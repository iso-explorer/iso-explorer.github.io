post_cb({"bq_ids": {"n4140": {"so_26422189_26422189_0": {"length": 14, "quality": 0.875, "section_id": 3252}, "so_26422189_26422452_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 235}, "so_26422189_26422189_1": {"length": 41, "quality": 0.7884615384615384, "section_id": 3256}, "so_26422189_26422189_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 3260}, "so_26422189_26422452_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 233}, "so_26422189_26422315_0": {"length": 61, "quality": 0.953125, "section_id": 245}}, "n3337": {"so_26422189_26422189_0": {"length": 14, "quality": 0.875, "section_id": 3124}, "so_26422189_26422452_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 228}, "so_26422189_26422189_1": {"length": 47, "quality": 0.9038461538461539, "section_id": 3128}, "so_26422189_26422189_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 3132}, "so_26422189_26422452_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 226}, "so_26422189_26422315_0": {"length": 46, "quality": 0.71875, "section_id": 237}}, "n4659": {"so_26422189_26422189_0": {"length": 14, "quality": 0.875, "section_id": 4010}, "so_26422189_26422452_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 245}, "so_26422189_26422189_1": {"length": 41, "quality": 0.7884615384615384, "section_id": 4014}, "so_26422189_26422189_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4018}, "so_26422189_26422452_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 243}, "so_26422189_26422315_0": {"length": 60, "quality": 0.9375, "section_id": 252}}}, "26422452": {"Id": "26422452", "PostTypeId": "2", "Body": "<p>C++11, 14.7.1/3:</p>\n<blockquote>\n<p id=\"so_26422189_26422452_0\">... Unless a call is to a function template explicit specialization or to a\n  member function of an explicitly specialized class template, <strong>a default argument for</strong> a function template or <strong>a\n  member function of a class template</strong> is implicitly instantiated when the function is called in a context that\n  <strong>requires the value of the default argument.</strong></p>\n</blockquote>\n<p>(Emphasis mine).</p>\n<p>Combine this with 14.7.1/1:</p>\n<blockquote>\n<p id=\"so_26422189_26422452_1\">... The <strong>implicit instantiation of a class template specialization</strong> causes the implicit\n  instantiation of the declarations, but <strong>not of</strong> the definitions or <strong>default arguments</strong>, of the class member functions, ...</p>\n</blockquote>\n<p>(Emphasis mine again)</p>\n<p>I would say that from the above, it follows that when called so that the default argument value is not required, it is <em>not</em> instantiated.</p>\n", "LastActivityDate": "2014-10-17T09:54:47.833", "CommentCount": "2", "CreationDate": "2014-10-17T09:54:47.833", "ParentId": "26422189", "Score": "8", "OwnerUserId": "1782465"}, "26422189": {"ViewCount": "322", "Body": "<p>Consider the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct Foo\n{\n    Foo (T v = {}) : var (v) {}\n    T var;\n};\n\nint main()\n{\n    // Foo&lt;int&amp;&gt; f;  // cannot compile\n\n   int x = 42;\n   Foo&lt;int&amp;&gt; f(x);\n   std::cout &lt;&lt; f.var;\n}\n</code></pre>\n<p>It builds and runs successfully in GCC 4.8, but is it <em>strictly</em> legal?<br>\n<code>T v = {}</code> is invalid for <code>T=int&amp;</code>, but this default argument is not used.</br></p>\n<hr>\n<p>The only pertinent language I can find in the standard does not seem to explicitly explain whether or not this program is valid; none of the following really seems completely relevant, despite touching on the subject in various ways:</p>\n<blockquote>\n<p id=\"so_26422189_26422189_0\"><code>[C++11: 8.3.6/1]:</code> If an initializer-clause is specified in a parameter-declaration this initializer-clause is used as a default argument. <strong>Default arguments will be used in calls where trailing arguments are missing.</strong></p>\n<p id=\"so_26422189_26422189_1\"><code>[C++11: 8.3.6/5]:</code> <strong>A default argument is implicitly converted (Clause 4) to the parameter type</strong>. The default argument has the same semantic constraints as the initializer in a declaration of a variable of the parameter type, using the copy-initialization semantics (8.5). <strong>The names in the default argument are bound, and the semantic constraints are checked, at the point where the default argument appears.</strong> Name lookup and checking of semantic constraints for default arguments in function templates and in member functions of class templates are performed as described in 14.7.1. <em>[..]</em></p>\n<p id=\"so_26422189_26422189_2\"><code>[C++11: 8.3.6/9]:</code> <strong>Default arguments are evaluated each time the function is called.</strong> <em>[..]</em></p>\n</blockquote>\n</hr>", "AcceptedAnswerId": "26422315", "Title": "Is a program, that doesn't use a default argument that would fail to bind to a reference parameter, legal?", "CreationDate": "2014-10-17T09:40:05.220", "Id": "26422189", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-10-17T11:51:30.213", "Score": "7", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "26422315": {"Id": "26422315", "PostTypeId": "2", "Body": "<p>See 14.7.1 Implicit instantiation[temp.inst]/13:</p>\n<blockquote>\n<p id=\"so_26422189_26422315_0\">If a function template f is called in a way that requires a default\n  argument to be used, the dependent names are looked up, the semantics\n  constraints are checked, and the instantiation of any template used in\n  the default argument is done as if the default argument had been an\n  initializer used in a function template specialization with the same\n  scope, the same template parameters and the same access as that of the\n  function template f used at that point, except that the scope in which\n  a closure type is declared (5.1.2) \u2013 and therefore its associated\n  namespaces \u2013 remain as determined from the context of the definition\n  for the default argument. This analysis is called default argument\n  instantiation. The instantiated default argument is then used as the\n  argument of f.</p>\n</blockquote>\n<p>The example below it also shows a case where the default argument is ill-formed\nif instantiated:</p>\n<pre><code>template&lt;class T&gt; void f(T x, T y = ydef(T()), T z = zdef(T()));\nclass\nA { };\nA zdef(A);\nvoid g(A a, A b, A c) {\n    f(a, b, c); // no default argument instantiation\n    f(a, b); // default argument z = zdef(T()) instantiated\n    f(a); // ill-formed; ydef is not declared\n}\n</code></pre>\n<p>There is no ydef, so the calls that use it are ill-formed, but the calls that don't use it are ok.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-17T11:51:30.213", "Score": "12", "CreationDate": "2014-10-17T09:47:14.413", "ParentId": "26422189", "CommentCount": "2", "OwnerUserId": "1315421", "LastEditDate": "2014-10-17T11:51:30.213"}});