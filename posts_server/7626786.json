post_cb({"7626786": {"CreationDate": "2011-10-02T13:59:57.143", "ViewCount": "163", "Id": "7626786", "Score": "0", "Title": "Deleting a pointer", "LastEditorUserId": "596068", "CommentCount": "0", "Body": "<p>In C++, whats the recommended way of deleting a pointer? For example, in the following case, do I need all three lines to delete the pointer safely (and if so, what do they do)?</p>\n<pre><code>// Create\nMyClass* myObject;\nmyObject = new MyClass(myVarA, myVarB, myVarC);\n\n// Use\n// ...\n\n// Delete\nif(myObject) { \n    delete myObject; \n    myObject = NULL; \n}\n</code></pre>\n", "Tags": "<c++><pointers>", "LastEditDate": "2011-10-02T14:02:25.300", "LastActivityDate": "2011-10-02T14:12:24.103", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "795016"}, "7626804": {"CommentCount": "0", "Body": "<p>No, you don't need that.</p>\n<p>Just write <code>delete p</code>, and be sure to not accept advice about anything else from anyone advocating that you do more.</p>\n<p>General advice: avoid raw <code>new</code> and <code>delete</code>. Let some standard container deal with allocation, copying and deallocation. Or use a smart-pointer.</p>\n<p>Cheers &amp; hth.,</p>\n", "CreationDate": "2011-10-02T14:02:27.703", "ParentId": "7626786", "Id": "7626804", "LastActivityDate": "2011-10-02T14:02:27.703", "PostTypeId": "2", "Score": "4", "OwnerUserId": "464581"}, "7626829": {"CommentCount": "2", "Body": "<p>Best to use a resource-managing class and let the library take care of that for you:</p>\n<pre><code>#include &lt;memory&gt;\n\n\nvoid foo()  // unique pointer\n{\n  std::unique_ptr&lt;MyClass&gt; myObject(new Myclass(myVarA, myVarB, myVarC));\n  // ...\n}  // all clean\n\nvoid goo()  // shared pointer -- feel free to pass it around\n{\n  auto myObject = std::make_shared&lt;MyClass&gt;(myVarA, myVarB, myVarC);\n  // ...\n}  // all clean\n\nvoid hoo()  // manual -- you better know what you're doing!\n{\n  MyClass * myObject = new MyClass(myVarA, myVarB, myVarC);\n  // ...\n  delete myObject;  // hope there wasn't an exception!\n}\n</code></pre>\n", "CreationDate": "2011-10-02T14:06:53.220", "ParentId": "7626786", "Id": "7626829", "LastActivityDate": "2011-10-02T14:06:53.220", "PostTypeId": "2", "Score": "3", "OwnerUserId": "596781"}, "7626859": {"CommentCount": "3", "Body": "<p>Just to add that setting the pointer to NULL after it's been <code>delete</code>'d is a good idea so you don't leave any dangling pointers around since attempts to dereference a NULL pointer is likely to crash your application straight away (and so be relatively easy to debug), whereas dereferencing a dangling pointer will most likely crash your application at some random point and be much more difficult to track down and fix.</p>\n", "CreationDate": "2011-10-02T14:12:24.103", "ParentId": "7626786", "Id": "7626859", "LastActivityDate": "2011-10-02T14:12:24.103", "PostTypeId": "2", "Score": "2", "OwnerUserId": "230833"}, "7626796": {"LastActivityDate": "2011-10-02T14:07:27.373", "CreationDate": "2011-10-02T14:01:15.957", "CommentCount": "2", "Body": "<p>No you do not need to check for <code>NULL</code>.<br>\n<code>delete</code> takes care if the pointer being passed is <code>NULL</code>.</br></p>\n<pre><code>delete myObject; \nmyObject = NULL; \n</code></pre>\n<p>is sufficient.</p>\n<p>As a general policy, avoid using freestore allocations wherever you can, and if you must use <strong>Smart Pointers(<a href=\"https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii\">RAII</a>)</strong> instead of raw pointers.</p>\n<hr>\n<p><strong>C++03 Standard Section \u00a73.7.3.2.3:</strong></p>\n<blockquote>\n<p id=\"so_7626786_7626796_0\"><strong>The value of the first argument supplied to one of the deallocation functions provided in the standard library may be a null pointer value; if so, the call to the deallocation function has no effect</strong>. Otherwise, the value supplied to operator delete(void*) in the standard library shall be one of the values returned by a previous invocation of either operator new(size_t) or operator new(size_t, const std::nothrow_t&amp;) in the standard library, and the value supplied to operator delete in the standard library shall be one of the values returned by a previous invocation of either operator new or operator new[](size_t, const std::nothrow_t&amp;) in the standard library.</p>\n</blockquote>\n</hr>", "Id": "7626796", "LastEditDate": "2017-05-23T09:59:38.323", "ParentId": "7626786", "OwnerUserId": "452307", "PostTypeId": "2", "Score": "6", "LastEditorUserId": "-1"}, "bq_ids": {"n4140": {"so_7626786_7626796_0": {"length": 44, "quality": 0.8, "section_id": 7182}}, "n3337": {"so_7626786_7626796_0": {"length": 44, "quality": 0.8, "section_id": 6926}}}});