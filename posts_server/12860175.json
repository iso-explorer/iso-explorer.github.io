post_cb({"12860175": {"ViewCount": "877", "Body": "<p>Why does the following code not work when compiling with:</p>\n<pre>\n$ g++ temp_main.cpp temp_spec.cpp\n/tmp/ccirjc3Y.o:temp_spec.cpp:(.text+0x100): multiple definition of `my::say()'\n/tmp/ccSo7IVO.o:temp_main.cpp:(.text$_ZN2myILi0EE3sayEv[my::say()]+0x0):\nfirst defined here collect2: ld returned 1 exit status\n</pre>\n<p>I'm trying to have specialization of static function only when using\nparamteter 0.</p>\n<p><strong>temp_gen.h:</strong></p>\n<pre><code>#ifndef temp_gen_h\n#define temp_gen_h\n\n#include &lt;iostream&gt;\n\ntemplate&lt;int N&gt;\nstruct my\n{\n   static void say();\n};\n\ntemplate&lt;int N&gt;\nvoid my&lt;N&gt;::say()\n{\n   std::cout &lt;&lt; \"generic \" &lt;&lt; N &lt;&lt; std::endl;\n}\n\n#endif\n</code></pre>\n<p><strong>temp_spec.h:</strong></p>\n<pre><code>#ifndef temp_spec_h\n#define temp_spec_h\n\n#include &lt;iostream&gt;\n\n#include \"temp_gen.h\"\n\ntemplate&lt;&gt;\nvoid my&lt;0&gt;::say()\n{\n   std::cout &lt;&lt; \"specialized \" &lt;&lt; 0 &lt;&lt; std::endl;\n}\n\n#endif\n</code></pre>\n<p><strong>temp_spec.cpp:</strong></p>\n<pre><code>#include \"temp_spec.h\"\n</code></pre>\n<p><strong>temp_main.cpp:</strong></p>\n<pre><code>#include \"temp_gen.h\"\n\nint main(int argc, char* argv[])\n{\n   my&lt;0&gt;::say();  //should say \"specialized 0\"\n   my&lt;1&gt;::say();  //should say \"generic 0\"\n}\n</code></pre>\n", "AcceptedAnswerId": "12860341", "Title": "Template specialization for static function when compiling with g++", "CreationDate": "2012-10-12T13:30:37.847", "Id": "12860175", "CommentCount": "0", "LastEditDate": "2012-10-12T13:50:44.030", "PostTypeId": "1", "LastEditorUserId": "592323", "LastActivityDate": "2012-10-12T17:32:13.060", "Score": "3", "OwnerUserId": "159589", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "3"}, "12864290": {"Id": "12864290", "PostTypeId": "2", "Body": "<p>Using the n3337 version of the Standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_12860175_12864290_0\"><strong>14.7.3 Explicit specialization [temp.expl.spec]</strong></p>\n<p id=\"so_12860175_12864290_1\"><strong>6/</strong> If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, <strong>in every translation unit</strong> in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>Because in <code>main</code> the specialization of <code>my&lt;0&gt;::say</code> is not visible, implicit instantiation occurs and you end up in the case above: <em>no diagnostic required</em> (from the compiler).</p>\n<p>Note that a specialization may only be declared after its generic counterpart has been declared.</p>\n", "LastActivityDate": "2012-10-12T17:32:13.060", "Score": "1", "CreationDate": "2012-10-12T17:32:13.060", "ParentId": "12860175", "CommentCount": "0", "OwnerUserId": "147192"}, "bq_ids": {"n4140": {"so_12860175_12864290_1": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_12860175_12864290_1": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_12860175_12864290_1": {"length": 29, "quality": 1.0, "section_id": 275}}}, "12860341": {"Id": "12860341", "PostTypeId": "2", "Body": "<p>From within your <code>main.cpp</code>, you did not specialize the template class, this is because you don't include the <code>temp_spec.h</code>.</p>\n<p>As Vaughn Cato pointed out (see comments), you should move the <em>definition</em> of the specialized method (which is no template method anymore), to <code>temp_spec.cpp</code>.</p>\n<p>I think (but I'm not an expert at this) you should always <strong>put specialization directly below the generic template</strong> (in the same header file), because whenever you include this, you also want the specialized ones to be defined, otherwise you will be confused when such errors happen. You can, however, just include the <code>temp_spec.h</code> at the bottom of <code>temp_gen.h</code>.</p>\n<p><del>Also, you don't need the .cpp files for the template headers, as there will never be any code to be compiled separately (template classes are always compiled at the other .cpp file which uses it, and I think duplicates will be removed when linking, causing <strong>trouble at link time</strong> again when in one case you <em>did not</em> specialize it, one time you <em>did</em>)</del> [This paragraph only applies to the generic template class, not to (fully) specialized classes, as they <em>require</em> some code in their own compilation unit, see comments and the edit above.]</p>\n", "LastEditorUserId": "592323", "LastActivityDate": "2012-10-12T13:59:57.233", "Score": "2", "CreationDate": "2012-10-12T13:39:40.313", "ParentId": "12860175", "CommentCount": "13", "LastEditDate": "2012-10-12T13:59:57.233", "OwnerUserId": "592323"}, "12860239": {"Id": "12860239", "PostTypeId": "2", "Body": "<p>I believe that since your template specialization's implementation is in the header you'll need to mark it <code>inline</code> so the compiler/linker know you're allowed to violate the one definition rule.</p>\n", "LastActivityDate": "2012-10-12T13:33:14.350", "Score": "2", "CreationDate": "2012-10-12T13:33:14.350", "ParentId": "12860175", "CommentCount": "3", "OwnerUserId": "251738"}});