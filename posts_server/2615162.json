post_cb({"2615199": {"Id": "2615199", "PostTypeId": "2", "Body": "<p>Normally a temporary object (such as one returned by a function call) has a lifetime that extends to the end of the \"enclosing expression\".  However, a temporary bound to a reference generally has it's lifetime 'promoted' to the lifetime of the reference (which may or may not be the lifetime of the calling function), but there are a couple exceptions. This is covered by the standard in 12.2/5 \"Temporary objects\":</p>\n<blockquote>\n<p id=\"so_2615162_2615199_0\">The temporary to which the reference is bound or the temporary that is the complete object to a subobject of which the temporary is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits. A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n<p>See the following for more information:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/2604206/c-constant-reference-lifetime/2604269#2604269\">C++ constant reference lifetime (container adaptor)</a></li>\n<li><a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow noreferrer\">GotW #88: A Candidate For the \"Most Important const\"</a> </li>\n</ul>\n<p>An example that might help visualize what's going on:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass foo {\npublic:\n    foo( std::string const&amp; n) : name(n) { \n        std::cout &lt;&lt; \"foo ctor - \" &lt;&lt; name + \" created\\n\"; \n    };\n    foo( foo const&amp; other) : name( other.name + \" copy\") { \n        std::cout &lt;&lt; \"foo copy ctor - \" &lt;&lt; name + \" created\\n\";\n    };\n\n    ~foo() { \n        std::cout &lt;&lt; name + \" destroyed\\n\"; \n    };\n\n    std::string getname() const { return name; };\n    foo getcopy() const { return foo( *this); };\n\nprivate:\n    std::string name;\n};\n\nstd::ostream&amp; operator&lt;&lt;( std::ostream&amp; strm, foo const&amp; f) {\n    strm &lt;&lt; f.getname();\n    return strm;\n}\n\n\nint main()\n{\n    foo x( \"x\");\n\n    std::cout &lt;&lt; x.getcopy() &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"note that the temp has already been destroyed\\n\\n\\n\";\n\n    foo const&amp; ref( x.getcopy());\n\n    std::cout &lt;&lt; ref &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"the temp won't be deleted until after this...\\n\\n\";\n    std::cout &lt;&lt; \"note that the temp has *not* been destroyed yet...\\n\\n\";\n}\n</code></pre>\n<p>Which displays:</p>\n<pre><code>foo ctor - x created\nfoo copy ctor - x copy created\nx copy\nx copy destroyed\nnote that the temp has already been destroyed\n\n\nfoo copy ctor - x copy created\nx copy\nthe temp won't be deleted until after this...\n\nnote that the temp has *not* been destroyed yet...\n\nx copy destroyed\nx destroyed\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-04-10T22:39:17.183", "Score": "8", "CreationDate": "2010-04-10T22:14:33.797", "ParentId": "2615162", "CommentCount": "0", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T11:53:16.803"}, "2615183": {"Id": "2615183", "PostTypeId": "2", "Body": "<p>Usually, if you return an object by value from a function, the said object will be destroyed when the assignment expression is finished:</p>\n<pre><code>myclass X = getX(); // after copy constructor, the returned value is destroyed\n                    // (but you still hold a copy in X)\n</code></pre>\n<p>In the case you describe, the returned value will be destroyed later on, allowing you to use it:</p>\n<pre><code>const myclass&amp; X = getX();\ncout &lt;&lt; X.a &lt;&lt; endl; // still can access the returned value, it's not destroyed\n</code></pre>\n", "LastActivityDate": "2010-04-10T22:06:02.860", "CommentCount": "0", "CreationDate": "2010-04-10T22:06:02.860", "ParentId": "2615162", "Score": "1", "OwnerUserId": "276994"}, "2615162": {"ViewCount": "2139", "Body": "<p>\"If you return a value (not a reference) from the function, then bind it to a const reference in the calling function, its lifetime would be extended to the scope of the calling function.\"</p>\n<p>So: CASE A</p>\n<pre><code>const BoundingBox Player::GetBoundingBox(void)\n{\n    return BoundingBox( &amp;GetBoundingSphere() );\n}\n</code></pre>\n<p>Returns a value of type const BoundingBox from function GetBoundingBox()</p>\n<p>Called function: (From within function Update() the following is called:)\nvariant I: (Bind it to a const reference)</p>\n<pre><code>const BoundingBox&amp; l_Bbox = l_pPlayer-&gt;GetBoundingBox();\n</code></pre>\n<p>variant II: (Bind it to a const copy)</p>\n<pre><code>const BoundingBox l_Bbox = l_pPlayer-&gt;GetBoundingBox();\n</code></pre>\n<p>Both work fine and I don't see the l_Bbox object going out of scope. (Though, I understand in variant one, the copy constructor is not called and thus is slightly better than variant II).</p>\n<p>Also, for comparison, I made the following changes.</p>\n<p>CASE B</p>\n<pre><code>BoundingBox Player::GetBoundingBox(void)\n{\n    return BoundingBox( &amp;GetBoundingSphere() );\n}\n</code></pre>\n<p>with Variants:\nI</p>\n<pre><code>BoundingBox&amp; l_Bbox = l_pPlayer-&gt;GetBoundingBox();\n</code></pre>\n<p>and II:</p>\n<pre><code>BoundingBox l_Bbox = l_pPlayer-&gt;GetBoundingBox();\n</code></pre>\n<hr>\n<p>The objet l_Bbox still does not out scope. So, I don't see how \"bind it to a const reference in the calling function, its lifetime would be extended to the scope of the calling function\", really extends the lifetime of the object to the scope of the calling function ?</p>\n<p>Am I missing something trivial here..please explain ..</p>\n<p>Thanks a lot</p>\n</hr>", "AcceptedAnswerId": "2615199", "Title": "return value (not a reference) from the function, bound to a const reference in the calling function; how is its lifetime extended to the scope of the calling function?", "CreationDate": "2010-04-10T21:58:04.717", "Id": "2615162", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-04-10T22:15:46.140", "LastEditorUserId": "280924", "LastActivityDate": "2010-04-10T23:47:48.737", "Score": "8", "OwnerUserId": "280924", "Tags": "<c++><memory><const><pass-by-reference>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_2615162_2615199_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 382}}, "n3337": {"so_2615162_2615199_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 373}}, "n4659": {"so_2615162_2615199_0": {"length": 24, "quality": 0.5853658536585366, "section_id": 397}}}, "2615181": {"Id": "2615181", "PostTypeId": "2", "Body": "<p>The point is that when returning by value, the value is <strong>copied</strong> into the variable you are assigning the result of the function. (just like you said - the <em>copy constructor</em> is called). No lifetime extension, you just create a brand-new object.</p>\n<p>When returning by reference, under the hood you just pass the pointer to the variable defined in the function. So, a new object is not created, you just have reference to it outside the function. With that case the lifetime of an function-inside variable is extended.</p>\n", "LastEditorUserId": "193256", "LastActivityDate": "2010-04-10T22:10:50.550", "Score": "2", "CreationDate": "2010-04-10T22:04:45.783", "ParentId": "2615162", "CommentCount": "0", "OwnerUserId": "193256", "LastEditDate": "2010-04-10T22:10:50.550"}, "2615230": {"Id": "2615230", "PostTypeId": "2", "Body": "<p>Firstly, the lifetime of temporary object gets extended to the lifetime of const reference that's bound to it, not \"to the scope of the calling function\" (although maybe that what you meant by that strange wording \"the scope of the calling function\"). This is what your <code>CASE A</code> illustrates, where you attach a <em>const</em> reference to a temporary. The temporary continues to live as long as the reference lives. When the reference ends its lifetime, the temporary object gets destroyed as well.</p>\n<p>Secondly, your <code>CASE B</code> is simply ill-formed, non-compilable. Namely, the </p>\n<pre><code>BoundingBox&amp; l_Bbox = l_pPlayer-&gt;GetBoundingBox(); \n</code></pre>\n<p>is illegal. It is illegal in C++ to attach a non-const reference to a temporary. If your compiler allows it, it must be a quirk/extension of your compiler, which has little to do with C++ language.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-04-10T23:47:48.737", "Score": "4", "CreationDate": "2010-04-10T22:22:44.823", "ParentId": "2615162", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2010-04-10T23:47:48.737"}});