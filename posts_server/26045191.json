post_cb({"26045191": {"ViewCount": "56", "Body": "<p>I have following template:</p>\n<pre><code>template&lt;typename FirstParam&gt;\nstruct First\n{\n    template&lt;typename SecondParam&gt;\n    struct Second;\n};\n</code></pre>\n<p>Example specialization:</p>\n<pre><code>template&lt;typename T&gt; class D {};\n\ntemplate&lt;&gt;\ntemplate&lt;&gt;\nstruct First&lt;C1&gt;::Second&lt;C1::C2&gt;\n{\n    typedef D&lt;C1::C2&gt; type;\n};\n</code></pre>\n<p>This is case when both classes are specialized at the same time. But is there possible to specialize only second class?</p>\n<p>Something like:</p>\n<pre><code>template&lt;typename OuterParam&gt;\ntemplate&lt;&gt;\nstruct Outer&lt;OuterParam&gt;::Inner&lt;typename OuterParam::C2&gt;\n{\n    typedef E&lt;typename OuterParam::C2&gt; type;\n};\n</code></pre>\n<p>(Yes, I also need second param to be inner class of the first.)</p>\n", "AcceptedAnswerId": "26045277", "Title": "Specializing only nested template", "CreationDate": "2014-09-25T18:04:09.787", "Id": "26045191", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-09-25T18:22:13.797", "Score": "3", "OwnerUserId": "2076710", "Tags": "<c++><templates><template-specialization><typename><dependent-name>", "AnswerCount": "1"}, "26045277": {"Id": "26045277", "PostTypeId": "2", "Body": "<p>No. \u00a714.7.3 [temp.expl.spec]/p16, emphasis added:</p>\n<blockquote>\n<p id=\"so_26045191_26045277_0\">In an explicit specialization declaration for a member of a class\n  template or a member template that appears in namespace scope, the\n  member template and some of its enclosing class templates may remain\n  unspecialized, <strong>except that the declaration shall not explicitly\n  specialize a class member template if its enclosing class templates\n  are not explicitly specialized as well.</strong></p>\n</blockquote>\n<p>You can use a \"partial\" specialization and <code>std::is_same</code> instead:</p>\n<pre><code>template&lt;typename FirstParam&gt;\nstruct First\n{\n    template&lt;typename SecondParam, bool = std::is_same&lt;typename FirstParam::C2,\n                                                       SecondParam&gt;::value&gt;\n    struct Second;\n\n    template&lt;class T&gt;\n    struct Second&lt;T, true&gt; { \n    };\n};\n</code></pre>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-25T18:22:13.797", "Score": "4", "CreationDate": "2014-09-25T18:09:11.803", "ParentId": "26045191", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-09-25T18:22:13.797"}, "bq_ids": {"n4140": {"so_26045191_26045277_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_26045191_26045277_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_26045191_26045277_0": {"length": 35, "quality": 1.0, "section_id": 285}}}});