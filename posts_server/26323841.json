post_cb({"bq_ids": {"n4140": {"so_26323841_26323863_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 233}}, "n3337": {"so_26323841_26323863_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 226}}, "n4659": {"so_26323841_26323863_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 243}}}, "26323841": {"ViewCount": "79", "Body": "<p>I've inherited <code>std::list</code> to allow 'psuedo random access' with the <code>[]</code> operator.</p>\n<pre><code>#include &lt;list&gt;\ntemplate &lt;typename T&gt;\nclass rlist : public std::list&lt;T&gt; {\n    T&amp; operator[](int index){\n        typename std::list&lt;T&gt;::iterator iterator;\n        int pos;\n        for (iterator = this-&gt;begin(), pos = 0; iterator != this-&gt;end(); iterator++, pos++)\n            if (pos == index)\n                return *iterator;\n        return inexistent_element();\n    }\n\n    class inexistent_element {\n\n    };\n};\n</code></pre>\n<p><code>inexistent_element</code> does not yet inherit <code>T</code>, so this shouldn't compile. But it compiles. Also I'm pretty sure C++ shouldn't allow me to pass by non-const reference an object that was created inline.</p>\n<p>I'm using Code::Blocks IDE with MinGW gcc compiler. I'd like to know why this compiles.</p>\n", "Title": "Why does this compile without errors? (Returning a type that doesn't subclass the stated returned type)", "CreationDate": "2014-10-12T09:50:20.373", "LastActivityDate": "2014-10-12T12:06:31.580", "CommentCount": "7", "LastEditDate": "2014-10-12T12:06:31.580", "PostTypeId": "1", "LastEditorUserId": "149392", "Id": "26323841", "Score": "1", "OwnerUserId": "3150201", "Tags": "<c++><inheritance>", "AnswerCount": "2"}, "26323863": {"Id": "26323863", "PostTypeId": "2", "Body": "<p>The member function <code>operator[]</code> was never instantiated by you. How I know that? It's private.</p>\n<p>Note that instantiating a class does not automatically instantiate its member functions ([temp.inst]/1):</p>\n<blockquote>\n<p id=\"so_26323841_26323863_0\">The implicit instantiation of a class template specialization causes\n  the implicit instantiation of the declarations, but not of the\n  definitions or default arguments, of the class member functions,\n  member classes, scoped member enumerations, static data members and\n  member templates;</p>\n</blockquote>\n", "LastActivityDate": "2014-10-12T09:52:54.103", "CommentCount": "3", "CreationDate": "2014-10-12T09:52:54.103", "ParentId": "26323841", "Score": "5", "OwnerUserId": "3647361"}, "26324794": {"Id": "26324794", "PostTypeId": "2", "Body": "<p>Obviously, as others have pointed out, you've never actually instantiated the\n<code>operator[]</code>; the compiler is not required to diagnose the case where no legal\ninstantionations are possible, and different compilers are more or less\naggressive in this.  (MSC will diagnose almost nothing without an\ninstantiation; g++ will diagnose most cases where there can be no legal\ninstantiation.)</p>\n<p>But of course, there can be legal instantiations of your function.\n<code>inexisting_element</code> may not have a base class, but <code>T</code> could have a\nnon-explicit constructor taking an <code>inexisting_element</code> by const reference, so\nthe compiler cannot legally reject this code until it knows <code>T</code>; i.e. the\nfunction has been instantiated.</p>\n", "LastActivityDate": "2014-10-12T11:50:07.053", "CommentCount": "0", "CreationDate": "2014-10-12T11:50:07.053", "ParentId": "26323841", "Score": "0", "OwnerUserId": "649665"}});