post_cb({"bq_ids": {"n4140": {"so_33110423_33112433_0": {"length": 14, "quality": 1.0, "section_id": 26}, "so_33110423_33110548_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6147}, "so_33110423_33112433_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}, "so_33110423_33110548_0": {"length": 18, "quality": 0.9, "section_id": 6146}, "so_33110423_33110548_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 6088}}, "n3337": {"so_33110423_33110548_0": {"length": 18, "quality": 0.9, "section_id": 5909}, "so_33110423_33112433_0": {"length": 14, "quality": 1.0, "section_id": 23}, "so_33110423_33112433_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 29}, "so_33110423_33110548_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5911}, "so_33110423_33110548_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 5910}}, "n4659": {"so_33110423_33110548_0": {"length": 18, "quality": 0.9, "section_id": 7642}, "so_33110423_33112433_0": {"length": 14, "quality": 1.0, "section_id": 26}, "so_33110423_33112433_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}, "so_33110423_33110548_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 7644}, "so_33110423_33110548_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7643}}}, "33110548": {"Id": "33110548", "PostTypeId": "2", "Body": "<p>From [expr.shift]:</p>\n<blockquote>\n<p id=\"so_33110423_33110548_0\">The type of the result is that of the promoted left operand. The behavior is undefined if the right operand\n  is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>The result type of shifting a <code>bool</code> is always <code>int</code>, regardless of what's on the right hand side. We're never shifting by at least 32 or by a negative number, so we're ok there on all accounts. </p>\n<p>For the left-shifts (E1 &lt;&lt; E2):</p>\n<blockquote>\n<p id=\"so_33110423_33110548_1\">Otherwise, if E1 has a signed type and non-negative value, and E1\u00d72<sup>E2</sup> is representable\n  in the corresponding unsigned type of the result type, then that value, converted to the result type, is the\n  resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>1\u00d72<sup>31</sup> is representable by <code>unsigned int</code>, and that's the largest left-shift we're doing, so we're ok there on all accounts too.</p>\n<p>For the right-shifts (E1 &gt;&gt; E2):</p>\n<blockquote>\n<p id=\"so_33110423_33110548_2\">If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<p>E1 is never negative, so we're ok there too! No undefined or implementation-defined behavior anywhere.</p>\n", "LastActivityDate": "2015-10-13T18:58:30.560", "CommentCount": "0", "CreationDate": "2015-10-13T18:58:30.560", "ParentId": "33110423", "Score": "2", "OwnerUserId": "2069064"}, "33112433": {"Id": "33112433", "PostTypeId": "2", "Body": "<p>Following is mainly a complement to Barry's answer, that clearly explains the rules for left and right shifting.</p>\n<p>At least fo C++11, the integral promotion of a bool gives 0 for <code>false</code> and 1 for <code>true</code> : 4.5 Integral promotions [conv.prom] \u00a7 6</p>\n<blockquote>\n<p id=\"so_33110423_33112433_0\">A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true becoming one.</p>\n</blockquote>\n<p>So in original examples, <code>b</code>, <code>d</code>, <code>f</code> and <code>h</code> will all get a 0 value, <code>a</code> and <code>c</code> both get a <code>8</code> value: only perfectly defined behaviour until here.</p>\n<p>But <code>e</code> and <code>g</code> will receive the unsigned value <code>0x80000000</code>, so it would be fine if you affected it to an unsigned int variable, but you are using signed 32 bits integers. So you get an <em>integral conversion</em>: 4.7 Integral conversions [conv.integral] \u00a73</p>\n<blockquote>\n<p id=\"so_33110423_33112433_1\">If the destination type is signed, the value is unchanged if it can be represented in the destination type; otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>And unsigned 0x80000000 is not representable in a signed 64 bits integer so the result is <strong>implementation defined</strong> for <code>e</code> and <code>g</code>.</p>\n", "LastActivityDate": "2015-10-13T20:53:50.303", "CommentCount": "0", "CreationDate": "2015-10-13T20:53:50.303", "ParentId": "33110423", "Score": "0", "OwnerUserId": "3545273"}, "33110423": {"ViewCount": "673", "Body": "<p>I am trying to understand exaclty how integral promotion works with arithmetic shifts operators. Particularly, I would like to know, which values of <code>a, b, c, d, e, f, g, h</code> are exactly defined according to the C++14 standard, and which ones can depend on the platform/hardware/compiler (assuming that <code>sizeof(int) == 4</code>).</p>\n<pre><code>int a = true &lt;&lt; 3;\nint b = true &gt;&gt; 3;\n\nint c = true &lt;&lt; 3U;\nint d = true &gt;&gt; 3U;\n\nint e = true &lt;&lt; 31;\nint f = true &gt;&gt; 31;\n\nint g = true &lt;&lt; 31U;\nint h = true &gt;&gt; 31U;\n</code></pre>\n", "AcceptedAnswerId": "33110548", "Title": "Left shifts and right shifts on boolean", "CreationDate": "2015-10-13T18:51:09.570", "Id": "33110423", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-10-13T20:53:50.303", "Score": "3", "OwnerUserId": "882932", "Tags": "<c++><standards><c++14><bit-shift><integer-promotion>", "AnswerCount": "2"}});