post_cb({"8886892": {"CommentCount": "2", "Body": "<p>You could attempt to try:</p>\n<pre><code>template &lt; int ...Indices&gt;\nclass T1 \n{\n    static const int index_size = sizeof...(Indices);\n\n    template &lt;int _1, int _2&gt;\n    class T2;\n};\n\ntemplate &lt;int ...Indices&gt;\ntemplate &lt;int _1&gt;\nclass T1&lt;Indices...&gt;::T2&lt;_1, T1&lt;Indices...&gt;::index_size&gt; {};\n</code></pre>\n<p>and see if the compiler issue is with the actual <code>sizeof...</code> operator, or if it's with the way it's being used in the template declaration.</p>\n", "CreationDate": "2012-01-16T22:00:41.420", "ParentId": "8866881", "Id": "8886892", "LastActivityDate": "2012-01-16T22:00:41.420", "PostTypeId": "2", "Score": "0", "OwnerUserId": "649233"}, "bq_ids": {"n4140": {"so_8866881_10471851_0": {"length": 30, "quality": 0.6666666666666666, "section_id": 142}}, "n3337": {"so_8866881_10471851_0": {"length": 30, "quality": 0.6666666666666666, "section_id": 136}}}, "8866881": {"CreationDate": "2012-01-15T01:31:28.357", "ViewCount": "687", "Id": "8866881", "Score": "2", "Title": "Nested template specialization depending on enclosing template parameters", "LastEditorUserId": "636019", "CommentCount": "1", "Body": "<pre><code>template &lt; int ...Indices&gt;\n\nclass T1 {\n    template &lt;int _1, int _2&gt;\n    class T2;\n};\n\ntemplate &lt;int ...Indices&gt;\ntemplate &lt;int _1&gt;\nclass T1&lt;Indices...&gt;::T2&lt;_1, sizeof...(Indices)&gt; {};\n//^--error: non-type template argument depends on a template parameter of the partial specialization\n</code></pre>\n<p>compiles on gcc 4.5+ but neither on clang 3.1 nor icc, both complaining about the usage of <code>sizeof...(Indices)</code>.\nIs it just a not-yet implemented feature in the latter compilers or some special case?</p>\n<p>Thanks,</p>\n<p>Buote</p>\n", "Tags": "<c++><c++11><template-specialization><nested-class><variadic-templates>", "LastEditDate": "2012-01-16T21:45:42.330", "LastActivityDate": "2012-05-06T15:43:58.300", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1149934"}, "10471851": {"CommentCount": "0", "Body": "<p>The standard says in [temp.class.spec] paragraph 8 that </p>\n<blockquote>\n<p id=\"so_8866881_10471851_0\">Within the argument list of a class template partial specialization, the following restrictions apply:<br>\n  \u2014 A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple identifier. [ <em>Example:</em><pre>\n    template &lt;int I, int J&gt; struct A {};\n    template &lt;int I&gt; struct A&lt;I+5, I*2&gt; {};  // error<br>\n    template &lt;int I, int J&gt; struct B {};\n    template &lt;int I&gt; struct B&lt;I, I&gt; {};      // OK\n</br></pre>\u2014 <em>end example</em> ]</br></p>\n</blockquote>\n<p>The purpose of the rule is to disallow partial specializations based on non-trivial expressions like those in the example, and <code>sizeof...(Indices)</code> is <em>not</em> a simple identifier so maybe clang and ICC are right to reject it.  I'm not sure which compiler is right, to be honest.  I suggest reporting a bug to one of the compilers and if they say their implementation is correct report it to the others for interpreting it differently!</p>\n", "CreationDate": "2012-05-06T15:43:58.300", "ParentId": "8866881", "Id": "10471851", "LastActivityDate": "2012-05-06T15:43:58.300", "PostTypeId": "2", "Score": "1", "OwnerUserId": "981959"}});