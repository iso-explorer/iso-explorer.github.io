post_cb({"34810580": {"CommentCount": "1", "ViewCount": "372", "CreationDate": "2016-01-15T11:57:31.313", "LastActivityDate": "2016-01-15T13:34:55.110", "Title": "Does base class destructor prevent move constructor being generated", "PostTypeId": "1", "Id": "34810580", "Score": "0", "Body": "<p>I have a class where VS 2015 was not generating a move ctor and now VS 2015 Update 1 it is generating one, this is causing a binary compatibility issue, not sure which version is doing the right thing.</p>\n<pre><code>// MyLib\nstruct Shared\n{\n   virtual ~Shared(){}\n}\n\nstruct Callback : public Shared\n{\n    virtual void response() = 0;\n}\n\n// App\nstruct CallbackI : public Callback\n{\n   virtual void response(){}\n}\n</code></pre>\n<p>When I build MyLib with VS 2015 and App with VS 2015 update 1 linking App fails because a missing symbol referencing the move assignment operator for Callback base class.</p>\n<p>Seems to me that VS 2015 is not generating this operators and VS 2015 Update 1 it is, but which compiler version is right here?</p>\n", "Tags": "<c++><visual-studio-2015>", "OwnerUserId": "491807", "AnswerCount": "1"}, "34811315": {"ParentId": "34810580", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-01-15T12:40:25.350", "Score": "0", "LastEditorUserId": "1034255", "LastEditDate": "2016-01-15T13:34:55.110", "Id": "34811315", "OwnerUserId": "1034255", "Body": "<p>VS 2015 Update 1 is doing the right thing (and actually the first VS version that implements all of C++11)</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_34810580_34811315_0\"><strong>\u00a712.8 Copying and moving class objects</strong></p>\n<p id=\"so_34810580_34811315_1\">If the definition of a class X does not explicitly declare a move\n  constructor, one will be implicitly declared as defaulted if and only\n  if</p>\n<ul>\n<li>X does not have a user-declared copy constructor,</li>\n<li>X does not have a user-declared copy assignment operator,</li>\n<li>X does not have a user-declared move assignment operator,</li>\n<li>X does not have a user-declared destructor, and</li>\n<li>the move constructor would not be implicitly defined as deleted.</li>\n</ul>\n</blockquote>\n<p>The user-generated destructor in <code>Shared</code> implicitly marks the move constructor as deleted. When you let the compiler generate it, the compiler can also generate the move assignment operator.</p>\n<pre><code>struct Shared\n{\n   virtual ~Shared() = default;\n}\n</code></pre>\n<p>For performance reasons, it's also better to declare empty virtual destructors this way because it guarantees inlining by the compiler.</p>\n", "LastActivityDate": "2016-01-15T13:34:55.110"}, "bq_ids": {"n4140": {"so_34810580_34811315_1": {"section_id": 458, "quality": 1.0, "length": 12}}, "n3337": {"so_34810580_34811315_1": {"section_id": 449, "quality": 1.0, "length": 12}}, "n4659": {"so_34810580_34811315_1": {"section_id": 481, "quality": 1.0, "length": 12}}}});