post_cb({"3502531": {"ParentId": "3498444", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-08-17T12:48:45.853", "Score": "1", "LastEditorUserId": "4850040", "LastEditDate": "2016-08-03T15:49:21.613", "Id": "3502531", "OwnerUserId": "356440", "Body": "<p><strong>Even if it worked it is awful code.</strong> </p>\n<p>In serious programming you code not only for yourself, but also for others who will maintain your code.\nPlaying tricks like this must be avoided, because you respect your colleagues.</p>\n<p>One consequence of this code: whether the pointer is <code>NULL</code> or not is even not at question, but it implies that this member <code>kType</code> may not be a plain non-static member of the class. Sometimes classes are big (this is evil too) and one cannot always recheck the definition of each and every variable.</p>\n<p>Be rigorous. And call all your static members only this way:</p>\n<pre><code>Foo::kType\n</code></pre>\n<p>Another possibility is to follow a coding convention that let know that the member is static, for example, a <code>s_</code> prefix for all classes static members:</p>\n<pre><code>Foo::s_kType\n</code></pre>\n", "LastActivityDate": "2016-08-03T15:49:21.613"}, "3498444": {"CommentCount": "1", "AcceptedAnswerId": "3498473", "ClosedDate": "2015-02-12T18:27:40.903", "CreationDate": "2010-08-17T00:24:34.390", "LastActivityDate": "2016-08-03T15:49:21.613", "PostTypeId": "1", "ViewCount": "1566", "FavoriteCount": "3", "Title": "C++ static const access through a NULL pointer", "Id": "3498444", "Score": "11", "Body": "<pre><code>class Foo {\npublic:\n static const int kType = 42;\n};\n\nvoid Func() {\n Foo *bar = NULL;\n int x = bar-&gt;kType;\n putc(x, stderr);\n}\n</code></pre>\n<p>Is this defined behavior? I read through the C++ standard but couldn't find anything about accessing a static const value like this... I've examined the assembly produced by GCC 4.2, Clang++, and Visual Studio 2010 and none of them perform a dereference of the NULL pointer, but I'd like to be sure.</p>\n", "Tags": "<c++><pointers><static>", "OwnerUserId": "422309", "AnswerCount": "5"}, "3498820": {"ParentId": "3498444", "CommentCount": "0", "CreationDate": "2010-08-17T02:05:28.017", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3498820", "Score": "1", "Body": "<p>Apart from the issue about accessing through the NULL pointer, there is another subtle issue in the code</p>\n<p>$9.4.2/2 - \"The declaration of a static data member in its class definition is not a definition and may be of an incomplete type other than cv-qualified void. The definition for a static data member shall appear in a namespace scope enclosing the member\u2019s class definition.\"</p>\n<p>$9.4.2/4- \"If a static data member is of const integral or const enumeration type, its declaration in the class definition can specify a constant-initializer which shall be an integral constant expression (5.19). In that case, the member can appear in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and the namespace scope definition shall not contain an initializer.\"</p>\n<pre><code>class Foo { \npublic: \n static const int kType = 42; \n}; \n\nint const Foo::kType;\n\nvoid Func() { \n Foo *bar = NULL; \n int x = bar-&gt;kType; \n putc(x, stderr); \n}\n</code></pre>\n<p>So, yet one more reason for UB in the OP code.</p>\n", "LastActivityDate": "2010-08-17T02:05:28.017"}, "3573025": {"ParentId": "3498444", "CommentCount": "1", "CreationDate": "2010-08-26T07:45:12.663", "OwnerUserId": "374835", "PostTypeId": "2", "Id": "3573025", "Score": "-1", "Body": "<p>There is a higher rule so to speak which basically says - don't even think about compiling things that are provably not used. Advanced template programming depends on this a lot, so even if it might be a bit gray-zonish when a compiler clearly sees that the result of a construct is not used it's just going to eliminate it. Especially when it's provably safe like in this case.</p>\n<p>You may want to try a few variants if you want - like making pointer a param of a function, result of a function, leaving a pointer uninitialized (best chance for triggering compiler complaint), doing a straight cast of 0 (best chance of being conplaint-free).</p>\n", "LastActivityDate": "2010-08-26T07:45:12.663"}, "3498459": {"ParentId": "3498444", "CommentCount": "4", "CreationDate": "2010-08-17T00:28:38.670", "OwnerUserId": "40175", "PostTypeId": "2", "Id": "3498459", "Score": "3", "Body": "<p>I believe that the actual value of the type is not used at all when calling</p>\n<pre><code>bar-&gt;kType\n</code></pre>\n<p>since <code>kType</code> is static, and bar is of type <code>Foo</code> it is the same as calling</p>\n<pre><code>Foo::kType\n</code></pre>\n<p>which you should really be doing anyway for clarity. </p>\n<p>Calling <code>bar-&gt;kType</code> gives a compiler warning on most platforms for this reason.</p>\n", "LastActivityDate": "2010-08-17T00:28:38.670"}, "bq_ids": {"n4140": {"so_3498444_3498473_0": {"section_id": 5900, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_3498444_3498473_0": {"section_id": 5672, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_3498444_3498473_0": {"section_id": 7382, "quality": 0.9333333333333333, "length": 28}}}, "3498473": {"ParentId": "3498444", "CommentCount": "7", "CreationDate": "2010-08-17T00:31:52.997", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "3498473", "Score": "11", "Body": "<p>You can use a pointer (or other expression) to access a static member; however, doing so through a NULL pointer unfortunately is officially undefined behavior. From 9.4/2 \"Static members\":</p>\n<blockquote>\n<p id=\"so_3498444_3498473_0\">A static member s of class X may be\n  referred to using the qualified-id\n  expression X::s; it is not necessary\n  to use the class member access syntax\n  (5.2.5) to refer to a static member. A\n  static member may be referred to using\n  the class member access syntax, <strong>in\n  which case the object-expression is\n  evaluated.</strong></p>\n</blockquote>\n<p>Based on the example that follows: </p>\n<pre><code>class process {\npublic:\n    static void reschedule();\n};\n\nprocess&amp; g();\n\nvoid f()\n{\n    process::reschedule();   // OK: no object necessary\n    g().reschedule();        // g() is called\n}\n</code></pre>\n<p>The intent is to allow you to ensure that functions will be called in this scenario.</p>\n", "LastActivityDate": "2010-08-17T00:31:52.997"}});