post_cb({"bq_ids": {"n4140": {"so_44626415_44720780_2": {"length": 33, "quality": 0.9166666666666666, "section_id": 6997}, "so_44626415_44720780_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6008}, "so_44626415_44720780_0": {"length": 7, "quality": 1.0, "section_id": 6991}}, "n3337": {"so_44626415_44720780_2": {"length": 33, "quality": 0.9166666666666666, "section_id": 6743}, "so_44626415_44720780_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5776}, "so_44626415_44720780_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6737}}, "n4659": {"so_44626415_44720780_2": {"length": 33, "quality": 0.9166666666666666, "section_id": 8495}, "so_44626415_44720780_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7507}, "so_44626415_44720780_0": {"length": 7, "quality": 1.0, "section_id": 8489}}}, "44720780": {"Id": "44720780", "PostTypeId": "2", "Body": "<p>There is implementation variance here; ICC accepts your code while gcc, clang and MSVC reject it. ICC is correct and the other compilers are incorrect.</p>\n<p>Running the <a href=\"http://eel.is/c++draft/class.member.lookup\" rel=\"nofollow noreferrer\"><strong>[class.member.lookup]</strong></a> algorithm for <code>D::a</code>, we find that:</p>\n<ul>\n<li>There is no declaration of <code>a</code> in <code>D</code>, so S(a, D) is initially empty and we merge in the lookup sets of <code>a</code> in its base classes, calculated as follows:\n\n<ul>\n<li>S(a, B) = { { A::a }, { B } }</li>\n<li>S(a, C) = { { A::a }, { C } }</li>\n</ul></li>\n<li>The resulting lookup set is S(a, D) = { { A::a }, { B, C } }</li>\n</ul>\n<p>Note that in the <em>declaration set</em> of S(a, B), the member is <code>A::a</code> even though it is found in <code>B</code>, and similarly for S(a, C):</p>\n<blockquote>\n<p id=\"so_44626415_44720780_0\">In the declaration set, <em>using-declarations</em> are replaced by the set of designated members [...]</p>\n</blockquote>\n<p>To determine whether the member access <code>d.a</code> is ambiguous, we now check <strong>[expr.ref]</strong>/5:</p>\n<blockquote>\n<p id=\"so_44626415_44720780_1\">5 - [The] program is ill-formed if the class of which <code>E2</code> is directly a member is an ambiguous base of the naming class of <code>E2</code> [...]</p>\n</blockquote>\n<p>Here <code>E2</code> has been determined to be <code>A::a</code>, a direct member of <code>A</code>. The naming class is <code>D</code>. <code>A</code> is not an ambiguous base of <code>D</code>, since <code>A</code> is a virtual base of all the intermediate base class subobjects of <code>D</code>. So <code>d.a</code> is unambiguous both in name lookup and in member access, and your program is correct.</p>\n<hr>\n<p>As an analogous instance, we can consider replacing virtual inheritance with a static member per the note to [class.member.lookup]/9:</p>\n<blockquote>\n<p id=\"so_44626415_44720780_2\">9 - <em>[\u2009Note:</em> A static member, a nested type or an enumerator defined in a base class <code>T</code> can unambiguously be found even if an object has more than one base class subobject of type <code>T</code>. Two base class subobjects share the non-static member subobjects of their common virtual base classes. <em>\u2014\u2009end note\u2009]</em></p>\n</blockquote>\n<pre><code>struct A { static int a; };                 \nstruct B : A { using A::a; };                 \nstruct C : A { using A::a; };                 \nstruct D : B, C { };                 \n\nint main() {\n    D d;\n    d.a = 0; // OK\n}\n</code></pre>\n<p>Here again we have S(a, D) = { { A::a }, { B, C } }. Indeed, name lookup proceeds the same way even if <code>A::a</code> were a non-static member of a non-virtual base; the <em>name lookup</em> is unambiguous but the <em>member access</em> <strong>[expr.ref]</strong> is ambiguous in that case.</p>\n<p>To further elucidate the distinction between name lookup and member access, consider that even for a non-static data member of a non-virtual multiply inherited base class, it is possible to unambiguously use the name of the member taking the derived class as the naming class:</p>\n<pre><code>struct A { int a; };\nstruct B : A { using A::a; };\nstruct C : A { using A::a; };\nstruct D : B, C { };\nint B::*p = &amp;D::i;      // OK, unambiguous\n</code></pre>\n<p>Unfortunately, <em>every</em> compiler I have tried rejects this despite this being (modulo using-declarations) <a href=\"http://eel.is/c++draft/class.member.lookup#12\" rel=\"nofollow noreferrer\">an example in the Standard</a>!</p>\n</hr>", "LastActivityDate": "2017-06-23T11:49:29.123", "Score": "1", "CreationDate": "2017-06-23T11:49:29.123", "ParentId": "44626415", "CommentCount": "5", "OwnerUserId": "567292"}, "44626415": {"ViewCount": "104", "Body": "<pre><code>class A                      { public: int a;       };                 \nclass B : public virtual A   { public: using A::a;  };                 \nclass C : public virtual A   { public: using A::a;  };                 \nclass D : public C, public B {                      };                 \n\nclass W                      { public: int w;       };                  \nclass X : public virtual W   { public: using W::w;  };                  \nclass Y : public virtual W   {                      };                  \nclass Z : public Y, public X {                      };\n\nint main(){\n\n    D d;\n    d.a = 0; // Error\n\n    Z z;                                                               \n    z.w = 0; // Correct\n\n    return 0;\n}        \n</code></pre>\n<p>The first group of class declarations (<code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>) and the second (<code>W</code>, <code>X</code>, <code>Y</code> and <code>Z</code>) are built similarly except that <code>class C</code> has a using declaration (<code>using A::a</code>) and <code>class Y</code> doesn't.</p>\n<p>When trying to access member <code>a</code> in <code>d.a = 0</code> I get an error in Clang (<code>error: member 'a' found in multiple base classes of different types</code>) and in GCC (<code>error: request for member 'a' is ambiguous</code>). I checked recent and old versions of both compilers and all of them agree. However, accessing <code>w</code> in <code>z.w = 0</code> compiles successfully. </p>\n<p>What is the reason of this ambiguity when accessing <code>a</code>?</p>\n<p>To the best of my knowledge, both access declarations in classes <code>B</code> and <code>C</code> refer to the same base class member. And by the way, if I remove them the test compiles successfully because <code>a</code> is already publicly accessible ( <code>public</code> access specifier ).</p>\n<p>Thanks in advance.</p>\n<p>Note: The above code is a slightly modified test from <a href=\"https://www.solidsands.nl/\" rel=\"nofollow noreferrer\">SolidSands</a>' SuperTest suite.</p>\n", "AcceptedAnswerId": "44720780", "Title": "Ambiguity in Member Name LookUp and Access Declarations in C++", "CreationDate": "2017-06-19T09:08:49.690", "Id": "44626415", "CommentCount": "10", "LastEditDate": "2017-06-23T09:08:27.077", "PostTypeId": "1", "LastEditorUserId": "7325235", "LastActivityDate": "2017-06-23T11:49:29.123", "Score": "1", "OwnerUserId": "7325235", "Tags": "<c++><c++11><c++14><member><c++03>", "AnswerCount": "1"}});