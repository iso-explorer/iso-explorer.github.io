post_cb({"bq_ids": {"n4140": {"so_31361868_31361934_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_31361868_31361934_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_31361868_31361934_0": {"length": 35, "quality": 1.0, "section_id": 285}}}, "31361934": {"Id": "31361934", "PostTypeId": "2", "Body": "<p>You cannot explicitly specialize a class member template of a non-specialized class template, from [temp.expl.spec]:</p>\n<blockquote>\n<p id=\"so_31361868_31361934_0\">In an explicit specialization declaration for a member of a class template or a member template that appears\n  in namespace scope, the member template and some of its enclosing class templates may remain\n  unspecialized, except that the declaration <strong>shall not explicitly specialize a class member template if its enclosing\n  class templates are not explicitly specialized as well</strong>.</p>\n</blockquote>\n<p>Even the explicit specialiation of <code>B</code> inside of the definition of <code>A</code> is ill-formed. If you need to do such a thing, I would simply not use a member class template for <code>B</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-11T21:33:46.567", "Score": "1", "CreationDate": "2015-07-11T21:16:11.957", "ParentId": "31361868", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-07-11T21:33:46.567"}, "31365740": {"Id": "31365740", "PostTypeId": "2", "Body": "<p>I found a way to hack the system. Use partial specialization instead of explicit specialization, with fake template parameter, like this: <a href=\"http://goo.gl/yHRQwV\" rel=\"nofollow\">http://goo.gl/yHRQwV</a></p>\n<pre><code>template &lt;typename T1&gt;\nclass A\n{\npublic:  \n  template &lt;bool T2, typename = void&gt;\n  class B;\n\n  template &lt;typename Dummy&gt;\n  class B&lt;true, Dummy&gt;\n  {\n    public:\n    void f1();\n  };\n\n  template &lt;typename Dummy&gt;\n  class B&lt;false, Dummy&gt;\n  {\n    public:\n    void f1();\n  };\n};\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;true, Dummy&gt;::f1()\n{  \n}\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;false, Dummy&gt;::f1()\n{  \n}\n\nint main()\n{\n    A&lt;int&gt;::B&lt;true&gt; b1;\n    b1.f1();\n\n    A&lt;int&gt;::B&lt;false&gt; b2;\n    b2.f1();\n}\n</code></pre>\n<p>Not sure this is legal, but it works.</p>\n<p>Actually, it does not solves my problem. In this case I can't add general methods f2(), f3() etc, to class B without specialization: <a href=\"http://goo.gl/wtIY0e\" rel=\"nofollow\">http://goo.gl/wtIY0e</a></p>\n<pre><code>template &lt;typename T1&gt;\nclass A\n{\npublic:  \n  template &lt;bool T2, typename = void&gt;\n  class B  \n  {\n    public:\n    void f2();\n    void f3();\n  };\n\n  template &lt;typename Dummy&gt;\n  class B&lt;true, Dummy&gt;\n  {\n    public:\n    void f1();\n  };\n\n  template &lt;typename Dummy&gt;\n  class B&lt;false, Dummy&gt;\n  {\n    public:\n    void f1();\n  };\n};\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;true, Dummy&gt;::f1()\n{  \n}\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;false, Dummy&gt;::f1()\n{  \n}\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;bool T2, typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;T2, Dummy&gt;::f2()\n{\n}\n\ntemplate &lt;typename T1&gt;\ntemplate &lt;bool T2, typename Dummy&gt;\nvoid A&lt;T1&gt;::B&lt;T2, Dummy&gt;::f3()\n{\n}\n\nint main()\n{\n    A&lt;int&gt;::B&lt;true&gt; b1;\n    b1.f1();\n    b1.f2(); // error: A&lt;int&gt;::B&lt;true&gt; has no member f2\n    b1.f3(); // error: A&lt;int&gt;::B&lt;true&gt; has no member f3\n    A&lt;int&gt;::B&lt;false&gt; b2;\n    b2.f1();\n    b2.f2(); // error: A&lt;int&gt;::B&lt;false&gt; has no member f2\n    b2.f3(); // error: A&lt;int&gt;::B&lt;false&gt; has no member f3\n}\n</code></pre>\n<p>Finally, I found a solution that was looking for the whole day: <strong>Static polymorphism</strong> <a href=\"http://goo.gl/7yGZxM\" rel=\"nofollow\">http://goo.gl/7yGZxM</a></p>\n<pre><code>template &lt;typename T1&gt;\nstruct A\n{\n  template&lt;typename T2&gt;\n  struct BaseB\n  {\n    void f1();\n    void f2();\n    void f3();\n  };\n\n  struct B_true : BaseB&lt;B_true&gt;\n  {\n    void f1_impl();\n  };\n\n  struct B_false : BaseB&lt;B_false&gt;\n  {\n    void f1_impl();\n  };\n};\n\ntemplate &lt;typename T1&gt;\ntemplate&lt;typename T2&gt;\nvoid A&lt;T1&gt;::BaseB&lt;T2&gt;::f1()\n{\n  static_cast&lt;T2*&gt;(this)-&gt;f1_impl();\n}\n\ntemplate &lt;typename T1&gt;\ntemplate&lt;typename T2&gt;\nvoid A&lt;T1&gt;::BaseB&lt;T2&gt;::f2()\n{\n\n}\n\ntemplate &lt;typename T1&gt;\ntemplate&lt;typename T2&gt;\nvoid A&lt;T1&gt;::BaseB&lt;T2&gt;::f3()\n{\n\n}\n\ntemplate &lt;typename T1&gt;\nvoid A&lt;T1&gt;::B_true::f1_impl()\n{\n\n}\n\ntemplate &lt;typename T1&gt;\nvoid A&lt;T1&gt;::B_false::f1_impl()\n{\n\n}\n\nint main()\n{\n  A&lt;char&gt;::B_true b_true;\n  b_true.f1();\n  b_true.f2();\n  b_true.f3();\n\n  A&lt;char&gt;::B_false b_false;\n  b_false.f1();\n  b_false.f2();\n  b_false.f3();\n}\n</code></pre>\n", "LastEditorUserId": "4529811", "LastActivityDate": "2015-07-12T08:52:41.233", "Score": "0", "CreationDate": "2015-07-12T08:07:49.990", "ParentId": "31361868", "CommentCount": "0", "OwnerUserId": "4529811", "LastEditDate": "2015-07-12T08:52:41.233"}, "31361868": {"ViewCount": "94", "Body": "<p>Is it possible to move method definition outside declaration? </p>\n<pre><code>template &lt;typename T1&gt;\nclass A\n{\n  template &lt;bool T2&gt;\n  class B;\n\n  template&lt;&gt;\n  class B&lt;true&gt;\n  {\n    void f() { /* Do smg */ }\n  }\n  class B&lt;false&gt;\n  {\n    void f() { /* Do smg else */ }\n  }\n}\n</code></pre>\n<p>If I try to define f() outside class declaration, like this</p>\n<pre><code>template &lt;typename T1&gt;\ntemplate &lt;&gt;\nvoid A&lt;T1&gt;::B&lt;true&gt;::f() { /* Do smg */ }\n</code></pre>\n<p>compiler gives error <strong>C3855: template parameter T2 is incompatible with the declaration.</strong></p>\n", "AcceptedAnswerId": "31361934", "Title": "Move method definition for template nested class outside declaration", "CreationDate": "2015-07-11T21:07:43.437", "Id": "31361868", "CommentCount": "3", "LastEditDate": "2015-07-11T21:30:34.767", "PostTypeId": "1", "LastEditorUserId": "3510736", "LastActivityDate": "2015-07-12T08:52:41.233", "Score": "2", "OwnerUserId": "4529811", "Tags": "<c++><visual-studio><templates><nested>", "AnswerCount": "2"}});