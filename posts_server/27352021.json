post_cb({"27352166": {"Id": "27352166", "PostTypeId": "2", "Body": "<p>Both examples are equivalent.<br>\nThough only if the type is copyable or movable (check it for yourself) and NRVO is actually done (any halfway decent compiler will do it as a matter of course).</br></p>\n<p>Though if you had many constructors and constructor-chaining were inappropriate, the first method would allow you not to repeat yourself.</p>\n<p>Also, you can use that method to define aggregates with defaults different from aggregate-initialization for (some) members since C++14.</p>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2014-12-08T19:18:57.203", "Score": "6", "CreationDate": "2014-12-08T05:51:30.933", "ParentId": "27352021", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2014-12-08T19:18:57.203"}, "bq_ids": {"n4140": {"so_27352021_27354688_5": {"length": 13, "quality": 0.7647058823529411, "section_id": 3294}, "so_27352021_27354688_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 434}, "so_27352021_27354688_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 435}, "so_27352021_27354688_2": {"length": 8, "quality": 1.0, "section_id": 435}}, "n3337": {"so_27352021_27354688_5": {"length": 13, "quality": 0.7647058823529411, "section_id": 3164}, "so_27352021_27354688_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 426}, "so_27352021_27354688_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 427}, "so_27352021_27354688_2": {"length": 8, "quality": 1.0, "section_id": 427}}, "n4659": {"so_27352021_27354688_5": {"length": 13, "quality": 0.7647058823529411, "section_id": 4056}, "so_27352021_27354688_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 452}, "so_27352021_27354688_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 454}, "so_27352021_27354688_2": {"length": 7, "quality": 0.875, "section_id": 454}}}, "27352021": {"ViewCount": "5577", "Body": "<p>What difference between these ways of initializing object member variables in C++11 ? Is there another way ?  which way is better (performance) ?:</p>\n<pre><code>class any {\n  public:\n    obj s = obj(\"value\");\n    any(){}\n};\n</code></pre>\n<p>Or </p>\n<pre><code>class any {\n  public:\n    obj s;\n    any(): s(\"value\"){}\n};\n</code></pre>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "27354688", "Title": "C++11 member initializer list vs in-class initializer?", "CreationDate": "2014-12-08T05:37:25.857", "Id": "27352021", "CommentCount": "3", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2014-12-08T10:27:55.950", "LastEditorUserId": "1708801", "LastActivityDate": "2015-06-27T20:34:06.610", "Score": "23", "OwnerUserId": "4336020", "Tags": "<c++><c++11><initialization>", "AnswerCount": "3"}, "27354688": {"Id": "27354688", "PostTypeId": "2", "Body": "<p>No, these are <strong>not the same</strong>.</p>\n<p>The difference between them is the same that applies for <em>direct-initialization</em> vs. <em>copy-initialization</em>, which is subtle but often very confusing.</p>\n<p>\u00a712.6.2 [class.base.init]:</p>\n<blockquote>\n<ol start=\"7\">\n<li><p id=\"so_27352021_27354688_0\">The <em>expression-list</em> or <em>braced-init-list</em> in a <em>mem-initializer</em> is used to initialize the designated subobject (or, in the case of a delegating constructor, the complete class object) according to the initialization rules of 8.5 for <strong>direct-initialization.</strong> [...]</p></li>\n<li><p id=\"so_27352021_27354688_1\">In a non-delegating constructor, if a given non-static data member or base class is not designated by a <em>mem-initializer-id</em> (including the case where there is no <em>mem-initializer-list</em> because the constructor has no <em>ctor-initializer</em>) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<p id=\"so_27352021_27354688_2\">\u2014 if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em>, the entity is initialized <strong>as specified in 8.5</strong>;</p></li>\n</ol>\n</blockquote>\n<p>\u00a78.5 [dcl.init]:</p>\n<blockquote>\n<ol start=\"15\">\n<li><p id=\"so_27352021_27354688_3\">The initialization that occurs in the form</p>\n<p id=\"so_27352021_27354688_4\">T x = a;</p></li>\n</ol>\n<p id=\"so_27352021_27354688_5\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) <strong>is called copy-initialization</strong>.</p>\n</blockquote>\n<p>Initializing a non-static data member on a <em>member-initializer-list</em> follows the rules of <em>direct-initialization</em>, which doesn't create intermediate temporaries that need to be moved/copied (if compiled without a <em>copy-elision</em>), neither the type of the data member must be copyable/movable (even if the copy is elided). In addition, a <em>direct-initialization</em> introduces an explicit context, while a <em>copy-initialization</em> is non-explicit (if a constructor selected for the initialization is <code>explicit</code>, the program won't compile).</p>\n<p>In other words, the <code>obj s = obj(\"value\");</code> syntax won't compile if <code>obj</code> is declared as:</p>\n<pre><code>struct obj\n{\n    obj(std::string) {}\n    obj(const obj&amp;) = delete;\n};\n</code></pre>\n<p>or:</p>\n<pre><code>struct obj\n{\n    obj(std::string) {}\n    explicit obj(const obj&amp;) {}\n};\n</code></pre>\n<p>As a more tangible example, while the below won't compile:</p>\n<pre><code>struct any\n{\n   std::atomic&lt;int&gt; a = std::atomic&lt;int&gt;(1); // ill-formed: non-copyable/non-movable\n   std::atomic&lt;int&gt; b = 2; // ill-formed: explicit constructor selected\n};\n</code></pre>\n<p>this one will:</p>\n<pre><code>struct any\n{\n    std::atomic&lt;int&gt; a;\n    std::atomic&lt;int&gt; b{ 2 };\n    any() : a(1) {}\n};\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27352021_27354688_6\"><em>Which way is better (performance) ?</em></p>\n</blockquote>\n<p>With a <em>copy-elision</em> enabled both have identical performance. With <em>copy-elision</em> disabled, there is an additional copy/move constructor call upon every instantiation when the <em>copy-initialization</em> syntax is used (that <code>obj s = obj(\"value\");</code> is one of).</p>\n<hr>\n<blockquote>\n<p id=\"so_27352021_27354688_7\"><em>Is there another way ?</em></p>\n</blockquote>\n<p>The <em>brace-or-equal-initializer</em> syntax allows one to perform a <em>direct-list-initialization</em> as well:</p>\n<pre><code>class any {\npublic:\n    obj s{ \"value\" };\n    any() {}\n};\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27352021_27354688_8\"><em>Are there any other differences?</em></p>\n</blockquote>\n<p>Some other differences that are worth mentioning are:</p>\n<ol>\n<li><em>Brace-or-equal-initializer</em> must reside in a header file along with a class declaration.</li>\n<li>If both are combined, <em>member-initializer-list</em> takes priority over <em>brace-or-equal-initializer</em> (that is, <em>brace-or-equal-initializer</em> is ignored).</li>\n<li>(C++11 only, until C++14) A class that uses <em>brace-or-equal-initializer</em> violates constraints for an aggregate type.</li>\n<li>With the <em>brace-or-equal-initializer</em> syntax it's not possible to perform a <em>direct-initialization</em> other than a <em>direct-list-initialization</em>.</li>\n</ol>\n</hr></hr></hr>", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-27T20:34:06.610", "Score": "27", "CreationDate": "2014-12-08T09:12:29.950", "ParentId": "27352021", "CommentCount": "8", "OwnerUserId": "3953764", "LastEditDate": "2015-06-27T20:34:06.610"}, "27352182": {"Id": "27352182", "PostTypeId": "2", "Body": "<p>They are the same. </p>\n<p>Neither is better than the other in terms of performance, and there is no other way to initialise them.</p>\n<p>The benefit of in-class initialisation (the first in your example) is that the order of initialisation is implicit. In initialiser list you have to explicitly state the order - and compilers will warn of out-of-order initialisation if you get the ordering incorrect.</p>\n<p>From the standard:</p>\n<pre><code>12.6.2.5\nnonstatic data members shall be initialized in the order they were declared \nin the class definition\n</code></pre>\n<p>If you get the order wrong in your list, GCC will complain:</p>\n<pre><code>main.cpp: In constructor 'C::C()':\nmain.cpp:51:9: warning: 'C::b' will be initialized after\nmain.cpp:51:6: warning:   'int C::a'\n</code></pre>\n<p>The benefit of initialiser lists is perhaps a matter of taste - the list is explicit, typically in the source file. In-class is implicit (arguably), and is typically in the header file. </p>\n", "LastActivityDate": "2014-12-08T05:52:29.323", "CommentCount": "2", "CreationDate": "2014-12-08T05:52:29.323", "ParentId": "27352021", "Score": "2", "OwnerUserId": "955273"}});