post_cb({"bq_ids": {"n4140": {"so_9057119_9057119_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 1766}, "so_9057119_9057119_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 1765}, "so_9057119_9057119_3": {"length": 5, "quality": 1.0, "section_id": 1765}, "so_9057119_9057119_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1569}, "so_9057119_9057119_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 1765}}, "n3337": {"so_9057119_9057119_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 1759}, "so_9057119_9057119_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 1759}, "so_9057119_9057119_3": {"length": 5, "quality": 1.0, "section_id": 1759}, "so_9057119_9057119_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1565}, "so_9057119_9057119_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 1760}}, "n4659": {"so_9057119_9057119_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 1935}, "so_9057119_9057119_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 2124}, "so_9057119_9057119_3": {"length": 5, "quality": 1.0, "section_id": 2124}, "so_9057119_9057119_1": {"length": 7, "quality": 1.0, "section_id": 1936}, "so_9057119_9057119_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 1936}}}, "9057160": {"Id": "9057160", "PostTypeId": "2", "Body": "<p>The wording of the spec does not require that <code>pos</code> be less than the length of the string.  If <code>pos</code> is greater than the length of the string, then the first part of condition (1) cannot be satisfied, because if <code>pos &lt;= xpos</code>, then <code>xpos + str.size() &lt;= size()</code> can never be true.  As a result, by clause (2), the function will return <code>npos</code>.  Consequently, if the index is out of range, the behavior of the function is still perfectly well-defined.</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2012-01-29T21:58:25.510", "Score": "6", "CreationDate": "2012-01-29T21:58:25.510", "ParentId": "9057119", "CommentCount": "0", "OwnerUserId": "501557"}, "9057119": {"ViewCount": "287", "Body": "<p>Just reading 21.3.6.1 basic_string::find - and there is no mention that the pos argument be within bounds of the string itself. </p>\n<blockquote>\n<p id=\"so_9057119_9057119_0\">21.3.6.1 basic_string::find</p>\n<p id=\"so_9057119_9057119_1\">size_type find(const basic_string&amp; str,\n  size_type pos = 0) const;</p>\n<p id=\"so_9057119_9057119_2\">1 Effects: Determines the lowest position xpos, if possible, such that\n  both of the following conditions obtain:</p>\n<p id=\"so_9057119_9057119_3\">\u2014 pos &lt;= xpos and xpos + str.size() &lt;= size();</p>\n<p id=\"so_9057119_9057119_4\">\u2014 at(xpos+I) == str.at(I) for all elements I of the string controlled\n  by str.</p>\n<p id=\"so_9057119_9057119_5\">2 Returns: xpos if the function can determine such a value for xpos.\n  Otherwise, returns npos.</p>\n</blockquote>\n<p>I am reading this correctly?</p>\n", "AcceptedAnswerId": "9057160", "Title": "Does std::string find require that pos be less than the string size?", "CreationDate": "2012-01-29T21:52:05.467", "Id": "9057119", "CommentCount": "2", "LastEditDate": "2013-10-23T01:02:27.310", "PostTypeId": "1", "LastEditorUserId": "501557", "LastActivityDate": "2013-10-23T01:02:27.310", "Score": "2", "OwnerUserId": "990524", "Tags": "<c++><string><stl><stdstring>", "AnswerCount": "1"}});