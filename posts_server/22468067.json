post_cb({"22468944": {"ParentId": "22468067", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-03-18T01:49:56.280", "Score": "0", "LastEditorUserId": "192512", "LastEditDate": "2014-03-18T01:55:27.707", "Id": "22468944", "OwnerUserId": "192512", "Body": "<p>It is because in <code>Woman</code>, Your assignment operator takes a <code>Woman</code>, not a <code>Person</code>, and it also isn't virtual. Virtual method dispatch doesn't work like you expect it to. It works only if method signatures match exactly.</p>\n", "LastActivityDate": "2014-03-18T01:55:27.707"}, "22468067": {"CommentCount": "6", "ViewCount": "348", "PostTypeId": "1", "LastEditorUserId": "1316509", "CreationDate": "2014-03-18T00:20:24.380", "LastActivityDate": "2014-03-18T02:05:22.950", "Title": "C++ Why should I suppress the default copy constructor?", "FavoriteCount": "1", "LastEditDate": "2014-03-18T01:12:13.690", "Id": "22468067", "Score": "3", "Body": "<p>From Bjarne Stroustrup's The C++ Programming Language 4th Edition:</p>\n<p>3.3.4. Suppressing Operations</p>\n<p>Using the default copy or move for a class in a hierarchy is typically a disaster:\ngiven only a pointer to a base, we simply don\u2019t know what members the derived\nclass has (\u00a73.2.2), so we can\u2019t know how to copy them. So, the best thing to\ndo is usually to delete the default copy and move operations, that is, to\neliminate the default definitions of those two operations:</p>\n<pre><code>class Shape {\n    public:\n        Shape(const Shape&amp;) =delete; // no copy operations\n        Shape&amp; operator=(const Shape&amp;) =delete;\n        Shape(Shape&amp;&amp;) =delete; // no move operations\n        Shape&amp; operator=(Shape&amp;&amp;) =delete;\n        ~Shape();\n        // ...\n};\n</code></pre>\n<p>To try to understand what he meant to say, I created the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person {\n    private:\n            int age;\n    public:\n            Person(const int&amp; Age) : age {Age} {};\n            Person(const Person&amp; from) : age {from.Age()} { cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; };\n            Person&amp; operator=(const Person&amp; from) { cout &lt;&lt; \"copy assignment\" &lt;&lt; endl; age = from.Age(); return *this; }\n            virtual void Print() { cout &lt;&lt; age &lt;&lt; endl; };\n            void Age(const int&amp; Age) { age = Age; };\n            int Age() const { return age; };\n};\n\nclass Woman : public Person {\n    private:\n            int hotness;\npublic:\n            Woman(const int&amp; Age, const int&amp; Hotness) : Person(Age), hotness {Hotness} {};\n            Woman(const Woman&amp; from) : Person(from), hotness {from.Hotness()} { cout &lt;&lt; \"copy constructor of woman\" &lt;&lt; endl; };\n            Woman&amp; operator=(const Woman&amp; from) { Person::operator=(from); cout &lt;&lt; \"copy assignment of woman\" &lt;&lt; endl; hotness = from.Hotness(); return *this; };\n            void Print() override { cout &lt;&lt; Age() &lt;&lt; \" and \" &lt;&lt; hotness &lt;&lt; endl; };\n            int Hotness() const { return hotness; };\n};\n\nint main() {\n    Woman w(24, 10);\n\n    Person p = w;\n    p.Print();\n\n    return 0;\n}\n</code></pre>\n<p>The output for this version of the program was:</p>\n<pre><code>copy constructor\n24\n</code></pre>\n<p>Which was a bit of a surprise for me, being a noob, but then a realized that since p is not a pointer, the virtual table is not used, and since it's a Person, Person::Print() got called. So I knew that the copy constructor for Person got called, but I couldn't know if the copy constructor for Woman got called, but that wouldn't really matter, since p is a Person, and through it I'd never have access to Woman::Hotness, not even if I tried a cast.</p>\n<p>So I thought he was probably just talking about pointers, so I tried this:</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Person(20);\n    p-&gt;Print();\n    p = &amp;w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>the new output being:</p>\n<pre><code>20\n24 and 10\n</code></pre>\n<p>Now p is a pointer, and because it's a pointer there's no copying or moving going on, just change of reference.</p>\n<p>Then I thought I could try dereferencing p and assigning w to it:</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Person(20);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>the output is this:</p>\n<pre><code>20\ncopy assignment\n24\n</code></pre>\n<p>I thought the second call to p-&gt;Print() would call Woman::Print() since p was pointing to a Woman, but it didn't. Any idea why? The copy assignment from Person got called, I think because p is a Person*.</p>\n<p>Then I tried this:</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Woman(20, 7);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>the new output is this:</p>\n<pre><code>20 and 7\ncopy assignment\n24 and 7\n</code></pre>\n<p>So I guess because p is Person* the copy assignment for Person got called, but not the one for Woman. Weirdly enough, the age got updated but the value of hotness remained the same, and I have no idea why.</p>\n<p>One more try:</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Woman* p = new Woman(20, 7);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>20 and 7\ncopy assignment\ncopy assignment of woman\n24 and 10\n</code></pre>\n<p>Now the numbers seem to be right.</p>\n<p>My next move was to remove the implementation of the copy assignment for Person, and see if the default would be called:</p>\n<pre><code>//Person&amp; operator=(const Person&amp; from) { cout &lt;&lt; \"copy assignment\" &lt;&lt; endl; age = from.Age(); return *this; }\n</code></pre>\n<p>output:</p>\n<pre><code>20 and 7\ncopy assignment of woman\n24 and 10\n</code></pre>\n<p>Note that the age was copied, so no worries.</p>\n<p>The next obvious move is to remove the implementation of the copy assigment for Woman, and see what happens:</p>\n<pre><code>//Woman&amp; operator=(const Woman&amp; from) { Person::operator=(from); cout &lt;&lt; \"copy assignment of woman\" &lt;&lt; endl; hotness = from.Hotness(); return *this; };\n</code></pre>\n<p>output:</p>\n<pre><code>20 and 7\n24 and 10\n</code></pre>\n<p>Everything seems to be fine.</p>\n<p>So at this point I can't quite understand what the author meant to say, so if anyone could help me out, I'd appreciate it.</p>\n<p>Thanks.</p>\n<p>bccs.</p>\n", "Tags": "<c++><pointers><copy-constructor>", "OwnerUserId": "1316509", "AnswerCount": "3"}, "22468810": {"ParentId": "22468067", "CommentCount": "0", "Body": "<p>One example at a time.</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person p = w;\n    p.Print();\n\n    return 0;\n}\n</code></pre>\n<p>The object <code>p</code> is not a <code>Woman</code>, it is just a <code>Person</code> object.  It is constructed using the copy constructor and makes a copy of the <code>Person</code> base class subobject of <code>w</code>, and so has the same <code>age</code>.</p>\n<p>Whether or not a virtual override takes effect is not based on whether you have a pointer, reference, or neither.  It is based on the most-derived type of the object as it was created, which can be different from the type of a reference or pointer to that object.</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Person(20);\n    p-&gt;Print();\n    p = &amp;w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>The statement <code>p = &amp;w;</code> discards (leaks) the old value of <code>p</code>, and then makes <code>p</code> a pointer to the original object <code>w</code>, as though you had simply done <code>Person* p = &amp;w;</code>.  So in this case <code>*p</code> is a <code>Woman</code>, the same object <code>w</code>.</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Person(20);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>The statement <code>*p = w;</code> calls the assignment operator of <code>*p</code>.  But since <code>*p</code> is a <code>Person</code>, the assignment used is <code>Person::operator=(const Person&amp;);</code>, not <code>Woman::operator=(const Woman&amp;);</code>.  So the <code>age</code> member of <code>*p</code> is reassigned, but the most-derived type of <code>*p</code> cannot change and is still <code>Person</code>.</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Person* p = new Woman(20, 7);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>This time <code>*p</code> is created as a <code>Woman</code> to begin with.  So the most-derived type of object <code>*p</code> is <code>Woman</code>, although the type of expression <code>*p</code> is <code>Person</code>.  Then when you call the virtual function <code>Print</code>, both before and after the assignment, the function override from the most-derived type is used, so <code>Woman::Print()</code> is called, not <code>Person::Print()</code>.</p>\n<p>In the statement <code>*p = w;</code>, the left side has type <code>Person</code> and the right side has type <code>Woman</code>.  Since (for these classes) <code>operator=</code> is <em>not</em> a virtual function, the function called depends on the expression types only, so the function used is <code>Person::operator=(const Person&amp;);</code>.  As you saw, this has the effect of changing the <code>age</code> member but not the <code>hotness</code> member of object <code>*p</code>!</p>\n<pre><code>int main() {\n    Woman w(24, 10);\n\n    Woman* p = new Woman(20, 7);\n    p-&gt;Print();\n    *p = w;\n    p-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>This time the type of expression <code>*p</code> is <code>Woman</code>, so <code>*p = w;</code> calls <code>Woman::operator=(const Woman&amp;);</code> and does what you probably expect.</p>\n<p>When you start removing the definition of <code>operator=</code> functions, note that's different from deleting the functions as Stroustrup suggests.  If an assignment operator is not declared for a class, the compiler automatically generates its own.  So removing those declarations has no effect on your program other than the fact that you get less output.</p>\n<p>The perhaps unexpected behavior of <code>Person p = w;</code> and <code>*p = w;</code> (where <code>p</code> is a <code>Person*</code>) is known as \"object slicing\".  Stroustrup's recommendation of deleting the copy and assignment functions is meant to avoid accidentally writing code that tries to do it.  If those declarations are defined as deleted, neither of those two statements would compile.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "22468810", "Score": "2", "CreationDate": "2014-03-18T01:35:32.957", "LastActivityDate": "2014-03-18T01:35:32.957"}, "bq_ids": {"n4140": {"so_22468067_22468786_8": {"section_id": 456, "quality": 0.8, "length": 4}}, "n3337": {"so_22468067_22468786_8": {"section_id": 447, "quality": 0.8, "length": 4}}, "n4659": {"so_22468067_22468786_8": {"section_id": 479, "quality": 0.8, "length": 4}}}, "22468786": {"ParentId": "22468067", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-03-18T01:33:10.160", "Score": "4", "LastEditorUserId": "410767", "LastEditDate": "2014-03-18T02:05:22.950", "Id": "22468786", "OwnerUserId": "410767", "Body": "<pre><code>Woman w(24, 10);\n\nPerson p = w;\np.Print();\n</code></pre>\n<blockquote>\n<p id=\"so_22468067_22468786_0\">24</p>\n<p id=\"so_22468067_22468786_1\">Which was a bit of a surprise for me, being a noob, but then a realized that since p is not a pointer, the virtual table is not used, and since it's a Person, Person::Print() got called.</p>\n</blockquote>\n<p>Correct</p>\n<blockquote>\n<p id=\"so_22468067_22468786_2\">So I knew that the copy constructor for Person got called, but I couldn't know if the copy constructor for Woman got called,...</p>\n</blockquote>\n<p>No, it didn't.</p>\n<blockquote>\n<p id=\"so_22468067_22468786_3\">...but that wouldn't really matter, since p is a Person, and through it I'd never have access to Woman::Hotness, not even if I tried a cast.</p>\n</blockquote>\n<p>Consider that the line <code>Person p =</code> creates a new variable <code>p</code> with enough bytes of memory to store the data for a <code>Person</code>.  If you call the copy constructor <code>Person::Person(const Person&amp;);</code> the code only knows about the data members for Person - not those for any derived type - so \"slices\" the <code>Woman</code> object to copy just the data members constituting a <code>Person</code>.  There was no room to put <code>hotness</code>, and it wasn't copied.</p>\n<hr>\n<pre><code>Person* p = new Person(20);\np-&gt;Print();\n*p = w;\np-&gt;Print();\n</code></pre>\n<blockquote>\n<p id=\"so_22468067_22468786_4\">20<br>\n  copy assignment <br>\n  24</br></br></p>\n<p id=\"so_22468067_22468786_5\">I thought the second call to p-&gt;Print() would call Woman::Print() since p was pointing to a Woman, but it didn't. Any idea why? The copy assignment from Person got called, I think because p is a Person*.</p>\n</blockquote>\n<p><code>*p</code> refers to the <code>Person</code> object you've just allocated.  The <code>new</code> was only told about <code>Person</code> - it had no way of knowing you might want/expect/hope-for extra space into which the extra fields of a <code>Woman</code> could later be copied, so it just allocated space for a <code>Person</code>.  When you wrote <code>*p = w;</code> it copied only the fields that are part of a <code>Person</code>, using the <code>Person::operator=(const Person&amp;)</code> function.  This does not set the pointer to the virtual dispatch table to address <code>Woman</code>'s table... again there's no knowledge of <code>Woman</code>... which is why even a <code>virtual</code> function like <code>Print</code> won't be resolved to <code>Woman::Print</code> later.</p>\n<hr>\n<pre><code>Person* p = new Woman(20, 7);\np-&gt;Print();\n*p = w;\np-&gt;Print();\n</code></pre>\n<blockquote>\n<p id=\"so_22468067_22468786_6\">20 and 7<br>\n  copy assignment<br>\n  24 and 7</br></br></p>\n<p id=\"so_22468067_22468786_7\">So I guess because <code>p</code> is <code>Person*</code> the copy assignment for Person got called, but not the one for Woman. Weirdly enough, the age got updated but the value of hotness remained the same, and I have no idea why.</p>\n</blockquote>\n<p>Here, while <code>p</code> does point to a <code>Woman</code> with the extra data member for <code>hotness</code>, the copy is still done using <code>Person::operator=</code>, so it doesn't know to copy the extra field over.  Interestingly, it does copy the internal pointer to the virtual dispatch table, so when you use <code>p-&gt;Print()</code> it dispatches to <code>Woman::Print</code>.</p>\n<hr>\n<pre><code>Woman* p = new Woman(20, 7);\np-&gt;Print();\n*p = w;\np-&gt;Print();\n</code></pre>\n<blockquote>\n<p id=\"so_22468067_22468786_8\">20 and 7<br>\n  copy assignment<br>\n  copy assignment of woman<br>\n  24 and 10</br></br></br></p>\n<p id=\"so_22468067_22468786_9\">Now the numbers seem to be right.</p>\n</blockquote>\n<p>Yes, because the compiler knew to allocate and copy all the data members of a <code>Woman</code>, which includes the pointer to virtual dispatch table and <code>hotness</code>.</p>\n<hr>\n<p>What the rest of your experiments (removing the explicitly defined assignment operators) show is that the problem with which members get copied and whether/how the virtual dispatch table pointer is updated are fundamental to the static types involved, so those problems are there with or without your implementations.</p>\n<hr>\n<blockquote>\n<p id=\"so_22468067_22468786_10\">So at this point I can't quite understand what the author meant to say, so if anyone could help me out, I'd appreciate it.</p>\n</blockquote>\n<p>What he's saying is that if someone thinks they're getting a pointer or reference to a <code>Person</code> and copies it as such (like in your earlier attempts), they are often accidentally removing the derived class (<code>Woman</code>) related members and ending up with a simple <code>Person</code> object where at an application logic level a <code>Woman</code> would have made sense.  By deleting these operators the compiler will prevent this accidental slicing construction.  The correct thing to do is to provide a <code>clone()</code> function that creates a new object of whatever the dynamic object type is, allowing a kind of \"virtual copy\".  If you search for \"clone\" you'll turn up lots of explanation and examples.</p>\n</hr></hr></hr></hr></hr>", "LastActivityDate": "2014-03-18T02:05:22.950"}});