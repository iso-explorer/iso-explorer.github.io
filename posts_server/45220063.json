post_cb({"45220505": {"ParentId": "45220063", "CommentCount": "8", "Body": "<p>Your first snippet has undefined behavior. <a href=\"http://eel.is/c++draft/except#ctor-1\" rel=\"nofollow noreferrer\"><code>[exception.ctor]/1</code></a>:</p>\n<blockquote>\n<p id=\"so_45220063_45220505_0\">As control passes from the point where an exception is thrown to a handler, destructors are invoked by a process, specified in this section, called stack unwinding.</p>\n</blockquote>\n<p>Here, the destructor or <code>error</code> is called, causing the <code>c_str()</code> to become a dangling pointer. Later dereferencing it, when you use <code>std::cout</code> for instance, is undefined behavior.</p>\n<p>Your second snippet is perfectly fine. There is no reason why it would be undefined behavior. You never actually call <code>what</code>, or do anything else that might result in undefined behavior. The only thing not defined by the Standard is if stack unwinding happens or not, <a href=\"http://eel.is/c++draft/except.terminate#2\" rel=\"nofollow noreferrer\"><code>[except.terminate]/2</code></a>:</p>\n<blockquote>\n<p id=\"so_45220063_45220505_1\">In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before <code>std\u200b::\u200bterminate()</code> is called.</p>\n</blockquote>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "45220505", "Score": "2", "CreationDate": "2017-07-20T16:36:09.663", "LastActivityDate": "2017-07-20T16:36:09.663"}, "45220063": {"CommentCount": "0", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "2104697", "CreationDate": "2017-07-20T16:11:12.203", "LastActivityDate": "2017-07-20T17:54:19.580", "Title": "Is this use of c_str with exception undefined behavior?", "AcceptedAnswerId": "45220505", "LastEditDate": "2017-07-20T16:15:58.523", "Id": "45220063", "Score": "3", "Body": "<p>I've seen several similar snippets of code that looked like this:</p>\n<pre><code>struct MyExcept : std::exception {\n    explicit MyExcept(const char* m) noexcept : message{m} {}\n\n    const char* what() const noexcept override {\n        return message;\n    }\n\n    const char* message;\n};\n\nvoid foo() {\n    std::string error;\n\n    error += \"Some\";\n    error += \" Error\";\n\n    throw MyExcept{error.c_str()};\n}\n\nint main() {\n    try {\n        foo();\n    } catch (const MyExcept&amp; e) {\n        // Is this okay?\n        std::cout &lt;&lt; e.message &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>In the line following the comment <code>Is this okay?</code>, we read the c-style string that was allocated in the <code>foo</code> function using <code>std::string</code>. Since the string is destructed with stack unwinding, is this undefined behavior?</p>\n<hr>\n<p>If it's indeed undefined behavior, what if we replace the <code>main</code> function with this one?</p>\n<pre><code>int main() {\n    foo();\n}\n</code></pre>\n<p>Since there is no catch, the compiler is not forced to unwind the stack, and yet output the result of <code>what()</code> in the console and abort the program. So is it still undefined behavior?</p>\n</hr>", "Tags": "<c++><exception><c++14><undefined-behavior><stack-unwinding>", "OwnerUserId": "2104697", "AnswerCount": "3"}, "45221948": {"ParentId": "45220063", "CommentCount": "0", "Body": "<p>As others stated, the code is undefined since the pointer assigned to <code>message</code>  is left dangling. </p>\n<p><a href=\"http://en.cppreference.com/w/cpp/error/runtime_error\" rel=\"nofollow noreferrer\"><code>std::runtime_error</code></a> already provides a solution to this issue. Call its constructor that takes a <code>std::string</code> as input, and don't override <code>what()</code> at all:</p>\n<pre><code>struct MyExcept : std::runtime_error {\n    explicit MyExcept(const std::string &amp; m) noexcept : std::runtime_error(m) {}\n};\n\nvoid foo() {\n    std::string error;\n\n    error += \"Some\";\n    error += \" Error\";\n\n    throw MyExcept(error);\n}\n\nint main() {\n    try {\n        foo();\n    }\n    catch (const MyExcept&amp; e) {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p><code>std::runtime_error</code> has an internal <code>std::string</code> whose data <code>what()</code> returns by default, thus avoiding the dangling issue. </p>\n", "OwnerUserId": "65863", "PostTypeId": "2", "Id": "45221948", "Score": "1", "CreationDate": "2017-07-20T17:54:19.580", "LastActivityDate": "2017-07-20T17:54:19.580"}, "bq_ids": {"n4140": {"so_45220063_45220505_1": {"section_id": 3383, "quality": 0.9166666666666666, "length": 11}, "so_45220063_45220505_0": {"section_id": 3343, "quality": 0.6, "length": 9}}, "n3337": {"so_45220063_45220505_1": {"section_id": 3252, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_45220063_45220505_1": {"section_id": 4143, "quality": 0.9166666666666666, "length": 11}, "so_45220063_45220505_0": {"section_id": 4108, "quality": 0.9333333333333333, "length": 14}}}, "45220105": {"ParentId": "45220063", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Yes, that's undefined behavior. You are working with a dangling pointer.</p>\n<pre><code>void foo() {\n    std::string error;\n\n    error += \"Some\";\n    error += \" Error\";\n\n    throw MyExcept{error.c_str()};\n} // &lt;&lt;  error goes out of scope here and so does the pointer returned\n  //     from c_str()\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_45220063_45220105_0\">Since there is no catch, the compiler is not forced to unwind the stack, and yet output the result of <code>what()</code> in the console and abort the program. So is it still undefined behavior?</p>\n</blockquote>\n<p>Since the default implementation will use <a href=\"http://en.cppreference.com/w/cpp/error/terminate\" rel=\"nofollow noreferrer\"><code>std::terminate</code></a> and in turn calling <code>std::abort()</code> this may be still undefined behavior because most of the standard handler implementations will try to dereference <code>what()</code>.</p>\n<p>You can install your own handlers though to avoid that.</p>\n</hr>", "OwnerUserId": "8242698", "LastEditorUserId": "8242698", "LastEditDate": "2017-07-20T16:42:22.060", "Id": "45220105", "Score": "5", "CreationDate": "2017-07-20T16:13:19.877", "LastActivityDate": "2017-07-20T16:42:22.060"}});