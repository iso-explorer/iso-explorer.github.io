post_cb({"bq_ids": {"n4140": {"so_32104890_32104890_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 142}, "so_32104890_32426650_1": {"length": 11, "quality": 1.0, "section_id": 141}, "so_32104890_32426650_2": {"length": 10, "quality": 1.0, "section_id": 142}, "so_32104890_32426650_5": {"length": 14, "quality": 1.0, "section_id": 145}, "so_32104890_32426650_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 146}, "so_32104890_32426650_4": {"length": 18, "quality": 1.0, "section_id": 144}, "so_32104890_32426650_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 92}}, "n3337": {"so_32104890_32104890_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 136}, "so_32104890_32426650_1": {"length": 11, "quality": 1.0, "section_id": 135}, "so_32104890_32426650_2": {"length": 10, "quality": 1.0, "section_id": 136}, "so_32104890_32426650_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 140}, "so_32104890_32426650_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 87}, "so_32104890_32426650_4": {"length": 18, "quality": 1.0, "section_id": 138}, "so_32104890_32426650_5": {"length": 14, "quality": 1.0, "section_id": 139}}, "n4659": {"so_32104890_32104890_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 146}, "so_32104890_32426650_1": {"length": 11, "quality": 1.0, "section_id": 145}, "so_32104890_32426650_2": {"length": 10, "quality": 1.0, "section_id": 146}, "so_32104890_32426650_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 150}, "so_32104890_32426650_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 95}, "so_32104890_32426650_4": {"length": 18, "quality": 1.0, "section_id": 148}, "so_32104890_32426650_5": {"length": 8, "quality": 0.5714285714285714, "section_id": 344}}}, "32426650": {"Id": "32426650", "PostTypeId": "2", "Body": "<p>(IMHO) The most common reasons the standard disallows a specific feature are: </p>\n<ol>\n<li>The feature is covered by another mechanism in the language, rendering it superfluous.</li>\n<li>It contradicts existing language logic and implementation, making its implementation potentially code breaking. </li>\n<li>Legacy: the feature was left out in the first place and now we've built a lot without it that it's almost forgotten (see partial function template specialization).</li>\n</ol>\n<p>Difficulty of implementation is rarely a factor, though it may take some time for  compiler implementations to catch up with evolution on the \"hard\" stuff. </p>\n<p>You could always wrap your non type template parameter in another type:</p>\n<pre><code>template &lt; typename T1, typename T2 &gt; \nstruct Demo {}; // primary template\n\ntemplate &lt; typename T &gt; \nstruct Demo&lt;T, integral_constant&lt;T, 0&gt;&gt; {}; // specialization\n</code></pre>\n<p>I doubt <a href=\"http://coliru.stacked-crooked.com/a/724fbcb3dd8c13ee\" rel=\"nofollow\">this hack</a> falls into case 1. Case 3 is always a possibility so lets examine case 2. To do this, we have to know which are the related rules the standard imposes on class templates partial specializations. </p>\n<blockquote>\n<p id=\"so_32104890_32426650_0\">14.5.5 <strong>Class template partial specializations</strong></p>\n<ol start=\"7\">\n<li><p id=\"so_32104890_32426650_1\">A non-type argument is non-specialized if it is the name of a non-type parameter. All other non-type arguments are specialized. <strong>(C1)</strong></p></li>\n<li><p id=\"so_32104890_32426650_2\">Within the argument list of a class template partial specialization, the following restrictions apply:</p>\n<ul>\n<li>A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple identifier. <strong>(C2)</strong></li>\n<li>The type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization. <strong>(C3)</strong></li>\n</ul></li>\n</ol>\n</blockquote>\n<p>I marked the first three <strong>C</strong>lauses I found relevant (the third is the one in question). According to C1 in our case <strong>we have a specialized non-type argument</strong> so C2 should stand, yet this </p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;;\n</code></pre>\n<p>is actually </p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, T(1)&gt;; // notice the value initialization\n</code></pre>\n<p>so the partially specialized non type argument <code>T t</code> involves the template parameter of the partial specialization <code>class T</code> in an expression other than an identifier; furthermore such specializations are bound to involve <code>class T</code> in a value initialization which will always be a violation of the rules. Then C3 comes along and clears that out for us so that we won't have to make that deduction every time. </p>\n<p>So far we've established that the rules are in sync with themselves but this does NOT prove case 2 (once we remove the initial limitation every other related limitation falls apart). We'd have to dive into <strong>matching class template partial specializations</strong> rules; partial ordering is considered out of scope here because if we can produce valid candidates it's up to the programmer to put together a well formed program (i.e. not create ambiguous uses of class templates). </p>\n<p>Section </p>\n<blockquote>\n<p id=\"so_32104890_32426650_3\"><strong>Matching of class template partial specializations [temp.class.spec.match]</strong></p>\n</blockquote>\n<p>describes the (give or take) \"pattern matching\" process involved in template specialization. Rule <code>1</code> is the overall workflow of the procedure and the subsequent rules are those that define correctness </p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_32104890_32426650_4\">A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list</p></li>\n<li><p id=\"so_32104890_32426650_5\">A non-type template argument can also be deduced from the value of an actual template argument of a non-type parameter of the primary template.</p></li>\n<li><p id=\"so_32104890_32426650_6\">In a type name that refers to a class template specialization, (e.g., A) the argument list shall match the template parameter list of the primary template. The template arguments of a specialization are deduced from the arguments of the primary template.</p></li>\n</ol>\n</blockquote>\n<p><strong>These rules are not violated</strong> by allowing <em>the type of a template parameter corresponding to a specialized non-type argument to be dependent on a parameter of the specialization</em>. So IMHO <strong>there is no specific reason</strong> why we can't have this feature in future revisions of the language: <strong>legacy is to blame</strong>. Sadly I didn't manage to find any language proposals with the initiative to introduce this feature. </p>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2015-09-11T13:41:31.983", "Score": "5", "CreationDate": "2015-09-06T18:05:23.680", "ParentId": "32104890", "CommentCount": "3", "OwnerUserId": "2567683", "LastEditDate": "2015-09-11T13:41:31.983"}, "32104890": {"ViewCount": "956", "Body": "<p>In the answer to this post \"<a href=\"https://stackoverflow.com/questions/22486386/partially-specializing-a-non-type-template-parameter-of-dependent-type\">(Partially) specializing a non-type template parameter of dependent type</a>\", it states:</p>\n<blockquote>\n<p id=\"so_32104890_32104890_0\">The type of a template parameter corresponding to a specialized\n  non-type argument shall not be dependent on a parameter of the\n  specialization. [ Example:</p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\n\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<p id=\"so_32104890_32104890_1\">\u2014end example ]</p>\n</blockquote>\n<p>My question is why is this restriction here?  There is at least one use case where I find that this restriction interferes with writing clean code.  E.g.</p>\n<pre><code>template &lt;typename T, T*&gt;\nstruct test;\n\ntemplate &lt;typename T&gt;\nstruct test&lt;T, nullptr&gt; // or struct test&lt;T, (T*)nullptr&gt;\n{\n};\n\ntemplate &lt;typename R, typename...ARGs, R(*fn)(ARGs...)&gt;\nstruct test&lt;R(ARGs...), fn&gt;\n{\n};\n</code></pre>\n<p>Though I'm unsure if there are other cases that stating a constant based on a type is a problem beyond not making any sense.</p>\n<p>Anyone have a reason for why this is so?</p>\n", "AcceptedAnswerId": "32426650", "Title": "Why is initialization of a constant dependent type in a template parameter list disallowed by the standard?", "CreationDate": "2015-08-19T20:17:44.280", "Id": "32104890", "CommentCount": "15", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:28:45.303", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-11T13:41:31.983", "Score": "34", "OwnerUserId": "1366368", "Tags": "<c++><templates><c++11><c++14><template-meta-programming>", "AnswerCount": "1"}});