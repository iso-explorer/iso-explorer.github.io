post_cb({"2254276": {"ParentId": "2254263", "CommentCount": "0", "CreationDate": "2010-02-12T18:47:23.903", "OwnerUserId": "13", "PostTypeId": "2", "Id": "2254276", "Score": "4", "Body": "<p>Yes and yes. The order of destruction is always opposite to the order of construction, for member variables.</p>\n", "LastActivityDate": "2010-02-12T18:47:23.903"}, "2254279": {"ParentId": "2254263", "CommentCount": "1", "CreationDate": "2010-02-12T18:47:43.403", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "2254279", "Score": "25", "Body": "<p>Yes, they are (non-static members that is). See 12.6.2/5 for initialization (construction) and 12.4/6 for destruction.</p>\n", "LastActivityDate": "2010-02-12T18:47:43.403"}, "2254380": {"ParentId": "2254263", "CommentCount": "0", "CreationDate": "2010-02-12T19:04:10.947", "OwnerUserId": "456", "PostTypeId": "2", "Id": "2254380", "Score": "6", "Body": "<p>Yes, the standard guarantees objects get destructed in the reverse order they were created. The reason is that one object may use another, thus depend on it.  Consider:</p>\n<pre><code>struct A { };\n\nstruct B {\n A &amp;a;\n B(A&amp; a) : a(a) { }\n};\n\nint main() {\n    A a;\n    B b(a);\n}\n</code></pre>\n<p>If <code>a</code> were to destruct before <code>b</code> then <code>b</code> would hold an invalid member reference. By destructing the objects in the reverse order in which they were created we guarantee correct destruction.</p>\n", "LastActivityDate": "2010-02-12T19:04:10.947"}, "2254306": {"ParentId": "2254263", "CommentCount": "1", "CreationDate": "2010-02-12T18:50:58.397", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "2254306", "Score": "98", "Body": "<blockquote>\n<p id=\"so_2254263_2254306_0\">In other words, are members guaranteed to be initialized by order of declaration and destroyed in reverse order?</p>\n</blockquote>\n<p>Yes to both. See 12.6.2</p>\n<blockquote>\n<p id=\"so_2254263_2254306_1\"><strong>6</strong> Initialization shall proceed in the\n  following order: </p>\n<ul>\n<li><p id=\"so_2254263_2254306_2\">First, and only for\n  the constructor of the most derived\n  class as described below, virtual base\n  classes shall be initialized in the\n  order they appear on a depth-first\n  left-to-right traversal of the\n  directed acyclic graph of base\n  classes, where \u201cleft-to-right\u201d is the\n  order of appearance of the base class\n  names in the derived class\n  base-specifier-list. </p></li>\n<li><p id=\"so_2254263_2254306_3\">Then, direct\n  base classes shall be initialized in\n  declaration order as they appear in\n  the base-specifier-list (regardless of\n  the order of the mem-initializers). </p></li>\n<li><p id=\"so_2254263_2254306_4\">Then, non-static data members shall be\n  initialized in the order they were\n  declared in the class definition\n  (again regardless of the order of the\n  mem-initializers). </p></li>\n<li><p id=\"so_2254263_2254306_5\">Finally, the\n  compound-statement of the constructor\n  body is executed. [ Note: the\n  declaration order is mandated to\n  ensure that base and member subobjects\n  are destroyed in the reverse order of\n  initialization. \u2014end note ]</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2010-02-12T18:50:58.397"}, "bq_ids": {"n4140": {"so_2254263_2254306_2": {"section_id": 438, "quality": 0.875, "length": 28}, "so_2254263_2254306_4": {"section_id": 438, "quality": 1.0, "length": 15}, "so_2254263_2254306_3": {"section_id": 438, "quality": 1.0, "length": 13}, "so_2254263_2254306_0": {"section_id": 438, "quality": 0.7, "length": 7}, "so_2254263_2254306_5": {"section_id": 438, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_2254263_2254306_2": {"section_id": 429, "quality": 0.875, "length": 28}, "so_2254263_2254306_4": {"section_id": 429, "quality": 1.0, "length": 15}, "so_2254263_2254306_3": {"section_id": 429, "quality": 1.0, "length": 13}, "so_2254263_2254306_0": {"section_id": 429, "quality": 0.7, "length": 7}, "so_2254263_2254306_5": {"section_id": 429, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_2254263_2254306_2": {"section_id": 458, "quality": 0.875, "length": 28}, "so_2254263_2254306_4": {"section_id": 458, "quality": 1.0, "length": 15}, "so_2254263_2254306_3": {"section_id": 458, "quality": 1.0, "length": 13}, "so_2254263_2254306_5": {"section_id": 458, "quality": 0.8421052631578947, "length": 16}, "so_2254263_2254306_0": {"section_id": 458, "quality": 0.7, "length": 7}}}, "2254263": {"CommentCount": "1", "AcceptedAnswerId": "2254306", "CreationDate": "2010-02-12T18:44:32.937", "LastActivityDate": "2010-02-12T19:04:10.947", "PostTypeId": "1", "ViewCount": "33288", "FavoriteCount": "12", "Title": "Order of member constructor and destructor calls", "Id": "2254263", "Score": "79", "Body": "<p>Oh C++ gurus, I seek thy wisdom. Speak standardese to me and tell my if C++ guarantees that the following program:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A\n{\n    A() { cout &lt;&lt; \"A::A\" &lt;&lt; endl; }\n    ~A() { cout &lt;&lt; \"A::~\" &lt;&lt; endl; }\n};\n\nstruct B\n{\n    B() { cout &lt;&lt; \"B::B\" &lt;&lt; endl; }\n    ~B() { cout &lt;&lt; \"B::~\" &lt;&lt; endl; }\n};\n\nstruct C\n{\n    C() { cout &lt;&lt; \"C::C\" &lt;&lt; endl; }\n    ~C() { cout &lt;&lt; \"C::~\" &lt;&lt; endl; }\n};\n\nstruct Aggregate\n{\n    A a;\n    B b;\n    C c;\n};\n\nint main()\n{\n    Aggregate a;\n    return 0;\n}\n</code></pre>\n<p>will always produce</p>\n<pre><code>A::A\nB::B\nC::C\nC::~\nB::~\nA::~\n</code></pre>\n<p>In other words, are members guaranteed to be initialized by order of declaration and destroyed in reverse order?</p>\n", "Tags": "<c++>", "OwnerUserId": "169828", "AnswerCount": "4"}});