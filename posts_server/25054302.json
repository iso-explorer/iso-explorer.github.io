post_cb({"25055430": {"Id": "25055430", "PostTypeId": "2", "Body": "<p>The quote <em>\u00a721.4.7.1 basic_string accessors [string.accessors]</em> from the standard indicates that <code>std::string</code> has a guaranteed null terminated buffer.</p>\n<p>Also according to the standard <em>\u00a721.4.4/6-8 basic_string capacity [string.capacity]:</em></p>\n<blockquote>\n<p id=\"so_25054302_25055430_0\"><em><code>void resize(size_type n, charT c);</code></em></p>\n<p id=\"so_25054302_25055430_1\"><em><code>6</code> Requires: <code>n &lt;= max_size()</code></em></p>\n<p id=\"so_25054302_25055430_2\"><em><code>7</code> Throws: <code>length_error</code> if <code>n &gt; max_size()</code>.</em></p>\n<p id=\"so_25054302_25055430_3\"><em><code>8</code> Effects: Alters the length of the string designated by <code>*this</code> as follows:</em></p>\n<blockquote>\n<blockquote>\n<p id=\"so_25054302_25055430_10\"><em>- If <code>n &lt;= size()</code>, the function replaces the string designated by <code>*this</code> with a string of length <code>n</code> whose elements are a copy of the initial elements of the original string designated by <code>*this</code>.</em></p>\n<p id=\"so_25054302_25055430_11\"><em>- If <code>n &gt; size()</code>, the function replaces the string designated by <code>*this</code> with a string of length <code>n</code> whose first <code>size()</code> elements are a copy of the original string designated by <code>*this</code>, and whose remaining elements are all initialized to <code>c</code>.</em></p>\n</blockquote>\n</blockquote>\n<p id=\"so_25054302_25055430_6\"><em><code>void resize(size_type n);</code></em></p>\n<p id=\"so_25054302_25055430_7\"><code>9</code> <em>Effects: <code>resize(n,charT())</code>.</em></p>\n</blockquote>\n<p>Interpreting the above <code>std::string::resize</code> will not affect the terminating null character of the string's buffer.</p>\n<p>Now to your code:</p>\n<p>statement <code>std::string copy;</code> defines an empty string (i.e., <code>copy.size() == 0</code>).</p>\n<p>statement <code>copy.resize(count + 1);</code> since <code>(n == 5) &gt; 0</code> will replace copy with a string of length 5 filled with <code>\\0</code> (i.e., null characters).</p>\n<p>Now in statement <code>stream.read(&amp;copy[0], count);</code> <code>std::stream::read</code> will simply copy a block of data, without checking its contents nor appending a null character at the end.</p>\n<p>In other words it will just replace the first 4 null characters of <code>copy</code> with \"data\". The size of <code>copy</code> won't change it will be still a 5 sized string. That is, the contents of <code>copy</code>'s buffer will be \"data\\0\\0\".</p>\n<p>So calling <code>copy[count] = 0;</code> is redundant since <code>copy[4]</code> is already <code>\\0</code>. However, your string is not \"data\" but rather \"data\\0\". </p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-07-31T09:35:50.870", "Score": "4", "CreationDate": "2014-07-31T09:30:33.857", "ParentId": "25054302", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2014-07-31T09:35:50.870"}, "bq_ids": {"n4140": {"so_25054302_25055430_4": {"length": 15, "quality": 1.0, "section_id": 1607}, "so_25054302_25055430_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 1607}, "so_25054302_25055430_9": {"length": 20, "quality": 1.0, "section_id": 1607}, "so_25054302_25055430_11": {"length": 20, "quality": 1.0, "section_id": 1607}, "so_25054302_25055430_8": {"length": 15, "quality": 1.0, "section_id": 1607}, "so_25054302_25055430_10": {"length": 15, "quality": 1.0, "section_id": 1607}, "so_25054302_25055430_5": {"length": 20, "quality": 1.0, "section_id": 1607}}, "n3337": {"so_25054302_25055430_4": {"length": 15, "quality": 1.0, "section_id": 1603}, "so_25054302_25055430_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 1603}, "so_25054302_25055430_8": {"length": 15, "quality": 1.0, "section_id": 1603}, "so_25054302_25055430_11": {"length": 20, "quality": 1.0, "section_id": 1603}, "so_25054302_25055430_9": {"length": 20, "quality": 1.0, "section_id": 1603}, "so_25054302_25055430_5": {"length": 20, "quality": 1.0, "section_id": 1603}, "so_25054302_25055430_10": {"length": 15, "quality": 1.0, "section_id": 1603}}, "n4659": {"so_25054302_25055430_4": {"length": 15, "quality": 1.0, "section_id": 1758}, "so_25054302_25055430_10": {"length": 15, "quality": 1.0, "section_id": 1758}, "so_25054302_25055430_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 1758}, "so_25054302_25055430_8": {"length": 15, "quality": 1.0, "section_id": 1758}, "so_25054302_25055430_11": {"length": 20, "quality": 1.0, "section_id": 1758}, "so_25054302_25055430_9": {"length": 20, "quality": 1.0, "section_id": 1758}, "so_25054302_25055430_5": {"length": 20, "quality": 1.0, "section_id": 1758}}}, "25054302": {"ViewCount": "1517", "Body": "<p>I am copying some data from a stream into a string, so I thought about resizing the string with the actual number of characters plus one for the terminating one, like this:</p>\n<pre><code>std::istringstream stream { \"data\" };\nconst std::size_t count = 4;\n\nstd::string copy;\ncopy.resize(count + 1);\n\nstream.read(&amp;copy[0], count);\ncopy[count] = 0;\n</code></pre>\n<p>However, in this case, <code>copy</code> indicates it has a size of <code>5</code> (which is consistent since I called <code>resize(5)</code>). Does that mean that <code>resize()</code> will add the extra terminating character itself? Which would mean that I do not have to worry about appending <code>\\0</code> after invoking <code>read(&amp;data[0], count)</code>?</p>\n", "AcceptedAnswerId": "25054429", "Title": "Does the std::string::resize() method manages the terminating character?", "CreationDate": "2014-07-31T08:34:58.453", "Id": "25054302", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-07-31T09:35:50.870", "Score": "2", "OwnerUserId": "948128", "Tags": "<c++><string><c++11>", "AnswerCount": "2"}, "25054429": {"Id": "25054429", "PostTypeId": "2", "Body": "<p>No you don't have to. The <code>string</code> class abstracts the concept of \"null terminated char sequence\", so that you don't have to worry about that anymore.</p>\n<p>Also, the size of the string returned doesn't count the terminating character, which is consistent with the behavior I mentioned, because if you don't have to deal with the terminating character, you don't have to know about it. Your string is just the characters you want to manipulate, without any concern for that \"utility\" character that has nothing to do with your actual data.</p>\n", "LastEditorUserId": "1594913", "LastActivityDate": "2014-07-31T09:15:54.203", "Score": "3", "CreationDate": "2014-07-31T08:41:50.410", "ParentId": "25054302", "CommentCount": "0", "OwnerUserId": "1594913", "LastEditDate": "2014-07-31T09:15:54.203"}});