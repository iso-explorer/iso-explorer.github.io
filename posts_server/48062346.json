post_cb({"bq_ids": {"n4140": {"so_48062346_48065437_4": {"length": 14, "quality": 0.5384615384615384, "section_id": 7223}, "so_48062346_48065437_3": {"length": 22, "quality": 0.88, "section_id": 5792}, "so_48062346_48062531_1": {"length": 10, "quality": 0.5263157894736842, "section_id": 7223}, "so_48062346_48062346_0": {"length": 17, "quality": 1.0, "section_id": 7223}, "so_48062346_48062531_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 7223}}, "n3337": {"so_48062346_48065437_3": {"length": 22, "quality": 0.88, "section_id": 5565}, "so_48062346_48065437_4": {"length": 16, "quality": 0.6153846153846154, "section_id": 5913}, "so_48062346_48062531_1": {"length": 13, "quality": 0.6842105263157895, "section_id": 5913}, "so_48062346_48062346_0": {"length": 17, "quality": 1.0, "section_id": 6967}, "so_48062346_48062531_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 6967}}, "n4659": {"so_48062346_48065437_5": {"length": 75, "quality": 0.8928571428571429, "section_id": 8732}, "so_48062346_48065437_4": {"length": 21, "quality": 0.8076923076923077, "section_id": 8732}, "so_48062346_48065437_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 7249}, "so_48062346_48062531_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 8732}, "so_48062346_48065437_3": {"length": 23, "quality": 0.92, "section_id": 7251}, "so_48062346_48065437_2": {"length": 15, "quality": 0.9375, "section_id": 7250}, "so_48062346_48062531_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 8732}, "so_48062346_48062346_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 8732}}}, "48062531": {"Id": "48062531", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48062346_48062531_0\">Is this interpretation of this modification of the standard right or are there other rules that compensate the deletion of this cited sentence?</p>\n</blockquote>\n<p>Yes, this interpretation is correct. A pointer past the end isn't simply convertible to another pointer value that happens to point to that address.</p>\n<p>The new <a href=\"http://eel.is/c++draft/basic.compound#3\" rel=\"noreferrer\">[basic.compound]/3</a> says:</p>\n<blockquote>\n<p id=\"so_48062346_48062531_1\">Every value of pointer type is one of the following:<br>\n  (3.1)\n  a pointer to an object or function (the pointer is said to point to the object or function), or<br>\n  (3.2)\n  a pointer past the end of an object ([expr.add]), or</br></br></p>\n</blockquote>\n<p>Those are mutually exclusive. <code>p1+1</code> is a pointer past the end, not a pointer to an object. <code>p1+1</code> points to a hypothetical <code>x[1]</code> of a size-1 array at <code>p1</code>, not to <code>p2</code>. Those two objects are not pointer-interconvertible. </p>\n<p>We also have the non-normative note:</p>\n<blockquote>\n<p id=\"so_48062346_48062531_2\">[\u2009Note: A pointer past the end of an object ([expr.add]) is not considered to point to an unrelated object of the object's type that might be located at that address. [...] </p>\n</blockquote>\n<p>which clarifies the intent. </p>\n<hr/>\n<p>As T.C. points out in numerous comments (<a href=\"https://stackoverflow.com/questions/48062346/is-a-pointer-with-the-right-address-and-type-still-always-a-valid-pointer-since/48065437#comment83125977_48065437\">notably this one</a>), this is really a special case of the problem that comes with trying to implement <code>std::vector</code> - which is that <code>[v.data(), v.data() + v.size())</code> needs to be a valid range and yet <code>vector</code> doesn't create an array object, so the only defined pointer arithmetic would be going from any given object in the vector to past-the-end of its hypothetical one-size array. Fore more resources, see <a href=\"https://wg21.link/CWG2182\" rel=\"noreferrer\">CWG 2182</a>, <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/p4BXNhTHY7U/ahp5CzNFQQAJ\" rel=\"noreferrer\">this std discussion</a>, and two revisions of a paper on the subject: <a href=\"https://wg21.link/P0593R0\" rel=\"noreferrer\">P0593R0</a> and <a href=\"https://wg21.link/P0593R1\" rel=\"noreferrer\">P0593R1</a> (section 1.3 specifically).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2018-01-03T13:40:49.943", "Score": "40", "CreationDate": "2018-01-02T14:14:14.900", "ParentId": "48062346", "CommentCount": "11", "OwnerUserId": "2069064", "LastEditDate": "2018-01-03T13:40:49.943"}, "48062346": {"ViewCount": "3764", "Body": "<p><sub>(In reference to <a href=\"https://stackoverflow.com/questions/48058545/are-there-any-guarantees-for-unions-that-contain-a-wrapped-type-and-the-type-its/48060029#48060029\">this question and answer</a>.)</sub></p>\n<p>Before the C++17 standard, the following sentence was included in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.compound#3\" rel=\"noreferrer\">[basic.compound]/3</a>:</p>\n<blockquote>\n<p id=\"so_48062346_48062346_0\">If an object of type T is located at an address A, a pointer of type cv T* whose value is the address A is said to point to that object, regardless of how the value was obtained.</p>\n</blockquote>\n<p>But since C++17, this sentence has been <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#3\" rel=\"noreferrer\">removed</a>.</p>\n<p>For example I believe that this sentence made this example code defined, and that since C++17 this is undefined behavior:</p>\n<pre><code> alignas(int) unsigned char buffer[2*sizeof(int)];\n auto p1=new(buffer) int{};\n auto p2=new(p1+1) int{};\n *(p1+1)=10;\n</code></pre>\n<p>Before C++17, <code>p1+1</code> holds the address to <code>*p2</code> and has the right type, so <code>*(p1+1)</code> is a pointer to <code>*p2</code>. In C++17 <code>p1+1</code> is a <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#3.2\" rel=\"noreferrer\"><em>pointer past-the-end</em></a>, so it is not a <em>pointer to object</em> and I believe it is not dereferencable.</p>\n<p>Is this interpretation of this modification of the standard right or are there other rules that compensate the deletion of the cited sentence?</p>\n", "AcceptedAnswerId": "48062531", "Title": "Is a pointer with the right address and type still always a valid pointer since C++17?", "CreationDate": "2018-01-02T14:00:35.300", "LastActivityDate": "2018-01-31T16:20:21.733", "CommentCount": "4", "FavoriteCount": "18", "PostTypeId": "1", "LastEditDate": "2018-01-31T16:20:21.733", "LastEditorUserId": "2069064", "Id": "48062346", "Score": "72", "OwnerUserId": "5632316", "Tags": "<c++><pointers><c++14><language-lawyer><c++17>", "AnswerCount": "3"}, "48076395": {"Id": "48076395", "PostTypeId": "2", "Body": "<p>To expand on the answers given here is an example of what I believe the revised wording is excluding:</p>\n<p><strong>Warning: Undefined Behaviour</strong></p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    int A[1]{7};\n    int B[1]{10};\n    bool same{(B)==(A+1)};\n\n    std::cout&lt;&lt;B&lt;&lt; ' '&lt;&lt; A &lt;&lt;' '&lt;&lt;sizeof(*A)&lt;&lt;'\\n';\n    std::cout&lt;&lt;(same?\"same\":\"not same\")&lt;&lt;'\\n';\n    std::cout&lt;&lt;*(A+1)&lt;&lt;'\\n';//!!!!!  \n    return 0;\n}\n</code></pre>\n<p>For entirely implementation dependent (and fragile) reasons possible output of this program is:</p>\n<pre><code>0x7fff1e4f2a64 0x7fff1e4f2a60 4\nsame\n10\n</code></pre>\n<p>That output shows that the two arrays (in that case) happen to be stored in memory such that 'one past the end' of <code>A</code> happens to hold the value of the address of the first element of <code>B</code>.</p>\n<p>The revised specification is ensuring that regardless <code>A+1</code> is never a valid pointer to <code>B</code>. The old phrase 'regardless of how the value is obtained' says that if 'A+1' happens to point to 'B[0]' then it's a valid pointer to 'B[0]'.\nThat can't be good and surely never the intention.</p>\n", "LastEditorUserId": "4213662", "LastActivityDate": "2018-01-03T11:29:49.273", "Score": "0", "CreationDate": "2018-01-03T11:23:38.977", "ParentId": "48062346", "CommentCount": "1", "OwnerUserId": "4213662", "LastEditDate": "2018-01-03T11:29:49.273"}, "48065437": {"Id": "48065437", "PostTypeId": "2", "Body": "<p>In your example, <code>*(p1 + 1) = 10;</code> should be UB, because it is <em>one past the end of the array</em> of size 1. But we are in a very special case here, because the array was dynamically constructed in a larger char array.</p>\n<p>Dynamic object creation is described in <em>4.5 The C++ object model [intro.object]</em>, \u00a73 of the n4659 draft of the C++ standard:</p>\n<blockquote>\n<p id=\"so_48062346_48065437_0\">3 If a complete object is created (8.3.4) in storage associated with another object e of type \u201carray of N\n  unsigned char\u201d or of type \u201carray of N std::byte\u201d (21.2.1), that array provides storage for the created\n  object if: <br/>\n  (3.1) \u2014 the lifetime of e has begun and not ended, and <br/>\n  (3.2) \u2014 the storage for the new object fits entirely within e, and <br/>\n  (3.3) \u2014 there is no smaller array object that satisfies these constraints.</p>\n</blockquote>\n<p>The 3.3 seems rather unclear, but the examples below make the intent more clear:</p>\n<blockquote id=\"so_48062346_48065437_1\">\n<pre><code>struct A { unsigned char a[32]; };\nstruct B { unsigned char b[16]; };\nA a;\nB *b = new (a.a + 8) B; // a.a provides storage for *b\nint *p = new (b-&gt;b + 4) int; // b-&gt;b provides storage for *p\n// a.a does not provide storage for *p (directly),\n// but *p is nested within a (see below)\n</code></pre>\n</blockquote>\n<p>So in the example, the <code>buffer</code> array <em>provides storage</em> for both <code>*p1</code> and <code>*p2</code>.</p>\n<p>The following paragraphs prove that the complete object for both <code>*p1</code> and <code>*p2</code> is <code>buffer</code>:</p>\n<blockquote>\n<p id=\"so_48062346_48065437_2\">4 An object a is nested within another object b if: <br/>\n  (4.1) \u2014 a is a subobject of b, or <br/>\n  (4.2) \u2014 b provides storage for a, or <br/>\n  (4.3) \u2014 there exists an object c where a is nested within c, and c is nested within b.</p>\n<p id=\"so_48062346_48065437_3\">5 For every object x, there is some object called the complete object of x, determined as follows: <br/>\n  (5.1) \u2014 If x is a complete object, then the complete object of x is itself. <br/>\n  (5.2) \u2014 Otherwise, the complete object of x is the complete object of the (unique) object that contains x. <br/></p>\n</blockquote>\n<p>Once this is established, the other relevant part of draft n4659 for C++17 is [basic.coumpound] \u00a73(emphasize mine):</p>\n<blockquote>\n<p id=\"so_48062346_48065437_4\">3 ... Every\n  value of pointer type is one of the following: <br/>\n  (3.1) \u2014 a pointer to an object or function (the pointer is said to point to the object or function), or <br/>\n  (3.2) \u2014 a pointer past the end of an object (8.7), or <br/>\n  (3.3) \u2014 the null pointer value (7.11) for that type, or <br/>\n  (3.4) \u2014 an invalid pointer value.</p>\n<p id=\"so_48062346_48065437_5\">A value of a pointer type that is a pointer to or past the end of an object represents the address of the\n  first byte in memory (4.4) occupied by the object <strong>or the first byte in memory after the end of the storage</strong>\n  occupied by the object, respectively. [ Note: A pointer past the end of an object (8.7) is not considered to\n  point to an <strong>unrelated</strong> object of the object\u2019s type that might be located at that address. A pointer value\n  becomes invalid when the storage it denotes reaches the end of its storage duration; see 6.7. \u2014end note ]\n  For purposes of pointer arithmetic (8.7) and comparison (8.9, 8.10), a pointer past the end of the last element\n  of an array x of n elements is considered to be equivalent to a pointer to a hypothetical element x[n]. The\n  value representation of pointer types is implementation-defined. Pointers to layout-compatible types shall\n  have the same value representation and alignment requirements (6.11)...</p>\n</blockquote>\n<p>The note <em>A pointer past the end...</em> does not apply here because the objects pointed to by <code>p1</code> and <code>p2</code> and not <em>unrelated</em>, but are nested into the same complete object, so pointer arithmetics make sense inside the object that provide storage: <code>p2 - p1</code> is defined and is <code>(&amp;buffer[sizeof(int)] - buffer]) / sizeof(int)</code> that is 1.</p>\n<p>So <code>p1 + 1</code> <strong>is</strong> a pointer to <code>*p2</code>, and <code>*(p1 + 1) = 10;</code> has defined behaviour and sets the value of <code>*p2</code>.</p>\n<hr>\n<p>I have also read the C4 annex on the compatibility between C++14 and current (C++17) standards. Removing the possibility to use pointer arithmetics between objects dynamically created in a single character array would be an important change that IMHO should be cited there, because it is a commonly used feature. As nothing about it exist in the compatibility pages, I think that it confirms that it was not the intent of the standard to forbid it.</p>\n<p>In particular, it would defeat that common dynamic construction of an array of objects from a class with no default constructor:</p>\n<pre><code>class T {\n    ...\n    public T(U initialization) {\n        ...\n    }\n};\n...\nunsigned char *mem = new unsigned char[N * sizeof(T)];\nT * arr = reinterpret_cast&lt;T*&gt;(mem); // See the array as an array of N T\nfor (i=0; i&lt;N; i++) {\n    U u(...);\n    new(arr + i) T(u);\n}\n</code></pre>\n<p><code>arr</code> can then be used as a pointer to the first element of an array...</p>\n</hr>", "LastEditorUserId": "63550", "LastActivityDate": "2018-01-03T10:54:33.580", "Score": "8", "CreationDate": "2018-01-02T17:40:47.867", "ParentId": "48062346", "CommentCount": "16", "OwnerUserId": "3545273", "LastEditDate": "2018-01-03T10:54:33.580"}});