post_cb({"bq_ids": {"n4140": {"so_47933345_47933345_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 336}}, "n3337": {"so_47933345_47933345_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 293}}, "n4659": {"so_47933345_47933345_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 345}}}, "47933602": {"Id": "47933602", "PostTypeId": "2", "Body": "<p>You may make happy both compilers with non deducible type:</p>\n<pre><code>template &lt;typename T&gt;\nstruct non_deducible {\n    using type = T;  \n};\n\ntemplate &lt;typename T&gt; using non_deducible_t = typename non_deducible&lt;T&gt;::type;\n\n\ntemplate &lt;typename... TListElems, typename... TVectorElems&gt;\nvoid foo(std::tuple&lt;TListElems...&gt;*,\n         std::tuple&lt;TVectorElems...&gt;*,\n         void (*)(non_deducible_t&lt;std::list&lt;TListElems&gt;&gt;...,\n                  non_deducible_t&lt;std::vector&lt;TVectorElems&gt;&gt;...))\n{\n    // blah blah blah\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fa2b726e432b9912\" rel=\"nofollow noreferrer\">Demo</a></p>\n", "LastActivityDate": "2017-12-21T22:33:07.000", "Score": "2", "CreationDate": "2017-12-21T22:33:07.000", "ParentId": "47933345", "CommentCount": "1", "OwnerUserId": "2684539"}, "47934037": {"Id": "47934037", "PostTypeId": "2", "Body": "<p>I think clang is right here. </p>\n<p>In <code>void (*)(std::list&lt;TListElems&gt;..., std::vector&lt;TVectorElems&gt;...)</code>, <code>TListElems...</code> is <a href=\"http://eel.is/c++draft/temp.deduct.type#5.7\" rel=\"nofollow noreferrer\">a non-deduced context</a>, which makes <code>TVectorElems...</code> also <a href=\"http://eel.is/c++draft/temp.deduct.type#6\" rel=\"nofollow noreferrer\">a non-deduced context</a>. But both parameter packs <em>are</em> deducible from the two tuple pointer arguments, and it's expected to be able to just <a href=\"http://eel.is/c++draft/temp.deduct.type#4.sentence-3\" rel=\"nofollow noreferrer\">use that deduction result</a> here too.</p>\n<p>I filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83542\" rel=\"nofollow noreferrer\">gcc bug 83542</a>.</p>\n", "LastActivityDate": "2017-12-21T23:23:13.460", "Score": "3", "CreationDate": "2017-12-21T23:23:13.460", "ParentId": "47933345", "CommentCount": "1", "OwnerUserId": "2069064"}, "47933345": {"ViewCount": "135", "Body": "<p>I am trying to write a function which takes another function, using parameter packs and some standard matching rules. As an example:</p>\n<pre><code>template &lt;typename... TListElems, typename... TVectorElems&gt;\nvoid goal(void (*fn)(std::list&lt;TListElems&gt;..., std::vector&lt;TVectorElems&gt;...));\n</code></pre>\n<p>In order to disambiguate <code>TListElems</code> and <code>TVectorElems</code>, I added some <code>std::tuple&lt;T...&gt;*</code> so a caller can be explicit:</p>\n<pre><code>template &lt;typename... TListElems, typename... TVectorElems&gt;\nvoid foo(std::tuple&lt;TListElems...&gt;*,\n         std::tuple&lt;TVectorElems...&gt;*,\n         void (*)(std::list&lt;TListElems&gt;..., std::vector&lt;TVectorElems&gt;...))\n{\n    // blah blah blah\n}\n\nvoid bar(std::list&lt;int&gt;, std::list&lt;unsigned&gt;, std::vector&lt;float&gt;, std::vector&lt;double&gt;)\n{\n    // blah blah blah\n}\n\nint main()\n{\n    foo((std::tuple&lt;int, unsigned&gt;*) nullptr,\n        (std::tuple&lt;float, double&gt;*) nullptr,\n        &amp;bar);\n}\n</code></pre>\n<p>Clang happily compiles this in the way I would expect, while g++ (7.2.1) gives the compilation error:</p>\n<pre><code>matching.cpp: In function \u2018int main()\u2019:\nmatching.cpp:20:13: error: no matching function for call to \u2018foo(std::tuple&lt;int, unsigned int&gt;*, std::tuple&lt;float, double&gt;*, void (*)(std::list&lt;int&gt;, std::list&lt;unsigned int&gt;, std::vector&lt;float&gt;, std::vector&lt;double&gt;))\u2019\n         &amp;bar);\n             ^\nmatching.cpp:6:6: note: candidate: template&lt;class ... TListElems, class ... TVectorElems&gt; void foo(std::tuple&lt;_Tps ...&gt;*, std::tuple&lt;_Elements ...&gt;*, void (*)(std::list&lt;TListElems&gt;..., std::vector&lt;TVectorElems&gt;...))\n void foo(std::tuple&lt;TListElems...&gt;*,\n      ^~~\nmatching.cpp:6:6: note:   template argument deduction/substitution failed:\nmatching.cpp:20:13: note:   mismatched types \u2018std::vector&lt;TVectorElems&gt;\u2019 and \u2018std::list&lt;int&gt;\u2019\n         &amp;bar);\n             ^\n</code></pre>\n<p>In <code>main</code>, I would <em>expect</em> the call to <code>foo</code> to deduce <code>TListElems</code> as <code>&lt;int, unsigned&gt;</code> and <code>TVectorElems</code> as <code>&lt;float, double&gt;</code>, leading <code>fn</code> to be of type <code>void (*)(std::list&lt;int&gt;, std::list&lt;unsigned&gt;, std::vector&lt;float&gt;, std::vector&lt;double&gt;)</code> (the way things operate when there is only one pack or if I had manually written the overload).</p>\n<p>\u00a714.8.2.5/10 is the closest the Standard comes to explicitly preventing the <code>foo</code> example from working:</p>\n<blockquote>\n<p id=\"so_47933345_47933345_0\">[Note: A function parameter pack can only occur at the end of a parameter-declaration-list (8.3.5). -end note]</p>\n</blockquote>\n<p>The <code>std::list&lt;TListElems&gt;...</code> bit of <code>fn</code> seems like it would violate this note, but that's not entirely clear.</p>\n<p>The question is: Who is right? GCC, Clang, or something else?</p>\n", "AcceptedAnswerId": "47934037", "Title": "Parameter Pack Matching Rules with Multiple Packs", "CreationDate": "2017-12-21T22:06:05.530", "LastActivityDate": "2017-12-21T23:23:13.460", "CommentCount": "0", "LastEditDate": "2017-12-21T22:38:37.493", "PostTypeId": "1", "LastEditorUserId": "3043539", "Id": "47933345", "Score": "6", "OwnerUserId": "254306", "Tags": "<c++><c++11><templates><language-lawyer><variadic-templates>", "AnswerCount": "2"}});