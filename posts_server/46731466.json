post_cb({"46736909": {"ParentId": "46731466", "CommentCount": "0", "Body": "<p>No, you can't. See \u00a716.3p2 <code>[cpp.replace]</code> of the C++ standard (similar wording found in other versions and in the equivalent section of the C standard; nothing has changed) (emphasis mine):</p>\n<blockquote>\n<p id=\"so_46731466_46736909_0\">An identifier currently defined as an object-like macro (see below) may be redefined by another <code>#define</code> preprocessing directive <em>provided that the second definition is an object-like macro definition</em> and the two\n  replacement lists are identical, otherwise the program is ill-formed. Likewise, an identifier currently defined as a function-like macro (see below) may be redefined by another <code>#define</code> preprocessing directive <em>provided that the second definition is a function-like macro definition</em> that has the same number and spelling of parameters, and the two replacement lists are identical, otherwise the program is ill-formed.</p>\n</blockquote>\n<p>In other words, a macro identifier is either object-like or function-like, but the same identifier cannot be used for both.</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "46736909", "Score": "0", "CreationDate": "2017-10-13T19:36:47.973", "LastActivityDate": "2017-10-13T19:36:47.973"}, "46731466": {"CommentCount": "9", "ViewCount": "65", "PostTypeId": "1", "LastEditorUserId": "3594072", "CreationDate": "2017-10-13T13:47:43.947", "LastActivityDate": "2017-10-13T19:36:47.973", "Title": "Is it possible to have a function-like macro and an object-like macro over the same char sequence?", "AcceptedAnswerId": "46736909", "LastEditDate": "2017-10-13T14:54:12.127", "Id": "46731466", "Score": "0", "Body": "<p>My problem is this - I tried to make a Heap checker to be used in testing and for this</p>\n<p>a) overload standard global new/delete operators so that they let my custom class know about each alloc and delete</p>\n<p>b) add custom new operators that have a signature like </p>\n<pre><code>void* operator new(size_t size, const char* filename, const char* function, int line)\n</code></pre>\n<p>c) make a macro that replaces standard new calls with my new calls and the given file, func &amp; line</p>\n<pre><code>#define new new(__FILE__, __FUNCTION__, __LINE__)\n</code></pre>\n<ul>\n<li>this works well, except for cases where somebody uses a custom new in a class or <strong>operator new()</strong> directly - that means that I can only define this macro after loading in standard C++ libs (functional, algo, string...), as they are heavy on doing that stuff</li>\n</ul>\n<p>d) so we came up with the brilliant idea of using var-arg macro which would solve these problems</p>\n<pre><code>#define new(...) new(__VA_ARGS__, __FILE__, __FUNCTION__, __LINE__)\n</code></pre>\n<ul>\n<li><p>this works well for all the problematic cases in the last point, as any parameters passed to either <strong>new (someargs)</strong> or operator <strong>new(size_t, someargs)</strong> gets replaced by the var-arg macro and sent into my custom new operators</p></li>\n<li><p><strong>But</strong> it doesn't work for the most usual case of just calling:</p></li>\n</ul>\n<p>int* ptr = new int;</p>\n<ul>\n<li>because the <strong>new</strong> call doesn't have  parentheses, therefore it's not expanded as a function macro</li>\n</ul>\n<p>Which brings me to the question mentioned in the title :\nIs there any way to do this with macros so that one would be able to replace the same character sequence in original code no matter whether it's called without a parameter list or with one?</p>\n<p>The desired result in this case would be:</p>\n<p>new without parentheses after it - <code>new -&gt; new(__file__, __func__, __line__)</code></p>\n<p>new with parentheses after it - <code>new(args) -&gt; new(args, __file__, __func__, __line__)</code></p>\n<p>I realize that this is an obvious case of trying to redefine the same macro, so it shouldn't be possible. I'm looking for some preprocessor magic that would let me get around that.</p>\n<p>Disclaimer : I know it's ugly and we actually settled on the solution in c) with simply ignoring the standard library <strong>new</strong>s. But as I did spend some time researching the possibility I'd be interested if anyone has a potential way to do this.</p>\n<p>Cheerios!</p>\n<p><strong>___EDIT___</strong>\nPlease don't concentrate on what I'm trying to accomplish but only on the question in the title. The Heap Checker itself can be implemented in a variety of standard-compliant ways and this is not one of them :) It's more of my curiosity as to how much it's possible to bend the language with the preprocessor.</p>\n<p>The question stands - can I use some preprocessor commands to achieve a different behaviour for the same sequence with and without parentheses after it (that is, something that works just as if I had both a function-like and object-like macro of the same name)</p>\n<p>Thanks for any and all answers :)</p>\n", "Tags": "<c++><macros>", "OwnerUserId": "3594072", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46731466_46736909_0": {"section_id": 512, "quality": 0.8909090909090909, "length": 49}}, "n3337": {"so_46731466_46736909_0": {"section_id": 503, "quality": 0.8909090909090909, "length": 49}}, "n4659": {"so_46731466_46736909_0": {"section_id": 533, "quality": 0.9636363636363636, "length": 53}}}});