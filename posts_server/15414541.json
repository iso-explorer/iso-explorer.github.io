post_cb({"15414684": {"ParentId": "15414541", "CommentCount": "5", "Body": "<p>Instead of iterators, use a <code>vector</code> and store index values. They'll survive any restructuring. Iterators are primarily intended for use in pairs that designate a range; hanging on to individual iterators gets messy, as you've seen.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "15414684", "Score": "0", "CreationDate": "2013-03-14T16:19:48.583", "LastActivityDate": "2013-03-14T16:19:48.583"}, "15414926": {"ParentId": "15414541", "LastEditDate": "2013-03-14T16:37:20.723", "CommentCount": "1", "CreationDate": "2013-03-14T16:30:47.127", "OwnerUserId": "13005", "LastEditorUserId": "13005", "PostTypeId": "2", "Id": "15414926", "Score": "6", "Body": "<p>23.2.4/9 says of Associative Containers:</p>\n<blockquote>\n<p id=\"so_15414541_15414926_0\">The insert and emplace members shall not affect the validity of\n  iterators and references to the container, and the erase members shall\n  invalidate only iterators and references to the erased elements</p>\n</blockquote>\n<p>Now, there are some places where the standard talks about not invalidating \"iterators and references to elements of the container\", thus excluding <code>end()</code>. I don't believe that this is one of them - I'm pretty sure that an <code>end()</code> iterator is an \"iterator to the container\".</p>\n<p>23.3.5.4/1 says for <code>std::list</code> that <code>insert</code> \"Does not affect the validity of iterators and references\", and 23.3.5.4/3 says that <code>erase</code> \"invalidates only the iterators and references to the erased elements\". Again, <code>end()</code> iterators are iterators and so their validity isn't excluded.</p>\n<p>One thing to watch out for is that for any container, <code>swap</code> can invalidate end() iterators (I assume this is because there are two \"natural\" behaviors, either that the end iterator points to the end of the same container or else to the end of the one it was swapped with, but the standard doesn't want to dictate which or rule out other possibilities). But you aren't swapping, just adding and removing elements.</p>\n", "LastActivityDate": "2013-03-14T16:37:20.723"}, "15414541": {"CommentCount": "7", "AcceptedAnswerId": "15414926", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2013-03-14T16:13:18.940", "LastActivityDate": "2013-03-14T16:41:58.653", "LastEditDate": "2013-03-14T16:24:48.593", "ViewCount": "577", "FavoriteCount": "1", "Title": "For which standard container, if any, is the iterator returned by end() persistent?", "Id": "15414541", "Score": "1", "Body": "<p>I need a way to quickly access data in a container.</p>\n<p>So I remember iterator of that data position. Container maybe modified (elements added and removed) after that, but if I use container type that does not invalidate my iterator (like <code>std::map</code> or <code>std::list</code>) I am fine.</p>\n<p>Also my data may not be in the container (yet), so I set an iterator to <code>container.end()</code> to reflect that.</p>\n<p>Which standard container guarantees that <code>end()</code> would not change when elements added and removed? So I can still compare my iterator to the value returned by <code>container.end()</code> and not get false negative.</p>\n", "Tags": "<c++><containers>", "OwnerUserId": "432358", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_15414541_15414926_0": {"section_id": 745, "quality": 0.9375, "length": 15}}, "n3337": {"so_15414541_15414926_0": {"section_id": 734, "quality": 0.9375, "length": 15}}, "n4659": {"so_15414541_15414926_0": {"section_id": 803, "quality": 0.9375, "length": 15}}}, "15414677": {"CommentCount": "8", "CreationDate": "2013-03-14T16:19:38.880", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-14T16:41:58.653", "ParentId": "15414541", "PostTypeId": "2", "LastEditorDisplayName": "user1357649", "LastEditDate": "2017-05-23T10:26:37.750", "Id": "15414677", "Score": "3", "Body": "<p>From my experience, iterators from <code>std::vector</code> and <code>std::dequeue</code> break upon resizing from erasure or addition (this applies to <code>std::string</code>'s storage as well). <code>std::list</code> and <code>std::map</code> don't allocate blocks of memory: they usually allocate individual nodes (and most <code>std::unordered_map</code> implementations have buckets as a linked list of items (e.g., <code>std::list</code>)).</p>\n<p>If you need to have a surviving <code>end()</code> iterator, choose a <code>std::list</code> (I do this for my Signal/Slots implementation, for their tokens) or do your own personal bookkeeping with <code>std::vector</code>/<code>std::dequeue</code>.</p>\n<p><strong><em>EDIT</em></strong>:\nSo, <code>std::list</code> is a good way to have your iterators be always valid, provided your list itself never dies (which they aren't). From another answer, if you need standardese clarity:</p>\n<blockquote>\n<p id=\"so_15414541_15414677_0\">23.3.5.4/1 says for std::list that insert \"Does not affect the validity of iterators and references\", and 23.3.5.4/3 says that erase \"invalidates only the iterators and references to the erased elements\". Again, end() iterators are iterators and so their validity isn't excluded. - <a href=\"https://stackoverflow.com/a/15414926/1357649\">Another Answer</a></p>\n</blockquote>\n", "OwnerDisplayName": "user1357649"}});