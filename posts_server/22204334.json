post_cb({"bq_ids": {"n4140": {"so_22204334_22204487_2": {"length": 32, "quality": 0.8888888888888888, "section_id": 3367}, "so_22204334_22204487_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 3367}}, "n3337": {"so_22204334_22204487_2": {"length": 32, "quality": 0.8888888888888888, "section_id": 3237}, "so_22204334_22204487_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 3237}}, "n4659": {"so_22204334_22204487_1": {"length": 13, "quality": 0.5909090909090909, "section_id": 4132}}}, "22204526": {"Id": "22204526", "PostTypeId": "2", "Body": "<p>Just use the usual programming by contract pattern: make the\npure virtual functions private, and provide a non-virtual\nfunction to check pre- and post-conditions and call the virtual.\nSomething like: </p>\n<pre><code>class C\n{\n    virtual double doCalculate( double n ) = 0;\npublic:\n    double calculate( double n ) {\n        if ( n &lt; 0.0 )\n            throw whatever();\n        return doCalculate( n );\n    }\n};\n</code></pre>\n", "LastActivityDate": "2014-03-05T17:12:26.527", "CommentCount": "0", "CreationDate": "2014-03-05T17:12:26.527", "ParentId": "22204334", "Score": "2", "OwnerUserId": "649665"}, "22204516": {"Id": "22204516", "PostTypeId": "2", "Body": "<p>Yes, you can do that.</p>\n<p>In the base class, you'll want to have two groups of functions:</p>\n<ul>\n<li>Public, non-virtual functions that users of the class will call.</li>\n<li>Protected, pure-virtual functions that will be implemented by the derived classes.</li>\n</ul>\n<p>In the base class's public non-virtual functions, you can do any necessary argument checking, e.g. making sure that the argument isn't negative.  Throw exceptions as necessary.  Then, if the argument checks pass, call the corresponding virtual function to let the derived class do the rest.</p>\n<hr>\n<p>Also, note that if negative numbers don't make sense for your function's arguments, it may be simper to just use unsigned types for those arguments.</p>\n</hr>", "LastActivityDate": "2014-03-05T17:11:59.523", "CommentCount": "3", "CreationDate": "2014-03-05T17:11:59.523", "ParentId": "22204334", "Score": "0", "OwnerUserId": "226975"}, "22204334": {"ViewCount": "530", "Body": "<p>Currently in my project I am making a virtual abstract base class and three derived class. In the base class's pure virtual function is used in the derived classes to create an equation that will either add or subtract with two variables. My problem is that I also have to include a function to check if one of the variables put into the function is negative that will throw an exception if it is. Currently I put these functions and the exceptions into the derived classes but to me it seems a little redundant. So I am wondering if it is allowed to put the function to check to see if the variable I'm checking is negative and have the exception thrown both in the abstract base class?</p>\n", "AcceptedAnswerId": "22204516", "Title": "Can I make virtual abstract class throw an exception", "CreationDate": "2014-03-05T17:04:01.677", "Id": "22204334", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-03-05T17:16:54.047", "Score": "1", "OwnerUserId": "2340686", "Tags": "<c++><function><class><virtual><abstract>", "AnswerCount": "3"}, "22204487": {"Id": "22204487", "PostTypeId": "2", "Body": "<p>Yes, abstract class can throw exceptions from its functions. You should bare in mind however that</p>\n<blockquote>\n<p id=\"so_22204334_22204487_0\">n3337 <strong>\u00a7</strong> 15.4/5:</p>\n<p id=\"so_22204334_22204487_1\">If a virtual function has an exception-specification, all\n  declarations, including the definition, of any function that overrides\n  that virtual function in any derived class shall only allow exceptions\n  that are allowed by the exception-specification of the base class\n  virtual function. [ Example:</p>\n</blockquote>\n<pre><code>struct B {\n  virtual void f() throw (int, double);\n  virtual void g();\n};\nstruct D: B {\n  void f();\n  void g() throw (int);\n};\n</code></pre>\n<blockquote>\n<p id=\"so_22204334_22204487_2\">The declaration of <code>D::f</code> is ill-formed because it allows all\n  exceptions, whereas <code>B::f</code> allows only <code>int</code> and <code>double</code>. \u2014 end example ] A\n  similar restriction applies to assignment to and initialization of\n  pointers to functions, pointers to member functions, and references to\n  functions: the target entity shall allow at least the exceptions\n  allowed by the source value in the assignment or initialization. [\n  Example:</p>\n</blockquote>\n<pre><code>class A { /\u2217 ... \u2217/ };\nvoid (*pf1)();  // no exception specification\nvoid (*pf2)() throw(A);\n\nvoid f() {\n  pf1 = pf2;  // OK: pf1 is less restrictive\n  pf2 = pf1;  // error: pf2 is more restrictive\n}\n</code></pre>\n<blockquote>\n<p id=\"so_22204334_22204487_3\">\u2014 end example ]</p>\n</blockquote>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-03-05T17:16:54.047", "Score": "1", "CreationDate": "2014-03-05T17:10:35.367", "ParentId": "22204334", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-03-05T17:16:54.047"}});