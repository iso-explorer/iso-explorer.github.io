post_cb({"bq_ids": {"n4140": {"so_37103718_37103824_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}}, "n3337": {"so_37103718_37103824_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}}, "n4659": {"so_37103718_37103824_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}}}, "37103718": {"ViewCount": "106", "Body": "<p>In case I have two methods - one public, one protected that return the reference to same member, I get following compilation error:</p>\n<pre><code>'Server::getManager': cannot access protected member declared in class 'Server'\n</code></pre>\n<p>When I comment out protected function, code works. Could you please advise why this is happening?  Why the compiler cannot find the public function to same member?</p>\n<pre><code>class Manager\n    {\n    };\n\nclass Server\n{\npublic:\n    const Manager &amp; getManager() const { return m_man; }\nprotected:\n    Manager &amp; getManager() { return m_man;  } // &lt;-- after removing this method I get no compilation error\n\nprivate:\n\n    Manager m_man;\n};\n\nint main()\n{\n\n    Server s;\n    const Manager&amp; m = s.getManager();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "37103824", "Title": "c++ how to create public and protected accessors to same member", "CreationDate": "2016-05-08T19:02:17.553", "Id": "37103718", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-05-08T19:19:29.617", "Score": "6", "OwnerUserId": "2329332", "Tags": "<c++><public-method>", "AnswerCount": "1"}, "37103824": {"Id": "37103824", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37103718_37103824_0\">Why the compiler cannot find the public function to same member?</p>\n</blockquote>\n<p>That's not the issue. The compiler finds <em>both</em> functions and performs overload resolution to determine which is the best viable candidate. The two candidates are:</p>\n<pre><code>Manager&amp;       getManager()        // protected\nManager const&amp; getManager() const  // public\n</code></pre>\n<p>For member functions, there is an implicit first object parameter that is the instance of the class itself. In this case, the two functions become:</p>\n<pre><code>getManager(Server&amp; )         // protected\ngetManager(Server const&amp; )   // public\n</code></pre>\n<p>We're invoking it on an object (<code>s</code>) that is not <code>const</code>. Both candidates are viable, but the <code>public</code> candidate takes a reference to a <em>more</em> <em>cv</em>-qualified object than the <code>protected</code> candidate - so it's less preferred. The standardese is in [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_37103718_37103824_1\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if<br>\n  \u2014 S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers\n  is more cv-qualified than the type to which the reference initialized by S1 refers.</br></p>\n</blockquote>\n<p>As a result, the <code>protected</code> candidate is preferred - so that's the one that's called.</p>\n<p>Unfortunately, it's <code>protected</code>, so calling it is ill-formed. The access control is checked after overload resolution. So you'll have to restructure your program somehow. You could simply cast <code>s</code> to <code>const</code>:</p>\n<pre><code>const Manager&amp; m = const_cast&lt;Server const&amp;&gt;(s).getManager();\n</code></pre>\n<p>This would make the <code>protected</code> candidate non-viable. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-05-08T19:19:29.617", "Score": "6", "CreationDate": "2016-05-08T19:12:49.833", "ParentId": "37103718", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2016-05-08T19:19:29.617"}});