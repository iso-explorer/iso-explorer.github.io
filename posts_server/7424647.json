post_cb({"7424647": {"ViewCount": "2025", "Body": "<p>This is valid, because a <code>constexpr</code> expression is allowed to take the value of \"a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers to a sub-object of such an object\" (\u00a75.19/2):</p>\n<pre><code>constexpr char str[] = \"hello, world\";\nconstexpr char e = str[1];\n</code></pre>\n<p>However, it would seem that string literals do not fit this description:</p>\n<pre><code>constexpr char e = \"hello, world\"[1]; // error: literal is not constexpr\n</code></pre>\n<p>2.14.5/8 describes the type of string literals:</p>\n<blockquote>\n<p id=\"so_7424647_7424647_0\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration.</p>\n</blockquote>\n<p>It would seem that an object of this type could be indexed, if only it were temporary and not of static storage duration (5.19/2, right after the above snippet):</p>\n<blockquote>\n<p id=\"so_7424647_7424647_1\">[<code>constexpr</code> allows lvalue-to-rvalue conversion of] \u2026 a glvalue of literal type that refers to a non-volatile temporary object whose lifetime has not ended, initialized with a constant expression</p>\n</blockquote>\n<p>This is particularly odd since taking the lvalue of a temporary object is usually \"cheating.\" I suppose this rule applies to function arguments of reference type, such as in</p>\n<pre><code>constexpr char get_1( char const (&amp;str)[ 6 ] )\n    { return str[ 1 ]; }\n\nconstexpr char i = get_1( { 'y', 'i', 'k', 'e', 's', '\\0' } ); // OK\nconstexpr char e = get_1( \"hello\" ); // error: string literal not temporary\n</code></pre>\n<p>For what it's worth, GCC 4.7 accepts <code>get_1( \"hello\" )</code>, but rejects <code>\"hello\"[1]</code> because \"the value of \u2018._0\u2019 is not usable in a constant expression\"\u2026 yet <code>\"hello\"[1]</code> <em>is</em> acceptable as a case label or an array bound.</p>\n<p>I'm splitting some Standardese hairs here\u2026 is the analysis correct, and was there some design intent for this feature?</p>\n<p><strong>EDIT:</strong> Oh\u2026 there is some motivation for this. It seems that this sort of expression is the only way to use a lookup table in the preprocessor. For example, this introduces a block of code which is ignored unless <code>SOME_INTEGER_FLAG</code> is 1 or 5, and causes a diagnostic if greater than 6:</p>\n<pre><code>#if \"\\0\\1\\0\\0\\0\\1\"[ SOME_INTEGER_FLAG ]\n</code></pre>\n<p>This construct would be new to C++11.</p>\n", "AcceptedAnswerId": "7436323", "Title": "Can a string literal be subscripted in a constant expression?", "CreationDate": "2011-09-15T00:40:23.660", "Id": "7424647", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-01-27T19:18:56.253", "LastEditorUserId": "500104", "LastActivityDate": "2012-02-17T00:07:28.807", "Score": "17", "OwnerUserId": "153285", "Tags": "<c++><c++11><string-literals><constexpr>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7424647_7424647_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6185}, "so_7424647_7424647_0": {"length": 26, "quality": 1.0, "section_id": 5356}}, "n3337": {"so_7424647_7424647_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 5946}, "so_7424647_7424647_0": {"length": 26, "quality": 1.0, "section_id": 5153}}, "n4659": {"so_7424647_7424647_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7687}, "so_7424647_7424647_0": {"length": 26, "quality": 1.0, "section_id": 6781}}}, "9321083": {"Id": "9321083", "PostTypeId": "2", "Body": "<p>Regarding your question about <code>#if</code>, it was not the intent of the standards committee to increase the set of expressions which can be used in the preprocessor, and the current wording is considered to be a defect. This will be listed as core issue 1436 in the post-Kona WG21 mailing. Thanks for bringing this to our attention!</p>\n", "LastActivityDate": "2012-02-17T00:07:28.807", "CommentCount": "1", "CreationDate": "2012-02-17T00:07:28.807", "ParentId": "7424647", "Score": "1", "OwnerUserId": "1041090"}, "7436323": {"Id": "7436323", "PostTypeId": "2", "Body": "<p>The intent is that this works and the paragraphs that state when an lvalue to rvalue conversion is valid will <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1293\" rel=\"noreferrer\">be amended with a note</a> that states that an lvalue that refers to a subobject of a string literal is a constant integer object initialized with a constant expression (which is described as one of the allowed cases) in a post-C++11 draft.</p>\n<p>Your comment about the use within the preprocessor looks interesting but I'm unsure whether that is intended to work. I hear about this the first time at all.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-09-15T19:32:26.430", "Score": "6", "CreationDate": "2011-09-15T19:24:45.477", "ParentId": "7424647", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2011-09-15T19:32:26.430"}});