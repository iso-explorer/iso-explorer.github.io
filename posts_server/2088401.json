post_cb({"2088439": {"LastActivityDate": "2010-01-18T18:52:15.453", "ParentId": "2088401", "Id": "2088439", "Score": "1", "Body": "<p>The standard requires that the order of arrangement in memory match the order of definition, but allows arbitrary padding between them. If you have an access specifier (<code>public:</code>, <code>private:</code> or <code>protected:</code>) between members, even the guarantee about order is lost.</p>\n<p>Edit: in the specific case of all three members being of the same primitive type (i.e. not themselves structs or anything like that) you stand a pretty fair chance -- for primitive types, the object's size and alignment requirements are often the same, so it works out. </p>\n<p>OTOH, this is only by accident, and tends to be more of a weakness than a strength; the code is wrong, so ideally it would fail immediately instead of appearing to work, right up to the day that you're giving a demo for the owner of the company that's going to be your most important customer, at which time it will (of course) fail in the most heinous possible fashion...</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "179910", "CreationDate": "2010-01-18T18:52:15.453"}, "bq_ids": {"n3337": {"so_2088401_2088428_0": {"section_id": 5650, "quality": 0.8611111111111112, "length": 31}}}, "2088811": {"LastActivityDate": "2010-01-18T20:01:30.473", "ParentId": "2088401", "Id": "2088811", "Score": "2", "Body": "<p>When in doubt, change the data structure to suit the application: </p>\n<pre><code>struct xyz\n{\n    float  p[3];\n};  \n</code></pre>\n<p>For readability you may want to consider:</p>\n<pre><code>struct xyz\n{\n    enum { x_index = 0, y_index, z_index, MAX_FLOATS};\n    float p[MAX_FLOATS];\n\n    float  X(void) const {return p[x_index];}\n    float  X(const float&amp; new_x) {p[x_index] = new_x;}\n\n    float  Y(void) const {return p[y_index];}\n    float  Y(const float&amp; new_y) {p[y_index] = new_y;}\n\n    float  Z(void) const {return p[z_index];}\n    float  Z(const float&amp; new_z) {p[z_index] = new_z;}\n};\n</code></pre>\n<p>Perhaps even add some more encapsulation:</p>\n<pre><code>struct Functor\n{\n  virtual void operator()(const float&amp; f) = 0;\n};\n\nstruct xyz\n{\n  void for_each(Functor&amp; ftor)\n  {\n     ftor(p[0]);\n     ftor(p[1]);\n     ftor(p[2]);\n     return;\n  }\n  private:\n     float p[3];\n}\n</code></pre>\n<p>In general, if a data structure needs to be treated in two or more different ways, perhaps the data structure needs to be redesigned; or the code.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "225074", "CreationDate": "2010-01-18T20:01:30.473"}, "2088481": {"LastActivityDate": "2010-01-18T18:59:00.910", "ParentId": "2088401", "Id": "2088481", "Score": "1", "Body": "<p>No, you may not assume that there are no gaps.  You may check for you architecture, and if there aren't and you don't care about portability, it will be OK.</p>\n<p>But imagine a 64-bit architecture with 32-bit floats.  The compiler may align the struct's floats on 64-bit boundaries, and your </p>\n<pre><code>p[1]\n</code></pre>\n<p>will give you junk, and </p>\n<pre><code>p[2]\n</code></pre>\n<p>will give you what you think your getting from</p>\n<pre><code>p[1]\n</code></pre>\n<p>&amp;c.</p>\n<p>However, you compiler may give you some way to pack the structure.  It still wouldn't be \"standard\"---the standard provides no such thing, and different compilers provide very incompatible ways of doing this--- but it is likely to be more portable.</p>\n", "CommentCount": "3", "PostTypeId": "2", "OwnerUserId": "204190", "CreationDate": "2010-01-18T18:59:00.910"}, "11143600": {"LastActivityDate": "2012-06-21T17:33:43.000", "ParentId": "2088401", "Id": "11143600", "Score": "-1", "Body": "<p>I assume you want a struct to keep your coordinates accessed as members (.x, .y and .z) but you still want them to be accessed, let's say, an OpenGL way (as if it was an array).</p>\n<p>You can try implementing the [] operator of the struct so it can be accessed as an array. Something like:</p>\n<pre><code>struct xyz\n{\n  float x, y, z;\n  float&amp; operator[] (unsigned int i)\n  {\n    switch (i)\n    {\n    case 0:\n      return x;\n      break;\n    case 1:\n      return y;\n      break;\n    case 2:\n      return z;\n      break;\n    default:\n      throw std::exception\n      break;\n    }\n  }\n};\n</code></pre>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1389585", "CreationDate": "2012-06-21T17:33:43.000"}, "9126006": {"LastActivityDate": "2012-02-03T08:57:36.087", "ParentId": "2088401", "Id": "9126006", "Score": "1", "Body": "<p>Lets take a look at Doom III source code:</p>\n<pre><code>class idVec4 {\npublic: \n    float           x;\n    float           y;\n    float           z;\n    float           w;\n    ...\n    const float *   ToFloatPtr( void ) const;\n    float *         ToFloatPtr( void );\n    ...\n}\n\nID_INLINE const float *idVec4::ToFloatPtr( void ) const {\n    return &amp;x;\n}\n\nID_INLINE float *idVec4::ToFloatPtr( void ) {\n    return &amp;x;\n}\n</code></pre>\n<p>It works on many systems.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1065190", "CreationDate": "2012-02-03T08:57:36.087"}, "2088449": {"LastActivityDate": "2010-01-18T18:53:50.190", "ParentId": "2088401", "Id": "2088449", "Score": "0", "Body": "<p>Your code is OK (so long as it only ever handles data generated in the same environment). The structure will be laid out in memory as declared if it is POD. However, in general, there is a gotcha you need to be aware of: the compiler will insert padding into the structure to ensure each member's alignment requirements are obeyed.</p>\n<p>Had your example been</p>\n<pre><code>struct xyz\n{\n    float x;\n    bool y;\n    float z;\n};\n</code></pre>\n<p>then z would have began 8 bytes into the structure and sizeof(xyz) would have been 12 as <code>float</code>s are (usually) 4 byte aligned.</p>\n<p>Similarly, in the case</p>\n<pre><code>struct xyz\n{\n    float x;\n    bool y;\n};\n</code></pre>\n<p>sizeof(xyz) == 8, to ensure ((xyz*)ptr)+1 returns a pointer that obeys x's alignment requirements.</p>\n<p>Since alignment requirements / type sizes may vary between compilers / platforms, such code is not in general portable.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "11834", "CreationDate": "2010-01-18T18:53:50.190"}, "2088431": {"LastActivityDate": "2010-01-18T18:50:50.573", "ParentId": "2088401", "Id": "2088431", "Score": "2", "Body": "<p>Depends on the hardware. The standard explicitly allows POD classes to have unspecified and unpredictable padding. I noted this on the C++ Wikipedia page and grabbed the footnote with the spec reference for you.</p>\n<p>^ a b ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ \u00a79.2 Class members [class.mem] para. 17</p>\n<p>In practical terms, however, on common hardware and compilers it will be fine.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "131433", "CreationDate": "2010-01-18T18:50:50.573"}, "2088428": {"LastActivityDate": "2010-01-18T18:50:28.373", "ParentId": "2088401", "Id": "2088428", "Score": "4", "Body": "<p>No, it is not OK to do so except for the first field.</p>\n<p>From the C++ standards:</p>\n<blockquote>\n<p id=\"so_2088401_2088428_0\"><strong>9.2 Class members</strong><br>\n  A pointer to a POD-struct object,\n  suitably converted using a\n  reinterpret_cast, points to its\n  initial member (or if that member is a\n  bit-field, then to the unit in which\n  it resides) and vice versa. [Note:\n  There might therefore be unnamed\n  padding within a POD-struct object,\n  but not at its beginning, as necessary\n  to achieve appropriate alignment.</br></p>\n</blockquote>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "127893", "CreationDate": "2010-01-18T18:50:28.373"}, "2088446": {"LastActivityDate": "2010-01-18T18:53:19.273", "ParentId": "2088401", "Id": "2088446", "Score": "10", "Body": "<p>The answer here is a bit tricky.  The C++ standard says that POD data types will have C layout compatability guarantees (<a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2294.html\" rel=\"noreferrer\">Reference</a>).  According to section <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2294.html#class.mem\" rel=\"noreferrer\">9.2</a> of the C spec the members of a struct will be laid out in sequential order if </p>\n<ol>\n<li>There is no accessibility modifier difference</li>\n<li>No alignment issues with the data type </li>\n</ol>\n<p>So yes this solution will work as long as the type <code>float</code> has a compatible alignment on the current platform (it's the platform word size).  So this should work for 32 bit processors but my guess is that it would fail for 64 bit ones.  Essentially anywhere that <code>sizeof(void*)</code> is different than <code>sizeof(float)</code></p>\n", "CommentCount": "7", "PostTypeId": "2", "OwnerUserId": "23283", "CreationDate": "2010-01-18T18:53:19.273"}, "2088401": {"CreationDate": "2010-01-18T18:46:11.733", "AcceptedAnswerId": "2088446", "Tags": "<c++><c><pointers><layout><member>", "AnswerCount": "12", "OwnerUserId": "211885", "Body": "<p>Let's we have a simple structure (POD).</p>\n<pre><code>struct xyz\n{\n    float x, y, z;\n};\n</code></pre>\n<p>May I assume that following code is OK? May I assume there is no any gaps? What the standard says? Is it true for PODs? Is it true for classes?</p>\n<pre><code>xyz v;\nfloat* p = &amp;v.x;\np[0] = 1.0f;\np[1] = 2.0f; // Is it ok?\np[2] = 3.0f; // Is it ok?\n</code></pre>\n", "CommentCount": "3", "PostTypeId": "1", "ViewCount": "418", "FavoriteCount": "3", "LastActivityDate": "2012-07-16T08:51:24.230", "Id": "2088401", "LastEditorUserId": "1065190", "Title": "C++ member layout", "Score": "6", "LastEditDate": "2012-07-16T08:36:05.453"}, "11500889": {"LastActivityDate": "2012-07-16T08:51:24.230", "ParentId": "2088401", "Id": "11500889", "Score": "0", "Body": "<ol>\n<li>structure packing (eg <code>#pragma pack</code> in MSVC) <a href=\"http://msdn.microsoft.com/en-us/library/aa273913%28v=vs.60%29.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/aa273913%28v=vs.60%29.aspx</a></li>\n<li>variable alignment\n(eg <code>__declspec(align(</code> in MSVC) <a href=\"http://msdn.microsoft.com/en-us/library/83ythb65.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/83ythb65.aspx</a></li>\n</ol>\n<p>are two factors that can wreck your assumptions. floats are usually 4 bytes wide, so it's rare to misalign such large variables. But it's still easy to break your code.</p>\n<p>This issue is most visible when binary reading header struct with shorts (like BMP or TGA) - forgetting <code>pack 1</code> causes a disaster.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1059969", "CreationDate": "2012-07-16T08:51:24.230"}, "2088432": {"LastActivityDate": "2010-01-18T18:50:57.263", "ParentId": "2088401", "Id": "2088432", "Score": "5", "Body": "<p>This is not guaranteed by the standard, and will not work on many systems. The reasons are:</p>\n<ul>\n<li>The compiler may align struct members as appropriate for the target platform, which may mean 32-bit alignment, 64-bit alignment, or anything else.</li>\n<li>The size of the float might be 32 bits, or 64 bits. There's no guarantee that it's the same as the struct member alignment.</li>\n</ul>\n<p>This means that <code>p[1]</code> might be at the same location as <code>xyz.y</code>, or it might overlap partially, or not at all.</p>\n", "CommentCount": "4", "PostTypeId": "2", "OwnerUserId": "8078", "CreationDate": "2010-01-18T18:50:57.263"}, "2088531": {"LastActivityDate": "2010-01-18T19:07:34.647", "ParentId": "2088401", "Id": "2088531", "Score": "0", "Body": "<p>As others have pointed out the alignment is not guaranteed by the spec.  Many say it is hardware dependent, but actually it is also compiler dependent.   Hardware may support many different formats.  I remember that the PPC compiler support pragmas for how to \"pack\" the data.  You could pack it on 'native' boundaries or force it to 32 bit boundaries, etc.</p>\n<p>It would be nice to understand what you are trying to do.  If you are trying to 'parse' input data, you are better off with a real parser.  If you are going to serialize, then write a real serializer.   If you are trying to twiddle bits such as for a driver, then the device spec should give you a specific memory map to write to.  Then you can write your POD structure, specify the correct alignment pragmas (if supported) and move on.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "253194", "CreationDate": "2010-01-18T19:07:34.647"}});