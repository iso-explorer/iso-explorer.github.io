post_cb({"8096817": {"CommentCount": "3", "AcceptedAnswerId": "8097097", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2011-11-11T16:14:53.823", "LastActivityDate": "2011-12-26T03:54:41.367", "LastEditDate": "2011-11-11T16:33:56.413", "ViewCount": "1293", "FavoriteCount": "3", "Title": "Is NaN a valid key value for associative containers?", "Id": "8096817", "Score": "23", "Body": "<p>Consider the ordered and unordered associative containers in C++ keyed on <code>double</code>.</p>\n<p>Is <code>NaN</code> a valid key type?</p>\n<p>With ordered containers, I should say \"no\", because it does not respect the strict weak ordering.</p>\n<p>With unordered containers, I have no idea.</p>\n<p>Here's what happens in GCC 4.6.2:</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n\n#include &lt;cmath&gt;\n\n#include &lt;iostream&gt;\n#include &lt;prettyprint.hpp&gt;\n\nint main()\n{\n  typedef std::map&lt;double, int&gt; map_type; // replace by \"unorderd_map\"\n\n  map_type dm;\n  double d = std::acos(5); // a good nan\n\n  dm[d] = 2;\n  dm[d] = 5;\n  dm[d] = 7;\n\n  std::cout &lt;&lt; \"dm[NaN] = \" &lt;&lt; dm[d] &lt;&lt; \", dm = \" &lt;&lt; dm &lt;&lt; std::endl;\n}\n</code></pre>\n<p>For the ordered map, I get:</p>\n<pre><code>dm[NaN] = 7, dm = [(nan, 7)]\n</code></pre>\n<p>For the unordered map, I get:</p>\n<pre><code>dm[NaN] = 0, dm = [(nan, 0), (nan, 7), (nan, 5), (nan, 2)]\n</code></pre>\n<p>So in the ordered map, all NaNs are treated the same, which is what I expect, although it seemed like NaN would violate the requirements. For the unordered map, however, I can never retrieve an element again, and all NaNs are different. This is also not what I would expect.</p>\n<p>Does the standard have to say anything on this matter?</p>\n<p><strong>Update:</strong> Thanks to the great answers below, note that the <code>std::map</code> will break if you insert <em>anything else</em> into it once a NaN is in it.</p>\n<p>(I'd be very grateful for comments on how other languages handle floating point keys in associative containers.)</p>\n", "Tags": "<c++><map><nan><unordered-map>", "OwnerUserId": "596781", "AnswerCount": "3"}, "8096843": {"ParentId": "8096817", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This is because </p>\n<pre><code>std::less&lt;double&gt;(NaN, NaN) == false\n</code></pre>\n<p>Like you said, the <em>weak total ordering</em> (required for std::map&lt;&gt;) is ok, the equality (or <em>equivalence</em>, extra requirement for any hash-based container) isn't ok to satisfy the key requirements for the hash (unordered) map</p>\n<pre><code>Irreflexivity   f(x, x) must be false. \n Antisymmetry   f(x, y) implies !f(y, x) \n Transitivity   f(x, y) and f(y, z) imply f(x, z). \n Transitivity of equivalence     \n\n         Equivalence (as defined above) is transitive: if x \n         is equivalent to y and y is equivalent to z, then x is \n         equivalent to z. (This     implies that equivalence does \n         in fact satisfy the mathematical definition of an equivalence \n         relation.)\n</code></pre>\n<p>Seeing that for std::map, equivalence is when <code>!less(a,b) &amp;&amp; !less(b,a)</code>, I'd say all constraints are met.</p>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2011-11-11T16:24:19.307", "Id": "8096843", "Score": "5", "CreationDate": "2011-11-11T16:16:55.853", "LastActivityDate": "2011-11-11T16:24:19.307"}, "8097097": {"ParentId": "8096817", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>They are both forbidden by the standard.</p>\n<p>For the (ordered) associative containers, the definition of strict weak order (25.4/4) says:</p>\n<blockquote>\n<p id=\"so_8096817_8097097_0\">If we define <code>equiv(a, b)</code> as <code>!comp(a, b) &amp;&amp; !comp(b, a)</code>, then the\n  requirements are that <code>comp</code> and <code>equiv</code> both be transitive relations ...\n  <code>equiv(a, b) &amp;&amp; equiv(b, c)</code> implies <code>equiv(a, c)</code></p>\n</blockquote>\n<p>This fails for a = 0.0, b = NaN, c = 1.0, comp = <code>std::less&lt;double&gt;()</code></p>\n<p>For the unordered containers, 23.2.5/3 says that the equality predicate <code>Pred</code> \"induces an equivalence relation on values of type <code>Key</code>\". Equivalence relations are reflexive, and <code>std::equal_to&lt;double&gt;()(NaN,NaN)</code> is false, so <code>equal_to&lt;double&gt;()</code> is not an equivalence relation.</p>\n<p>By the way, keying containers on a double is slightly scary in the same way that comparing doubles for equality is always slightly scary. You never know what you're going to get in the least significant bit.</p>\n<p>Something I've always considered a little odd is that the standard expresses the requirements in terms of the key <em>type</em>, not in terms of the actual key values added to the container. I believe you could choose to read this as not guaranteeing that <code>map&lt;double, int&gt;</code> has defined behaviour at all if the implementation supports NaNs, regardless of whether you actually add a NaN to an instance or not. In practice, though, an implementation of <code>std::map</code> cannot somehow conjure a <code>NaN</code> out of its back pocket and try to compare it, it only ever compares key values passed to the instance. So it should be OK (if slightly scary) provided you avoid adding NaNs.</p>\n<blockquote>\n<p id=\"so_8096817_8097097_1\">I'd be very grateful for comments on how other languages handle\n  floating point keys in associative containers</p>\n</blockquote>\n<p>A few quick experiments in Python (where <code>set</code> and <code>dict</code> are unordered associative containers which hold keys and values by reference) suggest that NaNs are treated as objects that are unequal in value even if they're \"the same NaN\", but the same nan <em>object</em> can be found again by identity. As far as I've seen, the containers don't seem to be disturbed by containing multiple nans, or a mixture of nans and other values:</p>\n<pre><code>&gt;&gt;&gt; thing = set()\n&gt;&gt;&gt; nan = float('nan')\n&gt;&gt;&gt; nan\nnan\n&gt;&gt;&gt; thing.add(nan)\n&gt;&gt;&gt; thing.add(nan)\n&gt;&gt;&gt; thing\nset([nan])\n\n&gt;&gt;&gt; thing = dict()\n&gt;&gt;&gt; thing[nan] = 1\n&gt;&gt;&gt; thing[nan] = 2\n&gt;&gt;&gt; thing[nan]\n2\n&gt;&gt;&gt; nan2 = float('nan')\n&gt;&gt;&gt; thing[nan2] = 3\n&gt;&gt;&gt; thing\n{nan: 2, nan: 3}\n\n&gt;&gt;&gt; thing = set()\n&gt;&gt;&gt; thing.add(nan)\n&gt;&gt;&gt; thing.add(nan2)\n&gt;&gt;&gt; thing\nset([nan, nan])\n\n&gt;&gt;&gt; thing = dict()\n&gt;&gt;&gt; thing[nan] = 1\n&gt;&gt;&gt; thing[nan2] = 2\n&gt;&gt;&gt; thing[0] = 3\n&gt;&gt;&gt; thing\n{nan: 1, nan: 2, 0: 3}\n&gt;&gt;&gt; thing.keys()\n[nan, nan, 0]\n&gt;&gt;&gt; thing.values()\n[1, 2, 3]\n&gt;&gt;&gt; thing[0]\n3\n&gt;&gt;&gt; thing[1]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 1\n</code></pre>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2011-11-11T17:35:33.473", "Id": "8097097", "Score": "15", "CreationDate": "2011-11-11T16:38:34.397", "LastActivityDate": "2011-11-11T17:35:33.473"}, "8096890": {"ParentId": "8096817", "PostTypeId": "2", "CommentCount": "16", "Body": "<p><code>NaN</code>s can be stored inside a map -- namely, they are copy constructable and less than comparable. <code>std::less</code> for doubles doesn't meet map's requirements for a strict weak ordering, so you've technically got undefined behavior here. However, the behavior is easily explained, even if not required by the standard. Map uses equivalence rather than equality to determine whether an item is a duplicate. Two NaNs compare equivalent, but not equal. However, that falls apart in some cases. For example, if you tried to insert something <em>other than</em> a NaN into that map, it would be treated as equivalent to the NaN and you'd get no insert. Try adding some real numbers in addition to the NaNs and you can see map breaks down too.</p>\n<p>The hash behavior is expected but not defined for a hash table as well -- hash tables require their contents to be copy construcable and equality comparable. The hashes of multiple NaNs compare equal, so they're all going to go into the same bucket, but a hash table uses equality comparison rather than less than comparison (equality rather than equivalence). Therefore, none of the NaNs compare equal to each other and you get multiple inserts for that key. This is because NaN breaks the hash table's equality comparable requirement -- namely the invariant that std::equal_to(x, x) true.</p>\n", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2011-11-11T16:41:15.357", "Id": "8096890", "Score": "3", "CreationDate": "2011-11-11T16:21:24.257", "LastActivityDate": "2011-11-11T16:41:15.357"}, "bq_ids": {"n4140": {"so_8096817_8097097_0": {"section_id": 1396, "quality": 1.0, "length": 15}}, "n3337": {"so_8096817_8097097_0": {"section_id": 1390, "quality": 1.0, "length": 15}}, "n4659": {"so_8096817_8097097_0": {"section_id": 1514, "quality": 1.0, "length": 15}}}});