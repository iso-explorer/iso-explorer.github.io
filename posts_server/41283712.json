post_cb({"bq_ids": {"n4140": {"so_41283712_41284800_3": {"section_id": 481, "quality": 1.0, "length": 15}, "so_41283712_41302628_0": {"section_id": 481, "quality": 1.0, "length": 24}, "so_41283712_41284800_1": {"section_id": 481, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_41283712_41284800_3": {"section_id": 472, "quality": 0.9333333333333333, "length": 14}, "so_41283712_41302628_0": {"section_id": 472, "quality": 0.875, "length": 21}}, "n4659": {"so_41283712_41284800_0": {"section_id": 504, "quality": 1.0, "length": 9}, "so_41283712_41284800_3": {"section_id": 504, "quality": 1.0, "length": 15}, "so_41283712_41302628_0": {"section_id": 504, "quality": 1.0, "length": 24}, "so_41283712_41284800_1": {"section_id": 504, "quality": 0.9473684210526315, "length": 18}}}, "41283712": {"CommentCount": "3", "ViewCount": "219", "CreationDate": "2016-12-22T12:57:28.383", "LastActivityDate": "2016-12-23T14:23:47.230", "Title": "Deleted constructor - MSVC reports an error, Clang doesn't", "AcceptedAnswerId": "41284800", "PostTypeId": "1", "Id": "41283712", "Score": "9", "Body": "<p>Consider the following code:</p>\n<pre><code>class SILPassPipelinePlan final {\npublic:\n  SILPassPipelinePlan() = default;\n  ~SILPassPipelinePlan() = default;\n  SILPassPipelinePlan(const SILPassPipelinePlan &amp;) = default;\n  SILPassPipelinePlan(SILPassPipelinePlan &amp;&amp;) = delete;\n\n  SILPassPipelinePlan x() {\n    SILPassPipelinePlan P;\n\n    return P;\n  }\n};\n\nint main() {\n  return 0;\n}\n</code></pre>\n<p>MSVC reports the following error:</p>\n<blockquote>\n<p id=\"so_41283712_41283712_0\">1&gt;consoleapplication2.cpp(13): error C2280: 'SILPassPipelinePlan::SILPassPipelinePlan(SILPassPipelinePlan &amp;&amp;)': attempting to reference a deleted function</p>\n<p id=\"so_41283712_41283712_1\">1&gt;consoleapplication2.cpp(8): note: see declaration of 'SILPassPipelinePlan::SILPassPipelinePlan'</p>\n</blockquote>\n<p>Clang and GCC don't.</p>\n<p>From a specification point of view, which compiler is correct? Is this an MSVC bug, or a Clang bug?</p>\n<p>MSVC is from the latest Visual Studio 2015 Update 3, Clang is version 3.9.0.</p>\n", "Tags": "<c++><gcc><visual-c++><clang><language-lawyer>", "OwnerUserId": "1020773", "AnswerCount": "2"}, "41302628": {"ParentId": "41283712", "CommentCount": "2", "CreationDate": "2016-12-23T13:47:30.513", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "41302628", "Score": "4", "Body": "<p>All versions of GCC on Wandbox reject this code. Are you by any chance testing this on a Mac and using its Clang-masquerading-as-GCC?</p>\n<p>This has nothing to do with P0135. Clang is simply taking an excessively liberal reading of \"fails\" in what is currently <a href=\"https://timsong-cpp.github.io/cppwp/class.copy.elision#3\" rel=\"nofollow noreferrer\">[class.copy.elision]/3</a>, which says that in this situation</p>\n<blockquote>\n<p id=\"so_41283712_41302628_0\">overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. If the first\n  overload resolution <strong>fails</strong> or was not performed, [...], overload\n  resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>That overload resolution doesn't fail; it succeeds and selects the move constructor, which happens to be deleted. That should be the end of the matter.</p>\n<p>This has been reported as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=31025\" rel=\"nofollow noreferrer\">bug 31025</a>.</p>\n", "LastActivityDate": "2016-12-23T13:47:30.513"}, "41284800": {"ParentId": "41283712", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-12-22T13:55:20.923", "Score": "7", "LastEditorUserId": "3647361", "LastEditDate": "2016-12-23T14:23:47.230", "Id": "41284800", "OwnerUserId": "3647361", "Body": "<p>C++11 introduced implicit moves in certain scenarios\u2014<a href=\"http://eel.is/c++draft/class.copy.elision#3\" rel=\"nofollow noreferrer\">yours included</a>:</p>\n<blockquote>\n<p id=\"so_41283712_41284800_0\">In the following copy-initialization contexts, a move operation might\n  be used instead of a copy operation:</p>\n<ul>\n<li><p id=\"so_41283712_41284800_1\">If the expression in a return statement ([stmt.return]) is a (possibly parenthesized) <em>id-expression</em> that names an object with\n  automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>, or</p></li>\n<li><p id=\"so_41283712_41284800_2\">[\u2026]</p></li>\n</ul>\n<p id=\"so_41283712_41284800_3\">overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. If the first\n  overload resolution fails, [\u2026]</p>\n</blockquote>\n<p>Clang (the only accepting implementation, btw.) either misinterprets \"fails\" to include the selection of deleted functions, or applies <a href=\"http://eel.is/c++draft/over.match.funcs#8\" rel=\"nofollow noreferrer\">[over.match.funcs]/8</a> too laxly. See bug <a href=\"https://llvm.org/bugs/show_bug.cgi?id=31025\" rel=\"nofollow noreferrer\">31025</a>.</p>\n", "LastActivityDate": "2016-12-23T14:23:47.230"}});