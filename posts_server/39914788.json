post_cb({"39961693": {"Id": "39961693", "PostTypeId": "2", "Body": "<p>Beyond the theoretical answers, a practical observation would be that for a long time compilers have applied various transforms upon loops to reduce the amount of work done within them.  For example, given:</p>\n<pre><code>for (int i=0; i&lt;n; i++)\n  foo[i] = i*scale;\n</code></pre>\n<p>a compiler might transform that into:</p>\n<pre><code>int temp = 0;\nfor (int i=0; i&lt;n; i++)\n{\n  foo[i] = temp;\n  temp+=scale;\n}\n</code></pre>\n<p>Thus saving a multiplication with every loop iteration.  An additional form of optimization, which compilers adapted with varying degrees of aggressiveness,\nwould turn that into:</p>\n<pre><code>if (n &gt; 0)\n{\n  int temp1 = n*scale;\n  int *temp2 = foo;\n  do\n  {\n    temp1 -= scale;\n    *temp2++ = temp1;\n  } while(temp1);\n}\n</code></pre>\n<p>Even on machines with silent wraparound on overflow, that could malfunction if\nthere was some number less than n which, when multiplied by scale, would yield\n0.  It could also turn into an endless loop if scale was read from memory more\nthan once and something changed its value unexpectedly (in any case where\n\"scale\" could change mid-loop without invoking UB, a compiler would not be\nallowed to perform the optimization).</p>\n<p>While most such optimizations would not have any trouble in cases where two\nshort unsigned types are multiplied to yield a value which is between INT_MAX+1\nand UINT_MAX, gcc has some cases where such a multiplication within a loop\nmay cause the loop to early-exit.  I haven't noticed such behaviors stemming\nfrom comparison instructions in generated code, but it is observable in cases\nwhere the compiler uses the overflow to infer that a loop can execute at most\n4 or fewer times; it does not by default generate warnings in cases where some\ninputs would cause UB and others would not, even if its inferences cause the\nupper bound of the loop to be ignored.</p>\n", "LastActivityDate": "2016-10-10T15:27:59.670", "CommentCount": "0", "CreationDate": "2016-10-10T15:27:59.670", "ParentId": "39914788", "Score": "4", "OwnerUserId": "363751"}, "39915175": {"Id": "39915175", "PostTypeId": "2", "Body": "<p>If you're interested in a purely theoretical answer, the C++ standard allows undefined behaviour to \"time travel\":</p>\n<blockquote>\n<p id=\"so_39914788_39915175_0\"><code>[intro.execution]/5:</code>\n  A conforming implementation executing a well-formed program shall produce the same observable behavior\n  as one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input. However, <strong>if any such execution contains an undefined operation, this International\n  Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation)</strong></p>\n</blockquote>\n<p>As such, if your program contains undefined behaviour, then the behaviour of your <em>whole program</em> is undefined.</p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2016-10-07T10:33:55.133", "Score": "103", "CreationDate": "2016-10-07T10:32:25.830", "ParentId": "39914788", "CommentCount": "15", "OwnerUserId": "496161", "LastEditDate": "2016-10-07T10:33:55.133"}, "39925782": {"Id": "39925782", "PostTypeId": "2", "Body": "<p>TartanLlama's answer is correct. The undefined behavior can happen at any time, even during compile time.  This may seem absurd, but it's a key feature to permit compilers to do what they need to do.  It's not always easy to be a compiler.  You have to do exactly what the spec says, every time.  However, sometimes it can be monstrously difficult to prove that a particular behavior is occurring.  If you remember the halting problem, its rather trivial to develop software for which you cannot prove whether it completes or enters an infinite loop when fed a particular input.</p>\n<p>We could make compilers be pessimistic, and constantly compile in fear that the next instruction might be one of these halting problem like issues, but that isn't reasonable.  Instead we give the compiler a pass: on these \"undefined behavior\" topics, they are freed from any responsibility.  Undefined behavior consists of all of the behaviors which are so subtly nefarious that we have trouble separating them from the really-nasty-nefarious halting problems and whatnot.</p>\n<p>There is an example which I love to post, though I admit I lost the source to, so I have to paraphrase.  It was from a particular version of MySQL.  In MySQL, they had a circular buffer which was filled with user-provided data.  They, of course, wanted to make sure that the data didn't overflow the buffer, so they had a check:</p>\n<pre><code>if (currentPtr + numberOfNewChars &gt; endOfBufferPtr) { doOverflowLogic(); }\n</code></pre>\n<p>It looks sane enough.  However, what if numberOfNewChars is really big, and overflows?  Then it wraps around and becomes a pointer smaller than <code>endOfBufferPtr</code>, so the overflow logic would never get called. So they added a second check, before that one:</p>\n<pre><code>if (currentPtr + numberOfNewChars &lt; currentPtr) { detectWrapAround(); }\n</code></pre>\n<p>It looks like you took care of the buffer overflow error, right?  However, a bug was submitted stating that this buffer overflowed on a particular version of Debian!  Careful investigation showed that this version of Debian was the first to use a particularly bleeding-edge version of gcc.  On this version of gcc, the compiler recognized that currentPtr + numberOfNewChars can <strong>never</strong> be a smaller pointer than currentPtr because overflow for pointers is undefined behavior!  That was sufficient for gcc to optimize out the entire check, and suddenly you were not protected against buffer overflows <em>even though you wrote the code to check it!</em></p>\n<p>This was spec behavior.  Everything was legal (though from what I heard, gcc rolled back this change in the next version).  It's not what I would consider intuitive behavior, but if you stretch your imagination a bit, it's easy to see how a slight variant of this situation could become a halting problem for the compiler.  Because of this, the spec writers made it \"Undefined Behavior\" and stated that the compiler could do absolutely anything it pleased.</p>\n", "LastActivityDate": "2016-10-07T21:04:27.280", "CommentCount": "4", "CreationDate": "2016-10-07T21:04:27.280", "ParentId": "39914788", "Score": "6", "OwnerUserId": "2728148"}, "39914788": {"ViewCount": "10119", "Body": "<p>This is an example to illustrate my question which involves some much more complicated code that I can't post here.</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int a = 0;\n    for (int i = 0; i &lt; 3; i++)\n    {\n        printf(\"Hello\\n\");\n        a = a + 1000000000;\n    }\n}\n</code></pre>\n<p>This program contains undefined behavior on my platform because <code>a</code> will overflow on the 3rd loop.</p>\n<p>Does that make the <strong>whole program</strong> have undefined behavior, or only after the <strong>overflow actually happens</strong>? Could the compiler potentially work out that <code>a</code> <strong>will</strong> overflow so it can declare the whole loop undefined and not bother to run the printfs even though they all happen before the overflow?</p>\n<p><sub>(Tagged C and C++ even though are different because I'd be interested in answers for both languages if they are different.)</sub></p>\n", "AcceptedAnswerId": "39915175", "Title": "At what point in the loop does integer overflow become undefined behavior?", "CreationDate": "2016-10-07T10:12:29.567", "Id": "39914788", "CommentCount": "13", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2016-10-09T07:26:34.657", "LastEditorUserId": "63550", "LastActivityDate": "2016-10-21T21:25:29.560", "Score": "83", "OwnerUserId": "417292", "Tags": "<c++><c><undefined-behavior><integer-overflow>", "AnswerCount": "11"}, "39920064": {"Id": "39920064", "PostTypeId": "2", "Body": "<p>Assuming <code>int</code> is 32-bit, undefined behavior happens at the third iteration. So if, for example, the loop was only conditionally reachable, or could conditionally be terminated before the third iteration, there would be no undefined behavior unless the third iteration is actually reached. However, in the event of undefined behavior, <strong>all output of the program</strong> is undefined, including output which is \"in the past\" relative to the invocation of undefined behavior. For example, in your case, this means there is no guarantee of seeing 3 \"Hello\" messages in the output.</p>\n", "LastActivityDate": "2016-10-07T14:48:24.020", "CommentCount": "0", "CreationDate": "2016-10-07T14:48:24.020", "ParentId": "39914788", "Score": "6", "OwnerUserId": "379897"}, "bq_ids": {"n4140": {"so_39914788_39940251_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5801}, "so_39914788_39915175_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 5801}, "so_39914788_39925056_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5797}}, "n3337": {"so_39914788_39940251_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5574}, "so_39914788_39915175_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 5574}, "so_39914788_39925056_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5570}}, "n4659": {"so_39914788_39940251_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 7260}, "so_39914788_39915175_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 7260}, "so_39914788_39925056_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 7256}}}, "39936011": {"Id": "39936011", "PostTypeId": "2", "Body": "<p>Technically, under the C++ standard, if a program contains undefined behavior, the behavior of the entire program, <a href=\"https://stackoverflow.com/questions/11546193/does-undefined-behaviour-extend-to-compile-time\">even at compile time</a> (before the program is even executed), is undefined.</p>\n<p>In practice, because the compiler may assume (as part of an optimization) that the overflow will not occur, at least the behavior of the program on the third iteration of the loop (assuming a 32-bit machine) will be undefined, though it is likely that you will get correct results before the third iteration. However, since the behavior of the entire program is technically undefined, there's nothing stopping the program from generating completely incorrect output (including no output), crashing at runtime at any point during execution, or even failing to compile altogether (as undefined behavior extends to compile time).</p>\n<p>Undefined behavior provides the compiler with more room to optimize because they eliminate certain assumptions about what the code must do. In doing so, programs that rely on assumptions involving undefined behavior are not guaranteed to work as expected. As such, you should not rely on any particular behavior that is considered undefined per the C++ standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-09T01:11:32.963", "Score": "11", "CreationDate": "2016-10-08T18:41:44.973", "ParentId": "39914788", "CommentCount": "3", "OwnerUserId": "681231", "LastEditDate": "2017-05-23T12:17:54.117"}, "39925056": {"Id": "39925056", "PostTypeId": "2", "Body": "<p>To understand <em>why</em> undefined behavior can <a href=\"https://stackoverflow.com/a/39915175/3435400\">'time travel' as @TartanLlama adequately put it</a>, let's take a look at the 'as-if' rule:</p>\n<blockquote>\n<p id=\"so_39914788_39925056_0\"><strong>1.9 Program execution</strong> </p>\n<p id=\"so_39914788_39925056_1\"><sup>1</sup> The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. Rather, conforming implementations\n  are required to emulate (only) the observable behavior of the abstract\n  machine as explained below.</p>\n</blockquote>\n<p>With this, we could view the program as a 'black box' with an input and an output. The input could be user-input, files, and many other things. The output is the 'observable behavior' mentioned in the standard.</p>\n<p>The standard only defines a mapping between the input and the output, nothing else. It does this by describing an 'example black box', but explicitly says any other black box with the same mapping is equally valid. This means the content of the black box is irrelevant.</p>\n<p>With this in mind, it would not make sense to say that undefined behavior occurs at a certain moment. In the <em>sample</em> implementation of the black box, we could say where and when it happens, but the <em>actual</em> black box could be something completely different, so we can't say where and when it happens anymore. Theoretically, a compiler could for example decide to enumerate all the possible inputs, and pre-compute the resulting outputs. Then the undefined behavior would have happened during compilation.</p>\n<p>Undefined behavior is the inexistence of a mapping between input and output. A program can have undefined behavior for some input, but defined behavior for other. Then the mapping between input and output is simply incomplete; there is input for which no mapping to output exists.<br>\nThe program in the question has undefined behavior for any input, so the mapping is empty.</br></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-07T23:39:16.723", "Score": "9", "CreationDate": "2016-10-07T20:09:54.423", "ParentId": "39914788", "CommentCount": "0", "OwnerUserId": "3435400", "LastEditDate": "2017-05-23T12:10:10.203"}, "39914859": {"Id": "39914859", "PostTypeId": "2", "Body": "<p>An aggressively optimising C or C++ compiler targeting a 16 bit <code>int</code> will <em>know</em> that the behaviour on adding <code>1000000000</code> to an <code>int</code> type is <em>undefined</em>.</p>\n<p>It is permitted by either standard to do anything it wants which <em>could</em> include the deletion of the entire program, leaving <code>int main(){}</code>.</p>\n<p>But what about larger <code>int</code>s? I don't know of a compiler that does this yet (and I'm not an expert in C and C++ compiler design by any means), but I imagine that <em>sometime</em> a compiler targeting a 32 bit <code>int</code> or higher will figure out that the loop is infinite (<code>i</code> doesn't change) <em>and</em> so <code>a</code> will eventually overflow. So once again, it can optimise the output to <code>int main(){}</code>. The point I'm trying to make here is that as compiler optimisations become progressively more aggressive, more and more undefined behaviour constructs are manifesting themselves in unexpected ways.</p>\n<p>The fact that your loop is infinite is not in itself undefined since you are writing to standard output in the loop body.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2016-10-07T10:34:23.850", "Score": "28", "CreationDate": "2016-10-07T10:16:18.217", "ParentId": "39914788", "CommentCount": "10", "OwnerUserId": "2380830", "LastEditDate": "2016-10-07T10:34:23.850"}, "39927442": {"Id": "39927442", "PostTypeId": "2", "Body": "<p>Undefined behavior is, by definition, a grey area.  You simply can't predict what it will or won't do -- that's what \"undefined behavior\" <em>means</em>.</p>\n<p>Since time immemorial, programmers have always tried to salvage remnants of definedness from an undefined situation.  They've got some code they really want to use, but which turns out to be undefined, so they try to argue: \"I know it's undefined, but surely it will, at worst, do this or this; it will never do <em>that</em>.\"  And sometimes these arguments are more or less right -- but often, they're wrong.  And as the compilers get smarter and smarter (or, some people might say, sneakier and sneakier), the boundaries of the question keep changing.</p>\n<p>So really, if you want to write code that's guaranteed to work, and that will keep working for a long time, there's only one choice: avoid ye the undefined behavior at all costs.  Verily, if you dabble in it, it will come back to haunt you.</p>\n", "LastEditorUserId": "3923896", "LastActivityDate": "2016-10-21T21:25:29.560", "Score": "4", "CreationDate": "2016-10-08T00:25:04.473", "ParentId": "39914788", "CommentCount": "1", "OwnerUserId": "3923896", "LastEditDate": "2016-10-21T21:25:29.560"}, "39918778": {"Id": "39918778", "PostTypeId": "2", "Body": "<p>First, let me correct the title of this question:</p>\n<p><strong>Undefined Behavior is not (specifically) of the realm of execution.</strong></p>\n<p>Undefined Behavior affects all steps: compiling, linking, loading and executing.</p>\n<p>Some examples to cement this, bear in mind that no section is exhaustive:</p>\n<ul>\n<li>the compiler can assume that portions of code that contain Undefined Behavior are never executed, and thus assume the execution paths that would lead to them are dead code. See <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html\">What every C programmer should know about undefined behavior</a> by none other than Chris Lattner.</li>\n<li>the linker can assume that in the presence of multiple definitions of a weak symbol (recognized by name), all definitions are identical thanks to the <a href=\"https://en.wikipedia.org/wiki/One_Definition_Rule\">One Definition Rule</a></li>\n<li>the loader (in case you use dynamic libraries) can assume the same, thus picking the first symbol it finds; this is usually (ab)used for intercepting calls using <code>LD_PRELOAD</code> tricks on Unixes</li>\n<li>the execution might fail (SIGSEV) should you use dangling pointers</li>\n</ul>\n<p>This is what is <em>so scary</em> about Undefined Behavior: it is nigh impossible to predict, ahead of time, what exact behavior will occur, and this prediction has to be revisited at each update of the toolchain, underlying OS, ...</p>\n<hr>\n<p><em>I recommend watching this video by Michael Spencer (LLVM Developer): <a href=\"https://www.youtube.com/watch?v=g7entxbQOCc\">CppCon 2016: My Little Optimizer: Undefined Behavior is Magic</a>.</em></p>\n</hr>", "LastEditorUserId": "147192", "LastActivityDate": "2016-10-09T10:43:46.900", "Score": "30", "CreationDate": "2016-10-07T13:44:20.257", "ParentId": "39914788", "CommentCount": "6", "OwnerUserId": "147192", "LastEditDate": "2016-10-09T10:43:46.900"}, "39940251": {"Id": "39940251", "PostTypeId": "2", "Body": "<h3>The top answer is a wrong (but common) misconception:</h3>\n<h2>Undefined behavior is a <em>run-time</em> property*. It <strong>CANNOT</strong> \"time-travel\"!</h2>\n<p>Certain operations are defined (by the standard) to have <strong>side-effects</strong> and cannot be optimized away. Operations that do I/O or that access <code>volatile</code> variables fall in this category.</p>\n<p><strong>However</strong>, there is a caveat: UB can be <strong>any</strong> behavior, including behavior that <strong><em>undoes</em></strong> previous operations. This can have similar consequences, in some cases, to optimizing out earlier code.</p>\n<p>In fact, this is consistent with the quote in the top answer  (emphasis mine):</p>\n<blockquote>\n<p id=\"so_39914788_39940251_0\">A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input.<br>\n  However, if any such execution contains an undefined operation, this International Standard <em>places no requirement on the implementation <strong>executing</strong> that program with that input</em> (not even with regard to operations preceding the first undefined operation).</br></p>\n</blockquote>\n<p>Yes, this quote <em>does</em> say <em>\"not even with regard to operations preceding the first undefined operation\"</em>, but notice that this is specifically about code that is being <strong>executed</strong>, not merely compiled.<br>\nAfter all, undefined behavior that isn't actually reached doesn't do anything, and for the line containing UB to be actually reached, code that precedes it must execute first!  </br></p>\n<h3>So yes, <em>once UB is executed</em>, any effects of previous operations become undefined. But until that happens, the execution of the program is well-defined.</h3>\n<p>Note, however, that all executions of the program that result in this happening can be optimized to <em>equivalent</em> programs, including any that perform previous operations but then un-do their effects. Consequently, preceding code may be optimized away <em>whenever doing so would be equivalent to their effects being undone</em>; otherwise, it can't. See below for an example.</p>\n<p><strong>*Note:</strong> This is <em>not</em> inconsistent with <a href=\"/a/11546378/541686\">UB occurring at compile time</a>. If the compiler can indeed prove that UB code <strong>will</strong> always be executed for all inputs, then UB can extend to compile time. However, this requires knowing that <em>all previous code eventually returns</em>, which is a strong requirement. Again, see below for an example/explanation.</p>\n<hr>\n<p>To make this concrete, note that the following code <strong>must</strong> print <code>foo</code> and wait for your input regardless of any undefined behavior that follows it:</p>\n<pre><code>printf(\"foo\");\ngetchar();\n*(char*)1 = 1;\n</code></pre>\n<p>However, also note that there is no guarantee that <code>foo</code> will remain on the screen after the UB occurs, or that the character you typed will no longer be in the input buffer; both of these operations can be \"undone\", which has a similar effect to UB \"time-travel\".  </p>\n<p>If the <code>getchar()</code> line wasn't there, it <em>would</em> be legal for the lines to be optimized away <strong>if and only if</strong> that would be <strong>indistinguishable</strong> from outputting <code>foo</code> and then \"un-doing\" it.  </p>\n<p>Whether or not the two would be indistinguishable would depend <em>entirely</em> on the implementation (i.e. on your compiler and standard library). For example, can your <code>printf</code> <em>block</em> your thread here while waiting for another program to read the output? Or will it return immediately?  </p>\n<ul>\n<li><p>If it can block here, then another program can refuse to read its full output, and it may never return, and consequently UB may never actually occur.  </p></li>\n<li><p>If it can return immediately here, then we know it must return, and therefore optimizing it out is entirely indistinguishable from executing it and then un-doing its effects.</p></li>\n</ul>\n<p>Of course, since the compiler knows what behavior is permissible for its particular version of <code>printf</code>, it can optimize accordingly, and consequently <code>printf</code> may get optimized out in some cases and not others. But, again, the justification is that this would be indistinguishable from the UB un-doing previous operations, <strong>not</strong> that the previous code is \"poisoned\" because of UB.</p>\n</hr>", "LastEditorUserId": "541686", "LastActivityDate": "2016-10-09T05:39:23.887", "Score": "0", "CreationDate": "2016-10-09T05:12:19.057", "ParentId": "39914788", "CommentCount": "10", "OwnerUserId": "541686", "LastEditDate": "2016-10-09T05:39:23.887"}, "39922152": {"Id": "39922152", "PostTypeId": "2", "Body": "<p>One thing your example doesn't consider is optimisation.  <code>a</code> is set in the loop but never used, and an optimiser could work this out.  As such, it is legitimate for the optimiser to discard <code>a</code> completely, and in that case all undefined behaviour vanishes like a boojum's victim.</p>\n<p>However of course this itself is undefined, because optimisation is undefined. :)</p>\n", "LastActivityDate": "2016-10-07T16:40:00.703", "CommentCount": "4", "CreationDate": "2016-10-07T16:40:00.703", "ParentId": "39914788", "Score": "1", "OwnerUserId": "5162810"}});