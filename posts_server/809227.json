post_cb({"809701": {"Id": "809701", "PostTypeId": "2", "Body": "<p>As long as you have <code>#include &lt;limits.h&gt;</code> as one of your includes, you should just use </p>\n<pre><code>unsigned int flags = UINT_MAX;\n</code></pre>\n<p>If you want a long's worth of bits, you could use</p>\n<pre><code>unsigned long flags = ULONG_MAX;\n</code></pre>\n<p>These values are guaranteed to have all the value bits of the result set to 1, regardless of how signed integers are implemented.</p>\n", "LastEditorUserId": "99048", "LastActivityDate": "2016-01-04T00:23:31.897", "Score": "5", "CreationDate": "2009-05-01T00:20:58.750", "ParentId": "809227", "CommentCount": "1", "OwnerUserId": "99048", "LastEditDate": "2016-01-04T00:23:31.897"}, "39898329": {"Id": "39898329", "PostTypeId": "2", "Body": "<p>Leveraging on the fact that assigning all bits to one for an unsigned type is equivalent to taking the maximum possible value for the given type,<br/>\nand extending the scope of the question to all <em>unsigned</em> integer types:</p>\n<p><a href=\"https://stackoverflow.com/a/39865015/2436175\">Assigning -1 works for any <em>unsigned</em> integer type</a> (unsigned int, uint8_t, uint16_t, etc.) for both C and C++.</p>\n<p>As an alternative, for C++, you can either:</p>\n<ol>\n<li>Include <code>&lt;limits&gt;</code> and use <code>std::numeric_limits&lt; your_type &gt;::max()</code></li>\n<li>Write a <a href=\"https://stackoverflow.com/a/39878362/2436175\">custom templated function</a> (This would also allow some sanity check, i.e. if the destination type is really an unsigned type)</li>\n</ol>\n<p>The purpose could be add more clarity, as assigning <code>-1</code> would always need some explanatory comment.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-06T14:11:35.343", "Score": "0", "CreationDate": "2016-10-06T14:11:35.343", "ParentId": "809227", "CommentCount": "0", "OwnerUserId": "2436175", "LastEditDate": "2017-05-23T10:31:10.310"}, "809227": {"ViewCount": "28441", "Body": "<p>I've seen this pattern used a lot in C &amp; C++.</p>\n<pre><code>unsigned int flags = -1;  // all bits are true\n</code></pre>\n<p>Is this a good portable way to accomplish this?  Or is using <code>0xffffffff</code> or <code>~0</code> better?</p>\n", "AcceptedAnswerId": "809341", "Title": "Is it safe to use -1 to set all bits to true?", "CreationDate": "2009-04-30T21:37:02.623", "Id": "809227", "CommentCount": "2", "FavoriteCount": "53", "PostTypeId": "1", "LastEditDate": "2016-10-06T08:19:07.747", "LastEditorUserId": "2436175", "LastActivityDate": "2016-10-06T14:11:35.343", "Score": "119", "OwnerUserId": "1841", "Tags": "<c++><c><binary><bit-fields>", "AnswerCount": "19"}, "811331": {"Id": "811331", "PostTypeId": "2", "Body": "<p>A way which avoids the problems mentioned is to simply do:</p>\n<pre><code>unsigned int flags = 0;\nflags = ~flags;\n</code></pre>\n<p>Portable and to the point.</p>\n", "LastActivityDate": "2009-05-01T13:26:28.490", "CommentCount": "6", "CreationDate": "2009-05-01T13:26:28.490", "ParentId": "809227", "Score": "17", "OwnerUserId": "98117"}, "6204296": {"Id": "6204296", "PostTypeId": "2", "Body": "<blockquote>\n<pre><code>unsigned int flags = -1;  // all bits are true\n</code></pre>\n<p id=\"so_809227_6204296_0\">\"Is this a good[,] portable way to accomplish this?\"</p>\n</blockquote>\n<p>Portable?  <strong>Yes</strong>.</p>\n<p>Good?  <strong>Debatable</strong>, as evidenced by all the confusion shown on this thread.  Being clear enough that your fellow programmers can understand the code without confusion should be one of the dimensions we measure for good code.</p>\n<p>Also, this method is prone to <strong>compiler warnings</strong>.  To elide the warning without crippling your compiler, you'd need an explicit cast.  For example,</p>\n<pre><code>unsigned int flags = static_cast&lt;unsigned int&gt;(-1);\n</code></pre>\n<p>The explicit cast requires that you pay attention to the target type.  If you're paying attention to the target type, then you'll naturally avoid the pitfalls of the other approaches.</p>\n<p>My advice would be to pay attention to the target type and make sure there are no implicit conversions.  For example:</p>\n<pre><code>unsigned int flags1 = UINT_MAX;\nunsigned int flags2 = ~static_cast&lt;unsigned int&gt;(0);\nunsigned long flags3 = ULONG_MAX;\nunsigned long flags4 = ~static_cast&lt;unsigned long&gt;(0);\n</code></pre>\n<p>All of which are <strong>correct and more obvious</strong> to your fellow programmers.</p>\n<p><strong>And with C++11</strong>:  We can use <code>auto</code> to make any of these even simpler:</p>\n<pre><code>auto flags1 = UINT_MAX;\nauto flags2 = ~static_cast&lt;unsigned int&gt;(0);\nauto flags3 = ULONG_MAX;\nauto flags4 = ~static_cast&lt;unsigned long&gt;(0);\n</code></pre>\n<p>I consider correct and obvious better than simply correct.</p>\n", "LastEditorUserId": "1386054", "LastActivityDate": "2013-05-02T12:35:52.490", "Score": "10", "CreationDate": "2011-06-01T16:11:21.940", "ParentId": "809227", "CommentCount": "0", "OwnerUserId": "1386054", "LastEditDate": "2013-05-02T12:35:52.490"}, "13831831": {"Id": "13831831", "PostTypeId": "2", "Body": "<p>As others have mentioned, -1 is the correct way to create an integer that will convert to an unsigned type with all bits set to 1. However, the most important thing in C++ is using correct types. Therefore, the correct answer to your problem (which includes the answer to the question you asked) is this:</p>\n<pre><code>std::bitset&lt;32&gt; const flags(-1);\n</code></pre>\n<p>This will always contain the exact amount of bits you need. It constructs a <code>std::bitset</code> with all bits set to 1 for the same reasons mentioned in other answers.</p>\n", "LastActivityDate": "2012-12-12T02:26:58.753", "CommentCount": "0", "CreationDate": "2012-12-12T02:26:58.753", "ParentId": "809227", "Score": "1", "OwnerUserId": "852254"}, "bq_ids": {"n4140": {"so_809227_852861_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 7216}}, "n3337": {"so_809227_852861_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 6960}}, "n4659": {"so_809227_852861_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 8725}}}, "809242": {"Id": "809242", "PostTypeId": "2", "Body": "<p>It is certainly safe, as -1 will always have all available bits set, but I like ~0 better. -1 just doesn't make much sense for an <code>unsigned int</code>. <code>0xFF</code>... is not good because it depends on the width of the type.</p>\n", "LastActivityDate": "2009-04-30T21:40:28.747", "CommentCount": "1", "CreationDate": "2009-04-30T21:40:28.747", "ParentId": "809227", "Score": "0", "OwnerUserId": "83871"}, "814634": {"Id": "814634", "PostTypeId": "2", "Body": "<p>On Intel's IA-32 processors it is OK to write 0xFFFFFFFF to a 64-bit register and get the expected results.  This is because IA32e (the 64-bit extension to IA32) only supports 32-bit immediates.  In 64-bit instructions 32-bit immediates are <em>sign-extended</em> to 64-bits.  </p>\n<p>The following is illegal:</p>\n<pre><code>mov rax, 0ffffffffffffffffh\n</code></pre>\n<p>The following puts 64 1s in RAX:</p>\n<pre><code>mov rax, 0ffffffffh\n</code></pre>\n<p>Just for completeness, the following puts 32 1s in the lower part of RAX (aka EAX):</p>\n<pre><code>mov eax, 0ffffffffh\n</code></pre>\n<p>And in fact I've had programs fail when I wanted to write 0xffffffff to a 64-bit variable and I got a 0xffffffffffffffff instead.  In C this would be:</p>\n<pre><code>uint64_t x;\nx = UINT64_C(0xffffffff)\nprintf(\"x is %\"PRIx64\"\\n\", x);\n</code></pre>\n<p>the result is:</p>\n<pre><code>x is 0xffffffffffffffff\n</code></pre>\n<p>I thought to post this as a comment to all the answers that said that 0xFFFFFFFF assumes 32 bits, but so many people answered it I figured I'd add it as a separate answer.</p>\n", "LastActivityDate": "2009-05-02T10:53:37.333", "CommentCount": "3", "CreationDate": "2009-05-02T10:53:37.333", "ParentId": "809227", "Score": "2", "OwnerUserId": "1084"}, "852861": {"Id": "852861", "PostTypeId": "2", "Body": "<p>See litb's answer for a very clear explanation of the issues.</p>\n<p>My disagreement is that, very strictly speaking, there are no guarantees for either case. I don't know of any architecture that does not represent an unsigned value of 'one less than two to the power of the number of bits' as all bits set, but here is what the Standard actually says (3.9.1/7 plus note 44):</p>\n<blockquote>\n<p id=\"so_809227_852861_0\">The representations of integral types shall define values by use of a pure binary  numeration system. [Note 44:]A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position.</p>\n</blockquote>\n<p>That leaves the possibility for one of the bits to be anything at all.</p>\n", "LastActivityDate": "2009-05-12T13:41:33.717", "CommentCount": "4", "CreationDate": "2009-05-12T13:41:33.717", "ParentId": "809227", "Score": "2", "OwnerUserId": "11828"}, "809249": {"Id": "809249", "PostTypeId": "2", "Body": "<p>Practically:  Yes</p>\n<p>Theoretically:  No.</p>\n<p>-1 = 0xFFFFFFFF (or whatever size an int is on your platform) is only true with two's complement arithmetic.  In practice, it will work, but there are legacy machines out there (IBM mainframes, etc.) where you've got an actual sign bit rather than a two's complement representation.  Your proposed ~0 solution should work everywhere.</p>\n", "LastActivityDate": "2009-04-30T21:41:52.237", "CommentCount": "2", "CreationDate": "2009-04-30T21:41:52.237", "ParentId": "809227", "Score": "1", "OwnerUserId": "23934"}, "3383752": {"Id": "3383752", "PostTypeId": "2", "Body": "<p>Converting -1 into any unsigned type is <strong>guaranteed by the standard</strong> to result in all-ones. Use of <code>~0U</code> is generally bad since <code>0</code> has type <code>unsigned int</code> and will not fill all the bits of a larger unsigned type, unless you explicitly write something like <code>~0ULL</code>. On sane systems, <code>~0</code> should be identical to <code>-1</code>, but since the standard allows ones-complement and sign/magnitude representations, strictly speaking it's not portable.</p>\n<p>Of course it's always okay to write out <code>0xffffffff</code> if you know you need exactly 32 bits, but -1 has the advantage that it will work in any context even when you do not know the size of the type, such as macros that work on multiple types, or if the size of the type varies by implementation. If you do know the type, another safe way to get all-ones is the limit macros <code>UINT_MAX</code>, <code>ULONG_MAX</code>, <code>ULLONG_MAX</code>, etc.</p>\n<p>Personally I always use -1. It always works and you don't have to think about it.</p>\n", "LastActivityDate": "2010-08-01T21:02:49.757", "CommentCount": "10", "CreationDate": "2010-08-01T21:02:49.757", "ParentId": "809227", "Score": "9", "OwnerUserId": "379897"}, "809879": {"Id": "809879", "PostTypeId": "2", "Body": "<ul>\n<li><code>unsigned int flags = -1;</code>  is portable.</li>\n<li><code>unsigned int flags = ~0;</code> isn't portable because it\nrelies on a two's-complement representation.</li>\n<li><code>unsigned int flags = 0xffffffff;</code> isn't portable because\nit assumes 32-bit ints.</li>\n</ul>\n<p>If you want to set all bits in a way guaranteed by the C standard, use the first one.</p>\n", "LastEditorUserId": "365102", "LastActivityDate": "2011-11-21T09:03:25.990", "Score": "42", "CreationDate": "2009-05-01T01:31:29.190", "ParentId": "809227", "CommentCount": "13", "OwnerUserId": "95286", "LastEditDate": "2011-11-21T09:03:25.990"}, "17668317": {"Id": "17668317", "PostTypeId": "2", "Body": "<p>Yes. As mentioned in other answers, <code>-1</code> is the most portable; however, it is not very semantic and triggers compiler warnings.</p>\n<p>To solve these issues, try this simple helper:</p>\n<pre><code>static const struct All1s\n{\n    template&lt;typename UnsignedType&gt;\n    inline operator UnsignedType(void) const\n    {\n        return static_cast&lt;UnsignedType&gt;(-1);\n    }\n} ALL_BITS_TRUE;\n</code></pre>\n<p>Usage:</p>\n<pre><code>unsigned a = ALL_BITS_TRUE;\nuint8_t  b = ALL_BITS_TRUE;\nuint16_t c = ALL_BITS_TRUE;\nuint32_t d = ALL_BITS_TRUE;\nuint64_t e = ALL_BITS_TRUE;\n</code></pre>\n", "LastEditorUserId": "423481", "LastActivityDate": "2013-07-16T05:32:57.810", "Score": "5", "CreationDate": "2013-07-16T04:55:08.697", "ParentId": "809227", "CommentCount": "1", "OwnerUserId": "423481", "LastEditDate": "2013-07-16T05:32:57.810"}, "809341": {"Id": "809341", "PostTypeId": "2", "Body": "<p>I recommend you to do it exactly as you have shown, since it is the most straight forward one. Initialize to <code>-1</code> which will work <em>always</em>, independent of the actual sign representation, while <code>~</code> will sometimes have surprising behavior because you will have to have the right operand type. Only then you will get the most high value of an <code>unsigned</code> type. </p>\n<p>For an example of a possible surprise, consider this one:</p>\n<pre><code>unsigned long a = ~0u;\n</code></pre>\n<p>It won't necessarily store a pattern with all bits 1 into <code>a</code>. But it will first create a pattern with all bits 1 in an <code>unsigned int</code>, and then assign it to <code>a</code>. What happens when <code>unsigned long</code> has more bits is that not all of those are 1.</p>\n<p>And consider this one, which will fail on a non-two's complement representation:</p>\n<pre><code>unsigned int a = ~0; // Should have done ~0u !\n</code></pre>\n<p>The reason for that is that <code>~0</code> has to invert all bits. Inverting that will yield <code>-1</code> on a two's complement machine (which is the value we need!), but will <em>not</em> yield <code>-1</code> on another representation. On a one's complement machine, it yields zero. Thus, on a one's complement machine, the above will initialize <code>a</code> to zero. </p>\n<p>The thing you should understand is that it's all about values - not bits. The variable is initialized with a <em>value</em>. If in the initializer you modify the bits of the variable used for initialization, the value will be generated according to those bits. The value you need, to initialize <code>a</code> to the highest possible value, is <code>-1</code> or <code>UINT_MAX</code>. The second will depend on the type of <code>a</code> - you will need to use <code>ULONG_MAX</code> for an <code>unsigned long</code>. However, the first will not depend on its type, and it's a nice way of getting the most highest value.</p>\n<p><strong>We are <em>not</em> talking about whether <code>-1</code> has all bits one (it doesn't always have). And we're <em>not</em> talking about whether <code>~0</code> has all bits one (it has, of course).</strong></p>\n<p>But what we are talking about is what the result of the initialized <code>flags</code> variable is. And for it, <strong>only <code>-1</code></strong> will work with every type and machine. </p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2013-03-12T23:28:40.407", "Score": "146", "CreationDate": "2009-04-30T22:08:08.073", "ParentId": "809227", "CommentCount": "25", "OwnerUserId": "34509", "LastEditDate": "2013-03-12T23:28:40.407"}, "3904940": {"Id": "3904940", "PostTypeId": "2", "Body": "<p>yes the representation shown is very much correct as if we do it the other way round u will require an operator to reverse all the bits but in this case the logic is quite straightforward if we consider the size of the integers in the machine</p>\n<p>for instance in most machines an integer is 2 bytes = 16 bits maximum value it can hold is 2^16-1=65535 2^16=65536</p>\n<p>0%65536=0\n-1%65536=65535 which corressponds to 1111.............1 and all the bits are set to 1 (if we consider residue classes mod 65536)\nhence it is much straight forward.</p>\n<p>I guess</p>\n<p>no if u consider this notion it is perfectly dine for unsigned ints and it actually works out</p>\n<p>just check the following program fragment</p>\n<p>int main()\n{</p>\n<pre><code>unsigned int a=2;\n\ncout&lt;&lt;(unsigned int)pow(double(a),double(sizeof(a)*8));\n\nunsigned int b=-1;\n\ncout&lt;&lt;\"\\n\"&lt;&lt;b;\n\ngetchar();\n\nreturn 0;\n</code></pre>\n<p>}</p>\n<p>answer for b = 4294967295 whcih is -1%2^32 on 4 byte integers</p>\n<p>hence it is perfectly valid for unsigned integers</p>\n<p>in case of any discrepancies plzz report</p>\n", "LastEditorUserId": "472135", "LastActivityDate": "2010-10-11T09:32:44.470", "Score": "-6", "CreationDate": "2010-10-11T09:22:38.597", "ParentId": "809227", "CommentCount": "1", "OwnerUserId": "472135", "LastEditDate": "2010-10-11T09:32:44.470"}, "3905757": {"Id": "3905757", "PostTypeId": "2", "Body": "<p>I say:</p>\n<pre><code>int x;\nmemset(&amp;x, 0xFF, sizeof(int));\n</code></pre>\n<p>This will always give you the desired result.</p>\n", "LastActivityDate": "2010-10-11T11:28:57.730", "CommentCount": "1", "CreationDate": "2010-10-11T11:28:57.730", "ParentId": "809227", "Score": "0", "OwnerUserId": "420"}, "809505": {"Id": "809505", "PostTypeId": "2", "Body": "<p>I would not do the -1 thing.  It's rather non-intuitive (to me at least).  Assigning signed data to an unsigned variable just seems to be a violation of the natural order of things.</p>\n<p>In your situation, I always use <code>0xFFFF</code>.  (Use the right number of Fs for the variable size of course.)</p>\n<p>[BTW, I very rarely see the -1 trick done in real-world code.]</p>\n<p>Additionally, if you really care about the individual bits in a vairable, it would be good idea to start using the fixed-width <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> types.</p>\n", "LastEditorUserId": "1225413", "LastActivityDate": "2012-12-10T05:24:21.603", "Score": "3", "CreationDate": "2009-04-30T22:58:52.443", "ParentId": "809227", "CommentCount": "0", "OwnerUserId": "21962", "LastEditDate": "2012-12-10T05:24:21.603"}, "809251": {"Id": "809251", "PostTypeId": "2", "Body": "<p>Frankly I think all fff's is more readable. As to the comment that its an antipattern, if you really care that all the bits are set/cleared, I would argue that you are probably in a situation where you care about the size of the variable anyway, which would call for something like boost::uint16_t, etc.</p>\n", "LastActivityDate": "2009-04-30T21:42:34.950", "CommentCount": "2", "CreationDate": "2009-04-30T21:42:34.950", "ParentId": "809227", "Score": "24", "OwnerUserId": "8123"}, "6202945": {"Id": "6202945", "PostTypeId": "2", "Body": "<p>Although the <code>0xFFFF</code> (or <code>0xFFFFFFFF</code>, etc.) may be easier to read, it can break portability in code which would otherwise be portable.  Consider, for example, a library routine to count how many items in a data structure have certain bits set (the exact bits being specified by the caller).  The routine may be totally agnostic as to what the bits represent, but still need to have an \"all bits set\" constant.  In such a case, -1 will be vastly better than a hex constant since it will work with any bit size.</p>\n<p>The other possibility, if a <code>typedef</code> value is used for the bitmask, would be to use ~(bitMaskType)0; if bitmask happens to only be a 16-bit type, that expression will only have 16 bits set (even if 'int' would otherwise be 32 bits) but since 16 bits will be all that are required, things should be fine <em>provided</em> that one actually uses the appropriate type in the typecast.</p>\n<p>Incidentally, expressions of the form <code>longvar &amp;= ~[hex_constant]</code> have a nasty gotcha if the hex constant is too large to fit in an <code>int</code>, but will fit in an <code>unsigned int</code>.  If an <code>int</code> is 16 bits, then <code>longvar &amp;= ~0x4000;</code> or <code>longvar &amp;= ~0x10000</code>; will clear one bit of <code>longvar</code>, but <code>longvar &amp;= ~0x8000;</code> will clear out bit 15 and all bits above that.  Values which fit in <code>int</code> will have the complement operator applied to a type <code>int</code>, but the result will be sign extended to <code>long</code>, setting the upper bits.  Values which are too big for <code>unsigned int</code> will have the complement operator applied to type <code>long</code>.  Values which are between those sizes, however, will apply the complement operator to type <code>unsigned int</code>, which will then be converted to type <code>long</code> without sign extension.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2012-12-10T16:09:34.303", "Score": "1", "CreationDate": "2011-06-01T14:37:25.383", "ParentId": "809227", "CommentCount": "0", "OwnerUserId": "363751", "LastEditDate": "2012-12-10T16:09:34.303"}, "809244": {"Id": "809244", "PostTypeId": "2", "Body": "<p>I am not sure using an unsigned int for flags is a good idea in the first place in C++. What about bitset and the like?</p>\n<p><code>std::numeric_limit&lt;unsigned int&gt;::max()</code> is better because <code>0xffffffff</code> assumes that unsigned int is a 32-bit integer. </p>\n", "LastEditorUserId": "1225413", "LastActivityDate": "2012-12-10T05:26:20.370", "Score": "12", "CreationDate": "2009-04-30T21:41:17.543", "ParentId": "809227", "CommentCount": "4", "OwnerUserId": "41363", "LastEditDate": "2012-12-10T05:26:20.370"}});