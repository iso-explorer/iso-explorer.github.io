post_cb({"bq_ids": {"n4140": {"so_39355788_39355788_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 2727}, "so_39355788_39355788_4": {"length": 7, "quality": 0.875, "section_id": 2751}, "so_39355788_39357753_2": {"length": 6, "quality": 1.0, "section_id": 2760}, "so_39355788_39355788_7": {"length": 30, "quality": 0.967741935483871, "section_id": 2659}, "so_39355788_39355788_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2753}, "so_39355788_39355788_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 2760}, "so_39355788_39355788_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 2760}, "so_39355788_39357753_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 2777}}, "n3337": {"so_39355788_39355788_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 2721}, "so_39355788_39355788_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 2721}, "so_39355788_39355788_7": {"length": 30, "quality": 0.967741935483871, "section_id": 2623}, "so_39355788_39355788_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2714}, "so_39355788_39355788_4": {"length": 7, "quality": 0.875, "section_id": 2712}, "so_39355788_39357753_2": {"length": 6, "quality": 1.0, "section_id": 2721}, "so_39355788_39355788_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 2688}, "so_39355788_39357753_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 2738}}, "n4659": {"so_39355788_39355788_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 3498}, "so_39355788_39355788_7": {"length": 30, "quality": 0.967741935483871, "section_id": 3399}, "so_39355788_39355788_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3491}, "so_39355788_39355788_4": {"length": 7, "quality": 0.875, "section_id": 3489}, "so_39355788_39357753_2": {"length": 6, "quality": 1.0, "section_id": 3498}, "so_39355788_39355788_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 3466}, "so_39355788_39357753_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3515}}}, "39355788": {"ViewCount": "268", "Body": "<p>Suppose we have the following code:</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nstd::mutex m;\n\nvoid foo()\n{\n    m.lock();\n}\n\nint main()\n{\n    std::thread th(foo);\n    m.lock();\n    th.join();\n}\n</code></pre>\n<p>I know that this code contains a deadlock but I wonder about the following statement in the C++ Standard:</p>\n<p><strong>30.4.1.2 Mutex types [thread.mutex.requirements.mutex]</strong></p>\n<blockquote>\n<p id=\"so_39355788_39355788_0\">6 The expression m.lock() shall be well-formed and have the following\n  semantics:</p>\n<p id=\"so_39355788_39355788_1\">[...]</p>\n<p id=\"so_39355788_39355788_2\">12 Throws: system_error when an exception is required (30.2.2).</p>\n<p id=\"so_39355788_39355788_3\">13 Error conditions:</p>\n<p id=\"so_39355788_39355788_4\">\u2014 (13.1) operation_not_permitted \u2014 if the thread does not have the\n  privilege to perform the operation.</p>\n<p id=\"so_39355788_39355788_5\">\u2014 (13.2) resource_deadlock_would_occur \u2014 if the implementation detects\n  that a deadlock would occur.</p>\n<p id=\"so_39355788_39355788_6\">\u2014 (13.3) device_or_resource_busy \u2014 if the mutex is already locked\n  and blocking is not possible.</p>\n</blockquote>\n<p>As we can see, violating one of these rules should result in an exception:</p>\n<p><strong>30.2.2 Exceptions [thread.req.exception]</strong></p>\n<blockquote>\n<p id=\"so_39355788_39355788_7\">1 Some functions described in this Clause are specified to throw\n  exceptions of type system_error (19.5.7).\n  <strong>Such exceptions shall be thrown if any of the function\u2019s error conditions is detected</strong> or a call to an operating system or other\n  underlying API results in an error that prevents the library function\n  from meeting its specifications</p>\n</blockquote>\n<p>The code I provided surely contains a deadlock. Should the standard library throw an exception in such case then (because g++ and Visual C++ don't do it)? If not, why? Because from my point of view it seems that it either falls into 13.2 (resource_deadlock_would_occur) or 13.3 (device_or_resource_busy) category.</p>\n", "Title": "Why doesn't lock() throw an exception in case of a deadlock", "CreationDate": "2016-09-06T18:40:33.013", "LastActivityDate": "2016-09-06T20:59:40.017", "CommentCount": "8", "LastEditDate": "2016-09-06T18:53:46.937", "PostTypeId": "1", "LastEditorUserId": "27678", "Id": "39355788", "Score": "1", "OwnerUserId": "1608835", "Tags": "<c++><multithreading><c++11><c++14>", "AnswerCount": "2"}, "39357753": {"Id": "39357753", "PostTypeId": "2", "Body": "<p>30.4.1.2.1 [thread.mutex.class]</p>\n<blockquote id=\"so_39355788_39357753_0\">\n<ol start=\"4\">\n<li>[ Note: A program may deadlock if the thread that owns a mutex object calls lock() on that object. If the implementation can detect the deadlock, a resource_deadlock_would_occur error condition may be observed. \u2014end note ]</li>\n</ol>\n</blockquote>\n<p>And according to the pthread manual for <a href=\"http://pubs.opengroup.org/onlinepubs/007908775/xsh/pthread_mutex_lock.html\" rel=\"nofollow\">pthread_mutex_lock</a>:</p>\n<blockquote>\n<p id=\"so_39355788_39357753_1\">If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection is not provided. Attempting to relock the mutex causes deadlock. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, undefined behaviour results.</p>\n</blockquote>\n<p>Remember, in the standard section you quoted:</p>\n<blockquote>\n<p id=\"so_39355788_39357753_2\">\u2014 resource_deadlock_would_occur \u2014 if the implementation detects that a deadlock would occur.</p>\n</blockquote>\n<p>the key word is <em>if</em>.</p>\n", "LastActivityDate": "2016-09-06T20:59:40.017", "Score": "0", "CreationDate": "2016-09-06T20:59:40.017", "ParentId": "39355788", "CommentCount": "0", "OwnerUserId": "257645"}, "39356098": {"Id": "39356098", "PostTypeId": "2", "Body": "<p>You should program your code to handle deadlock exceptions, but do not rely on them to resolve deadlocks. There is no guarantee that deadlock exceptions will be thrown because they are not guaranteed to be detected. In other words, the implementation doesn't have to detect deadlocks, it just can, and that's how they are handled if they are found. It doesn't mean they will be found.</p>\n<p>Deadlocking code is a logic error, don't write code that can deadlock.</p>\n", "LastActivityDate": "2016-09-06T19:01:56.370", "Score": "5", "CreationDate": "2016-09-06T19:01:56.370", "ParentId": "39355788", "CommentCount": "7", "OwnerUserId": "2016752"}});