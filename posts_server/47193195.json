post_cb({"bq_ids": {"n4140": {"so_47193195_47193591_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5787}, "so_47193195_47193591_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5787}, "so_47193195_47193591_1": {"length": 13, "quality": 1.0, "section_id": 5922}}, "n3337": {"so_47193195_47193591_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5560}, "so_47193195_47193591_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5560}, "so_47193195_47193591_1": {"length": 13, "quality": 1.0, "section_id": 5694}}, "n4659": {"so_47193195_47193591_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 7244}, "so_47193195_47193591_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7244}, "so_47193195_47193591_1": {"length": 13, "quality": 1.0, "section_id": 7396}}}, "47193667": {"Id": "47193667", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47193195_47193667_0\">Can you? </p>\n</blockquote>\n<p>To a certain extent, yes. However, if you need <code>s</code> to deference and access the different members/locations, then no. (And it should be obvious you cannot have another thread destroy <code>s</code> concurrently.)</p>\n<blockquote>\n<p id=\"so_47193195_47193667_1\">Should you?</p>\n</blockquote>\n<p>In this case almost certainly not. Otherwise you're simply breaking down an encapsulation that was supposed to simplify design by fiddling in nitty-gritty details.</p>\n<p>That said, the principle is important with a more practical example:<br>\nWhen you have a collection of objects, different threads can operate on different elements without concurrency concerns: <em>provided adding/removing/moving items in the collection has appropriate thread safety in place</em>.</br></p>\n<h2>CAUTION</h2>\n<p>You may need to pay attention to machine architecture to be certain of thread safety of unaligned, adjacent memory locations. (Even if the hardware protects you, this could come at a performance cost.)</p>\n", "LastActivityDate": "2017-11-09T03:58:12.417", "CommentCount": "0", "CreationDate": "2017-11-09T03:58:12.417", "ParentId": "47193195", "Score": "0", "OwnerUserId": "224704"}, "47193195": {"ViewCount": "70", "Body": "<p>In C++14, there is a sentense like:</p>\n<pre><code>Different threads of execution are always allowed to access (read and modify) different memory locations concurrently, with no interference and no synchronization requirements.\n\nstruct S {\n    char a;     // memory location #1\n    int b : 5;  // memory location #2\n    int c : 11, // memory location #2 (continued)\n          : 0,\n        d : 8;  // memory location #3\n    struct {\n        int ee : 8; // memory location #4\n    } e;\n} obj; // The object 'obj' consists of 4 separate memory locations\n</code></pre>\n<p>that means we can use two threads to change S s::a and S s::b without thinking the sync of S s?</p>\n", "Title": "Different threads access different memory locations concurrently", "CreationDate": "2017-11-09T03:03:07.913", "LastActivityDate": "2017-11-09T03:58:12.417", "CommentCount": "5", "LastEditDate": "2017-11-09T03:07:34.903", "PostTypeId": "1", "LastEditorUserId": "806808", "Id": "47193195", "Score": "2", "OwnerUserId": "6384548", "Tags": "<c++><memory>", "AnswerCount": "2"}, "47193591": {"Id": "47193591", "PostTypeId": "2", "Body": "<p>From n4296 in 2014 at least, section 1.7.3:</p>\n<blockquote>\n<p id=\"so_47193195_47193591_0\">A memory location is either an object of scalar type or a maximal sequence of adjacent bit-fields all having\n  non-zero width.</p>\n</blockquote>\n<p>So yes, your intuition seems correct that you can read and write to them from separate threads without synchronizing.</p>\n<p>Also, this seems at least tangentially relevant from section 9.6.2 in that same draft:</p>\n<blockquote>\n<p id=\"so_47193195_47193591_1\">As a special case, an unnamed bit-field with a width of zero\n  specifies alignment of the next bit-field at an allocation unit boundary</p>\n</blockquote>\n<p>The same verbiage is in n4659 from 2017 in sections 4.4.3 and 12.2.4.2, respectively.</p>\n<p>I don't see the exact verbiage as the OP in n4296, but this is in section 1.7.3:</p>\n<blockquote>\n<p id=\"so_47193195_47193591_2\">Two or more threads of execution (1.10) can update and access separate memory\n  locations without interfering with each other.</p>\n</blockquote>\n", "LastEditorUserId": "2850543", "LastActivityDate": "2017-11-09T03:56:24.670", "Score": "0", "CreationDate": "2017-11-09T03:48:48.253", "ParentId": "47193195", "CommentCount": "0", "OwnerUserId": "2850543", "LastEditDate": "2017-11-09T03:56:24.670"}});