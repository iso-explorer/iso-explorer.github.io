post_cb({"16392885": {"CommentCount": "3", "AcceptedAnswerId": "16393281", "PostTypeId": "1", "LastEditorUserId": "759866", "CreationDate": "2013-05-06T06:07:22.550", "LastActivityDate": "2014-02-24T01:06:18.373", "LastEditDate": "2014-02-24T01:06:18.373", "ViewCount": "383", "FavoriteCount": "3", "Title": "Why is my specialized template function invoked only in debug builds?", "Id": "16392885", "Score": "7", "Body": "<p>I have templated functions in my C++11 Xcode project and some of them have specializations. However, I have discovered that the specializations only get called in debug builds; if I build in release, they are ignored.</p>\n<p>I have successfully created a very simple example:</p>\n<p><strong>special.h</strong></p>\n<pre><code>#include &lt;cstdio&gt;\n\nstruct special\n{\n    template&lt;typename T&gt;\n    void call(const T&amp;) { puts(\"not so special\"); }\n};\n</code></pre>\n<p><strong>special.cpp</strong></p>\n<pre><code>#include \"special.h\"\n#include &lt;string&gt;\n\ntemplate&lt;&gt;\nvoid special::call(const std::string&amp;) { puts(\"very special\"); }\n</code></pre>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include \"special.h\"\n#include &lt;string&gt;\n\nint main()\n{\n    std::string str = \"hello world\";\n    special s;\n    s.call(123);\n    s.call(str);\n}\n</code></pre>\n<p><a href=\"http://wikisend.com/download/566650/special.zip\" rel=\"nofollow\">You can download the project</a> (until somewhere this summer of 2013 at least) to reproduce the issue if you don't want to create it yourself. First run the project with the debug configuration, then run it again in release. The output that I expect is:</p>\n<blockquote>\n<p id=\"so_16392885_16392885_0\">not so special<br>\n  very special</br></p>\n</blockquote>\n<p>And this is indeed what I get with the Debug build configuration. However, with Release, I get this:</p>\n<blockquote>\n<p id=\"so_16392885_16392885_1\">not so special<br>\n  not so special</br></p>\n</blockquote>\n<p>Which means the specialized implementation of <code>special::call</code> in special.cpp was ignored.</p>\n<p>Why is the result inconsistent? What should I do to ensure that the specialized function is called in release builds?</p>\n", "Tags": "<c++><xcode>", "OwnerUserId": "251153", "AnswerCount": "2"}, "16393381": {"ParentId": "16392885", "CommentCount": "3", "Body": "<p>You violated the one definition rule (ODR). So what happens exactly? In <code>main.cpp</code> there is no specialization known for <code>special::call&lt;string&gt;</code>. Therefore the compiler generates an instantiation of the template into that translation unit (TU) that outputs \"not so special\". In <code>special.cpp</code> there is a full specialization declared and defined, so the compiler puts that definition into the other translation unit. So you have two different definitions of the very same function in two different translation units, which is a violation of the ODR which means it is undefined behavior.</p>\n<p>In theory, the outcome can be anything. A compiler error, a crash, a silent online order for a pizza, <em>anything</em>. Even different behavior in debug and release compiles.</p>\n<p>In practice, I <em>guess</em> the following happens: When linking the debug build, the Linker sees the same symbol defined twice in the two TUs, which is allowed only for templates and inline functions. Because of the ODR it may assume that both definitions are equivalent and picks the one from <code>special.cpp</code>, so you get by coincidence the behavior you expect.<br>\nDuring release build, the compiler inlines the call to <code>special::call&lt;string&gt;</code> during the compilation of <code>main.cpp</code>, so you get the only behavior seen in that TU: \"not so special\". </br></p>\n<p>So how can you fix this?<br>\nIn order to have only one definition for that specialization, you have to <em>define</em> it in one TU as you did, but you have to <em>declare</em> that there is a full specialization in any other TU, meaning declare that the specialization exists in the header <code>special.h</code>:</br></p>\n<pre><code>// in special.h\ntemplate&lt;&gt;\nvoid special::call(const std::string&amp;);\n</code></pre>\n<p>Or, which is seen more often, <em>define</em> it in the header, so it's seen in every TU. Since fully specialized function templates are normal functions, you will have to define it inline:</p>\n<pre><code>// in special.h\ntemplate&lt;&gt;\ninline void special::call(const std::string&amp;)\n{ \n  puts(\"very special\"); \n}\n</code></pre>\n", "OwnerUserId": "1838266", "PostTypeId": "2", "Id": "16393381", "Score": "8", "CreationDate": "2013-05-06T06:44:56.037", "LastActivityDate": "2013-05-06T06:44:56.037"}, "bq_ids": {"n4140": {"so_16392885_16393281_0": {"section_id": 268, "quality": 1.0, "length": 29}}, "n3337": {"so_16392885_16393281_0": {"section_id": 259, "quality": 1.0, "length": 29}}, "n4659": {"so_16392885_16393281_0": {"section_id": 275, "quality": 1.0, "length": 29}}}, "16393281": {"ParentId": "16392885", "CommentCount": "0", "Body": "<p>Your program has UB. An explicit specialisation or at least its declaration must be visible before being used. [temp.expl.spec]\u00a76:</p>\n<blockquote>\n<p id=\"so_16392885_16393281_0\">If a template, a member template or a member of a class template is\n  explicitly specialized then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>Add this declaration to <code>special.h</code>:</p>\n<pre><code>template&lt;&gt;\nvoid special::call(const std::string&amp;);\n</code></pre>\n<p>Alternatively, you can put the specialistation itself into the header. However, as a specialisation is no longer a template, it follows normal function rules and must be marked <code>inline</code> if placed in a header.</p>\n<p>Also, be careful that function template specialisations have rather specific behaviour, and it's generally better to use overloads than specialisations. See <a href=\"http://www.gotw.ca/publications/mill17.htm\">Herb Sutter's article</a> for details.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "16393281", "Score": "11", "CreationDate": "2013-05-06T06:38:41.463", "LastActivityDate": "2013-05-06T06:38:41.463"}});