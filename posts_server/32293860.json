post_cb({"32294378": {"ParentId": "32293860", "CommentCount": "5", "Body": "<p>Almost.</p>\n<p>Doing #1 if it works, and if not #2 if it works, and if not #3 is a pretty basic tag dispatching/sfinae exercise.</p>\n<p>For #3:</p>\n<p>Create a namespace that is used nowhere else.  Nest it in another.</p>\n<p>In the outer, put a <code>=delete</code> begin function that takes anything.</p>\n<p>Put a helper function that calls <code>begin</code> in it.</p>\n<p>That will find the adl begin, and otherwise the deleted begin.</p>\n<p>The failure mode is that the namespaces could be used somewhere else; there is no way to prevent it.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "32294378", "Score": "1", "CreationDate": "2015-08-30T07:45:22.347", "LastActivityDate": "2015-08-30T07:45:22.347"}, "32548994": {"ParentId": "32293860", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The following SFINAE-friendly approach seems to work as desired (see below for exceptions):</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace detail {\n    struct empty {};\n    template &lt;typename T&gt;\n    using base = std::conditional_t&lt;std::is_class&lt;T&gt;{} &amp;&amp; not std::is_final&lt;T&gt;{},\n                                    T, empty&gt;;\n\n    struct P1 {typedef int begin, end;};\n    template &lt;typename U&gt;\n    struct TestMemType : base&lt;U&gt;, P1 {\n        template &lt;typename T=TestMemType, typename=typename T::begin&gt;\n        static std::true_type test_begin(int);\n        template &lt;typename T=TestMemType, typename=typename T::end&gt;\n        static std::true_type test_end(int);\n\n        static std::false_type test_begin(float), test_end(float);\n    };\n\n    template &lt;typename T&gt;\n    constexpr bool hasMember = !decltype(TestMemType&lt;T&gt;::test_begin(0)){}\n                            || !decltype(TestMemType&lt;T&gt;::test_end(0)){};\n\n    //! Step 1\n    template &lt;typename T, std::size_t N&gt;\n    constexpr auto begin(int, T(&amp;a)[N]) {return a;}\n    template &lt;typename T, std::size_t N&gt;\n    constexpr auto end(int, T(&amp;a)[N]) {return a+N;}\n\n    //! Step 2 - this overload is less specialized than the above.\n    template &lt;typename T&gt;\n    constexpr auto begin(int, T&amp; a) -&gt; decltype(a.begin()) {return a.begin();}\n    template &lt;typename T&gt;\n    constexpr auto end(int, T&amp; a) -&gt; decltype(a.end()) {return a.end();}\n\n    //! Step 3\n    namespace nested_detail {\n        void begin(), end();\n        template &lt;typename T&gt;\n        constexpr auto begin_(T&amp; a) -&gt; decltype(begin(a)) {return begin(a);}\n        template &lt;typename T&gt;\n        constexpr auto end_(T&amp; a) -&gt; decltype(end(a)) {return end(a);}\n    }\n    template &lt;typename T, typename=std::enable_if_t&lt;not hasMember&lt;std::decay_t&lt;T&gt;&gt;&gt;&gt;\n    constexpr auto begin(float, T&amp; a) -&gt; decltype(nested_detail::begin_(a))\n    {return nested_detail::begin_(a);}\n    template &lt;typename T, typename=std::enable_if_t&lt;not hasMember&lt;std::decay_t&lt;T&gt;&gt;&gt;&gt;\n    constexpr auto end(float, T&amp; a) -&gt; decltype(nested_detail::end_(a))\n    {return nested_detail::end_(a);}\n}\n\ntemplate &lt;typename T&gt;\nconstexpr auto magic_begin(T&amp; a) -&gt; decltype(detail::begin(0, a))\n{return detail::begin(0, a);}\ntemplate &lt;typename T&gt;\nconstexpr auto magic_end  (T&amp; a) -&gt; decltype(detail::end  (0, a))\n{return detail::  end(0, a);}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3c8514f56c017396\" rel=\"nofollow noreferrer\"><strong>Demo</strong></a>. Note that GCCs lookup is broken as it doesn't consider non-type names for <code>typename T::begin</code> in <code>TestMemType::test_end/begin</code>. A workaround sketch can be found <a href=\"http://coliru.stacked-crooked.com/a/8abb2f9761f4ea34\" rel=\"nofollow noreferrer\"><strong>here</strong></a>.</p>\n<p>The check in step 2 requires that the class type be derivable, which implies that this method doesn't properly work with <code>final</code> classes or unions - if those have an inaccessible member with name <code>begin</code>/<code>end</code>.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-10-11T17:42:55.000", "Id": "32548994", "Score": "11", "CreationDate": "2015-09-13T11:00:57.900", "LastActivityDate": "2015-10-11T17:42:55.000"}, "32293860": {"CommentCount": "6", "AcceptedAnswerId": "32548994", "LastEditDate": "2015-09-13T09:33:30.987", "LastEditorUserId": "2756719", "CreationDate": "2015-08-30T06:26:00.047", "LastActivityDate": "2015-10-11T17:42:55.000", "PostTypeId": "1", "ViewCount": "580", "FavoriteCount": "3", "Title": "Simulating the range-based for loop's begin/end behavior", "Id": "32293860", "OwnerUserId": "2756719", "Body": "<p>Consider the specification of the range-based for loop's <em>begin-expr</em> and <em>end-expr</em> (N4140 [stmt.ranged]/p1). Given a range <code>__range</code> of type <code>_RangeT</code>,</p>\n<blockquote>\n<p id=\"so_32293860_32293860_0\"><em>begin-expr</em> and <em>end-expr</em> are determined as follows:</p>\n<ul>\n<li>if <code>_RangeT</code> is an array type, <em>begin-expr</em> and <em>end-expr</em> are <code>__range</code> and <code>__range + __bound</code>, respectively, where <code>__bound</code> is\n  the array bound. If <code>_RangeT</code> is an array of unknown size or an array\n  of incomplete type, the program is ill-formed;</li>\n<li>if <code>_RangeT</code> is a class type, the <em>unqualified-id</em>s <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access\n  lookup (3.4.5), and if either (or both) finds at least one\n  declaration, <em>begin-expr</em> and <em>end-expr</em> are <code>__range.begin()</code> and\n  <code>__range.end()</code>, respectively;</li>\n<li>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up in\n  the associated namespaces (3.4.2). [ <em>Note</em>: Ordinary unqualified\n  lookup (3.4.1) is not performed. \u2014<em>end note</em> ]</li>\n</ul>\n</blockquote>\n<p>Is it possible to simulate this <em>exact</em> behavior in ordinary C++ code? i.e., can we write a <code>magic_begin</code> and a <code>magic_end</code> function template such that</p>\n<pre><code>for(auto&amp;&amp; p : range_init) { /* statements */ }\n</code></pre>\n<p>and</p>\n<pre><code>{\n    auto&amp;&amp; my_range = range_init;\n    for(auto b = magic_begin(my_range), e = magic_end(my_range); b != e; ++b){\n        auto&amp;&amp; p = *b;\n        /* statements */\n    }\n}\n</code></pre>\n<p>always have the exact same behavior?</p>\n<p>Non-answers include qualified calls to <code>std::begin</code>/<code>std::end</code> (doesn't handle the third bullet, among other things) and <code>using std::begin; begin(range);</code> because, among other things, that is ambiguous if ADL for <code>begin</code> finds an overload that's equally good as <code>std::begin</code>.</p>\n<hr>\n<p>For illustration, given</p>\n<pre><code>namespace foo {\n    struct A { int begin; }; \n    struct B { using end = int; };\n    class C { int* begin(); int *end(); }; // inaccessible\n    struct D { int* begin(int); int* end();};\n    struct E {};\n\n    template&lt;class T&gt; int* begin(T&amp;) { return nullptr; }\n    template&lt;class T&gt; int* end(T&amp;) { return nullptr; }\n}\n\nfoo::A a; foo::B b; foo::C c; foo::D d; foo::E e;\n</code></pre>\n<p>I want <code>magic_begin(a)</code>/<code>magic_begin(b)</code>/<code>magic_begin(c)</code>/<code>magic_begin(d)</code> to be a compile error, and <code>magic_begin(e)</code> to return <code>(int*)nullptr</code>.</p>\n</hr>", "Tags": "<c++><c++11><foreach><c++14>", "Score": "14", "AnswerCount": "2"}, "bq_ids": {"n4659": {"so_32293860_32293860_0": {"section_id": 4792, "quality": 1.0, "length": 4}}}});