post_cb({"bq_ids": {"n4140": {"so_27158812_27158813_1": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_27158812_27158813_3": {"length": 14, "quality": 0.875, "section_id": 6004}, "so_27158812_27158813_2": {"length": 28, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_27158812_27158813_1": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_27158812_27158813_3": {"length": 14, "quality": 0.875, "section_id": 5772}, "so_27158812_27158813_2": {"length": 28, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_27158812_27158813_1": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_27158812_27158813_3": {"length": 14, "quality": 0.875, "section_id": 7503}, "so_27158812_27158813_2": {"length": 28, "quality": 1.0, "section_id": 7273}}}, "27158812": {"ViewCount": "5322", "Body": "<p>In Bjarne Stroustrup's <em><a href=\"https://en.wikipedia.org/wiki/The_C%2B%2B_Programming_Language\">The C++ Programming Language</a></em> 4th edition section <code>36.3.6</code> <em>STL-like Operations</em> the following code is used as an example of <a href=\"http://en.wikipedia.org/wiki/Method_chaining\">chaining</a>:</p>\n<pre><code>void f2()\n{\n    std::string s = \"but I have heard it works even if you don't believe in it\" ;\n    s.replace(0, 4, \"\" ).replace( s.find( \"even\" ), 4, \"only\" )\n        .replace( s.find( \" don't\" ), 6, \"\" );\n\n    assert( s == \"I have heard it works only if you believe in it\" ) ;\n}\n</code></pre>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/error/assert\">assert</a> fails in <code>gcc</code> (<em><a href=\"http://coliru.stacked-crooked.com/a/d3d81ff98cab2f5c\">see it live</a></em>) and <code>Visual Studio</code> (<em><a href=\"http://rextester.com/IFNX5880\">see it live</a></em>), but it does not fail when using <a href=\"http://en.wikipedia.org/wiki/Clang\">Clang</a> (<em><a href=\"http://coliru.stacked-crooked.com/a/e6facaa9f18e252f\">see it live</a></em>).</p>\n<p>Why am I getting different results? Are any of these compilers incorrectly evaluating the chaining expression or does this code exhibit some form of <a href=\"http://en.wikipedia.org/wiki/Unspecified_behavior\">unspecified</a> or <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a>?</p>\n", "Title": "Does this code from \"The C++ Programming Language\" 4th edition section 36.3.6 have well-defined behavior?", "CreationDate": "2014-11-26T21:02:34.740", "LastActivityDate": "2017-06-13T11:27:51.610", "CommentCount": "4", "FavoriteCount": "17", "PostTypeId": "1", "LastEditDate": "2014-12-01T14:10:28.853", "LastEditorUserId": "1708801", "Id": "27158812", "Score": "87", "OwnerUserId": "1708801", "Tags": "<c++><c++11><language-lawyer><order-of-evaluation><unspecified-behavior>", "AnswerCount": "2"}, "27158813": {"Id": "27158813", "PostTypeId": "2", "Body": "<p>The code exhibits unspecified behavior due to unspecified order of evaluation of sub-expressions although it does not invoke undefined behavior since all side effects are done within functions <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\">which introduces a sequencing relationship</a> between the side effects in this case.</p>\n<p>This example is mentioned in the proposal <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4228.pdf\">N4228: Refining Expression Evaluation Order for Idiomatic C++</a> which says the following about the code in the question:</p>\n<blockquote>\n<p id=\"so_27158812_27158813_0\">[...]This code has been reviewed by C++ experts world-wide, and published\n  (The C++ Programming Language, 4<sup>th</sup> edition.) Yet, its vulnerability\n  to unspecified order of evaluation has been discovered only recently\n  by a tool[...]</p>\n</blockquote>\n<p><b>Details</b></p>\n<p>It may be obvious to many that arguments to functions have an unspecified order of evaluation but it is probably not as obvious how this behavior interacts with chained functions calls. It was not obvious to me when I first analyzed this case and apparently not to all the <em>expert reviewers</em> either. </p>\n<p>At first glance it may appear that since each <code>replace</code> has to be evaluated from left to right that the corresponding function argument groups must be evaluated as groups from left to right as well. </p>\n<p>This is incorrect, function arguments have an unspecified order of evaluation,  although chaining function calls does introduce a left to right evaluation order for each function call, the arguments of each function call are only sequenced before with respect to the member function call they are part of. In particular this impacts the following calls:</p>\n<pre><code>s.find( \"even\" )\n</code></pre>\n<p>and:</p>\n<pre><code>s.find( \" don't\" )\n</code></pre>\n<p>which are indeterminately sequenced with respect to:</p>\n<pre><code>s.replace(0, 4, \"\" )\n</code></pre>\n<p>the two <code>find</code> calls could be evaluated before or after the <code>replace</code>, which matters since it has a side effect on <code>s</code> in a way that would alter the result of <code>find</code>, it changes the length of <code>s</code>. So depending on when that <code>replace</code> is evaluated relative to the two <code>find</code> calls the result will differ.</p>\n<p>If we look at the chaining expression and examine the evaluation order of some of the sub-expressions:</p>\n<pre><code>s.replace(0, 4, \"\" ).replace( s.find( \"even\" ), 4, \"only\" )\n^ ^       ^  ^  ^    ^        ^                 ^  ^\nA B       |  |  |    C        |                 |  |\n          1  2  3             4                 5  6\n</code></pre>\n<p>and:</p>\n<pre><code>.replace( s.find( \" don't\" ), 6, \"\" );\n ^        ^                   ^  ^\n D        |                   |  |\n          7                   8  9\n</code></pre>\n<p>Note, we are ignoring the fact that <code>4</code> and <code>7</code> can be further broken down into more sub-expressions. So:</p>\n<ul>\n<li><code>A</code> is sequenced before <code>B</code> which is sequenced before <code>C</code> which is sequenced before <code>D</code></li>\n<li><code>1</code> to <code>9</code> are indeterminately sequenced with respect to other sub-expressions with some of the exceptions listed below\n\n<ul>\n<li><code>1</code> to <code>3</code> are sequenced before <code>B</code></li>\n<li><code>4</code> to <code>6</code> are sequenced before <code>C</code></li>\n<li><code>7</code> to <code>9</code> are sequenced before <code>D</code></li>\n</ul></li>\n</ul>\n<p>The key to this issue is that:</p>\n<ul>\n<li><code>4</code> to <code>9</code> are indeterminately sequenced with respect to <code>B</code></li>\n</ul>\n<p>The potential order of evaluation choice for <code>4</code> and <code>7</code> with respect to <code>B</code> explains the difference in results between <code>clang</code> and <code>gcc</code> when evaluating <code>f2()</code>. In my tests <code>clang</code> evaluates <code>B</code> before evaluating <code>4</code> and <code>7</code> while <code>gcc</code> evaluates it after. We can use the following test program to demonstrate what is happening in each case:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::string::size_type my_find( std::string s, const char *cs )\n{\n    std::string::size_type pos = s.find( cs ) ;\n    std::cout &lt;&lt; \"position \" &lt;&lt; cs &lt;&lt; \" found in complete expression: \"\n        &lt;&lt; pos &lt;&lt; std::endl ;\n\n    return pos ;\n}\n\nint main()\n{\n   std::string s = \"but I have heard it works even if you don't believe in it\" ;\n   std::string copy_s = s ;\n\n   std::cout &lt;&lt; \"position of even before s.replace(0, 4, \\\"\\\" ): \" \n         &lt;&lt; s.find( \"even\" ) &lt;&lt; std::endl ;\n   std::cout &lt;&lt; \"position of  don't before s.replace(0, 4, \\\"\\\" ): \" \n         &lt;&lt; s.find( \" don't\" ) &lt;&lt; std::endl &lt;&lt; std::endl;\n\n   copy_s.replace(0, 4, \"\" ) ;\n\n   std::cout &lt;&lt; \"position of even after s.replace(0, 4, \\\"\\\" ): \" \n         &lt;&lt; copy_s.find( \"even\" ) &lt;&lt; std::endl ;\n   std::cout &lt;&lt; \"position of  don't after s.replace(0, 4, \\\"\\\" ): \"\n         &lt;&lt; copy_s.find( \" don't\" ) &lt;&lt; std::endl &lt;&lt; std::endl;\n\n   s.replace(0, 4, \"\" ).replace( my_find( s, \"even\" ) , 4, \"only\" )\n        .replace( my_find( s, \" don't\" ), 6, \"\" );\n\n   std::cout &lt;&lt; \"Result: \" &lt;&lt; s &lt;&lt; std::endl ;\n}\n</code></pre>\n<p>Result for <code>gcc</code> (<em><a href=\"http://coliru.stacked-crooked.com/a/a6035cb6e64f038f\">see it live</a></em>)</p>\n<pre><code>position of even before s.replace(0, 4, \"\" ): 26\nposition of  don't before s.replace(0, 4, \"\" ): 37\n\nposition of even after s.replace(0, 4, \"\" ): 22\nposition of  don't after s.replace(0, 4, \"\" ): 33\n\nposition  don't found in complete expression: 37\nposition even found in complete expression: 26\n\nResult: I have heard it works evenonlyyou donieve in it\n</code></pre>\n<p>Result for <code>clang</code> (<em><a href=\"http://coliru.stacked-crooked.com/a/84408d788238bacd\">see it live</a></em>):</p>\n<pre><code>position of even before s.replace(0, 4, \"\" ): 26\nposition of  don't before s.replace(0, 4, \"\" ): 37\n\nposition of even after s.replace(0, 4, \"\" ): 22\nposition of  don't after s.replace(0, 4, \"\" ): 33\n\nposition even found in complete expression: 22\nposition don't found in complete expression: 33\n\nResult: I have heard it works only if you believe in it\n</code></pre>\n<p>Result for <code>Visual Studio</code> (<em><a href=\"http://rextester.com/VKFPX23982\">see it live</a></em>):</p>\n<pre><code>position of even before s.replace(0, 4, \"\" ): 26\nposition of  don't before s.replace(0, 4, \"\" ): 37\n\nposition of even after s.replace(0, 4, \"\" ): 22\nposition of  don't after s.replace(0, 4, \"\" ): 33\n\nposition  don't found in complete expression: 37\nposition even found in complete expression: 26\nResult: I have heard it works evenonlyyou donieve in it\n</code></pre>\n<p><b>Details from the standard</b></p>\n<p>We know that unless specified the evaluations of sub-expressions are unsequenced, this is from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">draft C++11 standard</a> section <code>1.9</code> <em>Program execution</em> which says:</p>\n<blockquote>\n<p id=\"so_27158812_27158813_1\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced.[...]</p>\n</blockquote>\n<p>and we know that a function call introduces a sequenced before relationship of the function calls postfix expression and arguments with respect to the function body, from section <code>1.9</code>:</p>\n<blockquote>\n<p id=\"so_27158812_27158813_2\">[...]When calling a function (whether or not the function is inline), every\n  value computation and side effect associated with any argument\n  expression, or with the postfix expression designating the called\n  function, is sequenced before execution of every expression or\n  statement in the body of the called function.[...]</p>\n</blockquote>\n<p>We also know that class member access and therefore chaining will evaluate from left to right, from section <code>5.2.5</code> <em>Class member access</em> which says:</p>\n<blockquote>\n<p id=\"so_27158812_27158813_3\">[...]The postfix expression before the dot or arrow is evaluated;<sup>64</sup>\n  the result of that evaluation, together with the id-expression,\n  determines the result of the entire postfix expression.</p>\n</blockquote>\n<p>Note, in the case where the <em>id-expression</em> ends up being a non-static member function it does not specify the order of evaluation of the <em>expression-list</em> within the <code>()</code> since that is a separate sub-expression. The relevant grammar from <code>5.2</code> <em>Postfix expressions</em>:</p>\n<pre><code>postfix-expression:\n    postfix-expression ( expression-listopt)       // function call\n    postfix-expression . templateopt id-expression // Class member access, ends\n                                                   // up as a postfix-expression\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-10-22T12:57:09.297", "Score": "94", "CreationDate": "2014-11-26T21:02:34.740", "ParentId": "27158812", "CommentCount": "6", "OwnerUserId": "1708801", "LastEditDate": "2015-10-22T12:57:09.297"}, "44497816": {"Id": "44497816", "PostTypeId": "2", "Body": "<p>This is intended to add information on the matter with regards to C++17. The proposal (<a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0145r1.pdf\" rel=\"nofollow noreferrer\">Refining Expression Evaluation Order for Idiomatic C++ Revision 2</a>) for <code>C++17</code> addressed the issue citing the code above was as specimen.</p>\n<p>As suggested, I added relevant information from the proposal and to quote (highlights mine):</p>\n<blockquote>\n<p id=\"so_27158812_44497816_0\">The order of expression evaluation, as it is currently specified in the standard, undermines advices, popular programming idioms, or the relative safety of standard library facilities. The traps aren't just for novices\n  or the careless programmer. They affect all of us indiscriminately, even when we know the rules.</p>\n<p id=\"so_27158812_44497816_1\">Consider the following program fragment:</p>\n<pre><code>void f()\n{\n  std::string s = \"but I have heard it works even if you don't believe in it\"\n  s.replace(0, 4, \"\").replace(s.find(\"even\"), 4, \"only\")\n      .replace(s.find(\" don't\"), 6, \"\");\n  assert(s == \"I have heard it works only if you believe in it\");\n}\n</code></pre>\n<p id=\"so_27158812_44497816_2\">The assertion is supposed to validate the programmer's intended result. It uses \"chaining\" of member function calls, a common standard practice. This code has been reviewed by C++ experts world-wide, and published (The C++ Programming Language, 4th edition.) Yet, its <strong>vulnerability to unspecified order of evaluation</strong> has been discovered only recently by a tool.</p>\n</blockquote>\n<p>The paper suggested changing the pre-<code>C++17</code> rule on the order of expression evaluation which was influenced by <code>C</code> and have existed for more than three decades. It proposed that <em>the language should guarantee contemporary idioms</em> or risk <em>\"traps and sources of obscure, hard to find bugs\"</em> such as what happened with the code specimen above.</p>\n<p>The proposal for <code>C++17</code> is to <strong>require that every expression has a well-defined evaluation order</strong>:</p>\n<ul>\n<li>Postfix expressions are evaluated from left to right. This includes functions calls and member selection expressions.</li>\n<li>Assignment expressions are evaluated from right to left. This includes compound assignments.</li>\n<li>Operands to shift operators are evaluated from left to right.</li>\n<li>The order of evaluation of an expression involving an overloaded operator is determined by the order associated with the corresponding built-in operator, not the rules for function calls.</li>\n</ul>\n<p>The above code compiles successfully using <code>GCC 7.1.1</code> and <code>Clang 4.0.0</code>.</p>\n", "LastEditorUserId": "6091491", "LastActivityDate": "2017-06-13T11:27:51.610", "Score": "3", "CreationDate": "2017-06-12T11:02:31.467", "ParentId": "27158812", "CommentCount": "0", "OwnerUserId": "6091491", "LastEditDate": "2017-06-13T11:27:51.610"}});