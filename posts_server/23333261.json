post_cb({"23333298": {"ParentId": "23333261", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Map is lazily initialize with default constructor.(zero for all int)</p>\n<p>So it <code>0</code> didn't exist in map, it would be initialized to contain value 0 and 1 would be added after <code>+= 1</code>.</p>\n<p>So you can use upper version of code without any worries.</p>\n<p>Quoting <strong>Effect of calling map_obj[k]</strong> from <a href=\"http://www.cplusplus.com/reference/map/map/operator%5B%5D/\" rel=\"nofollow\">cplusplus.com</a></p>\n<blockquote>\n<p id=\"so_23333261_23333298_0\">If k matches the key of an element in the container, the function\n  returns a reference to its mapped value.</p>\n<p id=\"so_23333261_23333298_1\">If k does not match the key of any element in the container, the\n  function inserts a new element with that key and returns a reference\n  to its mapped value. Notice that this always increases the container\n  size by one, even if no mapped value is assigned to the element (the\n  element is constructed using its default constructor).</p>\n</blockquote>\n", "OwnerUserId": "2659313", "LastEditorUserId": "273767", "LastEditDate": "2014-04-30T03:01:13.137", "Id": "23333298", "Score": "2", "CreationDate": "2014-04-28T05:41:58.610", "LastActivityDate": "2014-04-30T03:01:13.137"}, "23333304": {"ParentId": "23333261", "CommentCount": "0", "Body": "<p>Yes this is fine, new entries default to value <code>value_type()</code> which is <code>0</code> for <code>int</code>.</p>\n<p>It still does <code>+=</code>, but <code>0 += 1</code> gives <code>1</code>.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "23333304", "Score": "4", "CreationDate": "2014-04-28T05:42:16.207", "LastActivityDate": "2014-04-28T05:42:16.207"}, "23333261": {"CommentCount": "1", "AcceptedAnswerId": "23333417", "CreationDate": "2014-04-28T05:39:02.163", "LastActivityDate": "2014-05-17T04:01:29.177", "Title": "Safe to use += operator to create a new std::map entry using []?", "ViewCount": "995", "PostTypeId": "1", "Id": "23333261", "Score": "12", "Body": "<p>Let's say I have a <code>std::map&lt;int, int&gt;</code>, would it be safe to do this?</p>\n<pre><code>std::map&lt;int, int&gt; m_map;\nm_map[0] += 1;\n</code></pre>\n<p>If the key <code>0</code> didn't exist in the map when I do this, how would it know what value to add <code>1</code> to?</p>\n<p>What I'm hoping is that std::map handles this by performing an <code>=</code> instead of <code>+=</code> in the case where the value creates a new entry in the map. This would spare me from having to do:</p>\n<pre><code>std::map&lt;int, int&gt;::iterator it = m_map.find(0);\nif(it != m_map.end()) {\n    it-&gt;second += 1;\n}\nelse {\n    m_map[0] = 1;\n}\n</code></pre>\n", "Tags": "<c++><map>", "OwnerUserId": "967504", "AnswerCount": "4"}, "23333347": {"ParentId": "23333261", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's guaranteed that you'll get 1 even with the shorter snippet. </p>\n<p>The key is that <code>operator[]</code> has to create the element in the map <em>before</em> returning a reference to it, so by the time you got to <code>+=</code> the element already exists, and, if it had to be created now, with value zero (since elements of a map are value-initialized). </p>\n<p>(incidentally, this is the reason why, when you use an <code>std::map</code> with a class type as value, it has to have a default constructor if you want to use <code>operator[]</code>, even if you assign an object to it immediately) </p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2014-04-28T05:52:28.230", "Id": "23333347", "Score": "7", "CreationDate": "2014-04-28T05:45:39.590", "LastActivityDate": "2014-04-28T05:52:28.230"}, "bq_ids": {"n4659": {"so_23333261_23333298_0": {"section_id": 823, "quality": 0.6, "length": 6}}}, "23333417": {"ParentId": "23333261", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>An element inserted into a map on invoke of <code>operator[]</code> due to a previously-unmapped key is <strong><em>value-initialized</em></strong>. If you've not seen that syntax, consider the special meaning the <strong><code>()</code></strong> has in the following code snippet. The parens are important. They introduce an different trip down the initialization tree than <em>default-initialization</em>. Both are important; both are laid out by the language standard. </p>\n<pre><code>int i = int();\n</code></pre>\n<p>As it turns out, value initialization for scalars (including pointers) eventually succumbs to <strong><em>zero-initialization</em></strong>. Though odd looking, the prior snippet value-initializes an instance of <code>int</code>, which becomes zero-initialization since <code>int</code> is a scalar, then copies it to <code>i</code>. (To be fair, there will almost certainly be some eliding, but the fundamentals are as-presented).</p>\n<p>Regardless, due to that feature, you can rest assured when you do this:</p>\n<pre><code>m_map[0] += 1;\n</code></pre>\n<p>or even this:</p>\n<pre><code>++m_map[0];\n</code></pre>\n<p>if the index wasn't mapped prior, a value-initialized element is added, which will zero-initialize for scalars, which means you'll officially starting out with <em>zero</em>.</p>\n<p>It is worth mentioning that a similar activity happens for <em>any type</em> with an implicitly declared constructor. Whether trivial or not, something interesting happens.</p>\n<pre><code>struct S { int a; int b; };\nstd::map&lt;int, S&gt; mymap;\n\n++mymap[0].a;\n</code></pre>\n<p>Is the <code>a</code> member mapped to <code>0</code> in our container reliably <code>1</code> after the above executes? <strong>Yes</strong>, it is. Further, consider this:</p>\n<pre><code>struct S { int a; std::string str; };\nstd::map&lt;int, S&gt; mymap;\n\n++mymap[0].a;\n</code></pre>\n<p>Now <code>S</code> has a non-trivial implicit constructor (it has to, as it must construct <code>str</code>). But is the <code>a</code> member mapped to <code>0</code> in our container <em>still</em> reliably zero-initialized (and therefore <code>1</code> after the above line)? <strong>Yes</strong>, it is. </p>\n<p>If curious about the referenced different paths of initialization, <a href=\"https://stackoverflow.com/a/14829622/1322972\"><strong>see this question and answer</strong></a>. Or review the C++11 standard, particularly <strong>C++11 \u00a7 8.5 Initializers, (p5,p7,p10)</strong>. It is worth the read.</p>\n", "OwnerUserId": "1322972", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:35.193", "Id": "23333417", "Score": "18", "CreationDate": "2014-04-28T05:52:14.430", "LastActivityDate": "2014-05-17T04:01:29.177"}});