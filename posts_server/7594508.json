post_cb({"7594508": {"CommentCount": "1", "AcceptedAnswerId": "7594577", "PostTypeId": "1", "LastEditorUserId": "2163727", "CreationDate": "2011-09-29T08:30:54.667", "LastActivityDate": "2017-06-05T19:18:42.560", "LastEditDate": "2015-09-28T21:07:32.537", "ViewCount": "88589", "FavoriteCount": "23", "Title": "Modulo operator with negative values", "Id": "7594508", "Score": "115", "Body": "<p>Why do such operations:</p>\n<pre><code>std::cout &lt;&lt; (-7 % 3) &lt;&lt; std::endl;\nstd::cout &lt;&lt; (7 % -3) &lt;&lt; std::endl;\n</code></pre>\n<p>give different results?</p>\n<pre><code>-1\n1\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "738811", "AnswerCount": "3"}, "44197900": {"ParentId": "7594508", "CommentCount": "0", "Body": "<pre><code>a % b\n</code></pre>\n<p>in c++ default:</p>\n<pre><code>(-7/3) =&gt; -2\n-2 * 3 =&gt; -6\nso a%b =&gt; -1\n\n(7/-3) =&gt; -2\n-2 * -3 =&gt; 6\nso a%b =&gt; 1\n</code></pre>\n<p>in python:</p>\n<pre><code>-7 % 3 =&gt; 2\n7 % -3 =&gt; -2\n</code></pre>\n<p>in c++ to python:</p>\n<pre><code>(b + (a%b)) % b\n</code></pre>\n", "OwnerUserId": "6671163", "PostTypeId": "2", "Id": "44197900", "Score": "2", "CreationDate": "2017-05-26T09:17:34.633", "LastActivityDate": "2017-05-26T09:17:34.633"}, "7594577": {"ParentId": "7594508", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>From ISO14882:2011(e) 5.6-4:</p>\n<blockquote>\n<p id=\"so_7594508_7594577_0\">The binary / operator yields the quotient, and the binary % operator\n  yields the remainder from the division of the first expression by the\n  second. If the second operand of / or % is zero the behavior is\n  undefined. For integral operands the / operator yields the algebraic quotient with any fractional part discarded; if the quotient a/b is\n  representable in the type of the result, (a/b)*b + a%b is equal to a.</p>\n</blockquote>\n<p>The rest is basic math:</p>\n<pre><code>(-7/3) =&gt; -2\n-2 * 3 =&gt; -6\nso a%b =&gt; -1\n\n(7/-3) =&gt; -2\n-2 * -3 =&gt; 6\nso a%b =&gt; 1\n</code></pre>\n<p>Note that </p>\n<blockquote>\n<p id=\"so_7594508_7594577_1\">If both operands are nonnegative then the remainder is nonnegative; if\n  not, the sign of the remainder is implementation-defined.</p>\n</blockquote>\n<p>from ISO14882:2003(e) is no longer present in ISO14882:2011(e) </p>\n", "OwnerUserId": "833362", "LastEditorUserId": "833362", "LastEditDate": "2011-09-29T08:54:34.780", "Id": "7594577", "Score": "147", "CreationDate": "2011-09-29T08:37:02.107", "LastActivityDate": "2011-09-29T08:54:34.780"}, "7594557": {"ParentId": "7594508", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The <em>sign</em> in such cases (i.e when one or both operands are negative) is implementation-defined. The spec says in \u00a75.6/4  (C++03), </p>\n<blockquote>\n<p id=\"so_7594508_7594557_0\">The binary / operator yields the quotient, and the binary % operator yields the remainder from the division of the first expression by the second. If the second operand of / or % is zero the behavior is undefined; otherwise (a/b)*b + a%b is equal to a. If both operands are nonnegative then the remainder is nonnegative; <strong>if not, the sign of the remainder is implementation-defined</strong>.</p>\n</blockquote>\n<p>That is all the language has to say, as far as C++03 is concerned.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "264325", "LastEditDate": "2017-06-05T19:18:42.560", "Id": "7594557", "Score": "16", "CreationDate": "2011-09-29T08:34:56.037", "LastActivityDate": "2017-06-05T19:18:42.560"}, "bq_ids": {"n4140": {"so_7594508_7594577_0": {"section_id": 6137, "quality": 0.7058823529411765, "length": 24}}, "n3337": {"so_7594508_7594577_0": {"section_id": 5901, "quality": 0.7058823529411765, "length": 24}}, "n4659": {"so_7594508_7594577_0": {"section_id": 7634, "quality": 0.7058823529411765, "length": 24}}}});