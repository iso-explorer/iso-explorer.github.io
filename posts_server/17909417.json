post_cb({"17909443": {"ParentId": "17909417", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it's implementation dependent for both C and C++.</p>\n<p>C11 \u00a76.4.5/7 <em>String literals</em></p>\n<blockquote>\n<p id=\"so_17909417_17909443_0\">It is unspecified whether these arrays are distinct provided their elements have the appropriate values. If the program attempts to modify such an array, the behavior is undefined.</p>\n</blockquote>\n<p>C++11 \u00a72.14.5/12 <em>String literals</em></p>\n<blockquote>\n<p id=\"so_17909417_17909443_1\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined. The effect of attempting to modify a string literal is undefined.</p>\n</blockquote>\n", "OwnerUserId": "1009479", "LastEditorUserId": "1009479", "LastEditDate": "2013-07-28T15:00:36.623", "Id": "17909443", "Score": "9", "CreationDate": "2013-07-28T14:53:28.030", "LastActivityDate": "2013-07-28T15:00:36.623"}, "17909460": {"ParentId": "17909417", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, this is not always true, nor is it portable.</p>\n<p>Merging identical string literals is an optimization that is performed by the compiler and the linker working together. Recent versions of both GCC and Microsoft's compiler both support it, but only when certain optimization switches are set.</p>\n<p>And it's not just an \"on\" or \"off\" feature. Different compilers and different optimization settings will also affect how <em>aggressively</em> this is performed. For example, sometimes string literals are pooled only within the scope of an individual function, other times it happens at the level of the translation unit, and still other times the linker might get involved to do it across multiple translation units.</p>\n<p>This is allowed because the C and C++ standards leave this behavior as implementation-dependent.</p>\n", "OwnerUserId": "366904", "LastEditorUserId": "366904", "LastEditDate": "2013-07-28T15:02:36.650", "Id": "17909460", "Score": "12", "CreationDate": "2013-07-28T14:54:28.943", "LastActivityDate": "2013-07-28T15:02:36.650"}, "17909828": {"ParentId": "17909417", "CommentCount": "0", "Body": "<p>You're comparing two different string literals, which happen to\nhave the same value.  According to the C++ standard, it is\nimplementation defined whether identical string literals occupy\nthe same memory or not (which means that the implementation must\ndocument what it does); according to the C standard, it is\nunspecified.  (I presume that the C++ standard would allow the\nimplementation to document something along the lines of \"string\nliterals of identical content share the same instance if they\nare in the same translation unit, and do not share the same\ninstance otherwise.) </p>\n<p>If your goal is to be able to just compare pointers, the usual\nsolution is to use a function (static if it is a class member)\nwhich returns the string literal:</p>\n<pre><code>char const*\nvalue()\n{\n    return \"Hello\";\n}\n\nbool\nisHello( char const* str )\n{\n    return str == valule;\n}\n</code></pre>\n<p>and then ensure that all instances of the string are obtained by\ncalling <code>value()</code>.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "17909828", "Score": "2", "CreationDate": "2013-07-28T15:30:28.020", "LastActivityDate": "2013-07-28T15:30:28.020"}, "17909462": {"ParentId": "17909417", "CommentCount": "0", "CreationDate": "2013-07-28T14:54:49.730", "Id": "17909462", "PostTypeId": "2", "OwnerDisplayName": "user529758", "Score": "2", "Body": "<blockquote>\n<p id=\"so_17909417_17909462_0\">But I wonder is it always true</p>\n</blockquote>\n<p>No, at least the C standard says something like \"whether two identical string literals are stored in the same array is implementation-defined\".</p>\n", "LastActivityDate": "2013-07-28T14:54:49.730"}, "bq_ids": {"n4140": {"so_17909417_17909443_1": {"section_id": 5361, "quality": 0.875, "length": 14}}, "n3337": {"so_17909417_17909443_1": {"section_id": 5157, "quality": 0.875, "length": 14}}, "n4659": {"so_17909417_17909443_1": {"section_id": 6789, "quality": 0.875, "length": 14}}}, "17909417": {"CommentCount": "0", "AcceptedAnswerId": "17909460", "PostTypeId": "1", "LastEditorUserId": "532208", "CreationDate": "2013-07-28T14:51:26.123", "LastActivityDate": "2013-09-26T08:33:08.300", "LastEditDate": "2013-09-26T08:33:08.300", "ViewCount": "372", "FavoriteCount": "2", "Title": "Strings in static memory instances count", "Id": "17909417", "Score": "14", "Body": "<p>As I know compiletime C-like strings are kept in static memory as only one instance. For instance I got both <code>true</code> on gcc 4.6 running example below. But I wonder is it always true and can be portable. Behavior on both C and C++ is interesting.</p>\n<pre><code>#include &lt;iostream&gt;\n\nbool amIportable(const char* value) {\n  const char* slocal = \"Hello\";\n  return (slocal==value);\n}\n\nint main() {\n  const char* s = \"Hello\";\n  std::cout &lt;&lt; std::boolalpha \n            &lt;&lt; amIportable(s) &lt;&lt; '\\n'\n            &lt;&lt; amIportable(\"Hello\") &lt;&lt; '\\n';\n}\n</code></pre>\n", "Tags": "<c++><c><string><memory><static>", "OwnerUserId": "532208", "AnswerCount": "4"}});