post_cb({"bq_ids": {"n4140": {"so_42791818_42792049_0": {"length": 40, "quality": 0.975609756097561, "section_id": 484}}, "n3337": {"so_42791818_42792049_0": {"length": 35, "quality": 0.8536585365853658, "section_id": 475}}}, "42791818": {"CreationDate": "2017-03-14T16:44:42.153", "ViewCount": "390", "Id": "42791818", "Score": "4", "Title": "Caveat with C++11 inherited constructor", "LastEditorUserId": "560648", "CommentCount": "1", "Body": "<p><a href=\"https://en.wikipedia.org/wiki/C++11#Object_construction_improvement\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/C++11#Object_construction_improvement</a></p>\n<blockquote>\n<p id=\"so_42791818_42791818_0\">For base-class constructors, C++11 allows a class to specify that base\n  class constructors will be inherited. Thus, the C++11 compiler will\n  generate code to perform the inheritance and the forwarding of the\n  derived class to the base class. This is an all-or-nothing feature:\n  either all of that base class's constructors are forwarded or none of\n  them are. Also, restrictions exist for multiple inheritance, such that\n  class constructors cannot be inherited from two classes that use\n  constructors with the same signature. <strong>Nor can a constructor in the\n  derived class exist that matches a signature in the inherited base\n  class.</strong></p>\n</blockquote>\n<p>Can someone give me an example to illustrate the issue with \"<strong><em>Nor can a constructor in the derived class exist that matches a signature in the inherited base class.</em></strong>\"?</p>\n", "Tags": "<c++><c++11>", "LastEditDate": "2017-03-14T17:39:24.630", "LastActivityDate": "2017-03-14T17:52:33.203", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "391104"}, "42792049": {"LastActivityDate": "2017-03-14T17:14:04.410", "CommentCount": "2", "Body": "<p>It means that if you have constructor in the derived class whose parameter list matches the parameter list of <em>any</em> constructor in the base class, then that derived class' constructor is taken and <strong>hides</strong> the base class'</p>\n<p>E.g.</p>\n<pre><code>struct Foo\n{\n   Foo(){std::cout &lt;&lt; \"Foo default ctor\\n\";}\n   Foo(int){std::cout &lt;&lt; \"Foo(int)\\n\";}\n};\n\nstruct Bar : Foo\n{\n   using Foo::Foo;\n   Bar(int){std::cout &lt;&lt; \"Bar\\n\";} // won't implicitly call Foo(int)\n};\n\nint main()\n{\n    Bar b(1);\n}\n</code></pre>\n<p>From \u00a712.9/3 [class.inhctor] (Emphasis mine):</p>\n<blockquote>\n<p id=\"so_42791818_42792049_0\">For each non-template constructor in the candidate set of inherited constructors other than a constructor\n  having no parameters or a copy/move constructor having a single parameter, a constructor is implicitly\n  declared with the same constructor characteristics <strong>unless there is a user-declared constructor with the same\n  signature in the complete class where the using-declaration appears or the constructor would be a default,\n  copy, or move constructor for that class</strong>.</p>\n</blockquote>\n", "CreationDate": "2017-03-14T16:55:56.867", "LastEditDate": "2017-03-14T17:14:04.410", "ParentId": "42791818", "Id": "42792049", "LastEditorUserId": "27678", "PostTypeId": "2", "Score": "6", "OwnerUserId": "27678"}});