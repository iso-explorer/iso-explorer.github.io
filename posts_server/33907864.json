post_cb({"33908016": {"Id": "33908016", "PostTypeId": "2", "Body": "<p>In all the cases listed in <code>9.2</code> <em>[class.mem]</em> knowing the type can be deferred until the class is fully defined. We can see this rationale listed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2818.html#643\" rel=\"nofollow\">defect report 643: Use of decltype in a class member-specification</a> which says:</p>\n<blockquote>\n<p id=\"so_33907864_33908016_0\">In the other cases where a class type is considered complete within the definition of the class, it is possible to defer handling the construct until the end of the definition. That is not possible for types, as the type may be needed immediately in subsequent declarations.</p>\n</blockquote>\n<p>As T.C. points out there is also issues of lookup involved as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#325\" rel=\"nofollow\">defect report 325: When are default arguments parsed?</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1352\" rel=\"nofollow\">defect report 1352</a> deal with. The later one also mentions the same technique of being able to defer parsing till the class is complete:</p>\n<blockquote>\n<p id=\"so_33907864_33908016_1\">The rules regarding class scope and when the class is considered to be complete (normally implemented by deferred parsing of portions of class member declarations) are inconsistent and need to be clarified.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-25T04:14:01.403", "Score": "6", "CreationDate": "2015-11-25T03:29:23.040", "ParentId": "33907864", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-25T04:14:01.403"}, "bq_ids": {"n4140": {"so_33907864_33908092_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 7093}, "so_33907864_33908092_4": {"length": 13, "quality": 1.0, "section_id": 7093}, "so_33907864_33908092_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7093}, "so_33907864_33908092_1": {"length": 6, "quality": 1.0, "section_id": 7094}, "so_33907864_33908092_3": {"length": 15, "quality": 0.9375, "section_id": 7093}, "so_33907864_33907864_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 5862}, "so_33907864_33908092_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 187}}, "n3337": {"so_33907864_33908092_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 6837}, "so_33907864_33907864_1": {"length": 37, "quality": 0.8809523809523809, "section_id": 5632}, "so_33907864_33908092_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6838}, "so_33907864_33908092_1": {"length": 6, "quality": 1.0, "section_id": 6838}, "so_33907864_33908092_3": {"length": 15, "quality": 0.9375, "section_id": 6837}, "so_33907864_33908092_4": {"length": 13, "quality": 1.0, "section_id": 6837}, "so_33907864_33908092_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 181}}, "n4659": {"so_33907864_33908092_5": {"length": 21, "quality": 0.9130434782608695, "section_id": 8594}, "so_33907864_33908092_4": {"length": 13, "quality": 1.0, "section_id": 8594}, "so_33907864_33908092_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 8594}, "so_33907864_33908092_1": {"length": 6, "quality": 1.0, "section_id": 8595}, "so_33907864_33908092_3": {"length": 15, "quality": 0.9375, "section_id": 8594}, "so_33907864_33907864_1": {"length": 32, "quality": 0.7619047619047619, "section_id": 7345}, "so_33907864_33908092_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 192}}}, "33907864": {"ViewCount": "139", "Body": "<p>According to the C++ standard, </p>\n<blockquote>\n<p id=\"so_33907864_33907864_0\"><strong>9.2 [class.mem]:</strong></p>\n<p id=\"so_33907864_33907864_1\">A class is considered a completely-defined object type (3.9) (or\n  complete type) at the closing } of the class-specifier. Within the\n  class member-specification, the class is regarded as complete within\n  function bodies, default arguments, using-declarations introducing\n  inheriting constructors (12.9), exception-specifications, and\n  brace-or-equal-initializers for non-static data members (including\n  such things in nested classes). Otherwise it is regarded as incomplete\n  within its own class member-specification</p>\n</blockquote>\n<p>So, the code below should compile, and indeed it does</p>\n<pre><code>struct Foo{\n     Foo()\n     {\n        Bar bar; // Bar is fully visible here, even though it's defined later\n     }\n     //void f(Bar){} // But NOT VISIBLE if used as a function parameter\n     struct Bar{};\n};\n\nint main()\n{\n    Foo foo;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7dd47ebf3b78c9b7\"><kbd>Live on Coliru</kbd></a></p>\n<p>However, if I uncomment the line that defines the member function <code>void Foo::f(Bar)</code>, then the code fails to compile with the error</p>\n<blockquote>\n<p id=\"so_33907864_33907864_2\">error: 'Bar' has not been declared</p>\n</blockquote>\n<p>Reading again the standard it indeed seems that function parameters are not considered as places where the class is regarded as complete. However, it does not make any sense at all. Can you shed some light why I cannot use <code>Bar</code> in a function parameter (but otherwise can fully use it <strong>inside</strong> a function without any issues whatsoever) before its full definition?</p>\n", "AcceptedAnswerId": "33908016", "Title": "Inner member visibility in class", "CreationDate": "2015-11-25T03:10:30.133", "Id": "33907864", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-11-25T04:50:07.130", "Score": "11", "OwnerUserId": "3093378", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "33908092": {"Id": "33908092", "PostTypeId": "2", "Body": "<p>From the 03 standard, 3.4.1/8 (Unqualified name lookup):</p>\n<blockquote>\n<p id=\"so_33907864_33908092_0\">A name used in the definition of a member function (9.3) of class X following the function\u2019s declarator-id<sup>29</sup>)\n  shall be declared in one of the following ways:</p>\n<p id=\"so_33907864_33908092_1\">\u2014 <strong>before its use in the block in which it is used or in an enclosing block (6.3)</strong>, or</p>\n<p id=\"so_33907864_33908092_2\">\u2014 shall be a member of class X or be a member of a base class of X (10.2), or</p>\n<p id=\"so_33907864_33908092_3\">\u2014 if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y\n  (this lookup applies in turn to Y\u2019s enclosing classes, starting with the innermost enclosing class),30) or</p>\n<p id=\"so_33907864_33908092_4\">\u2014 if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block\n  enclosing the definition of class X, or</p>\n<p id=\"so_33907864_33908092_5\">\u2014 <strong>if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class\n  or a nested class within a local class of a function that is a member of N, before the member function\n  definition, in namespace N or in one of N\u2019s enclosing namespaces.</strong></p>\n</blockquote>\n", "LastEditorUserId": "2883245", "LastActivityDate": "2015-11-25T04:50:07.130", "Score": "2", "CreationDate": "2015-11-25T03:37:30.203", "ParentId": "33907864", "CommentCount": "0", "OwnerUserId": "2883245", "LastEditDate": "2015-11-25T04:50:07.130"}});