post_cb({"bq_ids": {"n4140": {"so_18931993_19325983_0": {"length": 8, "quality": 1.0, "section_id": 5450}, "so_18931993_19325983_2": {"length": 15, "quality": 0.9375, "section_id": 5445}, "so_18931993_19325983_3": {"length": 15, "quality": 1.0, "section_id": 5446}, "so_18931993_19325983_1": {"length": 15, "quality": 0.9375, "section_id": 5446}}, "n3337": {"so_18931993_19325983_0": {"length": 7, "quality": 0.875, "section_id": 5244}, "so_18931993_19325983_3": {"length": 9, "quality": 0.6, "section_id": 5541}, "so_18931993_19325983_1": {"length": 9, "quality": 0.5625, "section_id": 5241}}, "n4659": {"so_18931993_19325983_0": {"length": 8, "quality": 1.0, "section_id": 6877}, "so_18931993_19325983_3": {"length": 15, "quality": 1.0, "section_id": 6873}, "so_18931993_19325983_2": {"length": 12, "quality": 0.75, "section_id": 6872}, "so_18931993_19325983_1": {"length": 15, "quality": 0.9375, "section_id": 6873}}}, "18931993": {"ViewCount": "1481", "Body": "<p>Here is a little experiment with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\" rel=\"noreferrer\"><strong>return type deduction</strong></a> for in-class friend functions (using Clang 3.4 SVN and g++ 4.8.1 with <code>std=c++1y</code> in both cases) that is not documented in the linked working paper</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int a_;\n    friend auto operator==(A const&amp; L, A const&amp; R) \n    { \n        return L.a_ == R.a_; // a_ is of type int, so should return bool\n    }\n};\n\ntemplate&lt;class T&gt;\nstruct B\n{\n    int b_;\n    friend auto operator==(B const&amp; L, B const&amp; R) \n    { \n        return L.b_ == R.b_; // b_ is of type int, so should return bool\n    }\n};\n\nusing BI = B&lt;int&gt;;\n\nint main()\n{\n    std::cout &lt;&lt; (A{1} == A{2}) &lt;&lt; \"\\n\";    // OK for Clang, ERROR for g++\n    std::cout &lt;&lt; (BI{1} == BI{2}) &lt;&lt; \"\\n\";  // ERROR for both Clang and g++\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9d5a7bcd7a6ee3c1\" rel=\"noreferrer\"><strong>Live Example</strong></a>.</p>\n<p><strong>Question</strong>: is automatic return type deduction for in-class friend functions supported in C++14?</p>\n", "AcceptedAnswerId": "19325983", "Title": "Return type deduction for in-class friend functions", "CreationDate": "2013-09-21T11:25:02.860", "Id": "18931993", "CommentCount": "22", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-10-11T07:06:58.453", "LastEditorUserId": "476681", "LastActivityDate": "2013-10-11T21:13:23.857", "Score": "30", "OwnerUserId": "819272", "Tags": "<c++><auto><c++14><return-type-deduction>", "AnswerCount": "1"}, "19325983": {"Id": "19325983", "PostTypeId": "2", "Body": "<p>With respect to the other answers: We're dealing explicitly with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\">n3638</a> here, and how it's incorporated in the recent drafts of C++1y.</p>\n<p>I'm using 9514cc28 from the <a href=\"https://github.com/cplusplus/draft\">commitee's github repository</a>, which incorporates some (minor) fixes/changes to n3638 already.</p>\n<p>n3638 allows explicitly:</p>\n<pre><code>struct A {\n  auto f(); // forward declaration\n};\nauto A::f() { return 42; }\n</code></pre>\n<p>And, as we can infer from [dcl.spec.auto], where this feature is specified, even the following will be legal:</p>\n<pre><code>struct A {\n  auto f(); // forward declaration\n};\n\nA x;\n\nauto A::f() { return 42; }\n\nint main() { x.f(); }\n</code></pre>\n<p>(but more on this later)</p>\n<p>This is fundamentally different from any <em>trailing-return-type</em> or dependent name lookup, as <code>auto f();</code> is a preliminary declaration, similar to <code>struct A;</code>. It needs to be completed later on, before it is used (before the return type is required).</p>\n<p>Additionally, the problems in the OP are related to internal compiler errors. The recent clang++3.4 trunk 192325 Debug+Asserts build fails to compile as an assertion fails while parsing the line <code>return L.b_ == R.b_;</code>. I have not checked with a recent version of g++ as of now.</p>\n<hr>\n<p>Is the OP's example legal wrt to a n3638?</p>\n<p>This is a bit tricky IMO. (I'm always referring to 9514cc28 in this section.)</p>\n<h3>1. Where is it allowed to use `auto`?</h3>\n<p>[dcl.spec.auto]</p>\n<blockquote>\n<p id=\"so_18931993_19325983_0\">6 \u00a0\u00a0 A program that uses <code>auto</code> or <code>decltype(auto)</code> in a context not explicitly allowed in this section is ill-formed.</p>\n<p id=\"so_18931993_19325983_1\">2 \u00a0\u00a0 The placeholder type can appear with a function declarator in the <em>decl-specifier-seq</em>, <em>type-specifier-seq</em>, <em>conversion-function-id</em>, or <em>trailing-return-type</em>, in any context where such a declarator is valid.</p>\n</blockquote>\n<p>/5 also defines some contexts, but they're irrelevant here.</p>\n<p>Therefore, <code>auto func()</code> and <code>auto operator@(..)</code> are generally allowed (this follows from the composition of a function declaration as <code>T D</code>, where <code>T</code> is of the form <em>decl-specifier-seq</em>, and <code>auto</code> is a <em>type-specifier</em>).</p>\n<hr>\n<h3>2. Is it allowed to write `auto func();`, i.e. a declaration that is not a definition?</h3>\n<p>[dcl.spec.auto]/1 says</p>\n<blockquote>\n<p id=\"so_18931993_19325983_2\">The <code>auto</code> and <code>decltype(auto)</code> <em>type-specifiers</em> designate a placeholder type that will be replaced later, either by deduction from an initializer or by explicit specification with a <em>trailing-return-type</em>.</p>\n</blockquote>\n<p>and /2</p>\n<blockquote>\n<p id=\"so_18931993_19325983_3\">If the declared return type of the function contains a placeholder type, the return type of the function is deduced from <code>return</code> statements in the body of the function, if any.</p>\n</blockquote>\n<p>Although it doesn't <em>explicitly</em> allow a declaration like <code>auto f();</code> for a function (that is, a declaration without definition), it is clear from n3638 and [dcl.spec.auto]/11 that it is intended to be allowed, and not explicitly forbidden.</p>\n<hr>\n<h3>3. What about friend functions?</h3>\n<p>So far, the example</p>\n<pre><code>struct A\n{\n    int a_;\n    friend auto operator==(A const&amp; L, A const&amp; R);\n}\n\nauto operator==(A const&amp; L, A const&amp; R)\n{ return L.a_ == R.a_; }\n</code></pre>\n<p>should be well-formed. The interesting part now is the definition of the friend function inside the definition of <code>A</code>, that is</p>\n<pre><code>struct A\n{\n    int a_;\n    friend auto operator==(A const&amp; L, A const&amp; R)\n    { return L.a_ == R.a_; } // allowed?\n}\n</code></pre>\n<p>In my opinion, it is allowed. To support this, I'll cite name lookup. The name lookup inside the definition of functions defined in a friend function declaration follows the name lookup of member functions as per [basic.lookup.unqual]/9. /8 of the same section specifies unqualified lookup for names used inside member function bodies. One of the ways a name can be declared to be used is that it \"shall be a member of class <code>X</code> or be a member of a base class of <code>X</code> (10.2)\". This allows the widely known</p>\n<pre><code>struct X\n{\n    void foo() { m = 42; }\n    int m;\n};\n</code></pre>\n<p>Note how <code>m</code> isn't declared before its use in <code>foo</code>, but it's a member of <code>X</code>.</p>\n<p>From this, I conclude that even</p>\n<pre><code>struct X\n{\n    auto foo() { return m; }\n    int m;\n}\n</code></pre>\n<p>is allowed. This is supported by clang++3.4 trunk 192325.\nName lookup requires to interpret this function only after the <code>struct</code> has been completed, also consider:</p>\n<pre><code>struct X\n{\n    auto foo() { return X(); }\n    X() = delete;\n};\n</code></pre>\n<p>Similarly, the body of friend functions defined inside a class can only be interpreted once the class is complete.</p>\n<hr>\n<h3>4. What about templates?</h3>\n<p>Specifically, what about <code>friend auto some_function(B const&amp; L) { return L.b_; }</code>?</p>\n<p>First, the <em>injected-class-name</em> <code>B</code> is equivalent to <code>B&lt;T&gt;</code>, see [temp.local]/1. It refers to the <em>current instantiation</em> ([temp.dep.type]/1).</p>\n<p>The <em>id-expression</em> <code>L.b_</code> refers to a <em>member of the current instantiation</em> (/4). It is also a <em>dependent member of the current instantiation</em> -- this is an addition made after C++11, see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1471\">DR1471</a>, and I don't know what to think about it: [temp.dep.expr]/5 states this <em>id-expression</em> is <em>not</em> type-dependent, and as far as I see [temp.dep.constexpr] doesn't say it's value-dependent.</p>\n<p>If the name in <code>L.b_</code> was not dependent, name lookup would follow the \"usual name lookup\" rules per [temp.nondep]. Else, this'll be fun (dependent name lookup is not very well specified), but considering that</p>\n<pre><code>template&lt;class T&gt;\nstruct A\n{\n    int foo() { return m; }\n    int m;\n};\n</code></pre>\n<p>is accepted by most compilers as well, I think the version with <code>auto</code> should be valid, too.</p>\n<p>There's also a section about friends of templates in [temp.friend], but IMO it doesn't shed light on the name lookup here.</p>\n<hr>\n<p>Also see <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/jahm7_tIN1Q/discussion\">this highly relevant discussion in the isocpp-forum</a>.</p>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-10-11T21:13:23.857", "Score": "10", "CreationDate": "2013-10-11T19:41:24.507", "ParentId": "18931993", "CommentCount": "5", "OwnerUserId": "420683", "LastEditDate": "2013-10-11T21:13:23.857"}});