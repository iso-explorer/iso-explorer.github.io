post_cb({"29558677": {"CommentCount": "3", "ViewCount": "584", "PostTypeId": "1", "LastEditorUserId": "3970411", "CreationDate": "2015-04-10T10:06:16.993", "LastActivityDate": "2015-04-16T08:16:39.843", "Title": "How can I show lambda functions on backtraces?", "FavoriteCount": "1", "LastEditDate": "2015-04-16T08:16:39.843", "Id": "29558677", "Score": "11", "Body": "<p>I'm writing a <code>C++11</code> software and I'm using lambdas. When I print the backtrace with <code>backtrace_symbols_fd</code> all functions are demangled except of lambda. It's a bit obvious because they are anonymous functions, but there is a way to get more insight instead of a raw pointer?</p>\n<p>I'm using GCC 4.8 on Linux</p>\n", "Tags": "<c++><c++11><gcc><lambda><backtrace>", "OwnerUserId": "1629718", "AnswerCount": "2"}, "29581627": {"ParentId": "29558677", "CommentCount": "1", "CreationDate": "2015-04-11T18:39:55.170", "OwnerUserId": "4200455", "PostTypeId": "2", "Id": "29581627", "Score": "0", "Body": "<p>According to the C++ Standard:</p>\n<p>\u00a75.1.2/3 states:</p>\n<blockquote>\n<p id=\"so_29558677_29581627_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed non-union class type.</p>\n</blockquote>\n<p>I don't think there is a way to get more useful information. Basically, lambdas are just instances of anonymous classes.</p>\n", "LastActivityDate": "2015-04-11T18:39:55.170"}, "bq_ids": {"n4140": {"so_29558677_29581627_0": {"section_id": 5962, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_29558677_29581627_0": {"section_id": 5731, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_29558677_29581627_0": {"section_id": 7451, "quality": 0.9166666666666666, "length": 11}}}, "29581952": {"ParentId": "29558677", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-04-11T19:13:18.677", "Score": "2", "LastEditorUserId": "981959", "LastEditDate": "2015-04-11T19:26:54.980", "Id": "29581952", "OwnerUserId": "981959", "Body": "<p>Some kind of useful information does exist in the binary, because GDB is able to show more useful names for lambda functions e.g.</p>\n<pre><code>(gdb) bt\n#0  &lt;lambda()&gt;::operator()(void) const (__closure=0x7fffffffd5ef) at ll.cc:3\n#1  0x00000000004005e7 in main () at ll.cc:3\n</code></pre>\n<p>(ALthough maybe the debug info just says it's a closure type, as GDB shows all such functions as <code>&lt;lambda()&gt;::operator()</code>)</p>\n<p>The mangled name of a template instantiated with a closure type includes a unique name e.g.</p>\n<pre><code>#3  0x0000000000400712 in func&lt;main()::&lt;lambda()&gt; &gt;(&lt;lambda()&gt;) (t=...) at l.cc:4\n</code></pre>\n<p>but maybe the name is only used when it's needed in other mangled names.</p>\n<p>With GCC you can also print out the name of the closure's <code>operator()</code> by printing the pre-defined variable <code>__PRETTY_FUNCTION__</code>, which shows something like <code>main()::&lt;lambda()&gt;</code></p>\n<p>Using GDB's Python API I can get yet another name for the same closure, e.g.</p>\n<pre><code>(gdb) python import gdb; print gdb.block_for_pc(0x8048591).function.name\n__lambda0::operator()() const\n</code></pre>\n<p>So that's at least three different names! So I think it's maybe a limitation of <code>backtrace_symbols_fd</code> that it can't find names for the lambda functions.</p>\n", "LastActivityDate": "2015-04-11T19:26:54.980"}});