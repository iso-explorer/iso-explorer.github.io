post_cb({"14419671": {"ParentId": "14419616", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I don't think the <em>not</em> extending to the object lifetime needs justification. The opposite would!</p>\n<p>The lifetime extension of a temporary extends merely to the enclosing scope, which is both natural and useful. This is because we have tight control on the lifetime of the receiving reference variable. By contrast, the class member isn't really \"in scope\" at all. Imagine this:</p>\n<pre><code>int foo();\nstruct Bar\n{\n    Bar(int const &amp;, int const &amp;, int const &amp;) : /* bind */ { }\n    int &amp; a, &amp; b, &amp; c;\n};\n\nBar * p = new Bar(foo(), foo(), foo());\n</code></pre>\n<p>It'd be nigh impossible to define a meaningful lifetime extension for the <code>foo()</code> temporaries.</p>\n<p>Instead, we have the default behaviour that the lifetime of the <code>foo()</code> temporary extends to the end of the full-expression in which it is contained, and no further.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "906773", "LastEditDate": "2013-01-20T21:22:20.630", "Id": "14419671", "Score": "2", "CreationDate": "2013-01-19T22:41:35.930", "LastActivityDate": "2013-01-20T21:22:20.630"}, "14420299": {"ParentId": "14419616", "CommentCount": "1", "Body": "<p>What memory would it live in?</p>\n<p>For it to work the way you propose, it can't be on the stack since it has to live longer than any single function call. It can't be put after struct A in memory, because it would have no way to know how A was allocated.</p>\n<p>At best, it would have to be turned into a secret heap allocation. That would then require a corresponding secret deallocation when the destructor runs. The copy constructor and assignment operator would need secret behavior too.</p>\n<p>I don't know if anyone ever actually considered such a way of doing it. But personally, it sounds like too much extra complexity for a rather obscure feature.</p>\n", "OwnerUserId": "126027", "PostTypeId": "2", "Id": "14420299", "Score": "1", "CreationDate": "2013-01-20T00:05:33.057", "LastActivityDate": "2013-01-20T00:05:33.057"}, "14419616": {"CommentCount": "0", "AcceptedAnswerId": "14419671", "CreationDate": "2013-01-19T22:34:34.810", "LastActivityDate": "2013-01-20T21:22:20.630", "PostTypeId": "1", "ViewCount": "119", "FavoriteCount": "0", "Title": "What is the rationale for not allowing temporaries bound to references in initialization lists to live past end of ctor?", "Id": "14419616", "Score": "1", "Body": "<p>Simple example:</p>\n<pre><code>struct A\n{\n   A() : i(int()) {}\n   const int&amp; i;\n};\n</code></pre>\n<p>Error from gcc:</p>\n<blockquote>\n<p id=\"so_14419616_14419616_0\">a temporary bound to 'A::i' only persists until the constructor exits</p>\n</blockquote>\n<p>Rule from 12.2p5:</p>\n<blockquote>\n<p id=\"so_14419616_14419616_1\">A temporary bound to a reference member in a constructor\u2019s\n  ctor-initializer (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n<p><strong>Question</strong></p>\n<p>Does anybody know the rationale for this rule? It would seem to me that allowing the temporary to live  until reference dies would be better.</p>\n", "Tags": "<c++>", "OwnerUserId": "906773", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_14419616_14419616_0": {"section_id": 382, "quality": 1.0, "length": 6}, "so_14419616_14419616_1": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_14419616_14419616_0": {"section_id": 373, "quality": 1.0, "length": 6}, "so_14419616_14419616_1": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_14419616_14419616_0": {"section_id": 397, "quality": 0.6666666666666666, "length": 4}}}, "14419636": {"ParentId": "14419616", "CommentCount": "0", "Body": "<p>The int() in your constructor initialization list is on the stack. </p>\n<p>Once that value is set, int() goes out of the scope and the reference becomes invalid.</p>\n", "OwnerUserId": "1272843", "PostTypeId": "2", "Id": "14419636", "Score": "1", "CreationDate": "2013-01-19T22:37:24.827", "LastActivityDate": "2013-01-19T22:37:24.827"}});