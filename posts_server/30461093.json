post_cb({"30461093": {"CommentCount": "0", "ViewCount": "105", "PostTypeId": "1", "LastEditorUserId": "335858", "CreationDate": "2015-05-26T14:13:18.917", "LastActivityDate": "2015-05-27T02:33:35.350", "Title": "Storing Lambda in class segfaults", "AcceptedAnswerId": "30461305", "LastEditDate": "2015-05-26T14:18:29.657", "Id": "30461093", "Score": "1", "Body": "<p>This is a stripped down version of my program to illustrate the issue:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nclass Piped {\npublic:\n    typedef T value_type;\n};\n\ntemplate&lt;class P1, class P2, class T&gt;\nclass PipeConnector : public Piped&lt;T&gt; {\npublic:\n    PipeConnector(const P1 &amp;p1, const P2 &amp;p2)\n     : m_1(p1), m_2(p2) { }\n\n    bool run(const T &amp;element) const {\n        return m_1.run(element) || m_2.run(element);\n    }\nprivate:\n    const P1 &amp;m_1;\n    const P2 &amp;m_2;\n};\n\ntemplate&lt;class T&gt;\nclass NullOp : public Piped&lt;T&gt; {\npublic:\n    bool run(const T&amp;) const {\n        return false;\n    }\n};\n\ntemplate&lt;class T, class Functor&gt;\nclass FunctionOp : public Piped&lt;T&gt; {\npublic:\n    FunctionOp(Functor f1)\n     : m_1(f1) { }\n\n    bool run(const T &amp;element) const {\n        return m_1(element);\n    }\nprivate:\n    std::function&lt;bool(T)&gt; m_1;\n};\n\ntemplate&lt;class P1, class Functor&gt;\nauto operator|(const P1 &amp;p1, const Functor &amp;f2) {\n    return PipeConnector&lt;P1,\n            FunctionOp&lt;typename P1::value_type, std::function&lt;bool(typename P1::value_type)&gt;&gt;, typename P1::value_type&gt;(\n                    p1, FunctionOp&lt;typename P1::value_type, std::function&lt;bool(typename P1::value_type)&gt;&gt;(f2));\n}\n\nint main() {\n    auto p = NullOp&lt;int&gt;() | [](int x) -&gt; bool { if (x &lt; 10) { return true;} return false; };\n    std::cout &lt;&lt; p.run(20) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Compiling this program using g++ / clang++ -std=c++14 leads to a segfault. Adding -O3 to it, makes it run without a segfault. </p>\n<p>When changing the PipeConnector to not store const references but storing copies, this works. I assume the problem is some lambda scope issue, but I don't understand what goes wrong. -O3 seems to elide the problem? Could you explain the issue to me, please?</p>\n", "Tags": "<c++><lambda>", "OwnerUserId": "4818654", "AnswerCount": "2"}, "30461305": {"ParentId": "30461093", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your <code>operator|()</code> creates a <code>PipeConnector</code> object, both of whose arguments are temporaries. The <code>PipeConnector</code> constructor then returns an object containing <em>references</em> to these temporaries. When that object's <code>run</code> method is invoked, the lifetime of the temporaries has expired.</p>\n<p>The <code>NullOp</code> object has no state, and it probably doesn't matter (in practice) that its reference is dangling, but the same cannot be said of the <code>std::function</code> object constructed from the lambda. This is not the same as the lambda itself; the lambda itself is stateless, but the <code>std::function</code> operator contains a function pointer.</p>\n<p>I suppose that with -O3 the compiler can figure out what function should be invoked when the <code>std::function</code> member variable is called, and so it inlines the call. But it is still UB, even when it appears to work.</p>\n<p><strong>Edit</strong>: OP suggests that the lifetime of the temporary should be extended because it is bound to a reference. However, in this context, that does not apply. See <a href=\"https://stackoverflow.com/questions/2784262/does-a-const-reference-prolong-the-life-of-a-temporary\">Does a const reference prolong the life of a temporary?</a></p>\n<p>There are three references initialized with temporary objects in the constructor of the <code>PipeConnector</code> created in the call to <code>operator|()</code>. The first of these, <code>NullOp&lt;int&gt;()</code>, is the argument to the <code>operator|()</code> function, and its lifetime is explicitly not extended by the wording of \u00a712.2 [class.temporary] paragraph 5.1:</p>\n<blockquote>\n<p id=\"so_30461093_30461305_0\">A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>The other two temporary objects are an instance of <code>std::function&lt;bool(int)&gt;</code> which results from the conversion of a <code>lambda</code>, used in the initializer of a <code>FunctionOp&lt;int, std::function&lt;bool(int)&gt;&gt;</code>, and the constructed <code>FunctionOp</code> itself. In versions of the draft standard available in 2013 and the first half of 2014, this case (which is very similar to the function call case) had similar wording:</p>\n<blockquote>\n<p id=\"so_30461093_30461305_1\">A temporary bound to a reference member in a constructor's ctor-initializer (12.6.2 [class.base.init]) persists until the constructor exits.</p>\n</blockquote>\n<p>However, that sentence was deleted in the proposed resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1696\" rel=\"nofollow noreferrer\">DR 1696</a> (<a href=\"https://github.com/cplusplus/draft/commit/c93a904986ca0cdf9cd02bc5aafc0da258d6a47b\" rel=\"nofollow noreferrer\">committed to the draft standard 29 September 2014</a>). I believe the sentence was deleted for clarity; as far as I can see, the situation referred is marked as invalid by the other modifications in the resolution to DR1696, especially the new paragraph 8 in \u00a712.6.2:</p>\n<blockquote>\n<p id=\"so_30461093_30461305_2\">A temporary expression bound to a reference member in a mem-initializer is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "1566221", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:10.767", "Id": "30461305", "Score": "0", "CreationDate": "2015-05-26T14:22:16.497", "LastActivityDate": "2015-05-27T02:33:35.350"}, "30463181": {"ParentId": "30461093", "CommentCount": "2", "Body": "<p>The problem is that <code>NullOp&lt;int&gt;()</code> is a temporary to which you store a const-reference to inside <code>PipedConnector</code>. This temporary has full-expression lifetime so it does not exist after <code>p</code> has been initialized. When you call <code>p.run(20)</code> you then reference that temporary again, which has since been deleted. The UB that results from that can cause a crash.</p>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "30463181", "Score": "1", "CreationDate": "2015-05-26T15:45:49.870", "LastActivityDate": "2015-05-26T15:45:49.870"}, "bq_ids": {"n4140": {"so_30461093_30461305_0": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_30461093_30461305_2": {"section_id": 91, "quality": 0.5714285714285714, "length": 4}, "so_30461093_30461305_1": {"section_id": 382, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_30461093_30461305_0": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_30461093_30461305_2": {"section_id": 86, "quality": 0.5714285714285714, "length": 4}, "so_30461093_30461305_1": {"section_id": 373, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_30461093_30461305_0": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_30461093_30461305_2": {"section_id": 453, "quality": 1.0, "length": 7}}}});