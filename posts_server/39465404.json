post_cb({"39467467": {"ParentId": "39465404", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First of all: when converting the expression in a <code>return</code> statement to the return type of the function, the rules are the same as for initialization (see [conv]/2.4 and [conv]/3).</p>\n<p>So we could examime the behaviour of the code using this example instead (with the same <code>X</code> as you have, but without <code>Y</code>):</p>\n<pre><code>X test1;\nbool b1 = test1;\n\nX const test2;\nbool b2 = test2;\n</code></pre>\n<p>(in the call <code>y.test2()</code>, the type of <code>this-&gt;x</code> is <code>X const</code>, that's what it means to have a const member function).  It would also be the same if we cast to <code>bool</code> instead of writing an initialization statement.</p>\n<hr>\n<p>The part of the Standard dealing with overload resolution in this situation is [over.match.conv], here is the C++14 text (with some elision for brevity):</p>\n<blockquote>\n<p id=\"so_39465404_39467467_0\"><strong>13.3.1.5 Initialization by conversion function [over.match.conv]</strong></p>\n<p id=\"so_39465404_39467467_1\"><sup>1</sup> Under the conditions specified in 8.5, as part of an initialization of an object of nonclass type, a conversion function can be invoked to convert an initializer expression of class type to the type of the object being initialized.  [...]</p>\n<p id=\"so_39465404_39467467_2\"><sup>2</sup> The argument list has one argument, which is the initializer expression. [<em>Note:</em> This argument will be compared against the implicit object parameter of the conversion functions. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>The <code>test2</code> case is straightforward - a non-const member function cannot be called on a const object, so the <code>operator void*</code> is never considered, there is only one candidate and no need for overload resolution. <code>operator bool()</code> is called.  </p>\n<p>So for the rest of this post I will just talk about the <code>test1</code> case. The part I elided in the above quote covers that both <code>operator bool</code> and <code>operator void*()</code> are candidate functions for the <code>test1</code> case.   </p>\n<hr>\n<p>It is important to note that <strong>overload resolution selects amongst these two candidate functions</strong>, and it is <strong>not</strong> a case of considering two implicit conversion sequences, each containing a user-defined conversion. To back this up, look at the first sentence of [over.best.ics]:</p>\n<blockquote>\n<p id=\"so_39465404_39467467_3\">An <em>implicit conversion sequence</em> is a sequence of conversions used to convert an argument in a function call to the type of the corresponding parameter of the function being called.</p>\n</blockquote>\n<p>We are not converting an argument in a function call here. The rules about implicit conversion sequences come into play when we are ranking candidate functions: the rules are applied to each argument of each candidate function, as we shall see in a moment.</p>\n<hr>\n<p>So now we look to the rules for <em>best viable function</em> to determine which of these two candidate functions is selected. I'll skip [over.match.viable], which clarifies that both of those candidates are viable, and onto [over.match.best]. </p>\n<p>The key part of that section is [over.match.best]/1.2:</p>\n<blockquote>\n<p id=\"so_39465404_39467467_4\">let <em>ICSi(F)</em> denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence\n  or worse conversion sequence than another.</p>\n</blockquote>\n<p>Here, <code>i == 1</code>, there is only one argument <code>test1</code> as explained by [over.match.conv]/2 above -- the argument is the initializer expression <code>test1</code>; the \"parameter of the viable function\" is the implicit object parameter of the member functions of <code>X</code>.</p>\n<p><em>Now</em> the implicit conversion sequence rules apply:</p>\n<ul>\n<li><code>operator void*()</code> requires no conversion - the argument is <code>X</code> and the parameter is <code>X&amp;</code></li>\n<li><code>operator bool() const</code> requires a qualification conversion - the argument is <code>X</code> and the parameter is <code>X const&amp;</code></li>\n</ul>\n<p><em>No conversion</em> is better than qualification conversion ([over.ics.rank]/3.1.1). So ICS1(<code>operator void*()</code>) is a better conversion sequence than ICS1(<code>operator bool() const</code>); so at this point <code>operator void*()</code> wins ([over.match.best]/1.3).</p>\n<p>The subsequent paragraph [over.match.best]/1.4 explains what would have happened if neither of those two sequences was better: we would only then go on to compare the standard conversion sequences from the return type of the candidate function onto the type being initialized.</p>\n<p>You can explore this case by changing the <code>X</code> member to <code>operator void*() const</code>. Now the two ICS1 sequences are indistinguishable as of /1.3, so we go onto /1.4 at which point <code>operator bool() const</code> wins because its conversion to <code>bool</code> is the identity, whereas <code>operator void*() const</code> still requires a boolean conversion.</p>\n</hr></hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2016-09-13T11:15:41.820", "Id": "39467467", "Score": "10", "CreationDate": "2016-09-13T10:12:11.753", "LastActivityDate": "2016-09-13T11:15:41.820"}, "39465464": {"ParentId": "39465404", "CommentCount": "2", "Body": "<p>The implicit <code>this</code> pointer is non-<code>const</code>. So <em>overload resolution</em> takes place on the set of <em>all</em> non-<code>const</code> methods (including templates - which is one for the pub quiz), <em>before</em> any <code>const</code> methods are considered.</p>\n<p>The fact that a function is marked <code>const</code> does not ever make it a better fit for a non-<code>const</code> <code>this</code> pointer, if you get my meaning.</p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\">http://en.cppreference.com/w/cpp/language/overload_resolution</a> which largely proxies the standards.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "39465464", "Score": "7", "CreationDate": "2016-09-13T08:29:13.063", "LastActivityDate": "2016-09-13T08:29:13.063"}, "39465404": {"CommentCount": "4", "ViewCount": "407", "PostTypeId": "1", "LastEditorUserId": "1639256", "CreationDate": "2016-09-13T08:25:16.960", "LastActivityDate": "2016-09-13T14:33:20.040", "Title": "Precedence of const member function over return value type match", "AcceptedAnswerId": "39467467", "LastEditDate": "2016-09-13T14:33:20.040", "Id": "39465404", "Score": "16", "Body": "<p>In <code>Y::test1()</code> a non-const <code>X::operator void*()</code> takes precedence over a seemingly better match, <code>X::operator bool() const</code> - Why is that? And where is this phenomenon described in the standard?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n  operator void*()      { std::cout &lt;&lt; \"  operator void*()\\n\"; return nullptr; }\n  operator bool() const { std::cout &lt;&lt; \"  operator bool()\\n\";  return true; }\n};\n\nstruct Y {\n  X x;\n  bool test1()       { std::cout &lt;&lt; \"test1()\\n\"; return x; }\n  bool test2() const { std::cout &lt;&lt; \"test2()\\n\"; return x; }\n};\n\nint main() {\n  Y y;\n  y.test1();\n  y.test2();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>test1()\n  operator void*()\ntest2()\n  operator bool()\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "485343", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39465404_39467467_3": {"section_id": 606, "quality": 0.9333333333333333, "length": 14}, "so_39465404_39467467_4": {"section_id": 603, "quality": 0.8611111111111112, "length": 31}, "so_39465404_39467467_2": {"section_id": 594, "quality": 0.75, "length": 15}, "so_39465404_39467467_1": {"section_id": 595, "quality": 1.0, "length": 21}}, "n3337": {"so_39465404_39467467_3": {"section_id": 596, "quality": 0.9333333333333333, "length": 14}, "so_39465404_39467467_4": {"section_id": 593, "quality": 0.8611111111111112, "length": 31}, "so_39465404_39467467_2": {"section_id": 584, "quality": 0.75, "length": 15}, "so_39465404_39467467_1": {"section_id": 585, "quality": 1.0, "length": 21}}, "n4659": {"so_39465404_39467467_3": {"section_id": 632, "quality": 0.9333333333333333, "length": 14}, "so_39465404_39467467_4": {"section_id": 629, "quality": 0.8611111111111112, "length": 31}, "so_39465404_39467467_2": {"section_id": 617, "quality": 0.75, "length": 15}, "so_39465404_39467467_1": {"section_id": 618, "quality": 1.0, "length": 21}}}});