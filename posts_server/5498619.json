post_cb({"5498712": {"ParentId": "5498619", "LastEditDate": "2016-07-12T16:09:22.443", "CommentCount": "6", "CreationDate": "2011-03-31T10:55:13.737", "Score": "9", "LastEditorUserId": "4082723", "PostTypeId": "2", "Id": "5498712", "OwnerUserId": "505088", "Body": "<p>C and C++ support atomic types in their current standards. </p>\n<p>C++11 introduced support for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html\" rel=\"nofollow\">atomic types</a>. Likewise C11 introduced <a href=\"http://en.cppreference.com/w/c/atomic\" rel=\"nofollow\">atomics</a>. </p>\n", "LastActivityDate": "2016-07-12T16:09:22.443"}, "5504678": {"ParentId": "5498619", "CommentCount": "0", "CreationDate": "2011-03-31T18:40:39.493", "OwnerUserId": "680696", "PostTypeId": "2", "Id": "5504678", "Score": "-1", "Body": "<p>Well definitely not atomic, but the compiler will most likely issue the copy as a memcpy() of N bytes, where the bytes is the size of the structur</p>\n", "LastActivityDate": "2011-03-31T18:40:39.493"}, "5498737": {"ParentId": "5498619", "LastEditDate": "2011-03-31T12:50:42.553", "CommentCount": "6", "CreationDate": "2011-03-31T10:57:53.703", "Score": "1", "LastEditorUserId": "85371", "PostTypeId": "2", "Id": "5498737", "OwnerUserId": "85371", "Body": "<p>No it isn't.</p>\n<p>That is actually a property of the CPU architecture in relation to the memory layout of struck</p>\n<p>You could use the 'atomic pointer swap' solution, which can be made atomic, and could be used in a lockfree scenario.\n<strike>Be sure to mark the respective shared pointer (variables) as volatile if it is important that changes are seen by other threads 'immediately'</strike><strong>This, in real life (TM) is not enough to guarantee correct treatment by the compiler.  Instead program against atomic primitives/intrinsics directly when you want to have lockfree semantics</strong>. <em>(see comments and linked articles for background)</em></p>\n<p>Of course, inversely, you'll have to make sure you take a deep copy at the relevant times in order to do processing on the reading side of this.</p>\n<p>Now all of this quickly becomes highly complex in relation to memory management and I suggest you scrutinize your design and ask yourself <strong>seriously</strong> whether all the (perceived?) performance benefits justify the risk. Why don't you opt for a simple (reader/writer) lock, or get your hands on a fancy shared pointer implementation that is threadsafe ?</p>\n", "LastActivityDate": "2011-03-31T12:50:42.553"}, "46071432": {"ParentId": "5498619", "LastEditDate": "2017-09-06T10:02:23.243", "CommentCount": "0", "CreationDate": "2017-09-06T09:23:31.460", "Score": "1", "LastEditorUserId": "224132", "PostTypeId": "2", "Id": "46071432", "OwnerUserId": "224132", "Body": "<p>Do you need to atomically snapshot all the struct members?  Or do you just need shared read/write access to separate members separately?  The latter is a lot easier, see below.</p>\n<hr>\n<p>C11 <a href=\"http://en.cppreference.com/w/c/atomic\" rel=\"nofollow noreferrer\">stdatomic</a> and C++11 <a href=\"http://en.cppreference.com/w/cpp/atomic\" rel=\"nofollow noreferrer\">std::atomic</a> provide syntax for atomic objects of arbitrary sizes.  But if they're larger than 8B or 16B, they won't be lock-free on typical systems, though.  (i.e. atomic load, store, exchange or CAS will be implemented by taking a hidden lock and then copying the whole struct).</p>\n<p>If you just want a couple members, it's probably better to use a lock yourself and then access the members, instead of getting the compiler to copy the whole struct.  (Current compilers aren't good at optimizing weird uses of atomics like that).</p>\n<p>Or <strong>add a level of indirection</strong>, so there's a pointer which can easily be updated atomically to point to another <code>struct</code> with a different set of values.  <strong>This is the building block for <a href=\"https://en.wikipedia.org/wiki/Read-copy-update\" rel=\"nofollow noreferrer\">RCU (Read-Copy-Update)</a></strong> See also <a href=\"https://lwn.net/Articles/262464/\" rel=\"nofollow noreferrer\">https://lwn.net/Articles/262464/</a>.  There are good library implementations of RCU, so use one instead of rolling your own unless your use-case is a lot simpler than the general case.  Figuring out when to free old copies of the struct is one of the hard parts, because you can't do that until the last reader thread is done with it.  And the whole point of RCU is to make the read path as light-weight as possible...</p>\n<hr>\n<p>Your struct is 16 bytes on most systems; just barely small enough that x86-64 can load or store the entire things somewhat more efficiently than just taking a lock.  (But only with <code>lock cmpxchg16b</code>).  Still, it's not totally silly to use C/C++ atomics for this</p>\n<p>common to both C++11 and C11:</p>\n<pre><code>struct A{\n    int a;\n    int b;\n    double c;\n};\n</code></pre>\n<p><strong>In C11 use the <code>_Atomic</code> type qualifier to make an atomic type</strong>.  It's a qualifier like <code>const</code> or <code>volatile</code>, so you can use it on just about anything.</p>\n<pre><code>#include &lt;stdatomic.h&gt;\n_Atomic struct A shared_struct;\n\n  // atomically take a snapshot of the shared state and do something\ndouble read_shared (void) {\n    struct A tmp = shared_struct;   // defaults to memory_order_seq_cst\n    // or atomic_load_explicit(&amp;shared_struct, &amp;tmp, memory_order_relaxed);\n\n    //int t = shared_struct.a;  // UNDEFINED BEHAVIOUR\n\n    // then do whatever you want with the copy, it's a normal struct\n    if (tmp.a &gt; tmp.b)\n       tmp.c = -tmp.c;\n    return tmp.c;\n}\n\n// or take tmp by value or pointer as a function arg\n// static inline\nvoid update_shared(int a, int b, double c) {\n    struct A tmp = {a, b, c};\n    //shared_struct = tmp;\n    // If you just need atomicity, not ordering, relaxed is much faster for small lock-free objects (no memory barrier)\n    atomic_store_explicit(&amp;shared_struct, tmp, memory_order_relaxed);\n}\n</code></pre>\n<p>Note that accessing a single member of an <code>_Atomic</code> struct is undefined behaviour.  It won't respect locking, and might not be atomic.  So don't do <code>int i = shared_state.a;</code>  (C++11 don't compile that, but C11 will).</p>\n<p><strong>In C++11, it's nearly the same</strong>: use the <code>std::atomic&lt;T&gt;</code> template.</p>\n<pre><code>#include &lt;atomic&gt;\nstd::atomic&lt;A&gt; shared_struct;\n\n  // atomically take a snapshot of the shared state and do something\ndouble read_shared (void) {\n    A tmp = shared_struct;   // defaults to memory_order_seq_cst\n    // or A tmp = shared_struct.load(std::memory_order_relaxed);\n    // or atomic_load_explicit(&amp;shared_struct, &amp;tmp, memory_order_relaxed);\n\n    //int t = shared_struct.a;  // won't compile: no operator.() overload\n\n    // then do whatever you want with the copy, it's a normal struct\n    if (tmp.a &gt; tmp.b)\n       tmp.c = -tmp.c;\n    return tmp.c;\n}\n\nvoid update_shared(int a, int b, double c) {\n    struct A tmp{a, b, c};\n    //shared_struct = tmp;\n    // If you just need atomicity, not ordering, relaxed is much faster for small lock-free objects (no memory barrier)\n    shared_struct.store(tmp, std::memory_order_relaxed);\n}\n</code></pre>\n<p>See it <a href=\"https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'struct+A%7B%0A++++int+a%3B%0A++++int+b%3B%0A++++double+c%3B%0A%7D%3B%0A%0A%23include+%3Catomic%3E%0Astd::atomic%3CA%3E+shared_struct%3B%0A%0A++//+atomically+take+a+snapshot+of+the+shared+state+and+do+something%0Adouble+read_shared+(void)+%7B%0A++++A+tmp+%3D+shared_struct%3B+++//+defaults+to+memory_order_seq_cst%0A++++//+or+A+tmp+%3D+shared_struct.load(std::memory_order_relaxed)%3B%0A++++//+or+atomic_load_explicit(%26shared_struct,+%26tmp,+memory_order_relaxed)%3B%0A%0A++++//int+t+%3D+shared_struct.a%3B++//+won!'t+compile:+no+operator.()+overload%0A%0A++++//+then+do+whatever+you+want+with+the+copy,+it!'s+a+normal+struct%0A++++if+(tmp.a+%3E+tmp.b)%0A+++++++tmp.c+%3D+-tmp.c%3B%0A++++return+tmp.c%3B%0A%7D%0A%0Avoid+update_shared(int+a,+int+b,+double+c)+%7B%0A++++struct+A+tmp%7Ba,+b,+c%7D%3B%0A++++//shared_struct+%3D+tmp%3B%0A++++//+If+you+just+need+atomicity,+not+ordering,+relaxed+is+much+faster+for+small+lock-free+objects+(no+memory+barrier)%0A++++shared_struct.store(tmp,+std::memory_order_relaxed)%3B%0A%7D%0A%0Avoid+update_shared2(A+tmp)+%7B%0A++++//shared_struct+%3D+tmp%3B%0A++++shared_struct.store(tmp,+std::memory_order_relaxed)%3B%0A%7D%0A++++'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:37.46397694524496,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((g:!((g:!((h:compiler,i:(compiler:clang400,filters:(___0:(),b:'0',commentOnly:'0',directives:'0',intel:'0',jquery:'3.2.1',length:1,prevObject:(___0:(sizzle1504687564252:(undefined:(legend:!(5,0,'1')))),length:1,prevObject:(___0:(jQuery321042181668995366041:(display:''),sizzle1504687564252:(undefined:(legend:!(5,0,'1')))),length:1))),options:'-std%3Dc%2B%2B11+-stdlib%3Dlibc%2B%2B+-O3+-Wall+-march%3Dskylake',source:1),l:'5',n:'0',o:'x86-64+clang+4.0.0+(Editor+%231,+Compiler+%231)',t:'0')),header:(),k:50,l:'4',m:70.23208879919274,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+clang+4.0.0',t:'0')),header:(),l:'4',m:29.767911200807262,n:'0',o:'',s:0,t:'0')),k:48.24074074074074,l:'3',n:'0',o:'',t:'0'),(g:!((g:!((h:compiler,i:(compiler:gsnapshot,filters:(___0:(),b:'0',commentOnly:'0',directives:'0',intel:'0',jquery:'3.2.1',length:1,prevObject:(___0:(sizzle1504687564252:(undefined:(legend:!(11,0,'1')))),length:1,prevObject:(___0:(jQuery321042181668995366041:(display:''),sizzle1504687564252:(undefined:(legend:!(11,0,'1')))),length:1))),options:'-std%3Dc%2B%2B11+-Wall+-Wextra+-O3+-march%3Dcore2',source:1),l:'5',n:'0',o:'x86-64+gcc+(trunk)+(Editor+%231,+Compiler+%232)',t:'0')),header:(),k:50,l:'4',m:74.06659939455096,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:2,editor:1),l:'5',n:'0',o:'%232+with+x86-64+gcc+(trunk)',t:'0')),header:(),l:'4',m:25.93340060544904,n:'0',o:'',s:0,t:'0')),k:51.75925925925926,l:'3',n:'0',o:'',t:'0')),k:62.53602305475504,l:'2',m:100,n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">on the Godbolt compiler explorer</a></p>\n<hr>\n<p>Of if you don't need to snapshot the entire struct, but instead <strong>just want each member to be <em>separately</em> atomic</strong>, then you can simply make each member an atomic type.  (Like <code>atomic_int</code> and <a href=\"https://stackoverflow.com/questions/45055402/atomic-double-floating-point-or-sse-avx-vector-load-store-on-x86-64\"><code>_Atomic double</code> or <code>std::atomic&lt;double&gt;</code></a>).</p>\n<pre><code>struct Amembers {\n    atomic_int a, b;\n#ifdef __cplusplus\n    std::atomic&lt;double&gt; c;\n#else\n    _Atomic double c;\n#endif\n} shared_state;\n// If these members are used separately, put them in separate cache lines\n// instead of in the same struct to avoid false sharing cache-line ping pong.\n</code></pre>\n<p>(Note that C11 stdatomic is not guaranteed to be compatible with C++11 \nstd::atomic, so don't expect to be able to access the same struct from C or C++.)</p>\n<p>In C++11, struct-assignment for a struct with atomic members won't compile, because <code>std::atomic</code> deletes its copy-constructor.  (You're supposed to load <code>std::atomic&lt;T&gt; shared</code> into <code>T tmp</code>, like in the whole-struct example above.)</p>\n<p>In C11, struct-assignment for a non-atomic struct with atomic members will compile but <em>is not atomic</em>.  The C11 standard doesn't specifically point this out anywhere.  The best I can find is: n1570: 6.5.16.1 Simple assignment:</p>\n<blockquote>\n<p id=\"so_5498619_46071432_0\">In simple assignment (=), the value of the right operand is converted to the type of the\n  assignment expression and replaces the value stored in the object designated by the left\n  operand.</p>\n</blockquote>\n<p>Since this doesn't say anything about special handling of atomic members, it must be assumed that it's like a <code>memcpy</code> of the object representations.  (Except that it's allowed to not update the padding.)</p>\n<p>In practice, it's easy to get gcc to generate asm for structs with an atomic member where it copies non-atomically.  Especially with a large atomic member which is atomic but not lock-free.</p>\n</hr></hr></hr>", "LastActivityDate": "2017-09-06T10:02:23.243"}, "5498619": {"CommentCount": "2", "ViewCount": "2368", "CreationDate": "2011-03-31T10:46:51.687", "LastActivityDate": "2017-09-06T10:02:23.243", "PostTypeId": "1", "AcceptedAnswerId": "5498635", "FavoriteCount": "1", "Title": "Is struct assignment atomic in C/C++?", "Id": "5498619", "Score": "15", "Body": "<p>I am writing a program which has one process reading and writing to a shared memory and another process only reading it. In the shared memory there is a struct like this:</p>\n<pre>\n<code>\nstruct A{\n    int a;\n    int b;\n    double c;\n};\n</code>\n</pre>\n<p>what I expect is to read the struct at once because while I am reading, the other process might be modifying the content of the struct. This can be achieved if the struct assignment is atomic, that is not interrupted. Like this:</p>\n<pre>\n<code>\nstruct A r = shared_struct;\n</code>\n</pre>\n<p>So, is struct assignment atomic in C/C++? I tried searching the web but cannot find helpful answers. Can anyone help?\nThank you.</p>\n", "Tags": "<c++><c><struct><variable-assignment><atomic>", "OwnerUserId": "685539", "AnswerCount": "5"}, "5498635": {"ParentId": "5498619", "CommentCount": "1", "CreationDate": "2011-03-31T10:48:17.710", "OwnerUserId": "57428", "PostTypeId": "2", "Id": "5498635", "Score": "16", "Body": "<p>No, both C and C++ standard don't guarantee assignment operations to be atomic. You need some implementation-specific stuff for that - either something in the compiler or in the operating system.</p>\n", "LastActivityDate": "2011-03-31T10:48:17.710"}, "bq_ids": {"n4140": {"so_5498619_46071432_0": {"section_id": 3291, "quality": 0.625, "length": 10}}, "n4659": {"so_5498619_46071432_0": {"section_id": 4053, "quality": 0.625, "length": 10}}}});