post_cb({"10770044": {"ViewCount": "608", "Body": "<p>Say we have this code</p>\n<pre><code>class A {\npublic:\n    A() : x(1) {}\n    virtual ~A() {}\n\n    int x;\n};\n\nclass B {\npublic:\n    B() : y(2) {}\n    virtual ~B() {}\n\n    void g()\n    {\n        cout &lt;&lt; \"B::\" &lt;&lt; y &lt;&lt; endl;\n    }\n\n    int y;\n};\n\nclass C : private A, private B {\npublic:\n    void f()\n    {\n        B* p = static_cast&lt;B*&gt;( this );\n        p-&gt;g();\n    }\n};\n\nint main()\n{\n    C c;\n    ((B*)&amp;c)-&gt;g();\n\n    return 0;\n}\n</code></pre>\n<p>The C style cast in the main function cannot be correctly expressed in terms of the C++ casts (<code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code>). But what is the reason to allow this in the first place? Doesn't it hurt encapsulation?</p>\n<p><strong>UPDATE</strong>\nThis is not a duplicate of the linked question, because this question is about design decisions in C++. It does not ask what I can or cannot do with the language, it asks why certain decisions might have been made.</p>\n", "AcceptedAnswerId": "10770083", "Title": "Why does C style cast allow you to convert to a private base class?", "CreationDate": "2012-05-26T21:50:00.607", "Id": "10770044", "CommentCount": "11", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-04-03T09:29:43.887", "LastEditorUserId": "193903", "LastActivityDate": "2016-04-03T09:29:43.887", "ClosedDate": "2016-03-31T08:41:49.923", "Score": "7", "OwnerUserId": "193903", "Tags": "<c++><class><casting><upcasting>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_10770044_10770061_8": {"length": 15, "quality": 1.0, "section_id": 6126}, "so_10770044_10770061_9": {"length": 31, "quality": 1.0, "section_id": 6126}, "so_10770044_10770061_7": {"length": 20, "quality": 1.0, "section_id": 6126}, "so_10770044_10770061_6": {"length": 24, "quality": 0.96, "section_id": 6126}}, "n3337": {"so_10770044_10770061_8": {"length": 15, "quality": 1.0, "section_id": 5890}, "so_10770044_10770061_9": {"length": 31, "quality": 1.0, "section_id": 5890}, "so_10770044_10770061_7": {"length": 20, "quality": 1.0, "section_id": 5890}, "so_10770044_10770061_6": {"length": 24, "quality": 0.96, "section_id": 5890}}, "n4659": {"so_10770044_10770061_8": {"length": 15, "quality": 1.0, "section_id": 7623}, "so_10770044_10770061_9": {"length": 31, "quality": 1.0, "section_id": 7623}, "so_10770044_10770061_7": {"length": 20, "quality": 1.0, "section_id": 7623}, "so_10770044_10770061_6": {"length": 24, "quality": 0.96, "section_id": 7623}}}, "10770065": {"Id": "10770065", "PostTypeId": "2", "Body": "<p>A C-style cast allows you to convert any type to any other type.  You can do <code>(std::istream*)&amp;c</code> if you'd like, but it's not recommended.</p>\n", "LastActivityDate": "2012-05-26T21:52:35.377", "Score": "-1", "CreationDate": "2012-05-26T21:52:35.377", "ParentId": "10770044", "CommentCount": "5", "OwnerUserId": "382471"}, "10770083": {"Id": "10770083", "PostTypeId": "2", "Body": "<p>It's because in C it was allowed to convert any pointer to any other pointer using this cast and C++ tries to be C-compatible as much as possible, but tries to do a good job to be correct when it comes to classes, so C style cast is stronger than <code>reinterpret_cast</code> in this situation.</p>\n", "LastEditorUserId": "193903", "LastActivityDate": "2013-09-11T15:19:33.383", "Score": "1", "CreationDate": "2012-05-26T21:55:30.823", "ParentId": "10770044", "CommentCount": "5", "LastEditDate": "2013-09-11T15:19:33.383", "OwnerUserId": "193903"}, "10770061": {"Id": "10770061", "PostTypeId": "2", "Body": "<p>When a C-style pointer cast is used between pointers to a base and derived class, it behaves like a <code>static_cast</code> - even if the base is private.</p>\n<p>(C-style casts between unrelated pointer types are <code>reinterpret_cast</code>s).</p>\n<p>The Standard says:</p>\n<blockquote>\n<p id=\"so_10770044_10770061_0\">The conversions performed by</p>\n<p id=\"so_10770044_10770061_1\">\u2014 a const_cast (5.2.11),</p>\n<p id=\"so_10770044_10770061_2\">\u2014 a static_cast (5.2.9),</p>\n<p id=\"so_10770044_10770061_3\">\u2014 a static_cast followed by a const_cast,</p>\n<p id=\"so_10770044_10770061_4\">\u2014 a reinterpret_cast (5.2.10), or</p>\n<p id=\"so_10770044_10770061_5\">\u2014 a reinterpret_cast followed by a const_cast,</p>\n<p id=\"so_10770044_10770061_6\">can be performed using the cast notation of explicit type conversion. The same semantic restrictions and behaviors apply, with the exception that in performing a static_cast in the following situations <strong>the conversion is valid even if the base class is inaccessible</strong>:</p>\n<p id=\"so_10770044_10770061_7\">\u2014 a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;</p>\n<p id=\"so_10770044_10770061_8\">\u2014 a pointer to member of derived class type may be explicitly converted to a pointer to member of an unambiguous non-virtual base class type;</p>\n<p id=\"so_10770044_10770061_9\">\u2014 a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type, respectively.</p>\n</blockquote>\n<p>Your situation is described in the first point, so the conversion is done by <code>static_cast</code> and the pointer is adjusted.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-03-31T08:39:27.113", "Score": "7", "CreationDate": "2012-05-26T21:52:15.970", "ParentId": "10770044", "CommentCount": "23", "LastEditDate": "2016-03-31T08:39:27.113", "OwnerUserId": "726361"}});