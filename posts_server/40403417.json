post_cb({"40403574": {"Id": "40403574", "PostTypeId": "2", "Body": "<p>This is not undefined behavior.  If we look at [class.dtor]/8 we have </p>\n<blockquote>\n<p id=\"so_40403417_40403574_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X\u2019s direct non-variant non-static data members, the destructors for X\u2019s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X\u2019s virtual base classes.</p>\n</blockquote>\n<p>which states the the non-static members of the class are destroyed after the body of the destructor is ran.  That means all the members are alive in the destructor and manipulating <code>x</code> and calling <code>join</code> behave just like they would in a normal member function.  The only difference is after the body of the destructor is ran then the members themselves will be destroyed.</p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2016-11-03T14:06:45.267", "Score": "6", "CreationDate": "2016-11-03T14:04:33.100", "ParentId": "40403417", "CommentCount": "0", "OwnerUserId": "4342498", "LastEditDate": "2016-11-03T14:06:45.267"}, "bq_ids": {"n4140": {"so_40403417_40403682_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}, "so_40403417_40403682_3": {"length": 7, "quality": 1.0, "section_id": 411}, "so_40403417_40403574_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 404}, "so_40403417_40403682_5": {"length": 40, "quality": 0.9523809523809523, "section_id": 7193}}, "n3337": {"so_40403417_40403682_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}, "so_40403417_40403682_3": {"length": 7, "quality": 1.0, "section_id": 402}, "so_40403417_40403682_5": {"length": 40, "quality": 0.9523809523809523, "section_id": 6937}, "so_40403417_40403574_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 395}}, "n4659": {"so_40403417_40403682_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_40403417_40403682_3": {"length": 7, "quality": 1.0, "section_id": 429}, "so_40403417_40403682_5": {"length": 39, "quality": 0.9285714285714286, "section_id": 8702}, "so_40403417_40403574_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 422}}}, "40403417": {"ViewCount": "142", "Body": "<p>One of my coworkers claims that as soon as an object's destructor invocation begins, all accesses to the object's members done by a thread <em>(that's a member of the object itself)</em> are UB.</p>\n<p>This implies that calling <code>std::thread::join</code> during the destructor of an object is UB if the thread is accessing any of the object's other members.</p>\n<p>I briefly looked in the latest standard draft, under <em>\"Object Lifetime\"</em>, but couldn't find something that gave me a conclusive answer.</p>\n<p><strong>Does the following code <a href=\"http://melpon.org/wandbox/permlink/GkyyR2rWhyTKXzzl\" rel=\"nofollow noreferrer\"><em>(on wandbox)</em></a> introduce <em>undefined behavior</em>?</strong> What's the part of the standard that clarifies this interaction?</p>\n<pre><code>struct A \n{\n    atomic&lt;bool&gt; x{true};\n    thread t;\n\n// Capturing 'this' is part of the issue.\n// The idea is that accessing 'this-&gt;x' becomes invalid as soon as '~A()' is entered.\n//           vvvv\n    A() : t([this]\n            { \n                while(x) \n                {\n                    this_thread::sleep_for(chrono::milliseconds(100)); \n                }\n            }) \n    { \n    }\n\n    ~A() \n    { \n        x = false; \n        t.join(); \n    }\n};\n\nint main()\n{\n    A a;\n}\n</code></pre>\n", "AcceptedAnswerId": "40403574", "Title": "Does joining a member thread accessing other members of its parent class in the parent's destructor result in undefined behavior?", "CreationDate": "2016-11-03T13:56:29.853", "Id": "40403417", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-11-03T14:25:50.820", "Score": "4", "OwnerUserId": "598696", "Tags": "<c++><multithreading><c++11><language-lawyer><undefined-behavior>", "AnswerCount": "2"}, "40403682": {"Id": "40403682", "PostTypeId": "2", "Body": "<p>Using N3337 since this question is tagged C++11.</p>\n<p>It doesn't seem that it's undefined to access class members during the destructor execution:</p>\n<blockquote>\n<p id=\"so_40403417_40403682_0\">\u00a712.7 [class.cdtor]/1</p>\n<p id=\"so_40403417_40403682_1\">For an object with a non-trivial destructor, referring to any\n  non-static member or base class of the object after the destructor\n  finishes execution results in undefined behavior.</p>\n</blockquote>\n<p>and although it's stated that</p>\n<blockquote>\n<p id=\"so_40403417_40403682_2\">\u00a712.4 [class.dtor]/15</p>\n<p id=\"so_40403417_40403682_3\">Once a destructor is invoked for an object, the object no longer exists</p>\n</blockquote>\n<p>the following explicitly links to 12.7 when discussing objects:</p>\n<blockquote>\n<p id=\"so_40403417_40403682_4\">\u00a73.8 [basic.life]/5</p>\n<p id=\"so_40403417_40403682_5\">Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated <sup>38</sup> or,\n  after the lifetime of an object has ended and before the storage which\n  the object occupied is reused or released, any pointer that refers to\n  the storage location where the object will be or was located may be\n  used but only in limited ways. For an object under construction or\n  destruction, see 12.7.</p>\n</blockquote>\n", "LastActivityDate": "2016-11-03T14:09:37.983", "CommentCount": "0", "CreationDate": "2016-11-03T14:09:37.983", "ParentId": "40403417", "Score": "3", "OwnerUserId": "2456565"}});