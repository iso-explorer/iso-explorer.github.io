post_cb({"28168290": {"CommentCount": "11", "ViewCount": "107", "CreationDate": "2015-01-27T10:32:32.880", "LastActivityDate": "2015-01-27T12:48:03.393", "Title": "Is a templated and a nontemplated version of the same function considered an overload?", "AcceptedAnswerId": "28170899", "PostTypeId": "1", "Id": "28168290", "Score": "3", "Body": "<p>A very formal question: is this considered an overload? Is removing the template fundamentally different than only overloading on arguments?</p>\n<pre><code>template&lt;class T&gt; void myFunction(const T&amp; t) {}\nvoid myFunction(const double&amp; t) {}\n</code></pre>\n<p>Then the follow up question, is it better to follow this approach or to use template specialization, instead of the overload?</p>\n<pre><code>template&lt;&gt; void myFunction(const double&amp; t) {}\n</code></pre>\n", "Tags": "<c++><templates><overloading><template-specialization>", "OwnerUserId": "1673574", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28168290_28170899_0": {"section_id": 603, "quality": 0.84, "length": 21}}, "n3337": {"so_28168290_28170899_0": {"section_id": 593, "quality": 0.88, "length": 22}}, "n4659": {"so_28168290_28170899_0": {"section_id": 629, "quality": 0.84, "length": 21}}}, "28170899": {"ParentId": "28168290", "CommentCount": "0", "Body": "<p>First of all, according to the standard (start of \u00a713): \u201cWhen two\nor more different declarations are specified for a single name in the\nsame scope, that name is said to be overloaded.[...]Only function and\nfunction template declarations can be overloaded; variable and type\ndeclarations cannot be overloaded.\u201d  So clearly, your two\ndeclarations are overloads.</p>\n<p>If you call <code>myFunction( 3.14159 )</code>, then the template will be\ninstantiated with the same signature as the non-template, and both will\nbe exact matches.  In this case (\u00a713.3.1):</p>\n<blockquote>\n<p id=\"so_28168290_28170899_0\">Given these definitions, a viable function F1 is defined to be a\n  better function than another viable function F2 if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and\n  then\n  [...]\n  \u2014 F1 is a non-template function and F2 is a function template\n  specialization,  [...]</p>\n</blockquote>\n<p>The standard has specified your exact case.</p>\n<p>With regards to the alternative of specializing the function:\nspecializations may be overloads according to the definition above, but\nthey do not participate in overload resolution.  Specializations work\ndifferently: overload resolution first occurs without them; then, if\noverload resolution has chosen the template, and there is a\nspecialization for the instantiation type(s), the specialization is\nused, rather than the generic instantiation of the template.  Generally\nspeaking, the results are the same, although\n<a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">http://www.gotw.ca/publications/mill17.htm</a> points out one exotic (and\nbadly written?) case where they aren't.  Still, to me at least, it seems\nmore natural to provide the overloaded function, rather than the\ntemplate specialization.  Most of the time, anyway.  (There is one real\nexception: it's sometimes useful to not provide a generic\nimplementation, but only specializations.  In my experience, this\nsituation usually occurs with traits classes, but it can occur for an\nindividual function as well.  In such cases, of course, you do\nspecialize the template; you cannot use it otherwise.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "28170899", "Score": "3", "CreationDate": "2015-01-27T12:48:03.393", "LastActivityDate": "2015-01-27T12:48:03.393"}});