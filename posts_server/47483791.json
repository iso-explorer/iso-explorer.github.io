post_cb({"47484559": {"ParentId": "47483791", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Since C++11, associative container insertion requires either <em>copy-costructible</em> lvalues or <em>move-insertable</em> mutable rvalues. So, there's no problem invoking <code>insert()</code> along with <code>make_pair()</code> as you do: the latter constructs a <code>pair&lt;const char[],unique_ptr&gt;</code> that is used to initialize a <code>value_type</code> rvalue.</p>\n<p>The problem with the brace initialization is that (until C++17) the value_type const&amp; overload gets preferred (because there's no proper value_type&amp;&amp; overload), hence a copy is requested and an error is raised.</p>\n<p>Indeed, note that both forms compile in gcc trunk and clang 5(with libc++) in c++17 mode.</p>\n<hr>\n<p>More precisely, from C++11 on, the relevant insert semantic requirements read</p>\n<blockquote>\n<p id=\"so_47483791_47484559_0\"><strong>[unord.req]</strong> If t is a non-const rvalue expression, value_type shall be MoveInsertable into X; otherwise, value_type shall be CopyInsertable into X.</p>\n</blockquote>\n<p>is the actual members specification where things differ; until C++17, we have:</p>\n<pre><code>pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);\ntemplate &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);\n...\n</code></pre>\n<p>where the generic overload is SFINAE constrained to <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code>. Clearly, using a <em>braced-init-list</em> will select the const&amp; overload here (note: there's also an initializer_list overload, but it does not apply to the OP case).</p>\n<p>Instead, in C++17 we also have</p>\n<pre><code>pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);\n</code></pre>\n</hr>", "OwnerUserId": "8631381", "LastEditorUserId": "8631381", "LastEditDate": "2017-11-25T14:06:15.207", "Id": "47484559", "Score": "1", "CreationDate": "2017-11-25T09:42:42.450", "LastActivityDate": "2017-11-25T14:06:15.207"}, "bq_ids": {"n4140": {"so_47483791_47484559_0": {"section_id": 744, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_47483791_47484559_0": {"section_id": 733, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_47483791_47484559_0": {"section_id": 802, "quality": 0.9090909090909091, "length": 10}}}, "47483791": {"CommentCount": "2", "ViewCount": "81", "PostTypeId": "1", "LastEditorUserId": "2050761", "CreationDate": "2017-11-25T07:56:18.710", "LastActivityDate": "2017-11-25T14:06:15.207", "Title": "C++ map brace initialization and unique ptr", "AcceptedAnswerId": "47484559", "LastEditDate": "2017-11-25T11:47:22.373", "Id": "47483791", "Score": "3", "Body": "<p>Why can't I use map's braces initialization with unique_ptr? </p>\n<p>Edit: I use gcc 7.2 in c++17 mode.</p>\n<p>I can create and insert into unordered map using make_pair and the [] operator.</p>\n<pre><code>std::unordered_map&lt;std::string, std::unique_ptr&lt;A&gt;&gt; map;\n\nmap.insert(std::make_pair(\"hello\",std::make_unique&lt;A&gt;()));\nmap[\"foo\"] = std::make_unique&lt;A&gt;();\n</code></pre>\n<p>But I can't figure out why it fails when using braces.</p>\n<pre><code>map.insert({\"foo\", std::make_unique&lt;A&gt;()}); // Error\n</code></pre>\n<blockquote>\n<p id=\"so_47483791_47483791_0\">error: use of deleted function \u2018std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;)</p>\n</blockquote>\n", "Tags": "<c++><dictionary><c++14><std><unique-ptr>", "OwnerUserId": "2050761", "AnswerCount": "1"}});