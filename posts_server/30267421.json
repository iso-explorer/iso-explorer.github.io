post_cb({"30267466": {"ParentId": "30267421", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You have undefined behaviour because your operations are between two consecutive <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">sequence points</a> (there are no sequence points between function arguments evaluation). You can loosely think of sequence points as \"temporal\" markers and between two consecutive ones you are not allowed to modify the same variable more than once.</p>\n<p>Basically your code is equivalent to</p>\n<pre><code>std::cout &lt;&lt; x &lt;&lt; x++; // undefined behaviour\n</code></pre>\n<p>since <code>y</code> is just a reference (an alias) for <code>x</code>.</p>\n<p><strong>1.9 Program execution [intro.execution]</strong> (emphasize mine)</p>\n<blockquote>\n<p id=\"so_30267421_30267466_0\">14) Every <strong>value computation</strong> and <strong>side effect</strong> associated with a\n  full-expression is sequenced before every value computation and side\n  effect associated with the next full-expression to be evaluated.</p>\n<p id=\"so_30267421_30267466_1\">15) Except where noted, <strong>evaluations of operands of individual\n  operators and of subexpressions of individual expressions are\n  unsequenced.</strong> [ Note: In an expression that is evaluated more than once\n  during the execution of a program, unsequenced and indeterminately\n  sequenced evaluations of its subexpressions need not be performed\n  consistently in different evaluations. \u2014 end note ] The value\n  computations of the operands of an operator are sequenced before the\n  value computation of the result of the operator. <strong>If a side effect on a\n  scalar object is unsequenced relative to either another side effect on\n  the same scalar object or a value computation using the value of the\n  same scalar object, and they are not potentially concurrent (1.10),\n  the behavior is undefined.</strong> [ Note: The next section imposes similar,\n  but more complex restrictions on potentially concurrent computations.\n  \u2014endnote]</p>\n<p id=\"so_30267421_30267466_2\">When calling a function (whether or not the function is inline), every\n  value computation and side effect associated with any argument\n  expression, or with the postfix expression designating the called\n  function, is sequenced before execution of every expression or\n  statement in the body of the called function. [ Note: Value\n  computations and side effects associated with different argument\n  expressions are unsequenced. \u2014 end note ] Every evaluation in the\n  calling function (including other function calls) that is not\n  otherwise specifically sequenced before or after the execution of the\n  body of the called function is indeterminately sequenced with respect\n  to the execution of the called function.9 Several contexts in C++\n  cause evaluation of a function call, even though no corresponding\n  function call syntax appears in the translation unit. [ Example:\n  Evaluation of a new-expression invokes one or more allocation and\n  constructor functions; see 5.3.4. For another example, invocation of a\n  conversion function (12.3.2) can arise in contexts in which no\n  function call syntax appears.</p>\n</blockquote>\n<p>Related: <a href=\"https://stackoverflow.com/a/10782972/3093378\">https://stackoverflow.com/a/10782972/3093378</a></p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:18.523", "Id": "30267466", "Score": "15", "CreationDate": "2015-05-15T19:36:46.233", "LastActivityDate": "2015-05-15T20:31:06.333"}, "30267421": {"CommentCount": "1", "AcceptedAnswerId": "30267466", "PostTypeId": "1", "ClosedDate": "2015-05-15T20:01:36.577", "LastEditorUserId": "2162470", "CreationDate": "2015-05-15T19:33:37.597", "LastActivityDate": "2015-11-25T19:33:12.350", "LastEditDate": "2015-11-25T19:33:12.350", "ViewCount": "153", "FavoriteCount": "1", "Title": "Alterations to reference variables in c++", "Id": "30267421", "Score": "10", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int x=80;\n    int &amp;y=x;\n    cout&lt;&lt;\"x\"&lt;&lt;x&lt;&lt;\" \"&lt;&lt;\"y\"&lt;&lt;y++; \n    return 0;\n}\n</code></pre>\n<p>The above code gave me the following output:</p>\n<pre><code>81 80\n</code></pre>\n<p><strong>Can anyone explain me how the value of <code>x</code> changes to <code>81</code>?</strong> The value of <code>y</code> is <code>80</code> and it later gets incremented to <code>81</code>, but <strong>how did it reflect in <code>x</code>?</strong></p>\n<p><strong>Did it reflect because <code>y</code> is a reference variable?</strong> Then the value should have been modified in both <code>x</code> and <code>y</code>?</p>\n", "Tags": "<c++><pointers><memory-address>", "OwnerUserId": "2749191", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30267421_30267466_2": {"section_id": 5811, "quality": 0.912621359223301, "length": 94}, "so_30267421_30267466_1": {"section_id": 5811, "quality": 0.9036144578313253, "length": 75}, "so_30267421_30267466_0": {"section_id": 5810, "quality": 1.0, "length": 18}}, "n3337": {"so_30267421_30267466_2": {"section_id": 5584, "quality": 0.912621359223301, "length": 94}, "so_30267421_30267466_1": {"section_id": 5584, "quality": 0.7228915662650602, "length": 60}, "so_30267421_30267466_0": {"section_id": 5583, "quality": 1.0, "length": 18}}, "n4659": {"so_30267421_30267466_2": {"section_id": 7273, "quality": 0.6407766990291263, "length": 66}, "so_30267421_30267466_1": {"section_id": 7272, "quality": 0.8313253012048193, "length": 69}, "so_30267421_30267466_0": {"section_id": 7271, "quality": 1.0, "length": 18}}}});