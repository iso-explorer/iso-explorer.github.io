post_cb({"bq_ids": {"n4140": {"so_38617309_38617484_0": {"length": 31, "quality": 1.0, "section_id": 481}}, "n4659": {"so_38617309_38617484_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 504}}}, "38617309": {"ViewCount": "157", "LastEditDate": "2016-07-27T15:32:35.287", "Title": "Implicit move the value contained in std::optional when return", "CreationDate": "2016-07-27T15:28:13.457", "LastActivityDate": "2016-07-27T16:07:01.683", "CommentCount": "2", "Body": "<p>Since C++11 we have move semantics. In the example below the move-constructor will be used (or copy elision), instead of the copy-constructor as in C++98, without any additional efforts.</p>\n<pre><code>std::string f()\n{\n    std::string res;\n    ...\n    return res; // &lt;- move is used here instead of copy\n}\n</code></pre>\n<p>But what about this case?</p>\n<pre><code>std::string f()\n{\n    std::optional&lt;std::string&gt; res;\n    ...\n    return *res; // &lt;-- will the std::string value be moved??\n}\n</code></pre>\n<p>Or one have to write something like this?</p>\n<pre><code>std::string f()\n{\n    std::optional&lt;std::string&gt; res;\n    ...\n    return *std::move(res);\n}\n</code></pre>\n", "PostTypeId": "1", "LastEditorUserId": "5599569", "Id": "38617309", "Score": "1", "OwnerUserId": "5599569", "Tags": "<c++><move-semantics><c++1z>", "AnswerCount": "1"}, "38617484": {"Id": "38617484", "PostTypeId": "2", "LastEditDate": "2016-07-27T16:07:01.683", "CommentCount": "7", "LastEditorUserId": "2069064", "LastActivityDate": "2016-07-27T16:07:01.683", "CreationDate": "2016-07-27T15:35:13.687", "ParentId": "38617309", "Score": "5", "Body": "<p><strong>No</strong>. The criteria for implicitly moving is in [class.copy]:</p>\n<blockquote>\n<p id=\"so_38617309_38617484_0\">When [...], or when the <em>expression</em> in a <code>return</code> statement is a (possibly\n  parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body or <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>, overload resolution to\n  select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<p><code>*res</code> is not an <em>id-expression</em>, so this rule does not apply. If you want to move the underlying string out, you have to do it explicitly:</p>\n<pre><code>return std::move(*res);\nreturn *std::move(res);\nreturn std::move(res).value(); // equivalent and possibly more legible\n</code></pre>\n<hr/>\n<p>The rules are intended to try the more efficient option only when it's definitely safe to do so. If you're returning an automatic storage duration variable, then it's perfectly safe to move it since nothing else will ever reference that variable again. </p>\n<p>But if you're returning <code>*res</code>, that's not necessarily safe to move from. What if that gave you a reference into some external object which will outlive this function? We would be silently moving-from state that we expect to still be valid! In this case, it is up to you as the user to state that you want it moved. </p>\n", "OwnerUserId": "2069064"}});