post_cb({"bq_ids": {"n4140": {"so_8201327_8201344_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7183}}, "n3337": {"so_8201327_8201344_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6927}}, "n4659": {"so_8201327_8201344_0": {"length": 16, "quality": 0.6666666666666666, "section_id": 8691}}}, "8201327": {"ViewCount": "108", "Body": "<p>I am relatively new to programming so this may well sound like a stupid question to you seasoned pros out there. Here goes: </p>\n<p>In C++, when I use the delete operator on arrays, I have noticed that the data contained in the released memory locations is preserved. For example:</p>\n<pre><code>int* testArray=new int[5];\ntestArray[3]=24;\ncout&lt;&lt;testArray[3]; //prints 24\ndelete [] testArray;\ncout&lt;&lt;testArray[3]; // still prints 24\n</code></pre>\n<p>Subsequently, am I right in assuming that since <code>testArray[3]</code> still prints 42 , the data in the deleted memory location is still preserved? If so, does this notion hold true for other languages, and is there any particular reason for this?</p>\n<p>Shouldn't \"freed\" memory locations have null data, or is \"free memory\" just a synonym for memory that can be used by other applications, irrespective of whether the locations contain data or not?</p>\n<p>I've noticed this is not the case when it comes to non array types such as int, double etc. Dereferencing and outputting the deleted variable prints 0 rather than the data. I also have a sneaking suspicion that I might be using wrong syntax to delete <code>testArray</code>, which will probably make this question all the more stupid. I'd love to hear your thoughts nonetheless.</p>\n", "AcceptedAnswerId": "8201344", "Title": "Deleting memory and effect on data in concerned locations", "CreationDate": "2011-11-20T11:57:54.080", "Id": "8201327", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-21T16:27:20.490", "LastEditorUserId": "4370109", "LastActivityDate": "2015-11-21T16:27:20.490", "Score": "1", "OwnerUserId": "1024596", "Tags": "<c++><memory><delete-operator>", "AnswerCount": "3"}, "8201371": {"Id": "8201371", "PostTypeId": "2", "Body": "<p>non-POD data will be altered in a destructor (which might appear as being null-ed in a debugger).</p>\n<p>Freed data is just usable, indeed.</p>\n<p>You can NOT depend on the data being unaltered after delete. On a related note, debugging malloc's or runtime libraries will frequently reset the data to a specific signature (0xdeadbeef, 0xdcdcdcdc etc) so you can easily spot accesses to deleted memory in a debugger.</p>\n", "LastActivityDate": "2011-11-20T12:07:29.863", "CommentCount": "2", "CreationDate": "2011-11-20T12:07:29.863", "ParentId": "8201327", "Score": "2", "OwnerUserId": "85371"}, "8201344": {"Id": "8201344", "PostTypeId": "2", "Body": "<p>Once you deallocate the memory by calling <code>delete</code> and try to access the memory at that address again it is an <strong>Undefined Behavior</strong>.    </p>\n<p>The Standard does not mandate the compilers to do anything special in this regard. It does not ask the compilers to mark the de-allocated memory with <code>0</code> or some special magic numbers.It is left out as the implementation detail for the compilers. Some compiler implementations do mark such memory with some special magic numbers but it is left up to each compiler implementation.   </p>\n<p>In your case, the data, still exists at the deallocated addresses because perhaps there is no other memory requirement which needed that memory to be re-utilized and the compiler didn't clear the contents of previous allocation(since it is not needed to).    </p>\n<p>However, You should not rely on this at all as this might not be the case always. It still is and will be an <strong>Undefined Behavior</strong>.   </p>\n<hr>\n<p>EDIT: To answer the Q in comment.<br>\nThe <code>delete</code> operator does not return any value so you cannot check the return status however the Standard guarantees that the <code>delete</code> operator will sucessfully do it's job.   </br></p>\n<p>Relevant quote from the C++03 Standard:<br>\n<strong>Section \u00a73.7.3.2.4:</strong> </br></p>\n<blockquote>\n<p id=\"so_8201327_8201344_0\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), <strong>the deallocation function shall deallocate the storage referenced by the pointer, render-ing invalid all pointers referring to any part of the deallocated storage.</strong></p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2011-11-21T04:11:39.413", "Score": "2", "CreationDate": "2011-11-20T11:59:57.870", "ParentId": "8201327", "CommentCount": "2", "OwnerUserId": "452307", "LastEditDate": "2011-11-21T04:11:39.413"}, "8201337": {"Id": "8201337", "PostTypeId": "2", "Body": "<p>The data is still there, because when you free, it frees it in the allocation table -- the system would be very slow if it had to zero over all the memory each time free() or delete is called. </p>\n<p>This is the same in any language.</p>\n<p>I think the non-array types were set to zero because they were in fact statically allocated rather than dynamically allocated. </p>\n", "LastActivityDate": "2011-11-20T11:59:10.723", "CommentCount": "2", "CreationDate": "2011-11-20T11:59:10.723", "ParentId": "8201327", "Score": "2", "OwnerUserId": "1028638"}});