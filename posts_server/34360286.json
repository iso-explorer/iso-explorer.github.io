post_cb({"bq_ids": {"n4140": {"so_34360286_34577436_1": {"section_id": 4, "quality": 0.9148936170212766, "length": 43}, "so_34360286_34577436_0": {"section_id": 6189, "quality": 1.0, "length": 24}, "so_34360286_34594252_1": {"section_id": 6186, "quality": 0.8125, "length": 13}, "so_34360286_34594252_2": {"section_id": 6186, "quality": 0.72, "length": 18}, "so_34360286_34594252_0": {"section_id": 6186, "quality": 0.8260869565217391, "length": 19}, "so_34360286_34360286_0": {"section_id": 6186, "quality": 0.8297872340425532, "length": 78}}, "n3337": {"so_34360286_34594252_2": {"section_id": 5947, "quality": 0.56, "length": 14}, "so_34360286_34594252_1": {"section_id": 5947, "quality": 0.8125, "length": 13}, "so_34360286_34594252_0": {"section_id": 5947, "quality": 0.6956521739130435, "length": 16}, "so_34360286_34577436_0": {"section_id": 5949, "quality": 0.75, "length": 18}, "so_34360286_34360286_0": {"section_id": 5947, "quality": 0.648936170212766, "length": 61}}, "n4659": {"so_34360286_34577436_1": {"section_id": 4, "quality": 0.9361702127659575, "length": 44}, "so_34360286_34577436_0": {"section_id": 7692, "quality": 1.0, "length": 24}, "so_34360286_34594252_2": {"section_id": 7689, "quality": 0.84, "length": 21}, "so_34360286_34594252_1": {"section_id": 7689, "quality": 0.6875, "length": 11}, "so_34360286_34594252_0": {"section_id": 7688, "quality": 0.5652173913043478, "length": 13}}}, "34360286": {"CommentCount": "3", "ViewCount": "730", "PostTypeId": "1", "LastEditorUserId": "411165", "CreationDate": "2015-12-18T16:48:13.590", "LastActivityDate": "2016-01-05T17:06:37.083", "Title": "Why do we need the two definitions: integral constant expression and converted constant expression?", "FavoriteCount": "6", "LastEditDate": "2015-12-18T20:05:51.017", "Id": "34360286", "Score": "17", "Body": "<p>\u00a75.19/3 in C++14 defines an integral constant expression and a converted constant expression:  </p>\n<blockquote>\n<p id=\"so_34360286_34360286_0\">An <em>integral constant expression</em> is an expression of integral or\n  unscoped enumeration type, implicitly converted to a prvalue, where\n  the converted expression is a core constant expression. [ Note: Such\n  expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field\n  lengths (9.6), as enumerator initializers if the underlying type is\n  not fixed (7.2), and as alignments (7.6.2). \u2014end note ] A <em>converted\n  constant expression</em> of type <code>T</code> is an expression, implicitly\n  converted to a prvalue of type <code>T</code>, where the converted expression is\n  a core constant expression and the implicit conversion sequence\n  contains only user-defined conversions, lvalue-to-rvalue conversions\n  (4.1), integral promotions (4.5), and integral conversions (4.7) other\n  than narrowing conversions (8.5.4). [ Note: such expressions may be\n  used in <code>new</code> expressions (5.3.4), as <code>case</code> expressions (6.4.2), as\n  enumerator initializers if the underlying type is fixed (7.2), as\n  array bounds (8.3.4), and as integral or enumeration non-type template\n  arguments (14.3). \u2014end note ]</p>\n</blockquote>\n<p>Maybe I'm missing something, but my first impression is that every <em>integral constant expression</em> is a <em>converted constant expression</em>.</p>\n<p><strong>Edit</strong> </p>\n<p>And I also believe there is an error in this paragraph:</p>\n<p>Instead of:  </p>\n<p><code>A converted constant expression of type T is an expression, implicitly converted to a prvalue of type T, ...</code></p>\n<p>it should be:</p>\n<p><code>A converted constant expression of type T is an expression, implicitly converted to a prvalue of an integral type, ...</code></p>\n<p>And this change allows the following code to compile:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A { operator int() { return 5; } } a;\n\nint main() {\n    int b[a]{ 0, 1, 2, 3, 4 };\n    std::cout &lt;&lt; b[4] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>where <code>a</code> in the declaration <code>int b[a]{ 0, 1, 2, 3, 4};</code> is a <em>converted constant expression</em> of type <code>A</code>, implicitly converted to a prvalue of integral type (<code>int</code>) where the converted expression <code>5</code> is a <em>core constant expression</em>, and the implicit conversion sequence contains only a user-defined conversion.</p>\n", "Tags": "<c++><language-lawyer><c++14><constexpr>", "OwnerUserId": "411165", "AnswerCount": "3"}, "34594252": {"ParentId": "34360286", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After discussion of answers provided by Jerry Coffin and cpplearner, let me propose to rewrite those damn rules, like this:</p>\n<p><strong>[expr.const] 5.20\\3 (modified)</strong></p>\n<blockquote>\n<p id=\"so_34360286_34594252_0\">An <em>integral constant expression</em> is an expression of integral or unscoped enumeration type, that is implicitly converted to a prvalue core constant expression of the same type such that the implicit conversion sequence contains only an lvalue-to-rvalue conversion.</p>\n</blockquote>\n<p><strong>[expr.const] 5.20\\4 (modified)</strong></p>\n<blockquote>\n<p id=\"so_34360286_34594252_1\">A <em>converted constant expression</em> of type T is an expression of any\n  type, that is implicitly converted to a constant expression of type T\n  such that the implicit conversion sequence contains only:</p>\n<ul>\n<li>user-defined conversions,</li>\n<li>lvalue-to-rvalue conversions,</li>\n<li>array-to-pointer conversions, </li>\n<li>function-to-pointer conversions,</li>\n<li>qualification conversions,</li>\n<li>integral promotions,</li>\n<li>integral conversions other than narrowing conversions,</li>\n<li>null pointer conversions from <code>std::nullptr_t</code>, </li>\n<li>null member pointer conversions from <code>std::nullptr_t</code>, and </li>\n<li>function pointer conversions,</li>\n</ul>\n<p id=\"so_34360286_34594252_2\">and where the reference binding (if any) binds directly. [ Note: such\n  expressions may be used in <code>new</code> expressions, as case expressions, as\n  enumerator initializers if the underlying type is fixed, as array\n  bounds, and as non-type template arguments.  \u2014 end note ]</p>\n</blockquote>\n<p>Now the difference is obvious, uh? Also it should be reminded that according to 5.20\\7; 4\\5 an expression of literal class type may be used instead of integral constant expression in some cases.</p>\n", "OwnerUserId": "5181494", "LastEditorUserId": "5181494", "LastEditDate": "2016-01-04T15:30:03.120", "Id": "34594252", "Score": "0", "CreationDate": "2016-01-04T15:17:06.377", "LastActivityDate": "2016-01-04T15:30:03.120"}, "34360690": {"ParentId": "34360286", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Both definitions are needed because there are things you can do with one but not the other. And no, not every <em>integral constant expression</em> is really a <em>converted constant expression</em>. For the obvious example, a <em>converted constant expression</em> prohibits narrowing conversions, but an <em>integral constant expression</em> doesn't. </p>\n<p>Therefore I can't do this:</p>\n<pre><code>enum x : char { a = 1024 };\n</code></pre>\n<p>If, however the initializer for an enum allowed an <em>integral constant expression</em>, rather than a <em>converted constant expression</em>, precisely that would be allowed.</p>\n<p>As a Venn diagram, I'd draw the situation something like this:</p>\n<p><a href=\"https://i.stack.imgur.com/q1FT3.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/q1FT3.png\"/></a></p>\n<p>So, there is quite a bit of overlap between the two (probably more than this diagram implies) but each allows at least a few things the other doesn't. I've given an example of one item in each direction, but haven't tried to list the differences exhaustively.</p>\n<p>I'm not entirely convinced about user-defined conversions being prohibited for integral constant expressions though (and a quick test shows that the compilers I have handy at the moment allow them). That would give the situation as I originally wrote this answer, which would be more like this:</p>\n<p><a href=\"https://i.stack.imgur.com/1LbeL.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/1LbeL.png\"/></a></p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-12-18T18:01:06.477", "Id": "34360690", "Score": "11", "CreationDate": "2015-12-18T17:14:30.363", "LastActivityDate": "2015-12-18T18:01:06.477"}, "34577436": {"ParentId": "34360286", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><sub>Note: this answer is based on the latest draft standard for now, known as N4567. Some differences between it and the C++11/14 standard are pointed out.</sub></p>\n<p><em>integral constant expression</em> and <em>converted constant expression</em> are different when class types are concerned. In C++98/03, when class types could not be used here (because there were no <code>constexpr</code> conversion functions at that time), there was indeed no such term as <em>converted constant expression of type <code>T</code></em>.</p>\n<p>For an <em>integral constant expression</em>, the destination type is unknown. But for a <em>converted constant expression of type <code>T</code></em>, the destination type is known to be <code>T</code>, and <code>T</code> is not necessarily an integral or unscoped enumeration type<sup>1</sup>.</p>\n<p>So, in order to compile a <em>integral constant expression</em>, the compiler first need to decide what the destination type is. If the expression has integral or unscoped enumeration type, then obviously the destination type is just the type of the expression. Otherwise, if the expression has a literal class type (let's call this type <code>E</code>), then the following process is used<sup>2</sup>:</p>\n<p>The compiler examines all the non-explicit conversion functions in <code>E</code><sup>3</sup>. Let's say the result types of these functions forms a set <code>S</code>. If <code>S</code> contains exactly one integral or unscoped enumeration type (reference modifier is stripped and <code>const</code> and <code>volatile</code> qualifiers are ignored: <code>const volatile int&amp;</code> is considered as <code>int</code> in this process), then the destination type is just that type. Otherwise, the determination fails.</p>\n<p>(It is important to note that in the aforementioned process, conversion function templates are not examined. )</p>\n<p><strong>As a consequence, for example, if a class type has two conversion functions, one is <code>constexpr operator int</code> and the other is <code>constexpr operator long</code>, then this type cannot be used in a <em>integral constant expression</em> (the destination type is undecidable). However, such type may be used in a <em>converted constant expression of type <code>int</code></em> or in a <em>converted constant expression of type <code>long</code></em>.</strong></p>\n<p>After deciding the destination type <code>D</code>, then overload resolution is applied to find the most appropriate conversion function or function template, and then the choosen conversion function (which must be <code>constexpr</code>) is called to produce a value of type <code>D</code>. \u2014 This part is, more or less, the same as a <em>converted constant expression of type <code>D</code></em>.</p>\n<p>In the following example, <code>Var{}</code> is a valid <em>integral constant expression</em>, but is an invalid <em>converted constant expression of type <code>std::size_t</code></em> (the example is inspired by <a href=\"https://stackoverflow.com/questions/25047109/classes-with-both-template-and-non-template-conversion-operators-in-the-conditio\">this question</a>).</p>\n<pre><code>class Var\n{\npublic:\n\n    constexpr operator int ()\n    { return 42; }\n\n    template &lt;typename T&gt;\n    constexpr operator T () = delete;\n};\n\nenum {\n    x = Var{} // the initializer of `x` is expected to be an \n              // integral constant expression\n              // x has value 42\n};\n\nint t[ Var{} ]; // the array bound is expected to be a\n                // converted constant expression of type std::size_t\n                // this declaration is ill-formed\n</code></pre>\n<h2>References</h2>\n<p>N4567 5.20 [expr.const]p7</p>\n<blockquote>\n<p id=\"so_34360286_34577436_0\">If an expression of literal class type is used in a context where an integral constant expression is required,\n  then that expression is contextually implicitly converted (Clause 4) to an integral or unscoped enumeration\n  type and the selected conversion function shall be <code>constexpr</code>.</p>\n</blockquote>\n<p>N4567 4[conv]p5</p>\n<blockquote>\n<p id=\"so_34360286_34577436_1\">Certain language constructs require conversion to a value having one of a speci\ufb01ed set of types appropriate to the construct. An expression <code>e</code> of class type <code>E</code> appearing in such a context is said to be <em>contextually implicitly converted</em> to a speci\ufb01ed type <code>T</code> and is well-formed if and only if <code>e</code> can be implicitly converted to a type <code>T</code> that is determined as follows: <code>E</code> is searched for non-explicit conversion functions whose return type is <em>cv</em> <code>T</code> or reference to <em>cv</em> <code>T</code> such that <code>T</code> is allowed by the context. There shall be exactly one such <code>T</code>.</p>\n</blockquote>\n<h2>Notes</h2>\n<ol>\n<li>In C++11/14, a converted constant expression could only be of integral or enumeration type. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"nofollow noreferrer\">N4268</a> changes that.</li>\n<li>In C++11, there were no such process, instead, it is required that \"the class type shall have a single non-explicit conversion function to an integral or enumeration type and that conversion function shall be <code>constexpr</code>.\" <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf\" rel=\"nofollow noreferrer\">N3323</a> changed that to the current wording.</li>\n<li>The word \"non-explicit\" did not exist in the C++14 standard. It was added by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1981\" rel=\"nofollow noreferrer\">CWG 1981</a>.</li>\n</ol>\n", "OwnerUserId": "4672588", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:05.260", "Id": "34577436", "Score": "3", "CreationDate": "2016-01-03T14:12:02.677", "LastActivityDate": "2016-01-05T17:06:37.083"}});