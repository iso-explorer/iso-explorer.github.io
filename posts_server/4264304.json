post_cb({"4264376": {"ParentId": "4264304", "CommentCount": "0", "Body": "<p>Well if you want to return your array from a function you must make sure that the values are not stored on the stack as they will be gone when you leave the function.</p>\n<p>So either make your array static or allocate the memory (or pass it in but your initial attempt is with a void parameter). For your method I would define it like this:</p>\n<pre><code>int *gnabber(){\n  static int foo[] = {1,2,3}\n  return foo;\n}\n</code></pre>\n", "OwnerUserId": "297303", "PostTypeId": "2", "Id": "4264376", "Score": "2", "CreationDate": "2010-11-24T07:27:58.750", "LastActivityDate": "2010-11-24T07:27:58.750"}, "28853311": {"ParentId": "4264304", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_4264304_28853311_0\">\"how can i return a array in a c++ method and how must i declare it?\n  int[] test(void); ??\"</p>\n</blockquote>\n<pre><code>template &lt;class X&gt;\n  class Array\n{\n  X     *m_data;\n  int    m_size;\npublic:\n    // there constructor, destructor, some methods\n    int Get(X* &amp;_null_pointer)\n    {\n        if(!_null_pointer)\n        {\n            _null_pointer = new X [m_size];\n            memcpy(_null_pointer, m_data, m_size * sizeof(X));\n            return m_size;\n        }\n       return 0;\n    }\n}; \n</code></pre>\n<p>just for int</p>\n<pre><code>class IntArray\n{\n  int   *m_data;\n  int    m_size;\npublic:\n    // there constructor, destructor, some methods\n    int Get(int* &amp;_null_pointer)\n    {\n        if(!_null_pointer)\n        {\n            _null_pointer = new int [m_size];\n            memcpy(_null_pointer, m_data, m_size * sizeof(int));\n            return m_size;\n        }\n       return 0;\n    }\n}; \n</code></pre>\n<p>example</p>\n<pre><code>Array&lt;float&gt; array;\nfloat  *n_data = NULL;\nint     data_size;\nif(data_size = array.Get(n_data))\n{     // work with array    }\n\ndelete [] n_data;\n</code></pre>\n<p>example for int</p>\n<pre><code>IntArray   array;\nint       *n_data = NULL;\nint        data_size;\nif(data_size = array.Get(n_data))\n{  // work with array  }\n\ndelete [] n_data;\n</code></pre>\n", "OwnerUserId": "4631898", "PostTypeId": "2", "Id": "28853311", "Score": "-1", "CreationDate": "2015-03-04T11:30:01.453", "LastActivityDate": "2015-03-04T11:30:01.453"}, "4264314": {"ParentId": "4264304", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>int* test();</code></p>\n<p>but it would be \"more C++\" to use vectors:</p>\n<p><code>std::vector&lt; int &gt; test();</code></p>\n<p><strong>EDIT</strong><br>\nI'll clarify some point. Since you mentioned C++, I'll go with <code>new[]</code> and <code>delete[]</code> operators, but it's the same with malloc/free.</br></p>\n<p>In the first case, you'll write something like:</p>\n<pre><code>int* test() {\n    return new int[size_needed];\n}\n</code></pre>\n<p>but it's not a nice idea because your function's client doesn't really know the size of the array you are returning, although the client can safely deallocate it with a call to <code>delete[]</code>.</p>\n<pre><code>int* theArray = test();\nfor (size_t i; i &lt; ???; ++i) { // I don't know what is the array size!\n    // ...\n}\ndelete[] theArray; // ok.\n</code></pre>\n<p>A better signature would be this one:</p>\n<pre><code>int* test(size_t&amp; arraySize) {\n    array_size = 10;\n    return new int[array_size];\n}\n</code></pre>\n<p>And your client code would now be:</p>\n<pre><code>size_t theSize = 0;\nint* theArray = test(theSize);\nfor (size_t i; i &lt; theSize; ++i) { // now I can safely iterate the array\n    // ...\n}\ndelete[] theArray; // still ok.\n</code></pre>\n<p>Since this is C++, `std::vector&lt; T &gt; is a widely-used solution:</p>\n<pre><code>std::vector&lt;int&gt; test() {\n    std::vector&lt;int&gt; vector(10);\n    return vector;\n}\n</code></pre>\n<p>Now you don't have to call <code>delete[]</code>, since it will be handled by the object, and you can safely iterate it with:</p>\n<pre><code>std::vector&lt;int&gt; v = test();\nstd::vector&lt;int&gt;::iterator it = v.begin();\nfor (; it != v.end(); ++it) {\n   // do your things\n}\n</code></pre>\n<p>which is easier and safer.</p>\n", "OwnerUserId": "347137", "LastEditorUserId": "1757964", "LastEditDate": "2017-07-21T18:28:15.737", "Id": "4264314", "Score": "54", "CreationDate": "2010-11-24T07:18:16.800", "LastActivityDate": "2017-07-21T18:28:15.737"}, "4264449": {"ParentId": "4264304", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_4264304_4264449_0\">how can i return a array in a c++ method and how must i declare it? int[] test(void); ??</p>\n</blockquote>\n<p>This sounds like a simple question, but in C++ you have quite a few options.  Firstly, you should prefer...</p>\n<ul>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"noreferrer\"><code>std::vector&lt;&gt;</code></a>, which grows dynamically to however many elements you encounter at runtime, or</p></li>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"noreferrer\"><code>std::array&lt;&gt;</code></a> (introduced with C++11), which always stores a number of elements specified at compile time,</p></li>\n</ul>\n<p>...as they manage memory for you, ensuring correct behaviour and simplifying things considerably:</p>\n<pre><code>std::vector&lt;int&gt; fn()\n{\n    std::vector&lt;int&gt; x;\n    x.push_back(10);\n    return x;\n}\n\nstd::array&lt;int, 2&gt; fn2()  // C++11\n{\n    return {3, 4};\n}\n\nvoid caller()\n{\n    std::vector&lt;int&gt; a = fn();\n    const std::vector&lt;int&gt;&amp; b = fn(); // extend lifetime but read-only\n                                      // b valid until scope exit/return\n\n    std::array&lt;int, 2&gt; c = fn2();\n    const std::array&lt;int, 2&gt;&amp; d = fn2();\n}\n</code></pre>\n<p>The practice of creating a <code>const</code> reference to the returned data can sometimes avoid a copy, but normally you can just rely on Return Value Optimisation, or - for <code>vector</code> but not <code>array</code> - move semantics (introduced with C++11).</p>\n<p>If you really want to use an <em>inbuilt</em> array (as distinct from the Standard library class called <code>array</code> mentioned above), one way is for the caller to reserve space and tell the function to use it:</p>\n<pre><code>void fn(int x[], int n)\n{\n    for (int i = 0; i &lt; n; ++i)\n        x[i] = n;\n}\n\nvoid caller()\n{\n    // local space on the stack - destroyed when caller() returns\n    int x[10];\n    fn(x, sizeof x / sizeof x[0]);\n\n    // or, use the heap, lives until delete[](p) called...\n    int* p = new int[10];\n    fn(p, 10);\n}\n</code></pre>\n<p>Another option is to wrap the array in a structure, which - unlike raw arrays - are legal to return by value from a function:</p>\n<pre><code>struct X\n{\n    int x[10];\n};\n\nX fn()\n{\n    X x;\n    x.x[0] = 10;\n    // ...\n    return x;\n}\n\nvoid caller()\n{\n    X x = fn();\n}\n</code></pre>\n<p>Starting with the above, if you're stuck using C++03 you might want to generalise it into something closer to the C++11 <code>std::array</code>:</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nstruct array\n{\n    T&amp; operator[](size_t n) { return x[n]; }\n    const T&amp; operator[](size_t n) const { return x[n]; }\n    size_t size() const { return N; }\n    // iterators, constructors etc....\n  private:\n    T x[N];\n};\n</code></pre>\n<p>Another option is to have the called function allocate memory on the heap:</p>\n<pre><code>int* fn()\n{\n    int* p = new int[2];\n    p[0] = 0;\n    p[1] = 1;\n    return p;\n}\n\nvoid caller()\n{\n    int* p = fn();\n    // use p...\n    delete[] p;\n}\n</code></pre>\n<p>To help simplify the management of heap objects, many C++ programmers use \"smart pointers\" that ensure deletion when the pointer(s) to the object leave their scopes.  With C++11:</p>\n<pre><code>std::shared_ptr&lt;int&gt; p(new int[2], [](int* p) { delete[] p; } );\nstd::unique_ptr&lt;int[]&gt; p(new int[3]);\n</code></pre>\n<p>If you're stuck on C++03, the best option is to see if the boost library is available on your machine: it provides <code>boost::shared_array</code>.</p>\n<p>Yet another option is to have some static memory reserved by <code>fn()</code>, though this is NOT THREAD SAFE, and means each call to <code>fn()</code> overwrites the data seen by anyone keeping pointers from previous calls.  That said, it can be convenient (and fast) for simple single-threaded code.</p>\n<pre><code>int* fn(int n)\n{\n    static int x[2];  // clobbered by each call to fn()\n    x[0] = n;\n    x[1] = n + 1;\n    return x;  // every call to fn() returns a pointer to the same static x memory\n}\n\nvoid caller()\n{\n    int* p = fn(3);\n    // use p, hoping no other thread calls fn() meanwhile and clobbers the values...\n    // no clean up necessary...\n}\n</code></pre>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2016-04-18T00:27:14.280", "Id": "4264449", "Score": "16", "CreationDate": "2010-11-24T07:37:45.917", "LastActivityDate": "2016-04-18T00:27:14.280"}, "4264304": {"CommentCount": "0", "AcceptedAnswerId": "4264314", "PostTypeId": "1", "ClosedDate": "2017-11-02T22:33:13.617", "LastEditorUserId": "3552770", "CreationDate": "2010-11-24T07:16:26.070", "LastActivityDate": "2017-07-21T18:28:15.737", "LastEditDate": "2015-09-01T18:32:31.363", "ViewCount": "135080", "FavoriteCount": "14", "Title": "How to return an array from a function?", "Id": "4264304", "Score": "39", "Body": "<p>How can I return an array from a method, and how must I declare it?</p>\n<pre><code>int[] test(void); // ??\n</code></pre>\n", "Tags": "<c++><arrays><method-signature>", "OwnerUserId": "515168", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4264304_4264495_0": {"section_id": 3244, "quality": 1.0, "length": 7}}, "n3337": {"so_4264304_4264495_0": {"section_id": 3117, "quality": 1.0, "length": 7}}, "n4659": {"so_4264304_4264495_0": {"section_id": 4002, "quality": 1.0, "length": 7}}}, "4264495": {"ParentId": "4264304", "CommentCount": "0", "Body": "<p>It is not possible to return an array from a C++ function. 8.3.5[dcl.fct]/6:</p>\n<blockquote>\n<p id=\"so_4264304_4264495_0\">Functions shall not have a return type of type array or function[...]</p>\n</blockquote>\n<p>Most commonly chosen alternatives are to return a value of class type where that class contains an array, e.g.</p>\n<pre><code>struct ArrayHolder\n{\n    int array[10];\n};\n\nArrayHolder test();\n</code></pre>\n<p>Or to return a pointer to the first element of a statically or dynamically allocated array, the documentation must indicate to the user whether he needs to (and if so how he should) deallocate the array that the returned pointer points to.</p>\n<p>E.g.</p>\n<pre><code>int* test2()\n{\n    return new int[10];\n}\n\nint* test3()\n{\n    static int array[10];\n    return array;\n}\n</code></pre>\n<p>While it is possible to return a reference or a pointer to an array, it's exceedingly rare as it is a more complex syntax with no practical advantage over any of the above methods.</p>\n<pre><code>int (&amp;test4())[10]\n{\n        static int array[10];\n        return array;\n}\n\nint (*test5())[10]\n{\n        static int array[10];\n        return &amp;array;\n}\n</code></pre>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "4264495", "Score": "9", "CreationDate": "2010-11-24T07:47:28.993", "LastActivityDate": "2010-11-24T07:47:28.993"}});