post_cb({"bq_ids": {"n4140": {"so_18432894_18432953_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 557}}, "n3337": {"so_18432894_18432953_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 548}}, "n4659": {"so_18432894_18432953_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 580}}}, "18432953": {"Id": "18432953", "PostTypeId": "2", "Body": "<p>You can overload functions on the r-valueness of <code>*this</code>. For example:</p>\n<pre><code>class A\n{\npublic:\n    // ... \n    A changed() const&amp;; // called for l-values\n    A changed() &amp;&amp;;     // called for r-values\n};\n</code></pre>\n<p>You cannot overload a version without reference qualification with one having reference qualifcations, though. See 13.1 [over.load] paragraph 2, third bullet:</p>\n<blockquote>\n<p id=\"so_18432894_18432953_0\">Member function declarations with the same name and the same parameter-type-list as well as member function template declarations with the same name, the same parameter-type-list, and the same template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualifier (8.3.5).</p>\n</blockquote>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2013-08-25T19:48:38.240", "Score": "4", "CreationDate": "2013-08-25T19:42:18.543", "ParentId": "18432894", "CommentCount": "6", "OwnerUserId": "1120273", "LastEditDate": "2013-08-25T19:48:38.240"}, "18432930": {"Id": "18432930", "PostTypeId": "2", "Body": "<p>Yes, you need to declare <code>A changed() &amp;&amp;;</code>. This overload will be available when the instance is an rvalue.</p>\n<pre><code>struct A\n{ \n    void foo() &amp;  { }\n    void foo() &amp;&amp; { }\n};\n\nint main()\n{\n    A x;\n    x.foo();             // picks first overload\n    std::move(x).foo();  // picks second overload\n    A().foo();           // \"typical\" use case for second overload\n}\n</code></pre>\n<p>This new language feature may not be supported by all compilers yet.</p>\n", "LastActivityDate": "2013-08-25T19:39:44.787", "CommentCount": "0", "CreationDate": "2013-08-25T19:39:44.787", "ParentId": "18432894", "Score": "3", "OwnerUserId": "596781"}, "18432894": {"ViewCount": "51", "Body": "<p>Is it possible to create method that will work differently when object <code>*this</code> is actually a temporary?</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct BigObj{\n    void changeFast() {}\n};\n\nclass A {\n    BigObj obj;\npublic:\n    A(){}\n    A(const A&amp; a) {\n        obj = a.obj;\n        std::cout &lt;&lt; \"copy\\n\";\n    }\n    A(A&amp;&amp; a) {\n        obj = std::move(a.obj);\n        std::cout &lt;&lt; \"move\\n\";\n    }\n    A changed() {\n        A ret = *this; //(1)\n        ret.obj.changeFast();\n        return ret;\n    }\n};\n\nint main(){\n    A a;\n    A b = std::move(a).changed();\n    (void)b;\n    return 0;\n}\n</code></pre>\n<p>In line (1) we have copy but it's not really needed. But we can't always move here because sometimes method called on not-temporary. What should one do to avoid copy here?</p>\n<p>If it was not method but just function one may write to similar functions:</p>\n<pre><code>A changed(const A&amp; a){\n}\n\nA changed(A&amp;&amp; a){\n}\n</code></pre>\n", "AcceptedAnswerId": "18432953", "Title": "Move semantic and temporary implicit this", "CreationDate": "2013-08-25T19:35:06.017", "Id": "18432894", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-08-25T19:48:38.240", "Score": "3", "OwnerUserId": "768110", "Tags": "<c++><optimization><methods><move-semantics>", "AnswerCount": "2"}});