post_cb({"12399628": {"CommentCount": "2", "ViewCount": "191", "PostTypeId": "1", "LastEditorUserId": "1667325", "CreationDate": "2012-09-13T04:56:43.507", "LastActivityDate": "2012-09-13T12:14:08.650", "Title": "Multidimensional dynamic arrays, Why doesn't it work?", "FavoriteCount": "2", "LastEditDate": "2012-09-13T06:43:33.283", "Id": "12399628", "Score": "4", "Body": "<p>I'm not looking for a solution here, I've found plenty on Google. I'm looking for an explanation.  </p>\n<p>While playing with arrays I found that declaring a 2D array dynamically doesn't work like expected  </p>\n<p><strong>1D Array, Works</strong></p>\n<pre><code>int main()\n{\nint rows;\nint* pointer;\npointer = new int[rows]; \n}\n</code></pre>\n<p><strong>2D Array, Doesn't Work</strong></p>\n<pre><code>int main()\n{\nint rows;\nint columns;\nint* pointer;\npointer = new int[rows][columns]; //error on this line\n}\n</code></pre>\n<p>This seems to me like the intuitive way of doing things because that's how its done with regular arrays, but apparently its incorrect and won't compile.</p>\n<p>I haven't been able to find a clear explanation of WHY this is the case, hopefully someone here can enlighten me.</p>\n<p>Thanks :) </p>\n", "Tags": "<c++><arrays><pointers>", "OwnerUserId": "1667325", "AnswerCount": "5"}, "12399812": {"ParentId": "12399628", "CommentCount": "0", "Body": "<p><strong>This is not only a problem of the data type as described by the other answers.</strong></p>\n<p>A syntax like</p>\n<pre><code>pointer = new int[rows][columns]\n</code></pre>\n<p>is only valid if <code>columns</code> is a constant expression. You can't use a variable there (but note that <code>rows</code> can be a variable).</p>\n<p>Here is the explanation. The C++ Standard enables you to use two-dimensional-array syntax with the <code>new</code> operator in the following way only (from \u00a75.3.4/1):</p>\n<pre><code>new-expression:\n  ::opt new new-placementopt new-type-id new-initializeropt\n  ::opt new new-placementopt ( type-id ) new-initializeropt\nnew-placement:\n  ( expression-list )\nnew-type-id:\n  type-specifier-seq new-declaratoropt\nnew-declarator:\n  ptr-operator new-declaratoropt\n  noptr-new-declarator\nnoptr-new-declarator:\n  [ expression ] attribute-specifier-seqopt\n  noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt\nnew-initializer:\n  ( expression-listopt )\n  braced-init-list\n</code></pre>\n<p><strong>The relevant part</strong> is this:</p>\n<pre><code>noptr-new-declarator:\n  [ expression ] attribute-specifier-seqopt\n  noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt\n</code></pre>\n<p>The first line means you can have one bracketed <em>expression</em> after the type-id. The second line (which is a recursive statement) allows you to use multiple pairs of brackets after the initial one, but they must enclose a <em>constant expression</em>.</p>\n<p>The Standard explains this further (emphasis mine):</p>\n<blockquote>\n<p id=\"so_12399628_12399812_0\">(\u00a75.3.4/5) When the allocated object is an array (that is, the noptr-new-declarator syntax is used or the new-type-id or type-id denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array. [ <strong>Note: both new int and new int[10] have type int* and the type of new int[i][10] is int (*)[10]</strong> \u2014 end note ] The attribute-specifier-seq in a noptr-new-declarator appertains to the associated array type.</p>\n<p id=\"so_12399628_12399812_1\">(\u00a75.3.4/6) Every constant-expression in a noptr-new-declarator shall be an integral constant expression (5.19) and evaluate to a strictly positive value. The expression in a noptr-new-declarator shall be of integral type, unscoped enumeration type, or a class type for which a single non-explicit conversion function to integral or unscoped enumeration type exists (12.3). [...] [ Example: <strong>Given the definition int n = 42, new float[n][5] is well-formed (because n is the expression of a noptr-new-declarator), but new float[5][n] is ill-formed (because n is not a constant expression).</strong> \u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "12399812", "Score": "4", "CreationDate": "2012-09-13T05:15:59.047", "LastActivityDate": "2012-09-13T05:15:59.047"}, "12399785": {"ParentId": "12399628", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Other people have explained it well, but here is an example that may shed light on creating dynamically sized multi-dimensional arrays using <code>new</code>:</p>\n<pre><code>int rows = 20;\nint columns = 30;\n\n// the following is essentially just an array of int pointers\nint **pointer = new int*[rows]; \n\n// so, loop through the array creating the second dimension\nfor (int i = 0;i &lt; rows;i++)\n    pointer[i] = new int[columns];\n</code></pre>\n", "OwnerUserId": "63950", "LastEditorUserId": "63950", "LastEditDate": "2012-09-13T05:23:19.343", "Id": "12399785", "Score": "0", "CreationDate": "2012-09-13T05:13:03.520", "LastActivityDate": "2012-09-13T05:23:19.343"}, "bq_ids": {"n4140": {"so_12399628_12399812_0": {"section_id": 6086, "quality": 0.875, "length": 35}}, "n3337": {"so_12399628_12399812_1": {"section_id": 5855, "quality": 0.8431372549019608, "length": 43}, "so_12399628_12399812_0": {"section_id": 5854, "quality": 0.875, "length": 35}}, "n4659": {"so_12399628_12399812_1": {"section_id": 7583, "quality": 0.5294117647058824, "length": 27}, "so_12399628_12399812_0": {"section_id": 7582, "quality": 0.85, "length": 34}}}, "12399681": {"ParentId": "12399628", "CommentCount": "1", "Body": "<p>The reason this doesnt work is because to be able to have a two dimensional array you need one array of pointers which will point to many arrays of the type you want. </p>\n<p>In this case you're trying to store the address to an array of int* (of which each \"cell\" will point to an array of ints) in a variable of type int*, it should be int**.</p>\n<p>To recap:\n1D array: int*\n2D array: int**\n3D array: int***</p>\n<p>The reason all arrays must be one dimensional is because your memory is one dimensional (think of all the memory as being one big array of memory addresses) which means multiple dimension arrays must be \"faked\".</p>\n", "OwnerUserId": "583833", "PostTypeId": "2", "Id": "12399681", "Score": "6", "CreationDate": "2012-09-13T05:03:11.043", "LastActivityDate": "2012-09-13T05:03:11.043"}, "12400241": {"ParentId": "12399628", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is a one dimensional char pointer array : <code>char* Dynamic_One_Dimensional_Char_Pointer_Array</code>. Notice the <code>char *</code>.</p>\n<p>This is a two dimensional char pointer array : <code>char **Dynamic_Two_Dimensional_Char_Pointer_Array</code>. Notice the <code>char **</code>.</p>\n<p>This is how you allocate memory for a a two dimensional char pointer array : </p>\n<pre><code>    //memory allocated for elements of rows.\n    Dynamic_Two_Dimensional_Char_Pointer_Array = new char *[ROWS] ;\n\n    //memory allocated for  elements of each column.\n    for(   i = 0 ; i &lt; ROWS ; i++ ) Dynamic_Two_Dimensional_Char_Pointer_Array[i] = new char[COLUMNS];\n</code></pre>\n<p>This is how to print the 2D array  (<code>[rows][columns]</code>) :</p>\n<pre><code>   for(rows=0;rows&lt;maxLines;rows++)\n   {\n       for(int columns=0;columns&lt;strlen(Dynamic_Two_Dimensional_Char_Pointer_Array[rows]);columns++)\n       {\n            cout&lt;&lt;Dynamic_Two_Dimensional_Char_Pointer_Array[rows][columns]&lt;&lt;\"\";\n       }\n       cout&lt;&lt;\"  \\n\";\n   }\n</code></pre>\n<p>his is how you de-allocate memory for a a two dimensional char pointer array : </p>\n<pre><code>//free the allocated memory\nfor(   i = 0 ; i &lt; ROWS ; i++ )   delete [] Dynamic_Two_Dimensional_Char_Pointer_Array[i] ;\ndelete [] Dynamic_Two_Dimensional_Char_Pointer_Array ;\n</code></pre>\n<p>Full sample code:</p>\n<pre><code>#include&lt;vector&gt;\n#include&lt;string&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\n    int COLUMNS =80; //80 characters wide\n    int ROWS =20;// 20 lines\n    int i,maxLines=0;\n\n    char* Dynamic_One_Dimensional_Char_Pointer_Array = new char[80];\n    char **Dynamic_Two_Dimensional_Char_Pointer_Array = 0;\n\n    //memory allocated for elements of rows.\n    Dynamic_Two_Dimensional_Char_Pointer_Array = new char *[ROWS] ;\n\n    //memory allocated for  elements of each column.\n    for(   i = 0 ; i &lt; ROWS ; i++ ) Dynamic_Two_Dimensional_Char_Pointer_Array[i] = new char[COLUMNS];\n\n\n    strcpy(Dynamic_One_Dimensional_Char_Pointer_Array,\"apples 123 oranges 456 bananas 789 lemons 101112 kiwi 132415 grapes 161718\" );\n    cout&lt;&lt;\"  \\ninput = \"&lt;&lt;Dynamic_One_Dimensional_Char_Pointer_Array&lt;&lt;\"  \\n\\n\";\n    cout&lt;&lt;\"Output = \\n\";\n\n    char seperators[]   = \" ,\\t\\n\";\n    char *token; \n   token = strtok( Dynamic_One_Dimensional_Char_Pointer_Array, seperators );  \n   i=0;\n\n   while( token != NULL )\n   {\n      strcpy(Dynamic_Two_Dimensional_Char_Pointer_Array[i],token);\n      token = strtok( NULL, seperators );  \n      i++;\n   }\n   maxLines=i;\n   cout&lt;&lt;\"  \\n\";\n\n   cout&lt;&lt;\"show contents 1 print [rows] \\n\";\n   cout&lt;&lt;\"-------------------------------------------\\n\";\n   for(int rows=0;rows&lt;maxLines;rows++)\n   {\n     cout&lt;&lt;Dynamic_Two_Dimensional_Char_Pointer_Array[rows]&lt;&lt;\"  \\n\";\n   }\n   cout&lt;&lt;\"  \\n\";\n\n   cout&lt;&lt;\"show contents 2  print [rows][columns]\\n\";\n   cout&lt;&lt;\"-------------------------------------------\\n\";\n\n   for(rows=0;rows&lt;maxLines;rows++)\n   {\n     //cout&lt;&lt;Dynamic_Two_Dimensional_Char_Pointer_Array[rows]&lt;&lt;\"  \\n\";\n       for(int columns=0;columns&lt;strlen(Dynamic_Two_Dimensional_Char_Pointer_Array[rows]);columns++)\n       {\n            cout&lt;&lt;Dynamic_Two_Dimensional_Char_Pointer_Array[rows][columns]&lt;&lt;\"\";\n       }\n       cout&lt;&lt;\"  \\n\";\n   }\n\n\n\n    delete[] Dynamic_One_Dimensional_Char_Pointer_Array;\n\n    //free the allocated memory\n    for(   i = 0 ; i &lt; ROWS ; i++ )   delete [] Dynamic_Two_Dimensional_Char_Pointer_Array[i] ;\n    delete [] Dynamic_Two_Dimensional_Char_Pointer_Array ;\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "999884", "LastEditorUserId": "999884", "LastEditDate": "2012-09-13T12:14:08.650", "Id": "12400241", "Score": "0", "CreationDate": "2012-09-13T05:58:58.340", "LastActivityDate": "2012-09-13T12:14:08.650"}, "12399660": {"ParentId": "12399628", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Well you can understand it in following manner:</p>\n<p>A 2-D array looks like a grid with row and columns for human representation but in memory it is stored in contiguous memory. So whenever you say a 2-D array or size <code>mxn</code> you are talking about <code>m</code> arrays of <code>n</code> elements each stored one after another. i.e. for a 3x3 grid elements are stored as :</p>\n<pre><code>(0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2)\n</code></pre>\n<p>If you want to access such data structure you need to use pointer to pointer i.e. a pointer to an array of addresses of location of the first element of every row.</p>\n<p>So the array can be accessed by means of 3 (number of rows) addresses</p>\n<pre><code>(Address of element 0,1) (Address of element 1,0) (Address of element 2,0)\n</code></pre>\n<p>Since address of elements are stored so now you need a pointer to pointer to access this array of pointers (holding addresses of first element of every row).</p>\n<p>For 1D array:</p>\n<pre><code>int* pointer = new int[3];\n\nArray: (0) (1) (2)\npointer: (Address of first element of Array)\n</code></pre>\n<p>For a 2D array:</p>\n<pre><code>int **pointer = new int[3][3];\n\nArray: (0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2)\nRow Address Array: (Address of 0,1) (Address of 1,0) (Address of 2,0)\npointer: (Address of first element of Row Address Array)\n</code></pre>\n<p>Hope this helps!</p>\n", "OwnerUserId": "185041", "LastEditorUserId": "185041", "LastEditDate": "2012-09-13T05:11:36.120", "Id": "12399660", "Score": "3", "CreationDate": "2012-09-13T05:00:48.383", "LastActivityDate": "2012-09-13T05:11:36.120"}});