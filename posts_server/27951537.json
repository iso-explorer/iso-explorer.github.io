post_cb({"27951537": {"CommentCount": "4", "ViewCount": "3352", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-01-14T20:09:23.067", "LastActivityDate": "2015-01-14T21:21:59.500", "Title": "How to convert unsigned char[] to std::vector<unsigned char>", "AcceptedAnswerId": "27951602", "LastEditDate": "2015-01-14T20:12:00.247", "Id": "27951537", "Score": "3", "Body": "<p>I am trying to pass this to another part of my project that requires it be a vector   </p>\n<pre><code>unsigned char vch[65];\n\nunsigned int size() const { return GetLen(vch[0]); }\nconst unsigned char* begin() const { return vch; }\nconst unsigned char* end() const { return vch + size(); \n\n\nstd::vector&lt;unsigned char&gt; Raw() const\n{\n        return (vch, vch + size());\n}\n</code></pre>\n<p>I get the error </p>\n<pre><code> could not convert '(const unsigned char*)(&amp;((const CPubKey*)this)-\nCPubKey::vch)' from 'const unsigned char*' to 'std::vector&lt;unsigned char*&gt;'\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "4454712", "AnswerCount": "2"}, "27951788": {"ParentId": "27951537", "CommentCount": "1", "Body": "<p>It is may not answering directly to the answer.</p>\n<p>But the question is why to use a vector when you can use  <code>std::string</code>, or <code>std::basic_string&lt;unsigned char&gt;</code> instead of std::vector, like this:</p>\n<pre><code>unsigned char a[]=\"1234\";\nstd::basic_string&lt;unsigned char&gt; v=a;\n</code></pre>\n", "OwnerUserId": "2852165", "PostTypeId": "2", "Id": "27951788", "Score": "0", "CreationDate": "2015-01-14T20:25:01.880", "LastActivityDate": "2015-01-14T20:25:01.880"}, "27951602": {"ParentId": "27951537", "PostTypeId": "2", "CommentCount": "5", "Body": "<pre><code>return (vch, vch + size());\n</code></pre>\n<p>This uses the comma operator - long story short, write</p>\n<pre><code>return std::vector&lt;unsigned char&gt;(vch, vch + size());\n</code></pre>\n<p>or</p>\n<pre><code>std::vector&lt;unsigned char&gt; vec(vch, vch + size())\nreturn vec;\n</code></pre>\n<p>instead. (The latter is semantically equivalent but preferable in terms of readability)\nOr with C++11:</p>\n<pre><code>return {vch, vch + size()};\n</code></pre>\n<p>This does work because a braced-init-list with pointers cannot be converted to <code>initializer_list&lt;unsigned char&gt;</code>. [over.match.list]/1:</p>\n<blockquote>\n<p id=\"so_27951537_27951602_0\">When objects of non-aggregate class type <code>T</code> are list-initialized such\n  that 8.5.4 specifies that overload resolution is performed according\n  to the rules in this section, overload resolution selects the\n  constructor in two phases:</p>\n<ul>\n<li><p id=\"so_27951537_27951602_1\">Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> [..]</p></li>\n<li><p id=\"so_27951537_27951602_2\"><strong>If no viable initializer-list constructor is found, overload resolution is performed again, where the\n     candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n    of the initializer list.</strong></p></li>\n</ul>\n</blockquote>\n<p>Now, is there a viable initializer-list constructor? [over.ics.list]:</p>\n<blockquote>\n<ol start=\"4\">\n<li>Otherwise, if the parameter type is <code>std::initializer_list&lt;X&gt;</code> <strong>and all the elements of the initializer list can be implicitly converted\n  to <code>X</code></strong>, [..]</li>\n</ol>\n<p id=\"so_27951537_27951602_3\">\u00a010. In all cases other than those enumerated above, <strong>no conversion is possible.</strong></p>\n</blockquote>\n<p>There is clearly no implicit conversion from <code>unsigned char*</code> to <code>unsigned char</code>, so the iterator-pair constructor template is chosen. <a href=\"http://coliru.stacked-crooked.com/a/8ffe0704f82d9574\" rel=\"noreferrer\"><strong>Demo</strong></a>.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-14T21:21:59.500", "Id": "27951602", "Score": "9", "CreationDate": "2015-01-14T20:12:55.887", "LastActivityDate": "2015-01-14T21:21:59.500"}, "bq_ids": {"n4140": {"so_27951537_27951602_3": {"section_id": 636, "quality": 1.0, "length": 9}, "so_27951537_27951602_0": {"section_id": 599, "quality": 0.5714285714285714, "length": 12}, "so_27951537_27951602_2": {"section_id": 599, "quality": 1.0, "length": 20}, "so_27951537_27951602_1": {"section_id": 599, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_27951537_27951602_3": {"section_id": 626, "quality": 1.0, "length": 9}, "so_27951537_27951602_0": {"section_id": 589, "quality": 0.5714285714285714, "length": 12}, "so_27951537_27951602_2": {"section_id": 589, "quality": 1.0, "length": 20}, "so_27951537_27951602_1": {"section_id": 589, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_27951537_27951602_3": {"section_id": 664, "quality": 1.0, "length": 9}, "so_27951537_27951602_0": {"section_id": 622, "quality": 0.9523809523809523, "length": 20}, "so_27951537_27951602_2": {"section_id": 622, "quality": 1.0, "length": 20}, "so_27951537_27951602_1": {"section_id": 622, "quality": 0.8571428571428571, "length": 6}}}});