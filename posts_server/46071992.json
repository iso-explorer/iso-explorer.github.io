post_cb({"bq_ids": {"n4140": {"so_46071992_46072220_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3296}, "so_46071992_46071992_0": {"length": 7, "quality": 1.0, "section_id": 481}, "so_46071992_46072220_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7040}}, "n3337": {"so_46071992_46072220_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3166}, "so_46071992_46071992_0": {"length": 7, "quality": 1.0, "section_id": 472}, "so_46071992_46072220_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 6785}}, "n4659": {"so_46071992_46072220_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 4058}, "so_46071992_46071992_0": {"length": 7, "quality": 1.0, "section_id": 504}, "so_46071992_46072220_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8537}}}, "46071992": {"ViewCount": "106", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Thing\n{\n    Thing(void)                       {std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;}\n    Thing(Thing const &amp;)              = delete;\n    Thing(Thing &amp;&amp;)                   = delete;\n    Thing &amp; operator =(Thing const &amp;) = delete;\n    Thing &amp; operator =(Thing &amp;&amp;)      = delete;\n};\n\nint main()\n{\n    Thing thing{Thing{}};\n}\n</code></pre>\n<p>I expect <code>Thing thing{Thing{}};</code> statement to mean construction of temporary object of <code>Thing</code> class using default constructor and construction of <code>thing</code> object of <code>Thing</code> class using move constructor with just created temporary object as an argument. And I expect that this program to be considered ill-formed because it contains an invocation of deleted move constructor, even though it can be potentially elided. The <strong>class.copy.elision</strong> section of standard seems to demand this as well:</p>\n<blockquote>\n<p id=\"so_46071992_46071992_0\">the selected constructor must be accessible even if the call is elided</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html\" rel=\"nofollow noreferrer\">Wording for guaranteed copy elision through simplified value categories</a> does not seem to allow it either.</p>\n<p>However gcc 7.2 (and clang 4 as well, but not VS2017 which <a href=\"https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance\" rel=\"nofollow noreferrer\">still does not support guaranteed copy elision</a>) will <a href=\"http://coliru.stacked-crooked.com/a/14daef7a5ebbf6da\" rel=\"nofollow noreferrer\">compile this code just fine</a> eliding move constructor call.</p>\n<p>Which behavior would be correct in this case?</p>\n", "AcceptedAnswerId": "46072220", "Title": "Is copy/move elision allowed to make a program using deleted functions well-formed?", "CreationDate": "2017-09-06T09:47:39.780", "Id": "46071992", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-09-06T10:05:01.187", "LastEditorUserId": "4850040", "LastActivityDate": "2017-09-06T10:59:49.313", "Score": "3", "OwnerUserId": "7860670", "Tags": "<c++><constructor><c++1z><copy-elision>", "AnswerCount": "1"}, "46072220": {"Id": "46072220", "PostTypeId": "2", "Body": "<p>It doesn't make an ill-formed program build. It gets rid of the reference to the deleted function entirely. The appropriate wording in the proposal is here:</p>\n<p>[dcl.init] bullet 17.6</p>\n<blockquote>\n<p id=\"so_46071992_46072220_0\">If the initializer expression is a prvalue and the cv-unqualified\n  version of the source type is the same class as the class of the\n  destination, the initializer expression is used to initialize the\n  destination object. [ Example: T x = T(T(T())); calls the T default\n  constructor to initialize x. ]</p>\n</blockquote>\n<p>The example further strengthens this. Since it indicates the whole expression must collapse into a single default construction.</p>\n<p>The thing to note is that the deleted function is never odr-used when the copies are elided due to value categories, so the program is <strong>not</strong> referring to it.</p>\n<p>This is an important distinction, since the <em>other</em> form of copy elision still odr-uses the copy c'tor, as described here:</p>\n<p>[basic.def.odr]/3</p>\n<blockquote>\n<p id=\"so_46071992_46072220_1\">... A constructor selected to copy or move an object of class type is\n  odr-used even if the call is actually elided by the implementation\n  ([class.copy] ...</p>\n</blockquote>\n<p>[class.copy] describes the other form of permissible (but not mandatory) copy-elision. Which, if we demonstrate with your class:</p>\n<pre><code>Thing foo() {\n    Thing t;\n    return t; // Can be elided according to [class.copy.elision] still odr-used\n}\n</code></pre>\n<p>Should make the program ill-formed. <a href=\"http://coliru.stacked-crooked.com/a/27324aa18431270f\" rel=\"nofollow noreferrer\">And GCC complains about it as expected</a>.</p>\n<hr>\n<p>And by the way. If you think the previous example in the online compiler is a magicians trick, and GCC complains because it needs to <em>call</em> the move c'tor. <a href=\"http://coliru.stacked-crooked.com/a/31cd3da6508482d5\" rel=\"nofollow noreferrer\">Have a look at what happens when we supply a definition</a>.</p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-09-06T10:59:49.313", "Score": "6", "CreationDate": "2017-09-06T09:57:54.210", "ParentId": "46071992", "CommentCount": "5", "OwnerUserId": "817643", "LastEditDate": "2017-09-06T10:59:49.313"}});