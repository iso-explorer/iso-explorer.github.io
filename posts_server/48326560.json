post_cb({"bq_ids": {"n4140": {"so_48326560_48326837_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5451}}}, "48326837": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48326560_48326837_0\">Is it possible to obtain the type of an instantiated template from a variable?</p>\n</blockquote>\n<p>Yes.</p>\n<ol>\n<li><p>Update the class template to provide the type that was used to instantiate it. </p>\n<pre><code>template &lt;typename T&gt; struct TemplateClass : public BaseClass\n{\n   using type = T;\n};\n</code></pre></li>\n<li><p>Use <code>decltype(A)</code> to use the type of <code>A</code>.</p></li>\n</ol>\n<hr>\n<p>Here's an updated version of your posted code that compiles and builds for me using g++ 5.4.0.</p>\n<pre><code>struct A {enum E{AA, AB, AC}; };\nstruct B {enum E{BX, BY, BZ}; };\n\nclass BaseClass {};\n\ntemplate &lt;typename T&gt; struct TemplateClass : public BaseClass\n{\n   using type = T;\n};\n\nclass AChild : public TemplateClass&lt;A&gt; {};\nclass BChild : public TemplateClass&lt;B&gt; {};\n\ntemplate &lt;typename T&gt;\nstruct WorkerClass\n{\n  static void dostuff(const BaseClass&amp; a) {};\n};\n\nint main(void)\n{\n  AChild a;\n  using type = decltype(a)::type;\n  WorkerClass&lt;type::E&gt;::dostuff(a);\n}\n</code></pre>\n</hr>", "ParentId": "48326560", "LastActivityDate": "2018-01-18T17:12:12.147", "CommentCount": "0", "CreationDate": "2018-01-18T17:12:12.147", "Id": "48326837", "Score": "2", "OwnerUserId": "434551"}, "48326560": {"ViewCount": "41", "Body": "<p>Is it possible to obtain the type of an instantiated template from a variable?</p>\n<pre><code>struct A { enum E {A_, B, C}; };\nstruct B { enum E {X, Y, Z}; };\n\nclass BaseClass {};\ntemplate &lt;typename T&gt; class TemplateClass : public BaseClass {};\n\nclass AChild : public TemplateClass&lt;A&gt; {};\nclass BChild : public TemplateClass&lt;B&gt; {};\n\ntemplate &lt;typename T&gt;\nclass WorkerClass\n{\n  static void do_stuff(const BaseClass&amp; a) {}\n};\n\nint main(void)\n{\n  AChild a;\n  //need to call WorkerClass&lt;A::E&gt;::do_stuff(a)\n}\n</code></pre>\n", "AcceptedAnswerId": "48326661", "Title": "Get type of inherited instantiated template", "CreationDate": "2018-01-18T16:57:13.947", "Id": "48326560", "CommentCount": "0", "LastEditDate": "2018-01-18T17:33:49.337", "PostTypeId": "1", "LastEditorUserId": "1597714", "LastActivityDate": "2018-01-18T18:12:46.050", "Score": "0", "OwnerUserId": "1043352", "Tags": "<c++><templates>", "AnswerCount": "4"}, "48326767": {"PostTypeId": "2", "Body": "<p>C++ has <strong>RTTI</strong> (Run Time Type Identification). Maybe you want to use <code>std::dynamic_cast</code> for this.</p>\n<p>dynamic_cast(elem) tries to get an object of type T from elem</p>\n<ul>\n<li>If T is of type pointer, it returns a pointer to the object, or 0 (if\nthe pointed object is not of type T)</li>\n<li>If T is of type reference, it returns a reference to the object, or\nthrows an std::bad_cast exception</li>\n</ul>\n", "ParentId": "48326560", "LastActivityDate": "2018-01-18T17:07:44.803", "CommentCount": "0", "CreationDate": "2018-01-18T17:07:44.803", "Id": "48326767", "Score": "0", "OwnerUserId": "8355261"}, "48326661": {"PostTypeId": "2", "LastEditDate": "2018-01-18T18:12:46.050", "ParentId": "48326560", "CommentCount": "2", "LastActivityDate": "2018-01-18T18:12:46.050", "CreationDate": "2018-01-18T17:02:00.563", "OwnerUserId": "2684539", "Id": "48326661", "Score": "4", "Body": "<p>You may do:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(TemplateClass&lt;T&gt;&amp; c)\n{\n    WorkerClass&lt;typename T::E&gt;::do(c)\n}\n</code></pre>\n<p>and then</p>\n<pre><code>foo(a);\n</code></pre>\n<p>Other traditional way is to add the type in template class:</p>\n<pre><code>template &lt;typename T&gt; class TemplateClass : public BaseClass\n{\n    using type = T;\n};\n</code></pre>\n<p>so you can do</p>\n<pre><code>WorkerClass&lt;AChild::type::E&gt;::do(a);\n</code></pre>\n", "LastEditorUserId": "2684539"}, "48327352": {"PostTypeId": "2", "Body": "<p>Adding to @Jarod42 's answer, you may also write a type trait instead, in C++11:</p>\n<pre><code>template &lt;typename T&gt;\nT&amp; GetEnumOfImpl(TemplateClass&lt;T&gt;&amp;);\n\ntemplate &lt;typename T&gt;\nusing GetEnumOf = typename std::decay_t&lt;decltype(GetEnumOfImpl(std::declval&lt;T&amp;&gt;()))&gt;::E;\n\n...\n\nAChild a;\nWorkerClass&lt;GetEnumOf&lt;AChild&gt;&gt;::do_stuff(a);\n</code></pre>\n", "ParentId": "48326560", "LastActivityDate": "2018-01-18T17:45:10.907", "CommentCount": "0", "CreationDate": "2018-01-18T17:45:10.907", "Id": "48327352", "Score": "0", "OwnerUserId": "8631381"}});