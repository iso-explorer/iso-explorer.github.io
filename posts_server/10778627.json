post_cb({"10778677": {"Id": "10778677", "PostTypeId": "2", "Body": "<p>in C++03 both <code>i = ++i + 1;</code> and <code>i = i++ + 1</code>  are not well defined.</p>\n<p>But in C++11  the <code>i = ++i + 1</code> becomes well defined. but <code>i=i++ + 1</code> is still not.</p>\n<p>Look the content in this like for details\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637\" rel=\"nofollow\">Sequencing rules and example disagree</a> </p>\n", "LastActivityDate": "2012-05-28T02:12:00.353", "Score": "4", "CreationDate": "2012-05-28T02:12:00.353", "ParentId": "10778627", "CommentCount": "0", "OwnerUserId": "818399"}, "bq_ids": {"n4140": {"so_10778627_10778627_1": {"length": 18, "quality": 1.0, "section_id": 5810}, "so_10778627_10778627_4": {"length": 14, "quality": 1.0, "section_id": 5934}, "so_10778627_10778627_0": {"length": 55, "quality": 0.8333333333333334, "section_id": 5809}, "so_10778627_10778627_2": {"length": 59, "quality": 0.921875, "section_id": 5811}, "so_10778627_10779755_1": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_10778627_10778627_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5811}, "so_10778627_10779755_0": {"length": 21, "quality": 1.0, "section_id": 6164}}, "n3337": {"so_10778627_10778627_2": {"length": 59, "quality": 0.921875, "section_id": 5584}, "so_10778627_10778627_4": {"length": 14, "quality": 1.0, "section_id": 5706}, "so_10778627_10778627_0": {"length": 55, "quality": 0.8333333333333334, "section_id": 5582}, "so_10778627_10779755_1": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_10778627_10778627_1": {"length": 18, "quality": 1.0, "section_id": 5583}, "so_10778627_10778627_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5584}, "so_10778627_10779755_0": {"length": 21, "quality": 1.0, "section_id": 5925}}, "n4659": {"so_10778627_10778627_2": {"length": 53, "quality": 0.828125, "section_id": 7272}, "so_10778627_10778627_4": {"length": 14, "quality": 1.0, "section_id": 7418}, "so_10778627_10778627_0": {"length": 55, "quality": 0.8333333333333334, "section_id": 7270}, "so_10778627_10779755_1": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_10778627_10778627_1": {"length": 18, "quality": 1.0, "section_id": 7271}, "so_10778627_10778627_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 7272}, "so_10778627_10779755_0": {"length": 21, "quality": 1.0, "section_id": 7661}}}, "10778645": {"Id": "10778645", "PostTypeId": "2", "Body": "<p>You are confusing value computation with resolution of side effects. While the value of <code>i++</code> must be computed before the assignment, nothing sequences the side-effect (the modification to <code>i</code>) with respect to the assignment other than the completion of the full expression.</p>\n<p>For a contrasting example, have a look at the comma operator: \"Every value computation and side effect associated with the left expression is sequenced before every value computation and side effect associated with the right expression.\" Notice how value computation and side effects are mentioned separately. There is no such rule for assignment.</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2012-05-28T11:59:42.363", "Score": "3", "CreationDate": "2012-05-28T02:05:45.007", "ParentId": "10778627", "CommentCount": "16", "LastEditDate": "2012-05-28T11:59:42.363", "OwnerUserId": "721269"}, "10778627": {"ViewCount": "2025", "Body": "<p>I am reading n3290 draft of C++11 standard (as close as I could get to actual standard text), and I noticed that <code>i = i++ + 1;</code> produces undefined behavior. I have seen similar questions before, but they were answered in terms of older standards (Sequence points). New standard introduces instead concept of <em>Sequencing before/after</em> relation between expression and sub-expression executions.</p>\n<blockquote>\n<p id=\"so_10778627_10778627_0\">1.9 13 Sequenced before is an asymmetric, transitive, pair-wise relation\n  between evaluations executed by a single thread (1.10), which induces\n  a partial order among those evaluations. Given any two evaluations A\n  and B, if A is sequenced before B, then the execution of A shall\n  precede the execution of B. If A is not sequenced before B and B is\n  not sequenced before A, then A and B are unsequenced. [ Note: The\n  execution of unsequenced evaluations can overlap. \u2014end note ]\n  Evaluations A and B are indeterminately sequenced when either A is\n  sequenced before B or B is sequenced before A, but it is unspecified\n  which. [ Note: Indeterminately sequenced evaluations cannot overlap,\n  but either could be executed first. \u2014end note ]</p>\n<p id=\"so_10778627_10778627_1\">1.9 14 Every value\n  computation and side effect associated with a full-expression is\n  sequenced before every value computation and side effect associated\n  with the next full-expression to be evaluated.</p>\n<p id=\"so_10778627_10778627_2\">1.9 15 Except where\n  noted, evaluations of operands of individual operators and of\n  subexpressions of individual expressions are unsequenced. [ Note: In\n  an expression that is evaluated more than once during the execution of\n  a program, unsequenced and indeterminately sequenced evaluations of\n  its subexpressions need not be performed consistently in different\n  evaluations. \u2014end note ] The value computations of the operands of an\n  operator are sequenced before the value computation of the result of\n  the operator. If a side effect on a scalar object is unsequenced\n  relative to either anotherside effect on the same scalar object or a\n  value computation using the value of the same scalar object, the\n  behavior is undefined.</p>\n</blockquote>\n<pre><code>[ Example:\nvoid f(int, int);\nvoid g(int i, int* v) {\ni = v[i++]; // the behavior is undefined\ni = 7, i++, i++; // i becomes 9\ni = i++ + 1; // the behavior is undefined\ni = i + 1; // the value of i is incremented\nf(i = -1, i = -1); // the behavior is undefined\n}\n\u2014end example ]\n</code></pre>\n<p>The way I understand it, it works like that: </p>\n<ul>\n<li><code>operator=</code> has two operand expressions: taking reference to <code>i</code> and <code>i++ + 1</code>, both unsequnced to one another. The second one has side effect on <code>i</code>, but the first one seems to me not to have side effect or be used in value computation (or is reference taking \"a value computation using the value of the same scalar object\"? does it actually depend on value stored in i? don't think so), so it's not undefined behavior;</li>\n<li><code>operator=</code> execution is sequenced after both operand evaluation. It has side effect on <code>i</code>, but it's well-sequenced in reference to both operands so it's not udefined behavior;</li>\n<li><code>i++ + 1</code> is obviously defined behavior.</li>\n</ul>\n<p>Am I wrong about something here? Or is this line undefined behaviour for some other reason?</p>\n<p>PS. Standard actually says </p>\n<blockquote>\n<p id=\"so_10778627_10778627_3\">The value computations of the operands of an operator are sequenced\n  before the value computation of the result of the operator.</p>\n</blockquote>\n<p>, and it doesn't mention side effects in this context at all. However sequencing relation is defined only between expression evaluations, and evaluation = value computing + side effects. So either I have to assume this draft to be inconsistent here, or assume that in this line they meant evaluation instead of value computation. Or am I wrong here?</p>\n<p>EDIT:</p>\n<p>I guess I will be answering myself here, but that was the reason for my confusion:</p>\n<blockquote>\n<p id=\"so_10778627_10778627_4\">5 1 An expression is a sequence of operators and operands that\n  specifies a computation. An expression can result in a value and can\n  cause side effects.</p>\n</blockquote>\n<p>So operands of operators are not sub-expressions themselves. Therefore only value computation for entire <code>i = i++ + 1;</code> is sequenced, and no mention of side effect sequencing is made by standard. That's the reason why it's undefined.</p>\n<p>Note that if eg. <code>operator=</code> was overloaded for given type (so it would be an implicite function call) it wouldn't be undefined behavior, right?</p>\n", "AcceptedAnswerId": "10779755", "Title": "Why is `i = i++ + 1` undefined behavior in C++11?", "CreationDate": "2012-05-28T02:01:08.620", "Id": "10778627", "CommentCount": "8", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-05-28T10:34:43.423", "LastEditorUserId": "34509", "LastActivityDate": "2012-05-28T11:59:42.363", "Score": "18", "OwnerUserId": "455304", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "10779755": {"Id": "10779755", "PostTypeId": "2", "Body": "<p>It's \"undefined behavior,\" not \"unspecified.\" Undefined means the machine is allowed to do anything including output an empty program, terminate randomly, or explode. Of course, a subtly unexpected value when porting to another platform is a more likely outcome.</p>\n<p>Undefined behavior applies to any case where two side effects apply to the same scalar without being sequenced relative to each other. In this case, the side effects happen to be identical (both increment <code>i</code> from its original value before the expression), but by the letter of the standard, they combine to produce UB.</p>\n<p>The side effects are unsequenced because aside from <code>,</code>, <code>?:</code>, <code>||</code>, and <code>&amp;&amp;</code>, operators do not define sequencing rules in terms such as C++11 \u00a75.15/2:</p>\n<blockquote>\n<p id=\"so_10778627_10779755_0\">If the second expression is evaluated, every value computation and side effect associated with the first expression is sequenced before every value computation and side effect associated with the second expression.</p>\n</blockquote>\n<p>The assignment operators do define a special sequencing rule, \u00a75.17/1:</p>\n<blockquote>\n<p id=\"so_10778627_10779755_1\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>This does not help <code>i = i ++ + 1</code> because the side effect of <code>i ++</code> is not part of any value computation.</p>\n", "LastActivityDate": "2012-05-28T05:30:56.603", "Score": "7", "CreationDate": "2012-05-28T05:30:56.603", "ParentId": "10778627", "CommentCount": "1", "OwnerUserId": "153285"}});