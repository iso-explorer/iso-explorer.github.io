post_cb({"4194298": {"ParentId": "4194191", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>You can store it like this.    </p>\n<pre><code>class my_type_info\n{\npublic:\n     my_type_info(const std::type_info&amp; info) : info_(&amp;info){}\n     std::type_info get() const { return *info_;}\nprivate:\n     const std::type_info* info_;\n};\n</code></pre>\n<p>EDIT:</p>\n<p>C++ standard 5.2.8.</p>\n<blockquote>\n<p id=\"so_4194191_4194298_0\">The result of a\n  typeid expression is an lvalue of\n  static type const std::type_info...</p>\n</blockquote>\n<p>Which means you can use it like this.</p>\n<pre><code>my_type_info(typeid(my_type));\n</code></pre>\n<p>The typeid function returns an lvalue (it is not temporary) and therefore the address of the returned type_info is always valid.</p>\n", "OwnerUserId": "346804", "LastEditorUserId": "346804", "LastEditDate": "2010-11-16T13:02:17.747", "Id": "4194298", "Score": "3", "CreationDate": "2010-11-16T12:51:47.637", "LastActivityDate": "2010-11-16T13:02:17.747"}, "4194398": {"ParentId": "4194191", "CommentCount": "4", "Body": "<p>After a quick look at the documentation, I would say that :</p>\n<ol>\n<li><p>std::type_info::name always returns two different strings for two different types, otherwise it means that the compiler lost itself while resolving types and you shouldn't use it anymore.</p></li>\n<li><p>Reference tells : \"before returns true if the type precedes the type of rhs in the collation order. The collation order is just an internal order kept by a particular implementation and is not necessarily related to inheritance relations or declaring order.\"\nYou therefore have the guarantee that no types has the same rank in the collation order.</p></li>\n<li><p>Each instantiation of a template class is a different type. Specialization make no exceptions.</p></li>\n<li><p>I don't really understand what you mean. If you mean something like having <code>typedef foo bar;</code> in two separate compilation units and that bar is the same in both, it works that way. If you mean <code>typedef foo bar; typedef int bar;</code>, it doesn't work (except if foo is int).</p></li>\n</ol>\n<p>About your other questions :</p>\n<ul>\n<li>You should store references to std::type_info, of wrap it somehow.</li>\n<li>Absolutely no idea about performance, I assume that comparison operators have constant time despite of the type complexity. Before must have linear complexity depending on the number of different types used in your code.</li>\n<li>This is really strange imho. You should overload your <code>operator==</code> instead of make it virtual and override it.</li>\n</ul>\n", "OwnerUserId": "292876", "PostTypeId": "2", "Id": "4194398", "Score": "7", "CreationDate": "2010-11-16T13:04:41.983", "LastActivityDate": "2010-11-16T13:04:41.983"}, "4194740": {"ParentId": "4194191", "CommentCount": "1", "Body": "<p>Type_info is implementation defined so I really wouldn't rely on it. However, based on my experiences using g++ and MSVC, assumptions 1,3 and 4 hold... not really sure about #2.</p>\n<p>Is there any reason you can't use another method like this?</p>\n<pre><code>template&lt;typename T, typename U&gt;\nstruct is_same       { static bool const result = false; };\n\ntemplate&lt;typename T&gt;\nstruct is_same&lt;T, T&gt; { static bool const result = true;  };\n\ntemplate&lt;typename S, typename T&gt;\nbool IsSame(const S&amp; s, const T&amp; t) {   return is_same&lt;S,T&gt;::result; }\n</code></pre>\n", "OwnerUserId": "462728", "PostTypeId": "2", "Id": "4194740", "Score": "0", "CreationDate": "2010-11-16T13:42:36.193", "LastActivityDate": "2010-11-16T13:42:36.193"}, "4194266": {"ParentId": "4194191", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Standard 18.5.1 (Class type_info) :</p>\n<blockquote>\n<p id=\"so_4194191_4194266_0\">The class type_info describes type\n  information generated by the\n  implementation. Objects of this class\n  effectively store a pointer to a name\n  for the type, and an encoded value\n  suitable for comparing two types for\n  equality or collating order. <strong>The\n  names, encoding rule, and collating\n  sequence for types are all unspecified\n  and may differ between programs</strong>.</p>\n</blockquote>\n<p>From my understanding :</p>\n<ol>\n<li>You don't have this guarantee regarding <code>std:type_info::name</code>. The standard only states that <code>name</code> returns <em>an implementation-defined NTBS</em>, and I believe a conforming implementation could very well return the same string for every type.</li>\n<li>I don't know, and the standard isn't clear on this point, so I wouldn't rely on such behavior.</li>\n<li>That one should be a definite 'Yes' for me</li>\n<li>That one should be a definite 'Yes' for me</li>\n</ol>\n<p>Regarding the second set of questions :</p>\n<ul>\n<li>No, you cannot store a <code>type_info</code>. Andrei Alexandrescu proposes a <code>TypeInfo</code> wrapper in its <a href=\"http://books.google.com/books?id=aJ1av7UFBPwC&amp;pg=PA37&amp;lpg=PA37\" rel=\"nofollow\">Modern C++ Design</a> book. Note that <strong>the objects returned by <code>typeid</code> have static storage</strong> so you can safely store pointers without worrying about object lifetime</li>\n<li>I believe you can assume that <code>type_info</code> comparison are extremely efficient (there really isn't much to compare).</li>\n</ul>\n", "OwnerUserId": "451980", "LastEditorUserId": "451980", "LastEditDate": "2010-11-16T13:14:54.467", "Id": "4194266", "Score": "3", "CreationDate": "2010-11-16T12:48:35.820", "LastActivityDate": "2010-11-16T13:14:54.467"}, "4195509": {"ParentId": "4194191", "CommentCount": "0", "Body": "<p>The current answers for questions 1 and 2 are perfectly correct, and they're essentially just details for the type_info class - no point in repeating those answers.</p>\n<p>For questions 3 and 4, it's important to understand what precisely is a type in C++, and how they relate to names. For starters, there are a whole bunch of predefined types, and those have names: <code>int, float, double</code>. Next, there are some constructed types that do <em>not</em> have names of their own: <code>const int, int*, const int*, int* const</code>. There are function types <code>int (int)</code> and function pointer types <code>int (*)(int)</code>. </p>\n<p>It's sometimes useful to give a name to an unnamed type, which is possible using <code>typedef</code>. For instance, <code>typedef int* pint</code> or <code>typedef int (*pf)(int);</code>. This introduces a name, not a new type.</p>\n<p>Next are user-defined types: structs, classes, unions. There's a good convention to give them names, but it's not mandatory. Don't add such a name with typedef, you can do so directly: <code>struct Foo { };</code> instead of <code>typedef struct {} Foo;</code>. It's common to have class definitions in headers, which end up\\ in multiple translation units. That does mean the class is defined more than once. This is still the same type, and therefore you aren't allowed to play tricks with macros to change the class member definitions.</p>\n<p>A template class is <em>not</em> a type, it's a recipe for types. Two instantiations of a single class template are distinct types if the template arguments are different types (or values). This works recursively: Given <code>template &lt;typename T&gt; struct Foo{};</code>, <code>Foo&lt;Foo&lt;int&gt; &gt;</code> is the same type as <code>Foo&lt;Foo&lt;Bar&gt; &gt;</code> if and only if <code>Bar</code> is another name for the type <code>int</code>.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "4195509", "Score": "1", "CreationDate": "2010-11-16T15:02:50.377", "LastActivityDate": "2010-11-16T15:02:50.377"}, "bq_ids": {"n4140": {"so_4194191_4194298_0": {"section_id": 6020, "quality": 0.8888888888888888, "length": 8}, "so_4194191_4194266_0": {"section_id": 6885, "quality": 0.9459459459459459, "length": 35}}, "n3337": {"so_4194191_4194298_0": {"section_id": 5788, "quality": 0.8888888888888888, "length": 8}, "so_4194191_4194266_0": {"section_id": 6631, "quality": 0.9459459459459459, "length": 35}}, "n4659": {"so_4194191_4194298_0": {"section_id": 7519, "quality": 0.8888888888888888, "length": 8}, "so_4194191_4194266_0": {"section_id": 8385, "quality": 0.9459459459459459, "length": 35}}}, "4194191": {"CommentCount": "1", "AcceptedAnswerId": "4194398", "PostTypeId": "1", "LastEditorUserId": "300805", "CreationDate": "2010-11-16T12:39:20.270", "LastActivityDate": "2010-11-16T15:02:50.377", "LastEditDate": "2010-11-16T13:32:44.797", "ViewCount": "13556", "FavoriteCount": "7", "Title": "C++: type_info to distinguish types", "Id": "4194191", "Score": "16", "Body": "<p>I know that compilers have much freedom in implementing <code>std::type_info</code> functions' behavior.</p>\n<p>I'm thinking about using it to compare object types, so I'd like to be sure that:</p>\n<ol>\n<li><p><code>std::type_info::name</code> must return two different strings for two different types.</p></li>\n<li><p><code>std::type_info::before</code> must say that <code>Type1</code> is <em>before</em> <code>Type2</code> <strong>exclusive-or</strong> <code>Type1</code> is <em>before</em> <code>Type2</code>.</p>\n<pre><code>// like this:\ntypeid(T1).before( typeid(T2) ) != typeid(T2).before( typeid(T1) )\n</code></pre></li>\n<li><p>Two different specialization of the same template class are considered different types.</p></li>\n<li><p>Two different <code>typedef</code>-initions of the same type are the same type.</p></li>\n</ol>\n<p>And finally:</p>\n<ul>\n<li><p>Since <code>std::type_info</code> is not copyable, how could I store <code>type_info</code>s somewhere (eg: in a <code>std::map</code>)? The only way it to have a <code>std::type_info</code> always allocated somewhere (eg: on the stack or on a static/global variable) and use a pointer to it?</p></li>\n<li><p>How fast are <code>operator==</code>, <code>operator!=</code> and <code>before</code> on most common compilers? I guess they should only compare a value. And how fast is <code>typeid</code>?</p></li>\n<li><p>I've got a class <code>A</code> with a <code>virtual bool operator==( const A&amp; ) const</code>. Since <code>A</code> has got many subclasses (some of which are unknown at compile time), I'd overload that virtual operator in any subclass <code>B</code> this way:</p>\n<pre><code>virtual bool operator==( const A &amp;other ) const {\n  if( typeid(*this) != typeid(other) ) return false;\n  // bool B::operator==( const B &amp;other ) const // is defined for any class B\n  return operator==( static_cast&lt;B&amp;&gt;( other ) );\n}\n</code></pre>\n<p>Is this an acceptable (and standard) way to implement such operator?</p></li>\n</ul>\n", "Tags": "<c++><typeid><typeinfo>", "OwnerUserId": "300805", "AnswerCount": "5"}});