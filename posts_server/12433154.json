post_cb({"bq_ids": {"n4140": {"so_12433154_12433681_0": {"length": 8, "quality": 1.0, "section_id": 992}}, "n3337": {"so_12433154_12433681_0": {"length": 8, "quality": 1.0, "section_id": 977}}, "n4659": {"so_12433154_12433681_0": {"length": 8, "quality": 1.0, "section_id": 1055}}}, "12433154": {"ViewCount": "2647", "Body": "<p>When thinking about this <a href=\"https://stackoverflow.com/questions/12432084/fastest-way-to-modify-part-of-array\">question</a> I start to wondering if <code>std::copy()</code> and/or <code>std::fill</code> are specialized (I really mean optimized) for <code>std::vector&lt;bool&gt;</code>.</p>\n<p>Is this required by C++ standard or, perhaps, it is common approach by C++ std library vendors?</p>\n<p>Simple speaking, I wonder to know if the following code:</p>\n<pre><code>std::vector&lt;bool&gt; v(10, false);\nstd::fill(v.begin(), v.end(), true);\n</code></pre>\n<p>is in any way better/different than that:</p>\n<pre><code>std::vector&lt;bool&gt; v(10, false);\nfor (auto it = v.begin(); it != v.end(); ++it) *it = true;\n</code></pre>\n<p>To be very strict - can, let say: <code>std::fill&lt;std::vector&lt;bool&gt;::iterator&gt;()</code> go into internal representation of <code>std::vector&lt;bool&gt;</code> and sets their entire bytes instead of single bits? I assume making <code>std::fill</code> friend of <code>std::vector&lt;bool&gt;</code> is not a big problem for library vendor?</p>\n<p>[UPDATE]</p>\n<p>Next related question: can I (or anybody else :) specialize such algorithms for let say <code>std::vector&lt;bool&gt;</code>, if not already specialized? Is this allowed by C++ standard? I know this will be non portable - but just for one selected std C++ library? Assuming I (or anybody else) find a way to get to <code>std::vector&lt;bool&gt;</code> private parts.</p>\n", "AcceptedAnswerId": "12434687", "Title": "Are std::fill, std::copy specialized for std::vector<bool>?", "CreationDate": "2012-09-14T23:18:11.730", "Id": "12433154", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:20.470", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-24T11:34:01.710", "Score": "11", "OwnerUserId": "1463922", "Tags": "<c++><vector><stl-algorithm><bitvector>", "AnswerCount": "3"}, "12433697": {"Id": "12433697", "PostTypeId": "2", "Body": "<p>Optimizations are nowhere mandated in the standard. It is assumed to be a \"quality of implementation\" issue if an optimization could applied. The asymptotic complexity of most algorithms is, however, restricted.</p>\n<p>Optimizations are allowed as long as a correct program behaves according to what the standard mandates. The examples you ask about, i.e., optimizations involving standard algorithms using iterators on <code>std::vector&lt;bool&gt;</code>, can achieve their objective pretty much in any way the implementation sees fit because there is no way to monitor how they are implemented. This said, I doubt very much that there is any standard library implementation optimizing operations on <code>std::vector&lt;bool&gt;</code>. Most people seem to think that this specialization is an abomination in the first place and that it should go away.</p>\n<p>A user is only allowed to create specializations of library types if the specialization involves at least one user defined type. I don't think a user is allowed to provide any function in namespace <code>std</code> at all: There isn't any needs because all such functions would involve a user defined type and would, thus, be found in the user's namespace. Formulated differently: I think you are out of luck with respect to getting algoritms optimized for <code>std::vector&lt;bool&gt;</code> for the time being. You might consider contributing optimized versions to the open source implementations (e.g., <code>libstdc++</code> and <code>libc++</code>), however.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2012-12-30T14:34:53.870", "Score": "4", "CreationDate": "2012-09-15T01:05:37.253", "ParentId": "12433154", "CommentCount": "0", "LastEditDate": "2012-12-30T14:34:53.870", "OwnerUserId": "1120273"}, "12433681": {"Id": "12433681", "PostTypeId": "2", "Body": "<p>23.2.5 Class vector from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">C++ International Standard</a> goes as far as to tell us</p>\n<blockquote>\n<p id=\"so_12433154_12433681_0\">To optimize space allocation, a specialization of vector for bool elements is provided:</p>\n</blockquote>\n<p>after which the bitset specialization is provided. That's as far as the standard goes regarding <code>vector&lt;bool&gt;</code>, vendors need to implement it using a bitset to optimize for space. Optimizing for space comes with a cost here, as to not optimize for speed.</p>\n<p>It's easier to get a book from the library than it is to find a book if it were between all the library books stapled closely together in containers....</p>\n<hr>\n<p>Take your example, you're trying to do a <code>std::fill</code> or <code>std::copy</code> from begin to end. But that's not always the case, sometimes it doen't just simply map to an entire byte. So, that's a bit of a problem in terms of speed optimization. It's easy for the case you'd have to change every bit to one, that's just changing the bytes to 0xF, but that's not the case here; it becomes much harder if you were to only changes certain bits of a byte. Then you'll need to actually compute what the byte will be; that's not a trivial thing to do<sup>*</sup>, or at least not as an atomic operation on current hardware.</p>\n<p>It's the premature optimization story, it's nice in terms of space but horrible in terms of performance.</p>\n<p>Is having a <code>\"is a multiple of 8 bits\"</code> check worth the overhead? I doubt it.</p>\n<p><sub>* We're talking about multiple bits here, for the case it's just one bit you can of course do a bit operation.</sub></p>\n</hr>", "LastEditorUserId": "47064", "LastActivityDate": "2012-09-15T01:05:29.943", "Score": "1", "CreationDate": "2012-09-15T01:00:22.663", "ParentId": "12433154", "CommentCount": "1", "LastEditDate": "2012-09-15T01:05:29.943", "OwnerUserId": "47064"}, "12434687": {"Id": "12434687", "PostTypeId": "2", "Body": "<p>STD  is  headers only library and it is shipped with your compiler. You can look into those headers yourself.  For GCC's <code>vector&lt;bool&gt;</code>  impelemtation is in <code>stl_bvector.h</code>. It probably will be the same file for other compilers too.  And yes, there is specialized <code>fill</code> (look near <code>__fill_bvector</code>). </p>\n", "LastEditorUserId": "1173542", "LastActivityDate": "2013-10-24T11:34:01.710", "Score": "10", "CreationDate": "2012-09-15T05:07:33.497", "ParentId": "12433154", "CommentCount": "1", "LastEditDate": "2013-10-24T11:34:01.710", "OwnerUserId": "1173542"}});