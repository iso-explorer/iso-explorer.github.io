post_cb({"bq_ids": {"n4140": {"so_25660234_25660498_1": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_25660234_25660498_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3228}, "so_25660234_25660498_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6185}}, "n3337": {"so_25660234_25660498_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 3101}}, "n4659": {"so_25660234_25660498_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_25660234_25660498_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3985}, "so_25660234_25660498_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7687}}}, "25660234": {"ViewCount": "880", "Body": "<pre><code>class armon\n{\n    static const int maxSize=10;    \n\n    int array[maxSize];\n\n    int count=0;\n\n    int* topOfStack=array;\n}\n</code></pre>\n<p>Why does <code>maxSize</code> need to be <code>static</code> for it to be used inside array? </p>\n", "AcceptedAnswerId": "25665411", "Title": "Why does this variable need to be static?", "CreationDate": "2014-09-04T08:02:26.527", "Id": "25660234", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-09-04T09:38:38.430", "LastEditorUserId": "3510483", "LastActivityDate": "2014-09-04T12:22:24.450", "Score": "8", "OwnerUserId": "4006148", "Tags": "<c++><arrays><static><member>", "AnswerCount": "3"}, "25662246": {"Id": "25662246", "PostTypeId": "2", "Body": "<p>It doesn't have to be static, it has to be constant.</p>\n<p>When you declare a constant inside a class you will be making a constant <strong>for each</strong> instance of the class. </p>\n<p>Also if your <code>maxSize</code> is just <code>const</code> you would have to intialize it in the constructor initializer list because <code>const maxSize</code> is treated as variable whose value you can't change. </p>\n<p>Inside a class <code>const</code>\nkeyword means \"This is a constant during the hole lifetime of this object\". <strong>Different objects of the same class can have different values for that constant.</strong></p>\n<p>But when it is a static constant there will be <strong>only one constant</strong> for all instances of the class. This means that you have to initialize constants value on the same line where you are defining it.</p>\n", "LastActivityDate": "2014-09-04T09:45:53.110", "CommentCount": "5", "CreationDate": "2014-09-04T09:45:53.110", "ParentId": "25660234", "Score": "1", "OwnerUserId": "3478972"}, "25665411": {"Id": "25665411", "PostTypeId": "2", "Body": "<p>There are two aspects to this question</p>\n<p>Aspect 1</p>\n<p>C++ array is of fixed size, the size of which needs to be known during compile time. If the decision needs to be deferred during runtime, the array expression becomes ill-formed.</p>\n<p>Aspect 2</p>\n<p>Declaring a member variable as non-static makes it an  instance variable, the value of which only exist once the object is instantiated which is done during run-time. A static variable is a class variable, the value of which can be determined during compile time. </p>\n<p>Your particular example becomes the classic chicken-egg paradox.</p>\n<pre><code>class armon\n{\n    static const int maxSize=10;    \n\n    int array[maxSize];\n\n}\n</code></pre>\n<ul>\n<li>In order to instantiate your class <code>armon</code>, you need to know its size. </li>\n<li>In order to know its size, you need to know the size of individual members. In your particular case, you need to know the size of the array. </li>\n<li>In order to know the size of the array, you need to know the value of the dependent variable maxSize. </li>\n<li>In order to  access the dependent variable maxSize you need to instantiate the class  <code>armon</code>.</li>\n<li>In order to instantiate your class <code>armon</code>, you need to know its size. </li>\n</ul>\n<p>So, your array size dependent variable should be a constant expression, which in your particular case should be a static variable, </p>\n", "LastActivityDate": "2014-09-04T12:22:24.450", "CommentCount": "0", "CreationDate": "2014-09-04T12:22:24.450", "ParentId": "25660234", "Score": "5", "OwnerUserId": "977038"}, "25660498": {"Id": "25660498", "PostTypeId": "2", "Body": "<p>It doesn't <strong>have</strong> to be static, but it must be a <strong>constant expression</strong>.</p>\n<p>C++ Standard \u00a7 8.3.4 [dcl.array] (emphasis mine) :</p>\n<blockquote>\n<p id=\"so_25660234_25660498_0\">If the constant-expression (5.19) is present, it shall be a converted <strong>constant expression of type std::size_t</strong> and its value shall be greater than zero</p>\n</blockquote>\n<hr>\n<p>That is, the following is also valid :</p>\n<pre><code>constexpr std::size_t Size()  { return 10; }; \n\nstruct Y\n{\n    int array[Size()];\n};\n</code></pre>\n<hr>\n<p><strong>Note:</strong></p>\n<p>Since the compiler needs to know the size of the class, you cannot do this :</p>\n<pre><code>struct Y\n{\n    const int size = 10;\n    int array[size];\n};\n</code></pre>\n<p>Possibly making different instances of <code>Y</code> having different sizes.</p>\n<p>Also note that in this context, <code>int array[size]</code> is <strong>not</strong> a constant expression, because it makes use of <code>this</code>, see the C++ standard section \u00a7 5.19 [expr.const] :</p>\n<blockquote>\n<p id=\"so_25660234_25660498_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_25660234_25660498_2\">\u2014 <strong>this</strong> (5.1.1), except in a constexpr function or a constexpr constructor that is being evaluated as part of e;</p>\n</blockquote>\n<p>(the evaluation of <code>size</code> is really <code>this-&gt;size</code>)</p>\n</hr></hr>", "LastEditorUserId": "3510483", "LastActivityDate": "2014-09-04T10:59:59.357", "Score": "14", "CreationDate": "2014-09-04T08:17:28.053", "ParentId": "25660234", "CommentCount": "6", "OwnerUserId": "3510483", "LastEditDate": "2014-09-04T10:59:59.357"}});