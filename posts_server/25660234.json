post_cb({"25660498": {"ParentId": "25660234", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It doesn't <strong>have</strong> to be static, but it must be a <strong>constant expression</strong>.</p>\n<p>C++ Standard \u00a7 8.3.4 [dcl.array] (emphasis mine) :</p>\n<blockquote>\n<p id=\"so_25660234_25660498_0\">If the constant-expression (5.19) is present, it shall be a converted <strong>constant expression of type std::size_t</strong> and its value shall be greater than zero</p>\n</blockquote>\n<hr>\n<p>That is, the following is also valid :</p>\n<pre><code>constexpr std::size_t Size()  { return 10; }; \n\nstruct Y\n{\n    int array[Size()];\n};\n</code></pre>\n<hr>\n<p><strong>Note:</strong></p>\n<p>Since the compiler needs to know the size of the class, you cannot do this :</p>\n<pre><code>struct Y\n{\n    const int size = 10;\n    int array[size];\n};\n</code></pre>\n<p>Possibly making different instances of <code>Y</code> having different sizes.</p>\n<p>Also note that in this context, <code>int array[size]</code> is <strong>not</strong> a constant expression, because it makes use of <code>this</code>, see the C++ standard section \u00a7 5.19 [expr.const] :</p>\n<blockquote>\n<p id=\"so_25660234_25660498_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_25660234_25660498_2\">\u2014 <strong>this</strong> (5.1.1), except in a constexpr function or a constexpr constructor that is being evaluated as part of e;</p>\n</blockquote>\n<p>(the evaluation of <code>size</code> is really <code>this-&gt;size</code>)</p>\n</hr></hr>", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-09-04T10:59:59.357", "Id": "25660498", "Score": "14", "CreationDate": "2014-09-04T08:17:28.053", "LastActivityDate": "2014-09-04T10:59:59.357"}, "25662246": {"ParentId": "25660234", "CommentCount": "5", "Body": "<p>It doesn't have to be static, it has to be constant.</p>\n<p>When you declare a constant inside a class you will be making a constant <strong>for each</strong> instance of the class. </p>\n<p>Also if your <code>maxSize</code> is just <code>const</code> you would have to intialize it in the constructor initializer list because <code>const maxSize</code> is treated as variable whose value you can't change. </p>\n<p>Inside a class <code>const</code>\nkeyword means \"This is a constant during the hole lifetime of this object\". <strong>Different objects of the same class can have different values for that constant.</strong></p>\n<p>But when it is a static constant there will be <strong>only one constant</strong> for all instances of the class. This means that you have to initialize constants value on the same line where you are defining it.</p>\n", "OwnerUserId": "3478972", "PostTypeId": "2", "Id": "25662246", "Score": "1", "CreationDate": "2014-09-04T09:45:53.110", "LastActivityDate": "2014-09-04T09:45:53.110"}, "25665411": {"ParentId": "25660234", "CommentCount": "0", "Body": "<p>There are two aspects to this question</p>\n<p>Aspect 1</p>\n<p>C++ array is of fixed size, the size of which needs to be known during compile time. If the decision needs to be deferred during runtime, the array expression becomes ill-formed.</p>\n<p>Aspect 2</p>\n<p>Declaring a member variable as non-static makes it an  instance variable, the value of which only exist once the object is instantiated which is done during run-time. A static variable is a class variable, the value of which can be determined during compile time. </p>\n<p>Your particular example becomes the classic chicken-egg paradox.</p>\n<pre><code>class armon\n{\n    static const int maxSize=10;    \n\n    int array[maxSize];\n\n}\n</code></pre>\n<ul>\n<li>In order to instantiate your class <code>armon</code>, you need to know its size. </li>\n<li>In order to know its size, you need to know the size of individual members. In your particular case, you need to know the size of the array. </li>\n<li>In order to know the size of the array, you need to know the value of the dependent variable maxSize. </li>\n<li>In order to  access the dependent variable maxSize you need to instantiate the class  <code>armon</code>.</li>\n<li>In order to instantiate your class <code>armon</code>, you need to know its size. </li>\n</ul>\n<p>So, your array size dependent variable should be a constant expression, which in your particular case should be a static variable, </p>\n", "OwnerUserId": "977038", "PostTypeId": "2", "Id": "25665411", "Score": "5", "CreationDate": "2014-09-04T12:22:24.450", "LastActivityDate": "2014-09-04T12:22:24.450"}, "25660234": {"CommentCount": "0", "AcceptedAnswerId": "25665411", "PostTypeId": "1", "LastEditorUserId": "3510483", "CreationDate": "2014-09-04T08:02:26.527", "LastActivityDate": "2014-09-04T12:22:24.450", "LastEditDate": "2014-09-04T09:38:38.430", "ViewCount": "880", "FavoriteCount": "0", "Title": "Why does this variable need to be static?", "Id": "25660234", "Score": "8", "Body": "<pre><code>class armon\n{\n    static const int maxSize=10;    \n\n    int array[maxSize];\n\n    int count=0;\n\n    int* topOfStack=array;\n}\n</code></pre>\n<p>Why does <code>maxSize</code> need to be <code>static</code> for it to be used inside array? </p>\n", "Tags": "<c++><arrays><static><member>", "OwnerUserId": "4006148", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_25660234_25660498_2": {"section_id": 6185, "quality": 0.8888888888888888, "length": 8}, "so_25660234_25660498_0": {"section_id": 3228, "quality": 0.8461538461538461, "length": 11}, "so_25660234_25660498_1": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_25660234_25660498_0": {"section_id": 3101, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_25660234_25660498_2": {"section_id": 7687, "quality": 0.8888888888888888, "length": 8}, "so_25660234_25660498_0": {"section_id": 3985, "quality": 0.9230769230769231, "length": 12}, "so_25660234_25660498_1": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}}}});