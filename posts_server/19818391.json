post_cb({"19819308": {"ParentId": "19818391", "Score": "3", "CreationDate": "2013-11-06T17:58:20.603", "LastActivityDate": "2013-11-06T19:02:27.650", "LastEditDate": "2013-11-06T19:02:27.650", "OwnerUserId": "1137388", "LastEditorUserId": "1137388", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_19818391_19819308_1\">Is this an issue with newer versions of g++ or is my code in fact wrong?</p>\n</blockquote>\n</blockquote>\n<p>I guess this is legal code (but I'm not so sure). To add to the list: it does compile with clang 3.3 and icc 13.1.3.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19818391_19819308_3\">how would one go about resolving such an ambiguity?</p>\n</blockquote>\n</blockquote>\n<p>You can use</p>\n<pre><code>    int (* const f_ptr)(Dummy&lt; int &gt; const&amp;) = f&lt;int&gt;;\n</code></pre>\n<p>to select the second overload or</p>\n<pre><code>    int (* const f_ptr)(Dummy&lt; int &gt; const&amp;) = f&lt;Dummy&lt;int&gt; &gt;;\n</code></pre>\n<p>to select the first one.</p>\n<p>If you don't want to manually disambiguate (like my suggestion above) I can suggest a workaround that uses SFINAE to disambiguate. I'm assuming you can use C++11 (default template arguments for function templates) but I believe with some extra work it can be extended to C++98.</p>\n<p>Change the definitions of <code>f</code> to:</p>\n<pre><code>template &lt; class T, class R = typename T::value_type&gt;\nR f (const T&amp;) {\n    return x.value;\n}\n\ntemplate &lt; class T, class R = T&gt;\nR f (Dummy&lt; T &gt; const&amp;) {\n    return x.value + 1;\n}\n</code></pre>\n<p>With this, the original line (below) compiles fine in gcc (4.7.3 and 4.8.1):</p>\n<pre><code>int (* const f_ptr)(Dummy&lt; int &gt; const&amp;) = f;\n</code></pre>\n", "Id": "19819308", "PostTypeId": "2", "CommentCount": "1"}, "19818391": {"Tags": "<c++><gcc><type-conversion><function-pointers><function-overloading>", "ViewCount": "590", "LastEditDate": "2013-11-06T17:59:39.560", "CreationDate": "2013-11-06T17:13:46.233", "LastEditorUserId": "1137388", "Title": "Converting overloaded function is ambiguous", "CommentCount": "3", "AcceptedAnswerId": "19819308", "Score": "6", "OwnerUserId": "2961413", "Id": "19818391", "LastActivityDate": "2013-11-06T19:02:27.650", "Body": "<p>I have an issue where creating a function pointer to an overloaded function results in a compile error on g++ 4.7 and g++ 4.8 but not on g++ 4.4, g++ 4.6 or clang++ 3.2 (and possibly VS2010).</p>\n<p>Having googled around a bit to find out whether the issue is with g++ or with my code, I still can't decide.\nAre the overload resolution rules that apply to function pointer conversion different than those that apply to function calls?</p>\n<p>This is a somewhat minimized code that demonstrates the issue:</p>\n<pre><code>template &lt; class T &gt;\nstruct Dummy {\n    typedef T value_type;\n    value_type value;\n};\n\ntemplate &lt; class T &gt;\ntypename T::value_type f (const T&amp; x) {\n    return x.value;\n}\n\ntemplate &lt; class T &gt;\nT f (Dummy&lt; T &gt; const&amp; x) {\n    return x.value + 1;\n}\n\nint main (int, char**) {\n    Dummy&lt; int &gt; d = { 1 };\n    // No ambiguity here\n    d.value = f(d);\n    // This is ambiguous for *some* compilers\n    int (* const f_ptr)(Dummy&lt; int &gt; const&amp;) = f;\n    return f_ptr( d );\n}\n</code></pre>\n<p>clang++ 3.2, g++ 4.4 and g++ 4.6 compile this with <code>-Wall -pedantic --std=c++98</code> without warnings.</p>\n<p>g++ 4.7 and g++ 4.8 however give the following error message:</p>\n<pre><code>test.cc: In function \u2018int main(int, char**)\u2019:\ntest.cc:15:45: error: converting overloaded function \u2018f\u2019 to type \u2018int (* const)(const struct Dummy&lt;int&gt;&amp;)\u2019 is ambiguous\ntest.cc:6:18: error: candidates are: typename T::Type f(const T&amp;) [with T = Dummy&lt;int&gt;; typename T::Type = int]\ntest.cc:9:3: error:                 T f(const Dummy&lt;T&gt;&amp;) [with T = int]\n</code></pre>\n<p>Is this an issue with newer versions of g++ or is my code in fact wrong?</p>\n<p>If it is, how would one go about resolving such an ambiguity?</p>\n", "PostTypeId": "1", "FavoriteCount": "1", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_19818391_19819308_3": {"length": 4, "section_id": 7709, "quality": 0.5714285714285714}, "so_19818391_19819308_2": {"length": 4, "section_id": 7709, "quality": 0.5714285714285714}}}});