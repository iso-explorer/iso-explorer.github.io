post_cb({"23119870": {"Id": "23119870", "PostTypeId": "2", "Body": "<p>Avoid casts at any time - it usually means that something is going wrong.</p>\n<p>In you example your are trying to convert an object to have more powers that it processes.</p>\n<p>It is like saying to somebody this vehicle is a lorry and point to a car.</p>\n<p>It will end in tears when a Trebant arrives not a wagon</p>\n", "LastActivityDate": "2014-04-16T20:51:12.717", "CommentCount": "0", "CreationDate": "2014-04-16T20:51:12.717", "ParentId": "23119795", "Score": "0", "OwnerUserId": "892256"}, "bq_ids": {"n4140": {"so_23119795_23120251_1": {"length": 52, "quality": 0.8125, "section_id": 5768}}, "n3337": {"so_23119795_23120251_1": {"length": 52, "quality": 0.8125, "section_id": 5541}}, "n4659": {"so_23119795_23120251_1": {"length": 52, "quality": 0.8125, "section_id": 7225}}}, "23119817": {"Id": "23119817", "PostTypeId": "2", "Body": "<p>It's because undefined behavior can have unexpected results, including appearing to work.</p>\n<p>Anything can happen, this is undefined behavior. What probably actually does happen is that <code>B::c()</code> uses the location where <code>B::x</code> would have been stored in a <code>B</code> instance, right after<sup>1</sup> the <code>A</code> subobject. And it overwrites memory belonging to some other object. In your case, the value was previously <code>0</code> and became <code>1</code>, but it could have been whatever value was put there by the real owner of that location.</p>\n<p><sup>(1)</sup> If the compiler implements the empty base class optimization, <code>B::x</code> and the <code>B::A</code> subobject could actually overlap.</p>\n<hr>\n<p>If you're asking why the compiler doesn't prevent it, it's because you've overridden type checking by using a <code>static_cast</code>.  Of all the casts, only <code>dynamic_cast</code> pays any attention to the true type of the object, and even that is easy to break.</p>\n<p>You're composing two operations which are well-defined in a very unsafe way.</p>\n<ul>\n<li>The compiler can't stop you from casting an <code>A*</code> to a <code>B*</code>, even when it knows there is no <code>B</code> object, because that <code>B*</code> is perfectly useful for the solitary purpose of casting back again.</li>\n<li>And it can't stop you from using a <code>B*</code> to access <code>B</code> members.</li>\n</ul>\n<p>The problem is that you used this \"fake\" <code>B*</code> for something other than casting back to its true type.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2014-04-16T20:58:42.390", "Score": "6", "CreationDate": "2014-04-16T20:48:02.670", "ParentId": "23119795", "CommentCount": "4", "OwnerUserId": "103167", "LastEditDate": "2014-04-16T20:58:42.390"}, "23120251": {"Id": "23120251", "PostTypeId": "2", "Body": "<p>dynamic_cast can provide information about success or failure (if you have at least one virtual function which I assume that your real program would have), but static_cast cannot.  static_cast doesn't use Run Time Type Identification.  There are legitimate reasons for casting, but you need to follow the rules in order to avoid undefined behavior.</p>\n<p>Prefer dynamic cast over static cast when downcasting.  Of course I have no idea why someone would write a program with inheritance and not one single virtual function (unless it is just a simple example for demonstrating a problem), but maybe there is a usecase or a reason for doing that.\n<a href=\"http://en.cppreference.com/w/cpp/language/dynamic_cast\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/dynamic_cast</a></p>\n<p>If you absolutely must use static_cast, then you need to follow the rules about when it makes sense to do so.  Unfortunately static_cast will not provide you with exception or failure notification so it must be used cautiously.\n<a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/static_cast</a></p>\n<blockquote>\n<p id=\"so_23119795_23120251_0\">2) If new_type is a pointer or reference to some class D and the type\n  of expression is a pointer or reference to its non-virtual base B,\n  static_cast performs a downcast. Such static_cast makes no runtime\n  checks to ensure that the object's runtime type is actually D, and may\n  only be used safely if this precondition is guaranteed by other means,\n  such as when implementing static polymorphism. Safe downcast may be\n  done with dynamic_cast.</p>\n</blockquote>\n<p>To address your question about why your example appears to work, allow me to quote the ANSI std.</p>\n<blockquote>\n<p id=\"so_23119795_23120251_1\">1.3.24 [defns.unde\ufb01ned] unde\ufb01ned behavior behavior for which this International Standard imposes no requirements [ Note: Unde\ufb01ned\n  behavior may be expected when this International Standard omits any\n  explicit de\ufb01nition of behavior or when a program uses an erroneous\n  construct or erroneous data. Permissible unde\ufb01ned behavior ranges from\n  ignoring the situation completely with unpredictable results, to\n  behaving during translation or program execution in a documented\n  manner characteristic of the environment (with or without the issuance\n  of a diagnostic message), to terminating a translation or execution\n  (with the issuance of a diagnostic message). Many erroneous program\n  constructs do not engender unde\ufb01ned behavior; they are required to be\n  diagnosed. \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "2993440", "LastActivityDate": "2014-04-16T21:41:23.547", "Score": "1", "CreationDate": "2014-04-16T21:13:07.820", "ParentId": "23119795", "CommentCount": "2", "OwnerUserId": "2993440", "LastEditDate": "2014-04-16T21:41:23.547"}, "23119795": {"ViewCount": "114", "Body": "<p>I have some problem with understanding the code below. Why am I able to call c() function? </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\n\nusing namespace std;\n\nclass A\n{};\n\nclass B : public A\n{\n public:\n  void c() { cout &lt;&lt; \"c: B\" &lt;&lt; ++x &lt;&lt; endl; }   \n  int x;\n};\n\nint main(void) {\n  class A *a = new A();\n  static_cast&lt;B*&gt;(a)-&gt;c();\n\n  return 0;\n}\n</code></pre>\n<p>The ouptut is:</p>\n<pre><code>constr A\nc: B1\n</code></pre>\n", "AcceptedAnswerId": "23119817", "Title": "Understanding static_cast", "CreationDate": "2014-04-16T20:46:41.083", "Id": "23119795", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-04-16T21:41:23.547", "Score": "0", "OwnerUserId": "1273055", "Tags": "<c++><static-cast>", "AnswerCount": "3"}});