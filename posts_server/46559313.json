post_cb({"bq_ids": {"n4140": {"so_46559313_46559427_3": {"length": 7, "quality": 0.875, "section_id": 457}, "so_46559313_46559427_4": {"length": 24, "quality": 0.96, "section_id": 457}, "so_46559313_46559427_2": {"length": 6, "quality": 1.0, "section_id": 3270}, "so_46559313_46559427_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 457}}, "n3337": {"so_46559313_46559427_3": {"length": 7, "quality": 0.875, "section_id": 448}, "so_46559313_46559427_4": {"length": 21, "quality": 0.84, "section_id": 448}, "so_46559313_46559427_2": {"length": 6, "quality": 1.0, "section_id": 3142}, "so_46559313_46559427_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 448}}, "n4659": {"so_46559313_46559427_3": {"length": 7, "quality": 0.875, "section_id": 480}, "so_46559313_46559427_4": {"length": 24, "quality": 0.96, "section_id": 480}, "so_46559313_46559427_2": {"length": 6, "quality": 1.0, "section_id": 4028}, "so_46559313_46559427_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 480}}}, "46559427": {"Id": "46559427", "PostTypeId": "2", "Body": "<p>You are in the right sections, but are overlooking some crucial bullets.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.fct.def.default#1\" rel=\"noreferrer\">[dcl.fct.def.default]/1</a>:</p>\n<blockquote>\n<p id=\"so_46559313_46559427_0\">A function definition of the form:</p>\n<p id=\"so_46559313_46559427_1\">...</p>\n<p id=\"so_46559313_46559427_2\">is called an <em>explicitly-defaulted</em> definition. A function that is\n  explicitly defaulted shall</p>\n<ul>\n<li><strong>have the same declared function type</strong> (except for possibly differing ref-qualifiers and except that in the case of a copy\n  constructor or copy assignment operator, <strong>the parameter type may be\n  \u201creference to non-const T\u201d, where T is the name of the member\n  function's class</strong>) <strong>as if it had been implicitly declared</strong>, and</li>\n</ul>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.copy.ctor#7\" rel=\"noreferrer\">[class.copy.ctor]/7</a>:</p>\n<blockquote>\n<p id=\"so_46559313_46559427_3\">The implicitly-declared copy constructor for a class X will have the\n  form</p>\n<pre><code>X::X(const X&amp;)\n</code></pre>\n<p id=\"so_46559313_46559427_4\">if each potentially constructed subobject of a class type M (or array\n  thereof) has a copy constructor whose first parameter is of type const\n  M&amp; or const volatile M&amp;.<sup><strong>119</strong></sup> Otherwise, the implicitly-declared copy\n  constructor will have the form</p>\n<pre><code>X::X(X&amp;)\n</code></pre>\n<p id=\"so_46559313_46559427_5\">...<br>\n<sub>119) This implies that the reference parameter of the implicitly-declared copy constructor cannot bind to a volatile lvalue; </sub></br></p>\n</blockquote>\n<p>When the above is summed up, your only two options for explicitly defaulting a copy c'tor are these:</p>\n<pre><code>struct A {\n   A(const A&amp;) = default;\n};\n\nstruct B {\n   B(B&amp;) = default;\n};\n</code></pre>\n<p>When the standard says <code>A(const volatile A&amp;)</code> is a copy constructor. It means that a <em>user-provided</em> c'tor with such a parameter can be the classes copy c'tor. </p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-10-04T08:05:58.300", "Score": "8", "CreationDate": "2017-10-04T07:36:29.050", "ParentId": "46559313", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-10-04T08:05:58.300"}, "46559313": {"ViewCount": "99", "Body": "<p>I could not find where in the standard it is stated that it is forbidden to explicitly default a copy-constructor and copy-assignment with a <code>volatile&amp;</code> or <code>const volatile&amp;</code> argument, like this:</p>\n<pre><code>struct A{\n   A(const volatile A&amp;) =default; // fails to compile on (all) compilers\n   };\n</code></pre>\n<p>In [dcl.fct.def.default] there is no such a restriction, while [class.copy] specifies that <code>A(const volatile A&amp;)</code> is a copy constructor.</p>\n<p>Note: I am just looking for the location in the text of the standard which specifies this behavior.</p>\n", "AcceptedAnswerId": "46559427", "Title": "Why is it impossible to explicitly default a copy constructor with volatile argument?", "CreationDate": "2017-10-04T07:29:19.753", "Id": "46559313", "CommentCount": "0", "LastEditDate": "2017-10-04T10:22:45.377", "PostTypeId": "1", "LastEditorUserId": "817643", "LastActivityDate": "2017-10-04T10:22:45.377", "Score": "4", "OwnerUserId": "5632316", "Tags": "<c++><language-lawyer><copy-constructor><volatile>", "AnswerCount": "1"}});