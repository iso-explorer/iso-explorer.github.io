post_cb({"15680489": {"CommentCount": "3", "AcceptedAnswerId": "15680881", "PostTypeId": "1", "LastEditorUserId": "2219418", "CreationDate": "2013-03-28T11:22:27.967", "LastActivityDate": "2013-03-28T21:02:44.950", "LastEditDate": "2013-03-28T12:11:46.960", "ViewCount": "481", "FavoriteCount": "3", "Title": "Move semantics & argument evaluation order", "Id": "15680489", "Score": "23", "Body": "<p>Considering the following:</p>\n<pre><code>std::string make_what_string( const std::string &amp;id );\n\nstruct basic_foo\n{\n    basic_foo( std::string message, std::string id );\n};\n\nstruct foo\n    : public basic_foo\n{\n    foo::foo( std::string id)\n        : basic_foo( make_what_string( id ), std::move( id ) ) // Is this valid?\n    {\n    }\n};\n</code></pre>\n<p>Because parameter evaluation order in C++ is unspecified, I'm wondering if\nthe line </p>\n<pre><code>basic_foo( make_what_string( id ), std::move( id ) )\n</code></pre>\n<p>in above code is valid.</p>\n<p>I know that <code>std::move</code> is nothing more than a cast, but when is the std::string\nmove ctor executed? After all arguments have been evaluated and it's time to call\nthe base constructor? Or is this done during evaluation of the parameters? In\nother words:</p>\n<p>Does the compiler do this:</p>\n<pre><code>std::string &amp;&amp;tmp2 = std::move(id);\nstd::string tmp1 = make_what_string(id);\nbasic_foo(tmp1, tmp2);\n</code></pre>\n<p>which is valid. Or this:</p>\n<pre><code>std::string tmp2 = std::move(id);\nstd::string tmp1 = make_what_string(id);\nbasic_foo(tmp1, tmp2);\n</code></pre>\n<p>which is invalid. Note that in both cases the order is the \"unexpected\"\none.</p>\n", "Tags": "<c++><c++11><move-semantics><order-of-evaluation>", "OwnerUserId": "2219418", "AnswerCount": "2"}, "15680672": {"ParentId": "15680489", "CommentCount": "5", "Body": "<p>It's not really valid. The order of function argument evaluation is unspecified. In other words, you don't know whether the compiler will choose this sequence:</p>\n<pre><code>tmp1 = make_what_string(id);\ntmp2 = std::move(id);\nbasic_foo(tmp1, tmp2);\n</code></pre>\n<p>or this one:</p>\n<pre><code>tmp1 = std::move(id);\ntmp2 = make_what_string(id);  //id has already been moved from!\nbasic_foo(tmp2, tmp1);\n</code></pre>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "15680672", "Score": "7", "CreationDate": "2013-03-28T11:32:00.793", "LastActivityDate": "2013-03-28T11:32:00.793"}, "bq_ids": {"n4140": {"so_15680489_15680881_4": {"section_id": 1569, "quality": 1.0, "length": 6}, "so_15680489_15680881_3": {"section_id": 5991, "quality": 0.7272727272727273, "length": 16}, "so_15680489_15680881_2": {"section_id": 5991, "quality": 0.9, "length": 9}, "so_15680489_15680881_1": {"section_id": 5811, "quality": 0.925, "length": 37}, "so_15680489_15680881_0": {"section_id": 5811, "quality": 1.0, "length": 11}}, "n3337": {"so_15680489_15680881_4": {"section_id": 1564, "quality": 1.0, "length": 6}, "so_15680489_15680881_1": {"section_id": 5584, "quality": 0.925, "length": 37}, "so_15680489_15680881_2": {"section_id": 5759, "quality": 0.9, "length": 9}, "so_15680489_15680881_3": {"section_id": 5759, "quality": 0.7272727272727273, "length": 16}, "so_15680489_15680881_0": {"section_id": 5584, "quality": 1.0, "length": 11}}, "n4659": {"so_15680489_15680881_4": {"section_id": 1718, "quality": 1.0, "length": 6}, "so_15680489_15680881_2": {"section_id": 7491, "quality": 0.9, "length": 9}, "so_15680489_15680881_1": {"section_id": 7273, "quality": 0.7, "length": 28}, "so_15680489_15680881_0": {"section_id": 7272, "quality": 1.0, "length": 11}}}, "15680881": {"ParentId": "15680489", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>See section 1.9:</p>\n<blockquote>\n<p id=\"so_15680489_15680881_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_15680489_15680881_1\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [ <em>Note</em>: Value computations and side effects associated with different argument expressions are unsequenced. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>I think the problem is that it's not very clear whether the initialization of the parameters is considered a side effect associated with the argument expressions. However, it appears to be backed up by section 5.2.2:</p>\n<blockquote>\n<p id=\"so_15680489_15680881_2\">The initialization and destruction of each parameter occurs within the context of the\n  calling function.</p>\n</blockquote>\n<p>And there's also a note in the same paragraph that makes it a little clearer:</p>\n<blockquote>\n<p id=\"so_15680489_15680881_3\">When a function is called, each parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding argument. [ <em>Note</em>: Such initializations are indeterminately sequenced with respect to each other (1.9) \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>So yes, the initialization of the arguments are indeterminately sequenced with respect to each other. The initializations might occur in either of these orders:</p>\n<pre><code>std::string message = make_what_string(id);\nstd::string id = std::move( id );\n\nstd::string id = std::move( id );\nstd::string message = make_what_string(id);\n</code></pre>\n<p>In the second case, <code>make_what_string</code> ends up working with a moved-from string.</p>\n<p>So, even though <code>std::move</code> doesn't actually move anything, the important thing is that the actual <em>moving</em> is also unsequenced with respect to the other argument.</p>\n<p>The definition of the move constructor of <code>basic_string(basic_string&amp;&amp; str)</code> states:</p>\n<blockquote>\n<p id=\"so_15680489_15680881_4\">[...] <code>str</code> is left in a valid state with an unspecified value.</p>\n</blockquote>\n<p>So you don't have undefined behaviour, you have unspecified behaviour.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-03-28T21:02:44.950", "Id": "15680881", "Score": "16", "CreationDate": "2013-03-28T11:43:15.457", "LastActivityDate": "2013-03-28T21:02:44.950"}});