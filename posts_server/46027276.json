post_cb({"46027276": {"CommentCount": "3", "AcceptedAnswerId": "46027318", "CreationDate": "2017-09-03T19:48:22.423", "LastActivityDate": "2017-09-03T21:28:58.417", "PostTypeId": "1", "ViewCount": "806", "FavoriteCount": "6", "Title": "Can non-type template parameters in c++17 be decltype(auto)?", "Id": "46027276", "Score": "36", "Body": "<p>I discovered that gcc and clang allow to use <code>decltype(auto)</code> in non-type template parameter type clause. E.g.:</p>\n<pre><code>template &lt;decltype(auto)&gt;\nstruct X {};\n\nint foo ;\n\nint main() {\n    X&lt;(foo)&gt; x;\n    static_cast&lt;void&gt;(x);\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/WjMznykm1OHne1WP\" rel=\"noreferrer\">[live demo gcc]</a> <a href=\"https://wandbox.org/permlink/MTmKJb5JOmsOfeJx\" rel=\"noreferrer\">[live demo clang]</a></p>\n<p>Is it standard compliant feature or is it some gnu extension?</p>\n", "Tags": "<c++><templates><language-lawyer><c++1z>", "OwnerUserId": "4324224", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46027276_46027318_0": {"section_id": 57, "quality": 1.0, "length": 8}, "so_46027276_46027318_1": {"section_id": 5445, "quality": 0.5294117647058824, "length": 18}}, "n3337": {"so_46027276_46027318_0": {"section_id": 52, "quality": 1.0, "length": 8}}, "n4659": {"so_46027276_46027318_0": {"section_id": 59, "quality": 1.0, "length": 8}, "so_46027276_46027318_1": {"section_id": 6872, "quality": 0.8823529411764706, "length": 30}, "so_46027276_46027318_2": {"section_id": 6876, "quality": 1.0, "length": 12}}}, "46027318": {"ParentId": "46027276", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is standard. First, for a non-type template parameter:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.param#4\" rel=\"noreferrer\">[temp.param/4]</a></p>\n<blockquote>\n<p id=\"so_46027276_46027318_0\">A non-type template-parameter shall have one of the following\n  (optionally cv-qualified) types:</p>\n<ul>\n<li>...</li>\n<li>a type that contains a <strong>placeholder type</strong>.</li>\n</ul>\n</blockquote>\n<p>Where placeholder types have the following specified:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.spec.auto#1\" rel=\"noreferrer\">[dcl.spec.auto/1]</a></p>\n<blockquote>\n<p id=\"so_46027276_46027318_1\"><strong>The auto and decltype(auto) type-specifiers are used to designate a\n  placeholder type</strong> that will be replaced later by deduction from an\n  initializer. The auto type-specifier is also used to introduce a\n  function type having a trailing-return-type or to signify that a\n  lambda is a generic lambda ([expr.prim.lambda.closure]). The auto\n  type-specifier is also used to introduce a structured binding\n  declaration.</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.spec.auto#1\" rel=\"noreferrer\">[dcl.spec.auto/5]</a></p>\n<blockquote>\n<p id=\"so_46027276_46027318_2\"><strong>A placeholder type can also be used</strong> in the type-specifier-seq in the\n  new-type-id or type-id of a new-expression and <strong>as a decl-specifier of\n  the parameter-declaration's decl-specifier-seq in a\n  template-parameter.</strong></p>\n</blockquote>\n<p>Since the bullet above says \"placeholder type\", and such a type can be designated either with <code>auto</code> or <code>decltype(auto)</code>, both compilers are correct. </p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-09-03T21:28:58.417", "Id": "46027318", "Score": "28", "CreationDate": "2017-09-03T19:54:31.457", "LastActivityDate": "2017-09-03T21:28:58.417"}});