post_cb({"bq_ids": {"n4140": {"so_40577808_40577869_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}, "so_40577808_40577869_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 7194}}, "n3337": {"so_40577808_40577869_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}, "so_40577808_40577869_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 6938}}, "n4659": {"so_40577808_40577869_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_40577808_40577869_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 8703}}}, "40577835": {"Id": "40577835", "PostTypeId": "2", "Body": "<p>None of the examples you've shown are undefined behavior. They are perfectly defined.</p>\n<p>The class instance exists until the destructor returns. The object's members get destroyed not before the destructor gets called, but after it returns. As such, modifying the members of the class, in the destructor, is completely kosher. And the superclass does not get destroyed until the subclass gets completely destroyed, so modifying the superclass's members is perfectly fine, too.</p>\n<p>Very generally speaking, an object gets destroyed by the following process:</p>\n<ol>\n<li>The destructor gets called.</li>\n<li>The class members get destroyed, in reverse order of their initial construction.</li>\n<li>Steps 1 and 2 are repeated for the object's superclasses.</li>\n</ol>\n<p>(I am ignoring virtual inheritance, for simplicity, and it's not relevant here).</p>\n", "LastActivityDate": "2016-11-13T19:18:42.223", "CommentCount": "0", "CreationDate": "2016-11-13T19:18:42.223", "ParentId": "40577808", "Score": "2", "OwnerUserId": "3943312"}, "40577808": {"ViewCount": "81", "Body": "<p>For example:</p>\n<pre><code>struct B { int b_; };\nstruct D : B\n{\n    ~D()\n    { // D object's lifetime ends here\n        d_ = 0;  // (1) undefined behavior?\n        b_ = 0;  // (2) undefined behavior also?\n    }\n    int d_;\n};\n</code></pre>\n<p>The <a href=\"http://eel.is/c++draft/basic.life#1\" rel=\"nofollow noreferrer\">C++ Standard defines</a> that for an object of type <code>D</code>, its <strong>lifetime ends</strong> when the destructor <code>~D()</code> call <strong>starts</strong>.</p>\n<p>Can we interpret this to mean that modifying the object inside the destructor, as in (1), results in undefined behavior?</p>\n<p>If so, does the same apply if we modify the base class subobject of <code>D</code>, as in (2)?</p>\n", "AcceptedAnswerId": "40577869", "Title": "Does modifying class member objects in the destructor result in undefined behavior?", "CreationDate": "2016-11-13T19:15:53.517", "Id": "40577808", "CommentCount": "11", "LastEditDate": "2016-11-13T19:47:54.180", "PostTypeId": "1", "LastEditorUserId": "4973224", "LastActivityDate": "2016-11-13T19:47:54.180", "Score": "2", "OwnerUserId": "4973224", "Tags": "<c++><language-lawyer><destructor><undefined-behavior><lifetime>", "AnswerCount": "2"}, "40577869": {"Id": "40577869", "PostTypeId": "2", "Body": "<p>Neither access is undefined, they're both perfectly okay.</p>\n<p>While you're right that the lifetime ends when the destructor starts, you can still use the object in limited ways, defined as:</p>\n<blockquote>\n<p id=\"so_40577808_40577869_0\">N4140 \u00a7 3.8 [basic.life] / 6</p>\n<p id=\"so_40577808_40577869_1\">Similarly, before the lifetime of an\n  object has started but after the storage which the object will occupy\n  has been allocated or, after the lifetime of an object has ended and\n  before the storage which the object occupied is reused or released,\n  any glvalue that refers to the original object may be used but only in\n  limited ways. <em>For an object under construction or destruction, see\n  [class.cdtor]</em>.</p>\n</blockquote>\n<p>and [class.cdtor]: </p>\n<blockquote>\n<p id=\"so_40577808_40577869_2\">N4140 \u00a7 12.7 [class.cdtor] /1</p>\n<p id=\"so_40577808_40577869_3\">For an object with a non-trivial destructor, referring to any\n  non-static member or base class of the object after the destructor\n  finishes execution results in undefined behavior.</p>\n</blockquote>\n<p>The above clearly states that only after the destructor finishes you can't touch members of that object.</p>\n", "LastActivityDate": "2016-11-13T19:22:09.110", "CommentCount": "1", "CreationDate": "2016-11-13T19:22:09.110", "ParentId": "40577808", "Score": "6", "OwnerUserId": "2456565"}});