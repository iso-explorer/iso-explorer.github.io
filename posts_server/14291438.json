post_cb({"bq_ids": {"n4140": {"so_14291438_14291520_0": {"length": 35, "quality": 0.875, "section_id": 179}}, "n3337": {"so_14291438_14291520_0": {"length": 35, "quality": 0.875, "section_id": 173}}, "n4659": {"so_14291438_14291520_0": {"length": 35, "quality": 0.875, "section_id": 184}}}, "14293117": {"Id": "14293117", "PostTypeId": "2", "Body": "<p>This is nonconformant behavior as of C++11 because C++11 says that the injected class name (which is a name automatically declared within the class body) is a template when it is passed to a template template parameter. So your code should  only fail in a C++03 implementation.</p>\n<p>However there is no need to open a bug report about this now. I have already done it way back.</p>\n", "LastActivityDate": "2013-01-12T12:00:24.043", "CommentCount": "2", "CreationDate": "2013-01-12T12:00:24.043", "ParentId": "14291438", "Score": "1", "OwnerUserId": "34509"}, "14291438": {"ViewCount": "325", "Body": "<p>It seems that clang++ (I tried clang 3.2) treats the name of a template class as a instantiated class, not a template for any occurence within the class scope. For example, the following codes</p>\n<pre><code>template &lt;template &lt;class&gt; class T&gt;\nclass A {};\n\ntemplate &lt;typename T&gt;\nclass B {\n    A&lt;B&gt; member;\n   // ^---- clang++ treats B as an instantiated class\n         // but I want it to be a template here\n         // this code could compile in g++\n};\n\nint main()\n{\n    B&lt;int&gt; b;\n    return 0;\n}\n</code></pre>\n<p>What should I do to compile that?</p>\n", "AcceptedAnswerId": "14291520", "Title": "clang++ - treat template class name as template in the class scope", "CreationDate": "2013-01-12T07:52:29.940", "Id": "14291438", "CommentCount": "0", "LastEditDate": "2013-01-12T08:02:03.237", "PostTypeId": "1", "LastEditorUserId": "555515", "LastActivityDate": "2013-01-12T13:01:09.713", "Score": "4", "OwnerUserId": "555515", "Tags": "<c++><templates><clang++>", "AnswerCount": "2"}, "14291520": {"Id": "14291520", "PostTypeId": "2", "Body": "<h1>C++03</h1>\n<p>Resolving <code>B</code> that way (called the <em>injected-class-name</em>, an implicitly-declared member of every class including template instantiations) is intended as a convenience. I've never seen it get in the way like that!</p>\n<p>To work around, qualify the name by adding <code>::</code> before it (and if necessary, the name of the namespace).</p>\n<pre><code>template &lt;typename T&gt;\nclass B {\n    A&lt; ::B&gt; member; // whitespace required to prevent digraph; see comments\n};\n</code></pre>\n<h1>C++11</h1>\n<p>C++11 \u00a714.6.1/1 specifies (emphasis mine)</p>\n<blockquote>\n<p id=\"so_14291438_14291520_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected- class-name can be used as a template-name or a type-name. When it is used with a template-argument-list, <strong>as a template-argument for a template template-parameter,</strong> or as the final identifier in the elaborated-type- specifier of a friend class template declaration, <strong>it refers to the class template itself.</strong> Otherwise, it is equivalent to the template-name followed by the template-parameters of the class template enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>Therefore, if this problem occurs under C++11 it is a compiler bug. Workaround as above.</p>\n<p>Note \u2014 for comparison, the corresponding paragraph in C++03 is</p>\n<blockquote>\n<p id=\"so_14291438_14291520_1\">Like normal (non-template) classes, class templates have an injected-class-name (clause 9). The injected- class-name can be used with or without a template-argument-list. When it is used without a template- argument-list, it is equivalent to the injected-class-name followed by the template-parameters of the class template enclosed in &lt;&gt;. When it is used with a template-argument-list, it refers to the specified class template specialization, which could be the current specialization or another specialization.</p>\n</blockquote>\n<p>As you can see, there's already one special case allowing the identifier to be a class or template, depending on whether it occurs in a template-name. They just added a couple more cases.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-01-12T13:01:09.713", "Score": "3", "CreationDate": "2013-01-12T08:05:24.837", "ParentId": "14291438", "CommentCount": "4", "OwnerUserId": "153285", "LastEditDate": "2013-01-12T13:01:09.713"}});