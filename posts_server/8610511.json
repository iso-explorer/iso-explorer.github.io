post_cb({"bq_ids": {"n4140": {"so_8610511_8610842_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 620}}, "n3337": {"so_8610511_8610842_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 610}}, "n4659": {"so_8610511_8610842_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 646}}}, "8610842": {"Id": "8610842", "PostTypeId": "2", "Body": "<p><code>\u00a713.3.3.1.2 [over.ics.user] p1</code></p>\n<blockquote>\n<p id=\"so_8610511_8610842_0\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by <strong>a user-defined conversion</strong> (12.3) followed by a second standard conversion sequence.</p>\n</blockquote>\n<p>Notice the singular and the missing of the word \"sequence\". Only one user-defined conversion will ever be considered during an implicit conversion sequence.</p>\n", "LastActivityDate": "2011-12-22T23:27:12.313", "CommentCount": "2", "CreationDate": "2011-12-22T23:27:12.313", "ParentId": "8610511", "Score": "8", "OwnerUserId": "500104"}, "8610511": {"ViewCount": "629", "Body": "<p>I've got a class which I need to implicitly convert to a few things, with intermediate values, e.g.</p>\n<pre><code>struct outer {\n    struct inner {\n        operator T() { return T(); }\n    };\n    operator inner() { return inner(); }\n};\n</code></pre>\n<p>If I have this structure, is it <em>always</em> valid to do, e.g.</p>\n<pre><code>void f(T t);\nouter o;\nf(o);\n</code></pre>\n", "Title": "Chaining implicit conversion operators", "CreationDate": "2011-12-22T22:40:34.627", "LastActivityDate": "2011-12-23T06:16:03.940", "CommentCount": "4", "LastEditDate": "2011-12-23T05:40:04.910", "PostTypeId": "1", "LastEditorUserId": "963864", "Id": "8610511", "Score": "3", "OwnerUserId": "298661", "Tags": "<c++><c++11><implicit-conversion>", "AnswerCount": "2"}, "8612843": {"Id": "8612843", "PostTypeId": "2", "Body": "<p>This works:</p>\n<pre><code>struct Foo {}; // renamed T in Foo to avoid confusion!\n\nstruct outer {\n        struct inner {\n                operator Foo() { return Foo(); }\n        };\n\n        operator inner() { return inner(); }\n\n        template &lt;typename T&gt;\n        operator T () {\n                return operator inner();\n        }\n};\n\nint main() {\n        void f(Foo t);\n        outer o;\n        f(o);\n}\n</code></pre>\n<p>But only because <code>f</code> is not overloaded, so it is not really a solution.</p>\n", "LastActivityDate": "2011-12-23T06:16:03.940", "CommentCount": "2", "CreationDate": "2011-12-23T06:16:03.940", "ParentId": "8610511", "Score": "0", "OwnerUserId": "963864"}});