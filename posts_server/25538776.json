post_cb({"bq_ids": {"n4140": {"so_25538776_25538876_0": {"length": 39, "quality": 1.0, "section_id": 44}}, "n3337": {"so_25538776_25538876_0": {"length": 39, "quality": 1.0, "section_id": 41}}, "n4659": {"so_25538776_25538876_0": {"length": 39, "quality": 1.0, "section_id": 45}}}, "25538876": {"Id": "25538876", "PostTypeId": "2", "Body": "<p>Tthe pointer gets converted to another type, <em>boolean</em>, because it is a function pointer &amp; there is no overloads of <code>operator&lt;&lt;</code> in iostrem library for these types of argument (because there is infinite number of such types). The pointer points to some non-zero address because it has been initialized with address of function - so gets converted to 1 (only 0x0 address would give you boolean 0).</p>\n<h2>Solution</h2>\n<p>To assert correct behavior you should cast the pointer to void* so you can use <code>operator&lt;&lt;</code> overload for <code>void*</code> which <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow\">is</a></p>\n<pre><code>ostream &amp; operator &lt;&lt;( ostream &amp;, const void * );\n</code></pre>\n<p>Example:</p>\n<pre><code>void Function1(){}\n\nint main() {\n    void ( *a) () = &amp;Function1;\n    cout &lt;&lt; ( void*)( a) &lt;&lt; endl;\n    /* or better - being explicit about harshness of this design */\n    cout &lt;&lt; reinterpret_cast&lt; void*&gt; ( a) &lt;, endl;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/Fne4Mu\" rel=\"nofollow\">http://ideone.com/Fne4Mu</a></p>\n<hr>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 4.12 Boolean conversions [conv.bool]</p>\n<blockquote>\n<p id=\"so_25538776_25538876_0\">1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer\n  to member type can be converted to a prvalue of type bool. A zero\n  value, null pointer value, or null member pointer value is converted\n  to false; any other value is converted to true. A prvalue of type\n  std::nullptr_t can be converted to a prvalue of type bool; the\n  resulting value is false.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1141471", "LastActivityDate": "2014-08-28T01:24:53.873", "Score": "5", "CreationDate": "2014-08-28T00:14:27.247", "ParentId": "25538776", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-08-28T01:24:53.873"}, "25538776": {"ViewCount": "138", "Body": "<p>I'm developing a c++ program that is dealing with addresses for different variables and functions.</p>\n<p>When I compiled my program on a Linux based OS, all functions including the main get the address of 1 instead of an 8 digit hexa number like other variables, which did not happen in Windows.</p>\n<p>I wrote this small piece of code to explain the issue</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nvoid Function1();\nvoid Function1()\n{\n}\nint main()\n{\nint tmp;\nvoid (*a) ()=&amp;Function1;\ncout&lt;&lt;a&lt;&lt;endl;\ncout&lt;&lt;&amp;Function1&lt;&lt;endl;\ncout&lt;&lt;&amp;main&lt;&lt;endl;\nreturn 0;\n}\n</code></pre>\n<p>for all 3 cout calls, the output is 1 instead of the virtual address.</p>\n<p>I really appreciate your help guys</p>\n<p>Thanks in Advance\nAziz</p>\n", "Title": "on Linux, printing function addresses always prints 1 (c++)", "CreationDate": "2014-08-28T00:01:25.047", "LastActivityDate": "2014-08-28T01:24:53.873", "CommentCount": "4", "PostTypeId": "1", "Id": "25538776", "Score": "1", "OwnerUserId": "3984773", "Tags": "<c++><printing><cout><virtual-memory>", "AnswerCount": "3"}, "25538887": {"Id": "25538887", "PostTypeId": "2", "Body": "<p><code>&lt;&lt;</code> has no standard overload taking a function pointer; so instead, the pointer is converted to <code>bool</code> (since that's a legitimate implicit conversion), giving <code>1</code>, or <code>true</code> if you've used the <code>std::boolalpha</code> manipulator on the stream.</p>\n<p>If you want the address, you'll have to explicitly convert it to an object pointer:</p>\n<pre><code>std::cout &lt;&lt; reinterpret_cast&lt;void*&gt;(&amp;Function1) &lt;&lt; std::endl;\n</code></pre>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-08-28T01:23:11.397", "Score": "3", "CreationDate": "2014-08-28T00:15:16.280", "ParentId": "25538776", "CommentCount": "1", "OwnerUserId": "204847", "LastEditDate": "2014-08-28T01:23:11.397"}, "25538912": {"Id": "25538912", "PostTypeId": "2", "Body": "<p>If I change your code to the following, the function pointer addresses will be displayed correctly:</p>\n<pre><code>void Function1() {\n}\n\nint main() {\n    void*a = (void*)&amp;Function1;\n    cout&lt;&lt;a&lt;&lt;endl;\n    cout&lt;&lt; (void*)&amp;Function1&lt;&lt;endl;\n    cout&lt;&lt; (void*)&amp;main&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>0x8048710\n0x8048710\n0x8048570\n</code></pre>\n<p>See the <a href=\"http://ideone.com/ADREqt\" rel=\"nofollow\">working sample here</a> please.</p>\n<hr>\n<p>The problem is, there's a standard operator overload available for </p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp;,void*)\n</code></pre>\n<p>but not for function pointers</p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp;,void (Function1Type*)())\n</code></pre>\n<p>and the least valid conversion draws </p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp;,bool)\n</code></pre>\n<p>where everything other than <code>0x00000000</code> is <code>true</code>.</p>\n</hr>", "LastEditorUserId": "1413395", "LastActivityDate": "2014-08-28T00:26:00.987", "Score": "0", "CreationDate": "2014-08-28T00:19:48.787", "ParentId": "25538776", "CommentCount": "2", "OwnerUserId": "1413395", "LastEditDate": "2014-08-28T00:26:00.987"}});