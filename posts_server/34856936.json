post_cb({"bq_ids": {"n4140": {"so_34856936_34857037_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}, "so_34856936_34857037_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 7207}, "so_34856936_34857037_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_34856936_34857037_2": {"length": 10, "quality": 1.0, "section_id": 3302}}, "n3337": {"so_34856936_34857037_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}, "so_34856936_34857037_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 6951}, "so_34856936_34857037_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_34856936_34857037_2": {"length": 10, "quality": 1.0, "section_id": 3172}}, "n4659": {"so_34856936_34857037_1": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}, "so_34856936_34857037_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 8716}, "so_34856936_34857037_0": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}}}, "34856936": {"ViewCount": "201", "Body": "<p>I have a struct which contains bit-fields:</p>\n<pre><code>struct Foo {\n    unsigned a : 16, b : 16;\n};\n</code></pre>\n<p>And I want to know if I can use aggregate initialization on it's bit-fields. For example:</p>\n<pre><code>struct Foo bar = {13, 42};\n</code></pre>\n<p>I note that this <a href=\"http://ideone.com/ruSyn9\" rel=\"nofollow\">does work in gcc 5.1</a> and Visual Studio 2015. I'd just like something to certify this was standard approved initialization for both C and C++.</p>\n", "AcceptedAnswerId": "34857037", "Title": "Is Aggregate Initialization of Bit-Fields Allowed?", "CreationDate": "2016-01-18T14:19:33.567", "Id": "34856936", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-01-18T14:41:49.990", "Score": "2", "OwnerUserId": "2642059", "Tags": "<c++><c><initialization><bit-fields><aggregate-initialization>", "AnswerCount": "1"}, "34857037": {"Id": "34857037", "PostTypeId": "2", "Body": "<p>From C++14 <code>[dcl.init.aggr]</code> we have</p>\n<blockquote>\n<p id=\"so_34856936_34857037_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>So <code>Foo</code> is an aggregate an qualifies for aggregate initialization.  Then we have</p>\n<blockquote>\n<p id=\"so_34856936_34857037_1\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order.[...]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_34856936_34857037_2\">Static data members and anonymous bit-fields are not considered members of the class for purposes of aggregate initialization.</p>\n</blockquote>\n<p>So in your case they will be initialized since they are not anonymous and they will be initialized in the order they appear in the <code>struct</code>.</p>\n<p>From C11 6.2.5(21) we have</p>\n<blockquote>\n<p id=\"so_34856936_34857037_3\">Arithmetic types and pointer types are collectively called scalar types. Array and structure types are collectively called aggregate types.<sup>46</sup>)</p>\n</blockquote>\n<p>So in C we are still dealing with an aggregate.  Then in 6.7.9(9) we have</p>\n<blockquote>\n<p id=\"so_34856936_34857037_4\">Except where explicitly stated otherwise, for the purposes of this subclause unnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate value even after initialization. </p>\n</blockquote>\n<p>and 6.7.9(17)</p>\n<blockquote>\n<p id=\"so_34856936_34857037_5\">Each brace-enclosed initializer list has an associated current object. When no\n  designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union.<sup>148</sup>) In contrast, a designation causes the following initializer to begin initialization of the subobject described by the designator. Initialization then continues forward in order, beginning with the next subobject after that described by the designator.<sup>149</sup>)</p>\n</blockquote>\n<p>So we have the same behavior as in C++ where anonymous bit fields are not initialized but since they are named they will be initialized in the order they appear in the <code>struct</code>.</p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2016-01-18T14:41:49.990", "Score": "6", "CreationDate": "2016-01-18T14:24:03.207", "ParentId": "34856936", "CommentCount": "5", "OwnerUserId": "4342498", "LastEditDate": "2016-01-18T14:41:49.990"}});