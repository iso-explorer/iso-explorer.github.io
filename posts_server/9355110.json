post_cb({"13891873": {"ParentId": "9355110", "CommentCount": "2", "Body": "<p>I think your suspicion is founded. The code should look like</p>\n<pre><code>void do_callback(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)\n{\n    if(callback &amp;&amp; !done)\n    {\n        boost::function&lt;void()&gt; local_callback=callback;\n        callback=boost::function&lt;void()&gt;;\n        relocker relock(lock); // unlock mutex?\n        local_callback();\n    }\n}    \n</code></pre>\n<p>or even </p>\n<pre><code>void do_callback(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)\n{\n    if(callback &amp;&amp; !done)\n    {\n        boost::function&lt;void()&gt; local_callback=boos::move(callback);\n        relocker relock(lock); // unlock mutex?\n        local_callback();\n    }\n}    \n</code></pre>\n<p>once Boost.Function will support move semantics.</p>\n<p>This has yet some issues as another thread could call set_wait_callback, so callback could be reassigned and two callbacks could be called. It seems that an additional state is needed to state if the callback has already been done.</p>\n<pre><code>void do_callback(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)\n{\n    if(callback &amp;&amp; ! callback_done &amp;&amp; !done)\n    {\n        boost::function&lt;void()&gt; local_callback=callback;\n        callback_done=true;\n        relocker relock(lock); // unlock mutex?\n        local_callback();\n    }\n}    \n</code></pre>\n<p>BTW, set_wait_callback is not thread-safe.</p>\n<pre><code>    template&lt;typename F,typename U&gt;\n    void set_wait_callback(F f,U* u)\n    {\n        callback=boost::bind(f,boost::ref(*u));\n    }\n</code></pre>\n<p>and must be protected</p>\n<pre><code>    template&lt;typename F,typename U&gt;\n    void set_wait_callback(F f,U* u)\n    {\n        boost::lock_guard&lt;boost::mutex&gt; lock(mutex);\n        callback=boost::bind(f,boost::ref(*u));\n    }\n</code></pre>\n<p>Please, could you create a Trac ticket to Boost Thread so this issue is not lost? </p>\n", "OwnerUserId": "320757", "PostTypeId": "2", "Id": "13891873", "Score": "2", "CreationDate": "2012-12-15T11:45:11.593", "LastActivityDate": "2012-12-15T11:45:11.593"}, "9355110": {"CommentCount": "0", "ViewCount": "670", "PostTypeId": "1", "LastEditorUserId": "346804", "CreationDate": "2012-02-20T01:25:27.370", "LastActivityDate": "2012-12-15T11:45:11.593", "Title": "boost::future - Is wait_callback guaranteed to only be invoked once?", "AcceptedAnswerId": "13891873", "LastEditDate": "2012-02-20T02:09:22.527", "Id": "9355110", "Score": "2", "Body": "<p>If I set a <code>set_wait_callback</code> on a <code>boost::unique_future</code>, is it guaranteed to only run once?</p>\n<p>I'm a bit suspicious since when looking at the source code I find the following:</p>\n<pre><code>struct relocker\n{\n    boost::unique_lock&lt;boost::mutex&gt;&amp; lock;\n\n    relocker(boost::unique_lock&lt;boost::mutex&gt;&amp; lock_):\n        lock(lock_)\n    {\n        lock.unlock();\n    }\n    ~relocker()\n    {\n        lock.lock();\n    }\nprivate:\n    relocker&amp; operator=(relocker const&amp;);\n};\n\nvoid do_callback(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)\n{\n    if(callback &amp;&amp; !done)\n    {\n        boost::function&lt;void()&gt; local_callback=callback;\n        relocker relock(lock); // unlock mutex?\n        local_callback();\n    }\n}    \n\nvoid wait(bool rethrow=true)\n{\n    boost::unique_lock&lt;boost::mutex&gt; lock(mutex);\n    do_callback(lock);\n    while(!done)\n    {\n        waiters.wait(lock);\n    }\n    if(rethrow &amp;&amp; exception)\n    {\n        boost::rethrow_exception(exception);\n    }\n}\n</code></pre>\n<p>Where in <code>do_callback</code> the mutex is actually unlocked while the callback is invoked, which from my understanding can lead to the callback being called multiple times if multiple threads call the <code>wait</code> function? </p>\n<p>Can the callback be called multiple times? Is it by design? Or am I missing something?</p>\n<p>The reason I'm a bit surprised is that in the C++11 standard the <code>async(std::launch::deferred, ...)</code> (to which <code>set_wait_callback</code> is a cousin), seems to have single invocation guarantee:</p>\n<p>\u00a730.6.8</p>\n<blockquote>\n<p id=\"so_9355110_9355110_0\">The shared state is not made ready until the function has completed.\n  <strong>The first call</strong> to a non-timed waiting function (30.6.4) on an\n  asynchronous return object referring to this shared state <strong>shall invoke\n  the deferred function in the thread that called the waiting function</strong>.</p>\n</blockquote>\n", "Tags": "<c++><boost-thread><future>", "OwnerUserId": "346804", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9355110_9355110_0": {"section_id": 3161, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_9355110_9355110_0": {"section_id": 3034, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_9355110_9355110_0": {"section_id": 3923, "quality": 0.8928571428571429, "length": 25}}}});