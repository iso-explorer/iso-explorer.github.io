post_cb({"40694439": {"ParentId": "40694384", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2016-11-19T15:14:22.920", "Score": "2", "LastEditorUserId": "6667256", "LastEditDate": "2016-11-19T15:29:10.223", "Id": "40694439", "OwnerUserId": "6667256", "Body": "<p>In section 7.4 the <a href=\"http://www.csee.umbc.edu/~tsimo1/CMSC455/IEEE-754-2008.pdf\" rel=\"nofollow noreferrer\">standard IEEE-754</a> (2008) says it is well-defined behavior for it. But it is related to IEEE-754 and C/C++ implementations are free to respect it or not (see the zwol answer).</p>\n<blockquote>\n<p id=\"so_40694384_40694439_0\">The overflow exception shall be signaled  if and only if \n   the destination format\u2019s largest finite  number is\n  exceeded in magnitude by what would have been the rounded floating-point result were the exponent\n  range unbounded. The default result shall be determined by the rounding-direction attribute and the sign of\n  the intermediate result as follows:</p>\n<p id=\"so_40694384_40694439_1\">a)\n  roundTiesToEven and roundTiesToAway carry all overflows to \n  \u221e\n   with the sign of the intermediate\n  result.</p>\n<p id=\"so_40694384_40694439_2\">b)    roundTowardZero  carries all overflows to the format\u2019s largest finite number with the sign of the\n  intermediate result.</p>\n<p id=\"so_40694384_40694439_3\">c)\n  roundTowardNegative carries positive overflows to the format\u2019s largest finite number, and carries\n  negative overflows to \n  \u2212\u221e</p>\n<p id=\"so_40694384_40694439_4\">d)    roundTowardPositive carries negative overflows to the format\u2019s most negative finite number, and\n  carries positive overflows to +\n  \u221e</p>\n</blockquote>\n<p>All cases of these 4 points provide a deterministic result for the conversion from integral to floating-point type.</p>\n<p>All other cases (no overflow) are also well-defined with deterministic results given by the IEEE-754 standard. </p>\n", "LastActivityDate": "2016-11-19T15:29:10.223"}, "40694536": {"ParentId": "40694384", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-11-19T15:23:23.853", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:37.933", "Id": "40694536", "OwnerUserId": "388520", "Body": "<p>IEC 60559 (the current successor standard to IEEE 754) makes integer-to-float conversion well-defined in all cases, as discussed in <a href=\"https://stackoverflow.com/a/40694439/388520\">Franck's answer</a>, but it is the language standard that has the final word on the subject.</p>\n<p>In the base standard, C++11 section 4.9 \"Floating-integral conversions\", paragraph 2, makes out-of-range integer-to-floating-point conversions undefined behavior.  (Quotation is from document <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a>, which is the closest approximation to the official 2011 C++ standard that is publicly available at no charge.)</p>\n<blockquote>\n<p id=\"so_40694384_40694536_0\">A prvalue of an integer type or of an unscoped enumeration type can be converted to a prvalue of a floating\n  point type. The result is exact if possible. If the value being converted is in the range of values that can\n  be represented but the value cannot be represented exactly, it is an implementation-defined choice of either\n  the next lower or higher representable value. [ Note: Loss of precision occurs if the integral value cannot\n  be represented exactly as a value of the floating type. \u2014 end note ] <em>If the value being converted is outside\n  the range of values that can be represented, the behavior is undefined.</em> If the source type is bool, the value\n  false is converted to zero and the value true is converted to one.</p>\n</blockquote>\n<p>Emphasis mine.  The C standard says the same thing in different words (section 6.3.1.4 paragraph 2).</p>\n<p>The C++ standard does not discuss what it would mean for an implementation of C++ to supply IEC 60559-conformant floating-point arithmetic.  However, the C standard (closest approximation to C11 available online at no charge is <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow noreferrer\">N1570</a>) does discuss this in its Annex F, and C++ implementors do tend to turn to C for guidance when C++ leaves something unspecified.  There is no <em>explicit</em> discussion of integer to floating point conversion in Annex F, but there is this sentence in F.1p1:</p>\n<blockquote>\n<p id=\"so_40694384_40694536_1\">Since\n  negative and positive infinity are representable in IEC 60559 formats, all real numbers lie\n  within the range of representable values.</p>\n</blockquote>\n<p>Putting that sentence together with 6.3.1.4p2 suggests to me that the C committee <em>meant</em> for integer-to-floating conversion to produce \u00b1Inf when the integer's magnitude is outside the range of representable finite numbers.  And that interpretation is consistent with the IEC 60559-specified behavior of conversions, so we can be reasonably confident that that's what an implementation <em>of C</em> that claimed to conform to Annex F would do.</p>\n<p>However, applying any interpretation of the <em>C</em> standard to C++ is risky at best; C++ has not been defined as a superset of C for a very long time.\nIf your implementation of C++ predefines the macro <code>__STDC_IEC_559__</code> and/or documents compliance with IEC 60559 in some way <em>and</em> you don't use the \"be sloppy about floating-point math in the name of speed\" compilation mode (which may be on by default), you can probably rely on out-of-range conversions to produce \u00b1Inf.  Otherwise, it's UB.</p>\n", "LastActivityDate": "2016-11-19T15:46:20.067"}, "bq_ids": {"n4140": {"so_40694384_40694536_0": {"section_id": 38, "quality": 0.9295774647887324, "length": 66}}, "n3337": {"so_40694384_40694536_0": {"section_id": 35, "quality": 0.9295774647887324, "length": 66}}, "n4659": {"so_40694384_40694536_0": {"section_id": 38, "quality": 0.9014084507042254, "length": 64}}}, "40694384": {"CommentCount": "6", "ViewCount": "74", "CreationDate": "2016-11-19T15:08:18.663", "LastActivityDate": "2016-11-19T15:46:20.067", "Title": "Integer to float conversions with IEEE FP", "AcceptedAnswerId": "40694536", "PostTypeId": "1", "Id": "40694384", "Score": "2", "Body": "<p>What are the guarantees regarding conversions from integral to floating-point types in a C++ implementation supporting IEEE-754 FP arithmetic?</p>\n<p>Specifically, is it always well-defined behaviour to convert any integral value to any floating-point type, possibly resulting in a value of <code>+-inf</code>? Or are there situations in which this would result in undefined behaviour?</p>\n<p>(Note, I am not asking about exact conversion, just if performing the conversion is always legal from the point of view of the language standard)</p>\n", "Tags": "<c++><ieee-754>", "OwnerUserId": "453925", "AnswerCount": "2"}});