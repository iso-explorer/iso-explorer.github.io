post_cb({"17091382": {"CommentCount": "4", "AcceptedAnswerId": "21150698", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-06-13T15:44:04.107", "LastActivityDate": "2017-03-14T17:14:47.877", "LastEditDate": "2017-05-23T12:09:57.963", "ViewCount": "12971", "FavoriteCount": "15", "Title": "Memory alignment : how to use alignof / alignas?", "Id": "17091382", "Score": "34", "Body": "<p>I work with shared memory right now.</p>\n<p>I can't understand <code>alignof</code> and <code>alignas</code>.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/alignof\" rel=\"noreferrer\">cppreference</a> is unclear : <code>alignof</code> returns \"alignment\" but what is \"alignment\" ? number of bytes to add for the next block to be aligned ? padded size ? <a href=\"https://stackoverflow.com/questions/7053190/what-are-the-alignas-and-alignof-keywords-used-for\">Stack overflow</a> / blogs entries are unclear too.</p>\n<p>Can someone explain clearly <code>alignof</code> and <code>alignas</code> ?</p>\n", "Tags": "<c++><c++11><x86-64><memory-alignment>", "OwnerUserId": "587407", "AnswerCount": "3"}, "17095736": {"ParentId": "17091382", "CommentCount": "0", "Body": "<p>Each type has an alignment requirement. Generally, this is so variables of the type can be accessed efficiently, without having to cause the CPU to generate more than one read/write access in order to reach any given member of the datatype. Furthermore, it also ensure efficient copying of the entire variable. <code>alignof</code> will return the alignment requirement for the given type.</p>\n<p><code>alignas</code> is used to force an alignment on a datatype (so long as it is not less stringent that what <code>alignof</code> said datatype would return)</p>\n", "OwnerUserId": "2176845", "PostTypeId": "2", "Id": "17095736", "Score": "3", "CreationDate": "2013-06-13T19:47:57.600", "LastActivityDate": "2013-06-13T19:47:57.600"}, "17094266": {"ParentId": "17091382", "CommentCount": "4", "Body": "<p>Alignment is not padding (although padding is sometimes introduced to satisfy alignment requirements). It is an intrisic property of a C++ type. To put it in standardese (<code>3.11[basic.align]</code>)</p>\n<blockquote>\n<p id=\"so_17091382_17094266_0\">Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment specifier (7.6.2).</p>\n</blockquote>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "17094266", "Score": "5", "CreationDate": "2013-06-13T18:20:37.280", "LastActivityDate": "2013-06-13T18:20:37.280"}, "21150698": {"ParentId": "17091382", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Alignment is a restriction on which memory positions a value's first byte can be stored. (It is needed to improve performance on processors and to permit use of certain instructions that works only on data with particular alignment, for example SSE need to be aligned to 16 bytes, while AVX to 32 bytes.)</p>\n<p>Alignment of 16 means that memory addresses that are a multiple of 16 are the only valid addresses.</p>\n<pre><code>alignas\n</code></pre>\n<p>force alignment to required number of bytes (cppreference does not mention it, but I think you can only align to powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, ...)</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    alignas(16) int a[4];\n    alignas(1024) int b[4];\n    printf(\"%p\\n\", a);\n    printf(\"%p\", b);\n}\n</code></pre>\n<p>example output:</p>\n<pre><code>0xbfa493e0\n0xbfa49000  // note how many more \"zeros\" now.\n// binary equivalent\n1011 1111 1010 0100 1001 0011 1110 0000\n1011 1111 1010 0100 1001 0000 0000 0000 // every zero is just a extra power of 2\n</code></pre>\n<p>the other keyword</p>\n<pre><code>alignof\n</code></pre>\n<p>is very convenient, you cannot do something like</p>\n<pre><code>int a[4];\nassert(a % 16 == 0); // check if alignment is to 16 bytes: WRONG compiler error\n</code></pre>\n<p>but you can do</p>\n<pre><code>assert(alignof(a) == 16);\nassert(alignof(b) == 1024);\n</code></pre>\n<p>note that in reality this is more strict than a simple \"%\" (modulus) operation. In fact we know that something aligned to 1024 bytes is necessarily aligned to 1, 2, 4, 8 bytes but</p>\n<pre><code> assert(alignof(b) == 32); // fail.\n</code></pre>\n<p>So to be more precise, \"alignof\" returns the greatest power of 2 to wich something is aligned.</p>\n<p>Also alignof is a nice way to know in advance minimum alignment requirement for basic datatypes (it will probably return 1 for chars, 4 for float etc.).</p>\n<p>Still legal:</p>\n<pre><code>alignas(alignof(float)) float SqDistance;\n</code></pre>\n<p><strong>Something with an alignment of 16 then will be placed on the next available address that is a multiple of 16</strong> (there may be a implicit padding from last used address).</p>\n", "OwnerUserId": "1829943", "LastEditorUserId": "4751585", "LastEditDate": "2017-03-14T17:14:47.877", "Id": "21150698", "Score": "34", "CreationDate": "2014-01-15T23:46:14.817", "LastActivityDate": "2017-03-14T17:14:47.877"}, "bq_ids": {"n4140": {"so_17091382_17094266_0": {"section_id": 7240, "quality": 0.8636363636363636, "length": 38}}, "n3337": {"so_17091382_17094266_0": {"section_id": 6984, "quality": 0.8636363636363636, "length": 38}}, "n4659": {"so_17091382_17094266_0": {"section_id": 8749, "quality": 0.8409090909090909, "length": 37}}}});