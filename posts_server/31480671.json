post_cb({"31480717": {"Id": "31480717", "PostTypeId": "2", "Body": "<p>Because an array stores it's elements in <em>contiguous</em> memory. So if you know the size of the type, and the pointer to the first element, you can figure out the address of all the remaining elements.</p>\n<pre><code>int values[10];\n&amp;values[5] == &amp;values[0] + 5 // due to pointer arithmetic\n</code></pre>\n<p><strong>\u00a75.7 Additive operators</strong></p>\n<blockquote>\n<p id=\"so_31480671_31480717_0\">The additive operators + and - group left-to-right. The usual arithmetic conversions are performed for operands of arithmetic or enumeration type. </p>\n<p id=\"so_31480671_31480717_1\"><strong>For addition</strong>, either both operands shall have arithmetic or unscoped enumeration type, or <strong>one operand shall be a pointer to a completely-defined object type and the other shall have integral or unscoped enumeration\n  type</strong>.  </p>\n<p id=\"so_31480671_31480717_2\">For subtraction, one of the following shall hold:<br>\n  \u2014 both operands have arithmetic or unscoped enumeration type; or<br>\n  \u2014 both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-definedobject type; or<br>\n  \u2014 the left operand is a pointer to a completely-defined object type and the right operand has integral or unscoped enumeration type.</br></br></br></p>\n<p id=\"so_31480671_31480717_3\">...</p>\n<p id=\"so_31480671_31480717_4\"><strong>When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression</strong>. In other words, if the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))\n  and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array object, provided they exist. Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So basically, the standard defines the arithmetic between a pointer <code>T*</code> and an integral type</p>\n<pre><code>T* t + n  // where n is an offset (of integral type)\n</code></pre>\n<p>To result in another <code>T*</code> that is <code>n * sizeof(T)</code> from the initial <code>t</code>.</p>\n", "LastEditorUserId": "2296458", "LastActivityDate": "2015-07-17T16:55:19.657", "Score": "0", "CreationDate": "2015-07-17T16:41:48.177", "ParentId": "31480671", "CommentCount": "1", "LastEditDate": "2015-07-17T16:55:19.657", "OwnerUserId": "2296458"}, "31480727": {"Id": "31480727", "PostTypeId": "2", "Body": "<p>All the story is about what the constructs expects from an iterator. It expects to be able to increment it (using ++), to deference it (using *). An interator is simply either a class that overloads the ++ and the * operator, or a basic pointer type that naturally supports both operations.</p>\n", "LastEditorUserId": "4436434", "LastActivityDate": "2015-07-17T16:44:46.707", "Score": "6", "CreationDate": "2015-07-17T16:42:24.563", "ParentId": "31480671", "CommentCount": "6", "LastEditDate": "2015-07-17T16:44:46.707", "OwnerUserId": "4436434"}, "bq_ids": {"n4140": {"so_31480671_31480717_4": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}, "so_31480671_31480717_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6138}, "so_31480671_31480717_2": {"length": 31, "quality": 0.9393939393939394, "section_id": 6139}, "so_31480671_31480717_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 6138}}, "n3337": {"so_31480671_31480717_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5902}, "so_31480671_31480717_2": {"length": 31, "quality": 0.9393939393939394, "section_id": 5903}, "so_31480671_31480717_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5902}, "so_31480671_31480717_4": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}, "n4659": {"so_31480671_31480717_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7635}, "so_31480671_31480717_2": {"length": 31, "quality": 0.9393939393939394, "section_id": 7636}, "so_31480671_31480717_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7635}}}, "31481105": {"Id": "31481105", "PostTypeId": "2", "Body": "<p>To answer your last question a pointer points to a place in memory.  Since memory is random access pointers can be classified as a having random access.  Iterators have the same type of classifications.  <a href=\"http://www.cplusplus.com/\" rel=\"nofollow\">cplusplus.com</a> has a nice layout showing which type of iterator support what <a href=\"http://www.cplusplus.com/reference/iterator/\" rel=\"nofollow\">here</a>.  With that we can see that input iterators are the lowest type and they can do the least amount of operations.  Since a pointer is the same as a random access iterator and a random access iterator can do everything an input iterator can do there isn't any issue with that.</p>\n<p>If this was the other way around and you had a function that wanted a random access iterator and you supplied a forward iterator there is no guarantee that the code would work.  This is because the function could be relying on some operation a random access iterator can do that the forward iterator can't do.</p>\n<p>Generally when you write this type of code and you specify what iterator type you want you specify the minimal type that allows your code to compile.  Something that just prints the contents just needs a forward iterator as you are just traversing the contents where sorting needs a random access.</p>\n", "LastActivityDate": "2015-07-17T17:05:12.797", "CommentCount": "0", "CreationDate": "2015-07-17T17:05:12.797", "ParentId": "31480671", "Score": "1", "OwnerUserId": "4342498"}, "31480671": {"ViewCount": "147", "Body": "<p>Below text is from a C++ online course. It says that the constructor of the <code>vector</code> class</p>\n<pre><code> template &lt;class InputIterator&gt;\n          vector ( InputIterator first, InputIterator last, const Allocator&amp; = Allocator() );\n</code></pre>\n<p>can receive pointers as first (<code>InputIterator first</code>) and second parameter (<code>InputIterator last</code>).</p>\n<blockquote>\n<p id=\"so_31480671_31480671_0\">The next constructor uses iterators to initialize itself. It will\n  create a vector with a copy of values from first (inclusive) to last\n  (exclusive). In the most typical case, this constructor creates a new\n  vector using elements from an already existing collection. But due to\n  the fact that iterators are defined as a set of operations instead of\n  a certain type, it is also possible to use normal pointers. This\n  remark leads to a conclusion that you can use a normal C++ array to\n  initialize a collection. And in fact you can.</p>\n</blockquote>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a1[]={1,2,3,4,5,6,7,8,9,10};\n    //first one\n    vector&lt;int&gt; v1(a1, a1+10);\n    cout&lt;&lt;\"Size (v1):  \"&lt;&lt;v1.size()&lt;&lt;endl;\n    for(unsigned i = 0; i &lt; v1.size(); ++i)\n    {\n        cout&lt;&lt; v1[i]&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n    //second one;\n    vector&lt;int&gt; v2(a1+5,a1+10);\n    cout&lt;&lt;\"Size (v2):  \"&lt;&lt;v2.size()&lt;&lt;endl;\n    for(unsigned i = 0; i &lt; v2.size(); ++i)\n    {\n        cout&lt;&lt; v2[i]&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>I can get used to this, but I don't really understand why it is possible. I'd like to understand this technique.</p>\n<p>My question in this case (see code) is <strong>how is it possible that I can simply put an array address instead of an iterator?</strong></p>\n<p>In the above code an element of type <code>int *</code> is put as a parameter of type <code>InputIterator</code>. This confuses me. </p>\n", "Title": "C++ - Using array/pointers in vector (or other container) constructor that expects type Iterator. How is that possible?", "CreationDate": "2015-07-17T16:38:38.563", "LastActivityDate": "2015-07-17T17:22:52.927", "CommentCount": "0", "LastEditDate": "2015-07-17T16:53:51.300", "PostTypeId": "1", "LastEditorUserId": "1566187", "Id": "31480671", "Score": "0", "OwnerUserId": "1566187", "Tags": "<c++><arrays><pointers><vector>", "AnswerCount": "4"}, "31481130": {"Id": "31481130", "PostTypeId": "2", "Body": "<p>C++ iterators are actually carefully designed to generalize the semantics of pointers and mimic their syntax (hence the <code>operator*</code> overload).</p>\n<p>See the general discussion in the <a href=\"https://www.sgi.com/tech/stl/Iterators.html\" rel=\"nofollow\">original SGI docs</a> or the treatment of more recent C++ versions <a href=\"http://en.cppreference.com/w/cpp/iterator\" rel=\"nofollow\">here</a>, and note in particular that:</p>\n<ol>\n<li>pointers satisfy all the requirements of RandomAccessIterators</li>\n<li>RandomAccessIterators model a superset of the requirements of an InputIterator</li>\n<li>the <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"nofollow\"><code>std::vector</code> constructor</a> only requires InputIterator</li>\n</ol>\n<p>If you don't really believe #1, you may also be interested to see that the standard library explicitly <a href=\"http://en.cppreference.com/w/cpp/iterator/iterator_traits#Specializations\" rel=\"nofollow\">provides iterator traits for raw pointers</a>, and if you're still struggling after that, take a look at the implementation of the constructor, and reassure yourself that all operations on its arguments are well-formed for pointers.</p>\n", "LastEditorUserId": "212858", "LastActivityDate": "2015-07-17T17:22:52.927", "Score": "2", "CreationDate": "2015-07-17T17:07:08.450", "ParentId": "31480671", "CommentCount": "0", "LastEditDate": "2015-07-17T17:22:52.927", "OwnerUserId": "212858"}});