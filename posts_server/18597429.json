post_cb({"18597429": {"ViewCount": "725", "Body": "<p>I tried to compare casting an int to void* that worked , even comparison between them</p>\n<pre><code>int i=1,j=2;\nfloat a=1.1;\n\nif((void *)i &gt; (void *)j )\ncout&lt;&lt;\"i&gt;j\"&lt;&lt;endl;\nelse\ncout&lt;&lt;\"i&lt;j\"&lt;&lt;endl;\n</code></pre>\n<p>output was</p>\n<pre><code>i&lt;j\n</code></pre>\n<p>but this</p>\n<pre><code>if((void *)a &gt; (void *)i )\ncout&lt;&lt;\"a&gt;i\"&lt;&lt;endl;\nelse\ncout&lt;&lt;\"a&lt;i\"&lt;&lt;endl;\n</code></pre>\n<p>gives an error</p>\n<pre><code> error: invalid cast from type \u2018float\u2019 to type \u2018void*\u2019\n</code></pre>\n<p>I thought we can cast any thing to void pointers?Is it not so?</p>\n", "AcceptedAnswerId": "18597508", "Title": "comparison between void pointer, is it defined or compiler dependent?", "CreationDate": "2013-09-03T16:43:28.160", "Id": "18597429", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-09-03T17:16:14.470", "Score": "0", "OwnerUserId": "953273", "Tags": "<c++><pointers>", "AnswerCount": "4"}, "18597549": {"Id": "18597549", "PostTypeId": "2", "Body": "<p>You can cast any <em>object pointer type</em> to <code>void*</code> not any type.</p>\n<p>So you can solve your problem with:</p>\n<pre><code>if((void *)&amp;a &gt; (void *)&amp;i )\n//         ^            ^\n</code></pre>\n<p><strong>But comparing the address of two variables is not the same thing as comparing the values.</strong> I don't think you will have the result you want... You will have <em>Undefined behaviour</em> here.</p>\n", "LastEditorUserId": "1394283", "LastActivityDate": "2013-09-03T16:57:45.890", "Score": "1", "CreationDate": "2013-09-03T16:51:07.127", "ParentId": "18597429", "CommentCount": "1", "OwnerUserId": "1394283", "LastEditDate": "2013-09-03T16:57:45.890"}, "bq_ids": {"n4140": {"so_18597429_18597508_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}, "so_18597429_18597508_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_18597429_18597508_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}, "so_18597429_18597508_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}}, "n4659": {"so_18597429_18597508_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}, "so_18597429_18597508_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}}}, "18597546": {"Id": "18597546", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18597429_18597546_0\">comparison between void pointer, is it defined or compiler dependent?</p>\n</blockquote>\n<p>That is well-defined, but the results are usually unspecified, as described by C++11 5.9/3: \"If both pointers represent the same address or are both the null pointer value, the result is true if the operator is &lt;= or &gt;= and false otherwise; otherwise the result is unspecified.\"</p>\n<p>Note that <code>std::less</code> and friends are required to define a total order for pointers, even if the built-in operators don't.</p>\n<p>However, doing just about anything with pointers that you've converted from arbitrary integer values will give undefined behaviour.</p>\n<blockquote>\n<p id=\"so_18597429_18597546_1\">I thought we can cast any thing to void pointers?Is it not so?</p>\n</blockquote>\n<p>No. <code>reinterpret_cast</code> (or an equivalent C-style cast) can convert between pointer and integer types. Converting a floating-point value to a pointer makes no sense at all.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-09-03T17:00:39.867", "Score": "5", "CreationDate": "2013-09-03T16:51:02.617", "ParentId": "18597429", "CommentCount": "9", "OwnerUserId": "204847", "LastEditDate": "2013-09-03T17:00:39.867"}, "18597508": {"Id": "18597508", "PostTypeId": "2", "Body": "<p>You can cast the address of \"anything\" (that's not a function or whose \"address\" is given by a pointer to member) to a <code>void *</code>. In addition, some integral types can be cast to pointers. I guess what you wanted to do is this</p>\n<pre><code>if((void *)&amp;i &gt; (void *)&amp;j )\n    cout&lt;&lt;\"i&gt;j\"&lt;&lt;endl;\nelse\n    cout&lt;&lt;\"i&lt;j\"&lt;&lt;endl;\n</code></pre>\n<p>and that</p>\n<pre><code>if((void *)&amp;a &gt; (void *)&amp;i )\n    cout&lt;&lt;\"a&gt;i\"&lt;&lt;endl;\nelse\n    cout&lt;&lt;\"a&lt;i\"&lt;&lt;endl;\n</code></pre>\n<p>However, notice that the results of such pointer comparisons are unspecified as per C++11 5.9/3 (as explained by <a href=\"https://stackoverflow.com/users/204847/mike-seymour\">Mike Seymour</a> in his <a href=\"https://stackoverflow.com/a/18597546/1137388\">post</a>.</p>\n<p>The best way to compare pointers of the same type is using the templates <code>greater</code>, <code>less</code>, <code>greater_equal</code> and <code>less_equal</code> because 20.8.5/8 says:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_18597429_18597508_1\">For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>\n</blockquote>\n</blockquote>\n<p>Therefore, you should use</p>\n<pre><code>if (std::greater&lt;void*&gt;()((void *) &amp;i, (void *) &amp;j))\n    cout&lt;&lt;\"i&gt;j\"&lt;&lt;endl;\nelse\n    cout&lt;&lt;\"i&lt;j\"&lt;&lt;endl;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-03T17:16:14.470", "Score": "1", "CreationDate": "2013-09-03T16:48:43.577", "ParentId": "18597429", "CommentCount": "4", "OwnerUserId": "1137388", "LastEditDate": "2017-05-23T10:25:17.303"}, "18597476": {"Id": "18597476", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18597429_18597476_0\">I thought we can cast any thing to void pointers?Is it not so?</p>\n</blockquote>\n<p>A <code>void*</code> is intended to allow you to cast to and from <em>any object pointer type</em>, not <em>any type</em>.</p>\n<p>This means you could do:</p>\n<pre><code>if((void *)&amp;a &gt; (void *)&amp;i )\n</code></pre>\n<p>However, checking and comparing pointer values like this is very rarely useful.</p>\n", "LastActivityDate": "2013-09-03T16:46:53.717", "CommentCount": "3", "CreationDate": "2013-09-03T16:46:53.717", "ParentId": "18597429", "Score": "3", "OwnerUserId": "65358"}});