post_cb({"844713": {"ParentId": "453432", "CommentCount": "0", "Body": "<p>Defining initial values in the variable declaration happens at a different place than using memset.</p>\n<p>For the former case the zeros are defined in some form in the binary as zero init memory (or non-zero depending on what you initialize to), and you hope that the loader honors that, has ABSOLUTELY nothing to do with C language standards.  The latter, using memset depends on the C library which you would also works. I have more faith in the library.</p>\n<p>I do a lot of embedded code where you learn to avoid the bad habit of initializing variables as part of the variable declaration and instead do it within the code.</p>\n<p>For standard operating systems, Linux, Windows, etc the init during variable declaration is fine, you will get an imperceptible performance increase, but if you are running an operating system you are on a platform that is fast enough to not see that difference.</p>\n<p>Depending on the binary type the former case of the init during declaration can make the binary larger.  This is extremely easy to test for.  Compile your binary as above, then change the array size from [16] to [16000] then compile again.  Then compile without the = {0x00} and compare the three binary sizes.</p>\n<p>For most systems that most programmers will ever see, there is no functional difference.  I recommend the memset as a habit.  Despite what standards say many if not most C compilers (of which most programmers will never see in their careers) wont like that init because the number of elements doesnt match the size.  Most compilers do not conform to the standards even if they claim to.  Instead develop good habits that avoid shortcuts or pretty much anything that should work for standard X but is different from the prior standard M.  (Avoid any gee whiz compiler or standards based tricks). </p>\n", "OwnerUserId": "16007", "PostTypeId": "2", "Id": "844713", "Score": "1", "CreationDate": "2009-05-10T04:55:55.523", "LastActivityDate": "2009-05-10T04:55:55.523"}, "455137": {"CommentCount": "2", "CreationDate": "2009-01-18T13:39:37.203", "LastEditorUserId": "6345", "LastActivityDate": "2009-01-18T14:22:48.037", "ParentId": "453432", "PostTypeId": "2", "LastEditorDisplayName": "Johann Gerell", "LastEditDate": "2009-01-18T14:22:48.037", "Id": "455137", "Score": "3", "Body": "<p>Given the hard-to-dispute fact that <code>= { 0 }</code> is infinitely more readable than <code>memset(..., ..., ... sizeof ...)</code>, then the following would discourage explicitly using <code>memset</code>:</p>\n<p>In Visual Studio 2005, compiling for Windows Mobile, full optimized release build:</p>\n<pre><code>; DWORD a[10] = { 0 };\n\nmov         r3, #0\nmov         r2, #0x24\nmov         r1, #0\nadd         r0, sp, #4\nstr         r3, [sp]\nbl          memset\nadd         r4, sp, #0\nmov         r5, #0xA\n\n; DWORD b[10];\n; memset(b, 0, sizeof(b));\n\nmov         r2, #0x28\nmov         r1, #0\nadd         r0, sp, #0x28\nbl          memset\nadd         r4, sp, #0x28\nmov         r5, #0xA\n</code></pre>\n<p>Pretty much the same.</p>\n", "OwnerUserId": "6345", "OwnerDisplayName": "Johann Gerell"}, "453432": {"CommentCount": "0", "AcceptedAnswerId": "453462", "PostTypeId": "1", "LastEditorUserId": "96780", "LastEditorDisplayName": "mhd", "CreationDate": "2009-01-17T15:21:37.143", "LastActivityDate": "2013-08-01T16:46:03.360", "AnswerCount": "6", "LastEditDate": "2013-08-01T16:46:03.360", "ViewCount": "6904", "FavoriteCount": "7", "Title": "Difference in initializing and zeroing an array in c/c++?", "Id": "453432", "Score": "16", "Body": "<p>In c (or maybe c++) , what's  the difference between \n<br/></p>\n<pre>\nchar myarr[16]={0x00};\n</pre>\n<p>and\n<br/></p>\n<pre>\nchar myarr[16];\nmemset(myarr, '\\0', sizeof(myarr));\n</pre>\n<p>??</p>\n<p>edit: I ask this because in vc++ 2005 the result is the same..\n<br/>\nedit more : \nand \n<pre>char myarr[16]={0x00,}; </pre>  ?\n<br/>\nmaybe can get more comprehensive answer and not ambiguous as some answers below refer to this kind of code,ie.\nput comma just before closing curly braces. Also the result is the same in vc++ 2005.</p>\n", "Tags": "<c++><c><arrays>", "OwnerUserId": "38515", "OwnerDisplayName": "mhd"}, "453462": {"CommentCount": "3", "CreationDate": "2009-01-17T15:38:41.323", "CommunityOwnedDate": "2009-01-17T23:49:06.060", "LastEditorUserId": "34509", "LastActivityDate": "2009-01-17T23:49:06.060", "ParentId": "453432", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2009-01-17T23:49:06.060", "Id": "453462", "Score": "18", "Body": "<p>The important difference is that the first default initializes the array in an element-specific manner: Pointers will receive a <em>null pointer value</em>, which doesn't need to be 0x00 (as in all-bits-zero), booleans will be <em>false</em>. If the element type is a class type that's not a so-called <em>POD</em> (plain old data-type), then you can only do the first one, because the second one only works for the simplest cases (where you don't have <em>virtual functions</em>, user defined constructors and so on). In contrast, the second way using the memset sets all elements of the array to all-bits-zero. That is not always that what you want. If your array has pointers for example, they won't be set to null-pointers necessarily. </p>\n<p>The first will default initialize the elements of the array, except for the first one, which is set to 0 explicitly. If the array is local and on the stack (that is, not a static), the compiler internally often does a memset to clear the array out. If the array is non-local or static, the first version can be <em>considerably more efficient</em>. The compiler can put the initializers already, at compile time, into the generated assembler code, making it require no runtime code at all. Alternatively, the array can be laid out on a section that is automatically zero'd out (also for pointers, if they have a all-bits-zero representation) when the program starts in a fast manner (i.e page-wise). </p>\n<p>The second does a memset explicitly over the whole array. Optimizing compilers will usually replace a memset for smaller regions with inline machine code that just loops using labels and branches. </p>\n<p><sub>\nHere is assembler-code generated for the first case. My gcc stuff isn't much optimized, so we got a real call to memset (16 bytes at the stack-top are always allocated, even if we got no locals. $n is a register number):</sub></p>\n<pre><code>void f(void) {\n    int a[16] = { 42 };\n}\n\nsub     $29, $29, 88 ; create stack-frame, 88 bytes\nstw     $31, $29, 84 ; save return address\nadd     $4, $29, 16  ; 1st argument is destination, the array.\nadd     $5, $0, 0    ; 2nd argument is value to fill\nadd     $6, $0, 64   ; 3rd argument is size to fill: 4byte * 16\njal     memset       ; call memset\nadd     $2, $0, 42   ; set first element, a[0], to 42\nstw     $2, $29, 16  ;\nldw     $31, $29, 84 ; restore return address\nadd     $29, $29, 88 ; destroy stack-frame\njr      $31          ; return to caller\n</code></pre>\n<p></p>\n<p>The gory details from the C++ Standard. The first case above will default-initialize remaining elements. </p>\n<p><code>8.5</code>:</p>\n<blockquote>\n<p id=\"so_453432_453462_0\">To zero-initialize storage for an object of type T means:</p>\n<ul>\n<li>if T is a scalar type, the storage is set to the value of 0 (zero) <em>converted to T</em>;</li>\n<li>if T is a non-union class type, the storage for each nonstatic data member and each base-class subobject is zero-initialized;</li>\n<li>if T is a union type, the storage for its first data member is zero-initialized;</li>\n<li>if T is an array type, the storage for each element is zero-initialized;</li>\n<li>if T is a reference type, no initialization is performed.</li>\n</ul>\n<p id=\"so_453432_453462_1\">To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a non-POD class type, the default constructor for T is called</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li>otherwise, the storage for the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p><code>8.5.1</code>:</p>\n<blockquote>\n<p id=\"so_453432_453462_2\">If there are fewer initializers in the list than there are members in the aggregate, \n  then each member not explicitly initialized shall be <em>default-initialized</em> (8.5). </p>\n</blockquote>\n", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "453466": {"CommentCount": "4", "CreationDate": "2009-01-17T15:42:47.400", "LastEditorUserId": "48015", "LastActivityDate": "2009-01-17T17:28:04.067", "ParentId": "453432", "PostTypeId": "2", "LastEditorDisplayName": "Christoph", "LastEditDate": "2009-01-17T17:28:04.067", "Id": "453466", "Score": "16", "Body": "<p>ISO/IEC 9899:TC3 6.7.8, paragraph 21:</p>\n<blockquote>\n<p id=\"so_453432_453466_0\">If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n<p>Arrays with static storage duration are initialized to <code>0</code>, so the C99 spec guarantees the not explicitly initialized array elements to be set to <code>0</code> as well.</p>\n<hr>\n<p>In my first edit to this post, I spouted some nonsense about using compound literals to assign to an array after initialization. That does not work. If you really want to use compound literals to set an array's values, you have to do something like this:</p>\n<pre><code>#define count(ARRAY) (sizeof(ARRAY)/sizeof(*ARRAY))\n\nint foo[16];\nmemcpy(foo, ((int [count(foo)]){ 1, 2, 3 }), sizeof(foo));\n</code></pre>\n<p>With some macro magic and the non-standard <code>__typeof__</code> operator, this can be considerably shortened:</p>\n<pre><code>#define set_array(ARRAY, ...) \\\n    memcpy(ARRAY, ((__typeof__(ARRAY)){ __VA_ARGS__ }), sizeof(ARRAY))\n\nint foo[16];\nset_array(foo, 1, 2, 3);\n</code></pre>\n</hr>", "OwnerUserId": "48015", "OwnerDisplayName": "Christoph"}, "454404": {"ParentId": "453432", "CommentCount": "0", "Body": "<p>Practically they're the same. The first form is guaranteed to init the whole type to 0x00 (even padding space between structure elements for example), and this is defined since C90.\nUnfortunately gcc gives a warning for the first form with the -Wmissing-field-initializers option. More details here:</p>\n<p><a href=\"http://www.pixelbeat.org/programming/gcc/auto_init.html\" rel=\"nofollow noreferrer\">http://www.pixelbeat.org/programming/gcc/auto_init.html</a></p>\n", "OwnerUserId": "4421", "Id": "454404", "PostTypeId": "2", "OwnerDisplayName": "pixelbeat", "Score": "0", "CreationDate": "2009-01-18T00:45:02.157", "LastActivityDate": "2009-01-18T00:45:02.157"}, "453616": {"ParentId": "453432", "CommentCount": "2", "Body": "<p>Perhaps <code>char myarr[16]={0x00};</code> isn't a good example to begin with, since both the explicit and implicit member initializations use zeros, making it harder to explain what's happening in that situation. I thought that a real-life example, with non-zero values could be more illustrative:</p>\n<pre><code>/**\n * Map of characters allowed in a URL\n *\n * !, \\, (, ), *, -, ., 0-9, A-Z, _, a-z, ~\n *\n * Allowed characters are set to non-zero (themselves, for easier tracking)\n */\nstatic const char ALLOWED_IN_URL[256] = {\n/*          0      1      2      3      4      5      6      7      8      9*/\n/*   0 */   0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n/*  10 */   0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n/*  20 */   0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n/*  30 */   0,     0,     0,    '!',    0,     0,     0,     0,     0,   '\\'',\n/*  40 */  '(',   ')',   '*',    0,     0,    '-',   '.',    0,    '0',   '1',\n/*  50 */  '2',   '3',   '4',   '5',   '6',   '7',   '8',   '9',    0,     0,\n/*  60 */   0,     0,     0,     0,     0,    'A',   'B',   'C',   'D',   'E',\n/*  70 */  'F',   'G',   'H',   'I',   'J',   'K',   'L',   'M',   'N',   'O',\n/*  80 */  'P',   'Q',   'R',   'S',   'T',   'U',   'V',   'W',   'X',   'Y',\n/*  90 */  'Z',    0,     0,     0,     0,    '_',    0,    'a',   'b',   'c',\n/* 100 */  'd',   'e',   'f',   'g' ,  'h',   'i',   'j',   'k',   'l',   'm',\n/* 110 */  'n',   'o',   'p',   'q',   'r',   's',   't',   'u',   'v',   'w',\n/* 120 */  'x',   'y',   'z',    0,     0,     0,    '~',\n};\n</code></pre>\n<p>This is a lookup table that can be used when URL-encoding a string. Only the characters that are allowed in a URL are set to a non-zero value. A zero means that the character is not allowed and needs to be URL-encoded (<code>%xx</code>). Notice that the table abruptly ends with a comma after the tilde character. None of the characters following the tilde are allowed and so should be set to zero. But instead of writing many more zeros to fill the table up to 256 entries, we let the compiler implicitly initialize the rest of the entries to zero.</p>\n", "OwnerUserId": "23501", "Id": "453616", "PostTypeId": "2", "OwnerDisplayName": "Ates Goral", "Score": "3", "CreationDate": "2009-01-17T17:09:35.163", "LastActivityDate": "2009-01-17T17:09:35.163"}, "bq_ids": {"n4140": {"so_453432_453462_0": {"section_id": 3285, "quality": 0.8, "length": 4}, "so_453432_453462_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_453432_453462_2": {"section_id": 3304, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_453432_453462_0": {"section_id": 3155, "quality": 0.8, "length": 4}, "so_453432_453462_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_453432_453462_2": {"section_id": 3174, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_453432_453462_2": {"section_id": 4070, "quality": 0.7142857142857143, "length": 10}}}});