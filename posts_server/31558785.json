post_cb({"31561234": {"ParentId": "31558785", "CommentCount": "0", "Body": "<p>Well the standard is not very clear in my opinion, but I would say that CLang is right :</p>\n<p>8.5.1 says :</p>\n<p>\u00a72 : <em>When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list\nare taken as initializers for the members of the aggregate, in increasing subscript or member order.</em> That is gcc interpretation : name is an array, there is a brace-init-list so first element of the array (a char) is initialized with the char array =&gt; error</p>\n<p>But 8.5.2 explicitely says : <em>An array of narrow character type ... can be initialized by a narrow string literal ... <strong>or by an appropriately-typed string literal enclosed in braces</strong></em></p> (emphasize mine)\n<p>My interpretation is that the standard consideres char arrays as special enough to explicitely allow a string literal enclosed in braces as valid even if it defeats 8.5.1 \u00a72</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "31561234", "Score": "5", "CreationDate": "2015-07-22T11:01:05.520", "LastActivityDate": "2015-07-22T11:01:05.520"}, "31558785": {"CommentCount": "5", "AcceptedAnswerId": "31561234", "LastEditDate": "2015-07-22T10:13:57.073", "LastEditorUserId": "3233393", "CreationDate": "2015-07-22T09:11:20.623", "LastActivityDate": "2015-07-22T11:44:40.450", "PostTypeId": "1", "ViewCount": "576", "FavoriteCount": "1", "Title": "Non-static member initialization of char array with brace gives an error in gcc while not in clang", "Id": "31558785", "OwnerUserId": "586873", "Body": "<p>Consider following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\n    char name[40] = { \"Blank\" }; // note the braces here\npublic:\n    const char *getName() { return name; }\n};\n\nint main()\n{\n    A a;\n\n    std::cout &lt;&lt; a.getName() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It gives an error in <code>gcc</code> (latest version <code>5.2.0</code>):</p>\n<pre><code>prog.cpp:5:28: error: invalid conversion from 'const char*' to 'char' [-fpermissive]\n  char name[40] = { \"Blank\" };\n                            ^\n</code></pre>\n<p>But it's not the case for <code>clang</code>, that compiles it flawlessly with <code>-std=c++11 -pedantic -Wall</code>.</p>\n<p>Is it really incorrect to put braces for non-static initializer here?</p>\n<p>AFAIR it doesn't matter if braces are present or not. For instance, the definition of array, such as:</p>\n<pre><code>char text[] = \"some text\";\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>char text[] = { \"some text\" };\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer>", "Score": "11", "AnswerCount": "4"}, "31561344": {"ParentId": "31558785", "CommentCount": "0", "Body": "<p>The code is valid, and is now accepted by GCC trunk. I think it was fixed by <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65815\">PR 65815 brace elision doesn't work in NSDMI</a></p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "31561344", "Score": "8", "CreationDate": "2015-07-22T11:06:18.287", "LastActivityDate": "2015-07-22T11:06:18.287"}, "31560154": {"ParentId": "31558785", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>From the C++ standard working draft <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">n4527</a>  [dcl.init]. An  initialization can be written like :  </p>\n<p>Initializers</p>\n<blockquote id=\"so_31558785_31560154_0\">\n<pre><code>initializer:\n  brace-or-equal-initializer\n  ( expression-list )\n\nbrace-or-equal-initializer:\n  = initializer-clause\n  braced-init-list\n\ninitializer-clause:\n  assignment-expression\n  braced-init-list\ninitializer-list:\n  initializer-clause...opt\n  initializer-list,initializer-clause...opt\n\nbraced-init-list:\n  {initializer-list,opt}\n  { }\n</code></pre>\n</blockquote>\n<p>A Class member declaration </p>\n<blockquote id=\"so_31558785_31560154_1\">\n<pre><code>member-declarator:\n  declarator virt-specifier-seq opt pure-specifier opt\n  declarator brace-or-equal-initializer opt\n</code></pre>\n</blockquote>\n<p>From what I read it seems like gcc does not meet the standard. Because the class member initialization using the braces is accepted by the standard.</p>\n", "OwnerUserId": "5076707", "LastEditorUserId": "5076707", "LastEditDate": "2015-07-22T10:43:45.587", "Id": "31560154", "Score": "4", "CreationDate": "2015-07-22T10:11:04.443", "LastActivityDate": "2015-07-22T10:43:45.587"}, "31560946": {"ParentId": "31558785", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>fwiw, <code>g++</code> has several problems with brace-based initialisation and/or constructor-calling, including some reported recently.</p>\n<p>However (editing), as Jonathan has rightly pointed out, most (all?) of these can be worked around easily. I have had success substituting the old parenthesis syntax into affected bits of code.</p>\n<p>It would be educational to hear of a situation where this couldn't be done, but thankfully I've not personally found one, so <code>g++</code> remains eminently usable for me (with comments explaining why I use the old syntax in certain odd places!)</p>\n", "OwnerUserId": "2757035", "LastEditorUserId": "2757035", "LastEditDate": "2015-07-22T11:44:40.450", "Id": "31560946", "Score": "2", "CreationDate": "2015-07-22T10:47:58.003", "LastActivityDate": "2015-07-22T11:44:40.450"}, "bq_ids": {"n4659": {"so_31558785_31560154_0": {"section_id": 4042, "quality": 0.5714285714285714, "length": 8}}}});