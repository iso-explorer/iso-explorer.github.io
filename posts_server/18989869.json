post_cb({"bq_ids": {"n4140": {"so_18989869_18991898_3": {"length": 21, "quality": 1.0, "section_id": 305}, "so_18989869_18991898_0": {"length": 23, "quality": 1.0, "section_id": 305}, "so_18989869_18991898_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 305}, "so_18989869_18991898_1": {"length": 12, "quality": 1.0, "section_id": 305}}, "n3337": {"so_18989869_18991898_3": {"length": 21, "quality": 1.0, "section_id": 296}, "so_18989869_18991898_0": {"length": 23, "quality": 1.0, "section_id": 296}, "so_18989869_18991898_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 296}, "so_18989869_18991898_1": {"length": 12, "quality": 1.0, "section_id": 296}}, "n4659": {"so_18989869_18991898_3": {"length": 21, "quality": 1.0, "section_id": 312}, "so_18989869_18991898_0": {"length": 23, "quality": 1.0, "section_id": 312}, "so_18989869_18991898_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 312}, "so_18989869_18991898_1": {"length": 12, "quality": 1.0, "section_id": 312}}}, "18989869": {"ViewCount": "232", "Body": "<p>Say you have two structures, <code>Generic_A</code> and <code>Generic_B</code>. <code>Generic_B</code> is derived from <code>Generic_A</code>. Why is it that when <code>Generic_B</code> tries to access a method in its parent, <code>Generic_A</code>, it generates the following error: </p>\n<pre><code>test2.cpp: In function 'int main()':\ntest2.cpp:26: error: no matching function for call to 'case1(void (Generic_A::*)()' \n</code></pre>\n<p>This code, compiled using gcc version 4.4.6, replicates the problem: </p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct Generic_A\n{\n    void p1() { printf(\"%s\\n\", __PRETTY_FUNCTION__); };\n};\n\nstruct Generic_B : public Generic_A\n{\n    void p2() { printf(\"%s\\n\", __PRETTY_FUNCTION__); };\n};\n\ntemplate &lt;class T,class... ARGS&gt;\nvoid case1( void (T::*p)(ARGS...) ) {\n    printf(\"%s\\n\", __PRETTY_FUNCTION__);\n}\n\ntemplate &lt;class T&gt;\nvoid case2( void (T::*p)() ) {\n    printf(\"%s\\n\", __PRETTY_FUNCTION__);\n}\n\nmain()\n{\n  //generates error\n    case1&lt;Generic_B&gt;(&amp;Generic_B::p1);\n\n  //compiles fine\n    case2&lt;Generic_B&gt;(&amp;Generic_B::p1);\n}\n</code></pre>\n<p>The only apparent difference between the two function calls is that <code>case1()</code> has a template argument parameter, and <code>case2()</code> doesn't. Shouldn't they both allow you to pass a function pointer to a method in Generic_B's parent (ie <code>&amp;Generic_B::p1</code>)?</p>\n<p>Also, casting the function pointer in <code>case1</code> seems to sometimes resolve the error:</p>\n<pre><code>case1&lt;Generic_B&gt;( (void (Generic_B::*)()) &amp;Generic_B::p1);\n</code></pre>\n<p>What is going on? </p>\n", "AcceptedAnswerId": "18991898", "Title": "can't pass function pointer to method in parent class through a variadic function--compiler bug?", "CreationDate": "2013-09-24T19:00:49.280", "Id": "18989869", "CommentCount": "6", "LastEditDate": "2013-09-24T20:27:10.217", "PostTypeId": "1", "LastEditorUserId": "2812261", "LastActivityDate": "2013-09-24T20:56:28.637", "Score": "2", "OwnerUserId": "2812261", "Tags": "<c++><inheritance><function-pointers><variadic><compiler-bug>", "AnswerCount": "1"}, "18991898": {"Id": "18991898", "PostTypeId": "2", "Body": "<p>This is tricky, but it turns out g++ is correct.</p>\n<p>First, the type of expression <code>&amp;Generic_B::p1</code> is <code>void (Generic_A::*)()</code>.  The compiler uses <code>Generic_B::</code> to qualify its name lookup and finds the member of <code>Generic_A</code>.  The expression type depends on the definition of the member found, not the type used within the <em>qualified-id</em>.</p>\n<p>But it's also legal to have</p>\n<pre><code>void (Generic_B::*member)() = &amp;Generic_B::p1;\n</code></pre>\n<p>since there is an implicit conversion from <code>void (Generic_A::*)()</code> to <code>void (Generic_B::*)()</code>.</p>\n<p>Whenever a function template is used as a function call, the compiler goes through three basic steps (or attempts to):</p>\n<ol>\n<li><p>Substitute any explicit template arguments for the template parameters in the function declaration.</p></li>\n<li><p>For each function parameter that still involves at least one template parameter, compare the corresponding function argument to that function parameter, to (possibly) deduce those template parameters.</p></li>\n<li><p>Substitute the deduced template parameters into the function declaration.</p></li>\n</ol>\n<p>In this case, we have the function template declaration</p>\n<pre><code>template &lt;class T,class... ARGS&gt;\nvoid case1( void (T::*p)(ARGS...) );\n</code></pre>\n<p>where the template parameters are <code>T</code> and <code>ARGS</code>, and the function call expression</p>\n<pre><code>case1&lt;Generic_B&gt;(&amp;Generic_B::p1)\n</code></pre>\n<p>where the explicit template argument is <code>Generic_B</code> and the function argument is <code>&amp;Generic_B::p1</code>.</p>\n<p>So step 1, substitute the explicit template argument:</p>\n<pre><code>void case1( void (Generic_B::*p)(ARGS...) );\n</code></pre>\n<p>Step 2, compare parameter types and argument types:</p>\n<p>The parameter type (<code>P</code> in Standard section 14.8.2) is <code>void (Generic_B::*)(ARGS...)</code>.  The argument type (<code>A</code>) is <code>void (Generic_A::*)()</code>.</p>\n<p>C++ Standard (N3485) 14.8.2.1p4:</p>\n<blockquote>\n<p id=\"so_18989869_18991898_0\">In general, the deduction process attempts to find template argument values that will make the deduced <code>A</code> identical to <code>A</code> (after the type <code>A</code> is transformed as described above).  However, there are three cases that allow a difference:</p>\n<ul>\n<li><p id=\"so_18989869_18991898_1\">If the original <code>P</code> is a reference type, the deduced <code>A</code> (i.e., the type referred to by the reference) can be more cv-qualified than the transformed <code>A</code>.</p></li>\n<li><p id=\"so_18989869_18991898_2\">The transformed <code>A</code> can be another pointer or pointer to member type that can be converted to the deduced <code>A</code> via a qualification conversion (4.4).</p></li>\n<li><p id=\"so_18989869_18991898_3\">If <code>P</code> is a class and <code>P</code> has the form <em>simple-template-id</em>, then the transformed <code>A</code> can be a derived class of the deduced <code>A</code>.  Likewise, if <code>P</code> is a pointer to a class of the form <em>simple-template-id</em>, the transformed <code>A</code> can be a pointer to a derived class pointed to by the deduced <code>A</code>.</p></li>\n</ul>\n</blockquote>\n<p>So type deduction allows for certain implicit conversions involving <code>const</code> / <code>volatile</code> and/or derived-to-base conversions, but implicit conversions of pointers to members are not considered.</p>\n<p>In the <code>case1</code> example, type deduction fails, and the function is not a match.</p>\n<p>Unfortunately, there's no way to explicitly specify that your template parameter pack <code>ARGS</code> should be substituted with an empty list.  As you already discovered, you can get this working by explicitly doing the necessary pointer to member function conversion yourself, even though it's otherwise valid as an implicit conversion.</p>\n", "LastActivityDate": "2013-09-24T20:56:28.637", "Score": "1", "CreationDate": "2013-09-24T20:56:28.637", "ParentId": "18989869", "CommentCount": "0", "OwnerUserId": "459640"}});