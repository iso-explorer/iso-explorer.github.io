post_cb({"bq_ids": {"n4140": {"so_27069432_27069592_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5559}}, "n3337": {"so_27069432_27069592_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5341}}, "n4659": {"so_27069432_27069592_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 7006}}}, "27069592": {"Id": "27069592", "PostTypeId": "2", "Body": "<p><strong>Yes, those program fragments have undefined behaviour.</strong></p>\n<p>Table 101 defines <code>test[0]</code> as <code>*(test.begin() + 0)</code>, which is invalid if you have no elements:</p>\n<blockquote>\n<p id=\"so_27069432_27069592_0\"><code>[C++11: 24.2.1/5]:</code> Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called <em>past-the-end</em> values. Values of an iterator <code>i</code> for which the expression <code>*i</code> is defined are called <em>dereferenceable</em>. <strong>The library never assumes that past-the-end values are dereferenceable.</strong> <em>[..]</em></p>\n</blockquote>\n<p>Table 106 states dereferenceability as a pre-requisite for the validity of <code>*i</code>, given any iterator <code>i</code>.</p>\n<p>It doesn't matter that you try to take the address afterwards: you've already broken your program. For example, your standard library implementation may compliantly trigger an assertion from <code>operator*</code> for any past-the-end iterator.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-21T20:33:20.207", "Score": "5", "CreationDate": "2014-11-21T20:18:37.483", "ParentId": "27069432", "CommentCount": "0", "LastEditDate": "2014-11-21T20:33:20.207", "OwnerUserId": "560648"}, "27069432": {"ViewCount": "210", "Body": "<p>Is this undefined behavior?</p>\n<pre><code>ptrdiff_t one() {\n   std::vector&lt;int&gt; test(1);\n   return &amp;test[1] - &amp;test[0];\n}\n</code></pre>\n<p>Is this undefined behavior?</p>\n<pre><code>ptrdiff_t zero() {\n   std::vector&lt;int&gt; test;\n   int * end = &amp;test[0];\n   int * begin = &amp;test[0];\n   return end - begin;\n}\n</code></pre>\n<p>If either of these are undefined behavior, can anyone help me locate the section in the C++11 spec where it describes that the subscript operator of a vector must be called on a value less than (rather than less than or equal to) size, or vice versa?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "27069592", "Title": "Is taking the address of std::vector::operator[](size) Undefined Behavior in C++11", "CreationDate": "2014-11-21T20:07:00.243", "LastActivityDate": "2014-11-21T20:33:20.207", "CommentCount": "7", "LastEditDate": "2014-11-21T20:19:36.540", "PostTypeId": "1", "Tags": "<c++><c++11>", "Id": "27069432", "AnswerCount": "1", "Score": "1", "OwnerUserId": "4280035", "ClosedDate": "2014-11-21T20:33:35.060", "LastEditorUserId": "241631"}});