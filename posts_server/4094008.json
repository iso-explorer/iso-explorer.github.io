post_cb({"4094068": {"Id": "4094068", "PostTypeId": "2", "Body": "<p><strong>Section 3.3.7/2</strong></p>\n<blockquote>\n<p id=\"so_4094008_4094068_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of an object, function, or enumerator declared in the same scope.  <strong>If a class or enumeration name and an object, function, or enumerator are\n  declared in the same scope (in any order) with the same name, the  class  or  enumeration  name  is  hidden\n  wherever the object, function, or enumerator name is visible</strong>.</p>\n</blockquote>\n<p>Then you need to use elaborated type specifier in such cases</p>\n<p><strong>3.4.4/1  Elaborated type specifiers</strong></p>\n<blockquote>\n<p id=\"so_4094008_4094068_1\"><strong>An elaborated-type-specifier may be used to refer to a previously declared class-name or enum-name even\n  though the name has been hidden by a non-type declaration (3.3.7).</strong>  The class-name or enum-name in the\n  elaborated-type-specifier may either be a simple identifer or be a qualified-id.</p>\n</blockquote>\n", "LastActivityDate": "2010-11-04T05:14:05.827", "CommentCount": "2", "CreationDate": "2010-11-04T05:14:05.827", "ParentId": "4094008", "Score": "5", "OwnerUserId": "165520"}, "bq_ids": {"n4140": {"so_4094008_4094068_1": {"length": 14, "quality": 0.5833333333333334, "section_id": 7123}, "so_4094008_4094068_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 7079}}, "n3337": {"so_4094008_4094068_1": {"length": 14, "quality": 0.5833333333333334, "section_id": 6867}, "so_4094008_4094068_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 6823}}, "n4659": {"so_4094008_4094068_1": {"length": 14, "quality": 0.5833333333333334, "section_id": 8624}, "so_4094008_4094068_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 8580}}}, "4094008": {"ViewCount": "389", "Body": "<pre><code>void S(){}\nstruct S{};\n\nint main(){\n   S();\n}\n</code></pre>\n<p>In the code above, the expression 'S()' in main is treated as a function call expression rather than an attempt to create a temporary of type 'S'.</p>\n<p>Which portion of the C++ Standard talks about the resolution of such an expression in favour of a function declaration? For some reason I am unable to locate it.</p>\n", "AcceptedAnswerId": "4094068", "Title": "Ambiguity Resolution", "CreationDate": "2010-11-04T05:00:04.803", "Id": "4094008", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-03-30T17:24:02.163", "Score": "3", "OwnerUserId": "418110", "Tags": "<c++><function><object><declaration><ambiguity>", "AnswerCount": "2"}, "43124532": {"Id": "43124532", "PostTypeId": "2", "Body": "<p>It can be resolved either by using the scope resolution operator(::) or by using virtual keyword(when we are dealing with either multiple or hybrid inheritance.  </p>\n", "LastActivityDate": "2017-03-30T17:24:02.163", "CommentCount": "0", "CreationDate": "2017-03-30T17:24:02.163", "ParentId": "4094008", "Score": "0", "OwnerUserId": "7793632"}});