post_cb({"42587200": {"ParentId": "42586836", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_42586836_42587200_0\">If the second constructor is commented out, then S{{}} is still valid expression, but (I sure) move-constructor from default-constructed instance of S{} is called in the case.</p>\n</blockquote>\n<p>Actually, that's not what happens. The ordering in [dcl.init.list] is:</p>\n<blockquote>\n<p id=\"so_42586836_42587200_1\">List-initialization of an object or reference of type T is defined as follows:<br>\n  \u2014 If T is an aggregate class and the initializer list has a single element of type cv U, [...]<br>\n  \u2014 Otherwise, if T is a character array and [...]<br>\n  \u2014 Otherwise, if T is an aggregate, aggregate initialization is performed (8.6.1).</br></br></br></p>\n</blockquote>\n<p>Once you remove the <code>S(void *)</code> constructor, <code>S</code> becomes an aggregate - it has no user-provided constructor. <code>S() = default</code> doesn't count as user-provided because reasons. Aggregate initialization from <code>{}</code> will end up value-initializing the <code>i</code> member.</p>\n<hr/>\n<blockquote>\n<p id=\"so_42586836_42587200_2\">Why conversion constructor has priority over the default one in the very first case?</p>\n</blockquote>\n<p>With the <code>void*</code> remaining, let's keep going down the bullet list:</p>\n<blockquote>\n<p id=\"so_42586836_42587200_3\">\u2014 Otherwise, if the initializer list has no elements [...]<br>\n  \u2014 Otherwise, if T is a specialization of std::initializer_list, [...]<br>\n  \u2014 Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated\n  and the best one is chosen through overload resolution (13.3, 13.3.1.7).</br></br></p>\n</blockquote>\n<p>[over.match.list] gives us a two-phase overload resolution process:</p>\n<blockquote>\n<p id=\"so_42586836_42587200_4\">\u2014 Initially, the candidate functions are the initializer-list constructors (8.6.4) of the class T and the\n  argument list consists of the initializer list as a single argument.<br>\n  \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class T and the argument list consists of the elements\n  of the initializer list.  </br></p>\n<p id=\"so_42586836_42587200_5\">If the initializer list has no elements and T has a default constructor, the first phase is omitted.</p>\n</blockquote>\n<p><code>S</code> doesn't have any initializer list constructors, so we go into the second bullet and enumerate all the constructors with the argument list of <code>{}</code>. We have multiple viable constructors:</p>\n<pre><code>S(S const&amp; );\nS(S&amp;&amp; );\nS(void *);\n</code></pre>\n<p>The conversion sequences are defined in [over.ics.list]:</p>\n<blockquote>\n<p id=\"so_42586836_42587200_6\">Otherwise, if the parameter is a non-aggregate class X and overload resolution per 13.3.1.7 chooses a single\n  best constructor C of X to perform the initialization of an object of type X from the argument initializer list:<br>\n  \u2014 If C is not an initializer-list constructor and the initializer list has a single element of type cv U, [...]\n  \u2014 Otherwise, the implicit conversion sequence is a <strong>user-defined conversion sequence with the second standard conversion sequence an identity conversion</strong>.</br></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_42586836_42587200_7\">Otherwise, if the parameter type is not a class: [...] \u2014 if the initializer list has no elements, <strong>the implicit conversion sequence is the identity conversion</strong>.</p>\n</blockquote>\n<p>That is, the <code>S(S&amp;&amp; )</code> and <code>S(S const&amp; )</code> constructors are both user-defined conversion sequences plus identity conversion. But <code>S(void *)</code> is just an identity conversion. </p>\n<p>But, [over.best.ics] has this extra rule:</p>\n<blockquote>\n<p id=\"so_42586836_42587200_8\">However, if the target is<br>\n  \u2014 <strong>the first parameter of a constructor</strong> or<br>\n  \u2014 the implicit object parameter of a user-defined conversion function<br>\n  and the constructor or user-defined conversion function is a candidate by<br>\n  \u2014 13.3.1.3, when [...]<br>\n  \u2014 13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases), or<br>\n  \u2014 <strong>the second phase of 13.3.1.7 when the initializer list has exactly one element that is itself an initializer list, and the target is the first parameter of a constructor of class <code>X</code>, and the conversion is to <code>X</code> or reference to (possibly cv-qualified) <code>X</code></strong>,  </br></br></br></br></br></br></p>\n<p id=\"so_42586836_42587200_9\"><strong>user-defined conversion sequences are not considered.</strong></p>\n</blockquote>\n<p>This excludes from consideration <code>S(S const&amp;)</code> and <code>S(S&amp;&amp; )</code> as candidates - they are precisely this case - the target being the first parameter of the constructor as a result of the second phase of [over.match.list] and the target being a reference to possibly cv-qualified <code>S</code>, and such a conversion sequence would be user-defined.</p>\n<p>Hence, the only remaining candidate is <code>S(void *)</code>, so it's trivially the best viable candidate. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-03-05T17:03:58.303", "Id": "42587200", "Score": "9", "CreationDate": "2017-03-03T19:43:35.740", "LastActivityDate": "2017-03-05T17:03:58.303"}, "bq_ids": {"n4140": {"so_42586836_42587200_6": {"section_id": 632, "quality": 0.7631578947368421, "length": 29}, "so_42586836_42587200_4": {"section_id": 599, "quality": 0.9705882352941176, "length": 33}, "so_42586836_42587200_1": {"section_id": 3325, "quality": 0.6363636363636364, "length": 14}, "so_42586836_42587200_3": {"section_id": 3325, "quality": 0.8260869565217391, "length": 19}, "so_42586836_42587200_7": {"section_id": 635, "quality": 1.0, "length": 12}, "so_42586836_42587200_5": {"section_id": 599, "quality": 1.0, "length": 8}, "so_42586836_42587200_8": {"section_id": 609, "quality": 0.8181818181818182, "length": 36}}, "n3337": {"so_42586836_42587200_4": {"section_id": 589, "quality": 0.9705882352941176, "length": 33}, "so_42586836_42587200_6": {"section_id": 622, "quality": 0.7105263157894737, "length": 27}, "so_42586836_42587200_3": {"section_id": 3195, "quality": 0.782608695652174, "length": 18}, "so_42586836_42587200_7": {"section_id": 625, "quality": 1.0, "length": 12}, "so_42586836_42587200_5": {"section_id": 589, "quality": 1.0, "length": 8}}, "n4659": {"so_42586836_42587200_4": {"section_id": 622, "quality": 0.9705882352941176, "length": 33}, "so_42586836_42587200_6": {"section_id": 660, "quality": 0.9736842105263158, "length": 37}, "so_42586836_42587200_3": {"section_id": 4091, "quality": 0.8260869565217391, "length": 19}, "so_42586836_42587200_7": {"section_id": 663, "quality": 1.0, "length": 12}, "so_42586836_42587200_5": {"section_id": 622, "quality": 1.0, "length": 8}, "so_42586836_42587200_1": {"section_id": 4091, "quality": 0.9545454545454546, "length": 21}, "so_42586836_42587200_8": {"section_id": 635, "quality": 0.8409090909090909, "length": 37}}}, "42586836": {"CommentCount": "2", "AcceptedAnswerId": "42587200", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2017-03-03T19:21:44.863", "LastActivityDate": "2017-03-05T17:03:58.303", "LastEditDate": "2017-03-04T07:25:01.563", "ViewCount": "583", "FavoriteCount": "0", "Title": "Double brace initialization", "Id": "42586836", "Score": "11", "Body": "<p>Which constructor should be called in the following code and why?</p>\n<pre><code>struct S\n{\n    int i;\n    S() = default;\n    S(void *) : i{1} { ; }\n};\n\nS s{{}};\n</code></pre>\n<p>If I use <code>clang</code> (from trunk), then the second one is called.</p>\n<p>If the second constructor is commented out, then <code>S{{}}</code> is still valid expression, but (I believe) move-constructor from default-constructed instance of <code>S{}</code> is called in the case.</p>\n<p>Why conversion constructor has priority over the default one in the very first case?</p>\n<p>The intention of such a combination of the constructors of <code>S</code> is to save its <code>std::is_trivially_default_constructible_v&lt; S &gt;</code> property, except a finite set of cases, when it should be initialized in a certain way.</p>\n", "Tags": "<c++><initialization><c++14><language-lawyer><default-constructor>", "OwnerUserId": "1430927", "AnswerCount": "1"}});