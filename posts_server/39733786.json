post_cb({"39733911": {"ParentId": "39733786", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_39733786_39733911_0\">but I don't understand why implicit conversion doesn't take place.</p>\n</blockquote>\n<p>There's no context for it to take place in. <code>operator-&gt;</code> applies implicitly to pointers, or to class types with that operator defined. But that's it. There's no other sequence through which the compiler will look to find it. In this case, the built-in candidate set for <code>b-&gt;</code> is empty, there is no <code>operator-&gt;</code>, hence compile error. </p>\n<p>You just want to add:</p>\n<pre><code>A* operator-&gt;() { return &amp;a; }\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "39733911", "Score": "3", "CreationDate": "2016-09-27T20:40:28.163", "LastActivityDate": "2016-09-27T20:40:28.163"}, "39733908": {"ParentId": "39733786", "CommentCount": "0", "Body": "<p>This is a consequence of how overload resolution is defined for the <code>-&gt;</code> operator. Quoting from C++14 [over.match.oper]/3:</p>\n<blockquote>\n<p id=\"so_39733786_39733908_0\">For the operator <code>,</code>, the unary operator <code>&amp;</code>, or the operator <code>-&gt;</code>, the built-in candidates set is empty.</p>\n</blockquote>\n<p>That is, if the left side operand of <code>-&gt;</code> is of class or enumeration type, then the <code>-&gt;</code> will never have its built-in meaning; instead, name lookup for <code>operator-&gt;</code> as a member of the left side operand's class <em>must</em> succeed.</p>\n<p>If the built-in <code>-&gt;</code> operator were a candidate, then the compiler could consider implicit conversions that would allow <code>B</code> to be converted to a type that the built-in <code>-&gt;</code> could take, but it is not a candidate, so that doesn't happen.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "39733908", "Score": "5", "CreationDate": "2016-09-27T20:40:18.527", "LastActivityDate": "2016-09-27T20:40:18.527"}, "bq_ids": {"n4140": {"so_39733786_39733908_0": {"section_id": 584, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_39733786_39733908_0": {"section_id": 574, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_39733786_39733908_0": {"section_id": 607, "quality": 0.8888888888888888, "length": 8}}}, "39733786": {"CommentCount": "0", "ViewCount": "43", "CreationDate": "2016-09-27T20:32:33.820", "LastActivityDate": "2016-09-27T20:42:08.723", "Title": "Why doesn't this class implicitly convert to a pointer?", "AcceptedAnswerId": "39733908", "PostTypeId": "1", "Id": "39733786", "Score": "3", "Body": "<pre><code>struct A {\n  int i;\n};\n\nstruct B {\n  A a;\n\n  operator A*() { return &amp;a; }\n};\n\nint main(int argc, char *argv[])\n{\n  B b;\n\n  return b-&gt;i;\n}\n</code></pre>\n<p><code>g++</code> reports <code>error: base operand of \u2018-&gt;\u2019 has non-pointer type \u2018B\u2019</code></p>\n<p>Why?  I've figured out how to circumvent this problem (using <code>operator-&gt;</code>), but I don't understand why implicit conversion doesn't take place.</p>\n", "Tags": "<c++><conversion-operator>", "OwnerUserId": "1493790", "AnswerCount": "3"}, "39733893": {"ParentId": "39733786", "CommentCount": "0", "Body": "<p>Because C++ will only implicitly convert a class instance when it knows what it should convert to. If you use expressions like <code>b-&gt;</code>, it can't know <em>what</em> pointer type (if any) you would want to convert it to, and will just use the normal operators (which are not defined unless overloaded):</p>\n<pre><code>B b;\n\n// calls B::operator-&gt; since that's what you tell it to do\nb-&gt;i;\n\n// calls B::operator A* since it knows it's implicitly converting to A*\nA *a = b;\n</code></pre>\n<p>If you want to use the first expression here, the <em>correct</em> way is to overload <code>operator-&gt;</code>:</p>\n<pre><code>class B {\n  /* ... */\n\n  A* operator -&gt;() { return &amp;a; }\n}\n</code></pre>\n", "OwnerUserId": "423170", "PostTypeId": "2", "Id": "39733893", "Score": "3", "CreationDate": "2016-09-27T20:39:39.050", "LastActivityDate": "2016-09-27T20:39:39.050"}});