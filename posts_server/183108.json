post_cb({"183108": {"CommentCount": "0", "ViewCount": "1521", "OwnerDisplayName": "hsivonen", "CreationDate": "2008-10-08T14:41:16.737", "LastActivityDate": "2017-07-17T17:28:49.407", "PostTypeId": "1", "AcceptedAnswerId": "183235", "FavoriteCount": "3", "Title": "Is object code generated for unused template class methods?", "Id": "183108", "Score": "11", "Body": "<p>I have a C++ template class that gets instantiated with 3 different type parameters. There's a method that the class needs to have for only one of those types and that isn't ever called with the two other types.</p>\n<p>Will object code for that method be generated thrice (for all types for which the template is instantiated), or is object code generated only once (for the type with which it is actually used)?</p>\n", "Tags": "<c++><templates><footprint>", "OwnerUserId": "18721", "AnswerCount": "3"}, "183157": {"ParentId": "183108", "CommentCount": "0", "Body": "<p>Usually, yes.</p>\n<p>All the compiler really knows is that your program can create at least one instance of each class.  But it doesn't know what you will do with those instances.  So the code will almost certain be generated.</p>\n<p>That said, if the methods in question are <em>not</em> virtual, and are never called, the <em>linker</em> can remove them with its normal dead code removal features.  So the generated (and compiled) code won't be in the final EXE.</p>\n<p>Also this will largely depend on the C++ compiler being used because they're not all the same.</p>\n", "OwnerUserId": "25879", "Id": "183157", "PostTypeId": "2", "OwnerDisplayName": "Jeff B", "Score": "1", "CreationDate": "2008-10-08T14:46:44.290", "LastActivityDate": "2008-10-08T14:46:44.290"}, "184233": {"ParentId": "183108", "CommentCount": "1", "Body": "<p>I think it depends on the compiler and settings. For example, I believe MSVC6 generated everything, but VS2005 does not. The spec says the compiler should not, but in the real world, it depends on the actual compiler (there are many work-arounds in boost for MSVC6, for example). The linker can remove unreferenced functions if /opt:ref is enabled (for VS, equivalent options exist for other compilers).</p>\n", "OwnerUserId": "26240", "PostTypeId": "2", "Id": "184233", "Score": "2", "CreationDate": "2008-10-08T18:43:25.750", "LastActivityDate": "2008-10-08T18:43:25.750"}, "183235": {"CommentCount": "3", "CreationDate": "2008-10-08T14:59:05.560", "CommunityOwnedDate": "2008-10-08T16:21:27.767", "LastEditorUserId": "27678", "LastActivityDate": "2017-07-17T17:28:49.407", "ParentId": "183108", "PostTypeId": "2", "LastEditorDisplayName": "Kristopher Johnson", "LastEditDate": "2017-07-17T17:28:49.407", "Id": "183235", "Score": "18", "Body": "<p>Virtual member functions are instantiated when a class template is instantiated, but non-virtual member functions are instantiated only if they are called.</p>\n<p>This is covered in [temp.inst] in the C++ standard (In C++11, this is \u00a714.7.1/10. In C++14, it is \u00a714.7.1/11, and in C++17 it is \u00a717.7.1/9. Excerpt from C++17 below)</p>\n<blockquote>\n<p id=\"so_183108_183235_0\">An implementation shall not implicitly instantiate a function template, a variable template, a member\n  template, a non-virtual member function, a member class, a static data member of a class template, or\n  a substatement of a <code>constexpr</code> if statement (9.4.1), unless such instantiation is required</p>\n</blockquote>\n<p>Also note that it is possible to instantiate a class template even if some of the member functions are not instantiable for the given template parameters.  For example:</p>\n<pre><code>template &lt;class T&gt;\nclass Xyzzy\n{\npublic:\n    void CallFoo() { t.foo(); }  // Invoke T::foo()\n    void CallBar() { t.bar(); }  // Invoke T::bar()\n\nprivate:\n    T t;\n};\n\nclass FooBar\n{\npublic:\n    void foo() { ... }\n    void bar() { ... }\n};\n\nclass BarOnly\n{\npublic:\n    void bar() { ... }\n};\n\nint main(int argc, const char** argv)\n{\n    Xyzzy&lt;FooBar&gt;  foobar;    // Xyzzy&lt;FooBar&gt; is instantiated\n    Xyzzy&lt;BarOnly&gt; baronly;   // Xyzzy&lt;BarOnly&gt; is instantiated\n\n    foobar.CallFoo();         // Calls FooBar::foo()\n    foobar.CallBar();         // Calls FooBar::bar()\n\n    baronly.CallBar();        // Calls BarOnly::bar()\n\n    return 0;\n}\n</code></pre>\n<p>This is valid, even though Xyzzy::CallFoo() is not instantiable because there is no such thing as BarOnly::foo().  This feature is used often as a template metaprogramming tool.</p>\n<p>Note, however, that \"instantiation\" of a template does not directly correlate to how much object code gets generated.  That will depend upon your compiler/linker implementation.</p>\n", "OwnerUserId": "1175", "OwnerDisplayName": "Kristopher Johnson"}, "bq_ids": {"n4140": {"so_183108_183235_0": {"section_id": 243, "quality": 0.7307692307692307, "length": 19}}, "n3337": {"so_183108_183235_0": {"section_id": 235, "quality": 0.6538461538461539, "length": 17}}, "n4659": {"so_183108_183235_0": {"section_id": 250, "quality": 0.9615384615384616, "length": 25}}}});