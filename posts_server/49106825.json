post_cb({"bq_ids": {"n4140": {"so_49106825_49108009_2": {"length": 16, "quality": 0.7619047619047619, "section_id": 63}, "so_49106825_49108009_1": {"length": 6, "quality": 0.6, "section_id": 3255}}, "n3337": {"so_49106825_49108009_2": {"length": 16, "quality": 0.7619047619047619, "section_id": 58}, "so_49106825_49108009_1": {"length": 6, "quality": 0.6, "section_id": 3127}}, "n4659": {"so_49106825_49108009_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 65}, "so_49106825_49108009_1": {"length": 6, "quality": 0.6, "section_id": 4013}}}, "49106825": {"ViewCount": "239", "Body": "<p>The following stripped down code doesn't work with the latest clang++5 but is accepted by g++7:</p>\n<pre><code>template&lt;typename Wrapped, typename U&gt;\nstruct wrapper;\n\ntemplate&lt;typename Wrapped, typename U=int&gt;\nstruct wrapper\n{\n    wrapper() = default;\n\n    // Automatic deduction guide\n    constexpr explicit wrapper(Wrapped) noexcept {}\n};\n\nint main()\n{\n    struct {} dummy;\n    constexpr auto wrapped = wrapper(dummy);\n}\n</code></pre>\n<p>It fails with the following error messages:</p>\n<pre><code>&lt;source&gt;:18:30: error: no viable constructor or deduction guide for deduction of template arguments of 'wrapper'\n    constexpr auto wrapped = wrapper(dummy);\n                             ^\n&lt;source&gt;:12:24: note: candidate template ignored: couldn't infer template argument 'U'\n    constexpr explicit wrapper(Wrapped) noexcept {}\n                       ^\n&lt;source&gt;:4:8: note: candidate template ignored: could not match 'wrapper&lt;Wrapped, U&gt;' against '(anonymous struct at &lt;source&gt;:17:5)'\nstruct wrapper;\n       ^\n&lt;source&gt;:9:5: note: candidate function template not viable: requires 0 arguments, but 1 was provided\n    wrapper() = default;\n    ^\n</code></pre>\n<p>However if I move the default template parameter <code>=int</code> from the class template definition to the forward declaration, everything works perfectly (<code>U</code> being deduced to <code>int</code> as expected), as if only the default template parameter in the forward declaration was taken into account when create the set of fictional function templates used by deduction guides.</p>\n<p>I tried to read the standard wording but couldn't get much out of it for this  specific case. Is only taking the default template parameter in the forward declaration the intended behaviour when generating the fictional function templates, or is this a compiler bug?</p>\n", "AcceptedAnswerId": "49108009", "Title": "Class template argument deduction and default template parameters", "CreationDate": "2018-03-05T09:10:52.887", "Id": "49106825", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-03-05T13:49:08.010", "Score": "11", "OwnerUserId": "1364752", "Tags": "<c++><templates><language-lawyer><c++17><template-deduction>", "AnswerCount": "1"}, "49108009": {"Id": "49108009", "PostTypeId": "2", "Body": "<p>This is not a quote of the Standard per se<sup>1</sup>, but I feel confident enough to consider it an answer.</p>\n<p>According to cppreference, on <a href=\"http://en.cppreference.com/w/cpp/language/template_parameters#Default_template_arguments\" rel=\"nofollow noreferrer\"><em>Default template arguments</em></a>:</p>\n<blockquote>\n<p id=\"so_49106825_49108009_0\">Default template arguments that appear in the declarations and the definition are merged similarly to default function arguments:</p>\n<pre><code>template&lt;typename T1, typename T2 = int&gt; class A;\ntemplate&lt;typename T1 = int, typename T2&gt; class A;\n// the above is the same as the following:\ntemplate&lt;typename T1 = int, typename T2 = int&gt; class A;\n</code></pre>\n<p id=\"so_49106825_49108009_1\">But the same parameter cannot be given default arguments twice in the same scope</p>\n<pre><code>template&lt;typename T = int&gt; class X;\ntemplate&lt;typename T = int&gt; class X {}; // error\n</code></pre>\n</blockquote>\n<p>This implies an implicit rule: <em>A template type argument can be given a default type in the template declaration or template definition interchangeably</em>.</p>\n<p>The behavior clang++5 exhibits is definitly a bug.</p>\n<hr>\n<p><sup>1)</sup> Provided by user Oliv:</p>\n<blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp#param-10\" rel=\"nofollow noreferrer\"><code>[temp.param]/10</code></a></h3>\n<p id=\"so_49106825_49108009_2\">The set of default <em>template-arguments</em> available for use is obtained by merging the default arguments from all prior declarations of the template in the same way default function arguments are (<code>[dcl.fct.default]</code>). [\u2009Example:</p>\n<pre><code>template&lt;class T1, class T2 = int&gt; class A;\ntemplate&lt;class T1 = int, class T2&gt; class A;\n</code></pre>\n<p id=\"so_49106825_49108009_3\">is equivalent to</p>\n<pre><code>template&lt;class T1 = int, class T2 = int&gt; class A;\n</code></pre>\n<p id=\"so_49106825_49108009_4\">\u2009\u2014\u2009end example\u2009]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "5470596", "LastActivityDate": "2018-03-05T13:49:08.010", "Score": "6", "CreationDate": "2018-03-05T10:14:45.107", "ParentId": "49106825", "CommentCount": "3", "OwnerUserId": "5470596", "LastEditDate": "2018-03-05T13:49:08.010"}});