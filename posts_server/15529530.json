post_cb({"15529530": {"CommentCount": "3", "ViewCount": "545", "CreationDate": "2013-03-20T16:41:08.077", "LastActivityDate": "2013-03-20T16:56:14.017", "Title": "Casting down the hierarchy a concrete object", "AcceptedAnswerId": "15529908", "PostTypeId": "1", "Id": "15529530", "Score": "1", "Body": "<p>I am looking at a piece of code where there's a c-style cast that puzzles me.</p>\n<p>I am fairly familiar with casting, but this one I really can't grasp. So, here it is: I have two classes, say Base and Derived, but Derived does not add any method/attribute. Basically it's just a particular case of Base when one of its attributes (call it M_blockSize) is fixed to 1; however, none of the methods requires a particular implementation nor there is an extension of functionalities. The benefit of such Derived class is not the point of this thread. Let's assume the developers had their good reasons for this.</p>\n<p>Anyway, in the piece of code I'm looking something like this happens:</p>\n<pre><code>void foo(const Derived&amp; d){...}\n[...]\nBase b;\nfoo((Derived&amp;) b);\n</code></pre>\n<p>So, the developers casted the base object into a reference to a derived one. In my understanding, downcasting is done if the concrete type of the \"castee\" (b) is indeed Derived. Which is not the case here.</p>\n<p>However, this is c-style cast, so the compiler is trying a whole bunch of casts and I don't know which one it eventually works.</p>\n<p>So, questions:</p>\n<ul>\n<li>1) what casting is the compiler doing? I'm assuming a reinterpret_cast maybe?</li>\n<li>2) would static_cast&lt; Derived&amp; &gt;(b) work as well?</li>\n<li>3) if class Derived added some methods/attributes (not used in foo), would this still work?</li>\n<li>4) is the key point that foo does not use any functionality of Derived that is not already in Base?</li>\n</ul>\n<p>I hope the question is clear. Thank you for your help.</p>\n", "Tags": "<c++><casting><derived-class>", "OwnerUserId": "1093346", "AnswerCount": "1"}, "15529908": {"ParentId": "15529530", "CommentCount": "1", "Body": "<p>The cast in effect here is a <code>static_cast&lt;Derived&amp;&gt;</code>, governed by the following rule (\u00a75.2.9 Static cast):</p>\n<blockquote>\n<p id=\"so_15529530_15529908_0\">An lvalue of type \"<em>cv1</em> <code>B</code>,\" where <code>B</code> is a class type, can be cast to type \"reference to <em>cv2</em> <code>D</code>,\" where <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard conversion from \"pointer to <code>D</code>\" to \"pointer to B\" exists (4.10), <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The result has type \"<em>cv2</em> <code>D</code>.\"</p>\n</blockquote>\n<p>The cast \"pointer to <code>D</code>\" to \"pointer to <code>B</code>\" is a valid standard conversion (\u00a74.10):</p>\n<blockquote>\n<p id=\"so_15529530_15529908_1\">A prvalue of type \"pointer to <em>cv</em> <code>D</code>\", where <code>D</code> is a class type, can be converted to a prvalue of type \"pointer to <em>cv</em> <code>B</code>\", where <code>B</code> is a base class (Clause 10) of <code>D</code>.</p>\n</blockquote>\n<p>However, just because the cast works, doesn't mean it's okay to do. Note (\u00a75.2.9):</p>\n<blockquote>\n<p id=\"so_15529530_15529908_2\">If the object of type \"<em>cv1</em> <code>B</code>\" is actually a subobject of an object of type <code>D</code>, the result refers to the enclosing object of type <code>D</code>. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n<p>So this code results in undefined behaviour. You <em>can</em> cast from a base class to any of its derived classes, but you only have define behaviour if it truly is an object of that derived type.</p>\n<p>So to answer the questions:</p>\n<ol>\n<li>It's a <code>static_cast&lt;Derived&amp;&gt;</code>.</li>\n<li>Yes, because that's what's happening.</li>\n<li>It doesn't work anyway because it results in undefined behaviour.</li>\n<li>I can't be certain what the point was here. I'd expect that it <em>might</em> continue to perform as expected if you don't use any <code>Derived</code> specific features inside <code>foo</code>. However, if that's the case, just take a <code>Base&amp;</code>.</li>\n</ol>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15529908", "Score": "1", "CreationDate": "2013-03-20T16:56:14.017", "LastActivityDate": "2013-03-20T16:56:14.017"}, "bq_ids": {"n4140": {"so_15529530_15529908_1": {"section_id": 41, "quality": 1.0, "length": 15}, "so_15529530_15529908_2": {"section_id": 6028, "quality": 0.8125, "length": 13}, "so_15529530_15529908_0": {"section_id": 6028, "quality": 0.8333333333333334, "length": 35}}, "n3337": {"so_15529530_15529908_1": {"section_id": 38, "quality": 1.0, "length": 15}, "so_15529530_15529908_2": {"section_id": 5796, "quality": 0.9375, "length": 15}, "so_15529530_15529908_0": {"section_id": 5796, "quality": 0.8333333333333334, "length": 35}}, "n4659": {"so_15529530_15529908_1": {"section_id": 41, "quality": 1.0, "length": 15}, "so_15529530_15529908_2": {"section_id": 7527, "quality": 0.8125, "length": 13}, "so_15529530_15529908_0": {"section_id": 7527, "quality": 0.6666666666666666, "length": 28}}}});