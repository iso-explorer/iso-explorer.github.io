post_cb({"bq_ids": {"n4140": {"so_39256916_39257706_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 2427}, "so_39256916_39257706_3": {"length": 9, "quality": 0.6, "section_id": 2426}, "so_39256916_39257706_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 2426}, "so_39256916_39257706_1": {"length": 18, "quality": 0.782608695652174, "section_id": 2471}}, "n3337": {"so_39256916_39257706_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 2412}, "so_39256916_39257706_3": {"length": 9, "quality": 0.6, "section_id": 2411}, "so_39256916_39257706_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 2411}, "so_39256916_39257706_1": {"length": 18, "quality": 0.782608695652174, "section_id": 2456}}, "n4659": {"so_39256916_39257706_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 2702}, "so_39256916_39257706_3": {"length": 9, "quality": 0.6, "section_id": 2701}, "so_39256916_39257706_2": {"length": 28, "quality": 0.7777777777777778, "section_id": 2701}, "so_39256916_39257706_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 2733}}}, "39256916": {"ViewCount": "1254", "Body": "<p>If you call the <code>std::ofstream</code> constructor without <code>openmode</code> flags, the <a href=\"http://www.cplusplus.com/reference/fstream/ofstream/ofstream/\" rel=\"nofollow\">default flag is <code>ios_base::out</code></a>. But does this imply <code>ios_base::trunc</code> or <code>ios_base::app</code>? </p>\n<p>In other words, if you already have a non-empty file \"past.txt\" in your file system and you call</p>\n<pre><code>std::ofstream stream( \"past.txt\" );\nstream &lt;&lt; \"new content\";\n</code></pre>\n<p>will \"new content\" be appended to the prior contents of \"past.txt\" or will it replace the prior contents?</p>\n", "AcceptedAnswerId": "39257706", "Title": "Does std::ofstream truncate or append by default?", "CreationDate": "2016-08-31T18:48:15.757", "Id": "39256916", "CommentCount": "5", "LastEditDate": "2016-08-31T18:54:47.777", "PostTypeId": "1", "LastEditorUserId": "4342498", "LastActivityDate": "2016-09-01T18:13:37.193", "Score": "5", "OwnerUserId": "358475", "Tags": "<c++><fstream>", "AnswerCount": "1"}, "39257706": {"Id": "39257706", "PostTypeId": "2", "Body": "<h2>The short version</h2>\n<p>The standard is basically spaghetti on this, but it eventually boils down to saying that it's the equivalent of saying <code>fopen(const char*, \"w\")</code> (27.9.1.4 [filebuf.members]), which then points us towards the ISO C 7.9 standard. </p>\n<p>Checking that out provides us with \u00a77.19.5.3, \"The fopen function\", which specifies the behavior when \"w\" is passed:</p>\n<blockquote>\n<p id=\"so_39256916_39257706_0\">w truncate to zero length or create text file for writing</p>\n</blockquote>\n<hr>\n<p><h2>The long version</h2> If you'd like to follow the spaghetti trail yourself, start with 27.9.1.11 [ofstream.cons], which describes the constructor's behavior as</p>\n<blockquote>\n<p id=\"so_39256916_39257706_1\">Effects: Constructs an object of <code>class basic_ofstream&lt;charT,traits&gt;</code>, initializing the base class with\n  <code>basic_ostream(&amp;sb</code>) and initializing <code>sb</code> with <code>basic_filebuf&lt;charT,traits&gt;())</code> (27.7.3.2, 27.9.1.2),\n  then calls <code>rdbuf()-&gt;open(s, mode|ios_base::out)</code>. If that function returns a null pointer, calls\n  <code>setstate(failbit)</code>.</p>\n</blockquote>\n<p>Where <code>rdbuf()</code> returns <code>basic_filebuf&lt;charT,traits&gt;*</code> (27.9.1.13 [ofstream])</p>\n<p>Which leads us to 27.9.1.1 [filebuf], or more specifically, 27.9.1.4 [filebuf.members] , which describes the <code>open</code> function:</p>\n<pre><code>basic_filebuf&lt;charT,traits&gt;* open(const char* s, ios_base::openmode mode);\n</code></pre>\n<p>as</p>\n<blockquote>\n<p id=\"so_39256916_39257706_2\">Effects: If <code>is_open() != false</code>, returns a null pointer. Otherwise, initializes the filebuf as required.\n  It then opens a file, if possible, whose name is the NTBS <code>s</code> (as if by calling <code>std::fopen(s,modstr)</code>).\n  The NTBS <code>modstr</code> is determined from <code>mode &amp; ~ios_base::ate</code> as indicated in Table 132. If mode is\n  not some combination of flags shown in the table then the open fails.</p>\n</blockquote>\n<p>NTBS: Null-terminated byte-string</p>\n<p>Table 132 describes equivalence rules between C++ <code>ios_base::openmode</code> and C-style stdio strings:</p>\n<blockquote id=\"so_39256916_39257706_3\">\n<pre><code><b>Table 132</b> \u2014 File open modes\n|\n|   'ios_base' flag combination   | 'stdio' equivalent |\n| binary | in | out | trunc | app |                    |\n|        |    |  +  |       |     |        \"w\"         |\n|                     etc...                           |\n</code></pre>\n</blockquote>\n<p>Which leads us to a footnote on the same page that states:</p>\n<blockquote>\n<p id=\"so_39256916_39257706_4\">...the function signatures <code>fopen(const char*, const char*)</code> and <code>fseek(FILE*, long,\n  int)</code> are declared, in <code>&lt;cstdio&gt;</code> (27.9.2).</p>\n</blockquote>\n<p>Which sends us, predictably, to 27.9.2 [c.files], which provides the nearly useless Table 134, but then references the C standard:</p>\n<blockquote>\n<p id=\"so_39256916_39257706_5\">See also: ISO C 7.9, Amendment 1 4.6.2.</p>\n</blockquote>\n<p>Which I talk about in the main portion of this answer.</p>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2016-09-01T18:13:37.193", "Score": "17", "CreationDate": "2016-08-31T19:38:21.353", "ParentId": "39256916", "CommentCount": "0", "LastEditDate": "2016-09-01T18:13:37.193", "OwnerUserId": "27678"}});