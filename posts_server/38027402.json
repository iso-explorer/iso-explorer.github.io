post_cb({"38027402": {"CommentCount": "0", "AcceptedAnswerId": "38027496", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-25T10:23:43.883", "LastActivityDate": "2016-06-25T10:44:11.713", "LastEditDate": "2017-05-23T10:34:05.533", "ViewCount": "214", "FavoriteCount": "1", "Title": "Unique pointer still holds the object after moving", "Id": "38027402", "Score": "1", "Body": "<p>I'm going through some tutorials on how smart pointers work in <strong>C++</strong>, but I'm stuck on the first one I tried: the <em>unique pointer</em>.  I'm following guidelines from <a href=\"https://en.wikipedia.org/wiki/Smart_pointer\" rel=\"nofollow noreferrer\">wikipedia</a>, <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow noreferrer\">cppreference</a> and <a href=\"http://www.cplusplus.com/reference/memory/unique_ptr/\" rel=\"nofollow noreferrer\">cplusplus</a>.  I've also looked at <a href=\"https://stackoverflow.com/questions/16894400/how-to-declare-stdunique-ptr-and-what-is-the-use-of-it\">this answer</a> already. A unique pointer is supposed to be the only pointer that has ownership over a certain memory cell/block if I understood this correctly. This means that only the unique pointer (should) point to that cell and no other pointer. From wikipedia they use the following code as an example:</p>\n<pre><code>std::unique_ptr&lt;int&gt; p1(new int(5));\nstd::unique_ptr&lt;int&gt; p2 = p1; //Compile error.\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); //Transfers ownership. p3 now owns the memory and p1 is rendered invalid.\n\np3.reset(); //Deletes the memory.\np1.reset(); //Does nothing.\n</code></pre>\n<p>Until the second line, that worked fine for me when I test it.  However, after <em>moving</em> the first unique pointer to a second unique pointer, I find that both pointers have access to the same object. I thought the whole idea was for the first pointer to be rendered useless so to speak? I expected a null pointer or some undetermined result. The code I ran:</p>\n<pre><code>class Figure {\npublic:\n    Figure() {}\n\n    void three() {\n        cout &lt;&lt; \"three\" &lt;&lt; endl;\n    }\n\n};\n\nclass SubFig : public Figure {\npublic:\n    void printA() {\n        cout &lt;&lt; \"printed a\" &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    unique_ptr&lt;SubFig&gt; testing (new SubFig());\n    testing-&gt;three();\n    unique_ptr&lt;SubFig&gt; testing2 = move(testing);\n    cout &lt;&lt; \"ok\" &lt;&lt; endl;\n    int t;\n    cin &gt;&gt; t; // used to halt execution so I can verify everything works up til here\n    testing-&gt;three(); // why is this not throwing a runtime error?\n}\n</code></pre>\n<p>Here, <code>testing</code> has been moved to <code>testing2</code>, so I'm surprised to find I can still call the method <code>three()</code> on <code>testing</code>.</p>\n<p>Also, calling <em>reset()</em> doesn't seem to delete the memory like it said it would. When I modify the main method to become:</p>\n<pre><code>int main()\n{\n    unique_ptr&lt;SubFig&gt; testing (new SubFig());\n    testing-&gt;three();\n    unique_ptr&lt;SubFig&gt; testing2 = move(testing);\n    cout &lt;&lt; \"ok\" &lt;&lt; endl;\n    int t;\n    cin &gt;&gt; t;\n    testing.reset(); // normally this should have no effect since the pointer should be invalid, but I added it anyway\n    testing2.reset();\n    testing2-&gt;three();\n}\n</code></pre>\n<p>Here I expect <code>three()</code> not to work for <code>testing2</code> since the example from wikipedia mentioned the memory should be deleted by resetting. I'm still printing out <em>printed a</em> as if everything is fine.  That seems weird to me.</p>\n<p>So can anyone explain to me why:</p>\n<ul>\n<li>moving from one unique pointer to another unique pointer doesn't make the first one invalid?</li>\n<li>resetting does not actually <em>remove</em> the memory? What's actually happening when <code>reset()</code> is called?</li>\n</ul>\n", "Tags": "<c++><pointers>", "OwnerUserId": "2959880", "AnswerCount": "3"}, "38027436": {"ParentId": "38027402", "CommentCount": "3", "Body": "<p>On calling <code>std::unique_ptr&lt;int&gt; p3 = std::move(p1);</code> your original pointer <code>p1</code> is in undefined state, as such using it will result in undefined behavior. Simply stated, never ever do it.</p>\n", "OwnerUserId": "2990896", "PostTypeId": "2", "Id": "38027436", "Score": "1", "CreationDate": "2016-06-25T10:27:26.043", "LastActivityDate": "2016-06-25T10:27:26.043"}, "38027496": {"ParentId": "38027402", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Essentially you invoke a member function through a null pointer:</p>\n<pre><code>int main()\n{\n    SubFig* testing = nullptr;\n    testing-&gt;three();\n}\n</code></pre>\n<p>... which is undefined behavior.</p>\n<p>From 20.8.1 Class template unique_ptr (N4296)</p>\n<blockquote>\n<p id=\"so_38027402_38027496_0\">4 Additionally, u can, upon request, transfer ownership to another\n  unique pointer u2. Upon completion of such a transfer, the following\n  <strong>postconditions</strong> hold:</p>\n<ul>\n<li>u2.p is equal to the pre-transfer u.p,</li>\n<li><strong>u.p is equal to nullptr</strong>, and</li>\n<li>if the pre-transfer u.d maintained state, such state has been transferred to u2.d.</li>\n</ul>\n</blockquote>\n<p>(emphasis mine)</p>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2016-06-25T10:44:11.713", "Id": "38027496", "Score": "5", "CreationDate": "2016-06-25T10:34:59.280", "LastActivityDate": "2016-06-25T10:44:11.713"}, "bq_ids": {"n4140": {"so_38027402_38027496_0": {"section_id": 4279, "quality": 0.9375, "length": 15}}, "n3337": {"so_38027402_38027496_0": {"section_id": 4120, "quality": 0.9375, "length": 15}}, "n4659": {"so_38027402_38027496_0": {"section_id": 5535, "quality": 0.9375, "length": 15}}}, "38027579": {"ParentId": "38027402", "CommentCount": "0", "Body": "<p>After the <code>std::move()</code> the original pointer <code>testing</code> is set to <code>nullptr</code>. </p>\n<p>The likely reason <code>std::unique_ptr</code> doesn't check for null access to throw a runtime error is that it would slow down every time you used the <code>std::unique_ptr</code>. By not having a runtime check the compiler is able to optimize the <code>std::unique_ptr</code> call away entirely, making it just as efficient as using a <em>raw pointer</em>.</p>\n<p>The reason you didn't get a crash when calling the <code>nullptr</code> is likely because the function you called doesn't access the (non-existent) object's memory. But it is <em>undefined behavior</em> so anything could happen.</p>\n", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "38027579", "Score": "3", "CreationDate": "2016-06-25T10:43:45.063", "LastActivityDate": "2016-06-25T10:43:45.063"}});