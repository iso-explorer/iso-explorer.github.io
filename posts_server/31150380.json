post_cb({"bq_ids": {"n4140": {"so_31150380_31150380_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 5341}, "so_31150380_31150380_0": {"length": 21, "quality": 1.0, "section_id": 5340}}, "n3337": {"so_31150380_31150380_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 5138}, "so_31150380_31150380_0": {"length": 21, "quality": 1.0, "section_id": 5137}}, "n4659": {"so_31150380_31150380_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 6762}, "so_31150380_31150380_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6761}}}, "31150380": {"ViewCount": "75", "Body": "<p>I have some code here:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main ()\n  {\n  char foo = 0xE7;\n  if (foo == 0xE7)\n    printf (\"true\\n\");\n  else\n    printf (\"false\\n\");\n  return 0;\n  }\n</code></pre>\n<p>That prints \"false\". I'm not too concerned about that because I can believe that foo contains 0xE7, which is now considered signed (-25) and compares false to 0xE7 - which is 231 in decimal.</p>\n<hr>\n<p>But what about this?</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main ()\n  {\n  char c = 0xE7;\n  if (c == 0xFFFFFFE7)\n    printf (\"true\\n\");\n  else\n    printf (\"false\\n\");\n  return 0;\n  }\n</code></pre>\n<p>That prints \"true\".</p>\n<p>According to the C++ standard:</p>\n<blockquote>\n<p id=\"so_31150380_31150380_0\">A hexadecimal integer literal (base sixteen) begins with 0x or 0X and consists of a sequence of hexadecimal digits, which include the decimal digits and the letters a through f and A through F with decimal values ten through fifteen.</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_31150380_31150380_1\">The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be represented.</p>\n</blockquote>\n<p>The first item on the list is \"int\". And since the comparison is true it would appear that 0xFFFFFFE7 == -25.</p>\n<hr>\n<p>However, 0xFFFFFFE7 is another way of writing 4294967271. So let's try:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main ()\n  {\n  char c = 0xE7;\n  if (c == 4294967271)\n    printf (\"true\\n\");\n  else\n    printf (\"false\\n\");\n  return 0;\n  }\n</code></pre>\n<p>That prints \"false\". So, 0xFFFFFFE7 is not the same as 4294967271.</p>\n<p>Going back to the Standard, what do the words \"in which its value can be represented\" really mean? Clearly you can stuff 0xFFFFFFE7 into a 4-byte signed int, but that is not really \"representing the value\" 4294967271.</p>\n<p>However:</p>\n<pre><code>  if (0xFFFFFFE7 == 4294967271)  // --&gt; prints \"true\"\n</code></pre>\n<p>Also:</p>\n<pre><code>  if (-25 == 0xFFFFFFE7)  // --&gt; prints \"true\"\n</code></pre>\n<p>So it appears that \"its value can be represented\" means \"at the binary level\", not \"treating the hex constant as its equivalent decimal number\". Does this sound right?</p>\n<p>Tested on gcc 4.8.2, Ubuntu 14.04, 64-bit processor.</p>\n</hr></hr>", "Title": "Integer promotion with hex constants", "CreationDate": "2015-06-30T23:47:48.110", "LastActivityDate": "2015-06-30T23:47:48.110", "CommentCount": "5", "PostTypeId": "1", "Id": "31150380", "Score": "0", "OwnerUserId": "5043289", "Tags": "<c++><hex><standards><integer-promotion>", "AnswerCount": "0"}});