post_cb({"10362992": {"Id": "10362992", "PostTypeId": "2", "Body": "<p>In C++03 there was no requirement that the internal string representation had to be a contiguous buffer. It was also allowed to share the internals with another string (using reference counting, for example).</p>\n<p>Therefore, a call to <code>data()</code> or <code>c_str()</code> might force the string to restructure its internal data, to be able to return a pointer to a char buffer.</p>\n", "LastActivityDate": "2012-04-28T11:17:19.620", "CommentCount": "0", "CreationDate": "2012-04-28T11:17:19.620", "ParentId": "10362672", "Score": "1", "OwnerUserId": "597607"}, "10362672": {"ViewCount": "384", "Body": "<p>I am now reading \u300aThe C++ Standard Library\u300b.When I read the chapter of strings,I get a problem.\nIt tell us that if the contents are exported by data(),references and pointers that refer to the character of a string my be invalidated.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/SYg5u.jpg\"/></p>\n<p>AS we know,data() returns the contents of the string as an array of characters and the return type is not a valid C-string because no '\\0' character gets appended.</p>\n<p>But why data() makes references and pointers invalidated?</p>\n<p>Could someone interpret for me?Thanks a lot!</p>\n", "AcceptedAnswerId": "10362687", "Title": "C++ string data() function make references and pointers invalidated?", "CreationDate": "2012-04-28T10:27:18.587", "Id": "10362672", "CommentCount": "2", "LastEditDate": "2012-04-28T10:44:34.733", "PostTypeId": "1", "LastEditorUserId": "1211152", "LastActivityDate": "2012-04-28T11:17:19.620", "Score": "1", "OwnerUserId": "1211152", "Tags": "<c++><stl>", "AnswerCount": "4"}, "10362839": {"Id": "10362839", "PostTypeId": "2", "Body": "<p>I'm reading a last C++11 draft and can't find anything that would support such claims:</p>\n<blockquote>\n<p id=\"so_10362672_10362839_0\">21.4.1 pt 6: References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:</p>\n<p id=\"so_10362672_10362839_1\">\u2014 as an argument to any standard library function taking a reference to non-const basic_string as an argument. </p>\n<p id=\"so_10362672_10362839_2\">\u2014 Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend.</p>\n</blockquote>\n<p>And a footnote to first point:</p>\n<blockquote>\n<p id=\"so_10362672_10362839_3\">For example, as an argument to non-member functions swap() (21.4.8.8), operator&gt;&gt;() (21.4.8.9), and getline() (21.4.8.9), or as an argument to basic_string::swap()</p>\n</blockquote>\n<p><code>data()</code> member function is declared <code>const</code>, so it should not invalidate anything.</p>\n", "LastActivityDate": "2012-04-28T10:54:07.723", "CommentCount": "1", "CreationDate": "2012-04-28T10:54:07.723", "ParentId": "10362672", "Score": "0", "OwnerUserId": "113662"}, "10362805": {"Id": "10362805", "PostTypeId": "2", "Body": "<p>An example, assuming C++11 (so that <code>data()</code> is guaranteed to be null-terminated):</p>\n<pre><code>string s = \"abc\" ;\nconst char* p = s.data() ;\ncout &lt;&lt; p &lt;&lt; endl ;\ns = \"ABCDE\" ;\ncout &lt;&lt; p &lt;&lt; endl ;\n</code></pre>\n<p>The second assignment to <code>s</code> invalidates <code>p</code>, because <code>s</code> might (here, it probably will) reallocate its internal buffer. So the result of the final <code>cout</code> is undefined. It might print \"abc\" or \"ABCDE\", or it might squirt cider in your ear.</p>\n", "LastEditorUserId": "428857", "LastActivityDate": "2012-04-28T10:52:58.427", "Score": "0", "CreationDate": "2012-04-28T10:47:18.977", "ParentId": "10362672", "CommentCount": "0", "OwnerUserId": "428857", "LastEditDate": "2012-04-28T10:52:58.427"}, "bq_ids": {"n4140": {"so_10362672_10362839_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 1567}, "so_10362672_10362839_2": {"length": 12, "quality": 1.0, "section_id": 1567}, "so_10362672_10362839_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 1567}, "so_10362672_10362839_1": {"length": 8, "quality": 1.0, "section_id": 1567}}, "n3337": {"so_10362672_10362839_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 1562}, "so_10362672_10362839_2": {"length": 12, "quality": 1.0, "section_id": 1562}, "so_10362672_10362839_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 1562}, "so_10362672_10362839_1": {"length": 8, "quality": 1.0, "section_id": 1562}}, "n4659": {"so_10362672_10362839_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 1716}, "so_10362672_10362839_2": {"length": 12, "quality": 1.0, "section_id": 1716}, "so_10362672_10362839_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 1716}, "so_10362672_10362839_1": {"length": 8, "quality": 1.0, "section_id": 1716}}}, "10362687": {"Id": "10362687", "PostTypeId": "2", "Body": "<p>Calling <code>data</code> itself doesn't, calling mutable methods (non-<code>const</code>) afterward might invalidate the previous pointer. That's because when you modify the string, the inner char array might get changed or re-allocated.</p>\n", "LastActivityDate": "2012-04-28T10:28:53.033", "CommentCount": "0", "CreationDate": "2012-04-28T10:28:53.033", "ParentId": "10362672", "Score": "4", "OwnerUserId": "673730"}});