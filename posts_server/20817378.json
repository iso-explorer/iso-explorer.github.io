post_cb({"20817378": {"CommentCount": "3", "AcceptedAnswerId": "20818023", "PostTypeId": "1", "LastEditorUserId": "1371057", "CreationDate": "2013-12-28T17:34:41.083", "LastActivityDate": "2013-12-28T18:47:07.207", "LastEditDate": "2013-12-28T17:55:06.553", "ViewCount": "4843", "FavoriteCount": "2", "Title": "template class - member function specialization", "Id": "20817378", "Score": "4", "Body": "<p>Here is an example code:   </p>\n<pre><code>template&lt;class T&gt;\nclass A\n{\npublic:\n   A(T t): x(t){}\n   T getX();\nprivate:\n   T x;\n};\n\ntemplate&lt;class T&gt;\nT A&lt;T&gt;::getX()\n{\n   return x;\n}\n\n// member function specialization\ntemplate&lt;&gt; // works with and without template&lt;&gt; \nlong A&lt;long&gt;::getX()\n{\n   return 1000L;\n}\n</code></pre>\n<p>The above code works with and without <strong>template&lt;&gt;</strong> before a member function specialization. Why ?\nWhat difference does it make in such case ? </p>\n<p><strong>Edit1:</strong>\nI use that template this way (VS 2012 compiler):</p>\n<pre><code>A&lt;int&gt; a1(1);\ncout&lt;&lt;a1.getX()&lt;&lt;endl;\nA&lt;long&gt; a2(1);\ncout&lt;&lt;a2.getX()&lt;&lt;endl;\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1371057", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20817378_20818023_1": {"section_id": 267, "quality": 0.875, "length": 14}, "so_20817378_20818023_0": {"section_id": 229, "quality": 0.9, "length": 18}}, "n3337": {"so_20817378_20818023_1": {"section_id": 258, "quality": 0.875, "length": 14}, "so_20817378_20818023_0": {"section_id": 222, "quality": 0.9, "length": 18}}, "n4659": {"so_20817378_20818023_1": {"section_id": 274, "quality": 0.875, "length": 14}, "so_20817378_20818023_0": {"section_id": 237, "quality": 0.9, "length": 18}}}, "20818023": {"ParentId": "20817378", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-12-28T18:41:05.163", "Score": "5", "LastEditorUserId": "560648", "LastEditDate": "2013-12-28T18:47:07.207", "Id": "20818023", "OwnerUserId": "560648", "Body": "<p><strong>Not compliantly, it doesn't.</strong></p>\n<p>FWIW, <a href=\"http://coliru.stacked-crooked.com/a/a539f8064c4a18e8\" rel=\"nofollow\">GCC 4.8 rejects your code without the <code>template &lt;&gt;</code>.</a></p>\n<p>Your compiler is either buggy or has an extension to support this; I can confirm that MSVS 2012 accepts the code. I'm told that MSVS 2013 November CTP also eats it up without complaint. To be fair, Visual Studio was always fairly lenient about template specifications.</p>\n<blockquote>\n<p id=\"so_20817378_20818023_0\"><code>[C++11: 14.7/3]:</code> <strong>An explicit specialization may be declared for</strong> a function template, a class template, <strong>a member of a class template</strong> or a member template. <strong>An explicit specialization declaration is introduced by <code>template&lt;&gt;</code>.</strong> <em>[..]</em></p>\n</blockquote>\n<p>The only exception to this rule is:</p>\n<blockquote>\n<p id=\"so_20817378_20818023_1\"><code>[C++11: 14.7.3/5]:</code> <em>[..]</em> Members of an explicitly specialized class template are\n  defined in the same manner as members of normal classes, and not using the <code>template&lt;&gt;</code> syntax. <em>[..]</em></p>\n</blockquote>\n<p>\u2026 but that does not apply here.</p>\n", "LastActivityDate": "2013-12-28T18:47:07.207"}});