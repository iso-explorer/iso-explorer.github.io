post_cb({"19681525": {"ParentId": "19681203", "CommentCount": "5", "Body": "<p>Change this</p>\n<pre><code>int *intAddr(){\nint i = 16;\nreturn &amp;i;}\n</code></pre>\n<p>to</p>\n<pre><code>int *intAddr(){\nint* i = new int(16);\nreturn i;\n</code></pre>\n", "OwnerUserId": "1592350", "PostTypeId": "2", "Id": "19681525", "Score": "0", "CreationDate": "2013-10-30T11:53:38.153", "LastActivityDate": "2013-10-30T11:53:38.153"}, "19681203": {"CommentCount": "2", "ViewCount": "111", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2013-10-30T11:39:51.897", "LastActivityDate": "2015-01-09T16:27:10.197", "Title": "Is the address of local variable freed?", "LastEditDate": "2015-01-09T16:27:10.197", "Id": "19681203", "Score": "1", "Body": "<pre><code>int *intAddr(){\n  int i = 16;\n  return &amp;i;\n}\n\nchar *charAddr(){\n  char A = 'a';\n  return &amp;A;\n}\n</code></pre>\n<p>Then I test these two function by </p>\n<pre><code>int *intaddr = intAddr();printf(\"%d\\n\", *intaddr);\nchar *charaddr = charAddr();printf(charaddr);\n</code></pre>\n<p>But the result is that only 16 not 'a'. When the funcion intAddr() is over, the variable <code>i</code> is destroyed. Why the <code>*intaddr</code> can get 16? </p>\n", "Tags": "<c++>", "OwnerUserId": "2326778", "AnswerCount": "4"}, "19681264": {"ParentId": "19681203", "CommentCount": "0", "Body": "<p>Accessing a memory that is pointing to an element that is already destroyed invokes <strong>undefined behavior</strong>. What will happen is not defined and it is quite possible that different things happen if you run the code several times. What you do above is not much different from accessing just any address by the way.</p>\n", "OwnerUserId": "812912", "PostTypeId": "2", "Id": "19681264", "Score": "1", "CreationDate": "2013-10-30T11:42:00.940", "LastActivityDate": "2013-10-30T11:42:00.940"}, "19681261": {"ParentId": "19681203", "LastEditDate": "2013-10-30T12:06:41.160", "CommentCount": "0", "CreationDate": "2013-10-30T11:41:56.960", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "19681261", "Score": "0", "Body": "<p>This is just simply <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> you are returning the address of an automatic variable, and so it won't exist once the function exits. Anything can happen with <em>undefined behavior</em> but it is not reliable. From the draft C++ standard section <code>6.7</code> <em>Declaration statement</em> paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_19681203_19681261_0\">Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is executed. Variables with automatic storage duration declared in the block are destroyed on exit from the block (6.6).</p>\n</blockquote>\n", "LastActivityDate": "2013-10-30T12:06:41.160"}, "19681246": {"ParentId": "19681203", "LastEditDate": "2013-10-30T11:48:06.457", "CommentCount": "6", "CreationDate": "2013-10-30T11:41:18.540", "OwnerUserId": "174614", "LastEditorUserId": "174614", "PostTypeId": "2", "Id": "19681246", "Score": "4", "Body": "<p>You <strong>SHOULD NOT</strong> return a pointer to a variable that's function local.  That's UNDEFINED BEHAVIOUR. DO NOT DO IT. EVER!!</p>\n<p>The reason is that your local variable, <code>i</code> in this case, is destroyed when your function exits, so you pointer after your function exit will point to memory that contains at most junk.</p>\n", "LastActivityDate": "2013-10-30T11:48:06.457"}, "bq_ids": {"n4140": {"so_19681203_19681261_0": {"section_id": 3917, "quality": 0.95, "length": 19}}, "n3337": {"so_19681203_19681261_0": {"section_id": 3777, "quality": 0.95, "length": 19}}, "n4659": {"so_19681203_19681261_0": {"section_id": 4803, "quality": 0.95, "length": 19}}}});