post_cb({"15102533": {"ParentId": "14777040", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_14777040_15102533_0\">Does anyone have any experience with wrapping these kind of timers a\n  la std:chrono ?</p>\n</blockquote>\n<p>Actually I do.  And on OSX, one of your platforms of interest. :-)</p>\n<p>You mention:</p>\n<blockquote>\n<p id=\"so_14777040_15102533_1\">on OSX, the period of mach_absolute_time() is given at runtime by\n  mach_timebase_info()</p>\n</blockquote>\n<p>Absolutely correct.  Also on OSX, the <a href=\"http://libcxx.llvm.org\" rel=\"nofollow\">libc++</a> implementation of <code>high_resolution_clock</code> and <code>steady_clock</code> is actually based on <code>mach_absolute_time</code>.  I'm the author of this code, which is open source with a generous license (do anything you want with it as long as you retain the copyright).</p>\n<p>Here is the source for <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/src/chrono.cpp\" rel=\"nofollow\">libc++'s <code>steady_clock::now()</code></a>.  It is built pretty much the way you surmised.  The run time period is converted to nanoseconds prior to returning.  On OS X the conversion factor is very often 1, and the code takes advantage of that fact with an optimization.  However the code is general enough to handle non-1 conversion factors.</p>\n<p>On the first call to <code>now()</code> there's a small cost of querying the run time conversion factor to nanoseconds.  In the general case a floating point conversion factor is computed.  In the common case (conversion factor == 1) the subsequent cost is calling through a function pointer.  I've found that the overhead is really quite reasonable.</p>\n<p>On OS X the conversion factor, although not determined until run time, is still a constant (i.e. does not vary as the program executes), so it only needs to be computed once.</p>\n<p>If you're in a situation where your period is actually varying dynamically, you'll need more infrastructure to handle this.  Essentially you would need to integrate (calculus) the period vs time curve and then compute an average period between two points in time.  That would require a constant monitoring of the period as it changes with time, and <code>&lt;chrono&gt;</code> isn't the right tool for that.  Such tools are typically handled at the OS level.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "15102533", "Score": "3", "CreationDate": "2013-02-27T01:18:57.437", "LastActivityDate": "2013-02-27T01:18:57.437"}, "14777040": {"CommentCount": "0", "ViewCount": "903", "PostTypeId": "1", "LastEditorUserId": "880928", "CreationDate": "2013-02-08T16:28:18.930", "LastActivityDate": "2015-09-30T00:18:43.567", "Title": "extending the std::chrono functionality to deal with run-time (non compile-time) constant periods", "FavoriteCount": "1", "LastEditDate": "2015-09-30T00:18:43.567", "Id": "14777040", "Score": "2", "Body": "<p>I have been experimenting with all kind of timers on Linux and OSX, and would like to try and wrap some of them with the same interface used by std::chrono.</p>\n<p>That's easy to do for timers that have a well-defined \"period\" at compile time, e.g. the POSIX clock_gettime() familiy, the clock_get_time() family on OSX, or gettimeofday().</p>\n<p>However, there are some useful timers for which the \"period\" - while constant - is only known at runtime.\nFor example:\n - POSIX states the period of clock(), CLOCKS_PER_SEC, may be a variable on non-XSI systems \n - on Linux, the period of times() is given at runtime by sysconf(_SC_CLK_TCK)\n - on OSX, the period of mach_absolute_time() is given at runtime by mach_timebase_info()\n - on recent Intel processors, the DST register ticks at a constant rate, but of course that can only be determined at runtime</p>\n<p>To wrap these timers in the std::chrono interface, one possibility would be to use a period of std::chrono::nanosecond , and convert the value of each timer to nanoseconds.  An other approach could be to use a floating point representation.  However, both approaches would introduce a (very small) overhead to the now() function, and a (probably small) loss in precision.</p>\n<p>The solution I'm trying to pursue is to define a set of classes to represent such \"run-time constant\" periods, built along the same lines as the std::ratio class.\nHowever I expect that will require rewriting all the related template classes and functions (as they assume constexpr values).</p>\n<p>Does anyone have any experience with wrapping these kind of timers a la std:chrono ?</p>\n<p>Or with using non-constexpr values for the time period of a clock ?</p>\n", "Tags": "<c++><time><ratio><chrono>", "OwnerUserId": "2050986", "AnswerCount": "3"}, "15102970": {"ParentId": "14777040", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I have done a similar thing for my purposes, only for Linux though. You find the code <a href=\"https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp\" rel=\"nofollow\">here</a>; feel free to use the code in whatever way you want.</p>\n<p>The challenges my implementation addresses overlap partially with the ones mentioned in your question. Specifically:</p>\n<ul>\n<li><p>The tick factor (required to convert from clock ticks to a time unit based on seconds) is retrieved at run time, but only the first time <code>now()</code> is used<sup>&amp;ddagger;</sup>. If you are concerned about the small overhead this causes, you may call the <code>now()</code> function once at start-up before you measure any actual intervals. The tick factor is stored in a static variable, which means there is still some overhead as \u2013 on the lowest level \u2013 each call of the <code>now()</code> function implies checking whether the static variable has been initialized. However, this overhead will be the <em>same in each call of <code>now()</code></em>, so it shouldn't impact measuring time intervals.</p></li>\n<li><p>I do not convert to nanoseconds by default, because when measuring relatively long periods of time (e.g. a few seconds) this causes overflows very quickly. This is in fact the main reason why I don't use the boost implementation. Instead of converting to nanoseconds, I implement the base unit as a template parameter (called <code>Precision</code> in the code). I use <code>std::ratio</code> from C++11 as template arguments. So I can choose, for example, a <code>clock&lt;micro&gt;</code>, which implies that calling the <code>now()</code> function will internally convert to microseconds rather than nanoseconds, which means I can measure periods of many seconds or minutes without overflows and still with good precision. (This is independent of the unit used to produce output. You can have a <code>clock&lt;micro&gt;</code> and display the result in seconds, etc.)</p></li>\n<li><p>My clock type, which is called <code>combined_clock</code> combines user time, system time and wall-clock time. There is a boost clock type for this, too, but it's not compatible with the ratio types and units from <code>std</code>, whereas mine is.</p></li>\n</ul>\n<p><sup>&amp;ddagger;</sup>The tick factor is retrieved using the <code>::sysconf()</code> call you suggest, and that is guaranteed to return one and the same value throughout the life time of the process.</p>\n<p>So the way you use it is as follows:</p>\n<pre><code>#include \"util/proctime.hpp\"\n\n#include &lt;ratio&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  using std::chrono::duration_cast;\n  using millisec   = std::chrono::milliseconds;\n  using clock_type = rlxutil::combined_clock&lt;std::micro&gt;;\n\n  auto tp1 = clock_type::now();\n\n  /* Perform some random calculations. */\n  unsigned long step1 = 1;\n  unsigned long step2 = 1;\n  for (int i = 0 ; i &lt; 50000000 ; ++i) {\n    unsigned long step3 = step1 + step2;\n    std::swap(step1,step2);\n    std::swap(step2,step3);\n  }\n\n  /* Sleep for a while (this adds to real time, but not CPU time). */\n  std::this_thread::sleep_for(millisec(1000));\n\n  auto tp2 = clock_type::now();\n\n  std::cout &lt;&lt; \"Elapsed time: \"\n            &lt;&lt; duration_cast&lt;millisec&gt;(tp2 - tp1)\n            &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>The usage above involves a pretty-print function that generates output like this:</p>\n<pre><code>Elapsed time: [user 40, system 0, real 1070 millisec]\n</code></pre>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-02-27T02:23:03.487", "Id": "15102970", "Score": "0", "CreationDate": "2013-02-27T02:10:49.467", "LastActivityDate": "2013-02-27T02:23:03.487"}, "bq_ids": {"n4140": {"so_14777040_14788089_1": {"section_id": 4756, "quality": 0.8, "length": 4}}, "n3337": {"so_14777040_14788089_1": {"section_id": 4563, "quality": 0.8, "length": 4}}, "n4659": {"so_14777040_14788089_1": {"section_id": 6166, "quality": 0.8, "length": 4}}}, "14788089": {"ParentId": "14777040", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_14777040_14788089_0\">[Does anyone have any experience] Or with using non-constexpr values for the time period of a clock ?</p>\n</blockquote>\n<p>After reading through the standard (20.11.5, Class template duration), \"period\" is expected to be \"a specialization of ratio\":</p>\n<blockquote>\n<p id=\"so_14777040_14788089_1\">Remarks: If Period is not a specialization of ratio, the program is ill-formed.</p>\n</blockquote>\n<p>and all chrono templates rely heavily on constexpr functionality.</p>\n<blockquote>\n<p id=\"so_14777040_14788089_2\">Does anyone have any experience with wrapping these kind of timers a la std:chrono ?</p>\n</blockquote>\n<p>I've found <a href=\"https://stackoverflow.com/a/12787703/2050986\">here</a> a suggestion to use a duration with period = 1, boost::rational as rep , though without any concrete examples.</p>\n", "OwnerUserId": "2050986", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:12.027", "Id": "14788089", "Score": "0", "CreationDate": "2013-02-09T12:19:23.170", "LastActivityDate": "2013-02-09T12:19:23.170"}});