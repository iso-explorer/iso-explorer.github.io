post_cb({"8667864": {"Id": "8667864", "PostTypeId": "2", "Body": "<p><strong>When will two pointer compare equal?</strong></p>\n<p>According to 5.10/1:</p>\n<blockquote>\n<p id=\"so_8667515_8667864_0\">The == (equal to) and the != (not equal to) operators have the same\n  semantic restrictions, conversions, and result type as the relational\n  operators except for their lower precedence and truth-value result. [\n  Note: <code>a&lt;b\n  == c&lt;d</code> is true whenever <code>a&lt;b</code> and <code>c&lt;d</code> have the same truth-value. \u2014end note ] Pointers of the same type (after pointer conversions) can be\n  compared for equality. Two pointers of the same type compare equal if\n  and only if they are both null, <strong>both point to the same function,</strong> or\n  both represent the same address (3.9.2).</p>\n</blockquote>\n<p><strong>Are <code>foo&lt;int&gt;()</code> and <code>foo&lt;char&gt;()</code> the same function?</strong></p>\n<p>According to 14.4/1:</p>\n<blockquote>\n<p id=\"so_8667515_8667864_1\">Two template-ids refer to the same class or function if</p>\n<ul>\n<li>their template-names, operator-function-ids, or literal-operator-ids refer to the same template and</li>\n<li><strong>their corresponding type template-arguments are the same type</strong> and</li>\n<li>their corresponding non-type template arguments of integral or enumeration type have identical values\n  and</li>\n<li>their corresponding non-type template-arguments of pointer type refer to the same external object or\n  function or are both the null pointer value and</li>\n<li>their corresponding non-type template-arguments of pointer-to-member type refer to the same class\n  member or are both the null member pointer value and</li>\n<li>their corresponding non-type template-arguments of reference type refer to the same external object\n  or function and</li>\n<li>their corresponding template template-arguments refer to the same template.</li>\n</ul>\n</blockquote>\n<p>So apparently <code>foo&lt;int&gt;()</code> and <code>foo&lt;char&gt;()</code> are not the same function.</p>\n<p>So <code>&amp;foo&lt;int&gt;()</code> and <code>&amp;foo&lt;char&gt;()</code> should not compare equal, whatever optimization is made.</p>\n<hr>\n<p><strong>EDIT:</strong></p>\n<p>As mentioned by @SergeDundich in the comment, 14.4/1 used <code>if</code> instead <code>if and only if</code>, which gives <strong>no</strong> guarantee whether <code>foo&lt;int&gt;()</code> and <code>foo&lt;char&gt;()</code> are the same function or not. In other parts of the specification, <code>if and only if</code> is used a lot.</p>\n<p>I didn't find any clarification to this in the specification. However, in the examples, I can find this:</p>\n<blockquote>\n<pre><code>template&lt;class T, void(*err_fct)()&gt; class list { /* ... */ };\nlist&lt;int,&amp;error_handler1&gt; x1;\nlist&lt;int,&amp;error_handler2&gt; x2;\nlist&lt;int,&amp;error_handler2&gt; x3;\nlist&lt;char,&amp;error_handler2&gt; x4;\n</code></pre>\n<p id=\"so_8667515_8667864_2\">declares x2 and x3 to be of the same type. Their type <strong>differs</strong> from the\n  types of x1 and x4.</p>\n</blockquote>\n<hr>\n<p><strong>EDIT2:</strong></p>\n<p><code>if</code> is used instead of <code>if and only if</code> as this situation exists: (Example from 14.5.7/2)</p>\n<pre><code>template&lt;class T&gt; struct Alloc { /* ... */ };\ntemplate&lt;class T&gt; using Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;\nVec&lt;int&gt; v; // same as vector&lt;int, Alloc&lt;int&gt;&gt; v;\n</code></pre>\n<p><code>Vec&lt;int&gt;</code> and <code>vector&lt;int, Alloc&lt;int&gt;&gt;</code> have a lot of differences, but still the same type.</p>\n<p>However, as to the case of <code>foo&lt;int&gt;()</code> and <code>foo&lt;char&gt;()</code>, their signatures are different. The different signatures should render them different functions.</p>\n<p>Thanks to @JohannesSchaub-litb .</p>\n</hr></hr>", "LastEditorUserId": "1058916", "LastActivityDate": "2011-12-29T15:19:22.150", "Score": "10", "CreationDate": "2011-12-29T12:26:55.680", "ParentId": "8667515", "CommentCount": "14", "OwnerUserId": "1058916", "LastEditDate": "2011-12-29T15:19:22.150"}, "bq_ids": {"n4140": {"so_8667515_8667864_2": {"length": 7, "quality": 1.0, "section_id": 95}, "so_8667515_8667864_1": {"length": 6, "quality": 1.0, "section_id": 95}}, "n3337": {"so_8667515_8667864_2": {"length": 7, "quality": 1.0, "section_id": 90}, "so_8667515_8667864_0": {"length": 49, "quality": 0.9074074074074074, "section_id": 5917}, "so_8667515_8667864_1": {"length": 6, "quality": 1.0, "section_id": 90}}, "n4659": {"so_8667515_8667864_2": {"length": 7, "quality": 1.0, "section_id": 99}, "so_8667515_8667864_1": {"length": 6, "quality": 1.0, "section_id": 99}}}, "8667515": {"ViewCount": "228", "Body": "<p>Is it safe to assume that two function pointers, that point to different instances of one templated function, will compare unequal?\nEven if the templated function does not use the template parameter(s) at all and thus does the exact same thing in every case?</p>\n<p>For example the following works fine on my compiler but I'm not sure if it does on any other:</p>\n<pre><code>class TypeChecker\n{\npublic:\n    template&lt; typename T &gt; static void foo( void )\n    {}\n    template&lt; typename T &gt; static void setType( void )\n    { s_fooPtr = &amp;foo&lt; T &gt;; }\n    template&lt; typename T &gt; static bool checkType( void )\n    { return ( s_fooPtr == &amp;foo&lt; T &gt; ); }\nprivate:\n    static void ( * s_fooPtr )( void );\n};\n\nvoid ( * TypeChecker::s_fooPtr )( void ) = 0;\n\nint main( void )\n{\n    TypeChecker::setType&lt; char &gt;();\n    TypeChecker::checkType&lt; char &gt;();           // true\n    TypeChecker::checkType&lt; unsigned char &gt;();  // false\n    TypeChecker::checkType&lt; signed char &gt;();    // false\n}\n</code></pre>\n", "AcceptedAnswerId": "8667864", "Title": "Pointers to different instances of one templated function guaranteed to compare unequal?", "CreationDate": "2011-12-29T11:52:12.730", "Id": "8667515", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-29T11:56:57.960", "LastEditorUserId": "847601", "LastActivityDate": "2011-12-29T15:19:22.150", "Score": "12", "OwnerUserId": "1094336", "Tags": "<c++><templates><function-pointers>", "AnswerCount": "1"}});