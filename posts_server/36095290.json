post_cb({"36095358": {"ParentId": "36095290", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_36095290_36095358_0\">After the move <code>f1.t</code> is always <code>true</code> and <code>f1.f</code> is always <code>false</code>.</p>\n</blockquote>\n<p>For the fundamental types, moving <em>is</em> copying. You wouldn't want your implementation to copy the bool <strong>AND</strong> zero out the old one - that's unnecessary extra work. In a simple POD, moving would just be a <code>memcpy</code> - but if what you're suggesting would happen, you'd also have to then do a <code>memset</code>. Much faster to just do nothing. </p>\n<blockquote>\n<p id=\"so_36095290_36095358_1\">Is this just a implementation details of my compilers (by coincidence the same) or is this in the standard?</p>\n</blockquote>\n<p>This is in the standard in <a href=\"http://eel.is/c++draft/class.copy#28\" rel=\"noreferrer\">[class.copy]</a>:</p>\n<blockquote>\n<p id=\"so_36095290_36095358_2\">The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-\n  /move assignment of its subobjects. [...] Each subobject is assigned in the manner\n  appropriate to its type:<br>\n  \u2014 [...]<br>\n  \u2014 if the subobject is of scalar type, the built-in assignment operator is used.</br></br></p>\n</blockquote>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-03-18T22:39:13.953", "Id": "36095358", "Score": "11", "CreationDate": "2016-03-18T22:33:58.580", "LastActivityDate": "2016-03-18T22:39:13.953"}, "36095290": {"CommentCount": "7", "AcceptedAnswerId": "36095358", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-18T22:28:08.927", "LastActivityDate": "2016-03-20T11:22:48.940", "LastEditDate": "2017-05-23T12:31:26.773", "ViewCount": "137", "FavoriteCount": "1", "Title": "What can be said about the value of fundamental type members of moved from object during move construction?", "Id": "36095290", "Score": "8", "Body": "<p>Consider this code</p>\n<pre><code>Foo f1;\nFoo f2{ std::move(f1) };\n</code></pre>\n<p>I would expect the member values of <code>f1</code> to no longer necessarily hold the values given by the default constructor. However, testing with multiple compilers using this implementation of <code>Foo</code> suggests otherwise.</p>\n<pre><code>class Foo\n{\npublic:\n    Foo() = default;\n    Foo(Foo &amp;&amp;) = default;\n\n    std::string s{ \"foo\" };\n    bool t{ true };\n    bool f{ false };\n};\n</code></pre>\n<p>After the move <code>f1.t</code> is always <code>true</code> and <code>f1.f</code> is always <code>false</code>. As described in <strong><a href=\"https://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object\">this question</a></strong> I would expect the values to either be nondeterministic or that both boolean values would have the same value. However, they seem to get the same value they would get from the default constructor.</p>\n<p><strong><a href=\"http://cpp.sh/8nqj\" rel=\"nofollow noreferrer\">Live example with GCC</a></strong></p>\n<p>Is this just a implementation details of my compilers (by coincidence the same) or <strong>is this in the standard?</strong></p>\n", "Tags": "<c++><c++11><language-lawyer><move-semantics>", "OwnerUserId": "212010", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36095290_36095358_2": {"section_id": 477, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_36095290_36095358_2": {"section_id": 468, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_36095290_36095358_2": {"section_id": 500, "quality": 0.8888888888888888, "length": 24}}}});