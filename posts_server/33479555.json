post_cb({"33479868": {"ParentId": "33479555", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is covered in the draft C++11 standard section <code>13.3.3.1.5</code> <em>[over.ics.list]</em> which says:</p>\n<blockquote>\n<p id=\"so_33479555_33479868_0\">Otherwise, if the parameter type is not a class:</p>\n<p id=\"so_33479555_33479868_1\">[...]</p>\n<ul>\n<li><p id=\"so_33479555_33479868_2\">if the initializer list has no elements, the implicit conversion sequence is the identity conversion.\n  [ Example:</p>\n<pre><code>void f(int);\nf( { } ); // OK: identity conversion\n</code></pre></li>\n</ul>\n<p id=\"so_33479555_33479868_3\">\u2014end example ]</p>\n</blockquote>\n<p>and so an identity conversion would be better than a constructor call.</p>\n<p>The reason why we get a nullptr is because it is value initializing the pointer. From section <code>8.5.4</code> <em>[dcl.init.list]</em>:</p>\n<blockquote>\n<p id=\"so_33479555_33479868_4\">List-initialization of an object or reference of type T is defined as follows:</p>\n<p id=\"so_33479555_33479868_5\">[...]</p>\n<ul>\n<li><p id=\"so_33479555_33479868_6\">Otherwise, if the initializer list has no elements, the object is value-initialized.\n  [ Example:</p>\n<pre><code>int** pp {}; // initialized to null pointer\n</code></pre></li>\n</ul>\n<p id=\"so_33479555_33479868_7\">\u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-03T02:25:47.937", "Id": "33479868", "Score": "3", "CreationDate": "2015-11-02T14:25:48.687", "LastActivityDate": "2015-11-03T02:25:47.937"}, "33479555": {"CommentCount": "0", "ViewCount": "126", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-02T14:09:20.027", "LastActivityDate": "2015-11-03T02:25:47.937", "Title": "C++11 Uniform Initialization and function overloading", "AcceptedAnswerId": "33479868", "LastEditDate": "2015-11-02T14:26:12.367", "Id": "33479555", "Score": "4", "Body": "<p>Simple program:</p>\n<pre><code>void f(const std::string&amp; s);\nvoid f(const char* p);\nf({});\n</code></pre>\n<p>Why clang calls <code>f((const char*)nullptr)</code>? I've expected compiler warning about ambiguous call.</p>\n", "Tags": "<c++><c++11><function-overloading><uniform-initialization>", "OwnerUserId": "475821", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33479555_33479868_4": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_33479555_33479868_0": {"section_id": 635, "quality": 1.0, "length": 4}, "so_33479555_33479868_2": {"section_id": 635, "quality": 0.8888888888888888, "length": 8}, "so_33479555_33479868_6": {"section_id": 3325, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_33479555_33479868_4": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_33479555_33479868_0": {"section_id": 625, "quality": 1.0, "length": 4}, "so_33479555_33479868_2": {"section_id": 625, "quality": 0.8888888888888888, "length": 8}, "so_33479555_33479868_6": {"section_id": 3195, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_33479555_33479868_4": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_33479555_33479868_0": {"section_id": 660, "quality": 1.0, "length": 4}, "so_33479555_33479868_2": {"section_id": 663, "quality": 0.8888888888888888, "length": 8}, "so_33479555_33479868_6": {"section_id": 4091, "quality": 0.8571428571428571, "length": 6}}}});