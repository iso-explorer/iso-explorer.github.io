post_cb({"bq_ids": {"n4140": {"so_33479555_33479868_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 635}, "so_33479555_33479868_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 3325}, "so_33479555_33479868_0": {"length": 4, "quality": 1.0, "section_id": 635}, "so_33479555_33479868_4": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_33479555_33479868_4": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_33479555_33479868_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 3195}, "so_33479555_33479868_0": {"length": 4, "quality": 1.0, "section_id": 625}, "so_33479555_33479868_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 625}}, "n4659": {"so_33479555_33479868_4": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_33479555_33479868_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 4091}, "so_33479555_33479868_0": {"length": 4, "quality": 1.0, "section_id": 660}, "so_33479555_33479868_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 663}}}, "33479555": {"ViewCount": "126", "Body": "<p>Simple program:</p>\n<pre><code>void f(const std::string&amp; s);\nvoid f(const char* p);\nf({});\n</code></pre>\n<p>Why clang calls <code>f((const char*)nullptr)</code>? I've expected compiler warning about ambiguous call.</p>\n", "AcceptedAnswerId": "33479868", "Title": "C++11 Uniform Initialization and function overloading", "CreationDate": "2015-11-02T14:09:20.027", "Id": "33479555", "CommentCount": "0", "LastEditDate": "2015-11-02T14:26:12.367", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-03T02:25:47.937", "Score": "4", "OwnerUserId": "475821", "Tags": "<c++><c++11><function-overloading><uniform-initialization>", "AnswerCount": "1"}, "33479868": {"Id": "33479868", "PostTypeId": "2", "Body": "<p>This is covered in the draft C++11 standard section <code>13.3.3.1.5</code> <em>[over.ics.list]</em> which says:</p>\n<blockquote>\n<p id=\"so_33479555_33479868_0\">Otherwise, if the parameter type is not a class:</p>\n<p id=\"so_33479555_33479868_1\">[...]</p>\n<ul>\n<li><p id=\"so_33479555_33479868_2\">if the initializer list has no elements, the implicit conversion sequence is the identity conversion.\n  [ Example:</p>\n<pre><code>void f(int);\nf( { } ); // OK: identity conversion\n</code></pre></li>\n</ul>\n<p id=\"so_33479555_33479868_3\">\u2014end example ]</p>\n</blockquote>\n<p>and so an identity conversion would be better than a constructor call.</p>\n<p>The reason why we get a nullptr is because it is value initializing the pointer. From section <code>8.5.4</code> <em>[dcl.init.list]</em>:</p>\n<blockquote>\n<p id=\"so_33479555_33479868_4\">List-initialization of an object or reference of type T is defined as follows:</p>\n<p id=\"so_33479555_33479868_5\">[...]</p>\n<ul>\n<li><p id=\"so_33479555_33479868_6\">Otherwise, if the initializer list has no elements, the object is value-initialized.\n  [ Example:</p>\n<pre><code>int** pp {}; // initialized to null pointer\n</code></pre></li>\n</ul>\n<p id=\"so_33479555_33479868_7\">\u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-03T02:25:47.937", "Score": "3", "CreationDate": "2015-11-02T14:25:48.687", "ParentId": "33479555", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-03T02:25:47.937"}});