post_cb({"bq_ids": {"n4140": {"so_32748870_32789107_0": {"length": 78, "quality": 0.9176470588235294, "section_id": 5559}}, "n3337": {"so_32748870_32789107_0": {"length": 78, "quality": 0.9176470588235294, "section_id": 5341}}, "n4659": {"so_32748870_32789107_0": {"length": 76, "quality": 0.8941176470588236, "section_id": 7006}}}, "32789107": {"Id": "32789107", "PostTypeId": "2", "Body": "<p>This code has undefined behavior. [iterator.requirements.general]/p6:</p>\n<blockquote>\n<p id=\"so_32748870_32789107_0\">Iterators can also have singular values that are not associated with\n  any sequence. [ <em>Example</em>: After the declaration of an uninitialized\n  pointer <code>x</code> (as with <code>int* x;</code>), <code>x</code> must always be assumed to have a\n  singular value of a pointer. \u2014<em>end example</em> ] Results of most\n  expressions are undefined for singular values; the only exceptions are\n  destroying an iterator that holds a singular value, the assignment of\n  a non-singular value to an iterator that holds a singular value, and,\n  for iterators that satisfy the <code>DefaultConstructible</code> requirements,\n  using a value-initialized iterator as the source of a copy or move\n  operation. [ <em>Note</em>: This guarantee is not offered for default\n  initialization, although the distinction only matters for types with\n  trivial default constructors such as pointers or aggregates holding\n  pointers. \u2014<em>end note</em> ] In these cases the singular value is\n  overwritten the same way as any other value. Dereferenceable values\n  are always non-singular.</p>\n</blockquote>\n<p><code>uninitialized</code> is singular, and its use doesn't fall within any of the exceptions listed in the paragraph.</p>\n<p>However, given the snippets you post, I suspect that your code wouldn't work either even if you value-initialize <code>uninitialized</code>, which is a bug in Microsoft's implementation, and which they fixed in a <a href=\"https://support.microsoft.com/en-us/kb/2545588\" rel=\"nofollow\">later hotfix</a>.</p>\n", "LastActivityDate": "2015-09-25T19:11:59.093", "CommentCount": "1", "CreationDate": "2015-09-25T19:11:59.093", "ParentId": "32748870", "Score": "1", "OwnerUserId": "2756719"}, "32748870": {"ViewCount": "182", "Body": "<p>The assignment of a default constructed <code>vector&lt;int*&gt;::const_iterator</code> errors on Visual Studio 2010. I've tried this on 5 Visual Studio 2010 systems that all have Service Pack 1. It fails on 3/5 machines, I've been able to identify what is causing the failure on the 3 systems but I cannot seem to find a bug report.</p>\n<p>Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;int*&gt; vec;\n    int arr[3] = {};\n\n    for(int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); ++i) vec.push_back(arr + i);\n\n    vector&lt;int*&gt;::const_iterator initialized = vec.cbegin();\n    vector&lt;int*&gt;::const_iterator uninitialized;\n\n    initialized = uninitialized;\n\n    cout &lt;&lt; \"Hello World\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Clearly everything but the <code>cout &lt;&lt; \"Hello World\" &lt;&lt; endl;</code> is optimized out in Release so this minimal example will only fail in Debug. But in Debug the error it gives is:</p>\n<blockquote>\n<p id=\"so_32748870_32748870_0\">Unhandled exception at 0x01071e14 in test.exe: 0xC0000005: Access violation reading location 0x00000000.</p>\n</blockquote>\n<p>Comparing the working and non-working MSVCP100D.dlls that were linked shows that there is a slight discrepancy, the working .dll is Product Version: 10.0.40219.325 and the non-working .dll is Product Version: 10.0.40219.1.</p>\n<p>The actual error occurs in</p>\n<blockquote>\n<p id=\"so_32748870_32748870_1\">C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility</p>\n</blockquote>\n<p>And again diffing the working and non-working version shows that a change has been made to the working version. The non-working code simply says:</p>\n<pre><code>if (_Myproxu != _Right._Myproxy)\n    _Adopt(_Right._Myproxy-&gt;_Mycont);\n</code></pre>\n<p>The working code says:</p>\n<pre><code>if (_Myproxy == _Right._Myproxy)\n    ;\nelse if (_Right._Myproxy != 0)\n    _Adopt(_Right._Myproxy-&gt;_Mycont);\nelse\n    {   // becoming invalid, disown current parent\n    _Lockit _Lock(_LOCK_DEBUG);\n    _Orphan_me();\n    }\n</code></pre>\n<p>All that to say, here's my actual question. How do I get this update? I've updated to the latest using Windows Update, but the problem has not been resolved. Is there some hidden patch that I need to go somewhere to get? I can't find this issue written up anywhere, so I also can't find information about the patch.</p>\n", "AcceptedAnswerId": "32789107", "Title": "Visual Studio const_iterator Assignment Error", "CreationDate": "2015-09-23T20:28:18.370", "Id": "32748870", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2015-09-25T19:11:59.093", "Score": "2", "OwnerUserId": "2642059", "Tags": "<c++><visual-studio><visual-studio-2010><iterator><initialization>", "AnswerCount": "1"}});