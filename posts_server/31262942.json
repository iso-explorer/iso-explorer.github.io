post_cb({"31283235": {"ParentId": "31262942", "CommentCount": "1", "CreationDate": "2015-07-08T03:53:19.607", "OwnerUserId": "977038", "PostTypeId": "2", "Id": "31283235", "Score": "1", "Body": "<p><strong>8.3.2 References [dcl.ref]</strong></p>\n<blockquote>\n<p id=\"so_31262942_31283235_0\">A reference can be thought of as a name of an object</p>\n</blockquote>\n<p>which is different from <strong>pointers</strong> which is a variable (unlike reference) that holds the address of a memory location of an Object<sup>**</sup>. The type of this variable is pointer to Object.</p>\n<p>Internally Reference may be implemented as pointer, but standard never guaranteed so.</p>\n<p>So to answer your question: C++Reference are not syntactic sugar to pointers. And whether it provides any speedup has already been answered in depth.</p>\n<p><sup>****** Object here it means any instance that has a memory address. Even pointers are Objects and so are functions (and thus we have nested pointers and function pointers). In similar sense, we do not have pointers to reference as they are not instantiated. </sup> </p>\n", "LastActivityDate": "2015-07-08T03:53:19.607"}, "31264684": {"ParentId": "31262942", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-07-07T09:25:14.503", "Score": "54", "LastEditorUserId": "147192", "LastEditDate": "2015-07-08T07:52:53.413", "Id": "31264684", "OwnerUserId": "1864364", "Body": "<p>Assume reference as a pointer that:</p>\n<ol>\n<li>Can't be NULL </li>\n<li>Once initialized, can't be re-pointed to other object</li>\n<li><p>Any attempt to use it will implicitly dereference it:</p>\n<pre><code>int a = 5;\nint &amp;ra = a;\nint *pa = &amp;a;\n\nra = 6;\n\n(*pa) = 6;\n</code></pre></li>\n</ol>\n<p>here as it looks in disassembly:</p>\n<pre><code>    int a = 5;\n00ED534E  mov         dword ptr [a],5  \n    int &amp;ra = a;\n00ED5355  lea         eax,[a]  \n00ED5358  mov         dword ptr [ra],eax  \n    int *pa = &amp;a;\n00ED535B  lea         eax,[a]  \n00ED535E  mov         dword ptr [pa],eax  \n\n    ra = 6;\n00ED5361  mov         eax,dword ptr [ra]  \n00ED5364  mov         dword ptr [eax],6  \n\n    (*pa) = 6;\n00ED536A  mov         eax,dword ptr [pa]  \n00ED536D  mov         dword ptr [eax],6  \n</code></pre>\n<p>the assigning to the reference is the same thing from the compiler perspective as the assigning to a dereferenced pointer. There are no difference between them as you can see (we are not talking about compiler optimization right now)\nHowever as mentioned above, references can't be null and have stronger guarantees of what they contains. </p>\n<p>As for me, I prefer using references as long as I don't need <code>nullptr</code> as a valid value, values that should be repointed or values of different types to be passed into (e.g. pointer to interface type).</p>\n", "LastActivityDate": "2015-07-08T07:52:53.413"}, "31286807": {"ParentId": "31262942", "CommentCount": "2", "CreationDate": "2015-07-08T08:02:16.010", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "31286807", "Score": "8", "Body": "<p><strong>No</strong></p>\n<hr>\n<p>References are not just a <em>syntactic</em> difference; they also have different <em>semantics</em>:</p>\n<ul>\n<li>A reference always aliases an existing object, unlike a pointer which may be <code>nullptr</code> (a sentinel value).</li>\n<li>A reference cannot be re-seated, it always points to the same object throughout its lifetime.</li>\n<li>A reference can extend the lifetime of an object, see binding to <code>auto const&amp;</code> or <code>auto&amp;&amp;</code>.</li>\n</ul>\n<p>Thus, at the language level, a reference is an entity of its own. The rest are implementation details.</p>\n</hr>", "LastActivityDate": "2015-07-08T08:02:16.010"}, "31262942": {"CommentCount": "12", "ViewCount": "5433", "PostTypeId": "1", "LastEditorUserId": "3837653", "CreationDate": "2015-07-07T08:00:59.703", "LastActivityDate": "2015-07-24T02:58:38.620", "Title": "C++ references - are they just syntactic sugar?", "FavoriteCount": "9", "LastEditDate": "2015-07-08T03:33:03.313", "Id": "31262942", "Score": "63", "Body": "<p>Is a C++ reference just syntactic sugar, or does it offer any speed ups in certain cases?</p>\n<p>For example, a call-by-pointer involves a copy anyway, and that seems to be true about a call-by-reference as well. The underlying mechanism appears to be the same.</p>\n<p>Edit: After about six answers and many comments. I am still of the opinion references are just syntatic sugar. If people could answer in a straight yes or no, and if someone could do an accepted answer?</p>\n", "Tags": "<c++>", "OwnerUserId": "3837653", "AnswerCount": "7"}, "31279475": {"ParentId": "31262942", "CommentCount": "0", "CreationDate": "2015-07-07T21:19:57.067", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "31279475", "Score": "10", "Body": "<p>References differ from pointers in that there are things you cannot do to a reference and have it be defined behavior.</p>\n<p>You cannot take the address of a reference, but only what is referred to.  You cannot modify a reference once it is created.</p>\n<p>A <code>T&amp;</code> and a <code>T*const</code> (note that <code>const</code> applies to the pointer, not the pointed-to, there) are relatively similar.  Taking the address of an actual <code>const</code> value and modifying it is undefined behavior, as is modifying (any storage that it uses directly) a reference.</p>\n<p>Now, in practice, you can get a the storage of a reference:</p>\n<pre><code>struct foo {\n  int&amp; x;\n};\n</code></pre>\n<p><code>sizeof(foo)</code> will almost certainly equal <code>sizeof(int*)</code>.  But the compiler is free to neglect the possibility that someone directly accessing the bytes of <code>foo</code> could actually change the value referred to.  This permits the compiler to read the reference \"pointer\" implementation once, and then never read it again.  If we had <code>struct foo{ int* x; }</code> the compiler would have to prove each time it did a <code>*f.x</code> that the pointer value had not changed.</p>\n<p>If you had <code>struct foo{ int*const x; }</code> is again starts behaving reference-like in its immutability (modifying something that was declared <code>const</code> is UB).</p>\n<hr>\n<p>A trick that I'm not aware of any compiler writers using is to compress reference-capture in a lambda.</p>\n<p>If you have a lambda that captures data by reference, instead of capturing each value via a pointer, it could capture only the stack frame pointer.  The offsets to each local variable are compile-time constants off the stack frame pointer.</p>\n<p>The exception is references captured by reference, which under a defect report to C++ must remain valid even if the reference variable goes out of scope.  So those have to be captured by pseudo-pointer.</p>\n<p>For a concrete example (if a toy one):</p>\n<pre><code>void part( std::vector&lt;int&gt;&amp; v, int left, int right ) {\n  std::function&lt;bool(int)&gt; op = [&amp;](int y){return y&lt;left &amp;&amp; y&gt;right;};\n  std::partition( begin(v), end(v), op );\n}\n</code></pre>\n<p>the lambda above could capture only the stack frame pointer, and know where <code>left</code> and <code>right</code> are relative to it, reducing it size, instead of capturing two <code>int</code>s by (basically pointer) reference.</p>\n<p>Here we have references implied by <code>[&amp;]</code> whose existence is eliminated easier than if they where pointers captured by value:</p>\n<pre><code>void part( std::vector&lt;int&gt;&amp; v, int left, int right ) {\n  int* pleft=&amp;left;\n  int* pright=&amp;right;\n  std::function&lt;bool(int)&gt; op = [=](int y){return y&lt;*pleft &amp;&amp; y&gt;*pright;};\n  std::partition( begin(v), end(v), op );\n}\n</code></pre>\n<hr>\n<p>There are a few other differences between references and pointers.</p>\n<p>A reference can extend the lifetime of a temporary.</p>\n<p>This is used heavily in <code>for(:)</code> loops.  Both the definition of the <code>for(:)</code> loop relies on reference lifetime extension to avoid needless copies, and users of <code>for(:)</code> loops can use <code>auto&amp;&amp;</code> to automatically deduce the lightest weight way to wrap the iterated objects.</p>\n<pre><code>struct big { int data[1&lt;&lt;10]; };\n\nstd::array&lt;big, 100&gt; arr;\n\narr get_arr();\n\nfor (auto&amp;&amp; b : get_arr()) {\n}\n</code></pre>\n<p>here reference lifetime extension carefully prevents needless copies from ever occuring.  If we change <code>make_arr</code> to return a <code>arr const&amp;</code> it continues to work without any copies.  If we change <code>get_arr</code> to return a container that returns <code>big</code> elements by-value (say, an input iterator range), again no needless copies are done.</p>\n<p>This is in a sense syntactic sugar, but it allows the same construct to be optimal in many cases without having to micro-optimize based on how things are returned or iterated over.</p>\n<hr>\n<p>Similarly, forwarding references allow data to be treated as a const, non-const, lvalue or rvalue intelligently.  Temporaries are marked as temporaries, data that users have no further need for is marked as temporary, data that will persist is marked as being an lvalue reference.</p>\n<p>The advantage references have over non-references here is that you can form a rvalue reference to a temporary, and you cannot form a pointer to that temporary without passing it through an rvalue reference-to-lvalue reference conversion.</p>\n</hr></hr></hr>", "LastActivityDate": "2015-07-07T21:19:57.067"}, "31263134": {"ParentId": "31262942", "CommentCount": "11", "CreationDate": "2015-07-07T08:10:38.313", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "31263134", "Score": "58", "Body": "<p>References have stronger guarantees than pointers, so the compiler can optimize more aggressively. I've recently seen GCC inline multiple nested calls through function references perfectly, but not a single one through function pointers (because it couldn't prove that the pointer was always pointing at the same function).</p>\n<p>If the reference ends up stored somewhere, it typically takes the same space as a pointer. That is not to say, again, that it will be used like a pointer : the compiler may well cut through it if it knows which object the reference was bound to.</p>\n", "LastActivityDate": "2015-07-07T08:10:38.313"}, "31263091": {"ParentId": "31262942", "CommentCount": "11", "CreationDate": "2015-07-07T08:08:11.187", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "31263091", "Score": "19", "Body": "<p>The compiler cannot assume a pointer is non-null; when optimizing code, it has to either prove the pointer is non-null, or emit a program that accounts for the possibility that it is null (in a context where that would be well-defined).</p>\n<p>Similarly, the compiler cannot assume the pointer never changes value. (nor can it assume the pointer points to a valid object, although I'm having trouble imagining a case where that would matter in a well-defined context)</p>\n<p>On the other hand, assuming that references are implemented as pointers, the compiler <em>is</em> still allowed to assume it is non-null, never changes where it points, and points to a valid object.</p>\n", "LastActivityDate": "2015-07-07T08:08:11.187"}, "31275223": {"ParentId": "31262942", "CommentCount": "0", "CreationDate": "2015-07-07T17:15:13.403", "OwnerUserId": "2728148", "PostTypeId": "2", "Id": "31275223", "Score": "7", "Body": "<p>There used to be efficiency advantages because references are easier for the compiler to optimize.  However, modern compilers have gotten so good at it that there is no longer any advantage.</p>\n<p>One <strong>huge</strong> advantage references have over pointers is that a reference can refer to a value in a register, while pointers can only point at blocks of memory.  Take the address of something which would have been in a register, and you would force the compiler to put that value into a normal memory location instead.  This can create tremendous benefits in tight loops.</p>\n<p>However, modern compilers are so good that they now recognize a pointer that <em>could have been</em> a reference for all intents and purposes, and treat it exactly the same as if it were a reference.  This can cause rather intriguing results in a debugger, where you can have a statement such as <code>int* p = &amp;x</code>, ask the debugger to print the value of <code>p</code>, only to have it say something along the lines of \"p cannot be printed\" because <code>x</code> was actually in a register, and the compiler was treating <code>*p</code> as a reference to <code>x</code>!  In this case, there literally is no value for <code>p</code></p>\n<p>(However, if you tried to do pointer arithmetic on <code>p</code>, you would then force the compiler to no longer optimize the pointer to act like a reference does, and everything would slow down)</p>\n", "LastActivityDate": "2015-07-07T17:15:13.403"}, "bq_ids": {"n4140": {"so_31262942_31283235_0": {"section_id": 3218, "quality": 1.0, "length": 5}}, "n3337": {"so_31262942_31283235_0": {"section_id": 3092, "quality": 1.0, "length": 5}}, "n4659": {"so_31262942_31283235_0": {"section_id": 3975, "quality": 1.0, "length": 5}}}});