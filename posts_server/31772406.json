post_cb({"31773038": {"ParentId": "31772406", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it is not possible. Your example is invalid, as standard requires you to return the same hash value for equivalent keys:</p>\n<blockquote id=\"so_31772406_31773038_0\">\n<h2>23.2.5 Unordered associative containers</h2>\n<ol start=\"5\">\n<li>Two values k1 and k2 of type Key are considered equivalent if the\n  container\u2019s key_equal function object returns true when passed those\n  values. <strong>If k1 and k2 are equivalent, the hash function shall return\n  the same value for both.</strong> [ Note: Thus, when an unordered associative\n  container is instantiated with a non-default Pred parameter it usually\n  needs a non-default Hash parameter as well. \u2014 end note ]</li>\n</ol>\n</blockquote>\n<p>Library user could not ensure values fall into different buckets anyway, since it is not defined how whole all possible hash values are mapped onto bucket indexes or how operations on the map change number of buckets.</p>\n", "OwnerUserId": "1126943", "LastEditorUserId": "1126943", "LastEditDate": "2015-08-02T15:00:40.723", "Id": "31773038", "Score": "1", "CreationDate": "2015-08-02T14:46:50.240", "LastActivityDate": "2015-08-02T15:00:40.723"}, "bq_ids": {"n4140": {"so_31772406_31773038_0": {"section_id": 757, "quality": 0.7954545454545454, "length": 35}, "so_31772406_31772406_1": {"section_id": 1078, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_31772406_31773038_0": {"section_id": 745, "quality": 0.8636363636363636, "length": 38}, "so_31772406_31772406_1": {"section_id": 1075, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_31772406_31772406_1": {"section_id": 1165, "quality": 0.9583333333333334, "length": 23}, "so_31772406_31773038_0": {"section_id": 817, "quality": 0.7954545454545454, "length": 35}}}, "31772406": {"CommentCount": "1", "ViewCount": "406", "PostTypeId": "1", "LastEditorUserId": "4338785", "CreationDate": "2015-08-02T13:32:55.050", "LastActivityDate": "2015-08-02T15:00:40.723", "Title": "Possible to have two keys in an unordered_set, that are considered equal?", "AcceptedAnswerId": "31773038", "LastEditDate": "2015-08-02T13:42:19.363", "Id": "31772406", "Score": "3", "Body": "<p><a href=\"http://www.cplusplus.com/reference/unordered_set/unordered_set/\" rel=\"nofollow\">From here</a>:</p>\n<blockquote>\n<p id=\"so_31772406_31772406_0\">Pred: The unordered_set object uses this expression to determine whether two element keys are equivalent. No two elements in an unordered_set container can have keys that yield true using this predicate.</p>\n</blockquote>\n<p>And also from 23.5.6.1/1:</p>\n<blockquote>\n<p id=\"so_31772406_31772406_1\">An unordered_set is an unordered associative container that supports unique keys (<strong>an unordered_set contains at most one of each key value</strong>) and in which the elements\u2019 keys are the elements themselves. The unordered_set class supports forward iterators.</p>\n</blockquote>\n<p>But I can bypass this if I define my own hasher and equivalent operation that use different features of a class type. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_set&gt; //for unordered_set and unordered_multiset\n\nusing namespace std;\n\nstruct A{\n    A() = default;\n    A(int a, int b): x(a), y(b) {}\n    int x = 0, y = 0;\n\n};\n\nsize_t hasher(const A &amp;sd){\n    return hash&lt;int&gt;()(sd.x);\n}\n\nbool eqOp(const A &amp;lhs, const A &amp;rhs){\n    return lhs.y == rhs.y;\n}\n\n\nint main(){\n\n    unordered_set&lt;A, decltype(hasher)*, decltype(eqOp)*&gt; unorderedA(10, hasher, eqOp);\n\n    unorderedA.emplace(2,3);\n    unorderedA.emplace(3,3);\n\n    for(const auto&amp; c : unorderedA)\n        cout &lt;&lt; c.x &lt;&lt; \" \" &lt;&lt; c.y &lt;&lt; endl;\n}\n</code></pre>\n<p>Outputs;</p>\n<pre><code>3 3\n2 3\n</code></pre>\n<p>I understand what's happening: the hasher places each key in different buckets because of their x value. However those two keys should've been considered equal by my eqOp function due to their y value, but they never get checked for equivalence since they get placed in different buckets. So is it normal functionality that an unordered container can contain two equivalent keys as long as they enter different buckets. Or is it the responsibility of the coder to make sure the hasher and predicate are written to place equivalent keys in the same bucket? Or maybe does my eqOp function violate a rule that the compiler does not detect?</p>\n<p>In a set and a map it's clear: the predicate provided to those defines a strict weak ordering and so two keys considered equivalent have only one element associated with them. In an unordered map it's not so clear to me: two equivalent keys can have different elements associated with them so long as those keys are in different buckets. But those sources above feel like they tell me otherwise. </p>\n", "Tags": "<c++><hash><unordered-set>", "OwnerUserId": "4338785", "AnswerCount": "1"}});