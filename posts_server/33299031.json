post_cb({"33299163": {"ParentId": "33299031", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A lambda <a href=\"https://stackoverflow.com/q/28746744/1708801\">without a capture is convertible to a function pointer</a> which will match the <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow noreferrer\">following overload</a>:</p>\n<pre><code>basic_ostream&amp; operator&lt;&lt;(\nstd::basic_ostream&lt;CharT,Traits&gt;&amp; (*func)(std::basic_ostream&lt;CharT,Traits&gt;&amp;) );\n</code></pre>\n<p>As the cppreference links notes:</p>\n<blockquote>\n<p id=\"so_33299031_33299163_0\">Calls func(*this);. These overloads are used to implement output I/O\n  manipulators such as std::endl.</p>\n</blockquote>\n<p>from the draft C++11 standard section <code>5.1.2</code> <em>[expr.prim.lambda]</em>:</p>\n<blockquote>\n<p id=\"so_33299031_33299163_1\">The closure type for a lambda-expression <strong>with no lambda-capture has a\n  public non-virtual non-explicit const conversion function to pointer\n  to function</strong> having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:31.033", "Id": "33299163", "Score": "5", "CreationDate": "2015-10-23T09:35:46.017", "LastActivityDate": "2015-10-24T03:21:50.777"}, "33299122": {"ParentId": "33299031", "CommentCount": "0", "Body": "<p>You are defining a function that accepts a <em>stream</em>, uses it and then return the same stream.</p>\n<p>A possible use of it follows:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; v(5, 3);\n    auto lmda = [&amp;v](std::ostream&amp; os) -&gt; std::ostream&amp; { os &lt;&lt; v.size(); return os; };\n    lmda(std::cout) &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "33299122", "Score": "0", "CreationDate": "2015-10-23T09:33:43.057", "LastActivityDate": "2015-10-23T09:33:43.057"}, "33299167": {"ParentId": "33299031", "CommentCount": "0", "Body": "<p>A lambda with no capture is convertible to a pointer-to-function.</p>\n<blockquote>\n<p id=\"so_33299031_33299167_0\">[5.1.2/6] The closure type for a non-generic lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function with C ++ language linkage (7.5) having the same\n  parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure\n  type\u2019s function call operator.</p>\n</blockquote>\n<p>A lambda with capture is not convertible to anything printable.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "33299167", "Score": "2", "CreationDate": "2015-10-23T09:35:53.600", "LastActivityDate": "2015-10-23T09:35:53.600"}, "bq_ids": {"n4140": {"so_33299031_33299167_0": {"section_id": 5965, "quality": 0.9318181818181818, "length": 41}, "so_33299031_33299163_1": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_33299031_33299167_0": {"section_id": 5734, "quality": 0.8636363636363636, "length": 38}, "so_33299031_33299163_1": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_33299031_33299167_0": {"section_id": 7456, "quality": 0.8409090909090909, "length": 37}, "so_33299031_33299163_1": {"section_id": 7456, "quality": 0.85, "length": 34}}}, "33299031": {"CommentCount": "0", "ViewCount": "690", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-10-23T09:29:00.613", "LastActivityDate": "2015-10-24T03:21:50.777", "Title": "Using lambda as parameter to std::cout", "AcceptedAnswerId": "33299163", "LastEditDate": "2015-10-23T10:08:45.453", "Id": "33299031", "Score": "6", "Body": "<p>I am experimenting with lambda use and when testing the following it compile say 'hi'.</p>\n<pre><code>auto lmda = [](std::ostream&amp; os) -&gt; std::ostream&amp; { os &lt;&lt; \"hi\"; return os; };\nstd::cout &lt;&lt; lmda;\n</code></pre>\n<p>But when adding capture, it does not compile.\nExample:</p>\n<pre><code>std::vector&lt;int&gt; v(5, 3);\nauto lmda = [&amp;v](std::ostream&amp; os) -&gt; std::ostream&amp; { os &lt;&lt; v.size(); return os; };\nstd::cout &lt;&lt; lmda;\n</code></pre>\n<p>Build error is:</p>\n<pre><code>In function 'int main()':\n10:18: error: cannot bind 'std::ostream {aka std::basic_ostream&lt;char&gt;}' lvalue to 'std::basic_ostream&lt;char&gt;&amp;&amp;'\nIn file included from /usr/include/c++/4.9/iostream:39:0,\n             from 2:\n/usr/include/c++/4.9/ostream:602:5: note: initializing argument 1 of 'std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp;, const _Tp&amp;) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Tp = main()::&lt;lambda(std::ostream&amp;)&gt;]'\n operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp; __os, const _Tp&amp; __x)\n</code></pre>\n<p>I don't get why it fails in the second example.\nAny lead?</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "5479368", "AnswerCount": "3"}});