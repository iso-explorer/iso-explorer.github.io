post_cb({"12075249": {"Id": "12075249", "PostTypeId": "2", "Body": "<p>Yes, your defaulted copy assign operator precludes the implicit move ctor.</p>\n<p>BTW putting <code>=default</code> is actually a <em>definition</em>.  I remember <a href=\"https://stackoverflow.com/questions/9020372/how-do-i-use-unique-ptr-for-pimpl\">trying to implement</a> a pimpl idiom with <code>std::unique_ptr</code> and having to remove <code>=default</code> from headers and putting them in the implementation file because the destructor for <code>unique_ptr</code> needed the definition of the class it is trying to clean up.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-22T14:23:12.513", "Score": "2", "CreationDate": "2012-08-22T14:23:12.513", "ParentId": "12073556", "CommentCount": "0", "OwnerUserId": "680359", "LastEditDate": "2017-05-23T12:01:44.953"}, "12074205": {"Id": "12074205", "PostTypeId": "2", "Body": "<p>That is correct, \u00a712.8 sets the conditions when a move constructor gets implicitly declared and the presence of a user-declared copy constructor precludes that. You cannot have</p>\n<ul>\n<li>user-declared copy constructor</li>\n<li>user-declared copy assignment operator</li>\n<li>user-declared move-assignment operator</li>\n<li>user-declared destructor</li>\n</ul>\n", "LastActivityDate": "2012-08-22T13:24:58.530", "CommentCount": "0", "CreationDate": "2012-08-22T13:24:58.530", "ParentId": "12073556", "Score": "1", "OwnerUserId": "661519"}, "12073591": {"Id": "12073591", "PostTypeId": "2", "Body": "<p>A <code>default</code>ed copy constructor <em>is</em> indeed \"user-declared\"; I think the addition of <code>default</code> was in fact the reason why they changed the term from \"user-defined\" to \"user-declared\".</p>\n", "LastActivityDate": "2012-08-22T12:52:17.547", "CommentCount": "0", "CreationDate": "2012-08-22T12:52:17.547", "ParentId": "12073556", "Score": "2", "OwnerUserId": "541686"}, "bq_ids": {"n4140": {"so_12073556_12074507_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 3274}}, "n3337": {"so_12073556_12074507_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3145}}, "n4659": {"so_12073556_12074507_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 4032}}}, "12074507": {"Id": "12074507", "PostTypeId": "2", "Body": "<p>From the standard:</p>\n<blockquote>\n<h3>8.4.2 Explicitly-defaulted functions [dcl.fct.def.default]</h3>\n<p id=\"so_12073556_12074507_0\">4 - [...] A special member function is user-provided if it is user-declared and not explicitly\n  defaulted or deleted on its \ufb01rst declaration. [...]</p>\n</blockquote>\n<p>An explicit default can be combined with its declaration, or it can be separate:</p>\n<pre><code>struct S {\n    S();\n};\nS::S() = default;\n</code></pre>\n<p>In either case its (first) declaration makes it user-declared.</p>\n", "LastActivityDate": "2012-08-22T13:42:29.587", "CommentCount": "0", "CreationDate": "2012-08-22T13:42:29.587", "ParentId": "12073556", "Score": "3", "OwnerUserId": "567292"}, "12073556": {"ViewCount": "1744", "Body": "<p>I guess it is so, but I am looking for C++11 language lawyers to confirm my impression. Is it true that the following class</p>\n<pre><code>struct X{\nX(){}\nX(X const&amp;)=default;\n};\n</code></pre>\n<p>will not be automatically move-enabled, i.e., getting <code>X(X&amp;&amp;)</code> and <code>operator=(X&amp;&amp;)</code>, because its copy constructor is \"user-declared\", even though it looks equivalent to</p>\n<pre><code>struct X{\n};\n</code></pre>\n<p>which will get both <code>X(X const&amp;)</code> and <code>X(X&amp;&amp;)</code> etc., implicitely declared and (trivially) defined on use.</p>\n", "AcceptedAnswerId": "12073591", "Title": "C++ 11: is a defaulted copy constructor user declared?", "CreationDate": "2012-08-22T12:50:26.563", "Id": "12073556", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-08-22T14:23:12.513", "Score": "14", "OwnerUserId": "779373", "Tags": "<c++><c++11>", "AnswerCount": "4"}});