post_cb({"bq_ids": {"n4140": {"so_19636539_19636588_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 5768}, "so_19636539_19636588_0": {"length": 26, "quality": 0.896551724137931, "section_id": 6146}, "so_19636539_19636580_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 6146}, "so_19636539_19636580_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}}, "n3337": {"so_19636539_19636588_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 5541}, "so_19636539_19636588_0": {"length": 26, "quality": 0.896551724137931, "section_id": 5909}, "so_19636539_19636580_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 5909}, "so_19636539_19636580_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}}, "n4659": {"so_19636539_19636588_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 7225}, "so_19636539_19636588_0": {"length": 26, "quality": 0.896551724137931, "section_id": 7642}, "so_19636539_19636580_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7642}, "so_19636539_19636580_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}}}, "19636580": {"Id": "19636580", "PostTypeId": "2", "Body": "<p>In C++ as in C, shifts are limited to the size (in bits) of the value shifted. For instance, if unsigned int is 32 bits, then a shift of more than 31 is undefined.</p>\n<p>In practice, a common result is that the 5 least-significant bits of the shift amount are used and the higher order bits are ignored; this is due to the compiler producing a machine instruction which does exactly that (eg SHR on x86).</p>\n<p>In this case, the shift value is <code>100000</code> (decimal) which happens to be <code>11000011010100000</code> in binary - the lower 5 bits are zero. So, you're effectively getting a shift by 0. You shouldn't rely on this however; technically, what you're seeing is <em>undefined behaviour</em>.</p>\n<p>References:</p>\n<p>For C, <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow noreferrer\">N1570</a> section 6.5.7:</p>\n<blockquote>\n<p id=\"so_19636539_19636580_0\">If the value of the right operand is negative or is greater than or\n  equal to the width of the promoted left operand, the behavior is\n  undefined.</p>\n</blockquote>\n<p>For C++, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">N3690</a> section 5.8 \"[expr.shift]\":</p>\n<blockquote>\n<p id=\"so_19636539_19636580_1\">The behavior is undefined if the right operand is negative, or greater\n  than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>N1570 is a draft, nearly identical to the released ISO C11 standard; this clause has been pretty much the same since the 1989 ANSI C standard.</p>\n<p>N3690 is a recent draft of the C++ standard; I'm not sure whether it's the best one to use, but again, this clause hasn't changed.</p>\n", "LastEditorUserId": "388661", "LastActivityDate": "2017-08-31T11:56:21.810", "Score": "44", "CreationDate": "2013-10-28T13:51:40.733", "ParentId": "19636539", "CommentCount": "4", "OwnerUserId": "388661", "LastEditDate": "2017-08-31T11:56:21.810"}, "19636588": {"Id": "19636588", "PostTypeId": "2", "Body": "<p>You are invoking <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a> if you shift greater than the bit length of the left operand, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">draft C++ standard</a> section <code>5.8</code> <em>Shift operators</em> paragraph <em>1</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19636539_19636588_0\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand. <strong>The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand.</strong></p>\n</blockquote>\n<p>Interesting to note that both <code>gcc</code> and <code>clang</code> <em>may</em> generate a warning for this code if the shift amount if a <em>literal</em>:</p>\n<pre><code>cout &lt;&lt; (b&gt;&gt; 100000) ;\n</code></pre>\n<p>or if <code>b</code> is a <em>const</em>, the warning for <code>gcc</code> is as follows:</p>\n<pre><code>warning: right shift count &gt;= width of type [enabled by default]\n</code></pre>\n<p>as MSalters points out in the comments to the question, we may not be able to even rely on this warning since this is <em>undefined behavior</em>, which is consistent with the standards note on <em>undefined behavior</em> in the <em>terms and definitions</em> section which says:</p>\n<blockquote>\n<p id=\"so_19636539_19636588_1\">Note: [...] Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). [...]</p>\n</blockquote>\n<p><b>Platform specific details</b></p>\n<p>A potential explanation for the apparent lack of a shift in the example code may be because on some platforms the shift count will be <em>masked</em> to <code>5 bits</code> for example on an <code>x86</code> architecture we can see the <a href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf\">Intel\u00ae 64 and IA-32 Architectures Software Developer\u2019s Manual</a> section <em>SAL/SAR/SHL/SHR\u2014Shift</em> in the <em>IA-32 Architecture Compatibility</em> section says:</p>\n<blockquote>\n<p id=\"so_19636539_19636588_2\">The 8086 does not mask the shift count. However, all other IA-32 processors (starting with the Intel 286 processor) do mask the shift count to 5 bits, resulting in a maximum count of 31. [...]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-10-28T17:19:50.713", "Score": "31", "CreationDate": "2013-10-28T13:51:52.137", "ParentId": "19636539", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2013-10-28T17:19:50.713"}, "19636539": {"ViewCount": "1256", "Body": "<p>I must be absolutely crazy here, but <code>gcc 4.7.3</code> on my machine is giving the most absurd result.  Here is the exact code that I'm testing:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n  unsigned int b = 100000;\n  cout &lt;&lt; (b&gt;&gt;b) &lt;&lt; endl;\n  b = b &gt;&gt; b;\n  cout &lt;&lt; b &lt;&lt; endl;\n  b &gt;&gt;= b;\n  cout &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>Now, any number that's right shifted by itself should result in <strong>0</strong> (<code>n/(2^n) ==  0</code> with <em>integer divide</em>, <code>n&gt;1</code>, and <em>positive/unsigned</em>), but somehow here is my output:</p>\n<pre><code>100000\n100000\n100000\n</code></pre>\n<p>Am I crazy?  What could possibly be going on?</p>\n", "AcceptedAnswerId": "19636580", "Title": "Arithmetic right shift gives bogus result?", "CreationDate": "2013-10-28T13:49:27.973", "Id": "19636539", "CommentCount": "9", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-06-24T11:25:33.243", "LastEditorUserId": "1698143", "LastActivityDate": "2017-08-31T11:56:21.810", "Score": "30", "OwnerUserId": "1464336", "Tags": "<c++><gcc><undefined-behavior><bit-shift>", "AnswerCount": "2"}});