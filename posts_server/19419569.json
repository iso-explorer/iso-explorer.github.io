post_cb({"19553549": {"Id": "19553549", "PostTypeId": "2", "Body": "<p>A similar question was asked before: <a href=\"https://stackoverflow.com/questions/13950642/why-does-a-function-with-no-parameters-compared-to-the-actual-function-definiti\">Why does a function with no parameters (compared to the actual function definition) compile?</a></p>\n<p>One of the top-ranked answers was:</p>\n<blockquote>\n<p id=\"so_19419569_19553549_0\">In C <code>func()</code> means that you can pass <strong>any</strong> number of arguments. If you\n  want no arguments then you have to declare as <code>func(void)</code></p>\n</blockquote>\n<p>So, I guess it's how <code>main</code> is declared (if you can apply the term \"declared\" to <code>main</code>). In fact you can write something like this:</p>\n<pre><code>int main(int only_one_argument) {\n    // code\n}\n</code></pre>\n<p>and it will still compile and run.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-23T22:32:37.660", "Score": "2", "CreationDate": "2013-10-23T22:32:37.660", "ParentId": "19419569", "CommentCount": "1", "OwnerUserId": "1039437", "LastEditDate": "2017-05-23T12:25:42.303"}, "19419789": {"Id": "19419789", "PostTypeId": "2", "Body": "<p>This is one of the strange asymmetries and special rules of the C and C++ language.</p>\n<p>In my opinion it exists only for historical reasons and there's no real serious logic behind it. Note that <code>main</code> is special also for other reasons (for example <code>main</code> in C++ cannot be recursive and you cannot take its address and in C99/C++ you are allowed to omit a final <code>return</code> statement).</p>\n<p>Note also that even in C++ it's not an overload... either a program has the first form or it has the second form; it cannot have both.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2013-10-23T06:15:57.087", "Score": "5", "CreationDate": "2013-10-17T06:34:01.563", "ParentId": "19419569", "CommentCount": "4", "OwnerUserId": "320726", "LastEditDate": "2013-10-23T06:15:57.087"}, "19591741": {"Id": "19591741", "PostTypeId": "2", "Body": "<p>You do not need to override this.because only one will used at a time.yes there are 2 different version of main function</p>\n", "LastActivityDate": "2013-10-25T13:52:31.130", "CommentCount": "0", "CreationDate": "2013-10-25T13:52:31.130", "ParentId": "19419569", "Score": "0", "OwnerUserId": "2919998"}, "19427751": {"Id": "19427751", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19419569_19427751_0\">Well, the two different signatures of the same function main() comes in picture only when you want them so, I mean if your programm needs data before any actual processing of your code you may pass them via use of - </p>\n</blockquote>\n<pre><code>    int main(int argc, char * argv[])\n    {\n       //code\n    }\n</code></pre>\n<p>where the variable argc stores the count of data that is passed and argv is an array of pointers to char which points to the passed values from console. \nOtherwise it's always good to go with </p>\n<pre><code>    int main()\n    {\n       //Code\n    }\n</code></pre>\n<p>However in any case there can be one and only one main() in a programm, as because that's the only point where from a program starts its execution and hence it can not be more than one.\n(hope its worthy) </p>\n", "LastActivityDate": "2013-10-17T13:14:08.193", "CommentCount": "0", "CreationDate": "2013-10-17T13:14:08.193", "ParentId": "19419569", "Score": "2", "OwnerUserId": "2424594"}, "19419617": {"Id": "19419617", "PostTypeId": "2", "Body": "<p>There is NO overloading of <code>main</code> even in C++. Main function is the entry point for a program and only a single definition should exist.</p>\n<p>For Standard C</p>\n<blockquote>\n<p id=\"so_19419569_19419617_0\">For a hosted environment (that's the normal one), the C99 standard\n  says:</p>\n<blockquote>\n<h3>5.1.2.2.1 Program startup</h3>\n<p id=\"so_19419569_19419617_5\">The function called at program startup is named <code>main</code>. The implementation declares no prototype for this function. It shall be\n    defined with a return type of <code>int</code> and with no parameters:</p>\n<pre><code>int main(void) { /* ... */ }\n</code></pre>\n<p id=\"so_19419569_19419617_6\">or with two parameters (referred to here as <code>argc</code> and <code>argv</code>, though any names may be used, as they are local to the function in which they\n    are declared):</p>\n<pre><code>int main(int argc, char *argv[]) { /* ... */ }\n</code></pre>\n<p id=\"so_19419569_19419617_7\">or equivalent;<sup>9)</sup> or in some other implementation-defined manner.</p>\n<p id=\"so_19419569_19419617_8\"><sup>9)</sup> Thus, <code>int</code> can be replaced by a typedef name defined as <code>int</code>, or the type of <code>argv</code> can be written as <code>char **argv</code>, and\n    so on.</p>\n</blockquote>\n</blockquote>\n<p>For standard C++:</p>\n<blockquote>\n<h3>3.6.1 Main function [basic.start.main]</h3>\n<p id=\"so_19419569_19419617_9\">1 A program shall contain a global function called main, which is the designated start of the program. [...]</p>\n<p id=\"so_19419569_19419617_10\">2 An implementation <strong><em>shall not</em></strong> predefine the main function. <strong>This function shall not be overloaded</strong>. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:</p>\n<pre><code>int main() { /* ... */ }\n</code></pre>\n<p id=\"so_19419569_19419617_11\">and</p>\n<pre><code>int main(int argc, char* argv[]) { /* ... */ }\n</code></pre>\n</blockquote>\n<p>The C++ standard explicitly says \"It [the main function] shall have a return type of type int, but otherwise its type is implementation defined\", and requires the same two signatures as the C standard. </p>\n<p>In a <strong>hosted environment</strong> (A C environment which also supports the C libraries) - the Operating System calls <code>main</code>. </p>\n<p>In a <strong>non-hosted environment</strong> (One intended for embedded applications) you can always change the entry point (or exit) of your program using the pre-processor directives like</p>\n<pre><code>#pragma startup [priority]\n#pragma exit [priority]\n</code></pre>\n<p>Where priority is an optional integral number.</p>\n<p>Pragma startup executes the function before the main (priority-wise) and pragma exit executes the function after the main function. If there is more than one startup directive then priority decides which will execute first. </p>\n", "LastEditorUserId": "418729", "LastActivityDate": "2013-10-17T08:50:33.173", "Score": "33", "CreationDate": "2013-10-17T06:23:13.617", "ParentId": "19419569", "CommentCount": "3", "OwnerUserId": "418729", "LastEditDate": "2013-10-17T08:50:33.173"}, "19419603": {"Id": "19419603", "PostTypeId": "2", "Body": "<p>There is no need for overloading. Yes, there are 2 versions, but only one can be used at the time.</p>\n", "LastActivityDate": "2013-10-17T06:22:38.840", "CommentCount": "0", "CreationDate": "2013-10-17T06:22:38.840", "ParentId": "19419569", "Score": "8", "OwnerUserId": "694733"}, "bq_ids": {"n4140": {"so_19419569_19419617_10": {"length": 19, "quality": 0.76, "section_id": 7146}, "so_19419569_19419617_9": {"length": 7, "quality": 1.0, "section_id": 7145}}, "n3337": {"so_19419569_19419617_10": {"length": 22, "quality": 0.88, "section_id": 6890}, "so_19419569_19419617_9": {"length": 7, "quality": 1.0, "section_id": 6889}}, "n4659": {"so_19419569_19419617_10": {"length": 19, "quality": 0.76, "section_id": 8647}, "so_19419569_19419617_9": {"length": 5, "quality": 0.7142857142857143, "section_id": 8646}}}, "19419569": {"ViewCount": "13238", "Body": "<p>I know there are two different signatures to write the main method -</p>\n<pre><code>int main()\n{\n   //Code\n}\n</code></pre>\n<p>or for handling command line argument, we write it as-</p>\n<pre><code>int main(int argc, char * argv[])\n{\n   //code\n}\n</code></pre>\n<p>In <code>C++</code> I know we can overload a method, but in <code>C</code> how does the compiler handle these two different signatures of <code>main</code> function?</p>\n", "AcceptedAnswerId": "19420041", "Title": "How does the main() method work in C?", "CreationDate": "2013-10-17T06:20:18.817", "Id": "19419569", "CommentCount": "7", "FavoriteCount": "30", "PostTypeId": "1", "LastEditDate": "2015-05-24T14:11:50.287", "LastEditorUserId": "2076937", "LastActivityDate": "2016-02-04T05:34:28.370", "Score": "90", "OwnerUserId": "2076937", "Tags": "<c++><c>", "AnswerCount": "9"}, "19420041": {"Id": "19420041", "PostTypeId": "2", "Body": "<p>Some of the features of the C language started out as hacks which just happened to work.</p>\n<p>Multiple signatures for main, as well as variable-length argument lists, is one of those features.</p>\n<p>Programmers noticed that they can pass extra arguments to a function, and nothing bad happens with their given compiler.</p>\n<p>This is the case if the calling conventions are such that:</p>\n<ol>\n<li>The calling function cleans up the arguments.</li>\n<li>The leftmost arguments are closer to the top of the stack, or to the base of the stack frame, so that spurious arguments do not invalidate the addressing.</li>\n</ol>\n<p>One set of calling conventions which obeys these rules is stack-based parameter passing whereby the caller pops the arguments, and they are pushed right to left:</p>\n<pre><code> ;; pseudo-assembly-language\n ;; main(argc, argv, envp); call\n\n push envp  ;; rightmost argument\n push argv  ;; \n push argc  ;; leftmost argument ends up on top of stack\n\n call main\n\n pop        ;; caller cleans up   \n pop\n pop\n</code></pre>\n<p>In compilers where this type of calling convention is the case, nothing special need to be done to support the two kinds of <code>main</code>, or even additional kinds. <code>main</code> can be a function of no arguments, in which case it is oblivious to the items that were pushed onto the stack. If it's a function of two arguments, then it finds <code>argc</code> and <code>argv</code> as the two topmost stack items. If it's a platform-specific three-argument variant with an environment pointer (a common extension), that will work too: it will find that third argument as the third element from the top of the stack.</p>\n<p>And so a fixed call works for all cases, allowing a single, fixed start-up module to be linked to the program. That module could be written in C, as a function resembling this:</p>\n<pre><code>/* I'm adding envp to show that even a popular platform-specific variant\n   can be handled. */\nextern int main(int argc, char **argv, char **envp);\n\nvoid __start(void)\n{\n  /* This is the real startup function for the executable.\n     It performs a bunch of library initialization. */\n\n  /* ... */\n\n  /* And then: */\n  exit(main(argc_from_somewhere, argv_from_somewhere, envp_from_somewhere));\n}\n</code></pre>\n<p>In other words, this start module just calls a three-argument main, always. If main takes no arguments, or only <code>int, char **</code>, it happens to work fine, as well as if it takes no arguments, due to the calling conventions.</p>\n<p>If you were to do this kind of thing in your program, it would be nonportable and considered undefined behavior by ISO C: declaring and calling a function in one manner, and defining it in another. But a compiler's startup trick does not have to be portable; it is not guided by the rules for portable programs.</p>\n<p>But suppose that the calling conventions are such that it cannot work this way. In that case, the compiler has to treat <code>main</code> specially. When it notices that it's compiling the <code>main</code> function, it can generate code which is compatible with, say, a three argument call.</p>\n<p>That is to say, you write this:</p>\n<pre><code>int main(void)\n{\n   /* ... */\n}\n</code></pre>\n<p>But when the compiler sees it, it essentially performs a code transformation so that the function which it compiles looks more like this:</p>\n<pre><code>int main(int __argc_ignore, char **__argv_ignore, char **__envp_ignore)\n{\n   /* ... */\n}\n</code></pre>\n<p>except that the names <code>__argc_ignore</code> don't literally exist. No such names are introduced into your scope, and there won't be any warning about unused arguments.\nThe code transformation causes the compiler to emit code with the correct linkage which knows that it has to clean up three arguments.</p>\n<p>Another implementation strategy is for the compiler or perhaps linker to custom-generate the <code>__start</code> function (or whatever it is called), or at least select one from several pre-compiled alternatives. Information could be stored in the object file about which of the supported forms of <code>main</code> is being used.  The linker can look at this info, and select the correct version of the start-up module which contains a call to <code>main</code> which is compatible with the program's definition.  C implementations usually have only a small number of supported forms of <code>main</code> so this approach is feasible. </p>\n<p>Compilers for the C99 language always have to treat <code>main</code> specially, to some extent, to support the hack that if the function terminates without a <code>return</code> statement, the behavior is as if <code>return 0</code> were executed.  This, again, can be treated by a code transformation. The compiler notices that a function called <code>main</code> is being compiled. Then it checks whether the end of the body is potentially reachable. If so, it inserts a <code>return 0;</code></p>\n", "LastEditorUserId": "1250772", "LastActivityDate": "2013-10-17T07:04:03.803", "Score": "125", "CreationDate": "2013-10-17T06:50:07.557", "ParentId": "19419569", "CommentCount": "1", "OwnerUserId": "1250772", "LastEditDate": "2013-10-17T07:04:03.803"}, "19419631": {"Id": "19419631", "PostTypeId": "2", "Body": "<p>The <code>main</code> is just a name for a starting address decided by the linker where <code>main</code> is the default name. All function names in a program are starting addresses where the function starts.</p>\n<p>The function arguments are pushed/popped on/from the stack so if there are no arguments specified for the function there are no arguments pushed/popped on/off the stack. That is how main can work both with or without arguments.</p>\n", "LastActivityDate": "2013-10-17T06:24:17.113", "CommentCount": "0", "CreationDate": "2013-10-17T06:24:17.113", "ParentId": "19419569", "Score": "3", "OwnerUserId": "45685"}, "19534717": {"Id": "19534717", "PostTypeId": "2", "Body": "<p>What's unusual about <code>main</code> isn't that it can be defined in more than one way, it's that it can <em>only</em> be defined in one of two different ways.</p>\n<p><code>main</code> is a user-defined function; the implementation doesn't declare a prototype for it.</p>\n<p>The same thing is true for <code>foo</code> or <code>bar</code>, but you can define functions with those names any way you like.</p>\n<p>The difference is that <code>main</code> is invoked by the implementation (the runtime environment), not just by your own code. The implementation isn't limited to ordinary C function call semantics, so it can (and must) deal with a few variations -- but it's not required to handle infinitely many possibilities. The <code>int main(int argc, char *argv[])</code> form allows for command-line arguments, and <code>int main(void)</code> in C or <code>int main()</code> in C++ is just a convenience for simple programs that don't need to process command-line arguments.</p>\n<p>As for how the compiler handles this, it depends on the implementation. Most systems probably have calling conventions that make the two forms effectively compatible, and any arguments passed to a <code>main</code> defined with no parameters are quietly ignored. If not, it wouldn't be difficult for a compiler or linker to treat <code>main</code> specially. If you're curious how it works <em>on your system</em>, you might look at some assembly listings.</p>\n<p>And like many things in C and C++, the details are largely a result of history and arbitrary decisions made by the designers of the languages and their predecessors.</p>\n<p>Note that both C and C++ both permit other implementation-defined definitions for <code>main</code> -- but there's rarely any good reason to use them. And for <em>freestanding implementations</em> (such as embedded systems with no OS), the program entry point is implementation-defined, and isn't necessarily even called <code>main</code>.</p>\n", "LastEditorUserId": "161801", "LastActivityDate": "2016-02-04T05:34:28.370", "Score": "4", "CreationDate": "2013-10-23T06:49:20.360", "ParentId": "19419569", "CommentCount": "0", "OwnerUserId": "827263", "LastEditDate": "2016-02-04T05:34:28.370"}});