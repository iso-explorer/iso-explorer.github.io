post_cb({"32678572": {"Id": "32678572", "PostTypeId": "2", "Body": "<p>The recursion will end eventually by actually executing a <code>return</code> statement. At that point, the compiler will place the returned value in the location used for return values.</p>\n<p>When you get back to the calling function, without executing any other return statements, it just happens to still be there. Just by chance.</p>\n", "LastActivityDate": "2015-09-20T10:58:53.727", "CommentCount": "0", "CreationDate": "2015-09-20T10:58:53.727", "ParentId": "32678334", "Score": "0", "OwnerUserId": "597607"}, "32678334": {"ViewCount": "205", "Body": "<p>I wrote a simple binary search function in C++. The code is like below:</p>\n<pre><code>int binary_search(int arr[], int key, int imin, int imax)\n{\n    if (imin &gt; imax)\n    {\n        return -1;\n    }\n    else\n    {\n        int imid = imin + (imax - imin) / 2;\n        if (arr[imid] &gt; key) binary_search(arr, key, imin, imid - 1);\n        else if (arr[imid] &lt; key) binary_search(arr, key, imid + 1, imax);\n        else return imid;\n    }\n\n}\n</code></pre>\n<p>But I found that if I add <code>return</code> in lines 10 and 11, the code seems work in the same way. The code is like below:</p>\n<pre><code>int binary_search(int arr[], int key, int imin, int imax)\n{\n    if (imin &gt; imax)\n    {\n        return -1;\n    }\n    else\n    {\n        int imid = imin + (imax - imin) / 2;\n        if (arr[imid] &gt; key) return binary_search(arr, key, imin, imid - 1);\n        else if (arr[imid] &lt; key) return binary_search(arr, key, imid + 1, imax);\n        else return imid;\n    }\n\n}\n</code></pre>\n<p>So my question is what is the difference between these two situation?</p>\n", "AcceptedAnswerId": "32678381", "Title": "What is the difference between return the function and not return in a recursive function?", "CreationDate": "2015-09-20T10:32:33.060", "Id": "32678334", "CommentCount": "2", "LastEditDate": "2015-09-20T10:35:43.563", "PostTypeId": "1", "LastEditorUserId": "418066", "LastActivityDate": "2015-09-20T11:25:05.433", "Score": "1", "OwnerUserId": "5059142", "Tags": "<c++>", "AnswerCount": "3"}, "32678482": {"Id": "32678482", "PostTypeId": "2", "Body": "<p>If a function that returns non-<code>void</code> \"falls of the end\" (i.e. with no return statement) and the caller uses the return value, then the result is undefined behaviour.   That is happening in your first version (either on your recursive calls, or for the caller) unless - by chance - your test case only ever results in the <code>return imid</code> statement being executed.</p>\n<p>Unfortunately, one possible result of undefined behaviour is code that appears to work correctly for all your test cases.   There is nothing preventing that.   Program crashes (or other abnormal program terminations) are what people are often more acquainted with when undefined behaviour occurs, but a more insidious result of undefined behaviour is code that <em>seems</em> to behave as if nothing is wrong.</p>\n<p>In practice, the reason your first case <em>seems</em> to work correctly is blind luck.   For historical reasons that I won't expand on, a fair few compilers place working data for calculations (i.e. statements in your function) and results into machine registers, doesn't bother to clear those registers, and also (when a function returns <code>int</code> or other non-<code>struct</code> types) uses those same machine registers to hold return values from functions.   So you can get lucky that the code in the first example behaves like the second.    The problem is, however, that such behaviour is not guaranteed by the standard, may change between compilers, may change with compiler settings (e.g. optimisation options), and may even change when your compiler is upgraded at some future time.</p>\n", "LastActivityDate": "2015-09-20T10:49:48.630", "CommentCount": "0", "CreationDate": "2015-09-20T10:49:48.630", "ParentId": "32678334", "Score": "1", "OwnerUserId": "4706785"}, "bq_ids": {"n4140": {"so_32678334_32678381_0": {"length": 12, "quality": 1.0, "section_id": 3913}}, "n3337": {"so_32678334_32678381_0": {"length": 12, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_32678334_32678381_0": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "32678381": {"Id": "32678381", "PostTypeId": "2", "Body": "<p>Any function that does not return nothing (<code>void</code>) must encounter a <code>return</code> statement before running out of things to do. This is quite simply because there is no magic \"return X if I do not return something\" imperative, and the person <em>using</em> the function might rely on the return that you promised (but failed to deliver).</p>\n<p>If you now follow the path that leads to those recursive calls in the original function, you will see that the call that initiated the recursive call in the first place now has to return something. Instead it simply ignores the result of the recursive call and runs out of things to do.</p>\n<p>This causes something called <em>undefined behavior</em>, because C++ does not know what the heck you expect it to do. In fact, <a href=\"http://catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow\">\"it is legal for it to make demons fly out of your nose.\"</a>, although it will usually - out of the pure benevolence of its soul - restrict itself to crashing horribly and unpredictably.</p>\n<p>Two primary options exist why you do not see a difference:</p>\n<ul>\n<li><p>The code is compiled in such a way that its undefined-ness will work as intended. You <em>must</em> not rely on this, ever. In practice, your code will be compiled in such a way that a single register holds your return value (<a href=\"https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions\" rel=\"nofollow\">RAX</a>). Since the recursive call is the last thing your code does, that register <em>may</em> not be modified again, causing the code to act <em>as if</em> you had returned the result of the recursive call.</p></li>\n<li><p>Your test cases never actually do a recursive call. This is technically legal, as the correctness of your program depends on its behavior at runtime. You <em>should</em> not rely on this either.</p></li>\n</ul>\n<p>If you are interested, the relevant part of the standard is [stmt.return]/2, which says:</p>\n<blockquote>\n<p id=\"so_32678334_32678381_0\">[...] Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>\n</blockquote>\n<p>\"Flowing\" refers to control-flow, and a \"value-returning function\" is any function that has a return type other than <code>void</code>.</p>\n", "LastEditorUserId": "65678", "LastActivityDate": "2015-09-20T11:25:05.433", "Score": "3", "CreationDate": "2015-09-20T10:38:09.527", "ParentId": "32678334", "CommentCount": "2", "LastEditDate": "2015-09-20T11:25:05.433", "OwnerUserId": "65678"}});