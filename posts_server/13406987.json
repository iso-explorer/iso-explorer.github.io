post_cb({"bq_ids": {"n4140": {"so_13406987_13407454_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 458}, "so_13406987_13407454_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 458}, "so_13406987_13407454_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 460}}, "n3337": {"so_13406987_13407454_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 449}, "so_13406987_13407454_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 449}, "so_13406987_13407454_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 451}}, "n4659": {"so_13406987_13407454_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 481}, "so_13406987_13407454_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 481}, "so_13406987_13407454_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 483}}}, "13407454": {"Id": "13407454", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13406987_13407454_0\"><code>[C++11: 12.8/9]:</code> <strong>If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</strong></p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator,</li>\n<li><strong><code>X</code> does not have a user-declared destructor</strong>, and</li>\n<li>the move constructor would not be implicitly defined as deleted.</li>\n</ul>\n<p id=\"so_13406987_13407454_1\">[ <em>Note:</em> When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise\n  would have invoked the move constructor may instead invoke a copy constructor. \u2014end note ]</p>\n</blockquote>\n<p>That's why your #3 is breaking the synthesis.</p>\n<p>In addition, <a href=\"https://stackoverflow.com/questions/13407737/are-volatile-data-members-trivially-copyable\">it's far from clear</a> that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3159.html#496\" rel=\"nofollow noreferrer\">volatile types (including your <code>node* volatile</code>) are trivially copyable</a>; it could be concluded that <a href=\"https://groups.google.com/forum/?fromgroups=#!topic/comp.std.c++/5cWxmw71ktI\" rel=\"nofollow noreferrer\">it is implementation-defined whether they are or not</a> and, in your case, it seems that they are not.</p>\n<p>At the very least, <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=48118\" rel=\"nofollow noreferrer\">GCC made it stop working quite deliberately</a> in v4.7, with a proposal to backport into v4.6.1 that I can only presume went ahead...</p>\n<p>So, given the following:</p>\n<blockquote>\n<p id=\"so_13406987_13407454_2\"><code>[C++11: 12.8/11]:</code> An implicitly-declared copy/move constructor is an inline public member of its class. <strong>A defaulted copy/move constructor for a class <code>X</code> is defined as deleted (8.4.3) if <code>X</code> has</strong>:</p>\n<ul>\n<li>a variant member with a non-trivial corresponding constructor and <code>X</code> is a union-like class,\n  a non-static data member of class type <code>M</code> (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to <code>M</code>\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</li>\n<li>a direct or virtual base class <code>B</code> that cannot be copied/moved because overload resolution (13.3), as applied to <code>B</code>\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</li>\n<li>any direct or virtual base class or non-static data member of a type with a destructor that is deleted or inaccessible from the defaulted constructor,</li>\n<li>for the copy constructor, a non-static data member of rvalue reference type, or</li>\n<li><strong>for the move constructor, a non-static data member</strong> or direct or virtual base class <strong>with a type that does not have a move constructor and is not trivially copyable</strong>.</li>\n</ul>\n</blockquote>\n<p>... that's why your #4 is breaking the synthesis too, independently of #3.</p>\n<p>As for #5, that's not actually a declaration of a <code>node</code> at all, but a declaration for a function called <code>m</code> \u2014 that's why it's not reproducing the symptoms related to construction of a <code>node</code> (this is known as the <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow noreferrer\">Most Vexing Parse</a>).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-15T22:58:02.317", "Score": "12", "CreationDate": "2012-11-15T22:35:33.137", "ParentId": "13406987", "CommentCount": "6", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T12:32:12.290"}, "13406987": {"ViewCount": "746", "Body": "<p>Look at the following code:</p>\n<pre><code>struct node\n{\n\n  node();\n  //node(const node&amp;);    //#1\n  //node(node&amp;&amp;);         //#2\n\n  virtual                 //#3\n  ~node ();\n\n  node*\n  volatile                //#4\n  next;\n\n};\n\nint main()\n{\n\n  node m(node());         //#5\n  node n=node();          //#6\n}\n</code></pre>\n<p>When compiled with gcc-4.6.1 it produces the following error:</p>\n<pre><code>g++ -g --std=c++0x   -c -o node.o node.cc\nnode.cc: In constructor node::node(node&amp;&amp;):\nnode.cc:3:8: error: expression node::next has side-effects\nnode.cc: In function int main():\nnode.cc:18:14: note: synthesized method node::node(node&amp;&amp;) first required here\n</code></pre>\n<p>As I understand the compiler fails to create default move or copy constructor on line #6, if I uncomment either line #1 or #2 it compiles fine, that is clear. The code compiles fine without c++0x option, so the error is related to default move constructor.</p>\n<p>However, what in the node class prevents default move constructor to be created? If I comment any of the lines #3 or #4 (i.e. make the destructor non-virtual or make data member non-volatile) it compiles again, so is it the combination of these two makes it not to compile?</p>\n<p>Another puzzle, line #5 does not cause an compilation error, what is different from line #6? \nIs it all specific for gcc? or gcc-4.6.1? </p>\n", "AcceptedAnswerId": "13407454", "Title": "How is the C++ synthesized move constructor affected by volatile and virtual members?", "CreationDate": "2012-11-15T22:00:20.610", "Id": "13406987", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-11-15T23:09:02.433", "LastEditorUserId": "9530", "LastActivityDate": "2012-11-15T23:09:02.433", "Score": "10", "OwnerUserId": "1827766", "Tags": "<c++><c++11><g++><move-constructor>", "AnswerCount": "1"}});