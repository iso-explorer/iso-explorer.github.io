post_cb({"31082669": {"ParentId": "31082389", "CommentCount": "0", "Body": "<p>I disagree with the consensus here. A struct with three doubles in it, is exactly the same as an array with 3 doubles in it. Unless you specifically pack the struct differently and are on a weird processor that has an odd number of bytes for doubles.</p>\n<p>It's not built into the language, but I would feel safe in doing it. Style wise I wouldn't do it, because it's just confusing.</p>\n", "OwnerUserId": "259032", "PostTypeId": "2", "Id": "31082669", "Score": "-2", "CreationDate": "2015-06-26T21:48:38.250", "LastActivityDate": "2015-06-26T21:48:38.250"}, "31082519": {"ParentId": "31082389", "CommentCount": "0", "Body": "<p>From all I know the answer is: yes.</p>\n<p>The only thing that could throw you off is a #pragma directive with some very unusual alignment setting for the struct. If for example a double takes 8 bytes on your machine and the #pragma directive tells to align every member on 16-byte boundaries that could cause problems. Other than that you are fine.</p>\n", "OwnerUserId": "5049516", "PostTypeId": "2", "Id": "31082519", "Score": "1", "CreationDate": "2015-06-26T21:35:49.560", "LastActivityDate": "2015-06-26T21:35:49.560"}, "31082389": {"CommentCount": "3", "ViewCount": "392", "PostTypeId": "1", "LastEditorUserId": "4818447", "CreationDate": "2015-06-26T21:26:17.590", "LastActivityDate": "2015-07-01T11:20:35.060", "Title": "Casting double array to a struct of doubles", "LastEditDate": "2015-07-01T11:20:35.060", "Id": "31082389", "Score": "8", "Body": "<p>Is it OK to cast a double array to a struct made of doubles?</p>\n<pre><code>struct A\n{\n   double x;\n   double y;\n   double z;\n};\n\nint main (int argc , char ** argv)\n{\n   double arr[3] = {1.0,2.0,3.0};\n   A* a = static_cast&lt;A*&gt;(static_cast&lt;void*&gt;(arr));\n   std::cout &lt;&lt; a-&gt;x &lt;&lt; \" \" &lt;&lt; a-&gt;y &lt;&lt; \" \" &lt;&lt; a-&gt;z &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>This prints <code>1 2 3</code>. But is it guaranteed to work every time with any compiler?</p>\n<p>EDIT: According to</p>\n<blockquote>\n<p id=\"so_31082389_31082389_0\">9.2.21: A pointer to a standard-layout struct object, suitably converted ? using a reinterpret_cast, points to its initial member (...) and vice versa. </p>\n</blockquote>\n<p>if I replace my code with</p>\n<pre><code>struct A\n{\n  double &amp; x() { return data[0]; }\n  double &amp; y() { return data[1]; }\n  double &amp; z() { return data[2]; }\nprivate:\n   double data[3];\n};\n\nint main (int, char **)\n{\n   double arr[3] = {1.0,2.0,3.0};\n   A* a = reinterpret_cast&lt;A*&gt;(arr);\n   std::cout &lt;&lt; a-&gt;x() &lt;&lt; \" \" &lt;&lt; a-&gt;y() &lt;&lt; \" \" &lt;&lt; a-&gt;z() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>then it is guaranteed to work. Correct? I understand that many people would not find this aesteticaly pleasing but there are advantages in working with a struct and not having to copy the input array data. I can define member functions in that struct to compute scalar and vector products, distances etc, that will make my code much easier to understand than if I work with arrays.</p>\n<p>How about</p>\n<pre><code>int main (int, char **)\n{\n   double arr[6] = {1.0,2.0,3.0,4.0,5.0,6.0};\n   A* a = reinterpret_cast&lt;A*&gt;(arr);\n   std::cout &lt;&lt; a[0].x() &lt;&lt; \" \" &lt;&lt; a[0].y() &lt;&lt; \" \" &lt;&lt; a[0].z() &lt;&lt; \"\\n\";\n   std::cout &lt;&lt; a[1].x() &lt;&lt; \" \" &lt;&lt; a[1].y() &lt;&lt; \" \" &lt;&lt; a[1].z() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Is this also guaranteed to work or the compiler could put something AFTER the data members so that <code>sizeof(A) &gt; 3*sizeof(double)</code>? And is there any portable way to prevent the compiler from doing so?</p>\n", "Tags": "<c++><arrays><struct><language-lawyer><static-cast>", "OwnerUserId": "4818447", "AnswerCount": "5"}, "31082764": {"ParentId": "31082389", "CommentCount": "0", "Body": "<p>The standard gives little guarantees about memory layout of objects. </p>\n<p>For classes/structs:    </p>\n<blockquote>\n<p id=\"so_31082389_31082764_0\"><strong>9.2./15:</strong>  Nonstatic data members of a class with the same access control  are allocated so that later members have higher addresses\n  within a class object. The order of allocation of non-static data\n  members with different access control is unspecified. Implementation\n  <strong>alignment requirements might cause two adjacent members not to be allocated immediately after each other</strong>; so might requirements for\n  space for managing virtual functions and virtual base classes.</p>\n</blockquote>\n<p>For arrays, the elements are contiguous. Nothing is said about alignment, so it may or may not use same alignment rules than in struct :</p>\n<blockquote>\n<p id=\"so_31082389_31082764_1\"><strong>8.3.4:</strong>  An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.</p>\n</blockquote>\n<p>The only thing you can be sure of in your specific example is that <code>a.x</code> corresponds to <code>arr[0]</code>, if using a reinterpret_cast: </p>\n<blockquote>\n<p id=\"so_31082389_31082764_2\"><strong>9.2.21:</strong> A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (...)\n  and vice versa. [<br>\n  &gt;</br></p>\n</blockquote>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "31082764", "Score": "2", "CreationDate": "2015-06-26T21:57:05.070", "LastActivityDate": "2015-06-26T21:57:05.070"}, "31082578": {"ParentId": "31082389", "CommentCount": "0", "Body": "<p>No it is not guaranteed, even if it should work with all compilers I know on common architectures, because C language specification says :</p>\n<p><em>6.2.6 Representations of types\n6.2.6.1 General1 The representations of all types are unspecified except as stated in this subclause.</em> And it says nothing on the default padding in a struct.</p>\n<p>Of course, common architectures use at most 64bits which is the size of a double on those architecture, so there should be no padding and your conversion should work.</p>\n<p>But <strong>beware</strong> : you are explicitely invoking Undefined Behaviour, and next generation of compilers could do <em>anything</em> when compiling such a cast.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "31082578", "Score": "1", "CreationDate": "2015-06-26T21:41:19.430", "LastActivityDate": "2015-06-26T21:41:19.430"}, "bq_ids": {"n4140": {"so_31082389_31082764_0": {"section_id": 5873, "quality": 0.9591836734693877, "length": 47}, "so_31082389_31082764_1": {"section_id": 3228, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_31082389_31082389_0": {"section_id": 5650, "quality": 0.9333333333333333, "length": 14}, "so_31082389_31082764_0": {"section_id": 5644, "quality": 0.9591836734693877, "length": 47}, "so_31082389_31082764_1": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}, "so_31082389_31082764_2": {"section_id": 5650, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_31082389_31082764_0": {"section_id": 7356, "quality": 0.9591836734693877, "length": 47}, "so_31082389_31082764_1": {"section_id": 3985, "quality": 0.9090909090909091, "length": 10}}}, "31082498": {"ParentId": "31082389", "CommentCount": "0", "Body": "<p>No, it's not guaranteed.</p>\n<p>The only thing prohibiting any compiler from inserting padding between <code>x</code> and <code>y</code>, or between <code>y</code> and <code>z</code> is common sense. There is no rule in any language standard that would disallow it.</p>\n<p>Even if there is no padding, even if the representation of <code>A</code> is exactly the same as that of <code>double[3]</code>, then it's still not valid. The language doesn't allow you to pretend one type is really another type. You're not even allowed to treat an instance of <code>struct A { int i; };</code> as if it's a <code>struct B { int i; };</code>.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "31082498", "Score": "8", "CreationDate": "2015-06-26T21:34:16.230", "LastActivityDate": "2015-06-26T21:34:16.230"}});