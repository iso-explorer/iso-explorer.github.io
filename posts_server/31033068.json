post_cb({"31033068": {"CommentCount": "5", "AcceptedAnswerId": "31034690", "CreationDate": "2015-06-24T17:21:53.870", "LastActivityDate": "2015-06-24T18:53:50.447", "PostTypeId": "1", "ViewCount": "204", "FavoriteCount": "1", "Title": "When can you specialize a template on a private member type?", "Id": "31033068", "Score": "7", "Body": "<p>Given these definitions</p>\n<pre><code>template&lt;class T&gt; class foo {};\ntemplate&lt;class T&gt; class foo1 { static int i; };\nclass bar { class baz {}; };\n</code></pre>\n<p>I'm surprised to see that this compiles</p>\n<pre><code>template&lt;&gt;\nclass foo&lt;bar::baz&gt; {};\n</code></pre>\n<p>but this fails with the error <code>'class bar::baz' is private</code></p>\n<pre><code>template&lt;&gt;\nint foo1&lt;bar::baz&gt;::i = 42;\n</code></pre>\n<p>When does this happen, and is there a workaround other than making the type public?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "603688", "AnswerCount": "1"}, "31034690": {"ParentId": "31033068", "CommentCount": "0", "Body": "<p>Consider <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#182\"><strong>CWG #182</strong></a>:</p>\n<blockquote>\n<p id=\"so_31033068_31034690_0\">Certain access checks are suppressed on explicit instantiations.\n  14.7.2 [temp.explicit] paragraph 8 says [\u2026] I was surprised that similar wording does not exist (that I could find) for explicit\n  specializations. I believe that the two cases should be handled\n  equivalently in the example below (i.e., that the specialization\n  should be permitted).</p>\n<pre><code>template &lt;class T&gt; struct C {\n  void f();\n  void g();\n};\n\ntemplate &lt;class T&gt; void C&lt;T&gt;::f(){}\ntemplate &lt;class T&gt; void C&lt;T&gt;::g(){}\n\nclass A {\n  class B {};\n  void f();\n};\n\ntemplate void C&lt;A::B&gt;::f();    // okay\ntemplate &lt;&gt; void C&lt;A::B&gt;::g(); // error - A::B inaccessible\n</code></pre>\n<p id=\"so_31033068_31034690_1\">[\u2026]</p>\n<p id=\"so_31033068_31034690_2\"><strong>Rationale (October 2002)</strong>:</p>\n<p id=\"so_31033068_31034690_3\"><strong>We reconsidered this and decided that the difference between the two\n  cases (explicit specialization and explicit instantiation) is\n  appropriate. The access rules are sometimes bent when necessary to\n  allow naming something, as in an explicit instantiation, but explicit\n  specialization requires not only naming the entity but also providing\n  a definition somewhere.</strong></p>\n</blockquote>\n<p>GCC and Clang do indeed reject the last line of the example shown, which is - apparently - inconsistent behavior, as for a corresponding explicit specialization of a class template, they do not issue an error message:</p>\n<pre><code>template &lt;class&gt; struct T {\n    void g();\n};\n\nclass A { class B; class C; };\n\ntemplate &lt;&gt; struct T&lt;A::B&gt;;    // Ok\ntemplate &lt;&gt; void T&lt;A::C&gt;::g(); // Error\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/683d27c05be058e8\"><strong>Demo</strong></a>. So I'll go out on a limb here and call both cases you showed ill-formed by \u00a714.3/3:</p>\n<blockquote>\n<p id=\"so_31033068_31034690_4\">The name of a <em>template-argument</em> shall be accessible at the point\n  where it is used as a <em>template-argument</em>.</p>\n</blockquote>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "31034690", "Score": "5", "CreationDate": "2015-06-24T18:53:50.447", "LastActivityDate": "2015-06-24T18:53:50.447"}, "bq_ids": {"n4140": {"so_31033068_31034690_4": {"section_id": 78, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_31033068_31034690_4": {"section_id": 73, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_31033068_31034690_4": {"section_id": 80, "quality": 0.8571428571428571, "length": 6}}}});