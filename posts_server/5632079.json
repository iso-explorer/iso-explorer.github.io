post_cb({"5632255": {"ParentId": "5632079", "CommentCount": "0", "CreationDate": "2011-04-12T08:16:01.010", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "5632255", "Score": "23", "Body": "<p>Because according to the standard, modifications through\na <code>set&lt;&gt;::iterator</code> are not allowed.  The standard specifically\nallows <code>set&lt;&gt;::iterator</code> and <code>set&lt;&gt;::const_iterator</code> to be the\nsame type.  And although it doesn't require them to be the same\ntype, it does require the <code>value_type</code> of <code>set&lt;&gt;::iterator</code> to\nbe <code>const</code>.</p>\n<p>The reason for this, of course, is that any modifications to the\nvalue could invalidate the invariants of <code>std::set&lt;&gt;</code>.</p>\n", "LastActivityDate": "2011-04-12T08:16:01.010"}, "5632079": {"CommentCount": "0", "AcceptedAnswerId": "5632255", "CreationDate": "2011-04-12T07:56:34.917", "LastActivityDate": "2013-07-23T13:00:02.963", "PostTypeId": "1", "ViewCount": "2449", "FavoriteCount": "5", "Title": "Why does std::set.insert() return a non-const iterator, and yet I cannot modify it?", "Id": "5632079", "Score": "12", "Body": "<p>Consider this code example:</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nset&lt;string&gt; string_set;\n\nvoid foo(const string&amp; a)\n{\n    pair&lt;set&lt;string&gt;::iterator, bool&gt; insert_result = string_set.insert(a);\n\n    string&amp; val = *(insert_result.first);\n    val += \" - inserted\";\n}\n</code></pre>\n<p>So, correctness aside, such as not checking for successful insertion and so on, this code looks like it should allow me to amend the string after insertion, but the compiler (VS2010) forbids dereferencing the iterator to a non-const string (we're migrating from VS2005 which waved this through without a warning).</p>\n<p>Now, I know this should be forbidden since it may make the string non-unique, and I'm kind of glad it works this way, but in the real world case it's not quite so clear cut as that, as I want to amend a non-mutable data member that doesn't participate in equivalence testing or ordering.</p>\n<p>What I want to know is, how does the compiler KNOW I'm not allowed to do this, and how do I know without reference to the documentation (which doesn't mention this anyway)?</p>\n<p>Cheers,\nGuy</p>\n", "Tags": "<c++><visual-studio-2010><stl><iterator><set>", "OwnerUserId": "11483", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5632079_5632131_0": {"section_id": 1031, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_5632079_5632131_0": {"section_id": 1016, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_5632079_5632131_0": {"section_id": 1103, "quality": 0.9130434782608695, "length": 21}}}, "5632131": {"ParentId": "5632079", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-04-12T08:01:26.213", "Score": "3", "LastEditorUserId": "476681", "LastEditDate": "2011-04-12T08:35:58.750", "Id": "5632131", "OwnerUserId": "476681", "Body": "<p>From the standard :</p>\n<p>23.3.3  </p>\n<blockquote>\n<p id=\"so_5632079_5632131_0\">A set is a kind of associative\n  container that supports unique keys\n  (contains at most one of each key\n  value) and provides for fast retrieval\n  of the keys themselves. Class set\n  supports bidirectional iterators.</p>\n</blockquote>\n<p>This is also from the standard :<br>\n    typedef implementation defined\n    iterator;\n    // See 23.1</br></p>\n<p>The real implementation of set::iterator is a constant iterator in order to keep the requirement to have unique keys. Otherwise you could change the values in set to all the same values.</p>\n", "LastActivityDate": "2011-04-12T08:35:58.750"}});