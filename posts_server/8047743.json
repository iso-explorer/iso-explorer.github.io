post_cb({"8047786": {"ParentId": "8047743", "CommentCount": "0", "Body": "<p>It is very well defined in C++, which is why RAII works at all. All automatic objects are destroyed at the point at which they go out of scope, in the reverse order of construction.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "8047786", "Score": "3", "CreationDate": "2011-11-08T08:39:21.823", "LastActivityDate": "2011-11-08T08:39:21.823"}, "bq_ids": {"n4140": {"so_8047743_8047778_1": {"section_id": 3917, "quality": 1.0, "length": 9}, "so_8047743_8047778_0": {"section_id": 407, "quality": 0.7857142857142857, "length": 11}, "so_8047743_8047778_2": {"section_id": 3909, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_8047743_8047778_1": {"section_id": 3777, "quality": 1.0, "length": 9}, "so_8047743_8047778_0": {"section_id": 398, "quality": 0.9285714285714286, "length": 13}, "so_8047743_8047778_2": {"section_id": 3769, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_8047743_8047778_1": {"section_id": 4803, "quality": 1.0, "length": 9}, "so_8047743_8047778_0": {"section_id": 425, "quality": 0.7857142857142857, "length": 11}, "so_8047743_8047778_2": {"section_id": 4795, "quality": 0.9444444444444444, "length": 17}}}, "8047778": {"ParentId": "8047743", "CommentCount": "0", "Body": "<p>The C++ standard (n3290) is pretty clear on this. Your RAII objects are always going to have automatic storage duration (if they don't you're doing it wrong!) so</p>\n<p>\u00a712.4.11 says:</p>\n<blockquote>\n<p id=\"so_8047743_8047778_0\">\"Destructors are invoked implicitly .... for constructed objects with\n  automatic storage duration (3.7.3) when the block in which an object\n  is created exits (6.7)\"</p>\n</blockquote>\n<p>\u00a76.7.2 says:</p>\n<blockquote>\n<p id=\"so_8047743_8047778_1\">Variables with automatic storage duration declared in the block are\n  destroyed on exit from the block (6.6)</p>\n</blockquote>\n<p>and \u00a76.6.2 states:</p>\n<blockquote>\n<p id=\"so_8047743_8047778_2\">On exit from a scope (however accomplished), objects with automatic\n  storage duration (3.7.3) that have been constructed in that scope are\n  destroyed in the reverse order of their construction.</p>\n</blockquote>\n<p>Which read together leaves no doubt that the only conforming way to implement this is for the observable behaviour to be that automatic storage objects are destructed at the end of a block.</p>\n", "OwnerUserId": "168175", "PostTypeId": "2", "Id": "8047778", "Score": "7", "CreationDate": "2011-11-08T08:38:36.420", "LastActivityDate": "2011-11-08T08:38:36.420"}, "8047743": {"CommentCount": "1", "ViewCount": "169", "CreationDate": "2011-11-08T08:35:22.443", "LastActivityDate": "2011-11-08T08:39:21.823", "Title": "Are stack based RAII guaranteed to be run only after going out of scope in C++?", "AcceptedAnswerId": "8047778", "PostTypeId": "1", "Id": "8047743", "Score": "3", "Body": "<p>When using <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">Resource Acquisition Is Initialisation (RIAA)</a> in C++ it's typical to have something  the following:</p>\n<pre><code>class CriticalSection {\npublic:\n    void enter();\n    void leave();\n};\n\nclass SectionLocker {\npublic:\n    SectionLocker(CriticalSection&amp; cs)\n    : mCs(cs) {\n       cs.enter();   \n    }\n\n    ~SectionLocker() {\n        cs.leave();\n    }\n\nprivate:\n    CriticalSection&amp; mCs;\n};\n\nCriticalSection gOperationLock; // Global lock for some shared resource\n\nvoid doThings(int a, int b) {\n    SectionLocker locker(gOperationLock);\n    int c = doOtherThings(a);\n    doMoreThings(b);\n    doOneMoreThing(a, b, c);\n}\n</code></pre>\n<p>I know that in some garbage collected languages (such as the CLR) that one of the many reasons why this would be unsafe is that the locker object inside doThings() would be eligible for garbage collection before doThings() returns, as locker is never referenced after being created. </p>\n<p>Is the expected behaviour, of the destructor for locker only being called after the call to doOneMoreThing(), well defined behaviour in C++?</p>\n<p>If so, are there any guarantees about when the destructor will be called (and gOperationLock is released)? Or is it just at some point after it goes out of scope?</p>\n", "Tags": "<c++><concurrency>", "OwnerUserId": "1849", "AnswerCount": "2"}});