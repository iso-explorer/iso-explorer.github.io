post_cb({"31608148": {"Id": "31608148", "PostTypeId": "2", "Body": "<p>This seems a relict from the old days of simple linkers. You can use static variables in static methods as workaround:</p>\n<pre><code>// header.hxx\n#include &lt;vector&gt;\n\nclass Class {\npublic:\n    static std::vector&lt;int&gt; &amp; replacement_for_initialized_static_non_const_variable() {\n        static std::vector&lt;int&gt; Static {42, 0, 1900, 1998};\n        return Static;\n    }\n};\n\nint compilation_unit_a();\n</code></pre>\n<p>and</p>\n<pre><code>// compilation_unit_a.cxx\n#include \"header.hxx\"\n\nint compilation_unit_a() {  \n    return Class::replacement_for_initialized_static_non_const_variable()[1]++;\n}\n</code></pre>\n<p>and</p>\n<pre><code>// main.cxx\n#include \"header.hxx\"\n\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout\n    &lt;&lt; compilation_unit_a()\n    &lt;&lt; Class::replacement_for_initialized_static_non_const_variable()[1]++\n    &lt;&lt; compilation_unit_a()\n    &lt;&lt; Class::replacement_for_initialized_static_non_const_variable()[1]++\n    &lt;&lt; std::endl;\n}\n</code></pre>\n<p>build:</p>\n<pre><code>g++ -std=gnu++0x -save-temps=obj -c compilation_unit_a.cxx \ng++ -std=gnu++0x -o main main.cxx compilation_unit_a.o\n</code></pre>\n<p>run:</p>\n<pre><code>./main\n</code></pre>\n<p>The fact that this works (consistently, even if the class definition is included in different compilation units), shows that the linker today (gcc 4.9.2) is actually smart enough.</p>\n<p>Funny: Prints <code>0123</code> on arm and <code>3210</code> on x86.</p>\n", "LastActivityDate": "2015-07-24T10:26:49.020", "CommentCount": "0", "CreationDate": "2015-07-24T10:26:49.020", "ParentId": "9656941", "Score": "3", "OwnerUserId": "2965738"}, "bq_ids": {"n4140": {"so_9656941_9657064_4": {"length": 53, "quality": 0.8983050847457628, "section_id": 5908}, "so_9656941_9657064_0": {"length": 28, "quality": 0.7567567567567568, "section_id": 5908}, "so_9656941_9657064_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 7216}}, "n3337": {"so_9656941_9657064_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 6960}, "so_9656941_9657064_0": {"length": 28, "quality": 0.7567567567567568, "section_id": 5680}, "so_9656941_9657064_4": {"length": 53, "quality": 0.8983050847457628, "section_id": 5680}}, "n4659": {"so_9656941_9657064_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 8725}, "so_9656941_9657064_0": {"length": 24, "quality": 0.6486486486486487, "section_id": 7390}}}, "9656941": {"ViewCount": "62731", "Body": "<p><strong>Why can't I initialize non-const <code>static</code> member or <code>static</code> array in a class?</strong> </p>\n<pre><code>class A\n{\n    static const int a = 3;\n    static int b = 3;\n    static const int c[2] = { 1, 2 };\n    static int d[2] = { 1, 2 };\n};\n\nint main()\n{\n    A a;\n\n    return 0;\n}\n</code></pre>\n<p>the compiler issues following errors:</p>\n<pre><code>g++ main.cpp\nmain.cpp:4:17: error: ISO C++ forbids in-class initialization of non-const static member \u2018b\u2019\nmain.cpp:5:26: error: a brace-enclosed initializer is not allowed here before \u2018{\u2019 token\nmain.cpp:5:33: error: invalid in-class initialization of static data member of non-integral type \u2018const int [2]\u2019\nmain.cpp:6:20: error: a brace-enclosed initializer is not allowed here before \u2018{\u2019 token\nmain.cpp:6:27: error: invalid in-class initialization of static data member of non-integral type \u2018int [2]\u2019\n</code></pre>\n<p>I have two questions:</p>\n<ol>\n<li><strong>Why can't I initialize <code>static</code> data members in class?</strong> </li>\n<li><strong>Why can't I initialize <code>static</code> arrays in class, even the <code>const</code> array?</strong></li>\n</ol>\n", "AcceptedAnswerId": "9657064", "Title": "Why can't I initialize non-const static member or static array in class?", "CreationDate": "2012-03-11T17:01:18.573", "Id": "9656941", "CommentCount": "2", "FavoriteCount": "50", "PostTypeId": "1", "LastEditDate": "2016-11-09T16:25:33.990", "LastEditorUserId": "4527337", "LastActivityDate": "2016-11-09T16:25:33.990", "Score": "74", "OwnerUserId": "1253826", "Tags": "<c++><static><const>", "AnswerCount": "4"}, "29218562": {"Id": "29218562", "PostTypeId": "2", "Body": "<p>static variables are specific to a class . Constructors initialize attributes ESPECIALY for an instance.</p>\n", "OwnerDisplayName": "user4704595", "LastActivityDate": "2015-03-23T19:16:09.950", "Score": "-2", "CreationDate": "2015-03-23T19:16:09.950", "ParentId": "9656941", "CommentCount": "0"}, "9657081": {"Id": "9657081", "PostTypeId": "2", "Body": "<p>I think it's to prevent you from mixing declarations and definitions. (Think about the problems that could occur if you include the file in multiple places.)</p>\n", "LastActivityDate": "2012-03-11T17:19:14.170", "CommentCount": "0", "CreationDate": "2012-03-11T17:19:14.170", "ParentId": "9656941", "Score": "2", "OwnerUserId": "541686"}, "9657064": {"Id": "9657064", "PostTypeId": "2", "Body": "<h2>Why I can't initialize <code>static</code> data members in class?</h2>\n<p>The C++ standard allows only static constant integral or enumeration types to be initialized inside the class. This is the reason <code>a</code> is allowed to be initialized while others are not.</p>\n<p>Reference:<br>\n<strong>C++03 9.4.2 Static data members</strong><br>\n\u00a74</br></br></p>\n<blockquote>\n<p id=\"so_9656941_9657064_0\">If a static data member is of const integral or const enumeration type, its declaration in the class definition can specify a constant-initializer which shall be an integral constant expression (5.19). In that case, the member can appear in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p><strong>What are integral types?</strong> </p>\n<p><strong>C++03 3.9.1 Fundamental types</strong><br>\n\u00a77     </br></p>\n<blockquote>\n<p id=\"so_9656941_9657064_1\">Types bool, char, wchar_t, and the signed and unsigned integer types are collectively called integral types.43) A synonym for integral type is integer type.  </p>\n</blockquote>\n<p>Footnote:       </p>\n<blockquote>\n<p id=\"so_9656941_9657064_2\"><sup>43)</sup> Therefore, enumerations (7.2) are not integral; however, enumerations can be promoted to int, unsigned int, long, or unsigned long, as specified in 4.5.</p>\n</blockquote>\n<h2>Workaround:</h2>\n<p>You could use the <em>enum trick</em> to initialize an array inside your class definition.    </p>\n<pre><code>class A \n{\n    static const int a = 3;\n    enum { arrsize = 2 };\n\n    static const int c[arrsize] = { 1, 2 };\n\n};\n</code></pre>\n<h2>Why does the Standard does not allow this?</h2>\n<p>Bjarne explains this aptly <strong><a href=\"http://www.stroustrup.com/bs_faq2.html#in-class\" rel=\"noreferrer\">here</a></strong>:</p>\n<blockquote>\n<p id=\"so_9656941_9657064_3\">A class is typically declared in a header file and a header file is typically included into many translation units. However, to avoid complicated linker rules, C++ requires that every object has a unique definition. That rule would be broken if C++ allowed in-class definition of entities that needed to be stored in memory as objects.</p>\n</blockquote>\n<h2>Why are only <code>static const</code> integral types &amp; enums allowed In-class Initialization?</h2>\n<p>The answer is hidden in Bjarne's quote read it closely,<br>\n<em>\"C++ requires that every object has a unique definition. That rule would be broken if C++ allowed in-class definition of entities that needed to be stored in memory as objects.\"</em> </br></p>\n<p>Note that only <code>static const</code> integers can be treated as compile time constants. The compiler knows that the integer value will not change anytime and hence it can apply its own magic and apply optimizations, the compiler simply inlines such class members i.e, they are not stored in memory anymore, As the need of being stored in memory is removed, it gives such variables the exception to rule mentioned by Bjarne.    </p>\n<p>It is noteworthy to note here that even if <code>static const</code> integral values can have In-Class Initialization, taking address of such variables is not allowed. One can take the address of a static member if (and only if) it has an out-of-class definition.This further validates the reasoning above.     </p>\n<p>enums are allowed this because values of an enumerated type can be used where ints are expected.<sup>see citation above</sup></p>\n<hr>\n<h2>How does this change in C++11?</h2>\n<p>C++11 relaxes the restriction to certain extent.     </p>\n<p><strong>C++11 9.4.2 Static data members</strong><br>\n\u00a73     </br></p>\n<blockquote>\n<p id=\"so_9656941_9657064_4\">If a static data member is of const literal type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. A static data member of literal type can be declared in the class definition with the <code>constexpr specifier;</code> if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. [ Note: In both these cases, the member may appear in constant expressions. \u2014end note ] The member shall still be defined in a namespace scope if it is used in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p>Also, C++11 <em>will</em> allow(\u00a712.6.2.8) a non-static data member to be initialized where it is declared(in its class). This will mean much easy user semantics.    </p>\n<p>Note that these features have not yet been implemented in latest gcc 4.7, So you might still get compilation errors.</p>\n</hr>", "LastEditorUserId": "150634", "LastActivityDate": "2012-12-01T17:41:13.517", "Score": "106", "CreationDate": "2012-03-11T17:16:44.543", "ParentId": "9656941", "CommentCount": "13", "OwnerUserId": "452307", "LastEditDate": "2012-12-01T17:41:13.517"}});