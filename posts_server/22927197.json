post_cb({"bq_ids": {"n4140": {"so_22927197_22931994_0": {"length": 22, "quality": 0.6875, "section_id": 1907}, "so_22927197_22931994_1": {"length": 26, "quality": 1.0, "section_id": 1908}}, "n3337": {"so_22927197_22931994_0": {"length": 22, "quality": 0.6875, "section_id": 1896}, "so_22927197_22931994_1": {"length": 26, "quality": 1.0, "section_id": 1897}}, "n4659": {"so_22927197_22931994_0": {"length": 22, "quality": 0.6875, "section_id": 2177}, "so_22927197_22931994_1": {"length": 26, "quality": 1.0, "section_id": 2178}}}, "22927579": {"Id": "22927579", "PostTypeId": "2", "Body": "<p>No. Particularly not with Unix. A DBM is going to want contiguous files. That means either a unix variant that support them or creating a disk partition. </p>\n<p>You're also going to want to handle the buffering; not following the C++ library's buffering.</p>\n<p>I could go on but streams are for - - streams of data -- not secure, reliable structured data.</p>\n", "LastActivityDate": "2014-04-08T04:29:41.837", "CommentCount": "0", "CreationDate": "2014-04-08T04:29:41.837", "ParentId": "22927197", "Score": "0", "OwnerUserId": "3344003"}, "22927197": {"ViewCount": "262", "Body": "<p>In C++, I know I can use read or write file using system function like read or write and I can also do that with fstream's help.</p>\n<p>Now I'm implementing a disk management which is a component of DBMS. For simplicity I only use disk management to manage the space of a Unix file.</p>\n<p>All I know is fstream wrap system function like read or write and provide some buffer.\nHowever I was wondering whether this will affect atomicity and synchronization or not?</p>\n<p>My question is which way should I use and why?</p>\n", "Title": "Can I use fstream in C++ to read or write file when I'm implementing a disk management component of DBMS", "CreationDate": "2014-04-08T03:54:11.103", "LastActivityDate": "2014-04-23T05:43:02.193", "CommentCount": "1", "LastEditDate": "2014-04-23T05:43:02.193", "PostTypeId": "1", "LastEditorUserId": "15168", "Id": "22927197", "Score": "0", "OwnerUserId": "1832786", "Tags": "<c++><database><fstream>", "AnswerCount": "2"}, "22931994": {"Id": "22931994", "PostTypeId": "2", "Body": "<p>The following information about synchronization and thread safety of 'fstream' can be found from ISO C++ standard.</p>\n<p><strong>27.2.3 Thread safety [iostreams.threadsafety]</strong></p>\n<blockquote>\n<p id=\"so_22927197_22931994_0\">Concurrent access to a stream object (27.8, 27.9), stream buffer\n  object (27.6), or C Library stream (27.9.2) by multiple threads may\n  result in a data race (1.10) unless otherwise specified (27.4). [\n  Note: Data races result in undefined behavior (1.10). \u2014end note ]</p>\n<p id=\"so_22927197_22931994_1\">If one thread makes a library call a that writes a value to a stream\n  and, as a result, another thread reads this value from the stream\n  through a library call b such that this does not result in a data\n  race, then a\u2019s write synchronizes with b\u2019s read.</p>\n</blockquote>\n<p>C/C++ file I/O operation are not thread safe by default. So if you are planning to use fstream of open/write/read system call, then you would have to use synchronization mechanism by yourself in your implementation. You may use 'std::mutex' mechanism provided in new C++ standard(.i.e C++11) to synchronize your file I/O.</p>\n", "LastActivityDate": "2014-04-08T08:48:14.360", "CommentCount": "0", "CreationDate": "2014-04-08T08:48:14.360", "ParentId": "22927197", "Score": "0", "OwnerUserId": "2724703"}});