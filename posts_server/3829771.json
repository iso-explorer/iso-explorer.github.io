post_cb({"3829771": {"CommentCount": "0", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2010-09-30T10:40:01.487", "LastActivityDate": "2011-02-06T16:13:22.763", "Title": "Lack of orthogonality in templates between class and function", "AcceptedAnswerId": "3830216", "LastEditDate": "2011-02-06T16:13:22.763", "Id": "3829771", "Score": "2", "Body": "<pre><code>// InternalTemplate.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n\ntemplate&lt;class T&gt;\nstruct LeftSide\n{\n static void insert(T*&amp; newLink, T*&amp; parent)\n {\n  parent-&gt;getLeft() = newLink;\n  newLink-&gt;parent = newLink;\n }\n};\n\ntemplate&lt;class T&gt;\nstruct Link\n{\n T* parent_;\n T* left_;\n T* right_;\n T*&amp; getParent()const\n {\n  return parent_;\n }\n template&lt;class Side&gt;\n void plugIn(Link&lt;T&gt;*&amp; newLink);\n\n\n};\n\ntemplate&lt;class T&gt;\ntemplate&lt;class Side&gt;\nvoid Link&lt;T&gt;::plugIn(Link&lt;T&gt;*&amp; newLink)//&lt;&lt;-----why can't I type  \n//void Link&lt;T&gt;::plugIn&lt;Side&gt;(Link&lt;T&gt;*&amp; newLink)&lt;---&lt;Side&gt; next to plugIn\n\n\n{\n Side::insert(newLink,this);\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n return 0;\n}\n</code></pre>\n<p>I find it strange that I have to specify parameter for a class but cannot specify parameter for a function. Is there any reason why?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "207177", "AnswerCount": "3"}, "3830216": {"ParentId": "3829771", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-09-30T11:47:45.923", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:09.937", "Id": "3830216", "OwnerUserId": "418110", "Body": "<p><code>$14/2</code> -  </p>\n<blockquote>\n<p id=\"so_3829771_3830216_0\">A template-declaration can appear only as a namespace scope or class scope declaration. <strong>In a function template declaration, the last component of the declarator-id shall be a template-name or operator-functionid (i.e., not a template-id).</strong> [ Note: in a class template declaration, if the class name is a simple-template-id, the declaration declares a class template partial specialization (14.5.5). \u2014end note ]\"</p>\n</blockquote>\n<p>The standard forbids such a syntax explicitly. Refer this for more idea about <a href=\"https://stackoverflow.com/questions/3796558/difference-between-template-name-and-template-id\">template id / template name</a></p>\n", "LastActivityDate": "2010-10-01T00:58:10.537"}, "4914414": {"ParentId": "3829771", "CommentCount": "0", "CreationDate": "2011-02-06T16:08:12.800", "OwnerUserId": "373025", "PostTypeId": "2", "Id": "4914414", "Score": "2", "Body": "<p>Function templates and class templates are complementary (I call them orthogonal, but you are free not to agree), and in template metaprogramming they actually serve orthogonal purposes.</p>\n<p>Class templates allow you to <em>pattern match</em> on the template argument, ie. they provide <em>partial specialization</em>.</p>\n<p>Function templates, to the contrary, don't allow partial specialization, but they allow <em>template argument deduction</em>, which means you don't have to write the template arguments explicitly (except for extra arguments, as in your example).</p>\n<p>This, I think, explains the differences in syntax since they are different in what they can achieve. Moreover, function templates can have overloads, class templates cannot.</p>\n<p>The way to combine both concepts is </p>\n<p>1) to have helper class templates with static non template functions if you want partial specialization for function templates:</p>\n<pre><code>template &lt;typename T&gt;\nstruct doSomethingWithPointersHelper\n{\n    static void act(T x) { ... }\n};\n\ntemplate &lt;typename T&gt;\nstruct doSomethingWithPointersHelper&lt;T*&gt;\n{\n    static void act(T* x) { ... }\n};\n\n// This acts as if we had a partial specialization\n// for pointer types\ntemplate &lt;typename T&gt;\ndoSomethingWithPointers(T x)\n{ return doSomethingWithPointersHelper&lt;T&gt;::act(x); }\n</code></pre>\n<p>There are other ways to achieve this in particular cases, but this approach always works.</p>\n<p>2) To have helper template functions if you want to make use of argument deduction when constructing complex classes:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct MyComplexClass\n{ ... };\n\ntemplate &lt;typename T, typename U&gt;\nMyComplexClass&lt;T, U&gt; makeComplex(T t, U u)\n{ return MyComplexClass&lt;T, U&gt;(t, u); }\n</code></pre>\n<p>in the standard library, you find <code>make_pair</code>, <code>bind1st</code> or <code>mem_fun</code> which make use of this technique.</p>\n", "LastActivityDate": "2011-02-06T16:08:12.800"}, "bq_ids": {"n4140": {"so_3829771_3830216_0": {"section_id": 49, "quality": 0.8181818181818182, "length": 27}}, "n3337": {"so_3829771_3830216_0": {"section_id": 44, "quality": 0.8181818181818182, "length": 27}}, "n4659": {"so_3829771_3830216_0": {"section_id": 50, "quality": 0.8181818181818182, "length": 27}}}, "3830501": {"ParentId": "3829771", "CommentCount": "0", "CreationDate": "2010-09-30T12:35:27.827", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "3830501", "Score": "0", "Body": "<p>You need to specialize on the <code>Link</code> struct in order to define it's template member function.</p>\n<pre><code>template&lt;&gt;\ntemplate&lt;class Side&gt;\nvoid Link&lt;int&gt;::plugIn(Link&lt;int&gt;*&amp; newLink)\n{\n Side::insert(newLink,this);\n}\n</code></pre>\n<p>Gotta be honest, this makes my brain explode a little.</p>\n", "LastActivityDate": "2010-09-30T12:35:27.827"}});