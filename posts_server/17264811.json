post_cb({"bq_ids": {"n4140": {"so_17264811_17264847_0": {"length": 24, "quality": 1.0, "section_id": 3876}, "so_17264811_17264847_1": {"length": 4, "quality": 0.8, "section_id": 3475}}, "n3337": {"so_17264811_17264847_0": {"length": 24, "quality": 1.0, "section_id": 3736}, "so_17264811_17264847_1": {"length": 4, "quality": 0.8, "section_id": 3344}}, "n4659": {"so_17264811_17264847_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 4690}, "so_17264811_17264847_1": {"length": 4, "quality": 0.8, "section_id": 4239}}}, "17264886": {"Id": "17264886", "PostTypeId": "2", "Body": "<p>I assume that the question is: \"Why does function overloading cause ambiguity error?\".</p>\n<p>The answer is very clear in your case: There is not any version of pow(a, b) that accepts the parameter a as integer. Rather than displaying an error, the compiler tries to find a version of pow where there is a built-in (or custom) type conversion operator that can cast int into the type pow expects. It happens that there are 3 such functions and there is a conversion operator for each such function. That is why the compiler finds it ambiguous.</p>\n", "LastActivityDate": "2013-06-23T20:15:31.093", "CommentCount": "1", "CreationDate": "2013-06-23T20:15:31.093", "ParentId": "17264811", "Score": "0", "OwnerUserId": "777530"}, "17264920": {"Id": "17264920", "PostTypeId": "2", "Body": "<p>Because <code>pow</code> acceptes a <code>double</code> or a <code>float</code> as second parameter (your <code>x</code>). <a href=\"http://www.cplusplus.com/reference/cmath/pow/\" rel=\"nofollow\">Here</a> is the description for <code>pow</code> in C++11.</p>\n<p>If your run the same code on VS2010 in will too issue an error.</p>\n", "LastActivityDate": "2013-06-23T20:18:30.727", "CommentCount": "0", "CreationDate": "2013-06-23T20:18:30.727", "ParentId": "17264811", "Score": "0", "OwnerUserId": "2339141"}, "17264847": {"Id": "17264847", "PostTypeId": "2", "Body": "<p>You do not get any compilation errors, since the C++ standards says that your integer type is to be accepted and converted to double.</p>\n<p>From the standard \u00a726.8/11:</p>\n<blockquote>\n<p id=\"so_17264811_17264847_0\">Moreover, there shall be additional overloads sufficient to ensure:<br>\n  [...]<br>\n  3. Otherwise, if any argument corresponding to a double parameter has type double or an integer type, then all arguments corresponding to double parameters are effectively cast to double.</br></br></p>\n</blockquote>\n<p>Also see <a href=\"http://en.cppreference.com/w/cpp/numeric/math/pow\" rel=\"nofollow\">cppreference.com/.../pow</a> where it says:</p>\n<blockquote>\n<p id=\"so_17264811_17264847_1\">If any argument has integral type, it is cast to double.</p>\n</blockquote>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2013-06-24T15:01:43.203", "Score": "3", "CreationDate": "2013-06-23T20:10:23.847", "ParentId": "17264811", "CommentCount": "10", "OwnerUserId": "951423", "LastEditDate": "2013-06-24T15:01:43.203"}, "17264811": {"ViewCount": "312", "Body": "<p>This code compiles without an error in gcc 4.6.1 and 4.8.1 ( eclipse auto compilation says: Candidates are: float pow(float, int) long double pow(long double, \n int) double pow(double, int) ):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(void) {\n    const int i = 0, x = 2;\n    double y = pow( i, x );\n    y = log( i ) / log( x );\n    cout &lt;&lt; y;\nreturn 0;\n}\n</code></pre>\n<p>Thank you very much. This code has performed some nice confusing at work. The compiler can be trusted?</p>\n", "AcceptedAnswerId": "17264847", "Title": "Why function overloading causes no ambiguous error? ( c++ )", "CreationDate": "2013-06-23T20:05:12.303", "Id": "17264811", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-06-24T15:01:43.203", "Score": "0", "OwnerUserId": "2514292", "Tags": "<c++><function><overloading><implicit-conversion>", "AnswerCount": "3"}});