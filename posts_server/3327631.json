post_cb({"3327638": {"Id": "3327638", "PostTypeId": "2", "Body": "<p>The compiler doesn't cast the <code>void*</code> pointer to anything -- you, the programmer, do. </p>\n<p>In order to do anything useful with a <code>void*</code> pointer, you need to <em>explicitly</em> cast it to a non-<code>void*</code> pointer, and if you're wrong about what type the pointer actually points to, you enter Undefined Behavior City.</p>\n", "LastActivityDate": "2010-07-25T01:30:33.767", "CommentCount": "1", "CreationDate": "2010-07-25T01:30:33.767", "ParentId": "3327631", "Score": "3", "OwnerUserId": "39375"}, "bq_ids": {"n4140": {"so_3327631_3327659_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 6044}}, "n3337": {"so_3327631_3327659_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 5807}}, "n4659": {"so_3327631_3327659_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 7543}}}, "3327631": {"ViewCount": "2290", "Body": "<p>If you have a void* pointer to Derived class that inherits from both <code>BaseA</code> and <code>BaseB</code>, how does the compiler cast the <code>void*</code> pointer to <code>BaseA*</code> (or <code>BaseB*</code>) without knowing that the <code>void*</code> pointer is of type <code>Derived</code>?</p>\n", "AcceptedAnswerId": "3327659", "Title": "Casting with multiple inheritance", "CreationDate": "2010-07-25T01:27:42.040", "Id": "3327631", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-07-25T01:43:45.543", "LastEditorUserId": "151292", "LastActivityDate": "2010-07-25T01:43:45.543", "Score": "6", "OwnerUserId": "401306", "Tags": "<c++><casting><multiple-inheritance>", "AnswerCount": "2"}, "3327659": {"Id": "3327659", "PostTypeId": "2", "Body": "<p>It doesn't.  The only guarantee when casting to and from a <code>void*</code> using a <code>static_cast</code> is:</p>\n<blockquote>\n<p id=\"so_3327631_3327659_0\">A value of type pointer to object converted to \"pointer to <code>cv void</code>\" and back to the original pointer type will have its original value (C++03 \u00a75.2.9/10).</p>\n</blockquote>\n<p>For example, the following code is incorrect because the <code>void*</code> is cast to a type other than the original pointer type (the cast sequence is <code>B1*</code> -&gt; <code>void*</code> -&gt; <code>B2*</code>):</p>\n<pre><code>struct B1 { int i; };\nstruct B2 { int j; };\n\nstruct D : B1, B2 { };\n\nD x;\nB1*   b1ptr   = &amp;x;\nvoid* voidptr = b1ptr;\nB2*   b2ptr   = static_cast&lt;B2*&gt;(voidptr);\n</code></pre>\n<p>Attempting to use <code>b2ptr</code> here would result in undefined behavior.  The only type to which you can safely cast <code>voidptr</code> is <code>B1*</code>, since that is the type from which the <code>void*</code> was obtained (well, or to a <code>char*</code>, since anything can be accessed via a <code>char*</code>).</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-07-25T01:42:09.823", "Score": "5", "CreationDate": "2010-07-25T01:37:07.637", "ParentId": "3327631", "CommentCount": "0", "OwnerUserId": "151292", "LastEditDate": "2010-07-25T01:42:09.823"}});