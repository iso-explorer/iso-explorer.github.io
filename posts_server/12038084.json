post_cb({"12038211": {"ParentId": "12038084", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>True, in many <code>[start, end)</code> pair algorithm end points <em>past</em> the last valid entry. But your implementation should never <em>dereference</em> <code>end</code>, the last entry actually accessed should be <code>end-1</code>, which is guaranteed to be in valid region. If your algorithm dereferences <code>*end</code> then is a bug. In fact there are test allocators that intentionally place the region on the very last bytes of a valid page, immedeatly followed by an unallocated region. With such allocators an algorithm that dereferences <code>*end</code> will cause protection fault.</p>\n<blockquote>\n<p id=\"so_12038084_12038211_0\"><a href=\"http://technet.microsoft.com/en-us/library/cc779664%28v=ws.10%29\" rel=\"nofollow\"><code>FLG_HEAP_PAGE_ALLOCS</code></a></p>\n<p id=\"so_12038084_12038211_1\">Turns on page heap debugging, which verifies dynamic heap memory\n  operations, including allocations and frees, and causes a debugger\n  break when it detects a heap error.</p>\n<p id=\"so_12038084_12038211_2\">This option enables full page heap debugging when set for image files\n  and standard page heap debugging when set in system registry or kernel\n  mode.</p>\n<ul>\n<li><p id=\"so_12038084_12038211_3\">Full page heap debugging (for /i) places an inaccessible page at the\n  end of an allocation.</p></li>\n<li><p id=\"so_12038084_12038211_4\">Standard page heap debugging (for /r or /k) examines allocations as\n  they are freed.</p></li>\n</ul>\n<p id=\"so_12038084_12038211_5\">Setting this flag for an image file is the same as typing gflags /p\n  enable /full for the image file at the command line</p>\n</blockquote>\n<p>As for the issue of pointer overfllow: no operating system allocates page containing VA address 0xFFFFFFFF, same way no operating system ever allocates page containing 0x00000000. For such overflow to occur the size of <code>*start</code> would have to be big enough for <code>start+1</code> to jump over all the reserved VA at the end of valid ranges. But in such case the addess allocated for <code>start</code> should be at least one such size <em>below</em> the last valid VA address, and this implies <code>start+1</code> will be valid (it follows <code>start+N</code> is also always valid as long as <code>start</code> was allocated as <code>sizeof(*start)*N</code>).</p>\n", "OwnerUserId": "105929", "LastEditorUserId": "105929", "LastEditDate": "2012-08-20T13:14:16.607", "Id": "12038211", "Score": "1", "CreationDate": "2012-08-20T13:02:20.637", "LastActivityDate": "2012-08-20T13:14:16.607"}, "12038131": {"ParentId": "12038084", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is not possible for elements of a contiguous memory allocation to have non-contiguous addresses. <code>end</code> always has an address of higher value than <code>start</code>.</p>\n<p>In the case that the allocation happens to end at exactly 0xFFFFFFFF for example, meaning <code>end</code> will be 0x00000000, this would be a bug and the code should be fixed to accommodate that scenario.</p>\n<p>On some platforms though this scenario is impossible by design and could be a reasonable compromise in logic for the sake of simplicity. For example I would not hesitate to write <code>if(p &lt; end)</code> on a Windows user-mode application.</p>\n", "OwnerUserId": "402169", "LastEditorUserId": "402169", "LastEditDate": "2012-08-20T13:04:08.807", "Id": "12038131", "Score": "1", "CreationDate": "2012-08-20T12:57:21.067", "LastActivityDate": "2012-08-20T13:04:08.807"}, "12038129": {"ParentId": "12038084", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Don't worry about it.  Your allocator (probably <code>new</code>, but maybe something else) won't give you something so close to the end of memory that it wraps around.</p>\n<p>Worry about bounds checking instead.  You won't ever get an allocation that wraps around like this, so as long as you don't overrun arrays (which has undefined behavior anyway), you won't end up wrapping around.</p>\n<p>It's also useful to note that large chunks of process address space are reserved for the kernel.  On most operating systems, this high-order area is reserved.</p>\n", "OwnerUserId": "1462604", "LastEditorUserId": "1462604", "LastEditDate": "2012-08-20T13:08:07.303", "Id": "12038129", "Score": "-1", "CreationDate": "2012-08-20T12:57:07.177", "LastActivityDate": "2012-08-20T13:08:07.303"}, "12038228": {"ParentId": "12038084", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_12038084_12038228_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>5.9 Relational operators [expr.rel]</h3>\n<p id=\"so_12038084_12038228_1\">If two pointers point to elements of the same array or one beyond\n  the end of the array, the pointer to the object with the higher subscript compares higher.</p>\n</blockquote>\n<p>So you don't need to worry; a conformant implementation will ensure that the past-the-end pointer compares correctly to the rest of the array.  In addition,</p>\n<blockquote>\n<h3>3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]</h3>\n<p id=\"so_12038084_12038228_2\">[...] The pointer returned shall be suitably aligned so that it can be converted\n  to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used\n  to access the object or array in the storage allocated [...]</p>\n</blockquote>\n<p>The implication is that the pointer returned should be able to be treated as the pointer to the beginning of an array of appropriate size, so 5.9 continues to hold.  This would be the case if the allocation function call is the result of calling <code>operator new[]</code> (5.3.4:5).</p>\n<p>As a practical matter, if you're on a platform where it is conceivable for the allocator to (non-conformantly) return a block of memory ending at <code>0xFFFFFFFF</code>, you could in most cases write</p>\n<pre><code>if (p != end)\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-08-20T13:58:03.613", "Id": "12038228", "Score": "9", "CreationDate": "2012-08-20T13:03:16.297", "LastActivityDate": "2012-08-20T13:58:03.613"}, "bq_ids": {"n4140": {"so_12038084_12038228_2": {"section_id": 7177, "quality": 0.9047619047619048, "length": 19}, "so_12038084_12038228_1": {"section_id": 6151, "quality": 0.6875, "length": 11}}, "n3337": {"so_12038084_12038228_2": {"section_id": 6921, "quality": 0.9047619047619048, "length": 19}, "so_12038084_12038228_1": {"section_id": 5913, "quality": 1.0, "length": 16}}, "n4659": {"so_12038084_12038228_1": {"section_id": 7648, "quality": 0.625, "length": 10}, "so_12038084_12038228_2": {"section_id": 8685, "quality": 0.7619047619047619, "length": 16}}}, "12038084": {"CommentCount": "0", "AcceptedAnswerId": "12038228", "PostTypeId": "1", "LastEditorUserId": "1462604", "CreationDate": "2012-08-20T12:54:49.427", "LastActivityDate": "2012-08-20T13:58:03.613", "LastEditDate": "2012-08-20T12:59:53.357", "ViewCount": "1883", "FavoriteCount": "1", "Title": "C++ Maximum valid memory address", "Id": "12038084", "Score": "11", "Body": "<p>I often see code that adds a value, such as a length to a pointer, and then uses this value, e.g.</p>\n<pre><code>T* end = buffer + bufferLen;//T* + size_t\n\nif (p &lt; end)\n</code></pre>\n<p>However, is it possible for the buffer to have been allocated near enough the end of memory that \"buffer + bufferLen\" may overflow (e.g. 0xFFFFFFF0 + 0x10), resulting in \"p &lt; end\" being false even if p was a valid element address (e.g. 0xFFFFFFF8).</p>\n<p>If it is possible, how can it be avoided when I see many things that work with a begin/end range where end next element after the last one </p>\n", "Tags": "<c++><pointers>", "OwnerUserId": "6266", "AnswerCount": "4"}});