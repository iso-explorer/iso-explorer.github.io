post_cb({"bq_ids": {"n4140": {"so_10011039_10011133_0": {"length": 86, "quality": 0.7610619469026548, "section_id": 7151}}, "n3337": {"so_10011039_10011133_0": {"length": 87, "quality": 0.7699115044247787, "section_id": 6895}}}, "10011039": {"CreationDate": "2012-04-04T12:24:27.787", "ViewCount": "738", "Id": "10011039", "AcceptedAnswerId": "10011133", "Score": "3", "Title": "Initialization order of static data inside class template", "CommentCount": "0", "Body": "<pre><code>// File: InitFirst.h\n\n#pragma once\n\ntemplate &lt;int val&gt;\nstruct InitFirst\n{\n    static float s_dividedByThree;\n};\n\ntemplate &lt;int val&gt;\nfloat InitFirst&lt;val&gt;::s_dividedByThree = val / 3.0;\n</code></pre>\n<hr>\n<pre><code>// File: Test.h\n\n#include &lt;conio.h&gt;\n#include &lt;tchar.h&gt;\n\n#include \"InitFirst.h\"\n\nfloat g_shouldBeOneThird = InitFirst&lt;1&gt;::s_dividedByThree;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    _cprintf(\"%f\\n\", g_shouldBeOneThird);\n    getch();\n    return 0;\n}\n</code></pre>\n<p>Is g_shouldBeOneThird guaranteed to be initialized to around 0.333? In other words, is the statically initialized InitFirst&lt;1&gt;::s_dividedByThree guaranteed to be initialized by the time it's used for statically initializing g_shouldBeOneThird?</p>\n</hr>", "Tags": "<c++><templates><static><initialization><static-initialization>", "LastActivityDate": "2012-04-04T18:55:23.530", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "313853"}, "10011133": {"LastActivityDate": "2012-04-04T18:55:23.530", "CommentCount": "4", "Body": "<p>From the standard (3.6.2):</p>\n<blockquote>\n<p id=\"so_10011039_10011133_0\">Objects with static storage duration (3.7.1) shall be zero-initialized\n  (8.5) before any other initialization takes place. A reference with\n  static storage duration and an object of POD type with static storage\n  duration can be initialized with a constant expression (5.19); this is\n  called constant initialization. Together, zero-initialization and\n  constant initialization are called static initialization; all other\n  initialization is dynamic initialization. Static initialization shall\n  be performed before any dynamic initialization takes place. Dynamic\n  initialization of an object is either ordered or unordered.\n  Definitions of explicitly specialized class template static data\n  members have ordered initialization. Other class template static data\n  members (i.e., implicitly or explicitly instantiated specializations)\n  have unordered initialization. Other objects defined in namespace\n  scope have ordered initialization. Objects defined within a single\n  translation unit and with ordered initialization shall be initialized\n  in the order of their definitions in the translation unit. The order\n  of initialization is unspecified for objects with unordered\n  initialization and for objects defined in different translation units.</p>\n</blockquote>\n<p>In your case here, since you're initializing <code>float InitFirst&lt;val&gt;::s_dividedByThree</code> with a constant expression, this will happen before any dynamic initialization (f.x <code>float g_shouldBeOneThird</code>). Though I have a feeling this simplified example might be a simplification of a case where you have dynamic initialization, then the relevant part is: \"Objects defined within a single translation unit and with ordered initialization shall be initialized in the order of their definitions in the translation unit.\".</p>\n<p>There is a trick to make sure that global variables (sort of) are initialised by the time you use them. The trick is to keep them as a static local variable in a global function. Since local static variables are initialised the first time they're accessed, initialisation order is not an issue anymore:</p>\n<pre><code>template &lt;int val&gt;\nstruct InitFirst\n{\n    static float &amp; s_dividedByThree();\n};\n\ntemplate &lt;int val&gt;\nfloat &amp; InitFirst&lt;val&gt;::s_dividedByThree(){\n    static float staticVariable = val / 3.0;\n    return staticVariable;\n}\n</code></pre>\n<p>You can then access those variables <strong>almost</strong> as before:</p>\n<pre><code>float g_shouldBeOneThird = InitFirst&lt;1&gt;::s_dividedByThree();\n</code></pre>\n<p>Beware though, initialization of local static variables are not safe under multiple threads (it's not in the standard that they should be safe). If that is a concern for you, you might want to protect the initializations with \nsome locks. The compilers are of course allowed to generate safe code, which is what gcc does by default (probably others too).</p>\n", "CreationDate": "2012-04-04T12:31:00.600", "LastEditDate": "2012-04-04T18:55:23.530", "ParentId": "10011039", "Id": "10011133", "LastEditorUserId": "1103705", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1103705"}});