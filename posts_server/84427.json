post_cb({"84562": {"ParentId": "84427", "CommentCount": "3", "Body": "<p>1: Taking the address of a temporary is not allowed. Visual C++ allows it as a language extension (language extensions are on by default).</p>\n<p>2: This is perfectly legal.</p>\n", "OwnerUserId": "11828", "PostTypeId": "2", "Id": "84562", "Score": "16", "CreationDate": "2008-09-17T15:34:34.540", "LastActivityDate": "2008-09-17T15:34:34.540"}, "84475": {"ParentId": "84427", "CommentCount": "1", "Body": "<p>Those A objects will only exist until execution reaches the semicolon.  So, the calls are safe, but don't try to save the pointer and use it later.   Also, the compiler may require bar take a const reference.</p>\n", "OwnerUserId": "12725", "Id": "84475", "PostTypeId": "2", "OwnerDisplayName": "James Curran", "Score": "1", "CreationDate": "2008-09-17T15:26:59.003", "LastActivityDate": "2008-09-17T15:26:59.003"}, "84494": {"ParentId": "84427", "CommentCount": "1", "Body": "<p>It is legal. We use it sometime to provide a default value which we might want to ignore.</p>\n<pre><code>int dosomething(error_code&amp; _e = ignore_errorcode()) {\n    //do something\n}\n</code></pre>\n<p>In the above case it will construct an empty error code object if no <code>error_code</code> is passed to the function.</p>\n", "OwnerUserId": "716", "Id": "84494", "PostTypeId": "2", "OwnerDisplayName": "roo", "Score": "-1", "CreationDate": "2008-09-17T15:29:09.157", "LastActivityDate": "2008-09-17T15:29:09.157"}, "89059": {"ParentId": "84427", "CommentCount": "2", "Body": "<p><em>foo</em> is not allowed in fully standard compliant C++, whereas <em>bar</em> is okay. Though chances are, <em>foo</em> will compile with warning, and <em>bar</em> may or may not compile with a warning as well.</p>\n<p><em>A()</em> create a temporary object, which unless bound to a reference (as is the case in <em>bar</em>), or used to initialize a named object, is destroyed at the end of the full expression in which it was created. A temporary created to hold a reference initializer persists until the end of its reference's scope. For the case of <em>bar</em>, that's the function call, so you can use <em>A</em> inside <em>bar</em> perfectly safely. It is forbidden to bound a temporary object (which is a rvalue) to a non-const reference. It is similarly forbidden to take the address of a rvalue (to pass as argument to initialize <em>A</em> for <em>foo</em>).</p>\n", "OwnerUserId": "12868", "Id": "89059", "PostTypeId": "2", "OwnerDisplayName": "KTC", "Score": "5", "CreationDate": "2008-09-18T00:58:12.657", "LastActivityDate": "2008-09-18T00:58:12.657"}, "1152218": {"ParentId": "84427", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Short answer is yes. </p>\n<p>If the object is received by function as const reference parameter - as you have modified <code>bar(const A&amp;)</code> method, then it's totally legal. The function can operate on the object, but the object will be destructed after the function call (address of temporary can be taken, but shall not be stored and used after the function call - see reason below).</p>\n<p>The <code>foo(A*)</code> is legal too because the temporary object is destroyed at the end of fullexpression. However most of the compiler will emit warning about taking address of temporary.</p>\n<p>The original version of <code>bar(A&amp;)</code> shall not compile, it's against the standard to initialize a non-const reference from a temporary.</p>\n<blockquote>\n<p id=\"so_84427_1152218_0\"><strong>C++ standard chapter 12.2</strong></p>\n<p id=\"so_84427_1152218_1\">3 [...] Temporary objects are destroyed as the last step in evaluating the fullexpression (1.9) that (lexically) contains the point where they were created. [...]</p>\n<p id=\"so_84427_1152218_2\">4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when an expression appears as an initializer for a declarator defining an object. In that context, the temporary that holds the result of the expression shall persist until the object\u2019s initialization is complete. [...]</p>\n<p id=\"so_84427_1152218_3\">5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object to a subobject of which the temporary is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor\u2019s ctorinitializer (12.6.2) persists until the constructor exits. A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.\n  A temporary bound to the returned value in a function return statement (6.6.3) persists until the function exits.</p>\n</blockquote>\n<p>A <strong>fullexpression</strong> is an expression that is not a subexpression of another expression.</p>\n", "OwnerUserId": "140006", "LastEditorUserId": "44390", "LastEditDate": "2015-05-15T16:45:49.020", "Id": "1152218", "Score": "2", "CreationDate": "2009-07-20T08:00:51.370", "LastActivityDate": "2015-05-15T16:45:49.020"}, "84521": {"ParentId": "84427", "CommentCount": "1", "Body": "<p>No, it's against the standard to pass a non-const reference to a temporary object. You can use a const reference:</p>\n<pre><code>class A{};\n\nvoid bar(const A&amp;);\n\nint main(void)\n{\n    bar(A());  // 2\n}\n</code></pre>\n<p>So while some compliers will accept it, and it would work as long as don't use the memory after the semicolon, a conforming compiler will not accept it.</p>\n", "OwnerUserId": "852", "Id": "84521", "PostTypeId": "2", "OwnerDisplayName": "Matt Price", "Score": "9", "CreationDate": "2008-09-17T15:30:52.473", "LastActivityDate": "2008-09-17T15:30:52.473"}, "84471": {"ParentId": "84427", "CommentCount": "1", "Body": "<p>It looked lke it would work, but it did not compile with g++ with the Wall option, here is what I get:</p>\n<pre>\nmichael@hardy-lenovo:~/Desktop$ g++ -Wall a.cpp\na.cpp: In function \u2018int main()\u2019:michael@hardy-lenovo:~/Desktop$ g++ -Wall a.cpp\na.cpp: In function \u2018int main()\u2019:\na.cpp:8: warning: taking address of temporary\na.cpp:9: error: invalid initialization of non-const reference of type \u2018A&amp;\u2019 from a temporary of type \u2018A\u2019\na.cpp:4: error: in passing argument 1 of \u2018void bar(A&amp;)\u2019\nmichael@hardy-lenovo:~/Desktop$ \n</pre>\n<p>Looks like you will need to use a constant reference.</p>\n", "OwnerUserId": "1638", "Id": "84471", "PostTypeId": "2", "OwnerDisplayName": "mmattax", "Score": "0", "CreationDate": "2008-09-17T15:26:43.733", "LastActivityDate": "2008-09-17T15:26:43.733"}, "84457": {"ParentId": "84427", "CommentCount": "0", "Body": "<p>Perfectly legal.</p>\n<p>The object will exist on the stack during the function call, just like any other local variable as well. </p>\n", "OwnerUserId": "15955", "Id": "84457", "PostTypeId": "2", "OwnerDisplayName": "Nils", "Score": "-2", "CreationDate": "2008-09-17T15:26:00.113", "LastActivityDate": "2008-09-17T15:26:00.113"}, "84505": {"ParentId": "84427", "CommentCount": "1", "Body": "<p>for //2 you need a const reference</p>\n<p>for //1 I think it's legal but useless</p>\n", "OwnerUserId": "10120", "Id": "84505", "PostTypeId": "2", "OwnerDisplayName": "ugasoft", "Score": "-1", "CreationDate": "2008-09-17T15:30:01.243", "LastActivityDate": "2008-09-17T15:30:01.243"}, "bq_ids": {"n4140": {"so_84427_1152218_3": {"section_id": 382, "quality": 0.8, "length": 48}, "so_84427_1152218_1": {"section_id": 380, "quality": 1.0, "length": 14}}, "n3337": {"so_84427_1152218_3": {"section_id": 373, "quality": 0.8, "length": 48}, "so_84427_1152218_1": {"section_id": 371, "quality": 1.0, "length": 14}}, "n4659": {"so_84427_1152218_3": {"section_id": 397, "quality": 0.6166666666666667, "length": 37}, "so_84427_1152218_1": {"section_id": 395, "quality": 1.0, "length": 14}}}, "84427": {"CommentCount": "0", "ViewCount": "6714", "OwnerDisplayName": "Adam Rosenfield", "CreationDate": "2008-09-17T15:23:57.250", "LastActivityDate": "2015-05-15T16:45:49.020", "PostTypeId": "1", "AcceptedAnswerId": "84562", "FavoriteCount": "3", "Title": "Is it legal to pass a newly constructed object by reference to a function?", "Id": "84427", "Score": "15", "Body": "<p>Specifically, is the following legal C++?</p>\n<pre>class A{};\n\nvoid foo(A*);\nvoid bar(const A&amp;);\n\nint main(void)\n{\n    foo(&amp;A;());  // 1\n    bar(A());  // 2\n}</pre>\n<p>It appears to work correctly, but that doesn't mean it's necessarily legal.  Is it?</p>\n<p><i>Edit - changed <code>A&amp;</code> to <code>const A&amp;</code></i></p>\n", "Tags": "<c++>", "OwnerUserId": "9530", "AnswerCount": "9"}});