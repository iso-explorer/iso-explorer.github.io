post_cb({"26561413": {"ParentId": "26561296", "CommentCount": "2", "Body": "<p>The standard is talking about the type of the object that a variable represents.<br>\nYou need to access the the scope of the class, not the variable.  </br></p>\n<p>And to access the members of the nested class from <code>U</code>, you need to create a member from that type, there are 2 ways to do that:</p>\n<pre><code>struct U\n{\n    struct A\n    {\n        static int v;\n        int a;\n    } VarNameForA;\n\n    struct B\n    {\n       int b;\n    };\n    B VarNameOfB;\n};\n</code></pre>\n<p>Use the scope operator <code>::</code> to access the types.</p>\n<p>Here is how you do everything you tried:</p>\n<pre><code>U a;\n\ntypedef decltype(a) varType;\ntypedef varType::A  nestedType;\n\nint main()\n{\n    std::cout &lt;&lt; typeid(U::A).hash_code(); \n    struct U::A b;                        \n    U u;\n    u.VarNameForA.a = 5;\n    u.VarNameOfB.b = 6;\n\n    U::A::c = 3;                          \n\n}\n</code></pre>\n<p>For members you use operator <code>dot (.)</code>, for types and statics you need to use the <code>scope ::</code> operator.</p>\n", "OwnerUserId": "536086", "PostTypeId": "2", "Id": "26561413", "Score": "2", "CreationDate": "2014-10-25T10:30:02.027", "LastActivityDate": "2014-10-25T10:30:02.027"}, "26561532": {"ParentId": "26561296", "CommentCount": "6", "Body": "<p>Look further down in [expr.ref] </p>\n<blockquote>\n<p id=\"so_26561296_26561532_0\">(4.4) If E2 is a nested type, the expression E1.E2 is ill-formed. </p>\n</blockquote>\n", "OwnerUserId": "657267", "PostTypeId": "2", "Id": "26561532", "Score": "4", "CreationDate": "2014-10-25T10:45:14.997", "LastActivityDate": "2014-10-25T10:45:14.997"}, "26561501": {"ParentId": "26561296", "LastEditDate": "2014-10-25T11:33:00.473", "CommentCount": "4", "CreationDate": "2014-10-25T10:42:06.720", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "PostTypeId": "2", "Id": "26561501", "Score": "2", "Body": "<p>You try to use <code>a.A</code> as a type specifier. </p>\n<p>The class member access rules (5.2.5) you refer to are valid only for <strong>expressions</strong> not for type specifiers and typenames (5/1:  \"<em>An expression is a sequence of operators and operands that specifies a computation. An expression can result in a value and can cause side effects.</em>\").  </p>\n<p>You have to look rules for <strong>type specifiers</strong> in section 7.1.6 of the standard. There is no use of operator <code>.</code> foreseen there.  The elaborated types (7.1.6.3) use a <code>::</code> to combine components on a typename. </p>\n<p>The <strong><em>clang</em></strong> error message is more explicit than the one you get from your compiler:  \"cannot use dot operator on a type\").   </p>\n<p>By the way, your <code>U</code> is an empty structure (no data) with only definition of nested types.  This is why     <code>a.A.v = 5;</code> is also an error: there is no lvalue here which could be assigned. </p>\n", "LastActivityDate": "2014-10-25T11:33:00.473"}, "bq_ids": {"n4140": {"so_26561296_26561532_0": {"section_id": 6007, "quality": 1.0, "length": 5}, "so_26561296_26561296_0": {"section_id": 6005, "quality": 0.8666666666666667, "length": 39}, "so_26561296_26561296_1": {"section_id": 5861, "quality": 1.0, "length": 9}}, "n3337": {"so_26561296_26561532_0": {"section_id": 5775, "quality": 1.0, "length": 5}, "so_26561296_26561296_0": {"section_id": 5773, "quality": 0.8666666666666667, "length": 39}, "so_26561296_26561296_1": {"section_id": 5631, "quality": 1.0, "length": 9}}, "n4659": {"so_26561296_26561532_0": {"section_id": 7506, "quality": 1.0, "length": 5}, "so_26561296_26561296_0": {"section_id": 7504, "quality": 0.8222222222222222, "length": 37}, "so_26561296_26561296_1": {"section_id": 7340, "quality": 1.0, "length": 9}}}, "26561296": {"CommentCount": "0", "AcceptedAnswerId": "26561532", "OwnerDisplayName": "user2953119", "CreationDate": "2014-10-25T10:14:07.820", "LastActivityDate": "2014-10-25T11:33:00.473", "PostTypeId": "1", "ViewCount": "1426", "FavoriteCount": "2", "Title": "Why can't we use nested type through class-member-access expression?", "Id": "26561296", "Score": "5", "Body": "<p>I'm trying to understand why we can't use nested type through class-member-access expression.\nFor instance, we have the following class:</p>\n<pre><code>struct U\n{\n    struct A\n    {\n        static int v;\n        int a;\n    };\n\n    struct B\n    {\n       int b;\n    };\n};\n\nU a;\n\ntypedef a.A T; //'a' does not name a type\n\nint main()\n{\n    std::cout &lt;&lt; typeid(a.A).hash_code(); //invalid use of 'struct U::A'\n    struct a.A b;                         //trying to declare a variable of type U::A\n                                          //error: expected unqualified-id before '.' token\n    a.A b;                                //the same as above\n                                          //error: expected unqualified-id before '.' token\n    a.A.v = 5;                            //error: expected unqualified-id before '.' token\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/c1e74f1e1ec6ce6e\">DEMO</a></strong></p>\n<p>The Standard says:</p>\n<p>Section <code>N3797::5.2.5/2 [expr.ref]</code></p>\n<blockquote>\n<p id=\"so_26561296_26561296_0\">For the first option (dot) the first expression shall have complete\n  class type. For the second option (arrow) the first expression shall\n  have pointer to complete class type. The expression E1-&gt;E2 is\n  converted to the equivalent form (*(E1)).E2; the remainder of 5.2.5\n  will address only the first option (dot).In either case, the\n  <em>id-expression shall name a member of the class or of one of its base classes</em>.</p>\n</blockquote>\n<p>Whereas, section <code>N3797::9.2/1 [class.mem]</code> gives a definition of class member:</p>\n<blockquote>\n<p id=\"so_26561296_26561296_1\">Members of a class are data members, member functions (9.3), nested\n  types, and enumerators.</p>\n</blockquote>\n<p>So I can't see the restriction for such usage of nested type. Why not?</p>\n", "Tags": "<c++><types>", "AnswerCount": "3"}});