post_cb({"48636462": {"ViewCount": "140", "Body": "<p>In C++ (not C), a global <code>const</code> array uses internal linkage for optimization.  If the definition for a global <code>const</code> array goes in a separate <strong>.cpp</strong> file, it will generate an <code>undefined reference</code> linker error. See <a href=\"https://stackoverflow.com/questions/10816410/undefined-reference-to-array-of-constants\">undefined reference to array of constants</a>.</p>\n<p>Thus, for each <strong>.cpp</strong> file to access a same const array, we should use a separate <code>const</code> array, preferably in header file form, as the example below:</p>\n<p><strong>foo.h</strong>:</p>\n<pre><code>const int Arr[10]={1,6,3,5,5,6,8,8,9,20};\n</code></pre>\n<p><strong>foo.cpp</strong>:</p>\n<pre><code>#include \"foo.h\"\n// ...\nmemcmp(Arr, MyArr, 10*sizeof(int));\n</code></pre>\n<p><strong>bar.cpp</strong>:</p>\n<pre><code>#include \"foo.h\"\n// ...\nmemcmp(Arr, MyArr2, 10*sizeof(int));\n</code></pre>\n<p>The question is:<br>\nSince <code>foo.cpp</code> and <code>bar.cpp</code> has its own <code>Arr[]</code>.  Will they be merged (optimized) into one copy?</br></p>\n", "AcceptedAnswerId": "48693960", "Title": "C++ global const array: Is it guaranteed to be merged (optimized) into one copy?", "CreationDate": "2018-02-06T06:05:34.920", "LastActivityDate": "2018-02-09T08:00:32.430", "CommentCount": "13", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-02-06T07:56:00.800", "LastEditorUserId": "6048373", "Id": "48636462", "Score": "2", "OwnerUserId": "4007560", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48636462_48693960_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 5795}, "so_48636462_48693960_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 5795}}, "n3337": {"so_48636462_48693960_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 5568}, "so_48636462_48693960_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 5568}}, "n4659": {"so_48636462_48693960_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 7254}, "so_48636462_48693960_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 7254}}}, "48693960": {"Id": "48693960", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48636462_48693960_0\">In C++ (not C), a global const array uses internal linkage for optimization</p>\n</blockquote>\n<p>\"Optimization\" is perhaps not the right word. Default internal linkage\nfor <code>const</code> file-scope objects allows us to define <code>const</code> objects in\nheader files without having to prefix <code>static</code>, or enclose them in an anonymous\nnamespace, to head off multiple-definition linkage errors. This is convenient\nand intuitive. Optimizations may accrue, or not, depending on this and that.</p>\n<p>\"File-scope\" is certainly a better word that \"global\" in this connection. You'll\nsee why in a while.</p>\n<p>And there's nothing special about arrays on this score. <em>All</em> <code>const</code> file-scope\nobjects have internal linkage by default, in C++.</p>\n<p>So maybe your question can be sharpened up as: <em>Does C++ guarantee that distinct file-scope</em> <code>const</code>\n<em>objects in different translation units that have the same name, type and byte-wise\nvalue will be merged to a single copy in a program that they are linked in?</em></p>\n<p>No it doesn't. On the contrary, the C++ Standard <em>probibits</em> distinct objects in a\nprogram (other than object and sub-object) from having the same address:</p>\n<p><strong>C++11 [intro.object], para 6</strong></p>\n<blockquote>\n<p id=\"so_48636462_48693960_1\">Unless an object is a bit-field or a base class subobject of zero size, the address\n  of that object is the address of the first byte it occupies. Two objects that are\n  not bit-fields may have the same address if one is a subobject of the other, or\n  if at least one is a base class subobject of zero size and they are of different types;\n  <strong>otherwise, they shall have distinct addresses</strong><sup>4</sup>.</p>\n</blockquote>\n<p>(emphasis mine). Later standards have words to the same effect.</p>\n<p>There is a crevice of wriggle-room provided by that footnote [4]:</p>\n<blockquote>\n<p id=\"so_48636462_48693960_2\">4) Under the \u201cas-if\u201d rule an implementation is allowed to store two objects at\n  the same machine address or not store an\n  object at all if the program cannot observe the difference.</p>\n</blockquote>\n<p>But if distinct objects are distinguishable in a program, then they <em>must not</em>\nhave the same address - which they would do, were they merged.</p>\n<p>And even if the Standard did not make this stipulation, the merging of identical\nfile-scope <code>const</code> objects from different translation units would be unfeasible anyway.\nConsider:</p>\n<p><strong>array.h</strong></p>\n<pre><code>#ifndef ARRAY_H\n#define ARRAY_H\n\nconst int Arr[10]={1,6,3,5,5,6,8,8,9,20};\n\n#endif\n</code></pre>\n<p><strong>foo.cpp</strong></p>\n<pre><code>#include \"array.h\"\n#include &lt;iostream&gt;\n\nvoid foo()\n{\n    std::cout &lt;&lt; \"Address of `Arr` in `foo.cpp` = \" &lt;&lt; Arr &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>bar.cpp</strong></p>\n<pre><code>#include \"array.h\"\n#include &lt;iostream&gt;\n\nvoid bar()\n{\n    std::cout &lt;&lt; \"Address of `Arr` in `bar.cpp` = \" &lt;&lt; Arr &lt;&lt; std::endl;\n</code></pre>\n<p>}</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>extern void foo();\nextern void bar();\n\nint main()\n{\n    foo();\n    bar();\n    return 0;\n}\n</code></pre>\n<p>Compile all those source files to object files:</p>\n<pre><code>g++ -Wall -c foo.cpp bar.cpp main.cpp\n</code></pre>\n<p>The compiler encountered a</p>\n<pre><code>const int Arr[10]={1,6,3,5,5,6,8,8,9,20};\n</code></pre>\n<p>in compiling <code>foo.cpp</code> to <code>foo.o</code> and accordingly defined an object\nin <code>foo.o</code>:</p>\n<pre><code>$ readelf -s foo.o | grep Arr\n     6: 0000000000000000    40 OBJECT  LOCAL  DEFAULT    5 _ZL3Arr\n</code></pre>\n<p><code>_ZL3Arr</code> is the name-mangling of file-scope symbol <code>Arr</code>:</p>\n<pre><code>$ c++filt _ZL3Arr\nArr\n</code></pre>\n<p><code>40</code> is the size of the object in bytes, which is right for 10 4-byte integers.</p>\n<p>The object is <code>LOCAL</code>:</p>\n<ul>\n<li><code>LOCAL</code> = internal linkage = invisible to the linker</li>\n<li><code>GLOBAL</code> = external linkage = visible to the linker</li>\n</ul>\n<p>(That's why \"file-scope\" was a better word than \"global\").</p>\n<p>The object is defined in the linkage section with index <code>5</code> in <code>foo.o</code>. <code>readelf</code> can also tell us what linkage\nsection that is:</p>\n<pre><code>$ readelf -t foo.o\nThere are 15 section headers, starting at offset 0x7e0:\n\nSection Headers:\n  [Nr] Name\n       Type              Address          Offset            Link\n       Size              EntSize          Info              Align\n       Flags\n  [ 0]\n       NULL                   NULL             0000000000000000  0000000000000000  0\n       0000000000000000 0000000000000000  0                 0\n       [0000000000000000]:\n  ...\n  ...\n  [ 5] .rodata\n       PROGBITS               PROGBITS         0000000000000000  00000000000000e0  0\n       0000000000000053 0000000000000000  0                 32\n       [0000000000000002]: ALLOC\n  ...\n  ...\n</code></pre>\n<p>Section 5 is <code>.rodata</code>, that is <em>readonly data</em>. <code>Arr</code> has been put in read-only data\nbecause it's <code>const</code>.</p>\n<p>For the same reasons, the same things are all true of <code>bar.o</code>:</p>\n<pre><code>$ readelf -s bar.o | grep Arr\n     6: 0000000000000000    40 OBJECT  LOCAL  DEFAULT    5 _ZL3Arr\n</code></pre>\n<p>So each of <code>foo.o</code> and <code>bar.o</code> contains its own 40-byte object <code>_ZL3Arr</code>\nthat is <code>LOCAL</code> and read-only. Compilation is all done and\nwe haven't got a program yet. So if the <code>_ZL3Arr</code> in <code>foo.o</code> and the <code>_ZL3Arr</code> in <code>bar.o</code>\nwere going to be merged in the program, they'd have to be merged by the linker.\nAnd even if we wanted it to, or C++ allowed it to, the linker can't do that, because\nthe linker can't see them!</p>\n<p>Let's do the linkage and ask for the linker's mapfile:</p>\n<pre><code>$ g++ -o prog main.o foo.o bar.o -Wl,-Map=prog.map\n</code></pre>\n<p>Mapfile hits for the <em>really</em> global ( = <code>GLOBAL</code>) symbols:</p>\n<pre><code>$ grep -Po 'foo' prog.map | wc -w\n12\n$ grep -Po 'bar' prog.map | wc -w\n10\n$ grep -Po 'main' prog.map | wc -w\n8\n</code></pre>\n<p>Mapfile hits for <code>Arr</code>:</p>\n<pre><code>$ grep -Po 'Arr' prog.map | wc -w\n0\n</code></pre>\n<p>But <code>readelf</code> can see local symbols, and now we've got a program:</p>\n<pre><code>$ readelf -s prog | grep Arr\n    36: 0000000000000b20    40 OBJECT  LOCAL  DEFAULT   16 _ZL3Arr\n    42: 0000000000000b80    40 OBJECT  LOCAL  DEFAULT   16 _ZL3Arr\n</code></pre>\n<p>So <code>prog</code> contains <em>two</em> 40 byte <code>LOCAL</code> objects by the name of <code>_ZL3Arr</code>,\nboth in linkage section 16 of the program, which is...</p>\n<pre><code>$ readelf -t prog\nThere are 29 section headers, starting at offset 0x2ce8:\n\nSection Headers:\n  [Nr] Name\n       Type              Address          Offset            Link\n\n       Size              EntSize          Info              Align\n       Flags\n  ...\n  ...\n  [16] .rodata\n       PROGBITS               PROGBITS         0000000000000b00  0000000000000b00  0\n       00000000000000d1 0000000000000000  0                 32\n       [0000000000000002]: ALLOC\n  ...\n  ...\n</code></pre>\n<p>once again, the read-only data.</p>\n<p><code>readelf</code> also said that the first of those <code>_ZL3Arr</code>s is at program offset <code>0xb20</code>; the second\nis at <code>0xb80</code><sup>1</sup>. So when we finally run the program we should be pleased,\nbut not surprised, to see that:</p>\n<pre><code>$ ./prog\nAddress of `Arr` in `foo.cpp` = 0x55edf0dd6b20\nAddress of `Arr` in `bar.cpp` = 0x55edf0dd6b80\n</code></pre>\n<p>the local <code>Arr</code> referenced by <code>foo()</code> and the one referenced by <code>bar()</code> remain\n0x60 bytes apart, respectively 0xb20 and 0xb80 bytes from the start of the program in memory.</p>\n<p>Evidently you would <em>prefer</em> to have just one <code>Arr</code>, not two, in the program. To\nachieve that you have to compile:</p>\n<pre><code>const int Arr[10]={1,6,3,5,5,6,8,8,9,20};\n</code></pre>\n<p>in just one object file, with <em>external</em> linkage, so the linker can see it there,\nand refer to that one object in all other object files. Like so:</p>\n<p><strong>array.h (revised)</strong></p>\n<pre><code>#ifndef ARRAY_H\n#define ARRAY_H\n\nextern const int Arr[10];\n\n#endif\n</code></pre>\n<p><strong>array.cpp</strong></p>\n<pre><code>#include \"array.h\"\n\nconst int Arr[10]={1,6,3,5,5,6,8,8,9,20};\n</code></pre>\n<p>Other files as before. In <code>array.h</code> we are expressly declaring that <code>Arr</code> has external linkage, and that declaration in seen and honoured by the compiler in <code>array.cpp</code>.</p>\n<p>Compile and link:</p>\n<pre><code>$ g++ -Wall -c main.cpp foo.cpp bar.cpp array.cpp\n$ g++ -o prog main.o foo.o bar.o array.o\n</code></pre>\n<p>What's the <code>Arr</code> count in the program now?</p>\n<pre><code>$ readelf -s prog | grep 'Arr'\n    60: 0000000000000b80    40 OBJECT  GLOBAL DEFAULT   16 Arr\n</code></pre>\n<p>One. Still in the read-only data. But now <code>GLOBAL</code>. And <code>prog</code> agrees\nthat there is only one <code>Arr</code>:</p>\n<pre><code>$ ./prog\nAddress of `Arr` in `foo.cpp` = 0x562a4fb7bb80\nAddress of `Arr` in `bar.cpp` = 0x562a4fb7bb80\n</code></pre>\n<p><hr>\n[1] Some close readers might wonder why we see offsets rather than absolute addresses\nhere. It's because my Ubuntu 17.10 toolchain make PIE executables by default.</hr></p>\n", "LastEditorUserId": "1362568", "LastActivityDate": "2018-02-09T08:00:32.430", "Score": "2", "CreationDate": "2018-02-08T20:10:23.230", "ParentId": "48636462", "CommentCount": "0", "OwnerUserId": "1362568", "LastEditDate": "2018-02-09T08:00:32.430"}});