post_cb({"39068744": {"ParentId": "39068546", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I'll offer a life lesson I've learned, rather than a direct answer, in response to your question:</p>\n<blockquote>\n<p id=\"so_39068546_39068744_0\">If you can formulate, for multiple alternatives, a reasonable argument for why that alternative should be the one mandated by the standard - then you should not assume <strong>any</strong> of them is mandated (even if one of them happens to be).</p>\n</blockquote>\n<p>In the context of tuples - please, please be kind to the people maintaining your code and do not allow the destruction order of tuple elements to potentially mess up the destruction of other elements. That's just evil... imagine the hapless programmer who will need to debug this thing. In fact, that poor soul might be yourself in a few years, when you've already forgotten about your clever trick from back-in-the-day.</p>\n<p>If you absolutely must rely on destruction order, perhaps you should just be using a proper class with the tuple's elements as its data members (which you could write a destructor for, making it clear what needs to happen in what order), or some other arrangement facilitating a more explicit control of the destruction.</p>\n", "OwnerUserId": "1593077", "LastEditorUserId": "1593077", "LastEditDate": "2016-12-30T10:27:03.347", "Id": "39068744", "Score": "52", "CreationDate": "2016-08-21T20:50:07.560", "LastActivityDate": "2016-12-30T10:27:03.347"}, "39068642": {"ParentId": "39068546", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>With Clang 3.4 I get the same destruction order for both <code>std::pair</code> and 2 element <code>std::tuple</code> and with g++ 5.3 I get opposite order which could be mainly due to the recursive implementation of <code>std::tuple</code> in libstd++.</p>\n<p>So, it basically boils down to what I said in the comment, it is implementation defined.</p>\n<p>From the <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66699\">BUG</a> report:</p>\n<p>Comment by Martin Sebor</p>\n<blockquote>\n<p id=\"so_39068546_39068642_0\">Since the layout of std::pair members is fully specified, so is the\n  order of their initialization and destruction.  The output of the test\n  case reflects this order.</p>\n<p id=\"so_39068546_39068642_1\">The order of initialization (and destruction) of std:stuple subobjects\n  is less clearly specified.  At least it's not immediately obvious from\n  my reading of the spec if any particular order is required.</p>\n<p id=\"so_39068546_39068642_2\">The reason why the output for std::tuple with libstdc++ is the reverse\n  of std::pair is because the implementation, which relies on recursive\n  inheritance,  stores and constructs tuple elements in the reverse\n  order: i.e., the base class, which stores the last element, is stored\n  and constructed first, followed by each derived class (each of which\n  stores the last - Nth element).</p>\n</blockquote>\n<p>The quote from standard [section 20.4.1] which the bug reporter is quoting to</p>\n<blockquote>\n<p id=\"so_39068546_39068642_3\">1 This subclause describes the tuple library that provides a tuple\n  type as the class template tuple that can be instantiated with any\n  number of arguments. Each template argument specifies the type of an\n  element in the tuple. Consequently, tuples are heterogeneous,\n  fixed-size collections of values. <strong>An instantiation of tuple with two\n  arguments is similar to an instantiation of pair with the same two\n  arguments</strong>. See 20.3.</p>\n</blockquote>\n<p>Argument against this made in the linked bug is:</p>\n<blockquote>\n<p id=\"so_39068546_39068642_4\">Being described as similar doesn't imply they are identical in every\n  detail.  std::pair and std::tuple are distinct classes with different\n  requirements on each.  If you believe the are required to behave\n  identically in this respect (i.e., have their subobjects defined in\n  the same order) you need to point to the specific wording that\n  guarantees it.</p>\n</blockquote>\n", "OwnerUserId": "434233", "LastEditorUserId": "434233", "LastEditDate": "2016-08-21T21:09:43.973", "Id": "39068642", "Score": "13", "CreationDate": "2016-08-21T20:37:26.360", "LastActivityDate": "2016-08-21T21:09:43.973"}, "bq_ids": {"n4140": {"so_39068546_39068874_0": {"section_id": 4011, "quality": 1.0, "length": 10}, "so_39068546_39068642_3": {"section_id": 4011, "quality": 0.95, "length": 38}}, "n3337": {"so_39068546_39068874_0": {"section_id": 3862, "quality": 1.0, "length": 10}, "so_39068546_39068642_3": {"section_id": 3862, "quality": 0.95, "length": 38}}, "n4659": {"so_39068546_39068874_0": {"section_id": 4918, "quality": 1.0, "length": 10}, "so_39068546_39068642_3": {"section_id": 4918, "quality": 0.95, "length": 38}}}, "39068874": {"ParentId": "39068546", "CommentCount": "0", "Body": "<p>The standard doesn't specify the order of destruction for <code>std::tuple</code>. The fact that \u00a720.4.1/p1 specifies that:</p>\n<blockquote>\n<p id=\"so_39068546_39068874_0\">An instantiation of tuple with two arguments is similar to an\n  instantiation of pair with the same two arguments.</p>\n</blockquote>\n<p><strong>Similar</strong> here is not interpreted as <strong>identical</strong> and consequently it's not implied that <code>std::tuple</code> should have a reverse destruction order of its arguments.</p>\n<p>Given the recursive nature of <code>std::tuple</code> most probable is that the order of destruction is in order with the order of its arguments.</p>\n<p>I also base my assumptions on a bug report for <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66699\">GCC BUG 66699</a> where in the discussion my assumptions above are justified.</p>\n<p><strong>That said, the order of destruction for <code>std::tuple</code> is unspecified.</strong></p>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "39068874", "Score": "33", "CreationDate": "2016-08-21T21:06:55.143", "LastActivityDate": "2016-08-21T21:06:55.143"}, "39068546": {"CommentCount": "4", "AcceptedAnswerId": "39068874", "PostTypeId": "1", "LastEditorUserId": "1491895", "CreationDate": "2016-08-21T20:25:51.667", "LastActivityDate": "2016-12-30T10:27:03.347", "LastEditDate": "2016-08-21T20:42:59.923", "ViewCount": "1986", "FavoriteCount": "1", "Title": "C++ std::tuple order of destruction", "Id": "39068546", "Score": "45", "Body": "<p>Is there a rule which states in which order the members of an std::tuple are destroyed?</p>\n<p>For example if <code>Function1</code> returns an <code>std::tuple&lt;std::unique_ptr&lt;ClassA&gt;, std::unique_ptr&lt;ClassB&gt;&gt;</code> to <code>Function2</code>, then can I be sure that (when the scope of <code>Function2</code> is left) the instance of <code>ClassB</code> referred to by the second member is destroyed before the instance of <code>ClassA</code> referred to by the first member?</p>\n<pre><code>std::tuple&lt; std::unique_ptr&lt; ClassA &gt;, std::unique_ptr&lt; ClassB &gt; &gt; Function1()\n{\n    std::tuple&lt; std::unique_ptr&lt; ClassA &gt;, std::unique_ptr&lt; ClassB &gt; &gt; garbage;\n    get&lt;0&gt;(garbage).reset( /* ... */ );\n    get&lt;1&gt;(garbage).reset( /* ... */ );\n    return garbage;\n}\n\nvoid Function2()\n{\n    auto to_be_destroyed = Function1();\n    // ... do something else\n\n    // to_be_destroyed leaves scope\n    // Is the instance of ClassB destroyed before the instance of ClassA?\n}\n</code></pre>\n", "Tags": "<c++><c++11><std><stdtuple>", "OwnerUserId": "6306782", "AnswerCount": "3"}});