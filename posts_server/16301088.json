post_cb({"bq_ids": {"n4140": {"so_16301088_16301421_0": {"length": 17, "quality": 0.85, "section_id": 6141}, "so_16301088_16301421_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_16301088_16301421_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}, "so_16301088_16301421_0": {"length": 17, "quality": 0.85, "section_id": 5905}}, "n4659": {"so_16301088_16301421_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}, "so_16301088_16301421_0": {"length": 11, "quality": 0.55, "section_id": 7603}}}, "16301088": {"ViewCount": "321", "Body": "<p>Does <code>c99/c++03</code> guarantee that <code>&amp;a+1 &gt; &amp;a</code> is always true?</p>\n<p>for example, there's a (c-like) <code>std::copy</code>, and</p>\n<pre><code>int a = 0 ;\nint b[9] ;\nstd__copy(&amp;a , &amp;a+1 , b) ;\n</code></pre>\n<p>Does this always work?</p>\n", "AcceptedAnswerId": "16301421", "Title": "Will \"&a+1 > &a\" cause an undefined behaviour", "CreationDate": "2013-04-30T13:26:47.037", "Id": "16301088", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-04-30T13:30:41.613", "LastEditorUserId": "16434", "LastActivityDate": "2013-04-30T15:15:36.857", "Score": "17", "OwnerUserId": "1479022", "Tags": "<c++><c><c99><c++03>", "AnswerCount": "2"}, "16301190": {"Id": "16301190", "PostTypeId": "2", "Body": "<p>Yes, that is guaranteed in C++ (don't know about C). The specifics is that a variable of type T is equivalent to an array of a single element of the same type, and you can always obtain a pointer beyond the end of an array.</p>\n", "LastActivityDate": "2013-04-30T13:31:50.120", "Score": "3", "CreationDate": "2013-04-30T13:31:50.120", "ParentId": "16301088", "CommentCount": "4", "OwnerUserId": "36565"}, "16301421": {"Id": "16301421", "PostTypeId": "2", "Body": "<p>Yes, C99 has special wording to say that when working with addresses, any given object <code>a</code> will act like an array of 1 item, so that <code>&amp;a+1</code> is valid (\u00a76.5.6/7):</p>\n<blockquote>\n<p id=\"so_16301088_16301421_0\">For the purposes of these operators, a pointer to an object that is not an element of an\n  array behaves the same as a pointer to the first element of an array of length one with the\n  type of the object as its element type.</p>\n</blockquote>\n<p>Though the section number is different (\u00a76.3.6), C90 gives the same requirement.</p>\n<p>C++ has the same requirement in \u00a75.7/4 (same section number in both C++03 and C++11).</p>\n<p>In C++, you can compare addresses of arbitrary objects (of the same type) using <code>std::less</code>, even when the built in <code>&lt;</code> operator would not yield meaningful results (e.g., two objects that are not parts of the same array) (\u00a720.8.5/7): </p>\n<blockquote>\n<p id=\"so_16301088_16301421_1\">For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>\n</blockquote>\n<p>Also note that although you can form these addresses, and can compare them to the address of the object, you <em>cannot</em> dereference these pointers (well, the compiler probably won't stop you if you try, but the result will be undefined behavior).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-04-30T15:15:36.857", "Score": "17", "CreationDate": "2013-04-30T13:42:00.687", "ParentId": "16301088", "CommentCount": "3", "LastEditDate": "2013-04-30T15:15:36.857", "OwnerUserId": "179910"}});