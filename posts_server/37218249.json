post_cb({"37218249": {"CommentCount": "8", "ViewCount": "387", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2016-05-13T19:46:43.993", "LastActivityDate": "2016-05-15T18:53:43.870", "Title": "Why is this operator= call ambiguous?", "AcceptedAnswerId": "37219591", "LastEditDate": "2016-05-13T20:01:01.580", "Id": "37218249", "Score": "10", "Body": "<p>I was making a thin derived class with a forwarding constructor.  (Bear with me, I must use GCC 4.7.2, which lacks inherited constructors).</p>\n<p>On the first try, I forgot to add the <code>explicit</code> keyword and got an error.  Could someone explain exactly why this particular error occurs?  I'm having trouble figuring out the sequence of events.</p>\n<pre><code>#include &lt;memory&gt;\n\ntemplate&lt;typename T&gt;\nstruct shared_ptr : std::shared_ptr&lt;T&gt;\n{\n  template&lt;typename...Args&gt;\n  /*explicit*/ shared_ptr(Args &amp;&amp;... args)\n    : std::shared_ptr&lt;T&gt;(std::forward&lt;Args&gt;(args)...)\n  {}\n};\n\nstruct A {};\n\nstruct ConvertsToPtr\n{\n  shared_ptr&lt;A&gt; ptr = shared_ptr&lt;A&gt;(new A());\n  operator shared_ptr&lt;A&gt; const &amp;() const { return ptr; }\n};\n\nint main()\n{\n  shared_ptr&lt;A&gt; ptr;\n  ptr = ConvertsToPtr(); // error here\n  return 0;\n}\n</code></pre>\n<p>The error:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:28:23: error: ambiguous overload for \u2018operator=\u2019 in \u2018ptr = ConvertsToPtr()\u2019\ntest.cpp:28:23: note: candidates are:\ntest.cpp:9:8: note: shared_ptr&lt;A&gt;&amp; shared_ptr&lt;A&gt;::operator=(const shared_ptr&lt;A&gt;&amp;)\ntest.cpp:9:8: note: shared_ptr&lt;A&gt;&amp; shared_ptr&lt;A&gt;::operator=(shared_ptr&lt;A&gt;&amp;&amp;)\n</code></pre>\n", "Tags": "<c++><c++11><implicit-conversion><explicit>", "OwnerUserId": "1086786", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37218249_37219591_0": {"section_id": 639, "quality": 0.95, "length": 19}}, "n3337": {"so_37218249_37219591_0": {"section_id": 629, "quality": 0.95, "length": 19}}, "n4659": {"so_37218249_37219591_0": {"section_id": 667, "quality": 0.95, "length": 19}}}, "37219591": {"ParentId": "37218249", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>This is also the case with <code>g++</code> 4.8.4 with the following:\n<br><code>g++ -g -pedantic --std=c++11 -o test main.cpp</code>\n<br> The VS2015 settings are all defaulted.</br></br></p>\n<p>The problem is that the compiler tries to convert a temporary returned by <code>ConvertsToPtr()</code> to a <code>shared_ptr</code> object. When the compiler is used with <code>explicit</code> keyword, then this conversion never occurs using the constructor. However, while examining with <code>gdb</code> it appears that instead it is using the <code>shared_ptr&lt;A&gt; const &amp;()</code> conversion function to match the appropriate Type. This conversion then returns a <code>const shared_ptr &amp;</code> which has no ambiguity when invoking the assignment operator (this is also match the findings of wojciech Frohmberg).</p>\n<p>However, if the <code>explicit</code> is omitted, then an object of <code>shared_ptr</code> is returned. this can be matched either to rvalue version of the assignment operator or the const lvalue version.</p>\n<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">N4296</a>, Table-11, then we have, after the construction with the <code>conversion constructor</code>, a <code>rvalue of shared_ptr</code> object. However the overload resolution finds two matches, which both ranks under <code>Exact Match</code> (the rvalue version is <code>Identity matching</code> while the other is under <code>Qualification matching</code>).</p>\n<p>I did check also on <code>VS2015</code> and like stated in the comments, it works. But using some <code>cout</code> debugging one can see that the <del>const lvalue assignment</del> rvalue is prioritized over the <del>rvalue</del> const lvalue refrence version counterpart. </p>\n<p><strong>EDIT:</strong> I looked a little deeper in the standard and add the modification. the deleted text regarding the results <code>VS2015</code> was wrong, because I didn't define both assignments. When both of assignments were declared it does prefer the rvalue. </p>\n<p>I assume that the VS compiler distinct the <code>Identity</code> from the <code>Qualification</code> matching in ranking. However as I conclude, it is the VS compiler that is buggy. the <code>g++</code> compilers obeys the given standard. However since GCC 5.0 Does work as Visual studio, The possibility of compiler bug is slim, so I would be happy to see another experts insights.</p>\n<p><strong>EDIT</strong>: In 13.3.3.2 one of the draw breakers, after the better ranking I wrote about it, is:</p>\n<blockquote>\n<p id=\"so_37218249_37219591_0\">\u2014 S1 and S2 are reference bindings (8.5.3) and neither refers to an\n  implicit object parameter of a non-static member function declared\n  without a ref-qualifier, and S1 binds an rvalue reference to an rvalue\n  and S2 binds an lvalue reference. </p>\n</blockquote>\n<p>There is an example attached showing that a given rvalue (not rvalue reference) is supposed to match a <code>const int &amp;&amp;</code> over <code>const int &amp;</code>. Therefore I guess, it is safe to assume that it is relevant to our case, even if we have <code>&amp;&amp;</code> type and not <code>const &amp;&amp;</code> type. I guess after all that <code>GCC</code> 4.7,4.8 is buggy after all.</p>\n", "OwnerUserId": "4768463", "LastEditorUserId": "4768463", "LastEditDate": "2016-05-15T18:53:43.870", "Id": "37219591", "Score": "7", "CreationDate": "2016-05-13T21:28:07.997", "LastActivityDate": "2016-05-15T18:53:43.870"}});