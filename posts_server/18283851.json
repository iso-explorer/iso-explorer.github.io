post_cb({"18283933": {"ParentId": "18283851", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Replace <code>X</code> with <code>int</code> and see which of the primary template yield a matching signature:</p>\n<pre><code>template&lt;class X&gt; void foo(X a)\n</code></pre>\n<p>becomes</p>\n<pre><code>template &lt;&gt; void foo&lt;int&gt;(int)\n</code></pre>\n<p>and</p>\n<pre><code>template&lt;class X&gt; void foo(X *a)\n</code></pre>\n<p>becomes</p>\n<pre><code>template&lt;&gt; void foo&lt;int&gt;(int *)\n</code></pre>\n<p>So, it can only be a specialization of the second function. Since the function doesn't specialize the first overload, it is necessary to declare the second primary template before you define a specialization because the specialization can't specialize the first primary template.</p>\n<p>If the template argument is not explicitly specified in the specialization, the relevant primary template is found using the normal argument deduction rules according to 14.8.2.6 [temp.deduct.decl] paragraph 1:</p>\n<blockquote>\n<p id=\"so_18283851_18283933_0\">In a declaration whose declarator-id refers to a specialization of a function template, template argument deduction is performed to identify the specialization to which the declaration refers. Specifically, this is done for explicit instantiations (14.7.2),\n  explicit specializations (14.7.3), and certain friend declarations (14.5.4).</p>\n</blockquote>\n<p>This argument deduction takes the partial ordering of the primary templates into account, i.e., it finds the second primary template. I didn't fall into the trap of reading the paragraph leading up to the limerick but the warning is real: I think you get into trouble if you change the order of the second primary template and the specialization! Beware the mentioned self-immolation warned about.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2013-08-17T01:09:21.440", "Id": "18283933", "Score": "2", "CreationDate": "2013-08-17T00:32:07.673", "LastActivityDate": "2013-08-17T01:09:21.440"}, "18283851": {"CommentCount": "2", "ViewCount": "150", "PostTypeId": "1", "LastEditorUserId": "909253", "CreationDate": "2013-08-17T00:19:34.460", "LastActivityDate": "2013-08-17T01:09:21.440", "Title": "Template specialization in case of multiple base templates in C++", "AcceptedAnswerId": "18283933", "LastEditDate": "2013-08-17T00:32:17.363", "Id": "18283851", "Score": "4", "Body": "<p>I have two template functions:</p>\n<pre><code>template&lt;class X&gt; void foo(X a)\n{\n    cout &lt;&lt; \"Template 1\" &lt;&lt; endl;\n}\n\n\ntemplate&lt;class X&gt; void foo(X *a)\n{\n    cout &lt;&lt; \"Template 2\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Now, if I define a specialization such as:</p>\n<pre><code>template&lt;&gt; void foo&lt;&gt;(int *a)\n{\n    cout &lt;&lt; \"Specialization 1\" &lt;&lt; endl;\n}\n</code></pre>\n<p>will this specialization belong to template 1 or template 2. Also, does it matter, if I define the specialization before or after template 2?</p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "909253", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18283851_18283933_0": {"section_id": 353, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_18283851_18283933_0": {"section_id": 343, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_18283851_18283933_0": {"section_id": 363, "quality": 0.8888888888888888, "length": 24}}}});