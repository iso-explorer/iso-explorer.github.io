post_cb({"bq_ids": {"n4140": {"so_38798791_38798823_0": {"length": 4, "quality": 1.0, "section_id": 6773}, "so_38798791_38799236_1": {"length": 11, "quality": 0.6875, "section_id": 3875}, "so_38798791_38798823_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6774}, "so_38798791_38798823_3": {"length": 6, "quality": 0.75, "section_id": 6774}, "so_38798791_38798823_2": {"length": 5, "quality": 1.0, "section_id": 6732}}, "n3337": {"so_38798791_38798823_0": {"length": 4, "quality": 1.0, "section_id": 6528}, "so_38798791_38798823_3": {"length": 6, "quality": 0.75, "section_id": 6529}, "so_38798791_38799236_1": {"length": 11, "quality": 0.6875, "section_id": 3735}, "so_38798791_38798823_2": {"length": 5, "quality": 1.0, "section_id": 6487}, "so_38798791_38798823_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6529}}, "n4659": {"so_38798791_38798823_0": {"length": 4, "quality": 1.0, "section_id": 8267}}}, "38798791": {"ViewCount": "586", "Body": "<p>Doing some optimziation on a piece of code, the correctness of the code depending on how the compiler handle NaNs.</p>\n<p>I read the IEEE-754 rules on NaN, which states:</p>\n<blockquote>\n<p id=\"so_38798791_38798791_0\">The comparisons EQ, GT, GE, LT, and LE, when either or both operands\n  is NaN returns FALSE.</p>\n<p id=\"so_38798791_38798791_1\">The comparison NE, when either or both operands is NaN returns TRUE.</p>\n</blockquote>\n<p>Are the above rules enforced in C/C++?</p>\n", "AcceptedAnswerId": "38798823", "Title": "NaN comparison rule in C/C++", "CreationDate": "2016-08-05T22:56:11.400", "Id": "38798791", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-08-05T23:56:05.513", "Score": "5", "OwnerUserId": "2188453", "Tags": "<c++><c><nan>", "AnswerCount": "2"}, "38798823": {"Id": "38798823", "PostTypeId": "2", "Body": "<p>C/C++ does not require specific floating-point representation and does not require that any comparison against <code>NaN</code> is <code>false</code>.</p>\n<p>In C++ you can check if all floating-point types fulfill IEEE 754 using <code>std::numeric_limits::is_iec559</code>:</p>\n<blockquote>\n<p id=\"so_38798791_38798823_0\"><code>static constexpr bool is_iec559;</code></p>\n<p id=\"so_38798791_38798823_1\"><sup>56</sup> True if and only if the type adheres to IEC 559 standard.<sup>217</sup></p>\n<p id=\"so_38798791_38798823_2\"><sup>57</sup> Meaningful for all floating point types.</p>\n<hr>\n<p id=\"so_38798791_38798823_3\">217) International Electrotechnical Commission standard 559 is the same as IEEE 754.</p>\n</hr></blockquote>\n<p>For other floating-point representations comparison against <code>NaN</code> \nmay or may not behave the same way.</p>\n<p>In fact, even representing <code>NaN</code> itself is not required. See <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/has_quiet_NaN\" rel=\"nofollow\"><code>std::numeric_limits&lt;T&gt;::has_quiet_NaN</code></a>, \n<a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/has_signaling_NaN\" rel=\"nofollow\"><code>std::numeric_limits&lt;T&gt;::has_signaling_NaN</code></a>.</p>\n", "LastEditorUserId": "1277769", "LastActivityDate": "2016-08-05T23:36:17.310", "Score": "5", "CreationDate": "2016-08-05T22:59:31.877", "ParentId": "38798791", "CommentCount": "7", "OwnerUserId": "3246555", "LastEditDate": "2016-08-05T23:36:17.310"}, "38799236": {"Id": "38799236", "PostTypeId": "2", "Body": "<p>The <code>==</code> and <code>!=</code> operators appear to <em>not</em> be constrained to the <code>IEEE 754</code> behavior for <code>NaN</code>s, as pointed out in @AlexD's answer already.</p>\n<p>However, the <code>&lt;math.h&gt;</code> comparison macros <em>are</em> required to follow <code>NaN</code> rules equivalent to <code>IEEE 754</code>'s. The following from the <code>C11</code> draft N1580 under 7.12.14 <em>Comparison Macros</em> states that the <code>&lt;math.h&gt;</code> comparison macros <em>are</em> required to ensure that, if either or both of <code>x, y</code> are <code>NaN</code>s then:</p>\n<ul>\n<li><p><code>isunordered(x, y)</code> is <code>true</code></p></li>\n<li><p><code>isgreater(x, y)</code>, <code>isgreaterequal(x, y)</code>, <code>isless(x, y)</code>, <code>islessequal(x, y)</code> are all <code>false</code></p></li>\n</ul>\n<blockquote>\n<p id=\"so_38798791_38799236_0\">The  relational  and  equality  operators  support  the  usual  mathematical  relationships between  numeric  values.  For  any <strong>ordered</strong> pair  of  numeric  values  exactly  one  of  the relationships - <code>less</code>, <code>greater</code>, and <code>equal</code> - is true.  Relational operators may raise the \"invalid\" floating-point  exception  when  argument  values  are  <code>NaN</code>s. <strong>For a <code>NaN</code>  and  a numeric value, or for two <code>NaN</code>s, just the unordered relationship is true</strong>.</p>\n</blockquote>\n<p>The <code>C++</code> standard simply defers to the <code>C</code> one on <code>&lt;math.h&gt;</code> matters:</p>\n<blockquote>\n<p id=\"so_38798791_38799236_1\">The classi\ufb01cation/comparison functions behave the same as the C macros with the corresponding names\n  de\ufb01ned in 7.12.3, Classi\ufb01cation macros, and 7.12.14, Comparison macros in the C Standard.</p>\n</blockquote>\n", "LastActivityDate": "2016-08-05T23:56:05.513", "CommentCount": "0", "CreationDate": "2016-08-05T23:56:05.513", "ParentId": "38798791", "Score": "3", "OwnerUserId": "5538420"}});