post_cb({"43793824": {"CommentCount": "0", "ViewCount": "213", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-05-04T22:37:45.720", "LastActivityDate": "2017-05-05T13:42:38.567", "Title": "Inheritance and is_detected_v provides a strange result (C++17)", "AcceptedAnswerId": "43793983", "LastEditDate": "2017-05-04T23:00:18.087", "Id": "43793824", "Score": "5", "Body": "<p>I have simplified version of code:</p>\n<pre><code>#include &lt;experimental/type_traits&gt;\n\ntemplate&lt;class T&gt; using has_data_t = decltype(T::data());\n\ntemplate &lt;class B&gt; constexpr auto get_data() {\n    return std::experimental::is_detected_v&lt;has_data_t, B&gt;;\n}\n\ntemplate &lt;typename Topt&gt; struct opt_base {\n    static constexpr bool i = get_data&lt;Topt&gt;();\n  //static constexpr auto j = get_data&lt;Topt&gt;(); // fail to compile\n};\n\nstruct opt : public opt_base&lt;opt&gt; {\n    static int data() { return 7;}\n};\n\nint main() {\n    static_assert(std::experimental::is_detected_v&lt;has_data_t, opt&gt;);\n}\n</code></pre>\n<p>This code compiles. But if you will uncomment commented line then assert fails. It was tested with GCC 7.1 and Clang 4.0.0. Compilation parameters: -std=c++1z -O3 -Wall. \n<a href=\"https://godbolt.org/g/4RuSdS\" rel=\"nofollow noreferrer\">Demo</a></p>\n", "Tags": "<c++><templates><c++1z>", "OwnerUserId": "7965722", "AnswerCount": "1"}, "43793983": {"ParentId": "43793824", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In this code:</p>\n<pre><code>static constexpr bool i = get_data&lt;Topt&gt;();\nstatic constexpr auto j = get_data&lt;Topt&gt;();\n</code></pre>\n<p><code>Topt</code> (that is, <code>opt</code>) isn't complete yet. So <code>is_detected_v&lt;has_data_t, opt&gt;</code> is should be <code>false</code>. But by the time we get to <code>main</code>, <code>opt</code> <em>is</em> complete. And so we'd expect <code>is_detected_v&lt;has_data_t, opt&gt;</code> to be <code>true</code>.</p>\n<p>Having a template that when instantiated in different contexts yields different results means that your program is ill-formed, no diagnostic required. See [temp.point]:</p>\n<blockquote>\n<p id=\"so_43793824_43793983_0\">A specialization for any template may have points of instantiation in multiple translation units. If two different points of instantiation give a template specialization different meanings according to the one-definition rule, the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>The addition of <code>j</code> doesn't really matter - it just happened to flip the switch that changed the order of the way the compiler chose to instantiate things. The program is ill-formed regardless of the presence of <code>j</code>. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-05-05T13:42:38.567", "Id": "43793983", "Score": "7", "CreationDate": "2017-05-04T22:57:23.107", "LastActivityDate": "2017-05-05T13:42:38.567"}, "bq_ids": {"n4140": {"so_43793824_43793983_0": {"section_id": 223, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_43793824_43793983_0": {"section_id": 216, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_43793824_43793983_0": {"section_id": 231, "quality": 1.0, "length": 24}}}});