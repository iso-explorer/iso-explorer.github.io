post_cb({"15977984": {"Id": "15977984", "PostTypeId": "2", "Body": "<p>if you want to vhave a pack of arguments as template you cannot write this in a way you already did:</p>\n<pre><code>template &lt;typename...Args, typename Func&gt;\nvoid call(const char *name, Args...args, Func f)\n{\n        f(3);\n}\n</code></pre>\n<p>But you can pack them in a <code>std::tuple</code>:</p>\n<pre><code>template &lt;typename...Args, typename Func&gt;\nvoid call(const char *name, std::tuple&lt;Args...&gt; args, Func f)\n{\n        f(3);\n}\n\ncall(\"test\", std::forward_as_tuple(1, 2, 3), [=](int i) { std::cout&lt;&lt; i; });\n</code></pre>\n", "LastActivityDate": "2013-04-12T18:03:24.260", "CommentCount": "0", "CreationDate": "2013-04-12T18:03:24.260", "ParentId": "15977656", "Score": "0", "OwnerUserId": "1141471"}, "bq_ids": {"n4140": {"so_15977656_15977854_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 64}}, "n3337": {"so_15977656_15977854_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 59}}, "n4659": {"so_15977656_15977854_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 66}}}, "15977656": {"ViewCount": "471", "Body": "<p>I have the following template function:</p>\n<pre><code>template &lt;typename...Args, typename Func&gt;\nvoid call(const char *name, Args...args, Func f)\n{\n        f(3);\n}\n</code></pre>\n<p>When I try to use it, like</p>\n<pre><code>    call(\"test\", 1, 2, 3, [=](int i) { std::cout&lt;&lt; i; });\n</code></pre>\n<p>The compiler complains that it cannot infer the template argument <code>Func</code>.\nHow can this problem be solved, knowing that <code>args</code> can be any type except a function pointer.</p>\n", "AcceptedAnswerId": "15977771", "Title": "How can a template argument after variardic arguments be inferred?", "CreationDate": "2013-04-12T17:43:44.577", "Id": "15977656", "CommentCount": "3", "LastEditDate": "2016-05-18T15:51:25.923", "PostTypeId": "1", "LastEditorUserId": "1774667", "LastActivityDate": "2016-05-18T15:51:25.923", "Score": "3", "OwnerUserId": "52568", "Tags": "<c++><templates><c++11><variadic>", "AnswerCount": "3"}, "15977854": {"Id": "15977854", "PostTypeId": "2", "Body": "<p>From 14.1p11:</p>\n<blockquote>\n<p id=\"so_15977656_15977854_0\">A template parameter pack of a function template shall not be followed\n  by another template parameter unless that template parameter can be deduced from the parameter-type-list\n  of the function template or has a default argument (14.8.2).</p>\n</blockquote>\n<p>If you want to keep the callable as the last argument, you can use <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple\" rel=\"noreferrer\"><code>forward_as_tuple</code></a>:</p>\n<pre><code>template &lt;typename...Args, typename Func&gt;\nvoid call(const char *name, std::tuple&lt;Args...&gt; args, Func f)\n{\n        f(3);\n}\n\ncall(\"test\", std::forward_as_tuple(1, 2, 3), [=](int i) { std::cout&lt;&lt; i; });\n</code></pre>\n<p>We can actually do better by synthesizing the <code>tuple</code> to contain the callable as well:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt;typename... Args_F&gt;\nvoid call_impl(const char *name, std::tuple&lt;Args_F... &amp;&amp;&gt; args_f) {\n   auto &amp;&amp;f = std::get&lt;sizeof...(Args_F) - 1&gt;(args_f);\n   f(3);\n}\n\ntemplate&lt;typename...ArgsF&gt;\nvoid call(const char *name, ArgsF &amp;&amp;...args_f) {\n   call_impl(name, std::tuple&lt;ArgsF &amp;&amp;...&gt;(std::forward&lt;ArgsF&gt;(args_f)...));\n}\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2013-04-12T18:16:09.350", "Score": "8", "CreationDate": "2013-04-12T17:54:54.483", "ParentId": "15977656", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2013-04-12T18:16:09.350"}, "15977771": {"Id": "15977771", "PostTypeId": "2", "Body": "<p>Write <code>get_last</code>, which extracts the last element of a parameter pack.</p>\n<p>Call it <code>f</code>.  Call <code>f</code>.</p>\n<p>As an example,</p>\n<pre><code>template&lt;typename T0&gt;\nauto get_last( T0&amp;&amp; t0 )-&gt;decltype(std::forward&lt;T0&gt;(t0))\n{\n  return std::forward&lt;T0&gt;(t0);\n}\ntemplate&lt;typename T0, typename... Ts&gt;\nauto get_last( T0&amp;&amp; t0, Ts&amp;&amp;... ts )-&gt;decltype(get_last(std::forward&lt;Ts&gt;(ts)...))\n{\n  return get_last(std::forward&lt;Ts&gt;(ts)...);\n}\n</code></pre>\n<p>if you don't care about overload resolution, just calling <code>get_last</code> and treating it like a functor might be enough:</p>\n<pre><code>template &lt;typename...Args&gt;\nvoid call(const char *name, Args...&amp;&amp; args)\n{\n    auto&amp;&amp; f = get_last(std::forward&lt;Args&gt;(args)...);\n    f(3);\n}\n</code></pre>\n<p>The next step up would be to do some SFINAE <code>enable_if</code> magic in order to make the <code>call</code> fail to match if you don't pass a valid functor last: however, this is probably overkill.</p>\n<p>To detect if the <code>f(3)</code> will work, a simple traits class:</p>\n<pre><code>// trivial traits class:\ntemplate&lt;typename T&gt;\nstruct is_type:std::true_type {};\n\ntemplate&lt;typename Functor, typename=void&gt;\nstruct can_be_called_with_3:std::false_type {}\n\ntemplate&lt;typename Functor&gt;\nstruct can_be_called_with_3&lt;Functor,\n  typename std::enable_if&lt;\n    std::is_type&lt; decltype(\n      std::declval&lt;Functor&gt;(3)\n    ) &gt;::value\n  &gt;::type\n&gt;:std::true_type {}\n</code></pre>\n<p>which is pretty silly.  A fancier traits class would have to be used if your requirements for the passed in type are more complex (say, you want it to be called with the arguments).</p>\n<p>Then you augment <code>call</code> with:</p>\n<pre><code>template &lt;typename...Args&gt;\nauto call(const char *name, Args...&amp;&amp; args)\n  -&gt; typename std::enable_if&lt;\n       can_be_called_with_3&lt; decltype( get_last(std::forward&lt;Args&gt;(args)... ) ) &gt;::value\n     &gt;::type\n{ /* body unchanged */ }\n</code></pre>\n<p>which is pretty obtuse.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-04-12T18:09:03.643", "Score": "4", "CreationDate": "2013-04-12T17:50:07.663", "ParentId": "15977656", "CommentCount": "11", "OwnerUserId": "1774667", "LastEditDate": "2013-04-12T18:09:03.643"}});