post_cb({"5644982": {"Id": "5644982", "PostTypeId": "2", "Body": "<p>When you call <code>free()</code> for an object allocated with <code>new</code>, its destructor is not called, so in this example you get memory leaks. Also, in this example you must use <code>delete[]</code> because memory is allocated with <code>new[]</code>.</p>\n", "LastActivityDate": "2011-04-13T05:53:53.197", "CommentCount": "2", "CreationDate": "2011-04-13T05:53:53.197", "ParentId": "5644937", "Score": "10", "OwnerUserId": "170842"}, "5646206": {"Id": "5646206", "PostTypeId": "2", "Body": "<p>There are a couple of problems with your code:</p>\n<p>Obviously the first one is the mixing of free/delete</p>\n<p>In C++ code to avoid confusion it is best not to use malloc/free. But if you must then free() can only be used to free pointers created via malloc/calloc/realloc. Pass any other pointer and your program is likely to go boom.</p>\n<p>Adding more context to this problem is that the C++ versions new/delete not only allocate/release memory but initialize/de-initialize the object via the constructor/destructor. The destructor is more obscure as it is used to release resources that were created in the constructor. In your case the constructor allocates memory and the destructor deallocates the memory. But since you are using free none of the destructors would get called (so you have a memory leak (in each cell)).</p>\n<p>The other problem you have is that the compiler generated versions of the copy constructor and assignment operator (these are two of four methods that can be automatically generated by the compiler for each class) do not work well when you have RAW pointers in your class.</p>\n<p>For example:</p>\n<pre><code>{\n  Foo     a;        // a.x = pointer to a dynamically allocated location\n  Foo     b(a);     // b.x = a.x (whoops)\n\n} // Both a and b go out of scope here.\n  // This means b's destructor is called\n  // Followed by a's destructor (now here is where the problem is)\n  // Because b.x = a.x you have now called delete on the same pointer twice.\n</code></pre>\n<p>Double deletion of the same pointer is not allowed.</p>\n<p>What you need to do is look up the <a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">Rule of Three</a> </p>\n<p>But basically when your class contains a RAW pointer you also want to make sure that Copy Constructor/Assignment operator/Destructor are all defined.</p>\n<p>So things to remember when allocating memory:</p>\n<ul>\n<li>new must be matched by a delete.</li>\n<li>new [] must be matched by a delete [].</li>\n<li>free() can only be used on the result of malloc/calloc/realloc</li>\n</ul>\n<p>Once you have mastered those rules:</p>\n<ul>\n<li>Try and never use delete.</li>\n<li>Learn about smart pointers and containers (let them do the work for you).</li>\n</ul>\n<p>If your object contains a RAW pointer (which should be rare because you have learn about smart pointers and containers). You must know the rule of three and how to make sure the compiler generated methods do not make a mess of your object accidentally.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-04-13T08:16:28.700", "Score": "1", "CreationDate": "2011-04-13T08:09:01.617", "ParentId": "5644937", "CommentCount": "0", "OwnerUserId": "14065", "LastEditDate": "2017-05-23T11:52:16.270"}, "5645203": {"Id": "5645203", "PostTypeId": "2", "Body": "<p>Apart from allocating and deallocating memory, the new operator calls the ctor, and the delete operator calls the destructor. The functions malloc and free only allocate and deallocate memory respectively.</p>\n", "LastActivityDate": "2011-04-13T06:21:52.760", "CommentCount": "0", "CreationDate": "2011-04-13T06:21:52.760", "ParentId": "5644937", "Score": "1", "OwnerUserId": "102062"}, "bq_ids": {"n4140": {"so_5644937_5644963_0": {"length": 9, "quality": 0.9, "section_id": 4272}}, "n3337": {"so_5644937_5644963_0": {"length": 9, "quality": 0.9, "section_id": 4113}}, "n4659": {"so_5644937_5644963_0": {"length": 8, "quality": 0.8, "section_id": 5531}}}, "5644948": {"Id": "5644948", "PostTypeId": "2", "Body": "<p>If you allocate an object with new, you <em>must</em> deallocate it with delete. free() frees blocks of memory allocated with malloc et al.</p>\n", "LastActivityDate": "2011-04-13T05:50:15.557", "CommentCount": "1", "CreationDate": "2011-04-13T05:50:15.557", "ParentId": "5644937", "Score": "1", "OwnerUserId": "675502"}, "5646160": {"Id": "5646160", "PostTypeId": "2", "Body": "<p>Calling <code>free</code> with an address that wasn't a return value of <code>malloc</code> or <code>calloc</code> is undefined behavior.  Clearly, in your example, the destructor of <code>Foo</code> will not be called, but that's in some ways the least of your worries.  Literally anything can happen.  (In my development environment at home, I use a debugging <code>operator new</code> and <code>operator delete</code>.  The address returned by <code>operator new</code> is <strong>not</strong> the address returned from a call to <code>malloc</code>, and calling <code>free</code> with it can have all sorts of disagreeable effects, including possibly corrupting the free space arena, causing a later crash.)</p>\n", "LastActivityDate": "2011-04-13T08:05:36.763", "CommentCount": "0", "CreationDate": "2011-04-13T08:05:36.763", "ParentId": "5644937", "Score": "1", "OwnerUserId": "649665"}, "5644937": {"ViewCount": "6758", "Body": "<blockquote>\n<p id=\"so_5644937_5644937_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/240212/what-is-the-difference-between-new-delete-and-malloc-free\">What is the difference between new/delete and malloc/free?</a> </br></p>\n</blockquote>\n<pre><code>class Foo\n   {\n    public:\n     Foo() { x =  new int; } \n     ~Foo() { delete x; }\n    private:\n        int *x;\n   };\n\n  Foo *p = new Foo[10];\n  free ( p );\n</code></pre>\n<p>I am getting confuse with the above code.\nIs there any problem about it?</p>\n", "Title": "Confusing with delete and free function in C++", "CreationDate": "2011-04-13T05:48:30.423", "Id": "5644937", "CommentCount": "3", "LastEditDate": "2017-05-23T11:58:22.093", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-23T11:04:56.950", "Tags": "<c++><destructor><free><delete-operator>", "Score": "0", "OwnerUserId": "704578", "ClosedDate": "2011-04-13T20:18:31.357", "AnswerCount": "6"}, "5644963": {"Id": "5644963", "PostTypeId": "2", "Body": "<p>Yep, there's a huge problem: <code>new</code> (and <code>delete</code>) can be overridden by anyone for any type, and may or may not use <code>malloc</code> as the underlying allocator (really, it <em>probably</em> won't). Meanwhile, \u00a720.4.6/4 of the C++03 standard says:</p>\n<blockquote>\n<p id=\"so_5644937_5644963_0\">The function <code>free()</code> does not attempt to deallocate storage by calling <code>::operator delete()</code>.</p>\n</blockquote>\n<p>Meaning, any <code>new</code> invocation may allocate memory in any fashion, but <code>free()</code> will most likely not deallocate it correctly.</p>\n", "LastActivityDate": "2011-04-13T05:52:55.023", "CommentCount": "0", "CreationDate": "2011-04-13T05:52:55.023", "ParentId": "5644937", "Score": "5", "OwnerUserId": "636019"}});