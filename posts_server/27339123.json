post_cb({"bq_ids": {"n4140": {"so_27339123_27339356_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_27339123_27339356_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_27339123_27339356_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "27339356": {"Id": "27339356", "PostTypeId": "2", "Body": "<p>Your lambda expression named <code>fn3</code> captures the variable <code>p</code>. Only capture-less lambdas define a conversion to a function pointer.</p>\n<p>Quoting N3337, <em>\u00a75.1.2/6</em> <strong>[expr.prim.lambda]</strong></p>\n<blockquote>\n<p id=\"so_27339123_27339356_0\">The closure type for a <em>lambda-expression</em> with <strong>no <em>lambda-capture</em></strong> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Hence, when you attempt to convert the lambda into a function pointer in the call to <code>pthread_create</code> it fails.</p>\n<hr>\n<p>The reason this is disallowed is that there is no way for a function pointer to carry along the state that has been captured by the lambda.</p>\n</hr>", "LastActivityDate": "2014-12-07T03:42:09.140", "CommentCount": "1", "CreationDate": "2014-12-07T03:42:09.140", "ParentId": "27339123", "Score": "2", "OwnerUserId": "241631"}, "27339123": {"ViewCount": "75", "Body": "<p>In the code below, I am having pthread_create call a class function using lambdas (same can be done with a function pointer).  The first two compile ok, but the third gives a compile error that looks like trying to convert a pointer to a class member to a C-type function.  Not sure.</p>\n<pre><code>#include &lt;pthread.h&gt;\n\n\nclass threadtest\n{\nprivate:\n    void* thread1()            { return nullptr; }\n    void* thread2( void* p )   { return p;       }\n\n\npublic:\n    void start();\n};\n\nvoid threadtest::start()\n{\n   pthread_t thd0;\n   auto fn0 = []( void* a_pArg ) -&gt; void* { return static_cast&lt;threadtest*&gt;( a_pArg )-&gt;thread1(); };\n   pthread_create( &amp;thd0, NULL, fn0, (void*)this );\n\n   pthread_t thd1;\n   auto fn1 = []( void* a_pArg ) -&gt; void* { void* p = nullptr; return static_cast&lt;threadtest*&gt;( a_pArg )-&gt;thread2( p ); };\n   pthread_create( &amp;thd1, NULL, fn1, (void*)this );\n\n   pthread_t thd2;\n   void* p;\n   auto fn3 = [p]( void* a_pArg ) -&gt; void* { return static_cast&lt;threadtest*&gt;( a_pArg )-&gt;thread2( p ); };\n   pthread_create( &amp;thd2, NULL, fn3, (void*)this );\n}\n</code></pre>\n<p><strong>Here is the error:</strong></p>\n<pre><code>threadtest.cpp: In member function \u2018void threadtest::start()\u2019:\nthreadtest.cpp:31:50: error: cannot convert \u2018threadtest::start()::__lambda2\u2019 to \u2018void* (*)(void*)\u2019 for argument \u20183\u2019 to \n\u2018int pthread_create(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*)\u2019\npthread_create( &amp;thd2, NULL, fn3, (void*)this );\n</code></pre>\n<p>The compiler version is: gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2</p>\n<p>In my actual code I am not doing the second or 3rd example.  I know there is a race condition on the var coming off of the stack while the thread gets access to it.  I am just curious as to why the compiler throws an error when any var gets captured?  What changes?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "27339356", "Title": "compile error only when passing capture var in labda to pthread_create", "CreationDate": "2014-12-07T03:03:08.373", "Id": "27339123", "CommentCount": "3", "LastEditDate": "2014-12-07T03:43:03.397", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-12-07T03:43:03.397", "Score": "0", "OwnerUserId": "4333389", "Tags": "<c++><c++11>", "AnswerCount": "1"}});