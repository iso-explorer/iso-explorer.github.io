post_cb({"bq_ids": {"n4140": {"so_31581880_31585629_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 3906}, "so_31581880_31585629_2": {"length": 15, "quality": 0.7142857142857143, "section_id": 3906}}, "n3337": {"so_31581880_31585629_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 3766}}, "n4659": {"so_31581880_31585629_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 4792}, "so_31581880_31585629_2": {"length": 15, "quality": 0.7142857142857143, "section_id": 4792}}}, "31581880": {"ViewCount": "1508", "Body": "<p>I tried to overload <code>(c)begin</code>/<code>(c)end</code> functions for a class so as to be able to call C++11 range-based for loop.</p>\n<p>It works in most of the cases, but I don't manage to understand and solve one : </p>\n<pre><code>for (auto const&amp; point : fProjectData-&gt;getPoints()){ ... }\n</code></pre>\n<p>This line returns error:</p>\n<pre><code>Error C2662: 'MyCollection&lt;T&gt;::begin' : cannot convert 'this' pointer from 'const MyCollection' to 'MyCollection&lt;T&gt; &amp;'\n</code></pre>\n<p>because <code>fProjectData</code> is a pointer to const. If I make it non-const, it does work. I don't understand why, considering that <code>cbegin()</code> &amp; <code>cend()</code> are developped with exactness as <code>begin()</code> &amp; <code>end()</code> functions.</p>\n<p>Here are my functions developped (in the header file) in MyCollection: </p>\n<pre><code>/// \\returns the begin iterator\ntypename std::list&lt;T&gt;::iterator begin() {\n    return objects.begin();\n}\n\n/// \\returns the begin const iterator\ntypename std::list&lt;T&gt;::const_iterator cbegin() const {\n    return objects.cbegin();\n}\n\n/// \\returns the end iterator\ntypename std::list&lt;T&gt;::iterator end() {\n    return objects.end();\n}\n\n/// \\returns the end const iterator\ntypename std::list&lt;T&gt;::const_iterator cend() const {\n    return objects.cend();\n}\n</code></pre>\n<p>Any ideas?</p>\n", "AcceptedAnswerId": "31585629", "Title": "Overloading (c)begin/(c)end", "CreationDate": "2015-07-23T08:22:19.173", "Id": "31581880", "CommentCount": "6", "LastEditDate": "2015-07-23T10:13:41.343", "PostTypeId": "1", "LastEditorUserId": "3953764", "LastActivityDate": "2015-07-23T11:30:59.757", "Score": "2", "OwnerUserId": "4850847", "Tags": "<c++><c++11><for-loop><const>", "AnswerCount": "1"}, "31585629": {"Id": "31585629", "PostTypeId": "2", "Body": "<p>A range-based for loop (for a class-type range) looks up for <code>begin</code> and <code>end</code> functions. <code>cbegin</code> and <code>cend</code> are not considered at all:</p>\n<p>\u00a7 6.5.4 [stmt.ranged]/p1 *:</p>\n<blockquote>\n<p id=\"so_31581880_31585629_0\">[...]</p>\n<ul>\n<li><p id=\"so_31581880_31585629_1\">if <code>_RangeT</code> is a class type, the <em>unqualified-ids</em> <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <em>begin-expr</em> and <em>end-expr</em> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;</p></li>\n<li><p id=\"so_31581880_31585629_2\">otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up in the associated namespaces (3.4.2). [ <em>Note</em>: Ordinary unqualified lookup (3.4.1) is not performed. \u2014 <em>end note</em> ]</p></li>\n</ul>\n</blockquote>\n<p>For a <code>const</code>-qualified range the related member functions must be <code>const</code>-qualified as well (or should be callable with a <code>const</code>-qualified instance if the latter option is in use). You'd need to introduce additional overloads:</p>\n<pre><code>typename std::list&lt;T&gt;::iterator begin() {\n    return objects.begin();\n}\n\ntypename std::list&lt;T&gt;::const_iterator begin() const {\n//                                            ~~~~^\n    return objects.begin();\n}\n\ntypename std::list&lt;T&gt;::const_iterator cbegin() const {\n    return begin();\n}\n\ntypename std::list&lt;T&gt;::iterator end() {\n    return objects.end();\n}\n\ntypename std::list&lt;T&gt;::const_iterator end() const {\n//                                          ~~~~^\n    return objects.end();\n}\n\ntypename std::list&lt;T&gt;::const_iterator cend() const {\n    return end();\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a133ee1a552dad69\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n<hr>\n<p><sub><sup>*</sup> the wording comes from C++14, but the differences are unrelated to the problem as it is stated</sub></p>\n</hr>", "LastEditorUserId": "3953764", "LastActivityDate": "2015-07-23T11:30:59.757", "Score": "2", "CreationDate": "2015-07-23T11:09:12.350", "ParentId": "31581880", "CommentCount": "0", "OwnerUserId": "3953764", "LastEditDate": "2015-07-23T11:30:59.757"}});