post_cb({"17548382": {"ParentId": "15278343", "CommentCount": "0", "Body": "<p>I some time ago I came across the same problem and then write a GNU thread-safe-asynchronous-queue template in C++11. I posted in my blog:</p>\n<p><a href=\"http://gnodebian.blogspot.com.es/2013/07/a-thread-safe-asynchronous-queue-in-c11.html\" rel=\"nofollow\">http://gnodebian.blogspot.com.es/2013/07/a-thread-safe-asynchronous-queue-in-c11.html</a></p>\n", "OwnerUserId": "2389678", "PostTypeId": "2", "Id": "17548382", "Score": "3", "CreationDate": "2013-07-09T12:39:36.430", "LastActivityDate": "2013-07-09T12:39:36.430"}, "15278582": {"ParentId": "15278343", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is probably how you should do it:</p>\n<pre><code>void push(std::string&amp;&amp; filename)\n{\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(qMutex);\n\n        q.push(std::move(filename));\n    }\n\n    populatedNotifier.notify_one();\n}\n\nbool try_pop(std::string&amp; filename, std::chrono::milliseconds timeout)\n{\n    std::unique_lock&lt;std::mutex&gt; lock(qMutex);\n\n    if(!populatedNotifier.wait_for(lock, timeout, [this] { return !q.empty(); }))\n        return false;\n\n    filename = std::move(q.front());\n    q.pop();\n\n    return true;    \n}\n</code></pre>\n", "OwnerUserId": "346804", "LastEditorUserId": "346804", "LastEditDate": "2014-10-30T11:35:57.013", "Id": "15278582", "Score": "11", "CreationDate": "2013-03-07T18:08:37.297", "LastActivityDate": "2014-10-30T11:35:57.013"}, "15278617": {"ParentId": "15278343", "CommentCount": "0", "Body": "<p>I would rewrite your dequeue function as:</p>\n<pre><code>std::string FileQueue::dequeue(const std::chrono::milliseconds&amp; timeout)\n{\n    std::unique_lock&lt;std::mutex&gt; lock(qMutex);\n    while(q.empty()) {\n        if (populatedNotifier.wait_for(lock, timeout) == std::cv_status::timeout ) \n           return std::string();\n    }\n    std::string ret = q.front();\n    q.pop();\n    return ret;\n}\n</code></pre>\n<p>It is shorter and does not have duplicate code like your did. Only issue it may wait longer that timeout. To prevent that you would need to remember start time before loop, check for timeout and adjust wait time accordingly. Or specify absolute time on wait condition.</p>\n", "OwnerUserId": "432358", "PostTypeId": "2", "Id": "15278617", "Score": "4", "CreationDate": "2013-03-07T18:10:11.570", "LastActivityDate": "2013-03-07T18:10:11.570"}, "28569768": {"ParentId": "15278343", "CommentCount": "0", "Body": "<p>There is also GLib solution for this case, I did not try it yet, but I believe it is a good solution.\n<a href=\"https://developer.gnome.org/glib/2.36/glib-Asynchronous-Queues.html#g-async-queue-new\" rel=\"nofollow\">https://developer.gnome.org/glib/2.36/glib-Asynchronous-Queues.html#g-async-queue-new</a></p>\n", "OwnerUserId": "1102681", "PostTypeId": "2", "Id": "28569768", "Score": "1", "CreationDate": "2015-02-17T19:40:57.303", "LastActivityDate": "2015-02-17T19:40:57.303"}, "15278343": {"CommentCount": "7", "AcceptedAnswerId": "15278455", "PostTypeId": "1", "LastEditorUserId": "713961", "CreationDate": "2013-03-07T17:56:22.413", "LastActivityDate": "2017-01-24T10:09:47.223", "LastEditDate": "2016-12-14T21:49:16.497", "ViewCount": "61319", "FavoriteCount": "20", "Title": "C++11 thread-safe queue", "Id": "15278343", "Score": "35", "Body": "<p>A project I'm working on uses multiple threads to do work on a collection of files. Each thread can add files to the list of files to be processed, so I put together (what I thought was) a thread-safe queue. Relevant portions follow:</p>\n<pre><code>// qMutex is a std::mutex intended to guard the queue\n// populatedNotifier is a std::condition_variable intended to\n//                   notify waiting threads of a new item in the queue\n\nvoid FileQueue::enqueue(std::string&amp;&amp; filename)\n{\n    std::lock_guard&lt;std::mutex&gt; lock(qMutex);\n    q.push(std::move(filename));\n\n    // Notify anyone waiting for additional files that more have arrived\n    populatedNotifier.notify_one();\n}\n\nstd::string FileQueue::dequeue(const std::chrono::milliseconds&amp; timeout)\n{\n    std::unique_lock&lt;std::mutex&gt; lock(qMutex);\n    if (q.empty()) {\n        if (populatedNotifier.wait_for(lock, timeout) == std::cv_status::no_timeout) {\n            std::string ret = q.front();\n            q.pop();\n            return ret;\n        }\n        else {\n            return std::string();\n        }\n    }\n    else {\n        std::string ret = q.front();\n        q.pop();\n        return ret;\n    }\n}\n</code></pre>\n<p>However, I am occasionally segfaulting inside the <code>if (...wait_for(lock, timeout) == std::cv_status::no_timeout) { }</code> block, and inspection in gdb indicates that the segfaults are occurring because the queue is empty. How is this possible? It was my understanding that <code>wait_for</code> only returns <code>cv_status::no_timeout</code> when it has been notified, and this should only happen after <code>FileQueue::enqueue</code> has just pushed a new item to the queue.</p>\n", "Tags": "<c++><multithreading><c++11><queue><condition-variable>", "OwnerUserId": "713961", "AnswerCount": "7"}, "23770027": {"ParentId": "15278343", "CommentCount": "1", "Body": "<p>Adding to the accepted answer, I would say that implementing a correct multi producers / multi consumers queue is difficult (easier since C++11, though)</p>\n<p>I would suggest you to try the (very good) <a href=\"http://www.boost.org/doc/libs/1_55_0/doc/html/lockfree.html\">lock free boost library</a>, the \"queue\" structure will do what you want, with wait-free/lock-free guarantees and <a href=\"http://www.boost.org/doc/libs/1_55_0/doc/html/lockfree/appendices.html#lockfree.appendices.supported_platforms___compilers\">without the need for a C++11 compiler</a>.</p>\n<p>I am adding this answer now because the lock-free library is quite new to boost (since 1.53 I believe)</p>\n", "OwnerUserId": "3510483", "PostTypeId": "2", "Id": "23770027", "Score": "7", "CreationDate": "2014-05-20T21:09:36.017", "LastActivityDate": "2014-05-20T21:09:36.017"}, "15278455": {"ParentId": "15278343", "CommentCount": "5", "Body": "<p>According to the standard <code>condition_variables</code> are allowed to wakeup spuriously, even if the event hasn't occured. In case of a spurious wakeup it will return <code>cv_status::no_timeout</code> (since it woke up instead of timing out), even though it hasn't been notified. The correct solution for this is of course to check if the wakeup was actually legit before proceding.</p>\n<p>The details are specified in the standard \u00a730.5.1 [thread.condition.condvar]:</p>\n<blockquote>\n<p id=\"so_15278343_15278455_0\">\u2014The function will unblock when signaled by a call to notify_one(), a call to notify_all(), expiration of the absolute timeout (30.2.4) speci\ufb01ed by abs_time, or spuriously. </p>\n<p id=\"so_15278343_15278455_1\">... </p>\n<p id=\"so_15278343_15278455_2\"><strong>Returns:</strong> cv_status::timeout if the absolute timeout (30.2.4) speci\ufb01edby abs_time expired, other-ise cv_status::no_timeout.</p>\n</blockquote>\n", "OwnerUserId": "201270", "PostTypeId": "2", "Id": "15278455", "Score": "23", "CreationDate": "2013-03-07T18:01:33.463", "LastActivityDate": "2013-03-07T18:01:33.463"}, "bq_ids": {"n4140": {"so_15278343_15278455_0": {"section_id": 3006, "quality": 0.8235294117647058, "length": 14}, "so_15278343_15278455_2": {"section_id": 3009, "quality": 0.6, "length": 6}}, "n3337": {"so_15278343_15278455_0": {"section_id": 2876, "quality": 0.8235294117647058, "length": 14}, "so_15278343_15278455_2": {"section_id": 2878, "quality": 0.6, "length": 6}}, "n4659": {"so_15278343_15278455_0": {"section_id": 3765, "quality": 0.8235294117647058, "length": 14}, "so_15278343_15278455_2": {"section_id": 3768, "quality": 0.6, "length": 6}}}, "16075550": {"ParentId": "15278343", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Just looking at it, when you check a condition variable it is best to use a while loop (so that if it get wakes up and is still not invalid you check again).  I just wrote a template for an async queue, hope this helps.</p>\n<pre><code>#ifndef SAFE_QUEUE\n#define SAFE_QUEUE\n\n#include &lt;queue&gt;\n#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n\n// A threadsafe-queue.\ntemplate &lt;class T&gt;\nclass SafeQueue\n{\npublic:\n  SafeQueue(void)\n    : q()\n    , m()\n    , c()\n  {}\n\n  ~SafeQueue(void)\n  {}\n\n  // Add an element to the queue.\n  void enqueue(T t)\n  {\n    std::lock_guard&lt;std::mutex&gt; lock(m);\n    q.push(t);\n    c.notify_one();\n  }\n\n  // Get the \"front\"-element.\n  // If the queue is empty, wait till a element is avaiable.\n  T dequeue(void)\n  {\n    std::unique_lock&lt;std::mutex&gt; lock(m);\n    while(q.empty())\n    {\n      // release lock as long as the wait and reaquire it afterwards.\n      c.wait(lock);\n    }\n    T val = q.front();\n    q.pop();\n    return val;\n  }\n\nprivate:\n  std::queue&lt;T&gt; q;\n  mutable std::mutex m;\n  std::condition_variable c;\n};\n#endif\n</code></pre>\n", "OwnerUserId": "1174799", "LastEditorUserId": "4870255", "LastEditDate": "2017-01-24T10:09:47.223", "Id": "16075550", "Score": "26", "CreationDate": "2013-04-18T06:00:48.270", "LastActivityDate": "2017-01-24T10:09:47.223"}});