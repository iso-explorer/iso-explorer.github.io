post_cb({"bq_ids": {"n4140": {"so_3233078_3233081_1": {"length": 22, "quality": 1.0, "section_id": 3376}, "so_3233078_3233081_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 3376}, "so_3233078_3233081_0": {"length": 7, "quality": 1.0, "section_id": 3376}, "so_3233078_3233081_3": {"length": 13, "quality": 1.0, "section_id": 404}, "so_3233078_3233078_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3367}}, "n3337": {"so_3233078_3233081_1": {"length": 22, "quality": 1.0, "section_id": 3246}, "so_3233078_3233081_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 3246}, "so_3233078_3233081_0": {"length": 7, "quality": 1.0, "section_id": 3246}, "so_3233078_3233081_3": {"length": 13, "quality": 1.0, "section_id": 395}, "so_3233078_3233078_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3237}}, "n4659": {"so_3233078_3233081_3": {"length": 13, "quality": 1.0, "section_id": 422}, "so_3233078_3233081_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 134}, "so_3233078_3233078_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 4132}}}, "3233078": {"ViewCount": "4262", "Body": "<p>The C++ Standard states the following about virtual functions that have exception specifications:</p>\n<blockquote>\n<p id=\"so_3233078_3233078_0\">If a virtual function has an <em>exception-specification</em>, all declarations, including the definition, of any function that overrides that virtual function in any derived class shall only allow exceptions that are allowed by the <em>exception-specification</em> of the base class virtual function (C++03 \u00a715.4/3).</p>\n</blockquote>\n<p>Thus, the following is ill-formed:</p>\n<pre><code>struct B {\n    virtual void f() throw() { } // allows no exceptions\n};\nstruct D : B {\n    virtual void f() { }         // allows all exceptions\n};\n</code></pre>\n<p>(1)  Does this rule apply to destructors?  That is, is the following well-formed?  </p>\n<pre><code>struct B {\n    virtual ~B() throw() { }\n};\nstruct D : B {\n    virtual ~D() { }\n};\n</code></pre>\n<p>(2)  How does this rule apply to an implicitly declared destructor?  That is, is the following well-formed?</p>\n<pre><code>struct B {\n    virtual ~B() throw() { }\n};\nstruct D : B { \n    // ~D() implicitly declared\n};\n</code></pre>\n<p>While in the general case one should <a href=\"http://www.gotw.ca/publications/mill22.htm\" rel=\"noreferrer\">never write an exception specification</a>, this question has practical implications because the <code>std::exception</code> destructor is virtual and has an empty exception specification.</p>\n<p>Since it is good practice not to allow an exception to be thrown from a destructor, let's assume for the sake of simplifying any examples that a destructor either allows all exceptions (that is, it has no exception specification) or it allows no exceptions (that is, it has an empty exception specification).</p>\n", "AcceptedAnswerId": "3233081", "Title": "How does an exception specification affect virtual destructor overriding?", "CreationDate": "2010-07-12T23:32:30.727", "Id": "3233078", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2010-07-12T23:33:05.467", "Score": "13", "OwnerUserId": "151292", "Tags": "<c++><exception><exception-handling><destructor><exception-specification>", "AnswerCount": "1"}, "3233081": {"Id": "3233081", "PostTypeId": "2", "Body": "<h3>(1) Does this rule apply to destructors?</h3>\n<p>Yes, this rule applies to destructors (there is no exception to the rule for destructors), so this example is ill-formed.  In order to make it well-formed, the exception specification of <code>~D()</code> must be compatible with that of <code>~B()</code>, e.g.,</p>\n<pre><code>struct B {\n    virtual ~B() throw() { }\n};\nstruct D : B {\n    virtual ~D() throw() { }\n};\n</code></pre>\n<h3>(2) How does this rule apply to implicitly declared special member function?</h3>\n<p>The C++ Standard says the following about implicitly declared special member functions:</p>\n<blockquote>\n<p id=\"so_3233078_3233081_0\">An implicitly declared special member function shall have an exception-specification. </p>\n<p id=\"so_3233078_3233081_1\">If <code>f</code> is an implicitly declared default constructor, copy constructor, destructor, or copy assignment operator, its implicit exception-specification specifies the type-id <code>T</code> if and only if <code>T</code> is allowed by the exception-specification of a function directly invoked by <code>f</code>\u2019s implicit \n  definition; </p>\n<p id=\"so_3233078_3233081_2\"><code>f</code> shall allow all exceptions if any function it directly invokes allows all exceptions, and <code>f</code> shall allow no exceptions if every function it directly invokes allows no exceptions (C++03 \u00a715.4/13).</p>\n</blockquote>\n<p>What functions are directly invoked by an implicitly declared destructor?</p>\n<blockquote>\n<p id=\"so_3233078_3233081_3\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class <code>X</code> calls </p>\n<ul>\n<li>the destructors for <code>X</code>\u2019s direct members, </li>\n<li>the destructors for <code>X</code>\u2019s direct base classes and, </li>\n<li>if <code>X</code> is the type of the most derived class, its destructor calls the destructors for <code>X</code>\u2019s virtual base classes </li>\n</ul>\n<p id=\"so_3233078_3233081_4\">(C++03 \u00a712.4/6; reformatted for easier reading).</p>\n</blockquote>\n<p>So, an implicitly declared destructor has an exception specification that allows any exceptions allowed by any of those destructors.  To consider the example from the question:</p>\n<pre><code>struct B {\n    virtual ~B() throw() { }\n};\nstruct D : B { \n    // ~D() implicitly declared\n};\n</code></pre>\n<p>The only destructor called by the implicitly declared <code>~D()</code> is <code>~B()</code>.  Since <code>~B()</code> allows no exceptions, <code>~D()</code> allows no exceptions and it is as if it were declared <code>virtual ~D() throw()</code>.</p>\n<p>This exception specification is obviously compatible with <code>~B()</code>'s, so this example is well-formed.</p>\n<hr>\n<p>As a practical example of why this matters, consider the following:</p>\n<pre><code>struct my_exception : std::exception {\n    std::string message_;\n};\n</code></pre>\n<p><code>~string()</code> allows all exceptions, so the implicitly declared <code>~my_exception()</code> allows all exceptions.  The base class destructor, <code>~exception()</code>, is virtual and allows no exceptions, so the derived class destructor is incompatible with the base class destructor and this is ill-formed.</p>\n<p>To make this example well-formed, we can explicitly declare the destructor with an empty exception specification:</p>\n<pre><code>struct my_exception : std::exception {\n    virtual ~my_exception() throw() { }\n    std::string message_;\n};\n</code></pre>\n<p>While the rule of thumb is never to write an exception specification, there is at least this one common case where doing so is necessary.</p>\n</hr>", "LastActivityDate": "2010-07-12T23:33:05.467", "CommentCount": "7", "CreationDate": "2010-07-12T23:33:05.467", "ParentId": "3233078", "Score": "12", "OwnerUserId": "151292"}});