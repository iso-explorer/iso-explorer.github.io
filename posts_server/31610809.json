post_cb({"bq_ids": {"n4140": {"so_31610809_31610964_0": {"length": 19, "quality": 1.0, "section_id": 169}}, "n3337": {"so_31610809_31610964_0": {"length": 19, "quality": 1.0, "section_id": 163}}, "n4659": {"so_31610809_31610964_0": {"length": 19, "quality": 1.0, "section_id": 174}}}, "31610809": {"ViewCount": "169", "Body": "<p>I have a struct <code>CRTPBase</code> serving as a base class for curiously recurring template pattern. Its only use is to expose the derived type:</p>\n<pre><code>template&lt;typename Derived&gt;\nstruct CRTPBase {\n    using asdf = Derived;\n};\n</code></pre>\n<p>Now, I use the class as follows:</p>\n<pre><code>struct D : public CRTPBase&lt;D&gt; {\n    static_assert(std::is_same&lt;asdf, D&gt;::value, \"\");\n};\n</code></pre>\n<p>So far, no problem. Now, instead of using a \"normal\" struct, I'd like to use a templated one:</p>\n<pre><code>template&lt;int N&gt;\nstruct DTmpl : public CRTPBase&lt;DTmpl&lt;N&gt;&gt; {\n    // the following compiles under VS2012, but not in clang\n    static_assert(std::is_same&lt;asdf, DTmpl&gt;::value, \"\");\n};\n</code></pre>\n<p>On VS2012, the above compiles fine, but clang needs me to mention that <code>asdf</code> is a type:</p>\n<pre><code>template&lt;int N&gt;\nstruct DTmpl : public CRTPBase&lt;DTmpl&lt;N&gt;&gt; {\n    static_assert(std::is_same&lt;typename CRTPBase&lt;DTmpl&lt;N&gt;&gt;::asdf, DTmpl&gt;::value, \"\");\n};\n</code></pre>\n<p>Now, I introduce another struct <code>Intermediate</code>, whose sole purpose is to \"wrap\" a given base class:</p>\n<pre><code>template&lt;typename Base&gt;\nstruct Intermediate : public Base {};\n</code></pre>\n<p>My intuition was that saying <code>Intermediate&lt;CRTPBase&lt;..&gt;&gt;</code> instead of <code>CRTPBase&lt;..&gt;</code> shall (essentially) make no difference.</p>\n<p>However, both Visual Studio and clang compile the following:</p>\n<pre><code>struct DIntrmd : public Intermediate&lt;CRTPBase&lt;DIntrmd&gt;&gt; {\n    static_assert(std::is_same&lt;asdf, DIntrmd&gt;::value, \"\");\n};\n</code></pre>\n<p>And both Visual Studio and clang reject the following:</p>\n<pre><code>template&lt;int N&gt;\nstruct DTmplIntrmd : public Intermediate&lt;CRTPBase&lt;DTmplIntrmd&lt;N&gt;&gt;&gt; {\n    static_assert(std::is_same&lt;asdf, DTmplIntrmd&gt;::value, \"\");\n};\n</code></pre>\n<p>Again, I have to explicitly state that <code>asdf</code> is a type so that it compiles:</p>\n<pre><code>template&lt;int N&gt;\nstruct DTmplIntrmd : public Intermediate&lt;CRTPBase&lt;DTmplIntrmd&lt;N&gt;&gt;&gt; {\n    static_assert(std::is_same&lt;typename Intermediate&lt;CRTPBase&lt;DTmplIntrmd&lt;N&gt;&gt;&gt;::asdf, DTmplIntrmd&gt;::value, \"\");\n};\n</code></pre>\n<p>So, here's my question: Which is the correct compiler behaviour regarding the situation described?</p>\n", "AcceptedAnswerId": "31610964", "Title": "CRTP derived class seemingly does not know inherited type", "CreationDate": "2015-07-24T12:41:14.957", "Id": "31610809", "CommentCount": "1", "LastEditDate": "2015-09-02T13:44:53.123", "PostTypeId": "1", "LastEditorUserId": "211160", "LastActivityDate": "2015-09-02T13:44:53.123", "Score": "2", "OwnerUserId": "255688", "Tags": "<c++><templates><c++11><crtp>", "AnswerCount": "1"}, "31610964": {"Id": "31610964", "PostTypeId": "2", "Body": "<p>According to [temp.res]</p>\n<blockquote>\n<p id=\"so_31610809_31610964_0\">A name used in a template declaration or definition and that is dependent on a <em>template-parameter</em> is\n  assumed <strong>not to name a type unless</strong> the applicable name lookup finds a type name or the name is qualified\n  by the keyword <code>typename</code>.</p>\n</blockquote>\n<p>So in this example:</p>\n<pre><code>template&lt;int N&gt;\nstruct DTmpl : public CRTPBase&lt;DTmpl&lt;N&gt;&gt; {\n    // the following compiles under VS2012, but not in clang\n    static_assert(std::is_same&lt;asdf, DTmpl&gt;::value, \"\");\n};\n</code></pre>\n<p><code>asdf</code> is a name dependent on a <em>template-parameter</em>, so should be assumed to not name a type since it is not qualified by <code>typename</code>. VS2012 is wrong to compile this code, and clang is correct.</p>\n<p>In every other example in your question, either <code>asdf</code> is not dependent (and both compilers accept the code) or it is dependent (and both compilers reject it). All the other behavior is correct. </p>\n<p>For more, see <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords\">Where and why do I have to put the \"template\" and \"typename\" keywords?</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-24T12:49:07.657", "Score": "3", "CreationDate": "2015-07-24T12:49:07.657", "ParentId": "31610809", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T12:15:47.287"}});