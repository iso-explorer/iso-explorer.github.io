post_cb({"3279280": {"ParentId": "3279220", "CommentCount": "0", "Body": "<p>AFAIK, this cast will never alter the byte, just change its representation.</p>\n", "OwnerUserId": "271725", "PostTypeId": "2", "Id": "3279280", "Score": "0", "CreationDate": "2010-07-19T07:52:21.057", "LastActivityDate": "2010-07-19T07:52:21.057"}, "3279220": {"CommentCount": "2", "ViewCount": "3286", "CreationDate": "2010-07-19T07:42:56.740", "LastActivityDate": "2010-07-20T04:34:02.360", "Title": "Can \"signed char\" and \"unsigned char\" always be cast to each other without loss of data?", "PostTypeId": "1", "Id": "3279220", "Score": "5", "Body": "<p>In C++ we can have <code>signed char</code> and <code>unsigned char</code> that are of same size but hold different ranges of values.</p>\n<p>In the following code:</p>\n<pre><code>signed char signedChar = -10;\nunsigned char unsignedChar = static_cast&lt;unsigned char&gt;( signedChar );\nsignedChar = static_cast&lt;signed char&gt;( unsignedChar );\n</code></pre>\n<p>will <code>signed char</code> retain its value regardless of what its original value was?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "57428", "AnswerCount": "4"}, "3279305": {"ParentId": "3279220", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>No, there's no such guarantee. The conversion from <code>signed char</code> to <code>unsigned char</code> is well-defined, as all signed-to-unsigned integral conversions in C++ (and C) are. However, the result of that conversion can easily turn out to be outside the bounds of the original signed type (will happen in your example with <code>-10</code>). </p>\n<p>The result of the reverse conversion - <code>unsigned char</code> to <code>signed char</code> - in that case is implementation-defined, as all overflowing unsigned-to-signed integral conversions in C++ (and C) are. This means that the result cannot be predicted from the language rules alone.</p>\n<p>Normally, you should expect the implementation to \"define\" it so that the original <code>signed char</code> value is restored. But the language makes no guarantees about that.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2010-07-20T04:34:02.360", "Id": "3279305", "Score": "10", "CreationDate": "2010-07-19T07:58:02.920", "LastActivityDate": "2010-07-20T04:34:02.360"}, "3279260": {"ParentId": "3279220", "CommentCount": "2", "Body": "<p>My first guess would be \"maybe.\"\nHave you tried testing this with various inputs?</p>\n", "OwnerUserId": "158103", "PostTypeId": "2", "Id": "3279260", "Score": "-1", "CreationDate": "2010-07-19T07:48:48.083", "LastActivityDate": "2010-07-19T07:48:48.083"}, "bq_ids": {"n4140": {"so_3279220_3284563_1": {"section_id": 7210, "quality": 0.9469026548672567, "length": 107}}, "n3337": {"so_3279220_3284563_1": {"section_id": 6954, "quality": 0.9469026548672567, "length": 107}}, "n4659": {"so_3279220_3284563_1": {"section_id": 8719, "quality": 0.911504424778761, "length": 103}}}, "3284563": {"ParentId": "3279220", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I guess the meaning of your question is what is key. When you say loss, you mean that you are losing bytes or something like that. You are not losing anything as such since the size of both are the same, they just have different ranges. </p>\n<p>signed char and unsigned char are not guaranteed to be equal. When most people think unsigned char, they are thinking from 0 to 255. </p>\n<p>On most implementations (I have to caveat because there is a difference), signed char and unsigned char are 1 byte or 8 bits. signed char is typically from -128 to +127 whereas unsigned char is from 0 to +255. </p>\n<p>As far as conversions, it is left up to different implementations to come up with an answer. On a whole, I wouldn't recommend you converting between the two. To me, it makes sense that it should give you the POSITIVE equivalent if the value is negative and remain the same if is positive. For instance in Borland C++ Builder 5, given a <code>signed char test = -1</code> and you cast it into <code>unsigned char</code>, the result will be 255. Alternatively, the result is different if all values are positive.  </p>\n<p>But as far as comparisons, while the values may appear the same, they probably won't be evaluated as equal. This is a major trip up when programmers sometimes compare signed and unsigned values and wonder why the data all looks the same, but the condition will not work properly. A good compiler should warn you about this.</p>\n<p>I'm of the opinion that there should be an implicit conversion between the signed and unsigned so that if you cast from one to the other, the compiler will take care of the conversion for you. It is up to the compiler's implementation on whether you lose the original meaning. Unfortunately there is no guarantee that it will always work.</p>\n<p>Finally, from the standard, there should exist a plain conversion between signed char or unsigned char to char. But whichever it chooses to take, is implementation defined</p>\n<blockquote>\n<p id=\"so_3279220_3284563_0\">3.9.1 Fundamental types [basic.fundamental]</p>\n<p id=\"so_3279220_3284563_1\">1 Objects declared as characters char)\n  shall be large enough to store any\n  member of the implementation's basic\n  character set. If a character from\n  this set is stored in a character\n  object, the integral value of that\n  character object is equal to the value\n  of the single character literal form\n  of that character. It is\n  implementation-defined whether a char\n  object can hold negative values.\n  Characters can be explicitly declared\n  unsigned or signed. Plain char, signed\n  char, and unsigned char are three\n  distinct types. A char, a signed char,\n  and an unsigned char occupy the same\n  amount of storage and have the same\n  alignment requirements (basic.types);\n  that is, they have the same object\n  representation. For character types,\n  all bits of the object representation\n  participate in the value\n  representation. For unsigned character\n  types, all possible bit patterns of\n  the value representation represent\n  numbers. These requirements do not\n  hold for other types. <strong>In any\n  particular implementation, a plain\n  char object can take on either the\n  same values as a signed char or an\n  unsigned char; which one is\n  implementation-defined.</strong></p>\n</blockquote>\n", "Id": "3284563", "LastEditDate": "2010-07-19T20:18:56.020", "OwnerDisplayName": "user195488", "Score": "1", "CreationDate": "2010-07-19T20:02:42.130", "LastActivityDate": "2010-07-19T20:18:56.020", "LastEditorDisplayName": "user195488"}});