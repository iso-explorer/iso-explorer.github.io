post_cb({"4984228": {"ParentId": "4810664", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-02-13T12:52:49.123", "Score": "66", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:50.260", "Id": "4984228", "OwnerUserId": "252000", "Body": "<h1>Array creation and initialization</h1>\n<p>As with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; <a href=\"https://stackoverflow.com/questions/1887097/\">C++ does not support VLAs</a>), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).</p>\n<h2>Automatic arrays</h2>\n<p>Automatic arrays (arrays living \"on the stack\") are created each time the flow of control passes through the definition of a non-static local array variable:</p>\n<pre><code>void foo()\n{\n    int automatic_array[8];\n}\n</code></pre>\n<p>Initialization is performed in ascending order. Note that the initial values depend on the element type <code>T</code>:</p>\n<ul>\n<li>If <code>T</code> is a <a href=\"https://stackoverflow.com/questions/146589/\">POD</a> (like <code>int</code> in the above example), no initialization takes place.</li>\n<li>Otherwise, the default-constructor of <code>T</code> initializes all the elements.</li>\n<li>If <code>T</code> provides no accessible default-constructor, the program does not compile.</li>\n</ul>\n<p>Alternatively, the initial values can be explicitly specified in the <em>array initializer</em>, a comma-separated list surrounded by curly brackets:</p>\n<pre><code>    int primes[8] = {2, 3, 5, 7, 11, 13, 17, 19};\n</code></pre>\n<p>Since in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:</p>\n<pre><code>    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19};   // size 8 is deduced\n</code></pre>\n<p>It is also possible to specify the size and provide a shorter array initializer:</p>\n<pre><code>    int fibonacci[50] = {0, 1, 1};   // 47 trailing zeros are deduced\n</code></pre>\n<p>In that case, the remaining elements are <a href=\"https://stackoverflow.com/questions/1613383/\">zero-initialized</a>. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to <em>initialize</em> arrays; they cannot later be used in assignments.</p>\n<h2>Static arrays</h2>\n<p>Static arrays (arrays living \"in the data segment\") are local array variables defined with the <code>static</code> keyword and array variables at namespace scope (\"global variables\"):</p>\n<pre><code>int global_static_array[8];\n\nvoid foo()\n{\n    static int local_static_array[8];\n}\n</code></pre>\n<p>(Note that variables at namespace scope are implicitly static. Adding the <code>static</code> keyword to their definition has a <a href=\"https://stackoverflow.com/questions/3891325/\">completely different, deprecated meaning</a>.)</p>\n<p>Here is how static arrays behave differently from automatic arrays:</p>\n<ul>\n<li>Static arrays without an array initializer are zero-initialized prior to any further potential initialization.</li>\n<li>Static POD arrays are initialized <em>exactly once</em>, and the initial values are <em>typically</em> baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.</li>\n<li>Static non-POD arrays are initialized the <em>first time</em> the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.</li>\n</ul>\n<p>(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)</p>\n<h2>Array data members</h2>\n<p>Array data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the <a href=\"https://stackoverflow.com/questions/1711990/\">member initializer list</a>, so initialization must be faked with assignments:</p>\n<pre><code>class Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo()\n    {\n        primes[0] = 2;\n        primes[1] = 3;\n        primes[2] = 5;\n        // ...\n    }\n};\n</code></pre>\n<p>Alternatively, you can define an automatic array in the constructor body and copy the elements over:</p>\n<pre><code>class Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo()\n    {\n        int local_array[] = {2, 3, 5, 7, 11, 13, 17, 19};\n        std::copy(local_array + 0, local_array + 8, primes + 0);\n    }\n};\n</code></pre>\n<p>In C++0x, arrays <em>can</em> be initialized in the member initializer list thanks to <a href=\"http://www.youtube.com/watch?v=uEqknlxXJfg\" rel=\"nofollow noreferrer\">uniform initialization</a>:</p>\n<pre><code>class Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo() : primes { 2, 3, 5, 7, 11, 13, 17, 19 }\n    {\n    }\n};\n</code></pre>\n<p>This is the only solution that works with element types that have no default constructor.</p>\n<h2>Dynamic arrays</h2>\n<p>Dynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as \"anonymous arrays\" from now on.</p>\n<p>In C, anonymous arrays are created via <code>malloc</code> and friends. In C++, anonymous arrays are created using the <code>new T[size]</code> syntax which returns a pointer to the first element of an anonymous array:</p>\n<pre><code>std::size_t size = compute_size_at_runtime();\nint* p = new int[size];\n</code></pre>\n<p>The following ASCII art depicts the memory layout if the size is computed as 8 at runtime:</p>\n<pre><code>             +---+---+---+---+---+---+---+---+\n(anonymous)  |   |   |   |   |   |   |   |   |\n             +---+---+---+---+---+---+---+---+\n               ^\n               |\n               |\n             +-|-+\n          p: | | |                               int*\n             +---+\n</code></pre>\n<p>Obviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)</p>\n<p>Note that there is <em>no</em> array-to-pointer decay going on here. Although evaluating <code>new int[size]</code> does in fact create an <em>array</em> of integers, the result of the expression <code>new int[size]</code> is <em>already</em> a pointer to a single integer (the first element), <em>not</em> an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)</p>\n<p>Concerning default values for elements, anonymous arrays behave similar to automatic arrays.\nNormally, anonymous POD arrays are not initialized, but there is a <a href=\"https://stackoverflow.com/questions/620137/\">special syntax</a> that triggers value-initialization:</p>\n<pre><code>int* p = new int[some_computed_size]();\n</code></pre>\n<p>(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:</p>\n<pre><code>int* p = new int[8] { 2, 3, 5, 7, 11, 13, 17, 19 };\n</code></pre>\n<p>If you are done using an anonymous array, you have to release it back to the system:</p>\n<pre><code>delete[] p;\n</code></pre>\n<p>You must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form <code>delete</code> (or <code>free</code>) instead of <code>delete[]</code> to release the array is also <a href=\"https://stackoverflow.com/questions/1612031/\">undefined behavior</a>.</p>\n", "LastActivityDate": "2011-02-13T12:52:49.123"}, "7439261": {"ParentId": "4810664", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2011-09-16T01:31:10.727", "Score": "60", "LastEditorUserId": "464581", "LastEditDate": "2015-07-31T00:15:12.717", "Id": "7439261", "OwnerUserId": "464581", "Body": "<h1>5. Common pitfalls when using arrays.</h1>\n<h2>5.1 Pitfall: Trusting type-unsafe linking.</h2>\n<p>OK, you\u2019ve been told, or have found out yourself, that globals (namespace\nscope variables that can be accessed outside the translation unit) are\nEvil\u2122. But did you know how truly Evil\u2122 they are? Consider the\nprogram below, consisting of two files [main.cpp] and [numbers.cpp]:</p>\n<pre><code>// [main.cpp]\n#include &lt;iostream&gt;\n\nextern int* numbers;\n\nint main()\n{\n    using namespace std;\n    for( int i = 0;  i &lt; 42;  ++i )\n    {\n        cout &lt;&lt; (i &gt; 0? \", \" : \"\") &lt;&lt; numbers[i];\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<p></p>\n<pre><code>// [numbers.cpp]\nint numbers[42] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n</code></pre>\n<p>In Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and\nVisual C++ 10.0.</p>\n<p>Since the types don't match, the program crashes when you run it.</p>\n<p><img alt=\"The Windows 7 crash dialog\" src=\"https://i.stack.imgur.com/v7KJF.png\"/></p>\n<p>In-the-formal explanation: the program has Undefined Behavior (UB), and instead\nof crashing it can therefore just hang, or perhaps do nothing, or it\ncan send threating e-mails to the presidents of the USA, Russia, India,\nChina and Switzerland, and make Nasal Daemons fly out of your nose.</p>\n<p>In-practice explanation: in <code>main.cpp</code> the array is treated as a pointer, placed\nat the same address as the array. For 32-bit executable this means that the first\n<code>int</code> value in the array, is treated as a pointer. I.e., in <code>main.cpp</code> the\n<code>numbers</code> variable contains, or appears to contain, <code>(int*)1</code>. This causes the\nprogram to access memory down at very bottom of the address space, which is\nconventionally reserved and trap-causing. Result: you get a crash.</p>\n<p>The compilers are fully within their rights to not diagnose this error,\nbecause C++11 \u00a73.5/10 says, about the requirement of compatible types\nfor the declarations,</p>\n<blockquote>\n<p id=\"so_4810664_7439261_0\"><strong>[N3290 \u00a73.5/10]</strong><br>\n  A violation of this rule on type identity does not require a diagnostic.</br></p>\n</blockquote>\n<p>The same paragraph details the variation that is allowed:</p>\n<blockquote>\n<p id=\"so_4810664_7439261_1\">\u2026 declarations for an array object can specify array types that\n  differ by the presence or absence of a major array bound (8.3.4).</p>\n</blockquote>\n<p>This allowed variation does not include declaring a name as an array in one\ntranslation unit, and as a pointer in another translation unit.    </p>\n<h2>5.2 Pitfall: Doing premature optimization (<code>memset</code> &amp; friends).</h2>\n<p><em>Not written yet</em></p>\n<h2>5.3 Pitfall: Using the C idiom to get number of elements.</h2>\n<p>With deep C experience it\u2019s natural to write \u2026</p>\n<pre><code>#define N_ITEMS( array )   (sizeof( array )/sizeof( array[0] ))\n</code></pre>\n<p>Since an <code>array</code> decays to pointer to first element where needed, the\nexpression <code>sizeof(a)/sizeof(a[0])</code> can also be written as\n<code>sizeof(a)/sizeof(*a)</code>. It means the same, and no matter how it\u2019s\nwritten it is the <strong>C idiom</strong> for finding the number elements of array.</p>\n<p>Main pitfall: the C idiom is not typesafe. For example, the code\n\u2026</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#define N_ITEMS( array ) (sizeof( array )/sizeof( *array ))\n\nvoid display( int const a[7] )\n{\n    int const   n = N_ITEMS( a );          // Oops.\n    printf( \"%d elements.\\n\", n );\n}\n\nint main()\n{\n    int const   moohaha[]   = {1, 2, 3, 4, 5, 6, 7};\n\n    printf( \"%d elements, calling display...\\n\", N_ITEMS( moohaha ) );\n    display( moohaha );\n}\n</code></pre>\n<p>passes a pointer to <code>N_ITEMS</code>, and therefore most likely produces a wrong\nresult. Compiled as a 32-bit executable in Windows 7 it produces \u2026</p>\n<blockquote>\n<p id=\"so_4810664_7439261_2\">7 elements, calling display...<br>\n  1 elements.</br></p>\n</blockquote>\n<ol>\n<li>The compiler rewrites <code>int const a[7]</code> to just <code>int const a[]</code>.</li>\n<li>The compiler rewrites <code>int const a[]</code> to <code>int const* a</code>.</li>\n<li><code>N_ITEMS</code> is therefore invoked with a pointer.</li>\n<li>For a 32-bit executable <code>sizeof(array)</code> (size of a pointer) is then 4.</li>\n<li><code>sizeof(*array)</code> is equivalent to <code>sizeof(int)</code>, which for a 32-bit executable is also 4.</li>\n</ol>\n<p>In order to detect this error at run time you can do \u2026</p>\n<pre><code>#include &lt;assert.h&gt;\n#include &lt;typeinfo&gt;\n\n#define N_ITEMS( array )       (                               \\\n    assert((                                                    \\\n        \"N_ITEMS requires an actual array as argument\",        \\\n        typeid( array ) != typeid( &amp;*array )                    \\\n        )),                                                     \\\n    sizeof( array )/sizeof( *array )                            \\\n    )\n</code></pre>\n<blockquote>\n<p id=\"so_4810664_7439261_3\">7 elements, calling display...<br>\n  Assertion failed: ( \"N_ITEMS requires an actual array as argument\", typeid( a ) != typeid( &amp;*a ) ), file runtime_detect\n  ion.cpp, line 16  </br></p>\n<p id=\"so_4810664_7439261_4\">This application has requested the Runtime to terminate it in an unusual way.<br>\n  Please contact the application's support team for more information.  </br></p>\n</blockquote>\n<p>The runtime error detection is better than no detection, but it wastes a little\nprocessor time, and perhaps much more programmer time. Better with detection at\ncompile time! And if you're happy to not support arrays of local types with C++98,\nthen you can do that:</p>\n<pre><code>#include &lt;stddef.h&gt;\n\ntypedef ptrdiff_t   Size;\n\ntemplate&lt; class Type, Size n &gt;\nSize n_items( Type (&amp;)[n] ) { return n; }\n\n#define N_ITEMS( array )       n_items( array )\n</code></pre>\n<p>Compiling this definition substituted into the first complete program, with g++,\nI got \u2026</p>\n<blockquote>\n<p id=\"so_4810664_7439261_5\">M:\\count&gt; g++ compile_time_detection.cpp<br>\n  compile_time_detection.cpp: In function 'void display(const int*)':<br>\n  compile_time_detection.cpp:14: error: no matching function for call to 'n_items(const int*&amp;)'  </br></br></p>\n<p id=\"so_4810664_7439261_6\">M:\\count&gt; _  </p>\n</blockquote>\n<p>How it works: the array is passed <em>by reference</em> to <code>n_items</code>, and so it does\nnot decay to pointer to first element, and the function can just return the\nnumber of elements specified by the type.</p>\n<p>With C++11 you can use this also for arrays of local type, and it's the type safe\n<strong>C++ idiom</strong> for finding the number of elements of an array.</p>\n<h2>5.4 C++11 &amp; C++14 pitfall: Using a <code>constexpr</code> array size function.</h2>\n<p>With C++11 and later it's natural, but as you'll see dangerous!, to\nreplace the C++03 function</p>\n<pre><code>typedef ptrdiff_t   Size;\n\ntemplate&lt; class Type, Size n &gt;\nSize n_items( Type (&amp;)[n] ) { return n; }\n</code></pre>\n<p>with</p>\n<pre><code>using Size = ptrdiff_t;\n\ntemplate&lt; class Type, Size n &gt;\nconstexpr auto n_items( Type (&amp;)[n] ) -&gt; Size { return n; }\n</code></pre>\n<p>where the significant change is the use of <code>constexpr</code>, which allows\nthis function to produce a <strong>compile time constant</strong>.</p>\n<p>For example, in contrast to the C++03 function, such a compile time constant\ncan be used to declare an array of the same size as another:</p>\n<pre><code>// Example 1\nvoid foo()\n{\n    int const x[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4};\n    constexpr Size n = n_items( x );\n    int y[n] = {};\n    // Using y here.\n}\n</code></pre>\n<p>But consider this code using the <code>constexpr</code> version:</p>\n<pre><code>// Example 2\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr int n = n_items( c );     // Not in C++14!\n    // Use c here\n}\n\nauto main() -&gt; int\n{\n    int x[42];\n    foo( x );\n}\n</code></pre>\n<p>The pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with\n<code>-pedantic-errors</code>, and,\ntesting with the online compilers at <a href=\"http://gcc.godbolt.org/\" rel=\"noreferrer\">gcc.godbolt.org/</a>, also with clang 3.0\nand clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or\n3.7 (experimental). And important for the Windows platform, it does not compile\nwith Visual C++ 2015. The reason is a C++11/C++14 statement about use of\nreferences in <code>constexpr</code> expressions:</p>\n\nC++11 C++14 $5.19/2 nine<sup><i>th</i></sup> dash\n\n<blockquote>\n<p id=\"so_4810664_7439261_7\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation\n  of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the\n  following expressions:<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22ee  </br></p>\n<ul>\n<li>an <em>id-expression</em> that refers to a variable or data member of reference type\n  unless the reference has a preceding initialization and either  \n  \n  <ul>\n<li>it is initialized with a constant expression or  </li>\n<li>it is a non-static data member of an object whose lifetime began within\n  the evaluation of e;</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>One can always write the more verbose</p>\n<pre><code>// Example 3  --  limited\n\nusing Size = ptrdiff_t;\n\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr Size n = std::extent&lt; decltype( c ) &gt;::value;\n    // Use c here\n}\n</code></pre>\n<p>\u2026 but this fails when <code>Collection</code> is not a raw array.</p>\n<p>To deal with collections that can be non-arrays one needs the overloadability of an\n<code>n_items</code> function, but also, for compile time use one needs a compile time\nrepresentation of the array size. And the classic C++03 solution, which works fine\nalso in C++11 and C++14, is to let the function report its result not as a value\nbut via its function result <em>type</em>. For example like this:</p>\n<pre><code>// Example 4 - OK (not ideal, but portable and safe)\n\n#include &lt;array&gt;\n#include &lt;stddef.h&gt;\n\nusing Size = ptrdiff_t;\n\ntemplate&lt; Size n &gt;\nstruct Size_carrier\n{\n    char sizer[n];\n};\n\ntemplate&lt; class Type, Size n &gt;\nauto static_n_items( Type (&amp;)[n] )\n    -&gt; Size_carrier&lt;n&gt;;\n// No implementation, is used only at compile time.\n\ntemplate&lt; class Type, size_t n &gt;        // size_t for g++\nauto static_n_items( std::array&lt;Type, n&gt; const&amp; )\n    -&gt; Size_carrier&lt;n&gt;;\n// No implementation, is used only at compile time.\n\n#define STATIC_N_ITEMS( c ) \\\n    static_cast&lt;Size&gt;( sizeof( static_n_items( c ).sizer ) )\n\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr Size n = STATIC_N_ITEMS( c );\n    // Use c here\n    (void) c;\n}\n\nauto main() -&gt; int\n{\n    int x[42];\n    std::array&lt;int, 43&gt; y;\n    foo( x );\n    foo( y );\n}\n</code></pre>\n<p>About the choice of return type for <code>static_n_items</code>: this code doesn't use <code>std::integral_constant</code>\nbecause with <code>std::integral_constant</code> the result is represented\ndirectly as a <code>constexpr</code> value, reintroducing the original problem. Instead\nof a <code>Size_carrier</code> class one can let the function directly return a\nreference to an array. However, not everybody is familiar with that syntax.</p>\n<p>About the naming: part of this solution to the <code>constexpr</code>-invalid-due-to-reference\nproblem is to make the choice of compile time constant explicit.</p>\n<p>Hopefully the oops-there-was-a-reference-involved-in-your-<code>constexpr</code> issue will be fixed with\nC++17, but until then a macro like the <code>STATIC_N_ITEMS</code> above yields portability,\ne.g. to the clang and Visual C++ compilers, retaining type safety.</p>\n<p>Related: macros do not respect scopes, so to avoid name collisions it can be a\ngood idea to use a name prefix, e.g. <code>MYLIB_STATIC_N_ITEMS</code>.</p>\n", "LastActivityDate": "2015-07-31T00:15:12.717"}, "4810672": {"ParentId": "4810664", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-01-26T22:15:14.367", "Score": "80", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:20.577", "Id": "4810672", "OwnerUserId": "252000", "Body": "<h1>Assignment</h1>\n<p>For no particular reason, arrays cannot be assigned to one another. Use <code>std::copy</code> instead:</p>\n<pre><code>#include &lt;algorithm&gt;\n\n// ...\n\nint a[8] = {2, 3, 5, 7, 11, 13, 17, 19};\nint b[8];\nstd::copy(a + 0, a + 8, b);\n</code></pre>\n<p>This is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.\n<code>std::copy</code> is usually specialized for primitive types to give maximum performance. It is unlikely that <code>std::memcpy</code> performs better. If in doubt, measure.</p>\n<p>Although you cannot assign arrays directly, you <em>can</em> assign structs and classes which <em>contain</em> array members. That is because <a href=\"https://stackoverflow.com/questions/4164279/\">array members are copied memberwise</a> by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.</p>\n<h1>Parameter passing</h1>\n<p>Arrays cannot be passed by value. You can either pass them by pointer or by reference.</p>\n<h2>Pass by pointer</h2>\n<p>Since arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called \"pass by pointer\". Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):</p>\n<pre><code>#include &lt;numeric&gt;\n#include &lt;cstddef&gt;\n\nint sum(const int* p, std::size_t n)\n{\n    return std::accumulate(p, p + n, 0);\n}\n\nint sum(const int* p, const int* q)\n{\n    return std::accumulate(p, q, 0);\n}\n</code></pre>\n<p>As a syntactic alternative, you can also declare parameters as <code>T p[]</code>, and it means the exact same thing as <code>T* p</code> <strong>in the context of parameter lists only</strong>:</p>\n<pre><code>int sum(const int p[], std::size_t n)\n{\n    return std::accumulate(p, p + n, 0);\n}\n</code></pre>\n<p>You can think of the compiler as rewriting <code>T p[]</code> to <code>T *p</code> <strong>in the context of parameter lists only</strong>. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a <em>huge</em> difference.</p>\n<p>Unfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:</p>\n<pre><code>int sum(const int* p, std::size_t n)\n\n// error: redefinition of 'int sum(const int*, size_t)'\nint sum(const int p[], std::size_t n)\n\n// error: redefinition of 'int sum(const int*, size_t)'\nint sum(const int p[8], std::size_t n)   // the 8 has no meaning here\n</code></pre>\n<h2>Pass by reference</h2>\n<p>Arrays can also be passed by reference:</p>\n<pre><code>int sum(const int (&amp;a)[8])\n{\n    return std::accumulate(a + 0, a + 8, 0);\n}\n</code></pre>\n<p>In this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:</p>\n<pre><code>template &lt;std::size_t n&gt;\nint sum(const int (&amp;a)[n])\n{\n    return std::accumulate(a + 0, a + n, 0);\n}\n</code></pre>\n<p>Note that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size <code>n</code>, a different function is instantiated from the template. You can also write <a href=\"https://stackoverflow.com/questions/4759078/\">quite useful</a> function templates that abstract from both the element type and from the size.</p>\n", "LastActivityDate": "2011-05-03T18:03:11.830"}, "4810664": {"CommentCount": "3", "AcceptedAnswerId": "4810668", "PostTypeId": "1", "LastEditorUserId": "-1", "LastEditorDisplayName": "user283145", "CreationDate": "2011-01-26T22:14:35.787", "LastActivityDate": "2017-03-22T16:20:24.913", "LastEditDate": "2017-05-23T11:54:50.260", "ViewCount": "108894", "FavoriteCount": "326", "Title": "How do I use arrays in C++?", "Id": "4810664", "Score": "411", "Body": "<p>C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (<code>std::vector&lt;T&gt;</code> since C++98 and <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"noreferrer\"><code>std::array&lt;T, n&gt;</code></a> since <a href=\"https://en.wikipedia.org/wiki/C++11\" rel=\"noreferrer\">C++11</a>), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.</p>\n<p>This FAQ is split into five parts:</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/4810668/\">arrays on the type level and accessing elements</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4984228/\">array creation and initialization</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4810672/\">assignment and parameter passing</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4810676/\">multidimensional arrays and arrays of pointers</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c/7439261#7439261\">common pitfalls when using arrays</a></li>\n</ol>\n<p>If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.</p>\n<p>In the following text, \"array\" means \"C array\", not the class template <code>std::array</code>. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of <code>new</code> and <code>delete</code> as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of <a href=\"https://stackoverflow.com/questions/712639/\">another FAQ</a>.</p>\n<p><sub>\n<em>(Note: This is meant to be an entry to <a href=\"https://stackoverflow.com/questions/tagged/c++-faq\">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href=\"https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href=\"http://chat.stackoverflow.com/rooms/10/c-lounge\">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</em>\n</sub></p>\n", "Tags": "<c++><arrays><pointers><multidimensional-array><c++-faq>", "OwnerUserId": "252000", "AnswerCount": "5"}, "4810668": {"ParentId": "4810664", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-01-26T22:14:47.427", "Score": "256", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:24.367", "Id": "4810668", "OwnerUserId": "252000", "Body": "<h1>Arrays on the type level</h1>\n<p>An array type is denoted as <code>T[n]</code> where <code>T</code> is the <em>element type</em> and <code>n</code> is a positive <em>size</em>, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstatic_assert(!std::is_same&lt;int[8], float[8]&gt;::value, \"distinct element type\");\nstatic_assert(!std::is_same&lt;int[8],   int[9]&gt;::value, \"distinct size\");\n</code></pre>\n<p>Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. <code>sizeof(T[n])</code> is equivalent to <code>n * sizeof(T)</code>.</p>\n<h2>Array-to-pointer decay</h2>\n<p>The only \"connection\" between <code>T[n]</code> and <code>T[m]</code> is that both types can implicitly be <em>converted</em> to <code>T*</code>, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a <code>T*</code> is required, you can provide a <code>T[n]</code>, and the compiler will silently provide that pointer:</p>\n<pre><code>                  +---+---+---+---+---+---+---+---+\nthe_actual_array: |   |   |   |   |   |   |   |   |   int[8]\n                  +---+---+---+---+---+---+---+---+\n                    ^\n                    |\n                    |\n                    |\n                    |  pointer_to_the_first_element   int*\n</code></pre>\n<p>This conversion is known as \"array-to-pointer decay\", and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (<code>T*</code>). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of <em>any</em> size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. <a href=\"https://stackoverflow.com/questions/4261074/\">Pointers are extremely stupid</a>.</p>\n<h2>Arrays are not pointers</h2>\n<p>The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer <em>value</em> is simply the address of the array. Note that the pointer is <em>not</em> stored as part of the array itself (or anywhere else in memory). <strong>An array is not a pointer.</strong></p>\n<pre><code>static_assert(!std::is_same&lt;int[8], int*&gt;::value, \"an array is not a pointer\");\n</code></pre>\n<p>One important context in which an array does <em>not</em> decay into a pointer to its first element is when the <code>&amp;</code> operator is applied to it. In that case, the <code>&amp;</code> operator yields a pointer to the <em>entire</em> array, not just a pointer to its first element. Although in that case the <em>values</em> (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:</p>\n<pre><code>static_assert(!std::is_same&lt;int*, int(*)[8]&gt;::value, \"distinct element type\");\n</code></pre>\n<p>The following ASCII art explains this distinction:</p>\n<pre><code>      +-----------------------------------+\n      | +---+---+---+---+---+---+---+---+ |\n+---&gt; | |   |   |   |   |   |   |   |   | | int[8]\n|     | +---+---+---+---+---+---+---+---+ |\n|     +---^-------------------------------+\n|         |\n|         |\n|         |\n|         |  pointer_to_the_first_element   int*\n|\n|  pointer_to_the_entire_array              int(*)[8]\n</code></pre>\n<p>Note how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).</p>\n<p>The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same <em>value</em> (the same address), yet they are completely distinct types.</p>\n<p>If you are unfamiliar with the C declarator syntax, the parenthesis in the type <code>int(*)[8]</code> are essential:</p>\n<ul>\n<li><code>int(*)[8]</code> is a pointer to an array of 8 integers.</li>\n<li><code>int*[8]</code> is an array of 8 pointers, each element of type <code>int*</code>.</li>\n</ul>\n<h1>Accessing elements</h1>\n<p>C++ provides two syntactic variations to access individual elements of an array.\nNeither of them is superior to the other, and you should familiarize yourself with both.</p>\n<h2>Pointer arithmetic</h2>\n<p>Given a pointer <code>p</code> to the first element of an array, the expression <code>p+i</code> yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:</p>\n<pre><code>std::cout &lt;&lt; *(x+3) &lt;&lt; \", \" &lt;&lt; *(x+7) &lt;&lt; std::endl;\n</code></pre>\n<p>If <code>x</code> denotes an <em>array</em>, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:</p>\n<pre><code>   +---+---+---+---+---+---+---+---+\nx: |   |   |   |   |   |   |   |   |   int[8]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n     |           |               |\nx+0  |      x+3  |          x+7  |     int*\n</code></pre>\n<p>(Note that the implicitly generated pointer has no name, so I wrote <code>x+0</code> in order to identify it.)</p>\n<p>If, on the other hand, <code>x</code> denotes a <em>pointer</em> to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which <code>i</code> is going to be added already exists:</p>\n<pre><code>   +---+---+---+---+---+---+---+---+\n   |   |   |   |   |   |   |   |   |   int[8]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n   +-|-+         |               |\nx: | | |    x+3  |          x+7  |     int*\n   +---+\n</code></pre>\n<p>Note that in the depicted case, <code>x</code> is a pointer <em>variable</em> (discernible by the small box next to <code>x</code>), but it could just as well be the result of a function returning a pointer (or any other expression of type <code>T*</code>).</p>\n<h2>Indexing operator</h2>\n<p>Since the syntax <code>*(x+i)</code> is a bit clumsy, C++ provides the alternative syntax <code>x[i]</code>:</p>\n<pre><code>std::cout &lt;&lt; x[3] &lt;&lt; \", \" &lt;&lt; x[7] &lt;&lt; std::endl;\n</code></pre>\n<p>Due to the fact that addition is commutative, the following code does exactly the same:</p>\n<pre><code>std::cout &lt;&lt; 3[x] &lt;&lt; \", \" &lt;&lt; 7[x] &lt;&lt; std::endl;\n</code></pre>\n<p>The definition of the indexing operator leads to the following interesting equivalence:</p>\n<pre><code>&amp;x[i]  ==  &amp;*(x+i)  ==  x+i\n</code></pre>\n<p>However, <code>&amp;x[0]</code> is generally <em>not</em> equivalent to <code>x</code>. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can <code>x</code> and <code>&amp;x[0]</code> be used interchangeably. For example:</p>\n<pre><code>T* p = &amp;array[0];  // rewritten as &amp;*(array+0), decay happens due to the addition\nT* q = array;      // decay happens due to the assignment\n</code></pre>\n<p>On the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an <em>array</em> to a pointer. Since this is meaningless (but <em>pointer</em> to pointer assignment makes sense), array-to-pointer decay kicks in as usual.</p>\n<h2>Ranges</h2>\n<p>An array of type <code>T[n]</code> has <code>n</code> elements, indexed from <code>0</code> to <code>n-1</code>; there is no element <code>n</code>. And yet, to support half-open ranges (where the beginning is <em>inclusive</em> and the end is <em>exclusive</em>), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:</p>\n<pre><code>   +---+---+---+---+---+---+---+---+....\nx: |   |   |   |   |   |   |   |   |   .   int[8]\n   +---+---+---+---+---+---+---+---+....\n     ^                               ^\n     |                               |\n     |                               |\n     |                               |\nx+0  |                          x+8  |     int*\n</code></pre>\n<p>For example, if you want to sort an array, both of the following would work equally well:</p>\n<pre><code>std::sort(x + 0, x + n);\nstd::sort(&amp;x[0], &amp;x[0] + n);\n</code></pre>\n<p>Note that it is illegal to provide <code>&amp;x[n]</code> as the second argument since this is equivalent to <code>&amp;*(x+n)</code>, and the sub-expression <code>*(x+n)</code> technically invokes <a href=\"https://stackoverflow.com/questions/3144904/\">undefined behavior</a> in C++ (but not in C99).</p>\n<p>Also note that you could simply provide <code>x</code> as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)</p>\n", "LastActivityDate": "2011-10-31T03:39:20.763"}, "bq_ids": {"n4140": {"so_4810664_7439261_7": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_4810664_7439261_0": {"section_id": 7143, "quality": 0.7777777777777778, "length": 7}, "so_4810664_7439261_1": {"section_id": 7143, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_4810664_7439261_0": {"section_id": 6887, "quality": 0.7777777777777778, "length": 7}, "so_4810664_7439261_1": {"section_id": 6887, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_4810664_7439261_7": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_4810664_7439261_0": {"section_id": 8644, "quality": 0.7777777777777778, "length": 7}, "so_4810664_7439261_1": {"section_id": 8644, "quality": 0.9285714285714286, "length": 13}}}, "4810676": {"ParentId": "4810664", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-01-26T22:15:30.997", "Score": "123", "LastEditorUserId": "718529", "LastEditDate": "2012-05-28T09:20:29.997", "Id": "4810676", "OwnerUserId": "252000", "Body": "<p>Programmers often confuse multidimensional arrays with arrays of pointers.</p>\n<h1>Multidimensional arrays</h1>\n<p>Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as \"arrays of arrays\" or \"<em>true</em> multidimensional arrays\".</p>\n<h2>Named multidimensional arrays</h2>\n<p>When using named multidimensional arrays, <em>all</em> dimensions must be known at compile time:</p>\n<pre><code>int H = read_int();\nint W = read_int();\n\nint connect_four[6][7];   // okay\n\nint connect_four[H][7];   // ISO C++ forbids variable length array\nint connect_four[6][W];   // ISO C++ forbids variable length array\nint connect_four[H][W];   // ISO C++ forbids variable length array\n</code></pre>\n<p>This is how a named multidimensional array looks like in memory:</p>\n<pre><code>              +---+---+---+---+---+---+---+\nconnect_four: |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n</code></pre>\n<p>Note that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a \"flat\" sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, <code>connect_four[0][6]</code> and <code>connect_four[1][0]</code> are neighbors in memory. In fact, <code>connect_four[0][7]</code> and <code>connect_four[1][0]</code> denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:</p>\n<pre><code>int* p = &amp;connect_four[0][0];\nint* q = p + 42;\nsome_int_sequence_algorithm(p, q);\n</code></pre>\n<h2>Anonymous multidimensional arrays</h2>\n<p>With anonymous multidimensional arrays, all dimensions <em>except the first</em> must be known at compile time:</p>\n<pre><code>int (*p)[7] = new int[6][7];   // okay\nint (*p)[7] = new int[H][7];   // okay\n\nint (*p)[W] = new int[6][W];   // ISO C++ forbids variable length array\nint (*p)[W] = new int[H][W];   // ISO C++ forbids variable length array\n</code></pre>\n<p>This is how an anonymous multidimensional array looks like in memory:</p>\n<pre><code>              +---+---+---+---+---+---+---+\n        +---&gt; |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |\n      +-|-+\n   p: | | |\n      +---+\n</code></pre>\n<p>Note that the array itself is still allocated as a single block in memory.</p>\n<h1>Arrays of pointers</h1>\n<p>You can overcome the restriction of fixed width by introducing another level of indirection.</p>\n<h2>Named arrays of pointers</h2>\n<p>Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:</p>\n<pre><code>int* triangle[5];\nfor (int i = 0; i &lt; 5; ++i)\n{\n    triangle[i] = new int[5 - i];\n}\n\n// ...\n\nfor (int i = 0; i &lt; 5; ++i)\n{\n    delete[] triangle[i];\n}\n</code></pre>\n<p>And here is how it looks like in memory:</p>\n<pre><code>          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\ntriangle: | | | | | | | | | | |\n          +---+---+---+---+---+\n</code></pre>\n<p>Since each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.</p>\n<h2>Anonymous arrays of pointers</h2>\n<p>Here is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:</p>\n<pre><code>int n = calculate_five();   // or any other number\nint** p = new int*[n];\nfor (int i = 0; i &lt; n; ++i)\n{\n    p[i] = new int[n - i];\n}\n\n// ...\n\nfor (int i = 0; i &lt; n; ++i)\n{\n    delete[] p[i];\n}\ndelete[] p;   // note the extra delete[] !\n</code></pre>\n<p>And here is how it looks like in memory:</p>\n<pre><code>          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\n          | | | | | | | | | | |\n          +---+---+---+---+---+\n            ^\n            |\n            |\n          +-|-+\n       p: | | |\n          +---+\n</code></pre>\n<h1>Conversions</h1>\n<p>Array-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:</p>\n<pre><code>int array_of_arrays[6][7];\nint (*pointer_to_array)[7] = array_of_arrays;\n\nint* array_of_pointers[6];\nint** pointer_to_pointer = array_of_pointers;\n</code></pre>\n<p>However, there is no implicit conversion from <code>T[h][w]</code> to <code>T**</code>. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of <code>h</code> pointers to <code>T</code> (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:</p>\n<pre><code>int connect_four[6][7];\n\nint** p = new int*[6];\nfor (int i = 0; i &lt; 6; ++i)\n{\n    p[i] = connect_four[i];\n}\n\n// ...\n\ndelete[] p;\n</code></pre>\n<p>Note that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:</p>\n<pre><code>int connect_four[6][7];\n\nint** p = new int*[6];\nfor (int i = 0; i &lt; 6; ++i)\n{\n    p[i] = new int[7];\n    std::copy(connect_four[i], connect_four[i + 1], p[i]);\n}\n\n// ...\n\nfor (int i = 0; i &lt; 6; ++i)\n{\n    delete[] p[i];\n}\ndelete[] p;\n</code></pre>\n", "LastActivityDate": "2012-05-28T09:20:29.997"}});