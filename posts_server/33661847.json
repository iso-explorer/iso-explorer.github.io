post_cb({"33662331": {"ParentId": "33661847", "CommentCount": "0", "Body": "<p>[Full disclosure: I authored Hana]</p>\n<p>I'm not trying to answer your original question, since Jonathan did that just fine.</p>\n<p>However, if you're looking for a solution to your problem and if you have access to a bugfree C++14 compiler (hence Clang for now), you can use <a href=\"https://github.com/boostorg/hana\" rel=\"nofollow\">Boost.Hana</a>. Hana is a modern metaprogramming library that enables you to metaprogram while keeping a high level of abstraction. Hence, you can write what you need in a readable way, instead of having to know about all the dirty tricks of the language. The library takes care of that for you:</p>\n<pre><code>#include &lt;boost/hana.hpp&gt;\n#include &lt;functional&gt; // for std::ref\n#include &lt;iostream&gt;\nnamespace hana = boost::hana;\n\ntemplate &lt;typename T0, typename ...T&gt;\nvoid shift(T0&amp;&amp; t0, T&amp;&amp; ...ts) {\n    auto args = hana::make_tuple(std::ref(t0), std::ref(ts)...);\n    hana::for_each(hana::range_c&lt;int, 0, sizeof...(ts)&gt;, [&amp;](auto i) {\n        args[i].get() = args[i + hana::int_c&lt;1&gt;].get();\n    });\n}\n\nint main() {\n    int i = 0, j = 1, k = 2;\n    shift(i, j, k);\n    std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; '\\n';\n}\n</code></pre>\n", "OwnerUserId": "627587", "PostTypeId": "2", "Id": "33662331", "Score": "4", "CreationDate": "2015-11-12T00:19:36.057", "LastActivityDate": "2015-11-12T00:19:36.057"}, "bq_ids": {"n4140": {"so_33661847_33661994_1": {"section_id": 64, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_33661847_33661994_1": {"section_id": 59, "quality": 0.7894736842105263, "length": 15}}, "n4659": {"so_33661847_33661994_1": {"section_id": 66, "quality": 0.9473684210526315, "length": 18}}}, "33661847": {"CommentCount": "0", "ViewCount": "179", "PostTypeId": "1", "LastEditorUserId": "2640636", "CreationDate": "2015-11-11T23:32:29.367", "LastActivityDate": "2015-11-15T11:10:35.647", "Title": "Backward variadic template", "AcceptedAnswerId": "33661994", "LastEditDate": "2015-11-12T04:17:30.637", "Id": "33661847", "Score": "3", "Body": "<p>I want to write a template function that does this (pseudo-code):</p>\n<pre><code>shift(T&amp; a,T&amp; b,T&amp; c,...,T&amp; y,const T&amp; z) {\n  a = b;\n  b = c;\n  ...\n  y = z;\n}\n</code></pre>\n<p>My attempt involved putting the variadic argument as the first argument as follows:</p>\n<pre><code>template&lt;typename A, typename B&gt;\ninline void shift(A&amp; a, const B&amp; b) noexcept {\n  a = b;\n}\ntemplate&lt;typename B, typename C, typename... AA&gt;\ninline void shift(AA&amp;... aa, B&amp; b, const C&amp; c) noexcept {\n  shift(aa...,b);\n  shift(b,c);\n}\n</code></pre>\n<p>Why doesn't this work? Can a variadic argument only be the last argument? Then is there a way to make the last reference constant?</p>\n<p>I need a <code>const</code> reference for a case like:</p>\n<pre><code>double a, b, c;\nshift(a,b,c,5);\n</code></pre>\n<p><strong>EDIT</strong>:\nOk, this particular problem can of course be solved by reversing the order of the function arguments:</p>\n<pre><code>template&lt;typename A, typename B&gt;\ninline void shift(const B&amp; b, A&amp; a) noexcept {\n  a = b;\n}\ntemplate&lt;typename C, typename B, typename... AA&gt;\ninline void shift(const C&amp; c, B&amp; b, AA&amp;... aa) noexcept {\n  shift(b,aa...);\n  b = c;\n}\n</code></pre>\n<p>But I would still like to know if syntax allows for placing variadic arguments in any place other then the last and under what circumstances?</p>\n", "Tags": "<c++><c++11><variadic-templates>", "OwnerUserId": "2640636", "AnswerCount": "2"}, "33661994": {"ParentId": "33661847", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As T.C.'s comment below points out, in your first example <code>aa</code> is in a non-deduced context (14.8.2.5 p5 defines non-deduced contexts, including \"a function parameter pack that does not occur at the end of the parameter-declaration-list\") and so the parameter pack cannot be deduced.</p>\n<blockquote>\n<p id=\"so_33661847_33661994_0\">if syntax allows for placing variadic arguments in any place other then the last and under what circumstances?</p>\n</blockquote>\n<p>In addition to the restriction stated above that caused problems for your first example, a template parameter pack has to be the last template parameter unless all following template parameters can be deduced. 14.1 [temp.param] p11:</p>\n<blockquote>\n<p id=\"so_33661847_33661994_1\">A template parameter pack of a function template shall not be followed\n  by another template parameter unless that template parameter can be deduced from the parameter-type-list of the function template or has a default argument (14.8.2).</p>\n</blockquote>\n<p>So this is OK because both template parameter packs can be deduced independently from the function parameters:</p>\n<pre><code>template&lt;typename... T, typename... U&gt;\n  void f(std::tuple&lt;T...&gt;, std::tuple&lt;U...&gt;)\n  { }\n</code></pre>\n<p>A different way to write your <code>shift</code> function is to use an <code>index_sequence</code></p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename... T, size_t... I&gt;\nvoid\nshift_impl(std::tuple&lt;T...&gt; t, std::index_sequence&lt;I...&gt;)\n{\n  // Use pack expansion with comma operator to populate unused array:\n  int dummy[] = {\n    (std::get&lt;I&gt;(t) = std::get&lt;I+1&gt;(t), 0)...\n  };\n}\n\ntemplate&lt;typename T0, typename... T&gt;\nvoid\nshift(T0&amp;&amp; arg0, T&amp;&amp;... args)\n{\n  shift_impl(std::tie(arg0, args...), std::index_sequence_for&lt;T...&gt;{});\n}\n\nint main()\n{\n  int i = 0, j = 1, k = 2;\n  shift(i, j, k);\n  std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; '\\n';\n}\n</code></pre>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-11-15T11:10:35.647", "Id": "33661994", "Score": "6", "CreationDate": "2015-11-11T23:46:07.930", "LastActivityDate": "2015-11-15T11:10:35.647"}});