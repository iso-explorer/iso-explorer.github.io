post_cb({"12458187": {"CommentCount": "6", "ViewCount": "319", "PostTypeId": "1", "LastEditorUserId": "1677322", "CreationDate": "2012-09-17T11:23:23.920", "LastActivityDate": "2013-03-05T20:28:00.777", "Title": "What is the rationale behind not having a writesome function for basic_ostream in the STL?", "FavoriteCount": "1", "LastEditDate": "2013-03-05T20:28:00.777", "Id": "12458187", "Score": "2", "Body": "<p>While working on a network library I recently noticed that having a pendant to basic_streambuf::in_avail in conjunction with a writesome function would be pretty handy for asynchronous I/O.</p>\n<p>I have searched the web and checked several C++ references if there is any function which meets these demands, but it seems I had no luck. The only source which mentions similar functionality is <a href=\"http://www.boost.org/doc/libs/1_51_0/doc/html/boost_asio/reference/basic_stream_socket/write_some.html\" rel=\"nofollow\">Boost's Asio</a> library, however the description clearly states that the function call will block until at least one byte has been sent which does not reflect my desired behaviour.</p>\n<p>To elaborate on my question, I created a rough draft based on the C++ N3337 publication.</p>\n<blockquote>\n<p id=\"so_12458187_12458187_0\"><strong>27.6.3.2.5  Put area [streambuf.pub.put]</strong></p>\n<p id=\"so_12458187_12458187_1\"><code>streamsize in_depart();</code></p>\n<p id=\"so_12458187_12458187_2\"><em>Returns:</em> If a write position is available, returns <code>epptr() - pptr()</code>. Otherwise \n  returns <code>showmanycp()</code>.</p>\n<p id=\"so_12458187_12458187_3\"><strong>27.6.3.4.5  Put area [streambuf.virt.put]</strong></p>\n<p id=\"so_12458187_12458187_4\"><code>streamsize showmanycp();</code> </p>\n<p id=\"so_12458187_12458187_5\"><em>Returns:</em> An estimate of the number of characters which can be written to the sequence,\n  or <code>-1</code>. If it returns a positive value, then successive calls to <code>overflow()</code> will not\n  return <code>traits::eof()</code> until at least that number of characters have been written to the\n  stream. If <code>showmanycp()</code> returns <code>-1</code>, then calls to <code>overflow()</code>will fail.</p>\n<p id=\"so_12458187_12458187_6\"><em>Default behavior:</em> Returns zero.  </p>\n<p id=\"so_12458187_12458187_7\"><em>Remarks:</em> Uses <code>traits::eof()</code>.</p>\n<p id=\"so_12458187_12458187_8\"><strong>27.7.3.7        Unformatted output functions [ostream.unformatted]</strong></p>\n<p id=\"so_12458187_12458187_9\"><code>streamsize writesome(char_type* s, streamsize n);</code></p>\n<p id=\"so_12458187_12458187_10\"><em>Effects:</em> Behaves as an unformatted output function (as described in 27.7.3.7, paragraph\n  1). After constructing a sentry object, if <code>!good()</code> calls<code>setstate(failbit)</code> which may\n  throw an exception, and return. Otherwise writes <code>n</code> characters designated by <code>s</code>. If\n  <code>rdbuf()-&gt;in_depart() == -1</code>, calls <code>setstate(badbit)</code> (which may throw\n  <code>ios_base::failure</code> (27.5.5.4)), and writes no characters;</p>\n<p id=\"so_12458187_12458187_11\">\u2014 If <code>rdbuf()-&gt;in_depart() == 0</code>, writes no characters.</p>\n<p id=\"so_12458187_12458187_12\">\u2014 If <code>rdbuf()-&gt;in_depart() &gt; 0</code>, writes <code>min(rdbuf()-&gt;in_depart(), n))</code> characters.</p>\n<p id=\"so_12458187_12458187_13\"><em>Returns:</em> The number of characters written.</p>\n</blockquote>\n", "Tags": "<c++><stl><network-programming><iostream>", "OwnerUserId": "1677322", "AnswerCount": "1"}, "12459370": {"ParentId": "12458187", "CommentCount": "6", "Body": "<p>I'd guess you misinterpret the meaning of <code>in_avail()</code> and <code>readsome()</code>: all these say is that the stream had read a block of data and there are still characters in the buffer. Yes, it could theoretically do something different but in particukar when reading from a network you don't know how much data is available until you tried reading it.</p>\n<p>Similarily, there is no way to guarantee to be able to get rid of a y specific number of characters: what would <code>out.writesome(buf, n)</code> mean? If you want it to mean that you dumped <code>n</code> characters into <code>out</code>'s buffer, you can just create a suitable stream buffer and use <code>write()</code>. Guaranteeing that <code>n</code> bytes are sent with blocking, however, can't be done (at least, for <code>1 &lt; n</code>). I guess you want the latter, though.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "12459370", "Score": "2", "CreationDate": "2012-09-17T12:40:06.933", "LastActivityDate": "2012-09-17T12:40:06.933"}, "bq_ids": {"n4140": {"so_12458187_12458187_2": {"section_id": 2111, "quality": 0.6, "length": 6}, "so_12458187_12458187_10": {"section_id": 2239, "quality": 0.7096774193548387, "length": 22}, "so_12458187_12458187_5": {"section_id": 2139, "quality": 0.7741935483870968, "length": 24}}, "n3337": {"so_12458187_12458187_2": {"section_id": 2099, "quality": 0.6, "length": 6}, "so_12458187_12458187_10": {"section_id": 2227, "quality": 0.7096774193548387, "length": 22}, "so_12458187_12458187_5": {"section_id": 2127, "quality": 0.7741935483870968, "length": 24}}, "n4659": {"so_12458187_12458187_5": {"section_id": 2412, "quality": 0.7741935483870968, "length": 24}, "so_12458187_12458187_10": {"section_id": 2512, "quality": 0.6774193548387096, "length": 21}, "so_12458187_12458187_2": {"section_id": 2384, "quality": 0.6, "length": 6}}}});