post_cb({"34494145": {"ParentId": "34493967", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_34493967_34494145_0\">Is it right to say that the first delete causes a memory leak while the second one its fine?</p>\n</blockquote>\n<p>The second one is indeed fine, but your first statement isn't exactly correct.</p>\n<p>Formally, deleting an object through a pointer to a base subobject that has a non-virtual destructor has undefined behaviour. A nemory leak is possible but not necessary. In fact, in your case, since neither <code>derived</code> nor any of its member objects allocate any dynamic memory that would be deallocated in the destructor, there probably won't be a leak.</p>\n<p>Whether memory is leaked or not is really the least of your concerns when your program has undefined behaviour.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2015-12-28T13:28:25.203", "Id": "34494145", "Score": "13", "CreationDate": "2015-12-28T13:09:56.057", "LastActivityDate": "2015-12-28T13:28:25.203"}, "34494205": {"ParentId": "34493967", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is Undefined Behaviour, which may, indeed, lead to memory leak:<br>\nThe C++ Standard, [expr.delete], paragraph 3 [<a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014\" rel=\"nofollow\">ISO/IEC 14882-2014</a>], states:</br></p>\n<blockquote>\n<p id=\"so_34493967_34494205_0\">In the first alternative (delete object), <strong>if the static type of the object to be deleted is different from its dynamic type</strong>, the static type shall be a base class of the dynamic type of the object to be deleted and <strong>the static type shall have a virtual destructor or the behavior is undefined</strong>. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>Since no destructor in neither <code>Base</code> nor <code>Derived</code> is user-defined, a default destructor is added by the compiler. Those destructors are not <code>virtual</code>.</p>\n<p>Since <code>base</code> is a <code>Base*</code>, <code>delete base</code> calls the destructor of the base class, which is <em>Undefined Behaviour</em>. In concrete terms, it leads to memory leak when you work with resources; in your case, since your classes only contain POD, I'd say there is no leak.</p>\n<p>In order to fix the memory leak, one should define a virtual destructor for classes meant to be inherited:</p>\n<pre><code>struct Base\n{\n    virtual ~Base() {}\n    int myInt;\n};\n\nstruct Derived : Base\n{\n    int myIntDerived;\n};\n\nint main()\n{\n    Base    *base    = new Derived;\n    Derived *derived = new Derived;\n\n    delete base;    // OK\n    delete derived; // OK\n}\n</code></pre>\n</hr>", "OwnerUserId": "5470596", "LastEditorUserId": "5470596", "LastEditDate": "2016-07-21T08:50:13.593", "Id": "34494205", "Score": "10", "CreationDate": "2015-12-28T13:14:09.473", "LastActivityDate": "2016-07-21T08:50:13.593"}, "bq_ids": {"n4140": {"so_34493967_34494205_0": {"section_id": 6107, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_34493967_34494205_0": {"section_id": 5873, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_34493967_34494205_0": {"section_id": 7604, "quality": 0.9512195121951219, "length": 39}}}, "34493967": {"CommentCount": "1", "ViewCount": "542", "PostTypeId": "1", "ClosedDate": "2016-01-02T23:17:42.813", "LastEditorUserId": "5470596", "CreationDate": "2015-12-28T12:58:06.297", "LastActivityDate": "2016-07-21T08:50:13.593", "Title": "C++ inheritance: does lack of virtual destructor lead to memory leak?", "LastEditDate": "2015-12-28T13:34:19.737", "Id": "34493967", "Score": "3", "Body": "<p>I have a doubt about a question I often ask myself, this is the situation:</p>\n<p>Two classes, no virtual destructor</p>\n<pre><code>class Base\n{\n    int myInt;\n};\n\nclass Derived : public Base\n{\n    int myIntDerived;\n};\n\nint main()\n{\n    Base    *base    = new Derived;\n    Derived *derived = new Derived;\n\n    delete base;\n    delete derived;\n}\n</code></pre>\n<p>Is it right to say that the first delete causes a memory leak while the second one its fine?</p>\n", "Tags": "<c++><memory><virtual><destructor>", "OwnerUserId": "1043572", "AnswerCount": "2"}});