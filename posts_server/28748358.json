post_cb({"28748358": {"ViewCount": "595", "Body": "<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::string s = \"abcdef\";\n\n    std::string s2 = s;\n\n    auto begin = const_cast&lt;std::string const &amp;&gt;(s2).begin();\n    auto end = s2.end();\n\n    std::cout &lt;&lt; end - begin &lt;&lt; '\\n';\n}\n</code></pre>\n<p>This code mixes the result of <code>begin() const</code> with the result of <code>end()</code>. Neither of these functions is permitted to invalidate any iterators. However I'm curious whether the requirement of <code>end()</code> to not invalidate the iterator variable <code>begin</code> actually means that the variable <code>begin</code> is usable with <code>end</code>.</p>\n<p>Consider a C++98, copy-on-write implementation of <code>std::string</code>; the non-const <code>begin()</code> and <code>end()</code> functions cause a the internal buffer to be copied because the result of these functions can be used to modify the string. So <code>begin</code> above starts out valid for both <code>s</code> and <code>s2</code>, but the use of the non-const <code>end()</code> member causes it to no longer be valid for <code>s2</code>, the container that produced it.</p>\n<p>The above code produces 'unexpected' results with a copy-on-write implementation, such as libstdc++. Instead of <code>end - begin</code> being the same as <code>s2.size()</code>, libstdc++ <a href=\"http://coliru.stacked-crooked.com/a/420ae2ef67b366f7\" rel=\"nofollow\">produces another number</a>.</p>\n<ul>\n<li><p>Does causing <code>begin</code> to no longer be valid iterator into <code>s2</code>, the container it was retrieved from, constitute 'invalidating' the iterator? If you look at the requirements on iterators, they all appear to hold for this iterator after <code>.end()</code> is called, so perhaps <code>begin</code> still qualifies as a valid iterator, and thus has not been invalidated?</p></li>\n<li><p>Is the above code well defined in C++98? In C++11, which prohibits copy-on-write implementations?</p></li>\n</ul>\n<p>From my own brief reading of the specs, it appears under-specified, so that there may not be any guarantee that the results of <code>begin()</code> and <code>end()</code> can ever be used together, even without mixing const and non-const versions.</p>\n", "AcceptedAnswerId": "28748737", "Title": "Iterator invalidation by `std::string::begin()`/`std::string::end()`?", "CreationDate": "2015-02-26T17:01:49.237", "Id": "28748358", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-02-27T16:28:40.827", "LastEditorUserId": "365496", "LastActivityDate": "2015-02-27T16:28:40.827", "Score": "6", "OwnerUserId": "365496", "Tags": "<c++><c++11><iterator><c++98><const-iterator>", "AnswerCount": "4"}, "28748604": {"Id": "28748604", "PostTypeId": "2", "Body": "<p>The code is OK: a CoW implementation is pretty much required to unshare when there is a danger to an iterator or reference to an element is held. That is, when you there is something which accessed an element in one string and a copy of it ventures to do the same, i.e., use an iterator or the subscript operator, it will have to be unshared. It could know about its iterators and update them as needed.</p>\n<p>Of course, in a concurrent system it is near impossible to do all this without data races but pre-C++11 there are no data races.</p>\n", "LastActivityDate": "2015-02-26T17:12:40.617", "CommentCount": "5", "CreationDate": "2015-02-26T17:12:40.617", "ParentId": "28748358", "Score": "2", "OwnerUserId": "1120273"}, "28748611": {"Id": "28748611", "PostTypeId": "2", "Body": "<p>As of N3337 (<a href=\"https://stackoverflow.com/a/10775520/179910\">which is essentially identical to C++11</a>), the specification reads ([string.require]/4):</p>\n<blockquote>\n<p id=\"so_28748358_28748611_0\">References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:<br>\n  [...]<br>\n  - Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend.</br></br></p>\n</blockquote>\n<p>At least as I'd read it, this means that a call to <code>begin</code> or <code>end</code> is not allowed to invalidate any iterators. Although not stated directly, I'd also take this as meaning that no call to a <code>const</code> member function can invalidate any iterators.</p>\n<p>This wording remains the same at least up through n4296.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-26T17:19:28.793", "Score": "2", "CreationDate": "2015-02-26T17:12:56.077", "ParentId": "28748358", "CommentCount": "4", "OwnerUserId": "179910", "LastEditDate": "2017-05-23T12:21:43.417"}, "28748737": {"Id": "28748737", "PostTypeId": "2", "Body": "<p>As you say, C++11 differs from earlier versions in this regard.  There's no problem in C++11 because all attempts to allow copy on write were removed.  In pre-C++11, your code results in undefined behavior; the call <code>s2.end()</code> is allowed to invalidate existing iterators (and did, and maybe still does, in g++).</p>\n<p>Note that even if <code>s2</code> were not a copy, the standard would allow it to invalidate iterators.  In fact, the CD for C++98 even made things like <code>f( s.begin(), s.end() )</code> or <code>s[i] == s[j]</code> undefined behavior.  This was only realized at the last minute, and corrected so that only the first call to <code>begin()</code>, <code>end()</code> or <code>[]</code> could invalidate the iterators.</p>\n", "LastActivityDate": "2015-02-26T17:19:09.857", "CommentCount": "3", "CreationDate": "2015-02-26T17:19:09.857", "ParentId": "28748358", "Score": "6", "OwnerUserId": "649665"}, "bq_ids": {"n4140": {"so_28748358_28752639_4": {"length": 10, "quality": 1.0, "section_id": 1567}, "so_28748358_28748611_0": {"length": 25, "quality": 1.0, "section_id": 1567}, "so_28748358_28752639_1": {"length": 6, "quality": 1.0, "section_id": 1567}, "so_28748358_28752639_0": {"length": 13, "quality": 1.0, "section_id": 1567}}, "n3337": {"so_28748358_28752639_4": {"length": 10, "quality": 1.0, "section_id": 1562}, "so_28748358_28748611_0": {"length": 25, "quality": 1.0, "section_id": 1562}, "so_28748358_28752639_1": {"length": 6, "quality": 1.0, "section_id": 1562}, "so_28748358_28752639_0": {"length": 13, "quality": 1.0, "section_id": 1562}}, "n4659": {"so_28748358_28752639_4": {"length": 10, "quality": 1.0, "section_id": 1716}, "so_28748358_28748611_0": {"length": 25, "quality": 1.0, "section_id": 1716}, "so_28748358_28752639_1": {"length": 6, "quality": 1.0, "section_id": 1716}, "so_28748358_28752639_0": {"length": 13, "quality": 1.0, "section_id": 1716}}}, "28752639": {"Id": "28752639", "PostTypeId": "2", "Body": "<p>C++98 [lib.basic.string]/5 states:</p>\n<blockquote>\n<p id=\"so_28748358_28752639_0\">References, pointers, and iterators referring to the elements of a <code>basic_string</code> sequence may be invalidated by the following uses of the <code>basic_string</code> object:</p>\n<ul>\n<li><p id=\"so_28748358_28752639_1\">As an argument to non-member functions <code>swap()</code>, <code>operator&gt;&gt;()</code>, and <code>getline()</code>.</p></li>\n<li><p id=\"so_28748358_28752639_2\">As an argument to <code>basic_string::swap()</code>.</p></li>\n<li><p id=\"so_28748358_28752639_3\">Calling <code>data()</code> and <code>c_str()</code> member functions.</p></li>\n<li><p id=\"so_28748358_28752639_4\">Calling non-const member functions, except <code>operator[]()</code>, <code>at()</code>, <code>begin()</code>, <code>rbegin()</code>, <code>end()</code>, and <code>rend()</code>.</p></li>\n<li><p id=\"so_28748358_28752639_5\">Subsequent to any of the above uses except the forms of <code>insert()</code> and <code>erase()</code> which return iterators, the first call to non-const member functions <code>operator[]()</code>, <code>at()</code>, <code>begin()</code>, <code>rbegin()</code>, <code>end()</code>, or <code>rend()</code>.</p></li>\n</ul>\n</blockquote>\n<p>Since the constructor of <code>s2</code> is a \"non-const member function\", it is conforming for the call to non-const <code>s2.end()</code> - the first such call per the last bullet above - to invalidate iterators. The program therefore does not have defined behavior per C++98.</p>\n<p>I won't comment on C++11 as I think the other answers explain clearly that the program has defined behavior in that context.</p>\n", "LastActivityDate": "2015-02-26T21:00:47.287", "CommentCount": "0", "CreationDate": "2015-02-26T21:00:47.287", "ParentId": "28748358", "Score": "1", "OwnerUserId": "923854"}});