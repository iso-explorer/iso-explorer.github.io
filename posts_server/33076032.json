post_cb({"33076132": {"ParentId": "33076032", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Maybe [iterator.requirements.general, 24.2.1]/6 contains what you're after?</p>\n<blockquote>\n<p id=\"so_33076032_33076132_0\">Results of most expressions are undefined for singular values;\n  the only exceptions are destroying an iterator that holds a singular value, the assignment of a non-singular\n  value to an iterator that holds a singular value, and, for iterators that satisfy the <code>DefaultConstructible</code>\n  requirements, using a value-initialized iterator as the source of a copy or move operation. [Note: This\n  guarantee is not offered for default initialization, although the distinction only matters for types with trivial\n  default constructors such as pointers or aggregates holding pointers. \u2014 end note] In these cases the singular\n  value is overwritten the same way as any other value. Dereferenceable values are always non-singular.</p>\n</blockquote>\n<p>Moreover, <em>invalid iterators</em> are defined by paragraph 11:</p>\n<blockquote>\n<p id=\"so_33076032_33076132_1\">An <em>invalid</em> iterator is an iterator that may be singular.</p>\n</blockquote>\n<p>Thus, invalid iterators are at least as constrained as singular iterators; specifically, the only permitted operations are destruction and assignment.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2015-10-12T09:08:10.290", "Id": "33076132", "Score": "3", "CreationDate": "2015-10-12T08:06:48.837", "LastActivityDate": "2015-10-12T09:08:10.290"}, "33076032": {"CommentCount": "0", "ViewCount": "114", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-12T08:00:45.927", "LastActivityDate": "2015-10-12T09:08:10.290", "Title": "Which operations are defined for invalid iterators?", "AcceptedAnswerId": "33076132", "LastEditDate": "2017-05-23T12:14:42.527", "Id": "33076032", "Score": "3", "Body": "<p>As a follow-up on <a href=\"https://stackoverflow.com/questions/31310175/unusual-behavior-with-auto-while-traversing-a-dynamic-vector/33065133?noredirect=1#comment53962071_33065133\">a question concerning comparing invalid iterators</a>, I tried to find a definition of the allowed expressions for invalid iterators in the C++ standard. Searching for \"invalid iterator\" finds only a single reference in \u00a724.2.1.11. It says that invalid iterators may be \"singular\", but only states that dereferencing them may be undefined behavior. No further semantics is given.</p>\n<p>One of the original answers suggests that it is implementation-defined behavior, but I think that this cannot be assumed in general because the above mentioned paragraph explicitly refers to UB.</p>\n<p><a href=\"https://stackoverflow.com/a/30694084/3309790\">This answer</a> shows that \"Any other use of an invalid pointer value has implementation-defined behavior\". Since iterators for vectors are often implemented as pointers, I would argue that comparing two invalid iterators is at least implementation-defined behavior.</p>\n<p>Could anybody point me to the relevant sections in the standard where the semantics for invalid iterators are defined?</p>\n", "Tags": "<c++><vector><stl><language-lawyer>", "OwnerUserId": "2169853", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33076032_33076132_1": {"section_id": 5564, "quality": 0.8, "length": 4}, "so_33076032_33076132_0": {"section_id": 5559, "quality": 0.9354838709677419, "length": 58}}, "n3337": {"so_33076032_33076132_1": {"section_id": 5346, "quality": 0.8, "length": 4}, "so_33076032_33076132_0": {"section_id": 5341, "quality": 0.9354838709677419, "length": 58}}, "n4659": {"so_33076032_33076132_1": {"section_id": 7011, "quality": 0.8, "length": 4}, "so_33076032_33076132_0": {"section_id": 7006, "quality": 0.9032258064516129, "length": 56}}}});