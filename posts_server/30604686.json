post_cb({"bq_ids": {"n4140": {"so_30604686_30604988_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 7136}, "so_30604686_30604988_6": {"length": 12, "quality": 1.0, "section_id": 6185}, "so_30604686_30604988_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_30604686_30604988_5": {"length": 13, "quality": 0.5909090909090909, "section_id": 87}, "so_30604686_30604988_2": {"length": 7, "quality": 0.875, "section_id": 7136}}, "n3337": {"so_30604686_30604988_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 6880}, "so_30604686_30604988_6": {"length": 11, "quality": 0.9166666666666666, "section_id": 5946}, "so_30604686_30604988_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_30604686_30604988_5": {"length": 16, "quality": 0.7272727272727273, "section_id": 82}, "so_30604686_30604988_2": {"length": 7, "quality": 0.875, "section_id": 6880}}, "n4659": {"so_30604686_30604988_4": {"length": 14, "quality": 1.0, "section_id": 8637}, "so_30604686_30604988_6": {"length": 12, "quality": 1.0, "section_id": 7687}, "so_30604686_30604988_7": {"length": 31, "quality": 1.0, "section_id": 6789}, "so_30604686_30604988_2": {"length": 7, "quality": 0.875, "section_id": 8637}, "so_30604686_30604988_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 90}}}, "30604988": {"Id": "30604988", "PostTypeId": "2", "Body": "<p><strong>1.</strong> Short answer: It works irrespective of it being declared <code>constexpr</code>, because you're defining an object with static storage duration (that is not a string literal - it stores a copy of the contents of one), and its address is a constant expression. Regarding linkage, <code>str2</code> has internal linkage, but that's fine - its address can be used as a non-type template argument.</p>\n<p>Long answer: </p>\n<p>In C++11 and 14, [14.3.2p1] says the following:</p>\n<blockquote>\n<p id=\"so_30604686_30604988_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em>\n  shall be one of:<br>\n  [...]  </br></p>\n<ul>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal\n  linkage or a function with external or internal linkage, including\n  function templates and function <em>template-id</em>s but excluding non-static\n  class members, expressed (ignoring parentheses) as <code>&amp;</code> <em>id-expression</em>,\n  where the <em>id-expression</em> is the name of an object or function, except\n  that the <code>&amp;</code> may be omitted if the name refers to a function or array\n  and shall be omitted if the corresponding <em>template-parameter</em> is a\n  reference;</li>\n</ul>\n<p id=\"so_30604686_30604988_1\">[...]</p>\n</blockquote>\n<p>So, you can use the address of an object with static storage duration, but the object has to be identified by a name with linkage (internal or external), and the way you're expressing that address is restricted. (String literals are not names and don't have linkage.)</p>\n<p>In short, even <code>char str1[] = \"Test 1\";</code> works. <code>static char str1[] = \"Test 1\";</code> is fine as well; GCC 5.1.0 rejects it, but I think that's a bug; Clang 3.6.0 accepts it.</p>\n<hr>\n<p>About <code>str2</code>'s linkage, C++11 and 14 [3.5p3] says:</p>\n<blockquote>\n<p id=\"so_30604686_30604988_2\">A name having namespace scope (3.3.6) has internal linkage if\n  it is the name of<br>\n  [...]  </br></p>\n<ul>\n<li>a non-volatile variable that is explicitly declared <code>const</code> or <code>constexpr</code> and neither explicitly declared <code>extern</code> nor previously\n  declared to have external linkage;  </li>\n</ul>\n<p id=\"so_30604686_30604988_3\">[...]</p>\n</blockquote>\n<p>N4431 has changed that slightly, as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1686\">DR 1686</a>, to:</p>\n<blockquote id=\"so_30604686_30604988_4\">\n<ul>\n<li>a variable of non-volatile const-qualified type that is neither explicitly declared <code>extern</code> nor previously declared to have external\n  linkage;</li>\n</ul>\n</blockquote>\n<p>reflecting the fact that <code>constexpr</code> implies const-qualification for objects.</p>\n<hr>\n<p><strong>2.</strong> Short answer: For C++11 and 14, see above; for draft C++1z, <code>str3</code> is not a constant expression, as the pointer itself is not <code>constexpr</code>, and it's also the address of a string literal. <code>str4</code> is constant, but still an address of a string literal.</p>\n<p>Long answer:</p>\n<p>In the current working draft, N4431, the constraints on non-type template arguments have been relaxed. [14.3.2p1] now says:</p>\n<blockquote>\n<p id=\"so_30604686_30604988_5\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a\n  converted constant expression (5.20) of the type of the\n  <em>template-parameter</em>. For a non-type <em>template-parameter</em> of reference or\n  pointer type, the value of the constant expression shall not refer to\n  (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li>a subobject (1.8),</li>\n<li>a temporary object (12.2),</li>\n<li>a string literal (2.13.5),</li>\n<li>the result of a <code>typeid</code> expression (5.2.8), or</li>\n<li>a predefined <code>__func__</code> variable (8.4.1).</li>\n</ul>\n</blockquote>\n<p>And those are all the restrictions. The <em>converted constant expression</em> part is pretty important; the full definition is <em>long</em>, but one part relevant to our case is that the address of an object with static storage duration is such an expression. </p>\n<p>Also relevant is that, according to [5.20p2.7], <em>an lvalue-to-rvalue conversion</em> applied to </p>\n<blockquote>\n<p id=\"so_30604686_30604988_6\">a non-volatile glvalue that refers to a non-volatile object defined\n  with <code>constexpr</code>, or that refers to a non-mutable sub-object of such an\n  object</p>\n</blockquote>\n<p>also satisfies the conditions for being a constant expression. This allows us to use some <code>constexpr</code> pointer variables as non-type template arguments. (Note that simply declaring a variable <code>const</code> is not enough, as it can be initialized with a non-constant expression.)</p>\n<p>So, something like <code>constexpr const char* str3 = str1;</code> is fine. It's accepted by Clang 3.6.0 in C++1z mode (and rejected in C++14 mode); GCC 5.1.0 still rejects it - it looks like it hasn't implemented the updated rules yet.</p>\n<hr>\n<p>Still, what's wrong with string literals? Here's the problem (N4431 [2.13.5p16]):</p>\n<blockquote>\n<p id=\"so_30604686_30604988_7\">Evaluating a <em>string-literal</em> results in a string literal object with\n  static storage duration, initialized from the given characters as\n  specified above. Whether all string literals are distinct (that is,\n  are stored in nonoverlapping objects) and whether successive\n  evaluations of a <em>string-literal</em> yield the same or a different object\n  is unspecified.</p>\n</blockquote>\n<p>An implementation is allowed to do lots of things with string literals: mix, match, make them overlap (entirely or partially), make 7 copies from the same translation unit - whatever. That makes the address of a string literal unusable as a non-type template argument.</p>\n</hr></hr></hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-06-03T00:06:23.143", "Score": "12", "CreationDate": "2015-06-02T19:31:54.840", "ParentId": "30604686", "CommentCount": "5", "OwnerUserId": "4326278", "LastEditDate": "2015-06-03T00:06:23.143"}, "30604686": {"ViewCount": "3833", "Body": "<p>I am very well aware that passing directly a <code>const char*</code> as a template non-type parameter is erroneous, since two identical string literals defined in two different translation units may have different addresses (although most of the time the compilers use the same address). There is a trick one may use, see code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;const char* msg&gt;\nvoid display()\n{\n    std::cout &lt;&lt; msg &lt;&lt; std::endl;\n}\n\n// need to have external linkage \n// so that there are no multiple definitions\nextern const char str1[] = \"Test 1\"; // (1)\n\n// Why constexpr is enough? Does it have external linkage?\nconstexpr char str2[] = \"Test 2\";    // (2)\n\n// Why doesn't this work? \nextern const char* str3 = \"Test 3\";  // (3) doesn't work\n\n// using C_PTR_CHAR = const char* const;   // (4) doesn't work either\nextern constexpr C_PTR_CHAR str4 = \"Test 4\"; \n\nint main()\n{\n    display&lt;str1&gt;();    // (1')\n    display&lt;str2&gt;();    // (2')\n    // display&lt;str3&gt;(); // (3') doesn't compile \n    //display&lt;str4&gt;();  // (4') doesn't compile\n}\n</code></pre>\n<p>Basically in (1) we declare and <em>define</em> an array with external linkage, which can then be used as a template parameter in (1'). I understand this very well. However, I don't understand:</p>\n<ol>\n<li><p>Why the <code>constexpr</code> version (2) works? Do <code>constexpr</code> have external linkage? If not, then defining the same string literal in a different translation unit may lead with duplicate template instantiation. </p></li>\n<li><p>Why (3) and (4) don't work? It seems perfectly reasonable for me, but the compiler doesn't believe so:</p>\n<blockquote>\n<p id=\"so_30604686_30604686_0\">error: 'str3' is not a valid template argument because 'str3' is a variable, not the address of a variable</p>\n</blockquote></li>\n</ol>\n", "AcceptedAnswerId": "30604988", "Title": "Template tricks with const char* as a non-type parameter", "CreationDate": "2015-06-02T19:15:11.283", "Id": "30604686", "CommentCount": "14", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-06-02T19:34:58.813", "LastEditorUserId": "3093378", "LastActivityDate": "2015-06-03T00:06:23.143", "Score": "18", "OwnerUserId": "3093378", "Tags": "<c++><templates><c++11><constexpr>", "AnswerCount": "1"}});