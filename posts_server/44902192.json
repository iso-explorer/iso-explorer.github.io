post_cb({"bq_ids": {"n4140": {"so_44902192_44902192_1": {"length": 5, "quality": 0.625, "section_id": 5451}, "so_44902192_44902192_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 5451}}, "n3337": {"so_44902192_44902192_2": {"length": 24, "quality": 0.8275862068965517, "section_id": 5245}}, "n4659": {"so_44902192_44902192_1": {"length": 8, "quality": 1.0, "section_id": 6887}, "so_44902192_44902192_2": {"length": 29, "quality": 1.0, "section_id": 6889}}}, "44902192": {"ViewCount": "72", "Body": "<p>I'm hereby strictly referring to the c++ draft (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">N4659</a>). Given the following example,</p>\n<pre><code>int&amp;&amp; f();\nauto x5a = f(); // decltype(x5a) is int\n</code></pre>\n<p>I'm not sure <strong>why the deduced type is <code>int</code>, instead of <code>int&amp;&amp;</code></strong>. Scott Meyers said in his book that </p>\n<blockquote>\n<p id=\"so_44902192_44902192_0\">..., the reference-ness of an initializing expression is ignored.</p>\n</blockquote>\n<p><strong>However, I couldn't find any paragraph in the above draft which ensures the statement.</strong> Here's the steps I took in order to deduce the type:</p>\n<ol>\n<li><p>According to 10.1.7.4.1 [dcl.type.auto.deduct] paragraph 2,</p>\n<blockquote>\n<p id=\"so_44902192_44902192_1\">A type <code>T</code> containing a placeholder type, and a corresponding initializer <code>e</code>, are determined as follows:</p>\n<ul>\n<li>...</li>\n<li>for a variable declared with a type that contains a placeholder type, <code>T</code> is the declared type of the variable and <code>e</code> is the initializer...</li>\n</ul>\n</blockquote>\n<p><strong>Therefore, <code>T</code> is <code>auto</code>, and <code>e</code> is <code>f()</code>.</strong></p></li>\n<li><p>As per 10.1.7.4.1 [dcl.type.auto.deduct] paragraph 4,</p>\n<blockquote>\n<p id=\"so_44902192_44902192_2\">If the placeholder is the auto <em>type-specifier</em>, ... Obtain <code>P</code> from <code>T</code> by replacing the occurrences of auto with either a new invented\n  type template parameter <code>U</code> or, ... Deduce a value for <code>U</code> <strong>\"using the rules of template argument deduction from a function call\"</strong>, where\n  <code>P</code> is a function template parameter type and the corresponding argument is <code>e</code>...</p>\n</blockquote>\n<p><strong>Therefore, <code>P</code> is <code>U</code>, and <code>A</code> is <code>int&amp;&amp;</code>.</strong></p></li>\n<li><p>According to 17.8.2.1 [temp.deduct.call] paragraph 2,</p>\n<blockquote>\n<p id=\"so_44902192_44902192_3\">If <code>P</code> is not a reference type:</p>\n<ol>\n<li>If <code>A</code> is an array type, ...</li>\n<li>If <code>A</code> is a function type, ...</li>\n<li>If <code>A</code> is a cv-qualified type, ...</li>\n</ol>\n</blockquote>\n<p><strong>Although <code>P = U</code> is indeed not a reference type, <code>A = int&amp;&amp;</code> stays that way because the three cases above are not applicable to <code>A</code>.</strong></p></li>\n</ol>\n<p>These are the only paragraphs that I've found which I think is relevant to this particular case. <strong>In conclusion, <code>U = int&amp;&amp;</code>, and the entire <code>T</code> is also <code>int&amp;&amp;</code>.</strong> </p>\n<p>I'm definitely missing something here, and I'm not sure what those are. <strong>If you're kind enough to answer this question, would you confine yourself to the formal wording (with the help of the c++ draft or standard)?</strong></p>\n", "Title": "Concerning placeholder type deduction", "CreationDate": "2017-07-04T09:32:19.967", "LastActivityDate": "2017-07-04T09:32:19.967", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "Id": "44902192", "Score": "3", "OwnerUserId": "5645940", "Tags": "<c++><language-lawyer>", "AnswerCount": "0"}});