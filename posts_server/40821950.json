post_cb({"40822131": {"ParentId": "40821950", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Preconditions for <code>is_default_constructible</code> state quite clearly:</p>\n<blockquote>\n<p id=\"so_40821950_40822131_0\">N4140 \u00a7 20.10.4.3 [meta.unary.prop] / <code>is_default_constructible</code> row</p>\n<p id=\"so_40821950_40822131_1\"><code>T</code> shall be a complete type, (possibly <em>cv</em>-qualified) <code>void</code>, or an\n  array of unknown bound.</p>\n</blockquote>\n<p>And according to the following, your program exhibits undefined behaviour:</p>\n<blockquote>\n<p id=\"so_40821950_40822131_2\">N4140 \u00a7 17.6.4.8 [res.on.functions] / 2</p>\n<p id=\"so_40821950_40822131_3\">the effects are undefined in the following cases:</p>\n<ul>\n<li>[...]</li>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for\n  that component.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2456565", "LastEditorUserId": "2456565", "LastEditDate": "2016-11-27T05:46:07.003", "Id": "40822131", "Score": "5", "CreationDate": "2016-11-26T19:15:49.577", "LastActivityDate": "2016-11-27T05:46:07.003"}, "bq_ids": {"n4140": {"so_40821950_40822131_3": {"section_id": 6324, "quality": 1.0, "length": 4}, "so_40821950_40822131_1": {"section_id": 4706, "quality": 1.0, "length": 8}}, "n3337": {"so_40821950_40822131_3": {"section_id": 6081, "quality": 1.0, "length": 4}, "so_40821950_40822131_1": {"section_id": 4515, "quality": 1.0, "length": 8}}, "n4659": {"so_40821950_40822131_3": {"section_id": 7834, "quality": 1.0, "length": 4}, "so_40821950_40822131_1": {"section_id": 6103, "quality": 0.625, "length": 5}}}, "40821950": {"CommentCount": "0", "ViewCount": "258", "CreationDate": "2016-11-26T18:57:32.353", "LastActivityDate": "2016-11-27T05:46:07.003", "Title": "SFINAE with std::enable_if and std::is_default_constructible for incomplete type in libc++", "AcceptedAnswerId": "40822131", "PostTypeId": "1", "Id": "40821950", "Score": "3", "Body": "<p>I just observed a strange issue with libc++ when using SFINAE to detect if a templated type is default constructible.</p>\n<p>The following is a minimal example I was able to come up with:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nstruct Dummy;\n\ntemplate &lt;&gt;\nstruct Dummy&lt;int&gt;{};\n\ntemplate &lt;typename T, typename = void&gt;\nstruct has_dummy : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_dummy&lt;C, std::enable_if_t&lt;std::is_default_constructible&lt;Dummy&lt;T&gt;&gt;::value&gt;&gt; : std::true_type{};\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; has_dummy&lt;int&gt;{}() &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; has_dummy&lt;double&gt;{}() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>It compiles and outputs the expected lines <code>true</code> and <code>false</code> when compiled with g++ or clang++ when using <code>libstdc++</code>. However when I try to compile it with libc++ (i.e. <code>clang++ -stdlib=libc++ -std=c++1z test.cpp</code>) I get the following error:</p>\n<blockquote>\n<p id=\"so_40821950_40821950_0\">/usr/bin/../include/c++/v1/type_traits:2857:38: error: implicit instantiation of undefined template\n       'Dummy'\n      : public integral_constant</p>\n<p id=\"so_40821950_40821950_1\">/usr/bin/../include/c++/v1/type_traits:3166:14: note: in instantiation of template class\n        'std::__1::is_constructible&gt;' requested here\n      : public is_constructible&lt;_Tp&gt;</p>\n<p id=\"so_40821950_40821950_2\">test.cpp:14:43: note: in instantiation of template class 'std::__1::is_default_constructible &gt;'\n        requested here <code>\n   struct has_dummy&lt;T, std::enable_if_t&lt;std::is_default_constructible&lt;Dummy&lt;T&gt;&gt;::value&gt;&gt; : std::true_type{};</code></p>\n<p id=\"so_40821950_40821950_3\">test.cpp:18:35: note: during template argument deduction for class template partial specialization\n        <code>'has_dummy&lt;type-parameter-0-0, typename enable_if&lt;std::is_default_constructible&lt;Dummy&lt;T&gt; &gt;::value,\n        void&gt;::type&gt;' [with T = double]</code></p>\n<pre><code>   std::cout &lt;&lt; std::boolalpha &lt;&lt; has_dummy&lt;double&gt;{}() &lt;&lt; '\\n';\n</code></pre>\n<p id=\"so_40821950_40821950_4\">test.cpp:5:8: note: template is declared here\n  <code>struct Dummy;</code></p>\n</blockquote>\n<p>Is this a bug in libc++'s implementation of <code>std::enable_if</code> or <code>std::is_default_constructible</code> or is what I'm doing somehow invoking undefined/implementation specific behaviour?</p>\n<p>Best\nCorristo</p>\n", "Tags": "<c++><templates><language-lawyer><sfinae><libc++>", "OwnerUserId": "3601321", "AnswerCount": "1"}});