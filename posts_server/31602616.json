post_cb({"31602999": {"ParentId": "31602616", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Your original code <code>throw;</code> when you have nothing to rethrow. That causes <code>std::terminate</code> to be called; the stack is not unwound (and hence the destructors don't run). </p>\n<p>Your new code throws an exception without handling it. In that case whether the stack is unwound is implementation-defined, so it's still perfectly conforming to <code>terminate()</code> right away. [except.terminate], emphasis mine:</p>\n<blockquote>\n<p id=\"so_31602616_31602999_0\">In some situations exception handling must be abandoned for less\n  subtle error handling techniques. [ <em>Note</em>: These situations are:</p>\n<ul>\n<li>when the exception handling mechanism, after completing the initialization of the exception object but before activation of a\n  handler for the exception (15.1), calls a function that exits via an\n  exception, or</li>\n<li><strong>when the exception handling mechanism cannot find a handler for a thrown exception (15.3)</strong>, or</li>\n<li>when the search for a handler (15.3) encounters the outermost block of a function with a noexcept-specification that does not allow the\n  exception (15.4), or</li>\n<li>when the destruction of an object during stack unwinding (15.2) terminates by throwing an exception, or</li>\n<li>when initialization of a non-local variable with static or thread storage duration (3.6.2) exits via an exception, or</li>\n<li>when destruction of an object with static or thread storage duration exits via an exception (3.6.3), or </li>\n<li>when execution of a function registered with <code>std::atexit</code> or <code>std::at_quick_exit</code> exits via an exception (18.5), or</li>\n<li><strong>when a <em>throw-expression</em> (5.17) with no operand attempts to rethrow an exception and no exception is being handled (15.1)</strong>, or</li>\n<li>when <code>std::unexpected</code> exits via an exception of a type that is not allowed by the previously violated exception specification, and\n  std::bad_exception is not included in that exception specification\n  (15.5.2), or</li>\n<li>when the implementation\u2019s default unexpected exception handler is called (D.8.1), or</li>\n<li>when the function <code>std::nested_exception::rethrow_nested</code> is called for an object that has captured no exception (18.8.6), or</li>\n<li>when execution of the initial function of a thread exits via an exception (30.3.1.2), or</li>\n<li>when the destructor or the copy assignment operator is invoked on an object of type <code>std::thread</code> that refers to a joinable thread\n  (30.3.1.3, 30.3.1.4), or</li>\n<li>when a call to a <code>wait()</code>, <code>wait_until()</code>, or <code>wait_for()</code> function on a condition variable (30.5.1, 30.5.2) fails to meet a\n  postcondition. \u2014<em>end note</em> ]</li>\n</ul>\n<p id=\"so_31602616_31602999_1\">In such cases, <code>std::terminate()</code> is called (18.8.3). <strong>In the situation\n  where no matching handler is found, it is implementation-defined\n  whether or not the stack is unwound before <code>std::terminate()</code> is\n  called.</strong> In the situation where the search for a handler (15.3)\n  encounters the outermost block of a function with a\n  <em>noexcept-specification</em> that does not allow the exception (15.4), it is implementation-defined whether the stack is unwound, unwound\n  partially, or not unwound at all before <code>std::terminate()</code> is called.\n  <strong>In all other situations, the stack shall not be unwound before\n  <code>std::terminate()</code> is called.</strong> An implementation is not permitted to\n  finish stack unwinding prematurely based on a determination that the\n  unwind process will eventually cause a call to <code>std::terminate()</code>.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-07-24T05:43:11.460", "Id": "31602999", "Score": "21", "CreationDate": "2015-07-24T05:41:22.910", "LastActivityDate": "2015-07-24T05:43:11.460"}, "31602616": {"CommentCount": "8", "AcceptedAnswerId": "31602999", "PostTypeId": "1", "LastEditorUserId": "1932452", "CreationDate": "2015-07-24T05:09:56.393", "LastActivityDate": "2015-07-24T05:43:11.460", "LastEditDate": "2015-07-24T05:42:27.087", "ViewCount": "828", "FavoriteCount": "3", "Title": "Why is a unique_ptr not freed after a constructor calls an exception?", "Id": "31602616", "Score": "20", "Body": "<p>In the following code:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nvoid mydeallocator(int * x) {\n    std::cerr &lt;&lt; \"Freeing memory\" &lt;&lt; std::endl;\n    delete x;\n}\n\nstruct Foo {\n    std::unique_ptr &lt;int,std::function &lt;void(int*)&gt;&gt; x;\n    Foo(bool fail) : x(new int(1),mydeallocator) {\n        if(fail)\n            throw std::runtime_error(\"We fail here\");\n    }\n};\n\nint main() {\n    {auto foo1 = Foo(false);}\n    {auto foo2 = Foo(true);}\n}\n</code></pre>\n<p>It appears that memory is not being deallocated properly when <code>Foo(true)</code> is called.  Namely, when we compile and run this program, we have the result:</p>\n<pre><code>Freeing memory\nterminate called after throwing an instance of 'std::runtime_error'\n  what():  We fail here\nAborted\n</code></pre>\n<p>I believe that the message <code>Freeing memory</code> should be called twice.  Basically, according to this <a href=\"https://stackoverflow.com/questions/1197566/is-it-ever-not-safe-to-throw-an-exception-in-a-constructor\">question</a> and the ISO C++ folks <a href=\"https://isocpp.org/wiki/faq/exceptions#ctors-can-throw\" rel=\"noreferrer\">here</a> and <a href=\"https://isocpp.org/wiki/faq/exceptions#selfcleaning-members\" rel=\"noreferrer\">here</a>, my understanding is that the stack should unwind on the constructor for <code>Foo</code> and that <code>x</code> should call its destructor, which should call <code>mydeallocator</code>.  Certainly, this is not happening, so why is the memory not being freed?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1932452", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31602616_31602999_0": {"section_id": 3382, "quality": 0.8571428571428571, "length": 12}, "so_31602616_31602999_1": {"section_id": 3383, "quality": 0.9230769230769231, "length": 60}}, "n3337": {"so_31602616_31602999_0": {"section_id": 3251, "quality": 0.8571428571428571, "length": 12}, "so_31602616_31602999_1": {"section_id": 3252, "quality": 0.9230769230769231, "length": 60}}, "n4659": {"so_31602616_31602999_0": {"section_id": 4142, "quality": 0.8571428571428571, "length": 12}, "so_31602616_31602999_1": {"section_id": 4143, "quality": 0.8769230769230769, "length": 57}}}});