post_cb({"bq_ids": {"n4140": {"so_18174368_25736581_0": {"length": 54, "quality": 0.9818181818181818, "section_id": 219}, "so_18174368_25736581_2": {"length": 74, "quality": 1.0, "section_id": 223}, "so_18174368_18174368_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 238}, "so_18174368_25736581_1": {"length": 16, "quality": 1.0, "section_id": 220}, "so_18174368_18174368_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 220}, "so_18174368_18174368_2": {"length": 35, "quality": 0.9210526315789473, "section_id": 243}}, "n3337": {"so_18174368_25736581_0": {"length": 54, "quality": 0.9818181818181818, "section_id": 212}, "so_18174368_25736581_2": {"length": 74, "quality": 1.0, "section_id": 216}, "so_18174368_18174368_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 230}, "so_18174368_25736581_1": {"length": 16, "quality": 1.0, "section_id": 213}, "so_18174368_18174368_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 213}, "so_18174368_18174368_2": {"length": 35, "quality": 0.9210526315789473, "section_id": 235}}, "n4659": {"so_18174368_25736581_0": {"length": 54, "quality": 0.9818181818181818, "section_id": 227}, "so_18174368_25736581_2": {"length": 72, "quality": 0.972972972972973, "section_id": 231}, "so_18174368_18174368_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 242}, "so_18174368_25736581_1": {"length": 16, "quality": 1.0, "section_id": 228}, "so_18174368_18174368_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 228}, "so_18174368_18174368_2": {"length": 33, "quality": 0.868421052631579, "section_id": 250}}}, "25736581": {"Id": "25736581", "PostTypeId": "2", "Body": "<p>This appears to be a result of the compiler delaying instantiation of <code>CRTP&lt;Derived, Base&gt;::DoSomething()</code> until the end of the translation unit, as it is allowed to do (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#993\" rel=\"nofollow\">CWG issue 993</a>).</p>\n<p><code>CRTP&lt;Derived, Base&gt;</code> is definitely instantiated right before the definition of <code>Derived</code> (\u00a714.6.4.1 [temp.point]/p4, all quotes are to N3936): </p>\n<blockquote>\n<p id=\"so_18174368_25736581_0\">For a class template specialization, a class member template\n  specialization, or a specialization for a class member of a class\n  template, if the specialization is implicitly instantiated because it\n  is referenced from within another template specialization, if the\n  context from which the specialization is referenced depends on a\n  template parameter, and if the specialization is not instantiated\n  previous to the instantiation of the enclosing template, the point of\n  instantiation is immediately before the point of instantiation of the\n  enclosing template. Otherwise, <strong>the point of instantiation for such a\n  specialization immediately precedes the namespace scope declaration or\n  definition that refers to the specialization.</strong></p>\n</blockquote>\n<p>Whether <code>CRTP&lt;Derived, Base&gt;::DoSomething()</code> is required to be instantiated at all depends on the meaning of the phrase <em>referenced in a context that requires the member definition to exist</em> (\u00a714.7.1 [temp.inst]/p2). All non-pure virtual functions are odr-used (\u00a73.2 [basic.def.odr]/p2), and \"every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program\" (\u00a73.2 [basic.def.odr]/p4); whether that counts as \"referenced in a context that requires the member definition to exist\" is unclear. </p>\n<p>(Even if it's not <em>required</em> to be instantiated, however, the compiler is still free to instantiate it per \u00a714.7.1 [temp.inst]/p11 - \"It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated.\".)</p>\n<p>If <code>CRTP&lt;Derived, Base&gt;::DoSomething()</code> is indeed instantiated, then the situation is covered by \u00a714.6.4.1 [temp.point]/p5 and p8 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18174368_25736581_1\">5 If a virtual function is implicitly instantiated, its point of\n  instantiation is immediately following the point of instantiation of\n  its enclosing class template specialization.</p>\n<p id=\"so_18174368_25736581_2\">8 <strong>A specialization</strong> for a function template, a member function template,\n  or <strong>of a member function</strong> or static data member <strong>of a class template may\n  have multiple points of instantiations within a translation unit, and\n  in addition to the points of instantiation described above, for any\n  such specialization that has a point of instantiation within the\n  translation unit, the end of the translation unit is also considered a\n  point of instantiation.</strong> A specialization for a class template has at\n  most one point of instantiation within a translation unit. A\n  specialization for any template may have points of instantiation in\n  multiple translation units. <strong>If two different points of instantiation\n  give a template specialization different meanings according to the one\n  definition rule (3.2), the program is ill-formed, no diagnostic\n  required.</strong></p>\n</blockquote>\n<p>That is, it has two points of instantiation, one right after <code>CRTP&lt; Derived, Base &gt;</code>'s point of instantiation, and one at the end of the translation unit. In this case, at the two points of instantiations name lookup for <code>typename T::Type</code> would produce different results, so the program is ill-formed, no diagnostic required.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-15T23:53:23.510", "Score": "5", "CreationDate": "2014-09-09T04:13:39.417", "ParentId": "18174368", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2014-09-15T23:53:23.510"}, "18174368": {"ViewCount": "870", "Body": "<p>I'm trying to understand if a simple CRTP pattern is valid by the standard.</p>\n<p>The code below compiles and works as expected (on clang).</p>\n<p>But my understanding of the relevant standard chapters/paragraphs is that \nthe point of instantiation of the virtual function CRTP&lt; Derived, Base &gt;::DoSomething()\nshould be at point (B) of the code, where the full declaration of Derived is not available.\nTherefore the inner typedef Type should not be available either.</p>\n<p>Can anyone kindly point out the relevant standard chapter that validates this code?</p>\n<p>In other words, something that says that in this case the virtual function is instantiated\nATFER point C?\nThanks a lot in advance for any insight.</p>\n<p>Francesco</p>\n<pre><code>//-------------------------\n// START CODE\n\n#include &lt;iostream&gt;\n\nstruct Type1 {};\nstruct Type2 {};\n\nstruct Base\n{\n  virtual ~Base() {}\n  virtual void DoSomething() = 0;\n};\n\ntemplate&lt; typename T, typename U &gt;\nstruct CRTP : U\n{\n  virtual void DoSomething() { DoSomething( typename T::Type() ); }\n\n void DoSomething( Type1 ) { std::cout &lt;&lt; \"1\\n\"; }\n void DoSomething( Type2 ) { std::cout &lt;&lt; \"2\\n\"; }\n};\n\n// (A) point of inst. of CRTP&lt; Derived, Base &gt; ( 14.7.1.4 ) ??\n// (B) point of inst. of CRTP&lt; Derived, Base &gt;::DoSomething() (14.6.4.1.4 ) ??\n\nstruct Derived : CRTP&lt; Derived, Base &gt;\n{\n  typedef Type2 Type;\n};\n\n// (C)\n\nint main()\n{\n  Base *  ptr = new Derived;\n  ptr-&gt;DoSomething();\n  delete ptr;\n}\n\n// END CODE\n//-------------------------\n</code></pre>\n<p>Relevant (?) standard paragraphs:</p>\n<blockquote>\n<p id=\"so_18174368_18174368_0\">14.6.4.1\n  4 If a virtual function is implicitly instantiated, <b>its point of instantiation is immediately following the point of instantiation of its enclosing class template specialization</b>.</p>\n<p id=\"so_18174368_18174368_1\">14.7.1\n  4 A class template specialization is implicitly instantiated if the class type is used in a context that requires a completely-defined object type or if the completeness of the class type might affect the semantics of the program.</p>\n<p id=\"so_18174368_18174368_2\">14.7.1\n  9 An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, a member class, or a static data member of a class template that does not require instan- tiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated.</p>\n</blockquote>\n", "AcceptedAnswerId": "25736581", "Title": "C++ CRTP virtual function point of instantiation", "CreationDate": "2013-08-11T16:54:07.043", "Id": "18174368", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-15T23:53:23.510", "Score": "12", "OwnerUserId": "1986452", "Tags": "<c++><templates><crtp>", "AnswerCount": "2"}, "25732167": {"Id": "25732167", "PostTypeId": "2", "Body": "<p>The use of <code>new Derived</code> causes the <code>Derived</code> class to be instantiated.  </p>\n<blockquote>\n<p id=\"so_18174368_25732167_0\">Correction: <code>Derived</code> is not itself a template, so its structure layout and contained member declarations are needed right away.  That causes <code>CRTP&lt;Derived,Base&gt;</code> to be instantiated immediately following the Derived definition.  I'll have to look up the formal standard later when I have more time; but the the point is still that the instantiation of CRTP only figures out the structure and available members, not the bodies of the member functions; and it knows the structure and members of the Derived class when it does so.  </p>\n<p id=\"so_18174368_25732167_1\">The member functions are not instantiated until they are used (here, the constructor), and it already has the class itself at that time.  The other thing to look up is whether the constructor of Derived, since it is not a template, is generated immediately following the class, or only if/when needed.  If the former, it can be made lazy by making Derived a template with a dummy argument.  But that doesn't affect this specific question: whether right after <code>Derived</code> or right after <code>main</code>, the function instantiation is still <em>not</em> before parsing the declaration of <code>Derived</code>.</p>\n</blockquote>\n<p>That causes <code>CRTP&lt;Derived,Base&gt;</code> to be instantiated.  But in both cases it is only the class structure that is needed, not the actual code for any of the members.  Erase all the inline function bodies, and you'll see there is no problem at this point.</p>\n<p>Now the Derived default constructor is used, so <code>Derived::Derived()</code> is implicitly instantiated.  The point of instantiation is immediately following the definition of <code>main</code>.  </p>\n<p>In instantiating <code>Derived::Derived()</code>, it then needs <code>CRTP&lt;Derived,Base&gt;::CRTP()</code>.  It is instantiated at the same point as the template instantiation that needed it.  That constructor needs all the virtual functions, so <code>DoSomething()</code> is instantiated, again, at the same point as the instantiation that kicked it off.  You can see that all this happens well after the complete definition of the fully rendered Derived class is known, in terms of all the declarations of all the members (not the function bodies).</p>\n<p>That's the missing insight:  the class definition does not include member function definitions, even if they are given within the lexical enclosing region of the class definition.  Remember the distinction between <em>definitions</em> and <em>declarations</em>, separately for classes and functions.</p>\n", "LastEditorUserId": "658087", "LastActivityDate": "2014-09-09T14:09:49.780", "Score": "0", "CreationDate": "2014-09-08T19:58:28.813", "ParentId": "18174368", "CommentCount": "6", "OwnerUserId": "658087", "LastEditDate": "2014-09-09T14:09:49.780"}});