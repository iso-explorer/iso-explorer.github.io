post_cb({"12362107": {"ParentId": "12362024", "CommentCount": "3", "Body": "<p>A compiler is free to inline any function that it has the definition for, if it chooses to do so. Once it is inlined there is no need for another definition in another file.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "12362107", "Score": "4", "CreationDate": "2012-09-11T02:56:57.887", "LastActivityDate": "2012-09-11T02:56:57.887"}, "36714283": {"ParentId": "12362024", "CommentCount": "0", "Body": "<p>According to the standard in section 14.7.3,</p>\n<blockquote>\n<p id=\"so_12362024_36714283_0\">Except for inline functions and class template specializations,\n  explicit instantiation declarations have the effect of suppressing the\n  implicit instantiation of the entity to which they refer.</p>\n</blockquote>\n<p>In your first example <code>Calc&lt;int&gt;::add</code> is inline.</p>\n<blockquote>\n<p id=\"so_12362024_36714283_1\">[ Note: The intent is that an inline function that is the subject of\n  an explicit instantiation declaration will still be implicitly\n  instantiated when odr-used (3.2) so that the body can be considered\n  for inlining, but that no out-of-line copy of the inline function\n  would be generated in the translation unit. \u2014 end note ]</p>\n</blockquote>\n<p>Keep in mind, that although the member function is inline, the compiler is free to decide if it will actually be inlined or not.</p>\n", "OwnerUserId": "1557062", "PostTypeId": "2", "Id": "36714283", "Score": "0", "CreationDate": "2016-04-19T09:30:25.893", "LastActivityDate": "2016-04-19T09:30:25.893"}, "bq_ids": {"n4140": {"so_12362024_36714283_1": {"section_id": 259, "quality": 0.8620689655172413, "length": 25}, "so_12362024_36714283_0": {"section_id": 259, "quality": 1.0, "length": 17}}, "n3337": {"so_12362024_36714283_1": {"section_id": 250, "quality": 0.8620689655172413, "length": 25}, "so_12362024_36714283_0": {"section_id": 250, "quality": 1.0, "length": 17}}, "n4659": {"so_12362024_36714283_1": {"section_id": 266, "quality": 0.8620689655172413, "length": 25}, "so_12362024_36714283_0": {"section_id": 266, "quality": 1.0, "length": 17}}}, "12362024": {"CommentCount": "2", "ViewCount": "650", "PostTypeId": "1", "LastEditorUserId": "670478", "CreationDate": "2012-09-11T02:44:09.740", "LastActivityDate": "2016-04-19T09:30:25.893", "Title": "msvc 11 only respects C++ extern templates in certain situations", "LastEditDate": "2012-09-11T03:01:13.713", "Id": "12362024", "Score": "1", "Body": "<p>I'm messing around with C++ extern templates to speed up compilation. I've noticed that Visual Studio 2012 has made some improvements in its handling of <code>extern template</code>, but I'm still finding issues. Here's an example:</p>\n<p><strong>main.cpp:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include \"Calc.h\"\n\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n    Calc&lt;int&gt; c1;\n    cout &lt;&lt; c1.add(1, 2) &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>Calc.h:</strong></p>\n<pre><code>#pragma once\n\ntemplate &lt;class A_Type&gt;\nclass Calc\n{\npublic:\n    A_Type add(A_Type x, A_Type y)\n    {\n        return x + y;\n    }\n};\n\nextern template class Calc&lt;int&gt;;\n</code></pre>\n<p>Normally I'd include <strong>Calc.cpp</strong> with <code>template class Calc&lt;int&gt;;</code>, ensuring the template is only instantiated once. For this example, I am only compiling <strong>Main.cpp</strong> and expecting it to fail.</p>\n<p>The problem is, Visual Studio 2012 will happily compile and link the code above. It's not respecting the <code>extern template</code>. The only solution I've found is to do this in the header:</p>\n<p><strong>Calc.h:</strong></p>\n<pre><code>#pragma once\n\ntemplate &lt;class A_Type&gt;\nclass Calc\n{\npublic:\n    A_Type add(A_Type x, A_Type y);\n};\n\ntemplate &lt;class A_Type&gt; A_Type Calc&lt;A_Type&gt;::add(A_Type x, A_Type y)\n{\n    return x + y;\n}\n\nextern template class Calc&lt;int&gt;;\n</code></pre>\n<p>Visual Studio fails to link if the header is like this (complaining about a missing definition for <code>Calc&lt;int&gt;::add</code>, as expected). <strong>However</strong>, <em>g++ 4.6.3</em> Fails to link either of these examples.</p>\n<p>Who is right? If both the prototypes and definitions of functions in a class are specified in the same header file, is there really a difference? Is there any way to specify the \"shorter-form\" <em>Calc.h</em> and have it fail as expected in Visual Studio 2012 (as well as gcc)?</p>\n", "Tags": "<c++><templates><visual-c++><c++11>", "OwnerUserId": "670478", "AnswerCount": "2"}});