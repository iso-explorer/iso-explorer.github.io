post_cb({"bq_ids": {"n4140": {"so_10043716_10043883_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 6325}, "so_10043716_10046261_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 744}, "so_10043716_10046261_7": {"length": 24, "quality": 0.8571428571428571, "section_id": 744}, "so_10043716_10046261_3": {"length": 23, "quality": 0.92, "section_id": 763}}, "n3337": {"so_10043716_10043883_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 6082}, "so_10043716_10046261_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 733}, "so_10043716_10046261_7": {"length": 24, "quality": 0.8571428571428571, "section_id": 733}, "so_10043716_10046261_3": {"length": 23, "quality": 0.92, "section_id": 750}}, "n4659": {"so_10043716_10043883_0": {"length": 28, "quality": 0.8484848484848485, "section_id": 7835}, "so_10043716_10046261_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 802}, "so_10043716_10046261_7": {"length": 24, "quality": 0.8571428571428571, "section_id": 802}, "so_10043716_10046261_3": {"length": 23, "quality": 0.92, "section_id": 823}}}, "10043854": {"Id": "10043854", "PostTypeId": "2", "Body": "<p>It is correct.</p>\n<p>Of course -when dealing with philosophy- anything can be questioned, but the compiler must do somehow.</p>\n<p>The choice of the designers was that -to perform a <em>move</em>- there must be a place to <em>go</em>.\nIf there is no such a place, the move doesn't happen.</p>\n<p>Note that whatever function takes a &amp;&amp;, it assume the the parameter is \"temporary\": if it doesn't \"stole\" the data, the temporary will be destroyed at the expression end.\nIf the temporariness had been <em>coerced</em> (via std::move), the object will stay in any case there until destroyed by its own scope. With or without its original data inside.</p>\n", "LastActivityDate": "2012-04-06T13:02:54.327", "Score": "0", "CreationDate": "2012-04-06T13:02:54.327", "ParentId": "10043716", "CommentCount": "2", "OwnerUserId": "924727"}, "10043716": {"ViewCount": "619", "Body": "<p>This question is about the specification of several functions in the C++11 Standard Library, that take their arguments as rvalue references, but do not consume them in all cases. One example is \n<code>std::unordered_set&lt;T&gt;::insert(T&amp;&amp;)</code>.</p>\n<p>It is pretty clear, that this method will use the move constructor of <code>T</code> to construct the element within the container, if it does not already exist. However, what happens if the element already exists in the container? I am pretty sure there is no reason the change the object in the case. However, I didn't find anything in the C++11 Standard supporting my claim.</p>\n<p>Here is an example to show why this might be interesting. The following code reads lines from std::cin and remove the first occurrence of duplicate lines.</p>\n<pre><code>std::unordered_set&lt;std::string&gt; seen;\nstd::string line;\nwhile (getline(std::cin, line)) {\n    bool inserted = seen.insert(std::move(line)).second;\n    if (!inserted) {\n        /* Is it safe to use line here, i.e. can I assume that the\n         * insert operation hasn't changed the string object, because \n         * the string already exists, so there is no need to consume it. */\n        std::cout &lt;&lt; line &lt;&lt; '\\n';\n    }\n}\n</code></pre>\n<p>Apparently, this example works with GCC 4.7. But I am not sure, if it is correct according to the standard.</p>\n", "AcceptedAnswerId": "10043883", "Title": "std::unordered_set<T>::insert(T&&): is argument moved if it exists", "CreationDate": "2012-04-06T12:49:32.477", "Id": "10043716", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-20T08:06:57.023", "LastEditorUserId": "573032", "LastActivityDate": "2016-03-20T08:06:57.023", "Score": "16", "OwnerUserId": "1305501", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "10046261": {"Id": "10046261", "PostTypeId": "2", "Body": "<p>The semantics given for <code>insert</code> on unordered associative containers in \u00a723.2.5/Table 103 don't specify whether the the move constructor of the argument to <code>insert</code> is invoked if the insert fails, the wording only talks about whether the insertion happens:</p>\n<blockquote>\n<p id=\"so_10043716_10046261_0\"><strong><code>a_uniq.insert(t)</code></strong></p>\n<p id=\"so_10043716_10046261_1\">Returns: <code>pair&lt;iterator, bool&gt;</code></p>\n<p id=\"so_10043716_10046261_2\">Requires: If <code>t</code> is a non-const\n  rvalue expression, <code>T</code> shall be MoveInsertable into X; otherwise, <code>T</code>\n  shall be CopyInsertable into <code>X</code>.</p>\n<p id=\"so_10043716_10046261_3\">Effects: Inserts <code>t</code> if and only if\n  there is no element in the container with key equivalent to the key of\n  <code>t</code>. The bool component of the returned pair indicates whether the\n  insertion takes place, and the iterator component points to the\n  element with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p><s>\nHowever, the specification for <code>emplace</code> is clearer (also from Table 103), and you should be able to use it instead of <code>insert</code> to get the guarantees you want:</s></p>\n<blockquote>\n<p id=\"so_10043716_10046261_4\"><strong><code>a_uniq.emplace(args)</code></strong></p>\n<p id=\"so_10043716_10046261_5\">Returns: <code>pair&lt;iterator, bool&gt;</code></p>\n<p id=\"so_10043716_10046261_6\">Requires: T shall be\n  EmplaceConstructible into <code>X</code> from args.</p>\n<p id=\"so_10043716_10046261_7\">Effects: Inserts a <code>T</code> object <code>t</code>\n  constructed with std::forward(args)... <em>if and only if there is\n  no element in the container with key equivalent to the key of <code>t</code></em>. The\n  bool component of the returned pair is true if and only if the\n  insertion takes place, and the iterator component of the pair points\n  to the element with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>I interpret this to mean ((Inserts a <code>T</code> object <code>t</code> constructed ...) (if and only if there is no element in the container ...)), <em>i.e.</em> both the insertion and construction should only happen if there is no matching element already in the container. If no object is constructed , the <code>std::string</code> you pass in will never be passed to a move constructor, and therefore will still be valid after the failed <code>emplace</code> call.</p>\n<p>gcc 4.7.0 doesn't seem to support <code>unordered_set::emplace</code>, but it is in the standard (\u00a723.5.6.1)</p>\n<p></p>\n<p>As @NicolBolas pointed out in the comments, and despite the above, it's impossible to implement an <code>emplace</code> function that doesn't construct a <code>T</code> if a conflicting entry already exists.</p>\n<p>So the only way to get the semantics you want in a way that is standards-conforming would be to do a <code>find</code> followed by, conditionally, an <code>insert</code> or <code>emplace</code>.</p>\n", "LastEditorUserId": "1030301", "LastActivityDate": "2012-04-06T17:09:19.913", "Score": "1", "CreationDate": "2012-04-06T16:25:42.757", "ParentId": "10043716", "CommentCount": "2", "LastEditDate": "2012-04-06T17:09:19.913", "OwnerUserId": "1030301"}, "10043883": {"Id": "10043883", "PostTypeId": "2", "Body": "<p>I found this note in the standard (17.4.6.9):</p>\n<blockquote>\n<p id=\"so_10043716_10043883_0\">[ <em>Note</em>: If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument <code>move(x)</code>), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. \u2014 end note ]</p>\n</blockquote>\n<p>While it doesn't directly answer your question it does indicate that you've effectively \"given\" the argument to the library function as a temporary so I wouldn't rely on its value once you've called <code>insert</code>. As far as I can tell, a library implementation would be entitled to move from the parameter even if it subsequently determines that it isn't going to keep the value in the container.</p>\n", "LastActivityDate": "2012-04-06T13:05:11.453", "Score": "6", "CreationDate": "2012-04-06T13:05:11.453", "ParentId": "10043716", "CommentCount": "2", "OwnerUserId": "19563"}});