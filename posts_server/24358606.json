post_cb({"bq_ids": {"n4140": {"so_24358606_24358853_0": {"length": 10, "quality": 1.0, "section_id": 6005}, "so_24358606_24358853_1": {"length": 10, "quality": 1.0, "section_id": 7126}, "so_24358606_24358606_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 7126}}, "n3337": {"so_24358606_24358853_0": {"length": 10, "quality": 1.0, "section_id": 5773}, "so_24358606_24358853_1": {"length": 10, "quality": 1.0, "section_id": 6870}, "so_24358606_24358606_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 6870}}, "n4659": {"so_24358606_24358853_0": {"length": 10, "quality": 1.0, "section_id": 7504}, "so_24358606_24358853_1": {"length": 10, "quality": 1.0, "section_id": 8627}, "so_24358606_24358606_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 8627}}}, "24358606": {"ViewCount": "114", "Body": "<p>Quote from 3.4.5/1 (document version N3797):</p>\n<blockquote>\n<p id=\"so_24358606_24358606_0\">In a class member access expression (5.2.5), if the . or -&gt; token is\n  immediately followed by an identifier followed by a &lt;, the identifier\n  must be looked up to determine whether the &lt; is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire postfix-expression and <strong>shall name a class template</strong>.</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n\nstruct A { };\n\ntemplate &lt;typename T&gt; class B{ };\n\n\nint main(){ A *a = new A(); a-&gt;B&lt;int&gt;; }\n</code></pre>\n<p>The lookup of <code>B&lt;int&gt;</code> in the context of the entire postfix-expression is success. But clang++ returns an error:</p>\n<pre><code>test.cpp:14:32: error: no member named 'B' in 'A'\n</code></pre>\n<p>Please, explain that diagnostic message.</p>\n<p>The following is not clear for me: If the indetifier is not found, clang++ returns an error. But the standard said that <code>If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class template</code>.</p>\n<p>What is the point of looking up after the identifier is not found in the object expression class scope?</p>\n", "AcceptedAnswerId": "24358853", "Title": "Class template appeared in the class member access expression", "CreationDate": "2014-06-23T04:56:57.157", "Id": "24358606", "CommentCount": "14", "LastEditDate": "2014-06-23T05:57:54.123", "PostTypeId": "1", "LastEditorDisplayName": "user2953119", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-08-03T09:15:17.727", "Score": "3", "Tags": "<c++><class><templates><language-lawyer>", "AnswerCount": "3"}, "24358853": {"Id": "24358853", "PostTypeId": "2", "Body": "<p>Your construct is banned by \u00a75.2.5[expr.ref]/p2, addressing class member access expressions:</p>\n<blockquote>\n<p id=\"so_24358606_24358853_0\">In either case, the <em>id-expression</em> shall name a member of the class or of one of its base classes.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_24358606_24358853_1\">If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class template.</p>\n</blockquote>\n<p><s>I believe that this lookup rule is for finding base classes that are templates. A lookup \"in the class of the object expression\" would find class members, but won't find the base classes themselves.</s> This doesn't seem right as base class names are injected into derived classes as well (see example in \u00a711.1 [class.access.spec]/p5).</p>\n<hr>\n<p>Edit: Well, here's a pretty contrived example that appears to depend on this rule:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nclass A {\npublic:\n  void foo() { cout &lt;&lt; \"A::foo()\" &lt;&lt; endl; }\n};\n\ntemplate &lt;class E&gt;\nusing base = A&lt;E&gt;;\n\nint main() {\n  A&lt;int&gt;* bp = new A&lt;int&gt;();\n  bp-&gt;base&lt;int&gt;::foo(); \n}\n</code></pre>\n<p>Looking up for <code>base</code> in <code>A</code> won't find it, so you need to look up in the context of the expression as well to determine if <code>&lt;</code> is less-than or starting a template argument list. However this clause has a pretty long history (predating template aliases) so there must be another use case that I'm missing...</p>\n</hr></hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:15:17.727", "Score": "1", "CreationDate": "2014-06-23T05:23:01.253", "ParentId": "24358606", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:15:17.727"}, "24359480": {"Id": "24359480", "PostTypeId": "2", "Body": "<p>A simple example where the meaning of <strong>If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class template</strong> becomes clear.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; struct B\n{\n   T data;\n};\n\nstruct A : B&lt;int&gt;\n{\n   float data;\n};\n\nint main()\n{\n   A *a = new A();\n   a-&gt;data = 25.3;\n   a-&gt;B&lt;int&gt;::data = 10; // Accessing the data from the base class, B&lt;int&gt;\n                         // The name B is looked up from the context of the\n                         // expression. B&lt;int&gt; is a base class. So, the\n                         // expression is a way to get to the members of\n                         // B&lt;int&gt;\n\n   a-&gt;B&lt;float&gt;::data = 10.1; // Not OK since B&lt;float&gt; is not a base class of A\n\n   std::cout &lt;&lt; a-&gt;data &lt;&lt; std::endl;\n   std::cout &lt;&lt; a-&gt;B&lt;int&gt;::data &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2014-06-23T06:15:18.033", "CommentCount": "3", "CreationDate": "2014-06-23T06:15:18.033", "ParentId": "24358606", "Score": "0", "OwnerUserId": "434551"}, "24385930": {"Id": "24385930", "PostTypeId": "2", "Body": "<p>I think that the sense of this rule is to lookup an alias for name which denotes the class member. The following simple example:</p>\n<pre><code>#include&lt;iostream&gt;\n\nstruct A\n{\n    int a;\n    A(){ a = 5; }\n};\n\ntypedef A B;\n\nint main()\n{\n    A *a = new A();\n    std::cout &lt;&lt; a-&gt;B::a; //Usual unqualified name lookup applied\n}\n</code></pre>\n", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-06-24T11:51:53.223", "Score": "0", "CreationDate": "2014-06-24T11:51:53.223", "ParentId": "24358606", "CommentCount": "2"}});