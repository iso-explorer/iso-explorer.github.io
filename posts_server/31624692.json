post_cb({"31624803": {"ParentId": "31624692", "CommentCount": "0", "Body": "<p>You should not confuse the return value of an operator and the priority.</p>\n<p>The first is dealing with what the operator returns, the second deals with when something happens.</p>\n<p>So if you have:</p>\n<pre><code>T min_value = *begin++;\n</code></pre>\n<p>Here is how it works:</p>\n<ol>\n<li><code>operator++</code> - it increments the pointer, but returns the pointer that was there originally.</li>\n<li><code>operator*</code> - dereferences the pointer returned previously, returns T that it pointed to.</li>\n<li><code>operator=</code> stores left-hand side into right-hand side, returns right-hand side.</li>\n</ol>\n<p>You don't use the last return value, but you theoretically could.</p>\n<p>Note here, that in #2 you use the return from #1, rather than accessing the pointer again.</p>\n", "OwnerUserId": "2893496", "PostTypeId": "2", "Id": "31624803", "Score": "1", "CreationDate": "2015-07-25T09:00:21.207", "LastActivityDate": "2015-07-25T09:00:21.207"}, "31624692": {"CommentCount": "1", "AcceptedAnswerId": "31624873", "PostTypeId": "1", "LastEditorUserId": "678093", "CreationDate": "2015-07-25T08:47:09.800", "LastActivityDate": "2015-07-25T11:54:19.913", "LastEditDate": "2015-07-25T08:50:57.510", "ViewCount": "219", "FavoriteCount": "1", "Title": "Order of incrementing and dereferencing pointer in C++", "Id": "31624692", "Score": "3", "Body": "<p>I tutor students in C++, and recently came across a problem involving pointer arithmetic with array names. The main thing I'm confused about is the statement</p>\n<pre><code>T min_value = *begin++; \n</code></pre>\n<p><a href=\"http://www.cplusplus.com/doc/tutorial/operators/\" rel=\"nofollow\">Cplusplus</a> tells me that the ++ operator has higher precedence than the * dereference operator, so I assume that begin is first incremented and then dereferenced. Also, <a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html\" rel=\"nofollow\">this</a> site confirms that when you pass the name of an array to a function, it gets turned into a pointer to the address of the first element, element [0]. However, when I run the code below in Visual Studio, it looks like min_value is set to be 1.5 at the beginning, which seems to contradict what I think the order of operations are.</p>\n<p>I think it should be:</p>\n<ol>\n<li>increment the begin pointer to the [1] element (2nd in the array)</li>\n<li>dereference the pointer value</li>\n<li>set min_value to be equal to the 2nd element in the array.</li>\n</ol>\n<p>However, my experiment seems to indicate that instead something different is happening: </p>\n<ol>\n<li>dereference pointer value</li>\n<li>set min_value equal to 1st element of array</li>\n<li>increment pointer to next element</li>\n</ol>\n<p>Can someone clarify this? </p>\n<pre><code>// Problem #3: Please write the implementation of min() function and max() function..\n\n#include &lt;iostream&gt; \nusing namespace std; \ntemplate&lt;typename T&gt; \n\nT min(T* begin, T* end) \n{ \n        T min_value = *begin++; \n        while(begin != end) // You can use for-loop too. \n        { \n                if( *begin &lt; min_value) \n                        min_value = *begin; \n                begin++; \n        } \n        return min_value; \n} \ntemplate&lt;typename T&gt; \nT max(T* begin, T* end) \n{ \n        T max_value = *begin++; \n        while(begin != end) \n        { \n                if( *begin &gt; max_value) \n                        max_value = *begin; \n                begin++; \n        } \n        return max_value; \n} \nint main() \n{ \n        double arr[] = {    1.5, 4.5, 3.5, 2.5, 5.5 }; \n        int values[] = {    1, 2, 3, 4, -1, 5 }; \n        cout &lt;&lt; \"min of arr[] is : \" &lt;&lt; min(arr, arr + 5) &lt;&lt; endl; \n        cout &lt;&lt; \"min of values[] is : \" &lt;&lt; min(values, values + 6) &lt;&lt; endl; \n        cout &lt;&lt; \"max of arr[] is : \" &lt;&lt; max(arr, arr + 5) &lt;&lt; endl; \n        cout &lt;&lt; \"max of values[] is : \" &lt;&lt; max(values, values + 6) &lt;&lt; endl; \n}\n</code></pre>\n", "Tags": "<c++><arrays><pointers>", "OwnerUserId": "4110064", "AnswerCount": "3"}, "31624873": {"ParentId": "31624692", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-07-25T09:09:30.530", "Score": "2", "LastEditorUserId": "3313064", "LastEditDate": "2015-07-25T11:54:19.913", "Id": "31624873", "OwnerUserId": "3313064", "Body": "<p>Precedence is only a rule for how the code should be parsed. <code>++</code> comes first, and <code>*</code> comes second. But when the code is executed, you have to consider what the operators actually <em>do</em>.</p>\n<p>In your case, the following happens:</p>\n<ol>\n<li>A copy of <code>begin</code> is made.</li>\n<li>The original is incremented.</li>\n<li>The copy is returned.</li>\n<li>The <strong>copy is dereferenced</strong>.</li>\n<li>The copy is assigned to <code>min_value</code>.</li>\n</ol>\n<p>That's just how the post-increment operator works, and it's also how you write the operator when you overload it for your own types:</p>\n<pre><code>T operator++(int)\n{\n    T copy = *this;\n    ++(*this);\n    return copy;\n}\n</code></pre>\n<hr>\n<p><em>Actually, in the case of the built-in post-increment operator, incrementation does not necessarily have to be step 2. It could also happen at a later point, as long as the observable behaviour is the same. For example, nothing stops the compiler from incrementing the original value after it has returned the copy. You could not perform such a thing in your own, overloaded operator, of course.</em></p>\n</hr>", "LastActivityDate": "2015-07-25T11:54:19.913"}, "31624740": {"ParentId": "31624692", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-07-25T08:52:15.410", "Score": "1", "LastEditorUserId": "2877241", "LastEditDate": "2015-07-25T09:29:45.773", "Id": "31624740", "OwnerUserId": "2877241", "Body": "<p>This expression</p>\n<pre><code>T min_value = *begin++; \n</code></pre>\n<p>can be imagined the following way</p>\n<pre><code>auto temp = begin;\nT min_value = *temp;\n++begin;\n</code></pre>\n<p>According to the C++ Standard (5.2.6 Increment and decrement)</p>\n<blockquote>\n<p id=\"so_31624692_31624740_0\">1 The value of a postfix ++ expression is <strong>the value of its\n  operand</strong>. [ Note: the value obtained is a copy of the original value\n  \u2014end note ] ...The value computation of the ++ expression is sequenced\n  before the modification of the operand object.</p>\n</blockquote>\n<p>In general case the function definitions are wrong because the range specified by <code>begin</code> and <code>end</code> can be empty and begin can point beyond a valid range. In this case you may neither increase begin nor dereference it.</p>\n<p>So it would be more correctly to write for example the following way</p>\n<pre><code>T * min( T* begin, T* end ) \n{\n    T *min_value = begin;\n\n    if ( begin != end )\n    {\n        while( ++begin != end )\n        { \n            if( *begin &lt; *min_value ) min_value = begin; \n        } \n    }\n\n    return min_value; \n} \n</code></pre>\n<p>In this case the call of the function will look like</p>\n<pre><code>cout &lt;&lt; \"min of arr[] is : \" &lt;&lt; *min(arr, arr + 5) &lt;&lt; endl;\n                               ^^^\n</code></pre>\n", "LastActivityDate": "2015-07-25T09:29:45.773"}, "bq_ids": {"n4140": {"so_31624692_31624740_0": {"section_id": 6009, "quality": 0.7916666666666666, "length": 19}}, "n3337": {"so_31624692_31624740_0": {"section_id": 5777, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_31624692_31624740_0": {"section_id": 7508, "quality": 0.7916666666666666, "length": 19}}}});