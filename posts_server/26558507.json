post_cb({"bq_ids": {"n4140": {"so_26558507_26682739_17": {"length": 8, "quality": 1.0, "section_id": 179}, "so_26558507_26682739_13": {"length": 16, "quality": 1.0, "section_id": 179}, "so_26558507_26682739_14": {"length": 8, "quality": 1.0, "section_id": 179}, "so_26558507_26682739_12": {"length": 13, "quality": 0.9285714285714286, "section_id": 179}, "so_26558507_26682739_9": {"length": 8, "quality": 1.0, "section_id": 7114}, "so_26558507_26682739_4": {"length": 8, "quality": 1.0, "section_id": 7114}, "so_26558507_26682739_10": {"length": 9, "quality": 0.9, "section_id": 7114}, "so_26558507_26682739_2": {"length": 5, "quality": 1.0, "section_id": 7114}, "so_26558507_26682739_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7114}, "so_26558507_26682739_7": {"length": 5, "quality": 1.0, "section_id": 7114}, "so_26558507_26682739_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 7114}, "so_26558507_26682739_15": {"length": 13, "quality": 0.9285714285714286, "section_id": 179}, "so_26558507_26682739_16": {"length": 16, "quality": 1.0, "section_id": 179}, "so_26558507_26682739_5": {"length": 9, "quality": 0.9, "section_id": 7114}}, "n3337": {"so_26558507_26682739_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 5662}, "so_26558507_26682739_13": {"length": 16, "quality": 1.0, "section_id": 173}, "so_26558507_26682739_14": {"length": 8, "quality": 1.0, "section_id": 173}, "so_26558507_26682739_12": {"length": 13, "quality": 0.9285714285714286, "section_id": 173}, "so_26558507_26682739_9": {"length": 8, "quality": 1.0, "section_id": 6858}, "so_26558507_26682739_4": {"length": 8, "quality": 1.0, "section_id": 6858}, "so_26558507_26682739_2": {"length": 5, "quality": 1.0, "section_id": 6858}, "so_26558507_26682739_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5662}, "so_26558507_26682739_7": {"length": 5, "quality": 1.0, "section_id": 6858}, "so_26558507_26682739_17": {"length": 8, "quality": 1.0, "section_id": 173}, "so_26558507_26682739_15": {"length": 13, "quality": 0.9285714285714286, "section_id": 173}, "so_26558507_26682739_16": {"length": 16, "quality": 1.0, "section_id": 173}}, "n4659": {"so_26558507_26682739_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 8615}, "so_26558507_26682739_13": {"length": 16, "quality": 1.0, "section_id": 184}, "so_26558507_26682739_14": {"length": 8, "quality": 1.0, "section_id": 184}, "so_26558507_26682739_12": {"length": 13, "quality": 0.9285714285714286, "section_id": 184}, "so_26558507_26682739_9": {"length": 8, "quality": 1.0, "section_id": 8615}, "so_26558507_26682739_4": {"length": 8, "quality": 1.0, "section_id": 8615}, "so_26558507_26682739_10": {"length": 9, "quality": 0.9, "section_id": 8615}, "so_26558507_26682739_2": {"length": 5, "quality": 1.0, "section_id": 8615}, "so_26558507_26682739_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8615}, "so_26558507_26682739_7": {"length": 5, "quality": 1.0, "section_id": 8615}, "so_26558507_26682739_17": {"length": 8, "quality": 1.0, "section_id": 184}, "so_26558507_26682739_15": {"length": 13, "quality": 0.9285714285714286, "section_id": 184}, "so_26558507_26682739_16": {"length": 16, "quality": 1.0, "section_id": 184}, "so_26558507_26682739_5": {"length": 9, "quality": 0.9, "section_id": 8615}}}, "26682739": {"Id": "26682739", "PostTypeId": "2", "Body": "<h3><code>gcc</code> is correct; your snippet is ill-formed!</h3>\n<pre><code>// reduced testcase\ntemplate&lt;class T&gt;\nclass A { };\n\nint main () {\n  A&lt;float&gt;::A&lt;int&gt; x; // ill-formed, bug in `clang` and `icc`\n}\n</code></pre>\n<p>In the above reduced testcase we have a <em>nested-name-specifier</em>, <code>A&lt;float&gt;::</code>, followed by an <em>unqualified-id</em> <code>A</code>, which is then followed by some gibberish (<code>&lt;int&gt;</code>).</p>\n<p>This is because the context in which the <em>nested-name-specifier</em> appears mandates that, during a look-up, function names are included (meaning that the constructor is found first, and the expression is ill-formed).</p>\n<p><br/></p>\n<p><strong>Relevant Bug Reports</strong>:</p>\n<ul>\n<li><a href=\"http://llvm.org/bugs/show_bug.cgi?id=8263\" rel=\"noreferrer\">llvm.org/bugs/ - <strong>#8263; Incorrect constructor name resolution</strong></a></li>\n</ul>\n<hr>\n<h3>How to circumvent the \"<em>problem</em>\"?</h3>\n<p>There are contexts in which member names that are looked up through a <em>nested-name-specifier</em> (that nominates a class) shall not include functions (hence, contexts where the constructor is not found), below are a few examples:</p>\n<pre><code>template&lt;class T&gt;\nstruct A {\n  typedef T value_type;\n};\n</code></pre>\n<pre><code>  struct A&lt;float&gt;::A&lt;int&gt;  x;     // ok, context: elaborate-type-specifier\ntypename A&lt;float&gt;::A&lt;int&gt; ();     // ok, context: [expr.type.conv]p1\n  A&lt;float&gt;::A::value_type  x;     // ok, context: nested-name-specifier\n\n\nstruct X : A&lt;float&gt;::A&lt;int&gt; { };  // ok, context: base-specifier\n</code></pre>\n<hr>\n<h3>What does the Standard say?</h3>\n<blockquote>\n<p id=\"so_26558507_26682739_0\"><code>3.4.3.1p2</code> <strong>Class members</strong> <code>[class.qual]</code></p>\n<blockquote>\n<p id=\"so_26558507_26682739_6\">In a lookup in which function names are not ignored<sup>88</sup> and the <em>nested-name-specifier</em> nominates a class <em>C</em>:</p>\n<ul>\n<li>if the name specified after the <em>nested-name-specifier</em>, when looked up in <em>C</em>, is the injected-class-name of <em>C</em> (Clause 9), or</li>\n<li>in a <em>using-declaration</em> (7.3.3) that is a <em>member-declaration</em>, if the name specified after the <em>nested-name-specifier</em> is the same as the <em>identifier</em> or the <em>simple-template-id</em>'s <em>template-name</em> in the last component of the *nested-name-specicifier,</li>\n</ul>\n<p id=\"so_26558507_26682739_7\">the name is instead considered to name the constructor of class <em>C</em>.</p>\n<p id=\"so_26558507_26682739_8\">[ <em>Note</em>: ... ]</p>\n<p id=\"so_26558507_26682739_9\">Such a constructor name shall be used only in the <em>declarator-id</em> of a declaration that names a constructor or in a <em>using-declaration</em>.</p>\n<hr>\n<p id=\"so_26558507_26682739_10\"><sup><sup>88.</sup> Lookups in which function names are ignored include names appearing in a <em>nested-name-specifier</em>, an <em>elaborated-type-specifier</em>, or a <em>base-specifier</em>.</sup></p>\n</hr></blockquote>\n</blockquote>\n<blockquote>\n<p id=\"so_26558507_26682739_11\"><code>14.6.1p2</code> <strong>Locally declared names</strong> <code>[temp.local]</code></p>\n<blockquote>\n<p id=\"so_26558507_26682739_15\">Like normal (non-template) classes, class templates have an injected-class-name\n    (Clause 9). The injected-class-name can be used as a <em>template-name</em> or a\n    <em>type-name</em>.</p>\n<p id=\"so_26558507_26682739_16\">When it is used with a <em>template-argument-list</em>, as a\n    <em>template-argument</em> for a template <em>template-parameter</em>, or as the final\n    identifier in the <em>elaborated-type-specifier</em> of a friend class template\n    declaration, it refers to the class template itself.</p>\n<p id=\"so_26558507_26682739_17\">Otherwise, it is\n    equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the \n    class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-11-01T01:50:49.433", "Score": "5", "CreationDate": "2014-10-31T20:16:12.177", "ParentId": "26558507", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-11-01T01:50:49.433"}, "26558507": {"ViewCount": "729", "Body": "<p>Inspired by <a href=\"https://stackoverflow.com/questions/26557065/can-a-class-have-a-templated-constructor-without-arguments/26557271\">the code in this answer</a>.  Consider:</p>\n<pre><code>template&lt;class&gt;\nclass A { };\n\nint main()\n{\n    A&lt;float&gt; a(A&lt;float&gt;::A&lt;int&gt;());\n    return 0;\n}\n</code></pre>\n<p>Is this code</p>\n<ol>\n<li>ill-formed, because <code>A&lt;float&gt;::A</code> names the constructor (per \u00a73.4.3.1 [class.qual]/p2) and cannot be used in this context (plus the <code>&lt;int&gt;</code> would complete fail to parse anyway), or</li>\n<li>well-formed, with <code>A&lt;float&gt;::A</code> being the <em>injected-class-name</em>, used as a <em>template-name</em> (\u00a714.6.1 [temp.local]), such that <code>A&lt;float&gt;::A&lt;int&gt;</code> means exactly the same as <code>A&lt;int&gt;</code>, and <code>a</code> being declared as a function (due to the most vexing parse)?</li>\n</ol>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b04ea755f4a0d85c\" rel=\"nofollow noreferrer\">g++ says 1. clang says 2</a>, and so does <a href=\"http://goo.gl/KT0NHo\" rel=\"nofollow noreferrer\">ICC 13</a>. Which compiler is correct?</p>\n", "AcceptedAnswerId": "26682739", "Title": "Injected-class-names of class templates", "CreationDate": "2014-10-25T01:30:03.137", "Id": "26558507", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:59:46.120", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-18T10:15:06.677", "Score": "13", "OwnerUserId": "2756719", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}});