post_cb({"40962538": {"ParentId": "40962505", "CommentCount": "2", "Body": "<p>You don't have multiple <em>definitions</em> of <code>a</code> in the first program.  You have multiple <em>declarations</em> of <code>a</code>.  Huge difference.</p>\n<p>If you couldn't have multiple declarations then <code>include</code> would not work as the preprocessor simply copies that information in each translation it's used in.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "40962538", "Score": "0", "CreationDate": "2016-12-04T19:14:31.603", "LastActivityDate": "2016-12-04T19:14:31.603"}, "40962746": {"ParentId": "40962505", "CommentCount": "3", "Body": "<p>[basic.def.odr]/1:</p>\n<blockquote>\n<p id=\"so_40962505_40962746_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</p>\n</blockquote>\n<p><em>Variable</em> is defined by [basic]/6:</p>\n<blockquote>\n<p id=\"so_40962505_40962746_1\">A <em>variable</em> is introduced by the declaration of a reference other than a non-static data member or of an object.</p>\n</blockquote>\n<p>Therefore, as a non-static data member is not a variable, function, class, enumeration, or template, the one definition rule simply doesn't apply to non-static data members.</p>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "40962746", "Score": "3", "CreationDate": "2016-12-04T19:33:25.640", "LastActivityDate": "2016-12-04T19:33:25.640"}, "40962505": {"CommentCount": "2", "ViewCount": "214", "PostTypeId": "1", "LastEditorUserId": "3177536", "CreationDate": "2016-12-04T19:11:03.943", "LastActivityDate": "2016-12-04T19:47:41.793", "Title": "non-static data members and one definition rule", "AcceptedAnswerId": "40962746", "LastEditDate": "2016-12-04T19:26:18.780", "Id": "40962505", "Score": "4", "Body": "<p><strong>Premise</strong></p>\n<p>In accordance with the <strong>One Definition Rule</strong>, as stated in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">C++14 Standard</a>, I can have a definition of the same class in each translation unit as long as I follow the rules in 3.2.6. This means allows the following program to be legal:</p>\n<pre><code>//a_1.cpp\nclass A {                      //definition of A\n    int a;                     //definition of A::a\n    static int b;              //declaration of A::b\n    int foo();                 //declaration of A::foo();\n    int boo(){ return 42; };   //definition of A::boo() implicity inlined \n};\n\n//a_2.cpp\nclass A {                      //definition of A\n    int a;                     //definition of A::a\n    static int b;              //declaration of A::b\n    int foo();                 //declaration of A::foo();\n    int boo(){ return 42; };   //definition of A::boo() implicity inlined \n};\n</code></pre>\n<p>If I try to define <code>b</code> or <code>foo()</code>, I am, however, limited to a single definition across the entire program, which I believe is due to the statement in 3.2.4:</p>\n<blockquote>\n<p id=\"so_40962505_40962505_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used\n  in that program; no diagnostic required.</p>\n</blockquote>\n<p>For this reason, the following program is ill-formed:</p>\n<pre><code>//a_1.cpp\nclass A {                      //definition of A\n    int a;                     //definition of A::a\n    static int b;              //declaration of A::b\n    int foo();                 //declaration of A::foo();\n    int boo(){ return 42; };   //definition of A::boo() implicity inlined \n};\nint A::b;\n\n//a_2.cpp\nclass A {                      //definition of A\n    int a;                     //definition of A::a\n    static int b;              //declaration of A::b\n    int foo();                 //declaration of A::foo();\n    int boo(){ return 42; };   //definition of A::boo() implicitly inlined \n};\nint A::b;\n</code></pre>\n<p>The same if I tried to define <code>foo()</code> in both source files. </p>\n<p>I can, however, have multiple definitions of <code>boo()</code> (one per translation unit) as this is not prohibited by 3.2.4 and is, actually, explicitly allowed by 3.2.6:</p>\n<blockquote>\n<p id=\"so_40962505_40962505_1\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), <strong>inline function with\n  external linkage</strong> (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for\n  which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit.</p>\n</blockquote>\n<p>To be fair, 3.2.6 qualifies the statement above adding a few requirement, among which the entity (in our case <code>boo()</code>) must be defined with the same sequence of tokens in each translation unit. </p>\n<p><strong>Question</strong></p>\n<p>What about the non-static data member <code>a</code>? Multiple definitions of <code>a</code> are obviously allowed (otherwise the program at the top of my question would not compile), but this would seem to be prohibited by 3.2.4 and not condoned by 3.2.6. Is this just a detail not strictly specified in the standard or am I missing something?</p>\n<p><strong>Edit</strong></p>\n<p>For those who have indicated to me that <code>a</code> is not defined, but is just declared, please consider this example, taken straight from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">C++14 Standard</a>, 3.2.2:</p>\n<pre><code>struct X { // defines X\n    int x; // defines non-static data member x\n    static int y; // declares static data member y\n    X(): x(0) { } // defines a constructor of X\n};\n</code></pre>\n<p>Please not that the comments to the code above are not mine, rather copied as well directly from the standard.</p>\n", "Tags": "<c++><class><scope><linkage><one-definition-rule>", "OwnerUserId": "3177536", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40962505_40962505_1": {"section_id": 7043, "quality": 0.8775510204081632, "length": 43}, "so_40962505_40962746_0": {"section_id": 7038, "quality": 1.0, "length": 14}, "so_40962505_40962505_0": {"section_id": 7041, "quality": 1.0, "length": 12}, "so_40962505_40962746_1": {"section_id": 7029, "quality": 0.9, "length": 9}}, "n3337": {"so_40962505_40962505_1": {"section_id": 6788, "quality": 0.8775510204081632, "length": 43}, "so_40962505_40962746_0": {"section_id": 6784, "quality": 1.0, "length": 14}, "so_40962505_40962505_0": {"section_id": 6786, "quality": 1.0, "length": 12}, "so_40962505_40962746_1": {"section_id": 6775, "quality": 0.9, "length": 9}}, "n4659": {"so_40962505_40962505_1": {"section_id": 8540, "quality": 0.8775510204081632, "length": 43}, "so_40962505_40962746_0": {"section_id": 8535, "quality": 1.0, "length": 14}, "so_40962505_40962505_0": {"section_id": 8538, "quality": 1.0, "length": 12}, "so_40962505_40962746_1": {"section_id": 8526, "quality": 0.9, "length": 9}}}});