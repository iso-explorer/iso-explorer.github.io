post_cb({"29035225": {"ViewCount": "929", "Body": "<p>I just can't see why the size of the enumeration is relevant for the compiler while the size of the class is not.</p>\n<p>My code example:</p>\n<pre><code>class A;\nenum E;   // must be enum E : int; in order to compile \n\nvoid f(const A &amp; param);\nvoid f(const E &amp; param);\n</code></pre>\n<p>I'm talking here of standard C++ compilers.\nI know that MSVC let it compile and works fine. So the question is:</p>\n<p>Why this has not been standardized?</p>\n", "AcceptedAnswerId": "29035972", "Title": "Why must an enumeration's size be provided when it is forward declared?", "CreationDate": "2015-03-13T14:46:35.190", "Id": "29035225", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-03-13T15:08:14.920", "LastEditorUserId": "333698", "LastActivityDate": "2015-11-05T18:51:37.350", "Score": "20", "OwnerUserId": "3074280", "Tags": "<c++><c++11><enums><forward-declaration>", "AnswerCount": "2"}, "29035972": {"Id": "29035972", "PostTypeId": "2", "Body": "<p>This has been standardized, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf\" rel=\"nofollow noreferrer\">proposal 2764: Forward declaration of enumerations (rev. 3)</a> allowed the forward declaration of enums if you specify the underlying type, whereas before this was not possible.</p>\n<p>The main reason is that when the underlying type is not specified the size is implementation defined and can depend on the enumerator values. From the draft C++11 standard section <code>7.2</code> <em>[dcl.enum]</em>:</p>\n<blockquote>\n<p id=\"so_29035225_29035972_0\">For an enumeration whose underlying type is not fixed, the underlying\n  type is an integral type that can represent all the enumerator values\n  defined in the enumeration. If no integral type can represent all the\n  enumerator values, the enumeration is ill-formed. It is\n  implementation-defined which integral type is used as the underlying\n  type except that the underlying type shall not be larger than int\n  unless the value of an enumerator cannot fit in an int or unsigned\n  int. If the enumerator-list is empty, the underlying type is as if the\n  enumeration had a single enumerator with value 0.</p>\n</blockquote>\n<p>When passing by value it makes sense that not knowing the underlying type is an issue, but why is it an issue when it is a pointer or reference? This matters since apparently on some architectures, <em>char*</em> and <em>int*</em> can have different sizes as mentioned in this <a href=\"http://compgroups.net/comp.lang.c++/gcc-and-forward-declaration-of-enum/1005825\" rel=\"nofollow noreferrer\">comp.lang.c++ discussion: GCC and forward declaration of enum</a>:</p>\n<blockquote>\n<p id=\"so_29035225_29035972_1\">[...] While on most architectures it may not be an issue, on some\n  architectures the pointer will have a different size, in case it is a\n  char pointer.  So finally our imaginary compiler would have no idea\n  what to put there to get a ColorsEnum*[...]</p>\n</blockquote>\n<p>We have the following stackoverflow answer for reference which describes the case where <a href=\"https://stackoverflow.com/a/15832757/1708801\">char* can be larger than int*</a>, which backs up the assertion in the discussion above.</p>\n<p>Some <a href=\"http://c-faq.com/null/machexamp.html\" rel=\"nofollow noreferrer\">more details on the possible sizes of pointers</a> it looks like <code>char *</code> and <code>void *</code> are the two main exceptions here and so other object pointers should not have the same issues. So it seems like this case ends up being unique to enums.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-05T18:51:37.350", "Score": "11", "CreationDate": "2015-03-13T15:20:23.100", "ParentId": "29035225", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:51:54.110"}, "29035576": {"Id": "29035576", "PostTypeId": "2", "Body": "<p>It's a difference in design goals.</p>\n<p>Forward declaring a class creates an incomplete type that can be used opaquely in pointers/references. This is a very useful property.</p>\n<p>An incomplete enum type is not that useful. However being able to declare an enum without declaring what constants are inside that enum <strong>is</strong> useful. The complexity that comes from an incomplete enum type can be avoided by requiring that the size must be specified.</p>\n<p>So my best guess is that compiler implementers were kept in mind when this feature was designed, and the committee found that the increased complexity of incomplete enums was not worth the benefits.</p>\n", "LastActivityDate": "2015-03-13T15:03:32.660", "CommentCount": "6", "CreationDate": "2015-03-13T15:03:32.660", "ParentId": "29035225", "Score": "7", "OwnerUserId": "565635"}, "bq_ids": {"n4140": {"so_29035225_29035972_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5466}}, "n3337": {"so_29035225_29035972_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5252}}, "n4659": {"so_29035225_29035972_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 6900}}}});