post_cb({"38977808": {"CommentCount": "11", "ViewCount": "285", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2016-08-16T14:37:53.937", "LastActivityDate": "2016-08-17T01:49:46.087", "Title": "Explicit type conversion (functional notation) with simple-type-specifier", "AcceptedAnswerId": "38978223", "LastEditDate": "2016-08-16T16:03:10.120", "Id": "38977808", "Score": "5", "Body": "<p>Porting some code I have discovered that line</p>\n<pre><code>unsigned char uc = unsigned char(c);\n</code></pre>\n<p>is accepted by MSVC but rejected by GCC. Is this syntax correct?<br>\nStandard says that </br></p>\n<blockquote>\n<p id=\"so_38977808_38977808_0\">A simple-type-specifier (7.1.7.2) ... followed by a parenthesized\n  optional expressionlist or by a braced-init-list (the initializer)\n  constructs a value of the specified type given the initializer</p>\n</blockquote>\n<p>Does it mean that MS is right? Is <code>unsigned char</code> a 'simple-type-specifier'?</p>\n", "Tags": "<c++><gcc><visual-c++><type-conversion><language-lawyer>", "OwnerUserId": "6282716", "AnswerCount": "3"}, "38978132": {"ParentId": "38977808", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>or you can use:</p>\n<pre><code>unsigned char uc = static_cast&lt;unsigned char&gt;(c);\n</code></pre>\n", "OwnerUserId": "6691803", "LastEditorUserId": "3309790", "LastEditDate": "2016-08-16T15:23:37.613", "Id": "38978132", "Score": "-2", "CreationDate": "2016-08-16T14:53:19.817", "LastActivityDate": "2016-08-16T15:23:37.613"}, "38978223": {"ParentId": "38977808", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://rextester.com/FIZK9146\" rel=\"nofollow\">GCC</a> and <a href=\"http://rextester.com/DRLIG49758\" rel=\"nofollow\">CLANG</a> are correct, the code is not valid. </p>\n<p><a href=\"http://eel.is/c++draft/dcl.type.simple#1\" rel=\"nofollow\">Simple type specifier</a> is single-word type name:</p>\n<blockquote>\n<p id=\"so_38977808_38978223_0\">The simple type specifiers are</p>\n<pre><code>simple-type-specifier:\n    nested-name-specifieropt type-name\n    nested-name-specifier template simple-template-id\n    nested-name-specifieropt template-name\n    char\n    char16_t\n    char32_t\n    wchar_t\n    bool\n    short\n    int\n    long\n    signed\n    unsigned\n    float\n    double\n    void\n    auto\n    decltype-specifier\n\ntype-name:\n    class-name\n    enum-name\n    typedef-name\n    simple-template-id\n\ndecltype-specifier:\n  decltype ( expression )\n  decltype ( auto )\n</code></pre>\n</blockquote>\n<p><code>unsigned char</code> is not a simple-type-specifier, it's a <strong>combination</strong> of simple-type-specifiers, as shown in <a href=\"http://eel.is/c++draft/dcl.type.simple#tab:simple.type.specifiers\" rel=\"nofollow\">Table 9</a> from standard.</p>\n<blockquote>\n<p id=\"so_38977808_38978223_1\">Table [tab:simple.type.specifiers] summarizes the valid combinations of simple-type-specifiers and the types they specify.</p>\n<p id=\"so_38977808_38978223_2\">Table 9 \u2014 simple-type-specifiers and the types they specify</p>\n<pre><code>Specifier(s)  Type\n...\nunsigned char     \u201cunsigned char\u201d \n...\n</code></pre>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\" rel=\"nofollow\">Here</a>'s an explanation from cppreference.com:</p>\n<blockquote>\n<p id=\"so_38977808_38978223_3\">2) The functional cast expression consists of a simple type specifier or a typedef specifier (in other words, a single-word type name: <code>unsigned int(expression)</code> or <code>int*(expression)</code> are not valid), followed by a single expression in parentheses.</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-08-17T01:49:46.087", "Id": "38978223", "Score": "9", "CreationDate": "2016-08-16T14:56:57.747", "LastActivityDate": "2016-08-17T01:49:46.087"}, "bq_ids": {"n4140": {"so_38977808_38978223_1": {"section_id": 5438, "quality": 0.7777777777777778, "length": 7}, "so_38977808_38978223_2": {"section_id": 5438, "quality": 0.8, "length": 4}, "so_38977808_38977808_0": {"section_id": 5999, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_38977808_38978223_1": {"section_id": 5233, "quality": 0.7777777777777778, "length": 7}, "so_38977808_38978223_2": {"section_id": 5233, "quality": 0.8, "length": 4}, "so_38977808_38977808_0": {"section_id": 5767, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_38977808_38978223_1": {"section_id": 6865, "quality": 0.7777777777777778, "length": 7}, "so_38977808_38978223_2": {"section_id": 6865, "quality": 0.8, "length": 4}, "so_38977808_38977808_0": {"section_id": 7499, "quality": 0.9285714285714286, "length": 13}}}, "38977981": {"ParentId": "38977808", "CommentCount": "1", "Body": "<p>For gcc</p>\n<pre><code>unsigned char uc = (unsigned char)c;\n</code></pre>\n<p>resolve the problem, \nthe syntax is ambiguous for gcc. </p>\n<p>MSVC may have its support for such scenario.</p>\n", "OwnerUserId": "53670", "PostTypeId": "2", "Id": "38977981", "Score": "-2", "CreationDate": "2016-08-16T14:46:41.993", "LastActivityDate": "2016-08-16T14:46:41.993"}});