post_cb({"3291552": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>It most likely works fine because the destructor does not reference any class member variables. If you tried to <code>delete</code> a variable within the destructor you would probably run into trouble when it is automatically called the second time.</p>\n<p>Then again, with undefined behavior, who knows? :)</p>\n", "OwnerUserId": "101258", "PostTypeId": "2", "Id": "3291552", "Score": "1", "CreationDate": "2010-07-20T15:22:17.303", "LastActivityDate": "2010-07-20T15:22:17.303"}, "3291507": {"CommentCount": "6", "CreationDate": "2010-07-20T15:17:50.757", "PostTypeId": "1", "AcceptedAnswerId": "3291787", "LastEditorUserId": "105344", "LastActivityDate": "2010-07-20T17:13:01.417", "LastEditDate": "2010-07-20T15:47:21.517", "ViewCount": "1331", "FavoriteCount": "1", "Title": "Does explicitly calling destructor result in Undefined Behavior here?", "Id": "3291507", "Score": "5", "Body": "<p>In my opinion, the following code (from some C++ question) should lead to UB, but the it seems it is not. Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass some{ public: ~some() { cout&lt;&lt;\"some's destructor\"&lt;&lt;endl; } };\nint main() { some s; s.~some(); }\n</code></pre>\n<p>and the answer is:</p>\n<pre><code>some's destructor\nsome's destructor\n</code></pre>\n<p>I learned form c++ faq lite that we should not explicitly call destructor. I think after the explicitly call to the destructor, the object s should be deleted. The program automatically calls the destructor again when it's finished, it should be UB. However, I tried it on g++, and get the same result as the above answer.</p>\n<p>Is it because the class is too simple (no new/delete involved)? Or it's not UB at all in this case?</p>\n", "Tags": "<c++><destructor><undefined-behavior>", "OwnerUserId": "347208", "AnswerCount": "9"}, "bq_ids": {"n4140": {"so_3291507_3291787_6": {"section_id": 401, "quality": 1.0, "length": 15}, "so_3291507_3291787_0": {"section_id": 411, "quality": 1.0, "length": 8}, "so_3291507_3291787_3": {"section_id": 7189, "quality": 1.0, "length": 5}, "so_3291507_3291787_2": {"section_id": 7189, "quality": 0.875, "length": 7}, "so_3291507_3291787_5": {"section_id": 401, "quality": 1.0, "length": 9}, "so_3291507_3291787_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_3291507_3291787_6": {"section_id": 392, "quality": 1.0, "length": 15}, "so_3291507_3291787_0": {"section_id": 402, "quality": 1.0, "length": 8}, "so_3291507_3291787_3": {"section_id": 6933, "quality": 1.0, "length": 5}, "so_3291507_3291787_2": {"section_id": 6933, "quality": 0.875, "length": 7}, "so_3291507_3291787_5": {"section_id": 392, "quality": 1.0, "length": 9}, "so_3291507_3291787_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_3291507_3291787_6": {"section_id": 419, "quality": 1.0, "length": 15}, "so_3291507_3291787_0": {"section_id": 429, "quality": 1.0, "length": 8}, "so_3291507_3291787_3": {"section_id": 8701, "quality": 1.0, "length": 5}, "so_3291507_3291787_2": {"section_id": 8697, "quality": 0.875, "length": 7}, "so_3291507_3291787_5": {"section_id": 419, "quality": 1.0, "length": 9}, "so_3291507_3291787_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "3291583": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>What the main function does is reserving space on the stack, calling some's constructor, and at the end calling some's destructor. This always happens with a local variable, whatever code you put inside the function.\nYour compiler won't detect that you manually called the destructor.</p>\n<p>Anyway you should never manually call an object's destructor, except for objects created with placement-new.</p>\n", "OwnerUserId": "392546", "PostTypeId": "2", "Id": "3291583", "Score": "0", "CreationDate": "2010-07-20T15:24:22.220", "LastActivityDate": "2010-07-20T15:24:22.220"}, "3291800": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>Can you define the undefined behaviour you expect?  Undefined doesn't mean random (or catastrophic): the behaviour of a given program may be repeatable between invocations, it just means you can't RELY on any particular behaviour because it is undefined and there is no guarantee of what will happen.</p>\n", "OwnerUserId": "105344", "PostTypeId": "2", "Id": "3291800", "Score": "0", "CreationDate": "2010-07-20T15:45:59.227", "LastActivityDate": "2010-07-20T15:45:59.227"}, "3291543": {"ParentId": "3291507", "CommentCount": "3", "Body": "<p>The problem here is that deletion / deallocation and destructors are separate and independent constructs.  Much like new / allocation and constructors.  It is possible to do only one of the above without the other.  </p>\n<p>In the general case this scenario does lack usefulness and just lead to confusion with stack allocated values.  Off the top of my head I can't think of a good scenario where you would want to do this (although I'm sure there is potentially one).  However it is possible to think of contrived scenarios where this would be legal.</p>\n<pre><code>class StackPointer&lt;T&gt; {\n  T* m_pData;\npublic:\n  StackPointer(T* pData) :m_pData(pData) {}\n  ~StackPointer() { \n    delete m_pData; \n    m_pData = NULL; \n  }\n  StackPointer&amp; operator=(T* pOther) {\n    this-&gt;~StackPointer();\n    m_pData = pOther;\n    return this;\n  }\n};\n</code></pre>\n<p>Note: Please don't ever code a class this way.  Have an explicit Release method instead.  </p>\n", "OwnerUserId": "23283", "PostTypeId": "2", "Id": "3291543", "Score": "1", "CreationDate": "2010-07-20T15:21:15.080", "LastActivityDate": "2010-07-20T15:21:15.080"}, "3291558": {"ParentId": "3291507", "CommentCount": "2", "Body": "<p>It's undefined behavior -- but as with any UB, one possibility is that it (more or less) appears to work, at least for some definition of work.</p>\n<p>Essentially the only time you need (or want) to explicitly invoke a destructor is in conjunction with placement new (i.e., you use placement new to create an object at a specified location, and an explicit dtor invocation to destroy that object).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3291558", "Score": "6", "CreationDate": "2010-07-20T15:22:27.190", "LastActivityDate": "2010-07-20T15:22:27.190"}, "3291628": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>From <a href=\"http://www.devx.com/tips/Tip/12684\" rel=\"nofollow noreferrer\">http://www.devx.com/tips/Tip/12684</a></p>\n<blockquote>\n<p id=\"so_3291507_3291628_0\">Undefined behavior indicates that an implementation may behave unpredictably when a program reaches a certain state, which almost without exception is a result of a bug. Undefined behavior can be manifested as a run time crash, unstable and unreliable program state, or--in rare cases--it <strong>may even pass unnoticed</strong>.</p>\n</blockquote>\n<p>In your case it doesn't crash because the destructor doesn't manipulate any field; actually, your class doesn't have any data members at all. If it did and in destructor's body you manipulated it in any way, you would likely get a run-time exception while calling destructor for the second time.</p>\n", "OwnerUserId": "232403", "PostTypeId": "2", "Id": "3291628", "Score": "3", "CreationDate": "2010-07-20T15:29:52.333", "LastActivityDate": "2010-07-20T15:29:52.333"}, "3291763": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>I believe that if you want your code to be OK you simply need to call placement new and fill it back in before exiting.  The call to the destructor isn't the issue, it's the second call to the destructor made when you leave scope.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "3291763", "Score": "0", "CreationDate": "2010-07-20T15:42:24.630", "LastActivityDate": "2010-07-20T15:42:24.630"}, "3292516": {"ParentId": "3291507", "CommentCount": "0", "Body": "<p>It is undefined behaviour. The undefined behaviour is the double destructor call and not with the destructor call itself. If you modify your example to:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass some{ public: ~some() { [INSERT ANY CODE HERE] } };\nint main() { some s; s.~some(); }\n</code></pre>\n<p>where <strong>[INSERT ANY CODE HERE]</strong> can be replaced with any arbitrary code. The results have unpredictable side effects, which is why it is considered undefined.</p>\n", "OwnerUserId": "361945", "PostTypeId": "2", "Id": "3292516", "Score": "0", "CreationDate": "2010-07-20T17:13:01.417", "LastActivityDate": "2010-07-20T17:13:01.417"}, "3291787": {"ParentId": "3291507", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The behavior is undefined because the destructor is invoked twice for the same object:</p>\n<ul>\n<li>Once when you invoke it explicitly</li>\n<li>Once when the scope ends and the automatic variable is destroyed</li>\n</ul>\n<p>Invoking the destructor on an object whose lifetime has ended results in undefined behavior per C++03 \u00a712.4/6:</p>\n<blockquote>\n<p id=\"so_3291507_3291787_0\">the behavior is undefined if the destructor is invoked for an object whose lifetime has ended</p>\n</blockquote>\n<p>An object's lifetime ends when its destructor is called per \u00a73.8/1:</p>\n<blockquote>\n<p id=\"so_3291507_3291787_1\">The lifetime of an object of type <code>T</code> ends when:</p>\n<p id=\"so_3291507_3291787_2\">\u2014 if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_3291507_3291787_3\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>Note that this means if your class has a trivial destructor, the behavior is well-defined because the lifetime of an object of such a type does not end until its storage is released, which for automatic variables does not happen until the end of the function.  Of course, I don't know why you would explicitly invoke the destructor if it is trivial.  </p>\n<p>What is a trivial destructor?  \u00a712.4/3 says:</p>\n<blockquote>\n<p id=\"so_3291507_3291787_4\">A destructor is trivial if it is an implicitly-declared destructor and if:</p>\n<p id=\"so_3291507_3291787_5\">\u2014 all of the direct base classes of its class have trivial destructors and</p>\n<p id=\"so_3291507_3291787_6\">\u2014 for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.</p>\n</blockquote>\n<p>As others have mentioned, one possible result of undefined behavior is your program appearing to continue running correctly; another possible result is your program crashing.  Anything can happen and there are no guarantees whatsoever.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2010-07-20T16:12:22.797", "Id": "3291787", "Score": "15", "CreationDate": "2010-07-20T15:44:50.863", "LastActivityDate": "2010-07-20T16:12:22.797"}});