post_cb({"41594186": {"CommentCount": "11", "AcceptedAnswerId": "41707564", "PostTypeId": "1", "LastEditorUserId": "2428389", "CreationDate": "2017-01-11T15:03:31.153", "LastActivityDate": "2017-01-18T15:30:22.723", "LastEditDate": "2017-01-11T15:45:37.667", "ViewCount": "405", "FavoriteCount": "0", "Title": "What rules govern use of multiple user-defined conversions between types?", "Id": "41594186", "Score": "11", "Body": "<p>I have this code:</p>\n<pre><code>class MyString\n{\npublic:\n    operator const char*() const {\n        return nullptr;\n    }\n};\n\nclass YourString\n{\npublic:\n    YourString() {}\n    YourString(const char* ptr) {\n        (void)ptr;\n    }\n\n    YourString&amp; operator=(const char* ptr)\n    {\n        return *this;\n    }\n};\n\nint main()\n{\n    MyString mys;\n\n    YourString yoursWorks;\n    yoursWorks = mys;\n\n    YourString yoursAlsoWorks(mys);\n\n    YourString yoursBreaks = mys;\n}\n</code></pre>\n<p>MSVC accepts it without issue. Clang-CL does not accept it:</p>\n<pre><code>$ \"C:\\Program Files\\LLVM\\msbuild-bin\\CL.exe\" ..\\string_conversion.cpp\n..\\string_conversion.cpp(32,13):  error: no viable conversion from 'MyString' to 'YourString'\n        YourString yoursBreaks = mys;\n                   ^             ~~~\n..\\string_conversion.cpp(10,7):  note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'MyString' to\n      'const YourString &amp;' for 1st argument\nclass YourString\n      ^\n..\\string_conversion.cpp(10,7):  note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'MyString' to\n      'YourString &amp;&amp;' for 1st argument\nclass YourString\n      ^\n..\\string_conversion.cpp(14,2):  note: candidate constructor not viable: no known conversion from 'MyString' to 'const char *' for 1st argument\n        YourString(const char* ptr) {\n        ^\n..\\string_conversion.cpp(5,2):  note: candidate function\n        operator const char*() const {\n        ^\n1 error generated.\n</code></pre>\n<p>Nor does GCC:</p>\n<pre><code>$ g++.exe -std=gnu++14 ..\\string_conversion.cpp\n..\\string_conversion.cpp: In function 'int main()':\n..\\string_conversion.cpp:33:27: error: conversion from 'MyString' to non-scalar type 'YourString' requested\n  YourString yoursBreaks = mys;\n                           ^\n</code></pre>\n<p>I understand that only one user-defined conversion is allowed.</p>\n<p>However, is MSVC justified in treating the line </p>\n<pre><code>YourString yoursBreaks = mys;\n</code></pre>\n<p>as </p>\n<pre><code>YourString yoursBreaks(mys);\n</code></pre>\n<p>and accepting it? Is that a conversion compilers are allowed to do? Under what rules is it allowed/disallowed? Is there a similar rule?</p>\n<p>Update: With MSVC, the <code>/Za</code> flag causes the code to not be accepted.</p>\n<pre><code>$ \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\x86_amd64\\CL.exe\" /Za ..\\string_conversion.cpp\n\nstring_conversion.cpp\n..\\string_conversion.cpp(33): error C2440: 'initializing': cannot convert from 'MyString' to 'YourString'\n..\\string_conversion.cpp(33): note: No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called\n</code></pre>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "2428389", "AnswerCount": "3"}, "41688134": {"ParentId": "41594186", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Let's look at the rules for implicit conversions <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow noreferrer\">found here</a>. The interesting bit is this :</p>\n<blockquote>\n<p id=\"so_41594186_41688134_0\">Implicit conversions are performed whenever an expression of some type T1 is used in context that does not accept that type, but accepts some other type T2; in particular: [...]when initializing a new object of type T2[...]</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_41594186_41688134_1\">A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit conversion function call</p>\n</blockquote>\n<p><strong>Case 1</strong></p>\n<pre><code>YourString yoursWorks;\nyoursWorks = mys;\n</code></pre>\n<p>In the first case, we need one non-explicit conversion function call. <code>YourString::operator=</code> expects <code>const char*</code> and is given a <code>MyString</code>. <code>MyString</code> provides a the non-explicit conversion function for this conversion.</p>\n<p><strong>Case 2</strong></p>\n<pre><code>YourString yoursAlsoWorks(mys);\n</code></pre>\n<p>In the second case, we again need one non-explicit conversion function call. <code>YourString::YourString</code> expects <code>const char*</code> and is given a MyString. <code>MyString</code> provides a the non-explicit conversion function for this conversion.</p>\n<p><strong>Case 3</strong></p>\n<pre><code>YourString yoursBreaks = mys;\n</code></pre>\n<p>The third case is different because it's not an assignment copy as it would appear. Contrary to the second case, <code>yoursBreaks</code> has not been initialized yet. You cannot call the assignment operator <code>operator=</code> on an object that hasn't been constructed yet. It's in fact an assignment by copy construction. To assign <code>mys</code> to <code>yoursBreaks</code> we need <strong>both</strong> a non-explicit conversion function call (to convert <code>mys</code> to <code>const char*</code> and <em>then</em> a non-explicit single-argument constructor (to construct the <code>YourString</code> from a <code>const char *</code>. Implicit conversions only allow for one <em>or</em> the other.</p>\n", "OwnerUserId": "7359094", "LastEditorUserId": "7359094", "LastEditDate": "2017-01-17T02:42:09.110", "Id": "41688134", "Score": "1", "CreationDate": "2017-01-17T02:23:53.553", "LastActivityDate": "2017-01-17T02:42:09.110"}, "bq_ids": {"n4140": {"so_41594186_41707564_5": {"section_id": 609, "quality": 1.0, "length": 11}, "so_41594186_41707564_1": {"section_id": 3296, "quality": 0.7910447761194029, "length": 53}, "so_41594186_41688134_1": {"section_id": 615, "quality": 0.5833333333333334, "length": 7}, "so_41594186_41707564_8": {"section_id": 3296, "quality": 0.8666666666666667, "length": 26}, "so_41594186_41707564_0": {"section_id": 3294, "quality": 0.6956521739130435, "length": 16}, "so_41594186_41707564_6": {"section_id": 609, "quality": 0.7777777777777778, "length": 35}, "so_41594186_41707564_2": {"section_id": 593, "quality": 0.8947368421052632, "length": 68}, "so_41594186_41707564_3": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_41594186_41707564_9": {"section_id": 592, "quality": 0.6153846153846154, "length": 8}, "so_41594186_41707564_4": {"section_id": 608, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_41594186_41707564_5": {"section_id": 584, "quality": 0.5454545454545454, "length": 6}, "so_41594186_41707564_1": {"section_id": 3166, "quality": 0.7910447761194029, "length": 53}, "so_41594186_41688134_1": {"section_id": 605, "quality": 0.5833333333333334, "length": 7}, "so_41594186_41707564_8": {"section_id": 3166, "quality": 0.8666666666666667, "length": 26}, "so_41594186_41707564_0": {"section_id": 3164, "quality": 0.6956521739130435, "length": 16}, "so_41594186_41707564_2": {"section_id": 583, "quality": 0.868421052631579, "length": 66}, "so_41594186_41707564_3": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_41594186_41707564_9": {"section_id": 582, "quality": 0.6153846153846154, "length": 8}, "so_41594186_41707564_4": {"section_id": 598, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_41594186_41707564_6": {"section_id": 635, "quality": 0.7777777777777778, "length": 35}, "so_41594186_41707564_5": {"section_id": 635, "quality": 1.0, "length": 11}, "so_41594186_41707564_1": {"section_id": 4058, "quality": 0.9701492537313433, "length": 65}, "so_41594186_41707564_8": {"section_id": 4058, "quality": 0.8666666666666667, "length": 26}, "so_41594186_41707564_0": {"section_id": 4056, "quality": 0.782608695652174, "length": 18}, "so_41594186_41707564_2": {"section_id": 616, "quality": 0.9473684210526315, "length": 72}, "so_41594186_41707564_3": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_41594186_41707564_9": {"section_id": 615, "quality": 0.9230769230769231, "length": 12}, "so_41594186_41707564_4": {"section_id": 634, "quality": 0.7222222222222222, "length": 13}}}, "41707564": {"ParentId": "41594186", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>tldr; The code is ill-formed, MSVC is wrong to accept it. Copy-initialization is different from direct-initialization. The layman explanation is that the initialization of <code>yoursBreaks</code> would involve two user-defined conversions (<code>MyString --&gt; const char* --&gt; YourString</code>), whereas direct-initialization involves one user-defined conversion (<code>MyString --&gt; const char*</code>), and you are allowed at most one user-defined conversion. The standardese explanation which enforces that rule is that [over.best.ics] doesn't allow for user-defined conversions in the context of copy-initialization of a class type from an unrelated class type by way of converting constructor.</p>\n<hr/>\n<p>To the standard! What does:</p>\n<pre><code>YourString yoursBreaks = mys;\n</code></pre>\n<p>mean? Any time we declare a variable, that's some kind of <em>initialization</em>. In this case, it is, according to [dcl.init]:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_0\">The initialization that occurs in the <code>=</code> form of a <em>brace-or-equal-initializer</em> or condition (6.4), as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.6.1), is called <strong><em>copy-initialization</em></strong>.</p>\n</blockquote>\n<p>Copy-initialization is anything of the form <code>T var = expr;</code> Despite the appearance of the <code>=</code>, this never invokes <code>operator=</code>.  We always goes through either a constructor or a conversion function.</p>\n<p>Specifically, this case:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_1\">If the destination type is a (possibly cv-qualified) class type:<br>\n  \u2014 If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same\n  class as the class of the destination, [...]<br>\n  \u2014 Otherwise, if the initialization is direct-initialization, or if it is copy-initialization where the\n  cv-unqualified version of the source type is the same class as, or a derived class of, the class of the\n  destination, [...]<br>\n  \u2014 Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that\n  can convert from the source type to the destination type or (when a conversion function is used) to\n  a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through\n  overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is\n  ill-formed.</br></br></br></p>\n</blockquote>\n<p>We fall into that last bullet. Let's hop over into 13.3.1.4:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_2\">\u2014 The converting constructors (12.3.1) of T are candidate functions.<br>\n  \u2014 When the type of the initializer expression is a class type \u201c<em>cv</em> <code>S</code>\u201d, the non-explicit conversion functions of <code>S</code> and its base classes are considered. When initializing a temporary to be bound to the first parameter\n  of a constructor where the parameter is of type \u201creference to possibly <em>cv</em>-qualified <code>T</code>\u201d and the constructor is called with a single argument in the context of direct-initialization of an object of type \u201c<em>cv2</em> <code>T</code>\u201d,\n  explicit conversion functions are also considered. <strong>Those that are not hidden within <code>S</code> and yield a type whose cv-unqualified version is the same type as <code>T</code> or is a derived class thereof are candidate functions</strong>. Conversion functions that return \u201creference to <code>X</code>\u201d return lvalues or xvalues, depending on the type\n  of reference, of type <code>X</code> and are therefore considered to yield <code>X</code> for this process of selecting candidate functions.</br></p>\n</blockquote>\n<p>The first bullet point gives us the converting constructors of <code>YourString</code>, which are:</p>\n<pre><code>YourString(const char* );\n</code></pre>\n<p>The second bullet gives us nothing. <code>MyString</code> does not have a conversion function that returns <code>YourString</code> or a class type derived from it.</p>\n<hr/>\n<p>So, okay. We have one candidate constructor. Is it viable? [over.match] checks reliability via:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_3\">Then the best viable function is selected based on the <strong>implicit conversion sequences (13.3.3.1)</strong> needed to match each argument to the corresponding parameter of each viable function.</p>\n</blockquote>\n<p>and, in [over.best.ics]:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_4\">A well-formed implicit conversion sequence is one of the following forms:<br>\n  \u2014 a standard conversion sequence (13.3.3.1.1),<br>\n  \u2014 a user-defined conversion sequence (13.3.3.1.2), or<br>\n  \u2014 an ellipsis conversion sequence (13.3.3.1.3).</br></br></br></p>\n<p id=\"so_41594186_41707564_5\">However, if the target is<br>\n  \u2014 <strong>the first parameter of a constructor</strong> or<br>\n  \u2014 the implicit object parameter of a user-defined conversion function  </br></br></p>\n<p id=\"so_41594186_41707564_6\">and the constructor or user-defined conversion function is a candidate by<br>\n  \u2014 13.3.1.3, when the argument is the temporary in the second step of a class copy-initialization,<br>\n  \u2014 <strong>13.3.1.4</strong>, 13.3.1.5, or 13.3.1.6 (in all cases), or<br>\n  \u2014 the second phase of 13.3.1.7 [...]<br>\n<strong>user-defined conversion sequences are not considered.</strong> <em>[ Note:</em> These rules prevent more than one user-defined\n  conversion from being applied during overload resolution, thereby avoiding infinite recursion. <em>\u2014end note ]</em> <em>[ Example:</em></br></br></br></br></p>\n<pre><code>struct Y { Y(int); };\nstruct A { operator int(); };\nY y1 = A(); // error: A::operator int() is not a candidate\n\nstruct X { };\nstruct B { operator X(); };\nB b;\nX x({b}); // error: B::operator X() is not a candidate\n</code></pre>\n<p id=\"so_41594186_41707564_7\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>So even though there is a conversion sequence from <code>MyString</code> to <code>const char*</code>, it is not considered in this case, so this constructor is not viable.</p>\n<p>Since we don't have another candidate constructor, the call is ill-formed.</p>\n<hr/>\n<p>The other line:</p>\n<pre><code>YourString yoursAlsoWorks(mys);\n</code></pre>\n<p>is called <em>direct-initialization</em>. We call into the 2nd bullet point of the three in the [dcl.init] block I quoted earlier, which in its entirety reads:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_8\">The applicable constructors are enumerated (13.3.1.3),\n  and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>where 13.3.1.3 indicates that constructors are enumerated from:</p>\n<blockquote>\n<p id=\"so_41594186_41707564_9\">For direct-initialization\n  or default-initialization that is not in the context of copy-initialization, the candidate functions are all the constructors of the class of the object being initialized. </p>\n</blockquote>\n<p>Those constructors are:</p>\n<pre><code>YourString(const char* )        // yours\nYourString(YourString const&amp; )  // implicit\nYourString(YourString&amp;&amp; )       // implicit\n</code></pre>\n<p>To check the viability of the latter two functions, we re-perform overload resolution from a copy-initialization context (which fails as per the above). But for your <code>YourString(const char*)</code>, it's straightforward, there is a viable conversion function from <code>MyString</code> to <code>const char*</code>, so it's used. </p>\n<p>Note that there is one single conversion here: <code>MyString --&gt; const char*</code>. One conversion is fine. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-01-18T15:30:22.723", "Id": "41707564", "Score": "10", "CreationDate": "2017-01-17T21:44:31.040", "LastActivityDate": "2017-01-18T15:30:22.723"}, "41687158": {"ParentId": "41594186", "CommentCount": "4", "Body": "<p>First of all</p>\n<pre><code>YourString yoursWorks;\nyoursWorks = mys;\n</code></pre>\n<p>is not equivalent to</p>\n<pre><code>YourString yoursAlsoWorks(mys);\n</code></pre>\n<p>or to</p>\n<pre><code>YourString yoursBreaks = (const char*) mys;\n</code></pre>\n<p>The first approach uses the constructor </p>\n<pre><code>YourString() {}\n</code></pre>\n<p>followed by MyString's conversion operator, and YourString's \nassignment operator.</p>\n<p>The second approach uses the constructor</p>\n<pre><code>YourString(const char* ptr) {(void)ptr;}\n</code></pre>\n<p>and MyString's conversion operator.</p>\n<p>(This might be demonstrated by adding trace statements to the constructors.)</p>\n<p>Then, when the (const char*) cast is missing from the last statement,\nMSVC will assume that it should be added implicitly.\nWhile this looks a reasonable approach, it conflicts the description\nin Stroustrup's book The C++ Programming Language 4th edition:</p>\n<blockquote>\n<p id=\"so_41594186_41687158_0\">18.4 Type Conversion\n       ... \n      explicit, that is, the conversion is only performed in a direct initialization i.e., as an initializer not using\n  a =. \n      ...</p>\n</blockquote>\n", "OwnerUserId": "7390790", "PostTypeId": "2", "Id": "41687158", "Score": "0", "CreationDate": "2017-01-17T00:23:09.150", "LastActivityDate": "2017-01-17T00:23:09.150"}});