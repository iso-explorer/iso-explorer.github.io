post_cb({"9890953": {"ParentId": "9890218", "CommentCount": "8", "Body": "<p>You are heading the wrong way.</p>\n<p>The type of <code>this</code> is purely dictacted by the signature of the method in which you use it. That is, <code>this</code> is always of type <code>cv T* const</code> where <code>cv</code> corresponds to the CV qualifiers of the method.</p>\n<p>Therefore, in a constructor, <code>this</code> is just <code>T* const</code>.</p>\n<hr>\n<p><code>const_cast</code> is a code smell, normally only of use when dealing with <code>const</code>-broken legacy libraries... or (sometimes) to avoid violating DRY. In new code, you should not have to use it.</p>\n<p>You are left with a choice:</p>\n<ul>\n<li>make <code>AccessValue</code> non-const, since it is not</li>\n<li>declare <code>i</code> as being <code>mutable</code>.</li>\n</ul>\n<p>I would advise choosing the former solution. Giving away a handle to a <code>private</code> attribute is bad already (breaks encapsulation), no need to violate <code>const</code> correctness as well.</p>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9890953", "Score": "3", "CreationDate": "2012-03-27T13:52:43.387", "LastActivityDate": "2012-03-27T13:52:43.387"}, "9890218": {"CommentCount": "9", "CreationDate": "2012-03-27T13:12:10.667", "PostTypeId": "1", "AcceptedAnswerId": "9890953", "LastEditorUserId": "476681", "LastActivityDate": "2013-03-08T19:08:07.883", "LastEditDate": "2013-03-08T19:08:07.883", "ViewCount": "1614", "FavoriteCount": "1", "Title": "Check if object declared const", "Id": "9890218", "Score": "1", "Body": "<p>I would like to break the compilation if the object is declared const.</p>\n<p>The following doesn't work :</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct A {\n\n    A() : v(0)\n    {\n        static_assert( ! std::is_const&lt;decltype(*this)&gt;::value, \"declared as const\" );\n    }\n\n    int&amp; AccessValue() const\n    {\n        return const_cast&lt; int&amp; &gt;( v );\n    }\n\n    int v;\n};\n\nint main()\n{\n    A a1; // ok, this compiles\n    const A a2; // no, this break the compilation\n\n    a1.AccessValue() = 5; // ok\n    a2.AccessValue() = 6; // OPS\n}\n</code></pre>\n<p>So, is there a way to break the compilation if an object of this type is declared const?</p>\n", "Tags": "<c++><c++11><typetraits>", "OwnerUserId": "476681", "AnswerCount": "3"}, "9890459": {"ParentId": "9890218", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>you can have multiple variables referring to the same object, some mutable and some const.\nFor example:</p>\n<pre><code>A a1;\nconst A &amp;a2 = a1;\nA * const pa = &amp;a1;\nf(a1);\n....\nvoid f(const A &amp;a);\n</code></pre>\n<p>should these be allowed in your case?\nConversion from mutable to const is implicit the reverse is not. \nMaybe if you give an example will help.</p>\n<p>EDIT: (in response to modified code)\nwith a const object you can call only const member function.\nwhy not have:</p>\n<pre><code>int&amp; AccessValue()\n{\n    return v;\n}\n</code></pre>\n<p>an the compiler with complain if you call AccessValue on a non const object.</p>\n", "OwnerUserId": "1273776", "LastEditorUserId": "1273776", "LastEditDate": "2012-03-27T13:42:21.427", "Id": "9890459", "Score": "0", "CreationDate": "2012-03-27T13:27:54.077", "LastActivityDate": "2012-03-27T13:42:21.427"}, "bq_ids": {"n4140": {"so_9890218_9890859_1": {"section_id": 6132, "quality": 0.8571428571428571, "length": 12}, "so_9890218_9890859_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_9890218_9890859_1": {"section_id": 5896, "quality": 0.8571428571428571, "length": 12}, "so_9890218_9890859_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_9890218_9890859_1": {"section_id": 7629, "quality": 0.8571428571428571, "length": 12}, "so_9890218_9890859_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}, "9890859": {"ParentId": "9890218", "CommentCount": "2", "Body": "<p>For your specific example, making <code>i</code> mutable would achieve your goal:</p>\n<pre><code>int&amp; AccessValue() const\n{\n    return v;\n}\n\nmutable int v;\n</code></pre>\n<p>This is from \u00a77.1.6.1/4 [dcl.type.cv]:</p>\n<blockquote>\n<p id=\"so_9890218_9890859_0\"><strong>Except that any class member declared mutable (7.1.1) can be modified</strong>, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>Note that you can't modify <code>v</code> using a pointer-to-member on a const object - \u00a75.5/5 of n3290 draft [expr.mptr.oper]: </p>\n<blockquote>\n<p id=\"so_9890218_9890859_1\">[ Note: it is not possible to use a pointer to member that refers to a mutable member to modify a const class object. For example,</p>\n</blockquote>\n<pre><code>struct S {\nS() : i(0) { }\nmutable int i;\n};\n\nvoid f()\n{\nconst S cs;\nint S::* pm = &amp;S::i; // pm refers to mutable member S::i\ncs.*pm = 88;         // ill-formed: cs is a const object\n}\n</code></pre>\n<blockquote>\n<p id=\"so_9890218_9890859_2\">\u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "9890859", "Score": "1", "CreationDate": "2012-03-27T13:48:55.053", "LastActivityDate": "2012-03-27T13:48:55.053"}});