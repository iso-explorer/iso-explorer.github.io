post_cb({"24877338": {"CommentCount": "6", "ViewCount": "661", "OwnerDisplayName": "Jason", "CreationDate": "2014-07-22T00:05:14.010", "LastActivityDate": "2016-02-26T08:28:29.403", "PostTypeId": "1", "AcceptedAnswerId": "24877422", "FavoriteCount": "1", "Title": "How can I pass floating point numbers as template parameters?", "Id": "24877338", "Score": "2", "Body": "<p>I am working on a meta-programming project, and we would like to have the ability to pass floating-point numbers as template arguments. I wasn't sure whether this question would be better suited to Stack Exchange, but I figured it's a somewhat conceptual so opted for this site.</p>\n<p>Basically, I want to do this:</p>\n<pre><code>template &lt;double var&gt;\ndouble fun() { return var; }\n\nint main()\n{\n  double myDoble = fun&lt;1.0&gt;();\n  return 0;\n}\n</code></pre>\n<p>Obviously, this can't be done. This link (<a href=\"http://en.cppreference.com/w/cpp/language/template_parameters\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/template_parameters</a>) makes it clear that the type passed as a template argument must be one of the following:</p>\n<pre><code>integral type\nenumeration\npointer to object or to function\nlvalue reference to object or to function\npointer to member object or to member function\nstd::nullptr_t (since C++11)\n</code></pre>\n<p>However, the fact that I can pass a pointer to an object (perhaps a pointer to a struct containing a double?) makes me wonder that there might be a way of achieving the above by passing a pointer to such a double.</p>\n<p>So I tried this:</p>\n<pre><code>template &lt;double* pVar&gt;\ndouble fun()\n{\n    return *pVar;\n}\n\nint main() {\n    static const double param = 1.2;\n    double value = fun&lt;&amp;param&gt;();\n    return 0;\n}\n</code></pre>\n<p>which gives the following error:</p>\n<pre><code>prog.cpp:9:29: error: \u2018&amp; param\u2019 is not a valid template argument of type \u2018double*\u2019 because \u2018param\u2019 has no linkage\n  double value = fun&lt;&amp;param&gt;();\n</code></pre>\n<p>I thought that the issue might be that I'm using a primitive, so I tried this:</p>\n<pre><code>struct D\n{\n    double val;\n};\n\ntemplate &lt;D* pD&gt;\ndouble fun()\n{\n    return pD-&gt;val;\n}\n\nint main() {\n    static const D d{1.2};\n\n    double value = fun&lt;&amp;d&gt;();\n    return 0;\n}\n</code></pre>\n<p>which gives the same error.</p>\n<p>Does anyone have other ideas for approaching this problem? I would appreciate it if people could refrain from \"it can't be done\" answers; I know it can't be done, I want to do it anyway! ;)</p>\n", "Tags": "<c++>", "OwnerUserId": "1613983", "AnswerCount": "4"}, "24877581": {"ParentId": "24877338", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The problem here is that only objects with linkage can be used as template non-type address arguments, we can see this by going to the draft C++ standard section <code>14.3.2</code> <em>Template non-type arguments</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_24877338_24877581_0\">A template-argument for a non-type, non-template template-parameter\n  shall be one of:</p>\n</blockquote>\n<p>and include the following bullet:</p>\n<blockquote>\n<p id=\"so_24877338_24877581_1\">a constant expression (5.19) that designates the address of an object\n  with static storage duration <strong>and external or internal linkage</strong> or a\n  function with external or internal linkage [...]</p>\n</blockquote>\n<p>Which is exactly what your error says:</p>\n<blockquote>\n<p id=\"so_24877338_24877581_2\">[...]because \u2018param\u2019 has no linkage</p>\n</blockquote>\n<p>and we can see that block scope variables with some exceptions have no linkage, this is covered in section <code>3.5</code> <em>Program and linkage</em> which says:</p>\n<blockquote>\n<p id=\"so_24877338_24877581_3\">Names not covered by these rules have no linkage. Moreover, except as\n  noted, a name declared at block scope (3.3.3) has no linkage. A type\n  is said to have linkage if and only if:</p>\n</blockquote>\n<p>and does not include any exceptions for this case. </p>\n<p>Declaring it globally, would solve your issue in this case:</p>\n<pre><code>static double param = 1.2;\n\nint main()\n{\n    double value = fun&lt;&amp;param&gt;();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-07-22T02:00:28.997", "Id": "24877581", "Score": "2", "CreationDate": "2014-07-22T01:38:14.967", "LastActivityDate": "2014-07-22T02:00:28.997"}, "24877821": {"ParentId": "24877338", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you want <code>*pVar</code> to be a compile-time constant for the purposes of optimising <code>fun()</code> and using it where only a constant is accept (e.g. as a template parameter or array dimension), you need to accept it as <code>const double* const</code> and make <code>param</code> be <code>constexpr</code> (code below also at <a href=\"http://ideone.com/3PpmO9\" rel=\"nofollow\">ideone.com here</a>)...</p>\n<pre><code>template &lt;int n&gt;\nstruct S { };\n\ntemplate &lt;const double* const pVar&gt;\ndouble fun()\n{\n    S&lt;(int)*pVar&gt; s;\n    return *pVar;\n}\n\nconstexpr double param = 1.2;\n\nint main()\n{\n   double value = fun&lt;&amp;param&gt;();\n}\n</code></pre>\n<p>Note that if different places in your code provide the template with pointers to distinct <code>double</code>s having the same value, you will probably get distinct instantiations in your executable (i.e. pointless \"code bloat\", failed attempts at specialisation...).</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2014-07-22T03:57:42.783", "Id": "24877821", "Score": "2", "CreationDate": "2014-07-22T02:13:42.867", "LastActivityDate": "2014-07-22T03:57:42.783"}, "35646874": {"ParentId": "24877338", "CommentCount": "0", "Body": "<p>If you really want to pass double's to templated function, you should use a wrapper.\nLike this one:</p>\n<pre><code>struct D\n{\n    operator double(){ return 1.2; }\n};\n\ntemplate &lt;typename T&gt;\ndouble fun()\n{\n    T t;\n    return t;\n}\n\nint main()\n{\n    double value = fun&lt;D&gt;();\n    return 0;\n}\n</code></pre>\n<p>but maybe more useful is to define a macro like this:</p>\n<pre><code>#define DBLWRAPPER(dbl) typedef struct { operator double(){ return dbl; } }\n\nint main()\n{\n    DBLWRAPPER(1.2) DBL1_2;\n    DBLWRAPPER(2.45) DBL2_45;\n\n    double value1_2 = fun&lt;DBL1_2&gt;();\n    double value2_45 = fun&lt;DBL2_45&gt;();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3119327", "PostTypeId": "2", "Id": "35646874", "Score": "2", "CreationDate": "2016-02-26T08:28:29.403", "LastActivityDate": "2016-02-26T08:28:29.403"}, "bq_ids": {"n4140": {"so_24877338_24877581_1": {"section_id": 87, "quality": 0.9375, "length": 15}, "so_24877338_24877581_3": {"section_id": 7141, "quality": 0.9444444444444444, "length": 17}, "so_24877338_24877581_0": {"section_id": 87, "quality": 1.0, "length": 5}}, "n3337": {"so_24877338_24877581_1": {"section_id": 82, "quality": 0.9375, "length": 15}, "so_24877338_24877581_3": {"section_id": 6885, "quality": 0.9444444444444444, "length": 17}, "so_24877338_24877581_0": {"section_id": 82, "quality": 1.0, "length": 5}}, "n4659": {"so_24877338_24877581_3": {"section_id": 8642, "quality": 0.9444444444444444, "length": 17}}}, "24877422": {"ParentId": "24877338", "CommentCount": "0", "Body": "<p>This works for me:</p>\n<pre><code>template &lt;double* pVar&gt;\ndouble fun()\n{\n    return *pVar;\n}\n\ndouble param = 1.2;\n\nint main() {\n   double value = fun&lt;&amp;param&gt;();\n   return 0;\n}\n</code></pre>\n<p>I'm using g++ 4.8.2.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "24877422", "Score": "2", "CreationDate": "2014-07-22T01:18:49.400", "LastActivityDate": "2014-07-22T01:18:49.400"}});