post_cb({"39137480": {"Id": "39137480", "PostTypeId": "2", "Body": "<p>Template argument deduction works well here, because for function template, the subsequent template arguments might be deduced by function arguments. In this case, template argument <code>U</code> could be deduced from function argument <code>u</code>. Note that for class template, as you expected, the subsequent template-parameter after a default template-argument shall either have a default template-argument or be a template parameter pack.</p>\n<p><a href=\"http://eel.is/c++draft/temp.param#11\" rel=\"noreferrer\">$14.1/11 Template parameters\n[temp.param]</a>:</p>\n<blockquote>\n<p id=\"so_39137281_39137480_0\">If a template-parameter of a class template, variable template, or\n  alias template has a default template-argument, each subsequent\n  template-parameter shall either have a default template-argument\n  supplied or be a template parameter pack. If a template-parameter of a\n  primary class template, primary variable template, or alias template\n  is a template parameter pack, it shall be the last template-parameter.\n  A template parameter pack of a function template shall not be followed\n  by another template parameter unless that template parameter can be\n  deduced from the parameter-type-list ([dcl.fct]) of the function\n  template or has a default argument ([temp.deduct]). A template\n  parameter of a deduction guide template ([temp.deduct.guide]) that\n  does not have a default argument shall be deducible from the\n  parameter-type-list of the deduction guide template. [ Example:</p>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B;   // error\n\n// U can be neither deduced from the parameter-type-list nor specified\ntemplate&lt;class... T, class... U&gt; void f() { } // error\ntemplate&lt;class... T, class U&gt; void g() { }    // error\n</code></pre>\n<p id=\"so_39137281_39137480_1\">\u2014 end example ]</p>\n</blockquote>\n<p>You could try to make <code>U</code> undeducible and see what will happen:</p>\n<pre><code>template &lt;bool T=true, class U&gt;   //\"default\" from LEFT-most parameter\nvoid f(){\n    if(T){ cout&lt;&lt;true;}\n    else cout&lt;&lt;false;\n}\nint main() {\n    f();            // Fail. Can't deduce U.\n    f&lt;true&gt;();      // Fail. Can't deduce U.\n    f&lt;true, int&gt;(); // Fine. T=true, U=int.\n    return 0;\n}\n</code></pre>\n<p>Note you have to specify all the template arguments explicitly to make the code work, which makes default template arguments meaningless at all. If you want to make <code>f()</code> or <code>f&lt;true&gt;()</code> work, you need to give <code>U</code> a default template-argument too (or make it template parameter pack).</p>\n<pre><code>template &lt;bool T=true, class U=int&gt;\nvoid f(){\n    if(T){ cout&lt;&lt;true;}\n    else cout&lt;&lt;false;\n}\nint main() {\n    f();              // Fine. T=true,  U=int\n    f&lt;false&gt;();       // Fine. T=false, U=int\n    f&lt;false, char&gt;(); // Fine. T=false, U=char\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-08-25T06:29:08.567", "Score": "8", "CreationDate": "2016-08-25T05:41:30.473", "ParentId": "39137281", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-08-25T06:29:08.567"}, "39137281": {"ViewCount": "148", "Body": "<p>Does default template parameter can use \"default value\" in a way that does NOT start from right?</p>\n<p>What is the criteria?<br>\nHow will the compiler interpret?</br></p>\n<p>For example, I am so surprised that <strong>this code works</strong>.      </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;bool T=true, class U&gt;   //\"default\" from LEFT-most parameter\nvoid f(U u){\n    if(T){ cout&lt;&lt;true;}\n    else cout&lt;&lt;false;\n}\nint main() {\n    auto x = []( ){  };\n    f(x);\n    return 0;\n}\n</code></pre>\n<p>See live demo here : <a href=\"https://ideone.com/l6d9du\" rel=\"noreferrer\">https://ideone.com/l6d9du</a></p>\n", "AcceptedAnswerId": "39137480", "Title": "default template parameter - don't have to be from right? Why it works?", "CreationDate": "2016-08-25T05:26:08.583", "Id": "39137281", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-25T06:06:25.473", "LastEditorUserId": "3309790", "LastActivityDate": "2016-08-25T06:29:08.567", "Score": "8", "OwnerUserId": "3577745", "Tags": "<c++><templates><default-parameters>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39137281_39137480_0": {"length": 47, "quality": 0.6714285714285714, "section_id": 64}}, "n3337": {"so_39137281_39137480_0": {"length": 44, "quality": 0.6285714285714286, "section_id": 59}}, "n4659": {"so_39137281_39137480_0": {"length": 66, "quality": 0.9428571428571428, "section_id": 66}}}, "39137433": {"Id": "39137433", "PostTypeId": "2", "Body": "<p>You can supply a default for any parameter.</p>\n<p>If you want to <em>use</em> the default, you can't explicitly specify parameters to the right of the defaulted parameter.  However, in your example, <code>U</code> is being deduced from the type of the argument to the function, and <code>T</code> is being defaulted.</p>\n", "LastActivityDate": "2016-08-25T05:38:12.037", "CommentCount": "0", "CreationDate": "2016-08-25T05:38:12.037", "ParentId": "39137281", "Score": "4", "OwnerUserId": "771073"}});