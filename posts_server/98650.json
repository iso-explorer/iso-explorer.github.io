post_cb({"bq_ids": {"n4140": {"so_98650_7005988_1": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_98650_7005988_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7239}, "so_98650_7005988_3": {"length": 9, "quality": 0.9, "section_id": 7239}}, "n3337": {"so_98650_7005988_1": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_98650_7005988_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6983}, "so_98650_7005988_3": {"length": 9, "quality": 0.9, "section_id": 6983}}, "n4659": {"so_98650_7005988_1": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_98650_7005988_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8748}, "so_98650_7005988_3": {"length": 9, "quality": 0.9, "section_id": 8748}}}, "16534243": {"Id": "16534243", "PostTypeId": "2", "Body": "<p>As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :</p>\n<p>check.c</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid check(short *h,long *k)\n{\n    *h=5;\n    *k=6;\n    if (*h == 5)\n        printf(\"strict aliasing problem\\n\");\n}\n\nint main(void)\n{\n    long      k[1];\n    check((short *)k,k);\n    return 0;\n}\n</code></pre>\n<p>Compile with <code>gcc -O2 -o check check.c</code> .\nUsually (with most gcc versions I tried) this outputs \"strict aliasing problem\", because the compiler assumes that \"h\" cannot be the same address as \"k\" in the \"check\" function. Because of that the compiler optimizes the <code>if (*h == 5)</code> away and always calls the printf.</p>\n<p>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</p>\n<pre><code>movw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC0, %edi\njmp puts\n</code></pre>\n<p>So the if condition is completely gone from the assembler code.</p>\n", "LastActivityDate": "2013-05-14T02:37:04.090", "Score": "24", "CreationDate": "2013-05-14T02:37:04.090", "ParentId": "98650", "CommentCount": "2", "OwnerUserId": "1917520"}, "98702": {"Body": "<p>The best explanation I have found is by Mike Acton, <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">Understanding Strict Aliasing</a>. It's focused a little on PS3 development, but that's basically just GCC.</p>\n<p>From the article:</p>\n<blockquote>\n<p id=\"so_98650_98702_0\">\"Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)\"</p>\n</blockquote>\n<p>So basically if you have an <code>int*</code> pointing to some memory containing an <code>int</code> and then you point a <code>float*</code> to that memory and use it as a <code>float</code> you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</p>\n<p>The exception to the rule is a <code>char*</code>, which is allowed to point to any type.</p>\n", "CreationDate": "2008-09-19T01:38:15.797", "ParentId": "98650", "CommentCount": "16", "LastEditDate": "2017-10-16T14:46:56.367", "PostTypeId": "2", "LastEditorDisplayName": "Niall Ryan", "LastActivityDate": "2017-10-16T14:46:56.367", "LastEditorUserId": "2157640", "Id": "98702", "OwnerDisplayName": "Niall Ryan", "Score": "187", "OwnerUserId": "6049"}, "98700": {"Body": "<p><a href=\"http://en.wikipedia.org/wiki/Type_punning\" rel=\"nofollow noreferrer\">Type punning</a> via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</p>\n", "CreationDate": "2008-09-19T01:38:01.117", "ParentId": "98650", "CommentCount": "4", "LastEditDate": "2014-07-06T18:31:53.523", "PostTypeId": "2", "OwnerDisplayName": "Chris Jester-Young", "LastEditorUserId": "13", "LastActivityDate": "2014-07-06T18:31:53.523", "Id": "98700", "Score": "14", "OwnerUserId": "13"}, "7005988": {"Id": "7005988", "PostTypeId": "2", "Body": "<p>This is the strict aliasing rule, found in section 3.10 of the <strong>C++03</strong> standard (other answers provide good explanation, but none provided the rule itself):</p>\n<blockquote>\n<p id=\"so_98650_7005988_0\">If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<p><strong>C++11</strong> and <strong>C++14</strong> wording (changes emphasized):</p>\n<blockquote>\n<p id=\"so_98650_7005988_1\">If a program attempts to access the stored value of an object through a <em>glvalue</em> of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li><em>a type similar (as defined in 4.4) to the dynamic type of the object,</em></li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its <em>elements or non-static data members</em> (including, recursively, an <em>element or non-static data member</em> of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<p>Two changes were small: <em>glvalue</em> instead of <em>lvalue</em>, and clarification of the aggregate/union case.</p>\n<p>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of <em>similar types</em> that are now safe to alias.</p>\n<hr>\n<p>Also the <strong>C</strong> wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 \u00a76.5 \u00b67):</p>\n<blockquote>\n<p id=\"so_98650_7005988_2\">An object shall have its stored value accessed only by an lvalue\n  expression that has one of the following types <sup> 73) or 88)</sup>:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a quali\ufb01ed version of a type compatible with the effective type of\n  the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the\n  effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a\n  quali\ufb01ed version of the effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned\n  types among its members (including, recursively, a member of a\n  subaggregate or contained union), or</li>\n<li>a character type.</li>\n</ul>\n<p id=\"so_98650_7005988_3\"><sup> 73) or 88)</sup> The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-10-19T22:30:34.197", "Score": "116", "CreationDate": "2011-08-10T04:43:33.067", "ParentId": "98650", "CommentCount": "33", "LastEditDate": "2017-10-19T22:30:34.197", "OwnerUserId": "103167"}, "98666": {"Body": "<p>Strict aliasing is not allowing different pointer types to the same data.</p>\n<p><a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">This article</a> should help you understand the issue in full detail.</p>\n", "CreationDate": "2008-09-19T01:33:31.770", "ParentId": "98650", "CommentCount": "2", "LastEditDate": "2013-11-04T13:38:55.477", "PostTypeId": "2", "LastEditorDisplayName": "Jason Dagit", "LastActivityDate": "2013-11-04T13:38:55.477", "LastEditorUserId": "2905299", "Id": "98666", "OwnerDisplayName": "Jason Dagit", "Score": "6", "OwnerUserId": "5113"}, "99010": {"Body": "<p>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to <code>uint32_t</code>s or <code>uint16_t</code>s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</p>\n<p>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:</p>\n<pre><code>struct Msg\n{\n    unsigned int a;\n    unsigned int b;\n};\n\nvoid SendWord(uint32_t);\n\nint main()\n{\n    // Get a 32-bit buffer from the system\n    uint32_t* buff = malloc(sizeof(Msg));\n\n    // Alias that buffer through message\n    Msg* msg = (Msg*)(buff);\n\n    // Send a bunch of messages    \n    for (int i =0; i &lt; 10; ++i)\n    {\n        msg-&gt;a = i;\n        msg-&gt;b = i+1;\n        SendWord(buff[0]);\n        SendWord(buff[1]);   \n    }\n}\n</code></pre>\n<p>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases another of an <a href=\"http://en.cppreference.com/w/c/language/type\" rel=\"noreferrer\">incompatible type</a> is undefined behavior. Unfortunately, you can still code this way, <em>maybe</em> get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code. </p>\n<p>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</p>\n<p>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of <code>buff</code> every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load <code>buff[0]</code> and <code>buff[1</code>] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of <code>buff</code> could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</p>\n<p>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</p>\n<pre><code>void SendMessage(uint32_t* buff, size_t size32)\n{\n    for (int i = 0; i &lt; size32; ++i) \n    {\n        SendWord(buff[i]);\n    }\n}\n</code></pre>\n<p>And rewrote our earlier loop to take advantage of this convenient function</p>\n<pre><code>for (int i =0; i &lt; 10; ++i)\n{\n    msg-&gt;a = i;\n    msg-&gt;b = i+1;\n    SendMessage(buff, 2);\n}\n</code></pre>\n<p>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If <code>SendMessage</code> is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</p>\n<p><strong>So how do I get around this?</strong></p>\n<ul>\n<li><p>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</p>\n<pre>\nunion {\n    Msg msg;\n    unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];\n};\n</pre></li>\n<li><p>You can disable strict aliasing in your compiler (<a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825\" rel=\"noreferrer\">f[no-]strict-aliasing</a> in gcc)) </p></li>\n<li><p>You can use <code>char*</code> for aliasing instead of your system's word. The rules allow an exception for <code>char*</code> (including <code>signed char</code> and <code>unsigned char</code>). It's always assumed that <code>char*</code> aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</p></li>\n</ul>\n<p><strong>Beginner beware</strong></p>\n<p>This is only one potential minefield when overlaying two types onto each other. You should also learn about <a href=\"http://en.wikipedia.org/wiki/Endianness\" rel=\"noreferrer\">endianness</a>, <a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/aligned.html\" rel=\"noreferrer\">word alignment</a>, and how to deal with alignment issues through <a href=\"http://grok2.tripod.com/structure_packing.html\" rel=\"noreferrer\">packing structs</a> correctly.</p>\n", "ParentId": "98650", "CreationDate": "2008-09-19T02:36:24.677", "LastActivityDate": "2017-08-31T01:50:14.630", "CommentCount": "36", "LastEditDate": "2017-08-31T01:50:14.630", "CommunityOwnedDate": "2011-09-22T15:32:28.883", "PostTypeId": "2", "LastEditorDisplayName": "Gaius", "OwnerDisplayName": "Doug T.", "LastEditorUserId": "3598119", "Id": "99010", "Score": "435", "OwnerUserId": "8123"}, "98650": {"ViewCount": "145286", "Body": "<p>When asking about <a href=\"https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into\">common undefined behavior in C</a>, souls more enlightened than I referred to the strict aliasing rule.<br>\nWhat are they talking about?</br></p>\n", "AcceptedAnswerId": "99010", "Title": "What is the strict aliasing rule?", "CreationDate": "2008-09-19T01:30:27.830", "LastActivityDate": "2017-10-19T22:30:34.197", "CommentCount": "5", "FavoriteCount": "304", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:47:29.467", "OwnerDisplayName": "Benoit Lavigne", "LastEditorUserId": "-1", "Id": "98650", "Score": "611", "OwnerUserId": "10703", "Tags": "<c><undefined-behavior><c++-faq><strict-aliasing><type-punning>", "AnswerCount": "8"}, "43645721": {"Id": "43645721", "PostTypeId": "2", "Body": "<p>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</p>\n<pre><code>int x;\nint test(double *p)\n{\n  x=5;\n  *p = 1.0;\n  return x;\n}\n</code></pre>\n<p>should be required to reload the value of <code>x</code> between the assignment and return statement so as to allow for the possibility that <code>p</code> might point to <code>x</code>, and the assignment to <code>*p</code> might consequently alter the value of <code>x</code>.  The notion that a compiler should be entitled to presume that there won't be aliasing <em>in situations like the above</em> was non-controversial.</p>\n<p>The authors of the Standard identified a few cases where aliasing might be used <em>in code that should be nearly 100% portable</em>, and mandated that compilers allow for aliasing in at least those cases.  They made no attempt to pass judgment upon what constructs should be usable within code that is only intended to be usable on specific platforms, nor what constructs should be supported by quality implementations that claim to be suitable for systems programming on those platforms.</p>\n<p>If a compiler for a particular platform indicates that it is intended for high-end number crunching applications, and a piece of operating system code for that platform malfunctions when fed to that compiler, that does not mean that the compiler is defective, nor does it mean that the code is defective.  It merely means that the compiler and operating system code are not suitable for use with each other.</p>\n<p>Unfortunately, some compiler writers point to the fact that the Standard doesn't require that all compilers recognize certain aliasing constructs as implying a judgment that all code using such constructs should be considered defective, even if the code does things which could not be done as efficiently any other way.  If such compiler writers would recognize that the authors of the Standard have never tried to enumerate all the features and guarantees needed to make a compiler suitable for any particular purpose, they could shift their efforts toward figuring out how to make their compiler as useful as possible for a wide range of purposes, rather than trying to argue that the Standard doesn't require them to do so.</p>\n", "LastActivityDate": "2017-04-26T22:42:55.587", "Score": "6", "CreationDate": "2017-04-26T22:42:55.587", "ParentId": "98650", "CommentCount": "0", "OwnerUserId": "363751"}, "6405776": {"Id": "6405776", "PostTypeId": "2", "Body": "<p>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. <a href=\"http://dbp-consulting.com/tutorials/StrictAliasing.html\">Strict Aliasing White Paper</a>.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</p>\n", "LastActivityDate": "2011-06-19T23:46:55.567", "Score": "36", "CreationDate": "2011-06-19T23:46:55.567", "ParentId": "98650", "CommentCount": "14", "OwnerUserId": "805830"}});