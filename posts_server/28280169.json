post_cb({"28280299": {"ParentId": "28280169", "CommentCount": "0", "Body": "<p>The code is bad, the problem being not on the calling site, but rather on the <code>print</code> function. You are taking an <em>rvalue</em> (only thing that will bind to an <em>rvalue-reference</em>) and returning a pointer to its internals which is a recipe for Undefined Behavior (if the user dereferences the <code>const char*</code> returned).</p>\n<p>In the particular example that you have, the <code>Foo()</code> temporary will live long enough, but this code is prone to clients storing the <code>const char*</code> beyond the full expression and causing undefined behavior.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "28280299", "Score": "5", "CreationDate": "2015-02-02T14:47:36.427", "LastActivityDate": "2015-02-02T14:47:36.427"}, "28280284": {"ParentId": "28280169", "CommentCount": "6", "Body": "<p>Yes, your code is well-defined.</p>\n<blockquote>\n<h3>[class.temporary]</h3>\n<p id=\"so_28280169_28280284_0\">3 - [...] Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. [...]</p>\n<h3>[intro.execution]</h3>\n<p id=\"so_28280169_28280284_1\">11 - <em>[ Note:</em> The evaluation of a full-expression can include the evaluation of subexpressions that are not lexically\n  part of the full-expression. For example, subexpressions involved in evaluating default arguments (8.3.6) are\n  considered to be created in the expression that calls the function, not the expression that de\ufb01nes the default\n  argument. <em>\u2014 end note ]</em></p>\n</blockquote>\n<p>That doesn't mean it's particularly <em>good</em>, though - it would be far too easy to bind the result of <code>Foo().print()</code> to a <code>char const*</code> variable, which would on the next full-expression become a dangling pointer.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "28280284", "Score": "6", "CreationDate": "2015-02-02T14:47:02.637", "LastActivityDate": "2015-02-02T14:47:02.637"}, "bq_ids": {"n4140": {"so_28280169_28280284_1": {"section_id": 5807, "quality": 0.7586206896551724, "length": 22}, "so_28280169_28280284_0": {"section_id": 380, "quality": 1.0, "length": 14}}, "n3337": {"so_28280169_28280284_1": {"section_id": 5580, "quality": 0.7586206896551724, "length": 22}, "so_28280169_28280284_0": {"section_id": 371, "quality": 1.0, "length": 14}}, "n4659": {"so_28280169_28280284_1": {"section_id": 7268, "quality": 0.7586206896551724, "length": 22}, "so_28280169_28280284_0": {"section_id": 395, "quality": 1.0, "length": 14}}}, "28280169": {"CommentCount": "4", "AcceptedAnswerId": "28280284", "CreationDate": "2015-02-02T14:40:06.207", "LastActivityDate": "2015-02-02T14:55:53.227", "PostTypeId": "1", "ViewCount": "508", "FavoriteCount": "2", "Title": "Is it safe to return a passed-in temporary value and read from it in the same statement?", "Id": "28280169", "Score": "9", "Body": "<p>I just wrote this without thinking too hard about it. It seems to work fine, but I'm not sure if it's strictly safe.</p>\n<pre><code>class Foo\n{\n    struct Buffer\n    {\n        char data [sizeof (\"output will look like this XXXX YYYY ZZZZ\")];\n    };\n\n    const char * print (const char * format = DEFUALT_FORMAT, Buffer &amp;&amp; buf = Buffer ())\n    {\n        sort_of_sprintf_thing (format, buf .data, sizeof (buf.data), ...);\n        return buf .data;\n    }\n};\n\nstd :: cout &lt;&lt; Foo () .print ();\n</code></pre>\n<p>So I <em>think</em> the semantics are that the temporary Buffer will remain in existence until the whole <code>cout</code> statement completes. Is that right, or will it go out of scope before then, in which case this is UB?</p>\n", "Tags": "<c++><scope><undefined-behavior>", "OwnerUserId": "458742", "AnswerCount": "2"}});