post_cb({"bq_ids": {"n4140": {"so_39745566_39750232_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 5914}, "so_39745566_39750232_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 369}}, "n3337": {"so_39745566_39750232_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 5686}, "so_39745566_39750232_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 359}}, "n4659": {"so_39745566_39750232_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 7406}, "so_39745566_39750232_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 382}}}, "39746479": {"Id": "39746479", "PostTypeId": "2", "Body": "<p>Actually you can use <code>std::make_pair</code>. But you need to implement <code>reference_wrapper</code> class to imitate reference. Examplary (not very polished, but working as expected) c++03 approach:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt;\nstruct reference_wrapper {\n   bool is_const;\n   T* v;\n   T const* cv;\n   reference_wrapper(T&amp; t): v(&amp;t), is_const(false) { }\n   reference_wrapper(T const&amp; t): cv(&amp;t), is_const(true) { }\n\n   reference_wrapper &amp;operator=(reference_wrapper const &amp;rw) {\n      if (rw.is_const) {\n         *v = *rw.cv;\n      } else {\n         *v = *rw.v;\n      }\n   }\n};\n\ntemplate &lt;class T&gt;\nreference_wrapper&lt;T&gt; ref(T &amp;t) {\n   return reference_wrapper&lt;T&gt;(t);\n}\n\npair&lt;int, int&gt; test() {\n    return make_pair(13, 42);\n}\n\nint main() {\n    int a = 1, b = 2;\n\n    //pair&lt;int&amp;, int&amp;&gt;(a, b) = test();  // works\n    make_pair(ref(a), ref(b)) = test(); // now it does work\n\n    std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastEditorUserId": "4324224", "LastActivityDate": "2016-09-28T13:09:29.390", "Score": "3", "CreationDate": "2016-09-28T11:42:57.857", "ParentId": "39745566", "CommentCount": "5", "OwnerUserId": "4324224", "LastEditDate": "2016-09-28T13:09:29.390"}, "39745604": {"Id": "39745604", "PostTypeId": "2", "Body": "<p><code>make_pair</code> produces a pair of values, not references. That means it would produce <code>pair&lt;int, int&gt;</code> in your example and you'd be assigning results of <code>test()</code> to a temporary variable\u00b9.</p>\n<p>You can mimic <code>tie</code> with the following:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nstd::pair&lt;T&amp;, U&amp;&gt; tie_pair(T&amp; l, U&amp; r)\n{\n    return std::pair&lt;T&amp;, U&amp;&gt;(l, r);\n}\n</code></pre>\n<p><a href=\"http://ideone.com/muAcaG\" rel=\"nofollow\">http://ideone.com/muAcaG</a></p>\n<p>\u00b9\u200b this is an unfortunate side-effect of C++03 not having ref-qualifiers. In C++\u226511 you can delete <code>operator=</code> for rvalue <code>this</code> (in non-std classes) and make such cases a compiler error rather than silent surprising behaviour.</p>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-09-28T11:36:50.227", "Score": "2", "CreationDate": "2016-09-28T11:01:44.933", "ParentId": "39745566", "CommentCount": "2", "OwnerUserId": "2456565", "LastEditDate": "2016-09-28T11:36:50.227"}, "39750232": {"Id": "39750232", "PostTypeId": "2", "Body": "<p>In 20.2.2[lib.pairs]8 the standard states that <code>pair</code> uses \"explicit types\" while <code>make_pair</code>'s \"types are deduced\".</p>\n<p>This is why the standard defines a constructor for <code>pair</code>:</p>\n<pre><code>template &lt;class T1, class T2&gt;\npair(const T1&amp; x, const T2&amp; y)\n</code></pre>\n<p>If you run your code on a <a href=\"http://ideone.com/T3OuMS\" rel=\"nofollow\">C++03 compiler</a> you will get this error:</p>\n<blockquote>\n<p id=\"so_39745566_39750232_0\">non-static reference member <code>int&amp; std::pair&lt;int&amp;, int&amp;&gt;::first</code>, can't use default assignment operator</p>\n</blockquote>\n<p>The problem is that <code>pair</code> uses an <a href=\"http://en.cppreference.com/w/cpp/language/copy_assignment#Deleted_implicitly-declared_copy_assignment_operator\" rel=\"nofollow\">implicitly-declared copy assignment operator</a> which is not defined if the <code>pair</code>:</p>\n<blockquote>\n<p id=\"so_39745566_39750232_1\">Has a non-static data member of a reference type</p>\n</blockquote>\n<p>Whether defined by <code>make_pair</code> or the <code>pair</code> constructor, the template arguments will define both of the <code>pair</code>'s members as <code>int&amp;</code> so the implicitly-declared copy assignment operator will not be defined. <strong>So this cannot be accomplished with a <code>pair</code> in C++03.</strong></p>\n<p>If using return parameter is undesirable, you can write your own implementation of <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/tie\" rel=\"nofollow\"><code>tie</code></a>:</p>\n<pre><code>template &lt;class T1, class T2&gt;\nstruct tie{\n    T1&amp; first;\n    T2&amp; second;\n\n    tie(T1&amp; x, T2&amp; y) : first(x), second(y) {}\n\n    tie&lt;T1, T2&gt;&amp; operator=(const pair&lt;T1, T2&gt;&amp; rhs){\n        first = rhs.first;\n        second = rhs.second;\n\n        return *this;\n    }\n};\n</code></pre>\n<p>This will allow assignment of a <code>pair</code>:</p>\n<pre><code>tie&lt;int, int&gt;(a, b) = test();\n</code></pre>\n<p>To get the exact C++11 behavior which doesn't require template arguments you'll need to define a function. If <code>tie</code> is nested in <code>namespace details</code> the function can be defined as:</p>\n<pre><code>template &lt;class T1, class T2&gt;\ndetails::tie&lt;T1, T2&gt; tie(T1&amp; x, T2&amp; y) { \n    return details::tie&lt;T1, T2&gt;(x, y);\n}\n</code></pre>\n<p>This will allow assignment of a <code>pair</code> just as in C++11:</p>\n<pre><code>tie(a, b) = test();\n</code></pre>\n<p><a href=\"http://ideone.com/6TbUxM\" rel=\"nofollow\"><kbd>Live Example</kbd></a></p>\n<p><sub>Note that this is still intolerant of using <code>int&amp;</code> template arguments, so <code>details::tie&lt;int&amp;, int&amp;&gt;</code> and <code>tie&lt;int&amp;, int&amp;&gt;</code> will fail just as before.</sub></p>\n", "LastActivityDate": "2016-09-28T14:20:05.757", "CommentCount": "0", "CreationDate": "2016-09-28T14:20:05.757", "ParentId": "39745566", "Score": "3", "OwnerUserId": "2642059"}, "39745566": {"ViewCount": "291", "Body": "<p>I'm trying to mimic the behavior of <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/tie\" rel=\"nofollow\"><code>tie</code></a> pre C++11.</p>\n<pre><code>pair&lt;int, int&gt; test() {\n    return make_pair(13, 42);\n}\n\nint main() {\n    int a = 1, b = 2;\n\n    pair&lt;int&amp;, int&amp;&gt;(a, b) = test();\n\n    cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/LPHWSS\" rel=\"nofollow\">This works</a> however if I use <code>make_pair</code> instead to the <code>pair</code> constructor <code>a</code> and <code>b</code> are not assigned.<br>\nWhy does the <code>pair</code> constructor work but not <code>make_pair</code>?</br></p>\n", "AcceptedAnswerId": "39750232", "Title": "Why can't I use make_pair to tie?", "CreationDate": "2016-09-28T10:59:44.350", "Id": "39745566", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-09-28T11:40:58.563", "LastEditorUserId": "2642059", "LastActivityDate": "2016-09-28T14:20:05.757", "Score": "3", "OwnerUserId": "2642059", "Tags": "<c++><c++11><reference><c++03><std-pair>", "AnswerCount": "3"}});