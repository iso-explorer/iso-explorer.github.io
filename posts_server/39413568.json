post_cb({"bq_ids": {"n4140": {"so_39413568_39413568_0": {"length": 115, "quality": 0.8214285714285714, "section_id": 5991}}, "n3337": {"so_39413568_39413568_0": {"length": 115, "quality": 0.8214285714285714, "section_id": 5759}}, "n4659": {"so_39413568_39413568_0": {"length": 119, "quality": 0.85, "section_id": 7491}}}, "39413568": {"ViewCount": "63", "Body": "<p><a href=\"http://eel.is/c++draft/expr.call#4\" rel=\"nofollow\">[expr.call]/4</a> in C++1z (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_39413568_39413568_0\">When a function is called, each parameter ([dcl.fct]) shall be\n  initialized ([dcl.init], [class.copy], [class.ctor]) with its\n  corresponding argument. If the function is a non-static member\n  function, the this parameter of the function ([class.this]) shall be\n  initialized with a pointer to the object of the call, converted as if\n  by an explicit type conversion ([expr.cast]). [ Note: There is no\n  access or ambiguity checking on this conversion; the access checking\n  and disambiguation are done as part of the (possibly implicit) class\n  member access operator. See [class.member.lookup],\n  [class.access.base], and [expr.ref].  \u2014 end note ] When a function is\n  called, the parameters that have object type shall have\n  completely-defined object type. [ Note: this still allows a parameter\n  to be a pointer or reference to an incomplete class type. However, it\n  prevents a passed-by-value parameter to have an incomplete class type.\n  \u2014 end note ] It is implementation-defined whether the lifetime of a\n  parameter ends when the function in which it is defined returns or at\n  the end of the enclosing full-expression. The initialization and\n  destruction of each parameter occurs within the context of the\n  <strong>calling function</strong>. [ Example: the access of the constructor, conversion functions or destructor is checked at the point of call in\n  the <strong>calling function</strong>. If a constructor or destructor for a\n  function parameter throws an exception, the search for a handler\n  starts in the scope of the <strong>calling function</strong>; in particular, if the\n  function called has a function-try-block (Clause [except]) with a\n  handler that could handle the exception, this handler is not\n  considered.  \u2014 end example ]</p>\n</blockquote>\n<p>My understanding is that the terms <strong>calling function</strong> above refer to a function that calls the function, whose parameter is being initialized. Is that correct?</p>\n", "Title": "The terms \"calling function\" below, do they refer to a function that calls the function, whose parameter is being initialized?", "CreationDate": "2016-09-09T14:10:11.467", "LastActivityDate": "2016-09-09T17:21:44.400", "CommentCount": "4", "LastEditDate": "2016-09-09T17:21:44.400", "PostTypeId": "1", "LastEditorUserId": "734069", "Id": "39413568", "Score": "3", "OwnerUserId": "2548699", "Tags": "<c++><language-lawyer>", "AnswerCount": "0"}});