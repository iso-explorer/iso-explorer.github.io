post_cb({"45294264": {"Id": "45294264", "PostTypeId": "2", "Body": "<p>To point out the difference between VC++ and g++, I think the below have some information on it \n<a href=\"https://stackoverflow.com/a/26581337/4669663\">https://stackoverflow.com/a/26581337/4669663</a></p>\n<p>Since the move constructor is added by default, this </p>\n<pre><code>Foo:Bar\n~Foo:Bar - Move constructor generated by VC\nFoo:Baz\n~Foo:Baz\n</code></pre>\n<blockquote>\n<p id=\"so_45293841_45294264_0\">\"Rvalue references v3.0\" adds new rules to automatically generate move\n  constructors and move assignment operators under certain conditions.\n  This is implemented in Visual Studio 2015.</p>\n</blockquote>\n", "LastActivityDate": "2017-07-25T04:59:44.630", "CommentCount": "1", "CreationDate": "2017-07-25T04:59:44.630", "ParentId": "45293841", "Score": "0", "OwnerUserId": "4669663"}, "bq_ids": {"n4140": {"so_45293841_45294129_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 382}, "so_45293841_45294129_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 382}}, "n3337": {"so_45293841_45294129_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 373}, "so_45293841_45294129_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 373}}, "n4659": {"so_45293841_45294129_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 397}, "so_45293841_45294129_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 397}}}, "45293841": {"ViewCount": "191", "Body": "<p>For the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct Foo {\n    string tag;\n\n    Foo(string t): tag(t){\n        cout &lt;&lt; \"Foo:\" &lt;&lt; tag &lt;&lt; endl;\n    }\n    ~Foo() {\n        cout &lt;&lt; \"~Foo:\" &lt;&lt; tag &lt;&lt; endl;\n    }\n};\n\nstruct Bar {\n    Foo&amp;&amp; foo;\n};\n\nstruct Baz{\n    Foo&amp;&amp; foo;\n    Baz(Foo&amp;&amp; f):foo(std::move(f)){\n\n    }\n};\n\nint main() {\n    Bar bar{Foo(\"Bar\")};\n    Baz baz{Foo(\"Baz\")};\n    cin.get();\n}\n</code></pre>\n<p>result(g++ 7.1.0):</p>\n<pre><code>Foo:Bar\nFoo:Baz\n~Foo:Baz\n</code></pre>\n<p>We can see that <code>bar</code> successfully extend the lifetime of a temporary Foo but <code>baz</code> failed to do so. What is the difference between the two? How can I implement the constructor of <code>Baz</code> correctly?</p>\n<p>Edit: actually VC++2017 gives:</p>\n<pre><code>Foo:Bar\n~Foo:Bar\nFoo:Baz\n~Foo:Baz\n</code></pre>\n<p>So I guess the whole thing is not reliable.</p>\n", "AcceptedAnswerId": "45294129", "Title": "rvalue data member initialization: Aggregate initialization vs constructor", "CreationDate": "2017-07-25T04:15:28.947", "Id": "45293841", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-07-25T04:28:01.327", "LastEditorUserId": "7614469", "LastActivityDate": "2017-07-25T05:08:36.450", "Score": "7", "OwnerUserId": "7614469", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "45294129": {"Id": "45294129", "PostTypeId": "2", "Body": "<p><code>Baz</code> is a class with a constructor. Therefore, when you use list initialization, the compiler will look for a constructor to call. That constructor will be passed the members of the braced-init-list, or a <code>std::initializer_list</code> if one matches the members of the list. In either case, the rules of temporary binding to function parameters are in effect ([class.temporary]/6.1): </p>\n<blockquote>\n<p id=\"so_45293841_45294129_0\">A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>However, <code>Bar</code> is not a class with a constructor; it is an aggregate. Therefore, when you use list initialization, you (in this case) invoke aggregate initialization. And therefore, the member reference will be bound to the given prvalue directly. The rule for that is ([class.temporary]/6):</p>\n<blockquote>\n<p id=\"so_45293841_45294129_1\">The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n</blockquote>\n<p>Followed by 3 exceptions which do not apply to this case (including 6.1, quoted above).</p>\n<p>The lifetime of the reference <code>Bar::foo</code> extends to the end of <code>main</code>. Which doesn't happen until <code>cin.get()</code> returns.</p>\n<hr>\n<blockquote>\n<p id=\"so_45293841_45294129_2\">How can I implement the constructor of Baz correctly?</p>\n</blockquote>\n<p>If by \"correctly\", you mean \"like <code>Bar</code>\", you <em>cannot.</em> Aggregates get to do things that non-aggregates can't; this is one of them.</p>\n<p>It's similar to this:</p>\n<pre><code>struct Types { int i; float f };\nusing Tpl = std::tuple&lt;int, float&gt;;\n\nint &amp;&amp;i1 = Types{1, 1.5}.i;\nint &amp;&amp;i2 = std::get&lt;0&gt;(Tpl{1, 1.5});\n</code></pre>\n<p><code>i2</code> is a dangling reference to a subobject of a destroyed temporary. <code>i1</code> is a reference to a subobject of a temporary whose lifetime was extended.</p>\n<p>There are some things you just can't do through functions.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2017-07-25T05:08:36.450", "Score": "5", "CreationDate": "2017-07-25T04:46:56.657", "ParentId": "45293841", "CommentCount": "0", "OwnerUserId": "734069", "LastEditDate": "2017-07-25T05:08:36.450"}});