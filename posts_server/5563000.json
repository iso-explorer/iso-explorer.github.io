post_cb({"23873536": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since the other answers don't talk about the rules in C++11 here's one. From C++11 standard (draft n3337) \u00a75/9:</p>\n<blockquote>\n<p id=\"so_5563000_23873536_0\">This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<p id=\"so_5563000_23873536_1\">\u2014 If either operand is of scoped enumeration type, no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.</p>\n<p id=\"so_5563000_23873536_2\">\u2014 If either operand is of type long double, the other shall be converted to long double.</p>\n<p id=\"so_5563000_23873536_3\">\u2014 Otherwise, if either operand is double, the other shall be converted to double.</p>\n<p id=\"so_5563000_23873536_4\">\u2014 Otherwise, if either operand is float, the other shall be converted to float.</p>\n<p id=\"so_5563000_23873536_5\">\u2014 Otherwise, the integral promotions shall be performed on both operands. Then the following rules shall be applied to the promoted operands:</p>\n<blockquote>\n<p id=\"so_5563000_23873536_11\">\u2014 If both operands have the same type, no further conversion is needed.</p>\n<p id=\"so_5563000_23873536_12\">\u2014 Otherwise, if both operands have signed integer types or both have unsigned integer types, the\n    operand with the type of lesser integer conversion rank shall be converted to the type of the\n    operand with greater rank.</p>\n<p id=\"so_5563000_23873536_13\">\u2014 Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n    rank of the type of the other operand, the operand with signed integer type shall be converted to\n    the type of the operand with unsigned integer type.</p>\n<p id=\"so_5563000_23873536_14\">\u2014 Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall\n    be converted to the type of the operand with signed integer type.</p>\n<p id=\"so_5563000_23873536_15\">\u2014 Otherwise, both operands shall be converted to the unsigned integer type corresponding to the\n    type of the operand with signed integer type.</p>\n</blockquote>\n</blockquote>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\">here</a> for a list that's frequently updated.</p>\n", "OwnerUserId": "183120", "LastEditorUserId": "183120", "LastEditDate": "2015-03-11T08:25:05.900", "Id": "23873536", "Score": "13", "CreationDate": "2014-05-26T15:36:51.553", "LastActivityDate": "2015-03-11T08:25:05.900"}, "24226189": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My <a href=\"http://codeforces.com/contest/439/submission/6892098\" rel=\"nofollow\">solution</a> to the <a href=\"http://codeforces.com/contest/439/problem/B\" rel=\"nofollow\">problem</a> got WA(wrong answer), then i changed one of <code>int</code> to <code>long long int</code> and it gave <a href=\"http://codeforces.com/contest/439/submission/6892114\" rel=\"nofollow\">AC(accept)</a>. Previously, I was trying to do <code>long long int += int * int</code>, and after I rectify it to <code>long long int += long long int * int</code>. Googling I came up with, </p>\n<h2>1. <a href=\"http://msdn.microsoft.com/en-us/library/09ka8bxx.aspx\" rel=\"nofollow\">Arithmetic Conversions</a></h2>\n<p>Conditions for Type Conversion: </p>\n<p>Conditions Met ---&gt; Conversion</p>\n<ul>\n<li><p>Either operand is of type <strong>long double</strong>. ---&gt; Other operand is converted to type <strong>long double</strong>.</p></li>\n<li><p>Preceding condition not met and either operand is of type <strong>double</strong>. ---&gt; Other operand is converted to type <strong>double</strong>.</p></li>\n<li><p>Preceding conditions not met and either operand is of type <strong>float</strong>. ---&gt; Other operand is converted to type <strong>float</strong>.</p></li>\n<li><p>Preceding conditions not met (none of the operands are of floating types). ---&gt; Integral promotions are performed on the operands as follows:</p>\n<ul>\n<li>If either operand is of type <strong>unsigned long</strong>, the other operand is converted to type <strong>unsigned long</strong>.</li>\n<li>If preceding condition not met, and if either operand is of type <strong>long</strong> and the other of type <strong>unsigned int</strong>, both operands are converted to type <strong>unsigned long</strong>.</li>\n<li>If the preceding two conditions are not met, and if either operand is of type <strong>long</strong>, t he other operand is converted to type <strong>long</strong>.</li>\n<li>If the preceding three conditions are not met, and if either operand is of type <strong>unsigned int</strong>, the other operand is converted to type <strong>unsigned int</strong>.</li>\n<li>If none of the preceding conditions are met, both operands are converted to type <strong>int</strong>.</li>\n</ul></li>\n</ul>\n<h2>2 . <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules\" rel=\"nofollow\">Integer conversion rules</a></h2>\n<ul>\n<li>Integer Promotions: </li>\n</ul>\n<p>Integer types smaller than int are promoted when an operation is performed on them. If all values of the original type can be represented as an int, the value of the smaller type is converted to an int; otherwise, it is converted to an unsigned int. Integer promotions are applied as part of the usual arithmetic conversions to certain argument expressions; operands of the unary +, -, and ~ operators; and operands of the shift operators.</p>\n<ul>\n<li><p>Integer Conversion Rank:</p>\n<ul>\n<li>No two signed integer types shall have the same rank, even if they have the same representation.</li>\n<li>The rank of a signed integer type shall be greater than the rank of any signed integer type with less precision.</li>\n<li>The rank of <code>long long int</code> shall be greater than the rank of <code>long int</code>, which shall be greater than the rank of <code>int</code>, which shall be greater than the rank of <code>short int</code>, which shall be greater than the rank of <code>signed char</code>.</li>\n<li>The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type, if any.</li>\n<li>The rank of any standard integer type shall be greater than the rank of any extended integer type with the same width.</li>\n<li>The rank of <code>char</code> shall equal the rank of <code>signed char</code> and <code>unsigned char</code>.</li>\n<li>The rank of any extended signed integer type relative to another extended signed integer type with the same precision is implementation-defined but still subject to the other rules for determining the integer conversion rank.</li>\n<li>For all integer types T1, T2, and T3, if T1 has greater rank than T2 and T2 has greater rank than T3, then T1 has greater rank than T3.</li>\n</ul></li>\n<li><p>Usual Arithmetic Conversions:</p>\n<ul>\n<li>If both operands have the same type, no further conversion is needed.</li>\n<li>If both operands are of the same integer type (signed or unsigned), the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.</li>\n<li>If the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type is converted to the type of the operand with unsigned integer type.</li>\n<li>If the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type is converted to the type of the operand with signed integer type.</li>\n<li>Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. Specific operations can add to or modify the semantics of the usual arithmetic operations.</li>\n</ul></li>\n</ul>\n", "OwnerUserId": "2948746", "LastEditorUserId": "2948746", "LastEditDate": "2014-06-15T03:21:09.477", "Id": "24226189", "Score": "2", "CreationDate": "2014-06-15T03:01:47.217", "LastActivityDate": "2014-06-15T03:21:09.477"}, "5563000": {"CommentCount": "2", "AcceptedAnswerId": "5563131", "CreationDate": "2011-04-06T07:44:19.847", "LastActivityDate": "2016-03-27T23:13:45.873", "PostTypeId": "1", "ViewCount": "65506", "FavoriteCount": "66", "Title": "Implicit type conversion rules in C++ operators", "Id": "5563000", "Score": "116", "Body": "<p>I want to be better about knowing when I should cast. What are the implicit type conversion rules in C++ when adding, multiplying, etc. For example,</p>\n<pre><code>int + float = ?\nint * float = ?\nfloat * int = ?\nint / float = ?\nfloat / int = ?\nint / int = ?\nint ^ float = ?\n</code></pre>\n<p>et cetera...</p>\n<p>Will the expression always be evaluated as the more precise type? Do the rules differ for Java? \nPlease correct me if I have worded this question inaccurately.</p>\n", "Tags": "<c++><casting><implicit>", "OwnerUserId": "264970", "AnswerCount": "9"}, "8935697": {"ParentId": "5563000", "CommentCount": "0", "Body": "<p>This answer is directed in large part at a comment made by @Rafa\u0142Dowgird:</p>\n<blockquote>\n<p id=\"so_5563000_8935697_0\">\"The minimum size of operations is int.\" - This would be very strange\n  (what about architectures that efficiently support char/short\n  operations?) Is this really in the C++ spec?</p>\n</blockquote>\n<p>Keep in mind that the C++ standard has the all-important \"as-if\" rule. See section 1.8: Program Execution:</p>\n<blockquote>\n<p id=\"so_5563000_8935697_1\">3) This provision is sometimes called the \"as-if\" rule, because an\n  implementation  is free to disregard any requirement of the Standard\n  as long as the result is as if the requirement had been obeyed, as far\n  as can be determined from the observable behavior of the program.</p>\n</blockquote>\n<p>The compiler cannot set an <code>int</code> to be 8 bits in size, even if it were the fastest, since the standard mandates a 16-bit minimum <code>int</code>.</p>\n<p>Therefore, in the case of a theoretical computer with super-fast 8-bit operations, the implicit promotion to <code>int</code> for arithmetic could matter. However, for many operations, you cannot tell if the compiler actually did the operations in the precision of an <code>int</code> and then converted to a <code>char</code> to store in your variable, or if the operations were done in char all along.</p>\n<p>For example, consider <code>unsigned char = unsigned char + unsigned char + unsigned char</code>, where addition would overflow (let's assume a value of 200 for each). If you promoted to <code>int</code>, you would get 600, which would then be implicitly down cast into an <code>unsigned char</code>, which would wrap modulo 256, thus giving a final result of 88. If you did no such promotions,you'd have to wrap between the first two additions, which would reduce the problem from <code>200 + 200 + 200</code> to <code>144 + 200</code>, which is 344, which reduces to 88. In other words, the program does not know the difference, so the compiler is free to ignore the mandate to perform intermediate operations in <code>int</code> if the operands have a lower ranking than <code>int</code>.</p>\n<p>This is true in general of addition, subtraction, and multiplication. It is not true in general for division or modulus.</p>\n", "OwnerUserId": "852254", "PostTypeId": "2", "Id": "8935697", "Score": "5", "CreationDate": "2012-01-20T01:24:30.680", "LastActivityDate": "2012-01-20T01:24:30.680"}, "5563095": {"ParentId": "5563000", "CommentCount": "0", "Body": "<p>Whole chapter 4 talks about conversions, but I think you should be mostly interested in these :</p>\n<p><strong>4.5 Integral promotions</strong>\n[conv.prom]<br>\nAn rvalue of type char, signed char, unsigned char, short int, or unsigned short\nint can be converted to an rvalue of type int if int can represent all the values of the source type; other-<br>\nwise, the source rvalue can be converted to an rvalue of type unsigned int.<br>\nAn rvalue of type wchar_t (3.9.1) or an enumeration type (7.2) can be converted to an rvalue of the first<br>\nof the following types that can represent all the values of its underlying type: int, unsigned int,<br>\nlong, or unsigned long.<br>\nAn rvalue for an integral bit-field (9.6) can be converted to an rvalue of type int if int can represent all<br>\nthe values of the bit-field; otherwise, it can be converted to unsigned int if unsigned int can rep-<br>\nresent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the<br>\nbit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.<br>\nAn rvalue of type bool can be converted to an rvalue of type int, with false becoming zero and true<br>\nbecoming one.<br>\nThese conversions are called integral promotions.  </br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p><strong>4.6 Floating point promotion</strong>\n[conv.fpprom]<br>\nAn rvalue of type float can be converted to an rvalue of type double. The value is unchanged.<br>\nThis conversion is called floating point promotion.  </br></br></p>\n<p>Therefore, all conversions involving float - the result is float.</p>\n<p>Only the one involving both int - the result is int :\nint / int = int</p>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "5563095", "Score": "1", "CreationDate": "2011-04-06T07:53:11.660", "LastActivityDate": "2011-04-06T07:53:11.660"}, "25113031": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-08-04T06:44:16.760", "Id": "25113031", "LastEditDate": "2015-05-14T18:24:17.733", "OwnerDisplayName": "user3905560", "Score": "1", "Body": "<p>Caveat!</p>\n<p>The conversions occur from left to right.</p>\n<p>Try this:</p>\n<pre><code>int i = 3, j = 2;\ndouble k = 33;\ncout &lt;&lt; k * j / i &lt;&lt; endl; // prints 22\ncout &lt;&lt; j / i * k &lt;&lt; endl; // prints 0\n</code></pre>\n", "LastActivityDate": "2015-05-14T18:24:17.733", "LastEditorUserId": "1080165"}, "5563131": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>In C++ operators (for POD types) always act on objects of the same type.<br>\nThus if they are not the same one will be promoted to match the other.<br>\nThe type of the result of the operation is the same as operands (after conversion). </br></br></p>\n<pre><code>If either is      long          double the other is promoted to      long          double\nIf either is                    double the other is promoted to                    double\nIf either is                    float  the other is promoted to                    float\nIf either is long long unsigned int    the other is promoted to long long unsigned int\nIf either is long long          int    the other is promoted to long long          int\nIf either is long      unsigned int    the other is promoted to long      unsigned int\nIf either is long               int    the other is promoted to long               int\nIf either is           unsigned int    the other is promoted to           unsigned int\nIf either is                    int    the other is promoted to                    int\nBoth operands are promoted to int\n</code></pre>\n<p>Note. The minimum size of operations is <code>int</code>. So <code>short</code>/<code>char</code> are promoted to <code>int</code> before the operation is done.</p>\n<p>In all your expressions the <code>int</code> is promoted to a <code>float</code> before the operation is performed. The result of the operation is a <code>float</code>.</p>\n<pre><code>int + float =&gt;  float + float = float\nint * float =&gt;  float * float = float\nfloat * int =&gt;  float * float = float\nint / float =&gt;  float / float = float\nfloat / int =&gt;  float / float = float\nint / int                     = int\nint ^ float =&gt;  &lt;compiler error&gt;\n</code></pre>\n", "OwnerUserId": "14065", "LastEditorUserId": "385513", "LastEditDate": "2016-03-27T23:13:45.873", "Id": "5563131", "Score": "157", "CreationDate": "2011-04-06T07:56:01.553", "LastActivityDate": "2016-03-27T23:13:45.873"}, "5563074": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The type of the expression, when not both parts are of the same type, will be converted to the <em>biggest</em> of both. The problem here is to understand which one is bigger than the other (it does not have anything to do with size in bytes).</p>\n<p>In expressions in which a real number and an integer number are involved, the integer will be promoted to real number. For example, in int + float, the type of the expression is float.</p>\n<p>The other difference are related to the capability of the type. For example, an expression involving an int and a long int will result of type long int.</p>\n", "OwnerUserId": "266978", "LastEditorUserId": "266978", "LastEditDate": "2011-04-06T11:29:07.407", "Id": "5563074", "Score": "1", "CreationDate": "2011-04-06T07:50:54.967", "LastActivityDate": "2011-04-06T11:29:07.407"}, "5563255": {"ParentId": "5563000", "CommentCount": "1", "Body": "<p>If you exclude the unsigned types, there is an ordered\nhierarchy: signed char, short, int, long, long long, float,\ndouble, long double.  First, anything coming before int in the\nabove will be converted to int.  Then, in a binary operation,\nthe lower ranked type will be converted to the higher, and the\nresults will be the type of the higher.  (You'll note that, from\nthe hierarchy, anytime a floating point and an integral type are\ninvolved, the integral type will be converted to the floating\npoint type.)</p>\n<p>Unsigned complicates things a bit: it perturbs the ranking, and\nparts of the ranking become implementation defined.  Because of\nthis, it's best to not mix signed and unsigned in the same\nexpression.  (Most C++ experts seem to avoid unsigned unless\nbitwise operations are involved.  That is, at least, what\nStroustrup recommends.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "5563255", "Score": "3", "CreationDate": "2011-04-06T08:08:58.183", "LastActivityDate": "2011-04-06T08:08:58.183"}, "bq_ids": {"n4140": {"so_5563000_5563063_9": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_5563000_23873536_4": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_5563000_5563063_7": {"section_id": 5341, "quality": 0.5172413793103449, "length": 15}, "so_5563000_5563063_6": {"section_id": 5943, "quality": 0.6666666666666666, "length": 6}, "so_5563000_5563063_1": {"section_id": 5943, "quality": 0.75, "length": 6}, "so_5563000_23873536_3": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_5563000_23873536_8": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_5563000_23873536_1": {"section_id": 5943, "quality": 1.0, "length": 15}, "so_5563000_23873536_0": {"section_id": 5943, "quality": 0.75, "length": 6}, "so_5563000_5563063_2": {"section_id": 5943, "quality": 1.0, "length": 9}, "so_5563000_5563063_0": {"section_id": 5943, "quality": 0.9565217391304348, "length": 22}, "so_5563000_23873536_15": {"section_id": 5943, "quality": 1.0, "length": 13}, "so_5563000_23873536_6": {"section_id": 5943, "quality": 1.0, "length": 8}, "so_5563000_23873536_2": {"section_id": 5943, "quality": 1.0, "length": 9}, "so_5563000_5563063_4": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_5563000_23873536_5": {"section_id": 5943, "quality": 1.0, "length": 12}, "so_5563000_23873536_7": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_5563000_23873536_9": {"section_id": 5943, "quality": 1.0, "length": 25}, "so_5563000_23873536_12": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_5563000_5563063_8": {"section_id": 5943, "quality": 0.8571428571428571, "length": 6}, "so_5563000_5563063_3": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_5563000_23873536_13": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_5563000_8935697_1": {"section_id": 5797, "quality": 0.9130434782608695, "length": 21}, "so_5563000_23873536_11": {"section_id": 5943, "quality": 1.0, "length": 8}, "so_5563000_5563063_5": {"section_id": 5943, "quality": 0.8333333333333334, "length": 5}, "so_5563000_23873536_10": {"section_id": 5943, "quality": 1.0, "length": 13}, "so_5563000_23873536_14": {"section_id": 5943, "quality": 1.0, "length": 25}}, "n3337": {"so_5563000_5563063_9": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_5563000_23873536_4": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_5563000_5563063_7": {"section_id": 5138, "quality": 0.5172413793103449, "length": 15}, "so_5563000_5563063_6": {"section_id": 5714, "quality": 0.6666666666666666, "length": 6}, "so_5563000_5563063_1": {"section_id": 5714, "quality": 0.75, "length": 6}, "so_5563000_23873536_3": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_5563000_23873536_8": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_5563000_23873536_1": {"section_id": 5714, "quality": 1.0, "length": 15}, "so_5563000_23873536_0": {"section_id": 5714, "quality": 0.75, "length": 6}, "so_5563000_5563063_2": {"section_id": 5714, "quality": 1.0, "length": 9}, "so_5563000_5563063_0": {"section_id": 5714, "quality": 0.9565217391304348, "length": 22}, "so_5563000_23873536_15": {"section_id": 5714, "quality": 1.0, "length": 13}, "so_5563000_8935697_1": {"section_id": 5570, "quality": 0.9130434782608695, "length": 21}, "so_5563000_23873536_2": {"section_id": 5714, "quality": 1.0, "length": 9}, "so_5563000_5563063_4": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_5563000_23873536_5": {"section_id": 5714, "quality": 1.0, "length": 12}, "so_5563000_23873536_6": {"section_id": 5714, "quality": 1.0, "length": 8}, "so_5563000_23873536_7": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_5563000_23873536_9": {"section_id": 5714, "quality": 1.0, "length": 25}, "so_5563000_23873536_12": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_5563000_5563063_8": {"section_id": 5714, "quality": 0.8571428571428571, "length": 6}, "so_5563000_5563063_3": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_5563000_23873536_13": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_5563000_23873536_11": {"section_id": 5714, "quality": 1.0, "length": 8}, "so_5563000_5563063_5": {"section_id": 5714, "quality": 0.8333333333333334, "length": 5}, "so_5563000_23873536_10": {"section_id": 5714, "quality": 1.0, "length": 13}, "so_5563000_23873536_14": {"section_id": 5714, "quality": 1.0, "length": 25}}, "n4659": {"so_5563000_5563063_9": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_5563000_23873536_4": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_5563000_5563063_7": {"section_id": 6762, "quality": 0.5172413793103449, "length": 15}, "so_5563000_23873536_2": {"section_id": 7428, "quality": 1.0, "length": 9}, "so_5563000_5563063_1": {"section_id": 7428, "quality": 0.75, "length": 6}, "so_5563000_23873536_3": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_5563000_23873536_8": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_5563000_23873536_1": {"section_id": 7428, "quality": 1.0, "length": 15}, "so_5563000_23873536_0": {"section_id": 7428, "quality": 0.75, "length": 6}, "so_5563000_5563063_2": {"section_id": 7428, "quality": 1.0, "length": 9}, "so_5563000_5563063_0": {"section_id": 7428, "quality": 0.9565217391304348, "length": 22}, "so_5563000_23873536_15": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_5563000_8935697_1": {"section_id": 7256, "quality": 0.9130434782608695, "length": 21}, "so_5563000_23873536_6": {"section_id": 7428, "quality": 1.0, "length": 8}, "so_5563000_5563063_4": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_5563000_23873536_5": {"section_id": 7428, "quality": 1.0, "length": 12}, "so_5563000_23873536_7": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_5563000_23873536_9": {"section_id": 7428, "quality": 1.0, "length": 25}, "so_5563000_23873536_12": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_5563000_5563063_8": {"section_id": 7428, "quality": 0.8571428571428571, "length": 6}, "so_5563000_5563063_3": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_5563000_23873536_13": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_5563000_5563063_6": {"section_id": 7428, "quality": 0.6666666666666666, "length": 6}, "so_5563000_23873536_11": {"section_id": 7428, "quality": 1.0, "length": 8}, "so_5563000_5563063_5": {"section_id": 7428, "quality": 0.8333333333333334, "length": 5}, "so_5563000_23873536_10": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_5563000_23873536_14": {"section_id": 7428, "quality": 1.0, "length": 25}}}, "5563063": {"ParentId": "5563000", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Arithmetic operations involving <code>float</code> results in <code>float</code>.</p>\n<pre><code>int + float = float\nint * float = float\nfloat * int = float\nint / float = float\nfloat / int = float\nint / int = int\n</code></pre>\n<p>For more detail answer. Look at what the section \u00a75/9 from the C++ Standard says</p>\n<blockquote>\n<p id=\"so_5563000_5563063_0\">Many binary operators that expect\n  operands of arithmetic or enumeration\n  type cause conversions and yield\n  result types in a similar way. The\n  purpose is to yield a common type,\n  <strong>which is also the type of the result</strong>.</p>\n<p id=\"so_5563000_5563063_1\">This pattern is called the usual\n  arithmetic conversions, which are\n  defined as follows:</p>\n<p id=\"so_5563000_5563063_2\">\u2014 If either operand is of type long\n  double, the other shall be converted\n  to long double.   </p>\n<p id=\"so_5563000_5563063_3\">\u2014 Otherwise, if either\n  operand is double, the other shall be\n  converted to double.</p>\n<p id=\"so_5563000_5563063_4\">\u2014 Otherwise, if\n  either operand is float, the other\n  shall be converted to float.</p>\n<p id=\"so_5563000_5563063_5\">\u2014 Otherwise, the integral promotions\n  (4.5) shall be performed on both\n  operands.54) </p>\n<p id=\"so_5563000_5563063_6\">\u2014 Then, if either operand\n  is unsigned long the other shall be\n  converted to unsigned long. </p>\n<p id=\"so_5563000_5563063_7\">\u2014 Otherwise, if one operand is a long\n  int and the other unsigned int, then\n  if a long int can represent all the\n  values of an unsigned int, the\n  unsigned int shall be converted to a\n  long int; otherwise both operands\n  shall be converted to unsigned long\n  int. </p>\n<p id=\"so_5563000_5563063_8\">\u2014 Otherwise, if either operand is\n  long, the other shall be converted to\n  long.</p>\n<p id=\"so_5563000_5563063_9\">\u2014 Otherwise, if either operand\n  is unsigned, the other shall be\n  converted to unsigned. </p>\n<p id=\"so_5563000_5563063_10\">[Note: otherwise, the only remaining case is\n  that both operands are int ]</p>\n</blockquote>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-06T07:56:13.703", "Id": "5563063", "Score": "27", "CreationDate": "2011-04-06T07:49:32.283", "LastActivityDate": "2011-04-06T07:56:13.703"}});