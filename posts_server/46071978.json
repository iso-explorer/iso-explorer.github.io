post_cb({"bq_ids": {"n4140": {"so_46071978_46072243_0": {"length": 14, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_46071978_46072243_0": {"length": 14, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_46071978_46072243_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7272}}}, "46071978": {"ViewCount": "139", "Body": "<p>In the legacy code base I'm working on, I discovered the line</p>\n<pre><code>n = ++n % size;\n</code></pre>\n<p>that is just a bad phrasing of the intended</p>\n<pre><code>n = (n+1) % size;\n</code></pre>\n<p>as deduced from the surrounding code and runtime-proved. (The latter now replaces the former.)</p>\n<p>But since this code was marked as an error by Cppckeck, and caused a warning in GCC, without ever having caused any malfunction, I didn't stop thinking here. I reduced the line to</p>\n<pre><code>n = ++n;\n</code></pre>\n<p>still getting the original error/warning messages:</p>\n<p>Cppcheck 1.80:</p>\n<blockquote>\n<p id=\"so_46071978_46071978_0\">Id: unknownEvaluationOrder<br/>\n  Summary: Expression 'n=++n' depends on order of evaluation of side effects<br/>\n  Message: Expression 'n=++n' depends on order of evaluation of side effects</p>\n</blockquote>\n<p>GCC (mingw32-g++.exe, version 4.9.2, C++98):</p>\n<blockquote>\n<p id=\"so_46071978_46071978_1\">warning: operation on 'n' may be undefined [-Wsequence-point]|</p>\n</blockquote>\n<p>I already learned that <a href=\"https://stackoverflow.com/q/45937876/2932052\">assignment expressions in C/C++ can be heavily affected by undefined evaluation order</a>, but in this very case <strong>I just can't imagine how</strong>.</p>\n<p>Can the <em>undefined evaluation order</em> of <code>n = ++n;</code> really be relevant for the resulting program, especially for intended value of <code>n</code>? That's what I imagine what may happen.</p>\n<pre><code>Scenario #1\n++n;\nn=n;\n\nScenario #2\nn=n;\n++n;\n</code></pre>\n<p>I know that the meaning and implications of relaying on <a href=\"https://stackoverflow.com/questions/tagged/undefined-behavior%20c%2b%2b\">undefined behaviour in C++</a>, is hard to understand and hard to teach. </p>\n<p>I know that the behaviour of <code>n=++n;</code> is undefined by C++ standards before C++11. But it has a defined behaviour from C++11 on, and this (now standard-defined behaviour) is exactly the same I'm observing with several compilers<sup>[1]</sup> for this small demo program</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n = 0;\n    cout &lt;&lt; \"n before: \" &lt;&lt; n &lt;&lt; endl;\n    n=++n;\n    cout &lt;&lt; \"n after: \" &lt;&lt; n &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>that has the output \n</p>\n<pre><code>n before: 0\nn after: 1\n</code></pre>\n<p>Is it reasonable to expect that the behaviour is actually the same for all compilers regardless of being defined or not by standards? Can you <strong>(a)</strong> show one <strong>counter example</strong> or <strong>(b)</strong> give an easy to understand <strong>explanation</strong> how this code could produce wrong results?</p>\n<hr>\n<p><sup>[1]</sup> the compilers a used</p>\n<ul>\n<li>Borland-C++ 5.3.0 (pre-C++98)</li>\n<li>Borland-C++ 5.6.4 (C++98)</li>\n<li><a href=\"http://rextester.com/YXWXC29339\" rel=\"nofollow noreferrer\">C++ (vc++)</a></li>\n<li><a href=\"https://ideone.com/rwIsPg\" rel=\"nofollow noreferrer\">C++ (gcc 6.3)</a></li>\n<li><a href=\"https://ideone.com/yICPZq\" rel=\"nofollow noreferrer\">C++14 (gcc 6.3)</a></li>\n<li><a href=\"https://ideone.com/C64w4D\" rel=\"nofollow noreferrer\">C++14 clang</a></li>\n</ul>\n</hr>", "Title": "Why change UB that will always work as intended?", "CreationDate": "2017-09-06T09:46:59.990", "Id": "46071978", "CommentCount": "26", "LastEditDate": "2017-09-08T12:36:00.687", "PostTypeId": "1", "LastEditorUserId": "2932052", "LastActivityDate": "2017-09-08T12:36:00.687", "Tags": "<c++><undefined-behavior><legacy-code><pre-increment>", "Score": "0", "OwnerUserId": "2932052", "ClosedDate": "2017-09-06T13:46:28.403", "AnswerCount": "2"}, "46072243": {"Id": "46072243", "PostTypeId": "2", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_46071978_46072243_0\">If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the behavior is undefined:</p>\n</blockquote>\n<pre><code>i = ++i + 2;       // undefined behavior until C++11\ni = i++ + 2;       // undefined behavior until C++17\nf(i = -2, i = -2); // undefined behavior until C++17\nf(++i, ++i);       // undefined behavior until C++17, unspecified after C++17\ni = ++i + i++;     // undefined behavior\n</code></pre>\n<p>For the case <code>n = ++n;</code> it would be an undefined behavior but we do not care which assignment happens first, <code>n =</code> or <code>++n</code>.</p>\n", "LastEditorUserId": "1981061", "LastActivityDate": "2017-09-06T10:17:57.400", "Score": "-1", "CreationDate": "2017-09-06T09:59:08.090", "ParentId": "46071978", "CommentCount": "13", "LastEditDate": "2017-09-06T10:17:57.400", "OwnerUserId": "1981061"}, "46072212": {"Id": "46072212", "PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">increment order</a> is precisely defined. It is stated there that</p>\n<pre><code>i = ++i + 2;       // undefined behavior until C++11\n</code></pre>\n<p>Since you use a C++11 compiler, you can leave your code as is is. Nevertheless, I  think that the expressiveness of </p>\n<pre><code>n = (n+1) % size;\n</code></pre>\n<p>is higher. You can more easily figure out what was intended by the writer of this code.</p>\n", "LastActivityDate": "2017-09-06T09:57:30.707", "Score": "3", "CreationDate": "2017-09-06T09:57:30.707", "ParentId": "46071978", "CommentCount": "5", "OwnerUserId": "2416647"}});