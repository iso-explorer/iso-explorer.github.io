post_cb({"35367578": {"Id": "35367578", "PostTypeId": "2", "Body": "<p>Assuming <code>size</code> is the actual array size, you are passing a pointer to past-the-end element to <code>std::sort()</code>.</p>\n<p>So, as I understand it, the question boils down to: is this pointer equivalent to <code>arr.end()</code>?</p>\n<p>There is little doubt this is true for every existing compiler, since array iterators are indeed plain old pointers, so <code>&amp;arr[size]</code> is the obvious choice for <code>arr.end()</code>.</p>\n<p>However, I doubt there is a specific requirement about the actual implementation of plain old array iterators.</p>\n<p>So, for the sake of the argument, you could imagine a compiler using a \"past end\" bit in addition to the actual address to implement plain old array iterators internally <em>and</em> perversely paint your mustache pink if it detected any concievable inconsistency between iterators and addresses obtained through pointer arithmetics.\nThis freakish compiler would cause a lot of existing C++ code to crash without actually violating the spec, which might just be worth the effort of designing it...</p>\n", "LastEditorUserId": "2960823", "LastActivityDate": "2016-02-12T16:36:03.913", "Score": "0", "CreationDate": "2016-02-12T16:29:47.630", "ParentId": "35365205", "CommentCount": "0", "OwnerUserId": "2960823", "LastEditDate": "2016-02-12T16:36:03.913"}, "35367343": {"Id": "35367343", "PostTypeId": "2", "Body": "<p>In the context of normal C++ arrays, yes.  It is legal to form the address of the one-past-the-end element of the array.   It is not legal to read or write to what it is pointing at, however (after all, there is no actual element there).  So when you do the <code>&amp;arr[size]</code>, the <code>arr[size]</code> forms what you might think of as a reference to the one-past-the-end element, but has not tried to actually access that element yet.  Then the <code>&amp;</code> gets you the address of that element.  Since nothing has tried to actually follow that pointer, nothing bad has happened.</p>\n<p>This isn't by accident, this makes pointers into arrays behave like iterators.  Thus <code>&amp;a[0]</code> is essentially <code>.begin()</code> on the array, and <code>&amp;a[size]</code> (where size is the number of elements in the array) is essentially <code>.end()</code>.  (See also <code>std::array</code> where this ends up being more explicit)</p>\n<p>Edit: Erm, I may have to retract this answer.  While it probably applies in most cases, if the type stored in the array has an overridden <code>operator&amp;</code> then when you do the <code>&amp;a[size]</code>, the <code>operator&amp;</code> method may attempt to access members of the instance of the type at <code>a[size]</code> <strong>where there is no instance</strong>.</p>\n", "LastEditorUserId": "1987633", "LastActivityDate": "2016-02-12T23:43:41.787", "Score": "1", "CreationDate": "2016-02-12T16:19:37.070", "ParentId": "35365205", "CommentCount": "0", "OwnerUserId": "1987633", "LastEditDate": "2016-02-12T23:43:41.787"}, "35365205": {"ViewCount": "368", "Body": "<p>Let's say I have a function, called like this:</p>\n<pre><code>void mysort(int *arr, std::size_t size)\n{\n  std::sort(&amp;arr[0], &amp;arr[size]);\n}\n\nint main()\n{\n  int a[] = { 42, 314 };\n  mysort(a, 2);\n}\n</code></pre>\n<p>My question is: does the code of <code>mysort</code> (more specifically, <code>&amp;arr[size]</code>) have defined behaviour?</p>\n<p>I know it would be perfectly valid if replaced by <code>arr + size</code>; pointer arithmetic allows pointing past-the-end normally. However, my question is specifically about the use of <code>&amp;</code> and <code>[]</code>.</p>\n<p>Per C++11 5.2.1/1, <code>arr[size]</code> is equivalent to <code>*(arr + size)</code>.</p>\n<p>Quoting 5.3.1/1, the rules for unary <code>*</code>:</p>\n<blockquote>\n<p id=\"so_35365205_35365205_0\">The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a <strong>pointer to an\n  object type</strong>, or a pointer to a function type and the <strong>result is an lvalue referring to the object</strong> or function\n  <strong>to which the expression points</strong>. If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is \u201c<code>T</code>.\u201d\n  [ <em>Note:</em> a pointer to an incomplete type (other than <em>cv</em> <code>void</code>) can be dereferenced. The lvalue thus obtained\n  can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a\n  prvalue, see 4.1. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Finally, 5.3.1/3 giving the rules for <code>&amp;</code>:</p>\n<blockquote>\n<p id=\"so_35365205_35365205_1\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue ... if the type of\n  the expression is <code>T</code>, the result has type \u201cpointer to <code>T</code>\u201d and is a prvalue that is the <strong>address of the designated object</strong> (1.7) or a pointer to the designated function.</p>\n</blockquote>\n<p>(Emphasis and ellipses mine).</p>\n<p>I can't quite make up my mind about this. I know for sure that forcing an lvalue-to-rvalue conversion on <code>arr[size]</code> would be Undefined. But no such conversion happens in the code. <code>arr + size</code> does not point to an object; but while the paragraphs above talk about objects, they never seem to explicitly call out the necessity for an object to actually exist at that location (unlike e.g. the lvalue-to-rvalue conversion in 4.1/1).</p>\n<p>So, the questio is: is <code>mysort</code>, the way it's called, valid or not?</p>\n<p>(Note that I'm quoting C++11 above, but if this is handled more explicitly in a later standard/draft, I would be perfectly happy with that).</p>\n", "AcceptedAnswerId": "35367582", "Title": "Is &arr[size] valid?", "CreationDate": "2016-02-12T14:36:24.300", "Id": "35365205", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2016-02-13T21:28:00.627", "Score": "14", "OwnerUserId": "1782465", "Tags": "<c++><arrays><language-lawyer><undefined-behavior>", "AnswerCount": "5"}, "35367582": {"Id": "35367582", "PostTypeId": "2", "Body": "<p>It's not valid. You bolded \"result is an lvalue referring to the object or function to which the expression points\" in your question. That's exactly the problem. <code>array + size</code> is a valid pointer value that does not point to an object. Therefore, your quote about <code>*(array + size)</code> does not specify what the result refers to, and that then means there is no requirement for <code>&amp;*(array + size)</code> to give the same value as <code>array + size</code>.</p>\n<p>In C, this was considered a defect and fixed so that the spec now says in <code>&amp;*ptr</code>, neither <code>&amp;</code> nor <code>*</code> gets evaluated. C++ hasn't yet received fixed wording. It's the subject of a very old still active DR: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\">DR #232</a>. The intent is that it is valid, just as it is in C, but the standard doesn't say so.</p>\n", "LastActivityDate": "2016-02-12T16:29:55.510", "CommentCount": "3", "CreationDate": "2016-02-12T16:29:55.510", "ParentId": "35365205", "Score": "9", "OwnerUserId": "743382"}, "bq_ids": {"n4140": {"so_35365205_35365205_0": {"length": 44, "quality": 0.8627450980392157, "section_id": 6064}, "so_35365205_35365205_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 6066}}, "n3337": {"so_35365205_35365205_0": {"length": 46, "quality": 0.9019607843137255, "section_id": 5832}, "so_35365205_35365205_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 5834}}, "n4659": {"so_35365205_35365205_0": {"length": 43, "quality": 0.8431372549019608, "section_id": 7560}, "so_35365205_35365205_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 7562}}}, "35365273": {"Id": "35365273", "PostTypeId": "2", "Body": "<p>It's perfectly fine and well defined as long as size is not larger than the size of the actual array (in units of the array elements). </p>\n<p>So if main () called mysort (a, 100), &amp;arr [size] would already be undefined behaviour (but most likely undetected, but std::sort would obviously go wrong badly as well). </p>\n", "LastActivityDate": "2016-02-12T14:40:13.720", "CommentCount": "2", "CreationDate": "2016-02-12T14:40:13.720", "ParentId": "35365205", "Score": "-5", "OwnerUserId": "3255455"}, "35385475": {"Id": "35385475", "PostTypeId": "2", "Body": "<p>If we admit that <code>arr[i]</code> is just a shorthand for <code>*(arr + i)</code>, we can rewrite <code>&amp;arr[size]</code> as <code>&amp;*(arr + size)</code>. Hence, we are dereferencing a pointer that points to the past-the-end element, which leads to an undefined behavior. As you correctly say, <code>arr + size</code> would instead be legal, because no dereferencing operation takes place.    </p>\n<p>Coincidentally, this is also presented as a quiz in Stepanov's <a href=\"http://www.stepanovpapers.com/notes.pdf\" rel=\"nofollow\">notes</a> (page 11).</p>\n", "LastEditorUserId": "1849221", "LastActivityDate": "2016-02-13T21:28:00.627", "Score": "0", "CreationDate": "2016-02-13T21:21:41.293", "ParentId": "35365205", "CommentCount": "0", "OwnerUserId": "1849221", "LastEditDate": "2016-02-13T21:28:00.627"}});