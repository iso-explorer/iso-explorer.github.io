post_cb({"2362454": {"CommentCount": "4", "ViewCount": "2094", "PostTypeId": "1", "LastEditorUserId": "155693", "CreationDate": "2010-03-02T10:34:34.527", "LastActivityDate": "2010-03-02T14:24:09.960", "Title": "Checking if an iterator references an item in a list", "AcceptedAnswerId": "2362490", "LastEditDate": "2010-03-02T12:52:57.257", "Id": "2362454", "Score": "0", "Body": "<p>i just want to check, if the iterator points on an object in a list.</p>\n<p>What's the cmd?</p>\n<p>Thank you. :)</p>\n<p>SkyThe</p>\n<p>EDIT:</p>\n<p>Hmm,.. ok i tried it.\nNow there is a Error: \"Expression: list iterators incompitable\"</p>\n<p>Maybe some code:</p>\n<pre><code>#include &lt;list&gt;\nlist&lt;obj&gt; list;\nlist&lt;obj&gt;::iterator it;\n\nif(it != list.end()){ //here the error pops up when i debug\n  vShowStatus();\n}else{\n  cout &lt;&lt; \"...\";\n}\n</code></pre>\n", "Tags": "<c++><list><iterator>", "OwnerUserId": "284308", "AnswerCount": "5"}, "2362502": {"ParentId": "2362454", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can't. There's no method to check that. You must structure your code so that your iterator is between list.begin() and list.end().</p>\n<p>Use iterator this way:</p>\n<pre><code>for (std::list&lt;int&gt;::const_iterator it = myList.begin(); it != myList.end(); ++it)\n         cout &lt;&lt; *it &lt;&lt; \" \";\n</code></pre>\n<p>You can't compare [<strong>EDIT</strong>] list iterators with relational operators (&lt;, &gt;, &lt;=, &gt;=), so when you use an iterator outside a for loop, then you must always check if you go outside the bounds by comparing to begin() (if your going backward with --it) or with end() (if your going forward with ++it).</p>\n<pre><code>std::list&lt;int&gt;::const_iterator it = ... // initialized with some CORRECT value\n// going backward\nwhile (true)\n{\n    cout &lt;&lt; *it;\n    if (it == list.begin())\n        break;\n    --it;\n}\n// going forward\nwhile (true)\n{\n    cout &lt;&lt; *it;\n    ++it;\n    if (it == list.end())\n        break;\n}\n// or simplier\nwhile (it != list.end())\n{\n    cout &lt;&lt; *it;\n    ++it;\n}\n</code></pre>\n<p>If, for some reason, you really need a check, then you can loop through the list and check if any of the iterators is equal to yours. But this may have a considerable impact on performance, so use it only in debug or/and in tests.</p>\n", "OwnerUserId": "279307", "LastEditorUserId": "279307", "LastEditDate": "2010-03-02T10:55:50.577", "Id": "2362502", "Score": "6", "CreationDate": "2010-03-02T10:43:42.540", "LastActivityDate": "2010-03-02T10:55:50.577"}, "bq_ids": {"n4140": {"so_2362454_2363369_0": {"section_id": 5559, "quality": 0.8636363636363636, "length": 38}}, "n3337": {"so_2362454_2363369_0": {"section_id": 5341, "quality": 0.8636363636363636, "length": 38}}, "n4659": {"so_2362454_2363369_0": {"section_id": 7006, "quality": 0.8636363636363636, "length": 38}}}, "2362633": {"ParentId": "2362454", "CommentCount": "0", "Body": "<p>You have an uninitialized iterator there. I don't think there is a way to test if it is uninitialized. (Always initialize your variables to avoid this problem in the first place.)</p>\n<p>You can determine if an <strong>initialized</strong> iterator points to something in a list by comparing it to the end iterator of the <strong>same</strong> list.</p>\n", "OwnerUserId": "219972", "PostTypeId": "2", "Id": "2362633", "Score": "0", "CreationDate": "2010-03-02T11:07:33.523", "LastActivityDate": "2010-03-02T11:07:33.523"}, "2363369": {"ParentId": "2362454", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard has this to say about uninitialized iterators (24.1.5): </p>\n<blockquote>\n<p id=\"so_2362454_2363369_0\">Iterators can also have singular\n  values that are not associated with\n  any container. For example, after the\n  declaration of an uninitialized\n  pointer <code>x</code> (as with <code>int* x;</code>), <code>x</code> must\n  always be assumed to have a singular\n  value of a pointer. Results of most\n  expressions are undefined for singular\n  values; the only exception is an\n  assignment of a non-singular value to\n  an iterator that holds a singular\n  value. In this case the singular value\n  is overwritten the same way as any\n  other value.</p>\n</blockquote>\n<p>So, no. Since the only thing you can do with an uninitialized (or invalidated) iterator is to make it a valid iterator, there is no way to test if you have one. Always initialize the iterators that you declare (also limit the scope you use them in), and make sure you don't continue to use the iterator after an invalidating operation.</p>\n<p>It is possible, though, that the specific implementation of your compiler's SC++L keeps track of uninitialized iterators, and throws an error of the kind you are seeing if you do something illegal with the iterator. This is in no way a guaranteed result, though.</p>\n", "OwnerUserId": "155693", "LastEditorUserId": "155693", "LastEditDate": "2010-03-02T14:24:09.960", "Id": "2363369", "Score": "1", "CreationDate": "2010-03-02T13:29:22.323", "LastActivityDate": "2010-03-02T14:24:09.960"}, "2362473": {"ParentId": "2362454", "CommentCount": "3", "Body": "<p>Read about <a href=\"http://www.cppreference.com/wiki/stl/iterators\" rel=\"nofollow noreferrer\">C++ Iterators</a></p>\n<p>En example:</p>\n<pre><code>vector&lt;int&gt; the_vector;\nvector&lt;int&gt;::iterator the_iterator;\n\n\nfor( int i=0; i &lt; 10; i++ ) the_vector.push_back(i);\nint total = 0;\nthe_iterator = the_vector.begin();\nwhile( the_iterator != the_vector.end() ) {\n  total += *the_iterator;\n  ++the_iterator;\n}\n\ncout &lt;&lt; \"Total=\" &lt;&lt; total &lt;&lt; endl;\n</code></pre>\n", "OwnerUserId": "39106", "PostTypeId": "2", "Id": "2362473", "Score": "1", "CreationDate": "2010-03-02T10:38:22.577", "LastActivityDate": "2010-03-02T10:38:22.577"}, "2362490": {"ParentId": "2362454", "CommentCount": "10", "Body": "<pre><code>if (it!=collection.end()) std::cout &lt;&lt; \"Iterator points to data\" &lt;&lt; std::endl;\nelse                      std::cout &lt;&lt; \"Iterator does not point to data\" &lt;&lt; std::endl;\n</code></pre>\n", "OwnerUserId": "163551", "PostTypeId": "2", "Id": "2362490", "Score": "0", "CreationDate": "2010-03-02T10:40:57.183", "LastActivityDate": "2010-03-02T10:40:57.183"}});