post_cb({"27930448": {"CommentCount": "21", "AcceptedAnswerId": "28021419", "PostTypeId": "1", "LastEditorUserId": "21475", "CreationDate": "2015-01-13T19:56:01.407", "LastActivityDate": "2015-02-11T09:13:44.217", "LastEditDate": "2015-01-14T20:39:21.250", "ViewCount": "688", "FavoriteCount": "5", "Title": "Why does this dependent name lookup find a global identifier instead of the method?", "Id": "27930448", "Score": "34", "Body": "<p>When the compiler tries to resolve <code>i.template hi&lt;T&gt;();</code> it finds <code>hi</code> in the global namespace instead of the method <code>hi</code> on <code>i</code> (<a href=\"http://ideone.com/3fbQ0a\">ideone</a>). Why?</p>\n<pre><code>#include &lt;cstdio&gt;\n\n// Define 'hi' and 'bye' in the global namespace; these should *not* be used\ntemplate&lt;typename T&gt; struct hi { };\ntemplate&lt;typename T&gt; struct bye { };\n\n// Foo needs to be templated for Foo::Inner to be a dependent type (I think)\ntemplate&lt;typename T&gt;\nstruct Foo\n{\n    struct Inner {\n        // This is a plain-old templated member function of Inner, yes?\n        template&lt;typename U&gt;\n        void hi() { std::printf(\"hi!\\n\"); }\n\n        // This is a plain-old member function of Inner\n        void bye() { std::printf(\"bye!\\n\"); }\n    };\n\n    void sayStuff()\n    {\n        Inner i;\n        i.template hi&lt;T&gt;();   // Fails to compile -- finds global hi instead of member\n        i.bye();              // Compiles fine, finds member\n    }\n};\n\nint main() {\n    Foo&lt;int&gt; f;\n    f.sayStuff();\n    return 0;\n}\n</code></pre>\n<p>I'm using g++ 4.9.1/4.9.2 (<code>-std=c++11</code>). The exact error message:</p>\n<pre><code>prog.cpp: In member function 'void Foo&lt;T&gt;::sayStuff()':\nprog.cpp:19:5: error: invalid use of 'struct hi&lt;T&gt;'\n   i.template hi&lt;T&gt;();\n     ^\n</code></pre>\n<p>This code works fine with Clang and VS2013, but generates an error in g++ and EDG. But which compilers are right?</p>\n<p>Is there any way to resolve this besides changing the name of the member? In my real code, the conflict arises when a type from the <code>std</code> namespace (that's been imported via <code>using namespace std</code>, say) has the same name as one of my member functions. Obviously I'd like my implementation code to be robust and not cause random name clashes in user code.</p>\n", "Tags": "<c++><templates><c++11><gcc><name-lookup>", "OwnerUserId": "21475", "AnswerCount": "1"}, "28021419": {"ParentId": "27930448", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>To the best of my knowledge here's what's going on.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#228\" rel=\"nofollow noreferrer\">DR228</a> says:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_0\">[Voted into WP at April 2003 meeting.]</p>\n<p id=\"so_27930448_28021419_1\">Consider the following example:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt;\nstruct X {\n   virtual void f();\n};\n\ntemplate&lt;class T&gt;\nstruct Y {\n  void g(X&lt;T&gt; *p) {\n    p-&gt;template X&lt;T&gt;::f();\n  }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_27930448_28021419_2\">This is an error because X is not a member template; 14.2 [temp.names] paragraph 5 says:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_9\">If a name prefixed by the keyword template is not the name of a member template, the program is ill-formed. </p>\n</blockquote>\n<p id=\"so_27930448_28021419_4\">In a way this makes perfect sense: X is found to be a template using ordinary lookup even though p has a dependent type. However, I think this makes the use of the template prefix even harder to teach.</p>\n<p id=\"so_27930448_28021419_5\">Was this intentionally outlawed?</p>\n<p id=\"so_27930448_28021419_6\">Proposed Resolution (4/02):</p>\n<p id=\"so_27930448_28021419_7\">Elide the first use of the word \"member\" in 14.2 [temp.names] paragraph 5 so that its first sentence reads:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_10\">If a name prefixed by the keyword template is not the name of a template, the program is ill-formed.</p>\n</blockquote>\n</blockquote>\n<p>However, in the most current publicly available draft of the C++ standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a> the following wording appears in \u00a714.2.5:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_11\">A name prefixed by the keyword template shall be a <em>template-id</em> or the name shall refer to a class template. [<em>Note</em>: The keyword <code>template</code> may not be applied to non-template members of class templates. <em>\u2014end note</em>] [<em>Note</em>: As is the case with the <code>typename</code> prefix, the <code>template</code> prefix is allowed in cases where it is not strictly necessary; i.e., when the <em>nested-name-specifier</em> or the expression on the left of the <code>-&gt;</code> or <code>.</code> is not dependent on a <em>template-parameter</em>, or the use does not appear in the scope of a template. <em>\u2014end note</em>]</p>\n<p id=\"so_27930448_28021419_12\">[<em>Example</em>:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; struct A {\n  void f(int);\n  template &lt;class U&gt; void f(U);\n};\n\ntemplate &lt;class T&gt; void f(T t) {\n  A&lt;T&gt; a;\n  a.template f&lt;&gt;(t); // OK: calls template\n  a.template f(t); // error: not a template-id\n}\n\ntemplate &lt;class T&gt; struct B {\n  template &lt;class T2&gt; struct C { };\n};\n// OK: T::template C names a class template:\n\ntemplate &lt;class T, template &lt;class X&gt; class TT = T::template C&gt; struct D { };\nD&lt;B&lt;int&gt; &gt; db;\n</code></pre>\n<blockquote>\n<p id=\"so_27930448_28021419_13\"><em>\u2014end example</em>]</p>\n</blockquote>\n<p>This wording sounded similar, but different enough to go digging.  I found that in the <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2010/n3126.pdf\" rel=\"nofollow noreferrer\">N3126</a> draft the wording was changed to this version.</p>\n<p>I was able to link this change back to this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3116.html#96\" rel=\"nofollow noreferrer\">DR96</a>:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_14\">The following is the wording from 14.2 [temp.names] paragraphs 4 and 5 that discusses the use of the \"template\" keyword following . or -&gt; and in qualified names.</p>\n<p id=\"so_27930448_28021419_15\">{snip}</p>\n<p id=\"so_27930448_28021419_16\">The whole point of this feature is to say that the \"template\" keyword is needed to indicate that a \"&lt;\" begins a template parameter list in certain contexts. The constraints in paragraph 5 leave open to debate certain cases.</p>\n<p id=\"so_27930448_28021419_17\">First, I think it should be made more clear that the template name must be followed by a template argument list when the \"template\" keyword is used in these contexts. If we don't make this clear, we would have to add several semantic clarifications instead. For example, if you say \"p-&gt;template f()\", and \"f\" is an overload set containing both templates and nontemplates: a) is this valid? b) are the nontemplates in the overload set ignored? If the user is forced to write \"p-&gt;template f&lt;&gt;()\" it is clear that this is valid, and it is equally clear that nontemplates in the overload set are ignored. As this feature was added purely to provide syntactic guidance, I think it is important that it otherwise have no semantic implications.</p>\n</blockquote>\n<p>Essentially, the very subtle change of DR228 was lost during a subsequent revision; however, because no similar restriction was placed the intent of DR228 probably still holds unless there's been another revision in the standard.  This means that template lookup has to occur globally in this case, even though it's a dependent type.</p>\n<p>Let's look at our name lookup rules \u00a73.4.5.1:</p>\n<blockquote>\n<p id=\"so_27930448_28021419_18\">In a class member access expression (5.2.5), if the <code>.</code> or <code>-&gt;</code> token is immediately followed by an <em>identifier</em> followed by a <code>&lt;</code>, the identifier must be looked up to determine whether the <code>&lt;</code> is the beginning of a <em>template</em> argument list (14.2) or a less-than operator. The identifier is first looked up in the class of the object expression. If the identifier is not found, it is then looked up in the context of the entire <em>postfix-expression</em> and shall name a class template.</p>\n</blockquote>\n<p>This seems to explicitly state that in <code>baz.foo-&gt;template bar&lt;T&gt;();</code>  We will first look in the class context, this includes standard template lookup.  After that is done and if nothing is found, if the form of the expression is correct we jump to the context of the entire expression.  In essence, it has been promoted and the lookup for that name must perform the same way if the line just read <code>template bar&lt;T&gt;();</code>  Really though we already knew this from DR228.  I just wanted to double check and confirm.  The real question is which template ought to get priority, the one in the global scope or the one in the class scope.</p>\n<p>For that we now need to ask unqualified name lookup, because now bar is being considered in the same context as foo, so it's no longer following member lookup rules, it's following normal, unqualified template lookup rules, which, naturally, prefer the local version.</p>\n<p>So in summation, it seems that Clang and MSVC exhibit correct behavior, and GCC and EDG do not in this instance.</p>\n<p>My best guess as to why GCC has it wrong is choosing the wrong context to assign to the expression after the rule is triggered.  Instead of placing the context at the same level as the postfix-expression it may be just placing it at in the global level on accident?  Maybe it simply skips the first lookup step?  (But this is merely speculation, I'd have to actually figure out where to look in the GCC source to say.)  This would also explain why @Mikael Persson's solution of changing the lookup to a qualified one caused the compile to start again.</p>\n<p>The linked bug report from the asker has people talking about why the global scope must be considered, and it ought to be, but it seems pretty straight forward that a local scope match must be given higher priority than the global one.  It also seems like there's been a bit of activity there recently.</p>\n", "OwnerUserId": "483486", "LastEditorUserId": "483486", "LastEditDate": "2015-02-11T09:13:44.217", "Id": "28021419", "Score": "8", "CreationDate": "2015-01-19T09:29:08.130", "LastActivityDate": "2015-02-11T09:13:44.217"}, "bq_ids": {"n4140": {"so_27930448_28021419_10": {"section_id": 73, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_9": {"section_id": 73, "quality": 0.75, "length": 6}, "so_27930448_28021419_3": {"section_id": 73, "quality": 0.75, "length": 6}, "so_27930448_28021419_11": {"section_id": 73, "quality": 0.8444444444444444, "length": 38}, "so_27930448_28021419_8": {"section_id": 73, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_18": {"section_id": 7126, "quality": 0.9230769230769231, "length": 36}}, "n3337": {"so_27930448_28021419_10": {"section_id": 68, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_9": {"section_id": 68, "quality": 0.75, "length": 6}, "so_27930448_28021419_3": {"section_id": 68, "quality": 0.75, "length": 6}, "so_27930448_28021419_11": {"section_id": 68, "quality": 0.8444444444444444, "length": 38}, "so_27930448_28021419_8": {"section_id": 68, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_18": {"section_id": 6870, "quality": 0.9230769230769231, "length": 36}}, "n4659": {"so_27930448_28021419_10": {"section_id": 75, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_9": {"section_id": 75, "quality": 0.75, "length": 6}, "so_27930448_28021419_3": {"section_id": 75, "quality": 0.75, "length": 6}, "so_27930448_28021419_11": {"section_id": 75, "quality": 0.8444444444444444, "length": 38}, "so_27930448_28021419_8": {"section_id": 75, "quality": 0.8571428571428571, "length": 6}, "so_27930448_28021419_18": {"section_id": 8627, "quality": 0.9230769230769231, "length": 36}}}});