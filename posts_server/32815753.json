post_cb({"32815753": {"CommentCount": "0", "ViewCount": "293", "PostTypeId": "1", "LastEditorUserId": "2122943", "CreationDate": "2015-09-28T04:35:48.803", "LastActivityDate": "2015-09-28T11:47:54.883", "Title": "C++ Map Concurrent Insertion and Reading by Two threads", "LastEditDate": "2015-09-28T04:48:11.793", "Id": "32815753", "Score": "0", "Body": "<p>There are two threads where one will insert into the map and the other will <code>find</code> from the map. </p>\n<pre><code>map&lt;string,object&gt;* mapA;\n</code></pre>\n<p>If thread A will insert the configuration object into the Map w.r.t the string key. </p>\n<p>Where the thread B will try to find with the same string key. If not present it will try again until the string key is found by it. </p>\n<p>Will it cause a crash or data corruption in the process , if thread A inserts at the same time when thread B is read the key ? Is there synchronization needed here?</p>\n<p><em>While testing with a sample application i dint face any type of crash or corruption</em></p>\n", "Tags": "<c++><multithreading><dictionary><synchronization>", "OwnerUserId": "2122943", "AnswerCount": "2"}, "32815910": {"ParentId": "32815753", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-09-28T04:54:17.160", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:48:17.497", "Id": "32815910", "OwnerUserId": "1163462", "Body": "<p>The container can be accessed without any locking mechanism, only if all the threads involved are reader threads.</p>\n<p>The thread safety of stl containers has been discussed here:</p>\n<p><a href=\"https://stackoverflow.com/questions/9274250/why-does-the-c-stl-not-provide-a-set-of-thread-safe-containers\">Why does the C++ STL not provide a set of thread-safe containers?</a> </p>\n<p>Quoting the spec:</p>\n<p>23.2.2 Container data races</p>\n<blockquote>\n<p id=\"so_32815753_32815910_0\">\"implementations are required to avoid data races when the contents of\n  the contained object in different elements in the same container,\n  excepting vector, are modified concurrently.\"</p>\n</blockquote>\n<p>In short, in your case, since both insert and find are involved from different threads, locking is needed.</p>\n<p><em>Use-case where locking is needed:\nIf you have a datastructure on which insert and find are being performed intermittently/concurrently, then locking is needed .</em></p>\n<p><em>Use-case where locking is not needed:\nIf you have a datastructure that is populated at one shot and then subsequently, only finds are performed then locking is not needed.</em></p>\n<p>Here is the source code:</p>\n<p>STL map uses rb-tree internally.so, here is a look at rb-tree find method.</p>\n<pre><code>template &lt;class _Key, class _Value, class _KeyOfValue, \n          class _Compare, class _Alloc&gt;\ntypename _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator \n_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::find(const _Key&amp; __k)\n{\n  _Link_type __y = _M_header;      // Last node which is not less than __k. \n  _Link_type __x = _M_root();      // Current node. \n\n  while (__x != 0) \n    if (!_M_key_compare(_S_key(__x), __k))\n      __y = __x, __x = _S_left(__x);\n    else\n      __x = _S_right(__x);\n\n  iterator __j = iterator(__y);   \n  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? \n     end() : __j;\n}\n</code></pre>\n<p>As seen, there is no lock used and it makes sense since the overhead of lock is not really needed/desired for non-threaded applications.</p>\n", "LastActivityDate": "2015-09-28T06:46:03.847"}, "bq_ids": {"n4140": {"so_32815753_32815910_0": {"section_id": 718, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_32815753_32815910_0": {"section_id": 707, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_32815753_32815910_0": {"section_id": 749, "quality": 0.9411764705882353, "length": 16}}}, "32822256": {"ParentId": "32815753", "CommentCount": "0", "Body": "<p>Basically you have no idea what will happen, STL will make no promises that the data will be ready for you to read from the first thread while the other does an insert. If you want to do this you need locking, just because you haven't seen any problem doesn't mean it will never happen.</p>\n", "OwnerUserId": "5375528", "PostTypeId": "2", "Id": "32822256", "Score": "0", "CreationDate": "2015-09-28T11:47:54.883", "LastActivityDate": "2015-09-28T11:47:54.883"}});