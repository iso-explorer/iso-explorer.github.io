post_cb({"12399372": {"CommentCount": "1", "AcceptedAnswerId": "12399395", "CreationDate": "2012-09-13T04:21:48.717", "LastActivityDate": "2012-09-13T04:51:53.583", "PostTypeId": "1", "ViewCount": "1121", "FavoriteCount": "1", "Title": "C++ const and mutable functions with the same name", "Id": "12399372", "Score": "4", "Body": "<p>Considering the following piece of code. </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Object\n{\npublic:\nObject() {}\n\nvoid Print() const\n{\ncout &lt;&lt; \"const\" &lt;&lt; endl;\n}\n\nvoid Print()\n{\ncout &lt;&lt; \"mutable\" &lt;&lt; endl;\n}\n};\n\nvoid print_obj(const Object&amp; obj)\n{\nobj.Print();\n}\n\nint main()\n{\nObject       obj1;\nconst Object obj2;\nObject*const pobj1 = &amp;obj1;\n\nprint_obj(obj1);\nprint_obj(obj2);\n\nobj1.Print();\nobj2.Print();\n\npobj1-&gt;Print();\n\nreturn 0;\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>const\nconst\nmutable\nconst\nmutable\n</code></pre>\n<p>I am wondering, how does C++ decide which method to invoke, when facing many mutable methods with the same name? </p>\n", "Tags": "<c++><const><overloading><method-overloading>", "OwnerUserId": "509205", "AnswerCount": "4"}, "12399431": {"ParentId": "12399372", "CommentCount": "0", "Body": "<p>Keeping in mind that, for a normal object if a non-<code>const</code> version is available then non-<code>const</code> version is chosen; otherwise <code>const</code> version is chosen. Below is the analysis:</p>\n<pre><code>print_obj(obj1); // print_obj() receives const argument, so `const` is chosen\nprint_obj(obj2); // same as above\n\nobj1.Print();  // obj1 is not const, so non-const version is chosen\nobj2.Print();  // obj2 is const, so must choose const version\n\npobj1-&gt;Print(); // pobj1 is a const pointer pointing to non-const object, so non-const version is chosen\n</code></pre>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "12399431", "Score": "1", "CreationDate": "2012-09-13T04:29:12.677", "LastActivityDate": "2012-09-13T04:29:12.677"}, "12399392": {"ParentId": "12399372", "CommentCount": "0", "Body": "<p>It would prefer a const method to non-const if both would do.</p>\n<p>Same works for volatile, BTW.</p>\n", "OwnerUserId": "73656", "PostTypeId": "2", "Id": "12399392", "Score": "-2", "CreationDate": "2012-09-13T04:24:04.783", "LastActivityDate": "2012-09-13T04:24:04.783"}, "12399402": {"ParentId": "12399372", "CommentCount": "0", "Body": "<p>The same way all function overloading works.</p>\n<p>When considering a member function for overloading, it includes the implicit <code>this</code> parameter. If the function is declared <code>const</code>, then the <code>this</code> parameter is <code>const Object *</code>. If the function is not <code>const</code> then the <code>this</code> parameter is <code>Object *</code>. Since <code>const</code> qualifiers affect the function overloading rules, this means that the <code>const</code>ness of a function also affects the function overloading rules.</p>\n<p>In your specific example, <code>print_obj(obj1)</code> prints <code>const</code> because <code>print_obj()</code> is declared as taking a <code>const Object&amp;</code>, which means it will always invoke the <code>const</code> version of <code>Print()</code>. Same thing with <code>print_obj(obj2)</code>.</p>\n<p><code>obj1.Print()</code> prints <code>mutable</code> because <code>obj1</code> is not <code>const</code>, therefore the non-<code>const</code> version of <code>Print()</code> is a better match and is picked for the function overload resolution.</p>\n<p><code>obj2.Print()</code> prints <code>const</code> because <code>obj2</code> is <code>const</code>, therefore the <code>const</code> version of <code>Print()</code> is the only function overload that's suitable.</p>\n<p><code>pobj1-&gt;Print()</code> prints <code>mutable</code> because <code>*pboj1</code> is a non-<code>const</code> value, so the non-<code>const</code> version of <code>Print()</code> is picked for the function overload resolution.</p>\n<p>The simplest way to think about it is, what would happen if you simply had</p>\n<pre><code>void Print(Object &amp;obj);\nvoid Print(const Object &amp;obj);\n</code></pre>\n", "OwnerUserId": "582", "PostTypeId": "2", "Id": "12399402", "Score": "1", "CreationDate": "2012-09-13T04:25:39.957", "LastActivityDate": "2012-09-13T04:25:39.957"}, "12399395": {"ParentId": "12399372", "PostTypeId": "2", "CommentCount": "1", "Body": "<pre><code>print_obj(obj1); \nprint_obj(obj2); \n</code></pre>\n<p>The function to be called is evaluated on the basis of the <em>cv-qualifier</em>(<code>const</code>/<code>volatile</code>) of the passed object. Note that <em>cv-qualifiers</em> are considered while function overload resolution.<br>\nIf passed object is <code>const</code>, function receiving <code>const</code> argument is selected.If passed object is non-const then function receiving non-const argument is selected.</br></p>\n<hr>\n<pre><code>obj1.Print();   \nobj2.Print();   \npobj1-&gt;Print();\n</code></pre>\n<p>If the object is <code>const</code> then only call <code>const</code> member function can be called.<br>\nIf the object is non-const then the non-const version is prefferred over the <code>const</code> version.        </br></p>\n<p>The rules are clearly specified by the standard.</p>\n<p>Reference:<br>\n<strong>C++03 standard:<br>\n\u00a713.3.1 Candidate functions and argument lists:</br></strong> </br></p>\n<blockquote>\n<p id=\"so_12399372_12399395_0\">For non-static member functions, the type of the implicit object parameter is \u201creference to cv <code>X</code>\u201d where <code>X</code> is the class of which the function is a member and cv is the cv-qualification on the member function declaration. [Example: for a const member function of class <code>X</code>, the extra parameter is assumed to have type \u201creference to const <code>X</code>\u201d. ]</p>\n</blockquote>\n<p>So if the object is <code>const</code> compiler will pick version of member function which has implicit object parameter of type <em>reference to const <code>Object</code></em> which is const version of <code>Print()</code>.</p>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-09-13T04:51:53.583", "Id": "12399395", "Score": "7", "CreationDate": "2012-09-13T04:24:36.337", "LastActivityDate": "2012-09-13T04:51:53.583"}, "bq_ids": {"n4140": {"so_12399372_12399395_0": {"section_id": 568, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_12399372_12399395_0": {"section_id": 559, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_12399372_12399395_0": {"section_id": 591, "quality": 0.9310344827586207, "length": 27}}}});