post_cb({"13674353": {"ParentId": "13674332", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The standard <em>does</em> guarantee that mixing the two allocation variants will work. What it <em>doesn't</em> permit is things like calling <code>free</code> on memory that came from <code>new</code>, since they may use a totally different arena for the two types.</p>\n<p>Providing you remember to call the correct deallocation function for a given block of memory, you will be fine. They <em>won't</em> trample each other if you follow the rules and, if you don't follow the rules then, technically, <em>you're</em> doing the trampling, not them :-)</p>\n<hr>\n<p>The controlling part of the C++11 standard is <code>20.6.13 C library</code> which states, paraphrased:</p>\n<ul>\n<li>The functions <code>calloc</code>, <code>malloc</code>, <code>free</code> and <code>realloc</code> are provided, based on the C standard.</li>\n<li>The functions do not use <code>::operator new()</code> or <code>::operator delete()</code>.</li>\n<li>This allows the heritage C stuff to use a different memory arena then the normal C++ memory allocation.</li>\n</ul>\n<p>That second bullet point is interesting in light of what you're eventually proposing, dropping in <code>tcmalloc</code> to replace the C heritage functions and have C++ use it as well.</p>\n<p>There's a footnote in the standard which explains why they don't use let <code>malloc()</code> call <code>::operator new()</code>:</p>\n<blockquote>\n<p id=\"so_13674332_13674353_0\">The intent is to have operator new() implementable by calling std::malloc() or std::calloc(). In other words, they want to avoid a circular dependency.</p>\n</blockquote>\n<p>However, while it <em>allows</em> <code>operator new()</code> to call <code>malloc()</code>, I'm not sure that the standard actually <em>requires</em> it. So, to be safe, you'd probably want to inject <code>tcmalloc</code> into both the C <em>and</em> C++ areas.</p>\n<p>You've indicated you already know how to do that for C. For C++, it can be done by simply providing the entire set of global <code>operator new()/delete()</code> functions in your code, suitably written to call <code>tcmalloc</code> under the covers. The C++ standard states in <code>3.7.4 Dynamic storage duration</code>:</p>\n<blockquote>\n<p id=\"so_13674332_13674353_1\">The library provides default definitions for the global allocation and deallocation functions. Some global allocation and deallocation functions are replaceable.</p>\n<p id=\"so_13674332_13674353_2\">A C++ program shall provide at most one definition of a replaceable allocation or deallocation function. Any such function definition replaces the\n  default version provided in the library.</p>\n<p id=\"so_13674332_13674353_3\">The following allocation and deallocation functions are implicitly declared in global scope in each translation unit of a program:</p>\n<ul>\n<li><code>void* operator new(std::size_t);</code></li>\n<li><code>void* operator new[](std::size_t);</code></li>\n<li><code>void operator delete(void*);</code></li>\n<li><code>void operator delete[](void*);</code></li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2015-09-22T01:38:03.227", "Id": "13674353", "Score": "26", "CreationDate": "2012-12-02T22:00:35.387", "LastActivityDate": "2015-09-22T01:38:03.227"}, "13674566": {"ParentId": "13674332", "CommentCount": "0", "Body": "<p>You don't have to worry about any memory allocated by the generated code of Flex or Bison; they take care of it themselves.  For the rest, just use <code>new</code> and <code>delete</code>.  (And Flex and Bison are capable of generating C++, of a sort.  In general, I've found running the output through a simple script, using <code>sed</code> has been sufficient to make their output truly C++ compatible.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "13674566", "Score": "-1", "CreationDate": "2012-12-02T22:21:57.800", "LastActivityDate": "2012-12-02T22:21:57.800"}, "13674837": {"ParentId": "13674332", "CommentCount": "0", "Body": "<p>Ok.  Dug up an old working draft of the standard (2/28/2011 rev 3242.)  It appears the relevant sections are <code>3.7.4 Dynamic storage duration</code> and <code>18.6.1 Storage allocation and deallocation</code>.</p>\n<p>In short it seems the pan-galactic hook I wanted are the global new and delete operators themselves.  If one respects some semantics (in <code>3.7.4.1</code> and <code>3.7.4.2</code>: basically delegate to <code>new_handler</code> as needed) one is allowed to replace</p>\n<pre><code>void* operator new(std::size_t);\nvoid* operator new[](std::size_t);\nvoid operator delete(void*);\nvoid operator delete[](void*);\n</code></pre>\n<p>to arrest default memory management of the entire C++ program.  I still can't find the section that proves @paxdiablo right, but I'm willing to run with it for now.</p>\n", "OwnerUserId": "580412", "PostTypeId": "2", "Id": "13674837", "Score": "2", "CreationDate": "2012-12-02T22:54:26.217", "LastActivityDate": "2012-12-02T22:54:26.217"}, "bq_ids": {"n4140": {"so_13674332_13674353_3": {"section_id": 7174, "quality": 0.9166666666666666, "length": 11}, "so_13674332_13674353_1": {"section_id": 7174, "quality": 0.9333333333333333, "length": 14}, "so_13674332_13674353_2": {"section_id": 7174, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_13674332_13674353_3": {"section_id": 6918, "quality": 0.9166666666666666, "length": 11}, "so_13674332_13674353_1": {"section_id": 6918, "quality": 0.9333333333333333, "length": 14}, "so_13674332_13674353_2": {"section_id": 6918, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_13674332_13674353_3": {"section_id": 8682, "quality": 0.9166666666666666, "length": 11}, "so_13674332_13674353_2": {"section_id": 8682, "quality": 0.9411764705882353, "length": 16}, "so_13674332_13674353_1": {"section_id": 8682, "quality": 0.9333333333333333, "length": 14}}}, "13674332": {"CommentCount": "0", "AcceptedAnswerId": "13674353", "PostTypeId": "1", "LastEditorUserId": "580412", "CreationDate": "2012-12-02T21:57:56.067", "LastActivityDate": "2015-09-22T01:38:03.227", "LastEditDate": "2015-09-21T23:37:59.773", "ViewCount": "2419", "FavoriteCount": "3", "Title": "What is the \"correct\" way to reconcile malloc and new in a mixed C/C++ program?", "Id": "13674332", "Score": "16", "Body": "<p>I have a mixed C/C++ program.  It contains a flex/bison parser which targets C, while the remainder is C++.</p>\n<p>Being C, the generated parser and scanner manage their memory with <code>malloc</code>, <code>realloc</code> and <code>free</code>.  They are good enough to expose hooks allowing me to submit my own implementations of these functions.  As you might expect, the rest of the (C++) program \"wants\" to use <code>new</code>, <code>delete</code>, etc.</p>\n<p>Doing a little research seems to show that the relevant standards do not guarantee that such mixing should work.  Particularly the C \"heap\" is not necessarily the C++ \"free area\".  It seems the two schemes can trample each other. </p>\n<p>On top of this, someday (soon) this program will probably want to integrate a customized heap implementation such as <a href=\"http://goog-perftools.sourceforge.net/doc/tcmalloc.html\" rel=\"nofollow\">tcmalloc</a>, used by both C and C++.</p>\n<p><strong>What is the \"right\" thing to do here?</strong></p>\n<p>Given the desire to integrate tcmalloc (which explains how to link with C programs) I'm tempted to find some cross-type, cross-thread, cross-everything overload/hook/whatever into C++ memory management.  With that I could point all C++ allocation/release calls back to their C equivalents (which in turn land on tcmalloc.)</p>\n<p>Does such a pan-galactic global C++ hook exist?  Might it already be doing what I want, similar to how <code>ios_base::sync_with_stdio</code> secretly marries iostream and stdio by default?</p>\n<p>I am not interested in talking about stdio vs. iostreams, nor about switching parser generators nor using the C++ flex/bison skeletons (they introduce independent headaches.)</p>\n<p><strong>EDIT</strong>: Please include the names of those sections of the C++ standard that support your answer.</p>\n", "Tags": "<c++><c><memory-management><malloc><new-operator>", "OwnerUserId": "580412", "AnswerCount": "3"}});