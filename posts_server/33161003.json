post_cb({"33161003": {"CommentCount": "1", "AcceptedAnswerId": "33161401", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-10-16T01:14:23.703", "LastActivityDate": "2015-10-30T18:21:42.603", "LastEditDate": "2015-10-16T02:10:19.183", "ViewCount": "307", "FavoriteCount": "1", "Title": "Using a temporary array as an lvalue", "Id": "33161003", "Score": "8", "Body": "<p>This program is ill-formed:</p>\n<pre><code>struct X { int i; };\n\nint main() {\n    (X { }).i = 1;\n}\n</code></pre>\n<p><code>i</code>, a sub-object of the temporary <code>X { }</code>, cannot be used as an lvalue because  <code>X { }</code> is an rvalue.</p>\n<p>However, this silently compiles with GCC 5.2.1 and <code>-Wall</code>:</p>\n<pre><code>using Y = int[10];\n\nint main() {\n    (Y { })[0] = 1;\n}\n</code></pre>\n<p>If the compiler is correct, then this time, the zeroth element of <code>(Y { })</code>, which is a subobject of <code>(Y { })</code>, can be treated as an lvalue.</p>\n<p>My questions are:</p>\n<ol>\n<li>Is the second program ill-formed?</li>\n<li>Why (not), even though both programs seem to treat a subobject of a temporary as an lvalue?</li>\n</ol>\n", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "5451968", "AnswerCount": "2"}, "33161103": {"ParentId": "33161003", "CommentCount": "1", "Body": "<p>The draft of C++ standard (N4527) \u00a7 5.2.1 clause 1 says:</p>\n<blockquote>\n<p id=\"so_33161003_33161103_0\">The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n<p>\u00a7 5.3.1 clause 1 says:</p>\n<blockquote>\n<p id=\"so_33161003_33161103_1\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and <strong>the result is an lvalue</strong> referring to the object or function to which the expression points.</p>\n</blockquote>\n", "OwnerUserId": "2486888", "PostTypeId": "2", "Id": "33161103", "Score": "3", "CreationDate": "2015-10-16T01:26:29.673", "LastActivityDate": "2015-10-16T01:26:29.673"}, "bq_ids": {"n4140": {"so_33161003_33161103_0": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}, "so_33161003_33161401_3": {"section_id": 6173, "quality": 0.9375, "length": 15}, "so_33161003_33161401_1": {"section_id": 5986, "quality": 0.7857142857142857, "length": 44}, "so_33161003_33161103_1": {"section_id": 6064, "quality": 0.9, "length": 18}, "so_33161003_33161401_2": {"section_id": 6001, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_33161003_33161103_0": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}, "so_33161003_33161401_3": {"section_id": 5934, "quality": 0.9375, "length": 15}, "so_33161003_33161401_1": {"section_id": 5754, "quality": 0.6071428571428571, "length": 34}, "so_33161003_33161103_1": {"section_id": 5832, "quality": 0.9, "length": 18}, "so_33161003_33161401_2": {"section_id": 5769, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_33161003_33161103_0": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}, "so_33161003_33161401_3": {"section_id": 7675, "quality": 0.9375, "length": 15}, "so_33161003_33161103_1": {"section_id": 7560, "quality": 0.9, "length": 18}, "so_33161003_33161401_1": {"section_id": 7486, "quality": 0.75, "length": 42}}}, "33161401": {"ParentId": "33161003", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I believe the second case is ill-formed, if I am reading <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1213\" rel=\"nofollow\">defect report 1213</a> correctly, it says:</p>\n<blockquote>\n<p id=\"so_33161003_33161401_0\">Because the subscripting operation is defined as indirection through a\n  pointer value, the result of a subscript operator applied to an xvalue\n  array is an lvalue, not an xvalue. This could be surprising to some.</p>\n</blockquote>\n<p>and the resolution was the following changes to the draft C++ standard section 5.2.1 [expr.sub], (<em>bolded sections were added and strikethroughs were removed</em>):</p>\n<blockquote>\n<p id=\"so_33161003_33161401_1\">A postfix expression followed by an expression in square brackets is a\n  postfix expression. One of the expressions shall have the type\n  <strong>\u201carray of T\u201d or</strong> \u201cpointer to T\u201d and the other shall have unscoped enumeration or integral type. The result is <s>an lvalue</s> of type\n  \u201cT.\u201d The type \u201cT\u201d shall be a completely-defined object type.62 The\n  expression E1[E2] is identical (by definition) to *((E1)+(E2)) [Note:\n  see 5.3 [expr.unary] and 5.7 [expr.add] for details of * and + and\n  8.3.4 [dcl.array] for details of arrays. \u2014end note]<strong>, except that in the case of an array operand, the result is an lvalue if that operand\n  is an lvalue and an xvalue otherwise.</strong></p>\n</blockquote>\n<p>The result of <code>Y{}</code> is a prvalue from section <code>5.2.3</code> <em>[expr.type.conv]</em>:</p>\n<blockquote>\n<p id=\"so_33161003_33161401_2\">Similarly, a simple-type-specifier or typename-specifier followed by a\n  braced-init-list creates a temporary object of the specified type\n  direct-list-initialized (8.5.4) with the specified braced-init-list,\n  and its value is\n  <strong>that temporary object as a prvalue.</strong></p>\n</blockquote>\n<p>So the result of <code>(Y { })[0]</code> should be an xvalue and therefore ill-formed since assignment requires a modifiable lvalue on the left operand:</p>\n<blockquote>\n<p id=\"so_33161003_33161401_3\">The assignment operator (=) and the compound assignment operators all group right-to-left. All require a\n  modifiable lvalue as their left operand [...]</p>\n</blockquote>\n<p>We can find the updated wording from the defect report in the  <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf\" rel=\"nofollow\">draft C++14 standard</a>, so this change was applied after C++11 but may apply to C++11 since this was a applied via a defect report.</p>\n<p>Why section <code>5.3.1</code> <em>[expr.unary.op]</em> was not also updated is unclear to me, it seems somewhat inconsistent to say the result is an <em>lvalue</em> which it is not in all cases.</p>\n<p><b>Update</b></p>\n<p>Filed a <a href=\"https://llvm.org/bugs/show_bug.cgi?id=25357\" rel=\"nofollow\">clang bug report</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-10-30T18:21:42.603", "Id": "33161401", "Score": "8", "CreationDate": "2015-10-16T02:03:32.760", "LastActivityDate": "2015-10-30T18:21:42.603"}});