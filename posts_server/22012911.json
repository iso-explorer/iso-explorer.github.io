post_cb({"22012911": {"ViewCount": "4142", "Body": "<p>I don't understand why following code <a href=\"http://ideone.com/hkEpqD\" rel=\"nofollow noreferrer\">compiles</a> ?</p>\n<pre><code>int main()\n{\n     //int a = nullptr;  // Doesn't Compile\n     //char b = nullptr; // Doesn't Compile\n       bool c = nullptr; // Compiles\n\n       return 0;\n}\n</code></pre>\n<p>whereas the commented section doesn't.</p>\n<hr>\n<p>I've already gone through <a href=\"https://stackoverflow.com/q/1282295/1870232\">this</a> and <a href=\"https://stackoverflow.com/a/18042253/1870232\">this</a>.</p>\n<p>Both <code>bool</code> and <code>nullptr</code> are keywords, so what's unique about the other data types?</p>\n</hr>", "AcceptedAnswerId": "22012945", "Title": "Why \"bool c = nullptr ;\" compiles (C++11)?", "CreationDate": "2014-02-25T11:30:32.537", "Id": "22012911", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:33.300", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-11T18:40:26.717", "Score": "26", "OwnerUserId": "1870232", "Tags": "<c++><pointers><c++11><null-pointer>", "AnswerCount": "4"}, "22015269": {"Id": "22015269", "PostTypeId": "2", "Body": "<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#654\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#654</a> , Jason Merril argues</p>\n<blockquote>\n<p id=\"so_22012911_22015269_0\">Anything we can do with an arbitrary pointer, we ought to be able to do with nullptr_t as well. </p>\n</blockquote>\n<p>I think the following (slightly artificial) example supports that argument (although I am not totally sure if it was intended for this case)</p>\n<pre><code>template&lt;typename T, typename P&gt;\nvoid safeProcess(T pointer, P &amp;processor) {\n  bool isNonNull(pointer);\n  if(isNonNull) {\n    processor.process(pointer);\n  }\n}\n</code></pre>\n<p>Which would allow passing <code>nullptr</code> along with other pointer types compatible with whatever <code>processor.process</code> accepts.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2014-02-25T14:08:33.143", "Score": "5", "CreationDate": "2014-02-25T13:11:10.297", "ParentId": "22012911", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2014-02-25T14:08:33.143"}, "22013065": {"Id": "22013065", "PostTypeId": "2", "Body": "<blockquote>\n<h3>C++11 \u00a74.12 <em>Boolean conversions</em></h3>\n<p id=\"so_22012911_22013065_0\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type <code>bool</code>. A zero value, <strong>null pointer value</strong>, or null member pointer value is converted to <code>false</code>; any other value is converted to <code>true</code>. A prvalue of type <code>std::nullptr_t</code> can be converted to a prvalue of type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p>It's true that <code>nullptr</code> is a keyword, but it's a null pointer literal, not the same role as <code>bool</code>. Think about the boolean literals, <code>true</code> and <code>false</code> are also keywords.</p>\n", "LastActivityDate": "2014-02-25T11:36:52.740", "CommentCount": "5", "CreationDate": "2014-02-25T11:36:52.740", "ParentId": "22012911", "Score": "19", "OwnerUserId": "1009479"}, "22012945": {"Id": "22012945", "PostTypeId": "2", "Body": "<p>For the same reason as</p>\n<pre><code>if( p ) { ... }\n</code></pre>\n<p>compiles: any value of basic type converts implicitly to boolean, with <code>0</code> converting to <code>false</code> and any other value to <code>true</code>.</p>\n<p>Originally basic type values had to convert to <code>bool</code> for C compatibility. C didn't originally have a <code>bool</code> type, but any numerical expression could be used as a boolean (with the 0 == <code>false</code> convention). And now we're caught in the backward compatibility tangle. <code>nullptr</code> has to support idiomatic constructs such as <code>if(p)</code>, especially for the cases where old code's literal <code>0</code> or <code>NULL</code> is replaced with <code>nullptr</code>. E.g. code like <code>if(p)</code> can result from a macro expansion, or in template code.</p>\n<hr>\n<p><strong>Addendum</strong>: the technical <em>how</em> of why <code>nullptr</code> doesn't convert to e.g. <code>int</code>.</p>\n<p>Since <code>nullptr</code> converts implicitly to <code>bool</code>, and <code>bool</code> (unfortunately) converts implicitly to <code>int</code>, one could expect that <code>nullptr</code> should also convert to <code>int</code>. But the point of <code>nullptr</code> is that it should behave as a <em>pointer value</em>. And while pointers do convert implicitly to <code>bool</code>, they do not convert implicitly to numerical types.</p>\n<p>Arranging such a restriction for a user-defined type is however not entirely straightforward. An <code>operator bool</code> conversion will be invoked for conversion to <code>int</code>, if it's present. One C++11 solution to enfore the restriction, is to make the conversion operator a template, restricted by a <code>std::enable_if</code>, as follows:</p>\n<pre><code>#include &lt;type_traits&gt;  // std::enable_if, std::is_same\n\nstruct S\n{\n    template&lt; class Type &gt;\n    operator Type* () const { return 0; }\n\n    template&lt;\n        class Bool_type,\n        class Enabled = typename std::enable_if&lt;\n            std::is_same&lt;Bool_type, bool&gt;::value, void\n            &gt;::type\n        &gt;\n    operator Bool_type () const { return false; }\n};\n\nauto main() -&gt; int\n{\n    bool const              b   = S();      // OK.\n    double const*  const    p   = S();      // OK.\n    int const               i   = S();      // !Doesn't compile.\n}\n</code></pre>\n</hr>", "LastEditorUserId": "441899", "LastActivityDate": "2014-02-27T07:26:12.367", "Score": "39", "CreationDate": "2014-02-25T11:32:03.743", "ParentId": "22012911", "CommentCount": "11", "OwnerUserId": "464581", "LastEditDate": "2014-02-27T07:26:12.367"}, "bq_ids": {"n4140": {"so_22012911_22013065_0": {"length": 39, "quality": 1.0, "section_id": 44}}, "n3337": {"so_22012911_22013065_0": {"length": 39, "quality": 1.0, "section_id": 41}}, "n4659": {"so_22012911_22013065_0": {"length": 39, "quality": 1.0, "section_id": 45}}}, "26317954": {"Id": "26317954", "PostTypeId": "2", "Body": "<p>C++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant: nullptr. It is of type nullptr_t, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool. While the original proposal specified that an rvalue of type nullptr should not be convertible to bool, the core language working group decided that such a conversion would be desirable, for consistency with regular pointer types. The proposed wording changes were unanimously voted into the Working Paper in June 2008.[2]</p>\n<p>For backwards compatibility reasons, 0 remains a valid null pointer constant.</p>\n<pre><code>char *pc = nullptr;     // OK\nint  *pi = nullptr;     // OK\nbool   b = nullptr;     // OK. b is false.\nint    i = nullptr;     // error\n</code></pre>\n", "LastActivityDate": "2014-10-11T18:40:26.717", "CommentCount": "0", "CreationDate": "2014-10-11T18:40:26.717", "ParentId": "22012911", "Score": "0", "OwnerUserId": "1648099"}});