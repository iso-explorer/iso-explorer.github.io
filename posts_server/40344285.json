post_cb({"40345460": {"ParentId": "40344285", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Templates don't require the complete type definition immediately (think CRTP). They must <em>use</em> the type in a way that will cause the complete type definition to be required. Your <code>pwm_test</code> doesn't use the type parameter it is given except by name. So the template body never needs to be instantiated.</p>\n<p>In the second case you create an object, so naturally the template body instantiation happens.</p>\n<p>So you need to force the instantiation by providing a context where it must happen:</p>\n<pre><code>template&lt;typename Timer&gt;\nclass pwm_test\n{\n  enum { _ = sizeof(Timer) };\n};\n</code></pre>\n<p>On a related note, if you have any static assertions in a member function of a template, those won't be triggered until you add a call to the function in your code.</p>\n<hr>\n<p>To answer your other question, why does <code>static_assert</code> result in an immediate error in one case but not the other:</p>\n<p><a href=\"http://eel.is/c++draft/temp#res-8\" rel=\"nofollow\">\u00a714.6/8</a> <strong>[temp.res]</strong></p>\n<blockquote>\n<p id=\"so_40344285_40345460_0\">Knowing which names are type names allows the syntax of every template\n  to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li>...</li>\n<li>a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not\n  depend on a template parameter, or</li>\n</ul>\n</blockquote>\n<p>So when encountering <code>static_assert(false)</code> while parsing the template, the compiler can deduce that all templates instantiations will be ill-formed. In this case it chooses to issue a diagnostic immediately (note that it doesn't have to).</p>\n<p>When <code>static_assert(T::res != T::res)</code> is encountered, the compiler checks the syntax, but it cannot deduce that <code>T::res != T::res</code> is always false, that information is only available when <code>T</code> is known (after all, <code>T::res</code> can be something that overloads <code>operator!=</code> to always return true).</p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2016-10-31T23:21:04.813", "Id": "40345460", "Score": "0", "CreationDate": "2016-10-31T15:34:54.750", "LastActivityDate": "2016-10-31T23:21:04.813"}, "bq_ids": {"n4140": {"so_40344285_40345460_0": {"section_id": 175, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_40344285_40345460_0": {"section_id": 169, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_40344285_40345460_0": {"section_id": 180, "quality": 0.9230769230769231, "length": 12}}}, "40344285": {"CommentCount": "3", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "7094947", "CreationDate": "2016-10-31T14:32:17.943", "LastActivityDate": "2016-10-31T23:21:04.813", "Title": "static_assert always computes true (avr, g++)", "LastEditDate": "2016-10-31T15:24:21.200", "Id": "40344285", "Score": "0", "Body": "<p>I have some templated code for timers abstraction on my avr device. Most relevant part here is:</p>\n<pre><code>template &lt;typename T&gt;\nclass Timerx8bit\n{\n    T reg;\n\n    static_assert(T::res == TimerResolution::bit8, \"The timer template is 8bit, registers must also be 8bit\");\n}\n\n\nstruct Timer0\n{\n    constexpr static const TimerResolution res = TimerResolution::bit16;\n\n    volatile uint8_t* tccra = &amp;TCCR0A;\n    volatile uint8_t* tccrb = &amp;TCCR0B;\n    //[...]\n};\n</code></pre>\n<p>Now I feed the Timer0 to the template. The problem with that code is, that the static assert seems to evaluate always to true, although in the above situation it should fail. TimerResolution is just an enum class.</p>\n<p>The problem seems to be in the template, if I put \"TimerResolution::bit8 != TimerResolution::bit8\" as the condition, compilation fails as expected, but \"T::res != T::res\" compiles without any problems... what am I missing here?</p>\n<p><strong>EDIT:</strong>\nWhile preparing full example of code I found the problem, although I still don't quite understand why it behaves that way. First, the code:</p>\n<pre><code>enum class TimerResolution_test\n{\n    bit8,\n    bit16\n};\n\nstruct Timer0_test\n{\n    constexpr static const TimerResolution_test res = TimerResolution_test::bit8;\n};\n\ntemplate &lt;typename T&gt;\nclass Timerx8bit_test\n{\npublic:\n    constexpr static const TimerResolution_test res = TimerResolution_test::bit8;\n\nprivate:\n    T reg;\n\n    static_assert(T::res != T::res, \"The timer template is 8bit, registers must also be 8bit\");\n};\n\ntemplate&lt;typename Timer&gt;\nclass pwm_test\n{\n\n};\n</code></pre>\n<p>Instantiation:</p>\n<pre><code>pwm_test&lt;Timerx8bit_test&lt;Timer0_test&gt;&gt; testTimer; // Compiles\nTimerx8bit_test&lt;Timer0_test&gt; testTimer2; // Fails\n</code></pre>\n<p>The second instantiation fails with the static_assert as above. If I put 'false' instead of the templated condition it fails in both cases... why is that? Shouldn't it fail in both cases with the original templated condition?</p>\n", "Tags": "<c++><avr>", "OwnerUserId": "7094947", "AnswerCount": "1"}});