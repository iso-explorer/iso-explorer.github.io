post_cb({"bq_ids": {"n4140": {"so_31842836_31843306_2": {"length": 178, "quality": 0.7639484978540773, "section_id": 7223}}, "n3337": {"so_31842836_31843306_2": {"length": 178, "quality": 0.7639484978540773, "section_id": 6967}}}, "31842977": {"LastActivityDate": "2015-08-06T04:11:49.280", "CommentCount": "1", "Body": "<p>Many computers have alignment requirements, so (for example) to read a 2-byte value, the address at which it's located must be a multiple of 2 (and likewise, a 4-byte value must be located at an address that's a multiple of 4, and so on). In fact, this alignment requirement is common enough that it's frequently referred to as \"natural alignment\".</p>\n<p>Likewise, some types (e.g., floating point types) impose requirements on the bit sequence that can be read as that type, so if you try to take some arbitrary data and treat it as a double, you might trigger something like a floating point exception.</p>\n<p>If you want to do this badly enough, you can use a cast to turn the pointer into the target type (but the results, if any, aren't usually portable).</p>\n<p>You are guaranteed that you can convert a pointer to any other type of object to a pointer to unsigned char, and use that to read the bytes that represent the pointee object.</p>\n<p>Also, if you primarily want an opaque pointer, without type information attached, you can assign a pointer to some other type to a <code>void *</code>.</p>\n<p>Finally: no, not all pointers are actually the same. Pointers to different types can be different sizes (e.g., on the early Cray compilers, a <code>char *</code> was substantially different from an <code>int *</code>).</p>\n", "CreationDate": "2015-08-05T21:16:17.607", "LastEditDate": "2015-08-06T04:11:49.280", "ParentId": "31842836", "Id": "31842977", "LastEditorUserId": "179910", "PostTypeId": "2", "Score": "6", "OwnerUserId": "179910"}, "31843306": {"CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_31842836_31843306_0\">In case of <strong>pointers</strong>, we know that their size <strong>is always same</strong> irrespective of <strong>data type of the variable</strong> it is pointing.</p>\n</blockquote>\n<p>No, we do <strong>not</strong> know that.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">Chapter and verse for C</a></p>\n<blockquote id=\"so_31842836_31843306_1\">\n<strong>6.2.5 Types</strong><br>\n...<br>\n28 A pointer to <code>void</code> shall have the same representation and alignment requirements as a\npointer to a character type.<sup>48)</sup> Similarly, pointers to qualified or unqualified versions of\ncompatible types shall have the same representation and alignment requirements. All\npointers to structure types shall have the same representation and alignment requirements\nas each other. All pointers to union types shall have the same representation and\nalignment requirements as each other. <strong><em>Pointers to other types need not have the same\nrepresentation or alignment requirements.</em></strong>\n<hr>\n<sup>48) The same representation and alignment requirements are meant to imply interchangeability as\narguments to functions, return values from functions, and members of unions.</sup>\n</hr></br></br></blockquote>\n<p>Emphasis added.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">Chapter and verse for C++</a></p>\n<blockquote id=\"so_31842836_31843306_2\">\n<strong>3.9.2 Compound types</strong><br>\n...<br>\n3 The type of a pointer to <code>void</code> or a pointer to an object type is called an <em>object pointer type</em>. [ <em>Note:</em> A pointer\nto void does not have a pointer-to-object type, however, because <code>void</code> is not an object type. <em>\u2014 end note</em> ]\nThe type of a pointer that can designate a function is called a <em>function pointer type</em>. A pointer to objects\nof type <code>T</code> is referred to as a \u201cpointer to <code>T</code>.\u201d [<em>Example:</em> a pointer to an object of type <code>int</code> is referred to as\n\u201cpointer to <code>int</code> \u201d and a pointer to an object of class <code>X</code> is called a \u201cpointer to <code>X</code>.\u201d <em>\u2014 end example</em> ] Except\nfor pointers to static members, text referring to \u201cpointers\u201d does not apply to pointers to members. Pointers\nto incomplete types are allowed although there are restrictions on what can be done with them (3.11).\nA valid value of an object pointer type represents either the address of a byte in memory (1.7) or a null\npointer (4.10). If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the\naddress <code>A</code> is said to point to that object, regardless of how the value was obtained. [ <em>Note:</em> For instance,\nthe address one past the end of an array (5.7) would be considered to point to an unrelated object of the\narray\u2019s element type that might be located at that address. There are further restrictions on pointers to\nobjects with dynamic storage duration; see 3.7.4.3. <em>\u2014 end note</em> ] The value representation of pointer types\nis implementation-defined. <strong><em>Pointers to layout-compatible types shall have the same value representation and\nalignment requirements</em></strong> (3.11). [ <em>Note:</em> Pointers to over-aligned types (3.11) have no special representation,\nbut their range of valid values is restricted by the extended alignment requirement. This International\nStandard specifies only two ways of obtaining such a pointer: taking the address of a valid object with\nan over-aligned type, and using one of the runtime pointer alignment functions. An implementation may\nprovide other means of obtaining a valid pointer value for an over-aligned type. <em>\u2014 end note</em> ]<br><br>\n4 A pointer to <em>cv</em>-qualified (3.9.3) or <em>cv</em>-unqualified <code>void</code> can be used to point to objects of unknown type.\nSuch a pointer shall be able to hold any object pointer. An object of type <em>cv</em> <code>void*</code> shall have the same\nrepresentation and alignment requirements as <em>cv</em> <code>char*</code>.\n</br></br></br></br></blockquote>\n<p>Emphasis added.  It is <em>entirely</em> possible to have different sizes and representations for different pointer types.  There is no reason to expect a pointer to <code>int</code> to have the same size and representation as a pointer to <code>double</code>, or a pointer to a <code>struct</code> type, or a pointer to a function type.  It's true for commodity platforms like x86, but not all the world runs on x86.  </p>\n<p>This is why you can't assign pointer values of one type to pointer values of another type without an explicit cast (except for converting between <code>void *</code> and other pointer types in C), since a representation change <em>may</em> be required.</p>\n<p>Secondly, pointer arithmetic depends on the size of the pointed-to type.  Assume you have pointers to a 32-bit <code>int</code> and a 64-bit <code>double</code>:</p>\n<pre><code>int *ip;\ndouble *dp;\n</code></pre>\n<p>The expression <code>ip + 1</code> will return the address of the next integer object (current address plus 4), while the expression <code>dp + 1</code> will return the address of the next double object (current address plus 8).  </p>\n<p>If I assign the address of a <code>double</code> to a pointer to <code>int</code>, incrementing that int pointer won't take me to the next <code>double</code> object.  </p>\n", "CreationDate": "2015-08-05T21:39:32.943", "ParentId": "31842836", "Id": "31843306", "LastActivityDate": "2015-08-05T21:39:32.943", "PostTypeId": "2", "Score": "3", "OwnerUserId": "134554"}, "31842836": {"CreationDate": "2015-08-05T21:07:02.290", "ViewCount": "136", "Id": "31842836", "Score": "-2", "Title": "Why can't I assign the address of a variable of one type(say double) to a pointer of int type?", "LastEditorUserId": "129570", "CommentCount": "8", "Body": "<p>In case of pointers, we know that their size is always same irrespective of data type of the variable it is pointing.</p>\n<p>Data type is needed when dereferencing the pointer so it knows how much data it should read. So why cant i assign address of variable of double type to a pointer of int type?</p>\n<p>why cant it happen like dereferencing a int pointer reads next 4 bytes from variable of double type and print its value?</p>\n", "Tags": "<c++><c><pointers>", "LastEditDate": "2015-08-05T21:13:42.070", "LastActivityDate": "2015-08-06T04:11:49.280", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "5173150"}});