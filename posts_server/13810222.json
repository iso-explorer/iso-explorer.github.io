post_cb({"bq_ids": {"n4140": {"so_13810222_13810408_18": {"length": 6, "quality": 0.5454545454545454, "section_id": 45}, "so_13810222_13810408_16": {"length": 6, "quality": 0.5454545454545454, "section_id": 5922}, "so_13810222_13810408_2": {"length": 81, "quality": 0.9, "section_id": 5921}, "so_13810222_13810408_4": {"length": 46, "quality": 0.6571428571428571, "section_id": 5923}, "so_13810222_13810408_3": {"length": 41, "quality": 0.9111111111111111, "section_id": 5922}, "so_13810222_13810408_0": {"length": 18, "quality": 0.72, "section_id": 5439}, "so_13810222_13810408_5": {"length": 45, "quality": 0.9782608695652174, "section_id": 5924}}, "n3337": {"so_13810222_13810408_18": {"length": 6, "quality": 0.5454545454545454, "section_id": 42}, "so_13810222_13810408_3": {"length": 41, "quality": 0.9111111111111111, "section_id": 5694}, "so_13810222_13810408_2": {"length": 81, "quality": 0.9, "section_id": 5693}, "so_13810222_13810408_4": {"length": 62, "quality": 0.8857142857142857, "section_id": 5695}, "so_13810222_13810408_0": {"length": 21, "quality": 0.84, "section_id": 5234}, "so_13810222_13810408_5": {"length": 45, "quality": 0.9782608695652174, "section_id": 5696}, "so_13810222_13810408_16": {"length": 6, "quality": 0.5454545454545454, "section_id": 5694}}, "n4659": {"so_13810222_13810408_18": {"length": 6, "quality": 0.5454545454545454, "section_id": 46}, "so_13810222_13810408_3": {"length": 40, "quality": 0.8888888888888888, "section_id": 7396}, "so_13810222_13810408_2": {"length": 81, "quality": 0.9, "section_id": 7395}, "so_13810222_13810408_4": {"length": 46, "quality": 0.6571428571428571, "section_id": 7397}, "so_13810222_13810408_0": {"length": 17, "quality": 0.68, "section_id": 6866}, "so_13810222_13810408_5": {"length": 45, "quality": 0.9782608695652174, "section_id": 7398}, "so_13810222_13810408_16": {"length": 6, "quality": 0.5454545454545454, "section_id": 7396}}}, "13810222": {"ViewCount": "493", "Body": "<p>Suppose the following c++ code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef struct \n{\n       int a: 5;\n       int b: 4;\n  int c: 1;\n  int d: 22;\n\n} example;\n\nint main()\n{\nexample blah;\n\nblah.a = -5; // 11011\nblah.b = -3; // 1101\n\nint result = blah.a &lt;&lt; 4 | blah.b;\n\ncout &lt;&lt; \"Result = \" &lt;&lt; result &lt;&lt; endl; // equals 445 , but I am interested in this having a value of -67 \n\nreturn 0;\n}\n</code></pre>\n<p>I am interested in having the variable result be of type int where the 9th bit is the most significant bit. I would like this to be the case so that result = -67 instead of 445. How is this done? Thanks.</p>\n", "AcceptedAnswerId": "13810408", "Title": "How to merge two signed bit variables into one signed bit variable?", "CreationDate": "2012-12-10T22:16:28.950", "Id": "13810222", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-12-10T23:13:49.633", "Score": "0", "OwnerUserId": "1456962", "Tags": "<c++><bit-manipulation><bits>", "AnswerCount": "1"}, "13810408": {"Id": "13810408", "PostTypeId": "2", "Body": "<p>See <a href=\"https://stackoverflow.com/a/13755737/15168\">Sign Extending an <code>int</code> in C</a> for a closely related question (but not a duplicate).</p>\n<p>You need to be aware that almost everything about bit fields is 'implementation defined'.  In particular, it is not clear that you can assign negative numbers to a 'plain <code>int</code>' bit-field; you have to know whether your implementation uses 'plain <code>int</code> is <code>signed</code>' or 'plain <code>int</code> is <code>unsigned</code>'.  Which is the 9<sup>th</sup> bit gets tricky too; are you counting from 0 or 1, and which end of the set of bit-fields is at bit 0 and which at bit 31 (counting least significant bit (LSB) as bit 0 and most significant bit (MSB) as bit 31 of a 32-bit quantity).  Indeed, the size of your structure need not be 32 bits; the compiler might have different rules for the layout.</p>\n<p>With all those caveats out of the way, you have a 9-bit value formed from <code>(blah.a &lt;&lt; 4) | blah.b</code>, and you want that sign-extended as if it was a 9-bit 2's complement number being promoted to (32-bit) <code>int</code>.</p>\n<p>The function in the cross-referenced answer could do the job:</p>\n<pre><code>#include &lt;assert.h&gt;\n#include &lt;limits.h&gt;\n\nextern int getFieldSignExtended(int value, int hi, int lo);\n\nenum { INT_BITS = CHAR_BIT * sizeof(int) };\nint getFieldSignExtended(int value, int hi, int lo)\n{\n    assert(lo &gt;= 0);\n    assert(hi &gt; lo);\n    assert(hi &lt; INT_BITS - 1);\n    int bits = (value &gt;&gt; lo) &amp; ((1 &lt;&lt; (hi - lo + 1)) - 1);\n    if (bits &amp; (1 &lt;&lt; (hi - lo)))\n        return(bits | (~0 &lt;&lt; (hi - lo)));\n    else\n        return(bits);\n}\n</code></pre>\n<p>Invoke it as:</p>\n<pre><code>int result = getFieldSignExtended((blah.a &lt;&lt; 4) | blah.b), 8, 0);\n</code></pre>\n<p>If you want to hard-wire the numbers, you can write:</p>\n<pre><code>int x = (blah.a &lt;&lt; 4) | blah.b;\n\nint result = (x &amp; (1 &lt;&lt; 8)) ? (x | (~0 &lt;&lt; 8)) : x;\n</code></pre>\n<p>Note I'm assuming the 9<sup>th</sup> bit is bit 8 of a value with bits 0..8 in it.  Adjust if you have some other interpretation in mind.</p>\n<hr>\n<p>Working code</p>\n<p>Compiled with <code>g++ (GCC) 4.1.2 20080704 (Red Hat 4.1.2-44)</code> from a RHEL 5 x86/64 machine.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef struct \n{\n    int a: 5;\n    int b: 4;\n    int c: 1;\n    int d: 22;\n} example;\n\nint main()\n{\n    example blah;\n\n    blah.a = -5; // 11011\n    blah.b = -3; // 1101\n\n    int result = blah.a &lt;&lt; 4 | blah.b;\n\n    cout &lt;&lt; \"Result = \" &lt;&lt; result &lt;&lt; endl;\n\n    int x = (blah.a &lt;&lt; 4) | blah.b;\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl;\n\n    int result2 = (x &amp; (1 &lt;&lt; 8)) ? (x | (~0 &lt;&lt; 8)) : x;\n    cout &lt;&lt; \"Result2 = \" &lt;&lt; result2 &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Sample output:</p>\n<pre><code>Result = 445\nx = 445\nResult2 = -67\n</code></pre>\n<hr>\n<h2>ISO/IEC 14882:2011 \u2014 C++ Standard</h2>\n<h3>\u00a77.1.6.2 Simple type specifiers</h3>\n<blockquote>\n<p id=\"so_13810222_13810408_0\">\u00b63 ... [ Note: It is implementation-defined whether objects of <code>char</code> type and certain bit-fields (9.6) are\n  represented as signed or unsigned quantities. The <code>signed</code> specifier forces char objects and bit-fields to be\n  signed; it is redundant in other contexts. \u2014end note ]</p>\n</blockquote>\n<h3>\u00a79.6 Bit-fields [class.bit]</h3>\n<blockquote>\n<p id=\"so_13810222_13810408_1\">\u00b61 A member-declarator of the form</p>\n<pre><code> identifier&lt;sub&gt;opt&lt;/sub&gt; attribute-specifier-seq&lt;sub&gt;opt&lt;/sub&gt;: constant-expression\n</code></pre>\n<p id=\"so_13810222_13810408_2\">specifies a bit-field; its length is set off from the bit-field name by a colon. The optional attribute-specifier-seq\n  appertains to the entity being declared. The bit-field attribute is not part of the type of the class\n  member. The constant-expression shall be an integral constant expression with a value greater than or equal\n  to zero. The value of the integral constant expression may be larger than the number of bits in the object\n  representation (3.9) of the bit-field\u2019s type; in such cases the extra bits are used as padding bits and do not\n  participate in the value representation (3.9) of the bit-field. Allocation of bit-fields within a class object is\n  implementation-defined. Alignment of bit-fields is implementation-defined. Bit-fields are packed into some\n  addressable allocation unit. [ Note: Bit-fields straddle allocation units on some machines and not on others.\n  Bit-fields are assigned right-to-left on some machines, left-to-right on others. \u2014end note ]</p>\n<p id=\"so_13810222_13810408_3\">\u00b62 A declaration for a bit-field that omits the identifier declares an unnamed bit-field. Unnamed bit-fields\n  are not members and cannot be initialized. [ Note: An unnamed bit-field is useful for padding to conform\n  to externally-imposed layouts. \u2014end note ] As a special case, an unnamed bit-field with a width of zero\n  specifies alignment of the next bit-field at an allocation unit boundary. Only when declaring an unnamed\n  bit-field may the value of the constant-expression be equal to zero.</p>\n<p id=\"so_13810222_13810408_4\">\u00b63 A bit-field shall not be a static member. A bit-field shall have integral or enumeration type (3.9.1). It is\n  implementation-defined whether a plain (neither explicitly signed nor unsigned) char, short, int, long,\n  or long long bit-field is signed or unsigned. A bool value can successfully be stored in a bit-field of any\n  nonzero size. The address-of operator &amp; shall not be applied to a bit-field, so there are no pointers to bitfields.\n  A non-const reference shall not be bound to a bit-field (8.5.3). [ Note: If the initializer for a reference\n  of type const T&amp; is an lvalue that refers to a bit-field, the reference is bound to a temporary initialized to\n  hold the value of the bit-field; the reference is not bound to the bit-field directly. See 8.5.3. \u2014end note ]</p>\n<p id=\"so_13810222_13810408_5\">\u00b64 If the value true or false is stored into a bit-field of type bool of any size (including a one bit bit-field),\n  the original bool value and the value of the bit-field shall compare equal. If the value of an enumerator is\n  stored into a bit-field of the same enumeration type and the number of bits in the bit-field is large enough\n  to hold all the values of that enumeration type (7.2), the original enumerator value and the value of the\n  bit-field shall compare equal. [ Example:</p>\n</blockquote>\n<pre><code>enum BOOL { FALSE=0, TRUE=1 };\nstruct A {\n    BOOL b:1;\n};\nA a;\nvoid f() {\n    a.b = TRUE;\n    if (a.b == TRUE) // yields true\n    { /* ... */ }\n}\n</code></pre>\n<p>\u2014end example ]</p>\n<hr>\n<blockquote id=\"so_13810222_13810408_6\">\n<h2>ISO/IEC 9899:2011 \u2014 C2011 Standard</h2>\n</blockquote>\n<p>The C standard has essentially the same effect, but the information is presented somewhat differently.</p>\n<blockquote>\n<h3>6.7.2.1 Structure and union specifiers</h3>\n<p id=\"so_13810222_13810408_7\">\u00b64 The expression that specifies the width of a bit-field shall be an integer constant\n  expression with a nonnegative value that does not exceed the width of an object of the\n  type that would be specified were the colon and expression omitted.<sup>122)</sup> If the value is\n  zero, the declaration shall have no declarator.</p>\n<p id=\"so_13810222_13810408_8\">\u00b65 A bit-field shall have a type that is a qualified or unqualified version of <code>_Bool</code>, <code>signed\n  int</code>, <code>unsigned int</code>, or some other implementation-defined type. It is\n  implementation-defined whether atomic types are permitted.</p>\n<p id=\"so_13810222_13810408_9\">\u00b69 ... In addition, a member may be declared to consist of a\n  specified number of bits (including a sign bit, if any). Such a member is called a\n  bit-field;<sup>124)</sup> its width is preceded by a colon.</p>\n<p id=\"so_13810222_13810408_10\">\u00b610 A bit-field is interpreted as having a signed or unsigned integer type consisting of the\n  specified number of bits.<sup>125)</sup> If the value 0 or 1 is stored into a nonzero-width bit-field of\n  type _Bool, the value of the bit-field shall compare equal to the value stored; a _Bool\n  bit-field has the semantics of a _Bool.</p>\n<p id=\"so_13810222_13810408_11\">\u00b611 An implementation may allocate any addressable storage unit large enough to hold a bitfield.\n  If enough space remains, a bit-field that immediately follows another bit-field in a\n  structure shall be packed into adjacent bits of the same unit. If insufficient space remains,\n  whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is\n  implementation-defined. The order of allocation of bit-fields within a unit (high-order to\n  low-order or low-order to high-order) is implementation-defined. The alignment of the\n  addressable storage unit is unspecified.</p>\n<p id=\"so_13810222_13810408_12\">\u00b612 A bit-field declaration with no declarator, but only a colon and a width, indicates an\n  unnamed bit-field.<sup>126)</sup> As a special case, a bit-field structure member with a width of 0\n  indicates that no further bit-field is to be packed into the unit in which the previous bitfield,\n  if any, was placed.</p>\n<p id=\"so_13810222_13810408_13\"><sup>122)</sup> While the number of bits in a <code>_Bool</code> object is at least <code>CHAR_BIT</code>, the width (number of sign and\n  value bits) of a _Bool may be just 1 bit.</p>\n<p id=\"so_13810222_13810408_14\"><sup>124)</sup> The unary &amp; (address-of) operator cannot be applied to a bit-field object; thus, there are no pointers to\n  or arrays of bit-field objects.</p>\n<p id=\"so_13810222_13810408_15\"><sup>125)</sup> As specified in 6.7.2 above, if the actual type specifier used is int or a typedef-name defined as int,\n  then it is implementation-defined whether the bit-field is signed or unsigned.</p>\n<p id=\"so_13810222_13810408_16\"><sup>126)</sup> An unnamed bit-field structure member is useful for padding to conform to externally imposed\n  layouts.</p>\n</blockquote>\n<p>Annex J of the standard defines Portability Issues, and \u00a7J.3 defines Implementation-defined Behaviour.  In part, it says:</p>\n<blockquote>\n<h3>J.3.9 Structures, unions, enumerations, and bit-fields</h3>\n<p id=\"so_13810222_13810408_17\">\u00b61 \u2014 Whether a \u2018\u2018plain\u2019\u2019 int bit-field is treated as a signed int bit-field or as an\n  unsigned int bit-field (6.7.2, 6.7.2.1).</p>\n<p id=\"so_13810222_13810408_18\">\u2014 Allowable bit-field types other than _Bool, signed int, and unsigned int\n  (6.7.2.1).</p>\n<p id=\"so_13810222_13810408_19\">\u2014 Whether atomic types are permitted for bit-fields (6.7.2.1).</p>\n<p id=\"so_13810222_13810408_20\">\u2014 Whether a bit-field can straddle a storage-unit boundary (6.7.2.1).</p>\n<p id=\"so_13810222_13810408_21\">\u2014 The order of allocation of bit-fields within a unit (6.7.2.1).</p>\n</blockquote>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-10T23:13:49.633", "Score": "1", "CreationDate": "2012-12-10T22:31:08.453", "ParentId": "13810222", "CommentCount": "0", "OwnerUserId": "15168", "LastEditDate": "2017-05-23T11:48:59.023"}});