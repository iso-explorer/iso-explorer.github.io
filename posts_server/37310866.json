post_cb({"37310866": {"CommentCount": "0", "ViewCount": "288", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-05-18T22:05:34.417", "LastActivityDate": "2016-05-18T23:45:23.600", "Title": "Operator cast, GCC and clang: which compiler is right?", "AcceptedAnswerId": "37311097", "LastEditDate": "2016-05-18T23:45:23.600", "Id": "37310866", "Score": "15", "Body": "<p>Consider the following code:</p>\n<pre><code>struct S {\n    using T = int;\n    operator T() { return 42; }\n};\n\nint main() {\n    S s;\n    S::T t = s;\n    // Is the following line correct?\n    t = s.operator T();\n}\n</code></pre>\n<p>It compiles with GCC (4.9/5.1/6.1), but it fails to compile with clang (3.8/3.7).<br>\nThe error returned is:</br></p>\n<blockquote>\n<p id=\"so_37310866_37310866_0\">error: unknown type name 'T'; did you mean 'S::T'?</p>\n</blockquote>\n<p>Which compiler is right in this case and why?</p>\n<p><strong>Note</strong></p>\n<p>Solving it is a matter of qualifying <code>T</code>:</p>\n<pre><code>t = s.operator S::T();\n</code></pre>\n<p>The question is not about how to make it work.</p>\n", "Tags": "<c++><c++11><gcc><clang><language-lawyer>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37310866_37311097_0": {"section_id": 7132, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_37310866_37311097_0": {"section_id": 6876, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_37310866_37311097_0": {"section_id": 8633, "quality": 0.9615384615384616, "length": 25}}}, "37311097": {"ParentId": "37310866", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2016-05-18T22:26:25.743", "Score": "15", "LastEditorUserId": "2069064", "LastEditDate": "2016-05-18T22:48:35.963", "Id": "37311097", "OwnerUserId": "2069064", "Body": "<p>I believe this is clang bug (submitted as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=27807\">#27807</a>)</p>\n<p>From <a href=\"http://eel.is/c++draft/basic.lookup.classref#7\">[basic.lookup.classref]</a>:</p>\n<blockquote>\n<p id=\"so_37310866_37311097_0\">If the <em>id-expression</em> is a <em>conversion-function-id</em>, its <em>conversion-type-id</em> is first looked up in the class of the\n  object expression and the name, if found, is used. Otherwise it is looked up in the context of the entire\n  <em>postfix-expression</em>. In each of these lookups, only names that denote types or templates whose specializations\n  are types are considered. <em>[ Example:</em></p>\n<pre><code>struct A { };\nnamespace N {\n    struct A {\n        void g() { }\n        template &lt;class T&gt; operator T();\n    };\n}\n\nint main() {\n    N::A a;\n    a.operator A(); // calls N::A::operator N::A\n}\n</code></pre>\n<p id=\"so_37310866_37311097_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>In <code>t = s.operator T();</code>, <code>T</code> is first looked up in the class of <code>S</code>, which should find your typedef and hence end up calling <code>operator int()</code>. </p>\n", "LastActivityDate": "2016-05-18T22:48:35.963"}});