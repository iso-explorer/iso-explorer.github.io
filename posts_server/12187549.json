post_cb({"12187549": {"ViewCount": "4154", "Body": "<p>When I compile the following snippet with <code>g++</code></p>\n<pre><code>template&lt;class T&gt;\nclass A\n{};\n\ntemplate&lt;class T&gt;\nclass B\n{\n    public:\n        typedef A&lt;T&gt; A;\n};\n</code></pre>\n<p>the compiler tells me</p>\n<pre><code>error: declaration of \u2018typedef class A&lt;T&gt; B&lt;T&gt;::A\u2019\nerror: changes meaning of \u2018A\u2019 from \u2018class A&lt;T&gt;\u2019\n</code></pre>\n<p>On the other hand, if I change the <code>typedef</code> to</p>\n<pre><code>typedef ::A&lt;T&gt; A;\n</code></pre>\n<p>everything compiles fine with <code>g++</code>. Clang++ 3.1 doesn't care either way.</p>\n<p>Why is this happening? And is the second behavior standard?</p>\n", "AcceptedAnswerId": "12187709", "Title": "typedef changes meaning", "CreationDate": "2012-08-29T22:47:58.127", "Id": "12187549", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-07-28T15:40:11.863", "LastEditorUserId": "106797", "LastActivityDate": "2016-07-28T15:40:49.113", "Score": "18", "OwnerUserId": "44738", "Tags": "<c++><typedef>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12187549_12187709_0": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_12187549_12187709_0": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_12187549_12187709_0": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "21465005": {"Id": "21465005", "PostTypeId": "2", "Body": "<p>I will add to Jesse's answer about the seemingly peculiar behavior of GCC in compiling:</p>\n<pre><code>typedef A&lt;T&gt; A;\n</code></pre>\n<p>vs</p>\n<pre><code>typedef ::A&lt;T&gt; A;\n</code></pre>\n<p>This also applies to using statements as well of the form:</p>\n<pre><code>using A =   A&lt;T&gt;;\nusing A = ::A&lt;T&gt;;\n</code></pre>\n<p>What seems to be happening within GCC, is that during the compilation of the typedef/using statement declaring B::A, that the symbol B::A becomes a valid candidate <strong>within the using statement itself</strong>. I.e. when saying <code>using A = A&lt;T&gt;;</code> or <code>typedef A&lt;T&gt; A;</code> GCC considers both <code>::A</code> and <code>B::A</code> valid candidates for <code>A&lt;T&gt;</code>.</p>\n<p>This seems odd behavior because as your question implies, you don't expect the new alias A to become a valid candidate within the typedef itself, but as Jesse's answer also says, anything declared within a class becomes visible to everything else inside the class - and in this case apparently even the declaration itself. This type of behavior may be implemented this way to permit recursive type definitions.</p>\n<p>The solution as you found is to specify for GCC precisely which A you're referring to within the typedef and then it no longer complains.</p>\n", "LastEditorUserId": "106797", "LastActivityDate": "2016-07-28T15:40:49.113", "Score": "1", "CreationDate": "2014-01-30T18:47:39.327", "ParentId": "12187549", "CommentCount": "0", "OwnerUserId": "2033241", "LastEditDate": "2016-07-28T15:40:49.113"}, "12187709": {"Id": "12187709", "PostTypeId": "2", "Body": "<p>g++ is correct and conforming to the standard. From [3.3.7/1]:</p>\n<blockquote>\n<p id=\"so_12187549_12187709_0\">A name N used in a class S shall refer to the same declaration in its\n  context and when re-evaluated in the completed scope of S. No\n  diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p>Before the typedef, <code>A</code> referred to the <code>::A</code>, however by using the typedef, you now make <code>A</code> refer to the typedef which is prohibited. However, since <code>no diagnostic is required</code>, clang is also standard conforming.</p>\n<p><a href=\"https://stackoverflow.com/questions/12187549/typedef-changes-meaning/12187709#comment16321921_12187709\">jogojapan's comment</a> explains the reason for this rule. \nTake the following change to your code:</p>\n<pre><code>template&lt;class T&gt;\nclass A\n{};\n\ntemplate&lt;class T&gt;\nclass B\n{\n    public:\n        A a; // &lt;-- What \"A\" is this referring to?\n        typedef     A&lt;T&gt;            A;\n};\n</code></pre>\n<p>Because of how class scope works, <code>A a;</code> becomes ambiguous.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-30T04:39:48.253", "Score": "10", "CreationDate": "2012-08-29T23:07:21.813", "ParentId": "12187549", "CommentCount": "14", "OwnerUserId": "906773", "LastEditDate": "2017-05-23T10:30:18.597"}});