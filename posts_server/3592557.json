post_cb({"3621405": {"Id": "3621405", "PostTypeId": "2", "Body": "<p>I think the issue could perhaps best be stated, as \"If a later piece of code does not depend on an earlier piece of code, and the earlier piece of code has no side-effects on any other part of the system, the compiler's output may execute the later piece of code before, after, or intermixed with, the execution of the former, even if the former contains loops, <i>without regard for when or whether the former code would actually complete</i>.  For example, the compiler could rewrite:</p>\n<pre>\nvoid testfermat(int n)\n{\n  int a=1,b=1,c=1;\n  while(pow(a,n)+pow(b,n) != pow(c,n))\n  {\n    if (b &gt; a) a++; else if (c &gt; b) {a=1; b++}; else {a=1; b=1; c++};\n  }\n  printf(\"The result is \");\n  printf(\"%d/%d/%d\", a,b,c);\n}\n</pre>\n<p>as</p>\n<pre>\nvoid testfermat(int n)\n{\n  if (fork_is_first_thread())\n  {\n    int a=1,b=1,c=1;\n    while(pow(a,n)+pow(b,n) != pow(c,n))\n    {\n      if (b &gt; a) a++; else if (c &gt; b) {a=1; b++}; else {a=1; b=1; c++};\n    }\n    signal_other_thread_and_die();\n  }\n  else // Second thread\n  {\n    printf(\"The result is \");\n    wait_for_other_thread();\n  }\n  printf(\"%d/%d/%d\", a,b,c);\n}\n</pre>\n<p>Generally not unreasonable, though I might worry that:</p>\n<pre>\n  int total=0;\n  for (i=0; num_reps &gt; i; i++)\n  {\n    update_progress_bar(i);\n    total+=do_something_slow_with_no_side_effects(i);\n  }\n  show_result(total);\n</pre>\n<p>would become</p>\n<pre>\n  int total=0;\n  if (fork_is_first_thread())\n  {\n    for (i=0; num_reps &gt; i; i++)\n      total+=do_something_slow_with_no_side_effects(i);\n    signal_other_thread_and_die();\n  }\n  else\n  {\n    for (i=0; num_reps &gt; i; i++)\n      update_progress_bar(i);\n    wait_for_other_thread();\n  }\n  show_result(total);\n</pre>\n<p>By having one CPU handle the calculations and another handle the progress bar updates, the rewrite would improve efficiency.  Unfortunately, it would make the progress bar updates rather less useful than they should be.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2010-09-03T15:18:42.897", "Score": "1", "CreationDate": "2010-09-01T19:20:38.357", "ParentId": "3592557", "CommentCount": "3", "LastEditDate": "2010-09-03T15:18:42.897", "OwnerUserId": "363751"}, "3592656": {"Id": "3592656", "PostTypeId": "2", "Body": "<p>To me, the relevant justification is:</p>\n<blockquote>\n<p id=\"so_3592557_3592656_0\">This is intended to allow compiler transfor- mations, such as removal of empty loops, even when termination cannot be proven.</p>\n</blockquote>\n<p>Presumably, this is because proving termination mechanically is <em>difficult</em>, and the inability to prove termination hampers compilers which could otherwise make useful transformations, such as moving nondependent operations from before the loop to after or vice versa, performing post-loop operations in one thread while the loop executes in another, and so on. Without these transformations, a loop might block all other threads while they wait for the one thread to finish said loop. (I use \"thread\" loosely to mean any form of parallel processing, including separate VLIW instruction streams.)</p>\n<p>EDIT: Dumb example:</p>\n<pre><code>while (complicated_condition()) {\n    x = complicated_but_externally_invisible_operation(x);\n}\ncomplex_io_operation();\ncout &lt;&lt; \"Results:\" &lt;&lt; endl;\ncout &lt;&lt; x &lt;&lt; endl;\n</code></pre>\n<p>Here, it would be faster for one thread to do the <code>complex_io_operation</code> while the other is doing all the complex calculations in the loop. But without the clause you have quoted, the compiler has to prove two things before it can make the optimisation: 1) that <code>complex_io_operation()</code> doesn't depend on the results of the loop, and 2) <em>that the loop will terminate</em>. Proving 1) is pretty easy, proving 2) is the halting problem. With the clause, it may assume the loop terminates and get a parallelisation win.</p>\n<p>I also imagine that the designers considered that the cases where infinite loops occur in production code are very rare and are usually things like event-driven loops which access I/O in some manner. As a result, they have pessimised the rare case (infinite loops) in favour of optimising the more common case (noninfinite, but difficult to mechanically prove noninfinite, loops).</p>\n<p>It does, however, mean that infinite loops used in learning examples will suffer as a result, and will raise gotchas in beginner code. I can't say this is entirely a good thing.</p>\n<p>EDIT: with respect to the insightful article you now link, I would say that \"the compiler may assume X about the program\" is logically equivalent to \"if the program doesn't satisfy X, the behaviour is undefined\". We can show this as follows: suppose there exists a program which does not satisfy property X. Where would the behaviour of this program be defined? The Standard only defines behaviour assuming property X is true. Although the Standard does not explicitly declare the behaviour undefined, it has declared it undefined by omission.</p>\n<p>Consider a similar argument: \"the compiler may assume a variable x is only assigned to at most once between sequence points\" is equivalent to \"assigning to x more than once between sequence points is undefined\".</p>\n", "LastEditorUserId": "276952", "LastActivityDate": "2010-08-28T22:40:28.890", "Score": "46", "CreationDate": "2010-08-28T22:01:26.160", "ParentId": "3592557", "CommentCount": "18", "LastEditDate": "2010-08-28T22:40:28.890", "OwnerUserId": "276952"}, "3593551": {"Id": "3593551", "PostTypeId": "2", "Body": "<p>I think the correct interpretation is the one from your edit: empty infinite loops are undefined behavior. </p>\n<p>I wouldn't say it's particularly intuitive behavior, but this interpretation makes more sense than the alternative one, that the compiler is arbitrarily allowed to <em>ignore</em> infinite loops without invoking UB.</p>\n<p>If infinite loops are UB, it just means that non-terminating programs aren't considered meaningful: according to C++0x, they <em>have</em> no semantics. </p>\n<p>That does make a certain amount of sense too. They are a special case, where a number of side effects just no longer occur (for example, nothing is ever returned from <code>main</code>), and a number of compiler optimizations are hampered by having to preserve infinite loops. For example, moving computations across the loop is perfectly valid if the loop has no side effects, because eventually, the computation will be performed in any case.\nBut if the loop never terminates, we can't safely rearrange code across it, because we <em>might</em> just be changing which operations actually get executed before the program hangs. Unless we treat a hanging program as UB, that is.</p>\n", "LastActivityDate": "2010-08-29T04:44:44.510", "Score": "14", "CreationDate": "2010-08-29T04:44:44.510", "ParentId": "3592557", "CommentCount": "6", "OwnerUserId": "33213"}, "3593625": {"Id": "3593625", "PostTypeId": "2", "Body": "<p>The relevant issue is that the compiler is allowed to reorder code whose side effects do not conflict.  The surprising order of execution could occur even if the compiler produced non-terminating machine code for the infinite loop.</p>\n<p>I believe this is the right approach.  The language spec defines ways to enforce order of execution.  If you want an infinite loop that cannot be reordered around, write this:</p>\n<pre><code>volatile int dummy_side_effect;\n\nwhile (1) {\n    dummy_side_effect = 0;\n}\n\nprintf(\"Never prints.\\n\");\n</code></pre>\n", "LastActivityDate": "2010-08-29T05:20:17.440", "Score": "8", "CreationDate": "2010-08-29T05:20:17.440", "ParentId": "3592557", "CommentCount": "2", "OwnerUserId": "282334"}, "bq_ids": {"n4140": {"so_3592557_3592656_0": {"length": 12, "quality": 0.8, "section_id": 5838}, "so_3592557_3592557_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 5838}, "so_3592557_3592557_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 5838}}, "n3337": {"so_3592557_3592656_0": {"length": 12, "quality": 0.8, "section_id": 5608}, "so_3592557_3592557_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 5608}, "so_3592557_3592557_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 5608}}, "n4659": {"so_3592557_3592656_0": {"length": 12, "quality": 0.8, "section_id": 7300}, "so_3592557_3592557_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 7300}, "so_3592557_3592557_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 7300}}}, "30988141": {"Id": "30988141", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3592557_30988141_0\">Does someone have a good explanation of why this was necessary to allow?</p>\n</blockquote>\n<p>Yes, Hans Boehm provides a rationale for this in <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1528.htm\" rel=\"nofollow noreferrer\">N1528: Why undefined behavior for infinite loops?</a>, although this is WG14 document the rationale applies to C++ as well and the document refers to both WG14 and WG21:</p>\n<blockquote>\n<p id=\"so_3592557_30988141_1\">As N1509 correctly points out, the current draft essentially gives\n  undefined behavior to infinite loops in 6.8.5p6. A major issue for\n  doing so is that it allows code to move across a potentially\n  non-terminating loop. For example, assume we have the following loops,\n  where count and count2 are global variables (or have had their address\n  taken), and p is a local variable, whose address has not been taken:</p>\n<pre><code>for (p = q; p != 0; p = p -&gt; next) {\n    ++count;\n}\nfor (p = q; p != 0; p = p -&gt; next) {\n    ++count2;\n}\n</code></pre>\n<p id=\"so_3592557_30988141_2\">Could these two loops be merged and replaced by the following loop?</p>\n<pre><code>for (p = q; p != 0; p = p -&gt; next) {\n        ++count;\n        ++count2;\n}\n</code></pre>\n<p id=\"so_3592557_30988141_3\">Without the special dispensation in 6.8.5p6 for infinite loops, this\n  would be disallowed: If the first loop doesn't terminate because q\n  points to a circular list, the original never writes to count2. Thus\n  it could be run in parallel with another thread that accesses or\n  updates count2. This is no longer safe with the transformed version\n  which does access count2 in spite of the infinite loop. Thus the\n  transformation potentially introduces a data race.</p>\n<p id=\"so_3592557_30988141_4\">In cases like this, it is very unlikely that a compiler would be able\n  to prove loop termination; it would have to understand that q points\n  to an acyclic list, which I believe is beyond the ability of most\n  mainstream compilers, and often impossible without whole program\n  information.</p>\n<p id=\"so_3592557_30988141_5\">The restrictions imposed by non-terminating loops are a restriction on\n  the optimization of terminating loops for which the compiler cannot\n  prove termination, as well as on the optimization of actually\n  non-terminating loops. The former are much more common than the\n  latter, and often more interesting to optimize.</p>\n<p id=\"so_3592557_30988141_6\">There are clearly also for-loops with an integer loop variable in\n  which it would be difficult for a compiler to prove termination, and\n  it would thus be difficult for the compiler to restructure loops\n  without 6.8.5p6. Even something like</p>\n<pre><code>for (i = 1; i != 15; i += 2)\n</code></pre>\n<p id=\"so_3592557_30988141_7\">or</p>\n<pre><code>for (i = 1; i &lt;= 10; i += j)\n</code></pre>\n<p id=\"so_3592557_30988141_8\">seems nontrivial to handle. (In the former case, some basic number\n  theory is required to prove termination, in the latter case, we need\n  to know something about the possible values of j to do so. Wrap-around\n  for unsigned integers may complicate some of this reasoning further.)</p>\n<p id=\"so_3592557_30988141_9\">This issue seems to apply to almost all loop restructuring\n  transformations, including compiler parallelization and\n  cache-optimization transformations, both of which are likely to gain\n  in importance, and are already often important for numerical code.\n  This appears likely to turn into a substantial cost for the benefit of\n  being able to write infinite loops in the most natural way possible,\n  especially since most of us rarely write intentionally infinite loops.</p>\n</blockquote>\n<p>The one major difference with C is that <a href=\"https://stackoverflow.com/a/28681034/1708801\">C11 provides an exception for controlling expressions that are constant expressions</a> which differs from C++ and makes your specific example well-defined in C11.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-23T17:51:00.260", "Score": "21", "CreationDate": "2015-06-22T19:22:47.913", "ParentId": "3592557", "CommentCount": "0", "LastEditDate": "2017-05-23T11:46:39.570", "OwnerUserId": "1708801"}, "3592607": {"Id": "3592607", "PostTypeId": "2", "Body": "<p>I think this is along the lines of the this type of <a href=\"https://stackoverflow.com/questions/3527829/is-this-a-bug-in-the-intel-c-compiler-icc/3527862#3527862\">question</a>, which references another <a href=\"https://stackoverflow.com/questions/2178115/are-compilers-allowed-to-eliminate-infinite-loops\">thread</a>.  Optimization can occasionally remove empty loops.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-08-28T21:47:05.137", "Score": "8", "CreationDate": "2010-08-28T21:47:05.137", "ParentId": "3592557", "CommentCount": "14", "LastEditDate": "2017-05-23T12:02:11.563", "OwnerUserId": "116941"}, "3592557": {"ViewCount": "11578", "Body": "<p><em>Updated, see below!</em></p>\n<p>I have heard and read that C++0x allows an compiler to print \"Hello\" for the following snippet</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n  while(1) \n    ;\n  std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It apparently has something to do with threads and optimization capabilities. It looks to me that this can surprise many people though. </p>\n<p>Does someone have a good explanation of why this was necessary to allow? For reference, the most recent C++0x draft says at <code>6.5/5</code></p>\n<blockquote>\n<p id=\"so_3592557_3592557_0\">A loop that, outside of the for-init-statement in the case of a for statement,</p>\n<ul>\n<li>makes no calls to library I/O functions, and</li>\n<li>does not access or modify volatile objects, and</li>\n<li>performs no synchronization operations (1.10) or atomic operations (Clause 29)</li>\n</ul>\n<p id=\"so_3592557_3592557_1\">may be assumed by the implementation to terminate. [ Note: This is intended to allow compiler transfor-\n  mations, such as removal of empty loops, even when termination cannot be proven. \u2014 end note ]</p>\n</blockquote>\n<p><strong>Edit:</strong></p>\n<p><a href=\"http://blog.regehr.org/archives/161\" rel=\"noreferrer\">This insightful article</a> says about that Standards text</p>\n<blockquote>\n<p id=\"so_3592557_3592557_2\">Unfortunately, the words \"undefined behavior\" are not used. However, anytime the standard says \"the compiler may assume P,\" it is implied that a program which has the property not-P has undefined semantics.</p>\n</blockquote>\n<p>Is that correct, and is the compiler allowed to print \"Bye\" for the above program?</p>\n<hr>\n<p>There is an even more insightful <a href=\"http://groups.google.com/group/comp.std.c/browse_thread/thread/bc57eedf030cd192/438c1705ef6bf1f7\" rel=\"noreferrer\">thread here</a>, which is about an analogous change to C, started off by the Guy done the above linked article. Among other useful facts, they present a solution that seems to also apply to C++0x (<em>Update</em>: This won't work anymore with n3225 - see below!)</p>\n<pre><code>endless:\n  goto endless;\n</code></pre>\n<p>A compiler is not allowed to optimize that away, it seems, because it's not a loop, but a jump. Another guy summarizes the proposed change in C++0x and C201X</p>\n<blockquote>\n<p id=\"so_3592557_3592557_3\">By writing a loop, the programmer is asserting <em>either</em> that the\n  loop does something with visible behavior (performs I/O, accesses\n  volatile objects, or performs synchronization or atomic operations),\n  <em>or</em> that it eventually terminates.  If I violate that assumption\n  by writing an infinite loop with no side effects, I am lying to the\n  compiler, and my program's behavior is undefined.  (If I'm lucky,\n  the compiler might warn me about it.)  The language doesn't provide\n  (no longer provides?) a way to express an infinite loop without\n  visible behavior. </p>\n</blockquote>\n<hr>\n<p>Update on 3.1.2011 with n3225: Committee moved the text to 1.10/24 and say</p>\n<blockquote>\n<p id=\"so_3592557_3592557_4\">The implementation may assume that any thread will eventually do one of the following:</p>\n<ul>\n<li>terminate,</li>\n<li>make a call to a library I/O function,</li>\n<li>access or modify a volatile object, or</li>\n<li>perform a synchronization operation or an atomic operation.</li>\n</ul>\n</blockquote>\n<p>The <code>goto</code> trick will <strong>not</strong> work anymore!</p>\n</hr></hr>", "AcceptedAnswerId": "30988141", "Title": "Optimizing away a \"while(1);\" in C++0x", "CreationDate": "2010-08-28T21:32:02.613", "Id": "3592557", "CommentCount": "16", "FavoriteCount": "54", "PostTypeId": "1", "LastEditDate": "2011-10-03T13:14:58.640", "LastEditorUserId": "34509", "LastActivityDate": "2015-06-23T17:51:00.260", "Score": "136", "OwnerUserId": "34509", "Tags": "<c++><optimization><loops><c++11>", "AnswerCount": "8"}, "3638609": {"Id": "3638609", "PostTypeId": "2", "Body": "<p>It is not decidable for the compiler for non-trivial cases if it is an infinite loop at all.</p>\n<p>In different cases, it can happen that your optimiser will reach a better complexity class for your code (e.g. it was O(n^2) and you get O(n) or O(1) after optimisation).</p>\n<p>So, to include such a rule that disallows removing an infinite loop into the C++ standard would make many optimisations impossible. And most people don't want this. I think this quite answers your question. </p>\n<hr>\n<p>Another thing: I never have seen any valid example where you need an infinite loop which does nothing.</p>\n<p>The one example I have heard about was an ugly hack that really should be solved otherwise: It was about embedded systems where the only way to trigger a reset was to freeze the device so that the watchdog restarts it automatically.</p>\n<p>If you know any valid/good example where you need an infinite loop which does nothing, please tell me.</p>\n</hr>", "LastActivityDate": "2010-09-03T18:36:04.820", "Score": "0", "CreationDate": "2010-09-03T18:36:04.820", "ParentId": "3592557", "CommentCount": "1", "OwnerUserId": "133374"}, "7188619": {"Id": "7188619", "PostTypeId": "2", "Body": "<p>I think it's worth pointing out that loops which would be infinite except for the fact that they interact with other threads via non-volatile, non-synchronised variables can now yield incorrect behaviour with a new compiler.</p>\n<p>I other words, make your globals volatile -- as well as arguments passed into such a loop via pointer/reference.</p>\n", "LastActivityDate": "2011-08-25T10:13:21.747", "Score": "0", "CreationDate": "2011-08-25T10:13:21.747", "ParentId": "3592557", "CommentCount": "2", "OwnerUserId": "458742"}});