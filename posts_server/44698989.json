post_cb({"44698989": {"CommentCount": "10", "ViewCount": "204", "PostTypeId": "1", "LastEditorUserId": "2380830", "CreationDate": "2017-06-22T12:06:13.197", "LastActivityDate": "2017-06-22T20:14:07.543", "Title": "Does this set of operators cause undefined behaviour?", "AcceptedAnswerId": "44699135", "LastEditDate": "2017-06-22T12:25:57.673", "Id": "44698989", "Score": "2", "Body": "<p>As far as I understand, things like <code>++i++</code> are not allowed in C/C++ because they break a rule that variables cannot be written to multiple times in a single statement. The result is undefined behaviour. </p>\n<p>Could someone confirm if this also applies to my statement: <code>++i %= j</code>?</p>\n<p>I would like a for loop where I increment <code>i</code> around a circular buffer (size <code>j</code>) starting at an arbitrary point <code>p</code> until I get back to point <code>p</code>.</p>\n<pre><code>for(int i = p+1 ; i != p; ++i %= j  )\n{\n    if (buffer[i].ready()) \n    {\n        buffer[i].do_something();\n        p = i;\n        break;\n    }\n}\n</code></pre>\n<p>I could do it in more lines of code, but would rather not.</p>\n", "Tags": "<c++><c><language-lawyer>", "OwnerUserId": "1723954", "AnswerCount": "5"}, "44706093": {"ParentId": "44698989", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-06-22T17:40:02.017", "Score": "0", "LastEditorUserId": "4564515", "LastEditDate": "2017-06-22T20:14:07.543", "Id": "44706093", "OwnerUserId": "4564515", "Body": "<p>Others have already answered that your code is valid C++11 and later, but is undefined behavior for earlier versions of C++ and won't even compile in C (ignoring class member fcn calls, of course).  All of which says you should probably use a more explicit form to achieve your desired end.</p>\n<p>I also wanted to point out that you likely have a subtle bug in your code when <code>p == j - 1</code> because you add one but don't mod when you initialize <code>i</code>, making you access beyond the end of the array in that case.</p>\n<p>You also never process the element at index <code>p</code>.  Is that <strong>really</strong> what you want?  If you repeatedly executed this code and none of the other buffers were <code>ready()</code>, then you would keep skipping over checking if <code>buffer[p].ready()</code>.</p>\n<p>More correct, more universal code (that still doesn't check the element at index <code>p</code>):</p>\n<pre><code>int i;\n\nfor (i = (p + 1) % j; i != p &amp;&amp; !buffer[i].ready(); ++i, i %= j);\n\nif (i != p)\n{\n  buffer[i].do_something();\n  p = i;\n}\n</code></pre>\n<p>A version that starts by processing the element at index <code>p</code>, but stops after going over the array at most once:</p>\n<pre><code>int i = p;\n\nwhile (!buffer[i].ready() &amp;&amp; (++i, i %= j, i != p));\n\nif (buffer[i].ready())\n{\n  buffer[i].do_something();\n  p = i;\n}\n</code></pre>\n<p>There is a subtle point about the above version.  If <code>!buffer[p].ready()</code> when we first enter the loop, we go through the whole array, and none the other elements are <code>ready()</code> either, then we will exit the loop with <code>i == p</code>.  We will then interrogate <code>buffer[p]</code> again asking if it is <code>ready()</code>.  So, it is possible to ask <code>buffer[p].ready()</code> twice, which may or may not be important (e.g. - if it has side effects).  Heads up!</p>\n<p>Here's a version that avoids that issue, but checks <code>buffer[p].ready()</code> last:</p>\n<pre><code>int i = p;\n\nwhile ((++i, i %= j, i != p) &amp;&amp; !buffer[i].ready());\n\nif (i != p || buffer[p].ready())\n{\n  buffer[i].do_something();\n  p = i;\n}\n</code></pre>\n", "LastActivityDate": "2017-06-22T20:14:07.543"}, "44699135": {"ParentId": "44698989", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-06-22T12:13:02.953", "Score": "4", "LastEditorUserId": "4342498", "LastEditDate": "2017-06-22T12:21:19.333", "Id": "44699135", "OwnerUserId": "8198230", "Body": "<p>In your code you say <code>++i % j</code>, which means 'Increment i (and store the new value in i), then calculate the modulo of i and j. But that value is not stored anywhere.</p>\n<p>To get a wrap around loop, you can use <code>i = (i+1)%j</code></p>\n", "LastActivityDate": "2017-06-22T12:21:19.333"}, "44699189": {"ParentId": "44698989", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2017-06-22T12:15:57.057", "Score": "2", "LastEditorUserId": "817643", "LastEditDate": "2017-06-22T12:35:01.813", "Id": "44699189", "OwnerUserId": "817643", "Body": "<p>Yes, your code is well defined (in C++17 anyway). Quoting the standard:</p>\n<p><a href=\"http://eel.is/c++draft/expr.ass#1\" rel=\"nofollow noreferrer\">[expr.ass]</a></p>\n<blockquote>\n<p id=\"so_44698989_44699189_0\">The assignment operator (=) and the <strong>compound assignment operators all\n  group right-to-left</strong>. All require a modifiable lvalue as their left\n  operand and return an lvalue referring to the left operand. The result\n  in all cases is a bit-field if the left operand is a bit-field. <strong>In all\n  cases, the assignment is sequenced after the value computation of the\n  right and left operands</strong>, and before the value computation of the\n  assignment expression. <strong>The right operand is sequenced before the left\n  operand.</strong> With respect to an indeterminately-sequenced function call,\n  the operation of a compound assignment is a single evaluation.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/expr.pre.incr#1\" rel=\"nofollow noreferrer\">[expr.pre.incr]</a></p>\n<blockquote>\n<p id=\"so_44698989_44699189_1\">The operand of prefix ++ is modified by adding 1. The operand shall be\n  a modifiable lvalue. The type of the operand shall be an arithmetic\n  type other than cv bool, or a pointer to a completely-defined object\n  type. <strong>The result is the updated operand; it is an lvalue,</strong> and it is a\n  bit-field if the operand is a bit-field. The expression ++x is\n  equivalent to x+=1.</p>\n</blockquote>\n<p>The text in bold means your code pretty much has the following semantics:</p>\n<pre><code>auto&amp; __j = j;   // refer to j\nauto&amp; __i = ++i; // refer to i after the increment\n__i %= __j;\n</code></pre>\n<p>If the expression looks fishy to you despite the standards reassurance, you can always sequence it yourself with the comma operator.</p>\n<pre><code>for(... ; ... ; (++i, i %= j))\n</code></pre>\n", "LastActivityDate": "2017-06-22T12:35:01.813"}, "44699142": {"CommentCount": "15", "CreationDate": "2017-06-22T12:13:18.140", "CommunityOwnedDate": "2017-06-22T19:30:21.063", "LastEditorUserId": "2380830", "LastActivityDate": "2017-06-22T12:22:03.460", "ParentId": "44698989", "PostTypeId": "2", "LastEditDate": "2017-06-22T12:22:03.460", "Id": "44699142", "Score": "2", "Body": "<h1><strong>The behaviour is undefined pre C++17.</strong></h1>\n<p><code>++i %= j</code> is equivalent to <code>i = ++i % j</code>.</p>\n<p>This is a dressed up version of <code>i = ++i</code>, and <em>everyone</em> knows that is UB.</p>\n", "OwnerUserId": "2380830"}, "44699242": {"ParentId": "44698989", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2017-06-22T12:18:45.603", "Score": "2", "LastEditorUserId": "1989995", "LastEditDate": "2017-06-22T12:42:22.290", "Id": "44699242", "OwnerUserId": "1989995", "Body": "<p>The code <code>++i %= j</code> is identical to the following code:</p>\n<pre><code>operator %= (++i, j);\n</code></pre>\n<p>In the standard (\u00a71.9/15) it's stated that</p>\n<blockquote>\n<p id=\"so_44698989_44699242_0\">The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.</p>\n</blockquote>\n<p>While \"value computations\" includes:</p>\n<ul>\n<li>value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and</li>\n<li>initiation of side effects.</li>\n</ul>\n<p>So, here the compiler is forced to first calculate <code>++i</code> and <code>j</code> (in any order), including the side-effect of <code>++</code>, and call <code>operator %=</code> only after these calculations finished. So, it's a <strong>well-defined behavior</strong> since at least C++11.</p>\n<p>Please see <a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points/4183735#4183735\">this answer</a> for more details.</p>\n", "LastActivityDate": "2017-06-22T12:42:22.290"}, "bq_ids": {"n4140": {"so_44698989_44699189_1": {"section_id": 6074, "quality": 0.75, "length": 24}, "so_44698989_44699189_0": {"section_id": 6173, "quality": 0.8360655737704918, "length": 51}, "so_44698989_44699242_0": {"section_id": 5811, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_44698989_44699189_1": {"section_id": 5842, "quality": 0.75, "length": 24}, "so_44698989_44699189_0": {"section_id": 5934, "quality": 0.8360655737704918, "length": 51}, "so_44698989_44699242_0": {"section_id": 5584, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_44698989_44699189_1": {"section_id": 7570, "quality": 0.8125, "length": 26}, "so_44698989_44699189_0": {"section_id": 7675, "quality": 0.9344262295081968, "length": 57}, "so_44698989_44699242_0": {"section_id": 7272, "quality": 0.9090909090909091, "length": 10}}}});