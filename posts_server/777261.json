post_cb({"777488": {"ParentId": "777261", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You could use:</p>\n<pre><code>Check( Func() == 1 );\n</code></pre>\n<p>And implement your Check( bool ) function as you want. It may either use assert, or throw a particular exception, write in a log file or to the console, have different implementations in debug and release, or a combination of all.</p>\n", "OwnerUserId": "93447", "LastEditorUserId": "93447", "LastEditDate": "2009-04-22T14:40:55.903", "Id": "777488", "Score": "3", "CreationDate": "2009-04-22T14:30:40.530", "LastActivityDate": "2009-04-22T14:40:55.903"}, "777903": {"ParentId": "777261", "CommentCount": "3", "Body": "<p>I'd use the following:</p>\n<pre><code>#ifdef _DEBUG\n#define ASSERT(FUNC, CHECK) assert(FUNC == CHECK)\n#else\n#define ASSERT(FUNC, CHECK)\n#endif\n\n...\n\nASSERT(Func(), 1);\n</code></pre>\n<p>This way, for release build, the compiler don't even need to produce any code for assert.</p>\n", "OwnerUserId": "68304", "PostTypeId": "2", "Id": "777903", "Score": "0", "CreationDate": "2009-04-22T15:42:54.210", "LastActivityDate": "2009-04-22T15:42:54.210"}, "42041004": {"ParentId": "777261", "CommentCount": "0", "Body": "<p>The simplest thing is to only declare/assign those variables if the asserts will exist. The <code>NDEBUG</code> macro is specifically defined if asserts <em>won't</em> be effected (done that way round just because <code>-DNDEBUG</code> is a convenient way to disable debugging, I think), so this tweaked copy of @Jardel's answer should work (cf. comment by @AdamPeterson on that answer):</p>\n<pre><code>#ifndef NDEBUG\nint Result =\n#endif\nFunc();\nassert(Result == 1);\n</code></pre>\n<p>or, if that doesn't suit your tastes, all sorts of variants are possible, e.g. this:</p>\n<pre><code>#ifndef NDEBUG\nint Result = Func();\nassert(Result == 1);\n#else\nFunc();\n#endif\n</code></pre>\n<p>In general with this stuff, be careful that there's never a possibility for different translation units to be build with different <code>NDEBUG</code> macro states -- especially re. asserts or other conditional content in public header files. The danger is that you, or users of your library might accidentally instantiate a different definition of an inline function from the one used inside the compiled part of the library, quietly violating the <a href=\"https://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">one definition rule</a> and making the runtime behaviour undefined.</p>\n", "OwnerUserId": "91808", "PostTypeId": "2", "Id": "42041004", "Score": "2", "CreationDate": "2017-02-04T13:34:35.383", "LastActivityDate": "2017-02-04T13:34:35.383"}, "777416": {"ParentId": "777261", "CommentCount": "2", "Body": "<pre><code>int Result = Func();\nassert( Result == 1 );\nResult;\n</code></pre>\n<p>This will make the compiler stop complaining about Result not being used.</p>\n<p>But you should think about using a version of assert that does something useful at run-time, like log descriptive errors to a file that can be retrieved from the production environment.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "777416", "Score": "0", "CreationDate": "2009-04-22T14:12:42.943", "LastActivityDate": "2009-04-22T14:12:42.943"}, "12150699": {"ParentId": "777261", "CommentCount": "1", "Body": "<p>Certainly you use a macro to control your assert definition, such as \"_ASSERT\". So, you can do this:</p>\n<pre><code>#ifdef _ASSERT \nint Result =\n#endif /*_ASSERT */\nFunc();\nassert(Result == 1);\n</code></pre>\n", "OwnerUserId": "1308676", "PostTypeId": "2", "Id": "12150699", "Score": "1", "CreationDate": "2012-08-27T22:55:13.583", "LastActivityDate": "2012-08-27T22:55:13.583"}, "36810382": {"ParentId": "777261", "CommentCount": "0", "Body": "<p>Most answers suggest using <code>static_cast&lt;void&gt;(expression)</code> trick in <code>Release</code> builds to suppress the warning, but this is actually suboptimal if your intention is to make checks truly <code>Debug</code>-only. The goals of an assertion macro in question are:</p>\n<ol>\n<li>Perform checks in <code>Debug</code> mode</li>\n<li>Do nothing in <code>Release</code> mode</li>\n<li>Emit no warnings in all cases</li>\n</ol>\n<p>The problem is that void-cast approach fails to reach the second goal. While there is no warning, the expression that you've passed to your assertion macro will still be <em>evaluated</em>. If you, for example, just do a variable check, that is probably not a big deal. But what if you call some function in your assertion check like <code>ASSERT(fetchSomeData() == data);</code> (which is very common in my experience)? The <code>fetchSomeData()</code> function will still be called. It may be fast and simple or it may be not.</p>\n<p>What you really need is not only warning suppression but perhaps more importantly - <strong>non-evaluation</strong> of the debug-only check expression. This can be achieved with a simple trick that I took from a specialized <a href=\"https://github.com/gpakosz/Assert\" rel=\"nofollow\">Assert</a> library:</p>\n<pre><code>void myAssertion(bool checkSuccessful)\n{\n   if (!checkSuccessful)\n    {\n      // debug break, log or what not\n    }\n}\n\n#define DONT_EVALUATE(expression)                                    \\\n   {                                                                 \\\n      true ? static_cast&lt;void&gt;(0) : static_cast&lt;void&gt;((expression)); \\\n   }\n\n#ifdef DEBUG\n#  define ASSERT(expression) myAssertion((expression))\n#else\n#  define ASSERT(expression) DONT_EVALUATE((expression))\n#endif // DEBUG\n\nint main()\n{\n  int a = 0;\n  ASSERT(a == 1);\n  ASSERT(performAHeavyVerification());\n\n  return 0;\n}\n</code></pre>\n<p>All the magic is in the <code>DONT_EVALUATE</code> macro. It is obvious that at least <em>logically</em> the evaluation of your expression is never needed inside of it. To strengthen that, the C++ standard guarantees that only one of the branches of conditional operator will be evaluated. Here is the quote:</p>\n<blockquote>\n<p id=\"so_777261_36810382_0\">5.16 Conditional operator [expr.cond]</p>\n<p id=\"so_777261_36810382_1\"><em>logical-or-expression ? expression : assignment-expression</em></p>\n<p id=\"so_777261_36810382_2\">Conditional expressions group right-to-left. The first expression is\n  contextually converted to bool. It is evaluated and if it is true, the\n  result of the conditional expression is the value of the second\n  expression, otherwise that of the third expression. Only one of these\n  expressions is evaluated.</p>\n</blockquote>\n<p>I have tested this approach in GCC 4.9.0, clang 3.8.0, VS2013 Update 4, VS2015 Update 4 with the most harsh warning levels. In all cases there are no warnings and the checking expression is never evaluated in <code>Release</code> build (in fact the whole thing is completely optimized away). Bare in mind though that with this approach you will get in trouble really fast if you put expressions that have side effects inside the assertion macro, though this is a very bad practice in the first place.</p>\n<p>Also, I would expect that static analyzers may warn about \"result of an expression is always constant\" (or something like that) with this approach. I've tested for this with clang, VS2013, VS2015 static analysis tools and got no warnings of that kind.</p>\n", "OwnerUserId": "3375765", "PostTypeId": "2", "Id": "36810382", "Score": "0", "CreationDate": "2016-04-23T11:44:51.993", "LastActivityDate": "2016-04-23T11:44:51.993"}, "777336": {"ParentId": "777261", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You should move the assert inside the function before the return value(s).  You know that the return value is not an unreferenced local variable.  </p>\n<p>Plus it makes more sense to be inside the function anyway, because it creates a self contained unit that has its OWN pre- and post-conditions.</p>\n<p>Chances are that if the function is returning a value, you should be doing some kind of error checking in release mode on this return value anyway.  So it shouldn't be an unreferenced variable to begin with.</p>\n<p><strong>Edit, But in this case the post condition should be X (see comments):</strong></p>\n<p>I strongly disagree with this point, one should be able to determine the post condition from the input parameters and if it's a member function, any object state. If a global variable modifies the output of the function, then the function should be restructured. </p>\n", "OwnerUserId": "3153", "LastEditorUserId": "3153", "LastEditDate": "2009-04-22T14:26:19.040", "Id": "777336", "Score": "1", "CreationDate": "2009-04-22T13:56:59.267", "LastActivityDate": "2009-04-22T14:26:19.040"}, "26206465": {"ParentId": "777261", "CommentCount": "0", "Body": "<p>If this code is inside a function, then act on and return the result:</p>\n<pre><code>bool bigPicture() {\n\n   //Check the results\n   bool success = 1 != Func();\n   assert(success == NO, \"Bad times\");\n\n   //Success is given, so...\n   actOnIt();\n\n   //and\n   return success;\n}\n</code></pre>\n", "OwnerUserId": "91260", "PostTypeId": "2", "Id": "26206465", "Score": "0", "CreationDate": "2014-10-05T19:41:19.847", "LastActivityDate": "2014-10-05T19:41:19.847"}, "777359": {"ParentId": "777261", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>We use a macro to specifically indicate when something is unused:</p>\n<pre><code>#define _unused(x) ((void)(x))\n</code></pre>\n<p>Then in your example, you'd have:</p>\n<pre><code>int Result = Func();\nassert( Result == 1 );\n_unused( Result ); // make production build happy\n</code></pre>\n<p>That way (a) the production build succeeds, and (b) it is obvious in the code that the variable is unused <em>by design</em>, not that it's just been forgotten about. This is especially helpful when parameters to a function are not used.</p>\n", "OwnerUserId": "1821", "LastEditorUserId": "15168", "LastEditDate": "2016-02-26T03:25:47.987", "Id": "777359", "Score": "42", "CreationDate": "2009-04-22T14:02:20.923", "LastActivityDate": "2016-02-26T03:25:47.987"}, "bq_ids": {"n4140": {"so_777261_36810382_2": {"section_id": 6167, "quality": 0.92, "length": 23}}, "n3337": {"so_777261_36810382_2": {"section_id": 5928, "quality": 0.92, "length": 23}}, "n4659": {"so_777261_36810382_2": {"section_id": 7664, "quality": 0.92, "length": 23}}}, "777261": {"CommentCount": "0", "AcceptedAnswerId": "777359", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2009-04-22T13:43:02.577", "LastActivityDate": "2017-02-04T13:34:35.383", "LastEditDate": "2009-07-17T15:43:24.377", "ViewCount": "12462", "FavoriteCount": "6", "Title": "Avoiding unused variables warnings when using assert() in a Release build", "Id": "777261", "Score": "40", "Body": "<p>Sometimes a local variable is used for the sole purpose of checking it in an assert(), like so -</p>\n<pre><code>int Result = Func();\nassert( Result == 1 );\n</code></pre>\n<p>When compiling code in a Release build, assert()s are usually disabled, so this code may produce a warning about Result being set but never read.</p>\n<p>A possible workaround is -</p>\n<pre><code>int Result = Func();\nif ( Result == 1 )\n{\n    assert( 0 );\n}\n</code></pre>\n<p>But it requires too much typing, isn't easy on the eyes and causes the condition to be always checked (yes, the compiler may optimize the check away, but still).</p>\n<p>I'm looking for an alternative way to express this assert() in a way that wouldn't cause the warning, but still be simple to use and avoid changing the semantics of assert().</p>\n<p>(disabling the warning using a #pragma in this region of code isn't an option, and lowering warning levels to make it go away isn't an option either...).</p>\n", "Tags": "<c++><warnings><assertions>", "OwnerUserId": "88451", "AnswerCount": "13"}, "777960": {"ParentId": "777261", "CommentCount": "0", "Body": "<p>You could create another macro that allows you to avoid using a temporary variable:</p>\n<pre><code>#ifndef NDEBUG\n#define Verify(x) assert(x)\n#else\n#define Verify(x) ((void)(x))\n#endif\n\n// asserts that Func()==1 in debug mode, or calls Func() and ignores return\n// value in release mode (any braindead compiler can optimize away the comparison\n// whose result isn't used, and the cast to void suppresses the warning)\nVerify(Func() == 1);\n</code></pre>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "777960", "Score": "8", "CreationDate": "2009-04-22T15:53:18.770", "LastActivityDate": "2009-04-22T15:53:18.770"}, "777472": {"ParentId": "777261", "PostTypeId": "2", "CommentCount": "10", "Body": "<pre><code>int Result = Func();\nassert( Result == 1 );\n</code></pre>\n<p>This situation means that in release mode, you really want:</p>\n<pre><code>Func();\n</code></pre>\n<p>But <code>Func</code> is non-void, i.e. it returns a result, i.e. it is a <strong>query</strong>.</p>\n<p>Presumably, besides returning a result, <code>Func</code> modifies something (otherwise, why bother calling it and not using its result?), i.e. it is a <strong>command</strong>.</p>\n<p>By the <strong>command-query separation principle</strong> (1), <code>Func</code> shouldn't be a command and a query at the same time. In other words, queries shouldn't have side effects, and the \"result\" of commands should be represented by the available queries on the object's state.</p>\n<pre><code>Cloth c;\nc.Wash(); // Wash is void\nassert(c.IsClean());\n</code></pre>\n<p>Is better than</p>\n<pre><code>Cloth c;\nbool is_clean = c.Wash(); // Wash returns a bool\nassert(is_clean);\n</code></pre>\n<p>The former doesn't give you any warning of your kind, the latter does.</p>\n<p>So, in short, my answer is: don't write code like this :)</p>\n<p><strong>Update (1):</strong> You asked for references about the <strong>Command-Query Separation Principle</strong>. <a href=\"http://en.wikipedia.org/wiki/Command-Query_Separation\" rel=\"noreferrer\">Wikipedia</a> is rather informative. I read about this design technique in <a href=\"http://archive.eiffel.com/doc/oosc/page.html\" rel=\"noreferrer\">Object Oriented Software Construction, 2nd Editon</a> by Bertrand Meyer.</p>\n<p><strong>Update (2):</strong> j_random_hacker comments \"OTOH, every \"command\" function f() that previously returned a value must now set some variable last_call_to_f_succeeded or similar\". This is only true for functions that don't promise anything in their contract, i.e. functions that might \"succeed\" or not, or a similar concept. With <strong>Design by Contract</strong>, a relevant number of functions will have <strong>postconditions</strong>, so after \"Empty()\" the object will be \"IsEmpty()\", and after \"Encode()\" the message string will be \"IsEncoded()\", with no need to check. In the same way, and somewhat symetrically, you don't call a special function \"IsXFeasible()\" before each and every call to a procedure \"X()\"; because you usually know by design that you're fulfilling X's preconditions at the point of your call.</p>\n", "OwnerUserId": "96780", "LastEditorUserId": "96780", "LastEditDate": "2009-06-12T09:39:39.670", "Id": "777472", "Score": "10", "CreationDate": "2009-04-22T14:25:59.870", "LastActivityDate": "2009-06-12T09:39:39.670"}, "777303": {"ParentId": "777261", "CommentCount": "4", "Body": "<p>This is a bad use of assert, IMHO. Assert is not meant as an error reporting tool, it's meant to assert preconditions. If Result is not used elsewhere, it's not a precondition.</p>\n", "Id": "777303", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "3", "CreationDate": "2009-04-22T13:50:43.870", "LastActivityDate": "2009-04-22T13:50:43.870"}, "985807": {"ParentId": "777261", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2009-06-12T09:25:23.900", "Id": "985807", "LastEditDate": "2015-04-13T21:16:18.003", "OwnerDisplayName": "hcpizzi", "Score": "17", "Body": "<p>I wouldn't be able to give a better answer than this, that addresses that problem, and many more:</p>\n<p><a href=\"http://cnicholson.net/2009/02/stupid-c-tricks-adventures-in-assert/\" rel=\"noreferrer\">Stupid C++ Tricks: Adventures in assert</a></p>\n<pre><code>#ifdef NDEBUG\n#define ASSERT(x) do { (void)sizeof(x);} while (0)\n#else\n#include &lt;assert.h&gt;\n#define ASSERT(x) assert(x)\n#endif\n</code></pre>\n", "LastActivityDate": "2015-04-13T21:16:18.003", "LastEditorUserId": "364818"}});