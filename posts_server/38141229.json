post_cb({"bq_ids": {"n4140": {"so_38141229_38141560_6": {"length": 12, "quality": 1.0, "section_id": 3071}, "so_38141229_38141497_0": {"length": 4, "quality": 1.0, "section_id": 3163}, "so_38141229_38141497_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 3163}, "so_38141229_38141497_4": {"length": 12, "quality": 1.0, "section_id": 3071}, "so_38141229_38141560_2": {"length": 4, "quality": 1.0, "section_id": 3113}, "so_38141229_38141560_7": {"length": 9, "quality": 1.0, "section_id": 3071}, "so_38141229_38141560_8": {"length": 28, "quality": 1.0, "section_id": 3071}, "so_38141229_38141497_7": {"length": 28, "quality": 1.0, "section_id": 3071}, "so_38141229_38141560_5": {"length": 12, "quality": 1.0, "section_id": 3071}}, "n3337": {"so_38141229_38141560_6": {"length": 12, "quality": 1.0, "section_id": 2948}, "so_38141229_38141497_0": {"length": 4, "quality": 1.0, "section_id": 3036}, "so_38141229_38141497_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 3036}, "so_38141229_38141560_2": {"length": 4, "quality": 1.0, "section_id": 2990}, "so_38141229_38141560_7": {"length": 9, "quality": 1.0, "section_id": 2948}, "so_38141229_38141497_4": {"length": 12, "quality": 1.0, "section_id": 2948}, "so_38141229_38141560_5": {"length": 12, "quality": 1.0, "section_id": 2948}}, "n4659": {"so_38141229_38141560_6": {"length": 12, "quality": 1.0, "section_id": 3831}, "so_38141229_38141497_0": {"length": 4, "quality": 1.0, "section_id": 3925}, "so_38141229_38141497_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 3925}, "so_38141229_38141560_7": {"length": 9, "quality": 1.0, "section_id": 3831}, "so_38141229_38141560_2": {"length": 4, "quality": 1.0, "section_id": 3875}, "so_38141229_38141560_8": {"length": 28, "quality": 1.0, "section_id": 3831}, "so_38141229_38141560_5": {"length": 12, "quality": 1.0, "section_id": 3831}, "so_38141229_38141497_4": {"length": 12, "quality": 1.0, "section_id": 3831}, "so_38141229_38141497_7": {"length": 28, "quality": 1.0, "section_id": 3831}}}, "38141560": {"Id": "38141560", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38141229_38141560_0\">it is guaranteed that all tasks are executed when printing out the result,</p>\n</blockquote>\n<p>Only the task assigned last is guaranteed to have been executed. At least, I couldn't find any rules that would guarantee the rest.</p>\n<blockquote>\n<p id=\"so_38141229_38141560_1\">whether the tasks would be executed one after another (i.e. the task assignment would be blocking) or not.</p>\n</blockquote>\n<p>Task assignment is generally non-blocking, but it may block in this case - with no guarantee.</p>\n<p><a href=\"http://eel.is/c++draft/futures#futures.unique_future-10\" rel=\"nofollow\">[futures.unique_future]</a></p>\n<blockquote>\n<p id=\"so_38141229_38141560_2\">future&amp; operator=(future&amp;&amp; rhs) noexcept;</p>\n<ol start=\"10\">\n<li><p id=\"so_38141229_38141560_3\">Effects:</p>\n<p id=\"so_38141229_38141560_4\">releases any shared state ([futures.state]).</p></li>\n</ol>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/futures.state#5\" rel=\"nofollow\">[futures.state]</a></p>\n<blockquote>\n<ol start=\"5\">\n<li><p id=\"so_38141229_38141560_5\">When an asynchronous return object or an asynchronous provider is said to release its shared state, it means:</p>\n<ul>\n<li><p id=\"so_38141229_38141560_6\">if the return object or provider holds the last reference to its shared state, the shared state is destroyed; and</p></li>\n<li><p id=\"so_38141229_38141560_7\">the return object or provider gives up its reference to its shared state; and</p></li>\n<li><p id=\"so_38141229_38141560_8\">these actions will not block for the shared state to become ready, except that <strong>it may block</strong> if all of the following are true: the shared state was created by a call to std::async, the shared state is not yet ready, and this was the last reference to the shared state. </p></li>\n</ul></li>\n</ol>\n</blockquote>\n<p>All of the conditions for potential blocking are true of the task created by <code>std::async</code> hadn't executed yet.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2016-07-01T09:40:43.717", "Score": "3", "CreationDate": "2016-07-01T09:14:57.120", "ParentId": "38141229", "CommentCount": "2", "OwnerUserId": "2079303", "LastEditDate": "2016-07-01T09:40:43.717"}, "38141229": {"ViewCount": "417", "Body": "<p>During a code review, I came across a piece of code that basically boils down to this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;thread&gt;\n\nint main( int, char ** )\n{\n    std::atomic&lt;int&gt; x( 0 );\n    std::future&lt;void&gt; task;\n    for( std::size_t i = 0u; i &lt; 5u; ++i )\n    {\n        task = std::async( std::launch::async, [&amp;x, i](){\n                std::this_thread::sleep_for( std::chrono::seconds( 2u * ( 5u - i ) ) );\n                ++x;\n            } );\n    }\n\n    task.get();\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I was not quite sure whether</p>\n<ul>\n<li>it is guaranteed that all tasks are executed when printing out the result,</li>\n<li>whether the tasks would be executed one after another (i.e. the task assignment would be blocking) or not.</li>\n</ul>\n<p>I could not answer that question from reading documentation on the internet, so I thought I would write the snippet above to find out what our compiler actually does.</p>\n<p>Now, I found out that the answer of what gcc-5 does is indecisive and that made me even more curious: One would assume that the assignment is either blocking or non-blocking.</p>\n<p>If it is blocking, the time taken by the program should basically be the sum of the time the individual tasks take to execute. The first one takes 10 seconds, the second 8, the third 6, the fourth 4 and the last 2 seconds. So in total it should take 10+8+6+4+2 = <strong>30 seconds</strong>.</p>\n<p>If it is non-blocking, it should take as long as the last task, i.e. <strong>2 seconds</strong>.</p>\n<p>Here is what happens: It takes <strong>18 seconds</strong> (measured using time ./a.out or a good old clock). By playing around a bit with the code I found out that the code behaves as if the assignment would be alternatingly blocking and non-blocking.</p>\n<p>But this can't be true, right? <code>std::async</code> probably falls back to <code>std::deferred</code> half of the time? My debugger says that it spawns two threads, blocks until both threads exit, then spawns two more threads and so on.</p>\n<p>What does the standard say? What should happen? What happens inside gcc-5?</p>\n", "AcceptedAnswerId": "38141497", "Title": "What happens when reassigning to a future that is not ready yet", "CreationDate": "2016-07-01T08:58:55.920", "Id": "38141229", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-07-01T09:12:09.257", "LastEditorUserId": "264325", "LastActivityDate": "2017-01-03T15:21:20.173", "Score": "15", "OwnerUserId": "898813", "Tags": "<c++><c++11><c++14><future>", "AnswerCount": "2"}, "38141497": {"Id": "38141497", "PostTypeId": "2", "Body": "<p>The assignment of <code>task</code> via <code>operator=(&amp;&amp;)</code> is not forced to be blocking (see below), but in your case you created the <code>std::future</code> using <code>std::async</code> so it is blocking (thanks to @T.C.):</p>\n<p><a href=\"http://eel.is/c++draft/futures.async#5\" rel=\"nofollow noreferrer\">[future.async]</a></p>\n<blockquote>\n<p id=\"so_38141229_38141497_0\">If the implementation chooses the launch::async policy,</p>\n<ul>\n<li><p id=\"so_38141229_38141497_1\">[...]</p></li>\n<li><p id=\"so_38141229_38141497_2\">the associated thread completion synchronizes with ([intro.multithread]) the return from the first function that successfully detects the ready status of the shared state or with <strong>the return from the last function that releases the shared state</strong>, whichever happens first. </p></li>\n</ul>\n</blockquote>\n<h1>Why do you get a 18 seconds execution time?</h1>\n<p>What happens in your case is that the <code>std::async</code> starts the \"thread\" for your lambda <strong>before</strong> the assignment - See below for a detailed explanation on how you get an execution time of 18 seconds.</p>\n<p>This is what (probably) happens in your code (<code>e</code> stands for an epsilon):</p>\n<ul>\n<li><code>t = 0</code>, first <code>std::async</code> call with <code>i = 0</code>, starting a new thread;</li>\n<li><code>t = 0 + e</code>, second <code>std::async</code> call with <code>i = 1</code> starting a new thread, then move: The move will release the current <em>shared state</em> of <code>task</code>, blocking for about 10 seconds (but the second <code>std::async</code> with <code>i = 1</code> is already executing);</li>\n<li><code>t = 10</code>, third <code>std::async</code> call with <code>i = 2</code> starting a new thread, then move: The current <em>shared state</em> of <code>task</code> was the call with <code>i = 1</code> which already ready so nothing blocks;</li>\n<li><code>t = 10 + e</code>, fourth <code>std::async</code> call with <code>i = 3</code> starting a new thread, then move: The move is blocking because the previous <code>std::async</code> with <code>i = 2</code> is not ready but the thread for <code>i = 3</code> as already started;</li>\n<li><code>t = 16</code>, fifth <code>std::async</code> call with <code>i = 4</code> starting a new thread, then move: The current <em>shared state</em> of <code>task</code> (<code>i = 3</code>) is already ready, so non-blocking;</li>\n<li><code>t = 16 + e</code>, out of the loops, call to <code>.get()</code> wait for the *shared state` to be ready;</li>\n<li><code>t = 18</code>, <em>shared state</em> becomes ready so the whole stuff ends.</li>\n</ul>\n<h1>Standard details on <code>std::future::operator=</code>:</h1>\n<p>Here is the standard quote for <code>operator=</code> on <code>std::future</code>:</p>\n<blockquote>\n<pre><code>future&amp; operator=(future&amp;&amp; rhs) noexcept;\n</code></pre>\n<p id=\"so_38141229_38141497_3\"><em>Effects:</em></p>\n<ul>\n<li>(10.1) \u2014 releases any shared state (30.6.4).</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>And here is what <em>\"Releases any shared state\"</em> mean (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_38141229_38141497_4\">When an asynchronous return object or an asynchronous provider is said to release its shared state, it means:</p>\n<p id=\"so_38141229_38141497_5\">(5.1) \u2014 [...]</p>\n<p id=\"so_38141229_38141497_6\">(5.2) \u2014 [...]</p>\n<p id=\"so_38141229_38141497_7\">(5.3) \u2014 these actions will not block for the shared state to become ready, except that it <strong>may block</strong> if all of the following are true: <strong>the shared state was created by a call to std::async, the shared state is not yet\n  ready, and this was the last reference to the shared state</strong>.</p>\n</blockquote>\n<p>Your case fall into what I emphasized (I think): Your created the shared state using <code>std::async</code>, it is sleeping (so not ready) and you have only one reference to it, so this <strong>may</strong> be blocking.</p>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2017-01-03T15:21:20.173", "Score": "7", "CreationDate": "2016-07-01T09:12:16.360", "ParentId": "38141229", "CommentCount": "3", "OwnerUserId": "2666289", "LastEditDate": "2017-01-03T15:21:20.173"}});