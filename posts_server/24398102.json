post_cb({"bq_ids": {"n4140": {"so_24398102_24398102_0": {"length": 5, "quality": 0.625, "section_id": 6185}, "so_24398102_24400015_0": {"length": 7, "quality": 0.7, "section_id": 6185}}, "n3337": {"so_24398102_24398102_0": {"length": 5, "quality": 0.625, "section_id": 5946}, "so_24398102_24400015_0": {"length": 10, "quality": 1.0, "section_id": 5946}}, "n4659": {"so_24398102_24398102_0": {"length": 5, "quality": 0.625, "section_id": 7687}}}, "24398102": {"ViewCount": "1854", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>struct foo {\n  static constexpr const void* ptr = reinterpret_cast&lt;const void*&gt;(0x1);\n};\n\nauto main() -&gt; int {\n  return 0;\n}\n</code></pre>\n<p>The above example compiles fine in g++ v4.9 (<a href=\"http://coliru.stacked-crooked.com/a/90c872d2d3572488\">Live Demo</a>), while it fails to compile in clang v3.4 (<a href=\"http://coliru.stacked-crooked.com/a/f45f22d89f8677c2\">Live Demo</a>) and generates the following error:</p>\n<blockquote>\n<p id=\"so_24398102_24398102_0\"><em>error: constexpr variable 'ptr' must be initialized by a constant expression</em></p>\n</blockquote>\n<p><strong>Questions:</strong></p>\n<ul>\n<li><p>Which of the two compilers is right according to the standard?</p></li>\n<li><p>What's the proper way of declaring an expression of such kind?</p></li>\n</ul>\n", "AcceptedAnswerId": "24400015", "Title": "constexpr and initialization of a static const void pointer with reinterpret cast, which compiler is right?", "CreationDate": "2014-06-24T23:48:03.660", "Id": "24398102", "CommentCount": "5", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-06-25T01:11:03.307", "LastEditorUserId": "2352671", "LastActivityDate": "2015-07-21T17:14:11.480", "Score": "14", "OwnerUserId": "2352671", "Tags": "<c++><gcc><c++11><clang><constexpr>", "AnswerCount": "2"}, "24398173": {"Id": "24398173", "PostTypeId": "2", "Body": "<p>Clang is right. The result of a reinterpret-cast is never a constant expression (cf. C++11 5.19/2).</p>\n<p>The purpose of constant expressions is that they can be reasoned about as values, and values have to be valid. What you're writing is not provably a valid pointer (since it's not the address of an object, or related to the address of an object by pointer arithmetic), so you're not allowed to use it as a constant expression. If you just want to store the number <code>1</code>, store it as a <code>uintptr_t</code> and do the reinterpret cast at the use site.</p>\n<hr>\n<p>As an aside, to elaborate a bit on the notion of \"valid pointers\", consider the following <code>constexpr</code> pointers:</p>\n<pre><code>int const a[10] = { 1 };\nconstexpr int * p1 = a + 5;\n\n\nconstexpr int b[10] = { 2 };\nconstexpr int const * p2 = b + 10;\n\n// constexpr int const * p3 = b + 11;    // Error, not a constant expression\n\n// static_assert(*p1 == 0, \"\")           // Error, not a constant expression\n\nstatic_assert(p2[-2] == 0, \"\");          // OK\n\n// static_assert(p2[1] == 0, \"\");        // Error, \"p2[2] would have UB\"\n\nstatic_assert(p2 != nullptr, \"\");        // OK\n\n// static_assert(p2 + 1 != nullptr, \"\"); // Error, \"p2 + 1 would have UB\"\n</code></pre>\n<p>Both <code>p1</code> and <code>p2</code> are constant expressions. But whether the result of pointer arithmetic is a constant expression depends on whether it is not UB! This kind of reasoning would be essentially impossible if you allowed the values of reinterpret_casts to be constant expressions.</p>\n</hr>", "LastEditorUserId": "596781", "LastActivityDate": "2014-06-25T08:48:36.950", "Score": "10", "CreationDate": "2014-06-24T23:56:48.600", "ParentId": "24398102", "CommentCount": "14", "OwnerUserId": "596781", "LastEditDate": "2014-06-25T08:48:36.950"}, "24400015": {"Id": "24400015", "PostTypeId": "2", "Body": "<p><b>TL;DR</b></p>\n<p><code>clang</code> is correct, this is known <code>gcc</code> bug. You can either use <code>intptr_t</code> instead and cast when you need to use the value or if that is not workable then both <code>gcc</code> and <code>clang</code> support a little documented work-around that should allow your particular use case.</p>\n<p><b>Details</b></p>\n<p>So <code>clang</code> is correct on this one if we go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a> section <code>5.19</code> <em>Constant expressions</em> paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_0\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression\n  [...]</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_1\">\u2014 a reinterpret_cast (5.2.10);</p>\n</blockquote>\n<p>One simple solution would be to use <a href=\"http://en.cppreference.com/w/cpp/types/integer\" rel=\"nofollow noreferrer\">intptr_t</a>:</p>\n<pre><code>static constexpr intptr_t ptr = 0x1;\n</code></pre>\n<p>and then cast later on when you need to use it:</p>\n<pre><code>reinterpret_cast&lt;void*&gt;(foo::ptr) ;\n</code></pre>\n<p>It may be tempting to leave it at that but this story gets more interesting though. This is know and still open <code>gcc</code> bug see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49171\" rel=\"nofollow noreferrer\">Bug 49171:  [C++0x][constexpr] Constant expressions support reinterpret_cast</a>. It is clear from the discussion that <code>gcc</code> devs have some clear use cases for this:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_2\">I believe I found a conforming usage of reinterpret_cast in constant\n  expressions useable in C++03:</p>\n<pre><code>//---------------- struct X {  X* operator&amp;(); };\n\nX x[2];\n\nconst bool p = (reinterpret_cast&lt;X*&gt;(&amp;reinterpret_cast&lt;char&amp;&gt;(x[1]))\n- reinterpret_cast&lt;X*&gt;(&amp;reinterpret_cast&lt;char&amp;&gt;(x[0]))) == sizeof(X);\n\nenum E { e = p }; // e should have a value equal to 1\n//----------------\n</code></pre>\n<p id=\"so_24398102_24400015_3\">Basically this program demonstrates the technique, the C++11 library\n  function addressof is based on and thus excluding reinterpret_cast\n  <em>unconditionally</em> from constant expressions in the core language would render this useful program invalid and would make it impossible to\n  declare addressof as a constexpr function.</p>\n</blockquote>\n<p>but were not able to get an exception carved for these use cases, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1384\" rel=\"nofollow noreferrer\">closed issues 1384</a>:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_4\">Although reinterpret_cast was permitted in address constant\n  expressions in C++03, this restriction has been implemented in some\n  compilers and has not proved to break significant amounts of code. CWG\n  deemed that the complications of dealing with pointers whose tpes\n  changed (pointer arithmetic and dereference could not be permitted on\n  such pointers) outweighed the possible utility of relaxing the current\n  restriction.</p>\n</blockquote>\n<p><em>BUT</em> apparently <code>gcc</code> and <code>clang</code> support a little documented extension that allows constant folding of non-constant expressions using <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"nofollow noreferrer\">__builtin_constant_p (exp)</a> and so the following expressions is accepted by both <code>gcc</code> and <code>clang</code>:</p>\n<pre><code>static constexpr const void* ptr = \n  __builtin_constant_p( reinterpret_cast&lt;const void*&gt;(0x1) ) ? \n    reinterpret_cast&lt;const void*&gt;(0x1) : reinterpret_cast&lt;const void*&gt;(0x1)  ;\n</code></pre>\n<p>Finding documentation for this is near impossible but this <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20120130/052477.html\" rel=\"nofollow noreferrer\">llvm commit is informative</a> with the following snippets provide for some interesting reading:</p>\n<blockquote id=\"so_24398102_24400015_5\">\n<ul>\n<li>support the gcc __builtin_constant_p() ? ... : ... folding hack in C++11</li>\n</ul>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_6\">+// __builtin_constant_p ? : is magical, and is always a potential constant.</p>\n</blockquote>\n<p>and:</p>\n<blockquote id=\"so_24398102_24400015_7\">\n<ul>\n<li>// This macro forces its argument to be constant-folded, even if it's not</li>\n<li>// otherwise a constant expression.</li>\n<li><h1>define fold(x) (__builtin_constant_p(x) ? (x) : (x))</h1></li>\n</ul>\n</blockquote>\n<p>We can find a more formal explanation of this feature in the gcc-patches email: <a href=\"https://gcc.gnu.org/ml/gcc-patches/2008-10/msg01061.html\" rel=\"nofollow noreferrer\">C constant expressions, VLAs etc. fixes</a> which says:</p>\n<blockquote>\n<p id=\"so_24398102_24400015_8\">Furthermore, the rules for __builtin_constant_p calls as conditional\n  expression condition in the implementation are more relaxed than those\n  in the formal model: the selected half of the conditional expression\n  is fully folded without regard to whether it is formally a constant\n  expression, since __builtin_constant_p tests a fully folded argument\n  itself.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-21T17:14:11.480", "Score": "11", "CreationDate": "2014-06-25T04:05:55.890", "ParentId": "24398102", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2015-07-21T17:14:11.480"}});