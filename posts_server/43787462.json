post_cb({"43787462": {"ViewCount": "286", "Body": "<p>I just encountered a strange difference in behavior between clang and gcc where I wanted to compile code which looks similar to the following:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace n1 {\n  template &lt;class T1, class T2&gt;\n  struct MyTemplate {\n    struct Inner {};\n  };\n}\n\nusing namespace n1;\nnamespace n2 {\n  using MyClass = MyTemplate&lt;int, int&gt;;\n}\n\nnamespace n1 {\n  using n2::MyClass;\n  template&lt;&gt; struct MyClass::Inner {\n    int member;\n  };\n\n  MyClass::Inner inner{0};\n}\n</code></pre>\n<p>Clang happily compiles this:</p>\n<pre><code>$ clang++ -std=c++11 -c -o alias_specialization.o alias_specialization.cc\n</code></pre>\n<p>but gcc throws the following error: </p>\n<pre><code>$ g++ -std=c++11 -c -o alias_specialization.o alias_specialization.cc\n\nalias_specialization:15:30: error: declaration of \u2018struct n1::MyTemplate&lt;int, int&gt;::Inner\u2019 in namespace \u2018n1\u2019 which does not enclose \u2018using MyClass = struct n1::MyTemplate&lt;int, int&gt;\u2019\n   template&lt;&gt; struct MyClass::Inner {\n</code></pre>\n<p>I know I can just write the full name of the original type (<code>MyTemplate&lt;int, int&gt;</code>) instead of <code>MyClass</code> in line 15.\nBut I'm simply wondering which of the two compilers is \"right\".\nThe exact compilers in use are:</p>\n<pre><code>$ clang++ --version\nclang version 4.0.0\n\n$ g++ --version\ng++ (GCC) 6.3.1 20170306\n</code></pre>\n", "AcceptedAnswerId": "43792468", "Title": "Member specialization of alias declaration in different namespaces", "CreationDate": "2017-05-04T15:44:07.540", "Id": "43787462", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-05-08T15:42:07.987", "Score": "12", "OwnerUserId": "1468532", "Tags": "<c++><c++11><gcc><clang><clang++>", "AnswerCount": "1"}, "43792468": {"Id": "43792468", "PostTypeId": "2", "Body": "<p><strong>Disclaimer</strong>: <del>GCC</del> Clang is right (as @suluke pointed out, using the findings below).</p>\n<p>I found the following passages in the C++14 standard, but I am sure the same applies to C++11:</p>\n<h2>Part I: Specialization &amp; Instantiation of Templates</h2>\n<h3><code>inline namespace</code> (\u00a77.3.1 cl. 8):</h3>\n<blockquote>\n<p id=\"so_43787462_43792468_0\">Members of an inline namespace can be used in most respects as though they were members of the enclosing namespace. Specifically, the inline namespace and its enclosing namespace are both added to the set of associated namespaces used in argument-dependent lookup (3.4.2) whenever one of them is, and a using- directive (7.3.4) that names the inline namespace is implicitly inserted into the enclosing namespace as for an unnamed namespace (7.3.1.1). Furthermore, each member of the inline namespace can subsequently be partially specialized (14.5.5), explicitly instantiated (14.7.2), or <strong>explicitly specialized (14.7.3)</strong> as though it were a member of the enclosing namespace. Finally, looking up a name in the enclosing namespace via explicit qualification (3.4.3.2) will include members of the inline namespace brought in by the using-directive even if there are declarations of that name in the enclosing namespace.</p>\n</blockquote>\n<h3>Explicit instantiation (\u00a7 14.7.2 cl. 3)</h3>\n<blockquote>\n<p id=\"so_43787462_43792468_1\">If the explicit instantiation is for a class or member class, the elaborated-type-specifier in the declaration shall include a simple-template-id. If the explicit instantiation is for a function or member function, the unqualified- id in the declaration shall be either a template-id or, where all template arguments can be deduced, a template-name or operator-function-id. [Note: The declaration may declare a qualified-id, in which case the unqualified-id of the qualified-id must be a template-id. \u2014end note] If the explicit instantiation is for a member function, a member class or a static data member of a class template specialization, the name of the class template specialization in the qualified-id for the member name shall be a simple-template-id. If the explicit instantiation is for a variable, the unqualified-id in the declaration shall be a template-id. <strong>An explicit instantiation shall appear in an enclosing namespace of its template. If the name declared in the explicit instantiation is an unqualified name, the explicit instantiation shall appear in the namespace where its template is declared or, if that namespace is inline (7.3.1), any namespace from its enclosing namespace set.</strong></p>\n</blockquote>\n<h3>Explicit instantiation (\u00a7 14.7.2 cl. 6)</h3>\n<blockquote>\n<p id=\"so_43787462_43792468_2\">An explicit instantiation of a class, function template, or variable template specialization is placed in the namespace in which the template is defined. An explicit instantiation for a member of a class template is placed in the namespace where the enclosing class template is defined. An explicit instantiation for a member template is placed in the namespace where the enclosing class or class template is defined. [ Example:</p>\n</blockquote>\n<pre><code>namespace N {\n    template&lt;class T&gt; class Y { void mf() { } };\n  }\n  template class Y&lt;int&gt;;  // error: class template Y not visible \n                          // in the global namespace\n\n  using N::Y;\n  template class Y&lt;int&gt;; // error: explicit instantiation outside of the \n                         // namespace of the template\n\n\n  template class N::Y&lt;char*&gt;;  // OK: explicit instantiation in namespace N\n  template void N::Y&lt;double&gt;::mf();  // OK: explicit instantiation\n                                     // in namespace N\n</code></pre>\n<blockquote>\n<p id=\"so_43787462_43792468_3\">\u2014 end example ]</p>\n</blockquote>\n<h2>Part II: Typedef, Aliasing</h2>\n<h3>What is typedef or an alias?</h3>\n<p>\u00a77.1.3 cl. 1 states:</p>\n<blockquote>\n<p id=\"so_43787462_43792468_4\">[...]\n  A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in the way described in Clause 8. <strong>A typedef-name is thus a synonym for another type. A typedef-name does not introduce a new type the way a class declaration (9.1) or enum declaration does.</strong></p>\n</blockquote>\n<p>\u00a77.1.3 cl. 2 states:</p>\n<blockquote>\n<p id=\"so_43787462_43792468_5\">A typedef-name can also be introduced by an <strong>alias-declaration</strong>. The identifier following the using keyword becomes a typedef-name and the optional attribute-specifier-seq following the identifier appertains to that typedef-name. <strong>It has the same semantics as if it were introduced by the typedef specifier. In particular, it does not define a new type</strong> and it shall not appear in the type-id.</p>\n</blockquote>\n<h2>Part III: Testing Your Case</h2>\n<p>Following your logic the following code should compile and produce 2 different types. I tested it with Clang, which is the compiler in question. Clang produces the same type as standard it requires.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace n1 {\n  template &lt;class T1, class T2&gt;\n  struct MyTemplate {\n    struct Inner {};\n  };\n}\n\nusing namespace n1;\nnamespace n2 {\n  using MyClass = MyTemplate&lt;int, int&gt;;\n}\n\nnamespace n3 {\n  using MyClass = MyTemplate&lt;int, int&gt;;\n}\n\nnamespace n1 {\n  using n2::MyClass;\n  template&lt;&gt; struct MyClass::Inner {\n    int member;\n  };\n\n  MyClass::Inner inner{0};\n}\n\nnamespace n4{\n  using n3::MyClass;\n\n  MyClass::Inner inner{0};\n}\n\nint main()\n{\n  using namespace std;\n\n  cout &lt;&lt; typeid(n1::inner).name() &lt;&lt; endl;\n  cout &lt;&lt; typeid(n4::inner).name() &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>\n<h3>Compilation</h3>\n<pre><code>c++ -std=c++14 typedef-typeid.cpp -O3 -o compiled.bin\n</code></pre>\n<p>OR </p>\n<pre><code>c++ -std=c++11 typedef-typeid.cpp -O3 -o compiled.bin\n</code></pre>\n<p><strong>Output in both cases</strong></p>\n<pre><code>N2n110MyTemplateIiiE5InnerE\nN2n110MyTemplateIiiE5InnerE\n</code></pre>\n<p>As it turns out that in this context <code>typedef</code> and <code>using</code> are equivalent, we can use <code>typedef</code> instead of <code>using</code>.</p>\n<p><strong>\u00a77.3.3 cl. 1</strong> points this out:</p>\n<blockquote>\n<p id=\"so_43787462_43792468_6\">[...] If a using-declaration names a constructor (3.4.3.1), it implicitly declares a set of constructors in the class in which the using-declaration appears (12.9); <strong>otherwise the name specified in a using-declaration is a synonym for a set of declarations in another namespace or class</strong>.</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nnamespace n1 {\n  template &lt;class T1, class T2&gt;\n  struct MyTemplate {\n    struct Inner {};\n  };\n}\n\nusing namespace n1;\nnamespace n2 {\n  typedef MyTemplate&lt;int, int&gt; MyClass;\n}\n\n\nnamespace n1 {\n  typedef n2::MyClass MyClass;\n\n  template&lt;&gt; struct MyClass::Inner {\n    int member;\n  };\n\n  MyClass::Inner inner{0};\n}\n\nint main()\n{\n  using namespace std;\n\n  cout &lt;&lt; typeid(n1::inner).name() &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>\n<p>And GCC perfectly compiles the example, without blaming anything.</p>\n<p>In addition it'd be interesting to find out how the <strong>transitiveness</strong> with <code>using</code> declaration works with GCC.</p>\n<p>Here is the modified example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nnamespace n1 {\n  template &lt;class T1, class T2&gt;\n  struct MyTemplate {\n    struct Inner {};\n  };\n}\n\n\nusing namespace n1;\nnamespace n2 {\n  using MyClass = MyTemplate&lt;int, int&gt;;\n\n}\n\nnamespace n3\n{\n  using n2::MyClass;\n}\n\n\nnamespace n1 {\n  typedef n3::MyClass MyClass;\n\n  template&lt;&gt; struct MyClass::Inner {\n    int member;\n  };\n\n  MyClass::Inner inner{0};\n}\n\nint main()\n{\n  using namespace std;\n\n  cout &lt;&lt; typeid(n1::inner).name() &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>\n<p>And again both Clang and GCC happily compile it.</p>\n", "LastEditorUserId": "98693", "LastActivityDate": "2017-05-08T15:42:07.987", "Score": "4", "CreationDate": "2017-05-04T20:44:59.553", "ParentId": "43787462", "CommentCount": "6", "OwnerUserId": "98693", "LastEditDate": "2017-05-08T15:42:07.987"}, "bq_ids": {"n4140": {"so_43787462_43792468_1": {"length": 88, "quality": 0.9361702127659575, "section_id": 252}, "so_43787462_43792468_6": {"length": 20, "quality": 0.9090909090909091, "section_id": 5490}, "so_43787462_43792468_2": {"length": 36, "quality": 0.972972972972973, "section_id": 255}, "so_43787462_43792468_4": {"length": 37, "quality": 1.0, "section_id": 5407}, "so_43787462_43792468_0": {"length": 75, "quality": 0.872093023255814, "section_id": 5480}, "so_43787462_43792468_5": {"length": 30, "quality": 0.967741935483871, "section_id": 5408}}, "n3337": {"so_43787462_43792468_1": {"length": 82, "quality": 0.8723404255319149, "section_id": 243}, "so_43787462_43792468_6": {"length": 15, "quality": 0.6818181818181818, "section_id": 5276}, "so_43787462_43792468_2": {"length": 33, "quality": 0.8918918918918919, "section_id": 246}, "so_43787462_43792468_4": {"length": 37, "quality": 1.0, "section_id": 5202}, "so_43787462_43792468_0": {"length": 75, "quality": 0.872093023255814, "section_id": 5266}, "so_43787462_43792468_5": {"length": 30, "quality": 0.967741935483871, "section_id": 5203}}, "n4659": {"so_43787462_43792468_1": {"length": 88, "quality": 0.9361702127659575, "section_id": 259}, "so_43787462_43792468_0": {"length": 77, "quality": 0.8953488372093024, "section_id": 6914}, "so_43787462_43792468_4": {"length": 37, "quality": 1.0, "section_id": 6829}, "so_43787462_43792468_5": {"length": 28, "quality": 0.9032258064516129, "section_id": 6830}, "so_43787462_43792468_2": {"length": 36, "quality": 0.972972972972973, "section_id": 262}}}});