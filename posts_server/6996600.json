post_cb({"6996600": {"CommentCount": "0", "ViewCount": "163", "CreationDate": "2011-08-09T13:05:25.967", "LastActivityDate": "2011-08-09T13:23:29.547", "Title": "In-place destruction on type with overloaded operator->", "AcceptedAnswerId": "6996740", "PostTypeId": "1", "Id": "6996600", "Score": "2", "Body": "<p>Suppose some type <code>Foo</code> has an overloaded <code>operator-&gt;</code> that returns a <code>Bar*</code>:</p>\n<pre><code>struct Foo\n{\n    Bar* operator-&gt;();\n};\n</code></pre>\n<p>If I want to destruct the returned <code>Bar</code> instance in-place from within the <code>Foo</code> class, can I write the following?</p>\n<pre><code>this-&gt;~Bar();\n</code></pre>\n<p>g++ does not like that code. It works if I write this:</p>\n<pre><code>(*this)-&gt;~Bar();\n</code></pre>\n<p>Does the \"rescursive forwarding rule\" not apply in this case? Why not?</p>\n", "Tags": "<c++><operator-overloading><destructor><forwarding>", "OwnerUserId": "252000", "AnswerCount": "3"}, "6996660": {"ParentId": "6996600", "CommentCount": "1", "Body": "<p><code>this</code> is a pointer to an object of type Foo.\nYou overwrote the operator -&gt; for the object, not the pointer.</p>\n<pre><code>this-&gt;~Bar()\n</code></pre>\n<p>attempts to call the ~Bar() method in Foo.</p>\n<pre><code>(*this)-&gt;~Bar()\n</code></pre>\n<p>works because you call the -&gt; operator of the object.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "6996660", "Score": "3", "CreationDate": "2011-08-09T13:09:45.703", "LastActivityDate": "2011-08-09T13:09:45.703"}, "6996651": {"ParentId": "6996600", "CommentCount": "1", "Body": "<p>Because <code>this</code> is a pointer and <em>not</em> a reference and <code>-&gt;</code> for a pointer doesn't <em>have</em> a return value for forwarding to take place on. Consider equivalently</p>\n<pre><code>shared_ptr&lt;std::string&gt;* ptr = // some init\nptr-&gt;push_back('0'); // error\n</code></pre>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6996651", "Score": "3", "CreationDate": "2011-08-09T13:09:15.363", "LastActivityDate": "2011-08-09T13:09:15.363"}, "bq_ids": {"n4140": {"so_6996600_6996740_0": {"section_id": 664, "quality": 0.9411764705882353, "length": 16}, "so_6996600_6996740_1": {"section_id": 6005, "quality": 0.84, "length": 21}}, "n3337": {"so_6996600_6996740_0": {"section_id": 654, "quality": 0.9411764705882353, "length": 16}, "so_6996600_6996740_1": {"section_id": 5773, "quality": 0.84, "length": 21}}, "n4659": {"so_6996600_6996740_0": {"section_id": 692, "quality": 0.9411764705882353, "length": 16}, "so_6996600_6996740_1": {"section_id": 7504, "quality": 0.8, "length": 20}}}, "6996740": {"ParentId": "6996600", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Here is the rule for chaining <code>-&gt;</code>, found in 13.5.6 <code>[over.ref]</code> of the standard:</p>\n<blockquote>\n<p id=\"so_6996600_6996740_0\">An expression <code>x-&gt;m</code> is interpreted as <code>(x.operator-&gt;())-&gt;m</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator-&gt;()</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).</p>\n</blockquote>\n<p>Since <code>this</code> is a pointer, not a class object, it doesn't apply.</p>\n<p>Instead, this rule in 5.2.5 (<code>[expr.ref]</code>) is applicable:</p>\n<blockquote>\n<p id=\"so_6996600_6996740_1\">For the second option (arrow) the first expression shall have pointer to complete class type.  The expression <code>E1-&gt;E2</code> is converted to the equivalent form <code>(*(E1)).E2</code>; the remainder of 5.2.5 will address only the first option (dot).</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-08-09T13:23:29.547", "Id": "6996740", "Score": "3", "CreationDate": "2011-08-09T13:15:07.193", "LastActivityDate": "2011-08-09T13:23:29.547"}});