post_cb({"28529376": {"CommentCount": "2", "ViewCount": "384", "CreationDate": "2015-02-15T18:13:08.217", "LastActivityDate": "2015-02-15T18:51:16.560", "Title": "std::vector constructor taking pair of iterators", "AcceptedAnswerId": "28529503", "PostTypeId": "1", "Id": "28529376", "Score": "6", "Body": "<p>I am making some sort of container and I would like to mimic the interface of an <a href=\"http://en.cppreference.com/w/cpp/container/vector\"><code>std::vector</code></a>. However, I am having a hard time understanding how <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\">the constructor overload (4)</a> works. The problem is that it normally conflicts with overload (2).</p>\n<pre><code>// (2)\nvector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());\n// (4)\ntemplate&lt;class InputIt&gt;\nvector(InputIt first, InputIt last, const Allocator&amp; alloc = Allocator());\n</code></pre>\n<p>According to cppreference, until C++11 :</p>\n<blockquote>\n<p id=\"so_28529376_28529376_0\">this constructor has the same effect as overload (2) if InputIt is an integral type.</p>\n</blockquote>\n<p>I understand how it was done (tag dispatching or template specialization, I suppose), but I have no idea how the new behavior is achieved in C++11 :</p>\n<blockquote>\n<p id=\"so_28529376_28529376_1\">This overload only participates in overload resolution if InputIt satisfies <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\">InputIterator</a>, to avoid ambiguity with the overload (2).</p>\n</blockquote>\n<p>Is that some sort of SFINAE trick ? I do not understand how SFINAE could work here. And, since concepts or not a thing in C++11 (nor C++14), I have no idea about how I could do that for my container.</p>\n<p>Hence my question : how is it done in the standard library (or at least a guess), and how can I do it relatively easily for my container ?</p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "3854570", "AnswerCount": "1"}, "28529503": {"ParentId": "28529376", "LastEditDate": "2015-02-15T18:51:16.560", "CommentCount": "0", "CreationDate": "2015-02-15T18:25:10.027", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "28529503", "Score": "5", "Body": "<p>The way it's currently worded in the standard is rather interesting. [sequence.reqmts]/p15:</p>\n<blockquote>\n<p id=\"so_28529376_28529503_0\">The extent to which an implementation determines that a type cannot be\n  an input iterator is unspecified, except that as a minimum integral\n  types shall not qualify as input iterators.</p>\n</blockquote>\n<p>In other words, it's sufficient for implementations to test for integral types only, but they can do more if they want to.</p>\n<p>With a SFINAE-friendly <code>std::iterator_traits</code> (voted into the C++17 working paper as an LWG issue, but probably provided by most implementations all along anyway), for example, one might test that <code>std::iterator_traits&lt;InputIterator&gt;::iterator_category</code> is valid and denotes a type derived from <code>std::input_iterator_tag</code> with something like</p>\n<pre><code>template&lt;class InputIt, std::enable_if_t&lt;std::is_base_of&lt;std::input_iterator_tag,\n                            typename std::iterator_traits&lt;InputIterator&gt;::iterator_category&gt;::value, int&gt; = 0&gt;\nvector(InputIt first, InputIt last, const Allocator&amp; alloc = Allocator());\n</code></pre>\n<p>Note that this is just a proof-of-concept. Real implementations in standard libraries would probably be 1) more complex (for example, it may optimize based on iterator category - for forward iterators or better, it can allocate memory for all the elements in one go) and 2) even uglier than this and filled with underscores to avoid name conflicts.</p>\n", "LastActivityDate": "2015-02-15T18:51:16.560"}, "bq_ids": {"n4140": {"so_28529376_28529503_0": {"section_id": 734, "quality": 0.9375, "length": 15}}, "n3337": {"so_28529376_28529503_0": {"section_id": 723, "quality": 0.9375, "length": 15}}, "n4659": {"so_28529376_28529376_0": {"section_id": 4058, "quality": 0.5714285714285714, "length": 4}, "so_28529376_28529503_0": {"section_id": 747, "quality": 0.9375, "length": 15}}}});