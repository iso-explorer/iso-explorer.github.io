post_cb({"bq_ids": {"n4140": {"so_27764647_27764647_0": {"length": 7, "quality": 1.0, "section_id": 264}, "so_27764647_27765150_1": {"length": 19, "quality": 0.95, "section_id": 7104}, "so_27764647_27765150_0": {"length": 10, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_27764647_27764647_0": {"length": 7, "quality": 1.0, "section_id": 255}, "so_27764647_27765150_1": {"length": 19, "quality": 0.95, "section_id": 6848}, "so_27764647_27765150_0": {"length": 8, "quality": 0.8, "section_id": 6848}}, "n4659": {"so_27764647_27764647_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 285}, "so_27764647_27765150_1": {"length": 19, "quality": 0.95, "section_id": 8605}, "so_27764647_27765150_0": {"length": 10, "quality": 1.0, "section_id": 8605}}}, "27764984": {"Id": "27764984", "PostTypeId": "2", "Body": "<p>I believe the problem is that most of that setup code needs to be inside a namespace. This code compiles and runs for me in ideone:</p>\n<pre><code>#include &lt;system_error&gt;\n#include &lt;iostream&gt;\n\nnamespace NS {\n    enum X {a,b,c};\n\n    class X_category : public std::error_category\n    {\n    public:\n        virtual const char *name() const noexcept override { return \"X\"; }\n        virtual std::string message(int ev) const override { return \"M\"; }\n    };\n\n    inline std::error_code make_error_code(X result)\n    {\n        return std::error_code(static_cast&lt;int&gt;(result), X_category());\n    }\n}\n\nnamespace std {\n    template&lt;&gt; struct is_error_code_enum&lt;NS::X&gt; : public true_type{};\n}\n\nint main()\n{\n    std::cout &lt;&lt; NS::X::a;\n    std::error_code e = NS::X::a;\n    std::cout &lt;&lt; e.value();\n}\n</code></pre>\n<p>Unfortunately I still can't make much sense out of system_error, so I can't explain why, for instance, using an enum class instead of just a plain enum gives me an unspecified runtime error.</p>\n", "LastActivityDate": "2015-01-04T11:21:09.493", "CommentCount": "2", "CreationDate": "2015-01-04T11:21:09.493", "ParentId": "27764647", "Score": "1", "OwnerUserId": "2727470"}, "27765150": {"Id": "27765150", "PostTypeId": "2", "Body": "<p>The constructor template from <code>error_code</code> is indeed considered in overload resolution - you correctly specialized <code>is_error_code</code>. The problem is the ADL in this line in the definition of <code>error_code</code>s constructor template:</p>\n<pre><code>*this = make_error_code(__e);\n</code></pre>\n<p><strong>ADL does not consider the global namespace</strong> because <code>X</code> was only defined in <code>NS</code>, not the global one. [basic.lookup.argdep]/(2.3):</p>\n<blockquote>\n<p id=\"so_27764647_27765150_0\">If <code>T</code> is an enumeration type, its associated namespace is the\n  innermost enclosing namespace of its declaration. [..]</p>\n</blockquote>\n<p>The using declaration doesn't change this. [basic.lookup.argdep]/2:</p>\n<blockquote>\n<p id=\"so_27764647_27765150_1\">The sets of namespaces and classes is determined entirely by the types\n  of the function arguments (and the namespace of any template template\n  argument).\n  <strong>Typedef names and <em>using-declaration</em>s used to specify the types do not contribute to this set.</strong></p>\n</blockquote>\n<p>To fix this add your <code>make_error_code</code> to NS:</p>\n<pre><code>namespace NS {\n    inline std::error_code make_error_code(X result)\n    {\n        return std::error_code(static_cast&lt;int&gt;(result), X_category());\n    }\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0de29e0a300136b8\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n", "LastActivityDate": "2015-01-04T11:45:35.197", "CommentCount": "5", "CreationDate": "2015-01-04T11:45:35.197", "ParentId": "27764647", "Score": "2", "OwnerUserId": "3647361"}, "27764647": {"ViewCount": "375", "Body": "<p>I am trying to create my own enum-based error category and want my enum with error codes to be defined inside some namespace. Much to my surprise this prevents the automatic conversion from values of my enum into <code>std::error_code</code> (such conversion works if the enum is defined in the global namespace).</p>\n<pre><code>#include &lt;system_error&gt;\n\nnamespace NS { enum class X {a,b,c}; }\nusing NS::X;\n\nclass X_category : public std::error_category\n{\npublic:\n    virtual const char *name() const noexcept override { return \"X\"; }\n    virtual std::string message(int ev) const override { return \"\"; }\n};\n\ninline const std::error_category&amp; X_category()\n{\n    static class X_category c; return c;\n}\n\ntemplate&lt;&gt; struct std::is_error_code_enum&lt;X&gt; : public std::true_type{};\n\ninline std::error_code make_error_code(X result)\n{\n    return std::error_code(static_cast&lt;int&gt;(result), X_category());\n}\n\nint main()\n{\n    std::error_code e = X::a; // does not work !!\n}\n</code></pre>\n<p>Am I missing something in my code above (related to overloading resolution rules perhaps) to make it work? Or do the enums for <code>std::is_error_code_enum&lt;&gt;</code> can only be defined inside a global namespace??</p>\n<p>EDIT. My compiler (MSVC2013) does not complain about it but it seems the specialization of std::is_error_code_enum&lt;&gt; must be done inside std namespace. Also I added noexcept keyword on name() method to make the code even more C++11 compliant (MSVC2013 won't understand noexcept, but MSVC2015 will).</p>\n<p>EDIT2. According to C++11 14.7.3.2 [temp.expl.spec]:</p>\n<blockquote>\n<p id=\"so_27764647_27764647_0\">An explicit specialization shall be declared in a namespace enclosing the specialized template.</p>\n</blockquote>\n<p>So it is not necessary to put specialization of std::is_error_code_enum&lt;&gt; inside an std namespace. MSVC compiles it correctly but GCC complains which is actually a bug in GCC since GCC acts by old C++03 rules which were more restrictive.</p>\n", "AcceptedAnswerId": "27765150", "Title": "is_error_code_enum<> enumeration must be defined in global namespace only?", "CreationDate": "2015-01-04T10:38:41.193", "Id": "27764647", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-04T13:23:12.223", "LastEditorUserId": "1997715", "LastActivityDate": "2015-01-04T13:23:12.223", "Score": "3", "OwnerUserId": "1997715", "Tags": "<c++><c++11><overloading>", "AnswerCount": "2"}});