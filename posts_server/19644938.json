post_cb({"19645450": {"ParentId": "19644938", "Score": "2", "CreationDate": "2013-10-28T21:31:48.110", "Id": "19645450", "OwnerUserId": "1120273", "LastActivityDate": "2013-10-28T21:31:48.110", "Body": "<p>The trigonometric functions are library functions with a reasonably vague specification. For example, here is what the C standard has to say on this topic (7.12.4.6):</p>\n<blockquote>\n<p id=\"so_19644938_19645450_0\">The sin functions</p>\n<p id=\"so_19644938_19645450_1\">Synopsis</p>\n</blockquote>\n<pre><code>#include &lt;math.h&gt;\ndouble sin(double x);\nfloat sinf(float x);\nlong double sinl(long double x);\n</code></pre>\n<blockquote>\n<p id=\"so_19644938_19645450_2\">Description</p>\n<p id=\"so_19644938_19645450_3\">The <code>sin</code> functions compute the sine of <code>x</code> (measured in radians).</p>\n<p id=\"so_19644938_19645450_4\">Returns</p>\n<p id=\"so_19644938_19645450_5\">The <code>sin</code> functions return sin <code>x</code></p>\n</blockquote>\n<p>As such, they will use different algorithms and different accuracy, i.e., using the library versions you won't get exactly the same results. For example, different libraries may make different trade-offs between accuracy and computation speed. Even if the library implementations were exactly the same, you probably won't get exactly the same results on different systems as the values may be rounded at different points throughout the calculations. To get reasonably close results between different platforms you may need to implement the same algorithms on these platforms.</p>\n<p>Note, that <code>sin(x)</code> clearly provides the best results in the range <code>[0, \u03c0/2]</code>. Passing a huge number to <code>sin(x)</code> will probably create a fairly bad approximation although I would expect that most implementations would start off with mapping <code>x</code> into the range given above before doing any computations. Ideally, you'd avoid the large values right from the start and express them in terms of multiples of <code>\u03c0</code> instead. However, you'll likely get different results from different implementations even when <code>x</code> falls into the range above.</p>\n", "PostTypeId": "2", "CommentCount": "7"}, "19644938": {"Tags": "<java><c++><math.h><sine>", "ViewCount": "623", "LastEditDate": "2013-10-28T23:30:30.807", "CreationDate": "2013-10-28T20:56:10.863", "LastEditorUserId": "460542", "Title": "results of sine function different between microsoft and Java / Linux", "CommentCount": "10", "AnswerCount": "1", "Score": "0", "OwnerUserId": "2929669", "Id": "19644938", "LastActivityDate": "2013-10-28T23:30:30.807", "Body": "<p>I have a C++ code written for Windows (Visual Studio) which I need to port into Java. This is not very easy and currently I am stuck using the sine function in . The results given from Linux (tested to have a comparison) and Java are different as the results from the Windows source. Both results are wrong but this doesn't matter. It is important that the results are exact the same.</p>\n<p>I will post the entire source at the bottom. For example I need to calculate the sine of 5174852443848405000.0. I know this is a very large and maybe unusual number but I can not change this. Linux and Java are returning 0.153662 and Windows something about 0.16xx.\nThe function \"random_value_genrator()\" is used about 500,000 times so the differences in the result may occur later sometime.</p>\n<p>initial_value_generator will calculate a value which is used later by the random_value_generator function. The value is generated out of a FILETIME object and three constants. Buffer overflows are occurring but not handled. \nThe random_value_generator is modifying the DWORD64 prng_initial_value each time when used.</p>\n<p>I was able to build the initial_value_generator function successfully.</p>\n<p>I guess I can't complete this task but any help is appreciated.</p>\n<p>Some global variables:</p>\n<pre><code>DWORD64 prng_initial_value = 0;\n\nDWORD64 CON1_RVG = 0x4F3D859E;\ndouble CON2_RVG = 0.946270391;\n\nDWORD64 CON1_PRNG = 0x2682D10B7;\nDWORD64 CON2_PRNG = 0x19254D38000;\nDWORD64 CON3_PRNG = 0x0F1E34A09;\n</code></pre>\n<p>This function is used once at program startup. Writing a large DWORD64 into prng_initial_value, which is used later by random_value_generator().\nA system time is multiplied by constant 1 (buffer overflow), divided by constant 2 and added with constant 3.</p>\n<pre><code>void initial_value_generator ()\n{\n    SYSTEMTIME systime;\n    FILETIME filetime;\n\n    // Systemzeit zu GMT-Format umwandeln\n    SystemTimeToFileTime(&amp;systime,&amp;filetime);\n\n    prng_initial_value = (*(DWORD64*)&amp;filetime) * CON1_PRNG / CON2_PRNG + CON3_PRNG;\n}\n</code></pre>\n<p>This function changes the DWORD64 prng_initial_value at each use.</p>\n<pre><code>int random_value_generator () \n{\n    double sin_value;\n    double copy_of_prng_initial_value;\n    DWORD64 prng_con1;\n    double result;\n\n    // Initialen Wert aus dem initial_random_generator in lokaler Variable speichern\n    copy_of_prng_initial_value = prng_initial_value;\n\n    // Sinus vom initialen Wert \n    sin_value = sin(copy_of_prng_initial_value);\n\n    // Initialen Wert mulipikation mit einem konstanten Wert (0x4F3D859E)\n    prng_con1 = prng_initial_value * CON1_RVG;\n</code></pre>\n<p>Some further calculations to become insane:</p>\n<pre><code>    result = prng_con1 + sin_value;\n    result = result * copy_of_prng_initial_value;\n    result = result + CON2_RVG;\n    result = result * copy_of_prng_initial_value;\n\n    // Das Ergebnis aus der Logarithmus Rechnung addieren\n    result += log(copy_of_prng_initial_value);\n\n    // Das Ergebnis aus den Berechnungen als Pointer in die\n    // Speicheradresse von prng_initial_value als double Pointer speichern.\n    *(double*)&amp;prng_initial_value = result;\n\n    // Rueckgabe des Berechneten Wert als Integer\n    return prng_initial_value;\n}\n</code></pre>\n<p>For reference I post my Java code (all comments are in English). The random function looks a bit crazy because I was testing a lot of things. I am very sorry about that. But the important point is just the use of the Math.sin(double x) function which result is different that the sin function in Math.h using Microsoft C++ compiler.</p>\n<pre><code>private final long initialValue;\nprivate long randomValue;\nfinal BigInteger uint64MaxValue = new BigInteger(\"18446744073709551616\");   //2^64\n\npublic ConfickerC() {\n    this.initialValue = this.generateInitialValue();\n    this.randomValue = this.initialValue;\n}\n\nprivate long generateInitialValue() {\n    //We need the actual date without the time from GMT +0 timezone\n    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n    cal.set(Calendar.HOUR_OF_DAY, 0);\n    cal.set(Calendar.MINUTE, 0);\n    cal.set(Calendar.SECOND, 0);\n    cal.set(Calendar.MILLISECOND, 0);\n\n    long systemtimeAsFiletime = cal.getTimeInMillis();\n\n    /*\n     * Goal is to get the above created date into Windows FileTime format.\n     * The Windows FileTime format has got 100 nano seconds per tick.\n     * So one increment of the long value results further 100 nano seconds.\n     * Instead of Unix the FileTime format begins with 1st January 1601 - not 1970.\n     * 11644473600 is the interval between 1601 and 1970 in seconds.\n     * Java has got a resolution of 1 ms per tick unix have got 1 second per\n     * tick. So first devide the time by 1000. Then add the interval. \n     * After this we multiply by 10 million to get a resolution of 100\n     * nano seconds per tick.\n     */\n    systemtimeAsFiletime /= 1000;        //divide by 1000 to get seconds instead of milliseconds\n    systemtimeAsFiletime += 11644473600L; //add x seconds to add the interval between 1601 and 1970\n    systemtimeAsFiletime *= 10000000L;   //Windows FileTime has a resolution of 100 nano seconds per tick; so multiply by 10M\n\n    /*\n     * The virus is calulating for getting the initial value: time * con1 / con2 + con3\n     * Originaly there occurs a buffer overflow which is not handled in the C++ code.\n     * The funny thing is that Java does not have a DWORD64 (unsinged _int64). So because of this bit missing (and so the overflow is different) we need BigInteger. \n     * Because BigInteger has no 2^64 limitation we need the maximul value of DWORD64.\n     * This is used to \"simulate\" the buffer overflow by calculating ((time * con1) % 2^64) / con2 + con3\n     * modulo 2^64 will result a value which is equal to the C++ calculation\n     */\n\n    final BigInteger CONSTANT_1 = new BigInteger(\"10337718455\");                //Original: 0x2682D10B7\n    final BigInteger CONSTANT_2 = new BigInteger(\"1728000000000\");              //Original: 0x19254D38000\n    final BigInteger CONSTANT_3 = new BigInteger(\"4058204681\");                 //Original: 0x0F1E34A09\n\n    BigInteger bigIntSystemTime = BigInteger.valueOf(systemtimeAsFiletime);\n\n    //Return as long value: ((time * con1) % 2^64) / con2 + con3\n    return bigIntSystemTime.multiply(CONSTANT_1).divideAndRemainder(uint64MaxValue)[1].divide(CONSTANT_2).add(CONSTANT_3).longValue();\n}\n\nprivate int generateRandomValue() {\n    final long CONSTANT_1 = 1329431966L;\n    final double CONSTANT_2 = 0.946270391;\n    double result = 0.0;\n    double copyOfInit = this.randomValue;\n\n    System.out.println(System.getProperty(\"line.separator\") + \"Copy of init: \" + copyOfInit);\n    System.out.printf(\"Copy of init: %f\\n\", copyOfInit);\n    double sinInit = Math.sin(copyOfInit); System.out.println(\"Sinus: \" + sinInit);  \n    System.out.printf(\"Sinus: %f\\n\", sinInit);\n    System.out.println(\"Sinus gerundet: \" + Math.round(sinInit*1000000)/1000000.0d);\n    BigInteger b =        BigInteger.valueOf(this.randomValue).multiply(BigInteger.valueOf(CONSTANT_1)).divideAndRemainder(uint64MaxValue)[1];\n\n    System.out.println(\"Init * Konstante 1: \" + b);\n    BigDecimal bd = new BigDecimal(b.toString());\n    //bd.add(BigDecimal.valueOf(sinInit));\n\n    //result = t + sinInit; System.out.println(\"Multi + Sinus: \" + result);\n    result = bd.add(BigDecimal.valueOf(sinInit)).doubleValue(); System.out.println(\"Multi + Sinus: \" + result);\n    result *= (long) this.randomValue; System.out.println(\"Zwischenergebnis * init: \" + result);\n    result += CONSTANT_2; System.out.println(\"Konstante 2 addiert: \" + result);\n    System.out.printf(\"BigD: %s\", BigDecimal.valueOf(result).multiply(BigDecimal.valueOf(randomValue)));\n    result *= this.randomValue; System.out.printf(\"Erneut mit init multipliziert: %f\", result);\n    double l = Math.log((long)this.randomValue); System.out.println(\"Log von init: \" + l);\n    result += l; System.out.printf(\"+= mit Log: %f\\n\", result);\n\n    this.randomValue = (long)result; System.out.printf(\"Ende: %d\\n\", this.randomValue);\n\n    this.randomValue = Double.doubleToRawLongBits(result);\n\n    return (int)this.randomValue;   \n}\n</code></pre>\n", "PostTypeId": "1", "FavoriteCount": "1"}, "bq_ids": {"n4659": {"so_19644938_19645450_3": {"length": 4, "section_id": 4730, "quality": 0.5714285714285714}}}});