post_cb({"33480889": {"Id": "33480889", "PostTypeId": "2", "Body": "<p>As @Columbo has already pointed out, (a-&gt;x) is to be taken as an expression, and that expression <strong>is</strong> <code>const</code> qualified, because *a is const.</p>\n<p>Let's consider this </p>\n<pre><code>decltype((a-&gt;x)); \n</code></pre>\n<p>was not <code>const</code> qualified.</p>\n<p>Then e.g. this</p>\n<pre><code>decltype((a-&gt;x)) ref = (a-&gt;x); \n</code></pre>\n<p>would implicitly sort-of lift the *a const qualifier, because *a's x would become mutable through <code>ref</code>. </p>\n", "LastEditorUserId": "5397699", "LastActivityDate": "2015-11-02T18:04:04.140", "Score": "0", "CreationDate": "2015-11-02T15:16:25.023", "ParentId": "33479631", "CommentCount": "0", "OwnerUserId": "5397699", "LastEditDate": "2015-11-02T18:04:04.140"}, "33480118": {"Id": "33480118", "PostTypeId": "2", "Body": "<p>\u00a7 7.1.6.4 [dcl.spec.auto] (draft n3797)</p>\n<blockquote id=\"so_33479631_33480118_0\">\n<ol start=\"7\">\n<li>... If the placeholder is the\n  decltype(auto)\n  type-specifier\n  , the declared type of the variable or return type\n  of the function shall be the placeholder alone. The type deduced for the variable or return type is determined\n  as described in\n  7.1.6.2\n  , as though the initializer had been the operand of the\n  decltype\n  .</li>\n</ol>\n</blockquote>\n<p>\u00a7 7.1.6.2 [dcl.type.simple]</p>\n<blockquote>\n<ol start=\"4\">\n<li>For an expression\n  e\n  , the type denoted by\n  decltype(e)\n  is defined as follows:</li>\n</ol>\n<p id=\"so_33479631_33480118_1\">\u2014\n   if\n  e\n  is an unparenthesized\n  id-expression\n  or an unparenthesized class member access (\n  5.2.5\n  ),\n  decltype(e)\n  is the type of the entity named by\n  e\n  . If there is no such entity, or if\n  e\n  names a set of overloaded func-\n  tions, the program is ill-formed;</p>\n<p id=\"so_33479631_33480118_2\">\u2014\n   otherwise, if\n  e\n  is an xvalue,\n  decltype(e)\n  is\n  T&amp;&amp;\n  , where\n  T\n  is the type of\n  e\n  ;</p>\n<p id=\"so_33479631_33480118_3\">\u2014\n   otherwise, if\n  e\n  is an lvalue,\n  decltype(e)\n  is\n  T&amp;\n  , where\n  T\n  is the type of\n  e\n  ;</p>\n<p id=\"so_33479631_33480118_4\">\u2014\n   otherwise,\n  decltype(e)\n  is the type of\n  e</p>\n</blockquote>\n<p><code>x</code> is is an unparenthesized id-expression and therefore the return type is deduced as the type of <code>x</code>: <code>int</code></p>\n<p><code>(x)</code> is <em>not</em> an <strong>un</strong>parenthesized id-expression so that rule does not apply. However, it <em>is</em> a (parenthesized) lvalue expression. Therefore the deduced type is <code>T&amp;</code> where <code>T</code> is the type of <code>x</code>: <code>int&amp;</code></p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2015-11-02T15:19:50.947", "Score": "5", "CreationDate": "2015-11-02T14:38:45.040", "ParentId": "33479631", "CommentCount": "1", "OwnerUserId": "2079303", "LastEditDate": "2015-11-02T15:19:50.947"}, "33480126": {"Id": "33480126", "PostTypeId": "2", "Body": "<p>The relevant standards quote is:</p>\n<blockquote>\n<p id=\"so_33479631_33480126_0\"><code>N4140 [dcl.type.simple]/4:</code> For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li>if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code>\n  is the type of the entity named by <code>e</code>. If there is no such entity, or if e names a set of overloaded functions, the program is ill-formed;</li>\n<li>otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of e;</li>\n<li><strong>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of e</strong>;</li>\n<li>otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</li>\n</ul>\n</blockquote>\n<p>Since <code>x</code> is an lvalue, and the expression is parenthesized, the third rule is used, so <code>decltype((x))</code> is <code>int&amp;</code>.</p>\n", "LastActivityDate": "2015-11-02T14:39:13.577", "CommentCount": "0", "CreationDate": "2015-11-02T14:39:13.577", "ParentId": "33479631", "Score": "10", "OwnerUserId": "496161"}, "bq_ids": {"n4140": {"so_33479631_33480118_1": {"length": 17, "quality": 0.85, "section_id": 5440}, "so_33479631_33480118_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 5451}, "so_33479631_33480126_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5440}, "so_33479631_33480152_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_33479631_33480118_2": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_33479631_33479631_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5440}, "so_33479631_33480118_3": {"length": 5, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_33479631_33479631_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5235}, "so_33479631_33480118_1": {"length": 17, "quality": 0.85, "section_id": 5235}, "so_33479631_33480126_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5235}, "so_33479631_33480118_2": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_33479631_33480152_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_33479631_33480118_3": {"length": 5, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_33479631_33479631_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6867}, "so_33479631_33480118_0": {"length": 14, "quality": 0.5384615384615384, "section_id": 6890}, "so_33479631_33480126_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 6867}, "so_33479631_33480118_2": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33479631_33480152_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_33479631_33480118_3": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33479631_33480118_1": {"length": 17, "quality": 0.85, "section_id": 6867}}}, "33480152": {"Id": "33480152", "PostTypeId": "2", "Body": "<p>[dcl.spec.auto]/7 mandates  that, roughly speaking, the return type is obtained by applying <code>decltype</code> to the expression in the <code>return</code> statement. Thus, as the comment suggests, we're looking for <code>decltype((x))</code>. A fiendish rule steps in:</p>\n<p><a href=\"https://i.stack.imgur.com/Q7gXr.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Q7gXr.png\"/></a></p>\n<p>Note that the first bullet point does not apply since the expression <em>is</em> parenthesized. Hence we get <code>int&amp;</code>.</p>\n<hr>\n<p>This distinction between applications of <code>decltype</code> on plain identifiers and parenthesized ones was introduced with revision 6 of the corresponding paper. See in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1978.pdf\" rel=\"nofollow noreferrer\">revision 5</a>, \u00a72.3:</p>\n<blockquote>\n<p id=\"so_33479631_33480152_0\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ol>\n<li>If <code>e</code> is of the form <code>(e1)</code>, <code>decltype(e)</code> is defined as <code>decltype(e1)</code>.</li>\n</ol>\n</blockquote>\n<p>The justification behind this is presumably the following: Writing <code>(x)</code>, the programmer intends <code>decltype</code> to not treat the operand as a name but rather an expression - considering its value category. </p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-02T15:36:35.237", "Score": "5", "CreationDate": "2015-11-02T14:40:43.010", "ParentId": "33479631", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-11-02T15:36:35.237"}, "33480165": {"Id": "33480165", "PostTypeId": "2", "Body": "<p><code>decltype</code> returns the declared type of a variable, or the \"type\" of an expression (with some reference added to indicate l/r valueness).</p>\n<p>This lets it be used for two different purposes.  Sometimes this causes confusion, but it is what it is.</p>\n<p>The token <code>x</code> is a variable.  The type of the variable is <code>int</code>.</p>\n<p>The tokens <code>(x)</code> are <em>not</em> a variable, but rather a (really trivial) expression containing nothing but one variable.  As such, the type of the <em>expression</em> (as determined by decltype) <code>(x)</code> is <code>int&amp;</code>.</p>\n<p>The type of the expression <code>x</code> (if you could convince decltype to give it to you; you cannot) is also <code>int&amp;</code>, but the rule that the <code>decltype(ACTUAL_VAR_NAME)</code> evaluates to the type of the variable \"wins\".</p>\n<p>Now, none of the above is true.  The actual truth is a quote of the standard which describes the steps that a compiler is supposed to go through to determine what type <code>decltype</code> returns.  But it is an effective lie, and one (if the standard wording turned out to have errors) that might indicate the standard has a bug when it disagrees with it.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-11-02T14:57:20.913", "Score": "8", "CreationDate": "2015-11-02T14:41:21.023", "ParentId": "33479631", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2015-11-02T14:57:20.913"}, "33479631": {"ViewCount": "948", "Body": "<p>Given:</p>\n<pre><code>decltype(auto) f1()\n{\n    int x = 0;\n    return x;  // decltype(x) is int, so f1 returns int\n}\ndecltype(auto) f2()\n{\n    int x = 0;\n    return (x);  // decltype((x)) is int&amp;, so f2 returns int&amp;\n}\n</code></pre>\n<p>(Taken from Scott Meyer's Effective Modern C++).</p>\n<p>Now, if I have found the correct paragraph, <strong>Section 7.1.5.2 Simple type specifiers [dcl.type.simple]</strong> of the C++ standard says:</p>\n<blockquote>\n<p id=\"so_33479631_33479631_0\">If e is an id-expression or a class member access (5.2.5 [expr.ref]),\n  decltype(e) is defined as the type of the entity named by e</p>\n</blockquote>\n<p>and the example from that section is:</p>\n<pre><code>struct A { double x; }\n\nconst A* a = new A();\n\ndecltype((a-&gt;x)); // type is const double&amp;\n</code></pre>\n<p>Now, I wonder why is the <code>decltype((x))</code> is deduced to be <code>int&amp;</code> in the book.</p>\n", "Title": "Type of (x) in C++", "CreationDate": "2015-11-02T14:13:36.400", "LastActivityDate": "2015-11-02T18:04:04.140", "CommentCount": "14", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-11-02T17:54:25.227", "Tags": "<c++><language-lawyer><c++14><decltype>", "Id": "33479631", "LastEditorUserId": "719662", "Score": "21", "OwnerUserId": "186193", "ClosedDate": "2015-11-02T18:40:12.530", "AnswerCount": "5"}});