post_cb({"21206359": {"CommentCount": "12", "AcceptedAnswerId": "21206446", "PostTypeId": "1", "LastEditorUserId": "150634", "CreationDate": "2014-01-18T15:54:19.763", "LastActivityDate": "2014-01-19T13:59:10.063", "LastEditDate": "2014-01-18T16:31:53.517", "ViewCount": "10715", "FavoriteCount": "11", "Title": "In which situations is the C++ copy constructor called?", "Id": "21206359", "Score": "24", "Body": "<p>I know of the following situations in c++ where the copy constructor would be invoked:</p>\n<ol>\n<li><p>when an existing object is assigned an object of it own class</p>\n<pre><code>MyClass A,B;\nA = new MyClass();\nB=A; //copy constructor called \n</code></pre></li>\n<li><p>if a functions receives as argument, passed by value, an object of a class</p>\n<pre><code>void foo(MyClass a);\nfoo(a); //copy constructor invoked\n</code></pre></li>\n<li><p>when a function returns (by value) an object of the class</p>\n<pre><code>MyClass foo ()\n   {\n      MyClass temp;\n      ....\n      return temp; //copy constructor called\n   } \n</code></pre></li>\n</ol>\n<p>Please feel free to correct any mistakes I've made; but I am more curious if there are any other situations in which the copy constructor is called.</p>\n", "Tags": "<c++><visual-c++><constructor><copy-constructor>", "OwnerUserId": "2978901", "AnswerCount": "7"}, "21206490": {"ParentId": "21206359", "CommentCount": "1", "Body": "<p>Situation (1) is incorrect and does not compile the way you've written it. It should be:</p>\n<pre><code>MyClass A, B;\nA = MyClass(); /* Redefinition of `A`; perfectly legal though superfluous: I've\n                  dropped the `new` to defeat compiler error.*/\nB = A; // Assignment operator called (`B` is already constructed)\nMyClass C = B; // Copy constructor called.\n</code></pre>\n<p>You are correct in case (2).</p>\n<p>But in case (3), the copy constructor may not be called: if the compiler can detect no side effects then it can implement <em>return value optimisation</em> to optimise out the unnecessary deep copy. C++11 formalises this with <em>rvalue references</em>.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "21206490", "Score": "10", "CreationDate": "2014-01-18T16:07:22.383", "LastActivityDate": "2014-01-18T16:07:22.383"}, "21206750": {"ParentId": "21206359", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_21206359_21206750_0\">When an existing object is assigned an object of it own class</p>\n<pre><code>    B = A;\n</code></pre>\n</blockquote>\n<p>Not necessarily. This kind of assignment is called <em>copy-assignment</em>, meaning the assignment operator of the class will be called to perform memberwise assignment of all the data members. The actual function is <code>MyClass&amp; operator=(MyClass const&amp;)</code></p>\n<p><strong>The copy-constructor is not invoked here</strong>. This is because the assignment operator takes a reference to its object, and therefore no copy-construction is performed.</p>\n<p>Copy-assignment is different from <em>copy-initialization</em> because copy-initialization is only done when an object is being initialized. For example:</p>\n<pre><code>T y = x;\n  x = y;\n</code></pre>\n<p>The first expression initializes <code>y</code> by copying <code>x</code>. It invokes the copy-constructor <code>MyClass(MyClass const&amp;)</code>.</p>\n<p>And as mentioned, <code>x = y</code> is a call to the assignment operator.</p>\n<p><sub>(There is also something called <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow noreferrer\"><em>copy-elison</em></a> whereby the compiler will elide calls to the copy-constructor. Your compiler more than likely uses this).</sub></p>\n<hr>\n<blockquote>\n<p id=\"so_21206359_21206750_1\">If a functions receives as argument, passed by value, an object of a class</p>\n<pre><code>    void foo(MyClass a);\n    foo(a);\n</code></pre>\n</blockquote>\n<p>This is correct. However, note that in C++11 if <code>a</code> is an xvalue and if <code>MyClass</code> has the appropriate constructor <code>MyClass(MyClass&amp;&amp;)</code>, <code>a</code> can be <a href=\"https://stackoverflow.com/questions/3106110/what-is-move-semantics\"><em>moved</em></a> into the parameter.</p>\n<p><sub>(The copy-constructor and the move-constructor are two of the default compiler-generated member functions of a class. If you do not supply them yourself, the compiler will generously do so for you under specific circumstances).</sub></p>\n<hr>\n<blockquote>\n<p id=\"so_21206359_21206750_2\">When a function returns (by value) an object of the class</p>\n<pre><code>    MyClass foo ()\n    {\n        MyClass temp;\n        ....\n        return temp; // copy constructor called\n    }\n</code></pre>\n</blockquote>\n<p>Through <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow noreferrer\">return-value optimization</a>, as mentioned in some of the answers, the compiler can remove the call to the copy-constructor. By using the compiler option <a href=\"http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/C_002b_002b-Dialect-Options.html\" rel=\"nofollow noreferrer\"><strong><code>-fno-elide-constructors</code></strong></a>, you can disable copy-elison and see that the copy-constructor would indeed be called in these situations.</p>\n</hr></hr>", "OwnerUserId": "701092", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:44.547", "Id": "21206750", "Score": "16", "CreationDate": "2014-01-18T16:31:06.213", "LastActivityDate": "2014-01-19T13:59:10.063"}, "21206519": {"ParentId": "21206359", "CommentCount": "0", "Body": "<p>This is basically correct (other than your typo in #1).</p>\n<p>One additional specific scenario to watch out for is when you have elements in a container, the elements may be copied at various times (for example, in a vector, when the vector grows or some elements are removed). This is actually just an example of #1, but it can be easy to forget about it.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "21206519", "Score": "5", "CreationDate": "2014-01-18T16:09:25.373", "LastActivityDate": "2014-01-18T16:09:25.373"}, "21206457": {"ParentId": "21206359", "CommentCount": "0", "Body": "<p>There are 3 situations in which the copy constructor is called:\nWhen we make copy of an object.\nWhen we pass an object as an argument by value to a method.\nWhen we return an object from a method by value.</p>\n<p>these are the only situations....i think...</p>\n", "OwnerUserId": "3198681", "PostTypeId": "2", "Id": "21206457", "Score": "5", "CreationDate": "2014-01-18T16:03:19.177", "LastActivityDate": "2014-01-18T16:03:19.177"}, "21206474": {"ParentId": "21206359", "CommentCount": "2", "Body": "<p>The following are the cases when copy constructor is called.</p>\n<ol>\n<li>When instantiating one object and initializing it with values from another object. </li>\n<li>When passing an object by value. </li>\n<li>When an object is returned from a function by value.</li>\n</ol>\n", "OwnerUserId": "3205764", "PostTypeId": "2", "Id": "21206474", "Score": "3", "CreationDate": "2014-01-18T16:05:43.923", "LastActivityDate": "2014-01-18T16:05:43.923"}, "21206446": {"ParentId": "21206359", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I might be wrong about this, but this class allows you to see what is called and when:</p>\n<pre><code>class a {\npublic:\n    a() {\n        printf(\"constructor called\\n\");\n    };  \n    a(const a&amp; other) { \n        printf(\"copy constructor called\\n\");\n    };    \n    a&amp; operator=(const a&amp; other) {\n        printf(\"copy assignment operator called\\n\");\n        return *this; \n    };\n};\n</code></pre>\n<p>So then this code:</p>\n<pre><code>a b; //constructor\na c; //constructor\nb = c; //copy assignment\nc = a(b); //copy constructor, then copy assignment\n</code></pre>\n<p>produces this as the result:</p>\n<pre><code>constructor called\nconstructor called\ncopy assignment operator called\ncopy constructor called\ncopy assignment operator called\n</code></pre>\n<p>Another interesting thing, say you have the following code:</p>\n<pre><code>a* b = new a(); //constructor called\na* c; //nothing is called\nc = b; //still nothing is called\nc = new a(*b); //copy constructor is called\n</code></pre>\n<p>This occurs because when you when you assign a pointer, that does nothing to the actual object.</p>\n", "OwnerUserId": "2159051", "LastEditorUserId": "2159051", "LastEditDate": "2014-01-18T16:07:49.650", "Id": "21206446", "Score": "16", "CreationDate": "2014-01-18T16:02:34.223", "LastActivityDate": "2014-01-18T16:07:49.650"}, "21209462": {"ParentId": "21206359", "CommentCount": "0", "Body": "<p>Others have provided good answers, with explanations and references. </p>\n<p>In addition, I have written a class to check the different type of instantations/assigments (C++11 ready),  within an extensive test: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;functional&gt;\n\n\ntemplate&lt;typename T , bool MESSAGES = true&gt;\nclass instantation_profiler\n{\nprivate:\n    static std::size_t _alive , _instanced , _destroyed ,\n                       _ctor , _copy_ctor , _move_ctor ,\n                       _copy_assign , _move_assign;\n\n\npublic:\n    instantation_profiler()\n    {\n        _alive++;\n        _instanced++;\n        _ctor++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; construction\" &lt;&lt; std::endl;\n    }\n\n    instantation_profiler( const instantation_profiler&amp; )\n    {\n        _alive++;\n        _instanced++;\n        _copy_ctor++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; copy construction\" &lt;&lt; std::endl;\n    }\n\n    instantation_profiler( instantation_profiler&amp;&amp; )\n    {\n        _alive++;\n        _instanced++;\n        _move_ctor++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; move construction\" &lt;&lt; std::endl;\n    }\n\n    instantation_profiler&amp; operator=( const instantation_profiler&amp; )\n    {\n        _copy_assign++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; copy assigment\" &lt;&lt; std::endl;\n    }\n\n    instantation_profiler&amp; operator=( instantation_profiler&amp;&amp; )\n    {\n        _move_assign++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; move assigment\" &lt;&lt; std::endl;\n    }\n\n    ~instantation_profiler()\n    {\n        _alive--;\n        _destroyed++;\n\n        if( MESSAGES ) std::cout &lt;&lt; \"&gt;&gt; destruction\" &lt;&lt; std::endl;\n    }\n\n\n\n    static std::size_t alive_instances()\n    {\n        return _alive;\n    }\n\n    static std::size_t instantations()\n    {\n        return _instanced;\n    }\n\n    static std::size_t destructions()\n    {\n        return _destroyed;\n    }\n\n    static std::size_t normal_constructions()\n    {\n        return _ctor;\n    }\n\n    static std::size_t move_constructions()\n    {\n        return _move_ctor;\n    }\n\n    static std::size_t copy_constructions()\n    {\n        return _copy_ctor;\n    }\n\n    static std::size_t move_assigments()\n    {\n        return _move_assign;\n    }\n\n    static std::size_t copy_assigments()\n    {\n        return _copy_assign;\n    }\n\n\n    static void print_info( std::ostream&amp; out = std::cout )\n    {\n        out &lt;&lt; \"# Normal constructor calls: \"  &lt;&lt; normal_constructions() &lt;&lt; std::endl\n            &lt;&lt; \"# Copy constructor calls: \"    &lt;&lt; copy_constructions()   &lt;&lt; std::endl\n            &lt;&lt; \"# Move constructor calls: \"    &lt;&lt; move_constructions()   &lt;&lt; std::endl\n            &lt;&lt; \"# Copy assigment calls: \"      &lt;&lt; copy_assigments()      &lt;&lt; std::endl\n            &lt;&lt; \"# Move assigment calls: \"      &lt;&lt; move_assigments()      &lt;&lt; std::endl\n            &lt;&lt; \"# Destructor calls: \"          &lt;&lt; destructions()         &lt;&lt; std::endl\n            &lt;&lt; \"# \"                                                      &lt;&lt; std::endl\n            &lt;&lt; \"# Total instantations: \"       &lt;&lt; instantations()        &lt;&lt; std::endl\n            &lt;&lt; \"# Total destructions: \"        &lt;&lt; destructions()         &lt;&lt; std::endl\n            &lt;&lt; \"# Current alive instances: \"   &lt;&lt; alive_instances()      &lt;&lt; std::endl;\n    }\n};\n\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_alive       = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_instanced   = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_destroyed   = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_ctor        = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_copy_ctor   = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_move_ctor   = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_copy_assign = 0;\ntemplate&lt;typename T , bool MESSAGES&gt;\nstd::size_t instantation_profiler&lt;T,MESSAGES&gt;::_move_assign = 0;\n</code></pre>\n<p>Here is the test:</p>\n<pre><code>struct foo : public instantation_profiler&lt;foo&gt;\n{\n    int value;\n};\n\n\n\n//Me suena bastante que Boost tiene una biblioteca con una parida de este estilo...\nstruct scoped_call\n{\nprivate:\n    std::function&lt;void()&gt; function; \n\npublic:\n    scoped_call( const std::function&lt;void()&gt;&amp; f ) : function( f ) {}\n\n    ~scoped_call()\n    {\n        function();\n    }\n};\n\n\nfoo f()\n{\n    scoped_call chapuza( [](){ std::cout &lt;&lt; \"Exiting f()...\" &lt;&lt; std::endl; } );\n\n    std::cout &lt;&lt; \"I'm in f(), which returns a foo by value!\" &lt;&lt; std::endl;\n\n    return foo();\n}\n\n\nvoid g1( foo )\n{\n    scoped_call chapuza( [](){ std::cout &lt;&lt; \"Exiting g1()...\" &lt;&lt; std::endl; } );\n\n    std::cout &lt;&lt; \"I'm in g1(), which gets a foo by value!\" &lt;&lt; std::endl;\n}\n\nvoid g2( const foo&amp; )\n{\n    scoped_call chapuza( [](){ std::cout &lt;&lt; \"Exiting g2()...\" &lt;&lt; std::endl; } );\n\n    std::cout &lt;&lt; \"I'm in g2(), which gets a foo by const lvalue reference!\" &lt;&lt; std::endl;\n}\n\nvoid g3( foo&amp;&amp; )\n{\n    scoped_call chapuza( [](){ std::cout &lt;&lt; \"Exiting g3()...\" &lt;&lt; std::endl; } );\n\n    std::cout &lt;&lt; \"I'm in g3(), which gets an rvalue foo reference!\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\nvoid h( T&amp;&amp; afoo )\n{\n    scoped_call chapuza( [](){ std::cout &lt;&lt; \"Exiting h()...\" &lt;&lt; std::endl; } );\n\n    std::cout &lt;&lt; \"I'm in h(), which sends a foo to g() through perfect forwarding!\" &lt;&lt; std::endl;\n\n    g1( std::forward&lt;T&gt;( afoo ) );\n}\n\n\nint main()\n{\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before a declaration ( foo a; )\"                &lt;&lt; std::endl;                                        foo a;\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before b declaration ( foo b; )\"                &lt;&lt; std::endl;                                        foo b;\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before c declaration ( foo c; )\"                &lt;&lt; std::endl;                                        foo c;\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before d declaration ( foo d( f() ); )\"         &lt;&lt; std::endl;                                        foo d( f() );\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before a to b assigment ( b = a )\"              &lt;&lt; std::endl;                                        b = a;\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before ctor call to b assigment ( b = foo() )\"  &lt;&lt; std::endl;                                        b = foo();\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before f() call to b assigment ( b = f() )\"     &lt;&lt; std::endl;                                        b = f();\n\n\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g1( foo ) call with lvalue arg ( g1( a ) )\"                         &lt;&lt; std::endl;             g1( a );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g1( foo ) call with rvalue arg ( g1( f() ) )\"                       &lt;&lt; std::endl;             g1( f() );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g1( foo ) call with lvalue ==&gt; rvalue arg ( g1( std::move( a ) ) )\" &lt;&lt; std::endl;             g1( std::move( a ) );\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g2( const foo&amp; ) call with lvalue arg ( g2( b ) )\"                          &lt;&lt; std::endl;     g2( b );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g2( const foo&amp; ) call with rvalue arg ( g2( f() ) )\"                        &lt;&lt; std::endl;     g2( f() );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g2( const foo&amp; ) call with lvalue ==&gt; rvalue arg ( g2( std::move( b ) ) )\"  &lt;&lt; std::endl;     g2( std::move( b ) );\n\n  //std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g3( foo&amp;&amp; ) call with lvalue arg ( g3( c ) )\"                         &lt;&lt; std::endl;           g3( c );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g3( foo&amp;&amp; ) call with rvalue arg ( g3( f() ) )\"                       &lt;&lt; std::endl;           g3( f() );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before g3( foo&amp;&amp; ) call with lvalue ==&gt; rvalue arg ( g3( std::move( c ) ) )\" &lt;&lt; std::endl;           g3( std::move( c ) );\n\n\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before h() call with lvalue arg ( h( d ) )\"                         &lt;&lt; std::endl;                    h( d );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before h() call with rvalue arg ( h( f() ) )\"                       &lt;&lt; std::endl;                    h( f() );\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Just before h() call with lvalue ==&gt; rvalue arg ( h( std::move( d ) ) )\" &lt;&lt; std::endl;                    h( std::move( d ) );\n\n    foo::print_info( std::cout );\n}\n</code></pre>\n<p>This is an abstract of the test compiled with <code>GCC 4.8.2</code> with <code>-O3</code> and <code>-fno-elide-constructors</code> flags:</p>\n<blockquote>\n<p id=\"so_21206359_21209462_0\">Normal constructor calls: 10<br>\n  Copy constructor calls: 2<br>\n  Move constructor calls: 11<br>\n  Copy assigment calls: 1<br>\n  Move assigment calls: 2<br>\n  Destructor calls: 19  </br></br></br></br></br></p>\n<p id=\"so_21206359_21209462_1\">Total instantations: 23<br>\n  Total destructions: 19<br>\n  Current alive instances: 4  </br></br></p>\n</blockquote>\n<p>Finally the same test with copy elision enabled:</p>\n<blockquote>\n<p id=\"so_21206359_21209462_2\">Normal constructor calls: 10<br>\n  Copy constructor calls: 2<br>\n  Move constructor calls: 3<br>\n  Copy assigment calls: 1<br>\n  Move assigment calls: 2<br>\n  Destructor calls: 11  </br></br></br></br></br></p>\n<p id=\"so_21206359_21209462_3\">Total instantations: 15<br>\n  Total destructions: 11<br>\n  Current alive instances: 4  </br></br></p>\n</blockquote>\n<p><a href=\"http://ideone.com/WDLjb9\" rel=\"nofollow\">Here</a> is the complete code running at ideone.</p>\n", "OwnerUserId": "1609356", "PostTypeId": "2", "Id": "21209462", "Score": "2", "CreationDate": "2014-01-18T20:28:05.960", "LastActivityDate": "2014-01-18T20:28:05.960"}, "bq_ids": {"n4140": {"so_21206359_21206750_2": {"section_id": 480, "quality": 0.8333333333333334, "length": 5}, "so_21206359_21206750_0": {"section_id": 449, "quality": 0.7142857142857143, "length": 5}, "so_21206359_21206750_1": {"section_id": 577, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_21206359_21206750_2": {"section_id": 471, "quality": 0.8333333333333334, "length": 5}, "so_21206359_21206750_0": {"section_id": 440, "quality": 0.7142857142857143, "length": 5}, "so_21206359_21206750_1": {"section_id": 567, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_21206359_21206750_2": {"section_id": 394, "quality": 0.8333333333333334, "length": 5}, "so_21206359_21206750_0": {"section_id": 471, "quality": 0.7142857142857143, "length": 5}, "so_21206359_21206750_1": {"section_id": 180, "quality": 0.5714285714285714, "length": 4}}}});