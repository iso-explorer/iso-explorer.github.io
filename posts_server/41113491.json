post_cb({"bq_ids": {"n4140": {"so_41113491_41113647_0": {"length": 14, "quality": 1.0, "section_id": 6107}, "so_41113491_41113721_2": {"length": 14, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_41113491_41113647_0": {"length": 14, "quality": 1.0, "section_id": 5873}, "so_41113491_41113721_2": {"length": 14, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_41113491_41113647_0": {"length": 14, "quality": 1.0, "section_id": 7604}, "so_41113491_41113721_2": {"length": 14, "quality": 1.0, "section_id": 7604}}}, "41113721": {"Id": "41113721", "PostTypeId": "2", "Body": "<p>Given,</p>\n<pre><code>Base* p = Derived[4];\n</code></pre>\n<p>the C++11 Standard makes </p>\n<pre><code>delete [] p;\n</code></pre>\n<p>to be undefined behavior.</p>\n<blockquote>\n<p id=\"so_41113491_41113721_0\"><strong>5.3.5 Delete</strong></p>\n<p id=\"so_41113491_41113721_1\">...</p>\n<p id=\"so_41113491_41113721_2\">2 ... In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>From a memory layout point of view, it also makes sense why <code>delete [] p;</code> will result in undefined behavior.</p>\n<p>If <code>sizeof(Derived)</code> is <code>N</code>, <code>new Derived[4]</code> allocates memory that will be something like:</p>\n<pre><code>+--------+--------+--------+--------+\n|   N    |   N    |   N    |   N    |\n+--------+--------+--------+--------+\n</code></pre>\n<p>In general, <code>sizeof(Base)</code> &lt;= <code>sizeof(Derived)</code>. In your case, <code>sizeof(Base)</code> &lt; <code>sizeof(Derived)</code> since <code>Derived</code> has an additional member variable.</p>\n<p>When you use:</p>\n<pre><code>Base* p = new Derived[4];\n</code></pre>\n<p>you have:</p>\n<pre><code>p\n|\nV\n+--------+--------+--------+--------+\n|   N    |   N    |   N    |   N    |\n+--------+--------+--------+--------+\n</code></pre>\n<p><code>p+1</code> points to someplace in the middle of the first object since <code>sizeof(Base) &lt; sizeof(Derived)</code>.</p>\n<pre><code>       p+1\n       |\n       V\n+--------+--------+--------+--------+\n|   N    |   N    |   N    |   N    |\n+--------+--------+--------+--------+\n</code></pre>\n<p>When the destructor is called on <code>p+1</code>, the pointer does not point to the start of an object. Hence, the program exhibits symptoms of undefined behavior.</p>\n<hr>\n<p><strong>A Related Problem</strong></p>\n<p>Due to the differences in sizes of <code>Base</code> and <code>Derived</code>, you cannot iterate over the elements of the dynamically allocated array using <code>p</code>.</p>\n<pre><code>for ( int i = 0; i &lt; 4; ++i )\n{\n   // Do something with p[i]\n   // will not work since p+i does not necessary point to an object\n   // boundary.\n}\n</code></pre>\n</hr>", "LastEditorUserId": "434551", "LastActivityDate": "2016-12-13T05:59:15.367", "Score": "20", "CreationDate": "2016-12-13T04:26:33.913", "ParentId": "41113491", "CommentCount": "3", "OwnerUserId": "434551", "LastEditDate": "2016-12-13T05:59:15.367"}, "41113647": {"Id": "41113647", "PostTypeId": "2", "Body": "<p>You get undefined behavior because operator <code>delete[]</code> has no idea what kind of object is stored in the array, so it trusts the static type to decide on offsets of individual objects. The standard says the following:</p>\n<blockquote>\n<p id=\"so_41113491_41113647_0\">In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined. </p>\n</blockquote>\n<p>The array's static type needs to match the element type that you use for the allocation:</p>\n<pre><code>Derived* p = new Derived[4]; // Obviously, this works\n</code></pre>\n<p><a href=\"https://stackoverflow.com/q/6171814/335858\">This Q&amp;A</a> goes into more details on the reason why the standard has this requirement.</p>\n<p>As far as fixing this behavior, you need to create an array of pointers, regular or smart (preferably smart to simplify memory management). </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-13T10:19:48.590", "Score": "14", "CreationDate": "2016-12-13T04:17:51.087", "ParentId": "41113491", "CommentCount": "2", "OwnerUserId": "335858", "LastEditDate": "2017-05-23T10:30:56.513"}, "41116082": {"Id": "41116082", "PostTypeId": "2", "Body": "<p>It has to do with the concepts of <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\" rel=\"nofollow noreferrer\"><strong>covariance</strong> and <strong>contravariance</strong></a>. I'll give an example that should hopefully clarify things.</p>\n<p>We'll start with a simple hierarchy. Suppose we're dealing with creating and destroying objects in the real world. We have 3D objects (such as wooden blocks) and 2D objects (such as sheets of paper). A 2D object can be treated like a 3D object, except with negligible height. This is the proper subclassing direction, since the reverse is not true; 2D objects can be laid flat on top of each other, something which is very difficult at best to do with arbitrary 3D objects.</p>\n<p>Something that produces objects, like a printer, is <strong>covariant</strong>. Suppose your friend wants to borrow a 3D printer, take ten objects that it produces, and stick them in a box. You can give them a 2D printer; it will print ten pages, and your friend will stick them in a box. However, if that friend wanted to take ten 2D objects and stick them in a folder, you couldn't give them a 3D printer.</p>\n<p>Something that consumes objects, like a shredder, is <strong>contravariant</strong>. Your friend has the folder with the pages it printed, but it didn't sell, so he wants to shred it. You can give them a 3D shredder, like the industrial ones used for shredding things like cars, and it will work just fine; feeding it pages causes it no hardship at all. On the other hand, if he wanted to shred the box of objects he got earlier, you couldn't give him the 2D shredder, as the objects may not fit into the slot.</p>\n<p>Arrays are <strong>invariant</strong>; they both consume objects (with assignment) and produce objects (with array access). As an example of this kind of relation, take a fax machine of some kind. If your friend wants a fax machine, they need the exact kind they're asking for; they can't have a super- or subclass, as you can't stick 3D objects into a slot for 2D paper, and you can't bind objects produced by a 3D fax machine into a book.</p>\n", "LastActivityDate": "2016-12-13T07:57:52.067", "CommentCount": "0", "CreationDate": "2016-12-13T07:57:52.067", "ParentId": "41113491", "Score": "4", "OwnerUserId": "4416280"}, "41115572": {"Id": "41115572", "PostTypeId": "2", "Body": "<p>While the other two answers (<a href=\"https://stackoverflow.com/a/41113647/2893496\">here</a> and <a href=\"https://stackoverflow.com/a/41113721/2893496\">here</a>) have approached the problem from the technical side and very well explained why the compiler would have an impossible task trying to compile the code that you have given it, they did not explain the conceptual problem with your question.</p>\n<p>Polymorphism can <strong>only</strong> work when we are talking about Class-Subclass relationship. So when we have the situation as you have coded we have:</p>\n<p><a href=\"https://i.stack.imgur.com/CibiX.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/CibiX.png\"/></a></p>\n<p>We are saying \"All instances of the <code>Derived</code> are also instances of <code>Base</code>\". Note that this <strong>must</strong> hold or we cannot even begin to talk about polymorphism. In this case it holds and thus we can use the pointer to <code>Derived</code> where the code expects a pointer to <code>Base</code>.</p>\n<p>But then you are attempting to do something different:</p>\n<p><a href=\"https://i.stack.imgur.com/4VZrY.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4VZrY.png\"/></a></p>\n<p>And here we have a problem. While in set theory we could say that a set of a subclass is also a set of a superclass, it is not true in programming. The problem is somewhat increased by the fact that the difference is \"only two characters\". But the array of elements is in a way a completely different thing then any one of those elements.</p>\n<p>Perhaps if you rewrote the code using <code>std::array</code> template that would become more clear:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nstruct Base\n{   \n    virtual ~Base()\n    {\n        std::cout &lt;&lt; \"~Base()\" &lt;&lt; std::endl;\n    }\n};\n\nstruct Derived : Base\n{   \n    ~Derived() override\n    {\n        std::cout &lt;&lt; \"~Derived()\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    std::array&lt;Base, 4&gt;* p = new std::array&lt;Derived, 4&gt;;\n    delete[] p;\n}\n</code></pre>\n<p>This code can clearly not compile, templates are do not become subclasses of one another depending upon their parameters. In a way this would be like expecting a pointer to one class to become a pointer to a completely unrelated class, this will simply not work.</p>\n<p>Hopefully this will help some people who want a more intuitive understanding of what is happening, rather than a technical explanation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-13T07:20:44.667", "Score": "2", "CreationDate": "2016-12-13T07:20:44.667", "ParentId": "41113491", "CommentCount": "0", "OwnerUserId": "2893496", "LastEditDate": "2017-05-23T11:47:35.397"}, "41113491": {"ViewCount": "1095", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Base\n{\n    virtual ~Base()\n    {\n        cout &lt;&lt; \"~Base(): \" &lt;&lt; b &lt;&lt; endl;\n    }\n\n    int b = 1;\n};\n\nstruct Derived : Base\n{\n    ~Derived() override\n    {\n        cout &lt;&lt; \"~Derived(): \" &lt;&lt; d &lt;&lt; endl;\n    }\n\n    int d = 2;\n};\n\nint main()\n{\n    Base* p = new Derived[4];\n    delete[] p;\n}\n</code></pre>\n<p>The output is as follws: (Visual Studio 2015 with Clang 3.8)</p>\n<pre><code>~Base(): 1\n~Base(): 2\n~Base(): -2071674928\n~Base(): 1\n</code></pre>\n<p>Why does polymorphism not apply on arrays in C++?</p>\n", "AcceptedAnswerId": "41113647", "Title": "Why does polymorphism not apply on arrays in C++?", "CreationDate": "2016-12-13T03:56:10.117", "LastActivityDate": "2016-12-13T10:19:48.590", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "Tags": "<c++><polymorphism><standards><virtual><destructor>", "Id": "41113491", "Score": "16", "OwnerUserId": "508343", "ClosedDate": "2016-12-13T09:35:46.547", "AnswerCount": "4"}});