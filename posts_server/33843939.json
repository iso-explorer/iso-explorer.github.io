post_cb({"33844221": {"ParentId": "33843939", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There's isn't in the standard something straightforward to state that</p>\n<blockquote>\n<p id=\"so_33843939_33844221_0\">if i = v.begin(), then ++i shall refer to the second element in the\n  vector.</p>\n</blockquote>\n<p>However, for vector's iterators why can imply it from the following wording in the draft standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> <em>24.2.1/p5 In general [iterator.requirements.general]:</em></p>\n<blockquote>\n<p id=\"so_33843939_33844221_1\">Iterators that further satisfy the requirement that, for integral\n  values <code>n</code> and dereferenceable iterator values <code>a</code> and <code>(a + n)</code>, <code>*(a + n)</code> is equivalent to <code>*(addressof(*a) + n)</code>, are called contiguous\n  iterators.</p>\n</blockquote>\n<p>Now, <code>std::vector</code>'s iterator satisfy this requirement, consequently we can imply that <code>++i</code> is equivalent to <code>i + 1</code> and thus to <code>addressof(*i) + 1</code>. Which indeed is the second element in the vector due to its contiguous nature.</p>\n<p>Edit:</p>\n<p>There was indeed a turbidness on the matter about <code>random</code> access iterators and contiguous storage containers in C++11 and C++14 standards. Thus, the commity decided to refine them by putting an extra group of iterators named <strong>contiguous iterators</strong>. You can find more info in the relative proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf\" rel=\"nofollow\">N3884</a>.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-11-21T14:30:14.577", "Id": "33844221", "Score": "3", "CreationDate": "2015-11-21T14:01:39.467", "LastActivityDate": "2015-11-21T14:30:14.577"}, "33844991": {"ParentId": "33843939", "CommentCount": "1", "Body": "<p>The specification isn't just in the iterators.   It is also in the specification of the containers, and the operations that modify those containers.</p>\n<p>The thing is, you are not going to find a single clause that says \"incrementing <code>begin()</code> repeatedly will access all elements of a vector in order\".   You need to look at the specification of every operation on every container (since these define an order of elements in the container) and the specification of iterators (and operations on them) which is essentially that \"incrementing moves to the next element in the order that operations on the container defined, until we pass the end\".     It is the combination of numerous clauses in the standard that give the end effect.</p>\n<p>The general concepts, however, are ....</p>\n<p>All containers maintain some range of zero or more elements.    That range has three key properties:  a beginning (corresponding to the first element in an order that is meaningful to the container), and an end (corresponding to the last element), and an order (which determines the sequence in which elements will be retrieved one after the other - i.e. defines the meaning of \"next\"). </p>\n<p>An iterator is an object that either references an element in a range, or has a \"past the end\" value.    An iterator that references an element in the range other than the end (last), when incremented, will reference the next element.   An iterator that references the end (last) element in the range, when incremented, will be an end (past the end) iterator.</p>\n<p>The <code>begin()</code> method returns an iterator that references (or points to) the first in the range (or an end iterator if the range has zero elements).   The <code>end()</code> method returns an end iterator - one that corresponds to \"one past the the end of the range\".  That means, if an iterator is initialised using the <code>begin()</code>, incrementing it repeatedly will move sequentially through the range until the end iterator is reached.</p>\n<p>Then it is necessary to look at the specification for the various modifiers of the container - the member functions that add or remove elements.   For example, <code>push_back()</code> is specified as adding an element to the end of the existing range for that container.   It extends the range by adding an element to the end.</p>\n<p>It is that combination of specifications - of iterators and of operations that modify containers - that guarantees the order.    The net effect is that, if elements are added to a container in some order, then a iterator initialised using <code>begin()</code> will - when incremented repeatedly - reference the elements in the order in which they were placed in the container.</p>\n<p>Obviously, some container modifiers are a bit more complicated - for example, <code>std::vector</code>'s <code>insert()</code> is given an iterator, and adds elements there, shuffling subsequent elements to make room.    However, the key point is that the modifiers place elements into the container in a defined order (or remove, in the case of operations like <code>std::vector::erase()</code>) and iterators will access elements in that defined order.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "33844991", "Score": "0", "CreationDate": "2015-11-21T15:16:24.503", "LastActivityDate": "2015-11-21T15:16:24.503"}, "33844489": {"ParentId": "33843939", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It looks to me like we need to put two separate parts of the standard together to get a solid requirement here. We can start with table 101, which requires that <code>a[n]</code> be equivalent to <code>*(a.begin() + n)</code> for sequence containers (specifically, <code>basic_string</code>, <code>array</code>, <code>deqeue</code> and <code>vector</code>) (and the same requirement for <code>a.at(n)</code>, for the same containers).</p>\n<p>Then we look at table 111 in [random.access.iterators], where it requires that the expression <code>r += n</code> be equivalent to:</p>\n<blockquote id=\"so_33843939_33844489_0\">\n<pre><code>{ \n    difference_type m = n;\n    if (m &gt;= 0)\n        while (m--)\n            ++r;\n    else\n        while (m++)\n            --r;\n    return r; \n}\n</code></pre>\n</blockquote>\n<p>[indentation added]</p>\n<p>Between the two, these imply that for any <code>n</code>, <code>*(begin() + n)</code> refers to the n<sup>th</sup> item in the vector. Just in case you want to cover the last base I see open, let's cover the requirement that <code>push_back</code> actually append to the collection. That's also in table 101: <code>a.push_back(t)</code> \"Appends a copy of t\" (again for <code>basic_string</code>, <code>string</code>, <code>deque</code>, <code>list</code>, and <code>vector</code>).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-11-21T14:43:49.103", "Id": "33844489", "Score": "1", "CreationDate": "2015-11-21T14:31:47.270", "LastActivityDate": "2015-11-21T14:43:49.103"}, "33844226": {"ParentId": "33843939", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_33843939_33844226_0\"><code>[C++14: 23.2.3/1]:</code> A sequence container organizes a finite set of objects, all of the same type, into a strictly linear arrangement. <em>[..]</em></p>\n</blockquote>\n<p>I don't know how else you'd interpret it.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "33844226", "Score": "0", "CreationDate": "2015-11-21T14:02:11.633", "LastActivityDate": "2015-11-21T14:02:11.633"}, "bq_ids": {"n4140": {"so_33843939_33844489_0": {"section_id": 5581, "quality": 1.0, "length": 5}, "so_33843939_33843939_0": {"section_id": 707, "quality": 1.0, "length": 7}, "so_33843939_33844226_0": {"section_id": 720, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_33843939_33844489_0": {"section_id": 5363, "quality": 1.0, "length": 5}, "so_33843939_33843939_0": {"section_id": 697, "quality": 1.0, "length": 7}, "so_33843939_33844226_0": {"section_id": 709, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_33843939_33844489_0": {"section_id": 7028, "quality": 1.0, "length": 5}, "so_33843939_33844221_1": {"section_id": 7005, "quality": 0.9285714285714286, "length": 13}, "so_33843939_33844226_0": {"section_id": 751, "quality": 0.8666666666666667, "length": 13}, "so_33843939_33843939_0": {"section_id": 736, "quality": 1.0, "length": 7}}}, "33843939": {"CommentCount": "3", "ViewCount": "87", "PostTypeId": "1", "LastEditorUserId": "388661", "CreationDate": "2015-11-21T13:32:25.217", "LastActivityDate": "2015-11-21T15:19:30.357", "Title": "C++ formal requirement of behaviour of iterators over a container", "FavoriteCount": "1", "LastEditDate": "2015-11-21T15:19:30.357", "Id": "33843939", "Score": "1", "Body": "<p>I'm sure that I'm not alone in expecting that I could add several elements in some order to a <code>vector</code> or <code>list</code>, and then could use an iterator to retrieve those elements in the same order. For example, in:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nint main(int argc, char **argv)\n{\n    using namespace std;\n    vector&lt;int&gt; v;\n    v.push_back(4);\n    v.push_back(10);\n    v.push_back(100);\n    auto i = v.begin();\n    assert(*i++ == 4);\n    assert(*i++ == 10);\n    assert(*i++ == 100);\n    return 0;\n}\n</code></pre>\n<p>... all assertions should pass and the program should terminate normally (assuming that no <code>std::bad_alloc</code> exception is thrown during construction of the vector or adding the elements to it).</p>\n<p>However, I'm having trouble reconciling this with any requirement in the C++ standard (I'm looking at C++11, but would like answers for other standards also if they are markedly different).</p>\n<p>The requirement for <code>begin()</code> is just (23.2.1 para 6):</p>\n<blockquote>\n<p id=\"so_33843939_33843939_0\">begin() returns an iterator referring to the first element in the container.</p>\n</blockquote>\n<p>What I'm looking for is the requirement, or combination of requirements that in turn logically requires, that if <code>i = v.begin()</code>, then <code>++i</code> shall refer to the second element in the vector (assuming that such an element exists) - or indeed, even the requirement that successive increments of an iterator will return each of the elements in the vector.</p>\n<p><strong>Edit:</strong></p>\n<p>A more general question is, what (if any) text in the standard requires that successfully incrementing an iterator obtained by calling <code>begin()</code> on a sequence (ordered or unordered) actually visits every element of the sequence?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "388661", "AnswerCount": "4"}});