post_cb({"bq_ids": {"n4140": {"so_15604129_15604270_1": {"length": 38, "quality": 0.926829268292683, "section_id": 4907}, "so_15604129_15604270_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 6259}}, "n3337": {"so_15604129_15604270_1": {"length": 38, "quality": 0.926829268292683, "section_id": 4702}, "so_15604129_15604270_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 6019}}, "n4659": {"so_15604129_15604270_1": {"length": 38, "quality": 0.926829268292683, "section_id": 6316}, "so_15604129_15604270_0": {"length": 41, "quality": 0.8541666666666666, "section_id": 7763}}}, "15604270": {"Id": "15604270", "PostTypeId": "2", "Body": "<p>Per Paragraph 17.6.1.2/4:</p>\n<blockquote>\n<p id=\"so_15604129_15604270_0\">Except as noted in Clauses 18 through 30 and Annex D, the contents of each header cname shall be the same\n  as that of the corresponding header name.h, as specified in the C standard library (1.2) or the C Unicode\n  TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for\n  names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace std. <strong>It is\n  unspecified whether these names are first declared within the global namespace scope and are then injected\n  into namespace std by explicit using-declarations</strong> (7.3.3).</p>\n</blockquote>\n<p>Also, per Annex D.5/2:</p>\n<blockquote>\n<p id=\"so_15604129_15604270_1\">Every C header, each of which has a name of the form name.h, <strong>behaves as if each name placed in the standard\n  library namespace by the corresponding cname header is placed within the global namespace scope</strong>. It is\n  unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace\n  std and are then injected into the global namespace scope by explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>Since the exact technique to be used for making global functions available is left up to implementations, your implementation is probably having a <code>using</code> directive such as the one below inside the <code>std</code> namespace:</p>\n<pre><code>namespace std\n{\n    using ::sqrt;\n\n    // ...\n}\n</code></pre>\n<p>Which means that <code>std::sqrt</code> actually becomes an alias for <code>::sqrt</code>, and you are providing a definition of <code>::sqrt</code> which effectively ends up calling itself recursively.</p>\n<p>The only solution is then to pick a different name.</p>\n", "LastActivityDate": "2013-03-24T21:32:41.763", "Score": "1", "CreationDate": "2013-03-24T21:32:41.763", "ParentId": "15604129", "CommentCount": "1", "OwnerUserId": "1932150"}, "15604228": {"Id": "15604228", "PostTypeId": "2", "Body": "<p><code>&lt;cmath&gt;</code> is a funny header.  It is allowed to (but not required to) make <code>::sqrt</code> and\n<code>std::sqrt</code> synonyms.  If you include it, it's best to assume\nthat both are present (or just include <code>&lt;math.h&gt;</code>, in which\ncase, <code>::sqrt</code> is all that you should get).  What's probably\nhappening in your case is that 1) <code>std::sqrt</code> is in fact a\nsynonym (via <code>using</code>) for <code>::sqrt</code>, and 2) the linker is picking\nup your <code>::sqrt</code> first, so you end up with endless recursion.\nThe only solution, short of changing the name, is to put your\n<code>sqrt</code> in a namespace.</p>\n<h2>EDIT:</h2>\n<p>Just to be clear: the above is C++11.  Earlier versions of C++ did <em>not</em> allow <code>&lt;cmath&gt;</code> to introduce anything into global namespace.  All implementations did, however, so the standard was changed to bless the practice.  (I guess that's one way of getting compilers to be standard compliant.)</p>\n<h2>EDIT:</h2>\n<p>Some additional information as to how a library \"picks up\"\nsymbols, in response to the question in comments.  Formally,\naccording to the C++ standard, you may not have two definitions\nof the same function (same name, namespace and argument types)\nin a program.  If the two definitions are in separate\ntranslation units, the behavior is undefine.  With this in mind,\nthere are several practical considerations.</p>\n<p>The first can be considered the definition of a library (or at\nleast the traditional definition).  A library is a set of\nmodules\u2014translation units, in terms of the standard.\n(Generally, but not always, the modules consist of compiled\nobject files.)  Linking in a library, however, does <em>not</em> bring\nin all of the modules in it; a module from a library is\nincorporated into your program only if it resolves an unresolved\nexternal.  Thus, if <code>::sqrt</code> is already defined (resolved)\nbefore the linker looks at the library, the module containing\n<code>::sqrt</code> in the library will not become part of your program.</p>\n<p>In practice, the term library has been abused in recent years,\nto the point where one might say that its meaning has changed.\nIn particular, what Microsoft calls \"dynamically loaded\nlibraries\" (and what were called \"shared objects\" in Unix, long\nbefore), are <em>not</em> libraries in the traditional sense, and the\nabove doesn't apply to them.  Other issues do, however, \ndepending on how the dynamic loader works.  In the case of Unix,\nif several shared objects have the same symbol, all will resolve\nto the first one loaded (by default\u2014this can be controlled\nby options passed to <code>dlopen</code>).  In the case of Windows, by\ndefault, a symbol will be resolved within the DLL if possible;\nin your case, if <code>std::sqrt</code> is an inline function, or is\nspecified as <code>using ::sqrt</code>, this will be the DLL which calls\n<code>std::sqrt</code>; if in the header, it is <code>__declspec(dllexport)</code>,\nthis will be the DLL that contains the implementation of\n<code>std::sqrt</code>.</p>\n<p>Finally, almost all linkers today support some form of weak\nreferences.  This is usually used for template instantiations:\nsomething like <code>std::vector&lt;int&gt;::vector( size_t, int )</code> will be\ninstantiated in every translation unit which uses it, but as\na \"weak\" symbol.  The linker then chooses one (probably the\nfirst it encounters, but it's not specified), and throws out all\nof the others.  While this technique is mainly used for template\ninstantiations, a compiler <em>can</em> define any function using weak\nreferences (and will do so if the function is inline).  In this\ncase, if the definitions are different (as in your case of\n<code>::sqrt</code>), then we can truly say that the program is illegal,\nsince it violates the one definition rule.  But the results are\nundefined behavior, and don't require a diagnostic.  It you\ndefine an inline function or a function template differently in\ntwo different translation units, for example, you will almost\nnever get an error; if the compiler doesn't actually inline\nthem, the linker will choose one, and use it in both translation\nunits.  In your case (<code>::sqrt</code>), I doubt that this applies;\nI would expect this to be a real library function, and not\ninlined.  (If it were inlined, the definition would be in the\nheader <code>&lt;cmath&gt;</code>, and you'd get a duplicate definition error,\nsince both definitions would be in the same translation unit.)</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2013-03-25T09:04:55.460", "Score": "3", "CreationDate": "2013-03-24T21:29:06.697", "ParentId": "15604129", "CommentCount": "4", "LastEditDate": "2013-03-25T09:04:55.460", "OwnerUserId": "649665"}, "15604184": {"Id": "15604184", "PostTypeId": "2", "Body": "<p>The problem seems to be that <code>&lt;cmath&gt;</code> is bringing in the <code>sqrt</code> name (without the <code>std::</code> namespace), as well as <code>std::sqrt</code>. I am afraid you need to use another name.</p>\n<p>See this example, using a snapshot of GCC 4.8:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n\nint main() {\n    double x = 9.0;\n    std::cout &lt;&lt; sqrt(x) &lt;&lt; '\\n'; // look, no std::sqrt\n}\n</code></pre>\n", "LastEditorUserId": "661519", "LastActivityDate": "2013-03-24T21:29:47.747", "Score": "2", "CreationDate": "2013-03-24T21:23:48.230", "ParentId": "15604129", "CommentCount": "1", "LastEditDate": "2013-03-24T21:29:47.747", "OwnerUserId": "661519"}, "15604129": {"ViewCount": "111", "Body": "<p>I wrote a very simple c++ code, where I defined a function called sqrt which just calls\nstd::sqrt. Unexpectedly, I got a segmentation fault. The problem doesn't exist if I rename\nthe function sqrt as something else. However, I can not see any naming conflict since\nthe sqrt function I defined is not in the namespace std so the two should be perfectly\nseparated. So what is the real cause of the problem? Thanks!</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n\ndouble sqrt(double d);\n\ndouble sqrt(double d) {\n    return std::sqrt(d);\n}\n\nint main() {\n    double x = 3.0;\n    std::cout &lt;&lt; \"The square root of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; sqrt(x) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "15604228", "Title": "Unknown error perhaps caused by naming conflict?", "CreationDate": "2013-03-24T21:18:15.170", "Id": "15604129", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2013-03-25T09:04:55.460", "Score": "1", "OwnerUserId": "690421", "Tags": "<c++>", "AnswerCount": "3"}});