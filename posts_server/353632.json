post_cb({"353762": {"ParentId": "353632", "CommentCount": "1", "CreationDate": "2008-12-09T18:36:15.910", "OwnerUserId": "28113", "PostTypeId": "2", "Id": "353762", "Score": "0", "Body": "<p>One argument that one could make for:</p>\n<p>std::string foo(\"bar\");</p>\n<p>Is that it keeps things the same even if the argument count changes, i.e.:</p>\n<p>std::string foo(\"bar\", 5);</p>\n<p>Doesn't work with a '=' sign.</p>\n<p>Another thing is that for many objects a '=' feels unnatural, for example say you have a Array class where the argument gives the length:</p>\n<p>Array arr = 5;</p>\n<p>Doesn't feel good, since we don't construct an Array with the value 5, but with length 5:</p>\n<p>Array arr(5);</p>\n<p>feels more natural, since you are constructing an object with the given parameter, not just copying a value.</p>\n", "LastActivityDate": "2008-12-09T18:36:15.910"}, "353659": {"ParentId": "353632", "CommentCount": "1", "CreationDate": "2008-12-09T17:59:16.937", "OwnerUserId": "6932", "Id": "353659", "PostTypeId": "2", "OwnerDisplayName": "Greg D", "Score": "4", "Body": "<p>Unless you've proven that it matters with respect to performance, I wouldn't worry about an extra copy using the assignment operator in your example (<code>std::string foo = \"Foo\";</code>).  I'd be pretty surprised if that copy even exists once you look at the optimized code, I believe that will actually call the appropriate parameterized constructor.</p>\n<p>In answer to your question, yes, I'd say that it's a pretty common convention.  Classically, people have used assignment to initialize built-in types, and there isn't a compelling reason to change the tradition.  Readability and habit are perfectly valid reasons for this convention given how little impact it has on the ultimate code.</p>\n", "LastActivityDate": "2008-12-09T17:59:16.937"}, "353660": {"ParentId": "353632", "CommentCount": "0", "Body": "<p>I believe that is more of a habit, very few objects could be initialized using = , the string is one of them. It's also a way of doing what you said \"using parenthesis everywhere (that the language allows you to use it)\"</p>\n", "PostTypeId": "2", "Id": "353660", "Score": "0", "CreationDate": "2008-12-09T17:59:23.723", "LastActivityDate": "2008-12-09T17:59:23.723"}, "353649": {"CommentCount": "7", "CreationDate": "2008-12-09T17:57:42.883", "LastEditorUserId": "9530", "LastActivityDate": "2008-12-09T18:47:21.097", "ParentId": "353632", "PostTypeId": "2", "LastEditorDisplayName": "Adam Rosenfield", "LastEditDate": "2008-12-09T18:47:21.097", "Id": "353649", "Score": "17", "Body": "<p>Initializing variables with the = operator or with a constructor call are semantically the same, it's just a question of style.  I prefer the = operator, since it reads more naturally.</p>\n<p>Using the = operator <em>usually</em> does not generate an extra copy - it just calls the normal constructor.  Note, however, that with non-primitive types, this is only for initializations that occur at the same time as the declarations.  Compare:</p>\n<pre><code>std::string strFooA(\"Foo\");  // Calls std::string(const char*) constructor\nstd::string strFoo = \"Foo\";  // Calls std::string(const char*) constructor\n                             // This is a valid (and standard) compiler optimization.\n\nstd::string strFoo;  // Calls std::string() default constructor\nstrFoo = \"Foo\";      // Calls std::string::operator = (const char*)\n</code></pre>\n<p>When you have non-trivial default constructors, the latter construction can be slightly more inefficient.</p>\n<p>The <a href=\"http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.13\" rel=\"noreferrer\">C++ standard</a>, section 8.5, paragraph 14 states:</p>\n<blockquote>\n<p id=\"so_353632_353649_0\">Otherwise (i.e., for the remaining copy-initialization cases), a temporary is created. User-defined conversion sequences that can convert from the source type to the destination type or a derived class thereof are enumerated (13.3.1.4), and the best one is chosen through overload resolution (13.3).  The user-defined conversion so selected is called to convert the initializer expression into a temporary, whose type is the type returned by the call of the user-defined conversion function, with the cv-qualifiers\n  of the destination type. If the conversion cannot be done or is ambiguous, the initialization is ill-formed.  The object being initialized is then direct-initialized\n  from the temporary according to the rules above.<sup>87</sup>) <strong>In certain cases, an implementation is permitted to eliminate the temporary by initializing the object directly; see 12.2.</strong></p>\n</blockquote>\n<p>Part of section 12.2 states:</p>\n<blockquote>\n<p id=\"so_353632_353649_1\">Even when the creation of the temporary object is avoided, all the semantic restrictions must be respected as if the temporary object was created. [Example:\n  even if the copy constructor is not called, all the semantic restrictions, such as accessibility (11), shall be satisfied. ]</p>\n</blockquote>\n", "OwnerUserId": "9530", "OwnerDisplayName": "Adam Rosenfield"}, "353650": {"ParentId": "353632", "CommentCount": "0", "CreationDate": "2008-12-09T17:57:58.920", "OwnerUserId": "893", "Id": "353650", "PostTypeId": "2", "OwnerDisplayName": "Greg Hewgill", "Score": "2", "Body": "<p>You will probably find that code such as</p>\n<pre><code>std::string strFoo = \"Foo\";\n</code></pre>\n<p>will avoid doing an extra copy and compiles to the same code (a call of a single-argument constructor) as the one with parentheses.</p>\n<p>On the other hand, there are cases where one <em>must</em> use parentheses, such as a constructor member initialisation list.</p>\n<p>I think the use of = or parentheses to construct local variables is largely a matter of personal choice.</p>\n", "LastActivityDate": "2008-12-09T17:57:58.920"}, "353651": {"ParentId": "353632", "CommentCount": "4", "CreationDate": "2008-12-09T17:58:06.017", "OwnerUserId": "35364", "Id": "353651", "PostTypeId": "2", "OwnerDisplayName": "hasen j", "Score": "1", "Body": "<p>Well, who knows what <em>they</em> think, but I also prefer the = for primitive types, mainly because they are not objects, and because that's the \"usual\" way to initialize them.</p>\n", "LastActivityDate": "2008-12-09T17:58:06.017"}, "353645": {"ParentId": "353632", "CommentCount": "0", "CreationDate": "2008-12-09T17:57:05.100", "OwnerUserId": "13029", "Id": "353645", "PostTypeId": "2", "OwnerDisplayName": "Andrew Stein", "Score": "0", "Body": "<p>It's an issue of style. Even the statement that \"std::string = \"Foo\"; would be inefficient because it would involve an extra copy\" is not correct. This \"extra copy\" is removed by the compiler.</p>\n", "LastActivityDate": "2008-12-09T17:57:05.100"}, "353632": {"CommentCount": "0", "CreationDate": "2008-12-09T17:52:07.497", "PostTypeId": "1", "AcceptedAnswerId": "353659", "LastEditorUserId": "3204551", "LastActivityDate": "2015-08-29T21:19:54.067", "AnswerCount": "9", "LastEditDate": "2015-08-29T21:19:54.067", "ViewCount": "2626", "FavoriteCount": "2", "Title": "Why use = to initialise a primitive type in C++?", "Id": "353632", "Score": "8", "Body": "<p>Where I work, people mostly think that objects are best initialised using C++-style construction (with parentheses), whereas primitive types should be initialised with the = operator:</p>\n<pre><code>std::string strFoo( \"Foo\" );\nint nBar = 5;\n</code></pre>\n<p>Nobody seems to be able to explain why they prefer things this way, though.  I can see that <code>std::string = \"Foo\";</code> would be inefficient because it would involve an extra copy, but what's wrong with just banishing the <code>=</code> operator altogether and using parentheses everywhere?</p>\n<p>Is it a common convention?  What's the thinking behind it?</p>\n", "Tags": "<c++><coding-style><c++03>", "OwnerUserId": "11575", "OwnerDisplayName": "Tommy Herbert"}, "353784": {"ParentId": "353632", "CommentCount": "0", "CreationDate": "2008-12-09T18:44:33.460", "OwnerUserId": "10897", "Id": "353784", "PostTypeId": "2", "OwnerDisplayName": "mgb", "Score": "0", "Body": "<p>But then just to confuse you even more you initialize primitives in the initialization list using object syntax.</p>\n<pre><code>foo::foo()   \n  ,anInt(0)   \n  ,aFloat(0.0)   \n{   \n}   \n</code></pre>\n", "LastActivityDate": "2008-12-09T18:44:33.460"}, "bq_ids": {"n4140": {"so_353632_353649_0": {"section_id": 3296, "quality": 0.56, "length": 42}, "so_353632_353649_1": {"section_id": 378, "quality": 0.5769230769230769, "length": 15}}, "n3337": {"so_353632_353649_0": {"section_id": 3166, "quality": 0.56, "length": 42}, "so_353632_353649_1": {"section_id": 369, "quality": 0.8076923076923077, "length": 21}}, "n4659": {"so_353632_353649_0": {"section_id": 4058, "quality": 0.56, "length": 42}, "so_353632_353649_1": {"section_id": 392, "quality": 0.5384615384615384, "length": 14}}}, "353736": {"CommentCount": "1", "CreationDate": "2008-12-09T18:21:34.147", "LastEditorUserId": "34509", "LastActivityDate": "2008-12-09T18:27:18.410", "ParentId": "353632", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2008-12-09T18:27:18.410", "Id": "353736", "Score": "11", "Body": "<p>I just felt the need for another silly litb post.</p>\n<pre><code>string str1 = \"foo\";\n</code></pre>\n<p>is called <strong>copy-initialization</strong>, because what the compiler does, if it doesn't elide any temporaries, is:</p>\n<pre><code>string str1(string(\"foo\")); \n</code></pre>\n<p>beside checking that the conversion constructor used is implicit. In fact, all implicit conversions are defined by the standard in terms of copy initialization. It is said that an implicit conversion from type U to type T is valid, if</p>\n<pre><code>T t = u; // u of type U\n</code></pre>\n<p>is valid. </p>\n<p>In constrast, </p>\n<pre><code>string str1(\"foo\");\n</code></pre>\n<p>is doing exactly what is written, and is called <strong>direct initialization</strong>. It also works with explicit constructors. </p>\n<p>By the way, you can disable eliding of temporaries by using -fno-elide-constructors:</p>\n<pre><code>-fno-elide-constructors\n    The C++ standard allows an implementation to omit creating a temporary which \n    is only used to initialize another object of the same type. Specifying this \n    option disables that optimization, and forces G++ to call the copy constructor \n    in all cases.\n</code></pre>\n<hr>\n<p>The Standard says there is practically no difference between </p>\n<pre><code>T a = u;\n</code></pre>\n<p>and </p>\n<pre><code>T a(u);\n</code></pre>\n<p>if T and the type of u are primitive types. So you may use both forms. I think that it's just the style of it that makes people use the first form rather than the second. </p>\n<hr>\n<p>Some people may use the first in some situation, because they want to disambiguate the declaration:</p>\n<pre><code>T u(v(a));\n</code></pre>\n<p>migh look to someone as a definition of a variable <code>u</code> that is initialized using a temporary of a type <code>v</code> that gets a parameter for its constructor called <code>a</code>. But in fact, what the compiler does with that is this:</p>\n<pre><code>T u(v a);\n</code></pre>\n<p>It creates a function declaration that takes a argument of type <code>v</code>, and with a parameter called <code>a</code>. So people do </p>\n<pre><code>T u = v(a);\n</code></pre>\n<p>to disambiguate that, even though they could have done</p>\n<pre><code>T u((v(a)));\n</code></pre>\n<p>too, because there are never parentheses around function parameters, the compiler would read it as a variable definition instead of a function declaration too :)</p>\n</hr></hr>", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}});