post_cb({"bq_ids": {"n4140": {"so_32672876_32672876_1": {"section_id": 42, "quality": 1.0, "length": 12}, "so_32672876_32673117_0": {"section_id": 6038, "quality": 0.9473684210526315, "length": 36}}, "n3337": {"so_32672876_32672876_1": {"section_id": 39, "quality": 1.0, "length": 12}, "so_32672876_32673117_0": {"section_id": 5806, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_32672876_32672876_1": {"section_id": 42, "quality": 1.0, "length": 12}, "so_32672876_32673117_0": {"section_id": 7537, "quality": 0.9473684210526315, "length": 36}}}, "32672876": {"CommentCount": "3", "ViewCount": "96", "CreationDate": "2015-09-19T20:28:33.723", "LastActivityDate": "2015-09-19T21:24:37.337", "Title": "Can a valid pointer-to-member have the same value as a NULL pointer?", "AcceptedAnswerId": "32673117", "PostTypeId": "1", "Id": "32672876", "Score": "0", "Body": "<p>According to <a href=\"http://refspecs.linux-foundation.org/cxxabi-1.83.html#member-pointers\" rel=\"nofollow\">ABI</a>, </p>\n<blockquote>\n<p id=\"so_32672876_32672876_0\">A pointer to data member is an offset from the base address of the\n  class object containing it... A NULL pointer is represented as -1</p>\n</blockquote>\n<p>However, according to the c++ standard (I have revision 4296, and there it's in <strong>4.11/1</strong>), </p>\n<blockquote>\n<p id=\"so_32672876_32672876_1\">the null member pointer value of that type ... is distinguishable\n  from any pointer to member not created from a null pointer constant</p>\n</blockquote>\n<p>and -1 can be a valid offset.</p>\n<p>Consider this situation:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {\n    char a,b,c,d,e,f,g,h;\n};\n\nstruct B {\n    int i;\n};\n\nstruct C : A,B {};\n\nint main() {\n    char C::*p=&amp;C::h;\n    char B::*q = static_cast&lt;char B::*&gt;(p);\n    cout&lt;&lt; (q==nullptr) &lt;&lt;endl; //prints 1\n}\n</code></pre>\n<p>In this code, my compiler (g++4.9.2 on x86_64-linux-gnu), places <code>h</code> at the last byte of <code>A</code>, and places <code>B</code> right after <code>A</code> in <code>C</code>. Hence, the offset of <code>C::A::h</code> from the base address of <code>C::B</code> is -1.</p>\n<p>(The conversion is legal, and its result can be used on an object of dynamic type C, even if its static type is B. The standard says (<strong>5.2.9/12</strong>) \"although class B need not contain the original member, the dynamic type of the object with which indirection through the pointer to member is performed must contain the original member\")</p>\n<p>What am I misunderstanding?</p>\n<p>(I suspect that my misunderstanding is about the phrase \"the class containing the original member\" (<strong>5.2.9/12</strong>) - considering <code>C::h</code>, that phrase may refer to <code>A</code> and not to <code>C</code>, but the standard explicitly says (<strong>10/2</strong>) \"members of a base class are also considered to be members of the derived class\")</p>\n", "Tags": "<c++><standards><language-lawyer><abi><pointer-to-member>", "OwnerUserId": "1055952", "AnswerCount": "2"}, "32673390": {"ParentId": "32672876", "CommentCount": "1", "Body": "<p>You're wrong, an offset of -1 from the <em>base</em> address is impossible. The base address of an object is the address of the full object, and not that off a subobject within that full object.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "32673390", "Score": "0", "CreationDate": "2015-09-19T21:24:37.337", "LastActivityDate": "2015-09-19T21:24:37.337"}, "32673117": {"ParentId": "32672876", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>[expr.static.cast]/p12:</p>\n<blockquote>\n<p id=\"so_32672876_32673117_0\">A prvalue of type \u201cpointer to member of <code>D</code> of type cv1 <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer to member of <code>B</code>\u201d of type cv2\n  <code>T</code>, where <code>B</code> is a base class (Clause 10) of <code>D</code>, [...]. If class <code>B</code> contains the original member, or is a base or\n  derived\n  class of the class containing the original member, the resulting\n  pointer to member points to the original member. Otherwise, the\n  behavior is undefined.</p>\n</blockquote>\n<p>The \"class containing the original member\" is <code>A</code>. <code>B</code> is not a base or derived class of <code>A</code>, so the behavior is undefined.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-09-19T20:55:43.017", "Id": "32673117", "Score": "2", "CreationDate": "2015-09-19T20:52:14.853", "LastActivityDate": "2015-09-19T20:55:43.017"}});