post_cb({"33058915": {"ViewCount": "116", "Body": "<p>I'm getting inconsistent results for <code>std::is_constructible&lt;void()&gt;::value</code>. My interpretation of the standard is that it should be false. However, Clang, with both libc++ and libstdc++*, gives true. GCC and MSVC both give false. Which result is correct?</p>\n<h1>Standardese</h1>\n<p>Here is the standardese, N4527 [meta.unary.prop]/7:</p>\n<blockquote>\n<p id=\"so_33058915_33058915_0\">Given the following function declaration:</p>\n<pre><code>template &lt;class T&gt; add_rvalue_reference_t&lt;T&gt; create() noexcept;\n</code></pre>\n<p id=\"so_33058915_33058915_1\">the predicate condition for a template specialization\n  <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the\n  following variable definition would be well-formed for some invented\n  variable <code>t</code>:</p>\n<pre><code>T t(create&lt;Args&gt;()...);\n</code></pre>\n</blockquote>\n<p>Note: This text changed slightly from C++11 (N3485), where <code>create</code> was not marked <code>noexcept</code>. However, the results of my tests did not change when accounting for this.</p>\n<h1>Test Case</h1>\n<p>Here is my minimal test case of both the type trait and the standardese definition:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstatic_assert(std::is_constructible&lt;void()&gt;::value, \"assertion fired\");\n\ntemplate&lt;typename T&gt;\nstd::add_rvalue_reference_t&lt;T&gt; create() noexcept;\n\ntemplate&lt;typename T, typename... Args&gt;\nvoid foo() {\n    T t(create&lt;Args&gt;()...);   \n}\n\nint main() {\n    foo&lt;void()&gt;();   \n}\n</code></pre>\n<h1>Results:</h1>\n<p><a href=\"http://melpon.org/wandbox/permlink/w9hcPuBocLVDjjNh\">Clang (HEAD, libc++)</a>:</p>\n<ul>\n<li>static assertion PASSED</li>\n<li><code>foo&lt;void()&gt;</code> did NOT compile</li>\n</ul>\n<p><a href=\"http://melpon.org/wandbox/permlink/4SUq6vz3PyZsu6Rx\">Clang (HEAD, libstdc++)</a>*:</p>\n<ul>\n<li>static assertion PASSED</li>\n<li><code>foo&lt;void()&gt;</code> did NOT compile</li>\n</ul>\n<p><a href=\"http://melpon.org/wandbox/permlink/9nBxGc4FO0JZF8Vp\">GCC (HEAD, libstdc++)</a>:</p>\n<ul>\n<li>static assertion FAILED</li>\n<li><code>foo&lt;void()&gt;</code> did NOT compile</li>\n</ul>\n<p>MSVC (version 19 via <a href=\"http://webcompiler.cloudapp.net/\">http://webcompiler.cloudapp.net/</a>):</p>\n<ul>\n<li>static assertion FAILED</li>\n<li><code>foo&lt;void()&gt;</code> did NOT compile (requires commenting out the static assertion)</li>\n</ul>\n<hr>\n<p>*<code>__GLIBCXX__</code> is not defined when Clang is used both with no <code>-stdlib</code> option and with <code>-stdlib=libstdc++</code>. I am unsure of whether libstdc++ is <em>actually</em> being used. If my interpretation of the standard is correct, then I am unsure of whether it is a bug with Clang or with libc++.</p>\n</hr>", "AcceptedAnswerId": "33059200", "Title": "What is the correct result of std::is_constructible<void()>::value?", "CreationDate": "2015-10-10T20:57:49.420", "Id": "33058915", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-10T21:34:48.837", "Score": "9", "OwnerUserId": "962089", "Tags": "<c++><language-lawyer><typetraits>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33058915_33058915_0": {"length": 4, "quality": 1.0, "section_id": 4710}, "so_33058915_33058915_1": {"length": 15, "quality": 1.0, "section_id": 4710}, "so_33058915_33059200_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 4710}}, "n3337": {"so_33058915_33058915_0": {"length": 4, "quality": 1.0, "section_id": 4518}, "so_33058915_33058915_1": {"length": 15, "quality": 1.0, "section_id": 4518}, "so_33058915_33059200_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 4518}}, "n4659": {"so_33058915_33058915_0": {"length": 4, "quality": 1.0, "section_id": 6496}, "so_33058915_33058915_1": {"length": 15, "quality": 1.0, "section_id": 6107}, "so_33058915_33059200_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 6107}}}, "33059200": {"Id": "33059200", "PostTypeId": "2", "Body": "<p>Keep reading. From the same paragraph:</p>\n<blockquote>\n<p id=\"so_33058915_33059200_0\">Access checking is performed as if in a context unrelated to <code>T</code> and\n  any of the <code>Args</code>. <strong>Only the validity of the immediate context of the\n  variable initialization is considered.</strong> [ <em>Note:</em> The evaluation of the\n  initialization can result in side effects such as the instantiation of\n  class template specializations and function template specializations,\n  the generation of implicitly-defined functions, and so on. Such side\n  effects are not in the \u201cimmediate context\u201d and can result in the\n  program being ill-formed. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>The assertion only fails when the template constructor is instantiated. However, as cleared up in the note, that assertion is not in the immediate context of the variable definition that is considered, and thus does not affect its \"validity\". So the compilers can count that definition as valid, even if actually attempting to construct a <code>void()</code> results in an ill-formed program.</p>\n<p>Note that the compilers are also allowed to, instead of having is_constructible yield false, just reject the original program based on the assertion.</p>\n", "LastActivityDate": "2015-10-10T21:34:48.837", "Score": "7", "CreationDate": "2015-10-10T21:34:48.837", "ParentId": "33058915", "CommentCount": "0", "OwnerUserId": "5432045"}});