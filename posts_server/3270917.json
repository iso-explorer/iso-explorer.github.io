post_cb({"3270925": {"Id": "3270925", "PostTypeId": "2", "Body": "<p>No constructor is applied at compile. In fact, no code at all is executing at compile time.</p>\n", "LastActivityDate": "2010-07-17T09:31:19.350", "CommentCount": "0", "CreationDate": "2010-07-17T09:31:19.350", "ParentId": "3270917", "Score": "0", "OwnerUserId": "17028"}, "bq_ids": {"n4140": {"so_3270917_3275101_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 7152}}, "n3337": {"so_3270917_3275101_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 6896}}, "n4659": {"so_3270917_3275101_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 8653}}}, "3270917": {"ViewCount": "465", "Body": "<p>take two following classes and their constructors as samples:</p>\n<pre><code>class One{\n public:\n  One(int a,int b):adad1(a),adad2(b){}\n private:\n  int adad1;\n  int adad2;\n};\nclass Two{\n public:\n  Two(int input[]){\n   for (int i=0;i&lt;10;i++)\n    araye[i]=input[i];\n  }\n private:\n  int araye[10];\n};\n</code></pre>\n<p>considering objects with static storage duration, I think first constructor can be applied during compile time due to its free function body that allows it to be converted to a constant expression in some cases as an optimization, but I have doubt about second one. anyway is there any rule specifying which kinds of constructors can be applied during compile time ?</p>\n", "AcceptedAnswerId": "3275101", "Title": "which kinds of constructors may be applied during compile time as optimization, for objects with static storage duration?", "CreationDate": "2010-07-17T09:27:04.330", "Id": "3270917", "CommentCount": "1", "LastEditDate": "2010-07-18T10:04:39.047", "PostTypeId": "1", "LastEditorUserId": "388056", "LastActivityDate": "2010-07-18T21:01:48.903", "Score": "1", "OwnerUserId": "388056", "Tags": "<c++><optimization><compiler-construction><constructor><initialization>", "AnswerCount": "2"}, "3275101": {"Id": "3275101", "PostTypeId": "2", "Body": "<p>There is no guarantee that any of the two are statically initialized before any runtime code is executed. For the first, it's easy to make it happen, though</p>\n<pre><code>class One{\n public:\n  int adad1;\n  int adad2;\n};\n\n// initialized statically, if a and b are constant-expressions\nOne one = { a, b }; \n</code></pre>\n<p>As another guy says, <code>constexpr</code> in C++0x allows constructors to be executed statically. In your case that would work for the first case, but not for the second. You will have to live that for the second, no guarantee is made by the Standard. But the Standard still allows an implementation to optimize it to be done at static initialization phase. See 3.6.2/2</p>\n<blockquote>\n<p id=\"so_3270917_3275101_0\">An implementation is permitted to perform the initialization of an object of namespace scope with static storage duration as a static initialization even if such initialization is not required to be done statically, provided that</p>\n<ul>\n<li>the dynamic version of the initialization does not change the value of any other object of namespace\n  scope with static storage duration prior to its initialization, and</li>\n<li>the static version of the initialization produces the same value in the initialized object as would be produced by the dynamic initialization if all objects not required to be initialized statically were initialized dynamically.</li>\n</ul>\n</blockquote>\n<p>If the array given is suitable, your constructor may not violate those rules. The Standard shows an example, which i explained in <a href=\"https://stackoverflow.com/questions/920615/why-do-some-const-variables-referring-to-some-exported-const-variables-get-the-va/921681#921681\">more detail here</a>. For completion, the example code is shown below</p>\n<pre><code>inline double fd() { return 1.0; }\nextern double d1;\ndouble d2 = d1;   // unspecified:\n                  // may be statically initialized to 0.0 or\n                  // dynamically initialized to 1.0\n\ndouble d1 = fd(); // may be initialized statically to 1.0\n</code></pre>\n<p>As you see, putting things to be initialized earlier can even go with changed initial values if there exist a certain relation between variables. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-07-18T21:01:48.903", "Score": "2", "CreationDate": "2010-07-18T10:12:58.283", "ParentId": "3270917", "CommentCount": "8", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T10:24:37.317"}});