post_cb({"42044456": {"ParentId": "42043414", "CommentCount": "0", "Body": "<p>Given <code>int f1()</code> and <code>int &amp;&amp; f2()</code>, it's intended that <code>decltype(f1())</code> is <code>int</code>, and <code>decltype(f2())</code> is <code>int &amp;&amp;</code>. The way this is made to work is by specifying that <code>f1()</code> is a prvalue and <code>f2()</code> is an xvalue. <code>decltype</code> then looks at whether the given expression is a prvalue, xvalue or lvalue. If <code>f1()</code> and <code>f2()</code> were both xvalues, that same distinction would still need to be made some other way.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "42044456", "Score": "2", "CreationDate": "2017-02-04T19:10:19.603", "LastActivityDate": "2017-02-04T19:10:19.603"}, "bq_ids": {"n4140": {"so_42043414_42043414_2": {"section_id": 378, "quality": 0.782608695652174, "length": 18}, "so_42043414_42043414_0": {"section_id": 7230, "quality": 0.8, "length": 20}, "so_42043414_42043414_1": {"section_id": 3321, "quality": 0.8333333333333334, "length": 10}, "so_42043414_42043414_3": {"section_id": 7230, "quality": 0.9375, "length": 15}}, "n3337": {"so_42043414_42043414_2": {"section_id": 369, "quality": 0.782608695652174, "length": 18}, "so_42043414_42043414_0": {"section_id": 6974, "quality": 0.8, "length": 20}, "so_42043414_42043414_1": {"section_id": 3191, "quality": 0.75, "length": 9}, "so_42043414_42043414_3": {"section_id": 6974, "quality": 0.9375, "length": 15}}, "n4659": {"so_42043414_42043414_3": {"section_id": 8741, "quality": 0.5625, "length": 9}}}, "42043414": {"CommentCount": "1", "AcceptedAnswerId": "42044456", "CreationDate": "2017-02-04T17:37:29.297", "LastActivityDate": "2017-02-04T19:10:19.603", "PostTypeId": "1", "ViewCount": "131", "FavoriteCount": "1", "Title": "Why are function expressions returning non-reference types considered to be prvalues and not xvalues?", "Id": "42043414", "Score": "6", "Body": "<p><code>\u00a7 3.10.1.5</code> from the standard defines <code>prvalue</code> expressions as: </p>\n<blockquote>\n<p id=\"so_42043414_42043414_0\">\u2014 A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function\n  whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is\n  also a prvalue. \u2014 end example ]</p>\n</blockquote>\n<p>Thus the function <code>foo()</code> is a <code>prvalue</code> expression: </p>\n<pre><code>class Foo {}; \nFoo foo() { return Foo{}; }\n</code></pre>\n<p>To initialize a <code>lvalue reference to a non-volatile const type</code> / <code>rvalue reference</code> the initializer expression has to be ( <code>\u00a7 5.2.1.1</code> ) : </p>\n<blockquote>\n<p id=\"so_42043414_42043414_1\">[...] an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and \u201ccv1 T1\u201d\n  is reference-compatible with \u201ccv2 T2\u201d, or [...]</p>\n</blockquote>\n<p>Thus, </p>\n<pre><code>Foo &amp;&amp;rrFoo_ = foo(); \n</code></pre>\n<p>is valid code where <code>rrFoo_</code> binds to a temporary object extending the lifetime of the object (<code>\u00a712.2</code>): </p>\n<blockquote>\n<p id=\"so_42043414_42043414_2\">Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), returning\n  a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1),\n  and in some initializations (8.5).</p>\n</blockquote>\n<p>As stated above and neglecting RVO, the following initialization of an object of type <code>Foo</code> will copy move construct a temporary from default constructed object. The temporary object which will then be used to copy move construct the final object named <code>obj_foo</code> : </p>\n<pre><code>Foo obj_foo{ foo() }; \n</code></pre>\n<p>So in both cases we either <em>steal</em> from or even <em>extend the lifetime</em> of the temporary object, which would otherwise be destroyed. </p>\n<p><code>\u00a73.10.1.2</code> defines xvalues as: </p>\n<blockquote>\n<p id=\"so_42043414_42043414_3\">An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near the end of its lifetime (so that its\n  resources may be moved, for example). [...]</p>\n</blockquote>\n<p>I cannot think of any case where a temporary object isn't created. So my question is, why are function expressions like <code>foo()</code> are considered to be <code>prvalue</code> expression even thought they have <em>at least</em> similar properties as <code>xvalues</code> ? </p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "4884487", "AnswerCount": "1"}});