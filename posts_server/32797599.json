post_cb({"bq_ids": {"n4140": {"so_32797599_32797990_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 190}, "so_32797599_32797990_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 190}}, "n3337": {"so_32797599_32797990_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 184}, "so_32797599_32797990_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 184}}, "n4659": {"so_32797599_32797990_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 195}, "so_32797599_32797990_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 195}}}, "32797990": {"Id": "32797990", "PostTypeId": "2", "Body": "<p>This is not a compiler bug. In your example, both <code>std::conditional&lt;std::is_integral&lt;T&gt;::value, B1, Empty&gt;::type</code> and <code>std::conditional&lt;std::is_floating_point&lt;T&gt;::value, B2, Empty&gt;::type</code> are dependent base classes because they depend on the template parameter <code>T</code>.  As specified in \u00a714.6.2 of the current working draft, <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">n4527</a>:</p>\n<blockquote>\n<p id=\"so_32797599_32797990_0\">In the definition of a class or class template, the scope of a dependent base class (14.6.2.1) is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member. [ <em>Example:</em></p>\n<pre><code>typedef double A;\ntemplate&lt;class T&gt; class B {\n    typedef int A;\n};\ntemplate&lt;class T&gt; struct X : B&lt;T&gt; {\n    A a; // a has type double\n};\n</code></pre>\n<p id=\"so_32797599_32797990_1\">The type name <code>A</code> in the definition of <code>X&lt;T&gt;</code> binds to the typedef name defined in the global namespace scope, not to the typedef name defined in the base class <code>B&lt;T&gt;</code>. \u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>GCC and Clang are properly issuing an error that <code>str</code> is undeclared because the compiler is essentially trying to find a declaration of <code>str</code> in the global scope before the declaration of <code>X</code>.</p>\n<p>You simply need to qualify <code>str</code>, either by writing <code>this-&gt;str</code> or <code>A::str</code>.</p>\n", "LastEditorUserId": "196844", "LastActivityDate": "2015-09-26T14:11:40.530", "Score": "2", "CreationDate": "2015-09-26T14:00:23.113", "ParentId": "32797599", "CommentCount": "0", "LastEditDate": "2015-09-26T14:11:40.530", "OwnerUserId": "196844"}, "32797599": {"ViewCount": "128", "Body": "<p>Lets take a look at the code below:</p>\n<pre><code>struct A {\n    A (std::string s) : str {s} {}\n    A () = default;\n    std::string str {\"XXX\"};\n};\n\nstruct B1 : virtual A {\n    B1 () = default;\n\n    void foo_b1 () {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n};\n\nstruct B2 : virtual A {\n    B2 () = default;\n\n    void foo_b2 () { \n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n};\n\nstruct Empty {};\n</code></pre>\n<p>So far so good, I want class A to have a member which instance (one and only one) will be shared between two classes B1 and B2, so I used virtual inheritance as it is. Next step is conditional inheritance from B1 and B2, depending on the template parameter T, like this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct X : std::conditional&lt;std::is_integral&lt;T&gt;::value, B1, Empty&gt;::type,\n           std::conditional&lt;std::is_floating_point&lt;T&gt;::value, B2, Empty&gt;::type {\n    X () : A (\"X ctor\") {\n//        std::cout &lt;&lt; str &lt;&lt; std::endl;  // (X)\n    }\n};\n</code></pre>\n<p>Everything is fine and usage of class <code>X</code> is almost as I wanted, so I am able to do this:</p>\n<pre><code>X&lt;int&gt; x1;\nx1.foo_b1 ();\nx1.foo_b2 ();   // (1)\n\nX&lt;double&gt; x2;\nx2.foo_b1 ();   // (2)\nx2.foo_b2 ();\n</code></pre>\n<p>Lines (1) and (2) of course don't compile and this is what I wanted, but if I uncomment line (X) GCC 4.8.3 and Clang 3.5.0 reject the code with message:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error: \u2018str\u2019 was not declared in this scope`  # GCC\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>error: use of undeclared identifier 'str'`    # Clang\n</code></pre>\n<p>Why? I inherited from B1 or B2, I should have access to virtual base member. So I tested it without conditional inheritance.</p>\n<pre><code>template &lt;typename T&gt;\nstruct Z : B1, Empty {\n    Z () : A (\"Z ctor\") {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;    // (Y)\n    }\n};\n</code></pre>\n<p>With usage like this (of course template parameter is unnecessary here. Class <code>Z</code> itself behaves like <code>X&lt;int&gt;</code> specialization):</p>\n<pre><code>Z&lt;int&gt; z;\nz.foo_b1 ();\n</code></pre>\n<p>And this is completely fine for both compilers. Line (Y) does not make any trouble in this case.</p>\n<p><strong>Is there any reason why there is no access to virtual base member if conditional inheritance is used? Or is it some kind of compilers bug?</strong></p>\n", "AcceptedAnswerId": "32797990", "Title": "Conditional virtual inheritance and access to virtual base member", "CreationDate": "2015-09-26T13:14:07.193", "Id": "32797599", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-26T13:53:15.507", "LastEditorUserId": "596781", "LastActivityDate": "2015-09-26T14:11:40.530", "Score": "2", "OwnerUserId": "3671410", "Tags": "<c++><inheritance><virtual-inheritance>", "AnswerCount": "2"}, "32797986": {"Id": "32797986", "PostTypeId": "2", "Body": "<p><code>str</code> is a dependent name and so you have to use <code>this-&gt;str</code> (or <code>A::str</code>).</p>\n<p>or else you have to inherit directly from <code>A</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct X : virtual A,\n           std::conditional&lt;std::is_integral&lt;T&gt;::value, B1, Empty&gt;::type,\n           std::conditional&lt;std::is_floating_point&lt;T&gt;::value, B2, Empty&gt;::type {\n    X () : A (\"X ctor\") {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;  // (X)\n    }\n};\n</code></pre>\n", "LastActivityDate": "2015-09-26T13:59:44.613", "Score": "1", "CreationDate": "2015-09-26T13:59:44.613", "ParentId": "32797599", "CommentCount": "0", "OwnerUserId": "2684539"}});