post_cb({"30603294": {"ParentId": "30599331", "CommentCount": "0", "CreationDate": "2015-06-02T17:59:07.170", "OwnerUserId": "1386054", "PostTypeId": "2", "Id": "30603294", "Score": "0", "Body": "<p>I suspect this is at the intersection of overlapping requirements.</p>\n<ol>\n<li>The layout for the same POD struct in C and C++ should be binary compatible.  (Whether this is required by the standard, I don't know, but most compiler vendors probably prioritize it because lots of existing code depends on it.)</li>\n<li>Structs and classes in C++ are effectively the same thing except for the default visibility.</li>\n<li>Data members of a class are constructed in the order they are declared, and destroyed in the opposite order.</li>\n</ol>\n<p>If the compiler were to reorder the data members for better alignment and/or tighter packing, should that change the order that the construction/destruction order?  Nope, that would break lots of code that relies on RAII.  But now the memory accesses during construction are less in-order, which might actually be a pessimization, depending on cache behavior, the size of the structure, and the frequency with which those structs are constructed.</p>\n<p>You could argue that those concerns don't apply to POD structs, but requirements 1 and 2 say that a C++ compiler must lay out POD structs the same way as classes (and vice versa).</p>\n", "LastActivityDate": "2015-06-02T17:59:07.170"}, "30599331": {"CommentCount": "1", "ViewCount": "426", "PostTypeId": "1", "ClosedDate": "2016-09-01T03:08:55.457", "LastEditorUserId": "253056", "CreationDate": "2015-06-02T14:45:22.140", "LastActivityDate": "2015-06-02T20:24:36.510", "Title": "How come Visual Studio does not optimize structs for best memory usage?", "AcceptedAnswerId": "30599762", "LastEditDate": "2015-06-02T14:51:04.873", "Id": "30599331", "Score": "2", "Body": "<p>My question is why doesnt the Visual Studio 2012 compiler automatically reorder struct members for best memory utilization?  The compiler seems to store the members in exactly the order they are declared in the struct definition, with some empty padding as required for member alignment. It seems like reordering would be a more desirable way to align the members than padding, whenever possible.  Is there a reason it must be stored in memory in declaration order?</p>\n<p>Pertinent details follow;</p>\n<p>I have a struct which represents a single element in what will be a large array.  The element has a number of members, some 32 bit, some 64 bit.   I have default struct member alignment tuned on for best performance.  </p>\n<p>I was exploring memory in debug mode and found that a signficant percentage of the memory was being wasted. I tracked the problem to how the stuct members were aligned in memory. I know that 32 bit members must be aligned on DWORD boundaries for best performance and it would appear that evidently 64 bit members must be aligned on QWORD boundaries (I would have thought DWORD boundaries would have been adequate)</p>\n<p>I was able to fix the problem by changing the order in which I listed the members in the struct definition.  I made sure to put 2 32 bit members consequtively whenever possible so that no padding is required to start the next 64 bit member on a QWORD boundary.</p>\n", "Tags": "<c++><visual-studio-2012><compiler-optimization><struct-member-alignment>", "OwnerUserId": "3856419", "AnswerCount": "4"}, "30599762": {"ParentId": "30599331", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-06-02T15:03:19.883", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:49.617", "Id": "30599762", "OwnerUserId": "1774667", "Body": "<p>Data that is in a standard layout structure or class must make certain layout guarantees.  Among other things if there is another standard layout structure or class that is the prefix of the first, you must be able to reinterpret one structure as the other, and the common prefix has to agree.</p>\n<p>This basically forces the memory order of standard layout structures to be in the order you declare them.</p>\n<p>This is similar to what C requires in terms of structure layout, as described <a href=\"https://stackoverflow.com/questions/9486364/why-cant-c-compilers-rearrange-struct-members-to-eliminate-alignment-padding\">here</a>.</p>\n<p>Now, in C++, there is some freedom is given for non-standard layout structures.</p>\n<p>[expr.rel]/3 subpoint 3:</p>\n<blockquote>\n<p id=\"so_30599331_30599762_0\">If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the pointer to the later declared member compares greater provided the two members have the same access control (Clause 11) and provided their class is not a union.</p>\n</blockquote>\n<p>The order of elements must be maintained within public/private/protected access control domains.  Space between elements can be added in nearly arbitrary ways.</p>\n<p>This means you can know that <code>&amp;this-&gt;x</code> is greater than or less than <code>&amp;this-&gt;y</code>, which some programmers may use.</p>\n<p>Under the as-if rule, if nobody ever takes an address of such data, the compiler could reorder them.  This is hard to prove in the usual compilation models.</p>\n<p>The spacing between elements in MSVC matches the spacing in plain old data structures, barring inheritance with virtual playing the game, in my experience.  Layout compatibility (beyond the standard) is important to a stable ABI, and code compiled with one version of the compiler is preferred to work in another.  Breaking that has a cost.</p>\n<p>C++ programmers can reorder data structures as they need, and visual studio provides <code>#pragma</code>s to change the structure packing rules, so if you really need that last bit of performance you can get it.</p>\n<p>You can even write a <code>tuple</code>-like data structure that guarantees optimal packing if you need it.  (I wouldn't rely on <code>std::tuple</code>, as it has no packing guarantees)</p>\n", "LastActivityDate": "2015-06-02T20:24:36.510"}, "30599541": {"ParentId": "30599331", "CommentCount": "0", "CreationDate": "2015-06-02T14:54:19.210", "OwnerUserId": "198083", "PostTypeId": "2", "Id": "30599541", "Score": "0", "Body": "<p>Without <code>#pragma</code>s, memory is not packed by C++ and are not reordered because the language guarantees layout consistent with the code. Imagine the havoc that would be caused -- mapping structs to files (memory mapped files) or hardware would never work.</p>\n<p>To get a feel for the layout of a class or struct, Visual C++ provide an undocumented command line parameter <code>/d1reportSingleClassLayout</code> which will draw you an ASCII-art diagram of the memory layout of your class/struct, including all members, base members and vtable. If you have a class called <code>foo</code>, for example, add <code>/d1reportSingleClassLayoutfoo</code> to your compiler command line.</p>\n", "LastActivityDate": "2015-06-02T14:54:19.210"}, "bq_ids": {"n4140": {"so_30599331_30599762_0": {"section_id": 6151, "quality": 1.0, "length": 31}, "so_30599331_30599493_0": {"section_id": 5873, "quality": 0.9433962264150944, "length": 50}}, "n3337": {"so_30599331_30599762_0": {"section_id": 5913, "quality": 1.0, "length": 31}, "so_30599331_30599493_0": {"section_id": 5644, "quality": 0.9245283018867925, "length": 49}}, "n4659": {"so_30599331_30599762_0": {"section_id": 7648, "quality": 1.0, "length": 31}, "so_30599331_30599493_0": {"section_id": 7356, "quality": 0.9433962264150944, "length": 50}}}, "30599493": {"ParentId": "30599331", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2015-06-02T14:52:28.620", "Score": "3", "LastEditorUserId": "3883676", "LastEditDate": "2015-06-02T15:12:46.213", "Id": "30599493", "OwnerUserId": "3883676", "Body": "<p>It's the C++ standard, compilers can't modify the order of the fields, probably because programmers may want to access fields via pointer to first field.\nTake a look at this <a href=\"http://www.catb.org/esr/structure-packing/\" rel=\"nofollow\">article</a> if you need to do the reordering by yourself </p>\n<p><strong>Section 9.2.13 :</strong></p>\n<blockquote>\n<p id=\"so_30599331_30599493_0\">Nonstatic data members of a (non-union) class with the same access\n  control (Clause 11) are allocated so that later members have higher\n  addresses within a class object. The order of allocation of non-static\n  data members with different access control is unspecified (Clause 11).\n  Implementation alignment requirements might cause two adjacent members\n  not to be allocated immediately after each other; so might\n  requirements for space for managing virtual functions (10.3) and\n  virtual base classes (10.1).</p>\n</blockquote>\n", "LastActivityDate": "2015-06-02T15:12:46.213"}});