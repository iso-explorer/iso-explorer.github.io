post_cb({"26744867": {"ParentId": "26744528", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The quote you are looking for from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a> is from section <code>5.1</code> <em>Primary expressions</em> which in paragraph <em>10</em> says:</p>\n<blockquote>\n<p id=\"so_26744528_26744867_0\">A nested-name-specifier that denotes an enumeration (7.2), followed by\n  the name of an enumerator of that enumeration, is a qualified-id that\n  refers to the enumerator. The result is the enumerator. The type of\n  the result is the type of the enumeration. The result is a prvalue.</p>\n</blockquote>\n<p>It does not restrict the use to scoped enumerations and so the example in section <code>7.2</code> <em>Enumeration declarations</em>:</p>\n<pre><code>enum direction { left='l', right='r' };\n\nvoid g() {\n   direction d; // OK\n   d = left; // OK\n   d = direction::right; // OK\n}\n</code></pre>\n<p>is entirely consistent. This is also consistent with section <code>3.4.3</code> <em>Qualified name lookup</em> which says:</p>\n<blockquote>\n<p id=\"so_26744528_26744867_1\">The name of a class or namespace member or enumerator can be referred\n  to after the :: scope resolution operator (5.1) applied to a\n  nested-name-specifier that denotes its class, namespace, or\n  enumeration. [...]</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26744528_26744867_2\">A name prefixed by a nested-name-specifier that nominates an\n  enumeration type shall represent an enumerator of that enumeration.</p>\n</blockquote>\n<p>again, there is nothing restricting this behavior to scoped enumerations. </p>\n<p><a href=\"https://stackoverflow.com/q/21364398/1708801\">Examples are non normative</a> but as long as they don't conflict with the normative text then they should be considered a good guideline.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:46.413", "Id": "26744867", "Score": "7", "CreationDate": "2014-11-04T20:56:30.790", "LastActivityDate": "2014-11-10T16:30:05.603"}, "26744528": {"CommentCount": "0", "AcceptedAnswerId": "26744867", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-11-04T20:35:02.900", "LastActivityDate": "2014-11-10T16:30:05.603", "LastEditDate": "2014-11-05T02:23:51.037", "ViewCount": "252", "FavoriteCount": "3", "Title": "C++11 Accessing Unscoped Enumerators with Qualified Name", "Id": "26744528", "Score": "9", "Body": "<p>I have a question about the wording of the C++11 standard as I have not had to dig into it frequently in the past and recently found myself confused on the (admittedly unimportant) topic of unscoped enums.</p>\n<p>I recently came across some code in a code review that was using an unscoped enum but accessing the enumerators using fully qualified names, like this:</p>\n<pre><code>enum SomeEnum\n{\n  EnumA,\n  ...\n};\n\nvoid foo()\n{\n  SomeEnum x = SomeEnum::EnumA;\n}\n</code></pre>\n<p>I was certain that this didn't work and that SomeEnum had to be an enum class for this behavior, but, sure enough, it compiled cleanly.</p>\n<p>Peeking into the C++11 standard, I at first thought that the standard agreed with me:</p>\n<blockquote>\n<p id=\"so_26744528_26744528_0\"><strong>\u00a7 7.2 Enumeration Declarations:</strong> Each enum-name and each unscoped\n  enumerator is declared in the scope that immediately contains the\n  enum-specifier. Each scoped enumerator is declared in the scope of the\n  enumeration.</p>\n</blockquote>\n<p>This appears to me to indicate that unscoped enumerators are declared only at the immediately containing scope of the enum itself. It doesn't mention that they are also declared at the enumeration scope.</p>\n<p>However, a little further down, the standard does include an example that shows accessing an unscoped enumerator using the fully qualified name.</p>\n<p>A quick bit of googling and searching on SO gave me a small number of places that assert that the standard does now allow the fully qualified name, but there isn't much discussion. Is this just weak wording in the spec that is clarified by the example, or is there something else I'm missing?</p>\n<p>Again, this isn't earth shattering, but I'm hoping someone can set me straight on my reading of the standard and I can learn something that may be useful in a future situation.</p>\n", "Tags": "<c++><c++11><enums><language-lawyer>", "OwnerUserId": "993780", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26744528_26744528_0": {"section_id": 5470, "quality": 0.8888888888888888, "length": 16}, "so_26744528_26744867_1": {"section_id": 7107, "quality": 0.9473684210526315, "length": 18}, "so_26744528_26744867_0": {"section_id": 5957, "quality": 0.8571428571428571, "length": 18}, "so_26744528_26744867_2": {"section_id": 7111, "quality": 1.0, "length": 9}}, "n3337": {"so_26744528_26744528_0": {"section_id": 5256, "quality": 0.8888888888888888, "length": 16}, "so_26744528_26744867_1": {"section_id": 6851, "quality": 0.9473684210526315, "length": 18}, "so_26744528_26744867_0": {"section_id": 5726, "quality": 0.8571428571428571, "length": 18}, "so_26744528_26744867_2": {"section_id": 6855, "quality": 1.0, "length": 9}}, "n4659": {"so_26744528_26744528_0": {"section_id": 6904, "quality": 0.8888888888888888, "length": 16}, "so_26744528_26744867_1": {"section_id": 8608, "quality": 0.9473684210526315, "length": 18}, "so_26744528_26744867_0": {"section_id": 7445, "quality": 0.8571428571428571, "length": 18}, "so_26744528_26744867_2": {"section_id": 8612, "quality": 1.0, "length": 9}}}});