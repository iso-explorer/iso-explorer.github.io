post_cb({"10681396": {"Id": "10681396", "PostTypeId": "2", "Body": "<p>Does the first one look like dividing? No. If you want to divide, use <code>x / 2</code>. Compiler can optimise it to use bit-shift if possible (it's called strength reduction), which makes it a useless micro-optimisation if you do it on your own.</p>\n", "LastEditorUserId": "912144", "LastActivityDate": "2012-05-22T11:33:08.993", "Score": "221", "CreationDate": "2012-05-21T07:56:38.147", "ParentId": "10681375", "CommentCount": "5", "OwnerUserId": "16102", "LastEditDate": "2012-05-22T11:33:08.993"}, "10684957": {"Id": "10684957", "PostTypeId": "2", "Body": "<p>x = x / 2; is the suitable code to use.. but an operation depend on your own program of how the output you wanted to produce.</p>\n", "LastActivityDate": "2012-05-21T12:07:29.733", "CommentCount": "0", "CreationDate": "2012-05-21T12:07:29.733", "ParentId": "10681375", "Score": "11", "OwnerUserId": "1407810"}, "10681389": {"Id": "10681389", "PostTypeId": "2", "Body": "<p>Just use divide (<code>/</code>), presuming it is clearer. The compiler will optimize accordingly.</p>\n", "LastActivityDate": "2012-05-21T07:56:04.133", "CommentCount": "4", "CreationDate": "2012-05-21T07:56:04.133", "ParentId": "10681375", "Score": "56", "OwnerUserId": "191596"}, "10694629": {"Id": "10694629", "PostTypeId": "2", "Body": "<p>As far as the CPU is concerned, bit-shift operations are faster than division operations.\nHowever, the compiler knows this and will optimize appropriately to the extent that it can, \nso you can code in the way that makes the most sense and rest easy knowing that your code is\nrunning efficiently. But remember that an <code>unsigned int</code> can (in some cases) be optimized better than an <code>int</code> for reasons previously pointed out. \nIf you don't need signed arithmatic, then don't include the sign bit.</p>\n", "LastActivityDate": "2012-05-22T01:17:05.007", "CommentCount": "0", "CreationDate": "2012-05-22T01:17:05.007", "ParentId": "10681375", "Score": "12", "OwnerUserId": "86060"}, "bq_ids": {"n4140": {"so_10681375_10681494_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6148}}, "n3337": {"so_10681375_10681494_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5911}}, "n4659": {"so_10681375_10681494_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7644}}}, "10681444": {"Id": "10681444", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10681375_10681444_0\">Which one is the best option and why for dividing the integer number by 2?</p>\n</blockquote>\n<p>Depends on what you mean by <strong>best</strong>. </p>\n<p>If you want your colleagues to hate you, or to make your code hard to read, I'd definitely go with the first option.</p>\n<p><strong>If you want to divide a number by 2, go with the second one.</strong></p>\n<p>The two are not equivalent, they don't behave the same if the number is negative or inside larger expressions - bitshift has lower precedence than <code>+</code> or <code>-</code>, division has higher precedence.</p>\n<p>You should write your code to express what its intent is. If performance is your concern, don't worry, the optimizer does a good job at these sort of micro-optimizations.</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-05-23T07:56:09.167", "Score": "62", "CreationDate": "2012-05-21T07:59:03.743", "ParentId": "10681375", "CommentCount": "0", "OwnerUserId": "673730", "LastEditDate": "2012-05-23T07:56:09.167"}, "10681410": {"Id": "10681410", "PostTypeId": "2", "Body": "<p><code>x / 2</code> is clearer, and <code>x &gt;&gt; 1</code> is not much faster (according to a micro-benchmark, about 30% faster for a Java JVM). As others have noted, for negative numbers the rounding is slightly different, so you have to consider this when you want to process negative numbers. Some compilers may automatically convert <code>x / 2</code> to <code>x &gt;&gt; 1</code> if they know the number can not be negative (even thought I could not verify this). </p>\n<p>Even <code>x / 2</code> may not use the (slow) division CPU instruction, because <a href=\"http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22JYOwLgBAZg9jAUFSWBAlAKAN4YhATgKZgCu%2BISEA9BAEwDcGAvkAAA%3D%3D%22%2C%22compiler%22%3A%22g520%22%2C%22options%22%3A%22-O1%20-std%3Dc%2B%2B0x%20-fomit-frame-pointer%22%7D%5D%7D\" rel=\"nofollow noreferrer\">some shortcuts are possible</a>, but it is still slower than <code>x &gt;&gt; 1</code>.</p>\n<p>(This is a C / C++ question, other programming languages have more operators. For Java there is also the unsigned right shift, <code>x &gt;&gt;&gt; 1</code>, which is again different. It allows to correctly calculate the mean (average) value of two values, so that <code>(a + b) &gt;&gt;&gt; 1</code> will return the mean value even for very large values of <code>a</code> and <code>b</code>. This is required for example for binary search if the array indices can get very large. There was <a href=\"http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\" rel=\"nofollow noreferrer\">a bug in many versions of binary search</a>, because they used <code>(a + b) / 2</code> to calculate the average. This doesn't work correctly. The correct solution is to use <code>(a + b) &gt;&gt;&gt; 1</code> instead.)</p>\n", "LastEditorUserId": "382763", "LastActivityDate": "2016-07-30T11:15:15.080", "Score": "32", "CreationDate": "2012-05-21T07:57:21.263", "ParentId": "10681375", "CommentCount": "4", "OwnerUserId": "382763", "LastEditDate": "2016-07-30T11:15:15.080"}, "10711722": {"Id": "10711722", "PostTypeId": "2", "Body": "<p>Knuth said:</p>\n<blockquote>\n<p id=\"so_10681375_10711722_0\"><em>Premature optimization is the root of all evil.</em></p>\n</blockquote>\n<p>So I suggest to use <code>x /= 2;</code></p>\n<p>This way the code is easy to understand and also I think that the optimization of this operation in that form, don't mean a big difference for the processor.</p>\n", "LastActivityDate": "2012-05-22T23:58:57.280", "CommentCount": "1", "CreationDate": "2012-05-22T23:58:57.280", "ParentId": "10681375", "Score": "22", "OwnerUserId": "1411395"}, "10681871": {"Id": "10681871", "PostTypeId": "2", "Body": "<p>To pile on: there are so many reasons to favor using <code>x = x / 2;</code>  Here are some:</p>\n<ul>\n<li><p>it expresses your intent more clearly (assuming you're not dealing with bit twiddling register bits or something)</p></li>\n<li><p>the compiler will reduce this to a shift operation anyway</p></li>\n<li><p>even if the compiler didn't reduce it and chose a slower operation than the shift, the likelihood that this ends up affecting your program's performance in a measurable way is itself vanishingly small (and if it does affect it measurably, then you have an actual reason to use a shift)</p></li>\n<li><p>if the division is going to be part of a larger expression, you're more likely to get the precedence right if you use the division operator:</p>\n<pre><code>x = x / 2 + 5;\nx = x &gt;&gt; 1 + 5;  // not the same as above\n</code></pre></li>\n<li><p>signed arithmetic might complicate things even more than the precedence problem mentioned above</p></li>\n<li><p>to reiterate - the compiler will already do this for you anyway. In fact, it'll convert division by a constant to a series of shifts, adds, and multiplies for all sorts of numbers, not just powers of two. See <a href=\"https://stackoverflow.com/a/1168616/12711\">this question</a> for links to even more information about this.</p></li>\n</ul>\n<p>In short, you buy nothing by coding a shift when you really mean to multiply or divide, except maybe an increased possibility of introducing a bug. It's been a lifetime since compilers weren't smart enough to optimize this kind of thing to a shift when appropriate.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-03T16:37:41.667", "Score": "186", "CreationDate": "2012-05-21T08:34:03.790", "ParentId": "10681375", "CommentCount": "7", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T12:03:05.607"}, "10690830": {"Id": "10690830", "PostTypeId": "2", "Body": "<p>Just an added note -</p>\n<p>x *= 0.5 will often be faster in some VM-based languages -- notably actionscript, as the variable won't have to be checked for divide by 0.</p>\n", "LastEditorUserId": "314752", "LastActivityDate": "2012-05-21T21:04:40.700", "Score": "15", "CreationDate": "2012-05-21T18:46:31.020", "ParentId": "10681375", "CommentCount": "4", "OwnerUserId": "314752", "LastEditDate": "2012-05-21T21:04:40.700"}, "10700416": {"Id": "10700416", "PostTypeId": "2", "Body": "<p>generaly the right shift divides : </p>\n<pre><code>q = i &gt;&gt; n; is the same as: q = i / 2**n;\n</code></pre>\n<p>this is sometimes used to speed up programs at the cost of clarity. I don't think you should do it . The compiler is smart enough to perform the speedup automatically. This means that <strong>putting in a shift gains you nothing at the expense of clarity</strong>.</p>\n<p>Take a look at this <a href=\"http://books.google.fr/books?id=pXDzdJ_1E3oC&amp;pg=PT189&amp;dq=c%2b%2b%20shift%20left&amp;hl=fr&amp;sa=X&amp;ei=jGe7T8LxDLOY1AWBu_DlBw&amp;ved=0CDUQ6AEwAA#v=onepage&amp;q=c%2b%2b%20shift%20left&amp;f=false\">page from Practical C++ Programming.</a></p>\n", "LastEditorUserId": "271999", "LastActivityDate": "2012-05-22T11:15:40.323", "Score": "7", "CreationDate": "2012-05-22T10:41:15.207", "ParentId": "10681375", "CommentCount": "1", "OwnerUserId": "271999", "LastEditDate": "2012-05-22T11:15:40.323"}, "10770803": {"Id": "10770803", "PostTypeId": "2", "Body": "<p>Take a look at the compiler output to help you decide.  I ran this test on x86-64 with<br>\ngcc (GCC) 4.2.1 20070719  [FreeBSD]</br></p>\n<p>Also see <a href=\"http://goo.gl/KRgIkb\" rel=\"nofollow\">compiler outputs online at godbolt</a>.</p>\n<p>What you see is the compiler does use a <code>sarl</code> (arithmetic right-shift) instruction in both cases, so it does recognize the similarity between the two expressions.  If you use the divide, the compiler also needs to adjust for negative numbers. To do that it shifts the sign bit down to the lowest order bit, and adds that to the result.  This fixes the off-by-one issue when shifting negative numbers, compared to what a divide would do.<br>\nSince the divide case does 2 shifts, while the explicit shift case only does one, we can now explain some of the performance differences measured by other answers here.</br></p>\n<p>C code with assembly output:</p>\n<p>For divide, your input would be </p>\n<pre><code>int div2signed(int a) {\n  return a / 2;\n}\n</code></pre>\n<p>and this compiles to</p>\n<pre><code>    movl    %edi, %eax\n    shrl    $31, %eax\n    addl    %edi, %eax\n    sarl    %eax\n    ret\n</code></pre>\n<p>similarly for shift</p>\n<pre><code>int shr2signed(int a) {\n  return a &gt;&gt; 1;\n}\n</code></pre>\n<p>with output:</p>\n<pre><code>    sarl    %edi\n    movl    %edi, %eax\n    ret\n</code></pre>\n", "LastEditorUserId": "224132", "LastActivityDate": "2015-10-04T15:12:00.133", "Score": "17", "CreationDate": "2012-05-27T00:32:25.617", "ParentId": "10681375", "CommentCount": "5", "OwnerUserId": "75204", "LastEditDate": "2015-10-04T15:12:00.133"}, "41256629": {"Id": "41256629", "PostTypeId": "2", "Body": "<p>While x&gt;&gt;1 is faster than x/2, the proper use of &gt;&gt; when dealing with negative values is a little more complicated.  It requires something similar to the following:</p>\n<pre><code>// Extension Method\npublic static class Global {\n    public static int ShiftDivBy2(this int x) {\n        return (x &lt; 0 ? x + 1 : x) &gt;&gt; 1;\n    }\n}\n</code></pre>\n", "LastActivityDate": "2016-12-21T06:41:31.343", "CommentCount": "0", "CreationDate": "2016-12-21T06:41:31.343", "ParentId": "10681375", "Score": "0", "OwnerUserId": "4190564"}, "10681494": {"Id": "10681494", "PostTypeId": "2", "Body": "<p>I agree with other answers that you should favor <code>x / 2</code> because its intent is clearer, and the compiler should optimize it for you.</p>\n<p>However, another reason for preferring <code>x / 2</code> over <code>x &gt;&gt; 1</code> is that the behavior of <code>&gt;&gt;</code> is implementation-dependent if <code>x</code> is a signed <code>int</code> and is negative.</p>\n<p>From section 6.5.7, bullet 5 of the ISO C99 standard:</p>\n<blockquote>\n<p id=\"so_10681375_10681494_0\">The result of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. If <code>E1</code> has\n  an unsigned type or if <code>E1</code> has a signed type and a nonnegative value,\n  the value of the result is the integral part of the quotient of <code>E1</code> /\n  2<sup><code>E2</code></sup>. If <code>E1</code> has a signed type and a negative value, the resulting value\n  is implementation-defined.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-21T08:02:33.903", "CommentCount": "1", "CreationDate": "2012-05-21T08:02:33.903", "ParentId": "10681375", "Score": "38", "OwnerUserId": "179715"}, "10681422": {"Id": "10681422", "PostTypeId": "2", "Body": "<p>Use the operation that best describes what you are trying to do.</p>\n<ul>\n<li>If you are treating the number as a sequence of bits, use bitshift.</li>\n<li>If you are treating it as a numerical value, use division.</li>\n</ul>\n<p>Note that they are not exactly equivalent. They can give different results for negative integers. For example: </p>\n<pre><code>-5 / 2  = -2\n-5 &gt;&gt; 1 = -3\n</code></pre>\n<p><a href=\"http://ideone.com/lnABV\" rel=\"noreferrer\">(ideone)</a></p>\n", "LastEditorUserId": "61974", "LastActivityDate": "2012-05-21T17:16:53.773", "Score": "832", "CreationDate": "2012-05-21T07:57:52.080", "ParentId": "10681375", "CommentCount": "20", "OwnerUserId": "61974", "LastEditDate": "2012-05-21T17:16:53.773"}, "10948063": {"Id": "10948063", "PostTypeId": "2", "Body": "<p>Obviously, if you are writing your code for the next guy who reads it, go for the clarity of \"x/2\".</p>\n<p><strong>However, if speed is your goal, try it both ways and time the results.</strong> A few months ago I worked on a bitmap  convolution routine which involved stepping through an array of integers and dividing each element by 2. I did all kinds of things to optimize it including the old trick of substituting \"x&gt;&gt;1\" for \"x/2\".</p>\n<p>When I actually timed both ways I discovered to my surprise that <strong>x/2 was faster than x&gt;&gt;1</strong> </p>\n<p>This was using Microsoft VS2008 C++ with the default optimizations turned on.</p>\n", "LastEditorUserId": "48068", "LastActivityDate": "2012-06-20T11:33:36.513", "Score": "7", "CreationDate": "2012-06-08T11:34:59.853", "ParentId": "10681375", "CommentCount": "0", "OwnerUserId": "48068", "LastEditDate": "2012-06-20T11:33:36.513"}, "10710228": {"Id": "10710228", "PostTypeId": "2", "Body": "<p>The answer to this will depend on the environment you're working under.</p>\n<ul>\n<li>If you're working on an 8-bit microcontroller or anything without hardware support for multiplication, bit shifting is expected and commonplace, and while the compiler will almost certainly turn <code>x /= 2</code> into <code>x &gt;&gt;= 1</code>, the presence of a division symbol will raise more eyebrows in that environment than using a shift to effect a division.</li>\n<li>If you're working in a performance-critical environment or section of code, or your code could be compiled with compiler optimization off, <code>x &gt;&gt;= 1</code> with a comment explaining its reasoning is probably best just for clarity of purpose.</li>\n<li>If you're not under one of the above conditions, make your code more readable by simply using <code>x /= 2</code>.  Better to save the next programmer who happens to look at your code the 10 second double-take on your shift operation than to needlessly prove you knew the shift was more efficient sans compiler optimization.</li>\n</ul>\n<p>All these assume unsigned integers.  The simple shift is probably not what you want for signed.  Also, DanielH brings up a good point about using <code>x *= 0.5</code> for certain languages like ActionScript.</p>\n", "LastActivityDate": "2012-05-22T21:11:21.797", "CommentCount": "0", "CreationDate": "2012-05-22T21:11:21.797", "ParentId": "10681375", "Score": "10", "OwnerUserId": "1224427"}, "10696470": {"Id": "10696470", "PostTypeId": "2", "Body": "<p>Use <code>x = x / 2;</code>  OR  <code>x /= 2;</code> Because it is possible that a new programmer works on it in future. So it will be easier for him to find out what is going on in the line of code. Everyone may not be aware of such optimizations.</p>\n", "LastEditorUserId": "946170", "LastActivityDate": "2012-05-22T07:56:53.650", "Score": "13", "CreationDate": "2012-05-22T05:58:09.947", "ParentId": "10681375", "CommentCount": "0", "OwnerUserId": "946170", "LastEditDate": "2012-05-22T07:56:53.650"}, "10690735": {"Id": "10690735", "PostTypeId": "2", "Body": "<p>I am telling for the purpose of programming competitions. Generally they have very large inputs where division  by 2 takes place many times and its known that input is positive or negative. </p>\n<p>x&gt;&gt;1 will be better than x/2. I checked on ideone.com by running a program where more than 10^10 division by 2 operations took place. x/2 took nearly 5.5s whereas x&gt;&gt;1 took nearly 2.6s for same program.</p>\n", "LastActivityDate": "2012-05-21T18:39:43.170", "CommentCount": "1", "CreationDate": "2012-05-21T18:39:43.170", "ParentId": "10681375", "Score": "12", "OwnerUserId": "1053930"}, "10692173": {"Id": "10692173", "PostTypeId": "2", "Body": "<p>mod 2, test for = 1. dunno the syntax in c. but this may be fastest.</p>\n", "LastActivityDate": "2012-05-21T20:30:22.530", "CommentCount": "0", "CreationDate": "2012-05-21T20:30:22.530", "ParentId": "10681375", "Score": "8", "OwnerUserId": "484698"}, "10681375": {"ViewCount": "50457", "Body": "<p>Which of the following techniques is the best option for dividing an integer by 2 and why?</p>\n<p>Technique 1:</p>\n<pre><code>x = x &gt;&gt; 1;\n</code></pre>\n<p>Technique 2:</p>\n<pre><code>x = x / 2;\n</code></pre>\n<p>Here <code>x</code> is an integer.</p>\n", "AcceptedAnswerId": "10681422", "Title": "Which is better option to use for dividing an integer number by 2?", "CreationDate": "2012-05-21T07:54:36.977", "Id": "10681375", "CommentCount": "11", "FavoriteCount": "82", "PostTypeId": "1", "LastEditDate": "2016-07-29T17:29:34.860", "LastEditorUserId": "5861", "LastActivityDate": "2016-12-21T06:41:31.343", "Score": "380", "OwnerUserId": "223622", "Tags": "<c++><c><optimization><division><micro-optimization>", "AnswerCount": "23"}, "10749126": {"Id": "10749126", "PostTypeId": "2", "Body": "<p>X/Y is a correct one...and \" &gt;&gt; \" shifting operator..if we want two divide a integer we can use (/) dividend operator. shift operator is used to shift the bits..   </p>\n<p>x=x/2;\nx/=2; we can use like this..</p>\n", "LastActivityDate": "2012-05-25T05:51:53.890", "CommentCount": "0", "CreationDate": "2012-05-25T05:51:53.890", "ParentId": "10681375", "Score": "3", "OwnerUserId": "1416413"}, "10698412": {"Id": "10698412", "PostTypeId": "2", "Body": "<p>Make your intentions clearer...for example, if you want to divide, use x / 2, and let the compiler optimize it to shift operator (or anything else).</p>\n<p>Today's processors won't let these optimizations have any impact on the performance of your programs.</p>\n", "LastActivityDate": "2012-05-22T08:29:03.087", "CommentCount": "0", "CreationDate": "2012-05-22T08:29:03.087", "ParentId": "10681375", "Score": "11", "OwnerUserId": "1409680"}, "10692050": {"Id": "10692050", "PostTypeId": "2", "Body": "<p>I would say there are several things to consider.</p>\n<ol>\n<li><p>Bitshift should be faster, as no special computation is really\n    needed to shift the bits, however as pointed out, there are\n    potential issues with negative numbers. If you are ensured to have\n    positive numbers, and are looking for speed then I would recommend\n    bitshift. </p></li>\n<li><p>The division operator is very easy for humans to read.\n        So if you are looking for code readability, you could use this. Note\n        that the field of compiler optimization has come a long way, so making code easy\n        to read and understand is good practice.</p></li>\n<li>Depending on the underlying hardware,\n        operations may have different speeds. Amdal's law is to make the\n        common case fast. So you may have hardware that can perform\n        different operations faster than others. For example, multiplying by\n        0.5 may be faster than dividing by 2. (Granted you may need to take the floor of the multiplication if you wish to enforce integer division).</li>\n</ol>\n<p>If you are after pure performance, I would recommend creating some tests that could do the operations millions of times. Sample the execution several times (your sample size) to determine which one is statistically best with your OS/Hardware/Compiler/Code.</p>\n", "LastActivityDate": "2012-05-21T20:21:51.530", "CommentCount": "3", "CreationDate": "2012-05-21T20:21:51.530", "ParentId": "10681375", "Score": "12", "OwnerUserId": "1190934"}, "10706987": {"Id": "10706987", "PostTypeId": "2", "Body": "<p>In terms of performance. CPU's shift operations are significantly faster than divide op-codes.\nSo dividing by two or multiplying by 2 etc all benefit from shift operations. </p>\n<p>As to the look and feel. As engineers when did we become so attached to cosmetics that even beautiful ladies don't use! :)</p>\n", "LastActivityDate": "2012-05-22T17:25:52.300", "CommentCount": "0", "CreationDate": "2012-05-22T17:25:52.300", "ParentId": "10681375", "Score": "4", "OwnerUserId": "1150825"}});