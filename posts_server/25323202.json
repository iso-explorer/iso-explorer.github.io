post_cb({"25323589": {"ParentId": "25323202", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>As Christophe has already written, this is basically an undefined operation.</p>\n<p>So why does C++ and PHP does it one way, and C# and Java the other way?</p>\n<p>In this case (which may be different for different compilers and platforms), the order of evaluation of arguments in C++ is inverted compared to C# - C# evaluates arguments in order of writing, while the C++ sample does it the other way around. This boils down to the default calling conventions both use, but again - for C++, this is an undefined operation, so it may differ based on other conditions.</p>\n<p>To illustrate, this C# code:</p>\n<pre><code>class Program\n{\n    static int x = 0;\n\n    static int f()\n    {\n        x = x + 10;\n        return 1;\n    }\n\n    public static void Main()\n    {\n        x = f() + x;\n        System.Console.WriteLine(x);\n    }\n}\n</code></pre>\n<p>Will produce <code>11</code> on output, rather than <code>1</code>.</p>\n<p>That's simply because C# evaluates \"in order\", so in your example, it first reads <code>x</code> and then calls <code>f()</code>, while in mine, it first calls <code>f()</code> and then reads <code>x</code>.</p>\n<p>Now, this still might be unrealiable. IL (.NET's bytecode) has <code>+</code> as pretty much any other method, but optimizations by the JIT compiler <em>might</em> result in a different order of evaluation. On the other hand, since C# (and .NET) <em>does</em> define the order of evaluation / execution, so I guess a compliant compiler should <em>always</em> produce this result.</p>\n<p>In any case, that's a lovely unexpected outcome you've found, and a cautionary tale - side-effects in methods can be a problem even in imperative languages :)</p>\n<p>Oh, and of course - <code>static</code> means something different in C# vs. C++. I've seen that mistake made by C++ers coming to C# before.</p>\n<p><strong>EDIT</strong>:</p>\n<p>Let me just expand a bit on the \"different languages\" issue. You've automatically assumed, that C++'s result is the correct one, because when you're doing the calculation manually, you're doing the evaluation in a certain order - and you've determined this order to comply with the results from C++. However, neither C++ nor C# do analysis on the expression - it's simply a bunch of operations over some values.</p>\n<p>C++ <em>does</em> store <code>x</code> in a register, just like C#. It's just that C# stores it <em>before</em> evaluating the method call, while C++ does it <em>after</em>. If you change the C++ code to do <code>x = f() + x</code> instead, just like I've done in C#, I expect you'll get the <code>1</code> on output.</p>\n<p>The most important part is that C++ (and C) simply didn't specify an explicit order of operations, probably because it wanted to exploit architectures and platforms that do either one of those orders. Since C# and Java were developed in a time when this doesn't really matter anymore, and since they could learn from all those failures of C/C++, they specified an explicit order of evaluation.</p>\n", "OwnerUserId": "3032289", "LastEditorUserId": "3032289", "LastEditDate": "2014-08-15T11:30:17.960", "Id": "25323589", "Score": "7", "CreationDate": "2014-08-15T08:43:21.243", "LastActivityDate": "2014-08-15T11:30:17.960"}, "25323202": {"CommentCount": "23", "AcceptedAnswerId": "25323426", "PostTypeId": "1", "LastEditorUserId": "815724", "CreationDate": "2014-08-15T08:11:18.033", "LastActivityDate": "2014-08-16T20:54:00.070", "LastEditDate": "2014-08-15T14:24:26.110", "ViewCount": "4277", "FavoriteCount": "3", "Title": "C++ and PHP vs C# and Java - unequal results", "Id": "25323202", "Score": "30", "Body": "<p>I found something a little strange in C# and Java.\nLet's look at this C++ code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Simple\n{\npublic:\n    static int f()\n    {\n        X = X + 10;\n        return 1;\n    }\n\n    static int X;\n};\nint Simple::X = 0;\n\nint main() {\n    Simple::X += Simple::f();\n    printf(\"X = %d\", Simple::X);\n    return 0;\n}\n</code></pre>\n<p>In a console you will see X = 11 (<a href=\"http://ideone.com/zm2RaN\">Look at the result here - IdeOne C++</a>).</p>\n<p>Now let's look at the same code on C#:</p>\n<pre><code>class Program\n{\n    static int x = 0;\n\n    static int f()\n    {\n        x = x + 10;\n        return 1;\n    }\n\n    public static void Main()\n    {\n        x += f();\n        System.Console.WriteLine(x);\n    }\n}\n</code></pre>\n<p>In a console you will see 1 (not 11!) (look at the result here - <a href=\"http://ideone.com/v8rktM\">IdeOne C#</a>\nI know what you thinking now - \"How that is possible?\", but let's go to the following code.</p>\n<p>Java code:</p>\n<pre><code>import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\n    static int X = 0;\n    static int f()\n    {\n        X = X + 10;\n        return 1;\n    }\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Formatter f = new Formatter();\n        f.format(\"X = %d\", X += f());\n        System.out.println(f.toString());\n    }\n}\n</code></pre>\n<p>Result the same as in C# (X = 1, look at the result <a href=\"http://ideone.com/cNtKc4\">here</a>).</p>\n<p>And for the last time let's look at the PHP code:</p>\n<pre><code>&lt;?php\nclass Simple\n{\n    public static $X = 0;\n\n    public static function f()\n    {\n        self::$X = self::$X + 10;\n        return 1;\n    }\n}\n\n$simple = new Simple();\necho \"X = \" . $simple::$X += $simple::f();\n?&gt;\n</code></pre>\n<p>Result is 11 (look at the result <a href=\"http://ideone.com/m6rvFB\">here</a>).</p>\n<p>I have a little theory - these languages (C# and Java) are making a local copy of static variable X on the stack (are they ignoring the <strong>static</strong> keyword?). And that is reason why result in those languages is 1.</p>\n<p>Is somebody here, who have other versions?</p>\n", "Tags": "<java><c#><php><c++><expression-evaluation>", "OwnerUserId": "2585154", "AnswerCount": "4"}, "25323426": {"ParentId": "25323202", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The C++ standard states: </p>\n<blockquote>\n<p id=\"so_25323202_25323426_0\">With respect to an indeterminately-sequenced function call, the operation of a compound assignment is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single compound assignment operator. \u2014end note ]</p>\n<p id=\"so_25323202_25323426_1\">\u00a75.17 [expr.ass]</p>\n</blockquote>\n<p>Hence, as in the same evaluation you use <code>X</code> and a function with a side effect on <code>X</code>, the result is undefined, because:</p>\n<blockquote>\n<p id=\"so_25323202_25323426_2\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n<p id=\"so_25323202_25323426_3\">\u00a71.9 [intro.execution]</p>\n</blockquote>\n<p>It happens to be 11 on many compilers, but there is no guarantee that a C++ compiler won't give you 1 as for the other languages. </p>\n<p>If you're still skeptical, another analysis of the standard leads to the same conclusion:  THe standard also says in the same section as above:  </p>\n<blockquote>\n<p id=\"so_25323202_25323426_4\">The behavior of an expression of the form <code>E1 op = E2</code> is equivalent to <code>E1 = E1 op E2</code> except that <code>E1</code> is evaluated only once.</p>\n</blockquote>\n<p>In you case <code>X = X + f()</code> except that <code>X</code> is evaluated only once.<br>\nAs there is no guarantee on the order of evaluation, in <code>X + f()</code>, you cannot take for granted that first f is evaluated and then <code>X</code>.  </br></p>\n<p><strong>Addendum:</strong> \nI'm not a java expert, but the java rules clearly specify the order of evaluation in an expression, which is guaranteed to be from left to right in section 15.7 of <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html\">java specifications</a>. In section <em>15.26.2. Compound Assignment Operators</em> the java specs also say that <code>E1 op= E2</code> is equivalent to <code>E1 = (T) ((E1) op (E2))</code>.  </p>\n<p>In your java programm this means again that your expression is equivalent to <code>X = X + f()</code> and first <code>X</code> is evaluated, then <code>f()</code>.  So the side effect of <code>f()</code> is not taken into account in the result.  </p>\n<p>So your java compiler doesn't have a bug. It just complies with the specifications.  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "305545", "LastEditDate": "2014-08-16T06:48:53.647", "Id": "25323426", "Score": "48", "CreationDate": "2014-08-15T08:29:53.793", "LastActivityDate": "2014-08-16T06:48:53.647"}, "25323699": {"ParentId": "25323202", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the Java language specification: </p>\n<blockquote>\n<p id=\"so_25323202_25323699_0\"><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2\" rel=\"nofollow\">JLS 15.26.2, Compound Assignment Operators</a></p>\n<p id=\"so_25323202_25323699_1\">A compound assignment expression of the form\n  <code>E1 op= E2</code>\n  is equivalent to\n  <code>E1\n  = (T) ((E1) op (E2))</code>\n  , where\n  <code>T</code>\n  is the type of\n  <code>E1</code>\n  , except that\n  <code>E</code>1\n  is evaluated\n  only once.</p>\n</blockquote>\n<p>This small program demonstrates the difference, and exhibits expected behavior based on this standard. </p>\n<pre><code>public class Start\n{\n    int X = 0;\n    int f()\n    {\n        X = X + 10;\n        return 1;\n    }\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Start actualStart = new Start();\n        Start expectedStart = new Start();\n        int actual = actualStart.X += actualStart.f();\n        int expected = (int)(expectedStart.X + expectedStart.f());\n        int diff = (int)(expectedStart.f() + expectedStart.X);\n        System.out.println(actual == expected);\n        System.out.println(actual == diff);\n    }\n}\n</code></pre>\n<p>In order, </p>\n<ol>\n<li><code>actual</code> is assigned to value of <code>actualStart.X += actualStart.f()</code>. </li>\n<li><code>expected</code> is assigned to the value of the</li>\n<li>result of retrieving <code>actualStart.X</code>, which is <code>0</code>, and </li>\n<li>applying the addition operator to <code>actualStart.X</code> with</li>\n<li>the return value of invoking <code>actualStart.f()</code>, which is <code>1</code></li>\n<li>and assigning the result of <code>0 + 1</code> to <code>expected</code>.</li>\n</ol>\n<p>I also declared <code>diff</code> to show how changing the order of invocation changes the result. </p>\n<ol>\n<li><code>diff</code> is assigned to value of the</li>\n<li>the return value of invoking <code>diffStart.f()</code>, with is <code>1</code>, and</li>\n<li>applying the addition operator to that value with </li>\n<li>the value of <code>diffStart.X</code> (which is 10, a side effect of <code>diffStart.f()</code></li>\n<li>and assigning the result of <code>1 + 10</code> to <code>diff</code>. </li>\n</ol>\n<p>In Java, this is <em>not</em> undefined behavior. </p>\n<p>Edit: </p>\n<p>To address your point regarding local copies of variables. That is correct, but it has nothing to do with <code>static</code>. Java saves the result of evaluating each side (left side first), then evaluates result of performing the operator on the saved values. </p>\n", "OwnerUserId": "272287", "LastEditorUserId": "272287", "LastEditDate": "2014-08-15T09:03:39.373", "Id": "25323699", "Score": "4", "CreationDate": "2014-08-15T08:51:43.587", "LastActivityDate": "2014-08-15T09:03:39.373"}, "25324088": {"ParentId": "25323202", "PostTypeId": "2", "CommentCount": "18", "Body": "<p><strong><em>Edit:</em></strong> Thanks to comments by Deduplicator and user694733, here is a modified version of my original answer.</p>\n<hr>\n<p>The C++ version has <del>undefined</del><em>unspecified</em> behaviour.</p>\n<p>There is a subtle difference between \"undefined\" and \"unspecified\", in that the former allows a program to do <em>anything</em> (including crashing) whereas the latter allows it to choose from a set of particular allowed behaviours without dictating which choice is correct.</p>\n<p>Except of very rare cases, you will always want to avoid both.</p>\n<hr>\n<p>A good starting point to understand whole issue are the C++ FAQs <a href=\"https://isocpp.org/wiki/faq/misc-technical-issues#double-mod-betw-seq-pt\" rel=\"noreferrer\">Why do some people think x = ++y + y++ is bad? </a>, <a href=\"https://isocpp.org/wiki/faq/misc-technical-issues#evaluation-order\" rel=\"noreferrer\">What\u2019s the value of i++ + i++?</a> and <a href=\"https://isocpp.org/wiki/faq/misc-technical-issues#sequence-points\" rel=\"noreferrer\">What\u2019s the deal with \u201csequence points\u201d?</a>:</p>\n<blockquote>\n<p id=\"so_25323202_25324088_0\"><strong>Between the previous and next sequence point</strong> a scalar object shall\n  have its stored <strong>value modified at most once</strong> by the evaluation of an\n  expression.</p>\n</blockquote>\n<p>(...)</p>\n<blockquote>\n<p id=\"so_25323202_25324088_1\">Basically, in C and C++, if you read a variable twice in an expression\n  where you also write it, the result is <strong>undefined</strong>.</p>\n</blockquote>\n<p>(...)</p>\n<blockquote>\n<p id=\"so_25323202_25324088_2\">At certain specified points in the execution sequence called sequence\n  points, all side effects of previous evaluations shall be complete and\n  no side effects of subsequent evaluations shall have taken place. (...)\n  The \u201ccertain specified points\u201d that are called <strong>sequence points are</strong> (...)\n  <strong>after evaluation of all a function\u2019s parameters</strong> but before the first\n  expression within the function is executed.</p>\n</blockquote>\n<p>In short, modifying a variable twice between two consecutive sequence points yields undefined behaviour, but a function call introduces an intermediate sequence point (actually, two intermediate sequence points, because the return statement creates another one).</p>\n<p>This means the fact that you have a function call in your expression \"saves\" your <code>Simple::X += Simple::f();</code> line from being undefined and turns it into \"only\" unspecified.</p>\n<p>Both 1 and 11 are possible and correct outcomes, whereas printing 123, crashing or sending an insulting e-mail to your boss are not allowed behaviours; you'll just never get a guarantee whether 1 or 11 will be printed.</p>\n<hr>\n<p>The following example is slightly different. It's seemingly a simplification of the original code but really serves to highlight the difference between undefined and unspecified behaviour:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 0;\n    x += (x += 10, 1);\n    std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Here the behaviour is indeed undefined, because the function call has gone away, so both modifications of <code>x</code> occur between two consecutive sequence points. The compiler is allowed by the C++ language specification to create a program which prints 123, crashes or sends an insulting e-mail to your boss.</p>\n<p>(The e-mail thing of course is just a very common humorous attempt at explaining how <em>undefined</em> really means <em>anything goes</em>. Crashes are often a more realistic result of undefined behaviour.)</p>\n<p>In fact, the <code>, 1</code> (just like the return statement in your original code) is a red herring. The following yields undefined behaviour, too:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 0;\n    x += (x += 10);\n    std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>This <em>may</em> print 20 (it does so on my machine with VC++ 2013) but the behaviour is still undefined.</p>\n<p>(Note: this applies to built-in operators. Operator overloading changes the behaviour back to <em>specified</em>, because overloaded operators copy the <em>syntax</em> from the built-in ones but have the <em>semantics</em> of functions, which means that an overloaded <code>+=</code> operator of a custom type that appears in an expression is actually a <em>function call</em>. Therefore, not only are sequence points introduced but the entire ambiguity goes away, the expression becoming equivalent to <code>x.operator+=(x.operator+=(10));</code>, which has guaranteed order of argument evaluation. This is probably irrelevant to your question but should be mentioned anyway.)</p>\n<p>In contrast, the Java version</p>\n<pre><code>import java.io.*;\n\nclass Ideone\n{\n    public static void main(String[] args)\n    {\n        int x = 0;\n        x += (x += 10);\n        System.out.println(x);\n    }\n}\n</code></pre>\n<p><em>must</em> print 10. This is because Java has neither undefined nor unspecified behaviour with regards to evaluation order. There are no sequence points to be concerned about. See <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html\" rel=\"noreferrer\">Java Language Specification 15.7. Evaluation Order</a>:</p>\n<blockquote>\n<p id=\"so_25323202_25324088_3\">The Java programming language guarantees that the operands of\n  operators appear to be evaluated in a specific evaluation order,\n  namely, from left to right.</p>\n</blockquote>\n<p>So in the Java case, <code>x += (x += 10)</code>, interpreted from left to right, means that first something is added to <em>0</em>, and that something is <em>0 + 10</em>. Hence <em>0 + (0 + 10) = 10</em>.</p>\n<p>See also example 15.7.1-2 in the Java specification.</p>\n<p>Going back to your original example, this also means that the more complex example with the static variable has defined and specified behaviour in Java.</p>\n<hr>\n<p>Honestly, I don't know about C# and PHP but I would guess that both of them have some guaranteed evaluation order as well. C++, unlike most other programming languages (but like C) tends to allow much more undefined and unspecified behaviour than other languages. That's not good or bad. It's a <strong>tradeoff between robustness and efficiency</strong>. Choosing the right programming language for a particular task or project is always a matter of analysing tradeoffs.</p>\n<p>In any case, expressions with such side effects are <strong>bad programming style in all four languages</strong>.</p>\n<p>One final word:</p>\n<blockquote>\n<p id=\"so_25323202_25324088_4\">I found a little bug in C# and Java.</p>\n</blockquote>\n<p>You should not assume to find bugs in <em>language specifications</em> or <em>compilers</em> if you don't have many years of professional experience as a software engineer.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "3313064", "LastEditorUserId": "3313064", "LastEditDate": "2014-08-15T21:09:51.893", "Id": "25324088", "Score": "20", "CreationDate": "2014-08-15T09:23:44.347", "LastActivityDate": "2014-08-15T21:09:51.893"}, "bq_ids": {"n4140": {"so_25323202_25323699_1": {"section_id": 6179, "quality": 0.6, "length": 6}, "so_25323202_25323426_0": {"section_id": 6173, "quality": 0.8518518518518519, "length": 23}, "so_25323202_25323426_4": {"section_id": 6179, "quality": 0.875, "length": 7}, "so_25323202_25323426_2": {"section_id": 5811, "quality": 1.0, "length": 22}}, "n3337": {"so_25323202_25323699_1": {"section_id": 5940, "quality": 0.6, "length": 6}, "so_25323202_25323426_0": {"section_id": 5934, "quality": 0.8518518518518519, "length": 23}, "so_25323202_25323426_4": {"section_id": 5940, "quality": 0.875, "length": 7}, "so_25323202_25323426_2": {"section_id": 5584, "quality": 1.0, "length": 22}}, "n4659": {"so_25323202_25323699_1": {"section_id": 7681, "quality": 0.6, "length": 6}, "so_25323202_25323426_0": {"section_id": 7675, "quality": 0.8518518518518519, "length": 23}, "so_25323202_25323426_4": {"section_id": 7681, "quality": 0.875, "length": 7}, "so_25323202_25323426_2": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}}}});