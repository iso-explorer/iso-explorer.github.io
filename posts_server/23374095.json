post_cb({"23374456": {"ParentId": "23374095", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-04-29T20:16:23.910", "Score": "2", "LastEditorUserId": "3204551", "LastEditDate": "2014-05-03T11:16:56.393", "Id": "23374456", "OwnerUserId": "3204551", "Body": "<p>I went through the standard, and the stream operator should be defined in terms of the C function <code>strtod</code>, but only after filtering anything which could become Not-a-Number or infinity in Stage 2.</p>\n<p>Following the document trail:</p>\n<blockquote>\n<h3>27.7.2.2.2 Arithmetic extractors</h3>\n<p id=\"so_23374095_23374456_0\">As in the case of the inserters, these extractors depend on the locale\u2019s num_get&lt;&gt; (22.4.2.1) object\n  to perform parsing the input stream data. These extractors behave as formatted input functions (as\n  described in 27.7.2.2.1). After a sentry object is constructed, the conversion occurs as if performed by\n  the following code fragment:</p>\n</blockquote>\n<pre><code>typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;\niostate err = iostate::goodbit;\nuse_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, val);\nsetstate(err);\n</code></pre>\n<blockquote>\n<h3>22.4.2.1.2 num_get virtual functions</h3>\n<p id=\"so_23374095_23374456_1\">Stage 2: If <code>in==end</code> then stage 2 terminates. Otherwise a charT is taken from in and local variables\n  are initialized as if by</p>\n</blockquote>\n<pre><code>char_type ct = *in;\nchar c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];\nif (ct == use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).decimal_point())\n    c = \u2019.\u2019;\nbool discard = ct == use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).thousands_sep()\n  &amp;&amp; use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().length() != 0\n</code></pre>\n<blockquote>\n<p id=\"so_23374095_23374456_2\">where the values src and atoms are defined as if by:</p>\n</blockquote>\n<pre><code>static const char src[] = \"0123456789abcdefxABCDEFX+-\";\nchar_type atoms[sizeof(src)];\nuse_facet&lt;ctype&lt;charT&gt; &gt;(loc).widen(src, src + sizeof(src), atoms);\n</code></pre>\n<blockquote>\n<p id=\"so_23374095_23374456_3\">for this value of loc.</p>\n</blockquote>\n", "LastActivityDate": "2014-05-03T11:16:56.393"}, "23374095": {"CommentCount": "2", "AcceptedAnswerId": "23374456", "PostTypeId": "1", "LastEditorUserId": "19405", "CreationDate": "2014-04-29T19:56:32.500", "LastActivityDate": "2014-05-03T11:16:56.393", "LastEditDate": "2014-04-29T20:05:31.313", "ViewCount": "316", "FavoriteCount": "1", "Title": "Should a stringstream parse \"INFINITY\" as an infinite value?", "Id": "23374095", "Score": "3", "Body": "<p>Looking at the documentation for <code>strtod</code>:</p>\n<p>Linux:</p>\n<blockquote>\n<p id=\"so_23374095_23374095_0\">An infinity is either \"INF\" or \"INFINITY\", disregarding case.</p>\n</blockquote>\n<p>OS X:</p>\n<blockquote>\n<p id=\"so_23374095_23374095_1\">If the portion of the string following the optional plus\n  or minus sign begins with ``INFINITY'' ... it is\n  interpreted as an infinity</p>\n</blockquote>\n<p>I'm using a <code>stringstream</code> to convert a <code>string</code> to a <code>double</code>, and (wrongly) assumed that <code>strtod</code> was being used behind the scenes. Neither clang++ 3.4 nor g++ 4.8 converts \"INFINITY\" to <code>inf</code>. Only clang++ seems to convert \"INF\" to <code>inf</code>.</p>\n<p>Am I assuming too much about the operation of <code>stringstream</code>'s <code>operator&gt;&gt;</code>?  Or maybe I'm failing to check an important error condition? My test code is below (<code>g++ -std=c++11 -Wall -Wextra inf.cpp -o inf</code>).</p>\n<h2>Test Code</h2>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nvoid\ndoTest(\n    const std::string &amp;str)\n{\n    double val1 = std::strtod(str.c_str(), nullptr);\n    std::cout &lt;&lt; str &lt;&lt; \" - std::isinf from strtod: \" &lt;&lt; std::boolalpha &lt;&lt;\n        std::isinf(val1) &lt;&lt; '\\n';\n\n    std::stringstream sstream(str);\n    double val2;\n    sstream &gt;&gt; val2;\n    std::cout &lt;&lt; str &lt;&lt; \" - std::isinf from stringstream: \" &lt;&lt;\n        std::boolalpha &lt;&lt; std::isinf(val2) &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; val1 &lt;&lt; \" vs \" &lt;&lt; val2 &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; std::endl;\n}\n\nint\nmain()\n{\n    doTest(\"INFINITY\");\n    doTest(\"+INF\");\n\n    return (0);\n}\n</code></pre>\n<h3>Output</h3>\n<p>clang++ 3.4 (OS X 10.9.2):</p>\n<pre><code>INFINITY - std::isinf from strtod: true\nINFINITY - std::isinf from stringstream: false\ninf vs 0\n\n+INF - std::isinf from strtod: true\n+INF - std::isinf from stringstream: true\ninf vs inf\n</code></pre>\n<p>g++ 4.8:</p>\n<pre><code>INFINITY - std::isinf from strtod: true\nINFINITY - std::isinf from stringstream: false\ninf vs 0\n\n+INF - std::isinf from strtod: true\n+INF - std::isinf from stringstream: false\ninf vs 0\n</code></pre>\n", "Tags": "<c++><floating-point><infinity>", "OwnerUserId": "277718", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23374095_23374456_0": {"section_id": 2189, "quality": 0.9032258064516129, "length": 28}, "so_23374095_23374456_1": {"section_id": 6536, "quality": 0.9090909090909091, "length": 10}, "so_23374095_23374456_2": {"section_id": 6536, "quality": 1.0, "length": 5}}, "n3337": {"so_23374095_23374456_0": {"section_id": 2177, "quality": 0.9032258064516129, "length": 28}, "so_23374095_23374456_1": {"section_id": 6291, "quality": 0.9090909090909091, "length": 10}, "so_23374095_23374456_2": {"section_id": 6291, "quality": 1.0, "length": 5}}, "n4659": {"so_23374095_23374456_0": {"section_id": 2462, "quality": 0.9032258064516129, "length": 28}, "so_23374095_23374456_1": {"section_id": 8018, "quality": 0.8181818181818182, "length": 9}, "so_23374095_23374456_2": {"section_id": 8018, "quality": 1.0, "length": 5}}}});