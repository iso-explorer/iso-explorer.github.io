post_cb({"16661153": {"ParentId": "16616253", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-05-21T02:17:05.880", "OwnerUserId": "103167", "CommunityOwnedDate": "2013-05-21T02:17:05.880", "Id": "16661153", "Score": "1", "Body": "<p>(Note: This is more of a comment, I'm using an answer to allow formatting and longer content.  Marking CW because comments should not receive rep)</p>\n<p>I believe this is a correct algorithm that avoids O(NM) complexity, if input iterators are random-access:</p>\n<ol>\n<li>Determine the size of the range to insert (only possible for random-access iterators).</li>\n<li>Reserve additional space.</li>\n<li>Adjust size.</li>\n<li>Move-construct the new tail elements.</li>\n<li>Move-assign the other intervening elements toward the new end.</li>\n<li>Copy the source elements into the range left empty by the move.</li>\n</ol>\n", "LastActivityDate": "2013-05-21T02:17:05.880"}, "16616253": {"CommentCount": "6", "ViewCount": "827", "PostTypeId": "1", "LastEditorUserId": "420683", "CreationDate": "2013-05-17T19:08:39.120", "LastActivityDate": "2013-05-21T02:17:05.880", "Title": "Is vector::insert allowed to reserve only once and avoid further capacity checks?", "FavoriteCount": "2", "LastEditDate": "2013-05-21T01:03:27.190", "Id": "16616253", "Score": "14", "Body": "<p><code>vector::insert(dst_iterator, src_begin, src_end)</code> (insert a range) can be optimized for random-access iterators to reserve the required capacity <code>src_end - src_begin</code> first, then perform the copy.</p>\n<p>The <strong>main question</strong> I have: Does the Standard also allow <code>vector::insert</code> to avoid a capacity check for each copied element? (I.e. not using <code>push_back</code> or similar on every element to be inserted)</p>\n<p>I'll refer to avoiding this capacity check as \"optimization of <code>insert</code>\".</p>\n<hr>\n<p>What could go wrong: I can imagine an <strong>iterator with side effects when dereferenced</strong>:</p>\n<p>Note: the Standard guarantees the iterators passed to <code>insert</code> will be dereferenced exactly once (see end of question).</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt; typename T &gt;\nstruct evil_iterator : std::iterator &lt; std::random_access_iterator_tag, T &gt;\n{\n    using base = std::iterator &lt; std::random_access_iterator_tag, T &gt;;\n\n    std::vector&lt;T&gt;* evil_feedback;\n    typename std::vector&lt;T&gt;::iterator innocent_iterator;\n\n    evil_iterator( std::vector&lt;T&gt;* c,\n                   typename std::vector&lt;T&gt;::iterator i )\n        : evil_feedback{c}\n        , innocent_iterator{i}\n    {}\n\n    void do_evil()\n    {\n        std::cout &lt;&lt; \"trying to do evil; \";\n        std::cout &lt;&lt; \"cap: \" &lt;&lt; evil_feedback-&gt;capacity() &lt;&lt; \", \";\n        std::cout &lt;&lt; \"size: \" &lt;&lt; evil_feedback-&gt;size() &lt;&lt; \", \";\n\n        // better not invalidate the iterators of `*evil_feedback`\n        // passed to the `insert` call (see example below)\n        if( evil_feedback-&gt;capacity() &gt; evil_feedback-&gt;size() )\n        {\n            evil_feedback-&gt;push_back( T{} );\n            // capacity() might be == size() now\n            std::cout &lt;&lt; \"successful &gt;:]\" &lt;&lt; std::endl;\n        }else\n        {\n            std::cout &lt;&lt; \"failed &gt;:[\" &lt;&lt; std::endl;\n        }\n    }\n\n    T&amp; operator*()\n    {\n        do_evil();  // &lt;----------------------------------------\n        return *innocent_iterator;\n    }\n\n\n    // non-evil iterator member functions-----------------------\n\n    evil_iterator&amp; operator++()\n    {\n        ++innocent_iterator;\n        return *this;\n    }\n    evil_iterator&amp; operator++(int)\n    {\n        evil_iterator temp(*this);\n        ++(*this);\n        return temp;\n    }\n\n\n    evil_iterator&amp; operator+=(typename base::difference_type p)\n    {\n        innocent_iterator += p;\n        return *this;\n    }\n    evil_iterator&amp; operator-=(typename base::difference_type p)\n    {\n        innocent_iterator -= p;\n        return *this;\n    }\n\n    evil_iterator&amp; operator=(evil_iterator const&amp; other)\n    {\n        evil_feedback = other.evil_feedback;\n        innocent_iterator = other.innocent_iterator;\n        return *this;\n    }\n\n    evil_iterator operator+(typename base::difference_type p)\n    {\n        evil_iterator temp(*this);\n        temp += p;\n        return temp;\n    }\n    evil_iterator operator-(typename base::difference_type p)\n    {\n        evil_iterator temp(*this);\n        temp -= p;\n        return temp;\n    }\n\n    typename base::difference_type operator-(evil_iterator const&amp; p)\n    {\n        return this-&gt;innocent_iterator - p.innocent_iterator;\n    }\n\n    bool operator!=(evil_iterator const&amp; other) const\n    {  return innocent_iterator != other.innocent_iterator;  }\n};\n</code></pre>\n<p>Example:</p>\n<pre><code>int main()\n{\n    std::vector&lt;int&gt; src = {3, 4, 5, 6};\n    std::vector&lt;int&gt; dst = {1, 2};\n\n    evil_iterator&lt;int&gt; beg = {&amp;dst, src.begin()};\n    evil_iterator&lt;int&gt; end = {&amp;dst, src.end()};\n\n    // explicit call to reserve, see below\n    dst.reserve( dst.size() + src.size() );\n    // using dst.end()-1, which stays valid during `push_back`,\n    //   thanks to Ben Voigt pointing this out\n    dst.insert(dst.end()-1, beg, end);  // &lt;--------------- doing evil?\n\n    std::copy(dst.begin(), dst.end(), \n              std::ostream_iterator&lt;int&gt;{std::cout, \", \"});\n}\n</code></pre>\n<hr>\n<h3>Questions:</h3>\n<ol>\n<li>Can <code>vector::insert</code> be optimized to avoid a capacity check for each inserted element?</li>\n<li>Is <code>evil_iterator</code> still a valid iterator?</li>\n<li>If so, is <code>evil_iterator</code> <em>evil</em>, i.e. can it result in UB / non-complying behaviour if <code>insert</code> is optimized as described above?</li>\n</ol>\n<p><strike>Maybe my <code>do_evil</code> is not evil enough.. have no problems on clang++ 3.2 (using libstdc++):</strike></p>\n<p>Edit 2: Added the call to <code>reserve</code>. Now, I'm doing evil :)</p>\n<blockquote>\n<p id=\"so_16616253_16616253_0\">trying to do evil; cap: 6, size: 2, successful &gt;:]<br/>\n  trying to do evil; cap: 6, size: 3, successful &gt;:]<br/>\n  trying to do evil; cap: 6, size: 4, successful &gt;:]<br/>\n  trying to do evil; cap: 6, size: 9, failed &gt;:[<br/>\n  1, 3, 4, 5, 6, 0, 0, 135097, 2, </p>\n</blockquote>\n<p>Edit: Why I think the optimization could break this:</p>\n<ol>\n<li>Consider <code>dst.size() == dst.capacity() == 2</code> at the beginning.</li>\n<li>The call to <code>insert</code> requires a new capacity of 6.</li>\n<li>The optimization enlarges the capacity to exactly 6, then begins to insert the elements by copying from the <code>src</code> iterators (<code>beg</code>, <code>end</code>).</li>\n<li>This copying is done within a loop where no capacity checks occur. (That is the optimization.)</li>\n<li>During the process of copying, further elements are added to the vector (w/o invalidating the iterators), in <code>do_evil</code>. The capacity now is not sufficient any more to hold the rest of the elements to be copied.</li>\n</ol>\n<p>Maybe you had to use <code>reserve</code> in the example explicitly to force updating the observable <code>capacity</code> before using <code>do_evil</code>. Currently, <code>insert</code> could reserve some capacity but change what <code>capacity</code> returns (i.e. observable capacity) only after the copying is done.</p>\n<hr>\n<p>What I've found in the Standard so far seems to allow the optimization of <code>insert</code>:</p>\n<p>[sequence.reqmts]/3</p>\n<blockquote>\n<p id=\"so_16616253_16616253_1\"><code>a.insert(p,i,j)</code> [...]</p>\n<p id=\"so_16616253_16616253_2\">Requires: T shall be EmplaceConstructible into X from *i.</p>\n<p id=\"so_16616253_16616253_3\">For vector, if the iterator does not meet the forward iterator requirements (24.2.5), T shall also be MoveInsertable into X and MoveAssignable. Each iterator in the range [i,j) shall be dereferenced exactly once.</p>\n<p id=\"so_16616253_16616253_4\">pre: i and j are not iterators into a. Inserts copies of elements in [i, j) before p</p>\n</blockquote>\n<p>[vector.modifiers] on <code>insert</code></p>\n<blockquote>\n<p id=\"so_16616253_16616253_5\">1 Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are no effects. If an exception is thrown by the move constructor of a non-CopyInsertable T, the effects are unspecified.</p>\n<p id=\"so_16616253_16616253_6\">2 Complexity: The complexity is linear in the number of elements inserted plus the distance to the end of the vector.</p>\n</blockquote>\n</hr></hr></hr>", "Tags": "<c++><vector><iterator><language-lawyer>", "OwnerUserId": "420683", "AnswerCount": "3"}, "16659808": {"ParentId": "16616253", "CommentCount": "5", "Body": "<p>Here are my views:</p>\n<ol>\n<li>Yes; de-referencing can have side effects on your vector (case in point) which could lead to undefined behavior in some cases, but this should not be the case with standard conforming iterators.</li>\n<li>No; Iterator's are intended as a generalization of pointers - since pointers de-referencing may not have side effects (cannot find reference) the same should be the case for iterators [iterator.requirements.general]. Given this interpretation \"optimization of insert\" (1) is valid.</li>\n</ol>\n", "OwnerUserId": "1598080", "PostTypeId": "2", "Id": "16659808", "Score": "0", "CreationDate": "2013-05-20T23:20:54.680", "LastActivityDate": "2013-05-20T23:20:54.680"}, "16659850": {"ParentId": "16616253", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Looking again, I think this rule (section 17.6.4.9) is a clearer prohibition on what you tried to do:</p>\n<blockquote>\n<p id=\"so_16616253_16659850_0\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless explicitly stated otherwise.</p>\n<ul>\n<li>If an argument to a function has an invalid value (such as a value outside the domain of the function or a pointer invalid for its intended use), the behavior is undefined.</li>\n</ul>\n</blockquote>\n<p>I think this rule applies during the entire duration of the function call, and not only at function entry.</p>\n<p>Furthermore, <code>push_back()</code> guarantees that (23.3.7.5):</p>\n<blockquote>\n<p id=\"so_16616253_16659850_1\">If no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>Your <code>position</code> passed to <code>insert</code>, which is <code>dst.end()</code> as evaluated before the <code>insert</code> call, is not <em>before the insertion point</em> of the first <code>evil_feedback-&gt;push_back()</code> call, so it does not remain valid (the fact that you carefully avoided reallocation here does not save you, as you only met half the condition).  Which means the argument you passed to <code>std::vector::insert</code>, a function defined in the C++ Standard Library, is invalid during the duration of that call, landing you squarely in the realm of undefined behavior.</p>\n<hr>\n<p>Previous answer:</p>\n<p>I think you violated this precondition that you quoted:</p>\n<blockquote>\n<p id=\"so_16616253_16659850_2\">pre: <code>i</code> and <code>j</code> are not iterators into <code>a</code>.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2013-05-21T00:40:39.550", "Id": "16659850", "Score": "3", "CreationDate": "2013-05-20T23:26:54.860", "LastActivityDate": "2013-05-21T00:40:39.550"}, "bq_ids": {"n4140": {"so_16616253_16616253_5": {"section_id": 986, "quality": 0.9767441860465116, "length": 42}, "so_16616253_16616253_4": {"section_id": 723, "quality": 1.0, "length": 7}, "so_16616253_16659850_1": {"section_id": 986, "quality": 1.0, "length": 10}, "so_16616253_16616253_3": {"section_id": 723, "quality": 0.8947368421052632, "length": 17}, "so_16616253_16616253_6": {"section_id": 987, "quality": 0.8181818181818182, "length": 9}, "so_16616253_16659850_0": {"section_id": 6325, "quality": 1.0, "length": 11}}, "n3337": {"so_16616253_16616253_5": {"section_id": 971, "quality": 0.9767441860465116, "length": 42}, "so_16616253_16616253_4": {"section_id": 712, "quality": 1.0, "length": 7}, "so_16616253_16659850_1": {"section_id": 971, "quality": 1.0, "length": 10}, "so_16616253_16616253_3": {"section_id": 712, "quality": 0.8947368421052632, "length": 17}, "so_16616253_16616253_6": {"section_id": 972, "quality": 0.8181818181818182, "length": 9}, "so_16616253_16659850_0": {"section_id": 6082, "quality": 1.0, "length": 11}}, "n4659": {"so_16616253_16616253_5": {"section_id": 1049, "quality": 0.9767441860465116, "length": 42}, "so_16616253_16659850_0": {"section_id": 7835, "quality": 1.0, "length": 11}, "so_16616253_16659850_1": {"section_id": 1049, "quality": 1.0, "length": 10}, "so_16616253_16616253_3": {"section_id": 754, "quality": 0.8947368421052632, "length": 17}, "so_16616253_16616253_6": {"section_id": 1050, "quality": 0.8181818181818182, "length": 9}, "so_16616253_16616253_4": {"section_id": 754, "quality": 0.8571428571428571, "length": 6}}}});