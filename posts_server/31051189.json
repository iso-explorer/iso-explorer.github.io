post_cb({"bq_ids": {"n4140": {"so_31051189_31051322_11": {"length": 21, "quality": 1.0, "section_id": 328}, "so_31051189_31051322_13": {"length": 21, "quality": 1.0, "section_id": 328}, "so_31051189_31051322_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 325}, "so_31051189_31051322_8": {"length": 14, "quality": 0.8235294117647058, "section_id": 328}, "so_31051189_31051322_6": {"length": 21, "quality": 1.0, "section_id": 328}, "so_31051189_31051322_5": {"length": 12, "quality": 1.0, "section_id": 327}, "so_31051189_31051322_0": {"length": 50, "quality": 0.9433962264150944, "section_id": 321}, "so_31051189_31051322_3": {"length": 11, "quality": 1.0, "section_id": 323}, "so_31051189_31051322_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 322}, "so_31051189_31051322_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}}, "n3337": {"so_31051189_31051322_3": {"length": 11, "quality": 1.0, "section_id": 313}, "so_31051189_31051322_13": {"length": 21, "quality": 1.0, "section_id": 318}, "so_31051189_31051322_8": {"length": 14, "quality": 0.8235294117647058, "section_id": 318}, "so_31051189_31051322_6": {"length": 21, "quality": 1.0, "section_id": 318}, "so_31051189_31051322_11": {"length": 21, "quality": 1.0, "section_id": 318}, "so_31051189_31051322_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 315}, "so_31051189_31051322_0": {"length": 50, "quality": 0.9433962264150944, "section_id": 311}, "so_31051189_31051322_5": {"length": 12, "quality": 1.0, "section_id": 317}, "so_31051189_31051322_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_31051189_31051322_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}}, "n4659": {"so_31051189_31051322_8": {"length": 17, "quality": 1.0, "section_id": 336}, "so_31051189_31051322_3": {"length": 11, "quality": 1.0, "section_id": 331}, "so_31051189_31051322_13": {"length": 21, "quality": 1.0, "section_id": 336}, "so_31051189_31051322_11": {"length": 21, "quality": 1.0, "section_id": 336}, "so_31051189_31051322_6": {"length": 21, "quality": 1.0, "section_id": 336}, "so_31051189_31051322_0": {"length": 50, "quality": 0.9433962264150944, "section_id": 329}, "so_31051189_31051322_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 333}, "so_31051189_31051322_9": {"length": 20, "quality": 0.9090909090909091, "section_id": 337}, "so_31051189_31051322_5": {"length": 12, "quality": 1.0, "section_id": 335}, "so_31051189_31051322_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 330}, "so_31051189_31051322_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}}}, "31051189": {"ViewCount": "778", "Body": "<p>Consider this simple pair of function templates. </p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T&amp; ) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n\ntemplate &lt;typename C&gt;\nvoid foo(const C&amp; ) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n</code></pre>\n<p>If we call <code>foo</code> with a non-const argument:</p>\n<pre><code>int i = 4;\nfoo(i);\n</code></pre>\n<p>The <code>T&amp;</code> overload is preferred based on [over.ics.rank]/3.2.6, since the deduced reference <code>int&amp;</code> is less <em>cv</em>-qualified than the deduced reference <code>const int&amp;</code>.</p>\n<p>However, if we call <code>foo</code> with a const argument:</p>\n<pre><code>const int ci = 42;\nfoo(ci);\n</code></pre>\n<p>The <code>const C&amp;</code> overload is preferred because it is \"more specialized\" based on [over.match.best]/1.7. But what are the rules to determine this? My understanding was that you synthesize a type for <code>C</code> (call it, <code>M</code>) and try to perform deduction on <code>foo(M)</code> - but that would succeed (with <code>T == M</code>). It's only an rvalue that would cause that deduction to fail - but how does the compiler  know that it has to choose an rvalue in the synthesis step?</p>\n", "AcceptedAnswerId": "31051322", "Title": "Overload resolution and partial template ordering", "CreationDate": "2015-06-25T13:03:04.067", "Id": "31051189", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-06-25T13:30:04.697", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-27T18:36:37.867", "Score": "19", "OwnerUserId": "2069064", "Tags": "<c++><templates><language-lawyer><overload-resolution>", "AnswerCount": "1"}, "31051322": {"Id": "31051322", "PostTypeId": "2", "Body": "<p>Disclaimer: The types we consider are always types of parameters. The types/value categories/etc. of the actual arguments passed are solely considered in overload resolution, never in partial ordering.</p>\n<p>Partial ordering considers both overloads in two \"turns\", in which one template is always the <strong>parameter template</strong>, and the other template is the <strong>argument template</strong>. [temp.deduct.partial]/2:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_0\">For each of the templates involved there is the original function type\n  and the transformed function type. [..] The deduction\n  process uses the transformed type as the argument  template and the\n  original type of the other template as the parameter template. This\n  process is done twice for each type involved in the partial ordering\n  comparison: once using the transformed template-1 as the argument\n  template and template-2 as the parameter template and again using the\n  transformed template-2 as the argument template and template-1 as the\n  parameter template.</p>\n</blockquote>\n<p>You should be familiar with the way transformed \"templates\" are generated. This is specified in \u00a714.5.6.2/3.</p>\n<blockquote>\n<p id=\"so_31051189_31051322_1\">To produce the transformed template, for each type, non-type, or\n  template template parameter (including template parameter packs\n  (14.5.3) thereof) synthesize a unique type, value, or class template\n  respectively and substitute it for each occurrence of that parameter\n  in the function type of the template.</p>\n</blockquote>\n<p>So our (transformed) argument templates are </p>\n<pre><code>void foo( Unique1&amp; );\n\nvoid foo( Unique2 const&amp; );\n</code></pre>\n<p>[temp.deduct.partial]/3 &amp; /4:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_2\">The types used to determine the ordering depend on the context in\n  which the partial ordering is done:</p>\n<ul>\n<li>In the context of a\n  function call, the types used are those function parameter types for\n  which the function call has arguments. [..]</li>\n</ul>\n<p id=\"so_31051189_31051322_3\">Each type nominated above from the parameter template and the corresponding type from the argument\n  template are used as the types of <code>P</code> and <code>A</code>.</p>\n</blockquote>\n<p>Thus we have two turns, and in both we have a type <code>P</code> and a type <code>A</code>:</p>\n<p>Turn 1:<br>\n\u00a0\u00a0\u00a0\u00a0<code>P1</code>:\u00a0\u00a0 <code>T const&amp;</code><br>\n\u00a0\u00a0\u00a0\u00a0<code>A1</code>:\u00a0\u00a0 <code>Unique1&amp;</code> </br></br></p>\n<p>Turn 2:<br>\n\u00a0\u00a0\u00a0\u00a0<code>P2</code>:\u00a0\u00a0 <code>T&amp;</code><br>\n\u00a0\u00a0\u00a0\u00a0<code>A2</code>:\u00a0\u00a0 <code>Unique2 const&amp;</code></br></br></p>\n<p>But before the fun begins, some transformations are performed on these types as well - I abbreviated [temp.deduct.partial]/5 &amp; /7: </p>\n<ul>\n<li>If <code>P</code> or <code>A</code> are references, then they're replaced by the type they refer to. </li>\n<li>Any top-level cv-qualifiers are removed.</li>\n</ul>\n<p>Note that the removed cv-qualifiers are \"remembered\" for later. [temp.deduct.partial]/6:  </p>\n<blockquote>\n<p id=\"so_31051189_31051322_4\">If both <code>P</code> and <code>A</code> were reference types (before being replaced with the\n  type referred to above), determine which of the two types (if any) is\n  more cv-qualified than the other; otherwise the types are considered\n  to be  equally cv-qualified for partial ordering purposes. The result\n  of this determination will be used below.</p>\n</blockquote>\n<p>Thus we're left with </p>\n<p>Turn 1:<br>\n\u00a0\u00a0\u00a0\u00a0<code>P1</code>:\u00a0\u00a0 <code>T</code><br>\n\u00a0\u00a0\u00a0\u00a0<code>A1</code>:\u00a0\u00a0 <code>Unique1</code> </br></br></p>\n<p>Turn 2:<br>\n\u00a0\u00a0\u00a0\u00a0<code>P2</code>:\u00a0\u00a0 <code>T</code><br>\n\u00a0\u00a0\u00a0\u00a0<code>A2</code>:\u00a0\u00a0 <code>Unique2</code></br></br></p>\n<p>Now we perform deduction - which clearly succeeds in both turns by setting <code>T=Unique[1/2]</code>. From [temp.deduct.partial]/8:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_5\">If deduction succeeds for a given type, the type from the argument template is considered\n  to be at least as specialized as the type from the parameter template.</p>\n</blockquote>\n<p>That gives us both that <code>Unique1&amp;</code> is at least as specialized as <code>T const&amp;</code>, and that <code>Unique2 const&amp;</code> is at least as specialized as <code>T&amp;</code>.</p>\n<hr>\n<p>However,  this is where [temp.deduct.partial]/(9.2) steps in:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_6\">If, for a given type, deduction succeeds in both directions (i.e., the\n  types are identical after the transformations above) and both <code>P</code> and\n  <code>A</code> were reference types (before being replaced with the type referred\n  to above):</p>\n<ul>\n<li><p id=\"so_31051189_31051322_7\">[..]; otherwise, </p></li>\n<li><p id=\"so_31051189_31051322_8\"><strong>if the type from the argument template is more cv-qualified than the type from the parameter template\n       (as described above), the parameter type is not considered to be at least as specialized as the argument\n      type.</strong></p></li>\n</ul>\n</blockquote>\n<p>The remembered cv-qualifiers come into play. <code>A2</code> is <em>\"more cv-qualified (as described above)\"</em> than <code>P2</code>, hence <strong><code>P2</code> is not considered to be at least as specialized as <code>A2</code></strong>.</p>\n<p>Finally, [temp.deduct.partial]/10:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_9\">Function template <code>F</code> is at least as specialized as function template <code>G</code>\n  if, for each pair of types used to determine the ordering, the type\n  from <code>F</code> is at least as specialized as the type from <code>G</code>.<br>\n<code>F</code> is more specialized\n  than <code>G</code> if <code>F</code> is at least as specialized as <code>G</code> and <code>G</code> is not at least as specialized as <code>F</code>.</br></p>\n</blockquote>\n<p>implies that since the type <code>T&amp;</code> is <strong>not at least as specialized</strong> as <code>Unique2 const&amp;</code> and we already established that <code>T const&amp;</code> is at least as specialized as <code>Unique1&amp;</code>, the <code>T const&amp;</code>-overload is more specialized than the <code>T&amp;</code>-overload.</p>\n<hr>\n<p>The aforementioned rule in paragraph 9 is currently subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2088\"><strong>CWG #2088</strong></a> created four months ago by R. Smith:</p>\n<blockquote>\n<p id=\"so_31051189_31051322_10\">The late tiebreakers for lvalue-vs-rvalue references and\n  cv-qualification in 14.8.2.4 [temp.deduct.partial] paragraph 9 are\n  applied</p>\n<blockquote>\n<p id=\"so_31051189_31051322_13\">If, for a given type, deduction succeeds in both directions (i.e., the\n    types are identical after the transformations above) and both <code>P</code> and <code>A</code>\n    were reference types (before being replaced with the type referred to\n    above):</p>\n</blockquote>\n<p id=\"so_31051189_31051322_12\">However, this is based on a false assumption. [..] We need to decide whether the rule is \u201cdeduction succeeds in both directions\u201d or \u201cthe types are identical.\u201d The latter seems more reasonable.</p>\n</blockquote>\n<p>This will not alter the result established though, since the types we got are indeed identical. </p>\n</hr></hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2015-07-27T18:36:37.867", "Score": "20", "CreationDate": "2015-06-25T13:08:58.690", "ParentId": "31051189", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-07-27T18:36:37.867"}});