post_cb({"19832248": {"Id": "19832248", "PostTypeId": "2", "Body": "<p>The short answer, as you seem to have suspected, is no. Which thread (or threads) notify_one is going to rouse is not necessarily guaranteed.</p>\n<p>That said, I'm not sure what to make of your example code. Specifically, passing a mutex to notify_one doesn't make sense to me (I am unaware of any condition variable implementations on any platform that signal/broadcast that way). I don't know your use case--perhaps you must have a lot of thread local data that prevents arranging your application state in such a way that any thread can pick up the necessary data to do the next task? My first reaction to that would be to refactor the code to care less about which particular OS thread does which work and focus more on the ordering of the work itself.</p>\n", "LastActivityDate": "2013-11-07T09:30:20.297", "CommentCount": "1", "CreationDate": "2013-11-07T09:30:20.297", "ParentId": "19829754", "Score": "2", "OwnerUserId": "2594110"}, "19832374": {"Id": "19832374", "PostTypeId": "2", "Body": "<p>No such guarantess are given by the standard, <code>notify_one</code> may wake any thread that is currently waiting (\u00a730.5.1):</p>\n<blockquote>\n<p id=\"so_19829754_19832374_0\"><code>void notify_one() noexcept;</code>\n  Effects: If any threads are blocked waiting for <code>*this</code>, unblocks one of those theads.</p>\n</blockquote>\n<p>The only way to ensure that a specific thread reacts to the event is to wake <em>all</em> threads and then have some additional synchronization mechanism that sends all but the correct thread back to sleep.</p>\n<p>This is a fundamental limitation due to the requirements that the platform has to fulfill: Usually condition variables are implemented in a way that the waiting threads are put into a suspended state and will not get scheduled by the system again until a notify occurs. A scheduler implementation is not required to provide the functionality for selecting a specific thread for waking up (and many actually don't).</p>\n<p>So this part of the logic inevitably has to be handled by user code, which in turn means you have to wake up all threads to make it work, because this is the only way to ensure that the correct thread will get woken at all.</p>\n", "LastEditorUserId": "577603", "LastActivityDate": "2013-11-07T09:47:42.860", "Score": "3", "CreationDate": "2013-11-07T09:36:11.117", "ParentId": "19829754", "CommentCount": "1", "OwnerUserId": "577603", "LastEditDate": "2013-11-07T09:47:42.860"}, "19829754": {"ViewCount": "659", "Body": "<p>I need to know if there is a way to \"queue up\" threads that wait on a condition variable so that they are awoken in the correct order...without writing a bunch of queueing code, that is.</p>\n<p>In most systems, the following reversal of the producer/consumer model (with blocking on full mailbox) may not ensure ordering:</p>\n<pre><code>unique_lock lock1(mutex), lock2(mutex)\nConditionVariable cv\n</code></pre>\n<p>Code Block A: (called by multiple threads)</p>\n<pre><code>lock(lock1)\ntimestampOnEntry = now()\ncv.wait(lock1) // Don't worry about spurious notifies, out of scope.\nsomethingRequiringMonotonicOrderOfTimestamps(timestampOnEntry)\nunlock(lock1)\n</code></pre>\n<p>Code Block B: (called by a single thread, typically within a loop)</p>\n<pre><code>lock(lock2)\nsomethingVeryVerySlow()\n(1) unlock(lock2)   // the ordering here is not a mistake\n(2) cv.notify_one(lock2) // prevents needless reblocking in code block A\n</code></pre>\n<p>Note that lines (1) and (2) in the given order. This prevents an unnecessary second block on guard in <em>code block A</em> should the notified thread wake up before guard is unlocked by the thread in <em>code block B</em>.</p>\n<p>The question is that if multiple threads are \"blocked\" on <em>wait</em>, I need to know if \n*notify_one* will wake them up in the order in which blocked. Probably not (as in Java). If not by default, if there is a way to specify that.</p>\n<p>This could of course be done with a bunch of queuing code, but I'd prefer to use a pre-canned BOOST methodology, regardless of how complicated the contents of the can are. Of course, should I convert *cv.notify_one(guard)*  into *cv.notify_all(guard)*, I would be required to do the queueing code, regardless.</p>\n", "AcceptedAnswerId": "19832374", "Title": "C++/BOOST: Does condition_variable::wait( ) / notify( ) ensure ordering of threads waiting?", "CreationDate": "2013-11-07T06:56:21.607", "Id": "19829754", "CommentCount": "0", "LastEditDate": "2013-11-07T07:34:50.790", "PostTypeId": "1", "LastEditorUserId": "1729703", "LastActivityDate": "2013-11-07T09:47:42.860", "Score": "1", "OwnerUserId": "1729703", "Tags": "<c++><multithreading><boost>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19829754_19832374_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 2993}}, "n3337": {"so_19829754_19832374_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 2863}}, "n4659": {"so_19829754_19832374_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 3752}}}});