post_cb({"bq_ids": {"n4140": {"so_44295575_44314006_0": {"length": 19, "quality": 0.7037037037037037, "section_id": 7114}}, "n3337": {"so_44295575_44314006_0": {"length": 19, "quality": 0.7037037037037037, "section_id": 6858}}, "n4659": {"so_44295575_44314006_0": {"length": 19, "quality": 0.7037037037037037, "section_id": 8615}}}, "44314006": {"Id": "44314006", "PostTypeId": "2", "Body": "<p>Expanding on dasblinkenlight's <a href=\"https://stackoverflow.com/a/44295729/5689220\">correct answer</a>--the C++03 standard explicitly outlaws his and my code in <code>[class.qual]</code>:</p>\n<blockquote>\n<p id=\"so_44295575_44314006_0\">If the <em>nested-name-specifier</em> nominates a class C, and the name\n  specified after the <em>nested-name-specifier</em>, when looked up in C, is the\n  injected-class-name of C (clause 9), the name is instead considered to\n  name the constructor of class C. Such a constructor name shall be used\n  only in the <em>declarator-id</em> of a constructor definition that appears\n  outside of the class definition. [<em>Example:</em></p>\n<pre><code>struct A { A(); };\nstruct B: public A { B(); };\n\nA::A() { }\nB::B() { }\n\nB::A ba; // object of type A\nA::A a;  // error, A::A is not a type name\n</code></pre>\n<p id=\"so_44295575_44314006_1\"><em>\u2014end example</em>]</p>\n</blockquote>\n", "LastActivityDate": "2017-06-01T17:45:28.637", "CommentCount": "0", "CreationDate": "2017-06-01T17:45:28.637", "ParentId": "44295575", "Score": "1", "OwnerUserId": "5689220"}, "44295575": {"ViewCount": "230", "Body": "<p>I have the following simple C++ code:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nclass A\n{\npublic:\n    A(int y) : x(y) {}\n    A&amp; operator=(const A&amp; rhs);\n    int x;\n};\n\nA::A&amp; A::operator=(const A&amp; rhs) { this-&gt;x = rhs.x; return *this; }\n\nint main(int, char**)\n{\n    A a1(5);\n    A a2(4);\n\n    printf(\"a2.x == %d\\n\", a2.x);\n\n    a2 = a1;\n\n    printf(\"a2.x == %d\\n\", a2.x);\n\n    return 0;\n}\n</code></pre>\n<p>Line 11, where the definition of <code>A</code>'s <code>operator=()</code> function is at, is malformed...or, at least, I believe so. As expected, G++ 4.7.4, as well as every newer version of GCC that I've tried, throws the following error:</p>\n<pre><code>main.cpp:11:1: error: \u2018A::A\u2019 names the constructor, not the type\n</code></pre>\n<p>Oddly, though, G++ 4.4.7 compiles this program successfully, with no warnings, and even prints 4 and 5 as would be expected if line 11 were written correctly (i.e. with just <code>A&amp;</code> instead of <code>A::A&amp;</code>).</p>\n<p>Can someone help me decipher what exactly is going on there with G++ 4.4.7? Is this just a bug in that release (albeit an extremely old one, and shame on us for still using it)? I'd think the standard would explicitly state how the <code>operator=()</code> function must be declared and defined.</p>\n", "AcceptedAnswerId": "44295729", "Title": "\"names the constructor, not the type\" in G++ 4.4.7", "CreationDate": "2017-05-31T22:22:02.283", "Id": "44295575", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-06-01T17:45:28.637", "Score": "6", "OwnerUserId": "5689220", "Tags": "<c++><gcc>", "AnswerCount": "2"}, "44295729": {"Id": "44295729", "PostTypeId": "2", "Body": "<p>There was a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=11764\" rel=\"noreferrer\">related bug in g++</a>. It was fixed in version 4.5.0, so 4.4.7 still has it.</p>\n<p>Here is the bug description:</p>\n<blockquote>\n<p id=\"so_44295575_44295729_0\">cc1plus does not implement the class name injection correctly.\n  In particular the snipped below should be rejected on the basis that\n  A::A does not name a type (it designates a constructor)</p>\n<pre><code>struct A { };\n\nint main()\n{\n    A::A a;       // should be an ERROR\n}\n</code></pre>\n</blockquote>\n<p>Although the symptoms of this bug are not identical to what you describe, in both cases the compiler treats <code>A::A</code> as a type name, when it actually names a constructor. I am pretty certain that the two behaviors have the same root cause, which is poor implementation of scope resolution prior to version 4.5.0.</p>\n", "LastActivityDate": "2017-05-31T22:36:25.680", "CommentCount": "0", "CreationDate": "2017-05-31T22:36:25.680", "ParentId": "44295575", "Score": "5", "OwnerUserId": "335858"}});