post_cb({"45341763": {"ViewCount": "176", "Body": "<p>I'm curious whether people in production environments actually manage to compile with strict aliasing? It seems like avoiding pointer casting is a bit of a pipe dream for large code bases. I know that you can use the char* cast to get around the aliasing issues, but in every large code base I've ever worked in there was always at least one pointer cast that was pretty unavoidable.</p>\n<p><strong>EDIT</strong>: Here is an example to give more context to the question: Imagine a Vector3 class which internally is just 3 floats and provides mathematically sound vector operations like +,-, dot product, etc... In this case you may want to perform operations that are <em>not</em> vector operations. For example you may wish to do component wise multiplication. One approach would be to implement the operator* to do this, but this can lead to bugs (for example the user meant to multiply a vector by a scalar not another vector) which the compiler would not catch.</p>\n<p>One approach is to add a Float3 class that permits pairwise operations. In this case you would likely use casting in order to temporarily treat the 3 floats as a Float3 in order to do something you would not expect a Vector3 to do. How would you recommend handling this case? This would surely lead to aliasing problems if the compiler chooses to reorder operations on the same 3 floats based on if it's a Vector3 or a Float3. I have seen similar cases where a Vector4 is temporarily treated as a Vector3 for one reason or another.</p>\n<p>Are there any elegant strategies for handling this? Using an anonymous union seems like it might be overly verbose.</p>\n", "Title": "Strategies for type punning and strict aliasing", "CreationDate": "2017-07-27T05:00:14.890", "LastActivityDate": "2017-07-28T03:26:24.180", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-28T03:26:24.180", "LastEditorUserId": "1516456", "Id": "45341763", "ClosedDate": "2017-07-27T09:01:40.963", "Score": "0", "OwnerUserId": "1516456", "Tags": "<c++><c><strict-aliasing>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_45341763_45344013_2": {"length": 32, "quality": 0.5925925925925926, "section_id": 5878}}, "n3337": {"so_45341763_45344013_2": {"length": 32, "quality": 0.5925925925925926, "section_id": 5649}}}, "45344013": {"PostTypeId": "2", "Body": "<p>This answer focuses on C, not on C++. Similar reasoning is probably possible with C++.</p>\n<hr>\n<p>First of all: Of course people compile code <em>conforming to the standard</em>. It isn't hard to do this even in huge codebases. What can be very hard is when you <strong>already</strong> have a large codebase that relies on some <em>undefined behavior</em> and try to make this conforming afterwards.</p>\n<blockquote>\n<p id=\"so_45341763_45344013_0\">It seems like avoiding pointer casting is a bit of a pipe dream for large code bases.</p>\n</blockquote>\n<p>Not every pointer cast violates strict aliasing. Avoiding pointer casts is good practice because you have to look very closely at any use of them. In your \"large codebase\", you <strong>will</strong> have pointer casts and you have to make sure they are legal.</p>\n<blockquote>\n<p id=\"so_45341763_45344013_1\">I know that you can use the <code>char *</code> cast to get around the aliasing issues</p>\n</blockquote>\n<p>Not in general! It's always correct to access any object through a pointer of type <code>char *</code>, but the opposite doesn't hold, so you can't just replace an arbitrary pointer cast by first casting to <code>char *</code> and then casting to whatever you want.</p>\n<hr>\n<p><em>Type punning</em> is almost always ill-adviced. There are two exceptions I'm aware of:</p>\n<ol>\n<li>Accessing the bytes of an object representation, e.g. for serializing, copying, or converting endianness. This is covered by the rule that lets you access the object through <code>char *</code>.</li>\n<li><em>struct inheritance</em>, e.g. you have some base struct for similarly shaped objects and concrete structs specializing for different purposes.</li>\n</ol>\n<p>For this second use case, you will see a lot of non-conforming code in the wild. A famous example is the BSD sockets API, using these structs (among others):</p>\n<pre><code>struct sockaddr\n{\n    unsigned short sa_family;\n    char sa_data[14];\n};\n\nstruct sockaddr_in\n{\n    short sin_family;\n    unsigned short sin_port;\n    struct in_addr sin_addr;\n    char sin_zero[8];\n};\n</code></pre>\n<p>Think about a function returning you a <code>struct sockaddr *</code>, but the object you get is in reality a <code>struct sockaddr_in</code>, so you have to do a cast here that's not correct. It won't cause problems in practice when handled correctly, because the object was originally created as a <code>struct sockaddr_in</code> and just passed to you using the wrong type -- all you have  to do is cast it and forget the pointer to the wrong type. But to find out it actually <strong>is</strong> a <code>struct sockaddr_in</code>, you would have to examine the <code>sa_family</code> member, and this access is strictly speaking <em>undefined behavior</em>.</p>\n<p>It's unfortunate, because there's a compliant way to achieve a similar thing (of course not with the same function signatures as are present in the API right now, this is only a hypothetical example):</p>\n<pre><code>struct my_sockaddr\n{\n    unsigned short family;\n};\n\nstruct my_sockaddr_in\n{\n    struct my_sockaddr sockaddr;\n    unsigned short port;\n    struct in_addr addr;\n};\n</code></pre>\n<p>Now, if you have a function returning <code>struct my_sockaddr *</code>, it can point to a <code>struct my_sockaddr_in</code> and still not violate any rules, because the <code>struct my_sockaddr</code> is the first member (which must be at offset 0 of the struct). After examining the <code>sa_family</code> member and therefore being sure it is a <code>struct my_sockaddr_in</code>, you can do a cast safely.</p>\n<p>If you think it's not so nice that given</p>\n<pre><code>struct my_sockaddr_in x;\n</code></pre>\n<p>you would have to write <code>x.sockaddr.family</code> to access the <code>family</code> member, there's even a solution to make this more comfortable without violating the standard:</p>\n<pre><code>struct my_sockaddr_in\n{\n    union\n    {\n        struct my_sockaddr sockaddr;\n        struct\n        {\n            unsigned short family;\n        };\n    };\n    unsigned short port;\n    struct in_addr addr;\n};\n</code></pre>\n<p>This uses the feature of <em>anonymous unions</em> and <em>anonymous structs</em>. Given a <code>struct my_sockaddr_in</code>, you can now safely access the address family with just <code>x.family</code>.</p>\n<p>This usage is conforming because of <strong>\u00a76.5.2.3, section 6</strong>:</p>\n<blockquote>\n<p id=\"so_45341763_45344013_2\">One special guarantee is made in order to simplify the use of unions: if a union contains\n  several structures that share a common initial sequence (see below), and if the union\n  object currently contains one of these structures, it is permitted to inspect the common\n  initial part of any of them anywhere that a declaration of the completed type of the union\n  is visible. Tw o structures share a <em>common initial sequence</em> if corresponding members\n  have compatible types (and, for bit-fields, the same widths) for a sequence of one or more\n  initial members.</p>\n</blockquote>\n<hr>\n<p>All in all, I would <strong>strongly</strong> suggest not to use something like <code>gcc</code>'s <code>-fno-strict-aliasing</code> flag <strong>for any new code you write</strong>. It just prevents some optimizations and allows you to compile <strong>some</strong> code relying on <em>undefined behavior</em>. You don't get the strong guarantees you get when writing code that fully conforms to the standard.</p>\n</hr></hr></hr>", "LastActivityDate": "2017-07-27T07:24:41.060", "Id": "45344013", "CommentCount": "1", "CreationDate": "2017-07-27T07:24:41.060", "ParentId": "45341763", "Score": "1", "OwnerUserId": "2371524"}, "45344180": {"PostTypeId": "2", "Body": "<p>Yep, I write code that conforms to the standard and use it in production.</p>\n", "LastActivityDate": "2017-07-27T07:32:37.847", "Id": "45344180", "CommentCount": "0", "CreationDate": "2017-07-27T07:32:37.847", "ParentId": "45341763", "Score": "0", "OwnerUserId": "1505939"}});