post_cb({"26626663": {"ViewCount": "129", "Body": "<p>I would like to know if the following code is not accepted by the C++ standard.</p>\n<pre><code>int n{ 10 };\ndouble* p = new double[0];\ndouble* q = p + n;\nstd::cout &lt;&lt; \"n = \" &lt;&lt; static_cast&lt;int&gt;(q - p) &lt;&lt; std::endl;\n</code></pre>\n<p>I want that program to display the value of n.</p>\n<p>As this question might look weird, here is the explanation of the origin of this problem. I want to design a dynamic array class in 2D (think of a std::vector kind of a container but in 2D instead of 1D). A straightforward approach would be:</p>\n<pre><code>template &lt;typename T&gt;\nclass Array2D&lt;T&gt; {\nprivate:\n    T* data_;\n    int nb_rows_;\n    int nb_columns_;\npublic:\n    ...\n};\n</code></pre>\n<p>Unfortunately, this design is not SIMD friendly as a loop such as</p>\n<pre><code>Array2D&lt;int&gt; A(5, 6);\nfor (int i = 0; i &lt; A.nb_rows(); ++i) {\n    for (int j = 0; j &lt; A.nb_columns(); ++j) {\n        A(i, j) += 1;\n    }\n}\n</code></pre>\n<p>would fail to vectorize as the compiler can't be sure if nb_columns_ is not changed during the loop because of pointer aliasing. Therefore, I use the same design as most implementation of std::vector where the size of the vector is \"hidden\" in a pointer.</p>\n<pre><code>template &lt;typename T&gt;\nclass Array2D&lt;T&gt; {\nprivate:\n    T* data_;\n    T* nb_rows_;\n    T* nb_columns_;\npublic:\n    Array2D(int n, int p) {\n        data_ = new T[n * p];\n        nb_rows_ = data_ + n;\n        nb_columns_ = data_ + p;\n    }\n    ...\n    int nb_columns() const {\n        return static_cast&lt;int&gt;(nb_columns_ - data_);\n    }\n    ...\n};\n</code></pre>\n<p>This design works well as long as n &gt;= 1 and p &gt;= 1. But if n = 0 and p = 5, you end up with the kind of \"problem\" explained above. Constructing an Array2D with 0 rows might be useful because of the following method in my class</p>\n<pre><code>void push_back(const Array1D&lt;T&gt;&amp; B);\n</code></pre>\n<p>that takes an Array1D of size p (it is checked with an assert) and adds a row to my Array2D object. You could do:</p>\n<pre><code>Array2D&lt;double&gt; A(0, 10);\nArray1D&lt;double&gt; B(10);\n\n// work with B\nA.push_back(B);\n</code></pre>\n<p>The code works fine on clang, g++ and icpc but I am still wondering if it is valid. Section 5.7 of the C++11 standard is about that problem but talk about \"array objects\". I am wondering if my p points to what they call an \"array object\", or if an array object is something such as \"double p[5]\".</p>\n", "AcceptedAnswerId": "26627045", "Title": "Pointer arithmetic: out of bound without dereferencing", "CreationDate": "2014-10-29T09:26:21.863", "Id": "26626663", "CommentCount": "6", "LastEditDate": "2014-10-29T09:44:05.130", "PostTypeId": "1", "LastEditorUserId": "3763545", "LastActivityDate": "2014-10-29T09:59:40.860", "Score": "2", "OwnerUserId": "3763545", "Tags": "<c++><arrays><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26626663_26627168_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6141}, "so_26626663_26627168_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7223}, "so_26626663_26627045_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}, "so_26626663_26627168_0": {"length": 32, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_26626663_26627168_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5905}, "so_26626663_26627168_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 6967}, "so_26626663_26627045_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}, "so_26626663_26627168_0": {"length": 32, "quality": 1.0, "section_id": 5906}}, "n4659": {"so_26626663_26627168_2": {"length": 11, "quality": 0.5789473684210527, "section_id": 7603}, "so_26626663_26627168_0": {"length": 20, "quality": 0.625, "section_id": 7638}}}, "26627045": {"Id": "26627045", "PostTypeId": "2", "Body": "<p>It's undefined behavior.  In practice, it will probably work on most modern systems, but there have been systems in the past where it would cause the program to crash.  A pointer is <em>not</em> just a special type of integer; it can have all sorts of structure, and just loading a pointer to unmapped memory into a register can cause a trap.</p>\n<p>From the standard (emphasis added), \u00a75.7/5:</p>\n<blockquote>\n<p id=\"so_26626663_26627045_0\">When an expression that has integral type is added to or\n  subtracted from a pointer, the result has the type of the\n  pointer operand. If the pointer operand points to an element of\n  an array object, <em>and the array is large enough</em>, the result\n  points to an element offset from the original element such that\n  the difference of the subscripts of the resulting and original\n  array elements equals the integral expression. In other words,\n  if the expression P points to the i-th element of an array\n  object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i + n-th\n  and i \u2212 n-th elements of the array object, provided they exist.\n  Moreover, if the expression P points to the last element of an\n  array object, the expression (P)+1 points one past the last\n  element of the array object, and if the expression Q points one\n  past the last element of an array object, the expression (Q)-1\n  points to the last element of the array object. <em>If both the\n  pointer operand and the result point to elements of the same\n  array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</em></p>\n</blockquote>\n<p>That last sentence is the important one: \"otherwise, the\nbehavior is undefined\".</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2014-10-29T09:51:21.323", "Score": "4", "CreationDate": "2014-10-29T09:45:13.893", "ParentId": "26626663", "CommentCount": "7", "OwnerUserId": "649665", "LastEditDate": "2014-10-29T09:51:21.323"}, "26627168": {"Id": "26627168", "PostTypeId": "2", "Body": "<pre><code>double* q = p + n;\n</code></pre>\n<p>This line induces undefined behavior. [expr.add]/5 specifies that</p>\n<blockquote>\n<p id=\"so_26626663_26627168_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. [\u2026] If both the pointer operand and the result point to elements of the\n  same array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; otherwise, the behavior\n  is undefined.</p>\n</blockquote>\n<p>The result doesn't point to an element of <code>p</code>, thus the last sentence applies. It will most certainly work on any system you test it on*, but it isn't covered by the standard in any way .</p>\n<hr>\n<blockquote>\n<p id=\"so_26626663_26627168_1\">Unfortunately, the standard does not seem to define what an \"array\n  object\" is.</p>\n</blockquote>\n<p>An array <em>object</em> is just an object with array type, shortly speaking: An array. </p>\n<pre><code>int a[5];\n</code></pre>\n<p>Declares an array (object) with five elements and size <code>sizeof int * 5</code>. Also consider [expr.add]/4:</p>\n<blockquote>\n<p id=\"so_26626663_26627168_2\">For the purposes of these operators, a pointer to a nonarray object\n  behaves the same as a pointer to the first element of an array of\n  length one with the type of the object as its element type.</p>\n</blockquote>\n<p>* <sub>The system you use will presumably represent addresses in pointers as simple integers and the addition and subtraction will only invoke simple arithmetic. There might also be systems that check pointer values loaded into registers. </sub> </p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-29T09:59:40.860", "Score": "3", "CreationDate": "2014-10-29T09:52:09.303", "ParentId": "26626663", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-10-29T09:59:40.860"}});