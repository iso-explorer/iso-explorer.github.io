post_cb({"6594023": {"Id": "6594023", "PostTypeId": "2", "Body": "<p>It never works for a nested type, unless T is also a parameter.</p>\n<p>If you call <code>f(1)</code>, the compiler has no chance of finding all T's with a nested <code>typedef int  value_type;</code>.</p>\n<p>You can infer a type that is part of the parameter type, like</p>\n<pre><code>template&lt;class T&gt;\nvoid f(std::vector&lt;T&gt;);\n</code></pre>\n", "LastActivityDate": "2011-07-06T09:12:24.733", "Score": "6", "CreationDate": "2011-07-06T09:12:24.733", "ParentId": "6593821", "CommentCount": "0", "OwnerUserId": "597607"}, "6593963": {"Id": "6593963", "PostTypeId": "2", "Body": "<p>The standard requires you to disambiguate the dependent type:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(typename T::value_type){}\n</code></pre>\n<p>In the past there have been some less-standard behaviours in this area, resulting in code that compiled on one (MSVC) but not on the other (GCC) compiler. These days, likely under the influence of heavily generic standard libraries like Boost, compilers seem to accept the correct code only.</p>\n<hr>\n<p>The typename keyword is sometimes needed to <a href=\"http://womble.decadent.org.uk/c++/template-faq.html#dependent\" rel=\"nofollow\">disambiguate identifiers dependent on template arguments</a> (also <a href=\"http://womble.decadent.org.uk/c++/template-faq.html#disambiguation\" rel=\"nofollow\">this</a>). Think of it this way: you have to give the compiler enough information to complete a syntax check the first time 'round while parsing a template definition. The actual template arguments aren't known at that time and (C++ having an involved grammar) you have to give the compiler hints what kind of symbol a token is going to represent later on</p>\n</hr>", "LastActivityDate": "2011-07-06T09:07:41.377", "Score": "0", "CreationDate": "2011-07-06T09:07:41.377", "ParentId": "6593821", "CommentCount": "0", "OwnerUserId": "85371"}, "6594119": {"Id": "6594119", "PostTypeId": "2", "Body": "<p>Unless you specify the <code>T</code> parameter somehow, the compiler will not try to deduct <code>T</code> in any way.</p>\n<p>Even if you specify it explicitly, I believe it will work only where the original definition is provided, not though typedefs.</p>\n<p>Consider the following example (compiled with clang++, apparently g++ fails on that):</p>\n<pre><code>#include &lt;stdio.h&gt;\ntemplate &lt;typename T&gt;\nvoid foo(T) {\nprintf(\"foo(T)\\n\");\n}\n\ntemplate &lt;typename T&gt;\nvoid foo(typename T::value) {\nprintf(\"foo(T::value)\\n\");\n}\n\nstruct X {\n  class value {};\n};\n\nstruct Z {\n  typedef int value;\n};\n\nstruct XZ {\n  typedef Z value;\n};\n\ntypedef X::value Xv;\n\n#define CALL(function,param) printf(#function \" (\" #param \") = \"); function(param());\n\nvoid explicitCalls() {\n  printf(\"Explicit calls:\\n\");\n  CALL(foo&lt;int&gt;,int);\n  CALL(foo&lt;X::value&gt;,X::value);\n  CALL(foo&lt;Z::value&gt;,Z::value);\n  CALL(foo&lt;XZ::value&gt;,XZ::value);\n  CALL(foo&lt;Xv&gt;,Xv);\n}\n\nvoid implicitCalls() {\n  printf(\"Implicit calls:\\n\");\n  CALL(foo,int);\n  CALL(foo,X::value);\n  CALL(foo,Z::value);\n  CALL(foo,XZ::value);\n  CALL(foo,Xv);\n}\n\nint main() {\n  explicitCalls();\n  implicitCalls();\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>Explicit calls:\nfoo&lt;int&gt; (int) = foo(T)\nfoo&lt;X::value&gt; (X::value) = foo(T::value)\nfoo&lt;Z::value&gt; (Z::value) = foo(T)\nfoo&lt;XZ::value&gt; (XZ::value) = foo(T)\nfoo&lt;Xv&gt; (Xv) = foo(T::value)\nImplicit calls:\nfoo (int) = foo(T)\nfoo (X::value) = foo(T)\nfoo (Z::value) = foo(T)\nfoo (XZ::value) = foo(T)\nfoo (Xv) = foo(T)\n</code></pre>\n", "LastActivityDate": "2011-07-06T09:20:33.363", "Score": "0", "CreationDate": "2011-07-06T09:20:33.363", "ParentId": "6593821", "CommentCount": "0", "OwnerUserId": "635654"}, "6593821": {"ViewCount": "119", "Body": "<p>Given a template function, that does not use the template parameter for input directly. How would C++ type inference work? For instance given</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T::value_type){}\n</code></pre>\n<p>when (if at all) will type inference work for this function?</p>\n<p>Is there any other place except of <code>template&lt;typename T1,...&gt;void f(T1,T2,...)</code> where type inference might occur?</p>\n<p>As always, quote the standard for extra credit.</p>\n", "AcceptedAnswerId": "6594440", "Title": "Type inference for `T::some_typredef` in Templated Function", "CreationDate": "2011-07-06T08:53:57.513", "Id": "6593821", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-07-06T09:46:58.003", "Score": "3", "OwnerUserId": "55094", "Tags": "<c++><templates>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_6593821_6594440_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}, "so_6593821_6594440_6": {"length": 41, "quality": 0.9534883720930233, "section_id": 337}, "so_6593821_6594440_2": {"length": 54, "quality": 0.9818181818181818, "section_id": 335}}, "n3337": {"so_6593821_6594440_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 326}, "so_6593821_6594440_6": {"length": 41, "quality": 0.9534883720930233, "section_id": 327}, "so_6593821_6594440_2": {"length": 54, "quality": 0.9818181818181818, "section_id": 325}}, "n4659": {"so_6593821_6594440_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}, "so_6593821_6594440_6": {"length": 41, "quality": 0.9534883720930233, "section_id": 346}, "so_6593821_6594440_2": {"length": 54, "quality": 0.9818181818181818, "section_id": 344}}}, "6594440": {"Id": "6594440", "PostTypeId": "2", "Body": "<p>I think here's your answer:</p>\n<blockquote>\n<h3>14.8.2.4 - Deducing template arguments from a type [temp.deduct.type]</h3>\n<p id=\"so_6593821_6594440_0\">[...]</p>\n<p id=\"so_6593821_6594440_1\"><strong>-3-</strong> [...]</p>\n<p id=\"so_6593821_6594440_2\">In most cases, the types, templates, and non-type values that are used to compose <code>P</code> participate in template argument deduction. That is, they may be used to determine the value of a template argument, and the value so determined must be consistent with the values determined elsewhere. In certain contexts, however, the value does not participate in type deduction, but instead uses the values of template arguments that were either deduced elsewhere or explicitly specified. If a template parameter is used only in nondeduced contexts and is not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_6593821_6594440_3\"><strong>-4-</strong> The nondeduced contexts are:</p>\n<ul>\n<li><p id=\"so_6593821_6594440_4\">The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.</p></li>\n<li><p id=\"so_6593821_6594440_5\">A type that is a <em>template-id</em> in which one or more of the <em>template-arguments</em> is an expression that references a <em>template-parameter</em>.</p></li>\n</ul>\n<p id=\"so_6593821_6594440_6\">When a type name is specified in a way that includes a nondeduced context, all of the types that comprise that type name are also nondeduced. However, a compound type can include both deduced and nondeduced types. [<em>Example</em>: If a type is specified as <code>A&lt;T&gt;::B&lt;T2&gt;</code>, both <code>T</code> and <code>T2</code> are nondeduced. Likewise, if a type is specified as <code>A&lt;I+J&gt;::X&lt;T&gt;</code>, <code>I</code>, <code>J</code>, and <code>T</code> are nondeduced. If a type is specified as <code>void f(A&lt;T&gt;::B, A&lt;T&gt;)</code>, the <code>T</code> in <code>A&lt;T&gt;::B</code> is nondeduced but the <code>T</code> in <code>A&lt;T&gt;</code> is deduced. ]</p>\n</blockquote>\n<p>Your <code>T::value_type</code> is a <em>qualified-id</em> of a type, so types in its <em>nested-name-specifier</em> are nondeduced and must be specified explicitly.</p>\n<p><strong>Edit:</strong> this information is from <a href=\"http://www.kuzbass.ru:8086/docs/isocpp/template.html#temp.deduct.type\" rel=\"nofollow\">ISO/IEC 14882:1998</a>.</p>\n", "LastActivityDate": "2011-07-06T09:46:58.003", "Score": "5", "CreationDate": "2011-07-06T09:46:58.003", "ParentId": "6593821", "CommentCount": "3", "OwnerUserId": "213376"}});