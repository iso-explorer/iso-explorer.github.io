post_cb({"bq_ids": {"n4140": {"so_7439268_7439387_0": {"length": 68, "quality": 0.8292682926829268, "section_id": 5340}}, "n3337": {"so_7439268_7439387_0": {"length": 74, "quality": 0.9024390243902439, "section_id": 5137}}, "n4659": {"so_7439268_7439387_0": {"length": 62, "quality": 0.7560975609756098, "section_id": 6761}}}, "7439387": {"Id": "7439387", "PostTypeId": "2", "Body": "<p>This question should not be answered on the level of assembler but stil on c/c++ language level. On most architectures it is impossible to compare signed and unsigned numbers, and c/c++ does not facilitate such comparisons. Instead there are rules about converting one of the operands to type of the other in order to compare them - see for example aswers to <a href=\"https://stackoverflow.com/questions/50605/signed-to-unsigned-conversion-in-c-is-it-always-safe\">this question</a></p>\n<p>About comparing to literals - typical way of doing it (as you did) is not wrong,  but you can do it better - according to c++ standard:</p>\n<blockquote>\n<p id=\"so_7439268_7439387_0\">2.13.1.1 An integer literal is a sequence of digits that has no period\n  or exponent part. An integer literal may have a prefix that specifies\n  its base and a suffix that specifies its type. The lexically first\n  digit of the sequence of digits is the most significant. A decimal\n  integer literal (base ten) begins with a digit other than 0 and con-\n  sists of a sequence of decimal digits. An octal integer literal (base\n  eight) begins with the digit 0 and con- sists of a sequence of octal\n  digits.22) A hexadecimal integer literal (base sixteen) begins with 0x\n  or 0X and consists of a sequence of hexadecimal digits, which include\n  the decimal digits and the letters a through f and A through F with\n  decimal values ten through fifteen. [Example: the number twelve can be\n  written 12, 014, or 0XC. ]</p>\n<p id=\"so_7439268_7439387_1\">2.13.1.2 The type of an integer literal depends on its form, value,\n  and suffix. If it is decimal and has no suffix, it has the first of\n  these types in which its value can be represented: int, long int; if\n  the value cannot be repre- sented as a long int, the behavior is\n  undefined. If it is octal or hexadecimal and has no suffix, it has the first of these types in which its value can be represented: int,\n  unsigned int, long int, unsigned long int. If it is suffixed by u or\n  U, its type is the first of these types in which its value can be\n  repre- sented: unsigned int, unsigned long int. If it is suffixed by l\n  or L, its type is the first of these types in which its value can be\n  represented: long int, unsigned long int. If it is suffixed by ul, lu,\n  uL, Lu, Ul, lU, UL, or LU, its type is unsigned long int.</p>\n</blockquote>\n<p>If you want to be sure about your literal type (and therefore comaprison type) add described suffixes to ensure right type of literal.</p>\n<p>It is also worth noticing that literal <code>0</code> is actually not decimal but octal - it doesn't seem to change anything, but is quite unexpected - or am I wrong?</p>\n<p>To summarize - it is not wrong to write code like that, but you should remeber that in certain conditions in might behave counter-intuitive (or at least counter-mathematical ;)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-16T02:11:04.133", "Score": "2", "CreationDate": "2011-09-16T01:55:57.493", "ParentId": "7439268", "CommentCount": "1", "OwnerUserId": "455304", "LastEditDate": "2017-05-23T12:22:00.533"}, "7439268": {"ViewCount": "926", "Body": "<p>The book told that writing:</p>\n<pre><code>static unsigned int foo;\n</code></pre>\n<p>and later</p>\n<pre><code>if( foo &gt; 0)\n{\n</code></pre>\n<p>is wrong, and it will leads to a hard to find bug.\nWhy is that?</p>\n<p>In the x86 assembly language programming there are signed arithmetic instructions and\nalso unsigned arithmetic instructions, \nJG JL &lt;-signed arithmetic \nJB JA &lt;- unsigned instructions.</p>\n<p>So the compiler can just assemble that if (foo &gt;0 ) statement with unsigned instructions \nisn't it? Can somebody explain how it works in advance?</p>\n<p>Is that instruction wrong? Or if there is a difference in \"C\" where \"C++\" is strict in\nthat case? Please explain.</p>\n<p>Here we are comparing a unsigned variable with a immediate value. What is happening inside\nthe compiler actually in this case?</p>\n<p>And when we compare a signed value with unsigned value what happens? Then what instructions will compiler choose, signed instructions or unsigned instructions?</p>\n<p>--thanks in advance--</p>\n", "Title": "Static unsigned int foo and later if ( foo >0 )?", "CreationDate": "2011-09-16T01:31:57.997", "LastActivityDate": "2012-06-05T18:06:59.383", "CommentCount": "0", "LastEditDate": "2012-06-05T18:06:59.383", "PostTypeId": "1", "LastEditorDisplayName": "user1114055", "Id": "7439268", "Score": "0", "OwnerUserId": "442399", "Tags": "<c++><c><int>", "AnswerCount": "1"}});