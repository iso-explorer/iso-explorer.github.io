post_cb({"bq_ids": {"n4140": {"so_36457841_36457841_6": {"length": 5, "quality": 1.0, "section_id": 9}, "so_36457841_36457841_5": {"length": 6, "quality": 1.0, "section_id": 9}, "so_36457841_36457841_2": {"length": 47, "quality": 0.9038461538461539, "section_id": 6064}, "so_36457841_36457841_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 8}, "so_36457841_36457841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7239}}, "n3337": {"so_36457841_36457841_6": {"length": 5, "quality": 1.0, "section_id": 6}, "so_36457841_36457841_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 6787}, "so_36457841_36457841_2": {"length": 44, "quality": 0.8461538461538461, "section_id": 5832}, "so_36457841_36457841_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 5}, "so_36457841_36457841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6983}}, "n4659": {"so_36457841_36457841_6": {"length": 5, "quality": 1.0, "section_id": 9}, "so_36457841_36457841_5": {"length": 6, "quality": 1.0, "section_id": 9}, "so_36457841_36457841_2": {"length": 45, "quality": 0.8653846153846154, "section_id": 7560}, "so_36457841_36457841_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 8}, "so_36457841_36457841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8748}}}, "36457841": {"ViewCount": "117", "Body": "<p>I am trying to determine whether the following code invokes undefined behavior:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A;\n\nvoid f(A&amp; f)\n{\n  char* x = reinterpret_cast&lt;char*&gt;(&amp;f);\n  for (int i = 0; i &lt; 5; ++i)\n    std::cout &lt;&lt; x[i];\n}\n\nint main(int argc, char** argue)\n{\n  A* a = reinterpret_cast&lt;A*&gt;(new char[5])\n  f(*a);\n}\n</code></pre>\n<p>My understanding is that <code>reinterpret_cast</code>s to and from <code>char*</code> are compliant because the standard permits aliasing with <code>char</code> and <code>unsigned char</code> pointers (emphasis mine):</p>\n<blockquote>\n<p id=\"so_36457841_36457841_0\">If a program <strong>attempts to access</strong> the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li><strong>a <code>char</code> or <code>unsigned char</code> type.</strong></li>\n</ul>\n</blockquote>\n<p>However, I am not sure whether <code>f(*a)</code> invokes undefined behavior by creating a <code>A&amp;</code> reference to the invalid pointer. The deciding factor seems to be what \"attempts to access\" verbiage means in the context of the C++ standard.</p>\n<p>My intuition is that this does <em>not</em> constitute an access, since an access would require <code>A</code> to be defined (it is declared, but not defined in this example). Unfortunately, I cannot find a concrete definition of \"access\" in the C++ standard:</p>\n<p><strong>Does <code>f(*a)</code> invoke undefined behavior? What constitutes \"access\" in the C++ standard?</strong></p>\n<p>I understand that, regardless of the answer, it is likely a bad idea to rely on this behavior in production code. I am asking this question primarily out of a desire to improve my understanding of the language.</p>\n<p><strong>[Edit]</strong> @SergeyA cited this section of the standard. I've included it here for easy reference (emphasis mine):</p>\n<blockquote>\n<p id=\"so_36457841_36457841_1\"><strong>5.3.1/1 [expr.unary.op]</strong></p>\n<p id=\"so_36457841_36457841_2\">The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is \u201c<code>T</code>.\u201d [Note: indirection through a pointer to an incomplete type (other than cv void) is valid. <strong>The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1.</strong> \u2014 end note ]</p>\n</blockquote>\n<p>Tracing the reference to 4.1, we find:</p>\n<blockquote>\n<p id=\"so_36457841_36457841_3\"><strong>4.1/1 [conv.lval]</strong></p>\n<p id=\"so_36457841_36457841_4\">A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If T is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise, the type of the prvalue is <code>T</code>.</p>\n<p id=\"so_36457841_36457841_5\"><strong>When an lvalue-to-rvalue conversion is applied to an expression <code>e</code></strong>, and either:</p>\n<ul>\n<li><code>e</code> is not potentially evaluated, or</li>\n<li>the evaluation of <code>e</code> results in the evaluation of a member <code>ex</code> of the set of potential results of <code>e</code>, and <code>ex</code> names a variable <code>x</code> that is not odr-used by <code>ex</code> (3.2)</li>\n</ul>\n<p id=\"so_36457841_36457841_6\">the value contained in <strong>the referenced object is not accessed</strong>.</p>\n</blockquote>\n<p>I think our answer lies in whether <code>*a</code> satisfies the second bullet point. I am having trouble parsing that condition, so I am not sure.</p>\n", "Title": "Creating an invalid reference via reinterpret cast", "CreationDate": "2016-04-06T17:09:07.353", "LastActivityDate": "2016-04-06T18:25:01.783", "CommentCount": "1", "LastEditDate": "2016-04-06T18:25:01.783", "PostTypeId": "1", "LastEditorUserId": "111426", "Id": "36457841", "Score": "5", "OwnerUserId": "111426", "Tags": "<c++><standards><language-lawyer><reinterpret-cast><strict-aliasing>", "AnswerCount": "1"}, "36457908": {"Id": "36457908", "PostTypeId": "2", "Body": "<p><code>char* x = reinterpret_cast&lt;char*&gt;(&amp;f);</code> is valid. Or, more specifically, access through <code>x</code> is allowed - the cast itself is always valid.</p>\n<p><code>A* a = reinterpret_cast&lt;A*&gt;(new char[5])</code> is not valid - or, to be precise, access through <code>a</code> will trigger undefined behaviour.</p>\n<p>The reason for this is that while it's OK to access object through a <code>char*</code>, it's not OK to access array of chars through a random object. Standard allows first, but not the second.</p>\n<p>Or, in layman terms, you can alias a <code>type*</code> through <code>char*</code>, but you can't alias <code>char*</code> through <code>type*</code>.</p>\n<p><strong>EDIT</strong></p>\n<p>I just noticed I didn't answer direct question (\"<em>What constitutes \"access\" in the C++ standard</em>\"). Apparently, Standard does not define <em>access</em> (at least, I was not able to find the formal definition), but dereferencing the pointer is commonly understood to qualify for access. </p>\n", "LastEditorUserId": "5245033", "LastActivityDate": "2016-04-06T17:31:08.940", "Score": "3", "CreationDate": "2016-04-06T17:12:29.273", "ParentId": "36457841", "CommentCount": "7", "OwnerUserId": "5245033", "LastEditDate": "2016-04-06T17:31:08.940"}});