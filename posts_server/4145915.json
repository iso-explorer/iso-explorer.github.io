post_cb({"4146008": {"ParentId": "4145915", "CommentCount": "2", "Body": "<p>[class.abstract]: \"A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1).\"</p>\n<p>Your <code>A::f</code> is called by <code>B::f</code>, so there must be a single definition of <code>A::f</code>.</p>\n", "OwnerUserId": "101225", "PostTypeId": "2", "Id": "4146008", "Score": "0", "CreationDate": "2010-11-10T15:25:56.757", "LastActivityDate": "2010-11-10T15:25:56.757"}, "4146296": {"ParentId": "4145915", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>As @Charles Bailey pointed out, your <code>A::f</code> is in fact used even though it's pure virtual.  But that's beside the main point.</p>\n<p>It's not accurate that the One Definition Rule does not apply to functions that are not used.  We have:</p>\n<blockquote>\n<p id=\"so_4145915_4146296_0\">3.2p1 No translation unit shall contain more than one definition of any variable, function, class type, enumeration type or template.</p>\n<p id=\"so_4145915_4146296_1\">3.2p3 Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required.</p>\n</blockquote>\n<p>Together, these requirements seem to imply that a used function must have exactly one definition, and an unused function (including a pure virtual function which is never explicitly called) may have either no definition or a single definition.  In either case, multiple definitions for a non-inline function makes the program ill-formed.</p>\n<p>At least, I'm quite certain that's the intent.  But you may be on to a hole in the phrasing, since a very literal reading does not say anywhere that multiple different definitions of the same unused function in different translation units is ill-formed.</p>\n<pre><code>// x.cpp\nvoid f() {}\nvoid g() {}\n\n// y.cpp\n#include &lt;iostream&gt;\nvoid f() {\n  std::cout &lt;&lt; \"Huh\" &lt;&lt; std::endl;\n}\nvoid h() {}\n\n// z.cpp\nvoid g();\nvoid h();\nint main() { \n  g();\n  h();\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2010-11-10T16:03:41.430", "Id": "4146296", "Score": "1", "CreationDate": "2010-11-10T15:50:57.953", "LastActivityDate": "2010-11-10T16:03:41.430"}, "4295246": {"ParentId": "4145915", "CommentCount": "1", "Body": "<p>This is related but off-topic: from the citations it seems there is a hole in the Standard alright: it should also say a pure virtual destructor is used, and, that it must be defined; at least if there exist any derived class objects which are destroyed or if a destructor of such is defined, since the derived class destructor must call the base destructor, implicitly it does so with the qualified::id syntax.  The definition of such destructors is usually trivial but cannot be elided and cannot be generated.</p>\n", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "4295246", "Score": "1", "CreationDate": "2010-11-28T03:51:28.037", "LastActivityDate": "2010-11-28T03:51:28.037"}, "4146005": {"ParentId": "4145915", "CommentCount": "8", "Body": "<p>The two clauses are not mutually exclusive.\nThat a virtual function is used if it is not pure, does not mean that the converse holds. If a virtual function is pure it does not mean that it is necessarily not used. It may still be used \"if its name appears in a potentially evaluated expression\" such as in your example: <code>A::f();</code>.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "4146005", "Score": "11", "CreationDate": "2010-11-10T15:25:40.310", "LastActivityDate": "2010-11-10T15:25:40.310"}, "4145915": {"CommentCount": "19", "AcceptedAnswerId": "4146005", "PostTypeId": "1", "LastEditorUserId": "469935", "CreationDate": "2010-11-10T15:15:26.817", "LastActivityDate": "2010-11-28T03:51:28.037", "LastEditDate": "2010-11-10T15:42:17.003", "ViewCount": "386", "FavoriteCount": "3", "Title": "A virtual member function is used if it is not pure?", "Id": "4145915", "Score": "8", "Body": "<p><code>C++03 3.2.2</code> <strong><em>...An object or non-overloaded function is used if its name appears in a potentially-evaluated expression. A virtual member function is used if it is not pure...</em></strong></p>\n<p>And then later in <code>3.2.3</code> we have: <strong><em>Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8).\nAn inline function shall be defined in every translation unit in which it is used.</em></strong></p>\n<p>Along the lines I am reading: a pure virtual function is not used. The ODR applies only to functions which are used. Doesn't this imply that the following would be legal? I am guessing the answer is no, it doesn't, but then I can't understand why. </p>\n<pre><code>//x.h\nstruct A\n{\n   virtual void f() = 0;\n};\n\n//y.cpp\n#include \"x.h\"\nvoid A::f()\n{\n}\n\n//z.cpp\n#include \"x.h\"\n#include &lt;iostream&gt;\nvoid A::f()\n{\n   std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n}\n\n//main.cpp\n#include \"x.h\"\nstruct B:A\n{\n   virtual void f()\n   {\n      A::f();\n   }\n};\n\nint main()\n{\n   A* p = new B;\n   p-&gt;f();\n}\n</code></pre>\n", "Tags": "<c++><pure-virtual><language-lawyer><one-definition-rule>", "OwnerUserId": "469935", "AnswerCount": "5"}, "4146034": {"ParentId": "4145915", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This code violates ODR. A::f is multiply defined. Hence it has UB.</p>\n<p>Multiple definitions across translation units are only allowed for the following as per $3.2/5</p>\n<blockquote>\n<p id=\"so_4145915_4146034_0\">There can be more than one definition\n  of a class type (clause 9),\n  enumeration type (7.2), inline\n  function with external linkage\n  (7.1.2), class template (clause 14),\n  non-static function template (14.5.5),\n  static data member of a class template\n  (14.5.1.3), member function of a class\n  template (14.5.1.1), or template\n  specialization for which some template\n  parameters are not specified (14.7,\n  14.5.4) in a program provided that each definition appears in a different\n  translation unit, and provided the\n  definitions satisfy the following\n  requirements.</p>\n</blockquote>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-11-10T15:35:34.610", "Id": "4146034", "Score": "3", "CreationDate": "2010-11-10T15:28:07.217", "LastActivityDate": "2010-11-10T15:35:34.610"}, "bq_ids": {"n4140": {"so_4145915_4146296_1": {"section_id": 7041, "quality": 0.8333333333333334, "length": 10}, "so_4145915_4146034_0": {"section_id": 7043, "quality": 0.8518518518518519, "length": 46}, "so_4145915_4146296_0": {"section_id": 7038, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_4145915_4146296_1": {"section_id": 6786, "quality": 0.8333333333333334, "length": 10}, "so_4145915_4146034_0": {"section_id": 6788, "quality": 0.8518518518518519, "length": 46}, "so_4145915_4146296_0": {"section_id": 6784, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_4145915_4146296_1": {"section_id": 8538, "quality": 0.8333333333333334, "length": 10}, "so_4145915_4146034_0": {"section_id": 8540, "quality": 0.8518518518518519, "length": 46}, "so_4145915_4146296_0": {"section_id": 8535, "quality": 0.9333333333333333, "length": 14}}}});