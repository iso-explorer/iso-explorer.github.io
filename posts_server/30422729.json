post_cb({"bq_ids": {"n4140": {"so_30422729_30443939_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5949}}, "n3337": {"so_30422729_30443939_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5719}}, "n4659": {"so_30422729_30443939_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 7435}}}, "30477417": {"Id": "30477417", "PostTypeId": "2", "Body": "<p><strong>Explicit instantiations of template function produce performance difference?</strong></p>\n<p>Some experiments I have done to look for the performance difference:</p>\n<p><strong>1.</strong><br>\nFirstly I suspected that the performance difference may be caused by the implementation itself. In fact, we have two sets of implementation, one is implemented by ourself(this one is quite similar to codes by @black), and another is implemented to serve as a wrapper of <code>Eigen::Matrix</code>, which is controlled by a macro on-off, But switch between these two implementation does not make any change, the global one is still slower than the member one.   </br></p>\n<p><strong>2.</strong><br>\nSince these codes(class<code>Vector&lt;Scalar, Dim&gt;</code> &amp; <code>SquareMatrix&lt;Scalar, Dim&gt;</code>) are implemented in a large project, then I guess that the performance difference may probably be influenced by other codes(though I think it impossible, but still worth a try). So I extract all necessary codes(implementation by ourself used), and put them in my manually-generated VS2010 project. Surprisingly but also normally, I find that the global one is slightly faster than the member one,  which is the same result as  @black @Myles Hathcock, even though I leave the implementation of codes unchanged.</br></p>\n<p><strong>3.</strong><br>\nBecause in our project, <code>outerProduct</code> are put into a release lib files, while in my manually-generate project, it straightforwardly produce the .obj files, and be link to .exe files. To exclude this issue, I use the codes extracted and produce the lib file through VS2010, and apply this lib file to another VS project to test the performance difference, but still the global one is slight faster than the member one. So, both codes have the same implementation and both of them are put into lib files, though one is produced by Scons and the other is generated by VS project, but they have different performance. Is Scons causing this problem?</br></p>\n<p><strong>4.</strong><br>\nFor the codes shown in my question, global function <code>outerProduct</code> is declared and defined in <code>.h</code> file, then <code>#include</code> by a <code>.cpp</code> file. So when compiling this <code>.cpp</code> file, <code>outerProduct</code> will be instantiated. But if I change this to another manner:<br>(I have to remind that these codes are now compiled by <strong>Scons</strong> to product <code>lib</code> file, not manually-generated VS2010 project)<br>\nFirst, I declare the global function <code>outerProduct</code> in <code>.h</code> file:</br></br></br></p>\n<pre><code>\\\\outProduct.h\ntemplate&lt;typename Scalar, int Dim&gt;\nvoid outerProduct(const Vector&lt;Scalar, Dim&gt; &amp; v1 , const Vector&lt;Scalar, Dim&gt; &amp; v2, SquareMatrix&lt;Scalar, Dim&gt; &amp; m);\n</code></pre>\n<p>then in <code>.cpp</code> file, </p>\n<pre><code>\\\\outerProduct.cpp\ntemplate&lt;typename Scalar, int Dim&gt;\nvoid outerProduct(const Vector&lt;Scalar, Dim&gt; &amp; v1 , const Vector&lt;Scalar, Dim&gt; &amp; v2, SquareMatrix&lt;Scalar, Dim&gt; &amp; m)\n{\n    for (unsigned int i=0; i&lt;Dim; i++)\n        for (unsigned int j=0; j&lt;Dim; j++)\n        {\n            m(i,j) = v1[i]*v2[j];\n        }\n}\n</code></pre>\n<p>Since it a template function, It requires some explicit instantiations:</p>\n<pre><code>\\\\outerProduct.cpp\ntemplate void outerProduct&lt;double, 3&gt;(const Vector&lt;double, 3&gt; &amp;, const Vector&lt;double, 3&gt; &amp;, SquareMatrix&lt;double, 3&gt; &amp;);\ntemplate void outerProduct&lt;float, 3&gt;(const Vector&lt;float, 3&gt; &amp;, const Vector&lt;float, 3&gt; &amp;, SquareMatrix&lt;float, 3&gt; &amp;);\n</code></pre>\n<p>Finally, in <code>.cpp</code> file calling this function:</p>\n<pre><code>\\\\use_outerProduct.cpp\n#include \"outerProduct.h\" //note: outerProduct.cpp is not needful.\n...\nouterProduct(v1, v2, m)\n...\n</code></pre>\n<p><strong>The strange thing, now, is that the global one finally be slightly faster than the member one, shown in the following picture:</strong></p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/N0uBU.png\"/></p>\n<p>But this only happens in a Scons environment. In mannually-generated VS2010 project, global one will always be slightly faster than the member one. So this performance difference only results from a Scons environment? and if template function being explicitly instantiated, it will become normal?</p>\n<p>Things are still strange ! <strong>It seems that Scons would have done something I didn't expected.</strong></p>\n<p>//------------------------------------------------------------------------<br>\nAdditionally, test codes are now changed to the followings to avoid the loop elision:</br></p>\n<pre><code>    Vector&lt;double, 3&gt; vec1(0.0);\n    Vector&lt;double, 3&gt; vec2(1.0);\n    Timer timer;\n    while(true)\n    {\n        timer.startTimer();\n        for (unsigned int i=0; i&lt;100000; i++)\n        {\n            vec1 = Vector&lt;double, 3&gt;(i);\n            SquareMatrix&lt;double,3&gt; m = vec1.outerProduct(vec2);\n        }\n        timer.stopTimer();\n        cout&lt;&lt;\"time cost for member function: \"&lt;&lt; timer.getElapsedTime()&lt;&lt;endl;\n\n        timer.startTimer();\n        SquareMatrix&lt;double,3&gt; m;\n        for (unsigned int i=0; i&lt;100000; i++)\n        {\n            vec1 = Vector&lt;double, 3&gt;(i);\n            outerProduct(vec1, vec2, m);\n        }\n        timer.stopTimer();\n        cout&lt;&lt;\"time cost for global function: \"&lt;&lt; timer.getElapsedTime()&lt;&lt;endl;\n        system(\"pause\");\n    }\n</code></pre>\n<p>@black @Myles Hathcock, Great thanks to warm-hearted people! <br>\n@Myles Hathcock, your explanation is really a subtle and abstruse one, but I think I would benefit a lot from it.<br>\nFinally, the entire implementation is on <br>\n<a href=\"https://github.com/FeiZhu/Physika\" rel=\"nofollow noreferrer\">https://github.com/FeiZhu/Physika</a> <br>\nWhich is a physical engine we are developing, and from which you can find more info including the whole source codes. <code>Vector</code>  and <code>SquareMatrix</code> are defined in <code>Physika_Src/Physika_Core</code> folder! But global function <code>outerProduct</code> is not uploaded, you can add it appropriately to somewhere.</br></br></br></br></p>\n", "LastEditorUserId": "4891563", "LastActivityDate": "2015-05-27T08:54:17.480", "Score": "0", "CreationDate": "2015-05-27T08:46:05.650", "ParentId": "30422729", "CommentCount": "0", "OwnerUserId": "4891563", "LastEditDate": "2015-05-27T08:54:17.480"}, "30424114": {"Id": "30424114", "PostTypeId": "2", "Body": "<p>One possible explanation:</p>\n<p>With inlining, in the first case, compiler may knows that <code>result(i, j)</code> (from local variable) doesn't alias <code>this[i]</code> or <code>vec3[j]</code>, and so neither of the Scalar array of <code>this</code> nor <code>vec3</code> are modified.</p>\n<p>In the second case, from the function point of view, the variables may alias, so each write into <code>m</code> might modify Scalars of <code>v1</code> or <code>v2</code>, so neither of <code>v1[i]</code> nor <code>v2[j]</code> can be cached.</p>\n<p>You may try the <a href=\"http://en.wikipedia.org/wiki/Restrict\" rel=\"nofollow\">restrict</a> keyword extension to check if my hypothesis is correct.</p>\n", "LastActivityDate": "2015-05-24T13:36:00.810", "CommentCount": "4", "CreationDate": "2015-05-24T13:36:00.810", "ParentId": "30422729", "Score": "3", "OwnerUserId": "2684539"}, "30443939": {"Id": "30443939", "PostTypeId": "2", "Body": "<p><strong>EDIT: loop elision in the original assembly has been corrected</strong></p>\n<blockquote>\n<p id=\"so_30422729_30443939_0\">[paraphrased] Why is the performance different between the member function and the static function?</p>\n</blockquote>\n<p>I'll start with the simplest things mentioned in your question, and progress to the more nuanced points of performance testing / analysis.</p>\n<p><strong>It is a bad idea to measure performance of debug builds.</strong> Compilers take liberties in many places, such as zeroing arrays that are uninitialized, generating extra code that isn't strictly necessary, and (obviously) not performing any optimization past the trivial ones such as constant propagation. This leads to the next point...</p>\n<p><strong>Always look at the assembly.</strong> C and C++ are high level languages when it comes to the subtleties of performance. Many people even consider x86 assembly a high level language since each instruction is decomposed into possibly several micro-ops during decoding. You <em>cannot tell what the computer is doing just by looking at C++ code</em>. For example, depending on how you implemented <code>SquareMatrix</code>, the compiler may or may not be able to perform copy elision during optimization.</p>\n<p>Entering the somewhat more nuanced topics when testing for performance...</p>\n<p><strong>Make sure the compiler is actually generating loops.</strong> Using your example test code, g++ 4.7.2 doesn't actually generate loops with my implementation of <code>SquareMatrix</code> and <code>Vector</code>. I implemented them to initialize all components to <code>0.0</code>, so the compiler can statically determine that the values never change, and so only generates a single set of <code>mov</code> instructions instead of a loop. <strike>In my example code, I use <code>COMPILER_NOP</code> which (with gcc) is <code>__asm__ __volatile__(\"\":::)</code> inside the loop to prevent this (as compilers cannot predict side-effects from manual assembly, and so cannot elide the loop).</strike> Edit: I DO use <code>COMPILER_NOP</code> but since the output values from the functions are never used, the compiler is still able to remove the bulk of the work from the loop, and reduce the loop to this:</p>\n<pre><code>.L7\n   subl $1, %eax\n   jne .L7\n</code></pre>\n<p><em>I have corrected this by performing additional operations inside the loop.</em> The loop now assigns a value from the output to the inputs, preventing this optimization and forcing the loop to cover what was originally intended.</p>\n<p>To (finally) get around to answering your question: When I implemented the rest of what is needed to get your code to run, and verified by checking the assembly that loops are actually generated, <strong>the two functions execute in the same amount of time</strong>. <em>They even have nearly identical implementations in assembly</em>. </p>\n<p>Here's the assembly for the member function:</p>\n<pre><code>movsd   32(%rsp), %xmm7\nmovl    $100000, %eax\nmovsd   24(%rsp), %xmm5\nmovsd   8(%rsp), %xmm6\nmovapd  %xmm7, %xmm12\nmovsd   (%rsp), %xmm4\nmovapd  %xmm7, %xmm11\nmovapd  %xmm5, %xmm10\nmovapd  %xmm5, %xmm9\nmulsd   %xmm6, %xmm12\nmulsd   %xmm4, %xmm11\nmulsd   %xmm6, %xmm10\nmulsd   %xmm4, %xmm9\nmovsd   40(%rsp), %xmm1\nmovsd   16(%rsp), %xmm0\njmp .L7\n.p2align 4,,10\n.p2align 3\n.L12:\nmovapd  %xmm3, %xmm1\nmovapd  %xmm2, %xmm0\n.L7:\nmovapd  %xmm0, %xmm8\nmovapd  %xmm1, %xmm3\nmovapd  %xmm1, %xmm2\nmulsd   %xmm1, %xmm8\nmovapd  %xmm0, %xmm1\nmulsd   %xmm6, %xmm3\nmulsd   %xmm4, %xmm2\nmulsd   %xmm7, %xmm1\nmulsd   %xmm5, %xmm0\nsubl    $1, %eax\njne .L12\n</code></pre>\n<p>and the assembly for the static function:</p>\n<pre><code>movsd   32(%rsp), %xmm7\nmovl    $100000, %eax\nmovsd   24(%rsp), %xmm5\nmovsd   8(%rsp), %xmm6\nmovapd  %xmm7, %xmm12\nmovsd   (%rsp), %xmm4\nmovapd  %xmm7, %xmm11\nmovapd  %xmm5, %xmm10\nmovapd  %xmm5, %xmm9\nmulsd   %xmm6, %xmm12\nmulsd   %xmm4, %xmm11\nmulsd   %xmm6, %xmm10\nmulsd   %xmm4, %xmm9\nmovsd   40(%rsp), %xmm1\nmovsd   16(%rsp), %xmm0\njmp .L9\n.p2align 4,,10\n.p2align 3\n.L13:\nmovapd  %xmm3, %xmm1\nmovapd  %xmm2, %xmm0\n.L9:\nmovapd  %xmm0, %xmm8\nmovapd  %xmm1, %xmm3\nmovapd  %xmm1, %xmm2\nmulsd   %xmm1, %xmm8\nmovapd  %xmm0, %xmm1\nmulsd   %xmm6, %xmm3\nmulsd   %xmm4, %xmm2\nmulsd   %xmm7, %xmm1\nmulsd   %xmm5, %xmm0\nsubl    $1, %eax\njne .L13\n</code></pre>\n<p><strong>In conclusion:</strong> You probably need to tighten your code up a bit before you can tell whether the implementations differ on your system. Make sure your loops are actually being generated (look at the assembly) and see whether the compiler was able to elide the return value from the member function.</p>\n<p>If those things are true and you still see differences, can you post the implementations here for <code>SquareMatrix</code> and <code>Vector</code> so we can give you some more info?</p>\n<p>Full code, a makefile, and the generated assembly for my working example is <a href=\"https://gist.github.com/hathcock/a2d86b0863e8b55bc800\" rel=\"nofollow\">available as a GitHub gist</a>.</p>\n", "LastEditorUserId": "947030", "LastActivityDate": "2015-05-25T18:37:36.967", "Score": "2", "CreationDate": "2015-05-25T18:16:55.630", "ParentId": "30422729", "CommentCount": "3", "OwnerUserId": "947030", "LastEditDate": "2015-05-25T18:37:36.967"}, "30422729": {"ViewCount": "541", "Body": "<p>I have implemented two functions to perform the cross product of two Vectors (not std::vector), one is a member function and another is a global one, here is the key codes(additional parts are ommitted)</p>\n<pre><code>//for member function\ntemplate &lt;typename Scalar&gt;\nSquareMatrix&lt;Scalar,3&gt; Vector&lt;Scalar,3&gt;::outerProduct(const Vector&lt;Scalar,3&gt; &amp;vec3) const\n{\n    SquareMatrix&lt;Scalar,3&gt; result;\n    for(unsigned int i = 0; i &lt; 3; ++i)\n        for(unsigned int j = 0; j &lt; 3; ++j)\n            result(i,j) = (*this)[i]*vec3[j];\n    return result;\n}\n\n//for global function: Dim = 3\ntemplate&lt;typename Scalar, int Dim&gt;\nvoid outerProduct(const Vector&lt;Scalar, Dim&gt; &amp; v1 , const Vector&lt;Scalar, Dim&gt; &amp; v2, SquareMatrix&lt;Scalar, Dim&gt; &amp; m)\n{\n    for (unsigned int i=0; i&lt;Dim; i++)\n        for (unsigned int j=0; j&lt;Dim; j++)\n        {\n            m(i,j) = v1[i]*v2[j];\n        }\n}\n</code></pre>\n<p>They are almost the same except that one is a member function having a return value and another is a global function where the values calculated are  straightforwardly assigned to a square matrix, thus requiring no return value. <br>\nActually, I was meant to replace the member one by the global one to improve the performance, since the first one involes copy operations. The strange thing, however, is that <strong>the time cost by the global function is almost two times longer than the member one.</strong> Furthermore, I find that the execution of</br></p>\n<pre><code>m(i,j) = v1[i]*v2[j]; // in global function\n</code></pre>\n<p>requires much more time than that of</p>\n<pre><code>result(i,j) = (*this)[i]*vec3[j]; // in member function\n</code></pre>\n<p>So the question is, how does this performance difference between member and global function arise? </p>\n<p>Anyone can tell the reasons? <br>\nHope I have presented my question clearly, and sorry to my poor english!</br></p>\n<p>//----------------------------------------------------------------------------------------<br>\nMore information added:<br>\nThe following is the codes I use to test the performance:</br></br></p>\n<pre><code>    //the codes below is in a loop\n    Vector&lt;double, 3&gt; vec1;\n    Vector&lt;double, 3&gt; vec2;\n    Timer timer;\n    timer.startTimer();\n    for (unsigned int i=0; i&lt;100000; i++)\n    {\n        SquareMatrix&lt;double,3&gt; m = vec1.outerProduct(vec2);\n    }\n    timer.stopTimer();\n    std::cout&lt;&lt;\"time cost for member function: \"&lt;&lt; timer.getElapsedTime()&lt;&lt;std::endl;\n\n    timer.startTimer();\n    SquareMatrix&lt;double,3&gt; m;\n    for (unsigned int i=0; i&lt;100000; i++)\n    {\n        outerProduct(vec1, vec2, m);\n    }\n    timer.stopTimer();\n    std::cout&lt;&lt;\"time cost for global function: \"&lt;&lt; timer.getElapsedTime()&lt;&lt;std::endl;\n    std::system(\"pause\");\n</code></pre>\n<p>and the result captured:<br>\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/MtPLB.png\"/></br></p>\n<p>You can see that the member funtion is almost twice faster than the global one.<br><br>\nAdditionally, my project is built upon a 64bit windows system, and the codes are in fact used to generate the static lib files based on the Scons construction tools, along with vs2010 project files produced.</br></br></p>\n<p>I have to remind that <strong>the strange performance difference only occurs in a release version, while in a debug build type, the global function is almost five times faster than the member one.(about 0.10s vs 0.02s)</strong></p>\n", "Title": "Performance difference between member function and global function in release version", "CreationDate": "2015-05-24T10:57:24.743", "LastActivityDate": "2015-05-27T08:54:17.480", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-25T13:09:16.983", "LastEditorUserId": "4891563", "Id": "30422729", "Score": "3", "OwnerUserId": "4891563", "Tags": "<c++><performance><global><member-functions>", "AnswerCount": "3"}});