post_cb({"bq_ids": {"n4140": {"so_23043251_23043357_0": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_23043251_23043357_1": {"length": 15, "quality": 0.9375, "section_id": 5817}}, "n3337": {"so_23043251_23043357_0": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_23043251_23043357_1": {"length": 15, "quality": 0.9375, "section_id": 5588}}, "n4659": {"so_23043251_23043357_0": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_23043251_23043357_1": {"length": 14, "quality": 0.875, "section_id": 7278}}}, "23043251": {"ViewCount": "220", "Body": "<p>I have a program which spawns multiple threads that may write the exact same value to the exact same memory location:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>std::vector&lt;int&gt; vec(32, 1); // Initialize vec with 32 times 1\nstd::vector&lt;std::thread&gt; threads;\nfor (int i = 0 ; i &lt; 8 ; ++i)\n{\n    threads.emplace_back([&amp;vec]()\n    {\n        for (std::size_t j = 0 ; j &lt; vec.size() ; ++j)\n        {\n            vec[j] = 0;\n        }\n    });\n}\n\nfor (auto&amp; thrd: threads)\n{\n    thrd.join();\n}\n\n// Read vec values\n</code></pre>\n<p>In this simplified code, all the threads may try to write the exact same value to the same memomry location in <code>vec</code>. Is this a data race likely to trigger undefined behavior, or is it safe since the values are never read before all the threads are joined again?</p>\n<p>If there is a potentially hazardous data race, will using a <code>std::vector&lt;std::atomic&lt;int&gt;&gt;</code> instead with <code>std::memory_order_relaxed</code> stores instead be enough to prevent the data races?</p>\n", "AcceptedAnswerId": "23043357", "Title": "Parallel writes of a same value", "CreationDate": "2014-04-13T13:21:21.937", "Id": "23043251", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-04-14T10:48:49.483", "Score": "3", "OwnerUserId": "1364752", "Tags": "<c++><multithreading><c++11><race-condition><memory-model>", "AnswerCount": "3"}, "23043357": {"Id": "23043357", "PostTypeId": "2", "Body": "<p>Language-lawyer answer, [intro.multithread] n3485</p>\n<blockquote>\n<p id=\"so_23043251_23043357_0\"><sup>21</sup> The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads,\n  at least one of which is not atomic, and neither happens before the other. Any such data race results in\n  undefined behavior.</p>\n<p id=\"so_23043251_23043357_1\"><sup>4</sup> Two expression evaluations <em>conflict</em> if one of them modifies a memory location and the other one\n  accesses or modifies the same memory location.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_23043251_23043357_2\">will using a <code>std::vector&lt;std::atomic&lt;int&gt;&gt;</code> instead with <code>std::memory_order_relaxed</code> stores instead be enough to prevent the data races?</p>\n</blockquote>\n<p>Yes. Those accesses are atomic, and there's a <em>happens-before</em> relationship introduced via the joining of the threads. Any subsequent read from the thread spawning those workers (which is synchronized via <code>.join</code>) is safe and defined.</p>\n</hr>", "LastActivityDate": "2014-04-13T13:31:34.010", "Score": "4", "CreationDate": "2014-04-13T13:31:34.010", "ParentId": "23043251", "CommentCount": "0", "OwnerUserId": "420683"}, "23058157": {"Id": "23058157", "PostTypeId": "2", "Body": "<p>It is a data race and compilers will eventually become smart enough to miscompile the code if they are not already.\nSee <a href=\"https://www.usenix.org/legacy/events/hotpar11/tech/final%5ffiles/Boehm.pdf\" rel=\"nofollow\">How to miscompile programs with \"benign\" data races</a> section 2.4 for why writes of the same value break the code.</p>\n", "LastActivityDate": "2014-04-14T10:48:49.483", "Score": "0", "CreationDate": "2014-04-14T10:48:49.483", "ParentId": "23043251", "CommentCount": "1", "OwnerUserId": "3484570"}, "23043451": {"Id": "23043451", "PostTypeId": "2", "Body": "<p>Implementation detail answer:</p>\n<p>While the language standard classifies this as undefined behavior, you can actually feel quite safe as long as you are really writing the same data.</p>\n<p>Why? The hardware sequentializes accesses to the same memory cell. The only thing that can go wrong is when several memory cells are written at the same time, because then you have no guarantee by the hardware that the accesses to several cells are sequentialized in the same way. For example, if one process writes <code>0x0000000000000000</code>, and another writes <code>0xffffffffffffffff</code>, your hardware may decide to sequentialize the accesses to the different bytes differently, resulting in something like <code>0x00000000ffffffff</code>.</p>\n<p>However, if the data written by both processes is the same, then there is no noticeable difference between the two possible serializations, the result is deterministic.</p>\n<p>Modern hardware does not handle memory accesses in a byte by byte fashion, instead, CPUs communicate with the main memory in terms of cache lines, and cores can usually communicate with their caches in terms of 8-byte words. As such, setting a properly aligned pointer is an atomic operation which can be relied on to implement lockfree algorithms. This has been exploited in the Linux kernel before more powerful atomic operations became available. C++ formalizes this in the form of <code>atomic&lt;&gt;</code> types, adding support for the more high level hardware features like write after read, atomic increments and such.</p>\n<p>But, of course, if you rely on your hardware details, you really should know what you are doing before you do it. Otherwise stick to language features like the <code>atomic&lt;&gt;</code> types to ensure proper operations and avoid UB.</p>\n", "LastEditorUserId": "2445184", "LastActivityDate": "2014-04-13T13:47:25.857", "Score": "0", "CreationDate": "2014-04-13T13:39:00.273", "ParentId": "23043251", "CommentCount": "4", "LastEditDate": "2014-04-13T13:47:25.857", "OwnerUserId": "2445184"}});