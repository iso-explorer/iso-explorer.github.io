post_cb({"bq_ids": {"n4140": {"so_17914630_17914630_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 1204}}, "n3337": {"so_17914630_17914630_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 1202}}, "n4659": {"so_17914630_17914630_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 1284}}}, "17914907": {"Id": "17914907", "PostTypeId": "2", "Body": "<p>The <code>atomic_compare_exchange_XXX</code> functions update their \"expected\" argument with the observed value, so your loop is the same as:</p>\n<pre><code>expected = current;\ndo {\n    desired = f(expected);\n} while (!current.atomic_compare_exchange_weak(expected, desired));\n</code></pre>\n<p>If the desired value is <em>independent</em> of the expected value, this loop becomes:</p>\n<pre><code>desired = ...;\nexpected = current;\nwhile (current.atomic_compare_exchange_weak(expected, desired))\n  ;\n</code></pre>\n<p>Let's add some semantics. Let's say that several threads are running this simultaneously. In each case <code>desired</code> is a non-zero ID for the current thread, and <code>current</code> is used to provide mutual exclusion to ensure that some thread performs a cleanup task. We don't really care which one, but we want to be sure that some thread gets access (and maybe other threads can observe the winner by reading it's ID from <code>current</code>).</p>\n<p>We can achieve the desired semantics with:</p>\n<pre><code>expected = 0;\nif (current.atomic_compare_exchange_strong(expected, this_thread)) {\n  // I'm the winner\n  do_some_cleanup_thing();\n  current = 0;\n} else {\n  std::cout &lt;&lt; expected &lt;&lt; \" is the winner\\n\";\n}\n</code></pre>\n<p>This is a case where <code>atomic_compare_exchange_weak</code> would require a loop to accomplish the same effect as <code>atomic_compare_exchange_strong</code>, since spurious failures are possible:</p>\n<pre><code>expected = 0;\nwhile(!current.atomic_compare_exchange_weak(expected, this_thread)\n       &amp;&amp; expected == 0))\n  ;\nif (expected == this_thread) {\n  do_some_cleanup_thing();\n  current = 0;\n} else {\n  std::cout &lt;&lt; expected &lt;&lt; \" is the winner\\n\";\n}\n</code></pre>\n<p>The standard suggests that implementations may provide more efficient code in this case for <code>atomic_compare_exchange_strong</code> than looping with <code>..._weak</code> (\u00a729.6.5/25 [atomics.types.operations.req]).</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-07-29T04:16:06.553", "Score": "9", "CreationDate": "2013-07-29T01:47:41.743", "ParentId": "17914630", "CommentCount": "0", "OwnerUserId": "923854", "LastEditDate": "2013-07-29T04:16:06.553"}, "17914630": {"ViewCount": "2942", "Body": "<p>There are two atomic CAS operations in C++11: <code>atomic_compare_exchange_weak</code> and <code>atomic_compare_exchange_strong</code>.</p>\n<p>According to <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_17914630_17914630_0\">The weak forms of the functions are allowed to fail spuriously, that\n  is, act as if *obj != *expected even if they are equal. When a\n  compare-and-exchange is in a loop, the weak version will yield better\n  performance on some platforms. <strong>When a weak compare-and-exchange would\n  require a loop and a strong one would not, the strong one is\n  preferable</strong>.</p>\n</blockquote>\n<p>The following is an example for using the <em>weak</em> version, I think:</p>\n<pre><code>do {\n    expected = current.value();\n    desired = f(expected);\n} while (!current.atomic_compare_exchange_weak(expected, desired));\n</code></pre>\n<p>Could someone give an example where the compare-and-exchange is not in a loop so that the <em>strong</em> version is preferable?</p>\n", "AcceptedAnswerId": "17914907", "Title": "When should std::atomic_compare_exchange_strong be used?", "CreationDate": "2013-07-29T01:05:05.420", "Id": "17914630", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-07-29T04:16:06.553", "Score": "9", "OwnerUserId": "571470", "Tags": "<c++><multithreading><c++11><atomic><compare-and-swap>", "AnswerCount": "1"}});