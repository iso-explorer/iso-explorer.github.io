post_cb({"16489692": {"Id": "16489692", "PostTypeId": "2", "Body": "<p>Whenever you are not sure about memory leaks in your code, you can use <a href=\"http://valgrind.org/\" rel=\"nofollow\">valgrind</a> <code>valgrind --tool=memcheck</code> to check for them, but be sure to compile the code without any optimization and in full debug mode (e.g. \"g++ -g\").</p>\n<p>Here is the output for your program:</p>\n<pre><code>=29667== Memcheck, a memory error detector\n==29667== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.\n==29667== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info\n==29667== Command: ./main\n==29667== \n==29667== Invalid free() / delete / delete[]\n==29667==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)\n==29667==    by 0x4006AB: main (main.cpp:7)\n==29667==  Address 0x7fefffd0c is on thread 1's stack\n==29667== \n==29667== \n==29667== HEAP SUMMARY:\n==29667==     in use at exit: 4 bytes in 1 blocks\n==29667==   total heap usage: 1 allocs, 1 frees, 4 bytes allocated\n==29667== \n==29667== LEAK SUMMARY:\n==29667==    definitely lost: 4 bytes in 1 blocks\n==29667==    indirectly lost: 0 bytes in 0 blocks\n==29667==      possibly lost: 0 bytes in 0 blocks\n==29667==    still reachable: 0 bytes in 0 blocks\n==29667==         suppressed: 0 bytes in 0 blocks\n==29667== Rerun with --leak-check=full to see details of leaked memory\n==29667== \n==29667== For counts of detected and suppressed errors, rerun with: -v\n==29667== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n</code></pre>\n<p>Your code looses 4 bytes at exit(). </p>\n<p>Here is the list of stuff you can do with memcheck, from the tool's <a href=\"http://valgrind.org/docs/manual/mc-manual.html\" rel=\"nofollow\">website</a></p>\n<blockquote>\n<p id=\"so_16489623_16489692_0\">Memcheck is a memory error detector. It can detect the following\n  problems that are common in C and C++ programs.</p>\n<ul>\n<li><p id=\"so_16489623_16489692_1\">Accessing memory you shouldn't, e.g. overrunning and \n  underrunning heap blocks, overrunning the top of the stack, and accessing memory\n  after it has been freed.</p></li>\n<li><p id=\"so_16489623_16489692_2\">Using undefined values, i.e. values that have not been initialised, \n  or that have been derived from other undefined values.</p></li>\n<li><p id=\"so_16489623_16489692_3\">Incorrect freeing of heap memory, such as double-freeing heap blocks, \n  or mismatched use of malloc/new/new[] versus\n  free/delete/delete[]</p>\n<ul>\n<li><p id=\"so_16489623_16489692_4\">Overlapping src and dst pointers in memcpy and related functions.</p></li>\n<li><p id=\"so_16489623_16489692_5\">Memory leaks.</p></li>\n</ul></li>\n</ul>\n<p id=\"so_16489623_16489692_6\"><strong>Problems like these can be difficult to find by other means</strong>, often\n  remaining undetected for long periods, then causing occasional,\n  difficult-to-diagnose crashes.</p>\n</blockquote>\n", "LastEditorUserId": "704028", "LastActivityDate": "2013-05-10T20:09:00.747", "Score": "4", "CreationDate": "2013-05-10T19:40:13.173", "ParentId": "16489623", "CommentCount": "5", "OwnerUserId": "704028", "LastEditDate": "2013-05-10T20:09:00.747"}, "16489637": {"Id": "16489637", "PostTypeId": "2", "Body": "<p>It not only leaks the dynamically allocated <code>int</code> but also has undefined behaviour, because you can't <code>delete</code> an object that wasn't allocated with <code>new</code> (\u00a75.3.5/2).</p>\n<blockquote>\n<p id=\"so_16489623_16489637_0\">the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined.</p>\n</blockquote>\n<p>Since the object denoted by <code>y</code> was not allocated with a <em>new-expression</em>, you cannot use <code>delete</code> to destroy it. Its lifetime is governed by its scope.</p>\n", "LastActivityDate": "2013-05-10T19:36:51.870", "CommentCount": "9", "CreationDate": "2013-05-10T19:36:51.870", "ParentId": "16489623", "Score": "8", "OwnerUserId": "150634"}, "16489649": {"Id": "16489649", "PostTypeId": "2", "Body": "<p>Yes, it does indeed cause a memory leak because the subsequent assignment of <code>pt</code> causes you to lose the previous assignment that contained the memory. If you had called <code>delete pt</code> before that, it would have been fine.</p>\n", "LastActivityDate": "2013-05-10T19:37:21.767", "CommentCount": "0", "CreationDate": "2013-05-10T19:37:21.767", "ParentId": "16489623", "Score": "0", "OwnerUserId": "701092"}, "16489641": {"Id": "16489641", "PostTypeId": "2", "Body": "<p>Yes.</p>\n<p>The moment you lost the pointer to the <code>new</code> <code>int</code> you leaked</p>\n<pre><code>pt = &amp;y; // Here the memory allocated is not reachable now and can not be deleted \n</code></pre>\n<p>And this is UB</p>\n<pre><code>delete pt;  // pt is pointing to automaticaly allocated memory now. You can't delete that.\n</code></pre>\n", "LastActivityDate": "2013-05-10T19:37:03.470", "CommentCount": "11", "CreationDate": "2013-05-10T19:37:03.470", "ParentId": "16489623", "Score": "0", "OwnerUserId": "6271971"}, "bq_ids": {"n4140": {"so_16489623_16489637_0": {"length": 23, "quality": 1.0, "section_id": 6106}}, "n3337": {"so_16489623_16489637_0": {"length": 23, "quality": 1.0, "section_id": 5872}}, "n4659": {"so_16489623_16489637_0": {"length": 23, "quality": 1.0, "section_id": 7603}}}, "16489623": {"ViewCount": "177", "Body": "<p>I am curious if this code causes memory\nleak probably due to the fact that I reassign\nthe pointer at line 3 before deleting it at line 4??</p>\n<p>Thanks.</p>\n<pre><code>1. int y = 12;\n2. int *pt = new int;\n3. pt = &amp;y;\n4. delete pt; \n</code></pre>\n", "AcceptedAnswerId": "16489637", "Title": "Does this code cause memory leak?", "CreationDate": "2013-05-10T19:35:35.750", "Id": "16489623", "CommentCount": "5", "LastEditDate": "2013-05-10T20:30:52.500", "PostTypeId": "1", "LastEditorUserId": "699233", "LastActivityDate": "2013-05-10T20:30:52.500", "Score": "2", "OwnerUserId": "2054339", "Tags": "<c++><memory-leaks>", "AnswerCount": "6"}, "16489646": {"Id": "16489646", "PostTypeId": "2", "Body": "<p>It should crash, because you assing a stack adress to your pointer and then delete it. At least it's undefined what happens.</p>\n", "LastActivityDate": "2013-05-10T19:37:14.987", "CommentCount": "0", "CreationDate": "2013-05-10T19:37:14.987", "ParentId": "16489623", "Score": "0", "OwnerUserId": "2282011"}, "16489640": {"Id": "16489640", "PostTypeId": "2", "Body": "<p>It would cause a memory leak if it didn't first likely cause a crash.</p>\n<p>You shouldn't delete an object that has 'automatic' storage.</p>\n", "LastActivityDate": "2013-05-10T19:36:59.343", "CommentCount": "0", "CreationDate": "2013-05-10T19:36:59.343", "ParentId": "16489623", "Score": "2", "OwnerUserId": "985032"}});