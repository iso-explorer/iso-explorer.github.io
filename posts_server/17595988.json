post_cb({"bq_ids": {"n4140": {"so_17595988_17603338_0": {"length": 69, "quality": 0.9452054794520548, "section_id": 286}}, "n3337": {"so_17595988_17603338_0": {"length": 69, "quality": 0.9452054794520548, "section_id": 277}}, "n4659": {"so_17595988_17603338_0": {"length": 69, "quality": 0.9452054794520548, "section_id": 293}}}, "17596028": {"Id": "17596028", "PostTypeId": "2", "Body": "<p>The parameter unpack <code>...I</code> is <em>deduced</em> by the compiler from the function argument. It is called <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Ftemplate_argument_deduction.htm\">template argument deduction</a>.</p>\n<p>Here are some simple, yet useful examples:</p>\n<pre><code>template&lt;typename T&gt; \nvoid f(T const&amp;) {}\n\nf(10);   //T is deduced as int\nf(10.0); //T is deduced as double\nf(\"10\"); //T is deduced as char[3]\n</code></pre>\n<p>Many functions from the standard library are function template, and often the template argument is deduced. Here is one example:</p>\n<pre><code>std::vector&lt;int&gt; vi;\nstd::vector&lt;std::string&gt; vs;\n//...\nstd::sort(vi.begin(), vi.end()); //template argument deduction\nstd::sort(vs.begin(), vs.end()); //template argument deduction\n</code></pre>\n<p>Here <code>std::sort</code> is a function template but as you can see, we don't explicitly pass the template argument. It is because the template argument is deduced by compiler itself, from the function arguments.</p>\n<p>Hope that helps.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2013-07-11T14:32:44.563", "Score": "6", "CreationDate": "2013-07-11T14:25:10.423", "ParentId": "17595988", "CommentCount": "2", "OwnerUserId": "415784", "LastEditDate": "2013-07-11T14:32:44.563"}, "17603239": {"Id": "17603239", "PostTypeId": "2", "Body": "<p>To add to nawaz answer: a template parameter that cannot be deduced must be provided and the template parameters that are provided must be in order of the definition. This means that if a template parameter is likely to require provision, it's best to put it first in the list of template parameters. For example</p>\n<pre><code>template&lt;typename A, typename B&gt; A foo(B);\ntemplate&lt;typename B, typename A&gt; A bar(B);\n\nauto x = foo&lt;int&gt;(0.0);       // A=int, B=double;\nauto y = foo&lt;int,double&gt;(0);  // A=int, B=double, argument implicitly cast to double\nauto z = bar&lt;int&gt;(0);         // error: cannot deduce A\nauto w = bar&lt;int,double&gt;(0);  // A=double, B=int;\n</code></pre>\n<p>In both cases <code>B</code> can be deduced (from the function argument type), but <code>A</code> cannot. So <code>foo</code> is more convenient, as only one template parameter must be provided. With <code>bar</code>, the first template parameter is deducible, but not the second. Hence, both must be provided. (just to clarify that changning <code>auto</code> to <code>double</code> or <code>int</code> makes no difference w.r.t. the problem at hand.)</p>\n", "LastActivityDate": "2013-07-11T20:48:58.560", "CommentCount": "0", "CreationDate": "2013-07-11T20:48:58.560", "ParentId": "17595988", "Score": "2", "OwnerUserId": "1023390"}, "17603338": {"Id": "17603338", "PostTypeId": "2", "Body": "<p>It's allowed to specify only part of parameters to function call(first ones) if it's possible to deduce other in compile time. Example:</p>\n<pre><code>template&lt;typename Ret, typename Arg&gt;\nRet cast(Arg x){\n    return x;\n}\n\ncast&lt;double&gt;(5);\n</code></pre>\n<p>Actually you may even compile this code:</p>\n<pre><code>template&lt;int...&gt;\nstruct Indices {};\n\ntemplate&lt;int J, int ...I&gt;\nvoid foo(Indices&lt;I...&gt;) {}\n\nint main(int argc, char **argv)\n{\n  foo&lt;2,3&gt;(Indices&lt;3,4,5&gt;()); //ok 2,3,4,5 starts with 2,3\n  return 0;\n}\n</code></pre>\n<p>But not this one:</p>\n<pre><code>template&lt;int...&gt;\nstruct Indices {};\n\ntemplate&lt;int J, int ...I&gt;\nvoid foo(Indices&lt;I...&gt;) {}\n\nint main(int argc, char **argv)\n{\n  foo&lt;2,1&gt;(Indices&lt;3,4,5&gt;()); //no way to make x,3,4,5 start with 2,1\n  return 0;\n}\n</code></pre>\n<p>See \u00a714.1.8 part 3 of C++11 standard(N3242 draft).</p>\n<blockquote>\n<p id=\"so_17595988_17603338_0\"><strong>Trailing template arguments that can be deduced (14.8.2) or obtained\n  from default template-arguments may be omitted from the list of\n  explicit template-arguments</strong>. A trailing template parameter pack\n  (14.5.3) not otherwise deduced will be deduced to an empty sequence of\n  template arguments. If all of the template arguments can be deduced,\n  they may all be omitted; in this case, the empty template argument\n  list &lt;&gt; itself may also be omitted. In contexts where deduction is\n  done and fails, or in contexts where deduction is not done, if a\n  template argument list is speci\ufb01ed and it, along with any default\n  template arguments, identi\ufb01es a single function template\n  specialization, then the template-id is an lvalue for the function\n  template specialization.</p>\n</blockquote>\n", "LastEditorUserId": "768110", "LastActivityDate": "2013-07-11T21:14:53.207", "Score": "2", "CreationDate": "2013-07-11T20:55:28.127", "ParentId": "17595988", "CommentCount": "0", "OwnerUserId": "768110", "LastEditDate": "2013-07-11T21:14:53.207"}, "17595988": {"ViewCount": "183", "Body": "<p>The following code compiles:</p>\n<pre><code>template&lt;int...&gt;\nstruct Indices {};\n\ntemplate&lt;int J, int ...I&gt;\nvoid foo(Indices&lt;I...&gt;) {}\n\nint main(int argc, char **argv)\n{\n  foo&lt;2&gt;(Indices&lt;3,4,5&gt;()); //why does this work?\n  return 0;\n}\n</code></pre>\n<p>In the function call, it seems to me that the <code>J</code> parameter becomes <code>2</code> and the <code>...I</code> parameter becomes <code>3,4,5</code>?</p>\n<p>But why does this work? I only specified <code>2</code> at <code>foo&lt;2&gt;</code> meaning I specified <code>J</code> as <code>2</code> and <code>...I</code> as nothing. Why can I still specify <code>...I</code> through the <code>Indices</code> argument? What template mechanism is being used here?</p>\n<p><strong>Update:</strong> The current answer does not explain why I can have one argument not deduced (explicitly specified) but the others deduced. When exactly does this work? I hope I'm not relying on undefined behavior. Does the standard allow what I'm doing above?</p>\n", "AcceptedAnswerId": "17603338", "Title": "Why does this function template call work?", "CreationDate": "2013-07-11T14:23:43.263", "Id": "17595988", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-11T15:03:26.237", "LastEditorUserId": "2521520", "LastActivityDate": "2013-07-11T21:14:53.207", "Score": "2", "OwnerUserId": "2521520", "Tags": "<c++><templates><c++11>", "AnswerCount": "3"}});