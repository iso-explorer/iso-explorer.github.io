post_cb({"17130607": {"CommentCount": "0", "AcceptedAnswerId": "17130847", "CreationDate": "2013-06-16T05:54:10.147", "LastActivityDate": "2013-06-16T08:03:34.903", "PostTypeId": "1", "ViewCount": "1742", "FavoriteCount": "6", "Title": "Overload resolution with ref-qualifiers", "Id": "17130607", "Score": "19", "Body": "<p>While working with ref-qualified function overloads, I'm getting different results from <em>GCC (4.8.1)</em> and <em>Clang (2.9 and trunk)</em>. Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct foo\n{\n    int&amp; bar() &amp;\n    {\n        std::cout &lt;&lt; \"non-const lvalue\" &lt;&lt; std::endl;\n        return _bar;\n    }\n    //~ int&amp;&amp; bar() &amp;&amp;\n    //~ {\n    //~     std::cout &lt;&lt; \"non-const rvalue\" &lt;&lt; std::endl;\n    //~     return std::move(_bar);\n    //~ }\n    int const&amp; bar() const &amp;\n    {\n        std::cout &lt;&lt; \"const lvalue\" &lt;&lt; std::endl;\n        return _bar;\n    }\n    int const&amp;&amp; bar() const &amp;&amp;\n    {\n        std::cout &lt;&lt; \"const rvalue\" &lt;&lt; std::endl;\n        return std::move(_bar);\n    }\n\n    int _bar;\n};\n\nint main(int argc, char** argv)\n{\n    foo().bar();\n}\n</code></pre>\n<p><em>Clang</em> compiles it and outputs <code>\"const rvalue\"</code>, while <em>GCC</em> thinks this is an ambiguous call with the two const-qualified functions both being best viable candidates. If I provide all 4 overloads, then both compilers output <code>\"non-const rvalue\"</code>.</p>\n<p>I would like to know which compiler <em>--if any--</em> is doing the right thing, and what are the relevant standard pieces in play.</p>\n<p><em><strong>Note:</strong></em> The reason this actually matters is that the real code declares both const-qualified functions as <code>constexpr</code>. Of course, there is no output to <code>std::cout</code> and <code>static_cast</code> is used instead of <code>std::move</code>, so that they are valid <code>constexpr</code> definitions. And since in <em>C++11</em> <code>constexpr</code> still implies <code>const</code>, the overload commented out in the sample code cannot be provided as it would redefine the const-qualified rvalue overload.</p>\n", "Tags": "<c++><c++11><overloading><language-lawyer><ref-qualifier>", "OwnerUserId": "927034", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17130607_17130847_5": {"section_id": 639, "quality": 1.0, "length": 21}, "so_17130607_17130847_2": {"section_id": 568, "quality": 1.0, "length": 5}, "so_17130607_17130847_1": {"section_id": 568, "quality": 1.0, "length": 6}, "so_17130607_17130847_4": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}, "so_17130607_17130847_0": {"section_id": 568, "quality": 0.875, "length": 7}, "so_17130607_17130847_3": {"section_id": 568, "quality": 1.0, "length": 8}}, "n3337": {"so_17130607_17130847_5": {"section_id": 629, "quality": 1.0, "length": 21}, "so_17130607_17130847_2": {"section_id": 559, "quality": 1.0, "length": 5}, "so_17130607_17130847_1": {"section_id": 559, "quality": 1.0, "length": 6}, "so_17130607_17130847_4": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}, "so_17130607_17130847_0": {"section_id": 559, "quality": 0.875, "length": 7}, "so_17130607_17130847_3": {"section_id": 559, "quality": 1.0, "length": 8}}, "n4659": {"so_17130607_17130847_3": {"section_id": 591, "quality": 1.0, "length": 8}, "so_17130607_17130847_5": {"section_id": 667, "quality": 1.0, "length": 21}, "so_17130607_17130847_2": {"section_id": 591, "quality": 1.0, "length": 5}, "so_17130607_17130847_4": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}, "so_17130607_17130847_0": {"section_id": 591, "quality": 0.875, "length": 7}, "so_17130607_17130847_1": {"section_id": 591, "quality": 1.0, "length": 6}}}, "17130847": {"ParentId": "17130607", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Firstly, the implicit object parameter is treated as a normal parameter as per 13.3.1.4:</p>\n<blockquote>\n<p id=\"so_17130607_17130847_0\">For non-static member functions, the type of the implicit object parameter is</p>\n<p id=\"so_17130607_17130847_1\">\u2014 \u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</p>\n<p id=\"so_17130607_17130847_2\">\u2014 \u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</p>\n<p id=\"so_17130607_17130847_3\">where X is the class of which the function is a member and cv is the cv-qualification on the member\n  function declaration.</p>\n</blockquote>\n<p>So what you are asking is equivalent to the following:</p>\n<pre><code>void bar(foo&amp;);\nvoid bar(foo&amp;&amp;);\nvoid bar(const foo&amp;);\nvoid bar(const foo&amp;&amp;);\n\nint main()\n{\n    bar(foo());\n}\n</code></pre>\n<p>The expression <code>foo()</code> is a class prvalue.</p>\n<p>Secondly, the non-const lvalue reference version is not viable, as a prvalue cannot bind to it.</p>\n<p>This leaves us with three viable functions for overload resolution.</p>\n<p>Each has a single implicit object parameter (<code>const foo&amp;</code>, <code>foo&amp;&amp;</code> or <code>const foo&amp;&amp;</code>), so we must rank these three to determine the best match.</p>\n<p>In all three case it is a <em>directly bound</em> reference binding.  This is described in declarators/initialization (8.5.3).</p>\n<p>The ranking of the three possible bindings (<code>const foo&amp;</code>, <code>foo&amp;&amp;</code> and <code>const foo&amp;&amp;</code>) is described in 13.3.3.2.3:</p>\n<blockquote>\n<p id=\"so_17130607_17130847_4\">Standard conversion sequence <strong>S1 is a better conversion sequence than standard conversion sequence S2</strong> if</p>\n<ul>\n<li>S1 and S2 are reference bindings and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier [this exception doesn't apply here, they all have ref-qualifiers], and <strong>S1 binds an rvalue reference to an rvalue</strong> [a class prvalue is an rvalue] <strong>and S2 binds an lvalue reference</strong>.</li>\n</ul>\n</blockquote>\n<p>This means that both <code>foo&amp;&amp;</code> and <code>const foo&amp;&amp;</code> are better then <code>const foo&amp;</code>.</p>\n<blockquote id=\"so_17130607_17130847_5\">\n<ul>\n<li>S1 and S2 are reference bindings, and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by <strong>S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers</strong>.</li>\n</ul>\n</blockquote>\n<p>This means that <code>foo&amp;&amp;</code> is better than <code>const foo&amp;&amp;</code>.</p>\n<p>So Clang is right, and it is a bug in GCC.  The overload ranking for <code>foo().bar()</code> is as follows:</p>\n<pre><code>struct foo\n{\n    int&amp;&amp; bar() &amp;&amp;;             // VIABLE - BEST  (1)\n    int const&amp;&amp; bar() const &amp;&amp;; // VIABLE -       (2)\n    int const&amp; bar() const &amp;;   // VIABLE - WORST (3)\n    int&amp; bar() &amp;;               // NOT VIABLE\n\n    int _bar;\n};\n</code></pre>\n<p>The bug in GCC seems to apply purely to implicit object parameters (with <code>ref-qualifiers</code>), for a normal parameter it seems to get the ranking correct, at least in 4.7.2.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-06-16T08:03:34.903", "Id": "17130847", "Score": "27", "CreationDate": "2013-06-16T06:37:38.333", "LastActivityDate": "2013-06-16T08:03:34.903"}});