post_cb({"24874210": {"ParentId": "24873891", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In your first case, the string literal is decaying to a pointer to a <em>const char</em>. Although <code>s1</code> really should be <code>const char *</code>, several compiler allow the other form as an extension:</p>\n<pre><code>const char* s1 = \"hello world\" ;\n</code></pre>\n<p>A sting literal is an <em>array of <code>const char</code></em>, we can see this from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>2.14.5</code> <em>String literals</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24873891_24874210_0\">Ordinary string literals and UTF-8 string literals are also referred\n  to as narrow string literals. A narrow string literal has <strong>type \u201carray\n  of <em>n</em> <code>const char</code>\u201d,</strong> where <em>n</em> is the size of the string as defined below,\n  and has static storage duration (3.7).</p>\n</blockquote>\n<p>The conversion of an array to pointer is covered in section <code>4.2</code> <em>Array-to-pointer conversion</em> which says:</p>\n<blockquote>\n<p id=\"so_24873891_24874210_1\">[...] an expression that has type \u2018\u2018array of type\u2019\u2019 is converted to an\n  expression with type \u2018\u2018pointer to type\u2019\u2019 that points to the initial\n  element of the array object and is not an lvalue.[...]</p>\n</blockquote>\n<p>Your other cases do not work because a scalar which can be an arithmetic type, enumeration types or a pointer type can only be initialized with a single element inside braces this is covered in the draft C++ standard section <s><code>5.17</code> <em>Assignment and compound assignment operators</em></s> <code>8.5.1</code> <em>List-initialization</em> paragraph <em>3</em> which says:</p>\n<blockquote>\n<p id=\"so_24873891_24874210_2\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n</blockquote>\n<p>and then enumerates the different cases the only that applies to the right hand side for this case is the following bullet:</p>\n<blockquote>\n<p id=\"so_24873891_24874210_3\">Otherwise, if the initializer list has a single element of type E and\n  either T is not a reference type or its referenced type is\n  reference-related to E, the object or reference is initialized from\n  that element; if a narrowing conversion (see below) is required to\n  convert the element to T, the program is ill-formed.</p>\n</blockquote>\n<p>which requires the list to have a single element, otherwise the final bullet applies:</p>\n<blockquote>\n<p id=\"so_24873891_24874210_4\">Otherwise, the program is ill-formed.</p>\n</blockquote>\n<p>In your two cases even if you reduced the initializer to one variable, the types are incorrect \n<code>h</code> is a char and <code>2</code> is an <code>int</code> which won't convert to a pointer.</p>\n<p>The assignment could be made to work by assigning the results to an array such as the following:</p>\n<pre><code>  char s1[] = { 'h', 'e', 'l', 'l', 'o',' ', 'w', 'o', 'r', 'l', 'd' } ;\n  int  a[]  = { 2, 3, 1, 45, 6 } ;\n</code></pre>\n<p>This would be covered in section <code>8.5.1</code> <em>Aggregates</em> which says:</p>\n<blockquote>\n<p id=\"so_24873891_24874210_5\">An array of unknown size initialized with a brace-enclosed\n  initializer-list containing n initializer-clauses, where n shall be\n  greater than zero, is defined as having n elements (8.3.4). [ Example:</p>\n<pre><code>int x[] = { 1, 3, 5 };\n</code></pre>\n<p id=\"so_24873891_24874210_6\">declares and initializes x as a one-dimensional array that has three\n  elements since no size was specified and there are three initializers.\n  \u2014end example ] An empty initializer list {} shall not be used as the\n  initializer-clause for an array of unknown bound.104</p>\n</blockquote>\n<p><b>Note:</b></p>\n<p>It is incorrect to say that a brace-init-list is not defined for pointers, it is perfectly usable for pointers:</p>\n<pre><code>int x   = 10 ;\nint *ip =  &amp;x ;\nint *a  = {nullptr} ;\nint *b  = {ip} ;\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-07-23T17:50:38.373", "Id": "24874210", "Score": "3", "CreationDate": "2014-07-21T20:34:16.503", "LastActivityDate": "2014-07-23T17:50:38.373"}, "24873891": {"CommentCount": "12", "ViewCount": "2997", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-07-21T20:15:50.383", "LastActivityDate": "2014-07-23T17:50:38.373", "Title": "The difference between char* and int*", "FavoriteCount": "2", "LastEditDate": "2014-07-22T09:27:09.713", "Id": "24873891", "Score": "10", "Body": "<p>What is the difference between <code>char*</code> and <code>int*</code>? Sure, they are of different types, but how is it that I can write </p>\n<pre><code>char* s1=\"hello world\";\n</code></pre>\n<p>as</p>\n<pre><code>\"hello world\"\n</code></pre>\n<p>it is not a one character, it's an array of characters, and I cannot write </p>\n<pre><code>*s1\n</code></pre>\n<p>as</p>\n<pre><code>char* s1 = {'h','e','l','l','o',' ','w','o','r','l','d'};\n</code></pre>\n<p>and</p>\n<pre><code>int* a = {2,3,1,45,6};\n</code></pre>\n<p>What is the difference?</p>\n", "Tags": "<c++><initialization><string-literals>", "OwnerUserId": "3858769", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24873891_24874210_6": {"section_id": 3301, "quality": 0.8636363636363636, "length": 19}, "so_24873891_24874210_3": {"section_id": 3325, "quality": 1.0, "length": 25}, "so_24873891_24874210_0": {"section_id": 5356, "quality": 1.0, "length": 26}, "so_24873891_24874210_2": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_24873891_24874210_1": {"section_id": 3321, "quality": 0.6, "length": 9}, "so_24873891_24874210_5": {"section_id": 3301, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_24873891_24874210_6": {"section_id": 3171, "quality": 0.8636363636363636, "length": 19}, "so_24873891_24874210_3": {"section_id": 3195, "quality": 0.76, "length": 19}, "so_24873891_24874210_1": {"section_id": 5947, "quality": 0.6, "length": 9}, "so_24873891_24874210_0": {"section_id": 5153, "quality": 1.0, "length": 26}, "so_24873891_24874210_2": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_24873891_24874210_5": {"section_id": 3171, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_24873891_24874210_6": {"section_id": 4067, "quality": 0.8636363636363636, "length": 19}, "so_24873891_24874210_3": {"section_id": 4091, "quality": 1.0, "length": 25}, "so_24873891_24874210_1": {"section_id": 4058, "quality": 0.6, "length": 9}, "so_24873891_24874210_0": {"section_id": 6781, "quality": 1.0, "length": 26}, "so_24873891_24874210_2": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_24873891_24874210_5": {"section_id": 4067, "quality": 0.8235294117647058, "length": 14}}}, "24874048": {"ParentId": "24873891", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is quite simple: A string literal, i.e., <code>\"foobar\"</code> is compiled to an array of chars which is stored in the static section of your program (i.e., where all constants are stored) and null terminated. Then, assigning this to a variable simply assigns a pointer to this memory to the variable. E.g., <code>const char* a = \"foo\";</code> will assign the address where <code>\"foo\"</code> is stored to <code>a</code>. </p>\n<p><em>In short, a string constant already brings the memory where it is to be stored with it.</em></p>\n<p>In contrast, initializing a pointer with an initializer list, (i.e., a list of elements inside curly braces) is not defined for pointers. Informally, the problem with <em>an initializer list</em> -- in contrast to a string literal -- is that it <em>does not \"bring its own memory\"</em>. Therefore, we must provide memory where the initializer list can store its chars. This is done by declaring an array instead of a pointer. This compiles fine:</p>\n<pre><code>char s1[11]={'h','e','l','l','o',' ','w','o','r','l','d'}\n</code></pre>\n<p>Now, we provided the space where the chars are to be stored by declaring <code>s1</code> as an array.</p>\n<p>Note that you can use brace initialization of pointers, though, e.g.:</p>\n<pre><code>char* c2 = {nullptr};\n</code></pre>\n<p>However, while the syntax seems equal, this something completely different which is called uniform initialization and will simply initialize <code>c2</code> with <code>nullptr</code>.</p>\n", "OwnerUserId": "1408611", "LastEditorUserId": "1408611", "LastEditDate": "2014-07-22T08:19:14.487", "Id": "24874048", "Score": "8", "CreationDate": "2014-07-21T20:24:44.247", "LastActivityDate": "2014-07-22T08:19:14.487"}});