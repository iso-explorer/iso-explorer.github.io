post_cb({"bq_ids": {"n4140": {"so_13089388_13089641_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6323}, "so_13089388_13089641_1": {"length": 5, "quality": 1.0, "section_id": 6324}}, "n3337": {"so_13089388_13089641_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6080}, "so_13089388_13089641_1": {"length": 5, "quality": 1.0, "section_id": 6081}}, "n4659": {"so_13089388_13089641_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7833}, "so_13089388_13089641_1": {"length": 5, "quality": 1.0, "section_id": 7834}}}, "13089641": {"Id": "13089641", "PostTypeId": "2", "Body": "<p>The C++ standard specifies for the various smart pointers that the template parameter is allowed to be an incomplete type.</p>\n<p>This information is not given for container types.  Because it is unspecified, an implementation is allowed to accept an incomplete type for one container class template and not another, and still be conformant.</p>\n<p>To make your code portable, avoid making containers of any type before the type is completed.</p>\n<p>Formally, this constraint is found in the following rule (17.6.4.8) which applies to your code:</p>\n<blockquote>\n<p id=\"so_13089388_13089641_0\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ standard library depends on components supplied by a C++ program.  If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n<p id=\"so_13089388_13089641_1\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_13089388_13089641_2\">...</p>\n<ul>\n<li>if an incomplete type is used as a template argument when instantiating a template component, unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-10-26T15:19:52.170", "Score": "15", "CreationDate": "2012-10-26T15:14:38.850", "ParentId": "13089388", "CommentCount": "3", "OwnerUserId": "103167", "LastEditDate": "2012-10-26T15:19:52.170"}, "13089388": {"ViewCount": "1387", "Body": "<p>This code:</p>\n<pre><code>class Foo {\n    std::unordered_map&lt;std::string, Foo&gt; x;\n};\n</code></pre>\n<p>gives me an error:</p>\n<pre><code>/usr/include/c++/4.7/bits/stl_pair.h:94:11:\n  error: 'std::pair&lt;_T1, _T2&gt;::second' has incomplete type\nfoo.cpp:4:7: error: forward declaration of 'class Foo'\n</code></pre>\n<p>However, this code compiles just fine:</p>\n<pre><code>class Foo {\n    std::vector&lt;Foo&gt; x;\n};\n</code></pre>\n<p>Is this a library/compiler bug?</p>\n", "AcceptedAnswerId": "13089641", "Title": "How to have an unordered_map where the value type is the class it's in?", "CreationDate": "2012-10-26T14:31:41.000", "Id": "13089388", "CommentCount": "3", "LastEditDate": "2012-10-26T15:07:07.370", "PostTypeId": "1", "OwnerDisplayName": "Martin C. Martin", "LastEditorUserId": "635608", "LastActivityDate": "2012-10-26T15:19:52.170", "Score": "9", "OwnerUserId": "3917", "Tags": "<c++>", "AnswerCount": "1"}});