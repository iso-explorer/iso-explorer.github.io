post_cb({"10201402": {"ParentId": "10201321", "CommentCount": "3", "Body": "<p>According to the C++11 standard, \u00a712.8.31:</p>\n<blockquote>\n<p id=\"so_10201321_10201402_0\">\u2026This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_10201321_10201402_1\">\u2026</p>\n<ul>\n<li>when a temporary class object that has not been bound to a reference would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n</blockquote>\n<p>Temporary objects get a lot of leeway in C++, and compilers will be pretty aggressive when removing them. If your object had a lifetime of its own in any way, then the copy constructor <em>would</em> end up being called.</p>\n<p>However, I would definitely expect it to check the copy constructor's access modifier, though I can see an argument that you shouldn't (after all, you just aren't calling the copy constructor). But that probably wouldn't be very good practice, since copy elision is optional.</p>\n", "OwnerUserId": "5696", "PostTypeId": "2", "Id": "10201402", "Score": "4", "CreationDate": "2012-04-18T01:05:24.993", "LastActivityDate": "2012-04-18T01:05:24.993"}, "bq_ids": {"n4140": {"so_10201321_10201402_0": {"section_id": 480, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_10201321_10201402_0": {"section_id": 471, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_10201321_10201402_0": {"section_id": 502, "quality": 0.9333333333333333, "length": 14}}}, "10201361": {"ParentId": "10201321", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is an optimization done by the compiler. According to the language specification, the compiler is allowed to omit the call to the copy-constructor whenever it can. </p>\n<p>An accessible  copy-constructor is needed for semantic check only, even though it is not <em>actually</em> called. Semantic check is done much before the optimization.</p>\n<p>However, if you compile it with <code>-fno-elide-constructors</code> option with GCC, then the copy-elision will not be performed, and the copy-constructor will be called. The <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/C_002b_002b-Dialect-Options.html\" rel=\"nofollow noreferrer\">GCC doc</a> says,</p>\n<blockquote>\n<p id=\"so_10201321_10201361_0\"><strong>-fno-elide-constructors</strong></p>\n<p id=\"so_10201321_10201361_1\">The C++ standard allows an implementation to omit creating a temporary which is only used to initialize another object of the same type. <strong>Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.</strong> </p>\n</blockquote>\n<p>With MSVC10, you can use <a href=\"http://msdn.microsoft.com/en-us/library/aafb762y(v=vs.100).aspx\" rel=\"nofollow noreferrer\">/Od</a> which according to the MSDN turns off all optimizations in the program.</p>\n<p><em>Note</em> : Wikipedia has an article on <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow noreferrer\">copy elision</a></p>\n", "OwnerUserId": "415784", "LastEditorUserId": "5614968", "LastEditDate": "2016-11-12T06:06:13.967", "Id": "10201361", "Score": "5", "CreationDate": "2012-04-18T01:00:34.527", "LastActivityDate": "2016-11-12T06:06:13.967"}, "10201321": {"CommentCount": "1", "AcceptedAnswerId": "10201361", "PostTypeId": "1", "LastEditorUserId": "921070", "CreationDate": "2012-04-18T00:55:57.187", "LastActivityDate": "2017-11-17T09:00:29.390", "LastEditDate": "2017-11-17T09:00:29.390", "ViewCount": "740", "FavoriteCount": "1", "Title": "Copy constructor elision?", "Id": "10201321", "Score": "4", "Body": "<p>Don't quite understand why this copy constructor is not invoked when I build with debug mode using VC2010.</p>\n<pre><code>class SomeClass\n{\npublic:\n    SomeClass(int meaningless){}\n\n    SomeClass(const SomeClass&amp; sc)\n    {\n        cout &lt;&lt; \"Copy Constructor invoked!\" &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    SomeClass test(SomeClass(9999));  // Copy constructor not invoked. \n}\n</code></pre>\n<p>I think this has nothing to do with RVO since I am not returning any values.</p>\n<p>More interesting, when I make the copy constructor private, the compiler wouldn't even compile even if it omit the copy constructor.</p>\n", "Tags": "<c++><constructor><copy>", "OwnerUserId": "921070", "AnswerCount": "2"}});