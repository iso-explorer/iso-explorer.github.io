post_cb({"33144731": {"Id": "33144731", "PostTypeId": "2", "Body": "<p>Yes, the requirements are less strict now. However, right below the part you're referencing, the linked documentation <em>clearly states</em> that:</p>\n<blockquote>\n<p id=\"so_33144419_33144731_0\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of Erasable, but many member functions impose stricter requirements. <strong>(since C++11)</strong></p>\n</blockquote>\n<p>References don't meet the requirements of Erasable, therefore they still can't work.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2015-10-15T09:41:17.110", "Score": "8", "CreationDate": "2015-10-15T09:28:00.947", "ParentId": "33144419", "CommentCount": "0", "LastEditDate": "2015-10-15T09:41:17.110", "OwnerUserId": "2079303"}, "33144419": {"ViewCount": "285", "Body": "<p>I know this question was asked a million of times. And most of answers just says that object should be CopyAssignable and CopyConstructible. But <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\">documentation</a> clearly says this is the rule <strong>(until C++11)</strong>! But still it doesn't work. Why?</p>\n", "AcceptedAnswerId": "33144731", "Title": "stl container of references C++11", "CreationDate": "2015-10-15T09:14:23.770", "Id": "33144419", "CommentCount": "0", "LastEditDate": "2015-10-15T09:30:22.140", "PostTypeId": "1", "LastEditorUserId": "1413395", "LastActivityDate": "2015-10-15T09:48:20.817", "Score": "1", "OwnerUserId": "1341942", "Tags": "<c++>", "AnswerCount": "4"}, "33144475": {"Id": "33144475", "PostTypeId": "2", "Body": "<p>The rules apply until C++11. In C++11 is required that element type is a complete type and meets the requirements of Erasable in which case references are not. </p>\n<p>However you can use <a href=\"http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper\" rel=\"nofollow\">std::reference_wrapper</a> to wrap your references and store them in a vector.</p>\n<pre><code>std::vector&lt;std::reference_wrapper&lt;T&gt;&gt; vector_of_references;\n</code></pre>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-10-15T09:41:38.170", "Score": "8", "CreationDate": "2015-10-15T09:16:54.127", "ParentId": "33144419", "CommentCount": "4", "LastEditDate": "2015-10-15T09:41:38.170", "OwnerUserId": "2352671"}, "bq_ids": {"n4140": {"so_33144419_33144715_0": {"length": 16, "quality": 1.0, "section_id": 702}}, "n3337": {"so_33144419_33144715_0": {"length": 16, "quality": 1.0, "section_id": 692}}, "n4659": {"so_33144419_33144715_0": {"length": 16, "quality": 1.0, "section_id": 731}}}, "33144715": {"Id": "33144715", "PostTypeId": "2", "Body": "<p>\u00a7 23.2.1 [container.requirements.general] \u00b6 1 of N4140 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33144419_33144715_0\"><strong>Containers are objects that store other objects</strong>. They control allocation and deallocation of these objects through constructors, destructors, insert and erase operations.</p>\n</blockquote>\n<p>But a reference is not an object so you cannot put it into a standard library container.</p>\n", "LastActivityDate": "2015-10-15T09:27:12.143", "CommentCount": "0", "CreationDate": "2015-10-15T09:27:12.143", "ParentId": "33144419", "Score": "4", "OwnerUserId": "1392132"}, "33144995": {"Id": "33144995", "PostTypeId": "2", "Body": "<p>C++11 relaxed the container requirements so that non-CopyConstructible types can be used in containers, as long as you avoid operations that would need to copy the elements.</p>\n<p>That doesn't mean that references are allowed though, just because one rule is relaxed doesn't mean that absolutely any type can be put in a container.</p>\n<p>As the cppreference page you quoted <a href=\"http://en.cppreference.com/w/cpp/container/vector#Template_parameters\" rel=\"nofollow\">says</a> for C++11</p>\n<blockquote>\n<p id=\"so_33144419_33144995_0\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of <code>Erasable</code>, but many member functions impose stricter requirements.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/concept/Erasable\" rel=\"nofollow\"><code>Erasable</code></a> requires that this is valid:</p>\n<pre><code>allocator_traits&lt;A&gt;::destroy(m, p)\n</code></pre>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/concept/Allocator\" rel=\"nofollow\">Allocator</a> requirements in 17.6.3.5 [allocator.requirements] say allocators deal with <em>any non-const object type</em> and references are not object types, so you cannot allocate or deallocate a reference, and therefore you cannot put them in containers.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2015-10-15T09:48:20.817", "Score": "6", "CreationDate": "2015-10-15T09:38:11.973", "ParentId": "33144419", "CommentCount": "0", "LastEditDate": "2015-10-15T09:48:20.817", "OwnerUserId": "981959"}});