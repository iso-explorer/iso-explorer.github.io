post_cb({"33144419": {"CommentCount": "0", "ViewCount": "285", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2015-10-15T09:14:23.770", "LastActivityDate": "2015-10-15T09:48:20.817", "Title": "stl container of references C++11", "AcceptedAnswerId": "33144731", "LastEditDate": "2015-10-15T09:30:22.140", "Id": "33144419", "Score": "1", "Body": "<p>I know this question was asked a million of times. And most of answers just says that object should be CopyAssignable and CopyConstructible. But <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\">documentation</a> clearly says this is the rule <strong>(until C++11)</strong>! But still it doesn't work. Why?</p>\n", "Tags": "<c++>", "OwnerUserId": "1341942", "AnswerCount": "4"}, "33144475": {"ParentId": "33144419", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-10-15T09:16:54.127", "Score": "8", "LastEditorUserId": "2352671", "LastEditDate": "2015-10-15T09:41:38.170", "Id": "33144475", "OwnerUserId": "2352671", "Body": "<p>The rules apply until C++11. In C++11 is required that element type is a complete type and meets the requirements of Erasable in which case references are not. </p>\n<p>However you can use <a href=\"http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper\" rel=\"nofollow\">std::reference_wrapper</a> to wrap your references and store them in a vector.</p>\n<pre><code>std::vector&lt;std::reference_wrapper&lt;T&gt;&gt; vector_of_references;\n</code></pre>\n", "LastActivityDate": "2015-10-15T09:41:38.170"}, "33144731": {"ParentId": "33144419", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-15T09:28:00.947", "Score": "8", "LastEditorUserId": "2079303", "LastEditDate": "2015-10-15T09:41:17.110", "Id": "33144731", "OwnerUserId": "2079303", "Body": "<p>Yes, the requirements are less strict now. However, right below the part you're referencing, the linked documentation <em>clearly states</em> that:</p>\n<blockquote>\n<p id=\"so_33144419_33144731_0\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of Erasable, but many member functions impose stricter requirements. <strong>(since C++11)</strong></p>\n</blockquote>\n<p>References don't meet the requirements of Erasable, therefore they still can't work.</p>\n", "LastActivityDate": "2015-10-15T09:41:17.110"}, "33144715": {"ParentId": "33144419", "CommentCount": "0", "Body": "<p>\u00a7 23.2.1 [container.requirements.general] \u00b6 1 of N4140 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33144419_33144715_0\"><strong>Containers are objects that store other objects</strong>. They control allocation and deallocation of these objects through constructors, destructors, insert and erase operations.</p>\n</blockquote>\n<p>But a reference is not an object so you cannot put it into a standard library container.</p>\n", "OwnerUserId": "1392132", "PostTypeId": "2", "Id": "33144715", "Score": "4", "CreationDate": "2015-10-15T09:27:12.143", "LastActivityDate": "2015-10-15T09:27:12.143"}, "33144995": {"ParentId": "33144419", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-15T09:38:11.973", "Score": "6", "LastEditorUserId": "981959", "LastEditDate": "2015-10-15T09:48:20.817", "Id": "33144995", "OwnerUserId": "981959", "Body": "<p>C++11 relaxed the container requirements so that non-CopyConstructible types can be used in containers, as long as you avoid operations that would need to copy the elements.</p>\n<p>That doesn't mean that references are allowed though, just because one rule is relaxed doesn't mean that absolutely any type can be put in a container.</p>\n<p>As the cppreference page you quoted <a href=\"http://en.cppreference.com/w/cpp/container/vector#Template_parameters\" rel=\"nofollow\">says</a> for C++11</p>\n<blockquote>\n<p id=\"so_33144419_33144995_0\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of <code>Erasable</code>, but many member functions impose stricter requirements.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/concept/Erasable\" rel=\"nofollow\"><code>Erasable</code></a> requires that this is valid:</p>\n<pre><code>allocator_traits&lt;A&gt;::destroy(m, p)\n</code></pre>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/concept/Allocator\" rel=\"nofollow\">Allocator</a> requirements in 17.6.3.5 [allocator.requirements] say allocators deal with <em>any non-const object type</em> and references are not object types, so you cannot allocate or deallocate a reference, and therefore you cannot put them in containers.</p>\n", "LastActivityDate": "2015-10-15T09:48:20.817"}, "bq_ids": {"n4140": {"so_33144419_33144715_0": {"section_id": 702, "quality": 1.0, "length": 16}}, "n3337": {"so_33144419_33144715_0": {"section_id": 692, "quality": 1.0, "length": 16}}, "n4659": {"so_33144419_33144715_0": {"section_id": 731, "quality": 1.0, "length": 16}}}});