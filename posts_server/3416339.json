post_cb({"3416740": {"ParentId": "3416339", "CommentCount": "0", "CreationDate": "2010-08-05T16:06:46.900", "OwnerUserId": "168225", "PostTypeId": "2", "Id": "3416740", "Score": "1", "Body": "<p>As Benoit proposed, you have to specialize the member function in the surrounding namespace:</p>\n<pre><code>struct X {\n    template&lt;int N&gt; void f() {}\n};\n\ntemplate&lt;&gt; void X::f&lt;1&gt;() {} // explicit specialization at namespace scope\n</code></pre>\n<p>This is because of <em>\u00a714.7.3</em> (C++03):</p>\n<blockquote>\n<p id=\"so_3416339_3416740_0\">An explicit specialization shall be declared in the namespace of which the template is a member, or, for member templates, in the namespace of which the enclosing class or enclosing class template is a member.</p>\n</blockquote>\n<p>VC however doesn't conform to the standard in that regard and thus creates some portability headaches.</p>\n", "LastActivityDate": "2010-08-05T16:06:46.900"}, "3416440": {"ParentId": "3416339", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-08-05T15:39:43.367", "Score": "1", "LastEditorUserId": "168225", "LastEditDate": "2010-08-05T16:09:54.473", "Id": "3416440", "OwnerUserId": "31640", "Body": "<p>Try the following</p>\n<pre><code>class X\n{\npublic:\n\n    // declaration\n    template&lt; int FLD &gt;\n    void set_native( char *ptr, unsigned int length );\n};\n\n// specialisations\ntemplate&lt;&gt; void X::set_native&lt; 1 &gt;( char *ptr, unsigned int length )\n{\n}\n</code></pre>\n<p>If it does not work, try adding a templated class behind set_native</p>\n<pre><code>template&lt;int FLD&gt; class SetNative;\nclass X\n{\npublic:    \n    // declaration\n    template&lt; int FLD &gt;\n    void set_native( char *ptr, unsigned int length )\n    { return SetNative()(ptr, length); }\n};\ntemplate&lt;&gt; class SetNative&lt;1&gt;\n{\n  void operator()( char *ptr, unsigned int length ){...}\n};\n</code></pre>\n", "LastActivityDate": "2010-08-05T16:09:54.473"}, "3416339": {"CommentCount": "0", "ViewCount": "306", "CreationDate": "2010-08-05T15:29:38.863", "LastActivityDate": "2010-08-05T16:09:54.473", "Title": "template method specialisation problem", "AcceptedAnswerId": "3416740", "PostTypeId": "1", "Id": "3416339", "Score": "1", "Body": "<p>Can anyone help me with this code. I'm trying to specialise a method. At the moment it doesn't work with one specialisation (1) but I'd like to ultimately have lots of specialisations (2, 3, 4, 5 etc)</p>\n<pre><code>class X\n{\npublic:\n\n    // declaration\n    template&lt; int FLD &gt;\n    void set_native( char *ptr, unsigned int length );\n\n    // specialisations\n\n    template&lt;&gt; void set_native&lt; 1 &gt;( char *ptr, unsigned int length )\n    {\n    }\n\n};\n</code></pre>\n<p>The error messages I'm getting are..</p>\n<p>x.cpp:13: error: explicit specialization in non-namespace scope 'class X'\nx.cpp:13: error: template-id 'set_native&lt;1&gt;' for 'void set_native(char*, unsigned int)' does not match any template declaration\nx.cpp:13: error: invalid function declaration</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "66191", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3416339_3416740_0": {"section_id": 255, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_3416339_3416740_0": {"section_id": 246, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_3416339_3416740_0": {"section_id": 262, "quality": 0.7333333333333333, "length": 11}}}});