post_cb({"bq_ids": {"n4140": {"so_19103244_19103585_1": {"length": 7, "quality": 0.875, "section_id": 775}, "so_19103244_19103585_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 775}}, "n3337": {"so_19103244_19103585_1": {"length": 7, "quality": 0.875, "section_id": 762}, "so_19103244_19103585_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 762}}}, "19103244": {"ViewCount": "2381", "Body": "<p>In C++11 <code>std::array</code> is defined to have contiguous storage and performance that is no worse than an array, but I can't decide if the various requirements of the standard imply that std::array has the same size and memory layout as a normal array. That is can you count on <code>sizeof(std::array&lt;int,N&gt;) == sizeof(int)*N</code> or is that implementation specific?</p>\n<p>In particular, is this guaranteed to work the way you would expect it to:</p>\n<pre><code>std::vector&lt; std::array&lt;int, N&gt; &gt; x(M);\ntypedef (*ArrayPointer)[N];\nArrayPointer y = (ArrayPointer) &amp;x[0][0];\n// use y like normal multidimensional array\n</code></pre>\n<p>It works in the two compilers I tried (GNU &amp; Intel). Furthermore, all the 3rd party documentation I could find (<a href=\"http://www.cplusplus.com/reference/array/array/\">like this</a>), states that std::array is just as memory efficient as a plain array, which combined with the contiguous requirement would imply that it must have identical memory layout. However I can't find this requirement in the standard.</p>\n", "AcceptedAnswerId": "19103585", "Title": "Is the size of std::array defined by standard", "CreationDate": "2013-09-30T20:29:17.210", "Id": "19103244", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-01-13T18:00:02.033", "LastEditorUserId": "103167", "LastActivityDate": "2015-01-13T18:00:02.033", "Score": "29", "OwnerUserId": "339595", "Tags": "<c++><c++11><stl><language-lawyer>", "AnswerCount": "1"}, "19103585": {"Id": "19103585", "PostTypeId": "2", "Body": "<p>It's <em>nearly</em> required. Specifically, \u00a723.3.2.1/2 says:</p>\n<blockquote>\n<p id=\"so_19103244_19103585_0\">An array is an aggregate (8.5.1) that can be initialized with the syntax</p>\n</blockquote>\n<pre><code>array&lt;T, N&gt; a = { initializer-list };\n</code></pre>\n<blockquote>\n<p id=\"so_19103244_19103585_1\">where <code>initializer-list</code> is a comma-separated list of up to N elements whose types are convertible to T.</p>\n</blockquote>\n<p>Since it's an aggregate, it can't use any sort of constructor to convert the data in the initializer-list to the correct format. That really only leaves one possibility: about the only thing it can store are the values themselves.</p>\n<p>I suppose it <em>would</em> be possible for an <code>std::array</code> to store some sort of auxiliary data following the specified data, such as extra memory set to some predefined value, so if you write past the end of the array, you'd probably change that data. The compiler/run-time would then check those values at shut-down, and if you'd changed the values, report your code's undefined behavior.</p>\n<p>It's also possible that a compiler <em>could</em> do padding/alignment differently for an <code>std::array</code> than for a built-in array. One obvious example for which this could even be desirable would be to support super-alignment requirements, such as data for use with Intel's SSE instructions. A built-in array <em>can't</em> support super-alignment, but I <em>think</em> the specification of <code>std::array</code> might be barely loose enough to allow it.</p>\n<p>Bottom line: without getting into questions of how many possibilities might exist, it's pretty clear that <code>std::array</code> doesn't necessarily have to follow the rule you're asking about.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-09-30T21:17:11.680", "CommentCount": "7", "CreationDate": "2013-09-30T20:50:49.047", "ParentId": "19103244", "Score": "23", "OwnerUserId": "179910", "LastEditDate": "2013-09-30T21:17:11.680"}});