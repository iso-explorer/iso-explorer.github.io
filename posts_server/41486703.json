post_cb({"bq_ids": {"n4140": {"so_41486703_41489471_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 3919}, "so_41486703_41489471_3": {"length": 19, "quality": 1.0, "section_id": 7156}, "so_41486703_41489471_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 7157}}, "n3337": {"so_41486703_41489471_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 3779}, "so_41486703_41489471_3": {"length": 19, "quality": 1.0, "section_id": 6900}, "so_41486703_41489471_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 6901}}, "n4659": {"so_41486703_41486703_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 8663}, "so_41486703_41489471_1": {"length": 18, "quality": 1.0, "section_id": 4805}, "so_41486703_41489471_3": {"length": 19, "quality": 1.0, "section_id": 8663}, "so_41486703_41489471_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 8664}}}, "41489471": {"Id": "41489471", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41486703_41489471_0\"><strong>[stmt.dcl] \u00b64</strong></p>\n<p id=\"so_41486703_41489471_1\">Dynamic initialization of a block-scope variable with static storage duration or thread storage duration is performed the first time control passes through its declaration.</p>\n<p id=\"so_41486703_41489471_2\"><strong>[basic.start.term] \u00b61</strong></p>\n<p id=\"so_41486703_41489471_3\">If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first.</p>\n<p id=\"so_41486703_41489471_4\"><strong>\u00b62</strong></p>\n<p id=\"so_41486703_41489471_5\">If a function contains a block-scope object of static or thread storage duration that has been destroyed and the function is called during the destruction of an object with static or thread storage duration, the program has <strong>undefined behaviour</strong> if the flow of control passes through the definition of the previously destroyed block-scope object.</p>\n</blockquote>\n<p>It is in the destructor of <code>SomethingElse</code> that we risk invoking this undefined behaviour:</p>\n<pre><code>SomethingElse::~SomethingElse() {\n    Something::get();\n}\n</code></pre>\n<p>If there is an instance of <code>SomethingElse</code> with static storage duration, then there are four possibilities:</p>\n<ol>\n<li><p>The single instance of <code>Something</code> was constructed before the <code>SomethingElse</code>. Its destruction will happen after the <code>SomethingElse</code>, so the behaviour is well defined.</p></li>\n<li><p>The single instance of <code>Something</code> was constructed after the <code>SomethingElse</code>. Its destruction will have happened before the <code>SomethingElse</code>, so the behaviour is undefined as described above.</p></li>\n<li><p>The single instance of <code>Something</code> was constructed in a different thread without being synchronized with respect to the construction of the <code>SomethingElse</code>. The destructions may happen concurrently, so the behaviour is undefined.</p></li>\n<li><p>No instance of <code>Something</code> was yet constructed (i.e. this is the first call to <code>Something::get</code>). In this case, the program calls for the construction of a <code>Something</code> after the <code>SomethingElse</code>, which means the destruction of the <code>Something</code> must happen before the <code>SomethingElse</code>, but since the destruction of the <code>SomethingElse</code> has already commenced, this is a contradiction, and the behaviour is undefined. (Technically, there is a cycle in the \"sequenced before\" relation.)</p></li>\n</ol>\n", "LastEditorUserId": "1639256", "LastActivityDate": "2017-01-05T16:10:27.557", "Score": "4", "CreationDate": "2017-01-05T16:02:33.360", "ParentId": "41486703", "CommentCount": "7", "OwnerUserId": "1639256", "LastEditDate": "2017-01-05T16:10:27.557"}, "41486703": {"ViewCount": "245", "Body": "<p>Assuming I have the following code</p>\n<h1>Something.hpp</h1>\n<pre><code>#pragma once\n\nclass Something {\npublic:\n    static Something&amp; get();\nprivate: \n    Something();\n};\n</code></pre>\n<h1>Something.cpp</h1>\n<pre><code>#include \"Something.hpp\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nSomething&amp; Something::get() {\n    static Something something;\n    return something;\n}\nSomething::Something() {\n    cout &lt;&lt; \"Something()\" &lt;&lt; endl;\n}\n</code></pre>\n<h1>main.cpp</h1>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct SomethingElse {\n    ~SomethingElse() {\n        Something::get();\n        cout &lt;&lt; \"~SomethingElse\" &lt;&lt; endl; \n    }\n};\n\nvoid func() {\n    static SomethingElse something_else;\n    // do something with something_else\n}\n\nint main() {\n    func();\n    return 0;\n}\n</code></pre>\n<p>Can more than one instance of the <code>Something</code> object ever be created?  Does the standard say anything about serializing the destruction of static objects?</p>\n<p><strong>Note</strong> I am aware the the destruction of file level static variables is undefined when across different translation units,  I wanted to know what happens in the case of function scoped static variables (<a href=\"https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_C.2B.2B11\" rel=\"nofollow noreferrer\">which have the double-checked locking pattern built into the C++ runtime</a>) For the same translation unit case with file level static variables, its easy for the compiler to ensure serialization with construction and destruction based on how the variables are laid out in the code (static), but what happens when the variables are dynamically lazily created when the functions are called?</p>\n<p><strong>Note</strong> What about for primitive variables?  Can we expect them to contain their values till program end?  Since they don't need to be destroyed.</p>\n<hr>\n<h1>Edit</h1>\n<p>Found this on cppreference.com (<a href=\"http://en.cppreference.com/w/cpp/utility/program/exit\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/program/exit</a>) </p>\n<blockquote>\n<p id=\"so_41486703_41486703_0\">If the completion of the constructor or dynamic initialization for thread-local or static object A was sequenced-before thread-local or static object B, the completion of the destruction of B is sequenced-before the start of the destruction of A</p>\n</blockquote>\n<p>If this is true then destruction for every static object is serialized?  But I also found this </p>\n<p><a href=\"https://isocpp.org/wiki/faq/ctors#construct-on-first-use-v2\" rel=\"nofollow noreferrer\">https://isocpp.org/wiki/faq/ctors#construct-on-first-use-v2</a> which contradicts the standard</p>\n</hr>", "Title": "Referencing a possibly destroyed static object", "CreationDate": "2017-01-05T13:45:58.033", "LastActivityDate": "2017-01-06T00:57:06.720", "CommentCount": "3", "LastEditDate": "2017-01-06T00:57:06.720", "PostTypeId": "1", "LastEditorUserId": "5501675", "Id": "41486703", "Score": "7", "OwnerUserId": "5501675", "Tags": "<c++><c++11><static-variables>", "AnswerCount": "2"}, "41486786": {"Id": "41486786", "PostTypeId": "2", "Body": "<p>The order of construction and destruction of static (and global non-static) objects is well-defined in the C++ specification, for <em>a single <a href=\"https://en.wikipedia.org/wiki/Translation_unit_(programming)\" rel=\"nofollow noreferrer\">translation unit</a></em>!</p>\n<p>If you have multiple translation unit (multiple source files) then the order of construction/destruction between the TUs is not defined.</p>\n<p>So the code you show can have <em>undefined behavior</em>.</p>\n", "LastActivityDate": "2017-01-05T13:50:51.713", "CommentCount": "1", "CreationDate": "2017-01-05T13:50:51.713", "ParentId": "41486703", "Score": "4", "OwnerUserId": "440558"}});