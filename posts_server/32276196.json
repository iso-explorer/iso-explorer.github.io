post_cb({"bq_ids": {"n4140": {"so_32276196_32276421_0": {"length": 14, "quality": 0.5185185185185185, "section_id": 1426}}, "n4659": {"so_32276196_32276421_0": {"length": 14, "quality": 0.5185185185185185, "section_id": 1546}}}, "32276196": {"ViewCount": "94", "Body": "<p>I need to process a list of objects of type <code>Foo</code> in groups sharing the quality of corresponding to the same value of <code>Bar</code>. The list is pre-sorted in relation to that quality,  so my idea was to use <code>std::upper_bound</code> to find where the subsequent groups begin.</p>\n<pre><code>Bar FooToBar(const Foo &amp;foo);\n// sorted so that FooToBar(foolist[0] &lt;= FooToBar(foolist[1]) &lt;= ...\nstd::list&lt;Foo&gt; foolist; \n\n// find bounds of a group of Foo-s corresponding to someBar;\nBar someBar;\nauto \n    groupBegin = foolist.begin(),\n    // find last item of foolist whose FooToBar() == someBar\n    groupEnd   = std::upper_bound( foolist.begin(), \n                                   foolist.end(), \n                                   someBar ); \n</code></pre>\n<p>Of course that will not work because <code>Foo</code> and <code>Bar</code> are not directly comparable. Luckily, there's an overload of <code>std::upper_bound</code> which takes an extra comparator argument:</p>\n<pre><code>groupEnd = std::upper_bound( foolist.begin(), foolist.end(), someBar, Compare);\n</code></pre>\n<p>Question is, how do I go about writing <code>Compare()</code>? Here's where things get interesting. <a href=\"http://en.cppreference.com/w/cpp/algorithm/upper_bound\" rel=\"nofollow\">cppreference.com</a> says:</p>\n<blockquote>\n<p id=\"so_32276196_32276196_0\">The signature of the comparison function should be equivalent to the following:</p>\n<p id=\"so_32276196_32276196_1\">bool cmp(const Type1 &amp;a, const Type2 &amp;b);</p>\n<p id=\"so_32276196_32276196_2\">The signature does not need to have const &amp;, but the function object must not modify the objects passed to it.\n  The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both Type1 and Type2, and an object of type ForwardIt can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b </p>\n</blockquote>\n<p>Obviously, there's no way I can satisfy those conditions with <code>Foo</code> and <code>Bar</code>. However, <a href=\"http://www.cplusplus.com/reference/algorithm/upper_bound/?kw=upper_bound\" rel=\"nofollow\">cplusplus.com</a> says something different:</p>\n<blockquote>\n<p id=\"so_32276196_32276196_3\">Binary function that accepts two arguments (the first is always val, and the second of the type pointed by ForwardIterator), and returns a value convertible to bool.</p>\n</blockquote>\n<p>I can work with that, so:</p>\n<pre><code>bool Compare(const Bar &amp;bar, const Foo &amp;foo) { /* ... */ }\n</code></pre>\n<p>However, that does not compile in either VS2013, nor g++:</p>\n<blockquote>\n<p id=\"so_32276196_32276196_4\">/usr/lib/gcc/x86_64-pc-cygwin/4.9.2/include/c++/bits/predefined_ops.h:141:37: error: cannot convert \u2018Foo\u2019 to \u2018Bar\u2019 in argument passing</p>\n</blockquote>\n<p>Curiously, when I reverse the argument order, it compiles, runs and behaves as expected:</p>\n<pre><code>bool Compare(const Foo &amp;foo, const Bar &amp;bar) { /* ... */ }\n</code></pre>\n<p>So it looks like one reference says one thing, other reference says something else, and the compiler accepts something still different. Or did I misunderstand something?</p>\n", "AcceptedAnswerId": "32276421", "Title": "Strange discrepancy between library reference and compiler for std::upper_bound()", "CreationDate": "2015-08-28T17:01:09.607", "Id": "32276196", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-08-28T17:24:31.007", "Score": "3", "OwnerUserId": "190600", "Tags": "<c++><stl><c++-standard-library>", "AnswerCount": "2"}, "32276421": {"Id": "32276421", "PostTypeId": "2", "LastEditDate": "2015-08-28T17:24:31.007", "CommentCount": "3", "LastEditorUserId": "2069064", "LastActivityDate": "2015-08-28T17:24:31.007", "CreationDate": "2015-08-28T17:14:12.643", "ParentId": "32276196", "Score": "4", "Body": "<p>What you're refering to is a defect in the standard: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270\" rel=\"nofollow\">#270</a>. The original wording was deemed to strict (indeed, your particular use case was mentioned). The section in the Standard now reads, [upper.bound]:</p>\n<blockquote>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\n  ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last,\n                const T&amp; value);\n\ntemplate&lt;class ForwardIterator, class T, class Compare&gt;\n  ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last,\n                const T&amp; value, Compare comp);\n</code></pre>\n<p id=\"so_32276196_32276421_0\"><em>Requires</em>: The elements <code>e</code> of <code>[first,last)</code> shall be partitioned with respect to the expression <code>!(value &lt; e)</code> or <code>!comp(value, e)</code>.<br>\n<em>Returns</em>: The furthermost iterator <code>i</code> in the range <code>[first,last]</code> such that for every iterator <code>j</code> in the range <code>[first,i)</code> the following corresponding conditions hold: <code>!(value &lt; *j)</code> or <code>comp(value, *j) == false</code>.</br></p>\n</blockquote>\n<p>In both cases, <code>value</code> is the first argument to <code>comp</code> and the element is second. So the following is perfectly valid code:</p>\n<pre><code>struct Foo { };\nstruct Bar { };\n\nstd::vector&lt;Foo&gt; foolist;\n\nauto it = std::upper_bound(foolist.begin(), foolist.end(), Bar{}, \n                           [](Bar const&amp;, Foo const&amp;) { return false; });\n</code></pre>\n<p>The above works on both gcc 5.2 (and even 4.6.4 -- modulo the lambda -- which is the oldest I have easy access to) and clang 3.6. </p>\n", "OwnerUserId": "2069064"}, "32276335": {"Id": "32276335", "PostTypeId": "2", "Body": "<p>If you read the part of the documentation that you quoted in your question, you will understand that unless there is an implicit conversion from <code>Bar</code> to <code>Foo</code>, both versions of <code>Compare</code> are incorrect. The fact that one version works is merely a lucky coincidence. It may easily fail with a different compiler.</p>\n", "Score": "1", "LastActivityDate": "2015-08-28T17:09:09.457", "CreationDate": "2015-08-28T17:09:09.457", "ParentId": "32276196", "CommentCount": "6", "OwnerUserId": "434551"}});