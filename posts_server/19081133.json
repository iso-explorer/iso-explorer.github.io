post_cb({"32926672": {"ParentId": "19081133", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Make it easy to opt-in to space savings</h2>\n<p>I have decided that this is a useful thing to do, but a full specialization is a little more work than necessary (for instance, getting <code>operator=</code> correct).</p>\n<p>I have posted on the Boost mailing list a way to simplify the task of specializing, especially when you only want to specialize some instantiations of a class template.</p>\n<p><a href=\"http://boost.2283326.n4.nabble.com/optional-Specializing-optional-to-save-space-td4680362.html\" rel=\"nofollow\">http://boost.2283326.n4.nabble.com/optional-Specializing-optional-to-save-space-td4680362.html</a></p>\n<p>My current interface involves a special tag type used to 'unlock' access to particular functions. I have creatively named this type <code>optional_tag</code>. Only <code>optional</code> can construct an <code>optional_tag</code>. For a type to opt-in to a space-efficient representation, it needs the following member functions:</p>\n<ul>\n<li><code>T(optional_tag)</code> constructs an uninitialized value</li>\n<li><code>initialize(optional_tag, Args &amp;&amp; ...)</code> constructs an object when there may be one in existence already</li>\n<li><code>uninitialize(optional_tag)</code> destroys the contained object</li>\n<li><code>is_initialized(optional_tag)</code> checks whether the object is currently in an initialized state</li>\n</ul>\n<p>By always requiring the optional_tag parameter, we do not limit any function signatures. This is why, for instance, we cannot use <code>operator bool()</code> as the test, because the type may want that operator for other reasons.</p>\n<p>An advantage of this over some other possible methods of implementing it is that you can make it work with any type that can naturally support such a state. It does not add any requirements such as having a move constructor.</p>\n<p>You can see a full code implementation of the idea at</p>\n<p><a href=\"https://bitbucket.org/davidstone/bounded_integer/src/8c5e7567f0d8b3a04cc98142060a020b58b2a00f/bounded_integer/detail/optional/optional.hpp?at=default&amp;fileviewer=file-view-default\" rel=\"nofollow\">https://bitbucket.org/davidstone/bounded_integer/src/8c5e7567f0d8b3a04cc98142060a020b58b2a00f/bounded_integer/detail/optional/optional.hpp?at=default&amp;fileviewer=file-view-default</a></p>\n<p>and for a class using the specialization:</p>\n<p><a href=\"https://bitbucket.org/davidstone/bounded_integer/src/8c5e7567f0d8b3a04cc98142060a020b58b2a00f/bounded_integer/detail/class.hpp?at=default&amp;fileviewer=file-view-default\" rel=\"nofollow\">https://bitbucket.org/davidstone/bounded_integer/src/8c5e7567f0d8b3a04cc98142060a020b58b2a00f/bounded_integer/detail/class.hpp?at=default&amp;fileviewer=file-view-default</a></p>\n<p>(lines 220 through 242)</p>\n<h2>An alternative approach</h2>\n<p>This is in contrast to my previous implementation, which required users to specialize a class template. You can see the old version here:</p>\n<p><a href=\"https://bitbucket.org/davidstone/bounded_integer/src/2defec41add2079ba023c2c6d118ed8a274423c8/bounded_integer/detail/optional/optional.hpp\" rel=\"nofollow\">https://bitbucket.org/davidstone/bounded_integer/src/2defec41add2079ba023c2c6d118ed8a274423c8/bounded_integer/detail/optional/optional.hpp</a></p>\n<p>and</p>\n<p><a href=\"https://bitbucket.org/davidstone/bounded_integer/src/2defec41add2079ba023c2c6d118ed8a274423c8/bounded_integer/detail/optional/specialization.hpp\" rel=\"nofollow\">https://bitbucket.org/davidstone/bounded_integer/src/2defec41add2079ba023c2c6d118ed8a274423c8/bounded_integer/detail/optional/specialization.hpp</a></p>\n<p>The problem with this approach is that it is simply more work for the user. Rather than adding four member functions, the user must go into a new namespace and specialize a template.</p>\n<p>In practice, all specializations would have an <code>in_place_t</code> constructor that forwards all arguments to the underlying type. The <code>optional_tag</code> approach, on the other hand, can just use the underlying type's constructors directly.</p>\n<p>In the specialize <code>optional_storage</code> approach, the user also has the responsibility of adding proper reference-qualified overloads of a value function. In the <code>optional_tag</code> approach, we already have the value so we do not have to pull it out.</p>\n<p><code>optional_storage</code> also required standardizing as part of the interface of optional two helper classes, only one of which the user is supposed to specialize (and sometimes delegate their specialization to the other).</p>\n<h2>The difference between this and compact_optional</h2>\n<p><code>compact_optional</code> is a way of saying \"Treat this special sentinel value as the type being not present, almost like a NaN\". It requires the user to know that the type they are working with has some special sentinel. An easily specializable <code>optional</code> is a way of saying \"My type does not need extra space to store the not present state, but that state is not a normal value.\" It does not require anyone to know about the optimization to take advantage of it; everyone who uses the type gets it for free.</p>\n<h2>The future</h2>\n<p>My goal is to get this first into boost::optional, and then part of the std::optional proposal. Until then, you can always use <code>bounded::optional</code>, although it has a few other (intentional) interface differences.</p>\n", "OwnerUserId": "852254", "LastEditorUserId": "852254", "LastEditDate": "2015-10-03T19:41:19.973", "Id": "32926672", "Score": "0", "CreationDate": "2015-10-03T19:33:44.650", "LastActivityDate": "2015-10-03T19:41:19.973"}, "19081133": {"CommentCount": "8", "ViewCount": "603", "CreationDate": "2013-09-29T17:35:55.910", "LastActivityDate": "2015-10-03T19:41:19.973", "Title": "Specializing std::optional", "AcceptedAnswerId": "19134895", "PostTypeId": "1", "Id": "19081133", "Score": "8", "Body": "<p>Will it be possible to specialize <code>std::optional</code> for user-defined types? If not, is it too late to propose this to the standard?</p>\n<p>My use case for this is an integer-like class that represents a value within a range. For instance, you could have an integer that lies somewhere in the range [0, 10]. Many of my applications are sensitive to even a single byte of overhead, so I would be unable to use a non-specialized <code>std::optional</code> due to the extra <code>bool</code>. However, a specialization for <code>std::optional</code> would be trivial for an integer that has a range smaller than its underlying type. We could simply store the value <code>11</code> in my example. This should provide no space or time overhead over a non-optional value.</p>\n<p>Am I allowed to create this specialization in <code>namespace std</code>?</p>\n", "Tags": "<c++><std><template-specialization><c++14>", "OwnerUserId": "852254", "AnswerCount": "5"}, "32880922": {"ParentId": "19081133", "CommentCount": "0", "Body": "<p>If you are after a library that efficiently packs the value and the \"no-value\" flag into one memory location, I recommend looking at <a href=\"https://github.com/akrzemi1/compact_optional\" rel=\"nofollow\">compact_optional</a>. It does exactly this.</p>\n<p>It does not specialize <code>boost::optional</code> or <code>std::experimental::optional</code> but it can wrap them inside, giving you a uniform interface, with optimizations where possible and a fallback to 'classical' optional where needed.</p>\n", "OwnerUserId": "838509", "PostTypeId": "2", "Id": "32880922", "Score": "4", "CreationDate": "2015-10-01T06:37:33.193", "LastActivityDate": "2015-10-01T06:37:33.193"}, "19081234": {"ParentId": "19081133", "CommentCount": "5", "Body": "<p>I've asked about the same thing, regarding specializing <code>optional&lt;bool&gt;</code> and <code>optional&lt;tribool&gt;</code> among other examples, to only use one byte. While the \"legality\" of doing such things was not under discussion, I do think that one should not, in theory, be allowed to specialize <code>optional&lt;T&gt;</code> in contrast to eg.: hash (which is explicitly allowed). </p>\n<p>I don't have the logs with me but part of the rationale is that the interface treats access to the data as access to a pointer or reference, meaning that if you use a different data structure in the internals, some of the invariants of access might change; not to mention providing the interface with access to the data might require something like <code>reinterpret_cast&lt;(some_reference_type)&gt;</code>. Using a <code>uint8_t</code> to store a optional-bool, for example, would impose several extra requirements on the interface of <code>optional&lt;bool&gt;</code> that are different to the ones of <code>optional&lt;T&gt;</code>. What should the return type of <code>operator*</code> be, for example?</p>\n<p>Basically, I'm guessing the idea is to avoid the whole <strong><code>vector&lt;bool&gt;</code> fiasco</strong> again.</p>\n<p>In your example, it might not be too bad, as the access type is still <code>your_integer_type&amp;</code> (or pointer). But in that case, simply designing your integer type to allow for a \"zombie\" or \"undetermined\" value instead of relying on <code>optional&lt;&gt;</code> to do the job for you, with its extra overhead and requirements, might be the safest choice.</p>\n", "OwnerUserId": "399580", "PostTypeId": "2", "Id": "19081234", "Score": "2", "CreationDate": "2013-09-29T17:46:00.370", "LastActivityDate": "2013-09-29T17:46:00.370"}, "19142311": {"ParentId": "19081133", "CommentCount": "1", "Body": "<p>I don't see how allowing or not allowing some particular bit pattern to represent the unengaged state falls under anything the standard covers.</p>\n<p>If you were trying to convince a library vendor to do this, it would require an implementation, exhaustive tests to show you haven't inadvertently blown any of the requirements of optional (or accidentally invoked undefined behavior) and extensive benchmarking to show this makes a notable difference in real world (and not just contrived) situations.</p>\n<p>Of course, you can do whatever you want to your own code.</p>\n", "OwnerUserId": "1082038", "PostTypeId": "2", "Id": "19142311", "Score": "0", "CreationDate": "2013-10-02T16:47:30.543", "LastActivityDate": "2013-10-02T16:47:30.543"}, "19134895": {"ParentId": "19081133", "CommentCount": "0", "Body": "<p>The general rule in 17.6.4.2.1 [namespace.std]/1 applies:</p>\n<blockquote>\n<p id=\"so_19081133_19134895_0\">A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.</p>\n</blockquote>\n<p>So I would say it's allowed.</p>\n<p>N.B. <code>optional</code> will not be part of the C++14 standard, it will be included in a separate Technical Specification on library fundamentals, so there is time to change the rule if my interpretation is wrong.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "19134895", "Score": "8", "CreationDate": "2013-10-02T10:31:18.913", "LastActivityDate": "2013-10-02T10:31:18.913"}, "bq_ids": {"n4140": {"so_19081133_19134895_0": {"section_id": 6299, "quality": 1.0, "length": 20}}, "n3337": {"so_19081133_19134895_0": {"section_id": 6056, "quality": 1.0, "length": 20}}, "n4659": {"so_19081133_19134895_0": {"section_id": 7808, "quality": 1.0, "length": 20}}}});