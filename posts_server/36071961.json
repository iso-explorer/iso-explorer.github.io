post_cb({"bq_ids": {"n4140": {"so_36071961_36071997_0": {"length": 19, "quality": 0.95, "section_id": 5972}}, "n3337": {"so_36071961_36071997_0": {"length": 13, "quality": 0.65, "section_id": 5740}}, "n4659": {"so_36071961_36071997_0": {"length": 19, "quality": 0.95, "section_id": 7471}}}, "36071961": {"ViewCount": "569", "Body": "<p>Why does this code compile with GCC (4.9 and 5+), but not with clang (3.5-3.9)?</p>\n<pre><code>void test(const int&amp;) { }\nint main() {\n  const int x = 42;\n  auto f = []{ test(x); };\n}\n</code></pre>\n<p>I have some vague idea that the discrepancy has to do with ODR (One Definition Rule) usage, but I don't understand that well enough to figure out what's going on here.</p>\n", "AcceptedAnswerId": "36071997", "Title": "Yet another clang/gcc discrepancy regarding ODR usage?", "CreationDate": "2016-03-17T21:24:44.930", "Id": "36071961", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-17T21:32:51.177", "LastEditorUserId": "827263", "LastActivityDate": "2016-03-17T21:46:51.213", "Score": "13", "OwnerUserId": "152060", "Tags": "<c++><c++11><g++><clang++><one-definition-rule>", "AnswerCount": "2"}, "36072197": {"Id": "36072197", "PostTypeId": "2", "Body": "<p>T.C. has the right diagnosis, here's a clearer bit of legal code where clang does the right thing and gcc doesn't:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid test(const int&amp;a) { std::cout &lt;&lt; \"in test() -- \" &lt;&lt; &amp;a &lt;&lt; \"\\n\"; }\nint main() {\n  const int x = 42;\n  std::cout &lt;&lt; \"in main() -- \" &lt;&lt; &amp;x &lt;&lt; \"\\n\";\n  auto f = [&amp;]{ test(x); };\n  f();\n}\n</code></pre>\n<p>gcc prints different addresses for a capture-by-reference variable than the original!</p>\n", "LastActivityDate": "2016-03-17T21:40:52.973", "CommentCount": "2", "CreationDate": "2016-03-17T21:40:52.973", "ParentId": "36071961", "Score": "8", "OwnerUserId": "103167"}, "36071997": {"Id": "36071997", "PostTypeId": "2", "Body": "<p><code>x</code> is odr-used because it's bound to a reference (<code>test</code>'s parameter). It therefore must be captured (<a href=\"http://eel.is/c++draft/expr.prim.lambda#13\" rel=\"noreferrer\">[expr.prim.lambda]/13</a>):</p>\n<blockquote>\n<p id=\"so_36071961_36071997_0\">If a <em>lambda-expression</em> or an instantiation of the function call\n  operator template of a generic lambda odr-uses ([basic.def.odr]) <code>this</code>\n  or a variable with automatic storage duration from its reaching scope,\n  that entity shall be captured by the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Violations of this rule, like all other rules in the standard that doesn't say \"no diagnostic required\" or \"undefined behavior\", <a href=\"http://eel.is/c++draft/intro.compliance#2\" rel=\"noreferrer\">require a diagnostic</a>.</p>\n<p>GCC, unfortunately, performs constant folding too early, before it could tell whether it's an odr-use or not. This can lead to problems <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70121\" rel=\"noreferrer\">such as <code>[&amp;]()-&gt;const int &amp; { return x; }</code> returning a dangling reference</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-03-17T21:46:51.213", "Score": "16", "CreationDate": "2016-03-17T21:27:10.410", "ParentId": "36071961", "CommentCount": "6", "OwnerUserId": "2756719", "LastEditDate": "2016-03-17T21:46:51.213"}});