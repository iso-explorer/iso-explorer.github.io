post_cb({"31500787": {"ViewCount": "631", "Body": "<p>I need to convert 2 bytes in <code>char pcm[]</code> to a 1 byte <code>short pcm_[]</code>. <a href=\"https://stackoverflow.com/questions/16851340/cast-char-to-short\">This</a> post used a C-style cast, which at first I tried out in my C++ program (using Qt):</p>\n<pre><code>#include &lt;QCoreApplication&gt;\n\n#include &lt;QDebug&gt;\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n\n    char pcm[2] = {0xA1, 0x12};\n    qDebug()&lt;&lt;pcm[0]&lt;&lt;pcm[1];\n\n    short pcm_ = ( pcm[1] &lt;&lt; 8 )| pcm[0];\n    qDebug()&lt;&lt;pcm_;\n\n    short pcm_2 =  ((unsigned char)(pcm[1])) &lt;&lt; 8| (unsigned char) pcm[0];\n    qDebug()&lt;&lt;pcm_2;\n\n    return a.exec();\n}\n</code></pre>\n<p>I figured out that it only works if I use <code>unsigned char</code> in the bit shifting, but do not understand, why this is necessary as the input is a <code>char</code>. </p>\n<p>Moreover, I would like to use C++-style-cast, and came up with this one:</p>\n<pre><code>short pcm_3 = (static_cast&lt;unsigned char&gt;(pcm[1])) &lt;&lt; 8|\n               static_cast&lt;unsigned char&gt;(pcm[0]);\nqDebug()&lt;&lt;pcm_3;\n</code></pre>\n<p>Again, I need to use <code>unsigned char</code> instead of <code>char</code>. </p>\n<p>So I have 2 questions: </p>\n<ul>\n<li>Is <code>static_cast</code> the right cast? In my mind is an example from somewhere that used a <code>reinterpret_cast</code>. However, the reinterpret cast does not work.</li>\n<li>Why do I have to use <code>unsigned char</code>?</li>\n</ul>\n", "Title": "Bit shifting `char` vs. `unsigned char`", "CreationDate": "2015-07-19T11:38:18.653", "LastActivityDate": "2015-07-19T12:25:42.290", "CommentCount": "4", "LastEditDate": "2017-05-23T12:06:06.113", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "31500787", "Score": "0", "OwnerUserId": "2366975", "Tags": "<c++><casting><bit-shift>", "AnswerCount": "5"}, "31501076": {"Id": "31501076", "PostTypeId": "2", "Body": "<p>The problem starts here:</p>\n<pre><code>char pcm[2] = {0xA1, 0x12};\n</code></pre>\n<p>On your system, <code>char</code> is signed, and has a range of <code>-128</code> through <code>127</code>. You try to assign <code>161</code> to a <code>char</code>. This is out of range.</p>\n<p>In C and C++ the result of out-of-range assignment is <em>implementation-defined</em>. Usually, the compiler decides to go with the char with the same representation, which is <code>-95</code> . </p>\n<p>Then you promote this to int (by virtue of using it as operand of <code>|</code>), giving the int value <code>-95</code> which has a representation starting with lots of <code>1</code> bits.</p>\n<p>If you actually want to work with the value <code>161</code> you will need to use a data type that can hold that value, such as <code>unsigned char</code>. The simplest way is to make <code>pcm[]</code> have that type, rather than using casts.</p>\n", "LastActivityDate": "2015-07-19T12:14:30.620", "CommentCount": "2", "CreationDate": "2015-07-19T12:14:30.620", "ParentId": "31500787", "Score": "1", "OwnerUserId": "1505939"}, "31500956": {"Id": "31500956", "PostTypeId": "2", "Body": "<p>According to the C Standard (6.5.11 Bitwise exclusive OR operator)</p>\n<pre><code>3 The usual arithmetic conversions are performed on the operands\n</code></pre>\n<p>The same is written in the C++ Standard (5.13 Bitwise inclusive OR operator)</p>\n<blockquote>\n<p id=\"so_31500787_31500956_0\">1 The usual arithmetic conversions are performed;</p>\n</blockquote>\n<p>The usual arithmetic conversions include the integer promotions. This means that in this expression</p>\n<pre><code>( pcm[1] &lt;&lt; 8 )| pcm[0];\n</code></pre>\n<p>operand <code>pcm[0]</code> is promoted to type <code>int</code>. If according to settings of your compiler type <code>char</code> behaves like type <code>signed char</code> then you get that value <code>0xA1</code> is promoted to signed int <code>0xFFFFFFA1</code> (provided that sizeof( int ) is equal to 4). That is the sign bit will be propogated.</p>\n<p>Hence you will get an incorrect result. To avoid it you shoud cast type <code>char</code> to type <code>unsigned char</code> In this case the promoted value will look like <code>0x000000A1</code>. In C++ it can be written like</p>\n<pre><code>static_cast&lt;unsigned char&gt;( pcm[0] ) \n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2015-07-19T12:19:26.730", "Score": "3", "CreationDate": "2015-07-19T11:59:40.907", "ParentId": "31500787", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2015-07-19T12:19:26.730"}, "bq_ids": {"n4140": {"so_31500787_31500956_0": {"length": 4, "quality": 0.8, "section_id": 5943}}, "n3337": {"so_31500787_31500956_0": {"length": 4, "quality": 0.8, "section_id": 5714}}, "n4659": {"so_31500787_31500956_0": {"length": 4, "quality": 0.8, "section_id": 7428}}}, "31500961": {"Id": "31500961", "PostTypeId": "2", "Body": "<p>You have to use <code>unsigned char</code> because of the promotion to <code>int</code> with <code>operator |</code></p>\n<p>Assuming <code>int</code> is 32 bits:</p>\n<ul>\n<li>signed char <code>0xA1</code> becomes int <code>0xFFFFFFA1</code> (to keep same value)</li>\n<li>unsigned char <code>0xA1</code> becomes <code>0x000000A1</code>.</li>\n</ul>\n", "LastActivityDate": "2015-07-19T11:59:58.730", "CommentCount": "0", "CreationDate": "2015-07-19T11:59:58.730", "ParentId": "31500787", "Score": "0", "OwnerUserId": "2684539"}, "31500965": {"Id": "31500965", "PostTypeId": "2", "Body": "<p>The reason you need to cast <code>char</code> to <code>unsigned char</code> is that <code>char</code> is allowed to be a signed data type. In this case it would be sign-extended before performing the <code>|</code>, meaning that the lower half would become negative for <code>char</code>s with the most significant bit set to <code>1</code>:</p>\n<pre><code>char c = 200;\nint a = c | 0; // returns -56 on systems where char is signed \n</code></pre>\n<p>In this example using <code>static_cast</code> or the C cast is a matter of style. Many C++ shops stay away from C casts, because they are harder to find in the source code, while <code>static_cast</code>s are much easier to spot.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2015-07-19T12:25:42.290", "Score": "0", "CreationDate": "2015-07-19T12:00:53.800", "ParentId": "31500787", "CommentCount": "0", "OwnerUserId": "335858", "LastEditDate": "2015-07-19T12:25:42.290"}, "31501005": {"Id": "31501005", "PostTypeId": "2", "Body": "<ol>\n<li>You shall cast data type to unsigned, because when you \"expand\" a signed character to signed short it's 7th bit gets replicated to bits 8-15 of the short.\nSo, from <code>A1</code> which is <code>10100001</code> you get <code>1111111110100001</code>.</li>\n<li>According to <a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used\">this question and answer</a>, reinterpret_cast is the last cast you should think of.</li>\n</ol>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-19T12:07:01.547", "Score": "0", "CreationDate": "2015-07-19T12:07:01.547", "ParentId": "31500787", "CommentCount": "0", "OwnerUserId": "5128826", "LastEditDate": "2017-05-23T12:06:06.113"}});