post_cb({"6893116": {"CommentCount": "3", "AcceptedAnswerId": "6893141", "CreationDate": "2011-07-31T23:49:50.497", "LastActivityDate": "2011-08-01T12:46:27.637", "PostTypeId": "1", "ViewCount": "337", "FavoriteCount": "1", "Title": "Is writing to memory an observable behaviour?", "Id": "6893116", "Score": "13", "Body": "<p>I've looked at the standard but couldn't find any indication that simply writing to memory would be considered observable behaviour. If not, that would mean the compiled code need not actually write to that memory. If a compiler choose to optimize away such access anything involving mapper memory, or shared memory, may not work.</p>\n<p>1.9-8 seems to defined a very limited observable behaviour but indicates an implementation may define more. Can one assume than any quality compiler would treat modifying memory as an observable behaviour?  That is, it may not guarantee atomicity or ordering, but does guarantee that data will eventually be written.</p>\n<p>So, have I overlooked something in the standard, or is the writing to memory merely something the compiler decides to do?</p>\n<p><em>Statements from the current or C++0x standard are good. Please note I'm not talking about accessing memory through a function, I mean direct access, such as writing data to a pointer (perhaps retrieved via mmap or another library function).</em></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "229686", "AnswerCount": "3"}, "6893229": {"ParentId": "6893116", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_6893116_6893229_0\">Can one assume than any quality compiler would treat modifying memory as an observable behaviour?</p>\n</blockquote>\n<p>No. Volatile is meant for marking that. However, you cannot fully trust the compiler even after adding the volatile qualifier, at least as told by a 2008 paper: <a href=\"http://www.cs.utah.edu/~regehr/papers/emsoft08-preprint.pdf\" rel=\"nofollow\">http://www.cs.utah.edu/~regehr/papers/emsoft08-preprint.pdf</a></p>\n<p><strong>EDIT:</strong></p>\n<p>From C standard (not C++) <a href=\"http://c0x.coding-guidelines.com/5.1.2.3.html\" rel=\"nofollow\">http://c0x.coding-guidelines.com/5.1.2.3.html</a></p>\n<blockquote>\n<p id=\"so_6893116_6893229_1\">An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).</p>\n</blockquote>\n", "Id": "6893229", "LastEditDate": "2011-08-01T00:29:22.513", "OwnerDisplayName": "user765770", "Score": "2", "CreationDate": "2011-08-01T00:18:56.403", "LastActivityDate": "2011-08-01T00:29:22.513", "LastEditorDisplayName": "user765770"}, "6893278": {"ParentId": "6893116", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>My reading of C99 is that unless you specify <code>volatile</code>, how and when the variable is actually accessed is implementation defined. If you specify <code>volatile</code> qualifier then code must work according to the rules of an <em>abstract machine</em>.</p>\n<p>Relevant parts in the standard are: <code>6.7.3 Type qualifiers</code> (<code>volatile</code> description) and <code>5.1.2.3 Program execution</code> (the <em>abstract machine definition</em>).</p>\n<p>For some time now I know that many compilers actually have heuristics to detect cases when a variable should be reread again and when it is okay to use a cached copy. Volatile makes it clear to the compiler that every access to the variable should be actually an access to the memory. Without volatile it seems compiler is free to never reread the variable.</p>\n<p>And BTW wrapping the access in a function doesn't change that since a function even without inline might be still inlined by the compiler within the current compilation unit.</p>\n<p>From your question below:</p>\n<blockquote>\n<p id=\"so_6893116_6893278_0\">Assume I use an array on the heap (unspecified where it is allocated),\n  and I use that array to perform a calculation (temp space). The\n  optimizer sees that it doesn't actually need any of that space as it\n  can use strictly registers. Does the compiler nonetheless write the\n  temp values to the memory?</p>\n</blockquote>\n<p><strong>Per MSalters below:</strong></p>\n<blockquote>\n<p id=\"so_6893116_6893278_1\">It's not guaranteed, and unlikely. Consider a a Static Single\n  Assignment optimizer. This figures out each possible write/read\n  dependency, and then assigns registers to optimize these dependencies.\n  As a side effect, any write that's not followed by a (possible) read\n  creates no dependencies at all, and is eliminated. In your example\n  (\"use strictly registers\") the optimizer has satisfied all write/read\n  dependencies with registers, so it won't write to memory at all. All\n  reads produce the correct values, so it's a correct optimization.</p>\n</blockquote>\n", "Id": "6893278", "LastEditDate": "2011-08-01T12:46:27.637", "OwnerDisplayName": "user195488", "Score": "1", "CreationDate": "2011-08-01T00:34:40.333", "LastActivityDate": "2011-08-01T12:46:27.637", "LastEditorDisplayName": "user195488"}, "bq_ids": {"n4140": {"so_6893116_6893229_1": {"section_id": 5797, "quality": 0.6190476190476191, "length": 13}}, "n3337": {"so_6893116_6893229_1": {"section_id": 5570, "quality": 0.6190476190476191, "length": 13}}, "n4659": {"so_6893116_6893229_1": {"section_id": 7256, "quality": 0.6190476190476191, "length": 13}}}, "6893141": {"ParentId": "6893116", "CommentCount": "6", "CreationDate": "2011-07-31T23:54:39.507", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6893141", "Score": "9", "Body": "<p>This kind of thing is what <code>volatile</code> exists for. Else, writing to memory and never apparently reading from it is not observable behaviour. However, in the general case, it would be quite impossible for the optimizer to prove that you never read it back except in relatively trivial examples, so it's not usually an issue.</p>\n", "LastActivityDate": "2011-07-31T23:54:39.507"}});