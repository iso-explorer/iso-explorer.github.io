post_cb({"bq_ids": {"n4140": {"so_13316727_13316839_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 224}, "so_13316727_13316839_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}, "so_13316727_13316839_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}}, "n3337": {"so_13316727_13316839_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 217}, "so_13316727_13316839_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}, "so_13316727_13316839_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}}, "n4659": {"so_13316727_13316839_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 232}, "so_13316727_13316839_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}, "so_13316727_13316839_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}}}, "13316839": {"Id": "13316839", "PostTypeId": "2", "Body": "<p>I think the rule is 14.6.4.2p1:</p>\n<blockquote>\n<p id=\"so_13316727_13316839_0\">For a function call that depends on a template parameter, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2, 3.4.3) except that:</p>\n<p id=\"so_13316727_13316839_1\">\u2014 For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only\n  function declarations from the template definition context are found.</p>\n<p id=\"so_13316727_13316839_2\">\u2014 For the part of the lookup using associated namespaces (3.4.2), only\n  function declarations found in either the template definition context\n  or the template instantiation context are found.</p>\n</blockquote>\n<p><code>void foo(n::A) {}</code> is <strong>not visible</strong> in the template definition context because it comes after and <code>foo</code> is not in the same namespace as <code>n::A</code>. So it needs to be either visible <em>before</em> the template definition or included in the same namespace like below:</p>\n<pre><code>namespace n\n{\n    void foo(n::A) {}\n}\n</code></pre>\n", "LastEditorUserId": "906773", "LastActivityDate": "2012-11-09T22:35:27.490", "Score": "2", "CreationDate": "2012-11-09T22:17:27.870", "ParentId": "13316727", "CommentCount": "5", "OwnerUserId": "906773", "LastEditDate": "2012-11-09T22:35:27.490"}, "13316727": {"ViewCount": "352", "Body": "<p>Consider the following C++ code example:</p>\n<pre><code>namespace n\n{\n    struct A {};\n}\n\nstruct B {};\n\nvoid foo(int) {}\n\ntemplate&lt;typename T&gt;\nvoid quux()\n{\n    foo(T());\n}\n\nvoid foo(n::A) {}\nvoid foo(B) {}\n\n\nint main()\n{\n    quux&lt;n::A&gt;(); // Error (but works if you comment out the foo(int) declaration)\n    quux&lt;B&gt;();    // Works\n\n    return 0;\n}\n</code></pre>\n<p>As indicated in the comment, the template instantiation <code>quux&lt;n::A&gt;()</code> causes a compiler error (on GCC 4.6.3):</p>\n<pre><code>foo.cpp: In function \u2018void quux() [with T = n::A]\u2019:\nfoo.cpp:22:16:   instantiated from here\nfoo.cpp:13:5: error: cannot convert \u2018n::A\u2019 to \u2018int\u2019 for argument \u20181\u2019 to \u2018void foo(int)\u2019\n</code></pre>\n<p>Can someone explain to me what is going on? I would have expected for it to work the same as with <code>quux&lt;B&gt;()</code>. It must have something to do with when <code>foo</code> is considered dependent. Unfortunately my C++ foo is not good enough. The example compiles fine, when the <code>foo(int)</code> declaration is not present, which is also surprising to me.</p>\n<p>Any hints, explanations and workarounds are welcome.</p>\n<p><strong>Update 1:</strong></p>\n<p>I do not want to (read cannot) move the declaration of <code>foo(n::A)</code> before the definition of <code>quux</code> (which would avoid the error).</p>\n<p><strong>Update 2:</strong></p>\n<p>Thanks for David for pointing out the related question <a href=\"https://stackoverflow.com/questions/13223278/template-function-call-confused-by-function-with-wrong-signature-declared-before\">Template function call confused by function with wrong signature declared before template</a>. The accepted answer by Johannes Schaub - litb proposes a wrapper class solution, that would also work in my case as a workaround. However, I'm not 100% happy with it.</p>\n<p><strong>Update 3:</strong></p>\n<p>I solved the issue by putting the definition of <code>foo(n::A)</code> in namespace <code>n</code>. Thanks for the helpful answers of Jesse Good and bames53 that not only point out the relevant sections of the standard, but also provide alternative solutions. Thanks to David Rodr\u00edguez - dribeas for his explanation when I did not understand the proposed solutions properly and all other contributors.</p>\n", "AcceptedAnswerId": "13316839", "Title": "Name resolution of functions inside templates instantiated with qualified types", "CreationDate": "2012-11-09T22:06:04.737", "Id": "13316727", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:12:21.323", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-12T21:54:42.260", "Score": "7", "OwnerUserId": "1813258", "Tags": "<c++><templates><namespaces><overloading><name-lookup>", "AnswerCount": "2"}, "13346637": {"Id": "13346637", "PostTypeId": "2", "Body": "<p>The error my compiler gives is:</p>\n<pre><code>main.cpp:11:5: error: call to function 'foo' that is neither visible in the template definition nor found by argument-dependent lookup\n    foo(T());\n    ^\nmain.cpp:18:5: note: in instantiation of function template specialization 'quux&lt;n::A&gt;' requested here\n    quux&lt;n::A&gt;(); // Error (but works if you comment out the foo(int) declaration)\n    ^\nmain.cpp:14:6: note: 'foo' should be declared prior to the call site or in namespace 'n'\nvoid foo(n::A) {}\n     ^\n</code></pre>\n<p>Which makes it clear what the problem is.</p>\n<p>Commenting out <code>void foo(int)</code> <em>does not</em> make it work however; that's just a bug/extension in your compiler.</p>\n<p>You mention that you can't define <code>void foo(n::A)</code> before <code>quux()</code>, however when you say in the comments that you can't define it inside namespace <code>n</code>, the reasons you give don't seem to apply. This should fix the problem without the other problems you mention.</p>\n<pre><code>template&lt;typename T&gt;\nvoid quux()\n{\n    foo(T());\n}\n\nnamespace n {\n    void foo(n::A) {}\n}\nusing n::foo; // in case there's any other code that depends on getting foo(n::A) from the global namespace\n\nvoid foo(B) {} // this stays in the global namespace\n</code></pre>\n<hr>\n<p>If you can't move the definition of <code>void foo(n::A)</code> to where it works with proper two-phase lookup (again, either before <code>quux()</code> <em>or</em> inside namespace <code>n</code>) there's a sort of hacky solution which may work for you: forward declare the proper overload of <code>foo()</code> <em>inside</em> <code>quux()</code>.</p>\n<pre><code>template&lt;typename T&gt;\nvoid quux()\n{\n    void foo(T);\n    foo(T());\n}\n</code></pre>\n<p>The function eventually must be defined inside the same namespace as <code>quux()</code> and it has to match the 'generic' forward declaration.</p>\n<hr>\n<p>Or there's another alternative. It's only been fairly recent that most C++ compilers started offering correct two-phase name lookup, so there's a lot of code out there that isn't correct but which compilers want to support. If you can't change your code then it may be a good candidate for enabling a compatibility compiler option; my compiler takes the flag <code>-fdelayed-template-parsing</code> to disable two-phase name lookup and instead always look names up in the instantiation context.</p>\n</hr></hr>", "LastEditorUserId": "365496", "LastActivityDate": "2012-11-12T17:21:16.043", "Score": "1", "CreationDate": "2012-11-12T15:35:33.847", "ParentId": "13316727", "CommentCount": "4", "OwnerUserId": "365496", "LastEditDate": "2012-11-12T17:21:16.043"}});