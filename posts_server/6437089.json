post_cb({"6437202": {"ParentId": "6437089", "CommentCount": "0", "Body": "<p>As Mat pointed out, it depends on whether you need to access your elements in sorted order.  Also, map has <em>guaranteed</em>, <em>worst-case</em> logarithmic access time (in the number of elements), whereas unordered map has <em>average</em> constant access time.</p>\n", "OwnerUserId": "2583", "PostTypeId": "2", "Id": "6437202", "Score": "1", "CreationDate": "2011-06-22T08:46:56.010", "LastActivityDate": "2011-06-22T08:46:56.010"}, "6437089": {"CommentCount": "1", "AcceptedAnswerId": "6437148", "PostTypeId": "1", "LastEditorUserId": "469935", "CreationDate": "2011-06-22T08:37:17.853", "LastActivityDate": "2011-06-22T14:40:12.167", "LastEditDate": "2011-06-22T08:41:27.950", "ViewCount": "81", "FavoriteCount": "1", "Title": "what is the uses cases in which order in key value associative container is useful", "Id": "6437089", "Score": "2", "Body": "<p>I am wondering in which uses cases, we can be interested by having an ordered associative container.</p>\n<p>In other terms, why use <code>std::map</code> and no <code>std::unorderd_map</code></p>\n", "Tags": "<c++>", "OwnerUserId": "619570", "AnswerCount": "5"}, "6437154": {"ParentId": "6437089", "CommentCount": "0", "Body": "<p>Unordered_map use more memory than map. If there is a constraint in memory then its recommended to use map. So the operations become slower when using unordered_map</p>\n<p><strong>EDIT</strong></p>\n<p>Quoting from the wiki article</p>\n<pre><code>It is similar to the map class in the C++ standard library but has different \nconstraints. As its name implies, unlike the map class, the elements of an \nunordered_map are not ordered. This is due to the use of hashing to store objects.\nunordered_map can still be iterated through like a regular map.\n</code></pre>\n", "OwnerUserId": "791287", "PostTypeId": "2", "Id": "6437154", "Score": "-1", "CreationDate": "2011-06-22T08:42:56.200", "LastActivityDate": "2011-06-22T08:42:56.200"}, "6437148": {"ParentId": "6437089", "CommentCount": "2", "Body": "<p>You use an ordered map when you need to be able to iterate over the keys in an ordered fashion.</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "6437148", "Score": "5", "CreationDate": "2011-06-22T08:42:22.113", "LastActivityDate": "2011-06-22T08:42:22.113"}, "6437922": {"ParentId": "6437089", "CommentCount": "0", "Body": "<p>The main reason for using <code>map</code> instead of <code>unordered_map</code> is that <code>map</code> is in standard and for sure you have it. Some companies have policy not to use definitions from <code>tr1</code>.<br>\nBut you ask when order is important - it is needed for operations like <code>lower_bound</code>, <code>upper_bound</code>, <code>set_union</code>, <code>set_intersection</code> etc.</br></p>\n", "OwnerUserId": "113662", "PostTypeId": "2", "Id": "6437922", "Score": "1", "CreationDate": "2011-06-22T09:47:59.013", "LastActivityDate": "2011-06-22T09:47:59.013"}, "6441763": {"ParentId": "6437089", "CommentCount": "0", "Body": "<p>If the comparison between unordered containers is needed, the complexity\nmight be an issue.<br>\nIt seems to be difficult to implement <code>operator==</code>/<code>operator!=</code> between\nunordered containers efficiently.<br>\nN3290 \u00a723.2.5/11 says</br></br></p>\n<blockquote>\n<p id=\"so_6437089_6441763_0\">the complexity of operator== ... is\n  proportional to ... N^2 in the worst\n  case, where N is a.size().</p>\n</blockquote>\n<p>while other containers have linear complexity.</p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "6441763", "Score": "1", "CreationDate": "2011-06-22T14:40:12.167", "LastActivityDate": "2011-06-22T14:40:12.167"}, "bq_ids": {"n4140": {"so_6437089_6441763_0": {"section_id": 764, "quality": 1.0, "length": 7}}, "n3337": {"so_6437089_6441763_0": {"section_id": 751, "quality": 1.0, "length": 7}}, "n4659": {"so_6437089_6441763_0": {"section_id": 824, "quality": 1.0, "length": 7}}}});