post_cb({"449823": {"CommentCount": "0", "CreationDate": "2009-01-16T08:20:33.037", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-18T15:27:38.987", "ParentId": "449436", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastEditDate": "2017-05-23T12:17:47.357", "Id": "449823", "Score": "31", "Body": "<p>In C++11 it is thread safe:</p>\n<blockquote>\n<p id=\"so_449436_449823_0\">\u00a76.7 [stmt.dcl] p4 If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>In C++03:  </p>\n<ul>\n<li>Under g++ it is thread safe.<br>\nBut this is because g++ explicitly adds code to guarantee it.</br></li>\n</ul>\n<p>One problem is that if you have two singletons and they try and use each other during construction and destruction.</p>\n<p>Read this:\n<a href=\"https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems#335746\">Finding C++ static initialization order problems</a></p>\n<p>A variation on this problem is if the singleton is accessed from the destructor of a global variable. In this situation the singleton has definitely been destroyed, but the get method will still return a reference to the destroyed object.</p>\n<p>There are ways around this but they are messy and not worth doing. Just don't access a singleton from the destructor of a global variable.</p>\n<p>A Safer definition but ugly:<br>\nI am sure you can add some appropriate macros to tidy this up</br></p>\n<pre><code>SomeBaseClass &amp;SomeClass::GetInstance()\n{\n#ifdef _WIN32 \nStart Critical Section Here\n#elif  defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3)\n// You are OK\n#else\n#error Add Critical Section for your platform\n#endif\n\n    static SomeClass instance;\n\n#ifdef _WIN32\nEND Critical Section Here\n#endif \n\n    return instance;\n}\n</code></pre>\n", "OwnerUserId": "14065", "OwnerDisplayName": "Martin York"}, "449436": {"CommentCount": "0", "ViewCount": "26713", "OwnerDisplayName": "Dmitriy Matveev", "CreationDate": "2009-01-16T03:44:31.143", "LastActivityDate": "2012-08-18T15:27:38.987", "PostTypeId": "1", "AcceptedAnswerId": "449823", "FavoriteCount": "19", "Title": "Singleton instance declared as static variable of GetInstance method", "Id": "449436", "Score": "24", "Body": "<p>I've seen implementations of Singleton patterns where instance variable was declared as static variable in GetInstance method. Like this:</p>\n<pre><code>SomeBaseClass &amp;SomeClass::GetInstance()\n{\n   static SomeClass instance;\n   return instance;\n}\n</code></pre>\n<p>I see following positive sides of this approach:</p>\n<ul>\n<li>The code is simpler, because it's compiler who responsible for creating this object only when GetInstance called for the first time.</li>\n<li>The code is safer, because there is no other way to get reference to instance, but with GetInstance method and there is no other way to change instance, but inside GetInstance method.</li>\n</ul>\n<p>What are the negative sides of this approach (except that this is not very OOP-ish) ? Is this thread-safe?</p>\n", "Tags": "<c++><design><design-patterns><singleton>", "OwnerUserId": "53481", "AnswerCount": "4"}, "3513732": {"ParentId": "449436", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to specs this should also work in VC++. Anyone know if it does?</p>\n<p>Just add keyword volatile.\nThe visual c++ compiler should then generate mutexes if the doc on msdn is correct.</p>\n<pre><code>SomeBaseClass &amp;SomeClass::GetInstance()\n{\n   static volatile SomeClass instance;\n   return instance;\n}\n</code></pre>\n", "OwnerUserId": "424188", "LastEditorUserId": "701988", "LastEditDate": "2012-01-05T08:51:14.863", "Id": "3513732", "Score": "2", "CreationDate": "2010-08-18T15:25:31.520", "LastActivityDate": "2012-01-05T08:51:14.863"}, "449488": {"ParentId": "449436", "CommentCount": "14", "Body": "<p>It shares all of the common failings of Singleton implementations, namely:</p>\n<ul>\n<li><a href=\"http://googletesting.blogspot.com/2008/08/by-miko-hevery-so-you-decided-to.html\" rel=\"nofollow noreferrer\">It is untestable</a></li>\n<li>It is not thread safe (this is trivial enough to see if you imagine two threads entering the function at the same time)</li>\n<li>It is a memory leak</li>\n</ul>\n<p>I recommend never using Singleton in any production code.</p>\n", "OwnerUserId": "3146", "Id": "449488", "PostTypeId": "2", "OwnerDisplayName": "1800 INFORMATION", "Score": "-6", "CreationDate": "2009-01-16T04:07:43.720", "LastActivityDate": "2009-01-16T04:07:43.720"}, "449681": {"ParentId": "449436", "CommentCount": "3", "Body": "<p>It is not thread safe as shown. The C++ language is silent on threads so you have no inherent guarantees from the language. You will have to use platform synchronization primitives, e.g. Win32 ::EnterCriticalSection(), to protect access.</p>\n<p>Your particular approach would be problematic b/c the compiler will insert some (non-thread safe) code to initialize the static <code>instance</code> on first invocation, most likely it will be before the function body begins execution (and hence before any synchronization can be invoked.)</p>\n<p>Using a global/static member pointer to <code>SomeClass</code> and then initializing within a synchronized block would prove less problematic to implement.</p>\n<pre><code>#include &lt;boost/shared_ptr.hpp&gt;\n\nnamespace\n{\n  //Could be implemented as private member of SomeClass instead..\n  boost::shared_ptr&lt;SomeClass&gt; g_instance;\n}\n\nSomeBaseClass &amp;SomeClass::GetInstance()\n{\n   //Synchronize me e.g. ::EnterCriticalSection()\n   if(g_instance == NULL)\n     g_instance = boost::shared_ptr&lt;SomeClass&gt;(new SomeClass());\n   //Unsynchronize me e.g. :::LeaveCriticalSection();\n   return *g_instance;\n}\n</code></pre>\n<p>I haven't compiled this so it's for illustrative purposes only. It also relies on the boost library to obtain the same lifetime (or there about) as your original example. You can also use std::tr1 (C++0x).</p>\n", "OwnerUserId": "4613", "Id": "449681", "PostTypeId": "2", "OwnerDisplayName": "Henk", "Score": "6", "CreationDate": "2009-01-16T06:32:39.213", "LastActivityDate": "2009-01-16T06:32:39.213"}, "bq_ids": {"n4140": {"so_449436_449823_0": {"section_id": 3919, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_449436_449823_0": {"section_id": 3779, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_449436_449823_0": {"section_id": 4805, "quality": 0.9285714285714286, "length": 13}}}});