post_cb({"29808457": {"Id": "29808457", "PostTypeId": "2", "Body": "<p><code>abs(INT_MIN)</code> will invoke undefined behavior. Standard says  </p>\n<h3>7.22.6.1 The <code>abs</code>, <code>labs</code> and <code>llabs</code> functions:</h3>\n<blockquote>\n<p id=\"so_29808397_29808457_0\">The <code>abs</code>, <code>labs</code>, and <code>llabs</code> functions compute the absolute value of an integer <code>j</code>. If the result cannot be represented, the behavior is undefined.  </p>\n</blockquote>\n<p>Try this instead  :<br>\nConvert <code>INT_MIN</code> to <code>unsignrd int</code>. Since -ve numbers can't be represented as an <code>unsigned int</code>, <code>INT_MAX</code> will be converted to <code>UINT_MAX + 1 + INT_MIN</code>. </br></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nunsigned min(unsigned a, unsigned b)\n{\n    return a &lt; b ? a : b;\n}\n\nint main(void)\n{\n    printf(\"%u\\n\", min(INT_MAX, INT_MIN));\n}  \n</code></pre>\n", "LastEditorUserId": "2455888", "LastActivityDate": "2015-04-23T05:06:16.673", "Score": "0", "CreationDate": "2015-04-22T20:46:25.177", "ParentId": "29808397", "CommentCount": "9", "OwnerUserId": "2455888", "LastEditDate": "2015-04-23T05:06:16.673"}, "29808461": {"Id": "29808461", "PostTypeId": "2", "Body": "<pre><code>INT_MAX + INT_MIN &lt; 0 ? INT_MAX : -INT_MIN\n</code></pre>\n<p><em>Edited to add explanation:</em> Of course the difficulty is that <code>-INT_MIN</code> or <code>abs(INT_MIN)</code> will be undefined if <code>-INT_MIN</code> is too big to fit in an <code>int</code>. So we need some way of checking whether this is the case. The condition <code>INT_MAX + INT_MIN &lt; 0</code> tests whether <code>-INT_MIN</code> is greater than <code>INT_MAX</code>. If it is, then <code>INT_MAX</code> is the smaller of the two absolute values. If not, then <code>INT_MAX</code> is the larger of the two absolute values, and <code>-INT_MIN</code> is the correct answer.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2015-04-22T20:52:59.230", "Score": "10", "CreationDate": "2015-04-22T20:46:36.157", "ParentId": "29808397", "CommentCount": "10", "OwnerUserId": "481267", "LastEditDate": "2015-04-22T20:52:59.230"}, "29809849": {"Id": "29809849", "PostTypeId": "2", "Body": "<p>While the <em>typical</em> value of <code>INT_MIN</code> is -2147483648, and the <em>typical</em> value of <code>INT_MAX</code> is 2147483647, it is not guaranteed by the standard. TL;DR: The value you're searching for is <code>INT_MAX</code> in a conforming implementation. But <em>calculating</em> <code>min(INT_MAX, abs(INT_MIN))</code> isn't portable.</p>\n<hr>\n<h2>The possible values of <code>INT_MIN</code> and <code>INT_MAX</code></h2>\n<p><code>INT_MIN</code> and <code>INT_MAX</code> are defined by the Annex E (Implementation limits) 1 (C standard, C++ inherits this stuff):</p>\n<blockquote>\n<p id=\"so_29808397_29809849_0\">The contents of the header  are given below, in alphabetical\n  order. The minimum magnitudes shown shall be replaced by\n  implementation-defined magnitudes with the same sign. The values shall\n  all be constant expressions suitable for use in #if preprocessing\n  directives. The components are described further in 5.2.4.2.1.</p>\n<p id=\"so_29808397_29809849_1\">[...]</p>\n<p id=\"so_29808397_29809849_2\"><code>#define INT_MAX +32767</code></p>\n<p id=\"so_29808397_29809849_3\"><code>#define INT_MIN -32767</code></p>\n<p id=\"so_29808397_29809849_4\">[...]</p>\n</blockquote>\n<p>The standard requires the type <code>int</code> to be an integer type that can represent the range <code>[INT_MIN, INT_MAX]</code> (section 5.2.4.2.1.).</p>\n<p>Then, 6.2.6.2. (Integer types, again part of the C standard), comes into play and further restricts this to what we know as <em>two's or ones' complement</em>:</p>\n<blockquote>\n<p id=\"so_29808397_29809849_5\">For signed integer types, the bits of the object representation shall be divided into three\n  groups: value bits, padding bits, and the sign bit. There need not be any padding bits;\n  signed char shall not have any padding bits. There shall be exactly one sign bit.\n  Each bit that is a value bit shall have the same value as the same bit in the object\n  representation of the corresponding unsigned type (if there are M value bits in the signed\n  type and N in the unsigned type, then M \u2264 N). If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, the value shall be modified in one of the\n  following ways:</p>\n<p id=\"so_29808397_29809849_6\">\u2014 the corresponding value with sign bit 0 is negated (sign and magnitude);</p>\n<p id=\"so_29808397_29809849_7\">\u2014 the sign bit has the value \u2212(2M) (two\u2019s complement);</p>\n<p id=\"so_29808397_29809849_8\">\u2014 the sign bit has the value \u2212(2M \u2212 1) (ones\u2019 complement).</p>\n</blockquote>\n<p>Section 6.2.6.2. is also very important to relate the value representation of the signed integer types with the value representation of its unsigned siblings.</p>\n<p>This means, you either get the range <code>[-(2^n - 1), (2^n - 1)]</code> or <code>[-2^n, (2^n - 1)]</code>, where <code>n</code> is <em>typically</em> 15 or 31.</p>\n<h2>Operations on signed integer types</h2>\n<p>Now for the second thing: Operations on signed integer types, that result in a value that is not within the range <code>[INT_MIN, INT_MAX]</code>, the behavior is undefined. This is explicitly mandated in C++ by Paragraph 5/4:</p>\n<blockquote>\n<p id=\"so_29808397_29809849_9\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of\n  representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>For C, 6.5/5 offers a very similar passage:</p>\n<blockquote>\n<p id=\"so_29808397_29809849_10\">If an exceptional condition occurs during the evaluation of an expression (that is, if the\n  result is not mathematically defined or not in the range of representable values for its\n  type), the behavior is undefined.</p>\n</blockquote>\n<p>So what happens if the value of <code>INT_MIN</code> happens to be less than the negative of <code>INT_MAX</code> (e.g. -32768 and 32767 respectively)? Calculating <code>-(INT_MIN)</code> will be undefined, the same as <code>INT_MAX + 1</code>.</p>\n<p>So we need to avoid ever calculating a value that may isn't in the range of <code>[INT_MIN, INT_MAX]</code>. Lucky, <code>INT_MAX + INT_MIN</code> is always in that range, as <code>INT_MAX</code> is a strictly positive value and <code>INT_MIN</code> a strictly negative value. Hence <code>INT_MIN &lt; INT_MAX + INT_MIN &lt; INT_MAX</code>.</p>\n<p>Now we can check, whether, <code>INT_MAX + INT_MIN</code> is equal to, less than, or greater than 0.</p>\n<pre><code>`INT_MAX + INT_MIN`  |  value of -INT_MIN    | value of -INT_MAX \n------------------------------------------------------------------\n         &lt; 0         |  undefined            | -INT_MAX\n         = 0         |  INT_MAX = -INT_MIN   | -INT_MAX = INT_MIN\n         &gt; 0         |  cannot occur according to 6.2.6.2. of the C standard\n</code></pre>\n<p>Hence, to determine the minimum of <code>INT_MAX</code> and <code>-INT_MIN</code> (in the mathematical sense), the following code is sufficient:</p>\n<pre><code>if ( INT_MAX + INT_MIN == 0 )\n{\n    return INT_MAX; // or -INT_MIN, it doesn't matter\n}\nelse if ( INT_MAX + INT_MIN &lt; 0 )\n{\n    return INT_MAX; // INT_MAX is smaller, -INT_MIN cannot be represented.\n}\nelse // ( INT_MAX + INT_MIN &gt; 0 )\n{\n    return -INT_MIN; // -INT_MIN is actually smaller than INT_MAX, may not occur in a conforming implementation.\n}\n</code></pre>\n<p>Or, to simplify:</p>\n<pre><code>return (INT_MAX + INT_MIN &lt;= 0) ? INT_MAX : -INT_MIN;\n</code></pre>\n<p>The values in a ternary operator will only be evaluated if necessary. Hence, <code>-INT_MIN</code> is either left unevaluated (therefore cannot produce UB), or is a well-defined value.</p>\n<p>Or, if you want an assertion:</p>\n<pre><code>assert(INT_MAX + INT_MIN &lt;= 0);\nreturn INT_MAX;\n</code></pre>\n<p>Or, if you want that at compile time:</p>\n<pre><code>static_assert(INT_MAX + INT_MIN &lt;= 0, \"non-conforming implementation\");\nreturn INT_MAX;\n</code></pre>\n<hr>\n<h2>Getting integer operations right (i.e. if correctness matters)</h2>\n<p>If you're interested in safe integer arithmetic, have a look at my <a href=\"http://ideone.com/bGClJX\" rel=\"nofollow\">implementation of safe integer operations</a>. If you want to see the patterns (rather than this lengthy text output) on which operations fail and which succeed, choose <a href=\"http://ideone.com/p9FqHn\" rel=\"nofollow\">this demo</a>.</p>\n<p>Depending on the architecture, there may be other options to ensure correctness, such as gcc's option <code>-ftrapv</code>.</p>\n</hr></hr>", "LastEditorUserId": "985296", "LastActivityDate": "2015-04-23T13:30:50.107", "Score": "22", "CreationDate": "2015-04-22T22:11:17.843", "ParentId": "29808397", "CommentCount": "4", "OwnerUserId": "985296", "LastEditDate": "2015-04-23T13:30:50.107"}, "bq_ids": {"n4140": {"so_29808397_29809849_9": {"length": 13, "quality": 1.0, "section_id": 5937}, "so_29808397_29809849_10": {"length": 13, "quality": 0.8125, "section_id": 5937}}, "n3337": {"so_29808397_29809849_9": {"length": 13, "quality": 1.0, "section_id": 5709}, "so_29808397_29809849_10": {"length": 13, "quality": 0.8125, "section_id": 5709}}, "n4659": {"so_29808397_29809849_9": {"length": 13, "quality": 1.0, "section_id": 7421}, "so_29808397_29809849_10": {"length": 13, "quality": 0.8125, "section_id": 7421}}}, "29808397": {"ViewCount": "2716", "Body": "<p>How can I portably find out the smallest of <code>INT_MAX</code> and abs(<code>INT_MIN</code>)? (That's the mathematical absolute value of <code>INT_MIN</code>, not a call to the <code>abs</code> function.)</p>\n<p>It should be as same as <code>INT_MAX</code> in most systems, but I'm looking for a more portable way.</p>\n", "AcceptedAnswerId": "29809849", "Title": "How to portably find out min(INT_MAX, abs(INT_MIN))?", "CreationDate": "2015-04-22T20:42:37.120", "Id": "29808397", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-05-09T21:13:24.673", "LastEditorUserId": "442945", "LastActivityDate": "2015-05-09T21:13:24.673", "Score": "29", "OwnerUserId": "3998522", "Tags": "<c++><c><math><limits>", "AnswerCount": "6"}, "29808442": {"Id": "29808442", "PostTypeId": "2", "Body": "<p>On most systems, abs (INT_MIN) is not defined. For example, on typical 32 bit machines, INT_MAX = 2^31 - 1, INT_MIN = - 2^31, and abs (INT_MIN) cannot be 2^31. </p>\n", "LastActivityDate": "2015-04-22T20:45:31.673", "CommentCount": "1", "CreationDate": "2015-04-22T20:45:31.673", "ParentId": "29808397", "Score": "0", "OwnerUserId": "3255455"}, "29808571": {"Id": "29808571", "PostTypeId": "2", "Body": "<p><code>-INT_MAX</code> is representable as an <code>int</code> in all C and C++ dialects, as far as I know. Therefore:</p>\n<pre><code>-INT_MAX &lt;= INT_MIN ? -INT_MIN : INT_MAX\n</code></pre>\n", "LastActivityDate": "2015-04-22T20:52:07.563", "CommentCount": "0", "CreationDate": "2015-04-22T20:52:07.563", "ParentId": "29808397", "Score": "1", "OwnerUserId": "387076"}, "29808593": {"Id": "29808593", "PostTypeId": "2", "Body": "<p>In C99 and above, <code>INT_MAX</code>.</p>\n<p>Quoth the spec:</p>\n<blockquote>\n<p id=\"so_29808397_29808593_0\">For signed integer types, the bits of the object representation shall be divided into three\n  groups: value bits, padding bits, and the sign bit. There need not be any padding bits;\n  signed char shall not have any padding bits. There shall be exactly one sign bit.\n  Each bit that is a value bit shall have the same value as the same bit in the object\n  representation of the corresponding unsigned type (if there are M value bits in the signed\n  type and N in the unsigned type, then M \u2264 N). If the sign bit is zero, it shall not affect\n  the resulting value. If the sign bit is one, the value shall be modified in one of the\n  following ways:</p>\n<ul>\n<li>the corresponding value with sign bit 0 is negated (sign and magnitude);</li>\n<li>the sign bit has the value \u2212(2^M) (two\u2019s complement);</li>\n<li>the sign bit has the value \u2212(2^M \u2212 1) (ones\u2019 complement).</li>\n</ul>\n</blockquote>\n<p>(Section 6.2.6.2 of <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a>)</p>\n", "LastEditorUserId": "387076", "LastActivityDate": "2015-04-22T20:56:24.137", "Score": "6", "CreationDate": "2015-04-22T20:53:20.733", "ParentId": "29808397", "CommentCount": "7", "OwnerUserId": "864393", "LastEditDate": "2015-04-22T20:56:24.137"}});