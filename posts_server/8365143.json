post_cb({"8365187": {"ParentId": "8365143", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This can be achieved through a simple copy:</p>\n<pre><code>uint32_t dst;\nfloat    src = get_float();\n\nchar * const p = reinterpret_cast&lt;char*&gt;(&amp;dst);\n\nstd::copy(p, p + sizeof(float), reinterpret_cast&lt;char *&gt;(&amp;src));\n\n// now read dst\n</code></pre>\n<p>Copying backwards works similarly.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "4086", "LastEditDate": "2011-12-03T12:55:32.900", "Id": "8365187", "Score": "6", "CreationDate": "2011-12-03T03:11:11.200", "LastActivityDate": "2011-12-03T12:55:32.900"}, "8365157": {"ParentId": "8365143", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Just do a reinterpret cast of the respective memory location:</p>\n<pre><code>float f = 0.5f;\nunsigned int i = *reinterpret_cast&lt;unsigned int*&gt;(&amp;f);\n</code></pre>\n<p>or the more C-like version:</p>\n<pre><code>unsigned int i = *(unsigned int*)&amp;f;\n</code></pre>\n<p>From your question text I assume you are aware that this breaks if <code>float</code> and <code>unsigned int</code> don't have the same size, but on most usual platforms both should be 32-bit.</p>\n<p><strong>EDIT:</strong> As Kerrek pointed out, this seems to be undefined behaviour. But I still stand to my answer, as it is short and precise and should indeed work on any practical compiler (convince me of the opposite). But look at Kerrek's answer if you want a UB-free answer.</p>\n", "OwnerUserId": "743214", "LastEditorUserId": "743214", "LastEditDate": "2011-12-03T03:20:40.500", "Id": "8365157", "Score": "2", "CreationDate": "2011-12-03T03:04:02.137", "LastActivityDate": "2011-12-03T03:20:40.500"}, "8365381": {"ParentId": "8365143", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can use <code>reinterpret_cast</code> if you really have to. You don't even need to play with pointers/addresses as other answers mention. For example</p>\n<pre><code>int i;\nreinterpret_cast&lt;float&amp;&gt;(i) = 10;\n\nstd::cout &lt;&lt; std::endl &lt;&lt; i &lt;&lt; \" \" &lt;&lt; reinterpret_cast&lt;float&amp;&gt;(i) &lt;&lt; std::endl;\n</code></pre>\n<p>also works (and prints <code>1092616192 10</code> if you are qurious ;).</p>\n<p>EDIT:</p>\n<p>From C++ standard (about reinterpret_cast):</p>\n<blockquote>\n<p id=\"so_8365143_8365381_0\">5.2.10.7 A pointer to an object can be explicitly converted to a pointer to an object of different type.Except that converting an\n  rvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1\n  and T2 are object types and where the alignment requirements of T2 are\n  no stricter than those of T1) and back to its original type yields the\n  original pointer value, the result of such a pointer conversion is\n  unspecified.</p>\n<p id=\"so_8365143_8365381_1\">5.2.10.10 10 An lvalue expression of type T1 can be cast to the type \u201creference to T2\u201d if an expression of type \u201cpointer to T1\u201d can be\n  explicitly converted to the type \u201cpointer to T2\u201d using a\n  reinterpret_cast. That is, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code>\n  has the same effect as the conversion\n  <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in &amp; and * operators. The result is an lvalue that refers to the same object as the source\n  lvalue, but with a different type. No temporary is created, no copy is\n  made, and constructors (12.1) or conversion functions (12.3) are not\n  called.67)</p>\n</blockquote>\n<p>So it seems that consistently reinterpreting pointers is not undefined behavior, and using references has the same result as taking address, reintepreting and deferencing obtained pointer. I still claim that this is not undefined behavior.</p>\n", "OwnerUserId": "455304", "LastEditorUserId": "455304", "LastEditDate": "2011-12-07T13:37:05.983", "Id": "8365381", "Score": "0", "CreationDate": "2011-12-03T03:53:45.980", "LastActivityDate": "2011-12-07T13:37:05.983"}, "8365143": {"CommentCount": "5", "ViewCount": "2939", "PostTypeId": "1", "LastEditorUserId": "743214", "CreationDate": "2011-12-03T03:00:56.857", "LastActivityDate": "2011-12-07T13:37:05.983", "Title": "How can I assign a float variable to an unsigned int variable, bit image, not cast", "FavoriteCount": "0", "LastEditDate": "2011-12-03T03:05:22.653", "Id": "8365143", "Score": "4", "Body": "<p>I know this is a bizarre thing to do, and it's not portable.  But I have an allocated array of unsigned ints, and I occasionaly want to \"store\" a float in it.  I don't want to cast the float or convert it to the closest equivalent int; I want to store the exact bit image of the float in the allocated space of the unsigned int, such that I could later retrieve it as a float and it would retain its original float value.</p>\n", "Tags": "<c++>", "OwnerUserId": "1020872", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8365143_8365381_1": {"section_id": 6050, "quality": 0.6122448979591837, "length": 30}, "so_8365143_8365381_0": {"section_id": 6046, "quality": 0.7105263157894737, "length": 27}}, "n3337": {"so_8365143_8365381_1": {"section_id": 5818, "quality": 0.8163265306122449, "length": 40}, "so_8365143_8365381_0": {"section_id": 5814, "quality": 0.8421052631578947, "length": 32}}, "n4659": {"so_8365143_8365381_1": {"section_id": 7549, "quality": 0.6122448979591837, "length": 30}, "so_8365143_8365381_0": {"section_id": 7545, "quality": 0.7105263157894737, "length": 27}}}});