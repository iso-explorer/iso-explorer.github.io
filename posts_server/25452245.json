post_cb({"25452245": {"CommentCount": "4", "CreationDate": "2014-08-22T17:08:59.480", "PostTypeId": "1", "AcceptedAnswerId": "25452626", "LastEditorUserId": "3747990", "LastActivityDate": "2014-08-22T17:44:33.337", "LastEditDate": "2014-08-22T17:44:33.337", "ViewCount": "269", "FavoriteCount": "0", "Title": "What is the scope of a user-defined literal?", "Id": "25452245", "Score": "8", "Body": "<p>Consider these two:</p>\n<pre><code>namespace X1\n{\n    A operator \"\" _x(unsigned long long i) { return A{i}; }\n};\n\nnamespace X2\n{\n    B operator \"\" _x(unsigned long long i) { return B{i}; }\n};\n</code></pre>\n<p>The <code>x</code> literal is defined twice, but one of them is defined in <code>namespace X1</code> while another is defined in <code>namespace X2</code>.</p>\n<p>According to the C++ standard, can this code be compiled?</p>\n", "Tags": "<c++><c++11><user-defined-literals>", "OwnerUserId": "417024", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25452245_25452626_0": {"section_id": 5368, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_25452245_25452626_0": {"section_id": 5164, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_25452245_25452626_0": {"section_id": 6793, "quality": 0.9285714285714286, "length": 26}}}, "25452626": {"ParentId": "25452245", "LastEditDate": "2014-08-22T17:39:02.330", "CommentCount": "1", "CreationDate": "2014-08-22T17:33:52.583", "OwnerUserId": "567292", "LastEditorUserId": "567292", "PostTypeId": "2", "Id": "25452626", "Score": "12", "Body": "<p>A user-defined literal is treated as a call to <code>operator \"\"</code><em><code>X</code></em><code>(...)</code> where <em><code>X</code></em> is an identifier (for example, <code>_x</code>) and the <code>...</code> depends on the form of the user-defined literal. Lookup of the appropriate user-defined literal operator then proceeds according to the usual rules for unqualified lookup; <strong>[lex.ext]</strong>:</p>\n<blockquote>\n<p id=\"so_25452245_25452626_0\">2 - A <em>user-defined-literal</em> is treated as a call to a literal operator or literal operator template (13.5.8). To determine the form of this call for a given <em>user-defined-literal <code>L</code></em> with <em>ud-suffix <code>X</code></em>, the <em>literal-operator-id</em> whose literal suffix identifier is <em><code>X</code></em> is looked up in the context of <em><code>L</code></em> <strong>using the rules for unqualified name lookup (3.4.1)</strong>. [...]</p>\n</blockquote>\n<p>The definitions of the <code>_x</code> literal only conflict if both definitions are made available for unqualified lookup by a <code>using</code> or <code>using namespace</code> declaration or by entering either namespace; the conflict is only problematic if a call to the unqualified operator is actually made. </p>\n<pre><code>{ using namespace X1; auto o = 5_x; }          // OK; o is of type A\n{ using namespace X2; auto o = 5_x; }          // OK; o is of type B\n{ using namespace X1; using namespace X2; }    // OK; operator \"\" _x is not used\n{ using namespace X1; using namespace X2; auto o = 5_x; }  // ambiguous\n</code></pre>\n<p>It would also be OK if the <code>_x</code> were different types of user-defined literal operators e.g. if one were an integer literal operator and the other a float literal operator.</p>\n", "LastActivityDate": "2014-08-22T17:39:02.330"}});