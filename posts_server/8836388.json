post_cb({"8837166": {"ParentId": "8836388", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-01-12T15:00:34.057", "Score": "2", "LastEditorUserId": "201270", "LastEditDate": "2012-11-19T07:39:02.853", "Id": "8837166", "OwnerUserId": "201270", "Body": "<p>I think you should simply put only the common parts in a third function leaving <code>dense_histogram</code> and <code>sparse_histogram</code> to create <code>h</code> and call that implementation function:</p>\n<pre><code>template &lt;class V, class C = size_t, class H&gt;\ninline void histogram_impl(const V &amp; x, H&amp; h) {\n    typedef typename V::value_type E; // element type\n    C bmax = 0;                      // bin max\n    for_each(begin(x), end(x),  // C++11\n             [&amp;h, &amp;bmax] (const E &amp; e) { // value element\n                 h[e]++;\n                 bmax = std::max(bmax, h[e]);\n             });\n    return h;\n}\ntemplate &lt;class V, class C = size_t, class H = vector&lt;C&gt; &gt;\ninline H dense_histogram(const V &amp; x) {\n    typedef typename V::value_type E; // element type\n    size_t n = (static_cast&lt;C&gt;(1)) &lt;&lt; (8*sizeof(E)); // maximum number of possible elements for dense variant\n    H h(n, 0);                       // histogram\n    histogram_impl(x, h);\n    return h;\n}\ntemplate &lt;class V, class C = size_t, class H = unordered_map&lt;typename V::value_type, C&gt; &gt;\ninline H sparse_histogram(const V &amp; x) {\n    H h;                        // histogram\n    histogram_impl(x, h);\n    return h;\n}\n</code></pre>\n<p>However since you asked for it: As you are working on containers I would assume they have a cheap move, so you could define a creation trait to generate your container and move that into your local variable. Then you can write your own detection of an appropriate constructor like this:</p>\n<pre><code>template&lt;typename T&gt; struct has_explicit_length_constructor{\nprivate:\n   template&lt;typename U&gt;\n   decltype(U(0, 0), void(), std::true_type()) test(int x);\n   template&lt;typename&gt;\n   std::false_type test(...);\n  typedef decltype(test&lt;T&gt;(0)) constant_type;\npublic:\n   constexpr bool value = constant_type::value;\n};\n\ntemplate&lt;class H, bool B = has_explicit_length_constructor&lt;H&gt;::value&gt; struct histogram_creation_trait;\ntemplate&lt;class H&gt; struct histogram_creation_trait&lt;H, true&gt; {\n  static H create()  {\n    size_t n = (static_cast&lt;C&gt;(1)) &lt;&lt; (8*sizeof(typename V::value_type));\n    return H(n, 0);  \n  }\n};\ntemplate&lt;class H&gt; struct histogram_creation_trait&lt;H, false&gt;\n{ static H create()  { return H(); } };\n\ntemplate &lt;class V, class C = size_t, class Ht&gt;\ninline void histogram_impl(const V &amp; x, H&amp; h, Trait) {\n    typedef typename V::value_type E; // element type\n    C bmax = 0;                      // bin max\n    H h = histogram_creation_trait&lt;H&gt;::create();\n    for_each(begin(x), end(x),  // C++11\n             [&amp;h, &amp;bmax] (const E &amp; e) { // value element\n                 h[e]++;\n                 bmax = std::max(bmax, h[e]);\n             });\n    return h;\n}\ntemplate &lt;class V, class H = vector&lt;size_t&gt; &gt; H make_dense_histogram(const V &amp; x) { return histogram_impl&lt;V, size_t, H&gt;(x); }\ntemplate &lt;class V, class H = unordered_map&lt;typename V::value_type, size_t&gt; &gt; H make_sparse_histogram(const V &amp; x) { return histogram_impl&lt;V, size_t, H&gt;(x); }\n</code></pre>\n<p>As a side not: Adding your own methods to <code>std</code> is UB by the standard (<code>[namespace.std] $17.6.4.2.1 p1</code>):</p>\n<blockquote>\n<p id=\"so_8836388_8837166_0\">The behavior of a C++ program is unde\ufb01ned if it adds declarations or de\ufb01nitions to namespace std or to a namespace within namespace std unless otherwise speci\ufb01ed. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-de\ufb01ned type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n", "LastActivityDate": "2012-11-19T07:39:02.853"}, "8836388": {"CommentCount": "2", "AcceptedAnswerId": "8837166", "CreationDate": "2012-01-12T14:07:59.213", "LastActivityDate": "2012-11-19T07:39:02.853", "PostTypeId": "1", "ViewCount": "3133", "FavoriteCount": "2", "Title": "Generic STL-Compatible Histogram in C++11", "Id": "8836388", "Score": "1", "Body": "<p>Here is my first try at a generic histogram template function in C++ tested with GCC 4.6. However, I would like to merge <code>dense_histogram()</code> and <code>sparse_histogram()</code> into one common generic function template. The problem is that the <em>dense</em>-specific constructor <code>H h(n, 0)</code> is neither defined nor relevant in the <em>sparse</em> version <code>H h</code>. Is there a way to solve this in some clever C++ regular way or statically typically using conditional compilation through Boost Type.Traits (<code>#include &lt;boost/type_traits.hpp&gt;</code>)?</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;limits&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nnamespace std\n{\n\n/*!\n * \\em Dense Histogram of \\p a.\n *\n * \\tparam V is Value Type.\n * \\tparam C is Count (Bin) Type.\n * \\tparam H is Histogram Storage Type, typically a vector.\n *\n * \\param[in] x is a set of the input data set\n */\ntemplate &lt;class V, class C = size_t, class H = vector&lt;C&gt; &gt;\ninline\nH dense_histogram(const V &amp; x)\n{\n    typedef typename V::value_type E; // element type\n    size_t n = (static_cast&lt;C&gt;(1)) &lt;&lt; (8*sizeof(E)); // maximum number of possible elements for dense variant\n    H h(n, 0);                       // histogram\n    C bmax = 0;                      // bin max\n    for_each(begin(x), end(x),  // C++11\n             [&amp;h, &amp;bmax] (const E &amp; e) { // value element\n                 h[e]++;\n                 bmax = std::max(bmax, h[e]);\n             });\n    return h;\n}\ntemplate &lt;class V, class H = vector&lt;size_t&gt; &gt; H make_dense_histogram(const V &amp; x) { return dense_histogram&lt;V, size_t, H&gt;(x); }\n\n/*!\n * \\em Sparse Histogram of \\p a.\n *\n * \\tparam V is Value Type.\n * \\tparam C is Count (Bin) Type.\n * \\tparam H is Histogram Structure Type, typically a unordered_map.\n *\n * \\param[in] x is a set of the input data set\n */\ntemplate &lt;class V, class C = size_t, class H = unordered_map&lt;typename V::value_type, C&gt; &gt;\ninline\nH sparse_histogram(const V &amp; x)\n{\n    typedef typename V::value_type E; // element type\n    H h;                        // histogram\n    C bmax = 0;                 // bin max\n    for_each(begin(x), end(x), // C++11\n             [&amp;h,&amp;bmax] (const E &amp; e) { // value element\n                 h[e]++;\n                 bmax = std::max(bmax, h[e]);\n             });\n    return h;\n}\ntemplate &lt;class V, class H = unordered_map&lt;typename V::value_type, size_t&gt; &gt; H make_sparse_histogram(const V &amp; x) { return sparse_histogram&lt;V, size_t, H&gt;(x); }\n\n}\n</code></pre>\n<p>run using</p>\n", "Tags": "<c++><templates><generics><histogram><conditional-compilation>", "OwnerUserId": "683710", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8836388_8837166_0": {"section_id": 6299, "quality": 0.8529411764705882, "length": 29}}, "n3337": {"so_8836388_8837166_0": {"section_id": 6056, "quality": 0.8529411764705882, "length": 29}}, "n4659": {"so_8836388_8837166_0": {"section_id": 7808, "quality": 0.8529411764705882, "length": 29}}}});