post_cb({"26781405": {"Id": "26781405", "PostTypeId": "2", "Body": "<p>I'm not sure \"copied\" is the right word (the compiler will only compile the code in <code>class A</code> once). As you have used public inheritance, <code>class B</code> actually <strong>is</strong> a special type of <code>class A</code>. As such, <code>class B</code> does have access to every (non-private) member of <code>class A</code>, so the code is re-used.</p>\n<p>In addition, from the conversation in the comments:</p>\n<p>No. Nothing is \"copied\", each instance of A and B has their own value for their own variables, except for any static data members. For static data members, again there is no copying going on; there is simply only one variable and that is shared by all instantiations of <code>A</code> and <code>B</code>.</p>\n", "LastEditorUserId": "125405", "LastActivityDate": "2014-11-06T14:12:13.683", "Score": "1", "CreationDate": "2014-11-06T14:04:13.767", "ParentId": "26781317", "CommentCount": "0", "OwnerUserId": "125405", "LastEditDate": "2014-11-06T14:12:13.683"}, "26782034": {"Id": "26782034", "PostTypeId": "2", "Body": "<p>I also have some doubts regarding relation between inheritance and code re-use. This is my take on this.  </p>\n<p>Inheritance is a mechanism used to categorize and facilitate polymorphism. Using inheritance we can build a hierarchy of concepts separated in categories at different levels of abstraction. By doing this, we can efficiently use another OOP concept, polymorphism, which allows the same control code to manage all objects in a category even if they are different in their implementation.</p>\n<p>I don't think that we use inheritance for code re-use purpose.</p>\n", "LastActivityDate": "2014-11-06T14:35:11.223", "CommentCount": "0", "CreationDate": "2014-11-06T14:35:11.223", "ParentId": "26781317", "Score": "0", "OwnerUserId": "4047092"}, "26782633": {"Id": "26782633", "PostTypeId": "2", "Body": "<p>\u00a71.8(2) of the C++ language standard defines what is meant by a <em>subobject</em>:</p>\n<blockquote>\n<p id=\"so_26781317_26782633_0\">Objects can contain other objects, called <em>subobjects</em>. A subobject can be a <em>member subobject</em> (9.2), a <em>base class subobject</em> (Clause 10), or an array element. An object that is not a subobject of any other object is called a <em>complete object</em>.</p>\n</blockquote>\n<p>These are examples of member subobjects and array elements, which you should be familiar with:</p>\n<pre><code>int a[5];\na[2]; // the third array element subobject of the complete object a\n\nstruct S { int x; }\nS s;\ns.x; // a member subobject of the complete object s\n</code></pre>\n<p>That leaves the remaining kind of subobject, the one which you are interested in: base class subobjects.</p>\n<pre><code>struct B { int x; }\nstruct D : public B { int y; }\n\nD d;\nd.y; // a member subobject of the complete object d\nd.x; // a member subobject of a base class subobject of the complete object d\n\nB &amp;b = d; // a reference to a base class subobject of the complete object d\n</code></pre>\n<p>Every instance of a derived class contains an instance of its base class, as a base class subobject.</p>\n", "LastActivityDate": "2014-11-06T15:04:36.240", "CommentCount": "0", "CreationDate": "2014-11-06T15:04:36.240", "ParentId": "26781317", "Score": "1", "OwnerUserId": "1639256"}, "bq_ids": {"n4140": {"so_26781317_26782633_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5791}}, "n3337": {"so_26781317_26782633_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5564}}, "n4659": {"so_26781317_26782633_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7248}}}, "26781467": {"Id": "26781467", "PostTypeId": "2", "Body": "<p>Code is never copied during inheritance. But when the child object (class B) is created  or instantiated at run time, it inherits the functionality and attributes of the parent class/object (class A).</p>\n", "LastActivityDate": "2014-11-06T14:07:40.013", "CommentCount": "0", "CreationDate": "2014-11-06T14:07:40.013", "ParentId": "26781317", "Score": "2", "OwnerUserId": "4198755"}, "26781431": {"Id": "26781431", "PostTypeId": "2", "Body": "<p>the code from class A does NOT copied to class B in the sense that there is only one place the code is written.</p>\n<p>however, and here cones the Reusable part, when using class b u can call the method and use the members, with respect to <code>private</code>, <code>public</code>, etd and thus does not have to write the same code for two class that do the same thing</p>\n<p>for example if i have a circle and a square, and they both have a member called color that i want a method that change it, i do not need to write the method and the member twice, but have them inherit class Shape that will implement it once and then they both will be able to use that method, thus reusing one method in two places</p>\n", "LastActivityDate": "2014-11-06T14:05:44.680", "CommentCount": "0", "CreationDate": "2014-11-06T14:05:44.680", "ParentId": "26781317", "Score": "1", "OwnerUserId": "2492977"}, "26782351": {"Id": "26782351", "PostTypeId": "2", "Body": "<p>In your example, you are comparing two different instances of two different classes. different instances means different base addresses to store instances data.</p>\n<p>Perhaps a better test of whether a field of a class is copied over in derived classes is the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\n\nprotected:\n int f;\n\npublic:\n\nvoid get() {\n    std::cout &lt;&lt; \"The address is: \" &lt;&lt; &amp;f &lt;&lt; std::endl;\n    }\n};\n\nclass B : public A {\n    // ....\n};\n\nint main() {\n\n B b;\n b.get();\n\n A *a = &amp;b;\n a-&gt;get();\n\n return 0;\n}\n</code></pre>\n<p>And the output is:</p>\n<pre><code>The address is: 0x7fff41d523f0\nThe address is: 0x7fff41d523f0\n</code></pre>\n<p>With that program, we can see that even though we have an instance of class <code>B</code>, its inherited content is physically the same as the one in the original class <code>A</code>. Note that it is also possible to redefine a class member in a derived class, but the original member will still be available if we coerce an instance of the derived class to the parent class (as I did in my example).</p>\n", "LastActivityDate": "2014-11-06T14:51:14.197", "CommentCount": "0", "CreationDate": "2014-11-06T14:51:14.197", "ParentId": "26781317", "Score": "1", "OwnerUserId": "1769720"}, "26781317": {"ViewCount": "107", "Body": "<p>Whenever I derive a new class from base class say:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\n\nprotected:\n     int f;\n\npublic:\n\n    void get() {\n        std::cout &lt;&lt; \"The address is: \"\n        &lt;&lt; &amp;f &lt;&lt; std::endl;\n        }\n};\n\nclass B : public A {\n        // ....\n};\n\nint main() {\n\n     A a;\n     a.get();\n\n     B b;\n     b.get();\n\n     return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_26781317_26781317_0\">The address is: 0xbfb0d5b8<br>\n  The address is: 0xbfb0d5bc</br></p>\n</blockquote>\n<p>Does this means that all the code from <code>class A</code> will be copied to <code>class B</code>? Since I have nothing in class <code>B</code> i.e. no data members or functions So, when I create an instance of class B, then I find that it has its own variable at different address and it also has a member function. How can it have its own of copy members if it they aren't copied?</p>\n<p>Is that what do we mean by <em>code reuse</em> in inheritance?</p>\n<h2>Edit:</h2>\n<p>Updated my code to reflect what I meant by copying of variables.</p>\n", "AcceptedAnswerId": "26781467", "Title": "Does the code get copied to derived class?", "CreationDate": "2014-11-06T13:59:49.853", "Id": "26781317", "CommentCount": "14", "LastEditDate": "2014-11-06T14:25:45.657", "PostTypeId": "1", "LastEditorUserId": "255412", "LastActivityDate": "2014-11-06T15:04:36.240", "Score": "1", "OwnerUserId": "255412", "Tags": "<c++><inheritance><code-reuse>", "AnswerCount": "6"}});