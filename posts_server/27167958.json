post_cb({"27168696": {"ParentId": "27167958", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The type of a constant expression must be a <em>literal type</em>. In fact, the entire purpose of the \"literal type\" taxon is to \"be the thing that can be a constant expression\". See [expr.const]:</p>\n<blockquote>\n<p id=\"so_27167958_27168696_0\">A <em>conditional-expression</em> <code>e</code> is a core constant expression unless the evaluation of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_27167958_27168696_1\">...</p>\n<p id=\"so_27167958_27168696_2\">\u2014 an invocation of a function other than <strong>a constexpr constructor for a literal class</strong>, a constexpr function,</p>\n<p id=\"so_27167958_27168696_3\">...</p>\n</blockquote>\n<p>Therefore, a <code>constexpr</code> constructor only allows you to produce constant expressions on literal classes, and otherwise, as your compiler is telling you, it would \"never produce a constant expression\".</p>\n<p>A literal class is constrained by [basic.types] in this way:</p>\n<blockquote>\n<p id=\"so_27167958_27168696_4\">A type is a <em>literal type</em> if it is:</p>\n<p id=\"so_27167958_27168696_5\">...</p>\n<p id=\"so_27167958_27168696_6\">\u2014 a class type (Clause 9) that has all of the following properties:</p>\n<ul>\n<li>it has a trivial destructor,</li>\n<li>it is an aggregate type (8.5.1) or has at least one <code>constexpr</code> constructor or constructor template that is not a copy or move constructor, and</li>\n<li>all of its non-static data members and base classes are of non-volatile literal types.</li>\n</ul>\n</blockquote>\n<p>However, as of C++14 (particularly, as of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html\" rel=\"nofollow\">N3652</a>), <code>constexpr</code> constructors have another, unrelated use: They permit static initialization (in the sense of [basic.start.init]):</p>\n<blockquote>\n<p id=\"so_27167958_27168696_7\">A <em>constant initializer</em> for an object <code>o</code> is an expression that is a\n  constant expression, except that it may also invoke <code>constexpr</code> constructors for <code>o</code> and its subobjects even if those objects are of non-literal class types [<em>Note</em>: such a class may have a non-trivial destructor \u2014 <em>end note</em>].</p>\n</blockquote>\n<p>So to recap: As of C++14, <code>constexpr</code> has two uses:</p>\n<ol>\n<li><p>The C++11 interpretation: a \"constant expression\" is an expression that is identical to its value (i.e. its evaluation has no side effects); <code>constexpr</code> variables are just placeholders for their value and not intended to be used for their object identity, and it is generally expected that constant expressions can be freely replaced with their (compile-time knowable) value.</p></li>\n<li><p>The C++14 <code>constexpr</code> functions, including constructors: These functions, including constructors, may be called in the static initialization phase to constant-initialize variables with static storage duration. If the variables are objects, they still retain their object identity and may need dynamic destruction, but their initialization happens before any dynamic initialization and is not subject to ordering.</p></li>\n</ol>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2014-11-27T11:53:52.153", "Id": "27168696", "Score": "5", "CreationDate": "2014-11-27T10:45:36.597", "LastActivityDate": "2014-11-27T11:53:52.153"}, "27167958": {"CommentCount": "7", "AcceptedAnswerId": "27168696", "PostTypeId": "1", "LastEditorUserId": "1433901", "CreationDate": "2014-11-27T10:10:11.840", "LastActivityDate": "2014-11-27T11:53:52.153", "LastEditDate": "2014-11-27T10:34:46.750", "ViewCount": "520", "FavoriteCount": "2", "Title": "constexpr for null-initialized constructor in a derived class", "Id": "27167958", "Score": "2", "Body": "<p>I have something similar to the following</p>\n<pre><code>class Base {\npublic:\n    explicit Base(int* i) noexcept { type = new int; *type = *i; };\n    constexpr Base(std::nullptr_t) : type(nullptr) { };\n    ~Base() { cout &lt;&lt; \"Destroying!\" &lt;&lt; endl; delete type; };\nprotected:\n    int* type;\n};\n\n\nclass Derived : public Base {\npublic:\n    explicit Derived(int* i) noexcept : Base(i) { };\n    //constexpr Derived(std::nullptr_t) : type(nullptr) { };\n    //constexpr Derived(std::nullptr_t) : Base(nullptr) { };\n    ~Derived() { };\n};\n</code></pre>\n<p>I would like to achieve some <code>constexpr</code> null constructor for the derived class, but the compiler complains a lot about the two options and similar tests I have done.</p>\n<p>Of course the code is more complex, I have an opaque handler and the destructor should behave in a more complex way. The resource free-ing is always the same (no need for multiple destructors, only the <code>Base</code> one).</p>\n<p>I don't know how to achieve this, maybe I am going through a wrong path? Any ideas? I expect to be able to do something like:</p>\n<pre><code>Derived a(nullptr);\nDerived b(handler1);\nBase c (nullptr);\nBase d (handler2);\n</code></pre>\n<p>and, in cleanup, both <code>handler1</code> and <code>handler2</code> are managed in the some way.</p>\n<p>Edit:</p>\n<p>Clang (version 3.4) complains:</p>\n<pre><code>error: constexpr constructor never produces a constant expression [-Winvalid-constexpr]\n</code></pre>\n<p>And gcc (version 4.8 [edit: multiple versions, haven't checked all]) doesn't complain when using </p>\n<pre><code>constexpr Derived(std::nullptr_t) : Base(nullptr) { };\n</code></pre>\n<p>In fact, <code>gcc</code> seems to do what I wanted to achieve, but I do not understand the <code>constexpr</code> enough to know which compiler is doing right and how I can amend the problem.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1433901", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27167958_27168696_0": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_27167958_27168696_6": {"section_id": 7208, "quality": 1.0, "length": 6}, "so_27167958_27168696_7": {"section_id": 7151, "quality": 0.8620689655172413, "length": 25}, "so_27167958_27168696_2": {"section_id": 6185, "quality": 1.0, "length": 10}}, "n3337": {"so_27167958_27168696_6": {"section_id": 6952, "quality": 1.0, "length": 6}, "so_27167958_27168696_2": {"section_id": 5946, "quality": 1.0, "length": 10}}, "n4659": {"so_27167958_27168696_0": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_27167958_27168696_7": {"section_id": 8652, "quality": 0.7931034482758621, "length": 23}, "so_27167958_27168696_6": {"section_id": 8717, "quality": 1.0, "length": 6}, "so_27167958_27168696_2": {"section_id": 7687, "quality": 1.0, "length": 10}}}});