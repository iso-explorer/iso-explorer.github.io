post_cb({"31041515": {"CreationDate": "2015-06-25T04:57:47.797", "LastActivityDate": "2015-06-25T05:47:26.783", "Id": "31041515", "ViewCount": "233", "Score": "12", "Title": "Static initialization of local variables", "CommentCount": "1", "Body": "<p>From Scott Meyers <strong>Effective C++</strong>:</p>\n<blockquote>\n<p id=\"so_31041515_31041515_0\">if you never call a function emulating a non-local static object, you\n  never incur the cost of constructing and destructing the object,\n  something that can\u2019t be said for true non-local static objects.</p>\n</blockquote>\n<p>The function:</p>\n<pre><code>FileSystem&amp; tfs()\n{ \n    static FileSystem fs;\n    return fs; \n}\n</code></pre>\n<p>But the Standard said:</p>\n<blockquote>\n<p id=\"so_31041515_31041515_1\">Constant initialization (3.6.2) of a block-scope entity with static\n  storage duration, if applicable, is performed before its block is\n  first entered. <strong>An implementation is permitted to perform early</strong>\n<strong>initialization of other block-scope variables with static or thread</strong>\n<strong>storage duration under the same conditions that an implementation is</strong>\n<strong>permitted to statically initialize a variable with static or thread</strong>\n<strong>storage duration in namespace scope (3.6.2).</strong></p>\n</blockquote>\n<p>That means that we can't say for sure if the <code>fs</code> variable is or is not initialized even if we don't call to the function <code>tfs()</code>. Because implementation is permitted to perform early initialization as for variables with static storage duration.</p>\n<p>Who was right or what did I miss?</p>\n", "Tags": "<c++><initialization>", "FavoriteCount": "2", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "4671213"}, "31041904": {"LastActivityDate": "2015-06-25T05:47:26.783", "CommentCount": "3", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/constant_initialization\">Constant initialization</a> describes initialization that can be determined at compile-time.</p>\n<p>Only in C++11 and later can a type with a non-trivial constructor be considered:</p>\n<blockquote>\n<p id=\"so_31041515_31041904_0\">if the constructor is <code>constexpr</code></p>\n</blockquote>\n<p>In \"Effective C++\", Meyers describes the class in your question literally as:</p>\n<blockquote>\n<p id=\"so_31041515_31041904_1\"><code>class FileSystem {...};</code></p>\n</blockquote>\n<p>This would imply that given the C++ Standard being correct, \"Effective C++\" can also remain correct <em>even after</em> C++11 as long as the supplied constructor for <code>FileSystem</code> is not <code>constexpr</code>.</p>\n", "CreationDate": "2015-06-25T05:29:44.263", "LastEditDate": "2015-06-25T05:47:26.783", "ParentId": "31041515", "Id": "31041904", "LastEditorUserId": "16287", "PostTypeId": "2", "Score": "7", "OwnerUserId": "16287"}, "bq_ids": {"n4140": {"so_31041515_31041515_1": {"length": 40, "quality": 0.9523809523809523, "section_id": 3919}}, "n3337": {"so_31041515_31041515_1": {"length": 40, "quality": 0.9523809523809523, "section_id": 3779}}}});