post_cb({"bq_ids": {"n4140": {"so_46323266_46323266_1": {"length": 16, "quality": 1.0, "section_id": 7239}, "so_46323266_46323681_2": {"length": 8, "quality": 0.8, "section_id": 5879}, "so_46323266_46323681_6": {"length": 33, "quality": 0.6, "section_id": 5878}}, "n3337": {"so_46323266_46323266_1": {"length": 16, "quality": 1.0, "section_id": 6983}, "so_46323266_46323681_2": {"length": 8, "quality": 0.8, "section_id": 5650}, "so_46323266_46323681_6": {"length": 33, "quality": 0.6, "section_id": 5649}}, "n4659": {"so_46323266_46323266_1": {"length": 16, "quality": 1.0, "section_id": 8748}, "so_46323266_46323681_2": {"length": 8, "quality": 0.8, "section_id": 7363}, "so_46323266_46323266_0": {"length": 4, "quality": 0.8, "section_id": 802}}}, "46323681": {"Id": "46323681", "PostTypeId": "2", "Body": "<blockquote id=\"so_46323266_46323681_0\">\n<ol>\n<li>I believe I am guaranteed (via #pragma compiler documentation, not language guarantee) that sizeof(vec) == 3*sizeof(float)</li>\n</ol>\n</blockquote>\n<p>Yes that's correct, assuming the <code>#pragma</code> disabled padding entirely.</p>\n<hr>\n<blockquote id=\"so_46323266_46323681_1\">\n<ol start=\"2\">\n<li>As such, I believe I am guaranteed that &amp;vec.x == &amp;vec.vals[0], ect.</li>\n</ol>\n</blockquote>\n<p>This is guaranteed regardless of padding, because there can never be padding at the beginning of the struct/union. See for example C11 6.7.2.1 \u00a715: </p>\n<blockquote>\n<p id=\"so_46323266_46323681_2\">There may be unnamed padding within a structure object, but not at its beginning.</p>\n</blockquote>\n<p>This holds true for all versions of the C standard, and as far as I know, also for all versions of the C++ standard.</p>\n<hr>\n<blockquote id=\"so_46323266_46323681_3\">\n<ol start=\"3\">\n<li>However, I am unsure if it is legal (that is, not allowed via strict aliasing), to write from v.x and then read from v.vals[0]</li>\n</ol>\n</blockquote>\n<p>This is fine in C but undefined behavior in C++. </p>\n<p>In C, the <code>.</code>/<code>-&gt;</code> operator guarantees this, C11 6.5.2.3:</p>\n<blockquote>\n<p id=\"so_46323266_46323681_4\">A postfix expression followed by the . operator and an identifier designates a member of\n  a structure or union object. The value is that of the named member,95) and is an lvalue if the first expression is an lvalue. </p>\n</blockquote>\n<p>Where footnote 95 (informative, not normative) says:</p>\n<blockquote>\n<p id=\"so_46323266_46323681_5\">95) If the member used to read the contents of a union object is not the same as the member last used to\n  store a value in the object, the appropriate part of the object representation of the value is reinterpreted\n  as an object representation in the new type as described in 6.2.6 (a process sometimes called \u2018\u2018type\n  punning\u2019\u2019). This might be a trap representation.</p>\n</blockquote>\n<p>C++ have no guarantees like this, so \"type punning\" through unions is undefined behavior in C++. This is a major difference between the two languages.</p>\n<p>Furthermore, C has the concept of <em>common initial sequence</em> for unions, also specified in C11 6.5.2.3:</p>\n<blockquote>\n<p id=\"so_46323266_46323681_6\">One special guarantee is made in order to simplify the use of unions: if a union contains\n  several structures that share a common initial sequence (see below), and if the union\n  object currently contains one of these structures, it is permitted to inspect the common\n  initial part of any of them anywhere that a declaration of the completed type of the union\n  is visible. Two structures share a <em>common initial sequence</em> if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more\n  initial members.</p>\n</blockquote>\n<hr>\n<p>It is true that the array and the struct in your example may alias, because of the part you cited \"an aggregate or union type that includes one of the aforementioned types among its members\". So writing to the struct and then reading that data through the array does not violate strict aliasing, neither in C nor C++.</p>\n<p><em>However</em>, C++ has the concept of \"active member\" when dealing with unions, so in C++ this would give poorly-specified behavior for other reasons than aliasing - namely that C++ only guaranteed that the last written member of the union can be safely read.</p>\n</hr></hr></hr>", "LastEditorUserId": "584518", "LastActivityDate": "2017-09-20T13:47:11.570", "Score": "6", "CreationDate": "2017-09-20T13:40:25.707", "ParentId": "46323266", "CommentCount": "5", "LastEditDate": "2017-09-20T13:47:11.570", "OwnerUserId": "584518"}, "46323266": {"ViewCount": "169", "Body": "<pre><code>union vec\n{\n#pragma pack(push,1)\n   struct\n   {\n      float x, y, z;\n   }\n#pragma pack(pop)\n   float vals[3];\n};\n</code></pre>\n<p>Consider the above definition. (Anonymous unions in C99 aside)</p>\n<p>I suppose this answer possibly permits different answers depending on choice of compiler, choice of language, and choice of standard.</p>\n<ol>\n<li>I believe I am guaranteed (via #pragma compiler documentation, not language guarantee) that <code>sizeof(vec) == 3*sizeof(float)</code></li>\n<li>As such, I believe I am guaranteed that <code>&amp;vec.x == &amp;vec.vals[0]</code>, ect.</li>\n<li>However, I am unsure if it is legal (that is, not allowed via strict aliasing), to write from <code>v.x</code> and then read from <code>v.vals[0]</code></li>\n</ol>\n<p>Packing aside, I believe the relevant verbiage (from the C99 standard, at least) is:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_46323266_46323266_0\">a type compatible with the effective type of the object,</p></li>\n<li><p id=\"so_46323266_46323266_1\">an aggregate or union type that includes one of the aforementioned\n  types among its members (including, recursively, a member of a\n  subaggregate or contained union), or</p></li>\n</ul>\n</blockquote>\n", "AcceptedAnswerId": "46323681", "Title": "Packing and pointer aliasing, C and C++", "CreationDate": "2017-09-20T13:23:01.667", "Id": "46323266", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2017-09-20T13:47:11.570", "Score": "5", "OwnerUserId": "2556973", "Tags": "<c++><c>", "AnswerCount": "1"}});