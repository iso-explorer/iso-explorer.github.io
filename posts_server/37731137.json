post_cb({"bq_ids": {"n4140": {"so_37731137_37731335_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 447}}, "n3337": {"so_37731137_37731335_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 438}}, "n4659": {"so_37731137_37731335_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 469}}}, "37731137": {"ViewCount": "26", "Body": "<p>I get the following linker error with the code below:</p>\n<p><code>undefined reference to</code>IBase::Name() const'`</p>\n<p>Note in the Base class, it's invoking the virtual function Name(). The intention is for the Derived class's implementation of Name to be invoked, but the linker is looking for IBase::Name, not Derived::Name(). How to resolve this?</p>\n<pre><code>template&lt;class T_Extendable&gt;\nclass IBase\n{\npublic:\n    virtual ~IBase() = default;\n    virtual const std::string&amp; Name() const = 0;\n};\n\ntemplate&lt;class T_Extendable&gt;\nclass Base : public IBase&lt;T_Extendable&gt;\n{\npublic:\n    virtual ~Base() { \"Destructing \" &lt;&lt; Name(); } // use virtual function Name()\n};\n\nclass Derived : public Base&lt;Foo&gt;\n{\npublic:\n    virtual ~Derived() = default;\n    const std::string&amp; Name() const final { return \"Derived\"; } // implement pure virtual method IBase::Name()\n};\n</code></pre>\n", "AcceptedAnswerId": "37731335", "Title": "How to link against an overloaded template method", "CreationDate": "2016-06-09T16:06:54.323", "Id": "37731137", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-06-09T16:17:31.503", "Score": "0", "OwnerUserId": "1198184", "Tags": "<c++><templates>", "AnswerCount": "1"}, "37731335": {"Id": "37731335", "PostTypeId": "2", "Body": "<p>You're calling a virtual function from the destructor. By the standard's object lifetime rules, that means that even if the object being destroyed is a <code>Derived</code>, by the time the <code>Base</code> destructor is running it no longer has access to the most-derived type's (in this case <code>Derived</code>'s) virtual function overrides. Thus it attempts to invoke the version declared in <code>IBase</code>, which isn't defined so you get a linker error.</p>\n<p>Note: this is the relevant section of the standard which specifies this behaviour [class.cdtor]:</p>\n<blockquote>\n<p id=\"so_37731137_37731335_0\">4 Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). When a virtual function\n  is called directly or indirectly from a constructor or from a\n  destructor, including during the construction or destruction of the\n  class\u2019s non-static data members, and the object to which the call\n  applies is the object (call it x) under construction or destruction,\n  <strong>the function called is the final overrider in the constructor\u2019s or\n  destructor\u2019s class and not one overriding it in a more-derived class</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-09T16:17:31.503", "CommentCount": "1", "CreationDate": "2016-06-09T16:17:31.503", "ParentId": "37731137", "Score": "3", "OwnerUserId": "6255513"}});