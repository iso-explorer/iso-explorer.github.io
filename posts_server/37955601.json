post_cb({"bq_ids": {"n4140": {"so_37955601_37955601_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 302}, "so_37955601_37955601_0": {"length": 16, "quality": 1.0, "section_id": 64}, "so_37955601_37955601_2": {"length": 15, "quality": 1.0, "section_id": 340}}, "n3337": {"so_37955601_37955601_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 293}, "so_37955601_37955601_0": {"length": 13, "quality": 0.8125, "section_id": 59}, "so_37955601_37955601_2": {"length": 15, "quality": 1.0, "section_id": 330}}, "n4659": {"so_37955601_37955601_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 309}, "so_37955601_37955601_0": {"length": 16, "quality": 1.0, "section_id": 66}, "so_37955601_37955601_2": {"length": 15, "quality": 1.0, "section_id": 349}}}, "37955601": {"ViewCount": "71", "Body": "<p>Playing yet again with variadic templates:</p>\n<pre><code>template &lt;typename... Ts1&gt;\nconstexpr bool ends_with_int(Ts1... ts1) {\n    return false;\n}\n\ntemplate &lt;typename... Ts1&gt;\nconstexpr bool ends_with_int(Ts1... ts1, int i) {\n    return true;\n}\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; ends_with_int(1, 2, 3) &lt;&lt; std::endl;   \n    std::cout &lt;&lt; ends_with_int&lt;int, int, int&gt;(1, 2, 3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; ends_with_int(3) &lt;&lt; std::endl;\n    // below is very similar to the spec example at 14.8.2.1/1\n    std::cout &lt;&lt; ends_with_int&lt;int, int&gt;(1, 2, 3) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Code: <a href=\"http://coliru.stacked-crooked.com/a/f0efb99a0c8f690a\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/f0efb99a0c8f690a</a></p>\n<h2>Output</h2>\n<pre><code>|---|---------------------------------------------------------------|\n| # | ends_with_int                     | clang (3.8) | g++ (6.1)   |\n|---|-----------------------------------|-------------|-------------|\n| 1 |1, 2, 3                            |  false      |  false      |\n|---|---------------------------------------------------------------|\n| 2 |&lt;int, int, int&gt;(1, 2, 3)           |  false      |  false      |\n|---|---------------------------------------------------------------|\n| 3 | 3                                 |  true       |  ambiguity  |\n|---|---------------------------------------------------------------|\n| 4 |&lt;int, int&gt;(1, 2, 3)                |  true       |  ambiguity  |\n|---|---------------------------------------------------------------|\n</code></pre>\n<hr>\n<p>Case 4 is very similar to the example at 14.8.2.1/1 in the spec:</p>\n<pre><code>template&lt;class T1, class ... Types&gt; void g1(Types ..., T1);\n\nvoid h(int x, float&amp; y) {\n  const int z = x;\n  g1(x, y, z);                 // error: Types is not deduced\n  g1&lt;int, int, int&gt;(x, y, z);  // OK, no deduction occurs\n}\n</code></pre>\n<p>IMHO, gcc behavior for case 4 is surprising, clang seems to capture that better.\nFor case 3 it is not clear to me who is right.</p>\n<hr>\n<p>But the difference between the compilers seem to signal that the spec wording for variadic templates is either too complicated or not closing all corners, specifically for the case where function parameter pack is not the last. (See also <a href=\"https://stackoverflow.com/questions/37924796/which-is-the-more-specialized-template-function-clang-and-g-differ-on-that\">other variadic template different behavior between clang and gcc</a>).</p>\n<p>Trying to understand from the spec what is the correct behavior, it seems that the answer is somewhere in the rules of 14.1/11, 14.8.2.1/1 and 14.8.2.5/9, but these sections may contradict each other, to my layman eyes, or at least I need a spec lawyer to assist.</p>\n<p>From <strong><a href=\"http://eel.is/c++draft/temp.param#11\" rel=\"nofollow noreferrer\">14.1/11</a></strong>:</p>\n<blockquote>\n<p id=\"so_37955601_37955601_0\">... A template parameter pack of a function template shall not be followed by another template parameter unless that template parameter can be deduced from the parameter-type-list of the function template [...]</p>\n</blockquote>\n<p>From <strong><a href=\"http://eel.is/c++draft/temp.fct.spec#temp.deduct.call-1\" rel=\"nofollow noreferrer\">14.8.2.1/1</a></strong>:</p>\n<blockquote>\n<p id=\"so_37955601_37955601_1\">... Each deduction deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack. When a function parameter pack appears in a non-deduced context ([temp.deduct.type]), the type of that parameter pack is never deduced. [...]</p>\n</blockquote>\n<p>From <strong><a href=\"http://eel.is/c++draft/temp.fct.spec#temp.deduct.type-9\" rel=\"nofollow noreferrer\">14.8.2.5/9</a></strong>:</p>\n<blockquote>\n<p id=\"so_37955601_37955601_2\">... If the template argument list of P contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context. [...]</p>\n</blockquote>\n<hr>\n<p>Do you see a problem with the wording in the spec? Or is it clear what is the right behavior and compilers shall just align?</p>\n</hr></hr></hr>", "Title": "Variadic Template - Clang and GCC differ again", "CreationDate": "2016-06-21T22:26:47.767", "LastActivityDate": "2016-06-22T08:31:09.867", "CommentCount": "1", "LastEditDate": "2017-05-23T12:32:12.290", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "37955601", "Score": "2", "OwnerUserId": "2085626", "Tags": "<c++><templates><c++11><variadic-templates><overload-resolution>", "AnswerCount": "0"}});