post_cb({"23505744": {"ParentId": "23505423", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_23505423_23505744_0\">Is this restriction part of the language specification? If yes, why C++ designers want to do that?</p>\n</blockquote>\n<p>Yes, it is. Quoting from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a>, \u00a713.5.6 [over.oper]:</p>\n<blockquote>\n<p id=\"so_23505423_23505744_1\">An operator function shall either be a non-static member function or be a non-member function and have at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.</p>\n</blockquote>\n<p>About the \"why\" part, because removing this requirement would mean that you could overload operators for builtin types, which already have their operator semantics defined. That's something totally undesiderable. </p>\n<p>For instance, do you think that defining this makes any sense? </p>\n<pre><code>int operator+(int a, int b) { return a - b; }\n</code></pre>\n<p>Does it allow more people to reason about your program when they read your code, or is it just something surprising that effectively breaks your reasoning?</p>\n<p>What happens if we get pointers into the game? </p>\n<pre><code>bool operator==(const char *str1, const char *str2) { \n    return strcmp(str1, str2) == 0;\n}\n</code></pre>\n<p>Would you expect that <code>operator==</code> now dereferences memory? I wouldn't. It's surprising. It goes against what the Standard already says about these operators. It breaks what every C program in the last 25 years behaved like. The language shouldn't let you do this kind of abuses.</p>\n", "OwnerUserId": "1873944", "LastEditorUserId": "1873944", "LastEditDate": "2014-05-06T22:49:34.340", "Id": "23505744", "Score": "4", "CreationDate": "2014-05-06T22:42:21.703", "LastActivityDate": "2014-05-06T22:49:34.340"}, "23505827": {"ParentId": "23505423", "CommentCount": "2", "Body": "<blockquote id=\"so_23505423_23505827_0\">\n<ol>\n<li>Is this restriction part of the language specification?</li>\n</ol>\n</blockquote>\n<p>Yes, it is. Why? Well, the main reason is probably because redefining the usual operators for standard types is seen as obfuscating. Imagin overloading <code>operator+(int,int)</code> or <code>operator+(int,char*)</code>. That would change the meaning of existing code!</p>\n<p>You could argue that there are operators between standard types that are not defined, so you could safely override them, for example <code>operator*(char*,int)</code>, but that is usually seen as rather useless.</p>\n<p>Moreover, operator overloads must be global, (or be in the namespace of some of its members (argument dependent lookup), but with standard types there are no namespace to depend on), so interoperatibility between libraries that fancy to override them would be a nightmare.</p>\n<blockquote id=\"so_23505423_23505827_1\">\n<ol>\n<li><code>\"hello\" + \"world\"</code>: why doesn't the compiler convert the two char* \"s to two strings?</li>\n</ol>\n</blockquote>\n<p>Well, for one, <code>std::operator+(const std::string&amp;, const std::string&amp;)</code> is in <code>namespace std;</code> so it will not be found by default.</p>\n<p>You could try calling the operator explicitly: <code>std::operator+(\"hello\", \"world\")</code>, but alas, there are so many <code>operator+()</code> overloads, many of them templates, that the call is ambiguous.</p>\n<p>So, taking all this into account, I think that a reasonable requirement is that at least one of the operators to be of a user-defined type. Think about it: the global and namespace problem is solved, ADL can be used (actually it was invented for this use) and it is impossible to redefine an operator with an existing meaning (except <code>operator,()</code> and <code>operator&amp;()</code>, I think, but who wants to override these...).</p>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "23505827", "Score": "5", "CreationDate": "2014-05-06T22:50:28.943", "LastActivityDate": "2014-05-06T22:50:28.943"}, "bq_ids": {"n4140": {"so_23505423_23505744_1": {"section_id": 653, "quality": 0.95, "length": 19}, "so_23505423_23505423_0": {"section_id": 653, "quality": 0.75, "length": 9}}, "n3337": {"so_23505423_23505744_1": {"section_id": 643, "quality": 1.0, "length": 20}, "so_23505423_23505423_0": {"section_id": 643, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_23505423_23505744_1": {"section_id": 681, "quality": 0.95, "length": 19}, "so_23505423_23505423_0": {"section_id": 681, "quality": 0.75, "length": 9}}}, "23505423": {"CommentCount": "7", "AcceptedAnswerId": "23505827", "PostTypeId": "1", "LastEditorUserId": "1593180", "CreationDate": "2014-05-06T22:13:08.070", "LastActivityDate": "2014-05-06T22:50:28.943", "LastEditDate": "2014-05-06T22:28:04.710", "ViewCount": "2589", "FavoriteCount": "1", "Title": "why C++ operator overloading requires \"having at least one parameter of class type\"?", "Id": "23505423", "Score": "5", "Body": "<p>The chapter 14.1 of \"C++ primer 5th edition\" reads, </p>\n<blockquote>\n<p id=\"so_23505423_23505423_0\">An operator function must either be a member of a class or have at least one parameter of class type. </p>\n</blockquote>\n<p>For example, <code>string(\"hello\")+\"world\"</code> compiles <code>\"hello\"+\"world\"</code> doesn't. And when I want to overload the <code>+</code> on two C strings.</p>\n<pre><code>std::string operator+ (const char* s1, const char* s2)\n</code></pre>\n<p>I get the following error. </p>\n<blockquote>\n<p id=\"so_23505423_23505423_1\">error: \u2018std::string operator+(const char*, const char*)\u2019 must have an argument of class or enumerated type</p>\n</blockquote>\n<p>I have two questions.</p>\n<ol>\n<li><p><strong>Is this restriction part of the language specification?</strong> If yes, why C++ designers want to do that?</p></li>\n<li><p><code>std::string</code> has constructor like <code>string (const char* s);</code>, which implies that compiler can do implicit class-type conversion from <code>char*</code> to <code>string</code>. When we call <code>\"hello\"+\"world\"</code>, <strong>why doesn't the compiler convert the two <code>char*</code> \"s to two strings?</strong> After all, there is a overloading \"+\" on two std::strings. \n<code>string operator+ (const string&amp; lhs, const string&amp; rhs);</code></p></li>\n</ol>\n", "Tags": "<c++><c++11><operator-overloading>", "OwnerUserId": "1593180", "AnswerCount": "3"}, "23505721": {"ParentId": "23505423", "CommentCount": "8", "Body": "<p>As Bjarne said in <em>Design and Evolution</em>, the goal was to make it easy to <em>extend</em> the language, not to <em>mutate</em> it. If you allowed overloading only builtin types, you would change the language, and allowing that went against the design goals. (For example, it would encourage the formation of mutually incompatible dialects and fracture the community.)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "23505721", "Score": "7", "CreationDate": "2014-05-06T22:40:19.657", "LastActivityDate": "2014-05-06T22:40:19.657"}});