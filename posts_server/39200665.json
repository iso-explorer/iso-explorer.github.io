post_cb({"39200904": {"ParentId": "39200665", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I don't know what you intend to do with that <code>string</code>, but if<br>\nall you need is a buffer of chars which frees its own memory automatically,<br>\nthen I usually use <code>vector&lt;char&gt;</code> or <code>vector&lt;int&gt;</code> or whatever type<br>\nof buffer you need.</br></br></br></p>\n<p>With <code>v</code> being the vector, it's guaranteed that <code>&amp;v[0]</code> points to <br>\na sequential memory which you can use as a buffer.</br></p>\n", "OwnerUserId": "888731", "LastEditorUserId": "888731", "LastEditDate": "2016-08-29T12:11:01.653", "Id": "39200904", "Score": "0", "CreationDate": "2016-08-29T07:39:57.513", "LastActivityDate": "2016-08-29T12:11:01.653"}, "39200852": {"ParentId": "39200665", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can simply use <code>&amp;s[0]</code> for a non-empty string. This gives you a pointer to the start of the buffer</p>\n<p>When you use it to put a string of <em>n</em> characters there the <code>string</code>'s length (not just the capacity) needs to be at least <em>n</em> beforehand, because there's no way to adjust it up without clobbering the data.</p>\n<p>I.e., usage can go like this:</p>\n<pre><code>auto foo( int const n )\n    -&gt; string\n{\n    if( n &lt;= 0 ) { return \"\"; }\n\n    string result( n, '#' );   // # is an arbitrary fill character.\n    int const n_stored = some_api_function( &amp;result[0], n );\n    assert( n_stored &lt;= n );\n    result.resize( n_stored );\n    return result;\n}\n</code></pre>\n<p>This approach has worked formally since C++11. Before that, in C++98 and C++03, the buffer was not formally guaranteed to be contiguous. However, for the in-practice the approach has worked since C++98, the first standard  \u2013  the reason that the contiguous buffer requirement could be adopted in C++11 (it was added in the Lillehammer meeting, I think that was 2005) was that there were no extant standard library implementations with a non-contiguous string buffer.</p>\n<hr>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_39200665_39200852_0\"><strong>\u201d</strong> C++17 added added non-const <code>data()</code> to <code>std::string</code> but it still says that you can't modify the buffer.</p>\n</blockquote>\n<p>I'm not aware of any such wording, and since that would defeat the purpose of non-const <code>data()</code> I doubt that this statement is correct.</p>\n<hr>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_39200665_39200852_1\"><strong>\u201d</strong> Now I plan to work with big amount of information and copying this buffer will have a noticeable impact and I want to avoid it.</p>\n</blockquote>\n<p>If copying the buffer has a noticeable impact, then you'd want to avoid inadvertently copying the <code>std::string</code>.</p>\n<p>One way is to wrap it in a class that's not copyable.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2016-08-29T07:55:13.387", "Id": "39200852", "Score": "0", "CreationDate": "2016-08-29T07:37:13.537", "LastActivityDate": "2016-08-29T07:55:13.387"}, "39200666": {"ParentId": "39200665", "PostTypeId": "2", "CommentCount": "8", "Body": "<h1>C++98/03</h1>\n<p>Impossible. String can be copy on write so it needs to handle all reads and writes.</p>\n<h1>C++11/14</h1>\n<p>In [string.require]:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_0\">The char-like objects in a <code>basic_string</code> object shall be stored contiguously. That is, for any <code>basic_string</code>\n  object <code>s</code>, the identity <code>&amp;*(s.begin() + n) == &amp;*s.begin() + n</code> shall hold for all values of <code>n</code> such that <code>0 &lt;= n &lt; s.size()</code>.</p>\n</blockquote>\n<p>So <code>&amp;str.front()</code> and <code>&amp;str[0]</code> should work.</p>\n<h1>C++17</h1>\n<p><code>str.data()</code>, <code>&amp;str.front()</code> and <code>&amp;str[0]</code> work.</p>\n<p><a href=\"http://eel.is/c++draft/string.ops\">Here</a> it says:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_1\"><code>charT* data() noexcept;</code></p>\n<p id=\"so_39200665_39200666_2\">Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0, size()]</code>.</p>\n<p id=\"so_39200665_39200666_3\">Complexity: Constant time.</p>\n<p id=\"so_39200665_39200666_4\">Requires: The program shall not alter the value stored <code>at p + size()</code>.</p>\n</blockquote>\n<p>The non-const <code>.data()</code> just works.</p>\n<p>The <a href=\"http://eel.is/c++draft/string.access\">recent draft</a> has the following wording for <code>.front()</code>:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_5\"><code>const charT&amp; front() const;</code></p>\n<p id=\"so_39200665_39200666_6\"><code>charT&amp; front();</code></p>\n<p id=\"so_39200665_39200666_7\">Requires: <code>!empty()</code>.</p>\n<p id=\"so_39200665_39200666_8\">Effects: Equivalent to <code>operator[](0)</code>.</p>\n</blockquote>\n<p>And the following for <code>operator[]</code>:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_9\"><code>const_reference operator[](size_type pos) const;</code></p>\n<p id=\"so_39200665_39200666_10\"><code>reference       operator[](size_type pos);</code></p>\n<p id=\"so_39200665_39200666_11\">Requires: <code>pos &lt;= size()</code>.</p>\n<p id=\"so_39200665_39200666_12\">Returns: <code>*(begin() + pos) if pos &lt; size()</code>. Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where modifying the object leads to undefined behavior.</p>\n<p id=\"so_39200665_39200666_13\">Throws: Nothing.</p>\n<p id=\"so_39200665_39200666_14\">Complexity: Constant time.</p>\n</blockquote>\n<p>So it uses iterator arithmetic. so we need to inspect the information about iterators. <a href=\"http://eel.is/c++draft/basic.string\">Here</a> it says:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_15\">3 A basic_string is a contiguous container ([container.requirements.general]).</p>\n</blockquote>\n<p>So we need to go <a href=\"http://eel.is/c++draft/container.requirements.general#13\">here</a>:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_16\">A contiguous container is a container that supports random access iterators ([random.access.iterators]) and whose member types <code>iterator</code> and <code>const_iterator</code> are contiguous iterators ([iterator.requirements.general]).</p>\n</blockquote>\n<p>Then <a href=\"http://eel.is/c++draft/iterator.requirements.general#5\">here</a>:</p>\n<blockquote>\n<p id=\"so_39200665_39200666_17\">Iterators that further satisfy the requirement that, for integral values n and dereferenceable iterator values <code>a</code> and <code>(a + n)</code>, <code>*(a + n)</code> is equivalent to <code>*(addressof(*a) + n)</code>, are called contiguous iterators.</p>\n</blockquote>\n<p>Apparently, contiguous iterators are a C++17 feature which was added in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf\">these</a> <a href=\"https://isocpp.org/files/papers/n4132.html\">papers</a>.</p>\n<p>The requirement can be rewritten as:</p>\n<pre><code>assert(*(a + n) == *(&amp;*a + n));\n</code></pre>\n<p>So, in the second part we dereference iterator, then take address of the value it points to, then do a pointer arithmetic on it, dereference it and it's the same as incrementing an iterator and then dereferencing it. This means that contiguous iterator points to the memory where each value stored right after the other, hence contiguous. Since functions that take <code>char*</code> expect contiguous memory, you can pass the result of <code>&amp;str.front()</code> or <code>&amp;str[0]</code> to these functions.</p>\n", "OwnerUserId": "3624760", "LastEditorUserId": "3624760", "LastEditDate": "2016-08-29T08:22:31.867", "Id": "39200666", "Score": "12", "CreationDate": "2016-08-29T07:26:45.077", "LastActivityDate": "2016-08-29T08:22:31.867"}, "bq_ids": {"n4140": {"so_39200665_39200666_12": {"section_id": 1617, "quality": 0.9473684210526315, "length": 18}, "so_39200665_39200666_5": {"section_id": 1621, "quality": 1.0, "length": 4}, "so_39200665_39200666_0": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}, "so_39200665_39200666_16": {"section_id": 763, "quality": 0.5625, "length": 9}}, "n3337": {"so_39200665_39200666_12": {"section_id": 1613, "quality": 0.9473684210526315, "length": 18}, "so_39200665_39200666_5": {"section_id": 1618, "quality": 1.0, "length": 4}, "so_39200665_39200666_0": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}, "so_39200665_39200666_16": {"section_id": 750, "quality": 0.5625, "length": 9}}, "n4659": {"so_39200665_39200666_5": {"section_id": 1774, "quality": 1.0, "length": 4}, "so_39200665_39200666_12": {"section_id": 1770, "quality": 0.9473684210526315, "length": 18}, "so_39200665_39200666_17": {"section_id": 7005, "quality": 0.9285714285714286, "length": 13}, "so_39200665_39200666_4": {"section_id": 1932, "quality": 0.6666666666666666, "length": 4}, "so_39200665_39200666_16": {"section_id": 743, "quality": 0.8125, "length": 13}}}, "39200665": {"CommentCount": "3", "AcceptedAnswerId": "39200666", "PostTypeId": "1", "LastEditorUserId": "3624760", "CreationDate": "2016-08-29T07:26:45.077", "LastActivityDate": "2016-08-29T12:11:01.653", "LastEditDate": "2016-08-29T08:13:33.123", "ViewCount": "1061", "FavoriteCount": "1", "Title": "Directly write into char* buffer of std::string", "Id": "39200665", "Score": "2", "Body": "<p>So I have an <code>std::string</code> and have a function which takes <code>char*</code> and writes into it. Since <code>std::string::c_str()</code> and <code>std::string::data()</code> return <code>const char*</code>, I can't use them. So I was allocating a temporary buffer, calling a function with it and copying it into <code>std::string</code>.</p>\n<p>Now I plan to work with big amount of information and copying this buffer will have a noticeable impact and I want to avoid it.</p>\n<p>Some people suggested to use <code>&amp;str.front()</code> or <code>&amp;str[0]</code> but does it invoke the undefined behavior?</p>\n", "Tags": "<c++><string><c++14><language-lawyer><c++1z>", "OwnerUserId": "3624760", "AnswerCount": "3"}});