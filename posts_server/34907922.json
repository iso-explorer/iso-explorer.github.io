post_cb({"34908323": {"ParentId": "34907922", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Yes; No.  Not within C++.</p>\n<p>The abstract machine of C++ does not talk about system allocation calls at all.  Only the side effects of such a call that impact the behavior of the abstract machine are fixed by C++, and even then the compiler is free to do something else, so long as-if it results in the same observable behavior on the part of the program in the abstract machine.</p>\n<p>In the abstract machine, <code>auto mem = std::make_unique&lt;std::array&lt;double, 5000000&gt;&gt;();</code> creates a variable <code>mem</code>.  It, if used, gives you access to a large amount of <code>double</code>s packed into an array.  The abstract machine is free to throw an exception, or provide you with that large amount of <code>double</code>s; either is fine.</p>\n<p>Note that it is a legal C++ compiler to replace all allocations through <code>new</code> with an unconditional <code>throw</code> of an allocation failure (or returning <code>nullptr</code> for the no throw versions), but that would be a poor quality of implementation.</p>\n<p>In the case where it is allocated, the C++ standard doesn't really say where it comes from.  The compiler is free to use a static array, for example, and make the <code>delete</code> call a no-op (note it may have to prove it catches all ways to call <code>delete</code> on the buffer).</p>\n<p>Next, if you have a static array, if nobody reads or writes to it (and the construction cannot be observed), the compiler is free to eliminate it.</p>\n<hr>\n<p>That being said, much of the above relies on the compiler knowing what is going on.</p>\n<p>So an approach is to make it impossible for the compiler to know.  Have your code load a DLL, then pass a pointer to the <code>unique_ptr</code> to that DLL at the points where you want its state to be known.</p>\n<p>Because the compiler cannot optimize over run-time DLL calls, the state of the variable has to basically be what you'd expect it to be.</p>\n<p>Sadly, there is no standard way to dynamically load code like that in C++, so you'll have to rely upon your current system.</p>\n<p>Said DLL can be separately written to be a noop; or, even, you can examine some external state, and conditionally load and pass the data to the DLL based on the external state.  So long as the compiler cannot prove said external state will occur, it cannot optimize around the calls <em>not</em> being made.  Then, never set that external state.</p>\n<p>Declare the variable at the top of the block.  Pass a pointer to it to the fake-external-DLL while uninitialized.  Repeat just before initializing it, then after.  Then finally, do it at the end of the block before destroying it, <code>.reset()</code> it, then do it again.</p>\n</hr>", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2016-01-20T19:06:40.480", "Id": "34908323", "Score": "4", "CreationDate": "2016-01-20T19:03:24.147", "LastActivityDate": "2016-01-20T19:06:40.480"}, "bq_ids": {"n4140": {"so_34907922_34907922_4": {"section_id": 6813, "quality": 0.9090909090909091, "length": 10}, "so_34907922_34907922_1": {"section_id": 5801, "quality": 1.0, "length": 18}}, "n3337": {"so_34907922_34907922_4": {"section_id": 6568, "quality": 0.9090909090909091, "length": 10}, "so_34907922_34907922_1": {"section_id": 5574, "quality": 1.0, "length": 18}}, "n4659": {"so_34907922_34907922_4": {"section_id": 8303, "quality": 0.5454545454545454, "length": 6}, "so_34907922_34907922_1": {"section_id": 7260, "quality": 1.0, "length": 18}}}, "34907922": {"CommentCount": "11", "ViewCount": "167", "PostTypeId": "1", "LastEditorUserId": "1149664", "CreationDate": "2016-01-20T18:40:07.623", "LastActivityDate": "2016-07-15T17:02:51.127", "Title": "as-if rule and removal of allocation", "AcceptedAnswerId": "34908323", "LastEditDate": "2016-07-15T17:02:51.127", "Id": "34907922", "Score": "9", "Body": "<p>The \"<a href=\"http://[1]%20[as_if%20rule][1]http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">as-if rule</a>\" gives the compiler the right to optimize out or reorder expressions that would not make a difference to the output and correctness of a program under certain rules, such as; </p>\n<blockquote>\n<p id=\"so_34907922_34907922_0\">\u00a71.9.5</p>\n<p id=\"so_34907922_34907922_1\">A conforming implementation executing a well-formed program shall\n  produce the same observable behavior as one of the possible executions\n  of the corresponding instance of the abstract machine with the same\n  program and the same input.</p>\n</blockquote>\n<p>The cppreference url I linked above specifically mentions special rules for the values of volatile objects, as well as for \"new expressions\", under C++14:</p>\n<blockquote>\n<p id=\"so_34907922_34907922_2\">New-expression has another exception from the as-if rule: the compiler\n  may remove calls to the replaceable allocation functions even if a\n  user-defined replacement is provided and has observable side-effects.</p>\n</blockquote>\n<p>I assume \"replaceable\" here is what is talked about for example in </p>\n<blockquote>\n<p id=\"so_34907922_34907922_3\">\u00a718.6.1.1.2</p>\n<p id=\"so_34907922_34907922_4\">Replaceable: a C++ program may define a function with this function\n  signature that displaces the default version defined by the C++\n  standard library.</p>\n</blockquote>\n<p>Is it correct that <code>mem</code> below can be removed or reordered under the as-if rule?  </p>\n<pre><code>  {\n  ... some conformant code // upper block of code\n\n  auto mem = std::make_unique&lt;std::array&lt;double, 5000000&gt;&gt;();\n\n  ... more conformant code, not using mem // lower block of code\n  }\n</code></pre>\n<p>Is there a way to ensure it's not removed, and stays between the upper and lower blocks of code? A well placed volatile (either/or volatile std::array or left of auto) comes to mind, but as there is no reading of <code>mem</code>, I think even that would not help under the <em>as-if</em> rule.</p>\n<p>Side note; I've not been able to get visual studio 2015 to optimize out <code>mem</code> and the allocation at all.</p>\n<p>Clarification: The way to <em>observe</em> this would be that the allocation call to the OS comes between any i/o from the two blocks. The point of this is for test cases and/or trying to get objects to be allocated at new locations.</p>\n", "Tags": "<c++><c++14><as-if>", "OwnerUserId": "1149664", "AnswerCount": "1"}});