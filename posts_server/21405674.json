post_cb({"21405674": {"CommentCount": "3", "AcceptedAnswerId": "21407037", "PostTypeId": "1", "LastEditorUserId": "420683", "CreationDate": "2014-01-28T12:34:57.007", "LastActivityDate": "2015-06-10T09:07:54.173", "LastEditDate": "2014-01-28T12:58:17.220", "ViewCount": "3812", "FavoriteCount": "5", "Title": "why do i need to use piecewise_construct in map::emplace for single arg constructors of noncopyable objects?", "Id": "21405674", "Score": "18", "Body": "<p>The following code will not compile on gcc 4.8.2.\nThe problem is that this code will attempt to copy construct an <code>std::pair&lt;int, A&gt;</code> which can't happen due to <code>struct A</code> missing copy and move constructors.</p>\n<p>Is gcc failing here or am I missing something?</p>\n<pre><code>#include &lt;map&gt;\nstruct A\n{\n  int bla;\n  A(int blub):bla(blub){}\n  A(A&amp;&amp;) = delete;\n  A(const A&amp;) = delete;\n  A&amp; operator=(A&amp;&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\nint main()\n{\n  std::map&lt;int, A&gt; map;\n  map.emplace(1, 2); // doesn't work\n  map.emplace(std::piecewise_construct,\n          std::forward_as_tuple(1),\n          std::forward_as_tuple(2)\n  ); // works like a charm\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><map><std-pair><emplace>", "OwnerUserId": "1103681", "AnswerCount": "1"}, "21407037": {"ParentId": "21405674", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>As far as I can tell, the issue isn't caused by <code>map::emplace</code>, but by <code>pair</code>'s constructors:</p>\n<pre><code>#include &lt;map&gt;\n\nstruct A\n{\n    A(int) {}\n    A(A&amp;&amp;) = delete;\n    A(A const&amp;) = delete;\n};\n\nint main()\n{\n    std::pair&lt;int, A&gt; x(1, 4); // error\n}\n</code></pre>\n<p>This code example doesn't compile, neither with coliru's g++4.8.1 nor with clang++3.5, which are both using libstdc++, as far as I can tell.</p>\n<p>The issue is rooted in the fact that although we can construct</p>\n<pre><code>A t(4);\n</code></pre>\n<p>that is, <code>std::is_constructible&lt;A, int&gt;::value == true</code>, we cannot <em>implicitly convert</em> an <code>int</code> to an <code>A</code> [conv]/3</p>\n<blockquote>\n<p id=\"so_21405674_21407037_0\">An expression <code>e</code> can be <em>implicitly converted</em> to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed,\n  for some invented temporary variable <code>t</code>.</p>\n</blockquote>\n<p>Note the copy-initialization (the <code>=</code>). This creates a temporary <code>A</code> and initializes <code>t</code> from this temporary, [dcl.init]/17. This initialization from a temporary tries to call the deleted move ctor of <code>A</code>, which makes the conversion ill-formed.</p>\n<hr>\n<p>As we cannot convert from an <code>int</code> to an <code>A</code>, the constructor of <code>pair</code> that one would expect to be called <em>is rejected by SFINAE</em>. This behaviour is surprising, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html\" rel=\"nofollow noreferrer\">N4387 - Improving pair and tuple</a> analyses and tries to improve the situation, by making the constructor <code>explicit</code> instead of rejecting it. N4387 has been voted into C++1z at the Lenexa meeting.</p>\n<p>The following describes the C++11 rules.</p>\n<p>The constructor I had expected to be called is described in [pairs.pair]/7-9</p>\n<blockquote>\n<pre><code>template&lt;class U, class V&gt; constexpr pair(U&amp;&amp; x, V&amp;&amp; y);\n</code></pre>\n<p id=\"so_21405674_21407037_1\">7 \u00a0\u00a0 <em>Requires:</em> <code>is_constructible&lt;first_type, U&amp;&amp;&gt;::value</code> is <code>true</code> and\n  <code>is_constructible&lt;second_type, V&amp;&amp;&gt;::value</code> is <code>true</code>.</p>\n<p id=\"so_21405674_21407037_2\">8 \u00a0\u00a0 <em>Effects:</em> The\n  constructor initializes first with <code>std::forward&lt;U&gt;(x)</code> and second with\n  <code>std::forward&lt;V&gt;(y)</code>.</p>\n<p id=\"so_21405674_21407037_3\">9 \u00a0\u00a0 <em>Remarks:</em> If <code>U</code> is not implicitly convertible to\n  <code>first_type</code> or <code>V</code> is not implicitly convertible to <code>second_type</code> this\n  constructor shall not participate in overload resolution.</p>\n</blockquote>\n<p>Note the difference between <code>is_constructible</code> in the <em>Requires</em> section, and \"is not implicitly convertible\" in the <em>Remarks</em> section. The requirements are fulfilled to call this constructor, but it may not participate in overload resolution (= has to be rejected via SFINAE).</p>\n<p>Therefore, overload resolution needs to select a \"worse match\", namely one whose second parameter is a <code>A const&amp;</code>. A temporary is created from the <code>int</code> argument and bound to this reference, and the reference is used to initialize the <code>pair</code> data member (<code>.second</code>). The initialization tries to call the deleted copy ctor of <code>A</code>, and the construction of the pair is ill-formed.</p>\n<hr>\n<p>libstdc++ has (as an extension) some nonstandard ctors. In the <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01514_source.html#l00096\" rel=\"nofollow noreferrer\">latest doxygen</a> (and in 4.8.2), the constructor of <code>pair</code> that I had expected to be called (being surprised by the rules required by the Standard) is:</p>\n<pre><code>template&lt;class _U1, class _U2,\n         class = typename enable_if&lt;__and_&lt;is_convertible&lt;_U1, _T1&gt;,\n                                           is_convertible&lt;_U2, _T2&gt;\n                                          &gt;::value\n                                   &gt;::type&gt;\nconstexpr pair(_U1&amp;&amp; __x, _U2&amp;&amp; __y)\n: first(std::forward&lt;_U1&gt;(__x)), second(std::forward&lt;_U2&gt;(__y)) { }\n</code></pre>\n<p>and the one that <em>is actually</em> called is the non-standard:</p>\n<pre><code>// DR 811.\ntemplate&lt;class _U1,\n         class = typename enable_if&lt;is_convertible&lt;_U1, _T1&gt;::value&gt;::type&gt;\nconstexpr pair(_U1&amp;&amp; __x, const _T2&amp; __y)\n: first(std::forward&lt;_U1&gt;(__x)), second(__y) { }\n</code></pre>\n<p>The program is ill-formed according to the Standard, it is <strong>not</strong> merely rejected by this non-standard ctor.</p>\n<hr>\n<p>As a final remark, here's the specification of <code>is_constructible</code> and <code>is_convertible</code>.</p>\n<p><code>is_constructible</code> [meta.rel]/4</p>\n<blockquote>\n<p id=\"so_21405674_21407037_4\">Given the following function prototype:</p>\n<pre><code>template &lt;class T&gt;\ntypename add_rvalue_reference&lt;T&gt;::type create();\n</code></pre>\n<p id=\"so_21405674_21407037_5\">the predicate condition for a template specialization <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the following variable definition would be well-formed for some invented variable <code>t</code>:</p>\n<pre><code>T t(create&lt;Args&gt;()...);\n</code></pre>\n<p id=\"so_21405674_21407037_6\">[<em>Note:</em> These tokens are never interpreted as a function declaration. \u2014 <em>end note</em>] Access checking is performed as if in a context unrelated to <code>T</code> and any of the <code>Args</code>. Only the validity of the immediate context of the variable initialization is considered.</p>\n</blockquote>\n<p><code>is_convertible</code> [meta.unary.prop]/6:</p>\n<blockquote>\n<p id=\"so_21405674_21407037_7\">Given the following function prototype:</p>\n<pre><code>template &lt;class T&gt;\ntypename add_rvalue_reference&lt;T&gt;::type create();\n</code></pre>\n<p id=\"so_21405674_21407037_8\">the predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code> shall be satisfied if and\n  only if the return expression in the following code would be well-formed, including any implicit conversions\n  to the return type of the function:</p>\n<pre><code>To test() {\n  return create&lt;From&gt;();\n}\n</code></pre>\n<p id=\"so_21405674_21407037_9\">[<em>Note:</em> This requirement gives well defined results for reference types, void types, array types, and function types. \u2014 <em>end note</em>] Access checking is performed as if in a context unrelated to <code>To</code> and <code>From</code>. Only\n  the validity of the immediate context of the expression of the <em>return-statement</em> (including conversions to\n  the return type) is considered. </p>\n</blockquote>\n<hr>\n<p>For your type <code>A</code>,</p>\n<pre><code>A t(create&lt;int&gt;());\n</code></pre>\n<p>is well-formed; however</p>\n<pre><code>A test() {\n  return create&lt;int&gt;();\n}\n</code></pre>\n<p>creates a temporary of type <code>A</code> and tries to <em>move</em> that into the return-value (copy-initialization). That selects the deleted ctor <code>A(A&amp;&amp;)</code> and is therefore ill-formed.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2015-06-10T09:07:54.173", "Id": "21407037", "Score": "16", "CreationDate": "2014-01-28T13:35:22.880", "LastActivityDate": "2015-06-10T09:07:54.173"}, "bq_ids": {"n4140": {"so_21405674_21407037_9": {"section_id": 4718, "quality": 0.8181818181818182, "length": 27}, "so_21405674_21407037_4": {"section_id": 4710, "quality": 1.0, "length": 4}, "so_21405674_21407037_6": {"section_id": 4710, "quality": 0.7619047619047619, "length": 16}, "so_21405674_21407037_0": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_21405674_21407037_3": {"section_id": 3964, "quality": 0.9090909090909091, "length": 10}, "so_21405674_21407037_2": {"section_id": 3963, "quality": 0.625, "length": 5}, "so_21405674_21407037_1": {"section_id": 3962, "quality": 0.5714285714285714, "length": 4}, "so_21405674_21407037_5": {"section_id": 4710, "quality": 1.0, "length": 15}, "so_21405674_21407037_7": {"section_id": 4710, "quality": 1.0, "length": 4}, "so_21405674_21407037_8": {"section_id": 4718, "quality": 1.0, "length": 18}}, "n3337": {"so_21405674_21407037_9": {"section_id": 4525, "quality": 0.8181818181818182, "length": 27}, "so_21405674_21407037_4": {"section_id": 4518, "quality": 1.0, "length": 4}, "so_21405674_21407037_6": {"section_id": 4518, "quality": 0.7619047619047619, "length": 16}, "so_21405674_21407037_0": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_21405674_21407037_3": {"section_id": 3821, "quality": 0.9090909090909091, "length": 10}, "so_21405674_21407037_2": {"section_id": 3820, "quality": 0.625, "length": 5}, "so_21405674_21407037_1": {"section_id": 3819, "quality": 0.5714285714285714, "length": 4}, "so_21405674_21407037_5": {"section_id": 4518, "quality": 1.0, "length": 15}, "so_21405674_21407037_7": {"section_id": 4518, "quality": 1.0, "length": 4}, "so_21405674_21407037_8": {"section_id": 4525, "quality": 1.0, "length": 18}}, "n4659": {"so_21405674_21407037_9": {"section_id": 6117, "quality": 0.696969696969697, "length": 23}, "so_21405674_21407037_6": {"section_id": 6107, "quality": 0.7619047619047619, "length": 16}, "so_21405674_21407037_0": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_21405674_21407037_5": {"section_id": 6107, "quality": 1.0, "length": 15}, "so_21405674_21407037_3": {"section_id": 5649, "quality": 0.5454545454545454, "length": 6}, "so_21405674_21407037_8": {"section_id": 6117, "quality": 1.0, "length": 18}}}});