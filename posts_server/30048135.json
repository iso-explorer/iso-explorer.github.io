post_cb({"30048395": {"ParentId": "30048135", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This is from Paragraph 4.7 \"Integral Conversions\" of document N3797, the latest working draft of the C++14 standard:</p>\n<blockquote>\n<p id=\"so_30048135_30048395_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em> is\n  the number of bits used to represent the unsigned type). [ Note: In a\n  two\u2019s complement representation, this conversion is conceptual and\n  there is no change in the bit pattern (if there is no truncation).\n  \u2014end note ]</p>\n</blockquote>\n<p>To a first approximation, all computers in the world use two's complement representation. So [1] is the way to go (unless you are porting C++ to the IBM 7090).</p>\n", "OwnerUserId": "428857", "LastEditorUserId": "464581", "LastEditDate": "2015-05-05T09:54:31.913", "Id": "30048395", "Score": "8", "CreationDate": "2015-05-05T08:57:04.320", "LastActivityDate": "2015-05-05T09:54:31.913"}, "30050906": {"ParentId": "30048135", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>[3] is correct in both C and C++ (as of C++14 but not previously); there is no need to use <code>memcpy</code> in this case. (That said, there's no reason <em>not</em> to use <code>memcpy</code>, as it communicates your intent effectively, is <em>obviously</em> safe, and has zero overhead.)</p>\n<p>C, <strong>6.5 Expressions</strong>:</p>\n<blockquote>\n<p id=\"so_30048135_30050906_0\">7 - An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types: [...]<br/></p>\n<ul>\n<li>a type that is the signed or unsigned type corresponding to the effective type of the\n  object, [...]</li>\n</ul>\n</blockquote>\n<p>C++, <strong>[basic.lval]</strong>:</p>\n<blockquote>\n<p id=\"so_30048135_30050906_1\">10 - If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined: [...]</p>\n<ul>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object, [...]</li>\n</ul>\n</blockquote>\n<p>As you can see, the wording in the two standards is very similar and so can be relied upon across the two languages.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2015-05-05T14:53:10.543", "Id": "30050906", "Score": "7", "CreationDate": "2015-05-05T10:48:11.060", "LastActivityDate": "2015-05-05T14:53:10.543"}, "30048310": {"ParentId": "30048135", "PostTypeId": "2", "CommentCount": "5", "Body": "<pre><code>/* [1] */\nint i = -1;\nunsigned u = (unsigned)i;\n</code></pre>\n<p>\u2191 This is guaranteed to <em>not</em> work on a sign-and-magnitude or 1's complement machine, because conversion to unsigned is guaranteed to yield the signed value modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of value representation bits in the unsigned type. I.e. the conversion is guaranteed to yield the same result <em>as if</em> the signed type used two's complement representation.</p>\n<hr>\n<pre><code>/* [2] */\nint i = -1;\nunsigned u;\nmemcpy(&amp;u, &amp;i, sizeof i);\n</code></pre>\n<p>\u2191 This would work nicely, because the types are guaranteed to have the same size.</p>\n<hr>\n<pre><code>/* [3] */\nint i = -1;\nunsigned u = *(unsigned *)&amp;i;\n</code></pre>\n<p>\u2191 This is formally Undefined Behavior in C++11 and earlier, but it's one of the cases included in the \"strict aliasing\" clause in the standard, and so it's probably supported by every extant compiler. Also, it's an example of what <code>reinterpret_cast</code> is there <em>for</em>. And in C++14 and later the language about undefined behavior has been removed from <sup>(1)</sup>the section on lvalue to rvalue conversion.</p>\n<p>If I did this I would use the named C++ cast for clarity.</p>\n<p>I would however try out what the sometimes look-the-standard-allows-me-to-do-the-impractical-thing compilers have to say about it, in particular g++ with its strict aliasing option, whatever it is, but also clang, since it's designed as a drop-in replacement for g++.</p>\n<p>At least if I planned on the code being used with those compilers and options.</p>\n<hr>\n<p><sup><sup>1) </sup>[conv.lval], \u00a74.1/1 in both C++11 and C++14.</sup></p>\n</hr></hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2015-05-05T14:55:56.760", "Id": "30048310", "Score": "9", "CreationDate": "2015-05-05T08:52:59.137", "LastActivityDate": "2015-05-05T14:55:56.760"}, "30048135": {"CommentCount": "8", "AcceptedAnswerId": "30050906", "PostTypeId": "1", "LastEditorUserId": "43681", "CreationDate": "2015-05-05T08:45:38.493", "LastActivityDate": "2015-05-05T14:55:56.760", "LastEditDate": "2015-05-05T12:31:20.347", "ViewCount": "1487", "FavoriteCount": "1", "Title": "Efficient way to bit-copy a signed integer to an unsigned integer", "Id": "30048135", "Score": "24", "Body": "<pre><code>/* [1] */\nint i = -1;\nunsigned u = (unsigned)i;\n\n/* [2] */\nint i = -1;\nunsigned u;\nmemcpy(&amp;u, &amp;i, sizeof i);\n\n/* [3] */\nint i = -1;\nunsigned u = *(unsigned *)&amp;i;\n</code></pre>\n<p>In order to bit-copy a signed integer to its unsigned partner, <code>[1]</code> should work on most machines, but as far as I know it is not guaranteed behaviour.</p>\n<p><code>[2]</code> should do exactly what I want, but I want to avoid the overhead of calling a library function.</p>\n<p>So how about <code>[3]</code>? Does it efficiently achieve what I intend?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "3998522", "AnswerCount": "4"}, "30048382": {"ParentId": "30048135", "PostTypeId": "2", "CommentCount": "20", "Body": "<pre><code>/* [4] */\nunion unsigned_integer\n{\n  int i;\n  unsigned u;\n};\n\nunsigned_integer ui;\nui.i = -1;\n// You now have access to ui.u\n</code></pre>\n<p><strong>Warning:</strong> As discussed in the comments, this seems to be okay in <code>C</code> and Undefined Behaviour in <code>C++</code>, since your question has both tags i'll leave this here. For more info check this SO question:</p>\n<p><a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined\">Accessing inactive union member and undefined behavior?</a></p>\n<p>I would then advise for <code>reinterpret_cast</code> in <code>C++</code>:</p>\n<pre><code>/* [5] */\nint i = -1;\nunsigned u = reinterpret_cast&lt;unsigned&amp;&gt;(i);\n</code></pre>\n", "OwnerUserId": "1147772", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:19.747", "Id": "30048382", "Score": "10", "CreationDate": "2015-05-05T08:56:14.287", "LastActivityDate": "2015-05-05T09:44:11.307"}, "bq_ids": {"n4140": {"so_30048135_30048395_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_30048135_30050906_0": {"section_id": 7230, "quality": 0.5454545454545454, "length": 6}, "so_30048135_30050906_1": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_30048135_30048395_0": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_30048135_30050906_0": {"section_id": 6974, "quality": 0.5454545454545454, "length": 6}, "so_30048135_30050906_1": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_30048135_30048395_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_30048135_30050906_1": {"section_id": 8748, "quality": 1.0, "length": 14}}}});