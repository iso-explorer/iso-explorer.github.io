post_cb({"25896482": {"CommentCount": "6", "ViewCount": "64", "PostTypeId": "1", "LastEditorUserId": "1209922", "CreationDate": "2014-09-17T17:09:35.120", "LastActivityDate": "2014-09-17T17:49:52.737", "Title": "Determining what the compiler generates for a given C-style cast", "LastEditDate": "2014-09-17T17:17:24.520", "Id": "25896482", "Score": "1", "Body": "<p>My understanding of C-style casts is that the compiler runs through all sorts of increasingly complicated/dangerous permutations of C++-style casts until it finds one that works, then silently sticks it in. I'm in the process of working through a codebase and replacing these C-style casts with true, explicit C++ casts. </p>\n<p>How can I determine which C++ casts the compiler generates for a given C-style cast?</p>\n<p>If architecture and compiler are relevant, I'm using Visual Studio 2010 on Windows 7 (though I'd prefer answers that are cognizant of Linux and GCC as well).</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1209922", "AnswerCount": "1"}, "25896661": {"ParentId": "25896482", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Since you are modifying the code anyway, you might first see if there is a way to refactor the code to not require the cast. If that proves fruitless:</p>\n<ul>\n<li>Most of the time, you should use <code>static_cast</code>. The most common use of this is turning a <code>void *</code> into a <code>T *</code>.</li>\n<li>If you are trying to drop a <code>const</code> from an object, you need <code>const_cast</code>.</li>\n<li>If the cast is truly between incompatible types (like, turning an <code>int</code> into a pointer), you will need <code>reinterpret_cast</code>.</li>\n</ul>\n<p>As described C++11 \u00a75.4/4, when the compiler encounters the cast notation, it should be attempting the conversion by following the recipe below until the first one that generates a valid result:</p>\n<blockquote>\n<p id=\"so_25896482_25896661_0\">The conversions performed by<br>\n  \u2014 a <code>const_cast</code> (5.2.11),<br>\n  \u2014 a <code>static_cast</code> (5.2.9),<br>\n  \u2014 a <code>static_cast</code> followed by a <code>const_cast</code>,<br>\n  \u2014 a <code>reinterpret_cast</code> (5.2.10), or<br>\n  \u2014 a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,<br>\n  can be performed using the cast notation of explicit type conversion.<br><br>\n  ...<sub><strong><em><code>static_cast</code> has some tweaks, see below</em></strong></sub>...<br><br>\n  If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed. If a conversion can be interpreted in more than one way as a <code>static_cast</code> followed by a <code>const_cast</code>, the conversion is ill-formed.</br></br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>The standard says that the <code>static_cast</code> that is performed on behalf of the cast notation is slightly tweaked to work even if there is non-<code>public</code> inheritance.</p>\n<blockquote>\n<p id=\"so_25896482_25896661_1\">The same semantic restrictions and behaviors apply, with the exception that in performing a <code>static_cast</code> in the following situations the conversion is valid even if the base class is inaccessible:<br>\n  \u2014 a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;<br>\n  \u2014 a pointer to member of derived class type may be explicitly converted to a pointer to member of an\n  unambiguous non-virtual base class type;<br>\n  \u2014 a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous\n  non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type\n  may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type, respectively.</br></br></br></p>\n</blockquote>\n", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2014-09-17T17:49:52.737", "Id": "25896661", "Score": "1", "CreationDate": "2014-09-17T17:19:20.330", "LastActivityDate": "2014-09-17T17:49:52.737"}, "bq_ids": {"n4140": {"so_25896482_25896661_0": {"section_id": 6126, "quality": 0.8620689655172413, "length": 50}, "so_25896482_25896661_1": {"section_id": 6126, "quality": 0.9879518072289156, "length": 82}}, "n3337": {"so_25896482_25896661_0": {"section_id": 5890, "quality": 0.8620689655172413, "length": 50}, "so_25896482_25896661_1": {"section_id": 5890, "quality": 0.9879518072289156, "length": 82}}, "n4659": {"so_25896482_25896661_0": {"section_id": 7623, "quality": 0.8620689655172413, "length": 50}, "so_25896482_25896661_1": {"section_id": 7623, "quality": 0.9879518072289156, "length": 82}}}});