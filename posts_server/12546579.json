post_cb({"12546579": {"CommentCount": "6", "ViewCount": "418", "PostTypeId": "1", "LastEditorUserId": "1691319", "CreationDate": "2012-09-22T18:32:30.750", "LastActivityDate": "2012-09-22T21:42:13.920", "Title": "How to use double checked lock to init a shared_ptr", "LastEditDate": "2012-09-22T21:42:13.920", "Id": "12546579", "Score": "0", "Body": "<p>(Assuming VC++ 2010: (1) can use /volatile:ms, (2) no std::atomic yet, (3) no thread-safe static variable initialization, (4) no std::call_once)</p>\n<p>If I have a plain C pointer, I can impl the following double checked lock pattern to avoid the cost of lock every time:</p>\n<pre><code>static volatile void * ptr = nullptr;\n\n//...\nif ( ptr == nullptr)\n{\n   // Acquire Lock\n   if (ptr == nullptr)\n   {\n      // some code\n      // ptr = ...; // init ptr\n   }\n   // Release Lock\n}\n// ....\n</code></pre>\n<p>Since VC++ 2005, the volatile makes sure the above code is correct. Assume I'm OK with the code being not portable.</p>\n<p>Now assume I need to replace the plain pointer with a std::shared_ptr or boost::shared_ptr, how would I do the same thing? How to make that shared_ptr volatile? Do I need another volatile flag? </p>\n", "Tags": "<c++><c++11><locking><shared-ptr><lazy-initialization>", "OwnerUserId": "1691319", "AnswerCount": "3"}, "12547347": {"ParentId": "12546579", "CommentCount": "3", "CreationDate": "2012-09-22T20:11:49.133", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "12547347", "Score": "1", "Body": "<p>In C++ 2011 it isn't even necesary to use <strong>any</strong> explict synchronization. According to 6.7 [stmt.dcl] paragraph 4 the initialization is synchronized by the system:</p>\n<blockquote>\n<p id=\"so_12546579_12547347_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>This seems to imply that the <code>std::shared_ptr&lt;T&gt;</code> can be initialzed like this:</p>\n<pre><code>{\n    static std::shared_ptr&lt;MyType&gt; ptr(new MyType(/*...*/));\n    // ...\n}\n</code></pre>\n", "LastActivityDate": "2012-09-22T20:11:49.133"}, "bq_ids": {"n4140": {"so_12546579_12547347_0": {"section_id": 3919, "quality": 1.0, "length": 13}}, "n3337": {"so_12546579_12547347_0": {"section_id": 3779, "quality": 1.0, "length": 13}}, "n4659": {"so_12546579_12547347_0": {"section_id": 4805, "quality": 1.0, "length": 13}}}, "12546724": {"ParentId": "12546579", "CommentCount": "1", "CreationDate": "2012-09-22T18:48:35.733", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "12546724", "Score": "4", "Body": "<p>With C++11, there are atomic accessor functions for <code>shared_ptr</code>. To write a double-checked lock that uses <code>shared_ptr</code>, use those accessors:</p>\n<pre><code>static std::shared_ptr&lt;MyType&gt; ptr;\nif (std::atomic_load(ptr) == 0) {\n    // lock the lock\n    if (std::atomic_load(ptr) == 0) {\n        std::shared_ptr&lt;MyType&gt; local_ptr(new MyType);\n        std::atomic_store(ptr, local_ptr);\n    }\n    // unlock the lock\n}\nreturn ptr;\n</code></pre>\n", "LastActivityDate": "2012-09-22T18:48:35.733"}, "12546655": {"ParentId": "12546579", "CommentCount": "2", "CreationDate": "2012-09-22T18:41:08.650", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "12546655", "Score": "3", "Body": "<blockquote>\n<p id=\"so_12546579_12546655_0\">Since VC++ 2005, the volatile makes sure the above code is correct.</p>\n</blockquote>\n<p>No, it does not. <code>volatile</code> has nothing to do with threading or atomicity.</p>\n<p>Your current code is incorrect and is not guaranteed by any C++ standard to produce reasonable behavior.</p>\n<p>Since your pretend-locking code doesn't work in general, it's certainly not going to work on <code>shared_ptr</code> or other smart pointers. If you want cheaper locking, look into lock-free coding patterns.</p>\n", "LastActivityDate": "2012-09-22T18:41:08.650"}});