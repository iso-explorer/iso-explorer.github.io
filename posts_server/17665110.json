post_cb({"17665110": {"ViewCount": "178", "Body": "<p>In the following example, which conversion function should be called? Why should that one be chosen over the other?</p>\n<pre><code>struct A\n{\n  operator int();\n  operator int*();\n};\n\nA x;\nint i = x + 1;\n</code></pre>\n<p>The compiler chooses <code>operator int()</code>.. but why?</p>\n<p>Here are some relevant quotes from C++03:</p>\n<p>From [expr.add]</p>\n<blockquote>\n<p id=\"so_17665110_17665110_0\">For addition, either both operands shall have arithmetic or enumeration type, or one operand shall be a pointer to a completely defined object type and the other shall have integral or enumeration type.</p>\n</blockquote>\n<p>From [conv] </p>\n<blockquote>\n<p id=\"so_17665110_17665110_1\">expressions with a given type will be implicitly converted to other types in several contexts:</p>\n<ul>\n<li>When used as operands of operators. The operator\u2019s requirements for its operands dictate the destination type</li>\n</ul>\n</blockquote>\n", "AcceptedAnswerId": "17665272", "Title": "If the first operand of an additive expression is convertible to both pointer and integer, which conversion is chosen?", "CreationDate": "2013-07-15T22:38:55.343", "Id": "17665110", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-07-15T23:05:59.003", "Score": "5", "OwnerUserId": "1690864", "Tags": "<c++><type-conversion><overloading><language-lawyer><implicit-conversion>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17665110_17665110_1": {"length": 10, "quality": 1.0, "section_id": 1}, "so_17665110_17665110_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 6138}, "so_17665110_17665272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 679}}, "n3337": {"so_17665110_17665110_1": {"length": 10, "quality": 1.0, "section_id": 1}, "so_17665110_17665110_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 5902}, "so_17665110_17665272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 669}}, "n4659": {"so_17665110_17665110_1": {"length": 9, "quality": 0.9, "section_id": 1}, "so_17665110_17665110_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 7635}, "so_17665110_17665272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 708}}}, "17665272": {"Id": "17665272", "PostTypeId": "2", "Body": "<p>The reason for this behavior is that the built-in operator which accepts a pointer as its left hand operand accepts an object of type <code>std::ptrdiff_t</code> as its right hand operand. This is specified in \u00a7 13.6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17665110_17665272_0\">For every cv-qualified or cv-unqualified object type T there exist candidate operator functions of the form</p>\n<pre><code>T * operator+(T *, std::ptrdiff_t);\n</code></pre>\n<p id=\"so_17665110_17665272_1\">[...]</p>\n</blockquote>\n<p>Since <code>1</code> has type <code>int</code>, the compiler considers the built-in <code>operator +</code> that takes two <code>int</code>s as a better choice, because it onlys require a (user-defined) conversion for the first argument.</p>\n<p>If you provided an argument of type <code>std::ptrdiff_t</code> as the right hand operand of <code>operator +</code>, you would see the expected ambiguity:</p>\n<pre><code>int i = x + static_cast&lt;std::ptrdiff_t&gt;(1); // AMBIGUOUS!\n</code></pre>\n<p>Here is a <a href=\"http://coliru.stacked-crooked.com/view?id=92ec60d6c6eb63ba29c46d0429b7e0a5-4610ec02f09472fe886fb7fc4894b294\" rel=\"noreferrer\"><strong>live example</strong></a>.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-07-15T23:05:59.003", "Score": "9", "CreationDate": "2013-07-15T22:54:38.733", "ParentId": "17665110", "CommentCount": "4", "OwnerUserId": "1932150", "LastEditDate": "2013-07-15T23:05:59.003"}});