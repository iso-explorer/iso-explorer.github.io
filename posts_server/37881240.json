post_cb({"37881359": {"ParentId": "37881240", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-17T12:16:26.880", "Score": "17", "LastEditorUserId": "60281", "LastEditDate": "2016-06-17T12:21:35.767", "Id": "37881359", "OwnerUserId": "60281", "Body": "<p>Types can be the result of templates; a template might state <code>const T</code>, and be instantiated with <code>T</code> as <code>void</code>.</p>\n<p>The linked answer is misled, or rather, limited in view in that it regards the special case of a non-template type, and even then <code>const void</code> might be <em>meaningless</em>, but it is <em>valid code</em>.</p>\n", "LastActivityDate": "2016-06-17T12:21:35.767"}, "37881363": {"ParentId": "37881240", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-06-17T12:16:34.763", "Score": "79", "LastEditorUserId": "440119", "LastEditDate": "2016-06-17T12:21:57.057", "Id": "37881363", "OwnerUserId": "440119", "Body": "<p><code>const void</code> is a type which you can form a pointer to. It's similar to a normal void pointer, but conversions work differently. For example, a <code>const int*</code> cannot be implicitly converted to a <code>void*</code>, but it can be implicitly converted to a <code>const void*</code>. Likewise, if you have a <code>const void*</code> you cannot <code>static_cast</code> it to an <code>int*</code>, but you can <code>static_cast</code> it to a <code>const int*</code>.</p>\n<pre><code>const int i = 10;\nvoid* vp = &amp;i;                           // error\nconst void* cvp = &amp;i;                    // ok\nauto ip = static_cast&lt;int*&gt;(cvp);        // error\nauto cip = static_cast&lt;const int*&gt;(cvp); // ok\n</code></pre>\n", "LastActivityDate": "2016-06-17T12:21:57.057"}, "37881240": {"CommentCount": "5", "AcceptedAnswerId": "37881363", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-17T12:09:42.433", "LastActivityDate": "2016-06-17T12:57:30.930", "LastEditDate": "2017-05-23T11:54:43.123", "ViewCount": "6456", "FavoriteCount": "7", "Title": "What is const void?", "Id": "37881240", "Score": "76", "Body": "<p>The description of <a href=\"http://en.cppreference.com/w/cpp/types/is_void\" rel=\"nofollow noreferrer\"><code>std::is_void</code></a> states that:</p>\n<blockquote>\n<p id=\"so_37881240_37881240_0\">Provides the member constant value  that is equal to true, if T is the <strong>type void, const void, volatile\n  void,</strong> or const volatile void.</p>\n</blockquote>\n<p>Then what could be <code>const void</code>, or a <code>volatile void</code> ? </p>\n<p><a href=\"https://stackoverflow.com/a/28707034/264325\">This answer</a> states that <code>const void</code> return type would be invalid (however compiles on VC++ 2015)</p>\n<pre><code>const void foo() { }\n</code></pre>\n<p>If by standard, <code>const void</code> is invalid (VC being wrong) - then what is <code>const void</code>?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "264325", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_37881240_37881475_0": {"section_id": 5939, "quality": 1.0, "length": 14}, "so_37881240_37881240_0": {"section_id": 3346, "quality": 0.6, "length": 9}}, "n3337": {"so_37881240_37881240_0": {"section_id": 3234, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_37881240_37881475_0": {"section_id": 7423, "quality": 1.0, "length": 14}, "so_37881240_37881240_0": {"section_id": 4113, "quality": 0.6, "length": 9}}}, "37881475": {"ParentId": "37881240", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-06-17T12:22:08.557", "Score": "20", "LastEditorUserId": "3647361", "LastEditDate": "2016-06-17T12:30:01.360", "Id": "37881475", "OwnerUserId": "3647361", "Body": "<p>As <code>void</code>, <code>const void</code> is a void type. However, if <code>const void</code> is a <em>return</em> type, the <code>const</code> is meaningless (albeit legal!), because <a href=\"http://eel.is/c++draft/expr#6\">[expr]/6</a>:</p>\n<blockquote>\n<p id=\"so_37881240_37881475_0\">If a prvalue initially has the type \u201c<em>cv</em> <code>T</code>\u201d, where <code>T</code> is a cv-unqualified non-class, non-array type, the type of\n  the expression is adjusted to <code>T</code> prior to any further analysis.</p>\n</blockquote>\n<p>However, it is a valid type itself and occurs in e.g. <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\">C-standard library functions</a>, where it's used to ensure const-correctness of argument pointers: <code>int const*</code> cannot be converted to <code>void*</code>, but <code>void const*</code>. </p>\n", "LastActivityDate": "2016-06-17T12:30:01.360"}});