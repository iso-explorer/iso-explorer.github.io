post_cb({"bq_ids": {"n4140": {"so_20253473_20276614_0": {"length": 10, "quality": 1.0, "section_id": 92}}, "n3337": {"so_20253473_20276614_0": {"length": 10, "quality": 1.0, "section_id": 87}}, "n4659": {"so_20253473_20276614_0": {"length": 10, "quality": 1.0, "section_id": 95}}}, "20253473": {"ViewCount": "1611", "Body": "<p>First some code, then some context, then the question:</p>\n<pre><code>template &lt;typename T&gt; using id = T;\n\ntemplate &lt;template &lt;typename...&gt; class F, typename... T&gt;\nusing apply1 = F &lt;T...&gt;;\n\ntemplate &lt;template &lt;typename...&gt; class F&gt;\nstruct apply2\n{\n    template &lt;typename... T&gt;\n    using map = F &lt;T...&gt;;\n};\n\n// ...\n\ncout &lt;&lt; apply1 &lt;id, int&gt;() &lt;&lt; endl;\ncout &lt;&lt; apply2 &lt;id&gt;::map &lt;int&gt;() &lt;&lt; endl;\n</code></pre>\n<p>Both clang 3.3 and gcc 4.8.1 compile this without error, applying the identity metafunction to <code>int</code>, so both expressions evaluate to a default <code>int</code> (zero).</p>\n<p>The fact that <code>id</code> is a <code>template &lt;typename&gt;</code> while <code>apply1</code>, <code>apply2</code> expect a <code>template &lt;typename...&gt;</code> did concern me in the first place. However, it is quite convenient that this example works because otherwise metafunctions like <code>apply1</code>, <code>apply2</code> would have to be so much more involved.</p>\n<p>On the other hand, such template aliases cause serious problems in real-world code that I cannot reproduce here: frequent internal compiler errors for gcc, and less frequent unexpected behavior for clang (only in more advanced SFINAE tests).</p>\n<p>After months of trial and error, I now install and try the code on the (experimental) gcc 4.9.0, and here comes the error:</p>\n<pre><code>test.cpp: In instantiation of \u2018struct apply2&lt;id&gt;\u2019:\ntest.cpp:17:22: error: pack expansion argument for non-pack parameter \u2018T\u2019 of alias template \u2018template&lt;class T&gt; using id = T\u2019\n  using map = F &lt;T...&gt;; \n                      ^\n</code></pre>\n<p>Ok, so it seems this code was not valid all this time, but gcc crashed in various ways instead of reporting the error. Interestingly, while <code>apply1</code>, <code>apply2</code> appear to be equivalent, the error is only reported for <code>apply2</code> (which is much more useful in practice). As for clang, I really cannot say.</p>\n<p>In practice, it seems I have no other way than to go along with gcc 4.9.0 and correct the code, even though it will become much more complex.</p>\n<p>In theory, I would like to know what the standard says: is this code valid? If not, is the use of <code>apply1</code> invalid as well? or only <code>apply2</code>?</p>\n<p><strong>EDIT</strong></p>\n<p>Just to clarify that all problems I've had so far refer to template aliases, not template structs. For instance, consider the following modification:</p>\n<pre><code>template &lt;typename T&gt; struct id1 { using type = T; };\n\n// ...\n\ncout &lt;&lt; typename apply1 &lt;id1, int&gt;::type() &lt;&lt; endl;\ncout &lt;&lt; typename apply2 &lt;id1&gt;::map &lt;int&gt;::type() &lt;&lt; endl;\n</code></pre>\n<p>This compiles fine and prints <code>0</code> in both cases, on clang 3.3, gcc 4.8.1, gcc 4.9.0.</p>\n<p>In most cases, my workarounds have been introducing an intermediate template struct before the alias. However, I am now trying to use metafunctions to parametrize generic SFINAE tests and in this case I have to use aliases directly, because structs should not be instantiated. Just to get an idea, a piece of the actual code is <a href=\"https://github.com/iavr/ivl2/blob/master/include/ivl/details/core/type/traits/sfinae.hpp\">here</a>.</p>\n", "Title": "Variadic template aliases as template arguments", "CreationDate": "2013-11-27T21:32:02.047", "LastActivityDate": "2013-11-29T00:24:18.677", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-11-27T23:52:08.780", "LastEditorUserId": "2644390", "Id": "20253473", "Score": "16", "OwnerUserId": "2644390", "Tags": "<c++><c++11><variadic-templates><template-meta-programming><template-aliases>", "AnswerCount": "1"}, "20276614": {"Id": "20276614", "PostTypeId": "2", "Body": "<p>ISO C++11 14.3.3/1:</p>\n<blockquote>\n<p id=\"so_20253473_20276614_0\">A template-argument for a <strong>template template-parameter</strong> shall be the name of a class template or an <strong>alias template</strong>, expressed as id-expression.</p>\n</blockquote>\n<p>Plus I don't see any special exceptions for variadic template template parameters.</p>\n<blockquote>\n<p id=\"so_20253473_20276614_1\">On the other hand, such template aliases cause serious problems in real-world code that I cannot reproduce here: frequent internal compiler errors for gcc, and less frequent unexpected behavior for clang (only in more advanced SFINAE tests).</p>\n</blockquote>\n<p>Root of problems can be in other places. You should try to localize code which causes internal compiler error - just remove unrelated parts one by one (or use some kind of binary search, i.e. divide-and-conquer) - and check if error is still here on each stage.</p>\n<hr>\n<p>As for GCC 4.9.0 error, try to change</p>\n<pre><code>template &lt;typename... T&gt;\nusing map = F &lt;T...&gt;;\n</code></pre>\n<p>to</p>\n<pre><code>template &lt;typename... U&gt;\nusing map = F &lt;U...&gt;;\n</code></pre>\n<p>Maybe this would help to understand what GCC sees.</p>\n</hr>", "LastActivityDate": "2013-11-29T00:24:18.677", "CommentCount": "1", "CreationDate": "2013-11-29T00:24:18.677", "ParentId": "20253473", "Score": "3", "OwnerUserId": "1762344"}});