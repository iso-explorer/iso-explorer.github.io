post_cb({"26055092": {"CommentCount": "3", "ViewCount": "497", "CreationDate": "2014-09-26T08:19:09.497", "LastActivityDate": "2014-09-26T09:22:47.947", "Title": "seg fault for accessing a singleton-like static member", "AcceptedAnswerId": "26055306", "PostTypeId": "1", "Id": "26055092", "Score": "1", "Body": "<p>Here is the code, simplified...</p>\n<pre><code>//A class used in the next class, Nothing much to worry about\nclass BasicLogger{\n//...\n};\n</code></pre>\n<p>Below is my main class. It has two member you need to look at: A static member(called <code>log</code>) of its own type.\nAnd, a container (called <code>repo</code>) for holding objects of the above class. <code>repo</code>'s items are accessible using <code>operator[]</code> overload:</p>\n<pre><code>class Logger {\nprotected:\n    //  repository of profilers. each profiler is distinguished by a file name!\n    std::map&lt;const std::string, boost::shared_ptr&lt;BasicLogger&gt; &gt; repo; \npublic:\n    Logger(){} //breakpoints never reach here. why?\n    //universal singleton-like access to this class\n    static Logger log;\n    //returns a member stored in the above 'repo' \n    virtual BasicLogger &amp; operator[](const std::string &amp;key);\n};\n</code></pre>\n<p>The problem comes from this method:</p>\n<pre><code>BasicLogger &amp; Logger::operator[](const std::string &amp;key)\n{\n    std::map&lt;std::string, boost::shared_ptr&lt;BasicLogger&gt; &gt;::iterator it = repo.find(key);\n    if(it == repo.end()){\n        std::cout &lt;&lt; \"creating a new Logger for \" &lt;&lt; key &lt;&lt; std::endl;\n        boost::shared_ptr&lt;BasicLogger&gt; t(new LogEngine(key));\n        std::map&lt;const std::string, boost::shared_ptr&lt;BasicLogger&gt; &gt; repo_debug;//just for debug\n        repo_debug.insert(std::make_pair(key,t));//ok\n        repo.insert(std::make_pair(key,t));//seg fault\n        return *t;\n    }\n    return *it-&gt;second;\n}\n</code></pre>\n<p>and last piece of information: Throughout the project, items in <code>repo</code> container are accessed like below. </p>\n<pre><code>namespace{\nBasicLogger &amp; logger = Logger::log[\"path_set\"];\n}\n</code></pre>\n<p><strong>Problem:</strong></p>\n<p>The problem is that at the beginning of program, before anything, the control goes directly to <code>BasicLogger &amp; logger = Logger::log[\"path_set\"];</code></p>\n<p><strong>Q1:</strong> why exactly does the control go here first? just because <code>log</code> is static or anonymous namespaces are also attended initially?</p>\n<p>Anyways,\nso when the operator[] is executed, <code>repo</code> seems to be uninitialized. I added a local dummy variable(<code>repo_debug</code>) with the same signature as <code>repo</code>. and observed their value using gdb:</p>\n<pre><code>//local repo_debug\n    Details:{... _M_header = {... _M_parent = 0x0, _M_left = 0x7fffffffdc08, _M_right = 0x7fffffffdc08}, _M_node_count = 0}}}\n//main 'repo'\n    Details:{..._M_parent = 0x0, _M_left = 0x0, _M_right = 0x0}, _M_node_count = 0}}}\n</code></pre>\n<p><strong>Q2.</strong> why is <code>repo</code> uninitialized? Basically, why <code>Logger</code>'s  constructor is not called?</p>\n<p><strong>Q3.</strong> suggestions to take care of this problem is highly appreciated. \nThanks</p>\n", "Tags": "<c++>", "OwnerUserId": "805896", "AnswerCount": "1"}, "26055306": {"ParentId": "26055092", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Q1: Presumably the declarations are in separate compilation units. Static initialization order across compilation units is implementation defined. So, it's this way due to chance. I'd say lucky chance because the other way you would have initially thought that it works only to find that it breaks on another cpu / compiler / os later on.</p>\n<p>Q2: Because <code>logger</code> in the anonymous namespace was initialized first causing a segfault which prevents the static <code>log</code> from ever initializing.</p>\n<p>Q3. You could avoid the problem by avoiding singletons in your design. But if you want singletons, one way to avoid static initialization order fiasco is Construct On First Use Idiom:</p>\n<pre><code>Logger&amp; Logger::log() {\n   static Logger* log = new Logger();\n   return *log;\n}\n</code></pre>\n<p>The drawback is that the dynamically allocated object is never actually freed (singletons would be freed at the end of the program anyway, but might be a problem if you run without an OS)</p>\n<p>Thread safety of initialization of static locals is guaranteed by the standard in \u00a76.7/4 (c++11 draft):</p>\n<blockquote>\n<p id=\"so_26055092_26055306_0\">...Otherwise such a variable is\n  initialized the first time control passes through its declaration; such a variable is considered initialized upon\n  the completion of its initialization. If the initialization exits by throwing an exception, the initialization\n  is not complete, so it will be tried again the next time control enters the declaration. <strong>If control enters\n  the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for\n  completion of the initialization.</strong></p>\n</blockquote>\n<p>In earlier standards and in visual c++, you can avoid concurrency issues by making sure that <code>log</code> is called in at least one constructor that is invoked during static initialization (which happens before main program can spawn any threads).</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2014-09-26T09:22:47.947", "Id": "26055306", "Score": "1", "CreationDate": "2014-09-26T08:32:48.037", "LastActivityDate": "2014-09-26T09:22:47.947"}, "bq_ids": {"n4140": {"so_26055092_26055306_0": {"section_id": 3919, "quality": 1.0, "length": 45}}, "n3337": {"so_26055092_26055306_0": {"section_id": 3779, "quality": 1.0, "length": 45}}, "n4659": {"so_26055092_26055306_0": {"section_id": 4805, "quality": 0.9333333333333333, "length": 42}}}});