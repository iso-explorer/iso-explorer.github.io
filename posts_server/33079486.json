post_cb({"bq_ids": {"n4140": {"so_33079486_33079574_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 367}, "so_33079486_33079574_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 6000}, "so_33079486_33079574_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 3887}, "so_33079486_33079574_3": {"length": 4, "quality": 0.8, "section_id": 3287}, "so_33079486_33079574_4": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}}, "n3337": {"so_33079486_33079574_2": {"length": 30, "quality": 0.8333333333333334, "section_id": 5768}, "so_33079486_33079574_6": {"length": 11, "quality": 0.8461538461538461, "section_id": 355}, "so_33079486_33079574_10": {"length": 10, "quality": 1.0, "section_id": 355}, "so_33079486_33079574_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 356}, "so_33079486_33079574_3": {"length": 4, "quality": 0.8, "section_id": 3157}, "so_33079486_33079574_7": {"length": 7, "quality": 1.0, "section_id": 355}, "so_33079486_33079574_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}}, "n4659": {"so_33079486_33079574_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 379}, "so_33079486_33079574_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 4766}, "so_33079486_33079574_4": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}}}, "33079574": {"Id": "33079574", "PostTypeId": "2", "Body": "<p>Neither of these are constructor calls.</p>\n<p>The first is an <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\" rel=\"nofollow noreferrer\">explicit type conversion</a>, which creates an object of type <code>std::list&lt;int&gt;</code>.</p>\n<p>The second is a variable definition which creates an object of type <code>std::list&lt;int&gt;</code>.</p>\n<p>The default-constructor (constructor taking no arguments) is called as part of the creation in both cases.</p>\n<p>Although you might see such things talked about as \"constructor calls\", there's no syntactic construct to explicitly and singularly call a constructor in C++. </p>\n<p>The reason one needs parentheses when the other doesn't is because they are two separate language constructs with different syntax rather than two ways to call a constructor.</p>\n<hr>\n<p>Note that if you add parentheses to your second example, you actually declare a function rather than defining a variable:</p>\n<pre><code>std::list&lt;int&gt; foo; //variable definition\nstd::list&lt;int&gt; foo(); //function taking no args, returning a std::list&lt;int&gt;\n</code></pre>\n<p>This is commonly known as the <a href=\"https://stackoverflow.com/questions/1424510/most-vexing-parse-why-doesnt-a-a-work\"><em>most-vexing-parse</em></a>. C++11 introduced braced-initialization to get around this:</p>\n<pre><code>std::list&lt;int&gt; foo{}; //variable definition\n</code></pre>\n<hr>\n<h2>The Standardese, for those so inclined</h2>\n<p>(Quotes from N3337)</p>\n<p><em>\"But <code>T()</code> sure looks like a constructor call, why is it not?\"</em></p>\n<p>In that context, <code>T()</code> is known as an explicit type conversion with functional notation:</p>\n<blockquote>\n<p id=\"so_33079486_33079574_0\"><strong>5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</strong></p>\n<p id=\"so_33079486_33079574_1\">1 [...]</p>\n<p id=\"so_33079486_33079574_2\">2 <strong>The expression <code>T()</code>, where <code>T</code> is a simple-type-specifier or typename-specifier for a non-array complete object type or the (possibly cv-qualified) void type, creates a prvalue of the specified type, which is value-initialized</strong> (8.5; no initialization is done for the void() case). [Note: if <code>T</code> is a non-class type that is\n  cv-qualified, the cv-qualifiers are ignored when determining the type of the resulting prvalue (3.10). \u2014end note ]</p>\n</blockquote>\n<p>So this creates a <em>prvalue</em> which is <em>value-initialized</em>.</p>\n<blockquote>\n<p id=\"so_33079486_33079574_3\"><code>[dcl.init]/7:</code> To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<p id=\"so_33079486_33079574_4\">\u2014 <strong>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called</strong> (and the initialization is ill-formed if T has no accessible default\n  constructor);</p>\n<p id=\"so_33079486_33079574_5\">\u2014 [...]</p>\n</blockquote>\n<p>So this calls the constructor as part of the value-initialization, which is part of an explicit type conversion. As stated above, there is no way to call a constructor directly. The standard says:</p>\n<blockquote>\n<p id=\"so_33079486_33079574_6\"><code>[class.ctor]/1:</code>  Constructors do not have names. A special declarator syntax is used to declare or define the constructor.\n  The syntax uses:</p>\n<p id=\"so_33079486_33079574_7\">\u2014 an optional decl-specifier-seq in which each decl-specifier is either a function-specifier or constexpr,</p>\n<p id=\"so_33079486_33079574_8\">\u2014 the constructor\u2019s class name, and</p>\n<p id=\"so_33079486_33079574_9\">\u2014 a parameter list</p>\n<p id=\"so_33079486_33079574_10\">in that order. In such a declaration, optional parentheses around the constructor class name are ignored.</p>\n</blockquote>\n<p>So constructors don't have names and we declare/define them with a syntax exception which the language defines.</p>\n<p><em>\"This seems like an academic distinction, does this matter in practice?\"</em></p>\n<p>Maybe, maybe not. My opinion is that interpreting syntax like the above as pure constructor calls paints an incorrect picture of what a constructor is. A constructor initializes an object; it doesn't allocate that object's memory, return the initialized object, bind a symbol to that object or anything else which is done by variable definitions and type conversions. Furthermore, it can create confusion like that of the OP, who expected uniform syntax because he thought those two constructs are both constructor calls.</p>\n<p>Why use inexact synecdoche when we have formal terms which avoid confusion?</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-28T08:48:11.543", "Score": "21", "CreationDate": "2015-10-12T11:07:14.273", "ParentId": "33079486", "CommentCount": "21", "OwnerUserId": "496161", "LastEditDate": "2017-05-23T11:59:22.303"}, "33079704": {"Id": "33079704", "PostTypeId": "2", "Body": "<p>Both statements call default constructor.</p>\n<pre><code>return std::list&lt;int&gt;();\n</code></pre>\n<p>This is same as:</p>\n<pre><code>std::list&lt;int&gt; value;\nreturn value;\n</code></pre>\n<p>Here an object is created (using default constructor) and object is returned.</p>\n<pre><code>std::list&lt;int&gt; foo;\n</code></pre>\n<p>Here object <code>foo</code> is created using the default constructor.</p>\n<p>Here are other way to do the same in <code>C++11</code>:</p>\n<pre><code>std::list&lt;int&gt; foo;\nstd::list&lt;int&gt; foo1{}; // C++11\n</code></pre>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-10-12T11:20:55.027", "Score": "8", "CreationDate": "2015-10-12T11:13:19.337", "ParentId": "33079486", "CommentCount": "0", "OwnerUserId": "964080", "LastEditDate": "2015-10-12T11:20:55.027"}, "33079486": {"ViewCount": "2046", "Body": "<p>I'm a C++ beginner and would like to understand why</p>\n<pre><code>return std::list&lt;int&gt;();\n</code></pre>\n<p>needs parentheses, but</p>\n<pre><code>std::list&lt;int&gt; foo;\n</code></pre>\n<p>doesn't need parentheses. What's the difference between these constructor calls?</p>\n", "AcceptedAnswerId": "33079574", "Title": "Difference between constructor calls with and without ( )", "CreationDate": "2015-10-12T11:02:37.753", "Id": "33079486", "CommentCount": "22", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-10-12T11:12:40.360", "LastEditorUserId": "3425536", "LastActivityDate": "2015-11-28T08:48:11.543", "Score": "20", "OwnerUserId": "3561614", "Tags": "<c++><constructor>", "AnswerCount": "3"}, "33079687": {"Id": "33079687", "PostTypeId": "2", "Body": "<p>look at it this way: <br>\n1) you need to create an object<br/>\n2) you need to return it.</br></p>\n<p>let's say the compiler looks at the expression <code>return Foo;</code> , the compiler thinks \"hey! he wants me to return a type! a type is not a thing that I can return! I need a true variable here!\" </p>\n<p>so you can write something like </p>\n<pre><code>Foo temp;\nreturn temp;\n</code></pre>\n<p>or make it shorter - call the default constructor of <code>Foo</code> , then return the <em>Anonymous</em> object I just created. you treat the constructor as a function that produces an object.</p>\n<p>does the code <code>return createDefaultFoo();</code> looks much more reasonable? well, this is what <code>Foo()</code> does, it creates and returns anonymous <code>Foo</code> obejct</p>\n<p>in this line :</p>\n<pre><code>std::list&lt;int&gt; foo;\n</code></pre>\n<p>the compiler <em>can tell</em> you want an object named <code>foo</code> from the type <code>std::list&lt;int&gt;</code>. so the <code>()</code> are redundand. as answered here, adding the <code>()</code> will make the compiler think you declare a function.</p>\n", "LastActivityDate": "2015-10-12T11:12:33.620", "CommentCount": "1", "CreationDate": "2015-10-12T11:12:33.620", "ParentId": "33079486", "Score": "10", "OwnerUserId": "3613500"}});