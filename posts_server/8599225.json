post_cb({"8599541": {"Id": "8599541", "PostTypeId": "2", "Body": "<p>(I think I might delete my other answer.)</p>\n<p>Everything about that behaviour is undefined. If you want better defined behaviour, you should look into <code>shared_ptr</code>, or implement something similar yourself. The following is defined behaviour, regardless of the virtual-ness of anything:</p>\n<pre><code>    shared_ptr&lt;B&gt; p(new D);\n    p.reset(); // To release the object (calling delete), as it's the last pointer.\n</code></pre>\n<p>The main trick of shared_ptr is the templated constructor.</p>\n", "LastActivityDate": "2011-12-22T04:49:08.510", "CommentCount": "0", "CreationDate": "2011-12-22T04:49:08.510", "ParentId": "8599225", "Score": "1", "OwnerUserId": "146041"}, "bq_ids": {"n4140": {"so_8599225_8599332_2": {"length": 36, "quality": 0.9230769230769231, "section_id": 6107}, "so_8599225_8599332_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 6105}, "so_8599225_8599332_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 5768}}, "n3337": {"so_8599225_8599332_2": {"length": 36, "quality": 0.9230769230769231, "section_id": 5873}, "so_8599225_8599332_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 5871}, "so_8599225_8599332_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 5541}}, "n4659": {"so_8599225_8599332_2": {"length": 36, "quality": 0.9230769230769231, "section_id": 7604}, "so_8599225_8599332_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 7602}, "so_8599225_8599332_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 7225}}}, "8599258": {"Id": "8599258", "PostTypeId": "2", "Body": "<ol>\n<li>Undefined Behavior</li>\n<li>(<em>One first note, these deconstructors are generally not as empty as you would think. You still have to deconstruct all of your members</em>) Even if the deconstructor is truly empty(POD?), then it still depends on your compiler. It is undefined by the standard. For all the standard cares your computer could blow up on the delete. </li>\n<li>Undefined Behavior</li>\n</ol>\n<p>There really is no reason for a non-virtual public destructor in a class that is meant to be inherited from. Look at <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"noreferrer\">this article</a>, Guideline #4.</p>\n<p>Use either a protected non-virtual destructor and shared_ptrs(they have static linking), or a public virtual destructor.</p>\n", "LastEditorUserId": "406009", "LastActivityDate": "2011-12-22T04:06:52.137", "Score": "7", "CreationDate": "2011-12-22T03:53:35.977", "ParentId": "8599225", "CommentCount": "4", "OwnerUserId": "406009", "LastEditDate": "2011-12-22T04:06:52.137"}, "8599225": {"ViewCount": "2738", "Body": "<p>This question is different than '<em>When/why should I use a <code>virtual</code> destructor?</em>'.</p>\n<pre><code>struct B {\n  virtual void foo ();\n  ~B() {}  // &lt;--- not virtual\n};\nstruct D : B {\n  virtual void foo ();\n  ~D() {}\n};\nB *p = new D;\ndelete p;  // D::~D() is not called\n</code></pre>\n<p><strong>Questions</strong>:</p>\n<ol>\n<li>Can this be classified as an undefined behavior (we are aware that <code>~D()</code> is not going to be called <em>for sure</em>)?</li>\n<li>What if <code>~D()</code> is empty. Will it affect the code in any way?</li>\n<li>Upon using <code>new[]</code>/<code>delete[]</code> with <code>B* p;</code>, the <code>~D()</code> will certainly not\nget called, irrespective of <code>virtual</code>ness of the destructor. Is it\nan undefined behavior or well defined behavior?</li>\n</ol>\n", "AcceptedAnswerId": "8599332", "Title": "Virtual destructor and undefined behavior", "CreationDate": "2011-12-22T03:46:12.570", "Id": "8599225", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-07-01T14:05:05.620", "LastEditorUserId": "569101", "LastActivityDate": "2013-07-01T14:05:05.620", "Score": "14", "OwnerUserId": "514235", "Tags": "<c++><undefined-behavior><virtual-destructor>", "AnswerCount": "4"}, "8599320": {"Id": "8599320", "PostTypeId": "2", "Body": "<p>As reaffirmed by others this is totally undefined because the Base's destructor is not virtual, and no statements can be made by anybody. See <a href=\"https://stackoverflow.com/a/2065961/146041\">this thread</a> for a reference to the standard and further discussion.</p>\n<p>(Of course, individual compilers are entitled to make certain promises, but I haven't heard anything about that in this case.)</p>\n<p>I find it interesting though, that in this case I think that <code>malloc</code> and <code>free</code> are better defined in some cases than <code>new</code> and <code>delete</code>. Perhaps we should be using those instead :-)</p>\n<p>Given a base class and a derived class, <em>neither of which have any virtual methods</em>, the following is defined:</p>\n<pre><code>Base * ptr = (Base*) malloc(sizeof(Derived)); // No virtual methods anywhere\nfree(ptr); // well-defined\n</code></pre>\n<p>You might get a memory leak if D had complex extra members, but apart from this is is defined behaviour.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-22T04:07:53.567", "Score": "2", "CreationDate": "2011-12-22T04:07:53.567", "ParentId": "8599225", "CommentCount": "5", "OwnerUserId": "146041", "LastEditDate": "2017-05-23T11:45:55.410"}, "8599332": {"Id": "8599332", "PostTypeId": "2", "Body": "<p><strong>when/why should I use a virtual destructor?</strong><br>\nFollow Herb Sutters <strong><a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"noreferrer\">guideline</a></strong>:    </br></p>\n<blockquote>\n<p id=\"so_8599225_8599332_0\">A base class destructor should be either public and virtual, or protected and nonvirtual</p>\n</blockquote>\n<p><strong>Can this be classified as an undefined behavior (we are aware that ~D() is not going to be called for sure) ?</strong> </p>\n<p>It is Undefined Behavior as per the standard, which usually results in the Derived class destructor not being called and resulting in a memory leak, but it is irrelevant to speculate on after effetcs of an Undefined Behavior because standard doesn't gaurantee anything in this regard.</p>\n<p><strong>C++03 Standard:  5.3.5 Delete</strong> </p>\n<p><strong>5.3.5/1:</strong></p>\n<blockquote>\n<p id=\"so_8599225_8599332_1\">The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.<br>\n  delete-expression:<br>\n  ::opt delete cast-expression<br>\n  ::opt delete [ ] cast-expression      </br></br></br></p>\n</blockquote>\n<p><strong>5.3.5/3:</strong></p>\n<blockquote>\n<p id=\"so_8599225_8599332_2\"><strong>In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</strong> In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n<p><strong>What if <code>~D()</code> is empty. Will it affect the code in any way ?</strong><br>\nStill it is Undefined Behavior as per the standard, The derived class destructor being empty may just make your program work normally but that is again implementation defined aspect of an particular implementation, technically, it is still an Undefined Behavior.    </br></p>\n<p>Note that there is no gaurantee here that not making the derived class destructor virtual just does not result in call to derived class destructor and this assumption is incorrect. As per the Standard all bets are off once you are crossed over in Undefined Behavior land.</p>\n<p>Note what he standard says about Undefined Behavior.</p>\n<p><strong>The C++03 Standard:  1.3.12 undefined behavior                [defns.undefined]</strong> </p>\n<blockquote>\n<p id=\"so_8599225_8599332_3\">behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no requirements. Undefined behavior may also be expected when this International Standard omits the description of any explicit definition of behavior. [<strong>Note: permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during\n  translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.</strong> ]</p>\n</blockquote>\n<p>If only derived destructor will be not called is governed by the bold text in the above quote, which is clearly left open for each implementation.</p>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-12-22T04:33:05.147", "Score": "19", "CreationDate": "2011-12-22T04:10:49.953", "ParentId": "8599225", "CommentCount": "7", "OwnerUserId": "452307", "LastEditDate": "2011-12-22T04:33:05.147"}});