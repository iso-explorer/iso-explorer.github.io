post_cb({"27183415": {"ParentId": "27183046", "CommentCount": "0", "Body": "<p>In the section 13.3.1.2 of the C++ Standard concerning operator overload resolution one finds the following rule:</p>\n<blockquote>\n<p id=\"so_27183046_27183415_0\">If the operator is the <code>operator ,</code>, the unary <code>operator &amp;</code>, or the <code>operator -&gt;</code>, and there are no viable functions, then the operator is assumed to be the built-in operator and interpreted according to Clause 5.</p>\n</blockquote>\n<p>If all types were provided with a member <code>operator&amp;</code> by default, the viable set could never be empty.  Since there's a rule for what to do when the viable set is empty, you can therefore be sure that types initially don't have a member <code>operator&amp;</code>.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "27183415", "Score": "1", "CreationDate": "2014-11-28T06:52:54.860", "LastActivityDate": "2014-11-28T06:52:54.860"}, "27183331": {"ParentId": "27183046", "CommentCount": "3", "Body": "<p>You are starting from the wrong premise. The <em>special member functions</em> are (\u00a712 [special]/p1)</p>\n<ul>\n<li>the default constructor - implicitly declared if there is no user-declared constructor</li>\n<li>the copy constructor and copy assignment operator - implicitly declared if not user-declared</li>\n<li>the move constructor and move assignment operator - implicitly declared only if no copy/move ctor/assignment operator or destructor is user-declared</li>\n<li>the destructor - implicitly declared if not user-declared</li>\n</ul>\n<p>The unary <code>operator &amp;</code> is not a special member function, and there is no such thing as a compiler generated <code>operator &amp;()</code> function. If you write</p>\n<pre><code>struct B {} b;\nB *pb = &amp;b;\n</code></pre>\n<p>then what is used is the built-in <code>&amp;</code> operator. No function call or overhead involved. It behaves just like if you took the address of a <code>int</code> variable.</p>\n<p>There are programmers who manually overload unary <code>operator &amp;</code>. This is usually a spectacularly bad idea.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "27183331", "Score": "3", "CreationDate": "2014-11-28T06:45:45.903", "LastActivityDate": "2014-11-28T06:45:45.903"}, "bq_ids": {"n4140": {"so_27183046_27183415_0": {"section_id": 590, "quality": 1.0, "length": 16}}, "n3337": {"so_27183046_27183415_0": {"section_id": 580, "quality": 1.0, "length": 16}}, "n4659": {"so_27183046_27183415_0": {"section_id": 613, "quality": 1.0, "length": 16}}}, "27183046": {"CommentCount": "4", "ViewCount": "279", "PostTypeId": "1", "LastEditorUserId": "542190", "CreationDate": "2014-11-28T06:23:38.800", "LastActivityDate": "2014-11-28T06:56:53.330", "Title": "Why does the address operator come as a default member of C++ class and what is it?", "FavoriteCount": "1", "LastEditDate": "2014-11-28T06:56:53.330", "Id": "27183046", "Score": "-1", "Body": "<p>There are 5 default members in C++ classes. Default constructor, destructor, copy constructor, assignment operator and address operator.</p>\n<ol>\n<li><p>What is an address operator? Is it <code>className* operator &amp;() {}</code>?</p></li>\n<li><p>If so, why does the compiler generate this address operator by default (as we already have an address operator in C and we can get the address of an object without this extra overhead)?\nIs there any special purpose?</p></li>\n</ol>\n", "Tags": "<c++><address-operator>", "OwnerUserId": "1716427", "AnswerCount": "2"}});