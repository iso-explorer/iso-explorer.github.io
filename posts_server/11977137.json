post_cb({"11977137": {"CommentCount": "9", "AcceptedAnswerId": "11977247", "PostTypeId": "1", "ClosedDate": "2012-08-15T21:23:34.287", "LastEditorUserId": "-1", "CreationDate": "2012-08-15T20:55:19.100", "LastActivityDate": "2012-08-15T21:25:29.340", "LastEditDate": "2017-05-23T12:34:50.693", "ViewCount": "5703", "FavoriteCount": "2", "Title": "Why is calling a static member function with . or -> syntax legal?", "Id": "11977137", "Score": "16", "Body": "<blockquote>\n<p id=\"so_11977137_11977137_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/325555/c-static-member-method-call-on-class-instance\">C++ Static member method call on class instance</a> </br></p>\n</blockquote>\n<p>Today I discovered that something I had long (and I mean <em>long</em>\u2014like, for twenty years), thought illegal in C++ is actually legal. Namely, calling a static member function as if it belonged to an individual object. For example:</p>\n<pre><code>struct Foo\n{\n    static void bar() { cout &lt;&lt; \"Whatever.\"; }\n};\n\nvoid caller()\n{\n    Foo foo;\n    foo.bar();    // Legal -- what?\n}\n</code></pre>\n<p>I normally see static member functions being called strictly with \"scope resolution syntax,\" thus:</p>\n<pre><code>Foo::bar();\n</code></pre>\n<p>This makes sense, because a static member function is not associated with any particular instance of the class, and therefore we wouldn't expect a particular instance to be syntactically \"attached\" to the function call.</p>\n<p>Yet I discovered today that GCC 4.2, GCC 4.7.1, and Clang 3.1 (as a random sampling of compilers) accept the former syntax, as well as:</p>\n<pre><code>Foo* foo = new Foo;\nfoo-&gt;bar();\n</code></pre>\n<p>In my particular case, the legality of this expression led to a runtime error, which convinced me that the peculiarity of this syntax is of more than academic interest\u2014it has practical consequences.</p>\n<p>Why does C++ allow static member functions to be called as if they were direct members of individual objects\u2014that is, by using the . or -&gt; syntax attached to an object instance?</p>\n", "Tags": "<c++><static><member-functions>", "OwnerUserId": "358475", "AnswerCount": "5"}, "11977247": {"ParentId": "11977137", "CommentCount": "7", "Body": "<p>Presumably so you can call it in places where you may not know the class type of something but the compiler does.</p>\n<p>Say I had a bunch of classes that each has a static member that returned the class name:</p>\n<pre><code>class Foo\n{\n    static const char* ClassName() { return \"Foo\"; }\n};\n\nclass Bar\n{\n    static const char* ClassName() { return \"Bar\"; }\n};\n</code></pre>\n<p>Then all over my code I could do things like:</p>\n<pre><code>Foo foo;\n\nprintf( \"This is a %s\\n\", foo.ClassName() );    \n</code></pre>\n<p>Without having to worry about knowing the class of my objects all the time. This would be very convenient when writing templates for example.</p>\n", "OwnerUserId": "1412808", "PostTypeId": "2", "Id": "11977247", "Score": "9", "CreationDate": "2012-08-15T21:03:26.490", "LastActivityDate": "2012-08-15T21:03:26.490"}, "11977459": {"ParentId": "11977137", "CommentCount": "1", "Body": "<p>From <a href=\"http://www.usenix.org/publications/compsystems/1989/sum_stroustrup.pdf\">The Evolution of C++ (pdf), section 8. Static Member Functions</a>:</p>\n<blockquote>\n<p id=\"so_11977137_11977459_0\">...It was also observed that nonportable code, such as </p>\n</blockquote>\n<pre><code>    ((x*)0)-&gt;f();\n</code></pre>\n<blockquote>\n<p id=\"so_11977137_11977459_1\">was used to simulate static member functions.</p>\n</blockquote>\n<p>So my guess is (based on the pattern of rationale for almost every other weird syntactical thing) they allowed invoking a static member function when you just had the type to provide backwards compatibility with an established but broken idiom.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "11977459", "Score": "5", "CreationDate": "2012-08-15T21:17:03.913", "LastActivityDate": "2012-08-15T21:17:03.913"}, "11977277": {"ParentId": "11977137", "CommentCount": "0", "Body": "<p>If you don't subscribe to the \"because the standard says so\" school of causality, I also suggest that static methods are old enough to come from a time when people actually worried about the extra overhead from passing the <code>this</code> argument to a function call, so making pure functions \"static\" as an optimization was probably all the rage in 1985. </p>\n", "OwnerUserId": "334485", "PostTypeId": "2", "Id": "11977277", "Score": "1", "CreationDate": "2012-08-15T21:05:01.547", "LastActivityDate": "2012-08-15T21:05:01.547"}, "11977222": {"ParentId": "11977137", "CommentCount": "10", "Body": "<p>It's like this because the standard says that's how it works. n3290 \u00a7 9.4 states:</p>\n<blockquote>\n<p id=\"so_11977137_11977222_0\">A static member s of class X may be referred to using the qualified-id\n  expression <code>X::s;</code> it is not necessary to use the class member access\n  syntax (5.2.5) to refer to a static member. A static member may be\n  referred to using the class member access syntax, in which case the\n  object expression is evaluated. [ Example: </p>\n<pre><code>struct process { \n  static void reschedule(); \n}; \n\nprocess&amp; g();\n\nvoid f() { \n  process::reschedule(); // OK: no object necessary\n  g().reschedule(); // g() is called \n} \n</code></pre>\n<p id=\"so_11977137_11977222_1\">end example ]</p>\n</blockquote>\n", "OwnerUserId": "168175", "PostTypeId": "2", "Id": "11977222", "Score": "6", "CreationDate": "2012-08-15T21:01:50.630", "LastActivityDate": "2012-08-15T21:01:50.630"}, "bq_ids": {"n4140": {"so_11977137_11977222_0": {"section_id": 5900, "quality": 0.9375, "length": 30}}, "n3337": {"so_11977137_11977222_0": {"section_id": 5672, "quality": 0.9375, "length": 30}}, "n4659": {"so_11977137_11977222_0": {"section_id": 7382, "quality": 0.9375, "length": 30}}}, "11977427": {"ParentId": "11977137", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In <em>The Design and Evolution of C++</em> at page 288, Bjarne Stroustrup mentions that in the days before static member functions, programmers used hacks like <code>((X*)0)-&gt;f()</code> to call member functions that didn't need an object. My guess is that when static member functions were added to the language, access through <code>-&gt;</code> was allowed so that programmers with code like that could change <code>f</code> to <code>static</code> without having to hunt down and change every use of it.</p>\n", "OwnerUserId": "1593860", "LastEditorUserId": "1593860", "LastEditDate": "2012-08-15T21:25:29.340", "Id": "11977427", "Score": "11", "CreationDate": "2012-08-15T21:14:36.740", "LastActivityDate": "2012-08-15T21:25:29.340"}});