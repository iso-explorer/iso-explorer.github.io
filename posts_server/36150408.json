post_cb({"36150408": {"ViewCount": "210", "Body": "<p>One of the weirder corner cases of C is that functions can be declared within other functions, e.g.</p>\n<pre><code>void foo(void)\n{\n  void bar(void); // Behaves as if this was written above void foo(void)\n  bar();\n}\n</code></pre>\n<p>This has carried through into C++, at least for most functions. Clang doesn't appear to recognise the pattern if the function in question happens to be called operator==.</p>\n<pre><code>struct foo\n{\n  int value;\n};\n\nstruct bar\n{\n  foo value;\n};\n\nbool wot(const bar &amp;x, const bar &amp;y)\n{\n  bool eq(const foo &amp;, const foo &amp;);         // Declare function eq\n  bool operator==(const foo &amp;, const foo &amp;); // Declare function operator==\n  bool func = eq(x.value, y.value);          // This line compiles fine\n  bool call = operator==(x.value, y.value);  // Also OK - thanks user657267!\n  bool op = x.value == y.value;              // This one doesn't\n  return func &amp;&amp; call &amp;&amp; op;\n}\n\nbool test()\n{\n  bar a;\n  bar b;\n  return wot(a,b);\n}\n</code></pre>\n<p>GCC and ICC compile this fine. Checking name mangling in the object suggests the operator== has been declared with the right types. Clang (I tried up to 3.8) errors:</p>\n<pre><code>error: invalid operands to binary expression\n      ('const foo' and 'const foo')\n      bool op = x.value == y.value;\n                ~~~~~~~ ^  ~~~~~~~\n</code></pre>\n<p>Unless the declaration is moved to directly above the function, in which case Clang is happy too:</p>\n<pre><code>bool operator==(const foo &amp;, const foo &amp;);\nbool wot(const bar &amp;x, const bar &amp;y)\n{\n  return x.value == y.value; // fine\n}\n</code></pre>\n<p>I can't use this workaround as the \"real world\" case that provoked this question involves layers of templates, meaning I only know the type name \"foo\" within the function declaration.</p>\n<p>I believe this is a bug in Clang - is there special handling of operatorX free functions which prohibits declaring them within a function?</p>\n", "AcceptedAnswerId": "36152300", "Title": "Cannot declare an operator within a function. Clang bug or spec?", "CreationDate": "2016-03-22T09:20:17.653", "Id": "36150408", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-22T11:02:43.973", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-22T11:19:01.533", "Score": "19", "OwnerUserId": "3726169", "Tags": "<c++><clang><language-lawyer><infix-notation><name-lookup>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_36150408_36152300_0": {"length": 18, "quality": 1.0, "section_id": 584}, "so_36150408_36152300_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 584}}, "n3337": {"so_36150408_36152300_0": {"length": 18, "quality": 1.0, "section_id": 574}, "so_36150408_36152300_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 574}}, "n4659": {"so_36150408_36152300_0": {"length": 18, "quality": 1.0, "section_id": 607}, "so_36150408_36152300_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 607}}}, "36152300": {"Id": "36152300", "PostTypeId": "2", "Body": "<p>For overloaded operators, see <a href=\"http://eel.is/c++draft/over.match.oper#3\">[over.match.oper]/(3.2)</a>:</p>\n<blockquote>\n<p id=\"so_36150408_36152300_0\">[\u2026] for a binary operator <code>@</code> with a left operand of a type whose cv-unqualified version is <code>T1</code> and a right operand of a type whose\n  cv-unqualified version is <code>T2</code>, [\u2026] <em>non-member\n  candidates</em> [\u2026] are constructed as follows:</p>\n<p id=\"so_36150408_36152300_1\"><strong>The set of non-member candidates is the result of the unqualified\n  lookup of <code>operator@</code> in the context of the expression according to the\n  usual rules for name lookup in unqualified function calls (3.4.2)\n  except that all member functions are ignored.</strong> However, if no operand\n  has a class type, [\u2026]</p>\n</blockquote>\n<p>That is, we have the exact same name lookup rules as in ordinary calls, because <code>x.value</code> is of class type (<code>foo</code>). It's a Clang bug, and it occurs with all binary operators. Filed as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=27027\">#27027</a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-22T11:07:00.933", "Score": "7", "CreationDate": "2016-03-22T10:46:21.600", "ParentId": "36150408", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2016-03-22T11:07:00.933"}, "36151961": {"Id": "36151961", "PostTypeId": "2", "Body": "<p>It is true that C allows functions to be declared inside functions: 6.7.5.3 Function declarators \u00a717 (draft n1256 for C99) says (emphasize mine)</p>\n<blockquote>\n<p id=\"so_36150408_36151961_0\">If the declaration occurs outside of any function, the identifiers have file scope and external linkage. <strong>If the\n  declaration occurs inside a function</strong>, the identifiers of the functions f and fip have block scope and either\n  internal or external linkage (depending on what file scope declarations for these identifiers are visible), and\n  the identifier of the pointer pfi has block scope and no linkage.</p>\n</blockquote>\n<p>C++ also allows them. Draft n4296 for C++ 14 says:</p>\n<blockquote>\n<p id=\"so_36150408_36151961_1\">13.2 Declaration matching [over.dcl] <br/>...<br/>\n  2 <strong>A locally declared function</strong> is not in the same scope as a function in a containing scope. [ Example:<br/>\n  void f(const char*);<br/>\n  void g() {<br/>\n  extern void f(int);<br/>\n  ...</p>\n</blockquote>\n<p>(the above quote is only here to have an explicit evidence that C++ allows function declarations inside function)</p>\n<p>I could even test that with your example this line:</p>\n<pre><code>bool op2 = operator == (x.value, y.value);\n</code></pre>\n<p>compiles fine without a single warning and gives expected results.</p>\n<p>So I would say that it is a bug in Clang</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2016-03-22T11:19:01.533", "Score": "2", "CreationDate": "2016-03-22T10:30:52.670", "ParentId": "36150408", "CommentCount": "3", "OwnerUserId": "3545273", "LastEditDate": "2016-03-22T11:19:01.533"}});