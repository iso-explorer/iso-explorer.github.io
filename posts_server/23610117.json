post_cb({"23610649": {"ParentId": "23610117", "CommentCount": "0", "CreationDate": "2014-05-12T13:40:34.397", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "23610649", "Score": "2", "Body": "<p>There are no standard conversions involving references, so that rule isn't relevant here. Instead, we need the rules for initialising references, given in C++11 8.5.3. These are quite complicated; the relevant one here is the final bullet of clause 5 (for the case where the initialiser isn't reference-compatible with the reference type):</p>\n<blockquote>\n<p id=\"so_23610117_23610649_0\">a temporary of type <code>cv1 T1</code> is created and initialized from the initializer expression\n  using the rules for a non-reference copy-initialization</p>\n</blockquote>\n<p>Here, <code>cv1 T1</code> is <code>const CL1</code>. There is no way to create a temporary <code>T1</code> from <code>int</code>, and so the initialisation fails. The compiler isn't required to search all types derived from, or convertible to, the reference type; it only considers the reference type itself. You will have to specify that you want to create a <code>CL2</code>:</p>\n<pre><code>func(CL2(5));\n</code></pre>\n<p>which, being reference-compatible with <code>const CL1</code>, can be used to initialise the reference.</p>\n<p><sub>NOTE: I'm quoting C++11 since that's been the standard for some years. The rules and section numbers were essentially the same in C++03 (and indeed C++98).</sub></p>\n", "LastActivityDate": "2014-05-12T13:40:34.397"}, "23610117": {"CommentCount": "2", "AcceptedAnswerId": "23610649", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2014-05-12T13:15:53.090", "LastActivityDate": "2014-05-12T13:40:34.397", "LastEditDate": "2014-05-12T13:27:42.223", "ViewCount": "73", "FavoriteCount": "0", "Title": "User-defined and standard conversions", "Id": "23610117", "Score": "3", "Body": "<p>Why doesn't the following code compile?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct CL1{};\n\nstruct CL2:CL1\n{\n    CL2(int){cout&lt;&lt;\"int\";}\n};\n\nvoid fnc(const CL1&amp;)\n{\n}\n\nint main()\n{\n    fnc(5);\n    return 0;\n}\n</code></pre>\n<p>Isn't two conversions working?  </p>\n<ol>\n<li>user-defined conversion <code>int</code> to <code>CL2</code></li>\n<li>standard conversion derived-to-base (<code>CL2</code> to <code>const CL1&amp;</code>)</li>\n</ol>\n<p>The standard (2003) says:</p>\n<blockquote>\n<p id=\"so_23610117_23610117_0\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by a user-defined conversion (12.3) followed by a second standard conversion sequence. </p>\n</blockquote>\n<p>Why does this not work?</p>\n", "Tags": "<c++><type-conversion>", "OwnerUserId": "3514538", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23610117_23610649_0": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}, "so_23610117_23610117_0": {"section_id": 620, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_23610117_23610649_0": {"section_id": 3191, "quality": 0.9090909090909091, "length": 10}, "so_23610117_23610117_0": {"section_id": 610, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_23610117_23610649_0": {"section_id": 4087, "quality": 0.6363636363636364, "length": 7}, "so_23610117_23610117_0": {"section_id": 646, "quality": 0.9333333333333333, "length": 14}}}});