post_cb({"8309246": {"CommentCount": "0", "ViewCount": "113", "PostTypeId": "1", "LastEditorUserId": "220918", "CreationDate": "2011-11-29T10:29:01.983", "LastActivityDate": "2011-11-29T12:46:19.950", "Title": "Casts between different class trees ins C++", "AcceptedAnswerId": "8309322", "LastEditDate": "2011-11-29T10:57:29.377", "Id": "8309246", "Score": "3", "Body": "<p>The following code seems to work with the compilers (clang, g++ on both, Linux and Mac OS) I tried, but is it guaranteed to always do what one would expect?</p>\n<pre><code>struct A {\n  virtual void foo() = 0;\n};\n\nstruct A2 {\n  virtual void foo() = 0;\n};\n\nstruct B : public A2 {\n  void foo() {\n    printf(\"test\\n\");\n  }\n};\n\nint main() {\n  B* b = new B;\n  ((A*)b)-&gt;foo();\n}\n</code></pre>\n<p>I realize this is bad practice and one should not do this, but does it work generally?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "220918", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8309246_8309322_0": {"section_id": 6046, "quality": 0.6379310344827587, "length": 37}}, "n3337": {"so_8309246_8309322_0": {"section_id": 5814, "quality": 0.896551724137931, "length": 52}}, "n4659": {"so_8309246_8309322_0": {"section_id": 7545, "quality": 0.6206896551724138, "length": 36}}}, "8309340": {"ParentId": "8309246", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>If you use C++-style cast, then you would see the problem immediately:</p>\n<pre><code>(static_cast&lt;A*&gt;(b))-&gt;foo();  //compile-time error\n(dynamic_cast&lt;A*&gt;(b))-&gt;foo(); //runtime error\n</code></pre>\n<p>Demo : <a href=\"http://ideone.com/LZjrx\" rel=\"nofollow\">http://ideone.com/LZjrx</a> (compile-time error)<br>\nDemo : <a href=\"http://ideone.com/ePIfO\" rel=\"nofollow\">http://ideone.com/ePIfO</a> (runtime error)</br></p>\n<p>Since <code>static_cast</code> gives compilation error, the story ends right then, at compilation time. When <code>dynamic_cast</code>,  then casting returns null, on which you trying to invoke <code>foo</code>, so you get runtime error.</p>\n<p>Even if you don't know which casts to use, these two casts give enough confidence to doubt the code, while the usage of <code>reinterpret_cast</code> is so rare, that I don't even consider here.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-11-29T10:42:45.307", "Id": "8309340", "Score": "3", "CreationDate": "2011-11-29T10:37:00.440", "LastActivityDate": "2011-11-29T10:42:45.307"}, "8309322": {"ParentId": "8309246", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>It's not bad practice: It <strong>doesn't</strong> <em>work</em>. It will do <em>something</em> allright. Not unlikely, crashing. It is all allowed since you are invoking <a href=\"http://en.wikipedia.org/wiki/Unspecified_behavior\" rel=\"nofollow\"><em>unspecified behaviour</em></a>. <strong>Edit</strong> You might consult your compiler technical documentation (<em>refer to ABI</em>) to find compiler-specific <em>extensions</em> that you might rely on.</p>\n<p>Try using</p>\n<pre><code>static_cast&lt;A*&gt;(b)    // invalid static cast (compile error)\ndynamic_cast&lt;A*&gt;(b)   // returns null pointer value (runtime)\n</code></pre>\n<p>What you are doing is effectively</p>\n<ul>\n<li><code>reinterpret_cast&lt;A*&gt;(b)</code></li>\n</ul>\n<p>and the results are entirely <strike>your own responsibility</strike> <em>implementation-defined</em>.</p>\n<p><strong>Edit</strong> To Nawaz: relevant standards passage: \u00a7 5.2.10, clause </p>\n<blockquote>\n<p id=\"so_8309246_8309322_0\"><strong><code>7.</code></strong> A pointer to an object can be explicitly converted to a pointer to a different object type.<sup>69</sup> When a\n  <em>prvalue</em> <code>v</code> of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to <em>cv</em> T2\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both T1 and T2 are standard-layout types (3.9) and the alignment\n  requirements of T2 are no stricter than those of T1. Converting a <em>prvalue</em> of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. <em><strong>The result of any\n  other such pointer conversion is unspecified</strong></em>.</p>\n</blockquote>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2011-11-29T12:46:19.950", "Id": "8309322", "Score": "4", "CreationDate": "2011-11-29T10:35:48.727", "LastActivityDate": "2011-11-29T12:46:19.950"}, "8309300": {"ParentId": "8309246", "CommentCount": "5", "Body": "<p>If one would expect the undefined behavior, then it is guaranteed.</p>\n", "OwnerUserId": "95382", "PostTypeId": "2", "Id": "8309300", "Score": "6", "CreationDate": "2011-11-29T10:33:32.923", "LastActivityDate": "2011-11-29T10:33:32.923"}});