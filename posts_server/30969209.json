post_cb({"30969314": {"ParentId": "30969209", "CommentCount": "0", "Body": "<p>[class.abstract]/3 says:</p>\n<blockquote>\n<p id=\"so_30969209_30969314_0\">An abstract class shall not be used as a parameter type</p>\n</blockquote>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "30969314", "Score": "3", "CreationDate": "2015-06-21T21:04:13.173", "LastActivityDate": "2015-06-21T21:04:13.173"}, "30969209": {"CommentCount": "1", "AcceptedAnswerId": "30969314", "PostTypeId": "1", "LastEditorUserId": "1392731", "CreationDate": "2015-06-21T20:50:51.070", "LastActivityDate": "2015-06-21T23:36:58.860", "LastEditDate": "2015-06-21T23:36:58.860", "ViewCount": "77", "FavoriteCount": "1", "Title": "Pointer to function taking abstract parameter", "Id": "30969209", "Score": "0", "Body": "<p>Let A be an abstract class in C++:</p>\n<pre><code>// legal\nclass A {\n  virtual void m() = 0;\n}\n</code></pre>\n<p>It is illegal, of course, to define a variable whose type is an abstract class:</p>\n<pre><code>A a; // illegal\n</code></pre>\n<p>Indeed, <code>clang</code> 3.6.0 complains thus:</p>\n<pre><code>wat.cc:5:3: error: variable type 'A' is an abstract class\nA a;\n  ^\nwat.cc:2:16: note: unimplemented pure virtual method 'm' in 'A'\n  virtual void m() = 0;\n               ^\n1 error generated.\n</code></pre>\n<p>Likewise, it is illegal to define a function with a parameter whose type is an abstract class:</p>\n<pre><code>void f(A a) {} // illegal\n</code></pre>\n<p>Indeed, <code>clang</code> complains thus:</p>\n<pre><code>wat.cc:5:10: error: parameter type 'A' is an abstract class\nvoid f(A a) {}\n         ^\nwat.cc:2:16: note: unimplemented pure virtual method 'm' in 'A'\n  virtual void m() = 0;\n               ^\n1 error generated.\n</code></pre>\n<p>On the other hand, it is legal, of course, to define a variable whose type is a pointer to values of an abstract class:</p>\n<pre><code>A * a_ptr; // legal\n</code></pre>\n<p>Even if that class never had any base classes defined, the type <code>A *</code> has at least one value, <code>nullptr</code>, so it is always possible to use such a variable in a type-correct way, even if it\u2019s probably not very useful unless <code>A</code> at some point gets some concrete subclasses:</p>\n<pre><code>a_ptr = nullptr; // legal\n</code></pre>\n<p>Presumably, this reasoning applies to <em>any</em> pointer type.</p>\n<p>Likewise, it is legal to define a function taking a parameter whose type is a pointer to values of an abstract class:</p>\n<pre><code>void f(A * a) {} // legal\n</code></pre>\n<p>Likewise, it is legal to define a function taking a parameter whose type is a pointer to functions taking a parameter whose type is a pointer to values of an abstract class:</p>\n<pre><code>void f(void (* g)(A *)) {} // legal\n</code></pre>\n<p>Both of these functions, of course, can be called legally:</p>\n<pre><code>f(nullptr); // legal\n</code></pre>\n<p>Presumably, the specific type of the function parameter is irrelevant to the correctness of the type as long as it\u2019s a pointer type.  That call to <code>f</code> should be legal in either case.  In terms of type theory, well-formed pointer types are always legal and <code>nullptr</code> always inhabits them.  By this reasoning, this definition should be presumed legal:</p>\n<pre><code>void f(void (* g)(A)) {}\n</code></pre>\n<p><code>f</code> is a function that takes a parameter whose type is a pointer to functions that take a parameter whose type is a value of the abstract class A.</p>\n<p>Indeed, the only possible value for that parameter is <code>nullptr</code>, since no actual function can take a parameter whose type is an abstract class.</p>\n<p>Is this legal per the C++ standard?</p>\n<p>Clang complains:</p>\n<pre><code>wat.cc:5:20: error: parameter type 'A' is an abstract class\nvoid f(void (* g)(A)) {}\n                   ^\nwat.cc:2:16: note: unimplemented pure virtual method 'm' in 'A'\n  virtual void m() = 0;\n               ^\n1 error generated.\n</code></pre>\n<p>GCC doesn\u2019t.</p>\n<p><strong>Update</strong>: This question was correctly answered, but the question itself is wrong in stating Clang accepts that function.  Both GCC and Clang yield similar errors with this code.  However, Clang accepts such functions <strong>if they are member functions</strong>.  This works:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n  virtual ~A() = 0;\n};\n\nstruct B {\n  void f(void (*g)(A)) {\n    std::cout &lt;&lt; \"Works!\" &lt;&lt; std::endl;\n  }\n};\n\nint main() {\n  B().f(nullptr);\n  return 0;\n}\n</code></pre>\n<p>This seems to be simply a bug in Clang, though.  According to the language in the section of the standard cited in the accepted answer, this code should be rejected.</p>\n", "Tags": "<c++><abstract-class><function-pointers>", "OwnerUserId": "1392731", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30969209_30969314_0": {"section_id": 300, "quality": 1.0, "length": 4}}, "n3337": {"so_30969209_30969314_0": {"section_id": 291, "quality": 1.0, "length": 4}}, "n4659": {"so_30969209_30969314_0": {"section_id": 307, "quality": 1.0, "length": 4}}}});