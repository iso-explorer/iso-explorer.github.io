post_cb({"37662100": {"CommentCount": "5", "AcceptedAnswerId": "37662548", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-06-06T16:08:39.503", "LastActivityDate": "2016-06-06T16:34:00.480", "LastEditDate": "2016-06-06T16:34:00.480", "ViewCount": "332", "FavoriteCount": "1", "Title": "Calling derived class through base class function pointer", "Id": "37662100", "Score": "7", "Body": "<p>Can I call a derived class through a base class function <em>pointer</em>, as shown in the example below?</p>\n<p>I understand that my example <em>works</em>, but is it guaranteed to always do so (Assuming the object actually implements the function!), or is this just an idiosyncrasy of the compiler I'm using?</p>\n<p>By this logic can't one simply derive all their classes from \"CBase\" (which in this case is empty so I guess no overhead) and ignore the type in the function pointer?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct CBase\n{ \n};\n\nstruct CDerived : CBase\n{\n    void MyFunction()\n    {\n        std::cout &lt;&lt; \"Called OK\" &lt;&lt; std::endl;\n    }\n};\n\ntypedef void (CBase::*FunctionPointer)();\n\n\nint main()\n{\n    CDerived* base = new CDerived();\n\n    FunctionPointer pointer = static_cast&lt;FunctionPointer&gt;(&amp;CDerived::MyFunction);\n    (base-&gt;*pointer)();\n\n    delete base;\n}\n</code></pre>\n<p>Example usage scenario:\nA derived class that takes one or more pointers to \"callbacks\" in the base class. Can the callback type just be defined using the derived class and thus forgo the need for a template?</p>\n", "Tags": "<c++><polymorphism><member-function-pointers>", "OwnerUserId": "3601660", "AnswerCount": "2"}, "37662548": {"ParentId": "37662100", "CommentCount": "0", "Body": "<p>Yes, it's guaranteed to work. From [expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_37662100_37662548_0\">A prvalue of type \u201cpointer to member of <code>D</code> of type <em>cv1</em> <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer\n  to member of <code>B</code> of type <em>cv2</em> <code>T</code>\u201d, where <code>B</code> is a base class (Clause 10) of <code>D</code>, if <em>cv2</em> is the same <em>cv</em>-qualification\n  as, or greater cv-qualification than, cv1.70 If no valid standard conversion from \u201cpointer to member of B of\n  type T\u201d to \u201cpointer to member of D of type T\u201d exists (4.11), the program is ill-formed. The null member\n  pointer value (4.11) is converted to the null member pointer value of the destination type. If class <code>B</code> contains\n  the original member, or is a base or derived class of the class containing the original member, the resulting\n  pointer to member points to the original member.</p>\n</blockquote>\n<p>In this case, we're converting a pointer to member of <code>CDerived</code> of type <code>void()</code> to a poitner to member of <code>CBase</code> ov type <code>void()</code>. <code>CBase</code> is a base of the class containing the original member, so the resulting pointer points to the original member. </p>\n<p>From [expr.mptr.oper]:</p>\n<blockquote>\n<p id=\"so_37662100_37662548_1\">Abbreviating pm-expression.*cast-expression as <code>E1.*E2</code>, <code>E1</code> is called the object expression. If the dynamic\n  type of <code>E1</code> does not contain the member to which <code>E2</code> refers, the behavior is undefined.</p>\n</blockquote>\n<p>In this case, <code>pointer</code> pointers to the original member. <code>base</code> has that member.  So this is fine. </p>\n<hr/>\n<p>Note that in your example, <code>base</code> is actually a <code>CDerived*</code>. It would be just as valid to write:</p>\n<pre><code>CDerived d;\nCBase* b = &amp;d;\n\n(b-&gt;*pointer)(); // ok - the dynamic type of b contains the member to which pointer refers\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "37662548", "Score": "5", "CreationDate": "2016-06-06T16:32:09.340", "LastActivityDate": "2016-06-06T16:32:09.340"}, "bq_ids": {"n4140": {"so_37662100_37662548_0": {"section_id": 6038, "quality": 0.803030303030303, "length": 53}, "so_37662100_37662548_1": {"section_id": 6131, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_37662100_37662548_0": {"section_id": 5806, "quality": 0.803030303030303, "length": 53}, "so_37662100_37662548_1": {"section_id": 5895, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_37662100_37662548_0": {"section_id": 7537, "quality": 0.8939393939393939, "length": 59}, "so_37662100_37662548_1": {"section_id": 7628, "quality": 0.8571428571428571, "length": 12}}}, "37662217": {"ParentId": "37662100", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-06-06T16:15:29.833", "Score": "0", "LastEditorUserId": "1927176", "LastEditDate": "2016-06-06T16:17:40.283", "Id": "37662217", "OwnerUserId": "1927176", "Body": "<p>You can use this method but casting pointers is not a good practice at all. Method you are using has nothing common with polymorphism. A better way to implement this is using a <code>virtual</code> function and a <code>pure</code> function.</p>\n<p>Your base class must have a pure function (pure functions also virtual) and your derived class must implement this function. So you will be able to call this function with base pointer and implementation of your derived class will be called.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n\nstruct CBase\n{\n    virtual void MyFunction() =0;    // this is a `pure` function. Pure means it's a virtual and may not have implementation. If a class has at least one pure function it means this class is an abstract class\n    virtual ~CBase()=default;       //  gotta be or we will have a memory leak during `delete`..\n};\n\nstruct CDerived : CBase\n{\n    virtual void MyFunction() override\n    {\n        std::cout &lt;&lt; \"Called OK\" &lt;&lt; std::endl;\n    }\n};\n\n//typedef void (CBase::*FunctionPointer)();\n\n\nint main()\n{\n    CBase* base = new CDerived();\n\n    base-&gt;MyFunction();\n\n    delete base;\n\n    system(\"pause\");\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2016-06-06T16:17:40.283"}});