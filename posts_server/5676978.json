post_cb({"5676978": {"ViewCount": "5260", "Body": "<p>I find in the new C++ Standard</p>\n<pre><code>2.11 Identifiers                  [lex.name]\nidentifier:\n    identifier-nondigit\n    identifier identifier-nondigit\n    identifier digit\nidentifier-nondigit:\n    nondigit\n    universal-character-name\n    other implementation-defined character\n</code></pre>\n<p>with the additional text</p>\n<blockquote>\n<p id=\"so_5676978_5676978_0\">An identifier is an arbitrarily long sequence of letters and digits. Each <strong>universal-character-name in an identifier</strong> shall designate a character whose encoding in ISO 10646 falls into one of the ranges specified\n  in E.1. [...]</p>\n</blockquote>\n<p>I can not quite comprehend what this means. From the old std I am used to that a \"universal character name\" is written <code>\\u89ab</code> for example. But using those in an identifier...? Really?</p>\n<p><strong>Is the new standard more open w.r.t to Unicode?</strong> And I do not refer to the new <em>Literal Types</em> <code>\"uHello \\u89ab thing\"u32</code>, I think I understood those. But:</p>\n<ul>\n<li>Can (portable) source code be in any unicode encoding, like UTF-8, UTF-16 or any (how-ever-defined) codepage?</li>\n<li>Can I write an identifier with <code>\\u1234</code> in it <code>myfu\\u1234ntion</code> (for whatever purpose)</li>\n<li><p>Or can i use the \"character names\" that unicode defines like in the ICU, i.e.</p>\n<pre><code>const auto x = \"German Braunb\\U{LOWERCASE LETTER A WITH DIARESIS}r.\"u32;\n</code></pre>\n<p>or even in an identifier in the source itself? That would be a treat... <em>cough</em>...</p></li>\n</ul>\n<p>I think the answer to all thise questions is <em>no</em> but I can not map this reliably to the wording in the standard... :-)</p>\n<p><strong>Edit:</strong> I found \"2.2 Phases of translation [lex.phases]\", Phase 1:</p>\n<blockquote>\n<p id=\"so_5676978_5676978_1\">Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set [...] if necessary. The set of physical source file characters accepted is implementation-defined. [...] Any source file character not in the basic\n  source character set (2.3) is replaced by the universal-character-name that designates that character. (An implementation may use any internal encoding, so long as an actual extended character encountered in the source file, and the same extended character expressed in the source file as a universal-character-name (i.e., using the \\uXXXX notation), are handled equivalently except where this replacement is reverted in a raw string literal.)</p>\n</blockquote>\n<p>By reading this I now think, that a compiler may choose to accept UTF-8, UTF-16 or any codepage it wishes (by meta information or user configuration). In Phase 1 it translates this into an ASCII form (\"basic source character set\") in which then the Unicode-characters are replaced by its <code>\\uNNNN</code> notation (or the compiler can choose to continue to work in its Unicode-representation, but than has to make sure it handles the other <code>\\uNNNN</code> the same way.</p>\n<p>What do you think?</p>\n", "AcceptedAnswerId": "17431868", "Title": "Unicode Identifiers and Source Code in C++11?", "CreationDate": "2011-04-15T12:49:16.943", "Id": "5676978", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-07-03T08:00:13.427", "LastEditorUserId": "472245", "LastActivityDate": "2016-09-25T15:41:51.453", "Score": "8", "OwnerUserId": "472245", "Tags": "<unicode><syntax><c++11>", "AnswerCount": "5"}, "32020299": {"Id": "32020299", "PostTypeId": "2", "Body": "<p>Present versions of gcc (up to version 5.2 so far) only support ASCII and in some cases EBCDIC input files.  Therefore, unicode characters in identifiers have to be represented using \\uXXXX and \\UXXXXXXXX escape sequences in ASCII encoded files.  While it may be possible to represent unicode characters as ??/uXXXX and ??/UXXXXXXX in EBCDIC encoded input files, I have not tested this.  At anyrate, a simple one-line patch to cpp allows direct reading of UTF-8 input provided a recent version of iconv is installed.  Details are in</p>\n<p><a href=\"https://www.raspberrypi.org/forums/viewtopic.php?p=802657\" rel=\"nofollow\">https://www.raspberrypi.org/forums/viewtopic.php?p=802657</a></p>\n<p>and may be summarized by the patch</p>\n<pre><code>diff -cNr gcc-5.2.0/libcpp/charset.c gcc-5.2.0-ejo/libcpp/charset.c\n*** gcc-5.2.0/libcpp/charset.c  Mon Jan  5 04:33:28 2015\n--- gcc-5.2.0-ejo/libcpp/charset.c  Wed Aug 12 14:34:23 2015\n***************\n*** 1711,1717 ****\n    struct _cpp_strbuf to;\n    unsigned char *buffer;\n\n!   input_cset = init_iconv_desc (pfile, SOURCE_CHARSET, input_charset);\n    if (input_cset.func == convert_no_conversion)\n      {\n        to.text = input;\n--- 1711,1717 ----\n    struct _cpp_strbuf to;\n    unsigned char *buffer;\n\n!   input_cset = init_iconv_desc (pfile, \"C99\", input_charset);\n    if (input_cset.func == convert_no_conversion)\n      {\n        to.text = input;\n</code></pre>\n", "LastActivityDate": "2015-08-15T00:20:17.430", "Score": "1", "CreationDate": "2015-08-15T00:20:17.430", "ParentId": "5676978", "CommentCount": "1", "OwnerUserId": "3609689"}, "6915585": {"Id": "6915585", "PostTypeId": "2", "Body": "<p>This article <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/PRE30-C.+Do+not+create+a+universal+character+name+through+concatenation\" rel=\"nofollow\">https://www.securecoding.cert.org/confluence/display/seccode/PRE30-C.+Do+not+create+a+universal+character+name+through+concatenation</a> works with the idea that <code>int \\u0401;</code> is compliant code, though it's based on C99, instead of C++0x.</p>\n", "LastActivityDate": "2011-08-02T16:49:16.020", "Score": "1", "CreationDate": "2011-08-02T16:49:16.020", "ParentId": "5676978", "CommentCount": "2", "OwnerUserId": "845092"}, "5677301": {"Id": "5677301", "PostTypeId": "2", "Body": "<p>I think the intent is to allow Unicode characters in identifiers, such as:</p>\n<pre><code>long p\u00f6jk;\nostream* \u00e5;\n</code></pre>\n", "LastActivityDate": "2011-04-15T13:12:37.970", "Score": "2", "CreationDate": "2011-04-15T13:12:37.970", "ParentId": "5676978", "CommentCount": "3", "OwnerUserId": "19100"}, "bq_ids": {"n4140": {"so_5676978_5676978_0": {"length": 20, "quality": 1.0, "section_id": 5333}, "so_5676978_5676978_1": {"length": 58, "quality": 0.9206349206349206, "section_id": 5313}}, "n3337": {"so_5676978_5676978_0": {"length": 20, "quality": 1.0, "section_id": 5130}, "so_5676978_5676978_1": {"length": 58, "quality": 0.9206349206349206, "section_id": 5110}}, "n4659": {"so_5676978_5676978_0": {"length": 20, "quality": 1.0, "section_id": 6754}, "so_5676978_5676978_1": {"length": 58, "quality": 0.9206349206349206, "section_id": 6737}}}, "39688716": {"Id": "39688716", "PostTypeId": "2", "Body": "<p>I suggest using <code>clang++</code> instead of <code>g++</code>. Clang is designed to be highly compatible with GCC (<a href=\"https://en.wikipedia.org/wiki/Clang#Performance_and_GCC_compatibility\" rel=\"nofollow\">wikipedia-source</a>), so you can most likely just substitute that command.</p>\n<p>I wanted to use Greek symbols in my source code.\nIf code readability is the goal, then it seems reasonable to use (for example) <code>\u03b1</code> over <code>alpha</code>. Especially when used in larger mathematical formulas, they can be read more easily in the source code.</p>\n<p>To achieve this, this is a minimal working example:</p>\n<pre><code>&gt; cat /tmp/test.cpp\n#include &lt;iostream&gt;\n\nint main()\n{\n    int \u03b1 = 10;\n    std::cout &lt;&lt; \"\u03b1 = \" &lt;&lt; \u03b1 &lt;&lt; std::endl;\n    return 0;\n}\n&gt; clang++ /tmp/test.cpp -o /tmp/test\n&gt; /tmp/test \n\u03b1 = 10\n</code></pre>\n", "LastActivityDate": "2016-09-25T15:41:51.453", "Score": "0", "CreationDate": "2016-09-25T15:41:51.453", "ParentId": "5676978", "CommentCount": "0", "OwnerUserId": "1009901"}, "17431868": {"Id": "17431868", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5676978_17431868_0\">Is the new standard more open w.r.t to Unicode?</p>\n</blockquote>\n<p>With respect to allowing universal character names in identifiers the answer is no; UCNs were allowed in identifiers back in C99 and C++98. However compilers did not implement that particular requirement until recently. Clang 3.3 I think introduces support for this and GCC has had an experimental feature for this for some time. Herb Sutter also mentioned during his Build 2013 talk \"The Future of C++\" that this feature would also be coming to VC++ at some point. (Although IIRC Herb refers to it as a C++11 feature; it is in fact a C++98 feature.)</p>\n<p>It's not expected that identifiers will be written using UCNs. Instead the expected behavior is to write the desired character using the source encoding. E.g., source will look like:</p>\n<pre><code>long p\u00f6rk;\n</code></pre>\n<p>not:</p>\n<pre><code>long p\\u00F6rk;\n</code></pre>\n<p>However UCNs are also useful for another purpose; Compilers are not all required to accept the same source encodings, but modern compilers all support some encoding scheme where at least the basic source characters have the same encoding (that is, modern compilers all support some ASCII compatible encoding).</p>\n<p>UCNs allow you to write source code with only the basic characters and yet still name extended characters. This is useful in, for example, writing a string literal \"\u00b0\" in source code that will be compiled both as CP1252 and as UTF-8:</p>\n<pre><code>char const *degree_sign = \"\\u00b0\";\n</code></pre>\n<p>This string literal is encoded into the appropriate execution encoding on multiple compilers, even when the source encodings differ, as long as the compilers at least share the same encoding for basic characters.</p>\n<blockquote>\n<p id=\"so_5676978_17431868_1\">Can (portable) source code be in any unicode encoding, like UTF-8, UTF-16 or any (how-ever-defined) codepage?</p>\n</blockquote>\n<p>It's not required by the standard, but most compilers will accept UTF-8 source. Clang supports <em>only</em> UTF-8 source (although it has some compatibility for non-UTF-8 data in character and string literals), gcc allows the source encoding to be specified and includes support for UTF-8, and VC++ will guess at the encoding and can be made to guess UTF-8.</p>\n<p>(Update: VS2015 now provides an <a href=\"https://msdn.microsoft.com/en-us/library/mt708821.aspx\" rel=\"nofollow\">option</a> to force the source and execution character sets to be UTF-8.)</p>\n<blockquote>\n<p id=\"so_5676978_17431868_2\">Can I write an identifier with \\u1234 in it myfu\\u1234ntion (for whatever purpose)</p>\n</blockquote>\n<p>Yes, the specification mandates this, although as I said not all compilers implement this requirement yet.</p>\n<blockquote>\n<p id=\"so_5676978_17431868_3\">Or can i use the \"character names\" that unicode defines like in the ICU, i.e.</p>\n<pre><code>const auto x = \"German Braunb\\U{LOWERCASE LETTER A WITH DIARESIS}r.\"u32;\n</code></pre>\n</blockquote>\n<p>No, you cannot use Unicode long names.</p>\n<blockquote>\n<p id=\"so_5676978_17431868_4\">or even in an identifier in the source itself? That would be a treat... cough...</p>\n</blockquote>\n<p>If the compiler supports a source code encoding that contains the extended character you want then that character written literally in the source must be treated exactly the same as the equivalent UCN. So yes, if you use a compiler that supports this requirement of the C++ spec then you may write any character in its source character set directly in the source without bothering with writing UCNs.</p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2016-09-03T19:48:36.693", "Score": "8", "CreationDate": "2013-07-02T17:19:39.873", "ParentId": "5676978", "CommentCount": "3", "LastEditDate": "2016-09-03T19:48:36.693", "OwnerUserId": "365496"}});