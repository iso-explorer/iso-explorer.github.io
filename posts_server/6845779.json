post_cb({"6846309": {"ParentId": "6845779", "CommentCount": "2", "Body": "<p>You can try following syntax it works in gcc as well:</p>\n<pre><code>obj-&gt;v.template ~vector&lt;T&gt;();\n</code></pre>\n<p><a href=\"http://www.ideone.com/44fCg\" rel=\"nofollow\">Demo</a>.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "6846309", "Score": "0", "CreationDate": "2011-07-27T14:44:01.933", "LastActivityDate": "2011-07-27T14:44:01.933"}, "6845779": {"CommentCount": "11", "CreationDate": "2011-07-27T14:05:50.780", "PostTypeId": "1", "AcceptedAnswerId": "6855977", "LastEditorUserId": "166749", "LastActivityDate": "2011-07-28T09:18:32.737", "LastEditDate": "2011-07-27T14:35:34.673", "ViewCount": "2530", "FavoriteCount": "1", "Title": "Explicit destructor in templated context", "Id": "6845779", "Score": "10", "Body": "<p>I want to explicitly destroy a <code>vector</code> in a templated context. The following works for me (GNU C++ 4.3, 4.4 and Clang++ 1.1):</p>\n<pre><code>template &lt;typename T&gt;\nvoid destroy_vector_owner(VectorOwner&lt;T&gt; *obj)\n{\n    obj-&gt;v.~vector();\n    // further cleanup by Python API functions omitted\n}\n</code></pre>\n<p>while it fails on Mac OS X v10.5's <code>g++</code> (<code>i686-apple-darwin10-gcc-4.2.1</code>) with</p>\n<pre><code>expected class-name before \u2018(\u2019 token\n</code></pre>\n<p>If I change it to</p>\n<pre><code>obj-&gt;v.~vector&lt;T&gt;();\n</code></pre>\n<p>the code fails to compile with G++, but Clang can still handle it. Which is the correct idiom? Are any of these compilers known to be broken in this regard?</p>\n<p><strong>Update</strong>: the definition of <code>VectorOwner</code> is</p>\n<pre><code>template &lt;typename T&gt;\nstruct VectorOwner {\n  PyObject_HEAD\n  std::vector&lt;T&gt; v;\n};\n</code></pre>\n<p>This is a Python object that has to keep an <code>std::vector</code> alive. I admit that the construct is slightly dangerous, but I need the compact storage, amortized O(1) <code>push_back</code> and the ability to steal another vector's contents with the <code>swap</code> member.</p>\n", "Tags": "<c++><templates><destructor>", "OwnerUserId": "166749", "AnswerCount": "3"}, "6855977": {"ParentId": "6845779", "LastEditDate": "2011-07-28T09:18:32.737", "CommentCount": "0", "CreationDate": "2011-07-28T08:22:23.407", "OwnerUserId": "76722", "LastEditorUserId": "76722", "PostTypeId": "2", "Id": "6855977", "Score": "3", "Body": "<p>My first answer was wrong actually, litb pointed my into the right direction. The right answer is\nthat both syntaxes are correct:</p>\n<hr>\n<h2>Destructor call syntax.</h2>\n<p>The syntax for an explicit destructor call is described in <code>12.4 Destructors</code>:</p>\n<pre><code>12  In an explicit destructor call, the destructor name appears\n    as a \u02dc followed by a type-name that names the destructor\u2019s \n    class type. The invocation of a destructor is subject to the\n    usual rules for member functions (9.3) [...]\n</code></pre>\n<p><code>type-name</code> can be found in <code>7.1.5.2 Simple type specifiers</code>:</p>\n<pre><code>type-name:\n    class-name\n    enum-name\n    typedef-name\n</code></pre>\n<p><code>class-name</code> is described in <code>9. Classes</code>:</p>\n<pre><code>class-name:\n    identifier\n    template-id\n</code></pre>\n<p>So a destructor call is, simplified, one of the following</p>\n<pre><code>foo.~typedef-name ()\nfoo.~identifier   ()\nfoo.~template-id  ()\n</code></pre>\n<p>We neither have a typedef-name here, nor a simple identifier, so only <code>foo.~template-id()</code> is left\nfor us.</p>\n<hr>\n<h2>Compiler's assumption on destructor call with template-arguments.</h2>\n<p>We also find in <code>14. Templates</code></p>\n<pre><code>3 After name lookup (3.4) finds that a name is a template-name,\n  if this name is followed by a &lt;, the &lt; is always taken as the\n  beginning of a template-argument-list and never as a name\n  followed by the less-than operator.\n</code></pre>\n<p>So the compiler must assume in your example that the <code>&lt;</code> is the beginning\nof a template-argument-list.</p>\n<p>Also, if your destructor would be a template (...), then</p>\n<pre><code>4   When the name of a member template specialization appears \n    after . or -&gt; in a postfix-expression, or after nested-name-specifier\n    in a qualified-id, and the postfix-expression or qualified-id explicitly\n    depends on a template-parameter (14.6.2), the member template name must\n    be prefixed by the keyword template. Otherwise the name is assumed to \n    name a non-template.\n</code></pre>\n<p>So because you did not prefix your destructor call <code>f.~foo&lt;int&gt;</code> with template, i.e.\nlike <code>f.template ~foo&lt;int&gt;</code>, the compiler must assume that your destructor\nis NOT a template.</p>\n<h3>Backtrack.</h3>\n<p>Further,</p>\n<pre><code>6   A template-id that names a class template specialization\n    is a class-name (clause 9).\n</code></pre>\n<p>So <code>~foo&lt;int&gt;</code> names your template specialization <code>foo&lt;int&gt;</code> and therefore is a <code>class-name</code>,\na <code>class-name</code> is by the grammar rules a <code>type-name</code>, and a <code>~</code> followed by a <code>typename</code> is \na destructor call. Therefore</p>\n<pre><code>foo&lt;int&gt; f;\nf.~foo&lt;int&gt;(); // valid\n</code></pre>\n<hr>\n<h2>Destructor call without template-arguments.</h2>\n<p>But also </p>\n<pre><code>f.~foo(); // valid\n</code></pre>\n<p>Because <code>3.4.5 Class member access</code>:</p>\n<pre><code>3 If the unqualified-id is \u02dctype-name, and the type of the object expression\n  is of a class type C (or of pointer to a class type C), the type-name is\n  looked up in the context of the entire postfix-expression and in the scope of\n  class C. [...]\n</code></pre>\n<p>thus in  <code>f.~foo();</code>, <code>foo</code> is looked up within <code>f.</code>, and <em>within</em> the scope of <code>foo&lt;int&gt;</code>, it is valid\nto refer to it just with with <code>foo</code>.</p>\n<hr>\n<h2>The standard is actually explicit on this topic, d'oh.</h2>\n<p>And finally, 14.3 contains the one-and-for-all-permission:</p>\n<pre><code>5   An explicit destructor call (12.4) for an object that \n    has a type that is a class template specialization may\n    explicitly specify the template-arguments. [Example:\n\n      template&lt;class T&gt; struct A {\n          \u02dcA();\n      };\n      void f(A&lt;int&gt;* p, A&lt;int&gt;* q) {\n          p-&gt;A&lt;int&gt;::\u02dcA();      // OK: destructor call\n          q-&gt;A&lt;int&gt;::\u02dcA&lt;int&gt;(); // OK: destructor call\n      }\n\n    \u2014end example]\n</code></pre>\n</hr></hr></hr></hr>", "LastActivityDate": "2011-07-28T09:18:32.737"}, "bq_ids": {"n4140": {"so_6845779_6846266_0": {"section_id": 7128, "quality": 0.96, "length": 24}}, "n3337": {"so_6845779_6846266_0": {"section_id": 6872, "quality": 0.96, "length": 24}}, "n4659": {"so_6845779_6846266_0": {"section_id": 8629, "quality": 0.88, "length": 22}}}, "6846266": {"ParentId": "6845779", "LastEditDate": "2011-07-27T14:48:32.440", "CommentCount": "2", "CreationDate": "2011-07-27T14:40:55.163", "OwnerUserId": "726300", "LastEditorUserId": "726300", "PostTypeId": "2", "Id": "6846266", "Score": "3", "Body": "<p>From n3290, 3.4.5 Class member access [basic.lookup.classref]</p>\n<blockquote>\n<p id=\"so_6845779_6846266_0\">3 If the unqualified-id is ~type-name, the type-name is looked up in\n  the context of the entire postfix-expression. If the type T of the\n  object expression is of a class type C, the type-name is also looked\n  up in the scope of class C. At least one of the lookups shall find a\n  name that refers to (possibly cv-qualified) T. [...]</p>\n</blockquote>\n<p>Following that is an example (as a non-normative note) which contains the following snippet of code:</p>\n<pre><code>a-&gt;~A(); // OK: lookup in *a finds the injected-class-name\n</code></pre>\n<p>In particular, for <code>template&lt;typename T, typename Allocator&gt; class vector;</code>, <code>vector</code> is the injected-class-name. For that reason, I believe</p>\n<pre><code>obj-&gt;v.~vector();\n</code></pre>\n<p>is correct.</p>\n<p>(I don't have anything to say about <code>~vector&lt;T&gt;</code> <s>at the moment.</s>)</p>\n", "LastActivityDate": "2011-07-27T14:48:32.440"}});