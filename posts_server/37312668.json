post_cb({"bq_ids": {"n4140": {"so_37312668_37313013_1": {"length": 23, "quality": 0.7666666666666667, "section_id": 7040}, "so_37312668_37313013_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_37312668_37313013_2": {"length": 7, "quality": 0.875, "section_id": 7039}}, "n3337": {"so_37312668_37313013_1": {"length": 18, "quality": 0.6, "section_id": 6785}, "so_37312668_37313013_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 5235}, "so_37312668_37313013_2": {"length": 7, "quality": 0.875, "section_id": 6785}}, "n4659": {"so_37312668_37313013_1": {"length": 27, "quality": 0.9, "section_id": 8537}, "so_37312668_37313013_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_37312668_37313013_2": {"length": 7, "quality": 0.875, "section_id": 8536}}}, "37313013": {"Id": "37313013", "PostTypeId": "2", "Body": "<p>[declval] stipulates that:</p>\n<blockquote>\n<p id=\"so_37312668_37313013_0\">If this function is odr-used (3.2), the program is ill-formed.</p>\n</blockquote>\n<p>That's basically it. Where functions are concerned, odr-use means, from [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_37312668_37313013_1\">A function whose name appears as a potentially-evaluated expression is odr-used\n  if it is the unique lookup result or the selected member of a set of overloaded functions (3.4, 13.3, 13.4),\n  unless it is a pure virtual function and either its name is not explicitly qualified or the expression forms\n  a pointer to member (5.3.1).</p>\n</blockquote>\n<p>But also:</p>\n<blockquote>\n<p id=\"so_37312668_37313013_2\">An expression is <em>potentially evaluated</em> unless it is an unevaluated operand (Clause 5) or a subexpression\n  thereof.</p>\n</blockquote>\n<p>And [dcl.type.simple]:</p>\n<blockquote>\n<p id=\"so_37312668_37313013_3\">The operand of the <code>decltype</code> specifier is an unevaluated operand (Clause 5).</p>\n</blockquote>\n<p>So in <code>decltype(std::declval&lt;const void&gt;)</code>, <code>std::declval</code> isn't potentially evaluated and hence it's not odr-used. Since that's the one criteria on <code>declval</code> for the program to be ill-formed and we don't meet it, I think libstdc++ is wrong to emit the static assertion.</p>\n<hr/>\n<p>Though I don't think this is a libstc++ thing. I think it's more of a question of when <code>static_assert</code>s get triggered. The libstdc++ implementation of <code>declval</code> is:</p>\n<pre><code>template&lt;typename _Tp&gt; \nstruct __declval_protector\n{    \n    static const bool __stop = false;\n    static typename add_rvalue_reference&lt;_Tp&gt;::type __delegate();\n};   \n\ntemplate&lt;typename _Tp&gt; \ninline typename add_rvalue_reference&lt;_Tp&gt;::type\ndeclval() noexcept\n{    \n    static_assert(__declval_protector&lt;_Tp&gt;::__stop,\n         \"declval() must not be used!\");\n    return __declval_protector&lt;_Tp&gt;::__delegate();\n} \n</code></pre>\n<p>Both gcc and clang trigger that <code>static_assert</code> in this context (but obviously not with <code>decltype(std::declval&lt;const void&gt;())</code>, even though we're in an unevaluated context in both cases. I suspect that's a bug, but it may simply be underspecified in the standard what the correct behavior is with regards to triggering <code>static_assert</code>s. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-05-19T13:36:09.777", "Score": "4", "CreationDate": "2016-05-19T02:33:38.667", "ParentId": "37312668", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2016-05-19T13:36:09.777"}, "37312668": {"ViewCount": "645", "Body": "<p>The following code triggers a static assertion on libstdc++:</p>\n<pre><code>#include &lt;utility&gt;\n\nusing t = decltype(std::declval&lt;const void&gt;);\n</code></pre>\n<p>Should it?</p>\n<hr>\n<p>Motivation for this question:</p>\n<p>The following <code>declval</code> implementation <a href=\"https://llvm.org/bugs/show_bug.cgi?id=27798\" rel=\"noreferrer\">proposed by Eric Niebler</a> (which is apparently a compile time optimization)</p>\n<pre><code>template&lt;typename _Tp, typename _Up = _Tp&amp;&amp;&gt;\n_Up __declval(int);\n\ntemplate&lt;typename _Tp&gt;\n_Tp __declval(long);\n\ntemplate&lt;typename _Tp&gt;\nauto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0));\n</code></pre>\n<p>would be questionable if a user could legally observe the type of <code>std::declval&lt;const void&gt;</code>. The signature in the standard </p>\n<pre><code>template &lt;class T&gt;\nadd_rvalue_reference_t&lt;T&gt; declval() noexcept;\n</code></pre>\n<p>results in the type <code>const void ()</code> (or <code>const void () noexcept</code> in C++17), whereas the proposed version results in the type <code>void ()</code> (or <code>void () noexcept</code>).</p>\n</hr>", "Title": "Is it allowed to use decltype on std::declval<T> (the function itself, not the result of calling it)?", "CreationDate": "2016-05-19T01:49:17.923", "LastActivityDate": "2016-05-19T13:36:09.777", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-19T08:10:26.937", "LastEditorUserId": "2756719", "Id": "37312668", "Score": "10", "OwnerUserId": "2756719", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}});