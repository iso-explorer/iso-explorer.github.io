post_cb({"46107312": {"CommentCount": "2", "AcceptedAnswerId": "46107877", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2017-09-08T01:29:19.330", "LastActivityDate": "2017-09-08T02:55:35.850", "LastEditDate": "2017-09-08T01:44:51.863", "ViewCount": "267", "FavoriteCount": "1", "Title": "C++ standard: do namespace-scoped constexpr variables have internal linkage?", "Id": "46107312", "Score": "11", "Body": "<p>Imagine we have a header <code>foo.h</code> containing the following:</p>\n<pre><code>#ifndef FOO_H_\n#define FOO_H_\n\nnamespace foo {\nconstexpr std::string_view kSomeString = \"blah\";\n}\n\n#endif  // FOO_H_\n</code></pre>\n<p>Is <code>foo::kSomeString</code> guaranteed to have internal linkage in any translation unit that includes <code>foo.h</code>? Does this vary between C++11 and C++17?</p>\n<p>In the draft standard <a href=\"http://eel.is/c++draft/basic.link#3\" rel=\"noreferrer\">[basic.link]/3</a> says</p>\n<blockquote>\n<p id=\"so_46107312_46107312_0\">A name having namespace scope has internal linkage if it is the name of [...] a non-inline variable of non-volatile const-qualified type that is neither explicitly declared extern nor previously declared to have external linkage [...]</p>\n</blockquote>\n<p>But I don't know if <code>constexpr</code> counts as \"const-qualified\". Does the standard say so somewhere?</p>\n<p>Assuming this is guaranteed to have internal linkage, it seems like there can be no problem with the ODR for this usage, right? (In contrast to what it says in <a href=\"https://stackoverflow.com/a/45666276/1505451\">this answer</a>.)</p>\n", "Tags": "<c++><c++11><language-lawyer><c++1z><linkage>", "OwnerUserId": "1505451", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46107312_46107312_0": {"section_id": 7136, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_46107312_46107312_0": {"section_id": 6880, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_46107312_46107312_0": {"section_id": 8637, "quality": 1.0, "length": 22}}}, "46107877": {"ParentId": "46107312", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-09-08T02:48:58.637", "Score": "13", "LastEditorUserId": "2756719", "LastEditDate": "2017-09-08T02:55:35.850", "Id": "46107877", "OwnerUserId": "2756719", "Body": "<p>Yes, <code>constexpr</code> on an object declaration means that the object is <code>const</code>. See <a href=\"https://timsong-cpp.github.io/cppwp/dcl.constexpr#9\" rel=\"noreferrer\">[dcl.constexpr]/9</a>. And yes, that means that <code>kSomeString</code> in your example has internal linkage.</p>\n<p>The species of ODR violation we are talking about here is not the definition of <code>kSomeString</code> itself, but other definitions that attempt to use it. And there's a problem precisely because of the internal linkage. Consider:</p>\n<pre><code>void f(const std::string_view &amp;);\n\ninline void g() { \n    f(foo::kSomeString); \n}\n</code></pre>\n<p>This is an ODR violation if included in multiple translation units, essentially because the definition of <code>g</code> in each translation unit references a different object.</p>\n", "LastActivityDate": "2017-09-08T02:55:35.850"}});