post_cb({"27302647": {"ParentId": "27302548", "CommentCount": "0", "Body": "<p>For <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\">unique_ptr</a> the answer is yes:</p>\n<blockquote>\n<p id=\"so_27302548_27302647_0\">The <strong>object is destroyed and its memory deallocated when either of the\n  following happen</strong>s:</p>\n<ul>\n<li>unique_ptr managing the object is destroyed</li>\n<li><strong>unique_ptr managing the object is assigned another pointer via operator= or reset().</strong></li>\n</ul>\n<p id=\"so_27302548_27302647_1\">The object is destroyed using a potentially user-supplied deleter by\n  calling Deleter(ptr). The deleter calls the destructor of the object\n  and dispenses the memory.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "PostTypeId": "2", "Id": "27302647", "Score": "3", "CreationDate": "2014-12-04T19:43:22.057", "LastActivityDate": "2014-12-04T19:43:22.057"}, "27302548": {"CommentCount": "0", "ViewCount": "1732", "PostTypeId": "1", "CreationDate": "2014-12-04T19:38:36.970", "LastActivityDate": "2014-12-07T19:43:59.160", "Title": "Reassigning Smart Pointers", "AcceptedAnswerId": "27302643", "LastEditorDisplayName": "user4236667", "LastEditDate": "2014-12-04T19:44:18.490", "Id": "27302548", "Score": "6", "Body": "<p>Generally speaking do smart pointers such as <code>std::unique_ptr</code> and <code>Glib::RefPtr</code> delete their object when reassigned to point at another object, given they are the only pointers holding that given object (obviously implied in case of <code>std::unique_ptr</code>)?</p>\n", "Tags": "<c++><c++11><smart-pointers><glib><gtkmm>", "OwnerUserId": "3314927", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27302548_27302643_1": {"section_id": 4321, "quality": 1.0, "length": 7}, "so_27302548_27302643_0": {"section_id": 4341, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_27302548_27302643_1": {"section_id": 4162, "quality": 0.8571428571428571, "length": 6}, "so_27302548_27302643_0": {"section_id": 4182, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_27302548_27302643_1": {"section_id": 5578, "quality": 1.0, "length": 7}, "so_27302548_27302643_0": {"section_id": 5598, "quality": 0.8666666666666667, "length": 13}}}, "27302643": {"ParentId": "27302548", "LastEditDate": "2014-12-07T19:43:59.160", "CommentCount": "2", "CreationDate": "2014-12-04T19:43:03.437", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "27302643", "Score": "9", "Body": "<p>For <code>unique_ptr::reset</code>, [unique.ptr.single.modifiers]/4:</p>\n<blockquote>\n<p id=\"so_27302548_27302643_0\"><em>Effects</em>: assigns <code>p</code> to the stored pointer, and then <strong>if the old value of the stored pointer, <code>old_p</code>, was not equal to <code>nullptr</code>, calls\n  <code>get_deleter()(old_p)</code></strong>.</p>\n</blockquote>\n<p>Or the move assignment operator, <code>operator=(unique_ptr&amp;&amp; u)</code> in [unique.ptr.single.asgn]/2:</p>\n<blockquote>\n<p id=\"so_27302548_27302643_1\">Transfers ownership from <code>u</code> to <code>*this</code> as if <strong>by calling\n  <code>reset(u.release())</code></strong> followed by <code>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</code>.</p>\n</blockquote>\n<p><sub>(Equivalent for the other assignment operator template)</sub><br>\n<hr>\nFor <code>shared_ptr</code>, reassignment is a little bit different. <code>shared_ptr</code> will never destroy a referenced object when it's not the last remaining one owning it, so let's assume that is given.<br>\n<code>shared_ptr::reset(Y*)</code> specifies in [util.smartptr.shared.mod]/3:</br></hr></br></p>\n<blockquote>\n<p id=\"so_27302548_27302643_2\"><em>Effects</em>: Equivalent to <code>shared_ptr(p).swap(*this)</code>.</p>\n</blockquote>\n<p>But clearly the temporary gets destroyed at the end of the function call, destroying the hold object (if applicable).<br> That is the same behavior <code>operator=(shared_ptr&lt;&gt; const&amp;)</code> has, [util.smartptr.shared.assign]/1 and 4:</br></p>\n<blockquote>\n<p id=\"so_27302548_27302643_3\"><em>Effects</em>: Equivalent to <code>shared_ptr(r).swap(*this)</code>.</p>\n</blockquote>\n<p>\u2026 move assignment operator (template), <code>r</code> is <code>shared_ptr&lt;&gt;&amp;&amp;</code>:</p>\n<blockquote>\n<p id=\"so_27302548_27302643_4\"><em>Effects</em>: Equivalent to <code>shared_ptr(std::move(r)).swap(*this)</code>.</p>\n</blockquote>\n<p>If <code>*this</code> was the last owning the object, then now the temporary is - which will be destroyed inside.</p>\n<hr>\n<p>For <code>Glib::RefPtr</code> the scenario is similar to <code>shared_ptr</code>: The copy assignment operator (and an assignment operator template) are defined with the same semantics. If the current <code>RefPtr</code> is assigned to something else, the currently hold objects reference counter is decremented and its destroyed if the resulting counter value is zero.</p>\n</hr>", "LastActivityDate": "2014-12-07T19:43:59.160"}});