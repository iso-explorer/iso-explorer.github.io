post_cb({"bq_ids": {"n4140": {"so_45455345_45457821_4": {"length": 7, "quality": 0.875, "section_id": 1409}, "so_45455345_45457821_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 1438}, "so_45455345_45457821_2": {"length": 15, "quality": 0.75, "section_id": 1407}, "so_45455345_45457821_3": {"length": 10, "quality": 0.6666666666666666, "section_id": 1401}}, "n3337": {"so_45455345_45457821_4": {"length": 7, "quality": 0.875, "section_id": 1403}, "so_45455345_45457821_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 1432}, "so_45455345_45457821_2": {"length": 15, "quality": 0.75, "section_id": 1401}, "so_45455345_45457821_3": {"length": 10, "quality": 0.6666666666666666, "section_id": 1395}}, "n4659": {"so_45455345_45457821_4": {"length": 5, "quality": 0.625, "section_id": 1527}, "so_45455345_45457821_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 1576}, "so_45455345_45457821_2": {"length": 15, "quality": 0.75, "section_id": 1526}, "so_45455345_45457821_3": {"length": 10, "quality": 0.6666666666666666, "section_id": 1518}}}, "45457821": {"Id": "45457821", "PostTypeId": "2", "Body": "<p>Nothing requires partial_sort to be implemented in a certain way, except the guarantees of complexity</p>\n<blockquote>\n<p id=\"so_45455345_45457821_0\">25.4.1.3 partial_sort [partial.sort] </p>\n<p id=\"so_45455345_45457821_1\">template void partial_sort(RandomAccessIterator first,\n   RandomAccessIterator middle, RandomAccessIterator last);\n   template \n   void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,\n   RandomAccessIterator last, Compare comp); </p>\n<p id=\"so_45455345_45457821_2\">1 Effects: Places the first middle - first sorted elements from the range [first,last) into the range [first,middle). The rest of the elements in the range [middle,last) are placed in an unspecified order. </p>\n<p id=\"so_45455345_45457821_3\">2 Requires:\n  RandomAccessIterator shall satisfy the requirements of ValueSwappable\n  (17.6.3.2). The type of *first shall satisfy the requirements of\n  MoveConstructible (Table 20) and of MoveAssignable (Table 22). </p>\n<p id=\"so_45455345_45457821_4\">3 Complexity: It takes approximately (last - first) * log(middle - first) comparisons</p>\n</blockquote>\n<p>An alternative implementation could be</p>\n<pre><code>std::nth_element - average linear time\nfollowed by\nstd::sort - on the reduced range begin()-nth (n log n)\n</code></pre>\n", "LastEditorUserId": "4013258", "LastActivityDate": "2017-08-02T10:33:34.300", "Score": "1", "CreationDate": "2017-08-02T10:08:14.277", "ParentId": "45455345", "CommentCount": "0", "OwnerUserId": "4013258", "LastEditDate": "2017-08-02T10:33:34.300"}, "45455442": {"Id": "45455442", "PostTypeId": "2", "Body": "<p>According to <a href=\"https://www.sgi.com/tech/stl/partial_sort.html\" rel=\"nofollow noreferrer\">sgi doc</a>, <code>partial_sort</code> uses <em>heapsort</em>, <code>sort</code> uses <em>introsort</em>:</p>\n<blockquote>\n<p id=\"so_45455345_45455442_0\">partial_sort(first, last, last) has the effect of sorting the entire range [first, last), just like sort(first, last). They use different algorithms, however: sort uses the introsort algorithm (a variant of quicksort), and partial_sort uses heapsort. See section 5.2.3 of Knuth (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and Searching. Addison-Wesley, 1975.), and J. W. J. Williams (CACM 7, 347, 1964). Both heapsort and introsort have complexity of order N log(N), but introsort is usually faster by a factor of 2 to 5.</p>\n</blockquote>\n<p>So, it is normal <code>partial_sort</code> is 4 times slower than <code>sort</code>.</p>\n<hr>\n<p>I have checked my VS2017 library, and found the implementation of <code>partial_sort</code> and <code>sort</code>. And it is similar with SGI.</p>\n<h3>partial_sort</h3>\n<pre><code>template&lt;class _RanIt,\n    class _Pr&gt; inline\nvoid _Partial_sort_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last,\n        _Pr&amp; _Pred)\n{       // order [_First, _Last) up to _Mid, using _Pred\n    if (_First == _Mid)\n        return; // nothing to do, avoid violating _Pop_heap_hole_unchecked preconditions\n    _Make_heap_unchecked(_First, _Mid, _Pred);\n    for (_RanIt _Next = _Mid; _Next &lt; _Last; ++_Next)\n        if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))\n        {       // replace top with new largest\n            _Iter_value_t&lt;_RanIt&gt; _Val = _STD move(*_Next);\n            _Pop_heap_hole_unchecked(_First, _Mid, _Next, _STD move(_Val), _Pred);\n        }\n    _Sort_heap_unchecked(_First, _Mid, _Pred);\n}\n</code></pre>\n<h3>sort</h3>\n<pre><code>template&lt;class _RanIt,\n    class _Diff,\n    class _Pr&gt; inline\nvoid _Sort_unchecked1(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr&amp; _Pred)\n{       // order [_First, _Last), using _Pred\n    _Diff _Count;\n    while (_ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal)\n    {   // divide and conquer by quicksort\n        pair&lt;_RanIt, _RanIt&gt; _Mid =\n            _Partition_by_median_guess_unchecked(_First, _Last, _Pred);\n        _Ideal /= 2, _Ideal += _Ideal / 2;      // allow 1.5 log2(N) divisions\n\n        if (_Mid.first - _First &lt; _Last - _Mid.second)\n        {       // loop on second half\n            _Sort_unchecked1(_First, _Mid.first, _Ideal, _Pred);\n            _First = _Mid.second;\n        }\n        else\n        {       // loop on first half\n            _Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);\n            _Last = _Mid.first;\n        }\n    }\n\n    if (_ISORT_MAX &lt; _Count)\n    {   // heap sort if too many divisions\n        _Make_heap_unchecked(_First, _Last, _Pred);\n        _Sort_heap_unchecked(_First, _Last, _Pred);\n    }\n    else if (2 &lt;= _Count)\n        _Insertion_sort_unchecked(_First, _Last, _Pred);        // small\n}\n</code></pre>\n</hr>", "LastEditorUserId": "675154", "LastActivityDate": "2017-08-02T08:47:59.920", "Score": "3", "CreationDate": "2017-08-02T08:25:55.363", "ParentId": "45455345", "CommentCount": "4", "OwnerUserId": "675154", "LastEditDate": "2017-08-02T08:47:59.920"}, "45455345": {"ViewCount": "174", "Body": "<p>Is there a significant difference between the following two approaches? Way 1 uses <code>sort</code> or <code>partial_sort</code>, depending on the size of the vector while way 2 always uses <code>partial_sort</code>. I find way 2 more appealing because my predicate is a bit more complicated than in the example, so I don't want to repeat it. But I wonder if <code>partial_sort</code> performs worse than <code>sort</code> because it is not meant to be used to sort the whole range, which is why I tend to use way 1.</p>\n<pre><code>int main()\n{\n  std::vector&lt;double&gt; vec;\n  vec.push_back(1.0);\n  vec.push_back(3.0);\n  vec.push_back(2.0);\n  vec.push_back(5.0);\n  vec.push_back(4.0);\n  vec.push_back(9.0);\n  const size_t numBest = 3;\n  const size_t numTotal= vec.size();\n\n#if WAY1\n  if (numTotal &lt; numBest)\n  {\n    std::sort(vec.begin(), vec.end(), std::not2(std::less&lt;double&gt;()));\n  }\n  else\n  {\n    std::partial_sort(vec.begin(), vec.begin() + numBest, vec.end(), std::not2(std::less&lt;double&gt;()));\n    vec.resize(numBest);\n  }\n#elif WAY2\n  {\n    const size_t numMiddle = numTotal &lt; numBest ? numTotal : numBest;\n    std::partial_sort(vec.begin(), vec.begin() + numMiddle, vec.end(), std::not2(std::less&lt;double&gt;()));\n    vec.resize(numMiddle);\n  }\n#endif\n\n  // now vec contains the largest numBest results.\n  return 0;\n}\n</code></pre>\n<p>Some testing yielded that partial_sort is significantly worse (factor of 4 in my usecase) than sort if if has to sort the whole range. This indicates that way 1 is to be preferred. It seems that partial_sort is only meant for sorting a small fraction of the whole range. I tested in Visual Studio 2010.</p>\n", "Title": "Performance of std::partial_sort() versus std::sort() when sorting the whole range?", "CreationDate": "2017-08-02T08:21:22.167", "LastActivityDate": "2017-08-02T10:33:34.300", "CommentCount": "1", "LastEditDate": "2017-08-02T08:49:50.870", "PostTypeId": "1", "LastEditorUserId": "4675398", "Id": "45455345", "Score": "3", "OwnerUserId": "4675398", "Tags": "<c++><performance><sorting><partial-sort>", "AnswerCount": "2"}});