post_cb({"31876378": {"ViewCount": "83", "Body": "<p>This is quite normal:</p>\n<pre><code>[const] char *str = \"some text\";\n</code></pre>\n<p>But initialisation is not the same as reassignment and string literals are a bit of a special case. What are the rules if you try to do this:</p>\n<pre><code>[const] char *str = \"some text\";\nstr = \"some other text\";\n</code></pre>\n<p><strong>Note</strong> before someone says \"try it\" I'm asking what the language spec says, not what my particular compiler does.</p>\n", "Title": "Are you allowed to re-assign char* to a string literal?", "CreationDate": "2015-08-07T11:13:39.653", "LastActivityDate": "2015-08-07T11:27:46.153", "CommentCount": "0", "LastEditDate": "2015-08-07T11:22:20.717", "PostTypeId": "1", "LastEditorUserId": "197229", "Id": "31876378", "Score": "1", "OwnerUserId": "197229", "Tags": "<c++>", "AnswerCount": "3"}, "31876568": {"Id": "31876568", "PostTypeId": "2", "Body": "<p>First of all it would be correctly to write</p>\n<pre><code>const char *str = \"some text\";\n^^^^^\n</code></pre>\n<p>because string literals in C++ have types of constant character arrays. For example string literal \"some text\" has type <code>const char [10]</code>.</p>\n<p>An array name used in expressions is implicitly converted to a pointer to its first element.</p>\n<p>For example in this declaration</p>\n<pre><code>const char *str = \"some text\";\n</code></pre>\n<p>the string literal is implicitly converted to an object of type <code>const char *</code> and has value of the address of the first character of the string literal.</p>\n<p>Pointers may be reassigned. The assignment operator may be used with pointers.</p>\n<p>So you may write</p>\n<pre><code>const char *str = \"some text\";\nstr = \"some other text\";\n</code></pre>\n<p>Now pointer str is reassigned and points to to the first character of string literal \"some other text\".</p>\n<p>However if you declare the pointer itself as a constant object as for example</p>\n<pre><code>const char * const str = \"some text\";\n             ^^^^^\n</code></pre>\n<p>then in this case you may not reassigned it. The compiler will issue an error for statement</p>\n<pre><code>str = \"some other text\";\n</code></pre>\n", "LastActivityDate": "2015-08-07T11:24:55.853", "CommentCount": "0", "CreationDate": "2015-08-07T11:24:55.853", "ParentId": "31876378", "Score": "1", "OwnerUserId": "2877241"}, "bq_ids": {"n4140": {"so_31876378_31876401_2": {"length": 7, "quality": 1.0, "section_id": 3314}, "so_31876378_31876401_0": {"length": 38, "quality": 0.95, "section_id": 3314}}, "n3337": {"so_31876378_31876401_2": {"length": 7, "quality": 1.0, "section_id": 3184}, "so_31876378_31876401_0": {"length": 34, "quality": 0.85, "section_id": 3184}}, "n4659": {"so_31876378_31876401_2": {"length": 7, "quality": 1.0, "section_id": 4080}, "so_31876378_31876401_0": {"length": 38, "quality": 0.95, "section_id": 4080}}}, "31876451": {"Id": "31876451", "PostTypeId": "2", "Body": "<p>Let's repose your question as being assignment and reassignment to a <code>const char*</code>. This is because a string literal is a read-only array of characters terminated will <code>\\0</code>, and compilers are lapse in allowing assignment of a string literal to a <code>char*</code>. C++11 explicitly forbids this.</p>\n<p>Reassignment of a <code>const char*</code> to a different literal is permissible: there is no danger of a memory leak here since the strings will be stored in a read-only section of your compiled binary.</p>\n", "LastEditorUserId": "3233393", "LastActivityDate": "2015-08-07T11:21:47.103", "Score": "2", "CreationDate": "2015-08-07T11:17:55.793", "ParentId": "31876378", "CommentCount": "4", "OwnerUserId": "2380830", "LastEditDate": "2015-08-07T11:21:47.103"}, "31876401": {"Id": "31876401", "PostTypeId": "2", "Body": "<h3>About <code>char*</code></h3>\n<p>As of C++11 all of that code is illegal. String literals can only be binded to <code>char const*</code> or in general a <code>[char] const</code> array. </p>\n<p>Notice that a <code>char[]</code> can be initialized with a string literal as per \u00a78.5.2/1:</p>\n<blockquote>\n<p id=\"so_31876378_31876401_0\">An array of narrow character type (3.9.1), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array can be initialized by a narrow string literal, <code>char16_t</code> string literal, <code>char32_t</code> string literal, or wide string literal, respectively, or by an appropriately-typed string literal enclosed in braces (2.13.5). Successive characters of the value of the string literal initialize the elements of the array. </p>\n<p id=\"so_31876378_31876401_1\">[Example:</p>\n<pre><code>char msg[] = \"Syntax error on line %s\\n\";\n</code></pre>\n<p id=\"so_31876378_31876401_2\">shows a character array whose members are initialized with a string-literal. [...]</p>\n</blockquote>\n<p>Previously <code>char*</code> was supported but considered deprecated. And anyway, modifications to the string via that <code>char*</code> were considered undefined behaviour.</p>\n<p>As per \u00a74.2/2 (pre-C++11):</p>\n<blockquote>\n<p id=\"so_31876378_31876401_3\">A string literal (2.13.4) that is not a wide string literal can be converted to an rvalue of type \u201cpointer to <code>char</code>\u201d; a wide string literal can be converted to an rvalue of type \u201cpointer to <code>wchar_t</code>\u201d. In either case, the result is a pointer to the first element of the array. This conversion is considered only when there is an explicit appropriate pointer target type, and not when there is a general need to convert from an lvalue to an rvalue. [Note: this conversion is deprecated. See Annex D. ] For the purpose of ranking in overload resolution (13.3.3.1.1), this conversion is considered an array-to-pointer conversion followed by a qualification conversion (4.4). [Example: <code>\"abc\"</code> is converted to \u201cpointer to <code>const char</code>\u201d as an array-to-pointer conversion, and then to \u201cpointer to <code>char</code>\u201d as a qualification conversion. ]</p>\n</blockquote>\n<h2>About reassigning the pointer</h2>\n<p>Reassinging a <code>char*</code> or a <code>char const*</code> is perfectly fine. The <code>const</code> there refers to the character, not the pointer. To avoid reassigning you would need <code>char* const</code> and <code>char const* const</code> respectively.</p>\n", "LastEditorUserId": "493122", "LastActivityDate": "2015-08-07T11:27:46.153", "Score": "2", "CreationDate": "2015-08-07T11:15:21.823", "ParentId": "31876378", "CommentCount": "1", "OwnerUserId": "493122", "LastEditDate": "2015-08-07T11:27:46.153"}});