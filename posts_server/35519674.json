post_cb({"35519744": {"ParentId": "35519674", "CommentCount": "0", "Body": "<p>You need to provide a type argument to clear up the overload:</p>\n<pre><code>std::mem_fn&lt;void(const int&amp;)&gt;(&amp;vector&lt;int&gt;::push_back);\n</code></pre>\n<p>Or</p>\n<pre><code>std::mem_fn&lt;void(int&amp;&amp;)&gt;(&amp;vector&lt;int&gt;::push_back);\n</code></pre>\n", "OwnerUserId": "102441", "PostTypeId": "2", "Id": "35519744", "Score": "2", "CreationDate": "2016-02-20T05:55:33.997", "LastActivityDate": "2016-02-20T05:55:33.997"}, "35519674": {"CommentCount": "0", "ViewCount": "242", "CreationDate": "2016-02-20T05:48:06.583", "LastActivityDate": "2016-02-20T06:20:11.473", "Title": "C++0x auto cannot deduce the type of vector<int> member function pointer", "PostTypeId": "1", "Id": "35519674", "OwnerUserId": "637902", "Body": "<p>Using GCC 4.7.0 (g++ -std=c++0x test.cpp) to compile the following simple C++ code gives compile error message: <strong>error: unable to deduce \u2018auto\u2019 from \u2018&amp; std::vector&lt;_Tp, _Alloc&gt;::push_back &gt;\u2019</strong> </p>\n<p>I question is why in this simple case <strong>auto</strong> cannot deduce the type of member function pointer?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main(void) {\n\n    // works \n    void (vector&lt;int&gt;::*pb)(const vector&lt;int&gt;::value_type&amp;)\n        = &amp;vector&lt;int&gt;::push_back;\n\n    // not work\n    auto pbb = std::mem_fn(&amp;vector&lt;int&gt;::push_back);\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><vector><auto>", "Score": "4", "AnswerCount": "2"}, "bq_ids": {"n4659": {"so_35519674_35519743_0": {"section_id": 7851, "quality": 0.9107142857142857, "length": 51}}}, "35519743": {"ParentId": "35519674", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++11 added an overload for <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\"><code>vector::push_back</code></a> that takes an rvalue argument. <code>mem_fn</code> is unable to deduce which one of the two overloads you wish to take the address of, so you'll need to add a cast to disambiguate.</p>\n<pre><code>auto pbb = std::mem_fn(static_cast&lt;void (vector&lt;int&gt;::*)(const vector&lt;int&gt;::value_type&amp;)&gt;(&amp;vector&lt;int&gt;::push_back));\n</code></pre>\n<hr>\n<p>Note that taking the address of a member function of a class in the standard library should be avoided as far as possible. Implementations are allowed to add additional overloads, parameters with default arguments etc., which will make the code non-portable.</p>\n<p>\u00a717.6.5.5/2 <em>[member.functions]</em></p>\n<blockquote>\n<p id=\"so_35519674_35519743_0\">For a non-virtual member function described in the C++ standard library, an implementation may declare a different set of member function signatures, provided that any call to the member function that would select an overload from the set of declarations described in this standard behaves as if that overload were selected. [ <em>Note:</em> For instance, an implementation may add parameters with default values, or replace a member function with default arguments with two or more member functions with equivalent behavior, or\n  add additional signatures for a member function name. <em>\u2014end note</em> ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2016-02-20T06:20:11.473", "Id": "35519743", "Score": "9", "CreationDate": "2016-02-20T05:55:29.040", "LastActivityDate": "2016-02-20T06:20:11.473"}});