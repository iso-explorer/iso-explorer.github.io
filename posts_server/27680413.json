post_cb({"bq_ids": {"n4140": {"so_27680413_27680626_1": {"length": 23, "quality": 1.0, "section_id": 5422}}, "n3337": {"so_27680413_27680626_1": {"length": 23, "quality": 1.0, "section_id": 5217}}, "n4659": {"so_27680413_27680626_1": {"length": 23, "quality": 1.0, "section_id": 6844}}}, "27680413": {"ViewCount": "102", "Body": "<p>The following definition is not allowed by my compiler as <code>std::string</code> has a non trivial destructor (makes sense that <code>teststr</code> can't have a trivial dtor when a member doesn't):</p>\n<pre><code>class teststr\n{\nprivate:\n    std::string _m;\npublic:\n    constexpr teststr(std::string value) : _m(value) {};\n\n    constexpr std::string m() const { return _m; }\n    void m(std::string value) { _m = value; }\n};\n</code></pre>\n<p>However, the following equivalent (to the best of my knowledge) definition of <code>teststr</code> is allowed:</p>\n<pre><code>template&lt;typename T&gt;\nclass test\n{\nprivate:\n    T _m;\npublic:\n    constexpr test(T value) : _m(value) {};\n\n    constexpr T m() const { return _m; }\n    void m(T value) { _m = value; }\n};\n\ntypedef test&lt;std::string&gt; teststr;\n</code></pre>\n<p>What is it about templating the type that makes this definition allowed?</p>\n", "AcceptedAnswerId": "27680626", "Title": "Literal class with std::string only works with template specialization?", "CreationDate": "2014-12-28T20:43:04.870", "Id": "27680413", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2014-12-28T21:12:52.010", "Score": "5", "OwnerUserId": "611562", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}, "27680626": {"Id": "27680626", "PostTypeId": "2", "Body": "<p><code>constexpr</code> is more often allowed in templates because it is not generally known at template definition time whether the member satisfies the requirements of <code>constexpr</code>. When a template member is declared <code>constexpr</code>, it is determined at template instantiation time whether <code>constexpr</code> is appropriate, and if not, it is silently dropped.</p>\n<p>Given</p>\n<pre><code>template &lt;typename T&gt; struct test {\n  T val;\n  constexpr test(T val) : val(val) { }\n};\n</code></pre>\n<p>you can have</p>\n<pre><code>constexpr test&lt;int&gt; i = 3;\n</code></pre>\n<p>because with <code>T = int</code>, the constructor meets the requirements of <code>constexpr</code>, but you cannot have</p>\n<pre><code>constexpr test&lt;string&gt; s = \"\";\n</code></pre>\n<p>because <em>that</em> constructor does not meet the requirements of <code>constexpr</code>.</p>\n<p>It is not a hard error to instantiate <code>test&lt;string&gt;</code> because that would severely limit the ability to use <code>constexpr</code> in templates.</p>\n<p>From the standard (C++11):</p>\n<blockquote>\n<p id=\"so_27680413_27680626_0\"><strong>7.1.5 The constexpr specifier [dcl.constexpr]</strong></p>\n<p id=\"so_27680413_27680626_1\">6 If the instantiated template specialization of a <code>constexpr</code> function template or member function of a class template would fail to satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor, that specialization is not a <code>constexpr</code> function or <code>constexpr</code> constructor. [...]</p>\n</blockquote>\n", "LastActivityDate": "2014-12-28T21:12:52.010", "CommentCount": "0", "CreationDate": "2014-12-28T21:12:52.010", "ParentId": "27680413", "Score": "5", "OwnerUserId": "743382"}});