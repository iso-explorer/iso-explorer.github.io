post_cb({"bq_ids": {"n4140": {"so_46863507_46863716_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 1396}, "so_46863507_46863716_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1395}}, "n3337": {"so_46863507_46863716_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 1390}, "so_46863507_46863716_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1389}}, "n4659": {"so_46863507_46863716_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 1514}, "so_46863507_46863716_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1513}}}, "46863598": {"Id": "46863598", "PostTypeId": "2", "Body": "<p>The ordering for a set must act like <code>&lt;</code>, not <code>&lt;=</code>.  Since you have an element with the key you\u2019re looking for, the <code>&lt;=</code> is wrong and sends the search the wrong way.</p>\n<p>Meanwhile, using <code>std::lower_bound</code> on a <code>set</code> is wasteful: the iterators don\u2019t expose the search structure, so the search is effectively linear.  You can avoid this with C++14\u2019s <a href=\"http://en.cppreference.com/w/cpp/container/set/lower_bound\" rel=\"nofollow noreferrer\">heterogeneous comparisons</a> if you define <code>setCompareFunctorAux ::is_transparent</code>.</p>\n", "LastEditorUserId": "8586227", "LastActivityDate": "2017-10-21T13:24:13.257", "Score": "2", "CreationDate": "2017-10-21T13:13:50.623", "ParentId": "46863507", "CommentCount": "2", "OwnerUserId": "8586227", "LastEditDate": "2017-10-21T13:24:13.257"}, "46863625": {"Id": "46863625", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46863507_46863625_0\">The expected result is 15, but the real result is 33.</p>\n</blockquote>\n<p>No, the expected result is 20, since the function \"Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.\", as you can read in the <a href=\"http://www.cplusplus.com/reference/algorithm/lower_bound/\" rel=\"nofollow noreferrer\"><code>std::lower_bound</code></a> reference.</p>\n<p>You will not get this result, because you use <code>&lt;=</code> instead of <code>&lt;</code> in your <code>setCompareFunctorAux</code> struct.</p>\n<p>As a result, when you search for 20, it get confused from the equality, and go towards the wrong direction when searching.</p>\n<hr>\n<p>PS: Not related to your problem, but <code>setCompareFunctor</code> is not a valid comparator, because it doesn't satisfy the strict weak ordering. In order to do so, just change <code>&lt;=</code> to <code>&lt;</code>. Read more in <a href=\"https://stackoverflow.com/questions/979759/operator-and-strict-weak-ordering\">Operator&lt; and strict weak ordering</a>.</p>\n</hr>", "LastEditorUserId": "2411320", "LastActivityDate": "2017-10-21T13:35:24.870", "Score": "5", "CreationDate": "2017-10-21T13:16:20.050", "ParentId": "46863507", "CommentCount": "5", "OwnerUserId": "2411320", "LastEditDate": "2017-10-21T13:35:24.870"}, "46863716": {"Id": "46863716", "PostTypeId": "2", "Body": "<p>You have to use the strict less operator\nFrom the C++ 2017 Standard (28.7 Sorting and related operations)</p>\n<blockquote>\n<p id=\"so_46863507_46863716_0\">3 For all algorithms that take Compare, there is a version that uses\n  operator&lt; instead. That is, comp(*i, *j) != false defaults to *i &lt; *j\n  != false. For algorithms other than those described in 28.7.3, comp\n  shall induce a <strong>strict weak ordering on the values</strong>.</p>\n<p id=\"so_46863507_46863716_1\">4 The term strict refers to the requirement of an irreflexive relation\n  (!comp(x, x) for all x), and the term weak to requirements that are\n  not as strong as those for a total ordering, but stronger than those\n  for a partial ordering...</p>\n</blockquote>\n<pre><code>struct setCompareFunctor\n{\n    bool operator( )(const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs) const\n    {\n        return(lhs.second &lt; rhs.second);\n    }\n};\n\nstruct setCompareFunctorAux\n{\n    bool operator( )(const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs) const\n    {\n        return(lhs.second &lt; rhs.second);\n    }\n\n    bool operator( )(const pair&lt; int, int &gt; &amp;lhs, int val) const\n    {\n        return(lhs.second &lt; val);\n    }\n\n    bool operator( )(int val, const pair&lt; int, int &gt; &amp;rhs) const\n    {\n        return(val &lt; rhs.second);\n    }\n};\n</code></pre>\n<p>Take into account that within the called algorithm there is used the operator</p>\n<pre><code>struct setCompareFunctorAux\n{\n    //...    \n    bool operator( )(const pair&lt; int, int &gt; &amp;lhs, int val) const\n    {\n        return(lhs.second &lt; val);\n    }\n\n};\n</code></pre>\n<p>Here is a demonstrative program</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nint main()\n{\n    using namespace std;\n\n    struct setCompareFunctor\n    {\n        bool operator( )(const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs) const\n        {\n            return(lhs.second &lt; rhs.second);\n        }\n    };\n\n    struct setCompareFunctorAux\n    {\n        bool operator( )(const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs) const\n        {\n            return(lhs.second &lt; rhs.second);\n        }\n\n        bool operator( )(const pair&lt; int, int &gt; &amp;lhs, int val) const\n        {\n            return(lhs.second &lt; val);\n        }\n\n        bool operator( )(int val, const pair&lt; int, int &gt; &amp;rhs) const\n        {\n            return(val &lt;= rhs.second);\n        }\n    };\n\n    set&lt; pair&lt; int, int &gt;, setCompareFunctor &gt; submultimi;\n\n    submultimi.insert(make_pair(1, 15));\n    submultimi.insert(make_pair(2, 9));\n    submultimi.insert(make_pair(3, 33));\n    submultimi.insert(make_pair(4, 44));\n    submultimi.insert(make_pair(5, 20));\n    submultimi.insert(make_pair(6, 15));\n\n    for (const auto &amp;p : submultimi)\n    {\n        cout &lt;&lt; \"{ \" &lt;&lt; p.first\n            &lt;&lt; \", \" &lt;&lt; p.second\n            &lt;&lt; \" } \";\n    }\n    cout &lt;&lt; endl;\n\n    set&lt; pair&lt; int, int &gt;, setCompareFunctor &gt;::iterator it = lower_bound(submultimi.begin(), submultimi.end(), 20, setCompareFunctorAux());\n\n    cout &lt;&lt; (*it).second &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Its output is</p>\n<pre><code>{ 2, 9 } { 1, 15 } { 5, 20 } { 3, 33 } { 4, 44 }\n20\n</code></pre>\n<blockquote>\n<p id=\"so_46863507_46863716_2\">The expected result is 15, but the real result is 33.</p>\n</blockquote>\n<p>And the expected and correct result is 20 because there is an element with the second value equal to 20 and you are searching exactly 20. </p>\n<p>Take into account that the template class <code>std::set</code> has its own member function <code>lower_bound</code>.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2017-10-21T14:04:35.660", "Score": "1", "CreationDate": "2017-10-21T13:26:14.567", "ParentId": "46863507", "CommentCount": "4", "OwnerUserId": "2877241", "LastEditDate": "2017-10-21T14:04:35.660"}, "46863507": {"ViewCount": "87", "Body": "<p>I'm having some issues with the lower_bound comparison function.</p>\n<p>I have a set of pairs ordered by the second value of the pair and i'm tryin to get the lower_bound from this set by a value.</p>\n<p>My current code is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nstruct setCompareFunctor\n{\n    bool operator( )( const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs ) const\n    {\n        return( lhs.second &lt;= rhs.second );\n    }\n};\n\nstruct setCompareFunctorAux\n{\n    bool operator( )( const pair&lt; int, int &gt; &amp;lhs, const pair&lt; int, int &gt; &amp;rhs ) const\n    {\n        return( lhs.second &lt;= rhs.second );\n    }\n\n    bool operator( )( const pair&lt; int, int &gt; &amp;lhs, int val ) const\n    {\n        return( lhs.second &lt;= val );\n    }\n\n    bool operator( )( int val, const pair&lt; int, int &gt; &amp;rhs ) const\n    {\n        return( val &lt;= rhs.second );\n    }\n};\n\n\nint main( )\n{\n    set&lt; pair&lt; int, int &gt;, setCompareFunctor &gt; submultimi;\n\n    submultimi.insert( make_pair( 1, 15 ) );\n    submultimi.insert( make_pair( 2, 9 ) );\n    submultimi.insert( make_pair( 3, 33 ) );\n    submultimi.insert( make_pair( 4, 44 ) );\n    submultimi.insert( make_pair( 5, 20 ) );\n    submultimi.insert( make_pair( 6, 15 ) );\n\n    set&lt; pair&lt; int, int &gt;, setCompareFunctor &gt;::iterator it = lower_bound( submultimi.begin( ), submultimi.end( ), 20, setCompareFunctorAux( ) );\n\n\n    cout &lt;&lt; ( *it ).second &lt;&lt; endl;\n\n\n    return 0;\n}\n</code></pre>\n<p>The expected result is 15, but the real result is 33.</p>\n<p>What is wrong ?</p>\n", "AcceptedAnswerId": "46863625", "Title": "C++ STL set lower_bound wrong result", "CreationDate": "2017-10-21T13:04:17.520", "Id": "46863507", "CommentCount": "4", "LastEditDate": "2017-10-21T13:18:32.103", "PostTypeId": "1", "LastEditorUserId": "2411320", "LastActivityDate": "2017-10-21T14:04:35.660", "Score": "2", "OwnerUserId": "8488496", "Tags": "<c++><algorithm><function><stl><lower-bound>", "AnswerCount": "4"}, "46863973": {"Id": "46863973", "PostTypeId": "2", "Body": "<p>I think you are trying to achieve something different from what <code>std::lower_bound</code> can give to you.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;utility&gt;\n\nusing my_key = std::pair&lt;int, int&gt;;\n\nint main(int argc, char *argv[]) {\n  auto comp = [](const my_key &amp;l, const my_key &amp;r) {\n    return l.second &lt; r.second;\n  };\n  std::set&lt;my_key, decltype(comp)&gt; submultimi(comp);\n\n  submultimi.insert({1, 15});\n  submultimi.insert({2, 9});\n  submultimi.insert({3, 33});\n  submultimi.insert({4, 44});\n  submultimi.insert({5, 20});\n  submultimi.insert({6, 15}); // \"&lt;=\" inside comp will put this pair into the set\n\n  for (const auto &amp;elem : submultimi)\n    std::cout &lt;&lt; elem.first &lt;&lt; \" -&gt; \" &lt;&lt; elem.second &lt;&lt; '\\n';\n\n  auto it = std::lower_bound(\n      submultimi.begin(), submultimi.end(), 20,\n      [](const my_key &amp;l, const int &amp;r) { return l.second &lt; r; });\n\n  std::cout &lt;&lt; it-&gt;second &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>\n<p>outputs</p>\n<pre><code>2 -&gt; 9\n1 -&gt; 15 # note the lack of 6 -&gt; 15 in the set\n5 -&gt; 20\n3 -&gt; 33\n4 -&gt; 44\n20\n</code></pre>\n<p>Everything seems legitimate as per the documentation provided in <a href=\"http://en.cppreference.com/w/\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/</a>.</p>\n<p>I assume you are trying to put <code>6-&gt;15</code> using some trick, and the very same trick breaks <code>std::lower_bound</code> due to the violation of the weak ordering as is already pointed out by the other responders.</p>\n", "LastActivityDate": "2017-10-21T13:53:43.873", "CommentCount": "0", "CreationDate": "2017-10-21T13:53:43.873", "ParentId": "46863507", "Score": "0", "OwnerUserId": "4720025"}});