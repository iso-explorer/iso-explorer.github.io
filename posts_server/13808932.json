post_cb({"13808933": {"ParentId": "13808932", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2012-12-10T20:46:01.270", "Score": "58", "LastEditorUserId": "2756719", "LastEditDate": "2016-01-01T19:36:40.533", "Id": "13808933", "OwnerUserId": "150634", "Body": "<p><sub>I refer to the C++11 standard in this post</sub></p>\n<h1>Declarations</h1>\n<p><strong>Declarations</strong> of the type we're concerned with are known as <i>simple-declaration</i>s in the grammar of C++, which are of one of the following two forms (\u00a77/1):</p>\n<blockquote>\n<p id=\"so_13808932_13808933_0\"><em>decl-specifier-seq<sub>opt</sub></em> <em>init-declarator-list<sub>opt</sub></em> ;<br>\n<em>attribute-specifier-seq</em> <em>decl-specifier-seq<sub>opt</sub></em> <em>init-declarator-list</em> ;</br></p>\n</blockquote>\n<p>The <em>attribute-specifier-seq</em> is a sequence of attributes (<code>[[something]]</code>) and/or alignment specifiers (<code>alignas(something)</code>). Since these don't affect the type of the declaration, we can ignore them and the second of the above two forms.</p>\n<h2>Declaration specifiers</h2>\n<p>So the first part of our declaration, the <em>decl-specifier-seq</em>, is made up of declaration specifiers. These include some things that we can ignore, such as storage specifiers (<code>static</code>, <code>extern</code>, etc.), function specifiers (<code>inline</code>, etc.), the <code>friend</code> specifier, and so on. However, the one declaration specifier of interest to us is the <strong>type specifier</strong>, which may include simple type keywords (<code>char</code>, <code>int</code>, <code>unsigned</code>, etc.), names of user-defined types, cv-qualifiers (<code>const</code> or <code>volatile</code>), and others that we don't care about.</p>\n<p><em>Example</em>: So a simple example of a <em>decl-specifier-seq</em> which is just a sequence of type specifiers is <code>const int</code>. Another one could be <code>unsigned int volatile</code>.</p>\n<p>You may think \"Oh, so something like <code>const volatile int int float const</code> is also a <em>decl-specifier-seq</em>?\" You'd be right that it fits the rules of the grammar, but the semantic rules disallow such a <em>decl-specifier-seq</em>. Only one type specifier is allowed, in fact, except for certain combinations (such as <code>unsigned</code> with <code>int</code> or <code>const</code> with anything except itself) and at least one non-cv-qualifier is required (\u00a77.1.6/2-3).</p>\n<p><strong>Quick Quiz</strong> (you might need to reference the standard)</p>\n<ol>\n<li><p>Is <code>const int const</code> a valid declaration specifier sequence or not? If not, is it disallowed by the syntactic or semantic rules?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_1\"> Invalid by semantic rules! <code>const</code> cannot be combined with itself.</p>\n</blockquote></li>\n<li><p>Is <code>unsigned const int</code> a valid declaration specifier sequence or not? If not, is it disallowed by the syntactic or semantic rules?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_2\"> Valid! It doesn't matter that the <code>const</code> separates the <code>unsigned</code> from <code>int</code>.</p>\n</blockquote></li>\n<li><p>Is <code>auto const</code> a valid declaration specifier sequence or not? If not, is it disallowed by the syntactic or semantic rules?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_3\"> Valid! <code>auto</code> is a declaration specifier but changed category in C++11. Before it was a storage specifier (like <code>static</code>), but now it is a type specifier.</p>\n</blockquote></li>\n<li><p>Is <code>int * const</code> a valid declaration specifier sequence or not? If not, is it disallowed by the syntactic or semantic rules?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_4\"> Invalid by syntactic rules! While this may very well be the full type of a declaration, only the <code>int</code> is the declaration specifier sequence. The declaration specifiers only provides the base type, and not compound modifiers like pointers, references, arrays, etc.</p>\n</blockquote></li>\n</ol>\n<h2>Declarators</h2>\n<p>The second part of a <em>simple-declaration</em> is the <em>init-declarator-list</em>. It is a sequence of <strong>declarators</strong> separated by commas, each with an optional initializer (\u00a78). Each declarator introduces a single variable or function into the program. The most simple form of declarator is just the name you're introducing - the <em>declarator-id</em>. The declaration <code>int x, y = 5;</code> has a declaration specifier sequence that is just <code>int</code>, followed by two declarators, <code>x</code> and <code>y</code>, the second of which has an initializer. We will, however, ignore initializers for the rest of this post. </p>\n<p>A declarator can have a particularly complex syntax because this is the part of the declaration that allows you to specify whether the variable is a pointer, reference, array, function pointer, etc. Note that these are all part of the <em>declarator</em> and not the declaration as a whole. This is precisely the reason why <code>int* x, y;</code> does not declare two pointers - the asterisk <code>*</code> is part of the declarator of <code>x</code> and not part of the declarator of <code>y</code>. One important rule is that every declarator must have exactly one <em>declarator-id</em> - the name it is declaring. The rest of the rules about valid declarators are enforced once the type of the declaration is determined (we'll come to it later).</p>\n<p><em>Example</em>: A simple example of a declarator is <code>*const p</code>, which declares a <code>const</code> pointer to... something. The type it points to is given by the declaration specifiers in its declaration. A more terrifying example is the one given in the question, <code>(*(*(&amp;e)[10])())[5]</code>, which declares a reference to an array of function pointers that return pointers to... again, the final part of the type is actually given by the declaration specifiers.</p>\n<p>You're unlikely to ever come across such horrible declarators but sometimes similar ones do appear. It's a useful skill to be able to read a declaration like the one in the question and is a skill that comes with practice. It is helpful to understand how the standard interprets the type of a declaration.</p>\n<p><strong>Quick Quiz</strong> (you might need to reference the standard)</p>\n<ol>\n<li><p>Which parts of <code>int const unsigned* const array[50];</code> are the declaration specifiers and the declarator?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_5\"> Declaration specifiers: <code>int const unsigned</code><br>\n Declarator: <code>* const array[50]</code></br></p>\n</blockquote></li>\n<li><p>Which parts of <code>volatile char (*fp)(float const), &amp;r = c;</code> are the declaration specifiers and the declarators?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_6\"> Declaration specifiers: <code>volatile char</code><br>\n Declarator #1: <code>(*fp)(float const)</code><br>\n Declarator #2: <code>&amp;r</code></br></br></p>\n</blockquote></li>\n</ol>\n<h1>Declaration Types</h1>\n<p>Now we know that a declaration is made up of a declarator specifier sequence and a list of declarators, we can begin to think about how the type of a declaration is determined. For example, it might be obvious that <code>int* p;</code> defines <code>p</code> to be a \"pointer to int\", but for other types it's not so obvious.</p>\n<p>A declaration with multiple declarators, let's say 2 declarators, is considered to be two declarations of particular identifiers. That is, <code>int x, *y;</code> is a declaration of identifier <code>x</code>, <code>int x</code>, and a declaration of identifier <code>y</code>, <code>int *y</code>.</p>\n<p>Types are expressed in the standard as English-like sentences (such as \"pointer to int\"). The interpretation of a declaration's type in this English-like form is done in two parts. First, the type of the declaration specifier is determined. Second, a recursive procedure is applied to the declaration as a whole.</p>\n<h2>Declaration specifiers type</h2>\n<p>The type of a declaration specifier sequence is determined by Table 10 of the standard. It lists the types of the sequences given that they contain the corresponding specifiers in any order. So for example, any sequence that contains <code>signed</code> and <code>char</code> in any order, including <code>char signed</code>, has type \"signed char\". Any cv-qualifier that appears in the declaration specifier sequence is added to the front of the type. So <code>char const signed</code> has type \"const signed char\". This makes sure that regardless of what order you put the specifiers, the type will be the same.</p>\n<p><strong>Quick Quiz</strong> (you might need to reference the standard)</p>\n<ol>\n<li><p>What is the type of the declaration specifier sequence <code>int long const unsigned</code>?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_7\"> \"const unsigned long int\"</p>\n</blockquote></li>\n<li><p>What is the type of the declaration specifier sequence <code>char volatile</code>?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_8\"> \"volatile char\"</p>\n</blockquote></li>\n<li><p>What is the type of the declaration specifier sequence <code>auto const</code>?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_9\"> It depends! <code>auto</code> will be deduced from the initializer. If it is deduced to be <code>int</code>, for example, the type will  be \"const int\".</p>\n</blockquote></li>\n</ol>\n<h2>Declaration type</h2>\n<p>Now that we have the type of the declaration specifier sequence, we can work out the type of an entire declaration of an identifier. This is done by applying a recursive procedure defined in \u00a78.3. To explain this procedure, I'll use a running example. We'll work out the type of <code>e</code> in <code>float const (*(*(&amp;e)[10])())[5]</code>.</p>\n<p><strong>Step 1</strong> The first step is to split the declaration into the form <code>T D</code> where <code>T</code> is the declaration specifier sequence and <code>D</code> is the declarator. So we get:</p>\n<pre><code>T = float const\nD = (*(*(&amp;e)[10])())[5]\n</code></pre>\n<p>The type of <code>T</code> is, of course, \"const float\", as we determined in the previous section. We then look for the subsection of \u00a78.3 that matches the current form of <code>D</code>. You'll find that this is \u00a78.3.4 Arrays, because it states that it applies to declarations of the form <code>T D</code> where <code>D</code> has the form:</p>\n<blockquote>\n<p id=\"so_13808932_13808933_10\"><code>D1 [</code> <em>constant-expression<sub>opt</sub></em> <code>]</code> <em>attribute-specifier-seq<sub>opt</sub></em></p>\n</blockquote>\n<p>Our <code>D</code> is indeed of that form where <code>D1</code> is <code>(*(*(&amp;e)[10])())</code>.</p>\n<p>Now imagine a declaration <code>T D1</code> (we've gotten rid of the <code>[5]</code>).</p>\n<pre><code>T D1 = const float (*(*(&amp;e)[10])())\n</code></pre>\n<p>It's type is \"&lt;some stuff&gt; <code>T</code>\". This section states that the type of our identifier, <code>e</code>, is \"&lt;some stuff&gt; array of 5 <code>T</code>\", where &lt;some stuff&gt; is the same as in the type of the imaginary declaration. So to work out the remainder of the type, we need to work out the type of <code>T D1</code>.</p>\n<p>This is the recursion! We recursively work out the type of an inner part of the declaration, stripping a bit of it off at every step.</p>\n<p><strong>Step 2</strong> So, as before, we split our new declaration into the form <code>T D</code>:</p>\n<pre><code>T = const float\nD = (*(*(&amp;e)[10])())\n</code></pre>\n<p>This matches paragraph \u00a78.3/6 where <code>D</code> is of the form <code>( D1 )</code>. This case is simple, the type of <code>T D</code> is simply the type of <code>T D1</code>:</p>\n<pre><code>T D1 = const float *(*(&amp;e)[10])()\n</code></pre>\n<p><strong>Step 3</strong> Let's call this <code>T D</code> now and split it up again:</p>\n<pre><code>T = const float\nD = *(*(&amp;e)[10])()\n</code></pre>\n<p>This matches \u00a78.3.1 Pointers where <code>D</code> is of the form <code>* D1</code>. If <code>T D1</code> has type \"&lt;some stuff&gt; <code>T</code>\", then <code>T D</code> has type \"&lt;some stuff&gt; pointer to <code>T</code>\". So now we need the type of <code>T D1</code>:</p>\n<pre><code>T D1 = const float (*(&amp;e)[10])()\n</code></pre>\n<p><strong>Step 4</strong> We call it <code>T D</code> and split it up:</p>\n<pre><code>T = const float\nD = (*(&amp;e)[10])()\n</code></pre>\n<p>This matches \u00a78.3.5 Functions where <code>D</code> is of the form <code>D1 ()</code>. If <code>T D1</code> has type \"&lt;some stuff&gt; <code>T</code>\", then <code>T D</code> has type \"&lt;some stuff&gt; function of () returning <code>T</code>\". So now we need the type of <code>T D1</code>:</p>\n<pre><code>T D1 = const float (*(&amp;e)[10])\n</code></pre>\n<p><strong>Step 5</strong> We can apply the same rule we did for step 2, where the declarator is simply parenthesised to end up with:</p>\n<pre><code>T D1 = const float *(&amp;e)[10]\n</code></pre>\n<p><strong>Step 6</strong> Of course, we split it up:</p>\n<pre><code>T = const float\nD = *(&amp;e)[10]\n</code></pre>\n<p>We match \u00a78.3.1 Pointers again with <code>D</code> of the form <code>* D1</code>. If <code>T D1</code> has type \"&lt;some stuff&gt; <code>T</code>\", then <code>T D</code> has type \"&lt;some stuff&gt; pointer to <code>T</code>\". So now we need the type of <code>T D1</code>:</p>\n<pre><code>T D1 = const float (&amp;e)[10]\n</code></pre>\n<p><strong>Step 7</strong> Split it up:</p>\n<pre><code>T = const float\nD = (&amp;e)[10]\n</code></pre>\n<p>We match \u00a78.3.4 Arrays again, with <code>D</code> of the form <code>D1 [10]</code>. If <code>T D1</code> has type \"&lt;some stuff&gt; <code>T</code>\", then <code>T D</code> has type \"&lt;some stuff&gt; array of 10 <code>T</code>\". So what is <code>T D1</code>'s type?</p>\n<pre><code>T D1 = const float (&amp;e)\n</code></pre>\n<p><strong>Step 8</strong> Apply the parentheses step again:</p>\n<pre><code>T D1 = const float &amp;e\n</code></pre>\n<p><strong>Step 9</strong> Split it up:</p>\n<pre><code>T = const float\nD = &amp;e\n</code></pre>\n<p>Now we match \u00a78.3.2 References where <code>D</code> is of the form <code>&amp; D1</code>. If <code>T D1</code> has type \"&lt;some stuff&gt; <code>T</code>\", then <code>T D</code> has type \"&lt;some stuff&gt; reference to <code>T</code>\". So what is the type of <code>T D1</code>?</p>\n<pre><code>T D1 = const float e\n</code></pre>\n<p><strong>Step 10</strong> Well it's just \"T\" of course! There is no &lt;some stuff&gt; at this level. This is given by the base case rule in \u00a78.3/5.</p>\n<p><strong>And we're done!</strong></p>\n<p>So now if we look at the type we determined at each step, substituting the &lt;some stuff&gt;s from each level below, we can determine the type of <code>e</code> in <code>float const (*(*(&amp;e)[10])())[5]</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>&lt;some stuff&gt; array of 5 T\n\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n&lt;some stuff&gt; pointer to T\n\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n&lt;some stuff&gt; function of () returning T\n|          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n&lt;some stuff&gt; pointer to T\n|          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n&lt;some stuff&gt; array of 10 T\n|          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n&lt;some stuff&gt; reference to T\n|          |\n&lt;some stuff&gt; T\n</code></pre>\n<p>If we combine this all together, what we get is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>reference to array of 10 pointer to function of () returning pointer to array of 5 const float\n</code></pre>\n<p>Nice! So that shows how the compiler deduces the type of a declaration. Remember that this is applied to each declaration of an identifier if there are multiple declarators. Try figuring out these:</p>\n<p><strong>Quick Quiz</strong> (you might need to reference the standard)</p>\n<ol>\n<li><p>What is the type of <code>x</code> in the declaration <code>bool **(*x)[123];</code>?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_11\"> \"pointer to array of 123 pointer to pointer to bool\"</p>\n</blockquote></li>\n<li><p>What are the types of <code>y</code> and <code>z</code> in the declaration <code>int const signed *(*y)(int), &amp;z = i;</code>?</p>\n<blockquote class=\"spoiler\">\n<p id=\"so_13808932_13808933_12\"> <code>y</code> is a \"pointer to function of (int) returning pointer to const signed int\"<br>\n<code>z</code> is a \"reference to const signed int\"</br></p>\n</blockquote></li>\n</ol>\n<p><sub>If anybody has any corrections, please let me know!</sub></p>\n", "LastActivityDate": "2016-01-01T19:36:40.533"}, "13808932": {"CommentCount": "0", "AcceptedAnswerId": "13808933", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-10T20:46:01.270", "LastActivityDate": "2017-04-05T17:47:45.580", "LastEditDate": "2017-05-23T11:46:39.687", "ViewCount": "4106", "FavoriteCount": "32", "Title": "What are declarations and declarators and how are their types interpreted by the standard?", "Id": "13808932", "Score": "36", "Body": "<p>How exactly does the standard define that, for example, <code>float (*(*(&amp;e)[10])())[5]</code> declares a variable of type \"reference to array of 10 pointer to function of () returning pointer to array of 5 <code>float</code>\"?</p>\n<p><sub>Inspired by <a href=\"https://stackoverflow.com/a/13779331/150634\">discussion with @DanNissenbaum</a></sub></p>\n", "Tags": "<c++><types><c++11><standards><declaration>", "OwnerUserId": "150634", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13808932_13808933_11": {"section_id": 11, "quality": 0.6666666666666666, "length": 4}, "so_13808932_13808933_7": {"section_id": 5427, "quality": 1.0, "length": 4}}, "n3337": {"so_13808932_13808933_11": {"section_id": 8, "quality": 0.6666666666666666, "length": 4}, "so_13808932_13808933_7": {"section_id": 5222, "quality": 1.0, "length": 4}}, "n4659": {"so_13808932_13808933_11": {"section_id": 12, "quality": 0.6666666666666666, "length": 4}, "so_13808932_13808933_7": {"section_id": 6855, "quality": 1.0, "length": 4}}}, "43238224": {"ParentId": "13808932", "CommentCount": "0", "CreationDate": "2017-04-05T17:47:45.580", "OwnerUserId": "1473218", "PostTypeId": "2", "Id": "43238224", "Score": "0", "Body": "<p>Here's the way I parse <code>float const (*(*(&amp;e)[10])())[5]</code>. First of all, identify the specifier. Here the specifier is <code>float const</code>. Now, let's look at the precedence. <code>[] = () &gt; *</code>. The parentheses are used to disambiguate the precedence. With precedence in mind, let's identify the variable ID, which is <code>e</code>. So, e is a reference to an array (since <code>[] &gt; *</code>) of 10 pointers to functions (since <code>() &gt; *</code>) which take no argument and return and a pointer to an array of 5 float const. So the specifier comes last and rest are parsed according to the precedence. </p>\n", "LastActivityDate": "2017-04-05T17:47:45.580"}});