post_cb({"bq_ids": {"n4140": {"so_4706677_4707150_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3240}, "so_4706677_4706677_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 601}}, "n3337": {"so_4706677_4707150_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3113}, "so_4706677_4706677_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 591}}, "n4659": {"so_4706677_4707150_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3996}, "so_4706677_4706677_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 627}}}, "4706677": {"ViewCount": "3901", "Body": "<p>Continuing <a href=\"https://stackoverflow.com/q/4691657/20984\">my journey into the world of variadic templates</a>, I encountered another problem.</p>\n<p>Assuming the following template class:</p>\n<pre><code>template &lt; typename T &gt;\nstruct foo \n{\n    //default implementation\n};\n</code></pre>\n<p>it is possible to partially specialize it for variadic template instantiations like this:</p>\n<pre><code>template &lt; template &lt; typename ... &gt; class T, typename ...Args &gt;\nstruct foo&lt; T&lt; Args... &gt; &gt;\n{\n    //specialized implementation\n};\n</code></pre>\n<p>With this, <code>foo&lt; int &gt;</code> will correspond to the default implementation and <code>foo&lt; std::tuple&lt; int, char &gt; &gt;</code> to the specialized implementation.</p>\n<p>However, things become more complicated when using several template parameters. For example, if we have the following template class</p>\n<pre><code>template &lt; typename T, typename U &gt;\nstruct bar {};\n</code></pre>\n<p>and we want to partially specialize it as we did for <code>foo</code>, we cannot do</p>\n<pre><code>template &lt; template &lt; typename ... &gt; class T, typename ...TArgs,\n           template &lt; typename ... &gt; class U, typename ...UArgs &gt;\nstruct bar&lt; T&lt; TArgs... &gt;, U&lt; UArgs... &gt; &gt; {};\n\n//This would correspond to the specialized version with\n//T=std::tuple,\n//TArgs=int,char\n//U=std::tuple,\n//UArgs=float\nbar&lt; std::tuple&lt; int, char &gt;, std::tuple&lt; float &gt; &gt; b;\n</code></pre>\n<p>Indeed, if I am correct, we can only have one template parameter pack and it must be positioned at the end of the parameter list. I understand why this is mandatory in template declarations, but for certain partial template specialization (like the example above), this should not be an issue.</p>\n<p>Is it possible to achieve partial template specialization with multiple template parameter packs?</p>\n<hr>\n<p><strong>Edit</strong>: Now I feel silly...the code I gave above compiles perfectly (at least with gcc 4.5). The compile error I had was not because of multiple parameter packs, but because of their use as member functions parameters. In the partial specialization of <code>bar</code>, I tried to define a member function that takes both <code>TArgs</code> and <code>UArgs</code> parameters:</p>\n<pre><code>template &lt; template &lt; typename ... &gt; class T, typename ...TArgs, \n           template &lt; typename ... &gt; class U, typename ...UArgs &gt;\nstruct bar&lt; T&lt; TArgs... &gt;, U&lt; UArgs... &gt; &gt;\n{\n    void method( TArgs... targs, UArgs... uargs ) //compile error here\n    {\n    }\n};\n</code></pre>\n<p>On the member function declaration, gcc gives me the error </p>\n<blockquote>\n<p id=\"so_4706677_4706677_0\">parameters packs must be at the end of the parameter list.</p>\n</blockquote>\n<p>As far as I can tell, the compiler should be able to define the correct member function for a given template instantiation, e.g. <code>bar&lt; std::tuple&lt; int, char &gt;, std::tuple&lt; float &gt; &gt;</code> should contain a member function <code>void method( int, char, float )</code>. Am I doing something wrong? Or am I trying to do something that is not possible? If so, is there a good reason why this is not possible?</p>\n</hr>", "AcceptedAnswerId": "4707150", "Title": "Partial template specialization with multiple template parameter packs", "CreationDate": "2011-01-16T16:53:44.670", "Id": "4706677", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:51:41.787", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-21T23:56:39.983", "Score": "15", "OwnerUserId": "20984", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "1"}, "4707150": {"Id": "4707150", "PostTypeId": "2", "Body": "<p>Probably this answer won't clear your question directly,\nbut the following code compiled on ideone(gcc-4.5.1) when I tested.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt; class, class &gt; struct S {\n  S() { puts(\"primary\"); }\n};\n\ntemplate&lt;\n  template&lt; class... &gt; class T, class...TArgs\n, template&lt; class... &gt; class U, class...UArgs\n&gt;\nstruct S&lt; T&lt; TArgs... &gt;, U&lt; UArgs... &gt; &gt; {\n  S() { puts(\"specialized\"); }\n};\n\nint main()\n{\n  S&lt; int, int &gt;  p;                                       // \"primary\"\n  S&lt; std::tuple&lt; int, char &gt;, std::tuple&lt; float &gt; &gt;  s;   // \"specialised\"\n}\n</code></pre>\n<p>I'm not sure this code is strictly conformant, but\nas far as I read N3225 14.5.3, I couldn't find the statement which mentions\nthat template parameter pack has to be the last template parameter.</p>\n<p>Edit:<br>\nI reread N3225 and found the following statements:</br></p>\n<blockquote>\n<p id=\"so_4706677_4707150_0\">8.3.5/4 If the parameter-declaration-clause\n  terminates with an ellipsis or a\n  function parameter pack (14.5.3), the\n  number of arguments shall be equal to\n  or greater than the number of\n  parameters that do not have a default\n  argument and are not function\n  parameter packs.</p>\n<p id=\"so_4706677_4707150_1\">14.8.2.5/10 [Note: A function parameter pack can only occur at the\n  end of a\n  parameter-declarationlist(8.3.5). -end\n  note]</p>\n</blockquote>\n<p>So, as you mentioned, function parameter pack has to be the last parameter\nunfortunately.<br>\nA non-template member function of a class template is an ordinary function\nfor that class when it is instantiated(fully specialized).\nSo I wish that the code in this question can be compiled logically, as a\nspecial case.</br></p>\n", "LastEditorUserId": "24874", "LastActivityDate": "2014-10-21T23:56:39.983", "Score": "6", "CreationDate": "2011-01-16T18:21:12.557", "ParentId": "4706677", "CommentCount": "5", "LastEditDate": "2014-10-21T23:56:39.983", "OwnerUserId": "547710"}});