post_cb({"21097439": {"ParentId": "21096908", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The answer to your very first question is that yes, prior to C++11 some types (such as local types) are NOT allowed as template parameters. See 14.3.1/2:</p>\n<blockquote>\n<p id=\"so_21096908_21097439_0\">A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types shall not be used as a\n  template argument for a template type parameter.</p>\n</blockquote>\n<p>Since <code>remove_if</code> is a template, you cannot use the local predicate as its parameter.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2014-01-14T15:51:37.527", "Id": "21097439", "Score": "3", "CreationDate": "2014-01-13T17:20:40.943", "LastActivityDate": "2014-01-14T15:51:37.527"}, "21096908": {"CommentCount": "1", "ViewCount": "717", "CreationDate": "2014-01-13T16:55:18.710", "LastActivityDate": "2014-01-14T15:51:37.527", "Title": "no matching function for call to std::list::remove_if( function()::predicate )", "AcceptedAnswerId": "21097439", "PostTypeId": "1", "Id": "21096908", "Score": "1", "Body": "<p>So, defining a predicate inside a function and use as <code>std::list::remove_if</code> argument is not allowed?</p>\n<hr>\n<p>Consider the following code, which fails to compile:</p>\n<pre><code>struct a { };\n\nint main()\n{\n    struct pred { bool operator()( const a&amp; ) { return false; }  };\n\n    std::list&lt; a &gt; l; // fill l\n    l.remove_if( pred() );\n\n    return 0;\n}\n\nerror: no matching function for call to \n    \u2018std::list&lt;a, std::allocator&lt;a&gt; &gt;::remove_if(main()::pred)\u2019\n</code></pre>\n<hr>\n<p>Now, if I replace <code>l.remove_if( pred() );</code> with</p>\n<pre><code>pred()( *l.begin() );\n// or\npred p;\np( *l.begin() );\n</code></pre>\n<p>which <code>remove_if</code> does internally, it compiles and works as expected.</p>\n<p>And even more: if I move <code>struct pred</code> to be defined <em>outside</em> main, both tests work as expected.</p>\n<hr>\n<p>This doesn't make <em>any</em> sense to me.</p>\n<p>I thought that it could be something with dependent names and ADL and things like this, but... the argument of <code>remove_if</code> is an <strong>instance, not a type</strong>. It's true, that this is a template function and the argument's type is still resolved, but..</p>\n<p>Can somebody explain what and why happens?</p>\n</hr></hr></hr>", "Tags": "<c++><predicate><stdlist><argument-dependent-lookup>", "OwnerUserId": "435800", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21096908_21097439_0": {"section_id": 3487, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_21096908_21097439_0": {"section_id": 3352, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_21096908_21097439_0": {"section_id": 4250, "quality": 0.6428571428571429, "length": 9}}}});