post_cb({"bq_ids": {"n4140": {"so_44296002_44296079_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 6183}, "so_44296002_44296079_5": {"length": 18, "quality": 0.782608695652174, "section_id": 6183}}, "n3337": {"so_44296002_44296079_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 5944}, "so_44296002_44296079_5": {"length": 18, "quality": 0.782608695652174, "section_id": 5944}}, "n4659": {"so_44296002_44296079_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 7685}, "so_44296002_44296079_5": {"length": 18, "quality": 0.782608695652174, "section_id": 7685}}}, "44296002": {"ViewCount": "1531", "Body": "<p>I found the following interesting code today:</p>\n<pre><code>SomeFunction(some_bool_variable ? 12.f, 50.f : 50.f, 12.f)\n</code></pre>\n<p>I created a small sample to reproduce the behavior:</p>\n<pre><code>class Vector3f\n{\npublic:\n    Vector3f(float val)\n    {\n        std::cout &lt;&lt; \"vector constructor: \" &lt;&lt; val &lt;&lt; '\\n';\n    }\n};\n\nvoid SetSize(Vector3f v)\n{\n    std::cout &lt;&lt; \"SetSize single param\\n\";\n}\n\nvoid SetSize(float w, float h, float d=0)\n{\n    std::cout &lt;&lt; \"SetSize multi param: \" &lt;&lt; w &lt;&lt; \", \" &lt;&lt; h &lt;&lt; \", \" &lt;&lt; d &lt;&lt; '\\n';\n}\n\nint main()\n{\n    SetSize(true ? 12.f, 50.f : 50.f, 12.f);\n    SetSize(false ? 12.f, 50.f : 50.f, 12.f);\n}\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/6c2286c8ea8f996f\" rel=\"noreferrer\">Live Sample</a>)</p>\n<p>The result I get from running the above code is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>clang++ -std=c++14 -O2 -Wall -pedantic -lboost_system -lboost_filesystem -pthread main.cpp &amp;&amp; ./a.out\nmain.cpp:29:20: warning: expression result unused [-Wunused-value]\n    SetSize(true ? 12.f, 50.f : 50.f, 12.f);\n                   ^~~~\nmain.cpp:30:21: warning: expression result unused [-Wunused-value]\n    SetSize(false ? 12.f, 50.f : 50.f, 12.f);\n                    ^~~~\n2 warnings generated.\nSetSize multi param: 50, 12, 0\nSetSize multi param: 50, 12, 0\n</code></pre>\n<p>What I was expecting in <em>both</em> cases was that a single parameter would be passed to <code>SetSize(float)</code>. However, two parameters are passed which I find extremely confusing (especially since ternary has precedence over comma; so I assumed the comma was not delimiting function arguments in this case). For example, if using <code>true</code>, the ternary should result in <code>12.f, 50.f</code>. In this expression, the value to the left of the comma gets dropped/ignored, so I'd expect the end result to be:</p>\n<pre><code>SetSize(50.f);\n</code></pre>\n<p>The second part of the confusion is that whether we use <code>true</code> or <code>false</code> in the ternary, the same 2 values are passed to the function. The <code>true</code> case should be <code>h=12, w=50</code> I'd think...</p>\n<p>I see the compiler is trying to warn me about something, but I can't quite understand what's going on. Can someone decompose this logic and explain the result in a step by step fashion?</p>\n", "AcceptedAnswerId": "44296079", "Title": "Confusion with commas in ternary expression", "CreationDate": "2017-05-31T23:05:49.613", "Id": "44296002", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-06-14T19:14:48.043", "LastEditorUserId": "1687119", "LastActivityDate": "2017-08-16T23:59:16.700", "Score": "34", "OwnerUserId": "157971", "Tags": "<c++>", "AnswerCount": "3"}, "44296108": {"Id": "44296108", "PostTypeId": "2", "Body": "<p>The compiler is warning you that you're throwing away precisely 50% of your floating-point literals.</p>\n<p>Let's decompose it.</p>\n<pre><code>// void SetSize(float w, float h, float d=0)\nSetSize(true ? 12.f, 50.f : 50.f, 12.f);\n//      ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^\n</code></pre>\n<p>Here we present an expression using the <em>conditional operator</em> as the first argument, and the literal <code>12.f</code> as the second argument; the third argument is left at its default (<code>0</code>).</p>\n<p>Yes, really.</p>\n<p>It's parsed like this (because there's no other valid way to parse it):</p>\n<pre><code>SetSize( (true ? 12.f, 50.f : 50.f), 12.f);\n//        ^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^\n</code></pre>\n<p>The value of the second argument is straightforward, so let's examine the first:</p>\n<pre><code>true ? 12.f, 50.f : 50.f\n</code></pre>\n<p>This means:</p>\n<ul>\n<li>If true, the result is <code>12.f, 50.f</code></li>\n<li>Otherwise, the result is <code>50.f</code></li>\n</ul>\n<p>Well, true is always true, so we can immediately discount the second option.</p>\n<p>And the expression <code>12.f, 50.f</code> utilises the <em>comma operator</em>, which evaluates both operands then chucks away the first and results in the second, i.e. <code>50.f</code>.</p>\n<p>Therefore, the whole thing is actually:</p>\n<pre><code>SetSize(50.f, 12.f);\n</code></pre>\n<p>If this is not some arcane and pointless programming \"puzzle\", it's a remarkably stupid piece of code, with an uneducated programmer hoping to \"unpack\" the expression into something more equivalent to:</p>\n<pre><code>SetSize(\n   (true ? 12.f : 50.f),\n   (true ? 50.f : 12.f)\n);\n</code></pre>\n<p>\u2026 which is <em>still</em> terrible and useless code, because true is still always true.</p>\n<p>(Obviously, the values are different in the case that <code>false</code> is written instead, but the same logic applies.)</p>\n<hr>\n<blockquote>\n<p id=\"so_44296002_44296108_0\">The true case should be h=12, w=50 I'd think...</p>\n</blockquote>\n<p>It is. That's what the output you posted says. It's clearer when you don't arbitrarily re-arrange the arguments, i.e. they're w=50 h=12.</p>\n</hr>", "LastActivityDate": "2017-05-31T23:15:39.783", "CommentCount": "0", "CreationDate": "2017-05-31T23:15:39.783", "ParentId": "44296002", "Score": "10", "OwnerUserId": "560648"}, "44296100": {"Id": "44296100", "PostTypeId": "2", "Body": "<p>This is because <a href=\"http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator\" rel=\"noreferrer\">C++ does not treat the second comma as a comma operator</a>:</p>\n<blockquote>\n<p id=\"so_44296002_44296100_0\">The comma in various comma-separated lists, such as function argument lists <code>f(a, b, c)</code> and initializer lists <code>int a[] = {1,2,3}</code>, is not the comma operator.</p>\n</blockquote>\n<p>As far as the first comma is concerned, C++ has no other option but to treat it as a comma operator. Otherwise, the parse would be invalid.</p>\n<p>One simple way of viewing it is to think that as soon as C++ parser finds <code>?</code> in context where comma separators are allowed, it looks for the matching <code>:</code> to complete the first part of the expression, and then matches as little as is necessary to complete the second expression. The second comma would not be treated as an operator even if you remove the two-argument overload.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2017-05-31T23:25:50.053", "Score": "17", "CreationDate": "2017-05-31T23:14:57.093", "ParentId": "44296002", "CommentCount": "0", "OwnerUserId": "335858", "LastEditDate": "2017-05-31T23:25:50.053"}, "44296079": {"Id": "44296079", "PostTypeId": "2", "Body": "<p>While the second part of the ternary operator is self contained, the third part is not.   The grammar is as follows:</p>\n<blockquote>\n<p id=\"so_44296002_44296079_0\"><em>conditional-expression</em>:</p>\n<blockquote>\n<p id=\"so_44296002_44296079_3\"><em>logical-or-expression</em></p>\n<p id=\"so_44296002_44296079_4\"><em>logical-or-expression ? expression : assignment-expression</em></p>\n</blockquote>\n</blockquote>\n<p>So your function call is effectively this:</p>\n<pre><code>SetSize((true ? (12.f, 50.f): 50.f), 12.f)\n</code></pre>\n<p>So the ternary expression <code>true ? (12.f, 50.f): 50.f</code> gets evaluated as the first parameter to the function. Then <code>12.f</code> is passed as the second value.  The comma in this case is <em>not</em> the comma operator but the function parameter separator.</p>\n<p>From section 5.18 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">C++ standard</a>:</p>\n<blockquote>\n<p id=\"so_44296002_44296079_5\"><em>2</em> In contexts where comma is given a special meaning, [\n  <em>Example:</em> in lists of arguments to functions (5.2.2) and lists of initializers (8.5) \u2014 <em>end example</em> ] the comma operator as described\n  in Clause 5 can appear only in parentheses. [\n  <em>Example:</em></p>\n<pre><code>f(a, (t=3, t+2), c);\n</code></pre>\n<p id=\"so_44296002_44296079_6\">has three arguments, the second of which has the value 5 . \u2014 <em>end\n  example</em> ]</p>\n</blockquote>\n<p>If you want the last two subexpressions to be grouped together, you need to add parenthesis:</p>\n<pre><code>SetSize(true ? 12.f, 50.f : (50.f, 12.f));\nSetSize(false ? 12.f, 50.f : (50.f, 12.f));\n</code></pre>\n<p>Now you have a comma operator and the single argument version of <code>SetSize</code> gets called.</p>\n", "LastEditorUserId": "1687119", "LastActivityDate": "2017-06-01T15:47:24.550", "Score": "30", "CreationDate": "2017-05-31T23:13:05.077", "ParentId": "44296002", "CommentCount": "0", "OwnerUserId": "1687119", "LastEditDate": "2017-06-01T15:47:24.550"}});