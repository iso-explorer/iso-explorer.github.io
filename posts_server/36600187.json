post_cb({"36601200": {"ParentId": "36600187", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Member initialization</h2>\n<p>In both cases we are talking about <a href=\"http://en.cppreference.com/w/cpp/language/data_members#Member_initialization\" rel=\"nofollow noreferrer\">member initialization</a>. \nKeep in mind that the members are initialized in the <a href=\"https://stackoverflow.com/questions/12222417/why-should-i-initialize-member-variables-in-the-order-theyre-declared-in\">sequence in which they are declared</a> in the class. </p>\n<h2>Code 2: Member initializer list</h2>\n<p>In the second version:</p>\n<pre><code>Test() : count(10) {\n</code></pre>\n<p><code>: count(10)</code>  is a constructor initializer (<a href=\"http://en.cppreference.com/w/cpp/language/function#Function_definition\" rel=\"nofollow noreferrer\">ctor-initializer</a>) and <code>count(10)</code> is a <strong>member initializer</strong> as part of the member initializer list. I like to think of this as the 'real' or primary way that the initialization happens, but it does not determine the sequence of initialization.</p>\n<h2>Code 1: Default member initializer</h2>\n<p>In the first version:</p>\n<pre><code>private:\n    int count=10;\n</code></pre>\n<p><code>count</code> has a <em>default member intitializer</em>. It is the fallback option. It will be used as a <strong>member initializer</strong> if none is present in the constructor, but in the class the sequence of members for initialization is determined.</p>\n<p>From section <strong>12.6.2 Initializing bases and members, item 10</strong> of the standard:</p>\n<blockquote>\n<p id=\"so_36600187_36601200_0\">If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n<pre><code>struct A {\nint i = / some integer expression with side effects / ;\nA(int arg) : i(arg) { }\n// ...\n};\n</code></pre>\n<p id=\"so_36600187_36601200_1\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-or-equalinitializer will not take\n  place. \u2014end example ]</p>\n</blockquote>\n<p>Something else to keep in mind would be that if you introduce a non-static data member initializer then a struct will no longer be considered an aggregate in C++11, but this has been <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html\" rel=\"nofollow noreferrer\">updated for C++14</a>.</p>\n<hr>\n<h2>Differences</h2>\n<blockquote>\n<p id=\"so_36600187_36601200_2\">what's the differences of using one form rather than the other (if\n  any).</p>\n</blockquote>\n<ul>\n<li>The difference is the priority given to the two options. A constructor initializer, directly specified, has precedence. In both cases we end up with a member initializer via different paths. </li>\n<li>It is best to use the default member initializer because \n\n<ul>\n<li>then the compiler can use that information to generate the constructor's initializer list for you and it might be able to optimize.</li>\n<li>You can see all the defaults in one place and in sequence.</li>\n<li>It reduces duplication. You could then only put the exceptions in the manually specified member initializer list.</li>\n</ul></li>\n</ul>\n</hr>", "OwnerUserId": "1460794", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:21.533", "Id": "36601200", "Score": "2", "CreationDate": "2016-04-13T14:16:27.520", "LastActivityDate": "2016-04-13T14:33:46.587"}, "36601355": {"ParentId": "36600187", "CommentCount": "0", "Body": "<p>In the C++ Core Guidelines (see note 1 below), <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-in-class-initializer\" rel=\"noreferrer\">Guideline C.48</a> recommends the first approach (in-class initializers.) The reasoning provided is:</p>\n<blockquote>\n<p id=\"so_36600187_36601355_0\">Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.</p>\n</blockquote>\n<p>In fact if your constructor does nothing but initialize member variables, as in your question, then <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-default\" rel=\"noreferrer\">Guideline C.45</a> is firmer still, saying to use in-class initializers for sure. It explains that</p>\n<blockquote>\n<p id=\"so_36600187_36601355_1\">Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.</p>\n</blockquote>\n<p>I am not going to argue with Stroustrup, Sutter, and several hundred of their friends and colleagues even if I haven't written a compiler so I can't prove it's more efficient. Use in-class initializers wherever you can.</p>\n<ol>\n<li>If you're not familiar with the guidelines do follow the links to see sample code and more explanations. </li>\n</ol>\n", "OwnerUserId": "203458", "PostTypeId": "2", "Id": "36601355", "Score": "5", "CreationDate": "2016-04-13T14:21:42.023", "LastActivityDate": "2016-04-13T14:21:42.023"}, "36600323": {"ParentId": "36600187", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>When you initialise next to the declaration of the member, this is valid only in C++11 onwards, so if you're in C++98/03 you outright cannot do this.</p>\n<p>If the value never changes, you could choose to make this a <code>constexpr static</code> instead and the compiler would then be required to not use any extra storage for the value (so long as you don't define it) and instant use constant propagation wherever the value is used instead.</p>\n<p>One disadvantage of using the by-declaration syntax is that it must be in the header, which will result in a recompile of all translation units that include the header every time you want to change its value. If this takes a long time, that might be unacceptable.</p>\n<p>Another difference is that using the member initialisation list lets you change the value for each constructor, whilst using the by-declaration version only allows you to specify one value for all constructors (although you could overwrite this value ... but I'd personally avoid this as it could get quite confusing!).</p>\n<hr>\n<p>As an aside, there's no need to use <code>new</code> here to create an instance of <code>Test</code>. This is a common mistake when people come to the language from other languages and I wanted to make you aware. There are of course many uses for doing this outside of your example.</p>\n</hr>", "OwnerUserId": "1816262", "LastEditorUserId": "1816262", "LastEditDate": "2016-04-13T14:11:57.110", "Id": "36600323", "Score": "1", "CreationDate": "2016-04-13T13:43:32.780", "LastActivityDate": "2016-04-13T14:11:57.110"}, "36600755": {"ParentId": "36600187", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The difference I can think of is that <a href=\"http://en.cppreference.com/w/cpp/language/initializer_list\" rel=\"nofollow\">member initializer list</a> is prior to <a href=\"http://en.cppreference.com/w/cpp/language/data_members#Member_initialization\" rel=\"nofollow\">default member initializer</a>.</p>\n<blockquote>\n<p id=\"so_36600187_36600755_0\">Through a default member initializer, which is simply a brace or\n  equals initializer included in the member declaration, which is used\n  if the member is omitted in the member initializer list.</p>\n<p id=\"so_36600187_36600755_1\">If a member has a default member initializer and also appears in the\n  member initialization list in a constructor, the default member\n  initializer is ignored.</p>\n</blockquote>\n<p>For example:</p>\n<pre><code>class Test \n{\npublic:\n    Test() {}  // count will be 10 since it's omitted in the member initializer list\n    Test(int c) : count(c) {} // count's value will be c, the default member initializer is ignored. \nprivate:\n    int count = 10;\n};\n</code></pre>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-04-13T14:19:08.163", "Id": "36600755", "Score": "4", "CreationDate": "2016-04-13T13:59:47.547", "LastActivityDate": "2016-04-13T14:19:08.163"}, "36600519": {"ParentId": "36600187", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There is no difference in the code. The difference would come if you would be would have more than one constructor overload and in more than one count would be 10. With the first version you would have less writing to do.</p>\n<pre><code>class Test \n{\npublic:\n    Test() = default;\n    Test(int b) : b(b) {} // a = 1, c = 3\n\n    ~Test();\n\nprivate:\n    int a = 1;\n    int b = 2;\n    int c = 3;\n};\n</code></pre>\n<p>As opposed to the second version where the above code would look like this:</p>\n<pre><code>class Test \n{\npublic:\n    Test() : a(1), b(2), c(3) {}\n    Test(int b) : a(1), b(b), c(3) {}\n\n    ~Test();\n\nprivate:\n    int a;\n    int b;\n    int c;\n};\n</code></pre>\n<p>The difference gets bigger with more member variables.</p>\n", "OwnerUserId": "1771055", "LastEditorUserId": "1771055", "LastEditDate": "2016-04-13T14:01:58.623", "Id": "36600519", "Score": "2", "CreationDate": "2016-04-13T13:50:51.923", "LastActivityDate": "2016-04-13T14:01:58.623"}, "36600187": {"CommentCount": "11", "ViewCount": "567", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2016-04-13T13:38:07.217", "LastActivityDate": "2016-04-13T14:33:46.587", "Title": "What's the differences between member initializer list and default member initializer on non-static data member?", "AcceptedAnswerId": "36601200", "LastEditDate": "2016-04-13T14:11:15.430", "Id": "36600187", "Score": "5", "Body": "<p>I'd like to understand what's the differences of using one form rather than the other (if any).</p>\n<p><a href=\"http://cpp.sh/82bq\" rel=\"nofollow\">Code 1</a> (init directly on variables):</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Test \n{\npublic:\n    Test() {\n        cout&lt;&lt; count;\n    }\n\n    ~Test();\n\nprivate:\n    int count=10;\n};\n\nint main()\n{\n    Test* test = new Test();\n}\n</code></pre>\n<p><a href=\"http://cpp.sh/4cke\" rel=\"nofollow\">Code 2</a> (init with initialization list on constructor):</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Test \n{\npublic:\n    Test() : count(10) {\n        cout&lt;&lt; count;\n    }\n\n    ~Test();\n\nprivate:\n    int count;\n};\n\nint main()\n{\n    Test* test = new Test();\n}\n</code></pre>\n<p>Is there any difference in the semantics, or it is just syntactic?</p>\n", "Tags": "<c++><class><variables><init>", "OwnerUserId": "365251", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_36600187_36601200_1": {"section_id": 436, "quality": 0.8666666666666667, "length": 13}, "so_36600187_36601200_0": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_36600187_36601200_1": {"section_id": 428, "quality": 0.8666666666666667, "length": 13}, "so_36600187_36601200_0": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_36600187_36601200_1": {"section_id": 455, "quality": 0.8, "length": 12}, "so_36600187_36601200_0": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}, "so_36600187_36600755_1": {"section_id": 382, "quality": 0.6428571428571429, "length": 9}}}});