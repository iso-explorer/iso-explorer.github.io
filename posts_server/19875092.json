post_cb({"19875092": {"CommentCount": "5", "ViewCount": "179", "PostTypeId": "1", "LastEditorUserId": "1137388", "CreationDate": "2013-11-09T10:52:38.297", "LastActivityDate": "2013-11-11T14:28:02.207", "Title": "What happens if we use \"decltype(auto) f()\" as a function declaration with \"decltype(f()) result\" in the definition?", "AcceptedAnswerId": "19908754", "LastEditDate": "2013-11-09T10:56:17.330", "Id": "19875092", "Score": "1", "Body": "<p>This is really a C++14 question.  And it's more theoretical than practical.</p>\n<p>Sometimes you build a function's result in piecemeal:</p>\n<pre><code>int f( int x, int y )\n{\n    int  a;\n    //...\n    return a;\n}\n</code></pre>\n<p>but if you change the return type, you have to change the type of \"a\" too.  I get around this with a special declaration:</p>\n<pre><code>int f( int x, int y )\n{\n    decltype( f(x,y) )  a;\n    //...\n    return a;\n}\n</code></pre>\n<p>(For the newbies: what is the pitfall if a function parameter uses an r-value reference?  Hint: we need <code>std::forward</code> to fix it.)  A question randomly popped into my head: what if I use the new C++14 feature of \"<code>decltype( auto )</code>\" as the return type?!  Will we get a recursive black hole?  Or an error that it's not allowed?  Would adding an initializer to \"a\" make everything all-right?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1010226", "AnswerCount": "1"}, "19908754": {"ParentId": "19875092", "CommentCount": "0", "CreationDate": "2013-11-11T14:28:02.207", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "19908754", "Score": "2", "Body": "<blockquote>\n<p id=\"so_19875092_19908754_0\">A question randomly popped into my head: what if I use the new C++14\n  feature of \"decltype( auto )\" as the return type?!</p>\n</blockquote>\n<p>The example the OP is referring to is:</p>\n<pre><code>auto f( int x, int y ) // using C++1y's return type deduction\n{\n    decltype( f(x,y) )  a;\n    //...\n    return a;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_19875092_19908754_1\">Will we get a recursive black hole? Or an error that it's not allowed?</p>\n</blockquote>\n<p>It's not allowed [dcl.spec.auto]/11:</p>\n<blockquote>\n<p id=\"so_19875092_19908754_2\">If the type of an entity with an undeduced placeholder type is needed\n  to determine the type of an expression, the program is ill-formed.\n  Once a return statement has been seen in a function, however, the\n  return type deduced from that statement can be used in the rest of the\n  function, including in other return statements.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_19875092_19908754_3\">Would adding an initializer to <code>a</code> make everything all-right?</p>\n</blockquote>\n<p>Ex.</p>\n<pre><code>decltype( f(x,y) )  a = 42;\n</code></pre>\n<p>No; the use of <code>decltype</code> requires determining the return type of <code>f</code>. However, the following is possible:</p>\n<pre><code>auto a = 42;\n</code></pre>\n<p>From a comment:</p>\n<blockquote>\n<p id=\"so_19875092_19908754_4\">so I could have a quick-and-dirty <code>if</code> &amp; <code>return</code> block at the beginning of the function, then use the <code>decltype(f(X))</code> construct afterwards (for the rest of the function)?</p>\n</blockquote>\n<p>Yes, e.g.</p>\n<pre><code>auto f( int x, int y ) // using C++1y's return type deduction\n{\n    if(false) return int();\n\n    decltype( f(x,y) )  a;\n    //...\n    return a;\n}\n</code></pre>\n<p>However, I'd prefer either:</p>\n<pre><code>auto f( int x, int y ) // using C++1y's return type deduction\n{\n    int a; // specifying the return type of `f` here\n    //...\n    return a;\n}\n</code></pre>\n<p>or</p>\n<pre><code>auto f( int x, int y ) // using C++1y's return type deduction\n{\n    auto a = 42; // specifying the return type of `f` via the initializer\n    //...\n    return a;\n}\n</code></pre>\n</hr>", "LastActivityDate": "2013-11-11T14:28:02.207"}, "bq_ids": {"n4140": {"so_19875092_19908754_2": {"section_id": 5455, "quality": 1.0, "length": 28}}, "n4659": {"so_19875092_19908754_2": {"section_id": 6881, "quality": 1.0, "length": 28}}}});