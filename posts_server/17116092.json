post_cb({"17118324": {"ParentId": "17116092", "LastEditDate": "2013-06-15T20:17:48.737", "CommentCount": "2", "CreationDate": "2013-06-14T22:43:03.530", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "17118324", "Score": "2", "Body": "<p>I think GCC is right, and your technique is correct. Basically, since the type argument for <code>C</code> is specified explicitly, the question is whether:</p>\n<p>a. substitution of <code>C</code> everywhere else in the function template signature happens first, and then type deduction is performed (which should result in a substitution failure); or</p>\n<p>b. type deduction is performed first, and then substitution is performed (which would not result in a substitution failure, because the corresponding argument pack would be empty, and so there would be no substitution to perform).</p>\n<p>It seems GCC assumes (1), while Clang assumes (2). Paragraph 14.8.2/2 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_0\">When an explicit template argument list is specified, the template arguments must be compatible with the\n  template parameter list and must result in a valid function type as described below; otherwise type deduction\n  fails. Specifically, <strong>the following steps are performed</strong> when evaluating an explicitly specified template\n  argument list with respect to a given function template:</p>\n<p id=\"so_17116092_17118324_1\">\u2014 The specified template arguments must match the template parameters in kind (i.e., type, non-type,\n  template). There must not be more arguments than there are parameters unless at least one parameter\n  is a template parameter pack, and there shall be an argument for each non-pack parameter. Otherwise,\n  type deduction fails.</p>\n<p id=\"so_17116092_17118324_2\">\u2014 Non-type arguments must match the types of the corresponding non-type template parameters, or must\n  be convertible to the types of the corresponding non-type parameters as specified in 14.3.2, otherwise\n  type deduction fails.</p>\n<p id=\"so_17116092_17118324_3\">\u2014 <strong>The specified template argument values are substituted for the corresponding template parameters as\n  specified below</strong>.</p>\n</blockquote>\n<p>The following paragraph then says:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_4\">After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed. [...]</p>\n</blockquote>\n<p>Moreover, paragraph 14.8.2/5 specifies:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_5\">The resulting substituted and adjusted function type <strong>is used as the type of the function template for template\n  argument deduction</strong>. [...]</p>\n</blockquote>\n<p>Finally, paragraph 14.8.2/6 goes as follows:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_6\">At certain points in the template argument deduction process it is necessary to take a function type that\n  makes use of template parameters and replace those template parameters with the corresponding template\n  arguments. <strong>This is done at the beginning of template argument deduction when any explicitly specified template\n  arguments are substituted into the function type</strong>, and again at the end of template argument deduction\n  when any template arguments that were deduced or obtained from default arguments are substituted.</p>\n</blockquote>\n<p>This all seems to imply that first substitution is performed, then template argument deduction. Hence, a substitution failure should occur in either case and one of the two templates should be discarded from the overload set.</p>\n<p>Unfortunately, there does not seem to be a clear specification as to what the behavior should be when templates arguments are deduced rather than being explicitly specified.</p>\n", "LastActivityDate": "2013-06-15T20:17:48.737"}, "17116092": {"CommentCount": "0", "CreationDate": "2013-06-14T19:41:20.133", "PostTypeId": "1", "AcceptedAnswerId": "17118324", "LastEditorUserId": "1774667", "LastActivityDate": "2013-06-15T20:17:48.737", "LastEditDate": "2013-06-14T19:55:14.210", "ViewCount": "242", "FavoriteCount": "3", "Title": "Empty variardic packs of enums -- do they make two functions different?", "Id": "17116092", "Score": "8", "Body": "<p>There is a technique I sometimes use when overriding <code>template</code> functions that goes like this:</p>\n<pre><code>#include &lt;utility&gt;\ntemplate&lt;int&gt; struct unique_enum { enum class type {}; };\ntemplate&lt;int index&gt; using UniqueEnum = typename unique_enum&lt;index&gt;::type;\ntemplate&lt;bool b, int index=1&gt;\nusing EnableFuncIf = typename std::enable_if&lt; b, UniqueEnum&lt;index&gt; &gt;::type;\ntemplate&lt;bool b, int index=1&gt;\nusing DisableFuncIf = EnableFuncIf&lt;!b, -index&gt;;\n\n// boring traits class:\ntemplate&lt;typename T&gt;\nstruct is_int : std::false_type {};\ntemplate&lt;&gt;\nstruct is_int&lt;int&gt; : std::true_type {};\n\n#include &lt;iostream&gt;\n// use empty variardic packs to give these two SFINAE functions different signatures:\ntemplate&lt;typename C, EnableFuncIf&lt; is_int&lt;C&gt;::value &gt;...&gt;\nvoid do_stuff() {\n  std::cout &lt;&lt; \"int!\\n\";\n}\ntemplate&lt;typename C, DisableFuncIf&lt; is_int&lt;C&gt;::value &gt;...&gt;\nvoid do_stuff() {\n  std::cout &lt;&lt; \"not int!\\n\";\n}\n\nint main() {\n  do_stuff&lt;int&gt;();\n  do_stuff&lt;double&gt;();\n}\n</code></pre>\n<p>This distinguishes <code>do_stuff</code> from <code>do_stuff</code>, because one takes 0 or more <code>UniqueEnum&lt;1&gt;</code>s, and the other takes 0 or more <code>UniqueEnum&lt;-1&gt;</code>s.  gcc 4.8 considers these different empty packs to be distinct.</p>\n<p>However, in the latest version of clang I tried, this fails: it treats the function with 0 <code>UniqueEnum&lt;1&gt;</code>s as being the same as the function with 0 <code>UniqueEnum&lt;-1&gt;</code>s.</p>\n<p>There are easy workarounds that work in clang, but I'm wondering if my above technique is legal -- do two function <code>template</code>s, which differ only by empty variardic parameter packs, actually different?</p>\n", "Tags": "<c++><templates><c++11><language-lawyer><sfinae>", "OwnerUserId": "1774667", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17116092_17118324_4": {"section_id": 295, "quality": 0.9, "length": 9}, "so_17116092_17118324_6": {"section_id": 298, "quality": 0.98, "length": 49}, "so_17116092_17118324_3": {"section_id": 294, "quality": 0.9090909090909091, "length": 10}, "so_17116092_17118324_0": {"section_id": 294, "quality": 1.0, "length": 39}, "so_17116092_17118324_5": {"section_id": 297, "quality": 0.9166666666666666, "length": 11}, "so_17116092_17118324_2": {"section_id": 294, "quality": 0.9523809523809523, "length": 20}, "so_17116092_17118324_1": {"section_id": 294, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_17116092_17118324_4": {"section_id": 286, "quality": 0.9, "length": 9}, "so_17116092_17118324_3": {"section_id": 285, "quality": 0.9090909090909091, "length": 10}, "so_17116092_17118324_6": {"section_id": 289, "quality": 0.98, "length": 49}, "so_17116092_17118324_0": {"section_id": 285, "quality": 1.0, "length": 39}, "so_17116092_17118324_5": {"section_id": 288, "quality": 0.9166666666666666, "length": 11}, "so_17116092_17118324_2": {"section_id": 285, "quality": 0.9523809523809523, "length": 20}, "so_17116092_17118324_1": {"section_id": 285, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_17116092_17118324_4": {"section_id": 302, "quality": 0.9, "length": 9}, "so_17116092_17118324_6": {"section_id": 305, "quality": 0.98, "length": 49}, "so_17116092_17118324_3": {"section_id": 301, "quality": 0.9090909090909091, "length": 10}, "so_17116092_17118324_0": {"section_id": 301, "quality": 1.0, "length": 39}, "so_17116092_17118324_5": {"section_id": 304, "quality": 0.9166666666666666, "length": 11}, "so_17116092_17118324_2": {"section_id": 301, "quality": 0.9523809523809523, "length": 20}, "so_17116092_17118324_1": {"section_id": 301, "quality": 0.9705882352941176, "length": 33}}}});