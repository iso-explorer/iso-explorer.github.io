post_cb({"bq_ids": {"n4140": {"so_17116092_17118324_0": {"length": 39, "quality": 1.0, "section_id": 294}, "so_17116092_17118324_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 294}, "so_17116092_17118324_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 294}, "so_17116092_17118324_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 297}, "so_17116092_17118324_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 294}, "so_17116092_17118324_6": {"length": 49, "quality": 0.98, "section_id": 298}, "so_17116092_17118324_4": {"length": 9, "quality": 0.9, "section_id": 295}}, "n3337": {"so_17116092_17118324_0": {"length": 39, "quality": 1.0, "section_id": 285}, "so_17116092_17118324_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 285}, "so_17116092_17118324_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 285}, "so_17116092_17118324_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 288}, "so_17116092_17118324_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 285}, "so_17116092_17118324_6": {"length": 49, "quality": 0.98, "section_id": 289}, "so_17116092_17118324_4": {"length": 9, "quality": 0.9, "section_id": 286}}, "n4659": {"so_17116092_17118324_0": {"length": 39, "quality": 1.0, "section_id": 301}, "so_17116092_17118324_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 301}, "so_17116092_17118324_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 301}, "so_17116092_17118324_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 304}, "so_17116092_17118324_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 301}, "so_17116092_17118324_6": {"length": 49, "quality": 0.98, "section_id": 305}, "so_17116092_17118324_4": {"length": 9, "quality": 0.9, "section_id": 302}}}, "17118324": {"Id": "17118324", "PostTypeId": "2", "Body": "<p>I think GCC is right, and your technique is correct. Basically, since the type argument for <code>C</code> is specified explicitly, the question is whether:</p>\n<p>a. substitution of <code>C</code> everywhere else in the function template signature happens first, and then type deduction is performed (which should result in a substitution failure); or</p>\n<p>b. type deduction is performed first, and then substitution is performed (which would not result in a substitution failure, because the corresponding argument pack would be empty, and so there would be no substitution to perform).</p>\n<p>It seems GCC assumes (1), while Clang assumes (2). Paragraph 14.8.2/2 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_0\">When an explicit template argument list is specified, the template arguments must be compatible with the\n  template parameter list and must result in a valid function type as described below; otherwise type deduction\n  fails. Specifically, <strong>the following steps are performed</strong> when evaluating an explicitly specified template\n  argument list with respect to a given function template:</p>\n<p id=\"so_17116092_17118324_1\">\u2014 The specified template arguments must match the template parameters in kind (i.e., type, non-type,\n  template). There must not be more arguments than there are parameters unless at least one parameter\n  is a template parameter pack, and there shall be an argument for each non-pack parameter. Otherwise,\n  type deduction fails.</p>\n<p id=\"so_17116092_17118324_2\">\u2014 Non-type arguments must match the types of the corresponding non-type template parameters, or must\n  be convertible to the types of the corresponding non-type parameters as specified in 14.3.2, otherwise\n  type deduction fails.</p>\n<p id=\"so_17116092_17118324_3\">\u2014 <strong>The specified template argument values are substituted for the corresponding template parameters as\n  specified below</strong>.</p>\n</blockquote>\n<p>The following paragraph then says:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_4\">After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed. [...]</p>\n</blockquote>\n<p>Moreover, paragraph 14.8.2/5 specifies:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_5\">The resulting substituted and adjusted function type <strong>is used as the type of the function template for template\n  argument deduction</strong>. [...]</p>\n</blockquote>\n<p>Finally, paragraph 14.8.2/6 goes as follows:</p>\n<blockquote>\n<p id=\"so_17116092_17118324_6\">At certain points in the template argument deduction process it is necessary to take a function type that\n  makes use of template parameters and replace those template parameters with the corresponding template\n  arguments. <strong>This is done at the beginning of template argument deduction when any explicitly specified template\n  arguments are substituted into the function type</strong>, and again at the end of template argument deduction\n  when any template arguments that were deduced or obtained from default arguments are substituted.</p>\n</blockquote>\n<p>This all seems to imply that first substitution is performed, then template argument deduction. Hence, a substitution failure should occur in either case and one of the two templates should be discarded from the overload set.</p>\n<p>Unfortunately, there does not seem to be a clear specification as to what the behavior should be when templates arguments are deduced rather than being explicitly specified.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-15T20:17:48.737", "Score": "2", "CreationDate": "2013-06-14T22:43:03.530", "ParentId": "17116092", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-06-15T20:17:48.737"}, "17116092": {"ViewCount": "242", "Body": "<p>There is a technique I sometimes use when overriding <code>template</code> functions that goes like this:</p>\n<pre><code>#include &lt;utility&gt;\ntemplate&lt;int&gt; struct unique_enum { enum class type {}; };\ntemplate&lt;int index&gt; using UniqueEnum = typename unique_enum&lt;index&gt;::type;\ntemplate&lt;bool b, int index=1&gt;\nusing EnableFuncIf = typename std::enable_if&lt; b, UniqueEnum&lt;index&gt; &gt;::type;\ntemplate&lt;bool b, int index=1&gt;\nusing DisableFuncIf = EnableFuncIf&lt;!b, -index&gt;;\n\n// boring traits class:\ntemplate&lt;typename T&gt;\nstruct is_int : std::false_type {};\ntemplate&lt;&gt;\nstruct is_int&lt;int&gt; : std::true_type {};\n\n#include &lt;iostream&gt;\n// use empty variardic packs to give these two SFINAE functions different signatures:\ntemplate&lt;typename C, EnableFuncIf&lt; is_int&lt;C&gt;::value &gt;...&gt;\nvoid do_stuff() {\n  std::cout &lt;&lt; \"int!\\n\";\n}\ntemplate&lt;typename C, DisableFuncIf&lt; is_int&lt;C&gt;::value &gt;...&gt;\nvoid do_stuff() {\n  std::cout &lt;&lt; \"not int!\\n\";\n}\n\nint main() {\n  do_stuff&lt;int&gt;();\n  do_stuff&lt;double&gt;();\n}\n</code></pre>\n<p>This distinguishes <code>do_stuff</code> from <code>do_stuff</code>, because one takes 0 or more <code>UniqueEnum&lt;1&gt;</code>s, and the other takes 0 or more <code>UniqueEnum&lt;-1&gt;</code>s.  gcc 4.8 considers these different empty packs to be distinct.</p>\n<p>However, in the latest version of clang I tried, this fails: it treats the function with 0 <code>UniqueEnum&lt;1&gt;</code>s as being the same as the function with 0 <code>UniqueEnum&lt;-1&gt;</code>s.</p>\n<p>There are easy workarounds that work in clang, but I'm wondering if my above technique is legal -- do two function <code>template</code>s, which differ only by empty variardic parameter packs, actually different?</p>\n", "AcceptedAnswerId": "17118324", "Title": "Empty variardic packs of enums -- do they make two functions different?", "CreationDate": "2013-06-14T19:41:20.133", "Id": "17116092", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-06-14T19:55:14.210", "LastEditorUserId": "1774667", "LastActivityDate": "2013-06-15T20:17:48.737", "Score": "8", "OwnerUserId": "1774667", "Tags": "<c++><templates><c++11><language-lawyer><sfinae>", "AnswerCount": "1"}});