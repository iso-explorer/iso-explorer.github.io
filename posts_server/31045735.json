post_cb({"31045826": {"Id": "31045826", "PostTypeId": "2", "Body": "<p>Static variables have internal linkage which effectively means they are local to the compilation unit. Since you have the static variable declared in a header included in 2 source files, you basically have 2 distinct variables: one <code>i</code> local to <code>MyObject.cpp</code> and another, different <code>i</code>, local to <code>main.cpp</code></p>\n", "LastActivityDate": "2015-06-25T09:04:52.450", "CommentCount": "2", "CreationDate": "2015-06-25T09:04:52.450", "ParentId": "31045735", "Score": "50", "OwnerUserId": "2805305"}, "bq_ids": {"n4140": {"so_31045735_31045964_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7151}}, "n3337": {"so_31045735_31045964_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6895}}, "n4659": {"so_31045735_31045964_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 4051}}}, "31046213": {"Id": "31046213", "PostTypeId": "2", "Body": "<p>You should not put static valiables in header files. That leads to every cpp file that includes that header to have a copy of that static local to its compilation unit. </p>\n<p>What you could do is extern storage specifier:</p>\n<p>Header:</p>\n<pre><code>namespace Header {\n    extern int i;\n}\n</code></pre>\n<p>Cpp:</p>\n<pre><code>namespace Header {\n    int i = 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-06-25T09:22:09.927", "CommentCount": "0", "CreationDate": "2015-06-25T09:22:09.927", "ParentId": "31045735", "Score": "9", "OwnerUserId": "4999494"}, "31045877": {"Id": "31045877", "PostTypeId": "2", "Body": "<p>You have two variables i</p>\n<pre><code>static int i;\n</code></pre>\n<p>because it has internal linkage. That means that each compilation unit where the corresponding header was included has its own object i and other compilation units know nothing about presnece of that object in this compilation unit.</p>\n<p>If you will remove specifier <code>static</code> then the linker should issue a message that the variable is defined twice.</p>\n<p>The same effect can be achieved if to place a variable in an unnamed namespace in C++ 2011. For example instead of</p>\n<pre><code>namespace Header {\n    static int i;\n};\n</code></pre>\n<p>you could write</p>\n<pre><code>namespace {\n    int i;\n};\n</code></pre>\n<p>In this case varaible i also has internal linkage. This is valid for C++ 2011.</p>\n", "LastActivityDate": "2015-06-25T09:07:17.753", "CommentCount": "0", "CreationDate": "2015-06-25T09:07:17.753", "ParentId": "31045735", "Score": "12", "OwnerUserId": "2877241"}, "31045938": {"Id": "31045938", "PostTypeId": "2", "Body": "<p>The variable that is declared static only has scope in the file in which it is declared where as the variable declared without static can be accessed from other files using an extern declaration.</p>\n", "LastActivityDate": "2015-06-25T09:09:46.660", "CommentCount": "0", "CreationDate": "2015-06-25T09:09:46.660", "ParentId": "31045735", "Score": "3", "OwnerUserId": "2947387"}, "31046029": {"Id": "31046029", "PostTypeId": "2", "Body": "<p>Its better to declare your variable with <code>extern</code> in your header file to specify that it has an external linkage. Otherwise the above behavior will occur or potential compile or link problems can happen. </p>\n<pre><code>static int i ; // i has internal linkage\nextern int i ; // i has external linkage\n</code></pre>\n", "LastActivityDate": "2015-06-25T09:13:26.457", "CommentCount": "0", "CreationDate": "2015-06-25T09:13:26.457", "ParentId": "31045735", "Score": "5", "OwnerUserId": "3741717"}, "31045735": {"ViewCount": "2143", "Body": "<p>I know that this program is not using the static variable in an appropriate way, but it shows how to reproduce a behavior I have seen :</p>\n<p><strong>Main.cpp :</strong></p>\n<pre><code>int main(){\n    MyObject* p = new MyObject();\n    Header::i = 5;\n\n    printf(\"i %i\\n\", Header::i);\n    p-&gt;update();\n\n    return 0;\n}\n</code></pre>\n<p><strong>MyObject.cpp :</strong></p>\n<pre><code>MyObject::MyObject(){\n}\n\nvoid MyObject::update(){\n    printf(\"i %i\\n\", Header::i);\n}\n</code></pre>\n<p><strong>Extern.h :</strong></p>\n<pre><code>namespace Header {\n    static int i;\n};\n</code></pre>\n<p>The output I get is :</p>\n<pre><code>i : 5\ni : 0\n</code></pre>\n<p>Why don't I get <code>5</code> for both outputs ? Where does this <code>0</code>come from ?\nCould you explain how static variables work ?</p>\n", "AcceptedAnswerId": "31045826", "Title": "Strange behavior of static global variable", "CreationDate": "2015-06-25T09:00:17.263", "Id": "31045735", "CommentCount": "3", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-06-26T04:50:38.997", "LastEditorUserId": "193545", "LastActivityDate": "2016-02-24T16:36:58.197", "Score": "28", "OwnerUserId": "4560470", "Tags": "<c++><static><global>", "AnswerCount": "8"}, "31046607": {"Id": "31046607", "PostTypeId": "2", "Body": "<p>As an addition to the all the answers. WHY it happens, was already explained. However HOW to fix it, was suggested till now only by using static/extern approach. This is little bit C-like. Unles you don't have to use the header in C-part of the project with C-linkage, you could use C++.</p>\n<p>So <strong>IF</strong> you have really to use something static in your code.</p>\n<p>Either declare the variable as a member of a class:</p>\n<p><strong>header.h</strong></p>\n<pre><code>MyGlobalVariableHoler\n{\n  public: static int i;\n};\n</code></pre>\n<p><strong>main.cpp</strong></p>\n<pre><code>// class' statics have has to be initialized, otherwise linker error.\nint MyGlobalVariableHoler::i=0;\n</code></pre>\n<p><strong>any_code.cpp</strong></p>\n<pre><code>#include &lt;header.h&gt;\n\nMyGlobalVariableHolder::i=4711;\n</code></pre>\n<p>Or use a singleton to avoid the explicit initialization</p>\n<p><strong>header.h</strong></p>\n<pre><code>MyGlobalVariableHolder\n{\n    MyGlobalVariableHolder(){i=0;}\n  public:\n    static MyGlobalVariableHolder &amp; instance()\n    {\n       static MyGlobalVariableHolder inst;\n       return inst;\n    }\n    int i;\n};\n</code></pre>\n<p><strong>any_code.cpp</strong></p>\n<pre><code>#include &lt;header.h&gt;\nMyGlobalVariableHolder::instance().i=4711;\n</code></pre>\n", "LastEditorUserId": "298206", "LastActivityDate": "2016-02-24T16:36:58.197", "Score": "7", "CreationDate": "2015-06-25T09:38:31.843", "ParentId": "31045735", "CommentCount": "2", "OwnerUserId": "298206", "LastEditDate": "2016-02-24T16:36:58.197"}, "31045948": {"Id": "31045948", "PostTypeId": "2", "Body": "<p>You are getting confused with class level static variable with namespace level static variable. Both are accessed by <code>X::y</code> qualification, adding to confusion. Others have explained actual reason (at the compilation/linkage level).</p>\n", "LastActivityDate": "2015-06-25T09:09:57.133", "CommentCount": "0", "CreationDate": "2015-06-25T09:09:57.133", "ParentId": "31045735", "Score": "4", "OwnerUserId": "264325"}, "31045964": {"Id": "31045964", "PostTypeId": "2", "Body": "<p>You have one static variable per translation unit where you include the header, because static variables have internal linkage.</p>\n<blockquote>\n<p id=\"so_31045735_31045964_0\">Where does this 0 come from ?</p>\n</blockquote>\n<p>You've not initialized the variable in the second translation unit, and static variables are zero-initialized, that's where the 0 comes from.</p>\n<p>In the standard (\u00a73.6.2/2):</p>\n<blockquote>\n<p id=\"so_31045735_31045964_1\">Variables with static storage duration (3.7.1) [...] shall be zero-initialized (8.5) before any other initialization takes place.[...]</p>\n</blockquote>\n", "LastActivityDate": "2015-06-25T09:10:33.387", "CommentCount": "0", "CreationDate": "2015-06-25T09:10:33.387", "ParentId": "31045735", "Score": "13", "OwnerUserId": "1594913"}});