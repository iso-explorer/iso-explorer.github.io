post_cb({"4638525": {"Id": "4638525", "PostTypeId": "2", "Body": "<p>As others have said, your <code>i += ++i</code> example works with the user-defined type since you're calling functions, and functions comprise sequence points.</p>\n<p>On the other hand, <code>a[++i] = i</code> is not so lucky assuming that <code>a</code> is your basic array type, or even a user defined one.  The problem you've got here is that we don't know which part of the expression containing <code>i</code> is evaluated first.  It could be that <code>++i</code> is evaluated, passed off to <code>operator[]</code> (or the raw version) in order to retrieve the object there, and then the value of <code>i</code> gets passed to that (which is after i was incremented).  On the other hand, perhaps the latter side is evaluated first, stored for later assignment, and then the <code>++i</code> part is evaluated.</p>\n", "LastActivityDate": "2011-01-09T09:35:22.560", "CommentCount": "14", "CreationDate": "2011-01-09T09:35:22.560", "ParentId": "4638364", "Score": "10", "OwnerUserId": "301883"}, "4638392": {"Id": "4638392", "PostTypeId": "2", "Body": "<p>I think it's well-defined:</p>\n<p>From the C++ draft standard (n1905) \u00a71.9/16:</p>\n<blockquote>\n<p id=\"so_4638364_4638392_0\">\"There is also a sequence point after\n  the copying of a returned value and\n  before the execution of any\n  expressions outside the function13) .\n  Several contexts in C++ cause\n  evaluation of a function call, even\n  though no corresponding function call\n  syntax appears in the translation\n  unit. [ <em>Example</em>: evaluation of a new\n  expression invokes one or more\n  allocation and constructor functions;\n  see 5.3.4. For another example,\n  invocation of a conversion function\n  (12.3.2) can arise in contexts in\n  which no function call syntax appears.\n  \u2014 <em>end example</em> ] The sequence points at\n  function-entry and function-exit (as\n  described above) are features of the\n  function calls as evaluated, <strong>whatever\n  the syntax of the expression</strong> that\n  calls the function might be. \"</p>\n</blockquote>\n<p>Note the part I bolded.  This means there is indeed a sequence point after the increment function call (<code>i.operator ++()</code>) but before the compound assignment call (<code>i.operator+=</code>).</p>\n", "LastActivityDate": "2011-01-09T08:48:46.830", "CommentCount": "0", "CreationDate": "2011-01-09T08:48:46.830", "ParentId": "4638364", "Score": "7", "OwnerUserId": "47773"}, "4638364": {"ViewCount": "9893", "Body": "<p>Consider this topic a sequel of the following topic:</p>\n<blockquote>\n<p id=\"so_4638364_4638364_0\"><strong>Previous installment</strong> <br/>\n<em><a href=\"https://stackoverflow.com/questions/4176328\">Undefined behavior and sequence points</a></em></p>\n</blockquote>\n<p>Let's revisit this <em>funny</em> and <em>convoluted</em> expression (the italicized phrases are taken from the above topic *smile* ):</p>\n<pre><code>i += ++i;\n</code></pre>\n<p>We say this invokes undefined-behavior. I presume that when say this, we implicitly assume that <em>type</em> of <code>i</code> is one of the built-in types.</p>\n<p>What if the <em>type</em> of <code>i</code> is a user-defined type? Say its type is <code>Index</code> which is defined later in this post (see below). Would it still invoke undefined-behavior?</p>\n<p>If yes, why? Is it not equivalent to writing <code>i.operator+=(i.operator++());</code> or even syntactically simpler  <code>i.add(i.inc());</code>? Or, do they too invoke undefined-behavior?</p>\n<p>If no, why not? After all, the object <code>i</code> gets modified <strong>twice</strong> between consecutive sequence points. Please recall the rule of thumb: <a href=\"http://msdn.microsoft.com/en-us/library/d45c7a5d%28v=vs.90%29.aspx\" rel=\"nofollow noreferrer\">an expression can modify an object's value only once between consecutive \"sequence points</a>. And if  <code>i += ++i</code> is an expression, then it must invoke undefined-behavior. If so, then its equivalents <code>i.operator+=(i.operator++());</code> and  <code>i.add(i.inc());</code> must also invoke undefined-behavior which seems to be untrue! (as far as I understand)</p>\n<p>Or, <code>i += ++i</code> is not an <em>expression</em> to begin with? If so, then what is it and what is the definition of <em>expression</em>?</p>\n<p>If it's an expression, and at the same time, its behavior is <strong>also</strong> well-defined, then it implies that the number of sequence points associated with an expression somehow depends on the <em>type</em> of operands involved in the expression. Am I correct (even partly)?</p>\n<hr>\n<p>By the way, how about this expression?</p>\n<pre><code>//Consider two cases:\n//1. If a is an array of a built-in type\n//2. If a is user-defined type which overloads the subscript operator!\n\na[++i] = i; //Taken from the previous topic. But here type of `i` is Index.\n</code></pre>\n<p>You must consider this too in your response (if you know its behavior for sure). :-)</p>\n<hr>\n<p>Is</p>\n<pre><code>++++++i;\n</code></pre>\n<p>well-defined in C++03? After all, this is this,</p>\n<pre><code>((i.operator++()).operator++()).operator++();\n</code></pre>\n<hr>\n<pre><code>class Index\n{\n    int state;\n\n    public:\n        Index(int s) : state(s) {}\n        Index&amp; operator++()\n        {\n            state++;\n            return *this;\n        }\n        Index&amp; operator+=(const Index &amp; index)\n        {\n            state+= index.state;\n            return *this;\n        }\n        operator int()\n        {\n            return state;\n        }\n        Index &amp; add(const Index &amp; index)\n        {\n            state += index.state;\n            return *this;\n        }\n        Index &amp; inc()\n        {\n            state++;\n            return *this;\n        }\n};\n</code></pre>\n</hr></hr></hr>", "AcceptedAnswerId": "4638386", "Title": "Undefined behavior and sequence points reloaded", "CreationDate": "2011-01-09T08:40:54.597", "Id": "4638364", "CommentCount": "11", "FavoriteCount": "67", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:41.940", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-28T15:56:23.830", "Score": "78", "OwnerUserId": "415784", "Tags": "<c++><undefined-behavior><c++-faq><sequence-points>", "AnswerCount": "5"}, "4640419": {"Id": "4640419", "PostTypeId": "2", "Body": "<p><a href=\"http://www.eelis.net/C++/analogliterals.xhtml\" rel=\"noreferrer\">http://www.eelis.net/C++/analogliterals.xhtml</a>\nAnalog literals comes to my mind</p>\n<pre><code>  unsigned int c = ( o-----o\n                     |     !\n                     !     !\n                     !     !\n                     o-----o ).area;\n\n  assert( c == (I-----I) * (I-------I) );\n\n  assert( ( o-----o\n            |     !\n            !     !\n            !     !\n            !     !\n            o-----o ).area == ( o---------o\n                                |         !\n                                !         !\n                                o---------o ).area );\n</code></pre>\n", "LastEditorUserId": "534381", "LastActivityDate": "2014-05-14T10:01:30.027", "Score": "10", "CreationDate": "2011-01-09T16:59:48.533", "ParentId": "4638364", "CommentCount": "1", "OwnerUserId": "534381", "LastEditDate": "2014-05-14T10:01:30.027"}, "bq_ids": {"n4140": {"so_4638364_4638392_0": {"length": 51, "quality": 0.6986301369863014, "section_id": 5811}}, "n3337": {"so_4638364_4638392_0": {"length": 51, "quality": 0.6986301369863014, "section_id": 5584}}, "n4659": {"so_4638364_4638392_0": {"length": 48, "quality": 0.6575342465753424, "section_id": 7273}}}, "4638386": {"Id": "4638386", "PostTypeId": "2", "Body": "<p>It looks like the code</p>\n<pre><code>i.operator+=(i.operator ++());\n</code></pre>\n<p>Works perfectly fine with regards to sequence points.  Section 1.9.17 of the C++ ISO standard says this about sequence points and function evaluation:</p>\n<blockquote>\n<p id=\"so_4638364_4638386_0\">When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all function arguments (if any) which takes place before execution of any expressions or statements in the function body. There is also a sequence point after the copying of a returned value and before the execution of any expressions outside the function.</p>\n</blockquote>\n<p>This would indicate, for example, that the <code>i.operator ++()</code> as the parameter to <code>operator +=</code> has a sequence point after its evaluation.  In short, because overloaded operators are functions, the normal sequencing rules apply.</p>\n<p>Great question, by the way!  I really like how you're forcing me to understand all the nuances of a language that I already thought I knew (and thought that I thought that I knew). :-)</p>\n", "LastActivityDate": "2011-01-09T08:47:32.700", "CommentCount": "0", "CreationDate": "2011-01-09T08:47:32.700", "ParentId": "4638364", "Score": "46", "OwnerUserId": "501557"}, "4638718": {"Id": "4638718", "PostTypeId": "2", "Body": "<p>Alright. After going through previous responses, I re-thought about my own question, particularly this part that only Noah attempted to <a href=\"https://stackoverflow.com/questions/4638364/undefined-behavior-and-sequence-points-reloaded/4638525#4638525\">answer</a> but I'm not convinced with him completely. </p>\n<pre><code>a[++i] = i;\n</code></pre>\n<h1>Case 1:</h1>\n<p>If <code>a</code> is an array of built-in type. Then what Noah said is correct. That is, </p>\n<blockquote>\n<p id=\"so_4638364_4638718_0\">a[++i] = i is not so lucky assuming\n  that a is your basic array type, <del> or\n  even a user defined one </del>. The problem\n  you've got here is that we don't know\n  which part  of the expression\n  containing i is evaluated first.</p>\n</blockquote>\n<p>So <code>a[++i]=i</code> invokes undefined-behavior, or the result is unspecified. Whatever it is, it's not well-defined!</p>\n<p>PS: In above quotation, <del>strike-through</del> is of course mine.</p>\n<h1>Case 2:</h1>\n<p>If <code>a</code> is an object of user-defined type which overloads the <code>operator[]</code>, then again there are two cases. </p>\n<ol>\n<li>If the return type of overloaded <code>operator[]</code> function is built-in type, then again <code>a[++i]=i</code> invokes undefined-behavior or the result is unspecified.</li>\n<li>But if the return type of overloaded <code>operator[]</code> function is user-defined type, then the behavior of <code>a[++i] = i</code> is well-defined (as far as I understand), since in this case <code>a[++i]=i</code> is equivalent to writing <code>a.operator[](++i).operator=(i);</code> which is same as, <code>a[++i].operator=(i);</code>. That is, assignment <code>operator=</code> gets invoked on the <strong>returned</strong> object of <code>a[++i]</code>, which seems be very well-defined, since by the time <code>a[++i]</code> returns, <code>++i</code> have already been evaluated, and then the <em>returned</em> object calls <code>operator=</code> function passing the updated value of <code>i</code> to it as argument. <strong>Note that there is a sequence point between these two calls</strong>. And the syntax ensures that there is no competition between these two calls, and <code>operator[]</code> would get invoked first, and consecutively, the argument <code>++i</code> passed into it, would also get evaluated first.</li>\n</ol>\n<p>Think of this as <code>someInstance.Fun(++k).Gun(10).Sun(k).Tun();</code> in which each consecutive function call returns an object of some user-defined type.  To me, this situation seems more like this: <code>eat(++k);drink(10);sleep(k)</code>, because in both situations, there exists sequence point after each function call.</p>\n<p>Please correct me if I'm wrong. :-)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-01-09T19:53:42.220", "Score": "5", "CreationDate": "2011-01-09T10:39:04.703", "ParentId": "4638364", "CommentCount": "18", "OwnerUserId": "415784", "LastEditDate": "2017-05-23T11:54:47.530"}});