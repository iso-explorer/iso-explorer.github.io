post_cb({"bq_ids": {"n4140": {"so_15079947_15080960_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 5505}, "so_15079947_15080960_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 5503}, "so_15079947_15080960_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5492}}, "n3337": {"so_15079947_15080960_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 5291}, "so_15079947_15080960_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 5289}, "so_15079947_15080960_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5278}}, "n4659": {"so_15079947_15080960_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 6939}, "so_15079947_15080960_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 6937}, "so_15079947_15080960_0": {"length": 19, "quality": 0.6129032258064516, "section_id": 6926}}}, "15079947": {"ViewCount": "528", "Body": "<p>I was surprised by the fact that GCC does <strong>not</strong> consider the call to <code>foo()</code> in the following program ambiguous:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B1 { bool foo(bool) { return true; } };\nstruct B2 { bool foo(bool) { return false; } };\n\nstruct C : public B1, public B2\n{\n    using B1::foo;\n    using B2::foo;\n};\n\nint main()\n{\n    C c;\n\n    // Compiles and prints `true` on GCC 4.7.2 and GCC 4.8.0 (beta);\n    // does not compile on Clang 3.2 and ICC 13.0.1;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; c.foo(true);\n}\n</code></pre>\n<p>The above function call compiles and returns <code>true</code> on GCC 4.7.2 and GCC 4.8.0 (beta), while it <em>won't compile</em> (as I would expect) on Clang 3.2 and ICC 13.0.1.</p>\n<p><strong>Is this a case of \"<em>no diagnostic required</em>\", or is it a bug in GCC?</strong> References to the C++11 Standard are encouraged.</p>\n", "AcceptedAnswerId": "15080960", "Title": "Obviously ambiguous call does not cause a compilation error on GCC", "CreationDate": "2013-02-26T01:46:44.520", "Id": "15079947", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2013-02-26T03:58:30.600", "Score": "9", "OwnerUserId": "1932150", "Tags": "<c++><c++11><language-lawyer><diagnostics><ambiguous-call>", "AnswerCount": "2"}, "15080138": {"Id": "15080138", "PostTypeId": "2", "Body": "<p>The call to <code>foo(true)</code> in your program is, as you say, clearly ambiguous; furthermore, it is ambiguous according to the algorithm presented in \u00a710.2 and consequently, it should be flagged on use. (Flagging the <code>using</code> declaration would be incorrect; 10.2(1) clearly states that ambiguous uses of names are flagged on lookup, not on declaration.)</p>\n<p>It's interesting to contrast this program with a similar one, which is the subject of a <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=46687\" rel=\"nofollow\">a recognized gcc bug</a> (slightly modified from that bug report to make the parallel clearer):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n   static int foo() {return 1;}\n   static int foo(char) { return 2;}\n};\n\nstruct B1 : A {\n//   using A::foo;\n};\nstruct B2 : A {\n//   using A::foo;\n};\n\nstruct C : B1, B2 {\n//   using B1::foo;\n//   using B2::foo;\n};\n\nint main()\n{\n    std::cout &lt;&lt; C::foo();\n}\n</code></pre>\n<p>The above program is correct; despite the diamond inheritance, <code>foo</code> is a static member of <code>A</code>, so it is not ambiguous. In fact, gcc compiles it without trouble. However, uncommenting the two instances of <code>using A::foo</code>, which does not change anything about either <code>foo</code>, causes gcc to produce the oddly reduplicated error noted in the bug report. Uncommenting the two <code>using</code> declarations inside <code>C</code>, which presumably triggers the other bug which is the subject of this question, then masks the <code>static function</code> bug and causes the program to compile again.</p>\n<p>clang seems to handle all possible variants of this program, for what it's worth.</p>\n<p>Finally, note that an explicitly declared <code>foo(bool)</code> within <code>C</code> (in the original program) will win out over any <code>foo(bool)</code> brought into <code>C</code>'s scope by <code>using</code> declarations. I suspect that both of these bugs are the result of bad bookkeeping while trying to keep track of the various function declarations in each class's scope and their individual provenance (as a sequence of <code>using</code> declarations and function declarations).</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2013-02-26T03:58:30.600", "Score": "1", "CreationDate": "2013-02-26T02:05:53.393", "ParentId": "15079947", "CommentCount": "0", "OwnerUserId": "1566221", "LastEditDate": "2013-02-26T03:58:30.600"}, "15080960": {"Id": "15080960", "PostTypeId": "2", "Body": "<p>\u00a77.3.3/3:</p>\n<blockquote>\n<p id=\"so_15079947_15080960_0\">In a using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the class being defined. If such a using-declaration names a constructor, the nested-name-specifier shall name a direct base class of the class being defined; otherwise <strong>it introduces the set of declarations found by member name lookup (10.2, 3.4.3.1)</strong>.</p>\n</blockquote>\n<p>\u00b614:</p>\n<blockquote>\n<p id=\"so_15079947_15080960_1\">\u2026 [ Note: Two using-declarations may introduce functions with the same name and the same parameter types. If, for a call to an unqualified function name, function overload resolution selects the functions introduced by such using-declarations, the function call is ill-formed.</p>\n</blockquote>\n<p>\u00b616:</p>\n<blockquote>\n<p id=\"so_15079947_15080960_2\">For the purpose of overload resolution, the functions which are introduced by a using-declaration into a\n  derived class will be treated as though they were members of the derived class.</p>\n</blockquote>\n<p>So, the <code>using</code> declarations are legal, but the functions are peers in the same overload set, as you said, and the program is ill-formed.</p>\n", "LastActivityDate": "2013-02-26T03:41:42.593", "CommentCount": "0", "CreationDate": "2013-02-26T03:41:42.593", "ParentId": "15079947", "Score": "4", "OwnerUserId": "153285"}});