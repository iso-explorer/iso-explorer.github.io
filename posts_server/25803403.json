post_cb({"bq_ids": {"n4140": {"so_25803403_25803403_2": {"length": 10, "quality": 1.0, "section_id": 715}, "so_25803403_25803403_19": {"length": 4, "quality": 0.8, "section_id": 3952}, "so_25803403_25803403_4": {"length": 9, "quality": 0.9, "section_id": 715}, "so_25803403_25803403_13": {"length": 5, "quality": 0.8333333333333334, "section_id": 460}, "so_25803403_25803403_5": {"length": 11, "quality": 1.0, "section_id": 4280}, "so_25803403_25803403_9": {"length": 4, "quality": 0.8, "section_id": 3079}, "so_25803403_25803813_1": {"length": 37, "quality": 0.8809523809523809, "section_id": 4710}, "so_25803403_25803403_20": {"length": 15, "quality": 1.0, "section_id": 4710}, "so_25803403_25803403_18": {"length": 4, "quality": 1.0, "section_id": 4710}, "so_25803403_25803403_16": {"length": 6, "quality": 0.6666666666666666, "section_id": 4706}, "so_25803403_25803813_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6328}}, "n3337": {"so_25803403_25803403_9": {"length": 4, "quality": 0.8, "section_id": 2956}, "so_25803403_25803403_13": {"length": 5, "quality": 0.8333333333333334, "section_id": 451}, "so_25803403_25803403_5": {"length": 11, "quality": 1.0, "section_id": 4121}, "so_25803403_25803403_2": {"length": 8, "quality": 0.8, "section_id": 704}, "so_25803403_25803813_1": {"length": 37, "quality": 0.8809523809523809, "section_id": 4518}, "so_25803403_25803403_20": {"length": 15, "quality": 1.0, "section_id": 4518}, "so_25803403_25803813_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6085}, "so_25803403_25803403_18": {"length": 4, "quality": 1.0, "section_id": 4518}}, "n4659": {"so_25803403_25803403_9": {"length": 4, "quality": 0.8, "section_id": 3839}, "so_25803403_25803403_19": {"length": 4, "quality": 0.8, "section_id": 4839}, "so_25803403_25803403_4": {"length": 9, "quality": 0.9, "section_id": 745}, "so_25803403_25803403_13": {"length": 5, "quality": 0.8333333333333334, "section_id": 382}, "so_25803403_25803403_5": {"length": 11, "quality": 1.0, "section_id": 5536}, "so_25803403_25803403_2": {"length": 10, "quality": 1.0, "section_id": 745}, "so_25803403_25803813_1": {"length": 37, "quality": 0.8809523809523809, "section_id": 6107}, "so_25803403_25803403_20": {"length": 15, "quality": 1.0, "section_id": 6107}, "so_25803403_25803813_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7838}, "so_25803403_25803403_16": {"length": 6, "quality": 0.6666666666666666, "section_id": 6103}}}, "25803813": {"Id": "25803813", "PostTypeId": "2", "Body": "<p>There are two problems in your analysis.</p>\n<p>First, violating a <em>Requires</em> clause causes undefined behavior (\u00a717.6.4.11 [res.on.required]):</p>\n<blockquote>\n<p id=\"so_25803403_25803813_0\">Violation of the preconditions specified in a function\u2019s <em>Requires:</em>\n  paragraph results in undefined behavior unless the function\u2019s\n  <em>Throws:</em> paragraph specifies throwing an exception when the precondition is violated.</p>\n</blockquote>\n<p>Which means that the library can do anything it wants if you try to copy construct an <code>unordered_map</code> with a non-CopyInsertable element. It doesn't necessarily lead to the program being ill-formed (although it probably will, somewhere deep inside the copy constructor's implementation). </p>\n<p>Second, the testing performed by the <code>is_constructible</code> trait is limited to the immediate context (\u00a720.10.4.3 [meta.unary.prop]/p7, emphasis added):</p>\n<blockquote>\n<p id=\"so_25803403_25803813_1\">Access checking is performed as if in a context unrelated to <code>T</code> and any\n  of the <code>Args</code>. <strong>Only the validity of the immediate context of the\n  variable initialization is considered.</strong> [ <em>Note</em>: The evaluation of\n  the initialization can result in side effects such as the\n  instantiation of class template specializations and function template\n  specializations, the generation of implicitly-defined functions, and\n  so on. Such side effects are not in the \u201cimmediate context\u201d and can\n  result in the program being ill-formed. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>In other words, this basically just considers if there's a matching, accessible, and non-deleted constructor signature, not if instantiating the constructor will result in well-formed code.</p>\n<p>The standard would have to specify the copy constructor of containers with something along the lines of <em>\"this constructor shall not participate in overload resolution if <code>T</code> is not CopyInsertable into <code>X</code>\"</em> to guarantee that the <code>is_copy_constructible</code> trait behaves the way you want it to. There is no such specification in the standard.</p>\n<p>As Marc Glisse wrote in the comments, while this isn't mandated by the standard, it can be considered a quality of implementation issue, so a bug report would be reasonable.</p>\n<hr>\n<p>Edit: It occurred to me that a requirement to remove the copy constructor from overload resolution for non-<code>CopyInsertable</code> elements is probably not implementable, since that property is specified in terms of a call to <code>allocator_traits&lt;A&gt;::construct(m, p, v)</code> being well-formed and having the required semantics. I do not believe SFINAE could determine the well-formedness of the body of the call to <code>allocator_traits&lt;A&gt;::construct()</code>.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-18T03:18:27.293", "Score": "9", "CreationDate": "2014-09-12T08:20:55.357", "ParentId": "25803403", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-09-18T03:18:27.293"}, "25803403": {"ViewCount": "488", "Body": "<p><code>g++ --version</code> yields:</p>\n<pre><code>g++.exe (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 4.9.1\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n<p>Program:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_map&gt;\n\nstatic_assert(!std::is_copy_constructible&lt;std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;&gt;&gt;::value,\"Copyable\");\n\nint main () {   }\n</code></pre>\n<p>Result of compilation:</p>\n<pre><code>.\\unorderedmapcopyable.cpp:5:1: error: static assertion failed: Copyable\n static_assert(!std::is_copy_constructible&lt;std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;&gt;&gt;::value,\"Copyable\");\n ^\n</code></pre>\n<p>Relevant standardese:</p>\n<h2>On Containers Being Copyable</h2>\n<p>For the statements <code>X u(a)</code> and <code>X u=a</code> to be valid, for some container type <code>X</code>, which contains type <code>T</code>, where <code>a</code> is a value of type <code>X</code>:</p>\n<blockquote>\n<p id=\"so_25803403_25803403_0\"><em>Requires:</em> <code>T</code> is <code>CopyInsertable</code> into <code>X</code></p>\n<p id=\"so_25803403_25803403_1\">\u00a723.2.1 [container.requirements.general]</p>\n</blockquote>\n<p><strong>My understanding of this:</strong> If <code>T</code> (in our case <code>std::pair&lt;const int,std::unique_ptr&lt;int&gt;&gt;</code>) is not <code>CopyInsertable</code> into <code>X</code> (in our case <code>std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;&gt;</code>), then <code>X u(a)</code> and <code>X u=a</code> are not well-formed.</p>\n<h2>On <code>CopyInsertable</code></h2>\n<blockquote>\n<p id=\"so_25803403_25803403_2\"><code>T</code> is <code>CopyInsertable</code> into <code>X</code> means that, in addition to <code>T</code> being <code>MoveInsertable</code> into <code>X</code>, the following expression is well-formed:</p>\n<p id=\"so_25803403_25803403_3\"><code>allocator_traits&lt;A&gt;::construct(m, p, v)</code></p>\n<p id=\"so_25803403_25803403_4\">and its evaluation causes the following postcondition to hold: The value of <code>v</code> is unchanged and is equivalent to <code>*p</code>.</p>\n</blockquote>\n<p><strong>My understanding of this:</strong> <code>std::pair&lt;const int,std::unique_ptr&lt;int&gt;&gt;</code> is not <code>CopyInsertable</code>, due to the fact <code>std::unique_ptr&lt;int&gt;</code> is not copyable:</p>\n<blockquote>\n<p id=\"so_25803403_25803403_5\">Each object of a type <code>U</code> instantiated from the <code>unique_ptr</code> template specified in this subclause [...] is not <code>CopyConstructible</code> nor <code>CopyAssignable</code>.</p>\n<p id=\"so_25803403_25803403_6\">\u00a720.8.1 [unique.ptr]</p>\n</blockquote>\n<p>And due to the fact that the copy constructor of <code>std::pair&lt;const int,std::unique_ptr&lt;int&gt;&gt;</code> is defaulted:</p>\n<blockquote>\n<p id=\"so_25803403_25803403_7\"><code>pair(const pair&amp;) = default;</code></p>\n<p id=\"so_25803403_25803403_8\">\u00a720.3.2 [pairs.pair]</p>\n</blockquote>\n<p>And due to the fact that <code>std::pair&lt;const int,std::unique_ptr&lt;int&gt;&gt;</code> has a member of type <code>std::unique_ptr&lt;int&gt;</code>:</p>\n<blockquote>\n<p id=\"so_25803403_25803403_9\"><code>template &lt;class T1, class T2&gt; struct pair {</code></p>\n<p id=\"so_25803403_25803403_10\">[...]</p>\n<p id=\"so_25803403_25803403_11\"><code>T2 second;</code></p>\n<p id=\"so_25803403_25803403_12\">\u00a720.3.2 [pairs.pair]</p>\n</blockquote>\n<p>And due to the fact that defaulted copy constructors are deleted when it is not the case that all members of a type are <code>CopyConstructible</code>:</p>\n<blockquote>\n<p id=\"so_25803403_25803403_13\">A defaulted copy/move constructor for a class <code>X</code> is defined as deleted if X has:</p>\n<p id=\"so_25803403_25803403_14\">[...]</p>\n<ul>\n<li>a non-static data member of class type <code>M</code> (or array thereof) that cannot be copied/moved because overload resolution, as applied to <code>M</code>\u2019s corresponding constructor, results in [...] a function that is deleted [...]</li>\n</ul>\n<p id=\"so_25803403_25803403_15\">\u00a712.8 [class.copy]</p>\n</blockquote>\n<h2>On <code>std::is_copy_constructible</code></h2>\n<blockquote>\n<p id=\"so_25803403_25803403_16\">For a referenceable type <code>T</code>, the same result as <code>is_constructible&lt;T,const T&amp;&gt;::value</code>,\n  otherwise <code>false</code>.</p>\n<p id=\"so_25803403_25803403_17\">\u00a720.10.4.3 [meta.unary.prop]</p>\n</blockquote>\n<p><strong>My understanding/reading of this:</strong> <code>std::is_copy_constructible&lt;std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;&gt;</code> is the same as <code>std::is_constructible&lt;std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;,std::unordered_map&lt;int,std::unique_ptr&lt;int&gt; &amp;&gt;</code>.</p>\n<h2>On <code>std::is_constructible</code></h2>\n<blockquote>\n<p id=\"so_25803403_25803403_18\">Given the following function prototype:</p>\n<p id=\"so_25803403_25803403_19\"><code>template &lt;class T&gt; add_rvalue_reference_t&lt;T&gt; create() noexcept;</code></p>\n<p id=\"so_25803403_25803403_20\">the predicate condition for a template specialization <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the following variable definition would be well-formed for some invented variable <code>t</code>:</p>\n<p id=\"so_25803403_25803403_21\"><code>T t(create&lt;Args&gt;()...);</code></p>\n<p id=\"so_25803403_25803403_22\">\u00a720.10.4.3 [meta.unary.prop]</p>\n</blockquote>\n<p><strong>My understanding of this:</strong> <code>std::is_constructible&lt;std::unordered_map&lt;int,std::unique_ptr&lt;int&gt;&gt;,std::unordered_map&lt;int,std::unique_ptr&lt;int&gt; &amp;&gt;</code> ought to be <code>std::false_type</code>, not <code>std::true_type</code>, since <code>X u(a)</code> is not well-formed.</p>\n<h2>My Question</h2>\n<p>Should the above code be accepted?  Is this a GCC/libstdc++ bug, or is there something in the standard I'm missing?</p>\n<p>I don't currently have access to Clang or MSVC++, otherwise I'd test on them.</p>\n", "AcceptedAnswerId": "25803813", "Title": "std::unordered_map<T,std::unique_ptr<U>> copyable? GCC bug?", "CreationDate": "2014-09-12T07:54:16.453", "Id": "25803403", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-18T03:18:27.293", "Score": "12", "OwnerUserId": "1007504", "Tags": "<c++><gcc><g++><language-lawyer><c++14>", "AnswerCount": "1"}});