post_cb({"bq_ids": {"n4140": {"so_15311447_15311928_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 5315}, "so_15311447_15311928_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5313}, "so_15311447_15311447_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5313}}, "n3337": {"so_15311447_15311928_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 5112}, "so_15311447_15311928_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5110}, "so_15311447_15311447_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 5110}}, "n4659": {"so_15311447_15311928_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 6739}, "so_15311447_15311928_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6737}, "so_15311447_15311447_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 6737}}}, "15311928": {"Id": "15311928", "PostTypeId": "2", "Body": "<p>Note the preceding sentence which states:</p>\n<blockquote>\n<p id=\"so_15311447_15311928_0\">Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set (introducing new-line characters for end-of-line indicators) if necessary.</p>\n</blockquote>\n<p>That is, it's entirely up to the compiler how it actually interprets the characters or bytes that make up your file. In doing this interpretation, it must decide which of the physical characters belong to the basic source character set and which don't. If a character does not belong, then it is replaced with the universal character name (or at least, the effect is <em>as if</em> it had done).</p>\n<p>The point of this is to reduce the source file down to a very small set of characters - there are only 96 characters in the basic source character set. Any character not in the basic source character set has been replaced by <code>\\</code>, <code>u</code> or <code>U</code>, and some hexadecimal digits (<code>0</code>-<code>F</code>).</p>\n<p>A universal character name is one of:</p>\n<pre><code>\\uNNNN\n\\UNNNNNNNN\n</code></pre>\n<p>Where each <code>N</code> is a hexadecimal digit. The meaning of these digits is given in \u00a72.3:</p>\n<blockquote>\n<p id=\"so_15311447_15311928_1\">The character designated by the universal-character-name <code>\\UNNNNNNNN</code> is that character whose character short name in ISO/IEC 10646 is <code>NNNNNNNN</code>; the character designated by the universal-character-name <code>\\uNNNN</code> is that character whose character short name in ISO/IEC 10646 is <code>0000NNNN</code>. If the hexadecimal value for a universal-character-name corresponds to a surrogate code point (in the range <code>0xD800</code>\u2013<code>0xDFFF</code>, inclusive), the program is ill-formed.</p>\n</blockquote>\n<p>The ISO/IEC 10646 standard originated before Unicode and defined the Universal Character Set (UCS). It assigned code points to characters and specified how those code points should be encoded. The Unicode Consortium and the ISO group then joined forces to work on Unicode. The Unicode standard specifies much more than ISO/IEC 10646 does (algorithms, functional character specifications, etc.) but both standards are now kept in sync.</p>\n<p>So you can think of the <code>NNNN</code> or <code>NNNNNNNN</code> as the Unicode code point for that character.</p>\n<p>As an example, consider a line in your source file containing this:</p>\n<pre><code>const char* str = \"Hell\u00f4\";\n</code></pre>\n<p>Since \u00f4 is not in the basic source character set, that line is internally translated to:</p>\n<pre><code>const char* str = \"Hell\\u00F4\";\n</code></pre>\n<p>This will give the same result.</p>\n<p>There are only certain parts of your code that a universal-character-name is permitted:</p>\n<ul>\n<li>In string literals</li>\n<li>In character literals</li>\n<li>In identifiers (however, <a href=\"https://stackoverflow.com/q/12692067/150634\">this is not very well supported</a>)</li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-09T15:14:53.010", "Score": "3", "CreationDate": "2013-03-09T14:42:17.590", "ParentId": "15311447", "CommentCount": "7", "OwnerUserId": "150634", "LastEditDate": "2017-05-23T11:56:50.887"}, "15312222": {"Id": "15312222", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15311447_15312222_0\">But I don't get how to obtain this NNNN or NNNNNNNN. So this is my question: how to do conversion?</p>\n</blockquote>\n<p>The mapping is implementation-defined (e.g. \u00a72.3 footnote 14). For instance if I save the following file as Latin-1:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hall\u00f6\\n\";\n}\n</code></pre>\n<p>And compile it with <code>g++</code> on OS X, I get the following output after running it:</p>\n<pre><code>Hell\ufffd\n</code></pre>\n<p>\u2026 but if I had saved it as UTF-8 I would have gotten this:</p>\n<pre><code>Hell\u00f6\n</code></pre>\n<p>Because GCC assumes UTF-8 as the input encoding on my system.</p>\n<p>Other compilers may perform different mappings.</p>\n", "LastActivityDate": "2013-03-09T15:10:47.323", "CommentCount": "0", "CreationDate": "2013-03-09T15:10:47.323", "ParentId": "15311447", "Score": "2", "OwnerUserId": "1968"}, "15311447": {"ViewCount": "1329", "Body": "<p>I can't understand what does it mean in c++ standard:</p>\n<blockquote>\n<p id=\"so_15311447_15311447_0\">Any source file character not in the basic source character set (2.3)\n  is replaced by the universal-character-name that designates that\n  charac- ter. (An implementation may use any internal encoding, so long\n  as an actual extended character encountered in the source file, and\n  the same extended character expressed in the source file as a\n  universal-character-name (i.e., using the \\uXXXX notation), are\n  handled equivalently except where this replacement is reverted in a\n  raw string literal.)</p>\n</blockquote>\n<p>As I understand, if compiler sees charcter not in the basic character set it's just replaced it with sequence of characters in this format <strong>'\\uNNNN'</strong> or <strong>'\\UNNNNNNNN'</strong>. But I don't get how to obtain this NNNN or NNNNNNNN. \nSo this is my question: <strong>how to do conversion</strong> ? </p>\n", "AcceptedAnswerId": "15311928", "Title": "C++ Compilation. Phase of translation #1. Universal character name", "CreationDate": "2013-03-09T13:50:33.650", "Id": "15311447", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-03-09T15:14:53.010", "Score": "4", "OwnerUserId": "1811538", "Tags": "<c++><compiler-construction><utf-8>", "AnswerCount": "3"}, "15311685": {"Id": "15311685", "PostTypeId": "2", "Body": "<p>So, if your file is called <code>Hello\u00b0\u00b6.c</code>, the compile would, when using that name internally, e.g. if we do:</p>\n<pre><code>cout &lt;&lt; __FILE__ &lt;&lt; endl;\n</code></pre>\n<p>the compiler would translate <code>Hello\u00b0\u00b6.c</code> to <code>Hello\\u00b0\\u00b6.c</code>. </p>\n<p>However, when I just tried this with <code>g++</code> it doesn't do that... </p>\n<p>But the assembler output contains:</p>\n<pre><code>.string \"Hello\\302\\260\\302\\266.c\"\n</code></pre>\n", "LastActivityDate": "2013-03-09T14:17:52.607", "CommentCount": "10", "CreationDate": "2013-03-09T14:17:52.607", "ParentId": "15311447", "Score": "1", "OwnerUserId": "1919155"}});