post_cb({"4909766": {"CommentCount": "4", "AcceptedAnswerId": "4909801", "CreationDate": "2011-02-05T21:26:35.667", "LastActivityDate": "2016-12-23T17:17:17.483", "PostTypeId": "1", "ViewCount": "2072", "FavoriteCount": "4", "Title": "Is it unspecified behavior to compare pointers to different arrays for equality?", "Id": "4909766", "Score": "13", "Body": "<p>The equality operators have the semantic restrictions of relational operators on pointers:</p>\n<blockquote>\n<p id=\"so_4909766_4909766_0\">The == (equal to) and the != (not equal to) operators have the same semantic restrictions, conversions, and result type as the relational operators except for their lower precedence and truth-value result. [C++03 \u00a75.10p2]</p>\n</blockquote>\n<p>And the relational operators have a restriction on comparing pointers:</p>\n<blockquote>\n<p id=\"so_4909766_4909766_1\">If two pointers p and q of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of p&lt;q, p&gt;q, p&lt;=q, and p&gt;=q are unspecified. [\u00a75.9p2]</p>\n</blockquote>\n<p>Is this a semantic restriction which is \"inherited\" by equality operators?</p>\n<p>Specifically, given:</p>\n<pre><code>int a[42];\nint b[42];\n</code></pre>\n<p>It is clear that (a + 3) &lt; (b + 3) is unspecified, but is (a + 3) == (b + 3) also unspecified?</p>\n", "Tags": "<c++><pointers><standards><unspecified-behavior>", "OwnerUserId": "511601", "AnswerCount": "3"}, "4909929": {"ParentId": "4909766", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The result from equality operators (<code>==</code> and <code>!=</code>) produce specified results as long as the pointers are to objects of the same type. Given two pointers to the same type, exactly one of the following is true:</p>\n<ol>\n<li>both are null pointers, and they compare equal to each other.</li>\n<li>both are pointers to the same object, and they compare equal to each other.</li>\n<li>they are pointers to different objects, and they compare not-equal to each other.</li>\n<li>at least one is not initialized, and the result of the comparison is not defined (and, in fact, the comparison itself may never happen--just trying to read the pointer to do the comparison gives undefined behavior).</li>\n</ol>\n<p>Under the same constraints (both pointers are to the same type of object) the result from the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) is only specified if both of them are pointers to the same object, or to separate objects in the same array (and for this purpose, a \"chunk\" of memory allocated with <code>malloc</code>, <code>new</code>, etc., qualifies as an array). If the pointers refer to separate objects that are not part of the same array, the result is unspecified. If one or both the pointers has not be initialized, you have undefined behavior.</p>\n<p>Despite that, however, the comparison templates in the standard library (<code>std::less</code>, <code>std::greater</code>, <code>std::less_equal</code> and <code>std::greater_equal</code>) <em>do</em> all yield a meaningful result, even when/if the built-in operators do not. In particular, they are required to yield a total ordering. As such, you can get ordering if you want it, just not with the built-in comparison operators (though, of course, if either or both of the pointers is un-initialized, the behavior is still undefined).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-12-23T17:17:17.483", "Id": "4909929", "Score": "10", "CreationDate": "2011-02-05T21:52:22.253", "LastActivityDate": "2016-12-23T17:17:17.483"}, "4909801": {"ParentId": "4909766", "CommentCount": "2", "Body": "<p>The semantics for <code>op==</code> and <code>op!=</code> explicitly say that the mapping is <em>except for their truth-value result</em>. So you need to look what is defined for their truth value result. If they say that the result is unspecified, then it is unspecified. If they define specific rules, then it is not. It says in particular</p>\n<blockquote>\n<p id=\"so_4909766_4909801_0\">Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address</p>\n</blockquote>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "4909801", "Score": "14", "CreationDate": "2011-02-05T21:31:17.433", "LastActivityDate": "2011-02-05T21:31:17.433"}, "bq_ids": {"n4140": {"so_4909766_4909801_0": {"section_id": 6155, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_4909766_4909766_0": {"section_id": 5917, "quality": 0.8571428571428571, "length": 18}, "so_4909766_4909801_0": {"section_id": 5917, "quality": 1.0, "length": 17}, "so_4909766_4909766_1": {"section_id": 5913, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_4909766_4909801_0": {"section_id": 7652, "quality": 0.6470588235294118, "length": 11}}}, "4911233": {"ParentId": "4909766", "CommentCount": "2", "Body": "<p>Since there's confusion on conformance semantics, these are the rules for C++. C uses a completely different conformance model.</p>\n<ol>\n<li><p>Undefined behaviour is an oxymoronic term, it means the <em>translator</em> NOT your program, may do as it pleases. This generally means it can generate code which will also do anything it pleases (but that is a deduction). Where the Standard says behaviour is undefined the text is actually of no significance to the user in the sense that eliding this text will not change the requirements the Standard imposes on translators.</p></li>\n<li><p>Ill formed program means that unless otherwise specified the behaviour of the translator is rigidly defined: it is required to reject your program and issue a diagnostic message.\nThe primary special case here is the One-Definition Rule, if you breach that your program is ill-formed but no diagnostic is required.</p></li>\n<li><p>Implementation defined imposes a requirement on the translator that it contain documentation specifying the behaviour explicitly. In this special case Undefined Behaviour can be the result but must be explicitly stated.</p></li>\n<li><p>Unspecified is a stupid term which means that the behaviour come from a set. In this sense well-defined is just a special case where the set of permitted behaviours contains only one element. Unspecified does not require documentation, so in some sense it also means the same as implementation defined without documentation.</p></li>\n</ol>\n<p>In general, the C++ Standard is a not a Language Standard, it is a <em>model</em> for a language Standard. To generate an actual Standard you have to plug in various parameters. The easiest of these to recognize are the implementation defined limits. </p>\n<p>There are a couple of silly conflicts in the Standard, for example, a legitimate translator can reject every apparently good C++ program on the basis that you are required to supply a <code>main()</code> function but the translator only supports identifiers of 1 character. This problem is resolve by the notion of <em>QOI</em> or Quality of Implementation. It basically says, who cares, no one is going to buy that compiler just because it is conforming.</p>\n<p>Technically the unspecified nature of <code>operator &lt;</code> when the pointers are to unrelated objects is probably intended to mean: you will get some kind of result which is either true or false but your program will not crash, however this is not the correct meaning of unspecified, so that is a Defect: unspecified <em>imposed a burden on the Standards writers to document the set of allowed behaviours</em> because if the set is open, then it is equivalent to undefined behaviour.</p>\n<p>I actually proposed <code>std::less</code> as a solution to the problem that some data structures require keys to be totally ordered, but pointers are not totally ordered by <code>operator &lt;</code>.  On most machines using linear addressing <code>less</code> is the same as <code>&lt;</code>, but the <code>less</code> operation on, say, an x86 processor is potentially more expensive. </p>\n", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "4911233", "Score": "7", "CreationDate": "2011-02-06T02:59:28.227", "LastActivityDate": "2011-02-06T02:59:28.227"}});