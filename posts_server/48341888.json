post_cb({"48343512": {"Id": "48343512", "PostTypeId": "2", "Body": "<p>I think that the part of the standard that describes the most precisely what performs an access is [basic.life]. In this paragraph it is explained what can be done with a reference that refers to, or a pointer that point to, an object which is out of its lifetime period. Everything that is authorized to do with such entities does not perform an access to the object value since such value does not exist (otherwise the standard would be inconsistent).</p>\n<p>So we can take a more drastic example, if this is not undefined behavior, so there are no access to <code>e</code> in your example code (accordingly to the reasonning above):</p>\n<pre><code>struct E{\n     E()=default;\n     E(const E&amp;){}\n     };\nE e;\ne.~E();\nE f(e);\n</code></pre>\n<p>Here <code>e</code> is an object whose lifetime has ended but whose storage is still allocated. What can be done with such a lvalue is described in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.life#6\" rel=\"nofollow noreferrer\">[basic.life]/6</a></p>\n<blockquote>\n<p id=\"so_48341888_48343512_0\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see [class.cdtor]. Otherwise, such a glvalue refers to allocated storage ([basic.stc.dynamic.deallocation]), and <strong>using the properties of the glvalue that do not depend on its value is well-defined</strong>. The program has undefined behavior if:</p>\n<ul>\n<li><p id=\"so_48341888_48343512_1\">an lvalue-to-rvalue conversion ([conv.lval]) is applied to such a glvalue,</p></li>\n<li><p id=\"so_48341888_48343512_2\">the glvalue is used to access a non-static data member or call a non-static member function of the object, or</p></li>\n<li><p id=\"so_48341888_48343512_3\">the glvalue is implicitly converted ([conv.ptr]) to a reference to a base class type, or</p></li>\n<li><p id=\"so_48341888_48343512_4\">the glvalue is used as the operand of a static_cast ([expr.static.cast]) except when the conversion is ultimately to cv char&amp; or cv unsigned char&amp;, or</p></li>\n<li><p id=\"so_48341888_48343512_5\">the glvalue is used as the operand of a dynamic_cast ([expr.dynamic.cast]) or as the operand of typeid. </p></li>\n</ul>\n</blockquote>\n<p>None of the cited point above does happen inside <code>E</code> copy constructor so the example code in this answer is well defined, which implies that there have been no access to the value of the destroyed object. So there is no access to <code>e</code> in your example code.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-19T14:44:58.550", "Score": "3", "CreationDate": "2018-01-19T14:39:56.253", "ParentId": "48341888", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-19T14:44:58.550"}, "bq_ids": {"n4140": {"so_48341888_48343512_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}, "so_48341888_48343512_4": {"length": 8, "quality": 0.7272727272727273, "section_id": 7193}, "so_48341888_48343512_3": {"length": 6, "quality": 0.75, "section_id": 6169}, "so_48341888_48343512_2": {"length": 10, "quality": 1.0, "section_id": 7194}, "so_48341888_48341888_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 464}, "so_48341888_48343512_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 7194}, "so_48341888_48343512_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6185}}, "n3337": {"so_48341888_48343512_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}, "so_48341888_48343512_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 6938}, "so_48341888_48343512_2": {"length": 10, "quality": 1.0, "section_id": 6938}, "so_48341888_48341888_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 455}, "so_48341888_48343512_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 6938}, "so_48341888_48343512_3": {"length": 7, "quality": 0.875, "section_id": 6938}, "so_48341888_48343512_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5946}}, "n4659": {"so_48341888_48343512_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}, "so_48341888_48343512_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 8702}, "so_48341888_48343512_2": {"length": 9, "quality": 0.9, "section_id": 8702}, "so_48341888_48341888_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 487}, "so_48341888_48341888_0": {"length": 4, "quality": 1.0, "section_id": 7225}, "so_48341888_48343512_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 8703}, "so_48341888_48343512_3": {"length": 6, "quality": 0.75, "section_id": 8539}, "so_48341888_48343512_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7687}}}, "48341888": {"ViewCount": "337", "Body": "<p>Inspired from <a href=\"https://stackoverflow.com/a/48273386/4832499\">this</a> question.</p>\n<pre><code>struct E {};\nE e;\nE f(e);  // Accesses e?\n</code></pre>\n<p>To <a href=\"https://timsong-cpp.github.io/cppwp/defns.access\" rel=\"noreferrer\">access</a> is to</p>\n<blockquote>\n<p id=\"so_48341888_48341888_0\">read or modify the value of an object</p>\n</blockquote>\n<p>The empty class has an <a href=\"https://timsong-cpp.github.io/cppwp/class.copy.ctor#14\" rel=\"noreferrer\">implicitly defined copy constructor</a></p>\n<blockquote>\n<p id=\"so_48341888_48341888_1\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move of its bases and members. [...] The order of initialization is the same as the order of initialization of bases and members in a user-defined constructor. Let <code>x</code> be either the parameter of the constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner appropriate to its type:</p>\n<ul>\n<li>[...] the base or member is direct-initialized with the corresponding base or member of <code>x</code>.</li>\n</ul>\n</blockquote>\n", "AcceptedAnswerId": "48343512", "Title": "Does copying an empty object involve accessing it", "CreationDate": "2018-01-19T13:09:55.453", "LastActivityDate": "2018-01-19T14:44:58.550", "CommentCount": "22", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2018-01-19T13:30:38.997", "LastEditorUserId": "4832499", "Id": "48341888", "Score": "15", "OwnerUserId": "4832499", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "48343139": {"Id": "48343139", "PostTypeId": "2", "Body": "<p>I think it does not access the object, though a valid object is required to be present.</p>\n<pre><code>E f(e);\n</code></pre>\n<p>This calls <code>E</code>'s implicitly defined constructor <code>E::E(const E&amp;)</code>. Obviously the body of this constructor is empty (because there is nothing to do). So if anything happens, it must happen during argument passing, i.e. during the initialization of <code>const E&amp;</code> from <code>e</code>.</p>\n<p>It is self-evident that this initialization does not modify <code>e</code>. Now, to read the value of <code>e</code>, a lvalue-to-rvalue conversion must take place. However, the standard actually says that this conversion does not take place during direct reference binding<sup>1</sup>. That is to say, no read is performed.</p>\n<p>However, the standard does require that a reference must be initialized to refer to a valid object or function<sup>2</sup> (though this is subject to <a href=\"http://wg21.link/cwg453\" rel=\"nofollow noreferrer\">CWG 453</a>), so things like <code>E f(*reinterpret_cast&lt;E*&gt;(nullptr));</code> will be ill-formed.</p>\n<hr>\n<p><sup>1. This is done by not normatively requiring such conversion, and further strengthened by <a href=\"http://eel.is/c++draft/dcl.init.ref#5.1.sentence-3\" rel=\"nofollow noreferrer\">the non-normative note in [dcl.init.ref]</a>.</sup></p>\n<p><sup>2. <a href=\"http://eel.is/c++draft/dcl.ref#5.sentence-3\" rel=\"nofollow noreferrer\">[dcl.ref]</a>.</sup></p>\n</hr>", "LastEditorUserId": "4672588", "LastActivityDate": "2018-01-19T14:32:38.260", "Score": "2", "CreationDate": "2018-01-19T14:19:20.920", "ParentId": "48341888", "CommentCount": "4", "OwnerUserId": "4672588", "LastEditDate": "2018-01-19T14:32:38.260"}});