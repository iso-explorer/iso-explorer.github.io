post_cb({"40841777": {"CommentCount": "18", "AcceptedAnswerId": "40993650", "PostTypeId": "1", "LastEditorUserId": "1639256", "CreationDate": "2016-11-28T10:16:42.130", "LastActivityDate": "2017-01-18T19:36:51.950", "LastEditDate": "2016-12-02T00:51:00.537", "ViewCount": "1189", "FavoriteCount": "5", "Title": "Using C++11 auto keyword to declare two (or more) variables", "Id": "40841777", "Score": "25", "Body": "<p>I have code like this:</p>\n<pre><code>template&lt;class ListItem&gt;\nstatic void printList(QList&lt;ListItem&gt;* list)\n{\n    for (auto i = list-&gt;size() - 1, j = -1; i &gt;= 0; --i) {\n        std::cout &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \": \" &lt;&lt; list-&gt;at(i) &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>When I compile it with g++ 6.2.1 I get the following compiler output:</p>\n<pre><code>test.cpp: In function \u2018void printList(QList&lt;T&gt;*)\u2019:\ntest.cpp:10:7: error: inconsistent deduction for \u2018auto\u2019: \u2018auto\u2019 and then \u2018int\u2019\n  for (auto i = list-&gt;size() - 1, j = -1; i &gt;= 0; --i) {\n       ^~~~\n</code></pre>\n<p>I'd understand this, if variables had different types like <code>auto i = 0.0, j = 0;</code>, but in this case list is a pointer to QList and its size() method returns <code>int</code>, <code>-1</code> on its own should be <code>int</code>, too. The error message is a bit strange as well.</p>\n<p>Variables <code>i</code> and <code>j</code> are only needed in this loop and I'd like to declare them as loop parameters. It's not hard to type <code>int</code> instead of auto, but I'd like to know: is <code>auto</code> not supposed to be used for declaring multiple variables in one go, or I am missing something here and it really is erroneous code, or maybe it is the compiler's bug?</p>\n<p>P.S. Looks like using a template function is the critical part here, factoring the loop out of the template does not produce errors. So, more like a bug in the compiler?</p>\n<p><a href=\"https://godbolt.org/g/6zAhEl\" rel=\"nofollow noreferrer\">Live demo - minimal code</a></p>\n", "Tags": "<c++><c++11><templates><auto>", "OwnerUserId": "7219463", "AnswerCount": "3"}, "40993650": {"ParentId": "40841777", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is a bug in GCC.</p>\n<p>According to [dcl.spec.auto]/1:</p>\n<blockquote>\n<p id=\"so_40841777_40993650_0\">The <code>auto</code> and <code>decltype(auto)</code> <em>type-speci\ufb01ers</em> are used to designate\n  a placeholder type that will be replaced later by deduction from an\n  initializer. [...]</p>\n</blockquote>\n<p>The rules for template argument deduction never deduce a type to be <code>auto</code>. The purpose of deduction in this case is actually to <em>replace</em> <code>auto</code> with a deduced type. </p>\n<p>In the example, <code>list</code> has a dependent type (it depends on the template parameter <code>ListItem</code>), so the expression <code>list-&gt;size() - 1</code> also has a dependent type, which makes the type of <code>i</code> also dependent, which means it will only be resolved upon instantiation of the function template <code>printList</code>. Only then can the other semantic constraints related to that declaration be checked.</p>\n<p>According to [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_40841777_40993650_1\">Knowing which names are type names allows the syntax of every template\n  to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<p id=\"so_40841777_40993650_2\">[... long list of cases of which none applies here ...]</p>\n<p id=\"so_40841777_40993650_3\">Otherwise, <strong>no diagnostic shall be issued for a template for which a\n  valid specialization can be generated</strong>. [ <em>Note:</em> If a template is\n  instantiated, errors will be diagnosed according to the other rules in\n  this Standard. Exactly when these errors are diagnosed is a quality of\n  implementation issue. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>GCC is wrong to issue that error when analyzing the definition of the template <code>printList</code>, since clearly valid specializations of the template can be generated. In fact, if <code>QList</code> doesn't have any specializations for which <code>size()</code> returns something else than <code>int</code>, the declaration for <code>i</code> and <code>j</code> will be valid in all instantiations of <code>printList</code>.</p>\n<hr>\n<p>All quotes are from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf\" rel=\"nofollow noreferrer\">N4606</a>, the (almost) current working draft, but the relevant parts of the quotes above haven't changed since C++14.</p>\n<hr>\n<p>Update: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78693\" rel=\"nofollow noreferrer\">Confirmed as a regression</a> in GCC 6 / 7. Thanks to <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a> for the bug report.</p>\n<p>Update: The original bug (<a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78693\" rel=\"nofollow noreferrer\">78693</a>) was fixed for the upcoming 6.4 and 7.0 releases. It also uncovered some other issues with the way GCC handles such constructs, resulting in two other bug reports: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79009\" rel=\"nofollow noreferrer\">79009</a> and <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79013\" rel=\"nofollow noreferrer\">79013</a>.</p>\n</hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2017-01-18T19:36:51.950", "Id": "40993650", "Score": "13", "CreationDate": "2016-12-06T10:56:50.697", "LastActivityDate": "2017-01-18T19:36:51.950"}, "40989539": {"ParentId": "40841777", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>As mentioned in my comment to <a href=\"https://stackoverflow.com/a/40852055/514235\">your answer</a>, I agree with the analysis you have presented.<br>\nSimplest form of the problem (<a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow noreferrer\">demo</a>):</br></p>\n<pre><code>template&lt;class T&gt;\nvoid foo (T t) {\n  auto i = t, j = 1; // error: inconsistent deduction for \u2018auto\u2019: \u2018auto\u2019 and then \u2018int\u2019\n}    \nint main () {}\n</code></pre>\n<p>In case of templates, compiler in its 1st stage, checks the basic syntax without instantiating it. In our case, we are never invoking <code>foo()</code> anyways.</p>\n<p>Now, in above example, the <code>decltype(auto)</code> for <code>i</code> is still <code>auto</code>, because the dependent type <code>T</code> is not known. However, <code>j</code> is surely <code>int</code>. \nHence, the <strong>compiler error makes sense</strong>. Present behavior (G++ &gt;= 6), may or may not be a bug. It depends on what do we expect from the compiler. :-)</p>\n<p>However, this error cannot be condemned. Here is the supporting standard quote from <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf\" rel=\"nofollow noreferrer\">C++17 draft</a>:</p>\n<blockquote>\n<p id=\"so_40841777_40989539_0\">7.1.7.4.1  Placeholder type deduction  </p>\n<p id=\"so_40841777_40989539_1\"><sup>4</sup> <strong>If the placeholder is the auto type-specifier, the deduced type T replacing T is determined using the rules for template argument deduction</strong>. Obtain P from T by replacing the occurrences of auto with either a new invented\n  type template parameter U</p>\n</blockquote>\n<p>The same thing is present in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++14 standard</a> as 7.1.6.4 / 7. </p>\n<hr>\n<p><strong>Why is this error being reported in the first template check itself?</strong></p>\n<p>We may rightly argue that, why the compiler is being so \"pedantic\" in the first syntax check itself. Since, we are not instantiating, then shouldn't it be ok! Even if we instantiate, shouldn't it give error only for the problematic calls!<br>\nThat's what g++-5 does. Why did they bother to change it?</br></p>\n<p>I think, it's a valid argument. With g++-5, if I call:</p>\n<pre><code>foo(1);  // ok\nfoo(1.0); // error reported inside `foo()`, referencing this line\n</code></pre>\n<p>Then compiler correctly reports the error and its hierarchy when <code>i</code> and <code>j</code> are of different types.  </p>\n</hr>", "OwnerUserId": "514235", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:27.040", "Id": "40989539", "Score": "4", "CreationDate": "2016-12-06T06:57:57.717", "LastActivityDate": "2016-12-06T10:43:59.763"}, "bq_ids": {"n4140": {"so_40841777_40993650_3": {"section_id": 175, "quality": 0.8148148148148148, "length": 22}, "so_40841777_40989539_1": {"section_id": 5451, "quality": 0.9090909090909091, "length": 20}, "so_40841777_40993650_1": {"section_id": 175, "quality": 0.9230769230769231, "length": 12}, "so_40841777_40993650_0": {"section_id": 5445, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_40841777_40993650_3": {"section_id": 169, "quality": 0.8148148148148148, "length": 22}, "so_40841777_40989539_1": {"section_id": 5245, "quality": 0.7727272727272727, "length": 17}, "so_40841777_40993650_1": {"section_id": 169, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_40841777_40993650_3": {"section_id": 180, "quality": 0.8518518518518519, "length": 23}, "so_40841777_40989539_1": {"section_id": 6889, "quality": 1.0, "length": 22}, "so_40841777_40993650_1": {"section_id": 180, "quality": 0.9230769230769231, "length": 12}, "so_40841777_40993650_0": {"section_id": 6872, "quality": 0.8333333333333334, "length": 10}}}, "40852055": {"ParentId": "40841777", "CommentCount": "4", "Body": "<p>I'll summerise the information received on the topic then.</p>\n<p>The issue in the example code is in using a template function.\nCompiler does a generic check of a template first without instantiating it, this means that types, that are template arguments (and types that depend on them, like other templates) are not known, and <code>auto</code> if it depends on those unknown types is deduced into <code>auto</code> again (or not deduced into some concrete type). It never appeared to me that even after deduction <code>auto</code> can still be <code>auto</code>. Now original compiler error text makes perfect sense: variable <code>j</code> is deduced to be of type <code>int</code>, but variable <code>i</code> is still <code>auto</code> after deduction. Since <code>auto</code> and <code>int</code> are different types, compiler generates the error.</p>\n", "OwnerUserId": "7219463", "PostTypeId": "2", "Id": "40852055", "Score": "1", "CreationDate": "2016-11-28T19:32:37.270", "LastActivityDate": "2016-11-28T19:32:37.270"}});