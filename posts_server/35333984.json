post_cb({"35334187": {"PostTypeId": "2", "Body": "<p>As long a <code>Data</code> remains a POD this should be fine. Otherwise you would have to switch to placement new.</p>\n<p>I would however put a static assert in place so that this doesn't change during later refactoring</p>\n", "LastActivityDate": "2016-02-11T08:26:55.127", "Id": "35334187", "CommentCount": "0", "CreationDate": "2016-02-11T08:26:55.127", "ParentId": "35333984", "Score": "5", "OwnerUserId": "2881849"}, "35334070": {"Id": "35334070", "PostTypeId": "2", "Body": "<p>As long as the memory is used for only one thing at a time it's safe. You're basically use the allocated data as a <code>union</code>.</p>\n<p>If you want to use the memory for instances of classes and not only simple C-style structures or data-types, you have to remember to do <em>placement new</em> to \"allocate\" the objects, as this will actually call the constructor of the object. The destructor you have to call explicitly when you're done with the object, you can't <code>delete</code> it.</p>\n", "LastEditorUserId": "440558", "LastActivityDate": "2016-02-11T08:27:13.210", "CommentCount": "0", "CreationDate": "2016-02-11T08:21:02.897", "ParentId": "35333984", "Score": "8", "OwnerUserId": "440558", "LastEditDate": "2016-02-11T08:27:13.210"}, "35334077": {"Id": "35334077", "PostTypeId": "2", "Body": "<p>It's \"OK\", it works as you have written it (assuming primitives and plain-old-datatypes (PODs)). It is safe. It is effectively a custom memory manager.</p>\n<p>Some notes:</p>\n<ul>\n<li><p>If objects with non-trivial destructors are created in the location of the allocated memory, make sure it is called</p>\n<pre><code>obj-&gt;~obj();\n</code></pre></li>\n<li><p>If creating objects, consider the <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow\">placement new syntax</a> over a plain cast (works with PODs as well)</p>\n<pre><code>Object* obj = new (data) Object();\n</code></pre></li>\n<li><p>Check for a <code>nullptr</code> (or <code>NULL</code>), if <code>malloc</code> fails, <code>NULL</code> is returned</p></li>\n<li>Alignment shouldn't a problem, but always be aware of it when creating a memory manager and make sure that the alignment is appropriate</li>\n</ul>\n<p>Given you are using a C++ compiler, unless you want to keep the \"C\" nature to the code you can also look to the global <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow\"><code>operator new()</code></a>.</p>\n<p>And as always, once done don't forget the <code>free()</code> (or <code>delete</code> if using <code>new</code>)</p>\n<hr>\n<p>You mention that you are not going to convert any of the code just yet; but if or when you do consider it, there are a few idiomatic features in C++ you may wish to use over the <code>malloc</code> or even the global <code>::operator new</code>.</p>\n<p>You should look to the smart pointer <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\"><code>std::unique_ptr&lt;&gt;</code></a> or <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\"><code>std::shared_ptr&lt;&gt;</code></a> and allow them to take care of the memory management issues.</p>\n</hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2016-05-05T18:56:39.823", "CommentCount": "3", "CreationDate": "2016-02-11T08:21:18.500", "ParentId": "35333984", "Score": "52", "OwnerUserId": "3747990", "LastEditDate": "2016-05-05T18:56:39.823"}, "35333984": {"ViewCount": "4243", "Body": "<p>This question is based on some existing C code ported to C++. I am just interested in whether it is \"safe\". I already know I wouldn't have written it like this. I am aware that the code here is basically C rather than C++ but it's compiled with a C++ compiler and I know that the standards are slightly different sometimes.</p>\n<p>I have a function that allocates some memory. I cast the returned <code>void*</code> to an <code>int*</code> and start using it.</p>\n<p>Later on I cast the returned <code>void*</code> to a <code>Data*</code> and start using that.</p>\n<p>Is this safe in C++?</p>\n<p>Example :-</p>\n<pre><code>void* data = malloc(10000);\n\nint* data_i = (int*)data;\n*data_i = 123;\nprintf(\"%d\\n\", *data_i);\n\nData* data_d = (Data*)data;\ndata_d-&gt;value = 456;\nprintf(\"%d\\n\", data_d-&gt;value);\n</code></pre>\n<p>I never read variables used via a different type than they were stored but worry that the compiler might see that <code>data_i</code> and <code>data_d</code> are different types and so cannot legally alias each other and decide to reorder my code, for example putting the store to <code>data_d</code> before the first <code>printf</code>. Which would break everything.</p>\n<p>However this is a pattern that is used all the time. If you insert a <code>free</code> and <code>malloc</code> in between the two accesses I don't believe it alters anything as it doesn't touch the affected memory itself and can reuse the same data.</p>\n<p>Is my code broken or is it \"correct\"? </p>\n", "AcceptedAnswerId": "35334077", "Title": "Is reusing a memory location safe?", "CreationDate": "2016-02-11T08:16:16.023", "Id": "35333984", "CommentCount": "3", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2016-02-11T19:19:35.283", "LastEditorUserId": "333698", "LastActivityDate": "2016-05-05T18:56:39.823", "Score": "64", "OwnerUserId": "417292", "Tags": "<c++>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_35333984_35336062_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 5878}}, "n3337": {"so_35333984_35336062_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 5649}}}, "35334094": {"PostTypeId": "2", "Body": "<p>As long as you only handle \"C\"-types, this would be ok. But as soon as you use C++ classes you will get into trouble with proper initialization. If we assume that <code>Data</code> would be <code>std::string</code> for example, the code would be very wrong.</p>\n<p>The compiler cannot really move the store across the call to <code>printf</code>, because that is a visible side effect. The result has to be as if the side effects are produced in the order the program prescribes.</p>\n", "LastActivityDate": "2016-02-11T08:22:18.033", "Id": "35334094", "CommentCount": "0", "CreationDate": "2016-02-11T08:22:18.033", "ParentId": "35333984", "Score": "6", "OwnerUserId": "597607"}, "35336062": {"Id": "35336062", "PostTypeId": "2", "Body": "<p>The rules surrounding strict aliasing can be quite tricky.</p>\n<p>An example of strict aliasing is:</p>\n<pre><code>int a = 0;\nfloat* f = reinterpret_cast&lt;float*&gt;(&amp;a);\nf = 0.3;\nprintf(\"%d\", a);\n</code></pre>\n<p>This is a strict aliasing violation because:</p>\n<ul>\n<li>the lifetime of the variables (and their use) overlap</li>\n<li>they are interpreting the same piece of memory through two different \"lenses\"</li>\n</ul>\n<p>If you are not doing <em>both</em> at the same time, then your code does not violate strict aliasing.</p>\n<hr>\n<p>In C++, the lifetime of an object starts when the constructor ends and stops when the destructor starts.</p>\n<p>In the case of built-in types (no destructor) or PODs (trivial destructor), the rule is instead that their lifetime ends whenever the memory is either overwritten or freed.</p>\n<p><em>Note: this is specifically to support writing memory managers; after all <code>malloc</code> is written in C and <code>operator new</code> is written in C++ and they are explicitly allowed to pool memory.</em></p>\n<hr>\n<p>I specifically used <em>lenses</em> instead of <em>types</em> because the rule is a bit more difficult.</p>\n<p>C++ generally use <em>nominal typing</em>: if two types have a different name, they are different. If you access a value of dynamic type <code>T</code> as if it were a <code>U</code>, then you are violating aliasing.</p>\n<p>There are a number of exceptions to this rule:</p>\n<ul>\n<li>access by base class</li>\n<li>in PODs, access as a pointer to the first attribute</li>\n</ul>\n<p>And the most complicated rule is related to <code>union</code> where C++ shifts to <em>structural typing</em>: you can access a piece of memory through two different types, if you only access parts at the beginning of this piece of memory in which the two types share a common initial sequence.</p>\n<blockquote>\n<p id=\"so_35333984_35336062_0\"><strong>\u00a79.2/18</strong> If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. Two standard-layout structs share a common initial sequence if corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.</p>\n</blockquote>\n<p>Given:</p>\n<ul>\n<li><code>struct A { int a; };</code></li>\n<li><code>struct B: A { char c; double d; };</code></li>\n<li><code>struct C { int a; char c; char* z; };</code></li>\n</ul>\n<p>Within a <code>union X { B b; C c; };</code> you can access <code>x.b.a</code>, <code>x.b.c</code> and <code>x.c.a</code>, <code>x.c.c</code> at the same time; however accessing <code>x.b.d</code> (respectively <code>x.c.z</code>) is a violation of aliasing if the currently stored type is not <code>B</code> (respectively not <code>C</code>).</p>\n<p><em>Note: informally, structural typing is like mapping down the type to a tuple of its fields (flattening them).</em></p>\n<p><em>Note: <code>char*</code> is specifically exempt from this rule, you can view any piece of memory through <code>char*</code>.</em></p>\n<hr>\n<p>In your case, without the definition of <code>Data</code> I cannot say whether the \"lenses\" rule could be violated, however since you are:</p>\n<ul>\n<li>overwriting memory with <code>Data</code> before accessing it through <code>Data*</code></li>\n<li>not accessing it through <code>int*</code> afterwards</li>\n</ul>\n<p>then you are compliant with the lifetime rule, and thus there is no aliasing taking place as far as the language is concerned.</p>\n</hr></hr></hr>", "LastEditorUserId": "147192", "LastActivityDate": "2016-02-12T07:56:57.230", "CommentCount": "9", "CreationDate": "2016-02-11T10:00:54.393", "ParentId": "35333984", "Score": "16", "OwnerUserId": "147192", "LastEditDate": "2016-02-12T07:56:57.230"}, "35334462": {"Id": "35334462", "PostTypeId": "2", "Body": "<p>Depending on the definition of <code>Data</code>, your code <em>might</em> be broken. It's <em>bad</em> code, either way.</p>\n<p>If <code>Data</code> is a plain old data type (POD, i.e. a typedef for a basic type, a struct of POD types etc.), <strong>and the allocated memory is properly aligned for the type</strong> (*), then your code is <em>well-defined</em>, which means it will \"work\" (as long as you <em>initialize</em> each member of <code>*data_d</code> before using it), but it is not good practice. (See below.)</p>\n<p>If <code>Data</code> is a non-POD type, you are heading for trouble: The pointer assignment would not have invoked any constructors, for example. <code>data_d</code>, which is of type \"pointer to <code>Data</code>\", would effectively be <em>lying</em> because it points at something, but that something <em>is not of type <code>Data</code></em> because no such type has been created / constructed / initialized. Undefined behaviour will be not far off at that point.</p>\n<p>The solution for properly <em>constructing</em> an object at a given memory location is called <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\">placement new</a>:</p>\n<pre><code>Data * data_d = new (data) Data();\n</code></pre>\n<p>This instructs the compiler to construct a <code>Data</code> object <em>at the location <code>data</code></em>. This will work for POD and non-POD types alike. You will also need to call the destructor (<code>data_d-&gt;~Data()</code>) to make sure it is run before <code>delete</code>ing the memory.</p>\n<blockquote>\n<p id=\"so_35333984_35334462_0\">Take good care to never mix the allocation / release functions. Whatever you <code>malloc()</code> needs to be <code>free()</code>d, what is allocated with <code>new</code> needs <code>delete</code>, and if you <code>new []</code> you have to <code>delete []</code>. Any other combination is UB.</p>\n</blockquote>\n<hr>\n<p>In any case, using \"naked\" pointers for memory ownership is discouraged in C++. You should either</p>\n<ol>\n<li><p>put <code>new</code> in a constructor and the corresponding <code>delete</code> in the destructor of a class, making the <em>object</em> the owner of the memory (including proper deallocation when the object goes out of scope, e.g. in the case of an exception); or</p></li>\n<li><p>use a <a href=\"http://en.cppreference.com/w/cpp/memory\">smart pointer</a> which effectively does the above for you.</p></li>\n</ol>\n<hr>\n<p>(*): Implementations are known to define \"extended\" types, the alignment requirements of which are not taken into account by malloc(). I'm not sure if language lawyers would still call them \"POD\", actually. MSVC, for example, does <a href=\"https://msdn.microsoft.com/en-us/library/ycsb6wwf.aspx\">8-byte alignment</a> on malloc() but defines the SSE extended type <code>__m128</code> as having a <a href=\"https://msdn.microsoft.com/en-us/library/ayeb3ayc.aspx\">16-byte alignment</a> requirement.</p>\n</hr></hr>", "LastEditorUserId": "4330954", "LastActivityDate": "2016-02-14T07:05:30.567", "CommentCount": "8", "CreationDate": "2016-02-11T08:41:42.957", "ParentId": "35333984", "Score": "25", "OwnerUserId": "60281", "LastEditDate": "2016-02-14T07:05:30.567"}, "35334056": {"PostTypeId": "2", "Body": "<p>Effectively, you've implemented your own allocator on top of <code>malloc</code>/<code>free</code> that reuses a block in this case. That's perfectly safe. Allocator wrappers can certainly reuse blocks so long as the block is big enough and comes from a source that guarantees sufficient alignment (and <code>malloc</code> does).</p>\n", "LastActivityDate": "2016-02-11T08:20:25.617", "Id": "35334056", "CommentCount": "0", "CreationDate": "2016-02-11T08:20:25.617", "ParentId": "35333984", "Score": "5", "OwnerUserId": "721269"}, "35334161": {"PostTypeId": "2", "Body": "<p>I don't find any mistake in reusing the memory space. Only what I care for is the dangling reference. Reusing memory space as you have said I think it doesn't have any effect on the program.<br>\nYou can go on with your programming. But it is always preferable to <code>free()</code> the space and then allocate to another variable.</br></p>\n", "LastActivityDate": "2016-02-11T08:25:52.920", "Id": "35334161", "CommentCount": "0", "CreationDate": "2016-02-11T08:25:52.920", "ParentId": "35333984", "Score": "4", "OwnerUserId": "4948889"}});