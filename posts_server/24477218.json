post_cb({"24477911": {"ParentId": "24477218", "CommentCount": "0", "CreationDate": "2014-06-29T16:15:52.790", "OwnerUserId": "3510483", "PostTypeId": "2", "Id": "24477911", "Score": "2", "Body": "<p>This code does what you say, reseting the seed between each number generation :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;random&gt;\n\nint main ()\n{\n    std::mt19937 r; \n\n    for(int i = 0;i&lt;10;i++){\n       r.seed(i);\n       int v = r();\n        std::cout &lt;&lt; v &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>The output of this program is <strong>deterministic</strong>. You keep reseting the state between each generation (and this state is used to generate the next random number). You have absolutely no guarantee about the distribution, or the uniformity, of numbers generated from different mersenne sequences (again, a new sequence being started each time you reset the seed).</p>\n<p>If your goal is to generate a uniform distribution constrained in an interval, use <code>std::uniform_real_distribution</code> :</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution\" rel=\"nofollow\">Example from en.cppreference.com</a> :</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution&lt;&gt; dis(1, 2);\n    for (int n = 0; n &lt; 10; ++n) {\n        std::cout &lt;&lt; dis(gen) &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p>It is defined in the C++ standard, section <strong>\u00a7 26.5.8.2.2</strong> :</p>\n<blockquote>\n<p id=\"so_24477218_24477911_0\">A uniform_real_distribution random number distribution produces random\n  numbers x , a \u2264 x &lt; b , distributed according to the constant\n  probability density function p ( x | a,b ) = 1 / ( b \u2212 a )</p>\n</blockquote>\n", "LastActivityDate": "2014-06-29T16:15:52.790"}, "bq_ids": {"n4140": {"so_24477218_24477911_0": {"section_id": 3619, "quality": 1.0, "length": 13}}, "n3337": {"so_24477218_24477911_0": {"section_id": 3481, "quality": 1.0, "length": 13}}, "n4659": {"so_24477218_24477911_0": {"section_id": 4383, "quality": 1.0, "length": 13}}}, "24477218": {"CommentCount": "4", "AcceptedAnswerId": "24477911", "CreationDate": "2014-06-29T14:54:07.780", "LastActivityDate": "2014-06-29T16:15:52.790", "PostTypeId": "1", "ViewCount": "423", "FavoriteCount": "0", "Title": "Using continuously seed to generate uniform random numbers?", "Id": "24477218", "Score": "0", "Body": "<p>I have an interesting question, namely</p>\n<p>by using the famous mersenne twister <code>std::mt19937 r</code> in the standard library (or any other random generator) and setting it up with a seed as <code>r.seed(4)</code>  for example it is possible to obtain uniformly random generated numbers (in the range <code>uint_fast32_t</code> provides).</p>\n<p>What exactly happens if we loop through the seed from say 1 till 100 and generate the first random number, is this sequence still uniformly distributed or not?</p>\n<pre><code>for(int i = 0;i&lt;100;i++){\n   r.seed(i);\n   int v = r();\n}\n</code></pre>\n<p>I have some algorithm which would be much easier to implement by using this trick instead of generating the number in the usual way (without resetting the seed everytime).</p>\n<p>I actually don't believe that by misusing the generator like that, that the uniformity of the sequence can be maintained anymore.</p>\n<p>Does anybody has the expertise to give some reasoning about this?</p>\n<p>Thanks a lot!</p>\n", "Tags": "<c++><c++11><random>", "OwnerUserId": "293195", "AnswerCount": "1"}});