post_cb({"bq_ids": {"n4140": {"so_20268114_20273619_1": {"length": 30, "quality": 0.967741935483871, "section_id": 143}, "so_20268114_20273619_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 144}, "so_20268114_20273619_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 294}}, "n3337": {"so_20268114_20273619_1": {"length": 30, "quality": 0.967741935483871, "section_id": 137}, "so_20268114_20273619_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 138}, "so_20268114_20273619_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 285}, "so_20268114_20273619_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 338}}, "n4659": {"so_20268114_20273619_1": {"length": 30, "quality": 0.967741935483871, "section_id": 147}, "so_20268114_20273619_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 148}, "so_20268114_20273619_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 301}}}, "20268114": {"ViewCount": "1446", "Body": "<p>I have the following C++11 code.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nusing IntType = unsigned long long;\n\ntemplate &lt;IntType N&gt; struct Int {};\n\ntemplate &lt;class T&gt;\nstruct is_int : std::false_type {};\n\ntemplate &lt;long long N&gt;\nstruct is_int&lt;Int&lt;N&gt;&gt; : std::true_type {};\n\nint main()\n{\n    static_assert (is_int&lt;Int&lt;0&gt;&gt;::value, \"\");\n    return 0;\n}\n</code></pre>\n<p>Clang++ 3.3 compiles the code but on g++ 4.8.2 static assertion fails</p>\n<pre><code>$ g++ -std=c++11 main.cpp \nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:15:5: error: static assertion failed: \n     static_assert (is_int&lt;Int&lt;0&gt;&gt;::value, \"\");\n     ^\n$ \n</code></pre>\n<p>The problem is caused by different integral template parameters. \nWhich compiler is right in this case?</p>\n", "AcceptedAnswerId": "20273619", "Title": "g++ and clang++ different behaviour with integral template parameter", "CreationDate": "2013-11-28T14:00:56.497", "Id": "20268114", "CommentCount": "7", "FavoriteCount": "12", "PostTypeId": "1", "LastActivityDate": "2013-11-29T07:49:48.030", "Score": "34", "OwnerUserId": "3046011", "Tags": "<c++><templates><c++11><g++><clang++>", "AnswerCount": "2"}, "20273619": {"Id": "20273619", "PostTypeId": "2", "Body": "<h2>The surprise</h2>\n<p>This is a subtle Clang bug, deeply buried in the Standard. The problem is that in almost all cases, non-type template <em>arguments</em> can be converted to the type of the template <em>parameter</em>. E.g. the expression <code>Int&lt;0&gt;</code> has an <code>int</code> literal argument of value <code>0</code> that is being converted to the type <code>unsigned long long</code> of the template parameter <code>N</code>.</p>\n<p><strong>14.8.2 Template argument deduction [temp.deduct]/2 2nd bullet</strong></p>\n<blockquote>\n<p id=\"so_20268114_20273619_0\">-- Non-type arguments must match the types of the corresponding non-type\n  template parameters, <strong>or must be convertible to</strong> the types of the\n  corresponding non-type parameters as speci\ufb01ed in 14.3.2, otherwise\n  type deduction fails.</p>\n</blockquote>\n<p>Since your class template <code>is_int&lt;T&gt;</code> has a partial specialization, we need to look at</p>\n<p><strong>14.5.5.1 Matching of class template partial specializations [temp.class.spec.match]</strong></p>\n<blockquote>\n<p id=\"so_20268114_20273619_1\">1 When a class template is used in a context that requires an\n  instantiation of the class, it is necessary to determine whether the\n  instantiation is to be generated using the primary template or one of\n  the partial specializations. <strong>This is done by matching the template\n  arguments of the class template specialization with the template\n  argument lists of the partial specializations</strong>.</p>\n<p id=\"so_20268114_20273619_2\">2 A partial specialization matches a given actual template argument\n  list if the template arguments of the partial specialization <strong>can be\n  deduced from</strong> the actual template argument list (14.8.2).</p>\n</blockquote>\n<p>So it would seem that we can proceed to the earlier quote of 14.8.2/2 2nd bullet and match the second specialization (although in that case an even more complicated overload resolution game would have to be played). </p>\n<h2>The resolution</h2>\n<p>However, it turns out (as mentioned by @DyP in the comments) that another clause in the Standard supersedes this:</p>\n<p><strong>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</strong></p>\n<blockquote>\n<p id=\"so_20268114_20273619_3\">17 If, in the declaration of a function template with a non-type\n  template-parameter, the non-type templateparameter is used in an\n  expression in the function parameter-list and, if the corresponding\n  template-argument is deduced, <strong>the template-argument type shall match\n  the type of the template-parameter exactly</strong>, except that a\n  template-argument deduced from an array bound may be of any integral\n  type. [ Example:</p>\n</blockquote>\n<pre><code>template&lt;int i&gt; class A { / ... / };\ntemplate&lt;short s&gt; void f(A&lt;s&gt;);\n  void k1() {\n  A&lt;1&gt; a;\n  f(a); // error: deduction fails for conversion from int to short\n  f&lt;1&gt;(a); // OK\n}\n</code></pre>\n<p>The upshot is that the partial specialization of <code>is_int</code> cannot be deduced because it does not take the exact same type (<code>unsigned long long</code> vs <code>long long</code>) as the <code>Int</code> class template's formal non-type template parameter.</p>\n<p>You can resolve this by giving the non-type template parameter <code>N</code> in the partial specialization of <code>is_int</code> the same type as the non-type parameter <code>N</code> in the primary template <code>Int</code>.</p>\n<pre><code>template &lt;IntType N&gt;\n//        ^^^^^^^^         \nstruct is_int&lt;Int&lt;N&gt;&gt; : std::true_type {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5d0ad7b77db02034\"><strong>Live Example</strong></a>.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-11-29T07:49:48.030", "Score": "25", "CreationDate": "2013-11-28T19:32:55.197", "ParentId": "20268114", "CommentCount": "5", "LastEditDate": "2013-11-29T07:49:48.030", "OwnerUserId": "819272"}, "20268488": {"Id": "20268488", "PostTypeId": "2", "Body": "<p>Clang is being inconsistent. <a href=\"http://coliru.stacked-crooked.com/a/94b4b1df122762ce\">Since it accepts your code</a>, I'm expecting the following code must output <code>f(Int&lt;long long&gt;)</code> instead of <code>f(T)</code>:</p>\n<pre><code>using IntType = unsigned long long;\ntemplate &lt;IntType N&gt; struct Int {};\n\ntemplate&lt;typename T&gt;\nvoid f(T) { std::cout &lt;&lt; \"f(T)\" &lt;&lt; std::endl; }\n\ntemplate&lt;long long N&gt;\nvoid f(Int&lt;N&gt;) { std::cout &lt;&lt; \"f(Int&lt;long long&gt;)\" &lt;&lt; std::endl; }\n\nint main()\n{\n    f(Int&lt;0&gt;{});\n}\n</code></pre>\n<p>But surprisingly, it outputs this (<a href=\"http://coliru.stacked-crooked.com/a/0ad6a48e90adeb1d\">online demo</a>):</p>\n<pre><code>f(T)\n</code></pre>\n<p>That shows <code>Int&lt;0&gt;</code> does NOT match with the second overload which accepts the argument as <code>Int&lt;N&gt;</code>.  If that is so, then why does it match with <code>Int&lt;N&gt;</code> when it is used as template argument to the class template (in your case)?</p>\n<p>My conclusion:</p>\n<ul>\n<li>If Clang is correct in <strong>my</strong> case, then it is incorrect in <strong>your</strong> case.</li>\n<li>If Clang is correct in <strong>your</strong> case, then it is incorrrect in <strong>my</strong> case.</li>\n</ul>\n<p>Either way, Clang seems to have bug.</p>\n<p>GCC, on the other hand, is consistent at least. That doesn't prove though that it doesn't have bug  \u2014 it might mean that it has bug in both cases! Unless someone comes up with the standardese and showing it has bug <em>too</em>, I'm going to trust GCC in this case.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2013-11-28T14:36:30.933", "Score": "10", "CreationDate": "2013-11-28T14:21:44.903", "ParentId": "20268114", "CommentCount": "11", "LastEditDate": "2013-11-28T14:36:30.933", "OwnerUserId": "415784"}});