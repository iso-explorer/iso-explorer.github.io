post_cb({"40266806": {"CommentCount": "10", "AcceptedAnswerId": "40267527", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-10-26T15:52:18.380", "LastActivityDate": "2016-10-26T16:26:14.723", "LastEditDate": "2017-05-23T12:16:36.567", "ViewCount": "321", "FavoriteCount": "1", "Title": "Template default type vs default value", "Id": "40266806", "Score": "4", "Body": "<p>This question follows a <a href=\"https://stackoverflow.com/q/40250368/1460794\">previous one</a>.</p>\n<hr>\n<h2>Case 1: Default type</h2>\n<p>The following program does not compile and reports <code>error C2995: 'T foo(void)': function template has already been defined</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt; typename T, typename = std::enable_if_t&lt; std::is_integral&lt;T&gt;::value&gt; &gt;\nT foo() { std::cout &lt;&lt; \"integral\" &lt;&lt; std::endl; return T(); }\n\ntemplate &lt; typename T, typename = std::enable_if_t&lt; !std::is_integral&lt;T&gt;::value&gt; &gt;\nT foo() { std::cout &lt;&lt; \"non-integral\" &lt;&lt; std::endl; return T(); }\n\nint main() {\n    foo&lt;int&gt;();\n    foo&lt;float&gt;();\n}\n</code></pre>\n<p>Each of the templates are <em>alternately</em> used and ignored (SFINAE), by the two <code>foo</code> instantiations. So I assume the compiler at some point sees:</p>\n<pre><code>template &lt; typename T, typename = void &gt;\nT foo() { std::cout &lt;&lt; \"integral\" &lt;&lt; std::endl; return T(); }\n\ntemplate &lt; typename T, typename = void &gt;\nT foo() { std::cout &lt;&lt; \"non-integral\" &lt;&lt; std::endl; return T(); }\n</code></pre>\n<p>Both definitions are the same and the error is somewhat understandable. Maybe less understandable is why the compiler hadn't assigned different internal function names by this point.</p>\n<hr>\n<h2>Case 2: Default value</h2>\n<p>Now, the program can be fixed by, rather than using default types, we use default values:</p>\n<pre><code>template &lt; typename T, std::enable_if_t&lt; std::is_integral&lt;T&gt;::value&gt;* = nullptr &gt;\nT foo() { std::cout &lt;&lt; \"integral\" &lt;&lt; std::endl; return T(); }\n\ntemplate &lt; typename T, std::enable_if_t&lt; !std::is_integral&lt;T&gt;::value&gt;* = nullptr &gt;\nT foo() { std::cout &lt;&lt; \"non-integral\" &lt;&lt; std::endl; return T(); }\n</code></pre>\n<p>Here, following the same procedure, I derive:</p>\n<pre><code>template &lt; typename T, void* = nullptr &gt;\nT foo() { std::cout &lt;&lt; \"integral\" &lt;&lt; std::endl; return T(); }\n\ntemplate &lt; typename T, void* = nullptr &gt;\nT foo() { std::cout &lt;&lt; \"non-integral\" &lt;&lt; std::endl; return T(); }\n</code></pre>\n<p>Which, had that been the substitution, would have had the same definition and would not have compiled. So clearly the compiler is not doing that, or if it is, it doesn't stop there and ends up with something like:</p>\n<pre><code>int foo_int() { std::cout &lt;&lt; \"integral\" &lt;&lt; std::endl; return int(); }\n\nfloat foo_float() { std::cout &lt;&lt; \"non-integral\" &lt;&lt; std::endl; return float(); }\n\nint main() {\n    foo_int();\n    foo_float();\n}\n</code></pre>\n<hr>\n<p>Why does the compiler manage to get two different functions in the second case, but not the first?</p>\n<p>What algorithm does the standard specify for interpreting template default types vs. default values? </p>\n</hr></hr></hr>", "Tags": "<c++><templates><sfinae>", "OwnerUserId": "1460794", "AnswerCount": "1"}, "40267527": {"ParentId": "40266806", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40266806_40267527_0\">Here, following the same procedure, I derive:</p>\n</blockquote>\n<p>Everything was right until that point. You have your two function templates (ignoring the defaults):</p>\n<pre><code>template &lt; typename T, std::enable_if_t&lt; std::is_integral&lt;T&gt;::value&gt;*&gt;\nT foo();\n\ntemplate &lt; typename T, std::enable_if_t&lt; !std::is_integral&lt;T&gt;::value&gt;*&gt;\nT foo();\n</code></pre>\n<p>The two non-type template parameters do not have type <code>void*</code>. They have type <code>std::enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;*</code> and <code>std::enable_if_t&lt;!std::is_integral&lt;T&gt;::value&gt;*</code>, respectively. Those aren't the same type. There doesn't even exist a <code>T</code> for which, after substitution, those are the same type. </p>\n<p>The specific rule is in [temp.over.link]:</p>\n<blockquote>\n<p id=\"so_40266806_40267527_1\">Two expressions involving template parameters are considered equivalent if two function definitions containing\n  the expressions would satisfy the one-definition rule (3.2), except that the tokens used to name the template\n  parameters may differ as long as a token used to name a template parameter in one expression is replaced by\n  another token that names the same template parameter in the other expression. For determining whether two\n  dependent names (14.6.2) are equivalent, only the name itself is considered, not the result of name lookup in\n  the context of the template.</p>\n<p id=\"so_40266806_40267527_2\">Two function templates are equivalent if they are declared in the same scope, have the same name, have\n  identical template parameter lists, and have return types and parameter lists that are equivalent using the\n  rules described above to compare expressions involving template parameters. Two function templates are\n  functionally equivalent if they are equivalent except that one or more expressions that involve template\n  parameters in the return types and parameter lists are functionally equivalent using the rules described\n  above to compare expressions involving template parameters. If a program contains declarations of function\n  templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is\n  required.</p>\n</blockquote>\n<p>These two functions don't have identical template parameter lists. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "40267527", "Score": "4", "CreationDate": "2016-10-26T16:26:14.723", "LastActivityDate": "2016-10-26T16:26:14.723"}, "bq_ids": {"n4140": {"so_40266806_40267527_2": {"section_id": 158, "quality": 0.971830985915493, "length": 69}, "so_40266806_40267527_1": {"section_id": 157, "quality": 0.9245283018867925, "length": 49}}, "n3337": {"so_40266806_40267527_2": {"section_id": 152, "quality": 0.971830985915493, "length": 69}, "so_40266806_40267527_1": {"section_id": 151, "quality": 0.6792452830188679, "length": 36}}, "n4659": {"so_40266806_40267527_2": {"section_id": 162, "quality": 0.971830985915493, "length": 69}, "so_40266806_40267527_1": {"section_id": 161, "quality": 0.9433962264150944, "length": 50}}}});