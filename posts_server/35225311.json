post_cb({"bq_ids": {"n4140": {"so_35225311_35225313_0": {"section_id": 37, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_35225311_35225313_0": {"section_id": 34, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_35225311_35225313_0": {"section_id": 37, "quality": 0.8333333333333334, "length": 20}}}, "35225313": {"ParentId": "35225311", "CommentCount": "0", "Body": "<p>According to the standard (\u00a7[conv.fpint]).</p>\n<blockquote>\n<p id=\"so_35225311_35225313_0\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. <strong>The behavior is undefined if the truncated value cannot be represented in the destination type.</strong></p>\n</blockquote>\n<p>So, your -54.1234 is truncated to -54. Since that can't be represented in an unsigned, you get undefined behavior.</p>\n", "OwnerUserId": "179910", "Id": "35225313", "PostTypeId": "2", "OwnerDisplayName": "Jerry Coffin", "Score": "4", "CreationDate": "2016-02-05T01:59:01.783", "LastActivityDate": "2016-02-05T01:59:01.783"}, "35225311": {"CommentCount": "3", "ViewCount": "26", "OwnerDisplayName": "L_M", "CreationDate": "2016-02-04T17:52:39.387", "LastActivityDate": "2016-02-05T13:21:49.623", "Title": "How do the conversions between signed, unsigned and float types work?", "PostTypeId": "1", "Id": "35225311", "Score": "2", "Body": "<p>The compiler I use is <code>g++ (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4.</code></p>\n<p>I compile my programs with the following command:</p>\n<pre><code>g++ -std=c++11 -pedantic -Wall program.cpp\n</code></pre>\n<p><strong>The program no. 1.:</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  unsigned int b;\n  b = -54;\n  cout &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The program prints 4294967242 and this is the value I expected, because this is the case when we assign an out-of-range value to a variable of unsigned type, so the result is the remainder of a modulo division. </p>\n<p><strong>The program no. 2.:</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  unsigned int b;\n  b = 54.1234;\n  cout &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The program prints 54, and this is also OK, because the stored value is the part before the decimal point, and the franctional part is truncated.</p>\n<p><strong>The program no. 3.:</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  unsigned int b;\n  b = -54.1234;\n  cout &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>Here during compilation I get the warning \"overflow in implicit constant conversion\". </p>\n<p>And the program prints 0.  Why is it so?  I thought that it will do the truncation of the fractional part (as in program 2) and then store the result of the modulo division (as in program 1).</p>\n<p>But if I write program no. 4.:</p>\n<p><strong>program no. 4.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  unsigned int b;\n  float k = -54.1234;\n  b = k;\n  cout &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>then I get no warning, and I get the result (expected by me) 4294967242, which is the result of the modulo division.</p>\n<p>I would be grateful if somebody can explain it to me.</p>\n<p>Why doesn't the program no. 3 behave like program no. 4?  Why don't I get a warning when compiling program no. 1, but I get one when compiling program no. 3.?</p>\n", "Tags": "<c++11><floating-point><casting><type-conversion><warnings>", "OwnerUserId": "5888407", "AnswerCount": "2"}, "35225312": {"ParentId": "35225311", "CommentCount": "1", "Body": "<p>When converting floating point numbers to integers, C and C++ round floating point numbers towards zero. The rounded result must then be representable in the destination type. </p>\n<p>As a result, for 32 bit unsigned int the conversion is guaranteed to give the correct result if -1 &lt; x &lt; 2^32. For smaller numbers there are no guarantees. Since numbers between -1 and 0 must be rounded to zero, and numbers -1 and smaller have no requirements, it wouldn't be surprising if the compiler checks whether x &lt; 0 and gives a result of 0 in that case. (The compiler might check whether x &lt; 1 and give a result of 0; this handles very small positive numbers as well). </p>\n", "OwnerUserId": "3255455", "Id": "35225312", "PostTypeId": "2", "OwnerDisplayName": "gnasher729", "Score": "1", "CreationDate": "2016-02-04T20:18:03.040", "LastActivityDate": "2016-02-04T20:18:03.040"}});