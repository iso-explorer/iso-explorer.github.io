post_cb({"bq_ids": {"n4140": {"so_41724428_41724428_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5929}, "so_41724428_41724428_1": {"length": 7, "quality": 0.875, "section_id": 5929}, "so_41724428_41725812_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 3919}}, "n3337": {"so_41724428_41725812_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 3779}, "so_41724428_41724428_1": {"length": 7, "quality": 0.875, "section_id": 5701}, "so_41724428_41724428_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5701}}, "n4659": {"so_41724428_41725812_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 4805}, "so_41724428_41724428_1": {"length": 7, "quality": 0.875, "section_id": 7414}, "so_41724428_41724428_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 7414}}}, "41724428": {"ViewCount": "305", "Body": "<p>While reading this part of C++14 (<a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf\">a free draft N4141, closest to C++14</a>):</p>\n<blockquote>\n<p id=\"so_41724428_41724428_0\">9.8 Local class declarations [class.local] </p>\n<p id=\"so_41724428_41724428_1\">[..]\n  The name of a local class is local to its enclosing scope. [..]</p>\n<p id=\"so_41724428_41724428_2\">Declarations in a local class shall not odr-use (3.2) a variable with\n  automatic storage duration from an enclosing scope. [ Example: </p>\n<pre><code>//[..]\nvoid f() \n{ \n    static int s ; \n    int x; \n    // [..]\n    struct local { \n       int g() { return x; } // error: odr-use of automatic variable x \n       int h() { return s; } // OK \n       // [..]\n   };\n}\nlocal* p = 0; // error: local not in scope\n</code></pre>\n<p id=\"so_41724428_41724428_3\">\u2014end example ]</p>\n</blockquote>\n<p>I noticed, that, first - I can define <code>p</code> with return value auto deduction:</p>\n<pre><code>auto f()\n{\n  static int s;\n  int x;\n  struct local\n  {\n     int h() { return s; }\n  };\n  return local{};\n}\ndecltype(f())* p = 0; // OK - ignored, that local is not in scope!\n</code></pre>\n<p>Maybe it seems ok, why not to use local type by deducing it from function return value, but - it seems in this way I can access local <code>s</code> variable before it is constructed:</p>\n<pre><code>struct TalkativeInt\n{\n    TalkativeInt() : value() \n    {\n        std::cout &lt;&lt; \"TalkativeInt()\\n\";\n    }\n    TalkativeInt(int value) : value(value) \n    {\n        std::cout &lt;&lt; \"TalkativeInt(\" &lt;&lt; value &lt;&lt; \")\\n\";\n    }\n\n    int value;\n};\n\nauto f()\n{\n  static TalkativeInt s = 7;\n  int x;\n  struct local\n  {\n     auto h() { return s.value; }\n  };\n  return local{};\n}\ndecltype(f())* p = 0;\n\nint main() {\n    decltype(f()) l;\n    std::cout &lt;&lt; l.h();\n}\n</code></pre>\n<p>Output is just::</p>\n<pre><code>0\n</code></pre>\n<p>But one might expect:</p>\n<pre><code>TalkativeInt(7)\n7\n</code></pre>\n<p>Both clang and gcc do not protest in any way, see <a href=\"http://melpon.org/wandbox/permlink/dP15ThN3TLZSVPiN\">demo</a>.</p>\n<p>I wonder, maybe such case should be mentioned somehow either in  </p>\n<blockquote>\n<p id=\"so_41724428_41724428_4\">9.8 Local class declarations [class.local]</p>\n</blockquote>\n<p>or in</p>\n<blockquote>\n<p id=\"so_41724428_41724428_5\">7.1.6.4 auto specifier [dcl.spec.auto]</p>\n</blockquote>\n<p>?</p>\n<p>Of course, I feel that reading (and writing) from variable before it is constructed is <strong>bad thing</strong>, but I have not found anything about that in standard - probably, it was not possible before C++14? Or there are some basic rules I just overlooked?</p>\n", "AcceptedAnswerId": "41725812", "Title": "Are local class rules aligned to c++14 return type deduction?", "CreationDate": "2017-01-18T16:23:42.000", "Id": "41724428", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2017-01-18T17:29:45.220", "Score": "7", "OwnerUserId": "1463922", "Tags": "<c++><c++14><language-lawyer><return-type><auto>", "AnswerCount": "1"}, "41725812": {"Id": "41725812", "PostTypeId": "2", "Body": "<p>The rule for static local variables is <a href=\"http://eel.is/c++draft/stmt.dcl#4\">plain and simple</a>:</p>\n<blockquote>\n<p id=\"so_41724428_41725812_0\">Dynamic initialization of a block-scope variable with static storage\n  duration (3.7.1) or thread storage duration (3.7.2) is performed the\n  first time control passes through its declaration; such a variable is\n  considered initialized upon the completion of its initialization.</p>\n</blockquote>\n<p>And accessing an object's members before its construction is disallowed by <a href=\"http://eel.is/c++draft/basic.life#7\">[basic.life]/(7.1)</a>.</p>\n", "LastActivityDate": "2017-01-18T17:29:45.220", "CommentCount": "2", "CreationDate": "2017-01-18T17:29:45.220", "ParentId": "41724428", "Score": "8", "OwnerUserId": "3647361"}});