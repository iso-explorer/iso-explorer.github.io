post_cb({"29475395": {"CommentCount": "6", "ViewCount": "663", "PostTypeId": "1", "LastEditorUserId": "4031604", "CreationDate": "2015-04-06T16:36:08.197", "LastActivityDate": "2015-04-06T17:12:02.700", "Title": "C++ can operator delete fails and if not why?", "LastEditDate": "2015-04-06T17:12:02.700", "Id": "29475395", "Score": "1", "Body": "<p>Can operator delete throw an exception or signal in some other way of error during memory de-allocation?</p>\n<p>In other way is it possible for <code>operator delete</code> to fail and what is it's default behavior in this case?</p>\n<p>Also what did ISO standard says about this?</p>\n<p>For example in Windows OS - C++ <code>operator new</code> and <code>operator delete</code> are normally implemented via functions <code>HeapAlloc</code> and <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa366701(v=vs.85).aspx\" rel=\"nofollow\"><code>HeapFree</code></a>. The later function returns a boolean value which clearly indicates a fail is possible. Imagine how C++ <code>operator delete</code> will be written on it:</p>\n<pre><code>void operator delete(void *pMem)\n{\n    extern HANDLE hHeap;\n    extern DWORD dwFlags;\n\n    BOOL bSuccee = HeapFree(hHeap, dwFlags, pMem);\n\n    //return bSuccee ????????????\n}\n</code></pre>\n", "Tags": "<c++><winapi><iso><delete-operator>", "OwnerUserId": "4031604", "AnswerCount": "2"}, "29475523": {"ParentId": "29475395", "CommentCount": "0", "Body": "<p>Operator <code>delete</code> is <code>noexcept</code> since C++11, so it doesn't throw, see <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_delete\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/memory/new/operator_delete</a></p>\n<p>If operator <code>delete</code> throws, then you can end up throwing in destructor, and all bets are off.</p>\n", "OwnerUserId": "3093378", "PostTypeId": "2", "Id": "29475523", "Score": "1", "CreationDate": "2015-04-06T16:43:40.030", "LastActivityDate": "2015-04-06T16:43:40.030"}, "29475610": {"ParentId": "29475395", "CommentCount": "9", "Body": "<p>In C++11 18.6 delete is defined as a <code>noexcept</code> function.  From section 5.3.5 Delete</p>\n<blockquote>\n<p id=\"so_29475395_29475610_0\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In the first alternative (delete object), the value of the operand of delete may be a null pointer value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). <strong>If not, the behavior is undefined</strong>. In the second alternative (delete array), the value of the operand of delete may be a null pointer value or a pointer value that resulted from a previous array new-expression.82 <strong>If not, the behavior is undefined</strong>. [ Note: this means that the syntax of the delete-expression must match the type of the object allocated by new, not the syntax of the new-expression. \u2014end note</p>\n</blockquote>\n<p><strong>Emphasis mine.</strong></p>\n<p>From this we can see using delete in a manner it isn't intended to be used is UB.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "29475610", "Score": "3", "CreationDate": "2015-04-06T16:49:11.090", "LastActivityDate": "2015-04-06T16:49:11.090"}, "bq_ids": {"n4140": {"so_29475395_29475610_0": {"section_id": 6106, "quality": 0.9230769230769231, "length": 72}}, "n3337": {"so_29475395_29475610_0": {"section_id": 5872, "quality": 0.9230769230769231, "length": 72}}, "n4659": {"so_29475395_29475610_0": {"section_id": 7603, "quality": 0.9230769230769231, "length": 72}}}});