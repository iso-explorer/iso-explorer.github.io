post_cb({"19939597": {"Id": "19939597", "PostTypeId": "2", "Body": "<p><code>Astruct</code> and <code>Bstruct</code> are <em>layout compatible</em> but you are modifying a <code>const</code> object here:</p>\n<pre><code>std::memcpy(&amp;s2, &amp;s1, sizeof s2);\n</code></pre>\n<p>since <code>s2</code> in <code>Bstruct</code> is <em>const</em> and this is <em>undefined behavior</em> as we can see from the draft C++ standard section <code>7.1.6.1</code> <em>The cv-qualifiers</em> paragraph <em>4</em>:</p>\n<blockquote>\n<p id=\"so_19938365_19939597_0\">[...]any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.[...]</p>\n</blockquote>\n<p>and this exact issue was actually covered in a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3384.html#290\" rel=\"nofollow\">defect report 290</a> since section <code>3.9</code> <em>paragraph 3</em> seems to imply that it is valid. It says:</p>\n<blockquote>\n<p id=\"so_19938365_19939597_1\">7.1.6.1 [dcl.type.cv] paragraph 4 already forbids modifying a const member of a POD struct. The prohibition need not be repeated in 3.9 [basic.types].</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-08-06T15:15:24.353", "Score": "1", "CreationDate": "2013-11-12T20:50:28.120", "ParentId": "19938365", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-08-06T15:15:24.353"}, "19938578": {"Id": "19938578", "PostTypeId": "2", "Body": "<p>Yes, they are. Every definition has and will have a well known size and layout. However, a 'memcpy' might defeat copy construction (if the struct is not POD)</p>\n", "LastActivityDate": "2013-11-12T19:51:11.180", "CommentCount": "1", "CreationDate": "2013-11-12T19:51:11.180", "ParentId": "19938365", "Score": "1", "OwnerUserId": "2249683"}, "bq_ids": {"n4140": {"so_19938365_19939597_0": {"length": 10, "quality": 1.0, "section_id": 5433}}, "n3337": {"so_19938365_19939597_0": {"length": 10, "quality": 1.0, "section_id": 5228}}, "n4659": {"so_19938365_19939597_0": {"length": 10, "quality": 1.0, "section_id": 6861}}}, "19938365": {"ViewCount": "112", "Body": "<p>Are identical simple struct definitions, defined in different classes, possibly different program files <em>compiled with same compiler and flags</em>, identical in memory? Common sense says they should be, but common sense and language standards don't always quite match...</p>\n<p>Same in code, is <code>assertAB</code> method below well defined and will it always pass all asserts (assuming double value is a number)?</p>\n<pre><code>class Aclass {\npublic:\n    struct Astruct {\n        int i1;\n        char s1[10];\n        double d1;\n    }\n}\n\nclass Bclass {\nprivate:\n    struct Bstruct {\n        int i2;\n        const char s2[10];\n        double d2;\n    };\n\npublic:\n\n    void assertAB(Aclass::Astruct s1) {\n        Bstruct s2;\n        std::memcpy(&amp;s2, &amp;s1, sizeof s2);\n\n        assert(s1.i1 == s2.i2);\n        assert(std::strncmp(s1.s1, s2.s2, sizeof (s2.s2)) == 0);\n        assert(s1.d1 == s2.d2);\n    }        \n\n}\n</code></pre>\n", "AcceptedAnswerId": "19939597", "Title": "Binary compatibility of identical struct definitions inside different classes", "CreationDate": "2013-11-12T19:39:26.797", "Id": "19938365", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-08-06T15:15:24.353", "Score": "2", "OwnerUserId": "1717300", "Tags": "<c++>", "AnswerCount": "2"}});