post_cb({"11985856": {"ParentId": "11985774", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>First, default argument promotions</p>\n<blockquote>\n<p id=\"so_11985774_11985856_0\">6.5.2.2</p>\n<p id=\"so_11985774_11985856_1\">If  the  expression  that  denotes  the  called  function  has  a \n  type  that  does  not  include  a prototype, <strong>the integer promotions\n  are performed on each argument</strong>, and arguments that have  type float\n  are  promoted  to double. These  are  called  the <em>default  argument\n  promotions</em>.</p>\n</blockquote>\n<p>Now for integer promotions:</p>\n<blockquote>\n<p id=\"so_11985774_11985856_2\">6.3.1.1</p>\n<p id=\"so_11985774_11985856_3\">The following may be used in an expression wherever an int or unsigned\n  int may be used:</p>\n<ul>\n<li>An object or expression with an integer type (other than int or\n  unsigned int) whose  integer  conversion  rank  is  less  than  or \n  equal  to  the  rank  of int and unsigned int.</li>\n</ul>\n<p id=\"so_11985774_11985856_4\">If an int can represent all values of the original type (as restricted\n  by the width, for a bit-\ufb01eld), the value is converted to an int;\n  otherwise, it is converted to an unsigned int. These are called the\n  <em>integer promotions</em>.</p>\n</blockquote>\n<p>So for C at least a <code>char</code> is default-promoted to <code>int</code> or <code>unsigned int</code>.</p>\n", "OwnerUserId": "714501", "LastEditorUserId": "714501", "LastEditDate": "2012-08-16T11:12:46.393", "Id": "11985856", "Score": "13", "CreationDate": "2012-08-16T11:07:36.007", "LastActivityDate": "2012-08-16T11:12:46.393"}, "11985774": {"CommentCount": "6", "AcceptedAnswerId": "12338977", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2012-08-16T11:02:37.843", "LastActivityDate": "2012-09-09T18:16:51.087", "LastEditDate": "2012-09-09T12:31:44.777", "ViewCount": "1044", "FavoriteCount": "5", "Title": "Is char default-promoted?", "Id": "11985774", "Score": "15", "Body": "<p>This may be a silly question, but could someone please provide a standard reference for C++11 and C11:</p>\n<p><strong>Is <code>char</code> default-promoted to <code>int</code>?</strong></p>\n<p>Here's a little background: Both C and C++ have notions of <em>default argument promotion</em> (C++11: 5.2.2/7; C11: 6.5.2.2/6). This entails that in the following call, the arguments are promoted:</p>\n<pre><code>void f(int, ...);\n\nfloat a = 1; short int b = 2; char c = 'x';\n\nf(0, a, b, c);\n</code></pre>\n<p>For the function call, <code>a</code> is converted to <code>double</code> and <code>b</code> is converted to <code>int</code>. But what happens to <code>c</code>? I have always been under the impression that <code>char</code> also gets promoted to <code>int</code>, but I cannot find the relevant statement in the standards.</p>\n", "Tags": "<c++><c><language-lawyer><integer-promotion>", "OwnerUserId": "596781", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11985774_12338977_6": {"section_id": 7212, "quality": 0.6470588235294118, "length": 11}, "so_11985774_12338977_13": {"section_id": 45, "quality": 0.9090909090909091, "length": 10}, "so_11985774_12338977_4": {"section_id": 22, "quality": 0.9818181818181818, "length": 54}, "so_11985774_12338977_16": {"section_id": 45, "quality": 0.8, "length": 8}, "so_11985774_12338977_10": {"section_id": 45, "quality": 0.9166666666666666, "length": 11}, "so_11985774_12338977_11": {"section_id": 45, "quality": 0.8461538461538461, "length": 11}, "so_11985774_12338977_17": {"section_id": 45, "quality": 0.5454545454545454, "length": 6}, "so_11985774_12338977_1": {"section_id": 5994, "quality": 0.9, "length": 90}, "so_11985774_12338977_9": {"section_id": 45, "quality": 0.875, "length": 7}, "so_11985774_12338977_21": {"section_id": 21, "quality": 0.7, "length": 14}, "so_11985774_12338977_22": {"section_id": 25, "quality": 0.75, "length": 6}, "so_11985774_12338977_15": {"section_id": 45, "quality": 0.8888888888888888, "length": 8}, "so_11985774_12338977_18": {"section_id": 45, "quality": 0.875, "length": 21}, "so_11985774_12338977_19": {"section_id": 45, "quality": 0.9285714285714286, "length": 13}, "so_11985774_12338977_14": {"section_id": 45, "quality": 0.8333333333333334, "length": 10}, "so_11985774_12338977_3": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_11985774_12338977_12": {"section_id": 45, "quality": 0.9583333333333334, "length": 23}, "so_11985774_12338977_0": {"section_id": 5993, "quality": 0.8648648648648649, "length": 32}, "so_11985774_12338977_2": {"section_id": 5994, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_11985774_12338977_6": {"section_id": 6956, "quality": 0.6470588235294118, "length": 11}, "so_11985774_12338977_13": {"section_id": 42, "quality": 0.9090909090909091, "length": 10}, "so_11985774_12338977_4": {"section_id": 19, "quality": 0.9818181818181818, "length": 54}, "so_11985774_12338977_16": {"section_id": 42, "quality": 0.8, "length": 8}, "so_11985774_12338977_10": {"section_id": 42, "quality": 0.9166666666666666, "length": 11}, "so_11985774_12338977_11": {"section_id": 42, "quality": 0.8461538461538461, "length": 11}, "so_11985774_12338977_17": {"section_id": 42, "quality": 0.5454545454545454, "length": 6}, "so_11985774_12338977_1": {"section_id": 5762, "quality": 0.9, "length": 90}, "so_11985774_12338977_9": {"section_id": 42, "quality": 0.875, "length": 7}, "so_11985774_12338977_21": {"section_id": 18, "quality": 0.7, "length": 14}, "so_11985774_12338977_22": {"section_id": 22, "quality": 0.75, "length": 6}, "so_11985774_12338977_15": {"section_id": 42, "quality": 0.8888888888888888, "length": 8}, "so_11985774_12338977_18": {"section_id": 42, "quality": 0.875, "length": 21}, "so_11985774_12338977_19": {"section_id": 42, "quality": 0.9285714285714286, "length": 13}, "so_11985774_12338977_14": {"section_id": 42, "quality": 0.8333333333333334, "length": 10}, "so_11985774_12338977_3": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}, "so_11985774_12338977_12": {"section_id": 42, "quality": 0.9583333333333334, "length": 23}, "so_11985774_12338977_0": {"section_id": 5761, "quality": 0.8648648648648649, "length": 32}, "so_11985774_12338977_2": {"section_id": 5762, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_11985774_12338977_10": {"section_id": 46, "quality": 0.9166666666666666, "length": 11}, "so_11985774_12338977_13": {"section_id": 46, "quality": 0.9090909090909091, "length": 10}, "so_11985774_12338977_0": {"section_id": 7495, "quality": 0.8648648648648649, "length": 32}, "so_11985774_12338977_16": {"section_id": 46, "quality": 0.8, "length": 8}, "so_11985774_12338977_6": {"section_id": 8721, "quality": 0.6470588235294118, "length": 11}, "so_11985774_12338977_11": {"section_id": 46, "quality": 0.8461538461538461, "length": 11}, "so_11985774_12338977_4": {"section_id": 22, "quality": 0.9818181818181818, "length": 54}, "so_11985774_12338977_9": {"section_id": 46, "quality": 0.875, "length": 7}, "so_11985774_12338977_3": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_11985774_12338977_19": {"section_id": 46, "quality": 0.9285714285714286, "length": 13}, "so_11985774_12338977_22": {"section_id": 25, "quality": 0.75, "length": 6}, "so_11985774_12338977_15": {"section_id": 46, "quality": 0.8888888888888888, "length": 8}, "so_11985774_12338977_18": {"section_id": 46, "quality": 0.875, "length": 21}, "so_11985774_12338977_17": {"section_id": 46, "quality": 0.5454545454545454, "length": 6}, "so_11985774_12338977_14": {"section_id": 46, "quality": 0.8333333333333334, "length": 10}, "so_11985774_12338977_1": {"section_id": 7496, "quality": 0.87, "length": 87}, "so_11985774_12338977_12": {"section_id": 46, "quality": 0.9583333333333334, "length": 23}, "so_11985774_12338977_21": {"section_id": 21, "quality": 0.7, "length": 14}, "so_11985774_12338977_2": {"section_id": 7496, "quality": 0.7407407407407407, "length": 20}}}, "12338977": {"ParentId": "11985774", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2>C++</h2>\n<p>In C++ 2011 (ISO/IEC 14882:2011), the relevant parts seem to be:</p>\n<blockquote>\n<h3>\u00a75.2.2 Function Call [expr.call]</h3>\n<p id=\"so_11985774_12338977_0\">\u00b66 A function can be declared to accept fewer arguments (by declaring default arguments (8.3.6)) or more\n  arguments (by using the ellipsis, ..., or a function parameter pack (8.3.5)) than the number of parameters\n  in the function definition (8.4). [Note: this implies that, except where the ellipsis (...) or a function\n  parameter pack is used, a parameter is available for each argument. \u2014end note]</p>\n<p id=\"so_11985774_12338977_1\">\u00b67 When there is no parameter for a given argument, the argument is passed in such a way that the receiving\n  function can obtain the value of the argument by invoking va_arg (18.10). [Note: This paragraph does not\n  apply to arguments passed to a function parameter pack. Function parameter packs are expanded during\n  template instantiation (14.5.3), thus each such argument has a corresponding parameter when a function\n  template specialization is actually called. \u2014end note] The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and\n  function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that\n  has (possibly cv-qualified) type std::nullptr_t is converted to type void* (4.10). After these conversions,\n  if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the\n  program is ill-formed. Passing a potentially-evaluated argument of class type (Clause 9) having a nontrivial\n  copy constructor, a non-trivial move contructor, or a non-trivial destructor, with no corresponding\n  parameter, is conditionally-supported with implementation-defined semantics.</p>\n<p id=\"so_11985774_12338977_2\">If the argument has integral\n  or enumeration type that is subject to the integral promotions (4.5), or a floating point type that is subject\n  to the floating point promotion (4.6), the value of the argument is converted to the promoted type before\n  the call. These promotions are referred to as the default argument promotions.</p>\n</blockquote>\n<p>I've separated the last two sentences to give them emphasis.  They're a continuous part of paragraph 7 in the standard.</p>\n<blockquote>\n<h3>\u00a74.5 Integral promotions [conv.prom]</h3>\n<p id=\"so_11985774_12338977_3\">\u00b61 A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion\n  rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned\n  int</code>.</p>\n<p id=\"so_11985774_12338977_4\">\u00b62 A prvalue of type <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> (3.9.1) can be converted to a prvalue of the first of\n  the following types that can represent all the values of its underlying type: <code>int</code>, <code>unsigned int</code>, <code>long int</code>,\n  <code>unsigned long int</code>, <code>long long int</code>, or <code>unsigned long long int</code>. If none of the types in that list can\n  represent all the values of its underlying type, a prvalue of type <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> can be\n  converted to a prvalue of its underlying type.</p>\n</blockquote>\n<p>Etc.</p>\n<hr>\n<h2>C</h2>\n<p>C has two contexts where arguments are default promoted.  One is when there is no prototype in scope for a function (first covered by another answer), and the second when there is a prototype with ellipsis.  C++ does not allow the first case at all, of course.  These quotes are from the same sections of the standard as chosen by another answer, but the snippets here are somewhat longer. They were found by independent analysis of the standard, and it was only when cross-checking that I noticed that the sections are the same.</p>\n<p>In C 2011 (ISO/IEC 9899:2011), the relevant parts seem to be:</p>\n<blockquote>\n<h3>\u00a76.5.2.2 Function calls</h3>\n<p id=\"so_11985774_12338977_5\">\u00b66 If the expression that denotes the called function has a type that does not include a\n  prototype, the integer promotions are performed on each argument, and arguments that\n  have type float are promoted to double. These are called the default argument\n  promotions. If the number of arguments does not equal the number of parameters, the\n  behavior is undefined. If the function is defined with a type that includes a prototype, and\n  either the prototype ends with an ellipsis (<code>, ...</code>) or the types of the arguments after\n  promotion are not compatible with the types of the parameters, the behavior is undefined.\n  If the function is defined with a type that does not include a prototype, and the types of\n  the arguments after promotion are not compatible with those of the parameters after\n  promotion, the behavior is undefined, except for the following cases:</p>\n<p id=\"so_11985774_12338977_6\">\u2014 one promoted type is a signed integer type, the other promoted type is the\n  corresponding unsigned integer type, and the value is representable in both types;</p>\n<p id=\"so_11985774_12338977_7\">\u2014 both types are pointers to qualified or unqualified versions of a character type or\n  void.</p>\n<p id=\"so_11985774_12338977_8\">\u00b67 If the expression that denotes the called function has a type that does include a prototype,\n  the arguments are implicitly converted, as if by assignment, to the types of the\n  corresponding parameters, taking the type of each parameter to be the unqualified version\n  of its declared type. The ellipsis notation in a function prototype declarator causes\n  argument type conversion to stop after the last declared parameter. The default argument\n  promotions are performed on trailing arguments.</p>\n</blockquote>\n<p>The 'integer promotions' are defined in \u00a76.3.1.1:</p>\n<blockquote>\n<h3>\u00a76.3.1 Arithmetic operands</h3>\n<h3>\u00a76.3.1.1 Boolean, characters, and integers</h3>\n<p id=\"so_11985774_12338977_9\">\u00b61 Every integer type has an integer conversion rank defined as follows:</p>\n<p id=\"so_11985774_12338977_10\">\u2014 No two signed integer types shall have the same rank, even if they hav e the same\n  representation.</p>\n<p id=\"so_11985774_12338977_11\">\u2014 The rank of a signed integer type shall be greater than the rank of any signed integer\n  type with less precision.</p>\n<p id=\"so_11985774_12338977_12\">\u2014 The rank of long long int shall be greater than the rank of long int, which\n  shall be greater than the rank of int, which shall be greater than the rank of short\n  int, which shall be greater than the rank of signed char.</p>\n<p id=\"so_11985774_12338977_13\">\u2014 The rank of any unsigned integer type shall equal the rank of the corresponding\n  signed integer type, if any.</p>\n<p id=\"so_11985774_12338977_14\">\u2014 The rank of any standard integer type shall be greater than the rank of any extended\n  integer type with the same width.</p>\n<p id=\"so_11985774_12338977_15\">\u2014 The rank of char shall equal the rank of signed char and unsigned char.</p>\n<p id=\"so_11985774_12338977_16\">\u2014 The rank of _Bool shall be less than the rank of all other standard integer types.</p>\n<p id=\"so_11985774_12338977_17\">\u2014 The rank of any enumerated type shall equal the rank of the compatible integer type\n  (see 6.7.2.2).</p>\n<p id=\"so_11985774_12338977_18\">\u2014 The rank of any extended signed integer type relative to another extended signed\n  integer type with the same precision is implementation-defined, but still subject to the\n  other rules for determining the integer conversion rank.</p>\n<p id=\"so_11985774_12338977_19\">\u2014 For all integer types T1, T2, and T3, if T1 has greater rank than T2 and T2 has\n  greater rank than T3, then T1 has greater rank than T3.</p>\n<p id=\"so_11985774_12338977_20\">\u00b62 The following may be used in an expression wherever an <code>int</code> or <code>unsigned int</code> may\n  be used:</p>\n<p id=\"so_11985774_12338977_21\">\u2014 An object or expression with an integer type (other than <code>int</code> or <code>unsigned int</code>)\n  whose integer conversion rank is less than or equal to the rank of <code>int</code> and\n  <code>unsigned int</code>.</p>\n<p id=\"so_11985774_12338977_22\">\u2014 A bit-field of type <code>_Bool</code>, <code>int</code>, <code>signed int</code>, or <code>unsigned int</code>.</p>\n<p id=\"so_11985774_12338977_23\">If an <code>int</code> can represent all values of the original type (as restricted by the width, for a\n  bit-field), the value is converted to an <code>int</code>; otherwise, it is converted to an <code>unsigned\n  int</code>. These are called the <em>integer promotions</em>.<sup>58)</sup> All other types are unchanged by the\n  integer promotions.</p>\n<p id=\"so_11985774_12338977_24\"><sup>58)</sup> The integer promotions are applied only: as part of the usual arithmetic conversions, to certain\n  argument expressions, to the operands of the unary +, -, and ~ operators, and to both operands of the\n  shift operators, as specified by their respective subclauses.</p>\n</blockquote>\n<hr>\n<p>I note that at one time, the question listed the function <code>void f(...);</code>, which is a C++ function and not a C function; C does not allow the ellipsis to appear as the only argument to the function.  The question has since been updated to <code>void f(int, ...);</code> which is valid in both C and C++.</p>\n</hr></hr>", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2012-09-09T18:16:51.087", "Id": "12338977", "Score": "8", "CreationDate": "2012-09-09T12:16:34.900", "LastActivityDate": "2012-09-09T18:16:51.087"}});