post_cb({"bq_ids": {"n4140": {"so_22386191_22386307_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 5409}, "so_22386191_22386307_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5409}, "so_22386191_22386307_4": {"length": 21, "quality": 0.7777777777777778, "section_id": 5414}, "so_22386191_22386307_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 5411}, "so_22386191_22386307_3": {"length": 18, "quality": 1.0, "section_id": 5413}}, "n3337": {"so_22386191_22386307_4": {"length": 21, "quality": 0.7777777777777778, "section_id": 5209}, "so_22386191_22386307_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5204}, "so_22386191_22386307_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 5204}, "so_22386191_22386307_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 5206}, "so_22386191_22386307_3": {"length": 18, "quality": 1.0, "section_id": 5208}}, "n4659": {"so_22386191_22386307_4": {"length": 21, "quality": 0.7777777777777778, "section_id": 6836}, "so_22386191_22386307_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6831}, "so_22386191_22386307_3": {"length": 18, "quality": 1.0, "section_id": 6835}, "so_22386191_22386307_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 6833}, "so_22386191_22386307_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 6831}}}, "22386307": {"Id": "22386307", "PostTypeId": "2", "Body": "<p>In C++, you cannot use <code>struct myStruct</code> to refer to a tagless structure which has been <code>typedef</code>ed.  And you cannot define a different <code>struct myStruct</code>, because the name collides with the typedef name.</p>\n<p>If you add the tag, then both <code>struct myStruct</code> and <code>myStruct</code> alone will refer to the type, in both C and C++:</p>\n<pre><code>typedef struct myStruct {\n    int one;\n    int two;\n} myStruct;\n</code></pre>\n<p>Here there is no collision in C++ because the name resolves to just one type, and this is specifically allowed by a special rule.  C++ Standard section 7.1.3 includes the following rules:</p>\n<blockquote>\n<p id=\"so_22386191_22386307_0\">In a given non-class scope, a <code>typedef</code> specifier can be used to rede\ufb01ne the name of any type declared in that scope to refer to the type to which it already refers.</p>\n<p id=\"so_22386191_22386307_1\">If a typedef speci\ufb01er is used to rede\ufb01ne in a given scope an entity that can be referenced using an elaborated-type-specifier, the entity can continue to be referenced by an elaborated-type-specifier or as an enumeration or class name in an enumeration or class de\ufb01nition respectively.</p>\n<p id=\"so_22386191_22386307_2\">In a given scope, a typedef specifier shall not be used to rede\ufb01ne the name of any type declared in that scope to refer to a di\ufb00erent type.</p>\n<p id=\"so_22386191_22386307_3\">Similarly, in a given scope, a class or enumeration shall not be declared with the same name as a typedef-name that is declared in that scope and refers to a type other than the class or enumeration itself.</p>\n<p id=\"so_22386191_22386307_4\">[ Note:  A typedef-name that names a class type, or a cv-qualified version thereof, is also a class-name (9.1). <strong>If a typedef-name is used to identify the subject of an elaborated-type-specifier</strong> (7.1.6.3), a class definition (Clause 9), a constructor declaration (12.1), or a destructor declaration (12.4), <strong>the program is ill-formed</strong>.\n  \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-03-13T18:36:42.817", "Score": "3", "CreationDate": "2014-03-13T17:26:04.393", "ParentId": "22386191", "CommentCount": "15", "OwnerUserId": "103167", "LastEditDate": "2014-03-13T18:36:42.817"}, "22386191": {"ViewCount": "1211", "Body": "<p>This is my second investigation about structure declaration in C++. (The first is <a href=\"https://stackoverflow.com/questions/22363980/scope-of-structure-declared-defined-within-another-structure\">here</a>) But now I came across <a href=\"https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/18054549#18054549\">this post</a>. Specifically I am not sure why this is perfectly fine in C but not in C++.</p>\n<pre><code>typedef struct{\n    int one;\n    int two;\n}myStruct;\n\nstruct myStruct; //forward declaration fails\n\nvoid blah(myStruct* pStruct);\n</code></pre>\n<p>The code above compiles fine on my Ubuntu box with GCC. I reason that it is because the first <code>myStruct</code> lives in the normal namespace where function, variable names live. The second <code>myStruct</code> lives in the <strong>Tag</strong> namespace. When compiler sees <code>myStruct*</code> in the function prototype, it searches in both namespaces and found <code>myStruct</code> in the normal namspace and that name happen to be a <code>typedef</code> name, so it can be a valid type specifier. The second <code>myStruct</code> can be defined later as whatever the programmer wants to be. There won't be any confusion/collision with the first <strong>unnamed</strong> <code>myStruct</code> since the programmer has to use <code>struct myStruct</code> to refer to the second one.</p>\n<p>But in C++, according to the discussion found in the <a href=\"https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c\">linked question</a>, my understanding is that the first <strong>typedef</strong> <code>myStruct</code> lives in the normal namespace as usual. The second <code>myStruct</code> also lives in\nthe normal namespace(no specific <strong>tag</strong> namespace in C++?) but can be overshadowed by other identifiers. So my question is why wouldn't the first <code>myStruct</code> which is in the same namespace as the second <code>myStruct</code> shadow the second <code>myStruct</code>?</p>\n<p>In a more general sense, other than explicit namespaces introduced by the programmer using the namespace facility provided by the C++ language, are there any pre-defined namespaces disambiguating the use of identifiers (including tags, labels, typedef names, object/functino identifiers) like in C? (C has 4 namespaces pre-defined found in my first investigation). Can I find these in the C++ standard stating where these names belong?</p>\n<p><strong>EDIT</strong>: It seems I didn't ask the question clear enough. All I want to know is</p>\n<p>1) Which namespaces (if there are such defined in the language) do Lables, typedef names, tag names of struct/union/enum, normal function, normal variable/object name belong? (If I missed any other kinds of name, please add.)</p>\n<p>2) Why can normal function name, normal variable name shadow tag names, while tag names can NOT.</p>\n<p>3) If there is any clauses in C++ that specify the name spaces like in C (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow noreferrer\">Section 6.2.1</a>)</p>\n", "AcceptedAnswerId": "22386307", "Title": "Typedef-name conflicts with struct tag in C++", "CreationDate": "2014-03-13T17:21:54.013", "Id": "22386191", "CommentCount": "4", "LastEditDate": "2017-05-23T12:13:11.177", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-15T18:06:46.333", "Score": "2", "OwnerUserId": "1021388", "Tags": "<c++><c><struct><typedef>", "AnswerCount": "1"}});