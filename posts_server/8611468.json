post_cb({"8611512": {"ParentId": "8611468", "CommentCount": "11", "CreationDate": "2011-12-23T01:56:05.453", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8611512", "Score": "5", "Body": "<p>No, there's no problem:</p>\n<p>Member objects come alive before a constructor body runs, and they stay alive until after the destructor finishes. Therefore, you can refer to member objects in the constructor and the destructor.</p>\n<p>The object <em>itself</em> doesn't come alive until after its own constructor finishes, and it dies as soon as its destructor starts execution. But that's only as far as the outside world is concerned. Constructors and destructors may still refer to member objects.</p>\n", "LastActivityDate": "2011-12-23T01:56:05.453"}, "8611468": {"CommentCount": "3", "AcceptedAnswerId": "8611507", "PostTypeId": "1", "LastEditorUserId": "36723", "CreationDate": "2011-12-23T01:48:20.397", "LastActivityDate": "2017-01-12T18:45:56.160", "LastEditDate": "2011-12-23T01:50:12.510", "ViewCount": "1635", "FavoriteCount": "4", "Title": "Lifetime of object is over before destructor is called?", "Id": "8611468", "Score": "10", "Body": "<p>I don't understand this:</p>\n<blockquote>\n<p id=\"so_8611468_8611468_0\">3.8/1 \"The lifetime of an object of type T ends when:  \u2014 if T is a class type with a non-trivial destructor (12.4), <em>the destructor call\n  starts</em>, or  \u2014 the storage which the object occupies is reused or\n  released.\"</p>\n</blockquote>\n<p><strong>If the lifetime ends before the destructor starts, doesn't that mean accessing members in the destructor is undefined behavior?</strong></p>\n<p>I saw this quote too:</p>\n<blockquote>\n<p id=\"so_8611468_8611468_1\">12.7 \"For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor\n  finishes execution results in undefined behavior.\"</p>\n</blockquote>\n<p>But it doesn't make clear what's allowed during the destructor.</p>\n", "Tags": "<c++><destructor><language-lawyer><object-lifetime>", "OwnerUserId": "964135", "AnswerCount": "4"}, "41620698": {"ParentId": "8611468", "CommentCount": "0", "CreationDate": "2017-01-12T18:45:56.160", "OwnerUserId": "262304", "PostTypeId": "2", "Id": "41620698", "Score": "1", "Body": "<p>\"Lifetime\" doesn't mean that. It is a precisely defined term in the standard that has a variety of implications, but it might not have all the implications that you would think. Members can still be used during construction and destruction, outside code can call member functions, etc, etc.</p>\n<p>Granted, it's a bit odd for client code to call member functions concurrently with the destructor, but not unheard of and certainly not disallowed by the language. In particular, <code>std::condition_variable</code> explicitly allows the destructor to be invoked while there are outstanding calls to <code>condition_variable::wait()</code>. It only prohibits <em>new</em> calls to <code>wait()</code> after the destructor starts.</p>\n", "LastActivityDate": "2017-01-12T18:45:56.160"}, "8611504": {"ParentId": "8611468", "CommentCount": "4", "CreationDate": "2011-12-23T01:54:20.353", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "8611504", "Score": "7", "Body": "<blockquote>\n<p id=\"so_8611468_8611504_0\">If the lifetime ends before the destructor starts, doesn't that mean accessing members in the destructor is undefined behavior?</p>\n</blockquote>\n<p>Hopefully not:</p>\n<p>From N3242 <strong>Construction and destruction [class.cdtor]</strong> /3</p>\n<blockquote>\n<p id=\"so_8611468_8611504_1\">To form a pointer to (or access the value of) a direct non-static member of an object obj, the construction of obj shall have started and <strong>its destruction shall not have completed</strong>, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-23T01:54:20.353"}, "bq_ids": {"n4140": {"so_8611468_8611468_1": {"section_id": 444, "quality": 0.8888888888888888, "length": 16}, "so_8611468_8611504_1": {"section_id": 446, "quality": 1.0, "length": 27}, "so_8611468_8611468_0": {"section_id": 7189, "quality": 0.85, "length": 17}}, "n3337": {"so_8611468_8611468_1": {"section_id": 435, "quality": 0.8888888888888888, "length": 16}, "so_8611468_8611504_1": {"section_id": 437, "quality": 1.0, "length": 27}, "so_8611468_8611468_0": {"section_id": 6933, "quality": 0.85, "length": 17}}, "n4659": {"so_8611468_8611468_1": {"section_id": 467, "quality": 0.8888888888888888, "length": 16}, "so_8611468_8611504_1": {"section_id": 468, "quality": 1.0, "length": 27}, "so_8611468_8611468_0": {"section_id": 8697, "quality": 0.8, "length": 16}}}, "8611507": {"ParentId": "8611468", "CommentCount": "5", "CreationDate": "2011-12-23T01:54:55.563", "OwnerUserId": "278836", "PostTypeId": "2", "Id": "8611507", "Score": "8", "Body": "<p>The \"lifetime\" of an object is relevant for <em>consumers</em> of the object, not the object itself. Therefore a consuming class should not attempt to access members of an object once destruction has started.</p>\n", "LastActivityDate": "2011-12-23T01:54:55.563"}});