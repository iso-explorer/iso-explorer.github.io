post_cb({"11033120": {"CommentCount": "2", "ViewCount": "395", "CreationDate": "2012-06-14T12:31:22.323", "LastActivityDate": "2012-06-14T12:50:14.340", "Title": "set_new_handler and errno", "AcceptedAnswerId": "11033396", "PostTypeId": "1", "Id": "11033120", "Score": "3", "Body": "<p>If you use <code>set_new_handler</code> and your handler function is called, is <code>errno</code> guaranteed to be set, the way it is on a return of 0 from <code>malloc</code>? Or is it better to use <code>strerror(ENOMEM)</code>? <code>errno</code> works on Microsoft C++ and GCC, but that still leaves the question of whether it's guaranteed.</p>\n", "Tags": "<c++><memory><errno>", "OwnerUserId": "45843", "AnswerCount": "2"}, "11033388": {"ParentId": "11033120", "CommentCount": "0", "Body": "<p>There's no requirement that <code>new</code> (or <code>malloc</code>, for that matter) set <code>errno</code>.  Both have a clearly defined error reporting semantics (throwing <code>std::bad_alloc</code> or returning a null pointer) which doesn't involve <code>errno</code>.  (From a quality of implementation point of view, I would not want <code>new</code> or <code>malloc</code> to be allowed to modify <code>errno</code>.  Non obstante the Posix requirements.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "11033388", "Score": "2", "CreationDate": "2012-06-14T12:49:35.880", "LastActivityDate": "2012-06-14T12:49:35.880"}, "11033396": {"ParentId": "11033120", "CommentCount": "0", "Body": "<p>I don't think <code>errno</code> is good enough for detecting dynamic memory allocation failures. Looking at N3337, specifically <em>3.7.4.1 Allocation functions</em>:</p>\n<blockquote>\n<p id=\"so_11033120_11033396_0\"><strong>2</strong> [...] Even if the size of the space requested is zero, the request can fail.\n  If the request succeeds, the value returned shall be a non-null pointer value (4.10) p0 different from any\n  previously returned value p1, unless that value p1 was subsequently passed to an operator delete. The\n  effect of dereferencing a pointer returned as a request for zero size is undefined.<sup>35</sup></p>\n<p id=\"so_11033120_11033396_1\"><strong>3</strong> An allocation function that fails to allocate storage can invoke the\n  currently installed new-handler function (18.6.2.3), if any. [ Note: A\n  program-supplied allocation function can obtain the address of the\n  currently installed new_handler using the std::get_new_handler\n  function (18.6.2.4). \u2014end note ] If an allocation function declared\n  with a non-throwing exception-specification (15.4) fails to allocate\n  storage, it shall return a null pointer. Any other allocation function\n  that fails to allocate storage shall indicate failure only by throwing\n  an exception of a type that would match a handler (15.3) of type\n  std::bad_alloc (18.6.2.1).</p>\n</blockquote>\n<p>and footnote 35 (this is only a indicative and non-normative):</p>\n<blockquote>\n<p id=\"so_11033120_11033396_2\"><sup>35)</sup> The intent is to have operator new() implementable by calling std::malloc() or std::calloc(), so the rules are substantially\n  the same. C++ differs from C in requiring a zero request to return a non-null pointer.</p>\n</blockquote>\n<p>Now, heading on to the C standard draft, N1570 and a look at <em>7.5 Errors <code>&lt;errno.h&gt;</code></em>:</p>\n<blockquote>\n<p id=\"so_11033120_11033396_3\"><strong>3</strong> The value of errno in the initial thread is zero at program startup (the initial value of\n  errno in other threads is an indeterminate value), but is never set to zero by any library\n  function.202) The value of errno may be set to nonzero by a library function call\n  whether or not there is an error, provided the use of errno is not documented in the\n  description of the function in this International Standard.</p>\n</blockquote>\n<p>It appears that <code>errno</code> may be set by a <code>malloc</code> failure but this is not required.</p>\n<p>Also <em>7.22.3 Memory management functions</em> from the N1570 does not specify that <code>malloc</code> or friends are required to set <code>errno</code>.</p>\n<p>My suggestion would be to stick to what the standard guarantees and use the exception (<code>std::bad_alloc</code>) thrown by <code>new</code> (i.e. not use the no-throw <code>new</code>).</p>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "11033396", "Score": "2", "CreationDate": "2012-06-14T12:50:14.340", "LastActivityDate": "2012-06-14T12:50:14.340"}, "bq_ids": {"n4140": {"so_11033120_11033396_0": {"section_id": 7177, "quality": 0.8857142857142857, "length": 31}, "so_11033120_11033396_1": {"section_id": 7178, "quality": 0.847457627118644, "length": 50}, "so_11033120_11033396_2": {"section_id": 7177, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_11033120_11033396_0": {"section_id": 6921, "quality": 0.9142857142857143, "length": 32}, "so_11033120_11033396_1": {"section_id": 6922, "quality": 0.847457627118644, "length": 50}, "so_11033120_11033396_2": {"section_id": 6921, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_11033120_11033396_0": {"section_id": 8685, "quality": 0.8857142857142857, "length": 31}, "so_11033120_11033396_1": {"section_id": 8686, "quality": 0.8135593220338984, "length": 48}, "so_11033120_11033396_2": {"section_id": 8685, "quality": 0.9473684210526315, "length": 18}}}});