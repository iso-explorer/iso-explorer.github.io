post_cb({"8771433": {"ParentId": "8771409", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2012-01-07T17:05:31.783", "Score": "33", "LastEditorUserId": "560648", "LastEditDate": "2012-01-07T17:17:37.963", "Id": "8771433", "OwnerUserId": "560648", "Body": "<p>You're passing an <code>int</code> to this overloaded function.</p>\n<p>Although human intuition says that <code>ambig(signed long)</code> ought to be preferred because your input is a negative integer (which cannot be represented as such by an <code>unsigned long</code>), the two conversions are in fact equivalent in \"precedence\" in C++.</p>\n<p>That is, the conversion <code>int</code> \u2192 <code>unsigned long</code> is considered to be just as valid as <code>int</code> \u2192 <code>signed long</code>, and neither is preferred to the other.</p>\n<p>On the other hand, if your parameter were already a <code>long</code> rather than an <code>int</code>, then there is an <em>exact match</em> to <code>signed long</code>, with no conversion necessary. <a href=\"http://codepad.org/xjBi8uDo\" rel=\"noreferrer\">This avoids the ambiguity</a>.</p>\n<pre><code>void ambig(  signed long) { }\nvoid ambig(unsigned long) { }\n\nint main(void) { ambig(static_cast&lt;long&gt;(-1)); return 0; }\n</code></pre>\n<p>\"Just one of those things\".</p>\n<hr>\n<blockquote>\n<p id=\"so_8771409_8771433_0\"><code>[C++11: 4.13/1]:</code> (\"Integer conversion rank\")</p>\n<p id=\"so_8771409_8771433_1\">Every integer type has an integer conversion rank defined as follows:</p>\n<ul>\n<li>[..]</li>\n<li><strong>The rank of a signed integer type shall be greater than the rank of any signed integer type with a smaller size.</strong></li>\n<li>The rank of <code>long long int</code> shall be greater than <strong>the rank of <code>long int</code></strong>, which <strong>shall be greater than the rank of <code>int</code></strong>, which shall be greater than the rank of <code>short int</code>, which shall be greater than the rank of signed char.</li>\n<li><strong>The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</strong></li>\n<li>[..]</li>\n</ul>\n<p id=\"so_8771409_8771433_2\">[ <em>Note:</em> The integer conversion rank is used in the definition of the integral promotions (4.5) and the usual arithmetic conversions (Clause 5). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Overload resolution is complex, and is defined in <code>[C++11: 13.3]</code>; I shan't bore you by quoting a majority of it here.</p>\n<p>Here's a highlight, though:</p>\n<blockquote>\n<p id=\"so_8771409_8771433_3\"><code>[C++11: 13.3.3.1/8]:</code> If no conversions are required to match an argument to a parameter type, the implicit conversion sequence is the standard conversion sequence consisting of the identity conversion (13.3.3.1.1).</p>\n<p id=\"so_8771409_8771433_4\"><code>[C++11: 13.3.3.1/9]:</code> If no sequence of conversions can be found to convert an argument to a parameter type or the conversion is otherwise ill-formed, an implicit conversion sequence cannot be formed.</p>\n<p id=\"so_8771409_8771433_5\"><code>[C++11: 13.3.3.1/10]:</code> If several different sequences of conversions exist that each convert the argument to the parameter type, the implicit conversion sequence associated with the parameter is defined to be the unique conversion sequence designated the ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences as described in 13.3.3.2, the ambiguous conversion sequence is treated as a user-defined sequence that is indistinguishable from any other user-defined conversion sequence134. If a function that uses the ambiguous conversion sequence is selected as the best viable function, the call will be ill-formed because the conversion of one of the arguments in the call is ambiguous.</p>\n</blockquote>\n<ul>\n<li><code>/10</code> is the case you're experiencing; <code>/8</code> is the case you use with a <code>long</code> argument.</li>\n</ul>\n</hr>", "LastActivityDate": "2012-01-07T17:17:37.963"}, "8771432": {"ParentId": "8771409", "CommentCount": "0", "CreationDate": "2012-01-07T17:05:23.777", "OwnerUserId": "440119", "PostTypeId": "2", "Id": "8771432", "Score": "3", "Body": "<p>Because <code>-1</code> is of type <code>int</code>.  And <code>int</code> can be implicitly converted to either <code>signed long</code> or <code>unsigned long</code>.</p>\n", "LastActivityDate": "2012-01-07T17:05:23.777"}, "8771409": {"CommentCount": "0", "AcceptedAnswerId": "8771433", "PostTypeId": "1", "LastEditorUserId": "541686", "CreationDate": "2012-01-07T17:01:18.743", "LastActivityDate": "2012-08-19T03:20:06.183", "LastEditDate": "2012-08-19T03:20:06.183", "ViewCount": "3996", "FavoriteCount": "3", "Title": "Why is it ambiguous to call overloaded ambig(long) and ambig(unsigned long) with an integer literal?", "Id": "8771409", "Score": "31", "Body": "<p>When compiling</p>\n<pre><code>void ambig(  signed long) { }\nvoid ambig(unsigned long) { }\n\nint main(void) { ambig(-1); return 0; }\n</code></pre>\n<p>I get</p>\n<pre><code>error C2668: 'ambig' : ambiguous call to overloaded function\n    could be 'void ambig(unsigned long)'\n    or 'void ambig(long)'\nwhile trying to match the argument list '(int)'\n</code></pre>\n<p>I know I can 'fix' it by saying <code>-1L</code> instead of <code>-1</code>, but why/how exactly is this considered ambiguous in the first place?</p>\n", "Tags": "<c++><visual-c++><ambiguity>", "OwnerUserId": "541686", "AnswerCount": "3"}, "8771441": {"ParentId": "8771409", "CommentCount": "0", "CreationDate": "2012-01-07T17:06:56.913", "OwnerUserId": "149392", "PostTypeId": "2", "Id": "8771441", "Score": "8", "Body": "<p>The constant <code>-1</code> has the type <code>int</code>. So you're calling <code>ambig</code> with an <code>int</code> as an argument. <code>ambig</code> doesn't have an overload that accepts an <code>int</code>, so we'll have to look at the implicit conversions that we could do. An <code>int</code> can be implicitly converted to a <code>long</code> or an <code>unsigned long</code> (among other things), both of which would be valid arguments to <code>ambig</code>. So the compiler doesn't know which conversion to pick and you need to cast manually (or use a long constant (<code>-1l</code>) instead of an int constant to begin with).</p>\n<p>The fact that <code>-1</code> is a negative number doesn't factor into it because the compiler doesn't look at the arguments value, just its type.</p>\n", "LastActivityDate": "2012-01-07T17:06:56.913"}, "bq_ids": {"n4140": {"so_8771409_8771433_1": {"section_id": 45, "quality": 0.875, "length": 7}, "so_8771409_8771433_5": {"section_id": 615, "quality": 0.9032258064516129, "length": 56}, "so_8771409_8771433_2": {"section_id": 45, "quality": 0.7142857142857143, "length": 10}, "so_8771409_8771433_3": {"section_id": 613, "quality": 0.8235294117647058, "length": 14}, "so_8771409_8771433_4": {"section_id": 614, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_8771409_8771433_4": {"section_id": 604, "quality": 0.8888888888888888, "length": 16}, "so_8771409_8771433_5": {"section_id": 605, "quality": 0.9032258064516129, "length": 56}, "so_8771409_8771433_2": {"section_id": 42, "quality": 0.7142857142857143, "length": 10}, "so_8771409_8771433_3": {"section_id": 603, "quality": 0.8235294117647058, "length": 14}, "so_8771409_8771433_1": {"section_id": 42, "quality": 0.875, "length": 7}}, "n4659": {"so_8771409_8771433_1": {"section_id": 46, "quality": 0.875, "length": 7}, "so_8771409_8771433_5": {"section_id": 641, "quality": 0.9032258064516129, "length": 56}, "so_8771409_8771433_2": {"section_id": 46, "quality": 0.7142857142857143, "length": 10}, "so_8771409_8771433_3": {"section_id": 639, "quality": 0.8235294117647058, "length": 14}, "so_8771409_8771433_4": {"section_id": 640, "quality": 0.7222222222222222, "length": 13}}}});