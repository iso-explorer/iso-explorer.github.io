post_cb({"32029673": {"ParentId": "26268721", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>auto</code> is an unknown type in a type equation; as usual, the type should be defined at some point. A virtual function needs to have a definition, it is always \"used\" even if the function is never called in the program.</p>\n<h1>Short description of the vtable issue</h1>\n<p>Covariant return types are an implementation issue with the vtable: covariant returns is an internally powerful feature (then castrated by arbitrary language rules). Covariance is limited to pointers (and references) derived to base conversions, but the internal power and hence difficulty of implementation is almost the one of arbitrary conversions: derived to base amount to arbitrary code (derived to base restricted to exclusive base class subobjects, aka non-virtual inheritance, would be much simpler).</p>\n<p>Covariance in case of conversion to shared base subobjects (aka virtual inheritance) means that conversion not only can changes the value representation of the pointer, but it also changes its value in an information loosing way, in the general case.</p>\n<p>Hence virtual covariance (covariant return type involving virtual inheritance conversion) means that the overrider cannot be confused with the overridden function in a primary base situation.</p>\n<h1>Detailed explanation</h1>\n<h2>Basic theory of vtables and primary bases</h2>\n<pre><code>struct Primbase {\n    virtual void foo(); // new\n};\n\nstruct Der \n     : Primbase { // primary base \n    void foo(); // replace Primbase::foo()\n    virtual void bar(); // new slot\n};\n</code></pre>\n<p><code>Primbase</code> is the primary base here, it starts at the same address at the derived object. This is extremely important: for the primary base, the up/down conversions can be done with a reinterpret or C style cast in the generated code. Single inheritance is so much easier for the implementer because there are only primary base classes. With multiple inheritance, pointer arithmetic is needed.</p>\n<p>There is only one vptr in <code>Der</code>, the one of <code>Primbase</code>; there is one vtable for <code>Der</code>, layout compatible with the vtable of <code>Primbase</code>.</p>\n<p>Here the usual compiler will not allocate another slot for <code>Der::foo()</code> in the vtable, as the derived function is actually called (in hypothetical the generated C code) with a <code>Primbase*</code> <code>this</code> pointer, not a <code>Der*</code>. The <code>Der</code> vtable has only two slots (plus the RTTI data).</p>\n<h2>Primary covariance</h2>\n<p>Now we add some simple covariance:</p>\n<pre><code>struct Primbase {\n    virtual Primbase *foo(); // new slot in vtable\n};\n\nstruct Der \n     : Primbase { // primary base \n    Der *foo(); // replaces Primbase::foo() in vtable\n    virtual void bar(); // new slot\n};\n</code></pre>\n<p>Here the covariance is trivial, as it involves a primary base. Nothing to see at the compiled code level.</p>\n<h2>Non-zero offset covariance</h2>\n<p>More complex:</p>\n<pre><code>struct Basebelow {\n    virtual void bar(); // new slot\n};\n\nstruct Primbase {\n    virtual Basebelow *foo(); // new\n};\n\nstruct Der \n     : Primbase, // primary base \n       Basebelow { // base at a non zero offset\n    Der *foo(); // new slot?\n};\n</code></pre>\n<p>Here the representation of a <code>Der*</code> isn't the same as the representation of its base class subobject pointer <code>Basebelow*</code>. Two implementations choices:</p>\n<ul>\n<li><p><strong>(settle)</strong> settle on the <code>Basebelow *(Primbase::foo)()</code> virtual call interface for the whole hierarchy: <code>this</code> is a <code>Primbase*</code> (compatible with <code>Der*</code>) but return value type is not compatible (different representation), so the derived function implementation will convert the <code>Der*</code> to a <code>Primbase*</code> (pointer arithmetic) and the caller with convert back when doing a virtual call on a <code>Der</code>;</p></li>\n<li><p><strong>(introduce)</strong> another virtual function slot in the <code>Der</code> vtable for the function returning a <code>Der*</code>. </p></li>\n</ul>\n<h2>Generalized in a sharing hierarchy: virtual covariance</h2>\n<p>In the general case, base class subobjects are shared by different derived class, this is virtual \"diamond\":</p>\n<pre><code>struct B {};\nstruct L : virtual B {};\nstruct R : virtual B {};\nstruct D : L, R {};\n</code></pre>\n<p>Here the conversion to <code>B*</code> is dynamic, based on the runtime type (often using the vptr, or else internal pointers/offsets in the objects, as in MSVC).</p>\n<p>In general, such <strong>conversions to base class subobject lose information</strong> and cannot be undone. There is no reliable <code>B*</code> to <code>L*</code> down conversion. Hence, the <strong>(settle)</strong> choice is not available. The implementation will have to <strong>(introduce)</strong>.</p>\n<h1>Back to <code>auto</code> issue</h1>\n<p><strong>(introduce)</strong> is not a complicated implementation choice, but it makes the vtable grows: the layout of the vtable is determined by the number of <strong>(introduce)</strong> done.</p>\n<p>So the layout of <strong>the vtable is determined by</strong> the number of virtual functions (which we know from class definition), <strong>the presence of covariant virtual functions</strong> (which we can only know from function return types) and <strong>the type of covariance</strong>: primary covariance, non-zero offset covariance or virtual covariance.</p>\n<h1>Conclusion</h1>\n<p>The layout of the vtable can only be determined knowing the return type of virtual <strong>overriders of base class virtual functions returning a pointer (or reference) to a class type</strong>. The vtable computation would have to be delayed when there are such overriders in a class.</p>\n<p>This would complicate the implementation.</p>\n<p><strong>Note:</strong> the terms like \"virtual covariance\" used are all made up, except \"primary base\" which is officially defined in the Itanium C++ ABI.</p>\n<h1>EDIT: Why I think constraint checking is not an issue</h1>\n<p>Checking of covariant constraints is not a problem, doesn't break separate compilation, or the C++ model:</p>\n<h2><code>auto</code> overrider of a class pointer(/ref) pointer returning function</h2>\n<pre><code>struct B {\n    virtual int f();\n    virtual B *g();\n};\n\nstruct D : B {\n    auto f(); // int f() \n    auto g(); // ?\n};\n</code></pre>\n<p>The type of <code>f()</code> is fully constrained and the function definition must return an <code>int</code>.</p>\n<p>The return type of <code>g()</code> is partially constrained: it can be <code>B*</code> or some <code>derived_from_B*</code>. The checking will occur at the definition point.</p>\n<h2>Overriding of an auto virtual function</h2>\n<p>Consider an potential derived class <code>D2</code>:</p>\n<pre><code>struct D2 : D {\n    T1 f(); // T1 must be int \n    T2 g(); // ?\n};\n</code></pre>\n<p>Here the constraints on <code>f()</code> could be checked, as <code>T1</code> must be <code>int</code>, but not the constraints on <code>T2</code>, because the declaration of <code>D::g()</code> is not known. All we know is that <code>T2</code> must be a pointer to a subclass of <code>B</code> (possibly just <code>B</code>).</p>\n<p>The definition of <code>D::g()</code> can be covariant and introduce a stronger constraint:</p>\n<pre><code>auto D::g() { \n    return new D;\n} // covariant D* return\n</code></pre>\n<p>so <code>T2</code> must be a pointer to a class derived from <code>D</code> (possibly just <code>D</code>).</p>\n<p>Before seeing the definition, we cannot know this constraint.</p>\n<p><strong>Because the overriding declaration cannot be checked before seeing the definition, it must be rejected</strong>.</p>\n<p>For simplicity, I think <code>f()</code> should also be rejected.</p>\n", "OwnerUserId": "963864", "LastEditorUserId": "963864", "LastEditDate": "2015-08-15T22:35:50.640", "Id": "32029673", "Score": "3", "CreationDate": "2015-08-15T21:43:38.387", "LastActivityDate": "2015-08-15T22:35:50.640"}, "26268777": {"ParentId": "26268721", "CommentCount": "4", "Body": "<p>The rationale that you included is reasonably clear: naturally, virtual functions are meant to be overridden by subclasses, so you as the designer of the base class should make it as easy as possible for people who inherit your class to provide a suitable override. However, if you use <code>auto</code>, figuring out the return type for the override becomes a tedious task for a programmer. Compilers would have less of a problem with it, but humans would have many opportunities to get confused.</p>\n<p>For example, if you see a return statement that looks like this</p>\n<pre><code>return a * 3 + b;\n</code></pre>\n<p>you would have to trace the program back to the point of declaration of <code>a</code> and <code>b</code>, figure out the type promotions, and decide what the return type shall be.</p>\n<p>It appears that the language designers figured out that this would be rather confusing, and decided against allowing this feature.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "26268777", "Score": "21", "CreationDate": "2014-10-09T01:02:34.883", "LastActivityDate": "2014-10-09T01:02:34.883"}, "26268721": {"CommentCount": "0", "ViewCount": "2366", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2014-10-09T00:55:27.003", "LastActivityDate": "2015-08-15T22:35:50.640", "LastEditDate": "2015-08-15T21:46:28.153", "AcceptedAnswerId": "26268777", "OwnerDisplayName": "user3920237", "Title": "Why can't virtual functions use return type deduction?", "Id": "26268721", "Score": "23", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\">n3797</a> says:</p>\n<p>\u00a7 7.1.6.4/14:</p>\n<blockquote>\n<p id=\"so_26268721_26268721_0\">A function declared with a return type that uses a placeholder type\n  shall not be virtual (10.3).</p>\n</blockquote>\n<p>Therefore the following program is ill-formed:</p>\n<pre><code>struct s\n{\n    virtual auto foo()\n    {\n    }\n};\n</code></pre>\n<p>All I can find for the rationale is this vague one-liner from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\">n3638</a>:</p>\n<blockquote>\n<p id=\"so_26268721_26268721_1\"><strong>virtual</strong> </p>\n<p id=\"so_26268721_26268721_2\">It would be possible to allow return type deduction for virtual\n  functions, but that would complicate both override checking and vtable\n  layout, so it seems preferable to prohibit this.</p>\n</blockquote>\n<p>Can anyone provide further rationale or give a good (code) example that agrees with the above quote?</p>\n", "Tags": "<c++><c++14><auto><virtual-functions><vtable>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26268721_26268721_0": {"section_id": 5458, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_26268721_26268721_0": {"section_id": 382, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_26268721_26268721_0": {"section_id": 6884, "quality": 0.8888888888888888, "length": 8}}}, "26268785": {"ParentId": "26268721", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Well, the deduced return type of the function only becomes known at the point of function <em>definition</em>:   the return type is deduced from the <code>return</code> statements inside the function body.</p>\n<p>Meanwhile, the vtable is built and override semantics is checked based purely on function <em>declarations</em> present in the class definition. These checks never relied on function definition and never needed to see the definition. For example, the language requires the overriding function to have the same return type or a covariant return type as the function it overrides. When non-defining function declaration specifies a deduced return type (i.e. <code>auto</code> without trailing return type), its return type is <em>unknown</em> at that point and remains unknown until the compiler encounters the definition of the function. It is not possible to perform the aforementioned return type check when return type is unknown. Asking the compiler to somehow postpone the return type check to the point where it becomes known would require a major qualitative redesign of this fundamental area of the language specification. (I'm not sure it is even possible.)</p>\n<p>Another alternative would be to relieve the compiler of that burden under the blanket mandate of \"no diagnostics is required\" or \"the behavior is undefined\", i.e. hand the responsibility over to the user, but that would also constitute a major deviation from the former design of the language.</p>\n<p>Basically, for a somewhat similar reason you cannot apply the <code>&amp;</code> operator to a function declared as <code>auto f();</code> but not defined yet, as the example in 7.1.6.3/11 shows.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-10-09T05:52:29.210", "Id": "26268785", "Score": "15", "CreationDate": "2014-10-09T01:05:49.753", "LastActivityDate": "2014-10-09T05:52:29.210"}});