post_cb({"bq_ids": {"n4140": {"so_28714018_28714908_2": {"length": 10, "quality": 1.0, "section_id": 3248}, "so_28714018_28714908_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6076}}, "n3337": {"so_28714018_28714908_2": {"length": 10, "quality": 1.0, "section_id": 3121}, "so_28714018_28714908_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5844}}, "n4659": {"so_28714018_28714908_2": {"length": 10, "quality": 1.0, "section_id": 4006}, "so_28714018_28714908_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 7572}}}, "28714018": {"ViewCount": "603", "Body": "<p>First of all, I've seen <a href=\"https://stackoverflow.com/q/19785518/57428\">this question about C99</a> and the accepted answer references <em>operand is not evaluated</em> wording in the C99 Standard draft. I'm not sure this answer applies to C++03. There's also <a href=\"https://stackoverflow.com/q/7721184/57428\">this question about C++</a> that has an accepted answer citing similar wording and also <em>In some contexts, unevaluated operands appear. An unevaluated operand is not evaluated.</em> wording.</p>\n<p>I have this code:</p>\n<pre><code> int* ptr = 0;\n void* buffer = malloc( 10 * sizeof( *ptr ) );\n</code></pre>\n<p>The question is - is there a null pointer dereference (and so UB) inside <code>sizeof()</code>?</p>\n<p>C++03 5.3.3/1 says <em>The sizeof operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is not evaluated, or a parenthesized type-id.</em></p>\n<p>The linked to answers cite this or similar wording and make use of \"is not evaluated\" part to deduce there's no UB.</p>\n<p>However I cannot find where exactly the Standard links <em>evaluation</em> to having or not having UB in this case.</p>\n<p>Does \"not evaluating\" the expression to which sizeof is applied make it legal to dereference a null or invalid pointer inside sizeof in C++?</p>\n", "AcceptedAnswerId": "28723577", "Title": "Does not evaluating the expression to which sizeof is applied make it legal to dereference a null or invalid pointer inside sizeof in C++?", "CreationDate": "2015-02-25T08:04:15.810", "Id": "28714018", "CommentCount": "16", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:07:34.250", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-15T16:50:04.240", "Score": "10", "OwnerUserId": "57428", "Tags": "<c++><language-lawyer><sizeof><undefined-behavior><null-pointer>", "AnswerCount": "3"}, "28714908": {"Id": "28714908", "PostTypeId": "2", "Body": "<p>Since you explicitly asked for standard references - [expr.sizeof]/1:</p>\n<blockquote>\n<p id=\"so_28714018_28714908_0\">The operand is either <strong>an expression, which is an unevaluated operand\n  (Clause 5)</strong>, or a parenthesized <em>type-id</em>.</p>\n</blockquote>\n<p>[expr]/8:</p>\n<blockquote>\n<p id=\"so_28714018_28714908_1\">In some contexts, <em>unevaluated operands</em> appear (5.2.8, 5.3.3, 5.3.7,\n  7.1.6.2). An unevaluated operand is not evaluated.</p>\n</blockquote>\n<p>Because the expression (i.e. the dereferenciation) is never evaluated, this expression is not subject to some constraints that it would normally be violating. Solely the type is inspected. In fact, the standard uses null references itself in an example in [dcl.fct]/12:</p>\n<blockquote>\n<p id=\"so_28714018_28714908_2\">A <em>trailing-return-type</em> is most useful for a type that would be more\n  complicated to specify before the\n  <em>declarator-id</em>:</p>\n<pre><code>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);\n</code></pre>\n<p id=\"so_28714018_28714908_3\">rather than</p>\n<pre><code>template &lt;class T, class U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);\n</code></pre>\n<p id=\"so_28714018_28714908_4\"><em>\u2014 end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2015-02-25T09:01:38.003", "Score": "4", "CreationDate": "2015-02-25T09:01:38.003", "ParentId": "28714018", "CommentCount": "5", "OwnerUserId": "3647361"}, "28714686": {"Id": "28714686", "PostTypeId": "2", "Body": "<p>The specification only says that dereferencing some pointer that is NULL is UB. Since sizeof() is not a real function, and it doesn't actually use the arguments for anything other than getting the type, it never references the pointer. That's WHY it works. Someone else can get all the points for looking up the spec wording that states that \"the argument to <code>sizeof</code> doesn't get referenced\". </p>\n<p>Note that it's also entirely legal to do <code>int arr[2]; size_t s = sizeof(arr[-111100000]);</code> too - it doesn't matter what the index is, because <code>sizeof</code> never actually \"does anything\" to the argument passed.</p>\n<p>Another example to show how it's \"not doing anything\" would be something like this:</p>\n<pre><code>int func()\n{\n    int *ptr = reinterpret_cast&lt;int*&gt;(32);\n    *ptr = 7;\n    return 42;\n}\n\nsize_t size = sizeof(func()); \n</code></pre>\n<p>Again, this wouldn't crash, because <code>func()</code> is just resolved by the compiler to the type that it produces.</p>\n<p>Equally, if <code>sizeof</code> actually \"does something\" with the argument, what would happen when you do this:</p>\n<pre><code>   char *buffer = new sizeof(char[10000000000]);\n</code></pre>\n<p>Would it create a <code>10000000000</code> stack allocation, then give the size back after it crashed the code because there isn't enough megabytes of stack? [In some systems, stack size is counted in bytes, not megabytes]. And whilst nobody writes code like that, you could easily come up with something similar using <code>typedef</code> of either <code>buffer_type</code> as an array of <code>char</code>, or some kind of <code>struct</code> with large content.</p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2015-02-25T09:26:28.113", "Score": "4", "CreationDate": "2015-02-25T08:49:30.883", "ParentId": "28714018", "CommentCount": "16", "LastEditDate": "2015-02-25T09:26:28.113", "OwnerUserId": "1919155"}, "28723577": {"Id": "28723577", "PostTypeId": "2", "Body": "<p>I believe this is currently underspecified in the standard, like many issues such as <a href=\"https://stackoverflow.com/q/14991219/1708801\">What is the value category of the operands of C++ operators when unspecified?</a>. I don't think it was intentional, like hvd points outs it is probably obvious to the committee.</p>\n<p>In this specific case I think we have the evidence to show what the intention was. From <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3118.html#GB91\" rel=\"nofollow noreferrer\">GB 91 comment from the Rapperswil meeting</a> which says:</p>\n<blockquote>\n<p id=\"so_28714018_28723577_0\">It is mildly distasteful to dereference a null pointer as part of our specification, as we are playing on the edges of undefined behaviour. With the addition of the declval function template, already used in these same expressions, this is no longer necessary.   </p>\n</blockquote>\n<p>and suggested an alternate expression, it refers to this expression which is no longer in the standard but can be found in <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2010/n3090.pdf\" rel=\"nofollow noreferrer\">N3090</a>:</p>\n<pre><code>noexcept(*(U*)0 = declval&lt;U&gt;())\n</code></pre>\n<p>The suggestion was rejected since this does not invoke undefined behavior since it is unevaluated:</p>\n<blockquote>\n<p id=\"so_28714018_28723577_1\">There is no undefined behavior because the expression is an unevaluated operand. It's not at all clear that the proposed change would be clearer.</p>\n</blockquote>\n<p>This rationale applies to <code>sizeof</code> as well since it's operands are unevaluated.</p>\n<p>I say underspecified but I wonder if this is covered by section <code>4.1</code> <em>[conv.lval]</em> which says:</p>\n<blockquote>\n<p id=\"so_28714018_28723577_2\">The value contained in the object indicated by the lvalue is the rvalue result. When an lvalue-to-rvalue conversion occurs\n  within the operand of sizeof (5.3.3) the value contained in the referenced object is not accessed, since that operator\n  does not evaluate its operand.</p>\n</blockquote>\n<p>It says the value contained is not accessed, which if we follow the logic of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">issue 232</a> means there is no undefined behavior:</p>\n<blockquote>\n<p id=\"so_28714018_28723577_3\">In other words, it is only the act of \"fetching\", of lvalue-to-rvalue conversion, that triggers the ill-formed or undefined behavior</p>\n</blockquote>\n<p>This is somewhat speculative since the issue is not settled yet.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-15T16:50:04.240", "Score": "6", "CreationDate": "2015-02-25T15:56:18.687", "ParentId": "28714018", "CommentCount": "0", "LastEditDate": "2017-05-23T11:52:26.310", "OwnerUserId": "1708801"}});