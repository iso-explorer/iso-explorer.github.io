post_cb({"bq_ids": {"n4140": {"so_48259160_48261043_1": {"length": 36, "quality": 0.972972972972973, "section_id": 480}, "so_48259160_48261043_0": {"length": 13, "quality": 1.0, "section_id": 480}}, "n3337": {"so_48259160_48261043_1": {"length": 36, "quality": 0.972972972972973, "section_id": 471}, "so_48259160_48261043_0": {"length": 13, "quality": 1.0, "section_id": 471}}, "n4659": {"so_48259160_48261043_1": {"length": 37, "quality": 1.0, "section_id": 502}, "so_48259160_48261043_0": {"length": 13, "quality": 1.0, "section_id": 502}, "so_48259160_48261043_2": {"length": 12, "quality": 1.0, "section_id": 502}}}, "48259160": {"ViewCount": "109", "Body": "<p>After reading about copy elision of <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">cppreference</a> I wanted to play with exceptions and copy elision. \nSo I wrote the following code with gcc 7.2 on <a href=\"http://coliru.stacked-crooked.com/a/bc566db0e757b85e\" rel=\"nofollow noreferrer\">coliru</a> </p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Exception\n{\npublic:\n    Exception() { std::cout &lt;&lt; \"constructed\\n\"; }\n    Exception(Exception&amp; other) {std::cout &lt;&lt; \"copy constructed\\n\";}\n    Exception(const Exception&amp; other) {std::cout &lt;&lt; \"copy constructed\\n\";}\n    Exception(Exception&amp;&amp; other) {std::cout &lt;&lt; \"move constructed\\n\";}\n};\n\nvoid foo()\n{\n    throw Exception();\n}\n\nint main()\n{\n    try\n    {\n        foo();\n    }\n    catch(Exception e )\n    {\n\n    }\n}\n</code></pre>\n<p>Output </p>\n<blockquote>\n<p id=\"so_48259160_48259160_0\">constructed<br>\n  copy constructed</br></p>\n</blockquote>\n<p>We can see that the copy constructor is called and this happens even when gcc is invoked with -O2. \nIt seems to me that this code should be eligible to copy elision according to the following clause :</p>\n<blockquote>\n<p id=\"so_48259160_48259160_1\">When handling an exception, if the argument of the catch clause is of\n  the same type (ignoring top-level cv-qualification) as the exception\n  object thrown, the copy is omitted and the body of the catch clause\n  accesses the exception object directly, as if caught by reference.</p>\n</blockquote>\n<p>So why is the copy constructor called? Why does copy elision not work in this case?</p>\n", "AcceptedAnswerId": "48261043", "Title": "Copy elision and exceptions", "CreationDate": "2018-01-15T08:20:43.587", "LastActivityDate": "2018-01-15T12:26:32.923", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-15T12:26:32.923", "LastEditorUserId": "597607", "Id": "48259160", "Score": "6", "OwnerUserId": "5076707", "Tags": "<c++><exception><copy-constructor>", "AnswerCount": "1"}, "48261043": {"Id": "48261043", "PostTypeId": "2", "Body": "<p>cppreference is inaccurate on this. There is in fact no guarantee that the copy will be elided except in a <em>constant expression</em> (<code>constexpr</code>) or a <em>constant initialization</em> (static or thread-local). That is not the case in your example.</p>\n<p>See <a href=\"http://eel.is/c++draft/class.copy.elision#1\" rel=\"noreferrer\">[class.copy.elision]/1</a> in the current C++17 draft (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48259160_48261043_0\">When certain criteria are met, ... elision of copy/move operations, called copy elision, is <strong><em>permitted</em></strong> in the following circumstances:</p>\n<p id=\"so_48259160_48261043_1\">\u2014 in a <em>throw-expression</em>, when the operand is the name of a non-volatile automatic object (other than a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost enclosing try-block (if there is one), the copy/move operation from the operand to the exception object can be omitted by constructing the automatic object directly into the exception object</p>\n<p id=\"so_48259160_48261043_2\">Copy elision is <strong><em>required</em></strong> where an expression is evaluated in a context requiring a <em>constant expression</em> and in <em>constant initialization</em>.</p>\n</blockquote>\n<p>That means that some day it may be implemented as a compiler optimization, it is just not the case currently.</p>\n<p>It would be wise therefore to <code>catch</code> by <code>const&amp;</code> for the time being (also to avoid accidental slicing).</p>\n", "LastActivityDate": "2018-01-15T10:26:42.840", "Score": "5", "CreationDate": "2018-01-15T10:26:42.840", "ParentId": "48259160", "CommentCount": "0", "OwnerUserId": "485343"}});