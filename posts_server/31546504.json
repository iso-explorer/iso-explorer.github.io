post_cb({"bq_ids": {"n4140": {"so_31546504_31546666_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 481}}, "n4659": {"so_31546504_31546666_0": {"length": 30, "quality": 0.7142857142857143, "section_id": 504}}}, "31546666": {"Id": "31546666", "PostTypeId": "2", "LastEditDate": "2015-07-21T18:35:56.183", "CommentCount": "9", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-21T18:35:56.183", "CreationDate": "2015-07-21T18:15:56.207", "ParentId": "31546504", "Score": "2", "Body": "<p><code>ScriptThread</code> is noncopyable (the implicit copy constructor/assignment operators are defined as deleted because you declared move constructor/assignment). In <code>spawn()</code>, your original implementation:</p>\n<pre><code>ScriptThread ScriptThread::spawn(const Script &amp;script) {\n    return spawn().execute(script);\n}\n</code></pre>\n<p>is attempting to construct a <code>ScriptThread</code> from an <em>lvalue</em> reference (<code>execute</code> returns a <code>ScriptThread&amp;</code>). That will call the copy constructor, which is deleted, hence the error.</p>\n<p>However, in your second attempt:</p>\n<pre><code>ScriptThread ScriptThread::spawn(const Script &amp;script) {\n    ScriptThread thread = spawn();\n    thread.execute(script);\n    return thread;\n}\n</code></pre>\n<p>we run into the rule, from [class.copy]:</p>\n<blockquote>\n<p id=\"so_31546504_31546666_0\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the\n  object to be copied is designated by an lvalue, <strong>or when the expression in a return statement is a (possibly\n  parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body</strong> or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>, overload resolution\n  to select the constructor for the copy is first performed <strong>as if the object were designated by an rvalue</strong>.</p>\n</blockquote>\n<p>Even though <code>thread</code> is an lvalue, we perform overload resolution on the constructor of <code>ScriptThread</code> as if it were an rvalue. And we do have a valid constructor for this case: your move constructor/assignment. </p>\n<p>That's why the replacement is valid (and uses move construction), but the original failed to compile (because it required copy construction). </p>\n", "OwnerUserId": "2069064"}, "31546504": {"ViewCount": "65", "Body": "<p>I've written a class similar to the following:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class ScriptThread {\npublic:\n    ScriptThread(): mParent() {}\n\nprivate:\n    ScriptThread(ScriptThread *parent): mParent(parent) {}\n\npublic:\n    ScriptThread(ScriptThread &amp;&amp;rhs);\n    ScriptThread &amp;operator = (ScriptThread &amp;&amp;rhs);\n    // copy constructor/assignment deleted implicitly\n\n    ScriptThread &amp;execute(const Script &amp;script);\n    ScriptThread spawn();\n    ScriptThread spawn(const Script &amp;script);\n\nprivate:\n    ScriptThread *mParent;\n};\n\nScriptThread &amp;ScriptThread::execute(const Script &amp;script) {\n    // start executing the given script\n    return *this;\n}\n\nScriptThread ScriptThread::spawn() {\n    // create a ScriptThread with \"this\" as its parent\n    return ScriptThread(this);\n}\n\nScriptThread ScriptThread::spawn(const Script &amp;script) {\n    // convenience method to spawn and execute at the same time\n    return spawn().execute(script); // ERROR: \"use of deleted function\"\n}\n</code></pre>\n<p>As written, g++ fails to compile it at the line marked \"ERROR\", claiming that it's trying to use the (deleted) copy constructor.  However, if I replace the last function with this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>ScriptThread ScriptThread::spawn(const Script &amp;script) {\n    ScriptThread thread = spawn();\n    thread.execute(script);\n    return thread;\n}\n</code></pre>\n<p>It compiles without an error.  Even after referring to a number of articles, references, and other SO questions, I don't understand: why does the first invoke the copy constructor at all?  Isn't the move constructor enough?</p>\n", "AcceptedAnswerId": "31546666", "Title": "Return reference to *this without a copy constructor?", "CreationDate": "2015-07-21T18:07:04.470", "Id": "31546504", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-07-21T18:44:04.947", "Score": "0", "OwnerUserId": "1287112", "Tags": "<c++11><copy-constructor><move-constructor><return-by-reference><return-by-value>", "AnswerCount": "2"}, "31546977": {"Id": "31546977", "PostTypeId": "2", "LastEditDate": "2015-07-21T18:44:04.947", "CommentCount": "1", "LastEditorUserId": "981959", "LastActivityDate": "2015-07-21T18:44:04.947", "CreationDate": "2015-07-21T18:32:37.527", "ParentId": "31546504", "Score": "3", "Body": "<p><code>execute(script)</code> returns an lvalue. You can't implicitly move from an lvalue, so to use the move constructor for the returned object you would need to say</p>\n<pre><code>return std::move(spawn().execute(script));\n</code></pre>\n<p>You didn't do this so it tries to use the copy constructor, because that's how you make new objects from lvalues.</p>\n<p>In your replacement case you have:</p>\n<pre><code>return thread;\n</code></pre>\n<p>Here <code>thread</code> is also an lvalue, <em>but</em> it's about to go out of scope as soon as the function ends, so conceptually it can be considered to be like a temporary or other variable that is going to disappear at the end of the expression. Because of this there is a special rule in the C++ standard that says the compiler treats such local variables as rvalues, allowing the move constructor to be used <em>even though <code>thread</code> is really an lvalue</em>.</p>\n<p>See Barry's more complete answer for the references to the standard where the special rule is defined, and the full details of the rule.</p>\n", "OwnerUserId": "981959"}});