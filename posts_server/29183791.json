post_cb({"29187612": {"ParentId": "29183791", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Did you intend to use <code>&amp;&amp;</code> in <code>std::tuple&lt;Types&amp;&amp;...&gt;</code> as a universal reference? This is not universal reference; it is rvalue reference and can only bind to rvalues. You can do like this to check what kind of reference it is:</p>\n<pre><code>template&lt;typename T&gt;\nclass TD;\n</code></pre>\n<p>Then define your template function:</p>\n<pre><code>template &lt;typename... Types&gt;\nvoid print_tuple(const std::tuple&lt;Types&amp;&amp;...&gt;&amp; value)\n{\n    TD&lt;decltype(value)&gt; a;\n    std::cout &lt;&lt; std::get&lt;0&gt;(value) &lt;&lt; \",\" &lt;&lt; std::get&lt;1&gt;(value) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Then you will see the compilation error like:</p>\n<pre><code>implicit instantiation of undefined template 'TD&lt;const std::__1::tuple&lt;std::__1::basic_string&lt;char&gt; &amp;&amp;, int &amp;&amp;&gt; &amp;&gt;'\n</code></pre>\n<p>You can see that even for the <code>int</code> type, it deduces to be rvalue reference. Rvalue references cannot bind to lvalues. You can try that by calling:</p>\n<pre><code>int i = 1;\nprint_tuple(std::forward_as_tuple(i,1)); // error.\n</code></pre>\n<p>Therefore, it is correct that <code>const char(&amp;&amp;)[5]</code> is deduced, and a string literal cannot be converted to <code>const char(&amp;&amp;)[5]</code>. If you call <code>print_tuple</code> like:</p>\n<pre><code>print_tuple(std::forward_as_tuple(string(\"test\"),1));\n</code></pre>\n<p>It will work. Now the type is <code>tuple&lt;string&amp;&amp;, int&amp;&amp;&gt;</code>.</p>\n", "OwnerUserId": "897297", "LastEditorUserId": "897297", "LastEditDate": "2015-03-21T20:38:11.110", "Id": "29187612", "Score": "0", "CreationDate": "2015-03-21T20:20:29.103", "LastActivityDate": "2015-03-21T20:38:11.110"}, "29183791": {"CommentCount": "4", "ViewCount": "619", "CreationDate": "2015-03-21T14:25:10.577", "LastActivityDate": "2015-03-21T22:31:33.597", "Title": "deduce the type of tuple elements in c++11", "AcceptedAnswerId": "29188808", "PostTypeId": "1", "Id": "29183791", "Score": "6", "Body": "<p>I have the following code.</p>\n<pre><code>template &lt;typename... Types&gt;\nvoid print_tuple(const std::tuple&lt;Types&amp;&amp;...&gt;&amp; value)\n{\n    std::cout &lt;&lt; std::get&lt;0&gt;(value) &lt;&lt; \",\" &lt;&lt; std::get&lt;1&gt;(value) &lt;&lt; std::endl;\n}\nprint_tuple(std::forward_as_tuple(\"test\",1));\n</code></pre>\n<p>which compiler complains about</p>\n<pre><code>error: invalid initialization of reference of type \u2018const std::tuple&lt;const char (&amp;&amp;)[5], int&amp;&amp;&gt;&amp;\u2019 from expression of type \u2018std::tuple&lt;const char (&amp;)[5], int&amp;&amp;&gt;\u2019\n     print_tuple(std::forward_as_tuple(\"test\",1));\n</code></pre>\n<p>why does compiler deduce the type of the first element in the tuple to be const char (&amp;&amp;)[5]?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4696339", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29183791_29188808_6": {"section_id": 282, "quality": 0.5714285714285714, "length": 4}, "so_29183791_29188808_1": {"section_id": 339, "quality": 1.0, "length": 15}, "so_29183791_29188808_7": {"section_id": 304, "quality": 1.0, "length": 13}, "so_29183791_29188808_5": {"section_id": 341, "quality": 0.9615384615384616, "length": 50}}, "n3337": {"so_29183791_29188808_6": {"section_id": 273, "quality": 0.5714285714285714, "length": 4}, "so_29183791_29188808_1": {"section_id": 329, "quality": 1.0, "length": 15}, "so_29183791_29188808_7": {"section_id": 295, "quality": 1.0, "length": 13}, "so_29183791_29188808_5": {"section_id": 331, "quality": 0.9615384615384616, "length": 50}}, "n4659": {"so_29183791_29188808_6": {"section_id": 289, "quality": 0.5714285714285714, "length": 4}, "so_29183791_29188808_1": {"section_id": 348, "quality": 1.0, "length": 15}, "so_29183791_29188808_7": {"section_id": 311, "quality": 1.0, "length": 13}, "so_29183791_29188808_5": {"section_id": 350, "quality": 0.8653846153846154, "length": 45}}}, "29188808": {"ParentId": "29183791", "CommentCount": "0", "Body": "<p>Generally speaking, for deduction to succeed, the argument needs to have the same general form as the parameter. There are some exceptions where <code>T &amp;&amp;</code> can be deduced from <code>U &amp;</code> (by selecting <code>T = U &amp;</code>), but no such exception was specified for this case.</p>\n<blockquote>\n<p id=\"so_29183791_29188808_0\"><strong>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</strong></p>\n<p id=\"so_29183791_29188808_1\">8 A template type argument <code>T</code>, a template template argument <code>TT</code> or a template non-type argument <code>i</code> can be deduced if <code>P</code> and <code>A</code> have one of the following forms:</p>\n<p id=\"so_29183791_29188808_2\">[...]</p>\n<p id=\"so_29183791_29188808_3\"><code>T&amp;</code><br>\n<code>T&amp;&amp;</code></br></p>\n<p id=\"so_29183791_29188808_4\">[...]</p>\n</blockquote>\n<p>It's not exactly clear, but this requires <code>P</code> (the parameter) and <code>A</code> (the argument) to both have the same form. They need to both be of the <code>T&amp;</code> form, or both of the <code>T&amp;&amp;</code> form. The exceptions, the circumstances where <code>T &amp;&amp;</code> can be deduced from <code>U &amp;</code>, are done by changing <code>T &amp;&amp;</code> to plain <code>T</code> before the matching takes place, in limited circumstances:</p>\n<blockquote>\n<p id=\"so_29183791_29188808_5\">10 Similarly, if <code>P</code> has a form that contains <code>(T)</code>, then each parameter type <code>P<sub><em>i</em></sub></code> of the respective <em>parameter-type-list</em> of <code>P</code> is compared with the corresponding parameter type <code>A<sub><em>i</em></sub></code> of the corresponding <em>parameter-type-list</em> of <code>A</code>. If <code>P</code> and <code>A</code> are function types that originated from deduction when taking the address of a function template (14.8.2.2) or when deducing template arguments from a function declaration (14.8.2.6) and <code>P<sub><em>i</em></sub></code> and\n  <code>A<sub><em>i</em></sub></code> are parameters of the top-level <em>parameter-type-list</em> of <code>P</code> and <code>A</code>, respectively, <code>P<sub><em>i</em></sub></code> is adjusted if it is an rvalue reference to a cv-unqualified template parameter and <code>A<sub><em>i</em></sub></code> is an lvalue reference, in which case the type of <code>P<sub><em>i</em></sub></code> is changed to be the template parameter type (i.e., <code>T&amp;&amp;</code> is changed to simply <code>T</code>). [...]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_29183791_29188808_6\"><strong>14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]</strong></p>\n<p id=\"so_29183791_29188808_7\">3 [...] If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \"lvalue reference to <code>A</code>\" is used in place of <code>A</code> for type deduction. [...]</p>\n</blockquote>\n<p>but no similar exception applies to your scenario.</p>\n<p>It's this same principle that renders</p>\n<pre><code>template &lt;typename T&gt; struct S { };\ntemplate &lt;typename T&gt; void f(S&lt;const T&gt;) { }\nint main() { f(S&lt;void()&gt;()); }\n</code></pre>\n<p>invalid: <code>const T</code> cannot be deduced from <code>void()</code>, even though <code>T = void()</code> would give exactly that result, and calling <code>f&lt;void()&gt;</code> would succeed.</p>\n<p>Wintermute's deleted answer showed that you can use</p>\n<blockquote id=\"so_29183791_29188808_8\">\n<pre><code>template &lt;typename... Types&gt;       // vv-- change here\nvoid print_tuple(const std::tuple&lt;Types...&gt;&amp; value)\n</code></pre>\n</blockquote>\n<p>instead: this allows <code>Types</code> to be deduced as lvalue references, as rvalue references, or as non-references, depending on the type of <code>value</code>.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "29188808", "Score": "2", "CreationDate": "2015-03-21T22:31:33.597", "LastActivityDate": "2015-03-21T22:31:33.597"}});