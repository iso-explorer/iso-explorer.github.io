post_cb({"11711991": {"Id": "11711991", "PostTypeId": "2", "Body": "<p>C++11 removes the need for manual locking. Concurrent execution shall wait if a static local variable is already being initialized.</p>\n<p><code>\u00a76.7 [stmt.dcl] p4</code></p>\n<blockquote>\n<p id=\"so_11711920_11711991_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>As such, simple have a <code>static</code> function like this:</p>\n<pre><code>static Singleton&amp; get(){\n  static Singleton instance;\n  return instance;\n}\n</code></pre>\n<p>This will work all-right in C++11 (as long as the compiler properly implements that part of the standard, of course).</p>\n<hr>\n<p>Of course, the <em>real</em> correct answer is <a href=\"http://www.onelib.org/article/singletons-solving-problems-you-didnt-know-you-never-had-since-1995\" rel=\"noreferrer\">to <em>not</em> use a singleton, period</a>.</p>\n</hr>", "LastEditorUserId": "6287794", "LastActivityDate": "2016-08-25T17:14:20.320", "Score": "109", "CreationDate": "2012-07-29T18:52:21.700", "ParentId": "11711920", "CommentCount": "16", "OwnerUserId": "500104", "LastEditDate": "2016-08-25T17:14:20.320"}, "11712515": {"Id": "11712515", "PostTypeId": "2", "Body": "<p>It is hard to read your approach as you are not using the code as intended... that is, the common pattern for a singleton is calling <code>instance()</code> to get the single instance, then use it (also, if you really want a singleton, no constructor should be public).</p>\n<p>At any rate, I don't think that your approach is safe, consider that two threads try to acquire the singleton, the first one that gets to update the flag will be the only one initializing, but the <code>initialize</code> function will exit early on the second one, and that thread might proceed to use the singleton <em>before</em> the first thread got around to complete initialization.</p>\n<p>The semantics of your <code>initialize</code> are broken. If you try to <em>describe</em> / <em>document</em> the behavior of the function you will have some fun, and will end up describing the implementation rather than a simple operation. Documenting is usually a simple way to double check a design/algorithm: if you end up describing <em>how</em>  rather than <em>what</em>, then you should get back to design. In particular, there is no guarantee that after <code>initialize</code> completes the object has actually been initialized (only if the returned value is <code>true</code>, and sometimes if it is <code>false</code>, but not always).</p>\n", "LastActivityDate": "2012-07-29T20:07:13.727", "CommentCount": "1", "CreationDate": "2012-07-29T20:07:13.727", "ParentId": "11711920", "Score": "2", "OwnerUserId": "36565"}, "28050250": {"Id": "28050250", "PostTypeId": "2", "Body": "<p>IMHO, the best way to implement singletons is with a \"double-check, single-lock\" pattern, which you can implement portably in C++ 11:\n<a href=\"http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/\" rel=\"nofollow noreferrer\">Double-Checked Locking Is Fixed In C++11</a>\nThis pattern is fast in the already-created case, requiring only a single pointer comparison, and safe in the first-use case.</p>\n<p>As mentioned in previous answer, C++ 11 guarantees construction-order safety for static local variables <a href=\"https://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11\">Is local static variable initialization thread-safe in C++11?</a> so you are safe using that pattern.  However, Visual Studio 2013 does not yet support it :-( <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/hh567368(v=vs.120).aspx\" rel=\"nofollow noreferrer\">See the \"magic statics\" row on this page</a>, so if you are using VS2013 you still need to do it yourself.</p>\n<p>Unfortunately, nothing is ever simple.  The <a href=\"http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/\" rel=\"nofollow noreferrer\">sample code</a> referenced for the pattern above cannot be called from CRT initialization, because the static std::mutex has a constructor, and is thus not guaranteed to be initialized before the first call to get the singleton, if said call is a side-effect of CRT initialization.  To get around <strong>that</strong>, you have to use, not a mutex, but a pointer-to-mutex, which is guaranteed to be zero-initialized before CRT initialization starts.  Then you would have to use std::atomic::compare_exchange_strong to create and use the mutex.</p>\n<p>I am assuming that the C++ 11 thread-safe local-static-initialization semantics work even when called during CRT initialization.</p>\n<p>So if you have the C++ 11 thread-safe local-static-initialization semantics available, use them.  If not, you have some work to do, even moreso if you want your singleton to be thread-safe during CRT initialization.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-20T16:21:43.123", "Score": "1", "CreationDate": "2015-01-20T16:21:43.123", "ParentId": "11711920", "CommentCount": "0", "OwnerUserId": "1366016", "LastEditDate": "2017-05-23T12:18:20.013"}, "bq_ids": {"n4140": {"so_11711920_11711991_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_11711920_11711991_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_11711920_11711991_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "11711920": {"ViewCount": "48918", "Body": "<p>Now that C++11 has multithreading I was wondering what is the correct way to implement lazy initialized singleton without using mutexes(for perf reasons).\nI came up with this, but tbh Im not really good at writing lockfree code, so Im looking for some better solutions.</p>\n<pre><code>// ConsoleApplication1.cpp : Defines the entry point for the console application.\n//\n# include &lt;atomic&gt;\n# include &lt;thread&gt;\n# include &lt;string&gt;\n# include &lt;iostream&gt;\nusing namespace std;\nclass Singleton\n{\n\npublic:\n    Singleton()\n    {\n    }\nstatic  bool isInitialized()\n    {\n        return (flag==2);\n    }\nstatic  bool initizalize(const string&amp; name_)\n    {\n        if (flag==2)\n            return false;// already initialized\n        if (flag==1)\n            return false;//somebody else is initializing\n        if (flag==0)\n        {\n            int exp=0;\n            int desr=1;\n            //bool atomic_compare_exchange_strong(std::atomic&lt;T&gt;* obj, T* exp, T desr)\n            bool willInitialize=std::atomic_compare_exchange_strong(&amp;flag, &amp;exp, desr);\n            if (! willInitialize)\n            {\n                //some other thread CASed before us\n                std::cout&lt;&lt;\"somebody else CASed at aprox same time\"&lt;&lt; endl;\n                return false;\n            }\n            else \n            {\n                initialize_impl(name_);\n                assert(flag==1);\n                flag=2;\n                return true;\n            }\n        }\n    }\nstatic void clear()\n{\n    name.clear();\n    flag=0;\n}\nprivate:\nstatic  void initialize_impl(const string&amp; name_)\n{\n        name=name_;\n}\nstatic  atomic&lt;int&gt; flag;\nstatic  string name;\n};\natomic&lt;int&gt; Singleton::flag=0;\nstring Singleton::name;\nvoid myThreadFunction()\n{\n    Singleton s;\n    bool initializedByMe =s.initizalize(\"1701\");\n    if (initializedByMe)\n        s.clear();\n\n}\nint main()\n{\n    while (true)\n    {\n        std::thread t1(myThreadFunction);\n        std::thread t2(myThreadFunction);\n        t1.join();\n        t2.join();\n    }\n    return 0;\n}\n</code></pre>\n<p>Note that <code>clear()</code> is just for testing, real singleton wouldnt have that function.</p>\n", "AcceptedAnswerId": "11711991", "Title": "How to implement multithread safe singleton in C++11 without using <mutex>", "CreationDate": "2012-07-29T18:42:33.580", "Id": "11711920", "CommentCount": "0", "FavoriteCount": "30", "PostTypeId": "1", "LastEditDate": "2012-07-29T19:13:52.883", "LastEditorUserId": "500104", "LastActivityDate": "2016-08-25T17:14:20.320", "Score": "52", "OwnerUserId": "700825", "Tags": "<c++><multithreading><c++11><singleton><atomic>", "AnswerCount": "4"}, "34653512": {"Id": "34653512", "PostTypeId": "2", "Body": "<p>For me the best way to implement a singleton using c++11 is:</p>\n<pre><code>class Singleton\n{\npublic:\nstatic Singleton &amp; Instance()\n{\n    // Since it's a static variable, if the class has already been created,\n    // It won't be created again.\n    // And it **is** thread-safe in C++11.\n\n    static Singleton myInstance;\n\n    // Return a reference to our instance.\n    return myInstance;\n}\n\n// delete copy and move constructors and assign operators\nSingleton(Singleton const&amp;) = delete;             // Copy construct\nSingleton(Singleton&amp;&amp;) = delete;                  // Move construct\nSingleton&amp; operator=(Singleton const&amp;) = delete;  // Copy assign\nSingleton&amp; operator=(Singleton &amp;&amp;) = delete;      // Move assign\n\n// Any other public methods\n\nprotected:\nSingleton()\n{\n     // Constructor code goes here.\n}\n\n~Singleton()\n{\n     // Destructor code goes here.\n}\n\n // And any other protected methods.\n}\n</code></pre>\n", "LastActivityDate": "2016-01-07T11:03:09.517", "CommentCount": "1", "CreationDate": "2016-01-07T11:03:09.517", "ParentId": "11711920", "Score": "21", "OwnerUserId": "4211031"}});