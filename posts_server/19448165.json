post_cb({"bq_ids": {"n4140": {"so_19448165_19449007_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 51}}, "n3337": {"so_19448165_19449007_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 46}}, "n4659": {"so_19448165_19449007_0": {"length": 33, "quality": 0.6875, "section_id": 52}}}, "19448165": {"ViewCount": "191", "Body": "<p>I understand that a template cannot appear inside an <code>extern \"C\"</code> block, the reason for which is that the <em>name</em> of the instantiated template functions cannot appear once than once using an unmangled name.</p>\n<p>However, in the code below, the name of the function <em>is</em> being mangled (so there should be no problem because each instantiation will have a unique name) but still has function type with C language linkage. My question is whether the code below is well formed:</p>\n<pre><code>extern \"C\" using fn_type = void();\n\ntemplate&lt;typename T&gt;\nfn_type foo;\n\nint main()\n{\n    fn_type* const p = foo&lt;int&gt;;\n    p();\n}\n</code></pre>\n<p>Edit: it is hard to test if this is conforming just by running it through a compiler because GCC, Clang and MSVC don't distinguish between C++ and C function pointer types.</p>\n", "AcceptedAnswerId": "19449007", "Title": "C language linkage typedef & templates", "CreationDate": "2013-10-18T11:07:06.030", "Id": "19448165", "CommentCount": "5", "LastEditDate": "2015-06-23T20:24:48.740", "PostTypeId": "1", "LastEditorUserId": "7028", "LastActivityDate": "2015-06-23T20:24:48.740", "Score": "1", "OwnerUserId": "2491746", "Tags": "<c++><c><templates><typedef><linkage>", "AnswerCount": "1"}, "19449007": {"Id": "19449007", "PostTypeId": "2", "Body": "<p>To me, the standard does not seem 100% clear on this. The only relevant part which mentions templates and linkage is C++11, [temp]\u00a74:</p>\n<blockquote>\n<p id=\"so_19448165_19449007_0\">A template name has linkage (3.5). A non-member function template can have internal linkage; any other template name shall have external linkage. Specializations (explicit or implicit) of a template that has internal linkage are distinct from all specializations in other translation units. <strong>A template, a template explicit specialization (14.7.3), and a class template partial specialization shall not have C linkage.</strong> Use of a linkage specification other than C or C++ with any of these constructs is conditionally-supported, with implementation-defined semantics. <em>[...]</em></p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>The paragraph starts with template <em>names</em> having linkage. Then it says \"funciton <em>template</em> <code>(not</code><em><code>name</code></em><code>)</code> can have internal linkage; any other template <em>name</em> shall have external linkage.\"</p>\n<p>To me, this seems to imply referring to the linkage of a template refers to the linkage of the template's <em>name.</em> If that interpretation is correct, then your example is well-formed, as the bolded part would apply to template <em>names</em> as well. Then nothing prevents function template <em>types</em> from having C linkage.</p>\n<p>That's how I would interpret the standard.</p>\n", "LastActivityDate": "2013-10-18T11:52:35.513", "CommentCount": "0", "CreationDate": "2013-10-18T11:52:35.513", "ParentId": "19448165", "Score": "1", "OwnerUserId": "1782465"}});