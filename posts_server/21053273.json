post_cb({"bq_ids": {"n4140": {"so_21053273_21213706_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 5564}, "so_21053273_21053273_2": {"length": 17, "quality": 1.0, "section_id": 5942}, "so_21053273_21053273_3": {"length": 19, "quality": 0.8636363636363636, "section_id": 5944}, "so_21053273_21053273_4": {"length": 47, "quality": 0.9038461538461539, "section_id": 6064}, "so_21053273_21053756_0": {"length": 24, "quality": 0.96, "section_id": 6064}, "so_21053273_21213706_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 5559}, "so_21053273_21053273_1": {"length": 10, "quality": 1.0, "section_id": 0}}, "n3337": {"so_21053273_21213706_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 5346}, "so_21053273_21053273_2": {"length": 17, "quality": 1.0, "section_id": 5713}, "so_21053273_21053273_4": {"length": 44, "quality": 0.8461538461538461, "section_id": 5832}, "so_21053273_21053756_0": {"length": 24, "quality": 0.96, "section_id": 5832}, "so_21053273_21053273_1": {"length": 10, "quality": 1.0, "section_id": 0}, "so_21053273_21053273_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5715}, "so_21053273_21053273_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 5}, "so_21053273_21213706_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 5341}}, "n4659": {"so_21053273_21213706_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 7011}, "so_21053273_21053273_2": {"length": 17, "quality": 1.0, "section_id": 7426}, "so_21053273_21053273_4": {"length": 45, "quality": 0.8653846153846154, "section_id": 7560}, "so_21053273_21053756_0": {"length": 23, "quality": 0.92, "section_id": 7560}, "so_21053273_21053273_1": {"length": 10, "quality": 1.0, "section_id": 0}, "so_21053273_21053273_3": {"length": 19, "quality": 0.8636363636363636, "section_id": 7429}, "so_21053273_21213706_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 7006}}}, "21213706": {"Id": "21213706", "PostTypeId": "2", "Body": "<p>I have converted the update section in my question to an answer since at this point it seems to be the answer, albeit an unsatisfactory one that my question is unanswerable:</p>\n<p><a href='https://stackoverflow.com/users/420683/dyp\"'>dyp</a> pointed me to two relevant threads that cover very similar ground:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/14991219/what-is-the-value-category-of-the-operands-of-c-operators-when-unspecified\">What is the value category of the operands of C++ operators when unspecified?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/14935722/does-initialization-entail-lvalue-to-rvalue-conversion-is-int-x-x-ub\">Does initialization entail lvalue-to-rvalue conversion? Is int x = x; UB?\n</a></li>\n</ul>\n<p>The consensus seems to be that the standard is <em>ill-specified</em> and therefore can not provide the answer I am looking for, <a href=\"https://stackoverflow.com/users/150634/sftrabbit\">Joseph Mansfield</a> <a href=\"https://groups.google.com/a/isocpp.org/forum/#%21topic/std-discussion/zhe10OxlEZk/discussion\" rel=\"nofollow noreferrer\">posted a defect report on this lack of specification</a>, and it looks like it is still <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1642\" rel=\"nofollow noreferrer\">open</a> and it is not clear when it may be clarified.</p>\n<p>There are a few common sense arguments to be made as to the <em>intent</em> of the standard. One can argue <a href=\"https://stackoverflow.com/questions/14991219/what-is-the-value-category-of-the-operands-of-c-operators-when-unspecified#comment21055383_14991297\">Logicially, an operand is a prvalue if the operation requires using the value of that operand</a>. Another argument is that if we look back to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">C99 draft standard</a> says <a href=\"https://stackoverflow.com/questions/14991219/what-is-the-value-category-of-the-operands-of-c-operators-when-unspecified#comment21055456_14991219\">an lvalue to rvalue conversion is done by default</a> and the exceptions are noted. The relevant section from the draft C99 standard is <code>6.3.2.1</code> <em>Lvalues, arrays, and function designators</em> paragraph <em>2</em> which says:</p>\n<blockquote>\n<p id=\"so_21053273_21213706_0\">Except when it is the operand of the sizeof operator, the unary &amp; operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, \n  an lvalue that does not have array type is converted to the value stored in the designated object (and is no longer an lvalue). [\u2026]</p>\n</blockquote>\n<p>which basically says with some exceptions an operand <em>is converted to the value stored</em> and since <em>indirection</em> is not an exception if this is clarified to also be the case in <em>C++</em> as well then it would indeed make the answer to my question <em>yes</em>.</p>\n<p>As I attempted to clarify the proof of undefined behavior was less important than clarifying whether a lvalue-to-rvalue conversion is mandated. If we want to prove undefined behavior we have alternate approaches. Jerry\u2019s approach is a common sense one and in that <em>indirection</em> requires that the expression be a pointer to an object or function and an indeterminate value will only by accident point to a valid object. <s>In general the draft C++ standard does not give an explicit statement to say using an indeterminate value is undefined, unlike the C99 draft standard</s> In C++11 and back the standard does not give an explicit statement to say using an indeterminate value is undefined. The exception being iterators and by extension pointers we do have the concept of <em>singular value</em> and we are told in section <code>24.2.1</code> that:</p>\n<blockquote>\n<p id=\"so_21053273_21213706_1\">[\u2026][ Example: After the declaration of an uninitialized pointer x (as with int* x;), x must always be assumed to have a singular value of a pointer. \u2014end example ] [\u2026] Dereferenceable values are always non-singular.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_21053273_21213706_2\">An invalid iterator is an iterator that may be singular.<sup>268</sup></p>\n</blockquote>\n<p>and footnote 268 says:</p>\n<blockquote>\n<p id=\"so_21053273_21213706_3\">This definition applies to pointers, since pointers are iterators. The effect of dereferencing an iterator that has been invalidated is undefined.</p>\n</blockquote>\n<p>In C++1y <a href=\"https://stackoverflow.com/questions/23415661/has-c-standard-changed-with-respect-to-the-use-of-indeterminate-values-and-und\">the language changes and we do have an explicit statement making the use of an intermediate value undefined with some narrow exceptions</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-06T21:06:17.483", "Score": "4", "CreationDate": "2014-01-19T05:58:03.983", "ParentId": "21053273", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:17:41.613"}, "21053756": {"Id": "21053756", "PostTypeId": "2", "Body": "<p>I think you're approaching this from a rather oblique angle, so to speak. According to \u00a75.3.1/1: </p>\n<blockquote>\n<p id=\"so_21053273_21053756_0\">The unary <code>*</code> operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an\n  object type, or a pointer to a function type and the result is an lvalue referring to the object or function\n  to which the expression points. If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d</p>\n</blockquote>\n<p>Although this doesn't talk about the lvalue-to-rvalue conversion, it requires that the expression be a pointer to an object or function. An uninitialized pointer won't (except, perhaps by accident) be any such thing so the attempt at dereferencing gives undefined behavior.</p>\n", "LastActivityDate": "2014-01-10T20:25:14.067", "CommentCount": "13", "CreationDate": "2014-01-10T20:25:14.067", "ParentId": "21053273", "Score": "13", "OwnerUserId": "179910"}, "21053273": {"ViewCount": "675", "Body": "<p><b>TL;DR</b></p>\n<p>Given the following code:</p>\n<pre><code>int* ptr;\n*ptr = 0;\n</code></pre>\n<p>does <code>*ptr</code> require an <em>lvalue-to-rvalue</em> conversion of <code>ptr</code> before applying indirection?</p>\n<p>The standard covers the topic of <em>lvalue-to-rvalue</em> in many places but does not seem to specify enough information to determine whether the <em>* operator</em> require such a conversion.</p>\n<p><b>Details</b></p>\n<p>The <em>lvalue-to-rvalue</em> conversion is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">N3485</a> in section <code>4.1</code> <em>Lvalue-to-rvalue conversion</em> paragraph <em>1</em> and says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_21053273_21053273_0\">A glvalue (3.10) of a non-function, non-array type T can be converted\n  to a prvalue.53 If T is an incomplete type, a program that\n  necessitates this conversion is ill-formed. If the object to which the\n  glvalue refers is not an object of type T and is not an object of a\n  type derived from T, <strong>or if the object is uninitialized, a program\n  that necessitates this conversion has undefined behavior</strong>.[...]</p>\n</blockquote>\n<p>So does <code>*ptr = 0;</code> <em>necessitate this conversion</em>?</p>\n<p>If we go to section <code>4</code> paragraph <em>1</em> it says:</p>\n<blockquote>\n<p id=\"so_21053273_21053273_1\">[...]A standard conversion sequence will be applied to an expression\n  <strong>if necessary</strong> to convert it to a required destination type.</p>\n</blockquote>\n<p>So when is it <em>necessary</em>? If we look at section <code>5</code> <em>Expressions</em> the <em>lvalue-to-rvalue</em> conversion is mentioned in paragraph <em>9</em> which says:</p>\n<blockquote>\n<p id=\"so_21053273_21053273_2\">Whenever a glvalue expression appears as an operand of an operator\n  that expects a prvalue for that operand, the lvalue-to-rvalue (4.1),\n  array-to-pointer (4.2), or function-to-pointer (4.3) standard\n  conversions are applied to convert the expression to a prvalue. [...]</p>\n</blockquote>\n<p>and paragraph <em>11</em> which says:</p>\n<blockquote>\n<p id=\"so_21053273_21053273_3\">In some contexts, an expression only appears for its side effects.\n  Such an expression is called a discarded-value expression.[...] The\n  lvalue-to-rvalue conversion (4.1) is applied if and only if the\n  expression is an lvalue of volatile-qualified type and it is one of\n  the following [...]</p>\n</blockquote>\n<p>neither paragraph seems to apply to this code sample and <code>5.3.1</code> <em>Unary operators</em> paragraph <em>1</em> it says:</p>\n<blockquote>\n<p id=\"so_21053273_21053273_4\">The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and the result is an lvalue referring to the object or\n  function to which the expression points. If the type of the expression\n  is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d [ Note: indirection\n  through a pointer to an incomplete type (other than cv void) is valid.\n  The lvalue thus obtained can be used in limited ways (to initialize a\n  reference, for example); this lvalue must not be converted to a\n  prvalue, see 4.1. \u2014end note ]</p>\n</blockquote>\n<p>it does not seem to require the <em>value</em> of the pointer and I don't see any requirements for a conversion of the pointer here am I missing something?</p>\n<p><b>Why do we care?</b></p>\n<p>I have seen an answer and comments in other questions that claim the use of an uninitialized pointer is undefined behavior due the need for an <em>lvalue-to-rvalue</em> conversion of <code>ptr</code> before applying indirection. For example: <a href=\"https://stackoverflow.com/questions/4285895/where-exactly-does-c-standard-say-dereferencing-an-uninitialized-pointer-is-un\">Where exactly does C++ standard say dereferencing an uninitialized pointer is undefined behavior?</a> makes this argument and I can not reconcile the argument with what is laid out in any of the recent draft versions of the standard. Since I have seen this several times I wanted to get clarification. </p>\n<p>The actual proof of undefined behavior is not as important since as I noted in the linked question above we have others way to get to undefined behavior.</p>\n", "AcceptedAnswerId": "21213706", "Title": "Does the standard mandate an lvalue-to-rvalue conversion of the pointer variable when applying indirection?", "CreationDate": "2014-01-10T19:53:55.470", "Id": "21053273", "CommentCount": "8", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:36.713", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-16T03:19:49.497", "Score": "19", "OwnerUserId": "1708801", "Tags": "<c++><pointers><language-lawyer><indirection><lvalue-to-rvalue>", "AnswerCount": "2"}});