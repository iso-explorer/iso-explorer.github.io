post_cb({"24753189": {"Id": "24753189", "PostTypeId": "2", "Body": "<p>It might be helpful to go through the constructor calls in reverse order.</p>\n<pre><code>B b({ A() });\n</code></pre>\n<p>To construct a <code>B</code>, the compiler must call B's constructor that takes a <code>const vector&lt;A&gt;&amp;</code>. That constructor in turn must make a copy of the vector, including all of its elements. That's the second copy ctor call you see.</p>\n<p>To construct the temporary vector to be passed to <code>B</code>'s constructor, the compiler must invoke the <code>initializer_list</code> constructor of <code>std::vector</code>. That constructor, in turn, must make a copy of what's contained in the <code>initializer_list</code><sup>*</sup>. That's the first copy constructor call you see.</p>\n<p>The standard specifies how <code>initializer_list</code> objects are constructed in \u00a78.5.4 [dcl.init.list]/p5:</p>\n<blockquote>\n<p id=\"so_24752830_24753189_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an\n  initializer list as if the implementation allocated an array of N\n  elements of type <code>const E</code><sup>**</sup>, where N is the number of elements in the\n  initializer list. Each element of that array is copy-initialized with\n  the corresponding element of the initializer list, and the\n  <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array.</p>\n</blockquote>\n<p>Copy-initialization of an object from something of the same type uses overload resolution to select the constructor to use (\u00a78.5 [dcl.init]/p17), so with an rvalue of the same type it will invoke the move constructor if one is available. Thus, to construct the <code>initializer_list&lt;A&gt;</code> from the braced initializer list, the compiler will first construct an array of one <code>const A</code> by moving from the temporary <code>A</code> constructed by <code>A()</code>, causing a move constructor call, and then construct the <code>initializer_list</code> object to refer to that array.</p>\n<p>I can't figure out where the other move in g++ comes from, though. <code>initializer_list</code>s are usually nothing more than a pair of pointers, and the standard mandates that copying one doesn't copy the underlying elements. g++ seems to <a href=\"http://coliru.stacked-crooked.com/a/739fb176fb25a92d\" rel=\"noreferrer\">call the move constructor twice</a> when creating an <code>initializer_list</code> from a temporary. It even <a href=\"http://coliru.stacked-crooked.com/a/4b3c0411bcd035c6\" rel=\"noreferrer\">calls the move constructor</a> when constructing an <code>initializer_list</code> from a lvalue.</p>\n<p>My best guess is that it's implementing the standard's non-normative example literally. The standard provides the following example:</p>\n<blockquote>\n<pre><code>struct X {\n    X(std::initializer_list&lt;double&gt; v);\n};\n\nX x{ 1,2,3 };\n</code></pre>\n<p id=\"so_24752830_24753189_1\">The initialization will be implemented in a way roughly equivalent to\n  this:<sup>**</sup></p>\n<pre><code>const double __a[3] = {double{1}, double{2}, double{3}};\nX x(std::initializer_list&lt;double&gt;(__a, __a+3));\n</code></pre>\n<p id=\"so_24752830_24753189_2\">assuming that the implementation can construct an initializer_list object with a pair of pointers. </p>\n</blockquote>\n<p>So if you take this example literally, the array underlying the <code>initializer_list</code> in our case will be constructed as if by:</p>\n<pre><code>const A __a[1] = { A{A()} };\n</code></pre>\n<p>which does incur two move constructor calls because it constructs a temporary <code>A</code>, copy-initializes a second temporary <code>A</code> from the first one, then copy-initializes the array member from the second temporary. The normative text of the standard, however, makes clear that there should only be one copy-initialization, not two, so this seems like a bug.</p>\n<p>Finally, the first <code>A::A</code> comes directly from <code>A()</code>.</p>\n<p>There's not much to discuss about the destructor calls. All temporaries (regardless of number) created during the construction of <code>b</code> will be destructed at the end of the statement in reverse order of construction, and the one <code>A</code> stored in <code>b</code> will be destructed when <code>b</code> goes out of scope. </p>\n<hr>\n<p><sup>*</sup> <sub>The <code>initializer_list</code> constructors of standard library containers are defined as being equivalent to invoking the constructor taking two iterators with <code>list.begin()</code> and <code>list.end()</code>. Those member functions return a <code>const T*</code>, so it can't be moved from. In C++14, the backing array is made <code>const</code>, so it's even clearer that you can't possibly move from it or otherwise change it.</sub></p>\n<p><sup>**</sup> <sub> This answer originally quoted N3337 (the C++11 standard plus some minor editorial changes), which has the array having elements of type <code>E</code> rather than <code>const E</code> and the array in the example being of type <code>double</code>. In C++14, the underlying array was made <code>const</code> as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1418\" rel=\"noreferrer\">CWG 1418</a>.</sub></p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-07-17T02:49:37.440", "Score": "42", "CreationDate": "2014-07-15T08:18:54.150", "ParentId": "24752830", "CommentCount": "6", "OwnerUserId": "2756719", "LastEditDate": "2014-07-17T02:49:37.440"}, "bq_ids": {"n4140": {"so_24752830_24753189_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3327}, "so_24752830_24753189_2": {"length": 8, "quality": 1.0, "section_id": 3327}, "so_24752830_24753189_0": {"length": 30, "quality": 1.0, "section_id": 3327}}, "n3337": {"so_24752830_24753189_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3197}, "so_24752830_24753189_2": {"length": 8, "quality": 1.0, "section_id": 3197}, "so_24752830_24753189_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 3197}}, "n4659": {"so_24752830_24753189_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 4093}, "so_24752830_24753189_2": {"length": 8, "quality": 1.0, "section_id": 4093}, "so_24752830_24753189_0": {"length": 27, "quality": 0.9, "section_id": 4093}}}, "24753300": {"Id": "24753300", "PostTypeId": "2", "Body": "<p>Consider this:</p>\n<ol>\n<li>The temporary <code>A</code> is instanced: <code>A()</code></li>\n<li>That instance is moved to the initializer list: <code>A(A&amp;&amp;)</code></li>\n<li>The initializer list is moved to the vector ctor, so its elements are moved: <code>A(A&amp;&amp;)</code>.\n<strong>EDIT</strong>: <em>As T.C. noticed, initializer_list elements are not moved/copied for initializer_list moving/copying. As his code example shows, seems like two rvalue ctor calls are used during initializer_list initialization.</em></li>\n<li>The vector element is initialized by value, instead of by move (Why?, I'm not sure): <code>A(const A&amp;)</code> <strong>EDIT:</strong> <em>Again, is not the vector but the initializer list</em></li>\n<li>Your ctor gets that temporal vector and copies it (Note your vector initializer), so\nthe elements are copied: <code>A(const A&amp;)</code></li>\n</ol>\n", "LastEditorUserId": "1609356", "LastActivityDate": "2014-07-15T12:25:23.820", "Score": "3", "CreationDate": "2014-07-15T08:24:29.643", "ParentId": "24752830", "CommentCount": "1", "OwnerUserId": "1609356", "LastEditDate": "2014-07-15T12:25:23.820"}, "24753529": {"Id": "24753529", "PostTypeId": "2", "Body": "<p>Try split the code a little to better understand the behavior:</p>\n<pre><code>int main(void) {\n    cout&lt;&lt;\"Begin\"&lt;&lt;endl;\n    vector&lt;A&gt; va({A()});\n\n    cout&lt;&lt;\"After va;\"&lt;&lt;endl;\n    B b(va);\n\n    cout&lt;&lt;\"After b;\"&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>The output is similar (note the <code>-fno-elide-constructors</code> is used)</p>\n<pre><code>Begin\nA::A        &lt;-- temp A()\nA::A(A&amp;&amp;)   &lt;-- moved to initializer_list\nA::A(A&amp;&amp;)   &lt;-- no idea, but as @Manu343726, it's moved to vector's ctor\nA::A(A&amp;)    &lt;-- copied to vector's element\nA::~A\nA::~A\nA::~A\nAfter va;\nA::A(A&amp;)    &lt;-- copied to B's va\nAfter b;\nA::~A\nA::~A\n</code></pre>\n", "LastActivityDate": "2014-07-15T08:38:39.700", "CommentCount": "0", "CreationDate": "2014-07-15T08:38:39.700", "ParentId": "24752830", "Score": "5", "OwnerUserId": "1030870"}, "24752830": {"ViewCount": "4326", "Body": "<p>I have a class <code>B</code> which contains a vector of class <code>A</code>. I want to initialize this vector through the constructor. Class <code>A</code> outputs some debug info so I can see when it is constructed, destructed, copied or moved.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    A()           { cout &lt;&lt; \"A::A\" &lt;&lt; endl; }        \n    ~A()          { cout &lt;&lt; \"A::~A\" &lt;&lt; endl; }               \n    A(const A&amp; t) { cout &lt;&lt;\"A::A(A&amp;)\" &lt;&lt; endl; }              \n    A(A&amp;&amp; t)      { cout &lt;&lt; \"A::A(A&amp;&amp;)\" &lt;&lt; endl; }            \n};\n\nclass B {\npublic:\n    vector&lt;A&gt; va;\n    B(const vector&lt;A&gt;&amp; va) : va(va) {};\n};\n\nint main(void) {\n    B b({ A() });\n    return 0;\n}\n</code></pre>\n<p>Now when I run this program (Compiled with GCC option <code>-fno-elide-constructors</code> so the move constructor calls are not optimized away) I get the following output:</p>\n<pre><code>A::A\nA::A(A&amp;&amp;)\nA::A(A&amp;&amp;)\nA::A(A&amp;)\nA::A(A&amp;)\nA::~A\nA::~A\nA::~A\nA::~A\nA::~A\n</code></pre>\n<p>So instead of just one instance of <code>A</code> the compiler generates five instances of it. <code>A</code> is moved two times and it is copied two times. I didn't expect that. The vector is passed by reference to the constructor and then copied into the class field. So I would have expected a single copy-operation or even just a move operation (because I hoped the vector I pass to the constructor is just a rvalue), not two copies and two moves. Can someone please explain what exactly happens in this code? Where and why does it create all these copies of <code>A</code>?</p>\n", "AcceptedAnswerId": "24753189", "Title": "What happens technically in this C++ code?", "CreationDate": "2014-07-15T07:56:57.710", "Id": "24752830", "CommentCount": "16", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2014-07-15T08:43:42.373", "LastEditorUserId": "274473", "LastActivityDate": "2014-07-17T02:49:37.440", "Score": "45", "OwnerUserId": "274473", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "24753689": {"Id": "24753689", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24752830_24753689_0\"><code>A::A</code></p>\n</blockquote>\n<p>The constructor is executed, when the temporary object is created.</p>\n<blockquote>\n<p id=\"so_24752830_24753689_1\">first A::A(A&amp;&amp;)</p>\n</blockquote>\n<p>The temporary object is moved into the initialization list (which is also rvalue).</p>\n<blockquote>\n<p id=\"so_24752830_24753689_2\">second A::A(A&amp;&amp;)</p>\n</blockquote>\n<p>The initialization list is moved into vector's constructor.</p>\n<blockquote>\n<p id=\"so_24752830_24753689_3\">first A::A(A&amp;)</p>\n</blockquote>\n<p>The vector is copied because the B's constructor takes the lvalue, and a rvalue is passed.</p>\n<blockquote>\n<p id=\"so_24752830_24753689_4\">second A::A(A&amp;)</p>\n</blockquote>\n<p>Again, the vector is copied when creating the B's member variable <code>va</code>.</p>\n<blockquote>\n<p id=\"so_24752830_24753689_5\">A::~A<br>\n  A::~A<br>\n  A::~A<br>\n  A::~A<br>\n  A::~A  </br></br></br></br></p>\n</blockquote>\n<p>Destructor is called for every rvalue and lvalue (whenever the constructor, copy or move constructors are called, destructor is executed when the objects gets destroyed).</p>\n", "LastEditorUserId": "476681", "LastActivityDate": "2014-07-15T09:02:58.080", "Score": "0", "CreationDate": "2014-07-15T08:47:05.360", "ParentId": "24752830", "CommentCount": "1", "OwnerUserId": "476681", "LastEditDate": "2014-07-15T09:02:58.080"}});