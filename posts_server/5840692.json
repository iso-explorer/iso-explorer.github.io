post_cb({"5840934": {"Id": "5840934", "PostTypeId": "2", "Body": "<p>This appears to be an error in VS2010's C++ implementation.</p>\n<p>When you <code>throw</code> an expression a temporary exception object is created by copying (or moving) the operand of the throw expression. If the expression has class type this involves the copy (or move) constructor and the constructor must be accessible at the point of the <code>throw</code>. If the copy constructor of an exception object is private then that object could only be thrown from a member function or a friend function.</p>\n<p>This concern is completely independent of whether the exception object is subsequently caught by value or by reference later in the program.</p>\n<p>In constructing the temporary exception object, the actual copy may be elided but C++ requires that the constructor that would have been used still be accessible.</p>\n<p>ISO/IEC 14882:2003 15.1 [except.throw] / 5:</p>\n<blockquote>\n<p id=\"so_5840692_5840934_0\">If the use of the temporary object can be eliminated without changing the meaning of the program except for the execution of constructors and destructors associated with the use of the temporary object (12.2), then the exception in the handler can be initialized directly with the argument of the throw expression. When the thrown object is a class object, and the copy constructor used to initialize the temporary copy is not accessible, the program is ill-formed (even when the temporary object could otherwise be eliminated).\n  Similarly, if the destructor for that object is not accessible, the program is ill-formed (even when the temporary object could otherwise be eliminated).</p>\n</blockquote>\n<p>This requirement has not been removed in C++0x although the throw expression may now be moved instead of copied where appropriate.</p>\n<p>Draft n3291 15.1 [except.throw] / 5:</p>\n<blockquote>\n<p id=\"so_5840692_5840934_1\">When the thrown object is a class object, the copy/move constructor and the destructor shall be accessible, even if the copy/move operation is elided (12.8).</p>\n</blockquote>\n", "LastEditorUserId": "19563", "LastActivityDate": "2011-04-30T09:56:29.387", "Score": "5", "CreationDate": "2011-04-30T09:51:01.700", "ParentId": "5840692", "CommentCount": "0", "OwnerUserId": "19563", "LastEditDate": "2011-04-30T09:56:29.387"}, "5840692": {"ViewCount": "1484", "Body": "<p>I have the below exception class.</p>\n<pre><code>class ExceptionTest : std::exception\n{\npublic:\nExceptionTest(int value):\n  m_value(value)\n{\n}\n~ExceptionTest()\n{\n}\nprivate:\nExceptionTest(const ExceptionTest&amp; test)\n{\n}\n\nint m_value;\n};\n</code></pre>\n<p>I then use it in this way - </p>\n<pre><code>int checkexception()\n{\nthrow ExceptionTest(2);\n}\n\nint main()\n{\ntry\n{\n    checkexception();\n}\ncatch (ExceptionTest&amp; exception)\n{\n    cout&lt;&lt;\"haha\";\n}\nreturn 1;\n}\n</code></pre>\n<p>This works perfectly fine even though the copy constructor is private.</p>\n<p>If you catch the exception by value it fails - </p>\n<pre><code>int main()\n{\ntry\n{\n    checkexception();\n}\ncatch (ExceptionTest exception) --&gt; this fails\n{\n    cout&lt;&lt;\"haha\";\n}\nreturn 1;\n}\n</code></pre>\n<p>the error i get is </p>\n<pre><code>error C2316: 'ExceptionTest' : cannot be caught as the destructor and/or copy   \nconstructor are inaccessible\n</code></pre>\n<p>I get a linker error if I do not define the copy constructor in the class</p>\n<pre><code>class ExceptionTest : std::exception\n{\npublic:\nExceptionTest(int value):\n  m_value(value)\n{\n}\n~ExceptionTest()\n{\n}\nprivate:\nExceptionTest(const ExceptionTest&amp; test);\n\nint m_value;\n};\n</code></pre>\n<p>LINK : C:\\Users\\sumitha\\Documents\\Visual Studio 2010\\Projects\\test\\Debug\\test.exe not found or not built by the last incremental link; performing full link\n1&gt;main.obj : error LNK2001: unresolved external symbol \"private: __thiscall ExceptionTest::ExceptionTest(class ExceptionTest const &amp;)\" (??0ExceptionTest@@AAE@ABV0@@Z)\n1&gt;C:\\Users\\sumitha\\Documents\\Visual Studio 2010\\Projects\\test\\Debug\\test.exe : fatal error LNK1120: 1 unresolved externals\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</p>\n<p>If the above is true, we can always make the copy constructor of the exception class private, so that the caller would be forced to catch the exception by reference. I think this is happening because of \"return value optimization\"</p>\n", "AcceptedAnswerId": "5840934", "Title": "why does the below code compile successfully in VS2010?", "CreationDate": "2011-04-30T08:55:04.810", "Id": "5840692", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-04-30T09:56:29.387", "Score": "0", "OwnerUserId": "590421", "Tags": "<c++>", "AnswerCount": "4"}, "5840836": {"Id": "5840836", "PostTypeId": "2", "Body": "<p>Making the copy constructor (and assignment operator) private is a very widely used technique in C++ to prevent copying. Arguably, the vast majority of C++ classes (but not  exceptions, which must have an accessible copy constructor) should have copying disabled - I know that almost all of the classes in my own code do this.</p>\n", "LastEditorUserId": "2100815", "LastActivityDate": "2011-04-30T09:54:12.150", "Score": "0", "CreationDate": "2011-04-30T09:27:25.590", "ParentId": "5840692", "CommentCount": "2", "OwnerUserId": "2100815", "LastEditDate": "2011-04-30T09:54:12.150"}, "5840749": {"Id": "5840749", "PostTypeId": "2", "Body": "<p>When you catch the exception using reference (&amp; symbol) you will get the same exception object that was generated i.e the variable in the catch block will be pointing to same exception object in memory that was thrown and hence no need to have a copy cons. Where as if you use the other catch block which catches the exception by value then code needs to be generated by the compiler to create a copy of the exception object that is being caught and assign this new copy to the variable in the catch block, hence you need to have a public copy cons.</p>\n", "LastActivityDate": "2011-04-30T09:07:08.003", "CommentCount": "0", "CreationDate": "2011-04-30T09:07:08.003", "ParentId": "5840692", "Score": "0", "OwnerUserId": "553209"}, "bq_ids": {"n4140": {"so_5840692_5840934_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3338}}, "n3337": {"so_5840692_5840934_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 3208}}, "n4659": {"so_5840692_5840934_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4105}}}, "5840735": {"Id": "5840735", "PostTypeId": "2", "Body": "<p>Like Marino said, if you catch by reference there is no copy construction involved.</p>\n<p>So, the compiler doesn't look for it, and never fails on a private constructor :)</p>\n<p>As a sidenote, I recall that specifically for exceptions there is an 'exception' (no pun intended) in the specs regarding the pass-by-value semantics. I don't know the specifics anymore, but it has to do with</p>\n<ul>\n<li>passing local exceptions from an auto variable (stackallocated) which is naturally a bit tricky while unwinding the stack</li>\n<li>perhaps active specifically in the case of a re-throw of an exception that was caught by value</li>\n</ul>\n<p>.</p>\n<pre><code>....\ncatch (std::runtime_error e)\n{\n     // ....\n     throw;\n}\n</code></pre>\n", "LastActivityDate": "2011-04-30T09:04:04.237", "CommentCount": "3", "CreationDate": "2011-04-30T09:04:04.237", "ParentId": "5840692", "Score": "1", "OwnerUserId": "85371"}});