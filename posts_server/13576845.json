post_cb({"13576910": {"ParentId": "13576845", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your function <code>template&lt;class T&gt;T Read(const string&amp; key)const;</code> is templated on type T but T only appears as the return type.</p>\n<p>If it is your intention to manually bake a return type into your function (and it seems like it is from the appearance of <code>return 1;</code>), you can change the declaration to something like:</p>\n<pre><code>int Read(const string&amp; key) const;\n</code></pre>\n<p>Otherwise you must specify the templated type manually in the call as so:</p>\n<pre><code>tt.Read&lt;int&gt;(\"Hello\");\n</code></pre>\n<p>This boils down to the fact that a function cannot have a templated type deduced when that templated type appears solely in return.</p>\n<p>The C++ standard says it in a way much less easy on the eyes in the section titled:</p>\n<p><code>Explicit template argument specification [temp.arg.explicit]</code></p>\n<blockquote>\n<p id=\"so_13576845_13576910_0\">If all of the template arguments can be deduced, they may all be\n  omitted; in this case, the empty template argument list &lt;&gt; itself may\n  also be omitted. In contexts where deduction is done and fails, or in\n  contexts where deduction is not done, if a template argument list is\n  specified and it, along with any default template arguments, identifies\n  a single function template specialization, then the template-id is an\n  lvalue for the function template specialization.</p>\n</blockquote>\n<pre><code>template&lt;class X, class Y&gt; X f(Y);\n\nint i = f&lt;int&gt;(5.6); // Y is deduced to be double\nint j = f(5.6); // ill-formed: X cannot be deduced\n</code></pre>\n", "OwnerUserId": "1020072", "LastEditorUserId": "1020072", "LastEditDate": "2012-11-27T04:02:22.373", "Id": "13576910", "Score": "1", "CreationDate": "2012-11-27T03:23:07.493", "LastActivityDate": "2012-11-27T04:02:22.373"}, "13576913": {"ParentId": "13576845", "CommentCount": "0", "Body": "<p>I believe it is because when dealing with templates, the compiler would like to know what the return function is and it can't figure it out even though it returns 1 which is an int. Technically <code>return 1</code> could be an error as it doesn't know what the return value SHOULD be. </p>\n<p>Use <code>tt.Read&lt;int&gt;(\"Hello\");</code></p>\n", "Id": "13576913", "PostTypeId": "2", "OwnerDisplayName": "user34537", "Score": "1", "CreationDate": "2012-11-27T03:23:31.980", "LastActivityDate": "2012-11-27T03:23:31.980"}, "13576908": {"ParentId": "13576845", "CommentCount": "3", "Body": "<p>You're trying to define a function that returns a T:</p>\n<pre><code>template&lt;class T&gt;\nT TT::Read(const string&amp; key) const\n{\n    std::cout &lt;&lt; key &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre>\n<p>However, you always return an <code>int</code> from this function. You either need to call it like so:</p>\n<pre><code>tt.Read&lt;int&gt;(\"Hello\");\n</code></pre>\n<p>Or remove the template definition, as it makes no sense here.</p>\n", "OwnerUserId": "1085573", "PostTypeId": "2", "Id": "13576908", "Score": "6", "CreationDate": "2012-11-27T03:22:51.173", "LastActivityDate": "2012-11-27T03:22:51.173"}, "bq_ids": {"n4140": {"so_13576845_13576910_0": {"section_id": 286, "quality": 1.0, "length": 46}}, "n3337": {"so_13576845_13576910_0": {"section_id": 277, "quality": 1.0, "length": 46}}, "n4659": {"so_13576845_13576910_0": {"section_id": 293, "quality": 1.0, "length": 46}}}, "13576845": {"CommentCount": "2", "AcceptedAnswerId": "13576908", "PostTypeId": "1", "LastEditorUserId": "522663", "CreationDate": "2012-11-27T03:14:09.520", "LastActivityDate": "2012-11-27T04:02:22.373", "LastEditDate": "2012-11-27T03:18:22.537", "ViewCount": "148", "FavoriteCount": "0", "Title": "A C++ class-function", "Id": "13576845", "Score": "3", "Body": "<p>A simple c++ file and the class TT has two methods.</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass TT{ \n    public:\n        TT(const string&amp; str);\n        template&lt;class T&gt;T Read(const string&amp; key)const;\n        template&lt;class T&gt;T Read(const string&amp; key, const T&amp; value)const;\n};\n\nTT::TT(const string&amp; str){\n    cout&lt;&lt;str&lt;&lt;endl;\n}\n\ntemplate&lt;class T&gt;T TT::Read(const string&amp; key)const{\n    std::cout&lt;&lt;key&lt;&lt;std::endl;\n    return 1;\n}\n\ntemplate&lt;class T&gt;T TT::Read(const string&amp; key, const T&amp; value)const{\n    std::cout&lt;&lt;key&lt;&lt;'\\t'&lt;&lt;value&lt;&lt;std::endl;\n    return value;\n}\n\nint main(void){\n    TT tt(\"First\");\n\n    tt.Read(\"Hello\", 12);\n    return 1;\n}\n</code></pre>\n<p>If replace the </p>\n<pre><code>tt.Read(\"Hello world!\", 12);\n</code></pre>\n<p>with </p>\n<pre><code>tt.Read(\"Hello world!\");\n</code></pre>\n<p>in <b>main()</b></p>\n<p>G++ says:</p>\n<blockquote>\n<p id=\"so_13576845_13576845_0\">new.cc:31: error: no matching function for call to \u2018TT::Read(const char [5])\u2019</p>\n</blockquote>\n<p>Why G++ cann't find the <b>Read(const string&amp; key)const</b> method?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><class>", "OwnerUserId": "1424948", "AnswerCount": "3"}});