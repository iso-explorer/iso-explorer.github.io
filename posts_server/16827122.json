post_cb({"16827409": {"ParentId": "16827122", "CommentCount": "3", "Body": "<p>Yes, the iteration sequence changes. This is due to \u00a723.2.4.1/10 and /11:</p>\n<blockquote>\n<p id=\"so_16827122_16827409_0\">(p10) The fundamental property of iterators of associative containers is that they iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct them. For any two dereferenceable iterators i and j such that distance from i to j is positive,</p>\n<pre><code>value_comp(*j, *i) == false\n</code></pre>\n<p id=\"so_16827122_16827409_1\">(p11)\n  For associative containers with unique keys the stronger condition holds,</p>\n<pre><code>value_comp(*i, *j) != false.\n</code></pre>\n</blockquote>\n<p>If, after an insert, the new element were added at the beginning of the iteration sequence regardless of the ordering of elements (so as to not to modify the sequence ahead of any existing iterator position), the above requirement would be violated.</p>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "16827409", "Score": "0", "CreationDate": "2013-05-30T03:21:55.950", "LastActivityDate": "2013-05-30T03:21:55.950"}, "16827184": {"ParentId": "16827122", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Erasing an element from a <code>map</code> does not invalidate iterators, so I would expect it to continue to iterate properly.</p>\n<p>See <a href=\"https://stackoverflow.com/a/6438087/5987\">https://stackoverflow.com/a/6438087/5987</a></p>\n", "OwnerUserId": "5987", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:12.987", "Id": "16827184", "Score": "1", "CreationDate": "2013-05-30T02:49:41.517", "LastActivityDate": "2013-05-30T02:49:41.517"}, "16827589": {"ParentId": "16827122", "CommentCount": "0", "Body": "<p>In spite of your note, for the <code>erase</code> case this question is <em>exactly</em> about iterator invalidation, because if no iterator is invalidated, the order necessarily remains the same. This is because <code>map</code> is a sorted container, so no matter what internal representation changes may happen, the iteration order has to remain exactly the same.</p>\n<p>To address specifically your example, it will traverse each element exactly once, because you save off the iterator to check and increment your traversal iterator.</p>\n<p>In the case of insertion, if you insert before the current point of iteration that element won't be visited. Inserting after the current iterator will result in the new item being traversed.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "16827589", "Score": "0", "CreationDate": "2013-05-30T03:46:34.230", "LastActivityDate": "2013-05-30T03:46:34.230"}, "16827122": {"CommentCount": "4", "ViewCount": "1126", "PostTypeId": "1", "LastEditorUserId": "389135", "CreationDate": "2013-05-30T02:43:30.593", "LastActivityDate": "2013-05-30T03:46:34.230", "Title": "Does inserting/erasing an element from a std::map modify the iteration sequence?", "AcceptedAnswerId": "16827539", "LastEditDate": "2013-05-30T03:08:10.673", "Id": "16827122", "Score": "4", "Body": "<p>Say I have the following code:</p>\n<pre><code>typedef std::map&lt; int, std::string &gt;::iterator Iterator;\nIterator iter = myMap.begin();\n\nwhile (iter != myMap.end())\n{\n    Iterator current = iter;\n    ++iter;\n\n    maybeDeleteElement( current ) // may call erase.\n}\n</code></pre>\n<p>Given that <code>std::map</code> is implemented as a red-black tree, is it guaranteed that every element in the map will be visited exactly once? Or will modifying the map cause the tree to rebalance, and thus the iteration sequence to change?</p>\n<p>Note: This is not a question about whether or not any iterators will be invalidated. But an iterator remaining valid does not necessarily mean that incrementing it will give you the same next element that it did before.</p>\n", "Tags": "<c++><iterator><stdmap><red-black-tree>", "OwnerUserId": "389135", "AnswerCount": "5"}, "16827539": {"ParentId": "16827122", "CommentCount": "0", "Body": "<p>In a <code>std::map</code> the elements will be visited in order.</p>\n<p>If you store an iterator that refers to an element that is not deleted, and hence not invalidated, the iterator will still refer to that same element.  (If it was the end iterator, it remains the end iterator, as it is not invalidated).</p>\n<p>When you advance that iterator, it will advance to the next element in order after the element you refer to.</p>\n<p>For your particular example, yes, every element will be visited exactly once, because all deletion of elements was elements that are before the current iterator state of your loop.</p>\n<p>If you insert elements ahead of whatever iterator you are using to iterate, then you'll eventually reach them as you iterate forward with your iterator.  If you delete elements ahead of whatever iterator you are using to iterate, then they are no longer part of the future elements you'll reach if you iterate with that iterator.</p>\n<p>If you insert or delete elements that are before the current location of the iterator, unless you start calling <code>--</code> or similar functions, your current iteration will continue without noticing that they went away.</p>\n<p>This is because <code>++</code> on a valid iterator in an ordered container is guaranteed to return the next element in the order, and operations on other iterators that do not invalidate an iterator don't change that iterator's invariants (like what element they refer to).</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "16827539", "Score": "3", "CreationDate": "2013-05-30T03:39:21.703", "LastActivityDate": "2013-05-30T03:39:21.703"}, "16827419": {"ParentId": "16827122", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes, inserting/erasing can modify the iteration sequence. It does not happen in your example, as you erase iterators you've already passed by, but if you erase/insert elements that are positioned <strong>ahead</strong> of your current iterator, then it will modify the rest of the sequence.</p>\n<p>Here is a short code which displays such behavior:</p>\n<pre><code>int main (){\n    map&lt;int,int&gt; mapa;\n    for(int i = 0; i &lt; 5; ++i) mapa[i] = i;\n    bool add = false;\n    for(auto it = mapa.begin(); it != mapa.end(); ++it){\n        int x = it-&gt;second;\n        printf(\"%d\\n\", x);\n        if(add) mapa.erase(x+1);\n        add = !add;\n    }\n    return 0;\n}\n</code></pre>\n<p>The example above will print <code>0 1 3 4</code> (instead of <code>0 1 2 3 4</code>). Additionally, if you erase the current iterator, its reference to the next element will be invalidated and your program will crash at the next iteration.</p>\n<p>Alternatively, you can also test the insertion, by substituting the <code>if(add)</code> above with:</p>\n<pre><code>if(add) mapa[x+5] = x+5;\nelse mapa[x-20] = x-20;\n</code></pre>\n<p>The example will print the extra elements {6, 8, 11, 16}, and not print the negative ones, since those are being inserted in a position prior to your current one.</p>\n", "OwnerUserId": "2386719", "LastEditorUserId": "2386719", "LastEditDate": "2013-05-30T03:33:02.750", "Id": "16827419", "Score": "2", "CreationDate": "2013-05-30T03:23:21.693", "LastActivityDate": "2013-05-30T03:33:02.750"}, "bq_ids": {"n4140": {"so_16827122_16827409_0": {"section_id": 746, "quality": 0.8928571428571429, "length": 25}, "so_16827122_16827409_1": {"section_id": 747, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_16827122_16827409_0": {"section_id": 735, "quality": 0.8928571428571429, "length": 25}, "so_16827122_16827409_1": {"section_id": 736, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_16827122_16827409_0": {"section_id": 805, "quality": 0.8928571428571429, "length": 25}, "so_16827122_16827409_1": {"section_id": 806, "quality": 0.7777777777777778, "length": 7}}}});