post_cb({"30259298": {"ParentId": "30258639", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>The this pointer is accessible in every non-static member function ...</h3>\n<p><strong>\u00a79.3.2</strong>/1</p>\n<blockquote>\n<p id=\"so_30258639_30259298_0\">In the body of a non-static (9.3) member function, the keyword <code>this</code> is a prvalue expression whose value is the address of the object for which the function is called. The type of this in a member function of a class X is X*. If the member function is declared const, the type of this is const X*, if the member function is declared volatile, the type of this is volatile X*, and if the member function is declared const volatile, the type of this is const volatile X*.</p>\n</blockquote>\n<h3>... where constructors and destructors are member functions ...</h3>\n<p><strong>\u00a712</strong>/1</p>\n<blockquote>\n<p id=\"so_30258639_30259298_1\">The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor and move assignment operator (12.8), and destructor (12.4) are special member functions.</p>\n</blockquote>\n<h3>... which aren't static.</h3>\n<p><strong>\u00a712.1</strong>/4</p>\n<blockquote>\n<p id=\"so_30258639_30259298_2\">A constructor shall not be virtual (10.3) or static (9.4).</p>\n</blockquote>\n<p><strong>\u00a712.4</strong>/2</p>\n<blockquote>\n<p id=\"so_30258639_30259298_3\">A destructor shall not be static.</p>\n</blockquote>\n<h3>Thus, <code>this</code> is available in constructors and destructors. But there are limitations (especially with respect to the use of <code>this</code> inside the initializer list).</h3>\n<p><em>(Note: Inside the constructor / destructor body, the initialization of all subobjects and members is completed and they are accessible; see further down below).</em> </p>\n<p><strong>1. Only access object being constructed (or their subobjects) through <code>this</code>.</strong></p>\n<p><strong>\u00a712.1</strong>/14</p>\n<blockquote>\n<p id=\"so_30258639_30259298_4\">During the construction of a const object, if the value of the object or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor\u2019s <code>this</code> pointer, the value of the object or subobject thus obtained is unspecified. </p>\n</blockquote>\n<p><strong>2. Do not call virtual functions that are overriden in a derived class in the base constructor</strong></p>\n<p><strong>\u00a712.7</strong>/4</p>\n<blockquote>\n<p id=\"so_30258639_30259298_5\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more derived class. If the virtual function call uses an explicit class member access (5.2.5) and the object expression refers to the complete object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p><strong>3. Do not apply <code>dynamic_cast</code> to cast <code>this</code> into any type other than the type under construction or any base type thereof.</strong></p>\n<p><strong>\u00a712.7</strong>/6</p>\n<blockquote>\n<p id=\"so_30258639_30259298_6\">dynamic_casts (5.2.7) can be used during construction or destruction (12.6.2). When a dynamic_cast is used in a constructor (including the mem-initializer or brace-or-equal-initializer for a non-static data member) or in a destructor, or used in a function called (directly or indirectly) from a constructor or destructor, if the operand of the dynamic_cast refers to the object under construction or destruction, this object is considered to be a most derived object that has the type of the constructor or destructor\u2019s class. If the operand of the dynamic_cast refers to the object under construction or destruction and the static type of the operand is not a pointer to or object of the constructor or destructor\u2019s own class or one of its bases, the dynamic_cast results in undefined behavior.</p>\n</blockquote>\n<p><strong>4. Conversion of <code>this</code> into base type pointer is only allowed through paths that consist of constructed base types.</strong></p>\n<p><strong>\u00a712.7</strong>/3</p>\n<blockquote>\n<p id=\"so_30258639_30259298_7\">To explicitly or implicitly convert a pointer (a glvalue) referring to an object of class X to a pointer (reference) to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes shall not have completed, otherwise the conversion results in undefined behavior. To form a pointer to (or access the value of) a direct non-static member of an object obj, the construction of obj shall have started and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior. </p>\n</blockquote>\n<h3>Accessing sub-objects and members in the initializer list and the constructor body</h3>\n<p>In principle you can access constructed / initialized objects from the initializer list, if their initialization takes place before accessing them.\nThe order of initialization is</p>\n<p><strong>\u00a712.6.2</strong>/10</p>\n<blockquote>\n<p id=\"so_30258639_30259298_8\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li><p id=\"so_30258639_30259298_9\">First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</p></li>\n<li><p id=\"so_30258639_30259298_10\">Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</p></li>\n<li><p id=\"so_30258639_30259298_11\">Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</p></li>\n<li><p id=\"so_30258639_30259298_12\">Finally, the compound-statement of the constructor body is executed.</p></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "951423", "LastEditorUserId": "538866", "LastEditDate": "2016-07-28T22:11:14.067", "Id": "30259298", "Score": "5", "CreationDate": "2015-05-15T12:13:57.053", "LastActivityDate": "2016-07-28T22:11:14.067"}, "30258818": {"ParentId": "30258639", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Within any non-static member function, <code>this</code> points to the object that the function was called on. It's safe to use as long as that's a valid object.</p>\n<p>Within the body of a constructor or destructor, there is a valid object of the class currently being constructed. However, if this is the base sub-object of some derived class, then only the base sub-object is valid at that time; so it's generally not safe to down-cast and try to access members of the derived class. For the same reason, you need to be careful calling virtual functions here, since they are dispatched according to the class being created or destroyed, not the final overrider.</p>\n<p>Within the initialiser list of a constructor, you'll need to be careful only to access members that have been initialised; that is, members declared before the one currently being initialised.</p>\n<p>Up-casting to a base class is always safe, since base sub-objects are always initialised first.</p>\n<p>For the specific examples you just added to the question:</p>\n<ul>\n<li>case 1 is fine (if fragile), since <code>a</code> has been initialised at that point. Initialising <code>a</code> with the value of <code>b</code> would be undefined, since <code>b</code> is initialised after <code>a</code>.</li>\n<li>case 2 is fine: all members have been initialised at that point.</li>\n<li>case 3 won't compile, since there's no suitable <code>foo</code> constructor. If there were, then it would depend on what that constructor did with it - whether or not it tried to access members before they were initialised.</li>\n<li>case 4 would be well-formed if you added the missing <code>)</code>, but dangerous if you tried to use the pointer to access the object. <code>this</code> does not yet point to a valid <code>bar</code> object (only the <code>foo</code> part has been initialised) so accessing members of <code>bar</code> could give undefined behaviour. Simply checking whether the pointer is non-null is fine, and will always give <code>true</code> (whether or not you apply a pointless cast).</li>\n</ul>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2015-05-15T12:11:30.553", "Id": "30258818", "Score": "25", "CreationDate": "2015-05-15T11:50:26.300", "LastActivityDate": "2015-05-15T12:11:30.553"}, "30258639": {"CommentCount": "7", "AcceptedAnswerId": "30258818", "PostTypeId": "1", "LastEditorUserId": "3243563", "CreationDate": "2015-05-15T11:42:34.597", "LastActivityDate": "2016-10-28T12:31:08.707", "LastEditDate": "2016-10-28T12:31:08.707", "ViewCount": "15328", "FavoriteCount": "7", "Title": "When is it safe to call this-> in constructor and destructor", "Id": "30258639", "Score": "20", "Body": "<p>I've not been able to find a conclusive answer to this so far. When is it safe to call <code>this-&gt;</code> from within an object. And in particular from inside the constructor and destructor.</p>\n<p>And also, when using public inheritance. Is it safe to use up and downcasting on the result of the this call?</p>\n<p>So for example:</p>\n<pre><code>class foo\n{\n   foo():\n   a(),\n   b(this-&gt;a)//case 1\n   {\n       this-&gt; a = 5; //case 2\n   }\n\n   int a;\n   int b;\n};\n\nclass bar: public baz\n{\n   bar():\n   baz(this)//case 3 - assuming baz has a valid constructor\n   {\n\n\n   }\n\n}\n</code></pre>\n<p>And finally the most unlikely one</p>\n<pre><code>foo()\n   {\n      if(static_cast&lt;bar*&gt;(this));//case 4\n   }\n</code></pre>\n<p>Which of the above cases are legal?</p>\n<p><strong>Note:</strong> I'm aware a lot of the practices above are inadvisable. </p>\n", "Tags": "<c++><c++11><constructor><destructor>", "OwnerUserId": "3243563", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30258639_30259298_6": {"section_id": 449, "quality": 0.9672131147540983, "length": 59}, "so_30258639_30259298_10": {"section_id": 438, "quality": 1.0, "length": 13}, "so_30258639_30259298_5": {"section_id": 447, "quality": 0.9333333333333333, "length": 70}, "so_30258639_30259298_12": {"section_id": 438, "quality": 1.0, "length": 5}, "so_30258639_30259298_11": {"section_id": 438, "quality": 1.0, "length": 15}, "so_30258639_30259298_4": {"section_id": 377, "quality": 1.0, "length": 22}, "so_30258639_30259298_7": {"section_id": 446, "quality": 1.0, "length": 62}, "so_30258639_30259298_8": {"section_id": 438, "quality": 1.0, "length": 6}, "so_30258639_30259298_1": {"section_id": 361, "quality": 0.7619047619047619, "length": 16}, "so_30258639_30259298_9": {"section_id": 438, "quality": 1.0, "length": 29}, "so_30258639_30259298_0": {"section_id": 5895, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_30258639_30259298_10": {"section_id": 429, "quality": 1.0, "length": 13}, "so_30258639_30259298_12": {"section_id": 429, "quality": 1.0, "length": 5}, "so_30258639_30259298_4": {"section_id": 368, "quality": 1.0, "length": 22}, "so_30258639_30259298_0": {"section_id": 5666, "quality": 0.9736842105263158, "length": 37}, "so_30258639_30259298_11": {"section_id": 429, "quality": 1.0, "length": 15}, "so_30258639_30259298_5": {"section_id": 438, "quality": 0.9333333333333333, "length": 70}, "so_30258639_30259298_7": {"section_id": 437, "quality": 1.0, "length": 62}, "so_30258639_30259298_8": {"section_id": 429, "quality": 1.0, "length": 6}, "so_30258639_30259298_1": {"section_id": 351, "quality": 0.7619047619047619, "length": 16}, "so_30258639_30259298_9": {"section_id": 429, "quality": 1.0, "length": 29}, "so_30258639_30259298_6": {"section_id": 440, "quality": 0.9672131147540983, "length": 59}}, "n4659": {"so_30258639_30259298_1": {"section_id": 373, "quality": 0.7619047619047619, "length": 16}, "so_30258639_30259298_10": {"section_id": 458, "quality": 1.0, "length": 13}, "so_30258639_30259298_4": {"section_id": 391, "quality": 0.9545454545454546, "length": 21}, "so_30258639_30259298_6": {"section_id": 471, "quality": 0.9508196721311475, "length": 58}, "so_30258639_30259298_11": {"section_id": 458, "quality": 1.0, "length": 15}, "so_30258639_30259298_5": {"section_id": 469, "quality": 0.9333333333333333, "length": 70}, "so_30258639_30259298_7": {"section_id": 468, "quality": 1.0, "length": 62}, "so_30258639_30259298_8": {"section_id": 458, "quality": 1.0, "length": 6}, "so_30258639_30259298_0": {"section_id": 7378, "quality": 0.9736842105263158, "length": 37}, "so_30258639_30259298_9": {"section_id": 458, "quality": 1.0, "length": 29}, "so_30258639_30259298_12": {"section_id": 458, "quality": 1.0, "length": 5}}}, "30258725": {"ParentId": "30258639", "CommentCount": "0", "Body": "<p>There is a good entry on it at the C++ super-faq:</p>\n<p><a href=\"https://isocpp.org/wiki/faq/ctors#using-this-in-ctors\">https://isocpp.org/wiki/faq/ctors#using-this-in-ctors</a></p>\n<blockquote>\n<p id=\"so_30258639_30258725_0\">Some people feel you should not use the this pointer in a constructor\n  because the object is not fully formed yet. However you can use this\n  in the constructor (in the {body} and even in the initialization list)\n  if you are careful.</p>\n<p id=\"so_30258639_30258725_1\">Here is something that always works: the {body} of a constructor (or a\n  function called from the constructor) can reliably access the data\n  members declared in a base class and/or the data members declared in\n  the constructor\u2019s own class. This is because all those data members\n  are guaranteed to have been fully constructed by the time the\n  constructor\u2019s {body} starts executing.</p>\n<p id=\"so_30258639_30258725_2\">Here is something that never works: the {body} of a constructor (or a\n  function called from the constructor) cannot get down to a derived\n  class by calling a virtual member function that is overridden in the\n  derived class. If your goal was to get to the overridden function in\n  the derived class, you won\u2019t get what you want. Note that you won\u2019t\n  get to the override in the derived class independent of how you call\n  the virtual member function: explicitly using the this pointer (e.g.,\n  this-&gt;method()), implicitly using the this pointer (e.g., method()),\n  or even calling some other function that calls the virtual member\n  function on your this object. The bottom line is this: even if the\n  caller is constructing an object of a derived class, during the\n  constructor of the base class, your object is not yet of that derived\n  class. You have been warned.</p>\n<p id=\"so_30258639_30258725_3\">Here is something that sometimes works: if you pass any of the data\n  members in this object to another data member\u2019s initializer, you must\n  make sure that the other data member has already been initialized. The\n  good news is that you can determine whether the other data member has\n  (or has not) been initialized using some straightforward language\n  rules that are independent of the particular compiler you\u2019re using.\n  The bad news is that you have to know those language rules (e.g., base\n  class sub-objects are initialized first (look up the order if you have\n  multiple and/or virtual inheritance!), then data members defined in\n  the class are initialized in the order in which they appear in the\n  class declaration). If you don\u2019t know these rules, then don\u2019t pass any\n  data member from the this object (regardless of whether or not you\n  explicitly use the this keyword) to any other data member\u2019s\n  initializer! And if you do know the rules, please be careful.</p>\n</blockquote>\n", "OwnerUserId": "131140", "PostTypeId": "2", "Id": "30258725", "Score": "15", "CreationDate": "2015-05-15T11:45:56.173", "LastActivityDate": "2015-05-15T11:45:56.173"}});