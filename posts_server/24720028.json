post_cb({"24720119": {"Id": "24720119", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24720028_24720119_0\">What's the difference between Object obj(args...) and Object obj{args...}? and why Scott says so.</p>\n</blockquote>\n<p>The difference is that in the former case, the order of evaluation of arguments is  unsequenced (i.e unspecified) but in the latter case, the order is left-to-right (i.e in which they appear).</p>\n<p>The following text from $5.2.2/8 [expr.call] (n3690) deals with <code>Object(args...)</code> form:</p>\n<blockquote>\n<p id=\"so_24720028_24720119_1\">The evaluations of the postfix expression and of the arguments are all <strong>unsequenced</strong> relative to one another. All side effects of argument evaluations are sequenced before the function is entered (see 1.9).</p>\n</blockquote>\n<p>And the text from $8.5.4/4 [dcl.init.list] (n3690) deals with <code>Object{args...}</code> form:</p>\n<blockquote>\n<p id=\"so_24720028_24720119_2\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are <strong>evaluated in the order in which they appear</strong>. That is,\n  every value computation and side e\ufb00ect associated with a given\n  initializer-clause is sequenced before every value computation and\n  side e\ufb00ect associated with any initializer-clause that follows it in\n  the comma-separated list of the initializer-list.[ Note: This\n  evaluation ordering holds regardless of the semantics of the\n  initialization; for example, it applies when the elements of the\n  initializer-list are interpreted as arguments of a constructor call,\n  even though ordinarily there are no sequencing constraints on the\n  arguments of a call. \u2014 end note ]</p>\n</blockquote>\n<p>Well which means this:</p>\n<pre><code> int f() { static int i = 10; return ++i; }  //increment the static int!\n\n Object obj(f(), f()); //is it obj(11,12) or obj(12,11)? Unspecified. \n\n Object obj{f(), f()}; //it is obj(11,12). Guaranteed.\n</code></pre>\n<p>Note that <a href=\"https://stackoverflow.com/questions/14060264/order-of-evaluation-of-elements-in-list-initialization\">GCC (4.7.0 and 4.7.2) have a bug because of which <code>{}</code> form doesn't work the way it should</a>. I'm not sure if it is fixed in the current version.</p>\n<p>Hope that helps. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-13T10:42:14.710", "Score": "1", "CreationDate": "2014-07-13T06:25:29.240", "ParentId": "24720028", "CommentCount": "0", "LastEditDate": "2017-05-23T11:46:34.270", "OwnerUserId": "415784"}, "24720384": {"Id": "24720384", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24720028_24720384_0\">What's the difference between Object obj(args...) and Object obj{args...}?</p>\n</blockquote>\n<p>{args...} will prefer a constructor with an initializer_list over other legal candidates.</p>\n<pre><code>std::vector&lt;int&gt; v(10); // vector of size 10\nstd::vector&lt;int&gt; v{10}; // vector initialized with a single element, (int) 10\n</code></pre>\n<p>On the other hand, you give up implicit narrowing.</p>\n<pre><code>std::vector&lt;int&gt; v(10.5); // vector of size 10\nstd::vector&lt;int&gt; v{10.5}; // illegal - no compile\nstd::vector&lt;float&gt; v{10.5}; // vector initialized with a single element, (float) 10.5\n</code></pre>\n", "LastEditorUserId": "257090", "LastActivityDate": "2014-07-13T07:25:34.407", "Score": "1", "CreationDate": "2014-07-13T07:14:36.613", "ParentId": "24720028", "CommentCount": "0", "LastEditDate": "2014-07-13T07:25:34.407", "OwnerUserId": "257090"}, "24720311": {"Id": "24720311", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24720028_24720311_0\">What's the difference between <code>Object obj(args...)</code> and <code>Object obj{args...}</code>?</p>\n</blockquote>\n<p>The first is <em>direct-initialization</em> while the second is <em>direct-list-initialization</em>. This is mentioned in two different sections:</p>\n<p><em>\u00a78.5/16 [dcl.init]</em></p>\n<blockquote>\n<p id=\"so_24720028_24720311_1\">The initialization that occurs in the forms</p>\n<pre><code> T x(a);\n T x{a};\n</code></pre>\n<p id=\"so_24720028_24720311_2\">as well as in <code>new</code> expressions (5.3.4), <code>static_cast</code> expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called <strong><em>direct-initialization</em></strong>.</p>\n</blockquote>\n<p>and <em>\u00a78.5.4/1 [dcl.init.list]</em></p>\n<blockquote>\n<p id=\"so_24720028_24720311_3\"><em>List-initialization</em> is initialization of an object or reference from a <em>braced-init-list</em>. Such an initializer is called an <em>initializer list</em>, and the comma-separated <em>initializer-clauses</em> of the list are called the <em>elements</em> of the initializer list. An initializer list may be empty. <strong>List-initialization can occur in direct-initialization or copy-initialization contexts; list-initialization in a direct-initialization context is called <em>direct-list-initialization</em></strong> and list-initialization in a copy-initialization context is called <em>copy-list-initialization</em>.</p>\n</blockquote>\n<hr>\n<p>There are a few differences between the two:</p>\n<ul>\n<li><p>If the type being constructed has a constructor that takes an <code>initializer_list</code> argument, <em>direct-list-initialization</em> will always favor that constructor. Other constructors will only be considered if the <code>initializer_list</code> constructor is not viable. <em>\u00a713.3.1.7/1 [over.match.list]</em></p></li>\n<li><p><em>direct-list-initialization</em> does not allow narrowing conversions within the argument list. <em>\u00a78.5.4/3 [dcl.init.list]</em></p></li>\n<li><p>If the type being initialized is an aggregate, <em>direct-list-initialization</em> will perform aggregate initialization. <em>\u00a78.5.4/3 [dcl.init.list]</em></p></li>\n<li><p>The order of evaluation of the elements of a <em>braced-init-list</em> is from left to right. <em>\u00a78.5.4/4 [dcl.init.list]</em></p></li>\n<li><p>You can avoid the most vexing parse by using <em>direct-list-initialization</em></p></li>\n</ul>\n<p>\u00a0</p>\n<pre><code>  struct foo{};\n  struct bar \n  {    \n    bar(foo const&amp;) {}\n  };\n\n  bar b1(foo()); // most vexing parse\n  bar b2(foo{}); // all 3 of the following construct objects of type bar\n  bar b3{foo()};\n  bar b4{foo{}};\n</code></pre>\n</hr>", "LastActivityDate": "2014-07-13T07:03:11.653", "CommentCount": "0", "CreationDate": "2014-07-13T07:03:11.653", "ParentId": "24720028", "Score": "5", "OwnerUserId": "241631"}, "bq_ids": {"n4140": {"so_24720028_24720311_3": {"length": 37, "quality": 1.0, "section_id": 3323}, "so_24720028_24720311_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 3295}, "so_24720028_24720119_1": {"length": 19, "quality": 0.95, "section_id": 5995}, "so_24720028_24720119_2": {"length": 54, "quality": 0.8709677419354839, "section_id": 3326}}, "n3337": {"so_24720028_24720311_3": {"length": 37, "quality": 1.0, "section_id": 3193}, "so_24720028_24720311_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 3165}, "so_24720028_24720119_1": {"length": 18, "quality": 0.9, "section_id": 5763}, "so_24720028_24720119_2": {"length": 54, "quality": 0.8709677419354839, "section_id": 3196}}, "n4659": {"so_24720028_24720311_3": {"length": 34, "quality": 0.918918918918919, "section_id": 4089}, "so_24720028_24720311_2": {"length": 10, "quality": 0.5555555555555556, "section_id": 4057}, "so_24720028_24720119_1": {"length": 11, "quality": 0.55, "section_id": 7492}, "so_24720028_24720119_2": {"length": 54, "quality": 0.8709677419354839, "section_id": 4092}}}, "24720293": {"Id": "24720293", "PostTypeId": "2", "Body": "<p>The behavior of <code>Object obj(args...)</code> and <code>Object{args...}</code> depends on the constructors defined in <code>Object</code>.</p>\n<p>Take the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct A\n{\n   A(int a, int b) {std::cout &lt;&lt; \"Came to A::A()\\n\";}\n};\n\nstruct B\n{\n   B(int a, int b) {std::cout &lt;&lt; \"Came to B::B(int, int)\\n\";}\n   B(std::initializer_list&lt;int&gt; in) {std::cout &lt;&lt; \"Came to B::B(std::initializer_list&lt;int&gt;)\\n\";}\n};\n\nint main()\n{\n   A a1(10, 20); // Resolves to A(int, int)\n   A a2{10, 20}; // Resolves to A(int, int)\n   A a3{30};     // Does not resolve to anything. It's a compiler error.\n\n   B b1(10, 20); // Resolves to B(int, int)\n   B b2{10, 20}; // Resolves to B(std::initializer_list&lt;int&gt; )\n   B b3{30};     // Resolves to B(std::initializer_list&lt;int&gt; )\n\n}\n</code></pre>\n", "LastActivityDate": "2014-07-13T06:59:59.030", "CommentCount": "0", "CreationDate": "2014-07-13T06:59:59.030", "ParentId": "24720028", "Score": "2", "OwnerUserId": "434551"}, "24720028": {"ViewCount": "365", "Body": "<p>The draft book <a href=\"http://scottmeyers.blogspot.com/2013/01/effective-c11-content-and-status.html\" rel=\"nofollow noreferrer\">Effective C++11</a> by Scott Meyers states: </p>\n<blockquote>\n<p id=\"so_24720028_24720028_0\">Distinguish () and {} when creating objects</p>\n</blockquote>\n<p>What's the difference between <code>Object obj(args...)</code> and <code>Object obj{args...}</code>? and why Scott says so.</p>\n<p><strong>Update:</strong></p>\n<p>The question <a href=\"https://stackoverflow.com/questions/7612075/how-to-use-c11-uniform-initialization-syntax\">How to use C++11 uniform initialization syntax?</a> asks for HOW, and this question asks for WHY. </p>\n<p><strong>Update2:</strong></p>\n<p>I find the following link is helpful and completely answers this question: </p>\n<p><a href=\"https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax\">https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax</a> </p>\n", "AcceptedAnswerId": "24720311", "Title": "What's the difference between `Object obj(args...)` and `Object obj{args...}`?", "CreationDate": "2014-07-13T06:03:56.347", "Id": "24720028", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:06.110", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-13T10:42:14.710", "Score": "7", "OwnerUserId": "508343", "Tags": "<c++><oop><c++11><constructor><uniform-initialization>", "AnswerCount": "4"}});