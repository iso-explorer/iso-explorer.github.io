post_cb({"48861757": {"Id": "48861757", "PostTypeId": "2", "Body": "<p><code>std::unique_ptr::reset</code> does not invoke destructor directly, instead it invokes <code>operator ()</code> of the deleter template parameter (which defaults to <code>std::default_delete&lt;T&gt;</code>). This operator is required to not throw exceptions, as specified in </p>\n<blockquote>\n<p id=\"so_48861586_48861757_0\"><strong>23.11.1.2.5 unique_ptr modifiers [unique.ptr.single.modifiers]</strong></p>\n<p id=\"so_48861586_48861757_1\"><code>void reset(pointer p = pointer()) noexcept;</code></p>\n<p id=\"so_48861586_48861757_2\">Requires: The expression <code>get_deleter()(get())</code> shall be well-formed, shall have &gt;well-defined behavior, and shall not throw exceptions.</p>\n</blockquote>\n<p>Note that <em>shall not throw</em> is not the same as <code>noexcept</code> though. <code>operator ()</code> of the <code>default_delete</code> is not declared as <code>noexcept</code> even though it only invokes <code>delete</code> operator (executes <code>delete</code> statement). So this seems to be a rather weak spot in the standard. <code>reset</code> should either be conditionally noexcept:</p>\n<pre><code>noexcept(noexcept(::std::declval&lt;D&gt;()(::std::declval&lt;T*&gt;())))\n</code></pre>\n<p>or <code>operator ()</code> of the deleter should be required to be <code>noexcept</code> to give a stonger guarantee.</p>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2018-02-19T21:40:29.863", "Score": "5", "CreationDate": "2018-02-19T08:04:42.873", "ParentId": "48861586", "CommentCount": "14", "OwnerUserId": "7860670", "LastEditDate": "2018-02-19T21:40:29.863"}, "bq_ids": {"n4140": {"so_48861586_48861711_1": {"length": 4, "quality": 1.0, "section_id": 4339}, "so_48861586_48861711_4": {"length": 6, "quality": 1.0, "section_id": 6276}, "so_48861586_48861757_2": {"length": 7, "quality": 0.7, "section_id": 4318}, "so_48861586_48861711_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 4318}, "so_48861586_48861757_1": {"length": 4, "quality": 1.0, "section_id": 4339}}, "n3337": {"so_48861586_48861711_1": {"length": 4, "quality": 1.0, "section_id": 4180}, "so_48861586_48861711_4": {"length": 6, "quality": 1.0, "section_id": 6036}, "so_48861586_48861757_2": {"length": 7, "quality": 0.7, "section_id": 4159}, "so_48861586_48861711_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 4159}, "so_48861586_48861757_1": {"length": 4, "quality": 1.0, "section_id": 4180}}, "n4659": {"so_48861586_48861757_1": {"length": 4, "quality": 1.0, "section_id": 5596}, "so_48861586_48861711_4": {"length": 6, "quality": 1.0, "section_id": 7783}, "so_48861586_48861757_2": {"length": 7, "quality": 0.7, "section_id": 5575}, "so_48861586_48861711_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5575}, "so_48861586_48861711_1": {"length": 4, "quality": 1.0, "section_id": 5596}}}, "48864736": {"Id": "48864736", "PostTypeId": "2", "Body": "<p>Perhaps this would be easier to explain this with an example. If we assume that <code>reset</code> wasn't always <code>noexcept</code>, then we could write some code like this would cause problems:</p>\n<pre><code>class Foobar {\npublic:\n  ~Foobar()\n  {\n    // Toggle between two different types of exceptions.\n    static bool s = true;\n    if(s) throw std::bad_exception();\n    else  throw std::invalid_argument(\"s\");\n    s = !s;\n  }\n};\n\nint doStuff() {\n  Foobar* a = new Foobar(); // wants to throw bad_exception.\n  Foobar* b = new Foobar(); // wants to throw invalid_argument.\n  std::unique_ptr&lt;Foobar&gt; p;\n  p.reset(a);\n  p.reset(b);\n}\n</code></pre>\n<p>What do we when <code>p.reset(b)</code> is called?</p>\n<p>We want to avoid memory leaks, so <code>p</code> needs to claim ownership of <code>b</code> so that it can destroy the instance, but it also needs to destroy <code>a</code> which wants to throw an exception. So how and we destroy both <code>a</code> and <code>b</code>?</p>\n<p>Also, which exception should <code>doStuff()</code> throw? <code>bad_exception</code> or <code>invalid_argument</code>?</p>\n<p>Forcing <code>reset</code> to always be <code>noexcept</code> prevents these problems. But this sort of code would be rejected at compile-time.</p>\n", "LastActivityDate": "2018-02-19T11:03:49.813", "CommentCount": "0", "CreationDate": "2018-02-19T11:03:49.813", "ParentId": "48861586", "Score": "0", "OwnerUserId": "1904009"}, "48861586": {"ViewCount": "1607", "Body": "<p><a href=\"https://stackoverflow.com/questions/48849887/default-argument-vs-overloads-in-c/\">A recent question</a> (and especially my answer to it) made me wonder:</p>\n<p>In C++11 (and newer standards), destructors are always implicitly <code>noexcept</code>, unless specified otherwise (i.e. <code>noexcept(false)</code>). In that case, these destructors may legally throw exceptions. (Note that this is still a <em>you should really know what you are doing</em>-kind of situation!) </p>\n<p>However, all overloads of\n<code>std::unique_ptr&lt;T&gt;::reset()</code> are declared to always be <code>noexcept</code> (see <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/reset\" rel=\"noreferrer\">cppreference</a>), even if the destructor if <code>T</code> isn't, resulting in program termination if a destructor throws an exception during <code>reset()</code>. Similar things apply to <code>std::shared_ptr&lt;T&gt;::reset()</code>.</p>\n<p><strong>Why is <code>reset()</code> always noexcept, and not conditionally noexcept?</strong> </p>\n<p>It should be possible to declare it <code>noexcept(noexcept(std::declval&lt;T&gt;().~T()))</code> which makes it noexcept exactly if the destructor of <code>T</code> is noexcept. Am I missing something here, or is this an oversight in the standard (since this is admittedly a highly academic situation)?</p>\n", "AcceptedAnswerId": "48861711", "Title": "Why is std::unique_ptr::reset() always noexcept?", "CreationDate": "2018-02-19T07:49:48.877", "LastActivityDate": "2018-02-26T07:19:26.537", "CommentCount": "0", "LastEditDate": "2018-02-19T08:34:43.490", "PostTypeId": "1", "LastEditorUserId": "3747990", "Id": "48861586", "Score": "29", "OwnerUserId": "3198247", "Tags": "<c++><c++11><language-lawyer><destructor><noexcept>", "AnswerCount": "4"}, "48861769": {"Id": "48861769", "PostTypeId": "2", "Body": "<p>Without having been in the discussions in the standards committee, my first thought is that this is a case where the standards committee has decided that the pain of throwing in the destructor, which is generally considered undefined behaviour due to the destruction of stack memory when unwinding the stack, was not worth it.</p>\n<p>For the <code>unique_ptr</code> in particular, consider what could happen if an object held by a <code>unique_ptr</code> throws in the destructor:</p>\n<ol>\n<li>The <code>unique_ptr::reset()</code> is called.</li>\n<li>The object inside is destroyed</li>\n<li>The destructor throws</li>\n<li>The stack starts unwinding</li>\n<li>The <code>unique_ptr</code> goes out of scope</li>\n<li>Goto 2</li>\n</ol>\n<p>There was to ways of avoiding this. One is setting the pointer inside of the <code>unique_ptr</code> to a <code>nullptr</code> before deleting it, which would result in a memory leak, or to define what should happen if a destructor throws an exception in the general case.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2018-02-19T19:40:50.920", "Score": "4", "CreationDate": "2018-02-19T08:05:46.350", "ParentId": "48861586", "CommentCount": "1", "OwnerUserId": "1008428", "LastEditDate": "2018-02-19T19:40:50.920"}, "48861711": {"Id": "48861711", "PostTypeId": "2", "Body": "<p>The requirements of the call to the function object <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow noreferrer\"><code>Deleter</code></a> are specific on this as listed in the requirements of the <code>std::unique_ptr&lt;T&gt;::reset()</code> member.</p>\n<p>From <a href=\"http://eel.is/c++draft/unique.ptr.single.modifiers#3\" rel=\"nofollow noreferrer\">[unique.ptr.single.modifiers]/3</a>, circa N4660 \u00a723.11.1.2.5/3;</p>\n<blockquote>\n<p id=\"so_48861586_48861711_0\"><strong><code>unique_ptr</code> modifiers</strong></p>\n<p id=\"so_48861586_48861711_1\"><code>void reset(pointer p = pointer()) noexcept;</code></p>\n<p id=\"so_48861586_48861711_2\">Requires: The expression <code>get_deleter()(get())</code> shall be well formed, shall have well-defined behavior, and shall <strong>not throw exceptions</strong>.</p>\n</blockquote>\n<p>In general the type would need to be destructible. And as per the <a href=\"http://en.cppreference.com/w/cpp/concept/Destructible\" rel=\"nofollow noreferrer\">cppreference</a> on the C++ concept <em>Destructible</em>, the standard lists this under the table in <a href=\"http://eel.is/c++draft/utility.arg.requirements#tab:destructible\" rel=\"nofollow noreferrer\">[utility.arg.requirements]/2</a>, \u00a720.5.3.1 (emphasis mine);</p>\n<blockquote>\n<p id=\"so_48861586_48861711_3\"><code>Destructible</code> requirements</p>\n<p id=\"so_48861586_48861711_4\"><code>u.~T()</code> All resources owned by <code>u</code> are reclaimed, <strong>no exception is propagated</strong>.</p>\n</blockquote>\n<p>Also note the general library requirements for replacement functions; <a href=\"http://eel.is/c++draft/res.on.functions#2\" rel=\"nofollow noreferrer\">[res.on.functions]/2</a>.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2018-02-26T07:19:26.537", "Score": "24", "CreationDate": "2018-02-19T08:00:52.647", "ParentId": "48861586", "CommentCount": "5", "OwnerUserId": "3747990", "LastEditDate": "2018-02-26T07:19:26.537"}});