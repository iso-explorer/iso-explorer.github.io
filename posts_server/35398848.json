post_cb({"35400387": {"ParentId": "35398848", "CommentCount": "3", "Body": "<p>It seems to me that current gcc accepts it, and clang does too, because <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4198.html\" rel=\"nofollow\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4198.html</a> has been implemented by both. That is, of course, if you use their C++17 modes.</p>\n", "OwnerUserId": "1315421", "PostTypeId": "2", "Id": "35400387", "Score": "1", "CreationDate": "2016-02-15T01:56:04.553", "LastActivityDate": "2016-02-15T01:56:04.553"}, "bq_ids": {"n4659": {"so_35398848_35398848_0": {"section_id": 93, "quality": 0.6153846153846154, "length": 8}, "so_35398848_35399091_1": {"section_id": 93, "quality": 0.6153846153846154, "length": 8}}}, "35398848": {"CommentCount": "0", "AcceptedAnswerId": "35400387", "CreationDate": "2016-02-14T22:35:49.287", "LastActivityDate": "2016-02-15T01:56:04.553", "Title": "Using a pointer to data member as a non-type template argument", "ViewCount": "74", "PostTypeId": "1", "Id": "35398848", "Score": "1", "Body": "<p>I'd like to know the rationale for preventing pointers to data members from being used as non-type template arguments, as explained in [temp.arg.nontype]:</p>\n<blockquote>\n<p id=\"so_35398848_35398848_0\">[Note: The address of an array element or non-static data member is not an \n  acceptable template-argument. [snip] \u2014 end note ]</p>\n</blockquote>\n<p>Furthermore, cppreference.com <a href=\"http://en.cppreference.com/w/cpp/language/template_parameters#Template_non-type_arguments\" rel=\"nofollow\">says that</a> pointers to data-members <strong>can</strong> be used as non-type template arguments, but they are required to be expressed as <code>&amp;Class::member</code>. This seems to be confirmed by the following code (checked\non both Clang and GCC):</p>\n<pre><code>#include &lt;type_traits&gt;\nstruct Foo { int bar; };\nusing X = std::integral_constant&lt;int Foo::*, &amp;Foo::bar&gt;; // works\nusing Y = std::integral_constant&lt;int Foo::*, X::value&gt;; // fails\n</code></pre>\n<p>Hence, I would like to know whether I missed something in the standard or cppreference.com is wrong on this point. If cppreference.com is right, is there any rationale for allowing <code>&amp;Foo::bar</code> but not <code>X::value</code>?</p>\n<p>I'm using the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">C++14 working draft</a>.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "627587", "AnswerCount": "2"}, "35399091": {"ParentId": "35398848", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_35398848_35399091_0\">I'd like to know the rationale for preventing pointers to data members from being used as non-type template arguments [...]</p>\n</blockquote>\n<p>I do not believe it says that.</p>\n<blockquote>\n<p id=\"so_35398848_35399091_1\">[Note: The <strong>address of</strong> an array element or non-static data member is not an acceptable template-argument. [snip] \u2014 end note ]</p>\n</blockquote>\n<p>Now, maybe I'm reading to much into the wording of this note,\nbut I see a distinction between <em>address of</em> (i.e. <code>&amp;s.s -&gt; int*</code>) and pointer to member (i.e. <code>&amp;S::s -&gt; int S::* -&gt; int*</code>), which <em>is</em> allowed.</p>\n<p>If you expand that <code>[snip]</code> you'll see that note answers part of your question already: </p>\n<pre><code>X&lt;&amp;s.s&gt; x5;  // error: &amp;S::s must be used\nX&lt;&amp;S::s&gt; x6; // OK: address of static member\n</code></pre>\n<p>So cppreference is not wrong.</p>\n", "OwnerUserId": "996886", "PostTypeId": "2", "Id": "35399091", "Score": "1", "CreationDate": "2016-02-14T23:02:29.773", "LastActivityDate": "2016-02-14T23:02:29.773"}});