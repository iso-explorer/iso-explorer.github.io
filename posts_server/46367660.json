post_cb({"46368488": {"ParentId": "46367660", "CommentCount": "0", "CreationDate": "2017-09-22T15:43:23.057", "OwnerUserId": "5129715", "PostTypeId": "2", "Id": "46368488", "Score": "1", "Body": "<p>Bitset does not offer atomic modification, so changes of bits may latch older values in nearby bits.</p>\n<p>If there was a reset(5) that may mean thread 1 never sees the set bit.</p>\n", "LastActivityDate": "2017-09-22T15:43:23.057"}, "46367660": {"CommentCount": "7", "ViewCount": "124", "PostTypeId": "1", "LastEditorUserId": "8656479", "CreationDate": "2017-09-22T14:55:49.970", "LastActivityDate": "2017-09-22T18:59:27.750", "Title": "Is it safe to access (read) a bit from a bitset (C++) which may be modified by a different thread", "AcceptedAnswerId": "46371205", "LastEditDate": "2017-09-22T15:00:04.507", "Id": "46367660", "Score": "4", "Body": "<p>Is this type of operation considered safe? (in other words no chance of reading some bogus intermediate value if the bitset is being modified on a different thread)? Specifically I'm only interested in whether the read is safe, in other words, I am not asking whether it's safe to write to a bitset from two separate threads.</p>\n<p>eg: Will thread 1 reliably get the current state of bit 5 regardless of whether other bits in bs are being set/cleared at the same time?</p>\n<pre><code>std::bitset&lt;64&gt; bs;\n\n//thread 1:\nbool val;\nval=bs.test(5);\n// ...\n\n//thread 2:\n// set/clear a few bits\nbs.set(1);\nbs.set(3);\nbs.set(5);\nbs.reset(6);\n// ...\n</code></pre>\n", "Tags": "<c++><stl><thread-safety><bit-manipulation>", "OwnerUserId": "8656479", "AnswerCount": "3"}, "46371205": {"ParentId": "46367660", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-09-22T18:36:22.277", "Score": "1", "LastEditorUserId": "6651824", "LastEditDate": "2017-09-22T18:59:27.750", "Id": "46371205", "OwnerUserId": "6651824", "Body": "<p>Using a <code>std::bitset</code> that way is <strong>not</strong> thread safe.  </p>\n<p>This is what the standard says about accessing a bitset (\u00a7 20.9.2.2-51):</p>\n<blockquote>\n<p id=\"so_46367660_46371205_0\">For the purpose of determining the presence of a data race, any access or update through the resulting reference potentially accesses or modifies, respectively, the entire underlying bitset.</p>\n</blockquote>\n<p>Therefore, writing to a bitset object while reading from it in another thread of execution is a data race (which triggers undefined behavior). Even if all threads access the bitset object using a different index.</p>\n", "LastActivityDate": "2017-09-22T18:59:27.750"}, "46368301": {"ParentId": "46367660", "CommentCount": "4", "CreationDate": "2017-09-22T15:33:11.040", "OwnerUserId": "7632486", "PostTypeId": "2", "Id": "46368301", "Score": "0", "Body": "<p>No STL container is thread-safe. While you will not get an intermediate value, you might end up ignoring a set of the value if the threads are not synchronized. Use <code>atomic</code> operations.</p>\n", "LastActivityDate": "2017-09-22T15:33:11.040"}, "bq_ids": {"n4140": {"so_46367660_46371205_0": {"section_id": 4175, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_46367660_46371205_0": {"section_id": 4018, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_46367660_46371205_0": {"section_id": 5435, "quality": 0.9444444444444444, "length": 17}}}});