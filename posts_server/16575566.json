post_cb({"16575566": {"ViewCount": "239", "Body": "<p>started moving some libraries from msvc to mingw, and found really interesting behavior of msvc when one wants to delete an <strong>array</strong> of upcasted objects. Namely msvc does some dark magic (it seems to love doing that) and the bellow code executes just fine, however in mingw (4.7.2( crashes. I believe that mingw is performing correctly and its the msvc voodoo thats the issue for making a sleeper bug.</p>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass foo{\n    static int idgen;\nprotected:\n    int id;\npublic:\n    foo(){\n        id = idgen++;\n        std::cout &lt;&lt; \"Hello  ( foo - \"&lt;&lt;id&lt;&lt;\")\"&lt;&lt;std::endl;\n    }\n    virtual ~foo(){\n        std::cout &lt;&lt; \"Bye bye ( foo - \"&lt;&lt;id&lt;&lt;\")\"&lt;&lt;std::endl;\n    };\n};\n\nint foo::idgen = 0;\n\n\nclass bar: public foo{\n    double some_data[20];\npublic:\n    bar(){\n\n    std::cout &lt;&lt; \"Hello  ( bar - \"&lt;&lt;id&lt;&lt;\")\"&lt;&lt;std::endl;\n}\n    ~bar(){\n        std::cout &lt;&lt; \"Bye bye ( bar - \"&lt;&lt;id&lt;&lt;\")\"&lt;&lt;std::endl;\n    }\n};\n\nint main()\n{\n    const unsigned int size = 2;\n    foo** arr = new foo*[size];\n    {\n        bar* tmp = new bar[size];\n        for(int i=0; i&lt;size; i++)\n        {\n            arr[i] = &amp;(tmp[i]); //take address of each object\n        }\n    }\n\n    delete [] arr[0]; //take address of first object, pointer is same as tmp. This also crashes mingw\n    delete [] arr;\n\n}\n</code></pre>\n<p>Output from msvc 2010</p>\n<pre><code>Hello  ( foo - 0)\nHello  ( bar - 0)\nHello  ( foo - 1)\nHello  ( bar - 1)\nBye bye ( bar - 1)\nBye bye ( foo - 1)\nBye bye ( bar - 0)\nBye bye ( foo - 0)\n</code></pre>\n<p>And mingw (crashed at the destruction) </p>\n<pre><code>Hello  ( foo - 0)\nHello  ( bar - 0)\nHello  ( foo - 1)\nHello  ( bar - 1) \n</code></pre>\n<p>My question is, what is the correct approach to fix this. The current hackfix that I came up with involved just trying to downcast to every possible class and invoking the delete operation on the downcasted pointer:</p>\n<pre><code>if(dynamic_cast&lt;bar*&gt;(arr[0]) != 0)\n    delete [] dynamic_cast&lt;bar*&gt;(arr[0]); \n</code></pre>\n<p>Is there a better approach, besides redesigning the library (it isn't mine)?</p>\n", "AcceptedAnswerId": "16576673", "Title": "Deleting an array of objects upcasted to base pointers", "CreationDate": "2013-05-15T21:48:57.497", "Id": "16575566", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-05-15T22:31:15.223", "LastEditorUserId": "2387522", "LastActivityDate": "2013-05-15T23:38:03.400", "Score": "4", "OwnerUserId": "2387522", "Tags": "<c++><crash><mingw><visual-studio-2010><upcasting>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16575566_16576673_0": {"length": 14, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_16575566_16576673_0": {"length": 14, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_16575566_16576673_0": {"length": 14, "quality": 1.0, "section_id": 7604}}}, "16576732": {"Id": "16576732", "PostTypeId": "2", "Body": "<p>gcc 4.7.2 fails even with a simple example here -&gt; ideone.com/z876QX#view_edit_box So we can't apparently make use of virtual destructors if it is an array.</p>\n<pre><code>const unsigned int size = 2;\nfoo* test = new bar[size];\ndelete[] test;\n</code></pre>\n<p>However, you get away if you use an array of pointers that will allow you to use <code>delete</code> instead of <code>delete[]</code>.</p>\n<p><a href=\"http://ideone.com/NfbF3n#view_edit_box\" rel=\"nofollow\">http://ideone.com/NfbF3n#view_edit_box</a></p>\n<pre><code>const int size = 5;\nfoo *test[size];\nfor(int i = 0; i &lt; size; ++i)\n    test[i] = new bar;\nfor(int i = 0; i &lt; size; ++i)\n   delete test[i];\n</code></pre>\n", "LastActivityDate": "2013-05-15T23:38:03.400", "CommentCount": "0", "CreationDate": "2013-05-15T23:38:03.400", "ParentId": "16575566", "Score": "1", "OwnerUserId": "1576556"}, "16576673": {"Id": "16576673", "PostTypeId": "2", "Body": "<p>In the standard specifications, Section 5.3.5  paragraph 3, regarding the <code>delete</code> operator:</p>\n<blockquote>\n<p id=\"so_16575566_16576673_0\">[...] In the second alternative (delete <em>array</em>) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>So indeed, you should not rely on the gentle behaviour of Visual C++ in this case, and try to provide the array <code>delete</code> operator a pointer of the correct type, which basically means dynamic casting in your situation. </p>\n<p>You may avoid that problem by using a vector instance to store your upcasted objects allocated one by one.</p>\n", "LastActivityDate": "2013-05-15T23:30:52.297", "CommentCount": "1", "CreationDate": "2013-05-15T23:30:52.297", "ParentId": "16575566", "Score": "4", "OwnerUserId": "1769720"}});