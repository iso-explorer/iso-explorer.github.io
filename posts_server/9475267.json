post_cb({"9475267": {"CommentCount": "1", "AcceptedAnswerId": "9478134", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-28T01:52:44.840", "LastActivityDate": "2012-02-28T07:43:33.993", "LastEditDate": "2017-05-23T11:59:58.680", "ViewCount": "1640", "FavoriteCount": "3", "Title": "Why would I use dynamic_cast to cast TO a void *?", "Id": "9475267", "Score": "8", "Body": "<p>So I was reading the answers to <a href=\"https://stackoverflow.com/questions/4131091/dynamic-cast-from-void\">dynamic_cast from \"void *\"</a> and although you can't cast from a <code>void *</code> to a <code>T *</code> several of the responses point out that it is possible to cast a <code>T *</code> to a <code>void *</code>, but don't give any indication <em>why</em> you'd want to do that.</p>\n<p>Is this just a bit of trivia that it's possible, or is there a case where it would make sense? I thought about maybe for readability or to make it clear that we're converting to a <code>void *</code>, but given the purpose of <code>dynamic_cast</code>, it doesn't fit very well to me.</p>\n<p>For that matter, is there any reason to do anything other than let <code>T *</code> become <code>void *</code> implicitly? I've seen C-style casts to <code>void *</code> used from time to time for this purpose, I presume just to be explicit (assuming we're not doing something unusual like casting <code>int</code> to a pointer or something).</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1172428", "AnswerCount": "2"}, "9475371": {"ParentId": "9475267", "CommentCount": "5", "CreationDate": "2012-02-28T02:05:40.913", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "9475371", "Score": "5", "Body": "<p>There is a purpose to this, kinda. It is hinted at in the part of the spec that allows it. From N3337, section 5.2.7, paragraph 7:</p>\n<blockquote>\n<p id=\"so_9475267_9475371_0\">If T is \u201cpointer to cv void,\u201d then the result is a pointer to the most derived object pointed to by v.</p>\n</blockquote>\n<p>So a <code>dynamic_cast&lt;void*&gt;(...)</code> is really shorthand for <code>static_cast&lt;void*&gt;(dynamic_cast&lt;MostDerivedType*&gt;(...))</code>. And that would be useful... sort of.</p>\n<p>The difficulty in making it useful is that you don't necessarily know what <code>MostDerivedType</code> is. After all, it can be different for each expression. So once you have it as a <code>void*</code>, you don't necessarily have a way to cast it back <em>safely</em>. If you make a guess about <code>MostDerivedType</code> and just <code>static_cast</code> it, and you're <em>wrong</em>, then you're in undefined behavior land. Whereas if you do the <code>dynamic_cast</code> to that type (then <code>static_cast</code> to <code>void*</code>), it will at least return NULL if it isn't of that type.</p>\n<p>So no, I would say that it isn't very useful. Not if you want to live within the boundaries of C++ and not rely on potentially undefined behavior.</p>\n", "LastActivityDate": "2012-02-28T02:05:40.913"}, "bq_ids": {"n4140": {"so_9475267_9475371_0": {"section_id": 6017, "quality": 1.0, "length": 9}}, "n3337": {"so_9475267_9475371_0": {"section_id": 5785, "quality": 1.0, "length": 9}}, "n4659": {"so_9475267_9475371_0": {"section_id": 7516, "quality": 1.0, "length": 9}}}, "9478134": {"ParentId": "9475267", "CommentCount": "6", "CreationDate": "2012-02-28T07:43:33.993", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9478134", "Score": "7", "Body": "<p>First, when using <code>dynamic_cast&lt;void*&gt;(x)</code> you get a pointer to the first byte of the <em>most derived</em> object. As long as the static type of <code>x</code> is polymorphic.</p>\n<p>This can be useful in a handful of scenarios, where the address serves as object identity:</p>\n<ul>\n<li>you now have a way to fully distinguish pointers to subobjects of the same object from pointers to unrelated subobjects.</li>\n<li>you can now walk some twisted graphs without visiting the same object several times... which can be used for <em>serialization</em>.</li>\n</ul>\n<p>Granted, this is certainly not a <em>daily usage</em>, but in C++ the memory address is a de-facto identifier for objects, so a mechanism to access it from any part of the inheritance hierarchy certainly is useful for those few edge cases.</p>\n", "LastActivityDate": "2012-02-28T07:43:33.993"}});