post_cb({"48223365": {"Id": "48223365", "PostTypeId": "2", "Body": "<p>The other answers explain the way that the standards diverge in what they require. This answer provides a motivating example in the area of difference.</p>\n<p>In C++, you can have a function like <code>int&amp; foo(int&amp;);</code>, which has no analog in C. It is useful (and not onerous) for C++ to have the option of <code>foo(foo(x));</code>.</p>\n<p>Imagine for a moment that operations on basic types were defined somewhere, e.g. <code>int&amp; operator++(int&amp;);</code>. <code>++++x</code> itself is not a motivating example, but it fits the pattern of <code>foo</code> above.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2018-01-15T15:24:46.223", "Score": "2", "CreationDate": "2018-01-12T09:38:56.773", "ParentId": "48203314", "CommentCount": "2", "OwnerUserId": "2610810", "LastEditDate": "2018-01-15T15:24:46.223"}, "48203314": {"ViewCount": "1434", "Body": "<p>Why is</p>\n<pre><code>int main()\n{\n    int i = 0;\n    ++++i;\n}\n</code></pre>\n<p>valid C++ but not valid C?</p>\n", "AcceptedAnswerId": "48203451", "Title": "Why are multiple pre-increments allowed in C++ but not in C?", "CreationDate": "2018-01-11T09:10:45.617", "LastActivityDate": "2018-01-15T15:24:46.223", "CommentCount": "11", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2018-01-12T08:43:41.003", "LastEditorUserId": "1536976", "Id": "48203314", "ClosedDate": "2018-01-16T19:34:29.550", "Score": "35", "OwnerUserId": "8030323", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "4"}, "48203451": {"Id": "48203451", "PostTypeId": "2", "Body": "<p>C and C++ say different things about the result of prefix ++. In C++:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.pre.incr\" rel=\"noreferrer\">[expr.pre.incr]</a></p>\n<blockquote>\n<p id=\"so_48203314_48203451_0\">The operand of prefix ++ is modified by adding 1. <strong>The operand shall be\n  a modifiable lvalue</strong>. The type of the operand shall be an arithmetic\n  type other than cv bool, or a pointer to a completely-defined object\n  type. <strong>The result is the updated operand; it is an lvalue</strong>, and it is a\n  bit-field if the operand is a bit-field. The expression ++x is\n  equivalent to x+=1.</p>\n</blockquote>\n<p>So ++ can be applied on the result again, because the result is basically just the object being incremented and is an lvalue. In C however:</p>\n<p><a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.5.3\" rel=\"noreferrer\"><strong>6.5.3 Unary operators</strong></a></p>\n<blockquote>\n<p id=\"so_48203314_48203451_1\">The operand of the prefix increment or decrement operator shall have atomic, qualified, or unqualified real or pointer type, <strong>and shall be a modifiable lvalue.</strong></p>\n<p id=\"so_48203314_48203451_2\">The value of the operand of the prefix ++ operator is incremented. <strong>The\n  result is the new value</strong> of the operand after incrementation.</p>\n</blockquote>\n<p>The result is not an lvalue; it's just the pure value of the incrementation. So you can't apply any operator that requires an lvalue on it, including ++.</p>\n<p>If you are ever told the C++ and C are superset or subset of each other, know that it is not the case. There are many differences that make that assertion false.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2018-01-15T15:22:53.243", "Score": "44", "CreationDate": "2018-01-11T09:18:37.747", "ParentId": "48203314", "CommentCount": "2", "OwnerUserId": "817643", "LastEditDate": "2018-01-15T15:22:53.243"}, "48203446": {"Id": "48203446", "PostTypeId": "2", "Body": "<p>I assume you understand why it's fine in C++ so I'm not going to elaborate on that.</p>\n<p>For whatever it's worth, here's my test result:</p>\n<pre><code>t.c:6:2: error: lvalue required as increment operand\n  ++ ++c;\n  ^\n</code></pre>\n<p>Regarding <a href=\"http://en.cppreference.com/w/c/language/value_category#Non-lvalue_object_expressions\" rel=\"noreferrer\">CppReference</a>:</p>\n<blockquote>\n<h3>Non-lvalue object expressions</h3>\n<p id=\"so_48203314_48203446_0\">Colloquially known as rvalues, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.</p>\n<p id=\"so_48203314_48203446_1\">The following expressions are non-lvalue object expressions:</p>\n<ul>\n<li><p id=\"so_48203314_48203446_2\">all operators <strong>not specified to return lvalues</strong>, including</p>\n<ul>\n<li>increment and decrement operators (note: pre- forms are lvalues in C++)</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>And Section 6.5.3.1 from n1570:</p>\n<blockquote>\n<p id=\"so_48203314_48203446_3\">The value of the operand of the prefix ++ operator is incremented. <strong>The result is the new <em>value</em></strong> of the operand after incrementation.</p>\n</blockquote>\n<p>So in C, the result of prefix increment and prefix decrement operators are <strong>not required to be lvalue</strong>, thus not incrementable again. In fact, such word can be understood as \"required to be rvalue\".</p>\n", "LastEditorUserId": "5958455", "LastActivityDate": "2018-01-11T09:27:47.023", "Score": "4", "CreationDate": "2018-01-11T09:18:11.080", "ParentId": "48203314", "CommentCount": "0", "OwnerUserId": "5958455", "LastEditDate": "2018-01-11T09:27:47.023"}, "bq_ids": {"n4140": {"so_48203314_48203451_0": {"length": 24, "quality": 0.75, "section_id": 6074}}, "n3337": {"so_48203314_48203451_0": {"length": 24, "quality": 0.75, "section_id": 5842}}, "n4659": {"so_48203314_48203446_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7797}, "so_48203314_48203451_0": {"length": 26, "quality": 0.8125, "section_id": 7570}}}, "48205483": {"Id": "48205483", "PostTypeId": "2", "Body": "<p>In C, it's always been that way. Possibly because pre-incremented <code>++</code> can be optimised to a single machine code instruction on many CPUs, including ones from the 1970s which was when the <code>++</code> concept developed.</p>\n<p>In C++ though there's the symmetry with operator overloading to consider. To match C, the canonical pre-increment <code>++</code> would need to return <code>const &amp;</code>, unless you had different behaviour for user-defined and built-in types (which would be a smell). Restricting the return to <code>const &amp;</code> is a contrivance. So the return of <code>++</code> gets relaxed from the C rules, at the expense of increased compiler complexity in order to exploit any CPU optimisations for built-in types.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2018-01-11T12:44:51.937", "Score": "14", "CreationDate": "2018-01-11T10:59:55.877", "ParentId": "48203314", "CommentCount": "7", "OwnerUserId": "2380830", "LastEditDate": "2018-01-11T12:44:51.937"}});