post_cb({"27572071": {"Id": "27572071", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27432506_27572071_0\">The question is why is it this way?</p>\n</blockquote>\n<p>Because that's how it was in C at the Dawn of Time (1973 actually) <a href=\"http://cm.bell-labs.com/who/dmr/chist.html\" rel=\"nofollow\">see here</a></p>\n<blockquote>\n<p id=\"so_27432506_27572071_1\">If it was legal, you could do it in for loops, which is somewhat useful.</p>\n</blockquote>\n<p>It is legal, just not very pretty:</p>\n<pre><code>for(std::tuple&lt;int, double&gt; t = std::make_tuple(0, 10.0) ; \n    std::get&lt;0&gt;(t) &lt; 10 ; \n    ++std::get&lt;0&gt;(t), std::get&lt;1&gt;(t) *= 1.1)\n{\n    cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; \", \" &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2014-12-19T18:42:35.233", "Score": "1", "CreationDate": "2014-12-19T18:42:35.233", "ParentId": "27432506", "CommentCount": "6", "OwnerUserId": "2015579"}, "bq_ids": {"n4140": {"so_27432506_27432506_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5427}, "so_27432506_27432506_2": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_7": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_9": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_12": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_8": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_10": {"length": 8, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_13": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_15": {"length": 11, "quality": 0.9166666666666666, "section_id": 3196}, "so_27432506_27432506_3": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_11": {"length": 5, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_14": {"length": 7, "quality": 0.875, "section_id": 3196}, "so_27432506_27432506_4": {"length": 8, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_6": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_27432506_27432506_5": {"length": 5, "quality": 1.0, "section_id": 5427}}, "n3337": {"so_27432506_27432506_10": {"length": 8, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5222}, "so_27432506_27432506_2": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_12": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_14": {"length": 7, "quality": 0.875, "section_id": 3070}, "so_27432506_27432506_7": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_11": {"length": 5, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_8": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_13": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_15": {"length": 11, "quality": 0.9166666666666666, "section_id": 3070}, "so_27432506_27432506_3": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_9": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_4": {"length": 8, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_6": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_27432506_27432506_5": {"length": 5, "quality": 1.0, "section_id": 5222}}, "n4659": {"so_27432506_27432506_1": {"length": 12, "quality": 0.8, "section_id": 6855}, "so_27432506_27432506_2": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_12": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_9": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_7": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_11": {"length": 5, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_13": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_10": {"length": 8, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_15": {"length": 11, "quality": 0.9166666666666666, "section_id": 3958}, "so_27432506_27432506_8": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_14": {"length": 7, "quality": 0.875, "section_id": 3958}, "so_27432506_27432506_4": {"length": 8, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_6": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_3": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_27432506_27432506_5": {"length": 5, "quality": 1.0, "section_id": 6855}}}, "27432506": {"ViewCount": "342", "Body": "<p>The following is invalid code:</p>\n<pre><code>int i = 0, double j = 2.0;\n</code></pre>\n<p>The draft standard says why:</p>\n<blockquote>\n<p id=\"so_27432506_27432506_0\">[N4140/7.1.6]</p>\n<p id=\"so_27432506_27432506_1\"><code>2</code> As a general rule, at most one <em>type-specifier</em> is allowed in the\n  complete <em>decl-specifier-seq</em> of a declaration or in a\n  <em>type-specifier-seq</em> or <em>trailing-type-specifier-seq</em>. The only exceptions to this rule are the following:</p>\n<blockquote>\n<p id=\"so_27432506_27432506_8\">\u2014 <code>const</code> can be combined with any type specifier except itself.</p>\n<p id=\"so_27432506_27432506_9\">\u2014 <code>volatile</code> can be combined with any type specifier except itself.</p>\n<p id=\"so_27432506_27432506_10\">\u2014 <code>signed</code> or <code>unsigned</code> can be combined with <code>char</code>, <code>long</code>, <code>short</code>,\n    or <code>int</code>.</p>\n<p id=\"so_27432506_27432506_11\">\u2014 <code>short</code> or <code>long</code> can be combined with <code>int</code>.</p>\n<p id=\"so_27432506_27432506_12\">\u2014 <code>long</code> can be combined with <code>double</code>.</p>\n<p id=\"so_27432506_27432506_13\">\u2014 <code>long</code> can be combined with <code>long</code>.</p>\n</blockquote>\n</blockquote>\n<p>Yes, it prevents something silly like <code>int int</code>, but I don't see anything wrong with the invalid code posted above. Quoting <code>[N4140/7]</code>, a <em>simple-declaration</em> consists of a <em>decl-specifier-seq<sub>opt</sub> init-declarator-list<sub>opt</sub>;</em> </p>\n<p><code>[N4140/8]</code> then shows that an <em>init-declarator-list</em> consists of an <em>init-declarator-list</em> , <em>init-declarator</em>,</p>\n<p>and an <em>init-declarator</em> is a <em>declarator initializer<sub>opt</sub></em>. </p>\n<p>Since we're concerned with only syntax of the form <code>int i = 0</code>, then the <em>declarator</em> we care about is a <em>ptr-declarator</em>, which is a <em>noptr-declarator</em>, which is a <em>declarator-id attribute-specifier-seq<sub>opt</sub></em> and finally a <em>declarator-id</em> consists of merely <code>...</code><sub>opt</sub> <em>id-expression</em>. </p>\n<p>For completeness, <code>[N4140/5.1.1]</code> says an <em>id-expression</em> can be an <em>unqualified-id</em>, or simply an <em>identifier</em>.</p>\n<p>If I haven't tripped up so far, this is what the grammar reflects.</p>\n<p><code>int</code> <em>decl-specifier-seq</em></p>\n<p><code>i</code> <em>unqualified-id</em></p>\n<p><code>= 0</code> <em>initializer</em></p>\n<p><code>int i = 0</code> <em>init-declarator</em></p>\n<p>Since the <em>simple-declaration</em> has the <em>decl-specifier-seq</em>, only one <em>decl-specifier-seq</em> applies to the entire <em>init-declarator-list</em>. </p>\n<p>Funnily enough, that means you can't do something like this:</p>\n<pre><code>int i, const j;\n</code></pre>\n<p>Yet:</p>\n<pre><code>int i, * j;\n</code></pre>\n<p>is perfectly legal because the star is part of a <em>ptr-operator</em>. But you can't do this:</p>\n<pre><code>int i, const * j; // pointer to const int\n</code></pre>\n<p>This means in the following code that <code>i</code> becomes a pointer to const int. Surprise!</p>\n<pre><code>int h = 25;\nint const * j, * i = &amp;h;\n*i = 50; // error: assignment of read-only location '* i'\n</code></pre>\n<p>The intent is clear in <code>[N4140/8]</code> with:</p>\n<blockquote>\n<p id=\"so_27432506_27432506_14\"><code>3</code> Each <em>init-declarator</em> in a declaration is analyzed separately as\n  if it was in a declaration by itself.<sup>99</sup></p>\n<p id=\"so_27432506_27432506_15\">99) A declaration with several declarators is usually equivalent to\n  the corresponding sequence of declarations each with a single\n  declarator. That is</p>\n<pre><code>T D1, D2, ... Dn;\n</code></pre>\n<p id=\"so_27432506_27432506_16\">is usually equivalent to</p>\n<pre><code>T D1; T D2; ... T Dn;\n</code></pre>\n</blockquote>\n<p>The question is why is it this way?</p>\n<hr/>\n<p>If it was legal, you could do it in for loops, which is somewhat useful.</p>\n", "Title": "How come you can't have multiple decl-specifier-seq's in a declaration?", "CreationDate": "2014-12-11T21:15:58.637", "LastActivityDate": "2014-12-19T18:42:35.233", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-11T21:29:54.800", "LastEditorUserId": "4351360", "Id": "27432506", "Score": "12", "OwnerUserId": "4351360", "Tags": "<c++>", "AnswerCount": "3"}, "27495044": {"Id": "27495044", "PostTypeId": "2", "Body": "<p>Short answer: one statement can allow only 'one declaration of a type' but this declaration can declare 'multiple identifiers'. Also const/volatile are either type qualifiers or pointer qualifiers so they need a type or a pointer to bind to.</p>\n<p>Long answer:</p>\n<p>I haven't ever read the standard but here I go...</p>\n<p>\"it prevents something silly like int int, but I don't see anything wrong with the invalid code posted above.\"</p>\n<ul>\n<li>The way I see it is that <strong>one statement can allow you only one declaration</strong> but one declaration can allow you to declare multiple identifiers of the same type.</li>\n<li>So the problem with int i = 0, double j = 2.0; is that you have two types, int and double. Which goes against [N4140/7.1.6].</li>\n<li>It's what the language allows and thus the above statement is incorrect.</li>\n</ul>\n<p>But you went ahead and dug deeper and I believe your confusion began here onward \"Since we're concerned with only syntax of the form...\". Wouldn't the declaration break up as follows?</p>\n<pre><code>int i = 0 ::= simple-declaration\nWhere in...\nint ::= type-specifier\ni ::= identifier\n= 0 ::= init-declarator\n</code></pre>\n<p>More</p>\n<p>You mentioned...</p>\n<pre><code>Not Allowed: int i, const j;\nAllowed: int i, * j;\nNot Allowed: int i, const * j; // pointer to const int\nAllowed: int const * j, * i = &amp;h;\n</code></pre>\n<p>My response:</p>\n<pre><code>Not Allowed: int i, const j; - because const is a type modifier, syntactically there is no type specified to bind to.\nAllowed: int i, * j; - because * grabs the type int and j has a complete type.\nNot Allowed: int i, const * j; - because const is not associated to a type here. It is the same problem as in the first case. Read it as j is a pointer to &lt;unexpected word in between&gt; and thus screws up the grammar.\nAllowed: int const * j, * i = &amp;h; - because syntactically const has a type to bind to.\n</code></pre>\n<p>\"The question is why is it this way?\"</p>\n<ul>\n<li><p>When I was learning C I was initially confused with the use of const before / after the type name and to clear the confusion I tried some test code and figured out what the language allows and the following is what I came up with. It is from my old notes. It definitely looks like something made by a new programmer. However, it clears most of the doubts.</p>\n<p><strong>[storage class] [sign qualifier] [size qualifier]  [type qualifiers] &lt;[* [type qualifiers]] [symbol name] [[] | ([parameters])]&gt;</strong></p>\n<p>storage classes: auto, register, static, extern, typedef</p>\n<p>sign qualifiers: signed, unsigned</p>\n<p>size qualifiers: short, long, long long</p>\n<p>basic types: char, int, float, double, void</p>\n<p>type qualifiers: const, volatile</p>\n<p>symbol name could be a variable, constant, type(def) name and function</p>\n<p>A * prefixed to the symbol makes it a pointer. * can appear N number of times, making it pointer-to-pointer and so on.</p>\n<p>A [] suffixed to the symbol makes it an array. [] can appear N number of times, making it a multi-dimension array.</p>\n<p>A () suffixed to the symbol makes it a function. () can appear N number of times but since a function cannot return a function, () can appear again when a function returns a function pointer.</p></li>\n</ul>\n<p>The above helped me think straight when declaring variables.</p>\n<p>Modifying the type specifier syntax from my age old notes:</p>\n<pre><code>[storage class] [sign qualifier] [size qualifier] &lt;type&gt; [type qualifiers] [* [pointer qualifiers]] [symbol name] [[] | ([parameters])]\n</code></pre>\n<p>That is const and volatile are either a type qualifier or a pointer qualifier and they need a type or a pointer to bind to qualify them.</p>\n<p>Consider the idea of \"one statement can allow you only one declaration but one declaration can allow you to declare multiple identifiers of the same type.\" This means the type specifier syntax can be broken down as follows:</p>\n<pre><code>type ::= [storage class] [sign qualifier] [size qualifier] &lt;type&gt; [type qualifiers]\n\nsymbol ::= [* [pointer qualifiers]] [symbol name] [[] | ([parameters])]\n</code></pre>\n<p>And a simplified syntax of a declaration would be:</p>\n<p>type symbol[, symbol...]</p>\n<p>Clearly,</p>\n<p>int i, const j; - does not agree with the grammar.</p>\n<p>int const  i, j; - agrees with the grammar.</p>\n<p>I am sure a person good with the standard can use the standard and provide the answer using the correct terminology and references. However, please keep in mind that less experienced programmers might find a less technical answer easy to understand.</p>\n<p>If the form \"int i, const j\" is allowed then one can write \"int const i, const j\" and that would means j is a double constant. That does not make any sense.</p>\n", "LastEditorUserId": "2623102", "LastActivityDate": "2014-12-17T17:48:01.223", "Score": "3", "CreationDate": "2014-12-15T23:27:48.130", "ParentId": "27432506", "CommentCount": "6", "LastEditDate": "2014-12-17T17:48:01.223", "OwnerUserId": "2623102"}, "27517199": {"Id": "27517199", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27432506_27517199_0\">The question is why is it this way?</p>\n</blockquote>\n<p>Unfortunately, I can't answer this with certainty. My guess is that it is a short-hand that came about to save keystrokes in C or one of its predecessors. I will say though that the <code>*</code> operator, IMHO, does change the type of the variable you have declared and so I don't know why it is allowed where <code>const</code> is not.</p>\n<p>I would also like to add an example that you have not included which <em>is legal</em>:</p>\n<pre><code>int i = 0, * const j = &amp;i;\n</code></pre>\n<p>And it is legal because the <code>const</code>, in this instance, is being applied to the <code>*</code> and not the <code>int</code>. At least according to <a href=\"http://ideone.com/BX61Hh\" rel=\"nofollow\">ideone</a>.</p>\n<p>It is likely that this is just legacy which needed to be brought forward.</p>\n<p>Your extract from the standard sheds some light on the topic:</p>\n<pre><code>99) A declaration with several declarators is usually equivalent to the corresponding sequence of declarations each with a single declarator. That is\n\nT D1, D2, ... Dn;\nis usually equivalent to\n\nT D1; T D2; ... T Dn;\n</code></pre>\n<p>The intent seems to be that the <code>Dn</code>'s when declared together separated by commas would be the same type. Because if you're changing types you might as well use a semicolon, since this saves you no keystrokes i.e.</p>\n<pre><code>int i, j = 0; double k, l = 7.3;\n</code></pre>\n<p>Here you've saved yourself typing <code>int</code> and <code>double</code> twice by using the comma in the right place.</p>\n<p>I can see your point with the type modifiers like <code>const</code>, <code>volatile</code> etc. Why not allow us to combine those at will? I mean how is this different from the <code>*</code>? I don't think that it is different and I hope that someone smarter than me will come and explain why. I would say either ban the <code>*</code> or allow us to use other modifiers too.</p>\n<p>So <strong>in short, I don't know, <em>but here's a cool additional example of the craziness</em></strong>:</p>\n<pre><code>int i = 0, * const j = &amp;i;\n</code></pre>\n", "LastEditorUserId": "1667513", "LastActivityDate": "2014-12-17T02:06:22.413", "Score": "2", "CreationDate": "2014-12-17T02:00:09.360", "ParentId": "27432506", "CommentCount": "0", "LastEditDate": "2014-12-17T02:06:22.413", "OwnerUserId": "1667513"}});