post_cb({"24043642": {"ParentId": "24036357", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>It's because of the relative ordering of overload resolution, template overload resolution, template declaration instantiation, and template <em>definition</em> instantiation.</p>\n<p>Let's look at the C++11 case first.  When the compiler needs to evaluate <code>decltype(iter(Int&lt;0&gt;{}))</code>, it performs overload resolution on the name <code>iter</code> called with arguments prvalue <code>Int&lt;0&gt;</code>. Since a template is in the overload set, we apply 14.8.3 <strong>[temp.over]</strong>:</p>\n<blockquote>\n<p id=\"so_24036357_24043642_0\">1 - A function template can be overloaded either by (non-template) functions of its name or by (other) function templates of the same name. When a call to that name is written (explicitly, or implicitly using the operator notation), template argument deduction (14.8.2) and checking of any explicit template arguments (14.3) are performed for each function template to find the template argument values (if any) that can be used with\n  that function template to instantiate a function template specialization that can be invoked with the call arguments. [...]</p>\n</blockquote>\n<p>As a result, the declaration <code>template&lt;int i&gt; constexpr auto iter(...) -&gt; ...</code> is instantiated (14.7.1p10 <strong>[temp.inst]</strong>) with <code>i = 0</code>, which forces the evaluation of <code>decltype(iter(Int&lt;-1&gt;{}))</code> and off down the rabbit hole of negative integers we go.</p>\n<p>It doesn't matter that <code>constexpr auto iter(Int&lt;0&gt;) -&gt; Int&lt;0&gt;</code> would be a better overload (by 13.3.3p1 <strong>[over.match.best]</strong>), because we never get that far; the compiler is away marching merrily towards negative infinity.</p>\n<p>By contrast, with C++14 deduced return types 7.1.6.4p12 <strong>[dcl.spec.auto]</strong> applies:</p>\n<blockquote>\n<p id=\"so_24036357_24043642_1\">12 - Return type deduction for a function template with a placeholder in its declared type occurs when the definition is instantiated [...]</p>\n</blockquote>\n<p>Since definition instantiation occurs <em>after</em> template overload resolution (14.7.1p3), the bad template <code>iter&lt;0&gt;</code> is never instantiated; 14.8.3p5:</p>\n<blockquote>\n<p id=\"so_24036357_24043642_2\">5 - Only the signature of a function template specialization is needed to enter the specialization in a set of candidate functions. Therefore only the function template declaration is needed to resolve a call for which a template specialization is a candidate.</p>\n</blockquote>\n<p>The \"signature\" of <code>iter&lt;0&gt;</code> here is <code>(Int&lt;0&gt;) -&gt; decltype(auto)</code>, a signature containing a <em>placeholder type</em> (7.1.6.4).</p>\n<hr>\n<p>Suggested workaround: use SFINAE to prevent any attempted call to <code>iter(Int&lt;-1&gt;{})</code>:</p>\n<pre><code>template&lt;int i&gt; constexpr auto iter(Int&lt;i&gt;)\n  -&gt; decltype(iter(typename std::enable_if&lt;i != 0, Int&lt;i-1&gt;&gt;::type{}));\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        ^^^^^^^\n</code></pre>\n<p>Note that the SFINAE has to go <em>inside</em> the <code>decltype</code>, and indeed inside the call to <code>iter</code>.</p>\n</hr>", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-06-04T18:06:38.577", "Id": "24043642", "Score": "11", "CreationDate": "2014-06-04T17:17:34.410", "LastActivityDate": "2014-06-04T18:06:38.577"}, "24036357": {"CommentCount": "3", "AcceptedAnswerId": "24043642", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-06-04T11:36:26.263", "LastActivityDate": "2014-06-04T18:06:38.577", "LastEditDate": "2014-06-04T16:11:06.847", "ViewCount": "781", "FavoriteCount": "4", "Title": "Name resolution for recursive trailing return type", "Id": "24036357", "Score": "15", "Body": "<p>I found a weird difference between explicit and automatic trailing return types.</p>\n<p>In the following code, we define a struct templated on an integer and an iter function, which take one object of this type as argument. The return type depends on the result of calling itself after decrementing the template value. </p>\n<p>To break the instantiation loop (or so I thought), I provide a specialization which returns a non-dependent type.</p>\n<p>We have a toy main to instantiate the templates.</p>\n<p>Here is a bit of code:</p>\n<pre><code>template&lt;int i&gt; struct Int {};\n\nconstexpr auto iter(Int&lt;0&gt;) -&gt; Int&lt;0&gt;;\n\ntemplate&lt;int i&gt; constexpr auto iter(Int&lt;i&gt;) -&gt; decltype(iter(Int&lt;i-1&gt;{}));\n\nint main(){\n  decltype(iter(Int&lt;10&gt;{})) a;\n}\n</code></pre>\n<p>This code does not work in both gcc 4.9 and clang 3.5. Both trigger infinite instantiation (they don't match the specialized base case).</p>\n<pre><code>rec.cpp:11:62: fatal error: recursive template instantiation exceeded maximum depth of 256\ntemplate&lt;int i&gt; constexpr auto iter(Int&lt;i&gt;) -&gt; decltype(iter(Int&lt;i-1&gt;{}));\n</code></pre>\n<p>Now, if we use C++14 <code>decltype(auto)</code> and we provide a body for the template which returns the exact same thing:</p>\n<pre><code>template&lt;int i&gt; struct Int {};\n\nconstexpr auto iter(Int&lt;0&gt;) -&gt; Int&lt;0&gt;;\n\ntemplate&lt;int i&gt;\nconstexpr auto iter(Int&lt;i&gt;) -&gt; decltype(auto) {\n  return iter(Int&lt;i-1&gt;{});\n}\n\nint main(){\n  decltype(iter(Int&lt;10&gt;{})) a;\n}\n</code></pre>\n<p>This now works for both compilers and behave as expected.</p>\n<p>I tried different ways to express the specialization and moved it around a bit (to be careful about its location), but that didn't prevent its self-immolation ;(</p>\n<p>I also tried to sprinkle the code with more <code>decltype</code> and <code>declval</code>, but I can't seem to get the C++11 syntax working.</p>\n<p>Could someone explain the difference between the two syntaxes for the name lookup?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "401200", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24036357_24043642_2": {"section_id": 359, "quality": 0.9523809523809523, "length": 20}, "so_24036357_24043642_0": {"section_id": 355, "quality": 0.9607843137254902, "length": 49}, "so_24036357_24043642_1": {"section_id": 5456, "quality": 1.0, "length": 13}}, "n3337": {"so_24036357_24043642_2": {"section_id": 349, "quality": 0.9523809523809523, "length": 20}, "so_24036357_24043642_0": {"section_id": 345, "quality": 0.9607843137254902, "length": 49}}, "n4659": {"so_24036357_24043642_2": {"section_id": 369, "quality": 0.9523809523809523, "length": 20}, "so_24036357_24043642_0": {"section_id": 365, "quality": 0.9607843137254902, "length": 49}, "so_24036357_24043642_1": {"section_id": 6882, "quality": 1.0, "length": 13}}}});