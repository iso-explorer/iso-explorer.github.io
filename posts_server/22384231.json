post_cb({"bq_ids": {"n4140": {"so_22384231_22384526_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 709}}, "n3337": {"so_22384231_22384526_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 698}}, "n4659": {"so_22384231_22384526_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 738}}}, "22384515": {"Id": "22384515", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22384231_22384515_0\">I thought containers have to rebind whatever allocator they are given into an allocator that works</p>\n</blockquote>\n<p>I can\u2019t find that requirement anywhere. Rather, <code>rebind</code> is used if the container needs to allocate <em>something other than <code>value_type</code></em>. Consider a typical, simplified <code>list</code> implementation:</p>\n<pre><code>template &lt;typename T, typename A = std::allocator&lt;T&gt;&gt;\nclass list {\n    struct node {\n        T value;\n        node* next;\n        node* prev;\n    };\n    using allocator = typename A::template rebind&lt;node&gt;::other;\n};\n</code></pre>\n<p>Here we need to use <code>rebind</code> because the <code>list</code> doesn\u2019t allocate <code>T</code>s; it allocates <code>list&lt;T&gt;::node</code>s.</p>\n", "LastEditorUserId": "1968", "LastActivityDate": "2014-03-13T16:22:21.457", "Score": "3", "CreationDate": "2014-03-13T16:12:42.167", "ParentId": "22384231", "CommentCount": "0", "OwnerUserId": "1968", "LastEditDate": "2014-03-13T16:22:21.457"}, "22384526": {"Id": "22384526", "PostTypeId": "2", "Body": "<p>23.2.1 [container.requirements.general]/7:</p>\n<blockquote>\n<p id=\"so_22384231_22384526_0\">All other constructors for these container types take an <code>Allocator&amp;</code> argument (17.6.3.5), an allocator whose value type is the same as the container\u2019s value type.</p>\n</blockquote>\n<p>So your code is invalid.</p>\n<p>The above is a rather obscure place to find this, though. We can do better. Table 99 (allocator-aware container requirements) requires in its first row that the container has an <code>allocator_type</code> nested type, whose <code>value_type</code> is identical to the container's. And the synopsis for <code>vector</code> (and the other containers) defines <code>allocator_type</code> thus:</p>\n<pre><code>typedef Allocator allocator_type;\n</code></pre>\n<p>In other words, the <code>Allocator</code> parameter you supply is responsible for fulfilling the requirement.</p>\n", "LastActivityDate": "2014-03-13T16:12:57.040", "CommentCount": "3", "CreationDate": "2014-03-13T16:12:57.040", "ParentId": "22384231", "Score": "4", "OwnerUserId": "8922"}, "22384231": {"ViewCount": "495", "Body": "<p>I thought containers have to rebind whatever allocator they are given into an allocator that works, but in STL that ships with LLVM (part of libc++, I guess), this doesn't seem to be the case. Is this a bug in LLVM, or does the standard not require rebinding?</p>\n<p>The following snippet works as expected with GCC's STL. It fails with STL that comes with clang 3.3 (from MacPorts, on a Mac). It compiles fine with clang on Linux, but I think that one uses the same STL as GCC.</p>\n<pre><code>#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;char, std::allocator&lt;int&gt; &gt;  c;\n    c.push_back(5);\n}\n</code></pre>\n<p>The error is</p>\n<pre><code>clang++ test-rebind.cpp \nIn file included from test-rebind.cpp:1:\n/opt/local/libexec/llvm-3.3/bin/../lib/c++/v1/vector:505:5: error: implicit instantiation of undefined template '__static_assert_test&lt;false&gt;'\n    static_assert((is_same&lt;typename allocator_type::value_type, value_type&gt;::value),\n    ^\n/opt/local/libexec/llvm-3.3/bin/../lib/c++/v1/__config:412:35: note: expanded from macro 'static_assert'\n    typedef __static_assert_check&lt;sizeof(__static_assert_test&lt;(__b)&gt;)&gt; \\\n                                  ^\ntest-rebind.cpp:5:46: note: in instantiation of template class 'std::__1::vector&lt;char, std::__1::allocator&lt;int&gt; &gt;' requested here\n    std::vector&lt;char, std::allocator&lt;int&gt; &gt;  c;\n                                             ^\n/opt/local/libexec/llvm-3.3/bin/../lib/c++/v1/__config:408:24: note: template is declared here\ntemplate &lt;bool&gt; struct __static_assert_test;\n                       ^\n1 error generated.\n</code></pre>\n", "AcceptedAnswerId": "22384526", "Title": "Is use of allocator::rebind required by C++ standard?", "CreationDate": "2014-03-13T16:02:33.353", "Id": "22384231", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-13T16:22:21.457", "Score": "1", "OwnerUserId": "44738", "Tags": "<c++><stl><allocator>", "AnswerCount": "2"}});