post_cb({"20317413": {"CommentCount": "3", "ViewCount": "9434", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-12-01T21:21:57.500", "LastActivityDate": "2015-09-10T03:07:13.310", "LastEditDate": "2015-09-10T03:07:13.310", "AcceptedAnswerId": "20383136", "FavoriteCount": "32", "Title": "What are transparent comparators?", "Id": "20317413", "Score": "70", "Body": "<p>In C++14, associative containers seem to have changed from C++11 \u2013 [associative.reqmts]/13 says:</p>\n<blockquote>\n<p id=\"so_20317413_20317413_0\">The member function templates <code>find</code>, <code>count</code>, <code>lower_bound</code>, <code>upper_bound</code>, and <code>equal_range</code> shall not participate in overload resolution unless the type <code>Compare::is_transparent</code> exists.</p>\n</blockquote>\n<p>What is the purpose of making an comparator \"transparent\"?</p>\n<p>C++14 also provides library templates like this:</p>\n<pre><code>template &lt;class T = void&gt; struct less {\n    constexpr bool operator()(const T&amp; x, const T&amp; y) const;\n    typedef T first_argument_type;\n    typedef T second_argument_type;\n    typedef bool result_type;\n};\n\ntemplate &lt;&gt; struct less&lt;void&gt; {\n    template &lt;class T, class U&gt; auto operator()(T&amp;&amp; t, U&amp;&amp; u) const\n    -&gt; decltype(std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u));\n    typedef *unspecified* is_transparent;\n};\n</code></pre>\n<p>So for example, <code>std::set&lt;T, std::less&lt;T&gt;&gt;</code> would <em>not</em> have a transparent comparator, but <code>std::set&lt;T, std::less&lt;&gt;&gt;</code> <em>would</em> have one.</p>\n<p>What problem does this solve, and does this change how standard containers work? For example, the template parameters of <code>std::set</code> are still <code>Key, Compare = std::less&lt;Key&gt;, ...</code>, so does the default set lose its <code>find</code>, <code>count</code>, etc. members?</p>\n", "Tags": "<c++><c++14><c++-faq>", "OwnerUserId": "596781", "AnswerCount": "4"}, "20383485": {"ParentId": "20317413", "CommentCount": "0", "CreationDate": "2013-12-04T18:52:11.067", "OwnerUserId": "153891", "PostTypeId": "2", "Id": "20383485", "Score": "4", "Body": "<p>Stephan T Lavavej talks about problems where the compiler keeps creating temporaries, and how his proposal of transparent operator functors will solve this in c++1y</p>\n<p><a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Don-t-Help-the-Compiler\" rel=\"nofollow\">GoingNative 2013 - Dont help the Compiler</a> (at about the hour mark)</p>\n", "LastActivityDate": "2013-12-04T18:52:11.067"}, "20318064": {"ParentId": "20317413", "LastEditDate": "2013-12-01T22:34:24.207", "CommentCount": "2", "CreationDate": "2013-12-01T22:28:27.590", "Score": "25", "LastEditorUserId": "1120273", "PostTypeId": "2", "Id": "20318064", "OwnerUserId": "1120273", "Body": "<p>In C++11 there are not member templates <code>find()</code>, <code>lower_bound()</code>, etc. That is, nothing is lost by this change. The member templates were introduced with n3657 to allow heterogeneous keys being used with the associative containers. I don't see any concrete example where this is useful except for the example which is good and bad!</p>\n<p>The <code>is_transparent</code> use is intended to avoid unwanted conversions. If the member templates were unconstrained, existing code may pass through objects directly which would have been converted without the member templates. The example use-case from n3657 is locating an object in a <code>std::set&lt;std::string&gt;</code> using a string literal: with the C++11 definition a <code>std::string</code> object is constructed when passing a string literals to the corresponding member function. With the change it is possible to use the string literal directly. If the underlying comparison function object is implemented exclusively in terms of <code>std::string</code> that is bad because now a <code>std::string</code> would be created for each comparison. On the other hand, if the underlying comparison function object can take a <code>std::string</code> and a string literal, that may avoid construction of a temporary object.</p>\n<p>The nested <code>is_transparent</code> type in the comparison function object provides a way to specify if the templated member function should be used: if the comparison function object can deal with heterogeneous arguments, it defines this type to indicate that it can deal with different arguments efficiently. For example, the new operator function objects just delegate to <code>operator&lt;()</code> and claim to be transparent. That, at least, works for <code>std::string</code> which has overloaded less than operators taking <code>char const*</code> as argument. Since these function objects are also new, even if they do the wrong thing (i.e. require a conversion for some type) it would, at least, not be a silent change resulting in a performance degradation.</p>\n", "LastActivityDate": "2013-12-01T22:34:24.207"}, "20318388": {"CommentCount": "7", "CreationDate": "2013-12-01T23:05:03.423", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-06T06:21:25.560", "ParentId": "20317413", "LastEditDate": "2017-05-23T11:54:27.700", "LastEditorDisplayName": "user1508519", "PostTypeId": "2", "Id": "20318388", "Score": "14", "Body": "<p><sub>The following is all copy-pasta from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm\" rel=\"nofollow noreferrer\">n3657</a>.</sub></p>\n<blockquote>\n<p id=\"so_20317413_20318388_0\">Q. <em>What is the purpose of making an comparator \"transparent\"?</em></p>\n<p id=\"so_20317413_20318388_1\">A. The associative container lookup functions (find, lower_bound,\n  upper_bound, equal_range) only take an argument of key_type, requiring\n  users to construct (either implicitly or explicitly) an object of the\n  key_type to do the lookup. This may be expensive, e.g. constructing a\n  large object to search in a set when the comparator function only\n  looks at one field of the object.  There is strong desire among users\n  to be able to search using other types which are comparable with the\n  key_type.</p>\n<p id=\"so_20317413_20318388_2\">Q. <em>What problem does this solve</em></p>\n<p id=\"so_20317413_20318388_3\">A. The LWG had concerns about code like the following:</p>\n<pre><code>std::set&lt;std::string&gt; s = /* ... */;\ns.find(\"key\");\n</code></pre>\n<p id=\"so_20317413_20318388_4\">In C++11 this will construct a single std::string temporary and then\n  compare it with elements to find the key.</p>\n<p id=\"so_20317413_20318388_5\">With the change proposed by N3465 the std::set::find() function would\n  be an unconstrained template which would pass the const char* through\n  to the comparator function, std::less, which would\n  construct a std::string temporary for every comparison.  The LWG\n  considered this performance problem to be a serious issue.  The\n  template find() function would also prevent finding NULL in a\n  container of pointers, which causes previously valid code to no longer\n  compile, but this was seen as a less serious issue than the silent\n  performance regression</p>\n<p id=\"so_20317413_20318388_6\">Q. <em>does this change how standard containers work</em></p>\n<p id=\"so_20317413_20318388_7\">A. This proposal modifies the associative containers in  and \n  by overloading the lookup member functions with member function\n  templates. There are no language changes.  </p>\n<p id=\"so_20317413_20318388_8\">Q. <em>so does the default set lose its find, count, etc. members</em></p>\n<p id=\"so_20317413_20318388_9\">A. Almost all existing C++11 code is unaffected because the member\n  functions are not present unless new C++14 library features are used\n  as the comparison functions.</p>\n</blockquote>\n<p>To quote <a href=\"https://stackoverflow.com/questions/18939882/raw-pointer-lookup-for-sets-of-unique-ptrs\">Yakk</a>,</p>\n<blockquote>\n<p id=\"so_20317413_20318388_10\">In C++14, std::set::find is a template function if\n  Compare::is_transparent exists. The type you pass in does not need to\n  be Key, just equivalent under your comparator.</p>\n</blockquote>\n<p>and n3657,</p>\n<blockquote>\n<p id=\"so_20317413_20318388_11\">Add paragraph 13 in 23.2.4 [associative.reqmts]:\n  The member function templates find, lower_bound, upper_bound and\n  equal_range shall not participate in overload resolution unless the\n  type Compare::is_transparent <strike>does not exist</strike> does exist.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421\" rel=\"nofollow noreferrer\">n3421</a> provides an example of <a href=\"https://stackoverflow.com/questions/17737132/transparent-operator-functors\">\"Transparent Operator Functors\"</a>. </p>\n<p>The <a href=\"http://coliru.stacked-crooked.com/a/b13c99f3567c163e\" rel=\"nofollow noreferrer\">full code is here</a>.</p>\n", "OwnerDisplayName": "user1508519"}, "20383136": {"ParentId": "20317413", "LastEditDate": "2017-05-23T11:46:55.120", "CommentCount": "2", "CreationDate": "2013-12-04T18:32:47.200", "Score": "35", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "20383136", "OwnerUserId": "981959", "Body": "<blockquote>\n<p id=\"so_20317413_20383136_0\">What problem does this solve,</p>\n</blockquote>\n<p>See Dietmar and remyabel's answer.</p>\n<blockquote>\n<p id=\"so_20317413_20383136_1\">and does this change how standard containers work?</p>\n</blockquote>\n<p>No, not by default.</p>\n<p>The new member function template overloads of <code>find</code> etc. allow you to use a type that is comparable with the container's key, instead of using the key type itself.  See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf\" rel=\"nofollow noreferrer\">N3465</a> by Joaqu\u00edn M\u00aa L\u00f3pez Mu\u00f1oz for rationale and a detailed, carefully written proposal to add this feature.</p>\n<p>At the Bristol meeting the LWG agreed that the heteregeneous lookup feature was useful and desirable, but we could not be sure that Joaqu\u00edn's proposal would be safe in all cases. The N3465 proposal would have caused serious problems for some programs (see the <strong>Impact on existing code</strong> section). Joaqu\u00edn prepared an updated draft proposal with some alternative implementations with different trade-offs, which was very useful helping the LWG understand the pros and cons, but they all risked breaking some programs in some way so there was no consensus to add the feature.  We decided that although it wouldn't be safe to add the feature unconditionally, it would be safe if it was disabled by default and only \"opt in\".</p>\n<p>The key difference of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm\" rel=\"nofollow noreferrer\">N3657</a> proposal (which was a last-minute revision by myself and STL based on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf\" rel=\"nofollow noreferrer\">N3465</a> and a later unpublished draft by Joaqu\u00edn) was to add the <code>is_transparent</code> type as the protocol that can be used to opt in to the new functionality.</p>\n<p>If you don't use a \"transparent functor\" (i.e. one that defines a <code>is_transparent</code> type) then the containers behave the same as they've always done, and that's still the default.</p>\n<p>Iff you choose to use <code>std::less&lt;&gt;</code> (which is new for C++14) or another \"transparent functor\" type then you get the new functionality.</p>\n<p>Using <code>std::less&lt;&gt;</code> is easy with alias templates:</p>\n<pre><code>template&lt;typename T, typename Cmp = std::less&lt;&gt;, typename Alloc = std::allocator&lt;T&gt;&gt;\n  using set = std::set&lt;T, Cmp, Alloc&gt;;\n</code></pre>\n<p>The name <code>is_transparent</code> comes from STL's <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm\" rel=\"nofollow noreferrer\">N3421</a> which added the \"diamond operators\" to C++14. A \"transparent functor\" is one which accepts any argument types (which don't have to be the same) and simply forwards those arguments to another operator.  Such a functor happens to be exactly what you want for heterogeneous lookup in associative containers, so the type <code>is_transparent</code> was added to all the diamond operators and used as the tag type to indicate the new functionality should be enabled in associative containers. Technically, the containers don't need a \"transparent functor\", just one that supports calling it with heterogeneous types (e.g. the <code>pointer_comp</code> type in <a href=\"https://stackoverflow.com/a/18940595/981959\">https://stackoverflow.com/a/18940595/981959</a> is not transparent according to STL's definition, but defining <code>pointer_comp::is_transparent</code> allows it to be used to solve the problem). If you only ever lookup in your <code>std::set&lt;T, C&gt;</code> with keys of type <code>T</code> or <code>int</code> then <code>C</code> only needs to be callable with arguments of type <code>T</code> and <code>int</code> (in either order), it doesn't need to be truly transparent.   We used that name partly because we couldn't come up with a better name (I would have preferred <code>is_polymorphic</code> because such functors use static polymorphism, but there's already a <code>std::is_polymorphic</code> type trait which refers to dynamic polymorphism). </p>\n", "LastActivityDate": "2013-12-04T19:38:11.403"}, "bq_ids": {"n4140": {"so_20317413_20317413_0": {"section_id": 749, "quality": 0.8, "length": 12}, "so_20317413_20318388_11": {"section_id": 749, "quality": 0.5238095238095238, "length": 11}}, "n4659": {"so_20317413_20317413_0": {"section_id": 808, "quality": 0.8, "length": 12}, "so_20317413_20318388_11": {"section_id": 808, "quality": 0.5238095238095238, "length": 11}}}});