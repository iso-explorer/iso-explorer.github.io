post_cb({"17496410": {"ParentId": "17496268", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I believe this is due to 14.8.2.1/1:</p>\n<blockquote>\n<p id=\"so_17496268_17496410_0\">[...] an initializer list argument causes the parameter to be considered a non-deduced context (14.8.2.5). [<em>Example:</em> [...]</p>\n<pre><code>template&lt;class T&gt; void g(T);\ng({1,2,3});                    // error: no argument deduced for T\n</code></pre>\n<p id=\"so_17496268_17496410_1\">\u2014 <em>end example</em>]</p>\n</blockquote>\n<p>Now you may think that <code>auto</code> is just template argument deduction, but for braced lists <code>auto</code> receives special treatment in 7.1.6.4/6:</p>\n<blockquote>\n<p id=\"so_17496268_17496410_2\">replacing the occurrences of <code>auto</code> with either a new invented type template parameter U or, if the initializer is a <em>braced-init-list</em> (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>. [...] [<em>Example</em>:</p>\n<pre><code>auto x1 = { 1, 2 };   // decltype(x1) is std::initializer_list&lt;int&gt;\n</code></pre>\n<p id=\"so_17496268_17496410_3\">\u2014 <em>end example</em>]</p>\n</blockquote>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2013-07-05T20:33:03.690", "Id": "17496410", "Score": "9", "CreationDate": "2013-07-05T20:27:21.277", "LastActivityDate": "2013-07-05T20:33:03.690"}, "bq_ids": {"n4140": {"so_17496268_17496410_0": {"section_id": 302, "quality": 0.7777777777777778, "length": 7}, "so_17496268_17496410_2": {"section_id": 5451, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_17496268_17496410_0": {"section_id": 293, "quality": 0.7777777777777778, "length": 7}, "so_17496268_17496410_2": {"section_id": 5245, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_17496268_17496410_0": {"section_id": 309, "quality": 0.7777777777777778, "length": 7}, "so_17496268_17496410_2": {"section_id": 6889, "quality": 0.7142857142857143, "length": 10}}}, "17496268": {"CommentCount": "3", "AcceptedAnswerId": "17496410", "PostTypeId": "1", "LastEditorUserId": "1003615", "CreationDate": "2013-07-05T20:14:43.973", "LastActivityDate": "2013-07-05T20:33:03.690", "LastEditDate": "2013-07-05T20:28:00.200", "ViewCount": "328", "FavoriteCount": "1", "Title": "type inference with rvalue initializer_list", "Id": "17496268", "Score": "11", "Body": "<p>In the following code</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;typename T&gt; void f(T&amp;&amp; x) {}\ntemplate&lt;typename T&gt; void g(std::initializer_list&lt;T&gt; x) {}\n\nint main()\n{\n    auto   x = {0}; // OK\n    auto&amp;&amp; y = {0}; // OK\n    g(x); // OK\n    g(std::move(x)); // OK\n    g({0}); // OK\n    f(x); // OK\n    f(std::move(x)); // OK\n    f({0}); // failure\n    return 0;\n}\n</code></pre>\n<p>rvalue <code>initializer_list</code> can be deduced with <code>auto</code> but not with <code>template</code>.</p>\n<p>Why C++ forbids this?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1003615", "AnswerCount": "1"}});