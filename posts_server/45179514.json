post_cb({"bq_ids": {"n4140": {"so_45179514_45179751_2": {"length": 35, "quality": 1.0, "section_id": 481}}, "n3337": {"so_45179514_45179751_2": {"length": 32, "quality": 0.9142857142857143, "section_id": 472}}, "n4659": {"so_45179514_45179751_2": {"length": 35, "quality": 1.0, "section_id": 504}, "so_45179514_45179751_0": {"length": 9, "quality": 1.0, "section_id": 504}}}, "45179751": {"Id": "45179751", "PostTypeId": "2", "Body": "<h3>First Example</h3>\n<p>For your first example, the answer is clearly \"no\". The standard gives permission for the compiler to take various liberties about copies (even with side effects) when dealing with the return value from a function. I suppose, in the specific case of <code>std::string</code>, the compiler could \"know\" that neither copying nor moving has any side effects, so it could substitute one for the other under the as-if rule. If, however, we had something like:</p>\n<pre><code>struct foo {\n    foo(foo const &amp;f) { std::cout &lt;&lt; \"copy ctor\\n\"; }\n    foo(foo &amp;&amp;f) { std::cout &lt;&lt; \"move ctor\\n\"; }\n};\n\nfoo outer;\n{ \n    foo inner;\n    // ...\n    outer = inner;\n}\n</code></pre>\n<p>...a properly functioning compiler <em>must</em> generate code that prints out \"copy ctor\", not \"move ctor\". There's really no specific citation for this--rather, there are citations talking about exceptions for return values from functions, which don't apply here because we're not dealing with the return value from a function.</p>\n<p>As to why nobody's dealt with this: I'd guess that it's simply because nobody's bothered. Returning values from functions happens often enough that it's worth putting a fair amount of effort into optimizing it. Creating a non-function block, and creating a value in the block that you proceed to copy to a value outside the block to maintain its visibility happens rarely enough that it seems unlikely anybody's written up a proposal.</p>\n<h3>Second Example</h3>\n<p>This example <em>is</em> at least returning a value from a function--so we have to look at the specifics of the exceptions that allow moves instead of copies.</p>\n<p>Here, the rule is (N4659, \u00a7[class.copy.elision]/3):</p>\n<blockquote>\n<p id=\"so_45179514_45179751_0\">In the following copy-initialization contexts, a move operation might be used instead of a copy operation:</p>\n<ul>\n<li>If the expression in a return statement (9.6.3) is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression,</li>\n</ul>\n<p id=\"so_45179514_45179751_1\">[...]</p>\n<p id=\"so_45179514_45179751_2\">overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If the first overload resolution fails or was not performed, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>The expression (<code>y</code>) in your return statement is an id-expression that names an object with automatic storage duration declared in the body of the innermost enclosing function, so the compiler must do the two-stage overload resolution.</p>\n<p>However, what it's looking for at this point is a constructor to create an <code>X</code> from a <code>Y</code>. <code>X</code> defines one (and only one) such constructor--but that constructor receives its <code>Y</code> <em>by value</em>. Since that's the only available constructor, that's the one that \"wins\" in overload resolution. Since it takes its argument by value, the fact that we first tried overload resolution treating <code>y</code> as an rvalue doesn't really make any difference, because <code>X</code> doesn't have a ctor of the right type to receive it.</p>\n<p>Now, <em>if</em> we defined <code>X</code> something like this:</p>\n<pre><code>struct X\n{\n    X(Y &amp;&amp;y);\n    X(Y const &amp;y); \n\n    Y y_;\n}\n</code></pre>\n<p>...<strong>then</strong> the two-stage overload resolution would have a real effect--even though <code>y</code> designates an lvalue, the first round of overload resolution treats it as an rvalue, so <code>X(Y &amp;&amp;y)</code> would be selected and used to create the temporary <code>X</code> that gets returned--that is, we'd get a move instead of a copy (even though <code>y</code> is an lvalue, and we have a copy constructor that takes an lvalue reference).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2017-07-19T21:13:26.220", "Score": "8", "CreationDate": "2017-07-19T01:56:33.510", "ParentId": "45179514", "CommentCount": "5", "OwnerUserId": "179910", "LastEditDate": "2017-07-19T21:13:26.220"}, "45179514": {"ViewCount": "207", "Body": "<p><strong>EDIT:</strong> Consider 2 following examples:</p>\n<pre><code>std::string x;\n{\n    std::string y = \"extremely long text ...\";\n    ...\n    x = y; // *** (1)\n}\ndo_something_with(x);\n</code></pre>\n<hr>\n<pre><code>struct Y\n{\n    Y();\n    Y(const Y&amp;);\n    Y(Y&amp;&amp;);\n    ... // many \"heavy\" members\n};\n\nstruct X\n{\n    X(Y y) : y_(std::move(y)) { }\n    Y y_;\n}\n\nX foo()\n{\n    Y y;\n    ...\n    return y; // *** (2)\n}\n</code></pre>\n<p>In both examples <code>y</code> on lines (1) and (2) is near end of its lifetime and is about to be destroyed. It seems obvious that it can be treated as an rvalue and be moved in both cases. In (1) its contents can be moved into <code>x</code> and in (2) into temp instance of <code>X().y_</code>.</p>\n<p>My questions are:</p>\n<p>1) Will it be moved in either of the above examples?\n    (a) If yes, under what standard provision.\n    (b) If no, why not? Is that an omission in the standard or is there another reason that I am not thinking of?</p>\n<p>2) If the above answer is NO. In the first example I can change (1) to <code>x = std::move(y)</code> to force the compiler to perform the move. What can I do in the second example to indicate to the compiler that <code>y</code> can be moved? <code>return std::move(y)</code>?</p>\n<p>NB: I am purposely returning an instance of <code>Y</code> and not <code>X</code> in (2) to avoid (N)RVO.</p>\n</hr>", "AcceptedAnswerId": "45179751", "Title": "Can an lvalue at end of scope be treated as an rvalue?", "CreationDate": "2017-07-19T01:21:55.457", "Id": "45179514", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-19T15:40:40.160", "LastEditorUserId": "4358570", "LastActivityDate": "2017-07-19T21:13:26.220", "Score": "6", "OwnerUserId": "4358570", "Tags": "<c++><c++14><lvalue-to-rvalue>", "AnswerCount": "2"}, "45179698": {"Id": "45179698", "PostTypeId": "2", "Body": "<p>Why not just use <code>outer</code> for everything? Or if working with a function pass in <code>&amp;outer</code> . Then, inside the function work with <code>*inner</code>.</p>\n", "LastActivityDate": "2017-07-19T01:49:00.897", "CommentCount": "1", "CreationDate": "2017-07-19T01:49:00.897", "ParentId": "45179514", "Score": "-3", "OwnerUserId": "6917518"}});