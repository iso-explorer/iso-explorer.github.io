post_cb({"4365157": {"ViewCount": "237", "Body": "<p><em><strong>C++03 5.3.5.3</strong></em></p>\n<blockquote>\n<p id=\"so_4365157_4365157_0\">In the first alternative (delete\n  object), if the static type of the\n  operand is different from its dynamic\n  type, the static type shall be a base\n  class of the operand\u2019s dynamic type\n  and the static type shall have a\n  virtual destructor or the behavior is\n  undefined.</p>\n</blockquote>\n<p>This is the theory. The question, however, is a practical one. What if the derived class adds no data members? </p>\n<pre><code>struct Base{\n   //some members\n   //no virtual functions, no virtual destructor\n};\nstruct Derived:Base{\n   //no more data members\n   //possibly some more nonvirtual member functions\n};\n\nint main(){\n     Base* p = new Derived;\n     delete p; //UB according to the quote above\n}\n</code></pre>\n<p>The question: <strong><em>is there any existing implementation on which this would really be dangerous?</em></strong>\nIf so, could you please describe how the internals are implemented in that implementation which makes this code crash/leak or whatever? I <em>beg</em> you to believe, I <em>swear</em> that I have no intentions to rely on this behavior :) </p>\n", "AcceptedAnswerId": "4365257", "Title": "virtual destructor's practical necessity in a particular case", "CreationDate": "2010-12-06T09:57:48.427", "Id": "4365157", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2010-12-06T11:21:47.703", "Score": "0", "OwnerUserId": "469935", "Tags": "<c++><virtual-destructor>", "AnswerCount": "5"}, "4365257": {"Id": "4365257", "PostTypeId": "2", "Body": "<p>One example is if you provide a custom <code>operator new</code> in <code>struct Derived</code>. Obviously calling wrong <code>operator delete</code> will likely produce devastating results.</p>\n", "LastActivityDate": "2010-12-06T10:06:55.440", "CommentCount": "14", "CreationDate": "2010-12-06T10:06:55.440", "ParentId": "4365157", "Score": "6", "OwnerUserId": "57428"}, "4365413": {"Id": "4365413", "PostTypeId": "2", "Body": "<p>I know of no implementation on which the above would be dangerous, and I think it unlikely that there ever will be such an implementation.</p>\n<p>Here's why:</p>\n<p>\"undefined behaviour\" is a catch-all phrase meaning (as everyone knows), anything could happen. The code could eat your lunch, or do nothing at all. </p>\n<p>However, compiler <em>writers</em> are sane people, and there's a difference between undefined behaviour at compile-time, and undefined behaviour at run-time. If I was writing a compiler for an implementation where the code snippet above was dangerous, <strong>it would be easy to catch and prevent at compile time.</strong> I can says it's a compilation error (or warning, maybe): <code>Error 666: Cannot derive from class with non-virtual destructor.</code></p>\n<p>I think I'm allowed to do that, because the compiler's behaviour in this case is <em>not</em> defined by the standard.</p>\n", "LastEditorUserId": "1737", "LastActivityDate": "2010-12-06T10:53:32.650", "Score": "1", "CreationDate": "2010-12-06T10:27:08.527", "ParentId": "4365157", "CommentCount": "2", "OwnerUserId": "1737", "LastEditDate": "2010-12-06T10:53:32.650"}, "4365387": {"Id": "4365387", "PostTypeId": "2", "Body": "<p>I can't answer for specific compilers, you'd have to ask the compiler writers. Even if a compiler works now, it might not do so in the next version so I would not rely on it.</p>\n<p>Do you need this behaviour?</p>\n<p>Let me guess that</p>\n<ol>\n<li>You want to be able to have a base class pointer without seeing the derived class and</li>\n<li>Not have a v-table in Base and</li>\n<li>Be able to clean up in the base class pointer.</li>\n</ol>\n<p>If those are your requirements it is possible to do, with boost::shared_ptr or your own adaptation.</p>\n<p>At the point you pass the pointer you pass in a boost::shared_ptr with an actual \"Derived\" underneath. When it is deleted it will use the destructor that was created when the pointer was created which uses the correct delete. You should probably give Base a protected destructor though to be safe.</p>\n<p>Note that there still is a v-table but it is in the shared pointer deleter base not in the class itself.</p>\n<p>To create your own adaptation, if you use boost::function and boost::bind you don't need a v-table at all. You just get your boost::bind to wrap the underlying Derived* and the function calls delete on it.</p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2010-12-06T10:29:17.840", "Score": "0", "CreationDate": "2010-12-06T10:24:17.417", "ParentId": "4365157", "CommentCount": "1", "OwnerUserId": "442284", "LastEditDate": "2010-12-06T10:29:17.840"}, "4365841": {"Id": "4365841", "PostTypeId": "2", "Body": "<p>I totally agree with 'Roddy'.</p>\n<p>Unless you're writing the code for perverted compiler designed for a non-existing virtual machine just to prove that so-called <em>undefined behavior</em> can bite - there's no problem.</p>\n<p>The point of 'sharptooth' about custom <code>new/delete</code> operators is inapplicable here. Because virtual d'tor and won't solve in any way the problem he/she describes.</p>\n<p>However it's a good point though. It means that the model where you provide a virtual d'tor and by such enable the polymorphic object creating/deletion is defective by design.\nA more correct design is to equip such objects with a virtual function that does two things at once: call its (correct) destructor, and also free its memory the way it should be freed. In simple words - destroy the object by the appropriate means, which are known for the object itself.</p>\n", "LastActivityDate": "2010-12-06T11:21:47.703", "CommentCount": "2", "CreationDate": "2010-12-06T11:21:47.703", "ParentId": "4365157", "Score": "0", "OwnerUserId": "1560850"}, "bq_ids": {"n4140": {"so_4365157_4365157_0": {"length": 23, "quality": 0.92, "section_id": 6107}}, "n3337": {"so_4365157_4365157_0": {"length": 23, "quality": 0.92, "section_id": 5873}}, "n4659": {"so_4365157_4365157_0": {"length": 23, "quality": 0.92, "section_id": 7604}}}, "4365805": {"Id": "4365805", "PostTypeId": "2", "Body": "<p>In your particular case, where you do not have any data member declared in the derived class and if you do not have any custom new/delete operators (as mentioned by Sharptooth), you may not have any problems ,but do you guarantee that no user will ever derive your class? If you do not make your <code>Base's</code> destructor virtual, there is no way for any of the classes derived from <code>Derived</code> to call their destructors in case the objects of derived classes are used via a <code>Base</code> pointer. </p>\n<p>Also, there is a general notion that if you have virtual functions in your base class, the destructor should be made virtual. So better not surprise anybody :)</p>\n", "LastActivityDate": "2010-12-06T11:15:10.280", "CommentCount": "0", "CreationDate": "2010-12-06T11:15:10.280", "ParentId": "4365157", "Score": "0", "OwnerUserId": "240857"}});