post_cb({"21178903": {"CommentCount": "4", "ViewCount": "331", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-01-17T05:59:49.320", "LastActivityDate": "2014-01-17T06:37:48.900", "Title": "reinterpret_cast behavior when dereferencing a void pointer", "LastEditDate": "2017-05-23T12:03:59.320", "Id": "21178903", "Score": "3", "Body": "<p>While arguing with someone over the suggestion he made in the comment thread of <a href=\"https://stackoverflow.com/a/21177728/241631\">this answer</a>, I came across some code that gcc4.8 and VS2013 refuse to compile but clang happily accepts it and displays the correct result.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int i{ 5 };\n    void* v = &amp;i;\n    std::cout &lt;&lt; reinterpret_cast&lt;int&amp;&gt;(*v) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/20806bf917a7f8ca\" rel=\"nofollow noreferrer\">Live demo</a>. Both GCC and VC fail with the error I was expecting, complaining that the code attempts to dereference a <code>void*</code> within the <code>reinterpret_cast</code>. So I decided to look this up in the standard. From N3797, <em>\u00a75.2.10/11 [expr.reinterpret.cast]</em></p>\n<blockquote>\n<p id=\"so_21178903_21178903_0\">A glvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. The result refers to the same object as the source glvalue, but with the specified type. [ <em>Note:</em> That is, for lvalues, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). <em>\u2014end note</em> ] No temporary is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called. </p>\n</blockquote>\n<p>In this case <code>T1</code> is <code>void</code> and <code>T2</code> is <code>int</code>, and a <code>void*</code> can be converted to <code>int*</code> using <code>reinterpret_cast</code>. So all requirements are met. </p>\n<p>According to the note, <code>reinterpret_cast&lt;int&amp;&gt;(*v)</code> has the same effect as <code>*reinterpret_cast&lt;int*&gt;(&amp;(*v))</code>, which, by my reckoning, is the same as <code>*reinterpret_cast&lt;int*&gt;(v)</code>.</p>\n<p>So is this a GCC and VC bug, or are clang and I misinterpreting this somehow?</p>\n", "Tags": "<c++><reinterpret-cast>", "OwnerUserId": "241631", "AnswerCount": "3"}, "21179058": {"ParentId": "21178903", "CommentCount": "0", "Body": "<p>If <code>v</code> is of type <code>void *</code>, then <code>*v</code> just makes no sense. The problem is not the cast, the problem is that it is illegal to dereference a pointer to void.</p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "21179058", "Score": "1", "CreationDate": "2014-01-17T06:11:12.457", "LastActivityDate": "2014-01-17T06:11:12.457"}, "21179084": {"ParentId": "21178903", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Thing is, the expression inside the cast is invalid. According to \u00a75.3.1 <em>Unary Operators</em>:</p>\n<blockquote>\n<p id=\"so_21178903_21179084_0\">The unary * operator performs indirection: the expression to which it is applied shall be <strong>a pointer to an object type</strong>, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1. \u2014 end note ]</p>\n</blockquote>\n<p><code>void</code> isn't an object type. So things stop there, the whole expression is invalid. clang appears to get this wrong here.</p>\n<p>What's more, the <code>void</code> type can only be used in a specific set of circumstances as per \u00a73.9.1 <em>Fundamental types</em>:</p>\n<blockquote>\n<p id=\"so_21178903_21179084_1\">An expression of type void shall be used only as an expression statement (6.2), as an operand of a comma expression (5.18), as a second or third operand of ?: (5.16), as the operand of typeid or decltype, as the expression in a return statement (6.6.3) for a function with the return type void, or as the operand of an explicit conversion to type cv void.</p>\n</blockquote>\n<p>So even if the derefence was legal, you can't use a <code>void</code> \"object\" as the source in a cast (except a cast to void).</p>\n<p><code>reinterpret_cast&lt;int&amp;&gt;(*v)</code> might indeed have the same effect as <code>*reinterpret_cast&lt;int*&gt;(&amp;(*v))</code> <em>when both these expressions are valid</em> (and no fancy operator overloading ruins the day). Just because an expression could be re-written in a valid form doesn't imply that it is itself valid.</p>\n", "OwnerUserId": "635608", "LastEditorUserId": "635608", "LastEditDate": "2014-01-17T06:37:48.900", "Id": "21179084", "Score": "3", "CreationDate": "2014-01-17T06:13:30.823", "LastActivityDate": "2014-01-17T06:37:48.900"}, "21179190": {"ParentId": "21178903", "CommentCount": "0", "Body": "<p>An expression of type <code>void</code> is allowed as a mostly just syntactical device in a <code>return</code> statement, and also you can cast an expression to <code>void</code>, but that's all: there are no glvalues of type <code>void</code>, an expression of type <code>void</code> does not refer to memory. Thus the quoted passage from the standard, starting with a glvalue, does not apply. Thus, clang is wrong.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "21179190", "Score": "3", "CreationDate": "2014-01-17T06:21:28.110", "LastActivityDate": "2014-01-17T06:21:28.110"}, "bq_ids": {"n4140": {"so_21178903_21179084_1": {"section_id": 7218, "quality": 0.896551724137931, "length": 26}, "so_21178903_21178903_0": {"section_id": 6050, "quality": 0.8113207547169812, "length": 43}, "so_21178903_21179084_0": {"section_id": 6064, "quality": 0.8431372549019608, "length": 43}}, "n3337": {"so_21178903_21179084_1": {"section_id": 6962, "quality": 0.896551724137931, "length": 26}, "so_21178903_21178903_0": {"section_id": 5818, "quality": 0.6037735849056604, "length": 32}, "so_21178903_21179084_0": {"section_id": 5832, "quality": 0.8823529411764706, "length": 45}}, "n4659": {"so_21178903_21179084_1": {"section_id": 8727, "quality": 0.7931034482758621, "length": 23}, "so_21178903_21178903_0": {"section_id": 7549, "quality": 0.8113207547169812, "length": 43}, "so_21178903_21179084_0": {"section_id": 7560, "quality": 0.8431372549019608, "length": 43}}}});