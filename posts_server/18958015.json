post_cb({"18958178": {"ParentId": "18958015", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-09-23T11:32:23.680", "Score": "14", "LastEditorUserId": "951757", "LastEditDate": "2013-09-23T11:51:37.433", "Id": "18958178", "OwnerUserId": "951757", "Body": "<p>Your code leads to undefined behavior, because <code>std::sort()</code> requires a strict weak ordering, which <code>&lt;</code> or <code>&gt;</code> provides, but <code>&gt;=</code> does not provide because <strong>it violates the requirement to be antisymmetric</strong>.</p>\n<p>Regarding <code>strict weak ordering</code>, it also include below properties</p>\n<p>(1) <strong>antisymmetric</strong></p>\n<pre><code>That for operator &lt;: If x &lt; y is true, then y &lt; x is false.\nThat for a predicate op(): If op(x,y) is true, then op(y,x) is false.\n</code></pre>\n<p>(2) <strong>transitive</strong></p>\n<p>that for operator &lt;: If x &lt; y is true and y &lt; z is true, then x &lt; z is true.\n   That for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z)\nis true.</p>\n<p>(3) <strong>irreflexive</strong></p>\n<pre><code>That for operator &lt;: x &lt; x is always false.\nThat for a predicate op(): op(x,x) is always false.\n</code></pre>\n<p>(4) <strong>transitivity of equivalence</strong>, which means roughly: If a is equivalent to b and b is equivalent to c, then a is equivalent to c. </p>\n<p>\u00a7 25.4.4</p>\n<blockquote>\n<p id=\"so_18958015_18958178_0\">For all algorithms that take Compare, there is a version that uses operator&lt; instead. That is, 1comp(*i,*j) != false1 defaults to *i &lt; *j != false. <strong>For algorithms other than those described in 25.4.3 to work correctly, comp has to induce a strict weak ordering on the values.</strong></p>\n</blockquote>\n<p>To read more about <a href=\"http://www.sgi.com/tech/stl/StrictWeakOrdering.html\" rel=\"noreferrer\">strict weak ordering</a></p>\n", "LastActivityDate": "2013-09-23T11:51:37.433"}, "18958250": {"ParentId": "18958015", "CommentCount": "0", "CreationDate": "2013-09-23T11:36:15.713", "OwnerUserId": "1394283", "PostTypeId": "2", "Id": "18958250", "Score": "3", "Body": "<p>In C++, the \"compare\" predicate must be a <a href=\"http://www.sgi.com/tech/stl/StrictWeakOrdering.html\" rel=\"nofollow\"><strong>strict weak ordering</strong></a>. For example, the case <code>descending_sort( X, X )</code> (both pairs identical) should always return <code>false</code>.</p>\n<p>Also, on this <a href=\"http://en.cppreference.com/w/cpp/algorithm/sort\" rel=\"nofollow\">reference</a>, it is said:</p>\n<blockquote>\n<p id=\"so_18958015_18958250_0\"><strong>comp</strong> - comparison function which returns \u200btrue if the first argument is <strong><em>less</em></strong> than the second.</p>\n</blockquote>\n<p>For you it means that in <code>descending_sort</code>:</p>\n<pre><code>return a.second &gt;= b.second;\n</code></pre>\n<p>should be</p>\n<pre><code>return a.second &gt; b.second;\n</code></pre>\n", "LastActivityDate": "2013-09-23T11:36:15.713"}, "bq_ids": {"n4140": {"so_18958015_18958250_0": {"section_id": 1394, "quality": 0.7, "length": 7}, "so_18958015_18958178_0": {"section_id": 1395, "quality": 0.8, "length": 24}}, "n3337": {"so_18958015_18958250_0": {"section_id": 1388, "quality": 0.7, "length": 7}, "so_18958015_18958178_0": {"section_id": 1389, "quality": 0.8, "length": 24}}, "n4659": {"so_18958015_18958250_0": {"section_id": 1512, "quality": 0.7, "length": 7}, "so_18958015_18958178_0": {"section_id": 1513, "quality": 0.7333333333333333, "length": 22}}}, "18958015": {"CommentCount": "2", "AcceptedAnswerId": "18958178", "PostTypeId": "1", "LastEditorUserId": "131433", "CreationDate": "2013-09-23T11:23:09.020", "LastActivityDate": "2013-09-23T11:51:37.433", "LastEditDate": "2013-09-23T11:33:16.373", "ViewCount": "350", "FavoriteCount": "1", "Title": "std::sort giving very strange results", "Id": "18958015", "Score": "3", "Body": "<p>I have managed to find a reproducible example of the strange behaviour I am seeing with <code>std::sort</code></p>\n<p>I am trying to sort a list of pairs, where it should be sorted on the second element. The list of the second elements is <code>[1 1 1 1 3 1 1 1 1 1 1 3 2 1 1 5 2 1 7 1]</code>.</p>\n<p>Below is my code:</p>\n<pre><code>std::vector&lt;pair&lt;int, double&gt; &gt; pairs;\nfor (int i = 0; i &lt; 4; i++) {\n    pairs.push_back(pair&lt;int, double&gt;(1, 1));\n}\npairs.push_back(pair&lt;int, double&gt;(1, 3));\nfor (int i = 0; i &lt; 6; i++) {\n    pairs.push_back(pair&lt;int, double&gt;(1, 1));\n}\npairs.push_back(pair&lt;int, double&gt;(1, 3));\npairs.push_back(pair&lt;int, double&gt;(1, 2));\npairs.push_back(pair&lt;int, double&gt;(1, 1));\npairs.push_back(pair&lt;int, double&gt;(1, 1));\npairs.push_back(pair&lt;int, double&gt;(1, 5));\npairs.push_back(pair&lt;int, double&gt;(1, 2));\npairs.push_back(pair&lt;int, double&gt;(1, 1));\npairs.push_back(pair&lt;int, double&gt;(1, 7));\npairs.push_back(pair&lt;int, double&gt;(1, 1));\n</code></pre>\n<p>and the sorting function is:</p>\n<pre><code>template&lt;typename T&gt;\nstruct descending_sort {\n    bool operator()(pair&lt;T, double&gt; const &amp; a, pair&lt;T, double&gt; const &amp; b) const {\n        cout &lt;&lt; \"sorting (\" &lt;&lt; a.second &lt;&lt; \" , \" &lt;&lt; b.second &lt;&lt; \")\" &lt;&lt; std::endl;\n        return a.second &gt;= b.second;\n    }\n};\n\ndescending_sort &lt; int &gt; d = descending_sort&lt;int&gt;();\nstd::sort(pairs.begin(), pairs.end(), d);\n</code></pre>\n<p>This produces the correct result, but when I examine a bit closely the output of the sort function at each step (what I print to console) I get some very interesting output.</p>\n<p>The whole output can be found <a href=\"http://pastebin.com/0WXg5s6f\" rel=\"nofollow\">here</a> but there are some strange lines (i.e. line 46 in linked page) which read:</p>\n<pre><code>sorting (0 , 1)\n</code></pre>\n<p>But 0 does not appear in the input list. Why is this here?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "225814", "AnswerCount": "2"}});