post_cb({"13218520": {"ParentId": "13218449", "CommentCount": "0", "Body": "<pre><code>new (&amp;myArray[i]) MyClass(params);\n</code></pre>\n<p>is the <strong>Placement <code>new</code></strong> operator. It allows you to create an object at pre-allocated memory location.</p>\n<p><strong>18.4.1.3 Placement forms</strong></p>\n<blockquote>\n<p id=\"so_13218449_13218520_0\">void* operator new(std::size_t size, void* ptr) throw();</p>\n<p id=\"so_13218449_13218520_1\">Returns: ptr.<br>\n  3 Notes: Intentionally performs no other action.<br>\n  4 [Example: This can be useful for constructing an object at a known address:    </br></br></p>\n</blockquote>\n<pre><code>void* place = operator new(sizeof(Something));\n\nSomething* p = new (place) Something();\n\u2014end example]\n\nvoid* operator new[](std::size_t size, void* ptr) throw();\n\n5 Returns: ptr.\n6 Notes: Intentionally performs no other action.\n</code></pre>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "13218520", "Score": "1", "CreationDate": "2012-11-04T12:29:59.847", "LastActivityDate": "2012-11-04T12:29:59.847"}, "13218523": {"ParentId": "13218449", "CommentCount": "0", "Body": "<p>Wikipedia will answer your questions.</p>\n<p>The first <code>new</code> is for allocating raw memory.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/New_(C%2B%2B)#void.2A_operator_new.28size_t_size.29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/New_(C%2B%2B)#void.2A_operator_new.28size_t_size.29</a></p>\n<blockquote>\n<p id=\"so_13218449_13218523_0\">The C++ language construct that only allocates memory is called void* operator new(size_t size). It is used by new in the allocation phase. It can be overridden per class to define a class specific memory allocator.</p>\n</blockquote>\n<hr>\n<p>The second <code>new</code> is called placement new.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Placement_new\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Placement_new</a></p>\n<blockquote>\n<p id=\"so_13218449_13218523_1\">The placement overloads of operator new and operator delete that employ an additional void * parameter are used for default placement, also known as pointer placement.</p>\n</blockquote>\n</hr>", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "13218523", "Score": "2", "CreationDate": "2012-11-04T12:30:22.390", "LastActivityDate": "2012-11-04T12:30:22.390"}, "13218742": {"ParentId": "13218449", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>To understand this, you first need to understand how plain and simple <code>new</code> works. The usual syntax of a <code>new</code> expression is something like <code>new T</code>. When you use a <code>new</code> expression, the following occurs:</p>\n<ol>\n<li><p>First, it calls an <em>allocation function</em> to obtain storage for the object. The allocation function simply has to return a pointer to some allocated storage large enough to fit the requested object. It does no more than this. It doesn't initialize the object.</p></li>\n<li><p>Next, the object is initialized in the allocated space.</p></li>\n<li><p>A pointer to the allocated space (and now initialized object) is returned.</p></li>\n</ol>\n<p>In the case of <code>new T</code>, the allocation function is named <code>operator new</code>. When allocating an array, such as <code>new T[5]</code>, the allocation function is named <code>operator new[]</code>. Default definitions of these functions are provided in the global namespace. They each take a single argument of type <code>std::size_t</code> which is the number of bytes required. So when you do <code>new T</code>, the corresponding call is to <code>operator new(sizeof(T))</code>, whereas for <code>new T[5]</code>, <code>operator new[](sizeof(T)*5)</code> gets called.</p>\n<p>It is, however, possible to pass more arguments to the allocation function. This is known as the <em>placement new</em> syntax. To pass more arguments, you use syntax like so: <code>new (some, arguments, 3) T</code>, which will call <code>operator new(sizeof(T), some, arguments, 3)</code>. The list of arguments goes in parentheses between <code>new</code> and the type.</p>\n<p>In addition to the simple <code>operator new(std::size_t)</code> and its array counterpart that are both provided by the implementation, there are also default definitions that take an extra argument of type <code>void*</code>. That is, they take a pointer to an object. These functions don't actually allocate any space and simply return the pointer you gave them. So when you do <code>new (some_pointer) T</code>, it first calls <code>operator new(sizeof(T), some_pointer)</code> which just returns <code>some_pointer</code> back again and then it initializes the object in that space. This gives you a way to initialize an object in some <em>already allocated</em> space.</p>\n<p>So now we have these four pre-defined allocation functions (in fact, there are a few others and you're free to define your own too):</p>\n<pre><code>// Normal allocation functions that allocate space of the given size\noperator new(std::size_t)\noperator new[](std::size_t)\n// Placement allocation functions that just return the pointer they're given\noperator new(std::size_t, void*)\noperator new[](std::size_t, void*)\n</code></pre>\n<hr>\n<p>So lets take a look at the code snippet you provided:</p>\n<pre><code>void * memory = operator new[] (10*sizeOf(MyClass));\nMyClass * myArray = static_cast&lt;MyClass*&gt;(memory);\nfor(int i= 0; i&lt;10; i++)\n{\n  new (&amp;myArray[i]) MyClass(params);\n}\n</code></pre>\n<p>In the first line, we are calling <code>operator new[]</code> directly to allocate some storage. How much storage? Well, enough for 10 objects of type <code>MyClass</code>. This function returns a pointer to that allocated storage and you store it in <code>memory</code>.</p>\n<p>After this, the <code>void*</code> is cast to a <code>MyClass*</code> to allow you to index the allocated storage in blocks of size <code>sizeof(MyClass)</code>, i.e. <code>myArray[0]</code> will now point to the first <code>MyClass</code>  and <code>myArray[1]</code> to the second.</p>\n<p>Now we loop through that array, calling <em>placement new</em> with the address of each uninitialized <code>MyClass</code>-sized bit of allocated storage. In the first iteration, for example, this will call allocation function <code>operator new(sizeof(MyClass), &amp;myArray[0])</code> which, as we saw before, does nothing but return the pointer you've given it. The new expression will complete by initializing a <code>MyClass</code> object in this space and returning the pointer to it.</p>\n<p>So in summary, the code allocates some storage to fit 10 <code>MyClass</code> objects (but doesn't initialize them), then loops through each <code>MyClass</code>-sized space in that storage, initializing an object in each of them.</p>\n<p>This demonstrates how you can initialize objects in already pre-allocated storage. You can reuse the same storage over and over with newly initialized objects.</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-11-04T13:07:00.730", "Id": "13218742", "Score": "2", "CreationDate": "2012-11-04T13:01:54.817", "LastActivityDate": "2012-11-04T13:07:00.730"}, "13218449": {"CommentCount": "2", "ViewCount": "166", "CreationDate": "2012-11-04T12:19:37.200", "LastActivityDate": "2012-11-04T13:07:00.730", "Title": "C++ Sytanx about Array of Class and usage of new operator", "AcceptedAnswerId": "13218742", "PostTypeId": "1", "Id": "13218449", "Score": "2", "Body": "<p>My question is about a code snanpshot from Scott Meyer's Book \"More Effective C++ 35 new ways ...\" </p>\n<p>the code (parameter names are changed) </p>\n<pre><code>void * memory = operator new[] (10*sizeOf(MyClass));\nMyClass * myArray = static_cast&lt;MyClass*&gt;(memory);\nfor(int i= 0; i&lt;10; i++)\n{\nnew (&amp;myArray[i]) MyClass(params);\n}\n</code></pre>\n<p>I am not familiar with this syntax. Even the operator new [] and the new (&amp;myArray[i]) ... Is there any resource that I can read detailed about that syntax, how they are working. </p>\n", "Tags": "<c++><syntax><operator-keyword>", "OwnerUserId": "696296", "AnswerCount": "4"}, "13218522": {"ParentId": "13218449", "PostTypeId": "2", "CommentCount": "1", "Body": "<pre><code>void * memory = operator new[] (10*sizeOf(MyClass));\n</code></pre>\n<p>Here you allocate memory of size <code>10*sizeOf(MyClass)</code> bytes. This is raw <em>uninitialized</em> memory. There is no C++ objects constructed in this memory.</p>\n<pre><code>new (&amp;myArray[i]) MyClass(params);\n</code></pre>\n<p>Here you use <em>placement-new</em> to construct an object in the given memory pointed to by <code>&amp;myArray[i]</code>.</p>\n<p>The typical syntax for placement-new is this:</p>\n<pre><code>X * x = new (pAllocatedMem) X(a,b,c);\n</code></pre>\n<p>It means, you construct an object of type <code>X</code> passing <code>a</code>,<code>b</code>,<code>c</code> to the constructor. The object is constructed at memory pointed  to by <code>pAllocatedMem</code>.</p>\n<p>Also note that you delete such object which is constructed using placement-new, as:</p>\n<pre><code>x-&gt;~X(); //delete the constructed object. DONT USE : delete x;\n</code></pre>\n<p>That is, you don't do <code>delete x</code> to delete such objects.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2012-11-04T12:35:27.510", "Id": "13218522", "Score": "2", "CreationDate": "2012-11-04T12:30:15.793", "LastActivityDate": "2012-11-04T12:35:27.510"}, "bq_ids": {"n4140": {"so_13218449_13218520_0": {"section_id": 6857, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_13218449_13218520_0": {"section_id": 6603, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_13218449_13218520_0": {"section_id": 8349, "quality": 0.8571428571428571, "length": 6}}}});