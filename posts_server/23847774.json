post_cb({"23851373": {"ParentId": "23847774", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is no \"using typename directive\". There are <em>using-directives</em> and <em>using-declarations</em>.</p>\n<p>You're not using any <em>using-directives</em>, and they aren't relevant to the question in any case (they name namespaces, and can't use the typename keyword).</p>\n<p>When <em>using-declarations</em> happen to appear within class templates, and happen to name dependent types, they have to use the <code>typename</code> keyword just like anything else that happens to be in a template and happens to name a dependent type.</p>\n<p>For example:</p>\n<pre><code>template &lt;typename A, typename R&gt;\nclass Functor : public std::unary_function&lt;A, R&gt;\n{\n    using typename std::unary_function&lt;A, R&gt;::result_type;\n    using typename std::unary_function&lt;A, R&gt;::argument_type;\n public:\n    result_type operator() (argument_type) {}\n};\n</code></pre>\n<p>In your situations, the namespace-declaration does not appear to be a part of the body of a class template, in fact it appears to be at namespace scope, in which case attempting to name a class member (doesn't matter if it's a type or a function or whatever) violates <code>7.3.3[namespace.udecl]/8</code></p>\n<blockquote>\n<p id=\"so_23847774_23851373_0\">A <em>using-declaration</em> for a class member shall be a <em>member-declaration</em></p>\n</blockquote>\n<p>as the compiler correctly diagnosed with \"error : using declaration can not refer to class member\"</p>\n", "OwnerUserId": "273767", "LastEditorUserId": "273767", "LastEditDate": "2014-05-25T02:15:30.973", "Id": "23851373", "Score": "3", "CreationDate": "2014-05-25T02:08:27.113", "LastActivityDate": "2014-05-25T02:15:30.973"}, "23851636": {"ParentId": "23847774", "CommentCount": "0", "Body": "<p>A <code>using</code> declaration referring to a namespace member <code>A</code> may only appear at namespace or local scope.</p>\n<p>A <code>using</code> declaration referring to a class member <code>Nested</code> may only appear at class scope (along with member declarations), in a class derived from <code>Nested</code>. In fact, such <code>using</code> declarations are grammatically considered to be member declarations. They are used to adjust access qualification, and (with <code>typename</code>) to allow members of type-dependent bases to be used without qualification. These are specific use cases, so member <code>using</code> declarations are a bit specialized.</p>\n<p>A nested class <em>is</em> a member of its enclosing class. You should generally avoid using class enclosures as a substitute for namespaces. Metaprogramming provides some exceptions to the rule, but in those cases you still wouldn't use <code>using</code> declarations, at least at namespace scope, because namespaces cannot be templated. Inheriting from an empty metaprogramming class is viable, but do mind the spaghetti.</p>\n<p>The <code>using</code> directive is a different beast. It looks like <code>using namespace</code> and it links one namespace to another as a fallback path in name lookup.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "23851636", "Score": "2", "CreationDate": "2014-05-25T03:11:14.220", "LastActivityDate": "2014-05-25T03:11:14.220"}, "bq_ids": {"n4140": {"so_23847774_23851373_0": {"section_id": 5497, "quality": 1.0, "length": 4}}, "n3337": {"so_23847774_23851373_0": {"section_id": 5283, "quality": 1.0, "length": 4}}, "n4659": {"so_23847774_23851373_0": {"section_id": 6931, "quality": 1.0, "length": 4}}}, "23847774": {"CommentCount": "8", "ViewCount": "1903", "PostTypeId": "1", "LastEditorUserId": "1498329", "CreationDate": "2014-05-24T17:22:00.070", "LastActivityDate": "2014-05-25T03:11:14.220", "Title": "Are \"using typename\" directives not implemented by compilers?", "AcceptedAnswerId": "23851636", "LastEditDate": "2014-05-24T17:44:50.427", "Id": "23847774", "Score": "7", "Body": "<p>I have some code which looks like this:</p>\n<pre><code>namespace myLibrary\n{\n    class A\n    {\n    public:\n        struct Nested\n        {\n            ...\n        };\n\n        ...\n    };\n}\n</code></pre>\n<p>In some other parts of the code, I need to access A. Since I like readable code, I also like the using directive:</p>\n<pre><code>using myLibrary::A;\n...\nA a;\n</code></pre>\n<p>Now, at some point I also need to access my nested class, so I want to write something like this:</p>\n<pre><code>using myLibrary::A::Nested;\n</code></pre>\n<p>Obviously, the compiler can't know that this is a nested class and not a class member, and gives me an error:</p>\n<pre><code>error : using declaration can not refer to class member\n</code></pre>\n<p>What I can't understand is why this does not solve the problem:</p>\n<pre><code>using typename myLibrary::A::Nested;\n</code></pre>\n<p>The compiler still gives me the exact same error!</p>\n<p>Luckily, I have alternatives:</p>\n<pre><code>// Using a typedef\ntypedef myLibrary::A::Nested Nested;\n\n// Using the new C++11 syntax for type aliasing\nusing Nested = myLibrary::A::Nested;\n</code></pre>\n<p>but I'd like to understand why the <em>using typename</em> directive did not work. Does it not do what I think it does? Or is it not implemented by compilers? If it is the latter, is there a reason for it?</p>\n", "Tags": "<c++><using><nested-class><typename>", "OwnerUserId": "3600266", "AnswerCount": "2"}});