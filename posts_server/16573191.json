post_cb({"16573191": {"ViewCount": "190", "Body": "<p>a class declaration makes the class an incomplete type, so no object of the class could be defined. And the definition of an incomplete type is that its member are not specified. Doesn't that means a class with empty body with no member specified in its definition makes it an incomplete type? </p>\n<pre><code>class Empty { };\n\nEmpty e1; // okay, but why?\n</code></pre>\n", "Title": "Is a class with empty body an incomplete type?", "CreationDate": "2013-05-15T19:13:31.537", "LastActivityDate": "2013-05-15T22:29:58.217", "CommentCount": "11", "PostTypeId": "1", "Id": "16573191", "Score": "2", "OwnerUserId": "2150864", "Tags": "<c++><class><declaration><definition><incomplete-type>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16573191_16573219_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 7203}, "so_16573191_16573219_2": {"length": 8, "quality": 1.0, "section_id": 5862}}, "n3337": {"so_16573191_16573219_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 6947}, "so_16573191_16573219_2": {"length": 8, "quality": 1.0, "section_id": 5632}}, "n4659": {"so_16573191_16573219_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 8712}, "so_16573191_16573219_2": {"length": 8, "quality": 1.0, "section_id": 7345}}}, "16573228": {"Id": "16573228", "PostTypeId": "2", "Body": "<p>Yes, it is a complete type. When I last checked the size is one byte (at least on MS's compiler).</p>\n<p>In order to create an incomplete struct omit your braces:</p>\n<pre><code>struct Empty;\n</code></pre>\n<p>This is also known as a forward declared structure, and is not a definition of the struct.</p>\n", "LastActivityDate": "2013-05-15T19:15:53.417", "CommentCount": "1", "CreationDate": "2013-05-15T19:15:53.417", "ParentId": "16573191", "Score": "0", "OwnerUserId": "1825760"}, "16573219": {"Id": "16573219", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16573191_16573219_0\">Is a class with empty body an incomplete type?</p>\n</blockquote>\n<p>No, a class with an empty body is simply an empty class, but still a fully defined one. An incomplete type is a type whose full definition is not visible.</p>\n<pre><code>class Empty;\n\n// Here, Empty is an incomplete type\n\nclass Empty { };\n\n// Here, Empty is a complete type\n</code></pre>\n<p>Per paragraph 3.9/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16573191_16573219_1\">A class that has been declared <strong>but not defined</strong>, or an array of unknown size or of incomplete element type, is\n  an incompletely-defined object type. Incompletely-defined object types and the void types are incomplete\n  types (3.9.1). Objects shall not be defined to have an incomplete type.</p>\n</blockquote>\n<p>Also, per paragraph 9.2/2:</p>\n<blockquote>\n<p id=\"so_16573191_16573219_2\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the class-specifier. [...]</p>\n</blockquote>\n", "LastActivityDate": "2013-05-15T19:15:08.873", "CommentCount": "2", "CreationDate": "2013-05-15T19:15:08.873", "ParentId": "16573191", "Score": "4", "OwnerUserId": "1932150"}, "16573370": {"Id": "16573370", "PostTypeId": "2", "Body": "<p>As others have said, it is not an incomplete type.  In C++ there are times when this kind of thing is desirable.</p>\n<p>Consider the following:</p>\n<pre><code>template&lt;class T&gt;\nclass Field\n{\npublic:\n    virtual std::string toString() const = 0;\n};\n</code></pre>\n<p>How can I store this in a collection?  Answer is, I can't.  But I could do:</p>\n<pre><code>class FieldBase \n{\npublic:\n    virtual ~FieldBase() = 0 { }; // virtual destructor needed, but no other members\n    virtual std::string toString() const = 0;\n};\n</code></pre>\n<p>Now, technically, that doesn't have any members defined, as per your question.  It's abstract.  It cannot be instantiated.  But now we can do:</p>\n<pre><code>template&lt;class T&gt;\nclass Field : public FieldBase\n{\n     virtual std::string toString() const { /* ... */ };\n};\n</code></pre>\n<p>I know this slightly deviates from your original question, but it does illustrate that a base-class has nothing defined (except intent), and we can now store these template-classes in a <code>std::vector&lt;FieldBase*&gt;</code> collection.</p>\n", "LastEditorUserId": "437768", "LastActivityDate": "2013-05-15T22:29:58.217", "Score": "1", "CreationDate": "2013-05-15T19:24:51.467", "ParentId": "16573191", "CommentCount": "4", "OwnerUserId": "437768", "LastEditDate": "2013-05-15T22:29:58.217"}});