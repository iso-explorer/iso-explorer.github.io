post_cb({"11455989": {"CommentCount": "0", "ViewCount": "456", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-07-12T16:06:11.443", "LastActivityDate": "2012-07-17T22:08:13.970", "Title": "unique_ptr: How to safely share raw pointer", "AcceptedAnswerId": "11456489", "LastEditDate": "2012-07-17T22:08:13.970", "Id": "11455989", "Score": "1", "Body": "<p>I am making an class which is managed by a <code>unique_ptr</code>, but for various reasons I need to give implementations access to a raw pointer to the object. However I want to ensure that users don't inadvertently delete the underlying object. I have come up with the following example code:<br>\n(It is part of a tree structure, and I need to be able to look at members of tree nodes without actually detaching them. <code>shared_ptr</code> seems like overkill in this situation.)</br></p>\n<pre><code>#include &lt;memory&gt;\n\nusing namespace std;\n\nclass unOnly\n{\n    ~unOnly() {}\npublic:\n    unOnly() {}\n    friend class default_delete&lt;unOnly&gt;;\n};\n\nint main()\n{\n    unique_ptr&lt;unOnly&gt; ptr(new unOnly());\n}\n</code></pre>\n<p>This compiles for me in gcc 4.4.5. However, can I be sure that in all implementations <code>default_delete</code> is what actually <code>delete</code>s the object, as opposed to some private implementation class? Should I write my own deleter to be sure?</p>\n", "Tags": "<c++><c++11><unique-ptr>", "OwnerUserId": "603688", "AnswerCount": "3"}, "11456049": {"ParentId": "11455989", "CommentCount": "1", "Body": "<p>The point of <code>unique_ptr</code> (besides having an object which owns it's pointer) is that you can pass it a custom deleter, so it makes sense just to write one instead of doing something else, which seems unnecessarily complex.</p>\n", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "11456049", "Score": "1", "CreationDate": "2012-07-12T16:09:16.827", "LastActivityDate": "2012-07-12T16:09:16.827"}, "11456489": {"ParentId": "11455989", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Why not</p>\n<pre><code>class unOnly\n{\n    unOnly() {}\n    ~unOnly() {}\n    struct deleter { void operator()(unOnly* x) { delete x; }};\n\npublic:\n    typedef std::unique_ptr&lt;unOnly, deleter&gt; handle;\n\n    static handle create() { return handle(new unOnly); }\n};\n\nauto x = unOnly::create();\n</code></pre>\n<p>? Or even</p>\n<pre><code>class unOnly\n{\n    ~unOnly() {}\n    struct deleter { void operator()(unOnly* x) { delete x; }};\n\npublic:\n    unOnly() {}\n    typedef std::unique_ptr&lt;unOnly, deleter&gt; handle;\n};\n\nunOnly::handle x(new unOnly);\n</code></pre>\n<p>(I prefer the former, but the latter is perhaps more in the spirit of what you're asking for)</p>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2012-07-12T16:45:25.383", "Id": "11456489", "Score": "2", "CreationDate": "2012-07-12T16:35:52.443", "LastActivityDate": "2012-07-12T16:45:25.383"}, "bq_ids": {"n4140": {"so_11455989_11456151_3": {"section_id": 4282, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_11455989_11456151_3": {"section_id": 4123, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_11455989_11456151_3": {"section_id": 5538, "quality": 0.9166666666666666, "length": 11}}}, "11456151": {"ParentId": "11455989", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Quoting from the standard:</p>\n<blockquote>\n<p id=\"so_11455989_11456151_0\"><strong>20.7.1</strong> Class template unique_ptr</p>\n<p id=\"so_11455989_11456151_1\"><em>6</em>. [...]</p>\n<pre><code>  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;\n</code></pre>\n<p id=\"so_11455989_11456151_2\"><strong>20.7.1.1.1</strong></p>\n<p id=\"so_11455989_11456151_3\"><em>1</em> The class template default_delete serves as the default deleter (destruction policy) for the class template unique_ptr.</p>\n</blockquote>\n<p>So, it seems implementations of <code>unique_ptr</code> are required to use <code>default_delete</code> as the default deleter. </p>\n<p><strong>EDIT:</strong><br/>\nBut this doesn't mean your approach is foolproof, see @RMartinhoFernandes' comment below.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2012-07-12T16:29:00.887", "Id": "11456151", "Score": "1", "CreationDate": "2012-07-12T16:15:10.537", "LastActivityDate": "2012-07-12T16:29:00.887"}});