post_cb({"3049609": {"Id": "3049609", "PostTypeId": "2", "Body": "<p>The ostream_iterator is an output iterator.<br>\n<a href=\"http://www.sgi.com/tech/stl/OutputIterator.html\" rel=\"nofollow noreferrer\">http://www.sgi.com/tech/stl/OutputIterator.html</a></br></p>\n<p>One of the requirements of the output iterator is that between each assignment to the stream that the ++ operator (pre or post) is used. Thus it is undefined behavior to assign to the stream twice in a row without incrementing the iterator.</p>\n<pre><code>Dereference assignment:     *x = t\n\nPre-Conditions:             x is dereferenceable:\n\n                            If there has been a previous assignment through x,\n                            then there has been an intervening increment.\n</code></pre>\n<p>So technically what you are doing above is undefined behavior.<br>\nThus the implementation is allowed to provide the output you describe.</br></p>\n<p>See Expression semantics for de-re assignament (pre-conditions) also See Note [3] in the linked page above.</p>\n<p>For the official standard quote:</p>\n<p><a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2010/n3090.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2010/n3090.pdf</a> (latest draft)<br>\nSection 24.2.4: Paragraph 2  (emphasis by me)</br></p>\n<blockquote>\n<p id=\"so_3049597_3049609_0\">[ Note: The only valid use of an operator* is on the left side of the assignment statement. <b>Assignment\n  through the same value of the iterator happens only once</b>. Algorithms on output iterators should never\n  attempt to pass through the same iterator twice. They should be single pass algorithms. Equality and\n  inequality might not be defined. Algorithms that take output iterators can be used with ostreams as the\n  destination for placing data through the ostream_iterator class as well as with insert iterators and insert\n  pointers. \u2014end note ]</p>\n</blockquote>\n<p>I disagree with AndreyT interpretation of defect report 485:</p>\n<blockquote>\n<p id=\"so_3049597_3049609_1\">a) That each value of the output iterator is written to: The standard allows: ++x; ++x; ++x;<br>\n  b) That assignments to the output iterator are made in order X a(x); ++a; *a=1; *x=2; is allowed<br>\n  c) Chains of output iterators cannot be constructed: X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current wording (I believe) x,a,b,c could be written to in any order.</br></br></p>\n</blockquote>\n<p>Problem (a) and (c) are not relevant.<br>\nProblem (b) refers to a situations where there are multiple iterators involved.</br></p>\n<p>Note in (b) we are using iterator a (copy of x) and iterator x. The defect is that the current standard does not requrie 'x' to be increment before use; after 'a' has been assigned through. Which is not the situation in this context.</p>\n", "LastEditorUserId": "1242646", "LastActivityDate": "2017-03-21T14:32:56.003", "Score": "3", "CreationDate": "2010-06-15T22:42:32.283", "ParentId": "3049597", "CommentCount": "2", "OwnerUserId": "14065", "LastEditDate": "2017-03-21T14:32:56.003"}, "3049597": {"ViewCount": "206", "Body": "<p>In my code, I have the following:</p>\n<pre><code>ostream_iterator&lt;double&gt; doubleWriter(cout, \" ~ \");\n// ...\n*doubleWriter = 1.1;\ndoubleWriter++;\n*doubleWriter = 2.2;\n*doubleWriter = 3.3; // shouldn't 2.2 be overwritten?\ndoubleWriter++;\n*doubleWriter = 44.2;\n\ncout &lt;&lt; endl &lt;&lt; endl;\n</code></pre>\n<p>I expected it to output this:</p>\n<pre><code>1.1 ~ 3.3 ~ 44.2 ~ \n</code></pre>\n<p>Instead, the output was this:</p>\n<pre><code>1.1 ~ 2.2 ~ 3.3 ~ 44.2 ~ \n</code></pre>\n<p>Why does this happen? It would seem to me that I overwrite 2.2 and stick 3.3 in its spot, since I didn't increment. Is incrementation an optional step?</p>\n", "AcceptedAnswerId": "3049633", "Title": "STL ostream_iterator writes to screen even though I overwrote it?", "CreationDate": "2010-06-15T22:39:29.610", "Id": "3049597", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-03-21T14:32:56.003", "Score": "0", "OwnerUserId": "211176", "Tags": "<c++><stl><iterator>", "AnswerCount": "3"}, "3049633": {"Id": "3049633", "PostTypeId": "2", "Body": "<p>For standard <code>ostream_iterator</code>, operator <code>++</code> (both prefix and postfix) is a no-op. It does nothing and makes no difference.</p>\n<p>There's no need to do the <code>++</code> manually, since the iterator always \"advances\" when you output something through it.</p>\n<p><strong>P.S.</strong> According to library <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#485\" rel=\"nofollow noreferrer\">Defect Report 485</a>, the intent was to require that  assignment and increments alternate. This requirement apparently haven't made it into the current version of the standard. But in the future revisions, it will be included. In other words, as others already noted, the proper way to use output iterator is to alternate assignments and increments.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-06-15T23:19:01.870", "Score": "3", "CreationDate": "2010-06-15T22:48:07.437", "ParentId": "3049597", "CommentCount": "15", "OwnerUserId": "187690", "LastEditDate": "2010-06-15T23:19:01.870"}, "bq_ids": {"n4140": {"so_3049597_3049609_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 5572}}, "n3337": {"so_3049597_3049609_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 5354}}, "n4659": {"so_3049597_3049609_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 7019}}}, "3049619": {"Id": "3049619", "PostTypeId": "2", "Body": "<p>The ostream iterator behavior is to always move the output position. That's what you usually want.</p>\n", "LastActivityDate": "2010-06-15T22:44:24.577", "CommentCount": "0", "CreationDate": "2010-06-15T22:44:24.577", "ParentId": "3049597", "Score": "0", "OwnerUserId": "79737"}});