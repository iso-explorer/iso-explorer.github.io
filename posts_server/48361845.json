post_cb({"bq_ids": {"n4140": {"so_48361845_48361845_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 5417}, "so_48361845_48367718_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 7034}}, "n3337": {"so_48361845_48361845_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 3082}, "so_48361845_48367718_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 6780}}, "n4659": {"so_48361845_48367718_5": {"length": 16, "quality": 0.8421052631578947, "section_id": 6305}, "so_48361845_48361845_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 6839}, "so_48361845_48367718_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 8531}, "so_48361845_48367718_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6839}}}, "48361845": {"ViewCount": "183", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct foo {};\n\ntemplate&lt;&gt;\nstruct foo&lt;int&gt; {\n  static constexpr char value[] = \"abcde\";\n};\n\ntemplate&lt;class T&gt;\nstruct bar {\n  static constexpr char value[] = \"abcde\";\n};\n\ntemplate&lt;class T&gt;\nstruct baz {\n  static constexpr int value = 12345;\n};\n\nint main() {\n    char c = foo&lt;int&gt;::value[2];\n    char d = bar&lt;int&gt;::value[2];\n    int e = baz&lt;int&gt;::value;\n\n    std::cout &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; \"\\n\";\n\n}\n</code></pre>\n<p>When compiling with: <code>clang++ -std=c++14 ./test_foo.cc</code>, I got linker error for undefined symbols: <code>bar&lt;int&gt;::value</code> and <code>foo&lt;int&gt;::value</code>. When I change to <code>clang++ -std=c++17</code>, then only one undefined symbol: <code>foo&lt;int&gt;::value</code>. My clang++ version is 5.0. </p>\n<p>However, when I tried <code>g++ -std=c++14 ./test_foo.cc</code>, compile succeeded. My g++ version is 5.4.0.</p>\n<p>I have precisely 2 things to ask.</p>\n<p><strong>1) From the C++ standard viewpoint, which compiler behaves correctly ?</strong></p>\n<p>I have googled and read many cppreference pages, but haven't found anything really related to this phenomenon. Especially for the clang++ with <code>-std=c++17</code>, the behave is really bizarre, since <code>bar&lt;int&gt;</code> got passed but <code>foo&lt;int&gt;</code> failed, the only difference is that <code>foo&lt;int&gt;</code> is a specialization. And I read from <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/constexpr</a> that </p>\n<blockquote>\n<p id=\"so_48361845_48361845_0\">A constexpr specifier used in a function or static member variable (since C++17) declaration implies inline.</p>\n</blockquote>\n<p>Thus there seems no reason for template specialization <code>foo&lt;int&gt;</code> to fail. Furthermore, I looked at the generated object file before linking, the access to <code>foo&lt;int&gt;::value[2];</code> is <em>not</em> done at compile time as one would expect it to be. I highly suspect there is something wrong in the clang++ compiler.</p>\n<p><strong>2) How to deal with this clang++ linking error ?</strong> </p>\n<p>I tried something like <a href=\"https://stackoverflow.com/questions/8016780/undefined-reference-to-static-constexpr-char\">Undefined reference to static constexpr char[]</a>, but finally I couldn't find any way to overcome this linking error. So I just wonder whether there is a way to get this linking succeed.</p>\n", "AcceptedAnswerId": "48367718", "Title": "constexpr array member with template specialization: inconsistent behavior cross compilers", "CreationDate": "2018-01-20T22:45:02.207", "LastActivityDate": "2018-01-21T14:14:10.103", "CommentCount": "2", "LastEditDate": "2018-01-20T23:18:02.147", "PostTypeId": "1", "LastEditorUserId": "8605791", "Id": "48361845", "Score": "5", "OwnerUserId": "8605791", "Tags": "<c++><c++14><constexpr><clang++><c++17>", "AnswerCount": "1"}, "48367718": {"Id": "48367718", "PostTypeId": "2", "Body": "<p>Until C++17, the reason is exactly the same as what stated in <a href=\"https://stackoverflow.com/questions/8016780/undefined-reference-to-static-constexpr-char\">the question you found</a> (I think the answer posted by Shafik Yaghmour explains this problem more exactly). In short, the definition of a <code>constexpr</code> static data member is still required if the member is <a href=\"http://en.cppreference.com/w/cpp/language/definition#ODR-use\" rel=\"nofollow noreferrer\">odr-used</a>.</p>\n<p>You can <a href=\"https://wandbox.org/permlink/IkBwrOkcHiRRHJoW\" rel=\"nofollow noreferrer\">resolve the problem</a> by providing definitions of these variable <strong>until C++17</strong> (i.e. using <code>-std=c++14</code>).</p>\n<hr>\n<p>Since C++17, the current standard in <a href=\"http://www.eel.is/c++draft/dcl.constexpr#1\" rel=\"nofollow noreferrer\">[dcl.constexpr] paragraph 1</a> says</p>\n<blockquote>\n<p id=\"so_48361845_48367718_0\">... A function or static data member declared with the <code>constexpr</code> specifier is implicitly an inline function or variable ([dcl.inline]).</p>\n</blockquote>\n<p>and in <a href=\"http://www.eel.is/c++draft/basic.def#2\" rel=\"nofollow noreferrer\">[basic.def] paragraph 2</a> says</p>\n<blockquote>\n<p id=\"so_48361845_48367718_1\">A declaration is a <em>definition</em> unless</p>\n<ul>\n<li><p id=\"so_48361845_48367718_2\">...</p></li>\n<li><p id=\"so_48361845_48367718_3\">it declares a <strong>non-inline</strong> static data member in a class definition ([class.mem], [class.static]),</p></li>\n<li><p id=\"so_48361845_48367718_4\">...</p></li>\n</ul>\n</blockquote>\n<p>So such definitions at namespace scope are not required. </p>\n<p>In addition, the current standard in <a href=\"http://www.eel.is/c++draft/depr.static_constexpr#1\" rel=\"nofollow noreferrer\">[depr.static_constexpr] paragraph 1</a> says</p>\n<blockquote>\n<p id=\"so_48361845_48367718_5\">For compatibility with prior C++ International Standards, a constexpr static data member may be redundantly redeclared outside the class with no initializer. This usage is deprecated. [\u2009Example:</p>\n<pre><code>struct A {\n  static constexpr int n = 5;  // definition (declaration in C++ 2014)\n};\n\nconstexpr int A::n;  // redundant declaration (definition in C++ 2014)\n</code></pre>\n<p id=\"so_48361845_48367718_6\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>So you'd better avoid such definitions since C++17.</p>\n<blockquote>\n<p id=\"so_48361845_48367718_7\">When I change to <code>clang++ -std=c++17</code>, then only one undefined symbol: <code>foo&lt;int&gt;::value</code>. </p>\n</blockquote>\n<p>It is a Clang bug. Anyway, it <a href=\"https://wandbox.org/permlink/FrHufggNun6COGBP\" rel=\"nofollow noreferrer\">works well</a> for Clang HEAD 7.0.0. </p>\n</hr>", "LastActivityDate": "2018-01-21T14:14:10.103", "Score": "2", "CreationDate": "2018-01-21T14:14:10.103", "ParentId": "48361845", "CommentCount": "2", "OwnerUserId": "5376789"}});