post_cb({"bq_ids": {"n4140": {"so_10953392_10953417_0": {"length": 40, "quality": 0.9523809523809523, "section_id": 7200}}, "n3337": {"so_10953392_10953417_0": {"length": 40, "quality": 0.9523809523809523, "section_id": 6944}}, "n4659": {"so_10953392_10953417_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 8709}}}, "10953417": {"Id": "10953417", "PostTypeId": "2", "Body": "<p>In general, no. There's an explicit guarantee that this works for trivially copyable types on \u00a73.9/2, but there's no such thing for other types.</p>\n<blockquote>\n<p id=\"so_10953392_10953417_0\">For any object (other than a base-class subobject) of trivially\n  copyable type <code>T</code>, whether or not the object holds a valid value of type\n  <code>T</code>, the underlying bytes (1.7) making up the object can be copied into\n  an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of\n  <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall\n  subsequently hold its original value. [<em>Example:</em></p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj;\n// obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N);\n// between these two calls to std::memcpy,\n// obj might be modified\nstd::memcpy(&amp;obj, buf, N);\n// at this point, each subobject of obj of scalar type\n// holds its original value\n</code></pre>\n<p id=\"so_10953392_10953417_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2012-06-08T17:29:35.900", "Score": "9", "CreationDate": "2012-06-08T17:29:35.900", "ParentId": "10953392", "CommentCount": "7", "OwnerUserId": "46642"}, "10954673": {"Id": "10954673", "PostTypeId": "2", "Body": "<p>In general, yes. The only way things break is if you access the object after destroying the object and before the restitution of it's data:</p>\n<p>memset(&amp;o, 0, sizeof(o));</p>\n<p>obj.doSomething();  &lt;--- breaks</p>\n<p>memcpy(&amp;o, bytes, sizeof(o));</p>\n", "LastActivityDate": "2012-06-08T19:05:22.847", "Score": "1", "CreationDate": "2012-06-08T19:05:22.847", "ParentId": "10953392", "CommentCount": "2", "OwnerUserId": "1445244"}, "10953392": {"ViewCount": "221", "Body": "<p>This is purely hypothetical, but I'm not sure whether the following code will result in undefined behavior according to the C++ spec.  I'd like to make a copy of the bytes in an object, blast the object by overwriting it with zeros, then copy the old bytes back.  Can I do so without causing undefined behavior?</p>\n<p>Sample code:</p>\n<pre><code>NonPODType o;\nchar bytes[sizeof(o)];\n\nmemcpy(bytes, &amp;o, sizeof(o));\nmemset(&amp;o, 0, sizeof(o));\nmemcpy(&amp;o, bytes, sizeof(o));\n</code></pre>\n", "AcceptedAnswerId": "10953417", "Title": "Can I clone the bytes of a C++ object, overwrite the original bytes, then copy those bytes back?", "CreationDate": "2012-06-08T17:27:13.183", "Id": "10953392", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-10T16:38:44.860", "LastEditorUserId": "5640", "LastActivityDate": "2015-08-10T16:38:44.860", "Score": "7", "OwnerUserId": "501557", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});