post_cb({"27179071": {"ParentId": "27178483", "CommentCount": "2", "Body": "<p>Looks correct to me. While overload resolution is done only in phase 2, in phase 1 you already have to know that <code>foobar(t)</code> is a function call expression. If <code>foobar</code> names a type, <code>t</code> wouldn't even be a dependent name.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "27179071", "Score": "1", "CreationDate": "2014-11-27T21:45:39.820", "LastActivityDate": "2014-11-27T21:45:39.820"}, "27178667": {"ParentId": "27178483", "CommentCount": "6", "Body": "<p>Phase two lookup only includes name lookup rules that can't be applied in phase one- ADL, for example. Two-phase lookup is exactly that- some names are looked up in phase one, and some are looked up in phase two. This particular kind of name is a phase one name, as the compiler is perfectly capable of looking for <code>foobar</code> in the namespace(s) of the function during phase one.</p>\n<p>Visual C++ does not implement two-phase name lookup.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "27178667", "Score": "6", "CreationDate": "2014-11-27T21:09:45.890", "LastActivityDate": "2014-11-27T21:09:45.890"}, "27179338": {"ParentId": "27178483", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>tl;dr</strong> <code>Foo&lt;int&gt;</code> doesn't invoke any ADL, but <code>Foo&lt;X&gt;</code> would (where <code>X</code> is a class type).</p>\n<hr>\n<p>First of all, in this code <code>foobar</code> is a dependent name because of (C++14/N3936) <code>[temp.dep]/1</code></p>\n<blockquote>\n<p id=\"so_27178483_27179338_0\">In an expression of the form:</p>\n<pre><code>postfix-expression ( expression-list opt )\n</code></pre>\n<p id=\"so_27178483_27179338_1\">where the postfix-expression is an unqualified-id, the unqualified-id denotes a dependent name if [...]</p>\n<ul>\n<li>any of the expressions in the expression-list is a type-dependent expression (14.6.2.2), or</li>\n</ul>\n</blockquote>\n<p>and <code>t</code> is a dependent name because it is part of a declaration <code>T t</code> where <code>T</code> is a template parameter and thus a dependent type.</p>\n<p>Moving onto dependent name resolution, there is <code>[temp.dep.res]/1</code> which introduces the fact that names can be both looked up in the definition context, and the instantiation context, and defines where the instantiation context is. I have omitted that for brevity, but in this example <code>template class Foo&lt;int&gt;;</code> is the point of instantiation.</p>\n<p>The next bit is <code>[temp.dep.candidate]/1</code>:</p>\n<blockquote>\n<p id=\"so_27178483_27179338_2\">For a function call where the <em>postfix-expression</em> is a dependent name, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n</blockquote>\n<p>Those last two parts are the \"two phases\" of two-phase lookup.   (Note - this section changed in wording from C++11 to C++14, but the effect in the same).</p>\n<p>In the first phase, 3.4.1, no names are found for <code>foobar</code>. </p>\n<hr>\n<p>So we move onto the second phase. The actual places that names are looked up as described in 3.4.2.  The text is long but the here are two of the relevant rules:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_27178483_27179338_3\">If T is a fundamental type, its associated sets of namespaces and classes are both empty.</p></li>\n<li><p id=\"so_27178483_27179338_4\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost enclosing namespaces of its associated classes. [...]</p></li>\n</ul>\n</blockquote>\n<p>So when you instantiate <code>Foo&lt;int&gt;</code>, then the second phase of lookup does not introduce any additional namespaces to search. </p>\n<p>However, if you change your example to have <code>struct X {};</code> and then change <code>int</code> to <code>X</code> everywhere, then the code <em>does</em> compile. This is because of the latter bullet point: ADL for an argument of class type does search the enclosing namespace of that class (which is the global namespace now), however ADL for an argument of built-in type does not search the global namespace.</p>\n</hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2014-11-28T07:03:14.750", "Id": "27179338", "Score": "8", "CreationDate": "2014-11-27T22:12:09.027", "LastActivityDate": "2014-11-28T07:03:14.750"}, "bq_ids": {"n4140": {"so_27178483_27179338_3": {"section_id": 7104, "quality": 1.0, "length": 9}, "so_27178483_27179338_1": {"section_id": 188, "quality": 0.8571428571428571, "length": 6}, "so_27178483_27179338_4": {"section_id": 7104, "quality": 1.0, "length": 25}, "so_27178483_27179338_2": {"section_id": 224, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_27178483_27179338_3": {"section_id": 6848, "quality": 1.0, "length": 9}, "so_27178483_27179338_1": {"section_id": 182, "quality": 0.8571428571428571, "length": 6}, "so_27178483_27179338_4": {"section_id": 6848, "quality": 0.96, "length": 24}, "so_27178483_27179338_2": {"section_id": 217, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_27178483_27179338_3": {"section_id": 8605, "quality": 1.0, "length": 9}, "so_27178483_27179338_1": {"section_id": 193, "quality": 1.0, "length": 7}, "so_27178483_27179338_4": {"section_id": 8605, "quality": 1.0, "length": 25}, "so_27178483_27179338_2": {"section_id": 232, "quality": 0.8235294117647058, "length": 14}}}, "27178483": {"CommentCount": "12", "AcceptedAnswerId": "27179338", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2014-11-27T20:48:38.183", "LastActivityDate": "2014-11-28T07:03:14.750", "LastEditDate": "2014-11-27T21:15:59.347", "ViewCount": "901", "FavoriteCount": "3", "Title": "Lookup of dependent names in C++ template instantiation", "Id": "27178483", "Score": "18", "Body": "<p>When I try to compile this code</p>\n<pre><code>// void foobar(int); \n\ntemplate &lt;class T&gt;\nstruct Foo {\n  void bar(T t) { foobar(t); };\n};\n\nvoid foobar(int);\n\ntemplate class Foo&lt;int&gt;;\n</code></pre>\n<p>with g++ 4.8.2 I get the following error message</p>\n<pre><code>foo.cc: In instantiation of \u2018void Foo&lt;T&gt;::bar(T) [with T = int]\u2019:\nfoo.cc:10:16:   required from here\nfoo.cc:5:27: error: \u2018foobar\u2019 was not declared in this scope, and no \n             declarations were found by argument-dependent lookup at \n               the point of instantiation [-fpermissive]\n   void bar(T t) { foobar(t); };\n                           ^\nfoo.cc:8:6: note: \u2018void foobar(int)\u2019 declared here, later in the translation unit\n void foobar(int);\n      ^\n</code></pre>\n<p>(With clang 3.4 it's nearly the same). </p>\n<p>First, I think the code is correct and <em>should</em> compile, since foobar is a dependent name in the template declaration and should be looked up only in phase two when the template is instantiated. When this is done in the last line, 'foobar(int)' is already declared. The code compiles, BTW, when I uncomment the topmost line, but both declarations are before the instantiation and so this should not matter.</p>\n<p>Second, the error message itself seems contradictory to me. It says \"no declarations were found at the point of instatiation\" which is foo.cc:10:16, and it says it's declared \"later\" at foo.cc:8:6. For all that I know about numbers and the English language I would call that \"before\" not \"later\".</p>\n<p>So, is it a bug in gcc or did I get something wrong? Since this seems to me a common usage pattern I can't quite believe that, however.</p>\n<p>BTW: when I try out the second example of \"Name Resolution for Dependent Types\" at MSDN (<a href=\"http://msdn.microsoft.com/en-us/library/dx2zs2ee.aspx\">http://msdn.microsoft.com/en-us/library/dx2zs2ee.aspx</a>) with g++ the result is different from vc++, which (not generally, but in this specific case) would undermine this being a bug in g++. </p>\n", "Tags": "<c++><templates><language-lawyer><argument-dependent-lookup>", "OwnerUserId": "942179", "AnswerCount": "3"}});