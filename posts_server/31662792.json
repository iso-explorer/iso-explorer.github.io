post_cb({"31666090": {"ParentId": "31662792", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-07-28T01:44:58.040", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:25.683", "Id": "31666090", "OwnerUserId": "1708801", "Body": "<p>For arithmetic operators the type of the result is not dependent on what you are assigning the result to but the types of the operands. For arithmetic operators the <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Conversions\" rel=\"nofollow noreferrer\">usual arithmetic conversions</a> are performed on the operands. This is used to bring the operands to a common type, this means for types smaller than <em>unsigned</em>/<em>signed</em> int if the values can fit they are promoted to <em>unsigned</em>/<em>signed</em> int, in this case they are already both int so no conversion is required. See <a href=\"https://stackoverflow.com/q/24371868/1708801\">Why must a short be converted to an int before arithmetic operations in C and C++?</a> for the details on why.</p>\n<p>What we have now is undefined behavior since signed integer overflow is undefined behavior, this is covered in the draft C++ standard section <code>5</code> <em>[Expr]</em> which says:</p>\n<blockquote>\n<p id=\"so_31662792_31666090_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of\n  representable values for its type, the behavior is undefined. [ Note: most existing implementations of C++\n  ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all\n  floating point exceptions vary among machines, and is usually adjustable by a library function. \u2014end note ]</p>\n</blockquote>\n<p>Now-a-days we have sanitizers to catch these types of undefined behavior and using <code>-fsanitize=undefined</code> with both clang and gcc will catch this at runtime with the following error (<em><a href=\"http://melpon.org/wandbox/permlink/72MXRnNPNz4xjaN4\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<blockquote>\n<p id=\"so_31662792_31666090_1\">runtime error: signed integer overflow: 1000000 * 1000000 cannot be\n  represented in type 'int'</p>\n</blockquote>\n<p>For reference section <code>5.6</code> <em>[expr.mul]</em> says:</p>\n<blockquote>\n<p id=\"so_31662792_31666090_2\">[...]The usual arithmetic conversions are performed on the operands\n  and determine the type of the result.</p>\n</blockquote>\n<p>and section <code>5</code> says:</p>\n<blockquote>\n<p id=\"so_31662792_31666090_3\">Otherwise, the integral promotions (4.5) shall be performed on both operands.61 Then the following\n  rules shall be applied to the promoted operands</p>\n<ul>\n<li>If both operands have the same type, no further conversion is needed.</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2015-07-28T02:51:16.400"}, "37790780": {"ParentId": "31662792", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-13T13:13:05.017", "Score": "0", "LastEditorUserId": "1913850", "LastEditDate": "2016-06-13T13:19:42.423", "Id": "37790780", "OwnerUserId": "1913850", "Body": "<p>It's kind of absurd, because the assembler instruction does always compute </p>\n<p>int * int -&gt; 64 bits long </p>\n<p>so if you look at the machine code, you see :\n<strong>imul</strong> \nthat store 64bits into eax edx\nthen \n<strong>cdq</strong> \nthat put the bit sign of eax into edx (thus losing the full 64bits result)\nand then  eax edx are stored into the 64bits variable</p>\n<p>and if you convert the 32bits values into 64bits before the multiplication, you get a call to the 64bits multiplication function for no reason </p>\n<p>(I checked : it's not the case when the code is optimized)</p>\n", "LastActivityDate": "2016-06-13T13:19:42.423"}, "31662792": {"CommentCount": "9", "ViewCount": "4988", "PostTypeId": "1", "LastEditorUserId": "304832", "CreationDate": "2015-07-27T20:36:01.150", "LastActivityDate": "2016-06-13T13:19:42.423", "Title": "Multiplication of two integers in C++", "LastEditDate": "2015-07-27T20:45:41.557", "Id": "31662792", "Score": "9", "Body": "<p>I have a pretty basic question, but I am not sure if I understand the concept or not. Suppose we have:</p>\n<pre><code>int a = 1000000;\nint b = 1000000;\nlong long c = a * b;\n</code></pre>\n<p>When I run this, c shows negative value, so I changed also a and b to long long and then everything was fine. So why do I have to change a and b, when their values are in range of int and their product is assigned to c (which is long long)?</p>\n<p>I am using C/C++</p>\n", "Tags": "<c++><int><range><long-integer>", "OwnerUserId": "5033592", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31662792_31666090_2": {"section_id": 6135, "quality": 0.8888888888888888, "length": 8}, "so_31662792_31666090_0": {"section_id": 5937, "quality": 0.926829268292683, "length": 38}, "so_31662792_31666090_3": {"section_id": 5943, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_31662792_31666090_2": {"section_id": 5899, "quality": 0.8888888888888888, "length": 8}, "so_31662792_31666090_0": {"section_id": 5709, "quality": 0.926829268292683, "length": 38}, "so_31662792_31666090_3": {"section_id": 5714, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_31662792_31666090_2": {"section_id": 7632, "quality": 0.8888888888888888, "length": 8}, "so_31662792_31666090_0": {"section_id": 7421, "quality": 0.7073170731707317, "length": 29}, "so_31662792_31666090_3": {"section_id": 7428, "quality": 0.9166666666666666, "length": 11}}}, "31663294": {"ParentId": "31662792", "CommentCount": "0", "CreationDate": "2015-07-27T21:04:51.127", "OwnerUserId": "1196549", "PostTypeId": "2", "Id": "31663294", "Score": "17", "Body": "<p>The <code>int</code>s are not promoted to <code>long long</code> before multiplication, they remain <code>int</code>s and the product as well. Then the product is cast to <code>long long</code>, but too late, overflow has struck.</p>\n<p>Having one of <code>a</code> or <code>b</code> <code>long long</code> should work as well, as the other would be promoted.</p>\n", "LastActivityDate": "2015-07-27T21:04:51.127"}});