post_cb({"14791495": {"CommentCount": "0", "ViewCount": "2496", "LastActivityDate": "2013-09-04T04:02:35.137", "Body": "<p>I am trying to get familiar with the new memory ordering concepts of c++11 and believed I actully had a quite good grasp on them, until I stumbled upon this implementation of a spin lock:  </p>\n<pre><code>#include &lt;atomic&gt;\n\nnamespace JayZ\n{\n    namespace Tools\n    {\n        class SpinLock\n        {\n        private:\n            std::atomic_flag spin_lock;\n        public:\n            inline SpinLock( void ) : atomic_flag( ATOMIC_FLAG_INIT ) {}\n\n            inline void lock( void )\n            {\n                while( spin_lock.test_and_set( std::memory_order_acquire ) )\n                    ;\n            }\n\n            inline void unlock( void )\n            {\n                lock.clear( std::memory_order_release );\n            }\n        };\n    }\n}\n</code></pre>\n<p>It is e.g. equivalently mentioned at <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic_flag\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/atomic/atomic_flag</a><br>\nand also in the book \"Concurrency in Action\". I also found it someplace here at SO.  </br></p>\n<p>But I just don't understand why it would work!<br>\nImagine thread 1 calls lock() and test_and_set() returns 0 as the old value --&gt; thread 1 has acquired the lock.<br>\nBut then thread 2 comes along and tries the same. Now since there has occurred no \"store synchronization\" (release,seq_cst_acq_rel) thread 1's store to spin_lock should be of type relaxed.<br>\nBut from this follows that it cannot imao be synchronized with thread 2's read of spin_lock. This should make it possible for thread 2 to read the value 0 from spin_lock and thus acquire the lock as well.<br>\nWhere is my mistake?</br></br></br></br></p>\n", "PostTypeId": "1", "AcceptedAnswerId": "14791524", "FavoriteCount": "2", "Title": "memory ordering with atomic_flag spin lock", "Id": "14791495", "Score": "4", "CreationDate": "2013-02-09T20:54:12.210", "Tags": "<c++><c++11><atomic>", "OwnerUserId": "483421", "AnswerCount": "3"}, "18605204": {"ParentId": "14791495", "CommentCount": "0", "Body": "<p>For a given atomic variable, there is a \"modification order\" for it.  Once thread 1 test_and_sets the value from 0 to 1, it is impossible for thread 2 to see a 0.</p>\n<p>Memory order affects how all other memory addresses are 'synced.'  If one thread modifies an atomic variable with a memory-order_release, then any thread that reads the same variable with memory_order_acquire \"sees\" every memory change the first thread made before it released.</p>\n<p>The acquire and release is not about the atomic.  It's about making sure every thread that successfully locks the spinlock \"sees\" the changes of every thread that locked it before.</p>\n<p>The modification order is the key to making the algorithm lockfree.  Both thread 1 and thread 2 are trying to do a test_and_set on the same variable, so by the rules, one modification \"happens before\" the other.  Because the test_and_set that \"happens before\" the other gets to \"progress,\" at least one thread must always make progress.  This is the definition of lockfree</p>\n", "OwnerUserId": "2728148", "PostTypeId": "2", "Id": "18605204", "Score": "1", "CreationDate": "2013-09-04T04:02:35.137", "LastActivityDate": "2013-09-04T04:02:35.137"}, "14792770": {"ParentId": "14791495", "CommentCount": "0", "Body": "<p><code>test_and_set</code> operations on atomic flags are specified to be <em>read-modify-write</em> operations which have special characteristics, one of which is:</p>\n<blockquote>\n<p id=\"so_14791495_14792770_0\">Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation. [n3337 \u00a7 29.3/12]</p>\n</blockquote>\n<p>This is also why <code>fetch_add</code>, for example, works whereas simple load operations are not required to read the latest value in the modification order.</p>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "14792770", "Score": "1", "CreationDate": "2013-02-09T23:23:15.017", "LastActivityDate": "2013-02-09T23:23:15.017"}, "bq_ids": {"n4140": {"so_14791495_14792770_0": {"section_id": 1158, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_14791495_14792770_0": {"section_id": 1156, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_14791495_14792770_0": {"section_id": 1252, "quality": 0.8823529411764706, "length": 15}}}, "14791524": {"ParentId": "14791495", "CommentCount": "13", "Body": "<p>Your mistake is in forgetting that <code>spin_lock</code> is an <code>atomic_flag</code> and thus <code>test_and_set</code> is an atomic operation. The <code>memory_order_acquire</code> and <code>memory_order_release</code> is needed to prevent reads from migrating to before the lock operation or writes from migrating to after the unlock. The lock itself is protected by atomicity which always includes visibility.</p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "14791524", "Score": "3", "CreationDate": "2013-02-09T20:58:32.690", "LastActivityDate": "2013-02-09T20:58:32.690"}});