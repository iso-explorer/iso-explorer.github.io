post_cb({"bq_ids": {"n4140": {"so_20958262_20958364_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 7214}}, "n3337": {"so_20958262_20958364_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 6958}}, "n4659": {"so_20958262_20958364_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 8723}}}, "20958364": {"Id": "20958364", "PostTypeId": "2", "Body": "<p>For 1: They are distinct types according to</p>\n<blockquote>\n<h3>3.9.1 Fundamental types [basic.fundamental]</h3>\n<p id=\"so_20958262_20958364_0\"><sup>5</sup> Type <code>wchar_t</code> is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1). Type <code>wchar_t</code> shall have the same size, signedness, and alignment requirements (3.11) as one of the other integral types, called its <em>underlying type</em>. Types <code>char16_t</code> and <code>char32_t</code> <strong>denote distinct types</strong> with the same size, signedness, and alignment as <code>uint_least16_t</code> and <code>uint_least32_t</code>, respectively, in <code>&lt;cstdint&gt;</code>, called the underlying types.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>This means GCC is correct and VS is wrong.</p>\n<p>For 2: GCC implements them as intended, i.e., as distinct types.</p>\n<p>For 3: Only Microsoft can answer that question, but I think it's likely that they will implement them correctly. Compiler vendors sometimes simply use a hack as a work-around to bridge the gap until a full solution is ready.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2014-01-06T20:22:48.363", "Score": "4", "CreationDate": "2014-01-06T20:09:06.030", "ParentId": "20958262", "CommentCount": "4", "LastEditDate": "2014-01-06T20:22:48.363", "OwnerUserId": "2073257"}, "20958262": {"ViewCount": "3086", "Body": "<p>As I understand, in C++11 <code>char16_t</code> and <code>char32_t</code> are not typedefs, but new primitive data types. (please correct me if I am wrong).</p>\n<p>I writing a library meant to be used on linux gcc and Windows Visual Studio. So I write a trait:</p>\n<pre><code>template &lt;class T&gt;\nstruct IsChar : std::false_type {\n};\n\ntemplate &lt;&gt;\nstruct IsChar&lt;char&gt; : std::true_type {\n};\n\ntemplate &lt;&gt;\nstruct IsChar&lt;wchar_t&gt; : std::true_type {\n};\n\ntemplate &lt;&gt;\nstruct IsChar&lt;char16_t&gt; : std::true_type {\n};\n\ntemplate &lt;&gt;\nstruct IsChar&lt;char32_t&gt; : std::true_type {\n};\n</code></pre>\n<p>However, I have noticed that in VS (2013), <code>char16_t</code> and <code>char32_t</code> are just typedefs for <code>unsigned short</code> and <code>unsigned</code> in <code>[..]\\Microsoft Visual Studio 12.0\\VC\\include\\yvals.h</code>.</p>\n<p>So I checked and</p>\n<p><code>std::is_same&lt;char32_t, unsigned&gt;::value</code></p>\n<p>is <code>true</code> in VS and <code>false</code> in gcc.</p>\n<p>So my questions are:</p>\n<ol>\n<li>Are <code>char16_t</code> and <code>char32_t</code> new primitive types in the standard (Is VS implementation of these two types non-standard?)</li>\n<li>Are these two types new primitives types in gcc, or just another typedefs (but maybe not the same typedefs as in VS)?'</li>\n<li>Is VS planning on implementing these types as new primitive types in the near future?</li>\n</ol>\n", "AcceptedAnswerId": "20958364", "Title": "char16_t and char32_t types in C++11", "CreationDate": "2014-01-06T20:02:44.550", "Id": "20958262", "CommentCount": "2", "LastEditDate": "2014-01-06T20:16:14.603", "PostTypeId": "1", "LastEditorUserId": "2073257", "LastActivityDate": "2014-01-06T20:22:48.363", "Score": "3", "OwnerUserId": "2805305", "Tags": "<c++><gcc><c++11><visual-studio-2013>", "AnswerCount": "1"}});