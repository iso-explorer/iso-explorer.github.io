post_cb({"22676859": {"CommentCount": "0", "AcceptedAnswerId": "22676925", "CreationDate": "2014-03-27T01:59:19.000", "LastActivityDate": "2014-09-13T18:19:34.103", "PostTypeId": "1", "ViewCount": "54", "FavoriteCount": "1", "Title": "why clock() does not work on the the cluster machine", "Id": "22676859", "Score": "0", "Body": "<p>I want to get the running time of part of my code.</p>\n<p>my C++ code is like:</p>\n<pre><code>...\ntime_t t1 = clock();\n/*\nHere is my core code.\n*/\ntime_t t2 = clock();\ncout &lt;&lt;\"Running time: \"&lt;&lt;  (1000.0 * (t2 - t1)) / CLOCKS_PER_SEC &lt;&lt; \"ms\" &lt;&lt; endl;\n...\n</code></pre>\n<p>This code works well on my laptop.(Opensuse,g++ and clang++, Core i5).</p>\n<p>But it does not work well on the cluster in the department.\n(Ubuntu, g++, amd Opteron and intel Xeon)</p>\n<p>I always get some integer running time :\nlike : 0ms or 10ms or 20ms.</p>\n<p>What cause that ? Why? Thanks!</p>\n", "Tags": "<c++><gcc><profiling><cpu>", "OwnerUserId": "1823894", "AnswerCount": "1"}, "22676925": {"ParentId": "22676859", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Clocks are not guaranteed to be exact down to ~10<sup>-44</sup> seconds (Planck time), they often have a minimal resolution. The Linux man page implies this with:</p>\n<blockquote>\n<p id=\"so_22676859_22676925_0\">The clock() function returns an <strong>approximation</strong> of processor time used by the program.</p>\n</blockquote>\n<p>and so does the ISO standard <code>C11 7.27.2.1 The clock function /3</code>:</p>\n<blockquote>\n<p id=\"so_22676859_22676925_1\">The clock function returns the implementation\u2019s <strong>best approximation</strong> of ...</p>\n</blockquote>\n<p>and in <code>7.27.1 Components of time /4</code>:</p>\n<blockquote>\n<p id=\"so_22676859_22676925_2\">The range and <strong>precision</strong> of times representable in clock_t and time_t are implementation-defined.</p>\n</blockquote>\n<p>From your (admittedly limited) sample data, it looks like the minimum resolution of your cluster machines is on the order of 10ms.</p>\n<hr>\n<p>In any case, you have several possibilities if you need a finer resolution.</p>\n<ul>\n<li><p>First, find a (probably implementation-specific) means of timing things more accurately.</p></li>\n<li><p>Second, don't do it once. Do it a thousand times in a tight loop and then just divide the time taken by 1000. That should <em>roughly</em> increase your resolution a thousand-fold.</p></li>\n<li><p>Thirdly, think about the implication that your code only takes 50ms at the outside. Unless you have a pressing need to execute it more than twenty times a second (assuming you have no other code to run), it may not be an issue.</p></li>\n</ul>\n<p>On that last point, think of things like \"What's the longest a user will have to wait before they get annoyed?\". The answer to that would vary but half a second might be fine in most situations.</p>\n<p>Since 50ms code could run ten times over during that time, you may want to ignore it. You'd be better off concentrating on code that has a clearly larger impact.</p>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "759866", "LastEditDate": "2014-09-13T18:19:34.103", "Id": "22676925", "Score": "1", "CreationDate": "2014-03-27T02:06:55.810", "LastActivityDate": "2014-09-13T18:19:34.103"}, "bq_ids": {"n4140": {"so_22676859_22676925_0": {"section_id": 2665, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_22676859_22676925_0": {"section_id": 2629, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_22676859_22676925_0": {"section_id": 3405, "quality": 0.5714285714285714, "length": 4}}}});