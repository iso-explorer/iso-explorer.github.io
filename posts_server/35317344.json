post_cb({"bq_ids": {"n4140": {"so_35317344_35317344_1": {"length": 7, "quality": 0.875, "section_id": 4321}, "so_35317344_35317344_0": {"length": 24, "quality": 0.96, "section_id": 4320}}, "n3337": {"so_35317344_35317344_1": {"length": 6, "quality": 0.75, "section_id": 4162}, "so_35317344_35317344_0": {"length": 23, "quality": 0.92, "section_id": 4161}}, "n4659": {"so_35317344_35317344_1": {"length": 7, "quality": 0.875, "section_id": 5578}, "so_35317344_35317344_0": {"length": 24, "quality": 0.96, "section_id": 5577}}}, "35317773": {"Id": "35317773", "PostTypeId": "2", "Body": "<p>A reference can't be reseated after initialization. It acts in all ways as the object it refers to. And that includes assignment.</p>\n<p>Because the reference acts as the object that it refers to, the copying of the referent is what you'd get in an ordinary class with an assignment operator implemented as a sequence of per-member assignments. </p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2017-05-18T22:49:15.970", "Score": "0", "CreationDate": "2016-02-10T14:24:43.347", "ParentId": "35317344", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2017-05-18T22:49:15.970"}, "35317344": {"ViewCount": "394", "Body": "<p>Imaging the case when you have an <code>unique_ptr</code> with a custom deleter stored by a reference:</p>\n<pre><code>struct CountingDeleter\n{\n    void operator()(std::string *p) {\n        ++cntr_;\n        delete p;\n    }\n\n    unsigned long cntr_ = 0;\n};\n\nint main()\n{\n    CountingDeleter d1{}, d2{};\n\n    {\n        std::unique_ptr&lt;std::string, CountingDeleter&amp;&gt;\n            p1(new std::string{\"first\"} , d1),\n            p2(new std::string{\"second\"}, d2);\n\n        p1 = std::move(p2); // does d1 = d2 under cover\n    }\n\n    std::cout &lt;&lt; \"d1 \" &lt;&lt; d1.cntr_ &lt;&lt; \"\\n\"; // output: d1 1\n    std::cout &lt;&lt; \"d2 \" &lt;&lt; d2.cntr_ &lt;&lt; \"\\n\"; // output: d2 0\n}\n</code></pre>\n<p>It was a surprise for me that the assignment in the code above has a side-effect of copying <code>d2</code> into <code>d1</code>. I've double check it and found that this behavior is as described in the standard in <a href=\"http://eel.is/c++draft/unique.ptr.single.asgn\" rel=\"noreferrer\">[unique.ptr.single.asgn]</a>:</p>\n<blockquote>\n<p id=\"so_35317344_35317344_0\">(1) - Requires: If <code>D</code> is not a reference type, <code>D</code> shall satisfy the requirements of <code>MoveAssignable</code> and assignment of the deleter from an rvalue of type <code>D</code> shall not throw an exception.\n  Otherwise, <code>D</code> is a reference type; <code>remove_reference_t&lt;D&gt;</code> shall satisfy the <code>CopyAssignable</code> requirements and assignment of the deleter from an lvalue of type <code>D</code> shall not throw an exception.</p>\n<p id=\"so_35317344_35317344_1\">(2) - Effects: Transfers ownership from <code>u</code> to <code>*this</code> as if by calling <code>reset(u.release())</code> followed by <code>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</code>.</p>\n</blockquote>\n<p>To get the behavior that I expected (a shallow copy of the deleter reference) I had to wrap the deleter reference into <code>std::reference_wrapper</code>:</p>\n<pre><code>std::unique_ptr&lt;std::string, std::reference_wrapper&lt;CountingDeleter&gt;&gt;\n    p1(new std::string{\"first\"} , d1),\n    p2(new std::string{\"second\"}, d2);\n\np1 = std::move(p2); // p1 now stores reference to d2 =&gt; no side effects!\n</code></pre>\n<p>For me the current handling of a deleter reference in the unique ptr is counter-intuitive and even error-prone:</p>\n<ol>\n<li><p>When you store a deleter by a reference rather than by value this mostly because you want the shared deleter with some important unique state. So you don't expect the shared deleter is overwritten and its state is lost after a unique ptr assignment.</p></li>\n<li><p>It's expected that assignment of a unique_ptr is extremely chip, especially if the deleter is a reference. But instead of this, you get copying of the deleter what can be (unexpectedly) expensive.</p></li>\n<li><p>After the assignment, the pointer become bound to original deleter's copy, rather than to the original deleter itself. This might lead to some unexpected side-effects if the deleter's identity is important.</p></li>\n<li><p>Also, current behavior prevents from using a const reference to a deleter because you just can't copy into a const object.</p></li>\n</ol>\n<p>IMO it would be better to forbid a deleters of reference types and accept only a movable value types.</p>\n<p>So my question is the following (it looks like two questions in one, sorry):</p>\n<ul>\n<li><p>Is there any reason why the standard <code>unique_ptr</code> behaves like this?</p></li>\n<li><p>Does anybody have a good example where it's useful to have a reference type deleter in <code>unique_ptr</code> rather than a non-reference one (i.e. a value type)?</p></li>\n</ul>\n", "Title": "unique_ptr's assignment operator copies a deleter stored by a reference. Is it a feature or a bug?", "CreationDate": "2016-02-10T14:04:50.227", "LastActivityDate": "2017-05-18T22:49:15.970", "CommentCount": "13", "LastEditDate": "2016-02-11T22:35:01.723", "PostTypeId": "1", "LastEditorUserId": "2572774", "Id": "35317344", "Score": "10", "OwnerUserId": "2572774", "Tags": "<c++><c++11><smart-pointers><unique-ptr>", "AnswerCount": "3"}, "35317370": {"Id": "35317370", "PostTypeId": "2", "Body": "<p>Having reference data members often leads to surprising results because assigning to a reference has non-value semantics because a reference cannot be re-assigned to refer to another object. Basically, reference data members break your assignment operator semantics. </p>\n<p>Using pointer members instead fixes that. Alternatively, use <code>std::reference_wrapper&lt;&gt;</code> and <code>std::ref()</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_35317344_35317370_0\">Why does it perform a deep copy of a deleter stored by a reference rather than just a shallow copy?</p>\n</blockquote>\n<p>It performs member-wise copy. If the value being copied is a pointer, that happens to be a shallow copy.</p>\n</hr>", "LastEditorUserId": "412080", "LastActivityDate": "2016-02-10T14:22:41.297", "Score": "2", "CreationDate": "2016-02-10T14:06:29.853", "ParentId": "35317344", "CommentCount": "3", "OwnerUserId": "412080", "LastEditDate": "2016-02-10T14:22:41.297"}, "35318283": {"Id": "35318283", "PostTypeId": "2", "Body": "<p>This is a feature.</p>\n<p>If you have stateful deleters presumably the state is important, and is associated with the pointer that it will be used to delete. That means the deleter state should be transferred when ownership of the pointer transfers.</p>\n<p>But if you store a deleter by reference it means you care about the identity of the deleter, not just its value (i.e. it's state), and updating the <code>unique_ptr</code> should not re-bind the reference to a different object.</p>\n<p>So if you don't want this, why are you even storing a deleter by reference?</p>\n<p>What does a shallow copy of a reference even <em>mean</em>? There's no such thing in C++. If you don't want reference semantics, don't use references.</p>\n<p>If you really want to do this, then the solution is simple: define assignment for your deleter to not change the counter:</p>\n<pre><code>CountingDeleter&amp;\noperator=(const CountingDeleter&amp;) noexcept\n{ return *this; }\n</code></pre>\n<p>Or since what you really seem to care about is the counter, not the deleter, keep the counter outside the deleter and don't use reference deleters:</p>\n<pre><code>struct CountingDeleter\n{\n    void operator()(std::string *p) {\n        ++*cntr_;\n        delete p;\n    }\n\n    unsigned long* cntr_;\n};\n\nunsigned long c1 = 0, c2 = 0;\nCountingDeleter d1{&amp;c1}, d2{&amp;c2};\n\n{\n    std::unique_ptr&lt;std::string, CountingDeleter&gt;\n        p1(new std::string{\"first\"} , d1),\n        p2(new std::string{\"second\"}, d2);\n</code></pre>\n", "LastEditorUserId": "981959", "LastActivityDate": "2016-02-10T15:05:29.107", "Score": "13", "CreationDate": "2016-02-10T14:45:49.497", "ParentId": "35317344", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2016-02-10T15:05:29.107"}});