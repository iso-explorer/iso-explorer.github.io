post_cb({"bq_ids": {"n4140": {"so_43071676_43071676_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 371}, "so_43071676_43071946_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6805}}, "n3337": {"so_43071676_43071676_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 361}, "so_43071676_43071946_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6560}}, "n4659": {"so_43071676_43071676_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 385}}}, "43071676": {"ViewCount": "1994", "Body": "<pre><code>#include &lt;cstdlib&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace std::literals;\n\nstruct A\n{\n    int n_ = 0;\n    A(int n) : n_(n) { cout &lt;&lt; \"A:\" &lt;&lt; n_ &lt;&lt; endl; }\n    ~A() { cout &lt;&lt; \"~A:\" &lt;&lt; n_ &lt;&lt; endl; }\n};\n\nA a1(1);\n\nint main()\n{\n    std::thread([]()\n    {\n        static A a2(2);\n        thread_local A a3(3);\n        std::this_thread::sleep_for(24h);\n    }).detach();\n\n    static A a4(4);\n    thread_local A a5(5);\n\n    std::this_thread::sleep_for(1s);\n    std::exit(0);\n}\n</code></pre>\n<p>My compiler is <code>clang 5.0</code> with <code>-std=c++1z</code>.</p>\n<p>The output is as follows:</p>\n<blockquote id=\"so_43071676_43071676_0\">\n<pre><code>A:1\nA:2\nA:4\nA:5\nA:3\n~A:5\n~A:2\n~A:4\n~A:1\n</code></pre>\n</blockquote>\n<p>Note that there is no <code>~A:3</code>, which means the object <code>A a3</code> was not destructed.</p>\n<p>However, according to <a href=\"http://en.cppreference.com/w/cpp/utility/program/exit\" rel=\"noreferrer\">cppref</a>:</p>\n<blockquote>\n<p id=\"so_43071676_43071676_1\"><code>std::exit</code> causes normal program termination to occur. Several cleanup steps are\n  performed:</p>\n<p id=\"so_43071676_43071676_2\">The destructors of objects with thread local storage duration ... are\n  guaranteed to be called.  </p>\n</blockquote>\n", "AcceptedAnswerId": "43071946", "Title": "Why does `std::exit` not trigger destructors as expected?", "CreationDate": "2017-03-28T14:01:18.297", "Id": "43071676", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-03-28T19:16:26.297", "LastEditorUserId": "1157100", "LastActivityDate": "2017-03-28T19:16:26.297", "Score": "24", "OwnerUserId": "508343", "Tags": "<c++><c++11><global-variables><destructor><thread-local-storage>", "AnswerCount": "2"}, "43071946": {"Id": "43071946", "PostTypeId": "2", "Body": "<p>Objects with thread storage duration are guaranteed to be destroyed only for the thread which calls <code>exit</code>. Quoting C++14 (N4140), [support.start.term] 18.5/8 (emphasis mine):</p>\n<blockquote>\n<pre><code>[[noreturn]] void exit(int status)\n</code></pre>\n<p id=\"so_43071676_43071946_0\">The function <code>exit()</code> has additional behavior in this International Standard:</p>\n<ul>\n<li>First, objects with thread storage duration <strong>and associated with the current thread</strong> are destroyed.\n  Next, objects with static storage duration are destroyed and functions registered by calling atexit\n  are called. See 3.6.3 for the order of destructions and calls. (Automatic objects are not\n  destroyed as a result of calling <code>exit()</code>.)\n  If control leaves a registered function called by <code>exit</code> because the function does not provide a\n  handler for a thrown exception, <code>std::terminate()</code> shall be called (15.5.1).</li>\n<li>Next, all open C streams (as mediated by the function signatures declared in <code>&lt;cstdio&gt;</code>) with\n  unwritten buffered data are flushed, all open C streams are closed, and all files created by calling\n  <code>tmpfile()</code> are removed.</li>\n<li>Finally, control is returned to the host environment. If status is zero or <code>EXIT_SUCCESS</code>, an\n  implementation-defined form of the status successful termination is returned. If status is <code>EXIT_FAILURE</code>, an implementation-defined form of the status unsuccessful termination is returned.\n  Otherwise the status returned is implementation-defined.</li>\n</ul>\n</blockquote>\n<p>The standard therefore does not guarantee destruction of objects with thread storage duration associated with other threads than the one calling <code>exit</code>.</p>\n", "LastActivityDate": "2017-03-28T14:13:25.670", "CommentCount": "2", "CreationDate": "2017-03-28T14:13:25.670", "ParentId": "43071676", "Score": "37", "OwnerUserId": "1782465"}, "43071913": {"Id": "43071913", "PostTypeId": "2", "Body": "<p>The problem here is that when you exit the process, the thread will be (on most modern multi-tasking operating systems) forcibly killed. This killing of the thread happens at the OS level, and the OS doesn't know anything about objects or destructors.</p>\n", "LastActivityDate": "2017-03-28T14:11:45.187", "CommentCount": "2", "CreationDate": "2017-03-28T14:11:45.187", "ParentId": "43071676", "Score": "14", "OwnerUserId": "440558"}});