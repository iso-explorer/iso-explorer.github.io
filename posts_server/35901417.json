post_cb({"bq_ids": {"n4140": {"so_35901417_35901524_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 715}}, "n4659": {"so_35901417_35901524_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 745}}}, "35901417": {"ViewCount": "171", "LastEditDate": "2016-03-09T20:01:54.130", "AcceptedAnswerId": "35901524", "Title": "Default-inserting into a vector isn't default initialization?", "CreationDate": "2016-03-09T19:58:07.017", "LastActivityDate": "2016-03-09T20:51:27.720", "CommentCount": "12", "Body": "<p>One of the <code>std::vector</code> constructors is stipulated as, emphasis mine:</p>\n<blockquote>\n<p id=\"so_35901417_35901417_0\"><code>explicit vector(size_type n, const Allocator&amp; = Allocator());</code><br>\n<em>Effects:</em> Constructs a <code>vector</code> with <code>n</code> <strong>default-inserted</strong> elements using the specified allocator.<br>\n<em>Requires:</em> <code>T</code> shall be <code>DefaultInsertable</code> into <code>*this.</code><br>\n<em>Complexity:</em> Linear in <code>n</code>.</br></br></br></p>\n</blockquote>\n<p>Is default-insertion in any way related to default initialization? On this code:</p>\n<pre><code>std::vector&lt;char&gt; v(66000);\n</code></pre>\n<p>gcc 5.2 optimized produces:</p>\n<pre><code>  400d18:   bf d0 01 01 00          mov    $0x101d0,%edi\n  400d1d:   48 83 c5 01             add    $0x1,%rbp\n  400d21:   e8 1a fd ff ff          callq  400a40 &lt;operator new(unsigned long)@plt&gt;\n  400d26:   31 f6                   xor    %esi,%esi\n  400d28:   48 89 c3                mov    %rax,%rbx\n  400d2b:   ba d0 01 01 00          mov    $0x101d0,%edx\n  400d30:   48 89 c7                mov    %rax,%rdi\n  400d33:   e8 38 fc ff ff          callq  400970 &lt;memset@plt&gt;\n</code></pre>\n<p><code>memset</code>? What are <em>you</em> doing here? I thought this should simply do the equivalent of <code>new char[66000]</code>... that is, no initialization. clang 3.7 also emits a <code>memset</code>. </p>\n<p>Why is there a <code>memset</code> here? Is this correct with respect to the standard? After all, if I wanted 66000 value-initialized chars I already have this constructor:</p>\n<pre><code>std::vector&lt;char&gt; v(66000, '\\0');\n</code></pre>\n", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "35901417", "AnswerCount": "1", "Score": "4", "OwnerUserId": "2069064", "Tags": "<c++><c++11><vector>", "FavoriteCount": "1"}, "35901524": {"Id": "35901524", "PostTypeId": "2", "LastEditDate": "2016-03-09T20:51:27.720", "CommentCount": "0", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-09T20:51:27.720", "CreationDate": "2016-03-09T20:04:53.983", "ParentId": "35901417", "Score": "8", "Body": "<p>This is correct behaviour. See 23.2.1: </p>\n<blockquote>\n<p id=\"so_35901417_35901524_0\">An element of X is default-inserted if it is initialized by evaluation of the expression <code>allocator_traits&lt;A&gt;::construct(m, p)</code></p>\n</blockquote>\n<p>Than, <code>allocator_traits&lt;A&gt;::construct</code> will call <code>a.construct(p, std::forward&lt;Args&gt;(args)...)</code>. Which, in turn, calls <code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</code>, which in effect calls <code>new()</code>, which does value-initialization.</p>\n<h2>Conclusion:</h2>\n<p><code>memset()</code> is appropriate.</p>\n<h2>Conclusion #2</h2>\n<p>Absent custom allocators, <code>std::vector</code> does not allow one an option to access uninitialized storage. Every object which is legitimately in vector was value-initialized.</p>\n", "OwnerUserId": "5245033"}});