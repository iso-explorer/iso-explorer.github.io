post_cb({"47168614": {"ParentId": "47168371", "CommentCount": "0", "CreationDate": "2017-11-07T22:42:17.660", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "47168614", "Score": "5", "Body": "<p>In C++17, a paragraph was added that explicitly discusses cases like <code>u.i = 42</code>:</p>\n<blockquote>\n<p id=\"so_47168371_47168614_0\"><strong>[class.union]/5</strong> When the left operand of an assignment operator involves a member access expression (8.2.5) that nominates a union member, it may begin the lifetime of that union member, as described below. For an expression <code>E</code>,\n  define the set <code>S(E)</code> of subexpressions of <code>E</code> as follows:</p>\n<p id=\"so_47168371_47168614_1\">(5.1) \u2014 If <code>E</code> is of the form <code>A.B</code>, <code>S(E)</code> contains the elements of <code>S(A)</code>, and also contains <code>A.B</code> if <code>B</code> names a union member of a non-class, non-array type, or of a class type with a trivial default constructor that is not deleted, or an array of such types.</p>\n<p id=\"so_47168371_47168614_2\">(5.2) \u2014 If <code>E</code> is of the form <code>A[B]</code> and is interpreted as a built-in array subscripting operator, <code>S(E)</code> is <code>S(A)</code> if <code>A</code> is of array type, <code>S(B)</code> if <code>B</code> is of array type, and empty otherwise.</p>\n<p id=\"so_47168371_47168614_3\">(5.3) \u2014 Otherwise, <code>S(E)</code> is empty.</p>\n<p id=\"so_47168371_47168614_4\">In an assignment expression of the form <code>E1 = E2</code> that uses either the built-in assignment operator (8.18) or a trivial assignment operator (15.8), for each element <code>X</code> of <code>S(E1)</code>, if modification of <code>X</code> would have undefined behavior under 6.8, an object of the type of <code>X</code> is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment. [ <em>Note:</em> This ends the lifetime of the previously-active member of the union, if any (6.8). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>(Followed by a longish example that I'm too lazy to format properly, but which you can see <a href=\"http://eel.is/c++draft/class.union#5\" rel=\"noreferrer\">here</a>.)</p>\n", "LastActivityDate": "2017-11-07T22:42:17.660"}, "47168371": {"CommentCount": "8", "AcceptedAnswerId": "47168614", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-11-07T22:19:42.933", "LastActivityDate": "2017-11-09T09:34:04.707", "LastEditDate": "2017-11-09T09:34:04.707", "ViewCount": "191", "FavoriteCount": "3", "Title": "What makes a union member active?", "Id": "47168371", "Score": "6", "Body": "<p>What makes a union member active?</p>\n<p>I've read chapter 9.5 of the C++14 standard (the one about unions), but I haven't found a clear answer to what makes a union member active.</p>\n<p>There is a note:</p>\n<blockquote>\n<p id=\"so_47168371_47168371_0\">In general, one must use explicit destructor calls and placement new\n  operators to change the active member of a union.</p>\n</blockquote>\n<p>So for example,</p>\n<pre><code>union U {\n  int i;\n  short s;\n} u;\n\nnew(&amp;u.i) int(42);\n</code></pre>\n<p>Okay, placement new changes the active member, it's clear. But we usually don't use placement new when working with types with trivial constructors.</p>\n<p>Does <code>operator=</code> change the active member without UB?</p>\n<pre><code>u.i = 42;\n</code></pre>\n<p>Here, <code>operator=</code> called on an unconstructed object. Is it well defined?</p>\n<p>What about this?</p>\n<pre><code>struct A {\n  int i0;\n  int i1;\n};\nunion U {\n  A a;\n  short s;\n} u;\n</code></pre>\n<p>What makes <code>a</code> to be the active member of <code>u</code>? Is setting both <code>i0</code> &amp; <code>i1</code> enough?</p>\n<pre><code>u.a.i0 = 42;\nu.a.i1 = 99;\n</code></pre>\n<p>What if I write:</p>\n<pre><code>u.a.i0 = 42;     // supposedly this doesn't change the active member to a, as i1 isn't set\nint x = u.a.i0;  // is it fine to read from a.i0? a is not an active member supposedly\n</code></pre>\n<p>After <code>u.a.i0 = 42;</code>, the active member isn't changed to <code>a</code> (I think), so is it UB to do <code>int x = u.a.i0;</code>?</p>\n<p>Does C++17 improve on the description of active members?</p>\n", "Tags": "<c++><c++14><language-lawyer><c++1z><unions>", "OwnerUserId": "8157187", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47168371_47168371_0": {"section_id": 5916, "quality": 1.0, "length": 14}}, "n3337": {"so_47168371_47168371_0": {"section_id": 5688, "quality": 1.0, "length": 14}}, "n4659": {"so_47168371_47168371_0": {"section_id": 7409, "quality": 0.8571428571428571, "length": 12}, "so_47168371_47168614_2": {"section_id": 7408, "quality": 1.0, "length": 12}, "so_47168371_47168614_4": {"section_id": 7408, "quality": 0.8823529411764706, "length": 45}, "so_47168371_47168614_1": {"section_id": 7408, "quality": 1.0, "length": 20}, "so_47168371_47168614_0": {"section_id": 7408, "quality": 0.8888888888888888, "length": 24}}}});