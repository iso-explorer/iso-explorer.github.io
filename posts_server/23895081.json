post_cb({"bq_ids": {"n4140": {"so_23895081_23895527_6": {"length": 5, "quality": 0.7142857142857143, "section_id": 5988}, "so_23895081_23895527_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 5907}}, "n3337": {"so_23895081_23895527_6": {"length": 5, "quality": 0.7142857142857143, "section_id": 5756}, "so_23895081_23895527_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 5679}}, "n4659": {"so_23895081_23895527_6": {"length": 5, "quality": 0.7142857142857143, "section_id": 7488}, "so_23895081_23895527_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 7389}}}, "23895527": {"Id": "23895527", "PostTypeId": "2", "Body": "<p>Different generations of the same compiler sometimes <em>can</em> be compatible with each other, but not always. For example, GCC 4.7.0 <a href=\"http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/gcc-4.7.0-1/\">changed its C/C++ ABI</a>, meaning libraries compiled with 4.7.0+ and 4.7.0- are not likely to be compatible with each other (so in your example, the library compiled with 4.6 will <em>not</em> be compatible with the library compiled with 4.9). There can also be ABI bugs within a given compiler release, <a href=\"http://gcc.gnu.org/gcc-4.7/changes.html\">as happened in GCC 4.7.0/4.7.1</a>:</p>\n<blockquote>\n<p id=\"so_23895081_23895527_0\">GCC versions 4.7.0 and 4.7.1 had changes to the C++ standard library which affected the ABI in C++11 mode: a data member was added to std::list changing its size and altering the definitions of some member functions, and std::pair's move constructor was non-trivial which altered the calling convention for functions with std::pair arguments or return types. The ABI incompatibilities have been fixed for GCC version 4.7.2 but as a result C++11 code compiled with GCC 4.7.0 or 4.7.1 may be incompatible with C++11 code compiled with different GCC versions and with C++98/C++03 code compiled with any version.</p>\n</blockquote>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\">The GCC ABI Policy and Guidelines page</a> indicates they try to maintain forward compatibility, but not backward compatibility:</p>\n<blockquote>\n<p id=\"so_23895081_23895527_1\">Versioning gives subsequent releases of library binaries the ability to add new symbols and add functionality, all the while retaining compatibility with the previous releases in the series. Thus, program binaries linked with the initial release of a library binary will still run correctly if the library binary is replaced by carefully-managed subsequent library binaries. This is called forward compatibility.</p>\n<p id=\"so_23895081_23895527_2\">The reverse (backwards compatibility) is not true. It is not possible to take program binaries linked with the latest version of a library binary in a release series (with additional symbols added), substitute in the initial release of the library binary, and remain link compatible.</p>\n</blockquote>\n<p>That page also has some fairly lengthy explanations on the versioning system GCC uses to mark different versions of given components, as well as an explanation for the versioning behind GCC itself:</p>\n<blockquote>\n<p id=\"so_23895081_23895527_3\">Allowed Changes</p>\n<ul>\n<li><p id=\"so_23895081_23895527_4\">The following will cause the library minor version number to increase, say from \"libstdc++.so.3.0.4\" to \"libstdc++.so.3.0.5\".</p></li>\n<li><p id=\"so_23895081_23895527_5\">Adding an exported global or static data member</p></li>\n<li><p id=\"so_23895081_23895527_6\">Adding an exported function, static or non-virtual member function</p></li>\n<li><p id=\"so_23895081_23895527_7\">Adding an exported symbol or symbols by additional instantiations</p></li>\n<li><p id=\"so_23895081_23895527_8\">Other allowed changes are possible.</p></li>\n</ul>\n<p id=\"so_23895081_23895527_9\">Prohibited Changes</p>\n<p id=\"so_23895081_23895527_10\">The following non-exhaustive list will cause the library major version number to increase, say from \"libstdc++.so.3.0.4\" to \"libstdc++.so.4.0.0\".</p>\n<ul>\n<li><p id=\"so_23895081_23895527_11\"><strong>Changes in the gcc/g++ compiler ABI</strong></p></li>\n<li><p id=\"so_23895081_23895527_12\">Changing size of an exported symbol</p></li>\n<li><p id=\"so_23895081_23895527_13\">Changing alignment of an exported symbol</p></li>\n<li><p id=\"so_23895081_23895527_14\">Changing the layout of an exported symbol</p></li>\n<li><p id=\"so_23895081_23895527_15\">Changing mangling on an exported symbol</p></li>\n<li><p id=\"so_23895081_23895527_16\">Deleting an exported symbol</p></li>\n<li><p id=\"so_23895081_23895527_17\">Changing the inheritance properties of a type by adding or removing base classes</p></li>\n<li><p id=\"so_23895081_23895527_18\">Changing the size, alignment, or layout of types specified in the C++ standard. These may not necessarily be instantiated or otherwise exported in the library binary, and include all the required locale facets, as well as things like std::basic_streambuf, et al.</p></li>\n<li><p id=\"so_23895081_23895527_19\">Adding an explicit copy constructor or destructor to a class that would otherwise have implicit versions. This will change the way the compiler deals with this class in by-value return statements or parameters: instead of passing instances of this class in registers, the compiler will be forced to use memory. See the section on Function Calling Conventions and APIs of the C++ ABI documentation for further details.</p></li>\n</ul>\n</blockquote>\n<p>Note the bolded bit. In a perfect world, GCC versions with the same major release number would be binary-compatible. This isn't a perfect world, so test very very carefully before you go mixing compiler versions like this, but in general you'll probably be okay.</p>\n", "LastActivityDate": "2014-05-27T17:30:20.130", "CommentCount": "0", "CreationDate": "2014-05-27T17:30:20.130", "ParentId": "23895081", "Score": "19", "OwnerUserId": "2245528"}, "23895081": {"ViewCount": "6322", "Body": "<p>For example could I mix a set of libraries that have been compiled in say GCC-4.6 with GCC-4.9.</p>\n<p>I'm aware different compilers \"breeds\" such as VS cannot be with MinGW but can different generations of the same compiler? Are issues likely to occur? If so what?</p>\n", "AcceptedAnswerId": "23895527", "Title": "Can you mix c++ compiled with different versions of the same compiler", "CreationDate": "2014-05-27T17:03:31.093", "Id": "23895081", "CommentCount": "4", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2014-05-28T07:26:15.947", "LastEditorUserId": "3235496", "LastActivityDate": "2014-05-28T07:26:15.947", "Score": "19", "OwnerUserId": "1458214", "Tags": "<c++><gcc><abi><gcc4.9><gcc4.6>", "AnswerCount": "2"}, "23895468": {"Id": "23895468", "PostTypeId": "2", "Body": "<p>You can only mix generated binary files from different compilers or different versions of the same compiler if they are ABI (Application Binary Interface) compatible. </p>\n<p>Things like:</p>\n<ul>\n<li>Calling procedure</li>\n<li>Name mangling</li>\n<li>Thread local storage handling</li>\n</ul>\n<p>are all part of the ABI.</p>\n<p>If one of these things change, you will find that you either get linker errors, crashes or other forms of unexpected behaviour.\nAs a general rule, compiler vendors will often try maintaining at least backwards compatibility with older version, but there is no guarantee of this. As other have said you must either read the documentation or just recompile everything.</p>\n", "LastActivityDate": "2014-05-27T17:26:01.543", "CommentCount": "2", "CreationDate": "2014-05-27T17:26:01.543", "ParentId": "23895081", "Score": "3", "OwnerUserId": "232918"}});