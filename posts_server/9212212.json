post_cb({"9212421": {"ParentId": "9212212", "CommentCount": "0", "Body": "<p>Weird C++ fact: it is legal (and, very rarely, useful) to define a pure virtual function.</p>\n<p>You could try adding</p>\n<pre><code>void base::bar() { cout &lt;&lt; \"Wuh?\"; }\n</code></pre>\n<p>and you will find line 2 and line 4 invoke that function.</p>\n<p>The legal way to call that definition is to do it explicitly: <code>base::bar();</code></p>\n<p>The compiler has managed to optimise the virtual call (which will fail) to the non-virtual call in those cases. It is neither required nor prevented from doing that; all your calls have undefined behaviour.</p>\n", "OwnerUserId": "212870", "PostTypeId": "2", "Id": "9212421", "Score": "0", "CreationDate": "2012-02-09T14:13:49.170", "LastActivityDate": "2012-02-09T14:13:49.170"}, "9212212": {"CommentCount": "4", "AcceptedAnswerId": "9212392", "PostTypeId": "1", "LastEditorUserId": "452307", "CreationDate": "2012-02-09T14:01:00.307", "LastActivityDate": "2014-03-08T23:40:55.247", "LastEditDate": "2012-02-09T15:23:58.517", "ViewCount": "1316", "FavoriteCount": "3", "Title": "Pure Virtual Function call from Base Ctor", "Id": "9212212", "Score": "5", "Body": "<p>Consider the following sample code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass base\n{\n   public:\n      base()\n      {\n         bar(); //Line1\n         this-&gt;bar(); //Line2\n         base *bptr = this; \n         bptr-&gt;bar(); //Line3\n         ((base*)(this))-&gt;bar(); //Line4\n      }\n\n      virtual void bar() = 0;\n};\n\nclass derived: base\n{\n   public:\n      void bar()\n      {\n         cout &lt;&lt; \"vfunc in derived class\\n\";\n      }\n};\n\nint main()\n{\n   derived d;\n}\n</code></pre>\n<p>The above code has pure virtual function <code>bar()</code> in base class which is overriden in the derived class. The pure virtual function <code>bar()</code> has no definition in base class.</p>\n<p>Now focus on <code>Line1</code>, <code>Line2</code>, <code>Line3</code> and <code>Line4</code>.</p>\n<p><strong>I understand</strong> : <code>Line1</code> gives compilation error, because pure virtual function cannot be called from ctor.</p>\n<p><strong>Questions:</strong></p>\n<ol>\n<li><p>Why does <code>Line2</code> and <code>Line4</code> give no <code>compilation error</code> for the same reason mentioned in <code>I understand</code> statement above?. The calls in <code>Line2</code> and <code>Line4</code> will eventually cause <code>linker-error</code> only.</p></li>\n<li><p>Why does <code>Line3</code> give neither compilation error nor linker error but gives <code>run-time exception</code> only ?</p></li>\n</ol>\n<p>Real-Life example of UB when Pure virtual function call through constructor:</p>\n<p><img alt=\"Real-Life example of UB when Pure virtual function call through constructor\" src=\"https://i.stack.imgur.com/gWeqe.png\"/></p>\n", "Tags": "<c++><constructor><linker-errors><runtime-error><pure-virtual>", "OwnerUserId": "1220250", "AnswerCount": "6"}, "9212392": {"ParentId": "9212212", "CommentCount": "7", "Body": "<p>Calling an Pure virtual function from constructor is an <strong>Undefined Behavior</strong> &amp; the compiler is free to show any behavior.   </p>\n<p>Reference:<br>\n<strong>C++03 Standard 10.4/6:</strong> </br></p>\n<blockquote>\n<p id=\"so_9212212_9212392_0\">\"Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.\"</p>\n</blockquote>\n<p>The C++ standard defines Undefined behavior in:   </p>\n<p><strong>[defns.undefined] 1.3.12 undefined behavior</strong> </p>\n<blockquote>\n<p id=\"so_9212212_9212392_1\">behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no requirements. Undefined behavior may also be expected when this International Standard omits the description of any explicit definition of behavior. [<strong>Note: permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.</strong> ]</p>\n</blockquote>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "9212392", "Score": "5", "CreationDate": "2012-02-09T14:12:23.277", "LastActivityDate": "2012-02-09T14:12:23.277"}, "9212450": {"ParentId": "9212212", "CommentCount": "0", "Body": "<p>Your code contains undefined behavior, so whatever the compiler does is\ncorrect.  All of the calls to <code>bar()</code> in your code require dynamic\nresolution, and would result in a call to a pure virtual function; this\nis undefined behavior.  (You can call <code>Base::bar()</code> if you write it like\nthat and the function exists, since no dynamic resolution is required.)\nThe fact that the code compiles doesn't mean that it will run\nsuccessfully; in the case of g++, for example, I'm fairly sure that it\nwill crash with an error message.</p>\n<p>Whether the compiler complains or not probably depends on how much \neffort it goes to to resolve the dynamic resolution at compile time.\nWithout optimization, it almost certainly can't resolve 3 at compile\ntime, but I'm somewhat surprised that it treats 1 and 2 differently.</p>\n<p>And the statement that \"pure virtual function cannot be called from\nconstructor\" is false.  The only time there is a problem is when dynamic\nresolution resolves to a pure virtual function.  Calling it with static\nresolution (assuming it exists) is fine, and calling a pure virtual\nfunction in a base class is fine if the dynamic resolution turns up a\nnon pure virtual function in a derived class whose constructor has\nstarted or has run.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "9212450", "Score": "0", "CreationDate": "2012-02-09T14:16:08.367", "LastActivityDate": "2012-02-09T14:16:08.367"}, "9212379": {"ParentId": "9212212", "CommentCount": "0", "Body": "<p>I can partially answer.  Line 3 requires that the compiler do data flow analysis to determine that the function Is not being called on another fully constructed object.</p>\n", "OwnerUserId": "183203", "PostTypeId": "2", "Id": "9212379", "Score": "1", "CreationDate": "2012-02-09T14:11:42.857", "LastActivityDate": "2012-02-09T14:11:42.857"}, "9212369": {"ParentId": "9212212", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In all four cases, the behaviour is undefined; so exactly what happens depends on what your compiler happens to do in the face of invalid input.</p>\n<p>The compiler might attempt to diagnose the problem to give a warning; this is easy to do for Line 1, and more difficult for the other lines, which would explain why you only see a warning for Line 1.</p>\n<p>When calling a virtual function from a constructor, the compiler knows which overload should be called, and so it might generate a static call. This is why you get a link error from Line 2 and Line 4.</p>\n<p>In Line 3, the compiler must have decided that it's too difficult to work out whether it can generate a static call, so it generated a dynamic call instead. Tracking the value of a variable is rather harder than working out that a temporary pointer must refer to <code>this</code>, and often not possible at all. That's why you get a run-time error there.</p>\n<p>Of course, all of this is undefined behaviour, and might change from compiler to compiler, or according to the phase of the moon.</p>\n<p>If the function had an implementation, then it would be valid to call it <em>statically</em>, as <code>Base::bar()</code>, or <code>bptr-&gt;Base::bar()</code>. Calling it dynamically would still give undefined behaviour.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2012-02-09T14:24:33.950", "Id": "9212369", "Score": "5", "CreationDate": "2012-02-09T14:10:50.160", "LastActivityDate": "2012-02-09T14:24:33.950"}, "bq_ids": {"n4140": {"so_9212212_9212392_0": {"section_id": 7023, "quality": 0.9615384615384616, "length": 25}, "so_9212212_9212392_1": {"section_id": 5768, "quality": 0.7777777777777778, "length": 49}}, "n3337": {"so_9212212_9212392_0": {"section_id": 6769, "quality": 0.9615384615384616, "length": 25}, "so_9212212_9212392_1": {"section_id": 5541, "quality": 0.7777777777777778, "length": 49}}, "n4659": {"so_9212212_9212392_0": {"section_id": 8520, "quality": 0.9615384615384616, "length": 25}, "so_9212212_9212392_1": {"section_id": 7225, "quality": 0.7777777777777778, "length": 49}}}, "9212475": {"ParentId": "9212212", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Which compiler are you using?</p>\n<p>Vc10 and gcc 4.6 all compile fine. gcc give a nice warning about calling virtual function from constructor will be just using the base::bar() function instead of polymorphic.</p>\n<p>This is probably bocs calling virtual from constructor is Undefined Behavior.</p>\n", "OwnerUserId": "833538", "LastEditorUserId": "759866", "LastEditDate": "2014-03-08T23:40:55.247", "Id": "9212475", "Score": "1", "CreationDate": "2012-02-09T14:17:48.337", "LastActivityDate": "2014-03-08T23:40:55.247"}});