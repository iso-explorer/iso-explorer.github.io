post_cb({"12323343": {"Id": "12323343", "PostTypeId": "2", "Body": "<p>Edited for clarity, original retained below.</p>\n<p>This code has undefined behavior because in the context of <code>main.cpp</code> the implicit <code>Cpimpl::~Cpimpl</code> destructor only has a forward declaration of <code>Cimpl</code>, but the <code>auto_ptr</code> (or any other form of doing <code>delete</code>) needs a full definition to legally clean up the <code>Cimpl</code>. Given that it's undefined behavior no further explanation for your observations is needed.</p>\n<p>Original answer:</p>\n<p>I suspect that what's happening here is that the implicit destructor of <code>Cpimpl</code> is being generated in the context of <code>classes.h</code> and <em>not</em> having access to the full definition of <code>Cimpl</code>. Then when the <code>auto_ptr</code> tries to do its thing and clean up its contained pointer, it deletes an incomplete class, which is undefined behavior. Given that it's undefined we don't have to go any further to explain that it's perfectly acceptable for it to work in different ways depending on the link order.</p>\n<p>I suspect that an explicit destructor for <code>Cpimpl</code> with a definition in a source file would solve your problem.</p>\n<p>EDIT: Actually now that I look at it again, I believe your program violates the one definition rule as it stands. In <code>main.cpp</code> it sees an implicit destructor that doesn't know how to call a destructor of <code>Cimpl</code> (because it only has a forward declaration). In <code>classes.cpp</code> the implicit destructor <em>does</em> have access to <code>Cimpl</code>'s definition and thus how to call its destructor.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2012-09-07T18:32:27.710", "Score": "0", "CreationDate": "2012-09-07T18:14:48.000", "ParentId": "12323028", "CommentCount": "2", "OwnerUserId": "251738", "LastEditDate": "2012-09-07T18:32:27.710"}, "12323028": {"ViewCount": "1247", "Body": "<p>I ran across this issue in my application after checking it for memory leaks, and discovered that some of my classes are not being destroyed at all. </p>\n<p>The code below is split into 3 files, it is supposed to implement a pattern called <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\" rel=\"nofollow\" title=\"pimpl\">pimpl</a>. The expected scenario is to have both <code>Cimpl</code> constructor and destructor print their messages. However, that's not what I get with g++. In my application, only constructor got called.</p>\n<p>classes.h:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass Cimpl;\n\nclass Cpimpl {\n    std::auto_ptr&lt;Cimpl&gt; impl;\npublic:\n    Cpimpl();\n};\n</code></pre>\n<p>classes.cpp:</p>\n<pre><code>#include \"classes.h\"\n#include &lt;stdio.h&gt;\n\nclass Cimpl {\npublic:\n    Cimpl() {\n        printf(\"Cimpl::Cimpl()\\n\");\n    }\n    ~Cimpl() {\n        printf(\"Cimpl::~Cimpl()\\n\");\n    }\n};    \n\nCpimpl::Cpimpl() {\n    this-&gt;impl.reset(new Cimpl);\n}\n</code></pre>\n<p>main.cpp:</p>\n<pre><code>#include \"classes.h\"\n\nint main() {\n    Cpimpl c;\n    return 0;\n}\n</code></pre>\n<p>Here is what I was able to discover further:</p>\n<pre><code>g++ -Wall -c main.cpp\ng++ -Wall -c classes.cpp\ng++ -Wall main.o classes.o -o app_bug\ng++ -Wall classes.o main.o -o app_ok\n</code></pre>\n<p>It looks like the destructor is being called in one of two possible cases, and it depends on the linking order. With app_ok I was able to get the correct scenario, while app_bug behaved exactly like my application.</p>\n<p>Is there any bit of wisdom I am missing in this situation?\nThanks for any suggestion in advance!</p>\n", "AcceptedAnswerId": "12323721", "Title": "C++ destructor not being called, depending on the linking order", "CreationDate": "2012-09-07T17:51:03.130", "Id": "12323028", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-09-07T20:12:36.720", "Score": "3", "OwnerUserId": "411907", "Tags": "<c++><gcc><destructor>", "AnswerCount": "4"}, "12323721": {"Id": "12323721", "PostTypeId": "2", "Body": "<p>The goal of the pimpl idiom is to not have to expose a definition of the implementation class in the header file.  But all the standard smart pointers require a definition of their template parameter to be visible <em>at the point of declaration</em> in order to work correctly.</p>\n<p>That means this is one of the rare occasions where you actually want to use <code>new</code>, <code>delete</code>, and a bare pointer.  (If I'm wrong about this and there's a <em>standard</em> smart pointer that can be used for pimpl, someone please let me know.)</p>\n<h3>classes.h</h3>\n<pre><code>struct Cimpl;\n\nstruct Cpimpl\n{\n    Cpimpl();\n    ~Cpimpl();\n\n    // other public methods here\n\nprivate:\n    Cimpl *ptr;\n\n    // Cpimpl must be uncopyable or else make these copy the Cimpl\n    Cpimpl(const Cpimpl&amp;);\n    Cpimpl&amp; operator=(const Cpimpl&amp;);\n};\n</code></pre>\n<h3>classes.cpp</h3>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct Cimpl\n{\n    Cimpl()\n    {\n        puts(\"Cimpl::Cimpl()\");\n    }\n    ~Cimpl()\n    {\n        puts(\"Cimpl::~Cimpl()\");\n    }\n\n    // etc\n};\n\nCpimpl::Cpimpl() : ptr(new Cimpl) {}\nCpimpl::~Cpimpl() { delete ptr; }\n\n// etc\n</code></pre>\n", "LastEditorUserId": "388520", "LastActivityDate": "2012-09-07T20:12:36.720", "Score": "1", "CreationDate": "2012-09-07T18:46:23.753", "ParentId": "12323028", "CommentCount": "5", "OwnerUserId": "388520", "LastEditDate": "2012-09-07T20:12:36.720"}, "bq_ids": {"n4140": {"so_12323028_12323818_0": {"length": 16, "quality": 1.0, "section_id": 6109}}, "n3337": {"so_12323028_12323818_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_12323028_12323818_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "12323818": {"Id": "12323818", "PostTypeId": "2", "Body": "<p>The problem is that at the point of the definition of the  <code>auto_ptr&lt;Cimpl&gt;</code> object, <code>Cimpl</code> is an incomplete type, that is, the compiler has only seen a forward declaration of <code>Cimpl</code>. That's okay, but since it eventually deletes the object that it holds a pointer to, you have to comply with this requirement, from [expr.delete]/5:</p>\n<blockquote>\n<p id=\"so_12323028_12323818_0\">If the object being deleted has incomplete class type at the point of\n  deletion and the complete class has a non-trivial destructor or a\n  deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>So this code runs into undefined behavior, and all bets are off.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2012-09-07T19:05:30.140", "Score": "1", "CreationDate": "2012-09-07T18:52:09.387", "ParentId": "12323028", "CommentCount": "0", "OwnerUserId": "1593860", "LastEditDate": "2012-09-07T19:05:30.140"}, "12323337": {"Id": "12323337", "PostTypeId": "2", "Body": "<p>The code violates the One Definition Rule. There's a definition of the class <code>Cimpl</code> in classes.h, and a different definition of the class <code>Cimpl</code> in the file classes.cpp. The result is undefined behavior. It's okay to have more than one definition of a class, but they must be the same.</p>\n", "LastActivityDate": "2012-09-07T18:14:27.987", "CommentCount": "7", "CreationDate": "2012-09-07T18:14:27.987", "ParentId": "12323028", "Score": "0", "OwnerUserId": "1593860"}});