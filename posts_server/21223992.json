post_cb({"21223992": {"CommentCount": "9", "ViewCount": "256", "PostTypeId": "1", "LastEditorUserId": "85371", "CreationDate": "2014-01-19T23:19:44.067", "LastActivityDate": "2014-01-19T23:42:57.647", "Title": "This warning in clang and gcc doesn't seem to be correct", "AcceptedAnswerId": "21224099", "LastEditDate": "2014-01-19T23:24:59.163", "Id": "21223992", "Score": "4", "Body": "<p>I believe the example below in page 66 of Bjarne Stroutrup's new book, TCPL 4th edition, has a minor error, as the <code>class Vector_container</code> doesn't have an <code>std::initializer_list</code> constructor. The error message <a href=\"http://coliru.stacked-crooked.com/a/87350171f02c5b97\" rel=\"nofollow\">here</a> confirms this.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Vector{\n    double* elem;\n    int sz;\npublic:\n    Vector(int s):elem{new double[s]}, sz{s} { for(int i = 0; i != sz; ++i) elem[i]= 0; }\n    Vector(std::initializer_list&lt;double&gt; lst): elem{new double[lst.size()]}, sz(lst.size()) { std::copy(lst.begin(), lst.end(), elem); }\n    ~Vector() { delete[] elem; }\n    double&amp; operator[](int i) { return elem[i]; }\n    int size() const { return sz; }\n};\n\nclass Container{\npublic:\n    virtual double&amp; operator[](int i) = 0;\n    virtual int size() const = 0;\n    virtual ~Container() {}\n};\n\nclass Vector_container:public Container{\n    Vector v;\npublic:\n    Vector_container(int s): v{s}{}\n    ~Vector_container() {}\n    double&amp; operator[](int i) { return v[i]; }\n    int size() const {return v.size(); }\n};\n\nvoid use(Container&amp; c)\n{\n    const int sz = c.size();\n    for(int i = 0; i != sz; i++) std::cout &lt;&lt; c[i] &lt;&lt; '\\n';\n}\n\nint main()\n{\n    Vector_container vc{10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n    use(vc);\n}\n</code></pre>\n<p>But the warning emitted for the expression <code>v{s}</code> in the member-initializer list for the <code>Vector_container(int)</code> constructor surprised me, as it says: <code>warning: narrowing conversion of 's' from 'int' to 'double' inside { }</code>, which doesn't seem to be correct, as there's no narrowing in this case.</p>\n<p>Also, if you change the expression <code>Vector_container vc{10, ..., 1};</code> in <code>main()</code> to <code>Vector_container vc{10};</code> the error message disappears, as expected, but the warning continues to show off. Nonetheless the <code>std::initializer-list</code> constructor for the <code>Vector</code> class is chosen by the compiler, and I presume this to be correct, according to 13.3.1.7/1 in the Standard. </p>\n<p>Thus, I wonder <strong>if there's any way to impose the invoking of the <code>Vector(int)</code> constructor, instead of the initializer-list ctor</strong> in the <code>Vector</code> class, in this last example with <code>Vector_container vc{10};</code>.</p>\n", "Tags": "<c++><c++11><constructor><initializer-list>", "OwnerUserId": "2548699", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21223992_21224099_1": {"section_id": 3327, "quality": 1.0, "length": 6}}, "n3337": {"so_21223992_21224099_1": {"section_id": 3197, "quality": 1.0, "length": 6}}, "n4659": {"so_21223992_21224099_1": {"section_id": 4093, "quality": 1.0, "length": 6}}}, "21224099": {"ParentId": "21223992", "LastEditDate": "2014-01-19T23:42:57.647", "CommentCount": "4", "CreationDate": "2014-01-19T23:34:18.440", "OwnerUserId": "420683", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "21224099", "Score": "4", "Body": "<p>You're correct about the overload resolution: Inside</p>\n<pre><code>Vector_container(int s): v{s}{}\n</code></pre>\n<p>the initialization <code>v{s}</code> selects the following constructor:</p>\n<pre><code>Vector(std::initializer_list&lt;double&gt; lst)\n</code></pre>\n<p>as per [over.match.list]/1.</p>\n<p>When the <code>std::initializer_list&lt;double&gt;</code> is created from <code>{s}</code>, where <code>s</code> is of type <code>int</code>, there is a narrowing conversion from <code>int</code> to <code>double</code> (n3485) [dcl.init.list]/7</p>\n<blockquote>\n<p id=\"so_21223992_21224099_0\">A narrowing conversion is an implicit conversion</p>\n<ul>\n<li>[...]</li>\n<li>from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will\n  produce the original value when converted back to the original type, or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Note that <code>s</code> here is not a constant expression any more (being a parameter). Narrowing conversions may not appear in the construction of an <code>std::initializer_list</code> object, [dcl.init.list]/5</p>\n<blockquote>\n<p id=\"so_21223992_21224099_1\">If a narrowing conversion\n  is required to initialize any of the elements, the program is ill-formed.</p>\n</blockquote>\n<p>So that warning should be an error (or it's an extension).</p>\n<hr>\n<blockquote>\n<p id=\"so_21223992_21224099_2\">Thus, I wonder if there's any way to impose the invoking of the <code>Vector(int)</code> constructor, instead of the initializer-list ctor in the <code>Vector</code> class.</p>\n</blockquote>\n<p>I'm not sure if I understood you correctly (see comments to OP), but not using list-init here solves the problem:</p>\n<pre><code>Vector_container(int s): v(s) {}  // initializer-list ctor not viable\n</code></pre>\n</hr>", "LastActivityDate": "2014-01-19T23:42:57.647"}});