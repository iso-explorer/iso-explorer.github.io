post_cb({"bq_ids": {"n4140": {"so_3823033_3823454_2": {"length": 17, "quality": 0.6071428571428571, "section_id": 3890}, "so_3823033_3823454_0": {"length": 24, "quality": 0.5217391304347826, "section_id": 3890}}, "n3337": {"so_3823033_3823454_2": {"length": 21, "quality": 0.75, "section_id": 3750}, "so_3823033_3823454_0": {"length": 43, "quality": 0.9347826086956522, "section_id": 3750}}, "n4659": {"so_3823033_3823454_2": {"length": 17, "quality": 0.6071428571428571, "section_id": 4776}, "so_3823033_3823454_0": {"length": 24, "quality": 0.5217391304347826, "section_id": 4776}}}, "3823454": {"Id": "3823454", "PostTypeId": "2", "Body": "<p><code>case</code> condition expression must be of integral type, or convertible to integral type, and must be const.</p>\n<h2>6.4.2 [stmt.switch]</h2>\n<blockquote>\n<p id=\"so_3823033_3823454_0\">The condition shall be of integral\n  type, enumeration type, or of a class\n  type for which a single conversion\n  function to integral or enumeration\n  type exists (12.3). If the condition\n  is of class type, the condition is\n  converted by calling that conversion\n  function, and the result of the\n  conversion is used in place of the\n  original condition for the remainder\n  of this section. Integral promotions\n  are performed. Any statement within\n  the switch statement can be labeled\n  with one or more case labels as\n  follows:</p>\n<p id=\"so_3823033_3823454_1\">case constant-expression :</p>\n<p id=\"so_3823033_3823454_2\">where the constant-expression shall be\n  an integral constant-expression. The\n  integral constant-expression (5.19) is\n  implicitly converted to the promoted\n  type of the switch condition. No two\n  of the case constants in the same\n  switch shall have the same value after\n  conversion to the promoted type of the\n  switch condition.</p>\n</blockquote>\n<p>Your expression isn't a constant expression, even though the variable itself is <code>const</code>, so you can't switch on it.  You'll need to use an <code>if</code>.</p>\n<p>You have another problem though:</p>\n<p>You create a <code>union</code>,</p>\n<pre><code>union CharUInt  \n{  \n    char sz[4];  \n    unsigned int u;  \n};\n</code></pre>\n<p>...then you initialize the <code>sz</code> member of that union,</p>\n<pre><code>static const CharUInt Mask1 = {'\\x81', '\\x0', '\\x0', '\\x81'};  \n</code></pre>\n<p>...and then you access the <code>u</code> member of that union.</p>\n<pre><code>static const unsigned int uMask1 = Mask1.u;  \n</code></pre>\n<p>This evokes undefined behavior according to the standard.  In the language of the Standard, 2 members of a union can't be active at one time.  Meaning you can't treat a union like a caster.  </p>\n", "LastActivityDate": "2010-09-29T16:01:21.420", "CommentCount": "1", "CreationDate": "2010-09-29T16:01:21.420", "ParentId": "3823033", "Score": "1", "OwnerUserId": "241536"}, "3823033": {"ViewCount": "15908", "Body": "<p>this is a strange one...</p>\n<p>I am playing with some decompression algo. Instead of going through the <code>char buffer[]</code> and looping until a stop-bit in  <code>buffer[i]</code> is found, I am trying use some bit-mask techniques but with chars.</p>\n<p>I have the following example:  </p>\n<pre><code>// In a *.h file  \nconst char ch = '\\x81';  \n// To avoid Endianess  \nunion CharUInt  \n{  \n    char sz[4];  \n    unsigned int u;  \n};  \n// Legal because char[] is declared before uint32 in the union  \nconst CharUInt Mask1 = {'\\x81', '\\x0', '\\x0', '\\x81'};  \nconst CharUInt Mask2 = {'\\x0', '\\x81', '\\x81', '\\x0'};  \n// Proxy / Auxillary uint32 as usimg Mask2.u in the switch blocked produced the same errors  \nconst unsigned int uMask1 = Mask1.u;  \nconst unsigned int uMask2 = Mask2.u;  \nconst unsigned int uMask_ = (uMask1 &amp; uMask2);  \n// buf is always long enough  \nbool Foo(char buf[])  \n{  \n    const CharUInt Type = {buf[0], buf[1], buf[2], buf[3]};  \n    unsigned int uType = (Type.u &amp; uMask_);  \n    switch(uType)  \n    {  \n    case uMask1:  \n        // do stuff  \n    case uMask2:    \n        // do more stuff  \n        return true;  \n        break;  \n    default:  \n        // do different stuff  \n        return false;  \n        break;  \n    }  \n};  \n</code></pre>\n<p>Without considering the syntax of the <code>union</code> stuff (the actual code compiles run fine for that) and without considering whether the function-return for <code>Foo</code> is pretty, I get<br>\n<code>'uMask1' cannot appear in a constant-expression</code><br>\nand if the unions themselves are used, I get<br>\n<code>'Mask1' cannot appear in a constant-expression</code><br>\n<code>'.' cannot appear in a constant-expression</code><br>\nand of course the errors also apply for uMask2 and Mask2.u</br></br></br></br></br></p>\n<p>What am I missing?</p>\n<p>Thanks in advance</p>\n", "Title": "Switch error:: cannot appear in a constant-expression", "CreationDate": "2010-09-29T15:20:18.273", "LastActivityDate": "2010-09-29T16:48:01.417", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-09-29T16:48:01.417", "LastEditorUserId": "461912", "Id": "3823033", "Score": "6", "OwnerUserId": "461912", "Tags": "<c++><compiler-errors><switch-statement>", "AnswerCount": "2"}, "3823433": {"Id": "3823433", "PostTypeId": "2", "Body": "<p>The confusion comes from the fact that const and const are two.</p>\n<p>The case's in the switch statement need 'constant expressions'.  Or in other words: expressions that can be 'calculated' by the compiler, at compile-time.\nThis could be a hard-coded number (like 42), or something that has been defined before as a number (using #define).</p>\n<p>Const is also used by the compiler with the meaning \"once this variable has a value, it won't change anymore\".  E.g. in the following code:</p>\n<pre><code>void myFunction (const int value)\n{\n...\n}\n</code></pre>\n<p>value will be const.  I will not be able to change the value of const, but this does not make it a 'constant expression' for the compiler.</p>\n<p>In your case, uMask1 is const (can't change it anymore) but not a constant expression.</p>\n", "LastActivityDate": "2010-09-29T15:59:11.690", "CommentCount": "2", "CreationDate": "2010-09-29T15:59:11.690", "ParentId": "3823033", "Score": "6", "OwnerUserId": "163551"}});