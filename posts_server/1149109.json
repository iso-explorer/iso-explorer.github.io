post_cb({"1149207": {"ParentId": "1149109", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Pointers have an implicit conversion to <code>bool</code>. Perhaps you have seen the following:</p>\n<pre><code>void myFunc(int* a)\n{\n    if (a)\n        ++(*a);\n}\n</code></pre>\n<p>Now, in C++, implicit conversions between built-in types take precedence over conversions between class-types. So for example, if you had a class:</p>\n<pre><code>class Int\n{\npublic:\n    Int(int i) {}\n}\n</code></pre>\n<p>And you overloaded a function for <code>long</code> and <code>Int</code>:</p>\n<pre><code>void test(long n) {cout &lt;&lt; \"long\";}\nvoid test(Int n) {cout &lt;&lt; \"Int\";}\n</code></pre>\n<p>You'll see that the following code calls the long overload:</p>\n<pre><code>int i;\ntest(i);\n</code></pre>\n", "OwnerUserId": "72631", "LastEditorUserId": "72631", "LastEditDate": "2009-07-20T16:13:20.933", "Id": "1149207", "Score": "6", "CreationDate": "2009-07-19T03:54:23.643", "LastActivityDate": "2009-07-20T16:13:20.933"}, "1149112": {"ParentId": "1149109", "CommentCount": "1", "Body": "<p>My guess is the conversion from pointer to bool is an implicit primitive type conversion, where the conversion to <code>std::string</code> requires the call of a constructor and the construction of a temporary.</p>\n", "OwnerUserId": "138304", "PostTypeId": "2", "Id": "1149112", "Score": "14", "CreationDate": "2009-07-19T02:38:59.553", "LastActivityDate": "2009-07-19T02:38:59.553"}, "1149311": {"ParentId": "1149109", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In your case you have has overloaded functions. Overloading resolution occurs according to Section 13.3.</p>\n<p><strong>C++03 13.3.3.2/2:</strong></p>\n<blockquote>\n<p id=\"so_1149109_1149311_0\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)<br>\n  \u2014  a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and<br>\n  \u2014  a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</br></br></p>\n</blockquote>\n<p>Conversion pointer into bool is a standard conversion. Conversion pointer into std::string is a user-defined conversion.</p>\n<blockquote>\n<p id=\"so_1149109_1149311_1\"><strong>4.12 Boolean conversions</strong>\n  An rvalue of arithmetic, enumeration, <strong>pointer</strong>, or pointer to member type can be converted to an rvalue of type <strong>bool</strong>.  A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.</p>\n</blockquote>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-07-19T06:23:03.717", "Id": "1149311", "Score": "9", "CreationDate": "2009-07-19T05:53:20.983", "LastActivityDate": "2009-07-19T06:23:03.717"}, "1149109": {"CommentCount": "0", "AcceptedAnswerId": "1149112", "CreationDate": "2009-07-19T02:36:38.903", "LastActivityDate": "2009-07-20T16:13:20.933", "PostTypeId": "1", "ViewCount": "1612", "FavoriteCount": "3", "Title": "Why does a quoted string match bool method signature before a std::string?", "Id": "1149109", "Score": "14", "Body": "<p>Given the following methods:</p>\n<pre><code>// Method 1\nvoid add(const std::string&amp; header, bool replace);\n\n//Method 2\nvoid add(const std::string&amp; name, const std::string&amp; value);\n</code></pre>\n<p>It would appear that the following code will end up calling method 1 instead of method 2:</p>\n<pre><code>something.add(\"Hello\", \"World\");\n</code></pre>\n<p>I ended up creating another method that looks like this:</p>\n<pre><code>//Method 3\nvoid MyClass::add(const char* name, const char* value) {\n    add(std::string(name), std::string(value));\n}\n</code></pre>\n<p>It worked. So it would seem that when a method accepts a \"quoted string\" it will match in the following order:</p>\n<ol>\n<li><code>const char*</code></li>\n<li><code>bool</code></li>\n<li><code>std::string</code></li>\n</ol>\n<p>Why would a quoted string be treated as a <code>bool</code> before a <code>std::string</code>? Is this the usual behavior? I have written a decent amount of code for this project and haven't had any other issues with the wrong method signature being selected...</p>\n", "Tags": "<c++><string><arguments><boolean>", "OwnerUserId": "50453", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_1149109_1149311_1": {"section_id": 44, "quality": 0.8333333333333334, "length": 25}, "so_1149109_1149311_0": {"section_id": 638, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_1149109_1149311_1": {"section_id": 41, "quality": 0.8333333333333334, "length": 25}, "so_1149109_1149311_0": {"section_id": 628, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_1149109_1149311_1": {"section_id": 45, "quality": 0.8333333333333334, "length": 25}, "so_1149109_1149311_0": {"section_id": 666, "quality": 0.8823529411764706, "length": 30}}}});