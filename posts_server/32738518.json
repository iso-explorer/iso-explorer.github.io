post_cb({"32739682": {"ParentId": "32738518", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>IMHO, you have formal Undefined Behaviour, because you always access the a part of the unions, even if last written was b.</p>\n<p>Of course it works, because except for its management, a unique_ptr just contains a raw pointer and a stored deleter. Pointers to any type have same representation, and except for alignement question, it is safe to convert a pointer to X to a pointer to Y and back. So <em>at low level</em> if is safe to swap raw pointers. It could be more implementation dependant, but I assume it is also safe to swap stored deleters, because what is actually stored is normally an address. And anyway, for types <code>struct A</code> and <code>struct B</code>, the destructors are simply no-op.</p>\n<p>The only thing that could cause you code fail, would be if the compiler enforced the rule that only last written member of an union can be accessed, except for the common initial subsequence. For current compilers, I am pretty sure that none enforce that, so it should work.</p>\n<p>But in a question that I once ask about <a href=\"https://stackoverflow.com/a/30383876\">another possible UB case</a>, Hans Passant gave a <a href=\"http://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201503-asplos2015-cheri-cmachine.pdf\" rel=\"nofollow noreferrer\">link</a> to research work on advanced compilers able to detect buffer overflows. I really think that same technics could be used to enforce rules on access to union members, so such compilers could raise exception at run-time with your code.</p>\n<p>TL/DR: this code should work with all current known compilers, but as is is not strictly standard conformant, future compilers could trap with it. As such I call this <em>formal undefined behaviour</em>.</p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:10.920", "Id": "32739682", "Score": "1", "CreationDate": "2015-09-23T12:30:20.837", "LastActivityDate": "2015-09-23T12:30:20.837"}, "32738518": {"CommentCount": "4", "ViewCount": "227", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2015-09-23T11:36:03.733", "LastActivityDate": "2015-09-23T12:40:29.367", "Title": "swap non-active std::unique_ptr data members for union", "AcceptedAnswerId": "32739887", "LastEditDate": "2015-09-23T11:59:09.780", "Id": "32738518", "Score": "0", "Body": "<p>Given a union:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include &lt;cassert&gt;\n#include &lt;cstdlib&gt;\n\nstruct A { int a; };\nstruct B { int b; };\n\ntemplate&lt; typename X &gt;\nstruct S\n{\n\n    std::size_t tag;\n\n    std::unique_ptr&lt; X &gt; x;\n\n};\n\nunion U\n{\n    S&lt; A &gt; a;\n    S&lt; B &gt; b;\n\n    U(A x) : a{0, std::make_unique&lt; A &gt;(x)} { ; }\n    U(B x) : b{1, std::make_unique&lt; B &gt;(x)} { ; }\n\n    std::size_t tag() { return a.tag; }\n\n    ~U()\n    {\n        switch (tag()) {\n        case 0 : {\n            a.~S&lt; A &gt;();\n            break;\n        }\n        case 1 : {\n            b.~S&lt; B &gt;();\n            break;\n        }\n        default : assert(false);\n        }\n    }\n\n    void\n    swap(U &amp; u) noexcept\n    {\n        a.x.swap(u.a.x);\n        std::swap(a.tag, u.a.tag);\n    }\n\n};\n\nstatic_assert(std::is_standard_layout&lt; U &gt;{});\n\nint\nmain()\n{\n    U a{A{ 0}};\n    U b{B{~0}};\n    assert((a.tag() == 0) &amp;&amp; (a.a.x-&gt;a ==  0));\n    assert((b.tag() == 1) &amp;&amp; (b.b.x-&gt;b == ~0));\n    a.swap(b);\n    assert((a.tag() == 1) &amp;&amp; (a.b.x-&gt;b == ~0));\n    assert((b.tag() == 0) &amp;&amp; (b.a.x-&gt;a ==  0));\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p><code>U::tag()</code> funcion is correct due to it permittable to inspect common initial subsequence of alternative data members in <code>U</code>-like unions.</p>\n<p><code>U::swap()</code> works, but is it legal for <code>std::unique_ptr</code>s? Is it allowed to swap non-active <code>std::unique_ptr</code>s alternative data members of <code>U</code>-like unions?</p>\n<p>It seems to be permittable due to simple nature of <code>std::unique_ptr&lt; X &gt;</code>: it is just a wrapper over <code>X *</code> and for any <code>A</code> and <code>B</code> I sure <code>static_assert((sizeof(A *) == sizeof(B *)) &amp;&amp; (alignof(A *) == alignof(B *)));</code> holds and pointers arrangement is identical for all types (except pointers to data members and member functions of classes). Is it true?</p>\n<p>Example code works fine. But very likely there is UB if we read the standard.</p>\n", "Tags": "<c++><c++14><smart-pointers><unique-ptr><discriminated-union>", "OwnerUserId": "1430927", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32738518_32739887_1": {"section_id": 4276, "quality": 0.7916666666666666, "length": 19}, "so_32738518_32739887_2": {"section_id": 7223, "quality": 0.7727272727272727, "length": 17}, "so_32738518_32739887_0": {"section_id": 5913, "quality": 1.0, "length": 34}}, "n3337": {"so_32738518_32739887_1": {"section_id": 4117, "quality": 0.7916666666666666, "length": 19}, "so_32738518_32739887_0": {"section_id": 5685, "quality": 1.0, "length": 34}, "so_32738518_32739887_2": {"section_id": 6967, "quality": 0.7727272727272727, "length": 17}}, "n4659": {"so_32738518_32739887_1": {"section_id": 5532, "quality": 0.7916666666666666, "length": 19}, "so_32738518_32739887_2": {"section_id": 8732, "quality": 0.6363636363636364, "length": 14}, "so_32738518_32739887_0": {"section_id": 7404, "quality": 0.9705882352941176, "length": 33}}}, "32739887": {"ParentId": "32738518", "CommentCount": "1", "Body": "<p>from\n<code>\u00a7 9.5 Unions</code></p>\n<p>specifically the note about standard layout types:</p>\n<blockquote>\n<p id=\"so_32738518_32739887_0\">... One special guarantee\n  is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout\n  structs that share a common initial sequence (9.2), and if an object of this standard-layout union type\n  contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of\n  standard-layout struct members ...</p>\n</blockquote>\n<p>So the common initial sequence is allowed to be used for either union member.</p>\n<p>In your case the common initial sequence is definitely <code>std::size_t tag</code>. Then we need to know if <code>std::unique_ptr&lt;T&gt;</code> will be the same for all <code>T</code> so it can also be treated as part of the common initial sequence:</p>\n<blockquote>\n<p id=\"so_32738518_32739887_1\">\u00a7 20.8.1 Class template <code>unique_ptr</code><br>\n  [1] A unique pointer is an object that owns another object and manages that other object through a pointer.\n  More precisely, a unique pointer is an object <code>u</code> that stores a pointer to a second object <code>p</code> ...</br></p>\n</blockquote>\n<p>Yep. But how do we know all pointers will be represented the same? Well, in your case:</p>\n<blockquote>\n<p id=\"so_32738518_32739887_2\">\u00a7 3.9.2 Compound types<br>\n  [ 3 ] ... The value representation of pointer types\n  is implementation-defined. Pointers to cv-qualified and cv-unqualified versions (3.9.3) of layout-compatible\n  types shall have the same value representation and alignment requirements ...</br></p>\n</blockquote>\n<p>So we can rely on the value of the pointer stored in <code>std::unique_ptr</code> being value representable in the other member of the union.</p>\n<p>So no, no undefined behaviour here.</p>\n", "OwnerUserId": "2297448", "PostTypeId": "2", "Id": "32739887", "Score": "1", "CreationDate": "2015-09-23T12:40:29.367", "LastActivityDate": "2015-09-23T12:40:29.367"}});