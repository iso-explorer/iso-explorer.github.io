post_cb({"bq_ids": {"n4140": {"so_32813694_32813750_0": {"length": 10, "quality": 1.0, "section_id": 381}, "so_32813694_32813750_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 382}}, "n3337": {"so_32813694_32813750_0": {"length": 10, "quality": 1.0, "section_id": 372}, "so_32813694_32813750_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 373}}, "n4659": {"so_32813694_32813750_0": {"length": 9, "quality": 0.9, "section_id": 396}, "so_32813694_32813750_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 397}}}, "32813694": {"ViewCount": "83", "Body": "<p>In the below code snippet...  is it safe to store a reference to the temporary string returned by <code>Quote::toXML</code> in <code>ToXML::s_</code> member variable, at least as long as it is used with the <code>&lt;&lt;</code> operator only?  I.e. is the result of the sub-expression <code>q.toXML</code> alive until the next <code>;</code>?</p>\n<p>And what is the full expression here w.r.t. the return value of <code>q.toXML</code>.  The entire <code>std::cout</code> or the call to <code>ToXML</code> constructor ?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct ToXML\n{\n    ToXML(char const * const tag, std::string const &amp; s) : tag_(tag), s_(s)\n    {\n    }\n\n    char const * tag_;\n    std::string const &amp; s_;\n};\n\nstd::ostream &amp; operator &lt;&lt; (std::ostream &amp; os, ToXML const &amp; v)\n{\n    return os &lt;&lt; \"&lt;\" &lt;&lt; v.tag_ &lt;&lt; \"&gt;\" &lt;&lt; v.s_ &lt;&lt; \"&lt;/\" &lt;&lt; v.tag_ &lt;&lt; \"&gt;\";\n}\n\nstruct Quote\n{\n    std::string toXML() const\n    {\n        return \"&lt;Quote/&gt;\";\n    }\n};\n\nint main()\n{\n    Quote q;\n    std::cout &lt;&lt; ToXML(\"quote\", q.toXML()) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "32813750", "Title": "Another c++ temporary lifetime confusion", "CreationDate": "2015-09-27T22:55:23.030", "Id": "32813694", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-09-27T23:01:06.553", "LastEditorUserId": "4532037", "LastActivityDate": "2015-09-27T23:04:24.107", "Score": "2", "OwnerUserId": "4532037", "Tags": "<c++>", "AnswerCount": "1"}, "32813750": {"Id": "32813750", "PostTypeId": "2", "Body": "<p>Yes, it is safe. </p>\n<p>From [class.temp]:</p>\n<blockquote>\n<p id=\"so_32813694_32813750_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. [...] </p>\n<p id=\"so_32813694_32813750_1\">The second context is when a reference is bound to a temporary.117 The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference except:<br>\n  \u2014 A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion\n  of the full-expression containing the call.</br></p>\n</blockquote>\n<p>We're in that bullet point. The temporary object is bound to a reference parameter (<code>s</code>) and persists until the completion of the full-expression containing the call. That is, it persists until</p>\n<pre><code>std::cout &lt;&lt; ToXML(\"quote\", q.toXML()) &lt;&lt; std::endl;\n// --- here ---------------------------------------^\n</code></pre>\n<p>Since it lasts throughout its usage, it is perfectly safe. However, as soon as you do something like:</p>\n<pre><code>ToXML x(\"quote\", q.toXML());\n</code></pre>\n<p>you're stuck with a dangling reference, so I would use this pattern sparingly. </p>\n", "LastActivityDate": "2015-09-27T23:04:24.107", "CommentCount": "0", "CreationDate": "2015-09-27T23:04:24.107", "ParentId": "32813694", "Score": "2", "OwnerUserId": "2069064"}});