post_cb({"bq_ids": {"n4140": {"so_32373979_32373979_5": {"length": 11, "quality": 1.0, "section_id": 323}, "so_32373979_32373979_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 322}, "so_32373979_32373979_2": {"length": 11, "quality": 1.0, "section_id": 322}, "so_32373979_32375678_3": {"length": 10, "quality": 1.0, "section_id": 327}, "so_32373979_32375678_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 603}, "so_32373979_32373979_8": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}, "so_32373979_32373979_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 322}, "so_32373979_32375678_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}, "so_32373979_32373979_6": {"length": 60, "quality": 0.967741935483871, "section_id": 327}, "so_32373979_32373979_3": {"length": 9, "quality": 1.0, "section_id": 322}}, "n3337": {"so_32373979_32373979_5": {"length": 11, "quality": 1.0, "section_id": 313}, "so_32373979_32373979_2": {"length": 11, "quality": 1.0, "section_id": 312}, "so_32373979_32373979_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 312}, "so_32373979_32373979_8": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}, "so_32373979_32375678_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 593}, "so_32373979_32375678_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}, "so_32373979_32373979_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_32373979_32373979_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_32373979_32373979_6": {"length": 60, "quality": 0.967741935483871, "section_id": 317}, "so_32373979_32375678_3": {"length": 10, "quality": 1.0, "section_id": 317}}, "n4659": {"so_32373979_32373979_5": {"length": 11, "quality": 1.0, "section_id": 331}, "so_32373979_32373979_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 330}, "so_32373979_32375678_4": {"length": 20, "quality": 0.9090909090909091, "section_id": 337}, "so_32373979_32373979_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 330}, "so_32373979_32373979_8": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}, "so_32373979_32375678_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 629}, "so_32373979_32373979_2": {"length": 11, "quality": 1.0, "section_id": 330}, "so_32373979_32373979_3": {"length": 9, "quality": 1.0, "section_id": 330}, "so_32373979_32375678_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}, "so_32373979_32373979_6": {"length": 48, "quality": 0.7741935483870968, "section_id": 335}, "so_32373979_32375678_3": {"length": 8, "quality": 0.8, "section_id": 335}}}, "32375678": {"Id": "32375678", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32373979_32375678_0\">Why <code>f(1, 2, 3);</code> calls #2?</p>\n</blockquote>\n<p>There's a lot of questions in your question (one question per question please!), so I will stick to that one. First, we perform template deduction. #3 fails, but #1 and #2 succeed:</p>\n<pre><code>template&lt;class... Args&gt;\nvoid f(Args... args);        // #1, with Args = {int, int, int}\ntemplate&lt;class T1, class... Args&gt; \nvoid f(T1 a1, Args... args); // #2, with T1 = int, Args = {int, int}\n</code></pre>\n<p>Both functions take three <code>int</code>s by value, so all the normal tiebreakers in overload resolution fail to resolve the ambiguity. So we get to the very last one: </p>\n<blockquote>\n<p id=\"so_32373979_32375678_1\">Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function <code>F2</code> if for all arguments <code>i</code>, ICS<sub>i</sub>(<code>F1</code>) is not a worse conversion sequence than ICS<sub>i</sub>(<code>F2</code>), and then<br>\n  \u2014 [...]<br>\n  \u2014 <code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</br></br></p>\n</blockquote>\n<p>The rules are:</p>\n<p><strong>Step 1</strong>: synthesize types [temp.func.order]:</p>\n<blockquote>\n<p id=\"so_32373979_32375678_2\">To produce the transformed template, for each type, non-type, or template template parameter (including\n  template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively\n  and substitute it for each occurrence of that parameter in the function type of the template.</p>\n</blockquote>\n<p>So we have: </p>\n<pre><code>void f(Pack1... args);         // #1\nvoid f(U2 a1, Pack2... args);  // #2\n</code></pre>\n<p><strong>Step 2</strong>: perform deduction as described in [temp.deduct.partial]. The context we're in is a function call, so we use the types for which the function call has arguments. </p>\n<p>First, we try to deduce #2 from #1. That is, we try to match (<code>T1, Args...</code>) against <code>(Pack1...)</code>. The first part is then <code>P = T1, A = Pack1...</code>. We have:</p>\n<blockquote>\n<p id=\"so_32373979_32375678_3\">If A was transformed from a function parameter pack and P is not a parameter pack, type deduction fails.</p>\n</blockquote>\n<p>So deducing #2 from #1 fails, so the argument <code>Args...</code> is not at least as specialized as <code>T1, Args...</code>. </p>\n<p>Next, we try to deduce #1 from #2. That is, we try to match <code>(Args...)</code> against <code>(U2, Pack2...)</code>. That succeeds, so <code>T1, Args...</code> is at least as specialized as <code>Args...</code>.</p>\n<p>Since #2 is at least as specialized as #1 and #1 is not at least as specialized as #2, we can say that #2 is more specialized:</p>\n<blockquote>\n<p id=\"so_32373979_32375678_4\">Function template <code>F</code> is at least as specialized as function template <code>G</code> if, for each pair of types used to\n  determine the ordering, the type from <code>F</code> is at least as specialized as the type from <code>G</code>. <code>F</code> is more specialized\n  than <code>G</code> if <code>F</code> is at least as specialized as <code>G</code> and <code>G</code> is not at least as specialized as <code>F</code>.</p>\n</blockquote>\n<p>The more specialized template is preferred, so we call #2.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-09-04T00:43:38.170", "Score": "3", "CreationDate": "2015-09-03T12:29:48.033", "ParentId": "32373979", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-09-04T00:43:38.170"}, "32373979": {"ViewCount": "158", "Body": "<blockquote>\n<p id=\"so_32373979_32373979_0\">N4527 14.8.2.4 [temp.deduct.partial]</p>\n<p id=\"so_32373979_32373979_1\">3 The types used to determine the ordering depend on the context in which the partial ordering is done:</p>\n<p id=\"so_32373979_32373979_2\">(3.1) \u2014 In the context of a function call, the types used are those function parameter types for which the function call has arguments.</p>\n<p id=\"so_32373979_32373979_3\">(3.2) \u2014 In the context of a call to a conversion function, the return types of the conversion function templates are used.</p>\n<p id=\"so_32373979_32373979_4\">(3.3) \u2014 In other contexts (14.5.6.2) the function template\u2019s function type is used.</p>\n<p id=\"so_32373979_32373979_5\">4 Each type nominated above from the parameter template and the corresponding type from the argument\n  template are used as the types of <code>P</code> and <code>A</code>.</p>\n<p id=\"so_32373979_32373979_6\">8 If <code>A</code> was transformed from a function parameter pack and <code>P</code> is not a parameter pack, type deduction fails.\n  Otherwise, using the resulting types <code>P</code> and <code>A</code>, the deduction is then done as described in 14.8.2.5. If <code>P</code>\n  is a function parameter pack, the type <code>A</code> of each remaining parameter type of the argument template is\n  compared with the type <code>P</code> of the declarator-id of the function parameter pack. Each comparison deduces\n  template arguments for subsequent positions in the template parameter packs expanded by the function\n  parameter pack. If deduction succeeds for a given type, the type from the argument template is considered\n  to be at least as specialized as the type from the parameter template. \n  [ Example:</p>\n</blockquote>\n<pre><code>template&lt;class... Args&gt;           void f(Args... args);        // #1\ntemplate&lt;class T1, class... Args&gt; void f(T1 a1, Args... args); // #2\ntemplate&lt;class T1, class T2&gt;      void f(T1 a1, T2 a2);        // #3\n\nf();        // calls #1\nf(1, 2, 3); // calls #2\nf(1, 2);    // calls #3; non-variadic template #3 is more\n            // specialized than the variadic templates #1 and #2\n</code></pre>\n<p>Why <code>f(1, 2, 3);</code> calls #2?</p>\n<p>I need more details including:</p>\n<p>1 Which context is it?</p>\n<p>2 What are the transformed froms?<br> e.g. the transformed from of #1 is <code>void (U)</code> , <code>void (U...)</code> or other form?(<code>U</code> means an unique type)</br></p>\n<blockquote>\n<p id=\"so_32373979_32373979_7\">14.5.6.2 [temp.func.order]/p3</p>\n<p id=\"so_32373979_32373979_8\">To produce the transformed template, for each type, non-type, or template template parameter (including\n  template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively\n  and substitute it for each occurrence of that parameter in the function type of the template.</p>\n</blockquote>\n<p>3 What are the types of <code>P</code> and <code>A</code> used in deduction? e.g </p>\n<pre><code>template &lt;class T&gt; void f(T);\nint a = 1;\nf(a);//P = T, A = int\n</code></pre>\n", "AcceptedAnswerId": "32375678", "Title": "Deducing template arguments during partial ordering when parameters are function parameter pack", "CreationDate": "2015-09-03T11:09:56.167", "Id": "32373979", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-09-03T12:53:15.267", "LastEditorUserId": "2069064", "LastActivityDate": "2015-09-04T00:43:38.170", "Score": "4", "OwnerUserId": "4958516", "Tags": "<c++><templates><c++11><variadic-templates><overload-resolution>", "AnswerCount": "1"}});