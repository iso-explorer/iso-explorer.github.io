post_cb({"7386860": {"ParentId": "7386628", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Temporaies in general last only to the end of the expression that they were created in:</p>\n<pre><code>#include &lt;complex&gt;\n\n\nvoid func()\n{\n    std::complex&lt;int&gt;   a; // Real variable last until the end of scope.\n\n    a = std::complex&lt;int&gt;(1,2) + std::complex&lt;int&gt;(3,4);\n     // ^^^^^^^^^^^^^^^^^^^^^^  Creates a temporary object\n     //                         This is destroyed at the end of the expression.\n     // Also note the result of the addition creates a new temporary object\n     // Then uses the assignment operator to change the variable 'a'\n     // Both the above temporaries and the temporary returned by '+'\n     // are destroyed at ';'\n</code></pre>\n<p>If you create a temporary object and bind it to a reference. You extend its lifespan to the same lifespan of the reference it is bound too.</p>\n<pre><code>    std::complex&lt;int&gt; const&amp; b  = std::complex&lt;int&gt;(5,6);\n                      //           ^^^^^^^^^^^^^^^^ Temporary object\n                      // ^^^^                       Bound to a reference.\n                      //                            Will live as long as b lives \n                      //                            (until end of scope)\n</code></pre>\n<p>The exception to this rule is when the temporary is bound to a reference in a new initializer.</p>\n<pre><code>    S* p1 = new S{ 1, {2,3} };\n    // This is the new C++11 syntax that does the `equivalent off`:\n\n    S* p2 = new S {1, std::pair&lt;int,int&gt;(2,3) };\n                 //   ^^^^^^^^^^^^^^^^^^^^^^^    Temporary object.\n                 //                              This lives until the end of the \n                 //                              expression that belongs to the new.\n                 //                              ie the temporary will be destroyed\n                 //                              when we get to the ';'\n</code></pre>\n<p>But here we are binding the new temporary object to the member </p>\n<p><code>const std::pair&lt;int,int&gt;&amp; mp;</code></p>\n<p>This is a const reference. But the temporary object it is bound to will be destroyed at the ';' in the above expression so mp will be a reference to an object that no longer exists when you try and use it in subsequent expressions.</p>\n<pre><code>}\n</code></pre>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2011-09-12T11:08:53.470", "Id": "7386860", "Score": "7", "CreationDate": "2011-09-12T11:02:38.247", "LastActivityDate": "2011-09-12T11:08:53.470"}, "bq_ids": {"n4140": {"so_7386628_7386628_1": {"section_id": 382, "quality": 0.8333333333333334, "length": 10}, "so_7386628_7386628_2": {"section_id": 382, "quality": 0.75, "length": 12}, "so_7386628_7386628_0": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_7386628_7386628_1": {"section_id": 373, "quality": 0.8333333333333334, "length": 10}, "so_7386628_7386628_2": {"section_id": 373, "quality": 0.75, "length": 12}, "so_7386628_7386628_0": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_7386628_7386628_1": {"section_id": 397, "quality": 0.8333333333333334, "length": 10}, "so_7386628_7386628_0": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_7386628_7386628_2": {"section_id": 397, "quality": 0.6875, "length": 11}}}, "7386628": {"CommentCount": "3", "ViewCount": "231", "PostTypeId": "1", "LastEditorUserId": "2157640", "CreationDate": "2011-09-12T10:41:59.000", "LastActivityDate": "2017-08-03T16:45:27.147", "Title": "Temporaries lifetime in N3290 C++ draft", "AcceptedAnswerId": "7386860", "LastEditDate": "2017-08-03T16:45:27.147", "Id": "7386628", "Score": "3", "Body": "<p>A point from N3290 C++ draft, \u00a7 12.2, 5th point, line 10.</p>\n<blockquote>\n<p id=\"so_7386628_7386628_0\">The second context is when a reference is bound to a temporary. The\n  temporary to which the reference is bound or the temporary that is the\n  complete object of a  subobject to which the reference is bound\n  persists for the lifetime of the  reference except:</p>\n<p id=\"so_7386628_7386628_1\">A temporary bound to a reference in a new-initializer (5.3.4)\n  persists until   the completion of the full-expression containing the\n  new-initializer.     [ Example:</p>\n<pre><code>struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };\nS a { 1, {2,3} };\nS* p = new S{ 1, {2,3} };// Creates dangling reference\n</code></pre>\n<p id=\"so_7386628_7386628_2\">\u2014 end example ]   [ Note: This may introduce a dangling reference,\n  and implementations are    encouraged  to issue a warning in such a\n  case. \u2014 end note ]</p>\n</blockquote>\n<p>This is the added point when compared to C++03. But the example is not understandable for me. Can you please explain this point with any other example?</p>\n<p>I know what dangling references and temporary objects are and that <code>std::pair</code> holds two values of possibly different data types.</p>\n", "Tags": "<c++><c++11><language-lawyer><temporary-objects><dangling-pointer>", "OwnerUserId": "751747", "AnswerCount": "1"}});