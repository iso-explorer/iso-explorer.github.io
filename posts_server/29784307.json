post_cb({"bq_ids": {"n4140": {"so_29784307_29784353_0": {"length": 18, "quality": 1.0, "section_id": 31}}, "n3337": {"so_29784307_29784353_0": {"length": 18, "quality": 1.0, "section_id": 28}}, "n4659": {"so_29784307_29784353_0": {"length": 18, "quality": 1.0, "section_id": 31}}}, "29784307": {"ViewCount": "3083", "Body": "<p>I am trying to convert an unsigned long long to unsigned long. Is the following a correct way to do it?</p>\n<pre><code>unsigned long removeExtraBits2(unsigned long long c) {\n    return (unsigned long) ((c &lt;&lt; 32) &gt;&gt; 32);\n}\n</code></pre>\n<p>If not, can you provide a working example?</p>\n<p>My assumption is that when shifting left, and then back right, the 32 leftmost bits get set to 0.</p>\n<p>Thanks!</p>\n<p>EDIT: The purpose of the conversion is to get rid of the extra bits, 'higher' than the 32nd, effectively keeping only the rightmost 32 bits into an unsigned long.</p>\n", "AcceptedAnswerId": "29784353", "Title": "C++: convert unsigned long long to unsigned long", "CreationDate": "2015-04-21T22:28:50.680", "Id": "29784307", "CommentCount": "5", "LastEditDate": "2015-04-21T22:33:29.870", "PostTypeId": "1", "LastEditorUserId": "2859912", "LastActivityDate": "2015-04-21T23:36:01.503", "Score": "-2", "OwnerUserId": "2859912", "Tags": "<c++><unsigned>", "AnswerCount": "2"}, "29784353": {"Id": "29784353", "PostTypeId": "2", "Body": "<p>Just do a \"plain\" cast (<code>(unsigned long)c</code>, or, if you like verbosity, <code>static_cast&lt;unsigned long&gt;(c)</code>, or even just assign the <code>unsigned long long</code> source value to the <code>unsigned long</code> target variable), the standard guarantees that the extra bits on the left will get truncated.</p>\n<blockquote>\n<p id=\"so_29784307_29784353_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>(C++11, \u00a74.7 \u00b62)</p>\n<p>which, if the source is unsigned (or is signed and in 2's complement arithmetic), is a fancy way to say that the extra bits are truncated.</p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2015-04-21T22:41:41.850", "Score": "7", "CreationDate": "2015-04-21T22:32:22.640", "ParentId": "29784307", "CommentCount": "5", "OwnerUserId": "214671", "LastEditDate": "2015-04-21T22:41:41.850"}, "29785059": {"Id": "29785059", "PostTypeId": "2", "Body": "<p>There are many different processors and operating systems. The <code>unsigned long long</code> is 64-bits almost on everything. The <code>unsigned long</code> is the other story. It is for example <strong>64</strong>-bits on Linux x86-64, <strong>32</strong>-bits on Linux x86-32 and <strong>32</strong>-bits on Windows x86-64 and x86-32. Plain convert may be noop.</p>\n<p>I think this is a safe solution.</p>\n<pre><code>unsigned long removeExtraBits(unsigned long long c) {\n    c %= 0x100000000ULL;\n    return (unsigned long)(c);\n}\n</code></pre>\n<p>Compiler will change <code>%</code> to simple <code>mov</code>.</p>\n", "LastActivityDate": "2015-04-21T23:36:01.503", "CommentCount": "0", "CreationDate": "2015-04-21T23:36:01.503", "ParentId": "29784307", "Score": "0", "OwnerUserId": "260149"}});