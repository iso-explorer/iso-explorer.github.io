post_cb({"17287778": {"CommentCount": "8", "CreationDate": "2013-06-25T01:34:03.023", "PostTypeId": "1", "AcceptedAnswerId": "17288193", "LastEditorUserId": "951423", "LastActivityDate": "2015-01-18T11:49:02.347", "LastEditDate": "2015-01-18T11:49:02.347", "ViewCount": "1434", "FavoriteCount": "1", "Title": "How do I use the class-name inside the class itself as a template argument?", "Id": "17287778", "Score": "8", "Body": "<p>I've got a templated class having two template paramters</p>\n<pre><code>template &lt;class T, class U&gt; class A  /* ... */\n</code></pre>\n<p>and another template class that accepts a template class with two arguments as template parameter.</p>\n<pre><code>template &lt;class T, class U, template&lt;class X, class Y&gt; class Z&gt;\nclass B\n{\n    typedef typename Z&lt;T,U&gt;::pointer pointer;\n};\n</code></pre>\n<p>Is it impossible to create an instance of B in A where Z is A?</p>\n<pre><code>template &lt;class T, class U&gt;\nclass A  \n{\npublic:\n  B&lt;T,U,A&gt; foo (void) // compiler complaining here\n  {\n    B&lt;T,U,A&gt; test; // and here\n    return test;\n  }\n};\n</code></pre>\n<p>A free function doing the same thing isn't problematic at all.</p>\n<pre><code>template&lt;class T, class U&gt;\nB&lt;T, U, A&gt; bar (void)\n{\n    B&lt;T,U,A&gt; test;\n    return test;\n}\n</code></pre>\n<p>In other words: Is there any rule I didn't fell over yet that prevents me from using the name of the class I am in as a template argument?</p>\n<hr>\n<p>The code is:</p>\n<pre><code>template &lt;class T, class U, template&lt;class X, class Y&gt; class Z&gt;\nclass B\n{\n  typedef typename Z&lt;T,U&gt;::pointer pointer;\n};\n\ntemplate &lt;class T, class U&gt;\nclass A \n{\npublic:\n  B&lt;T,U, A&gt; foo (void) \n  {\n    B&lt;T,U,A&gt; test;\n    return test;\n  }\n};\n\ntemplate&lt;class T, class U&gt;\nB&lt;T, U, A&gt; bar (void)\n{\n    B&lt;T,U,A&gt; test;\n    return test;\n}\n\nint main (void)\n{\n return 0;\n}\n</code></pre>\n<p>And the MSVC 2012 compiler gives a <a href=\"http://msdn.microsoft.com/en-us/library/3xwxftta.aspx\" rel=\"nofollow\">Compiler Error 3200</a>.</p>\n<pre><code>'A&lt;T,U&gt;' : invalid template argument for template parameter 'Z', expected a class template\n</code></pre>\n</hr>", "Tags": "<c++><templates>", "OwnerUserId": "951423", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17287778_17288193_1": {"section_id": 179, "quality": 0.9666666666666667, "length": 29}, "so_17287778_17288193_0": {"section_id": 191, "quality": 0.8181818181818182, "length": 9}, "so_17287778_17288193_2": {"section_id": 183, "quality": 1.0, "length": 15}}, "n3337": {"so_17287778_17288193_1": {"section_id": 173, "quality": 0.9666666666666667, "length": 29}, "so_17287778_17288193_0": {"section_id": 185, "quality": 0.8181818181818182, "length": 9}, "so_17287778_17288193_2": {"section_id": 177, "quality": 1.0, "length": 15}}, "n4659": {"so_17287778_17288193_1": {"section_id": 184, "quality": 0.9666666666666667, "length": 29}, "so_17287778_17288193_0": {"section_id": 196, "quality": 0.8181818181818182, "length": 9}, "so_17287778_17288193_2": {"section_id": 188, "quality": 1.0, "length": 15}}}, "17287874": {"ParentId": "17287778", "CommentCount": "1", "Body": "<p>If class A is defined before class B, I'm getting the error: 'B' does not name a type (in other words, B is not defined yet). Is this the error you are getting? It can be fixed either by placing B in front of A, or, if the two are referencing each other, by forward-declaring class B before A like this:</p>\n<pre><code>template &lt;typename T, class U, template&lt;typename X, class Y&gt; class Z&gt; class B;\n</code></pre>\n", "OwnerUserId": "43848", "PostTypeId": "2", "Id": "17287874", "Score": "0", "CreationDate": "2013-06-25T01:45:48.130", "LastActivityDate": "2013-06-25T01:45:48.130"}, "17288193": {"ParentId": "17287778", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your compiler, MSVC, seems to follow the general rule laid down in \u00a714.6.2.1/1 C++11:</p>\n<blockquote>\n<p id=\"so_17287778_17288193_0\">A name refers to the <em>current instantiation</em> if it is, [...] in the definition of a class template, [...] the injected-class name [...] of the class template [...]</p>\n</blockquote>\n<p>Inside the definition of class template <code>A</code>, the name <code>A</code> can be used because it is \"injected\" into the local (class) scope of <code>A</code>. Therefore, and famously, you can use <code>A</code> as well as <code>A::A</code>, as well as <code>A::A::A</code> and so on, to refer to <code>A</code>. By the rule quoted above, all of these expressions refer to the <em>current instantiation</em> (i.e. a specific type like <code>A&lt;int,float&gt;</code>), and not to the name of template <code>A</code> itself.</p>\n<p>However, there is another rule, in \u00a714.6.1/1:</p>\n<blockquote>\n<p id=\"so_17287778_17288193_1\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name can be used as a template-name or a type-name. When it is used [...] as a template-argument for a template template-parameter [...] it refers to the class template itself. Otherwise, it is equivalent to the template-name followed by the template-parameters of the class template enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>(Note that in C++03, there is no such exception for template template parameters; 14.6.1/1, in fact, is worded entirely differently. Under C++03, MSVC's interpretation of the rules was probably correct.)</p>\n<p>Given the C++11 rule, however, in the member declaration</p>\n<pre><code>B&lt;T,U,A&gt; test;\n</code></pre>\n<p>inside the definition of <code>A</code>, the name <code>A</code> is clearly used as an argument for a template template parameter and therefore must be interpreted as template name, not as type name referring to the current instantiation.</p>\n<p>However, it is not uncommon that compilers are confused in situations like this. There are two valid ways to tell them how to interpret <code>A</code>:</p>\n<ol>\n<li><p>Using the so-called <em>normal name</em> <code>::A</code> rather than the injected one:</p>\n<pre><code>B&lt;T,U,::A&gt; test;\n</code></pre>\n<p>This is possible because of \u00a714.6.1/5 (which was 14.6.1/2c in C++03):</p>\n<blockquote>\n<p id=\"so_17287778_17288193_2\">When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name) is used, it always refers to the class template itself and not a specialization of the template. [...]</p>\n</blockquote></li>\n<li><p>Using the injected one explicitly, but designating it as a template:</p>\n<pre><code>B&lt;T,U,A::template A&gt; test;\n</code></pre></li>\n</ol>\n<p>Both methods have been confirmed as solving this problem in MSVC.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-06-25T02:40:19.867", "Id": "17288193", "Score": "9", "CreationDate": "2013-06-25T02:29:51.257", "LastActivityDate": "2013-06-25T02:40:19.867"}});