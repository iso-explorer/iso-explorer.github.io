post_cb({"28928790": {"CreationDate": "2015-03-08T16:19:50.870", "LastActivityDate": "2015-03-08T16:45:20.780", "LastEditorUserId": "3723423", "ParentId": "28928391", "Score": "2", "Id": "28928790", "OwnerUserId": "3723423", "Body": "<p>The concepts of struct are similar in C and C++ although not identical.  The storage of struct members is defined in similar manners in C11: </p>\n<blockquote>\n<p id=\"so_28928391_28928790_0\"><strong>C11 6.7.2.1/6:</strong> a structure is a type consisting of a sequence of members, whose storage is allocated in an ordered sequence</p>\n<p id=\"so_28928391_28928790_1\"><strong>ibid/14:</strong> Each non-bit-field member of a structure or union object is aligned in an implementationdefined manner appropriate to its type.</p>\n<p id=\"so_28928391_28928790_2\"><strong>ibid/15:</strong> Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in\n  the order in which they are declared.</p>\n</blockquote>\n<p>But most of this definition is implementation-defined as in C++.  So you don't have any garantee, that it's the same memory layout.  </p>\n<p>In fact there is even a <strong>fundamental difference: in C the pointer to the first member is always guaranteed to be the address of the struct</strong> object:   </p>\n<blockquote>\n<p id=\"so_28928391_28928790_3\"><strong>C11 6.7.2.1/15</strong>  ... A pointer to a structure object, suitably converted, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides), and vice versa.</p>\n</blockquote>\n<p>In <strong>C++ you don't have such guarantee at all</strong>.  For example, take these two simple C++ structures: </p>\n<pre><code>struct A { int a; }; \nstruct B {\n    int a;\n    virtual void test() { }  // make the struct plymorphic\n};\n</code></pre>\n<p>Depending of your compiler, the address of the struct in this example might not be the same as its first member:  </p>\n<pre><code>A a; B b;\ncout &lt;&lt; \"&amp;a=\" &lt;&lt; (void*)&amp;a &lt;&lt; \" &amp;a.a=\" &lt;&lt; (void*)&amp;a.a &lt;&lt; endl; \ncout &lt;&lt; \"&amp;b=\" &lt;&lt; (void*)&amp;b &lt;&lt; \" &amp;b.a=\" &lt;&lt; (void*)&amp;b.a &lt;&lt; endl;\n</code></pre>\n<p>With MSVC2013 for instance, the address of <code>b.a</code> is four bytes higher than address of <code>b</code>.  This is because the compiler stores at the begin of the object a pointer to a vtable for virtual functions and dynamic type info.  As said, this is implmentation defined.  Just keep in mind that you have no guarantee. </p>\n<p>THis underlines the fac that C concept of struct is different from C++, as there is no constructor and a couple of other subtle semantic differences.   </p>\n<p>In C you don't have the notion of <em>reference</em>.  </p>\n<p>The way references in C++ are handled is implementation defined.  You can think of them as some kind of pointner that dereferences itself, but there is no guarantee that your compiler needs to store anything at all for a reference (it could be in some cases optimized away).  </p>\n", "CommentCount": "0", "PostTypeId": "2", "LastEditDate": "2015-03-08T16:45:20.780"}, "bq_ids": {"n3337": {"so_28928391_28928790_3": {"section_id": 5650, "quality": 0.8333333333333334, "length": 15}}}, "28928391": {"AcceptedAnswerId": "28928790", "Tags": "<c++><class><oop><memory>", "AnswerCount": "2", "OwnerUserId": "1141493", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/data_members\" rel=\"nofollow\">Here</a>, there is a paragraph on the notion of layout for a C class.</p>\n<blockquote>\n<p id=\"so_28928391_28928391_0\"><strong>Layout</strong> </p>\n<p id=\"so_28928391_28928391_1\">When an object of some class C is created, each non-static data\n  member of non-reference type is allocated in some part of the object\n  representation of C. Whether reference members occupy any storage is\n  implementation-defined. </p>\n<p id=\"so_28928391_28928391_2\">For non-union class types, members with the\n  same member access are always allocated so that the members declared\n  later have higher addresses within a class object. Members with\n  different access control are allocated in unspecified order (the\n  compiler may group them together). Alignment requirements may\n  necessitate padding between members, or after the last member of a\n  class.</p>\n</blockquote>\n<p>Is there a strict equivalent of the notion of layout in C++ ? </p>\n<p>What is the standard layout of a C++ class ? </p>\n<p>Is there any storage for reference members in common implementations ?</p>\n", "CommentCount": "2", "PostTypeId": "1", "CreationDate": "2015-03-08T15:46:37.220", "ViewCount": "96", "LastActivityDate": "2015-03-08T16:45:20.780", "Id": "28928391", "LastEditorUserId": "25324", "Title": "What is the layout of a class in C++?", "Score": "-3", "LastEditDate": "2015-03-08T16:16:32.423"}, "28928797": {"LastActivityDate": "2015-03-08T16:20:39.017", "ParentId": "28928391", "Id": "28928797", "Score": "1", "Body": "<p>The standard doesn't enforce any layouting rules, which is why there is this thing called \"binary incompatibility\" between different compilers and platforms.</p>\n<p>As part of its C legacy, C++ has to support a number of exotic platforms which go against \"common sense\" which is why the standard cannot afford to enforce layout rules for the sake of supporting those (mostly dead now) platforms.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "991484", "CreationDate": "2015-03-08T16:20:39.017"}});