post_cb({"bq_ids": {"n4140": {"so_48266525_48266664_0": {"length": 56, "quality": 0.9180327868852459, "section_id": 3326}}, "n3337": {"so_48266525_48266664_0": {"length": 56, "quality": 0.9180327868852459, "section_id": 3196}}, "n4659": {"so_48266525_48266664_0": {"length": 56, "quality": 0.9180327868852459, "section_id": 4092}}}, "48266525": {"ViewCount": "82", "Body": "<p>So I've read here: <a href=\"https://stackoverflow.com/a/598150/2642059\">https://stackoverflow.com/a/598150/2642059</a> that this is illegal:</p>\n<pre><code>foo(i++, i++);\n</code></pre>\n<p>But I believe that's because there is not a forced sequence, which I understand is the case for Initializer Lists. So is this legal code?</p>\n<pre><code>const int foo[] = { i++, i++ };\n</code></pre>\n", "AcceptedAnswerId": "48266664", "Title": "Do the Requirements Placed on Function Arguments Also Apply to Initializer Lists?", "CreationDate": "2018-01-15T15:59:05.823", "LastActivityDate": "2018-01-16T13:48:51.170", "CommentCount": "0", "LastEditDate": "2018-01-15T21:44:34.847", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "48266525", "Score": "7", "OwnerUserId": "2642059", "Tags": "<c++><arguments><language-lawyer><initializer-list><sequencing>", "AnswerCount": "1"}, "48266664": {"Id": "48266664", "PostTypeId": "2", "Body": "<p>Yes, the order of the evaluation of initializer-clauses is guaranteed in braced-init-list.</p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/dcl.init.list#4\" rel=\"nofollow noreferrer\">\u00a711.6.4/4 List-initialization [dcl.init.list]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_48266525_48266664_0\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions,\n  are evaluated in the order in which they appear. That is, every value\n  computation and side effect associated with a given initializer-clause\n  <strong>is sequenced before</strong> every value computation and side effect associated\n  with any initializer-clause that follows it in the comma-separated\n  list of the initializer-list. [\u2009Note: This evaluation ordering holds\n  regardless of the semantics of the initialization; for example, it\n  applies when the elements of the initializer-list are interpreted as\n  arguments of a constructor call, even though ordinarily there are no\n  sequencing constraints on the arguments of a call. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization#Notes\" rel=\"nofollow noreferrer\">cppreference.com</a>:</p>\n<blockquote>\n<p id=\"so_48266525_48266664_1\">Every initializer clause is <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">sequenced\n  before</a> any\n  initializer clause that follows it in the braced-init-list. This is in\n  contrast with the arguments of a <a href=\"http://en.cppreference.com/w/cpp/language/operator_other#Built-in_function_call_operator\" rel=\"nofollow noreferrer\">function call\n  expression</a>,\n  which are\n  <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">unsequenced</a>.</p>\n</blockquote>\n<p>Example for the note of the standard,</p>\n<pre><code>struct A { A(int, int) {} };\n...\nint i = 0;\nA a1(i++, i++); // used as the arguments of the constructor; unsequenced\nA a2{i++, i++}; // used as the arguments of the constructor; sequenced, within the initializer-list of a braced-init-list\n</code></pre>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-01-16T13:48:51.170", "Score": "8", "CreationDate": "2018-01-15T16:06:45.650", "ParentId": "48266525", "CommentCount": "2", "OwnerUserId": "3309790", "LastEditDate": "2018-01-16T13:48:51.170"}});