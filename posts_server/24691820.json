post_cb({"24691820": {"CommentCount": "10", "CreationDate": "2014-07-11T07:00:38.207", "PostTypeId": "1", "AcceptedAnswerId": "24692216", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-11T09:04:49.163", "LastEditDate": "2017-05-23T11:57:51.743", "ViewCount": "200", "FavoriteCount": "2", "Title": "Why does the compiler require a copying constructor, need and have moving one and doesn't uses any of them?", "Id": "24691820", "Score": "2", "Body": "<p>I've already tried to ask this question but I wasn't clear enough. So here is one more try. And I am very sorry for my English ;) <p>\nLet's see the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nstruct A {\n    unique_ptr&lt;int&gt; ref;\n\n    void printRef() {\n        if (ref.get())\n            cout&lt;&lt;\"i=\"&lt;&lt;*ref&lt;&lt;endl;\n        else\n            cout&lt;&lt;\"i=NULL\"&lt;&lt;endl;\n    }\n\n    A(const int i) : ref(new int(i)) { \n        cout&lt;&lt;\"Constructor with \";\n        printRef();\n    }\n    ~A() {\n        cout&lt;&lt;\"Destructor with\";\n        printRef();\n    }\n};\n\nint main()\n{\n    A a[2] = { 0, 1 };\n   return 0;\n}\n</code></pre>\n<p>It can not be compiled because <em>unique_ptr</em> has deleted copying constructor.<br/>\nOrly?!<br/>\nThis class DOES HAVE an implied moving constructor because unique_ptr has one.<p>\nLet's do a test:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nstruct A {\n    unique_ptr&lt;int&gt; ref;\n\n    void printRef() {\n        if (ref.get())\n            cout&lt;&lt;\"i=\"&lt;&lt;*ref&lt;&lt;endl;\n        else\n            cout&lt;&lt;\"i=NULL\"&lt;&lt;endl;\n    }\n\n    A(const int i) : ref(new int(i)) { \n        cout&lt;&lt;\"Constructor with \";\n        printRef();\n    }\n    // Let's add a moving constructor.\n    A(A&amp;&amp; a) : ref(std::move(a.ref)) { \n        cout&lt;&lt;\"Moving constructor with\";\n        printRef();\n    }\n    ~A() {\n        cout&lt;&lt;\"Destructor with\";\n        printRef();\n    }\n};\n\nint main()\n{\n    A a[2] = { 0, 1 };\n   return 0;\n}\n</code></pre>\n<p>I've added a moving constructor and now the code can be compiled and executed.<br/>\nEven if the moving constructor is not used.<br/>\nThe output:</p>\n<blockquote>\n<p id=\"so_24691820_24691820_0\">Constructor with i=0<br/>\n  Constructor with i=1<br/>\n  Destructor withi=1<br/>\n  Destructor withi=0<br/></p>\n</blockquote>\n<p>Okay...<br/>Let's do one more test and remove the copying constructor (but leave the moving one).<br/>\nI don't post the code, there only one line has been added:</p>\n<pre><code>A(const A&amp; a) = delete;\n</code></pre>\n<p>You should trust me - it works. So the compiler doesn't require a copying constructor.\nBut it did! (a facepalm should be here)<br/>\nSo what's going on? I see it completely illogical! Or is there some sort of twisted logic I don't see?<p>\nOnce more:<br/>\n<em>unique_ptr</em> has a moving constructor and has a deleted copying constructor. Compiler requires copying constructor to be present. But in fact the compiler requires a moving constructor (even if it is not used) and doesn't require a copying (because it could be deleted). And as I see the moving constructor is (should be?) present impliedly.<br/>\nWhat's wrong with that?\n<p>P.S. One more thing - if I delete the moving constructor the program could not be compiled. So the moving constructor is required, but not the copying one.<br/>Why does it require copy-constructor if it's <strong>prohibited</strong> to use it there?\n<p>\nP.P.S.\nBig thanks to juanchopanza's answer! This can be solved by:</p>\n<pre><code>A(A&amp;&amp; a) = default;\n</code></pre>\n<p>And also big thanks to Matt McNabb.<br/>\nAs I see it now, the moving constructor is absent because <strike><em>unique_ptr</em> doesn't have a copying one</strike> the class has a destructor (and the general rule is that default/copying/moving constructors and destructor could be generated by default only all together). Then the compiler doesn't stop at moving one (why?!) and falls back to copying one. At this point the compiler can't generate it and stops with an error (about the copy constructor) when nothing else can be done.<p>\nBy the way it you add:</p>\n<pre><code>A(A&amp;&amp; a) = delete;\nA(const A&amp; a) = default;\n</code></pre>\n<p>It could NOT be compiled with error about 'A::A(A&amp;&amp; a)' deletion, There will be no fall back to copying constructor.<p></p>\n<p><strong>P.P.P.S The last question - why does it stop with error at the COPY constructor but not the MOVE constructor?!<br/></strong>\nGCC++ 4.7/4.8 says: \"<em>error: use of deleted function \u2018A::A(const A&amp;)\u2019</em>\"<br/>\nSo it stops at copy constructor.<br/>\nWhy?! There should be '<em>A::A(A&amp;&amp;)</em>'<p>\n<strong>Ok. Now it seems like a question about move/copy constrcutor choosing rule.<br/>\nI've created the new more specific question <a href=\"https://stackoverflow.com/questions/24693950/what-is-copy-move-constructor-choosing-rule-in-c-when-does-move-to-copy-fallb\">here</a></strong></p>\n</p></p></p></p></p></p></p></p>", "Tags": "<c++><c++11><constructor><copy-constructor><move-constructor>", "OwnerUserId": "3544995", "AnswerCount": "3"}, "24691907": {"ParentId": "24691820", "LastEditDate": "2014-07-11T07:42:12.343", "CommentCount": "10", "CreationDate": "2014-07-11T07:05:45.520", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "PostTypeId": "2", "Id": "24691907", "Score": "5", "Body": "<p>This is called <em>copy elision</em>. </p>\n<p>The rule in this situation is that a copy/move operation is specified, but the compiler is allowed to <em>optionally</em> elide it as an optimization, even if the copy/move constructor had side-effects.</p>\n<p>When copy elision happens, typically the object is created directly in the memory space of the destination; instead of creating a new object and then copy/moving it over to the destination and deleting the first object.</p>\n<p>The copy/move constructor still has to actually be present, otherwise we would end up with stupid situations where the code appears to compile, but then fails to compile later when the compiler decides not to do copy-elision.  Or the code would work on some compilers and break on other compilers, or if you used different compiler switches.</p>\n<hr>\n<p>In your first example you do not declare a copy nor a move constructor. This means that it gets an <em>implicitly-defined</em> copy-constructor. </p>\n<p>However, there is a rule that if a class has a user-defined destructor then it does <em>not</em> get an implicitly-defined move constructor. Don't ask me why this rule exists, but it does (see [class.copy]#9 for reference).</p>\n<p>Now, the exact wording of the standard is important here. In [class.copy]#13 it says:</p>\n<blockquote>\n<p id=\"so_24691820_24691907_0\">A copy/move constructor that is defaulted and not defined as deleted is implicitly defined if it is <strong>odr-used</strong> (3.2)</p>\n<p id=\"so_24691820_24691907_1\">[Note: The copy/move constructor is implicitly defined <strong>even if the implementation elided its odr-use</strong> (3.2, 12.2). \u2014end note</p>\n</blockquote>\n<p>The definition of <em>odr-used</em> is quite complicated, but the gist of it is that if you never attempt to copy the object then it will not try to generate the implicitly-defined copy constructor (and likewise for moving and move). </p>\n<p>As T.C. explains on your previous thread though, the act of doing <code>A a[2] = {0, 1};</code> does specify a <em>copy/move</em>, i.e. the value <code>a[0]</code> must be initialized either by copy or by move, from a temporary <code>A(0)</code>.   This temporary is able to undergo <em>copy elision</em>, but as I explain earlier, the right constructors must still exist so that the code would work if the compiler decides not to use copy elision in this case.</p>\n<p>Since your class does not have a move constructor here, it cannot be moved. But the attempt to bind the temporary to a constructor of <code>A</code> still succeeds because there <em>is</em> a copy-constructor defined (albeit implicitly-defined). At that point, <em>odr-use</em> happens and it attempts to generate the copy-constructor and fails due to the <code>unique_ptr</code>.</p>\n<hr>\n<p>In your second example, you provide a move-constructor but no copy-constructor.  There is still an implicitly-declared copy-constructor which is not generated until it is <em>odr-used</em>, as before.</p>\n<p>But the rules of overload resolution say that if a copy and a move are both possible, then the move constructor is used. So it does not <em>odr-use</em> the copy-constructor in this case and everything is fine.</p>\n<p>In the third example, again the move-constructor wins overload resolution so it does not matter what how the copy-constructor is defined.</p>\n</hr></hr>", "LastActivityDate": "2014-07-11T07:42:12.343"}, "24692216": {"ParentId": "24691820", "LastEditDate": "2014-07-11T08:29:40.613", "CommentCount": "7", "CreationDate": "2014-07-11T07:24:30.623", "OwnerUserId": "661519", "LastEditorUserId": "661519", "PostTypeId": "2", "Id": "24692216", "Score": "3", "Body": "<p>I think you are asking why this</p>\n<pre><code>A a[2] = { 0, 1 };\n</code></pre>\n<p>fails to compile, while you would expect it to compile because <code>A</code> may have a move constructor. But it doesn't.</p>\n<p>The reason is that <code>A</code> <strike>has a member that is not copyable, so its own copy constructor is <code>deleted</code>, and this counts as a <em>user declared copy constructor</em></strike> has a <em>user-declared destructor</em>.</p>\n<p>This in turn <a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow\">means <code>A</code> has no <em>implicitly declared move constructor</em></a>. You have to enable move construction, which you can do by defaulting the constructor:</p>\n<pre><code>A(A&amp;&amp;) = default;\n</code></pre>\n<p>To check whether a class is move constructible, you can use <code>is_move_constructible</code>, from the <code>type_traits</code> header:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha;\nstd::cout &lt;&lt; std::is_move_constructible&lt;A&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>This outputs <code>false</code> in your case.</p>\n", "LastActivityDate": "2014-07-11T08:29:40.613"}, "bq_ids": {"n4140": {"so_24691820_24691907_1": {"section_id": 462, "quality": 0.6428571428571429, "length": 9}, "so_24691820_24691907_0": {"section_id": 462, "quality": 0.875, "length": 7}}, "n3337": {"so_24691820_24691907_1": {"section_id": 453, "quality": 0.6428571428571429, "length": 9}, "so_24691820_24691907_0": {"section_id": 453, "quality": 0.875, "length": 7}}, "n4659": {"so_24691820_24691907_1": {"section_id": 485, "quality": 0.6428571428571429, "length": 9}, "so_24691820_24691907_0": {"section_id": 485, "quality": 0.875, "length": 7}}}, "24692018": {"ParentId": "24691820", "CommentCount": "4", "Body": "<p>The twisted logic is that you are supposed to write programs at a higher abstraction level. If an object has a copy constructor it can be copied, otherwise it cannot. If you tell the compiler this object shall not be copied it will obey you and not cheat. Once you tell it that it can be copied the compiler will try to make the copy as fast as possible, usually by avoiding the copy constructor.</p>\n<p>As for the move constructor: It is an optimization. It tends to be faster to move an object from one place to another than to make an exact copy and destroy the old one. This is what move constructors are for. If there is no move constructor the move can still be done with the old fashioned copy and destroy method.</p>\n", "OwnerUserId": "3484570", "PostTypeId": "2", "Id": "24692018", "Score": "1", "CreationDate": "2014-07-11T07:12:58.420", "LastActivityDate": "2014-07-11T07:12:58.420"}});