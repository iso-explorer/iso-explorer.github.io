post_cb({"610245": {"ViewCount": "99828", "Body": "<p>In templates, where and why do I have to put <code>typename</code> and <code>template</code> on dependent names? What exactly are dependent names anyway? I have the following code:</p>\n<pre><code>template &lt;typename T, typename Tail&gt; // Tail will be a UnionNode too.\nstruct UnionNode : public Tail {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        // Q: where to add typename/template here?\n        typedef Tail::inUnion&lt;U&gt; dummy; \n    };\n    template&lt; &gt; struct inUnion&lt;T&gt; {\n    };\n};\ntemplate &lt;typename T&gt; // For the last node Tn.\nstruct UnionNode&lt;T, void&gt; {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        char fail[ -2 + (sizeof(U)%2) ]; // Cannot be instantiated for any U\n    };\n    template&lt; &gt; struct inUnion&lt;T&gt; {\n    };\n};\n</code></pre>\n<p>The problem I have is in the <code>typedef Tail::inUnion&lt;U&gt; dummy</code> line. I'm fairly certain that <code>inUnion</code> is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add <code>template</code> somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. <code>inUnion&lt;U&gt;</code> names a type and not a function?</p>\n", "AcceptedAnswerId": "613132", "Title": "Where and why do I have to put the \"template\" and \"typename\" keywords?", "CreationDate": "2009-03-04T11:56:16.583", "LastActivityDate": "2016-09-02T15:50:24.260", "CommentCount": "11", "FavoriteCount": "577", "PostTypeId": "1", "LastEditDate": "2016-06-01T12:28:05.610", "OwnerDisplayName": "MSalters", "LastEditorUserId": "15416", "Id": "610245", "Score": "809", "OwnerUserId": "15416", "Tags": "<c++><templates><typename><c++-faq><dependent-name>", "AnswerCount": "5"}, "613132": {"Body": "<p>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</p>\n<pre><code>t * f;\n</code></pre>\n<p>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what <code>t</code> means. If it's a type, then it will be a declaration of a pointer <code>f</code>. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</p>\n<blockquote>\n<p id=\"so_610245_613132_0\">Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</p>\n</blockquote>\n<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to a template type parameter? <code>x</code> could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a <em>dependent name</em> (it \"depends\" on the template parameters). </p>\n<p>You might recommend to just wait till the user instantiates the template: </p>\n<blockquote>\n<p id=\"so_610245_613132_1\"><em>Let's wait until the user instantiates the template, and then later find out the real meaning of <code>t::x * f;</code>.</em> </p>\n</blockquote>\n<p>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. </p>\n<p>So there has to be a way to tell the compiler that certain names are types and that certain names aren't. </p>\n<h2>The \"typename\" keyword</h2>\n<p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a dependent name, then we need to prefix it by <code>typename</code> to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</p>\n<blockquote>\n<p id=\"so_610245_613132_2\">A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename. </p>\n</blockquote>\n<p>There are many names for which <code>typename</code> is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with <code>T *f;</code>, when <code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</p>\n<pre><code>// t::x is taken as non-type, but as an expression the following misses an\n// operator between the two names or a semicolon separating them.\nt::x f;\n</code></pre>\n<p><em>The syntax allows <code>typename</code> only before qualified names</em> - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</p>\n<p>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</p>\n<h2>The \"template\" keyword</h2>\n<p>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example: </p>\n<pre><code>boost::function&lt; int() &gt; f;\n</code></pre>\n<p>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>\n<pre><code>namespace boost { int function = 0; }\nint main() { \n  int f = 0;\n  boost::function&lt; int() &gt; f; \n}\n</code></pre>\n<p>That's actually a valid <em>expression</em>! It uses the less-than operator to compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you might well know, <code>boost::function</code> <a href=\"http://www.boost.org/doc/libs/1_54_0/doc/html/function.html\" rel=\"noreferrer\">in real life</a> is a template, so the compiler knows (14.2/3):</p>\n<blockquote>\n<p id=\"so_610245_613132_3\">After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &lt;, the &lt; is\n  always taken as the beginning of a template-argument-list and never as a name followed by the less-than\n  operator.</p>\n</blockquote>\n<p>Now we are back to the same problem as with <code>typename</code>. What if we can't know yet whether the name is a template when parsing the code? We will need to insert <code>template</code> immediately before the template name, as specified by <code>14.2/4</code>. This looks like:</p>\n<pre><code>t::template f&lt;int&gt;(); // call a function template\n</code></pre>\n<p>Template names can not only occur after a <code>::</code> but also after a <code>-&gt;</code> or <code>.</code> in a class member access. You need to insert the keyword there too:</p>\n<pre><code>this-&gt;template f&lt;int&gt;(); // call a function template\n</code></pre>\n<hr>\n<h2>Dependencies</h2>\n<p>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</p>\n<p>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to <em>depend</em> on template parameters.</p>\n<p>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</p>\n<ul>\n<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>\n<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>\n<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>\n</ul>\n<p>Most of the rules are intuitive and are built up recursively: For example, a type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent expression or <code>T</code> is a dependent type. The details of this can be read in section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent expressions and <code>(14.6.2.3)</code> for value-dependent expressions. </p>\n<h3>Dependent names</h3>\n<p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a simple read (you know, the principle of least surprise), all it defines as a <em>dependent name</em> is the special case for function names below. But since clearly <code>T::x</code> also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). </p>\n<p>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore \"dependent names\". A name can take different forms - the Standard says:</p>\n<blockquote>\n<p id=\"so_610245_613132_4\">A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</p>\n</blockquote>\n<p>An identifier is just a plain sequence of characters / digits, while the next two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-name &lt;argument list&gt;</code>. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</p>\n<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of all dependent constructs that are names is called <em>dependent name</em>. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. </p>\n<h3>Dependent function names</h3>\n<p>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name. In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>\n<h2>Additional notes and examples</h2>\n<p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should look like the following</p>\n<pre><code>template &lt;typename T, typename Tail&gt;\nstruct UnionNode : public Tail {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        typedef typename Tail::template inUnion&lt;U&gt; dummy;\n    };\n    // ...\n};\n</code></pre>\n<p>The keyword <code>template</code> doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</p>\n<pre><code>typename t::template iterator&lt;int&gt;::value_type v;\n</code></pre>\n<p>In some cases, the keywords are forbidden, as detailed below</p>\n<ul>\n<li><p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>\n<pre><code> template &lt;typename T&gt;\n struct derive_from_Has_type : /* typename */ SomeBase&lt;T&gt;::type \n { };\n</code></pre></li>\n<li><p>In using-declarations it's not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109\" rel=\"noreferrer\">said</a> not to work on a solution. </p>\n<pre><code> template &lt;typename T&gt;\n struct derive_from_Has_type : SomeBase&lt;T&gt; {\n    using SomeBase&lt;T&gt;::template type; // error\n    using typename SomeBase&lt;T&gt;::type; // typename *is* allowed\n };\n</code></pre></li>\n</ul>\n</hr>", "CreationDate": "2009-03-05T00:27:57.213", "ParentId": "610245", "CommentCount": "12", "LastEditDate": "2016-09-02T15:50:24.260", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2016-09-02T15:50:24.260", "LastEditorUserId": "523124", "Id": "613132", "OwnerDisplayName": "litb", "Score": "836", "OwnerUserId": "34509"}, "610579": {"Id": "610579", "PostTypeId": "2", "Body": "<pre><code>typedef typename Tail::inUnion&lt;U&gt; dummy;\n</code></pre>\n<p>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the \"fail\" tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</p>\n<pre><code>template &lt;typename T, typename TypeList&gt; struct Contains;\n\ntemplate &lt;typename T, typename Head, typename Tail&gt;\nstruct Contains&lt;T, UnionNode&lt;Head, Tail&gt; &gt;\n{\n    enum { result = Contains&lt;T, Tail&gt;::result };\n};\n\ntemplate &lt;typename T, typename Tail&gt;\nstruct Contains&lt;T, UnionNode&lt;T, Tail&gt; &gt;\n{\n    enum { result = true };\n};\n\ntemplate &lt;typename T&gt;\nstruct Contains&lt;T, void&gt;\n{\n    enum { result = false };\n};\n</code></pre>\n<p>PS: Have a look at <a href=\"http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html\" rel=\"noreferrer\">Boost::Variant</a></p>\n<p>PS2: Have a look at <a href=\"http://www.ddj.com/cpp/184403813\" rel=\"noreferrer\">typelists</a>, notably in Andrei Alexandrescu's book: Modern C++ Design</p>\n", "OwnerDisplayName": "Luc Touraille", "LastActivityDate": "2009-03-04T13:37:47.963", "Score": "17", "CreationDate": "2009-03-04T13:37:47.963", "ParentId": "610245", "CommentCount": "7", "OwnerUserId": "20984"}, "17579889": {"Id": "17579889", "PostTypeId": "2", "Body": "<h2>C++11</h2>\n<h3>Problem</h3>\n<p>While the rules in C++03 about when you need <code>typename</code> and <code>template</code> are largely reasonable, there is one annoying disadvantage of its formulation</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n  typedef int result_type;\n\n  void f() {\n    // error, \"this\" is dependent, \"template\" keyword needed\n    this-&gt;g&lt;float&gt;();\n\n    // OK\n    g&lt;float&gt;();\n\n    // error, \"A&lt;T&gt;\" is dependent, \"typename\" keyword needed\n    A&lt;T&gt;::result_type n1;\n\n    // OK\n    result_type n2; \n  }\n\n  template&lt;typename U&gt;\n  void g();\n};\n</code></pre>\n<p>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that <code>A::result_type</code> can only be <code>int</code> (and is hence a type), and <code>this-&gt;g</code> can only be the member template <code>g</code> declared later (even if <code>A</code> is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of <code>A</code>!). </p>\n<h3>Current instantiation</h3>\n<p>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, <code>A</code>, <code>A&lt;T&gt;</code>, <code>::A&lt;T&gt;</code>). A type referenced by such a name is known to be  the <em>current instantiation</em>. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, <code>A::NestedClass</code> and <code>A</code> are both current instantiations). </p>\n<p>Based on this notion, the language says that <code>CurrentInstantiation::Foo</code>, <code>Foo</code> and <code>CurrentInstantiationTyped-&gt;Foo</code> (such as <code>A *a = this; a-&gt;Foo</code>) are all <em>member of the current instantiation</em> <strong>if</strong> they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). </p>\n<p>The keywords <code>typename</code> and <code>template</code> are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that <code>A&lt;T&gt;</code> is <em>still</em> a type-dependent name (after all <code>T</code> is also type dependent). But <code>A&lt;T&gt;::result_type</code> is known to be a type - the compiler will \"magically\" look into this kind of dependent types to figure this out. </p>\n<pre><code>struct B {\n  typedef int result_type;\n};\n\ntemplate&lt;typename T&gt;\nstruct C { }; // could be specialized!\n\ntemplate&lt;typename T&gt;\nstruct D : B, C&lt;T&gt; {\n  void f() {\n    // OK, member of current instantiation!\n    // A::result_type is not dependent: int\n    D::result_type r1;\n\n    // error, not a member of the current instantiation\n    D::questionable_type r2;\n\n    // OK for now - relying on C&lt;T&gt; to provide it\n    // But not a member of the current instantiation\n    typename D::questionable_type r3;        \n  }\n};\n</code></pre>\n<p>That's impressive, but can we do better? The language even goes further and <em>requires</em> that an implementation again looks up <code>D::result_type</code> when instantiating <code>D::f</code> (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined <code>C</code> like this</p>\n<pre><code>template&lt;&gt;\nstruct C&lt;int&gt; {\n  typedef bool result_type;\n  typedef int questionable_type;\n};\n</code></pre>\n<p>A compiler is required to catch the error when instantiating <code>D&lt;int&gt;::f</code>. So you get the best of the two worlds: \"Delayed\" lookup protecting you if you could get in trouble with dependent base classes, and also \"Immediate\" lookup that frees you from <code>typename</code> and <code>template</code>. </p>\n<h3>Unknown specializations</h3>\n<p>In the code of <code>D</code>, the name <code>typename D::questionable_type</code> is not a member of the current instantiation. Instead the language marks it as a <em>member of an unknown specialization</em>. In particular, this is always the case when you are doing <code>DependentTypeName::Foo</code> or <code>DependentTypedName-&gt;Foo</code> and either the dependent type is <em>not</em> the current instantiation (in which case the compiler can give up and say \"we will look later what <code>Foo</code> is) or it <em>is</em> the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. </p>\n<p>Imagine what happens if we had a member function <code>h</code> within the above defined <code>A</code> class template</p>\n<pre><code>void h() {\n  typename A&lt;T&gt;::questionable_type x;\n}\n</code></pre>\n<p>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate <code>A&lt;T&gt;::h</code> (whatever argument you give to <code>T</code>). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since <code>A</code> has no dependent base classes, and <code>A</code> declares no member <code>questionable_type</code>, the name <code>A&lt;T&gt;::questionable_type</code> is <em>neither</em> a member of the current instantiation <em>nor</em> a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</p>\n<h3>Examples and trivia</h3>\n<p>You can try this knowledge on <a href=\"https://stackoverflow.com/a/14005063/34509\">this answer</a> and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  </p>\n<p>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</p>\n<pre><code>struct B { void f(); };\nstruct A : virtual B { void f(); };\n\ntemplate&lt;typename T&gt;\nstruct C : virtual B, T {\n  void g() { this-&gt;f(); }\n};\n\nint main() { \n  C&lt;A&gt; c; c.g(); \n}\n</code></pre>\n<p>This valid C++03 code would bind <code>this-&gt;f</code> to <code>A::f</code> at instantiation time and everything is fine. C++11 however immediately binds it to <code>B::f</code> and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating <code>C&lt;A&gt;::g</code>, the <a href=\"http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)\" rel=\"noreferrer\">Dominance Rule</a> applies and lookup will find <code>A::f</code> instead.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-12T19:03:24.660", "Score": "110", "CreationDate": "2013-07-10T20:02:50.770", "ParentId": "610245", "CommentCount": "1", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T12:18:22.093"}, "bq_ids": {"n4140": {"so_610245_613132_2": {"length": 19, "quality": 1.0, "section_id": 169}, "so_610245_613132_3": {"length": 13, "quality": 0.7647058823529411, "section_id": 71}, "so_610245_613132_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 7030}, "so_610245_613132_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 7027}}, "n3337": {"so_610245_613132_2": {"length": 19, "quality": 1.0, "section_id": 163}, "so_610245_613132_3": {"length": 13, "quality": 0.7647058823529411, "section_id": 66}, "so_610245_613132_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 6776}, "so_610245_613132_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 6773}}, "n4659": {"so_610245_613132_2": {"length": 19, "quality": 1.0, "section_id": 174}, "so_610245_613132_3": {"length": 13, "quality": 0.7647058823529411, "section_id": 73}, "so_610245_613132_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 8527}, "so_610245_613132_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 8524}}}, "24101297": {"Id": "24101297", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_610245_24101297_0\"><strong>PREFACE</strong></p>\n<p id=\"so_610245_24101297_1\">This post is meant to be an <em>easy-to-read</em> alternative to <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889\">litb's post</a>.</p>\n<p id=\"so_610245_24101297_2\">The underlying purpose is the same; an explanation to \"When?\" and \"Why?\" <code>typename</code> and <code>template</code> must be applied.</p>\n</blockquote>\n<hr>\n<h1>What's the purpose of <code>typename</code> and <code>template</code>?</h1>\n<p><code>typename</code> and <code>template</code> are usable in circumstances other than when declaring a template.</p>\n<p>There are certain contexts in <em>C++</em> where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one <em>template-parameter</em>.</p>\n<p>We refer to such names, where there can be an ambiguity in interpretation, as; \"<em>dependent names</em>\".</p>\n<p>This post will offer an explanation to the relationship between <em>dependent-names</em>, and the two keywords.</p>\n<hr>\n<h2>A SNIPPET SAYS MORE THAN 1000 WORDS</h2>\n<p>Try to explain what is going on in the following <em>function-template</em>, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (<em>A</em>)?</p>\n<pre><code>template&lt;class T&gt; void f_tmpl () { T::foo * x; /* &lt;-- (A) */ }\n</code></pre>\n<p><sup><br/></sup>\nIt might not be as easy as one thinks, more specifically the result of evaluating (<em>A</em>) heavily <em>depends</em> on the definition of the type passed as template-parameter <code>T</code>.</p>\n<p>Different <code>T</code>s can drastically change the semantics involved.</p>\n<pre><code>struct X { typedef int       foo;       }; /* (C) --&gt; */ f_tmpl&lt;X&gt; ();\nstruct Y { static  int const foo = 123; }; /* (D) --&gt; */ f_tmpl&lt;Y&gt; ();\n</code></pre>\n<p><sup><br/></sup></p>\n<p><strong>The two different scenarios</strong>:</p>\n<ul>\n<li><p>If we instantiate the function-template with type <em>X</em>, as in (<em>C</em>), we will have a declaration of a <em>pointer-to int</em> named <em>x</em>, but;</p></li>\n<li><p>if we instantiate the template with type <em>Y</em>, as in (<em>D</em>), (<em>A</em>) would instead consist of an expression that calculates the product of <em>123</em> multiplied with some already declared variable <em>x</em>.</p></li>\n</ul>\n<p><br/></p>\n<hr>\n<h2>THE RATIONALE</h2>\n<p>The C++ Standard cares about our safety and well-being, at least in this case.</p>\n<p>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a <em>dependent-name</em> by <em>explicitly</em> stating the intent anywhere we'd like to treat the name as either a <em>type-name</em>, or a <em>template-id</em>.</p>\n<p>If nothing is stated, the <em>dependent-name</em> will be considered to be either a variable, or a function.</p>\n<p><br/></p>\n<hr>\n<h2>HOW TO HANDLE <em>DEPENDENT NAMES</em>?</h2>\n<p>If this was a Hollywood film, <em>dependent-names</em> would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</p>\n<p>A <em>dependent-name</em> is <strong>any</strong> name that directly, or indirectly, depends on a <em>template-parameter</em>.\n<sup><br/><br/></sup></p>\n<pre><code>template&lt;class T&gt; void g_tmpl () {\n   SomeTrait&lt;T&gt;::type                   foo; // (E), ill-formed\n   SomeTrait&lt;T&gt;::NestedTrait&lt;int&gt;::type bar; // (F), ill-formed\n   foo.data&lt;int&gt; ();                         // (G), ill-formed    \n}\n</code></pre>\n<p>We have four <em>dependent</em> names in the above snippet:</p>\n<ul>\n<li><strong>E</strong>)\n\n<ul>\n<li><strong>\"type\"</strong> depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>, which include <code>T</code>, and;</li>\n</ul></li>\n<li><strong>F</strong>)\n\n<ul>\n<li><strong>\"NestedTrait\"</strong>, which is a <em>template-id</em>, depends on <code>SomeTrait&lt;T&gt;</code>, and;</li>\n<li><strong>\"type\"</strong> at the end of (<em>F</em>) depends on <em>NestedTrait</em>, which depends on <code>SomeTrait&lt;T&gt;</code>, and;</li>\n</ul></li>\n<li><strong>G</strong>)\n\n<ul>\n<li><strong>\"data\"</strong>, which looks like a <em>member-function template</em>, is indirectly a <em>dependent-name</em> since the type of <em>foo</em> depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>.</li>\n</ul></li>\n</ul>\n<p>Neither of statement (<em>E</em>), (<em>F</em>) or (<em>G</em>) is valid if the compiler would interpret the <em>dependent-names</em> as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).\n<sup><br/><br/></sup></p>\n<h3>THE SOLUTION</h3>\n<p>To make <code>g_tmpl</code> have a valid definition we must explicitly tell the compiler that we expect a type in (<em>E</em>), a <em>template-id</em> and a <em>type</em> in (<em>F</em>), and a <em>template-id</em> in (<em>G</em>).</p>\n<pre><code>template&lt;class T&gt; void g_tmpl () {\n   typename SomeTrait&lt;T&gt;::type foo;                            // (G), legal\n   typename SomeTrait&lt;T&gt;::template NestedTrait&lt;int&gt;::type bar; // (H), legal\n   foo.template data&lt;int&gt; ();                                  // (I), legal\n}\n</code></pre>\n<p>Every time a <em>name</em> denotes a type, <strong>all</strong> <em>names</em> involved must be either <em>type-names</em> or <em>namespaces</em>, with this in mind it's quite easy to see that we apply <code>typename</code> at the beginning of our fully <em>qualified name</em>.</p>\n<p><code>template</code> however, is different in this regard, since there's no way of coming to a conclusion such as; <em>\"oh, this is a template, than this other thing must also be a template\"</em>. This means that we apply <code>template</code> directly in front of any <em>name</em> that we'd like to treat as such.</p>\n<p><br/></p>\n<hr>\n<h2>CAN I JUST STICK THE <em>KEYWORDS</em> IN FRONT OF ANY NAME?</h2>\n<blockquote>\n<p id=\"so_610245_24101297_3\">\"<em>Can I just stick <code>typename</code> and <code>template</code> in front of any name? I don't want to worry about the context in which they appear...</em>\" - <code>Some C++ Developer</code></p>\n</blockquote>\n<p>The rules in the Standard states that you may apply the keywords as long as you are dealing with a <em>qualified-name</em> (<em>K</em>), but if the name isn't <em>qualified</em> the application is ill-formed (<em>L</em>).</p>\n<pre><code>namespace N {\n  template&lt;class T&gt;\n  struct X { };\n}\n</code></pre>\n<p><sup></sup></p>\n<pre><code>         N::         X&lt;int&gt; a; // ...  legal\ntypename N::template X&lt;int&gt; b; // (K), legal\ntypename template    X&lt;int&gt; c; // (L), ill-formed\n</code></pre>\n<p><sup><strong>Note</strong>: Applying <code>typename</code> or <code>template</code> in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.</sup></p>\n<p><br/></p>\n<p>Additionally there are contexts where <code>typename</code> and <code>template</code> are <strong>explicitly</strong> disallowed:</p>\n<ul>\n<li><p><strong>When specifying the bases of which a class inherits</strong></p>\n<p>Every name written in a derived class's <em>base-specifier-list</em> is already treated as a <em>type-name</em>, explicitly specifying <code>typename</code> is both ill-formed, and redundant.</p>\n<pre><code>                   // .------- the base-specifier-list\n template&lt;class T&gt; // v\n struct Derived      : typename SomeTrait&lt;T&gt;::type /* &lt;- ill-formed */ {\n   ...\n };\n</code></pre>\n<p><br/></p></li>\n<li><p><strong>When the <em>template-id</em> is the one being referred to in a derived class's <em>using-directive</em></strong></p>\n<pre><code> struct Base {\n   template&lt;class T&gt;\n   struct type { };\n };\n\n struct Derived : Base {\n   using Base::template type; // ill-formed\n   using Base::type;          // legal\n };\n</code></pre></li>\n</ul>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-13T21:40:02.220", "Score": "67", "CreationDate": "2014-06-07T20:28:32.803", "ParentId": "610245", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2017-05-23T11:47:22.050"}, "24091502": {"Id": "24091502", "PostTypeId": "2", "Body": "<p><sub>\n<em>This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go <a href=\"https://stackoverflow.com/a/613132/1381108\">here</a>.</em>\n</sub></p>\n<hr>\n<p>The general rule for putting the <code>typename</code> keyword is mostly when you're using a template parameter and you want to access a nested <code>typedef</code> or using-alias, for example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct test {\n    using type = T; // no typename required\n    using underlying_type = typename T::type // typename required\n};\n</code></pre>\n<p>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify <code>typename</code>, for example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct test {\n    // typename required\n    using type = typename std::conditional&lt;true, const T&amp;, T&amp;&amp;&gt;::type;\n    // no typename required\n    using integer = std::conditional&lt;true, int, float&gt;::type;\n};\n</code></pre>\n<p>The general rules for adding the <code>template</code> qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</p>\n<p>Given this struct and function:</p>\n<pre><code>template&lt;typename T&gt;\nstruct test {\n    template&lt;typename U&gt;\n    void get() const {\n        std::cout &lt;&lt; \"get\\n\";\n    }\n};\n\ntemplate&lt;typename T&gt;\nvoid func(const test&lt;T&gt;&amp; t) {\n    t.get&lt;int&gt;(); // error\n}\n</code></pre>\n<p>Attempting to access <code>t.get&lt;int&gt;()</code> from inside the function will result in an error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>main.cpp:13:11: error: expected primary-expression before 'int'\n     t.get&lt;int&gt;();\n           ^\nmain.cpp:13:11: error: expected ';' before 'int'\n</code></pre>\n<p>Thus in this context you would need the <code>template</code> keyword beforehand and call it like so:</p>\n<p><code>t.template get&lt;int&gt;()</code></p>\n<p>That way the compiler will parse this properly rather than <code>t.get &lt; int</code>.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-13T13:40:33.033", "Score": "14", "CreationDate": "2014-06-06T22:23:21.637", "ParentId": "610245", "CommentCount": "0", "OwnerUserId": "1381108", "LastEditDate": "2017-05-23T12:10:34.053"}});