post_cb({"40577179": {"CommentCount": "3", "ViewCount": "1061", "PostTypeId": "1", "CreationDate": "2016-11-13T18:18:06.657", "LastActivityDate": "2016-11-14T01:16:27.547", "Title": "structure tag in C vs C++", "AcceptedAnswerId": "40577244", "LastEditorDisplayName": "user824425", "LastEditDate": "2016-11-13T21:18:29.300", "Id": "40577179", "Score": "18", "Body": "<p>I wrote following simple program &amp; compiled it on gcc compiler</p>\n<pre><code>#include &lt;stdio.h&gt;\ntypedef int i;\nvoid foo()\n{\n    struct i {i i;} i;\n    i.i = 3;\n    printf(\"%i\\n\", i.i);\n}\nint main() { foo(); }\n</code></pre>\n<p>It compiles &amp; runs fine in C.(See live demo <a href=\"http://melpon.org/wandbox/permlink/5qIet28ycmvGmuCQ\" rel=\"noreferrer\">here</a>) But it fails in compilation in C++. C++ compiler gives following error messages.</p>\n<pre><code>prog.cc: In function 'void foo()':\nprog.cc:5:17: error: field 'i' has incomplete type 'foo()::i'\n     struct i {i i;} i;\n                 ^\nprog.cc:5:12: note: definition of 'struct foo()::i' is not complete until the closing brace\n     struct i {i i;} i;\n</code></pre>\n<p>See live demo <a href=\"http://melpon.org/wandbox/permlink/fgFBTI1xohY18pbS\" rel=\"noreferrer\">here</a></p>\n<p>I couldn't find rules regarding this in C &amp; C++ standards. Why it compiles fine in C but not in C++ ? What does the standard says about this ? I very well know that C &amp; C++ are different languages having different rules but I am curious to know about exact rules.</p>\n", "Tags": "<c++><c><struct><language-lawyer>", "OwnerUserId": "3777958", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40577179_40577244_5": {"section_id": 7085, "quality": 0.9090909090909091, "length": 10}, "so_40577179_40577244_6": {"section_id": 7093, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_40577179_40577244_5": {"section_id": 6829, "quality": 0.9090909090909091, "length": 10}, "so_40577179_40577244_6": {"section_id": 6837, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_40577179_40577244_6": {"section_id": 8594, "quality": 0.9090909090909091, "length": 20}, "so_40577179_40577244_5": {"section_id": 8586, "quality": 0.9090909090909091, "length": 10}}}, "40577244": {"ParentId": "40577179", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The difference between C and C++ is the following. In C the data member <code>i</code> is considered as having type <code>int</code> because if you wanted that it had type <code>struct i</code> then you have to write <code>struct i i</code> specifying the keyword <code>struct</code> before <code>i</code>.</p>\n<p>Structure tags are in their own namespace compared with the namespace of other variables.</p>\n<p>According to the C Standard (6.2.3 Name spaces of identifiers)</p>\n<blockquote>\n<p id=\"so_40577179_40577244_0\">1 If more than one declaration of a particular identifier is visible\n  at any point in a translation unit, the syntactic context\n  disambiguates uses that refer to different entities. <strong>Thus, there are\n  separate name spaces for various categories of identifiers, as\n  follows:</strong></p>\n<p id=\"so_40577179_40577244_1\">\u2014 label names (disambiguated by the syntax of the label declaration\n  and use);</p>\n<p id=\"so_40577179_40577244_2\">\u2014 <strong>the tags of structures, unions, and enumerations</strong> (disambiguated by\n  following any32) of the keywords struct, union, or enum);</p>\n<p id=\"so_40577179_40577244_3\">\u2014 the members of structures or unions; each structure or union has a\n  separate name space for its members (disambiguated by the type of the\n  expression used to access the member via the . or -&gt; operator);</p>\n<p id=\"so_40577179_40577244_4\">\u2014 all other identifiers, called ordinary identifiers (declared in\n  ordinary declarators or as enumeration constants). </p>\n</blockquote>\n<p>As for C++ then  inside the structure definition the name of the structure hides the  name of the typedef and the compiler issues the error. In C++ there is separate <strong>class scope</strong>.</p>\n<p>For example in C++ (3.4 Name lookup) there is written</p>\n<blockquote>\n<p id=\"so_40577179_40577244_5\">3 <strong>The injected-class-name of a class</strong> (Clause 9) is also considered\n  to be a member of that class for the purposes of <strong>name hiding and\n  lookup</strong>.</p>\n</blockquote>\n<p>and (3.4.1 Unqualified name lookup)</p>\n<blockquote>\n<p id=\"so_40577179_40577244_6\">7 A name used in the definition of a class X outside of a member\n  function body or nested class definition29 shall be declared in one of\n  the following ways: \u2014 <strong>before its use in class X</strong> or be a member of\n  a base class of X (10.2), or ...</p>\n</blockquote>\n<p>Thus the injected name of the class hides the typedef name within the class definition.</p>\n<p>Take into account that outside the class definition the name of the class can be hidden by the same name of an object. Thus if you want to declare an object of the class in that scope you have to use its elaborated name like</p>\n<pre><code>int i;\n\nstruct i {};\n\n//...\n\nstruct i obj;\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "450609", "LastEditDate": "2016-11-14T01:16:27.547", "Id": "40577244", "Score": "19", "CreationDate": "2016-11-13T18:24:52.583", "LastActivityDate": "2016-11-14T01:16:27.547"}});