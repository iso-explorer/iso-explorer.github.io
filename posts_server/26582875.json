post_cb({"26583020": {"PostTypeId": "2", "Body": "<p>The compiler does not know if x and y are always available at compile time as constant values (expression), and what more, <strong>C++11/14 does not support constexpr function parameter</strong>, so there's no way x and y can be used as parameter for the template add&lt;&gt; in addFunc.</p>\n", "LastActivityDate": "2014-10-27T07:47:33.033", "Id": "26583020", "CommentCount": "0", "CreationDate": "2014-10-27T07:47:33.033", "ParentId": "26582875", "Score": "5", "OwnerUserId": "1882090"}, "26584275": {"Id": "26584275", "PostTypeId": "2", "Body": "<p>Function parameters of a <code>constexpr</code> function aren't constant expressions. The function is <code>constexpr</code> to the outside (as calling it might result in a constant expression), but calculations inside are just as <code>constexpr</code> as they would be in a normal function.</p>\n<p>Template-arguments require constant expressions. These are the crucial requirements for constant expressions that aren't met in your code and thus produce the compiler error ([expr.const]/2, emphasis mine):</p>\n<blockquote>\n<p id=\"so_26582875_26584275_0\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it\n  involves one of the following as a potentially evaluated subexpression\n  (3.2) [\u2026]:<br> </br></p>\n<p id=\"so_26582875_26584275_1\">\u2014 an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object <strong>with a preceding initialization, initialized\n  with a constant expression,</strong> or</li>\n<li>a glvalue of literal type that refers to a non-volatile object <strong>defined with constexpr</strong>, or that refers to a sub-object of such an\n  object, or</li>\n<li>a glvalue of literal type that refers to a non-volatile <strong>temporary object</strong> whose lifetime has not ended, initialized with a constant\n  expression;</li>\n</ul>\n</blockquote>\n<p>You are applying an lvalue-to-rvalue conversion on the parameters to pass them as template arguments.\n<br>The first bullet item doesn't apply as the function parameter is neither precedingly initialized nor known to be initialized with a constant expression, and the second and third don't either (in particular, function parameters shall not be declared <code>constexpr</code>).</br></p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-27T09:28:15.807", "CommentCount": "0", "CreationDate": "2014-10-27T09:15:59.743", "ParentId": "26582875", "Score": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-10-27T09:28:15.807"}, "26584055": {"PostTypeId": "2", "Body": "<p>You tell the compiler, that <code>addFunc</code> would be a constexpr. But it depents on parameters, that are not constexpr itself, so the compiler already chokes on that. Marking them const only means you are not going to modify them in the function body, and the specific calls you make to the function are not considered at this point.</p>\n<p>There is a way you can make the compiler understand you are only going to pass compile time constants to <code>addFunc</code>: Make the parameters a template parameters itself:</p>\n<pre><code>template &lt;int x, int y&gt;\nconstexpr int addFunc() {\n    return add&lt;x,y&gt;::ret;\n}\n</code></pre>\n<p>Then call as</p>\n<pre><code>cout &lt;&lt; addFunc&lt;1,2&gt;() &lt;&lt; endl;\n</code></pre>\n", "LastActivityDate": "2014-10-27T09:01:17.383", "Id": "26584055", "CommentCount": "0", "CreationDate": "2014-10-27T09:01:17.383", "ParentId": "26582875", "Score": "7", "OwnerUserId": "2298533"}, "bq_ids": {"n4140": {"so_26582875_26584275_0": {"length": 7, "quality": 0.7, "section_id": 6185}}, "n3337": {"so_26582875_26584275_0": {"length": 10, "quality": 1.0, "section_id": 5946}}}, "26583950": {"PostTypeId": "2", "Body": "<p>If your purpose is just to shorten code a bit, in C++14 you can create variable template:</p>\n<pre><code>template &lt;int x, int y&gt;\nconstexpr int addVar = x + y;\n\ncout &lt;&lt; addVar&lt;5, 6&gt; &lt;&lt; endl; // Works with clang 3.5, fails on GCC 4.9.1\n</code></pre>\n<p>GCC 5 <a href=\"https://gcc.gnu.org/gcc-5/changes.html#cxx\" rel=\"noreferrer\">will also support this</a>.</p>\n", "LastActivityDate": "2014-10-27T08:54:06.367", "Id": "26583950", "CommentCount": "0", "CreationDate": "2014-10-27T08:54:06.367", "ParentId": "26582875", "Score": "7", "OwnerUserId": "3959454"}, "26582875": {"ViewCount": "7568", "Body": "<p>I am playing around with some toy code using c++11 to figure out a bit more about how things work. During this I came across the following issue that simplifies down to:</p>\n<pre><code>template &lt;int x, int y&gt;\nclass add {\npublic:\n    static constexpr int ret = x + y;\n};\n\nconstexpr int addFunc(const int x, const int y) {\n    return add&lt;x,y&gt;::ret;\n}\n\nint main() {\n    const int x = 1;\n    const int y = 2;\n    cout &lt;&lt; add&lt;x,y&gt;::ret &lt;&lt; endl; // Works\n    cout &lt;&lt; addFunc(1,2) &lt;&lt; endl;  // Compiler error\n    return 0;\n}\n</code></pre>\n<p>I'm using GCC 4.8.1 and the output is: <br/>\n'x' is not a constant expression in template argument for type 'int' <br/>\n'y' is not a constant expression in template argument for type 'int'</p>\n<p>What exactly is the difference between the two ways I am trying to calculate <code>add::ret</code>? Both of these values should be available at compile time. </p>\n", "AcceptedAnswerId": "26584055", "Title": "constexpr function parameters as template arguments", "CreationDate": "2014-10-27T07:36:03.960", "Id": "26582875", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-10-27T07:41:25.803", "LastEditorUserId": "1332396", "LastActivityDate": "2014-10-27T09:28:15.807", "Score": "12", "OwnerUserId": "1332396", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "4"}});