post_cb({"29941820": {"ParentId": "29941499", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your code is ill-formed. <code>mem_fn</code> is in a non-deduced context according to [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_29941499_29941820_0\">The non-deduced contexts are:<br>\n    \u2014 ...<br>\n    \u2014 A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>.</br></br></p>\n</blockquote>\n<p>And from [temp.param]:</p>\n<blockquote>\n<p id=\"so_29941499_29941820_1\">A template parameter pack of a function template <strong>shall not</strong> be followed\n  by another template parameter <strong>unless that template parameter can be deduced</strong> from the <em>parameter-type-list</em>\n  of the function template or has a default argument (14.8.2). <em>[ Example:</em></p>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B; // error\n\n// U can be neither deduced from the parameter-type-list nor specified\ntemplate&lt;class... T, class... U&gt; void f() { } // error\ntemplate&lt;class... T, class U&gt; void g() { } // error\n</code></pre>\n<p id=\"so_29941499_29941820_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The <code>mem_fn</code> argument in this declaration:</p>\n<pre><code>template &lt;typename... Args, void(S::*mem_fn)(Args...)&gt;\nvoid invoke(S* pd, Args... args) {\n</code></pre>\n<p>follows a template parameter pack. It cannot be deduced from the list. You could, however, pass it as an argument:</p>\n<pre><code>template &lt;typename... Args&gt;\nvoid invoke(S* pd, void(S::*mem_fn)(Args...), Args... args);\n</code></pre>\n<p>Or wrap the whole thing in a struct so that you don't need to follow a parameter pack with another template:</p>\n<pre><code>template &lt;typename... Args&gt;\nstruct Invoke {\n    template &lt;void (S::*mem_fn)(Args...)&gt;\n    static void invoke(S* pd, Args... args);\n};\n\nvoid(*pfn)(S*, const char*) = Invoke&lt;const char*&gt;::invoke&lt;&amp;S::f&gt;;\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-29T11:12:08.757", "Id": "29941820", "Score": "5", "CreationDate": "2015-04-29T11:03:47.577", "LastActivityDate": "2015-04-29T11:12:08.757"}, "29942213": {"ParentId": "29941499", "CommentCount": "2", "Body": "<p>A slightly more generic alternative to Barry's solution could use <code>decltype</code> to deduce the entire member function signature, including the class it belongs to:</p>\n<pre><code>template &lt;typename Sig, Sig Fn&gt;\nstruct invoke;\n\ntemplate &lt;typename Ret, class Class, typename... Args, Ret(Class::*mem_fn)(Args...)&gt;\nstruct invoke &lt;Ret(Class::*)(Args...), mem_fn&gt;\n{\n    static void exec (Class* pd, Args... args)\n    {\n        (pd-&gt;*mem_fn)(args...);\n    }\n};\n</code></pre>\n<p>Then use it like this:</p>\n<pre><code>void(*pfn)(S*, const char*) = invoke&lt;decltype(&amp;S::f),&amp;S::f&gt;::exec;\n</code></pre>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "29942213", "Score": "2", "CreationDate": "2015-04-29T11:21:30.633", "LastActivityDate": "2015-04-29T11:21:30.633"}, "bq_ids": {"n4140": {"so_29941499_29941820_0": {"section_id": 336, "quality": 0.9, "length": 9}, "so_29941499_29941820_1": {"section_id": 64, "quality": 0.9, "length": 18}}, "n3337": {"so_29941499_29941820_0": {"section_id": 293, "quality": 0.8, "length": 8}, "so_29941499_29941820_1": {"section_id": 59, "quality": 0.75, "length": 15}}, "n4659": {"so_29941499_29941820_0": {"section_id": 345, "quality": 0.9, "length": 9}, "so_29941499_29941820_1": {"section_id": 66, "quality": 0.9, "length": 18}}}, "29941499": {"CommentCount": "0", "AcceptedAnswerId": "29941820", "CreationDate": "2015-04-29T10:48:47.573", "LastActivityDate": "2015-04-29T11:21:30.633", "PostTypeId": "1", "ViewCount": "577", "FavoriteCount": "3", "Title": "Compilation issue with instantiating function template", "Id": "29941499", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct S {\n  void f(const char* s) {\n    std::cout &lt;&lt; s &lt;&lt; '\\n';\n  }\n};\n\ntemplate &lt;typename... Args, void(S::*mem_fn)(Args...)&gt;\nvoid invoke(S* pd, Args... args) {\n  (pd-&gt;*mem_fn)(args...);\n}\n\nint main() {\n  S s;\n  void(*pfn)(S*, const char*) = invoke&lt;const char*, &amp;S::f&gt;;\n  pfn(&amp;s, \"hello\");\n}\n</code></pre>\n<p>When compiling the code, clang gives the following error:</p>\n<pre><code>main.cpp:16:33: error: address of overloaded function 'invoke' does not match required type 'void (S *, const char *)'\n  void(*pfn)(S*, const char*) = invoke&lt;const char*, &amp;S::f&gt;\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmain.cpp:10:6: note: candidate template ignored: invalid explicitly-specified argument for template parameter 'Args'\nvoid invoke(S* pd, Args... args) {\n     ^\n1 error generated.\n</code></pre>\n<p>The message seems to suggest that the template instantiation <code>invoke&lt;const char*, &amp;S::f&gt;</code> has failed. Could somebody give me some clues as to why is this? I believe it has something to do with the parameter pack.</p>\n", "Tags": "<c++><c++11><language-lawyer><variadic-templates><function-templates>", "OwnerUserId": "1348273", "AnswerCount": "2"}});