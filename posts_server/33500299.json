post_cb({"bq_ids": {"n4140": {"so_33500299_33500369_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_33500299_33500369_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}}}, "33500299": {"CreationDate": "2015-11-03T13:24:49.087", "ViewCount": "117", "ClosedDate": "2015-11-03T17:43:13.637", "Score": "1", "Title": "Possible compiler bug? auto deduction isn't possible when calling a templated method with a pointer retrieved from a templated static member function", "LastEditorUserId": "-1", "CommentCount": "11", "Body": "<p><strong>UPDATE 2</strong></p>\n<p>Why is this marked a duplicate? <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords\"><code>Where and why do I have to put the \u201ctemplate\u201d and \u201ctypename\u201d keywords?</code></a> doesn't answer this question. The behavior described here isn't mentioned there anywhere (you won't find a single remark about the expected behavior of <code>auto</code> there).</p>\n<p>This is <strong>not</strong> a duplicate, especially since there's a conflicting behavior in different compilers.</p>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>Much like GCC, clang also fails to compile:</p>\n<pre><code>17 : error: expected expression\nreturn p-&gt;is&lt;true&gt;();\n^\n</code></pre>\n<p><em>However</em>, on <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">MSVC</a> the code with the <code>auto</code> detection <strong>is compiling successfully</strong>.</p>\n<p>Clearly, there's a compiler bug <strong>somewhere</strong>.</p>\n<hr>\n<p><a href=\"http://coliru.stacked-crooked.com/a/da13af5c64f50838\" rel=\"nofollow noreferrer\">Live example</a></p>\n<p>Consider the following class:</p>\n<pre><code>struct A {\n    template&lt;bool&gt;\n    bool is() const {\n        return true;\n    }\n\n    template&lt;bool&gt;\n    static A* get() {\n        static A a;\n        return &amp;a;\n    }\n};\n</code></pre>\n<p>If a template function, such as</p>\n<pre><code>template&lt;bool cond&gt;\nbool foo() {\n    auto p = A::get&lt;cond&gt;();\n    return p-&gt;is&lt;true&gt;();\n}\n</code></pre>\n<p>tries to call <code>A::is&lt;bool&gt;</code>, it fails miserably:</p>\n<pre><code>main.cpp: In function 'bool foo()':\nmain.cpp:17:24: error: expected primary-expression before ')' token\n     return p-&gt;is&lt;true&gt;();\n                        ^\nmain.cpp: In instantiation of 'bool foo() [with bool cond = true]':\nmain.cpp:21:22:   required from here\nmain.cpp:17:17: error: invalid operands of types '&lt;unresolved overloaded function type&gt;' and 'bool' to binary 'operator&lt;'\n     return p-&gt;is&lt;true&gt;();\n                 ^\n</code></pre>\n<p>however, if only we replace <code>auto</code> with the explicit type (<code>A*</code>):</p>\n<pre><code>template&lt;bool cond&gt;\nbool foo() {\n    A* p = A::get&lt;cond&gt;();\n    return p-&gt;is&lt;true&gt;();\n}\n</code></pre>\n<p>it works.</p>\n<p>What is the reason for this?</p>\n</hr></hr>", "Tags": "<c++><templates><c++11><c++14><auto>", "Id": "33500299", "LastEditDate": "2017-05-23T12:06:44.117", "LastActivityDate": "2015-11-03T15:11:36.037", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "852045"}, "33500369": {"LastActivityDate": "2015-11-03T15:11:36.037", "CommentCount": "11", "Body": "<p>You need to write</p>\n<pre><code>return p-&gt;template is&lt;true&gt;();\n</code></pre>\n<p>because the compiler does not know initially that <code>is</code> is a template.</p>\n<hr>\n<p>Some more deep explanation. With</p>\n<pre><code>A* p = A::get&lt;cond&gt;();\nreturn p-&gt;is&lt;true&gt;();\n</code></pre>\n<p>the compiler knows even when it is parsing the code that <code>p</code> is of type <code>A*</code> and therefore it sees that <code>p-&gt;is</code> is a template.</p>\n<p>With </p>\n<pre><code>auto p = A::get&lt;cond&gt;();\nreturn p-&gt;is&lt;true&gt;();\n</code></pre>\n<p>the compiler does not initially know what type <code>p</code> will be. It will know this only after it has instantiated <code>A::get&lt;cond&gt;</code>, and this will happen only when <code>foo</code> is instantiated. So it does not know that <code>p-&gt;is</code> is a template. (And it may easily be not a template is you had specialized version of <code>A</code> for, say, <code>true</code> template parameter.)</p>\n<p>Further reading: <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords\">Where and why do I have to put the \"template\" and \"typename\" keywords?</a></p>\n<hr>\n<p>Quote from the Standard [14.2.4]:</p>\n<blockquote>\n<p id=\"so_33500299_33500369_0\">When the name of a member template specialization appears after . or\n  -&gt; in a postfix-expression or after a nested-name-specifier in a qualified-id, and the object expression of the postfix-expression is\n  type-dependent or the nested-name-specifier in the qualified-id refers\n  to a dependent type, but the name is not a member of the current\n  instantiation (14.6.2.1), the member template name must be prefixed by\n  the keyword template. Otherwise the name is assumed to name a\n  non-template.</p>\n</blockquote>\n<p>I think this clearly explains that what is observed is correct behavior. Without <code>auto</code>, the type of <code>p</code> is not type-dependent. With <code>auto</code>, is becomes type-dependent.</p>\n</hr></hr>", "CreationDate": "2015-11-03T13:28:02.367", "LastEditDate": "2017-05-23T11:48:31.080", "ParentId": "33500299", "Id": "33500369", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "9", "OwnerUserId": "3216312"}});