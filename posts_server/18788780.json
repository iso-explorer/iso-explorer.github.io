post_cb({"18791721": {"Id": "18791721", "PostTypeId": "2", "Body": "<p>This isn't a guarantee from the standard, but as another data point, <code>v.push_back(v[0])</code> is safe for <a href=\"http://libcxx.llvm.org/\" rel=\"nofollow\">LLVM's libc++</a>.</p>\n<p><a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/vector\" rel=\"nofollow\">libc++'s <code>std::vector::push_back</code></a> calls <code>__push_back_slow_path</code> when it needs to reallocate memory:</p>\n<pre><code>void __push_back_slow_path(_Up&amp; __x) {\n  allocator_type&amp; __a = this-&gt;__alloc();\n  __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(size() + 1), \n                                                  size(), \n                                                  __a);\n  // Note that we construct a copy of __x before deallocating\n  // the existing storage or moving existing elements.\n  __alloc_traits::construct(__a, \n                            _VSTD::__to_raw_pointer(__v.__end_), \n                            _VSTD::forward&lt;_Up&gt;(__x));\n  __v.__end_++;\n  // Moving existing elements happens here:\n  __swap_out_circular_buffer(__v);\n  // When __v goes out of scope, __x will be invalid.\n}\n</code></pre>\n", "LastEditorUserId": "98654", "LastActivityDate": "2013-09-13T19:08:15.853", "Score": "3", "CreationDate": "2013-09-13T17:10:56.040", "ParentId": "18788780", "CommentCount": "2", "LastEditDate": "2013-09-13T19:08:15.853", "OwnerUserId": "98654"}, "18789352": {"Id": "18789352", "PostTypeId": "2", "Body": "<p>From 23.3.6.5/1: <code>Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid.</code></p>\n<p>Since we're inserting at the end, no references will be invalidated <em>if</em> the vector isn't resized. So if the vector's <code>capacity() &gt; size()</code> then it's guaranteed to work, otherwise it's guaranteed to be undefined behavior.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2013-09-13T14:59:43.623", "Score": "-2", "CreationDate": "2013-09-13T14:54:39.337", "ParentId": "18788780", "CommentCount": "4", "LastEditDate": "2013-09-13T14:59:43.623", "OwnerUserId": "251738"}, "18788780": {"ViewCount": "4891", "Body": "<pre><code>vector&lt;int&gt; v;\nv.push_back(1);\nv.push_back(v[0]);\n</code></pre>\n<p>If the second push_back causes a reallocation, the reference to the first integer in the vector will no longer be valid. So this isn't safe?</p>\n<pre><code>vector&lt;int&gt; v;\nv.push_back(1);\nv.reserve(v.size() + 1);\nv.push_back(v[0]);\n</code></pre>\n<p>This makes it safe?</p>\n", "AcceptedAnswerId": "18794634", "Title": "Is it safe to push_back an element from the same vector?", "CreationDate": "2013-09-13T14:27:29.653", "Id": "18788780", "CommentCount": "18", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2013-09-13T20:14:13.127", "LastEditorUserId": "819272", "LastActivityDate": "2013-09-24T18:02:36.027", "Score": "119", "OwnerUserId": "2068573", "Tags": "<c++><vector><reference><language-lawyer><push-back>", "AnswerCount": "9"}, "18789179": {"Id": "18789179", "PostTypeId": "2", "Body": "<p>Both are safe since push_back will copy the value, not the reference. If you are storing pointers, that is still safe as far as the vector is concerned, but just know that you'll have two elements of your vector pointing to the same data.</p>\n<blockquote id=\"so_18788780_18789179_0\">\n<h3>Section 23.2.1 General Container Requirements</h3>\n16\n<ul>\n<li>a.push_back(t)    Appends a copy of t.    Requires: T shall be CopyInsertable into X.</li>\n<li>a.push_back(rv)   Appends a copy of rv.   Requires: T shall be MoveInsertable into X.</li>\n</ul>\n</blockquote>\n<p>Implementations of push_back must therefore ensure that <em>a copy of</em> <code>v[0]</code> is inserted. By counter example, assuming an implementation that would reallocate before copying, it would not assuredly append a copy of <code>v[0]</code> and as such violate the specs.</p>\n", "LastEditorUserId": "154088", "LastActivityDate": "2013-09-13T17:43:34.077", "Score": "-1", "CreationDate": "2013-09-13T14:45:36.663", "ParentId": "18788780", "CommentCount": "16", "LastEditDate": "2013-09-13T17:43:34.077", "OwnerUserId": "154088"}, "18788810": {"Id": "18788810", "PostTypeId": "2", "Body": "<p>Yes, it's safe, and standard library implementations jump through hoops to make it so.</p>\n<p>I believe implementers trace this requirement back to 23.2/11 somehow, but I can't figure out how, and I can't find something more concrete either. The best I can find is this article:</p>\n<p><a href=\"http://www.drdobbs.com/cpp/copying-container-elements-from-the-c-li/240155771\">http://www.drdobbs.com/cpp/copying-container-elements-from-the-c-li/240155771</a></p>\n<p>Inspection of libc++'s and libstdc++'s implementations shows that they are also safe.</p>\n", "LastEditorUserId": "8922", "LastActivityDate": "2013-09-13T14:58:42.890", "Score": "21", "CreationDate": "2013-09-13T14:28:45.340", "ParentId": "18788780", "CommentCount": "7", "LastEditDate": "2013-09-13T14:58:42.890", "OwnerUserId": "8922"}, "18789407": {"Id": "18789407", "PostTypeId": "2", "Body": "<p>The standard guarantees even your first example to be safe. Quoting C++11</p>\n<p>[sequence.reqmts]</p>\n<blockquote>\n<p id=\"so_18788780_18789407_0\">3 In Tables 100 and 101 ... <code>X</code> denotes a sequence container class, <code>a</code> denotes a value of <code>X</code> containing elements of type <code>T</code>, ... <code>t</code> denotes an lvalue or a const rvalue of <code>X::value_type</code></p>\n<p id=\"so_18788780_18789407_1\">16 Table 101 ...</p>\n<p id=\"so_18788780_18789407_2\"><strong>Expression</strong> <code>a.push_back(t)</code> <strong>Return type</strong> <code>void</code> <strong>Operational semantics</strong> Appends a copy of <code>t.</code> <em>Requires:</em> <code>T</code> shall be <code>CopyInsertable</code> into <code>X</code>.  <strong>Container</strong> <code>basic_string</code>, <code>deque</code>, <code>list</code>, <code>vector</code></p>\n</blockquote>\n<p>So even though it's not exactly trivial, the implementation must guarantee it will not invalidate the reference when doing the <code>push_back</code>.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2013-09-13T15:04:38.943", "Score": "13", "CreationDate": "2013-09-13T14:58:09.167", "ParentId": "18788780", "CommentCount": "49", "LastEditDate": "2013-09-13T15:04:38.943", "OwnerUserId": "1782465"}, "18898821": {"Id": "18898821", "PostTypeId": "2", "Body": "<p><strong>It is completely safe.</strong></p>\n<p>In your second example you have</p>\n<pre><code>v.reserve(v.size() + 1);\n</code></pre>\n<p>which is not needed because if vector goes out of its size, it will imply the <code>reserve</code>.</p>\n<p>Vector is responsible for this stuff, not you.</p>\n", "LastEditorUserId": "823738", "LastActivityDate": "2013-09-20T08:16:02.663", "Score": "0", "CreationDate": "2013-09-19T15:25:36.063", "ParentId": "18788780", "CommentCount": "0", "LastEditDate": "2013-09-20T08:16:02.663", "OwnerUserId": "823738"}, "bq_ids": {"n4140": {"so_18788780_18789407_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 735}, "so_18788780_18789889_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6351}, "so_18788780_18789407_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 722}, "so_18788780_18789179_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 735}}, "n3337": {"so_18788780_18789407_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 724}, "so_18788780_18789889_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6108}, "so_18788780_18789407_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 711}, "so_18788780_18789179_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 724}}, "n4659": {"so_18788780_18789407_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 764}, "so_18788780_18789889_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 7860}, "so_18788780_18794634_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 7709}, "so_18788780_18789407_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 753}, "so_18788780_18789179_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 764}}}, "18794634": {"Id": "18794634", "PostTypeId": "2", "Body": "<p>It looks like <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526</a> addressed this problem (or something very similar to it) as a potential defect in the standard:</p>\n<blockquote>\n<p id=\"so_18788780_18794634_0\">1) Parameters taken by const reference can be changed during execution\n  of the function</p>\n<p id=\"so_18788780_18794634_1\">Examples:</p>\n<p id=\"so_18788780_18794634_2\">Given std::vector v:</p>\n<p id=\"so_18788780_18794634_3\">v.insert(v.begin(), v[2]);</p>\n<p id=\"so_18788780_18794634_4\">v[2] can be changed by moving elements of vector</p>\n</blockquote>\n<p>The proposed resolution was that this was not a defect:</p>\n<blockquote>\n<p id=\"so_18788780_18794634_5\">vector::insert(iter, value) is required to work because the standard\n  doesn't give permission for it not to work.</p>\n</blockquote>\n", "LastActivityDate": "2013-09-13T20:23:36.563", "Score": "31", "CreationDate": "2013-09-13T20:23:36.563", "ParentId": "18788780", "CommentCount": "4", "OwnerUserId": "98654"}, "18789889": {"Id": "18789889", "PostTypeId": "2", "Body": "<p>The first version is definitely NOT safe:</p>\n<blockquote>\n<p id=\"so_18788780_18789889_0\">Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it. [ Note: <strong>In particular, container operations that invalidate iterators conflict with operations on iterators associated with that container.</strong> \u2014 end note ]</p>\n</blockquote>\n<p>from section 17.6.5.9</p>\n<hr>\n<p>Note that this is the section on data races, which people normally think of in conjunction with threading... but the actual definition involves \"happens before\" relationships, and I don't see any ordering relationship between the multiple side-effects of <code>push_back</code> in play here, namely the reference invalidation seems not to be defined as ordered with respect to copy-constructing the new tail element.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2013-09-13T16:07:41.737", "Score": "0", "CreationDate": "2013-09-13T15:22:02.240", "ParentId": "18788780", "CommentCount": "3", "LastEditDate": "2013-09-13T16:07:41.737", "OwnerUserId": "103167"}, "18789309": {"Id": "18789309", "PostTypeId": "2", "Body": "<p>It is not obvious that the first example is safe, because the simplest implementation of <code>push_back</code> would be to first reallocate the vector, if needed, and then copy the reference.</p>\n<p>But at least it seems to be safe with Visual Studio 2010. Its implementation of <code>push_back</code> does special handling of the case when you push back an element in the vector.\nThe code is structured as follows:</p>\n<pre><code>void push_back(const _Ty&amp; _Val)\n    {   // insert element at end\n    if (_Inside(_STD addressof(_Val)))\n        {   // push back an element\n                    ...\n        }\n    else\n        {   // push back a non-element\n                    ...\n        }\n    }\n</code></pre>\n", "LastEditorUserId": "763305", "LastActivityDate": "2013-09-15T13:46:38.737", "Score": "7", "CreationDate": "2013-09-13T14:51:58.493", "ParentId": "18788780", "CommentCount": "11", "LastEditDate": "2013-09-15T13:46:38.737", "OwnerUserId": "763305"}});