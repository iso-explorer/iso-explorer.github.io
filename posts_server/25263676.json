post_cb({"25266476": {"ParentId": "25263676", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Undefined behavior is not safe, even if it works today in your test.  In C++, \"it worked when I tried it\" is not good evidence that you are doing it correctly: one of the most common types of undefined behavior is \"it seems to work\".</p>\n<p>The problem is that undefined behavior working is fundamentally fragile.  It can break if you breathe on it hard.</p>\n<p>The compiler is free to optimize branches and code reached only via undefined behavior away, and in many cases does just that.  It is even free to do so after a service patch, compiler upgrade, seemingly irrelevant change in flags passed to compiler, or the length of the executable path name.  It is free to work fine 99.9% of tge time, then format your hard drive the other 0,1% of the time.</p>\n<p>Some of these are more likely than others.</p>\n<p>While iterators to <code>std::string</code> and <code>std::vector</code> elements are basically pointers in release, and the compiler can even typedef a pointer to be said iterators, even that assumption can fail when the next compiler version uses wrapped pointers.</p>\n<p>Undefined behavior is left in the C++ standard to allow freedom for compiler writers to generate more optimal code.  If you invoke it, you can step on their toes.</p>\n<p>That being said, there are reasons to use behavior undefined by the C++ standard.  When you do so, document it heavily, isolate it, and make sure the payoff (say, delegates twice as fast as <code>std::function</code>) is worth it.</p>\n<p>The above is non-isolated and not worth doing undefined behavior, especially because you can solve it without the undefined behavior.</p>\n<p>The easiest solution if you want to iterate backwards is to make some reverse iterators.</p>\n<pre><code>template&lt;class ConstBiIter&gt;\nbool func(ConstBiIter seq_begin, ConstBiIter seq_end)\n{\n  std::reverse_iterator&lt;ConstBiIter&gt; const rend(seq_beg);\n  for (std::reverse_iterator&lt;ConstBiIter&gt; rit(seq_end); rit != rend; ++rit)\n  {\n    ......\n  }\n  return true;\n}\n</code></pre>\n<p>Now <code>rfirst</code> iterates over the range backwards.</p>\n<p>If you need to get back to a forward iterator that refers to the same element for whatever reason, and you are not <code>rend</code>, you can <code>std::prev(rit.base())</code>.  If <code>rit == seq_end</code> at that point, that is undefined behavior.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-08-12T16:16:10.250", "Id": "25266476", "Score": "1", "CreationDate": "2014-08-12T14:08:43.007", "LastActivityDate": "2014-08-12T16:16:10.250"}, "25263782": {"ParentId": "25263676", "CommentCount": "2", "Body": "<p>No, it's not safe to try and decrement the begin iterator.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/iterator/reverse_iterator\" rel=\"noreferrer\"><code>std::reverse_iterator</code></a> (which is what is returned by <a href=\"http://en.cppreference.com/w/cpp/iterator/rend\" rel=\"noreferrer\"><code>std::rend</code></a>) does not actually, underneath, contain an iterator before the begin iterator.  It stores an underlying iterator to the next element from the one it conceptually points to.  Therefore, when the reverse iterator is \"one past the end\" (i.e. \"before the beginning\") its underlying iterator (that you get by calling <a href=\"http://en.cppreference.com/w/cpp/iterator/reverse_iterator/base\" rel=\"noreferrer\"><code>base()</code></a>) is the begin iterator.</p>\n", "OwnerUserId": "1007504", "PostTypeId": "2", "Id": "25263782", "Score": "6", "CreationDate": "2014-08-12T12:02:07.267", "LastActivityDate": "2014-08-12T12:02:07.267"}, "25264552": {"ParentId": "25263676", "CommentCount": "0", "Body": "<p><strong>24.5.1 Reverse iterators</strong></p>\n<blockquote>\n<p id=\"so_25263676_25264552_0\">Class template reverse_iterator is an iterator adaptor that iterates from the end of the sequence defined by its underlying iterator to the beginning of that sequence. The fundamental relation between a reverse iterator and its corresponding iterator i is established by the identity: &amp;*(reverse_iterator(i)) == &amp;*(i - 1).</p>\n</blockquote>\n", "OwnerUserId": "3853514", "PostTypeId": "2", "Id": "25264552", "Score": "1", "CreationDate": "2014-08-12T12:39:30.397", "LastActivityDate": "2014-08-12T12:39:30.397"}, "bq_ids": {"n4140": {"so_25263676_25264552_0": {"section_id": 5600, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_25263676_25264552_0": {"section_id": 5383, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_25263676_25264552_0": {"section_id": 7044, "quality": 0.9230769230769231, "length": 24}}}, "25263676": {"CommentCount": "3", "ViewCount": "2874", "PostTypeId": "1", "LastEditorUserId": "4834", "CreationDate": "2014-08-12T11:56:11.577", "LastActivityDate": "2014-08-12T16:16:10.250", "Title": "Is it safe to use std::prev(vector.begin()) or std::next(vector.begin(), -1) like some_container.rend() as reversed sentry?", "AcceptedAnswerId": "25266476", "LastEditDate": "2014-08-12T12:18:54.863", "Id": "25263676", "Score": "2", "Body": "<p>I wrote some code that takes iterators but have to do comparison in reversed order,</p>\n<pre><code>template&lt;class ConstBiIter&gt;\nbool func(ConstBiIter seq_begin, ConstBiIter seq_end)\n{\n    ConstBiIter last = std::prev(seq_end);\n    while (--last != std::prev(seq_begin)) // --&gt; I need to compare the beginning data\n    {\n        ......\n    }\n    return true;\n}\n</code></pre>\n<p>In VS2013, when running in Debug mode, <code>--last != std::prev(seq_begin)</code> will cause debugger assertion fail with the error message</p>\n<pre><code>Expression:string iterator + offset out of range.\n</code></pre>\n<p>but it is perfectly OK when running in Release mode and giving out correct result, because there's no boundary check in Released mode.</p>\n<p>My questions are:</p>\n<ol>\n<li><p>Is it safe to use <code>std::prev(some_container.begin())</code> as sentry like <code>some_container.rend()</code>?</p></li>\n<li><p>How can I directly compare a <code>reverse_iterator</code> with an <code>iterator</code>?  If I write the code:\n<code>std::cout &lt;&lt; (std::prev(some_container.begin())==some_container.rend()) &lt;&lt; std::endl;</code> it won't compile, even if you <code>reinterpret_cast</code> them.</p></li>\n</ol>\n<p>I am curious if <code>prev(some_container.begin())</code> equals <code>some_container.rend()</code> physically?</p>\n", "Tags": "<c++><c++11><iterator><reverse-iterator>", "OwnerUserId": "3674776", "AnswerCount": "3"}});