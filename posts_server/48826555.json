post_cb({"bq_ids": {"n4140": {"so_48826555_48837011_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6185}}, "n4659": {"so_48826555_48837011_0": {"length": 12, "quality": 0.8, "section_id": 7687}}}, "48826555": {"ViewCount": "86", "LastEditDate": "2018-02-16T19:37:42.630", "AcceptedAnswerId": "48837011", "Title": "not-constexpr variable in if constexpr \u2013 clang vs. GCC", "CreationDate": "2018-02-16T12:14:51.870", "LastActivityDate": "2018-02-17T01:19:22.800", "CommentCount": "8", "Body": "<pre><code>struct A{\n    constexpr operator bool()const{ return true; }\n};\n\nint main(){\n    auto f = [](auto v){ if constexpr(v){} };\n    A a;\n    f(a);\n}\n</code></pre>\n<p>clang 6 accepts the Code, GCC 8 rejects it with:</p>\n<pre><code>$ g++ -std=c++17 main.cpp\nmain.cpp: In lambda function:\nmain.cpp:6:37: error: 'v' is not a constant expression\n  auto f = [](auto v){ if constexpr(v){} };\n                                     ^\n</code></pre>\n<p>Who is correct and why?</p>\n<p>When I take the parameter per reference, both reject the code:</p>\n<pre><code>struct A{\n    constexpr operator bool()const{ return true; }\n};\n\nint main(){\n    auto f = [](auto&amp; v){ if constexpr(v){} };\n    constexpr A a;\n    f(a);\n}\n</code></pre>\n<p>Compiled with clang 6:</p>\n<pre><code>$ clang++ -std=c++17 main.cpp\nmain.cpp:6:40: error: constexpr if condition is not a constant expression\n    auto f = [](auto&amp; v){ if constexpr(v){} };\n                                       ^\nmain.cpp:8:6: note: in instantiation of function template specialization \n    'main()::(anonymous class)::operator()&lt;const A&gt;' requested here\n    f(a);\n     ^\n1 error generated.\n</code></pre>\n<p>When I copy the parameter into a local variable both accept the code:</p>\n<pre><code>struct A{\n    constexpr operator bool()const{ return true; }\n};\n\nint main(){\n    auto f = [](auto v){ auto x = v; if constexpr(x){} };\n    A a;\n    f(a);\n}\n</code></pre>\n<p>Edit: I am sure that the second and third cases will be handled correctly by both compilers. I don't know what the rule is, though.</p>\n<p>In the first case I suspect that clang is right, because the case resembles the second. I would like to know if in the first case clang or GCC is correct and which rules in the second case makes the use of the not-constexpr variable <code>v</code> invalid and in the third case <code>x</code> valid.</p>\n<p>Edit 2: First Question is clear now:\n<a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84421\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84421</a></p>\n<p>clang was right, GCC 7 accepted the code as well. The bug will be fixed in the final version of GCC 8.</p>\n", "PostTypeId": "1", "LastEditorUserId": "4821621", "Id": "48826555", "Score": "3", "OwnerUserId": "4821621", "Tags": "<c++><language-lawyer><constexpr><c++17><if-constexpr>", "AnswerCount": "1"}, "48837011": {"PostTypeId": "2", "Body": "<p>Clang is correct in all cases. [Full disclosure: I'm a Clang developer]</p>\n<p>The question in all cases reduces to this: can we call a <code>constexpr</code> member function on <code>v</code> within a constant expression?</p>\n<p>To answer this question, we need to look at [expr.const]p2, which says:</p>\n<blockquote>\n<p id=\"so_48826555_48837011_0\">An expression e is a <em>core constant expression</em> unless the evaluation of e, following the rules of the abstract machine (6.8.1), would evaluate one of the following expressions:</p>\n<ul>\n<li>...</li>\n<li>an <em>id-expression</em> that refers to a variable or data member of reference type unless the reference has a\n  preceding initialization and either\n  \n  <ul>\n<li>it is initialized with a constant expression or</li>\n<li>its lifetime began within the evaluation of <code>e</code>;</li>\n</ul></li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>None of the other rules prohibit any of your examples. In particular, you <em>are</em> allowed to name local variables in a constant expression if they are not of reference type. (You are <em>not</em> allowed to perform lvalue-to-rvalue conversions on them -- that is, read their values -- unless their value is known (for instance, because they're <code>constexpr</code>), and you're not allowed to end up referring to the address of such a variable, but you <em>are</em> allowed to name them.)</p>\n<p>The reason that the rules are different for entities of reference type is that merely naming an entity of reference type causes the reference to be immediately resolved, even if you don't do anything with the result, and resolving a reference requires knowing what it's bound to.</p>\n<p>So: the first example is valid. The <code>*this</code> value of the <code>constexpr</code> member function is bound to the local variable <code>a</code>. It doesn't matter that we don't know what object that is, because the evaluation doesn't care.</p>\n<p>The second example (where <code>v</code> is of reference type) is ill-formed. Merely naming <code>v</code> requires resolving it to the object it's bound to, which can't be done as part of the constant expression evaluation because we have no idea what it'll end up being bound to. It doesn't matter that the later evaluation steps won't use the resulting object; references are resolved immediately when they're named.</p>\n<p>The third example is valid for the same reason as the first. Notably, the third example remains valid even if you change <code>v</code> to be of reference type:</p>\n<pre><code>auto f = [](auto &amp;v) { auto x = v; if constexpr (x) {} };\nA a;\nf(a);\n</code></pre>\n<p>... because <code>x</code> is, once again, a local variable that we can name within a constant expression.</p>\n", "LastActivityDate": "2018-02-17T01:19:22.800", "Score": "3", "Id": "48837011", "CreationDate": "2018-02-17T01:19:22.800", "ParentId": "48826555", "CommentCount": "0", "OwnerUserId": "1041090"}});