post_cb({"bq_ids": {"n4140": {"so_4516078_4516153_0": {"length": 9, "quality": 0.9, "section_id": 1544}}, "n3337": {"so_4516078_4516153_0": {"length": 9, "quality": 0.9, "section_id": 1538}}, "n4659": {"so_4516078_4516153_0": {"length": 9, "quality": 0.9, "section_id": 1694}}}, "4516078": {"ViewCount": "730", "Body": "<pre><code>#include \"stdafx.h\"\n#include \"iostream\"\n#include \"string\"\n\nusing namespace std;\n\nvoid main()\n{\nstring a = \"a\";\nstring b(1, -70); /*constructor, create a string having 1 character that its value is equal to -70*/\ncout&lt;&lt;((b&gt;a)?b:a);\n}\n\n//output on screen: b was printed, not a (!)\n</code></pre>\n<p>Why b&gt;a although the value of b is less than the value of a?\nHow can I rectify this situation?</p>\n", "Title": "C++ string comparison", "CreationDate": "2010-12-23T05:21:32.767", "LastActivityDate": "2010-12-23T05:57:14.443", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "Id": "4516078", "Score": "4", "OwnerUserId": "552008", "Tags": "<c++><string><comparison>", "AnswerCount": "3"}, "4516098": {"Id": "4516098", "PostTypeId": "2", "Body": "<p>See the binary equivalent value of -70 as a 1 character.</p>\n", "LastActivityDate": "2010-12-23T05:25:30.283", "Score": "1", "CreationDate": "2010-12-23T05:25:30.283", "ParentId": "4516078", "CommentCount": "0", "OwnerUserId": "443075"}, "4516160": {"Id": "4516160", "PostTypeId": "2", "Body": "<p>On VS2010, I found that the char  was signed - hence not the desired explanation.\nStepping through the debugger on the comparison, I eventually hit the code:</p>\n<pre><code>template&lt;&gt; struct char_traits&lt;char&gt;\n { // properties of a string or stream char element\n typedef char _Elem;\n typedef _Elem char_type;\n typedef int int_type;\n typedef streampos pos_type;\n typedef streamoff off_type;\n typedef _Mbstatet state_type;\n\n static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\n  size_t _Count)\n  { // compare [_First1, _First1 + _Count) with [_First2, ...)\n  return (_CSTD memcmp(_First1, _First2, _Count));\n  }\n// etc\n};\n</code></pre>\n<p>So the real comparision boils down to a <a href=\"http://www.cplusplus.com/reference/clibrary/cstring/memcmp/\" rel=\"nofollow\">memcmp</a>. Checking that out, we find \"evaluated as unsigned char values\", hence the problem.</p>\n<p>Cf. Arytom's answer - Interesting, I did not know this. Looking it up:</p>\n<p>The 1998 standard 21.1.3.1:6 on char_traits states 'lt' is defined identically to the built in operator &lt;.</p>\n<p>The N3126 draft, 21.2.3.1:5 states it should be as for unsigned char.</p>\n", "LastEditorUserId": "540026", "LastActivityDate": "2010-12-23T05:48:03.563", "Score": "3", "CreationDate": "2010-12-23T05:37:22.687", "ParentId": "4516078", "CommentCount": "0", "LastEditDate": "2010-12-23T05:48:03.563", "OwnerUserId": "540026"}, "4516153": {"Id": "4516153", "PostTypeId": "2", "Body": "<p>Strings are always compared as <code>unsigned char</code> regardless of the signess of actual character. </p>\n<p><code>std::string</code> took this behavior from C where strcmp uses characters in range 0-255 even if the <code>char</code> is in range -128 -- 127. </p>\n<p>So basically -70 is 186 and 186 &gt; 'a'</p>\n<p><strong>Edit:</strong> Reference to standard. I don't have C++98/2003 near me just C++0x, but:</p>\n<p>\"Working Draft, Standard for Programming Language C++\", N2915, 21.2.3.1, remark 5 says:</p>\n<blockquote>\n<p id=\"so_4516078_4516153_0\">The two-argument members eq and lt shall be defined identically to the built-in operators == and &lt; for type unsigned char.</p>\n</blockquote>\n<p>i.e. characters compared as unsigned char. (it references to character traits specialization for char)</p>\n", "LastEditorUserId": "66522", "LastActivityDate": "2010-12-23T05:57:14.443", "Score": "2", "CreationDate": "2010-12-23T05:36:06.840", "ParentId": "4516078", "CommentCount": "2", "LastEditDate": "2010-12-23T05:57:14.443", "OwnerUserId": "66522"}});