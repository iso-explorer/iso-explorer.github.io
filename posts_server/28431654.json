post_cb({"28431883": {"Id": "28431883", "PostTypeId": "2", "Body": "<p>First, let's remember that there is no <code>a[100]</code>. It does not exist! If you tried to access <code>a[100]</code>'s \"value\" then, according to the abstract machine called C++, anything can happen. This includes blowing up the sun or dying my hair purple; now, I like my hair the way it is, so please don't!</p>\n<p>Anyway, what you're doing is playing with the array's \"one-past-the-end\" pointer. You are allowed to obtain this pointer, which is a fake pointer of sorts, as long as you do not dereference it.</p>\n<p>It is available only because the \"101<sup>st</sup> element\" would be \"one past the end\" of the array. (And there is debate as to whether you are allowed to write <code>&amp;a[100]</code>, rather than <code>a+100</code>, to get such a pointer; I am in the \"no\" camp.)</p>\n<p>However, that still says nothing about comparing it to the address of some entirely different object. You cannot assume anything about the relative location of local variables in memory. You simply have no idea where <code>n</code> will live with respect to <code>a</code>.</p>\n<p>The results you're observing are unpredictable, unreliable and meaningless side effects of the <em>undefined behaviour</em> exhibited by your program, caused by a combination of compiler optimisations and data locality.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-02-10T13:00:59.650", "CommentCount": "8", "CreationDate": "2015-02-10T12:37:16.577", "ParentId": "28431654", "Score": "4", "OwnerUserId": "560648", "LastEditDate": "2015-02-10T13:00:59.650"}, "28431890": {"PostTypeId": "2", "Body": "<p>by writing <code>&amp;a[100]</code> you're invoking undefined behavior, since there is no element with index 100 in the array <code>a</code>. To get the same address safely, you could instead write <code>a+100</code> (or <code>&amp;a[0]+100</code>) in which case your program would be well-defined, but whether or not the if condition will hold cannot be predicted or relied upon on any implementation.</p>\n", "LastActivityDate": "2015-02-10T12:37:45.017", "Id": "28431890", "CommentCount": "0", "CreationDate": "2015-02-10T12:37:45.017", "ParentId": "28431654", "Score": "-1", "OwnerUserId": "469935"}, "bq_ids": {"n4140": {"so_28431654_28431982_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 6155}}, "n3337": {"so_28431654_28431982_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5917}}}, "28431982": {"PostTypeId": "2", "Body": "<p>For a bit if facts here is the relevant text from the specifications\nEquality operator (==,!=)</p>\n<p>Pointers to objects of the same type can be compared for equality with the 'intuitive' expected results:</p>\n<p>From \u00a7 5.10 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_28431654_28431982_0\">Pointers of the same type (after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if &gt; and only if they are both null, both point to the same function, or &gt; both represent the same address (3.9.2).</p>\n<p id=\"so_28431654_28431982_1\">(leaving out details on comparison of pointers to member and or the\n  null pointer constants - they continue down the same line of 'Do &gt;\n  What I Mean':)</p>\n<ul>\n<li>[...] If both operands are null, they compare equal. Otherwise if    only one is null, they compare unequal.[...]</li>\n</ul>\n<p id=\"so_28431654_28431982_2\">The most 'conspicuous' caveat has to do with virtuals, and it does seem to be the logical thing to expect too:</p>\n<ul>\n<li>[...] if either is a pointer to a virtual member function, the result    is unspecified. Otherwise they compare equal if and only if\n  they    would refer to the same member of the same most derived object\n  (1.8)    or the same subobject if they were dereferenced with a\n  hypothetical    object of the associated class type. [...]</li>\n</ul>\n</blockquote>\n<p>Maybe the problem could be that array of <em>int</em> is not the same as <em>int</em>!</p>\n", "LastActivityDate": "2015-02-10T12:42:08.913", "Id": "28431982", "CommentCount": "1", "CreationDate": "2015-02-10T12:42:08.913", "ParentId": "28431654", "Score": "0", "OwnerUserId": "4226058"}, "28431833": {"Id": "28431833", "PostTypeId": "2", "Body": "<p>For the array declaration <code>int a[100]</code>, array index starts from <code>0</code> to <code>99</code> and when you try access the address of 101th element which is out of its range could overlap with next member (in your case its variable <code>n</code>) on the stack. However its undefined behavior.    </p>\n", "LastEditorUserId": "1079907", "LastActivityDate": "2015-02-10T12:40:31.577", "CommentCount": "0", "CreationDate": "2015-02-10T12:34:39.173", "ParentId": "28431654", "Score": "2", "OwnerUserId": "1079907", "LastEditDate": "2015-02-10T12:40:31.577"}, "28431654": {"ViewCount": "89", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int a[100],n;\n    cout&lt;&lt;&amp;n&lt;&lt;\" \"&lt;&lt;&amp;a[100]&lt;&lt;endl;\n    if(&amp;n!=&amp;a[100])\n    {\n         cout&lt;&lt;\" What is wrong with C++?\";\n    }\n}\n</code></pre>\n<p>It prints the address of n and a[100] as same. But when I compare the two values in the if loop It says that they both are not equal.</p>\n<p>What does this mean?</p>\n<p>When I change the value of n, a[100] also changes so doesn't that mean n and a[100] are equal.</p>\n", "Title": "C++: Memory allocation", "CreationDate": "2015-02-10T11:19:28.433", "LastActivityDate": "2017-08-19T10:05:43.187", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-08-19T10:05:43.187", "OwnerDisplayName": "Transcend97", "LastEditorUserId": "1033581", "Id": "28431654", "Score": "-3", "OwnerUserId": "4446016", "Tags": "<c++><memory-management>", "AnswerCount": "4"}});