post_cb({"bq_ids": {"n4140": {"so_34389262_34389400_2": {"length": 10, "quality": 0.7692307692307693, "section_id": 5945}, "so_34389262_34389400_7": {"length": 7, "quality": 0.5833333333333334, "section_id": 6795}, "so_34389262_34389400_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5945}}, "n3337": {"so_34389262_34389400_2": {"length": 10, "quality": 0.7692307692307693, "section_id": 5716}, "so_34389262_34389400_7": {"length": 7, "quality": 0.5833333333333334, "section_id": 6550}, "so_34389262_34389400_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5716}}, "n4659": {"so_34389262_34389400_2": {"length": 10, "quality": 0.7692307692307693, "section_id": 7430}, "so_34389262_34389400_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7430}}}, "34391948": {"Id": "34391948", "PostTypeId": "2", "Body": "<p>Depending on FLT_EVAL_METHOD, xi * xd may be calculated with higher precision than double. If xi were so large that it cannot be represented exactly in double, then I'm not even sure if the compiler would be allowed to convert it exactly to long double or not - probably not, because that conversion happens <em>before</em> anything covered by FLT_EVAL_METHOD. There is no requirement that higher precision must be used consistently. </p>\n<p>There are two places where conversion to double must happen: At the point of the cast (double) and at the point of assignment to a double. There have been gcc versions where the cast to double was \"optimised\" away if a value was already \"officially\" a double (like xi * xd here) even if in reality it was higher precision; that \"optimisation\" was always a bug because a cast <em>must</em> convert. </p>\n<p>So you may have run into this bug where a cast to double wasn't performed (if the bug is still there), you may have run into inconsistent use of higher precision, which is legal if FLT_EVAL_METHOD allows it, and you may even have run into inconsistent use of higher precision when FLT_EVAL_METHOD didn't allow it at all, which would again be a bug (not the inconsistency, but the use of higher precision in the first place). </p>\n", "LastActivityDate": "2015-12-21T08:56:25.017", "Score": "2", "CreationDate": "2015-12-21T08:56:25.017", "ParentId": "34389262", "CommentCount": "2", "OwnerUserId": "3255455"}, "34389400": {"Id": "34389400", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34389262_34389400_0\">even if the compiler uses a higher internal precision than double for the computation of xi * xd, it should do this consistently</p>\n</blockquote>\n<p>Whether required or not (discussed below), this clearly doesn't happen: Stackoverflow is littered with questions from people who've seen similar-seeming calculations change for no ostensible reason <em>within the same program</em>.</p>\n<p>The C++ Standard draft n3690 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_34389262_34389400_1\">The values of the floating operands and the results of floating expressions <strong><em>may</em></strong> be represented in greater precision and range than that required by the type; the types are not changed thereby.62</p>\n<p id=\"so_34389262_34389400_2\">62) The cast and assignment operators must still perform their specific conversions as described in 5.4, 5.2.9 and 5.17.</p>\n</blockquote>\n<p>So - in agreement with M.M.'s comment and contrary to my earlier edit - it's the version with the <code>(double)</code> cast that <strong>must</strong> be rounded to a 64-bit <code>double</code> - which evidently happens to be &gt;= 1180000000 in the run documented in the question - before truncation to integer.  The more general case sans 62) leaves the compiler freedom not to round early in the other case.</p>\n<blockquote>\n<p id=\"so_34389262_34389400_3\">[c.limits]/3 says that FLT_EVAL_METHOD should be imported from C99. IOW I expected that it should not be allowed to use a different precision for xi * xd on one line than it does on another line.</p>\n</blockquote>\n<p>Check the <a href=\"http://en.cppreference.com/w/cpp/types/climits/FLT_EVAL_METHOD\" rel=\"nofollow\">cppreference page</a>:</p>\n<blockquote>\n<p id=\"so_34389262_34389400_4\">Regardless of the value of FLT_EVAL_METHOD, any floating-point expression may be contracted, that is, calculated as if all intermediate results have infinite range and precision (unless #pragma STDC FP_CONTRACT is off) </p>\n</blockquote>\n<p>As tmyklebu comments, it continues:</p>\n<blockquote>\n<p id=\"so_34389262_34389400_5\">Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location. </p>\n</blockquote>\n<p>This last agrees with the \"62)\" part of the Standard.</p>\n<p>M.M. comments:</p>\n<blockquote>\n<p id=\"so_34389262_34389400_6\">STDC FP_CONTRACT does not seem to appear in the C++ Standard and also it's not clear to me exactly to what extent the C99 behaviour is 'imported' </p>\n</blockquote>\n<p>Doesn't appear in the draft I looked at.  That suggests C++ doesn't guarantee its availability, leaving the default mentioned above of <em>\"any floating-point expression may be contracted\"</em>, but we know per M.M. comments and the Standard and cppreference quotes above the <code>(double)</code> cast is an exception forcing rounding to 64 bits.</p>\n<p>The C++ Standard draft mentioned above says of <code>&lt;cfloat&gt;</code>:</p>\n<blockquote>\n<p id=\"so_34389262_34389400_7\">The contents are the same as the Standard C library header .\n  See also: ISO C 7.1.5, 5.2.4.2.2, 5.2.4.2.1.</p>\n</blockquote>\n<p>If one of those C Standards required <code>STDC FP_CONTRACT</code> there's more chance of it being portable for use by C++ programs, but I've not surveyed implementations for support.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2015-12-21T08:41:06.160", "Score": "3", "CreationDate": "2015-12-21T05:19:42.507", "ParentId": "34389262", "CommentCount": "6", "LastEditDate": "2015-12-21T08:41:06.160", "OwnerUserId": "410767"}, "34389262": {"ViewCount": "181", "Body": "<p>In the following code:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cinttypes&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint main() {\n    double xd = 1.18;\n    int64_t xi = 1000000000;\n\n    int64_t res1 = (double)(xi * xd);\n\n    double d = xi * xd;\n    int64_t res2 = d;\n\n    printf(\"%\" PRId64\"\\n\", res1);\n    printf(\"%\" PRId64\"\\n\", res2);\n}\n</code></pre>\n<p>Using v4.9.3 <code>g++ -std=c++14</code> targeting 32-bit Windows I get output:</p>\n<pre><code>1179999999\n1180000000\n</code></pre>\n<p>Are these values allowed to be different? </p>\n<p>I expected that, even if the compiler uses a higher internal precision than <code>double</code> for the computation of <code>xi * xd</code>, it should do this consistently.  Loss of precising in floating conversion is <em>implementation-defined</em>, and also the precision of this calculation is <em>implementation-defined</em> - [c.limits]/3 says that <code>FLT_EVAL_METHOD</code> should be imported from C99. IOW I expected that it should not be allowed to use a different precision for <code>xi * xd</code> on one line than it does on another line.</p>\n<p><em>Note:</em> This is intentionally a C++ question and not a C question - I believe the two languages have different rules in this area.</p>\n", "Title": "Does the C++ standard allow this floating-point behaviour?", "CreationDate": "2015-12-21T05:07:06.087", "LastActivityDate": "2015-12-21T08:56:25.017", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "Id": "34389262", "Score": "8", "OwnerUserId": "1505939", "Tags": "<c++><floating-point><language-lawyer><c++14>", "AnswerCount": "2"}});