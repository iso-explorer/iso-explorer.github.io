post_cb({"bq_ids": {"n4140": {"so_8850759_8850759_0": {"section_id": 144, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_8850759_8850759_0": {"section_id": 138, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_8850759_8850759_0": {"section_id": 148, "quality": 0.6666666666666666, "length": 4}}}, "8850759": {"CommentCount": "1", "ViewCount": "94", "PostTypeId": "1", "ClosedDate": "2012-01-13T12:52:21.957", "LastEditorUserId": "-1", "CreationDate": "2012-01-13T12:43:54.650", "LastActivityDate": "2012-01-13T12:43:54.650", "Title": "Nested template dependent typedef and argument type deduction", "LastEditDate": "2017-05-23T12:29:04.557", "Id": "8850759", "Score": "1", "Body": "<blockquote>\n<p id=\"so_8850759_8850759_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/6060824/c-template-argument-can-not-be-deduced\">C++, template argument can not be deduced</a> </br></p>\n</blockquote>\n<p>I have the following code:</p>\n<pre><code>template&lt;typename T&gt;\nstruct A { };\n\ntemplate&lt;typename T&gt;\nstruct B\n{\n    typedef A&lt;T&gt; NestedA;\n};\n\ntemplate&lt;typename T&gt;\nvoid f(typename B&lt;T&gt;::NestedA a) { }\n\nvoid g()\n{\n    B&lt;int&gt;::NestedA a;\n    f(a); //g++ error: no matching function for call to \u2018f(A&lt;int&gt;&amp;)\u2019\n}\n</code></pre>\n<p>Why does g++ 4.4.3 complain here? Why it can not deduce the type of <code>a</code>? It is not even a nested type, but a nested typedef. After all isn't typedef an alias for a type?</p>\n", "Tags": "<c++><templates><gcc><g++><typedef>", "OwnerUserId": "324204", "AnswerCount": "0"}});