post_cb({"41348082": {"CommentCount": "1", "ViewCount": "164", "PostTypeId": "1", "LastEditorUserId": "1020773", "CreationDate": "2016-12-27T15:44:39.347", "LastActivityDate": "2016-12-27T15:50:35.987", "Title": "Why can't MSVC and GCC initialize a struct with a field with a default value", "AcceptedAnswerId": "41348146", "LastEditDate": "2016-12-27T15:50:35.987", "Id": "41348082", "Score": "0", "Body": "<pre><code>int main() {\n  struct WorkItem {\n    int node;\n    unsigned predecessorIndex = 0;\n  };  \n\n  auto x = WorkItem { 0 };\n\n  return 0;\n}\n</code></pre>\n<p>This code compiles fine with Clang, but not with GCC:</p>\n<blockquote>\n<p id=\"so_41348082_41348082_0\">source_file.cpp: In function \u2018int main()\u2019:</p>\n<p id=\"so_41348082_41348082_1\">source_file.cpp:9:25: error: no matching function for call to \u2018main()::WorkItem::WorkItem()\u2019\n     auto x = WorkItem { 0 };\n                           ^</p>\n<p id=\"so_41348082_41348082_2\">source_file.cpp:9:25: note: candidates are:</p>\n<p id=\"so_41348082_41348082_3\">source_file.cpp:4:10: note: main()::WorkItem::WorkItem()\n     struct WorkItem {\n            ^</p>\n<p id=\"so_41348082_41348082_4\">source_file.cpp:4:10: note:   candidate expects 0 arguments, 1 provided</p>\n<p id=\"so_41348082_41348082_5\">source_file.cpp:4:10: note: constexpr main()::WorkItem::WorkItem(const main()::WorkItem&amp;)</p>\n<p id=\"so_41348082_41348082_6\">source_file.cpp:4:10: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const main()::WorkItem&amp;\u2019</p>\n<p id=\"so_41348082_41348082_7\">source_file.cpp:4:10: note: constexpr main()::WorkItem::WorkItem(main()::WorkItem&amp;&amp;)</p>\n<p id=\"so_41348082_41348082_8\">source_file.cpp:4:10: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018main()::WorkItem&amp;&amp;\u2019</p>\n</blockquote>\n<p>Or MSVC:</p>\n<blockquote>\n<p id=\"so_41348082_41348082_9\">source_file.cpp(9): error C2440: 'initializing': cannot convert from 'initializer list' to 'main::WorkItem'</p>\n<p id=\"so_41348082_41348082_10\">source_file.cpp(9): note: No constructor could take the source type, or constructor overload resolution was ambiguous</p>\n</blockquote>\n<p>Is Clang incorrectly compiling this code, or are MSVC and GCC wrong, from a standards point of view?\nAlso, why does removing the <code>= 0</code> allow GCC and MSVC to compile? E.g.</p>\n<pre><code>int main() {\n  struct WorkItem {\n    int node;\n    unsigned predecessorIndex = 0;\n  };  \n\n  auto x = WorkItem { 0 };\n\n  return 0;\n}\n</code></pre>\n<p>GCC version: 4.9.3\nClang version: 3.7.0\nMSVC version: 19.00.24215.1</p>\n", "Tags": "<c++><gcc><visual-c++><clang><language-lawyer>", "OwnerUserId": "1020773", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41348082_41348082_10": {"section_id": 3296, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_41348082_41348082_10": {"section_id": 3166, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_41348082_41348082_10": {"section_id": 4058, "quality": 0.5833333333333334, "length": 7}}}, "41348146": {"ParentId": "41348082", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_41348082_41348146_0\">GCC version: 4.9.3</p>\n</blockquote>\n<p>Aggregate initialization with default member initializers is a C++14 feature which GCC <a href=\"http://en.cppreference.com/w/cpp/compiler_support\" rel=\"nofollow noreferrer\">does not support until GCC 5.x</a>.</p>\n<blockquote>\n<p id=\"so_41348082_41348146_1\">MSVC version: 19.00.23506</p>\n</blockquote>\n<p>I believe this is Update 1 of VC 2015. Aggregate initialization with default member initializers is a C++14 feature that VC <a href=\"http://en.cppreference.com/w/cpp/compiler_support\" rel=\"nofollow noreferrer\">doesn't support until 2017</a>.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "41348146", "Score": "4", "CreationDate": "2016-12-27T15:49:40.110", "LastActivityDate": "2016-12-27T15:49:40.110"}});