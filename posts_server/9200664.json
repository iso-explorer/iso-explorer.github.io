post_cb({"9201435": {"ParentId": "9200664", "LastEditDate": "2016-12-28T05:29:12.153", "CommentCount": "6", "CreationDate": "2012-02-08T21:08:08.040", "OwnerUserId": "924727", "LastEditorUserId": "372128", "PostTypeId": "2", "Id": "9201435", "Score": "37", "Body": "<p><code>shared_ptr</code> must manage a reference counter and the carrying of a deleter functor that is deduced by the type of the object given at initialization.</p>\n<p>The <code>shared_ptr</code> class typically hosts two members: a <code>T*</code> (that is returned by <code>operator-&gt;</code> and dereferenced in <code>operator*</code>) and a <code>aux*</code> where <code>aux</code> is a inner abstract class that contains:</p>\n<ul>\n<li>a counter (incremented / decremented upon copy-assign / destroy)</li>\n<li>whatever is needed to make increment / decrement atomic (not needed if specific platform atomic INC/DEC is available)</li>\n<li>an abstract <code>virtual destroy()=0;</code></li>\n<li>a virtual destructor.</li>\n</ul>\n<p>Such <code>aux</code> class (the actual name depends on the implementation) is derived by a family of templatized classes (parametrized on the type given by the explicit constructor, say <code>U</code> derived from <code>T</code>), that add:</p>\n<ul>\n<li>a pointer to the object (same as <code>T*</code>, but with the actual type: this is needed to properly manage all the cases of <code>T</code> being a base for whatever <code>U</code> having multiple <code>T</code> in the derivation hierarchy)</li>\n<li>a copy of the <code>deletor</code> object given as deletion policy to the explicit constructor (or the default <code>deletor</code> just doing delete <code>p</code>, where <code>p</code> is the <code>U*</code> above)</li>\n<li>the override of the destroy method, calling the deleter functor.</li>\n</ul>\n<p>A simplified sketch can be this one:</p>\n<pre><code>template&lt;class T&gt;\nclass shared_ptr\n{\n    struct aux\n    {\n        unsigned count;\n\n        aux() :count(1) {}\n        virtual void destroy()=0;\n        virtual ~aux() {} //must be polymorphic\n    };\n\n    template&lt;class U, class Deleter&gt;\n    struct auximpl: public aux\n    {\n        U* p;\n        Deleter d;\n\n        auximpl(U* pu, Deleter x) :p(pu), d(x) {}\n        virtual void destroy() { d(p); } \n    };\n\n    template&lt;class U&gt;\n    struct default_deleter\n    {\n        void operator()(U* p) const { delete p; }\n    };\n\n    aux* pa;\n    T* pt;\n\n    void inc() { if(pa) interlocked_inc(pa-&gt;count); }\n\n    void dec() \n    { \n        if(pa &amp;&amp; !interlocked_dec(pa-&gt;count)) \n        {  pa-&gt;destroy(); delete pa; }\n    }\n\npublic:\n\n    shared_ptr() :pa(), pt() {}\n\n    template&lt;class U, class Deleter&gt;\n    shared_ptr(U* pu, Deleter d) :pa(new auximpl&lt;U,Deleter&gt;(pu,d)), pt(pu) {}\n\n    template&lt;class U&gt;\n    explicit shared_ptr(U* pu) :pa(new auximpl&lt;U,default_deleter&lt;U&gt; &gt;(pu,default_deleter&lt;U&gt;())), pt(pu) {}\n\n    shared_ptr(const shared_ptr&amp; s) :pa(s.pa), pt(s.pt) { inc(); }\n\n    template&lt;class U&gt;\n    shared_ptr(const shared_ptr&lt;U&gt;&amp; s) :pa(s.pa), pt(s.pt) { inc(); }\n\n    ~shared_ptr() { dec(); }\n\n    shared_ptr&amp; operator=(const shared_ptr&amp; s)\n    {\n        if(this!=&amp;s)\n        {\n            dec();\n            pa = s.pa; pt=s.pt;\n            inc();\n        }        \n        return *this;\n    }\n\n    T* operator-&gt;() const { return pt; }\n    T&amp; operator*() const { return *pt; }\n};\n</code></pre>\n<p>Where <code>weak_ptr</code> interoperability is required a second counter (<code>weak_count</code>) is required in <code>aux</code> (will be incremented / decremented by <code>weak_ptr</code>), and <code>delete pa</code> must happen only when both the counters reach zero.</p>\n", "LastActivityDate": "2016-12-28T05:29:12.153"}, "9200664": {"CommentCount": "11", "CreationDate": "2012-02-08T20:12:09.380", "PostTypeId": "1", "AcceptedAnswerId": "9201435", "LastEditorUserId": "743214", "LastActivityDate": "2016-12-28T05:29:12.153", "LastEditDate": "2013-05-02T11:02:30.853", "ViewCount": "16740", "FavoriteCount": "16", "Title": "How is the std::tr1::shared_ptr implemented?", "Id": "9200664", "Score": "26", "Body": "<p>I've been thinking about using shared pointers, and I know how to implement one myself--Don't want to do it, so I'm trying <code>std::tr1::shared_ptr</code>,and I have couple of questions...</p>\n<p>How is the reference counting implemented? Does it use a doubly linked list? (Btw, I've already googled, but I can't find anything reliable.)</p>\n<p>Are there any pitfalls for using the <code>std::tr1::shared_ptr</code>?</p>\n", "Tags": "<c++><shared-ptr><tr1>", "OwnerUserId": "1148237", "AnswerCount": "4"}, "35204206": {"ParentId": "9200664", "LastEditDate": "2016-02-04T23:37:32.077", "CommentCount": "0", "CreationDate": "2016-02-04T14:52:14.393", "OwnerUserId": "3313438", "LastEditorUserId": "3313438", "PostTypeId": "2", "Id": "35204206", "Score": "8", "Body": "<blockquote>\n<p id=\"so_9200664_35204206_0\">How is the reference counting implemented?</p>\n</blockquote>\n<p>A smart pointer implementation could be deconstructed, using <a href=\"https://en.wikipedia.org/wiki/Policy-based_design\" rel=\"noreferrer\">policy-based class design</a><sup>1</sup>, into :</p>\n<ul>\n<li><p>Storage Policy</p></li>\n<li><p>Ownership Policy</p></li>\n<li><p>Conversion Policy</p></li>\n<li><p>Checking Policy</p></li>\n</ul>\n<p>included as template parameters.\nPopular ownership strategies include: deep copy, reference counting, reference linking, and destructive copy.</p>\n<p>Reference counting tracks the number of smart pointers pointing to (owning<sup>2</sup>) the same object. When the number goes to zero, the pointee object is deleted<sup>3</sup>. The actual counter could be:</p>\n<ol>\n<li>Shared among smart pointer objects, where each smart pointer holds a pointer to the reference counter:</li>\n</ol>\n<p><a href=\"https://i.stack.imgur.com/KFjUM.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/KFjUM.png\"/></a></p>\n<ol start=\"2\">\n<li>Included only in an additional structure that adds an extra level of indirection the pointee object. Here the space overhead of holding a counter in each smart pointer is exchanged with slower access speed:</li>\n</ol>\n<p><a href=\"https://i.stack.imgur.com/lL7li.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/lL7li.png\"/></a> </p>\n<ol start=\"3\">\n<li><p>Contained within the pointee object itself: intrusive reference counting. The disadvantage is that the object must be constructed a priori with facilities for counting:</p>\n<p><a href=\"https://i.stack.imgur.com/4Gb2j.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4Gb2j.png\"/></a></p></li>\n<li><p>Finally the method in your question, reference counting using doubly linked lists is called reference linking and it:</p></li>\n</ol>\n<blockquote>\n<p id=\"so_9200664_35204206_1\">...[1] relies on the observation that you don't really need the actual count of smart pointer objects pointing to one pointee object; you only need to detect when that count goes down to zero. This leads to the idea of keeping an \"ownership list\" :</p>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/J6fLM.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/J6fLM.png\"/></a></p>\n<blockquote>\n<p id=\"so_9200664_35204206_2\">The advantage of reference linking over reference counting is that the former does not use extra free store, which makes it more reliable: Creating a reference-linked smart pointer cannot fail. The disadvantage is\n  that reference linking needs more memory for its bookkeeping (three pointers versus only one pointer plus one integer). Also, reference counting should be a bit speedier\u2014when you copy smart pointers, only an indirection and an increment are needed. The list management is slightly more elaborate. In conclusion,\n  you should use reference linking only when the free store is scarce. Otherwise, prefer reference counting.</p>\n</blockquote>\n<h2>Regarding your second question:</h2>\n<blockquote>\n<p id=\"so_9200664_35204206_3\">Does it (<code>std::shared_ptr</code>) use a doubly linked list? </p>\n</blockquote>\n<p>All that I could find in the C++ standard was:</p>\n<blockquote>\n<p id=\"so_9200664_35204206_4\"><strong>20.7.2.2.6 shared_ptr creation</strong><br>\n  ...<br>\n  7. [ Note: These functions will typically allocate more memory than <code>sizeof(T)</code> to allow for internal bookkeeping structures such as the reference counts. \u2014end note ]</br></br></p>\n</blockquote>\n<p>Which, in my opinion, excludes doubly linked lists, as they do not contain actual count.</p>\n<h2>Your third question:</h2>\n<blockquote>\n<p id=\"so_9200664_35204206_5\">Are there any pitfalls for using the <code>std::shared_ptr</code>?</p>\n</blockquote>\n<p>Reference management either counting or linking is a victim of the resource leak known as <em>cyclic reference</em>. Let's have an object A that holds a smart pointer to an object B. Also, object B holds a smart pointer to A. These two objects form a cyclic reference; even though you don't use any of them any more, they use each other. The reference management strategy cannot detect such cyclic references, and the two objects remain allocated forever. </p>\n<p>Because the implementation of <code>shared_ptr</code> uses reference counting, cyclic references are potentially a problem. A cyclic <code>shared_ptr</code> chain can be broken by changing the code so that one of the references is a <code>weak_ptr</code>. This is done by assigning values between shared pointers and weak pointers, but a weak pointer doesn't affect the reference count. If the only pointers that point to an object are weak, the object is destroyed.</p>\n<hr>\n<p><sup>1. Each design feature with multiple implementations if formulated as policy.</sup></p>\n<p><sup>2. Smart pointers similarly to pointers that point to object allocated with <code>new</code>, not only point to that object but also are responsible for its destruction and with the release of the memory it occupies.</sup></p>\n<p><sup>3. With no further problems, if no other raw pointers are used and/or point to it.</sup></p>\n<p>[1] Modern C++ Design: Generic Programming and Design Patterns Applied. Andrei Alexandrescu, February 01, 2001</p>\n</hr>", "LastActivityDate": "2016-02-04T23:37:32.077"}, "9200780": {"ParentId": "9200664", "LastEditDate": "2016-05-08T09:30:42.073", "CommentCount": "0", "CreationDate": "2012-02-08T20:20:29.660", "OwnerUserId": "56338", "LastEditorUserId": "800454", "PostTypeId": "2", "Id": "9200780", "Score": "3", "Body": "<p>If you want to see all the gory details, you can have a look at the boost <code>shared_ptr</code> implementation:</p>\n<p><a href=\"https://github.com/boostorg/smart_ptr\" rel=\"nofollow\">https://github.com/boostorg/smart_ptr</a></p>\n<p>The reference counting seems to usually be implemented with a counter and platform specific atomic increment/decrement instructions or explicit locking with a mutex (see the <code>atomic_count_*.hpp</code> files in the <a href=\"http://svn.boost.org/svn/boost/trunk/boost/smart_ptr/detail/\" rel=\"nofollow\">detail namespace</a>).</p>\n", "LastActivityDate": "2016-05-08T09:30:42.073"}, "9202209": {"ParentId": "9200664", "LastEditDate": "2016-02-04T15:50:52.120", "CommentCount": "4", "CreationDate": "2012-02-08T22:02:47.337", "OwnerUserId": "649233", "LastEditorUserId": "3313438", "PostTypeId": "2", "Id": "9202209", "Score": "3", "Body": "<blockquote>\n<p id=\"so_9200664_9202209_0\">Are there any pitfalls for using the <code>std::tr1::shared_ptr</code>?</p>\n</blockquote>\n<p>Yes, If you create cycles in your shared memory pointers, then the memory being managed by the smart pointer will not be recycled when the last pointer goes out of scope because there are still references to the pointer (i.e., the cycles cause the reference count to not go down to zero).</p>\n<p>For instance:</p>\n<pre><code>struct A\n{\n    std::shared_ptr&lt;A&gt; ptr;\n};\n\nstd::shared_ptr&lt;A&gt; shrd_ptr_1 = std::make_shared(A());\nstd::shared_ptr&lt;B&gt; shrd_ptr_2 = std::make_shared(A());\nshrd_ptr_1-&gt;ptr = shrd_ptr_2;\nshrd_ptr_2-&gt;ptr = shrd_ptr_1;\n</code></pre>\n<p>Now, even if <code>shrd_ptr_1</code> and <code>shrd_ptr_2</code> go out of scope, the memory they are managing is not reclaimed because the <code>ptr</code> member of each are pointing to each other.  While this is a very naive example of such a memory cycle, it can, if you use these types of pointers without any discipline, occur in a much more nefarious and hard-to-track fashion.  For instance, I could see where trying to implement a circular linked-list where each <code>next</code> pointer is a <code>std::shared_ptr</code>, if you're not too careful, could result in problems.</p>\n", "LastActivityDate": "2016-02-04T15:50:52.120"}, "bq_ids": {"n4140": {"so_9200664_35204206_4": {"section_id": 4444, "quality": 0.6818181818181818, "length": 15}}, "n3337": {"so_9200664_35204206_4": {"section_id": 4281, "quality": 0.6818181818181818, "length": 15}}, "n4659": {"so_9200664_35204206_4": {"section_id": 5709, "quality": 0.6818181818181818, "length": 15}}}});