post_cb({"43216468": {"CommentCount": "15", "ViewCount": "112", "PostTypeId": "1", "LastEditorUserId": "7816293", "CreationDate": "2017-04-04T19:52:50.127", "LastActivityDate": "2017-04-05T05:38:21.587", "Title": "Can sizeof of struct be affected by array metadata?", "AcceptedAnswerId": "43216647", "LastEditDate": "2017-04-05T05:38:21.587", "Id": "43216468", "Score": "-3", "Body": "<p>There has been a number of questions regarding the <code>sizeof</code> of <code>struct</code>'s (not) being equal to the sum of <code>sizeof</code>'s of its elements. Usually this is due to data alignment. This question is <em>not</em> concerned with data alignment, so please suppose that sizes of all types are multiples of the alignment (say 4B).</p>\n<p>As explained <a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#num-elems-in-new-array\" rel=\"nofollow noreferrer\">here</a>, allocating an array will result in some metadata beeing stored about the size of the allocated array. Let's say we had the following code:</p>\n<pre><code>const int size = 10;\n\nstruct X {\n    int someInt;\n    int array[size];\n};\n\nstruct Y {\n    int someInt;\n    T array[size];\n};\n</code></pre>\n<p>Since the <code>size</code> is known at compile-time, the compiler <em>should</em> be smart enough to determine that there is no need to store any metadata in the case of <code>X</code>. The compiler <em>could</em> be smart enough to follow this reasoning even in the case of <code>Y</code> (there could be difference between C and C++ here, since in C++ there is the additional requirement of calling destructors for individual instances of <code>T</code>).</p>\n<p>My question is: am I <em>guaranteed</em> that <code>sizeof(X) == (size + 1) * sizeof(int)</code> or is it compiler-specific? Or more generally, is <code>sizeof(Y) == size * sizeof(T) + sizeof(int)</code>?</p>\n<hr>\n<p><strong>EDIT:</strong> To hopefully clarify things a bit: the question is about <em>both</em> C and C++. Also the original motivation for asking this question is this. If I run</p>\n<pre><code>X *foo = new X[100];\n</code></pre>\n<p>or it's C equivalent somewhere in code, will it create a <em>continuous</em> block of memory of size <code>100 * (size + 1) * sizeof(int)</code>?</p>\n</hr>", "Tags": "<c++><c><arrays><struct>", "OwnerUserId": "7816293", "AnswerCount": "2"}, "43217371": {"ParentId": "43216468", "CommentCount": "0", "CreationDate": "2017-04-04T20:44:44.227", "OwnerUserId": "2410359", "PostTypeId": "2", "Id": "43217371", "Score": "0", "Body": "<p>Meta data can hide between <code>struct</code> members.  I have never see this use for meta-data, yet a compiler could play with the alignments of types, up to a point, to provide a discontinuous memory between two <code>int</code> members by obliging the alignment of an <code>int</code> to be greater than an <code>int</code>width such as 4 bytes.  If the compiler uses this for meta-data, performance padding or spite, it is irrelevant.  The point is that it may exist.</p>\n<p>C99/C11 provides <code>max_align_t</code>, so types will not natively exceed that alignment per the C spec.</p>\n<blockquote>\n<p id=\"so_43216468_43217371_0\">A <em>fundamental alignment</em> is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to <code>_Alignof (max_align_t)</code>.  \u00a76.2.811dr \u00a76.2.8 2</p>\n<p id=\"so_43216468_43217371_1\"><code>max_align_t</code> which is an object type whose alignment is as great as is supported by the implementation in all contexts; \u00a77.19 2</p>\n</blockquote>\n<p>So any structure member that is smaller than <code>max_align_t</code> is subject to padding/meta data <em>in a potential context</em>.</p>\n", "LastActivityDate": "2017-04-04T20:44:44.227"}, "43216647": {"ParentId": "43216468", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2017-04-04T20:03:02.910", "Score": "3", "LastEditorUserId": "1084774", "LastEditDate": "2017-04-04T20:32:47.480", "Id": "43216647", "OwnerUserId": "1084774", "Body": "<p>C arrays in common implementations don't store any metadata around them, however, padding may be added to structs so that <code>a_struct_ptr + 1</code> has sufficient alignment for <code>a_struct</code>.</p>\n<p>In the case of the first struct (<code>{ int someInt; int array[size]; }</code>), no padding should be required, so </p>\n<pre><code>sizeof(X) == (size + 1) * sizeof(int)\n</code></pre>\n<p>should hold (though, I don't think compilers are obligated to guarantee it).</p>\n<p>In the case of the second struct, the alignment requirements of <code>T</code> and <code>int</code> may cause padding to be added to the struct, which would invalidate your equation.</p>\n", "LastActivityDate": "2017-04-04T20:32:47.480"}, "bq_ids": {"n4140": {"so_43216468_43217371_1": {"section_id": 6710, "quality": 0.5454545454545454, "length": 6}, "so_43216468_43217371_0": {"section_id": 7241, "quality": 0.7222222222222222, "length": 13}}, "n3337": {"so_43216468_43217371_1": {"section_id": 6465, "quality": 0.5454545454545454, "length": 6}, "so_43216468_43217371_0": {"section_id": 6985, "quality": 0.7222222222222222, "length": 13}}, "n4659": {"so_43216468_43217371_1": {"section_id": 8185, "quality": 0.5454545454545454, "length": 6}, "so_43216468_43217371_0": {"section_id": 8750, "quality": 0.7222222222222222, "length": 13}}}});