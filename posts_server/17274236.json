post_cb({"17274398": {"ParentId": "17274236", "CommentCount": "4", "Body": "<p>From 5.3.5-3:</p>\n<blockquote>\n<p id=\"so_17274236_17274398_0\">In the first alternative (delete object), if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or the\n  behavior is undefined.</p>\n</blockquote>\n<p>Leaving aside possible problems in using <code>reinterpret_cast</code> here, this is UB because the types do not match. Imagine some nontrivial type, then you can easily see this as the \"wrong\" dtor would be called.</p>\n<p>Additionally using the result of <code>reinterpret_cast</code> for anything else than casting it back is mostly unspecified by the standard.</p>\n", "OwnerUserId": "833362", "PostTypeId": "2", "Id": "17274398", "Score": "2", "CreationDate": "2013-06-24T11:29:11.540", "LastActivityDate": "2013-06-24T11:29:11.540"}, "17274384": {"ParentId": "17274236", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Here you are:</p>\n<blockquote>\n<p id=\"so_17274236_17274384_0\">5.3.5 point 3: In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>As for questions of what is static and dynamic type:</p>\n<blockquote>\n<p id=\"so_17274236_17274384_1\">1.3.7 dynamic type (glvalue)<br>\n   type of the most derived object (1.8) to which the glvalue denoted by a glvalue expression refers\n  [ Example: if a pointer (8.3.1) p whose static type is \u201cpointer to class B\u201d is pointing to an object of class\n  D, derived from B (Clause 10), the dynamic type of the expression *p is \u201cD.\u201d References (8.3.2) are treated\n  similarly. \u2014end example ]</br></p>\n<p id=\"so_17274236_17274384_2\">1.3.23 static type<br>\n  type of an expression (3.9) resulting from analysis of the program without considering execution semantics\n  [Note: The static type of an expression depends only on the form of the program in which the expression\n  appears, and does not change while the program is executing. \u2014end note]</br></p>\n</blockquote>\n", "OwnerUserId": "113662", "LastEditorUserId": "113662", "LastEditDate": "2013-06-24T11:43:47.497", "Id": "17274384", "Score": "0", "CreationDate": "2013-06-24T11:28:38.330", "LastActivityDate": "2013-06-24T11:43:47.497"}, "17274236": {"CommentCount": "2", "ViewCount": "149", "CreationDate": "2013-06-24T11:20:50.353", "LastActivityDate": "2013-06-24T11:43:47.497", "Title": "Operator delete and casting", "AcceptedAnswerId": "17274377", "PostTypeId": "1", "Id": "17274236", "Score": "5", "Body": "<p>Can i use smth like the following code:</p>\n<pre><code>int main()\n{\n    int* foo = new int;\n    double* bar = reinterpret_cast&lt;double*&gt;(foo);\n    delete bar;\n}\n</code></pre>\n<p>Is it UB?</p>\n<p>I think that we need to call operator delete only for pointers returned by operator new, but what about casting in this case?</p>\n<p>I think that it's UB since the reinterpret_cast don't give any guarantees about the resulting pointer. Am i right?</p>\n<p>Can somebody post the right quote from the standard, please?</p>\n", "Tags": "<c++>", "OwnerUserId": "1608835", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_17274236_17274398_0": {"section_id": 6107, "quality": 0.9629629629629629, "length": 26}, "so_17274236_17274384_2": {"section_id": 5768, "quality": 0.8, "length": 20}, "so_17274236_17274384_0": {"section_id": 6107, "quality": 0.896551724137931, "length": 26}, "so_17274236_17274384_1": {"section_id": 5768, "quality": 0.7714285714285715, "length": 27}}, "n3337": {"so_17274236_17274398_0": {"section_id": 5873, "quality": 0.9629629629629629, "length": 26}, "so_17274236_17274384_2": {"section_id": 5541, "quality": 0.8, "length": 20}, "so_17274236_17274384_0": {"section_id": 5873, "quality": 0.896551724137931, "length": 26}, "so_17274236_17274384_1": {"section_id": 5541, "quality": 0.7714285714285715, "length": 27}}, "n4659": {"so_17274236_17274398_0": {"section_id": 7604, "quality": 0.9629629629629629, "length": 26}, "so_17274236_17274384_2": {"section_id": 7225, "quality": 0.8, "length": 20}, "so_17274236_17274384_0": {"section_id": 7604, "quality": 0.896551724137931, "length": 26}, "so_17274236_17274384_1": {"section_id": 7225, "quality": 0.6571428571428571, "length": 23}}}, "17274377": {"ParentId": "17274236", "CommentCount": "8", "Body": "<p>\u00a75.3.5/2 \"In the first alternative (delete object), the value of\nthe operand of delete may be a null pointer value, a pointer to\na non-array object created by a previous new-expression, or\na pointer to a subobject (1.8) representing a base class of such\nan object (Clause 10). If not, the behavior is undefined.\" Since\n<code>bar</code> points to a <code>double</code>, it does not point to an object\ncreated by a previous new-expression (which created an <code>int</code>).</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "17274377", "Score": "6", "CreationDate": "2013-06-24T11:28:12.187", "LastActivityDate": "2013-06-24T11:28:12.187"}});