post_cb({"14258264": {"Id": "14258264", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14256695_14258264_0\">Why so?</p>\n</blockquote>\n<p>Historical reasons.</p>\n<p>Before the advent of the ANSI C standard and <code>size_t</code> in 1989, <code>int</code> was the type used to index into arrays. <code>malloc</code> took an <code>int</code> as its argument, <code>strlen</code> returned one. Thus <code>int</code> had to be large enough to index any array, but small enough to not cause too much overhead. For file offsets, typically a larger type such as <code>long</code> was <code>typedef</code>'d to <code>off_t</code>.</p>\n<p>On the <a href=\"https://en.wikipedia.org/wiki/PDP-11\" rel=\"nofollow\">PDP-11</a> were C was first implemented in the early 1970s, <code>int</code> was as large as a processor register: 16 bits. On larger machines such as the <a href=\"https://en.wikipedia.org/wiki/VAX\" rel=\"nofollow\">VAX</a>, it was widened to 32 bits to allow for larger arrays.</p>\n<p>This convention has been largely abandoned; the C and C++ standards use <code>size_t</code> and <code>ssize_t</code> for indices and lenghts of arrays. On 64-bit platforms, often <code>int</code> is still 32 bits wide while <code>size_t</code> is 64 bits. (Many older APIs, e.g. <a href=\"http://www.netlib.org/blas/\" rel=\"nofollow\">CBLAS</a>, still use <code>int</code> for indices, though.)</p>\n", "LastEditorUserId": "166749", "LastActivityDate": "2013-01-10T15:14:18.407", "Score": "4", "CreationDate": "2013-01-10T12:45:07.693", "ParentId": "14256695", "CommentCount": "0", "OwnerUserId": "166749", "LastEditDate": "2013-01-10T15:14:18.407"}, "bq_ids": {"n4140": {"so_14256695_14257140_2": {"length": 41, "quality": 0.9761904761904762, "section_id": 7211}, "so_14256695_14257140_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5785}, "so_14256695_14257140_1": {"length": 12, "quality": 1.0, "section_id": 7210}}, "n3337": {"so_14256695_14257140_2": {"length": 41, "quality": 0.9761904761904762, "section_id": 6955}, "so_14256695_14257140_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5558}, "so_14256695_14257140_1": {"length": 12, "quality": 1.0, "section_id": 6954}}, "n4659": {"so_14256695_14257140_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 8720}, "so_14256695_14257140_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 7242}, "so_14256695_14257140_1": {"length": 12, "quality": 1.0, "section_id": 8719}}}, "14258683": {"Id": "14258683", "PostTypeId": "2", "Body": "<p>Your question can be reformulated as why the different types of data structure depends on the CPU. This can be justified simply by the fact that C is a language that can be used in low-level programming. You can see in <a href=\"http://lwn.net/images/pdf/LDD3/ch11.pdf\" rel=\"nofollow\">Data Types in the Kernel</a> how that data types are defined for different types of CPU in Linux. This is link to word length of the processor.</p>\n", "LastActivityDate": "2013-01-10T13:09:11.827", "CommentCount": "0", "CreationDate": "2013-01-10T13:09:11.827", "ParentId": "14256695", "Score": "1", "OwnerUserId": "1929959"}, "14256770": {"Id": "14256770", "PostTypeId": "2", "Body": "<p>A <em>byte</em> is the smallest unit of memory which your target system can handle and uniquely address. As such, the size of a byte is platform and compiler-dependant, but in most settings is 8 bits.</p>\n<p>So, assuming a byte is 8 bits, this would mean that 64 bits equals 8 bytes, 32 bits equals 4 bytes and 16 bits equals 2 bytes.</p>\n<p>On a fuzzy level, an \"X bit system\" is a system where basic values (registers, ints, etc.) are X bits by default. Thus, how many bits your system natively uses immediately affects how many bytes are needed to hold those values.</p>\n", "LastActivityDate": "2013-01-10T11:21:28.897", "CommentCount": "5", "CreationDate": "2013-01-10T11:21:28.897", "ParentId": "14256695", "Score": "2", "OwnerUserId": "980195"}, "14256695": {"ViewCount": "1757", "Body": "<p>I wounder why size of int depends on which OS one is using ,in C &amp; C++. It's ok if size of pointer varies, but why size of integer. If 16 bit OS sizeof(int) = 2 byte, for 32 bit sizeof(int) = 4 byte. Why so?</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "14257140", "Title": "Why does sizeof(int) vary across different operating systems?", "CreationDate": "2013-01-10T11:17:41.990", "Id": "14256695", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-10T12:28:14.540", "LastEditorUserId": "1926664", "LastActivityDate": "2014-11-06T07:02:19.390", "Score": "3", "OwnerUserId": "1926664", "Tags": "<c++><c><operating-system>", "AnswerCount": "4"}, "14257140": {"Id": "14257140", "PostTypeId": "2", "Body": "<p>According to the C++ standard</p>\n<p>1.7.1 states:</p>\n<blockquote>\n<p id=\"so_14256695_14257140_0\">The fundamental storage unit in the C++ memory model is the byte. A\n  byte is at least large enough to contain any member of the basic\n  execution character set ...</p>\n</blockquote>\n<p>then 3.9.1.1 states:</p>\n<blockquote>\n<p id=\"so_14256695_14257140_1\">Objects declared as characters (char) shall be large enough to store\n  any member of the implementation\u2019s basic character set.</p>\n</blockquote>\n<p>So we can infer that <code>char</code> is actually a byte. Most importantly 3.9.1.2 also says:</p>\n<blockquote>\n<p id=\"so_14256695_14257140_2\">There are \ufb01ve signed integer types: \u201csigned char\u201d, \u201cshort int\u201d, \u201cint\u201d,\n  \u201clong int\u201d, and \u201clong long int\u201d. In this list, each type provides at\n  least as much storage as those preceding it in the list. Plain ints\n  have the natural size suggested by the architecture of the execution\n  environment; the other signed integer types are provided to meet\n  special needs.</p>\n</blockquote>\n<p>So in other words the size of <code>int</code> is (a) guaranteed to be at least a byte and (b) naturally aligned to the OS/hardware it's running on so most likely these days to be 64 bit or (for many older systems) 32 bit.</p>\n", "LastEditorUserId": "166749", "LastActivityDate": "2013-01-10T14:00:03.487", "Score": "1", "CreationDate": "2013-01-10T11:41:32.987", "ParentId": "14256695", "CommentCount": "3", "OwnerUserId": "258009", "LastEditDate": "2013-01-10T14:00:03.487"}});