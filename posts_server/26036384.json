post_cb({"26036384": {"CommentCount": "6", "ViewCount": "141", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2014-09-25T10:33:28.387", "LastActivityDate": "2014-09-25T17:57:42.550", "Title": "Why derived constructor needs base destructor?", "FavoriteCount": "1", "LastEditDate": "2014-09-25T10:35:32.827", "Id": "26036384", "Score": "5", "Body": "<pre><code>class A{\n  public:\n   A();\n  private:\n   ~A();\n};\n\nclass B:public A{\n  public:\n    B(){};\n  private:\n   ~B();\n};\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p>I've got a compile error like this:</p>\n<pre><code>test.cpp: In constructor 'B::B()':\ntest.cpp:5:4: error: 'A::~A()' is private\ntest.cpp:10:8: error: within this context\n</code></pre>\n<p>I know the derived constructor need to invoke the base destructor, hence I set <code>A::A()</code> as <code>public</code>.\nHowever, why the compiler complains that it need public <code>A::~A()</code> either?</p>\n", "Tags": "<c++>", "OwnerUserId": "4078840", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26036384_26045084_1": {"section_id": 461, "quality": 0.6470588235294118, "length": 11}, "so_26036384_26045084_3": {"section_id": 407, "quality": 0.8, "length": 12}, "so_26036384_26045084_2": {"section_id": 437, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_26036384_26038319_0": {"section_id": 398, "quality": 1.0, "length": 12}, "so_26036384_26045084_1": {"section_id": 452, "quality": 0.6470588235294118, "length": 11}}, "n4659": {"so_26036384_26038319_0": {"section_id": 242, "quality": 0.5833333333333334, "length": 7}, "so_26036384_26045084_1": {"section_id": 484, "quality": 0.6470588235294118, "length": 11}, "so_26036384_26045084_2": {"section_id": 457, "quality": 0.6666666666666666, "length": 10}, "so_26036384_26045084_3": {"section_id": 425, "quality": 0.8, "length": 12}}}, "26038319": {"ParentId": "26036384", "CommentCount": "0", "Body": "<p>The closest specification I could find is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/wp/html/oct97/special.html#class.dtor\" rel=\"nofollow\">here - 12.4.10 <code>class.dtor</code></a>:</p>\n<blockquote>\n<p id=\"so_26036384_26038319_0\">... A  program  is ill-formed if an object of class type or array\n  thereof is declared and <strong>the destructor for the class is not accessible\n  at  the  point  of  the  declaration.</strong></p>\n</blockquote>\n<p><code>class B</code> is not able to access <code>private: ~A()</code>, but is <em>implicitly</em> declaring <code>class A</code> because it is a base class (it is almost the same as declaring first member variable - except empty base optimization).</p>\n<p><strong>I am not a language lawyer and not a native speaker</strong>, but the inaccessible base class destructor seems to be the problem and the above may explain why the error points to the constructor <code>B()</code> (the compiler may perform the checks when they are really needed, not before).</p>\n<p>The destructor <code>~A()</code> needs to be made at least <code>protected</code> or <code>B</code> friend of <code>A</code>.</p>\n", "OwnerUserId": "1722660", "PostTypeId": "2", "Id": "26038319", "Score": "4", "CreationDate": "2014-09-25T12:09:42.860", "LastActivityDate": "2014-09-25T12:09:42.860"}, "26045084": {"ParentId": "26036384", "CommentCount": "0", "Body": "<p>The C++ standards committee core working group defect report <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1424\" rel=\"nofollow\">1424</a> (submitted by Daniel Kr\u00fcgler on 2011-12-07) says:</p>\n<blockquote>\n<p id=\"so_26036384_26045084_0\">The current specification does not appear to say whether an implementation is permitted/required/forbidden to complain when a sub-object's destructor is inaccessible.</p>\n</blockquote>\n<p>This is fixed in C++14 by the addition of the notion of a destructor being <em>potentially invoked</em>. The current draft standard section <strong>12.6.2(10)</strong> says:</p>\n<blockquote>\n<p id=\"so_26036384_26045084_1\"><strong>In a non-delegating constructor, the destructor for each direct or virtual base class</strong> and for each non-static data member of class type <strong>is potentially invoked (12.4).</strong></p>\n<p id=\"so_26036384_26045084_2\">[ <em>Note:</em> This provision ensures that destructors can be called for fully-constructed sub-objects in case an exception is thrown (15.2). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>And in <strong>12.4(11)</strong>:</p>\n<blockquote>\n<p id=\"so_26036384_26045084_3\">A destructor is <em>potentially invoked</em> if it is invoked or as specified in 5.3.4 and 12.6.2. <strong>A program is ill-formed if a destructor that is potentially invoked is deleted or not accessible from the context of the invocation.</strong></p>\n</blockquote>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "26045084", "Score": "3", "CreationDate": "2014-09-25T17:57:42.550", "LastActivityDate": "2014-09-25T17:57:42.550"}, "26036477": {"ParentId": "26036384", "CommentCount": "0", "Body": "<p>Declare constructor and destructor as public (base class constructor anddestructor may be protected, if you ensure that is called by the subclasses only). Subclasses when constructed have base class instance created as a cubobject, so either explicit or implicit call of constructor and destructor are done</p>\n", "OwnerUserId": "2032021", "PostTypeId": "2", "Id": "26036477", "Score": "0", "CreationDate": "2014-09-25T10:37:49.257", "LastActivityDate": "2014-09-25T10:37:49.257"}});