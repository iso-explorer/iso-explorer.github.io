post_cb({"18212610": {"ParentId": "18212329", "CommentCount": "1", "Body": "<p>Without C++11 I think the best you can do is a fake type alias, that may require some code (constructor) duplicatation (which may not solve the real problem you're attempting):</p>\n<pre><code>template&lt; typename G, int N &gt; class Foo { /* ... */ };\n\ntemplate&lt;typename G&gt; class FooAlias : public Foo&lt;G, 0&gt; { };\n\ntemplate&lt; typename T &gt;\nclass Bar {\n  template&lt; typename G &gt; friend class FooAlias;\n\n  /* ... */\n};\n</code></pre>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "18212610", "Score": "1", "CreationDate": "2013-08-13T15:01:25.980", "LastActivityDate": "2013-08-13T15:01:25.980"}, "bq_ids": {"n4140": {"so_18212329_18212526_0": {"section_id": 133, "quality": 1.0, "length": 5}}, "n3337": {"so_18212329_18212526_0": {"section_id": 127, "quality": 1.0, "length": 5}}, "n4659": {"so_18212329_18212526_0": {"section_id": 137, "quality": 1.0, "length": 5}}}, "18212329": {"CommentCount": "0", "AcceptedAnswerId": "18212526", "CreationDate": "2013-08-13T14:49:20.297", "LastActivityDate": "2013-08-13T18:40:58.747", "PostTypeId": "1", "ViewCount": "396", "FavoriteCount": "2", "Title": "Partially specialized template friends", "Id": "18212329", "Score": "5", "Body": "<p>I have a class template</p>\n<pre><code>template&lt; typename G, int N &gt; class Foo { /* ... */ };\n</code></pre>\n<p>I want the specialization for <code>N=0</code> to be a friend of another class, but I don't know the syntax for it (and I could not find it out myself). I tried:</p>\n<pre><code>template&lt; typename T &gt;\nclass Bar {\n  template&lt; typename G &gt; friend class Foo&lt; G, 0 &gt;;\n\n  /* ... */\n};\n</code></pre>\n<p>I want for any type G <code>Foo&lt; G, 0 &gt;</code> to be a friend of <code>class Bar&lt; T &gt;</code>. What is the correct syntax for this?</p>\n<p>Thank you!</p>\n", "Tags": "<c++><templates><friend>", "OwnerUserId": "890793", "AnswerCount": "2"}, "18212526": {"ParentId": "18212329", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In C++03 that is not possible; the C++ standard 14.5.3/9 says the following:</p>\n<blockquote>\n<p id=\"so_18212329_18212526_0\">Friend declarations shall not declare partial specializations.</p>\n</blockquote>\n<p>As noted in another answer, there may be some workarounds for this issue, but the specific functionality you are asking for is not available in that standard.</p>\n<p>Luckily, C++11 is quite well supported nowadays, and with the ability to specify template aliases, we can achieve just this:</p>\n<pre><code>template &lt;typename, typename&gt; struct X{};\n\ntemplate &lt;typename T&gt; \nstruct Y\n{\n    template &lt;typename U&gt; using X_partial = X&lt;T, U&gt;;\n    template &lt;typename&gt; friend class X_partial;\n};\n</code></pre>\n", "OwnerUserId": "1056003", "LastEditorUserId": "1056003", "LastEditDate": "2013-08-13T18:40:58.747", "Id": "18212526", "Score": "2", "CreationDate": "2013-08-13T14:57:41.420", "LastActivityDate": "2013-08-13T18:40:58.747"}});