post_cb({"19886176": {"ParentId": "19886094", "LastEditDate": "2013-11-10T04:29:19.833", "CommentCount": "4", "CreationDate": "2013-11-10T04:09:59.943", "OwnerUserId": "2167655", "LastEditorUserId": "2167655", "PostTypeId": "2", "Id": "19886176", "Score": "3", "Body": "<pre><code>template &lt;typename... Ts&gt;                                                          \nstruct Test : Ts::template Nested&lt;Test&lt;Ts...&gt;&gt;...                                  \n{                                                                                  \n\n};  \n</code></pre>\n<p>This is the same answer as above but I figured I'd explain how it works. First in your example <code>Test</code> has no template param (which the compiler should warn you of), but which should we give it. The point of CRTP is to give the class you inherit from a template param that is the same as your type, that way it has access to your methods and members through the of the template param. Your type in this case is <code>Test&lt;Ts...&gt;</code> so that is what you have to pass it. As @aschepler already pointed out normally you could use <code>Test</code> by itself but it's not in scope until your already inside the class.  </p>\n<p><strong>I think this is a cleaner way of doing what you want.</strong> </p>\n<pre><code>template &lt;typename T&gt;                                                              \nstruct A {                                                                         \n    void bar (){                                                                   \n        static_cast&lt;T*&gt;(this)-&gt;val = 3;                                            \n    }                                                                              \n};                                                                                 \n\ntemplate &lt;typename T&gt;                                                              \nstruct B {                                                                         \n    void foo (){                                                                   \n        static_cast&lt;T*&gt;(this)-&gt;val = 90;                                           \n    }                                                                              \n};                                                                                 \n\n\ntemplate &lt;template&lt;class&gt; class ... Ts&gt;                                            \nstruct Test : Ts&lt;Test&lt;Ts...&gt;&gt;...                                                   \n{                                                                                  \n    int val;                                                                       \n};                                                                                 \n\nint main() {                                                                       \n    Test&lt;A,B&gt; test;                                                                \n    test.foo();                                                                    \n    test.bar();                                                                    \n    return 0;                                                                      \n}  \n</code></pre>\n", "LastActivityDate": "2013-11-10T04:29:19.833"}, "19886144": {"ParentId": "19886094", "LastEditDate": "2013-11-10T04:19:02.493", "CommentCount": "0", "CreationDate": "2013-11-10T04:05:10.267", "OwnerUserId": "1762344", "LastEditorUserId": "1762344", "PostTypeId": "2", "Id": "19886144", "Score": "2", "Body": "<p>This <a href=\"http://coliru.stacked-crooked.com/a/9730b521df93ceb7\" rel=\"nofollow\">works</a>:</p>\n<pre><code>template&lt;typename... Ts&gt;\nstruct Test : Ts::template Nested&lt;Test&lt;Ts...&gt;&gt;...\n//                                    ^^^^^^^\n{\n};\n</code></pre>\n<p>9/2:</p>\n<blockquote>\n<p id=\"so_19886094_19886144_0\">[...]. The class-name is also <strong>inserted into the <em>scope</em> of the class itself</strong>; this is known as the injected-class-name. For purposes of access checking, the injected-class-name is treated as if it were a public member name. [...]</p>\n</blockquote>\n<p>14.6.1/1:</p>\n<blockquote>\n<p id=\"so_19886094_19886144_1\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injectedclass-name can be used as a template-name or a type-name. When it is used with a template-argument-list, as a template-argument for a template template-parameter, or as the final identifier in the elaborated-typespecifier of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent to the template-name followed by the template-parameters of the class template enclosed in &lt;&gt;.</p>\n</blockquote>\n", "LastActivityDate": "2013-11-10T04:19:02.493"}, "19886177": {"ParentId": "19886094", "CommentCount": "1", "Body": "<p>The \"injected class name\" <code>Test</code> which can be used as an abbreviation of <code>Test&lt;Ts...&gt;</code> is not in scope where you tried to use <code>Nested&lt;Test&gt;</code>, since the class scope does not begin until the <code>{</code> token.</p>\n<p>Use</p>\n<pre><code>template&lt;typename... Ts&gt;\nstruct Test : public Ts::template Nested&lt;Test&lt;Ts...&gt;&gt;...\n{\n};\n</code></pre>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "19886177", "Score": "2", "CreationDate": "2013-11-10T04:10:07.697", "LastActivityDate": "2013-11-10T04:10:07.697"}, "bq_ids": {"n4140": {"so_19886094_19886144_1": {"section_id": 179, "quality": 0.9736842105263158, "length": 37}, "so_19886094_19886144_0": {"section_id": 5846, "quality": 0.9, "length": 18}}, "n3337": {"so_19886094_19886144_1": {"section_id": 173, "quality": 0.9736842105263158, "length": 37}, "so_19886094_19886144_0": {"section_id": 5616, "quality": 0.9, "length": 18}}, "n4659": {"so_19886094_19886144_1": {"section_id": 184, "quality": 0.9736842105263158, "length": 37}, "so_19886094_19886144_0": {"section_id": 7325, "quality": 0.9, "length": 18}}}, "19886094": {"CommentCount": "0", "ViewCount": "499", "PostTypeId": "1", "LastEditorUserId": "2167655", "CreationDate": "2013-11-10T03:54:34.207", "LastActivityDate": "2013-11-10T04:31:21.173", "Title": "How to derive from a nested class of a variadic template argument?", "AcceptedAnswerId": "19886176", "LastEditDate": "2013-11-10T04:31:21.173", "Id": "19886094", "Score": "2", "Body": "<p>Given the following two structs, one could derive from both nested 'Nested' classes, and call foo() and bar() from the derived object:</p>\n<pre><code>struct WithNested1 {\n    template&lt;class T&gt; struct Nested {\n        void foo();\n    };\n};\n\nstruct WithNested2 {\n    template&lt;class T&gt; struct Nested {\n        void bar();\n    };\n};\n\nstruct Test : WithNested1::Nested&lt;Test&gt;,\n              WithNested2::Nested&lt;Test&gt;\n{\n\n};\n\nTest test;\ntest.foo();\ntest.bar();\n</code></pre>\n<p><br>\nBut, if both of the outer classes were passed as variadic template arguments, how would you derive from them?</br></p>\n<p>For example, this fails to compile:</p>\n<pre><code>template&lt;typename... Ts&gt;\nstruct Test : Ts::template Nested&lt;Test&gt;...\n{\n\n};\n\nTest&lt;WithNested1, WithNested2&gt; test;\ntest.foo();\ntest.bar();\n</code></pre>\n<blockquote>\n<p id=\"so_19886094_19886094_0\">error: 'foo' : is not a member of 'Test'<br>\n  error: 'bar' : is not a member of 'Test'</br></p>\n</blockquote>\n<p>strangely, it compiles if the calls to foo() and bar() are removed.</p>\n", "Tags": "<c++><templates><c++11><variadic-templates><crtp>", "OwnerUserId": "402041", "AnswerCount": "3"}});