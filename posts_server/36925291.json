post_cb({"36926402": {"Id": "36926402", "PostTypeId": "2", "Body": "<p>The message seems pretty plain:</p>\n<blockquote>\n<p id=\"so_36925291_36926402_0\">error: implicit conversion from 'int' to 'const type' (aka 'const unsigned short') changes value from 1048560 to 65520 [-Werror,-Wconstant-conversion]</p>\n</blockquote>\n<p><code>mask &lt;&lt; shift</code> has value <code>1048560</code> (arising from <code>65535 &lt;&lt; 4</code>), and you assign it to <code>unsigned short</code>, which is defined to adjust the value <code>mod 65536</code>, giving <code>65520</code>.</p>\n<p>This last conversion is well-defined. The error message is because you passed compiler flags <code>-Werror,-Wconstant-conversion</code> requesting to get an error message in this situation anyway.  If you don't want this error then don't pass those flags.</p>\n<hr>\n<p>Although this particular usage was well-defined, there could be undefined behaviour for some inputs (namely, <code>shift</code> being <code>16</code> or greater, if you are on a 32-bit int system). So you should fix the function.</p>\n<p>To fix the function you need to be more careful in the <code>unsigned short</code> case, because of the supremely annoying rule about integer promotion of unsigned short to signed int.</p>\n<p>Here's one solution a bit different from the other offerings.. avoid the shift issue entirely, works for any shift size:</p>\n<pre><code>template&lt;unsigned int shift, typename T&gt;\nconstexpr T zero_right(T arg)\n{\n    T mask = -1;\n    for (int s = shift; s--; ) mask *= 2u;\n    return mask &amp; arg;\n}\n\n// Demo\nauto f() { return zero_right&lt;15&gt;((unsigned short)65535); }  //  mov eax, 32768\n</code></pre>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2016-04-28T22:53:06.423", "Score": "2", "CreationDate": "2016-04-28T22:14:34.000", "ParentId": "36925291", "CommentCount": "3", "OwnerUserId": "1505939", "LastEditDate": "2016-04-28T22:53:06.423"}, "36925610": {"Id": "36925610", "PostTypeId": "2", "Body": "<p>I don't know if this is exactly what you want, but it compiles:</p>\n<pre><code>template&lt;unsigned int shift&gt;\nunsigned short zero_right(unsigned short arg) {\n  using type = unsigned short;\n\n  //constexpr type mask = ~(type(0));\n  type right_zeros = ~(type(0));\n  right_zeros &lt;&lt;= shift;\n  return arg &amp; right_zeros;\n}\n\nint check() {\n  return zero_right&lt;4&gt;(16);\n}\n</code></pre>\n<hr>\n<p><strong>UPDATE:</strong></p>\n<blockquote>\n<p id=\"so_36925291_36925610_0\">Seems like you simply hushed the compiler by making sure it has no idea what is going on with the types.</p>\n</blockquote>\n<p>No</p>\n<p>First you get <code>right_zeros</code> with value <code>FFFF</code> (from <code>~0</code>). Normally, <code>~0</code> is <code>FFFFFFFFFFFFFF...</code> but because you're using <code>u16</code>, you get <code>FFFF</code>.</p>\n<p>Then, shift by 4 produces <code>FFFF0</code> [calculation is extended to 32 bits], but when stored back, only the rightmost 16 bits remain, so the value is <code>FFF0</code></p>\n<p>This is perfectly legal and defined behavior and you're taking advantage of the truncation. The compiler is <em>not</em> \"being fooled\". Actually, it works fine with or without truncation.</p>\n<p>You could make <code>right_zeros</code> into u32 or u64 if you wished, but then you'd need to add <code>right_zeros &amp;= 0xFFFF</code></p>\n<blockquote>\n<p id=\"so_36925291_36925610_1\">If there is an undefined behavior (the very essence of my question!) you simply made it undetectable.</p>\n</blockquote>\n<p>There is <em>no</em> UB based on the totality of your code, no matter what the compiler says.</p>\n<p>Actually, Tavian got it. Use an explicit cast:</p>\n<pre><code>constexpr type right_zeros = (type) (mask &lt;&lt; shift); // now clean\n</code></pre>\n<p>This is telling the compiler, amongst other things, that you <em>want</em> the truncation to 16 bits.</p>\n<p>If there were UB, then the compiler should still complain.</p>\n</hr>", "LastEditorUserId": "5382650", "LastActivityDate": "2016-04-28T21:51:47.180", "Score": "2", "CreationDate": "2016-04-28T21:17:02.503", "ParentId": "36925291", "CommentCount": "2", "OwnerUserId": "5382650", "LastEditDate": "2016-04-28T21:51:47.180"}, "36926198": {"Id": "36926198", "PostTypeId": "2", "Body": "<p>Yes, as you suspect, even after suppressing the compiler diagnostics, your code is strictly speaking not fully portable because of the promotion from unsigned short to signed int, bit arithmetic being done in signed int, and then signed int being converted back to unsigned short. You've managed to avoid undefined behaviour (I think, after a quick look), but the result is not guaranteed to be what you are hoping for. <code>(type)~(type)0</code> is not required to correspond to \"all bits one\" in type <code>type</code>; it's already iffy before the shift.</p>\n<p>To get something fully portable, simply make sure you do all your arithmetic in at least unsigned int (wider types if necessary, but never narrower). Then there won't be any promotions to signed types to worry about.</p>\n<pre><code>template&lt;unsigned int shift&gt;\nunsigned short zero_right(unsigned short arg) {\n  using type = unsigned short;\n\n  constexpr auto mask = ~(type(0) + 0U);\n  constexpr auto right_zeros = mask &lt;&lt; shift;\n  return arg &amp; right_zeros;\n}\n\nint check() {\n  return zero_right&lt;4&gt;(16);\n}\n</code></pre>\n", "LastEditorUserId": "743382", "LastActivityDate": "2016-04-28T22:03:14.727", "Score": "3", "CreationDate": "2016-04-28T21:56:50.680", "ParentId": "36925291", "CommentCount": "0", "OwnerUserId": "743382", "LastEditDate": "2016-04-28T22:03:14.727"}, "36925596": {"Id": "36925596", "PostTypeId": "2", "Body": "<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_36925291_36925596_0\"><strong>5.8 Shift operators [expr.shift]</strong></p>\n<p id=\"so_36925291_36925596_1\">1 \n  ...</p>\n<p id=\"so_36925291_36925596_2\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand.</p>\n</blockquote>\n<p>The expression</p>\n<pre><code>mask &lt;&lt; shift;\n</code></pre>\n<p>is evaluated <strong>after integral promotion is applied</strong> to <code>mask</code>. Hence, it evaluates to <code>1048560</code> if <code>sizeof(unsigned short)</code> is 2, which explains the message from clang.</p>\n<p>One way to avoid the overflow problem is to right shift first before performing a left shift, and move that to a function of its own.</p>\n<pre><code>template &lt;typename T, unsigned int shift&gt;\nconstexpr T right_zero_bits()\n{\n   // ~(T(0)) performs integral promotion, if needed\n   // T(~(T(0))) truncates the number to T, if needed.\n   return (T(~(T(0))) &gt;&gt; shift ) &lt;&lt; shift;\n}\n\ntemplate&lt;unsigned int shift&gt;\nunsigned short zero_right(unsigned short arg) {\n   return arg &amp; right_zero_bits&lt;unsigned short, shift&gt;();\n}\n</code></pre>\n", "LastEditorUserId": "434551", "LastActivityDate": "2016-04-28T22:22:01.290", "Score": "3", "CreationDate": "2016-04-28T21:15:52.283", "ParentId": "36925291", "CommentCount": "7", "OwnerUserId": "434551", "LastEditDate": "2016-04-28T22:22:01.290"}, "bq_ids": {"n4140": {"so_36925291_36925596_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 6146}}, "n3337": {"so_36925291_36925596_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 5909}}, "n4659": {"so_36925291_36925596_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 7642}}}, "36925291": {"ViewCount": "203", "Body": "<p>Let's consider the function (one of possible implementations of it) which would zero out right N bits of an unsigned short value (or any other unsigned integral type). The possible implementation could look like following:</p>\n<pre><code>template&lt;unsigned int shift&gt;\nunsigned short zero_right(unsigned short arg) {\n  using type = unsigned short;\n\n  constexpr type mask = ~(type(0));\n  constexpr type right_zeros = mask &lt;&lt; shift; // &lt;-- error here\n  return arg &amp; right_zeros;\n}\n\nint check() {\n  return zero_right&lt;4&gt;(16);\n}\n</code></pre>\n<p>With this code, all compilers I have access to complain, in one way or another, about possible overflow. CLang is the most explicit one, with following clear message:</p>\n<blockquote>\n<p id=\"so_36925291_36925291_0\">error: implicit conversion from 'int' to 'const type' (aka 'const\n  unsigned short') changes value from 1048560 to 65520\n  [-Werror,-Wconstant-conversion]</p>\n</blockquote>\n<p>This code looks well defined and clear as day to me, yet when 3 compilers complain, I am becoming very nervous. Am I missing something here? Is there really a chance something fishy is happening? </p>\n<p>P.S. While alternative implementations of zeriong out left X bits might be welcome and interesting, the primary focus of this question is of validity of code as posted.</p>\n", "AcceptedAnswerId": "36926402", "Title": "Bit-shifting left and discarding bits", "CreationDate": "2016-04-28T20:55:08.020", "Id": "36925291", "CommentCount": "11", "PostTypeId": "1", "LastActivityDate": "2016-04-28T22:53:06.423", "Score": "6", "OwnerUserId": "5245033", "Tags": "<c++><language-lawyer><bit-shift><integer-overflow>", "AnswerCount": "4"}});