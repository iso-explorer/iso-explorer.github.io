post_cb({"25127444": {"ParentId": "25127204", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>\u00a7 23.2.1 [container.requirements.general]/p3:</p>\n<blockquote>\n<p id=\"so_25127204_25127444_0\">For the components affected by this subclause that declare an\n  <code>allocator_type</code>, objects stored in these components shall be\n  constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code>\n  function and destroyed using the\n  <code>allocator_traits&lt;allocator_type&gt;::destroy</code> function (20.7.8.2).</p>\n</blockquote>\n<p>There's no provision allowing for those calls to be omitted beyond the as-if rule. In fact, I can't find a single instance of the word \"trivial\" in Clause 23, which specifies the standard library containers.</p>\n<p>As to why they specified type traits like <code>is_trivially_destructible</code>, you'll have to dig out the original proposal paper for the rationale. It's not used in the C++14 standard, but it is currently <a href=\"https://isocpp.org/files/papers/N4078.html\" rel=\"nofollow\">used to specify <code>std::optional</code></a> in the draft Library Fundamentals TS:</p>\n<blockquote>\n<pre><code>~optional();\n</code></pre>\n<ul>\n<li><p id=\"so_25127204_25127444_1\"><em>Effects</em>: If <code>is_trivially_destructible&lt;T&gt;::value != true</code> and <code>*this</code> contains a value, calls <code>val-&gt;T::~T()</code>.</p></li>\n<li><p id=\"so_25127204_25127444_2\"><em>Remarks</em>: If <code>is_trivially_destructible&lt;T&gt;::value == true</code> then this destructor shall be a trivial destructor.</p></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-04T21:12:18.860", "Id": "25127444", "Score": "7", "CreationDate": "2014-08-04T20:59:47.363", "LastActivityDate": "2014-08-04T21:12:18.860"}, "bq_ids": {"n4140": {"so_25127204_25127444_0": {"section_id": 704, "quality": 0.8888888888888888, "length": 16}, "so_25127204_25127444_2": {"section_id": 4706, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_25127204_25127444_0": {"section_id": 694, "quality": 0.8888888888888888, "length": 16}, "so_25127204_25127444_2": {"section_id": 5485, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_25127204_25127444_0": {"section_id": 733, "quality": 0.7777777777777778, "length": 14}, "so_25127204_25127444_2": {"section_id": 5051, "quality": 0.7142857142857143, "length": 5}, "so_25127204_25127444_1": {"section_id": 5050, "quality": 0.5714285714285714, "length": 4}}}, "25127204": {"CommentCount": "46", "AcceptedAnswerId": "25127444", "CreationDate": "2014-08-04T20:43:22.840", "LastActivityDate": "2014-08-04T21:12:18.860", "PostTypeId": "1", "ViewCount": "194", "FavoriteCount": "0", "Title": "Are STL containers allowed to skip calling allocator::construct and allocator::destroy if the object is trivially constructible/destructible?", "Id": "25127204", "Score": "6", "Body": "<p>The question is in the title. Is this allowed for containers, or are the allocator's methods guaranteed to be called even when the object is trivially constructible/destructible?</p>\n<p>I did try to search for this but came back empty-handed... but if it's a duplicate please let me know.</p>\n", "Tags": "<c++><allocator>", "OwnerUserId": "541686", "AnswerCount": "1"}});