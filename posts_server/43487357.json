post_cb({"bq_ids": {"n4140": {"so_43487357_43487579_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2768}, "so_43487357_43487468_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 2778}, "so_43487357_43487579_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 2754}}, "n3337": {"so_43487357_43487579_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2729}, "so_43487357_43487468_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 2739}, "so_43487357_43487579_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 2715}}, "n4659": {"so_43487357_43487579_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3506}, "so_43487357_43487468_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 3516}, "so_43487357_43487579_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3492}}}, "43487468": {"Id": "43487468", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/thread/mutex\" rel=\"nofollow noreferrer\">cppreference <code>std::mutex</code></a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_43487357_43487468_0\">The behavior of a program is undefined if a mutex is destroyed while still owned by any threads, <strong>or a thread terminates while owning a mutex.</strong></p>\n</blockquote>\n<p>From the same site on <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/try_lock\" rel=\"nofollow noreferrer\"><code>std::mutex::try_lock</code></a> and as <a href=\"https://stackoverflow.com/a/43487488/4143855\">TC points out in their answer</a>:</p>\n<blockquote>\n<p id=\"so_43487357_43487468_1\">If try_lock is called by a thread that already owns the mutex, the behavior is undefined.</p>\n</blockquote>\n<p>And also <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/unlock\" rel=\"nofollow noreferrer\"><code>std::mutex::unlock</code></a> and as <a href=\"https://stackoverflow.com/a/43487488/4143855\">TC points out in their answer</a>:</p>\n<blockquote>\n<p id=\"so_43487357_43487468_2\">The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>Both your functions and threads cause undefined behaviour:</p>\n<ol>\n<li><code>increment</code> calls <code>lock()</code> and then <code>try_lock()</code>: undefined behaviour</li>\n<li><code>increment1</code> calls <code>unlock()</code> before owning the mutex: undefined behaviour</li>\n</ol>\n<p>Removing the <code>try_lock()</code> from <code>increment</code> will still result in undefined behaviour if you don't call <code>unlock()</code> before the thread ends.</p>\n<p>You should prefer to use a <a href=\"http://en.cppreference.com/w/cpp/thread/lock_guard\" rel=\"nofollow noreferrer\"><code>std::lock_guard</code></a>, or for a simple <code>int</code> you could also use <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow noreferrer\"><code>std::atomic</code></a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-19T06:02:38.027", "Score": "-1", "CreationDate": "2017-04-19T05:52:26.420", "ParentId": "43487357", "CommentCount": "1", "OwnerUserId": "4143855", "LastEditDate": "2017-05-23T11:46:58.117"}, "43487357": {"ViewCount": "186", "Body": "<p>I was reading differences between binary semaphore and mutex (<a href=\"https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex\">Difference between binary semaphore and mutex</a>) and one thing that i want to verify is that when a task locks (acquires) a mutex only it can unlock (release) it. If another task tries to unlock a mutex it hasn\u2019t locked (thus doesn\u2019t own) then an error condition is encountered and, most importantly, the mutex is not unlocked and for that i created below code in c++14:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\nusing namespace std;\n\nint counter;\nint i;\nstd::mutex g_pages_mutex;\nvoid increment()\n{\n    std::cout&lt;&lt;\"increment....\"&lt;&lt;std::endl;    \n    g_pages_mutex.lock();\n    bool flag = g_pages_mutex.try_lock();\n    std::cout&lt;&lt;\"increment Return value is \"&lt;&lt;flag&lt;&lt;std::endl;\n    counter++;\n    std::this_thread::sleep_for(5s);\n}\nvoid increment1()\n{\n    std::this_thread::sleep_for(5s);    \n    std::cout&lt;&lt;\"increment1....\"&lt;&lt;std::endl;       \n    g_pages_mutex.unlock();    \n    counter++;\n    bool flag = g_pages_mutex.try_lock();\n    std::cout&lt;&lt;\"increment1 Return value is \"&lt;&lt;flag&lt;&lt;std::endl;\n}\nint main()\n{\n    counter = 0;\n    std::thread t(increment);\n    std::thread t1(increment1);\n    t.join();\n    t1.join();\n    return 0;\n}\n</code></pre>\n<p>However with this example I was able to unlock mutex from thread that doesn't own that , so just want is there some understanding gap or is this issue in c++14 std::mutex ?</p>\n", "AcceptedAnswerId": "43487488", "Title": "How std::mutex got unlocked in different thread?", "CreationDate": "2017-04-19T05:45:49.473", "Id": "43487357", "CommentCount": "2", "LastEditDate": "2017-05-23T12:25:40.890", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-19T06:02:38.027", "Score": "-1", "OwnerUserId": "3600304", "Tags": "<c++><multithreading><c++14><mutex>", "AnswerCount": "3"}, "43487579": {"Id": "43487579", "PostTypeId": "2", "Body": "<p>The precondition for calling <code>unlock</code> is holding an ownership of the mutex, according to (std)30.4.1.2:</p>\n<blockquote>\n<p id=\"so_43487357_43487579_0\">The expression m.unlock() shall be well-formed and have the following semantics:</p>\n<p id=\"so_43487357_43487579_1\">Requires: The calling thread shall own the mutex.</p>\n</blockquote>\n<p>Since thread executing <code>increment1</code> does not hold the ownership of the mutex it detonated undefined behavior.</p>\n", "LastActivityDate": "2017-04-19T06:00:16.860", "CommentCount": "0", "CreationDate": "2017-04-19T06:00:16.860", "ParentId": "43487357", "Score": "0", "OwnerUserId": "7860670"}, "43487488": {"Id": "43487488", "PostTypeId": "2", "Body": "<p>Calling <code>try_lock</code> on a <code>std::mutex</code> (which is not recursive) owned by the calling thread, calling <code>unlock</code> on a mutex not owned by the calling thread, and ending a thread while holding a mutex, all result in undefined behavior. </p>\n<p>It might appear to succeed, it might fail and throw an exception, it might format your hard drive, it might summon nasal demons, it might time travel and correct your code for you, or it might do something else. As far as the standard is concerned, <em>anything</em> is permissible.</p>\n", "LastActivityDate": "2017-04-19T05:54:05.257", "CommentCount": "0", "CreationDate": "2017-04-19T05:54:05.257", "ParentId": "43487357", "Score": "3", "OwnerUserId": "2756719"}});