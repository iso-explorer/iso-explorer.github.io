post_cb({"2188001": {"Id": "2188001", "PostTypeId": "2", "Body": "<p>Off the top of my head:</p>\n<pre><code>template &lt;class element_type&gt;\nclass matrix\n{\npublic:\n    matrix(size_t width, size_t height): m_stride(width), m_height(height), m_storage(width*height) {  }\n\n    element_type &amp;operator()(size_t row, size_t column)\n    {\n        // column major\n        return m_storage[std::slice(column, m_height, m_stride)][row];\n\n        // row major\n        return m_storage[std::slice(row, m_stride, m_height)][column];\n    }\n\nprivate:\n    std::valarray&lt;element_type&gt; m_storage;\n    size_t m_stride;\n    size_t m_height;\n};\n</code></pre>\n<p><code>std::valarray</code> provides many interesting ways to access elements, via slices, masks, multidimentional slices, or an indirection table. See <code>std::slice_array</code>, <code>std::gslice_array</code>, <code>std::mask_array</code>, and <code>std::indirect_array</code> for more details.</p>\n", "LastEditorUserId": "6210", "LastActivityDate": "2012-08-07T19:11:29.490", "Score": "10", "CreationDate": "2010-02-02T21:54:15.637", "ParentId": "2187648", "CommentCount": "11", "OwnerUserId": "6210", "LastEditDate": "2012-08-07T19:11:29.490"}, "bq_ids": {"n4140": {"so_2187648_2187963_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 3394}, "so_2187648_2187963_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 3735}, "so_2187648_2187963_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3393}, "so_2187648_2187963_5": {"length": 23, "quality": 0.9583333333333334, "section_id": 3760}}, "n3337": {"so_2187648_2187963_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 3263}, "so_2187648_2187963_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 3597}, "so_2187648_2187963_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3262}, "so_2187648_2187963_5": {"length": 23, "quality": 0.9583333333333334, "section_id": 3622}}, "n4659": {"so_2187648_2187963_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 4152}, "so_2187648_2187963_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 4502}, "so_2187648_2187963_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 4151}, "so_2187648_2187963_5": {"length": 16, "quality": 0.6666666666666666, "section_id": 4528}}}, "47483028": {"Id": "47483028", "PostTypeId": "2", "Body": "<p>If you want to test for the multidimensional array to be a contiguous (columns x rows) block. You can see this example with <strong>valarray</strong>.</p>\n<pre><code>template&lt;class T&gt;\nclass Array: public std::valarray&lt;T&gt; {\n  size_t row,col; \npublic:\n  Array(){}\n  Array(size_t nx) : std::valarray&lt;T&gt;(nx){row=nx,col=1;}\n  Array(size_t nx, size_t ny) : std::valarray&lt;T&gt;(nx*ny){row=nx,col=ny;}\n  virtual ~Array(){}\n  T&amp; operator()(size_t i,size_t j) { return (*this)[i*col+j];}\n  size_t Size(size_t n) const { return (n&lt;2) ? col: row;}\n};\n</code></pre>\n", "LastActivityDate": "2017-11-25T05:50:19.523", "CommentCount": "0", "CreationDate": "2017-11-25T05:50:19.523", "ParentId": "2187648", "Score": "0", "OwnerUserId": "6261539"}, "2187963": {"Id": "2187963", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;valarray&gt;\n\nusing namespace std;\n\ntypedef valarray&lt;valarray&lt;int&gt; &gt; va2d;\n\nint main()\n{\n    int data[][3] = { {1, 2, 3}, {4, 5, 6} };\n    va2d mat(valarray&lt;int&gt;(3), 2);\n    for (int i = 0; i &lt; 2; ++i)\n    {\n        for (int j = 0; j &lt; 3; ++j)\n           mat[ i ][ j ] = data[ i ][ j ];\n    }\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n           cout &lt;&lt; mat[ i ][ j ] &lt;&lt; endl;\n}\n</code></pre>\n<p>More on <code>valarray</code>:</p>\n<ul>\n<li>It is optimized for numeric computation.</li>\n<li>It is a <code>vector</code> like container with special member functions for slicing and dicing.</li>\n<li>No iterators</li>\n<li>Designed for vector machines and perform poorly on current ones: <code>vector</code> access may be faster</li>\n<li>Was not supported by all compilers (check the documentation)  / poorly implemented</li>\n<li>See 26.1 for the types that can be used as a parameter to <code>valarray&lt;T&gt;</code>: E.g:</li>\n</ul>\n<blockquote>\n<p id=\"so_2187648_2187963_0\">3 In addition, many member and related\n  functions of valarray can be\n  successfully instantiated and will\n  exhibit well-defined behavior if and\n  only if T satisfies additional\n  requirements specified for each such\n  member or related function. </p>\n<p id=\"so_2187648_2187963_1\">4 [\n  Example: It is valid to instantiate\n  valarray, but operator&gt;()\n  will not be successfully instantiated\n  for valarray operands, since\n  complex does not have any ordering\n  operators. \u2014end example ]</p>\n</blockquote>\n<p>Edit#2: The standard gurantees that <code>vector</code>, like arrays, always use contiguous memory. Also, we have:</p>\n<blockquote>\n<p id=\"so_2187648_2187963_2\"><strong>26.5.2 Class template valarray</strong></p>\n<p id=\"so_2187648_2187963_3\">1 The class template valarray is a\n  one-dimensional smart array, with\n  elements numbered sequentially from\n  zero. It is a representation of the\n  mathematical concept of an ordered set\n  of values. The illusion of higher\n  dimensionality may be produced by the\n  familiar idiom of computed indices,\n  together with the powerful\n  subsetting capabilities provided by\n  the generalized subscript operators.</p>\n</blockquote>\n<p>and further:</p>\n<blockquote>\n<p id=\"so_2187648_2187963_4\"><strong>26.5.2.3 valarray element access</strong></p>\n<p id=\"so_2187648_2187963_5\">4 Likewise, the expression &amp;a[i] !=\n  &amp;b[j] evaluates as true for any two\n  arrays a and b and for any size_t i\n  and size_t j such that i is less than\n  the length of a and j is less than the\n  length of b. This property indicates\n  an absence of aliasing and may be used\n  to advantage by optimizing compilers.</p>\n</blockquote>\n", "LastEditorUserId": "1536976", "LastActivityDate": "2015-05-29T08:40:27.193", "Score": "5", "CreationDate": "2010-02-02T21:47:17.773", "ParentId": "2187648", "CommentCount": "7", "OwnerUserId": "66692", "LastEditDate": "2015-05-29T08:40:27.193"}, "2187826": {"Id": "2187826", "PostTypeId": "2", "Body": "<p><a href=\"http://www.linuxtopia.org/online_books/programming_books/c++_practical_programming/c++_practical_programming_202.html\" rel=\"nofollow noreferrer\">Here's</a> an example that includes a bit of matrix manipulation</p>\n", "LastActivityDate": "2010-02-02T21:24:52.350", "CommentCount": "3", "CreationDate": "2010-02-02T21:24:52.350", "ParentId": "2187648", "Score": "0", "OwnerUserId": "223046"}, "2187648": {"ViewCount": "7874", "Body": "<p>How can I use a <code>std::valarray</code> to store/manipulate a 2D array?</p>\n<p>I'd like to see an example of a 2D array with elements accessed by row/column indices. Something like this pseudo code:</p>\n<pre><code>matrix(i,j) = 42;\n</code></pre>\n<p>An example of how to initialize such an array would also be nice.</p>\n<p>I'm already aware of Boost.MultiArray, Boost.uBlas, and Blitz++.</p>\n<p>Feel free to answer why I shouldn't use valarray for my use case. However, I want the memory for the multidimensional array to be a contiguous (columns x rows) block. No Java-style nested arrays.</p>\n", "AcceptedAnswerId": "2188001", "Title": "How can I use a std::valarray to store/manipulate a contiguous 2D array?", "CreationDate": "2010-02-02T20:57:59.683", "Id": "2187648", "CommentCount": "3", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-05-29T08:35:59.647", "LastEditorUserId": "1536976", "LastActivityDate": "2017-11-25T05:50:19.523", "Score": "7", "OwnerUserId": "245265", "Tags": "<c++><multidimensional-array><c++-standard-library>", "AnswerCount": "4"}});