post_cb({"17957366": {"ViewCount": "466", "Body": "<p>Take from <a href=\"http://stdcxx.apache.org/doc/stdlibug/15-2.html\" rel=\"noreferrer\">here</a> (which is quite old):</p>\n<blockquote>\n<p id=\"so_17957366_17957366_0\">It's also important that the type used for the allocator template\n  parameter and the type used as the element type in a standard\n  container agree. For instance:</p>\n<pre><code>std::list&lt;int, std::allocator&lt;long&gt; &gt;                    // Wrong!\n</code></pre>\n<p id=\"so_17957366_17957366_1\">won't work.</p>\n</blockquote>\n<p><strong>Question</strong></p>\n<p>Is the above statement correct (or was it ever correct)? Any tests I have done seem to work fine no matter what I put for <code>T</code> in <code>std::allocator</code>. For example, <code>std::vector&lt;int, std::allocator&lt;std::string&gt;&gt;</code> compiled and worked fine pushing back and erasing elements, etc.\n(From what I understand <code>std::allocator&lt;std::string&gt;::rebind&lt;int&gt;::other</code> is the magic that makes this work).</p>\n", "AcceptedAnswerId": "17958229", "Title": "Is it wrong if the standard container element type and std::allocator type are different?", "CreationDate": "2013-07-30T21:04:17.817", "Id": "17957366", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-07-31T03:24:18.303", "Score": "10", "OwnerUserId": "906773", "Tags": "<c++>", "AnswerCount": "2"}, "17961043": {"Id": "17961043", "PostTypeId": "2", "Body": "<p>I'm adding an answer here to clarify the difference between ill-formed and undefined behavior.</p>\n<p>[intro.compliance]/p1:</p>\n<blockquote>\n<p id=\"so_17957366_17961043_0\">The set of diagnosable rules consists of all syntactic and semantic\n  rules in this International Standard except for those rules containing\n  an explicit notation that \u201cno diagnostic is required\u201d or which are\n  described as resulting in \u201cundefined behavior.\u201d</p>\n</blockquote>\n<p>[defns.ill.formed]:</p>\n<blockquote>\n<p id=\"so_17957366_17961043_1\">program that is not well formed</p>\n</blockquote>\n<p>[defns.well.formed]</p>\n<blockquote>\n<p id=\"so_17957366_17961043_2\">C++ program constructed according to the syntax rules, diagnosable\n  semantic rules, and the One Definition Rule (3.2).</p>\n</blockquote>\n<p>In English:  an ill-formed program shall have a diagnostic associated with it.  Undefined behavior can do anything:</p>\n<ol>\n<li>It can compile and execute as you intended.</li>\n<li>It can issue a diagnostic.</li>\n<li>It can delete the code you have written.</li>\n<li>It can reformat the nearest disk.</li>\n</ol>\n<p>(all but the 4th routinely happen in practice)</p>\n<p>Undefined behavior is very bad, and imho, the C and C++ standards apply that specification much too liberally.</p>\n<p>Technically, violating a <em>Requires</em> clause results in undefined behavior.</p>\n<p>[res.on.required]/p1:</p>\n<blockquote>\n<p id=\"so_17957366_17961043_3\">Violation of the preconditions specified in a function\u2019s Requires:\n  paragraph results in undefined behavior unless the function\u2019s Throws:\n  paragraph specifies throwing an exception when the precondition is\n  violated.</p>\n</blockquote>\n<p>As noted by MSN, <code>allocator_type::value_type</code> shall be the same as <code>container::value_type</code> as stated in Table 99 -- Allocator-aware container <strong>requirements</strong>.</p>\n<pre><code>allocator_type A       Requires:  allocator_type::value_type \n                                  is the same as X::value_type.\n</code></pre>\n<p>(<code>X</code> denotes an allocator-aware container class with a <code>value_type</code> of <code>T</code> using allocator of type <code>A</code>)</p>\n<p>So a violation such as:</p>\n<pre><code>std::list&lt;int, std::allocator&lt;long&gt; &gt;  \n</code></pre>\n<p>is undefined behavior.  So it:</p>\n<ol>\n<li>can compile and execute as you intended.</li>\n<li>can issue a diagnostic.</li>\n<li>can delete the code you have written.</li>\n<li>can reformat the nearest disk.</li>\n</ol>\n<p>Just very recently (within weeks of me writing this), libc++ (<a href=\"http://libcxx.llvm.org\">http://libcxx.llvm.org</a>) has started diagnosing this undefined behavior with <code>static_assert</code> so that you get the bad news asap.</p>\n<p>We decided to go this direction, instead of allowing the behavior because the containers are not set up to allow conversions among closely related types.  For example:</p>\n<pre><code>std::list&lt;int, std::allocator&lt;long&gt;&gt;  list1;\nstd::list&lt;int&gt;                        list2 = list1;  // is specified to not work\n</code></pre>\n<p>I.e. if you start treating <code>list1</code> and <code>list2</code> as equivalent types because the <code>std::allocator</code> gets <code>rebind</code>'d anyway, you're going to get disappointed down the road as you discover the two lists are really different types and not designed to interoperate anyway.  So it is really best to get the bad news asap, instead of finding out 2 months, or 2 years later, when you try to use them as equivalent types.</p>\n<p>Perhaps a future standard will treat <code>list1</code> and <code>list2</code> as equivalent types.  It is mostly technically possible (<code>std::is_same</code> would likely not work).  But there are no proposals that I've heard of in this direction.  This direction does not seem likely to me.  And with <code>static_assert</code>, the error is easily diagnosable.  Instead I would like to see the standard move in the direction of making this code ill-formed instead of undefined.  The hardest part in doing so would be word-smithing the standard, and not in the std::lib implementation.</p>\n", "LastActivityDate": "2013-07-31T03:24:18.303", "CommentCount": "2", "CreationDate": "2013-07-31T03:24:18.303", "ParentId": "17957366", "Score": "7", "OwnerUserId": "576911"}, "17958229": {"Id": "17958229", "PostTypeId": "2", "Body": "<p>EDIT: In [containers.requirements.general], the Allocator-aware container requirements indicate that the <code>allocator_type::value_type</code> is the same as <code>Container::value_type</code>.</p>\n<p>So it's ill formed to pass in an allocator type with a different <code>value_type</code>, although at least one implementation simply uses <code>allocator_traits&lt;...&gt;::rebind&lt;value_type&gt;</code> to get the correct allocator.</p>\n", "LastEditorUserId": "6210", "LastActivityDate": "2013-07-30T22:17:23.253", "Score": "5", "CreationDate": "2013-07-30T22:00:34.957", "ParentId": "17957366", "CommentCount": "3", "OwnerUserId": "6210", "LastEditDate": "2013-07-30T22:17:23.253"}, "bq_ids": {"n4140": {"so_17957366_17961043_2": {"length": 10, "quality": 1.0, "section_id": 5768}, "so_17957366_17961043_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 6328}, "so_17957366_17961043_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5769}}, "n3337": {"so_17957366_17961043_2": {"length": 10, "quality": 1.0, "section_id": 5541}, "so_17957366_17961043_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 6085}, "so_17957366_17961043_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5542}}, "n4659": {"so_17957366_17961043_2": {"length": 7, "quality": 0.7, "section_id": 7225}, "so_17957366_17961043_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 7838}, "so_17957366_17961043_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7226}}}});