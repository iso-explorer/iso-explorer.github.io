post_cb({"1876659": {"ParentId": "1876633", "CommentCount": "1", "Body": "<p>because of the way memory is allocated, there will be padding after a short</p>\n", "OwnerUserId": "219762", "PostTypeId": "2", "Id": "1876659", "Score": "0", "CreationDate": "2009-12-09T20:28:20.093", "LastActivityDate": "2009-12-09T20:28:20.093"}, "1876648": {"ParentId": "1876633", "CommentCount": "1", "Body": "<p>I think your compiler uses 4-byte allignment for the fields.</p>\n", "OwnerUserId": "225703", "PostTypeId": "2", "Id": "1876648", "Score": "5", "CreationDate": "2009-12-09T20:27:27.317", "LastActivityDate": "2009-12-09T20:27:27.317"}, "1876666": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p>This is due to alignment - the compiler has to do some padding.</p>\n", "OwnerUserId": "165132", "PostTypeId": "2", "Id": "1876666", "Score": "0", "CreationDate": "2009-12-09T20:29:37.610", "LastActivityDate": "2009-12-09T20:29:37.610"}, "1876653": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p>It's because the 4 byte ints are aligned to a 4 byte boundry, so there are 2 bytes of padding after bfType.</p>\n", "OwnerUserId": "197514", "PostTypeId": "2", "Id": "1876653", "Score": "12", "CreationDate": "2009-12-09T20:27:48.077", "LastActivityDate": "2009-12-09T20:27:48.077"}, "1876633": {"CommentCount": "6", "ViewCount": "907", "PostTypeId": "1", "ClosedDate": "2009-12-09T20:53:29.210", "LastEditorUserId": "-1", "CreationDate": "2009-12-09T20:25:32.467", "LastActivityDate": "2016-12-30T20:11:32.990", "LastEditDate": "2017-05-23T12:33:47.130", "FavoriteCount": "0", "Title": "C++ struct size: 2+4+2+2+4 = 16", "Id": "1876633", "Score": "3", "Body": "<blockquote>\n<p id=\"so_1876633_1876633_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member\">Why isn\u2019t sizeof for a struct equal to the sum of sizeof of each member?</a> </br></p>\n</blockquote>\n<p>Why is the <code>sizeof();</code> of this structure 16 bytes?  I'm compiling in g++.</p>\n<pre><code>struct bitmapfileheader {       \n     unsigned short bfType;\n     unsigned int bfSize;\n     unsigned short bfReserved1;\n     unsigned short bfReserved2;\n     unsigned int bfOffBits;   \n   };\n</code></pre>\n", "Tags": "<c++><sizeof><structure-packing>", "OwnerUserId": "228278", "AnswerCount": "9"}, "1876715": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p>ISO C++03, 9.2[class.mem]/12:</p>\n<blockquote>\n<p id=\"so_1876633_1876715_0\">Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated so that later members have higher addresses within a class object. The order of allocation of nonstatic data members separated by an access-specifier is unspecified (11.1). <strong>Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other</strong>; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "1876715", "Score": "1", "CreationDate": "2009-12-09T20:37:26.967", "LastActivityDate": "2009-12-09T20:37:26.967"}, "1876656": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p><strong>Alignment.</strong>\nLikely on your platform ints have to be 4byte aligned and shorts are 2byte aligned.</p>\n<pre><code>+0 -1 : bfType\n+2 -3 : &lt;padding&gt;\n+4 -7: bfSize\n+8 -9: bfReserve1\n+10 -11: bfReserve2\n+12 -15: bfOffBits\n-------------\n16 bytes\n</code></pre>\n<p>Alignment is good because unaligned structures require extra work for many architectures.</p>\n", "OwnerUserId": "9353", "PostTypeId": "2", "Id": "1876656", "Score": "8", "CreationDate": "2009-12-09T20:28:04.473", "LastActivityDate": "2009-12-09T20:28:04.473"}, "1876649": {"ParentId": "1876633", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2009-12-09T20:27:30.810", "Score": "7", "LastEditorUserId": "224346", "LastEditDate": "2009-12-09T20:32:40.817", "Id": "1876649", "OwnerUserId": "224346", "Body": "<p>The individual fields in a structure need to be aligned appropriately. The compiler will pad additional space in the structure in order to satisfy alignment requirements.</p>\n<p>If you don't want this, you can use the <code>UNALIGNED</code> macro.</p>\n", "LastActivityDate": "2009-12-09T20:32:40.817"}, "1876690": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p>U can pragma pack the structure to avoid padding</p>\n", "OwnerUserId": "224640", "PostTypeId": "2", "Id": "1876690", "Score": "1", "CreationDate": "2009-12-09T20:33:35.420", "LastActivityDate": "2009-12-09T20:33:35.420"}, "bq_ids": {"n4140": {"so_1876633_1876715_0": {"section_id": 5873, "quality": 0.8235294117647058, "length": 42}}, "n3337": {"so_1876633_1876715_0": {"section_id": 5644, "quality": 0.8235294117647058, "length": 42}}, "n4659": {"so_1876633_1876715_0": {"section_id": 7356, "quality": 0.8235294117647058, "length": 42}}}, "1876763": {"ParentId": "1876633", "CommentCount": "0", "Body": "<p>This issue comes because of a concept known as <em>alignment</em>. In many cases, it is desirable to have a number placed at an address that is a multiple of the size of the number in bytes (up to some maximum, often the pointer size of the platform). A variable so placed is said to be <em>aligned to a n-byte boundary</em>, where <em>n</em> is the number. The exact effects of this depend on the processor. Many processors perform math faster if the data is properly aligned. Some are even incapable of performing operations (sometimes even load operations) on unsuitably-aligned data - in order to work on such data, it has to be loaded into two registers and then a series of bit shifts and masks need to be performed to get a usable value, and then it needs to be put back. Think of it like storing half of the <code>int</code> in each of two buckets and needing to put them together to use it, rather than simply storing the whole <code>int</code> in one bucket.</p>\n<p>In your case, the initial <code>bfType</code> likely needs to be aligned to a 2-byte boundary, while <code>bfSize</code> likely needs to be aligned to a 4-byte boundary. The compiler has to accomodate this by aligning the entire struct to 4 bytes, and leaving 2 unused bytes between <code>bfType</code> and <code>bfSize</code>.</p>\n<p>When compiling on the same system, however, the padding is probably going to be consistent, possibly depending on compiler options and the specific ABI used (generally, you're safe on the same platform unless you are trying to make things incompatible). You can freely make another struct with the same first 5 members, and they will take up 16 bytes of the other struct, in the exact same positions.</p>\n<p>If you really need to avoid this behavior, you will have to check your compiler documentation. Most compilers offer an attribute or keyword to declare a variable as having no alignment, and another one to indicate that a struct should have no padding. But these are rarely necessary in the general course of things.</p>\n", "OwnerUserId": "16855", "PostTypeId": "2", "Id": "1876763", "Score": "2", "CreationDate": "2009-12-09T20:45:03.450", "LastActivityDate": "2009-12-09T20:45:03.450"}});