post_cb({"43677844": {"Id": "43677844", "PostTypeId": "2", "Body": "<p>I'm surprised no one has mentioned this cheap counterexample yet:</p>\n<pre><code>struct foo {\n  static foo f;\n  // might seem dubious but doesn't violate anything\n  void* operator new(size_t, void* p) {return &amp;f;}\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2c030d00c5f05a6b\" rel=\"nofollow noreferrer\">Demo on Coliru</a>.</p>\n<p>Unless a class-specific placement version is called, however, your assertion should hold. Both expressions have to represent the same address as explained in the other answer (the main point being that the standard non-allocating <code>operator new</code> simply returns the pointer argument and the new expression not doing anything fancy), and neither of these is a pointer past the end of some object so, by [expr.eq]/2, they compare equal.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2017-04-28T11:00:31.303", "Score": "4", "CreationDate": "2017-04-28T10:19:25.647", "ParentId": "40897533", "CommentCount": "9", "OwnerUserId": "3647361", "LastEditDate": "2017-04-28T11:00:31.303"}, "40897533": {"ViewCount": "629", "Body": "<p>Consider the following C++14 code:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;new&gt;\n#include &lt;type_traits&gt;\n\nstruct NonStandardLayout\n{\n    // ...\n};\n\nint main()\n{\n    using T = NonStandardLayout;\n\n    std::aligned_storage_t&lt; sizeof(T), alignof(T) &gt; storage;\n    T *const valid_ptr = new(static_cast&lt;void *&gt;(&amp;storage)) T;\n\n    T *const maybe_ptr = reinterpret_cast&lt;T *&gt;(&amp;storage);\n    assert(maybe_ptr == valid_ptr); // ???\n\n    valid_ptr-&gt;T::~T();\n    return 0;\n}\n</code></pre>\n<p>Is it guaranteed by the standard that the assert in the example will never fail, for any type T?</p>\n<h2>Discussion</h2>\n<p>Looking in the latest standard (<a href=\"http://eel.is/c++draft/\" rel=\"noreferrer\">http://eel.is/c++draft/</a>), I cannot see any reference to this particular scenario but I have found the following paragraphs that arguably points to the answer 'yes'.</p>\n<p>Is it correct of me to think that\n[expr.new/15]\nand\n[new.delete.placement/2]\ntogether states that the value of <code>valid_ptr</code> will equal the address of <code>storage</code>, always?</p>\n<p>If so, is it true that the <code>reinterpret_cast</code> will yield a pointer to a fully constructed object? Because,\n[expr.reinterpret.cast/7],\n[expr.static.cast/13]\nand\n[basic.compound/4]\ntogether seem to indicate that it should be the case.</p>\n<p>From my observations, library implementations of the default allocator seem to cast similar to this and without worry! Is it <em>really</em> safe to cast like this?</p>\n<p>How can we be sure that the two pointers will be the same, or can we?</p>\n", "AcceptedAnswerId": "43677844", "Title": "Return value of placement new", "CreationDate": "2016-11-30T20:25:47.713", "Id": "40897533", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-11-30T20:27:08.910", "LastEditorUserId": "6451573", "LastActivityDate": "2017-04-28T11:00:31.303", "Score": "22", "OwnerUserId": "7232794", "Tags": "<c++><c++14><language-lawyer>", "AnswerCount": "2"}, "40897892": {"Id": "40897892", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40897533_40897892_0\">18.6.1.3 Placement forms [new.delete.placement]</p>\n<p id=\"so_40897533_40897892_1\">void* operator new(std::size_t size, void* ptr) noexcept;</p>\n<p id=\"so_40897533_40897892_2\">Returns: ptr.</p>\n</blockquote>\n<p>It is unambiguously specified that the placement <code>new</code> operator returns whatever pointer is passed to it. \"Returns: ptr\". Can't get any clearer than that.</p>\n<p>That, pretty much, seals the deal for me as far as \"the return value from placement new\" goes: placement <code>new</code> does nothing to the pointer it places, and it always returns the same pointer.</p>\n<p>Everything else in your question relates to any other changes that might occur as the result of the other casts; but you're asking specifically about the return value from placement <code>new</code>, so I take it that you're accepting that all other conversion are type-conversions only, and have no effect on the actual pointer, and you were only asking about placement new -- but it would also be possible to go through the other casts, and make a similar determination.</p>\n", "LastActivityDate": "2016-11-30T20:47:01.547", "CommentCount": "6", "CreationDate": "2016-11-30T20:47:01.547", "ParentId": "40897533", "Score": "0", "OwnerUserId": "3943312"}, "bq_ids": {"n4140": {"so_40897533_40897892_1": {"length": 7, "quality": 1.0, "section_id": 6857}}, "n3337": {"so_40897533_40897892_1": {"length": 7, "quality": 1.0, "section_id": 6603}}, "n4659": {"so_40897533_40897892_1": {"length": 7, "quality": 1.0, "section_id": 8349}}}});