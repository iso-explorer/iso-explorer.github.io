post_cb({"23851697": {"ParentId": "13092266", "CommentCount": "0", "Body": "<p>The keyworkd <strong>nullptr</strong> is introduced in c++11 because multiple definition of the C <strong>NULL</strong>, and it confuses when overloading a function with int arguments and NULL.</p>\n<pre><code>#define NULL 0\n#define NULL (void*)0\n</code></pre>\n<p>In the bible The C++ Programming Language (4th), page 270</p>\n<blockquote>\n<p id=\"so_13092266_23851697_0\">The pointer-to-bool conversion is useful in conditions, but confusing elsewhere.</p>\n</blockquote>\n<p>So I think nullptr_t varible convert to int is not allowed because that's the reason why it exists, but it can be used as a test condition like bool variables.</p>\n", "OwnerUserId": "2567512", "PostTypeId": "2", "Id": "23851697", "Score": "0", "CreationDate": "2014-05-25T03:24:06.317", "LastActivityDate": "2014-05-25T03:24:06.317"}, "13092497": {"ParentId": "13092266", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To understand why is this happening, you should understand how to use <code>nullptr</code>. Check these links bellow:</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/C%2B%2B11\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/C%2B%2B11</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1282295/what-exactly-is-nullptr\">What exactly is nullptr?</a></li>\n</ul>\n<p>I hope it helps.</p>\n", "OwnerUserId": "1341622", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:33.450", "Id": "13092497", "Score": "2", "CreationDate": "2012-10-26T18:34:50.223", "LastActivityDate": "2012-10-26T18:34:50.223"}, "13092294": {"ParentId": "13092266", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Because it is exactly the main idea of <code>nullptr</code>.</p>\n<p><code>nullptr</code> was meant to avoid this behavior: </p>\n<pre><code>struct myclass {};\n\nvoid f(myclass* a) { std::cout &lt;&lt; \"myclass\\n\"; }\nvoid f(int a) { std::cout &lt;&lt; \"int\\n\"; }\n\n// ...\n\nf(NULL); // calls void f(int)\n</code></pre>\n<p>If <code>nullptr</code> were convertible to <code>int</code> this behavior would occur.</p>\n<p>So the question is \"<em>why is it convertible to</em> <code>bool</code>?\". </p>\n<p>Syntax-\"suggarness\":</p>\n<pre><code>int* a = nullptr;\nif (a) {\n}\n</code></pre>\n<p>Which looks way better than:</p>\n<pre><code>if (a == nullptr) {\n}\n</code></pre>\n", "OwnerUserId": "321337", "LastEditorUserId": "321337", "LastEditDate": "2012-10-26T18:54:34.177", "Id": "13092294", "Score": "28", "CreationDate": "2012-10-26T18:20:02.707", "LastActivityDate": "2012-10-26T18:54:34.177"}, "13092266": {"CommentCount": "4", "ViewCount": "3857", "PostTypeId": "1", "LastEditorUserId": "1498329", "CreationDate": "2012-10-26T18:18:10.240", "LastActivityDate": "2014-05-25T04:27:05.703", "Title": "Why can't nullptr convert to int?", "FavoriteCount": "4", "LastEditDate": "2014-05-25T04:27:05.703", "Id": "13092266", "Score": "15", "Body": "<p>Summary: <code>nullptr</code> converts to <code>bool</code>, and <code>bool</code> converts to <code>int</code>, so why doesn't <code>nullptr</code> convert to <code>int</code>?</p>\n<p>This code is okay:</p>\n<pre><code>void f(bool);\nf(nullptr);      // fine, nullptr converts to bool\n</code></pre>\n<p>And this is okay:</p>\n<pre><code>bool b;\nint i(b);        // fine, bool converts to int\n</code></pre>\n<p>So why isn't this okay?</p>\n<pre><code>void f(int);\nf(nullptr);      // why not convert nullptr to bool, then bool to int?\n</code></pre>\n", "Tags": "<c++><c++11><implicit-conversion><nullptr>", "OwnerUserId": "1426649", "AnswerCount": "4"}, "13092320": {"ParentId": "13092266", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In \u00a74.1 of the Standard, it says how conversions are performed:</p>\n<blockquote>\n<p id=\"so_13092266_13092320_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions. A standard conversion sequence is a sequence of standard conversions in the following order:</p>\n<p id=\"so_13092266_13092320_1\">\u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion.</p>\n<p id=\"so_13092266_13092320_2\">\u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions.</p>\n<p id=\"so_13092266_13092320_3\">\u2014 Zero or one qualification conversion.</p>\n</blockquote>\n<p>So the compiler only does \"zero or one conversion\" of some, none, or all of each of the above types of conversions, not arbitrarily many. And that's a <em>really good thing</em>.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2012-10-26T18:32:56.623", "Id": "13092320", "Score": "18", "CreationDate": "2012-10-26T18:21:42.520", "LastActivityDate": "2012-10-26T18:32:56.623"}, "bq_ids": {"n4140": {"so_13092266_13092320_2": {"section_id": 0, "quality": 1.0, "length": 24}, "so_13092266_13092320_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_13092266_13092320_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}, "so_13092266_13092320_1": {"section_id": 0, "quality": 1.0, "length": 11}}, "n3337": {"so_13092266_13092320_2": {"section_id": 0, "quality": 1.0, "length": 24}, "so_13092266_13092320_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_13092266_13092320_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}, "so_13092266_13092320_1": {"section_id": 0, "quality": 1.0, "length": 11}}, "n4659": {"so_13092266_13092320_2": {"section_id": 0, "quality": 0.8333333333333334, "length": 20}, "so_13092266_13092320_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_13092266_13092320_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}, "so_13092266_13092320_1": {"section_id": 0, "quality": 1.0, "length": 11}}}});