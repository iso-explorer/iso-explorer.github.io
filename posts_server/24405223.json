post_cb({"24405223": {"CommentCount": "5", "ViewCount": "216", "PostTypeId": "1", "LastEditorUserId": "1559666", "CreationDate": "2014-06-25T09:41:21.980", "LastActivityDate": "2014-06-25T10:14:36.320", "Title": "C variadic macro call another variadic macro", "AcceptedAnswerId": "24405910", "LastEditDate": "2014-06-25T10:13:03.453", "Id": "24405223", "Score": "1", "Body": "<p>I have the following code (as is):</p>\n<pre><code>template&lt;class T, class FieldT&gt;\nusing addRefU = typename std::conditional&lt;\n                            std::is_rvalue_reference&lt;T&gt;::value,\n                            typename std::add_rvalue_reference&lt; FieldT &gt;::type,\n                            typename std::conditional&lt;\n                                std::is_rvalue_reference&lt;FieldT&gt;::value,\n                                typename std::add_rvalue_reference&lt; FieldT &gt;::type,\n                                typename std::add_lvalue_reference&lt; FieldT &gt;::type\n                            &gt;::type\n                        &gt;::type;\n\n#define VA_NARGS_IMPL(_1, _2, _3, _4, _5, N, ...) N\n#define VA_NARGS(...) VA_NARGS_IMPL(X,##__VA_ARGS__, 4, 3, 2, 1, 0)\n#define VARARG_IMPL2(base, count, ...) base##count(__VA_ARGS__)\n#define VARARG_IMPL(base, count, ...) VARARG_IMPL2(base, count, __VA_ARGS__)\n#define VARARG(base, ...) VARARG_IMPL(base, VA_NARGS(__VA_ARGS__), __VA_ARGS__)\n\n\n#define REF2(val, p1) addRefU&lt;decltype(val), decltype(val.p1)&gt;\n#define REF3(val, p1, p2) addRefU&lt;decltype(val), decltype(val.p1.p2)&gt;\n#define REF4(val, p1, p2, p3) addRefU&lt;decltype(val), decltype(val.p1.p2.p3)&gt;\n#define REF5(val, p1, p2, p3, p4) addRefU&lt;decltype(val), decltype(val.p1.p2.p3.p4)&gt;\n#define REF(...) VARARG(REF, __VA_ARGS__)     // It says REF is not defined here\n\n\n\n#define CAST_REF2(val, p1) static_cast&lt;REF(val, p1)&gt;(val.p1)\n#define CAST_REF3(val, p1, p2) static_cast&lt;REF(val, p1, p2)&gt;(val.p1.p2)\n#define CAST_REF4(val, p1, p2, p3) static_cast&lt;REF(val, p1, p2, p3)&gt;(val.p1.p2.p3)\n#define CAST_REF5(val, p1, p2, p3, p4) static_cast&lt;REF(val, p1, p2, p3, p4)&gt;(val.p1.p2.p3.p4)\n#define CAST_REF(...) VARARG(CAST_REF, __VA_ARGS__)\n\n\nstruct A{};\nstruct B{A a;};\n\nint main()\n{\n    B b;\n\n    using t = REF(b, a);    // Ok\n\n    auto &amp;&amp;k = CAST_REF2(b, a); // work\n    auto &amp;&amp;k1 = CAST_REF(b, a); // NOT work\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8dff49f68b7e15e1\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/8dff49f68b7e15e1</a></p>\n<p>If I change </p>\n<p><code>#define CAST_REF2(val, p1) static_cast&lt;REF(val, p1)&gt;(val.p1)</code> to </p>\n<p><code>#define CAST_REF2(val, p1) static_cast&lt;REF2(val, p1)&gt;(val.p1)</code> (change <code>REF</code> to <code>REF2</code>)</p>\n<p>It works.\nI don't understand why I can call <code>REF</code> directly, and can't do this from macro.</p>\n", "Tags": "<c++><c><c-preprocessor>", "OwnerUserId": "1559666", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24405223_24405910_0": {"section_id": 531, "quality": 0.9215686274509803, "length": 47}}, "n3337": {"so_24405223_24405910_0": {"section_id": 522, "quality": 0.9215686274509803, "length": 47}}, "n4659": {"so_24405223_24405910_0": {"section_id": 552, "quality": 0.9215686274509803, "length": 47}}}, "24405910": {"ParentId": "24405223", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code (sans includes) <a href=\"http://coliru.stacked-crooked.com/a/0c451d3dd690f74c\" rel=\"nofollow noreferrer\">preprocesses to the following</a>:</p>\n<pre><code>struct A{};\nstruct B{A a;};\n\nint main()\n{\n    B b;\n\n    using t = addRefU&lt;decltype(b), decltype(b.a)&gt;\n\n    auto &amp;&amp;k = static_cast&lt;VARARG(REF, b, a)&gt;(b.a);\n    auto &amp;&amp;k1 = static_cast&lt;addRefU&lt;decltype(b), decltype(b.a)&gt; &gt;(b.a);\n\n    return 0;\n}\n</code></pre>\n<p>Clearly, <code>VARARG</code> hasn't been expanded, and this is because it was already expanded previously in the expansion of <code>CAST_REF</code> (which isn't the case for <code>CAST_REF2</code>):</p>\n<blockquote>\n<p id=\"so_24405223_24405910_0\"><code>[C++11: 16.3.4/2]:</code> If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source \ufb01le\u2019s preprocessing tokens), it is not replaced. <strong>Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts\n  in which that macro name preprocessing token would otherwise have been replaced.</strong></p>\n</blockquote>\n<p>The intent of the rule is to prohibit infinite recursions, even though you're not actually at risk of one in this particular case.</p>\n<p>This has been discussed on Stack Overflow <a href=\"https://stackoverflow.com/q/5641836/560648\">before</a>, but I'm not entirely sure how you can get around it, at this point (other than by copying <code>VARARG</code>).</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:36.200", "Id": "24405910", "Score": "3", "CreationDate": "2014-06-25T10:14:36.320", "LastActivityDate": "2014-06-25T10:14:36.320"}});