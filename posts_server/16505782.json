post_cb({"bq_ids": {"n4140": {"so_16505782_16509511_2": {"length": 41, "quality": 0.5774647887323944, "section_id": 3244}, "so_16505782_16509511_0": {"length": 41, "quality": 1.0, "section_id": 3244}, "so_16505782_16509511_6": {"length": 15, "quality": 0.9375, "section_id": 3228}, "so_16505782_16505879_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6714}, "so_16505782_16509511_3": {"length": 10, "quality": 1.0, "section_id": 7020}, "so_16505782_16509511_4": {"length": 13, "quality": 1.0, "section_id": 6324}, "so_16505782_16509511_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 3245}}, "n3337": {"so_16505782_16509511_2": {"length": 41, "quality": 0.5774647887323944, "section_id": 3117}, "so_16505782_16509511_0": {"length": 41, "quality": 1.0, "section_id": 3117}, "so_16505782_16509511_6": {"length": 15, "quality": 0.9375, "section_id": 3101}, "so_16505782_16505879_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6469}, "so_16505782_16509511_3": {"length": 10, "quality": 1.0, "section_id": 6766}, "so_16505782_16509511_4": {"length": 13, "quality": 1.0, "section_id": 6081}, "so_16505782_16509511_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 3118}}, "n4659": {"so_16505782_16509511_0": {"length": 29, "quality": 0.7073170731707317, "section_id": 4002}, "so_16505782_16509511_6": {"length": 13, "quality": 0.8125, "section_id": 307}, "so_16505782_16505879_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 8209}, "so_16505782_16509511_3": {"length": 10, "quality": 1.0, "section_id": 8517}, "so_16505782_16509511_4": {"length": 13, "quality": 1.0, "section_id": 7834}, "so_16505782_16509511_1": {"length": 16, "quality": 0.5333333333333333, "section_id": 4003}}}, "16505879": {"Id": "16505879", "PostTypeId": "2", "Body": "<p>Concerning the type trait that decides whether a type can be returned for a function, here is how I would go about it:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T, typename = void&gt;\nstruct can_be_returned_from_function : std::false_type { };\n\ntemplate&lt;typename T&gt;\nstruct can_be_returned_from_function&lt;T,\n    typename std::enable_if&lt;!std::is_abstract&lt;T&gt;::value,\n    decltype(std::declval&lt;T()&gt;(), (void)0)&gt;::type&gt;\n    : std::true_type { };\n</code></pre>\n<p>On the other hand, <a href=\"https://stackoverflow.com/questions/16505782/determining-if-stdnumeric-limitst-is-safe-to-instantiate/16505879#comment23694486_16505782\">as suggested by Tom Knapen in the comments</a>, you may want to use the <a href=\"http://en.cppreference.com/w/cpp/types/is_arithmetic\" rel=\"nofollow noreferrer\"><code>std::is_arithmetic</code></a> standard type trait to determine whether you can specialize <code>numeric_limits</code> for a certain type.</p>\n<p>Per paragraph 18.3.2.1/2 of the C++11 Standard on the <code>numeric_limits</code> class template, in fact:</p>\n<blockquote>\n<p id=\"so_16505782_16505879_0\"><strong>Specializations shall be provided for each arithmetic type</strong>, both floating point and integer, including <code>bool</code>.\n  The member <code>is_specialized</code> shall be true for all such specializations of <code>numeric_limits</code>.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-12T18:56:08.353", "Score": "5", "CreationDate": "2013-05-12T09:18:45.130", "ParentId": "16505782", "CommentCount": "9", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:21:51.003"}, "16509511": {"Id": "16509511", "PostTypeId": "2", "Body": "<h2>C++11 solutions</h2>\n<p>Since <code>T</code> only appears as the return type of static member functions in the declarations of the unspecialised <code>::std::numeric_limits&lt;T&gt;</code> (see C++03 18.2.1.1 and C++11 18.3.2.3), it is enough for this specific problem to ensure that doing so is declaration-safe.</p>\n<p>The reason this leads to a compile time error is, that the use of a template-argument may not give rise to an ill-formed construct in the instantiation of the template specialization (C++03 14.3/6, C++11 14.3/6).</p>\n<p>For C++11 enabled projects, Andy Prowl's <code>can_be_returned_from_function</code> solution works in all relevant cases: <a href=\"http://ideone.com/SZB2bj\" rel=\"nofollow\">http://ideone.com/SZB2bj</a> , but it is not easily portable to a C++03 environment. It causes an error in when instantiated with an incomplete type ( <a href=\"http://ideone.com/k4Y25z\" rel=\"nofollow\">http://ideone.com/k4Y25z</a> ). The proposed solution will accept incomplete classes instead of causing an error. The current Microsoft compiler (msvc 1700 / VS2012) seems to dislike this solution and fail to compile.</p>\n<p>Jonathan Wakely proposed a solution that works by utilizing <code>std::is_convertible&lt;T, T&gt;</code> to determine if <code>T</code> can be the return value of a function. This also eliminates incomplete classes, and is easy to show correct (it is defined in C++11  to do exactly what we want). Execution shows that all cases (arrays, arrays of undefined length, functions, abstract classes) which are known to be problematic are correctly recognized. As a bonus, it also correctly recognizes incomplete classes, which are not allowed as parameters to <code>numeric_limits</code> by the standards (see below), although they seem to cause no problems in practice, as long as no problematic functions are actually called. Test execution: <a href=\"http://ideone.com/zolXpp\" rel=\"nofollow\">http://ideone.com/zolXpp</a> . Some current compilers (icc 1310 and msvc 1700, which is VS2012's compiler) generate incorrect results with this method.</p>\n<p>Tom Knapen's <code>is_arithmetic</code> solution is a very concise C++11 solution, but requires the implementer of a type that specialises <code>numeric_limits</code> to also specialise <code>is_arithmetic</code>. Alternatively, a type that in its base case inherits from <code>is_arithmetic</code> (this type might be called <code>numeric_limits_is_specialised</code>) might be specialised in those cases, since specialising <code>is_abstract</code> might not be semantically correct (e.g. a type that does not specify all basic arithmetic operators, but still is a valid integer-like type).<br>\nThis whitelisting approach ensures that even incomplete types are handled correctly, unless someone maliciously tries to force compilation errors.</br></p>\n<h3>Caveat</h3>\n<p>As shown by the mixed results, C++11 support remains spotty, even with current compilers, so your mileage with these solutions may vary. A C++03 solution will benefit from more consistent results and the ability to be used in projects that do not wish to switch to C++11.</p>\n<h2>Towards a robust C++03 solution</h2>\n<p>Paragraph C++11 8.3.5/8 lists the restrictions for return values:</p>\n<blockquote>\n<p id=\"so_16505782_16509511_0\">If the type of a parameter includes a type of the form \"pointer to array of unknown bound of T\" or \"reference to array of unknown bound of T\", the program is ill-formed. <strong>Functions shall not have a return type of type array or function, although they may have a return type of type pointer or reference to such things.</strong> There shall be no arrays of functions, although there can be arrays of pointers to functions.</p>\n</blockquote>\n<p>and goes on in paragraph C++11 8.3.5/9:</p>\n<blockquote>\n<p id=\"so_16505782_16509511_1\">Types shall not be defined in return or parameter types. The type of a parameter or the <strong>return type for a function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is nested within the member-specification for that class</strong> (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>Which is pretty much the same as paragraph C++03 8.3.5/6:</p>\n<blockquote>\n<p id=\"so_16505782_16509511_2\">If the type of a parameter includes a type of the form \"pointer to array of unknown bound of T\" or \"reference to array of unknown bound of T\", the program is ill-formed. <strong>Functions shall not have a return type of type array or function</strong>, although they may have a return type of type pointer or reference to such things. There shall be no arrays of functions, although there can be arrays of pointers to functions. Types shall not\n  be defined in return or parameter types. The type of a parameter or <strong>the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is nested within the member-specification for that class</strong> (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>Another kind of problematic types is mentioned identically in C++11 10.4/3 and C++03 10.4/3:</p>\n<blockquote>\n<p id=\"so_16505782_16509511_3\">An abstract class shall not be used as a parameter type, as a function return type, or as the type of an explicit conversion. [...]</p>\n</blockquote>\n<p>The problematic functions are not nested within an incomplete class type (except of <code>::std::numeric_limits&lt;T&gt;</code>, which cannot be their <code>T</code>), so we have four kinds of problematic values of <code>T</code>: Arrays, functions, incomplete class types and abstract class types.</p>\n<h3>Array Types</h3>\n<pre><code>template&lt;typename T&gt; struct is_array\n{ static const bool value = false; };\n\ntemplate&lt;typename T&gt; struct is_array&lt;T[]&gt;\n{ static const bool value = true; };\n\ntemplate&lt;typename T, size_t n&gt; struct is_array&lt;T[n]&gt;\n{ static const bool value = true; };\n</code></pre>\n<p>detects the simple case of <code>T</code> being an array type.</p>\n<h3>Incomplete Class Types</h3>\n<p>Incomplete class types interestingly do not lead to a compilation error just from instantiation, which means either the tested implementations are more forgiving than the standard, or I am missing something.</p>\n<p>C++03 example: <a href=\"http://ideone.com/qZUa1N\" rel=\"nofollow\">http://ideone.com/qZUa1N</a>\nC++11 example: <a href=\"http://ideone.com/MkA0Gr\" rel=\"nofollow\">http://ideone.com/MkA0Gr</a></p>\n<p>Since I cannot come up with a proper way to detect incomplete types, and even the standard specifies (C++03 17.4.3.6/2 item 5)</p>\n<blockquote>\n<p id=\"so_16505782_16509511_4\">In particular, the effects are undefined in the following cases: [...] if an incomplete type (3.9) is used as a template argument when instantiating a template component.</p>\n</blockquote>\n<p>Adding only the following special allowance in C++11 (17.6.4.8/2):</p>\n<blockquote>\n<p id=\"so_16505782_16509511_5\">[...] unless specifically allowed for that component</p>\n</blockquote>\n<p>it seems safe to assume that anybody passing incomplete types as template parameters are on their own.</p>\n<p>A complete list of the cases where C++11 allows incomplete type parameters is quite short:</p>\n<ul>\n<li><code>declval</code></li>\n<li><code>unique_ptr</code></li>\n<li><code>default_delete</code> (C++11 20.7.1.1.1/1: \"The class template default_delete serves as the default deleter (destruction policy) for the class template <code>unique_ptr</code>.\"</li>\n<li><code>shared_ptr</code></li>\n<li><code>weak_ptr</code></li>\n<li><code>enable_shared_from_this</code></li>\n</ul>\n<h3>Abstract Class &amp; Function Types</h3>\n<p>Detecting functions is a bit more work than in C++11, since we do not have variadic templates in C++03. However, the above quotes on functions already contain the hint we need; functions may not be elements of arrays.</p>\n<p>Paragraph C++11 8.3.4\\1 contains the sentence</p>\n<blockquote>\n<p id=\"so_16505782_16509511_6\">T is called the array element type; this type shall not be a reference type, the (possibly cv qualified) type void, a function type or an abstract class type.</p>\n</blockquote>\n<p>which is also verbatim in paragraph C++03 8.3.4\\1 and will allow us to test if a type is a function type. Detecting <code>(cv) void</code> and reference types is simple:</p>\n<pre><code>template&lt;typename T&gt; struct is_reference\n{ static const bool value = false; };\n\ntemplate&lt;typename T&gt; struct is_reference&lt;T&amp;&gt;\n{ static const bool value = true; };\n\ntemplate&lt;typename T&gt; struct is_void\n{ static const bool value = false; };\n\ntemplate&lt;&gt; struct is_void&lt;void&gt;\n{ static const bool value = true; };\n\ntemplate&lt;&gt; struct is_void&lt;void const&gt;\n{ static const bool value = true; };\n\ntemplate&lt;&gt; struct is_void&lt;void volatile&gt;\n{ static const bool value = true; };\n\ntemplate&lt;&gt; struct is_void&lt;void const volatile&gt;\n{ static const bool value = true; };\n</code></pre>\n<p>Using this, it is simple to write a meta function for abstract class types and functions:</p>\n<pre><code>template&lt;typename T&gt;\nclass is_abstract_class_or_function\n{\n    typedef char (&amp;Two)[2];\n    template&lt;typename U&gt; static char test(U(*)[1]);\n    template&lt;typename U&gt; static Two test(...);\n\npublic:\n    static const bool value =\n        !is_reference&lt;T&gt;::value &amp;&amp;\n        !is_void&lt;T&gt;::value &amp;&amp;\n        (sizeof(test&lt;T&gt;(0)) == sizeof(Two));\n};\n</code></pre>\n<p>Note that the following meta function may be used to distinguish between the two, should one wish to make a distinct <code>is_function</code> and <code>is_abstract_class</code></p>\n<pre><code>template&lt;typename T&gt;\nclass is_class\n{\n    typedef char (&amp;Two)[2];\n    template&lt;typename U&gt; static char test(int (U::*));\n    template&lt;typename U&gt; static Two test(...);\n\npublic:\n    static const bool value = (sizeof(test&lt;T&gt;(0)) == sizeof(char));\n};\n</code></pre>\n<h3>Solution</h3>\n<p>Combining all of the previous work, we can construct the <code>is_returnable</code> meta function:</p>\n<pre><code>template&lt;typename T&gt; struct is_returnable\n{ static const bool value = !is_array&lt;T&gt;::value &amp;&amp; !is_abstract_class_or_function&lt;T&gt;::value; };\n</code></pre>\n<p>Execution for C++03 (gcc 4.3.2): <a href=\"http://ideone.com/thuqXY\" rel=\"nofollow\">http://ideone.com/thuqXY</a><br>\nExecution for C++03 (gcc 4.7.2): <a href=\"http://ideone.com/OR4Swf\" rel=\"nofollow\">http://ideone.com/OR4Swf</a> \nExecution for C++11 (gcc 4.7.2): <a href=\"http://ideone.com/zIu7GJ\" rel=\"nofollow\">http://ideone.com/zIu7GJ</a></br></p>\n<p>As expected, all test cases except for the incomplete class yield the correct answer.</p>\n<p>In addition to the above test runs, this version is tested (with the exact same test program) to yield the same results w/o warnings or errors on:</p>\n<ul>\n<li>MSVC 1700 (VS2012 with and w/o XP profile), 1600 (VS2010), 1500 (VS2008)</li>\n<li>ICC Win 1310</li>\n<li>GCC (C++03 and C++11/C++0x mode) 4.4.7, 4.6.4, 4.8.0 and a 4.9 snapshot</li>\n</ul>\n<h2>Restrictions for either case</h2>\n<p>Note that, while this approach in either version works for any <code>numeric_limits</code> implementation that does not extend upon the implementation shown in the standard, it is by no means a solution to the general problem, and in fact may theoretically lead to problems with weird but standard compliant implementations (e.g. ones which add private members).</p>\n<p>Incomplete classes remain a problem, but it seems silly to require higher robustness goals than the standard library itself.</p>\n", "LastEditorUserId": "65678", "LastActivityDate": "2013-05-13T06:59:10.237", "Score": "4", "CreationDate": "2013-05-12T16:26:05.343", "ParentId": "16505782", "CommentCount": "5", "OwnerUserId": "65678", "LastEditDate": "2013-05-13T06:59:10.237"}, "16505782": {"ViewCount": "855", "Body": "<p>The class template <code>::std::numeric_limits&lt;T&gt;</code> may only be instantiated for types <code>T</code>, which can be the return value of functions, since it always defines member functions like <code>static constexpr T min() noexcept { return T(); }</code> (see <a href=\"http://www.cplusplus.com/reference/limits/numeric_limits/\" rel=\"nofollow\">http://www.cplusplus.com/reference/limits/numeric_limits/</a> for more information of the non-specialised versions in c++03 or c++11).</p>\n<p>If <code>T</code> is i.e. <code>int[2]</code> the instantiation will immediately lead to a compile time error, since <code>int[2]</code> cannot be the return value of a function.</p>\n<p>Wrapping <code>::std::numeric_limits</code> with a safe version is easy - <em>if a way to determine if it is safe to instantiate <code>::std::numeric_limits</code> is known.</em> This is necessary, since the problematic functions should be accessible if possible.</p>\n<p>The obvious (and obviously wrong) way of testing <code>::std::numeric_limits&lt;T&gt;::is_specialised</code> does not work since it requires instantiation of the problematic class template.</p>\n<p>Is there a way to test for safety of instantiation, preferably without enumerating all known bad types? Maybe even a general technique to determine if any class template instantiation is safe?</p>\n", "AcceptedAnswerId": "16509511", "Title": "Determining if ::std::numeric_limits<T> is safe to instantiate", "CreationDate": "2013-05-12T09:05:14.440", "Id": "16505782", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-05-13T15:06:13.247", "LastEditorUserId": "65678", "LastActivityDate": "2013-05-13T15:06:13.247", "Score": "9", "OwnerUserId": "65678", "Tags": "<c++><templates><c++11><c++03>", "AnswerCount": "3"}, "16511063": {"Id": "16511063", "PostTypeId": "2", "Body": "<p><code>std::is_convertible&lt;T, T&gt;::value</code> will tell you if a type can be returned from a function.  </p>\n<p><code>is_convertible&lt;T1, T2&gt;</code> is defined in terms of a function returning a <code>T2</code> converted from an expression of type <code>T1</code>.</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\nstruct Incomplete;\nstruct Abstract { virtual void f() = 0; };\n\ntemplate&lt;typename T&gt;\n  using is_numeric_limits_safe = std::is_convertible&lt;T, T&gt;;\n\nint main()\n{\n  static_assert(!is_numeric_limits_safe&lt;Incomplete&gt;::value, \"Incomplete\");\n  static_assert(!is_numeric_limits_safe&lt;Abstract&gt;::value,   \"Abstract\");\n  static_assert(!is_numeric_limits_safe&lt;int[2]&gt;::value,     \"int[2]\");\n}\n</code></pre>\n<p>This might not be exactly what you want, because it <em>is</em> safe to instantiate <code>std::numeric_limits&lt;Incomplete&gt;</code> as long as you don't call any of the functions that return by value.  It's not possible to instantiate <code>std::numeric_limits&lt;int[2]&gt;</code> though.</p>\n<p>Here's a better test (using SFINAE) which gives <code>is_numeric_limits_safe&lt;Incomplete&gt;::value==true</code></p>\n<pre><code>template&lt;typename T&gt;\nclass is_numeric_limits_unsafe\n{\n  struct mu { };\n\n  template&lt;typename U&gt;\n    static U test(int);\n\n  template&lt;typename U&gt;\n    static mu test(...);\n\npublic:\n    typedef std::is_same&lt;decltype(test&lt;T&gt;(0)), mu&gt; type;\n};\n\ntemplate&lt;typename T&gt;\nstruct is_numeric_limits_safe\n: std::integral_constant&lt;bool, !is_numeric_limits_unsafe&lt;T&gt;::type::value&gt;\n{ };\n</code></pre>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-05-12T19:45:37.743", "Score": "3", "CreationDate": "2013-05-12T19:11:08.320", "ParentId": "16505782", "CommentCount": "5", "OwnerUserId": "981959", "LastEditDate": "2013-05-12T19:45:37.743"}});