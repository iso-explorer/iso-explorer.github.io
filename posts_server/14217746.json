post_cb({"14217769": {"Id": "14217769", "PostTypeId": "2", "Body": "<p><code>this</code> will never be null in a member function so the check you perform is useless. </p>\n<p>As pointed by Matthieu M. in a comment, if you do something like this in your code:</p>\n<pre><code>C* c = 0; \nc-&gt;member();\n</code></pre>\n<p>This would cause <strong>undefined behavior</strong> and that is something <strong>bad</strong>. </p>\n", "LastEditorUserId": "812912", "LastActivityDate": "2013-01-08T15:11:47.263", "Score": "12", "CreationDate": "2013-01-08T14:59:11.023", "ParentId": "14217746", "CommentCount": "5", "OwnerUserId": "812912", "LastEditDate": "2013-01-08T15:11:47.263"}, "14218183": {"Id": "14218183", "PostTypeId": "2", "Body": "<p>As has been pointed out, <code>this</code> can never be a null pointer.  If it is, you've already invoked undefined behavior.  You could, instead, create a set of overloaded functions, like this:</p>\n<pre><code>void DoTheThing(C* cp)\n{\n    if (cp)\n        cp-&gt;member_func();\n    else\n    {\n        // take some default action\n    }\n}\n\nvoid DoTheThing(B* bp)\n{\n    if (bp)\n        bp-&gt;some_other_member_func();\n    else\n    {\n        // take some default action\n    }\n}\n</code></pre>\n<p>If the function you want to call has the same name in each class, then you could make a static function in each class which performs the default action for that class (all with the same name), and make a template:</p>\n<pre><code>template&lt;typname T&gt;\nvoid DoTheThing(T* tp)\n{\n    if (tp)\n        tp-&gt;member_func();\n    else\n        T::default_action()\n}\n</code></pre>\n", "LastActivityDate": "2013-01-08T15:19:05.627", "CommentCount": "4", "CreationDate": "2013-01-08T15:19:05.627", "ParentId": "14217746", "Score": "6", "OwnerUserId": "440119"}, "14217746": {"ViewCount": "1123", "Body": "<p>I have an application involving objects of different class types.  The objects are referenced by pointers.  A null pointer signifies that the associated object does not exist.  Currently the calling codes is cumbersome, because each time it uses a pointer to an object, it tests the pointer value for null, and take some appropriate action it is null.  Because the default action to be taken in the case of non-existence depends on the type of object, I would prefer to encode it in the classes for the objects themselves rather than in the calling program.  This results in constructions like the following:</p>\n<pre><code>class C\n{ ... \n  void member_func() //non-virtual !\n  { if (this) { do something with the object ... }\n    else { take some default action }\n  }\n  ...\n};\n</code></pre>\n<p>Clearly the member function cannot be virtual, because the lookup table does not exist when the object does not exist, and the virtual call would fail.   But is this code legal C++ for non-virtual member functions?  It seems to work correctly for the compilers I have tried it on, but I am worried about possible non-portability. In the standard I can\u2019t find a clause that either expressly allows or expressly prohibits such constructions.</p>\n", "Title": "Is it legal C++ to test the this-pointer in a member function?", "CreationDate": "2013-01-08T14:58:03.550", "LastActivityDate": "2015-05-24T17:14:58.197", "CommentCount": "3", "LastEditDate": "2015-05-24T17:14:58.197", "PostTypeId": "1", "LastEditorUserId": "19405", "Id": "14217746", "Score": "4", "OwnerUserId": "1958486", "Tags": "<c++><null><this>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_14217746_14218744_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5889}, "so_14217746_14218744_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6005}}, "n3337": {"so_14217746_14218744_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5660}, "so_14217746_14218744_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5773}}, "n4659": {"so_14217746_14218744_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7372}, "so_14217746_14218744_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7504}}}, "14218744": {"Id": "14218744", "PostTypeId": "2", "Body": "<p>I think, it's not allowed to do that. You asked for references to the standard. I believe first thing of interest is 9.3.1 Nonstatic member functions, 1.:</p>\n<blockquote>\n<p id=\"so_14217746_14218744_0\">A non-static member function may be called for an object of its class\n  type, or for an object of a class derived (Clause 10) from its class\n  type, using the class member access syntax (5.2.5, 13.3.1.1).</p>\n</blockquote>\n<p>Second let's look at 5.2.5 Class member access, 2.:</p>\n<blockquote>\n<p id=\"so_14217746_14218744_1\">The expression E1-&gt;E2 is converted to the equivalent form (*(E1)).E2;\n  the remainder of 5.2.5 will address only the first option (dot).</p>\n</blockquote>\n<p>So if E1 is a nullptr, the *E1 will not be allowed. So at least is my guess.</p>\n", "LastActivityDate": "2013-01-08T15:45:59.723", "CommentCount": "1", "CreationDate": "2013-01-08T15:45:59.723", "ParentId": "14217746", "Score": "0", "OwnerUserId": "1023911"}, "14217812": {"Id": "14217812", "PostTypeId": "2", "Body": "<p>Standard-wise, the code is not legal, <strong>but</strong> it's used in practice (bad practice that is).</p>\n<p>In fact, IIRC MFC uses these checks internally.</p>\n", "LastActivityDate": "2013-01-08T15:01:07.170", "CommentCount": "4", "CreationDate": "2013-01-08T15:01:07.170", "ParentId": "14217746", "Score": "1", "OwnerUserId": "673730"}, "14218013": {"Id": "14218013", "PostTypeId": "2", "Body": "<p><em>Checking</em> whether <code>this == NULL</code> is not a problem. <em>Calling</em> a method through a NULL object pointer is.</p>\n<p>If you want to keep the checks somewhere, you could put it in a smart pointer class which can  take the appropriate action if the held pointer is NULL.  If the \"appropriate action\" is uniquely determined by the held type, you can use a traits class to specify it.</p>\n<p>This way your NULL checks and their logic is kept together, and not mixed into either the caller or the method code.</p>\n<hr>\n<pre><code>// specialize this to provide behaviour per held type\ntemplate &lt;typename T&gt; struct MaybeNullDefaultAction {\n    void null_call() { throw std::runtime_error(\"call through NULL pointer\"); }\n}\n\ntemplate &lt;typename T&gt; class MaybeNull: MaybeNullDefaultAction&lt;T&gt; {\n    T *ptr;\npublic:\n    explicit MaybeNull(T *p) : ptr(p) {}\n\n    T* operator-&gt; () {\n        if (!ptr)\n            null_call();\n        // null_call should throw to avoid returning NULL here\n        return ptr;\n    }\n};\n</code></pre>\n<p>Unfortunately, I can't see a way to do this without throwing. There's no way to intercept function calls for all methods names, otherwise I'd just return <code>*this</code> from <code>operator-&gt;</code> and do the work in <code>operator()</code>.</p>\n</hr>", "LastEditorUserId": "212858", "LastActivityDate": "2013-01-08T15:24:45.310", "Score": "1", "CreationDate": "2013-01-08T15:10:34.803", "ParentId": "14217746", "CommentCount": "3", "OwnerUserId": "212858", "LastEditDate": "2013-01-08T15:24:45.310"}});