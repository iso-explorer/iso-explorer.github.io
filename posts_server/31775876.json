post_cb({"31775876": {"CommentCount": "19", "ViewCount": "187", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-02T19:42:26.033", "LastActivityDate": "2015-09-26T20:34:05.677", "Title": "While doing copy-elision, the compiler doesn't consider the copy constructor in overload resolution, when the move constructor is deleted. Why?", "AcceptedAnswerId": "31777835", "LastEditDate": "2017-05-23T12:29:37.923", "Id": "31775876", "Score": "5", "Body": "<p>I can understand the compiler is doing <em>copy-elision</em> in the code below, as the copy and move constructors are not invoked in the so called <code>copy-initialization</code> done in <code>main()</code>. See <a href=\"http://coliru.stacked-crooked.com/a/5c4254a63a89d8c6\" rel=\"nofollow noreferrer\">live example</a>.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct S {\n    S() = default;\n    S(const S&amp;) { std::cout &lt;&lt; \"copy ctor\" &lt;&lt; '\\n'; }\n    S(S&amp;&amp;) { std::cout &lt;&lt; \"move ctor\" &lt;&lt; '\\n'; }\n};\n\nint main() {\n    S s = S(); \n}\n</code></pre>\n<p>But I can't understand why the code doesn't compile when I delete the move constructor as below:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct S {\n    S() = default;\n    S(const S&amp;) { std::cout &lt;&lt; \"copy ctor\" &lt;&lt; '\\n'; }\n    S(S&amp;&amp;) = delete;\n};\n\nint main() {\n    S s = S(); \n}\n</code></pre>\n<p>I can't find anything in \u00a712.8/32 (N4140) that could disallow the <strong>copy constructor</strong> from being used or elided, in this case. This is the sentence that called my attention in \u00a712.8/32, which seems to indicate that the copy constructor should have been considered in the overload resolution:</p>\n<blockquote>\n<p id=\"so_31775876_31775876_0\">If the first overload resolution fails or was not performed, or if the\n  type of the first parameter of the selected constructor is not an\n  rvalue reference to the object\u2019s type (possibly cv-qualified),\n  overload resolution is performed again, considering the object as an\n  lvalue.</p>\n</blockquote>\n<p><strong>Edit</strong></p>\n<p>From one of the comments by <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a> below, I understand that when the object to be copied is designated by an rvalue, the compiler, according to \u00a712.8/32, doesn't consider the copy-constructor as a candidate for the copy, even though the copy would be elided anyway. That is, the end result would be the construction of the object <code>s</code> with the default constructor. Instead, in this situation the Standard mandates (where??) the code to be ill-formed. Unless my understanding of this scheme is completely wrong, that doesn't make any sense to me. </p>\n", "Tags": "<c++><language-lawyer><c++14><copy-elision>", "OwnerUserId": "4470210", "AnswerCount": "1"}, "31777835": {"ParentId": "31775876", "CommentCount": "2", "Body": "<p>This is nothing specific to do with copy elision or constructors; it is just overload resolution.</p>\n<p>If we have a pair of overloads:</p>\n<pre><code>void f( T&amp;&amp; rv );\nvoid f( const T&amp; lv );\n</code></pre>\n<p>then the overload resolution rules say that <code>f( T{} )</code> is a better match for <code>f(T&amp;&amp;)</code>.</p>\n<p>Copy elision can elide a copy or move, but only when the code is well-defined ( even if the compiler chooses not to implement copy elision).  Your code is not well-defined, because it specifies to call a deleted function.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "31777835", "Score": "1", "CreationDate": "2015-08-03T00:07:05.967", "LastActivityDate": "2015-08-03T00:07:05.967"}, "bq_ids": {"n4140": {"so_31775876_31775876_0": {"section_id": 481, "quality": 1.0, "length": 24}}, "n3337": {"so_31775876_31775876_0": {"section_id": 472, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_31775876_31775876_0": {"section_id": 504, "quality": 1.0, "length": 24}}}});