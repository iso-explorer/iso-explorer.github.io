post_cb({"bq_ids": {"n4140": {"so_39980854_39980889_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 955}}, "n3337": {"so_39980854_39980889_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 943}}}, "39981155": {"PostTypeId": "2", "Body": "<p>Yes, but I'd use <code>vec.data()</code> instead.  A bonus of using <code>.data()</code> is that non-contiguous <code>std</code> containers don't have it, so your code reliably stops compiling when the container being iterated over doesn't work that way (like <code>deque</code> or <code>std::vector&lt;bool&gt;</code>).  (There are other minor advantages, like <code>std::addressof</code> issues, and the fact it is well defined on empty containers, but those aren't as important especially here.)</p>\n<p>Alternatively we write an <code>index_t</code> iterator-like wrapper:</p>\n<pre><code>template&lt;class T&gt;\nstruct index_t {\n  T t;\n  T operator*()const{ return t; }\n  void operator++() { ++t; }\n  friend bool operator==( index_t const&amp; lhs, index_t const&amp; rhs ) {\n    return lhs.t == rhs.t;\n  }\n  friend bool operator!=( index_t const&amp; lhs, index_t const&amp; rhs ) {\n    return lhs.t != rhs.t;\n  }\n};\ntemplate&lt;class T&gt;\nindex_t&lt;T&gt; index(T t) { return {t}; }\n</code></pre>\n<p><code>index_t&lt;int&gt;</code> can be used to create counting <code>for(:)</code> loops.</p>\n<p><code>index_t&lt;iterator&gt;</code> can be used to create iterator-returning <code>for(:)</code> loops.</p>\n<pre><code>template&lt;class It&gt;\nstruct range_t {\n  It b,e;\n  It begin() const {return b;}\n  It end() const {return e;}\n};\ntemplate&lt;class It&gt;\nrange_t&lt;It&gt; range( It s, It f ) { return {s,f}; }\n\ntemplate&lt;class T&gt;\nrange_t&lt;index_t&lt;T&gt;&gt;\nindex_over( T s, T f ) {\n  return {{{s}}, {{f}}};\n}\ntemplate&lt;class Container&gt;\nauto iterators_of( Container&amp; c ) {\n  using std::begin; using std::end;\n  return index_over( begin(c), end(c) );\n}\n</code></pre>\n<p>we can now iterator over iterators of a container.</p>\n<pre><code>for (auto it : iterators_of(vec))\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a4de64b26bdb213f\">live example</a>.</p>\n<hr>\n<p>The mentioned iterate-over-integers is:</p>\n<pre><code>for (int i : index_over( 0, 100 ) )\n</code></pre>\n<p>we can also directly get the indexes of the container:</p>\n<pre><code>template&lt;class Container&gt;\nrange_t&lt; index_t&lt;std::size_t&gt; &gt;\nindexes_of( Container&amp; c ) {\n  return index_over( std::size_t(0), c.size() );\n}\ntemplate&lt;class T, std::size_t N&gt;\nrange_t&lt; index_t&lt;std::size_t&gt; &gt;\nindexes_of( T(&amp;)[N] ) {\n  return index_over( std::size_t(0), N );\n}\n</code></pre>\n<p>which lets us:</p>\n<pre><code>for( auto i : indexes_of( vec ) )\n</code></pre>\n<p>where <code>i</code> varies from <code>0</code> to <code>vec.size()-1</code>.  I find this is easier to work with sometimes than a zip iterator or the like.</p>\n<hr>\n<p>Improvements omitted:</p>\n<p>Make <code>index_t</code> a real <code>input_iterator</code>.  Use <code>std::move</code> and/or <code>std::forward</code> as needed in making indexes and ranges.  Support Sentinals on ranges.  Make <code>range_t</code> interface richer (<code>size</code>, optional random-access <code>[]</code>, <code>empty</code>, <code>front</code>, <code>back</code>, <code>range_t range_t::without_front(n) const</code>, etc.</p>\n</hr></hr>", "LastActivityDate": "2016-10-11T16:08:50.473", "LastEditorUserId": "1774667", "Id": "39981155", "CommentCount": "0", "CreationDate": "2016-10-11T15:36:43.020", "ParentId": "39980854", "Score": "18", "OwnerUserId": "1774667", "LastEditDate": "2016-10-11T16:08:50.473"}, "39980889": {"PostTypeId": "2", "Body": "<p>Yes, that's a valid solution. The underlying data is guaranteed to be contiguous (<code>std::vector</code> is supposed to be a dynamic array, more or less).</p>\n<blockquote>\n<p id=\"so_39980854_39980889_0\">n4140 \u00a723.3.6.1 [vector.overview]/1</p>\n<p id=\"so_39980854_39980889_1\">The elements of a <code>vector</code> are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code></p>\n</blockquote>\n", "LastActivityDate": "2016-10-11T15:35:01.727", "LastEditorUserId": "2456565", "Id": "39980889", "CommentCount": "6", "CreationDate": "2016-10-11T15:23:58.430", "ParentId": "39980854", "Score": "6", "OwnerUserId": "2456565", "LastEditDate": "2016-10-11T15:35:01.727"}, "39980854": {"ViewCount": "467", "Body": "<p>The C++11 introduced ranged-based for loop that is internally implemented using (const) iterators so this:</p>\n<pre><code>std::vector&lt;std::string&gt; vec;\n\nfor(std::string &amp;str : vec)\n{\n//...\n}\n</code></pre>\n<p>is basically equivalent to more verbose (yes, it could be simplified using <code>auto</code>):</p>\n<pre><code>for(std::vector&lt;std::string&gt;::iterator it = vec.begin(); it != vec.end(); ++it)\n{\n//...\n}\n</code></pre>\n<p>However commonly one needs an index of the item as well. With the second approach that is easy:</p>\n<pre><code>auto index = it - vec.begin();\n</code></pre>\n<p>In ranged-based <code>for</code> it is not so straightforward. But <strong>I was wondering if this was ok and portable solution</strong> that avoids iterators altogether:</p>\n<pre><code>for(auto &amp;str : vec)\n{\n    auto index = &amp;str - &amp;vec[0];\n}\n</code></pre>\n<p>(<code>const</code> version will be the same but one needs to watch out not to mix non-<code>const</code> container with const reference which might not always be obvious.)</p>\n<p>Obviously this relies on several assumptions:</p>\n<ul>\n<li><p>that iterator of vector is just a reference to an item (probably in the standard?)</p></li>\n<li><p>container is guaranteed contiguous (<code>std::vector</code> is...)</p></li>\n<li><p>the internal implementation of ranged based for (also probably in the standard)</p></li>\n</ul>\n", "AcceptedAnswerId": "39981155", "Title": "Obtaining item index in ranged based for on vector", "CreationDate": "2016-10-11T15:22:17.893", "Id": "39980854", "CommentCount": "4", "LastEditDate": "2016-10-11T15:30:25.133", "PostTypeId": "1", "LastEditorUserId": "2194193", "LastActivityDate": "2016-10-11T16:08:50.473", "Score": "13", "OwnerUserId": "2194193", "Tags": "<c++><c++11><ranged-loops>", "AnswerCount": "2"}});