post_cb({"bq_ids": {"n4140": {"so_15022060_15022107_1": {"length": 15, "quality": 1.0, "section_id": 472}}, "n3337": {"so_15022060_15022107_1": {"length": 15, "quality": 1.0, "section_id": 463}}, "n4659": {"so_15022060_15022107_1": {"length": 15, "quality": 1.0, "section_id": 495}}}, "15022107": {"Id": "15022107", "PostTypeId": "2", "Body": "<p>You're setting a member reference to a local temp variable. the parameter in your constructor is a temp). This is causing a \"dangling reference\", which is not good.</p>\n<p>Change the param to a reference, or change your member to a non-reference. For your purposes you'll likely want:</p>\n<pre><code>class A\n{\npublic:\n    A(string&amp; a):ma(a) { }\n\n    A&amp; operator =(const A&amp; other) \n    { \n        ma = other.ma; \n        return *this; \n    }\n\n    string&amp; ma;\n};\n</code></pre>\n<p>But you should know, the default copy constructor of your class is probably not going to do what you think it will. </p>\n<p><strong>UPDATE</strong></p>\n<p>Specific area of the standard dealing with why the default copy-assignment operator is deleted when the class has a reference member:</p>\n<blockquote>\n<p id=\"so_15022060_15022107_0\">C++11 \u00a7 12.8,p23</p>\n<p id=\"so_15022060_15022107_1\">A defaulted copy/move assignment operator for class X is defined as deleted if X has:\n  - a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or</p>\n<ul>\n<li>a non-static data member of const non-class type (or array thereof), or</li>\n<li><strong>a non-static data member of reference type</strong>, or</li>\n<li>a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or</li>\n<li>a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B\u2019s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or</li>\n<li>for the move assignment operator, a non-static data member or direct base class with a type that does not have a move assignment operator and is not trivially copyable, or any direct or indirect virtual base class.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "1322972", "LastActivityDate": "2013-02-22T11:21:46.063", "Score": "1", "CreationDate": "2013-02-22T10:34:48.017", "ParentId": "15022060", "CommentCount": "4", "OwnerUserId": "1322972", "LastEditDate": "2013-02-22T11:21:46.063"}, "15022060": {"ViewCount": "57", "Body": "<p>The following code is correct</p>\n<pre><code>    string s1=\"abc\";\n    string s2=\"bcd\";\n    string &amp;rs1=s1;\n    string &amp;rs2=s2;\n    rs1=rs2;\n    cout&lt;&lt;rs1&lt;&lt;\"----\"&lt;&lt;rs2&lt;&lt;endl;\n</code></pre>\n<p>And thefollowing code will compile error:</p>\n<pre><code>class A\n{\npublic:\n    A(string&amp; a):ma(a) { }\n\n    string&amp; ma;\n};\n\nstring s1=\"abc\";\nstring s2=\"bcd\";\nA oa(s1);\nA ob(s2);\noa=ob;\ncout&lt;&lt;oa.ma&lt;&lt;\"----\"&lt;&lt;ob.ma&lt;&lt;endl;\n</code></pre>\n<p>All above is <code>string&amp;</code> type assignment, why put them into class will cause a compile error?\n(gcc version 4.7.1 )</p>\n<p>error info is  </p>\n<pre><code>non-static reference member 'std::string&amp; A::ma', can't use default assignment operator\n</code></pre>\n", "AcceptedAnswerId": "15022107", "Title": "confusion about c++ reference in class", "CreationDate": "2013-02-22T10:32:31.377", "Id": "15022060", "CommentCount": "5", "LastEditDate": "2013-02-22T10:54:55.133", "PostTypeId": "1", "LastEditorUserId": "1406245", "LastActivityDate": "2013-02-22T11:21:46.063", "Score": "0", "OwnerUserId": "1406245", "Tags": "<c++>", "AnswerCount": "1"}});