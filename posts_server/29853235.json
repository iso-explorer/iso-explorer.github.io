post_cb({"29853235": {"CommentCount": "5", "AcceptedAnswerId": "29853544", "PostTypeId": "1", "LastEditorUserId": "4516316", "CreationDate": "2015-04-24T16:54:59.057", "LastActivityDate": "2015-04-24T17:39:23.387", "LastEditDate": "2015-04-24T17:09:35.103", "ViewCount": "336", "FavoriteCount": "1", "Title": "static initialization of user defined type in C++ (Win64/PC)", "Id": "29853235", "Score": "2", "Body": "<p>I use VS2012  Win64/PC</p>\n<p>I know there is a lot about what is a static variable and about the initialization order, this goes a bit further.</p>\n<p>Imagine in 1 CPP, the following lines:</p>\n<pre><code>struct A\n{\n  void* a;\n  size_t b;\n};\n\nstatic bool bMyBoolean = true;\nstatic std::vector&lt;A&gt; myVector;\n</code></pre>\n<p>The guarantee here is that <code>bMyBoolean</code> is initialized before <code>myVector</code>.\nThey also are both initialized before <code>main()</code> gets called.<br>\nHowever, <code>myVector</code> has a valid value and memory address, but gets initialized during _initterm while <code>bMyboolean</code> is initialized earlier and doesn't need an initialize call during initterm.</br></p>\n<p>This is due to it being a native type it seems, but I can't find any references or info about this behavior.</p>\n<p>A bit of context: when I overload <code>malloc</code> for example, and a constructor is called for a userdefined type, it will go into <code>malloc</code>, but some of your static data here is not ready yet (this is expected since static variables between translation units is not guaranteed) but it means I can access and alter it safely, and then it gets re-initialized.</p>\n<p>This leads me to the next question, where does this memory live then?<br>\nDoes it get in-place reconstructed?<br>\nSince a <code>malloc</code> call is being made, it then gets initialized. Does it mean the native variables live in a static heap that is allocated at boot of the program, and the user defined types live on the heap?</br></br></p>\n<p>If that is the case, how can you track your user defined types that are declared static?</p>\n", "Tags": "<c++><initialization><64bit><pc>", "OwnerUserId": "1090031", "AnswerCount": "3"}, "29854042": {"ParentId": "29853235", "CommentCount": "1", "CreationDate": "2015-04-24T17:39:23.387", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29854042", "Score": "1", "Body": "<p>You've got four questions in your post. However, I have a hunch that your primary concern is that the states of some of the <code>static</code> objects are modified by <code>malloc</code> before those objects are initialized by the run time environment.</p>\n<p>It's better not to rely on the initialization order of global <code>static</code> variables.</p>\n<p>If <code>malloc</code> needs to modify some <code>static</code> data, it's better to provide access to those data through a function.</p>\n<p>Instead of:</p>\n<pre><code>static std::vector&lt;A&gt; myVector;\n</code></pre>\n<p>use</p>\n<pre><code>static std::vector&lt;A&gt;&amp; getVector()\n{\n   static std::vector&lt;A&gt; myVector;\n   return myVector;\n}\n</code></pre>\n<p>If you do that, <code>myVector</code> is guaranteed to be initialized when the function returns.</p>\n", "LastActivityDate": "2015-04-24T17:39:23.387"}, "29853617": {"ParentId": "29853235", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-04-24T17:16:40.790", "Score": "0", "LastEditorUserId": "1348273", "LastEditDate": "2015-04-24T17:31:42.370", "Id": "29853617", "OwnerUserId": "1348273", "Body": "<p><code>bMyBoolean</code> and <code>myVector</code> both live in static storage, contributing a total of <code>sizeof(bool) + sizeof(std::vector&lt;A&gt;)</code> bytes. Static storage is in the image file itself, say <code>app.exe</code>. When you execute <code>app.exe</code>, Windows loads (maps) the image file into the virtual memory address spawned for the new process, and that is when the originally \"dead\" static storage comes into alive. The system later runs the code in <code>app.exe</code>, which involves invoking the constructor of <code>std::vector&lt;A&gt;</code> on <code>myVector</code>. That is, on the static storage of <code>myVector</code>. Remember the <code>this</code> pointer? The <code>this</code> pointer passed to the constructor will point to the static storage of <code>myVector</code>. The memory allocated by the constructor is then dynamic and on the heap. Pointer to this dynamic storage is stored in the static storage of <code>myVector</code>.</p>\n<p>I suggest you to read more about linking and loading.</p>\n", "LastActivityDate": "2015-04-24T17:31:42.370"}, "29853544": {"ParentId": "29853235", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-04-24T17:12:12.980", "Score": "2", "LastEditorUserId": "2812864", "LastEditDate": "2015-04-24T17:21:55.133", "Id": "29853544", "OwnerUserId": "2812864", "Body": "<p>That's because C++ standard distinguishes three types of initialization:</p>\n<ul>\n<li>zero-initialization</li>\n<li>constant initialization</li>\n<li>dynamic initialization.</li>\n</ul>\n<p><strong>\u00a7 3.6.2</strong></p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_29853235_29853544_0\">Variables with static storage duration or thread storage duration shall be zero-initialized before any other initialization takes place.</p>\n<p id=\"so_29853235_29853544_1\">Constant initialization is performed:</p>\n<ul>\n<li>if each full-expression (including implicit conversions) that appears in the initializer of a reference with static or thread\n  storage duration is a constant expression and the reference is bound\n  to an lvalue designating an object with static storage duration or to\n  a temporary</li>\n<li>if an object with static or thread storage duration is initialized by a constructor call, if the constructor is a constexpr constructor,\n  if all constructor arguments are constant expressions (including\n  conversions), and if, after function invocation substitution, every\n  constructor call and full-expression in the mem-initializers and in\n  the brace-or-equal initializers for non-static data members is a\n  constant expression</li>\n<li>if an object with static or thread storage duration is not initialized by a constructor call and if every full-expression that\n  appears in its initializer is a constant expression.</li>\n</ul>\n<p id=\"so_29853235_29853544_2\">Together, zero-initialization and constant initialization are called\n  static initialization; all other initialization is dynamic\n  initialization. Static initialization shall be performed before any\n  dynamic initialization takes place.</p></li>\n</ol>\n</blockquote>\n<p>What are you talking about is constant initialization (a part of static initialization) and it is not restricted to built-in types.</p>\n<p>Get familiar with section <strong>3.6.2</strong> of the standard: <strong>\"Initialization of non-local variables\"</strong> if you want to know more.</p>\n<hr>\n<blockquote>\n<p id=\"so_29853235_29853544_3\">[...] but it means I can access and alter it safely, and then it gets re-initialized.</p>\n</blockquote>\n<p>Of course - you can always modify content under specific memory location as long as OS allows you to do so. Think about it like placement new - there is an allocated memory for such object, but constructor gets called when it comes to initialization phase. So it is initialized \"in place\".</p>\n<blockquote>\n<p id=\"so_29853235_29853544_4\">Does it mean the native variables live in a static heap that is allocated at boot of the program, and the user defined types live on the heap?</p>\n</blockquote>\n<p>No. There is no direct connection between type of variable and its location. Local variables are placed on the stack, dynamic (allocated via <code>malloc()</code>/<code>new</code>) live inside the heap and static are placed inside the image (for example <code>MyApp.exe</code>). After app is executed, it is loaded to memory, including all objects with static storage, for which memory is reserved at this point. You may consider such objects valid as long as <code>main()</code> is running.</p>\n</hr>", "LastActivityDate": "2015-04-24T17:21:55.133"}, "bq_ids": {"n4140": {"so_29853235_29853544_2": {"section_id": 7151, "quality": 0.9, "length": 18}, "so_29853235_29853544_0": {"section_id": 7151, "quality": 1.0, "length": 13}}, "n3337": {"so_29853235_29853544_2": {"section_id": 6895, "quality": 0.9, "length": 18}, "so_29853235_29853544_0": {"section_id": 6895, "quality": 1.0, "length": 13}}, "n4659": {"so_29853235_29853544_2": {"section_id": 8652, "quality": 0.7, "length": 14}, "so_29853235_29853544_0": {"section_id": 4051, "quality": 0.6923076923076923, "length": 9}}}});