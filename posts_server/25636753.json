post_cb({"bq_ids": {"n4140": {"so_25636753_25636753_0": {"section_id": 7193, "quality": 0.9444444444444444, "length": 68}, "so_25636753_25636753_2": {"section_id": 7193, "quality": 1.0, "length": 10}}, "n3337": {"so_25636753_25636753_0": {"section_id": 6937, "quality": 0.8888888888888888, "length": 64}, "so_25636753_25636753_2": {"section_id": 6937, "quality": 1.0, "length": 10}}, "n4659": {"so_25636753_25636753_0": {"section_id": 8702, "quality": 0.9305555555555556, "length": 67}, "so_25636753_25636753_2": {"section_id": 8702, "quality": 1.0, "length": 10}}}, "25636788": {"ParentId": "25636753", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-09-03T05:23:55.967", "Score": "18", "LastEditorUserId": "841108", "LastEditDate": "2017-09-17T16:36:43.907", "Id": "25636788", "OwnerUserId": "841108", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">Undefined behavior</a> means that <em>anything</em> can happen with a standard conforming implementation. Really anything. (and your point 2 is UB)</p>\n<p>An implementation could</p>\n<ul>\n<li>explode your computer and harm you physically</li>\n<li>make a black-hole which swallows the entire solar system</li>\n<li>do nothing serious</li>\n<li>light some LED on your keyboard</li>\n<li>make some time-travel and kill all your grandparents before the birth of your own parents</li>\n<li>etc.... </li>\n</ul>\n<p>and be conforming (in the event of UB); read also about the more familiar idea of <a href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow noreferrer\">nasal demons</a>.</p>\n<p>So what happens on UB is not predictable and is not reproducible (in general).</p>\n<p><sup>More seriously, think a bit about what UB could mean in the computer connected to the ABS brakes of your car, or in some <a href=\"https://en.wikipedia.org/wiki/Artificial_heart\" rel=\"nofollow noreferrer\">artificial heart</a>, or driving some nuclear power plant.</sup></p>\n<p>In particular, it might work sometimes. Since most OSes have <a href=\"http://en.wikipedia.org/wiki/Address_space_layout_randomization\" rel=\"nofollow noreferrer\">ASLR</a> your code has a tiny chance to work (e.g. if <code>0xa31a3442</code> happens to point to some <em>valid</em> location, e.g. on the stack, but you won't reproduce that on the next run!)</p>\n<p>UB is a way to give freedom to implementors (e.g. of compilers or of OSes) and to computers to do whatever they \"want\", in other words to not care about consequences. This enables e.g. clever optimizations or nice implementation tricks. But <em>you</em> should care (and consequences are different if you are coding the embedded flight control system of a airplane, or just some hacky demo lighting LEDs with a RasberryPi, or a simple example for some C++ course running on Linux).</p>\n<p>Recall that languages standards don't even require any computer (or any hardware) in the implementation: you might \"run\" your C++ code with a team of human slaves, but that would be highly unethical (and costly, and unreliable).</p>\n<p>See also <a href=\"https://softwareengineering.stackexchange.com/a/289020/40065\">here</a> for more references. You should at least read <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow noreferrer\">Lattner's blog on <em>Undefined Behavior</em></a> (most of what he wrote for C applies to C++ and many other languages having UB).</p>\n<hr>\n<p><sup>(added in december 2015 &amp; june 2016)</sup></p>\n<p>NB. The <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">valgrind</a> tool and various <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html\" rel=\"nofollow noreferrer\"><code>-fsanitize=</code> debugging options</a> for recent <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a> or <a href=\"http://clang.llvm.org/\" rel=\"nofollow noreferrer\">Clang/LLVM</a> are quite useful. Also, enable all warnings and debug info in your compiler (e.g. <code>g++ -Wall -Wextra -g</code>), and use appropriate <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html\" rel=\"nofollow noreferrer\">instrumentation options</a> such as <code>-fsanitize=undefined</code>. Be aware that it is impossible to detect statically and exhaustively at compile time <em>all</em> cases of UB (that would be equivalent to the <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" rel=\"nofollow noreferrer\">Halting Problem</a>).</p>\n<p><sup>PS. The above answer is not specific to C++; it also fits for C!</sup></p>\n</hr>", "LastActivityDate": "2017-09-17T16:36:43.907"}, "25636753": {"CommentCount": "3", "AcceptedAnswerId": "25636788", "OwnerDisplayName": "user2953119", "CreationDate": "2014-09-03T05:19:24.513", "LastActivityDate": "2017-09-17T16:36:43.907", "PostTypeId": "1", "ViewCount": "1103", "FavoriteCount": "1", "Title": "Is segmentation fault actual undefined behavior when we refer to a non-static data-member", "Id": "25636753", "Score": "5", "Body": "<p>I had read the following rule and I've been trying to write an example, which reflects one.\nThe rule is from 3.8/5 N3797:</p>\n<blockquote>\n<p id=\"so_25636753_25636753_0\">Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated or, after the lifetime\n  of an object has ended and before the storage which the object\n  occupied is reused or released, any pointer that refers to the storage\n  location where the object will be or was located may be used but only\n  in limited ways. For an object under construction or destruction, see\n  12.7. <strong>Otherwise</strong>, such a pointer refers to allocated storage (3.7.4.2), and using the    pointer as if the pointer were of type <code>void*</code> is well-defined. Indirection through such a pointer is permitted but  the resulting lvalue may only be used in limited ways, as described\n  below. The program has undefined behavior if:</p>\n<p id=\"so_25636753_25636753_1\">[...] </p>\n<p id=\"so_25636753_25636753_2\">\u2014 the pointer is used to access a non-static data member or call a\n  non-static member function of the object, or</p>\n<p id=\"so_25636753_25636753_3\">[...]</p>\n</blockquote>\n<p>The example I've written for:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing std::cout;\nusing std::endl;\n\nstruct A\n{\n    int b = 5;\n    static const int a = 5;\n};\n\nint main()\n{\n    A *p = (A*)0xa31a3442;\n    cout &lt;&lt; p -&gt; a; //1, Well-fromed, there is no compile-time error\n    cout &lt;&lt; p -&gt; b; //2, Segmentation fault is producing\n}\n</code></pre>\n<p>Is it true that in the case <code>//1</code> is well-formed and doesn't cause any <code>UB</code>, but <code>//2</code> produced segmentation fault, which is <code>UB</code>?</p>\n", "Tags": "<c++><pointers><undefined-behavior>", "AnswerCount": "3"}, "25636902": {"ParentId": "25636753", "CommentCount": "0", "CreationDate": "2014-09-03T05:34:40.113", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "25636902", "Score": "1", "Body": "<p>You asked:</p>\n<blockquote>\n<p id=\"so_25636753_25636902_0\">Is it true that in the case //1 is well-formed and doesn't cause any UB?</p>\n</blockquote>\n<p>The parts of the standard you quoted does not mention anything about it.</p>\n<p>You also asked:</p>\n<blockquote>\n<p id=\"so_25636753_25636902_1\">but //2 produced segmentation fault, which is UB? </p>\n</blockquote>\n<p>The parts of the standard you quoted does not correspond to this particular behavior. You are seeing UB because of where <code>p</code> points. It points to memory that does not hold a valid object.</p>\n", "LastActivityDate": "2014-09-03T05:34:40.113"}, "25636879": {"ParentId": "25636753", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-03T05:32:44.517", "Score": "1", "LastEditorUserId": "3995498", "LastEditDate": "2014-09-03T05:39:59.107", "Id": "25636879", "OwnerUserId": "3995498", "Body": "<p>Rule 3.8/5 is about the time outside of the construction/destruction of an object but inside the allocation/release of the memory in which the object resides.  The following demonstrates the points outside of the lifetime of an object:</p>\n<pre><code>void *buffer = malloc(sizeof(A));\n// outside of lifetime of a\n// a-&gt;b is undefined\nA* a = new (buffer) A();\n// within lifetime of a\n// a-&gt;b is valid\na-&gt;~A();\n// outside of lifetime of a\n// a-&gt;b is undefined\nfree(buffer);\n</code></pre>\n<p>Technically, your post doesn't actually reflect rule 3.8/5, because you are not accessing the object outside of its lifetime. You are simply casting random memory as an instance.</p>\n", "LastActivityDate": "2014-09-03T05:39:59.107"}});