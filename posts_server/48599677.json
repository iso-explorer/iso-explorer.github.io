post_cb({"bq_ids": {"n4140": {"so_48599677_48600248_0": {"length": 20, "quality": 0.6060606060606061, "section_id": 5797}}, "n3337": {"so_48599677_48600248_0": {"length": 20, "quality": 0.6060606060606061, "section_id": 5570}}, "n4659": {"so_48599677_48600248_0": {"length": 20, "quality": 0.6060606060606061, "section_id": 7256}}}, "48599711": {"Id": "48599711", "PostTypeId": "2", "Body": "<p>It can mostly on cases where the output control flow of the program doesn't depend on the run time event(this is one of the most common technique). For example, here this won't be optimized because you never know what the value of <code>i</code> wll be. But this will be for sure,</p>\n<pre><code>static void bar(int i) {\n  i = 1;\n  if(i &gt; 0) {\n    //Do something useful\n    printf(\"FOO-BAR\");\n  }\n}\n</code></pre>\n<p>Here no matter what the next <code>i&gt;0</code> check is redundant. Moreover , you always should generate the assembly and look for it. compilers can be very aggresive on this regard of optimization. </p>\n<p>There is another thing to notice over here - for example here the compiler won't optimize this code - even if it is used always for greater than <code>0</code> valued parameters. There is no way compiler will predict that. </p>\n<p>The most common techniques in code optimizations involve - checking the data flow graph, dead code elimination, loop unrolling (which certainly can't be applied non-aggresively in your small example).</p>\n", "LastEditorUserId": "3796113", "LastActivityDate": "2018-02-04T18:17:56.913", "Score": "2", "CreationDate": "2018-02-03T16:53:23.733", "ParentId": "48599677", "CommentCount": "7", "OwnerUserId": "3796113", "LastEditDate": "2018-02-04T18:17:56.913"}, "48600248": {"Id": "48600248", "PostTypeId": "2", "Body": "<p>Standard allows for it.</p>\n<p>For C language, draft n1570 says in 5.1.2.3 Program execution (emphasize mine)</p>\n<blockquote>\n<p id=\"so_48599677_48600248_0\">1 The semantic descriptions in this International Standard describe the behavior of an\n  abstract machine in which issues of optimization are irrelevant<br/>...<br/>\n  4 In the abstract machine, all expressions are evaluated as specified by the semantics. <strong>An\n  actual implementation need not evaluate part of an expression if it can deduce that its\n  value is not used and that no needed side effects are produced</strong></p>\n</blockquote>\n<hr>\n<p>For C++ draft n1659 contains at 4.6 Program execution [intro.execution]</p>\n<blockquote>\n<p id=\"so_48599677_48600248_1\">1 The semantic descriptions in this International Standard define a parameterized nondeterministic abstract\n  machine. This International Standard places no requirement on the structure of conforming implementations.\n  In particular, they need not copy or emulate the structure of the abstract machine. Rather, <strong>conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine</strong> as explained\n  below.6\n  <br/>...<br/>\n  5 <strong>A conforming implementation executing a well-formed program shall produce the same observable behavior as\n  one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input</strong>. However, if any such execution contains an undefined operation, this International\n  Standard places no requirement on the implementation executing that program with that input (not even\n  with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n</hr>", "LastEditorUserId": "445296", "LastActivityDate": "2018-02-04T19:26:18.547", "Score": "2", "CreationDate": "2018-02-03T17:51:41.207", "ParentId": "48599677", "CommentCount": "0", "OwnerUserId": "3545273", "LastEditDate": "2018-02-04T19:26:18.547"}, "48599677": {"ViewCount": "168", "Body": "<p>Let us consider following block of code written in C:</p>\n<pre><code>void foo(int i) {\n  if(i &gt; 0) {\n    bar(i);\n  }\n}\n\nstatic void bar(int i) {\n  if(i &gt; 0) {\n    //Do something useful\n    printf(\"FOO-BAR\");\n  }\n}\n</code></pre>\n<p>Can a good mainstream C compiler optimize out the unnecessary <strong>i &gt; 0</strong> comparison from the bar(int) called inside foo(int)?</p>\n<p>If yes then under what circumstances and if no then why not?</p>\n", "AcceptedAnswerId": "48611795", "Title": "Can a compiler optimize out unnecessary comparison?", "CreationDate": "2018-02-03T16:50:02.593", "Id": "48599677", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2018-02-04T19:32:56.240", "Score": "1", "OwnerUserId": "2856296", "Tags": "<c++><c><optimization>", "AnswerCount": "3"}, "48611795": {"Id": "48611795", "PostTypeId": "2", "Body": "<p>A C++ compiler is free to make any optimization that is not observable. The optimizers are much more cleaver than most might imagine. <a href=\"https://youtu.be/bSkpMdDe4g4\" rel=\"nofollow noreferrer\">What Has My Compiler Done For Me Lately?</a> What's probably going to happen in the given case is that <code>foo</code> will be converted to this:</p>\n<pre><code>void foo(int i) {\n  if(i &gt; 0) {\n     printf(\"FOO-BAR\");\n  }\n}\n</code></pre>\n<p>That is what VC++ 2017 does. In fact, it optimizes away both <code>foo</code> and <code>bar</code> and performs only one test when given the following MCVE.</p>\n<pre><code>static void bar(int i) {\n    if (i &gt; 0) {\n        //Do something useful\n        printf(\"FOO-BAR\");\n    }\n}\n\nvoid foo(int i) {\n    if (i &gt; 0) {\n        bar(i);\n    }\n}\n\nint main() {\n    int i;\n    scanf(\"%d\", &amp;i);\n    foo(i);\n}\n</code></pre>\n<p>Below is the resulting assembly. Notice that after reading the <code>int i</code> from stdin, the next instruction is a <code>cmp</code> (compare) followed by <code>jle</code> (jump if less-than-or-equal). No <code>foo</code> or <code>bar</code> survived the optimizer.</p>\n<pre><code>  int main() {\n000000013F401000  sub         rsp,38h  \n000000013F401004  mov         rax,qword ptr [__security_cookie (013F403000h)]  \n000000013F40100B  xor         rax,rsp  \n000000013F40100E  mov         qword ptr [rsp+28h],rax  \n    int i;\n    scanf(\"%d\", &amp;i);\n000000013F401013  lea         rdx,[i]  \n000000013F401018  lea         rcx,[string \"%d\" (013F402228h)]  \n000000013F40101F  call        scanf (013F401060h)  \n    foo(i);\n000000013F401024  cmp         dword ptr [i],0  \n000000013F401029  jle         main+37h (013F401037h)  \n000000013F40102B  lea         rcx,[string \"FOO-BAR\" (013F402220h)]  \n000000013F401032  call        printf (013F4010D0h)  \n}\n000000013F401037  xor         eax,eax  \n000000013F401039  mov         rcx,qword ptr [rsp+28h]  \n000000013F40103E  xor         rcx,rsp  \n000000013F401041  call        __security_check_cookie (013F401140h)  \n000000013F401046  add         rsp,38h  \n000000013F40104A  ret  \n</code></pre>\n", "LastEditorUserId": "445296", "LastActivityDate": "2018-02-04T19:32:56.240", "Score": "2", "CreationDate": "2018-02-04T18:50:16.103", "ParentId": "48599677", "CommentCount": "0", "OwnerUserId": "445296", "LastEditDate": "2018-02-04T19:32:56.240"}});