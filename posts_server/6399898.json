post_cb({"6400860": {"ParentId": "6399898", "CommentCount": "1", "Body": "<p>It really looks like a C vs. C++ difference, to me. C++ implicitly typedefs structs and unions to their tags; so adding the typedef is superfluous, but not an error. I don't know if this works for enums as well.</p>\n<p>The thing to do next is to see what variable definitions are permitted after these declarations.</p>\n<pre><code>enum test etest;\ntest etest2;\nstruct named snamed;\nnamed snamed2;\n</code></pre>\n", "OwnerUserId": "733077", "PostTypeId": "2", "Id": "6400860", "Score": "0", "CreationDate": "2011-06-19T06:01:30.673", "LastActivityDate": "2011-06-19T06:01:30.673"}, "6399998": {"ParentId": "6399898", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is a degenerate syntax that is allowed but provides no benefit.  Most modern compilers can be provoked into emitting a warning about it; by default, they may not.  Without the typedef name, the keyword <code>typedef</code> is superfluous; in your example, it is completely equivalent to:</p>\n<pre><code>enum test { one };\n</code></pre>\n<p>Another place where it can occur is with a structure:</p>\n<pre><code>typedef struct SomeThing { int whatever; };\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>struct SomeThing { int whatever; };\n</code></pre>\n<p>Note that <code>typedef</code> is officially (or syntactically) a 'storage class specifier', like <code>static</code>, <code>extern</code>, <code>auto</code> and <code>register</code>.</p>\n<hr>\n<h2>C Standard</h2>\n<p>In ISO/IEC 9899:1999 (that's the C standard), we find:</p>\n<blockquote>\n<h3>\u00a76.7 Declarations</h3>\n<p id=\"so_6399898_6399998_0\"><strong>Syntax</strong></p>\n<p id=\"so_6399898_6399998_1\"><em>declaration</em>:</p>\n<p id=\"so_6399898_6399998_2\"><code></code> <em>declaration-specifiers</em> <i>init-declarator-list</i><sub>opt</sub>;</p>\n<p id=\"so_6399898_6399998_3\"><em>declaration-specifiers</em>:</p>\n<p id=\"so_6399898_6399998_4\"><code></code> <em>storage-class-specifier</em> <i>declaration-specifiers</i><sub>opt</sub></p>\n<p id=\"so_6399898_6399998_5\"><code></code> <em>type-specifier</em> <i>declaration-specifiers</i><sub>opt</sub></p>\n<p id=\"so_6399898_6399998_6\"><code></code> <em>type-qualifier</em> <i>declaration-specifiers</i><sub>opt</sub></p>\n<p id=\"so_6399898_6399998_7\"><code></code> <em>function-specifier</em> <i>declaration-specifiers</i><sub>opt</sub></p>\n<p id=\"so_6399898_6399998_8\"><em>init-declarator-list</em>:</p>\n<p id=\"so_6399898_6399998_9\"><code></code> <em>init-declarator</em></p>\n<p id=\"so_6399898_6399998_10\"><code></code> <em>init-declarator-list</em> , <em>init-declarator</em></p>\n<p id=\"so_6399898_6399998_11\"><em>init-declarator</em>:</p>\n<p id=\"so_6399898_6399998_12\"><code></code> <em>declarator</em></p>\n<p id=\"so_6399898_6399998_13\"><code></code> <em>declarator</em> = <em>initializer</em></p>\n</blockquote>\n<p>And (as requested):</p>\n<blockquote>\n<h3>\u00a76.7.1 Storage-class specifiers</h3>\n<p id=\"so_6399898_6399998_14\"><strong>Syntax</strong></p>\n<p id=\"so_6399898_6399998_15\">storage-class-specifier:</p>\n<p id=\"so_6399898_6399998_16\"><code>typedef</code></p>\n<p id=\"so_6399898_6399998_17\"><code>extern</code></p>\n<p id=\"so_6399898_6399998_18\"><code>static</code></p>\n<p id=\"so_6399898_6399998_19\"><code>auto</code></p>\n<p id=\"so_6399898_6399998_20\"><code>register</code></p>\n</blockquote>\n<p>If you track through that syntax, there are a lot of degenerate possibilities, and what you showed is just one of the many.</p>\n<hr>\n<h2>C++ Standard</h2>\n<p>It is possible that C++ has different rules.</p>\n<p>In ISO/IEC 14882:1998 (the original C++ standard), we find in \u00a77.1.1 'Storage class specifiers' that C++ does not treat <code>typedef</code> as a storage class; the list adds <code>mutable</code> and excludes <code>typedef</code>.  So, the grammatical specification of <code>typedef</code> in C++ is definitely different from the C specification.</p>\n<blockquote id=\"so_6399898_6399998_21\">\n<h3>\u00a77 Declarations</h3>\n</blockquote>\n<p>Declarations specify how names are to be interpreted. Declarations have the form</p>\n<blockquote>\n<p id=\"so_6399898_6399998_22\">declaration-seq:</p>\n<p id=\"so_6399898_6399998_23\"><code></code> declaration</p>\n<p id=\"so_6399898_6399998_24\"><code></code> declaration-seq declaration</p>\n<p id=\"so_6399898_6399998_25\">declaration:</p>\n<p id=\"so_6399898_6399998_26\"><code></code> block-declaration</p>\n<p id=\"so_6399898_6399998_27\"><code></code> function-definition</p>\n<p id=\"so_6399898_6399998_28\"><code></code> template-declaration</p>\n<p id=\"so_6399898_6399998_29\"><code></code> explicit-instantiation</p>\n<p id=\"so_6399898_6399998_30\"><code></code> explicit-specialization</p>\n<p id=\"so_6399898_6399998_31\"><code></code> linkage-specification</p>\n<p id=\"so_6399898_6399998_32\"><code></code> namespace-definition</p>\n<p id=\"so_6399898_6399998_33\">block-declaration:</p>\n<p id=\"so_6399898_6399998_34\"><code></code> simple-declaration</p>\n<p id=\"so_6399898_6399998_35\"><code></code> asm-definition</p>\n<p id=\"so_6399898_6399998_36\"><code></code> namespace-alias-definition</p>\n<p id=\"so_6399898_6399998_37\"><code></code> using-declaration</p>\n<p id=\"so_6399898_6399998_38\"><code></code> using-directive</p>\n<p id=\"so_6399898_6399998_39\">simple-declaration:</p>\n<p id=\"so_6399898_6399998_40\"><code></code> decl-specifier-seq<sub>opt</sub> init-declarator-list<sub>opt</sub> ;</p>\n<p id=\"so_6399898_6399998_41\">...</p>\n<p id=\"so_6399898_6399998_42\">\u00b65 If the decl-specifier-seq\n  contains the <code>typedef</code> specifier, the declaration is called a <code>typedef</code> declaration and\n  the name of each <code>init-declarator</code>\n  is declared to be a typedef-name,\n  synonymous with its associated type\n  (7.1.3).</p>\n<h3>\u00a77.1 Specifiers [dcl.spec]</h3>\n<p id=\"so_6399898_6399998_43\">The specifiers that can be used in a declaration are</p>\n<p id=\"so_6399898_6399998_44\">decl-specifier:</p>\n<p id=\"so_6399898_6399998_45\"><code></code> storage-class-specifier</p>\n<p id=\"so_6399898_6399998_46\"><code></code> type-specifier</p>\n<p id=\"so_6399898_6399998_47\"><code></code> function-specifier</p>\n<p id=\"so_6399898_6399998_48\"><code></code> <code>friend</code></p>\n<p id=\"so_6399898_6399998_49\"><code></code> <code>typedef</code></p>\n<p id=\"so_6399898_6399998_50\">decl-specifier-seq:</p>\n<p id=\"so_6399898_6399998_51\"><code></code> decl-specifier-seq<sub>opt</sub></p>\n<p id=\"so_6399898_6399998_52\"><code></code> decl-specifier</p>\n<h3>\u00a77.1.1 Storage class specifiers [dcl.stc]</h3>\n<p id=\"so_6399898_6399998_53\">storage-class-specifier:</p>\n<p id=\"so_6399898_6399998_54\"><code>auto</code></p>\n<p id=\"so_6399898_6399998_55\"><code>register</code></p>\n<p id=\"so_6399898_6399998_56\"><code>static</code></p>\n<p id=\"so_6399898_6399998_57\"><code>extern</code></p>\n<p id=\"so_6399898_6399998_58\"><code>mutable</code></p>\n<h3>\u00a77.1.2 Function specifiers [dcl.fct.spec]</h3>\n<p id=\"so_6399898_6399998_59\">function-specifier:</p>\n<p id=\"so_6399898_6399998_60\"><code>inline</code></p>\n<p id=\"so_6399898_6399998_61\"><code>virtual</code></p>\n<p id=\"so_6399898_6399998_62\"><code>explicit</code></p>\n<h3>\u00a77.1.3 The typedef specifier [dcl.typedef]</h3>\n<p id=\"so_6399898_6399998_63\">Declarations containing the decl-specifier\n  <code>typedef</code> declare identifiers that can be used later for naming\n  fundamental (3.9.1) or compound (3.9.2) types. The <code>typedef</code> specifier shall not be used in a function-definition\n  (8.4), and it shall not be combined in a decl-specifier-seq\n  with any other kind of specifier except\n  a type-specifier.</p>\n<p id=\"so_6399898_6399998_64\">typedef-name:</p>\n<p id=\"so_6399898_6399998_65\"><code></code> identifier</p>\n<p id=\"so_6399898_6399998_66\">...</p>\n<p id=\"so_6399898_6399998_67\">In a given scope, a typedef specifier can be used to redefine the name of any type declared in that scope\n  to refer to the type to which it already refers. [Example:</p>\n<pre><code>typedef struct s { /* ... */ } s;\ntypedef int I;\ntypedef int I;\ntypedef I I;\n</code></pre>\n<p id=\"so_6399898_6399998_68\">\u2014end example]</p>\n<h3>\u00a77.1.4 The friend specifier [dcl.friend]</h3>\n<p id=\"so_6399898_6399998_69\">The friend specifier is used to specify access to class members; see 11.4.</p>\n<h3>\u00a77.1.5 Type specifiers [dcl.type]</h3>\n<p id=\"so_6399898_6399998_70\">type-specifier:</p>\n<p id=\"so_6399898_6399998_71\"><code></code> simple-type-specifier</p>\n<p id=\"so_6399898_6399998_72\"><code></code> class-specifier</p>\n<p id=\"so_6399898_6399998_73\"><code></code> enum-specifier</p>\n<p id=\"so_6399898_6399998_74\"><code></code> elaborated-type-specifier</p>\n<p id=\"so_6399898_6399998_75\"><code></code> cv-qualifier</p>\n</blockquote>\n<hr>\n<p>Since \u00a77 \u00b65 says that <code>typedef</code> names come from the <em>init-declarator</em> and the <em>init-declarator-list</em> is tagged '<em>opt</em>', I think that means that the <code>typedef</code> name can be omitted in C++, just as in C.</p>\n</hr></hr></hr>", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2011-06-19T10:38:26.720", "Id": "6399998", "Score": "36", "CreationDate": "2011-06-19T01:28:44.713", "LastActivityDate": "2011-06-19T10:38:26.720"}, "6399931": {"ParentId": "6399898", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The only thing I could find was the following in the C++03 standard <code>\u00a77.1.3 [dcl.typedef] p1</code>:</p>\n<blockquote>\n<p id=\"so_6399898_6399931_0\"><em>typedef-name:</em></p>\n<ul>\n<li><em>identifier</em></li>\n</ul>\n<p id=\"so_6399898_6399931_1\">A name declared with the <code>typedef</code> specifier becomes a <em>typedef-name</em>.</p>\n</blockquote>\n<p>Notice the missing <em><sub>opt</sub></em> after <em>identifier</em>, which indicates, atleast to me, that an <em>identifier</em> is needed for the <em>typedef-name</em>. Strange that all tested compilers (silently) accept this.</p>\n<hr>\n<p><strong>Edit</strong>: After @Jonathan's answer, I found the following in the same standard as above:</p>\n<blockquote>\n<p id=\"so_6399898_6399931_2\"><em>decl-specifier</em>:</p>\n<ul>\n<li><em>storage-class-specifier</em></li>\n<li><em>type-specifier</em></li>\n<li><em>function-specifier</em></li>\n<li><code>friend</code></li>\n<li><code>typedef</code></li>\n</ul>\n</blockquote>\n<p>As can be seen, it provides an extra case for <code>typedef</code> and the list on <em>storage-class-specifiers</em> confirms this:</p>\n<blockquote>\n<p id=\"so_6399898_6399931_3\">storage-class-specifier:</p>\n<ul>\n<li><code>auto</code></li>\n<li><code>register</code></li>\n<li><code>static</code></li>\n<li><code>extern</code></li>\n<li><code>mutable</code></li>\n</ul>\n</blockquote>\n<p>So, we're just as clueless as before in the C++ case.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-06-19T01:36:08.997", "Id": "6399931", "Score": "3", "CreationDate": "2011-06-19T01:07:19.323", "LastActivityDate": "2011-06-19T01:36:08.997"}, "bq_ids": {"n4140": {"so_6399898_6399998_42": {"section_id": 5385, "quality": 0.8888888888888888, "length": 16}, "so_6399898_6399998_67": {"section_id": 5409, "quality": 0.9333333333333333, "length": 14}, "so_6399898_6399998_63": {"section_id": 5407, "quality": 0.84, "length": 21}, "so_6399898_6399998_69": {"section_id": 5416, "quality": 0.7777777777777778, "length": 7}, "so_6399898_6399931_1": {"section_id": 5407, "quality": 1.0, "length": 6}}, "n3337": {"so_6399898_6399998_42": {"section_id": 5179, "quality": 0.8888888888888888, "length": 16}, "so_6399898_6399998_67": {"section_id": 5204, "quality": 0.9333333333333333, "length": 14}, "so_6399898_6399998_63": {"section_id": 5202, "quality": 0.84, "length": 21}, "so_6399898_6399998_69": {"section_id": 5211, "quality": 0.7777777777777778, "length": 7}, "so_6399898_6399931_1": {"section_id": 5202, "quality": 1.0, "length": 6}}, "n4659": {"so_6399898_6399998_42": {"section_id": 6810, "quality": 0.8888888888888888, "length": 16}, "so_6399898_6399998_67": {"section_id": 6831, "quality": 0.9333333333333333, "length": 14}, "so_6399898_6399998_63": {"section_id": 6829, "quality": 0.64, "length": 16}, "so_6399898_6399998_69": {"section_id": 6838, "quality": 0.7777777777777778, "length": 7}, "so_6399898_6399931_1": {"section_id": 6829, "quality": 1.0, "length": 6}}}, "6399898": {"CommentCount": "9", "AcceptedAnswerId": "6399998", "PostTypeId": "1", "LastEditorUserId": "36565", "CreationDate": "2011-06-19T00:56:47.123", "LastActivityDate": "2011-06-19T10:38:26.720", "LastEditDate": "2011-06-19T01:30:07.960", "ViewCount": "20816", "FavoriteCount": "7", "Title": "Is the typedef-name optional in a typedef declaration?", "Id": "6399898", "Score": "30", "Body": "<p>I was quite surprised when I saw the following code compile without errors or warnings in g++-4.2:</p>\n<pre><code>typedef enum test { one };\n</code></pre>\n<p>My assumption was that if you used the <code>typedef</code> keyword it would require an extra identifier as in:</p>\n<pre><code>typedef enum test { one } test;\n</code></pre>\n<p>As already mentioned, g++-4.2 accepts it without even a warning. Clang++ 3.0 warns \"<em>warning: typedef requires a name</em>\", similarly Comeau warns \"<em>warning: declaration requires a typedef name</em>\", and g++-4.6 informs: \"<em>warning: 'typedef' was ignored in this declaration</em>\".</p>\n<p>I have not been able to identify where in the standard this is allowed, and I find it slightly confusing that two of the compilers warn that it is <em>required</em>, shouldn't it be an error if the typedef-name is <em>required</em> but not present?</p>\n<p><strong>UPDATE</strong>: I have checked in C with the same compilers. Clang and comeau yield the same output, gcc gives a warning: \"<em>warning: useless storage class specifier in empty declaration</em>\", which seems even more confusing.</p>\n<p><strong>UPDATE</strong>: I have checked removing the name of the enum and the results are the same:</p>\n<pre><code>typedef enum { one };\n</code></pre>\n<p>Similarly with a named struct:</p>\n<pre><code>typedef struct named { int x };\n</code></pre>\n<p>But not with an unnamed struct, in which case the code was rejected in g++ (4.2/4.6) with \"<em>error: missing type-name in typedef-declaration</em>\", gcc (4.2/4.6) gave a warning: \"<em>warning: unnamed struct/union that defines no instances</em>\", clang++ \"<em>warning: declaration does not declare anything</em>\", comeau \"<em>error: declaration requires a typedef name</em>\"</p>\n", "Tags": "<c++><c><typedef>", "OwnerUserId": "36565", "AnswerCount": "3"}});