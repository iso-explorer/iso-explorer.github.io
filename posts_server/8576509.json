post_cb({"8576509": {"CommentCount": "1", "ViewCount": "680", "PostTypeId": "1", "LastEditorUserId": "366904", "CreationDate": "2011-12-20T13:53:12.613", "LastActivityDate": "2013-08-06T14:40:52.313", "Title": "C++ exception definition", "AcceptedAnswerId": "8576705", "LastEditDate": "2011-12-20T14:11:26.957", "Id": "8576509", "Score": "0", "Body": "<p>Could anyone explain to me this definition of standard exception in C++:</p>\n<pre><code>virtual const char* what() const throw();\n</code></pre>\n<p>What does <code>const throw()</code> mean at the end?</p>\n", "Tags": "<c++><exception><exception-handling>", "OwnerUserId": "1094640", "AnswerCount": "3"}, "8576539": {"ParentId": "8576509", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>These are two separate, unrelated, things.</p>\n<p>The <code>const</code> means that the member function won't modify any (non-<code>mutable</code>) member variables; this in turn means that it can be called on <code>const</code> objects. e.g.:</p>\n<pre><code>class Foo {\npublic:\n    void a() const {\n        x = 5;  // Compiler error!\n    }\n\n    void b() {\n        x = 5;  // This is fine\n    }\n\nprivate:\n    int x;\n};\n\nint main() {\n    Foo       p;\n    const Foo q;\n\n    p.a();   // This is fine\n    p.b();   // This is fine\n    q.a();   // This is fine\n    q.b();   // Compiler error!\n}\n</code></pre>\n<p>The <code>throw()</code> is an <em>exception specifier</em>.  It declares that this function will not throw an exception.  See e.g. <a href=\"https://stackoverflow.com/questions/88573/should-i-use-an-exception-specifier-in-c\">Should I use an exception specifier in C++?</a> for a discussion.</p>\n", "OwnerUserId": "129570", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:08:28.820", "Id": "8576539", "Score": "9", "CreationDate": "2011-12-20T13:54:57.473", "LastActivityDate": "2011-12-20T14:03:35.600"}, "8576705": {"ParentId": "8576509", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>These are separate issues.</p>\n<hr>\n<h1>Regarding <code>const</code></h1>\n<p>From the standard (if too long, only read the <strong>bold</strong> parts):</p>\n<blockquote>\n<h3>Nonstatic member functions</h3>\n<p id=\"so_8576509_8576705_0\">[...] A non-static member function may be declared const, volatile, or const volatile. These cv-qualifiers\n  affect the type of the this pointer (9.3.2). They also affect the function type (8.3.5) of the member function;\n  <strong>a member function declared const is a const member function</strong>, a member function declared volatile is\n  a volatile member function and a member function declared const volatile is a const volatile member\n  function. [...]</p>\n<h3>The <code>this</code> pointer</h3>\n<p id=\"so_8576509_8576705_1\">[...] In a const member function, the object for which the function is called is accessed through a const access\n  path; therefore, <strong>a const member function shall not modify the object and its non-static data members.</strong> [...]</p>\n<h3>Storage class specifiers</h3>\n<p id=\"so_8576509_8576705_2\">[...] The mutable specifier on a class data member nullifies a const specifier applied to the containing class object\n  and permits modification of the mutable class member even though the rest of the object is const (7.1.6.1).</p>\n</blockquote>\n<p>Summary: A member function qualified with <code>const</code> is not allowed to change any member that is not declared <code>mutable</code>. The reason for <code>mutable</code> is that even if an object is <code>const</code>, mechanism like caching can be done; it is good practice that the observable behavior of an object does not change by calling const member function.</p>\n<hr>\n<h1>Regarding <code>throw()</code></h1>\n<blockquote>\n<h3>Exception specifications [expect.spec]</h3>\n<p id=\"so_8576509_8576705_3\">A function declaration lists exceptions that its function might directly or indirectly throw by using an\n  exception-specification as a suffix of its declarator.</p>\n</blockquote>\n<p>More specifically, it is a dynamic-exception-specification, and a</p>\n<blockquote>\n<p id=\"so_8576509_8576705_4\">[...] function is said to allow an exception of type E if its dynamic-exception-specification contains a type T for\n  which a handler of type T would be a match (15.3) for an exception of type E.</p>\n</blockquote>\n<p>In other words, the types within <code>(</code> and <code>)</code> are the exceptions that this function might throw. However, it is common practice to not use non-empty dynamic exception specifications <a href=\"https://stackoverflow.com/questions/88573/should-i-use-an-exception-specifier-in-c\">for some good reasons</a>.</p>\n<p>Using <code>throw()</code>, i.e. an empty exception list, in pre-C++11 was accepted practice to annotate functions that never throw. However, as of C++11, the current standard, one should use <code>noexcept</code> instead.</p>\n<p>Also, as of C++11,</p>\n<blockquote>\n<p id=\"so_8576509_8576705_5\">[ Note: The use of dynamic-exception-specifications is deprecated (see Annex D). \u2014end note ]</p>\n</blockquote>\n<p>so use <code>noexcept</code> instead.</p>\n</hr></hr>", "OwnerUserId": "76722", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:58.590", "Id": "8576705", "Score": "2", "CreationDate": "2011-12-20T14:07:00.820", "LastActivityDate": "2011-12-20T16:31:27.393"}, "bq_ids": {"n4140": {"so_8576509_8576705_5": {"section_id": 3380, "quality": 0.5555555555555556, "length": 5}, "so_8576509_8576705_2": {"section_id": 5400, "quality": 0.9166666666666666, "length": 22}, "so_8576509_8576705_3": {"section_id": 3363, "quality": 1.0, "length": 15}, "so_8576509_8576705_1": {"section_id": 5895, "quality": 0.6190476190476191, "length": 13}, "so_8576509_8576705_0": {"section_id": 5892, "quality": 0.8913043478260869, "length": 41}, "so_8576509_8576705_4": {"section_id": 3370, "quality": 0.875, "length": 14}}, "n3337": {"so_8576509_8576705_5": {"section_id": 3249, "quality": 0.5555555555555556, "length": 5}, "so_8576509_8576705_2": {"section_id": 5195, "quality": 0.9166666666666666, "length": 22}, "so_8576509_8576705_3": {"section_id": 3233, "quality": 1.0, "length": 15}, "so_8576509_8576705_1": {"section_id": 5667, "quality": 1.0, "length": 21}, "so_8576509_8576705_0": {"section_id": 5663, "quality": 0.8913043478260869, "length": 41}, "so_8576509_8576705_4": {"section_id": 3240, "quality": 0.875, "length": 14}}, "n4659": {"so_8576509_8576705_1": {"section_id": 7378, "quality": 0.6190476190476191, "length": 13}, "so_8576509_8576705_0": {"section_id": 7375, "quality": 0.8913043478260869, "length": 41}, "so_8576509_8576705_2": {"section_id": 6825, "quality": 0.9166666666666666, "length": 22}}}, "8576559": {"ParentId": "8576509", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>const</code> means that the function will not change any members of the class it is embedded in, <code>throw()</code> is an exception specification; the function promises not to throw an exception.</p>\n<p>Note that since C++11 the exception specification <code>throw</code> is deprecated because of several reasons: exception lists were too hard to maintain while <code>throw(...)</code> was to non-expressive, so that <code>throw()</code> was basically the only specification used anyway, and these specification were dynamically checked at runtime, producing a large overhead and thus slowing down your application.</p>\n<p>Now, you can safely replace <code>throw()</code> with <code>noexcept(true)</code>, or just <code>noexcept</code>. There will be no checks whether such a method actually throws an exception - it's a guarantee you give to the compiler, not vice versa. If an exception is thrown, <code>std::terminate</code> is called.</p>\n", "OwnerUserId": "1056003", "LastEditorUserId": "1056003", "LastEditDate": "2013-08-06T14:40:52.313", "Id": "8576559", "Score": "6", "CreationDate": "2011-12-20T13:56:28.980", "LastActivityDate": "2013-08-06T14:40:52.313"}});