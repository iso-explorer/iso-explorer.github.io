post_cb({"bq_ids": {"n4140": {"so_46202087_46202508_0": {"length": 9, "quality": 0.75, "section_id": 6345}}, "n3337": {"so_46202087_46202508_0": {"length": 9, "quality": 0.75, "section_id": 6102}}, "n4659": {"so_46202087_46202508_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7854}}}, "46202508": {"Id": "46202508", "PostTypeId": "2", "Body": "<h1>Summary</h1>\n<p>The problem is that you're calling <code>emplace_back</code> on the <code>deque</code> <em>from</em> a constructor being called by <code>emplace_back</code>. You are not allowed to modify a container while one of its methods is already in progress. This is prohibited by <a href=\"https://timsong-cpp.github.io/cppwp/reentrancy\" rel=\"nofollow noreferrer\">section [reentrancy] of the C++ standard</a> (thanks to @T.C.).</p>\n<blockquote>\n<p id=\"so_46202087_46202508_0\">Except where explicitly specified in this International Standard, it is implementation-defined which functions in the C++ standard library may be recursively reentered.</p>\n</blockquote>\n<p>To see why this sort of thing isn't allowed, here is a more obvious example. Imagine calling <code>std::vector::push_back()</code> from a copy constructor which is being invoked by <code>std::vector</code> during reallocation for another <code>push_back()</code> in progress. Reallocation works by allocating the new chunk of memory before freeing the old one, so you'd temporarily end up with three chunks, and at best the two new elements might end up in different \"new\" chunks.</p>\n<h1>Solution overview</h1>\n<p>Fundamentally, the problem is the combination of two things: </p>\n<ul>\n<li><code>std::deque&lt;Node&gt;::emplace_back()</code> is being called <em>by</em> <code>Node::Node(...)</code></li>\n<li><code>std::deque&lt;Node&gt;::emplace_back()</code> is making a call <em>to</em> <code>Node::Node(...)</code></li>\n</ul>\n<p>Combining these two problems, <code>std::deque::emplace_back()</code> ends up calling itself. The solution is therefore to fix one of these two things.</p>\n<h1>Specific solutions</h1>\n<ol>\n<li>Use a wrapper function, which I call <code>make()</code>. <code>make()</code> calls itself, and calls <code>emplace_back()</code> (which calls <code>Node::Node(...)</code>), but <code>Node::Node(...)</code> never calls <code>emplace_back()</code>.</li>\n<li>This is a variation on the idea of (1). It also uses a wrapper function, but it uses reference members (like the original question) so it has to construct the child nodes first.</li>\n<li>This fixes the other problem: <code>Node::Node(...)</code> is allowed to <code>emplace_back()</code>, but this time <code>emplace_back()</code> is not allowed to construct <code>Node</code> objects. The way I do this is that I use a deque of <em>pointers</em> to <code>Node</code> objects. However, as written this solution is not exception safe, and I consider it much uglier than the other solutions.</li>\n<li>This is essentially @AMA's ingenious idea: I again use a wrapper function, but this time the wrapper function is called <code>Node::Node(int, Pool&amp;)</code>! The point is, this calls itself and <code>emplace_back()</code>. But <code>emplace_back()</code> calls a <em>different</em> constructor, namely the copy constructor, which I write manually to avoid it copying references to temporaries, and which never calls back to <code>emplace_back()</code>.</li>\n<li>Bonus solution! Part of the complexity here is due to using <code>*this</code> as a sentinel value. Using pointers with <code>nullptr</code> is more conventional. This solution does this (so uses pointer members like solution 1), and creates the child nodes first (like solution 2), and as a bonus the creation is totally non-invasive.</li>\n</ol>\n<h2>Solution 1: Wrapper function and pointers</h2>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node;\nusing Pool = std::deque&lt;Node&gt;;\n\nstruct Node\n{\n    Node(int d)\n        : level{d}, l{this}, r{this}\n    {\n    }\n    static Node&amp; make(int d, Pool&amp; pool)\n    {\n        pool.emplace_back(d);\n        Node&amp; result = pool.back();\n        if (d &gt; 0) {\n            result.l = &amp;make(d - 1, pool);\n            result.r = &amp;make(d - 1, pool);\n        }\n        return result;\n    }\n\n    int level;\n    const Node* l;\n    const Node* r;\n\n    int check() const\n    {\n        if(l != this)\n            return l-&gt;check() + 1 + r-&gt;check();\n        else\n            return 1;\n    }\n};\n\nint main()\n{\n    int depth{2};\n    Pool pool;\n    Node&amp; c = Node::make(depth, pool);\n    return c.check()==7 ? 0 : 1;\n}\n</code></pre>\n<h2>Solution 2: Wrapper function with reference members</h2>\n<p>Note: this changes the order of elements in the <code>deque</code>: child elements are inserted first, so they are now earlier than their parents.</p>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node;\nusing Pool = std::deque&lt;Node&gt;;\n\nstruct Node\n{\n    static Node&amp; make(int d, Pool&amp; pool)\n    {\n        Node* l = nullptr;\n        Node* r = nullptr;\n        if (d &gt; 0) {\n            l = &amp;make(d - 1, pool);\n            r = &amp;make(d - 1, pool);\n        }\n        pool.emplace_back(d, l, r);\n        return pool.back();\n    }\n\n    Node(int d, Node* l_ptr, Node* r_ptr)\n        : level{d}\n        , l{l_ptr ? *l_ptr : *this}\n        , r{r_ptr ? *r_ptr : *this}\n    {\n    }\n\n    int level;\n    const Node&amp; l;\n    const Node&amp; r;\n\n    int check() const\n    {\n        if(!(&amp;l == this))\n            return l.check() + 1 + r.check();\n        else\n            return 1;\n    }\n};\n\nint main()\n{\n    int depth{2};\n    Pool pool;\n    Node&amp; c = Node::make(depth, pool);\n    return c.check()==7 ? 0 : 1;\n}\n</code></pre>\n<h2>Solution 3: pointers in the container</h2>\n<p>This uses references, and avoids an auxiliary function, and stores elements in the pool in the correct order. In its current form it is <em>NOT EXCEPTION SAFE</em> e.g. if the call to <code>new</code> for <code>r</code> throws an exception (e.g. <code>std::bad_alloc</code>) then <code>l</code> will not be freed. This would be tricky to sort out, and ultimately I think the other solutions would be neater.</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;memory&gt;\n\nstruct Node;\nusing Pool = std::deque&lt;std::unique_ptr&lt;const Node&gt;&gt;;\n\nstruct Node\n{\n    Node(int d, Pool&amp; pool)\n        : level{d}\n        , l{d &gt; 0 ? *new Node(d - 1, pool) : *this}\n        , r{d &gt; 0 ? *new Node(d - 1, pool) : *this}\n    {\n        if (&amp;l != this) {\n            pool.emplace_back(&amp;l);\n        }\n        if (&amp;r != this) {\n            pool.emplace_back(&amp;r);\n        }\n    }\n\n    int level;\n    const Node&amp; l;\n    const Node&amp; r;\n\n    int check() const\n    {\n        if(!(&amp;l == this))\n            return l.check() + 1 + r.check();\n        else\n            return 1;\n    }\n};\n\nint main()\n{\n    int depth{2};\n    Pool pool;\n    Node c(depth, pool);\n    return c.check()==7 ? 0 : 1;\n}\n</code></pre>\n<h2>Solution 4: Two constructors</h2>\n<p>This is arguably the simplest solution, but I would argue that it's not completely obvious that it doesn't keep any dangling references to temporary objects, unlike solution 1 and solution 2.</p>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node;\nusing Pool = std::deque&lt;Node&gt;;\n\nstruct Node\n{\n    Node(int d, Pool&amp; pool)\n        : level{d}\n        , l{d &gt; 0 ? pool.emplace_back(Node(d - 1, pool)) : *this}\n        , r{d &gt; 0 ? pool.emplace_back(Node(d - 1, pool)) : *this}\n    {\n    }\n\n    Node(const Node&amp; other)\n        : level{other.level}\n        , l{&amp;other.l == &amp;other ? *this : other.l}\n        , r{&amp;other.r == &amp;other ? *this : other.r}\n    {\n    }\n\n    int level;\n    const Node&amp; l;\n    const Node&amp; r;\n\n    int check() const\n    {\n        if(!(&amp;l == this))\n            return l.check() + 1 + r.check();\n        else\n            return 1;\n    }\n};\n</code></pre>\n<h2>Bonus solution: Pointers, wrapper function and nullptr</h2>\n<p>The simplest solution is if you're prepared to use pointers, construct child nodes first, and use <code>nullptr</code> instead of <code>this</code> as a sentinel value. Note that <code>Node</code> is now cleanly separated from <code>Pool</code> and <code>make()</code>.</p>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node {\n    int level;\n    const Node* const l;\n    const Node* const r;\n\n    Node(int level, const Node* l, const Node* r):\n        level(level), l(l), r(r)\n    {\n    }\n\n    int check() const\n    {\n        if(l)\n            return l-&gt;check() + 1 + r-&gt;check();\n        else\n            return 1;\n    }\n};\n\nusing Pool = std::deque&lt;Node&gt;;\n\nNode* make(int d, Pool&amp; pool)\n{\n    Node* l = d &gt; 0 ? make(d - 1, pool) : nullptr;\n    Node* r = d &gt; 0 ? make(d - 1, pool) : nullptr;\n    return &amp;pool.emplace_back(d, l, r);\n}\n</code></pre>\n<h1>Diagram of solutions</h1>\n<p><a href=\"https://i.stack.imgur.com/IyTuc.png\" rel=\"nofollow noreferrer\"><img alt=\"Diagram showing calling patterns in solutions\" src=\"https://i.stack.imgur.com/IyTuc.png\"/></a></p>\n", "LastEditorUserId": "7008416", "LastActivityDate": "2017-09-14T08:43:34.923", "Score": "14", "CreationDate": "2017-09-13T16:24:10.003", "ParentId": "46202087", "CommentCount": "17", "OwnerUserId": "7008416", "LastEditDate": "2017-09-14T08:43:34.923"}, "46202087": {"ViewCount": "255", "Body": "<p>The <a href=\"http://coliru.stacked-crooked.com/a/6d02e382baf2f26d\" rel=\"noreferrer\">following program</a> attempts to create a tree of nodes consisting of references to <code>std::deque</code> elements.</p>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node;\nusing Pool = std::deque&lt;Node&gt;;\n\nstruct Node\n{\n    Node(int d, Pool&amp; pool)\n        : level{d}\n        , l{d &gt; 0 ? pool.emplace_back(d - 1, pool) : *this}\n        , r{d &gt; 0 ? pool.emplace_back(d - 1, pool) : *this}\n    {\n    }\n\n    int level;\n    const Node&amp; l;\n    const Node&amp; r;\n\n    int check() const\n    {\n        if(!(&amp;l == this))\n            return l.check() + 1 + r.check();\n        else\n            return 1;\n    }\n};\n\nint main()\n{\n    int depth{2};\n    Pool pool;\n    Node c(depth, pool);\n    return c.check()==7 ? 0 : 1;\n}\n</code></pre>\n<p>It creates the correct number of elements, but not all references are initialized to the emplaced elements and the <code>level</code> variable is not set for levels higher than <code>0</code>.</p>\n<p>Finally, program fails due to <code>this</code> being a <code>nullptr</code> when the <code>check()</code> function is executed.</p>\n<p>How can the references be correctly initialized?</p>\n", "AcceptedAnswerId": "46202508", "Title": "Tree elements initialized with references to emplaced deque members results in nullptr for this", "CreationDate": "2017-09-13T15:59:28.237", "Id": "46202087", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-09-14T18:47:28.527", "Score": "6", "OwnerUserId": "1460794", "Tags": "<c++><c++1z>", "AnswerCount": "2"}, "46226296": {"Id": "46226296", "PostTypeId": "2", "Body": "<p>A solution inspired from solutions 2 and 4 from Arthur Tacca answer (if you like it, give a +1 to Arthur; if you don't like it: it's my fault).</p>\n<p>This solution use a second constructor (as solution 4) but call it directly (as delegating constructor) an a static method (inspired by solution 2) used to create the childs of the new node.</p>\n<p>Remain unaltered the main point from Arthur: it's necessary to avoid a <code>emplace_back()</code> that call itself and insert the child nodes before the father.</p>\n<p>Works also with c++11</p>\n<pre><code>#include &lt;deque&gt;\n\nstruct Node;\n\nusing Pool = std::deque&lt;Node&gt;;\n\nstruct Node\n {\n   Node (int d, Pool &amp; pool, Node const * pl, Node const * pr)\n      : level { d }, l { pl ? *pl : *this }, r { pr ? *pr : *this }\n    { }\n\n   static Node const * getChild (int d, Pool &amp; pool)\n    {\n      Node const * ret { nullptr };\n\n      if ( d-- &gt; 0 )\n       {\n         pool.emplace_back(d, pool, getChild(d, pool), getChild(d, pool));\n\n         ret = &amp; pool.back();\n       }\n\n      return ret;\n    }\n\n   Node (int d, Pool&amp; pool)\n      : Node { d, pool, getChild(d, pool), getChild(d, pool) }\n    { }\n\n   int level;\n\n   Node const &amp; l;\n   Node const &amp; r;\n\n   int check() const\n    { return (!(&amp;l == this)) ? l.check() + 1 + r.check() : 1 ; }\n };\n\nint main ()\n {\n   int depth{2};\n   Pool pool;\n   Node c(depth, pool);\n\n   return c.check()==7 ? 0 : 1;\n }\n</code></pre>\n", "LastActivityDate": "2017-09-14T18:47:28.527", "CommentCount": "0", "CreationDate": "2017-09-14T18:47:28.527", "ParentId": "46202087", "Score": "2", "OwnerUserId": "6022656"}});