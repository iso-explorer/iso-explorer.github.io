post_cb({"24965255": {"CommentCount": "13", "AcceptedAnswerId": "24965318", "PostTypeId": "1", "LastEditorUserId": "583570", "CreationDate": "2014-07-25T22:10:34.450", "LastActivityDate": "2014-07-25T22:46:53.963", "LastEditDate": "2014-07-25T22:46:53.963", "ViewCount": "128", "FavoriteCount": "0", "Title": "Implementation of ++ operator in c++", "Id": "24965255", "Score": "-2", "Body": "<p>How is the standard ++ operator defined in c++?(c++ 11)</p>\n<p>For eg.</p>\n<pre><code>int k, i=3;\nk = i++;\n</code></pre>\n<p>first assigns value of i equal to 3 then increments i.</p>\n<p>Can somebody please explain how this is implemented?</p>\n<p>Also, is a copy made of the variable?</p>\n", "Tags": "<c++><operators>", "OwnerUserId": "2370728", "AnswerCount": "4"}, "24965289": {"ParentId": "24965255", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-07-25T22:14:46.200", "Score": "3", "LastEditorUserId": "1576556", "LastEditDate": "2014-07-25T22:21:07.413", "Id": "24965289", "OwnerUserId": "1576556", "Body": "<p>When you make a overload for your class, you code it like this:</p>\n<pre><code>T&amp; T::operator++() // pre-increment, return *this by reference\n{\n  // increment something, somehow\n  // maybe there is local int i and you will type 'i = i + 1;' or '++i;'\n  // so whatever 'increment by one' means in your case.\n\n  // for type 'int', this function would result in (an instruction | a series of instructions)\n  // that increment the variable by one.\n  return *this;\n}\n\nT T::operator++(int) // post-increment\n{\n  T copy(*this);\n  ++(*this);// pre-increment here seems logical\n  return copy;\n}\n</code></pre>\n<p>As you can see, a temporary is created and returned after the actual data is incremented. So the returned value is the old value while incrementing the actual value.</p>\n<p>For built-in types, it works with the same logic. How to do it is up to the people who implement the operations and can vary. But it works the same way.</p>\n", "LastActivityDate": "2014-07-25T22:21:07.413"}, "24965319": {"ParentId": "24965255", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-07-25T22:17:01.573", "Score": "2", "LastEditorUserId": "3111536", "LastEditDate": "2014-07-25T22:23:48.440", "Id": "24965319", "OwnerUserId": "3111536", "Body": "<p>the post fix ++, as in <code>i++</code>, is like this (in case of int):</p>\n<pre><code>int operator++(int i)\n{\n    int temp = i;\n    i = i + 1;\n    return temp;\n}\n</code></pre>\n<p>the prefix ++, as in <code>++i</code> is like this (again for int):</p>\n<pre><code>int operator++()\n{\n    return i + 1;\n}\n</code></pre>\n<p>You see why prefix ++ and -- are considered more efficient?</p>\n", "LastActivityDate": "2014-07-25T22:23:48.440"}, "24965300": {"ParentId": "24965255", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-07-25T22:15:36.253", "Score": "1", "LastEditorUserId": "3471062", "LastEditDate": "2014-07-25T22:25:10.127", "Id": "24965300", "OwnerUserId": "3471062", "Body": "<p>You have pre and post increment in C/C++ language. The value in pre-increment is returned before incrementing, post-increment returned the already incremented value.</p>\n<p>Here is a excerpt from Wikipedia:</p>\n<pre><code>int  x;\nint  y;\n\n// Increment operators\nx = 1;\ny = ++x;    // x is now 2, y is also 2\ny = x++;    // x is now 3, y is 2\n\n// Decrement operators\nx = 3;\ny = x--;    // x is now 2, y is 3\ny = --x;    // x is now 1, y is also 1\n</code></pre>\n<p>More info on <a href=\"http://en.wikipedia.org/wiki/Increment_and_decrement_operators\" rel=\"nofollow\">Increment and decrement operators</a></p>\n<p>GCC Internals explains this:</p>\n<blockquote>\n<p id=\"so_24965255_24965300_0\">The value of the single operand is computed, and the operand incremented or decremented. In the case of PREDECREMENT_EXPR and PREINCREMENT_EXPR, the value of the expression is the value resulting after the increment or decrement; in the case of POSTDECREMENT_EXPR and POSTINCREMENT_EXPR is the value before the increment or decrement occurs. The type of the operand, like that of the result, will be either integral, boolean, or floating-point. </p>\n</blockquote>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gccint/Unary-and-Binary-Expressions.html#Unary-and-Binary-Expressions\" rel=\"nofollow\">Unary and Binary Expressions - GNU Compiler Collection (GCC) Internals</a></p>\n", "LastActivityDate": "2014-07-25T22:25:10.127"}, "24965318": {"ParentId": "24965255", "CommentCount": "2", "CreationDate": "2014-07-25T22:17:01.280", "OwnerUserId": "3510483", "PostTypeId": "2", "Id": "24965318", "Score": "6", "Body": "<p>The standard only defines what <strong>it does</strong>, <strong>not how it should be implemented.</strong></p>\n<p>As for the quote, you will find it in the C++ standard, section \u00a7 5.2.6 [ Increment and decrement] :</p>\n<blockquote>\n<p id=\"so_24965255_24965318_0\">The value of a postfix\n  ++ expression is the value of its operand. [ Note: the value obtained is a copy of the original value \u2014end note ] The operand shall be a\n  modifiable lvalue. The type of the operand shall be an arithmetic type\n  or a pointer to a complete object type. The value of the operand\n  object is modified by adding 1 to it, unless the object is of type\n  bool , in which case it is set to true . [ Note: this use is\n  deprecated, see Annex D . \u2014end note ] The value computation of the\n  ++ expression is sequenced before the modification of the operand object. With respect to an indeterminately-sequenced function call,\n  the operation of postfix\n  ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side\n  effect associated with any single postfix ++ operator. \u2014end note ] The\n  result is a prvalue. The type of the result is the cv-unqualified\n  version of the type of the operand.</p>\n</blockquote>\n", "LastActivityDate": "2014-07-25T22:17:01.280"}, "bq_ids": {"n4140": {"so_24965255_24965318_0": {"section_id": 6009, "quality": 0.8131868131868132, "length": 74}}, "n3337": {"so_24965255_24965318_0": {"section_id": 5777, "quality": 0.8131868131868132, "length": 74}}, "n4659": {"so_24965255_24965318_0": {"section_id": 7508, "quality": 0.7032967032967034, "length": 64}}}});