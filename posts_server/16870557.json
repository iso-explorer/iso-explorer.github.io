post_cb({"bq_ids": {"n4140": {"so_16870557_16870897_0": {"length": 9, "quality": 0.75, "section_id": 739}}, "n3337": {"so_16870557_16870897_0": {"length": 9, "quality": 0.75, "section_id": 728}}, "n4659": {"so_16870557_16870897_0": {"length": 9, "quality": 0.75, "section_id": 797}}}, "16870557": {"ViewCount": "77", "Body": "<p>I know this is problematic, but I am curious whether doing this causes undefined behavior?</p>\n<pre><code>class A\n{\npublic:\n    int i;\n};\nclass As {\npublic:\n    bool operator()(const A* l, const A* r)\n    {\n        return l-&gt;i &lt; r-&gt;i;\n    }\n};\nint main() {\n    std::set&lt;A*,As&gt; s;\n    A* a1 = new A();\n    a1-&gt;i = 9;\n    A* a2 = new A();\n    a2-&gt;i = 2;\n    s.insert(a1);\n    s.insert(a2);\n    for(std::set&lt;A*,As&gt;::iterator i = s.begin(); i != s.end(); ++i)\n        std::cout&lt;&lt;(*i)-&gt;i&lt;&lt;std::endl;\n    for(std::set&lt;A*,As&gt;::iterator i = s.begin(); i != s.end(); ++i)\n    {\n        if((*i)-&gt;i == 2)\n            (*i)-&gt;i = 22;\n    }\n    for(std::set&lt;A*,As&gt;::iterator i = s.begin(); i != s.end(); ++i)\n        std::cout&lt;&lt;(*i)-&gt;i&lt;&lt;std::endl;\n    //now s is in incorrect state, insert all elements into a tmp one\n    std::set&lt;A*,As&gt; t;\n    for(std::set&lt;A*,As&gt;::iterator i = s.begin(); i != s.end(); ++i)\n        t.insert(*i);\n    s.swap(t);\n    for(std::set&lt;A*,As&gt;::iterator i = s.begin(); i != s.end(); ++i)\n        std::cout&lt;&lt;(*i)-&gt;i&lt;&lt;std::endl;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>2\n9\n22\n9\n9\n22\n</code></pre>\n<p>It seems to work fine when compiled by GCC 4.7, but I don't know whether this may just be luck.</p>\n", "AcceptedAnswerId": "16870897", "Title": "Modify sort-relevant parts of an element in a C++ std::set", "CreationDate": "2013-06-01T08:06:36.947", "Id": "16870557", "CommentCount": "3", "LastEditDate": "2013-06-01T09:36:08.087", "PostTypeId": "1", "LastEditorUserId": "777186", "LastActivityDate": "2013-06-01T09:36:08.087", "Score": "1", "OwnerUserId": "851185", "Tags": "<c++><set><std>", "AnswerCount": "1"}, "16870897": {"Id": "16870897", "PostTypeId": "2", "Body": "<p>The Standard (C++11) says about the key comparison function used in associative containers, i.e. containers like <code>std::set</code>:</p>\n<blockquote>\n<p id=\"so_16870557_16870897_0\">(\u00a723.2.4/3) [...] For any two keys <code>k1</code> and <code>k2</code> in the same container, calling <code>comp(k1,k2)</code> shall always return the same value.</p>\n</blockquote>\n<p>There <code>comp</code> refers to the comparison function, which in your case is the functor <code>As()</code>.</p>\n<p>Clearly, when the keys contain pointers to external objects and the result of calling <code>comp(k1,k2)</code> depends on those external objects, then modifying the objects causes the rule above to be violated.</p>\n<p>The Standard doesn't say what happens if you violate this rule. So, formally speaking, you have undefined behaviour then (because the Standard leaves the behaviour undefined).</p>\n<p>In practice, I guess there is a significant chance that terrible things, including segmentation faults, could happen as a result of a violation, because the next time the set is searched for a key, or an insert is made, the search algorithm \u2013 built on the assumption that the keys are in order \u2013 might go astray and make out-of-bounds accesses and the like.</p>\n<p>So the conclusion is that, yes, this is UB, and can cause bad things to happen even if it works in a few selected cases in practice.</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2013-06-01T09:34:04.810", "Score": "3", "CreationDate": "2013-06-01T08:50:00.640", "ParentId": "16870557", "CommentCount": "0", "OwnerUserId": "777186", "LastEditDate": "2013-06-01T09:34:04.810"}});