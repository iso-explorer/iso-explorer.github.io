post_cb({"bq_ids": {"n4140": {"so_38874050_38874356_3": {"length": 18, "quality": 0.6666666666666666, "section_id": 1617}}, "n3337": {"so_38874050_38874356_3": {"length": 18, "quality": 0.6666666666666666, "section_id": 1613}}, "n4659": {"so_38874050_38874356_3": {"length": 18, "quality": 0.6666666666666666, "section_id": 1770}}}, "38874356": {"Id": "38874356", "PostTypeId": "2", "Body": "<p>According to standard, yes. Underlying char container is accessible using <code>string::data</code> or <code>string::c_str</code> on which standard says:</p>\n<blockquote>\n<p id=\"so_38874050_38874356_0\">21.4.7.1 <code>basic_string</code> accessors <a href=\"http://eel.is/c++draft/string.accessors#1\" rel=\"nofollow\"><strong>[string.accessors]</strong></a><br>\n<code>const charT* c_str() const noexcept;</code><br>\n<code>const charT* data() const noexcept;</code></br></br></p>\n<p id=\"so_38874050_38874356_1\">1 <em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.<br>\n  2 <em>Complexity:</em> Constant time.<br>\n  3 <em>Requires:</em> The program shall not alter any of the values stored in the character array.</br></br></p>\n</blockquote>\n<p>And to prove, that it's null-terminated, look at definition of <code>operator[]</code> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_38874050_38874356_2\">21.4.5 <code>basic_string</code> element access <a href=\"http://eel.is/c++draft/string.access#2\" rel=\"nofollow\"><strong>[string.access]</strong></a><br>\n<code>const_reference operator[](size_type pos) const;</code><br>\n<code>reference operator[](size_type pos);</code></br></br></p>\n<p id=\"so_38874050_38874356_3\">1 <em>Requires:</em> <code>pos &lt;= size().</code><br>\n  2 <em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. <strong>Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where modifying the object leads to undefined behavior.</strong><br>\n  3 <em>Throws</em>: Nothing.<br>\n  4 <em>Complexity</em>: Constant time.</br></br></br></p>\n</blockquote>\n<p>thus <code>operator[size()]</code> returns <code>charT()</code> and since <code>std::string</code> is <code>std::basic_string&lt;char&gt;</code>, <code>charT()</code> is <code>'\\0'</code>.</p>\n<p>That means, in your case, <code>*(&amp;str[0] + str.size()) == '\\0'</code> shall be, according to standard, always <code>true</code>.</p>\n<hr>\n<p>Beware, that modifying <code>operator[size()]</code> is UB.</p>\n</hr>", "LastEditorUserId": "3087601", "LastActivityDate": "2016-08-10T20:40:14.753", "Score": "5", "CreationDate": "2016-08-10T13:07:22.247", "ParentId": "38874050", "CommentCount": "13", "OwnerUserId": "3087601", "LastEditDate": "2016-08-10T20:40:14.753"}, "38874806": {"Id": "38874806", "PostTypeId": "2", "Body": "<p>In practice, yes.  There are exactly zero implementations of <code>std::string</code> that are standards-comforming that do not store a NUL character at the end of the buffer.</p>\n<p>So if you aren't wondering for wondering sake,  you are done.</p>\n<p>However, if you are wondering about the standard being abtruse:</p>\n<hr>\n<p>In C++14, yes.  There is a clear requirement that <code>[]</code> return a contiguous set of elements, and <code>[size()]</code> must return a NUL character, and const methods may not modify state.  So <code>*((&amp;str[0])+size())</code> must be the same as <code>str[size()]</code>, and <code>str[size()]</code> must be a NUL, thus game over.</p>\n<hr>\n<p>In C++11, almost certainly.  There are rules that <code>const</code> methods may not modify state.  There are guarantees that <code>data()</code> and <code>c_str()</code> return a null-terminated buffer that agrees with <code>[]</code> at each point.</p>\n<p>A convoluted reading of C++11 standard would state that prior to any call of <code>data()</code> or <code>c_str()</code>, <code>[size()]</code> doesn't return the NUL terminator at the end of the buffer but rather a <code>static const CharT</code> that is stored separately, and the buffer has an unitialized (or even a trap value) where NUL should be.  Due to the requirement that <code>const</code> methods not modify state I believe this reading is incorrect.</p>\n<p>This requires <code>&amp;str[str.size()]</code> change between calls to <code>.data()</code>, which is an observable change in state in <code>string</code> over a <code>const</code> call, which I would read as being illegal.</p>\n<p>An alternative way to get around the standard might be to not initialize <code>str[str.size()]</code> until you legally access it via calling <code>.data()</code>, <code>.c_str()</code> or actually passing <code>str.size()</code> to <code>operator[]</code>.  As there are no defined ways to access that element other than those 3 in the standard, you could stretch things and say lazy initialization of the NUL is legal.</p>\n<p>I'd question this, as the definition of <code>.data()</code> implies that the return value of <code>[]</code> is contiguous, so <code>&amp;[0]</code> is the same address as <code>.data()</code>, and <code>.data()+.size()</code> is guaranteed to point to a NUL <code>CharT</code> so must <code>(&amp;[0])+.size()</code>, and with no non-<code>const</code> methods called the state of the <code>std::string</code> may not change between the calls.</p>\n<p>But, what if the fact the compiler can look and see you'll never call <code>.data()</code> or <code>.c_str()</code>, does the requirement of contiguity hold if it can be proven you never call them?</p>\n<p>At which point I'd throw my hands up and shoot the hostile compiler.</p>\n<hr>\n<p>The standard is very passively voiced about this.  So there may be a way to make an arguably standards conforming <code>std::string</code> that doesn't follow these rules.  And because the guarantees get closer and closer to explicitly requiring that NUL terminator there, the odds against a new compiler showing up that uses a tortured reading of C++ to claim this is standards compliant is low.</p>\n</hr></hr></hr>", "LastActivityDate": "2016-08-10T13:27:21.653", "CommentCount": "4", "CreationDate": "2016-08-10T13:27:21.653", "ParentId": "38874050", "Score": "7", "OwnerUserId": "1774667"}, "38874050": {"ViewCount": "275", "Body": "<p>I have an object of the <code>std::string</code> class that I need to pass to C function that operates the <code>char*</code> buffer by iterating over it and searching for the null terminated symbol.</p>\n<p>So, I have something like this:</p>\n<pre><code>// C function\nvoid foo(char* buf);\n\n// C++ code\nstd::string str(\"str\");\nfoo(&amp;str[0]);\n</code></pre>\n<p>Suppose that we use C++11, so we have a guarantee that <code>std::string</code> representation will have contiguously stored characters.</p>\n<p>But I wonder is there any guarantee that <code>&amp;str[0]</code> will point to the buffer that ends with <code>\\0</code>? Yeah, there's <code>c_str</code> member function but I'm talking about <code>operator[]</code>.</p>\n<p>Can somebody quote the standard please?</p>\n", "AcceptedAnswerId": "38874806", "Title": "Will C++11 std::string::operator[] return null-terminated buffer", "CreationDate": "2016-08-10T12:54:40.653", "Id": "38874050", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-08-10T20:40:14.753", "Score": "4", "OwnerUserId": "1608835", "Tags": "<c++><c++11>", "AnswerCount": "2"}});