post_cb({"bq_ids": {"n4140": {"so_3699009_3699009_0": {"length": 20, "quality": 1.0, "section_id": 6299}}, "n3337": {"so_3699009_3699009_0": {"length": 20, "quality": 1.0, "section_id": 6056}}, "n4659": {"so_3699009_3699009_0": {"length": 20, "quality": 1.0, "section_id": 7808}}}, "3699009": {"ViewCount": "798", "Body": "<p><a href=\"https://stackoverflow.com/questions/3696286/can-one-access-the-template-parameter-outside-of-a-template-without-a-typedef/3696307#3696307\">This question</a> got me thinking. Sometimes it's useful to grab an actual argument from a class template specialization, if it fails to define a public <code>typedef</code> of the argument. In C++03 it's a sign of either bad template design, or contrary design intent, and not particularly common. But variadic templates make typedef coverage impossible, so it would be nice to have a tool around to solve the problem without additional work.</p>\n<p>C++0x solves the <code>typedef</code> problem for one particular variadic template, <code>tuple</code>.</p>\n<pre><code>tuple_element&lt; 2, tuple&lt; char, short, int &gt; &gt;::type my_int; // nth element type\n</code></pre>\n<p>But <code>tuple_element</code> isn't married to <code>tuple</code>; it also works with <code>pair</code> and <code>array</code>. Its declaration doesn't mention <code>tuple</code>.</p>\n<pre><code>template&lt; size_t index, typename something_like_a_tuple &gt;\nstruct tuple_element; // general case is left incomplete, unimplemented\n</code></pre>\n<p><code>tuple</code> is related by a partial specialization:</p>\n<pre><code>template&lt; size_t index, typename ... tuple_elements &gt;\nstruct tuple_element&lt; index, tuple&lt; tuple_elements ... &gt; &gt; { // impl. in here\n</code></pre>\n<p>But it doesn't need to be. A template template parameter could match <code>tuple</code>, along any other template parameterized only over types.</p>\n<pre><code>template&lt; size_t index,\n    template&lt; typename ... &gt; class template_over_types,\n    typename ... types &gt;\nstruct tuple_element&lt; index, template_over_types&lt; types ... &gt; &gt; {\n</code></pre>\n<p>This would allow</p>\n<pre><code>tuple_element&lt; 1, almost_any_template&lt; char, int &gt; &gt;::type my_int;\ntuple_element&lt; 0, pair&lt; int, char &gt; &gt;::type another_int; // same specialization\n</code></pre>\n<p>and yet allow the additional specialization for <code>array</code></p>\n<pre><code>template&lt; size_t index, typename element, size_t extent &gt;\nstruct tuple_element&lt; index, array&lt; element, extent &gt; &gt; \n    { typedef element type; }\n</code></pre>\n<p>No conflict is possible because <code>array</code>'s second argument is a <code>size_t</code>, not a type.</p>\n<hr>\n<p>Unfortunately, the user is allowed to specialize the <code>tuple_element</code> interface for their own types. The user's precondition and their guarantee is given by C++0x \u00a717.6.3.2.1/1:</p>\n<blockquote>\n<p id=\"so_3699009_3699009_0\">A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>So, not only must the general specialization not conflict with the <code>array</code> specialization, it can't conflict with <em>any</em> specialization that names a user-defined type. That is, if the user declares a specialization, the existence of the general argument getter cannot affect whether it's chosen.</p>\n<p>When ambiguity arises in instantiation (that is, two partial specializations match an argument list), the alternatives are compared to determine which is most specialized, in other words least generalized. Call the alternatives A and B. This means that, if A can do B's job, but B cannot do A's job, then B is more specialized. A is the generalist. B will be chosen. The actual arguments instigating the instantiation aren't considered, since they are already known to be a match to both candidates.</p>\n<p>Since we want the general template to defer to everything else, we're in good shape.</p>\n<p>Generality is checked by replacing the partial specialization parameters in A with unique dummy types, and checking whether B can also implement such a specialization. Repeat with the roles reversed, and if the opposite result is obtained, one candidate is known to be more specialized.</p>\n<p>The existence of a user-defined type in the user's specialization guarantees its precedence, because there must be a corresponding unique dummy type in the argument-getter which won't match it.</p>\n<p>For example, here is a very general user-declared specialization. It defines <code>tuple_element</code> for any type-parameterized template containing a given <code>user_type</code>.</p>\n<pre><code> template&lt; size_t I,\n           template&lt; typename ... &gt; class any_template,\n           typename ... T, typename ... U &gt;\n struct tuple_element&lt; I, any_template&lt; T ..., ::user_type, U ... &gt; &gt;;\n</code></pre>\n<p>The sequence <code>..., user_type, ...</code> can be handled by the general case, but the user's case cannot handle a sequence composed entirely of artificial unique types, because it won't include <code>user_type</code>.</p>\n<p>If any user specialization is a candidate, it will be the superior one.</p>\n<p><sub>(The standard does specify in pseudocode a separate partial specialization for <code>tuple</code>, but it could be omitted under the as-if rule. Anyway, if implemented, it would be covered by the same precedence rule as protects the user.)</sub></p>\n<hr>\n<p>I haven't made many forays into the partial ordering rules. Is this analysis correct? Is it OK for the implementation to expose a general template indexer through <code>std::tuple_element</code>?</p>\n</hr></hr>", "AcceptedAnswerId": "3700102", "Title": "May std::tuple_element double as a universal template argument retriever?", "CreationDate": "2010-09-13T09:03:24.017", "Id": "3699009", "CommentCount": "2", "LastEditDate": "2017-05-23T12:26:47.817", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-02T10:46:41.523", "Score": "3", "OwnerUserId": "153285", "Tags": "<c++><templates><c++11><standard-library><partial-specialization>", "AnswerCount": "1"}, "3700102": {"Id": "3700102", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3699009_3700102_0\">So, not only must the general specialization not conflict with the array specialization, it can't conflict with any  specialization that names a user-defined type. That is, if the user declares a specialization, the existence of the general argument getter cannot affect whether it's chosen.</p>\n</blockquote>\n<p>I don't understand this. What do you mean?</p>\n<hr>\n<blockquote>\n<p id=\"so_3699009_3700102_1\">Is it OK for the implementation to expose a general template indexer through std::tuple_element?</p>\n</blockquote>\n<p>It's impossible to do so for the general case. Imagine this one</p>\n<pre><code>template&lt;int A, char B, long C, class D, int &amp;X, int(*Handler)()&gt;\nstruct funny_template { };\n\nint x, y();\nstd::tuple_element&lt;3, funny_template&lt;1, 2, 3, long, x, y&gt; &gt;::type along = 0;\n</code></pre>\n<p>Happy macro meta-programming :)</p>\n<hr>\n<blockquote>\n<p id=\"so_3699009_3700102_2\">I haven't made many forays into the partial ordering rules. Is this analysis correct?</p>\n</blockquote>\n<p>Partial ordering for two partial specializations</p>\n<pre><code>template&lt;class A1, ..., class AN&gt;\nclass T&lt;Am1, ..., AmM&gt;;\n\ntemplate&lt;class B1, ..., class BL&gt;\nclass T&lt;Bm1, ..., BmM&gt;;\n</code></pre>\n<p>Works like transforming them to function templates and ordering <em>them</em></p>\n<pre><code>template&lt;class A1, ..., class AN&gt;\nvoid f(T1&lt;Am1, ..., AmM&gt;);\n\ntemplate&lt;class B1, ..., class BL&gt;\nvoid f(T2&lt;Bm1, ..., BmM&gt;);\n</code></pre>\n<p>Partial ordering like your analysis says correctly puts unique types for each template parameter transforming it to an argument for argument deduction, comparing it to the other template</p>\n<pre><code>T1A&lt;Uam1, ..., UAmM&gt; -&gt; T2&lt;Bm1, ..., BmM&gt;\nT2A&lt;UBm1, ..., UBmM&gt; -&gt; T1&lt;Am1, ..., AmM&gt;\n</code></pre>\n<p>If there is a non-deduced context it's not compared like usual. Like if <code>BmM</code> is <code>typename Foo::X</code>, the first deduction above would consider deduction of the last sub-type as success because there can't be a mismatch for a nondeduced context. The other way around though, <code>Foo::X</code> against <code>AmM</code> <em>can</em> mismatch though if <code>AmM</code> is not a nondeduced context itself. </p>\n<p>If deduction succeeds for one round and not the other way around (... leaving off some other rules because they only happen for real function template ordering), the template on the right side above for the round that failed deduction is more specialized. Otherwise, the partial specializations are unordered. </p>\n</hr></hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-09-13T12:04:38.793", "Score": "1", "CreationDate": "2010-09-13T11:50:22.150", "ParentId": "3699009", "CommentCount": "3", "OwnerUserId": "34509", "LastEditDate": "2010-09-13T12:04:38.793"}});