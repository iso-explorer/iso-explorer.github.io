post_cb({"32523222": {"ParentId": "32522701", "CommentCount": "0", "Body": "<p>I believe this is a gcc bug. The code compiles on clang. </p>\n<p>First, both candidates are viable. From [conv]:</p>\n<blockquote>\n<p id=\"so_32522701_32523222_0\">A <em>standard conversion sequence</em> is a sequence of standard conversions in the following order:<br>\n  \u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, <strong>array-to-pointer conversion</strong>,\n  and function-to-pointer conversion.<br>\n  \u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral\n  conversions, floating point conversions, floating-integral conversions, <strong>pointer conversions</strong>, pointer to\n  member conversions, and boolean conversions.</br></br></p>\n</blockquote>\n<p>Both calls to <code>foo</code> would involve an array-to-pointer conversion (from <code>C[10]</code> to <code>C*</code>) and then a pointer conversion (from <code>C*</code> to either <code>A*</code> or <code>B*</code>). That is an allowable standard conversion. </p>\n<p>Now, how do we rank those conversions? Amusingly, the line from the standard matches <strong>exactly</strong> our use-case, in [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_32522701_32523222_1\">Two conversion sequences with the same rank\n  are indistinguishable unless one of the following rules applies:<br>\n  \u2014 If class B is derived directly or indirectly from class A and class C is derived directly or indirectly from\n  B,<br>\n  \u00a0\u00a0\u00a0\u2014 <strong>conversion of C* to B* is better than conversion of C* to A*</strong></br></br></p>\n</blockquote>\n<p>We have two conversions sequences of the same rank (Conversion), that are both viable, but one is considered better than the other. The code should unambiguously prefer <code>foo(B* )</code> over <code>foo(A* )</code>. The fact that <code>c</code> is declared an array should not make it ambiguous. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32523222", "Score": "5", "CreationDate": "2015-09-11T12:10:28.967", "LastActivityDate": "2015-09-11T12:10:28.967"}, "bq_ids": {"n4140": {"so_32522701_32523222_0": {"section_id": 0, "quality": 1.0, "length": 41}, "so_32522701_32523222_1": {"section_id": 640, "quality": 1.0, "length": 23}}, "n3337": {"so_32522701_32523222_0": {"section_id": 0, "quality": 1.0, "length": 41}, "so_32522701_32523222_1": {"section_id": 630, "quality": 1.0, "length": 23}}, "n4659": {"so_32522701_32523222_0": {"section_id": 0, "quality": 0.9024390243902439, "length": 37}, "so_32522701_32523222_1": {"section_id": 668, "quality": 1.0, "length": 23}}}, "32522860": {"ParentId": "32522701", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>C c[10]</code> is not a polymorphic type. You might be able to get a pointer to the first item in the array, but that is still just a <code>C</code>. </p>\n<p>You would get slicing if you tried to cast it to <code>B</code>.</p>\n<p><code>C* c = new C();</code>  can be be <code>dynamic_cast</code> to <code>B</code>.</p>\n", "OwnerUserId": "174614", "LastEditorUserId": "174614", "LastEditDate": "2015-09-11T12:08:12.340", "Id": "32522860", "Score": "1", "CreationDate": "2015-09-11T11:51:20.043", "LastActivityDate": "2015-09-11T12:08:12.340"}, "32522701": {"CommentCount": "7", "ViewCount": "113", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-09-11T11:43:34.180", "LastActivityDate": "2015-09-11T12:10:28.967", "Title": "Ambiguous overload with array passed as pointer", "AcceptedAnswerId": "32523222", "LastEditDate": "2017-05-23T12:02:34.210", "Id": "32522701", "Score": "1", "Body": "<p>The following code</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {};\n\nclass B : public A {};\n\nclass C : public B {};\n\nvoid foo(A *a) {\n    cout &lt;&lt; 'A' &lt;&lt; endl;\n}\n\nvoid foo(B *b) {\n    cout &lt;&lt; 'B' &lt;&lt; endl;\n}\n\nint main() {\n    C *c = new C[10];\n\n    foo(c);\n}\n</code></pre>\n<p>compiles fine and prints 'B' as expected.</p>\n<p>But when I change the <code>main()</code> function to</p>\n<pre><code>int main() {\n    C c[10];\n\n    foo(c);\n}\n</code></pre>\n<p>I get a compiler error saying</p>\n<pre><code>test_arr.cpp: In function 'int main()':\ntest_arr.cpp:23:10: error: call of overloaded 'foo(C [10])' is ambiguous\ntest_arr.cpp:23:10: note: candidates are:\ntest_arr.cpp:11:6: note: void foo(A*)\ntest_arr.cpp:15:6: note: void foo(B*)\n</code></pre>\n<p>Why is it ambiguous now?  I thought an array was always just a pointer so I don't really see the difference.</p>\n<p><strong>Edit:</strong> </p>\n<p>I just realized the whole code I posted was a bad idea to start with: As soon as you add data members to the classes and access them in the <code>foo</code> functions you will run into problems, as explained <a href=\"https://stackoverflow.com/questions/13718527/how-to-make-an-array-with-polymorphism-in-c\">here</a>, since the <code>foo(B*)</code> function has no way of knowing it's actually dealing with <code>C</code> objects which potentially take more memory space.  So don't do this!</p>\n<p>Nevertheless I am still interested in understanding why the compiler complains about ambiguity here, since I really don't see a problem with <em>that</em> here.</p>\n", "Tags": "<c++><arrays><pointers><overloading><function-overloading>", "OwnerUserId": "4994337", "AnswerCount": "2"}});