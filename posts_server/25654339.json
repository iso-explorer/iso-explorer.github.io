post_cb({"25656964": {"ParentId": "25654339", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In C the result of pre and post increment are rvalues and we can not assign to an <em>rvalue</em>, we need an <em>lvalue</em>(<em><a href=\"http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/\" rel=\"noreferrer\">also see: Understanding lvalues and rvalues in C and C++</a></em>) . We can see by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">draft C11 standard</a> section <code>6.5.2.4</code> <em>Postfix increment and decrement operators</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_25654339_25656964_0\">The <strong>result</strong> of the postfix ++ operator <strong>is the value</strong> of the\n  operand. [...] See the discussions of additive operators and compound\n  assignment for information on constraints, types, and conversions and\n  the effects of operations on pointers. [...]</p>\n</blockquote>\n<p>So the result of post-increment is a <em>value</em> which is synonymous for <em>rvalue</em> and we can confirm this by going to section <code>6.5.16</code> <em>Assignment operators</em> which the paragraph above points us to for further understanding of constraints and results, it says:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_1\">[...] An assignment expression has the value of the left operand after the\n  assignment, <strong>but is not an lvalue</strong>.[...]</p>\n</blockquote>\n<p>which further confirms the result of post-increment is not an <em>lvalue</em>.</p>\n<p>For pre-increment we can see from section <code>6.5.3.1</code> <em>Prefix increment and decrement operators</em> which says:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_2\">[...]See the discussions of additive operators and compound assignment for\n  information on constraints, types, side effects, and conversions and\n  the effects of operations on pointers.</p>\n</blockquote>\n<p>also points back to <code>6.5.16</code> like post-increment does and therefore the result of pre-increment in C is also not an <em>lvalue</em>.</p>\n<p>In C++ post-increment is also an <em>rvalue</em>, more specifically a <em>prvalue</em> we can confirm this by going to section <code>5.2.6</code> <em>Increment and decrement</em> which says:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_3\">[...]<strong>The result is a prvalue.</strong> The type of the result is the cv-unqualified\n  version of the type of the operand[...]</p>\n</blockquote>\n<p>With respect to pre-increment C and C++ differ. In C the result is an <em>rvalue</em> while in C++ the result is a <em>lvalue</em> which explains why <code>++ptr = ptr1;</code> works in C++ but not C.</p>\n<p>For C++ this is covered in section <code>5.3.2</code> <em>Increment and decrement</em> which says:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_4\">[...]The result is the updated operand; <strong>it is an lvalue</strong>, and it is a\n  bit-field if the operand is a bit-field.[...]</p>\n</blockquote>\n<p>To understand whether:</p>\n<pre><code>++ptr = ptr1;\n</code></pre>\n<p>is well defined or not in C++ we need two different approaches one for pre C++11 and one for C++11. </p>\n<p>Pre C++11 this expression invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"noreferrer\">undefined behavior</a>, since it is modifying the object more than once within the same sequence point. We can see this by going to a Pre C++11 draft standard section <code>5</code> <em>Expressions</em> which says:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_5\">Except where noted, the order of evaluation of operands of individual\n  operators and subexpressions of individual expressions, and the order\n  in which side effects take place, is unspecified.57) <strong>Between the\n  previous and next sequence point a scalar object shall have its stored\n  value modified at most once by the evaluation of an expression.</strong>\n  Furthermore, the prior value shall be accessed only to determine the\n  value to be stored. The requirements of this paragraph shall be met\n  for each allowable ordering of the subexpressions of a full\n  expression; otherwise the behavior is undefined. [ Example:</p>\n<pre><code> i = v[i ++]; / / the behavior is undefined\n i = 7 , i++ , i ++; / / i becomes 9\n i = ++ i + 1; / / the behavior is undefined\n i = i + 1; / / the value of i is incremented\n</code></pre>\n<p id=\"so_25654339_25656964_6\">\u2014end example ]</p>\n</blockquote>\n<p>We are incrementing <code>ptr</code> and then subsequently assigning to it, which is two modifications and in this case the sequence point occurs at the end of the expression after the <code>;</code>.</p>\n<p>For C+11, we should go to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637\" rel=\"noreferrer\">defect report 637: Sequencing rules and example disagree </a> which was the defect report that resulted in:</p>\n<pre><code>i = ++i + 1;\n</code></pre>\n<p>becoming well defined behavior in C++11 whereas prior to C++11 this was <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"noreferrer\">undefined behavior</a>. The explanation in this report is one of best I have even seen and reading it many times was enlightening and helped me understand many concepts in a new light.</p>\n<p>The logic that lead to this expression becoming well defined behavior goes as follows:</p>\n<ol>\n<li><p>The assignment side-effect is required to be sequenced after the value computations of both its LHS and RHS (5.17 [expr.ass] paragraph 1).</p></li>\n<li><p>The LHS (i) is an lvalue, so its value computation involves computing the address of i.</p></li>\n<li><p>In order to value-compute the RHS (++i + 1), it is necessary to first value-compute the lvalue expression ++i and then do an lvalue-to-rvalue conversion on the result. This guarantees that the incrementation side-effect is sequenced before the computation of the addition operation, which in turn is sequenced before the assignment side effect. In other words, it yields a well-defined order and final value for this expression.</p></li>\n</ol>\n<p>The logic is somewhat similar for:</p>\n<pre><code>++ptr = ptr1;\n</code></pre>\n<ol>\n<li><p>The value computations of the LHS and RHS are sequenced before the assignment side-effect.</p></li>\n<li><p>The RHS is an lvalue, so its value computation involves computing the address of ptr1.</p></li>\n<li><p>In order to value-compute the LHS (++ptr), it is necessary to first value-compute the lvalue expression ++ptr and then do an lvalue-to-rvalue conversion on the result. This guarantees that the incrementation side-effect is sequenced before the assignment side effect. In other words, it yields a well-defined order and final value for this expression.</p></li>\n</ol>\n<p><b>Note</b></p>\n<p>The OP said:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_7\">Yes, I understand it's messy and you're dealing with unallocated\n  memory, but it works and compiles.</p>\n</blockquote>\n<p>Pointers to non-array objects are considered arrays of size one for additive operators, I am going to quote the draft C++ standard but C11 has almost the exact same text. From section <code>5.7</code> <em>Additive operators</em>:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_8\">For the purposes of these operators, a pointer to a nonarray object\n  behaves the same as a pointer to the first element of an array of\n  length one with the type of the object as its element type.</p>\n</blockquote>\n<p>and further tells us pointing one past the end of an array is valid as long as you don't dereference the pointer:</p>\n<blockquote>\n<p id=\"so_25654339_25656964_9\">[...]If both the pointer operand and the result point to elements of\n  the same array object, <strong>or one past the last element of the array\n  object</strong>, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</p>\n</blockquote>\n<p>so:</p>\n<pre><code>++ptr ;\n</code></pre>\n<p>is still a valid pointer.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-09-04T17:01:21.743", "Id": "25656964", "Score": "17", "CreationDate": "2014-09-04T03:44:41.370", "LastActivityDate": "2014-09-04T17:01:21.743"}, "25654561": {"ParentId": "25654339", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>In both C and C++, the result of <code>x++</code> is an rvalue, so you can't assign to it.</p>\n<p>In C, <code>++x</code> is equivalent to <code>x += 1</code> (C standard \u00a76.5.3.1/p2; all C standard cites are to WG14 N1570). In C++, <code>++x</code> is equivalent to <code>x += 1</code> if <code>x</code> is not a <code>bool</code> (C++ standard \u00a75.3.2 [expr.pre.incr]/p1; all C++ standard cites are to WG21 N3936).</p>\n<p>In C, the result of an assignment expression is an rvalue (C standard \u00a76.5.16/p3):</p>\n<blockquote>\n<p id=\"so_25654339_25654561_0\">An assignment operator stores a value in the object designated by the\n  left operand. An assignment expression has the value of the left\n  operand after the assignment, but is not an lvalue.</p>\n</blockquote>\n<p>Because it's not an lvalue, you can't assign to it: (C standard \u00a76.5.16/p2 - note that this is a constraint)</p>\n<blockquote>\n<p id=\"so_25654339_25654561_1\">An assignment operator shall have a modifiable lvalue as its left\n  operand.</p>\n</blockquote>\n<p>In C++, the result of an assignment expression is an lvalue (C++ standard \u00a75.17 [expr.ass]/p1):</p>\n<blockquote>\n<p id=\"so_25654339_25654561_2\">The assignment operator (=) and the compound assignment operators all\n  group right-to-left. All require a modifiable lvalue as their left\n  operand and return an lvalue referring to the left operand.</p>\n</blockquote>\n<p>So <code>++ptr = ptr1;</code> is a diagnosable constraint violation in C, but does not violate any diagnosable rule in C++.</p>\n<p>However, pre-C++11, <code>++ptr = ptr1;</code> has undefined behavior, as it modifies <code>ptr</code> twice between two adjacent sequence points.</p>\n<p>In C++11, the behavior of <code>++ptr = ptr1</code> becomes well defined. It's clearer if we rewrite it as </p>\n<pre><code>(ptr += 1) = ptr1;\n</code></pre>\n<p>Since C++11, the C++ standard provides that (\u00a75.17 [expr.ass]/p1)</p>\n<blockquote>\n<p id=\"so_25654339_25654561_3\">In all cases, the assignment is sequenced after the value computation\n  of the right and left operands, and before the value computation of\n  the assignment expression. With respect to an\n  indeterminately-sequenced function call, the operation of a compound\n  assignment is a single evaluation.</p>\n</blockquote>\n<p>So the assignment performed by the <code>=</code> is sequenced after the value computation of <code>ptr += 1</code> and <code>ptr1</code>. The assignment performed by the <code>+=</code> is sequenced before the value computation of <code>ptr += 1</code>, and all value computations required by the <code>+=</code> are necessarily sequenced before that assignment. Thus, the sequencing here is well-defined and there is no undefined behavior.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-02-20T15:38:54.960", "Id": "25654561", "Score": "73", "CreationDate": "2014-09-03T22:23:31.487", "LastActivityDate": "2015-02-20T15:38:54.960"}, "25654339": {"CommentCount": "28", "AcceptedAnswerId": "25654561", "PostTypeId": "1", "LastEditorUserId": "2139766", "CreationDate": "2014-09-03T22:01:15.887", "LastActivityDate": "2015-02-20T15:38:54.960", "LastEditDate": "2014-09-05T23:06:21.507", "ViewCount": "4226", "FavoriteCount": "22", "Title": "The difference between C and C++ regarding the ++ operator", "Id": "25654339", "Score": "68", "Body": "<p>I have been fooling around with some code and saw something that I don't understand the \"why\" of.</p>\n<pre><code>int i = 6;\nint j;\n\nint *ptr = &amp;i;\nint *ptr1 = &amp;j\n\nj = i++;\n\n//now j == 6 and i == 7. Straightforward.\n</code></pre>\n<p>What if you put the operator on the left side of the equals sign?</p>\n<pre><code>++ptr = ptr1;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>(ptr = ptr + 1) = ptr1; \n</code></pre>\n<p>whereas</p>\n<pre><code>ptr++ = ptr1;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>ptr = ptr + 1 = ptr1;\n</code></pre>\n<p>The postfix runs a compilation error and I get it. You've got a constant \"ptr + 1\" on the left side of an assignment operator. Fair enough. </p>\n<p>The prefix one compiles and WORKS in C++. Yes, I understand it's messy and you're dealing with unallocated memory, but it works and compiles. In C this does not compile, returning the same error as the postfix \"lvalue required as left operand of assignment\". This happens no matter how it's written, expanded out with two \"=\" operators or with the \"++ptr\" syntax.</p>\n<p>What is the difference between how C handles such an assignment and how C++ handles it?</p>\n", "Tags": "<c++><c><increment><prefix>", "OwnerUserId": "1871495", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25654339_25656964_1": {"section_id": 6173, "quality": 0.5555555555555556, "length": 5}, "so_25654339_25656964_9": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_25654339_25656964_4": {"section_id": 6074, "quality": 0.875, "length": 7}, "so_25654339_25654561_2": {"section_id": 6173, "quality": 0.9523809523809523, "length": 20}, "so_25654339_25654561_3": {"section_id": 6173, "quality": 0.96, "length": 24}, "so_25654339_25656964_3": {"section_id": 6009, "quality": 0.8, "length": 8}, "so_25654339_25654561_1": {"section_id": 6173, "quality": 0.75, "length": 6}, "so_25654339_25656964_8": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_25654339_25656964_1": {"section_id": 5934, "quality": 0.5555555555555556, "length": 5}, "so_25654339_25656964_9": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_25654339_25656964_4": {"section_id": 5842, "quality": 0.875, "length": 7}, "so_25654339_25654561_2": {"section_id": 5934, "quality": 0.9523809523809523, "length": 20}, "so_25654339_25654561_3": {"section_id": 5934, "quality": 0.96, "length": 24}, "so_25654339_25656964_3": {"section_id": 5777, "quality": 0.8, "length": 8}, "so_25654339_25654561_1": {"section_id": 5934, "quality": 0.75, "length": 6}, "so_25654339_25656964_8": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_25654339_25656964_1": {"section_id": 8741, "quality": 0.6666666666666666, "length": 6}, "so_25654339_25656964_9": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_25654339_25656964_4": {"section_id": 7570, "quality": 0.875, "length": 7}, "so_25654339_25654561_2": {"section_id": 7675, "quality": 0.9523809523809523, "length": 20}, "so_25654339_25654561_3": {"section_id": 7675, "quality": 0.96, "length": 24}, "so_25654339_25656964_3": {"section_id": 7508, "quality": 0.8, "length": 8}, "so_25654339_25654561_1": {"section_id": 7675, "quality": 0.75, "length": 6}, "so_25654339_25654561_0": {"section_id": 7675, "quality": 0.5294117647058824, "length": 9}, "so_25654339_25656964_8": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}}}});