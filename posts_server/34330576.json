post_cb({"bq_ids": {"n4140": {"so_34330576_34331455_1": {"length": 37, "quality": 0.925, "section_id": 2717}}, "n3337": {"so_34330576_34331455_1": {"length": 37, "quality": 0.925, "section_id": 2678}}, "n4659": {"so_34330576_34331455_1": {"length": 35, "quality": 0.875, "section_id": 3457}}}, "34330576": {"ViewCount": "700", "Body": "<p>I am trying to use multithread for connecting for more then one peer simultinaly.\nWhile I am running my code and run more then a one thread the program crashes in the \"connect\" function and it writes: \"Abort() has been called\".</p>\n<p>This is How I call to the threads:</p>\n<pre><code>TcpPeers(OrderedMap&lt;std::string, unsigned short&gt; peers, std::string     infoHash)\n   {\n    this-&gt;peers = peers;\n    peersArr = new Peer[peers.GetSize()];\n\n    for (int i = 0; i &lt; peers.GetSize(); i++)\n    {\n        Peer * pp = new Peer(peers.GetKeyByIndex(i), peers.GetValueByIndex(i), infoHash);\n        *(peersArr + i) = *pp;\n    }\n\n    for (int i = 0; i &lt; peers.GetSize(); i++)\n    {\n        std::thread t1(&amp;Peer::CreateConnection, *(peersArr + i));\n    }\n}\n</code></pre>\n<p>A peer is another client that I need to connect with while I am trying to implement the bittorent protocol.</p>\n<p>Again, when there is one thread all goes right, when I have more then two peers all crashes.</p>\n", "AcceptedAnswerId": "34331455", "Title": "Abort() has been called - Connect Function multithreads Cpp", "CreationDate": "2015-12-17T09:07:46.257", "Id": "34330576", "CommentCount": "2", "LastEditDate": "2015-12-17T09:40:36.220", "PostTypeId": "1", "LastEditorUserId": "3421416", "LastActivityDate": "2015-12-17T09:56:35.177", "Score": "2", "OwnerUserId": "3421416", "Tags": "<c++><multithreading><sockets><thread-safety><bittorrent>", "AnswerCount": "1"}, "34331455": {"Id": "34331455", "PostTypeId": "2", "Body": "<p>When a <code>std::thread</code> object gets destroyed it is not allowed to be <code>joinable()</code>, i.e., one of two things have to happen before it is destroyed:</p>\n<ol>\n<li>It was detached and the thread has gone into the wild and there is pretty much no control over whether it has finished or not.</li>\n<li>The thread has been <code>join()</code>ed.</li>\n</ol>\n<p>If a <code>std::thread</code> object is destroyed without either of these states, <code>std::terminate()</code> is called which is probably the cause for the call to <code>abort()</code> you observe. In your loop you keep destroying threads without having called either <code>detach()</code> or <code>join()</code> on them. The system sees that as a request to terminate your program.</p>\n<p>In case you need a reference for this behavior: see 30.3.1.3 [thread.thread.destr] paragraph 1:</p>\n<blockquote>\n<p id=\"so_34330576_34331455_0\"><code>~thread();</code></p>\n<p id=\"so_34330576_34331455_1\">If <code>joinable()</code>, calls <code>std::terminate()</code>. Otherwise, has no effects. [ Note: Either implicitly detaching or joining a <code>joinable()</code> thread in its destructor could result in difficult to debug correctness (for <code>detach</code>) or performance (for <code>join</code>) bugs encountered only when an exception is raised. Thus the programmer must ensure that the destructor is never executed while the thread is still <code>joinable</code>. \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2015-12-17T09:56:35.177", "Score": "1", "CreationDate": "2015-12-17T09:50:56.830", "ParentId": "34330576", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2015-12-17T09:56:35.177"}});