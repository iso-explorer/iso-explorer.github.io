post_cb({"bq_ids": {"n4140": {"so_30462113_30473350_1": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_30462113_30473350_3": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_30462113_30473350_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_30462113_30473350_2": {"length": 9, "quality": 1.0, "section_id": 7195}, "so_30462113_30473350_4": {"length": 17, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_30462113_30473350_1": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_30462113_30473350_3": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_30462113_30473350_2": {"length": 9, "quality": 1.0, "section_id": 6939}, "so_30462113_30473350_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_30462113_30473350_4": {"length": 17, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_30462113_30473350_1": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_30462113_30473350_3": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_30462113_30473350_2": {"length": 9, "quality": 1.0, "section_id": 8704}, "so_30462113_30473350_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_30462113_30473350_4": {"length": 17, "quality": 1.0, "section_id": 8704}}}, "30564385": {"Id": "30564385", "PostTypeId": "2", "Body": "<p>Destroy-and-regenerate has fundamentally different behavior from copy-and-swap. Compare:</p>\n<ol>\n<li>Destroy the old value. It's gone forever now.</li>\n<li>Try to construct a new value.</li>\n<li>Give up and construct a default value if necessary.</li>\n</ol>\n<p>Copy-and-swap:</p>\n<ol>\n<li>Try to construct a new value.</li>\n<li>Give up and leave the old value if necessary.</li>\n<li>Apply the new value.</li>\n</ol>\n<p>Both have their merits, but copy-and-swap is ubiquitous so its disadvantages are mooted by the principle of least surprise. So let's emulate its behavior:</p>\n<pre><code>foo &amp; operator = ( foo const &amp; other ) {\n    static_assert ( std::is_nothrow_move_constructible&lt; foo &gt;::value\n                 || std::is_nothrow_default_constructible&lt; foo &gt;::value\n                 , \"Exception safety violation\" );\n\n    foo next( other );\n    try {\n        this-&gt; ~ foo();\n        new (this) foo( std::move( next ) );\n    } catch (...) {\n        new (this) foo();\n        throw;\n    }\n    return * this;\n}\n</code></pre>\n<p>Although more complicated, this is better-behaved than a throwing <code>swap</code>, which could leave a hodgepodge of the old and new values after an exception.</p>\n<p>In the common case where the move constructor doesn't throw (you remembered to declare it <code>noexcept</code>, right?), the algorithm reduces nicely:</p>\n<pre><code>foo &amp; operator = ( foo const &amp; other ) {\n    foo next( other );\n    // The dangerous part is over now.\n\n    this-&gt; ~ foo();\n    new (this) foo( std::move( next ) );\n    return * this;\n}\n</code></pre>\n", "LastActivityDate": "2015-06-01T01:11:24.767", "CommentCount": "0", "CreationDate": "2015-06-01T01:11:24.767", "ParentId": "30462113", "Score": "0", "OwnerUserId": "153285"}, "30473350": {"Id": "30473350", "PostTypeId": "2", "Body": "<p>The standard makes guarantees about such interrupted lifetimes in [basic.life] \u00a73.8/7:</p>\n<blockquote>\n<p id=\"so_30462113_30473350_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_30462113_30473350_1\">\u2014 the storage for the new object exactly overlays the storage location which the original object occupied, and</p>\n<p id=\"so_30462113_30473350_2\">\u2014 the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p>\n<p id=\"so_30462113_30473350_3\">\u2014 the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</p>\n<p id=\"so_30462113_30473350_4\">\u2014 the original object was a most derived object (\u00a71.8) of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</p>\n</blockquote>\n<p>The last point disqualifies my use-case. However, since this is only for one non-polymorphic class, it's just as well to turn the destructor and constructors into <code>destroy</code> and <code>init</code> private member functions, respectively.</p>\n<p>In other words, when destroy-and-regenerate is legal, you might as well do the same thing using member functions and no <code>new</code>/<code>delete</code>.</p>\n<p>An \"advantage\" to this is that it ceases to look clever, so no ignorant passer-by would want to copy the design.</p>\n", "LastActivityDate": "2015-05-27T04:43:41.250", "CommentCount": "0", "CreationDate": "2015-05-27T04:43:41.250", "ParentId": "30462113", "Score": "2", "OwnerUserId": "153285"}, "30462113": {"ViewCount": "146", "Body": "<p>This is a bad pattern. Copy-and-swap is better.</p>\n<pre><code>foo &amp; operator = ( foo const &amp; other ) {\n    static_assert ( noexcept( new (this) foo() ), \"Exception safety violation\" );\n\n    this-&gt; ~ foo();\n    try {\n        new (this) foo( other );\n    } catch (...) {\n        new (this) foo(); // does not throw\n        throw;\n    }\n    return * this;\n}\n</code></pre>\n<p>As long as <code>foo</code> is <a href=\"https://stackoverflow.com/q/28113431/153285\">not polymorphic</a>, what could go wrong? (However, assume that it <em>is</em> a base class.)</p>\n<p>Background: I'm dealing with local-storage type erasure, and the alternative is to implement <code>swap</code> as two hard-coded assignments through a local storage space. The objects in the memory blobs of the source and destination are of different types and simply can't swap with each other. Copy/move construction defined in terms of such a swap is twice as complicated for seemingly no gain.</p>\n", "AcceptedAnswerId": "30564385", "Title": "Destroy-and-regenerate assignment operator: what if I'm careful?", "CreationDate": "2015-05-26T14:56:21.480", "Id": "30462113", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:43:45.330", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-01T01:11:24.767", "Score": "6", "OwnerUserId": "153285", "Tags": "<c++><destructor><undefined-behavior>", "AnswerCount": "2"}});