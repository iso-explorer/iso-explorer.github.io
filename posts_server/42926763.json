post_cb({"42927051": {"Id": "42927051", "PostTypeId": "2", "Body": "<p>Quoting <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Multiplicative_operators\" rel=\"noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_42926763_42927051_0\">If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/is_iec559\" rel=\"noreferrer\"><code>std::numeric_limits::is_iec559</code></a>), then:</p>\n<ul>\n<li><p id=\"so_42926763_42927051_1\">if one operand is NaN, the result is NaN</p></li>\n<li><p id=\"so_42926763_42927051_2\">dividing a non-zero number by \u00b10.0 gives the correctly-signed infinity and <code>FE_DIVBYZERO</code> is raised</p></li>\n<li><p id=\"so_42926763_42927051_3\">dividing 0.0 by 0.0 gives NaN and <code>FE_INVALID</code> is raised </p></li>\n</ul>\n</blockquote>\n<p>We are talking about floating-point division here, so it is actually implementation-defined whether <code>double</code> division by zero is undefined.</p>\n<p>If <code>std::numeric_limits&lt;double&gt;::is_iec559</code> is <code>true</code>, and it is <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/is_iec559\" rel=\"noreferrer\">\"usually <code>true</code>\"</a>, then the behaviour is well-defined and produces the expected results.  </p>\n<p>A pretty safe bet would be to plop down a:</p>\n<pre><code>static_assert(std::numeric_limits&lt;double&gt;::is_iec559, \"Please use IEEE754, you weirdo\");\n</code></pre>\n<p>... near your code.</p>\n", "LastEditorUserId": "3233393", "LastActivityDate": "2017-03-21T12:28:01.913", "Score": "17", "CreationDate": "2017-03-21T12:22:48.473", "ParentId": "42926763", "CommentCount": "15", "OwnerUserId": "3233393", "LastEditDate": "2017-03-21T12:28:01.913"}, "42929232": {"Id": "42929232", "PostTypeId": "2", "Body": "<p>As to the submitter's question 'Who's correct?', it is perfectly OK to say that <em>both</em> answers are correct.  The fact that the C standard describes the behavior as 'undefined' DOES NOT dictate what the underlying hardware actually does; it merely means that <em>if you want your program to be meaningful according to the standard</em> you -may not assume- that the hardware actually implements that operation.  But if you happen to be running on hardware that implements the IEEE standard, you will find the operation is in fact implemented, with the results as stipulated by the IEEE standard.</p>\n", "LastActivityDate": "2017-03-21T13:57:10.117", "CommentCount": "0", "CreationDate": "2017-03-21T13:57:10.117", "ParentId": "42926763", "Score": "1", "OwnerUserId": "7746016"}, "42926899": {"Id": "42926899", "PostTypeId": "2", "Body": "<p>Division by 0 is <strong>undefined behavior</strong>.</p>\n<p>From section 5.6 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++ standard (C++11)</a>:</p>\n<blockquote>\n<p id=\"so_42926763_42926899_0\">The binary <code>/</code> operator yields the quotient, and the binary <code>%</code> operator\n  yields the remainder from the division of the first expression by the\n  second. <strong>If the second operand of <code>/</code> or <code>%</code> is zero the behavior is\n  undefined.</strong> For integral operands the <code>/</code> operator yields the algebraic\n  quotient with any fractional part discarded; if the quotient <code>a/b</code> is\n  representable in the type of the result, <code>(a/b)*b + a%b</code> is equal to <code>a</code> .</p>\n</blockquote>\n<p>No distinction is made between integer and floating point operands for the <code>/</code> operator.  The standard only states that dividing by zero is undefined without regard to the operands.</p>\n", "LastEditorUserId": "1687119", "LastActivityDate": "2017-03-22T02:52:43.723", "Score": "4", "CreationDate": "2017-03-21T12:16:07.083", "ParentId": "42926763", "CommentCount": "3", "OwnerUserId": "1687119", "LastEditDate": "2017-03-22T02:52:43.723"}, "42928409": {"Id": "42928409", "PostTypeId": "2", "Body": "<p>This also depends on the floating point environment.</p>\n<p>cppreference has details:\n<a href=\"http://en.cppreference.com/w/cpp/numeric/fenv\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/numeric/fenv</a>\n(no examples though).</p>\n<p>This should be available in most desktop/server C++11 and C99 environments. There are also platform-specific variations that predate the standardization of all this.</p>\n<p>I would expect that enabling exceptions makes the code run more slowly, so probably for this reason most platforms that I know of disable exceptions by default.</p>\n", "LastActivityDate": "2017-03-21T13:22:01.120", "CommentCount": "2", "CreationDate": "2017-03-21T13:22:01.120", "ParentId": "42926763", "Score": "0", "OwnerUserId": "6594576"}, "42927110": {"Id": "42927110", "PostTypeId": "2", "Body": "<p>In [expr]/4 we have</p>\n<blockquote>\n<p id=\"so_42926763_42927110_0\">If during the evaluation of an expression, <strong>the result is not mathematically defined</strong> or not in the range of representable values for its type, <strong>the behavior is undefined</strong>. [ Note: most existing implementations of C++ ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all floating point exceptions vary among machines, and is usually adjustable by a library function. \u2014end note ]</p>\n</blockquote>\n<p><sup>Emphasis mine</sup></p>\n<p>So per the standard this is undefined behavior.  It does go on to say that some of these cases are actually handled by the implementation and are configurable.  So it won't say it is implementation defined but it does let you know that implementations do define some of this behavior.</p>\n", "LastActivityDate": "2017-03-21T12:25:29.367", "CommentCount": "0", "CreationDate": "2017-03-21T12:25:29.367", "ParentId": "42926763", "Score": "5", "OwnerUserId": "4342498"}, "bq_ids": {"n4140": {"so_42926763_42927110_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5937}, "so_42926763_42926875_1": {"length": 4, "quality": 0.8, "section_id": 6106}, "so_42926763_42926875_5": {"length": 5, "quality": 1.0, "section_id": 6732}, "so_42926763_42926899_0": {"length": 24, "quality": 0.7058823529411765, "section_id": 6137}, "so_42926763_42926875_6": {"length": 4, "quality": 1.0, "section_id": 6773}, "so_42926763_42926875_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 6774}, "so_42926763_42926875_3": {"length": 4, "quality": 1.0, "section_id": 6773}}, "n3337": {"so_42926763_42927110_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5709}, "so_42926763_42926875_1": {"length": 4, "quality": 0.8, "section_id": 5872}, "so_42926763_42926875_5": {"length": 5, "quality": 1.0, "section_id": 6487}, "so_42926763_42926899_0": {"length": 24, "quality": 0.7058823529411765, "section_id": 5901}, "so_42926763_42926875_6": {"length": 4, "quality": 1.0, "section_id": 6528}, "so_42926763_42926875_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 6529}, "so_42926763_42926875_3": {"length": 4, "quality": 1.0, "section_id": 6528}}, "n4659": {"so_42926763_42927110_0": {"length": 29, "quality": 0.7073170731707317, "section_id": 7421}, "so_42926763_42926875_1": {"length": 4, "quality": 0.8, "section_id": 7603}, "so_42926763_42926875_3": {"length": 4, "quality": 1.0, "section_id": 8267}, "so_42926763_42926899_0": {"length": 24, "quality": 0.7058823529411765, "section_id": 7634}, "so_42926763_42926875_6": {"length": 4, "quality": 1.0, "section_id": 8267}}}, "42926875": {"Id": "42926875", "PostTypeId": "2", "Body": "<p>C++ standard does not force the IEEE 754 standard, because that depends mostly on hardware architecture.</p>\n<p>If the hardware/compiler implement correctly the IEEE 754 standard, the division will provide the expected INF, -INF and NaN, otherwise... it depends.</p>\n<p>Undefined means, the compiler implementation decides, and there are many variables to that like the hardware architecture, code generation efficiency, compiler developer laziness, etc..</p>\n<p><strong>Source:</strong></p>\n<p>The C++ standard state that a division by 0.0 is <code>undefined</code></p>\n<blockquote>\n<p id=\"so_42926763_42926875_0\">C++ Standard 5.6.4</p>\n<p id=\"so_42926763_42926875_1\">... If the second operand of / or % is zero the behavior is undefined</p>\n<p id=\"so_42926763_42926875_2\">C++ Standard 18.3.2.4</p>\n<p id=\"so_42926763_42926875_3\">...static constexpr bool is_iec559;</p>\n<p id=\"so_42926763_42926875_4\">...56. True if and only if the type adheres to IEC 559 standard.217</p>\n<p id=\"so_42926763_42926875_5\">...57. Meaningful for all floating point types.</p>\n</blockquote>\n<p><strong>C++ detection of IEEE754:</strong></p>\n<p>The standard library includes a template to detect if IEEE754 is supported or not:</p>\n<blockquote>\n<p id=\"so_42926763_42926875_6\">static constexpr bool is_iec559;</p>\n</blockquote>\n<pre><code>#include &lt;numeric&gt;\nbool isFloatIeee754 = std::numeric_limits&lt;float&gt;::is_iec559();\n</code></pre>\n<p>Of course, this mechanism assumes the compiler is aware of the target execution machine (which could theoretically not be the case).</p>\n<p><strong>What if IEEE754 is not supported?</strong></p>\n<p>It depends, usually a division by 0 trigger a hardware exception and make the application terminate. </p>\n", "LastEditorUserId": "1212756", "LastActivityDate": "2017-03-22T21:59:04.700", "Score": "24", "CreationDate": "2017-03-21T12:14:53.843", "ParentId": "42926763", "CommentCount": "20", "OwnerUserId": "1212756", "LastEditDate": "2017-03-22T21:59:04.700"}, "42926763": {"ViewCount": "3198", "Body": "<p>Consider</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    double a = 1.0 / 0;\n    double b = -1.0 / 0;\n    double c = 0.0 / 0;\n    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c; // to stop compilers from optimising out the code.    \n}\n</code></pre>\n<p>I have always thought that <code>a</code> will be +Inf, <code>b</code> will be -Inf, and <code>c</code> will be NaN. But I also hear rumours that strictly speaking the behaviour of floating point division by zero is <em>undefined</em> and therefore the above code cannot considered to be portable C++. (That theoretically obliterates the integrity of my million line plus code stack. Oops.)</p>\n<p>Who's correct?</p>\n<p>Note I'm happy with <em>implementation defined</em>, but I'm talking about cat-eating, demon-sneezing <em>undefined behaviour</em> here.</p>\n", "Title": "The behaviour of floating point division by zero", "CreationDate": "2017-03-21T12:10:03.383", "LastActivityDate": "2017-03-22T21:59:04.700", "CommentCount": "16", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-03-21T12:30:52.260", "LastEditorUserId": "3233393", "Id": "42926763", "Score": "32", "OwnerUserId": "2380830", "Tags": "<c++><floating-point><language-lawyer><undefined-behavior>", "AnswerCount": "6"}});