post_cb({"8688921": {"ParentId": "8688912", "CommentCount": "1", "Body": "<p>I've just realised I'm being silly:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nint main() {\n   std::ifstream f;\n   std::cout &lt;&lt; f.get() &lt;&lt; \", \";\n   std::cout &lt;&lt; f.good() &lt;&lt; \", \" &lt;&lt; f.bad();\n}\n\n// Output: -1, 0, 0\n</code></pre>\n<p>Unspecified evaluation order. Duh.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "8688921", "Score": "1", "CreationDate": "2011-12-31T15:27:59.443", "LastActivityDate": "2011-12-31T15:27:59.443"}, "8688926": {"ParentId": "8688912", "CommentCount": "1", "Body": "<p>The problem is that the order that the operations on f is called is not specified by the standard.  The compiler is free to call <code>f.good()</code>, <code>f.bad()</code>, and <code>f.get()</code> in any order it chooses.</p>\n<p>Try changing to print it on separate lines.</p>\n", "OwnerUserId": "862231", "PostTypeId": "2", "Id": "8688926", "Score": "2", "CreationDate": "2011-12-31T15:29:06.353", "LastActivityDate": "2011-12-31T15:29:06.353"}, "8688912": {"CommentCount": "2", "ViewCount": "236", "CreationDate": "2011-12-31T15:25:29.243", "LastActivityDate": "2011-12-31T15:29:06.353", "Title": "Why is this non-open ifstream still \"good\" after I try to extract from it?", "AcceptedAnswerId": "8688921", "PostTypeId": "1", "Id": "8688912", "Score": "3", "Body": "<p>In GCC 4.7.0 20111217, <a href=\"http://codepad.org/nhojwVXL\" rel=\"nofollow\">GCC 4.1.2</a>, <a href=\"http://www.ideone.com/ybRxD\" rel=\"nofollow\">GCC 4.3.4</a> and <a href=\"http://www.ideone.com/7kciC\" rel=\"nofollow\">GCC 4.5.1</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nint main() {\n   std::ifstream f;\n   std::cout &lt;&lt; f.get() &lt;&lt; \", \" &lt;&lt; f.good() &lt;&lt; \", \" &lt;&lt; f.bad();\n}\n\n// Output: -1, 1, 0\n</code></pre>\n<p>I'd have expected <code>-1, 0, 1</code> (which Clang 3.1 gives me), because of these paragraphs:</p>\n<blockquote>\n<p id=\"so_8688912_8688912_0\"><code>[C++11: 27.7.2.3]:</code></p>\n<pre><code>int_type get();\n</code></pre>\n<p id=\"so_8688912_8688912_1\">4 <strong>Effects:</strong> Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After constructing a sentry object, <strong>extracts a character <code>c</code>, if one is available. Otherwise, the function calls <code>setstate(failbit)</code></strong>, which may throw <code>ios_base::failure</code> (27.5.5.4), <br/>\n  5 <strong>Returns:</strong> <code>c</code> if available, otherwise <code>traits::eof()</code>.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_8688912_8688912_2\"><code>[C++11: 27.9.1.1/3]:</code> In particular:</p>\n<ul>\n<li>If the file is not open for reading the input sequence cannot be read.</li>\n<li>If the file is not open for writing the output sequence cannot be written.</li>\n<li>A joint file position is maintained for both the input sequence and the output sequence.</li>\n</ul>\n</blockquote>\n<p>Is GCC in the wrong here? Did an implementer misinterpret the \"otherwise\" in <code>[C++11: 27.7.2.3/4]</code>? Or did I misinterpret the standard?</p>\n", "Tags": "<c++><iostream>", "OwnerUserId": "560648", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8688912_8688912_1": {"section_id": 2211, "quality": 0.75, "length": 21}}, "n3337": {"so_8688912_8688912_1": {"section_id": 2199, "quality": 0.75, "length": 21}}, "n4659": {"so_8688912_8688912_1": {"section_id": 2484, "quality": 0.7142857142857143, "length": 20}}}});