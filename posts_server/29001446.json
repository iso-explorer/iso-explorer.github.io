post_cb({"bq_ids": {"n4140": {"so_29001446_29001694_1": {"length": 13, "quality": 0.5909090909090909, "section_id": 87}, "so_29001446_29001694_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_29001446_29001446_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 7104}, "so_29001446_29001648_0": {"length": 13, "quality": 0.5909090909090909, "section_id": 87}}, "n3337": {"so_29001446_29001694_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 82}, "so_29001446_29001694_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_29001446_29001648_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 82}, "so_29001446_29001446_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 6848}}, "n4659": {"so_29001446_29001694_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 90}, "so_29001446_29001648_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 90}, "so_29001446_29001446_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 8605}, "so_29001446_29001446_0": {"length": 5, "quality": 0.625, "section_id": 180}}}, "29001446": {"ViewCount": "1137", "Body": "<p>I don't really understand why the code below does not compile:</p>\n<pre><code>template&lt;const char*&gt;\nstruct Foo{};\n\nconstexpr const char s1[] = \"test1\";\nconstexpr const char* const s2 = \"test2\";\n\nint main()\n{\n    Foo&lt;s1&gt; foo1; // ok\n    // Foo&lt;s2&gt; foo2; // doesn't compile\n}\n</code></pre>\n<p>Uncommenting the last line in <code>main()</code> makes g++ and clang++ emit the errors</p>\n<blockquote id=\"so_29001446_29001446_0\">\n<pre><code>error: 's2' is not a valid template argument because 's2' is a\nvariable, not the address of a variable\n</code></pre>\n</blockquote>\n<p>and </p>\n<blockquote id=\"so_29001446_29001446_1\">\n<pre><code>error: non-type template argument for template parameter of\n      pointer type 'const char *' must have its address taken\n</code></pre>\n</blockquote>\n<p>respectively.</p>\n<p>My questions are:</p>\n<ol>\n<li>Why is <code>s1</code> instantiation OK and <code>s2</code> not?</li>\n<li>Is there any sane situation where such pointer non-type template parameter is of any use?</li>\n</ol>\n", "AcceptedAnswerId": "29001648", "Title": "pointer non-type template parameter", "CreationDate": "2015-03-12T03:37:55.253", "Id": "29001446", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-03-12T08:36:56.360", "Score": "15", "OwnerUserId": "3093378", "Tags": "<c++><templates><c++11>", "AnswerCount": "3"}, "29001648": {"Id": "29001648", "PostTypeId": "2", "Body": "<p>For 1.:</p>\n<p>From [temp.arg.nontype]</p>\n<blockquote>\n<p id=\"so_29001446_29001648_0\">1 A template-argument for a non-type template-parameter shall be a converted constant expression (5.20) of the type of the template-parameter. For a non-type template-parameter of reference or pointer type, the value of the constant expression shall not refer to (<strong>or for a pointer type, shall not be the address of</strong>):</p>\n<p id=\"so_29001446_29001648_1\">[...] </p>\n<p id=\"so_29001446_29001648_2\">(1.3) \u2014 a string literal (2.13.5),</p>\n</blockquote>\n<p><code>s2</code> holds the address of a string literal, and so cannot be used as the parameter here. <code>s1</code> on the other hand is an array of <code>char</code> that has been <em>initialized</em> with a string literal, but the value of <code>s1</code> (when converted to <code>const char*</code>) doesn't point to the string literal used in the initialization.</p>\n<p>For 2.:</p>\n<p>Function pointers perhaps? Still I can't say I've ever used a pointer as a non-type parameter.</p>\n", "LastEditorUserId": "657267", "LastActivityDate": "2015-03-12T04:10:58.710", "Score": "4", "CreationDate": "2015-03-12T04:01:08.600", "ParentId": "29001446", "CommentCount": "4", "OwnerUserId": "657267", "LastEditDate": "2015-03-12T04:10:58.710"}, "29001694": {"Id": "29001694", "PostTypeId": "2", "Body": "<p>There's a recent change in the relevant standard text, but the code is acceptable in neither version of the standard.</p>\n<p>N4140 [temp.arg.nontype]/p1:</p>\n<blockquote>\n<p id=\"so_29001446_29001694_0\">1 A <em>template-argument</em> for a non-type, non-template\n  template-parameter shall be one of:</p>\n<ul>\n<li>for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the\n  <em>template-parameter</em>; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal\n  linkage or a function with external or internal linkage, including\n  function templates and function <em>template-ids</em> but excluding\n  non-static class members, expressed (ignoring parentheses) as <code>&amp; id-expression</code>,\n  where the <em>id-expression</em> is the name of an object or\n  function, except that the <code>&amp;</code> may be omitted if the name refers to a\n  function or array and shall be omitted if the corresponding\n  <em>template-parameter</em> is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1; or</li>\n<li>a constant expression of type <code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n<p>N4296 [temp.arg.nontype]/p1:</p>\n<blockquote>\n<p id=\"so_29001446_29001694_1\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a\n  converted constant expression (5.20) of the type of the\n  <em>template-parameter</em>. For a non-type <em>template-parameter</em> of reference or pointer type, the value of the constant expression shall not refer\n  to (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li>a subobject (1.8),</li>\n<li>a temporary object (12.2),</li>\n<li>a string literal (2.13.5),</li>\n<li>the result of a <code>typeid</code> expression (5.2.8), or</li>\n<li>a predefined <code>__func__</code> variable (8.4.1).</li>\n</ul>\n</blockquote>\n<p>The N4140 version is the one currently implemented by compilers. The N4296 version is somewhat more relaxed, but in neither case is the address of a string literal an acceptable template argument.</p>\n<p>Presumably part of the reason for this is that template arguments must be mangled, and mangling a string literal in a sane way that would work across multiple translation units would be very difficult, if not impossible.</p>\n", "LastActivityDate": "2015-03-12T04:06:39.303", "CommentCount": "0", "CreationDate": "2015-03-12T04:06:39.303", "ParentId": "29001446", "Score": "4", "OwnerUserId": "2756719"}, "29005089": {"Id": "29005089", "PostTypeId": "2", "Body": "<p>In a comment above, vsoftco adds:</p>\n<blockquote>\n<p id=\"so_29001446_29005089_0\">seems extremely weird, afaik string literals are not temporaries but are stored for the whole duration of the program, so their address is for sure a compile time constant (or at least that's what I believe)</p>\n</blockquote>\n<p>That's true. However, the standard doesn't specify whether string literals have <em>unique addresses</em>.</p>\n<p>Some linkers merge or deduplicate string literals. I have worked on systems where <code>\"ello\" == \"hello\"+1</code> actually evaluates to <code>true</code>. Other linkers are so dumb that <code>\"hello\"</code> in foo.cc has a different address from <code>\"hello\"</code> in bar.cc. Heck, some tiny C compilers are so dumb that <code>\"hello\"</code> can have two different addresses within the same translation unit!</p>\n<p>For such a dumb linker (or compiler), should <code>Foo&lt;\"hello\"&gt;</code> cause one instantiation or two? That is...</p>\n<pre><code>const char *sa = \"hello world\";\nconst char *sb = \"hello world\";\nassert(sa != sb);  // this assertion is permitted to succeed\n\ntemplate&lt;char*&gt; struct F {};\nF&lt;\"hello world\"&gt; fa;\nF&lt;\"hello world\"&gt; fb;\nassert(!is_same&lt;decltype(fa), decltype(fb)&gt;::value);\n    // should we permit this assertion to succeed also?\n</code></pre>\n<p>The Committee admirably refused to open that can of worms, by simply prohibiting the construct.</p>\n<hr>\n<p>Now, it's conceivable (to me, at the moment) that <strong>sometime in the future</strong> the Committee could mandate that all string literals be deduplicated by the same mechanism that implementations currently use for <code>inline</code> and <code>template</code> functions. That is, we can imagine a source-level transformation that turns</p>\n<pre><code>const char *sc = \"yoo hoo\";\n</code></pre>\n<p>into</p>\n<pre><code>inline auto&amp; __stringlit_yoo_x20hoo() {\n    static const char x[] = \"yoo hoo\";\n    return x;\n}\nconst char *sc = __stringlit_yoo_x20hoo();\n</code></pre>\n<p>Then there would be only a single instance of <code>__stringlit_yoo_x20hoo</code> (and only a single instance of that function's static array <code>x</code>) anywhere in the program, so the meaning of <code>F&lt;\"yoo hoo\"&gt;</code> would be unambiguous. The implementation would have to name-mangle the thing unambiguously as well, but that's a simple problem once you've already committed to name-mangling things like <code>F&lt;1+1&gt;</code> and <code>F&lt;FruitType,ORANGE&gt;</code> (which C++ compilers have been doing forever).</p>\n<p>...But then you would <strong>still</strong> have problems with those extremely smart linkers (like the one I worked on) that allow</p>\n<pre><code>assert(\"hello\" == \"hello\\0world\");  // this assertion is permitted to succeed\n\nassert(!is_same_v&lt; F&lt;\"hello\"&gt;, F&lt;\"hello\\0world\"&gt; &gt;);\n    // should we permit this assertion to succeed also?\n    // Surely this way lies madness.\n</code></pre>\n</hr>", "LastActivityDate": "2015-03-12T08:36:56.360", "CommentCount": "1", "CreationDate": "2015-03-12T08:36:56.360", "ParentId": "29001446", "Score": "6", "OwnerUserId": "1424877"}});