post_cb({"26532884": {"CommentCount": "3", "CreationDate": "2014-10-23T16:32:12.330", "PostTypeId": "1", "AcceptedAnswerId": "26533057", "LastEditorUserId": "828609", "LastActivityDate": "2014-10-23T23:04:00.880", "LastEditDate": "2014-10-23T23:04:00.880", "ViewCount": "872", "FavoriteCount": "2", "Title": "Why std::move is required to invoke move assign operator of std::vector", "Id": "26532884", "Score": "5", "Body": "<p>I am learning c++11 and i have a question regarding move semantics and rvalue references.\nMy sample code is as following (C++ Shell URL is <a href=\"http://cpp.sh/8gt\" rel=\"nofollow\">cpp.sh/8gt</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid aaa(std::vector&lt;int&gt;&amp;&amp; a)\n{\n    std::cout &lt;&lt; \"size of a before move: \" &lt;&lt; a.size() &lt;&lt; std::endl;\n    std::vector&lt;int&gt; v;\n    v = a; /*std::move(a)*/\n    std::cout &lt;&lt; \"size of a after move: \" &lt;&lt; a.size() &lt;&lt; std::endl;\n}\n\nint main ()\n{\n  std::vector&lt;int&gt; foo (3,0);\n\n  aaa(std::move(foo));\n\n  return 0;\n}\n</code></pre>\n<p>The result of the is:  </p>\n<blockquote id=\"so_26532884_26532884_0\">\n<pre><code>size of a before move: 3  \nsize of a after move: 3\n</code></pre>\n</blockquote>\n<p>It seems the move assign operator of std::vector is not invoked at line <code>v = a</code> in function <code>aaa</code>, otherwise <code>a</code> would have size 0 instead of 3.<br>\nHowever if i change <code>v = a</code> to <code>v = std::move(a)</code> the output became </br></p>\n<blockquote>\n<p id=\"so_26532884_26532884_1\">size of a before move: 3<br>\n   size of a after move: 0</br></p>\n</blockquote>\n<p>and I thinke the move assign operator of std::vector has been invoked this time.  </p>\n<p>My quesiton is why the assign operator is not invoked the first time? According to c++ reference std::vector has a assign operator which takes a rvalue reference. </p>\n<blockquote>\n<p id=\"so_26532884_26532884_2\">copy (1)  vector&amp; operator= (const vector&amp; x);<br>\n  move (2)    vector&amp; operator= (<strong>vector&amp;&amp; x</strong>);<br>\n  initializer list (3)    vector&amp; operator= (initializer_list il);  </br></br></p>\n</blockquote>\n<p>Then at line <code>v = a</code>, since a is declared as rvalue reference, the move operator should be invoked. Why we still need to wrap a with a std::move?</p>\n<p>Many thanks in advance! </p>\n<p><em>[edit]\nI think both Loopunroller and Kerrek SB answered my question. Thanks!\nI don't think I can choose two answers so I will just pick the first one.</em></p>\n", "Tags": "<c++><c++11><stdvector><move-semantics><rvalue-reference>", "OwnerUserId": "828609", "AnswerCount": "2"}, "26533057": {"ParentId": "26532884", "LastEditDate": "2014-10-23T16:45:56.213", "CommentCount": "0", "CreationDate": "2014-10-23T16:40:21.887", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "26533057", "Score": "9", "Body": "<p>This note from [expr]/6 might clarify what is going on (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26532884_26533057_0\">[ <em>Note:</em> An expression is an xvalue if it is: </p>\n<ul>\n<li>the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</li>\n<li>a cast to an rvalue reference to object type,<br/></li>\n<li>a class member access expression designating a non-static data member of non-reference type in which the object expression is an\n  xvalue, or<br/></li>\n<li>a <code>.*</code> pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.<br/></li>\n</ul>\n<p id=\"so_26532884_26533057_1\">In general, <strong>the effect of this rule is that named rvalue references\n  are treated as lvalues</strong> and unnamed rvalue references to objects are\n  treated as xvalues; rvalue references to functions are treated as\n  lvalues whether named or not. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>It is not hard to see that the expression <code>std::move(a)</code> is an xvalue according to the list above (bullet one).<br> <code>a</code> is the name of an rvalue reference, and thus an lvalue as an expression. </br></p>\n", "LastActivityDate": "2014-10-23T16:45:56.213"}, "26532932": {"ParentId": "26532884", "CommentCount": "4", "Body": "<p>The expression <code>a</code> is an lvalue. The expression <code>std::move(a)</code> is an rvalue. Only rvalues bind to rvalue references, which make up the move constructor and move assignment operator.</p>\n<p>It is worth repeating this to yourself until it makes sense: Evaluating any reference variable, and also dereferencing any dereferenceable pointer, produces an lvalue.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "26532932", "Score": "6", "CreationDate": "2014-10-23T16:35:10.550", "LastActivityDate": "2014-10-23T16:35:10.550"}, "bq_ids": {"n4140": {"so_26532884_26532884_1": {"section_id": 986, "quality": 0.6666666666666666, "length": 4}, "so_26532884_26533057_1": {"section_id": 5940, "quality": 0.9130434782608695, "length": 21}, "so_26532884_26532884_0": {"section_id": 986, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_26532884_26532884_1": {"section_id": 971, "quality": 0.6666666666666666, "length": 4}, "so_26532884_26533057_1": {"section_id": 5711, "quality": 0.9130434782608695, "length": 21}, "so_26532884_26532884_0": {"section_id": 971, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_26532884_26532884_1": {"section_id": 1049, "quality": 0.6666666666666666, "length": 4}, "so_26532884_26533057_1": {"section_id": 7424, "quality": 0.9130434782608695, "length": 21}, "so_26532884_26532884_0": {"section_id": 1049, "quality": 0.6666666666666666, "length": 4}}}});