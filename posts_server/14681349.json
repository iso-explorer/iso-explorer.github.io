post_cb({"14682009": {"ParentId": "14681349", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-02-04T07:17:50.913", "Score": "5", "LastEditorUserId": "560648", "LastEditDate": "2013-02-04T07:23:38.507", "Id": "14682009", "OwnerUserId": "560648", "Body": "<p>In a typical single-constructor inheritance scenario, it is UB to call a pure virtual function in the base constructor: </p>\n<blockquote>\n<p id=\"so_14681349_14682009_0\"><code>[C++11: 10.4/6]:</code> Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n<pre><code>struct Base\n{\n   Base()\n   {\n      foo();  // UB\n   }\n\n   virtual void foo() = 0;\n};\n\nstruct Derived : Base\n{\n   virtual void foo() {}\n};\n</code></pre>\n<p>There is no exemption here for such a call being made in a delegated constructor call, because at this point the more-derived part of the object still hasn't been constructed.</p>\n<pre><code>struct Base\n{\n   Base()\n   {\n      foo();  // still UB\n   }\n\n   Base(int) : Base() {};\n\n   virtual void foo() = 0;\n};\n\nstruct Derived : Base\n{\n   virtual void foo() {}\n};\n</code></pre>\n<p>Here's the Wikipedia passage that you cited:</p>\n<blockquote>\n<p id=\"so_14681349_14682009_1\">C++11 considers an object constructed once any constructor finishes execution. <strong>Since multiple constructors will be allowed to execute, this will mean that each delegate constructor will be executing on a fully constructed object of its own type. Derived class constructors will execute after all delegation in their base classes is complete.</strong></p>\n</blockquote>\n<p>The key is the <em>second</em> bolded sentence, rather than the first, as one may misconstrue from a quick glance.</p>\n<p><strong><em>However</em>, your posted code snippet is fine</strong>, and that's because the <em>derived</em> constructor body is undergoing execution, not the constructor for the abstract class, which has already been completely constructed. That said, the fact that you've had to ask for proof that it's safe should be some indication that this is not the most expressive or intuitive approach, and I would try to avoid it in your design.</p>\n", "LastActivityDate": "2013-02-04T07:23:38.507"}, "14682015": {"ParentId": "14681349", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-02-04T07:18:14.533", "Score": "8", "LastEditorUserId": "131930", "LastEditDate": "2013-02-04T07:29:16.833", "Id": "14682015", "OwnerUserId": "131930", "Body": "<p>With the updates, the example code looks okay to me, with the caveat that if you ever make a subclass of Derived, the subclass's override of Do() won't get called by Derived(const std::string &amp;), rather Derived::Do() will still get called; which might not be what you wanted.  In particular, when Initialize() is called from the Derived(const std::string &amp;) constructor, the object is still \"only\" a Derived object and not a SubDerived object yet (because the SubDerived layer of construction-code hasn't started yet) and that is why Derived::Do() would be called and not SubDerived::Do().</p>\n<p>Q:  What if the subclass uses the same delegation pattern to ensure everything is instantiate in the same way?</p>\n<p>A:  That would mostly work, but only if it's okay for Derived::Do() to be called before SubDerived::Do() is called.</p>\n<p>In particular, say you had class SubDerived that did the same things as Derived does above.  Then when the calling code did this:</p>\n<pre><code>SubDerived foo(\"Hello\");\n</code></pre>\n<p>the following sequence of calls would occur:</p>\n<pre><code>Base()\nDerived()\nDerived(const std::string &amp;)\n  Base::Initialize()\n    Derived::Do()\nSubDerived()\nSubDerived(const std::string &amp;)\n  Base::Initialize()\n    SubDerived::Do()\n</code></pre>\n<p>... so yes, SubDerived::Do() would eventually get called, but Derived::Do() would have been called also.  Whether or not that will be a problem depends on what the various Do() methods actually do.</p>\n<p>Some advice:  Calling virtual methods from within a constructor is usually not the best way to go.  You might want to consider simply requiring the calling code to call Do() manually on the object after the object is constructed.  It's a bit more work for the calling code, but the advantage is that it you can avoid the not-very-obvious-or-convenient semantics that come into play when doing virtual method calls on partially-constructed objects.</p>\n", "LastActivityDate": "2013-02-04T07:29:16.833"}, "14681349": {"CommentCount": "15", "CreationDate": "2013-02-04T06:18:10.257", "PostTypeId": "1", "AcceptedAnswerId": "14682015", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-04T19:05:02.000", "LastEditDate": "2017-05-23T12:33:58.123", "ViewCount": "3955", "FavoriteCount": "3", "Title": "C++ 11 Delegated Constructor Pure Virtual Method & Function Calls -- Dangers?", "Id": "14681349", "Score": "14", "Body": "<p><em>Not a Duplicate of <a href=\"https://stackoverflow.com/questions/8642363/invoking-virtual-function-and-pure-virtual-function-from-a-constructor\">Invoking virtual function and pure-virtual function from a constructor</a>:</em></p>\n<p><em>Former Question relates to C++ 03, not new Constructor Delegation behavior in C++ 11, and the question does not address the mitigation of undefined behavior by using delegation to ensure proper construction before pure virtual implementations are executed.</em></p>\n<p>In C++ 11, what are the dangers of invoking Pure Virtual functions in a class' constructor, during construction, but after the class/object has been \"fully constructed\" via constructor delegation?</p>\n<p>Apparently, somewhere in the C++ 11 spec such a constraint exists,</p>\n<blockquote>\n<p id=\"so_14681349_14681349_0\">Member functions (including virtual member functions, 10.3) can be\n  called for an object under construction.  Similarly, an object under\n  construction can be the operand of the typeid operator .. \n  - 12.6.2 #13 of the [C++ Working Draft] (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a>)\n  Can't find \"Fair Use\" version of Published Spec.</p>\n<p id=\"so_14681349_14681349_1\">C++11 considers an object constructed once any constructor finishes\n  execution. Since multiple constructors will be allowed to execute,\n  this will mean that each delegate constructor will be executing on a\n  fully constructed object of its own type. Derived class constructors\n  will execute after all delegation in their base classes is complete. \n  - <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11\" rel=\"nofollow noreferrer\">Wikipedia</a> saying that this is a C++ 11 thing.</p>\n</blockquote>\n<p>Actual C++ 11 Reference unknown.</p>\n<p>Following Example Compiles AND RUNS in Nov CTP of Visual Studio 2012 C++ Compiler:</p>\n<pre><code>#include &lt;string&gt;\n\n/**************************************/\nclass Base\n{\npublic:\n    int sum;\n    virtual int Do() = 0;\n\n    void Initialize()\n    {\n        Do();\n    }\n    Base()\n    {\n    }\n};\n\n/**************************************/\n// Optionally declare class as \"final\" to avoid\n// issues with further sub-derivations.\nclass Derived final : public Base\n{\npublic:\n\n    virtual int Do() override final\n    {\n        sum = 0 ? 1 : sum;\n        return sum / 2 ; // .5 if not already set.\n    }\n\n    Derived(const std::string &amp; test)\n        : Derived() // Ensure \"this\" object is constructed.\n    {\n        Initialize(); // Call Pure Virtual Method.\n    }\n    Derived()\n        : Base()\n    {\n        // Effectively Instantiating the Base Class.\n        // Then Instantiating This.\n        // The the target constructor completes.\n    }\n};\n\n\n\n\n/********************************************************************/\nint main(int args, char* argv[])\n{\n    Derived d;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><constructor><delegation><pure-virtual>", "OwnerUserId": "1981711", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14681349_14682009_0": {"section_id": 7023, "quality": 0.8928571428571429, "length": 25}, "so_14681349_14681349_0": {"section_id": 441, "quality": 0.6129032258064516, "length": 19}}, "n3337": {"so_14681349_14682009_0": {"section_id": 6769, "quality": 0.8928571428571429, "length": 25}, "so_14681349_14681349_0": {"section_id": 432, "quality": 0.6129032258064516, "length": 19}}, "n4659": {"so_14681349_14681349_0": {"section_id": 461, "quality": 0.6129032258064516, "length": 19}, "so_14681349_14682009_0": {"section_id": 8520, "quality": 0.8928571428571429, "length": 25}}}});