post_cb({"21611215": {"CommentCount": "11", "AcceptedAnswerId": "21811516", "PostTypeId": "1", "LastEditorUserId": "607084", "CreationDate": "2014-02-06T18:37:53.147", "LastActivityDate": "2014-02-16T16:06:35.130", "LastEditDate": "2014-02-16T11:33:24.397", "ViewCount": "325", "FavoriteCount": "2", "Title": "GCC bug? Chaining methods, broken sequence point", "Id": "21611215", "Score": "15", "Body": "<p>I've been debugging a program for some time, and eventually found the error was due to a reference not being updated as I thought it would be.</p>\n<p>Here's a example that shows the problem I encountered:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Test {\n    Test&amp; set(int&amp; i){ i = 10; return *this; }\n    Test&amp; print(const int&amp; i){ cout &lt;&lt; i &lt;&lt; endl; return *this; }\n};\n\nint main(void){\n    int i = 0;\n    Test t;\n\n    t.set(i).print(i + 5);\n\n    return 0;\n}\n</code></pre>\n<p>I had expected that the print() method here would output 15, but instead it outputs 5.</p>\n<p>EDIT: 10 days later I just realised that with clang it outputs 15! Is this a bug in GCC?</p>\n", "Tags": "<c++><gcc><compiler-bug>", "OwnerUserId": "607084", "AnswerCount": "3"}, "21811608": {"ParentId": "21611215", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-02-16T13:17:42.413", "Score": "0", "LastEditorUserId": "718379", "LastEditDate": "2014-02-16T14:22:23.297", "Id": "21811608", "OwnerUserId": "694576", "Body": "<p>[too long for a comment:]</p>\n<p>If adding</p>\n<pre><code>Test&amp; add(int&amp; i, const int toadd)\n{\n  i += toadd;\n  return *this;\n}\n</code></pre>\n<p>This call</p>\n<pre><code>t.set(i).add(i, 5).print(i);\n</code></pre>\n<p>returns</p>\n<pre><code>15\n</code></pre>\n<p>From this I conclude that the culprit is the  <code>i + 5</code> as parameter to print.</p>\n", "LastActivityDate": "2014-02-16T14:22:23.297"}, "21811516": {"ParentId": "21611215", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-02-16T13:09:36.663", "Score": "10", "LastEditorUserId": "2128694", "LastEditDate": "2014-02-16T16:06:35.130", "Id": "21811516", "OwnerUserId": "2128694", "Body": "<p>Let me try interpreting the C++11 standard on this. In \u00a71.9/15 it says:</p>\n<blockquote>\n<p id=\"so_21611215_21811516_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>Certainly <code>int</code> is an scalar type, and <code>t.set(i).print(i + 5);</code> contains a side effect on <code>i</code> in <code>set()</code> and the value computation <code>i + 5</code>, so if not noted otherwise, the behavior is indeed undefined. Reading \u00a75.2.5 (\"Class member access\"), I could not find any notes about sequences regarding the <code>.</code> operator. [But see edit below!]</p>\n<p>Note, however that it is of course guaranteed that <code>set()</code> is executed before <code>print()</code> because the latter receives the return value of the former as an (implicit <code>this</code>) argument.\nThe culprit here is that the value computation for <code>print</code>'s arguments is <del>unsequenced</del> indeterminately sequenced relative to the call of <code>set</code>.</p>\n<p>EDIT: After reading the answer in your (@Xeno's) comment, I reread the paragraph in the standard, and in fact it later says:</p>\n<blockquote>\n<p id=\"so_21611215_21811516_1\">Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.</p>\n</blockquote>\n<p>Because <em>indeterminately sequenced</em> is not <em>unsequenced</em> (\"execution of unsequenced evaluations can overlap\", \u00a71.9/13), this is indeed not undefined behavior, but \"just\" unspecified behavior, meaning that both 15 and 5 are correct outputs.</p>\n<p>So when <code>&lt;</code> means \"sequenced before\" and <code>~</code> means \"indeterminately sequenced\", we have:</p>\n<p><code>(value computations for print()'s arguments ~ execution of set()) &lt; execution of print()</code></p>\n", "LastActivityDate": "2014-02-16T16:06:35.130"}, "bq_ids": {"n4140": {"so_21611215_21811516_0": {"section_id": 5811, "quality": 1.0, "length": 33}, "so_21611215_21811516_1": {"section_id": 5811, "quality": 1.0, "length": 23}}, "n3337": {"so_21611215_21811516_0": {"section_id": 5584, "quality": 1.0, "length": 33}, "so_21611215_21811516_1": {"section_id": 5584, "quality": 1.0, "length": 23}}, "n4659": {"so_21611215_21811516_0": {"section_id": 7272, "quality": 0.8181818181818182, "length": 27}}}, "21810590": {"ParentId": "21611215", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-02-16T11:38:22.653", "Score": "2", "LastEditorUserId": "938694", "LastEditDate": "2014-02-16T14:05:03.083", "Id": "21810590", "OwnerUserId": "938694", "Body": "<p>There's no guarantee in C++ about the order in which function arguments in a single expression are evaluated, not even when these functions are chained method calls. You are invoking undefined behavior here and that's what you get.</p>\n<p>The . operator <em>does</em> imply sequencing, but only insofar that the expression before the . has to be fully evaluated before the member is accessed. It doesn't mean that the evaluations of subexpressions are suspended until that point.</p>\n<p>Also, don't pass <code>int</code>s by <code>const int&amp;</code>, there's no way this could be faster than passing an <code>int</code> directly (unless for some strange reason <code>int</code> doesn't fit into a processor word and the reference does).</p>\n", "LastActivityDate": "2014-02-16T14:05:03.083"}});