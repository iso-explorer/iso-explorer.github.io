post_cb({"4806510": {"CommentCount": "0", "CreationDate": "2011-01-26T15:44:28.350", "PostTypeId": "1", "AcceptedAnswerId": "4817981", "LastEditorUserId": "234513", "LastActivityDate": "2011-01-27T15:02:28.147", "LastEditDate": "2011-01-26T16:10:46.610", "ViewCount": "27574", "FavoriteCount": "7", "Title": "const variables in header file and static initialization fiasco", "Id": "4806510", "Score": "12", "Body": "<p>After reading a lot of the questions regarding initialization of static variables I am still not sure how this applies to <code>const</code> variables at namespace level.</p>\n<p>I have kind of the following code in a <em>header</em> file <code>config.h</code> generated by the build script:</p>\n<pre><code>static const std::string path1 = \"/xyz/abc\";\nstatic const std::string path2 = \"/etc\";\n</code></pre>\n<p>According to what I have read the <code>static</code> keyword is not necessary, even deprecated here.</p>\n<p><em>My Question:</em> Is the code above prone to the static initialization fiasco?</p>\n<p>If I have the following in a <em>header</em> file <code>myclass.h</code>:</p>\n<pre><code>class MyClass\n{\npublic:\n    MyClass(const std::string&amp; str) : m_str(str) {}\n    std::string Get() const { return m_str; }\n\nprivate:\n    std::string m_str;\n}\n\nconst MyClass myclass1(\"test\");\n</code></pre>\n<p>Will this pose any problems with static initialization?</p>\n<p>If I understood right, due to <code>const</code> variables having internal linkage there should be no problem in both cases?</p>\n<p><strong>Edit:</strong> (due to dribeas answer)</p>\n<p>Maybe I should mention that I am interested in use cases like:</p>\n<p>In <code>main.cpp</code>:</p>\n<pre><code>#include &lt;config.h&gt;\n#include &lt;myclass.h&gt;\n\nstd::string anotherString(path1 + myclass1.Get());\n\nint main()\n{\n    ...\n}\n</code></pre>\n<p>Another question regarding this use case: Will the compiler optimize away <code>path2</code> in this case?</p>\n", "Tags": "<c++><initialization><linkage>", "OwnerUserId": "234513", "AnswerCount": "4"}, "4806641": {"ParentId": "4806510", "CommentCount": "0", "Body": "<p>Static initialization fiasco refers to static variables that <em>depend on</em> each other. Merely defining some <code>static const</code> variables will not be a source of problems.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "4806641", "Score": "2", "CreationDate": "2011-01-26T15:55:35.220", "LastActivityDate": "2011-01-26T15:55:35.220"}, "4806614": {"ParentId": "4806510", "LastEditDate": "2011-01-26T17:08:21.610", "CommentCount": "3", "CreationDate": "2011-01-26T15:52:13.007", "OwnerUserId": "178761", "LastEditorUserId": "178761", "PostTypeId": "2", "Id": "4806614", "Score": "12", "Body": "<p>Your first definition places <code>path1</code> in each compilation unit that includes <code>config.h</code>. To avoid this, don't define variables in header files. Usually you'd declare the variables in the header as <code>extern</code>:</p>\n<pre><code>extern const std::string path1;\nextern const MyClass myclass1;\n</code></pre>\n<p>and define them in an implementation file, e.g. <code>config.cpp</code>:</p>\n<pre><code>const std::string path1 = \"/xyz/abc\";\nconst MyClass myclass1(\"test\");\n</code></pre>\n<p>Sometimes you need a constant variable that is usable only from one implementation file. Then you can declare that variable at file scope as <code>static</code>.</p>\n<pre><code>static const std::string path1 = \"/xyz/abc\";\n</code></pre>\n<p><code>static</code> is not deprecated any more. <code>static</code> and <code>extern</code> are sometimes implied, but I always forget where and how, so I usually specify them explicitly for all namespace-level variables.</p>\n", "LastActivityDate": "2011-01-26T17:08:21.610"}, "4817981": {"ParentId": "4806510", "CommentCount": "0", "Body": "<p>I tried to get the necessary information right from the C++03 Standard document. Here is what I found:</p>\n<p><strong>Regarding the <code>const static</code> declarations:</strong></p>\n<p>According to section 3.5.3 objects defined at namespace level and declared <code>const</code> have <em>internal linkage</em> by default. <code>static</code> also declares a namespace level object to have internal linkage so there is no need to declare an object <code>static const</code>.</p>\n<p>Also according to Annex D.2</p>\n<blockquote>\n<p id=\"so_4806510_4817981_0\">The use of the static keyword is\n  deprecated when declaring objects in\n  namespace scope (see 3.3.5).</p>\n</blockquote>\n<p><strong>Regarding the static initialization fiasco:</strong></p>\n<p>Since the variables are defined in a header file they are always defined before any other static objects using them.</p>\n<p>From section 3.6.2.1:</p>\n<blockquote>\n<p id=\"so_4806510_4817981_1\">Objects with static storage duration\n  defined in namespace scope in the same\n  translation unit and dynamically\n  initialized shall be initialized in\n  the order in which their definition\n  appears in the translation unit.</p>\n</blockquote>\n<p><strong>Answer 1:</strong> This means <em>passing</em> the variables to a static object constuctor should be fine.</p>\n<p><strong>Answer 2:</strong> However a problem could occur if the variables are referenced from a non-inline constructor of a static object:</p>\n<p>Neither in section 3.6.2.1 nor 3.6.2.3 is it specified in which order the static objects in different compilation units are initialized <em>if</em> dynamic initialization is done before the first statement of <code>main</code>.</p>\n<p>Consider the following:</p>\n<pre><code>// consts.h\n#include &lt;string&gt;\n\nconst std::string string1 = \"ham\";\nconst std::string string2 = \"cheese\";\n\n// myclass.h\n#include &lt;string&gt;\n\nclass MyClass\n{\npublic:\n    MyClass();\n    MyClass(std::string str);\n    std::string Get() { return memberString; }\nprivate:\n    std::string memberString;\n}\n\n// myclass.cpp\n#include \"consts.h\"\n#include \"myclass.h\"\n\nMyClass::MyClass() : memberString(string1) {}\n\nMyClass::MyClass(std::string str) : memberString(str) {}\n\n// main.cpp\n#include &lt;iostream&gt;\n#include \"consts.h\"\n#include \"myclass.h\"\n\nMyClass myObject1;\nMyClass myObject2(string2);\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; myObject1.Get(); // might not print \"ham\"\n    cout &lt;&lt; myObject2.Get(); // will always print \"cheese\"\n}\n</code></pre>\n<p>Since <code>myclass.cpp</code> has its own copy of the <code>const</code> variables, these might not be initialized when <code>MyClass::MyClass()</code> is called.</p>\n<p><strong>So yes, <code>const</code> variables defined in header files can be used in a way that is prone to the static initialization fiasco</strong></p>\n<p>As far as I can see this does only apply to variables not requiring static initialization:</p>\n<p>From C++03 standard, section 3.6.2.1:</p>\n<blockquote>\n<p id=\"so_4806510_4817981_2\">Objects of POD types (3.9) with static\n  storage duration initialized with\n  constant expressions (5.19) shall be\n  initialized before any dynamic\n  initialization takes place.</p>\n</blockquote>\n", "OwnerUserId": "234513", "PostTypeId": "2", "Id": "4817981", "Score": "9", "CreationDate": "2011-01-27T15:02:28.147", "LastActivityDate": "2011-01-27T15:02:28.147"}, "4806632": {"ParentId": "4806510", "CommentCount": "11", "Body": "<p>What is referred as the static initialization fiasco is a problem when one namespace level variable depends on the value assigned to a different namespace level variable that might or not be initialized before. In your two examples there is no such dependency and there should not be any problem.</p>\n<p>This, on the other hand, is prone to that type of error:</p>\n<pre><code>// header.h\nextern const std::string foo;\n\n// constant.cpp\nconst std::string foo( \"foo\" );\n\n// main.cpp\n#include \"header.h\"\nconst std::string foobar( foo+\"bar\" );\nint main() {\n   std::cout &lt;&lt; foobar &lt;&lt; std::endl;\n}\n</code></pre>\n<p>There is no guarantee that <code>foo</code> will be initialized before <code>foobar</code>, even if both are constant. That means that the program behavior is undefined and it could well print \"foobar\", \"bar\" or die.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "4806632", "Score": "8", "CreationDate": "2011-01-26T15:54:20.227", "LastActivityDate": "2011-01-26T15:54:20.227"}, "bq_ids": {"n4140": {"so_4806510_4817981_1": {"section_id": 7152, "quality": 0.5263157894736842, "length": 10}, "so_4806510_4817981_2": {"section_id": 7151, "quality": 0.6875, "length": 11}}, "n3337": {"so_4806510_4817981_1": {"section_id": 6896, "quality": 0.5263157894736842, "length": 10}, "so_4806510_4817981_2": {"section_id": 6895, "quality": 0.625, "length": 10}}, "n4659": {"so_4806510_4817981_2": {"section_id": 8652, "quality": 0.5625, "length": 9}}}});