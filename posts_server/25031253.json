post_cb({"bq_ids": {"n4140": {"so_25031253_25031961_0": {"length": 14, "quality": 1.0, "section_id": 7090}, "so_25031253_25031961_4": {"length": 7, "quality": 0.875, "section_id": 7070}, "so_25031253_25031961_5": {"length": 27, "quality": 0.9, "section_id": 7070}, "so_25031253_25031961_7": {"length": 11, "quality": 1.0, "section_id": 7070}, "so_25031253_25031961_6": {"length": 15, "quality": 1.0, "section_id": 7070}, "so_25031253_25031961_1": {"length": 19, "quality": 1.0, "section_id": 7091}, "so_25031253_25031961_2": {"length": 71, "quality": 0.9594594594594594, "section_id": 7093}}, "n3337": {"so_25031253_25031961_0": {"length": 14, "quality": 1.0, "section_id": 6834}, "so_25031253_25031961_4": {"length": 7, "quality": 0.875, "section_id": 6814}, "so_25031253_25031961_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 6814}, "so_25031253_25031961_7": {"length": 11, "quality": 1.0, "section_id": 6814}, "so_25031253_25031961_6": {"length": 15, "quality": 1.0, "section_id": 6814}, "so_25031253_25031961_1": {"length": 19, "quality": 1.0, "section_id": 6835}, "so_25031253_25031961_2": {"length": 71, "quality": 0.9594594594594594, "section_id": 6837}}, "n4659": {"so_25031253_25031961_2": {"length": 71, "quality": 0.9594594594594594, "section_id": 8594}, "so_25031253_25031961_0": {"length": 14, "quality": 1.0, "section_id": 8591}, "so_25031253_25031961_1": {"length": 19, "quality": 1.0, "section_id": 8592}, "so_25031253_25031961_6": {"length": 15, "quality": 1.0, "section_id": 8568}, "so_25031253_25031961_5": {"length": 27, "quality": 0.9, "section_id": 8567}}}, "25033041": {"Id": "25033041", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25031253_25033041_0\">\"<strong><em>why</em></strong> can I conduct a similar concept in a struct, but not get yelled at for it?\"</p>\n</blockquote>\n<p>In a <code>struct</code> or <code>class</code> definition you're <strong><em>presenting the public interface</em></strong> to a class and it's much easier to understand, search and maintain/update that API if it's presented in:</p>\n<ul>\n<li>a predictable order, with</li>\n<li>minimal clutter.</li>\n</ul>\n<p>For predictable order, people have their own styles and there's a bit of \"art\" involved, but for example I use each access specifier at most once and always <code>public</code> before <code>protected</code> before <code>private</code>, then within those I normally put <code>typedef</code>s, <code>const</code> data, constructors, destructors, mutating/non-const functions, <code>const</code> functions, <code>static</code>s, <code>friend</code>s....</p>\n<p>To minimise clutter, if a function is <em>defined</em> in the class, it might as well be without a prior declaration.  Having both tends only to obfuscate the interface.</p>\n<p>This is different from functions that aren't members of a class - where people who like top-down programming do use function declarations and hide the definitions later in the file - in that:</p>\n<ul>\n<li><p>people who prefer a bottom-up programming style won't appreciate being forced to either have separate declarations in classes or abandon the oft-conflicting practice of grouping by access specifier</p></li>\n<li><p>Classes are statistically more likely to have many very short functions, largely because they provide encapsulation and wrap a lot of trivial data member accesses or provide operator overloading, casting operators, implicit constructors and other convenience features that aren't relevant to non-OO, non-member functions.  That makes a constant forced separation of declarations and definitions more painful for many classes (not so much in the public interfaces where definitions might be in a separate file, but definitely for e.g. classes in anonymous namespaces supporting the current translation unit).</p></li>\n<li><p>Best practice is for classes not to cram in a wildly extensive interface... you generally want a functional core and then some discretionary convenience functions, after which it's worth considering what can be added as non-member functions.  The <code>std::string</code> is an often claimed to have too many member functions, though I personally think it's quite reasonable.  Still, this also differs from a header file declaring a library interface, where exhaustive functionality can be expected to be crammed together making a separation of even <code>inline</code> implementation more desirable.</p></li>\n</ul>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-07-31T08:21:23.053", "Score": "5", "CreationDate": "2014-07-30T09:19:55.797", "ParentId": "25031253", "CommentCount": "0", "LastEditDate": "2014-07-31T08:21:23.053", "OwnerUserId": "410767"}, "25031324": {"Id": "25031324", "PostTypeId": "2", "Body": "<p>A <code>struct</code> in C++ is actually a <code>class</code> definition where its content are <code>public</code>, unless specified otherwise by including a protected: or private: section.</p>\n<p>When the compiler sees a <code>class</code> or <code>struct</code>, it first digests all the declarations within the block (<code>{}</code>) before operating on them.</p>\n<p>In the regular method case, the compiler hasn't yet seen the type declared.</p>\n", "LastEditorUserId": "374746", "LastActivityDate": "2014-07-30T17:37:30.287", "Score": "15", "CreationDate": "2014-07-30T07:43:26.047", "ParentId": "25031253", "CommentCount": "4", "LastEditDate": "2014-07-30T17:37:30.287", "OwnerUserId": "797308"}, "25031961": {"Id": "25031961", "PostTypeId": "2", "Body": "<p>C++ standard 3.4.1:</p>\n<p>.4:</p>\n<blockquote>\n<p id=\"so_25031253_25031961_0\">A name used in global scope, outside of any function, class or\n  user-declared namespace, shall be declared before its use in global\n  scope.</p>\n</blockquote>\n<p>This is why global variables and functions cannot be used before an afore declaration.</p>\n<p>.5:</p>\n<blockquote>\n<p id=\"so_25031253_25031961_1\">A name used in a user-declared namespace outside of the definition of\n  any function or class shall be declared before its use in that\n  namespace or before its use in a namespace enclosing its namespace.</p>\n</blockquote>\n<p>same thing just written again as the .4 paragraph explictely restricted its saying to \"global\", this paragraph now says \"by the way, its true as well in namespeces folks...\"</p>\n<p>.7:</p>\n<blockquote>\n<p id=\"so_25031253_25031961_2\">A name used in the definition of a class X outside of a member\n  function body or nested class definition29 shall be declared in one of\n  the following ways: \u2014 before its use in class X or be a member of a\n  base class of X (10.2), or \u2014 if X is a nested class of class Y (9.7),\n  before the definition of X in Y, or shall be a member of a base class\n  of Y (this lookup applies in turn to Y \u2019s enclosing classes, starting\n  with the innermost enclosing class),30 or \u2014 if X is a local class\n  (9.8) or is a nested class of a local class, before the definition of\n  class X in a block enclosing the definition of class X, or \u2014 if X is a\n  member of namespace N, or is a nested class of a class that is a\n  member of N, or is a local class or a nested class within a local\n  class of a function that is a member of N, before the definition of\n  class X in namespace N or in one of N \u2019s enclosing namespaces.</p>\n</blockquote>\n<p>I think this speaks of all the code that does not stand in cpu executed code (eg declarative code).</p>\n<p>and finally the interesting part:</p>\n<blockquote>\n<p id=\"so_25031253_25031961_3\">3.3.7 Class scope [basic.scope.class]</p>\n<p id=\"so_25031253_25031961_4\">1 The following rules describe the scope of names declared in classes.</p>\n<p id=\"so_25031253_25031961_5\">1) The potential scope of a\n  name declared in a class consists not only of the declarative region\n  following the name\u2019s point of declaration, but also of all function\n  bodies, brace-or-equal-initializers of non-static data members, and\n  default arguments in that class (including such things in nested\n  classes).</p>\n<p id=\"so_25031253_25031961_6\">2) A name N used in a class S shall refer to the same\n  declaration in its context and when re-evaluated in the completed\n  scope of S. No diagnostic is required for a violation of this rule.</p>\n<p id=\"so_25031253_25031961_7\">3)\n  If reordering member declarations in a class yields an alternate valid\n  program under (1) and (2), the program is ill-formed, no diagnostic is\n  required.</p>\n</blockquote>\n<p>particularly, by the last point they use a negative manner to define that \"any ordering is possible\" because if re-ordering would change lookup then there is a problem. its a negative way of saying \"you can reorder anything and its ok, it doesnt change anything\".</p>\n<p>effectively saying, in a class, the declaration is looked-up in a two-phase compilation fashion.</p>\n", "LastEditorUserId": "893406", "LastActivityDate": "2014-07-30T09:04:06.903", "Score": "13", "CreationDate": "2014-07-30T08:22:17.903", "ParentId": "25031253", "CommentCount": "0", "LastEditDate": "2014-07-30T09:04:06.903", "OwnerUserId": "893406"}, "25031253": {"ViewCount": "1370", "Body": "<p>Take, for example, the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    print(\"Hello!\");\n}\n\nvoid print(std::string s) {\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n}\n</code></pre>\n<p>When trying to build this, I get the following:</p>\n<pre><code>program.cpp: In function \u2018int main()\u2019:\nprogram.cpp:6:16: error: \u2018print\u2019 was not declared in this scope\n</code></pre>\n<p>Which makes sense.</p>\n<p>So why can I conduct a similar concept in a struct, but not get yelled at for it?</p>\n<pre><code>struct Snake {\n    ...\n\n    Snake() {\n        ...\n        addBlock(Block(...));\n    }\n\n    void addBlock(Block block) {\n        ...\n    }\n\n    void update() {\n        ...\n    }\n\n} snake1;\n</code></pre>\n<p>Not only do I not get warnings, but the program actually compiles! Without error! Is this just the nature of structs? What's happening here? Clearly <code>addBlock(Block)</code> was called before the method was ever declared.</p>\n", "AcceptedAnswerId": "25031324", "Title": "Why don't methods of structs have to be declared in C++?", "CreationDate": "2014-07-30T07:40:15.107", "LastActivityDate": "2014-07-31T08:21:23.053", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "OwnerDisplayName": "user3835277", "Id": "25031253", "Score": "29", "Tags": "<c++><function><methods><struct><declare>", "AnswerCount": "3"}});