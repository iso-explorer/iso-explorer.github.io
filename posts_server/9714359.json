post_cb({"9721995": {"ParentId": "9714359", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I apologize if I miss an important point that is somehow implicit in the question and I don't see it. But, regarding this central line:</p>\n<pre><code>std::auto_ptr&lt;Base&gt; p(new((void*)(new char[size])) Packet());\n</code></pre>\n<p>This is what I think can be said about it:</p>\n<ol>\n<li><p>The constructor call at the end should be <code>Packet</code>, not <code>Packet()</code>, although in practice the compiler might accept it as is, and it might not make any difference</p></li>\n<li><p>The inner allocation <code>new char[size]</code> uses the array allocator <code>new []</code>. The <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow\">CPP reference</a> states about the expression <code>new [array_n]</code>:</p></li>\n</ol>\n<blockquote>\n<p id=\"so_9714359_9721995_0\">Note that more than size_of( type ) * array_n might be allocated because of additional information encoded by the compiler (such as the size of the array, since this information is needed in order to destruct the objects in the array properly).</p>\n</blockquote>\n<p>Now, the outer allocator call, <code>new ((void*)(...))</code>, is an instance of <em>placement new</em>, which is described <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow\">here</a> as follows:</p>\n<blockquote>\n<p id=\"so_9714359_9721995_1\"><code>void* operator new  ( std::size_t, void* ptr );</code> <strong>does nothing, returns ptr.</strong></p>\n</blockquote>\n<p>In other words, it <strong>may happen</strong> that the call to <code>new []</code> causes the compiler to <strong>allocate more memory than strictly required</strong> by the array and to <strong>encode size-related information</strong> in the extra space. However, since placement new does \"nothing\", it does not handle in any way or remove the extra information.</p>\n<p>But, since the use of <code>std::auto_ptr</code> implies that that <strong>deallocation</strong> will be carried out using <code>delete</code> (and <strong>not</strong> <code>delete []</code>), the extra information will not be properly deallocated, hence a memory leak or worse may result.</p>\n<p><strong>Edit:</strong> To avoid relying on the CPP reference only, the relevant parts of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">C++ Standard N3337</a> are as follows:</p>\n<ul>\n<li>\u00a7 18.6.1.2 states that only <code>delete</code> shall be used to deallocate space allocated by <code>new</code>, and correspondingly <code>delete []</code> for space allocated by <code>new []</code></li>\n<li>\u00a7 18.6.1.3 explicitly states that the placement forms of <code>new</code> and <code>new []</code> do not perform any action. This implies that neither can be used to \"transform\" single-object space into array space.</li>\n</ul>\n<p>Now perhaps the <strong>real question</strong> is whether the application of placement new proposed in the question would be valid if only <code>delete []</code> was used to deallocate the space later. Perhaps the answer is undefined (which should be interpreted as equivalent to a \"No\").</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-03-16T02:22:39.313", "Id": "9721995", "Score": "0", "CreationDate": "2012-03-15T14:37:09.863", "LastActivityDate": "2012-03-16T02:22:39.313"}, "9715259": {"ParentId": "9714359", "CommentCount": "0", "Body": "<p>No, this does not work: objects constructed with any form of <code>new</code> taken extra parameters other than <code>std::nothrow</code> need to be destroyed explicitly and the memory been taken care of separately:</p>\n<pre><code>void* memory = operator new(size);\nT* ptr = new(memory) T(args);\n...\nptr-&gt;~T();\noperator delete(memory);\n</code></pre>\n<p>Also note that the way to allocate raw memory is <strong>not</strong> something like <code>new char[size]</code>: this constructs <code>char</code> objects in the memory which need to be destroyed. I realize that neither construction nor destruction actually do anything on built-in types but I'm pretty an implementation is allowed to do something and there is no permission to skip these destructors as far as I know.</p>\n<p>Finally, note that you also need to construct the <code>int</code> objects and the implementation is allowed to put something after the apparent end of the structure.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "9715259", "Score": "1", "CreationDate": "2012-03-15T07:04:25.193", "LastActivityDate": "2012-03-15T07:04:25.193"}, "bq_ids": {"n4659": {"so_9714359_9721995_1": {"section_id": 8312, "quality": 0.6, "length": 6}}}, "9714359": {"CommentCount": "2", "ViewCount": "161", "LastEditDate": "2017-04-13T12:40:36.697", "LastEditorUserId": "-1", "CreationDate": "2012-03-15T05:16:12.797", "LastActivityDate": "2012-03-16T02:22:39.313", "PostTypeId": "1", "FavoriteCount": "1", "Title": "Placement new to get dynamic sizeing", "Id": "9714359", "OwnerUserId": "14065", "Body": "<p>Based on this question: <a href=\"https://codereview.stackexchange.com/questions/10034/variable-sized-type-allocation\">Variable size type allocation</a></p>\n<p>Will the following work?</p>\n<pre><code>{\n    // size calculated.\n    std::auto_ptr&lt;Base&gt; p(new((void*)(new char[size])) Packet());\n\n    // Do Stuff\n}\n</code></pre>\n<p>Where the Packet is POD struct where the last member is an array. The idea being to allow a dynamically sized array (like we used to do in C all those years ago)</p>\n<pre><code>struct Packet\n{\n    // STUFF\n    int  data[1];\n}\n</code></pre>\n", "Tags": "<c++><memory-management><placement-new><dynamic-sizing>", "Score": "0", "AnswerCount": "2"}});