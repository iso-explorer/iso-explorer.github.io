post_cb({"12320605": {"Id": "12320605", "PostTypeId": "2", "Body": "<p>To follow up with all good answers here this is good practice to declare a virtual destructor to ensure a proper clean-up when a class  is supposed to <strong>be subclassed to form a hierarchy</strong> and you want to delete the derived object through a pointer to it. The C++ standard is clear on this: </p>\n<blockquote>\n<p id=\"so_12320135_12320605_0\">when you want to delete a derived class object through a base class\n  pointer and the destructor of the base class is not virtual and the\n  result is undefined</p>\n</blockquote>\n<p>By undefined behavior you could think of memory leaks for example if your derived class allocate some dynamic memories and you try to delete it later on through this base class. Your teacher was probably thinking of this scenario.</p>\n", "LastActivityDate": "2012-09-07T14:59:13.340", "Score": "0", "CreationDate": "2012-09-07T14:59:13.340", "ParentId": "12320135", "CommentCount": "2", "OwnerUserId": "997084"}, "12320309": {"Id": "12320309", "PostTypeId": "2", "Body": "<p>Adding to the other answers: You could also envisage a situation where you do want a common base class, but you don't have any actual interface functions for it. But if you want RTTI and dynamic cast support, you need a virtual function in your class. A destructor can be just that function.</p>\n<p>For example, imagine you're a recovering Java programmer and insist that everything is an <code>Object</code>. You might start your first C++ program like so:</p>\n<pre><code>class Object\n{\npublic:\n   virtual ~Object() { }\n};\n</code></pre>\n<p>Now <code>Object</code> can indeed serve as the ultimate polymorphic base class of each of your classes.</p>\n<p><sub>If you also think that <code>Object</code> should be abstract, you can even make the destructor pure-virtual:</sub></p>\n<pre><code>class Object { public: virtual ~Object() = 0; }; Object::~Object() { }\n</code></pre>\n<p></p>\n", "LastActivityDate": "2012-09-07T14:41:27.587", "Score": "0", "CreationDate": "2012-09-07T14:41:27.587", "ParentId": "12320135", "CommentCount": "4", "OwnerUserId": "596781"}, "12320205": {"Id": "12320205", "PostTypeId": "2", "Body": "<p>If your class is intended to be used polymorphically, you'll likely have pointers to the base class that point to derived objects. </p>\n<p>Deleting a derived object through a pointer to a base class with no <code>virtual</code> destructor causes undefined behavior. That's probably her reasoning.</p>\n<h3>5.3.5</h3>\n<blockquote>\n<p id=\"so_12320135_12320205_0\">3) In the first alternative (delete object ), if the static type of\n  the operand is different from its dynamic type, the static type shall\n  be a base class of the operand\u2019s dynamic type and the static type\n  shall have a virtual destructor or the behavior is undefined. [...]</p>\n</blockquote>\n", "LastActivityDate": "2012-09-07T14:35:52.920", "Score": "5", "CreationDate": "2012-09-07T14:35:52.920", "ParentId": "12320135", "CommentCount": "0", "OwnerUserId": "673730"}, "12321748": {"Id": "12321748", "PostTypeId": "2", "Body": "<p>Within the standard, most inheritance hierarchies have a virtual destructor at their base; however, <code>sub_match</code> is defined to public inherit from <code>std::pair&lt;BidirectionalIterator, BidirectionalIterator&gt;</code> and as such it could own dynamically allocated memory.  In a related area, <code>match_results</code> is not required to but usually implemented to public inherit from <code>std::vector&lt;...&gt;</code> which definitely allocates memory.</p>\n<p>Your examiner is not entirely incorrect, but the focus on dynamically allocated memory is a red herring and betrays a worrying <em>ignorance</em> of the standard; while in most implementations deleting a derived type by a pointer to base type without virtual destructor will result in destructing a sliced object, per the standard it is undefined behaviour.</p>\n", "LastActivityDate": "2012-09-07T16:09:40.323", "Score": "1", "CreationDate": "2012-09-07T16:09:40.323", "ParentId": "12320135", "CommentCount": "1", "OwnerUserId": "567292"}, "bq_ids": {"n4140": {"so_12320135_12320205_0": {"length": 23, "quality": 0.92, "section_id": 6107}}, "n3337": {"so_12320135_12320205_0": {"length": 23, "quality": 0.92, "section_id": 5873}}, "n4659": {"so_12320135_12320205_0": {"length": 23, "quality": 0.92, "section_id": 7604}, "so_12320135_12320605_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 7527}}}, "12320135": {"ViewCount": "1559", "Body": "<p>This question looks like the discussion in <a href=\"https://stackoverflow.com/questions/2065938/virtual-destructor-is-it-required-when-not-dynamically-allocated-memory/12292952#12292952\">Virtual destructor: is it required when not dynamically allocated memory?</a></p>\n<p>In an exam question, I have been asked:\n- What should any base class that maintain pointers to dynamically allocated memory define?</p>\n<p>I answered:\n- A copy constructor and an assignment operator (to make sure NOT only pointers are copied... c.f. deep copy), and a destructor (to free allocated memory)</p>\n<p>They said this is not correct because this base class should also define a virtual destructor instead of the plain destructor. Why?</p>\n", "Title": "Virtual destructor: is it required in base class if base class allocated memory dynamically?", "CreationDate": "2012-09-07T14:30:44.103", "LastActivityDate": "2013-07-01T14:02:32.970", "CommentCount": "3", "LastEditDate": "2017-05-23T12:19:26.503", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "12320135", "Score": "0", "OwnerUserId": "1650782", "Tags": "<c++><virtual-destructor>", "AnswerCount": "6"}, "12320303": {"Id": "12320303", "PostTypeId": "2", "Body": "<p>They are not 100% correct. Virtual destructor is a must if</p>\n<ol>\n<li>class hierarchy used with dynamic polymorphism AND </li>\n<li>derived objects are destroyed via pointer to base.</li>\n</ol>\n<p>Otherwise non-virtual destructor is OK. But in most cases even if only #1 is intended it's a good style to make destructor virtual regardless of #2.</p>\n", "LastActivityDate": "2012-09-07T14:41:15.107", "Score": "4", "CreationDate": "2012-09-07T14:41:15.107", "ParentId": "12320135", "CommentCount": "0", "OwnerUserId": "1599260"}, "12320217": {"Id": "12320217", "PostTypeId": "2", "Body": "<p>Your base class needs a virtual destructor <strong>if</strong> objects of derived classes are intended to be destroyed via a base-class pointer, like so</p>\n<pre><code>Base *pointer_to_base_class = new Derived;\ndelete pointer_to_base_class;\n</code></pre>\n<p>From your question, it is unclear whether this is the case. Perhaps another part of the question (or a previous question) made clear that such polymorphic destruction was intended. Or, perhaps you were taught during the class to always anticipate such use as a best practice.</p>\n", "LastActivityDate": "2012-09-07T14:36:26.233", "Score": "5", "CreationDate": "2012-09-07T14:36:26.233", "ParentId": "12320135", "CommentCount": "2", "OwnerUserId": "8747"}});