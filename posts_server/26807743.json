post_cb({"bq_ids": {"n4140": {"so_26807743_26807798_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6019}}, "n3337": {"so_26807743_26807798_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5787}}, "n4659": {"so_26807743_26807798_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7518}}}, "26807795": {"Id": "26807795", "PostTypeId": "2", "Body": "<p>Yes you can do it by employing concepts of RTTI:-</p>\n<pre><code>#include &lt;typeinfo&gt;\n//Using for loop iterate through all elements\nif ( typeid(*iter) == typeid(Foo) )\n  //You got the Foo object\n</code></pre>\n<p>But that's almost never preferable in C++.</p>\n", "LastEditorUserId": "4047092", "LastActivityDate": "2014-11-07T18:41:13.970", "Score": "1", "CreationDate": "2014-11-07T18:32:43.130", "ParentId": "26807743", "CommentCount": "0", "LastEditDate": "2014-11-07T18:41:13.970", "OwnerUserId": "4047092"}, "26807798": {"Id": "26807798", "PostTypeId": "2", "Body": "<p>Yep:</p>\n<pre><code>Component* c = components[0];\nif (foo* f = dynamic_cast&lt;foo*&gt;(c)) {\n    // use f\n}\nelse {\n    // c is not a foo. Maybe it's a bar, or something else\n}\n</code></pre>\n<p>So if you want to write a function to <em>find</em> the <code>foo*</code>, you could do this (assuming C++11):</p>\n<pre><code>foo* find_foo(const std::vector&lt;Component*&gt;&amp; components)\n{\n    for (auto c : components) {\n        if (foo* f = dynamic_cast&lt;foo*&gt;(c)) {\n            return f;\n        }\n    }\n    return nullptr;\n}\n</code></pre>\n<p>The cast, <code>dynamic_cast&lt;foo*&gt;</code> will either return a valid <code>foo*</code> or <code>nullptr</code>, it <strong>will not</strong> throw. From the standard \u00a75.2.7.9:</p>\n<blockquote>\n<p id=\"so_26807743_26807798_0\">The value of a failed cast to pointer type is the null pointer value of the required result type.</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2014-11-07T18:38:45.887", "Score": "2", "CreationDate": "2014-11-07T18:33:05.547", "ParentId": "26807743", "CommentCount": "4", "LastEditDate": "2014-11-07T18:38:45.887", "OwnerUserId": "2069064"}, "26807743": {"ViewCount": "78", "Body": "<p>So i have a vector that holds pointers of a Component abstract class <br/> , and let's say i have 2 inherited classes from component , foo and bar , is there any way to get the pointer with type \"foo\" from this vector? <br/></p>\n<pre><code>    vector&lt;Component*&gt; components;\n    class foo : Component;\n    class bar : Component;\n    components.push_back(new foo());\n    components.push_back(new bar());\n</code></pre>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "26807798", "Title": "C++ : get inherited type from abstract pointer vector", "CreationDate": "2014-11-07T18:29:30.640", "Id": "26807743", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-11-07T18:41:13.970", "Score": "0", "OwnerUserId": "4204890", "Tags": "<c++><pointers><inheritance><vector>", "AnswerCount": "2"}});