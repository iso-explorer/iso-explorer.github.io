post_cb({"bq_ids": {"n4140": {"so_38107707_38109735_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 2727}, "so_38107707_38109735_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 2730}}, "n3337": {"so_38107707_38109735_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 2688}, "so_38107707_38109735_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 2691}}, "n4659": {"so_38107707_38109735_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 3466}, "so_38107707_38109735_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 3468}}}, "38109735": {"Id": "38109735", "PostTypeId": "2", "Body": "<p>Page 1121 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">Working Draft, Standard for Programming Language C++</a> from 2012-01-16 seems to state that once the main thread exits, its detached threads will be cleaned up as well (unless I'm misinterpreting it):</p>\n<blockquote>\n<p id=\"so_38107707_38109735_0\">void detach();</p>\n<p id=\"so_38107707_38109735_1\">Requires: joinable() is true.</p>\n<p id=\"so_38107707_38109735_2\">Effects: The thread represented by *this continues execution without the calling thread blocking. When detach() returns, *this no longer represents the possibly continuing thread of execution. When the thread previously represented by *this ends execution, the implementation shall release any owned resources.</p>\n<p id=\"so_38107707_38109735_3\">Postcondition: get_id() == id().</p>\n<p id=\"so_38107707_38109735_4\">Throws: system_error when an exception is required (30.2.2).</p>\n<p id=\"so_38107707_38109735_5\">Error conditions:</p>\n<p id=\"so_38107707_38109735_6\">\u2014 no_such_process \u2014 if the thread is not valid.</p>\n<p id=\"so_38107707_38109735_7\">\u2014 invalid_argument \u2014 if the thread is not joinable.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-29T20:46:08.653", "Score": "0", "CreationDate": "2016-06-29T20:46:08.653", "ParentId": "38107707", "CommentCount": "1", "OwnerUserId": "206543"}, "38107707": {"ViewCount": "290", "Body": "<p>Normally, when <code>main()</code> exits, all threads are killed.  <code>pthread_exit(3)</code> says</p>\n<blockquote>\n<p id=\"so_38107707_38107707_0\">To allow other threads to continue execution, the main thread should terminate by calling pthread_exit() rather than exit(3).</p>\n</blockquote>\n<p>Is there an equivalent C++11 API call?  Something like <code>std::this_thread::exit(0)</code>?</p>\n", "Title": "Do C++11 threads provide a way for detached threads to continue after the main thread exits?", "CreationDate": "2016-06-29T18:41:20.640", "LastActivityDate": "2016-07-13T10:13:03.620", "CommentCount": "4", "PostTypeId": "1", "Id": "38107707", "Score": "3", "OwnerUserId": "502399", "Tags": "<c++><multithreading><c++11><pthreads>", "AnswerCount": "2"}, "38109071": {"Id": "38109071", "PostTypeId": "2", "Body": "<p>Historically, the <code>main()</code> function has been special - it represents the lifetime of the application. C++11 does not change this.</p>\n<p>When the <code>main</code> function returns, the program cleans up and terminates. That's hard-coded into the C runtime.</p>\n<p>Anything that will prevent <code>main</code> from retuning normally will work (but there is no portable way to terminate a thread).</p>\n<p>A workaround in <em>your</em> case might be just to block the main thread forever, or re-use it to do some monitoring/housekeeping.</p>\n", "LastEditorUserId": "485343", "LastActivityDate": "2016-07-13T10:13:03.620", "Score": "0", "CreationDate": "2016-06-29T20:02:56.147", "ParentId": "38107707", "CommentCount": "0", "LastEditDate": "2016-07-13T10:13:03.620", "OwnerUserId": "485343"}});