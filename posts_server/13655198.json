post_cb({"13655374": {"ParentId": "13655198", "LastEditDate": "2012-12-01T02:51:30.993", "CommentCount": "0", "CreationDate": "2012-12-01T01:09:15.817", "OwnerUserId": "1594090", "LastEditorUserId": "1594090", "PostTypeId": "2", "Id": "13655374", "Score": "3", "Body": "<p>Using <code>= default</code> on a constructor or copy-constructor means that the compiler will generate that function for you during compile-time. This happens normally when you exclude the respective functions from your <code>class</code>/<code>struct</code>. And in the case where you define your own constructor, this new syntax allows you to explicitly tell the compiler to default-construct the constructor where it normally won't. Take for instance:</p>\n<pre><code>struct S {\n\n};\n\nint main() {\n\n    S s1; // 1\n    S s2(s1); // 2\n\n}\n</code></pre>\n<p>The compiler will generate both a copy-constructor and a default-constructor, thus allowing us to instantiate an <code>S</code> object like we did (1) and copy <code>s2</code> into <code>s1</code> (2). But if we define our own constructor, we find that we are unable to <em>instantiate</em> in the same way:</p>\n<pre><code>struct S {\n    S(int);\n};\n\nint main() {\n\n    S s;    // illegal\n    S s(5); // legal\n\n}\n</code></pre>\n<p>This fails because <code>S</code> has been given a custom-defined constructor, and the compiler won't generate the default one. But if we still want the compiler to give us one, we can <em>explicitly</em> convey this using <code>default</code>:</p>\n<pre><code>struct S {\n    S(int);\n    S() = default;\n    S(const S &amp;) = default;\n};\n\nint main() {\n\n    S s;     // legal\n    S s(5);  // legal\n\n    S s2(s); // legal\n\n}\n</code></pre>\n<p>Note, however, that only certain functions with certain function-signatures can be overloaded. It follows that this will fail because it is neither a copy-constructor nor a default-constructor or a move or assignment operator:</p>\n<pre><code>struct S {\n    S(int) = default; // error\n};\n</code></pre>\n<p>We are also able to explicitly define the assignment operator (just like the default/copy-constructor, a default one is generated for us when we do not write out our own). So take for example:</p>\n<pre><code>struct S {\n    int operator=(int) {\n        // do our own stuff\n    }\n};\n\nint main() {\n\n    S s;\n\n    s = 4;\n\n}\n</code></pre>\n<p>This compiles, but it won't work  for us in the general case where we want to assign another <code>S</code> object into <code>s</code>. This is because since we wrote our own, the compiler doesn't provide one for us. This is where <code>default</code> comes into play:</p>\n<pre><code>struct S {\n    int operator=(int) {\n        // do our own stuff\n    }\n\n    S &amp; operator=(const S &amp;) = default;\n};\n\nint main() {\n\n    S s1, s2;\n\n    s1 = s2; // legal\n\n}\n</code></pre>\n<p>But technically it's superfluous to define the assignment operator, copy, or move constructor as default when there is no other function \"overriding\" it as the compiler will provide one for you in that case anyway. The only case in which it <em>won't</em> provide you one is where you define your own one (or variation thereof). But as a matter of preference, asking the compiler to provide a default function using the new aforementioned syntax is more explicit and easier to see and understand if intentionally left out for the compiler.</p>\n", "LastActivityDate": "2012-12-01T02:51:30.993"}, "13655198": {"CreationDate": "2012-12-01T00:41:04.720", "CommentCount": "6", "ViewCount": "282", "PostTypeId": "1", "ClosedDate": "2012-12-01T06:15:17.807", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-01T02:51:30.993", "LastEditDate": "2017-05-23T12:12:23.590", "AcceptedAnswerId": "13655827", "FavoriteCount": "2", "Title": "What are defaulted methods and how do I use them properly?", "Id": "13655198", "Score": "10", "Body": "<blockquote>\n<p id=\"so_13655198_13655198_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/823935/whats-the-point-in-defaulting-functions-in-c11\">What\u2019s the point in defaulting functions in C++11?</a> </br></p>\n</blockquote>\n<p>C++11 introduced defaulted methods (e.g. <code>void myMethod() = default;</code>).</p>\n<p>What does it do to methods (how do methods behave after being <code>default</code>ed). How do I use them properly (what are its uses)?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1619294", "AnswerCount": "3"}, "13655252": {"ParentId": "13655198", "LastEditDate": "2012-12-01T02:09:58.117", "CommentCount": "4", "CreationDate": "2012-12-01T00:49:11.473", "OwnerUserId": "673730", "LastEditorUserId": "673730", "PostTypeId": "2", "Id": "13655252", "Score": "3", "Body": "<p>Actually, <code>default</code> can only apply to special methods - i.e. constructors, destructors, assignment operator:</p>\n<h3>8.4.2 Explicitly-defaulted functions [dcl.fct.def.default]</h3>\n<blockquote>\n<p id=\"so_13655198_13655252_0\">1 A function definition of the form:\n  <code>attribute-specifier-seqopt decl-specifier-seqopt declarator = default ;</code>\n  is called an explicitly-defaulted definition. A function that is explicitly defaulted shall<br/>\n  \u2014 be a special member function,<br/>\n  \u2014 have the same declared function type (except for possibly differing ref-qualifiers and except that in\n  the case of a copy constructor or copy assignment operator, the parameter type may be \u201creference to\n  non-const T\u201d, where T is the name of the member function\u2019s class) as if it had been implicitly declared,\n  and<br/>\n  \u2014 not have default arguments.</p>\n</blockquote>\n<p>They behave the same as if the compiler generated them and are useful for cases like:</p>\n<pre><code>class Foo{\n     Foo(int) {}\n};\n</code></pre>\n<p>here, the default constructor doesn't exist, so <code>Foo f;</code> wouldn't be valid. However, you can tell the compiler that you want a default constructor without the need to implement it yourself:</p>\n<pre><code>class Foo{\n     Foo() = default;\n     Foo(int) {}\n};\n</code></pre>\n<p>EDIT: Pointed out by @Nicol Bolas in the comments, this truly doesn't explain why you'd prefer this over <code>Foo() {}</code>. What I'm guessing is: if you have a class w/ implementations separated in an implementation file, your class definition (if you don't use <code>=default</code>) would look like:</p>\n<pre><code>class Foo{\n     Foo();\n     Foo(int);\n};\n</code></pre>\n<p>What I'm <em>assuming</em> is that the <code>=default</code> is meant to provide an idiomatic way of telling you \"we're not doing anything special in the constructor\". With the above class definition, the default constructor could very well not value-initialize the class members. With the <code>=default</code> you have that guarantee just by looking at the header.</p>\n", "LastActivityDate": "2012-12-01T02:09:58.117"}, "bq_ids": {"n4140": {"so_13655198_13655252_0": {"section_id": 3270, "quality": 0.9591836734693877, "length": 47}}, "n3337": {"so_13655198_13655252_0": {"section_id": 3142, "quality": 0.9591836734693877, "length": 47}}, "n4659": {"so_13655198_13655252_0": {"section_id": 4028, "quality": 0.9591836734693877, "length": 47}}}, "13655827": {"ParentId": "13655198", "LastEditDate": "2017-05-23T12:18:44.627", "CommentCount": "5", "CreationDate": "2012-12-01T02:38:11.677", "OwnerUserId": "734069", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "13655827", "Score": "4", "Body": "<p>There are a number of class members that are considered \"special member functions\" by the C++ standard. These are:</p>\n<ul>\n<li>The default constructor (a constructor that can be called with no parameters).</li>\n<li>The copy constructor (a constructor that can be called with one parameter that is the object type as an lvalue reference).</li>\n<li>The copy assignment operator (an operator= overload that can be called with one parameter that is the object type as either an lvalue reference or a value).</li>\n<li>The move constructor (a constructor that can be called with one parameter that is the object type as an rvalue reference).</li>\n<li>The move assignment operator (an operator= overload that can be called with one parameter that is the object type as either an rvalue reference or a value).</li>\n<li>The destructor.</li>\n</ul>\n<p>These member functions are special in that the language does special things with them on types. Another thing that makes them special is that the compiler can provide definitions for them if you do not. These are the only functions that you can use the <code>= default;</code> syntax on.</p>\n<p>The issue is that the compiler will only provide a definition <em>under certain conditions</em>. That is, there are conditions under which a definition will not be provided.</p>\n<p>I won't go over the entire list, but one example is what others have mentioned. If you provide a constructor for a type that is not a special constructor (ie: not one of the constructors mentioned above), a default constructor will <em>not</em> be automatically generated. Therefore, this type:</p>\n<pre><code>struct NoDefault\n{\n  NoDefault(float f);\n};\n</code></pre>\n<p><code>NoDefault</code> cannot be default constructed. Therefore, it cannot be used in any context where default construction is needed. You can't do <code>NoDefault()</code> to create a temporary. You can't <a href=\"http://ideone.com/WiVL8Z\" rel=\"nofollow noreferrer\">create arrays of <code>NoDefault</code></a> (since those are default constructed). You cannot create a <code>std::vector&lt;NoDefault&gt;</code> and <a href=\"http://ideone.com/gn4M0c\" rel=\"nofollow noreferrer\">call the sizing constructor without providing a value to copy from</a>, or any other operation that requires that the type be <code>DefaultConstructible</code>.</p>\n<p>However, you could do this:</p>\n<pre><code>struct UserDefault\n{\n  UserDefault() {}\n  UserDefault(float f);\n};\n</code></pre>\n<p>That would fix everything, right?</p>\n<p><strong><em>WRONG!</em></strong></p>\n<p>That is not the same thing as this:</p>\n<pre><code>struct StdDefault\n{\n  StdDefault() = default;\n  StdDefault(float f);\n};\n</code></pre>\n<p>Why? Because <code>StdDefault</code> is a <em>trivial</em> type. What does that mean? I won't explain the whole thing, but <a href=\"https://stackoverflow.com/a/7189821/734069\">go here for the details.</a> Making types trivial is often a useful feature to have, when you can do it.</p>\n<p>One of the requirements of a trivial type is that it does not have a user-provided default constructor. <code>UserDefault</code> has a provided one, even though it does the exact same thing as the compiler-generated one would. Therefore, <code>UserDefault</code> is not trivial. <code>StdDefault</code> is a trivial type because <code>= default</code> syntax means that the compiler will generate it. So it's not user-provided.</p>\n<p>The <code>= default</code> syntax tells the compiler, \"generate this function anyway, even if you normally wouldn't.\" This is important to ensure that a class is a trivial type, since you cannot actually implement special members the way the compiler can. It allows you to force the compiler to generate the function even when it wouldn't.</p>\n<p>This is very useful in many circumstances. For example:</p>\n<pre><code>class UniqueThing\n{\npublic:\n  UniqueThing() : m_ptr(new SomeType()) {}\n  UniqueThing(const UniqueThing &amp;ptr) : m_ptr(new SomeType(*ptr)) {}\n  UniqueThing &amp;operator =(const UniqueThing &amp;ptr)\n  {\n    m_ptr.reset(new SomeType(*ptr)); return *this;\n  }\n\nprivate:\n  std::unique_ptr&lt;SomeType&gt; m_ptr;\n};\n</code></pre>\n<p>We must write every one of these functions to make the class copy the contents of the unique_ptr; there's no way to avoid that. But we also want this to be moveable, and the move constructor/assignment operators won't automatically be generated for us. It'd silly to re-implement them (and error-prone if we add more members), so we can use the <code>= default</code> syntax:</p>\n<pre><code>class UniqueThing\n{\npublic:\n  UniqueThing() : m_ptr(new SomeType()) {}\n  UniqueThing(const UniqueThing &amp;ptr) : m_ptr(new SomeType(*ptr)) {}\n  UniqueThing(UniqueThing &amp;&amp;ptr) = default;\n  UniqueThing &amp;operator =(const UniqueThing &amp;ptr)\n  {\n    m_ptr.reset(new SomeType(*ptr)); return *this;\n  }\n\n  UniqueThing &amp;operator =(UniqueThing &amp;&amp;ptr) = default;\n\nprivate:\n  std::unique_ptr&lt;SomeType&gt; m_ptr;\n};\n</code></pre>\n", "LastActivityDate": "2012-12-01T02:44:01.870"}});