post_cb({"bq_ids": {"n4140": {"so_48061343_48061344_2": {"length": 51, "quality": 0.796875, "section_id": 5768}}, "n3337": {"so_48061343_48061344_2": {"length": 51, "quality": 0.796875, "section_id": 5541}}, "n4659": {"so_48061343_48061344_2": {"length": 59, "quality": 0.921875, "section_id": 7225}}}, "48061343": {"ViewCount": "1786", "Body": "<p>How can the following program be calling <code>never_called</code> if it's never\ncalled in code?</p>\n<pre><code>#include &lt;cstdio&gt;\n\nstatic void never_called()\n{\n  std::puts(\"formatting hard disk drive!\");\n}\n\nstatic void (*foo)() = nullptr;\n\nvoid set_foo()\n{\n  foo = never_called;\n}\n\nint main()\n{\n  foo();\n}\n</code></pre>\n<p>This differs from compiler to compiler. Compiling with Clang with\noptimizations on, the function <code>never_called</code> executes at runtime.</p>\n<pre><code>$ clang++ -std=c++17 -O3 a.cpp &amp;&amp; ./a.out\nformatting hard disk drive!\n</code></pre>\n<p>Compiling with GCC, however, this code just crashes:</p>\n<pre><code>$ g++ -std=c++17 -O3 a.cpp &amp;&amp; ./a.out\nSegmentation fault (core dumped)\n</code></pre>\n<p>Compilers version:</p>\n<pre><code>$ clang --version\nclang version 5.0.0 (tags/RELEASE_500/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n$ gcc --version\ngcc (GCC) 7.2.1 20171128\nCopyright (C) 2017 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n", "AcceptedAnswerId": "48061344", "Title": "Function not called in code gets called at runtime", "CreationDate": "2018-01-02T12:49:41.553", "LastActivityDate": "2018-03-03T11:53:15.880", "CommentCount": "2", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2018-01-02T20:13:09.810", "LastEditorUserId": "3646096", "Id": "48061343", "Score": "23", "OwnerUserId": "3646096", "Tags": "<c++><g++><compiler-optimization><undefined-behavior><clang++>", "AnswerCount": "2"}, "48070347": {"Id": "48070347", "PostTypeId": "2", "Body": "<p>Unless an implementation specifies the effect of trying to invoke a null function pointer, it could behave as a call to arbitrary code.  Such arbitrary code could perfectly well behave like a call to function \"foo()\".  While Annex L of the C Standard would invite implementations to distinguish between \"Critical UB\" and \"non-critical UB\", and some C++ implementations might apply a similar distinction, a invoking an invalid function pointer would be critical UB in any case.</p>\n<p>Note that the situation in this question is very different from e.g.</p>\n<pre><code>unsigned short q;\nunsigned hey(void)\n{\n  if (q &lt; 50000)\n    do_something();\n  return q*q;\n}\n</code></pre>\n<p>In the latter situation, a compiler which does not claim to be \"analyzable\" might recognize that code will invoke if q is greater than 46,340 when execution reaches the <code>return</code> statement, and thus it might as well invoke <code>do_something()</code> unconditionally.  While Annex L is badly written, it would seem the intention would be to forbid such \"optimizations\".  In the case of calling an invalid function pointer, however, even straightforwardly-generated code on most platforms might have arbitrary behavior.</p>\n", "LastActivityDate": "2018-01-03T02:19:33.430", "Score": "0", "CreationDate": "2018-01-03T02:19:33.430", "ParentId": "48061343", "CommentCount": "0", "OwnerUserId": "363751"}, "48061344": {"Id": "48061344", "PostTypeId": "2", "Body": "<p>The program contains undefined behavior, as dereferencing a null pointer\n(i.e. calling <code>foo()</code> in main without assigning a valid address to it\nbeforehand) is UB, therefore no requirements are imposed by the standard.</p>\n<p>Executing <code>never_called</code> at runtime is a perfect valid situation when\nundefined behavior has been hit, it's as valid as just crashing (like\nwhen compiled with GCC).  Okay, but why is Clang doing that? If you\ncompile it with optimizations off, the program will no longer output\n\"formatting hard disk drive\", and will just crash:</p>\n<pre><code>$ clang++ -std=c++17 -O0 a.cpp &amp;&amp; ./a.out\nSegmentation fault (core dumped)\n</code></pre>\n<p>The generated code for this version is as follows:</p>\n<pre><code>main:                                   # @main\n        push    rbp\n        mov     rbp, rsp\n        call    qword ptr [foo]\n        xor     eax, eax\n        pop     rbp\n        ret\n</code></pre>\n<p>It tries to make a call to a function to which <code>foo</code> points, and as <code>foo</code>\nis initialized with <code>nullptr</code> (or if it didn't have any initialization,\nthis would still be the case), its value is zero. Here, undefined\nbehavior has been hit, so anything can happen at all and the program\nis rendered useless.  Normally, making a call to such invalid address\nresults in segmentation fault errors, hence the message we get when\nexecuting the program.</p>\n<p>Now let's examine the same program but compiling it with optimizations on:</p>\n<pre><code>$ clang++ -std=c++17 -O3 a.cpp &amp;&amp; ./a.out\nformatting hard disk drive!\n</code></pre>\n<p>The generated code for this version is as follows:</p>\n<pre><code>set_foo():                            # @set_foo()\n        ret\nmain:                                   # @main\n        push    rax\n        mov     edi, .L.str\n        call    puts\n        xor     eax, eax\n        pop     rcx\n        ret\n.L.str:\n        .asciz  \"formatting hard disk drive!\"\n</code></pre>\n<p>Interestingly, somehow optimizations modified the program so that\n<code>main</code> calls <code>std::puts</code> directly. But why did Clang do that? And why is\n<code>set_foo</code> compiled to a single <code>ret</code> instruction?</p>\n<p>Let's get back to the standard (N4660, specifically) for a moment. What\ndoes it say about undefined behavior?</p>\n<blockquote>\n<p id=\"so_48061343_48061344_0\">3.27 undefined behavior <a href=\"http://eel.is/c++draft/defns.undefined\" rel=\"nofollow noreferrer\">[defns.undefined]</a></p>\n<p id=\"so_48061343_48061344_1\">behavior for which this document imposes no requirements</p>\n<p id=\"so_48061343_48061344_2\">[Note: <strong>Undefined behavior may be expected</strong> when this document omits\n  any explicit definition of behavior or <strong>when a program uses an erroneous\n  construct or erroneous data.</strong> Permissible undefined behavior ranges\n  from <strong>ignoring the situation completely</strong> with unpredictable results, to\n  <strong>behaving during translation</strong> or program execution in a documented manner\n  characteristic of the environment (with or without the issuance of a\n  diagnostic message), to terminating a translation or execution (with the\n  issuance of a diagnostic message).  Many erroneous program constructs\n  do not engender undefined behavior; they are required to be diagnosed.\n  Evaluation of a constant expression never exhibits behavior explicitly\n  specified as undefined ([expr.const]).  \u2014\u2009end note]</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>A program that exhibits undefined behavior becomes useless, as everything\nit has done so far and will do further has no meaning if it contains\nerroneous data or constructs. With that in mind, do remember that\ncompilers may completely ignore for the case when undefined behavior\nis hit, and this actually is used as discovered facts when optimizing a\nprogram. For instance, a construct like <code>x + 1 &gt; x</code> (where <code>x</code> is a signed integer) will be compiled to\ntrue, even if the value of <code>x</code> is unknown at compile-time. The reasoning\nis that the compiler wants to optimize for valid cases, and the only\nway for that construct to be valid is if it doesn't trigger arithmetic\noverflow (i.e. if <code>x != std::numeric_limits&lt;decltype(x)&gt;::max()</code>). This\nis a new learned fact in the optimizer. Based on that, the construct is\nproven to always be true.</p>\n<p><strong>Note</strong>: this same optimization can't occur for unsigned integers, because overflowing one is not UB. That is, the compiler needs to keep the expression as it is, because it might have a different evaluation when it overflows (unsigned is module 2<sup>N</sup>, where N is number of bits). Optimizing it away for unsigned integers would be incompliant with the standard (thanks aschepler.)</p>\n<p>This is useful as it allows for <a href=\"https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633/\" rel=\"nofollow noreferrer\">tons of optimizations to kick\nin</a>. So\nfar, so good, but what happens if <code>x</code> holds its maximum value at runtime?\nWell, that is undefined behavior, so it's nonsense to try to reason about\nit, as anything may happen and the standard imposes no requirements.</p>\n<p>Now we have enough information in order to better examine your faulty\nprogram. We already know that accessing a null pointer is undefined\nbehavior, and that's what's causing the funny behavior at runtime.\nSo let's try and understand why Clang (or technically LLVM) optimized\nthe program the way it did.</p>\n<pre><code>static void (*foo)() = nullptr;\n\nstatic void never_called()\n{\n  std::puts(\"formatting hard disk drive!\");\n}\n\nvoid set_foo()\n{\n  foo = never_called;\n}\n\nint main()\n{\n  foo();\n}\n</code></pre>\n<p>Remember that it's possible to call <code>set_foo</code> before the <code>main</code> entry\nstarts executing.  For example, when top-level declaring a variable,\nyou can call it while initializing the value of that variable:</p>\n<pre><code>void set_foo();\nint x = (set_foo(), 42);\n</code></pre>\n<p>If you write this snippet before <code>main</code>, the program no\nlonger exhibits undefined behavior, and the message <em>\"formatting hard\ndisk drive!\"</em> is displayed, with optimizations either on or off.</p>\n<p>So what's the only way this program is valid? There's this <code>set_foo</code>\nfunction that assigns the address of <code>never_called</code> to <code>foo</code>, so we might\nfind something here. Note that <code>foo</code> is marked as <code>static</code>, which means it\nhas internal linkage and can't be accessed from outside this translation\nunit. In contrast, the function <code>set_foo</code> has external linkage, and may\nbe accessed from outside. If another translation unit contains a snippet\nlike the one above, then this program becomes valid.</p>\n<p>Cool, but there's no one calling <code>set_foo</code> from outside. Even though this\nis the fact, the optimizer sees that the only way for this program to\nbe valid is if <code>set_foo</code> is called before <code>main</code>, otherwise it's\njust undefined behavior. That's a new learned fact, and it assumes <code>set_foo</code>\nis in fact called. Based on that new knowledge, other optimizations that\nkick in may take advantage of it.</p>\n<p>For instance, when <a href=\"https://en.wikipedia.org/wiki/Constant_folding\" rel=\"nofollow noreferrer\">constant\nfolding</a> is\napplied, it sees that the construct <code>foo()</code> is only valid if <code>foo</code> can be properly initialized. The only way for that to happen is if <code>set_foo</code> is called outside of this translation unit, so <code>foo = never_called</code>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Dead_code_elimination\" rel=\"nofollow noreferrer\">Dead code elimination</a> and <a href=\"https://en.wikipedia.org/wiki/Interprocedural_optimization\" rel=\"nofollow noreferrer\">interprocedural optimization</a> might find out that if <code>foo == never_called</code>, then the code inside <code>set_foo</code> is unneeded,\nso it's transformed into a single <code>ret</code> instruction.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Inline_expansion\" rel=\"nofollow noreferrer\">Inline expansion</a> optimization\nsees that <code>foo == never_called</code>, so the call to <code>foo</code> can be replaced\nwith its body. In the end, we end up with something like this:</p>\n<pre><code>set_foo():\n        ret\nmain:\n        mov     edi, .L.str\n        call    puts\n        xor     eax, eax\n        ret\n.L.str:\n        .asciz  \"formatting hard disk drive!\"\n</code></pre>\n<p>Which is somewhat equivalent to the output of Clang with optimizations on. Of course, what Clang really did can (and might) be different, but optimizations are nonetheless capable of reaching the same conclusion.</p>\n<p>Examining GCC's output with optimizations on, it seems it didn't bother investigating:</p>\n<pre><code>.LC0:\n        .string \"formatting hard disk drive!\"\nnever_called():\n        mov     edi, OFFSET FLAT:.LC0\n        jmp     puts\nset_foo():\n        mov     QWORD PTR foo[rip], OFFSET FLAT:never_called()\n        ret\nmain:\n        sub     rsp, 8\n        call    [QWORD PTR foo[rip]]\n        xor     eax, eax\n        add     rsp, 8\n        ret\n</code></pre>\n<p>Executing that program results in a crash (segmentation fault), but if you call <code>set_foo</code> in another translation unit before main gets executed, then this program doesn't exhibit undefined behavior anymore.</p>\n<p>All of this can change crazily as more and more optimizations are engineered, so do not rely on the assumption that your compiler will take care of code containing undefined behavior, it might just screw you up as well (and format your hard drive for real!)</p>\n<hr>\n<p>I recommend you read <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow noreferrer\">What every C programmer should know about Undefined Behavior</a> and <a href=\"https://blog.regehr.org/archives/213\" rel=\"nofollow noreferrer\">A Guide to Undefined Behavior in C and C++</a>, both article series are very informative and might help you out with understanding the state of art.</p>\n</hr>", "LastEditorUserId": "3646096", "LastActivityDate": "2018-03-03T11:53:15.880", "Score": "36", "CreationDate": "2018-01-02T12:49:41.553", "ParentId": "48061343", "CommentCount": "1", "OwnerUserId": "3646096", "LastEditDate": "2018-03-03T11:53:15.880"}});