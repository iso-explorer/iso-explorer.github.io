post_cb({"bq_ids": {"n4140": {"so_18933857_18934399_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 7088}, "so_18933857_18934399_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5510}}, "n3337": {"so_18933857_18934399_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 6832}, "so_18933857_18934399_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5296}}, "n4659": {"so_18933857_18934399_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 8589}, "so_18933857_18934399_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6945}}}, "18934399": {"Id": "18934399", "PostTypeId": "2", "Body": "<p>I'll change it slightly so the fall-back declaration of <code>bar</code> isn't a template (= shorter code), and don't use SFINAE as this is purely a name lookup issue.</p>\n<pre><code>namespace foo {\n    int bar(int);\n}\n\nnamespace feature_test {\n    namespace detail_overload {\n        void bar(...);\n    }\n\n    namespace detail {\n        using namespace detail_overload;\n        using namespace foo;\n\n        void test() { bar(0); } // (A)\n    }\n}\n</code></pre>\n<p>In line (A), the compiler needs to find the name <code>bar</code>. How is it looked up? It's not argument-dependent, so it must be unqualified lookup: [basic.lookup.unqual]/2</p>\n<blockquote>\n<p id=\"so_18933857_18934399_0\">The declarations from the namespace nominated by a <em>using-directive</em> become visible in a namespace enclosing the using-directive; see 7.3.4. For the purpose of the unqualified name lookup rules described in 3.4.1, the declarations from the namespace nominated by the <em>using-directive</em> are considered members of that enclosing namespace.</p>\n</blockquote>\n<p>Note they become in <strong>an enclosing</strong> namespace, not <strong>the</strong> enclosing namespace. The details from [namespace.udir]/2 reveal the issue:</p>\n<blockquote>\n<p id=\"so_18933857_18934399_1\">[...] During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains both the <em>using-directive</em> and the nominated namespace.</p>\n</blockquote>\n<p>That is, for the name lookup of <code>bar</code> inside <code>test</code>:</p>\n<pre><code>namespace foo {\n    int bar(int);\n}\n\n// as if\nusing foo::bar;\nnamespace feature_test {\n    namespace detail_overload {\n        void bar(...);\n    }\n\n    // as if\n    using detail_overload::bar;\n    namespace detail {\n        // resolved\n        // using namespace detail_overload;\n        // using namespace foo;\n\n        void test() { bar(0); } // (A)\n    }\n}\n</code></pre>\n<p>Therefore, the name <code>bar</code> found in <code>feature_test</code> hides the name (not) found in the global scope.</p>\n<p><em>Note:</em> Maybe you can hack around this issue with argument-dependent name lookup (and a second SFINAE). If something comes to my mind, I'll add it.</p>\n", "LastActivityDate": "2013-09-21T15:32:46.390", "Score": "3", "CreationDate": "2013-09-21T15:32:46.390", "ParentId": "18933857", "CommentCount": "2", "OwnerUserId": "420683"}, "18933857": {"ViewCount": "421", "Body": "<p>I want to check for the existence of a function in a specific namespace using SFINAE. I have found <a href=\"https://stackoverflow.com/questions/8756779/sfinae-to-test-a-free-function-from-another-namespace\">SFINAE to test a free function from another namespace</a> which does the job, but there are some things I don't understand.</p>\n<p>Currently I have this working code, straight from the linked question:</p>\n<pre><code>// switch to 0 to test the other case\n#define ENABLE_FOO_BAR 1\n\nnamespace foo {\n  #if ENABLE_FOO_BAR\n    int bar();\n  #endif\n}\n\nnamespace detail_overload {\n  template&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\n}\nnamespace detail {\n  using namespace detail_overload;\n  using namespace foo;\n  template&lt;typename T&gt; decltype(bar()) test(T);\n  template&lt;typename&gt; void test(...);\n}\nstatic constexpr bool has_foo_bar = std::is_same&lt;decltype(detail::test&lt;int&gt;(0)), int&gt;::value;\n\nstatic_assert(has_foo_bar == ENABLE_FOO_BAR, \"something went wrong\");\n</code></pre>\n<p>(the <code>ENABLE_FOO_BAR</code> macro is just for testing purpose, in my real code I don't have such a macro available otherwise I wouldn't be using SFINAE)</p>\n<hr>\n<p>However, as soon as I put <code>detail_overload::bar()</code> in any other namespace (adjusting the <code>using</code> directive as needed), the detection breaks silently and the <code>static_assert</code> kicks in <strong>when <code>foo::bar()</code> exists</strong>. It only works when the \"dummy\" <code>bar()</code> overload is directly in the global namespace, or part of the <code>::detail_overload</code> namespace (note the global <code>::</code> scope).</p>\n<pre><code>// breaks\nnamespace feature_test {\n  namespace detail_overload {\n    template&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\n  }\n  namespace detail {\n    using namespace detail_overload;\n    using namespace foo;\n    //...\n\n// breaks\nnamespace feature_test {\n  template&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\n  namespace detail {\n    using namespace foo;\n    //...\n\n// breaks\nnamespace detail {\n  namespace detail_overload {\n    template&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\n  }\n  using namespace detail_overload;\n  using namespace foo;\n  //...\n\n// works\ntemplate&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\nnamespace feature_test {\n  namespace detail {\n    using namespace foo;\n    //...\n\n// works\nnamespace detail_overload {\n  template&lt;typename... Args&gt; void bar(Args&amp;&amp;...);\n}\nnamespace feature_test {\n  namespace detail {\n    using namespace detail_overload;\n    using namespace foo;\n    //...\n</code></pre>\n<p>I realize this is the very same problem as the question I linked to, and as mentioned I already have a working solution, but what is not addressed there is <strong>why <em>precisely</em> does this happen?</strong></p>\n<p>As a side question, is there any way to achieve correct SFINAE detection without polluting the global namespace with either <code>bar()</code> or a <code>detail_overload</code> namespace? As you can guess from the non-working examples, I'd like to neatly wrap everything in a single <code>feature_test</code> namespace.</p>\n</hr>", "AcceptedAnswerId": "18934399", "Title": "SFINAE: checking the existence of a function breaks when the overload is moved to other namespaces", "CreationDate": "2013-09-21T14:35:25.480", "Id": "18933857", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:46:31.853", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-21T17:03:43.743", "Score": "4", "OwnerUserId": "2070725", "Tags": "<c++><c++11><namespaces><sfinae><overload-resolution>", "AnswerCount": "2"}, "18935155": {"Id": "18935155", "PostTypeId": "2", "Body": "<p>In addition to DyP's answer and following his comment:</p>\n<blockquote>\n<p id=\"so_18933857_18935155_0\">If your function <code>bar</code> took any arguments, you could make use of dependent name lookup to make it work (w/o a second overload of <code>bar</code>).</p>\n</blockquote>\n<p>Indeed in my real code <code>bar()</code> <em>does</em> take arguments.</p>\n<blockquote>\n<p id=\"so_18933857_18935155_1\">As a side question, is there any way to achieve correct SFINAE detection without polluting the global namespace...</p>\n</blockquote>\n<p>So yes, dependent name lookup works like a charm. For the sake of completeness, and in case it can help others in the future, here's my now perfectly working code:</p>\n<pre><code>#define ENABLE_FOO_BAR 1\n\nnamespace foo {\n  #if ENABLE_FOO_BAR\n    int bar(int);\n  #endif\n}\n\nnamespace feature_test {\n  namespace detail {\n    using namespace foo;\n    template&lt;typename T&gt; decltype(bar(std::declval&lt;T&gt;())) test(int);\n    template&lt;typename&gt; void test(...);\n  }\n  static constexpr bool has_foo_bar = std::is_same&lt;decltype(detail::test&lt;int&gt;(0)), int&gt;::value;\n  static_assert(has_foo_bar == ENABLE_FOO_BAR, \"something went wrong\");\n}\n</code></pre>\n<p>All credit goes to <a href=\"https://stackoverflow.com/users/420683/dyp\">DyP</a>, I don't believe I'd have thought about this by myself.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-21T17:03:43.743", "Score": "2", "CreationDate": "2013-09-21T16:53:19.003", "ParentId": "18933857", "CommentCount": "0", "LastEditDate": "2017-05-23T11:54:01.217", "OwnerUserId": "2070725"}});