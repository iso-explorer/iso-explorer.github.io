post_cb({"bq_ids": {"n4140": {"so_13870601_13870601_2": {"length": 9, "quality": 1.0, "section_id": 5573}, "so_13870601_13870601_5": {"length": 6, "quality": 0.6, "section_id": 5578}, "so_13870601_13870601_1": {"length": 7, "quality": 1.0, "section_id": 5573}}, "n3337": {"so_13870601_13870601_2": {"length": 9, "quality": 1.0, "section_id": 5355}, "so_13870601_13870601_5": {"length": 6, "quality": 0.6, "section_id": 5360}, "so_13870601_13870601_1": {"length": 7, "quality": 1.0, "section_id": 5355}}, "n4659": {"so_13870601_13870601_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7020}, "so_13870601_13870601_5": {"length": 6, "quality": 0.6, "section_id": 7025}, "so_13870601_13870601_1": {"length": 7, "quality": 1.0, "section_id": 7020}}}, "13870688": {"Id": "13870688", "PostTypeId": "2", "Body": "<p>Don't limit yourself by thinking about a \"conformant container\": there is nothing in the standard that depends on having one. Think of container requirements as a shorthand way of describing the requirements for the containers that are defined in the standard. Nothing more. As long as the iterators that your container produces are valid, you're fine with all the corresponding algorithms, and, presumably, with algorithms that you write yourself.</p>\n", "LastActivityDate": "2012-12-13T23:59:40.437", "CommentCount": "1", "CreationDate": "2012-12-13T23:59:40.437", "ParentId": "13870601", "Score": "2", "OwnerUserId": "1593860"}, "13870601": {"ViewCount": "324", "Body": "<p>I have more or less come to the conclusion that it is impossible to write a conformant container whose value_type was not stored directly in the container. I think this is unfortunate, because I frequently end up wishing I had containers where the value type is either partially computed or assembled from discontiguous pieces (examples below, but not directly relevant to the question). I know how to write iterators which use proxy objects, although it's pretty annoying. But I'm now wondering whether there really is space in the C++ standard for such beasts. There's probably too much verbiage here; the tl;dr version is simple: What do paragraphs 1 and 6 of \u00a724.2.5 really mean, and to what extent will violating the apparent meaning break standard algorithms? Or, to put it another way, how can they be interpreted to allow proxy iterators? </p>\n<p>As Pete Becker points out, there is really nothing forcing my containers to conform to requirements set out for standard library containers. But in order to use a container with many standard algorithms, it must either have a conformant iterator with at least a <code>forward_iterator_tag</code>, or it must lie about that but still manage to satisfy the operational (if not formal) requirements the particular algorithm imposes on its iterators.</p>\n<p>Here is my reasoning:</p>\n<p>Table 96 (\u00a7 23.2.1), container requirements, includes:</p>\n<pre><code>Expression     Return type         Assertion/note\n------------   -------------       ---------------------\nX::iterator    iterator type       any iterator category\n               whose value         that meets the\n               type is T           forward iterator\n                                   requirements.\n                                   Convertible to\n                                   const_iterator.\n\n a.begin()     iterator;\n               const_iterator for\n               constant a.\n</code></pre>\n<p>Now, forward iterator:</p>\n<blockquote>\n<p id=\"so_13870601_13870601_0\">\u00a7 24.2.5, para. 1:</p>\n<p id=\"so_13870601_13870601_1\">A class or pointer type <code>X</code> satisfies the requirements of a forward iterator if \u2026</p>\n<p id=\"so_13870601_13870601_2\">\u2014 if <code>X</code> is a mutable iterator, <code>reference</code> is a reference to <code>T</code>; if <code>X</code> is a const iterator, <code>reference</code> is a reference to <code>const T</code></p>\n</blockquote>\n<p>It's true that there is no direct requirement for <code>*a</code> to return <code>reference</code> (where <code>a</code> is of type <code>X</code>). The requirements are:</p>\n<blockquote>\n<p id=\"so_13870601_13870601_3\">from Table 107 (input iterators) <code>*a</code> must be \"convertible to T\" if <code>a</code> is dereferencable.</p>\n<p id=\"so_13870601_13870601_4\">from Table 106 (iterators) <code>*r</code> must have type <code>reference</code> where <code>r</code> is of type <code>X&amp;</code> and is dereferencable.</p>\n</blockquote>\n<p>However, Table 106 also specifies that <code>++r</code> returns <code>X&amp;</code>, so <code>*++r</code> must be <code>reference</code>. Also, (as per Table 107), <code>*a++</code> must be <code>reference</code>, although (Table 109) <code>a[n]</code> only needs to be \"convertible to reference\". I've got to say that I don't see how <code>*a</code> where <code>a</code> is of type <code>X</code> and <code>*r</code> where <code>r</code> is of type <code>X&amp;</code> could be different, but maybe I'm missing some subtlety.</p>\n<p>Maybe there is a little wiggle-room here, but not much; at some point, you need to be prepared to create a <code>T</code>, if you don't actually have one in the container, so that you can provide a reference to it.</p>\n<p>But the kicker is </p>\n<blockquote>\n<p id=\"so_13870601_13870601_5\">\u00a7 24.2.5, para. 6 (<code>a</code> and <code>b</code> are values of type <code>X</code>):\n  If <code>a</code> and <code>b</code> are both dereferenceable, then <code>a == b</code> if and only if <code>*a</code> and <code>*b</code> are bound to the same object.</p>\n</blockquote>\n<p>I can't find a formal definition of <code>bound to</code>, but it seems to me that the usual strategy for making iterators of non-addressable objects is to create a proxy object, generally stored inside the iterator itself. In this case, it would require an extremely generous understanding of what \"bound to\" means to interpret 24.2.5/6 in any way other than to forbid equality comparisons succeeding between two different iterator objects, even if they are logically indicating the same position in the container.</p>\n<p>On the other hand, I note that Dietmar K\u00fchl, who ought to know, in his response to <a href=\"https://stackoverflow.com/questions/13130708/what-is-the-advantage-of-using-universal-references-in-range-based-for-loops\">this question</a> says that:</p>\n<blockquote>\n<p id=\"so_13870601_13870601_6\">C++ 2011 got relaxed requirements and iterators aren't necessarily required to yield an lvalue</p>\n</blockquote>\n<p>So, can an iterator return a proxy, or can it not? If it can, what is the nature of such a proxy? Where does my reasoning that such an iterator is non-conformant fail?</p>\n<hr>\n<p>As promised, a few containers whose effective value_types would not be stored contiguously in the container:</p>\n<p>1) A compact associative container whose key and value types can be more efficiently stored in two separate vectors. (Keeping the keys in a vector can also improve cache-friendliness, as well as reducing allocation overhead.)</p>\n<p>2) A <code>vector&lt;T&gt;</code> which masquerades as a <code>map&lt;integer_type, T&gt;</code>, simplifying inter-operability with other <code>map&lt;X, T&gt;</code> types.</p>\n<p>3) A logical container formed by zipping several other containers, producing a logical value_type which is a <code>tuple</code> of references to the value types of the zipped containers. (In some applications, one or more of the zipped containers might be wholly computed, either as a function of the other values, or as a sequence number.)</p>\n<p>4) A view of a container of an aggregate type which has only some of the values. (Quite possibly, both the underlying container and the view are tuples where the view tuple's type list is a subset, possibly in a different order, of the underlying containers' types).</p>\n<p>I'm sure other people could easily add to this list; these are just the ones I've hacked around in some way or another in the past couple of months.</p>\n</hr>", "Title": "Can a container's iterator yield something other than an lvalue?", "CreationDate": "2012-12-13T23:50:06.943", "LastActivityDate": "2012-12-17T06:56:57.063", "CommentCount": "0", "LastEditDate": "2017-05-23T10:34:12.230", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "13870601", "Score": "8", "OwnerUserId": "1566221", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "13909151": {"Id": "13909151", "PostTypeId": "2", "Body": "<p>The best model is <code>std::vector&lt; bool &gt;</code>. It is as close to being compliant as possible, yet its iterators do yield proxies.</p>\n<p>The standard even specifies that <code>std::vector&lt;bool&gt;::reference</code> is a class. Yet the container requirements table specifies that <code>X::reference</code> yields \"lvalue of T.\" Thus is it strictly non-compliant.</p>\n<p>But the iterators aren't bound to <code>T</code>. The iterator <code>value_type</code> must be <code>T</code> and consulting the input iterator requirements, <code>reference</code> must convert to <code>value_type</code>.</p>\n<p>As Pete Becker mentions, the tables of requirements are rather broad blankets, and individual algorithms specify what they need. Only an algorithm that requires <code>reference</code> to really be a reference will break, which is kind of just stating the obvious.</p>\n", "LastActivityDate": "2012-12-17T06:10:15.117", "CommentCount": "6", "CreationDate": "2012-12-17T06:10:15.117", "ParentId": "13870601", "Score": "2", "OwnerUserId": "153285"}});