post_cb({"bq_ids": {"n4140": {"so_36439777_36440524_0": {"length": 18, "quality": 1.0, "section_id": 31}}, "n3337": {"so_36439777_36440524_0": {"length": 18, "quality": 1.0, "section_id": 28}}, "n4659": {"so_36439777_36440524_0": {"length": 18, "quality": 1.0, "section_id": 31}}}, "36440524": {"Id": "36440524", "PostTypeId": "2", "Body": "<p>This is <em>perfectly safe</em>:</p>\n<pre><code>small[3] = large;\n</code></pre>\n<p>and such a conversion is explicitly described in [conv.integral]:</p>\n<blockquote>\n<p id=\"so_36439777_36440524_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>That is, these four statements all are guaranteed to end up with the same value in <code>small[3]</code>:</p>\n<pre><code>small[3] = large;\nsmall[3] = large % 256;\nsmall[3] = large &amp; 255;\nsmall[3] = static_cast&lt;uint8_t&gt;(large);\n</code></pre>\n<p>there's no functional reason to do the <code>%</code> or <code>&amp;</code> or cast yourself, though if you want to anyway I would be surprised if the compiler didn't generate the same code for all four (gcc and clang do). </p>\n<p>The one difference would be if you compile with something like <code>-Wconversion</code>, which would cause this to issue a warning (which can sometimes be beneficial). In that case, you'll want to do the cast. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-04-06T03:19:42.697", "Score": "1", "CreationDate": "2016-04-06T02:39:37.620", "ParentId": "36439777", "CommentCount": "0", "LastEditDate": "2016-04-06T03:19:42.697", "OwnerUserId": "2069064"}, "36439777": {"ViewCount": "424", "Body": "<p>If I have a large int, say a uint64_t, and an array of uint8_t, e.g.:  </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>uint64_t large = 12345678901234567890;\nuint8_t small[5];\n</code></pre>\n<p>and I want to copy the 8 least significant bits of the <code>uint64_t</code> into an element of the array of <code>uint8_t</code>, is it safe to just use:  </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>small[3] = large;\n</code></pre>\n<p>or should I use a bit-mask:  </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>small[3] = large &amp; 255;\n</code></pre>\n<p>i.e. Is there any situation where the rest of the large int may somehow overflow into the other elements of the array?</p>\n", "AcceptedAnswerId": "36440524", "Title": "Should I use a bit mask when truncating uint64_t to uint8_t[i]?", "CreationDate": "2016-04-06T01:16:17.027", "Id": "36439777", "CommentCount": "4", "LastEditDate": "2016-04-06T01:24:19.133", "PostTypeId": "1", "LastEditorUserId": "1199684", "LastActivityDate": "2016-04-06T03:19:42.697", "Score": "7", "OwnerUserId": "4907604", "Tags": "<c++><arrays><int><type-conversion><bit-manipulation>", "AnswerCount": "2"}, "36439836": {"Id": "36439836", "PostTypeId": "2", "Body": "<p>It will most certainly not cause data to be processed incorrectly. However, some compilers may generate a warning message.</p>\n<p>There are two options to avoid these.</p>\n<p>You can cast your variable:</p>\n<pre><code>(uint8_t)large\n</code></pre>\n<p>Or you can disable the warning:</p>\n<pre><code>#pragma warning(disable:4503)\n</code></pre>\n<p>I would suggest <strong>casting</strong> the variable, because hiding compiler warnings will potentially keep you from spotting actual problems and is therefore not best practice.</p>\n", "LastEditorUserId": "4907604", "LastActivityDate": "2016-04-06T01:31:59.760", "Score": "4", "CreationDate": "2016-04-06T01:24:04.993", "ParentId": "36439777", "CommentCount": "3", "LastEditDate": "2016-04-06T01:31:59.760", "OwnerUserId": "1199684"}});