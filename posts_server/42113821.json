post_cb({"42113947": {"ParentId": "42113821", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>The problem is here:</p>\n<pre><code>int get() const&amp; {\n//            ^^^\n</code></pre>\n<p>Your member function is lvalue-reference qualified. In your <code>Apply()</code>:</p>\n<pre><code>template&lt;typename Func&gt;\nstd::result_of_t&lt;Func(X)&gt; Apply(Func fn) {\n    return fn(X{});\n}\n</code></pre>\n<p>you're invoking it with an rvalue. Which brings us to the [very surprising to me] difference between these two expressions:</p>\n<pre><code>X{}.get();        // ok\n(X{}.*&amp;X::get)(); // ill-formed\n</code></pre>\n<p>On <em>specifically</em> pointer-to-member operators, the ref-qualifiers of the member pointer are checked against the value category of the object. From [expr.mptr.oper]:</p>\n<blockquote>\n<p id=\"so_42113821_42113947_0\">In a <code>.*</code> expression whose object expression is an rvalue, the program is ill-formed if the second operand is a pointer to member function with <em>ref-qualifier</em> <code>&amp;</code>. In a <code>.*</code> expression whose object expression is an lvalue, the\n  program is ill-formed if the second operand is a pointer to member function with ref-qualifier <code>&amp;&amp;</code>.</p>\n</blockquote>\n<p>So the first expression is okay, <code>get()</code> is <code>const&amp;</code>-qualified but rvalues can bind to that. The second expression is not okay - the rules just explicitly prohibit it. </p>\n<p>So the behavior you see is perfectly correct - <code>mem_fn</code> is defined by directly invoking the member function, which is ill-formed on an rvalue, so <code>Apply</code> is removed from the overload set. If it were not, then instantiating the body would be a hard error. </p>\n<p>The reason the lambda works is that the temporary <code>X</code> is bound to the lambda's reference parameter. <code>get()</code> is then invoked on the lvalue function parameter - not on the temporary passed into it. But even without that, invoking <code>get()</code> directly on the temporary would still be fine. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-02-08T13:17:00.577", "Id": "42113947", "Score": "7", "CreationDate": "2017-02-08T13:03:50.227", "LastActivityDate": "2017-02-08T13:17:00.577"}, "bq_ids": {"n4140": {"so_42113821_42113947_0": {"section_id": 6133, "quality": 1.0, "length": 24}}, "n3337": {"so_42113821_42113947_0": {"section_id": 5897, "quality": 1.0, "length": 24}}, "n4659": {"so_42113821_42113947_0": {"section_id": 7630, "quality": 1.0, "length": 24}}}, "42113821": {"CommentCount": "0", "AcceptedAnswerId": "42113947", "PostTypeId": "1", "LastEditorUserId": "255688", "CreationDate": "2017-02-08T12:58:16.753", "LastActivityDate": "2017-02-08T13:57:05.203", "LastEditDate": "2017-02-08T13:57:05.203", "ViewCount": "149", "FavoriteCount": "1", "Title": "result_of does not define type for mem_fn", "Id": "42113821", "Score": "9", "Body": "<p>I have the following piece of code:</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct X {\n    int get() const&amp; {\n        return 42;\n    }\n};\n\ntemplate&lt;typename Func&gt;\nstd::result_of_t&lt;Func(X)&gt; Apply(Func fn) {\n    X x;\n    return fn(x);\n}\n\nint main(void) {\n    Apply([](X const&amp; x){return x.get();});\n    //Apply(std::mem_fn(&amp;X::get)); // does not compile\n}\n</code></pre>\n<p>The first call to <code>Apply</code> compiles fine, but if I uncomment the second call, I get the following compilation error:</p>\n<pre><code>main.cpp:16:5: error: no matching function for call to 'Apply'\n    Apply(std::mem_fn(&amp;X::get)); // does not compile\n    ^~~~~\nmain.cpp:10:27: note: candidate template ignored: substitution failure [with Func = std::_Mem_fn&lt;int (X::*)() const &amp;&gt;]: no type named 'type' in 'std::result_of&lt;std::_Mem_fn&lt;int (X::*)() const &amp;&gt; (X)&gt;'\nstd::result_of_t&lt;Func(X)&gt; Apply(Func fn) {\n                          ^\n</code></pre>\n<p>I somehow expected that both calls could be used interchangeably and that <code>std::mem_fn</code> just \"would do the right thing\". Can anybody explain, what happens here?</p>\n", "Tags": "<c++><c++14><member-function-pointers><result-of>", "OwnerUserId": "255688", "AnswerCount": "1"}});