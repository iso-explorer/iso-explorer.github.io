post_cb({"bq_ids": {"n4140": {"so_48105175_48105304_0": {"length": 19, "quality": 0.95, "section_id": 6064}}, "n3337": {"so_48105175_48105304_0": {"length": 19, "quality": 0.95, "section_id": 5832}}, "n4659": {"so_48105175_48105304_0": {"length": 18, "quality": 0.9, "section_id": 7560}}}, "48105175": {"ViewCount": "47", "Body": "<p>It is, as far as I have known, been a good rule that a pointer like argument type to a function should be a pointer if the argument can sensible be null and it should be a reference if the argument should never be null.</p>\n<p>Based on that \"rule\", I have naiively expected that doing something like \nsomeMethodTakingAnIntReference(*aNullPointer) would fail <em>when trying to make the call</em>, but to my surprise the following code is running just fine which kinda makes \"the rule\" less usable. A developer can still read meaning from the argument type being reference, but the compiler doesn't help and the location of the runtime error does not either.</p>\n<p>Am I misunderstanding the point of this rule, or is this undefined behavior, or...?</p>\n<pre><code>int test(int&amp; something1, int&amp; something2)\n{\n    return something2;\n}\n\nint main()\n{\n    int* i1 = nullptr;\n    int* i2 = new int{ 7 };\n\n    //this compiles and runs fine returning 7.\n    //I expected the *i1 to cause an error here where test is called\n    return test(*i1, *i2); \n}\n</code></pre>\n<p>While the above works, obviously the following does not, but the same would be true if the references were just pointers; meaning that the rule and the compiler is not really helping.</p>\n<pre><code>int test(int&amp; something1, int&amp; something2)\n{\n    return something1+something2;\n}\n\nint main()\n{\n    int* i1 = nullptr;\n    int* i2 = new int{ 7 };\n\n\n    //this compiles and runs returning 7.\n    //I expected the *i1 to cause an error here where test is called\n    return test(*i1, *i2); \n}\n</code></pre>\n", "Title": "Make argument a reference and not a pointer, if null is not a valid value", "CreationDate": "2018-01-04T23:41:25.817", "LastActivityDate": "2018-01-05T00:30:36.137", "CommentCount": "7", "PostTypeId": "1", "Id": "48105175", "Score": "0", "OwnerUserId": "1059762", "Tags": "<c++><pointers><reference>", "AnswerCount": "2"}, "48105304": {"Id": "48105304", "PostTypeId": "2", "Body": "<p>Writing <code>test(*i1, *i2)</code> causes <a href=\"https://stackoverflow.com/q/2397984/1505939\">undefined behaviour</a>; specifically the part <code>*i1</code>. This is covered in the C++ Standard by [expr.unary.op]/1:</p>\n<blockquote>\n<p id=\"so_48105175_48105304_0\">The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>This defines the behaviour of <code>*X</code> only for the case where <code>X</code> points to an object or function.  Since <code>i1</code>  does not point to an object or function, the standard does not define the behaviour of <code>*i1</code>, therefore it is undefined behaviour. (This is sometimes known as \"undefined by omission\", and this same practice handles many other uses of lvalues that don't designate objects).</p>\n<hr>\n<p>As described in the linked page, undefined behaviour does not necessitate any sort of diagnostic message. The runtime behaviour could literally be anything. The compiler <em>could</em>, but is not required to, generate a compilation warning or error.  In general, it's up to the programmer to comply with the rules of the language. The compiler helps out to some extent but it cannot cover all cases.</p>\n</hr>", "LastActivityDate": "2018-01-04T23:58:23.710", "CommentCount": "3", "CreationDate": "2018-01-04T23:58:23.710", "ParentId": "48105175", "Score": "1", "OwnerUserId": "1505939"}, "48105578": {"Id": "48105578", "PostTypeId": "2", "Body": "<p>You're better off thinking of references as little more than a handy notation for pointers.</p>\n<p>They are still pointers, and the runtime error occurs when you use (dereference) a null pointer, not when you pass it to a function.</p>\n<p>(An added advantage of references is that they can not be changed to reference something else, once initialized.)</p>\n", "LastActivityDate": "2018-01-05T00:30:36.137", "CommentCount": "3", "CreationDate": "2018-01-05T00:30:36.137", "ParentId": "48105175", "Score": "0", "OwnerUserId": "9125195"}});