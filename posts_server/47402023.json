post_cb({"47402114": {"ParentId": "47402023", "Score": "-2", "CreationDate": "2017-11-20T22:23:44.403", "LastActivityDate": "2017-11-21T10:59:09.913", "LastEditDate": "2017-11-21T10:59:09.913", "OwnerUserId": "4271923", "LastEditorUserId": "4271923", "Body": "<blockquote>\n<p id=\"so_47402023_47402114_0\">Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.</p>\n</blockquote>\n<p>I read that as: they are not allowed to use additional storage on top of the storage for the base of <code>std::optional</code>. But that <code>std::optional&lt;int&gt;</code> looks to be implemented as <code>struct { int value; byte has_value; };</code> and passed as reference (pointer) to the code (from the machine code point of view, it's \"pass by value\" in C++ terms, but the actual implementation for CPU is using one level of indirection any way), thus any access to the content needs indirection from that reference/pointer.</p>\n<p>But if you will set it from empty to value, or delete value, it will not change allocated storage, it will keep those 5 bytes of storage in any case (probably padded to 8).</p>\n<p>Your custom class does use 8 bytes of storage, working with it as whole <code>qword</code>, extracting the <code>has_value</code> and <code>value</code> by arithmetic (bit shifting and masking), looks to be somewhat better, can't think of particular disadvantage against the <code>std</code> variant in 15 seconds.</p>\n<p>And it's passed as value, not reference.</p>\n<hr>\n<p>That standard wording would be broken, if the storage of <code>std::optional&lt;int&gt;</code> would be only 4 bytes, and it would work itself as pointer to dynamically allocated memory, i.e. empty it would contain <code>nullptr</code>, and upon storing <code>int</code> value into it, it would allocated dynamic memory somewhere, and the original 4B storage would keep the pointer to the new memory.</p>\n</hr>", "Id": "47402114", "PostTypeId": "2", "CommentCount": "4"}, "47402023": {"Tags": "<c++><assembly><x86-64><c++1z><c++-standard-library>", "ViewCount": "84", "LastEditDate": "2017-11-20T22:28:33.543", "CreationDate": "2017-11-20T22:15:43.703", "LastEditorUserId": "547981", "Title": "Why does std::optional has pointer-like overhead?", "CommentCount": "0", "AnswerCount": "1", "Score": "0", "OwnerUserId": "2576930", "ClosedDate": "2017-11-20T22:27:33.803", "Id": "47402023", "LastActivityDate": "2017-11-21T10:59:09.913", "Body": "<h1>The problem</h1>\n<p>I have made some tests on <a href=\"https://gcc.godbolt.org/\" rel=\"nofollow noreferrer\">compiler-explorer</a> about <code>std::optional</code>, and  to my surprise, it seems like it behaves like a pointer, even though it is stated in the standard (<em>\u00a723.6.3</em>) that it should contain it:</p>\n<blockquote>\n<p id=\"so_47402023_47402023_0\">Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.</p>\n</blockquote>\n<h1>The tests</h1>\n<p>The full code I tested is on this compiler-explorer <a href=\"https://godbolt.org/g/4CENGw\" rel=\"nofollow noreferrer\">sheet</a>, although I don't know how much time it will remain up. That is why I will describe here the tests I made.</p>\n<h2>What I am testing</h2>\n<p>I am making two tests with one function each:</p>\n<ul>\n<li>Checking if the value is there</li>\n<li>Checking if the value is there and retrieval of it if it is there, or 67780 otherwise</li>\n</ul>\n<p>I used <code>-O2</code> minimum and <code>--std=c++17</code> as compiler flags for both gcc 7.2 and clang 5.0.0 on for the x86_64 target. The results copied here are from clang.</p>\n<h2>Using <code>std::optional</code></h2>\n<h3>Checking</h3>\n<p>Code:</p>\n<pre><code>bool check(const std::optional&lt;int&gt; maybe_int) {\n    return maybe_int.has_value();\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>mov al, byte ptr [rdi + 4]\nret\n</code></pre>\n<p>One indirection.</p>\n<h3>Retrieving</h3>\n<p>Code:</p>\n<pre><code>int retrieve(const std::optional&lt;int&gt; maybe_int) {\n    if(maybe_int.has_value())\n        return maybe_int.value();\n    else\n        return 67780;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>cmp byte ptr [rdi + 4], 0\nje .LBB1_1\nmov eax, dword ptr [rdi]\nret\n.LBB1_1:\nmov eax, 67780\nret\n</code></pre>\n<p>One indirection for checking, one for retrieving.</p>\n<h2>Using a custom class</h2>\n<h3>The class</h3>\n<pre><code>template&lt;typename T&gt;\nclass my_optional {\nprivate:\n    T val;\n    bool has_val;\npublic:\n    /* Constuctors ... */\n\n    bool has_value() const {\n        return has_val;\n    }\n    decltype(auto) value() const {\n        return val;\n    }\n};\n</code></pre>\n<h3>Checking</h3>\n<p>Code:</p>\n<pre><code>bool check(const my_optional&lt;int&gt; maybe_int) {\n    return maybe_int.has_value();\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>shr rdi, 32\ntest dil, dil\nsetne al\nret\n</code></pre>\n<p>No indirections.</p>\n<h3>Retrieving</h3>\n<p>Code:</p>\n<pre><code>int retrieve(const my_optional&lt;int&gt; maybe_int) {\n    if(maybe_int.has_value())\n        return maybe_int.value();\n    else\n        return 67780;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>movabs rax, 1095216660480\ntest rdi, rax\nmov eax, 67780\ncmovne eax, edi\nret\n</code></pre>\n<p>Although I don't know how that works, it does not have any indirections.</p>\n<h1>The questions</h1>\n<p>Either the title or \"<em>What is wrong with my tests ?</em>\"</p>\n", "PostTypeId": "1"}, "bq_ids": {"n4659": {"so_47402023_47402023_0": {"length": 12, "section_id": 5016, "quality": 1.0}, "so_47402023_47402114_0": {"length": 12, "section_id": 5016, "quality": 1.0}}}});