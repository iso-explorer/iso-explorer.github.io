post_cb({"46123867": {"CommentCount": "9", "ViewCount": "195", "CreationDate": "2017-09-08T20:09:00.983", "LastActivityDate": "2017-09-08T21:07:54.253", "Title": "Struct offsets and pointer safety in C++", "PostTypeId": "1", "Id": "46123867", "Score": "5", "Body": "<p>This question is about pointers derived using pointer arithmetic with struct offsets.</p>\n<p>Consider the following program:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n#include &lt;new&gt;\n\nstruct A {\n  float a;\n  double b;\n  int c;\n};\n\nstatic constexpr auto off_c = offsetof(A, c);\n\nint main() {\n  A * a = new A{0.0f, 0.0, 5};\n  char * a_storage = reinterpret_cast&lt;char *&gt;(a);\n  int * c = reinterpret_cast&lt;int *&gt;(a_storage + off_c));\n\n  std::cout &lt;&lt; *c &lt;&lt; std::endl;\n\n  delete a;\n}\n</code></pre>\n<p>This program appears to work and give expected results on compilers that I tested, using default settings and C++11 standard.</p>\n<p>(A closely related program, where we use <code>void *</code> instead of <code>char *</code> and <code>static_cast</code> instead of <code>reinterpret_cast</code>,\nis not universally accepted. <code>gcc 5.4</code> issues a warning about pointer arithmetic with void pointers, and <code>clang 6.0</code> says that pointer\narithmetic with <code>void *</code> is an error.)</p>\n<p>Does this program have well-defined behavior according to the C++ standard?</p>\n<p>Does the answer depend on whether the implementation has relaxed or strict pointer safety (<code>[basic.stc.dynamic.safety]</code>)?</p>\n", "Tags": "<c++><c++11><pointers><language-lawyer><offsetof>", "OwnerUserId": "3598119", "AnswerCount": "3"}, "46124019": {"ParentId": "46123867", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is safe in your specific example, but only because your struct is a <strong>standard layout</strong>, which you can double-check using <code>std::is_standard_layout&lt;&gt;</code>.</p>\n<p>Trying to apply this to a struct such as:</p>\n<pre><code>struct A {\n  float a;\n  double b;\n  int c;\n  std::string str;\n};\n</code></pre>\n<p>Would be illegal, even if the string is past the part of the struct that's relevant.</p>\n<p><strong>Edit</strong> </p>\n<blockquote>\n<p id=\"so_46123867_46124019_0\">Heres what im concerned abt: in 3.7.4.3 [basic.stc.dynamic.safety] it says pointer is safely derived only if (conditions) and if we have strict pointer safety then a pointer is invalid if it doesnt come from such a place. In 5.7 pointer arithmetic, it says i can do usual arithmetic within an array but i dont see anything there telling me struct offset arithmetic is ok. Im trying to figure out if this isnt relevant in the way i think it is, or if struct offset arithmetic is not ok in the hypothetical \"strict\" impls, or if i read 5.7 wrong (n4296)</p>\n</blockquote>\n<p>When you are doing the pointer arithmatic, you are performing it on an array of <code>char</code>, the size of which is at least <code>sizeof(A)</code>, so that's fine.</p>\n<p>Then, when you cast back into the second member, you are covered under (2.4):</p>\n<blockquote>\n<p id=\"so_46123867_46124019_1\">\u2014 the result of a well-defined pointer conversion (4.10, 5.4) of a safely-derived pointer value;</p>\n</blockquote>\n", "OwnerUserId": "4442671", "LastEditorUserId": "4442671", "LastEditDate": "2017-09-08T21:06:05.590", "Id": "46124019", "Score": "3", "CreationDate": "2017-09-08T20:22:43.100", "LastActivityDate": "2017-09-08T21:06:05.590"}, "46124041": {"ParentId": "46123867", "CommentCount": "2", "Body": "<p>you should examine your assumptions.</p>\n<p>Assumption #1) offsetof gives the correct offset in bytes. This is only guaranteed if the class is considered \"standard-layout\", which has a number of restrictions, such as no virtual methods, avoids multiple inheritances, etc. In this case, it should be fine, but in general you can't be sure.</p>\n<p>Assumption #2) A char is the same size as a byte. In C, this is by definition, so you are safe.</p>\n<p>Assumption #3) The offsetof gives the correct offset from the pointer to the class, not from the beginning of the data. This is basically the same as #1, but a vtable could certainly be a problem. Again, only works with standard-layout.</p>\n", "OwnerUserId": "3991211", "PostTypeId": "2", "Id": "46124041", "Score": "1", "CreationDate": "2017-09-08T20:24:53.467", "LastActivityDate": "2017-09-08T20:24:53.467"}, "46124016": {"ParentId": "46123867", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>There are no fundamental errors in your code.</p>\n<p>If <code>A</code> isn't plain old data, the above is UB (prior to C++17) and conditionally supported (after C++17).</p>\n<p>You might want to replace <code>char*</code> and <code>int*</code> with <code>auto*</code>, but that is a style thing.</p>\n<p>Note that pointers to members do this exact same thing in a type-safe manner.  Most compilers implement a pointer to member ... as the offset of the member in the type.  They do, however, work everywhere even on non-pod structures.</p>\n<p>Aside: I don't see a guarantee that <code>offsetof</code> is <code>constexpr</code> in the standard.  ;)</p>\n<p>In any case, replace:</p>\n<pre><code>static constexpr auto off_c = offsetof(A, c);\n</code></pre>\n<p>with</p>\n<pre><code>static constexpr auto off_c = &amp;A::c;\n</code></pre>\n<p>and</p>\n<pre><code>  auto* a_storage = static_cast&lt;char *&gt;(a);\n  auto* c = reinterpret_cast&lt;int *&gt;(a_storage + off_c));\n</code></pre>\n<p>with</p>\n<pre><code>  auto* c = &amp;(a-&gt;*off_c);\n</code></pre>\n<p>to do it the C++ way.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-09-08T21:07:54.253", "Id": "46124016", "Score": "8", "CreationDate": "2017-09-08T20:22:34.690", "LastActivityDate": "2017-09-08T21:07:54.253"}, "bq_ids": {"n4140": {"so_46123867_46124019_1": {"section_id": 7185, "quality": 0.875, "length": 7}}, "n3337": {"so_46123867_46124019_1": {"section_id": 6929, "quality": 0.875, "length": 7}}, "n4659": {"so_46123867_46124019_1": {"section_id": 8693, "quality": 0.875, "length": 7}}}});