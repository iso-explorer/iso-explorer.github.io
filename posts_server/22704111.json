post_cb({"22704165": {"ParentId": "22704111", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In C++ inherited virtual functions remain virtual in the derived class even without the <code>virtual</code> keyword. It is considered good practice to write <code>virtual</code> for every inherited function.</p>\n<p><strong>Update</strong></p>\n<p>As pointed out in the comments in C++ 11 it is considered good practice to include the keyword <code>override</code> immediately after the declarator. This catches a common class of errors and explicitly makes the intention clear in the code.</p>\n", "OwnerUserId": "2251525", "LastEditorUserId": "2251525", "LastEditDate": "2014-03-28T04:30:33.047", "Id": "22704165", "Score": "3", "CreationDate": "2014-03-28T04:24:53.657", "LastActivityDate": "2014-03-28T04:30:33.047"}, "22704111": {"CommentCount": "0", "ViewCount": "65", "CreationDate": "2014-03-28T04:19:23.733", "LastActivityDate": "2014-03-28T05:05:12.870", "Title": "Why is this method behaving as virtual when its not marked as virtual?", "AcceptedAnswerId": "22704165", "PostTypeId": "1", "Id": "22704111", "Score": "0", "Body": "<p>Suppose I have the following code</p>\n<pre><code>class base\n{\n    public:\n    virtual void MyVirtual() { std::cout &lt;&lt; \"This is base MyVirtual \\n\";}\n    void NonVirtual()        { std::cout &lt;&lt; \"This is base NonVirtual \\n\";}\n};\n\nclass derA : public base\n{\n    public:\n    void MyVirtual()  { std::cout &lt;&lt; \"This is derA MyVirtual \\n\";}\n    void NonVirtual() { std::cout &lt;&lt; \"This is derA NonVirtual \\n\";}\n};\n\n\nclass derB : public derA\n{\n    public:\n    void MyVirtual()  { std::cout &lt;&lt; \"This is derB MyVirtual \\n\";}\n    void NonVirtual() { std::cout &lt;&lt; \"This is derB NonVirtual \\n\";}\n};\n\nint main()\n{\n    derA *da = new derB;\n    da-&gt;MyVirtual();     // \"This is derB MyVirtual \\n\"\n    da-&gt;NonVirtual();\n    std::cin.get();\n    return 0;\n}\n</code></pre>\n<p>Now my question is why is MyVirtual Method behaving as virtual when it is not marked as virtual in class <code>derA</code> ?</p>\n", "Tags": "<c++><polymorphism>", "OwnerUserId": "1305891", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22704111_22704617_0": {"section_id": 7003, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_22704111_22704617_0": {"section_id": 6749, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_22704111_22704617_0": {"section_id": 8500, "quality": 0.967741935483871, "length": 30}}}, "22704617": {"ParentId": "22704111", "CommentCount": "0", "Body": "<p>As per the Standard \u00a7 10.3 Point #2</p>\n<blockquote>\n<p id=\"so_22704111_22704617_0\">If a virtual member function vf is declared in a class Base and in a\n  class Derived, derived directly or indirectly from Base, a member\n  function vf with the same name, parameter-type-list ,\n  cv-qualification, and refqualifier (or absence of same) as Base::vf is\n  declared, then Derived::vf is also virtual (whether or not it is so\n  declared) and it overrides Base::vf.</p>\n</blockquote>\n<p>There goes your answer, straight from the standards. So, it doesn't matter if you have used the keyword <code>virtual</code> in your derived class or not.</p>\n", "OwnerUserId": "1182192", "PostTypeId": "2", "Id": "22704617", "Score": "3", "CreationDate": "2014-03-28T05:05:12.870", "LastActivityDate": "2014-03-28T05:05:12.870"}});