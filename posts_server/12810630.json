post_cb({"bq_ids": {"n4140": {"so_12810630_12810755_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 179}, "so_12810630_12810755_0": {"length": 18, "quality": 0.5142857142857142, "section_id": 179}}, "n3337": {"so_12810630_12810755_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 173}, "so_12810630_12810755_0": {"length": 18, "quality": 0.5142857142857142, "section_id": 173}}, "n4659": {"so_12810630_12810755_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 184}, "so_12810630_12810755_0": {"length": 18, "quality": 0.5142857142857142, "section_id": 184}}}, "12810755": {"Id": "12810755", "PostTypeId": "2", "Body": "<p>This is a place where C++03 and C++11 are different from each other. The relevant part of the standard is <code>[temp.local]/1</code>. In C++03, this states:</p>\n<blockquote>\n<p id=\"so_12810630_12810755_0\">Like normal (non-template) classes, class templates have an injected-class-name (clause 9). The injected-class-name can be used with or without a template-argument-list. When it is used without a template- argument-list, it is equivalent to the injected-class-name followed by the template-parameters of the class template enclosed in &lt;&gt;. When it is used with a template-argument-list, it refers to the specified class template specialization, which could be the current specialization or another specialization.</p>\n</blockquote>\n<p>This means that <code>child</code> (without any template arguments) refers to the specialization <code>child&lt;V&gt;</code>. In C++11, it was changed to:</p>\n<blockquote>\n<p id=\"so_12810630_12810755_1\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected- class-name can be used as a template-name or a type-name. When it is used with a template-argument-list, as a template-argument for a template template-parameter, or as the final identifier in the elaborated-type-specifier of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent to the template-name followed by the template-parameters of the class template enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>Note in particular <code>When it is used ... as a template-argument for a template template-parameter ... it refers to the class template itself.</code>. This means that in C++11, your code would be correct.</p>\n", "LastActivityDate": "2012-10-10T01:35:51.770", "CommentCount": "4", "CreationDate": "2012-10-10T01:35:51.770", "ParentId": "12810630", "Score": "4", "OwnerUserId": "485561"}, "12810630": {"ViewCount": "463", "Body": "<p>Here's the scenario:</p>\n<pre><code>template &lt;template &lt;typename&gt; class T, typename V&gt;\nstruct parent {\n    void do_something();\n};\n\ntemplate &lt;typename V&gt;\nstruct child : public parent&lt;child, V&gt; {\n    void do_something(V argument);\n    using parent&lt;child, V&gt;::do_something; // C3200: invalid template argument for template parameter 'IMPL', expected a class template\n};\n</code></pre>\n<p>The above code fails to compile on the given line with the given error (MSVC 9.0).  However if I write this instead, outside of the class definition for <code>child</code>:</p>\n<pre><code>template &lt;typename V&gt;\nstruct parent_identity_meta {\n    typedef typename parent&lt;child, V&gt; type; // no error!\n};\n</code></pre>\n<p>I can now successfully do the following, within <code>child</code>:</p>\n<pre><code>using parent_identity_meta&lt;V&gt;::type::do_something;\n</code></pre>\n<p>I know there's a limitation (alleviated in C++11) that you can't typedef against a template, but I don't think that's what I'm running into here, otherwise the typedef in <code>parent_identity_meta</code> would fail.  It seems like <code>child</code> refers to the <em>template</em> when not inside of its own class definition, and to the <em>class being generated</em> from within itself.</p>\n<p>This is pretty understandable (having to write <code>child&lt;V&gt;</code> every single time would be painful); but is there any way to override this behaviour?</p>\n", "AcceptedAnswerId": "12810755", "Title": "How do I refer to a class template, as a template, from within its own class definition?", "CreationDate": "2012-10-10T01:16:13.103", "Id": "12810630", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-10T01:25:12.087", "LastEditorUserId": "584585", "LastActivityDate": "2012-10-10T01:35:51.770", "Score": "6", "OwnerUserId": "584585", "Tags": "<c++><templates>", "AnswerCount": "1"}});