post_cb({"3540852": {"Id": "3540852", "PostTypeId": "2", "Body": "<p>C and C++ are the same in this regard. The prototype names don't need to match up\u2026 that's <em>why</em> they may be omitted.</p>\n<p>Pick names for the parameters; when you put them in Doxygen they become part of your API. You can change them later, but you're changing the API; you can change them in the implementation as well but then it won't match the spec as cleanly.</p>\n<p>Do not use a double underscore, even for \"ignored\" identifiers. The compiler may define anything beginning with double underscore to mean anything, potentially causing a syntax error. Such words aren't just forbidden for names of in-scope variables, they are completely toxic.</p>\n", "LastActivityDate": "2010-08-22T09:10:47.970", "CommentCount": "3", "CreationDate": "2010-08-22T09:10:47.970", "ParentId": "3540841", "Score": "0", "OwnerUserId": "153285"}, "3540924": {"Id": "3540924", "PostTypeId": "2", "Body": "<p>I always use parameter names both in header and in implementation. It is not difficult to keep them in sync - when I change the function parameters, I usually:<br/>\n* Add/remove a parameter (no problem here - you have to sync it even if you didn't use parameter names)<br/>\n* Change the order to be more logical (again, even the types have to be synced)<br/><br/></p>\n<p>The advantage of having the parameter names in both prototype and implementation is that it helps the user - he can see the names in his IDE code completion, he doesn't have to navigate to the definition (which might be unavailable) to find out the parameter names. Another good reason for sticking to this practice is your Doxygen problem.<br/><br/></p>\n<p>I also don't really see the point of using double underscores in prototype parameters. Yes, #defines are evil, but double underscores are reserved for compiler writers. Unless you write a standard header for your compiler, you should avoid it.</p>\n", "LastActivityDate": "2010-08-22T09:29:10.373", "CommentCount": "0", "CreationDate": "2010-08-22T09:29:10.373", "ParentId": "3540841", "Score": "1", "OwnerUserId": "391850"}, "3544844": {"Id": "3544844", "PostTypeId": "2", "Body": "<p>What is protype declaration is that  you are informing compiler that this type of function is going to come with this arguments and with this data types. So compiler will make arrangemnts for that type of arguments.</p>\n<p>hence proto data type and number of arguments should match with  the actual definition and run time usage.</p>\n<p>Otherwise it will give an run time error.</p>\n", "LastEditorUserId": "20270", "LastActivityDate": "2010-08-25T17:56:13.063", "Score": "0", "CreationDate": "2010-08-23T04:56:24.230", "ParentId": "3540841", "CommentCount": "0", "OwnerUserId": "427986", "LastEditDate": "2010-08-25T17:56:13.063"}, "3540841": {"ViewCount": "4782", "Body": "<p>In my header, I have a prototype declaration like this:</p>\n<pre><code>void move(int, int);\n</code></pre>\n<p>I can omit the parameter names, that's how I'm used to it from C. I do that so that I don't have to keep the parameter names in sync - it's extremely confusing if they differ between prototype and implementation.</p>\n<p>Right now, I'm documenting all of my code with Doxygen, and I decided to put all comments into the header. Now I have to refer to parameter names that are defined in the implementation but not in the header: I find that confusing.</p>\n<pre><code>/**\n * Moves the entity to the specified point.\n * @param x The x coordinate of the new position.\n * @param y The y coordinate of the new position.\n */\nvoid move(int, int);\n</code></pre>\n<p>In the generated Doxygen HTML, it is not easy to figure out which parameter is which. Of course, one could follow the same order here, but if one has many parameters, it is still confusing.</p>\n<p>The alternative would be to duplicate parameter names and try to keep them in sync. However, <a href=\"http://bytes.com/topic/c/answers/513001-function-prototype-different-argument-names#post1998451\" rel=\"nofollow noreferrer\">some people</a> don't encourage this approach, saying that header parameters should start with a double underscore so that the user of a method can not possibly use the same name (names starting with __ are disallowed in C++).</p>\n<p>How do you do it?</p>\n", "AcceptedAnswerId": "3540883", "Title": "Prototype parameter names", "CreationDate": "2010-08-22T09:07:04.200", "Id": "3540841", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2010-08-23T02:49:00.457", "LastEditorUserId": "225647", "LastActivityDate": "2010-08-25T17:56:13.063", "Score": "7", "OwnerUserId": "427032", "Tags": "<c++><parameters><prototype><header>", "AnswerCount": "8"}, "3543077": {"Id": "3543077", "PostTypeId": "2", "Body": "<p>WRONG documentation/parameter names is ALWAYS WORSE than NO documentation/parameter names.  I'm not saying you don't need documentation or parameter names - I'm saying that you better keep up with them!  That's why they pay us the big $$$  :-D</p>\n", "LastActivityDate": "2010-08-22T19:48:45.043", "CommentCount": "1", "CreationDate": "2010-08-22T19:48:45.043", "ParentId": "3540841", "Score": "2", "OwnerUserId": "346104"}, "bq_ids": {"n4140": {"so_3540841_3540883_0": {"length": 8, "quality": 1.0, "section_id": 6307}}, "n3337": {"so_3540841_3540883_0": {"length": 8, "quality": 1.0, "section_id": 6064}}, "n4659": {"so_3540841_3540883_0": {"length": 5, "quality": 0.625, "section_id": 7844}}}, "3540894": {"Id": "3540894", "PostTypeId": "2", "Body": "<p>It is a terrible idea to not name the parameters in the header if it is not clear what that parameter is for.  The header should be the documentation for your code, so that someone trying to use it can avoid reading the implementation.  As you found, it's pointless to document the parameters by name and then not tell the user which is which.  That's not to say that they must match, but in the header they should be meaningful for the users of your code.  In the implementation, choose the name that is best for you.  E.g. it would be totally feasible to have:</p>\n<p>.h:</p>\n<pre><code>void move(int x, int y);\n</code></pre>\n<p>.cpp:</p>\n<pre><code>void move(int deltaX, int deltaY)\n{\n   ...\n</code></pre>\n<p>The only times that it would make sense (if you care about other programmers using your code) to elide the parameter names is when it is bone crushingly obvious what that parameter does.  E.g.</p>\n<pre><code>void SetNumPotatoes(int);\nvoid EnableLights(bool);\nvoid InitFoo(Foo&amp;);\n\n// but then...\nT&amp; GetItem(int);  // probably obvious enough, but does typing 'index' kill you?\nvoid DoSomething(bool, float, int);  // someone using this will say, \"WTF?\"\n</code></pre>\n", "LastActivityDate": "2010-08-22T09:19:05.617", "CommentCount": "1", "CreationDate": "2010-08-22T09:19:05.617", "ParentId": "3540841", "Score": "10", "OwnerUserId": "65845"}, "3540883": {"Id": "3540883", "PostTypeId": "2", "Body": "<p>Surely if \"names starting with __ are disallowed in C++\", you shouldn't be using them in prototypes either :-) <sup>*a</sup></p>\n<p>I see two ways to do it.</p>\n<p>One, you can ensure that the order of parameters in your comments always matches the order in your prototype.</p>\n<p>Or, two, you could actually put the real names in your prototypes as well.</p>\n<p>Myself, I prefer the second approach since I like to be able to tell what parameters are passed in, even if the function has no comments on it (or worse, the comments get out of date). This is far easier with a prototype like:</p>\n<pre><code>void move(int xcoord, int ycoord);\n</code></pre>\n<p>than it is with:</p>\n<pre><code>void move(int, int);\n</code></pre>\n<p>In some environments, we've even gone so far as to have the build process ensure that all function prototypes have identically named parameters as the function definition.</p>\n<hr>\n<p><sup>*a)</sup> These identifiers are actually not for the use of regular programs. Section 17.6.3.3.2 of cpp0x (but this restriction has been around for quite a while in both C and C++) states:</p>\n<blockquote>\n<p id=\"so_3540841_3540883_0\">Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li>Each name that contains a double underscore <code>__</code> or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.</li>\n<li>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</li>\n</ul>\n</blockquote>\n<p>In other words, <em>don't use them for your own purposes.</em></p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2010-08-22T09:32:24.540", "Score": "5", "CreationDate": "2010-08-22T09:16:55.617", "ParentId": "3540841", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2010-08-22T09:32:24.540"}, "3544413": {"Id": "3544413", "PostTypeId": "2", "Body": "<p>If the header file belongs to an OEM library which is expected to be used by many third party vendors, inquisitive developers (such as those belonging to SO), will most certainly explore the header files in addition to the supplied documentation, given the fact that most of the time documentation is either very bad or lags significantly behind the code.</p>\n<p>Therefore, I would say, the issues cited about the naming the parameters <em>could</em> be a development time pain, but is almost certainly a customer's delight.</p>\n", "LastActivityDate": "2010-08-23T02:44:35.397", "CommentCount": "0", "CreationDate": "2010-08-23T02:44:35.397", "ParentId": "3540841", "Score": "0", "OwnerUserId": "418110"}, "3540867": {"Id": "3540867", "PostTypeId": "2", "Body": "<p>They don't need to match, but I find parameter names to be invaluable documentation.  I hate it when they're missing.  I like in-code documentation far better than documentation in comments.</p>\n<p>And the advice at the end of that link is really silly.  Parameter names are nothing special as far as being in danger of being redefined by a <code>#define</code>.  Function names and practically any other identifier in your header are in danger as well.  That's why the naming convention of using ALL_UPPERCASE for your <code>#define</code> names exists.</p>\n<p>No, make the names match in your implementation and in your header, even though the compiler will be fine if they don't.  And if they don't match, fix it so they do.  They provide excellent documentation and they will be confusing if they don't match.</p>\n", "LastActivityDate": "2010-08-22T09:14:14.390", "CommentCount": "1", "CreationDate": "2010-08-22T09:14:14.390", "ParentId": "3540841", "Score": "3", "OwnerUserId": "167958"}});