post_cb({"44187130": {"ParentId": "44186063", "CommentCount": "0", "Body": "<p>It seems to be impossible to get exactly what you want. The problem is that an inline friend declared function will only be found by argument-dependant lookup, as defined in the C++ standard 11 and 14 in</p>\n<blockquote>\n<p id=\"so_44186063_44187130_0\"><strong>7.3.1.2</strong></p>\n<p id=\"so_44186063_44187130_1\"><em>3</em> Every name first declared in a namespace is a member of that namespace. If a friend declaration in a non-local class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a matching declaration is provided in that namespace scope (either before or after the class definition granting friendship). If a friend function is called, its name may be found by the name lookup that considers functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the name in a friend declaration is neither qualified nor a template-id and the declaration is a function or an elaborated-type-specifier, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace.</p>\n</blockquote>\n<p>That means it is only ever be found by argument dependent lookup. Revising the rules, argument dependent lookup is only applied within a function call expression. Hence you will not be able to retrieve the address of the function as any such an expression will evaluate to the result of the call.</p>\n<hr>\n<p>In case you only need a pointer referring to a function with the same functionality as <code>bar</code>, you could however utilize lambdas to get a pointer to such a function nevertheless. </p>\n<pre><code>void foo::foobar() {\n    using fntype = void(*)(foo);\n    std::cout &lt;&lt; (fntype)[](foo f){ bar(f); } &lt;&lt; '\\n'; // error\n}\n</code></pre>\n<p>The downside is that any other lambda will likely result in an intirely different address. You could however offer the address in a different (static) member function if the uniqueness is of importance.</p>\n</hr>", "OwnerUserId": "3750062", "PostTypeId": "2", "Id": "44187130", "Score": "1", "CreationDate": "2017-05-25T18:08:58.500", "LastActivityDate": "2017-05-25T18:08:58.500"}, "44186488": {"ParentId": "44186063", "CommentCount": "6", "Body": "<p>Did you try something like this? I find it interesting that you would declare a friend function from inside the scope of the struct/class but hey.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// forward declare foo so you can forward declare bar :)\nstruct foo;\n\n// forward declare bar so an address is available on the line that references it.\nvoid bar(foo);\n\nstruct foo \n{\n    friend void bar(foo)\n    {\n       std::cout &lt;&lt; \"bar called\" &lt;&lt; std::endl;\n    }\n\n    void foobar() \n    {\n        std::cout &lt;&lt; \"address of bar \" &lt;&lt; &amp;bar &lt;&lt; '\\n'; // error\n    }\n};\n\nint main() \n{\n    bar(foo{}); // ok, visible through ADL\n    foo{}.foobar();\n}\n</code></pre>\n<p>Tried it and it works LOL not sure why:</p>\n<pre><code>$ ./test.exe\nbar called\naddress of bar 1\n</code></pre>\n<p>though address of 1 is suspicious. :) but hey it compiled and did something. maybe you can take it further or someone can explain why this compiled/worked in the first place.</p>\n", "OwnerUserId": "793716", "PostTypeId": "2", "Id": "44186488", "Score": "0", "CreationDate": "2017-05-25T17:32:12.517", "LastActivityDate": "2017-05-25T17:32:12.517"}, "44189936": {"ParentId": "44186063", "CommentCount": "0", "Body": "<p>You could declare the friend function in the enclosing namespace scope in a different translation unit:</p>\n<p>In <em>foo.hpp</em>:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct foo;\nvoid (*get_bar_address())(foo);\nstruct foo {\n  friend void bar(foo) {}\n\n  void foobar() {\n      std::cout &lt;&lt; get_bar_address() &lt;&lt; '\\n'; // no error\n  } \n};\n</code></pre>\n<p>In <em>foo.cpp</em></p>\n<pre><code>#include \"foo.hpp\"\nvoid bar(foo);\nvoid (*get_bar_address())(foo){\n   return bar;\n}\n</code></pre>\n", "OwnerUserId": "5632316", "PostTypeId": "2", "Id": "44189936", "Score": "2", "CreationDate": "2017-05-25T21:14:47.210", "LastActivityDate": "2017-05-25T21:14:47.210"}, "bq_ids": {"n4140": {"so_44186063_44187130_1": {"section_id": 5485, "quality": 0.9058823529411765, "length": 77}}, "n3337": {"so_44186063_44187130_1": {"section_id": 5271, "quality": 0.9529411764705882, "length": 81}}, "n4659": {"so_44186063_44187130_1": {"section_id": 6920, "quality": 0.8235294117647058, "length": 70}}}, "44186063": {"CommentCount": "3", "ViewCount": "116", "CreationDate": "2017-05-25T17:06:01.920", "LastActivityDate": "2017-05-25T21:14:47.210", "Title": "Getting the address of an inline defined friend function", "FavoriteCount": "1", "PostTypeId": "1", "Id": "44186063", "Score": "6", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo {\n    friend void bar(foo) {}\n\n    void foobar() {\n        std::cout &lt;&lt; &amp;bar &lt;&lt; '\\n'; // error\n    }\n};\n\nint main() {\n    bar(foo{}); // ok, visible through ADL\n    foo{}.foobar();\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/sjPbtk\" rel=\"noreferrer\">gcc</a> gives me this error:</p>\n<blockquote id=\"so_44186063_44186063_0\">\n<pre><code>main.cpp: In member function 'void foo::foobar()':\nmain.cpp:7:23: error: 'bar' was not declared in this scope\n         std::cout &lt;&lt; &amp;bar &lt;&lt; '\\n'; // error\n                       ^~~\n</code></pre>\n</blockquote>\n<p>That's because <code>bar</code> is a friend function defined in the class itself, making it invisible in the global namespace. The only way to access it is through ADL, but I have not found a way to use ADL to get the address of <code>bar</code>.</p>\n<p>So my question is, how can I take the address of <code>bar</code>? Is there any other way than to define <code>bar</code> outside of <code>foo</code>?</p>\n", "Tags": "<c++>", "OwnerUserId": "3980929", "AnswerCount": "3"}});