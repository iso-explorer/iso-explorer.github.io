post_cb({"5557555": {"CommentCount": "1", "AcceptedAnswerId": "5557651", "CreationDate": "2011-04-05T19:42:15.740", "LastActivityDate": "2011-04-06T16:44:41.210", "PostTypeId": "1", "ViewCount": "1138", "FavoriteCount": "4", "Title": "RAII and Stack unwinding", "Id": "5557555", "Score": "0", "Body": "<p>TIL that my notions of the 'inter-twining' (for the lack of a better word) of RAII &amp; stack-unwinding are/were quite(if not completely) wrong. My understanding was that using RAII, guarded against any/all resource leaks - even ones potentially caused by unhandled exceptions. </p>\n<p>However writing <a href=\"http://pastebin.com/hrmAUzPM\" rel=\"nofollow\">this test program</a> and subsequently stumbling upon <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr155.htm\" rel=\"nofollow\">this article/documentation</a>, made me realize that stack unwinding would only cause the RAII-enabled resource deallocation to kick in for automatic's within the try block as opposed to automatic's in, say, outer/other scopes.</p>\n<p>Am I correct in this (new) understanding? Or are there further nuances I am yet not grasping? Any gurus out there want to chime in? Pointers to any good write-ups/analyses/explanations (of stack-unwinding) would be helpful/appreciated\u2026</p>\n", "Tags": "<c++><exception><exception-handling><raii><stack-unwinding>", "OwnerUserId": "391113", "AnswerCount": "3"}, "5557651": {"ParentId": "5557555", "CommentCount": "3", "CreationDate": "2011-04-05T19:50:49.443", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "5557651", "Score": "4", "Body": "<p>From the C++03 standard, \u00a715.3/9:</p>\n<blockquote>\n<p id=\"so_5557555_5557651_0\">If no matching handler is found in a program, the function terminate() is called; whether or not the stack is unwound before this call to terminate() is implementation-defined (15.5.1).</p>\n</blockquote>\n<p>\u00a715.5.1/1:</p>\n<blockquote>\n<p id=\"so_5557555_5557651_1\">In the following situations exception handling must be abandoned for less subtle error handling techniques: ... when the exception handling mechanism cannot find a handler for a thrown exception (15.3) ...</p>\n</blockquote>\n<p>\u00a715.5.1/2:</p>\n<blockquote>\n<p id=\"so_5557555_5557651_2\">In such cases,\n  <br/><br/>\u00a0\u00a0\u00a0\u00a0void terminate();\n  <br/><br/>is called (18.6.3). In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before terminate() is called. In all other situations, the stack shall not be unwound before terminate() is called. An implementation is not permitted to finish stack unwinding prematurely based on a determination that the unwind process will eventually cause a call to terminate().</p>\n</blockquote>\n", "LastActivityDate": "2011-04-05T19:50:49.443"}, "5569878": {"ParentId": "5557555", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-04-06T16:34:54.517", "Score": "0", "LastEditorUserId": "459640", "LastEditDate": "2011-04-06T16:39:57.417", "Id": "5569878", "OwnerUserId": "459640", "Body": "<p>The Standard defines three ways to end execution of a C++ program:</p>\n<ul>\n<li>Return from <code>main</code>.  Objects with automatic storage (function-local) have already been destroyed.  Objects with static storage (global, class-static, function-static) will be destroyed.</li>\n<li><code>std::exit</code> from <code>&lt;cstdlib&gt;</code>.  Objects with automatic storage are <em>NOT</em> destroyed.  Objects with static storage will be destroyed.</li>\n<li><code>std::abort</code> from <code>&lt;cstdlib&gt;</code>.  Objects with automatic and static storage are <em>NOT</em> destroyed.</li>\n</ul>\n<p>Also relevant is <code>std::terminate</code> from <code>&lt;exception&gt;</code>.  The behavior of <code>terminate</code> can be replaced using <code>std::set_terminate</code>, but <code>terminate</code> must always \"terminate execution of the program\" by calling <code>abort</code> or some similar implementation-specific alternative.  The default is just <code>{ std::abort(); }</code>.</p>\n<p>C++ will call <code>std::terminate</code> whenever an exception is thrown and C++ can't reasonably do stack unwinding.  For example, an exception from a destructor called by stack unwinding or an exception from a static storage object constructor or destructor.  In these cases, there is no (more) stack unwinding done.</p>\n<p>C++ will also call <code>std::terminate</code> when a matching <code>catch</code> handler is not found.  In this single case, C++ may <em>optionally</em> unwind to <code>main</code> before calling <code>terminate</code>.  So your example might have different results with a different compiler.</p>\n<p>So if you use RAII correctly, the remaining steps to \"leak-proof\" your program are:</p>\n<ul>\n<li>Avoid <code>std::abort</code>.</li>\n<li>Either avoid <code>std::exit</code> or avoid all objects with static storage duration.</li>\n<li>Put a <code>catch (...)</code> handler in <code>main</code>, and make sure no allocations or exceptions happen in or after it.</li>\n<li>Avoid the other programming errors that can cause <code>std::terminate</code>.\n<ul>\n<li>(On some implementations, functions compiled with a C compiler act like they have C++'s empty <code>throw()</code> specification, meaning that exceptions cannot be thrown \"past\" them even though they have no destructors to be called.)</li>\n</ul></li>\n</ul>\n", "LastActivityDate": "2011-04-06T16:39:57.417"}, "bq_ids": {"n4140": {"so_5557555_5557651_2": {"section_id": 3383, "quality": 0.8292682926829268, "length": 34}, "so_5557555_5557651_1": {"section_id": 3382, "quality": 0.9047619047619048, "length": 19}, "so_5557555_5557651_0": {"section_id": 3354, "quality": 0.7142857142857143, "length": 10}}, "n3337": {"so_5557555_5557651_2": {"section_id": 3252, "quality": 0.8292682926829268, "length": 34}, "so_5557555_5557651_1": {"section_id": 3251, "quality": 0.9047619047619048, "length": 19}, "so_5557555_5557651_0": {"section_id": 3224, "quality": 0.7142857142857143, "length": 10}}, "n4659": {"so_5557555_5557651_2": {"section_id": 4143, "quality": 0.8292682926829268, "length": 34}, "so_5557555_5557651_1": {"section_id": 4142, "quality": 0.9047619047619048, "length": 19}, "so_5557555_5557651_0": {"section_id": 4121, "quality": 0.7142857142857143, "length": 10}}}, "5557847": {"ParentId": "5557555", "CommentCount": "3", "CreationDate": "2011-04-05T20:08:36.903", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "5557847", "Score": "2", "Body": "<p>You are right that \"stack unwinding\" happens on the way from the <code>throw some_exception</code> to <code>catch(some_exception)</code>. If your exception never reaches a catch, we don`t known what happens.</p>\n<p>Is that a big problem? As you have shown yourself, you just have to add a <code>catch(...)</code> somewhere to catch all possible exceptions, and the problem goes away.</p>\n", "LastActivityDate": "2011-04-05T20:08:36.903"}});