post_cb({"31875800": {"Id": "31875800", "PostTypeId": "2", "Body": "<p>This declaration</p>\n<pre><code>struct abc *d;\n</code></pre>\n<p>on the one hand declares <code>struct abc</code> and on the other hand declares pointer <code>d</code> of type <code>struct abc *</code>.</p>\n<p>In this declaration there is no need to have the exact definition of struct abc because no data member of the structure is used. </p>\n<p>This specifier <code>struct abc</code> is called elaborated type specifier.</p>\n<p>It introduces a new type in the given scope or refers to an already declared type. </p>\n", "LastActivityDate": "2015-08-07T10:43:17.433", "CommentCount": "0", "CreationDate": "2015-08-07T10:43:17.433", "ParentId": "31875710", "Score": "6", "OwnerUserId": "2877241"}, "31875710": {"ViewCount": "364", "Body": "<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nstruct a{\n    int e;\n    struct abc *d;\n};\n\nstruct abc{\n    int c;\n};\n\nint main()\n{\n return 0;  \n}\n</code></pre>\n<p>I have defined the <code>struct abc</code> after definition of <code>struct a</code> in which i have declared a structure pointer for <code>abc</code>. This is supposed to throw compilation error because <code>abc</code> is used before its declaration. But, it doesn't, why?\nWhereas when i replace it with just <code>struct abc d</code> instead of <code>struct abc *d</code>, it is giving compilation error as expected.</p>\n", "Title": "Why doesn't this C++ code give compilation error?", "CreationDate": "2015-08-07T10:38:07.090", "LastActivityDate": "2015-08-10T13:44:26.023", "CommentCount": "7", "LastEditDate": "2015-08-07T10:41:13.270", "PostTypeId": "1", "LastEditorUserId": "1030018", "Id": "31875710", "Score": "4", "OwnerUserId": "5201678", "Tags": "<c++><pointers><struct><structure>", "AnswerCount": "5"}, "31875852": {"Id": "31875852", "PostTypeId": "2", "Body": "<p>Pointer declared to incomplete types are allowed .</p>\n<p>This is forward declaration-</p>\n<blockquote>\n<p id=\"so_31875710_31875852_0\">Forward declaration is a declaration preceeding an actual definition, usually for the purpose of being able to reference the declared type when the definition is not available. Of course, not everything may be done with the declared-not-defined structure, but in certain context it is possible to use it. Such type is called incomplete.</p>\n</blockquote>\n<p>A declaration of the following form </p>\n<pre><code>  class-key attr identifier ;   // struct abc *d; (Your case)\n</code></pre>\n<p>Declares a class type which will be defined later in this scope. Until the definition appears, this class name has incomplete type.</p>\n<p>When <code>struct a</code> is declared it doesn't know the specs of <code>struct abc</code> yet, but you can forward reference it.</p>\n", "LastEditorUserId": "4606734", "LastActivityDate": "2015-08-07T11:33:06.007", "Score": "0", "CreationDate": "2015-08-07T10:46:39.367", "ParentId": "31875710", "CommentCount": "5", "OwnerUserId": "4606734", "LastEditDate": "2015-08-07T11:33:06.007"}, "31876176": {"Id": "31876176", "PostTypeId": "2", "Body": "<p>You're right in that, usually, you'd need a forward declaration of such a type:</p>\n<pre><code>// Forward declaration\nstruct bar;\n\nstruct foo\n{\n    bar* d;   // only a pointer-to-bar; forward declaration sufficient\n};\n\nstruct bar\n{\n    int c;\n};\n</code></pre>\n<p>However, you are (for some reason) using the antiquated idiom of writing <code>struct</code> before the type name. (This was required in C but has never been in C++.)</p>\n<pre><code>struct foo\n{\n    struct bar* d;\n};\n\nstruct bar\n{\n    int c;\n};\n</code></pre>\n<p>Because you write <code>struct bar</code> there instead of just <code>bar</code>, <em>that itself counts as a forward declaration</em> of sorts. The compiler now knows that <code>bar</code> is a type and that's all it needs to know.</p>\n<p>It's a bit obscure and subtle, but that's why you do not need the prior forward declaration any more.</p>\n<blockquote>\n<p id=\"so_31875710_31876176_0\"><code>[C++11: 3.1/4]:</code> <em>[ Note:</em> <strong>A class name can also be implicitly declared by an <em>elaborated-type-specifier</em></strong> (7.1.6.3). <em>\u2014end note ]</em></p>\n<p id=\"so_31875710_31876176_1\"><code>[C++11: 3.3.2/6]:</code> <strong>The point of declaration of a class first declared in an <em>elaborated-type-specifier</em> is as follows</strong>:</p>\n<ul>\n<li><p id=\"so_31875710_31876176_2\">for a declaration of the form</p>\n<p id=\"so_31875710_31876176_3\">\u00a0\u00a0\u00a0<em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em> <code>;</code></p>\n<p id=\"so_31875710_31876176_4\">the <em>identifier</em> is declared to be a <em>class-name</em> in the scope that contains the declaration, otherwise</p></li>\n<li><p id=\"so_31875710_31876176_5\"><strong>for an <em>elaborated-type-specifier</em> of the form</strong></p>\n<p id=\"so_31875710_31876176_6\">\u00a0\u00a0\u00a0<strong><em>class-key identifier</em></strong></p>\n<p id=\"so_31875710_31876176_7\">if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a function defined in namespace scope, the <em>identifier</em> is declared as a <em>class-name</em> in the namespace that contains the declaration; otherwise, except as a friend declaration, <strong>the <em>identifier</em> is declared in the smallest namespace or block scope that contains the declaration</strong>. <em>[ Note:</em> These rules also apply within templates. <em>\u2014end note ] [ Note:</em> Other forms of <em>elaborated-type-specifier</em> do not declare a new name,\n  and therefore must refer to an existing <em>type-name</em>. See 3.4.4 and 7.1.6.3. <em>\u2014end note ]</em></p></li>\n</ul>\n<p id=\"so_31875710_31876176_8\"><code>[C++11: 3.4.4/2]:</code> <em>[..]</em> <strong>If the <em>elaborated-type-specifier</em> is introduced by the class-key and this lookup does not find a previously declared <em>type-name</em></strong>, or if the <em>elaborated-type-specifier</em> appears in a declaration with the form:</p>\n<p id=\"so_31875710_31876176_9\">\u00a0\u00a0\u00a0<em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em> <code>;</code></p>\n<p id=\"so_31875710_31876176_10\"><strong>the <em>elaborated-type-specifier</em> is a declaration that introduces the <em>class-name</em> as described in 3.3.2</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-08-07T11:16:57.273", "Score": "5", "CreationDate": "2015-08-07T11:03:36.597", "ParentId": "31875710", "CommentCount": "0", "OwnerUserId": "560648", "LastEditDate": "2015-08-07T11:16:57.273"}, "bq_ids": {"n4140": {"so_31875710_31876176_10": {"length": 5, "quality": 0.8333333333333334, "section_id": 7124}, "so_31875710_31876176_8": {"length": 13, "quality": 0.8666666666666667, "section_id": 7124}, "so_31875710_31876176_1": {"length": 7, "quality": 0.7, "section_id": 7055}, "so_31875710_31876176_4": {"length": 7, "quality": 1.0, "section_id": 7055}, "so_31875710_31876176_7": {"length": 42, "quality": 0.8235294117647058, "section_id": 7055}, "so_31875710_31876176_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 7036}}, "n3337": {"so_31875710_31876176_10": {"length": 5, "quality": 0.8333333333333334, "section_id": 6868}, "so_31875710_31876176_8": {"length": 13, "quality": 0.8666666666666667, "section_id": 6868}, "so_31875710_31876176_1": {"length": 7, "quality": 0.7, "section_id": 6799}, "so_31875710_31876176_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 6782}, "so_31875710_31876176_7": {"length": 42, "quality": 0.8235294117647058, "section_id": 6799}, "so_31875710_31876176_4": {"length": 7, "quality": 1.0, "section_id": 6799}}, "n4659": {"so_31875710_31876176_10": {"length": 5, "quality": 0.8333333333333334, "section_id": 8625}, "so_31875710_31876176_8": {"length": 13, "quality": 0.8666666666666667, "section_id": 8625}, "so_31875710_31876176_1": {"length": 7, "quality": 0.7, "section_id": 8552}, "so_31875710_31876176_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 8533}, "so_31875710_31876176_7": {"length": 42, "quality": 0.8235294117647058, "section_id": 8552}, "so_31875710_31876176_4": {"length": 7, "quality": 1.0, "section_id": 8552}}}, "31875789": {"Id": "31875789", "PostTypeId": "2", "Body": "<p>It works, because the compiler has all the information it needs:</p>\n<ul>\n<li>the size of <code>d</code> (= size of pointer)<sup>1</sup>, and</li>\n<li>what <code>abc</code> is (it's a <code>struct</code>).</li>\n</ul>\n<hr>\n<p>If you stored an <em>object</em> of type <code>struct abc</code> instead:</p>\n<pre><code>struct abc d;\n</code></pre>\n<p>it would result in an error because the information about the size and memory layout of <code>d</code> is missing (because <code>struct abc</code> hasn't been defined yet).</p>\n<p>Also if you left out the <code>struct</code> keyword:</p>\n<pre><code>abc *d;\n</code></pre>\n<p>then the information about what <code>abc</code> is would be missing, and it would be an error as well.</p>\n<hr>\n<blockquote>\n<p id=\"so_31875710_31875789_0\">This is supposed to throw compilation error because <code>abc</code> is used before its declaration.</p>\n</blockquote>\n<p>It is not <em>used</em>, it is only <em>declared</em>. Using <code>abc</code> via a pointer would require <em>dereferencing</em> the pointer first (and if <code>abc</code> is not defined at that point, it would be an error).</p>\n<hr>\n<p><sup>1</sup> Pointers to incomplete types are allowed because the size and memory layout of a pointer doesn't depend on what it points to.</p>\n</hr></hr></hr>", "LastEditorUserId": "3425536", "LastActivityDate": "2015-08-07T11:01:53.703", "Score": "2", "CreationDate": "2015-08-07T10:42:53.213", "ParentId": "31875710", "CommentCount": "1", "OwnerUserId": "3425536", "LastEditDate": "2015-08-07T11:01:53.703"}, "31875824": {"Id": "31875824", "PostTypeId": "2", "Body": "<p>In <code>struct a</code> you refer to a <em>pointer</em> to <code>struct abc</code>, so the compiler has no need for more information about it to compute the size  of the <code>d</code> member.</p>\n<p>In a later stage, it will check that <code>struct abc</code> is defined, if needed (for exemple if it is dereferenced). This explains the rationale for the standard which </p>\n<ul>\n<li><p>forbids to declare variables of <em>unknown type</em> (<code>abc</code>, when not forwarded, is such an unknown type)</p></li>\n<li><p>allows to declare them as pointers to <em>incomplete type</em>. (<code>struct abc</code> is an incomplete type: at least it is known to be some <code>struct</code>).</p></li>\n</ul>\n<p>Practically, declaring a structure as</p>\n<pre><code> struct a {\n    struct abc *d;\n }\n</code></pre>\n<p>amounts to forwarding the declaration of (struct) type <code>abc</code>, as in</p>\n<pre><code>struct abc;           // forward\nstruct a {\n   abc *d;            // legal\n};\n</code></pre>\n<p>However the type <code>abc</code> is incomplete, so the following is illegal</p>\n<pre><code>struct z {\n   struct abc y;   // error : incomplete struct type\n}\n</code></pre>\n<p>For the curiosity, this is OK:</p>\n<pre><code>struct A {\n   struct B* ptr1;    // forwards declaration of B, and use it\n   B* ptr2;           // B is a known (incomplete-)type name now\n} \n</code></pre>\n", "LastEditorUserId": "4744142", "LastActivityDate": "2015-08-10T13:44:26.023", "Score": "-2", "CreationDate": "2015-08-07T10:44:50.637", "ParentId": "31875710", "CommentCount": "13", "OwnerUserId": "4744142", "LastEditDate": "2015-08-10T13:44:26.023"}});