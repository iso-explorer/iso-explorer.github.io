post_cb({"bq_ids": {"n4140": {"so_27418384_27418628_0": {"length": 55, "quality": 0.873015873015873, "section_id": 5485}, "so_27418384_27418628_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7106}, "so_27418384_27418628_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 7104}}, "n3337": {"so_27418384_27418628_0": {"length": 59, "quality": 0.9365079365079365, "section_id": 5271}, "so_27418384_27418628_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6850}, "so_27418384_27418628_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 6848}}, "n4659": {"so_27418384_27418628_0": {"length": 48, "quality": 0.7619047619047619, "section_id": 6920}, "so_27418384_27418628_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 8607}, "so_27418384_27418628_1": {"length": 37, "quality": 0.8409090909090909, "section_id": 8605}}}, "27418628": {"Id": "27418628", "PostTypeId": "2", "Body": "<p>I would say GCC accepts this incorrectly. Quoting C++11, emphasis mine:</p>\n<p>Namespace membership, 7.3.1.2/3</p>\n<blockquote>\n<p id=\"so_27418384_27418628_0\">Every name first declared in a namespace is a member of that namespace. <strong>If a <code>friend</code> declaration in a nonlocal\n  class first declares a class or function</strong> the friend class or function is a member of the innermost enclosing\n  namespace. <strong>The name of the friend is not found by unqualified lookup (3.4.1)</strong> or by qualified lookup (3.4.3) until a matching declaration is provided in that namespace scope (either before or after the class definition\n  granting friendship). <strong>If a friend function is called, its name may be found by the name lookup that considers\n  functions from namespaces and classes associated with the types of the function arguments (3.4.2).</strong> ...</p>\n</blockquote>\n<p>Argument-dependent lookup, 3.4.2/2:</p>\n<blockquote>\n<p id=\"so_27418384_27418628_1\">For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a\n  set of zero or more associated classes to be considered. The sets of namespaces and classes is determined\n  entirely by the types of the function arguments (and the namespace of any template template argument).\n  Typedef names and <em>using-declarations</em> used to specify the types do not contribute to this set. The sets of\n  namespaces and classes are determined in the following way:</p>\n<ul>\n<li>...</li>\n<li>If <code>T</code> is an enumeration type, its associated namespace is the namespace in which it is defined. If it is\n  class member, its associated class is the member\u2019s class; <strong>else it has no associated class.</strong></li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>3.4.2/4:</p>\n<blockquote>\n<p id=\"so_27418384_27418628_2\">When considering an associated namespace, the lookup is the same as the lookup performed when the\n  associated namespace is used as a qualifier (3.4.3.2) except that:</p>\n<ul>\n<li>...</li>\n<li>Any namespace-scope friend functions or friend function templates <strong>declared in associated classes</strong> are\n  visible within their respective namespaces even if they are not visible during an ordinary lookup (11.3).</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>Based on the above, I reason that <code>FooValueT</code> (the type of <code>FooValueT::ONE</code> and <code>FooValueT::TWO</code>) has <code>::</code> as an associated namespace, but has no associated classes (since it's an enumeration). Therefore, friend functions defined in class template <code>ImplAdd</code> should not be considered during ADL.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2014-12-11T12:53:07.847", "Score": "3", "CreationDate": "2014-12-11T08:45:28.810", "ParentId": "27418384", "CommentCount": "3", "OwnerUserId": "1782465", "LastEditDate": "2014-12-11T12:53:07.847"}, "27418384": {"ViewCount": "157", "Body": "<p>I have no idea, why gcc compiles this code</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class Type, class ValueT&gt;\nclass ImplAdd\n{\n   template&lt;typename T&gt;\n   friend typename std::enable_if&lt;std::is_same&lt;T, ValueT&gt;::value, Type&gt;::type \n   operator+(T, T)\n   {\n      return Type{};\n   }\n};\n\nenum class FooValueT { ONE, ZERO };\n\nclass Foo : ImplAdd&lt;Foo, FooValueT&gt;\n{\npublic:\n   Foo() {}\n   Foo(FooValueT) {}\n};\n\nstruct A {};\n\nint main()\n{\n   Foo f = FooValueT::ONE + FooValueT::ZERO;\n}\n</code></pre>\n<p>clang and msvc doesn't compile, and it seems to me, that they are right. Is it bug in GCC compiler? Version of gcc is 4.8.2.</p>\n<p>Question is caused by my answer in question: <a href=\"https://stackoverflow.com/questions/27376365/in-class-friend-operator-doesnt-seem-to-participate-in-overload-resolution/27376675?noredirect=1#comment43264999_27376675\">In-class friend operator doesn't seem to participate in overload resolution</a>, there is quote from standard in answer, that points, that such definition should be in class-scope, and if function is not template - gcc reject this code, that is right. Thanks for answers, and quotes from standard, that proves, that gcc is right (or not) are very appreciated.</p>\n", "AcceptedAnswerId": "27418628", "Title": "Friend template function in-class definition", "CreationDate": "2014-12-11T08:30:39.367", "Id": "27418384", "CommentCount": "0", "LastEditDate": "2017-05-23T12:21:42.520", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-11T12:53:07.847", "Score": "3", "OwnerUserId": "1498580", "Tags": "<c++><c++11><gcc><language-lawyer>", "AnswerCount": "1"}});