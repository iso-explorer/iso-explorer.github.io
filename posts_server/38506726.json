post_cb({"38507513": {"LastActivityDate": "2016-07-21T14:51:34.127", "CreationDate": "2016-07-21T14:51:34.127", "CommentCount": "0", "Body": "<p>In the C language, doing arithmetic on a pointer to produce another pointer that does not point into (or one-past-the-end) the same object or array of objects is <em>undefined behavior</em>: from <strong>6.5.6 Additive Operators</strong>:</p>\n<blockquote>\n<p id=\"so_38506726_38507513_0\">If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined. If the result points one past the last element of the array object, it\n  shall not be used as the operand of a unary <code>*</code> operator that is evaluated</p>\n</blockquote>\n<p>(for the purposes of this clause, a non-array object is treated as an array of length 1)</p>\n<hr>\n<p>You could get unlucky and the compiler could produce still produce a pointer you're allowed to do things with and then doing things with them will do things \u2014 but precisely what those things are is anybody's guess and will be unreliable and often difficult to debug.</p>\n<p>If you're lucky, the compiler produces a pointer into memory that \"does not belong to you\" and you get a <a href=\"https://stackoverflow.com/a/2346849/1084944\">segmentation fault</a> to alert you to the problem as soon as you try to read or write through it.</p>\n</hr>", "Id": "38507513", "LastEditDate": "2017-05-23T12:02:27.607", "ParentId": "38506726", "OwnerUserId": "1084944", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "-1"}, "38532173": {"CommentCount": "0", "Body": "<p>Technically, a process has a logical address. However, that often gets conflated into a virtual address space.</p>\n<p>The number of virtual addresses that can be mapped into that logical address space can be limited by:</p>\n<ol>\n<li>Hardware</li>\n<li>System resources (notably page file space)</li>\n<li>System Parameters (e.g., limiting page table size)</li>\n<li>Process quotas</li>\n</ol>\n<p>Your logical address space consists of an array of pages that are mapped to physical page frames. Not every page needs to have such a mapping (or even is likely to).</p>\n<p>The logical address space is usually divided into two (or more) areas: system (common to all processes) and user (created for each process).</p>\n<p>Theoretically, there is nothing in the user space to being a process with, only the system address space exists. </p>\n<p>If the system does not use up its entire range of logical addresses (which is normal), unused addresses cannot be accessed at all.</p>\n<p>Now your program starts running. The O/S has mapped some pages into your logical address space. Very little of that address space it likely to be mapped. Your application can map more pages into the unmapped pages of logical address space.</p>\n<blockquote>\n<p id=\"so_38506726_38532173_0\">Say, I allocate some dynamic memory using malloc() function call in a c program and subtract some positive value(say 1000) from the address returned by it. Now, I try to read what is written on that location which should be fine but what about writing to that location?</p>\n</blockquote>\n<p>The processor uses a page table to map logical pages to physical page frames. If you do you say a number of things can happen:</p>\n<ol>\n<li><p>There is no page table entry for the address =&gt; Access violation. Your system may not set up a page table that can span the entire logical address space.</p></li>\n<li><p>There is a page table entry for the address but it is marked invalid =&gt; Access Violation. </p></li>\n<li><p>You are attempting to access a page that is not accessible in your current processor mode (e.g., user mode access to a page that only allows kernel mode access) =&gt; Access Violation.</p></li>\n</ol>\n<blockquote>\n<p id=\"so_38506726_38532173_1\">virtual address space also has some read only chunk of memory. How does it protect that?</p>\n</blockquote>\n<ol start=\"4\">\n<li>You are attempting to access a page that in a manner not permitted to the page (e.g., write to readonly page, execute to a no execute page) =&gt; Access Violation The access allowed to a page is defined in the page table.</li>\n</ol>\n<p>[Ignoring page faults]</p>\n<p>If you make it though those tests, you can access the random memory address.</p>\n", "CreationDate": "2016-07-22T17:25:35.890", "ParentId": "38506726", "Id": "38532173", "LastActivityDate": "2016-07-22T17:25:35.890", "PostTypeId": "2", "Score": "0", "OwnerUserId": "3344003"}, "38525248": {"LastActivityDate": "2016-07-22T11:52:43.093", "CreationDate": "2016-07-22T11:25:15.773", "CommentCount": "0", "Body": "<p>How the system behaves when you read/write an unmapped memory address depends basically on your operating system implementation.  Operating systems normally behave differently when you try to access an unmapped virtual address.  What happens when you try one access to an unmapped (or mapped for not-memory ---for example to map a file in memory) the operating system is taking the control (by means of a trap) and what happens then is completely operating system dependant.  Suppose you have mapped the video framebuffer somewhere in your virtual address... then, writing there makes the screen change.  Suppose you have mapped a file, then reading/writing that memory means reading or writing a file.  Suppose you (the process running) try to access a swapped zone (due to physical memory lack your process has been partially swapped) your process is stopped and work for bringing that memory from secondary storage is begun, and then the instruction will be restarted.  For example, linux generates a <code>SIGSEGV</code> signal when you try to access memory not allocated.  But you can install a signal handler to be called upon receiving this signal and then, trying to access unallocated memory means jumping into a piece of code in your own program to deal with that situation.</p>\n<p>But think that trying to access memory that has not been correctly acquired, and more in a modern operating system, normally means that your program is behaving incorrectly, and normally it will crash, letting the system to take the control and it will be killed.</p>\n<h1>NOTE</h1>\n<p><code>malloc(3)</code> is not a system call, but a library function that manages a variable size allocation segment on your RAM, so what happens if you try to access even the first address previous to the returned one or past the last allocated memory cell, means undefined behaviour.  It does not mean you have accessed unallocated memory.  Probably you will be reading a perfectly allocated piece of memory in your code or in your data (or the stack) without knowing.  <code>malloc(3)</code> tends to ask the operating system for continous large amounts of memory to be managed for many malloc calls between costly asking the operating system for more memory.  See <code>sbrk(2)</code> or <code>memmap(2)</code> system calls manpages for getting more on this.</p>\n<p>For example, either <strong>linux</strong> or <strong>bsd unix</strong> allocate an entry in the virtual address space of each process <em>at page 0</em> (for the <code>NULL</code> address) to make the null pointer invalid access, and if you try to read or write to this address (or all in that page) you'll get a signal (or your process killed)  Try this:</p>\n<pre><code>int main()\n{\n    char *p = 0; /* p is pointing to the null address */\n    p[0] = '\\n'; /* a '\\n' is being written to address 0x0000 */\n    p[1] = '\\0'; /* a '\\0' is being written to address 0x0001 */\n}\n</code></pre>\n<p>This program should fail at runtime on all modern operating systems (try to compile it without optimization so the compiler doesn't eliminate the code in main, as it does effectively nothing) because you are trying to access an already allocated (for specific purposes) page of memory. </p>\n<p>The program on my system (mac OS X, a derivative from BSD unix) just does the following:</p>\n<pre><code>$ a.out\nSegmentation fault: 11\n</code></pre>\n<h1>NOTE 2</h1>\n<p>Many modern operating systems (mostly unix derived) implement a type of memory access called <strong>COPY ON WRITE</strong>.  This means that you can access that memory and modify it as you like, but the first time you access it for writing, a page fault is generated (normally, this is implemented as you receiving a read only page, letting the fault to happen and making the individual page copy to store your private modifications)  This is very effective on <code>fork(2)</code>, that normally are followed by an <code>exec(2)</code> syscall (only the pages modified by the program are actually copied before the process throws them all, saving a lot of computer power)</p>\n<p>Another case is the stack growing example.  Stack grows automatically as you enter/leave stack frames in your program, so the operating system has to deal with the page faults that happen when you <code>PUSH</code> something on the stack and that push crosses a virtual page and goes into the unknown.  When this happens, the OS automatically allocates a page and converts that region (the page) into more valid memor (read-write normally).</p>\n", "Id": "38525248", "LastEditDate": "2016-07-22T11:52:43.093", "ParentId": "38506726", "OwnerUserId": "3899431", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "3899431"}, "bq_ids": {"n4140": {"so_38506726_38507513_0": {"length": 20, "quality": 0.6060606060606061, "section_id": 6142}}, "n3337": {"so_38506726_38507513_0": {"length": 20, "quality": 0.6060606060606061, "section_id": 5906}}}, "38506995": {"LastActivityDate": "2016-07-21T14:43:56.510", "CreationDate": "2016-07-21T14:28:58.387", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_38506726_38506995_0\">Now, I try to read what is written on that location which should be fine</p>\n</blockquote>\n<p>It is not fine. According to the C++ standard, reading uninitialized memory has undefined behaviour.</p>\n<blockquote>\n<p id=\"so_38506726_38506995_1\">but what about writing to that location? </p>\n</blockquote>\n<p>Not fine either. Reading or writing unallocated memory also has undefined behaviour.</p>\n<p>Sure, the memory address that you ended up in <strong>might</strong> be allocated - it's possible. But even if it happens to be, the pointer arithmetic outside of bounds of the allocation is already UB.</p>\n<blockquote>\n<p id=\"so_38506726_38506995_2\">virtual address space also has some read only chunk of memory. How does it protect that?</p>\n</blockquote>\n<p>This one is out of scope of C++ (and C) since it does not define virtual memory at all. This may differ across operating systems, but at least one approach is that when the process requests memory from the OS, it sends flags that specify the desired protection type. See <a href=\"http://man7.org/linux/man-pages/man2/mmap.2.html\" rel=\"nofollow\"><code>prot</code> argument in the man page of mmap</a> as an example. The OS in turn sets up the virtual page table accordingly.</p>\n<p>Once the protection type is known, the OS can raise an appropriate signal if the protection has been violated, and possibly terminate the process. Just like it does when a process tries to access unmapped memory. The violations are typically detected by the memory management unit of the CPU.</p>\n", "Id": "38506995", "LastEditDate": "2016-07-21T14:43:56.510", "ParentId": "38506726", "OwnerUserId": "2079303", "PostTypeId": "2", "Score": "2", "LastEditorUserId": "2079303"}, "38506836": {"LastActivityDate": "2016-07-21T14:36:58.003", "CreationDate": "2016-07-21T14:22:00.947", "CommentCount": "3", "Body": "<p><strong>TL;DR</strong> No, it's not allowed.</p>\n<hr>\n<p>In your case, when you got a valid non-NULL pointer to a memory address returned by <code>malloc()</code>, only the requested size of memory is allocated to your process and you're allowed to use (read and / or write) into that much space only. </p>\n<p>In general, any allocated memory (compile-time or run-time) has an associated size with it. Either <strong>overrunning</strong> or <strong>underruning</strong> the allocated memory area is considered invalid memory access, which invokes <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a>.</p>\n<p>Even if, the memory <em>is</em> accessible and inside the process address space, there's nothing stopping the OS/ memory manager to return the pointer to <em>that</em> particular address, so, at <em>best</em>, either your previous write will be overwritten or you will be overwriting some other value. The worst case, as mentioned earlier, UB.</p>\n</hr>", "Id": "38506836", "LastEditDate": "2016-07-21T14:36:58.003", "ParentId": "38506726", "OwnerUserId": "2173917", "PostTypeId": "2", "Score": "4", "LastEditorUserId": "2173917"}, "38507211": {"LastActivityDate": "2016-07-21T15:22:30.643", "CreationDate": "2016-07-21T14:38:04.923", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_38506726_38507211_0\">Say, I allocate some dynamic memory using malloc() function call in a c program and subtract some positive value(say 1000) from the address returned by it. Now, I try to read what is written on that location which should be fine but what about writing to that location?</p>\n</blockquote>\n<p>What addresses you can read/write/execute from are based on a processes current memory map, which is set up by the operating system. </p>\n<p>On my linux box, if I run <a href=\"http://linux.die.net/man/1/pmap\" rel=\"nofollow\">pmap</a> on my current shell, I see something like this:</p>\n<pre><code>evaitl@bb /proc/13151 $ pmap 13151\n13151:   bash\n0000000000400000    976K r-x-- bash\n00000000006f3000      4K r---- bash\n00000000006f4000     36K rw--- bash\n00000000006fd000     24K rw---   [ anon ]\n0000000001f25000   1840K rw---   [ anon ]\n00007ff7cce36000     44K r-x-- libnss_files-2.23.so\n00007ff7cce41000   2044K ----- libnss_files-2.23.so\n00007ff7cd040000      4K r---- libnss_files-2.23.so\n00007ff7cd041000      4K rw--- libnss_files-2.23.so\n00007ff7cd042000     24K rw---   [ anon ]\n...\n[many more lines here...]\n</code></pre>\n<p>Each line has a base address, a size, and the permissions. These are considered memory segments. The last line either says what is being mapped in. <code>bash</code> is my shell. <code>anon</code> means this is allocated memory, perhaps for bss, maybe heap from malloc, or it could be a stack. </p>\n<p>Shared libraries are also mapped in, that is where the the libnns_files lines come from. </p>\n<p>When you malloc some memory, it will come from an anonymous program segment. If there isn't enough space in the current anon segment being used for the heap, the OS will increase its size. The permissions in those segments will almost certainly be <code>rw</code>. </p>\n<p>If you try to read/write outside of space you allocated, behavior is <em>undefined</em>. In this case that means that you may get <em>lucky</em> and nothing happens, or you may trip over an unmapped address and get a SIGSEGV signal. </p>\n", "Id": "38507211", "LastEditDate": "2016-07-21T15:22:30.643", "ParentId": "38506726", "OwnerUserId": "5058676", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "5058676"}, "38506942": {"CommentCount": "2", "Body": "<p>It does not. It's actually you duty as a programmer to handle this</p>\n", "CreationDate": "2016-07-21T14:26:57.250", "ParentId": "38506726", "Id": "38506942", "LastActivityDate": "2016-07-21T14:26:57.250", "PostTypeId": "2", "Score": "-1", "OwnerUserId": "4833867"}, "38508656": {"LastActivityDate": "2016-07-22T05:29:33.737", "CreationDate": "2016-07-21T15:43:00.930", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_38506726_38508656_0\">Processes in OS have their own virtual address spaces. Say, I allocate\n  some dynamic memory using malloc() function call in a c program and\n  subtract some positive value(say 1000) from the address returned by\n  it.  Now, I try to read what is written on that location which should\n  be fine but what about writing to that location?</p>\n</blockquote>\n<p>No, it should not be fine, since <strong>only</strong> the memory region allocated by <code>malloc()</code> is guaranteed to be accessible. There is no guarantee that the virtual address space is contiguous, and thus the memory addresses before and after your region are accessible (i.e. mapped to virtual address space).</p>\n<p>Of course, no one is stopping you from doing so, but the behaviour will be really undefined. If you access non-mapped memory address, it will generate a <a href=\"https://en.wikipedia.org/wiki/Page_fault\" rel=\"nofollow\">page fault</a> exception, which is a hardware CPU exception. When it is handled by the operating system, it will send SIGSEGV signal or access violation exception to your application (depending ot the OS).</p>\n<blockquote>\n<p id=\"so_38506726_38508656_1\">virtual address space also has some read only chunk of memory. How\n  does it\n  protect that?</p>\n</blockquote>\n<p>First it's important to note that <a href=\"https://en.wikipedia.org/wiki/Virtual_memory\" rel=\"nofollow\">virtual memory</a> mapping is realized partly by an external hardware component, called a <a href=\"https://en.wikipedia.org/wiki/Memory_management_unit\" rel=\"nofollow\">memory management unit</a>. It might be integrated in the CPU chip, or not. Additionally to being able to map various virtual memory addresses to physical ones, it supports also marking these addresses with different flags, one of which enables and disables writing protection.</p>\n<p>When the CPU tries to write on virtual address, marked as read-only, thus write-protected, (for examble by <a href=\"http://riffwiki.com/MOV_(x86_instruction)\" rel=\"nofollow\">MOV instruction</a>), the MMU fires a page fault exception on the CPU.</p>\n<p>Same goes for trying to access a non-present virtual memory pages.</p>\n", "Id": "38508656", "LastEditDate": "2016-07-22T05:29:33.737", "ParentId": "38506726", "OwnerUserId": "2830225", "PostTypeId": "2", "Score": "2", "LastEditorUserId": "2830225"}, "38506726": {"CreationDate": "2016-07-21T14:17:30.890", "ViewCount": "568", "Id": "38506726", "Score": "3", "Title": "Can a process read/write at any address from it's virtual memory?", "LastEditorUserId": "2173917", "CommentCount": "11", "Body": "<p>Processes in OS have their own virtual address spaces. Say, I allocate some dynamic memory using malloc() function call in a c program and subtract some positive value(say 1000) from the address returned by it. Now, I try to read what is written on that location which should be fine but what about writing to that location? </p>\n<p>virtual address space also has some read only chunk of memory. How does it protect that?</p>\n", "Tags": "<c++><c><memory><memory-management><operating-system>", "LastEditDate": "2016-07-21T14:37:29.490", "LastActivityDate": "2016-07-22T17:25:35.890", "PostTypeId": "1", "AnswerCount": "8", "OwnerUserId": "2641059"}});