post_cb({"43732122": {"ViewCount": "524", "Body": "<p>I'm playing around with overloading operators in c++14, and I tried to match two types of arguments: any-old-const-char*, and a-string-literal.</p>\n<p>That is, I'm trying to see if I can discriminate between:</p>\n<pre><code>const char * run_time;\n</code></pre>\n<p>and</p>\n<pre><code>\"compile time\"\n</code></pre>\n<p>I wrote the code below, and as shown, when I try <code>span &gt;&gt; \"literal\"</code> it invoked the <code>const char*</code> function.</p>\n<p>When I <code>#if 0</code>-out the <code>const char*</code> version, the template version gets called just fine.</p>\n<p>If I change the template version to take an rvalue-reference (&amp;&amp;) parameter for <code>literal</code>, it doesn't compile.</p>\n<p>If I add a <code>const char (&amp;literal)[]</code> non-template version, the <code>const char*</code> version is still preferred. Removing the const-char* version, the template version is preferred.</p>\n<p>Can you explain this? In particular:</p>\n<ol>\n<li>Why is <code>const char*</code> preferred over <code>const char (&amp;)[N]</code>?</li>\n<li>Why is <code>const char (&amp;)[N]</code> preferred over <code>const char (&amp;)[]</code> (non-template)?</li>\n<li>Why is <code>const char (&amp;&amp;)[N]</code> unable to compile?</li>\n<li>Is there a \"right way\" to capture literal strings?</li>\n</ol>\n<p>Thanks.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;gsl/gsl&gt;\n#include &lt;type_name.h++&gt;\n\ntemplate&lt;unsigned N&gt;\nauto\noperator&gt;&gt;(gsl::span&lt;const char*,-1&gt;&amp; spn, const char (&amp;literal)[N])\n    -&gt; gsl::span&lt;const char*, -1&gt;&amp;\n{\n    cout &lt;&lt; \"Got array: \" &lt;&lt; literal &lt;&lt; endl;\n    return spn;\n}\n\nauto\noperator&gt;&gt;(gsl::span&lt;const char*,-1&gt;&amp; spn, const char *literal)\n    -&gt; gsl::span&lt;const char*, -1&gt;&amp;\n{\n    cout &lt;&lt; \"Got const-char*: \" &lt;&lt; literal &lt;&lt; endl;\n    return spn;\n}\n#if 0\n#endif\n\nint\nmain(int argc, const char *argv[])\n{\n    auto spn = gsl::span&lt;const char*&gt;(argv, argc);\n\n    cout &lt;&lt; type_name&lt;decltype(spn)&gt;() &lt;&lt; endl; // gsl::span&lt;const char *, -1&gt;\n\n    cout &lt;&lt; type_name&lt;decltype(\"literal\")&gt;() &lt;&lt; endl; // char const (&amp;)[8]\n\n    cout &lt;&lt; type_name&lt;decltype((\"literal\"))&gt;() &lt;&lt; endl; // char const (&amp;)[8]\n\n    auto helpx = \"literal\";\n    cout &lt;&lt; type_name&lt;decltype(helpx)&gt;() &lt;&lt; endl; // const char *\n\n\n    spn &gt;&gt; \"literal\"; // Got const-char*: literal\n\n    return 0;\n}\n</code></pre>\n<p><strong>Edit:</strong></p>\n<p>In case it matters, I'm compiling with:</p>\n<pre><code>c++ --std=c++14 -Iinclude   -c -o main.o main.c++\n</code></pre>\n<p>And c++ says:</p>\n<pre><code>$ c++ --version\nApple LLVM version 8.0.0 (clang-800.0.42.1)\nTarget: x86_64-apple-darwin16.5.0\nThread model: posix\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\n</code></pre>\n", "AcceptedAnswerId": "43732803", "Title": "Why is `\"literal\"` encouraged to decay to `const char*` in C++ argument type match?", "CreationDate": "2017-05-02T07:10:33.043", "Id": "43732122", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-02T07:22:28.207", "LastEditorUserId": "4029014", "LastActivityDate": "2017-05-02T07:51:53.810", "Score": "11", "OwnerUserId": "4029014", "Tags": "<c++><c++14>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43732122_43732803_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 2304}, "so_43732122_43732722_4": {"length": 6, "quality": 1.0, "section_id": 126}, "so_43732122_43732722_2": {"length": 18, "quality": 0.9, "section_id": 603}}, "n3337": {"so_43732122_43732803_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 2291}, "so_43732122_43732722_4": {"length": 6, "quality": 1.0, "section_id": 120}, "so_43732122_43732722_2": {"length": 18, "quality": 0.9, "section_id": 593}}, "n4659": {"so_43732122_43732803_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 2168}, "so_43732122_43732722_4": {"length": 6, "quality": 1.0, "section_id": 131}, "so_43732122_43732722_2": {"length": 18, "quality": 0.9, "section_id": 629}}}, "43732803": {"Id": "43732803", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43732122_43732803_0\">Why is <code>const char*</code> preferred over <code>const char (&amp;)[N]</code>?</p>\n</blockquote>\n<p>The reason for this is rather technical. Even though the decay of a string literal from <code>const char[N]</code> to <code>const char*</code> is a conversion, it falls into the \"lvalue transformation\" category and is therefore considered by [over.ics.rank]/3 to be as good as no conversion at all. Since \"no conversion\" is required for either overload, the non-template overload wins.</p>\n<blockquote>\n<p id=\"so_43732122_43732803_1\">Why is <code>const char (&amp;)[N]</code> preferred over <code>const char (&amp;)[]</code> (non-template)?</p>\n</blockquote>\n<p>It is not possible to bind a <em>reference to array of unknown bound</em> to a value of type <em>array of known bound</em>. Instead, a reference to array of unknown bound can only be bound to values that are themselves arrays of unknown bound.</p>\n<blockquote>\n<p id=\"so_43732122_43732803_2\">Why is <code>const char (&amp;&amp;)[N]</code> unable to compile?</p>\n</blockquote>\n<p>A string literal is an lvalue so I'm not sure why you would expect this to work.</p>\n<blockquote>\n<p id=\"so_43732122_43732803_3\">Is there a \"right way\" to capture literal strings?</p>\n</blockquote>\n<p>You can use a helper function template that captures its argument using a forwarding reference so as to not destroy any type information (<code>const char*</code> versus <code>const char[N]</code>) then dispatch on the type using template specialization. You'll probably also want to use SFINAE to make sure it is disabled if anything other than a <code>const char*</code> or <code>const char[N]</code> is passed in. To wit,</p>\n<pre><code>template &lt;bool b&gt;\nstruct f_helper;\n\ntemplate &lt;&gt;\nstruct f_helper&lt;true&gt; {\n    void do_it(const char*) {\n        puts(\"pointer\");\n    }\n};\n\ntemplate &lt;&gt;\nstruct f_helper&lt;false&gt; {\n    template &lt;std::size_t N&gt;\n    void do_it(const char (&amp;)[N]) {\n        printf(\"array of length %zd\\n\", N);\n    }\n};\n\ntemplate &lt;class T, class = typename std::enable_if&lt;std::is_same&lt;char*, std::decay_t&lt;T&gt;&gt;::value ||\n                                                   std::is_same&lt;const char*, std::decay_t&lt;T&gt;&gt;::value&gt;::type&gt;\nvoid f(T&amp;&amp; s) {\n    f_helper&lt;std::is_pointer&lt;std::remove_reference_t&lt;T&gt;&gt;::value&gt;{}.do_it(s);\n}\n</code></pre>\n<p>Coliru link: <a href=\"http://coliru.stacked-crooked.com/a/0e9681868d715e87\" rel=\"noreferrer\">http://coliru.stacked-crooked.com/a/0e9681868d715e87</a></p>\n", "LastActivityDate": "2017-05-02T07:51:53.810", "CommentCount": "15", "CreationDate": "2017-05-02T07:51:53.810", "ParentId": "43732122", "Score": "9", "OwnerUserId": "481267"}, "43732722": {"Id": "43732722", "PostTypeId": "2", "Body": "<ol>\n<li>The overload taking a pointer is preffered because it is not a template according to</li>\n</ol>\n<blockquote>\n<p id=\"so_43732122_43732722_0\">13.3.3 Best viable function [over.match.best]</p>\n<p id=\"so_43732122_43732722_1\">...</p>\n<p id=\"so_43732122_43732722_2\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_43732122_43732722_3\">...</p>\n<p id=\"so_43732122_43732722_4\">(1.7)\n  F1 is not a function template specialization and F2 is a function template specialization</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>actually non-template <code>const char (&amp;)[]</code> does not seem to compile at all because it is a reference to a non-bound array. It is possible to pass a pointer like this <code>const char []</code>, but not array.</p></li>\n<li><p>this should fail at least for the same reason as (2)</p></li>\n<li>you can provide another template taking a reference to pointer:</li>\n</ol>\n<pre><code>template&lt; typename = void &gt; void\nfoo(char const * &amp; text)\n{\n    ::std::cout &lt;&lt; \"got ptr\" &lt;&lt; ::std::endl;\n}\n</code></pre>\n<p>Note that providing another template taking a pointer won't work because both template specializations will be fine and we'll get ambiguous choice of overloaded functions.</p>\n", "LastActivityDate": "2017-05-02T07:47:04.847", "CommentCount": "0", "CreationDate": "2017-05-02T07:47:04.847", "ParentId": "43732122", "Score": "1", "OwnerUserId": "7860670"}});