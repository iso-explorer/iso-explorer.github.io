post_cb({"36583663": {"Id": "36583663", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36583533_36583663_0\">Of course, this code will work only, if <code>x</code> and <code>y</code> are stored in \"straight-code\" </p>\n</blockquote>\n<p>I'm guessing the term you're looking for is <a href=\"https://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow\">endianness</a>. However, regardless of the endianness of your system, <code>(x &lt;&lt; 4) | y</code> gives you the same value. Math is <strong>endian-agnostic</strong>. Math is just math. The only difference is what the memory layout is - and for a single byte, even that doesn't matter.</p>\n<p>We can work through an example. Let's say <code>x</code> is <code>0x0A0B0C0D</code> and <code>y</code> is <code>0x01020304</code>. If your system is big-endian, that means the memory layout is:</p>\n<pre><code>x            : 0A 0B 0C 0D\ny            : 01 02 03 04\nx &lt;&lt; 4       : A0 B0 C0 D0\n(x &lt;&lt; 4) | y : A1 B2 C3 D4\nto char      :          D4\n</code></pre>\n<p>If it was little-endian:</p>\n<pre><code>x            : 0D 0C 0B 0A\ny            : 04 03 02 01\nx &lt;&lt; 4       : D0 C0 B0 A0\n(x &lt;&lt; 4) | y : D4 C3 B2 A1\nto char      : D4\n</code></pre>\n<p>Either way, <code>0xD4</code>.</p>\n<hr/>\n<p>Although, one thing you do have to worry about is the actual conversion to <code>char</code>. From [conv.integral]:</p>\n<blockquote>\n<p id=\"so_36583533_36583663_1\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). <em>[ Note:</em> In a two\u2019s\n  complement representation, this conversion is conceptual and there is no change in the bit pattern (if there\n  is no truncation). <em>\u2014end note ]</em></p>\n<p id=\"so_36583533_36583663_2\">If the destination type is signed, the value is unchanged if it can be represented in the destination type;\n  otherwise, the value is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>If <code>char</code> is unsigned, that part is well-defined. If it's signed, it's not. So prefer to use <code>unsigned char</code> for <code>my_code</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-04-12T21:40:02.543", "Score": "4", "CreationDate": "2016-04-12T20:42:15.477", "ParentId": "36583533", "CommentCount": "18", "OwnerUserId": "2069064", "LastEditDate": "2016-04-12T21:40:02.543"}, "bq_ids": {"n4140": {"so_36583533_36583663_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_36583533_36583663_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}, "n3337": {"so_36583533_36583663_1": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_36583533_36583663_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 29}}, "n4659": {"so_36583533_36583663_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_36583533_36583663_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}}, "36585377": {"Id": "36585377", "PostTypeId": "2", "Body": "<p>Don't try to hack things yourself. The compiler is perfectly capable of doing this directly:</p>\n<pre><code>struct Packed {\n  unsigned x : 4;\n  unsigned y : 4;\n};\n</code></pre>\n<p>You'd better have a few million of those, else the saving isn't really worthwhile.</p>\n", "LastActivityDate": "2016-04-12T22:40:45.397", "CommentCount": "0", "CreationDate": "2016-04-12T22:40:45.397", "ParentId": "36583533", "Score": "1", "OwnerUserId": "15416"}, "36583533": {"ViewCount": "148", "Body": "<p>I am playing with state-space, which requires very effective storage of explored states. That means, I need to store multiple information in a variable that's as small as possible.</p>\n<p>Let's have a very simple example: Imagine I'd like to store two coordinates. I can create a struct of two integers, but each integer is (correct me if I am wrong) 32b. But neither of my coordinates is greater than <strong>15</strong>. With zero, it is 16 = 2^4 distinct values, which means I only need 8b store both of them. So with some bitwise operator magic, I am able to store these two values inside a single <code>char</code>:</p>\n<pre><code>unsigned int x, y; // initialized!!!!!\nchar my_code = (x &lt;&lt; 4) | y;\n</code></pre>\n<p>Of course, this code will work only, if <code>x</code> and <code>y</code> are stored in \"straight-code\" (<strong>I am not sure about this name.</strong> It is simple binary representation of number, from biggest bit 2^n to 2^1 )</p>\n<p>So my question is: <strong>which binary codes are used to store which fundamental C/C++ variables?</strong></p>\n<p><strong>EDIT:</strong> Premature optimalization? No. My current task is small and it is preparation for bigger problem, where I need to store 4 coordinates from 0 to 7. Thoose coordinates are positions on board 8x8. So I need to keep track of many many unique combinations - because state-space searching is based on generating new states, which weren't already explored.</p>\n<p>There is no possible way of storing multiple ints and using custom comparator function and <code>set</code>. For big problems like this, my memory would bleed and keeping track of what I already visited wouldn't be nice either. Bitset with size of possible combinations is probably the best way. (You might say, that problem, that I described is too big for bitset that large, but there is neat trick to handle it, UNIMPORTANT for this question.) So, I need some sort of \"hash\", which can be created many ways - using modular arithmetics (one type of answers) or bitwise operations. Complexity between these two solutions aren't much different for todays computer to matter. Because I am curious, I wanted to use more exotic second way. But for that to work, I needed to know, how are numbers stored at binary level - if there is some verid coding, which would my idea make absolutely unusable.</p>\n<p>My question wasn't about size of variables either - those are well documented.</p>\n", "AcceptedAnswerId": "36583663", "Title": "How are the values of fundamental C/C++ types physically stored?", "CreationDate": "2016-04-12T20:33:55.643", "Id": "36583533", "CommentCount": "35", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-04-13T09:22:11.967", "LastEditorUserId": "2471974", "LastActivityDate": "2016-04-13T09:22:11.967", "ClosedDate": "2016-04-13T05:57:28.337", "Score": "-4", "OwnerUserId": "2471974", "Tags": "<c++><c><memory><binary-data>", "AnswerCount": "4"}, "36584210": {"Id": "36584210", "PostTypeId": "2", "Body": "<p>C does not mandate sizes for <code>short</code>, <code>int</code>, or <code>long</code>; it specifies the ranges of values they must be able to represent.  An <code>unsigned int</code> must be able to represent <em>at least</em> values in the range 0 to 65535, meaning it must be <em>at least</em> 16 bits wide, although it may (and often is) wider.  A signed <code>int</code> must represent <em>at least</em> the range -32767 to 32767.  Note that C does not mandate two's complement representation, which is why the lower value is -32767 and not -32768.  </p>\n<p>Also, these types may have <em>padding bits</em> in addition to value bits.  I've never worked on an implementation that used padding bits in integral types.  </p>\n<p>Integral values are stored in the value bits using regular binary representation (i.e., N bits, leftmost bit is the most significant bit).  </p>\n<p>C99 added the <code>stdint.h</code> header, which defines integer types that have exact widths and no padding bits.  If your values really do range from 0 to 15, then I'd suggest you use <code>uint8_t</code> (8 bits, unsigned) for each.  Since these types fit into a single byte, you won't have any endianness issues.  </p>\n", "LastActivityDate": "2016-04-12T21:17:12.997", "CommentCount": "1", "CreationDate": "2016-04-12T21:17:12.997", "ParentId": "36583533", "Score": "0", "OwnerUserId": "134554"}, "36584448": {"Id": "36584448", "PostTypeId": "2", "Body": "<p>C/C++ standards do not enforce particular representation for <a href=\"https://en.wikipedia.org/wiki/Integer_(computer_science)\" rel=\"nofollow\">integral types</a>. Actually, the standards allow three different representations --  two's complement, ones's complement, and signed magnitude representation. Luckily, positive numbers look the same in all of the representations.</p>\n<p>Anyway, you do not have to care about it -- simply avoid bit manipulation operators as follows. If the range of your coordinates is [0, N), you can pack them into a wider data type as:</p>\n<pre><code>code = N * x + y;\n</code></pre>\n<p>or</p>\n<pre><code>code = N * N * x + N * y + z;\n</code></pre>\n<p>For N = 16, you can pack two coordinates into a single <code>unsigned char</code> as:</p>\n<pre><code>unsigned char code = 16*x + y;\n</code></pre>\n", "LastActivityDate": "2016-04-12T21:31:31.997", "CommentCount": "8", "CreationDate": "2016-04-12T21:31:31.997", "ParentId": "36583533", "Score": "0", "OwnerUserId": "1729784"}});