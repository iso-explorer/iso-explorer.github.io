post_cb({"13516339": {"Id": "13516339", "PostTypeId": "2", "Body": "<p>This is an expected result. You can verify this by looking at the underlying assembly. For example, if I build with:</p>\n<pre><code>g++ -S ptr.c\n</code></pre>\n<p>then you can see the following in the file output (ptr.s):</p>\n<pre><code>        .file   \"ptr.c\"\n        .def    ___main;        .scl    2;      .type   32;     .endef\n        .section .rdata,\"dr\"\nLC0:\n        .ascii \"Hello\\0\"               ; Note - \"Hello\" only appears once in\n                                       ; this data section!\nLC1:\n        .ascii \"=\\0\"\nLC2:\n        .ascii \"!=\\0\"\n        .text\n.globl _main\n        .def    _main;  .scl    2;      .type   32;     .endef\n_main:\n        [... some stuff deleted for brevity ...]\nLCFI5:\n        call    ___main\n        movl    $LC0, -12(%ebp)        ; This sets str1\n        movl    $LC0, -8(%ebp)         ; This sets str2\n        movl    -12(%ebp), %eax\n</code></pre>\n<p>I've commented the two key bits -- only one appearance of 'Hello' is in the rdata section of the underlying code, and you can see str1 and str2 are set towards the end, both pointing to the same label: <code>LC0</code>. This is beacuse 'Hello' is a string literal and, importantly, is <em>constant</em>.</p>\n<p>As others have pointed out - this is perfectly legal under the standards.</p>\n", "LastActivityDate": "2012-11-22T15:58:41.510", "Score": "2", "CreationDate": "2012-11-22T15:58:41.510", "ParentId": "13515561", "CommentCount": "0", "OwnerUserId": "130352"}, "13515561": {"ViewCount": "1095", "Body": "<p>When I run this program using MinGW, im getting output as \"=\"</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n char *str1 = \"Hello\";\n char *str2 = \"Hello\";\n\n if(str1==str2)\n cout&lt;&lt;\"=\";\n else\n cout&lt;&lt;\"!=\";\n\n\n return 0;\n}\n</code></pre>\n<p>However, logically, it should be !=, coz these are pointers and they are pointing to different memory locations. When I run this code in my Turbo C++, i get !=</p>\n", "Title": "Two string literals have the same pointer value?", "CreationDate": "2012-11-22T15:11:54.500", "LastActivityDate": "2012-11-22T16:26:31.500", "CommentCount": "5", "LastEditDate": "2012-11-22T16:06:19.640", "PostTypeId": "1", "LastEditorUserId": "130352", "Id": "13515561", "Score": "6", "OwnerUserId": "922305", "Tags": "<c++><string><pointers>", "AnswerCount": "5"}, "13515607": {"Id": "13515607", "PostTypeId": "2", "Body": "<p>You are right in that they are pointers. However, whether they are pointing to different locations or not depends on the implementation. It is perfectly valid for a compiler to store a string literal just once and use its address wherever it's used in code.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2012-11-22T16:04:25.163", "Score": "13", "CreationDate": "2012-11-22T15:14:08.390", "ParentId": "13515561", "CommentCount": "0", "LastEditDate": "2012-11-22T16:04:25.163", "OwnerUserId": "1782465"}, "13515992": {"Id": "13515992", "PostTypeId": "2", "Body": "<p><code>char *str1 = \"Hello\";</code> -- this line, while allowed (by many compilers), is a bad idea to actually do.  It is basically only permitted for backward compatibility with C, and actually writing to *str1 results in undefined behavior.  I would recommend finding the compiler setting that gives you warnings when you do this, and if your compiler lacks such warnings finding a new compiler.</p>\n<p>The C++ standard gives compilers and execution environments ridiculous amounts of freedom about where <code>\"String literals\"</code> are stored.  They could literally use a pointer to the <code>\"literal\"</code> part of <code>\"String literals\"</code> as the pointer value for <code>\"literal\"</code>, and storing them in memory in which you'd segfault when you attempt to edit them is not unexpected.</p>\n<p>Note that <code>char buf1[] = \"Hello\";</code> does something fundamentally different than <code>char* str1 = \"Hello\";</code>: it actually initializes the buffer <code>buf1</code> with the characters <code>{'H','e','l','l','o','\\0'}</code>.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2012-11-22T16:26:31.500", "Score": "0", "CreationDate": "2012-11-22T15:37:28.780", "ParentId": "13515561", "CommentCount": "1", "LastEditDate": "2012-11-22T16:26:31.500", "OwnerUserId": "1774667"}, "13515903": {"Id": "13515903", "PostTypeId": "2", "Body": "<p>There are no guarantees that the two pointers are pointing to different memory locations. Maybe it is because optimizations, or the compiler uses its own rules... the behavior is \"Implementation De\ufb01ned\".</p>\n<p>According to the standard (C++11 \u00a72.14.5 String Literals):</p>\n<blockquote>\n<p id=\"so_13515561_13515903_0\">Whether all string literals are distinct (that is, are stored\n  in nonoverlapping objects) is implementation de\ufb01ned.</p>\n</blockquote>\n", "LastActivityDate": "2012-11-22T15:32:18.680", "Score": "8", "CreationDate": "2012-11-22T15:32:18.680", "ParentId": "13515561", "CommentCount": "0", "OwnerUserId": "438720"}, "13516556": {"Id": "13516556", "PostTypeId": "2", "Body": "<p>The type of a string literal like <code>\"Hello\"</code> is <em>array of <strong>const</strong> char</em>, therefore, you are directing two pointers to something that is not allowed to ever change. </p>\n<p>The C++ standard gives compilers the freedom to merge identical constant values together (note that compilers are not <em>required</em> to do so).</p>\n<p>Related: The declarations are therefore invalid and must be modified to:</p>\n<pre><code>const char *str1 = \"Hello\";\nconst char *str2 = \"Hello\";\n</code></pre>\n<p>or if you want</p>\n<pre><code>char const *str1 = \"Hello\";\nchar const *str2 = \"Hello\";\n</code></pre>\n<p>which reads nicely when reading right-to-left:</p>\n<pre><code>str1 is a pointer to const char\n</code></pre>\n<p>.</p>\n", "LastActivityDate": "2012-11-22T16:13:07.607", "Score": "2", "CreationDate": "2012-11-22T16:13:07.607", "ParentId": "13515561", "CommentCount": "0", "OwnerUserId": "76722"}, "bq_ids": {"n4140": {"so_13515561_13515903_0": {"length": 8, "quality": 0.8, "section_id": 5361}}, "n3337": {"so_13515561_13515903_0": {"length": 8, "quality": 0.8, "section_id": 5157}}, "n4659": {"so_13515561_13515903_0": {"length": 8, "quality": 0.8, "section_id": 6789}}}});