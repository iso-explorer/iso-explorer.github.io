post_cb({"15613125": {"ParentId": "15612700", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's only a guess, but they might have written that to imply that <code>it</code> is now \"invalid\" in the sense that it is no longer a valid iterator of <code>mylist1</code>, but instead becomes a valid iterator of <code>mylist2</code>.</p>\n<p>But still, and I guess you already knew that, it is a valid iterator, so the wording is misleading. You need to be careful, though, as it means that after the second splice-operation, for example, you can no longer do:</p>\n<pre><code>std::distance( mylist1.begin(), it );\n</code></pre>\n<p>but need to use</p>\n<pre><code>std::distance( mylist2.begin(), it );\n</code></pre>\n<p>as the first would be illegal.</p>\n<p>The standard clearly defines it that way in:</p>\n<blockquote>\n<h3>23.3.5.5 list operations [list.ops]</h3>\n<p id=\"so_15612700_15613125_0\"><code>void splice(const_iterator position, list&amp; x, const_iterator i);</code><br>\n<code>void splice(const_iterator position, list&amp;&amp; x, const_iterator i);</code></br></p>\n<p id=\"so_15612700_15613125_1\"><sup>7</sup> <em>Effects:</em> Inserts an element pointed to by <code>i</code> from list <code>x</code> before <code>position</code> and removes the element from <code>x</code>. The result is unchanged if <code>position == i</code> or <code>position == ++i</code>. Pointers and references to <code>*i</code> continue to refer to this same element but as a member of <code>*this</code>. Iterators to <code>*i</code> (including <code>i</code> itself) continue to refer to the same element, but now behave as iterators into <code>*this</code>, not into <code>x</code>.</p>\n</blockquote>\n<p>So, if your compiler/STL invalidates the iterator, this is clearly a bug.</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-03-25T11:24:06.370", "Id": "15613125", "Score": "3", "CreationDate": "2013-03-25T10:52:13.687", "LastActivityDate": "2013-03-25T11:24:06.370"}, "15613548": {"ParentId": "15612700", "CommentCount": "1", "Body": "<p>Apparently (since I'm using MSVC2012) the behavior is different:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/72fb8wzd.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/72fb8wzd.aspx</a></p>\n<blockquote>\n<p id=\"so_15612700_15613548_0\">In all cases, only iterators or references that point at spliced\n  elements become invalid.</p>\n</blockquote>\n<p>Thus when I have iterators to elements that get moved from one container to another, these iterators become invalid.</p>\n<p>I'd be interested in knowing if this behavior is the standard one, though.</p>\n", "OwnerUserId": "1494037", "PostTypeId": "2", "Id": "15613548", "Score": "1", "CreationDate": "2013-03-25T11:15:24.927", "LastActivityDate": "2013-03-25T11:15:24.927"}, "bq_ids": {"n4140": {"so_15612700_15613125_1": {"section_id": 929, "quality": 0.9428571428571428, "length": 33}, "so_15612700_15613125_0": {"section_id": 928, "quality": 1.0, "length": 10}}, "n3337": {"so_15612700_15613125_1": {"section_id": 917, "quality": 0.9428571428571428, "length": 33}, "so_15612700_15613125_0": {"section_id": 916, "quality": 1.0, "length": 10}}, "n4659": {"so_15612700_15613125_1": {"section_id": 991, "quality": 0.9428571428571428, "length": 33}, "so_15612700_15613125_0": {"section_id": 989, "quality": 1.0, "length": 10}}}, "15612700": {"CommentCount": "6", "AcceptedAnswerId": "15613125", "CreationDate": "2013-03-25T10:29:33.880", "LastActivityDate": "2013-03-25T11:24:06.370", "PostTypeId": "1", "ViewCount": "1234", "FavoriteCount": "2", "Title": "STL list::splice - iterator validity", "Id": "15612700", "Score": "3", "Body": "<p>I'm reading how \"<a href=\"http://www.cplusplus.com/reference/list/list/splice/\" rel=\"nofollow\">list::splice</a>\" works and I don't understand something:</p>\n<pre><code>  mylist1.splice (it, mylist2); // mylist1: 1 10 20 30 2 3 4\n                                // mylist2 (empty)\n                                // \"it\" still points to 2 (the 5th element)\n\n  mylist2.splice (mylist2.begin(),mylist1, it);\n                                // mylist1: 1 10 20 30 3 4\n                                // mylist2: 2\n                                // \"it\" is now invalid.\n  it = mylist1.begin();\n  std::advance(it,3);           // \"it\" points now to 30\n\n  mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());\n                                // mylist1: 30 3 4 1 10 20\n</code></pre>\n<p>in the first and third splice the <strong>it</strong> iterator is still valid, but why isn't it in the second splice?</p>\n<p>According to the documentation:</p>\n<blockquote>\n<p id=\"so_15612700_15612700_0\">Iterator validity </p>\n<p id=\"so_15612700_15612700_1\">No changes on the iterators, pointers and references\n  related to the container before the call. <strong>The iterators, pointers and\n  references that referred to transferred elements keep referring to\n  those same elements</strong>, but iterators now iterate into the container the\n  elements have been transferred to.</p>\n</blockquote>\n<p>thus it should still be valid</p>\n", "Tags": "<c++><list><stl>", "OwnerUserId": "1494037", "AnswerCount": "2"}});