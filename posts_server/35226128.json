post_cb({"35226128": {"CommentCount": "10", "AcceptedAnswerId": "35226186", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2016-02-05T14:04:16.237", "LastActivityDate": "2016-02-06T23:12:02.693", "LastEditDate": "2016-02-05T16:25:02.753", "ViewCount": "4866", "FavoriteCount": "10", "Title": "Are C/C++ fundamental types atomic?", "Id": "35226128", "Score": "57", "Body": "<p>Are C/C++ fundamental types, like <code>int</code>, <code>double</code>, etc., atomic, e.g. threadsafe?</p>\n<p>Are they free from data races; that is, if one thread writes to an object of such a type while another thread reads from it, is the behavior well-defined?</p>\n<p>If not, does it depend on the compiler or something else?</p>\n", "Tags": "<c++><c><multithreading><atomic>", "OwnerUserId": "2098831", "AnswerCount": "4"}, "35226186": {"ParentId": "35226128", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>No, fundamental data types (e.g., <code>int</code>, <code>double</code>) are not atomic, see <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\"><code>std::atomic</code></a>.</p>\n<p>Instead you can use <code>std::atomic&lt;int&gt;</code> or <code>std::atomic&lt;double&gt;</code>.</p>\n<p><strong>Note:</strong> <code>std::atomic</code> was introduced with C++11 and my understanding is that prior to C++11, the C++ standard didn't recognize the existence of multithreading at all.</p>\n<hr>\n<p>As pointed out by @Josh, <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic_flag\"><code>std::atomic_flag</code></a> is an atomic boolean type. It is <strong>guaranteed to be lock-free</strong>, unlike the <code>std::atomic</code> specializations.</p>\n<hr>\n<p>The quoted documentation is from: <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf</a>. I'm pretty sure the standard is not free and therefore this isn't the final/official version.</p>\n<h3>1.10 Multi-threaded executions and data races</h3>\n<blockquote id=\"so_35226128_35226186_0\">\n<ol start=\"6\">\n<li>Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one reads or modifies the same memory location.</li>\n<li>The library defines a number of atomic operations (Clause 29) and operations on mutexes (Clause 30) that are specially identified as synchronization operations. These operations play a special role in making assignments in one thread visible to another. A synchronization operation on one or more memory locations is either a consume operation, an acquire operation, a release operation, or both an acquire and release operation. A synchronization operation without an associated memory location is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence. In addition, there are relaxed atomic operations, which are not synchronization operations, and atomic read-modify-write operations, which have special characteristics.</li>\n</ol>\n</blockquote>\n<p><br/></p>\n<blockquote id=\"so_35226128_35226186_1\">\n<ol start=\"23\">\n<li>Two actions are potentially concurrent if\n  <br>\n  (23.1) \u2014 they are performed by different threads, or\n  <br>\n  (23.2) \u2014 they are unsequenced, and at least one is performed by a signal handler.\n  <br>\n  The execution of a program contains a data race if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other, except for the special case for signal handlers described below. Any such data race results in undefined behavior.</br></br></br></li>\n</ol>\n</blockquote>\n<h3>29.5 Atomic types</h3>\n<blockquote id=\"so_35226128_35226186_2\">\n<ol start=\"4\">\n<li>There shall be explicit specializations of the atomic template for the integral types ``char, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long</code>, <code>char16_</code>t, <code>char32_t</code>, <code>wchar_t</code>, and any other types needed by the typedefs in the header <code>&lt;cstdint&gt;</code>. For each integral type integral, the specialization <code>atomic&lt;integral&gt;</code> provides additional atomic operations appropriate to integral types. There shall be a specialization <code>atomic&lt;bool&gt;</code> which provides the general atomic operations as specified in 29.6.1..</li>\n</ol>\n</blockquote>\n<p><br/></p>\n<blockquote id=\"so_35226128_35226186_3\">\n<ol start=\"6\">\n<li>There shall be pointer partial specializations of the atomic class template. These specializations shall have standard layout, trivial default constructors, and trivial destructors. They shall each support aggregate initialization syntax.</li>\n</ol>\n</blockquote>\n<h3>29.7 Flag type and operations</h3>\n<blockquote id=\"so_35226128_35226186_4\">\n<ol start=\"2\">\n<li>Operations on an object of type atomic_flag shall be lock-free. [ Note: Hence the operations should also be address-free. No other type requires lock-free operations, so the atomic_flag type is the minimum hardware-implemented type needed to conform to this International standard. The remaining types can be emulated with atomic_flag, though with less than ideal properties. \u2014 end note ]</li>\n</ol>\n</blockquote>\n</hr></hr>", "OwnerUserId": "4505712", "LastEditorUserId": "4505712", "LastEditDate": "2016-02-06T15:52:45.843", "Id": "35226186", "Score": "67", "CreationDate": "2016-02-05T14:08:19.237", "LastActivityDate": "2016-02-06T15:52:45.843"}, "35226482": {"ParentId": "35226128", "CommentCount": "4", "Body": "<p>Since C is also (currently) mentioned in the question despite not being in the tags, the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">C Standard</a> states:</p>\n<blockquote>\n<p id=\"so_35226128_35226482_0\"><strong>5.1.2.3 Program execution</strong></p>\n<p id=\"so_35226128_35226482_1\">...</p>\n<p id=\"so_35226128_35226482_2\">When the processing of the abstract machine is interrupted by receipt\n  of a signal, the values of objects that are neither lock-free atomic\n  objects nor of type <code>volatile sig_atomic_t</code> are unspecified, as is the\n  state of the floating-point environment. The value of any object\n  modified by the handler that is neither a lock-free atomic object nor\n  of type <code>volatile sig_atomic_t</code> becomes indeterminate when the handler\n  exits, as does the state of the floating-point environment if it is\n  modified by the handler and not restored to its original state.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_35226128_35226482_3\"><strong>5.1.2.4  Multi-threaded executions and data races</strong></p>\n<p id=\"so_35226128_35226482_4\">...</p>\n<p id=\"so_35226128_35226482_5\">Two expression  evaluations\n  <em>conflict</em> if one of them modifies a memory location and the other one reads or modifies the same memory location.</p>\n<p id=\"so_35226128_35226482_6\">[several pages of standards - some paragraphs explicitly addressing atomic types]</p>\n<p id=\"so_35226128_35226482_7\">The execution of a program contains a\n  <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens\n  before the other.  <strong>Any such data race results in undefined behavior.</strong></p>\n</blockquote>\n<p>Note that values are \"indeterminate\" if a signal interrupts processing, and simultaneous access to types that are not explicitly atomic is undefined behavior.</p>\n", "OwnerUserId": "4756299", "PostTypeId": "2", "Id": "35226482", "Score": "15", "CreationDate": "2016-02-05T14:23:37.113", "LastActivityDate": "2016-02-05T14:23:37.113"}, "35234900": {"ParentId": "35226128", "PostTypeId": "2", "CommentCount": "4", "Body": "<h1>What is atomic?</h1>\n<p>Atomic, as describing something with the property of an atom. The word atom originates from Latin <a href=\"http://dictionary.reference.com/browse/atom?s=t\" rel=\"nofollow\">atomus</a> meaning \"undivided\".</p>\n<p>Typically I think of an atomic operation (regardless of language) to have two qualities:</p>\n<h3>An atomic operation is always undivided.</h3>\n<p>I.e. it is performed in an indivisible way, I believe this is what OP refers to as \"threadsafe\". In a sense the operation happens instantaneously when viewed by another thread.</p>\n<p>For example the following operation is likely divided (compiler/hardware dependent):</p>\n<pre><code>i += 1;\n</code></pre>\n<p>because it can be observed by another thread (on hypothetical hardware and compiler) as:</p>\n<pre><code>load r1, i;\naddi r1, #1;\nstore i, r1;\n</code></pre>\n<p>Two threads doing the above operation <code>i += 1</code> without appropriate synchronization may produce the wrong result. Say <code>i=0</code> initially, thread <code>T1</code> loads <code>T1.r1 = 0</code>, and the thread <code>T2</code> loads <code>t2.r1 = 0</code>. Both threads increment their respective <code>r1</code>s by 1 and then store the result to <code>i</code>. Although two increments have been performed, the value of <code>i</code> is still only 1 because the increment operation was divisible. Note that had there been synchronization before and after <code>i+=1</code> the other thread would have waited until the operation was complete and thus would have observed an undivided operation.</p>\n<p>Note that even a simple write may or may not be undivided:</p>\n<pre><code>i = 3;\n\nstore i, #3;\n</code></pre>\n<p>depending on the compiler and hardware. For example if the address of <code>i</code> is not aligned suitably, then an unaligned load/store has to be used which is executed by the CPU as several smaller loads/stores.</p>\n<h3>An atomic operation has guaranteed memory ordering semantics.</h3>\n<p>Non atomic operations may be re-ordered and may not necessarily occur in the order written in the program source code.</p>\n<p>For example, under the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">\"as-if\" rule</a> the compiler is allowed to re-order stores and loads as it sees fit as long as all access to volatile memory occurs in the order specified by the program \"as if\" the program was evaluated according to the wording in the standard. Thus non-atomic operations may be re-arranged breaking any assumptions about execution order in a multi-threaded program. This is why a seemingly innocent use of a raw <code>int</code> as a signaling variable in multi-threaded programming is broken, even if writes and reads may be indivisible, the ordering may break the program depending on the compiler. An atomic operation enforces ordering of the operations around it depending on what memory semantics are specified. See <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\"><code>std::memory_order</code></a>.</p>\n<p>The CPU may also re-order your memory accesses under the memory ordering constraints of that CPU. You can find the memory ordering constraints for the x86 architecture in the <a href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf\" rel=\"nofollow\">Intel 64 and IA32 Architectures Software Developer Manual</a> section 8.2 starting at page 2212.</p>\n<h1>Primitive types (<code>int</code>, <code>char</code> etc) are not Atomic</h1>\n<p>Because even if they under certain conditions may have indivisible store and load instructions or possibly even some arithmetic instructions, they do not guarantee the ordering of stores and loads. As such they are unsafe to use in multi-threaded contexts without proper synchronization to guarantee that the memory state observed by other threads is what you think it is at that point in time. </p>\n<p>I hope this explains <em>why</em> primitive types are not atomic. </p>\n", "OwnerUserId": "2498188", "LastEditorUserId": "2498188", "LastEditDate": "2016-02-06T23:12:02.693", "Id": "35234900", "Score": "8", "CreationDate": "2016-02-05T22:51:55.193", "LastActivityDate": "2016-02-06T23:12:02.693"}, "35235437": {"ParentId": "35226128", "CommentCount": "0", "Body": "<p>An additional info I haven't seen mentioned in the other answers so far:</p>\n<p>If you use <code>std::atomic&lt;bool&gt;</code>, for example, and <code>bool</code> is actually atomic on the target architecture, then the compiler will not generate any redundant fences or locks. The same code would be generated as for a plain <code>bool</code>.</p>\n<p>In other words, using <code>std::atomic</code> only makes the code less efficient if it is actually required to for correctness on the platform. So there is no reason to avoid it.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "35235437", "Score": "3", "CreationDate": "2016-02-05T23:45:42.300", "LastActivityDate": "2016-02-05T23:45:42.300"}, "bq_ids": {"n4140": {"so_35226128_35226482_7": {"section_id": 5834, "quality": 0.8, "length": 20}, "so_35226128_35226186_0": {"section_id": 5818, "quality": 0.7931034482758621, "length": 69}, "so_35226128_35226186_4": {"section_id": 1219, "quality": 0.8888888888888888, "length": 32}, "so_35226128_35226186_1": {"section_id": 5834, "quality": 0.8775510204081632, "length": 43}, "so_35226128_35226482_5": {"section_id": 5817, "quality": 0.875, "length": 14}, "so_35226128_35226186_2": {"section_id": 1168, "quality": 0.9482758620689655, "length": 55}, "so_35226128_35226186_3": {"section_id": 1170, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_35226128_35226482_7": {"section_id": 5605, "quality": 0.88, "length": 22}, "so_35226128_35226186_0": {"section_id": 5589, "quality": 0.7931034482758621, "length": 69}, "so_35226128_35226186_4": {"section_id": 1217, "quality": 0.8888888888888888, "length": 32}, "so_35226128_35226482_5": {"section_id": 5588, "quality": 0.875, "length": 14}, "so_35226128_35226186_2": {"section_id": 1166, "quality": 0.9310344827586207, "length": 54}, "so_35226128_35226186_3": {"section_id": 1168, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_35226128_35226186_1": {"section_id": 7296, "quality": 0.8775510204081632, "length": 43}, "so_35226128_35226482_5": {"section_id": 7278, "quality": 0.9375, "length": 15}, "so_35226128_35226482_7": {"section_id": 7296, "quality": 0.8, "length": 20}, "so_35226128_35226186_0": {"section_id": 7279, "quality": 0.7931034482758621, "length": 69}, "so_35226128_35226186_2": {"section_id": 1286, "quality": 0.8103448275862069, "length": 47}}}});