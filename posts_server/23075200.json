post_cb({"bq_ids": {"n4140": {"so_23075200_23077680_0": {"length": 22, "quality": 1.0, "section_id": 6017}}, "n3337": {"so_23075200_23077680_0": {"length": 22, "quality": 1.0, "section_id": 5785}}, "n4659": {"so_23075200_23077680_0": {"length": 22, "quality": 1.0, "section_id": 7516}}}, "23075200": {"ViewCount": "563", "Body": "<p>In the last two lines of below program, <code>static_cast&lt;void*&gt;</code> and <code>dynamic_cast&lt;void *&gt;</code> behave differently. From what I understand, The result of a <code>dynamic_cast&lt;void*&gt;</code> always resolves to the address of the complete object. So it uses RTTI in some way. Could anyone explain how compilers uses RTTI to differentiate between the two.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Top {\nprotected:\nint x;\npublic:\n    Top(int n) { x = n; }\n    virtual ~Top() {} \n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Top&amp; t) {\n        return os &lt;&lt; t.x;\n    }\n};\nclass Left : virtual public Top {\nprotected:\n    int y;\npublic:\n    Left(int m, int n) : Top(m) { y = n; }\n};\nclass Right : virtual public Top {\nprotected:\n    int z;\npublic:\n    Right(int m, int n) : Top(m) { z = n; }\n};\nclass Bottom : public Left, public Right {\n    int w; \npublic:\n    Bottom(int i, int j, int k, int m): Top(i), Left(0, j), Right(0, k) { w = m; }\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Bottom&amp; b) {\n        return os &lt;&lt; b.x &lt;&lt; ',' &lt;&lt; b.y &lt;&lt; ',' &lt;&lt; b.z&lt;&lt; ',' &lt;&lt; b.w;\n    }\n};\nint main() {\n    Bottom b(1, 2, 3, 4);\n    cout &lt;&lt; sizeof b &lt;&lt; endl;\n    cout &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; static_cast&lt;void*&gt;(&amp;b) &lt;&lt; endl;\n    Top* p = static_cast&lt;Top*&gt;(&amp;b);\n    cout &lt;&lt; *p &lt;&lt; endl;\n    cout &lt;&lt; p &lt;&lt; endl;\n    cout &lt;&lt; static_cast&lt;void*&gt;(p) &lt;&lt; endl;\n    cout &lt;&lt; dynamic_cast&lt;void*&gt;(p) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Possible output: <a href=\"https://ideone.com/WoX5DI\">https://ideone.com/WoX5DI</a></p>\n<pre><code>28\n1,2,3,4\n0xbfcce604\n1\n0xbfcce618\n0xbfcce618\n0xbfcce604\n</code></pre>\n", "AcceptedAnswerId": "23077680", "Title": "dynamic_cast vs static_cast to void*", "CreationDate": "2014-04-15T05:18:46.183", "Id": "23075200", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-04T21:40:55.787", "LastEditorUserId": "3235496", "LastActivityDate": "2014-06-04T21:40:55.787", "Score": "8", "OwnerUserId": "1023638", "Tags": "<c++><casting><void-pointers><dynamic-cast>", "AnswerCount": "1"}, "23077680": {"Id": "23077680", "PostTypeId": "2", "Body": "<p>From 5.2.7 / 7:</p>\n<blockquote>\n<p id=\"so_23075200_23077680_0\">If T is \"pointer to cv void,\" then the result is a pointer to the most\n  derived object pointed to by v. Otherwise, a run-time check is applied\n  to see if the object pointed or referred to by v can be converted to\n  the type pointed or referred to by T.</p>\n</blockquote>\n<p>So using <code>dynamic_cast&lt;void*&gt;(o)</code> you get a pointer to the first byte of the most \"derived\" object (if <code>o</code> is polymorphic).</p>\n<p>The code the compiler generates for <code>dynamic_cast&lt;void *&gt;(...)</code> is something like:</p>\n<pre><code>static_cast&lt;void*&gt;(dynamic_cast&lt;most_derived_type *&gt;(...))\n</code></pre>\n<p>This property is often used for serialization.</p>\n", "LastActivityDate": "2014-04-15T07:54:05.023", "CommentCount": "1", "CreationDate": "2014-04-15T07:54:05.023", "ParentId": "23075200", "Score": "9", "OwnerUserId": "3235496"}});