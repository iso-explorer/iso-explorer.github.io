post_cb({"19881804": {"ParentId": "19881803", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The code is not <em>undefined</em> pre-<em>C++11</em> but the evaluation order is <em>unspecified</em>. If we look at the draft standard section <code>1.9</code> <em>Program execution</em> paragraph <em>12</em> says:</p>\n<blockquote>\n<p id=\"so_19881803_19881804_0\">A full-expression is an expression that is not a subexpression of another expression. [...]</p>\n</blockquote>\n<p>and paragraph <em>15</em> says:</p>\n<blockquote>\n<p id=\"so_19881803_19881804_1\">There is a sequence point at the completion of evaluation of each full-expression<sup>12)</sup>.</p>\n</blockquote>\n<p>then the question is whether <code>count++, count++</code> is a <em>full expression</em> and each <code>count++</code> a <em>sub-expression</em> or is each <code>count++</code> it's own <em>full expression</em> and therefore there is <em>sequence point</em> after each one? if we look at the grammar for this initialization from section <code>8.5</code> <em>Initializers</em>:</p>\n<pre><code>initializer-clause:\n  assignment-expression\n  { initializer-list ,opt }\n  { }\ninitializer-list:\n  initializer-clause\n  initializer-list , initializer-clause\n</code></pre>\n<p>the only <em>expression</em> we have is an <em>assignment-expression</em> and the <code>,</code> separating the components is part of the <em>initializer-list</em> and and not part of an <em>expression</em> and therefore each <code>count++</code> is a <em>full expression</em> and there is a <em>sequence point</em> after each one.</p>\n<p>This interpretation is confirmed by the following <code>gcc</code> <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11633\" rel=\"nofollow\">bug report</a>, which has very similar code to mine(<em>I came up with my example way before I found this bug report</em>):</p>\n<pre><code>int count = 23;\nint foo[] = { count++, count++, count++ };\n</code></pre>\n<p>which ends up as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#430\" rel=\"nofollow\">defect report 430</a>, which I will quote:</p>\n<blockquote>\n<p id=\"so_19881803_19881804_2\">[...]I believe the standard is clear that each initializer expression in the above is a full-expression (1.9 [intro.execution]/12-13; see also issue 392) and therefore there is a sequence point after each expression (1.9 [intro.execution]/16). I agree that the standard does not seem to dictate the order in which the expressions are evaluated, and perhaps it should. Does anyone know of a compiler that would not evaluate the expressions left to right?</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-02-22T04:09:46.477", "Id": "19881804", "Score": "4", "CreationDate": "2013-11-09T18:59:54.483", "LastActivityDate": "2014-02-22T04:09:46.477"}, "19881803": {"CommentCount": "0", "ViewCount": "448", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-11-09T18:59:54.483", "LastActivityDate": "2014-12-15T14:28:10.687", "Title": "Are multiple mutations of the same variable within initializer lists undefined behavior pre C++11", "FavoriteCount": "3", "LastEditDate": "2017-05-23T12:01:03.210", "Id": "19881803", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>int main()\n{\n    int count = 0 ;\n    int arrInt[2] = { count++, count++ } ;\n\n    return 0 ;\n}\n</code></pre>\n<p>If we compile the code using <code>clang -std=c++03</code> it produces the following warning(<em><a href=\"http://coliru.stacked-crooked.com/a/69309c28d23554c2\" rel=\"nofollow noreferrer\">live example</a></em>):</p>\n<pre><code>warning: multiple unsequenced modifications to 'count' [-Wunsequenced]\n    int arrInt[2] = { count++, count++ } ;\n                           ^        ~~\n</code></pre>\n<p>I am not advocating for code like this but similar code came up in another question and there was disagreement over whether it is <em>defined</em> or not according to the standard pre-<em>C++11</em>. In <em>C++11</em> this behavior is well defined behavior according to <a href=\"https://stackoverflow.com/q/14442894/1708801\">Are multiple mutations within initializer lists undefined behavior</a> and indeed if I use <code>-std=c++11</code> then the warning goes away.</p>\n<p>If we look at a pre-<em>C++11</em> <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">draft standard</a> it does not have the same language covering <em>initializer-list</em> so it seems we are left with <code>Chapter 5</code> <em>Expressions</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_19881803_19881803_0\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.<sup>57)</sup> Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; otherwise the behavior is undefined.</p>\n</blockquote>\n<p>In order for this to be <em>undefined</em> it would seem we would have to interpret <code>count++, count++</code> as an <em>expression</em> and therefore each <code>count++</code> as a <em>subexpression</em>, so is this code <em>undefined</em> pre-<em>C++11</em>?</p>\n", "Tags": "<c++><language-lawyer><undefined-behavior><initializer-list>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19881803_19881804_0": {"section_id": 5806, "quality": 0.8, "length": 4}}, "n3337": {"so_19881803_19881804_0": {"section_id": 5579, "quality": 0.8, "length": 4}}, "n4659": {"so_19881803_19881804_0": {"section_id": 7267, "quality": 0.8, "length": 4}}}});