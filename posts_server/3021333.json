post_cb({"3023223": {"Id": "3023223", "PostTypeId": "2", "Body": "<p>I will notice that you admit there is an issue here. And you are aware of the potential drawbacks.</p>\n<p>My question is one of maintenance. Do you feel confident that nobody will ever include a field in this class that would botch up your great optimization ? I don't, I'm an engineer not a prophet.</p>\n<p>So instead of trying to improve the copy operation.... why not try to avoid it altogether ?</p>\n<p>Would it be possible to change the data structure used for storage to stop moving elements around... or at least not that much.</p>\n<p>For example, do you know of <code>blist</code> (the Python module). B+Tree can allow index access with performances quite similar to vectors (a bit slower, admittedly) for example, while minimizing the number of elements to shuffle around when inserting / removing.</p>\n<p>Instead of going in the quick and dirty, perhaps should you focus on finding a better collection ?</p>\n", "LastActivityDate": "2010-06-11T13:42:34.463", "Score": "3", "CreationDate": "2010-06-11T13:42:34.463", "ParentId": "3021333", "CommentCount": "0", "OwnerUserId": "147192"}, "3022901": {"Id": "3022901", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3021333_3022901_0\">[...] but are there any other hidden nasties\n  I should be aware of?</p>\n</blockquote>\n<p>Yes: your code makes certain assumptions that are neither suggested nor documented (unless you specifically document them). This is <em>a nightmare</em> for maintenance.</p>\n<p>Also, your implementation is basically hacking (if it's necessary it's not a bad thing) and it may depend (not sure on this) on how your current compiler implements things.</p>\n<p>This means that if you upgrade compiler / toolchain one year (or five) from now (or just change optimization settings in your current compiler) nobody will remember this hack (unless you make a big effort to keep it visible) and you may end up with undefined behavior on your hands, and developers cursing \"whoever did this\" a few years down the road.</p>\n<p>It's not that the decision is unsound, it's that it is (or will be) unexpected to maintainers.</p>\n<p>To minimize this (unexpectedness?) I would move the class into a structure within a namespace based on the current name of the class, with no internal functions in the structure at all. Then you are making it clear you're looking at a memory block and treating it as a memory block.</p>\n<p>Instead of:</p>\n<pre><code>class MyClass\n{\npublic:\n    MyClass();\n    int a,b,c;\n    double x,y,z;\n};\n\n#define  PageSize 1000000\n\nMyClass Array1[PageSize],Array2[PageSize];\n\nmemcpy(Array1,Array2,PageSize*sizeof(MyClass));\n</code></pre>\n<p>You should have:</p>\n<pre><code>namespace MyClass // obviously not a class, \n                  // name should be changed to something meaningfull\n{\n    struct Data\n    {\n        int a,b,c;\n        double x,y,z;\n    };\n\n    static const size_t PageSize = 1000000; // use static const instead of #define\n\n\n    void Copy(Data* a1, Data* a2, const size_t count)\n    {\n        memcpy( a1, a2, count * sizeof(Data) );\n    }\n\n    // any other operations that you'd have declared within \n    // MyClass should be put here\n}\n\nMyClass::Data Array1[MyClass::PageSize],Array2[MyClass::PageSize];\nMyClass::Copy( Array1, Array2, MyClass::PageSize );\n</code></pre>\n<p>This way you:</p>\n<ul>\n<li><p>make it clear that MyClass::Data is a POD structure, not a class (binary they will be the same or very close - the same if I remember correctly) but this way it is also visible to programmers reading the code.</p></li>\n<li><p>centralize the usage of memcpy (if you have to change to a std::copy or something else) in two years you do it in a single point.</p></li>\n<li><p>keep the usage of memcpy near the implementation of the POD structure.</p></li>\n</ul>\n", "LastEditorUserId": "186997", "LastActivityDate": "2013-11-07T15:30:12.557", "Score": "7", "CreationDate": "2010-06-11T13:00:23.497", "ParentId": "3021333", "CommentCount": "4", "LastEditDate": "2013-11-07T15:30:12.557", "OwnerUserId": "186997"}, "3021435": {"Id": "3021435", "PostTypeId": "2", "Body": "<p>Your class has a constructor, and so is not POD in the sense that a C struct is. It is therefore not safe to copy it with memcpy(). If you want POD data, remove the constructor. If you want non-POD data, where controlled construction is essential, don't use memcpy() - you can't have both.</p>\n", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastActivityDate": "2010-06-11T08:57:51.857", "Score": "9", "CreationDate": "2010-06-11T08:48:52.220", "ParentId": "3021333", "CommentCount": "2", "LastEditDate": "2010-06-11T08:57:51.857"}, "3021619": {"Id": "3021619", "PostTypeId": "2", "Body": "<p>When talking about the case you're referring to I suggest you declare <strong>struct</strong>'s instead of <strong>class</strong>'es. It makes it a lot easier to read (and less debatable :) ) and the default access specifier is public. </p>\n<p>Of course you can use memcpy in this case, but beware that adding other kinds of elements in the struct (like C++ classes) is not recommended (due to obvious reasons - you don't know how memcpy will influence them).</p>\n", "LastActivityDate": "2010-06-11T09:17:29.017", "Score": "1", "CreationDate": "2010-06-11T09:17:29.017", "ParentId": "3021333", "CommentCount": "2", "OwnerUserId": "13136"}, "bq_ids": {"n4140": {"so_3021333_3022238_0": {"length": 22, "quality": 0.7333333333333333, "section_id": 450}, "so_3021333_3021396_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 3296}, "so_3021333_3021396_0": {"length": 10, "quality": 1.0, "section_id": 7207}, "so_3021333_3021396_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5854}}, "n3337": {"so_3021333_3022238_0": {"length": 22, "quality": 0.7333333333333333, "section_id": 441}, "so_3021333_3021396_0": {"length": 10, "quality": 1.0, "section_id": 6951}, "so_3021333_3021396_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 3166}, "so_3021333_3021396_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5624}}, "n4659": {"so_3021333_3022238_0": {"length": 22, "quality": 0.7333333333333333, "section_id": 472}, "so_3021333_3021396_0": {"length": 10, "quality": 1.0, "section_id": 8716}, "so_3021333_3021396_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 4058}, "so_3021333_3021396_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 7333}}}, "3022052": {"Id": "3022052", "PostTypeId": "2", "Body": "<p>Let me give you an empirical answer: in our realtime app, we do this all the time, and it works just fine. This is the case in MSVC for Wintel and PowerPC and GCC for Linux and Mac, even for classes that have constructors. </p>\n<p>I can't quote chapter and verse of the C++ standard for this, just experimental evidence.</p>\n", "LastActivityDate": "2010-06-11T10:34:59.127", "Score": "10", "CreationDate": "2010-06-11T10:34:59.127", "ParentId": "3021333", "CommentCount": "6", "OwnerUserId": "53543"}, "3021396": {"Id": "3021396", "PostTypeId": "2", "Body": "<p>You could use <code>memcpy</code> for copying array of POD types. And it will be a good idea to add static assert for <code>boost::is_pod</code> is true. You class is not a POD type now.</p>\n<blockquote>\n<p id=\"so_3021333_3021396_0\">Arithmetic types, enumeration types, pointer types, and pointer to member types are POD.</p>\n<p id=\"so_3021333_3021396_1\">A cv-qualified version of a POD type is itself a POD type.</p>\n<p id=\"so_3021333_3021396_2\">An array of POD is itself POD.\n  A struct or union, all of whose non-static data members are POD, is itself POD if it has:</p>\n<ul>\n<li>No user-declared constructors.</li>\n<li>No private or protected non-static data members.</li>\n<li>No base classes.</li>\n<li>No virtual functions.</li>\n<li>No non-static data members of reference type.</li>\n<li>No user-defined copy assignment operator.</li>\n<li>No user-defined destructor.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "123111", "LastActivityDate": "2010-06-11T10:47:41.750", "Score": "5", "CreationDate": "2010-06-11T08:42:59.147", "ParentId": "3021333", "CommentCount": "3", "LastEditDate": "2010-06-11T10:47:41.750", "OwnerUserId": "123111"}, "3021392": {"Id": "3021392", "PostTypeId": "2", "Body": "<p>It will work, because a (POD-) class is the same as a struct (not completely, default access ...), in C++. And you may copy a POD struct with memcpy.</p>\n<p>The definition of POD was no virtual functions, no constructor, deconstructor no virtual inheritance ... etc.</p>\n", "LastActivityDate": "2010-06-11T08:42:28.220", "Score": "0", "CreationDate": "2010-06-11T08:42:28.220", "ParentId": "3021333", "CommentCount": "1", "OwnerUserId": "3186"}, "3021465": {"Id": "3021465", "PostTypeId": "2", "Body": "<p>Calling  memcpy on non-POD classes is undefined behaviour. I suggest to follow Kirill's tip for assertion. Using memcpy can be faster, but if the copy operation is not performance critical in your code then just use bitwise copy. </p>\n", "LastActivityDate": "2010-06-11T08:52:47.770", "Score": "1", "CreationDate": "2010-06-11T08:52:47.770", "ParentId": "3021333", "CommentCount": "1", "OwnerUserId": "259275"}, "3022238": {"Id": "3022238", "PostTypeId": "2", "Body": "<p>According to the Standard, if no copy constructor is provided by the programmer for a class, the compiler will synthesize a constructor which exhibits <em>default memberwise initialization</em>. (12.8.8)  However, in 12.8.1, the Standard also says,</p>\n<blockquote>\n<p id=\"so_3021333_3022238_0\">A class object can be copied in two\n  ways, by initialization (12.1, 8.5),\n  including for function argument\n  passing (5.2.2) and for function value\n  return (6.6.3), and by assignment\n  (5.17). Conceptually, these two\n  operations are implemented by a copy\n  constructor (12.1) and copy assignment\n  operator (13.5.3).</p>\n</blockquote>\n<p>The operative word here is \"conceptually,\" which, according to <a href=\"http://rads.stackoverflow.com/amzn/click/0201834545\" rel=\"noreferrer\">Lippman</a> gives compiler designers an 'out' to actually doing memberwise initialization in \"trivial\" (12.8.6) implicitly defined copy constructors.</p>\n<p>In practice, then, compilers have to synthesize copy constructors for these classes that exhibit behavior as if they were doing memberwise initialization.  But if the class exhibits \"Bitwise Copy Semantics\" (Lippman, p. 43) then the compiler does not have to synthesize a copy constructor (which would result in a function call, possibly inlined) and do bitwise copy instead.  This claim is apparently backed up in the <a href=\"http://rads.stackoverflow.com/amzn/click/0201514591\" rel=\"noreferrer\">ARM</a>, but I haven't looked this up yet.</p>\n<p>Using a compiler to validate that something is Standard-compliant is always a bad idea, but compiling your code and viewing the resulting assembly seems to verify that the compiler is not doing memberwise initialization in a synthesized copy constructor, but doing a <code>memcpy</code> instead:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nclass MyClass\n{\npublic:\n    MyClass(){};\n  int a,b,c;\n  double x,y,z;\n};\n\nint main()\n{\n    MyClass c;\n    MyClass d = c;\n\n    return 0;\n}\n</code></pre>\n<p>The assembly generated for <code>MyClass d = c;</code> is:</p>\n<pre><code>000000013F441048  lea         rdi,[d] \n000000013F44104D  lea         rsi,[c] \n000000013F441052  mov         ecx,28h \n000000013F441057  rep movs    byte ptr [rdi],byte ptr [rsi] \n</code></pre>\n<p>...where <code>28h</code> is the <code>sizeof(MyClass)</code>. </p>\n<p>This was compiled under MSVC9 in Debug mode.</p>\n<h2>EDIT:</h2>\n<p>The long and the short of this post is that:</p>\n<p>1) So long as doing a bitwise copy will exhibit the same side effects as memberwise copy would, the Standard allows trivial implicit copy constructors to do a <code>memcpy</code> instead of memberwise copies.</p>\n<p>2) Some compilers actually do <code>memcpy</code>s instead of synthesizing a trivial copy constructor which does memberwise copies.</p>\n", "LastEditorUserId": "241536", "LastActivityDate": "2010-06-11T11:28:17.427", "Score": "11", "CreationDate": "2010-06-11T11:15:19.143", "ParentId": "3021333", "CommentCount": "1", "LastEditDate": "2010-06-11T11:28:17.427", "OwnerUserId": "241536"}, "3021352": {"Id": "3021352", "PostTypeId": "2", "Body": "<p>You <em>could</em>. But first ask yourself:</p>\n<p>Why not just use the copy-constructor that is provided by your compiler to do a member-wise copy? </p>\n<p>Are you having specific performance problems for which you need to optimise?</p>\n<p>The current implementation contains all POD-types: what happens when somebody changes it?</p>\n", "LastEditorUserId": "78845", "LastActivityDate": "2010-06-11T09:15:01.437", "Score": "9", "CreationDate": "2010-06-11T08:36:24.813", "ParentId": "3021333", "CommentCount": "10", "LastEditDate": "2010-06-11T09:15:01.437", "OwnerUserId": "78845"}, "3021333": {"ViewCount": "17567", "Body": "<p>Say I have a class, something like the following;</p>\n<pre><code>class MyClass\n{\npublic:\n  MyClass();\n  int a,b,c;\n  double x,y,z;\n};\n\n#define  PageSize 1000000\n\nMyClass Array1[PageSize],Array2[PageSize];\n</code></pre>\n<p>If my class has not pointers or virtual methods, is it safe to use the following?</p>\n<pre><code>memcpy(Array1,Array2,PageSize*sizeof(MyClass));\n</code></pre>\n<p>The reason I ask, is that I'm dealing with very large collections of paged data, as decribed <a href=\"https://stackoverflow.com/questions/2472944/good-c-array-class-for-dealing-with-large-arrays-of-data-in-a-fast-and-memory-e\">here</a>, where performance is critical, and memcpy offers significant performance advantages over iterative assignment.  I suspect it should be ok, as the 'this' pointer is an implicit parameter rather than anything stored, but are there any other hidden nasties I should be aware of?  </p>\n<p><strong>Edit:</strong> </p>\n<p>As per sharptooths comments, the data does not include any handles or similar reference information.</p>\n<p>As per Paul R's comment, I've profiled the code, and avoiding the copy constructor is about 4.5 times faster in this case. Part of the reason here is that my templated array class is somewhat more complex than the simplistic example given, and calls a placement 'new' when allocating memory for types that don't allow shallow copying.  This effectively means that the default constructor is called as well as the copy constructor.</p>\n<p><strong>Second edit</strong></p>\n<p>It is perhaps worth pointing out that I fully accept that use of memcpy in this way is bad practice and should be avoided in general cases.  The specific case in which it is being used is as part of a high performance templated array class, which includes a parameter 'AllowShallowCopying', which will invoke memcpy rather than a copy constructor.  This has big performance implications for operations such as removing an element near the start of an array, and paging data in and out of secondary storage.  The better theoretical solution would be to convert the class to a simple structure, but given this involves a lot of refactoring of a large code base, avoiding it is not something I'm keen to do.</p>\n", "AcceptedAnswerId": "3022052", "Title": "Can I use memcpy in C++ to copy classes that have no pointers or virtual functions", "CreationDate": "2010-06-11T08:34:11.663", "Id": "3021333", "CommentCount": "14", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:17.723", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-07T15:30:12.557", "Score": "24", "OwnerUserId": "22564", "Tags": "<c++><performance><shallow-copy>", "AnswerCount": "10"}});