post_cb({"bq_ids": {"n4140": {"so_25873338_25873889_2": {"length": 5, "quality": 1.0, "section_id": 6885}, "so_25873338_25873889_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 6887}, "so_25873338_25873889_3": {"length": 4, "quality": 0.8, "section_id": 6886}}, "n3337": {"so_25873338_25873889_2": {"length": 5, "quality": 1.0, "section_id": 6631}, "so_25873338_25873889_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 6633}, "so_25873338_25873889_3": {"length": 4, "quality": 0.8, "section_id": 6632}}, "n4659": {"so_25873338_25873889_2": {"length": 5, "quality": 1.0, "section_id": 8385}, "so_25873338_25873889_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 8387}, "so_25873338_25873889_3": {"length": 4, "quality": 0.8, "section_id": 8386}}}, "25873889": {"Id": "25873889", "PostTypeId": "2", "Body": "<p>Ignoring whether that is a good programming practice or not ...</p>\n<p>Your program is safe from the language point of view. Comparison of <code>type_info</code>, the valued returned by the <code>typeid</code> operator, is well defined in the standard:</p>\n<blockquote>\n<p id=\"so_25873338_25873889_0\"><strong>18.5.1 Class type_info</strong></p>\n<p id=\"so_25873338_25873889_1\">...</p>\n<p id=\"so_25873338_25873889_2\"><code>bool operator==(const type_info&amp; rhs) const;</code></p>\n<p id=\"so_25873338_25873889_3\">2 <strong>Effects:</strong> Compares the current object with <em>rhs</em>.</p>\n<p id=\"so_25873338_25873889_4\">3 <strong>Returns:</strong> <code>true</code> if the two values describe the same type.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-16T16:24:25.920", "Score": "0", "CreationDate": "2014-09-16T16:24:25.920", "ParentId": "25873338", "CommentCount": "0", "OwnerUserId": "434551"}, "25873338": {"ViewCount": "4668", "Body": "<p>I would like to know if doing the following is safe:</p>\n<pre><code>template&lt;class T&gt;\nvoid Parameters::add(Parameter&lt;T&gt; p)\n{\n   std::string sprobe(\"\");\n   int iprobe = 0;\n   double dprobe = 0.;\n\n   if (typeid(T) == typeid(sprobe))\n     this-&gt;mstrings[p.name()] = p;\n\n   if (typeid(T) == typeid(iprobe))\n     this-&gt;mints[p.name()] = p;\n\n   if (typeid(T) == typeid(dprobe))\n     this-&gt;mdoubles[p.name()] = p;\n}\n</code></pre>\n<p>I have a Class for storing parameters. It has 3 boost::unordered_map member variables for storing parameters of type int, double and std::string;</p>\n<p>I created a template class Parameter.</p>\n<p>I understand that if my Parameter is not one of the 3 types that I anticipated this will fail. But it is not a problem since I know that the Parameters can only be of these types.</p>\n<p>Thanks for your help </p>\n", "Title": "Using typeid to check for template type", "CreationDate": "2014-09-16T15:56:06.803", "LastActivityDate": "2014-09-16T16:25:22.273", "CommentCount": "5", "PostTypeId": "1", "Id": "25873338", "Score": "1", "OwnerUserId": "3891144", "Tags": "<c++><templates><typeid>", "AnswerCount": "2"}, "25873901": {"Id": "25873901", "PostTypeId": "2", "Body": "<p>The code won't compile, but not because of <code>typeid</code>. The problem is that even with the correct <code>if</code>-clauses, the code of your method needs to be compiled - all of it. That is independent of whether or not a part of the code is executed (=evaluated) or not. This leads to the problem that if <code>T</code> is <code>int</code>, you still need to be able to compile the code for the other cases, e.g., this line:</p>\n<pre><code>this-&gt;mstrings[p.name()] = p;\n</code></pre>\n<p>The type of <code>mstrings</code> is very likely incompatible with passing <code>Parameter&lt;int&gt;</code> as <code>p</code>, hence you will get a compile error.</p>\n<p>The solution is to use overloading where each method must only compile one case, but not the others, example for <code>int</code>:</p>\n<pre><code>void Parameters::add(Parameter&lt;int&gt; p)\n{\n    this-&gt;mints[p.name()] = p;\n}\n</code></pre>\n<p>and likewise for the other cases.</p>\n<p>Final note: Even if you use <code>typeid</code>, you don't need the probes. You can simply use <code>typeid(int)</code> directly.</p>\n", "LastActivityDate": "2014-09-16T16:25:22.273", "Score": "4", "CreationDate": "2014-09-16T16:25:22.273", "ParentId": "25873338", "CommentCount": "0", "OwnerUserId": "2073257"}});