post_cb({"42099342": {"ParentId": "42098826", "CommentCount": "1", "Body": "<p>One effect of virtual inheritance is that downcasting by <code>static_cast</code> doesn't work. If you want to downcast from a virtual base, you must use <code>dynamic_cast</code> instead.</p>\n<pre><code>A* pa = new B;\nB* pb1 = static_cast&lt;B*&gt;(pa); // doesn't work: compilation error\nB* pb2 = dynamic_cast&lt;B*&gt;(pa); // works\n</code></pre>\n<p>Quoted from Standard (5.2.9):</p>\n<blockquote>\n<p id=\"so_42098826_42099342_0\">A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to a prvalue of type \u201cpointer to cv2 D,\u201d ... if ... B\n  is neither a virtual base class of D nor a base class of a virtual base class of D.</p>\n</blockquote>\n", "OwnerUserId": "509868", "PostTypeId": "2", "Id": "42099342", "Score": "2", "CreationDate": "2017-02-07T20:27:28.653", "LastActivityDate": "2017-02-07T20:27:28.653"}, "42098826": {"CommentCount": "6", "ViewCount": "80", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-02-07T19:57:37.700", "LastActivityDate": "2017-02-10T20:36:48.407", "Title": "virtual inheritance in the non-diamond inheritance tree - memory & behavior side-effects", "FavoriteCount": "1", "LastEditDate": "2017-02-10T20:36:48.407", "Id": "42098826", "Score": "0", "Body": "<p>I understand the <strong>effect</strong> of <em>virtual inheritance</em> in diamond inheritance tree but not the side-effects (if any) in a non-diamond inheritance tree.</p>\n<p>If you just have </p>\n<pre><code>class A;\n\nclass B: public virtual A;\n</code></pre>\n<p>What differences are there in <strong>behavior</strong> or <strong>memory layout</strong> (if any) of these two classes i.e. order of constructor calls, etc.</p>\n<p>Assume <code>class A</code> has data members.</p>\n<p><strong><em>Please provide official documentation for your answer</em></strong></p>\n", "Tags": "<c++><abi><virtual-inheritance><memory-layout>", "OwnerUserId": "4784683", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42098826_42099342_0": {"section_id": 6037, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_42098826_42099342_0": {"section_id": 5805, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_42098826_42099342_0": {"section_id": 43, "quality": 0.8260869565217391, "length": 19}}}, "42102077": {"ParentId": "42098826", "CommentCount": "0", "Body": "<p>Regarding the memory layout, some compilers might place the virtual base's data members <strong>after</strong> the subclass's data members (see <a href=\"http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074\" rel=\"nofollow noreferrer\">Multiple Inheritance Considered Useful</a>):</p>\n<pre><code>class A {\npublic:\n    int a;\n};\n\nclass B : public virtual A {\npublic:\n    int b;\n};\n\nint main() {\n    B b;\n\n    std::cout &lt;&lt; \"&amp;b.a &lt; &amp;b.b = \" &lt;&lt; (&amp;(b.a) &lt; &amp;(b.b)) &lt;&lt; std::endl; // &amp;b.a &lt; &amp;b.b =  = 0\n\n    return 0;\n}\n</code></pre>\n<p>On the other hand, non-virtual base's data members are usually placed <strong>before</strong> the child's data members:</p>\n<pre><code>class A {\npublic:\n    int a;\n};\n\nclass B : public virtual A {\npublic:\n    int b;\n};\n\nint main() {\n    B b;\n\n    std::cout &lt;&lt; \"&amp;b.a &lt; &amp;b.b = \" &lt;&lt; (&amp;(b.a) &lt; &amp;(b.b)) &lt;&lt; std::endl; // &amp;b.a &lt; &amp;b.b = 1\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "5652184", "PostTypeId": "2", "Id": "42102077", "Score": "0", "CreationDate": "2017-02-07T23:40:41.240", "LastActivityDate": "2017-02-07T23:40:41.240"}});