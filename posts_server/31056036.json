post_cb({"31056191": {"ParentId": "31056036", "CommentCount": "2", "Body": "<p>First one calls a constructor of Rectangle which is passed a temp Point object. </p>\n<p>Second one is copy constructed from a temp Rectangle class which is constructed the same way as the first one. </p>\n<p>Second one incurs an extra move/copy operation. </p>\n", "OwnerUserId": "597973", "PostTypeId": "2", "Id": "31056191", "Score": "0", "CreationDate": "2015-06-25T16:47:49.863", "LastActivityDate": "2015-06-25T16:47:49.863"}, "31056036": {"CommentCount": "1", "ViewCount": "93", "PostTypeId": "1", "ClosedDate": "2015-06-25T16:50:31.263", "LastEditorUserId": "5045227", "CreationDate": "2015-06-25T16:38:50.080", "LastActivityDate": "2015-06-25T17:01:42.033", "Title": "Is this a short hand variable declaration?", "AcceptedAnswerId": "31056162", "LastEditDate": "2015-06-25T16:43:05.473", "Id": "31056036", "Score": "2", "Body": "<p>Seen this in a book I'm reading:</p>\n<pre><code>Rectangle r(Point(200,200));\n</code></pre>\n<p>Is this the same as:</p>\n<pre><code>Rectangle r = Rectangle(Point(200,200));\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "5045227", "AnswerCount": "2"}, "31056162": {"ParentId": "31056036", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In:</p>\n<pre><code>Rectangle r(Point(200,200));\n</code></pre>\n<p>you are initializing a <code>Rectangle</code> object via a constructor that takes a <code>Point</code> object.</p>\n<p>In:</p>\n<pre><code>Rectangle r = Rectangle(Point(200,200));\n</code></pre>\n<p>you are constructing a <code>Rectangle</code> temporary object as above and then passing it to the copy/move constructor of <code>Rectangle</code>.</p>\n<p>If the copy constructor is properly written, then the resulting objects are the same, but one more copy/move constructor would be theoretically called in the latter.</p>\n<p>This is not true if the compiler decides to elide the copy, according to \u00a712.8/31:</p>\n<blockquote>\n<p id=\"so_31056036_31056162_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side eects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two dierent ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.122 This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_31056036_31056162_1\">[...]</p>\n<ul>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n<p id=\"so_31056036_31056162_2\">[...]</p>\n</blockquote>\n<p>If the contructor that takes a <code>Point</code>\u00a0is not marked <code>explicit</code>, then you could also have the form:</p>\n<pre><code>Rectangle r = Point(200,200);\n</code></pre>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2015-06-25T17:01:42.033", "Id": "31056162", "Score": "2", "CreationDate": "2015-06-25T16:45:49.527", "LastActivityDate": "2015-06-25T17:01:42.033"}, "bq_ids": {"n4140": {"so_31056036_31056162_0": {"section_id": 480, "quality": 0.9393939393939394, "length": 62}}, "n3337": {"so_31056036_31056162_0": {"section_id": 471, "quality": 0.8939393939393939, "length": 59}}, "n4659": {"so_31056036_31056162_0": {"section_id": 502, "quality": 0.9393939393939394, "length": 62}}}});