post_cb({"22419578": {"CommentCount": "0", "ViewCount": "52", "PostTypeId": "1", "LastEditorUserId": "2864740", "CreationDate": "2014-03-15T04:34:24.990", "LastActivityDate": "2014-03-15T04:54:38.023", "Title": "Why are there two definitions of operator[]?", "LastEditDate": "2014-03-15T04:47:49.403", "Id": "22419578", "Score": "2", "Body": "<p>I'm currently working on material from my data structures class, which involves an exercise where we attempt to define a class mimicking a vector so we can get an understanding of what's going on underneath the hood. Everything made sense until I realized that there are two definitions for<code>operator[]</code>. In context:</p>\n<pre><code>typedef unsigned int size_type;\nT&amp; operator[] (size_type i) { return m_data[i]; }\nconst T&amp; operator[] (size_type i) const { return m_data[i]; }\n</code></pre>\n<p>First question: why is it necessary to have two definitions of <code>operator[]</code>?</p>\n<p>Second question: why doesn't this throw a multiple definitions error?</p>\n<p>Sorry if anything is vague or seems obvious. I'm new to C++, my only other experience being in Java. Thanks!</p>\n", "Tags": "<c++><operators><operator-overloading><const>", "OwnerUserId": "3422258", "AnswerCount": "4"}, "22419633": {"ParentId": "22419578", "CommentCount": "0", "Body": "<p>This is a common C++ pattern.</p>\n<p>The <code>const</code> member function (that is, the one with the keyword <code>const</code> <em>after</em> the prototype) applies when <code>*this</code> is <code>const</code>; in other words, if it is used with a <code>const</code> object. Since <code>*this</code> is const, it's reasonable to assume that it cannot be modified, so <code>operator[]</code> must return a const reference.</p>\n<p>The other member function would apply to any object, but since it is less specific than the <code>const</code> one, it only applies if <code>*this</code> is not <code>const</code>. In that case, it is presumably possible to modify the returned reference (<code>object[3] = new_value;</code>), so the return type is not <code>const</code>. </p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "22419633", "Score": "2", "CreationDate": "2014-03-15T04:43:47.673", "LastActivityDate": "2014-03-15T04:43:47.673"}, "22419715": {"ParentId": "22419578", "CommentCount": "0", "Body": "<p>Each function can be recognized by what you can call <code>signature</code>, when you <code>declare</code> a function in C++ you write the signature of the function, a signature looks like</p>\n<pre><code>qualifiers T ( qualifiers U u ) qualifiers;\n############ ------------------ ::::::::::\n</code></pre>\n<p>so the signature it's composed of the 2 part that I outlined with <code>#</code> and <code>-</code>, the part with <code>#</code> is the return type and the part <code>-</code> is the description for the arguments accepted by the function.</p>\n<p>The point is that if you write the same signature with different <code>qualifiers</code>, <code>C++</code> still considers this the re-declaration/re-definition of the same function, so <code>qualifiers</code> are part of the signature but when comparing multiple declarations/definitions of functions with the same name they are virtually dropped by your compiler.</p>\n<p>You should read more about qualifiers, I simplified the concept here.</p>\n<p>You can also add more qualifiers after the signature, the part I outlined with <code>:</code>, to declare some properties about the way your function works, for example <code>const</code> means that you declare that your function doesn't modify the variables that it can access .</p>\n", "OwnerUserId": "2485710", "PostTypeId": "2", "Id": "22419715", "Score": "0", "CreationDate": "2014-03-15T04:54:38.023", "LastActivityDate": "2014-03-15T04:54:38.023"}, "22419598": {"ParentId": "22419578", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_22419578_22419598_0\"><strong>why is it necessary to have two definitions of operator[]?</strong></p>\n</blockquote>\n<p>It's necessary if you want one that you can modify its value (e.g. <code>obj[i] = value</code>) and the other cannot (with <code>const</code>).</p>\n<blockquote>\n<blockquote>\n<p id=\"so_22419578_22419598_2\"><strong>why doesn't this throw a multiple definitions error?</strong></p>\n</blockquote>\n</blockquote>\n<p>Based on <strong>$9.3.1/3 states-</strong></p>\n<blockquote>\n<p id=\"so_22419578_22419598_3\">\"A nonstatic member function may be declared const, volatile, or const volatile. <strong>These cvqualifiers affect the type of the this pointer (9.3.2). They also affect the function type (8.3.5) of the member function;</strong> a member function declared const is a const member function, a member function declared volatile is a volatile member function and a member function declared const volatile is a const volatile member function.\"</p>\n</blockquote>\n<p>That said, you can overload a function by using one of those qualifiers, e.g.:</p>\n<pre><code>void func();\nvoid func() const;\n</code></pre>\n", "OwnerUserId": "2589776", "LastEditorUserId": "2589776", "LastEditDate": "2014-03-15T04:53:26.037", "Id": "22419598", "Score": "2", "CreationDate": "2014-03-15T04:37:51.903", "LastActivityDate": "2014-03-15T04:53:26.037"}, "22419665": {"ParentId": "22419578", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_22419578_22419665_0\">First question: why is it necessary to have two definitions of\n  operator[]?</p>\n</blockquote>\n<p>Those definitions differ with their const-qualifier (and result type). One of them is const and returns const reference to internal data. It is used if your container is declaread as const, so that reference to it's contents are const as well. If your contianer is not const, non-const operator is used so that internal data can be modified.</p>\n<blockquote>\n<p id=\"so_22419578_22419665_1\">Second question: why doesn't this throw a multiple definitions error?</p>\n</blockquote>\n<p>Because const-qualifier is a part of function prototype, which means that <code>void foo();</code> and <code>void foo() const;</code> are actually two diffrent methods. It allows overloading based on const qualifier of object being used to call the method.</p>\n", "OwnerUserId": "455304", "PostTypeId": "2", "Id": "22419665", "Score": "2", "CreationDate": "2014-03-15T04:47:51.213", "LastActivityDate": "2014-03-15T04:47:51.213"}, "bq_ids": {"n4140": {"so_22419578_22419598_3": {"section_id": 5892, "quality": 0.8913043478260869, "length": 41}}, "n3337": {"so_22419578_22419598_3": {"section_id": 5663, "quality": 0.8913043478260869, "length": 41}}, "n4659": {"so_22419578_22419598_3": {"section_id": 7375, "quality": 0.8913043478260869, "length": 41}}}});