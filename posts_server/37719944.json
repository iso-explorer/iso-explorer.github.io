post_cb({"37719944": {"CommentCount": "2", "ViewCount": "576", "PostTypeId": "1", "ClosedDate": "2016-06-09T08:12:25.810", "LastEditorUserId": "1207195", "CreationDate": "2016-06-09T07:53:06.923", "LastActivityDate": "2016-06-09T12:28:21.267", "Title": "Where does the reference variable gets stored", "AcceptedAnswerId": "37720087", "LastEditDate": "2016-06-09T07:54:17.057", "Id": "37719944", "Score": "5", "Body": "<p>I know that reference does not take any memory it's will point to the same memory location which it is referencing.\nfor eg </p>\n<pre><code>int i=10;\nint &amp;r = a;\n</code></pre>\n<p>suppose <code>i</code> points to the memory location 1000 so in this case <code>r</code> will also points to the memory location 1000.\nBut in C++ when ever we are declaring a variable its will gets store in the memory at some location.\nIn this case <code>r</code> is pointing to some location but it should be stored somewhere in memory as internal representation on reference use const pointer only.\nthanks in advance.</p>\n", "Tags": "<c++><memory>", "OwnerUserId": "4791490", "AnswerCount": "4"}, "37720171": {"ParentId": "37719944", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_37719944_37720171_0\">as internal representation on reference use const pointer only</p>\n</blockquote>\n<p>Where did you hear that? That is not true. </p>\n<p>The standard doesn't specify how references are implemented.</p>\n<p>The following is <strong>overly simplified</strong></p>\n<p>Most commonly, the compiler has internally a symbol table where it stores all the information it needs about variables.</p>\n<p>Let's take a simple case:</p>\n<pre><code>int a;\na = 100;\n</code></pre>\n<p>then the compiler can have something like this (for simplicity lets make the address of <code>a</code> a fixed known address)</p>\n<pre><code>| identifier | type | address  |\n|------------|------|----------|\n| a          | int  | 0xFF00A4 |\n</code></pre>\n<p>Then it can translate the c++ code into something like this:</p>\n<pre><code>mov 0xFF00A4, 100\n</code></pre>\n<p>Let's add a reference in the mix:</p>\n<pre><code>int a;\na = 100;\nint&amp; ra = 300;\n</code></pre>\n<p>The symbol table the compiler has:</p>\n<pre><code>| identifier | type | address  |\n|------------|------|----------|\n| a          | int  | 0xFF00A4 |\n| ra         | int&amp; | 0xFF00A4 |\n</code></pre>\n<p>Or:</p>\n<pre><code>| identifier | type | address  | alias |\n|------------|------|----------|-------|\n| a          | int  | 0xFF00A4 | -     |\n| ra         | int&amp; | -        | a     |\n</code></pre>\n<p>And can therefore generate code like this:</p>\n<pre><code>mov 0xFF00A4, 100\nmov 0xFF00A4, 300\n</code></pre>\n<hr>\n<p>When you have a reference argument in a function, then a pointer is passed internally.</p>\n</hr>", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2016-06-09T08:12:25.197", "Id": "37720171", "Score": "0", "CreationDate": "2016-06-09T08:04:40.330", "LastActivityDate": "2016-06-09T08:12:25.197"}, "37720093": {"ParentId": "37719944", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37719944_37720093_0\">I know that reference does not take any memory</p>\n</blockquote>\n<p>Not exactly. Whether a reference has storage, is unspecified. It might or it might not. In this particular example, it does not need storage, so in a typical implementation, it doesn't use any.</p>\n<blockquote>\n<p id=\"so_37719944_37720093_1\">it's will point to the same memory location which it is referencing</p>\n</blockquote>\n<p>That sounds like a tautology or simply a misunderstanding, depending on what you mean by \"<em>point</em>\". A reference <em>refers</em> to the object or is <em>bound</em> to the object. You can consider it an alias of the variable name. The variable name doesn't use any memory either.</p>\n<blockquote>\n<p id=\"so_37719944_37720093_2\">In this case r is pointing to some location but it should be stored somewhere in memory</p>\n</blockquote>\n<p>It doesn't need to be stored in memory. Consider following code:</p>\n<pre><code>int i=10;\nint &amp;r = a;\nint j = r * 3;\n</code></pre>\n<p>The compiler can interpret <code>r * 3</code> as <code>i * 3</code> as if you had written so in the first place. The location of the referred object is known at compile time, so there is no need to store the address in memory which is a run time thing.</p>\n<p>But, in other situations, storage may be needed. For example: Consider a reference argument of a non-inline function that has external linkage. The referred object cannot be known when the function is compiled, so some information must be passed along in memory, at run time.</p>\n<blockquote>\n<p id=\"so_37719944_37720093_3\">as internal representation on reference use const pointer only</p>\n</blockquote>\n<p>That's not correct. The internal representation might use a pointer, or it might use something else, or it might not need to use anything.</p>\n<p>So, to concisely answer</p>\n<blockquote>\n<p id=\"so_37719944_37720093_4\">Where does the reference variable gets stored</p>\n</blockquote>\n<p>It is unspecified. Either nowhere, or somewhere.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-06-09T12:28:21.267", "Id": "37720093", "Score": "1", "CreationDate": "2016-06-09T08:01:25.703", "LastActivityDate": "2016-06-09T12:28:21.267"}, "37720087": {"ParentId": "37719944", "CommentCount": "0", "Body": "<p>That is left unspecified, and for good reason. The real answer is: it depends on the reference. It can be represented as a normal pointer, or it may not exist at all.</p>\n<p>If you have a function-local reference with automatic storage duration, such as this <code>r</code>:</p>\n<pre><code>void foo()\n{\n  int x[4] = {0, 1, 2, 3};\n  int &amp;r = x[1];\n  // more code\n}\n</code></pre>\n<p>then it will probably not take up any space at all. The compiler will simply treat all uses of <code>r</code> as an alias for <code>x[1]</code>, and access that <code>int</code> directly. Notice that such alias-style references can also result from function inlining.</p>\n<p>On the other hand, if the reference is \"persistent\" or visible to other translation units (such as a data member or a global variable), it has to occupy some space and be stored somewhere. In that case, it will most likely be represented as a pointer, and code using it will be compiled to dereference that pointer.</p>\n<p>Theoretically, other options would also be possible (such as a lookup table), but I don't think those are used by any real-world compiler.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "37720087", "Score": "6", "CreationDate": "2016-06-09T08:00:38.010", "LastActivityDate": "2016-06-09T08:00:38.010"}, "bq_ids": {"n4140": {"so_37719944_37720099_0": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_37719944_37720099_0": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_37719944_37720099_0": {"section_id": 3978, "quality": 1.0, "length": 5}, "so_37719944_37720093_1": {"section_id": 7272, "quality": 0.5714285714285714, "length": 4}}}, "37720099": {"ParentId": "37719944", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What the standard says:</p>\n<blockquote>\n<p id=\"so_37719944_37720099_0\">It is unspecified whether or not a reference requires storage (3.7).</p>\n</blockquote>\n<p>(C++11, [dcl.ref] \u00b64)</p>\n<p>This means that the compiler is free to choose on a per-case basis whether or not any storage is required.</p>\n<p>Now, let people say what they want, but references boil down to syntactic sugar for pointers (even at compiler level, in all major C++ compilers the \"reference\" concept disappears almost immediately after the frontend); thus, in the general case they may need their space in memory, exactly like a pointer does. However, in cases like yours (local references) the compiler should see through them and optimize them away as needed.</p>\n<p>Notice however that this isn't an exclusive of references - the compiler is able to perform this same kind of optimization even through pointers (once your code goes in SSA form there's nothing special even about the fact that references cannot be reseated).</p>\n<p>This:</p>\n<pre><code>int glob;\n\nvoid direct() {\n    glob = 16; \n}\n\nvoid through_reference() {\n    int &amp;a = glob;\n    a = 16;\n}\n\nvoid through_pointer() {\n    int *a = &amp;glob;\n    *a = 16;\n}\n</code></pre>\n<p>boils down always to the same code on any compiler I tried on gcc.godbolt.org - <a href=\"https://godbolt.org/g/vPl5C1\" rel=\"nofollow\">example</a>:</p>\n<pre><code>direct():\n        mov     DWORD PTR glob[rip], 16\n        ret\nthrough_reference():\n        mov     DWORD PTR glob[rip], 16\n        ret\nthrough_pointer():\n        mov     DWORD PTR glob[rip], 16\n        ret\nglob:\n        .zero   4\n</code></pre>\n<p>On the other hand, the situation gets a bit more slippery when talking about structures; here the compiler is allowed to kill references away from the actual layout of the structure (if it's able to reconstruct what they actually point to), while for pointers the situation may be a bit more complicated (their elision would break the standard-layout classes stuff).</p>\n<p>In practice, I never actually saw this kind of optimization implemented in any real-world compiler. Take gcc or MSVC or Clang or whatever and you'll always see that the struct size will come out equal <a href=\"https://godbolt.org/g/Mgcbiy\" rel=\"nofollow\">even in the most trivial cases</a>.</p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2016-06-09T09:05:27.233", "Id": "37720099", "Score": "0", "CreationDate": "2016-06-09T08:01:42.330", "LastActivityDate": "2016-06-09T09:05:27.233"}});