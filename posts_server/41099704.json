post_cb({"41100311": {"ParentId": "41099704", "CommentCount": "0", "Body": "<p>It's not valid at all.  When you allocate an array of objects with a destructor, the run time has to remember how many objects to call the destructor on.  The easiest way to do that, is to allocate a bit of extra memory before the array, and store the count there.  That means if you allocate 3 one-byte objects with a destructor, <code>operator new</code> is going to be asked for (say) 11 bytes of memory - three of which hold the objects, and 8 hold the count (in a size_t).</p>\n<p><code>operator delete</code> wants the address of that 11 byte block of memory - not the address of the 3 byte block that holds/held the three objects.</p>\n<p>Now, I know you are asking about built-in types, which don't have a destructor - the point is, that the run-time library may well choose to allocate the count <em>anyway</em> for simplicity.</p>\n", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "41100311", "Score": "3", "CreationDate": "2016-12-12T11:54:19.353", "LastActivityDate": "2016-12-12T11:54:19.353"}, "41101507": {"ParentId": "41099704", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_41099704_41101507_0\">Some seem to confuse this question with <a href=\"https://stackoverflow.com/q/941832/3344612\">Is it safe to delete a void pointer?</a>.</p>\n</blockquote>\n<p>(^-- The answer to which is \"<strong>no</strong>, but it might appear to work incidentally...in some cases\".)</p>\n<blockquote>\n<p id=\"so_41099704_41101507_1\">I am asking about mixing expression new with operator delete and operator new with expression delete.</p>\n</blockquote>\n<p>...which if it were legal, would probably make a good answer to the above question, wouldn't it?</p>\n<pre><code>\"Nope, you can't use ordinary `delete[]`...but you can use `operator delete[]`.\nIts type signature takes a `void*` instead of a typed pointer.\"\n</code></pre>\n<p>But that's not the answer (and if it were it would make the compiler seem kind of stubborn to not just do that for you.)  Either way, the problem is that given just a void pointer and no type information, a compiler does not necessarily have the right \"tear-down\" code for whatever \"build-up\" it did specific to the type it was given in <code>new</code>.</p>\n<p><em>(And if you don't think it might be interesting to do something special or distinct for basic types, what if you had an address-sanitizer or undefined-behavior-sanitizer type tool which wanted to throw in something special for <code>short</code> that would be measured differently from another type...maybe because you specifically asked to instrument shorts differently?)</em></p>\n<p>Since ordinary delete is implemented in terms of <code>operator delete[]</code>, there's no added magic powers...there's less!</p>\n<p>Hence the answer is pretty much the same.</p>\n", "OwnerUserId": "211160", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:20.080", "Id": "41101507", "Score": "0", "CreationDate": "2016-12-12T13:01:11.907", "LastActivityDate": "2016-12-12T13:01:11.907"}, "bq_ids": {"n4140": {"so_41099704_41100376_0": {"section_id": 6106, "quality": 0.9, "length": 54}}, "n3337": {"so_41099704_41100376_0": {"section_id": 5872, "quality": 0.9, "length": 54}}, "n4659": {"so_41099704_41100376_0": {"section_id": 7603, "quality": 0.9, "length": 54}}}, "41099704": {"CommentCount": "10", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-12-12T11:20:13.517", "LastActivityDate": "2016-12-12T13:01:11.907", "Title": "Mixing operator and expression new/delete", "LastEditDate": "2017-05-23T11:47:35.397", "Id": "41099704", "Score": "1", "Body": "<p>Consider following code:</p>\n<pre><code>unsigned char* a = new unsigned char[100];\nvoid* a1 = reinterpret_cast&lt;void*&gt;(a);\noperator delete[](a1);\n\nshort* b = new short[100];\nvoid* b1 = reinterpret_cast&lt;void*&gt;(b);\noperator delete[](b1);\n</code></pre>\n<p>It seems to me to be a valid syntax for scalar types as delete-expression is equivalent to calling destructor and operator delete. Same for a POD type:</p>\n<pre><code>struct POD {\n    int i;\n    float f;\n    char c;\n};\nPOD* c = new POD[100];\nvoid* c1 = reinterpret_cast&lt;void*&gt;(c);\noperator delete[](c1);\n</code></pre>\n<p>Another thing with scalar and POD types allocated using operator new and deallocated with delete expression:</p>\n<pre><code>void* d = operator new[](sizeof(unsigned char) * 100);\nunsigned char* d1 = reinterpret_cast&lt;unsigned char*&gt;(d);\ndelete[] d1;\n\nvoid* e = operator new[](sizeof(short) * 100);\nshort* e1 = reinterpret_cast&lt;short*&gt;(e);\ndelete[] e1;\n\nvoid* f = operator new[](sizeof(POD) * 100);\nPOD* f1 = reinterpret_cast&lt;POD*&gt;(f);\ndelete[] f1;\n</code></pre>\n<p>All these examples seem to be well-formed, but I didn't manage to find if it really is. Can someone confirm it or tell me where I am wrong? Especially I am concerned by the fact that all these types have different alignment and it should be passed to operator new/delete:</p>\n<blockquote>\n<p id=\"so_41099704_41099704_0\">alignof(unsigned char) 1<br>\n  alignof(short) 2<br>\n  alignof(POD) 4   </br></br></p>\n</blockquote>\n<hr>\n<p>UPD. Some seem to confuse this question with <a href=\"https://stackoverflow.com/q/941832/3344612\">Is it safe to delete a void pointer?</a>. I am asking about mixing <code>expression new</code> with <code>operator delete</code> and <code>operator new</code> with <code>expression delete</code>. According to standard expression forms are implemented with operator forms. And the question is how valid would be mixing them for scalar and POD types?</p>\n</hr>", "Tags": "<c++><memory><new-operator><delete-operator>", "OwnerUserId": "3344612", "AnswerCount": "3"}, "41100376": {"ParentId": "41099704", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think pairing <em>new-expressions</em> and <em>delete-expressions</em> with calls to (even the associated) <em>allocation functions</em> and <em>deallocation functions</em>\u2014like <code>operator delete[]()</code> etc\u2014results in undefined behavior. The former may do some additional housekeeping, while the latter operate on \"raw memory\", as far as I understand.</p>\n<p>This is from ISO/IEC\u00a014882:2014, clause\u00a05.3.5, and it seems to state this explicitly (set in bold by myself):</p>\n<blockquote>\n<p id=\"so_41099704_41100376_0\">In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). <strong>If not, the behavior is undefined</strong>. In the second alternative (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a pointer value that resulted from a previous array new-expression.<sup>81</sup> <strong>If not, the behavior is undefined</strong>. [\u00a0<em>Note:</em> this means that the syntax of the <em>delete-expression</em> must match the type of the object allocated by <code>new</code>, not the syntax of the <em>new-expression</em>. \u2014 <em>end note</em>\u00a0]</p>\n</blockquote>\n", "OwnerUserId": "7275076", "LastEditorUserId": "7275076", "LastEditDate": "2016-12-12T12:12:28.277", "Id": "41100376", "Score": "2", "CreationDate": "2016-12-12T11:57:22.613", "LastActivityDate": "2016-12-12T12:12:28.277"}});