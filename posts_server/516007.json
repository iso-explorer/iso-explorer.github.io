post_cb({"520463": {"ParentId": "516007", "CommentCount": "0", "Body": "<p>Why are you wanting to do this?</p>\n<p>You can't change the value of *p, since it's const std::string. If you did change it, then you might break the invariants of the container by changing the sort order of the elements.  </p>\n<p>Unless you have other requirements that you haven't given here, then you should just take a copy of the string.  </p>\n", "OwnerUserId": "50025", "Id": "520463", "PostTypeId": "2", "OwnerDisplayName": "Richard Wolf", "Score": "0", "CreationDate": "2009-02-06T14:29:02.053", "LastActivityDate": "2009-02-06T14:29:02.053"}, "516041": {"CommentCount": "3", "CreationDate": "2009-02-05T14:12:01.167", "LastEditorUserId": "845092", "LastActivityDate": "2012-04-25T16:54:06.487", "ParentId": "516007", "PostTypeId": "2", "LastEditorDisplayName": "PierreBdR", "LastEditDate": "2012-04-25T16:54:06.487", "Id": "516041", "Score": "19", "Body": "<p>First, maps are guaranteed to be stable; i.e. the iterators are not invalidated by element insertion or deletion (except the element being deleted of course).</p>\n<p>However, stability of iterator does not guarantee stability of pointers! Although it usually happens that most implementations use pointers - at least at some level - to implement iterators (which means it is quite safe to assume your solution will work), <em>what you should really store is the iterator itself</em>.</p>\n<p>What you could do is create a small object like:</p>\n<pre><code>struct StringPtrInMap\n{\n  typedef std::map&lt;string,string&gt;::iterator iterator;\n  StringPtrInMap(iterator i) : it(i) {}\n  const string&amp; operator*() const { return it-&gt;first; }\n  const string* operator-&gt;() const { return &amp;it-&gt;first; }\n  iterator it;\n}\n</code></pre>\n<p>And then store that instead of a string pointer.</p>\n", "OwnerUserId": "7136", "OwnerDisplayName": "PierreBdR"}, "516101": {"CommentCount": "8", "CreationDate": "2009-02-05T14:24:56.633", "LastEditorUserId": "5963", "LastActivityDate": "2009-02-06T14:19:39.483", "ParentId": "516007", "PostTypeId": "2", "LastEditorDisplayName": "Greg Rogers", "LastEditDate": "2009-02-06T14:19:39.483", "Id": "516101", "Score": "47", "Body": "<p>Section 23.1.2#8 (associative container requirements):</p>\n<blockquote>\n<p id=\"so_516007_516101_0\">The insert members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>So <em>yes</em> storing pointers to data members of a map element is guaranteed to be valid, unless you remove <em>that</em> element.</p>\n", "OwnerUserId": "5963", "OwnerDisplayName": "Greg Rogers"}, "516102": {"ParentId": "516007", "CommentCount": "7", "Body": "<p>If you're not sure which operations will invalidate your iterators, you can look it up pretty easily in the <a href=\"http://www.cplusplus.com/reference/stl/\" rel=\"nofollow noreferrer\">reference</a>. For instance for <a href=\"http://www.cplusplus.com/reference/stl/vector/insert.html\" rel=\"nofollow noreferrer\">vector::insert</a> it says:</p>\n<blockquote>\n<p id=\"so_516007_516102_0\">This effectively increases the vector size, which causes an automatic reallocation of the allocated storage space if, and only if, the new vector size surpases the current vector capacity. Reallocations in vector containers invalidate all previously obtained iterators, references and pointers.</p>\n</blockquote>\n<p><a href=\"http://www.cplusplus.com/reference/stl/map/insert.html\" rel=\"nofollow noreferrer\">map::insert</a> on the other hand doesn't mention anything of the sort.</p>\n<p>As Pierre said, you should store the iterator rather than the pointer, though.</p>\n", "OwnerUserId": "52844", "Id": "516102", "PostTypeId": "2", "OwnerDisplayName": "hackingwords", "Score": "1", "CreationDate": "2009-02-05T14:25:14.683", "LastActivityDate": "2009-02-05T14:25:14.683"}, "bq_ids": {"n4140": {"so_516007_516101_0": {"section_id": 745, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_516007_516101_0": {"section_id": 734, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_516007_516101_0": {"section_id": 803, "quality": 0.9333333333333333, "length": 14}}}, "516007": {"CommentCount": "1", "ViewCount": "25370", "OwnerDisplayName": "michael", "CreationDate": "2009-02-05T14:02:47.787", "LastActivityDate": "2012-04-25T16:54:06.487", "PostTypeId": "1", "AcceptedAnswerId": "516041", "FavoriteCount": "10", "Title": "std::map, pointer to map key value, is this possible?", "Id": "516007", "Score": "21", "Body": "<pre><code>std::map&lt;std::string, std::string&gt; myMap;\n\nstd::map&lt;std::string, std::string&gt;::iterator i = m_myMap.find(some_key_string);\nif(i == m_imagesMap.end())\n    return NULL;\n\nstring *p = &amp;i-&gt;first;\n</code></pre>\n<p>Is the last line valid? \nI want to store this pointer p somewhere else, will it be valid for the whole program life? \nBut what will happen if I add some more elements to this map (with other unique keys) or remove some other keys, won\u2019t it reallocate this string (key-value pair), so the p will become invalid? </p>\n", "Tags": "<c++><stl><pointers><map>", "OwnerUserId": "31207", "AnswerCount": "4"}});