post_cb({"bq_ids": {"n4140": {"so_27380209_27380358_2": {"length": 7, "quality": 0.875, "section_id": 6079}, "so_27380209_27380358_0": {"length": 7, "quality": 0.875, "section_id": 6076}, "so_27380209_27380358_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6078}}, "n3337": {"so_27380209_27380358_2": {"length": 7, "quality": 0.875, "section_id": 5847}, "so_27380209_27380358_0": {"length": 7, "quality": 0.875, "section_id": 5844}, "so_27380209_27380358_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5846}}, "n4659": {"so_27380209_27380358_2": {"length": 7, "quality": 0.875, "section_id": 7575}, "so_27380209_27380358_0": {"length": 7, "quality": 0.875, "section_id": 7572}, "so_27380209_27380358_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7574}}}, "27380209": {"ViewCount": "228", "Body": "<p>When I write the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct gg\n{\n   gg() {}\n   int a, b, c;\n};\n\nint main()\n{   \n    std::cout &lt;&lt; sizeof(gg()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>the result is <code>1</code>.</p>\n<p>But when I use a non-default constructor, like so:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct gg\n{\n   gg(int x) {}\n   int a, b, c;\n};\n\nint main()\n{   \n    std::cout &lt;&lt; sizeof(gg(10)) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>the output is 12.</p>\n<p>Since both examples have the same data members in <code>gg</code>, I expect them both to result in the same output.</p>\n<p>Why did <code>sizeof(gg())</code> result in <code>1</code>?</p>\n", "AcceptedAnswerId": "27380358", "Title": "Why does taking the `sizeof` of an object constructed with a default constructor always result in 1?", "CreationDate": "2014-12-09T13:34:45.280", "Id": "27380209", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-12-09T14:02:53.630", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-09T17:05:11.557", "Score": "9", "OwnerUserId": "4341587", "Tags": "<c++>", "AnswerCount": "1"}, "27380358": {"Id": "27380358", "PostTypeId": "2", "Body": "<p>There are two versions of <code>sizeof</code>. One expects a <em>unary-expression</em>, and the other expects a parenthesized <em>type-id</em>.  The first version leaves its operand unevaluated. The following is perfectly legal and outputs <code>12</code>:</p>\n<pre><code>std::cout &lt;&lt; sizeof gg();\n</code></pre>\n<p>On the other hand, <code>sizeof(gg())</code> is illegal. It's trying to apply <code>sizeof</code> to a function type.<sup>1</sup> The second code snippet is legal and has expected behavior.</p>\n<p>\u00a75.3.3:</p>\n<blockquote>\n<p id=\"so_27380209_27380358_0\"><code>1</code> ... The <code>sizeof</code> operator shall not be applied to an expression\n  that has function or incomplete type, ...</p>\n<p id=\"so_27380209_27380358_1\"><code>3</code> The <code>sizeof</code> operator can be applied to a pointer to a function,\n  but shall not be applied directly to a function.</p>\n<p id=\"so_27380209_27380358_2\"><code>4</code> The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are not applied to the operand of <code>sizeof</code>.</p>\n</blockquote>\n<p>The first code snippet fails in Clang (<kbd><a href=\"http://coliru.stacked-crooked.com/a/abf1025ec8c55f7f\" rel=\"nofollow\">live example</a></kbd>), and is documented as an extension in the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Pointer-Arith.html#Pointer-Arith\" rel=\"nofollow\">GCC manual</a>:</p>\n<blockquote>\n<h1>6.23 Arithmetic on void- and Function-Pointers</h1>\n<p id=\"so_27380209_27380358_3\">In GNU C, addition and subtraction operations are supported on\n  pointers to void and on pointers to functions. This is done by\n  treating the size of a void or of a function as 1.</p>\n<p id=\"so_27380209_27380358_4\"><strong>A consequence of this is that sizeof is also allowed on void and on function types, and returns 1.</strong></p>\n<p id=\"so_27380209_27380358_5\">The option -Wpointer-arith requests a warning if these extensions are\n  used.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>It appears that this extension exists in C++ mode as well, considering that I <a href=\"http://coliru.stacked-crooked.com/a/ecba688bfbb7a0cf\" rel=\"nofollow\">receive a warning</a>. In order to reject this code, use <code>-Wpedantic-errors</code>. For the code snippet which fails, simply use <code>sizeof(gg)</code> or <code>sizeof(gg{})</code>. The latter and <code>sizeof gg()</code> are needless obfuscation and <code>sizeof gg</code> is illegal since parentheses are required around the typename.</p>\n<hr/>\n<h3>Footnote</h3>\n<ol>\n<li>Some are suggesting that this is the <a href=\"https://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow\">most vexing parse</a>. To strengthen the argument, consider that Clang will reject any function type, <code>sizeof(int(int, char))</code>, <code>sizeof(gg(int, char))</code>, what have you. On the other hand, <code>sizeof int(45)</code> returns <code>4</code> and <code>sizeof gg(45)</code> (for where <code>gg</code> has a converting constructor) returns 12, etc.</li>\n</ol>\n", "LastEditorDisplayName": "user3920237", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-12-09T17:05:11.557", "Score": "7", "CreationDate": "2014-12-09T13:42:22.823", "ParentId": "27380209", "CommentCount": "2", "LastEditDate": "2014-12-09T17:05:11.557"}});