post_cb({"1704511": {"Id": "1704511", "PostTypeId": "2", "Body": "<p>No, out of class you have to write:</p>\n<pre><code>template &lt;typename T&gt;\nWrapper&lt;T&gt;::Wrapper&lt;T&gt;(const Wrapper&lt;T&gt;&amp; w) : t(w.t) {}\n</code></pre>\n<p>But inside the class, <code>Wrapper</code> stands in for the \"current class\".</p>\n<p>EDIT: This is for Andrew and his investigation into why a compiler would reject the  on the constructor:</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\npublic:\n    Foo() {}\n    Foo(const Foo&amp; f);\n};\n\ntemplate &lt;typename T&gt;\nFoo&lt;T&gt;::Foo&lt;T&gt;(const Foo&lt;T&gt;&amp; f) { }\n\nint main(int argc, char** argv)\n{\n    Foo&lt;int&gt; f;\n    Foo&lt;int&gt; g(f); // make sure the template is instantiated\n}\n</code></pre>\n", "LastEditorUserId": "44065", "LastActivityDate": "2009-11-10T22:22:23.863", "Score": "0", "CreationDate": "2009-11-09T22:52:19.070", "ParentId": "1704353", "CommentCount": "10", "OwnerUserId": "44065", "LastEditDate": "2009-11-10T22:22:23.863"}, "1704441": {"Id": "1704441", "PostTypeId": "2", "Body": "<p>It is explicitly specified by the language standard in 14.6.1/1: </p>\n<blockquote>\n<p id=\"so_1704353_1704441_0\">Within the scope of class template,\n  when the name of the template is\n  neither qualified nor followed by &lt;,\n  it is equivalent to the name of the\n  template followed by the\n  template-parameters enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>This was re-worded (through the concept of \"injected class name\") in the later versions of the standard, but the point is that this behavior is explicitly spelled out in the document.</p>\n<p>To answer the second part of your question, this rule also applies to parameter declarations when writing out-of-class method definitions, but it doesn't apply to the return type declarations. For example, this code is OK</p>\n<pre><code>template &lt;typename T&gt; struct S {\n  S foo(S);\n};\n\ntemplate &lt;typename T&gt; S&lt;T&gt; S&lt;T&gt;::foo(S s) {\n  /* whatever */\n}\n</code></pre>\n<p>but you can't remove the <code>&lt;T&gt;</code> bit from the return type in the definition of the method. (And you can't remove <code>&lt;T&gt;</code> from the qualified name of the method.)</p>\n<p>As for the constructior specifically: your should use the full name (with <code>&lt;T&gt;</code>) for the class, but you should not use <code>&lt;T&gt;</code> in the name of the constructor itself. So the shortest form for out-of-class definition in your case would be</p>\n<pre><code>template &lt;typename T&gt; Wrapper&lt;T&gt;::Wrapper(const Wrapper&amp; w) : t_(w.t_)\n{\n}\n</code></pre>\n<p>Note, that you can't add the <code>&lt;T&gt;</code> bit to the constructor name even if you want to</p>\n<pre><code>template &lt;typename T&gt; Wrapper&lt;T&gt;::Wrapper&lt;T&gt;(const Wrapper&amp; w)\n                                         ^ ERROR !!!\n</code></pre>\n<p>P.S. This last claim needs further research. Comeau Online compiler thinks it is an error, while GCC thinks it is OK. I'll return to it later.</p>\n<p>P.P.S. The compiler in MSVC++ 2005 complains about the latter declaration with a warning</p>\n<pre><code>warning C4812: obsolete declaration style: please use 'Wrapper&lt;T&gt;::Wrapper' instead\n</code></pre>\n<p>Interesting...</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2009-11-10T23:52:30.453", "Score": "3", "CreationDate": "2009-11-09T22:40:37.893", "ParentId": "1704353", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2009-11-10T23:52:30.453"}, "bq_ids": {"n4140": {"so_1704353_1704441_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 191}}, "n3337": {"so_1704353_1704441_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 185}}, "n4659": {"so_1704353_1704441_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 196}}}, "1704385": {"Id": "1704385", "PostTypeId": "2", "Body": "<p>Within a templated class like this using the name of the class is the same as using <code>Wrapper&lt;T&gt;</code>.</p>\n", "LastActivityDate": "2009-11-09T22:30:11.483", "CommentCount": "0", "CreationDate": "2009-11-09T22:30:11.483", "ParentId": "1704353", "Score": "0", "OwnerUserId": "22310"}, "1704378": {"Id": "1704378", "PostTypeId": "2", "Body": "<p>Basically, inside a class template definition you are allowed to use the <em>template-name</em>  for the template being defined as a short hand for the full parameterized version of the <em>template-id</em>.</p>\n", "LastActivityDate": "2009-11-09T22:29:08.447", "CommentCount": "0", "CreationDate": "2009-11-09T22:29:08.447", "ParentId": "1704353", "Score": "3", "OwnerUserId": "19563"}, "1704353": {"ViewCount": "466", "Body": "<p>It's hard to get a word for this. Sometimes I see a class like this:</p>\n<pre><code>template &lt;typename T&gt;\nclass Wrapper\n{\npublic:\n    Wrapper(const T&amp; t) : t_(t) {}\n    Wrapper(const Wrapper&amp; w) : t_(w.t_) {}\nprivate:\n    T t_;\n}\n</code></pre>\n<p>As far as I can tell this is legitimate code. However, why is the copy constructor allowed to accept a <code>const Wrapper&amp;</code> without explicitly stating that it needs a <code>const Wrapper&lt;T&gt;&amp;</code>. When else is the template type implied? Is it allowed to write the copy constructor this way if you don't use an in-class definition?</p>\n", "AcceptedAnswerId": "1704441", "Title": "Template lookup in class?", "CreationDate": "2009-11-09T22:26:04.913", "Id": "1704353", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2009-11-10T23:52:30.453", "Score": "2", "OwnerUserId": "72631", "Tags": "<c++><templates><lookup>", "AnswerCount": "4"}});