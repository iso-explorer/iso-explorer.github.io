post_cb({"1807009": {"Id": "1807009", "PostTypeId": "2", "Body": "<pre><code>#include&lt;iostream&gt;\nint main( void )\n{\n   int i = 3;    \n   const int *pi = &amp;i;\n   int *pj = (int*)&amp;i;\n    *pj = 4;\n\n   getchar(); \n   return 0;  \n}\n</code></pre>\n", "LastEditorUserId": "597607", "LastActivityDate": "2011-07-22T19:43:17.793", "Score": "0", "CreationDate": "2009-11-27T05:58:58.680", "ParentId": "583076", "CommentCount": "0", "OwnerUserId": "219845", "LastEditDate": "2011-07-22T19:43:17.793"}, "583089": {"Id": "583089", "PostTypeId": "2", "Body": "<p>You probably want to use const_cast:</p>\n<pre><code>int *ptr = const_cast&lt;int*&gt;(ptr_to_a);\n</code></pre>\n<p>I'm not 100% certain this will work though, I'm a bit rusty at C/C++ :-)</p>\n<p>Some readup for const_cast: <a href=\"http://msdn.microsoft.com/en-us/library/bz6at95h(VS.80).aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/bz6at95h(VS.80).aspx</a></p>\n", "OwnerDisplayName": "Steffen", "LastActivityDate": "2009-02-24T18:58:58.787", "Score": "0", "CreationDate": "2009-02-24T18:58:58.787", "ParentId": "583076", "CommentCount": "0"}, "583076": {"ViewCount": "43608", "Body": "<p>I had an article, but I lost it.  It showed and described a couple of C/C++ tricks that people should be careful. One of them interested me but now that I am trying to replicate it I'm not being able to put it to compile.</p>\n<p>The concept was that it is possible to change by accident the value of a <code>const</code> in C/C++</p>\n<p>It was something like this:</p>\n<pre><code>const int a = 3;          // I promise I won't change a\nconst int *ptr_to_a = &amp;a; // I still promise I won't change a\nint *ptr;\nptr = ptr_to_a;\n\n(*ptr) = 5;               // I'm a liar; a is now 5\n</code></pre>\n<p>I wanted to show this to a friend but now I'm missing a step.  Does anyone know what's missing for it to start compiling and working?</p>\n<p>ATM I'm getting <strong>invalid conversion from 'const int*' to 'int*'</strong> but when I read the article I tried and it worked great.</p>\n", "AcceptedAnswerId": "583104", "Title": "C/C++ changing the value of a const", "CreationDate": "2009-02-24T18:55:20.763", "Id": "583076", "CommentCount": "2", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2014-08-04T13:04:53.657", "LastEditorDisplayName": "Eddie", "OwnerDisplayName": "fmsf", "LastEditorUserId": "100297", "LastActivityDate": "2016-04-12T20:30:49.747", "Score": "13", "OwnerUserId": "26004", "Tags": "<c++><const>", "AnswerCount": "16"}, "583150": {"Body": "<p>Note any attempt to cast away constness is undefined by the standard. From 7.1.5.1 of the standard:</p>\n<blockquote>\n<p id=\"so_583076_583150_0\">Except that any class member declared\n  mutable can be modified, any\n  attempt to modify a const object\n  during its lifetime\n  results in undefined behavior.</p>\n</blockquote>\n<p>And right after this example is used:</p>\n<pre><code>const int* ciq = new const int (3);     //  initialized as required\nint* iq = const_cast&lt;int*&gt;(ciq);        //  cast required\n*iq = 4;                                //  undefined: modifies a  const  object\n</code></pre>\n<p>So in short what you want to do isn't possible using standard C++.</p>\n<p>Further when the compiler encounters a declaration like</p>\n<pre><code>const int a = 3; // I promisse i won't change a\n</code></pre>\n<p>it is free to replace any occurance of 'a' with 3 (effectively doing the same thing as <code>#define a 3</code>)</p>\n", "CreationDate": "2009-02-24T19:17:05.233", "ParentId": "583076", "CommentCount": "0", "LastEditDate": "2009-02-24T19:22:07.437", "PostTypeId": "2", "LastEditorDisplayName": "Andrew Khosravian", "LastActivityDate": "2009-02-24T19:22:07.437", "LastEditorUserId": "69883", "Id": "583150", "OwnerDisplayName": "Andrew Khosravian", "Score": "8", "OwnerUserId": "69883"}, "27740452": {"Id": "27740452", "PostTypeId": "2", "Body": "<p>I was looking on how to convert between consts and I found this one <a href=\"http://www.possibility.com/Cpp/const.html\" rel=\"nofollow\">http://www.possibility.com/Cpp/const.html</a> maybe it can be useful to someone. :)</p>\n", "LastActivityDate": "2015-01-02T10:10:17.530", "CommentCount": "0", "CreationDate": "2015-01-02T10:10:17.530", "ParentId": "583076", "Score": "0", "OwnerUserId": "3355387"}, "bq_ids": {"n4140": {"so_583076_583150_0": {"length": 17, "quality": 1.0, "section_id": 5433}}, "n3337": {"so_583076_583150_0": {"length": 17, "quality": 1.0, "section_id": 5228}}, "n4659": {"so_583076_583150_0": {"length": 17, "quality": 1.0, "section_id": 6861}}}, "583139": {"Id": "583139", "PostTypeId": "2", "Body": "<p>Back in the mists of time, we paleo-programmers used FORTRAN.  FORTRAN passed all its parameters by reference, and didn't do any typechecking.  This meant it was quite easy to accidentally change the value of even a literal constant.  You could pass \"3\" to a SUBROUTINE, and it would come back changed, and so every time from then on where your code had a \"3\", it would actually act like a different value.  Let me tell you, those were hard bugs to find and fix.</p>\n", "OwnerDisplayName": "Paul Tomblin", "LastActivityDate": "2009-02-24T19:13:18.583", "CommunityOwnedDate": "2009-02-24T19:13:18.583", "CommentCount": "1", "CreationDate": "2009-02-24T19:13:18.583", "ParentId": "583076", "Score": "6", "OwnerUserId": "3333"}, "583104": {"Body": "<p>you need to cast away the constness:</p>\n<pre><code>linux ~ $ cat constTest.c\n#include &lt;stdio.h&gt;\n\n\nvoid modA( int *x )\n{\n        *x = 7;\n}\n\n\nint main( void )\n{\n\n        const int a = 3; // I promisse i won't change a\n        int *ptr;\n        ptr = (int*)( &amp;a );\n\n        printf( \"A=%d\\n\", a );\n        *ptr = 5; // I'm a liar, a is now 5\n        printf( \"A=%d\\n\", a );\n\n        *((int*)(&amp;a)) = 6;\n        printf( \"A=%d\\n\", a );\n\n        modA( (int*)( &amp;a ));\n        printf( \"A=%d\\n\", a );\n\n        return 0;\n}\nlinux ~ $ gcc constTest.c -o constTest\nlinux ~ $ ./constTest\nA=3\nA=5\nA=6\nA=7\nlinux ~ $ g++ constTest.c -o constTest\nlinux ~ $ ./constTest\nA=3\nA=3\nA=3\nA=3\n</code></pre>\n<p>also the common answer doesn't work in g++ 4.1.2</p>\n<pre><code>linux ~ $ cat constTest2.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nint main( void )\n{\n        const int a = 3; // I promisse i won't change a\n        int *ptr;\n        ptr = const_cast&lt;int*&gt;( &amp;a );\n\n        cout &lt;&lt; \"A=\" &lt;&lt; a &lt;&lt; endl;\n        *ptr = 5; // I'm a liar, a is now 5\n        cout &lt;&lt; \"A=\" &lt;&lt; a &lt;&lt; endl;\n\n        return 0;\n}\nlinux ~ $ g++ constTest2.cpp -o constTest2\nlinux ~ $ ./constTest2\nA=3\nA=3\nlinux ~ $\n</code></pre>\n<p>btw.. this is never recommended... I found that g++ doesn't allow this to happen.. so that may be the issue you are experiencing.</p>\n", "CreationDate": "2009-02-24T19:02:12.900", "ParentId": "583076", "CommentCount": "7", "LastEditDate": "2009-02-24T21:06:37.030", "PostTypeId": "2", "LastEditorDisplayName": "sfossen", "LastActivityDate": "2009-02-24T21:06:37.030", "LastEditorUserId": "64657", "Id": "583104", "OwnerDisplayName": "sfossen", "Score": "34", "OwnerUserId": "64657"}, "583086": {"Id": "583086", "PostTypeId": "2", "Body": "<p>Did you try this?</p>\n<pre><code>ptr = const_cast&lt;int *&gt;(ptr_to_a);\n</code></pre>\n<p>That should help it compile but it's not really by accident due to the cast.</p>\n", "OwnerDisplayName": "Kristo", "LastActivityDate": "2009-02-24T18:58:18.383", "Score": "4", "CreationDate": "2009-02-24T18:58:18.383", "ParentId": "583076", "CommentCount": "4", "OwnerUserId": "46821"}, "583474": {"Id": "583474", "PostTypeId": "2", "Body": "<p>Some of these answers point out that the compiler can optimize away the variable 'a' since it is declared <code>const</code>.  If you really want to be able to change the value of <code>a</code> then you need to mark it as <code>volatile</code></p>\n<pre><code>  const volatile int a = 3; // I promise i won't change a\n  int *ptr = (int *)&amp;a;\n  (*ptr) = 5; // I'm a liar, a is now 5\n</code></pre>\n<p>Of course, declaring something as <code>const volatile</code> should really illustrate just how silly this is.</p>\n", "OwnerDisplayName": "Peter Kovacs", "LastActivityDate": "2009-02-24T20:35:30.647", "Score": "-1", "CreationDate": "2009-02-24T20:35:30.647", "ParentId": "583076", "CommentCount": "3", "OwnerUserId": "10615"}, "10222887": {"Id": "10222887", "PostTypeId": "2", "Body": "<p>In C++, Using Microsoft Visual Studio-2008</p>\n<pre><code>const int a = 3;    /* I promisse i won't change a */\nint * ptr1  = const_cast&lt;int*&gt; (&amp;a);\n*ptr1 = 5;  /* I'm a liar, a is now 5 . It's not okay. */\ncout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\n\"; /* prints 3 */\nint arr1[a]; /* arr1 is an array of 3 ints */\n\nint temp = 2;\n/* or, const volatile int temp = 2; */\nconst int b = temp + 1; /* I promisse i won't change b */\nint * ptr2  = const_cast&lt;int*&gt; (&amp;b);\n*ptr2 = 5; /* I'm a liar, b is now 5 . It's okay. */\ncout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \"\\n\"; /* prints 5 */\n//int arr2[b]; /* Compilation error */\n</code></pre>\n<p>In C, a const variable can be modified through its pointer; however it is undefined behavior. A const variable can be never used as length in an array declaration.</p>\n<p>In C++, if a const variable is initialized with a pure constant expression, then its value cannot be modified through its pointer even after try to modify, otherwise a const variable can be modified through its pointer.</p>\n<p>A pure integral const variable can be used as length in an array declaration, if its value is greater than 0.</p>\n<p>A pure constant expression consists of the following operands.</p>\n<ol>\n<li><p>A numeric literal (constant ) e.g. 2, 10.53 </p></li>\n<li><p>A symbolic constant defined by #define directive</p></li>\n<li><p>An Enumeration constant</p></li>\n<li><p>A pure const variable i.e. a const variable which is itself initialized with a pure constant expression.</p></li>\n<li><p>Non-const variables or volatile variables are not allowed.</p></li>\n</ol>\n", "LastEditorUserId": "1343193", "LastActivityDate": "2012-04-19T07:57:33.537", "Score": "2", "CreationDate": "2012-04-19T06:43:30.513", "ParentId": "583076", "CommentCount": "0", "OwnerUserId": "1343193", "LastEditDate": "2012-04-19T07:57:33.537"}, "15336577": {"Id": "15336577", "PostTypeId": "2", "Body": "<p>we can change the const variable value by the following code :</p>\n<pre><code>const int x=5; \n\nprintf(\"\\nValue of x=%d\",x);\n\n*(int *)&amp;x=7;\n\nprintf(\"\\nNew value of x=%d\",x);\n</code></pre>\n", "LastEditorUserId": "203657", "LastActivityDate": "2013-03-11T11:02:41.397", "Score": "0", "CreationDate": "2013-03-11T10:43:53.080", "ParentId": "583076", "CommentCount": "2", "OwnerUserId": "1932728", "LastEditDate": "2013-03-11T11:02:41.397"}, "583155": {"Id": "583155", "PostTypeId": "2", "Body": "<p>Just a guess, but a common question is why one can't convert an <code>int**</code> to a <code>const int**</code>, which at first appears to be reasonable (after all, you're just adding a <code>const</code>, which is normally ok).  The reason is that if you could do this, you could accidentally modify a <code>const</code> object:</p>\n<pre><code>const int x = 3;\nint *px;\nconst int **ppx = &amp;px;  // ERROR: conversion from 'int**' to 'const int**'\n*ppx = &amp;x;  // ok, assigning 'const int*' to 'const int*'\n*px = 4;    // oops, just modified a const object\n</code></pre>\n<p>It's a very non-intuitive result, but the only way to make sure that you can't modify a <code>const</code> object in this case (note how there are no typecasts) is to make line 3 an error.</p>\n<p>You're only allowed to add <code>const</code> without a cast at the FIRST level of indirection:</p>\n<pre><code>int * const *ppx = &amp;px;  // this is ok\n*ppx = &amp;x;               // but now this is an error because *ppx is 'const'\n</code></pre>\n<p>In C++, it is impossible to modify a <code>const</code> object without using a typecast of some sort.  You'll have to use either a C-style cast or a C++-style <code>const_cast</code> to remove the <code>const</code>-ness.  Any other attempt to do so will result in a compiler error somewhere.</p>\n", "OwnerDisplayName": "Adam Rosenfield", "LastActivityDate": "2009-02-24T19:19:03.873", "Score": "12", "CreationDate": "2009-02-24T19:19:03.873", "ParentId": "583076", "CommentCount": "2", "OwnerUserId": "9530"}, "36583286": {"Id": "36583286", "PostTypeId": "2", "Body": "<p>this will create a runtime fault. Because the <strong>int</strong> is <strong>static</strong>. Unhandled exception. Access violation writing location 0x00035834.</p>\n<pre><code>void main(void)\n{\n    static const int x = 5;\n    int *p = (int *)x;\n    *p = 99;                //here it will trigger the fault at run time\n}\n</code></pre>\n", "LastEditorUserId": "6195421", "LastActivityDate": "2016-04-12T20:30:49.747", "Score": "0", "CreationDate": "2016-04-12T20:18:28.053", "ParentId": "583076", "CommentCount": "0", "OwnerUserId": "6195421", "LastEditDate": "2016-04-12T20:30:49.747"}, "583186": {"Id": "583186", "PostTypeId": "2", "Body": "<p>The article you were looking at might have been talking about the difference between</p>\n<pre><code>const int *pciCantChangeTarget;\nconst int ci = 37;\npciCantChangeTarget = &amp;ci; // works fine\n*pciCantChangeTarget = 3; // compile error\n</code></pre>\n<p>and</p>\n<pre><code>int nFirst = 1;\nint const *cpiCantChangePointerValue = &amp;nFirst;\nint nSecond = 968;\n\n*pciCantChangePointerValue = 402; // works\ncpiCantChangePointerValue = &amp;ci; // compile error\n</code></pre>\n<p>Or so I recall-- I don't have anything but Java tools here, so can't test :)</p>\n", "OwnerDisplayName": "mjfgates", "LastActivityDate": "2009-02-24T19:24:06.543", "Score": "0", "CreationDate": "2009-02-24T19:24:06.543", "ParentId": "583076", "CommentCount": "0", "OwnerUserId": "21434"}, "583136": {"Body": "<p>The step you're missing is that you don't need the int* pointer. The line:</p>\n<pre><code>const int *ptr_to_a = &amp;a; // I still promiss i won't change a;\n</code></pre>\n<p>actually says you won't change ptr_to_a, not a. So if you changed your code to read like this:</p>\n<pre><code>const int a = 3; // I promise I won't change a\nconst int *ptr_to_a = &amp;a; // I promise I won't change ptr_to_a, not a.\n\n(*ptr_to_a) = 5; // a is now 5\n</code></pre>\n<p>a is now 5. You can change a through ptr_to_a without any warning.</p>\n<p>EDIT:</p>\n<p>The above is incorrect. It turns out I was confusing a similar trick with a shared_ptr, in which you can get access to the raw pointer and modify the internal data value without firing off any warnings. That is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/shared_ptr.hpp&gt;\n\nint main()\n{\n    const boost::shared_ptr&lt;int&gt;* a = new boost::shared_ptr&lt;int&gt;(new int(3));\n    *(a-&gt;get()) = 5;\n    std::cout &lt;&lt; \"A is: \" &lt;&lt; *(a-&gt;get()) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Will produce 5.</p>\n", "CreationDate": "2009-02-24T19:12:16.027", "ParentId": "583076", "CommentCount": "4", "LastEditDate": "2009-02-24T19:36:30.507", "PostTypeId": "2", "LastEditorDisplayName": "jasedit", "LastActivityDate": "2009-02-24T19:36:30.507", "LastEditorUserId": "59184", "Id": "583136", "OwnerDisplayName": "jasedit", "Score": "-2", "OwnerUserId": "59184"}, "583129": {"Id": "583129", "PostTypeId": "2", "Body": "<pre><code>const int foo = 42;\nconst int *pfoo = &amp;foo;\nconst void *t = pfoo;\nvoid *s = &amp;t; // pointer to pointer to int\nint **z = (int **)s; // pointer to int\n**z = 0;\n</code></pre>\n", "OwnerDisplayName": "dirkgently", "LastActivityDate": "2009-02-24T19:10:33.440", "Score": "0", "CreationDate": "2009-02-24T19:10:33.440", "ParentId": "583076", "CommentCount": "3", "OwnerUserId": "66692"}, "33775741": {"Id": "33775741", "PostTypeId": "2", "Body": "<p>I have tested the code below and it successfully changes the constant member variables.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\n    private:\n        int * pc1;  // These must stay on the top of the constant member variables.\n        int * pc2;  // Because, they must be initialized first\n        int * pc3;  // in the constructor initialization list.\n    public:\n        A() : c1(0), c2(0), c3(0), v1(0), v2(0), v3(0) {}\n        A(const A &amp; other)\n            :   pc1 (const_cast&lt;int*&gt;(&amp;other.c1)),\n                pc2 (const_cast&lt;int*&gt;(&amp;other.c2)),\n                pc3 (const_cast&lt;int*&gt;(&amp;other.c3)),\n                c1  (*pc1),\n                c2  (*pc2),\n                c3  (*pc3),\n                v1  (other.v1),\n                v2  (other.v2),\n                v3  (other.v3)\n        {\n        }\n        A(int c11, int c22, int c33, int v11, int v22, int v33) : c1(c11), c2(c22), c3(c33), v1(v11), v2(v22), v3(v33)\n        {\n        }\n        const A &amp; operator=(const A &amp; Rhs)\n        {\n            pc1     =  const_cast&lt;int*&gt;(&amp;c1);\n            pc2     =  const_cast&lt;int*&gt;(&amp;c2),\n            pc3     =  const_cast&lt;int*&gt;(&amp;c3),\n            *pc1    = *const_cast&lt;int*&gt;(&amp;Rhs.c1);\n            *pc2    = *const_cast&lt;int*&gt;(&amp;Rhs.c2);\n            *pc3    = *const_cast&lt;int*&gt;(&amp;Rhs.c3);\n            v1      = Rhs.v1;\n            v2      = Rhs.v2;\n            v3      = Rhs.v3;\n            return *this;\n        }\n        const int c1;\n        const int c2;\n        const int c3;\n        int v1;\n        int v2;\n        int v3;\n};\n\nstd::wostream &amp; operator&lt;&lt;(std::wostream &amp; os, const A &amp; a)\n{\n    os &lt;&lt; a.c1 &lt;&lt; '\\t' &lt;&lt; a.c2 &lt;&lt; '\\t' &lt;&lt; a.c3 &lt;&lt; '\\t' &lt;&lt; a.v1 &lt;&lt; '\\t' &lt;&lt; a.v2 &lt;&lt; '\\t' &lt;&lt; a.v3 &lt;&lt; std::endl;\n    return os;\n}\n\nint wmain(int argc, wchar_t *argv[], wchar_t *envp[])\n{\n    A ObjA(10, 20, 30, 11, 22, 33);\n    A ObjB(40, 50, 60, 44, 55, 66);\n    A ObjC(70, 80, 90, 77, 88, 99);\n    A ObjD(ObjA);\n    ObjB = ObjC;\n    std::wcout &lt;&lt; ObjA &lt;&lt; ObjB &lt;&lt; ObjC &lt;&lt; ObjD;\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>The console output is:</p>\n<pre><code>10      20      30      11      22      33\n70      80      90      77      88      99\n70      80      90      77      88      99\n10      20      30      11      22      33\nPress any key to continue . . .\n</code></pre>\n<p>Here, the handicap is, you have to define as many pointers as number of constant member variables you have.</p>\n", "LastActivityDate": "2015-11-18T09:07:36.320", "CommentCount": "0", "CreationDate": "2015-11-18T09:07:36.320", "ParentId": "583076", "Score": "0", "OwnerUserId": "245376"}});