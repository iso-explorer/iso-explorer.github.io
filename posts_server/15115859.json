post_cb({"bq_ids": {"n4140": {"so_15115859_15116012_0": {"length": 10, "quality": 1.0, "section_id": 456}, "so_15115859_15116012_1": {"length": 24, "quality": 0.96, "section_id": 451}}, "n3337": {"so_15115859_15116012_0": {"length": 10, "quality": 1.0, "section_id": 447}, "so_15115859_15116012_1": {"length": 24, "quality": 0.96, "section_id": 442}}, "n4659": {"so_15115859_15116012_0": {"length": 10, "quality": 1.0, "section_id": 479}, "so_15115859_15116012_1": {"length": 24, "quality": 0.96, "section_id": 474}}}, "15115939": {"Id": "15115939", "PostTypeId": "2", "Body": "<p>The compiler provides an implicitly declared non-template copy constructor with signature equivalent to</p>\n<pre><code>A(const A&amp; a);\n</code></pre>\n<p><strong>because</strong> a template constructor is not considered as a user defined copy constructor, i.e. a copy constructor has to be a non-template.</p>\n<p>The implicitly declared copy constructor is a better match in the overload resolution than the template version, and is the one that gets called when you copy construct an <code>A&lt;T&gt;</code> from an <code>A&lt;T&gt;</code>. This can be illustrated with a simple example, with a user defined <code>A(const A&amp;)</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct A \n{\n A() {};\n\n A(const A&amp; a) {\n   std::cout &lt;&lt; \"copy constructor used for A\" &lt;&lt; std::endl;\n }\n\n template&lt;class S&gt;\n A(const A&lt;S&gt;&amp; a) {\n   std::cout &lt;&lt; \"constructor template used for A\" &lt;&lt; std::endl;\n }\n};\n\nint main()\n{\n  A&lt;int&gt; ai;\n  A&lt;double&gt; ad = ai; /  calls template conversion contructor\n  A&lt;int&gt; ai2 = ai;   // calls copy constructor A(const A&amp;);\n}\n</code></pre>\n", "LastEditorUserId": "661519", "LastActivityDate": "2013-02-27T15:52:09.943", "Score": "4", "CreationDate": "2013-02-27T15:31:35.227", "ParentId": "15115859", "CommentCount": "6", "OwnerUserId": "661519", "LastEditDate": "2013-02-27T15:52:09.943"}, "15116012": {"Id": "15116012", "PostTypeId": "2", "Body": "<p>Per Paragraph 12.8/7 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15115859_15116012_0\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n</blockquote>\n<p>Moreover, per Paragraph 12.8/2:</p>\n<blockquote>\n<p id=\"so_15115859_15116012_1\">A <strong>non-template</strong> constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;,\n  volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters\n  have default arguments (8.3.6).</p>\n</blockquote>\n<p>Therefore, the compiler will generate an implicit copy constructor here that gets invoked during the execution of this line:</p>\n<pre><code>A&lt;int&gt; aa = a;\n</code></pre>\n<p>This explains why you do not see a corresponding output.</p>\n", "LastActivityDate": "2013-02-27T15:35:15.503", "CommentCount": "5", "CreationDate": "2013-02-27T15:35:15.503", "ParentId": "15115859", "Score": "4", "OwnerUserId": "1932150"}, "15115859": {"ViewCount": "136", "Body": "<p>While pursuing some errors, I stumbled upon the following behavior of initialization, which seems odd to me: While initialization checks for existing constructors, there seem to be cases were templates for fitting constructors are ignored. Consider for example the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct A {\n A() {};\n template&lt;class S&gt;\n A(const A&lt;S&gt;&amp; a) {std::cout &lt;&lt; \"constructor template used for A\" &lt;&lt; std::endl;};\n};\n\ntemplate&lt;class T&gt;\nstruct B{\n B() {};\n B(const B&lt;int&gt;&amp; b) {std::cout &lt;&lt; \"constructor used for B\" &lt;&lt; std::endl;};\n};\n\nint main() {\n A&lt;int&gt; a;\n B&lt;int&gt; b;\n A&lt;int&gt; aa = a;\n B&lt;int&gt; bb = b;\n A&lt;double&gt; aaa = a;\n}\n</code></pre>\n<p>For me, this produces the output</p>\n<pre><code>constructor used for B\nconstructor template used for A\n</code></pre>\n<p>this means it does not use the constructor in the third line of main. Why not? Is there a reason? Or is my syntax off somewhere? The template seems to work, as it is successfully used in the last line.</p>\n<p>I know the example seems overly complicated, but various simplifications made the behavior I wanted to display go away. Also: A template specialization will be used by the initialization and is how I currently prevent this causing errors (where it caused errors in the first place).</p>\n<p>I am sorry if my question is off in any way, I am not a programmer, I am not a native speaker and this is my first question, please forgive me.</p>\n", "AcceptedAnswerId": "15115939", "Title": "initialization ignores constructor templates", "CreationDate": "2013-02-27T15:27:59.587", "Id": "15115859", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-02-27T15:52:09.943", "Score": "3", "OwnerUserId": "2115777", "Tags": "<c++><templates><constructor><initialization>", "AnswerCount": "3"}, "15115929": {"Id": "15115929", "PostTypeId": "2", "Body": "<p>This is because templated ctor is not a copy ctor. See also <a href=\"https://stackoverflow.com/a/1249848/341065\">https://stackoverflow.com/a/1249848/341065</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-27T15:31:25.147", "Score": "0", "CreationDate": "2013-02-27T15:31:25.147", "ParentId": "15115859", "CommentCount": "0", "OwnerUserId": "341065", "LastEditDate": "2017-05-23T12:21:31.457"}});