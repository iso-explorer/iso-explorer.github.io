post_cb({"5354594": {"ViewCount": "210", "Body": "<p>I came across this example of an assertion and was wondering what the <code>#</code> is for:</p>\n<pre><code>#define ASSERT( x ) if ( !( x ) ) { \\\n    int *p = NULL; \\\n    DBGPRINTF(\"Assert failed: [%s]\\r\\n Halting.\", #x); \\\n    *p=1; \\\n  } \n</code></pre>\n", "Title": "What is the # for when formatting using %s", "CreationDate": "2011-03-18T15:58:26.367", "LastActivityDate": "2016-03-09T15:25:36.123", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-09T15:25:36.123", "LastEditorUserId": "4370109", "Id": "5354594", "Score": "5", "OwnerUserId": "666316", "Tags": "<c++><c><c-preprocessor><stringification>", "AnswerCount": "7"}, "5354626": {"Id": "5354626", "PostTypeId": "2", "Body": "<p>It is the \"stringize\" preprocessing operator.  </p>\n<p>It takes the tokens passed as the argument to the macro parameter <code>x</code> and turns them into a string literal.</p>\n<pre><code>#define ASSERT(x) #x\n\nASSERT(a b c d)\n// is replaced by\n\"a b c d\"\n</code></pre>\n", "LastActivityDate": "2011-03-18T16:01:05.213", "Score": "9", "CreationDate": "2011-03-18T16:01:05.213", "ParentId": "5354594", "CommentCount": "0", "OwnerUserId": "151292"}, "5354624": {"Id": "5354624", "PostTypeId": "2", "Body": "<p><code>#x</code> is the  stringification directive</p>\n<p><code>#define Stringify(x) #x</code></p>\n<p>means  <code>Stringify(abc)</code> will be substituted with <code>\"abc\"</code></p>\n<p>as in</p>\n<pre><code>#define initVarWithItsOwnName(x) const char* p = #x\n\nint main()\n{\n   initVarWithItsOwnName(Var);\n   std::cout &lt;&lt; Var; //will print Var\n}\n</code></pre>\n", "LastActivityDate": "2011-03-18T16:01:01.397", "Score": "4", "CreationDate": "2011-03-18T16:01:01.397", "ParentId": "5354594", "CommentCount": "0", "OwnerUserId": "469935"}, "5354685": {"Id": "5354685", "PostTypeId": "2", "Body": "<p><code>#</code> is the stringizing operator defined in Section 6.10.3.2 (C99) and in Section 16.3.2. (C++03)</p>\n<p>It converts macro parameters to string literals without expanding the parameter definition.</p>\n<blockquote>\n<p id=\"so_5354594_5354685_0\">If the replacement that results is not a valid character string literal, the\n  behavior is <strong>undefined</strong>.  The order of evaluation of # operator is <strong>unspecified</strong>.</p>\n</blockquote>\n<p>For instance, syntactically, occurrences of the backslash character in string literals are limited to escape sequences. </p>\n<p>In the following example:</p>\n<pre><code>1        #define  mkstr(x)  #  x\n2        char  *p  =  mkstr(a  \\  b);  \n       /*  \"a  \\  b\"  violates  the  syntax  of  string  literals  */\n</code></pre>\n<p>the result of the <code>#</code> operator need not be <code>\"a  \\  b\"</code>.</p>\n", "LastEditorUserId": "165520", "LastActivityDate": "2011-03-18T16:28:24.193", "Score": "2", "CreationDate": "2011-03-18T16:04:59.667", "ParentId": "5354594", "CommentCount": "6", "LastEditDate": "2011-03-18T16:28:24.193", "OwnerUserId": "165520"}, "5354632": {"Id": "5354632", "PostTypeId": "2", "Body": "<p><code>#</code> is the preprocessor's <a href=\"http://msdn.microsoft.com/en-us/library/7e3a913x.aspx\" rel=\"nofollow\">\"stringizing\" operator</a>. It turns macro parameters into string literals. If you called <code>ASSERT(foo &gt;= 32)</code> the <code>#x</code> is expanded to <code>\"foo &gt;= 32\"</code> during evaluation of the macro.</p>\n", "LastActivityDate": "2011-03-18T16:01:16.973", "Score": "3", "CreationDate": "2011-03-18T16:01:16.973", "ParentId": "5354594", "CommentCount": "0", "OwnerUserId": "197015"}, "5354669": {"Id": "5354669", "PostTypeId": "2", "Body": "<p>It's the stringizing operator.</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/7e3a913x(v=vs.80).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/7e3a913x(v=vs.80).aspx</a></p>\n", "LastActivityDate": "2011-03-18T16:03:21.303", "Score": "1", "CreationDate": "2011-03-18T16:03:21.303", "ParentId": "5354594", "CommentCount": "0", "OwnerUserId": "479869"}, "bq_ids": {"n4140": {"so_5354594_5354685_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 526}}, "n3337": {"so_5354594_5354685_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 517}}, "n4659": {"so_5354594_5354685_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 547}}}, "5354672": {"Id": "5354672", "PostTypeId": "2", "Body": "<p>What you see is called <em>stringification</em>. It allows you to convert an argument of a macro into a string literal. You can read more about it here <a href=\"http://gcc.gnu.org/onlinedocs/cpp/Stringification.html\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/cpp/Stringification.html</a>.</p>\n", "LastActivityDate": "2011-03-18T16:03:39.177", "Score": "0", "CreationDate": "2011-03-18T16:03:39.177", "ParentId": "5354594", "CommentCount": "1", "OwnerUserId": "648078"}, "5354634": {"Id": "5354634", "PostTypeId": "2", "Body": "<p>It's a preprocessor feature called <a href=\"http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification\" rel=\"nofollow\">stringification</a>. It </p>\n<blockquote>\n<p id=\"so_5354594_5354634_0\">replaces [the macro parameter] with the literal text of the actual argument, converted to a string constant.</p>\n</blockquote>\n", "LastActivityDate": "2011-03-18T16:01:23.057", "Score": "2", "CreationDate": "2011-03-18T16:01:23.057", "ParentId": "5354594", "CommentCount": "0", "OwnerUserId": "367273"}});