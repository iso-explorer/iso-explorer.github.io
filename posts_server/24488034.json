post_cb({"bq_ids": {"n4140": {"so_24488034_24488034_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 452}}, "n3337": {"so_24488034_24488034_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 443}}, "n4659": {"so_24488034_24488034_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 475}}}, "24488301": {"Id": "24488301", "PostTypeId": "2", "Body": "<p>Here are some of the differences between move constructors and other constructors:</p>\n<ul>\n<li>Move constructors can be defaulted</li>\n<li>Move constructors don't prevent a type from being a \"literal type\"</li>\n<li>Non-trivial move constructors prevent a type from being a \"trivially copyable type\"</li>\n<li>Move constructors prevent the implicit move constructor from being generated</li>\n<li>Move constructors may be automatically called by standard library functions</li>\n</ul>\n<p>As far as I can tell, for all of those, not calling <code>X(const X &amp;&amp;)</code> a move constructor gives undesirable results.</p>\n<p>You give an alternative: it might be called a copy constructor instead. That too seems to have undesirable results: it would suppress the implicit copy constructor.</p>\n<p>Whether a move constructor actually moves doesn't matter. A POD type may have a move constructor too. It'll just be making a copy, but it's still called a move constructor.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-06-30T10:48:13.330", "Score": "9", "CreationDate": "2014-06-30T10:43:10.423", "ParentId": "24488034", "CommentCount": "10", "OwnerUserId": "743382", "LastEditDate": "2014-06-30T10:48:13.330"}, "24488034": {"ViewCount": "321", "Body": "<blockquote>\n<p id=\"so_24488034_24488034_0\"><code>[C++11: 12.8/3]:</code> A non-template constructor for <code>class X</code> is a move constructor if its \ufb01rst parameter is of <code>typeX&amp;&amp;</code>, <code>const X&amp;&amp;</code>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6). <em>[..]</em></p>\n</blockquote>\n<p>Why is a constructor that takes a <code>const</code> rvalue reference called a \"move constructor\" by the standard? Surely <a href=\"https://stackoverflow.com/a/10770227/560648\">it's self-evident</a> that <a href=\"https://stackoverflow.com/q/24484680/560648\">this prohibits meaningful move semantics</a> in all but the most fringey cases?</p>\n<p>\"According to me\", as the SO saying goes, <code>T(const T&amp;&amp;)</code> shouldn't be deemed a \"move constructor\" as such, since <a href=\"https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use?lq=1\">it's basically useless</a>.</p>\n<p>If <em>anything</em>, shouldn't it be called a copy constructor?</p>\n", "AcceptedAnswerId": "24488301", "Title": "Why is `T(const T&&)` called a move constructor?", "CreationDate": "2014-06-30T10:28:08.880", "Id": "24488034", "CommentCount": "19", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:52:13.847", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-30T10:48:13.330", "Score": "5", "OwnerUserId": "560648", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "1"}});