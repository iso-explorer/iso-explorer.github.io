post_cb({"9586355": {"CommentCount": "1", "ViewCount": "228", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-03-06T15:12:20.460", "LastActivityDate": "2012-03-06T16:15:08.700", "Title": "C++ Accessing members of an instance via class scope", "LastEditDate": "2017-05-23T11:48:02.830", "Id": "9586355", "Score": "1", "Body": "<p>I am porting an application from Windows to Linux.\nOne component reads structured data from a file. </p>\n<p>Sample Input:\n#10=CLOSED_POCKET(2.0, CARPET);</p>\n<p>For every possible entity a corresponding c++ class is generated from the type definition.\nA factory creates the according object depending on the name of the entity (i.e CLOSED_POCKET). Afterwards the attributes are read one after another. Therefore we want to assign the members of the c++ class via the index of the current attribute.</p>\n<p>The code works correctly on Windows compiled with Visual Studio 2010. I ported the code to Linux 10.04 (Lucid Lynx) and compiled it successfully with gcc 4.4.6 in Eclipse CDT Indigo.</p>\n<p>Problem on Linux:\nWhen I access methods of the attributes the debugger sometimes jumps to wrong functions (resp. the function offset is not correct when function of subclasses should be called) what results in a segmentation fault.</p>\n<p>I made a minimal example which also results in a segmentation fault (see below).</p>\n<p>My Question is now: When Windows is able to run it successfully, what do I have to do, to run it under Linux with GCC?</p>\n<p>I know that Downcasting virtual inherited classes is illegal according to the c++ standard (see <a href=\"https://stackoverflow.com/questions/6044527/downcast-in-a-diamond-hierarchy\">Downcast in a diamond hierarchy</a>\n), but maybe there exists another solution to access members of instances via class scope.\nThe virtual inheritance is needed because of the structure of the entities given from a ISO standard.</p>\n<p>I also tought about providing an access array (MemberPtrArray) for every instance, but with about 80'000 entities read, an access over class scope would be nicer.</p>\n<pre><code>/*\n * MemberPointerTest.h\n */\n\n#ifndef MAINTEST_H_\n#define MAINTEST_H_\n\n#include &lt;string&gt;\n\nclass BaseAttribute{\npublic:\n    virtual void SetReal(double value);\n    virtual void SetSelectName(std::string selectName);\n};\nclass RealAttribute : public BaseAttribute{\npublic:\n    double value;\n    virtual void SetReal(double value);\n};\nclass SelectAttribute: public BaseAttribute{\npublic:\n    std::string selectName;\n    virtual void SetSelectName(std::string selectName);\n};\n\nclass BaseEntity{\npublic:\n    BaseAttribute id;\n    virtual ~BaseEntity(){}\n};\nclass PocketEntity : virtual public BaseEntity{\npublic:\n    RealAttribute depth;\n};\nclass ClosedPocketEntity : virtual public PocketEntity{\npublic:\n    SelectAttribute surfaceType;\n    static BaseAttribute ClosedPocketEntity::* memberPtrArray[3];\n    BaseAttribute* GetMember(unsigned int index);\n};\n\n#endif \n\n\n\n/* \n * MemberPointerTest.cpp\n */\n\n#include \"MemberPointerTest.h\"\n\nvoid BaseAttribute::SetReal(double value){\n\n}\nvoid BaseAttribute::SetSelectName(std::string selectName){\n\n}\n\nvoid RealAttribute::SetReal(double value){\n    this-&gt;value = value;\n}\nvoid SelectAttribute::SetSelectName(std::string selectName){\n    this-&gt;selectName = selectName;\n}\n\nBaseAttribute ClosedPocketEntity::* ClosedPocketEntity::memberPtrArray[] = {\n        (BaseAttribute ClosedPocketEntity::*) &amp;PocketEntity::depth,\n        (BaseAttribute ClosedPocketEntity::*) &amp;ClosedPocketEntity::surfaceType\n};\n/* Tried the following alternatives:\n*  &amp;PocketEntity::depth, // cannot convert \u2018RealAttribute PocketEntity::*\u2019 to \u2018BaseAttribute ClosedPocketEntity::*\u2019 in initialization\n*  (RealAttribute ClosedPocketEntity::*) &amp;ClosedPocketEntity::depth, // invalid conversion from \u2018RealAttribute ClosedPocketEntity::*\u2019 to \u2018BaseAttribute ClosedPocketEntity::*\u2019\n*/\n\nBaseAttribute* ClosedPocketEntity::GetMember(unsigned int index){\n    return &amp;(this-&gt;*memberPtrArray[index]);\n}\n\n\nint main(){\n    ClosedPocketEntity cpEntity;\n\n    // Case 1: Calls SetReal of BaseAttribute\n    BaseAttribute* depthPtr = cpEntity.GetMember(0);\n    depthPtr-&gt;SetReal(3.0);\n\n    // Case 2: Produces Segmentation fault\n    RealAttribute* depthPtr2 = dynamic_cast&lt;RealAttribute*&gt;(cpEntity.GetMember(0));\n    depthPtr2-&gt;SetReal(2.0); // SIGSEGV\n\n    return 0;\n\n}\n</code></pre>\n", "Tags": "<c++><linux><segmentation-fault><porting>", "OwnerUserId": "1240345", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9586355_9587564_0": {"section_id": 43, "quality": 0.8, "length": 24}}, "n3337": {"so_9586355_9587564_0": {"section_id": 40, "quality": 0.8, "length": 24}}, "n4659": {"so_9586355_9587564_0": {"section_id": 43, "quality": 0.8, "length": 24}}}, "9587564": {"ParentId": "9586355", "CommentCount": "1", "Body": "<pre><code>BaseAttribute ClosedPocketEntity::* ClosedPocketEntity::memberPtrArray[] = {\n        (BaseAttribute ClosedPocketEntity::*) &amp;PocketEntity::depth,\n        (BaseAttribute ClosedPocketEntity::*) &amp;ClosedPocketEntity::surfaceType\n};\n</code></pre>\n<p>The first pointer conversion you're forcing here is invalid. From C++03 \u00a74.11/2 <em>Pointer to member conversion</em>:</p>\n<blockquote>\n<p id=\"so_9586355_9587564_0\">An rvalue of type \u201cpointer to member of B of type cv T,\u201d where B is a class type, can be converted to an rvalue of type \u201cpointer to member of D of type cv T,\u201d where D is a derived class (clause 10) of B. If B is an inaccessible (clause 11), ambiguous (10.2) or <strong>virtual (10.1) base class of D, a program that necessitates this\n  conversion is ill-formed.</strong></p>\n</blockquote>\n<p>(Wording unchanged in C++11 as far as I can tell.)</p>\n<p><code>&amp;PocketEntity::depth</code> is of type <code>RealAttribute PocketEntity::*</code>, so even a conversion to <code>RealAttribute ClosedPocketEntity::*</code> would be ill-formed, since <code>PocketEntity</code> is a virtual base of <code>ClosedPocketEntity</code>.</p>\n<p><code>clang++</code> has this helpful error message:</p>\n<pre><code>error: conversion from pointer to member of class 'PocketEntity'\n  to pointer to member of class 'ClosedPocketEntity'\n  via virtual base 'PocketEntity' is not allowed\n</code></pre>\n<p>If you removed the virtual inheritance, the conversion is still invalid according to GCC and clang:</p>\n<pre><code>error: cannot initialize an array element of type\n 'BaseAttribute ClosedPocketEntity::*'\nwith an rvalue of type\n 'RealAttribute PocketEntity::*'\n</code></pre>\n<p>Nothing I can see in that section of the standard would allow this conversion (but do note that I'm out of my depth here, and might very well be missing something in the wonderful C++ conversion rules).</p>\n<p>The compiler you used on Windows either allows this as an extension, or just happens to \"do what you want\" in this case. Other compilers appear to deal differently with that forced invalid cast.</p>\n<p>As for how to fix this, I'm afraid I have no idea. (Are you sure you need such an intricate design?)</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "9587564", "Score": "2", "CreationDate": "2012-03-06T16:15:08.700", "LastActivityDate": "2012-03-06T16:15:08.700"}});