post_cb({"15999078": {"ParentId": "15911714", "CommentCount": "3", "Body": "<p><code>char</code>/<code>signed char</code>/<code>unsigned char</code> are three different types, and a <code>char</code> is not always 8 bits. on most platform they are all 8-bits integer, but std::ostream only defined char version of <code>&gt;&gt;</code> for behaviors like <code>scanf(\"%c\", ...)</code>.</p>\n", "OwnerUserId": "1723114", "PostTypeId": "2", "Id": "15999078", "Score": "-1", "CreationDate": "2013-04-14T12:28:30.607", "LastActivityDate": "2013-04-14T12:28:30.607"}, "16002781": {"ParentId": "15911714", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From \u00a7 18.4.1 [cstdint.syn] of the C++0x FDIS (N3290), <code>int8_t</code> is an optional typedef that is specified as follows:</p>\n<pre><code>namespace std {\n  typedef signed integer type int8_t;  // optional\n  //...\n} // namespace std\n</code></pre>\n<p>\u00a7 3.9.1 [basic.fundamental] states:</p>\n<blockquote>\n<p id=\"so_15911714_16002781_0\">There are five <em>standard signed integer types</em>: \u201c<code>signed char</code>\u201d, \u201c<code>short int</code>\u201d, \u201c<code>int</code>\u201d, \u201c<code>long int</code>\u201d, and \u201c<code>long long int</code>\u201d. In this list, each type provides at least as much storage as those preceding it in the list. There may also be implementation-defined <em>extended signed integer types</em>. The standard and extended signed integer types are collectively called <em>signed integer types</em>.</p>\n<p id=\"so_15911714_16002781_1\">...</p>\n<p id=\"so_15911714_16002781_2\">Types <code>bool</code>, <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and the signed and unsigned integer types are collectively called <em>integral types</em>. A synonym for integral type is <em>integer type</em>.</p>\n</blockquote>\n<p>\u00a7 3.9.1 also states:</p>\n<blockquote>\n<p id=\"so_15911714_16002781_3\">In any particular implementation, a plain <code>char</code> object can take on either the same values as a <code>signed char</code> or an <code>unsigned char</code>; which one is implementation-defined.</p>\n</blockquote>\n<p>It is tempting to conclude that <code>int8_t</code> may be a typedef of <code>char</code> provided <code>char</code> objects take on signed values; however, this is not the case as <code>char</code> is not among the list of <em>signed integer types</em> (standard and possibly extended signed integer types). See also <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/764409/visual-studio-2012-c-std-make-unsigned\" rel=\"noreferrer\">Stephan T. Lavavej's comments</a> on <code>std::make_unsigned</code> and <code>std::make_signed</code>.</p>\n<p>Therefore, either <code>int8_t</code> is a typedef of <code>signed char</code> or it is an extended signed integer type whose objects occupy exactly 8 bits of storage.</p>\n<p>To answer your question, though, you should not make assumptions. Because functions of both forms <code>x.operator&lt;&lt;(y)</code> and <code>operator&lt;&lt;(x,y)</code> have been defined, \u00a7 13.5.3 [over.binary] says that we refer to \u00a7 13.3.1.2 [over.match.oper] to determine the interpretation of <code>std::cout &lt;&lt; i</code>. \u00a7 13.3.1.2 in turn says that the implementation selects from the set of candidate functions according to \u00a7 13.3.2 and \u00a7 13.3.3. We then look to \u00a7 13.3.3.2 [over.ics.rank] to determine that:</p>\n<ul>\n<li>The <code>template&lt;class traits&gt; basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;, signed char)</code> template would be called if <code>int8_t</code> is an Exact Match for <code>signed char</code> (i.e. a typedef of <code>signed char</code>).</li>\n<li>Otherwise, the <code>int8_t</code> would be promoted to <code>int</code> and the <code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(int n)</code> member function would be called.</li>\n</ul>\n<p>In the case of <code>std::cout &lt;&lt; u</code> for <code>u</code> a <code>uint8_t</code> object:</p>\n<ul>\n<li>The <code>template&lt;class traits&gt; basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;, unsigned char)</code> template would be called if <code>uint8_t</code> is an Exact Match for <code>unsigned char</code>.</li>\n<li>Otherwise, since <code>int</code> can represent all <code>uint8_t</code> values, the <code>uint8_t</code> would be promoted to <code>int</code> and the <code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(int n)</code> member function would be called.</li>\n</ul>\n<p>If you always want to print a character, the safest and most clear option is:</p>\n<pre><code>std::cout &lt;&lt; static_cast&lt;signed char&gt;(i);\n</code></pre>\n<p>And if you always want to print a number:</p>\n<pre><code>std::cout &lt;&lt; static_cast&lt;int&gt;(i);\n</code></pre>\n", "OwnerUserId": "196844", "LastEditorUserId": "196844", "LastEditDate": "2013-04-24T11:11:14.350", "Id": "16002781", "Score": "22", "CreationDate": "2013-04-14T18:33:00.697", "LastActivityDate": "2013-04-24T11:11:14.350"}, "15911793": {"ParentId": "15911714", "CommentCount": "0", "Body": "<p>The working draft copy I have, N3376, specifies in [cstdint.syn] \u00a7 18.4.1 that the int types are typically typedefs.</p>\n<pre><code>namespace std {\ntypedef signed integer type int8_t; // optional\ntypedef signed integer type int16_t; // optional\ntypedef signed integer type int32_t; // optional\ntypedef signed integer type int64_t; // optional\ntypedef signed integer type int_fast8_t;\ntypedef signed integer type int_fast16_t;\ntypedef signed integer type int_fast32_t;\ntypedef signed integer type int_fast64_t;\ntypedef signed integer type int_least8_t;\ntypedef signed integer type int_least16_t;\ntypedef signed integer type int_least32_t;\ntypedef signed integer type int_least64_t;\ntypedef signed integer type intmax_t;\ntypedef signed integer type intptr_t; // optional\ntypedef unsigned integer type uint8_t; // optional\ntypedef unsigned integer type uint16_t; // optional\ntypedef unsigned integer type uint32_t; // optional\ntypedef unsigned integer type uint64_t; // optional\ntypedef unsigned integer type uint_fast8_t;\ntypedef unsigned integer type uint_fast16_t;\ntypedef unsigned integer type uint_fast32_t;\ntypedef unsigned integer type uint_fast64_t;\ntypedef unsigned integer type uint_least8_t;\ntypedef unsigned integer type uint_least16_t;\ntypedef unsigned integer type uint_least32_t;\ntypedef unsigned integer type uint_least64_t;\ntypedef unsigned integer type uintmax_t;\ntypedef unsigned integer type uintptr_t; // optional\n} // namespace std\n</code></pre>\n<p>Since the only requirement made is that it must be 8 bits, then typedef to a char is acceptable. </p>\n", "OwnerUserId": "1381108", "PostTypeId": "2", "Id": "15911793", "Score": "5", "CreationDate": "2013-04-09T20:24:50.750", "LastActivityDate": "2013-04-09T20:24:50.750"}, "16006093": {"ParentId": "15911714", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>I'll answer your questions in reverse order.</p>\n<blockquote>\n<p id=\"so_15911714_16006093_0\">Does the standard specify whether this type can or will be a character type?</p>\n</blockquote>\n<p><strong>Short answer</strong>: <code>int8_t</code> is <code>signed char</code> in the most popular platforms (GCC/Intel/Clang on Linux and Visual Studio on Windows) but might be something else in others.</p>\n<p>The long answer follows.</p>\n<p>Section 18.4.1 of the C++11 Standard provides the synopsis of <code>&lt;cstdint&gt;</code> which includes the following</p>\n<blockquote>\n<p id=\"so_15911714_16006093_1\"><code>typedef</code> <em>signed integer type</em> <code>int8_t; //optional</code></p>\n</blockquote>\n<p>Later in the same section, paragraph 2, it says</p>\n<blockquote>\n<p id=\"so_15911714_16006093_2\">The header [<code>&lt;cstdint&gt;</code>] defines all functions, types, and macros the same as 7.18 in the <strong>C standard</strong>.</p>\n</blockquote>\n<p>where C standard means C99 as per 1.1/2:</p>\n<blockquote>\n<p id=\"so_15911714_16006093_3\">C ++ is a general purpose programming language based on the C programming language as described in <strong>ISO/IEC 9899:1999 Programming languages \u2014 C</strong> (hereinafter referred to as the <strong>C standard</strong>).</p>\n</blockquote>\n<p>Hence, the definition of <code>int8_t</code> is to be found in Section 7.18 of the C99 standard. More precisely, C99's Section 7.18.1.1 says</p>\n<blockquote>\n<p id=\"so_15911714_16006093_4\">The <code>typedef</code> name <code>intN_t</code> designates a signed integer type with width <code>N</code> , no padding bits, and a two\u2019s complement representation. Thus, <strong>int8_t denotes a signed integer type with a width of exactly 8 bits</strong>.</p>\n</blockquote>\n<p>In addition, C99's Section 6.2.5/4 says</p>\n<blockquote>\n<p id=\"so_15911714_16006093_5\">There are five <strong>standard signed integer types</strong>, designated as <strong>signed char</strong>, <strong>short int</strong>, <strong>int</strong>, <strong>long int</strong>, and <strong>long long int</strong>. (These and other types may be designated in several additional ways, as described in 6.7.2.) There may also be <strong>implementation-defined extended signed integer types</strong>. The <strong>standard and extended signed integer types are collectively called signed integer types</strong>.</p>\n</blockquote>\n<p>Finally, C99's Section 5.2.4.2.1 imposes minimum sizes for standard signed integer types. Excluding <code>signed char</code>, all others are at least 16 bits long.</p>\n<p>Therefore, <code>int8_t</code> is either <code>signed char</code> or an 8 bits long extended (non standard) signed integer type.</p>\n<p>Both glibc (the GNU C library) and Visual Studio C library define <code>int8_t</code> as <code>signed char</code>. Intel and Clang, at least on Linux, also use libc and hence, the same applies to them. Therefore, in the most popular platforms <code>int8_t</code> is <code>signed char</code>.</p>\n<blockquote>\n<p id=\"so_15911714_16006093_6\">Given this C++11 program, should I expect to see a number or a letter? Or not make expectations?</p>\n</blockquote>\n<p><strong>Short answer</strong>: In the most popular platforms (GCC/Intel/Clang on Linux and Visual Studio on Windows) you will certainly see the letter 'A'. In other platforms you might get see <code>65</code> though. (Thanks to <a href=\"https://stackoverflow.com/users/420683/dyp\">DyP</a> for pointing this out to me.)</p>\n<p>In the sequel, all references are to the C++11 standard (current draft, N3485).</p>\n<p>Section 27.4.1 provides the synopsis of <code>&lt;iostream&gt;</code>, in particular, it states the declaration of <code>cout</code>:</p>\n<pre><code>extern ostream cout;\n</code></pre>\n<p>Now, <code>ostream</code> is a <code>typedef</code> for a template specialization of <code>basic_ostream</code> as per Section 27.7.1:</p>\n<pre><code>template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\nclass basic_ostream;\n\ntypedef basic_ostream&lt;char&gt; ostream;\n</code></pre>\n<p>Section 27.7.3.6.4 provides the following declaration:</p>\n<pre><code>template&lt;class traits&gt;\nbasic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, signed char c);\n</code></pre>\n<p>If <code>int8_t</code> is <code>signed char</code> then it's this overload that's going to be called. The same section also specifies that the effect of this call is printing the character (not the number).</p>\n<p>Now, let's consider the case where <code>int8_t</code> is an extended signed integer type. Obviously, the standard doesn't specify overloads of <code>operator&lt;&lt;()</code> for non standard types but thanks to promotions and convertions one of the provided overloads might accept the call. Indeed, <code>int</code> is at least 16 bits long and can represent all the values of <code>int8_t</code>. Then 4.5/1 gives that <code>int8_t</code> can be <em>promoted</em> to <code>int</code>. On the other hand, 4.7/1 and 4.7/2 gives that <code>int8_t</code> can be <em>converted</em> to <code>signed char</code>. Finally, 13.3.3.1.1 yields that promotion is favored over convertion during overload resolution. Therefore, the following overload (declared in in 23.7.3.1)</p>\n<blockquote>\n<p id=\"so_15911714_16006093_7\">basic_ostream&amp; basic_ostream::operator&lt;&lt;(int n);</p>\n</blockquote>\n<p>will be called. This means that, this code</p>\n<pre><code>int8_t i = 65;\nstd::cout &lt;&lt; i;\n</code></pre>\n<p>will print <code>65</code>.</p>\n<p><strong>Update:</strong></p>\n<p><strong>1</strong>. Corrected the post following <a href=\"https://stackoverflow.com/users/420683/dyp\">DyP</a>'s comment.</p>\n<p><strong>2</strong>. Added the following comments on the possibility of <code>int8_t</code> be a <code>typedef</code> for <code>char</code>.</p>\n<p>As said, the C99 standard (Section 6.2.5/4 quoted above) defines 5 standard signed integer types (<code>char</code> is not one of them) and allows implementations to add their onw which are referred as non standard signed integer types. The C++ standard reinforces that definition in Section 3.9.1/2:</p>\n<blockquote>\n<p id=\"so_15911714_16006093_8\">There are five standard signed integer types : \u201csigned char\u201d, \u201cshort int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\u201d [...] There may also be implementation-defined extended signed integer types. The standard and extended signed integer types are collectively called <strong>signed integer types</strong>.</p>\n</blockquote>\n<p>Later, in the same section, paragraph 7 says:</p>\n<blockquote>\n<p id=\"so_15911714_16006093_9\">Types <code>bool</code>, <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, <strong>and the signed and unsigned integer types</strong> are collectively called <strong>integral types</strong>. A synonym for integral type is <strong>integer type</strong>. </p>\n</blockquote>\n<p>Therefore, <code>char</code> is an integer type  but <strong><code>char</code> is neither a signed integer type nor an unsigned integer type</strong> and Section 18.4.1 (quoted above) says that <code>int8_t</code>, when present, is a <code>typedef</code> for a signed integer type.</p>\n<p>What might be confusing is that, depending on the implementation, <code>char</code> can take the same values as a <code>signed char</code>. In particular, <code>char</code> might have a sign but it's still not a <code>signed char</code>. This is explicitly said in Section 3.9.1/1:</p>\n<blockquote>\n<p id=\"so_15911714_16006093_10\">[...] Plain <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are <strong>three distinct types</strong>. [...] In any particular implementation, a plain <code>char</code> object can take on either the same values as a <code>signed char</code> or an <code>unsigned char</code>; which one is implementation-defined.</p>\n</blockquote>\n<p>This also implies that <code>char</code> is <strong>not</strong> a signed integer type as defined by 3.9.1/2.</p>\n<p><strong>3</strong>. I admit that my interpretation and, specifically, the sentence \"<code>char</code> is neither a signed integer type nor an unsigned integer type\" is a bit controversial.</p>\n<p>To strength my case, I would like to add that Stephan T. Lavavej said the very same thing <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/764409/visual-studio-2012-c-std-make-unsigned\" rel=\"nofollow noreferrer\">here</a> and <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub - litb</a> also used the same sentence in a comment on <a href=\"https://stackoverflow.com/q/9285657/1137388\">this</a> post.</p>\n", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:57.647", "Id": "16006093", "Score": "5", "CreationDate": "2013-04-15T00:49:53.463", "LastActivityDate": "2013-04-23T10:58:30.703"}, "15911714": {"CommentCount": "2", "AcceptedAnswerId": "16002781", "PostTypeId": "1", "LastEditorUserId": "16287", "CreationDate": "2013-04-09T20:20:03.803", "LastActivityDate": "2017-11-01T16:15:16.000", "LastEditDate": "2017-11-01T16:15:16.000", "ViewCount": "13351", "FavoriteCount": "7", "Title": "Are int8_t and uint8_t intended to be char types?", "Id": "15911714", "Score": "53", "Body": "<p>Given this C++11 program, should I expect to see a number or a letter?  Or not make expectations?</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    int8_t i = 65;\n    std::cout &lt;&lt; i;\n}\n</code></pre>\n<p>Does the standard specify whether this type can or will be a character type?</p>\n", "Tags": "<c++><c++11><iostream><language-lawyer><standard-library>", "OwnerUserId": "16287", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_15911714_16006093_10": {"section_id": 7210, "quality": 0.96, "length": 24}, "so_15911714_16006093_8": {"section_id": 7211, "quality": 0.9090909090909091, "length": 30}, "so_15911714_16006093_3": {"section_id": 5760, "quality": 0.9285714285714286, "length": 13}, "so_15911714_16006093_5": {"section_id": 7211, "quality": 0.6818181818181818, "length": 30}, "so_15911714_16006093_1": {"section_id": 5348, "quality": 0.6666666666666666, "length": 4}, "so_15911714_16002781_3": {"section_id": 7210, "quality": 0.9375, "length": 15}, "so_15911714_16006093_2": {"section_id": 6797, "quality": 0.8, "length": 8}, "so_15911714_16002781_0": {"section_id": 7211, "quality": 0.9302325581395349, "length": 40}, "so_15911714_16002781_2": {"section_id": 7216, "quality": 0.9473684210526315, "length": 18}, "so_15911714_16006093_9": {"section_id": 7216, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_15911714_16006093_10": {"section_id": 6954, "quality": 0.96, "length": 24}, "so_15911714_16006093_8": {"section_id": 6955, "quality": 0.9090909090909091, "length": 30}, "so_15911714_16006093_3": {"section_id": 5533, "quality": 0.9285714285714286, "length": 13}, "so_15911714_16006093_5": {"section_id": 6955, "quality": 0.6818181818181818, "length": 30}, "so_15911714_16006093_1": {"section_id": 5145, "quality": 0.6666666666666666, "length": 4}, "so_15911714_16002781_3": {"section_id": 6954, "quality": 0.9375, "length": 15}, "so_15911714_16006093_2": {"section_id": 6552, "quality": 0.8, "length": 8}, "so_15911714_16002781_0": {"section_id": 6955, "quality": 0.9302325581395349, "length": 40}, "so_15911714_16002781_2": {"section_id": 6960, "quality": 0.9473684210526315, "length": 18}, "so_15911714_16006093_9": {"section_id": 6960, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_15911714_16006093_10": {"section_id": 8719, "quality": 0.96, "length": 24}, "so_15911714_16006093_8": {"section_id": 8720, "quality": 0.8787878787878788, "length": 29}, "so_15911714_16006093_3": {"section_id": 7216, "quality": 0.8571428571428571, "length": 12}, "so_15911714_16002781_3": {"section_id": 8719, "quality": 0.9375, "length": 15}, "so_15911714_16006093_1": {"section_id": 6773, "quality": 0.6666666666666666, "length": 4}, "so_15911714_16006093_2": {"section_id": 8287, "quality": 0.6, "length": 6}, "so_15911714_16002781_0": {"section_id": 8720, "quality": 0.9069767441860465, "length": 39}, "so_15911714_16002781_2": {"section_id": 8725, "quality": 1.0, "length": 19}, "so_15911714_16006093_9": {"section_id": 8725, "quality": 1.0, "length": 19}, "so_15911714_16006093_5": {"section_id": 8720, "quality": 0.6590909090909091, "length": 29}}}, "15911962": {"ParentId": "15911714", "PostTypeId": "2", "CommentCount": "20", "Body": "<p><code>int8_t</code> is exactly 8 bits wide (if it exists).</p>\n<p>The only predefined integer types that can be 8 bits are <code>char</code>, <code>unsigned char</code>, and <code>signed char</code>. Both <code>short</code> and <code>unsigned short</code> are required to be at least 16 bits.</p>\n<p>So <code>int8_t</code> must be a typedef for either <code>signed char</code> or plain <code>char</code> (the latter if plain <code>char</code> is signed).</p>\n<p>If you want to print an <code>int8_t</code> value as an integer rather than as a character, you can explicitly convert it to <code>int</code>.</p>\n<p>In principle, a C++ compiler could define an 8-bit <em>extended integer type</em> (perhaps called something like <code>__int8</code>), and make <code>int8_t</code> a typedef for it. The only reason I can think of to do so would be to avoid making <code>int8_t</code> a character type. I don't know of any C++ compilers that have actually done this.</p>\n<p>Both <code>int8_t</code> and extended integer types were introduced in C99. For C, there's no particular reason to define an 8-bit extended integer type when the <code>char</code> types are available.</p>\n<p><strong>UPDATE</strong>:</p>\n<p>I'm not entirely comfortable with this conclusion. <code>int8_t</code> and <code>uint8_t</code> were introduced in C99. In C, it doesn't particularly matter whether they're character types or not; there are no operations for which the distinction makes a real difference. (Even <code>putc()</code>, the lowest-level character output routine in standard C, takes the character to be printed as an <code>int</code> argument). <code>int8_t</code>, and <code>uint8_t</code>, if they're defined, will almost certainly be defined as character types -- but character types are just small integer types.</p>\n<p>C++ provides specific overloaded versions of <code>operator&lt;&lt;</code> for <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>, so that <code>std::cout &lt;&lt; 'A'</code> and <code>std::cout &lt;&lt; 65</code> produce very different output. Later, C++ adopted <code>int8_t</code> and <code>uint8_t</code>, but in such a way that, as in C, they're almost certainly character types. For most operations, this doesn't matter any more than it does in C, but for <code>std::cout &lt;&lt; ...</code> it does make a difference, since this:</p>\n<pre><code>uint8_t x = 65;\nstd::cout &lt;&lt; x;\n</code></pre>\n<p>will probably print the letter <code>A</code> rather than the number <code>65</code>.</p>\n<p>If you want consistent behavior, add a cast:</p>\n<pre><code>uint8_t x = 65;\nstd::cout &lt;&lt; int(x); // or static_cast&lt;int&gt;(x) if you prefer\n</code></pre>\n<p>I think the root of the problem is that there's something missing from the language: very narrow integer types that are not character types.</p>\n<p>As for the <em>intent</em>, I could speculate that the committee members either didn't think about the issue, or decided it wasn't worth addressing. One could argue (and I would) that the benefits of adding the <code>[u]int*_t</code> types to the standard outweighs the inconvenience of their rather odd behavior with <code>std::cout &lt;&lt; ...</code>.</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2013-04-11T01:58:03.643", "Id": "15911962", "Score": "24", "CreationDate": "2013-04-09T20:34:17.650", "LastActivityDate": "2013-04-11T01:58:03.643"}});