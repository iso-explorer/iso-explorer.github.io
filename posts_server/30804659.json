post_cb({"bq_ids": {"n4140": {"so_30804659_30805815_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6143}, "so_30804659_30805815_2": {"length": 25, "quality": 1.0, "section_id": 5943}, "so_30804659_30805815_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6138}, "so_30804659_30804659_0": {"length": 105, "quality": 1.0, "section_id": 6142}, "so_30804659_30805815_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 675}}, "n3337": {"so_30804659_30805815_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 5907}, "so_30804659_30805815_2": {"length": 25, "quality": 1.0, "section_id": 5714}, "so_30804659_30805815_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5902}, "so_30804659_30804659_0": {"length": 105, "quality": 1.0, "section_id": 5906}, "so_30804659_30805815_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 665}}, "n4659": {"so_30804659_30805815_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 7639}, "so_30804659_30805815_2": {"length": 25, "quality": 1.0, "section_id": 7428}, "so_30804659_30805815_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7635}, "so_30804659_30805815_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 703}}}, "30804659": {"ViewCount": "178", "Body": "<p>I used to think that adding an integral type to a pointer (provided that the the pointer points to an array of a certain size etc. etc.) is always well defined, regardless of the integral type. The C++11 standard says ([expr.add]):</p>\n<blockquote>\n<p id=\"so_30804659_30804659_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. In other words, if the expression P points to the i -th element of an array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N has the value n ) point to, respectively, the i + n -th and i \u2212 n -th elements of the array object, provided they exist. Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>On the other hand, it was brought to my attention recently that the built-in add operators for pointers are defined in terms of <code>ptrdiff_t</code>, which is a signed type (see 13.6/13). This seems to hint that if one does a <code>malloc()</code> with a very large (unsigned) size and then tries to reach the end of the allocated space via a pointer addition with a <code>std::size_t</code> value, this might result in undefined behaviour because the unsigned <code>std::size_t</code> will be converted to <code>ptrdiff_t</code> which is potentially UB.</p>\n<p>I imagine similar issues would arise, e.g., in the <code>operator[]()</code> of <code>std::vector</code>, which is implemented in terms of an unsigned <code>size_type</code>. In general, it seems to me like this would make practically impossible to fully use the memory storage available on a platform.</p>\n<p>It's worth noting that nor GCC nor Clang complain about signed-unsigned integral conversions with all the relevant diagnostic turned on when adding unsigned values to pointers.</p>\n<p>Am I missing something?</p>\n<p><strong>EDIT</strong>: I'd like to clarify that I am talking about additions involving a pointer and an integral type (not two pointers).</p>\n<p><strong>EDIT2</strong>: an equivalent way of formulating the question might be this. Does this code result in UB in the second line, if <code>ptrdiff_t</code> has a smaller positive range than <code>size_t</code>?</p>\n<pre><code>char *ptr = static_cast&lt;char * &gt;(std::malloc(std::numeric_limits&lt;std::size_t&gt;::max()));\nauto end = ptr + std::numeric_limits&lt;std::size_t&gt;::max();\n</code></pre>\n", "AcceptedAnswerId": "30805815", "Title": "Confusion regarding types, overflows and UB in pointer-integral addition", "CreationDate": "2015-06-12T13:44:04.337", "Id": "30804659", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-06-12T14:28:51.640", "LastEditorUserId": "453925", "LastActivityDate": "2015-06-12T14:40:24.660", "Score": "8", "OwnerUserId": "453925", "Tags": "<c++><pointers><c++11>", "AnswerCount": "1"}, "30805815": {"Id": "30805815", "PostTypeId": "2", "Body": "<p>Your question is based on a false premise. </p>\n<p>Subtraction of pointers produces a ptrdiff_t \u00a7[expr.add]/6:</p>\n<blockquote>\n<p id=\"so_30804659_30805815_0\">When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two array elements. The type of the result is an implementation-defined signed integral type; this type shall be the same type that is defined as std::ptrdiff_t in the  header (18.2).</p>\n</blockquote>\n<p>That does <em>not</em>, however, mean that addition is defined in terms of <code>ptrdiff_t</code>. Rather the contrary, for addition only one conversion is specified (\u00a7[expr.add]/1):</p>\n<blockquote>\n<p id=\"so_30804659_30805815_1\">The usual arithmetic conversions are performed for operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>The \"usual arithmetic conversions\" are defined in \u00a7[expr]/10. This includes only one conversion from unsigned type to signed type:</p>\n<blockquote>\n<p id=\"so_30804659_30805815_2\">Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</p>\n</blockquote>\n<p>So, while there may be some room for question about exactly what type the <code>size_t</code> will be converted to (and whether it's converted at all), there's no question on one point: the only way it can be converted to a <code>ptrdiff_t</code> is if all its values can be represented without change as a <code>ptrdiff_t</code>.</p>\n<p>So, given:</p>\n<pre><code>size_t N;\nT *p;\n</code></pre>\n<p>...the expression <code>p + N</code> will <em>never</em> fail because of some (imagined) conversion of <code>N</code> to a <code>ptrdiff_t</code> before the addition takes place.</p>\n<p>Since \u00a713.6 is being mentioned, perhaps it's best to back up and look carefully at what \u00a713.6 really is:</p>\n<blockquote>\n<p id=\"so_30804659_30805815_3\">The candidate operator functions that represent the built-in operators defined in Clause 5 are specified in this subclause. These candidate functions participate in the operator overload resolution process as described in 13.3.1.2 and <strong>are used for no other purpose</strong>.</p>\n</blockquote>\n<p>[emphasis added]</p>\n<p>In other words, the fact that \u00a713.6 defines an operator that adds a <code>ptrdiff_t</code> to a pointer does <em>not</em> mean that when any other integer type is added to a pointer, it's first converted to a ptrdiff_t, or anything like that. More generally, the operators defined in \u00a713.6 <strong>are never used to carry out any arithmetic operations</strong>.</p>\n<p>With that, and the rest of the text you quoted from \u00a7[expr.add], we can quickly conclude that adding a <code>size_t</code> to a pointer can overflow if and only if there aren't that many elements in the array after the pointer.</p>\n<p>Given the above, one more question probably occurs to you. If I have code like this:</p>\n<pre><code>char *p = huge_array;\nsize_t N = sizeof(huge_array);\nchar *p2 = p + N;\n\nptrdiff_t diff = p2 - p;\n</code></pre>\n<p>...is it possible that the final subtraction will overflow? The short and simple answer to that is: Yes, it can.</p>\n", "LastActivityDate": "2015-06-12T14:40:24.660", "CommentCount": "2", "CreationDate": "2015-06-12T14:40:24.660", "ParentId": "30804659", "Score": "5", "OwnerUserId": "179910"}});