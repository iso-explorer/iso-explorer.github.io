post_cb({"bq_ids": {"n4140": {"so_17192991_17193859_0": {"length": 7, "quality": 0.875, "section_id": 2711}}, "n3337": {"so_17192991_17193859_0": {"length": 7, "quality": 0.875, "section_id": 2672}}, "n4659": {"so_17192991_17193859_0": {"length": 7, "quality": 0.875, "section_id": 3451}}}, "17192991": {"ViewCount": "442", "Body": "<p>I'm writing some threaded C++11 code, and I'm not totally sure on when I need to use a memory fence or something. So here is basically what I'm doing:</p>\n<pre><code>class Worker\n{\n   std::string arg1;\n   int arg2;\n   int arg3;\n   std::thread thread;\n\npublic:\n   Worker( std::string arg1, int arg2, int arg3 )\n   {\n      this-&gt;arg1 = arg1;\n      this-&gt;arg2 = arg2;\n      this-&gt;arg3 = arg3;\n   }\n\n   void DoWork()\n   {\n      this-&gt;thread = std::thread( &amp;Worker::Work, this );\n   }\n\nprivate:\n   Work()\n   {\n      // Do stuff with args\n   }\n}\n\nint main()\n{\n   Worker worker( \"some data\", 1, 2 );\n   worker.DoWork();\n\n   // Wait for it to finish\n   return 0;\n}\n</code></pre>\n<p>I was wondering, what steps do I need to take to make sure that the args are safe to access in the Work() function which runs on another thread. Is it enough that it's written in the constructor, and then the thread is created in a separate function? Or do I need a memory fence, and how do I make a memory fence to make sure all 3 args are written by the main thread, and then read by the Worker thread?</p>\n<p>Thanks for any help!</p>\n", "AcceptedAnswerId": "17193859", "Title": "C++11 When To Use A Memory Fence?", "CreationDate": "2013-06-19T13:48:30.090", "Id": "17192991", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-06-19T14:24:45.967", "Score": "2", "OwnerUserId": "928838", "Tags": "<multithreading><c++11><thread-safety><memory-fences>", "AnswerCount": "1"}, "17193859": {"Id": "17193859", "PostTypeId": "2", "Body": "<p>The C++11 standard section 30.3.1.2 <strong>thread constructors [thread.thread.constr]</strong> p5 describes the constructor <code>template &lt;class F, class... Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args)</code>: </p>\n<blockquote>\n<p id=\"so_17192991_17193859_0\"><em>Synchronization:</em> the completion of the invocation of the constructor synchronizes with the beginning of the invocation of the copy of <code>f</code>.</p>\n</blockquote>\n<p>So everything in the current thread <em>happens before</em> the thread function is called. You don't need to do anything special to ensure that the assignments to the <code>Worker</code> members are complete and will be visible to the new thread.</p>\n<p>In general, you should <em>never</em> have to use a memory fence when writing multithreaded C++11: synchronization is built into mutexes/atomics and they handle any necessary fences for you. (Caveat: you are on your own if you use <em>relaxed atomics</em>.)</p>\n", "LastActivityDate": "2013-06-19T14:24:45.967", "CommentCount": "1", "CreationDate": "2013-06-19T14:24:45.967", "ParentId": "17192991", "Score": "4", "OwnerUserId": "923854"}});