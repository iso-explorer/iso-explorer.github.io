post_cb({"47307620": {"ViewCount": "61", "Body": "<p>In my application, I have several readers which read data out of .csv files. I want to structure them now by creating a parent class for those readers which have in common that they own the method <code>getData(std::string filename)</code>. I wanted to do it by implementing a virtual method in the base class. The filename should be passed by the constructor. </p>\n<p>main</p>\n<pre><code>int main()\n{\n    std::string filename = \"file.csv\";\n    ChildReader1 reader = new ChildReader1(filename);\n}\n</code></pre>\n<p>ChildReader1.h</p>\n<pre><code>class ChildReader1: public ParentReader\n    {\n    public:\n        ChildReader1(std::string filename)\n            : ParentReader(filename)\n        {\n\n        };\n        void getData(std::string filename)\n        {\n             //get the data here\n        }\n    };\n</code></pre>\n<p>ParentReader.h</p>\n<pre><code>class ParentReader\n    {\n    public:\n        ParentReader() {};\n        ParentReader(std::string filename)\n        {\n            getData(filename);\n        };\n        ~ParentReader() {};\n\n        virtual void getData(std::string filename) {};\n    };\n</code></pre>\n<p>At the moment, filename is passed to ParentReader but the getData(filename) opens the virtual method in ParentReader instead of the actual method in ChildReader 1. How can I solve that?</p>\n", "AcceptedAnswerId": "47308756", "Title": "Method in child class doesn't get called by virtual function in parent class", "CreationDate": "2017-11-15T12:36:50.870", "Id": "47307620", "CommentCount": "5", "PostTypeId": "1", "OwnerDisplayName": "user8337500", "LastActivityDate": "2017-11-15T13:42:17.047", "Score": "1", "Tags": "<c++><virtual-method>", "AnswerCount": "4"}, "47308756": {"Id": "47308756", "PostTypeId": "2", "Body": "<p>As others have mentioned, you can't call a virtual method on a derived class in a base class constructor as the derived class is not ready yet. </p>\n<p>One solution is to have a factory function on <code>ChildReader1</code>:</p>\n<pre><code>class ParentReader {\npublic:\n  ParentReader(){};\n  void initialize(const std::string&amp; filename){\n    getData(filename);\n  };\n  virtual ~ParentReader(){};\n  virtual void getData(const std::string&amp; /*filename*/) {\n  };\n};\n\nclass ChildReader1 : public ParentReader {\nprivate:\n  ChildReader1(){}\npublic:\n  void getData(const std::string&amp; /*filename*/) override {\n    // get the data here\n  }\n  static std::unique_ptr&lt;ChildReader1&gt; create(const std::string &amp;filename) {\n    auto reader = std::unique_ptr&lt;ChildReader1&gt;(new ChildReader1);\n    reader-&gt;initialize(filename);\n    return reader;\n  }\n};\n\nint main() {\n  std::string filename = \"file.csv\";\n  auto reader = ChildReader1::create(filename);\n}\n</code></pre>\n<p>The factory function creates a fully formed object and can then call virtual functions before returning. You can make the constructor of the object private to force callers to use your factory function. </p>\n<p>To avoid code duplication between  derived classes you could introduce an intermediate CRTP class.</p>\n", "LastEditorUserId": "3422652", "LastActivityDate": "2017-11-15T13:42:17.047", "Score": "0", "CreationDate": "2017-11-15T13:32:43.707", "ParentId": "47307620", "CommentCount": "8", "OwnerUserId": "3422652", "LastEditDate": "2017-11-15T13:42:17.047"}, "bq_ids": {"n4140": {"so_47307620_47308001_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 447}}, "n3337": {"so_47307620_47308001_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 438}}, "n4659": {"so_47307620_47308001_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 469}}}, "47308792": {"Id": "47308792", "PostTypeId": "2", "Body": "<p>You might solve your issue with a factory:</p>\n<pre><code>class ParentReader\n{\npublic:\n    virtual ~ParentReader() = default\n    virtual void getData(const std::string&amp; filename) = 0;\n};\n\ntemplate &lt;typename T, typename ... Ts&gt;\nstd::unique_ptr&lt;T&gt; MakeReader(const std::string&amp; filename, Ts&amp;&amp;... args)\n{\n    static_assert(std::is_base_of&lt;ParentReader, T&gt;::value, \"!\");\n    auto res = std::make_unique&lt;T&gt;(std::forward&lt;Ts&gt;(args)...);\n    res-&gt;getData(filename);\n    return res;\n}\n</code></pre>\n", "LastActivityDate": "2017-11-15T13:34:10.023", "CommentCount": "0", "CreationDate": "2017-11-15T13:34:10.023", "ParentId": "47307620", "Score": "2", "OwnerUserId": "2684539"}, "47308001": {"Id": "47308001", "PostTypeId": "2", "Body": "<p>The virtual methods are not called during construction of the base (parent) class. Because the the derived is not ready yet.</p>\n<p>12.7 Construction and destruction [class.cdtor] #4 ISO/IEC N3797</p>\n<blockquote>\n<p id=\"so_47307620_47308001_0\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class. If the virtual function call uses an explicit class member access (5.2.5) and the object expression refers to the complete object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2017-11-15T12:55:06.817", "CommentCount": "0", "CreationDate": "2017-11-15T12:55:06.817", "ParentId": "47307620", "Score": "1", "OwnerUserId": "8918119"}, "47308967": {"Id": "47308967", "PostTypeId": "2", "Body": "<p>As said by others, you should not call virtual function in constructor. The reason is quite simple if you think about what is happening:</p>\n<p>call of ChildConstructor -&gt; call of ParentConstructor -&gt; creation of Parent -&gt; call of getData -&gt; creation of Child</p>\n<p>At the call of getData the only existing object is the Parent therefore it can't possibly call the getData of the Child.</p>\n", "LastActivityDate": "2017-11-15T13:42:02.403", "CommentCount": "0", "CreationDate": "2017-11-15T13:42:02.403", "ParentId": "47307620", "Score": "0", "OwnerUserId": "8945252"}});