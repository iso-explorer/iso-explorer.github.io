post_cb({"bq_ids": {"n4140": {"so_24547203_24549996_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3172}, "so_24547203_24549996_2": {"length": 13, "quality": 0.5909090909090909, "section_id": 3183}}, "n3337": {"so_24547203_24549996_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3045}, "so_24547203_24549996_2": {"length": 13, "quality": 0.5909090909090909, "section_id": 3056}}, "n4659": {"so_24547203_24549996_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3842}, "so_24547203_24549996_2": {"length": 13, "quality": 0.5909090909090909, "section_id": 3945}}}, "24549996": {"Id": "24549996", "PostTypeId": "2", "Body": "<p>As I understand (the N3337 draft of the) the standard, everything should be well as long as the shared state is created and a future is not yet fetched.</p>\n<p>The packed_task ctoring and the future fetching are sequential in your code; thus I understand that the possible collision you mention should do no harm; at least there is no such problem mentioned in item 14 below.</p>\n<p>N3337 \u00a730.6.9.1 [futures.task.members]</p>\n<p>has</p>\n<blockquote>\n<p id=\"so_24547203_24549996_0\">1[...]<br/><br>\n<code>template &lt;class F&gt; packaged_task(F&amp;&amp; f);</code> </br></p>\n<p id=\"so_24547203_24549996_1\">[...]<br/>\n  3 Effects: constructs a new packaged_task object with a shared state[...]<br/>\n  [...]<br/> </p>\n<p id=\"so_24547203_24549996_2\">11[...]<br/><br>\n<code>future&lt;R&gt; get_future();</code><br/><br>\n  [...]<br/><br>\n  13 Throws: a future_error object if an error occurs.<br/>\n  14 Error conditions:<br/> \n  \u2014 future_already_retrieved if get_future has already been called on a packaged_task object with the same shared state as *this.<br/> \n  \u2014 no_state if *this has no shared state.<br/></br></br></br></p>\n</blockquote>\n", "LastActivityDate": "2014-07-03T09:31:16.130", "CommentCount": "0", "CreationDate": "2014-07-03T09:31:16.130", "ParentId": "24547203", "Score": "1", "OwnerUserId": "2378245"}, "24547203": {"ViewCount": "37", "Body": "<p>I think this is a simple question about shared access to std::packaged_task.</p>\n<p>In the code below I am not sure if I need a mutex to protect access to the object 'p'.</p>\n<p>It seems that I should, since p.operator() may be called in the background thread at the same time as p.get_future() in the main thread. Or is this sort of access to a packaged_task object already protected in some way?</p>\n<pre><code>static double f(int a, int b) { return a * b; }\n\nint main()\n{\n    // Execute f() \"immediately\" in another thread\n    //std::future&lt;double&gt; result = std::async(f, 2, 3);\n    //std::cout &lt;&lt; result.get() &lt;&lt; std::endl;\n\n    // Deferred execution of f()\n    std::packaged_task&lt;double(int, int)&gt; p(f);\n    std::thread tt([&amp;p]{ /* processing ... */; p(2, 3); });\n    std::cout &lt;&lt; p.get_future().get() &lt;&lt; std::endl;\n    tt.join();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "24549996", "Title": "Protecting access to packaged_task", "CreationDate": "2014-07-03T07:09:04.763", "Id": "24547203", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-07-03T07:21:11.840", "LastEditorUserId": "767903", "LastActivityDate": "2014-07-03T09:31:16.130", "Score": "1", "OwnerUserId": "767903", "Tags": "<c++11><concurrency>", "AnswerCount": "1"}});