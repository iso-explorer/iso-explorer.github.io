post_cb({"6647613": {"ParentId": "6647542", "CommentCount": "3", "Body": "<p>The C++ standard demands that the delete will be called by the compiler.</p>\n<p>The C+ standard section which addresses this is: </p>\n<p>15.2 Constructors and destructors</p>\n<p>1 <em>As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.</em></p>\n<p>2 <strong><em>An object that is partially constructed or partially destroyed will have destructors executed for all of its fully constructed base classes and non-variant members, that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution. Similarly, if the non-delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s destructor will be invoked. If the object was allocated in a new-expression, the matching deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</em></strong></p>\n<p>3 <em>The process of calling destructors for automatic objects constructed on the path from a try block to a throwexpression is called \u201cstack unwinding.\u201d [ Note: If a destructor called during stack unwinding exits with an exception, std::terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. \u2014end note ]</em></p>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "6647613", "Score": "0", "CreationDate": "2011-07-11T08:35:11.270", "LastActivityDate": "2011-07-11T08:35:11.270"}, "6647542": {"CommentCount": "3", "ViewCount": "876", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-07-11T08:25:17.370", "LastActivityDate": "2014-06-03T15:42:52.710", "Title": "borland c++ compiler won't undo memory allocation when exception thrown across constructor boundary?", "AcceptedAnswerId": "6647610", "LastEditDate": "2017-05-23T10:34:20.683", "Id": "6647542", "Score": "1", "Body": "<p>I am using bcc32 command line compiler from Borland Embarcadero. Consider this program:</p>\n<pre><code>    int main(int, char **)\n    {\n        try\n        {\n            std::string *a = new string(0xf0000000, ' ');\n            ...\n            delete a;\n        }\n        catch(const std::bad_alloc &amp;)\n        {\n            ...\n        }\n    }\n</code></pre>\n<p>When the std::string constructor throws a memory exception, the stack is unwound and control is passed to the catch-block. Gnu compilers build in code to delete the memory allocated for the std::string object 'auto-magically', as was stated by someone who commented on the answer in <a href=\"https://stackoverflow.com/questions/1674980/who-deletes-the-memory-allocated-during-a-new-operation-which-has-exception-in/6639682#6639682\">Who deletes the memory allocated during a \"new\" operation which has exception in constructor?</a> which I wrote. I ran the program in <a href=\"http://ideone.com/IRxHX\" rel=\"nofollow noreferrer\">http://ideone.com/IRxHX</a> and the result is that nobody frees the memory allocated by 'operator new' if an exception is thrown before the result of 'new' is stored in an lvalue. In the above case the variable 'a'. </p>\n<p>Questions are: \n1 Is there a way to delete the memory generated by 'new' in case of an exception, as a part of the stack unwind procedure?\n2 What does the C++ standard demand from compilers in this case</p>\n", "Tags": "<c++><exception><memory-leaks>", "OwnerUserId": "837803", "AnswerCount": "3"}, "6647610": {"ParentId": "6647542", "CommentCount": "18", "Body": "<p>Either your compiler is broken, or something else funny is going on. The implementation is required to free the memory:</p>\n<p>5.3.4/17:</p>\n<blockquote>\n<p id=\"so_6647542_6647610_0\">If any part of the object initialization described above terminates by\n  throwing an exception and a suitable deallocation function can be\n  found, the deallocation function is called to free the memory in which\n  the object was being constructed, after which the exception continues\n  to propagate in the context of the new- expression. If no unambiguous\n  matching deallocation function can be found, propagating the exception\n  does not cause the object\u2019s memory to be freed.</p>\n</blockquote>\n", "OwnerUserId": "13005", "PostTypeId": "2", "Id": "6647610", "Score": "2", "CreationDate": "2011-07-11T08:34:47.410", "LastActivityDate": "2011-07-11T08:34:47.410"}, "bq_ids": {"n4140": {"so_6647542_6647610_0": {"section_id": 6101, "quality": 0.9523809523809523, "length": 40}}, "n3337": {"so_6647542_6647610_0": {"section_id": 5867, "quality": 0.9523809523809523, "length": 40}}, "n4659": {"so_6647542_6647610_0": {"section_id": 7598, "quality": 0.9523809523809523, "length": 40}}}, "6673048": {"ParentId": "6647542", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I tested your sample code with the following, stepping through the code to make sure it all works fine (I took your <a href=\"http://qc.embarcadero.com/wc/qcmain.aspx?d=96035\" rel=\"nofollow\">QC code</a> and modified it to make it work as intended):</p>\n<pre><code>#include &lt;tchar.h&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint count = 0;\nbool start = false;\n\n// from your QC code, modified to count instead of std::cout\nvoid *operator new(size_t cbytes)\n{\n    void *retval = std::malloc(cbytes);\n    if (retval == NULL &amp;&amp; cbytes != 0) throw std::bad_alloc();\n    if (start) count++;\n    return retval;\n}\n\n// from your QC code, modified to count instead of std::cout\nvoid operator delete(void *block)\n{\n    if (block != NULL)\n    {\n        std::free(block);\n        if (start) count--;\n    }\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    try\n    {\n        start = true;\n        std::string *a = new std::string(0xf0000000, ' ');\n        // ....\n        delete a;\n    }\n    catch(const std::bad_alloc&amp;)\n    {\n    }\n    std::cout &lt;&lt; count;\n    return 0;\n}\n</code></pre>\n<p>I get <code>0</code> for <code>count</code> indicating that the partially constructed string does get its memory freed. Tested with MSVC++ 2005 / 2010 with the same results.</p>\n<p>Tested with C++ Builder 2010 (command line: <code>bcc32 program.cpp</code>). It <em>is</em> consistent with the C++ standards.</p>\n<p>EDIT: Ah, finally saw that your QC report specifies the <strong><em>usage of dynamic RTL</em></strong> with the command line <code>bcc32 -WCR program.cpp</code>. And yes, when compiling with dynamic RTL, I see the problem. Even then, my test case would've been much better at show casing the problem.</p>\n", "OwnerUserId": "383306", "LastEditorUserId": "383306", "LastEditDate": "2011-07-13T01:46:37.187", "Id": "6673048", "Score": "2", "CreationDate": "2011-07-13T01:06:12.867", "LastActivityDate": "2011-07-13T01:46:37.187"}});