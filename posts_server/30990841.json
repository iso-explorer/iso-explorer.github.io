post_cb({"bq_ids": {"n4140": {"so_30990841_30991076_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 5083}}, "n3337": {"so_30990841_30991076_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 4880}}, "n4659": {"so_30990841_30991076_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 6504}}}, "30991243": {"Id": "30991243", "PostTypeId": "2", "Body": "<p><code>boost::basic_regex</code> objects have a <code>str()</code> function which returns a (copy of) the character string used to construct the regular expression. (They also provide <code>begin()</code> and <code>end()</code> interfaces which return iterators to the character sequence, as well as a mechanism for introspecting capture subexpressions.)</p>\n<p>These interfaces were in the initial TR1 regex standardization proposal, but were removed in 2003, after the adoption of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1499.html\" rel=\"noreferrer\">n1499: Simplifying Interfaces in basic_regex</a>, from which I quote:</p>\n<blockquote>\n<h3>basic_regex Should Not Keep a Copy of its Initializer</h3>\n<p id=\"so_30990841_30991243_0\">The <code>basic_regex</code> template has a member function <code>str</code> which returns a string object that holds the text used to initialize the <code>basic_regex</code> object\u2026 While it might occasionally be useful to look at the initializer string, we ought to apply the rule that you don't pay for it if you don't use it. Just as <code>fstream</code> objects don't carry around the file name that they were opened with, <code>basic_regex</code> objects should not carry around their initializer text. If someone needs to keep track of that text they can write a class that holds the text and the <code>basic_regex</code> object.</p>\n</blockquote>\n", "LastActivityDate": "2015-06-22T22:59:49.930", "CommentCount": "1", "CreationDate": "2015-06-22T22:59:49.930", "ParentId": "30990841", "Score": "6", "OwnerUserId": "1566221"}, "30990841": {"ViewCount": "1535", "Body": "<p>I have a function which is attempting to match a given string against a given regex pattern. If it does not match, it should create a string indicating such occurrence and include the regex pattern it failed and the content of the string. Something similar to such:</p>\n<pre><code>bool validate_content(const std::string &amp; str, const std::regex &amp; pattern, std::vector&lt;std::string&gt; &amp; errors)\n{\n    if ( false == std::regex_match(str, pattern) )\n    {\n        std::stringstream error_str;\n        // error_str &lt;&lt; \"Pattern match failure: \" &lt;&lt; pattern &lt;&lt; \", content: \" &lt;&lt; str;\n        errors.push_back(error_str.str());\n        return false;\n    }\n    return true;\n}\n</code></pre>\n<p>However as you can see, the commented-out line presents a challenge: is it possible to recover the original pattern of the regex object?</p>\n<p>There is obviously a workaround of providing the original pattern string (instead of or alongside) the regex object and then using that. But I would have of course preferred to not need to include the extra work to either recreate the regex object every time this function is called (biting cost in reparsing the pattern every time the function is called) or to pass the regex pattern along with the regex object (prone to typos and errors unless I provide a wrapper which does that for me, which is not as convenient).</p>\n<p>I'm using GCC 4.9.2 on Ubuntu 14.04.</p>\n", "AcceptedAnswerId": "30991243", "Title": "extracting original regex pattern from std::regex", "CreationDate": "2015-06-22T22:23:11.583", "Id": "30990841", "CommentCount": "1", "LastEditDate": "2015-06-22T22:42:10.680", "PostTypeId": "1", "LastEditorUserId": "1111557", "LastActivityDate": "2015-06-22T23:04:01.733", "Score": "9", "OwnerUserId": "1111557", "Tags": "<c++><regex><string><c++11>", "AnswerCount": "2"}, "30991076": {"Id": "30991076", "PostTypeId": "2", "Body": "<p>According to the standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4431.pdf\" rel=\"nofollow noreferrer\">N4431</a> <em>\u00a728.8/2 Class template basic_regex [re.regex] (<strong>Emphasis mine</strong>):</em> </p>\n<blockquote>\n<p id=\"so_30990841_30991076_0\"><strong>Objects of type specialization of <code>basic_regex</code> are responsible for converting the sequence of <code>charT</code> objects\n  to an internal representation. It is not specified what form this representation takes, nor how it is accessed by\n  algorithms that operate on regular expressions.</strong> [ <em>Note:</em> Implementations will typically declare some function templates as friends of <code>basic_regex</code> to achieve this <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>Thus, the <code>basic_regex</code> object is not required to keep internally the original character sequence.</p>\n<p>Consequently, you must store the sequence of characters upon the creation of the <code>regex</code>. For example:</p>\n<pre><code>struct RegexPattern {\n  std::string pattern;\n  std::regex  reg;\n};\n...\nbool validate_content(const std::string &amp; str, const RegexPattern &amp; pattern, std::vector&lt;std::string&gt; &amp; errors) {\n    if(false == std::regex_match(str, pattern.reg)) {\n        std::stringstream error_str;\n        error_str &lt;&lt; \"Pattern match failure: \" &lt;&lt; pattern.pattern &lt;&lt; \", content: \" &lt;&lt; str;\n        errors.push_back(error_str.str());\n        return false;\n    }\n    return true;\n}\n</code></pre>\n<p>Another more elegant solution proposed by <a href=\"https://stackoverflow.com/users/241631/praetorian\">@Praetorian</a> but somewhat less inefficient (I haven't benchmarked the two versions, thus I'm not sure). Would be to keep the pattern string and pass it as input argument to the function <code>validate_content</code> and create the <code>regex</code> object internally, as shown below:</p>\n<pre><code>bool validate_content(const std::string &amp; str, const string &amp; pattern, std::vector&lt;std::string&gt; &amp; errors) {\n    std::regex reg(pattern);\n    if(false == std::regex_match(str, reg)) {\n        std::stringstream error_str;\n        error_str &lt;&lt; \"Pattern match failure: \" &lt;&lt; pattern &lt;&lt; \", content: \" &lt;&lt; str;\n        errors.push_back(error_str.str());\n        return false;\n    }\n    return true;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-22T23:04:01.733", "Score": "5", "CreationDate": "2015-06-22T22:45:18.083", "ParentId": "30990841", "CommentCount": "8", "OwnerUserId": "2352671", "LastEditDate": "2017-05-23T10:31:19.160"}});