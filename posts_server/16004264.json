post_cb({"bq_ids": {"n4140": {"so_16004264_16004686_1": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_16004264_16004686_2": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_16004264_16004686_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_16004264_16004686_1": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_16004264_16004686_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_16004264_16004686_2": {"length": 10, "quality": 1.0, "section_id": 5946}}}, "16004686": {"PostTypeId": "2", "Body": "<p>Clang is correct. I believe 14.3.2p1 rules out this:</p>\n<blockquote>\n<p id=\"so_16004264_16004686_0\">A template-argument for a non-type, non-template template-parameter\n  shall be one of:</p>\n<p id=\"so_16004264_16004686_1\">\u2014 a constant expression (5.19) that designates the address of an\n  object with static storage duration and external or internal linkage\n  or <strong>a function with external or internal linkage</strong>, including\n  function templates and function template-ids but excluding non-static\n  class members, <strong>expressed (ignoring parentheses) as &amp;\n  id-expression</strong>, except that the &amp; may be omitted if the name refers\n  to a function or array and shall be omitted if the corresponding\n  template-parameter is a reference; or</p>\n</blockquote>\n<p>The important part is <code>expressed (ignoring parentheses) as &amp; id-expression</code>. The expression must have an <code>&amp;</code>, however you cannot take the address of an rvalue. So this pretty much rules out any casts.</p>\n<p>Also, from 5.19p2 <code>reinterpret_cast</code> is illegal in constant expressions:</p>\n<blockquote>\n<p id=\"so_16004264_16004686_2\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression</p>\n<p id=\"so_16004264_16004686_3\">\u2014 a reinterpret_cast (5.2.10);</p>\n</blockquote>\n", "LastActivityDate": "2013-04-14T21:43:24.933", "Id": "16004686", "CommentCount": "3", "CreationDate": "2013-04-14T21:43:24.933", "ParentId": "16004264", "Score": "3", "OwnerUserId": "906773"}, "16004264": {"ViewCount": "156", "Body": "<p>What I'm trying to do is create a template function that stores a generic function pointer and information about how to cast to it's actual type. This is being used by my script binding API to make C++ function calls from Python for a game engine. In the process of porting this to OSX using XCode4 with LLVM, I have run into an error. This sample code compiles and runs fine in Visual Studio 2012, but gives me the error \"No matching function for call to 'Call'\" with LLVM.</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid testfun (int i)\n{\n  std::cout &lt;&lt; \"Hello World \" &lt;&lt; i &lt;&lt; std::endl;\n}\n\ntypedef void BasicFunction ();\n\ntemplate &lt;BasicFunction* fn, typename T0&gt;\nvoid Call (void(*f)(T0), T0 i)\n{\n  reinterpret_cast&lt;decltype(f)&gt;(fn)(i);\n}\n\nint main(int argc, const char * argv[])\n{\n  Call&lt;reinterpret_cast&lt;BasicFunction*&gt;(testfun)&gt;(testfun, 5);\n  return 0;\n}\n</code></pre>\n<p>Is this non standard code? A bug with LLVM? Or is there just a better way to accomplish the same task? Note: The function pointer must come first in the template so that the function information can be deduced automatically.</p>\n", "AcceptedAnswerId": "16004686", "Title": "Simple template code compiles in Visual Studio but not with LLVM", "CreationDate": "2013-04-14T20:59:27.960", "Id": "16004264", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-04-14T21:43:24.933", "Score": "3", "OwnerUserId": "753105", "Tags": "<c++><templates><function-pointers>", "AnswerCount": "1"}});