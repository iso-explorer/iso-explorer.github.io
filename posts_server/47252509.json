post_cb({"47252509": {"ViewCount": "53", "Body": "<p>I try to understand meaning and implications of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">14.5.5/8 of the C++11 standard</a> (idem in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++14</a> and, I suppose, in C++17)</p>\n<blockquote>\n<p id=\"so_47252509_47252509_0\">The type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization.</p>\n</blockquote>\n<p>and, as usual, to understand who's correct between g++ and clang++.</p>\n<p>The standard show the following example</p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\n</code></pre>\n<p>and both g++ and clang++ give error.</p>\n<p>So far, so good.</p>\n<p>Let's complicate a little the example adding a type</p>\n<pre><code>template &lt;typename, typename T, T&gt;\nstruct foo { };\n\ntemplate &lt;typename T&gt;\nstruct foo&lt;T, int, 1&gt; { }; // compile\n\ntemplate &lt;typename T&gt;\nstruct foo&lt;T, T, 1&gt; { }; // error\n</code></pre>\n<p>Both g++ and clang++ compile the first partial specialization (the type of <code>1</code>, <code>int</code>, isn't a parameter of the specialization) and give error with the second one (the type of <code>1</code> is <code>T</code>, a parameter of the specialization)</p>\n<p>So far, so good.</p>\n<p>Let's introduce a template struct <code>bar</code> with an internal type that <strong>doesn't</strong> depend from the template parameter</p>\n<pre><code>template &lt;typename&gt;\nstruct bar \n { using type = int; };\n</code></pre>\n<p>and the following program</p>\n<pre><code>template &lt;typename&gt;\nstruct bar { using type = int; };\n\ntemplate &lt;typename, typename T, T&gt;\nstruct foo { };\n\ntemplate &lt;typename T&gt;\nstruct foo&lt;T, typename bar&lt;T&gt;::type, 1&gt; { };\n\nint main ()\n { }\n</code></pre>\n<p>it's compiled without error by g++ (tried in wandbox with 4.9.3, 5.5.0, 7.2.0 and head 8.0.0; with c++11, c++14 and, when available, c++17) but clang++ (3.9.1, 4.0.1, 5.0.0, head 6.0.0; c++11, c++14, c++17) give the following error</p>\n<pre><code>prog.cc:11:38: error: non-type template argument specializes a template parameter with dependent type 'T'\nstruct foo&lt;T, typename bar&lt;T&gt;::type, 1&gt; { };\n                                     ^\nprog.cc:7:34: note: template parameter is declared here\ntemplate &lt;typename, typename T, T&gt;\n                                ~^\n</code></pre>\n<p>As usual: who's right? </p>\n<p>clang++, that consider <code>1</code> dependent on <code>T</code> (when <code>typename bar&lt;T&gt;::type</code> is fixed as <code>int</code>) or g++ that doesn't relieve this dependencies?</p>\n<p>For completeness I have to say that changing <code>bar</code> as follows</p>\n<pre><code>template &lt;typename T&gt;\nstruct bar { using type = T; };\n</code></pre>\n<p>so making the <code>bar&lt;T&gt;::type</code> dependant on <code>T</code>, nothing change: g++ compile without error, and clang++ give the same error.</p>\n", "Title": "g++ and clang++ different behaviour with non-type argument in struct/class specialization", "CreationDate": "2017-11-12T18:42:37.650", "LastActivityDate": "2017-11-12T19:07:02.917", "CommentCount": "0", "PostTypeId": "1", "Id": "47252509", "Score": "2", "OwnerUserId": "6022656", "Tags": "<c++><c++11><gcc><clang><template-specialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47252509_47252509_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 142}}, "n3337": {"so_47252509_47252509_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 136}}, "n4659": {"so_47252509_47252509_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 146}}}, "47252653": {"Id": "47252653", "PostTypeId": "2", "Body": "<p>Look at it from the compiler's point of view. </p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\n</code></pre>\n<p>For the specialization, the compiler doesn't know if <code>T</code> can indeed have a value of <code>1</code>, and so the specialization is invalid.</p>\n<p>For</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo&lt;T, typename bar&lt;T&gt;::type, 1&gt; { };\n</code></pre>\n<p>Who's saying that <code>type</code> is always <code>int</code>? You might think that it is obvious, but I could introduce a specialization of <code>bar</code> for one specific <code>T</code> so that <code>type</code> is a <code>std::string</code>:</p>\n<pre><code>template&lt;&gt;\nstruct bar&lt;const volatile int&gt; { using type = std::string };\n</code></pre>\n<p>Basically, your statement \"<em>when <code>typename bar&lt;T&gt;::type</code> is fixed as <code>int</code>\"</em> is wrong, it is not fixed.</p>\n<p>Now what? The standard here says the same thing as for your first example, the specialization is ill-formed, because as your quote correctly states, the type of the non-type parameter depends on another (templated) type of the specialization, namely <code>T</code>, which is unknown. In that regard, clang is right, and gcc is wrong. </p>\n", "LastEditorUserId": "3980929", "LastActivityDate": "2017-11-12T19:07:02.917", "Score": "2", "CreationDate": "2017-11-12T18:57:25.777", "ParentId": "47252509", "CommentCount": "0", "OwnerUserId": "3980929", "LastEditDate": "2017-11-12T19:07:02.917"}});