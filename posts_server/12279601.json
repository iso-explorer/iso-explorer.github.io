post_cb({"bq_ids": {"n4140": {"so_12279601_12279842_3": {"length": 6, "quality": 0.6, "section_id": 0}}, "n3337": {"so_12279601_12279842_0": {"length": 8, "quality": 1.0, "section_id": 5732}, "so_12279601_12279842_3": {"length": 10, "quality": 1.0, "section_id": 5732}}, "n4659": {"so_12279601_12279842_3": {"length": 7, "quality": 0.7, "section_id": 7667}}}, "12279652": {"Id": "12279652", "PostTypeId": "2", "Body": "<p>You can call a function to return the result and initialize in the same statement:</p>\n<pre><code>template&lt;typename T&gt;\nconst T in_get (istream &amp;in = std::cin) {\n    T x;\n    if (!(in &gt;&gt; x)) throw \"Invalid input\";\n    return x;\n}\n\nconst int X = in_get&lt;int&gt;();\nconst string str = in_get&lt;string&gt;();\n\nfstream fin(\"myinput.in\",fstream::in);\nconst int Y = in_get&lt;int&gt;(fin);\n</code></pre>\n<p>Example: <a href=\"http://ideone.com/kFBpT\" rel=\"nofollow\">http://ideone.com/kFBpT</a></p>\n<p>If you have C++11, then you can specify the type only once if you use the <code>auto&amp;&amp;</code> keyword.</p>\n<pre><code>auto&amp;&amp; X = in_get&lt;int&gt;();\n</code></pre>\n", "LastEditorUserId": "1578925", "LastActivityDate": "2012-09-05T11:33:16.813", "Score": "5", "CreationDate": "2012-09-05T10:43:16.480", "ParentId": "12279601", "CommentCount": "7", "LastEditDate": "2012-09-05T11:33:16.813", "OwnerUserId": "1578925"}, "12279650": {"Id": "12279650", "PostTypeId": "2", "Body": "<p>I'm assuming that you will want to initialize a <em>global</em> variable, since for a local variable it just seems like a very awkward choice to forgo three lines of plain and understandable statements in order to have a constant of questionable value.</p>\n<p>At the global scope, we can't have errors in the initialization, so we'll have to handle them somehow. Here are some ideas.</p>\n<p>First, a templated little construction helper:</p>\n<pre><code>template &lt;typename T&gt;\nT cinitialize(std::istream &amp; is) noexcept\n{\n    T x;\n    return (is &amp;&amp; is &gt;&gt; x) ? x : T();\n}\n\nint const X = cinitialize&lt;int&gt;(std::cin);\n</code></pre>\n<p>Note that global initializers must not throw exceptions (under pain of <code>std::terminate</code>), and that the input operation may fail. All told, it's probably pretty bad design to initialize global variables from user input in such a fashion. Perhaps a fatal error would be indicated:</p>\n<pre><code>template &lt;typename T&gt;\nT cinitialize(std::istream &amp; is) noexcept\n{\n    T x;\n\n    if (!(is &amp;&amp; is &gt;&gt; x))\n    {\n        std::cerr &lt;&lt; \"Fatal error while initializing constants from user input.\\n\";\n        std::exit(1);\n    }\n\n    return x;\n}\n</code></pre>\n<p>Just to clarify my position after some discussion in the comments: In a local scope I would <em>never</em> resort to such an awkward crutch. Since we're processing <em>external, user-supplied</em> data, we basically have to live with failure as part of the normal control flow:</p>\n<pre><code>void foo()\n{\n    int x;\n\n    if (!(std::cin &gt;&gt; x)) { /* deal with it */ }\n}\n</code></pre>\n<p>I leave it up to you to decide whether that's too much to write or too hard too read.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-09-06T08:29:32.957", "Score": "3", "CreationDate": "2012-09-05T10:43:08.590", "ParentId": "12279601", "CommentCount": "14", "LastEditDate": "2012-09-06T08:29:32.957", "OwnerUserId": "596781"}, "12280095": {"Id": "12280095", "PostTypeId": "2", "Body": "<p>I'd probably opt for returning an <code>optional</code>, since the streaming could fail. To test if it did (in case you want to assign another value), use <code>get_value_or(default)</code>, as shown in the example.</p>\n<pre><code>template&lt;class T, class Stream&gt;\nboost::optional&lt;T&gt; stream_get(Stream&amp; s){\n  T x;\n  if(s &gt;&gt; x)\n    return std::move(x); // automatic move doesn't happen since\n                         // return type is different from T\n  return boost::none;\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/0feaa0fac77c5ec1a3f3057f44b6769d\">Live example.</a></p>\n<p>To further ensure that the user gets no wall-of-overloads presented when <code>T</code> is not input-streamable, you can write a trait class that checks if <code>stream &gt;&gt; T_lvalue</code> is valid and <code>static_assert</code> if it's not:</p>\n<pre><code>namespace detail{\ntemplate&lt;class T, class Stream&gt;\nstruct is_input_streamable_test{\n  template&lt;class U&gt;\n  static auto f(U* u, Stream* s = 0) -&gt; decltype((*s &gt;&gt; *u), int());\n  template&lt;class&gt;\n  static void f(...);\n\n  static constexpr bool value = !std::is_void&lt;decltype(f&lt;T&gt;(0))&gt;::value;\n};\n\ntemplate&lt;class T, class Stream&gt;\nstruct is_input_streamable\n  : std::integral_constant&lt;bool, is_input_streamable_test&lt;T, Stream&gt;::value&gt;\n{\n};\n\ntemplate&lt;class T, class Stream&gt;\nbool do_stream(T&amp; v, Stream&amp; s){ return s &gt;&gt; v; }\n} // detail::\n\ntemplate&lt;class T, class Stream&gt;\nboost::optional&lt;T&gt; stream_get(Stream&amp; s){\n  using iis = detail::is_input_streamable&lt;T, Stream&gt;;\n  static_assert(iis::value, \"T must support 'stream &gt;&gt; value_of_T'\");\n  T x;\n  if(detail::do_stream(x, s))\n    return std::move(x); // automatic move doesn't happen since\n                         // return type is different from T\n  return boost::none;\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/f1f8bcca190d3736e5d2d68e76d6e7f6\">Live example.</a></p>\n<p>I'm using a <code>detail::do_stream</code> function, since otherwise <code>s &gt;&gt; x</code> would still be parsed inside <code>get_stream</code> and you'd still get the wall-of-overloads that we wanted to avoid when the <code>static_assert</code> fires. Delegating this operation to a different function makes this work.</p>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-09-05T20:05:34.403", "Score": "22", "CreationDate": "2012-09-05T11:07:42.957", "ParentId": "12279601", "CommentCount": "8", "LastEditDate": "2012-09-05T20:05:34.403", "OwnerUserId": "500104"}, "12279601": {"ViewCount": "8201", "Body": "<p><strong>Common std::cin usage</strong></p>\n<pre><code>int X;\ncin &gt;&gt; X;\n</code></pre>\n<p>The main disadvantage of this is that X cannot be <code>const</code>. It can easily introduce bugs; and I am looking for some trick to be able to create a const value, and write to it just once.</p>\n<p><strong>The naive solution</strong></p>\n<pre><code>// Naive\nint X_temp;\ncin &gt;&gt; X_temp;\nconst int X = X_temp;\n</code></pre>\n<p>You could obviously improve it by changing X to <code>const&amp;</code>; still, the original variable can be modified.</p>\n<p>I'm looking for a short and clever solution of how to do this. I am sure I am not the only one who will benefit from a good answer to this question.</p>\n<p><strong>// EDIT:</strong> I'd like the solution to be easily extensible to the other types (let's say, all PODs, <code>std::string</code> and movable-copyable classes with trivial constructor) (if it doesn't make sense, please let me know in comments).</p>\n", "AcceptedAnswerId": "12280095", "Title": "Are there any tricks to use std::cin to initialize a const variable?", "CreationDate": "2012-09-05T10:40:36.673", "Id": "12279601", "CommentCount": "11", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2012-09-05T15:22:45.963", "LastEditorUserId": "385478", "LastActivityDate": "2012-09-06T08:29:32.957", "Score": "44", "OwnerUserId": "752976", "Tags": "<c++><c++11><iostream>", "AnswerCount": "5"}, "12280983": {"Id": "12280983", "PostTypeId": "2", "Body": "<p>A slight tweak to lx.'s lambda solution:</p>\n<pre><code>const int x = [](int t){ return iss &gt;&gt; t, t; }({});\n</code></pre>\n<p>Significantly less DRY violation; can be eliminated entirely by changing <code>const int x</code> to <code>const auto x</code>:</p>\n<pre><code>const auto x = [](int t){ return iss &gt;&gt; t, t; }({});\n</code></pre>\n<p>One further improvement; you can convert the copy into a move, since otherwise the comma operator suppresses the optimisation in 12.8:31 (<a href=\"https://stackoverflow.com/questions/12288131/move-constructor-suppressed-by-comma-operator\">Move constructor suppressed by comma operator</a>):</p>\n<pre><code>const auto x = [](int t){ return iss &gt;&gt; t, std::move(t); }({});\n</code></pre>\n<p>Note that this is still potentially less efficient than lx.'s lambda, as that can benefit from NRVO whereas this still has to use a move constructor.  On the other hand an optimising compiler should be able to optimise out a non-side-effect-bearing move.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-05T19:27:47.227", "Score": "13", "CreationDate": "2012-09-05T12:01:39.550", "ParentId": "12279601", "CommentCount": "1", "LastEditDate": "2017-05-23T12:25:51.473", "OwnerUserId": "567292"}, "12279842": {"Id": "12279842", "PostTypeId": "2", "Body": "<p>You could make use of lambdas for such cases:</p>\n<pre><code>   const int x = []() -&gt; int {\n                     int t;\n                     std::cin &gt;&gt; t;\n                     return t;\n                 }();\n</code></pre>\n<p>(Note the extra () at the end).</p>\n<p>Instead of writing a separate functions, this has the advantage of not having to jump around in your source file, when reading the code.</p>\n<p><s><strong>Edit:</strong> Since in the comments it was stated that this goes against the DRY rule, you could take advantage of <code>auto</code> and <code>5.1.2:4</code> to reduce type repetition:</s></p>\n<p><code>5.1.2:4</code> states:</p>\n<blockquote>\n<p id=\"so_12279601_12279842_0\">[...] If a lambda-expression does not include a trailing-return-type, it is as\n  if the trailing-return-type denotes the following type:</p>\n<ul>\n<li><p id=\"so_12279601_12279842_1\">if the compound-statement is of the form</p>\n<p id=\"so_12279601_12279842_2\"><code>{ attribute-specifier-seq(opt) return expression ; }</code></p>\n<p id=\"so_12279601_12279842_3\">the type of the returned expression after lvalue-to-rvalue conversion (4.1),\n  array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3);</p></li>\n<li><p id=\"so_12279601_12279842_4\">otherwise, void.</p></li>\n</ul>\n</blockquote>\n<p>So we could alter the code to look like this:</p>\n<pre><code>   const auto x = [] {\n                     int t;\n                     std::cin &gt;&gt; t;\n                     return t;\n                  }();\n</code></pre>\n<p>I can't decide if that is better though, since the type is now \"hidden\" within the lambda body...</p>\n<p><strong>Edit 2:</strong> In the comments it was pointed out, that just removing the type name where it is possible, does not result in a \"DRY-correct\" code.\nAlso the trailing-return-type deduction in this case is currently actually an extension of MSVC++ as well as g++ and not (yet) standard.</p>\n", "LastEditorUserId": "102693", "LastActivityDate": "2012-09-06T07:10:14.897", "Score": "19", "CreationDate": "2012-09-05T10:52:39.307", "ParentId": "12279601", "CommentCount": "12", "LastEditDate": "2012-09-06T07:10:14.897", "OwnerUserId": "102693"}});