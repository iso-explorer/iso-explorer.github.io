post_cb({"16549548": {"CommentCount": "0", "ViewCount": "121", "CreationDate": "2013-05-14T17:43:48.677", "LastActivityDate": "2013-05-14T18:20:40.370", "Title": "arbitrarily sized enum values", "AcceptedAnswerId": "16549565", "PostTypeId": "1", "Id": "16549548", "Score": "2", "Body": "<p>I'm compiling code that was written for GCC, in Visual C++ 2012. I'm getting warnings thrown about enum value truncation with the following enum (due to the value being outside the range of an int):</p>\n<pre><code>enum tile_flags {\n   TILE_FLAG_INNER_FLAME= 0x10000000ULL,\n    TILE_FLAG_CONSTRICTED= 0x20000000ULL,\n\n    TILE_FLAG_MIMIC_INEPT 0x2000000000ULL\n    TILE_FLAG_MIMIC 0x4000000000ULL\n    TILE_FLAG_MIMIC_RAVEN 0x6000000000ULL\n    TILE_FLAG_MIMIC_MASK 0x6000000000ULL\n}\n</code></pre>\n<p>When compiling for x86, it would appear MSVC simply truncates the enum values to fit in 32bits. However, no truncation occurs in GCC. What is happening on GCC? And how can I make this work for MSVC?</p>\n", "Tags": "<c++><visual-c++><gcc>", "OwnerUserId": "1362135", "AnswerCount": "2"}, "16549565": {"ParentId": "16549548", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2013-05-14T17:44:46.167", "Score": "10", "LastEditorUserId": "962089", "LastEditDate": "2013-05-14T18:20:40.370", "Id": "16549565", "OwnerUserId": "962089", "Body": "<p>From N3485, \u00a7 7.2/6:</p>\n<blockquote>\n<p id=\"so_16549548_16549565_0\">For an enumeration whose underlying type is not \ufb01xed, the underlying type is an integral type that can\n  represent all the enumerator values de\ufb01ned in the enumeration. If no integral type can represent all the\n  enumerator values, the enumeration is ill-formed. It is implementation-de\ufb01ned which integral type is used\n  as the underlying type except that the underlying type shall not be larger than int unless the value of an\n  enumerator cannot \ufb01t in an int or unsigned int. If the enumerator-list is empty, the underlying type is\n  as if the enumeration had a single enumerator with value 0.</p>\n</blockquote>\n<p>Therefore, if MSVC has the necessary <code>long long</code> support, it <em>should</em> make that the underlying type anyway. Seeing as how it doesn't, there's one thing you can try in order to coax it.</p>\n<p>Specify the underlying type:</p>\n<pre><code>enum tile_flags : unsigned long long {\n    ...\n};\n</code></pre>\n", "LastActivityDate": "2013-05-14T18:20:40.370"}, "bq_ids": {"n4140": {"so_16549548_16549565_0": {"section_id": 5466, "quality": 0.9230769230769231, "length": 48}}, "n3337": {"so_16549548_16549565_0": {"section_id": 5252, "quality": 0.9230769230769231, "length": 48}}, "n4659": {"so_16549548_16549565_0": {"section_id": 6900, "quality": 0.9230769230769231, "length": 48}}}, "16549954": {"ParentId": "16549548", "CommentCount": "0", "CreationDate": "2013-05-14T18:09:38.810", "OwnerUserId": "427309", "PostTypeId": "2", "Id": "16549954", "Score": "0", "Body": "<p>If you need more entries than an <code>unsigned long long</code> can get you, try using a struct:</p>\n<pre><code>struct tile_flags {\n   bool innerFlame : 1;\n   bool constricted : 1;\n   bool mimicInept : 1;\n   bool mimic : 1;\n   // etc\n};\n</code></pre>\n<p>This uses a bitfield, which usually means that the values will be packed as tightly as possible, and while it can make construction a bit more difficult than traditional flag numbers, its your easiest option for more than <code>sizeof unsigned long long</code> bits.</p>\n", "LastActivityDate": "2013-05-14T18:09:38.810"}});