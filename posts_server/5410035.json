post_cb({"5410171": {"Id": "5410171", "PostTypeId": "2", "Body": "<p>I found these notes helpful:</p>\n<p><a href=\"http://www.sgi.com/tech/stl/Vector.html#2\" rel=\"nofollow\">http://www.sgi.com/tech/stl/Vector.html#2</a></p>\n<p><a href=\"http://www.sgi.com/tech/stl/FAQ.html\" rel=\"nofollow\">http://www.sgi.com/tech/stl/FAQ.html</a>\n(Why does a vector expand its storage by a factor of two when it performs a reallocation?)</p>\n<p>However, this is the SGI STL, couldn't find g++ documentation.</p>\n", "LastActivityDate": "2011-03-23T18:55:13.380", "CommentCount": "0", "CreationDate": "2011-03-23T18:55:13.380", "ParentId": "5410035", "Score": "0", "OwnerUserId": "648565"}, "5410129": {"Id": "5410129", "PostTypeId": "2", "Body": "<p>From C++ standard 23.2.4.2:</p>\n<pre><code>size_type capacity() const;\n</code></pre>\n<blockquote>\n<p id=\"so_5410035_5410129_0\">Returns: The total number of elements that the vector can hold without requiring reallocation.</p>\n</blockquote>\n<p>Also from Standard</p>\n<blockquote>\n<p id=\"so_5410035_5410129_1\">Notes: Reallocation invalidates all the references, pointers, and iterators referring to the elements in the\n  sequence. It is <strong>guaranteed that no reallocation takes place</strong> during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the vector greater than the size\n  specified in the most recent call to reserve().</p>\n</blockquote>\n<p>So yes, you can be sure.</p>\n<p><em>Edit:</em> As @Bo Persson mentioned there is a catch. Standard doesn't say anything if we never call <code>reserve()</code> . However in practice it works well, because no implementation will care to remember if you called reserve, or not. I believe that this is bug. And as @Martin mentioned in his answer in C++0x draft it is corrected.</p>\n", "LastEditorUserId": "556049", "LastActivityDate": "2011-03-23T19:34:56.587", "Score": "13", "CreationDate": "2011-03-23T18:51:53.190", "ParentId": "5410035", "CommentCount": "4", "OwnerUserId": "556049", "LastEditDate": "2011-03-23T19:34:56.587"}, "5410133": {"Id": "5410133", "PostTypeId": "2", "Body": "<p>The standard guarantees which calls do not invalidate iterators.  Technically, a <code>std::vector</code> could comply with the standard by only doing resizes that don't require copying the data to a new location, i.e., that don't invalidate iterators.  I doubt anybody does, though.</p>\n<p>So, resizes happen on calls to <code>reserve()</code> or <code>resize()</code> or any other call that is documented as invalidating iterators.</p>\n", "LastActivityDate": "2011-03-23T18:52:04.723", "CommentCount": "0", "CreationDate": "2011-03-23T18:52:04.723", "ParentId": "5410035", "Score": "0", "OwnerUserId": "10593"}, "5410127": {"Id": "5410127", "PostTypeId": "2", "Body": "<p>std::vector would reallocate itself with the increased capacity on demand -- i.e. when current capacity is exceeded (when <code>size() == capacity()</code>).</p>\n<p>How much capacity would be added, depend on the implementation: usually <code>new_capacity = old_capacity * factor</code>, where <code>factor</code> is somewhere from 1.5 to 2 (with theoretical ideal equals to <a href=\"http://en.wikipedia.org/wiki/Golden_section\" rel=\"nofollow\">Golden section</a>). This is done so that pushing back new elements to the vector would have amortized constant time.</p>\n", "LastActivityDate": "2011-03-23T18:51:40.290", "CommentCount": "0", "CreationDate": "2011-03-23T18:51:40.290", "ParentId": "5410035", "Score": "2", "OwnerUserId": "104451"}, "bq_ids": {"n4140": {"so_5410035_5410129_0": {"length": 8, "quality": 0.8, "section_id": 967}, "so_5410035_5410129_1": {"length": 27, "quality": 0.75, "section_id": 972}, "so_5410035_5410229_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 969}, "so_5410035_5410229_2": {"length": 41, "quality": 0.8723404255319149, "section_id": 986}}, "n3337": {"so_5410035_5410129_0": {"length": 8, "quality": 0.8, "section_id": 957}, "so_5410035_5410129_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 961}, "so_5410035_5410229_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 958}, "so_5410035_5410229_2": {"length": 41, "quality": 0.8723404255319149, "section_id": 971}}, "n4659": {"so_5410035_5410129_0": {"length": 8, "quality": 0.8, "section_id": 1029}, "so_5410035_5410129_1": {"length": 27, "quality": 0.75, "section_id": 1034}, "so_5410035_5410229_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 1031}, "so_5410035_5410229_2": {"length": 41, "quality": 0.8723404255319149, "section_id": 1049}}}, "5410106": {"Id": "5410106", "PostTypeId": "2", "Body": "<p>From <a href=\"http://www.cplusplus.com/reference/stl/vector/\" rel=\"nofollow\">cplusplus.com</a>:</p>\n<blockquote>\n<p id=\"so_5410035_5410106_0\">But vectors, also have a capacity, which determines the amount of storage space they have allocated, and which can be either equal or greater than the actual size. The extra amount of storage allocated is not used, but is reserved for the vector to be used in the case it grows. This way, the vector does not have to reallocate storage on each occasion it grows, but only when this extra space is exhausted and a new element is inserted (which should only happen in logarithmic frequence in relation with its size).</p>\n</blockquote>\n", "LastActivityDate": "2011-03-23T18:49:30.530", "CommentCount": "0", "CreationDate": "2011-03-23T18:49:30.530", "ParentId": "5410035", "Score": "2", "OwnerUserId": "500104"}, "5410035": {"ViewCount": "11208", "Body": "<p>I can't find anything that gives a definitive answer. I was just curious if a std::vector reallocate its internal array only when it absolutely must or will it reallocate ahead of time in anticipation (so to speak).</p>\n<p>For example:</p>\n<pre><code>std::vector&lt;int&gt; myVector;\nfor (int i = 0; i &lt; 1000; ++i) myVector.push_back(i);\n\ncout &lt;&lt; myVector.size() &lt;&lt; '\\n'      // Gives 1000 as expected\n     &lt;&lt; myVector.capacity() &lt;&lt; endl; // Gives 1024 which makes sense\n</code></pre>\n<p>If I continue to add elements, is there ever any chance that one of the next 24 items I add will change the capacity or will it only reallocate once I put in a 25th item?</p>\n<p>Note:</p>\n<p>I did run a test using gcc 4.4.3 under Linux, but and it seems like the reallocation is done \"on-demand\", but I was curious if I was just lucky or if there is something somewhere stating that this is expected behavior.</p>\n", "AcceptedAnswerId": "5410129", "Title": "When does a std::vector reallocate its memory array?", "CreationDate": "2011-03-23T18:42:52.867", "Id": "5410035", "CommentCount": "2", "LastEditDate": "2011-03-23T18:50:35.047", "PostTypeId": "1", "LastEditorUserId": "467172", "LastActivityDate": "2011-03-23T19:34:56.587", "Score": "9", "OwnerUserId": "467172", "Tags": "<c++><stl><vector>", "AnswerCount": "8"}, "5410076": {"Id": "5410076", "PostTypeId": "2", "Body": "<p>If you look at the documentation for push_back on <a href=\"http://www.cplusplus.com/reference/stl/vector/push_back/\" rel=\"noreferrer\">cplusplus.com</a> it states:</p>\n<blockquote>\n<p id=\"so_5410035_5410076_0\">This effectively increases the vector\n  size by one, which causes a\n  reallocation of the internal allocated\n  storage if the vector size was equal\n  to the vector capacity before the\n  call. Reallocations invalidate all\n  previously obtained iterators,\n  references and pointers.</p>\n</blockquote>\n<p>So I very much doubt the size would change before that but you could always test it.  At least on my platform the size changes as stated above:</p>\n<pre><code>size vs capacity\n1020 vs 1024\n1021 vs 1024\n1022 vs 1024\n1023 vs 1024\n1024 vs 1024\n1025 vs 2048\n</code></pre>\n", "LastActivityDate": "2011-03-23T18:46:58.900", "CommentCount": "5", "CreationDate": "2011-03-23T18:46:58.900", "ParentId": "5410035", "Score": "5", "OwnerUserId": "398060"}, "5410146": {"Id": "5410146", "PostTypeId": "2", "Body": "<p><a href=\"http://www.sgi.com/tech/stl/Vector.html\" rel=\"nofollow\">http://www.sgi.com/tech/stl/Vector.html</a> states</p>\n<blockquote>\n<p id=\"so_5410035_5410146_0\">Memory will be reallocated\n  automatically if more than capacity()\n  - size() elements are inserted into the vector. Reallocation does not\n  change size(), nor does it change the\n  values of any elements of the vector.\n  It does, however, increase capacity(),\n  and it invalidates [5] any iterators\n  that point into the vector.</p>\n</blockquote>\n", "LastActivityDate": "2011-03-23T18:53:15.347", "CommentCount": "0", "CreationDate": "2011-03-23T18:53:15.347", "ParentId": "5410035", "Score": "0", "OwnerUserId": "322806"}, "5410229": {"Id": "5410229", "PostTypeId": "2", "Body": "<p>From the standard: n3092: Draft C++0x</p>\n<blockquote>\n<p id=\"so_5410035_5410229_0\">23.3.6.2 vector capacity [vector capacity]</p>\n<p id=\"so_5410035_5410229_1\">void reserve(size_type n);<br>\n  2 Effects: A directive that informs a vector of a planned change in size, so that it can manage the storage allocation accordingly. After reserve(), capacity() is greater or equal to the argument of reserve if reallocation happens; and equal to the previous value of capacity() otherwise. <strong><em>Reallocation happens at this point if and only if the current capacity is less than the argument of reserve()</em></strong>. If an exception is thrown other than by the move constructor of a non-CopyConstructible type, there are no effects.</br></p>\n<p id=\"so_5410035_5410229_2\">23.3.6.4 vector modifiers [vector.modifiers]<br>\n  Remarks: <strong><em>Causes reallocation if the new size is greater than the old capacity</em></strong>. If no reallocation happens, all the iterators and references before the insertion point remain valid. If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are no effects. If an exception is thrown by the move constructor of a non-CopyConstructible T, the effects are unspecified.</br></p>\n</blockquote>\n", "LastEditorUserId": "14065", "LastActivityDate": "2011-03-23T19:16:45.170", "Score": "8", "CreationDate": "2011-03-23T19:00:33.737", "ParentId": "5410035", "CommentCount": "4", "OwnerUserId": "14065", "LastEditDate": "2011-03-23T19:16:45.170"}});