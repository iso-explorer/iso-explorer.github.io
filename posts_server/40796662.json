post_cb({"40968240": {"Id": "40968240", "PostTypeId": "2", "Body": "<p>This is an abuse of mutable. You've clearly broken the contract of const here. The object is no longer visibly consistent to the client. </p>\n<p>The real answer is that data(...) simply isn't const. I'm assuming data(...) must be const because whatever you're overriding can't be changed.</p>\n<p>Either you rearrange a whole bunch of code to move the cache out of this class, somehow update the cache within a separate method, or just bend the rule with mutable.</p>\n<p>Don't change a correct, working implementation just to be a purist. Throw a comment in front of data(...) and be done with it. </p>\n<p>If this were a large project with many users (API users) I'd say get whoever is responsible for the const-ness to remove it, or add another method such as dataVersion2 that modifies the cache and is not const.</p>\n", "LastActivityDate": "2016-12-05T06:21:07.660", "CommentCount": "3", "CreationDate": "2016-12-05T06:21:07.660", "ParentId": "40796662", "Score": "0", "OwnerUserId": "116846"}, "40967442": {"Id": "40967442", "PostTypeId": "2", "Body": "<p>From section [class.this] in the C++ language standard,</p>\n<blockquote>\n<p id=\"so_40796662_40967442_0\">If the member function is declared const, the type of this is const X*</p>\n</blockquote>\n<p>So the <code>const</code> changes the type of <code>this</code>; there is nothing (that I've found) about \"logical constness\" of a class.  Since this is a const pointer to <code>MyDataModel</code>, what can you do with it?  [decl.type.cv] tells us</p>\n<blockquote>\n<p id=\"so_40796662_40967442_1\">Except that any class member declared mutable can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>Making changes to <code>mCache</code> within <code>data()</code> is allowed since it is declared <code>mutable</code>.</p>\n<p>There a not a requirement that a const member function must return the same value when called with the same parameters, as the internal state could get changed by updating mutable members or intervening calls to non-const member functions.</p>\n<p>In summary, as long as your calling code can handle the three different returned values (<code>QVariant::Invalid</code>, an empty <code>RowData</code> object if the data is currently being loaded, and a loaded row) you shouldn't have any issues with the member function declaration.</p>\n<p>Where you <em>can</em> have an issue is in your callback, when you move the newly loaded data into your cache.  If another thread tries to load the data for that row at the same time, it can get a <code>RowData</code> object that a mix of an empty row and a loaded one.</p>\n<p>In <code>SignalRowDataUpdated</code>, why are you doing the indirection thru a lambda, instead of doing a <code>const_cast</code> on <code>this</code>?</p>\n", "LastActivityDate": "2016-12-05T05:07:03.480", "CommentCount": "1", "CreationDate": "2016-12-05T05:07:03.480", "ParentId": "40796662", "Score": "2", "OwnerUserId": "5231607"}, "40994660": {"Id": "40994660", "PostTypeId": "2", "Body": "<p>First of all, const member function today <em>is not about logical constness</em>. <em>It is about thread safety</em> (see <a href=\"https://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/\" rel=\"nofollow noreferrer\">https://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/</a>). </p>\n<p>The main thing is that if you make member function <em>const</em>, you should guarantee that if it's invoked from several threads, there won't be race conditions.</p>\n<p>If you don't like <strong>mutable</strong> cache inside your class-definition, use indirection, making a smart pointer to your cache inside your class definition instead. You won't need <em>mutable</em> and compiler won't be upset about your function being <em>const</em> :)</p>\n", "LastActivityDate": "2016-12-06T11:48:37.283", "CommentCount": "1", "CreationDate": "2016-12-06T11:48:37.283", "ParentId": "40796662", "Score": "3", "OwnerUserId": "2091997"}, "41052321": {"Id": "41052321", "PostTypeId": "2", "Body": "<p>Looks like the real issue is that your data(...) method might not be thread safe, unless you're sure that data(...) would only be called from one thread(the UI thread maybe? I'm not familiar with Qt).</p>\n<p>Suppose that there're 2 threads calling data(...) concurrently:</p>\n<p>1) It's possible that both thread will execute the code inside if( !row_data ), you will need add a lock to synchonize this and double check mCache.Get( row ) to see if it's null inside if( !row_data ) </p>\n<p>2) After that, it's also possible that the SignalRowDataUpdated call caused by the first call of data(...) would be executed before the second call of data(...) returned with QVariant::Invalid. I guess this wouldn't be what you wanted. In this case, you'll also need to synchonize data(...) and SignalRowDataUpdated. </p>\n", "LastActivityDate": "2016-12-09T02:47:18.423", "CommentCount": "1", "CreationDate": "2016-12-09T02:47:18.423", "ParentId": "40796662", "Score": "0", "OwnerUserId": "573789"}, "bq_ids": {"n4140": {"so_40796662_40967442_0": {"length": 6, "quality": 1.0, "section_id": 5892}, "so_40796662_40967442_1": {"length": 17, "quality": 1.0, "section_id": 5433}}, "n3337": {"so_40796662_40967442_0": {"length": 6, "quality": 1.0, "section_id": 5663}, "so_40796662_40967442_1": {"length": 17, "quality": 1.0, "section_id": 5228}}, "n4659": {"so_40796662_40967442_0": {"length": 6, "quality": 1.0, "section_id": 7375}, "so_40796662_40967442_1": {"length": 17, "quality": 1.0, "section_id": 6861}}}, "41049923": {"Id": "41049923", "PostTypeId": "2", "Body": "<p>The contract of <code>MyDataModel::data()</code> could be defined so that the function <em>may</em> return the value or not, and that it doesn't block. And if it returns <code>QVariant::Invalid</code>, it must call the callback in the future.</p>\n<p>The fact that the class launches an asynchronous request the first time <code>data()</code> is queried is then part of the class's internals, and <code>data()</code> doesn't modify the object in a way visible from outside: <code>data()</code> still may or may not return the value immediatly for the next call.</p>\n<p>A problem would be if user of <code>MyDataModel</code> relies on the fact that <code>data()</code> will <em>return</em> the value immediatley after it has cached it, and delivered it using the callback the previous time. For it to be logically const, which of these behaviors occurs would need to remain undefined, i.e. the caller must always expect both. </p>\n<hr>\n<p>The interface may be more clean if the function <code>data()</code> would always deliver the value using a callback, and never return a value. If the data is in <code>mCache</code> it would just call the callback immediatly. The contract would then be that <code>data()</code> (maybe rename to <code>async_retrieve()</code> or similar) causes the callback to be called in the future, with the requested value. It can still be <code>const</code>, as the object would not become different from the outside.</p>\n<p>And maybe another function <code>sync_retrieve()</code> in which the caller always receives the value synchronously by return value, but it is allowed block if the value is not cached yet.</p>\n<p>With this the caller decides how it needs to receive the value, while <code>MyDataModel</code> can do caching internally to be more efficient.</p>\n</hr>", "LastActivityDate": "2016-12-08T22:25:28.730", "CommentCount": "0", "CreationDate": "2016-12-08T22:25:28.730", "ParentId": "40796662", "Score": "0", "OwnerUserId": "4108376"}, "40796662": {"ViewCount": "216", "Body": "<p>I'm concerned that I'm breaking the contract of <code>mutable</code> which I use for caching information in a data model that performs on-demand requests asynchronously.  The data model happens to be Qt, although that's not a particularly important fact.</p>\n<pre><code>class MyDataModel : public QAbstractItemModel\n{\npublic:\n    QVariant data( const QModelIndex &amp; index, int role ) const override;\n\nprivate:\n    void SignalRowDataUpdated( int row ) const;\n    mutable SimpleRowCache mCache;\n};\n</code></pre>\n<p>When <code>data()</code> is called, I check the cache to see if we have it.  If not, I return empty data immediately (to avoid blocking the UI) and also send an asynchronous request to the API to populate the cache.  Since <code>data()</code> must be const, this requires that <code>mCache</code> is mutable.  The guts of <code>data()</code> looks like this:</p>\n<pre><code>RowData row_data = mCache.Get( row );\nif( !row_data )\n{\n    // Store empty data in cache, to avoid repeated API requests\n    mCache.Set( row, RowData() );\n\n    // Invoke API with a lambda to deliver async result.  Note: 'this' is const\n    auto data_callback = [this, row]( RowData data )\n    {\n        mCache.Set( row, std::move(data) );\n        SignalRowDataUpdated( row );\n    };\n    DataApi::GetRowData( row, data_callback );\n\n    return QVariant::Invalid;\n}\nreturn row_data[ column ];\n</code></pre>\n<p>My concern is that the data model object's <em>logical constness</em> is being violated here: Calling <code>data()</code> for some index can directly result in a future call with the same parameters returning a different value.</p>\n<p>Is this A Bad Idea?  And is there a common pattern / paradigm for doing it \"correctly\"?</p>\n<hr>\n<p><em>Footnote:</em> I have a similar issue with <code>SignalRowDataUpdated()</code>.  This is actually a wrapper around emitting a Qt signal: <code>emit dataChanged( from, to )</code>, which is a non-const call.  I've handled that one by capturing <code>this</code> in a lambda at construction time allowing me to call the non-const method from a const function.  I don't feel proud of this =(</p>\n</hr>", "AcceptedAnswerId": "40967442", "Title": "Using 'mutable' for asynchronously-populated cache in a const method", "CreationDate": "2016-11-25T01:56:16.180", "Id": "40796662", "CommentCount": "0", "LastEditDate": "2016-11-28T03:00:52.800", "PostTypeId": "1", "LastEditorUserId": "1553090", "LastActivityDate": "2016-12-09T02:47:18.423", "Score": "4", "OwnerUserId": "1553090", "Tags": "<c++><qt><c++11>", "AnswerCount": "5"}});