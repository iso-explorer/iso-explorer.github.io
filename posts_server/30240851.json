post_cb({"30241368": {"ParentId": "30240851", "CommentCount": "0", "Body": "<p>From <strong>[expr.prim.lambda]</strong>:</p>\n<blockquote>\n<p id=\"so_30240851_30241368_0\">5 - [...] For a generic lambda, the closure type has a public inline function call operator member template (14.5.2) whose <em>template-parameter-list</em> consists of one invented type <em>template-parameter</em> for each occurrence of <code>auto</code> in the lambda's <em>parameter-declaration-clause</em>, in order of appearance. [...]</p>\n</blockquote>\n<p>Template parameters cannot be deduced from default arguments; <strong>[temp.deduct.call]</strong>:</p>\n<blockquote>\n<p id=\"so_30240851_30241368_1\">5 - [...] [ <em>Note:</em> If a <em>template-parameter</em> is not used in any of the\n  function parameters of a function template, or is used only in a non-deduced context, its corresponding <em>template-argument</em> cannot be deduced from a function call and the <em>template-argument</em> must be explicitly\n  specified. <em>\u2014end note</em>]</p>\n</blockquote>\n<p>A default argument is a non-deduced context (<strong>[temp.deduct.type]</strong>/5).</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "30241368", "Score": "1", "CreationDate": "2015-05-14T15:35:29.737", "LastActivityDate": "2015-05-14T15:35:29.737"}, "30241306": {"ParentId": "30240851", "CommentCount": "0", "Body": "<p>just to add to what have been said above, default arguments in lamda can make you \"cheat\" when it comes to capture list.\nas we all know you must \"capture\" outside parameters with the capture list:</p>\n<pre><code>int x=7;\nauto func = [&amp;x](){ return x+1 ;}\n</code></pre>\n<p>if you could use default parameters, you could \"cheat\" on the capture list and just put a reference with a default parameter:</p>\n<pre><code>int x=7;\nauto func = [](const int&amp; y = x){ return y+1 ;}\n</code></pre>\n<p>preventing default parameters prevents you not capturing outside arguments. </p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "30241306", "Score": "0", "CreationDate": "2015-05-14T15:32:29.663", "LastActivityDate": "2015-05-14T15:32:29.663"}, "30240851": {"CommentCount": "1", "ViewCount": "60", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-14T15:10:44.540", "LastActivityDate": "2015-05-14T15:35:29.737", "Title": "References for type deduction lambda", "AcceptedAnswerId": "30241159", "LastEditDate": "2017-05-23T12:06:37.087", "Id": "30240851", "Score": "0", "Body": "<p>I saw <a href=\"https://stackoverflow.com/q/30240131/1938163\">this answer</a> but I'm not satisfied: where is it written in the standard that type deduction for 'auto' does not consider default arguments?</p>\n<pre><code>int main() {\n    auto lambda = [] (auto subl = [] {}) {};\n    lambda();\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "4715851", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30240851_30241159_6": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241159_5": {"section_id": 336, "quality": 1.0, "length": 14}, "so_30240851_30241368_1": {"section_id": 306, "quality": 0.8571428571428571, "length": 18}, "so_30240851_30241159_2": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241368_0": {"section_id": 5964, "quality": 0.9259259259259259, "length": 25}, "so_30240851_30241159_9": {"section_id": 336, "quality": 1.0, "length": 14}, "so_30240851_30241159_8": {"section_id": 336, "quality": 1.0, "length": 9}, "so_30240851_30241159_0": {"section_id": 5451, "quality": 1.0, "length": 11}, "so_30240851_30241159_4": {"section_id": 336, "quality": 1.0, "length": 9}}, "n3337": {"so_30240851_30241159_6": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241159_5": {"section_id": 326, "quality": 1.0, "length": 14}, "so_30240851_30241368_1": {"section_id": 297, "quality": 0.8571428571428571, "length": 18}, "so_30240851_30241159_9": {"section_id": 326, "quality": 1.0, "length": 14}, "so_30240851_30241159_2": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241159_8": {"section_id": 326, "quality": 1.0, "length": 9}, "so_30240851_30241159_0": {"section_id": 5245, "quality": 0.7272727272727273, "length": 8}, "so_30240851_30241159_4": {"section_id": 326, "quality": 1.0, "length": 9}}, "n4659": {"so_30240851_30241159_6": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241159_5": {"section_id": 345, "quality": 1.0, "length": 14}, "so_30240851_30241368_1": {"section_id": 313, "quality": 0.8571428571428571, "length": 18}, "so_30240851_30241159_9": {"section_id": 345, "quality": 1.0, "length": 14}, "so_30240851_30241368_0": {"section_id": 7453, "quality": 0.9259259259259259, "length": 25}, "so_30240851_30241159_2": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}, "so_30240851_30241159_8": {"section_id": 345, "quality": 1.0, "length": 9}, "so_30240851_30241159_0": {"section_id": 6889, "quality": 1.0, "length": 11}, "so_30240851_30241159_4": {"section_id": 345, "quality": 1.0, "length": 9}}}, "30241159": {"ParentId": "30240851", "CommentCount": "0", "Body": "<p><code>auto</code> uses rules according to template argument deduction ([dcl.spec.auto]\n/p7):</p>\n<blockquote>\n<p id=\"so_30240851_30241159_0\">If the placeholder is the auto\n  <em>type-specifier</em>, the deduced type is determined using the rules for template argument deduction.</p>\n</blockquote>\n<p>Default arguments are explicitly a non-deduced context when its type is a deduced template parameter ([temp.deduct.type]/p5):</p>\n<blockquote>\n<p id=\"so_30240851_30241159_1\">The non-deduced contexts are:</p>\n<blockquote>\n<p id=\"so_30240851_30241159_6\">\u2014 The nested-name-specifier of a type that was specified using a <em>qualified-id</em>.   </p>\n<p id=\"so_30240851_30241159_7\">\u2014 The expression of a <em>decltype-specifier</em>.  </p>\n<p id=\"so_30240851_30241159_8\">\u2014 A non-type template argument or an array bound in which a subexpression references a template\n    parameter.  </p>\n<p id=\"so_30240851_30241159_9\">\u2014 <strong>A template parameter used in the parameter type of a function parameter that has a default argument\n    that is being used in the call for which argument deduction is being done.</strong></p>\n</blockquote>\n</blockquote>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "30241159", "Score": "3", "CreationDate": "2015-05-14T15:25:54.113", "LastActivityDate": "2015-05-14T15:25:54.113"}});