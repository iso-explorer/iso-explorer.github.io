post_cb({"15132284": {"ParentId": "15131140", "CommentCount": "2", "Body": "<p>The important thing to consider here is the <em>lifetime</em> of the object. The lifetime of an object must exist within the time that the storage for that object has been allocated. Many objects can exist at a single storage location within the time that storage is allocated, one after the other.</p>\n<p>Normally, when an object is destroyed (through going out of scope or calling <code>delete</code>), the objects lifetime is ended and then its memory is deallocated. However, when you call the destructor explicitly, all you do is end the lifetime of your object. The standard has no definition of the object \"not existing\", but it does have the concept of its lifetime ending.</p>\n<blockquote>\n<p id=\"so_15131140_15132284_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>Now, in the state after an objects lifetime has ended and before its storage has been deallocated, there are only very specific things you can do. The standard defines things that can be done in this state to both pointers and glvalues. In your case, <code>list</code> is a glvalue, so we'll take a look at the rules for that:</p>\n<blockquote>\n<p id=\"so_15131140_15132284_1\">[...] after the lifetime of an object has ended and before the storage which the object\n  occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. [...] The program has undefined behavior if:</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</li>\n<li>the glvalue is used to access a non-static data member or call a non-static member function of the object, or</li>\n<li>the glvalue is implicitly converted (4.10) to a reference to a base class type, or</li>\n<li>the glvalue is used as the operand of a <code>static_cast</code> (5.2.9) except when the conversion is ultimately to cv <code>char&amp;</code> or cv <code>unsigned char&amp;</code>, or</li>\n<li>the glvalue is used as the operand of a <code>dynamic_cast</code> (5.2.7) or as the operand of <code>typeid</code>.</li>\n</ul>\n</blockquote>\n<p>The second list item applies here. You have undefined behaviour beacuse you're accessing a non-static member function after the objects lifetime has ended.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15132284", "Score": "3", "CreationDate": "2013-02-28T09:48:18.950", "LastActivityDate": "2013-02-28T09:48:18.950"}, "15131140": {"CommentCount": "17", "ViewCount": "270", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-02-28T08:48:58.983", "LastActivityDate": "2013-03-01T20:50:59.520", "Title": "Invoking the destructor of the same object multiple times, result is not the same as described in standard", "AcceptedAnswerId": "15132284", "LastEditDate": "2013-03-01T20:50:59.520", "Id": "15131140", "Score": "-1", "Body": "<p>I use MS Visual Studio 2010.  </p>\n<p>I made implementation of a double-linked list.  </p>\n<p><strong>I wonder why in main function after invoking method Clean, which invoke destructor of an object, after I refer to the object no errors are raised.</strong></p>\n<p>Here are some of my double-linked list methods(relative to my question):  </p>\n<pre><code>/*DoubleLinkedList.cpp */  \n         DoubleLinkedList::~DoubleLinkedList(void)\n        {\n        cout &lt;&lt; \"Destructor invoked\" &lt;&lt; endl;\n        // as for data nodes memory is allocated in heap we have to release it:\n        const Node* const_iterator = m_head.m_next;\n        while (const_iterator != &amp;m_tail)\n        {\n            const_iterator = const_iterator-&gt;m_next;\n            delete const_iterator-&gt;m_prev;\n        }\n    }\n\nvoid DoubleLinkedList::Clean(void)\n{\n    cout &lt;&lt; \"Clean invoked\" &lt;&lt; endl;\n\n    this-&gt;~DoubleLinkedList(); /* According to C++ 11 standart: Once a destructor is invoked for an object, the object no longer exists*/\n}\n\n/* main.cpp */\n    int main(int argc, char* argv[])\n    {\n        DoubleLinkedList list;\n        Circle c1, c2(MyPoint(1,1),50), c3(MyPoint(2,2),30);\n        list.Front(&amp;c1);\n        list.Front(&amp;c2);\n        list.Front(&amp;c3);\n        list.Show();\n        list.Sort();\n        list.Show();\n        list.Clean();\n        list.Show(); /* Recall how Clean method is implemented. As list no longer exist, run-time error is expected here, but flow of executon continues and Show, Push_back preforms fine*/\n        list.Push_back(&amp;c1);\n        list.Push_back(&amp;c2);\n        list.Push_back(&amp;c3);\n</code></pre>\n<p><strong>Question:</strong> *<em>As stated in the 11 standart of C++ after destructor is called - object no longer exists</em>*, why I am still able to use the object after it`s destructor was invoked?</p>\n", "Tags": "<c++><destructor>", "OwnerUserId": "1280794", "AnswerCount": "2"}, "15131170": {"ParentId": "15131140", "CommentCount": "2", "Body": "<p>Use object AFTER it's destroyed (i.e. destructor's is called) is UB. UB means undefined behaviour. So...</p>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "15131170", "Score": "2", "CreationDate": "2013-02-28T08:50:49.480", "LastActivityDate": "2013-02-28T08:50:49.480"}, "bq_ids": {"n4140": {"so_15131140_15132284_1": {"section_id": 7194, "quality": 0.9523809523809523, "length": 20}, "so_15131140_15132284_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_15131140_15132284_1": {"section_id": 6938, "quality": 0.9523809523809523, "length": 20}, "so_15131140_15132284_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_15131140_15132284_1": {"section_id": 8703, "quality": 0.9523809523809523, "length": 20}, "so_15131140_15132284_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}});