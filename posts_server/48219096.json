post_cb({"bq_ids": {"n4140": {"so_48219096_48219374_0": {"length": 42, "quality": 0.75, "section_id": 162}}, "n3337": {"so_48219096_48219374_0": {"length": 32, "quality": 0.5714285714285714, "section_id": 156}}, "n4659": {"so_48219096_48219374_0": {"length": 52, "quality": 0.9285714285714286, "section_id": 166}}}, "48219096": {"ViewCount": "292", "Body": "<p>Consider the following:</p>\n<pre><code>template&lt;typename T&gt;\nstruct C {};\ntemplate&lt;typename T, typename U&gt;\nvoid operator +(C&lt;T&gt;&amp;, U);\n\nstruct D: C&lt;D&gt; {};\n\nstruct E {};\ntemplate&lt;typename T&gt;\nvoid operator +(C&lt;T&gt;&amp;, E);\n\nvoid F() { D d; E e; d + e; }\n</code></pre>\n<p>This code compiles fine on both GCC-7 and Clang-5. The selected overload for <code>operator +</code> is that of <code>struct E</code>.</p>\n<p>Now, if the following change takes place:</p>\n<pre><code>/* Put `operator +` inside the class. */\ntemplate&lt;typename T&gt;\nstruct C {\n    template&lt;typename U&gt;\n    void operator +(U);\n};\n</code></pre>\n<p>that is, if <code>operator +</code> is defined <em>inside</em> the class template, instead of <em>outside</em>, then Clang yields ambiguity between both <code>operator +</code>s present in the code. GCC still compiles fine.</p>\n<p>Why does this happen? Is this a bug in either GCC or Clang?</p>\n", "AcceptedAnswerId": "48235546", "Title": "Ambiguous operator overload in Clang", "CreationDate": "2018-01-12T03:21:02.880", "LastActivityDate": "2018-01-12T23:45:27.783", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-01-12T04:05:11.480", "LastEditorUserId": "921070", "Id": "48219096", "Score": "14", "OwnerUserId": "259543", "Tags": "<c++><templates><gcc><clang><language-lawyer>", "AnswerCount": "2"}, "48219374": {"Id": "48219374", "PostTypeId": "2", "Body": "<p>Edit: The original version of this answer said that GCC was correct. I now believe that Clang is correct according to the wording of the standard, but I can see how GCC's interpretation could also be correct.</p>\n<p>Let's look at your first example, where the two declarations are:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid operator +(C&lt;T&gt;&amp;, U);\ntemplate&lt;typename T&gt;\nvoid operator +(C&lt;T&gt;&amp;, E);\n</code></pre>\n<p>Both are viable, but it is obvious that the second template is more specialized than the first. So GCC and Clang both resolve the call to the second template. But let's walk through [temp.func.order] to see <em>why</em>, in the wording of the standard, the second template is more specialized.</p>\n<p>The partial ordering rules tell us to replace each type template parameter with a unique synthesized type and then perform deduction against the other template. Under this scheme, the first overload type becomes</p>\n<pre><code>void(C&lt;X1&gt;&amp;, X2)\n</code></pre>\n<p>and deduction against the second template fails since the latter only accepts <code>E</code>. The second overload type becomes</p>\n<pre><code>void(C&lt;X3&gt;&amp;, E)\n</code></pre>\n<p>and deduction against the first template <em>succeeds</em> (with <code>T</code> = <code>X3</code> and <code>U</code> = <code>E</code>). Since the deduction succeeded in only one direction, the template that accepted the other's transformed type (the first one) is considered less specialized, and thus, the second overload is chosen as the more specialized one.</p>\n<p>When the second overload is moved into class <code>C</code>, both overloads are still found and the overload resolution process should apply in exactly the same way. First, the argument list is constructed for both overloads, and since the first overload is a non-static class member, an implied object parameter is inserted. According to [over.match.funcs], the type of that implied object parameter should be \"lvalue reference to <code>C&lt;T&gt;</code>\" since the function does not have a ref-qualifier. So the two argument lists are both <code>(C&lt;D&gt;&amp;, E)</code>. Since this fails to effect a choice between the two overloads, the partial ordering test kicks in again.</p>\n<p>The partial ordering test, described in [temp.func.order], <em>also</em> inserts an implied object parameter:</p>\n<blockquote>\n<p id=\"so_48219096_48219374_0\">If only one of the function templates <code>M</code> is a non-static member of\n  some class <code>A</code>, <code>M</code> is considered to have a new first parameter inserted in its function parameter list. Given <em>cv</em>\n  as the cv-qualifiers of <code>M</code> (if any), the new parameter is of type \u201crvalue reference to <em>cv</em> <code>A</code>\u201d if the optional\n  <em>ref-qualifier</em> of <code>M</code> is <code>&amp;&amp;</code> or if <code>M</code> has no <em>ref-qualifier</em> and the first parameter of the other template has rvalue\n  reference type. Otherwise, the new parameter is of type \u201clvalue reference to <em>cv</em> <code>A</code>\u201d. [ <em>Note:</em> This allows a\n  non-static member to be ordered with respect to a non-member function and for the results to be equivalent\n  to the ordering of two equivalent non-members. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>This is the step where, presumably, GCC and Clang take different interpretations of the standard.</p>\n<p>My take: The member <code>operator+</code> has already been found in the class <code>C&lt;D&gt;</code>. The template parameter <code>T</code> for the class <code>C</code> is not being deduced; it is known because the name lookup process entered the concrete base class <code>C&lt;D&gt;</code> of <code>D</code>. The actual <code>operator+</code> that is submitted to partial ordering therefore does <em>not</em> have a free <code>T</code> parameter; it is not <code>void operator+(C&lt;T&gt;&amp;, U)</code>, but rather, <code>void operator+(C&lt;D&gt;&amp;, U)</code>.</p>\n<p>Thus, for the member overload, the transformed function type should not be <code>void(C&lt;X1&gt;&amp;, X2)</code>, but rather <code>void(C&lt;D&gt;&amp;, X2)</code>. For the non-member overload, the transformed function type is still <code>void(C&lt;X3&gt;&amp;, E)</code> as before. But now we see that <code>void(C&lt;D&gt;&amp;, X2)</code> is not a match for the non-member template <code>void(C&lt;T&gt;&amp;, E)</code> <em>nor</em> is <code>void(C&lt;X3&gt;&amp;, E)</code> a match for the member template <code>void(C&lt;D&gt;&amp;, U)</code>. So partial ordering fails, and overload resolution returns an ambiguous result.</p>\n<p>GCC's decision to continue to select the non-member overload makes sense if you assume that it is constructing the transformed function type for the member lexically, making it still <code>void(C&lt;X1&gt;&amp;, X2)</code>, while Clang substitutes <code>D</code> into the template, leaving only <code>U</code> as a free parameter, <em>before</em> beginning the partial ordering test.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2018-01-12T04:21:38.617", "Score": "7", "CreationDate": "2018-01-12T04:05:38.063", "ParentId": "48219096", "CommentCount": "11", "OwnerUserId": "481267", "LastEditDate": "2018-01-12T04:21:38.617"}, "48235546": {"Id": "48235546", "PostTypeId": "2", "Body": "<p>This is a bug in gcc; specifically, <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53499\" rel=\"noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53499</a> .</p>\n<p>The problem is that gcc is regarding the implicit object parameter of a class template member function as having a dependent type; that is, during function template partial ordering gcc transforms</p>\n<pre><code>C&lt;D&gt;::template&lt;class U&gt; void operator+(U);  // #1\n</code></pre>\n<p>into</p>\n<pre><code>template&lt;class T, class U&gt; void operator+(C&lt;T&gt;&amp;, U);  // #1a (gcc, wrong)\n</code></pre>\n<p>when it should be transformed into</p>\n<pre><code>template&lt;class U&gt; void operator+(C&lt;D&gt;&amp;, U);  // #1b (clang, correct)\n</code></pre>\n<p>We can see that when compared to your</p>\n<pre><code>template&lt;class T&gt; void operator+(C&lt;T&gt;&amp;, E);  // #2\n</code></pre>\n<p><code>#2</code> is better than the erroneous <code>#1a</code>, but is ambiguous with <code>#1b</code>.</p>\n<p>Observe that gcc incorrectly accepts even when <code>C&lt;D&gt;</code> is not a template at all - i.e., when <code>C&lt;D&gt;</code> is a class template full specialization:</p>\n<pre><code>template&lt;class&gt; struct C;\nstruct D;\ntemplate&lt;&gt; struct C&lt;D&gt; {\n    // ...\n</code></pre>\n<p>This is covered by <a href=\"http://eel.is/c++draft/temp.func.order#3\" rel=\"noreferrer\">[temp.func.order]/3</a>, with clarification in the example. Note that again, gcc miscompiles that example, incorrectly rejecting it but for the same reason.</p>\n", "LastActivityDate": "2018-01-12T23:45:27.783", "Score": "6", "CreationDate": "2018-01-12T23:45:27.783", "ParentId": "48219096", "CommentCount": "1", "OwnerUserId": "567292"}});