post_cb({"45497684": {"ViewCount": "702", "Body": "<p>From C++11 standard (15.1.p4):</p>\n<blockquote>\n<p id=\"so_45497684_45497684_0\">The memory for the exception object is allocated in an unspecified\n  way, except as noted in 3.7.4.1</p>\n</blockquote>\n<p>What if allocation fails -- will it throw <code>std::bad_alloc</code> instead? Call <code>std::terminate</code>? Unspecified?</p>\n", "AcceptedAnswerId": "45552806", "Title": "What happens if 'throw' fails to allocate memory for exception object?", "CreationDate": "2017-08-04T03:09:24.800", "Id": "45497684", "CommentCount": "5", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-10-15T08:58:15.107", "LastEditorUserId": "3919155", "LastActivityDate": "2017-10-17T10:04:03.680", "Score": "28", "OwnerUserId": "6427477", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "46764045": {"Id": "46764045", "PostTypeId": "2", "Body": "<p>Current answer already describes what GCC does. I have checked MSVC behavior - it allocates exception on the stack, so allocation does not depend on the heap. This makes stack overflow is possible (exception object can be big), but stack overflow handling is not covered by standard C++.</p>\n<p>I used this short program to examine what happens during exception throw:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\npublic:\n    A() { std::cout &lt;&lt; \"A::A() at \" &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; std::endl; }\n    A(const A &amp;) { std::cout &lt;&lt; \"A::A(const A &amp;) at \" &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; std::endl; }\n    A(A &amp;&amp;) { std::cout &lt;&lt; \"A::A(A &amp;&amp;) at \" &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; std::endl; }\n    ~A() { std::cout &lt;&lt; \"A::~A() at \" &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; std::endl; }\n    A &amp;operator=(const A &amp;) = delete;\n    A &amp;operator=(A &amp;&amp;) = delete;\n};\n\nint main()\n{\n    try {\n        try {\n            try {\n                A a;\n                throw a;\n            } catch (const A &amp;ex) {\n                throw;\n            }\n        } catch (const A &amp;ex) {\n            throw;\n        }\n    } catch (const A &amp;ex) {\n    }\n}\n</code></pre>\n<p>When build with GCC output clearly shows that exception thrown is being allocated far from stack:</p>\n<pre><code>A::A() at 0x22cad7\nA::A(A &amp;&amp;) at 0x600020510\nA::~A() at 0x22cad7\nA::~A() at 0x600020510\n</code></pre>\n<p>When build with MSVC output shows that exception is allocated nearby on the stack:</p>\n<pre><code>A::A() at 000000000018F4E4\nA::A(A &amp;&amp;) at 000000000018F624\nA::~A() at 000000000018F4E4\nA::~A() at 000000000018F624\n</code></pre>\n<p>Additional examination with debugger shows that catch handlers and destructors are executed on the top of the stack, so stack consumption grows with each catch block starting with the first throw and until <code>std::uncaught_exceptions()</code> becomes 0.</p>\n<p>Such behavior means that correct out of memory handling requires you to prove there is enough stack space for the program to execute exception handlers and all destructors on the way.</p>\n<p>To prove the same with GCC it seems that you will need to prove there no more than four nested exceptions and exceptions have size less than 1KiB (this includes header). Additionally if some thread has more than four nested exceptions, you also need to prove there is no deadlock caused by emergency buffer allocation.</p>\n", "LastEditorUserId": "1143634", "LastActivityDate": "2017-10-17T10:04:03.680", "Score": "2", "CreationDate": "2017-10-16T06:21:34.520", "ParentId": "45497684", "CommentCount": "10", "OwnerUserId": "1143634", "LastEditDate": "2017-10-17T10:04:03.680"}, "46754122": {"Id": "46754122", "PostTypeId": "2", "Body": "<p>Actualy it is specified that if allocation for the exception object fails, <code>bad_alloc</code> should be thrown and implementation could also call the new handler.</p>\n<p>This is what is actualy specified in the c++ standard section (\u00a73.7.4.1) you site <a href=\"http://eel.is/c++draft/basic.stc.dynamic.allocation#3\" rel=\"nofollow noreferrer\">[basic.stc.dynamic.allocation]</a>:</p>\n<blockquote>\n<p id=\"so_45497684_46754122_0\">An allocation function that fails to allocate storage can invoke the currently installed new-handler function\n  (21.6.3.3), if any. [\n  Note:\n  A program-supplied allocation function can obtain the address of the currently\n  installed\n  new_handler\n  using the\n  std::get_new_handler\n  function (21.6.3.4).\n  \u2014 end note\n  ] If an allocation\n  function that has a non-throwing exception specification (18.4) fails to allocate storage, it shall return a null\n  pointer. Any other allocation function that fails to allocate storage shall indicate failure only by throwing an\n  exception (18.1) of a type that would match a handler (18.3) of type\n  std::bad_alloc\n  (21.6.3.1).</p>\n</blockquote>\n<p>Then this recalled in <a href=\"http://eel.is/c++draft/except.terminate#1.1\" rel=\"nofollow noreferrer\">[except.terminate]</a></p>\n<blockquote>\n<p id=\"so_45497684_46754122_1\">In some situations exception handling must be abandoned for less subtle error handling techniques. [\n  Note:\n  These situations are:\n  \u2014\n  (1.1)\n  when the exception handling mechanism, <strong>after completing the initialization of the exception object</strong> but\n  before activation of a handler for the exception (18.1)*</p>\n</blockquote>\n<p>So the itanium ABI does not follow the c++ standard specification, since it can block or call <code>terminate</code> if the program fails to allocate memory for the exception object.</p>\n", "LastActivityDate": "2017-10-15T10:38:36.020", "CommentCount": "8", "CreationDate": "2017-10-15T10:38:36.020", "ParentId": "45497684", "Score": "0", "OwnerUserId": "5632316"}, "45552806": {"Id": "45552806", "PostTypeId": "2", "Body": "<p><em>(providing my own answer... I'll wait for few days and if there are no problems with it -- I'll mark it as accepted)</em></p>\n<p>I spent some time investigating this and here is what I unearthed:</p>\n<ul>\n<li>C++ standard does not specify what is going to happen in this case</li>\n<li>Clang and GCC seem to use <a href=\"https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html\" rel=\"noreferrer\">C++ Itanium ABI</a></li>\n</ul>\n<p>Itanimum ABI suggests to use heap for exceptions:</p>\n<blockquote>\n<p id=\"so_45497684_45552806_0\">Storage is needed for exceptions being thrown. This storage must\n  persist while stack is being unwound, since it will be used by the\n  handler, and must be thread-safe. Exception object storage will\n  therefore normally be allocated in the heap</p>\n<p id=\"so_45497684_45552806_1\">...</p>\n<p id=\"so_45497684_45552806_2\">Memory will be allocated by the <code>__cxa_allocate_exception</code> runtime library routine.</p>\n</blockquote>\n<p>So, yeah... throwing an exception will likely involve locking mutexes and searching for a free memory block. :-(</p>\n<p>It also mentions this:</p>\n<blockquote>\n<p id=\"so_45497684_45552806_3\">If __cxa_allocate_exception cannot allocate an exception object under these constraints, it calls terminate()</p>\n</blockquote>\n<p>Yep... in GCC and Clang \"throw myX();\" can kill your app and you can't do a thing about it (maybe writing your own <code>__cxa_allocate_exception</code> can help -- but it certainly won't be portable)</p>\n<p>It gets even better:</p>\n<blockquote>\n<p id=\"so_45497684_45552806_4\">3.4.1 Allocating the Exception Object</p>\n<p id=\"so_45497684_45552806_5\">Memory for an exception object will be allocated by the\n  __cxa_allocate_exception runtime library routine, with general requirements as described in Section 2.4.2. If normal allocation\n  fails, then it will attempt to allocate one of the emergency buffers,\n  described in Section 3.3.1, under the following constraints:</p>\n<ul>\n<li>The exception object size, including headers, is under 1KB. </li>\n<li>The current thread does not already hold four buffers.</li>\n<li>There are fewer than 16 other threads holding buffers, or <strong>this thread\n  will wait until one of the others releases its buffers</strong> before acquiring one.</li>\n</ul>\n</blockquote>\n<p>Yep, your program can simply hang! Granted chance of this are small -- you'd need to exhaust memory and your threads need to use up all 16 emergency buffers and enter wait for another thread that should generate an exception. But if you do things with <code>std::current_exception</code> (like chaining exception and passing them between threads) -- it is not so improbable.</p>\n<p><strong>Conclusion:</strong></p>\n<p>This is a deficiency in C++ standard -- you can't write 100% reliable programs (that use exceptions). Text book example is a server that accepts connections from clients and executes submitted tasks. Obvious approach to handle problems would be to throw an exception, which will unwind everything and close connection -- all other clients won't be affected and server will continue to operate (even under low memory conditions). Alas, such server is impossible to write in C++.</p>\n<p>You can claim that modern systems (i.e. Linux) will kill such server before we reach this situation anyway. But (1) it is not an argument; (2) memory manager can be set to overcommit; (3) OOM killer won't be triggered for 32-bit app running on 64bit hardware with enough memory (or if app artificially limited memory allocation).</p>\n<p>On personal note I am quite pissed about this discovery -- for many years I claimed that my code handles out-of-memory gracefully. Turns out I lied to my clients. :-( Might as well start intercepting memory allocation, call <code>std::terminate</code> and treat all related functions as <code>noexcept</code> -- this will certainly make my life easier (coding-wise). No wonder they still use Ada to programs rockets.</p>\n", "LastActivityDate": "2017-08-07T17:46:43.810", "CommentCount": "17", "CreationDate": "2017-08-07T17:46:43.810", "ParentId": "45497684", "Score": "6", "OwnerUserId": "6427477"}, "bq_ids": {"n4140": {"so_45497684_46754122_0": {"length": 48, "quality": 0.8, "section_id": 7178}, "so_45497684_45522989_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5770}, "so_45497684_45522989_0": {"length": 23, "quality": 0.92, "section_id": 5770}, "so_45497684_46754122_1": {"length": 26, "quality": 0.896551724137931, "section_id": 3382}, "so_45497684_45497684_0": {"length": 8, "quality": 0.8, "section_id": 3337}}, "n3337": {"so_45497684_46754122_0": {"length": 48, "quality": 0.8, "section_id": 6922}, "so_45497684_45522989_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5543}, "so_45497684_45522989_0": {"length": 23, "quality": 0.92, "section_id": 5543}, "so_45497684_46754122_1": {"length": 26, "quality": 0.896551724137931, "section_id": 3251}, "so_45497684_45497684_0": {"length": 8, "quality": 0.8, "section_id": 3207}}, "n4659": {"so_45497684_46754122_0": {"length": 50, "quality": 0.8333333333333334, "section_id": 8686}, "so_45497684_45522989_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7227}, "so_45497684_45522989_0": {"length": 23, "quality": 0.92, "section_id": 7227}, "so_45497684_46754122_1": {"length": 26, "quality": 0.896551724137931, "section_id": 4142}, "so_45497684_45497684_0": {"length": 8, "quality": 0.8, "section_id": 4104}}}, "45522989": {"Id": "45522989", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45497684_45522989_0\"><strong>[intro.compliance]/2</strong> Although this International Standard states only requirements on C++ implementations, those requirements are often easier to understand if they are phrased as requirements on programs, parts of programs, or execution of programs. Such requirements have the following meaning:</p>\n<p id=\"so_45497684_45522989_1\">(2.1) \u2014 If a program contains no violations of the rules in this International Standard, a conforming implementation shall, <strong>within its resource limits</strong>, accept and correctly execute that program.</p>\n</blockquote>\n<p>Emphasis mine. Basically, the standard envisions failure to allocate dynamic memory (and prescribes behavior in this case), but not any other kind of memory; and doesn't prescribe in any way what the implementation should do when its resource limits are reached.</p>\n<p>Another example is running out of stack due to a too-deep recursion. Nowhere does the standard say how deep a recursion is allowed. The resulting stack overflow is the implementation exercising its \"within resource limits\" right-to-fail.</p>\n", "LastActivityDate": "2017-08-05T14:25:59.007", "CommentCount": "2", "CreationDate": "2017-08-05T14:25:59.007", "ParentId": "45497684", "Score": "2", "OwnerUserId": "1670129"}});