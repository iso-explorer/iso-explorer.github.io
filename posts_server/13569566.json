post_cb({"21955217": {"Id": "21955217", "PostTypeId": "2", "Body": "<p>@Pubby I don't know if the C/C++ standards have defined the behavior when signed integer overflows, but gcc seems not always treat (x &lt; x + 1) as true.\nthe \"&lt;\" operator takes signed int as operand, so\n    x &lt; x + 1 --&gt; (int)x &lt; (int)x + (int)1</p>\n<p>the following code produces output: 1 0 0 0 (32bit Linux + gcc)</p>\n<pre><code>signed char c1, c2; \nsigned int i1, i2; \n\nc1 = 127;\nc2 = c1 + 1;\n\ni1 = 2147483647;\ni2 = i1 + 1;\n\nprintf(\"%d %d\\n\", c1 &lt; c1 + 1, c1 &lt; c2);\nprintf(\"%d %d\\n\", i1 &lt; i1 + 1, i1 &lt; i2);\n</code></pre>\n", "LastActivityDate": "2014-02-22T13:52:05.877", "CommentCount": "1", "CreationDate": "2014-02-22T13:52:05.877", "ParentId": "13569566", "Score": "0", "OwnerUserId": "3131403"}, "13569615": {"Id": "13569615", "PostTypeId": "2", "Body": "<p>Edit: See T.C.'s answer below. It's better.</p>\n<p>Signed integer overflow is undefined in C++ and C. In most implementations, the maximum value of <code>signed char</code>, <code>SCHAR_MAX</code>, is 127 and so putting 256 into it will overflow it. Most of the time you will see the number simply wrap around (to 0), but this is still undefined behavior.</p>\n", "LastEditorUserId": "964135", "LastActivityDate": "2015-02-11T18:37:52.870", "Score": "6", "CreationDate": "2012-11-26T17:04:54.093", "ParentId": "13569566", "CommentCount": "5", "OwnerUserId": "964135", "LastEditDate": "2015-02-11T18:37:52.870"}, "13569625": {"Id": "13569625", "PostTypeId": "2", "Body": "<p><code>unsigned char</code> values is (to be pedantic, usually) is from 0 to 255. There is 256 values, that 1 byte may hold.</p>\n<p>If you get overflow (usually) values are used modulo 256, as other Integer type modulo <code>MAX + 1</code></p>\n", "LastActivityDate": "2012-11-26T17:05:23.983", "CommentCount": "0", "CreationDate": "2012-11-26T17:05:23.983", "ParentId": "13569566", "Score": "1", "OwnerUserId": "768110"}, "bq_ids": {"n4140": {"so_13569566_28453985_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}, "so_13569566_28453985_3": {"length": 13, "quality": 1.0, "section_id": 5937}, "so_13569566_28453985_0": {"length": 18, "quality": 1.0, "section_id": 30}}, "n3337": {"so_13569566_28453985_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}, "so_13569566_28453985_3": {"length": 13, "quality": 1.0, "section_id": 5709}, "so_13569566_28453985_0": {"length": 18, "quality": 1.0, "section_id": 27}}, "n4659": {"so_13569566_28453985_3": {"length": 13, "quality": 1.0, "section_id": 7421}, "so_13569566_28453985_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}, "so_13569566_28453985_0": {"length": 18, "quality": 1.0, "section_id": 30}}}, "13569566": {"ViewCount": "2585", "Body": "<p>Reading the C++ Primer 5th edition book, I noticed that a <code>signed char</code> with a value of <code>256</code> is undefined.\nI decided to try that, and I saw that <code>std::cout</code> didn't work for that char variable. (Printed Nothing).</p>\n<p>But on C, the same thing\n<code>signed char c = 256;</code>\nwould give a value <code>0</code> for the <code>char c</code>.</p>\n<p>I tried searching but didn't find anything.</p>\n<p>Can someone explain to me why is this the case in C++?</p>\n<p>Edit: I understand that 256 is 2 bytes, but why doesn't the same thing as in C, happen to C++?</p>\n", "AcceptedAnswerId": "13569615", "Title": "Why 256 for a signed char is undefined in C++", "CreationDate": "2012-11-26T17:02:44.997", "Id": "13569566", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-02-16T02:46:45.920", "Score": "2", "OwnerUserId": "1252742", "Tags": "<c++><char><signed>", "AnswerCount": "6"}, "13569604": {"Id": "13569604", "PostTypeId": "2", "Body": "<p>A char is generally <code>8 bits</code> or a <code>byte</code>, therefore can hold <code>2^8</code> different values. If it is <code>unsigned</code>, from <code>0</code> to <code>255</code> otherwise, when <code>signed</code> from <code>-128</code> to <code>127</code></p>\n", "LastEditorUserId": "269211", "LastActivityDate": "2012-11-26T17:18:25.787", "Score": "2", "CreationDate": "2012-11-26T17:04:38.693", "ParentId": "13569566", "CommentCount": "1", "OwnerUserId": "269211", "LastEditDate": "2012-11-26T17:18:25.787"}, "13569749": {"Id": "13569749", "PostTypeId": "2", "Body": "<p>You're seeing the difference between <code>cout</code> and <code>printf</code>. When you output a character with <code>cout</code> you don't get the numeric representation, you get a single character. In this case the character was <code>NUL</code> which doesn't appear on-screen.</p>\n<p>See the example at <a href=\"http://ideone.com/7n6Lqc\" rel=\"nofollow\">http://ideone.com/7n6Lqc</a></p>\n", "LastActivityDate": "2012-11-26T17:13:20.390", "CommentCount": "0", "CreationDate": "2012-11-26T17:13:20.390", "ParentId": "13569566", "Score": "3", "OwnerUserId": "5987"}, "28453985": {"Id": "28453985", "PostTypeId": "2", "Body": "<p>The book is wildly incorrect. There's no undefined behavior in</p>\n<pre><code>signed char c = 256;\n</code></pre>\n<p><code>256</code> is an integer literal of type <code>int</code>. To initialize a <code>signed char</code> with it, it is converted to <code>signed char</code> (\u00a78.5 [dcl.init]/17.8; all references are to N4140). This conversion is governed by \u00a74.7 [conv.integral]:</p>\n<blockquote>\n<p id=\"so_13569566_28453985_0\">1 A prvalue of an integer type can be converted to a prvalue of\n  another integer type. A prvalue of an unscoped enumeration type can be\n  converted to a prvalue of an integer type.</p>\n<p id=\"so_13569566_28453985_1\">2  If the destination type is unsigned,  [...]</p>\n<p id=\"so_13569566_28453985_2\">3  If the destination type is signed, the value is unchanged if it can\n  be represented in the destination type (and bit-field width);\n  <strong>otherwise, the value is implementation-defined.</strong></p>\n</blockquote>\n<p>If <code>signed char</code> cannot represent 256, then conversion yields an implementation-defined value of type <code>signed char</code>, which is then used to initialize <code>c</code>. There is nothing undefined here.</p>\n<hr>\n<p>When people say \"signed overflow is UB\", they are usually referring to the rule in \u00a75 [expr]/p4:</p>\n<blockquote>\n<p id=\"so_13569566_28453985_3\">If during the evaluation of an expression, the result is not\n  mathematically defined or not in the range of representable values for\n  its type, the behavior is undefined.</p>\n</blockquote>\n<p>This renders UB expressions like <code>INT_MAX + 1</code> - the operands are both <code>int</code>s, so the result's type is also <code>int</code>, but the value is outside the range of representable values. This rule does not apply here, as the only expression is <code>256</code>, whose type is <code>int</code>, and 256 is obviously in the range of representable values for <code>int</code>. </p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2016-02-16T02:46:45.920", "Score": "9", "CreationDate": "2015-02-11T12:07:55.063", "ParentId": "13569566", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2016-02-16T02:46:45.920"}});