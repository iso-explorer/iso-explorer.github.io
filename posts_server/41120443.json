post_cb({"41125597": {"ParentId": "41120443", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You never delete the door</p>\n<pre><code>new Door(newRoom, anotherNewRoom);\n</code></pre>\n<p>You should add <code>Door *door</code> in world</p>\n<pre><code>public:\n  Door *door;\n\n...\n\n  door = new Door(newRoom, anotherNewRoom);\n</code></pre>\n<p>and call delete in the destructor of world:</p>\n<pre><code>delete door;\n</code></pre>\n<p>note that your code has a lot of undefined behavior.</p>\n<hr>\n<pre><code>std::set&lt;Room *&gt; rooms;\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/set\" rel=\"nofollow noreferrer\"><code>std::set</code></a> is an associative container that contains a sorted set of unique objects of type Key.</p>\n<p>You should use list:</p>\n<pre><code>std::list&lt;Room *&gt; rooms;\n</code></pre>\n</hr>", "OwnerUserId": "7076153", "LastEditorUserId": "7076153", "LastEditDate": "2016-12-13T17:06:17.553", "Id": "41125597", "Score": "0", "CreationDate": "2016-12-13T16:10:49.003", "LastActivityDate": "2016-12-13T17:06:17.553"}, "41126981": {"ParentId": "41120443", "CommentCount": "2", "Body": "<p>You should pay attention to compiler warning messages:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -std=c++17 -fPIC -g -Wall -Wextra -Wwrite-strings -Wno-parentheses -Wpedantic -Warray-bounds -Weffc++      41120443.cpp    -o 41120443\n41120443.cpp:1:15: warning: extra tokens at end of #include directive\n #include &lt;set&gt;;\n               ^\n41120443.cpp:7:7: warning: \u2018class Room\u2019 has pointer data members [-Weffc++]\n class Room {\n       ^~~~\n41120443.cpp:7:7: warning:   but does not override \u2018Room(const Room&amp;)\u2019 [-Weffc++]\n41120443.cpp:7:7: warning:   or \u2018operator=(const Room&amp;)\u2019 [-Weffc++]\n41120443.cpp: In constructor \u2018Room::Room()\u2019:\n41120443.cpp:12:5: warning: \u2018Room::door1\u2019 should be initialized in the member initialization list [-Weffc++]\n     Room(){}\n     ^~~~\n41120443.cpp:12:5: warning: \u2018Room::door2\u2019 should be initialized in the member initialization list [-Weffc++]\n41120443.cpp: In destructor \u2018Room::~Room()\u2019:\n41120443.cpp:15:16: warning: possible problem detected in invocation of delete operator: [-Wdelete-incomplete]\n         delete door1;\n                ^~~~~\n41120443.cpp:15:16: warning: invalid use of incomplete type \u2018class Door\u2019\n41120443.cpp:5:7: note: forward declaration of \u2018class Door\u2019\n class Door; // Forward declaration\n       ^~~~\n41120443.cpp:15:16: note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined\n         delete door1;\n                ^~~~~\n41120443.cpp:17:16: warning: possible problem detected in invocation of delete operator: [-Wdelete-incomplete]\n         delete door2;\n                ^~~~~\n41120443.cpp:17:16: warning: invalid use of incomplete type \u2018class Door\u2019\n41120443.cpp:5:7: note: forward declaration of \u2018class Door\u2019\n class Door; // Forward declaration\n       ^~~~\n41120443.cpp:17:16: note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined\n         delete door2;\n                ^~~~~\n41120443.cpp: At global scope:\n41120443.cpp:22:7: warning: \u2018class Door\u2019 has pointer data members [-Weffc++]\n class Door {\n       ^~~~\n41120443.cpp:22:7: warning:   but does not override \u2018Door(const Door&amp;)\u2019 [-Weffc++]\n41120443.cpp:22:7: warning:   or \u2018operator=(const Door&amp;)\u2019 [-Weffc++]\n41120443.cpp: In constructor \u2018Door::Door(Room*, Room*)\u2019:\n41120443.cpp:27:5: warning: \u2018Door::roomA\u2019 should be initialized in the member initialization list [-Weffc++]\n     Door(Room* roomA, Room* roomB) {\n     ^~~~\n41120443.cpp:27:5: warning: \u2018Door::roomB\u2019 should be initialized in the member initialization list [-Weffc++]\n41120443.cpp: In constructor \u2018World::World()\u2019:\n41120443.cpp:56:5: warning: \u2018World::rooms\u2019 should be initialized in the member initialization list [-Weffc++]\n     World() {\n     ^~~~~\n</code></pre>\n<p>and Valgrind output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>valgrind  ./41120443 \n==2864== Memcheck, a memory error detector\n==2864== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==2864== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==2864== Command: ./41120443\n==2864== \n==2864== Conditional jump or move depends on uninitialised value(s)\n==2864==    at 0x4C2C291: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==2864==    by 0x108BC3: Room::~Room() (41120443.cpp:17)\n==2864==    by 0x108D67: World::~World() (41120443.cpp:68)\n==2864==    by 0x108B65: main (41120443.cpp:75)\n==2864== \n==2864== Conditional jump or move depends on uninitialised value(s)\n==2864==    at 0x4C2C291: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==2864==    by 0x108BA8: Room::~Room() (41120443.cpp:15)\n==2864==    by 0x108D67: World::~World() (41120443.cpp:68)\n==2864==    by 0x108B65: main (41120443.cpp:75)\n==2864== \n==2864== Invalid free() / delete / delete[] / realloc()\n==2864==    at 0x4C2C2DB: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==2864==    by 0x108BC3: Room::~Room() (41120443.cpp:17)\n==2864==    by 0x108D67: World::~World() (41120443.cpp:68)\n==2864==    by 0x108B65: main (41120443.cpp:75)\n==2864==  Address 0x5a82e00 is 0 bytes inside a block of size 16 free'd\n==2864==    at 0x4C2C2DB: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==2864==    by 0x108BA8: Room::~Room() (41120443.cpp:15)\n==2864==    by 0x108D67: World::~World() (41120443.cpp:68)\n==2864==    by 0x108B65: main (41120443.cpp:75)\n==2864==  Block was alloc'd at\n==2864==    at 0x4C2B21F: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==2864==    by 0x108CCE: World::World() (41120443.cpp:63)\n==2864==    by 0x108B54: main (41120443.cpp:75)\n</code></pre>\n<p>You could make life much easier for yourself with judicious use of smart pointers:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;set&gt;\n\nclass Door; // Forward declaration\n\nstruct Room {\n    std::shared_ptr&lt;Door&gt; door1 = {};\n    std::shared_ptr&lt;Door&gt; door2 = {};\n\n    ~Room();\n};\n\nstruct Door {\n    const std::weak_ptr&lt;Room&gt; roomA;\n    const std::weak_ptr&lt;Room&gt; roomB;\n\n    Door(std::shared_ptr&lt;Room&gt; roomA, std::shared_ptr&lt;Room&gt; roomB)\n        : roomA(roomA),\n          roomB(roomB)\n    {\n        roomA-&gt;door1 = roomB-&gt;door1 = std::shared_ptr&lt;Door&gt;{this};\n    }\n\n    ~Door() = default;\n};\n\n// Now that Door is complete, we can define ~Room\nRoom::~Room() = default;\n\nstruct World {\n    std::set&lt;std::shared_ptr&lt;Room&gt;&gt; rooms = {};\n\n    World() {\n        // Set up two rooms and link them using a door\n        auto newRoom = std::make_shared&lt;Room&gt;();\n        rooms.insert(newRoom);\n        auto anotherNewRoom = std::make_shared&lt;Room&gt;();\n        rooms.insert(anotherNewRoom);\n\n        new Door(newRoom, anotherNewRoom);\n    }\n\n    ~World() = default;\n};\n\nint main() {\n\n    World world;\n\n    return 0;\n}\n</code></pre>\n<p>This builds and runs cleanly:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -std=c++17 -fPIC -g -Wall -Wextra -Wwrite-strings -Wno-parentheses -Wpedantic -Warray-bounds -Weffc++      41120443.cpp    -o 41120443\nvalgrind  ./41120443 \n==3254== Memcheck, a memory error detector\n==3254== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==3254== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==3254== Command: ./41120443\n==3254== \n==3254== \n==3254== HEAP SUMMARY:\n==3254==     in use at exit: 0 bytes in 0 blocks\n==3254==   total heap usage: 7 allocs, 7 frees, 72,952 bytes allocated\n==3254== \n==3254== All heap blocks were freed -- no leaks are possible\n==3254== \n==3254== For counts of detected and suppressed errors, rerun with: -v\n==3254== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n</code></pre>\n", "OwnerUserId": "4850040", "PostTypeId": "2", "Id": "41126981", "Score": "2", "CreationDate": "2016-12-13T17:20:24.263", "LastActivityDate": "2016-12-13T17:20:24.263"}, "41120443": {"CommentCount": "14", "ViewCount": "169", "PostTypeId": "1", "LastEditorUserId": "6916748", "CreationDate": "2016-12-13T11:50:48.307", "LastActivityDate": "2016-12-13T17:20:24.263", "Title": "C++ Destructor is not called", "AcceptedAnswerId": "41125563", "LastEditDate": "2016-12-13T15:51:21.743", "Id": "41120443", "Score": "0", "Body": "<p>I've got three classes: Room, Door and World</p>\n<pre><code>#include &lt;set&gt;;\n\nusing namespace std;\n\nclass Door; // Forward declaration\n\nclass Room {\npublic:\n    Door* door1;\n    Door* door2;\n\n    Room(){}\n\n    ~Room() {\n        delete door1;\n        door1 = 0;\n        delete door2;\n        door2 = 0;\n    }\n};\n\nclass Door {\npublic:\n    Room* roomA;\n    Room* roomB;\n\n    Door(Room* roomA, Room* roomB) {\n        this-&gt;roomA = roomA;\n        this-&gt;roomB = roomB;\n        linkRooms(); // This sets up the Door-Pointers in the Rooms\n                     // so they know about the new door.\n    }    \n\n    ~Door() {\n        // Returns the room-owned pointer pointing at this door\n        getMyRoomPointer(roomA) = 0;\n        getMyRoomPointer(roomB) = 0;\n    }    \n\n    Door * &amp; getMyRoomPointer(Room * const &amp; room) {\n        if (room-&gt;door1 == this) return room-&gt;door1;\n        else return room-&gt;door2;\n    }\n\n    void linkRooms() {\n        roomA-&gt;door1 = this;\n        roomB-&gt;door2 = this;\n    }\n\n};\n\nclass World {\npublic:\n    std::set&lt;Room*&gt; rooms;\n\n    World() {\n        // Set up two rooms and link them using a door\n        Room* newRoom = new Room();\n        rooms.insert(newRoom);\n        Room* anotherNewRoom = new Room();\n        rooms.insert(anotherNewRoom);\n\n        new Door(newRoom, anotherNewRoom);\n    }\n    ~World() {\n        // Iterate over the rooms and call delete on all of them\n        for (std::set&lt;Room*&gt;::iterator it = rooms.begin(); it != rooms.end(); ++it) {\n            delete *it;\n        }\n    }\n};\n\nint main() {\n\n    World world;\n\n    return 0;\n}\n</code></pre>\n<p>When running main, the constructor fills the world with just two rooms and a door as a link between them. After main returns, world should be deleted and all the rooms and doors also should be taken care of.</p>\n<p>The thing is, that my Door destructor is never called. So the Door pointers inside the rooms are not set to null and I get an error when the room \"at the other side\" tries to delete the same door.</p>\n<p>When I just create an instance of Door, and than delete it right afterwards, I'm not facing any problems:</p>\n<pre><code>int main(){\n\n    Room oneRoom;\n    Room anotherRoom;\n\n    Door* door = new Door(&amp;oneRoom, &amp;anotherRoom);\n    delete door; // works just fine\n\n    return 0;\n}\n</code></pre>\n<p>Questions: <strong>Why is the Door constructor not called? Is setting up Door like in the first example allowed?</strong></p>\n<p>I know, that I'm double deleting my room's Door pointers, and that I could (and should) use SmartPointers. Right now I'm just wondering why I am facing that kind of behavior. I'm still new  to  C++, after all.</p>\n<p>I did set up a runnable example now, that reproduces the error.</p>\n", "Tags": "<c++><destructor><dynamic-allocation>", "OwnerUserId": "6916748", "AnswerCount": "3"}, "41125563": {"ParentId": "41120443", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You call <code>delete</code> before <code>Door</code> has been defined. Therefore the behaviour of the program is undefined, and the destructor is not guaranteed to be called.</p>\n<p>A quote from the standard (draft) <a href=\"http://eel.is/c++draft/expr.delete#5\" rel=\"nofollow noreferrer\">[expr.delete]</a>:</p>\n<blockquote id=\"so_41120443_41125563_0\">\n<ol start=\"5\">\n<li>If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</li>\n</ol>\n</blockquote>\n<p>Solution: If the destructor of the type is non-trivial (i.e. user defined, such as the <code>~Door</code>, then never delete such object until the type is complete). In this case, define <code>Door</code>, before the functions that call delete.</p>\n<p>As a general rule, you can never call a member function unless the class type is complete. Unfortunately in the case of destructor, it may not always be possible for the compiler to catch the bug. PS. g++ does warn about your program: <code>warning: possible problem detected in invocation of delete operator: [-Wdelete-incomplete]</code></p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-12-13T16:41:03.437", "Id": "41125563", "Score": "3", "CreationDate": "2016-12-13T16:09:14.617", "LastActivityDate": "2016-12-13T16:41:03.437"}, "bq_ids": {"n4140": {"so_41120443_41125563_0": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_41120443_41125563_0": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_41120443_41125563_0": {"section_id": 7606, "quality": 1.0, "length": 16}}}});