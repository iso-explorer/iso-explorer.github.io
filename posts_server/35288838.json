post_cb({"35290352": {"ParentId": "35288838", "CommentCount": "0", "CreationDate": "2016-02-09T11:03:33.637", "OwnerUserId": "643393", "PostTypeId": "2", "Id": "35290352", "Score": "1", "Body": "<p>According to the standard[3.5/2]:</p>\n<blockquote>\n<p id=\"so_35288838_35290352_0\">When a name has <strong>external linkage</strong> , the entity it denotes can be\n  referred to by names from scopes of other translation units or from\n  other scopes of the same translation unit</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_35288838_35290352_1\">When a name has <strong>internal linkage</strong> , the entity it denotes can be\n  referred to by names from other scopes in the same translation unit.</p>\n</blockquote>\n<p>So basically if you can refer to something in a translation unit different from the one where this something has been defined then it has external linkage, otherwise it has internal linkage. So given the note from the question:</p>\n<blockquote>\n<p id=\"so_35288838_35290352_2\">Although entities in an unnamed namespace might have external linkage,\n  they are effectively qualified by a name unique to their translation\n  unit and therefore can never be seen from any other translation unit.</p>\n</blockquote>\n<p>We practically have a situation in which we have a name but we don't know it, hence no matter how hard we try we can't refer to it from the different translation unit. And it makes it indistinguishable from the one with internal linkage. So, in my opinion it is just a word juggling \u2014 if you can't distinguish one situation from another then they are the same.</p>\n", "LastActivityDate": "2016-02-09T11:03:33.637"}, "35288838": {"CommentCount": "4", "ViewCount": "367", "CreationDate": "2016-02-09T09:54:34.710", "LastActivityDate": "2016-02-09T12:14:00.393", "Title": "External linkage for name inside unnamed namespace", "AcceptedAnswerId": "35291419", "PostTypeId": "1", "Id": "35288838", "Score": "3", "Body": "<p>According to the clause 3.5/4 of C++ Standard:</p>\n<blockquote>\n<p id=\"so_35288838_35288838_0\">An unnamed namespace or a namespace declared directly or indirectly\n  within an unnamed namespace has internal linkage.</p>\n</blockquote>\n<p>Simultanously in paragraph 7.3.1.1 we have note 96):</p>\n<blockquote>\n<p id=\"so_35288838_35288838_1\">Although entities in an unnamed namespace might have external linkage,\n  they are effectively qualified by a name unique to their translation\n  unit and therefore can never be seen from any other translation unit.</p>\n</blockquote>\n<p>How to explicitly make external linkage for name inside unnamed namespace and how to check that linkage is actually external if Standard guaranteed that there is no way to access name defined inside unnamed namespace from another translation unit?</p>\n<p>In which cases doing explicit external linkage for name inside unnamed namespace is useful?</p>\n", "Tags": "<c++><c++14><unnamed-namespace>", "OwnerUserId": "3240681", "AnswerCount": "3"}, "35291419": {"ParentId": "35288838", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-02-09T11:53:41.363", "Score": "2", "LastEditorUserId": "981959", "LastEditDate": "2016-02-09T12:14:00.393", "Id": "35291419", "OwnerUserId": "981959", "Body": "<blockquote>\n<p id=\"so_35288838_35291419_0\">How to explicitly make external linkage for name inside unnamed namespace</p>\n</blockquote>\n<p>The only way I can think of is to give it C language linkage, so that its linkage name ignores the namespace qualification:</p>\n<pre><code>namespace {\n  extern void f() { }      // has internal linkage despite 'extern'\n  extern \"C\" void g() { }  // ignores linkage of namespace\n}\nvoid (*p)() = f;  // ensure 'f' won't be optimized away\n</code></pre>\n<p>(A strict reading of the standard suggests that <code>g</code> should have internal linkage, but that's not what compilers seem to do.)</p>\n<blockquote>\n<p id=\"so_35288838_35291419_1\">and how to check that linkage is actually external if Standard guaranteed that there is no way to access name defined inside unnamed namespace from another translation unit?</p>\n</blockquote>\n<p>Typically ELF compilers will implement internal linkage with non-global symbols, so you can compile the code and inspect the object file:</p>\n<pre><code>$ g++ -c linkage.cc\n$ nm linkage.o\n0000000000000000 t _ZN12_GLOBAL__N_11fEv\n0000000000000007 T g\n0000000000000000 D p\n</code></pre>\n<p>The mangled name of the unnamed namespace can vary between compilers, but demangling it will show:</p>\n<pre><code>$ nm -C  linkage.o\n0000000000000008 t (anonymous namespace)::f()\n0000000000000000 T g\n0000000000000000 D p\n</code></pre>\n<p>The lowercase <code>t</code> shows that <code>f</code> has local visibility, meaning it can't be linked to from other object files. The uppercase <code>T</code> shows that <code>g</code> has external linkage.</p>\n<p>This isn't guaranteed by the standard though, as ELF visibility is not part of the C++ standard, and some compilers implement linkage without using visibility even on ELF platforms, e.g. the EDG compiler produces a global symbol for the same code:</p>\n<pre><code>$ nm linkage.o\n0000000000000008 T _ZN23_GLOBAL__N__7_link_cc_p1fEv\n0000000000000004 C __EDGCPFE__4_9\n0000000000000000 T g\n0000000000000000 D p\n$ nm -C linkage.o\n0000000000000008 T (anonymous namespace)::f()\n0000000000000004 C __EDGCPFE__4_9\n0000000000000000 T g\n0000000000000000 D p\n</code></pre>\n<p>So using <code>extern \"C\"</code> allows you to give a name external linkage even if it appears in an unnamed namespace, <strong>but</strong> that doesn't make the note correct, because you <em>can</em> refer to that name from other translation units, because it doesn't use the unnamed namespace scope. That suggests to me that the note is simply a leftover from C++03 when entities in unnamed namespaces didn't automatically have internal linkage, and the note should be corrected or removed (and indeed T.C. points out it was already removed by <a href=\"http://wg21.link/cwg1603\" rel=\"nofollow\">DR 1603</a>).</p>\n<blockquote>\n<p id=\"so_35288838_35291419_2\">In which cases doing explicit external linkage for name inside unnamed namespace is useful?</p>\n</blockquote>\n<p>I can't think of any cases where it's useful.</p>\n", "LastActivityDate": "2016-02-09T12:14:00.393"}, "bq_ids": {"n4140": {"so_35288838_35290352_0": {"section_id": 7135, "quality": 0.9444444444444444, "length": 17}, "so_35288838_35290352_2": {"section_id": 5482, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35289169_1": {"section_id": 7137, "quality": 0.9692307692307692, "length": 63}, "so_35288838_35288838_0": {"section_id": 7137, "quality": 1.0, "length": 11}, "so_35288838_35289169_2": {"section_id": 5482, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35288838_1": {"section_id": 5482, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35290352_1": {"section_id": 7135, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_35288838_35290352_0": {"section_id": 6879, "quality": 0.9444444444444444, "length": 17}, "so_35288838_35288838_0": {"section_id": 6881, "quality": 1.0, "length": 11}, "so_35288838_35289169_1": {"section_id": 6881, "quality": 0.9692307692307692, "length": 63}, "so_35288838_35289169_2": {"section_id": 5268, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35290352_2": {"section_id": 5268, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35288838_1": {"section_id": 5268, "quality": 0.9565217391304348, "length": 22}, "so_35288838_35290352_1": {"section_id": 6879, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_35288838_35290352_0": {"section_id": 8636, "quality": 0.9444444444444444, "length": 17}, "so_35288838_35288838_0": {"section_id": 8638, "quality": 1.0, "length": 11}, "so_35288838_35289169_1": {"section_id": 8638, "quality": 0.9076923076923077, "length": 59}, "so_35288838_35290352_1": {"section_id": 8636, "quality": 0.9285714285714286, "length": 13}}}, "35289169": {"ParentId": "35288838", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-02-09T10:08:33.140", "Score": "3", "LastEditorUserId": "464581", "LastEditDate": "2016-02-09T12:00:02.670", "Id": "35289169", "OwnerUserId": "464581", "Body": "<p>Re</p>\n<blockquote>\n<p id=\"so_35288838_35289169_0\"><strong>\u201d</strong> In which cases doing explicit external linkage for name inside unnamed namespace is useful?</p>\n</blockquote>\n<p>The need for external linkage was important for C++03 templates. E.g. a function pointer as template argument had to be a pointer to function of external linkage. For example, the following would not compile with a C++03 compiler:</p>\n<pre><code>template&lt; void(*f)() &gt;\nvoid tfunc() { f(); }\n\n#include &lt;stdio.h&gt;\nstatic void g() { printf( \"Hello!\\n\" ); }\n\nint main()\n{\n    tfunc&lt;g&gt;();\n}\n</code></pre>\n<p>It compiles fine with a C++11 compiler.</p>\n<p><del>So, with C++11 the anonymous namespace mechanism for having external linkage yet no name conflicts between translation units, is only technically necessary for classes. A class has external linkage. One wouldn't want to have to choose class names that guaranteed did not occur in other translation units.</del></p>\n<p>With C++11 <strong>the rules changed</strong> not only for template parameters, but for whether things in an anonymous namespace have external linkage or not. With C++03 an anonymous namespace had formally external linkage, possibly unless it is itself within an anonymous namespace (C++03 \u00a73.5/4 last dash + C++03 \u00a77.3.1.1/1). With C++11 an anonymous namespace has formally internal linkage.</p>\n<p>This does not matter to the linker, because there's no linking of namespaces, but it matters as a formal device to describe linkage of things:</p>\n<i>C++11 \u00a73.5/4:</i>\n<blockquote>\n<p id=\"so_35288838_35289169_1\"><strong>\u201d</strong> An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. All other namespaces have external linkage. A name having namespace scope that has not\n  been given internal linkage above has the same linkage as the enclosing namespace if it is the name of<br>\n  \u2014 a variable; or<br>\n  \u2014 a function; or<br>\n  \u2014 a named class (Clause 9), or an unnamed class defined in a <code>typedef</code> declaration in which the class has  the <code>typedef</code> name for linkage purposes (7.1.3); or<br>\n  \u2014 a named enumeration (7.2), or an unnamed enumeration defined in a <code>typedef</code> declaration in which the enumeration has the typedef name for linkage purposes (7.1.3); or<br>\n  \u2014 an enumerator belonging to an enumeration with linkage; or<br>\n  \u2014 a template.</br></br></br></br></br></br></p>\n</blockquote>\n<hr>\n<p>Before going on to your other questions, it's worth noting that this quote from the standard,</p>\n<blockquote>\n<p id=\"so_35288838_35289169_2\"><strong>\u201d</strong> Although entities in an unnamed namespace might have external linkage, they are effectively qualified by a name unique to their translation unit and therefore can never be seen from any other translation unit.</p>\n</blockquote>\n<p>is plain <strong>wrong</strong>, because an <code>extern \"C\"</code> entity is visible from other translation units regardless of what namespace it's declared in.</p>\n<p>Happily, as I recall, notes are non-normative, i.e. they do not define the language.</p>\n<hr>\n<p>Re</p>\n<blockquote>\n<p id=\"so_35288838_35289169_3\"><strong>\u201d</strong> How to explicitly make external linkage for name inside unnamed namespace</p>\n</blockquote>\n<p><del>just declare a non-<code>const</code> variable, or a function, as <code>extern</code>.</del>\nyou can declare a non-<code>const</code> variable, or a function, as <code>extern \"C\"</code>, making the linkage extern but at the same time making the namespaces irrelevant as far as linking is concerned: the C language doesn't have them.</p>\n<pre><code>namespace {\n    extern \"C\" void foo() {}    // Extern linkage\n}  // namespace &lt;anon&gt;\n\nvoid bar() {}  // Also extern linkage, but visible to other TUs.\n</code></pre>\n<hr>\n<p>Re</p>\n<blockquote>\n<p id=\"so_35288838_35289169_4\"><strong>\u201d</strong>  how to check that linkage is actually external</p>\n</blockquote>\n<p>well, the linkage affects things like possible conflicts with the One Definition Rule, often abbreviated as the \u201c<strong>ODR</strong>\u201d, which in C++11 is \u00a73.2.</p>\n<p>So, one way to see the linkage in action is to link two object files generated from the above source, as if you had two translation units with that same source code:</p>\n<pre>\nC:\\my\\forums\\so\\088&gt; <b><i>g++ -c anon.cpp -o x.o &amp; g++ -c anon.cpp -o y.o</i></b>\n\nC:\\my\\forums\\so\\088&gt; <b><i>g++ main.cpp x.o y.o</i></b>\ny.o:anon.cpp:(.text+0x0): multiple definition of `foo'\nx.o:anon.cpp:(.text+0x0): first defined here\ny.o:anon.cpp:(.text+0x7): multiple definition of `bar()'\nx.o:anon.cpp:(.text+0x7): first defined here\ncollect2.exe: error: ld returned 1 exit status\n\nC:\\my\\forums\\so\\088&gt; _\n</pre>\n<p>The linker complains about multiple definitions of <code>foo</code>, because as with C language binding it appears, as far as the linker is concerned, as a non-<code>inline</code> external linkage member of the global namespace, with two (possibly conflicting) definitions.</p>\n</hr></hr></hr>", "LastActivityDate": "2016-02-09T12:00:02.670"}});