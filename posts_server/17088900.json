post_cb({"17088900": {"CommentCount": "13", "ViewCount": "664", "ClosedDate": "2013-06-14T08:31:21.880", "CreationDate": "2013-06-13T13:55:56.813", "LastActivityDate": "2014-09-18T14:30:26.553", "PostTypeId": "1", "FavoriteCount": "0", "Title": "Implementation of std::min", "Id": "17088900", "Score": "4", "Body": "<p>The implementation of <code>std::min</code> on <a href=\"http://en.cppreference.com/w/cpp/algorithm/min\" rel=\"nofollow\">cppreference</a> and in the <a href=\"http://www.sgi.com/tech/stl/stl_algobase.h\" rel=\"nofollow\">original stl</a> looks like this:</p>\n<pre><code>return (b &lt; a) ? b : a;\n</code></pre>\n<p>But I think this is slightly more readable:</p>\n<pre><code>return (a &lt; b) ? a : b;\n</code></pre>\n<p>Which makes me wonder: are both implementations equivalent? Is there a particular reason why it is implemented like it is?</p>\n", "Tags": "<c++>", "OwnerUserId": "75889", "AnswerCount": "3"}, "17089637": {"ParentId": "17088900", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>-- INCORRECT ANSWER -- SEE COMMENTS -- bb</p>\n<p>FWIW, it hasn't been my observation that STL was written to be especially easy to read, necessarily, but it's beautifully simple; in this case, the only other possible way to get the same result would be </p>\n<pre><code>return (a &lt;= b) ? a : b;\n</code></pre>\n<p>which would be one more character, and, IMHO, actually not as easy to read.  Additionally, see @Shahbaz 's commentary above on sort stability--operations like min have a well-defined behavior for inclusivity and exclusivity. </p>\n<p>TL;DR because \"Less than\" is not the same as \"Less than or equal to\"</p>\n<p>See comments below--this answer would be correct as a macro in C but actually is incorrect in C++ for reasons explained in the comments below.  I'm marking this as incorrect but leaving it up because the comments are useful and important to understand.  I apologize if I confused the issue for anyone.</p>\n", "OwnerUserId": "1178664", "LastEditorUserId": "1178664", "LastEditDate": "2013-06-13T16:21:01.050", "Id": "17089637", "Score": "-1", "CreationDate": "2013-06-13T14:26:58.687", "LastActivityDate": "2013-06-13T16:21:01.050"}, "17088980": {"ParentId": "17088900", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The implementations are not the same.  What will happen in either implementation if a and b are equal?  One will return a reference to a one will return a reference to b.  The values of course are identical.  But consider a struct in which the compare function only cared about one value, but some other values were different.  This could have dramatic implications on sorting functions attempting to guarantee a stable sort.</p>\n<p>Ultimately it's a style choice, in the event of equality should we return the first or second parameter?  However, now that this style choice has been made, that it remains the same is very important, this is why things like standards definitions exist!  </p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>\n<p>Search for \"25.4.7\" regarding maximum and minimum.</p>\n", "OwnerUserId": "1467304", "LastEditorUserId": "1467304", "LastEditDate": "2013-06-13T14:40:30.717", "Id": "17088980", "Score": "4", "CreationDate": "2013-06-13T13:59:08.650", "LastActivityDate": "2013-06-13T14:40:30.717"}, "bq_ids": {"n4140": {"so_17088900_17088983_2": {"section_id": 1490, "quality": 0.9, "length": 9}, "so_17088900_17088983_1": {"section_id": 1487, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_17088900_17088983_2": {"section_id": 1484, "quality": 0.9, "length": 9}, "so_17088900_17088983_1": {"section_id": 1481, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_17088900_17088983_2": {"section_id": 1631, "quality": 0.9, "length": 9}, "so_17088900_17088983_1": {"section_id": 1627, "quality": 0.8571428571428571, "length": 6}}}, "17088983": {"ParentId": "17088900", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The two different implementations would determine whether you choose the first or the second object as minimum if they are equal, which may make a difference for objects, if not for primitive types.</p>\n<p>This, coupled with implementation of some other algorithms could have a larger impact. For example, if a sort algorithm uses <code>min(a[i], a[j])</code> where <code>i &lt; j</code> and <code>a[i]</code> and <code>a[j]</code> have the same value, the first implementation would result in no swap between the elements while the second does, making the sort unstable.</p>\n<hr>\n<p>Note: As <a href=\"https://stackoverflow.com/questions/17088900/implementation-of-stdmin/17089637#comment24719041_17088900\">BoBTFish</a> mentioned, the C++11 standard guarantees that both min and max return the left most minimum:</p>\n<blockquote>\n<p id=\"so_17088900_17088983_0\">25.4.7:</p>\n<p id=\"so_17088900_17088983_1\">3 <em>Remarks:</em> Returns the first argument when the arguments are equivalent</p>\n<p id=\"so_17088900_17088983_2\">6 <em>Remarks:</em> Returns a copy of the leftmost argument when several arguments are equivalent to the smallest</p>\n</blockquote>\n</hr>", "OwnerUserId": "912144", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:58.643", "Id": "17088983", "Score": "6", "CreationDate": "2013-06-13T13:59:16.107", "LastActivityDate": "2014-09-18T14:30:26.553"}});