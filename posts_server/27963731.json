post_cb({"27963731": {"CommentCount": "3", "ViewCount": "230", "PostTypeId": "1", "LastEditorUserId": "2684539", "CreationDate": "2015-01-15T12:41:48.650", "LastActivityDate": "2015-01-15T13:21:35.607", "Title": "Template class copy constructor not called", "AcceptedAnswerId": "27963942", "LastEditDate": "2015-01-15T13:21:35.607", "Id": "27963731", "Score": "2", "Body": "<p>My copy constructor is not being called and I'm not sure why. Here's my code:</p>\n<pre><code>template &lt;typename T&gt;\nclass SmartPtr\n{\n    public:\n        explicit SmartPtr(T *p) : m_p(p) { cout &lt;&lt; \"ctor\" &lt;&lt; endl; }\n        SmartPtr(const SmartPtr&amp; p) : m_p(p.m_p) { cout &lt;&lt; \"copy ctor\" &lt;&lt; endl;}\n\n    private:\n        T* m_p;\n};\n\nint main()\n{\n    SmartPtr&lt;int&gt; pt4 = SmartPtr&lt;int&gt;(new int);\n}\n</code></pre>\n<p>The output is only \"ctor\". It looks like a default copy constructor is used. If I add \"explicit\" then it doesn't compile, giving the error:</p>\n<pre><code>\"error: no matching function for call to \u2018SmartPtr&lt;int&gt;::SmartPtr(SmartPtr&lt;int&gt;)\u2019\"\n</code></pre>\n<p>What am I doing wrong here?</p>\n", "Tags": "<c++><templates><copy-constructor><copy-elision>", "OwnerUserId": "663301", "AnswerCount": "1"}, "27963942": {"ParentId": "27963731", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is what is known as <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow\">Copy Elision</a>. It's a nice optimization where a copy clearly isn't necessary. Instead of effectively running the code:</p>\n<pre><code>SmartPtr&lt;int&gt; __tmp(new int);\nSmartPtr&lt;int&gt; ptr4(__tmp);\n__tmp.~SmartPtr&lt;int&gt;();\n</code></pre>\n<p>The compiler can know that <code>__tmp</code> only exists to construct <code>ptr4</code>, and thus is allowed to construct <code>__tmp</code> in-place in the memory owned by <code>ptr4</code> <strong>as if</strong> the actual code originally run was just:</p>\n<pre><code>SmartPtr&lt;int&gt; ptr4(new int);\n</code></pre>\n<p>Note that you can tell the compiler NOT to do this too. For instance, on gcc, you can pass the <code>-fno-elide-constructors</code> option and with that single change (additionally logging the destructor), now your code prints:</p>\n<pre><code>ctor\ncopy ctor // not elided!\ndtor      \ndtor      // extra SmartPtr!\n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/73df213e68f5463b\" rel=\"nofollow\">demo</a>.</p>\n<p>In the standard, \u00a712.8:</p>\n<blockquote>\n<p id=\"so_27963731_27963942_0\">This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>In a <code>return</code> statement in a function with a class return type, when ...</li>\n<li>In a <em>throw-expression</em>, when ...</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</li>\n<li>when the <em>exception-declaration</em> of an exception handler (Clause 15) ...</li>\n</ul>\n<p id=\"so_27963731_27963942_1\">[<em>Example:</em></p>\n<pre><code>class Thing {\npublic:\n    Thing();\n    ~Thing();\n    Thing(const Thing&amp;);\n};\n\nThing f() {\n    Thing t;\n    return t;\n}\n\nThing t2 = f();\n</code></pre>\n<p id=\"so_27963731_27963942_2\">Here the criteria for elision can be combined to eliminate two calls to the copy constructor of class <code>Thing</code>:\n  the copying of the local automatic object t into the temporary object for the return value of function <code>f()</code>\n  and the copying of that temporary object into object <code>t2</code>. Effectively, the construction of the local object <code>t</code>\n  can be viewed as directly initializing the global object <code>t2</code>, and that object\u2019s destruction will occur at program\n  exit. Adding a move constructor to Thing has the same effect, but it is the move construction from the\n  temporary object to <code>t2</code> that is elided. <em>\u2014end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-15T13:11:50.190", "Id": "27963942", "Score": "1", "CreationDate": "2015-01-15T12:53:17.713", "LastActivityDate": "2015-01-15T13:11:50.190"}, "bq_ids": {"n4140": {"so_27963731_27963942_0": {"section_id": 480, "quality": 0.9333333333333333, "length": 14}, "so_27963731_27963942_2": {"section_id": 480, "quality": 0.9642857142857143, "length": 54}}, "n3337": {"so_27963731_27963942_0": {"section_id": 471, "quality": 0.9333333333333333, "length": 14}, "so_27963731_27963942_2": {"section_id": 471, "quality": 0.9642857142857143, "length": 54}}, "n4659": {"so_27963731_27963942_0": {"section_id": 502, "quality": 0.9333333333333333, "length": 14}, "so_27963731_27963942_2": {"section_id": 503, "quality": 0.6964285714285714, "length": 39}}}});