post_cb({"38538983": {"Id": "38538983", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:08:08.997", "CommentCount": "0", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-23T07:04:30.293", "CreationDate": "2016-07-23T06:43:16.433", "ParentId": "38538855", "Score": "13", "Body": "<p>For (1), consider that it ensures that both the no-arg constructor <code>unique_ptr()</code> and null-pointer constructor <code>unique_ptr(nullptr_t)</code> have the same compile-time guarantees, i.e. both are <code>constexpr</code>. We can see the difference in \u00a720.8.1.2:</p>\n<pre><code>constexpr unique_ptr() noexcept;\nexplicit unique_ptr(pointer p) noexcept;\n...\nconstexpr unique_ptr(nullptr_t) noexcept\n: unique_ptr() { }\n</code></pre>\n<p>Why the two were not combined into a single constructor with a default value is likely historical contingency.</p>\n<p>With regards to (2), why we should care about <code>constexpr</code> despite having a non-trivial destructor, consider <a href=\"https://stackoverflow.com/a/30766445/591495\">the answer given here</a>:</p>\n<blockquote>\n<p id=\"so_38538855_38538983_0\"><code>constexpr</code> constructors can be used for constant initialization, which, as a form of static initialization, is guaranteed to happen before any dynamic initialization takes place.</p>\n<p id=\"so_38538855_38538983_1\">For example, given a global <code>std::mutex</code>:</p>\n<pre><code>std::mutex mutex;\n</code></pre>\n<p id=\"so_38538855_38538983_2\">In a conforming implementation (read: not MSVC), constructors of other objects can safely lock and unlock <code>mutex</code>, becuase <code>std::mutex</code>'s constructor is <code>constexpr</code>.</p>\n</blockquote>\n", "OwnerUserId": "591495"}, "bq_ids": {"n4140": {"so_38538855_38538983_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 7151}}, "n4659": {"so_38538855_38538983_0": {"length": 9, "quality": 0.6, "section_id": 8652}}}, "38538855": {"ViewCount": "1017", "LastEditDate": "2016-08-01T07:54:04.457", "AcceptedAnswerId": "38538983", "Title": "std::unique_ptr constexpr constructors", "CreationDate": "2016-07-23T06:23:43.260", "LastActivityDate": "2016-08-01T07:54:04.457", "CommentCount": "3", "Body": "<p>As shown <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr\" rel=\"nofollow\">here</a>, <code>std::unique_ptr</code> has two <code>constexpr</code> constructors for null pointers:</p>\n<pre><code>constexpr unique_ptr();\nconstexpr unique_ptr( nullptr_t );\n</code></pre>\n<p>I have two questions for these two constructors:</p>\n<ol>\n<li><p>Why do we need two? Can't we just declare one as:</p>\n<pre><code>constexpr unique_ptr( nullptr_t = nullptr );\n</code></pre></li>\n<li><p>Is the <code>constexpr</code> really useful? I tried doing this in my code but it didn't compile (g++ 6.1.0, <code>-std=c++14</code>):</p>\n<pre><code>constexpr std::unique_ptr&lt;int&gt; p;\n// error: the type 'const std::unique_ptr&lt;int&gt;' of constexpr variable 'p'\n// is not literal because 'std::unique_ptr&lt;int&gt;' has a non-trivial destructor\n</code></pre></li>\n</ol>\n", "PostTypeId": "1", "LastEditorUserId": "4850040", "Id": "38538855", "Score": "13", "OwnerUserId": "3234803", "Tags": "<c++><c++11><c++14>", "AnswerCount": "2"}, "38539123": {"Id": "38539123", "PostTypeId": "2", "Body": "<p>As to Q1, the <code>nullptr_t</code> constructor was added later in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm\">N2435</a>, well after the original proposal (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html\">N1586</a>).</p>\n<p>Adding a simple overload that can be specified in one line is much cleaner than trying to be clever, especially as [member.functions] already allows the implementation to use the \"clever\" version if they want.</p>\n", "Score": "9", "LastActivityDate": "2016-07-23T07:01:50.933", "CreationDate": "2016-07-23T07:01:50.933", "ParentId": "38538855", "CommentCount": "1", "OwnerUserId": "2756719"}});