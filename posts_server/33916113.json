post_cb({"bq_ids": {"n4140": {"so_33916113_33916186_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 6133}, "so_33916113_33916186_8": {"length": 4, "quality": 0.5714285714285714, "section_id": 500}, "so_33916113_33916186_1": {"length": 7, "quality": 0.7, "section_id": 6137}, "so_33916113_33923241_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 500}, "so_33916113_33916186_6": {"length": 17, "quality": 0.7727272727272727, "section_id": 6185}, "so_33916113_33916186_5": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_33916113_33916186_7": {"length": 6, "quality": 0.6, "section_id": 5464}, "so_33916113_33916180_1": {"length": 30, "quality": 0.7142857142857143, "section_id": 5768}, "so_33916113_33916186_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 5768}}, "n3337": {"so_33916113_33916186_8": {"length": 4, "quality": 0.5714285714285714, "section_id": 491}, "so_33916113_33916186_1": {"length": 7, "quality": 0.7, "section_id": 5901}, "so_33916113_33923241_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 491}, "so_33916113_33916186_7": {"length": 8, "quality": 0.8, "section_id": 5946}, "so_33916113_33916180_1": {"length": 30, "quality": 0.7142857142857143, "section_id": 5541}, "so_33916113_33916186_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 5541}}, "n4659": {"so_33916113_33916186_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 7630}, "so_33916113_33916186_8": {"length": 4, "quality": 0.5714285714285714, "section_id": 502}, "so_33916113_33916186_1": {"length": 7, "quality": 0.7, "section_id": 7634}, "so_33916113_33923241_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 521}, "so_33916113_33916186_6": {"length": 17, "quality": 0.7727272727272727, "section_id": 7687}, "so_33916113_33916186_5": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_33916113_33916186_7": {"length": 6, "quality": 0.6, "section_id": 6898}, "so_33916113_33916180_1": {"length": 30, "quality": 0.7142857142857143, "section_id": 7225}, "so_33916113_33916186_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 7225}}}, "33923241": {"Id": "33923241", "PostTypeId": "2", "Body": "<p>The mere presence of <code>1 / 0</code> does not permit the compiler to crash. At most, it is permitted to assume that the expression will never be evaluated, and thus, that execution will never reach the given line.</p>\n<p>If the expression is guaranteed to be evaluated, the standard imposes no requirements on the program or compiler. <em>Then</em> the compiler can crash.</p>\n<h3>1 / 0 is only UB if evaluated.</h3>\n<p>The C11 standard gives an <a href=\"http://port70.net/~nsz/c/c11/n1570.html#note118\">explicit example</a> of <code>1 / 0</code> being defined behavior when unevaluated:</p>\n<blockquote>\n<p id=\"so_33916113_33923241_0\">Thus, in the following initialization,</p>\n<pre><code>        static int i = 2 || 1 / 0;\n</code></pre>\n<p id=\"so_33916113_33923241_1\">the expression is a valid integer constant expression with value one.</p>\n</blockquote>\n<p>Section 6.6, footnote 118.</p>\n<h3>1 / 0 is not a constant expression.</h3>\n<p><a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.6\">Section 6.6</a> of the C11 standard, under Constraints, says</p>\n<blockquote id=\"so_33916113_33923241_2\">\n<ol start=\"3\">\n<li>Constant expressions shall not contain assignment, increment, decrement, function-call, or comma operators, except when they are contained within a subexpression that is not evaluated.</li>\n<li><strong>Each constant expression shall evaluate to a constant that is in the range of representable values for its type.</strong></li>\n</ol>\n</blockquote>\n<p>Since 1/0 does not evaluate to a constant in the range of values representable by an int, 1/0 is not a constant expression. This is a rule about what counts as a constant expression, like the rule about not having assignments in it. You can see that at least for C++, <a href=\"http://melpon.org/wandbox/permlink/3PTo6hKwjVjCufcX\">Clang doesn't consider 1/0 a constant expression</a>:</p>\n<pre><code>prog.cc:3:18: error: constexpr variable 'x' must be initialized by a constant expression\n   constexpr int x = 1/ 0 ;\n                 ^   ~~~~\n</code></pre>\n<h3>It wouldn't make much sense for an unevaluated 1 / 0 to be UB.</h3>\n<p><code>(x == 0) ? x : 1 / x</code> is perfectly well-defined, even if x is 0 and evaluating 1/x is UB. If it were the case that <code>(0 == 0) ? 0 : 1 / 0</code> were UB, that would be nonsense.</p>\n", "LastEditorUserId": "2357112", "LastActivityDate": "2015-11-26T18:57:20.117", "Score": "21", "CreationDate": "2015-11-25T17:49:22.493", "ParentId": "33916113", "CommentCount": "4", "OwnerUserId": "2357112", "LastEditDate": "2015-11-26T18:57:20.117"}, "33916180": {"Id": "33916180", "PostTypeId": "2", "Body": "<p>From C standard draft (N1570):</p>\n<blockquote>\n<h3>6.5.5 Multiplicative operators</h3>\n<p id=\"so_33916113_33916180_0\">...</p>\n<ol start=\"5\">\n<li>The result of the / operator is the quotient from the division of the first operand by the\n  second; the result of the % operator is the remainder. In both operations, <strong>if the value of\n  the second operand is zero, the behavior is undefined.</strong></li>\n</ol>\n</blockquote>\n<p>And about undefined behaviour in chapter 3. Terms, definitions, and symbols:</p>\n<blockquote id=\"so_33916113_33916180_1\">\n<h3>3.4.3</h3>\n<ol>\n<li>undefined behavior<br>\n  behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirements</br></li>\n<li>NOTE  Possible undefined behavior ranges from ignoring the situation completely with unpredictable\n  results, <strong>to behaving during translation</strong> or program execution <strong>in a documented manner characteristic of the\n  environment (with or without the issuance of a diagnostic message)</strong>, to terminating a translation or\n  execution (with the issuance of a diagnostic message).</li>\n</ol>\n</blockquote>\n<p>So crashing the compiler is allowed.</p>\n", "LastEditorUserId": "694733", "LastActivityDate": "2015-11-25T12:15:54.333", "Score": "15", "CreationDate": "2015-11-25T12:09:15.833", "ParentId": "33916113", "CommentCount": "4", "OwnerUserId": "694733", "LastEditDate": "2015-11-25T12:15:54.333"}, "33916113": {"ViewCount": "3274", "Body": "<p>My toy compiler crashes if I divide by zero in a constant expression:</p>\n<pre><code>int x = 1 / 0;\n</code></pre>\n<p>Is this behaviour allowed by the C and/or C++ standards?</p>\n", "AcceptedAnswerId": "33923241", "Title": "Dividing by zero in a constant expression", "CreationDate": "2015-11-25T12:06:00.760", "Id": "33916113", "CommentCount": "21", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-12-07T17:36:15.457", "Score": "39", "OwnerUserId": "252000", "Tags": "<c++><c><divide-by-zero><compile-time-constant><constant-expression>", "AnswerCount": "5"}, "34032876": {"Id": "34032876", "PostTypeId": "2", "Body": "<p>Others have already mentioned the relevant text from the standards, so, I'm not going to repeat that.</p>\n<p>My C compiler's expression evaluating function takes an expression in Reverse Polish Notation (array of values (numbers and identifiers) and operators) and returns two things: a flag for whether or not the expression evaluates to a constant and the value if it's a constant (0 otherwise). If the result is a constant, the whole RPN reduces to just that constant. 1/0 is not a constant expression since it doesn't evaluate to a constant integer value. The RPN is not reduced for 1/0 and stays intact.</p>\n<p>In C, static variables can be initialized with constant values only. So, the compiler errors out when it sees that an initializer for a static variable is not a constant. Variables of automatic storage can be initialized with non-constant expressions. In this case my compiler generates code to evaluate 1/0 (it still has the RPN for this expression!). If this code is reached at runtime, UB occurs as prescribed by the language standards. [On x86 this UB takes on the form of the division by zero CPU exception, while on MIPS this UB yields an incorrect quotient value (the CPU does not have a division by zero exception).]</p>\n<p>My compiler properly supports short-circuiting in ||-expressions and &amp;&amp;-expressions. So, it evaluates <code>1 || 1/0</code> as 1 and <code>0 &amp;&amp; 1/0</code> as 0, regardless of whether or not the right-hand operand of the logical operator is a constant. The expression evaluating function removes the right-hand operands of these operators (along with the operators) when they must not be evaluated and so <code>1 || 1/0</code> transforms into <code>1 != 0</code> (recall that the operands of &amp;&amp; and || undergo comparison with 0), which yields 1 and <code>0 &amp;&amp; 1/0</code> transforms into <code>0 != 0</code>, which yields 0.</p>\n<p>Another case to take care of is <code>INT_MIN / -1</code> and <code>INT_MIN % -1</code> (ditto for larger integer types). The quotient is not representable as a signed int (in the case of 2's complement signed integers, which is what we have in all modern CPUs) and so this is UB as well (you get the same division by zero exception on x86 at runtime). I handle this case similarly. This expression can't initialize a variable of static storage and it's thrown away if it's not evaluated in the logical &amp;&amp;/|| operator. It can initialize an automatic variable, possibly leading to UB at runtime.</p>\n<p>I also issue a warning when such division is encountered.</p>\n", "LastActivityDate": "2015-12-02T00:32:37.633", "CommentCount": "2", "CreationDate": "2015-12-02T00:32:37.633", "ParentId": "33916113", "Score": "2", "OwnerUserId": "968261"}, "33916186": {"Id": "33916186", "PostTypeId": "2", "Body": "<p>Yes, division by zero is undefined behavior and neither the C nor C++ standard impose any requirements in such cases. Although in this case I believe you should at least issue a diagnostic(<em>see below</em>).</p>\n<p>Before I go quoting the standards, I should note that although this may be conformant behavior <em>quality of implementation</em> is a different issue, being merely conforming is not the same as being useful. As far as I know the gcc, clang, Visual Studio and Intel(<em>as per tpg2114</em>) team consider internal compiler errors(<em>ICEs</em>) to be bugs that should be reported. It should be noted that both current gcc and clang produce a warning for this case seemingly regardless of flags provided. In the case where both operands are literals/constants, the case we have here, it seems rather straight forward to detect and provide a diagnostic for this. clang produces the following diagnostic for this case (<em><a href=\"http://coliru.stacked-crooked.com/a/231747f2a6ed74d6\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>warning: division by zero is undefined [-Wdivision-by-zero]\nint x = 1 / 0 ;\n          ^ ~\n</code></pre>\n<p>From the draft C11 standard section <code>6.5.5</code> Multiplicative operators (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33916113_33916186_0\">The result of the / operator is the quotient from the division of the first operand by the\n  second; [...] <strong>if the value of\n  the second operand is zero, the behavior is undefined.</strong></p>\n</blockquote>\n<p>and so it is undefined behavior.</p>\n<p>The draft C++ standard section <code>5.6</code> <em>[expr.mul]</em> says:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_1\">The binary / operator yields the quotient [...] <strong>If the second operand of / or % is zero the behavior is undefined</strong> [...]</p>\n</blockquote>\n<p>again undefined behavior.</p>\n<p>Both the draft C++ standard and draft C standard have a similar definition for undefined behavior both saying:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_2\">[...]for which this International Standard <strong>imposes no requirements</strong></p>\n</blockquote>\n<p>The phrase <em>imposes no requirements</em> seems too allow any behavior, including <a href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow noreferrer\">nasal demons</a>. Both have a similar note saying something along the lines of:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_3\">Undefined behavior may be expected when this International Standard omits any explicit definition of\n  behavior or when a program uses an erroneous construct or erroneous data. <strong>Permissible undefined behavior\n  ranges from ignoring the situation completely with unpredictable results</strong>, to behaving during translation or\n  program execution in a documented manner characteristic of the environment (with or without the issuance of\n  a diagnostic message), <strong>to terminating a translation or execution (with the issuance of a diagnostic message)</strong>.</p>\n</blockquote>\n<p>So although notes are not normative, it seems like if you are going to terminate during translation, you should at least issue a diagnostic. The term <em>terminating</em> is not defined, so it is hard to argue what this allows. I don't think I have seen a case where clang and gcc have an ICE without a diagnostic.</p>\n<p><b>Does the code have to be executed?</b></p>\n<p>If we read <a href=\"https://stackoverflow.com/q/18385020/1708801\">Can code that will never be executed invoke undefined behavior?</a> we can see at least in case of C there is room for debate where the <code>1 / 0</code> has to be executed in order to invoke undefined behavior. What is worse in the C++ case the definition of <em>behavior</em> is not present so part of the analysis used for the C case can not be used for the C++ case.</p>\n<p>It seems that if the compiler can prove the code will never be executed then we can reason that it would be <em>as-if</em> the program did not have undefined behavior but I don't think this is provable, just reasonable behavior.</p>\n<p>From the C perspective <a href=\"http://www.open-std.org/jtc1/sc22/wg14/docs/rr/dr_109.html\" rel=\"nofollow noreferrer\">WG14 defect report 109</a> further clarifies this. The following code example is given:</p>\n<pre><code>int foo()\n{\n  int i;\n  i = (p1 &gt; p2); /* Must this be \"successfully translated\"? */\n  1/0; /* Must this be \"successfully translated\"? */\n  return 0;\n} \n</code></pre>\n<p>and the response included:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_4\">Furthermore, if every possible execution of a given program would result in undefined behavior, the given program is not strictly conforming. \n  <br>A conforming implementation must not fail to translate a strictly conforming program simply because some possible execution of that program would result in undefined behavior. Because foo might never be called, the example given must be successfully translated by a conforming implementation. </br></p>\n</blockquote>\n<p>So in the case of C, unless it can be guaranteed that the code invoking undefined behavior will be executed then the compiler must successfully translate the program. </p>\n<p><b>C++ constexpr case</b></p>\n<p>If <code>x</code> was a constexpr variable:</p>\n<pre><code>constexpr int x = 1 / 0 ;\n</code></pre>\n<p>it would be ill-formed and gcc produces a warning and clang makes it error (<em><a href=\"http://melpon.org/wandbox/permlink/3PTo6hKwjVjCufcX\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>error: constexpr variable 'x' must be initialized by a constant expression\nconstexpr int x = 1/ 0 ;\n             ^   ~~~~\nnote: division by zero\nconstexpr int x = 1/ 0 ;\n                  ^\nwarning: division by zero is undefined [-Wdivision-by-zero]\nconstexpr int x = 1/ 0 ;\n                  ^ ~\n</code></pre>\n<p>Helpfully noting that <em>division by zero is undefined</em>.</p>\n<p>The draft C++ standard section <code>5.19</code> Constant expressions [expr.const] says:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_5\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_6\">an operation that would have undefined behavior [Note: including, for example, signed integer overflow\n  (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8)\n  \u2014end note ];</p>\n</blockquote>\n<p><b>Is 1 / 0 a constant expression in C11</b></p>\n<p><code>1 / 0</code> is not a constant expression in C11, we can see this from section <code>6.6</code> Constant expressions which says:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_7\">Each constant expression shall evaluate to a constant that is in the range of representable\n  values for its type.</p>\n</blockquote>\n<p>although, it does allow:</p>\n<blockquote>\n<p id=\"so_33916113_33916186_8\">An implementation may accept other forms of constant expressions.</p>\n</blockquote>\n<p>So <code>1 / 0</code> is not a constant expression in either C or C++ but that does not change the answer since it is not being used in a context that requires a constant expression. I suspect the OP meant that <code>1 / 0</code> is available for constant folding since both operands are literals, this would also explain the crash.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-07T17:36:15.457", "Score": "39", "CreationDate": "2015-11-25T12:09:38.913", "ParentId": "33916113", "CommentCount": "18", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:53:18.280"}, "34031568": {"Id": "34031568", "PostTypeId": "2", "Body": "<p>How the compiler should behave is unrelated to the value of the expression.  The compiler should not crash.  Period.   </p>\n<p>I imagine that a pedantic implementation, given an expression like this, would\ncompile to code that will execute 1/0 at run time, but I don't think that\nwould be seen as a good feature.</p>\n<p>So the remaining space is that the compiler should decline to compile it, and\ntreat it as some class of source code error.</p>\n", "LastActivityDate": "2015-12-01T22:39:34.313", "CommentCount": "0", "CreationDate": "2015-12-01T22:39:34.313", "ParentId": "33916113", "Score": "-1", "OwnerUserId": "172821"}});