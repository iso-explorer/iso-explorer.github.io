post_cb({"24172519": {"Id": "24172519", "PostTypeId": "2", "Body": "<p>An unnamed object matches <code>&amp;&amp;</code> better than <code>const&amp;</code>, naturally.<br>\nOtherwise move semantics would not work.</br></p>\n<p>Now, there are fewer calls to your default/copy/move-constructors, then one might naively expect, because there's a special rule allowing the ellision of copies, without regard to observable behavior (which must otherwise be preserved by optimizations):</p>\n<blockquote>\n<h3>12.8 Copying and moving of objects \u00a7 31</h3>\n<p id=\"so_24172205_24172519_0\">When <strong>certain criteria</strong> are met, an implementation is <strong>allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects</strong>. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.123 This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):<br>\n  Still, if it is returned from a function and directly used to initialize an object of the same type, that move will be omitted.<br>\n  \u2014 <strong>in a return statement</strong> in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value.<br>\n  \u2014 when <strong>a temporary class object that has not been bound to a reference</strong> (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move.<br>\n  - [... 2 more for exception handling]</br></br></br></br></p>\n</blockquote>\n<p>So, going through your list:</p>\n<pre><code>X x1;// default\n// That's right\nX x2(x1); // copy\n// Dito\nX x3{std::move(X{})}; // default then move\n// Yes. Sometimes it does not pay to call `std::move`\nX x41(getTransform(x2)); // copy in function ,then what?\n// Copy in function, copy to output, move-construction to x41.\n// RVO applies =&gt; no copy to output, and no dtor call for auto variable in function\n// Copy ellision applies =&gt; no move-construction nor dtor of temporary in main\n// So, only one time copy-ctor left\nX x42(std::move(getTransform(x2))); // copy in funciton, then move\n// `std::`move` is bad again\nX x51( (X()) );//default, then move? or copy? // extra() for the most vexing problem\n// Copy-elision applies: default+move+dtor of temporary\n// will be optimized to just default\nX x52(std::move(X())); //default then move\n// And again `std::`move` is a pessimization\n</code></pre>\n<p>I thought using <code>static_cast</code> might avoid binding the temporary, meaning the move can be ellided, but no such luck: <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1376\" rel=\"nofollow noreferrer\">1376. static_cast of temporary to rvalue reference</a> Thanks <a href=\"https://stackoverflow.com/questions/24172205/should-a-temporary-t-as-a-parameter-invoke-tconst-t-or-tt-in-c11#comment37311516_24172519\">@dyp for unearthing this issue</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-13T18:13:09.337", "Score": "6", "CreationDate": "2014-06-11T21:02:23.380", "ParentId": "24172205", "CommentCount": "12", "LastEditDate": "2017-05-23T12:05:32.633", "OwnerUserId": "3204551"}, "24172335": {"Id": "24172335", "PostTypeId": "2", "Body": "<p>I think it's simply Return Value Optimization kicking in. You create a copy within the functions on <code>X tx(src);</code>, and then this local variable is just given back to the main. Semantically as a copy, but in fact the copy operation is omitted.</p>\n<p>As others have said, moves can also be omitted.</p>\n", "LastEditorUserId": "1133179", "LastActivityDate": "2014-06-11T21:57:38.977", "Score": "1", "CreationDate": "2014-06-11T20:50:47.933", "ParentId": "24172205", "CommentCount": "4", "LastEditDate": "2014-06-11T21:57:38.977", "OwnerUserId": "1133179"}, "bq_ids": {"n4140": {"so_24172205_24172639_0": {"length": 62, "quality": 0.9393939393939394, "section_id": 480}, "so_24172205_24172639_1": {"length": 35, "quality": 1.0, "section_id": 480}, "so_24172205_24172639_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_24172205_24172519_0": {"length": 123, "quality": 0.8785714285714286, "section_id": 480}}, "n3337": {"so_24172205_24172639_0": {"length": 59, "quality": 0.8939393939393939, "section_id": 471}, "so_24172205_24172639_1": {"length": 35, "quality": 1.0, "section_id": 471}, "so_24172205_24172639_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_24172205_24172519_0": {"length": 124, "quality": 0.8857142857142857, "section_id": 471}}, "n4659": {"so_24172205_24172639_0": {"length": 62, "quality": 0.9393939393939394, "section_id": 502}, "so_24172205_24172639_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}, "so_24172205_24172639_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_24172205_24172519_0": {"length": 104, "quality": 0.7428571428571429, "section_id": 502}}}, "24172639": {"Id": "24172639", "PostTypeId": "2", "Body": "<p>According to the standard \u00a7 12.8 [<em>Copying and moving class objects</em>]</p>\n<blockquote>\n<p id=\"so_24172205_24172639_0\"><code>31</code> When certain criteria are met, <strong>an implementation is allowed to omit the copy/move construction of a class\n  object</strong>, even if the constructor selected for the copy/move operation and/or the destructor for the object\n  have side e\ufb00ects. In such cases, <strong>the implementation treats the source and target of the omitted copy/move\n  operation as simply two di\ufb00erent ways of referring to the same object</strong>, and the destruction of that object\n  occurs at the later of the times when the two objects would have been destroyed without the optimization.124\n  <strong>This elision of copy/move operations, called copy elision</strong>, is permitted in the following circumstances (which\n  may be combined to eliminate multiple copies)</p>\n<ul>\n<li><p id=\"so_24172205_24172639_1\"><strong>in a return statement in a function with a class return type</strong>, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, <strong>the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value.</strong></p></li>\n<li><p id=\"so_24172205_24172639_2\"><strong>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved</strong>\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</p></li>\n</ul>\n</blockquote>\n<p>Thus in the both cases (i.e., <code>x41</code>, <code>x51</code> respectively) you are experiencing a copy elision optimization effect.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-06-11T21:31:19.017", "Score": "1", "CreationDate": "2014-06-11T21:10:53.227", "ParentId": "24172205", "CommentCount": "0", "LastEditDate": "2014-06-11T21:31:19.017", "OwnerUserId": "2352671"}, "24172205": {"ViewCount": "166", "Body": "<p>So, code first:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct X{\n    int i;\n    void transform(){}\n    X() :i(0){std::cout&lt;&lt;\"default\\n\";}\n    X(const X&amp; src): i(src.i){std::cout&lt;&lt;\"copy\\n\";}\n    X(X&amp;&amp; msrc) :i(msrc.i){msrc.i=0;std::cout&lt;&lt;\"move\\n\";}\n};\n\nX getTransform(const X&amp; src){\n    X tx(src);\n    tx.transform();\n    return tx;\n}\n\nint main(){\n\n    X x1;// default\n    X x2(x1); // copy\n    X x3{std::move(X{})}; // default then move\n    X x41(getTransform(x2)); // copy in function ,then what?\n    X x42(std::move(getTransform(x2))); // copy in funciton, then move\n    X x51( (X()) );//default, then move? or copy?\n      // extra() for the most vexing problem\n    X x52(std::move(X())); //default then move\n    std::cout&lt;&lt;&amp;x41&lt;&lt;\"\\t\"&lt;&lt;&amp;x51&lt;&lt;std::endl;\n}\n</code></pre>\n<p>Then ouput from cygwin + gcc 4.8.2 with C++11 features turned on:</p>\n<pre><code>default\ncopy\ndefault\nmove\ncopy\ncopy\nmove\ndefault\ndefault\nmove\n0x22aa70        0x22aa50\n</code></pre>\n<p>What I don't quite get is the line for x41 and x51. For x41, should the temporary returned from the function call invoke the move constructor or the copy? Same question for x51. \nA second question is that, by looking at the output, the constructions of x41 and x51 didn't call any constructors defined, but the objects are clearly created as they reside in memory. How could this be?</p>\n<p>Thank you!</p>\n", "AcceptedAnswerId": "24172519", "Title": "Should a temporary T, as a parameter, invoke T(const T&) or T(T&&) in C++11?", "CreationDate": "2014-06-11T20:41:08.877", "Id": "24172205", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-11T21:47:47.643", "LastEditorUserId": "3204551", "LastActivityDate": "2014-06-13T18:13:09.337", "Score": "2", "OwnerUserId": "2666587", "Tags": "<c++11><move-constructor><temporary-objects>", "AnswerCount": "3"}});