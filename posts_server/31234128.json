post_cb({"bq_ids": {"n4140": {"so_31234128_31234415_0": {"length": 6, "quality": 1.0, "section_id": 7028}, "so_31234128_31234128_0": {"length": 14, "quality": 0.875, "section_id": 7026}}, "n3337": {"so_31234128_31234128_0": {"length": 14, "quality": 0.875, "section_id": 6772}, "so_31234128_31234415_0": {"length": 6, "quality": 1.0, "section_id": 6774}}, "n4659": {"so_31234128_31234128_0": {"length": 15, "quality": 0.9375, "section_id": 8523}, "so_31234128_31234415_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8525}}}, "31238920": {"Id": "31238920", "PostTypeId": "2", "Body": "<p>The C++ language standard is infamously vague about formally defining what an \"object\" and a \"value\" is. There are efforts to improve this (e.g. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4430.html\" rel=\"nofollow\">N4430</a>), but not before C++17.</p>\n<p>At present, one of the definitions of \"object\" is \"a region of storage\". The term \"value\" is never defined; the taxonomy of lvalues and rvalues does not have \"value\" as its common ancestor, but rather \"expression\".</p>\n<p>For the time being, I would like to offer the following commentary.</p>\n<p>Every value is an object: every value has a type, and the type is an object type, which is the type of that object. Conversely, every object has a value. The distinction is in usage: when talking about an object, usually it is the <em>storage</em> of the entity that is under consideration, while values are the result of <em>evaluation</em> of an expression. The value of an object is obtained by evaluating the object, or more precisely by evaluating any expression whose value is that object (tautologically). In yet other words, values are the subjects of computation, and objects are the means by which values are stored.</p>\n<p>The distinction comes into play when you consider rules that concern <em>accessing an object through a value</em>. Evaluating an id-expression that names an object yields an lvalue that <em>is</em> that object, and this is the canonical way of accessing that object. But you can produce other values and access the object that way:</p>\n<pre><code>unsigned char x;\nx = 10;                                   // \"x\" is an expression and an lvalue\nreinterpret_cast&lt;signed char &amp;&gt;(x) = 20;  // access through a different lvalue\n</code></pre>\n<p>(Note incidentally that <em>variables</em> can, but need not be objects (they can also be references), but <em>evaluating</em> an id-expression that names a variable always produces a value, hence an object. Conversely, not all objects are variables (e.g. a <code>new</code> expression produces an object that is not a variable), but all object types can in principle be the type of a variable  (subject to constructibility and destructibility).)</p>\n<p>Values are more diverse than objects, too. Consider this simple example:</p>\n<pre><code>int a;\nint b = 10;\nb = a;\n</code></pre>\n<p>The last line contains two objects, but several values: <code>b</code> is an lvalue of type <code>int</code> that is the object of the variable <code>b</code>. The expression <code>a</code> on the RHS is also an lvalue of type <code>int</code>, being the object of the variable <code>a</code>. But this value is not suitable for assignment. First, there is an implicit conversion, an lvalue-to-rvalue conversion, which produces a new value. This value is still the same object, but it is a prvalue, and it is <em>that</em> value that is used in the evaluation of the assignment.</p>\n<p>Finally, we have <em>temporaries</em>: Are they temporary <em>values</em> or temporary <em>objects</em>? Until recently the Standard was sly and just called them \"temporaries\", but recently this was made more precise in a few places and now says \"temporary objects\". Clearly for the purpose of evaluation it does not matter where the value is stored, and the fact that the storage and lifetime are temporary is what matters, so \"temporary object\" is appropriate. Note that even though you cannot take the address of a temporary object with the built-in address-of operator, such objects can of course have addresses (which can be exported e.g. via a class member function returning <code>this</code>). It's just not valid beyond the limited lifetime of the temporary object.</p>\n<p>In a nutshell: Objects and values are different facets of the same thing, but viewed from different perspectives: respectively the perspectives of evaluation on one side and storage, access and lifetime on the other.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2015-07-06T06:29:50.290", "Score": "1", "CreationDate": "2015-07-06T06:23:06.220", "ParentId": "31234128", "CommentCount": "0", "OwnerUserId": "596781", "LastEditDate": "2015-07-06T06:29:50.290"}, "31234415": {"Id": "31234415", "PostTypeId": "2", "Body": "<p>Parsing the chapter in the link, I read</p>\n<blockquote>\n<p id=\"so_31234128_31234415_0\">Every name that denotes an entity is introduced by a declaration.</p>\n</blockquote>\n<p>Apparently we can name values! (Are that consts? Edit: Apparently not, but template arguments can be named values, cf. comment by hvd below.). We can name only one thing which is not an entity, that is labels.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2015-07-06T05:36:01.737", "Score": "-1", "CreationDate": "2015-07-05T19:59:03.473", "ParentId": "31234128", "CommentCount": "9", "OwnerUserId": "3150802", "LastEditDate": "2015-07-06T05:36:01.737"}, "31234128": {"ViewCount": "105", "Body": "<p>In the c++ standard there following definition of an entity can be found:</p>\n<p>[basic]/3 ( <a href=\"http://eel.is/c++draft/basic#3\" rel=\"nofollow\">http://eel.is/c++draft/basic#3</a> ):</p>\n<blockquote>\n<p id=\"so_31234128_31234128_0\">An entity is a <strong>value</strong>, object, reference, function, enumerator, type,\n  class member, bit-field, template, template specialization, namespace,\n  parameter pack, or this.</p>\n</blockquote>\n<p>What is a value in this context?</p>\n<p>Is there any rule of the standard using the term entity, where it would make a difference if we didn't consider a value an entity?</p>\n<p>Is a pr-value expression a value?</p>\n", "AcceptedAnswerId": "31238920", "Title": "The term value is mentioned in the definition of an entity, but what is a value?", "CreationDate": "2015-07-05T19:21:46.443", "Id": "31234128", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-05T19:48:13.123", "LastEditorUserId": "1272610", "LastActivityDate": "2015-07-06T06:29:50.290", "Score": "0", "OwnerUserId": "1272610", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});