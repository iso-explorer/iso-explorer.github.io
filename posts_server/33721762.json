post_cb({"bq_ids": {"n4140": {"so_33721762_33730436_0": {"section_id": 7105, "quality": 0.75, "length": 9}, "so_33721762_33721762_3": {"section_id": 201, "quality": 1.0, "length": 7}, "so_33721762_33721762_2": {"section_id": 188, "quality": 0.6666666666666666, "length": 8}, "so_33721762_33730436_1": {"section_id": 5505, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_33721762_33730436_0": {"section_id": 6849, "quality": 0.75, "length": 9}, "so_33721762_33721762_3": {"section_id": 195, "quality": 1.0, "length": 7}, "so_33721762_33721762_2": {"section_id": 182, "quality": 0.6666666666666666, "length": 8}, "so_33721762_33730436_1": {"section_id": 5291, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_33721762_33730436_0": {"section_id": 8606, "quality": 0.75, "length": 9}, "so_33721762_33721762_3": {"section_id": 207, "quality": 1.0, "length": 7}, "so_33721762_33721762_2": {"section_id": 193, "quality": 0.5833333333333334, "length": 7}, "so_33721762_33730436_1": {"section_id": 6939, "quality": 0.8333333333333334, "length": 15}}}, "33721762": {"CommentCount": "5", "ViewCount": "59", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-15T16:04:39.627", "LastActivityDate": "2015-11-16T08:23:34.280", "Title": "Forcing name lookup to consider namespace scope", "AcceptedAnswerId": "33730436", "LastEditDate": "2017-05-23T12:07:23.233", "Id": "33721762", "Score": "0", "Body": "<p>This question is somewhat related to <a href=\"https://stackoverflow.com/questions/30514337/point-of-instantiation-and-name-binding\">point of instantiation and name binding</a> but not exactly. The question is about the standard and how it resolve lookup of symbols inside template definitions.</p>\n<p>Consider this example, loosely based on ostream library:</p>\n<pre><code>// Output module\nclass Output {\n public:\n  void operator&lt;&lt;(int);\n  void operator&lt;&lt;(double);\n  ...\n};\n\n// Item module\nclass Item {\n  friend void operator&lt;&lt;(Output&amp; obj, const Item&amp; x) {\n     ...\n  }\n};\n\n// Main program\nint main() {\n  Output out;\n  Item item;\n  out &lt;&lt; 3;\n  out &lt;&lt; 2.0;\n  out &lt;&lt; item;\n}\n</code></pre>\n<p>In this example, the key points is that the output module is defined before any modules that use it and there is one module (<code>Item</code> module) that uses the output module to emit items.</p>\n<p>This allow the base emit operators to be defined inside the <code>Output</code> class, but any module that define new classes and want to provide an emit method can do so by providing a friend function with two arguments. All fine so far.</p>\n<p>Now, let's try to use the same idea without operator overloading and instead use plan member functions for the pre-defined emit functions for the base type and still allow class-specific emit functions to be defined as friend functions for the class:</p>\n<pre><code>class Output {\n public:\n  template &lt;class Type&gt;\n  void emit(Type x) {\n    emit(*this, x);\n  }\n\n  void emit(int);\n  void emit(double);\n};\n\nclass Item {\n  friend void emit(Output&amp; obj, const Item&amp; x) {\n    ...\n  }\n  ...\n};\n\nint main() {\n  Output out;\n  Item item;\n  out.emit(3);\n  out.emit(2.0);\n  out.emit(item);\n}\n</code></pre>\n<p>Compared to the previous code, there is a template function added because it should not be necessary to have different calling conventions depending on the type. In other words, it should be possible to use the convention <code>out.emit(...)</code> regardless of what item is being emitted.</p>\n<p>However, when compiling this (using GCC 4.8.4), we get the following error:</p>\n<pre><code>example.cc: In instantiation of \u2018void Output::emit(Type) [with Type = Item]\u2019:\nexample.cc:49:20:   required from here\nexample.cc:33:9: error: no matching function for call to \u2018Output::emit(Output&amp;, Item&amp;)\u2019\n         emit(*this, x);\n         ^\nexample.cc:33:9: note: candidates are:\nexample.cc:32:12: note: template&lt;class Type&gt; void Output::emit(Type)\n       void emit(Type x) {\n            ^\nexample.cc:32:12: note:   template argument deduction/substitution failed:\nexample.cc:33:9: note:   candidate expects 1 argument, 2 provided\n         emit(*this, x);\n         ^\nexample.cc:36:12: note: void Output::emit(int)\n       void emit(int) {\n            ^\nexample.cc:36:12: note:   candidate expects 1 argument, 2 provided\nexample.cc:37:12: note: void Output::emit(double)\n       void emit(double) {\n            ^\nexample.cc:37:12: note:   candidate expects 1 argument, 2 provided\n</code></pre>\n<p>In other words, the top-level <code>emit</code> function is never considered and instead only the member functions inside <code>Output</code> class is considered when resolving the name.</p>\n<p>I assumed this was because the symbol <code>emit</code> was not a dependent name and hence was looked up at the point of definition (of the template) instead of point of instantiation, but section 14.6.2 \u00a71 in the C++ Standard says (slightly edited):</p>\n<blockquote>\n<p id=\"so_33721762_33721762_0\">[...] In an expression of the form:</p>\n<p id=\"so_33721762_33721762_1\">\u00a0\u00a0\u00a0\u00a0<em>postfix-expression</em> <code>(</code> <em>expression-list</em> <sub>opt</sub> <code>)</code></p>\n<p id=\"so_33721762_33721762_2\">where the <em>postfix-expression</em> is an <em>identifier</em> the <em>identifier</em> denotes a <em>dependent name</em> if and only if any of the expressions in <em>expression-list</em> is a type-dependent expression (14.6.2.2).</p>\n</blockquote>\n<p>And further, in 14.6.2.2 (\"Type-dependent expressions\") \u00a72 it says:</p>\n<blockquote>\n<p id=\"so_33721762_33721762_3\"><code>this</code> is type-dependent if the class type of the enclosing member function is dependent</p>\n</blockquote>\n<p>Which, AIUI, is the case here.</p>\n<p>So, the questions are:</p>\n<ol>\n<li>Why doesn't the lookup consider the top-level version of <code>emit</code> in the name resolution here?</li>\n<li>Is it possible to make the second example work in the same way as the first one so that the template member function definition will consider both member functions or namespace scope functions at the point of instantiation?</li>\n</ol>\n<p>Update: Changed the title of the post to be more accurate and did a slight edit of the quotes from the standard.</p>\n", "Tags": "<c++><templates><name-lookup>", "OwnerUserId": "758801", "AnswerCount": "1"}, "33730436": {"ParentId": "33721762", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As <a href=\"https://stackoverflow.com/users/34509/%E1%90%85-johannes-schaub-litb-%E1%90%8A\">Johannes</a> points out, if a member function is found ADL is not invoked and ADL is necessary to find the friend declaration of <code>Item</code>.</p>\n<p>So, to answer the first question, Section 3.4.2 \u00a72 in the C++ standard (C++03 version) says:</p>\n<blockquote>\n<p id=\"so_33721762_33730436_0\">If the ordinary unqualified lookup of the name finds the declaration of a class member function, the associated namespaces and classes are not considered. [...]</p>\n</blockquote>\n<p>To answer the second question, here is the fixed sample code:</p>\n<pre><code>namespace emitter {\n\nclass Output;\n\ntemplate &lt;class Type&gt;\nvoid emit(Output&amp; out, const Type&amp; t) {\n  emit(out, t);\n}\n\nclass Output {\n public:\n  template &lt;class Type&gt;\n  void emit(Type x) {\n    using emitter::emit;\n    emit(*this, x);\n  }\n\n  void emit(int);\n  void emit(double);\n};\n\n}\n\nclass Item {\n  friend void emit(emitter::Output&amp; obj, const Item&amp; x) {\n    ...\n  }\n};\n</code></pre>\n<p>I am, however, still struggling to find the paragraph that clarifies why the <code>using</code> declaration solves the issue. The closest I can find right now is 7.3.3 \u00a713:</p>\n<blockquote>\n<p id=\"so_33721762_33730436_1\">For the purpose of overload resolution, the functions which are introduced by a <em>using-declaration</em> into a derived class will be treated as through they were members of the derived class.</p>\n</blockquote>\n<p>But this refers to <code>using B::f</code> in a class <code>D</code> derived from <code>B</code>, so not a perfect match.</p>\n", "OwnerUserId": "758801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:22.597", "Id": "33730436", "Score": "0", "CreationDate": "2015-11-16T07:38:25.030", "LastActivityDate": "2015-11-16T07:38:25.030"}});