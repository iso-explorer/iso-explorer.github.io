post_cb({"24297220": {"Id": "24297220", "PostTypeId": "2", "Body": "<p><strong>tl;dr</strong> The code generates a test that <em>integer</em> + <em>positive integer</em> == <em>negative integer</em>. Usually the optimizer does not optimize this out, but in the specific case of <code>std::endl</code> being used next, the compiler does optimize this test out. I haven't figured out what's special about <code>endl</code> yet.</p>\n<hr>\n<p>From the assembly code at -O1 and higher levels, it is clear that gcc refactors the loop to:</p>\n<pre><code>i = 0;\ndo {\n    cout &lt;&lt; i &lt;&lt; endl;\n    i += NUMBER;\n} \nwhile (i != NUMBER * 4)\n</code></pre>\n<p>The biggest value that works correctly is <code>715827882</code>, i.e. floor(<code>INT_MAX/3</code>). The assembly snippet at <code>-O1</code> is:</p>\n<pre><code>L4:\nmovsbl  %al, %eax\nmovl    %eax, 4(%esp)\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo3putEc\nmovl    %eax, (%esp)\ncall    __ZNSo5flushEv\naddl    $715827882, %esi\ncmpl    $-1431655768, %esi\njne L6\n    // fallthrough to \"return\" code\n</code></pre>\n<p>Note, the <code>-1431655768</code> is <code>4 * 715827882</code> in 2's complement. </p>\n<p>Hitting <code>-O2</code> optimizes that to the following:</p>\n<pre><code>L4:\nmovsbl  %al, %eax\naddl    $715827882, %esi\nmovl    %eax, 4(%esp)\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo3putEc\nmovl    %eax, (%esp)\ncall    __ZNSo5flushEv\ncmpl    $-1431655768, %esi\njne L6\nleal    -8(%ebp), %esp\njne L6 \n   // fallthrough to \"return\" code\n</code></pre>\n<p>So the optimization that has been made is merely that the <code>addl</code> was moved higher up.</p>\n<p>If we recompile with <code>715827883</code> instead then the -O1 version is identical apart from the changed number and test value. However, -O2 then makes a change:</p>\n<pre><code>L4:\nmovsbl  %al, %eax\naddl    $715827883, %esi\nmovl    %eax, 4(%esp)\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo3putEc\nmovl    %eax, (%esp)\ncall    __ZNSo5flushEv\njmp L2\n</code></pre>\n<p>Where there was <code>cmpl $-1431655764, %esi</code> at <code>-O1</code>, that line has been removed for <code>-O2</code>. The optimizer must have decided that adding <code>715827883</code> to <code>%esi</code> can never equal <code>-1431655764</code>.</p>\n<p>This is pretty puzzling. Adding that to <code>INT_MIN+1</code> <em>does</em> generate the expected result, so the optimizer must have decided that <code>%esi</code> can never be <code>INT_MIN+1</code> and I'm not sure why it would decide that.</p>\n<p>In the working example it seems it'd be equally valid to conclude that adding <code>715827882</code> to a number cannot equal <code>INT_MIN + 715827882 - 2</code> ! (this is only possible if wraparound does actually occur), yet it does not optimize the line out in that example.</p>\n<hr>\n<p>The code I was using is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n\nint main()\n{\n    for (int i = 0; i &lt; 4; ++i)\n    {\n        //volatile int j = i*715827883;\n        volatile int j = i*715827882;\n        printf(\"%d\\n\", j);\n\n        std::endl(std::cout);\n    }\n}\n</code></pre>\n<p>If the <code>std::endl(std::cout)</code> is removed then the optimization no longer occurs. In fact replacing it with <code>std::cout.put('\\n'); std::flush(std::cout);</code> also causes the optimization to not happen, even though <code>std::endl</code> is inlined.</p>\n<p>The inlining of <code>std::endl</code> seems to affect the earlier part of the loop structure (which I don't quite understand what it is doing but I'll post it here in case someone else does):</p>\n<p>With original code and <code>-O2</code>:</p>\n<pre><code>L2:\nmovl    %esi, 28(%esp)\nmovl    28(%esp), %eax\nmovl    $LC0, (%esp)\nmovl    %eax, 4(%esp)\ncall    _printf\nmovl    __ZSt4cout, %eax\nmovl    -12(%eax), %eax\nmovl    __ZSt4cout+124(%eax), %ebx\ntestl   %ebx, %ebx\nje  L10\ncmpb    $0, 28(%ebx)\nje  L3\nmovzbl  39(%ebx), %eax\nL4:\nmovsbl  %al, %eax\naddl    $715827883, %esi\nmovl    %eax, 4(%esp)\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo3putEc\nmovl    %eax, (%esp)\ncall    __ZNSo5flushEv\njmp L2                  // no test\n</code></pre>\n<p>With mymanual inlining of <code>std::endl</code>, <code>-O2</code>:</p>\n<pre><code>L3:\nmovl    %ebx, 28(%esp)\nmovl    28(%esp), %eax\naddl    $715827883, %ebx\nmovl    $LC0, (%esp)\nmovl    %eax, 4(%esp)\ncall    _printf\nmovl    $10, 4(%esp)\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo3putEc\nmovl    $__ZSt4cout, (%esp)\ncall    __ZNSo5flushEv\ncmpl    $-1431655764, %ebx\njne L3\nxorl    %eax, %eax\n</code></pre>\n<p>One difference between these two is that <code>%esi</code> is used in the original , and <code>%ebx</code> in the second version; is there any difference in semantics defined between <code>%esi</code> and <code>%ebx</code> in general? (I don't know much about x86 assembly).</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2014-06-19T01:06:55.273", "Score": "21", "CreationDate": "2014-06-19T01:01:31.657", "ParentId": "24296571", "CommentCount": "1", "OwnerUserId": "1505939", "LastEditDate": "2014-06-19T01:06:55.273"}, "37604385": {"Id": "37604385", "PostTypeId": "2", "Body": "<p>Another example of this error being reported in gcc is when you have a loop that executes for a constant number of iterations, but you are using the counter variable as an index into an array that has less than that number of items, such as:</p>\n<pre><code>int a[50], x;\n\nfor( i=0; i &lt; 1000; i++) x = a[i];\n</code></pre>\n<p>The compiler can determine that this loop will try to access memory outside of the array 'a'. The compiler complains about this with this rather cryptic message: </p>\n<blockquote>\n<p id=\"so_24296571_37604385_0\">iteration xxu invokes undefined behavior [-Werror=aggressive-loop-optimizations]</p>\n</blockquote>\n", "LastEditorUserId": "821878", "LastActivityDate": "2016-06-03T01:15:19.477", "Score": "4", "CreationDate": "2016-06-03T01:00:57.510", "ParentId": "24296571", "CommentCount": "0", "OwnerUserId": "6417320", "LastEditDate": "2016-06-03T01:15:19.477"}, "24296629": {"Id": "24296629", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24296571_24296629_0\">What I cannot get is why i value is broken by that overflow operation?    </p>\n</blockquote>\n<p>It seems that integer overflow occurs in 4th iteration (for <code>i = 3</code>).\n<code>signed</code> integer overflow invokes <strong>undefined behavior</strong>. In this case nothing can be predicted. The loop may iterate only <code>4</code> times or it may go to infinite or anything else!<br>\nResult may vary compiler to compiler or even for different versions of same compiler.   </br></p>\n<h3>C11: 1.3.24 undefined behavior:</h3>\n<blockquote>\n<p id=\"so_24296571_24296629_1\">behavior for which this International Standard imposes no requirements<br>\n  [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior or when a program uses an erroneous construct or erroneous data. <strong>Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message)</strong>. Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.\n  \u2014end note ]  </br></p>\n</blockquote>\n", "LastEditorUserId": "2455888", "LastActivityDate": "2016-01-13T14:27:01.483", "Score": "5", "CreationDate": "2014-06-18T23:34:33.463", "ParentId": "24296571", "CommentCount": "8", "OwnerUserId": "2455888", "LastEditDate": "2016-01-13T14:27:01.483"}, "24297811": {"Id": "24297811", "PostTypeId": "2", "Body": "<p>Short answer, <code>gcc</code> specifically has documented this problem, we can see that in the <a href=\"https://gcc.gnu.org/gcc-4.8/changes.html\" rel=\"noreferrer\">gcc 4.8 release notes</a> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24296571_24297811_0\">GCC now uses a more <strong>aggressive analysis to derive an upper bound for\n  the number of iterations of loops using constraints imposed by\n  language standards</strong>. This may cause non-conforming programs to no\n  longer work as expected, such as SPEC CPU 2006 464.h264ref and\n  416.gamess. A new option, -fno-aggressive-loop-optimizations, was added to disable this aggressive analysis. In some loops that have\n  known constant number of iterations, but undefined behavior is known\n  to occur in the loop before reaching or during the last iteration, GCC\n  will warn about the undefined behavior in the loop instead of deriving\n  lower upper bound of the number of iterations for the loop. The\n  warning can be disabled with -Wno-aggressive-loop-optimizations.</p>\n</blockquote>\n<p>and indeed if we use <code>-fno-aggressive-loop-optimizations</code> the infinite loop behavior should cease and it does in all the cases I have tested.</p>\n<p>The long answer starts with knowing that <em>signed integer</em> overflow is undefined behavior by looking at the draft C++ standard section <code>5</code> <em>Expressions</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_24296571_24297811_1\">If during the evaluation of an expression, <strong>the result is not\n  mathematically defined or not in the range of representable values for\n  its type, the behavior is undefined</strong>. [ Note: most existing\n  implementations of C++ ignore integer overflows. Treatment of division\n  by zero, forming a remainder using a zero divisor, and all floating\n  point exceptions vary among machines, and is usually adjustable by a\n  library function. \u2014end note</p>\n</blockquote>\n<p>We know that the standard says undefined behavior is unpredictable from the note that come with the definition which says:</p>\n<blockquote>\n<p id=\"so_24296571_24297811_2\">[ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. <strong>Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results</strong>, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed. \u2014end note ]</p>\n</blockquote>\n<p>But what in the world can the <code>gcc</code> optimizer be doing to turn this into an infinite loop? It sounds completely wacky. But thankfully <code>gcc</code> gives us a clue to figuring it out in the warning:</p>\n<pre><code>warning: iteration 3u invokes undefined behavior [-Waggressive-loop-optimizations]\n   std::cout &lt;&lt; i*1000000000 &lt;&lt; std::endl;\n                  ^\n</code></pre>\n<p>The clue is the <code>Waggressive-loop-optimizations</code>, what does that mean? Fortunately for us this is not the first time this optimization has broken code in this way and we are lucky because <em>John Regehr</em> has documented a case in the article <a href=\"http://blog.regehr.org/archives/918\" rel=\"noreferrer\">GCC pre-4.8 Breaks Broken SPEC 2006 Benchmarks</a> which shows the following code:</p>\n<pre><code>int d[16];\n\nint SATD (void)\n{\n  int satd = 0, dd, k;\n  for (dd=d[k=0]; k&lt;16; dd=d[++k]) {\n    satd += (dd &lt; 0 ? -dd : dd);\n  }\n  return satd;\n}\n</code></pre>\n<p>the article says:</p>\n<blockquote>\n<p id=\"so_24296571_24297811_3\">The undefined behavior is accessing d[16] just before exiting the\n  loop. In C99 it is legal to create a pointer to an element one\n  position past the end of the array, but that pointer must not be\n  dereferenced.</p>\n</blockquote>\n<p>and later on says:</p>\n<blockquote>\n<p id=\"so_24296571_24297811_4\">In detail, here is what\u2019s going on. A C compiler, upon seeing d[++k],\n  is permitted to assume that the incremented value of k is within the\n  array bounds, since otherwise undefined behavior occurs. For the code\n  here, <strong>GCC can infer that k is in the range 0..15. A bit later, when\n  GCC sees k&lt;16, it says to itself: \u201cAha\u2013 that expression is always\n  true, so we have an infinite loop.\u201d</strong> The situation here, where the\n  compiler uses the assumption of well-definedness to infer a useful\n  dataflow fact,</p>\n</blockquote>\n<p>So what the compiler must be doing in some cases is assuming since signed integer overflow is undefined behavior then <code>i</code> must always be less than <code>4</code> and thus we have an infinite loop.</p>\n<p>He explains this is very similar to the infamous <a href=\"http://blog.regehr.org/archives/970\" rel=\"noreferrer\">Linux kernel null pointer check removal</a> where in seeing this code:</p>\n<pre><code>struct foo *s = ...;\nint x = s-&gt;f;\nif (!s) return ERROR;\n</code></pre>\n<p><code>gcc</code> inferred that since <code>s</code> was deferenced in  <code>s-&gt;f;</code> and since dereferencing a null pointer is undefined behavior then <code>s</code> must not be null and therefore optimizes away the <code>if (!s)</code> check on the next line.</p>\n<p>The lesson here is that modern optimizers are very aggressive about exploiting undefined behavior and most likely will only get more aggressive. Clearly with just a few examples we can see the optimizer does things that seem completely unreasonable to a programmer but in retrospect from the optimizers perspective make sense.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-23T03:10:50.130", "Score": "59", "CreationDate": "2014-06-19T02:22:38.057", "ParentId": "24296571", "CommentCount": "10", "OwnerUserId": "1708801", "LastEditDate": "2014-06-23T03:10:50.130"}, "bq_ids": {"n4140": {"so_24296571_24297811_1": {"length": 38, "quality": 0.926829268292683, "section_id": 5937}, "so_24296571_24296605_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 5937}, "so_24296571_24296605_5": {"length": 14, "quality": 0.875, "section_id": 7213}, "so_24296571_24297811_2": {"length": 51, "quality": 0.9272727272727272, "section_id": 5768}, "so_24296571_24296629_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 5768}}, "n3337": {"so_24296571_24297811_1": {"length": 38, "quality": 0.926829268292683, "section_id": 5709}, "so_24296571_24296629_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 5541}, "so_24296571_24296605_5": {"length": 16, "quality": 1.0, "section_id": 6957}, "so_24296571_24297811_2": {"length": 51, "quality": 0.9272727272727272, "section_id": 5541}, "so_24296571_24296605_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 5709}}, "n4659": {"so_24296571_24297811_1": {"length": 29, "quality": 0.7073170731707317, "section_id": 7421}, "so_24296571_24296605_0": {"length": 27, "quality": 0.6585365853658537, "section_id": 7421}, "so_24296571_24296605_5": {"length": 14, "quality": 0.875, "section_id": 8722}, "so_24296571_24297811_2": {"length": 51, "quality": 0.9272727272727272, "section_id": 7225}, "so_24296571_24296629_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 7225}}}, "24296571": {"ViewCount": "36741", "Body": "<p>Compiling this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    for (int i = 0; i &lt; 4; ++i)\n        std::cout &lt;&lt; i*1000000000 &lt;&lt; std::endl;\n}\n</code></pre>\n<p>and <code>gcc</code> produces the following warning:</p>\n<pre><code>warning: iteration 3u invokes undefined behavior [-Waggressive-loop-optimizations]\n   std::cout &lt;&lt; i*1000000000 &lt;&lt; std::endl;\n                  ^\n</code></pre>\n<p>I understand there is a signed integer overflow.</p>\n<p>What I cannot get is why <code>i</code> value is broken by that overflow operation?</p>\n<p>I've read the answers to <a href=\"https://stackoverflow.com/questions/7682477/why-does-integer-overflow-on-x86-with-gcc-cause-an-infinite-loop\">Why does integer overflow on x86 with GCC cause an infinite loop?</a>, but I'm still not clear on <em>why</em> this happens - I get that \"undefined\" means \"anything can happen\", but what's the underlying cause of <em>this specific behavior</em>?</p>\n<p>Online: <a href=\"http://ideone.com/dMrRKR\" rel=\"nofollow noreferrer\">http://ideone.com/dMrRKR</a></p>\n<p>Compiler: <code>gcc (4.8)</code></p>\n", "AcceptedAnswerId": "24296605", "Title": "Why does this loop produce \"warning: iteration 3u invokes undefined behavior\" and output more than 4 lines?", "CreationDate": "2014-06-18T23:27:31.010", "Id": "24296571", "CommentCount": "29", "FavoriteCount": "46", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:44.877", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-03T01:15:19.477", "Score": "143", "OwnerUserId": "251311", "Tags": "<c++><gcc><undefined-behavior>", "AnswerCount": "5"}, "24296605": {"Id": "24296605", "PostTypeId": "2", "Body": "<p>Signed integer overflow (as strictly speaking, there is no such thing as \"unsigned integer overflow\") means <em>undefined behaviour</em>. And this means anything can happen, and discussing why does it happen under the rules of C++ doesn't make sense.</p>\n<p>C++11 draft N3337: \u00a75.4:<sup>1</sup></p>\n<blockquote>\n<p id=\"so_24296571_24296605_0\">If during the evaluation of an expression, the result is not mathematically de\ufb01ned or not in the range of\n  representable values for its type, the behavior is unde\ufb01ned. [ Note: most existing implementations of C++\n  ignore integer over\ufb02ows. Treatment of division by zero, forming a remainder using a zero divisor, and all\n  \ufb02oating point exceptions vary among machines, and is usually adjustable by a library function. \u2014end note ]</p>\n</blockquote>\n<p>Your code compiled with <code>g++ -O3</code> emits warning (even without <code>-Wall</code>)</p>\n<pre><code>a.cpp: In function 'int main()':\na.cpp:11:18: warning: iteration 3u invokes undefined behavior [-Waggressive-loop-optimizations]\n   std::cout &lt;&lt; i*1000000000 &lt;&lt; std::endl;\n                  ^\na.cpp:9:2: note: containing loop\n  for (int i = 0; i &lt; 4; ++i)\n  ^\n</code></pre>\n<p>The only way we can analyze what the program is doing, is by reading the generated assembly code.</p>\n<p>Here is the full assembly listing:</p>\n<pre><code>    .file   \"a.cpp\"\n    .section    .text$_ZNKSt5ctypeIcE8do_widenEc,\"x\"\n    .linkonce discard\n    .align 2\nLCOLDB0:\nLHOTB0:\n    .align 2\n    .p2align 4,,15\n    .globl  __ZNKSt5ctypeIcE8do_widenEc\n    .def    __ZNKSt5ctypeIcE8do_widenEc;    .scl    2;  .type   32; .endef\n__ZNKSt5ctypeIcE8do_widenEc:\nLFB860:\n    .cfi_startproc\n    movzbl  4(%esp), %eax\n    ret $4\n    .cfi_endproc\nLFE860:\nLCOLDE0:\nLHOTE0:\n    .section    .text.unlikely,\"x\"\nLCOLDB1:\n    .text\nLHOTB1:\n    .p2align 4,,15\n    .def    ___tcf_0;   .scl    3;  .type   32; .endef\n___tcf_0:\nLFB1091:\n    .cfi_startproc\n    movl    $__ZStL8__ioinit, %ecx\n    jmp __ZNSt8ios_base4InitD1Ev\n    .cfi_endproc\nLFE1091:\n    .section    .text.unlikely,\"x\"\nLCOLDE1:\n    .text\nLHOTE1:\n    .def    ___main;    .scl    2;  .type   32; .endef\n    .section    .text.unlikely,\"x\"\nLCOLDB2:\n    .section    .text.startup,\"x\"\nLHOTB2:\n    .p2align 4,,15\n    .globl  _main\n    .def    _main;  .scl    2;  .type   32; .endef\n_main:\nLFB1084:\n    .cfi_startproc\n    leal    4(%esp), %ecx\n    .cfi_def_cfa 1, 0\n    andl    $-16, %esp\n    pushl   -4(%ecx)\n    pushl   %ebp\n    .cfi_escape 0x10,0x5,0x2,0x75,0\n    movl    %esp, %ebp\n    pushl   %edi\n    pushl   %esi\n    pushl   %ebx\n    pushl   %ecx\n    .cfi_escape 0xf,0x3,0x75,0x70,0x6\n    .cfi_escape 0x10,0x7,0x2,0x75,0x7c\n    .cfi_escape 0x10,0x6,0x2,0x75,0x78\n    .cfi_escape 0x10,0x3,0x2,0x75,0x74\n    xorl    %edi, %edi\n    subl    $24, %esp\n    call    ___main\nL4:\n    movl    %edi, (%esp)\n    movl    $__ZSt4cout, %ecx\n    call    __ZNSolsEi\n    movl    %eax, %esi\n    movl    (%eax), %eax\n    subl    $4, %esp\n    movl    -12(%eax), %eax\n    movl    124(%esi,%eax), %ebx\n    testl   %ebx, %ebx\n    je  L15\n    cmpb    $0, 28(%ebx)\n    je  L5\n    movsbl  39(%ebx), %eax\nL6:\n    movl    %esi, %ecx\n    movl    %eax, (%esp)\n    addl    $1000000000, %edi\n    call    __ZNSo3putEc\n    subl    $4, %esp\n    movl    %eax, %ecx\n    call    __ZNSo5flushEv\n    jmp L4\n    .p2align 4,,10\nL5:\n    movl    %ebx, %ecx\n    call    __ZNKSt5ctypeIcE13_M_widen_initEv\n    movl    (%ebx), %eax\n    movl    24(%eax), %edx\n    movl    $10, %eax\n    cmpl    $__ZNKSt5ctypeIcE8do_widenEc, %edx\n    je  L6\n    movl    $10, (%esp)\n    movl    %ebx, %ecx\n    call    *%edx\n    movsbl  %al, %eax\n    pushl   %edx\n    jmp L6\nL15:\n    call    __ZSt16__throw_bad_castv\n    .cfi_endproc\nLFE1084:\n    .section    .text.unlikely,\"x\"\nLCOLDE2:\n    .section    .text.startup,\"x\"\nLHOTE2:\n    .section    .text.unlikely,\"x\"\nLCOLDB3:\n    .section    .text.startup,\"x\"\nLHOTB3:\n    .p2align 4,,15\n    .def    __GLOBAL__sub_I_main;   .scl    3;  .type   32; .endef\n__GLOBAL__sub_I_main:\nLFB1092:\n    .cfi_startproc\n    subl    $28, %esp\n    .cfi_def_cfa_offset 32\n    movl    $__ZStL8__ioinit, %ecx\n    call    __ZNSt8ios_base4InitC1Ev\n    movl    $___tcf_0, (%esp)\n    call    _atexit\n    addl    $28, %esp\n    .cfi_def_cfa_offset 4\n    ret\n    .cfi_endproc\nLFE1092:\n    .section    .text.unlikely,\"x\"\nLCOLDE3:\n    .section    .text.startup,\"x\"\nLHOTE3:\n    .section    .ctors,\"w\"\n    .align 4\n    .long   __GLOBAL__sub_I_main\n.lcomm __ZStL8__ioinit,1,1\n    .ident  \"GCC: (i686-posix-dwarf-rev1, Built by MinGW-W64 project) 4.9.0\"\n    .def    __ZNSt8ios_base4InitD1Ev;   .scl    2;  .type   32; .endef\n    .def    __ZNSolsEi; .scl    2;  .type   32; .endef\n    .def    __ZNSo3putEc;   .scl    2;  .type   32; .endef\n    .def    __ZNSo5flushEv; .scl    2;  .type   32; .endef\n    .def    __ZNKSt5ctypeIcE13_M_widen_initEv;  .scl    2;  .type   32; .endef\n    .def    __ZSt16__throw_bad_castv;   .scl    2;  .type   32; .endef\n    .def    __ZNSt8ios_base4InitC1Ev;   .scl    2;  .type   32; .endef\n    .def    _atexit;    .scl    2;  .type   32; .endef\n</code></pre>\n<p>I can barely even read assembly, but even I can see the <code>addl $1000000000, %edi</code> line.\nThe resulting code looks more like</p>\n<pre><code>for(int i = 0; /* nothing, that is - infinite loop */; i += 1000000000)\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n</code></pre>\n<p>This comment of @T.C.:</p>\n<blockquote>\n<p id=\"so_24296571_24296605_1\">I suspect that it's something like: (1) because every iteration with <code>i</code> of any value larger than 2 has undefined behavior -&gt; (2) we can assume that <code>i &lt;= 2</code> for optimization purposes -&gt; (3) the loop condition is always true -&gt; (4) it's optimized away into an infinite loop.</p>\n</blockquote>\n<p>gave me idea to compare the assembly code of the OP's code to the assembly code of the following code, with no undefined behaviour.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    // changed the termination condition\n    for (int i = 0; i &lt; 3; ++i)\n        std::cout &lt;&lt; i*1000000000 &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And, in fact, the correct code has termination condition.</p>\n<pre><code>    ; ...snip...\nL6:\n    mov ecx, edi\n    mov DWORD PTR [esp], eax\n    add esi, 1000000000\n    call    __ZNSo3putEc\n    sub esp, 4\n    mov ecx, eax\n    call    __ZNSo5flushEv\n    cmp esi, -1294967296 // here it is\n    jne L7\n    lea esp, [ebp-16]\n    xor eax, eax\n    pop ecx\n    ; ...snip...\n</code></pre>\n<blockquote>\n<p id=\"so_24296571_24296605_2\">OMG, that's completely not obvious! It's not fair! I demand trial by fire!</p>\n</blockquote>\n<p>Deal with it, you wrote the buggy code and you should feel bad. Bear the consequences.</p>\n<p>...or, alternatively, make proper use of better diagnostics and better debugging tools - that's what they are for:</p>\n<ul>\n<li><p>enable all warnings</p>\n<ul>\n<li><code>-Wall</code> is the gcc option that enables all useful warnings with no false positives. This is a bare minimum that you should always use.</li>\n<li><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Warning-Options.html#Warning-Options\">gcc has many other warning options</a>, however, they are not enabled with <code>-Wall</code> as they may warn on false positives</li>\n<li>Visual C++ unfortunately is lagging behind with the ability to give useful warnings. At least the IDE enables some by default.</li>\n</ul></li>\n<li><p>use debug flags for debugging</p>\n<ul>\n<li>for integer overflow <code>-ftrapv</code> traps the program on overflow, </li>\n<li>Clang compiler is excellent for this: <code>-fcatch-undefined-behavior</code> catches a lot of instances of undefined behaviour (note: <code>\"a lot of\" != \"all of them\"</code>)</li>\n</ul></li>\n</ul>\n<blockquote>\n<p id=\"so_24296571_24296605_3\">I have a spaghetti mess of a program not written by me that needs to be shipped tomorrow! HELP!!!!!!111oneone</p>\n</blockquote>\n<p>Use gcc's <code>-fwrapv</code> </p>\n<blockquote>\n<p id=\"so_24296571_24296605_4\">This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. </p>\n</blockquote>\n<p><sup>1</sup> - this rule does not apply to \"unsigned integer overflow\", as \u00a73.9.1.4 says that</p>\n<blockquote>\n<p id=\"so_24296571_24296605_5\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number\n  of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>and e.g. result of <code>UINT_MAX + 1</code> is mathematically defined - by the rules of arithmetic modulo 2<sup>n</sup></p>\n", "LastEditorUserId": "1012936", "LastActivityDate": "2014-06-27T23:40:09.650", "Score": "91", "CreationDate": "2014-06-18T23:31:29.053", "ParentId": "24296571", "CommentCount": "16", "OwnerUserId": "1012936", "LastEditDate": "2014-06-27T23:40:09.650"}});