post_cb({"1255659": {"ParentId": "1255460", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The answers referring to \"initialization order of statics\" are correct for objects that are defined in different translation units but within the same TU the order is defined:</p>\n<p>9.4.2/7:</p>\n<blockquote>\n<p id=\"so_1255460_1255659_0\">Static data members are initialized and destroyed exactly like non-local objects (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>3.6.2/1:</p>\n<blockquote>\n<p id=\"so_1255460_1255659_1\">Objects with static storage duration defined in namespace scope in the same translation\n  unit and dynamically initialized shall be initialized in the order in which their definition appears in the\n  translation unit.</p>\n</blockquote>\n<p>Your definitions are ordered correctly, and so they should be initialized in the correct order.  I would go with the comment by AProgrammer regarding the multiple definitions.  Unlike non member const objects, your objects have external linkage:</p>\n<p>3.5/5:</p>\n<blockquote>\n<p id=\"so_1255460_1255659_2\">In addition, a member function, static data member, class or enumeration of class scope has external linkage\n  if the name of the class has external linkage.</p>\n</blockquote>\n<p>If the header file is included into multiple translation units, then the code violates the ODR and it is my guess that the resulting undefined behaviour is the strangness with the initializations.  Try putting the definition of the static members into a single source file and see what happens.</p>\n", "OwnerUserId": "11698", "LastEditorUserId": "11698", "LastEditDate": "2009-08-10T16:11:16.827", "Id": "1255659", "Score": "7", "CreationDate": "2009-08-10T15:46:08.203", "LastActivityDate": "2009-08-10T16:11:16.827"}, "bq_ids": {"n4140": {"so_1255460_1255659_1": {"section_id": 7152, "quality": 0.5263157894736842, "length": 10}, "so_1255460_1255659_2": {"section_id": 7138, "quality": 1.0, "length": 16}, "so_1255460_1255659_0": {"section_id": 5911, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_1255460_1255659_1": {"section_id": 6896, "quality": 0.5263157894736842, "length": 10}, "so_1255460_1255659_2": {"section_id": 6882, "quality": 1.0, "length": 16}, "so_1255460_1255659_0": {"section_id": 5683, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_1255460_1255659_2": {"section_id": 8639, "quality": 0.8125, "length": 13}, "so_1255460_1255659_0": {"section_id": 7393, "quality": 0.7272727272727273, "length": 8}}}, "1255584": {"ParentId": "1255460", "CommentCount": "0", "Body": "<p>The Standard, 3.6.2, says that such initialization should work, making a few assumptions.</p>\n<p>\"Objects of POD types (3.9) with static storage duration initialized with constant expressions (5.19)  shall be initialized before any dynamic initialization takes place.\"  Therefore, the assignment of 3.14 should happen before any other initialization.</p>\n<p>\"Objects with static storage duration defined in namespace scope in the same translation unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.\"  Since <code>pi</code> appears before <code>div</code> in the definition, it should be initialized first.</p>\n<p>I'm assuming that the statements are as you gave them, and that <code>TDouble</code> is some sort of fancy version of <code>double</code>.  If <code>TDouble</code> is a class with real behavior, that complicates things.  Similarly, you aren't showing the context of the code, or even whether the .h file is <code>#include</code>d in more than one .c file (in which case you'd have problems with the One Definition Rule).  Alternatively, you might not be using a standard-conformant compiler.</p>\n<p>So, what's the definition of <code>TDouble</code>?  What's the context for the lines?  What compiler are you using, and with which compiler options?</p>\n<p>Initialization like this is not good style, partly because minor changes in the code or how you use it can cause bugs, but this should work as far as I can tell.</p>\n", "OwnerUserId": "14148", "PostTypeId": "2", "Id": "1255584", "Score": "2", "CreationDate": "2009-08-10T15:31:27.733", "LastActivityDate": "2009-08-10T15:31:27.733"}, "1255485": {"ParentId": "1255460", "CommentCount": "8", "Body": "<p>Order of initialzation of static members isn't defined. Relying one one static member to initialize another is not going to work reliably. It's unlikely you really need two constant static members, so I'd say just eliminate one.</p>\n<p>Of course, it's likely your actual code has something more subtle going on. Just remember that you can't count on order of initialization of constants any more than you can count on order of initialization of fields in a constructor init list, and write your code accordingly. An occasional macro can help.</p>\n<pre><code>#define PI 3.14\nconst TDouble A::pi_d = PI;\nconst TDouble A::pi   = PI;\nconst TDouble A::div  = PI / 180.0;\n</code></pre>\n<p>That works because macros are textual replacement, and can't be re-ordered the way static member initializations can.</p>\n", "OwnerUserId": "5801", "PostTypeId": "2", "Id": "1255485", "Score": "0", "CreationDate": "2009-08-10T15:18:47.417", "LastActivityDate": "2009-08-10T15:18:47.417"}, "1255484": {"ParentId": "1255460", "CommentCount": "3", "Body": "<p>It's impossible to answer this question unless you give us more information on what exactly a TDouble type is.  </p>\n<p>My guess from the sample is that TDouble has either a lossy conversion error or does not properly implement the <code>/</code> operator (essentially converting to int before dividing).  But it's just speculation unless we see the type.  </p>\n", "OwnerUserId": "23283", "PostTypeId": "2", "Id": "1255484", "Score": "1", "CreationDate": "2009-08-10T15:18:44.780", "LastActivityDate": "2009-08-10T15:18:44.780"}, "1255460": {"CommentCount": "3", "ViewCount": "457", "OwnerDisplayName": "Asaf", "CreationDate": "2009-08-10T15:13:50.123", "LastActivityDate": "2009-08-10T16:11:16.827", "Title": "problems with static members", "PostTypeId": "1", "Id": "1255460", "Score": "1", "Body": "<p>Assuming I have this class in C++:</p>\n<pre><code>class A\n{\npublic:\n    static const TDouble pi_d;\n    static const TDouble pi;\n    static const TDouble div;\n};\n</code></pre>\n<p>They are initialized at the .h file in the following way:</p>\n<pre><code>const TDouble A::pi_d = 3.14;\nconst TDouble A::pi   = A::pi_d;\nconst TDouble A::div  = A::pi / 180.0;\n</code></pre>\n<p>When I print the member div the result is 0.0000.\nIf I change this line:</p>\n<pre><code>const TDouble A::pi   = A::pi_d;\n</code></pre>\n<p>with this line:</p>\n<pre><code>const TDouble A::pi   = 3.14;\n</code></pre>\n<p>then everything is OK and a correct value is printed.</p>\n<p>Do you know what is the reason for that?</p>\n<p>Thank you for your time.\nAsaf.</p>\n", "Tags": "<c++><static>", "AnswerCount": "4"}});