post_cb({"37645712": {"ParentId": "37645347", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The code is ill-formed. Both compilers correctly fail to compile:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt;class... Args, class T&gt;\nT method(std::tuple&lt;Args...&gt;, Args..., T) {\n   return T();\n}\n\nint main() {\n    method(std::make_tuple&lt;int, float, double&gt;(1, 1.0f, 1.0),\n        1, 1.0f, 1.0, 1);\n}\n</code></pre>\n<p>We do have, from [temp.deduct.call], emphasis mine:</p>\n<blockquote>\n<p id=\"so_37645347_37645712_0\">When a function parameter pack\n  appears in a non-deduced context (14.8.2.5), the type of that parameter pack is <strong>never deduced</strong>.</p>\n</blockquote>\n<p><code>Args...</code> appears in a non-deduced context because, from [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_37645347_37645712_1\">The non-deduced contexts are: [...] A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>.</p>\n</blockquote>\n<p>So by the exact wording of the standard, <code>Args...</code> shall not be deduced so you have to explicitly provide it - which in this case still isn't really possible to due <code>T</code>. </p>\n<p>But in this case, <code>Args...</code> appears both in a deduced <em>and</em> non-deduced context - there should be nothing preventing <code>Args...</code> from being deduced from the <code>tuple</code> argument as <code>{int, float, double}</code> and then simply re-using that deducing for the variadic arguments, and then deducing <code>T</code> as <code>int</code> at the end. </p>\n<p><em>But</em> this proposed process would conflict with the typical deduction process where we handle each parameter/argument pair independently. In this case, deduction on <code>T</code> depends very much on deduction on <code>Args...</code> from the <code>tuple&lt;&gt;</code> parameter/argument pair.</p>\n<p>If you simply flip the ordering:</p>\n<pre><code>template &lt;class... Args, class T&gt;\nT method(std::tuple&lt;Args...&gt;, T, Args...) { ... }\n</code></pre>\n<p>then both compilers compile it. </p>\n<p>I have no idea why gcc accepts the original example with varargs. That's clearly wrong. </p>\n<p>Additionally, if you flip the template parameter specification so that you can specify <code>T</code> without requiring deduction, then clang accepts but gcc rejects:</p>\n<pre><code>template&lt;class T, class... Args&gt;\nT method(std::tuple&lt;Args...&gt;, Args..., T) {\n    return T();\n}\n\nint main() {\n    method&lt;int&gt;(std::make_tuple&lt;int&gt;(1), 1, 1);\n}\n</code></pre>\n<p>I'd expect this to be well-formed - <code>Args...</code> can be deduced and <code>T</code> doesn't have to be. So the wording on \"never deduced\" is questionable, in my opinion.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-06-05T19:23:04.320", "Id": "37645712", "Score": "1", "CreationDate": "2016-06-05T19:08:01.630", "LastActivityDate": "2016-06-05T19:23:04.320"}, "bq_ids": {"n4140": {"so_37645347_37645712_1": {"section_id": 336, "quality": 0.9, "length": 9}, "so_37645347_37645712_0": {"section_id": 302, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_37645347_37645712_1": {"section_id": 293, "quality": 0.8, "length": 8}, "so_37645347_37645712_0": {"section_id": 293, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_37645347_37645712_1": {"section_id": 345, "quality": 0.9, "length": 9}, "so_37645347_37645712_0": {"section_id": 309, "quality": 0.9230769230769231, "length": 12}}}, "37645347": {"CommentCount": "8", "ViewCount": "284", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2016-06-05T18:27:56.920", "LastActivityDate": "2016-06-05T19:23:04.320", "Title": "clang does not infer template argument in variadic template function with varargs", "AcceptedAnswerId": "37645712", "LastEditDate": "2016-06-05T19:05:30.520", "Id": "37645347", "Score": "3", "Body": "<p>Consider the code:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt;class... Args, class T&gt;\nT method(std::tuple&lt;Args...&gt;, Args..., T, ...) {\n   return T();\n}\n\nint main() {\n    method(std::make_tuple&lt;int, float, double&gt;(1, 1.0f, 1.0),\n        1, 1.0f, 1.0, 1);\n}\n</code></pre>\n<p><code>g++</code> since 4.9 has no problem with compiling it. <code>clang++</code> on the other hand provides an error: </p>\n<pre><code>main.cpp:9:5: error: no matching function for call to 'method'\n    method(std::make_tuple&lt;int, float, double&gt;(1, 1.0f, 1.0),\n    ^~~~~~\nmain.cpp:4:3: note: candidate template ignored: couldn't infer template argument 'T'\nT method(std::tuple&lt;Args...&gt;, Args..., T, ...) {\n  ^\n1 error generated.\n</code></pre>\n<p>Which compiler is right?</p>\n", "Tags": "<c++><g++><c++14><variadic-templates><clang++>", "OwnerUserId": "4324224", "AnswerCount": "1"}});