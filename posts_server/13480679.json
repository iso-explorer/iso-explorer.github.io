post_cb({"bq_ids": {"n4140": {"so_13480679_13481498_0": {"length": 7, "quality": 0.7, "section_id": 1422}}, "n3337": {"so_13480679_13481498_0": {"length": 7, "quality": 0.7, "section_id": 1416}}, "n4659": {"so_13480679_13481498_0": {"length": 7, "quality": 0.7, "section_id": 1542}}}, "13480679": {"ViewCount": "223", "Body": "<p>I can't figure out how to call <code>lower_bound</code> with a <code>zip_iterator</code>.</p>\n<p>This won't compile:</p>\n<pre><code>#include &lt;boost/iterator/zip_iterator.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nvoid main()\n{\n    typedef int Key;\n    typedef double Value;\n\n    typedef boost::tuple&lt;typename std::vector&lt;Key&gt;::iterator,\n                         typename std::vector&lt;Value&gt;::iterator&gt; the_iterator_tuple;\n    typedef boost::zip_iterator&lt;the_iterator_tuple&gt; the_zip_iterator;\n\n    std::vector&lt;Key&gt;   keys_;\n    std::vector&lt;Value&gt; values_;\n\n    // Add values to keys_ and values_...\n\n    auto it = std::lower_bound(\n        the_zip_iterator(the_iterator_tuple(keys_.begin(), values_.begin())),\n        the_zip_iterator(the_iterator_tuple(keys_.end(), values_.end())),\n        123,\n        [](const the_iterator_tuple &amp; it, const int v) -&gt; bool { return *boost::get&lt;0&gt;(it) &lt; v; }\n    );\n\n    // Use \"it\"...\n}\n</code></pre>\n<p>VS2010 says it \"cannot convert parameter 1 from 'int' to 'const std::_Vector_iterator&lt;_Myvec&gt; &amp;'\" (plus several dozen other things for the same error), but it has to do with an obscure boost::tuple constructor, not with the given lambda.</p>\n<p>What am I doing wrong ?</p>\n", "AcceptedAnswerId": "13481332", "Title": "zip_iterator and lower_bound", "CreationDate": "2012-11-20T19:31:47.693", "Id": "13480679", "CommentCount": "0", "LastEditDate": "2012-11-20T22:14:58.653", "PostTypeId": "1", "LastEditorUserId": "341970", "LastActivityDate": "2012-11-20T22:14:58.653", "Score": "3", "OwnerUserId": "231306", "Tags": "<c++><boost><iterator><lower-bound>", "AnswerCount": "2"}, "13481332": {"Id": "13481332", "PostTypeId": "2", "Body": "<p><code>std::lower_bound(it, end, v)</code> needs to be able to do both <code>*it &lt; v</code> and <code>v &lt; *it</code>. Your function object supports only one of these.</p>\n<p>Since there is a comment on this, leaving the above statement: This isn't the case. As Howard pointed out, the comparison is required to use <code>comp(*it, v)</code>, i.e., there is no need for this operation to be symmetric.</p>\n<p>However, looking at the documentation of <a href=\"http://www.boost.org/doc/libs/1_51_0/libs/iterator/doc/zip_iterator.html\" rel=\"nofollow\"><code>boost::zip_iterator&lt;It0, It1&gt;</code></a> it seems that <code>*it</code> yields a <code>boost::tuple&lt;typename It0::reference, typename It1::reference&gt;</code>. Thus, adding the <code>typedef</code></p>\n<pre><code>typedef boost::tuple&lt;typename std::vector&lt;Key&gt;::reference,\n                     typename std::vector&lt;Value&gt;::reference&gt; the_reference_tuple;\n</code></pre>\n<p>... and changing the lambda to become</p>\n<pre><code>[](the_reference_tuple const&amp; it, int v) { return it.get&lt;0&gt;() &lt; v; }\n</code></pre>\n<p>solves the compilation issues using gcc and clang.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-11-20T20:56:02.297", "Score": "2", "CreationDate": "2012-11-20T20:14:51.583", "ParentId": "13480679", "CommentCount": "1", "OwnerUserId": "1120273", "LastEditDate": "2012-11-20T20:56:02.297"}, "13481498": {"Id": "13481498", "PostTypeId": "2", "Body": "<p>This looks like a \"concepts checking\" bug in VS2010.</p>\n<p>25.4.3.1 [lower.bound]/p1:</p>\n<blockquote>\n<p id=\"so_13480679_13481498_0\">Requires:: The elements <code>e</code> of <code>[first,last)</code> shall be partitioned with\n  respect to the expression <code>e &lt; value</code> or <code>comp(e, value)</code>.</p>\n</blockquote>\n<p>I.e. only <code>*it &lt; v</code> is required.</p>\n<p>The <code>upper_bound</code> algorithm has the opposite requirement:  <code>v &lt; *it</code>.  And <code>equal_range</code> requires both expressions to work.</p>\n", "LastActivityDate": "2012-11-20T20:24:57.793", "CommentCount": "0", "CreationDate": "2012-11-20T20:24:57.793", "ParentId": "13480679", "Score": "3", "OwnerUserId": "576911"}});