post_cb({"3519588": {"Id": "3519588", "PostTypeId": "2", "Body": "<p>I don't know what's the exact answer, but...</p>\n<p>Because of this operator:</p>\n<pre><code>operator ptr_t &amp; () { return data; }\n</code></pre>\n<p>there exist already built-in <code>[]</code> operator (array subscription) which accepts <code>size_t</code> as index. So we have two <code>[]</code> operators, the built-in and defined by you. Booth accepts <code>size_t</code> so this is considered as illegal overload probably.</p>\n<p>//EDIT<br/>\nthis should work as you intended</p>\n<pre><code>template&lt;typename ptr_t&gt;\nstruct TData\n{\n    ptr_t data;\n    operator ptr_t &amp; () { return data; }\n};\n</code></pre>\n", "LastEditorUserId": "273580", "LastActivityDate": "2010-08-19T07:29:44.683", "Score": "0", "CreationDate": "2010-08-19T07:18:46.643", "ParentId": "3519282", "CommentCount": "1", "OwnerUserId": "273580", "LastEditDate": "2010-08-19T07:29:44.683"}, "3519584": {"Id": "3519584", "PostTypeId": "2", "Body": "<p>I have tried to show the two candidates for the expression t[1][1]. These are both of equal RANK (CONVERSION). Hence ambiguity</p>\n<p>I think the catch here is that the built-in [] operator as per 13.6/13 is defined as</p>\n<pre><code>T&amp; operator[](T*, ptrdiff_t);\n</code></pre>\n<p>On my system ptrdiff_t is defined as 'int' (does that explain x64 behavior?)</p>\n<pre><code>template&lt;typename ptr_t&gt; \nstruct TData \n{ \n    typedef typename boost::remove_extent&lt;ptr_t&gt;::type value_type; \n    ptr_t data; \n\n    value_type &amp; operator [] ( size_t id ) { return data[id]; } \n    operator ptr_t &amp; () { return data; } \n}; \n\ntypedef float (&amp;ATYPE) [100][100];\n\nint main( int argc, char ** argv ) \n{ \n    TData&lt;float[100][100]&gt; t;    \n\n    t[size_t(1)][size_t(1)] = 5; // note the cast. This works now. No ambiguity as operator[] is preferred over built-in operator\n\n    t[1][1] = 5;                 // error, as per the logic given below for Candidate 1 and Candidate 2\n\n    // Candidate 1 (CONVERSION rank)\n    // User defined conversion from 'TData' to float array\n    (t.operator[](1))[1] = 5;\n\n    // Candidate 2 (CONVERSION rank)\n    // User defined conversion from 'TData' to ATYPE\n    (t.operator ATYPE())[1][1] = 6;\n\n    return 0; \n}\n</code></pre>\n<p>EDIT: </p>\n<p>Here is what I think:</p>\n<p>For candidate 1 (operator []) the conversion sequence S1 is\nUser defined conversion - Standard Conversion (int to size_t)</p>\n<p>For candidate 2, the conversion sequence S2 is\nUser defined conversion -&gt; int to ptrdiff_t (for first argument) -&gt; int to ptrdiff_t (for second argument)  </p>\n<p>The conversion sequence S1 is a subset of S2 and is supposed to be better. But here is the catch...</p>\n<p>Here the below quote from Standard should help.</p>\n<blockquote>\n<p id=\"so_3519282_3519584_0\">$13.3.3.2/3 states - Standard\n  conversion sequence S1 is a better\n  conversion sequence than standard\n  conversion sequence S2 if \u2014 S1 is a\n  proper subsequence of S2 (comparing\n  the conversion sequences in the\n  canonical form defined by 13.3.3.1.1,\n  excluding any Lvalue Transformation;\n  the identity conversion sequence is\n  considered to be a subsequence of any\n  non-identity conversion sequence) or,\n  if not that...</p>\n<p id=\"so_3519282_3519584_1\">$13.3.3.2 states- \" User-defined\n  conversion sequence U1 is a better\n  conversion sequence than another\n  user-defined conversion sequence U2 if\n  they contain the same user-defined\n  conversion function or constructor and\n  if the second standard conversion\n  sequence of U1 is better than the\n  second standard conversion sequence of\n  U2.\"</p>\n</blockquote>\n<p>Here the first part of the and condition \"<em>if they contain the same user-defined conversion function or constructor</em>\" does not hold good. So, even if the second part of the and condition \"<em>if the second standard conversion sequence of U1 is better than the second standard conversion sequence of U2.</em>\" holds good, neither S1 nor S2 is preferred over the other.</p>\n<p>That's why gcc's <em>phantom</em> error message \"ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second\"</p>\n<p>This explains the ambiguity quiet well IMHO</p>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-08-19T09:33:40.043", "Score": "0", "CreationDate": "2010-08-19T07:18:21.657", "ParentId": "3519282", "CommentCount": "11", "OwnerUserId": "418110", "LastEditDate": "2010-08-19T09:33:40.043"}, "3519282": {"ViewCount": "14786", "Body": "<p>Consider I have the following minimal code:</p>\n<pre><code>#include &lt;boost/type_traits.hpp&gt;\n\ntemplate&lt;typename ptr_t&gt;\nstruct TData\n{\n    typedef typename boost::remove_extent&lt;ptr_t&gt;::type value_type;\n    ptr_t data;\n\n    value_type &amp; operator [] ( size_t id ) { return data[id]; }\n    operator ptr_t &amp; () { return data; }\n};\n\nint main( int argc, char ** argv )\n{\n    TData&lt;float[100][100]&gt; t;   \n    t[1][1] = 5;\n    return 0;\n}\n</code></pre>\n<p>GNU C++ gives me the error:</p>\n<pre><code>test.cpp: In function 'int main(int, char**)':\ntest.cpp:16: error: ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for second:\ntest.cpp:9: note: candidate 1: typename boost::remove_extent&lt;ptr_t&gt;::type&amp; TData&lt;ptr_t&gt;::operator[](size_t) [with ptr_t = float [100][100]]\ntest.cpp:16: note: candidate 2: operator[](float (*)[100], int) &lt;built-in&gt;\n</code></pre>\n<p><strong>My questions are:</strong></p>\n<ol>\n<li>Why GNU C++ gives the error, but Intel C++ compiler is not?</li>\n<li>Why changing <code>operator[]</code> to the following leads to compiling without errors?\n\n<blockquote>\n<p id=\"so_3519282_3519282_0\"><code>value_type &amp; operator [] ( int id ) { return data[id]; }</code></p>\n</blockquote></li>\n</ol>\n<p>Links to the C++ Standard are appreciated.</p>\n<hr>\n<p>As I can see here are two conversion paths:</p>\n<ol>\n<li>(1)<code>int</code> to <code>size_t</code> and (2)<code>operator[](size_t)</code>.</li>\n<li>(1)<code>operator ptr_t&amp;()</code>, (2)<code>int</code> to <code>size_t</code> and (3)build-in <code>operator[](size_t)</code>.</li>\n</ol>\n</hr>", "AcceptedAnswerId": "3525172", "Title": "Why is this ambiguity here?", "CreationDate": "2010-08-19T06:30:30.533", "Id": "3519282", "CommentCount": "13", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2013-09-11T05:26:18.580", "LastEditorUserId": "123111", "LastActivityDate": "2013-09-11T05:26:18.580", "Score": "31", "OwnerUserId": "123111", "Tags": "<c++><templates><operator-overloading>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3519282_3525172_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 603}, "so_3519282_3525172_0": {"length": 18, "quality": 0.9, "section_id": 587}, "so_3519282_3519584_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 639}, "so_3519282_3519584_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 639}, "so_3519282_3525172_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 603}}, "n3337": {"so_3519282_3525172_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 593}, "so_3519282_3519584_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 629}, "so_3519282_3525172_0": {"length": 18, "quality": 0.9, "section_id": 577}, "so_3519282_3519584_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 629}, "so_3519282_3525172_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 593}}, "n4659": {"so_3519282_3525172_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 629}, "so_3519282_3519584_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 667}, "so_3519282_3525172_0": {"length": 18, "quality": 0.9, "section_id": 610}, "so_3519282_3519584_0": {"length": 26, "quality": 0.8666666666666667, "section_id": 667}, "so_3519282_3525172_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 629}}}, "3519710": {"Id": "3519710", "PostTypeId": "2", "Body": "<p>It seems to me that with</p>\n<pre><code>t[1][1] = 5;\n</code></pre>\n<p>the compiler has to choose between.</p>\n<pre><code>value_type &amp; operator [] ( size_t id ) { return data[id]; }\n</code></pre>\n<p>which would match if the <code>int</code> literal were to be converted to <code>size_t</code>, or</p>\n<pre><code>operator ptr_t &amp; () { return data; }\n</code></pre>\n<p>followed by normal array indexing, in which case the type of the index matches exactly.</p>\n<hr>\n<p>As to the error, it seems GCC as a compiler extension would like to choose the first overload for you, and you are compiling with the -pedantic and/or -Werror flag which forces it to stick to the word of the standard.</p>\n<p>(I'm not in a -pedantic mood, so no quotes from the standard, especially on this topic.)</p>\n</hr>", "LastActivityDate": "2010-08-19T07:43:45.133", "CommentCount": "6", "CreationDate": "2010-08-19T07:43:45.133", "ParentId": "3519282", "Score": "0", "OwnerUserId": "155693"}, "3525172": {"Id": "3525172", "PostTypeId": "2", "Body": "<p>It's actually quite straight forward. For <code>t[1]</code>, overload resolution has these candidates:</p>\n<p><strong>Candidate 1 (builtin: 13.6/13)</strong> (T being some arbitrary object type):</p>\n<ul>\n<li>Parameter list: <code>(T*, ptrdiff_t)</code></li>\n</ul>\n<p><strong>Candidate 2 (your operator)</strong></p>\n<ul>\n<li>Parameter list: <code>(TData&lt;float[100][100]&gt;&amp;, something unsigned)</code></li>\n</ul>\n<p>The argument list is given by <code>13.3.1.2/6</code>:</p>\n<blockquote>\n<p id=\"so_3519282_3525172_0\">The set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and the built-in candidates. The argument list contains all of the operands of the operator.</p>\n</blockquote>\n<ul>\n<li>Argument list: <code>(TData&lt;float[100][100]&gt;, int)</code></li>\n</ul>\n<p>You see that the first argument matches the first parameter of Candidate 2 exactly. But it needs a user defined conversion for the first parameter of Candidate 1. So for the first parameter, the second candidate wins. </p>\n<p>You also see that the outcome of the second position depends. Let's make some assumptions and see what we get:</p>\n<ol>\n<li><code>ptrdiff_t</code> is <code>int</code>: The first candidate wins, because it has an exact match, while the second candidate requires an integral conversion. </li>\n<li><code>ptrdiff_t</code> is <code>long</code>: Neither candidate wins, because both require an integral conversion. </li>\n</ol>\n<p>Now, <code>13.3.3/1</code> says</p>\n<blockquote>\n<p id=\"so_3519282_3525172_1\">Let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F. </p>\n<p id=\"so_3519282_3525172_2\">A viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then ... for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that ...</p>\n</blockquote>\n<p>For our first assumption, we don't get an overall winner, because Candidate 2 wins for the first parameter, and Candidate 1 wins for the second parameter. I call it the <strong>criss-cross</strong>. For our second assumption, the Candidate 2 wins overall, because neither parameter had a worse conversion, but the first parameter had a <em>better</em> conversion. </p>\n<p>For the first assumption, it does not matter that the integral conversion (int to unsigned) in the second parameter is less of an evil than the user defined conversion of the other candidate in the first parameter. In the criss-cross, rules are crude. </p>\n<hr>\n<p>That last point might still confuse you, because of all the fuss around, so let's make an example</p>\n<pre><code>void f(int, int) { }\nvoid f(long, char) { }\n\nint main() { f(0, 'a'); }\n</code></pre>\n<p>This gives you the same confusing GCC warning (which, I remember, was actually confusing the hell out of me when I first received it some years ago), because <code>0</code> converts to <code>long</code> worse than <code>'a'</code> to <code>int</code> - yet you get an ambiguity, because you are in a criss-cross situation.</p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-08-20T00:17:04.580", "Score": "26", "CreationDate": "2010-08-19T18:52:44.707", "ParentId": "3519282", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2010-08-20T00:17:04.580"}, "3519805": {"Id": "3519805", "PostTypeId": "2", "Body": "<p>With the expression:</p>\n<pre><code>t[1][1] = 5;\n</code></pre>\n<p>The compiler must focus on the left hand side to determine what goes there, so the <code>= 5;</code> is ignored until the lhs is resolved. Leaving us with the expression: <code>t[1][1]</code>, which represents two operations, with the second one operating on the result from the first one, so the compiler must only take into account the first part of the expression: <code>t[1]</code>.The actual type is <code>(TData&amp;)[(int)]</code></p>\n<p>The call does not match exactly any functions, as <code>operator[]</code> for <code>TData</code> is defined as taking a <code>size_t</code> argument, so to be able to use it the compiler would have to convert <code>1</code> from <code>int</code> to <code>size_t</code> with an implicit conversion. That is the first choice. Now, another possible path is applying user defined conversion to convert <code>TData&lt;float[100][100]&gt;</code> into <code>float[100][100]</code>.</p>\n<p>The <em><code>int</code> to <code>size_t</code></em> conversion is an <em>integral conversion</em> and is ranked as <em>Conversion</em> in Table 9 of the standard, as is the <em>user defined conversion</em> from <em><code>TData&lt;float[100][100]&gt;</code> to <code>float[100][100]</code></em> conversion according to \u00a713.3.3.1.2/4. The conversion from <code>float [100][100]&amp;</code> to <code>float (*)[100]</code> is ranked as <em>Exact Match</em> in Table 9. The compiler is not allowed to choose from those two conversion sequences.</p>\n<p><strong>Q1</strong>: Not all compilers adhere to the standard in the same way. It is quite common to find out that in some specific cases a compiler will perform differently than the others. In this case, the g++ implementors decided to whine about the standard not allowing the compiler to choose, while the Intel implementors probably just silently applied their preferred conversion.</p>\n<p><strong>Q2</strong>: When you change the signature of the user defined <code>operator[]</code>, the argument matches exactly the passed in type. <code>t[1]</code> is a perfect match for <code>t.operator[](1)</code> with no conversions whatsoever, so the compiler must follow that path.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2013-04-08T02:09:14.770", "Score": "12", "CreationDate": "2010-08-19T08:01:26.683", "ParentId": "3519282", "CommentCount": "9", "OwnerUserId": "36565", "LastEditDate": "2013-04-08T02:09:14.770"}, "3519892": {"Id": "3519892", "PostTypeId": "2", "Body": "<p>Overload resolution is a headache. But since you stumbled on a fix (eliminate conversion of the index operand to <code>operator[]</code>) which is too specific to the example (literals are type <code>int</code> but most variables you'll be using aren't), maybe you can generalize it:</p>\n<pre><code>template&lt; typename IT&gt;\ntypename boost::enable_if&lt; typename boost::is_integral&lt; IT &gt;::type, value_type &amp; &gt;::type\noperator [] ( IT id ) { return data[id]; }\n</code></pre>\n<p>Unfortunately I can't test this because GCC 4.2.1 and 4.5 accept your example without complaint under <code>--pedantic</code>. Which really raises the question whether it's a compiler bug or not.</p>\n<p>Also, once I eliminated the Boost dependency, it passed Comeau.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-08-19T23:19:19.517", "Score": "0", "CreationDate": "2010-08-19T08:17:54.053", "ParentId": "3519282", "CommentCount": "5", "OwnerUserId": "153285", "LastEditDate": "2010-08-19T23:19:19.517"}});