post_cb({"34545498": {"ParentId": "34545445", "CommentCount": "0", "Body": "<p>What comes to my mind is a signed overflow. It is undefined behavior but might yield a negative value.<br>\nTry <code>std::numeric_limits&lt;int&gt;::max()</code> and <code>2</code>.</br></p>\n", "OwnerUserId": "3494013", "PostTypeId": "2", "Id": "34545498", "Score": "5", "CreationDate": "2015-12-31T11:04:32.270", "LastActivityDate": "2015-12-31T11:04:32.270"}, "34545445": {"CommentCount": "1", "AcceptedAnswerId": "34545493", "PostTypeId": "1", "LastEditorUserId": "5057736", "CreationDate": "2015-12-31T11:01:05.113", "LastActivityDate": "2016-01-06T01:51:18.490", "LastEditDate": "2016-01-01T12:53:48.383", "ViewCount": "2422", "FavoriteCount": "3", "Title": "Positive integers that multiply to a negative value", "Id": "34545445", "Score": "17", "Body": "<p>I am learning C++ by reading Stroustrup's \"Principles and Practice Using C++\".</p>\n<p>In the section about pre- and post-conditions there is the following example of function:</p>\n<pre><code>int area(int length, int width)\n// calculate area of a rectangle;\n// pre-conditions: length and width are positive\n// post-condition: returns a positive value that is the area\n{\n    if (length&lt;=0 || width &lt;=0) \n        error(\"area() pre-condition\");\n\n    int a = length*width;\n\n    if (a&lt;=0) \n        error(\"area() post-condition\");\n\n    return a;\n}\n</code></pre>\n<p>What confused me is the task about this code:</p>\n<blockquote>\n<p id=\"so_34545445_34545445_0\">Find a pair of values so that the pre-condition of this version of\n  area holds, but the post-condition doesn\u2019t.</p>\n</blockquote>\n<p>Are there such possible values for integer that pre-conditions is ok but post-condition not?</p>\n", "Tags": "<c++><integer>", "OwnerUserId": "5057736", "AnswerCount": "9"}, "34545601": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Yes if suppose you are using 16 bit computer so int = 2B Max value +32767 so in following</p>\n<pre><code>{\n    length = 500, width = 100;\n    if (length&lt;=0 || width &lt;=0) error(\"area() pre-condition\");\n    int a = length*width;   // a = 500 * 100 = 50000\n    if (a&lt;=0) error(\"area() post-condition\");\n    return a;\n}\n</code></pre>\n<p>now final value will be <code>a = -17233</code> because it gets into -ve value.\nso second condition gets false.</p>\n<p>Its all depends on range.</p>\n", "OwnerUserId": "5622566", "LastEditorUserId": "5622566", "LastEditDate": "2015-12-31T12:06:45.887", "Id": "34545601", "Score": "4", "CreationDate": "2015-12-31T11:12:41.113", "LastActivityDate": "2015-12-31T12:06:45.887"}, "34545493": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_34545445_34545493_0\">Are there such possible values for integer that pre-conditions is ok but post-condition not?</p>\n</blockquote>\n<p>Yes there's a number of input values, that can cause the post condition to fail. If e.g.</p>\n<pre><code>int a = length*width;\n</code></pre>\n<p>overflows the positive <code>int</code> range (<code>std::numeric_limits&lt;int&gt;::max()</code>) and the compiler implementation yields a negative value for this case.</p>\n<hr>\n<p>As others noted in their answers, the situation that <code>length*width</code> goes out of bounds from <code>]0-std::numeric_limits&lt;int&gt;::max()[</code> is actually undefined behavior, and the post condition renders merely useless, because any value might need to be expected for <code>a</code>.</p>\n<p>The key point to fix this, is given in <a href=\"https://stackoverflow.com/users/3204551/deduplicator\">@Deduplicator</a>'s <a href=\"https://stackoverflow.com/a/34549434/1413395\">answer</a>, the pre-condition needs to be improved.</p>\n<hr>\n<p>As a lance for Bjarne Stroustrup's reasonings to give that example:</p>\n<p>I assume he wanted to point out that such undefined behavior might lead to unexpected negative values in the post-condition and surprising results for a naive assumption checked with the pre-condition.</p>\n</hr></hr>", "OwnerUserId": "1413395", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:56.423", "Id": "34545493", "Score": "32", "CreationDate": "2015-12-31T11:04:04.640", "LastActivityDate": "2016-01-01T03:18:13.233"}, "34549139": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://www.cplusplus.com/reference/climits/\" rel=\"nofollow\"><code>INT_MAX</code></a> will fail to fulfill the post-condition when used for both length and width for all conforming compilers.  </p>\n<p>One might be tempted to say that, since the standard guarantees that <code>INT_MAX</code>&gt;=32767, then <code>INT_MAX*INT_MAX</code> will always be greater than <code>INT_MAX</code> and thus not representable in an <code>int</code> which is defined as being able to hold a maximun value of <code>INT_MAX</code>.<br>\nIt is a good argument and it is actually what happens most often, you will get an overflow with most compilers.</br></p>\n<p>But to cover all bases we need to be aware that the <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"nofollow\">C++ standard</a> states  :</p>\n<blockquote>\n<p id=\"so_34545445_34549139_0\"><strong>3.4.3</strong><br>\n<strong>1 undefined behavior</strong><br>\n  behavior,upon use of a nonportable or erroneous program construct or of erroneous data,for which this International Standard imposes no requirements  </br></br></p>\n<p id=\"so_34545445_34549139_1\">2  NOTE Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).  </p>\n<p id=\"so_34545445_34549139_2\">3 EXAMPLE An example of undefined behavior is the behavior on integer overflow.</p>\n</blockquote>\n<p>So it is a bit more serious than not getting the right value for the area. When <code>INT_MAX</code> is used for both length and width (or any other combination with a result which is not representable) there is no guarantee of what the compiled program will do. Anything can happen; from the likely ones like overflows or crashes to the unlikely ones like disk formats.</p>\n", "OwnerUserId": "956880", "LastEditorUserId": "956880", "LastEditDate": "2015-12-31T17:10:37.053", "Id": "34549139", "Score": "3", "CreationDate": "2015-12-31T16:37:57.547", "LastActivityDate": "2015-12-31T17:10:37.053"}, "34624391": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>So basically, <strong>positive values in multiplication ... result in Positive values but these may not actually fit the result type</strong> . </p>\n<p>Your precondition is not complete, and you postcondition is also invalid. Not only you can get negative values but also positive values that are just smaller than the input value, all you need is sufficiently large values as input such that the wrap around goes beyond zero, i.e. a <em>long-wrap-around</em> .</p>\n<p>You can use <a href=\"https://stackoverflow.com/a/199455/4345926\">this</a> : </p>\n<pre><code>bool multiplication_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);\n    return (a_bits+b_bits&lt;=32);\n}\n</code></pre>\n<p>to guard against overflow, but then you would want to employ additional checks for FALSE-Positives .</p>\n<p>Alternatively if performance is not that much of an issue you can use <a href=\"https://stackoverflow.com/a/33322600/4345926\">MPZ</a> library. If performance is an issue and you want to write assembly for a CPU that has an overflow flag, then you can do just that. It is possible that your compiler also can do the checks for you e.g. G++ has <code>fno-strict-overflow</code> or maybe cast to <code>unsigned int</code> after the precondition check.</p>\n<p>At any rate, most of these solutions do not actually solve your problem that results will be <strong>foo</strong>, that is that you might get smaller area than the actual result. </p>\n<p>So your only safe choice is to allow only safe multiplications as shown herein, doing that you miss something, but not that much.</p>\n", "OwnerUserId": "4345926", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:17.887", "Id": "34624391", "Score": "0", "CreationDate": "2016-01-06T01:51:18.490", "LastActivityDate": "2016-01-06T01:51:18.490"}, "34545505": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>No, there aren't any values that will, within the bounds of defined behavior of standard C++, violate the post-condition. However, there are values that still can make the function behave incorrectly, namely values so large that their product does not fit within an integer. Try passing 200'000 and 15'000.</p>\n<p>Due to the way most compilers implement C++, you might see the post-condition being violated, but what you're actually observing is undefined behavior due to integer overflow.</p>\n", "OwnerUserId": "8922", "LastEditorUserId": "8922", "LastEditDate": "2016-01-01T17:16:53.443", "Id": "34545505", "Score": "27", "CreationDate": "2015-12-31T11:04:49.980", "LastActivityDate": "2016-01-01T17:16:53.443"}, "34553363": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since C++11 there is a boolean value you can test:</p>\n<pre><code>std::numeric_limits&lt;int&gt;::is_modulo\n</code></pre>\n<p>If this value is <code>true</code> then signed arithmetic behaves in a wraparound fashion, and there is no undefined behaviour in the original code. A negative value could indeed be produced and so the test in the original code is meaningful.</p>\n<p>For further discussion of <code>is_modulo</code> <a href=\"https://stackoverflow.com/questions/13272959/is-numeric-limitsintis-modulo-logically-contradictory\">see here</a></p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:17.887", "Id": "34553363", "Score": "3", "CreationDate": "2016-01-01T03:40:01.497", "LastActivityDate": "2016-01-01T03:40:01.497"}, "34549434": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The answer is that his precondition-check is incomplete. Even though it is too restrictive.<br>\nHe failed to include a check that the product can be represented instead of resulting in UB:</br></p>\n<pre><code>int area(int length, int width) {\n    // calculate area of a rectangle\n    assert(length &gt;= 0 &amp;&amp; width &gt;= 0 &amp;&amp; (!width\n        || std::numeric_limits&lt;int&gt;::max() / width &gt;= length));\n    int a = length * width;\n    assert(a &gt;= 0); // Not strictly neccessary - the math is easy enough\n    return a;\n}\n</code></pre>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2016-01-01T17:41:35.287", "Id": "34549434", "Score": "11", "CreationDate": "2015-12-31T17:07:32.993", "LastActivityDate": "2016-01-01T17:41:35.287"}, "bq_ids": {"n4140": {"so_34545445_34549139_1": {"section_id": 5768, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_34545445_34549139_1": {"section_id": 5541, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_34545445_34549139_1": {"section_id": 7225, "quality": 0.9259259259259259, "length": 25}}}, "34552362": {"ParentId": "34545445", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Multiplication of values that overflow the bit representation of value type is undefined because the number of bits overflowed could be more than 1. Thus you could end up with a positive or negative sign bit and the number of lost bits is variable.</p>\n<p>Example 1: <code>INT_MAX * 2</code> : result is correct but since the high bit represents the sign bit it is not corrected represented for its type.</p>\n<p>Example 2: <code>INT_MAX * 4</code> : 1 bit is lost to overflow and the the sign bit is incorrect like in the previous example.</p>\n<p>Example 3: <code>(INT_MAX + 1) * 2 = 0</code> : due to overflow of all set bits but sign is correct.</p>\n<p>I am using a 8 bit binary representation to make it easier to read, to show why this happens.</p>\n<pre><code>0111 1111              // Max positive signed value\n+1\n1000 0000              // Sign bit set but binary value is correct\n*2\n0000 0000              // Upper bit is lost due to overflow\n</code></pre>\n<p>In this case there is both soft overflow, no lost information but the representation is incorrect. And hard overflow where the bit is no longer present in the result.</p>\n<p>The difference in the overflows is how the overflow can be detected. Typically hard overflows will be detected by the hardware and require very little work for the software to handle. However software overflows may require the software to explicitly test for the overflow condition because the hardware typically does not recognize a sign bit in integer math operations.</p>\n<p>How the run-time library handles the overflow is up to the library. Most will ignore it because it is faster to do so, while others may throw an error. \nUndefined behavior does not mean it might format your disk. The result of a math operation does not alter the flow of code in any way except as the logic of the code dictates. It can ignore the overflow or try to handle it in some way. The standard does not dictate what method to employ if the code or the hardware tries to handle the problem.</p>\n<p>Basically three there are 3 possible things that can happen.<br>\n 1. The overflow is ignore and the returned value in invalid.<br>\n 2. The overflow is ignored by the run-time library but the hardware throws an error that is also ignored, resulting in a hard failure of the running code. In this situation it is completely up to the OS to determine what happens next. Going nuts and destroying data would to a poor design decision.<br>\n 3. The overflow is handled by the run-time library which must determine the best way to proceed. Typically this means giving the code a chance to catch the error and handle it, or by shutting down the code as graceful as possible.</br></br></br></p>\n", "OwnerUserId": "5735011", "LastEditorUserId": "5348281", "LastEditDate": "2015-12-31T23:32:34.387", "Id": "34552362", "Score": "3", "CreationDate": "2015-12-31T23:19:07.190", "LastActivityDate": "2015-12-31T23:32:34.387"}});