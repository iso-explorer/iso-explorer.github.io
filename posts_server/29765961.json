post_cb({"29767272": {"ParentId": "29765961", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The following answer extends the answer <a href=\"https://stackoverflow.com/a/620402/977038\">https://stackoverflow.com/a/620402/977038</a> which would serve as a reference for C++ 98 and C++ 03</p>\n<p>Quoting the answer</p>\n<ol>\n<li>In C++1998 there are 2 types of initialization: zero and default </li>\n<li>In C++2003 a 3rd type of initialization, value initialization was\nadded.</li>\n</ol>\n<p>C++11 (In reference to n3242)</p>\n<h2>Initializers</h2>\n<p>8.5 Initializers [dcl.init] specifies that a variable POD or non POD can be initialized either as <em>brace-or-equal-initializer</em> which can either be  <em>braced-init-list</em> or <em>initializer-clause</em> aggregately referred to as  <em>brace-or-equal-initializer</em> or using <em>( expression-list )</em>. Previous to C++11, only <em>(expression-list)</em> or <em>initializer-clause</em> was supported though <em>initializer-clause</em> was more restricted then what we have in C++11. In C++11, <em>initializer-clause</em> now supports <em>braced-init-list</em> apart from <em>assignment-expression</em> as was in C++03. The following grammar summarizes the new supported clause, where the part is bold is newly added in the C++11 standard.</p>\n<p>\ninitializer:<br/>\n\u00a0\u00a0\u00a0\u00a0<b>brace-or-equal-initializer</b><br/>\n\u00a0\u00a0\u00a0\u00a0( expression-list )<br/>\n<b>brace-or-equal-initializer:</b><br/>\n\u00a0\u00a0\u00a0\u00a0= initializer-clause <br/>\n\u00a0\u00a0\u00a0\u00a0<b>braced-init-list </b><br/>\ninitializer-clause:<br/>\n\u00a0\u00a0\u00a0&amp;nbspassignment-expression; <br/>\n\u00a0\u00a0\u00a0\u00a0<b>braced-init-list </b><br/>\n<b>initializer-list:</b><br/>\n\u00a0\u00a0\u00a0\u00a0<b>initializer-clause ...opt </b><br/>\n\u00a0\u00a0\u00a0\u00a0<b>initializer-list , initializer-clause ...opt**<br/>\n<b>braced-init-list: </b><br/>\n\u00a0\u00a0\u00a0\u00a0<b>{ initializer-list ,opt } </b><br/>\n\u00a0\u00a0\u00a0\u00a0{ }</b><br/>\n</p>\n<h2>Initialization</h2>\n<p>Like C++03, C++11 still supports three form of initialize</p>\n<hr>\n<p><strong>Note</strong> </p>\n<blockquote>\n<blockquote>\n<p id=\"so_29765961_29767272_1\">The part highlighted in bold has been added in C++11 and the one that is striked out has been removed from C++11.</p>\n</blockquote>\n</blockquote>\n<ol>\n<li><h3> Initializer Type:8.5.5 [dcl.init] _zero-initialize_ </h3> </li>\n</ol>\n<p><strong><em>Performed in the following cases</em></strong></p>\n<ul>\n<li>Objects with static or thread storage duration are zero-initialized</li>\n<li>If there are fewer initializers than there are array elements, each element not explicitly initialized shall be zero-initialized</li>\n<li>During <em>value-initialize</em>, if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized.</li>\n</ul>\n<blockquote>\n<p id=\"so_29765961_29767272_2\">To zero-initialize an object or reference of type T means:</p>\n<ul>\n<li>if T is a scalar type (3.9), the object is set to the value 0 (zero), <strong><em>taken as an integral constant expression</em></strong>, converted to T;</li>\n<li>if T is a <strong><em>(possibly cv-qualified)</em></strong> non-union class type, each non-static data member and each base-class subobject is zero-initialized <strong><em>and padding is initialized to zero bits;</em></strong></li>\n<li>if T is a <strong><em>(possibly cv-qualified)</em></strong> union type, the object\u2019s first non-static named data member is zero initialized <strong><em>and padding is initialized to zero bits;</em></strong></li>\n<li>if T is an array type, each element is zero-initialized;</li>\n<li>if T is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n<h3>2. Initializer Type: 8.5.6 [dcl.init] _default-initialize_</h3>\n<p>Performed in the following cases</p>\n<ul>\n<li>If the new-initializer is omitted, the object is default-initialized; if no initialization is performed, the object has indeterminate value.</li>\n<li>If no initializer is specified for an object, the object is default-initialized, except for Objects with static or thread storage duration</li>\n<li>When a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called.</li>\n</ul>\n<blockquote>\n<p id=\"so_29765961_29767272_3\">To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a <strong><em>(possibly cv-qualified)</em></strong> <strike> non-POD </strike> class type (Clause 9), the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li>otherwise, no initialization is performed.</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_29765961_29767272_4\"><strong>Note</strong> Until C++11, only non-POD class types with automatic storage duration were considered to be default-initialized when no initializer is used.</p>\n</blockquote>\n<hr>\n<h3>3. Initializer Type: 8.5.7 [dcl.init] _value-initialize_</h3>\n<ol>\n<li>When an object(nameless temporary, named variable, dynamic storage duration or non-static data member)  whose initializer is an empty set of parentheses, i.e., () or braces {}</li>\n</ol>\n<blockquote>\n<p id=\"so_29765961_29767272_5\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a <strong><em>(possibly cv-qualified)</em></strong> class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</li>\n<li>if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, <strike>then every non-static data member and base-class component of T is value-initialized;</strike> <strong><em>then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</em></strong></li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>So to summarize</p>\n<blockquote>\n<blockquote>\n<p id=\"so_29765961_29767272_7\"><strong>Note</strong> The relevant quotation from the standard is highlighted in <strong>bold</strong> </p>\n</blockquote>\n</blockquote>\n<ul>\n<li>new A : default-initializes (leaves A::m uninitialized)</li>\n<li>new A() : Zero-initialize A, as the value initialized candidate does not have a user-provided or deleted default constructor. <strong><em>if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</em></strong></li>\n<li>new B : default-initializes (leaves B::m uninitialized)</li>\n<li>new B() : value-initializes B which zero-initializes all fields; <strong><em>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called</em></strong></li>\n<li>new C : default-initializes C, which calls the default ctor. <strong><em>if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called</em></strong>, Moreover If the new-initializer is omitted, the object is default-initialized</li>\n<li>new C() : value-initializes C, which calls the default ctor. <strong><em>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called.</em></strong> Moreover, <strong><em>An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized</em></strong></li>\n</ul>\n</hr></hr></hr>", "OwnerUserId": "977038", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:24.333", "Id": "29767272", "Score": "10", "CreationDate": "2015-04-21T08:50:45.913", "LastActivityDate": "2015-04-21T16:14:51.363"}, "29766171": {"ParentId": "29765961", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>C++14 specifies initialization of objects created with <code>new</code> in [expr.new]/17 ([expr.new]/15 in C++11, and the note wasn't a note but normative text back then):</p>\n<blockquote>\n<p id=\"so_29765961_29766171_0\">A <em>new-expression</em> that creates an object of type <code>T</code> initializes that\n  object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em> (8.5). [ <em>Note:</em> If no initialization is\n      performed, the object has an indeterminate value. <em>\u2014 end note</em> ]</li>\n<li>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of 8.5 for <em>direct-initialization</em>.</li>\n</ul>\n</blockquote>\n<p>Default-initialization is defined in [dcl.init]/7 (/6 in C++11, and the wording itself has the same effect):</p>\n<blockquote>\n<p id=\"so_29765961_29766171_1\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9), the default constructor (12.1) for <code>T</code> is called (and the initialization\n  is ill-formed if <code>T</code> has no default constructor or overload resolution\n  (13.3) results in an ambiguity or in a function that is deleted or\n  inaccessible from the context of the initialization);</li>\n<li>if <code>T</code> is an array type, each element is <em>default-initialized</em>;</li>\n<li>otherwise, no initialization is performed.</li>\n</ul>\n</blockquote>\n<p>Thus</p>\n<ul>\n<li><code>new A</code> solely causes <code>A</code>s default constructor to be called, which does not initialize <code>m</code>. Indeterminate value. Should be the same for <code>new B</code>.</li>\n<li><p><code>new A()</code> is interpreted according to [dcl.init]/11 (/10 in C++11):</p>\n<blockquote>\n<p id=\"so_29765961_29766171_2\">An object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be value-initialized.</p>\n</blockquote>\n<p>And now consider [dcl.init]/8 (/7 in C++11\u2020):</p>\n<blockquote>\n<p id=\"so_29765961_29766171_3\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is\n  user-provided or deleted, then the object is default-initialized;</li>\n<li><strong>if <code>T</code> is a (possibly cv-qualified) class type without a user-provided or deleted default constructor, then the object is\n  zero-initialized and the semantic constraints for\n  default-initialization are checked, and if T has a non-trivial default\n  constructor, the object is default-initialized;</strong></li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>Hence <code>new A()</code> will zero-initialize <code>m</code>. And this should be equivalent for <code>A</code> and <code>B</code>.</p></li>\n<li><p><code>new C</code> and <code>new C()</code> will default-initialize the object again, since the first bullet point from the last quote applies (C has a user-provided default constructor!). But, clearly, now <code>m</code> is initialized in the constructor in both cases.</p></li>\n</ul>\n<hr>\n<p>\u2020 Well, this paragraph has slightly different wording in C++11, which does not alter the result:</p>\n<blockquote>\n<p id=\"so_29765961_29766171_4\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with a\n  user-provided constructor (12.1), then the default constructor for <code>T</code>\n  is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</li>\n<li>if <code>T</code> is a (possibly cv-qualified) non-union\n  class type without a user-provided constructor, then the object is\n  zero-initialized and, if <code>T</code>\u2019s implicitly-declared default constructor\n  is non-trivial, that constructor is called.</li>\n<li>if <code>T</code> is an array type,\n  then each element is value-initialized;</li>\n<li>otherwise, the object is\n  zero-initialized.</li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-21T08:11:20.377", "Id": "29766171", "Score": "20", "CreationDate": "2015-04-21T07:56:21.780", "LastActivityDate": "2015-04-21T08:11:20.377"}, "bq_ids": {"n4140": {"so_29765961_29766171_0": {"section_id": 6098, "quality": 1.0, "length": 7}, "so_29765961_29766171_2": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_29765961_29766171_4": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_29765961_29767272_2": {"section_id": 3285, "quality": 1.0, "length": 5}, "so_29765961_29766171_3": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_29765961_29766171_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_29765961_29767272_3": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_29765961_29767272_5": {"section_id": 3287, "quality": 1.0, "length": 4}}, "n3337": {"so_29765961_29766171_0": {"section_id": 5864, "quality": 1.0, "length": 7}, "so_29765961_29766171_2": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_29765961_29766171_4": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_29765961_29767272_2": {"section_id": 3155, "quality": 1.0, "length": 5}, "so_29765961_29766171_3": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_29765961_29766171_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_29765961_29767272_3": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_29765961_29767272_5": {"section_id": 3157, "quality": 1.0, "length": 4}}, "n4659": {"so_29765961_29766171_0": {"section_id": 7595, "quality": 1.0, "length": 7}, "so_29765961_29766171_2": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_29765961_29767272_2": {"section_id": 653, "quality": 0.8, "length": 4}}}, "29765961": {"CommentCount": "3", "ViewCount": "7363", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-21T07:44:49.640", "LastActivityDate": "2015-04-22T11:24:18.013", "Title": "Default, value and zero initialization mess", "FavoriteCount": "21", "LastEditDate": "2017-05-23T11:54:35.077", "Id": "29765961", "Score": "67", "Body": "<p>I am very confused about value- &amp; default- &amp; zero-initialization.\nand especially when they kick in for the different standards <em>C++03</em> and <em>C++11</em> (and <em>C++14</em>). </p>\n<p>I am quoting and trying to extend a really good answer <a href=\"https://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new\">Value-/Default-/Zero- Init <em>C++98</em> and <em>C++03</em></a> here to make it more general as it would help a lot of users if somebody could help fill out the needed gaps to have a good overview about what happens when?</p>\n<p><strong>The full insight by examples in a nutshell:</strong></p>\n<p>Sometimes the memory returned by the new operator will be initialized, and sometimes it won't depending on whether the type you're newing up is a <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\">POD (plain old data)</a>, or if it's a class that contains POD members and is using a compiler-generated default constructor.</p>\n<ul>\n<li>In <em>C++1998</em> there are 2 types of initialization: zero and default</li>\n<li>In <em>C++2003</em> a 3rd type of initialization, value initialization was added.</li>\n<li>In <em>C++2011/C++2014</em> only list-initialization was added and the rules for value-/default-/zero-initialization changed a bit.</li>\n</ul>\n<p>Assume:</p>\n<pre><code>struct A { int m; };                     \nstruct B { ~B(); int m; };               \nstruct C { C() : m(){}; ~C(); int m; };  \nstruct D { D(){}; int m; };             \nstruct E { E() = default; int m;} /** only possible in c++11/14 */  \nstruct F {F(); int m;}  F::F() = default; /** only possible in c++11/14 */\n</code></pre>\n<p><strong>In a C++98 compiler, the following should occur</strong>:</p>\n<ul>\n<li>new A   - indeterminate value (A is POD)</li>\n<li>new A() - zero-initialize </li>\n<li>new B   - default construct (B::m is uninitialized, B is non-POD)</li>\n<li>new B() - default construct (B::m is uninitialized)</li>\n<li>new C   - default construct (C::m is zero-initialized, C is non-POD)</li>\n<li>new C() - default construct (C::m is zero-initialized)</li>\n<li>new D   - default construct (D::m is uninitialized, D is non-POD)</li>\n<li>new D() - <em>default construct?</em> (D::m is uninitialized)</li>\n</ul>\n<p><strong>In a C++03 conformant compiler, things should work like so:</strong> </p>\n<ul>\n<li>new A    - indeterminate value (A is POD)</li>\n<li>new A()  - value-initialize A, which is zero-initialization since it's a POD.</li>\n<li>new B    - default-initializes (leaves B::m uninitialized, B is non-POD)</li>\n<li>new B()  - value-initializes B which zero-initializes all fields since its default ctor is compiler generated as opposed to user-defined.</li>\n<li>new C    - default-initializes C, which calls the default ctor. (C::m is zero-initialized, C is non-POD)</li>\n<li>new C()  - value-initializes C, which calls the default ctor.  (C::m is zero-initialized)</li>\n<li>new D    - default construct (D::m is uninitialized, D is non-POD)</li>\n<li>new D()  - <em>value-initializes D?</em>, which calls the default ctor (D::m is uninitialized)</li>\n</ul>\n<p>Italic values and ? are uncertainties, please help to correct this :-)</p>\n<p><strong>In a C++11 conformant compiler, things should work like so:</strong> </p>\n<p>??? (please help if I start here it will anyway go wrong)</p>\n<p><strong>In a C++14 conformant compiler, things should work like so:</strong>\n ??? (please help if I start here it will anyway go wrong)\n <em>(Draft based on answer)</em></p>\n<ul>\n<li>new A    - default-initializes A, compiler gen. ctor, (leavs A::m uninitialized) (A is POD)</li>\n<li><p>new A()  - value-initializes A, which is zero-initialization since 2. point in <em>[dcl.init]/8</em></p></li>\n<li><p>new B   - default-initializes B, compiler gen. ctor, (leavs A::m uninitialized) (B is non-POD)</p></li>\n<li>new B()  - value-initializes B which zero-initializes all fields since its default ctor is compiler generated as opposed to user-defined.</li>\n<li>new C    - default-initializes C, which calls the default ctor. (C::m is zero-initialized, C is non-POD)</li>\n<li>new C()  - value-initializes C, which calls the default ctor. (C::m is zero-initialized) </li>\n<li>new D    - default-initializes D (D::m is uninitialized, D is non-POD)</li>\n<li>new D()  - value-initializes D, which calls the default ctor (D::m is uninitialized)</li>\n<li>new E    - default-initializes E, which calls the comp. gen. ctor. (D::m is uninitialized, D is non-POD)</li>\n<li>new E()  - value-initializes E, which zero-initializes E since 2 point in <em>[dcl.init]/8</em> )</li>\n<li>new F    - default-initializes F, which calls the comp. gen. ctor. (D::m is uninitialized, D is non-POD)</li>\n<li>new F()  - value-initializes F, which <strong>default-initializes</strong> F since 1. point in <em>[dcl.init]/8</em> (A function is user-provided if it is user-declared and not explicitly defaulted or deleted on its first declaration. <a href=\"https://stackoverflow.com/questions/26699720/value-initialization-default-initialization-or-zero-initialization#comment47663175_26699720\">Link</a>)</li>\n</ul>\n", "Tags": "<c++><c++11><c++14><c++03><c++98>", "OwnerUserId": "293195", "AnswerCount": "2"}});