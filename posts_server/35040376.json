post_cb({"bq_ids": {"n4140": {"so_35040376_35040690_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 481}}, "n3337": {"so_35040376_35040690_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 472}}, "n4659": {"so_35040376_35040690_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 504}}}, "35040376": {"ViewCount": "54", "Body": "<p>Getting a reference to temporary variable:</p>\n<pre><code>struct S\n{\n    S() = default;\n    S(const S&amp; other) = delete;\n    S(S&amp;&amp; other) = delete;\n\n    ~S(){}\n};\n\nS foo1()\n{\n    return {}; // RVO (???)\n}\n\nint foo2()\n{\n    return 42; // RVO\n}\n\nint main()\n{\n    S&amp; i = foo1(); // compiles!\n    int&amp; i2 = foo3(); // error C2440: 'initializing' : cannot convert from 'int' to 'int &amp;'\n}\n</code></pre>\n<p>I know about reference life extension with <code>const</code> specifier. And it's clear why <code>foo2</code> gives an error. But why <code>foo1</code> works?</p>\n<p>P.S.: tested with VS2013/15</p>\n", "AcceptedAnswerId": "35040648", "Title": "Returning local object of a primitive type and a struct", "CreationDate": "2016-01-27T14:43:33.200", "Id": "35040376", "CommentCount": "6", "LastEditDate": "2016-01-27T14:48:08.470", "PostTypeId": "1", "LastEditorUserId": "1341942", "LastActivityDate": "2016-01-27T15:13:49.367", "Score": "1", "OwnerUserId": "1341942", "Tags": "<c++><reference><return-value-optimization>", "AnswerCount": "2"}, "35040648": {"Id": "35040648", "PostTypeId": "2", "Body": "<p>Compiling with all warnings enabled (<code>/Wall</code>), you incidentally get the following:</p>\n<blockquote>\n<p id=\"so_35040376_35040648_0\">source_file.cpp(22): warning C4239: nonstandard extension used: 'initializing': conversion from 'S' to 'S &amp;'</p>\n</blockquote>\n", "LastActivityDate": "2016-01-27T14:56:02.920", "CommentCount": "0", "CreationDate": "2016-01-27T14:56:02.920", "ParentId": "35040376", "Score": "1", "OwnerUserId": "602372"}, "35040690": {"Id": "35040690", "PostTypeId": "2", "Body": "<p>gcc 4.9.3 std=c++14 doesn't like either one of the initializations.</p>\n<p>If we change <code>foo1()</code> to</p>\n<pre><code>S foo1()\n{\n    S s;\n    return s; \n}\n</code></pre>\n<p>It also complains about the deleted move ctor. I'm unsure why the original code does not need one. </p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">Cppreference states</a>: \"Even when copy elision takes place and the copy-/move-constructor is not called, it must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed.\"</p>\n<p>In the standard, 12.8/32:</p>\n<blockquote>\n<p id=\"so_35040376_35040690_0\">[ Note: This two-stage overload resolution must be performed regardless of whether copy elision will\n  occur. It determines the constructor to be called if elision is not performed, and <strong>the selected constructor\n  must be accessible even if the call is elided.</strong> \u2014end note ]</p>\n</blockquote>\n<p>I understand that this note refers to finding the proper move (first attempt) or copy (second attempt) constructor, not another one.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2016-01-27T15:13:49.367", "Score": "1", "CreationDate": "2016-01-27T14:57:21.677", "ParentId": "35040376", "CommentCount": "7", "OwnerUserId": "3150802", "LastEditDate": "2016-01-27T15:13:49.367"}});