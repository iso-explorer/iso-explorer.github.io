post_cb({"13571749": {"ViewCount": "646", "Body": "<p>Just because a function (or constructor)...</p>\n<ul>\n<li>is declared constexpr and</li>\n<li>the function definition meets the constexpr requirements</li>\n</ul>\n<p>...doesn't mean that the compiler will evaluate the constexpr function during translation.  I've been looking through the C++11 FDIS (N3242, available at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/</a>) to try and determine two things:</p>\n<ul>\n<li>When is the compiler obligated to evaluate a constexpr function during translation?</li>\n<li>When is the compiler allowed to evaluate a constexpr function during translation?</li>\n</ul>\n<p>Section 5.19 Paragraph 1 says that constant expressions can be evaluated during translation.  As far as I can comprehend, the remainder of Section 5.19 sets forth the rules for what is valid in the definition of a constexpr function.</p>\n<p>I understand that I can force constexpr evaluation during translation by declaring the result of the constexpr function as constexpr.  Like this:</p>\n<pre><code>// Declaration\nconstexpr double eulers_num() { return 2.718281828459045235360287471; }\n\n// Forced evaluation during translation\nconstexpr double twoEulers = eulers_num() * 2.0;\nstatic_assert(twoEulers &gt; 5.0, \"Yipes!\");\n</code></pre>\n<p>So far I've been unable to find the paragraphs in the FDIS that:</p>\n<ul>\n<li>Force <code>twoEulers</code> to be evaluated during translation or</li>\n<li>Specify other situations when the compiler may or must evaluate a constexpr function during translation.</li>\n</ul>\n<p>What I'm particularly interested in discovering is whether constexpr evaluation during translation is triggered by:</p>\n<ol>\n<li>When all parameters passed to the constexpr function are literals, or</li>\n<li>The <em>implied object argument</em> during overload resolution (Section 13.3.1 Paragraph 3) is either constexpr or requires a literal (such as for array dimensions), or</li>\n<li>Something else entirely.</li>\n</ol>\n<p>Please, if possible, in your responses cite sections of the FDIS that I can look up or key phrases I can search in the FDIS.  The English in the standard is somewhat obtuse, so I may have been reading the relevant paragraphs and have entirely missed their meaning or intent.</p>\n", "AcceptedAnswerId": "13784100", "Title": "Where in the C++11 standard does it specify when a constexpr function can be evaluated during translation?", "CreationDate": "2012-11-26T19:30:07.077", "Id": "13571749", "CommentCount": "11", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2016-07-14T04:57:46.923", "LastEditorUserId": "3614835", "LastActivityDate": "2016-07-14T04:57:46.923", "Score": "18", "OwnerUserId": "1854241", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "4"}, "13578723": {"Id": "13578723", "PostTypeId": "2", "Body": "<p>Nicol Bolas is 100% correct, but there is one other interesting aspect: whether the expression is evaluated at translation-time and whether it is evaluated at run-time are completely independent questions. Since the constant expression cannot have side-effects, it can be evaluated an arbitrary number of times, and nothing stops it from being evaluated at both translation-time and run-time.</p>\n<p>Suppose the constant expression were a large array (not a <code>std::array</code>, just an array), which is entirely legal, and the program does not indicate that it has static storage. Suppose also that only element 7 of the array is used in a context in which compile-time computation is necessary. It is quite reasonable for the compiler to compute the entire array, use element 7, discard it, and insert code to compute it at run-time in the scope in which it is used, rather than bloating the binary with the whole computed array. I believe this is not a theoretical issue; I've observed it with various compilers in various contexts. <code>constexpr</code> does <em>not</em> imply <code>static</code>.</p>\n<p>Of course, if the compiler can determine that the array is not used at runtime, it might not even insert code to compute it, but that's yet another issue.</p>\n<p>If you do use such an object at run-time, and you want to indicate to the compiler that it would be worth keeping it around for the duration of the program, you should declare it as <code>static</code>.</p>\n", "LastActivityDate": "2012-11-27T06:41:11.573", "CommentCount": "1", "CreationDate": "2012-11-27T06:41:11.573", "ParentId": "13571749", "Score": "4", "OwnerUserId": "1566221"}, "bq_ids": {"n4140": {"so_13571749_13784100_4": {"length": 43, "quality": 0.8958333333333334, "section_id": 5908}, "so_13571749_13784100_3": {"length": 26, "quality": 0.5909090909090909, "section_id": 6188}, "so_13571749_13784100_2": {"length": 37, "quality": 0.8409090909090909, "section_id": 5425}}, "n3337": {"so_13571749_13784100_2": {"length": 42, "quality": 0.9545454545454546, "section_id": 5220}, "so_13571749_13784100_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 6895}, "so_13571749_13784100_3": {"length": 40, "quality": 0.9090909090909091, "section_id": 5948}, "so_13571749_13784100_4": {"length": 43, "quality": 0.8958333333333334, "section_id": 5680}, "so_13571749_13578205_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 5946}}, "n4659": {"so_13571749_13784100_3": {"length": 26, "quality": 0.5909090909090909, "section_id": 7691}, "so_13571749_13784100_4": {"length": 25, "quality": 0.5208333333333334, "section_id": 7390}}}, "13578446": {"Id": "13578446", "PostTypeId": "2", "Body": "<p>It is \"allowed\" to evaluate the <code>constexpr</code> call at compile time whenever it is actually possible to do so. Remember that the specification operates under the \"as if\" rule. So if you can't tell the difference, the compiler can do whatever it wants.</p>\n<p>The compiler is <em>required</em> to evaluate <code>constexpr</code> calls at compile time when it actually <em>needs</em> the answer at compile time. For example:</p>\n<pre><code>constexpr int foo() {return 5;}\n\nstd::array&lt;float, foo()&gt; arr;\n</code></pre>\n<p>The compiler needs to know the array size at compile time. Therefore, it must evaluate the constant expression at compile time. If the <code>constexpr</code> function cannot be executed at compile time, you get a compile-time error.</p>\n", "LastActivityDate": "2012-11-27T06:18:55.433", "CommentCount": "3", "CreationDate": "2012-11-27T06:18:55.433", "ParentId": "13571749", "Score": "6", "OwnerUserId": "734069"}, "13578205": {"Id": "13578205", "PostTypeId": "2", "Body": "<p>I don't think it's forced anywhere. I had a look too, it's tricky because there's not one paper on constexpr in that list; they all seem to add/remove from the previous collection of papers.</p>\n<p>I think the general idea is when the inputs to the constexpr function are constexpr themselves, it'll all be done at compile time; and by extension non-function constexpr statements, which are literal anyway will be run at compile time if you're using a half intelligent compiler.</p>\n<blockquote>\n<p id=\"so_13571749_13578205_0\">If a constexpr function or constructor is called with arguments which\n  aren't constant expressions, the call behaves as if the function were\n  not constexpr, and the resulting value is not a constant expression.</p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/C++11#constexpr_-_Generalized_constant_expressions%20-%20which%20in%20turn%20quotes\" rel=\"nofollow\">from wikipedia</a></p>\n<p>which in seem to get the info from <a href=\"http://www.stroustrup.com/sac10-constexpr.pdf\" rel=\"nofollow\">this pdf</a>:</p>\n<blockquote>\n<p id=\"so_13571749_13578205_1\">constexpr functions: A constexpr function is one which is \u201csuf-\n  ficiently simple\u201d so that it delivers a constant expression when\n  called with arguments that are constant values (see \u00a72.1).</p>\n</blockquote>\n", "LastActivityDate": "2012-11-27T05:58:55.797", "CommentCount": "1", "CreationDate": "2012-11-27T05:58:55.797", "ParentId": "13571749", "Score": "1", "OwnerUserId": "602340"}, "13784100": {"Id": "13784100", "PostTypeId": "2", "Body": "<p>By combing the FDIS I have found three places that specify where a constexpr expression must be evaluated during translation.</p>\n<p><strong>Section 3.6.2 Initialization of non-local variables</strong>, paragraph 2 says if an object with static or thread local storage duration is initialized with a <code>constexpr</code> constructor then the constructor is evaluated during translation:</p>\n<blockquote>\n<p id=\"so_13571749_13784100_0\"><em>Constant initialization</em> is performed:</p>\n<blockquote id=\"so_13571749_13784100_1\">\n<ul>\n<li>if an object with static or thread storage duration is initialized by a constructor call, if the constructor is a <code>constexpr</code> constructor, if all constructor arguments are constant expressions (including conversions), and if, after function invocation substitution (7.1.5), every constructor call and full-expression in the <em>mem-initializers</em> is a constant expression;</li>\n</ul>\n</blockquote>\n</blockquote>\n<p><strong>Section 7.1.5 The constexpr specifier</strong>, paragraph 9 says if an object declaration includes the <code>constexpr</code> specifier, that object is evaluated during translation (i.e., is a literal):</p>\n<blockquote>\n<p id=\"so_13571749_13784100_2\">A <code>constexpr</code> specifier used in an object declaration declares the object as const. Such an object shall have literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19). Otherwise, every full-expression that appears in its initializer shall be a constant expression. Each implicit conversion used in converting the initializer expressions and each constructor call used for the initialization shall be one of those allowed in a constant expression (5.19).</p>\n</blockquote>\n<p>I\u2019ve heard people argue that this paragraph leaves room for an implementation to postpone the initialization until runtime unless the effect can be detected during translation due to, say, a <code>static_assert</code>.  That is probably not an accurate view because whether a value is initialized during translation is, under some circumstances, observable.  This view is reinforced by <strong>Section 5.19 Constant expressions</strong> paragraph 4:</p>\n<blockquote>\n<p id=\"so_13571749_13784100_3\">[ <em>Note:</em> Although in some contexts constant expressions must be evaluated during program translation, others may be evaluated during program execution. Since this International Standard imposes no restrictions on the accuracy of floating-point operations, it is unspecified whether the evaluation of a floating-point expression during translation yields the same result as the evaluation of the same expression (or the same operations on the same values) during program execution... \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p><strong>Section 9.4.2 Static data members</strong>, paragraph 3 says if a const static data member of literal type is initialized by a constexpr function or constructor, then that function or constructor must be evaluated during translation:</p>\n<blockquote>\n<p id=\"so_13571749_13784100_4\">If a static data member is of const literal type, its declaration in the class definition can specify a <em>brace-orequal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. A static data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an assignment-expression is a constant expression. [ <em>Note:</em> In both these cases, the member may appear in constant expressions. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Interestingly, I did not find anything in the FDIS that required a <code>constexpr</code> expression to be evaluated if its result is used as an array dimension.  I'm quite sure the standard committee expects that to be the case.  But I also could have missed that in my search.</p>\n<p>Outside of those circumstances the C++11 standard <em>allows</em> computations in constexpr functions and constructors to be performed during translation.  But it does not require it.  The computations could occur at runtime.  Which computations the compiler performs during translation are, to a certain extent, a quality of implementation question.</p>\n<p>In all three of the situations I located, the trigger for translation-time evaluation is based on the requirements of the target using the result of the <code>constexpr</code> call.  Whether or not the arguments to the <code>constexpr</code> function are literal is never considered (although it is a pre-requisite for valid evaluation).</p>\n<p>So, to get to the real point of this, it appears that <code>constexpr</code> evaluation during translation is triggered by:</p>\n<ul>\n<li>The implied object argument during overload resolution (Section 13.3.1 Paragraph 3) is either constexpr or requires a literal.</li>\n</ul>\n<p>I hope that's helpful to someone besides me.  Thanks to everyone who contributed.</p>\n", "LastActivityDate": "2012-12-09T02:31:03.890", "CommentCount": "0", "CreationDate": "2012-12-09T02:31:03.890", "ParentId": "13571749", "Score": "4", "OwnerUserId": "1854241"}});