post_cb({"bq_ids": {"n4140": {"so_48707481_48707481_2": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_48707481_48707481_5": {"length": 17, "quality": 1.0, "section_id": 7195}, "so_48707481_48707481_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}, "so_48707481_48707481_4": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_48707481_48707481_1": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_48707481_48707481_3": {"length": 9, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_48707481_48707481_2": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_48707481_48707481_5": {"length": 17, "quality": 1.0, "section_id": 6939}, "so_48707481_48707481_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}, "so_48707481_48707481_4": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_48707481_48707481_1": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_48707481_48707481_3": {"length": 9, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_48707481_48707481_2": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_48707481_48707481_5": {"length": 17, "quality": 1.0, "section_id": 8704}, "so_48707481_48707481_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}, "so_48707481_48707481_4": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_48707481_48707481_1": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_48707481_48707481_3": {"length": 9, "quality": 1.0, "section_id": 8704}}}, "48707481": {"ViewCount": "148", "Body": "<p>I saw a presentation on cppcon of <a href=\"https://youtu.be/ehyHyAIa5so?list=PLHTh1InhhwT6bwIpRk0ZbCA0N2p1taxd6&amp;t=2802\" rel=\"nofollow noreferrer\">Piotr Padlewski</a> saying that the following is undefined behaviour:</p>\n<pre><code>int test(Base* a){\n  int sum = 0;\n  sum += a-&gt;foo();\n  sum += a-&gt;foo();\n  return sum;\n}\n\nint Base::foo(){\n  new (this) Derived;\n  return 1;\n}\n</code></pre>\n<p>Note: Assume <code>sizeof(Base) == sizeof(Derived)</code> and <code>foo</code> is virtual.</p>\n<p>Obviously this is bad, but I'm interested in WHY it is UB. I do understand the UB on accessing a <code>realloc</code>ed pointer but he says, that this is the same.</p>\n<p>Related questions: <a href=\"https://stackoverflow.com/questions/6224121/is-new-this-myclass-undefined-behaviour-after-directly-calling-the-destru\">Is `new (this) MyClass();` undefined behaviour after directly calling the destructor?</a> where it says \"ok if no exceptions\"\n<a href=\"https://stackoverflow.com/questions/6036086/is-it-valid-to-directly-call-a-virtual-destructor\">Is it valid to directly call a (virtual) destructor?</a> Where it says <code>new (this) MyClass();</code> results in UB. (contrary to the above question)</p>\n<p><a href=\"https://stackoverflow.com/questions/27552466/c-is-constructing-object-twice-using-placement-new-undefined-behaviour\">C++ Is constructing object twice using placement new undefined behaviour?</a> it says:</p>\n<blockquote>\n<p id=\"so_48707481_48707481_0\">A program may end the lifetime of any object by reusing the storage\n  which the object occupies or by explicitly calling the destructor for\n  an object of a class type with a non-trivial destructor. For an object\n  of a class type with a non-trivial destructor, the program is not\n  required to call the destructor explicitly before the storage which\n  the object occupies is reused or released; however, if there is no\n  explicit call to the destructor or if a delete-expression (5.3.5) is\n  not used to release the storage, the destructor shall not be\n  implicitly called and any program that depends on the side effects\n  produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>which again sounds like it is ok.</p>\n<p>I found another description of the placement new in <a href=\"https://stackoverflow.com/questions/47473621/placement-new-and-assignment-of-class-with-const-member\">Placement new and assignment of class with const member</a></p>\n<blockquote>\n<p id=\"so_48707481_48707481_1\">If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_48707481_48707481_2\">the storage for the new object exactly overlays the storage location which the original object occupied, and</p></li>\n<li><p id=\"so_48707481_48707481_3\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p></li>\n<li><p id=\"so_48707481_48707481_4\">the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is\n  const-qualified or a reference type, and</p></li>\n<li><p id=\"so_48707481_48707481_5\">the original object was a most derived object of type T and the new object is a most derived object of type T (that is, they are not\n  base class subobjects).</p></li>\n</ul>\n</blockquote>\n<p>This seems to explain the UB. But is really true?</p>\n<p>Doesn't this mean, that I could not have a <code>std::vector&lt;Base&gt;</code>? Because I assume due to its pre-allocation <code>std::vector</code> must rely on <code>placement-new</code>s and explicit ctors. And point 4 requires it to be the most-derived type which <code>Base</code> clearly isn't.</p>\n", "Title": "Undefined behaviour on reinitializing object via placement new on this pointer", "CreationDate": "2018-02-09T13:54:38.727", "LastActivityDate": "2018-02-09T16:48:13.707", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-09T16:48:13.707", "LastEditorUserId": "1930508", "Id": "48707481", "Score": "7", "OwnerUserId": "1930508", "Tags": "<c++><language-lawyer><destructor><placement-new>", "AnswerCount": "2"}, "48709830": {"Id": "48709830", "PostTypeId": "2", "Body": "<p>I believe Elizabeth Barret Browning said it best. Let me count the ways.</p>\n<ol>\n<li>If <code>Base</code> isn't trivially destructible, we're failing to cleanup resources. </li>\n<li>If <code>sizeof(Derived)</code> is larger than the size of the dynamic type of <code>this</code>, we're going to clobber other memory. </li>\n<li>If <code>Base</code> isn't the first subobject of <code>Derived</code>, then the storage for the new object won't exactly overlay the original storage, and you'd also end up clobbering other memory.</li>\n<li>If <code>Derived</code> is just a different type from the initial dynamic type, even if it's the same size, than the object that we're calling <code>foo()</code> on <a href=\"http://eel.is/c++draft/basic.memobj#basic.life-8\" rel=\"nofollow noreferrer\">cannot be used</a> to refer to the new object. The same is true if any of the members of <code>Base</code> or <code>Derived</code> are <code>const</code> qualified or are references. You'd need to <code>std::launder</code> any external pointers/references.</li>\n</ol>\n<p>However, if <code>sizeof(Base) == sizeof(Derived)</code>, and <code>Derived</code> is trivially destructible, <code>Base</code> is the first subobject of <code>Derived</code>, and you only actually have <code>Derived</code> objects... this is fine. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2018-02-09T16:38:21.830", "Score": "3", "CreationDate": "2018-02-09T16:10:02.553", "ParentId": "48707481", "CommentCount": "5", "OwnerUserId": "2069064", "LastEditDate": "2018-02-09T16:38:21.830"}, "48708279": {"Id": "48708279", "PostTypeId": "2", "Body": "<p>Regarding your question</p>\n<blockquote>\n<p id=\"so_48707481_48708279_0\">...Because I assume due to its pre-allocation std::vector must rely on\n  placement-news and explicit ctors. And point 4 requires it to be the\n  most-derived type which Base clearly isn't. And point 4 requires it to\n  be the most-derived type which Base clearly isn't.</p>\n</blockquote>\n<p>, I think the misunderstanding comes from the term \"most derived object\" or \"most derived type\":</p>\n<p>The \"most derived type\" of an object of class type is the class with which the object was instantiated, regardless of whether this class has further subclasses or not. Consider the following program:</p>\n<pre><code>struct A {\n    virtual void foo() { cout &lt;&lt; \"A\" &lt;&lt; endl; };\n};\n\nstruct B : public A {\n    virtual void foo() { cout &lt;&lt; \"B\" &lt;&lt; endl; };\n};\n\nstruct C : public B {\n    virtual void foo() { cout &lt;&lt; \"C\" &lt;&lt; endl; };\n};\n\nint main() {\n\n    B b;  // b is-a B, but it also is-an A (referred  to as a base object of b).\n          // The most derived class of b is, however, B, and not A and not C.\n}\n</code></pre>\n<p>When you now create a <code>vector&lt;B&gt;</code>, then the elements of this vector will be instances of class <code>B</code>, and so the most derived type of the elements will always be <code>B</code>, and not <code>C</code> (or <code>Derived</code>) in your case.</p>\n<p>Hope this brings some light in.</p>\n", "LastActivityDate": "2018-02-09T14:42:22.357", "CommentCount": "1", "CreationDate": "2018-02-09T14:42:22.357", "ParentId": "48707481", "Score": "2", "OwnerUserId": "2630032"}});