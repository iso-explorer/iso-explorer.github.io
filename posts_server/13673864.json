post_cb({"bq_ids": {"n4140": {"so_13673864_13673954_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7136}, "so_13673864_13673954_1": {"length": 27, "quality": 1.0, "section_id": 7137}}, "n3337": {"so_13673864_13673954_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6880}, "so_13673864_13673954_1": {"length": 27, "quality": 1.0, "section_id": 6881}}, "n4659": {"so_13673864_13673954_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8637}, "so_13673864_13673954_1": {"length": 27, "quality": 1.0, "section_id": 8638}}}, "13673864": {"ViewCount": "654", "Body": "<blockquote>\n<p id=\"so_13673864_13673864_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions\">Unnamed/anonymous namespaces vs. static functions</a> </br></p>\n</blockquote>\n<p>Is this completely redundant, or may there be a reason to do this?</p>\n<pre><code>namespace {\n  static void f() {\n    ...\n  }\n}\n</code></pre>\n", "AcceptedAnswerId": "13673954", "Title": "Static and anonymous namespace", "CreationDate": "2012-12-02T21:08:33.177", "Id": "13673864", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:16:13.477", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-02T21:28:51.617", "ClosedDate": "2012-12-03T00:23:39.243", "Score": "7", "OwnerUserId": "331785", "Tags": "<c++>", "AnswerCount": "1"}, "13673954": {"Id": "13673954", "PostTypeId": "2", "Body": "<p>It looks redundant to me -- either being declared static or being in an anonymous namespace means it has internal linkage.</p>\n<p>\u00a73.5/3: </p>\n<blockquote>\n<p id=\"so_13673864_13673954_0\">A name having namespace scope (3.3.6) has internal linkage if it is the name of:<br>\n  \u2014 a variable, function or function template that is explicitly declared static;</br></p>\n</blockquote>\n<p>\u00a73.5/4:</p>\n<blockquote>\n<p id=\"so_13673864_13673954_1\">[...] An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. [...] A name having namespace scope that has not\n  been given internal linkage above has the same linkage as the enclosing namespace if it is the name of<br>\n      \u2014 a variable; or<br>\n      \u2014 a function; or</br></br></p>\n</blockquote>\n<p>So, as it is right now, it has internal linkage because it's explicitly declared static. If it wasn't explicitly declared static, it would have internal linkage because it's declared inside an unnamed namespace. Same effect either way.</p>\n<p>Note that here I'm replying specifically about a function -- there are a <em>few</em> obscure cases where there's a difference when you're dealing with the name of a type (e.g., class/struct/union), but I don't know of any such thing that applies in the case of a function.</p>\n<p>As far as what internal linkage really means, that's one of those places the standard is actually quite direct and clear. It's probably best to quote the definitions of all three possibilities (\u00a73.5/2):</p>\n<ol>\n<li>When a name has <em>external linkage</em>, the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</li>\n<li>When a name has <em>internal linkage</em>, the entity it denotes can be referred to by names from other scopes in the same translation unit.</li>\n<li>When a name has <em>no linkage</em>, the entity it denotes cannot be referred to by names from other scopes.</li>\n</ol>\n<p>Note that the italics above match those in the standard, which is its way of saying that these sentences define what those phrases mean throughout the rest of the standard.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2012-12-02T21:28:51.617", "Score": "2", "CreationDate": "2012-12-02T21:19:22.877", "ParentId": "13673864", "CommentCount": "0", "OwnerUserId": "179910", "LastEditDate": "2012-12-02T21:28:51.617"}});