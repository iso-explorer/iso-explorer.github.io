post_cb({"3786481": {"PostTypeId": "2", "Body": "<p>ISO C++03 14.2/4:</p>\n<blockquote>\n<p id=\"so_3786360_3786481_0\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), <strong>the member template name must be prefixed by the keyword template</strong>. Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>In <code>t-&gt;f0&lt;U&gt;();</code> <code>f0&lt;U&gt;</code> is a member template specialization which appears after <code>-&gt;</code> and which explicitly depends on template parameter <code>U</code>, so the member template specialization must be prefixed by <code>template</code> keyword.</p>\n<p>So change <code>t-&gt;f0&lt;U&gt;()</code> to <code>t-&gt;template f0&lt;U&gt;()</code>.</p>\n", "LastActivityDate": "2012-08-02T13:48:33.077", "LastEditorUserId": "1511477", "Id": "3786481", "CommentCount": "2", "CreationDate": "2010-09-24T11:14:49.927", "ParentId": "3786360", "Score": "63", "OwnerUserId": "165520", "LastEditDate": "2012-08-02T13:48:33.077"}, "3786360": {"ViewCount": "14497", "Body": "<p>I've been playing with clang a while, and I stumbled upon \"test/SemaTemplate/dependent-template-recover.cpp\" (in the clang distribution) which is supposed to provide hints to recover from a template error.</p>\n<p>The whole thing can be easily stripped down to a minimal example:</p>\n<pre><code>template&lt;typename T, typename U, int N&gt; struct X {\n    void f(T* t)\n    {\n        // expected-error{{use 'template' keyword to treat 'f0' as a dependent template name}}\n        t-&gt;f0&lt;U&gt;();\n    }\n};\n</code></pre>\n<p>The error message yielded by clang:</p>\n<pre><code>tpl.cpp:6:13: error: use 'template' keyword to treat 'f0' as a dependent template name\n         t-&gt;f0&lt;U&gt;();\n            ^\n            template \n1 error generated.\n</code></pre>\n<p>... But I have a hard time understanding where exactly one is supposed to insert the <code>template</code> keyword to have the code to be syntactically correct?</p>\n", "AcceptedAnswerId": "3786481", "Title": "Confusing Template error", "CreationDate": "2010-09-24T10:59:48.830", "Id": "3786360", "CommentCount": "2", "LastEditDate": "2010-09-24T11:16:33.043", "PostTypeId": "1", "OwnerDisplayName": "user350814", "LastEditorUserId": "165520", "LastActivityDate": "2012-08-02T13:48:33.077", "AnswerCount": "4", "Score": "65", "Tags": "<c++><templates><llvm><clang>", "FavoriteCount": "16"}, "bq_ids": {"n4140": {"so_3786360_3786481_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}}, "n3337": {"so_3786360_3786481_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}}}, "3786726": {"PostTypeId": "2", "Body": "<p>In addition to the points others made, notice that sometimes the compiler couldn't make up his mind and both interpretations can yield alternative valid programs when instantiating</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct A {\n  typedef int R();\n\n  template&lt;typename U&gt;\n  static U *f(int) { \n    return 0; \n  }\n\n  static int f() { \n    return 0;\n  }\n};\n\ntemplate&lt;typename T&gt;\nbool g() {\n  A&lt;T&gt; a;\n  return !(typename A&lt;T&gt;::R*)a.f&lt;int()&gt;(0);\n}\n\n\nint main() {\n  std::cout &lt;&lt; g&lt;void&gt;() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This prints <code>0</code> when omitting <code>template</code> before <code>f&lt;int()&gt;</code> but <code>1</code> when inserting it. I leave it as an exercise to figure out what the code does. </p>\n", "LastActivityDate": "2010-09-24T12:22:26.630", "LastEditorUserId": "34509", "Id": "3786726", "CommentCount": "5", "CreationDate": "2010-09-24T11:46:12.240", "ParentId": "3786360", "Score": "18", "OwnerUserId": "34509", "LastEditDate": "2010-09-24T12:22:26.630"}, "3786454": {"PostTypeId": "2", "Body": "<p>Excerpt from <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"noreferrer\">C++ Templates</a></p>\n<p>The .template Construct\nA very similar problem was discovered after the introduction of typename. Consider the following example using the standard bitset type:</p>\n<pre><code>template&lt;int N&gt; \nvoid printBitset (std::bitset&lt;N&gt; const&amp; bs) \n{ \n    std::cout &lt;&lt; bs.template to_string&lt;char,char_traits&lt;char&gt;, \n                                       allocator&lt;char&gt; &gt;(); \n} \n</code></pre>\n<p>The strange construct in this example is .template. Without that extra use of template, the compiler does not know that the less-than token (&lt;) that follows is not really \"less than\" but the beginning of a template argument list. Note that this is a problem only if the construct before the period depends on a template parameter. In our example, the parameter bs depends on the template parameter N.</p>\n<p><strong>In conclusion, the .template notation (and similar notations such as -&gt;template) should be used only inside templates and only if they follow something that depends on a template parameter.</strong></p>\n", "LastActivityDate": "2010-09-24T11:11:58.873", "Id": "3786454", "CommentCount": "1", "CreationDate": "2010-09-24T11:11:58.873", "ParentId": "3786360", "Score": "6", "OwnerUserId": "418110"}, "3786370": {"PostTypeId": "2", "Body": "<p>Insert it just before the point where the caret is:</p>\n<pre><code>template&lt;typename T, typename U, int N&gt; struct X {\n     void f(T* t)\n     {\n        t-&gt;template f0&lt;U&gt;();\n     }\n};\n</code></pre>\n<p>Edit: the reason for this rule becomes clearer if you think like a compiler. <strike>Compilers generally only look ahead one or two tokens at once, and don't generally \"look ahead\" to the rest of the expression.</strike>[Edit: see comment] The reason for the keyword is the same as why you need the <code>typename</code> keyword to indicate dependent type names: it's telling the compiler \"hey, the identifier you're about to see is the name of a template, rather than the name of a static data member followed by a less-than sign\".</p>\n", "LastActivityDate": "2010-09-24T11:34:14.920", "LastEditorUserId": "51305", "Id": "3786370", "CommentCount": "3", "CreationDate": "2010-09-24T11:01:24.373", "ParentId": "3786360", "Score": "7", "OwnerUserId": "51305", "LastEditDate": "2010-09-24T11:34:14.920"}});