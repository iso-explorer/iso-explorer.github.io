post_cb({"30019483": {"ParentId": "30019454", "CommentCount": "1", "Body": "<p>From [class.bit]:</p>\n<blockquote>\n<p id=\"so_30019454_30019483_0\">A non-const reference shall not be bound to a\n  bit-field (8.5.3).</p>\n</blockquote>\n<p>So you simply cannot bind a <code>uint8_t&amp;</code> to any of your bits. You should consider instead using <a href=\"http://en.cppreference.com/w/cpp/utility/bitset\" rel=\"nofollow\"><code>std::bitset</code></a>, which solves this problem by using proxy objects (<a href=\"http://en.cppreference.com/w/cpp/utility/bitset/reference\" rel=\"nofollow\"><code>std::bitset::reference</code></a>). </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30019483", "Score": "1", "CreationDate": "2015-05-03T21:13:55.210", "LastActivityDate": "2015-05-03T21:13:55.210"}, "30024047": {"ParentId": "30019454", "CommentCount": "1", "Body": "<p>As has already been noted you can't bind a bit-field to a non-const reference. Since you're targeting the Arduino using <code>std::bitset</code> may not be a viable option depending on how much control you need over functionality or access to the data.</p>\n<p>There are a couple of things i want to note though. First I don't recommend using C++ bit-fields for this. They're good if you need named access to the bits but in this case I think there are more maintainable ways to accomplish what you want. Second, returning <code>uint8_t</code> or a reference to one from the index operators seems goofy, especially since you're actually working with boolean values.</p>\n<p>Since you are working with individual bits you'll need to use a proxy object to sets and retrieve the individual bits without affecting all values in the bit-field. By providing a conversion operator and assignment operator for <code>bool</code> types you can provide seamless access to the bit values. Something like the following should work for you.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n\nclass Bits\n{\n    typedef std::uint8_t value_type;\n\n    value_type   bits;\n\n    struct Twiddler\n    {\n        Twiddler(value_type&amp; value, size_t bitIndex)\n            : value(value), mask(1 &lt;&lt; bitIndex)\n        {}\n\n        Twiddler&amp; operator=(const Twiddler&amp;) = delete;\n        Twiddler&amp; operator=(bool bit)\n        {\n            value = value &amp; ~mask | static_cast&lt;value_type&gt;(bit ? mask : 0);\n            return *this;\n        }\n\n        operator bool() { return (value &amp; mask) != 0; }\n\n    private:\n\n        value_type&amp; value;\n        value_type mask;\n    };\n\n    struct ConstTwiddler\n    {\n        ConstTwiddler(const value_type&amp; value, size_t bitIndex)\n            : value(value), mask(1 &lt;&lt; bitIndex)\n        {}\n        ConstTwiddler&amp; operator=(const ConstTwiddler&amp;) = delete;\n        operator bool() { return (value &amp; mask) != 0; }\n\n    private:\n\n        const value_type&amp; value;\n        value_type mask;\n    };\n\npublic:\n\n    Bits() : bits() {}\n    Bits(value_type bits) : bits(bits) {}\n\n    size_t size() const { return sizeof(bits) * 8; }\n\n    Twiddler operator[](size_t index)\n    {\n        if (index &gt;= size())\n        {\n            throw std::out_of_range(\"Invalid bit index\");\n        }\n        return Twiddler(bits, index);\n    }\n\n    const ConstTwiddler operator[](size_t index) const\n    {\n        if (index &gt;= size())\n        {\n            throw std::out_of_range(\"Invalid bit index\");\n        }\n        return ConstTwiddler(bits, index);\n    }\n};\n</code></pre>\n", "OwnerUserId": "845568", "PostTypeId": "2", "Id": "30024047", "Score": "1", "CreationDate": "2015-05-04T06:43:11.527", "LastActivityDate": "2015-05-04T06:43:11.527"}, "bq_ids": {"n4140": {"so_30019454_30019483_0": {"section_id": 5923, "quality": 0.8, "length": 4}}, "n3337": {"so_30019454_30019483_0": {"section_id": 5695, "quality": 0.8, "length": 4}}, "n4659": {"so_30019454_30019483_0": {"section_id": 7397, "quality": 0.8, "length": 4}}}, "30019454": {"CommentCount": "2", "ViewCount": "268", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-05-03T21:11:00.110", "LastActivityDate": "2015-05-04T06:43:11.527", "Title": "operator[] overload in bit-field manipulation?", "AcceptedAnswerId": "30024047", "LastEditDate": "2015-05-03T21:16:28.137", "Id": "30019454", "Score": "1", "Body": "<p>I am working on an arduino-like platform (very limited RAM), and I need to use a bit-field. I need to modify a specific bit in a byte, with something like this:</p>\n<pre><code>OneByte myByte = 0b11101111;\nmyByte[5] = 1;\n</code></pre>\n<p>To achieve this, I wrote the following:</p>\n<pre><code>typedef struct {\n    uint8_t bit0:1;\n    uint8_t bit1:1;\n    uint8_t bit2:1;\n    uint8_t bit3:1;\n    uint8_t bit4:1;\n    uint8_t bit5:1;\n    uint8_t bit6:1;\n    uint8_t bit7:1;\n} BitByte;\n\ntypedef union {\n    BitByte asBits;\n    uint8_t asByte;\n} BitField;\n\nclass OneByte\n{\npublic:\n\n    OneByte();      // default constructor\n    ~OneByte();     // delete\n\n    // Assignment operator\n    uint8_t&amp; operator[] (const uint8_t pos  );\n    uint8_t  operator[] (const uint8_t pos  ) const;\n\nprivate:\n    BitField oneByte;\n};\n</code></pre>\n<p>and in the .cpp I put</p>\n<pre><code>// I know a switch case is horrible, but don't want to think too much\n// pos shoud always be between 0 and 7\nuint8_t&amp; OneByte::operator[] (const uint8_t pos  )  \n{\n    if (pos &lt; ByteSize)\n    {\n        switch (pos)\n        {\n            case 0:\n                return oneByte.asBits.bit0;\n                break;\n            case 1:\n                return oneByte.asBits.bit1;\n                break;\n            case 2:\n                return oneByte.asBits.bit2;\n                break;\n            case 3:\n                return oneByte.asBits.bit3;\n                break;\n            case 4:\n                return oneByte.asBits.bit4;\n                break;\n            case 5:\n                return oneByte.asBits.bit5;\n                break;\n            case 6:\n                return oneByte.asBits.bit6;\n                break;\n            case 7:\n                return oneByte.asBits.bit7;\n                break;\n        }\n    }\n    // If goes here, do some error handling\n}\n</code></pre>\n<p>The <code>uint8_t  operator[] (const uint8_t pos  ) const;</code> works fine, but the problem is with</p>\n<pre><code>uint8_t&amp; operator[] (const uint8_t pos  );\n</code></pre>\n<p>which fails to compile with the error:</p>\n<pre><code>error: cannot bind bitfield \u2018((OneByte*)this)-&gt;OneByte::oneByte.BitField::asBits.BitByte::bit0\u2019 to \u2018uint8_t&amp; {aka unsigned char&amp;}\u2019\n</code></pre>\n<p>I don't really know what to do in this case... Maybe make another class to wrap this one so I don't use the <code>operator[]</code> overload?</p>\n", "Tags": "<c++><operator-overloading><bit-fields>", "OwnerUserId": "4753483", "AnswerCount": "2"}});