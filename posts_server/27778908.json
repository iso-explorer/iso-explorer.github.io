post_cb({"27778908": {"CommentCount": "9", "ViewCount": "3296", "ClosedDate": "2015-01-05T15:00:43.377", "CreationDate": "2015-01-05T11:48:33.593", "LastActivityDate": "2015-01-05T15:00:33.200", "PostTypeId": "1", "FavoriteCount": "4", "Title": "Define private to public in C++", "Id": "27778908", "Score": "2", "Body": "<p>I want to define private and protected to public.</p>\n<pre><code>#define private public\n#define protected public\n</code></pre>\n<p>Is this safe in C++?</p>\n", "Tags": "<c++>", "OwnerUserId": "4419862", "AnswerCount": "5"}, "27779609": {"ParentId": "27778908", "CommentCount": "1", "Body": "<p>It is allowed only in a translation unit that doesn't in any way (even indirectly) include a standard header, but if you do there are restrictions such as this:</p>\n<blockquote>\n<p id=\"so_27778908_27779609_0\">(17.6.4.3.1) A translation unit shall not #define or #undef names lexically identical to keywords [...]</p>\n</blockquote>\n<p>Regardless of that, it's usually a bad idea - mucking around with access modifiers isn't \"safe\" by any common meaning of the word, even if it won't cause any immediate problems in itself.<br>\nIf you're using library code, there are usually good reasons for things being protected.  </br></p>\n<p>If you want to make things public temporarily, e.g. for testing purposes, you could use a special conditional macro for that part of the class:</p>\n<pre><code>#if TESTING\n#define PRIVATE_TESTABLE public\n#else\n#define PRIVATE_TESTABLE private\n#endif\n\nclass Foo\n{\npublic:\n    Foo();\n    void operation();\nPRIVATE_TESTABLE:\n    int some_internal_operation();\nprivate:\n    int some_internal_data;\n};\n</code></pre>\n", "OwnerUserId": "404970", "PostTypeId": "2", "Id": "27779609", "Score": "2", "CreationDate": "2015-01-05T12:32:02.400", "LastActivityDate": "2015-01-05T12:32:02.400"}, "27779038": {"ParentId": "27778908", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2015-01-05T11:57:07.883", "Score": "8", "LastEditorUserId": "1774667", "LastEditDate": "2015-01-05T15:00:33.200", "Id": "27779038", "OwnerUserId": "1774667", "Body": "<p>No, this almost certainly results in undefined behaviour.</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296</a> 17.6.4.3.1 [macro.names] /2: (via @james below)</p>\n<blockquote>\n<p id=\"so_27778908_27779038_0\">A translation unit shall not <code>#define</code> or <code>#undef</code> names lexically identical to keywords, to the identifiers listed in Table 2, or to the attribute-tokens described in 7.6.</p>\n</blockquote>\n<p><code>private</code> and <code>public</code> are keywords.  Simply doing a <code>#define</code> on one of them is undefined behavior <em>if</em> you use anything in the C++ standard library:</p>\n<p>17.6.4.1/1 [constraints.overview]</p>\n<blockquote>\n<p id=\"so_27778908_27779038_1\">This section describes restrictions on C ++ programs that use the facilities of the C++ standard library.</p>\n</blockquote>\n<p>If you do not, the restriction in 17.6.4.3.1 does not seem to apply.</p>\n<p>The other way it could lead to violation is if you use the same structure with two different definitions.  While most implementations may not care that the two structures are identical other than <code>public</code> vs <code>private</code>, the standard does not make that guarantee.</p>\n<p>Despite that, the most common kind of UB is 'it works', as few compilers care.</p>\n<p>But that does not mean it is 'safe'.  It may be safe in a particular compiler (examine the docs of said compiler: this would be a strange guarantee to give, however!).  Few compilers (if any) will provide the layout guarantees (and mangling guarantees) required for the above to work explicitly if you access the same structure through two different definitions, for example, even if the other possibilities of error are more remote.</p>\n<p>Many compilers will 'just work'.  That does not make it safe: the next compiler version could make one of a myriad of changes and break your code in difficult (or easy) to detect ways.</p>\n<p>Only do something like this if the payoff is large.</p>\n<p>I cannot find evidence that <code>#define</code>ing a keyword is undefined behavior if you never include any standard library headers and do not use it to make a definition different in two compilation units.  So in a highly restricted program, it may be legal.  In practice, even if it legal, it still isn't 'safe', both because that legality is extremely fragile, and because compilers are unlikely to test against that kind of language abuse, or care if it leads to a bug.</p>\n<p>The undefined behavior caused by <code>#define private foo</code> does not seem to be restricted to doing it <em>before</em> the <code>#include</code> of the <code>std</code> header, as an example of how fragile it is.</p>\n", "LastActivityDate": "2015-01-05T15:00:33.200"}, "27779042": {"ParentId": "27778908", "CommentCount": "1", "Body": "<p>There is nothing illegal about doing this, it's just crazy.</p>\n<p>You have to use this definition for all the compilation units (otherwise you might get the linker failing because of the name mangling.</p>\n<p>If you are asking out of curiosity then this is perfectly legal (if confusing) c++; if you are asking because you think this is a good idea so you don't have all those pesky access permissions then you are on a very bad path. There a specific semantic reasons for using protected and private which serve  to reduce he complexity of code and explain the 'contract' that modules have with each other. Using this define makes you code nearly unreadable for practiced c++ programmers.</p>\n", "OwnerUserId": "98636", "PostTypeId": "2", "Id": "27779042", "Score": "1", "CreationDate": "2015-01-05T11:57:28.820", "LastActivityDate": "2015-01-05T11:57:28.820"}, "27779258": {"ParentId": "27778908", "CommentCount": "0", "Body": "<p>Syntax is correct but semantic is wrong.</p>\n", "OwnerUserId": "1698661", "PostTypeId": "2", "Id": "27779258", "Score": "0", "CreationDate": "2015-01-05T12:10:06.620", "LastActivityDate": "2015-01-05T12:10:06.620"}, "bq_ids": {"n4140": {"so_27778908_27779038_0": {"section_id": 6306, "quality": 0.7692307692307693, "length": 10}, "so_27778908_27779609_0": {"section_id": 6306, "quality": 0.6666666666666666, "length": 6}, "so_27778908_27779038_1": {"section_id": 6298, "quality": 0.875, "length": 7}}, "n3337": {"so_27778908_27779038_0": {"section_id": 6063, "quality": 0.7692307692307693, "length": 10}, "so_27778908_27779609_0": {"section_id": 6063, "quality": 0.6666666666666666, "length": 6}, "so_27778908_27779038_1": {"section_id": 6055, "quality": 0.875, "length": 7}}, "n4659": {"so_27778908_27779038_0": {"section_id": 7817, "quality": 0.7692307692307693, "length": 10}, "so_27778908_27779609_0": {"section_id": 7817, "quality": 0.6666666666666666, "length": 6}, "so_27778908_27779038_1": {"section_id": 7807, "quality": 0.875, "length": 7}}}, "27779206": {"ParentId": "27778908", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-05T12:06:47.240", "Score": "0", "LastEditorUserId": "235671", "LastEditDate": "2015-01-05T12:16:57.870", "Id": "27779206", "OwnerUserId": "235671", "Body": "<p>Access modifiers are for humans only so that you by accident don't use a method or field etc. that you are not supposed to access/change.</p>\n<p>You could as well always make everything public if you write new code but in old code it can definitely break something. It would work but it would of course also be more error prone. Imagine what <code>IntelliSense</code> would suggest if you had access to everything everytime. Access modifiers don't only protect code that could break something if you used it in a wrong way but it helps <code>IntelliSense</code> to show you only members that are relevant in a particular context.</p>\n", "LastActivityDate": "2015-01-05T12:16:57.870"}});