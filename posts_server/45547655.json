post_cb({"45547655": {"CommentCount": "1", "AcceptedAnswerId": "45547918", "PostTypeId": "1", "LastEditorUserId": "2378300", "CreationDate": "2017-08-07T13:05:51.977", "LastActivityDate": "2017-08-07T13:32:30.317", "LastEditDate": "2017-08-07T13:32:30.317", "ViewCount": "160", "FavoriteCount": "0", "Title": "Constructing initializer_list by enumerating values contains random values", "Id": "45547655", "Score": "7", "Body": "<p>While thinking about solution for question <a href=\"https://stackoverflow.com/questions/45546362/stdinitializer-list-from-already-existing-stdarray-without-enumerating-each\">std::initializer list from already existing std::array without enumerating each element</a>, I developed similar mechanism as <a href=\"https://stackoverflow.com/a/45547299/3087601\">bolov</a> did, but not constructing the object, but rather only initializer list. I was surprised that my solution did not work and I couldn't figure out why.</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate&lt;typename T, std::size_t N, std::size_t... Is&gt;\nstd::initializer_list&lt;T&gt; array_to_init_list_helper(std::array&lt;T, N&gt; arr, std::index_sequence&lt;Is...&gt;)\n{\n    return {arr[Is]...};\n}\n\ntemplate&lt;typename T, std::size_t N&gt;\nstd::initializer_list&lt;T&gt; array_to_init_list(std::array&lt;T, N&gt; arr)\n{\n    return array_to_init_list_helper(arr, std::make_index_sequence&lt;N&gt;{});\n}\n\nint main()\n{\n    std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};\n    auto init_list = array_to_init_list(arr);\n    for (auto val : init_list)\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n}\n</code></pre>\n<p>I am <a href=\"http://coliru.stacked-crooked.com/a/58e0f0b317483f9e\" rel=\"nofollow noreferrer\">getting random values</a>, while I would expect to get values of <code>arr</code>.</p>\n", "Tags": "<c++><c++11><initializer-list>", "OwnerUserId": "3087601", "AnswerCount": "2"}, "45548083": {"ParentId": "45547655", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45547655_45548083_0\"><strong>[dcl.init.list]/5</strong> An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated an array of <code>N</code> elements of type <code>E</code>, where <code>N</code> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array.</p>\n<p id=\"so_45547655_45548083_1\"><strong>[dcl.init.list]/6</strong> The lifetime of the array is the same as that of the <code>initializer_list</code> object.</p>\n</blockquote>\n<p>This last part is important for your example. <code>array_to_init_list_helper</code> returns a copy of the original <code>initializer_list</code> - but the underlying array's lifetime ends with that of the original. The copy refers to the object whose lifetime has already ended. Your program then exhibits undefined behavior.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "45548083", "Score": "1", "CreationDate": "2017-08-07T13:26:24.920", "LastActivityDate": "2017-08-07T13:26:24.920"}, "45547918": {"ParentId": "45547655", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Going through the assembly <a href=\"https://godbolt.org/g/NqLKxa\" rel=\"nofollow noreferrer\">here</a> (clang 4.0.0) and/or <a href=\"https://godbolt.org/g/gBT8rq\" rel=\"nofollow noreferrer\">here</a> (GCC 7.1), it is clear that the <code>std::initializer_list</code> is using a dangling pointer, which (as we all know) produces seemingly random output.</p>\n<p><strong>EDIT</strong></p>\n<p>This result is of course in line with the comment made by <a href=\"https://stackoverflow.com/users/1670129/igor-tandetnik\">Igor Tandetnik</a>, quoting <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow noreferrer\">cppreference.com</a>:</p>\n<blockquote>\n<p id=\"so_45547655_45547918_0\">The underlying array is a temporary array of type const T[N], in which each element is copy-initialized (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other temporary object, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like binding a reference to a temporary (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory. </p>\n</blockquote>\n", "OwnerUserId": "2378300", "LastEditorUserId": "2378300", "LastEditDate": "2017-08-07T13:23:35.950", "Id": "45547918", "Score": "1", "CreationDate": "2017-08-07T13:18:20.537", "LastActivityDate": "2017-08-07T13:23:35.950"}, "bq_ids": {"n4140": {"so_45547655_45548083_0": {"section_id": 3327, "quality": 0.9666666666666667, "length": 29}, "so_45547655_45548083_1": {"section_id": 3328, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_45547655_45548083_0": {"section_id": 3197, "quality": 0.9666666666666667, "length": 29}, "so_45547655_45548083_1": {"section_id": 3198, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_45547655_45548083_0": {"section_id": 4093, "quality": 0.8666666666666667, "length": 26}, "so_45547655_45548083_1": {"section_id": 4094, "quality": 0.5714285714285714, "length": 4}}}});