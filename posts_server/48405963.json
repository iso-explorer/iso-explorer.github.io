post_cb({"bq_ids": {"n4140": {"so_48405963_48405963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 163}, "so_48405963_48405963_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}}, "n3337": {"so_48405963_48405963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 157}, "so_48405963_48405963_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}}, "n4659": {"so_48405963_48405963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 167}, "so_48405963_48405963_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}}}, "48405963": {"ViewCount": "520", "Body": "<p>Why are the next two template declarations ambiguous (so neither is more specialized than the other)? I know this question has been raised many times on Stack Overflow, but usually, people answer how to resolve ambiguity, not why it's happened.</p>\n<p>I.\n<code>template &lt;class T&gt; void func(char* buf, T size) {}</code></p>\n<p>II.\n<code>template &lt;std::size_t N&gt; void func(char (&amp;buf)[N], std::size_t size) {}</code></p>\n<p>Trying to pass steps of the C++14 standard to resolve partial function template ordering (14.5.6.2):</p>\n<blockquote>\n<p id=\"so_48405963_48405963_0\">To produce the transformed template, for each type, non-type, or template template parameter (including\n  template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively\n  and substitute it for each occurrence of that parameter in the function type of the template.</p>\n</blockquote>\n<p>Transformed function I template's function type is: <code>void func(char*, U1)</code>, where <code>U1</code> is some unique synthetic type.</p>\n<p>Transformed function II template's function type is: <code>void func(char (&amp;buf)[N1], std::size_t)</code>, where <code>N1</code> is some unique synthetic value.</p>\n<blockquote>\n<p id=\"so_48405963_48405963_1\">Using the transformed function template\u2019s function type, perform type deduction against the other template\n  as described in 14.8.2.4.</p>\n</blockquote>\n<p>So let's try to perform type deduction on one side (using the first template as an argument and the second one as a parameter template) and on the opposite side.</p>\n<h2>Case 1.</h2>\n<p>Parameter template: <code>template &lt;std::size_t N&gt; void func(char (&amp;buf)[N], std::size_t size)</code>.\nTransformed argument template: <code>void func(char*, U1)</code>.</p>\n<p>Trying to deduce template parameters. \"<code>char (&amp;buf)[N]</code>\" can't be deduced from \"<code>char*</code>\" type. U1 doesn't match <code>std::size_t</code> type either. Failed.</p>\n<h2>Case 2.</h2>\n<p>Parameter template: <code>template &lt;class T&gt; void func(char* buf, T size)</code>.\nTransformed argument template: <code>void func(char (&amp;buf)[N1], std::size_t)</code>.</p>\n<p>Trying to deduce template parameters. The first argument of parameter template is not type at all and it's compatible with a <code>char[]</code>. <code>T</code> should be deduced to <code>std::size_t</code>.</p>\n<p>So template II should be more specialized and should be selected in the following code:</p>\n<pre><code>char buf[16];\nfunc(buf, static_cast&lt;std::size_t&gt;(16));\n</code></pre>\n<p>Why is this not true for GCC 5.3 and for Clang 4.0?</p>\n", "Title": "Why is a C++ template accepting an array not more specialized than one accepting a pointer according to GCC 5.3 and Clang 4.0?", "CreationDate": "2018-01-23T16:01:02.573", "LastActivityDate": "2018-01-26T15:43:09.383", "CommentCount": "9", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2018-01-26T15:43:09.383", "LastEditorUserId": "34509", "Id": "48405963", "Score": "14", "OwnerUserId": "7029351", "Tags": "<c++><c++11><templates><standards-compliance><partial-ordering>", "AnswerCount": "0"}});