post_cb({"bq_ids": {"n4140": {"so_38999076_39024593_0": {"length": 21, "quality": 1.0, "section_id": 5857}}, "n3337": {"so_38999076_39024593_0": {"length": 21, "quality": 1.0, "section_id": 5627}}, "n4659": {"so_38999076_39024593_0": {"length": 21, "quality": 1.0, "section_id": 7336}}}, "38999076": {"ViewCount": "164", "Body": "<p>I was using an earlier version of Cocos2dx to write a game and compiling it with VS 2013. Note that I'm using CMake and Qt Creator with both compiler versions. When Cocos2dx v3.12 came out, I decided to upgrade the lib to that version in my game and started using VS 2015. Then I started getting this error:</p>\n<blockquote>\n<p id=\"so_38999076_38999076_0\">QCardManager.cpp.obj:-1: error: LNK2001: unresolved external symbol\n  \"public: static class QCard * __cdecl QCard::create(enum PLAYER,struct\n  Question const *,enum CARD_TYPE,int const &amp;)\"\n  (?create@QCard@@SAPAV1@W4PLAYER@@PBUQuestion@@W4CARD_TYPE@@ABH@Z)</p>\n</blockquote>\n<p>And I did not get that error when I was using VS 2013. After a couple of hours of debugging I found out the reason.</p>\n<p>Here's the rough decleration of <code>QCard</code>:</p>\n<pre><code>#include \"2d/CCSprite.h\"\n#include \"CommonVariables.h\"\n\nclass RandomPostureSprite;\nclass Question;\nnamespace cocos2d\n{\nclass Label;\n}\n\nenum class CARD_TYPE {\n    QUESTION,\n    OPTION\n};\n\nclass QCard : public cocos2d::Sprite\n{\npublic:\n    static QCard *create(PLAYER player, const Question *question, CARD_TYPE type, const int &amp;index);\n}\n</code></pre>\n<p>And I had the proper implementation of that function in <code>QCard.cpp</code> file and that file was also properly added to the project.\nSo the problem was the <code>class Question;</code> forward declaration. I included the <code>QuestionParser.h</code> file in <code>QCard.cpp</code> but since I used a forward declaration for <code>QCard</code> in <code>QCard.h</code>, <code>QCardManager.cpp</code> file did not have the implementation for <code>Question</code> and hence the linker error.</p>\n<p>Here's my question: I realize that what VS 2015 does should be the expected behaviour. But why is that behaviour happening? The same code compiles with no error on VS 2013 but not on VS 2015. I read the <a href=\"https://msdn.microsoft.com/en-us/library/bb531344.aspx\" rel=\"nofollow\">Breaking Changes in Visual C++ 2015</a> guide and couldn't not see anything that was related.</p>\n<p><strong>EDIT 1</strong>:\nTurns out the forward declaration should have been <code>struct Question</code> instead of <code>class Question</code>. When I try to use <code>QCard::create</code> in <code>QCardManager.cpp</code> I get the aforementioned linker error. But not in <code>TimerHUD.cpp</code>, which is in the same directory. I'll post the summary contents of them both. Keep in mind that I'm keeping the declaration of <code>QCard</code> the same with this edit.</p>\n<p>The Question struct, which is in <code>QuestionParser.h</code>:</p>\n<pre><code>struct Question {\n    Question()\n        : type()\n        , source()\n        , alias()\n        , color(0, 0, 0)\n    {}\n};\n</code></pre>\n<p><strong>QCardManager.h</strong></p>\n<pre><code>// Cocos2dx\n#include \"math/Vec2.h\"\n#include \"math/CCGeometry.h\"\n// Utilities\n#include \"CommonVariables.h\"\n// Local\n#include \"GameDefinitions.h\"\n#include \"QuestionParser.h\"// This has the Question struct\n\n// Forward declerations\nclass QCard;\nnamespace cocos2d\n{\nclass Layer;\nclass Sprite;\n}\n\nclass QCardManager\n{\n}\n</code></pre>\n<p><strong>QCardManager.cpp</strong></p>\n<pre><code>#include \"QCardManager.h\"\n// Local\n#include \"QCard.h\"\n#include \"RandomPostureSprite.h\"\n// Utilities\n#include \"GameManager.h\"\n#include \"GameSettings.h\"\n#include \"CocosUtils.h\"\n// Cocos2dx\n#include \"cocos2d.h\"\nusing namespace cocos2d;\n\nQCardManager::QCardManager(PLAYER player, Layer &amp;parent)\n{\n    // This line gives the linker error\n    QCard::create(PLAYER::PLAYER_ONE, nullptr, CARD_TYPE::QUESTION, 1);\n}\n</code></pre>\n<p><code>QCardManager</code> raises the linker error. But <code>TimerHUD</code> does not. I'm sharing the contents now.</p>\n<p><strong>TimerHUD.h</strong></p>\n<pre><code>// Cocos2dx\n#include \"2d/CCNode.h\"\n\nnamespace cocos2d\n{\nclass Sprite;\nclass Label;\n}\n\nclass TimerHUD : public cocos2d::Node\n{\n}\n</code></pre>\n<p><strong>TimerHUD.cpp</strong></p>\n<pre><code>// Cocos2dx\n#include \"cocos2d.h\"\n#include \"SimpleAudioEngine.h\"\n// Local\n#include \"GameDefinitions.h\"\n// Utilities\n#include \"GameManager.h\"\n#include \"GameSettings.h\"\n#include \"CocosUtils.h\"\n#include \"QCard.h\"\nusing namespace cocos2d;\n\nTimerHUD::TimerHUD()\n{\n    // This does not raise the linker error\n    QCard::create(PLAYER::PLAYER_ONE, nullptr, CARD_TYPE::QUESTION, 1);\n}\n</code></pre>\n", "AcceptedAnswerId": "39024593", "Title": "LNK2001 on VS 2013 (MSVC 18) but not on VS 2015 (MSVC 19)", "CreationDate": "2016-08-17T14:10:48.530", "Id": "38999076", "CommentCount": "1", "LastEditDate": "2016-08-18T09:29:37.433", "PostTypeId": "1", "LastEditorUserId": "1158719", "LastActivityDate": "2016-08-18T20:15:59.607", "Score": "3", "OwnerUserId": "1158719", "Tags": "<c++><visual-c++>", "AnswerCount": "1"}, "39024593": {"Id": "39024593", "PostTypeId": "2", "Body": "<p>You shouldn't need <code>Question</code>'s definition for this to link properly. The <code>U</code> in <code>@PBUQuestion@</code> and the linker error seem to talk about <code>struct Question</code> instead of <code>class Question</code>, so you have a mismatch between the declaration and definition of <code>Question</code>. If you were to raise your warning level, you'd see that:</p>\n<pre><code>&gt; type a.cpp\nstruct A;\nclass A {};\n\n&gt; cl /Wall a.cpp\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.00.24213.1 for x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\na.cpp\na.cpp(2): warning C4099: 'A': type name first seen using 'struct' now seen using 'class'\na.cpp(2): note: see declaration of 'A'\n</code></pre>\n<p>But because your warning level is too low, you don't get that diagnostic.</p>\n<p>Your code seems to be valid from the <a href=\"https://stackoverflow.com/questions/4866425/mixing-class-and-struct\">standard's point of view</a>. From C++11 9.1/2:</p>\n<blockquote>\n<p id=\"so_38999076_39024593_0\">A <em>declaration</em> consisting solely of <em>class-key identifier;</em> is either a redeclaration of the name in the current scope or a forward declaration of the identifier as a class name. It introduces the class name into the current scope.</p>\n</blockquote>\n<p>However, Visual C++ mangles the name of a function differently depending on whether a name is a <code>class</code> or a <code>struct</code>:</p>\n<pre><code>&gt; undname ?f@@YAXPAUA@@@Z\nvoid __cdecl f(struct A *)\n\n&gt; undname ?f@@YAXPAVA@@@Z\nvoid __cdecl f(class A *)\n</code></pre>\n<p>Note that <code>struct</code> is mangled as <code>U</code> and <code>class</code> as <code>V</code>. This is <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61339\" rel=\"nofollow noreferrer\">definitely a bug in Visual C++</a>, which shouldn't treat <code>class</code> and <code>struct</code> differently.</p>\n<p>Once this is understood, your error is easy to reproduce:</p>\n<pre><code>&gt; type a.cpp\nclass A;          // declares A as a class\nvoid f(A* a);     // declares f(class A*)\n\nint main()\n{\n    f(nullptr);   // calls f(class A*)\n}\n\n\n&gt; type b.cpp\nstruct A {};      // defines A as a struct, mismatch!\nvoid f(A* a) {}   // defines f(struct A*)!\n\n\n&gt; cl /nologo a.cpp b.cpp\na.cpp\nb.cpp\nGenerating Code...\na.obj : error LNK2019: unresolved external symbol\n    \"void __cdecl f(class A *)\" (?f@@YAXPAVA@@@Z) referenced\n        in function _main\na.exe : fatal error LNK1120: 1 unresolved externals\n</code></pre>\n<p>So the reason you're having these weird issues is because the behaviour depends on whether a particular <a href=\"https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c\"><em>translation unit</em></a> (basically, a <code>.cpp</code>) sees <code>Question</code> as a <code>class</code> or a <code>struct</code>. This in turn depends on which headers are included.</p>\n<p>Note that you need the mismatch to be in different translation units. Within the same unit, <a href=\"https://msdn.microsoft.com/en-us/library/695x5bes.aspx\" rel=\"nofollow noreferrer\">Visual C++ will use the the <em>class-key</em> from the definition</a>, even if there are different declarations before:</p>\n<blockquote>\n<p id=\"so_38999076_39024593_1\">Compiler Warning (level 2) C4099</p>\n<p id=\"so_38999076_39024593_2\">'identifier' : type name first seen using 'objecttype1' now seen using 'objecttype2'</p>\n<p id=\"so_38999076_39024593_3\">An object declared as a structure is defined as a class, or an object declared as a class is defined as a structure. The compiler uses the type given in the definition.</p>\n</blockquote>\n<p>As for the reason why this wasn't a problem in Visual C++ 2013, I doubt that the mangling scheme changed recently. It sounds like this bug has been present <a href=\"https://stackoverflow.com/a/5713722/4885801\">since at least 6.0</a>. You may have changed the order of includes inadvertently.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-18T20:15:59.607", "Score": "6", "CreationDate": "2016-08-18T17:50:49.053", "ParentId": "38999076", "CommentCount": "0", "LastEditDate": "2017-05-23T10:28:38.847", "OwnerUserId": "4885801"}});