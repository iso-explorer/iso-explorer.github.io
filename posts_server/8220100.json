post_cb({"8220325": {"Id": "8220325", "PostTypeId": "2", "Body": "<p>An object does not remember how it was created; placement delete is only used when the corresponding placement new throws, otherwise the regular delete operator is used.</p>\n", "LastActivityDate": "2011-11-22T00:10:35.283", "CommentCount": "0", "CreationDate": "2011-11-22T00:10:35.283", "ParentId": "8220100", "Score": "0", "OwnerUserId": "182705"}, "bq_ids": {"n4140": {"so_8220100_8220491_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 6090}}, "n3337": {"so_8220100_8220491_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5858}}, "n4659": {"so_8220100_8220491_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 7586}}}, "8220491": {"Id": "8220491", "PostTypeId": "2", "Body": "<p>As to your first and third question, it IMO works like that:</p>\n<ol>\n<li>Because you didn't use ::new, the compiler tries to find a new operator in the A class.</li>\n<li>It finds one, but it cannot find the proper overload, so it fails.</li>\n</ol>\n<p>If you explicitly state <code>::new</code>, it shouldn't have any problem. The compiler only goes to the global namespace if it cannot find the specialized version of the new operator in the class.</p>\n<p>From the standard: \u00a7 5.3.4,</p>\n<blockquote>\n<p id=\"so_8220100_8220491_0\"><strong>9.</strong> If the new-expression begins with a unary :: operator, the allocation function\u2019s name is looked up in the\n  global scope. Otherwise, if the allocated type is a class type T or array thereof, the allocation function\u2019s\n  name is looked up in the scope of T. If this lookup fails to \ufb01nd the name, or if the allocated type is not a\n  class type, the allocation function\u2019s name is looked up in the global scope.</p>\n</blockquote>\n", "LastEditorUserId": "85371", "LastActivityDate": "2011-11-22T00:49:31.200", "Score": "2", "CreationDate": "2011-11-22T00:31:08.367", "ParentId": "8220100", "CommentCount": "2", "OwnerUserId": "549315", "LastEditDate": "2011-11-22T00:49:31.200"}, "8220787": {"Id": "8220787", "PostTypeId": "2", "Body": "<p>Let's imagine some scenarios. First off, the following <em>always</em> works:</p>\n<pre><code>A * p1 = ::new A;\n::delete p1;\n\nA * p2 = ::new (addr) A;        // assume \"void * addr\" is valid\np2-&gt;~A();\n</code></pre>\n<p>The global expressions always use the corresponding operators from the global namespace, so we're fine. Note that <strong>there is no \"placement-delete\" expression</strong>. Every placement-constructed object <em>must</em> be destroyed explicitly by calling the destructor.</p>\n<p>Next up, suppose we write:</p>\n<pre><code>A * p3 = new A;\ndelete p3;\n</code></pre>\n<p>This time round, the allocation function <code>operator new(size_t)</code> is looked up in the <code>A</code>'s scope first. The name exists, but if you remove the correct overload, you have an error. (This answers Q1 and Q3.) The same goes for <code>operator delete()</code>. There's no particular reason why the one-parameter version (<code>(void *)</code>) is preferred over the two-argument version (<code>(void *, size_t)</code>); you should just have one of the two. (Note also that there's no <em>global</em> version of the two-argument function.)</p>\n<p>Finally, let us revisit placement-new expressions. Since <em>there is no placement-delete expression</em>, your final line of code is an error (undefined behaviour): You mustn't <code>delete</code> anything that wasn't obtained through a default-<code>new</code> expression. If you define a placement-new allocation function, you should also define the matching deallocation function. This function will only be called automatically on one specific situation, though: If a placement-new expression <code>new (a, b, c) Foo;</code> causes the constructor to throw an exception, <em>then</em> the corresponding deallocation function is called. Otherwise, since all placement-construction is manual, you will typically only call the placement deallocation function manually (and often never at all, because it rarely does any actual work).</p>\n<p>The typical scenario might be something like this:</p>\n<pre><code>void * addr = ::operator new(sizeof(Foo)); // do real work\n\nFoo * p = new (addr, true, 'a') Foo;       // calls Foo::operator new(void*, bool, char);,\n                                           // then calls the constructor Foo::Foo()\n\n// in case of exception, call Foo::operator delete(addr, true, 'a')\n\np-&gt;~Foo();\n\nFoo::operator delete(addr, true, 'a');      // rarely seen in practice, often no purpose\n\n::operator delete(addr);                    // do real work\n</code></pre>\n<p>To come full circle to the opening code example, note that the standard demands that the global <code>::operator delete(void *, void *)</code> do nothing. That is, global placement-new is required to need zero clean-up.</p>\n", "LastActivityDate": "2011-11-22T01:12:51.327", "CommentCount": "0", "CreationDate": "2011-11-22T01:12:51.327", "ParentId": "8220100", "Score": "2", "OwnerUserId": "596781"}, "8220100": {"ViewCount": "1719", "Body": "<p>Consider the following code and the questions below:</p>\n<pre><code>/*\n* GCC 4.4\n*/\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n\n    void* operator new(size_t s) {\n        cout &lt;&lt; \"A::operator new(size_t) called\\n\";\n    }\n\n    void operator delete(void* p) {\n        cout &lt;&lt; \"A::operator delete(void*) called\\n\";\n    }\n\n    void* operator new(size_t s, A* p) {\n        cout &lt;&lt; \"A::operator new(size_t, A*) called\\n\";\n    }\n\n    void operator delete(void* p, size_t s) {\n        cout &lt;&lt; \"A::operator delete(void*, size_t) called\\n\";\n    }\n\n};\n\nvoid* operator new(size_t s) {\n    cout &lt;&lt; \"::operator new(size_t) called\\n\";\n}\n\nvoid operator delete(void* p) {\n    cout &lt;&lt; \"::operator delete(void*) called\\n\";\n}\n\nvoid* operator new(size_t s, A* p) {\n    cout &lt;&lt; \"::operator new(size_t, A*) called\\n\";\n}\n\nvoid operator delete(void* p, size_t s) {\n    cout &lt;&lt; \"::operator delete(void*, size_t) called\\n\";\n}\n\nint main() {    \n    A* p1 = new A(); // See question 1.\n    delete p1; // See question 2.\n    A* p2 = new (p1) A(); // See question 3.\n    delete p2; // See question 4.\n}\n</code></pre>\n<p>The questions below might seem redundant somehow. However, what I am trying to distinguish is what is defined by the C++ standard rules from what is defined by the implementation.</p>\n<ol>\n<li><p><code>operator new(size_t)</code> will be used in any case (taken from A or from the global\n namespace, be it default or not). This is OK.\n Now try to remove <code>void* A::operator new(size_t) {}</code> only: why does the compiler gives:</p>\n<blockquote>\n<p id=\"so_8220100_8220100_0\">error: no matching function for call to \u2018A::operator new(unsigned\n  int)\u2019\n  note: candidates are: static void* A::operator new(size_t, A*)</p>\n</blockquote>\n<p>Connot the compiler pick up <code>::operator new(size_t)</code> from the global\n namespace?</p></li>\n<li><p>Why is <code>operator delete(void*)</code> preferred to <code>operator delete(void*, size_t)</code>\n (when both of those versions are present in the same namespace where <code>operator delete (void*)</code> is taken from)?</p></li>\n<li><p>Why will not the code compile if I remove <code>void* A::operator new(size_t, A*)</code>,\n although there is the same version of the operator defined in the global namespace?</p>\n<blockquote>\n<p id=\"so_8220100_8220100_1\">error: no matching function for call to \u2018A::operator new(unsigned int,\n  A*&amp;)\u2019\n       note: candidates are: static void* A::operator new(size_t)</p>\n</blockquote></li>\n<li><p>Why does the compiler still prefer \n <code>operator delete (void*)</code>, although <code>A::operator new(size_t, A*)</code> has been used\n for getting p2?</p></li>\n</ol>\n", "AcceptedAnswerId": "8220787", "Title": "Questions about operator new() and operator delete()", "CreationDate": "2011-11-21T23:38:29.907", "Id": "8220100", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2011-11-22T01:12:51.327", "Score": "1", "OwnerUserId": "989331", "Tags": "<c++>", "AnswerCount": "3"}});