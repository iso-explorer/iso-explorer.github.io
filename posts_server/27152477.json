post_cb({"27152477": {"ViewCount": "2048", "Body": "<p>I have a singleton:</p>\n<pre><code>struct foo {\n  static foo&amp; instance() {\n    static foo f;\n    return f;\n  }\n};\n</code></pre>\n<p>When re-arranging some code I ended up with this statement \"by error\":</p>\n<pre><code>foo::foo::instance()\n</code></pre>\n<p>But this is deemed correct by my compiler (gcc 4.7). In fact, even <code>foo::foo::foo::instance()</code> compiles. Why?</p>\n", "AcceptedAnswerId": "27152670", "Title": "Calling a static method by repeating the object name", "CreationDate": "2014-11-26T15:07:44.417", "Id": "27152477", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-11-27T06:42:00.970", "Score": "45", "OwnerUserId": "948128", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "27154384": {"Id": "27154384", "PostTypeId": "2", "Body": "<p>As stated in the other answers, the reason is name injection. To me, the main use case would be the following</p>\n<pre><code>struct B1 { void f(){} };\nstruct B2 { void f(){} };\n\nstruct D : B1, B2 { }\n\nint main() {\n    D obj; \n    obj.f(); \n}\n</code></pre>\n<p>In <code>main</code> the call to <code>f</code> is ambiguous and won't compile. The way to be specific is a qualified call, ie </p>\n<pre><code>obj.B1::f(); \n</code></pre>\n", "LastActivityDate": "2014-11-26T16:37:26.443", "CommentCount": "1", "CreationDate": "2014-11-26T16:37:26.443", "ParentId": "27152477", "Score": "8", "OwnerUserId": "4224575"}, "bq_ids": {"n4140": {"so_27152477_27152678_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5846}}, "n3337": {"so_27152477_27152678_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5616}}, "n4659": {"so_27152477_27152678_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7325}}}, "27152670": {"Id": "27152670", "PostTypeId": "2", "Body": "<p>It is due to \"injected-name\" \u2014 which means if <code>foo</code> is a class-name, and the same name \"foo\" is also injected into the class-scope which is why your code works. It is 100% Standard-conformant. </p>\n<p>Here is one interesting example which shows the benefits of this feature:</p>\n<pre><code>namespace N\n{\n   //define a class here\n   struct A \n   { \n       void f() { std::cout &lt;&lt; \"N::A\" &lt;&lt; std::endl; }\n   };\n}\n\nnamespace M\n{\n   //define another class with same name!\n   struct A \n   { \n       void f() { std::cout &lt;&lt; \"M::A\" &lt;&lt; std::endl; }\n   };\n\n   struct B : N::A  //NOTE : deriving from N::A\n   {\n         B()\n         {\n            A a;\n            a.f(); //what should it print?\n         }\n   };\n}\n</code></pre>\n<p>What should <code>a.f()</code> call? What is the type of <code>a</code>? Is it <code>M::A</code> or <code>N::A</code>?  The answer is, <code>N::A</code>, not <code>M::A</code>. </p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/1f03240f6bcc9adf\">Online Demo</a></li>\n</ul>\n<p>It is because of name-injection, <code>N::A</code> is available inside the constructor of <code>B</code> without <em>qualification</em>. It also <em>hides</em> <code>M::A</code>, which remains outside the scope of <code>B</code>. If you want to use <code>M::A</code>, then you've to write <code>M::A</code> (or better <code>::M::A</code>).</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2014-11-26T15:37:35.620", "Score": "38", "CreationDate": "2014-11-26T15:16:40.047", "ParentId": "27152477", "CommentCount": "0", "OwnerUserId": "415784", "LastEditDate": "2014-11-26T15:37:35.620"}, "27152678": {"Id": "27152678", "PostTypeId": "2", "Body": "<p>Because of <code>[class]/2</code>:</p>\n<blockquote>\n<p id=\"so_27152477_27152678_0\">A <em>class-name</em> is inserted into the scope in which it is declared immediately after the <em>class-name</em> is seen. The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.</p>\n</blockquote>\n<p>So <code>foo::foo</code> is an injected class name, denoting <code>foo</code> itself.</p>\n<hr>\n<p>Actually it's a bit more complicated: according to <code>[class.qual]/2</code>, <code>foo::foo</code> alone denotes a constructor of <code>foo</code>. In order to denote a class, it should either be preceded by <code>struct</code> (making it <em>elaborated-type-specifier</em>), or followed by <code>::</code> (making it a <em>nested-name-specifier</em> - this is your case), or be a <em>base-specifier</em> (for example <code>struct bar : foo::foo {};</code>).</p>\n</hr>", "LastEditorUserId": "3959454", "LastActivityDate": "2014-11-27T06:42:00.970", "Score": "19", "CreationDate": "2014-11-26T15:17:04.010", "ParentId": "27152477", "CommentCount": "0", "OwnerUserId": "3959454", "LastEditDate": "2014-11-27T06:42:00.970"}});