post_cb({"10866898": {"Id": "10866898", "PostTypeId": "2", "Body": "<p>Because both signatures match the call.</p>\n<pre><code>add();\n</code></pre>\n<p>can be interpreted as either <code>add(1,1)</code> or <code>add()</code>. When you write <code>void add(int a=1, int b=1)</code>, you're telling the compiler - <em>\"Listen dude, if I call <code>add</code> with no parameters, I want you to default them to <code>1</code>\"</em></p>\n<p>Most importantly, what do <strong>YOU</strong> expect to happen when you call <code>add()</code> with no parameters?</p>\n<ul>\n<li><p>If you expect it to print <code>2</code>, remove the version that takes no parameters.</p></li>\n<li><p>If you expect it to print <code>4</code>, remove the default parameters from the first version.</p></li>\n</ul>\n", "LastActivityDate": "2012-06-03T00:05:37.710", "Score": "7", "CreationDate": "2012-06-03T00:05:37.710", "ParentId": "10866895", "CommentCount": "6", "OwnerUserId": "673730"}, "bq_ids": {"n4140": {"so_10866895_10867345_3": {"length": 20, "quality": 1.0, "section_id": 604}, "so_10866895_10867345_2": {"length": 62, "quality": 0.5585585585585585, "section_id": 601}, "so_10866895_10867345_1": {"length": 38, "quality": 1.0, "section_id": 7092}, "so_10866895_10867345_0": {"length": 52, "quality": 0.9629629629629629, "section_id": 577}}, "n3337": {"so_10866895_10867345_3": {"length": 20, "quality": 1.0, "section_id": 594}, "so_10866895_10867345_2": {"length": 62, "quality": 0.5585585585585585, "section_id": 591}, "so_10866895_10867345_1": {"length": 38, "quality": 1.0, "section_id": 6836}, "so_10866895_10867345_0": {"length": 52, "quality": 0.9629629629629629, "section_id": 567}}, "n4659": {"so_10866895_10867345_3": {"length": 20, "quality": 1.0, "section_id": 630}, "so_10866895_10867345_2": {"length": 62, "quality": 0.5585585585585585, "section_id": 627}, "so_10866895_10867345_1": {"length": 27, "quality": 0.7105263157894737, "section_id": 8593}, "so_10866895_10867345_0": {"length": 52, "quality": 0.9629629629629629, "section_id": 600}}}, "10866895": {"ViewCount": "1158", "Body": "<p>I was trying out default argument values and function overloading in c++ by compiling the following code and I was surprised by the output which was : </p>\n<pre><code>Line 19: error: call of overloaded 'add()' is ambiguous\n</code></pre>\n<p>The code I compiled is :</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid add(int a=1, int b=1){\n\ncout&lt;&lt;a+b;\n}\n\nvoid add(){\n\nint a =2, b=2;\ncout&lt;&lt;a+b;\n}\n\n\nint main(){\n\nadd();\n\nreturn 0;\n}\n</code></pre>\n<p>Any explanations why it is ambiguous? Thx in advance. </p>\n", "AcceptedAnswerId": "10866898", "Title": "A confusion about c++ function overloading", "CreationDate": "2012-06-03T00:04:59.353", "Id": "10866895", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-06-03T02:04:10.710", "Score": "1", "OwnerUserId": "1231905", "Tags": "<c++><function><overloading><default><arguments>", "AnswerCount": "3"}, "10866932": {"Id": "10866932", "PostTypeId": "2", "Body": "<pre><code>void add(int a, int b);\nvoid add();\n</code></pre>\n<p>You should not give <code>a</code> and <code>b</code> default values. With default values there is no way for the compiler to know whether a call to <code>add()</code> should use the first or second function. </p>\n<p>Is there a reason you need to give <code>a</code> and <code>b</code> default values?</p>\n", "LastActivityDate": "2012-06-03T00:11:57.230", "Score": "2", "CreationDate": "2012-06-03T00:11:57.230", "ParentId": "10866895", "CommentCount": "1", "OwnerUserId": "306480"}, "10867345": {"Id": "10867345", "PostTypeId": "2", "Body": "<p>Overload resolution is defined by \u00a7 13.3 of the C++ standard(s) (at least <a href=\"http://en.wikipedia.org/wiki/C++03\" rel=\"nofollow noreferrer\">C++03</a> and <a href=\"http://en.wikipedia.org/wiki/C++11\" rel=\"nofollow noreferrer\">C++11</a>). There are three parts:</p>\n<ol>\n<li>determine candidate functions,</li>\n<li>determine viable functions from the candidate functions,</li>\n<li>select the best viable function.</li>\n</ol>\n<h2>Candidate Functions</h2>\n<p>Since <code>add</code> names a function (rather than an object), \u00a7 13.3.1.1.1 defines how to determine candidate functions. Since <code>add</code> isn't qualified (contains no <code>.</code> or <code>-&gt;</code> operator), clause 3 applies (taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft n3337</a> of C++11):</p>\n<blockquote>\n<p id=\"so_10866895_10867345_0\">In unqualified function calls, the name is not qualified by an -&gt; or . operator and has the more general form of a primary-expression. The name is looked up in the context of the function call following the normal rules for name lookup in function calls (3.4). The function declarations found by that lookup constitute the set of candidate functions. Because of the rules for name lookup, the set of candidate functions consists (1) entirely of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list is the same as the expression-list in the call. [...]</p></blockquote>\n<p>In short, the candidate functions are those found by standard name lookup in the context of the function call. Name lookup is defined in \u00a7 3.4. Often, \u00a7 3.4.2 (argument-dependent name lookup) will find additional candidate functions, but there are no arguments in the function call in question, so only \u00a7 3.4.1 matters. In particular, clause 6:</p>\n<blockquote>\n<p id=\"so_10866895_10867345_1\">A name used in the definition of a function following the function\u2019s <i>declarator-id</i> that is a member of namespace N (where, only for the purpose of exposition, N could represent the global scope) shall be declared before its use in the block in which it is used or in one of its enclosing blocks (6.3) or, shall be declared before its use in namespace N or, if N is a nested namespace, shall be declared before its use in one of N\u2019s enclosing namespaces.</p>\n</blockquote>\n<p>In short, the current namespace and any parent namespaces are searched, and only functions already declared are considered. In the sample code, any functions declared before <code>main</code> in the global namespace with a name of <code>add</code> are candidates: <code>add(int, int)</code> and <code>add()</code>. If you were to declare (e.g.) a function <code>add(float, float)</code> after <code>main</code>, it wouldn't be a candidate function.</p>\n<h2>Viable Functions</h2>\n<p>\u00a7 13.3.2:</p>\n<blockquote id=\"so_10866895_10867345_2\">\n2    First, to be a viable function, a candidate function shall have enough parameters to agree in number with the arguments in the list.\n<ul>\n<li>If there are m arguments in the list, all candidate functions having exactly m parameters are viable.</li>\n<li>A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding parameter is considered to \"match the ellipsis\" (13.3.3.1.3).</li>\n<li>A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a default argument (8.3.6). For the purposes of overload resolution, the parameter list is truncated on the right, so that there are exactly m parameters.</li>\n</ul>\n\n3    Second, for F to be a viable function, there shall exist for each argument an <em>implicit conversion sequence</em> (13.3.3.1) that converts that argument to the corresponding parameter of F. If the parameter has reference type, the implicit conversion sequence includes the operation of binding the reference, and the fact that an lvalue reference to non-const cannot be bound to an rvalue and that an rvalue reference cannot be bound to an lvalue can affect the viability of the function (see 13.3.3.1.4).\n</blockquote>\n<p>The argument list has 0 arguments. <code>add()</code> has 0 arguments, so it's viable. <code>add(int, int)</code> has 2 arguments, but the first has a default argument, so it's viable. Since there are no arguments in the call, the conversion in clause 3 doesn't come into play, but it's important to be aware of the clause, especially as it points out that a function declared as <code>int foo(int&amp;)</code> can't be bound to a function call <code>foo(0)</code>, since a <a href=\"https://stackoverflow.com/q/710807/90527\">non-const reference</a> (e.g. <code>int&amp;</code>) can't be bound to an rvalue (e.g. a literal 0). However, <code>int foo(const int&amp;)</code> can be bound to <code>foo(0)</code>.</p>\n<h2>Best Function</h2>\n<p>\u00a7 13.3.3 defines how one function is considered \"better\" than another when it comes to name resolution in terms of a <a href=\"http://en.wikipedia.org/wiki/Partially_ordered_set\" rel=\"nofollow noreferrer\">partial ordering</a> of functions:</p>\n<ol>\n<li>Some conversions are \"better\" than others (\u00a713.3.3.2), and a function that uses better argument conversions is a better function.</li>\n<li>If 1 doesn't determine the better function, non-template functions are better than template functions.</li>\n<li>If 2 doesn't determine the better function, then a function template specialization that is more specialized than another is better (\"more specialized\" is a partial ordering of defined in \u00a7 14.5.6.2).</li>\n</ol>\n<p>As there are no arguments, criteria 1 can't be used. Neither <code>add()</code> nor <code>add(int,int)</code> is a template, so neither 2 nor 3 can be used. In short, neither function is better than the other.</p>\n<p>Lastly, \u00a7 13.3.3 2 determines the final result:</p>\n<blockquote id=\"so_10866895_10867345_3\">If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed.</blockquote>\n<p>Since there are two viable functions in the sample code, the call is ill-formed.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-06-03T02:04:10.710", "Score": "1", "CreationDate": "2012-06-03T01:55:32.727", "ParentId": "10866895", "CommentCount": "0", "LastEditDate": "2017-05-23T11:45:56.913", "OwnerUserId": "90527"}});