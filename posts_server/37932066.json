post_cb({"37932066": {"CommentCount": "5", "ViewCount": "696", "PostTypeId": "1", "LastEditorUserId": "3234803", "CreationDate": "2016-06-20T21:25:50.017", "LastActivityDate": "2016-06-20T22:49:53.463", "Title": "GCC and Clang different behaviors on constexpr constructor", "AcceptedAnswerId": "37932251", "LastEditDate": "2016-06-20T21:33:40.477", "Id": "37932066", "Score": "14", "Body": "<p>For this struct:</p>\n<pre><code>struct Wrapper {\n    int value;\n\n    constexpr explicit Wrapper(int v) noexcept : value(v) {}\n    Wrapper(const Wrapper&amp; that) noexcept : value(that.value) {}\n};\n</code></pre>\n<p>And this function:</p>\n<pre><code>constexpr Wrapper makeWrapper(int v)\n{\n    return Wrapper(v);\n}\n</code></pre>\n<p>The following code fails to compile for Clang (Apple LLVM version 7.3.0), but compiles fine for GCC (4.9+), both with <code>-Wall -Wextra -Werror -pedantic-errors</code>:</p>\n<pre><code>constexpr auto x = makeWrapper(123);\n</code></pre>\n<p>Clang complains that \"non-constexpr constructor 'Wrapper' cannot be used in a constant expression.\" Which compiler is right?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3234803", "AnswerCount": "3"}, "37932332": {"ParentId": "37932066", "CommentCount": "0", "Body": "<p>Both compilers are right.</p>\n<p>The rules for <code>constexpr</code> functions and initialisers say that no non-<code>constexpr</code> function can be invoked.</p>\n<p>The rules for copy elision say that it's unspecified whether the non-<code>constexpr</code> copy constructor gets invoked.</p>\n<p>The only conclusion can be that it's unspecified whether the function and initialiser meet the requirements of <code>constexpr</code>. If they do, then the compiler must accept it. If they don't, then the compiler must diagnose the problem.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "37932332", "Score": "3", "CreationDate": "2016-06-20T21:47:54.090", "LastActivityDate": "2016-06-20T21:47:54.090"}, "37932251": {"ParentId": "37932066", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Although the copy or move when returning <code>Wrapper</code> from <code>makeWrapper()</code> can be elided, it is required to exist with C++14. The existing copy constructor is non-<code>constexpr</code> and its existence inhibits creation of an implicit move constructor. As a result I think clang is right: you'd need to make the copy constructor a <code>constexpr</code>.</p>\n<p>Note that with C++17 the code might become correct: there is a proposal to make copy-elision mandatory in some contexts: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html\">P0135r0</a>. However, it seems this change hasn't landed in the working paper, yet. It may land this week, though (thanks to @NicolBolas for pointing out that it isn't there, yet). I haven't seen an updated paper in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/#mailing2016-06\">mailing</a>.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2016-06-20T22:49:53.463", "Id": "37932251", "Score": "14", "CreationDate": "2016-06-20T21:40:52.257", "LastActivityDate": "2016-06-20T22:49:53.463"}, "bq_ids": {"n4140": {"so_37932066_37932254_1": {"section_id": 5425, "quality": 0.96875, "length": 31}, "so_37932066_37932254_0": {"section_id": 481, "quality": 1.0, "length": 13}}, "n3337": {"so_37932066_37932254_1": {"section_id": 5220, "quality": 0.96875, "length": 31}, "so_37932066_37932254_0": {"section_id": 472, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_37932066_37932254_1": {"section_id": 6847, "quality": 0.5625, "length": 18}, "so_37932066_37932254_0": {"section_id": 504, "quality": 0.6153846153846154, "length": 8}}}, "37932254": {"ParentId": "37932066", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Clang is correct. It works in g++ because it's automatically eliding the Copy constructor (RVO). if you pass <code>-fno-elide-constructors</code>. g++ will also complain.</p>\n<p>The C++14 standard isn't clear about Copy-Elision in <code>constexpr</code> objects..</p>\n<p><a href=\"http://eel.is/c++draft/class.copy#32\" rel=\"nofollow noreferrer\">[class.copy/32]</a> ...<em>(partially reproduced here)</em></p>\n<blockquote>\n<p id=\"so_37932066_37932254_0\">When the criteria for elision of a copy/move operation are met....  .... the selected constructor must be accessible even if the call is\n  elided.</p>\n</blockquote>\n<p>Until we know the definition of <code>accessible</code>? We can assume g++ is also correct?</p>\n<p><a href=\"http://eel.is/c++draft/dcl.constexpr#9\" rel=\"nofollow noreferrer\">dcl.constexpr/9</a></p>\n<blockquote>\n<p id=\"so_37932066_37932254_1\">A constexpr specifier used in an object declaration declares the\n  object as const. Such an object shall have literal type and shall be\n  initialized. If it is initialized by a constructor call, that call\n  shall be a constant expression ([expr.const]). Otherwise, or if a\n  constexpr specifier is used in a reference declaration, every\n  full-expression that appears in its initializer shall be a constant\n  expression.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/a/37932251/1621391\">Dietmar Kuhl's answer</a> tells us what's ahead.</p>\n<p>Demo:</p>\n<pre><code>struct Wrapper {\n    int value;\n\n    constexpr explicit Wrapper(int v) noexcept : value(v) {}\n    Wrapper(const Wrapper&amp; that) noexcept : value(that.value)  {}\n};\n\nconstexpr Wrapper makeWrapper(int v)\n{\n    return Wrapper(v);\n}\n\nint main()\n{\n    constexpr auto x = makeWrapper(123);\n}\n</code></pre>\n<p>Compile with </p>\n<pre><code>g++ -std=c++14 -Wall -pedantic -fno-elide-constructors main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>See it <a href=\"http://coliru.stacked-crooked.com/a/48972dbfd6f57ace\" rel=\"nofollow noreferrer\">live here</a></p>\n", "OwnerUserId": "1621391", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:21.527", "Id": "37932254", "Score": "4", "CreationDate": "2016-06-20T21:41:03.740", "LastActivityDate": "2016-06-20T22:18:20.677"}});