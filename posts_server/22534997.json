post_cb({"bq_ids": {"n4140": {"so_22534997_22536531_2": {"length": 40, "quality": 0.975609756097561, "section_id": 484}, "so_22534997_22536531_1": {"length": 40, "quality": 0.975609756097561, "section_id": 484}}, "n3337": {"so_22534997_22536531_2": {"length": 35, "quality": 0.8536585365853658, "section_id": 475}, "so_22534997_22536531_1": {"length": 35, "quality": 0.8536585365853658, "section_id": 475}}}, "22534997": {"ViewCount": "203", "Body": "<p>Using this hierarchy :</p>\n<pre><code>struct TestBase {\n    // Constructor\n    TestBase();\n    TestBase(int a);\n    TestBase(TestBase const &amp;testBase);\n\n    // Destructor\n    virtual ~TestBase();\n};\n\nstruct TestChild : public TestBase {\n    // Constructor inheritance\n    using TestBase::TestBase;\n};\n</code></pre>\n<p>With this test code :</p>\n<pre><code>TestBase testBase;                  // 1) Custom constructor\nTestChild testChild;                // 2) Default constructor created by the compiler\nTestChild testChild2(1);            // 3) Inherited from parent with 'using' keyword\nTestChild testChild3(testChild);    // 4) Default copy constructor created by the compiler ?\nTestChild testChild4(testBase);     // 5) Doesn't work, why it doesn't inherit ?\n</code></pre>\n<hr>\n<p>First I was thinking that in test 4 the copy constructor was inherited from TestBase (by the 'using' keyword) but in fact it's because the compiler generates a default copy constructor which calls copy constructor of the parent class, is it correct ?</p>\n<p>A copy constructor can't be inherited because it must have the same parameter type than the class, is it correct too ?</p>\n<p>But why test 5 doesn't compile ? It's not a copy constructor for the TestChild class so it must be inherited, no?</p>\n<hr>\n<p>This is the error message:</p>\n<pre class=\"lang-none prettyprint-override\"><code>foo.cpp: In function \u2018int main()\u2019:\nfoo.cpp:21:34: error: no matching function for call to \u2018TestChild::TestChild(TestBase&amp;)\u2019\n TestChild testChild4(testBase);     // 5) Doesn't work, why it doesn't inherit ?\n                              ^\nfoo.cpp:21:34: note: candidates are:\nfoo.cpp:11:12: note: TestChild::TestChild()\n     struct TestChild : public TestBase {\n            ^\nfoo.cpp:11:12: note:   candidate expects 0 arguments, 1 provided\nfoo.cpp:13:25: note: TestChild::TestChild(int)\n         using TestBase::TestBase;\n                         ^\nfoo.cpp:13:25: note:   no known conversion for argument 1 from \u2018TestBase\u2019 to \u2018int\u2019\nfoo.cpp:11:12: note: TestChild::TestChild(const TestChild&amp;)\n     struct TestChild : public TestBase {\n            ^\nfoo.cpp:11:12: note:   no known conversion for argument 1 from \u2018TestBase\u2019 to \u2018const TestChild&amp;\u2019\nfoo.cpp:11:12: note: TestChild::TestChild(TestChild&amp;&amp;)\nfoo.cpp:11:12: note:   no known conversion for argument 1 from \u2018TestBase\u2019 to \u2018TestChild&amp;&amp;\u2019\n</code></pre>\n</hr></hr>", "AcceptedAnswerId": "22536531", "Title": "Constructor inheritance and custom constructors", "CreationDate": "2014-03-20T13:48:27.580", "Id": "22534997", "CommentCount": "2", "LastEditDate": "2014-03-20T14:39:26.783", "PostTypeId": "1", "LastEditorUserId": "1090079", "LastActivityDate": "2014-03-20T14:46:40.627", "Score": "3", "OwnerUserId": "513750", "Tags": "<c++><inheritance><c++11>", "AnswerCount": "1"}, "22536531": {"PostTypeId": "2", "Body": "<p>A <em>using-declaration</em> that names a constructor implicitly declares a set of inherited constructors, but what is worth noting is that there are certain constructs which are not inherited.</p>\n<hr>\n<h3>What does the standard say?</h3>\n<blockquote>\n<p id=\"so_22534997_22536531_0\">12.9 <strong>Inheriting Constructors</strong> <code>[class.inhctor]</code></p>\n<blockquote>\n<p id=\"so_22534997_22536531_2\"><sup>3</sup> For <strong>each non-template constructor in the candidate set of inherited constructors other than a constructor having no parameters or a copy/move constructor having a single parameter, a constructor is implicitly declared with the same constructor characteristics</strong> unless there is a user-declared constructor with the same signature in the complete class where the <em>using-declaration</em> appears or the constructor would be a default, copy ,or move constructor for that class.</p>\n</blockquote>\n</blockquote>\n<p>The above sentence might look more cryptic that it actually is.. what it is saying, in simple english, is that a constructor is only inherited in the context of <code>using Base::Base</code> if the constructor;</p>\n<ul>\n<li>isn't a template, and;</li>\n<li>isn't a default constructor (ie. having no parameters), and;</li>\n<li>isn't a copy/move constructor, and;</li>\n<li>there's no explicit declaration in <code>Derived</code> that matches a constructor normally inherited from <code>Base</code></li>\n</ul>\n<hr>\n<h3>Conclusion</h3>\n<p>With the above in mind we realize that the constructor in <code>TestBase</code> that takes a <code>TestBase const&amp;</code> is a copy-constructor, and since copy-constructors are not inherited, that's the reason for it being non-present in <code>TestChild</code>.</p>\n</hr></hr>", "LastActivityDate": "2014-03-20T14:46:40.627", "Id": "22536531", "CommentCount": "0", "CreationDate": "2014-03-20T14:46:40.627", "ParentId": "22534997", "Score": "3", "OwnerUserId": "1090079"}});