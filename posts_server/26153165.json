post_cb({"26153187": {"Id": "26153187", "PostTypeId": "2", "LastEditDate": "2014-10-02T01:36:01.657", "CommentCount": "2", "LastEditorUserId": "103167", "LastActivityDate": "2014-10-02T01:36:01.657", "CreationDate": "2014-10-02T01:29:12.583", "ParentId": "26153165", "Score": "3", "Body": "<p>All of the above are ok, since none of them perform <em>lvalue-to-rvalue conversion</em> on the indeterminate value.  It's even permitted to bind a reference to a variable with non-trivial initialization before that initialization has completed.</p>\n<p>The rule is found in section 8.5:</p>\n<blockquote>\n<p id=\"so_26153165_26153187_0\">If  no  initializer  is  specified  for  an  object,  the  object  is  default-initialized.   When  storage  for  an  object with  automatic  or  dynamic  storage  duration  is  obtained,  the  object  has  an  indeterminate  value,  and  if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced (5.17).  [ Note:  Objects with static or thread storage duration are zero-initialized,  see 3.6.2.   \u2014end note ] <strong>If an indeterminate value is produced by an evaluation, the behavior is undefined</strong> except in the following cases:</p>\n</blockquote>\n<p>and the cases involve narrow character types, so not applicable here.  What is important is that no evaluation produces an indeterminate value (which would happen as a result of lvalue-to-rvalue conversion).</p>\n<p>As John points out, in your particular case, the default initialization of a <code>std::string</code> is not \"no initialization\", so you don't even have an indeterminate value to begin with.  But you'd be ok even for primitive types with no default initialization.</p>\n", "OwnerUserId": "103167"}, "26153165": {"ViewCount": "46", "Body": "<p>(Assuming includes/namespace std/prototypes in the lines above code)</p>\n<p>1) Is it safe to create a reference to a declared variable that isn't initialized?</p>\n<p><code>myVariable</code> is declared in line 2 and then <code>myRef</code> is set to reference the uninitialized <code>myVariable</code> in line 3.</p>\n<p>Is this something that shouldn't be done?</p>\n<pre><code>1- int main(){\n2-     string myVariable;\n3-     string&amp; myRef = myVariable;\n4- {\n</code></pre>\n<p>2) Is it safe to initialize an uninitialized variable by passing itself through as a reference to a function?</p>\n<p><code>myVar</code> is declared on line 2 and then initialized on line 3 but it uses its uninitialized self as an arguement in the function <code>askText</code>. Inside the function on line 3('7'), the reference <code>text_to_initialize</code> gives <code>myVar</code> a value finally.</p>\n<p>Is it safe to intialize with yourself as an arguement in line 3?</p>\n<pre><code>1- int main(){\n2-     string myVar;\n3-     myVar = inputText(myVar);\n4- }\n5- \n6- string inputText(string&amp; text_to_initialize){\n7-     cin &gt;&gt; text_to_initialize;\n8-     return (text_to_initialize + \"!\");\n8- }\n</code></pre>\n", "AcceptedAnswerId": "26153187", "Title": "Safety with referencing uninitalized variables in C++", "CreationDate": "2014-10-02T01:26:28.883", "Id": "26153165", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-10-02T01:36:01.657", "Score": "0", "OwnerUserId": "4080710", "Tags": "<c++><reference><initialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26153165_26153187_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 3291}}, "n4659": {"so_26153165_26153187_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 4053}}}});