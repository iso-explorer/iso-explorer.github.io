post_cb({"bq_ids": {"n4140": {"so_22590006_22590451_2": {"length": 33, "quality": 1.0, "section_id": 530}}, "n3337": {"so_22590006_22590451_2": {"length": 33, "quality": 1.0, "section_id": 521}}, "n4659": {"so_22590006_22590451_2": {"length": 33, "quality": 1.0, "section_id": 551}}}, "22590451": {"Id": "22590451", "PostTypeId": "2", "Body": "<p>My answer is valid for the C preprocessor, but according to <a href=\"https://stackoverflow.com/questions/5085533/is-a-c-preprocessor-identical-to-a-c-preprocessor\">Is a C++ preprocessor identical to a C preprocessor?</a>, the differences are not relevant for this case.</p>\n<p>From <em>C, A Reference Manual, 5th edition</em>:</p>\n<blockquote>\n<p id=\"so_22590006_22590451_0\">When a functionlike macro call is encoutered, the entire macro call is\n  replaced, after parameter processing, by a copy of the body. Parameter\n  processing proceeds as follows. Actual argument token strings are\n  associated with the corresponding formal parameter names. A copy of\n  the body is then made in which every occurrence of a formal parameter\n  name is replace by a copy of the actual parameter token sequence\n  associated with it. This copy of the body then replaces the macro\n  call.\n  [...] Once a macro call has been expanded, the scan for macro calls\n  resumes at the beginning of the expansion so that names of macros may\n  be recognized <strong>within the expansion</strong> for the purpose of further macro\n  replacement.</p>\n</blockquote>\n<p><del>Note the words <strong>within the expansion</strong>. That's what makes your example invalid. Now, combine it with this:</del> <strong>UPDATE</strong>: read comments below.</p>\n<blockquote>\n<p id=\"so_22590006_22590451_1\">[...] The macro is invoked by writing its name, a left parenthesis,\n  then once actual argument token sequence for each formal parameter,\n  then a right parenthesis. The actual argument token sequences are\n  separated by commas.</p>\n</blockquote>\n<p>Basically, it all boils down to whether the preprocessor will rescan for further macro invocations only within the previous expansion, or if it will keep reading tokens that show up even after the expansion.</p>\n<p>This may be hard to think about, but I believe that what <em>should</em> happen with your example is that the macro name <code>f</code> is recognized during rescanning, and since subsequent token processing reveals a macro invocation for <code>f()</code>, your example is correct and should output what you expect. GCC and clang give the correct output, and according to this reasoning, this would also be valid (and yield equivalent outputs):</p>\n<pre><code>#define dds f\n#define f(a,b) a+b\n\ndds(eoe,su)\n</code></pre>\n<p>And indeed, the preprocessing output is the same in both examples. As for the output you get with VC++, I'd say you found a bug.</p>\n<p>This is consistent with C99 section 6.10.3.4, as well as C++ standard section 16.3.4, <em>Rescanning and further replacement</em>:</p>\n<blockquote>\n<p id=\"so_22590006_22590451_2\">After all parameters in the replacement list have been substituted and # and ## \n  processing has taken place, all placemarker preprocessing tokens are removed. Then, the \n  resulting preprocessing token sequence is rescanned, along with all subsequent\n  preprocessing tokens of the source file, for more macro names to replace.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-23T12:25:44.670", "Score": "8", "CreationDate": "2014-03-23T11:46:47.890", "ParentId": "22590006", "CommentCount": "2", "OwnerUserId": "2793118", "LastEditDate": "2017-05-23T11:46:18.273"}, "22590006": {"ViewCount": "482", "Body": "<p>I'm studying the C++ standard on the exact behaviour the preprocessor (I need to implement some sort of C++ preprocessor).  From what I understand, the example I made up (to aid my understanding) below should be valid:</p>\n<pre><code>#define dds(x) f(x,\n#define f(a,b) a+b\ndds(eoe)\nsu)\n</code></pre>\n<p>I expect the first function like macro invocation <code>dds(eoe)</code> be replaced by <code>f(eoe,</code> (note the comma within the replacement string) which then considered as <code>f(eoe,su)</code> when the input is rescanned.</p>\n<p>But a test with VC++2010 gave me this (I told the VC++ to output the preprocessed file):</p>\n<pre><code>eoe+et_leoe+et_l\nsu)\n</code></pre>\n<p>This is counter-intuitive and is obviously incorrect.  Is it a bug with VC++2010 or my misunderstanding of the C++ standard?  In particular, is it incorrect to put a comma at the end of the replacement string like I did?  My understanding of the C++ standard grammar is that any <code>preprocessing-token</code>'s are allowed there.</p>\n<p>EDIT:</p>\n<p>I don't have GCC or other versions of VC++. Could someone help me to verify with these compilers.</p>\n", "AcceptedAnswerId": "22590790", "Title": "C++ Preprocessor Standard Behaviour", "CreationDate": "2014-03-23T11:05:56.997", "Id": "22590006", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-23T11:22:29.127", "LastEditorUserId": "237575", "LastActivityDate": "2014-03-23T12:25:44.670", "Score": "15", "OwnerUserId": "237575", "Tags": "<c++><visual-c++><preprocessor><c-preprocessor><compiler-bug>", "AnswerCount": "3"}, "22590425": {"Id": "22590425", "PostTypeId": "2", "Body": "<p>Well, the problem i see is that the preprocessor does the following </p>\n<p>ddx(x) becomes f(x, </p>\n<p>However, f(x,  is defined as well (even thou it's defined as f(a,b) ), so  f(x, expands to x+ garbage.</p>\n<p>So ddx(x) finally transforms into x + garbage (because you defined f(smthing,   ).</p>\n<p>Your dds(eoe) actually expands into a+b where a is eoe and b is et_l . \nAnd it does that twice for whatever reason :).</p>\n<p>This scenario you made is compiler specific, depends how the preprocessor chooses to handle the defines expansion.</p>\n", "LastActivityDate": "2014-03-23T11:44:06.610", "CommentCount": "2", "CreationDate": "2014-03-23T11:44:06.610", "ParentId": "22590006", "Score": "1", "OwnerUserId": "746569"}, "22590790": {"Id": "22590790", "PostTypeId": "2", "Body": "<p>To the best of my understanding there is nothing in the <code>[cpp.subst/rescan]</code> portions of the standard that makes what you do illegal, and <em>clang</em> and <em>gcc</em> are right in expanding it as <code>eoe+su</code>, and the MSC (Visual C++) behaviour has to be reported as a bug.</p>\n<p>I failed to make it work but I managed to find an ugly MSC workaround for you, using variadics - you may find it helpful, or you may not, but in any event it is:</p>\n<pre><code>#define f(a,b) (a+b\n#define dds(...) f(__VA_ARGS__)\n</code></pre>\n<p>It is expanded as:</p>\n<pre><code>(eoe+\nsu)\n</code></pre>\n<p>Of course, this won't work with <em>gcc</em> and <em>clang</em>.</p>\n", "LastActivityDate": "2014-03-23T12:16:48.180", "CommentCount": "0", "CreationDate": "2014-03-23T12:16:48.180", "ParentId": "22590006", "Score": "2", "OwnerUserId": "3099074"}});