post_cb({"5031856": {"CommentCount": "8", "AcceptedAnswerId": "5031972", "PostTypeId": "1", "LastEditorUserId": "21234", "CreationDate": "2011-02-17T16:44:57.920", "LastActivityDate": "2011-02-17T23:04:56.683", "LastEditDate": "2011-02-17T23:04:56.683", "ViewCount": "1270", "FavoriteCount": "2", "Title": "overload vs default parameters in c++ standard", "Id": "5031856", "Score": "9", "Body": "<p>I was reading another question, and it got me thinking. Often the standard specifies functions which have default parameters in their descriptions. Does the standard allow writing these as overloads instead?</p>\n<p>For example, the standard says that <code>std::basic_string::copy</code> has the following declaration:</p>\n<pre><code>size_type copy(Ch* p, size_type n, size_type pos = 0) const;\n</code></pre>\n<p>Could a conforming implementation of the standard library implement this instead as two functions like this?</p>\n<pre><code>size_type copy(Ch* p, size_type n, size_type pos) const;\nsize_type copy(Ch* p, size_type n) const;\n</code></pre>\n<p>In this example, the second version could skip the <code>if(pos &gt; size()) { throw out_of_range(); }</code> test that is necessary in the first one. A micro-optimization, but still you see the point of the example.</p>\n", "Tags": "<c++><overloading><std>", "OwnerUserId": "13430", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5031856_5031972_4": {"section_id": 6341, "quality": 1.0, "length": 7}, "so_5031856_5031972_1": {"section_id": 6341, "quality": 0.75, "length": 9}, "so_5031856_5031972_5": {"section_id": 6342, "quality": 0.8666666666666667, "length": 13}, "so_5031856_5031972_2": {"section_id": 6341, "quality": 0.7058823529411765, "length": 12}, "so_5031856_5031972_3": {"section_id": 6341, "quality": 1.0, "length": 13}}, "n3337": {"so_5031856_5031972_4": {"section_id": 6098, "quality": 1.0, "length": 7}, "so_5031856_5031972_1": {"section_id": 6098, "quality": 0.75, "length": 9}, "so_5031856_5031972_5": {"section_id": 6099, "quality": 0.8666666666666667, "length": 13}, "so_5031856_5031972_2": {"section_id": 6098, "quality": 0.7058823529411765, "length": 12}, "so_5031856_5031972_3": {"section_id": 6098, "quality": 1.0, "length": 13}}, "n4659": {"so_5031856_5031972_4": {"section_id": 115, "quality": 0.7142857142857143, "length": 5}, "so_5031856_5031972_5": {"section_id": 7847, "quality": 0.5333333333333333, "length": 8}, "so_5031856_5031972_3": {"section_id": 7851, "quality": 0.6923076923076923, "length": 9}}}, "5031972": {"ParentId": "5031856", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_5031856_5031972_0\">Could a conforming implementation of the standard library implement this instead as two functions like this?</p>\n</blockquote>\n<p>Yes.  The C++ Standard (C++03 17.4.4.4/2-3) says:</p>\n<blockquote>\n<p id=\"so_5031856_5031972_1\">An implementation can declare additional non-virtual member function signatures within a [Standard Library] class:</p>\n<p id=\"so_5031856_5031972_2\">-- by adding arguments with default values to a member function signature; the same latitude does not extend to the implementation of virtual or global or non-member functions, however.</p>\n<p id=\"so_5031856_5031972_3\">-- <strong>by replacing a member function signature with default values by two or more member function signatures with equivalent behavior;</strong></p>\n<p id=\"so_5031856_5031972_4\">-- by adding a member function signature for a member function name.</p>\n<p id=\"so_5031856_5031972_5\">A call to a member function signature described in the C + + Standard library behaves the same as if the implementation declares no additional member function signatures</p>\n</blockquote>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "5031972", "Score": "14", "CreationDate": "2011-02-17T16:55:09.693", "LastActivityDate": "2011-02-17T16:55:09.693"}});