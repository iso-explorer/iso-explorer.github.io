post_cb({"42070907": {"ParentId": "42070462", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-02-06T15:03:41.263", "Score": "0", "LastEditorUserId": "187690", "LastEditDate": "2017-02-06T15:16:24.360", "Id": "42070907", "OwnerUserId": "187690", "Body": "<p>The problem can probably be reduced to a simple</p>\n<pre><code>template &lt;typename T, T&amp; t&gt; void bar() {}\n\nstruct Z\n{\n  static constexpr Z&amp; get();\n};\n\nstatic Z z;\n\nconstexpr Z&amp; Z::get() { return z; }\n\nint main()\n{\n    bar&lt;Z, Z::get()&gt;();\n}\n</code></pre>\n<p>In C++11 and C++14 modes GCC responds with </p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:14:22: error: no matching function for call to 'bar()'\n     bar&lt;Z, Z::get()&gt;();\n                      ^\nmain.cpp:1:34: note: candidate: template&lt;class T, T&amp; t&gt; void bar()\n template &lt;typename T, T&amp; t&gt; void bar() {}\n                                  ^~~\nmain.cpp:1:34: note:   template argument deduction/substitution failed:\nmain.cpp:14:22: error: 'Z::get()' is not a valid template argument for type 'Z&amp;' because it is not an object with linkage\n     bar&lt;Z, Z::get()&gt;();\n                      ^\n</code></pre>\n<p>It does not like your attempt to use a function return as an argument for a reference-typed template parameter.</p>\n<p>Once the code becomes more complicated (like yours) the descriptive error messages disappear, replaced with the message you quoted or a very similar one.</p>\n<p>Yet, it compiles fine in <code>-std=c++17</code> mode.</p>\n", "LastActivityDate": "2017-02-06T15:16:24.360"}, "42070921": {"ParentId": "42070462", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-02-06T15:04:21.120", "Score": "3", "LastEditorUserId": "2069064", "LastEditDate": "2017-02-06T15:18:20.797", "Id": "42070921", "OwnerUserId": "2069064", "Body": "<p>The issue is you're failing to meet the requirements for the template non-type argument of type <code>Target&amp;</code>. From [temp.arg.nontype]:</p>\n<blockquote>\n<p id=\"so_42070462_42070921_0\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a converted constant expression (5.20) of the type of the <em>template-parameter</em>.</p>\n</blockquote>\n<p>Where a converted constant expression prohibits, from [expr.const]:</p>\n<blockquote>\n<p id=\"so_42070462_42070921_1\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions: [...] an invocation of a function other than a <code>constexpr</code> constructor for a literal class, a <code>constexpr</code> function, or an implicit invocation of a trivial destructor (12.4)</p>\n</blockquote>\n<p>You'll need some specific <code>MyTarget</code> object to refer to (or, in a post-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"nofollow noreferrer\">N4198</a> world, a <code>constexpr</code> function that returns such a thing or something similar). Like:</p>\n<pre><code>struct MyTarget { ... };\nstatic MyTarget x;\n\nusing TargetLogger = Logger&lt;MakeLogAtTarget&lt;MyTarget,x&gt;&gt;;\n</code></pre>\n", "LastActivityDate": "2017-02-06T15:18:20.797"}, "42070462": {"CommentCount": "6", "ViewCount": "222", "PostTypeId": "1", "LastEditorUserId": "214914", "CreationDate": "2017-02-06T14:42:40.680", "LastActivityDate": "2017-02-06T18:13:11.990", "Title": "Template specialization as a function pointer", "AcceptedAnswerId": "42071432", "LastEditDate": "2017-02-06T17:13:22.067", "Id": "42070462", "Score": "0", "Body": "<p>Consider the following code:</p>\n<pre><code>typedef void(__cdecl *logging_fnc)(int, const char*, ...);\n\ntemplate&lt;logging_fnc LogFnc&gt;\nclass Logger {\npublic:\n  void foo()\n  {\n    LogFnc(1, \"Foo\");\n  }\n\n};\n\ntemplate&lt;class Target, Target&amp; instance&gt;\nvoid MakeLogAtTarget(int lvl, const char* msg...)\n{\n   instance.log(\"specific foo\", lvl, msg);\n}\n</code></pre>\n<p>The <code>Logger</code> somewhere simply calls the non-type template <code>LogFnc</code> from some method. </p>\n<p>Now I also have a singleton class <code>MyTarget</code>.</p>\n<pre><code>class MyTarget {\npublic:\n  void log(const char* targetSpecific, int lvl, const char* msg)\n  {\n    printf(\"%s %s\", targetSpecific, msg);\n  }\n\n  static MyTarget&amp; GetInstance()\n  {\n    static MyTarget myInstance;\n    return myInstance;\n  }\n\nprivate:\n  MyTarget() = default;\n};\n</code></pre>\n<p>Why exactly the following doesn't work?</p>\n<pre><code>using TargetLogger = Logger&lt;MakeLogAtTarget&lt;MyTarget, MyTarget::GetInstance()&gt;&gt;;\n</code></pre>\n<p>I keep getting: <code>cannot convert from 'void (__cdecl *)(int,const char *,...)' to 'logging_fnc'</code></p>\n<p>Is it simply because the compiler cannot get the proper address of the specialization of <code>MakeLogAtTarget</code> it generates?</p>\n<p>Generally speaking: is it possible to feed the non-template argument a pointer to a function which in turn invokes a method from some class instance?</p>\n<p><strong>UPDATE</strong>: Also tried </p>\n<pre><code>static const MyTarget targetInstance = MyTarget::GetInstance();\nusing TargetLogger = Logger&lt;MakeLogAtTarget&lt;MyTarget, targetInstance)&gt;&gt;;\n</code></pre>\n<p>Still the same error.</p>\n<p><strong>UPDATE</strong></p>\n<pre><code>static const MyTarget targetInstance = MyTarget::GetInstance();\nstatic const logging_fnc targetFnc = MakeLogAtTarget&lt;MyTarget, targetInstance&gt;;\nusing TargetLogger = Logger&lt;targetFnc&gt;;\n</code></pre>\n<p>outputs the same error at the line where <code>targetFnc</code> is declared, moreover an additional error appears at the last line:\n<code>'targetFnc': an expression involving objects with internal linkage cannot be used as a non-type argument</code></p>\n", "Tags": "<c++><c++11><templates><visual-studio-2015>", "OwnerUserId": "214914", "AnswerCount": "3"}, "42071432": {"ParentId": "42070462", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2017-02-06T15:29:13.600", "Score": "0", "LastEditorUserId": "6717178", "LastEditDate": "2017-02-06T18:13:11.990", "Id": "42071432", "OwnerUserId": "6717178", "Body": "<p>It's not clear what you are trying to achieve. It seems that you have a singleton instance that you want to feed to a logger? I'm missing the bigger picture.</p>\n<pre><code>template&lt;class Target, Target&amp; instance&gt;\n</code></pre>\n<p>Here it seems you want to use an instance of an object as a template parameter. However, afaik templates are a compile-time construct, while the instance is generated at run-time. This construction would be impossible in that case. But I'm no expert.</p>\n<p>edit: hmm, a -1 feedback modifier again. The guys/gal doing that should comment why.</p>\n<p>edit 2:\nSo now I understand your problem better. But then again the question: is it required to have <code>MakeLogAtTarget</code> fully template-able?</p>\n<p>What you can do is use function pointers as template arguments. E.g.:</p>\n<pre><code>template&lt;class Target, Target&amp; (*Getter)()&gt;\nvoid MakeLogAtTarget(int lvl, const char* msg...)\n{\n    Getter().log(\"specific foo\", lvl, msg);\n}\n</code></pre>\n<p>Thus you can call it using:</p>\n<pre><code>using TargetLogger = Logger &lt; MakeLogAtTarget &lt; MyTarget, MyTarget::GetInstance &gt;&gt; ;\n</code></pre>\n<p>Is that what you are looking for?</p>\n", "LastActivityDate": "2017-02-06T18:13:11.990"}, "bq_ids": {"n4140": {"so_42070462_42070921_0": {"section_id": 87, "quality": 0.8888888888888888, "length": 8}, "so_42070462_42070921_1": {"section_id": 6185, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_42070462_42070921_0": {"section_id": 82, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_42070462_42070921_0": {"section_id": 90, "quality": 0.8888888888888888, "length": 8}, "so_42070462_42070921_1": {"section_id": 7687, "quality": 0.8620689655172413, "length": 25}}}});