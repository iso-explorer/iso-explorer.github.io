post_cb({"14291203": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14290795_14291203_0\">Why can't we write directly to this buffer?</p>\n</blockquote>\n<p>I'll state the obvious point: because it's <code>const</code>. And casting away a <code>const</code> value and then modifying that data is... rude.</p>\n<p>Now, why is it <code>const</code>? That goes back to the days when copy-on-write was considered a good idea, so <code>std::basic_string</code> had to allow implementations to support it. It would be very useful to get an immutable pointer to the string (for passing to C-APIs, for example) <em>without</em> incurring the overhead of a copy. So <code>c_str</code> needed to return a <code>const</code> pointer.</p>\n<p>As for why it's <em>still</em> <code>const</code>? Well... that goes to an oddball thing in the standard: the null terminator.</p>\n<p>This is legitimate code:</p>\n<pre><code>std::string stupid;\nconst char *pointless = stupid.c_str();\n</code></pre>\n<p><code>pointless</code> must be a NUL-terminated string. Specifically, it must be a pointer to a NUL character. So where does the NUL character come from? There are a couple of ways for a <code>std::string</code> implementation to allow this to work:</p>\n<ol>\n<li>Use small-string optimization, which is a common technique. In this scheme, every <code>std::string</code> implementation has an internal buffer it can use for a single NUL character.</li>\n<li>Return a pointer to <em>static memory</em>, containing a NUL character. Therefore, every <code>std::string</code> implementation will return the <em>same</em> pointer if it's an empty string.</li>\n</ol>\n<p>Everyone shouldn't be forced to implement SSO. So the standards committee needed a way to keep #2 on the table. And part of that is giving you a <code>const</code> string from <code>c_str()</code>. And since this memory is likely <em>real</em> <code>const</code>, not fake \"Please don't modify this memory <code>const</code>,\" giving you a mutable pointer to it is a bad idea.</p>\n<p>Of course, you can still get such a pointer by doing <code>&amp;str[0]</code>, but the standard is very clear that <a href=\"https://stackoverflow.com/questions/12740403/legal-to-overwrite-stdstrings-null-terminator\">modifying the NUL terminator is a bad idea</a>.</p>\n<p>Now, that being said, it is <em>perfectly valid</em> to modify the <code>&amp;str[0]</code> pointer, and the array of characters therein. So long as you stay in the half-open range [0, <code>str.size()</code>). You just can't do it through the pointer returned by <code>data</code> or <code>c_str</code>. Yes, even though the standard in fact <em>requires</em> <code>str.c_str() == &amp;str[0]</code> to be true.</p>\n<p>That's standardese for you.</p>\n", "LastActivityDate": "2016-01-12T03:25:08.823", "LastEditorUserId": "-1", "Id": "14291203", "CommentCount": "8", "CreationDate": "2013-01-12T07:14:32.810", "ParentId": "14290795", "Score": "30", "OwnerUserId": "734069", "LastEditDate": "2017-05-23T12:17:42.260"}, "bq_ids": {"n4140": {"so_14290795_14290795_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1566}}, "n3337": {"so_14290795_14290795_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1561}}}, "14290795": {"ViewCount": "2421", "Body": "<p>In C++11, the characters of a <code>std::string</code> have to be stored contiguously, as \u00a7 21.4.1/5 points out:</p>\n<blockquote>\n<p id=\"so_14290795_14290795_0\">The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string object s, the identity &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n such that 0 &lt;= n &lt; s.size().</p>\n</blockquote>\n<p>However, here is how \u00a7 21.4.7.1 lists the two functions to retrieve a pointer to the underlying storage (emphasis mine):</p>\n<blockquote>\n<p id=\"so_14290795_14290795_1\">const charT* c_str() const noexcept;<br>\n  const charT* data() const noexcept;<br>\n  1 Returns: A pointer p such that p + i == &amp;operator[](i) for each i in [0,size()].<br>\n  2 Complexity: constant time.<br>\n<strong>3 Requires: The program shall not alter any of the values stored in the character array.</strong></br></br></br></br></p>\n</blockquote>\n<p>One possibility I can think of for point number 3 is that the pointer can become invalidated by the following uses of the object (\u00a7 21.4.1/6):</p>\n<ul>\n<li>as an argument to any standard library function taking a reference to non-const basic_string as an\nargument.</li>\n<li>Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and\nrend.</li>\n</ul>\n<p>Even so, iterators can become invalidated, but we can still modify them regardless until they do. We can still use the pointer until it becomes invalidated to read from the buffer as well.</p>\n<p>Why can't we write directly to this buffer? Is it because it would put the class in an inconsistent state, as, for example, <code>end()</code> would not be updated with the new end? If so, why is it permitted to write directly to the buffer of something like <code>std::vector</code>?</p>\n<p>Use cases for this include being able to pass the buffer of a <code>std::string</code> to a C interface to retrieve a string instead of passing in a <code>vector&lt;char&gt;</code> instead and initializing the string with iterators from that:</p>\n<pre><code>std::string text;\ntext.resize(GetTextLength());\nGetText(text.data());\n</code></pre>\n", "AcceptedAnswerId": "14291203", "Title": "Why is modifying a string through a retrieved pointer to its data not allowed?", "CreationDate": "2013-01-12T06:10:48.187", "Id": "14290795", "CommentCount": "9", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2013-01-12T06:39:57.553", "LastEditorUserId": "1322972", "LastActivityDate": "2016-01-12T03:25:08.823", "Score": "22", "OwnerUserId": "962089", "Tags": "<c++><string><c++11><buffer><language-lawyer>", "AnswerCount": "1"}});