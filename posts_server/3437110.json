post_cb({"3439969": {"ParentId": "3437110", "CommentCount": "3", "CreationDate": "2010-08-09T12:29:19.110", "OwnerUserId": "373215", "PostTypeId": "2", "Id": "3439969", "Score": "0", "Body": "<p>I know, everyone who answered are experts in C/C++. But I thought, this is the primary reason.</p>\n<p>num2 = num1; </p>\n<p>Here you are trying to change the base address of the array, which is not permissible.</p>\n<p>and of course,\nstruct2 = struct1;</p>\n<p>Here, object struct1 is assigned to another object. </p>\n", "LastActivityDate": "2010-08-09T12:29:19.110"}, "3438004": {"ParentId": "3437110", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-08-09T07:16:10.307", "Score": "35", "LastEditorUserId": "385433", "LastEditDate": "2010-08-09T08:22:54.423", "Id": "3438004", "OwnerUserId": "385433", "Body": "<p>Here's my take on it:</p>\n<p><em>The Development of the C Language</em> offers some insight in the evolution of the array type in C:</p>\n<ul>\n<li><a href=\"http://cm.bell-labs.com/cm/cs/who/dmr/chist.html\" rel=\"noreferrer\">http://cm.bell-labs.com/cm/cs/who/dmr/chist.html</a></li>\n</ul>\n<p>I'll try to outline the array thing:</p>\n<p>C's forerunners B and BCPL had no distinct array type, a declaration like: </p>\n<pre><code>auto V[10] (B)\nor \nlet V = vec 10 (BCPL)\n</code></pre>\n<p>would declare V to be a (untyped) pointer which is initialized to point to an unused region of 10 \"words\" of memory. B already used <code>*</code> for pointer dereferencing and had the <code>[]</code>\u00a0short hand notation, <code>*(V+i)</code> meant <code>V[i]</code>, just as in C/C++ today. However, <code>V</code> is not an array, it is still a pointer which has to point to some memory. This caused trouble when Dennis Ritchie tried to extend B with struct types. He wanted arrays to be part of the structs, like in C today: </p>\n<pre><code>struct {\n    int inumber;\n    char name[14];\n};\n</code></pre>\n<p>But with the B,BCPL concept of arrays as pointers, this would have required the <code>name</code> field to contain a pointer which had to be <em>initialized at runtime</em> to a memory region of 14 bytes within the struct. The initialization/layout problem was eventually solved by giving arrays a special treatment: The compiler would track the location of arrays in structures, on the stack etc. without actually requiring the pointer to the data to materialize, except in expressions which involve the arrays. This treatment allowed almost all B code to still run and is the source of the <em>\"arrays convert to pointer if you look at them\"</em> rule. It is a compatiblity hack, which turned out to be very handy, because it allowed arrays of open size etc.</p>\n<p>And here's my guess why array can't be assigned: Since arrays were pointers in B, you could simply write: </p>\n<pre><code>auto V[10];\nV=V+5;\n</code></pre>\n<p>to rebase an \"array\". This was now meaningless, because the base of an array variable was not a lvalue anymore. So this assigment was disallowed, which helped to catch the few programs that did this rebasing <em>on declared arrays</em>. And then this notion stuck: As arrays were never designed to be first class citized of the C type system, they were mostly treated as special beasts which become pointer if you use them. And from a certain point of view (which ignores that C-arrays are a botched hack), disallowing array assignment still makes some sense: An open array or an array function parameter is treated as a pointer without size information. The compiler doesn't have the information to generate an array assignment for them and the pointer assignment was required for compatibility reasons. Introducing array assignment for the declared arrays would have introduced bugs though spurious assigments (is a=b a pointer assignment or an elementwise copy?) and other trouble (how do you pass an array by value?) without actually solving a problem - just make everything explicit with memcpy! </p>\n<pre><code>/* Example how array assignment void make things even weirder in C/C++, \n   if we don't want to break existing code.\n   It's actually better to leave things as they are...\n*/\ntypedef int vec[3];\n\nvoid f(vec a, vec b) \n{\n    vec x,y; \n    a=b; // pointer assignment\n    x=y; // NEW! element-wise assignment\n    a=x; // pointer assignment\n    x=a; // NEW! element-wise assignment\n}\n</code></pre>\n<p>This didn't change when a revision of C in 1978 added struct assignment ( <a href=\"http://cm.bell-labs.com/cm/cs/who/dmr/cchanges.pdf\" rel=\"noreferrer\">http://cm.bell-labs.com/cm/cs/who/dmr/cchanges.pdf</a> ). Even though records <em>were</em> distinct types in C, it was not possible to assign them in early K&amp;R C. You had to copy them member-wise with memcpy and you could pass only pointers to them as function parameters. Assigment (and parameter passing) was now simply defined as the memcpy of the struct's raw memory and since this couldn't break exsisting code it was readily adpoted. As a unintended side effect, this implicitly introduced some kind of array assignment, but this happended somewhere inside a structure, so this couldn't really introduce problems with the way arrays were used. </p>\n", "LastActivityDate": "2010-08-09T08:22:54.423"}, "3437197": {"ParentId": "3437110", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2010-08-09T03:42:57.233", "Score": "22", "LastEditorUserId": "151292", "LastEditDate": "2010-08-09T03:53:58.763", "Id": "3437197", "OwnerUserId": "151292", "Body": "<p>Concerning the assignment operators, the C++ standard says the following (C++03 \u00a75.17/1):</p>\n<blockquote>\n<p id=\"so_3437110_3437197_0\">There are several assignment operators... <strong>all require a modifiable lvalue as their left operand</strong></p>\n</blockquote>\n<p>An array is not a modifiable lvalue.</p>\n<p>However, assignment to a class type object is defined specially (\u00a75.17/4):</p>\n<blockquote>\n<p id=\"so_3437110_3437197_1\">Assignment to objects of a class is defined by the copy assignment operator.</p>\n</blockquote>\n<p>So, we look to see what the implicitly-declared copy assignment operator for a class does (\u00a712.8/13):</p>\n<blockquote>\n<p id=\"so_3437110_3437197_2\">The implicitly-defined copy assignment operator for class X performs memberwise assignment of its subobjects. ... Each subobject is assigned in the manner appropriate to its type:<br>\n  ...<br>\n  --  if the subobject is an array, each element is assigned, in the manner appropriate to the element type<br>\n  ...</br></br></br></p>\n</blockquote>\n<p>So, for a class type object, arrays are copied correctly.  Note that if you provide a user-declared copy assignment operator, you cannot take advantage of this, and you'll have to copy the array element-by-element.</p>\n<hr>\n<p>The reasoning is similar in C (C99 \u00a76.5.16/2):</p>\n<blockquote>\n<p id=\"so_3437110_3437197_3\">An assignment operator shall have a modi\ufb01able lvalue as its left operand.</p>\n</blockquote>\n<p>And \u00a76.3.2.1/1:</p>\n<blockquote>\n<p id=\"so_3437110_3437197_4\">A modi\ufb01able lvalue is an lvalue that does not have array type... [other constraints follow]</p>\n</blockquote>\n<p>In C, assignment is much simpler than in C++ (\u00a76.5.16.1/2):</p>\n<blockquote>\n<p id=\"so_3437110_3437197_5\">In simple assignment (=), the value of the right operand is converted to the type of the\n  assignment expression and replaces the value stored in the object designated by the left\n  operand.</p>\n</blockquote>\n<p>For assignment of struct-type objects, the left and right operands must have the same type, so the value of the right operand is simply copied into the left operand.</p>\n</hr>", "LastActivityDate": "2010-08-09T03:53:58.763"}, "3437187": {"ParentId": "3437110", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-08-09T03:40:02.660", "Score": "2", "LastEditorUserId": "480132", "LastEditDate": "2010-08-09T16:10:40.687", "Id": "3437187", "OwnerUserId": "480132", "Body": "<p>In this link:  <a href=\"http://www2.research.att.com/~bs/bs_faq2.html\" rel=\"nofollow noreferrer\">http://www2.research.att.com/~bs/bs_faq2.html</a>  there's a section on array assignment:</p>\n<p>The two fundamental problems with arrays are that</p>\n<ul>\n<li>an array doesn't know its own size</li>\n<li>the name of an array converts to a pointer to its first element at the slightest provocation </li>\n</ul>\n<p>And I think this is the fundamental difference between arrays and structs.  An array variable is a low level data element with limited self knowledge.  Fundamentally, its a chunk of memory and a way to index into it.</p>\n<p>So, the compiler can't tell the difference between int a[10] and int b[20].</p>\n<p>Structs, however, do not have the same ambiguity.</p>\n", "LastActivityDate": "2010-08-09T16:10:40.687"}, "3437110": {"CommentCount": "4", "AcceptedAnswerId": "3438004", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-08-09T03:10:49.957", "LastActivityDate": "2010-08-10T16:06:53.200", "LastEditDate": "2017-05-23T10:31:12.597", "ViewCount": "5893", "FavoriteCount": "15", "Title": "Why does C++ support memberwise assignment of arrays within structs, but not generally?", "Id": "3437110", "Score": "72", "Body": "<p>I understand that memberwise assignment of arrays is not supported, such that the following will not work:</p>\n<pre><code>int num1[3] = {1,2,3};\nint num2[3];\nnum2 = num1; // \"error: invalid array assignment\"\n</code></pre>\n<p>I just accepted this as fact, figuring that the aim of the language is to provide an open-ended framework, and let the user decide how to implement something such as the copying of an array. </p>\n<p>However, the following does work:</p>\n<pre><code>struct myStruct {int num[3];};\nmyStruct struct1={{1,2,3}};\nmyStruct struct2;\nstruct2 = struct1;\n</code></pre>\n<p>The array <code>num[3]</code> is member-wise assigned from its instance in <code>struct1</code>, into its instance in <code>struct2</code>. </p>\n<p>Why is member-wise assignment of arrays supported for structs, but not in general? </p>\n<p><strong>edit</strong>: <strong>Roger Pate</strong>'s comment in the thread <a href=\"https://stackoverflow.com/questions/2009996/stdstring-in-struct-copy-assignment-issues\">std::string in struct - Copy/assignment issues?</a> seems to point in the general direction of the answer, but I don't know enough to confirm it myself.</p>\n<p><strong>edit 2</strong>: Many excellent responses. I choose <strong>Luther Blissett</strong>'s because I was mostly wondering about the philosophical or historical rationale behind the behavior, but <strong>James McNellis</strong>'s reference to the related spec documentation was useful as well. </p>\n", "Tags": "<c++><c><arrays><variable-assignment><struct>", "OwnerUserId": "207544", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_3437110_3437197_3": {"section_id": 3291, "quality": 0.625, "length": 5}, "so_3437110_3437197_5": {"section_id": 3291, "quality": 0.625, "length": 10}, "so_3437110_3437197_2": {"section_id": 477, "quality": 0.9259259259259259, "length": 25}, "so_3437110_3437197_0": {"section_id": 6173, "quality": 0.8181818181818182, "length": 9}, "so_3437110_3437197_1": {"section_id": 6176, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_3437110_3437197_3": {"section_id": 5934, "quality": 0.625, "length": 5}, "so_3437110_3437197_2": {"section_id": 468, "quality": 0.9259259259259259, "length": 25}, "so_3437110_3437197_0": {"section_id": 5934, "quality": 0.8181818181818182, "length": 9}, "so_3437110_3437197_1": {"section_id": 5937, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_3437110_3437197_3": {"section_id": 4053, "quality": 0.625, "length": 5}, "so_3437110_3437197_5": {"section_id": 4053, "quality": 0.625, "length": 10}, "so_3437110_3437197_2": {"section_id": 500, "quality": 0.9259259259259259, "length": 25}, "so_3437110_3437197_0": {"section_id": 7675, "quality": 0.8181818181818182, "length": 9}, "so_3437110_3437197_1": {"section_id": 7678, "quality": 0.8571428571428571, "length": 6}}}});