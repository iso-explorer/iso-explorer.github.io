post_cb({"27556840": {"CommentCount": "11", "AcceptedAnswerId": "27557375", "PostTypeId": "1", "LastEditorUserId": "4031604", "CreationDate": "2014-12-18T22:29:05.367", "LastActivityDate": "2014-12-19T12:19:28.337", "LastEditDate": "2014-12-18T22:58:51.403", "ViewCount": "407", "FavoriteCount": "2", "Title": "Why can't you omit the array size in a new initializer?", "Id": "27556840", "Score": "18", "Body": "<p>This is allowed:</p>\n<pre><code>int a[]{1, 2, 3};\n</code></pre>\n<p>But not this:</p>\n<pre><code>auto a = new int[]{1, 2, 3};\n</code></pre>\n<p>You have to specify the bounds. Why?</p>\n<p>EDIT: The proper syntax (that doesn't compile) is:</p>\n<pre><code>auto a = new (int[]){1, 2, 3};\n</code></pre>\n<p>This gives the real error message, which is:</p>\n<pre><code>error: invalid use of array with unspecified bounds\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "4375981", "AnswerCount": "3"}, "27557262": {"ParentId": "27556840", "CommentCount": "0", "Body": "<p>As Jonathan Wakely already pointed out in the comments, this is in fact a closed issue. The resolution \"should be handled in Evolution Work Group\" essentially means WG21 thinks it's not a bad idea per se, but at the same time they don't consider it a defect in the current standard. Which makes sense - there's no hint somewhere that is should work, it's just by analogy.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "27557262", "Score": "5", "CreationDate": "2014-12-18T23:07:04.403", "LastActivityDate": "2014-12-18T23:07:04.403"}, "27557438": {"ParentId": "27556840", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think it is because the compiler read files in serial method, it never goes back, (that's why you must use forward declarations for example, and not just wait for function to be declared later). I'm not sure it is the official reason but it just make sense to me.</p>\n<p>This is my explanation:</p>\n<p>The line <code>int Array[]={1,2,3};</code> can be processed in serial way like this:</p>\n<p>start array: put 1 in the 1st place, put 2 in the 2nd, put three in the 3rd, end array, therefore: array size is 3 integers, so move the stack frame by this size. </p>\n<p>But the following line: <code>int *p=new int[]{1,2,3};</code> should have start with memory allocation, in addition to placing elements in the memory and detect the size. How can it done in a serial way?</p>\n<p>To allow something like this you must break the seriality principle, and begin the processing from the end and then go back to call the appropriate allocation size. </p>\n<p><strong>EDIT:</strong></p>\n<p>In response to the 1st comment</p>\n<p>I did some test, in the following code:</p>\n<pre><code>class A{\npublic:\n    A(){\n        err2 error;\n        cout&lt;&lt;sizeof(A)&lt;&lt;endl;\n    }\n    err1 error;\n};\n</code></pre>\n<p>the compiler appear to leave the inline functions to be compiled as though they come after the class.</p>\n<p>The evidence is that no matter the order, member errors detected before function errors. \nSo in the sample class, I'm getting <code>err1 error</code> before <code>err2 error</code>, even though the chronological order is the opposite.</p>\n<p>Therefore I guess classes are the exceptional, otherwise in-class functions was very limited in usage of the class itself.</p>\n<p><strong>EDIT2:</strong></p>\n<p><code>int Array[]={sizeof(Array)};</code> gives error, the only reason is the size of array is given after the closing of the array. it is more similar to the problem in the question than <code>int Array[]={1,2};</code></p>\n", "OwnerUserId": "2852165", "LastEditorUserId": "2852165", "LastEditDate": "2014-12-19T12:19:28.337", "Id": "27557438", "Score": "0", "CreationDate": "2014-12-18T23:21:14.087", "LastActivityDate": "2014-12-19T12:19:28.337"}, "bq_ids": {"n4140": {"so_27556840_27557375_0": {"section_id": 7203, "quality": 0.8571428571428571, "length": 6}, "so_27556840_27557375_2": {"section_id": 6082, "quality": 0.6666666666666666, "length": 4}, "so_27556840_27557375_1": {"section_id": 4706, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_27556840_27557375_0": {"section_id": 6947, "quality": 0.8571428571428571, "length": 6}, "so_27556840_27557375_2": {"section_id": 5850, "quality": 0.6666666666666666, "length": 4}, "so_27556840_27557375_1": {"section_id": 5719, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_27556840_27557375_0": {"section_id": 8712, "quality": 0.7142857142857143, "length": 5}, "so_27556840_27557375_2": {"section_id": 7578, "quality": 0.6666666666666666, "length": 4}, "so_27556840_27557375_1": {"section_id": 180, "quality": 0.5714285714285714, "length": 4}}}, "27557375": {"ParentId": "27556840", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"https://stackoverflow.com/a/27557262/501250\">MSalters' answer</a> addresses why this hasn't been changed in recent versions of the standard.  Here I will answer the companion question, \"where in the C++11 standard is this forbidden?\"</p>\n<h2>Regarding <code>new (int[]){1, 2, 3}</code></h2>\n<p>First, we need to note that <code>int[]</code> is an incomplete type.</p>\n<blockquote>\n<p id=\"so_27556840_27557375_0\">... an array of unknown size ... is an incompletely-defined object type.  -[basic.types] \u00a73.9 \u00b65</p>\n</blockquote>\n<p>Finally, we note that the <code>new</code> operator does not permit the specified type to be incomplete:</p>\n<blockquote>\n<p id=\"so_27556840_27557375_1\">This type shall be a complete object type ... -[expr.new] \u00a75.3.4 \u00b61</p>\n</blockquote>\n<p>There isn't anything in the standard to make an exception for this case when the <em>braced-init-list</em> syntax is used.</p>\n<h2>Regarding <code>new int[]{1, 2, 3}</code></h2>\n<p><code>int[]</code> in this case gets parsed using the <em>new-type-id</em> production, which uses the <em>noptr-new-declarator</em> production to parse the square brackets:</p>\n<blockquote>\n<p id=\"so_27556840_27557375_2\"><em>noptr-new-declarator:</em><br/>\n  \u00a0\u00a0\u00a0\u00a0[ <em>expression</em> ] <em>attribute-specifier-seq<sub>opt</sub></em><br/>\n  \u00a0\u00a0\u00a0\u00a0<em>noptr-new-declarator</em> [ <em>constant-expression</em> ] <em>attribute-specifier-seq<sub>opt</sub></em></p>\n</blockquote>\n<p>Note that <em>expression</em> is not marked optional, therefore this syntax simply fails to parse.</p>\n", "OwnerUserId": "501250", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:24.453", "Id": "27557375", "Score": "9", "CreationDate": "2014-12-18T23:15:39.467", "LastActivityDate": "2014-12-18T23:21:53.777"}});