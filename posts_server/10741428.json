post_cb({"bq_ids": {"n4140": {"so_10741428_10741428_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5510}, "so_10741428_10741741_1": {"length": 7, "quality": 0.875, "section_id": 5511}, "so_10741428_10741741_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 5510}}, "n3337": {"so_10741428_10741428_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5296}, "so_10741428_10741741_1": {"length": 7, "quality": 0.875, "section_id": 5297}, "so_10741428_10741741_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 5296}}, "n4659": {"so_10741428_10741428_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6945}, "so_10741428_10741741_1": {"length": 7, "quality": 0.875, "section_id": 6946}, "so_10741428_10741741_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 6945}}}, "10741428": {"ViewCount": "518", "Body": "<p>Consider the following code:</p>\n<pre><code>namespace C {\n    class X {};\n}\n\nnamespace A {\n    class X {};\n\n    namespace B {\n        using namespace C;\n\n        X x;\n    }\n}\n</code></pre>\n<p>I was expecting the type of <code>x</code> to be <code>C::X</code> due to the <code>using namespace</code> directive, but instead both <em>VS2010</em> and online <em>LLVM/Clang</em> compiler resolve <code>X</code> within the namespace <code>B</code> to be <code>A::X</code>. Changing the using directive with a using declaration (<code>using C::X</code>), then it does resolve to <code>C::X</code> as expected.</p>\n<p>The standard says on using directives [7.3.4.2]:</p>\n<blockquote>\n<p id=\"so_10741428_10741428_0\">A using-directive specifies that the names in the nominated namespace can be used in the scope in which the using-directive appears after the using-directive. During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains both the using-directive and the nominated namespace.</p>\n</blockquote>\n<p>My reading of this is that <code>C::X</code> should appear as if declared within namespace <code>B</code>, effectively hiding <code>A::X</code>. Which section(s) of the standard are behind this inconsistency between using directives and using declarations? Is there any way to hide a name from an outer scope by a using directive?</p>\n", "AcceptedAnswerId": "10741741", "Title": "Does using namespace cause name hiding?", "CreationDate": "2012-05-24T16:20:29.393", "Id": "10741428", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-05-24T16:39:21.610", "Score": "12", "OwnerUserId": "927034", "Tags": "<c++><namespaces><language-lawyer>", "AnswerCount": "1"}, "10741741": {"Id": "10741741", "PostTypeId": "2", "Body": "<p>The chapter on <em>using directive</em> seems to be <em>somehow</em> clear that you are seeing the expected behavior:</p>\n<blockquote>\n<p id=\"so_10741428_10741741_0\">7.3.4p2 A using-directive specifies that the names in the nominated namespace can be used in the scope in which the using-directive appears after the using-directive. During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains <strong>both</strong> the using-directive and the nominated namespace.</p>\n<p id=\"so_10741428_10741741_1\">7.3.4p3 A using-directive does not add any members to the declarative region in which it appears.</p>\n</blockquote>\n<p>That is, the <em>using-directive</em> adds the members of the namespace to the lookup set of the common namespace ancestor of the directive and the used namespace, not directly to the scope where the <em>using-directive</em> is used. This is explicitly stated in the second quote: it does not add any members to the declarative region of the <em>using-directive</em>.</p>\n<p>Later there is an example that is meant to illustrate something else but actually shows this:</p>\n<blockquote>\n<p id=\"so_10741428_10741741_2\">7.3.4p4 [...] For another example</p>\n</blockquote>\n<pre><code>namespace A {\n  int i;\n}\nnamespace B {\n  int i;\n  int j;\n  namespace C {\n    namespace D {\n      using namespace A;\n      int j;\n      int k;\n      int a = i; // B::i hides A::i\n    }\n</code></pre>\n<p>That last example is used to clarify transitivity (and contains more code), but it actually is equivalent to your code once you remove the extra code.</p>\n<p>So it seems that in your case, the <em>using-directive</em> is not hiding, but rather being hidden.</p>\n", "LastActivityDate": "2012-05-24T16:39:21.610", "Score": "6", "CreationDate": "2012-05-24T16:39:21.610", "ParentId": "10741428", "CommentCount": "3", "OwnerUserId": "36565"}});