post_cb({"8666594": {"Id": "8666594", "PostTypeId": "2", "Body": "<p>g++ accepts the following, but VC++ does not:</p>\n<pre><code>[&amp;z]{ z = 1; }();\n</code></pre>\n<p>Here <code>z</code> is being captured so g++ does not complain about an <em>undefined reference</em>. However:</p>\n<blockquote>\n<p id=\"so_8666492_8666594_0\"><strong>5.1.2/10:</strong></p>\n<p id=\"so_8666492_8666594_1\">The identifiers in a capture-list are looked up using the usual rules for unqualified name lookup (3.4.1); each such lookup shall find\n  a variable with automatic storage duration declared in the reaching\n  scope of the local lambda expression.</p>\n</blockquote>\n<p><code>z</code> is <em>not</em> automatic storage. <code>z</code> can therefore not be captured. g++ behavior is therefore incorrect, and VC++ is correct.</p>\n<p>In your code, that VC++ accepts and g++ does not:</p>\n<pre><code>[]{ z = 1; }();\n</code></pre>\n<p><code>z</code> is accessed by VC++ as static storage, which is allowed in a lambda body. g++ apparently does not resolve the name <code>z</code> to the static variable declared above and therefore throws <em>undefined reference</em>, while it shouldn't.</p>\n<p><strong>tl;dr</strong>\nIt's probably a bug in g++</p>\n<p><strong>Edit:</strong>\n<a href=\"http://comments.gmane.org/gmane.comp.gcc.bugs/334029\">It is indeed a bug</a> and is fixed in 4.7.</p>\n", "LastEditorUserId": "703016", "LastActivityDate": "2011-12-29T13:37:58.973", "Score": "10", "CreationDate": "2011-12-29T10:23:03.087", "ParentId": "8666492", "CommentCount": "1", "OwnerUserId": "703016", "LastEditDate": "2011-12-29T13:37:58.973"}, "bq_ids": {"n4140": {"so_8666492_8666594_1": {"length": 21, "quality": 0.84, "section_id": 5969}}, "n3337": {"so_8666492_8666594_1": {"length": 23, "quality": 0.92, "section_id": 5738}}, "n4659": {"so_8666492_8666594_1": {"length": 21, "quality": 0.84, "section_id": 7467}}}, "8666492": {"ViewCount": "658", "Body": "<p>This is the simplest example I could come up with that reproduces the problem.</p>\n<pre><code>template&lt;class T&gt;\nstruct X\n{\n    static void foo()\n    {\n        static int z = 0;\n        []{ z = 1; }();\n    }\n};\n\nint main()\n{\n    X&lt;int&gt;::foo();\n    return 0;\n}\n</code></pre>\n<p>I've tried it with MinGW 4.6 and 4.7, also g++ 4.6 in Ubuntu and all of them give me the link error \"undefined reference to `z'\". So now that makes me wonder if this is even legal. VC10 has no problem with it.</p>\n<p>It works if X is normal class instead of a template. Also, I don't think it's related to lambdas cause I get the error even if I replace the lambda with a local class.</p>\n", "AcceptedAnswerId": "8666594", "Title": "Undefined reference to a static local variable", "CreationDate": "2011-12-29T10:15:25.887", "Id": "8666492", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-29T10:55:00.107", "LastEditorUserId": "733152", "LastActivityDate": "2011-12-29T13:37:58.973", "Score": "9", "OwnerUserId": "458825", "Tags": "<c++><static><g++><c++11>", "AnswerCount": "2"}, "8667110": {"Id": "8667110", "PostTypeId": "2", "Body": "<p>I don't understand why it works for normal classes and not for templates. But you can get your example to work if you capture the local variable <code>z</code> by reference:</p>\n<pre><code>static void foo()\n{\n    static int z = 0;\n    [&amp;z]{ z = 1; }(); // Note: [&amp;z]\n}\n</code></pre>\n<p>Wikipedia has more info <a href=\"http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B\" rel=\"nofollow\">here</a>.</p>\n", "LastActivityDate": "2011-12-29T11:08:30.443", "CommentCount": "12", "CreationDate": "2011-12-29T11:08:30.443", "ParentId": "8666492", "Score": "-1", "OwnerUserId": "428857"}});