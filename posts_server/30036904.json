post_cb({"bq_ids": {"n4140": {"so_30036904_30038341_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4231}}, "n3337": {"so_30036904_30038341_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4072}}, "n4659": {"so_30036904_30038341_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5492}}}, "30037537": {"Id": "30037537", "PostTypeId": "2", "Body": "<pre><code>template &lt;typename T,\n  typename UserAllocator,\n  typename Mutex,\n  unsigned NextSize,\n  unsigned MaxSize &gt;\nstruct my_pool_allocator:\n  boost::pool_allocator&lt;T,UserAllocator,Mutex,NextSize,MaxSize&gt;\n{\n  using base=boost::pool_allocator&lt;T,UserAllocator,Mutex,NextSize,MaxSize&gt;;\n  using base::base;\n  template &lt;typename U&gt;\n  struct rebind\n  {\n    using other=my_pool_allocator&lt;U, UserAllocator, Mutex, NextSize, MaxSize&gt;;\n  };\n  using base::construct;\n  template&lt;class...Args&gt;\n  void construct(const typename base::pointer ptr, Args&amp;&amp;...args)\n  { new (ptr) T(std::forward&lt;Args&gt;(args)...); }\n};\n</code></pre>\n<p>or somesuch.  Inherit from <code>fast_pool_allocator</code>, inherit its constructors, write a custom <code>rebind</code>, inherit <code>construct</code>, and add another overload of <code>construct</code> that handles varargs.</p>\n<p>One should be able to write a \"modernize allocator\" template that does most of this for you I suspect.</p>\n<pre><code>template &lt;class OldAllocator&gt;\nstruct modernize_allocator:\n  OldAllocator\n{\n  using base=OldAllocator;\n\n  using T=typename base::value_type;\n\n  using base::base;\n  template &lt;typename U&gt;\n  struct rebind\n  {\n    using other=modernize_allocator&lt;typename base::rebind&lt;U&gt;::other&gt;;\n  };\n\n  using base::construct;\n  template&lt;class...Args&gt;\n  void construct(const typename base::pointer ptr, Args&amp;&amp;...args)\n  { new (ptr) T(std::forward&lt;Args&gt;(args)...); }\n};\n</code></pre>\n<p>There may be typos/errors above: it is just a sketch of a solution.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-05-04T19:53:50.673", "Score": "2", "CreationDate": "2015-05-04T18:40:06.667", "ParentId": "30036904", "CommentCount": "5", "OwnerUserId": "1774667", "LastEditDate": "2015-05-04T19:53:50.673"}, "30036904": {"ViewCount": "253", "Body": "<p>I'm trying to use <code>boost::fast_pool_allocator</code> as the allocator for a <code>std::list</code>, but it fails to find the <a href=\"http://en.cppreference.com/w/cpp/memory/allocator_traits/construct\" rel=\"nofollow\">overload</a> for <code>construct()</code> that uses variadic templates.</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;utility&gt;\n\n#include &lt;boost/pool/pool_alloc.hpp&gt;\n\nint main()\n{\n    typedef std::pair&lt;int, int&gt; Pair;\n    std::list&lt;Pair, boost::fast_pool_allocator&lt;Pair&gt;&gt; list;\n\n    list.emplace(list.begin(), 1, 2);\n}\n</code></pre>\n<p>This fails to compile with the following error (shortened):</p>\n<pre><code>stl_list.h:514:8: error: no matching function for call to \u2018boost::fast_pool_allocator&lt;blah&gt;::construct(std::list&lt;bleh&gt;::_Node*&amp;, int, int)'\n</code></pre>\n<p>Looking at the <a href=\"http://www.boost.org/doc/libs/1_58_0/libs/pool/doc/html/boost/fast_pool_allocator.html\" rel=\"nofollow\">header file</a>, it seems <code>boost::fast_pool_allocator</code> only has the pre-C++11 version of <code>construct()</code> (a pointer and a const_reference).</p>\n<p>Note that defining the list as <code>std::list&lt;Pair&gt;</code> (i.e. using the default allocator) works fine.</p>\n<p>Is there a workaround for this? Any adaptor or some way of defining the allocator traits? I'm new to allocators so this is kind of a dark land for me.</p>\n<p>I can make it work with</p>\n<pre><code>list.emplace(list.begin(), Pair(1, 2));\n</code></pre>\n<p>but 1st) the actual class I'm using in production is much more complex than the <code>Pair</code> I used for the example and performance is paramount (so I could really use in-place construction), and 2nd) ideally, I'd like to have a drop-in replacement for <code>std::allocator</code>, so I could measure the performance difference with a one-line change.</p>\n<p>I'm compiling in Cygwin with g++ 4.9.2 and boost 1.58.0, and I have the same problem in a linux environment (RHEL5.5) with g++ 4.8.3 and boost 1.55.0.</p>\n", "AcceptedAnswerId": "30037537", "Title": "Making boost::fast_pool_allocator work with variadic templates (emplace)", "CreationDate": "2015-05-04T18:06:46.647", "Id": "30036904", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-05-04T19:53:50.673", "Score": "1", "OwnerUserId": "671555", "Tags": "<c++><c++11><boost>", "AnswerCount": "2"}, "30038341": {"Id": "30038341", "PostTypeId": "2", "Body": "<p>Just for the record, it should be possible to use <code>fast_pool_allocator</code> directly with a C++11-conforming container, since the container is supposed to use <code>allocator_traits::construct</code>, which in turn calls the <code>allocator</code>'s <code>construct</code> only if the call is well-formed ([allocator.traits.members]/p5):</p>\n<blockquote>\n<pre><code>template &lt;class T, class... Args&gt;\nstatic void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_30036904_30038341_0\"><em>Effects</em>: calls <code>a.construct(p, std::forward&lt;Args&gt;(args)...)</code> if that call is well-formed; otherwise, invokes <code>::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)</code>.</p>\n</blockquote>\n<p>The problem is that libstdc++'s <code>std::list</code> <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html\" rel=\"nofollow\">is still not conforming to the C++11 standard</a>; it directly calls <code>construct</code> on the allocator. As a workaround, Yakk's answer is good.</p>\n", "LastActivityDate": "2015-05-04T19:24:33.510", "CommentCount": "2", "CreationDate": "2015-05-04T19:24:33.510", "ParentId": "30036904", "Score": "1", "OwnerUserId": "2756719"}});