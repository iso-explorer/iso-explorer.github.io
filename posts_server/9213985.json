post_cb({"bq_ids": {"n4140": {"so_9213985_9214528_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 5908}, "so_9213985_9214528_2": {"length": 10, "quality": 0.5555555555555556, "section_id": 7040}, "so_9213985_9214528_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5908}}, "n3337": {"so_9213985_9214528_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 5680}, "so_9213985_9214528_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 6785}, "so_9213985_9214528_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5680}}, "n4659": {"so_9213985_9214528_0": {"length": 24, "quality": 0.631578947368421, "section_id": 7390}, "so_9213985_9214528_2": {"length": 10, "quality": 0.5555555555555556, "section_id": 8537}, "so_9213985_9214528_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7390}}}, "9214528": {"Id": "9214528", "PostTypeId": "2", "Body": "<p>Citing the C++98 standard, <strong>9.4.2 Static data members</strong>:</p>\n<blockquote>\n<p id=\"so_9213985_9214528_0\">If a static data member is of const integral or const enumeration type, its declaration in the class definition can specify a constant-initializer which shall be an integral constant expression (5.19). In that case, the member can appear in integral constant. <strong>The member shall still be defined in a namespace scope if it is used in the program</strong> and the namespace\n  scope definition shall not contain an initializer. [emphasis mine].</p>\n</blockquote>\n<p>So you have to define the constant members is Alan Stokes pointed in his answer. If you don't do that, and the compiler manages to avoid any reference to the variable, because it is constant and it already knows the value, you <em>may</em> do without it. But no guarantees about that.</p>\n<p>Curiously enough in the C++11 draft, there are a few additional notes about <code>constexpr</code> and brace initializers, and then:</p>\n<blockquote>\n<p id=\"so_9213985_9214528_1\">The member shall still be defined in a namespace scope <strong>if it is odr-used</strong> (3.2) in the program.</p>\n</blockquote>\n<p>Then, in point 3.2 it defines what <em>odr-used</em> means:</p>\n<blockquote>\n<p id=\"so_9213985_9214528_2\">A variable whose name appears as a potentially-evaluated expression is <strong>odr-used</strong> unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied.</p>\n</blockquote>\n<p>That is, in C++11 you have the guarantee not to need the member definition if all your uses of the constant member are in constant expressions:</p>\n", "LastActivityDate": "2012-02-09T16:13:32.530", "CommentCount": "0", "CreationDate": "2012-02-09T16:13:32.530", "ParentId": "9213985", "Score": "3", "OwnerUserId": "865874"}, "9213985": {"ViewCount": "960", "Body": "<p>I have some linking issues which I do not understand.</p>\n<p>Here are the source:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt; typename T &gt;\nstruct CompressedEnums {\n    CompressedEnums () : data(0) {}\n\n    T get() const {\n        return (T)(data);\n    }\n\n    void set(const T&amp; value) {\n        data = value;\n    }\n\n    unsigned data;\n};\n\nnamespace Bbs_detail {\n    enum inner_type { BB0 = 0 , BB1 = 1 , BB2 = 2 };\n    typedef inner_type E;\n};\n\nstruct Bbs {\n    static const size_t size = 3;\n    typedef Bbs_detail::inner_type inner_type;\n    typedef inner_type E;\n    static const Bbs_detail::E BB0 = Bbs_detail::BB0;\n    static const Bbs_detail::E BB1 = Bbs_detail::BB1;\n    static const Bbs_detail::E BB2 = Bbs_detail::BB2;\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const Bbs::E&amp; e) {\n    switch(e) {\n        case Bbs::BB0: o &lt;&lt; \"BB0\"; return o;\n        case Bbs::BB1: o &lt;&lt; \"BB1\"; return o;\n        case Bbs::BB2: o &lt;&lt; \"BB2\"; return o;\n    }\n    return o;\n};\n\nint main(int argc, const char *argv[]) {\n    CompressedEnums&lt; Bbs::E &gt; l;\n\n    l.set(Bbs::BB0);\n    Bbs::E x = l.get();\n\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>When I compile this with -O3 it works, but I get linker errors with -O0. Ih have tried both with gcc 4.6.2 and and gcc 4.7.</p>\n<p>When compiling with clang 3.0 I get linker errors regardless of the optimization level.</p>\n<p>Linker errors:</p>\n<pre><code>/tmp/cch116DO.o: In function `main':\ntest.cxx:(.text+0x8f): undefined reference to `Bbs::BB0'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>Is this because I'm doing something illegal?</p>\n<p>I was of the opinion that static const members of integral types can be initialized in-class, isn't that right?</p>\n", "AcceptedAnswerId": "9214528", "Title": "Linking errors with static const values referring to enum in alternative namespace", "CreationDate": "2012-02-09T15:44:05.047", "Id": "9213985", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-02-09T16:13:32.530", "Score": "2", "OwnerUserId": "339753", "Tags": "<c++><linker>", "AnswerCount": "2"}, "9214129": {"Id": "9214129", "PostTypeId": "2", "Body": "<p>If you declare a static member of a class, you also need to define it in exactly one source file. </p>\n<p>(Often you can get away without doing this, but not always, and the standard requires it.)</p>\n<p>So somewhere you need</p>\n<pre><code>const Bbs_detail::E Bbs::BB0;\n</code></pre>\n<p>etc.</p>\n", "LastActivityDate": "2012-02-09T15:52:14.903", "CommentCount": "3", "CreationDate": "2012-02-09T15:52:14.903", "ParentId": "9213985", "Score": "1", "OwnerUserId": "212870"}});