post_cb({"44864483": {"ParentId": "44864106", "CommentCount": "1", "Body": "<p>It is allowed, nothing in the Standard prohibits this. But it just states that such a conversion operator will never be used. <a href=\"http://eel.is/c++draft/class.conv.fct#1\" rel=\"nofollow noreferrer\"><code>[class.conv.fct]/1</code></a>:</p>\n<blockquote>\n<p id=\"so_44864106_44864483_0\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void.</p>\n</blockquote>\n<p>Overload resolution will always prefer the base class constructor over a conversion operator, and the conversion operator will never be called, so it is unnecessary for implicit conversions. Access checking is always done after overload resolution, so the the conversion operator is never considered.</p>\n<pre><code>struct B {\n    B() = default;\n    B(const B&amp;) = default;\n    B&amp; operator=(const B&amp;) = default;\n};\n\nstruct D : protected B {\n    operator B() { return *this; }\n};\n\nint main() {\n    D d;\n    B b = d; // (1)\n    b = d; // (2)\n}\n</code></pre>\n<p>For (1), the copy constructor <code>B(const B&amp;)</code> is a better match then converting <code>D</code> to <code>B</code> using a conversion operator (<a href=\"http://eel.is/c++draft/over.match#ctor-1\" rel=\"nofollow noreferrer\"><code>[over.match.ctor]/1</code></a>), so that constructor will be chosen. But only now is access checked, and because the <code>B</code>'s copy constructor is <code>protected</code>, it doesn't compile.</p>\n<p>For (2) almost the exact same thing. <code>B&amp; operator=(const B&amp;)</code> is chosen by overload resolution because it is a better match than to call the user defined conversion operator of <code>D</code>. But now <code>B</code>'s assignment operator is also <code>protected</code>, and so you can't access it outside of <code>D</code>, and your code doesn't compile.</p>\n<p>That's just how overload resolution works, as far as I know that is the only reason.</p>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "44864483", "Score": "1", "CreationDate": "2017-07-01T19:09:10.037", "LastActivityDate": "2017-07-01T19:09:10.037"}, "44864106": {"CommentCount": "14", "AcceptedAnswerId": "44864483", "PostTypeId": "1", "LastEditorUserId": "8242004", "CreationDate": "2017-07-01T18:24:12.027", "LastActivityDate": "2017-07-01T19:09:10.037", "LastEditDate": "2017-07-01T18:51:03.130", "ViewCount": "61", "FavoriteCount": "0", "Title": "User-defined conversion operator to inaccessible base class", "Id": "44864106", "Score": "0", "Body": "<p>Why not allow user-defined conversion to base class (or reference to it) when base is inacessible: <code>protected</code> or <code>private</code>?</p>\n<p>When there is a class <code>D</code> and its <code>public</code> base <code>B</code>, there is an implicit rule to bind references to <code>B</code> (<code>B&amp;</code> or <code>B&amp;&amp;</code>, possibly cv-qualified) to objects of the class <code>D</code>, so the user-defined conversion to <code>B&amp;</code> doesn't make sense. But when the base class is <code>protected</code> or <code>private</code>, the implicit rule is not applicable anymore. So why not allow to use user-defined conversion to <code>B&amp;</code> (or <code>const B&amp;</code> or <code>B&amp;&amp;</code> etc.)?</p>\n", "Tags": "<c++><language-design>", "OwnerUserId": "8242004", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44864106_44864483_0": {"section_id": 391, "quality": 1.0, "length": 22}}, "n3337": {"so_44864106_44864483_0": {"section_id": 382, "quality": 1.0, "length": 22}}, "n4659": {"so_44864106_44864483_0": {"section_id": 408, "quality": 1.0, "length": 22}}}});