post_cb({"11892591": {"ViewCount": "207", "Body": "<p>I had this question (beginner C++) in a <a href=\"http://www.barrgroup.com/Embedded-Systems/Embedded-C++-Quiz\" rel=\"nofollow\">C++ quiz</a> : My answer was incorrect, I want to understand the explanation behind the correct answer - \"Undefined behavior\"</p>\n<p>Question:\nWhat will happen in the following code after the function foo() returns?</p>\n<pre><code>class base\n{\n    public:\n        base() { }\n        ~base() { }\n};\n\nclass derived : public base\n{\n    private:\n        int *p_pi_values;\n\n    public:\n        derived() : p_pi_values(new int[100]) {  }\n        ~derived() { delete [] p_pi_values; }\n};\n\nvoid foo(void)\n{\n    derived *p_derived = new derived();\n    base *p_base = p_derived;\n\n    // Do some other stuff here.\n\n    delete p_base;\n}\n</code></pre>\n<p>I gave this answer which turned out wrong ==&gt; integer array will not be properly deleted.</p>\n<p>Correct Answer ==&gt; The behavior is undefined.</p>\n", "AcceptedAnswerId": "11892645", "Title": "What is the explanation behind the answer to this C++ quiz?", "CreationDate": "2012-08-09T21:59:34.920", "Id": "11892591", "CommentCount": "1", "LastEditDate": "2012-08-09T22:05:25.543", "PostTypeId": "1", "LastEditorUserId": "27615", "LastActivityDate": "2012-08-09T22:52:41.580", "Score": "0", "OwnerUserId": "2759376", "Tags": "<c++>", "AnswerCount": "4"}, "11893154": {"Id": "11893154", "PostTypeId": "2", "Body": "<p>Out of curiousity I check the C++ specs. The answer to the question is item 3 in section 5.3.5: </p>\n<blockquote>\n<p id=\"so_11892591_11893154_0\">In the \ufb01rst alternative (delete object), if the static type of the\n  object to be deleted is di\ufb00erent from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or <em>the\n  behavior is unde\ufb01ned.</em></p>\n</blockquote>\n<p>Personally, I would have answered the same way you did. If you ignore the compiler's warning, the most likely outcome is that the destructor of the derived class won't get called. </p>\n", "LastActivityDate": "2012-08-09T22:52:41.580", "CommentCount": "0", "CreationDate": "2012-08-09T22:52:41.580", "ParentId": "11892591", "Score": "0", "OwnerUserId": "1418511"}, "11892672": {"Id": "11892672", "PostTypeId": "2", "Body": "<p>I guess compiler is allowed to optimize this code and hence the assignment of p_derived to p_base never happens.</p>\n<p>To be more specific the compiler may optimize the code to one line. </p>\n<p>delete new derived();</p>\n<p>Hence it is viewed that the behavior as undefined as this can change how the compiler really optimizes the code. </p>\n", "LastActivityDate": "2012-08-09T22:06:25.860", "CommentCount": "1", "CreationDate": "2012-08-09T22:06:25.860", "ParentId": "11892591", "Score": "-3", "OwnerUserId": "1275068"}, "bq_ids": {"n4140": {"so_11892591_11892645_0": {"length": 23, "quality": 0.92, "section_id": 6107}, "so_11892591_11893154_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 6107}}, "n3337": {"so_11892591_11892645_0": {"length": 23, "quality": 0.92, "section_id": 5873}, "so_11892591_11893154_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 5873}}, "n4659": {"so_11892591_11892645_0": {"length": 23, "quality": 0.92, "section_id": 7604}, "so_11892591_11893154_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 7604}}}, "11892645": {"Id": "11892645", "PostTypeId": "2", "Body": "<p>The destructor of your base class isn't <code>virtual</code>. It's simply a rule of the language that if you delete an object through a pointer to a base subobject, the corresponding base class must have a virtual des\u00adtruc\u00adtor, or otherwise it is undefined behaviour.</p>\n<p>(In practice, if your base class doesn't have a virtual destructor, the compiler may not emit the necessary code to perform all the necessary clean-up for the derived object. It will just assume that your object is of the same type as the pointer and not bother to look further, as indeed the polymorphic lookup of the most derived object comes at a cost that you don't want to impose needlessly.)</p>\n<p><strong>\u00a75.3.5/3:</strong></p>\n<blockquote>\n<p id=\"so_11892591_11892645_0\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-08-09T22:11:24.590", "Score": "9", "CreationDate": "2012-08-09T22:04:08.383", "ParentId": "11892591", "CommentCount": "4", "OwnerUserId": "596781", "LastEditDate": "2012-08-09T22:11:24.590"}, "11892663": {"Id": "11892663", "PostTypeId": "2", "Body": "<p>You should make your destructor virtual in a base class. The problem with the code as it is now is that <code>delete p_base</code> will cause a destructor of base class to be called. The one from the derived class won't be called and the memory allocated for the array of integers won't be freed. </p>\n<p>This happens because if a method isn't virtual in a base class, compiler simply looks at a pointer type and calls a method located in this type (in this case - it's a base class) i.e. a decision what method to call is made during compilation time based on the type of the pointer and not the real type of the object the pointer is referring to.</p>\n", "LastEditorUserId": "276274", "LastActivityDate": "2012-08-09T22:11:20.337", "Score": "2", "CreationDate": "2012-08-09T22:06:00.367", "ParentId": "11892591", "CommentCount": "0", "OwnerUserId": "276274", "LastEditDate": "2012-08-09T22:11:20.337"}});