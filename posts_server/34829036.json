post_cb({"34829036": {"ViewCount": "225", "Body": "<p>I have the following class (stripped down to contain only the relevant parts):</p>\n<pre><code>#include &lt;string&gt;\n\nclass Text\n{\nprivate:\n    std::string _text;\n\npublic:\n    Text(std::string&amp;&amp; text) :\n        _text(std::move(text))\n    {\n    }\n\n    operator const std::string&amp;() const\n    {\n        return _text;\n    }\n};\n</code></pre>\n<p>My question is: if I want to obtain a <code>const std::string&amp;</code>, can I do it like this without any penalty:</p>\n<pre><code> Text text(\"fred\");\n\n auto&amp; s = static_cast&lt;std::string&gt;(text);\n</code></pre>\n<p>Or will this construct an intermediate <code>std::string</code> that I end up getting a reference to? Is there a standard approach to this kind of scenario? I am reasonably new to C++.</p>\n", "AcceptedAnswerId": "34829557", "Title": "static_cast<> behaviour on class with implicit conversion operator that returns a const reference", "CreationDate": "2016-01-16T16:02:52.493", "Id": "34829036", "CommentCount": "10", "LastEditDate": "2016-01-16T17:38:10.517", "PostTypeId": "1", "LastEditorUserId": "2791577", "LastActivityDate": "2016-01-16T17:38:10.517", "Score": "6", "OwnerUserId": "2791577", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "34829346": {"PostTypeId": "2", "Body": "<p>I believe the behavior here, when you <code>static_cast</code> to <code>std::string</code> and not <code>const std::string &amp;</code>, is determined by this part of the C++11 standard:</p>\n<p>[expr.static.cast] [5.2.9.4]:</p>\n<blockquote>\n<p id=\"so_34829036_34829346_0\">An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code>\n  if the declaration <code>T t(e)</code>; is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an\n  explicit conversion is the same as performing the declaration and initialization and then using the temporary\n  variable as the result of the conversion. The expression <code>e</code> is used as a glvalue if and only if the initialization\n  uses it as a glvalue.</p>\n</blockquote>\n<p>If you <code>static_cast</code> to <code>const std::string &amp;</code> then I would expect that no copy would be made. But if you <code>static_cast</code> to <code>std::string</code>, you must get a <code>std::string</code> value out -- it should always be the case that <code>decltype(static_cast&lt;T&gt;(e))</code> is the same as type <code>T</code>. The only way that a new <code>std::string</code> could be constructed is with the <code>std::string</code> copy ctor, and because your conversion operator is not marked <code>explicit</code>, it is a valid implicit conversion to get a <code>std::string</code> from <code>Text</code> that way.</p>\n<blockquote>\n<p id=\"so_34829036_34829346_1\">Or will this construct an intermediate std::string that I end up getting a reference to?</p>\n</blockquote>\n<p>It will construct an intermediate <code>std::string</code> that you end up getting <em>by value</em>.</p>\n", "LastActivityDate": "2016-01-16T16:35:59.083", "Id": "34829346", "CommentCount": "2", "CreationDate": "2016-01-16T16:35:59.083", "ParentId": "34829036", "Score": "1", "OwnerUserId": "3598119"}, "bq_ids": {"n4140": {"so_34829036_34829346_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 6030}}, "n3337": {"so_34829036_34829346_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 5798}}}, "34829892": {"PostTypeId": "2", "Body": "<p>At first, the compiler creates a temp variable in the middle of the cast operation:</p>\n<pre><code>int main()\n{\n    string temp = \"foo\";\n    cout &lt;&lt; &amp;temp &lt;&lt; endl;\n    Text text(move(temp));\n    auto s = static_cast&lt;string&gt;(text);\n    cout &lt;&lt; &amp;s &lt;&lt; endl;\n    return 0;\n}\n\n$ main\n0x7fffb9dd7530\n0x7fffb9dd7540\n</code></pre>\n<p>As you can see the address of the variable has changed</p>\n<p>Secondly, The compiler shadows all the <code>const, volatile</code> etc. modifiers when you use <code>auto</code> </p>\n<pre><code>void f (int i) {}\n\nauto s = static_cast&lt;const string&amp;&gt;(text);\nf(s);\n</code></pre>\n<blockquote>\n<p id=\"so_34829036_34829892_0\">error: cannot convert <strong>'std::basic_string'</strong> to 'int' for argument\n  '1' to 'void f(int)'</p>\n</blockquote>\n<p>So if you need <code>const std::string&amp;</code> you need to apply it to the <code>auto</code> variable:</p>\n<pre><code>const auto&amp; s = static_cast&lt;string&gt;(text);\nf(s);\n</code></pre>\n<blockquote>\n<p id=\"so_34829036_34829892_1\">error: cannot convert <strong>'const std::basic_string'</strong> to 'int' for\n  argument '1' to 'void f(int)'</p>\n</blockquote>\n<p>As you can see the <code>auto</code> keyword shadows the <code>const</code> identifier.</p>\n", "LastActivityDate": "2016-01-16T17:28:02.783", "Id": "34829892", "CommentCount": "0", "CreationDate": "2016-01-16T17:28:02.783", "ParentId": "34829036", "Score": "0", "OwnerUserId": "3686755"}, "34829157": {"PostTypeId": "2", "Body": "<p>That's not even legal C++ for exactly that reason. If you static_cast to something, you will get out <em>exactly that something and nothing else</em>.</p>\n", "LastActivityDate": "2016-01-16T16:16:52.673", "Id": "34829157", "CommentCount": "3", "CreationDate": "2016-01-16T16:16:52.673", "ParentId": "34829036", "Score": "0", "OwnerUserId": "298661"}, "34829557": {"PostTypeId": "2", "Body": "<p>No, when you're calling <code>static_cast&lt;std::string&gt;(text)</code>, you're calling the implicitly defined copy constructor and creating a temporary object.</p>\n<p>However, if you would be calling</p>\n<pre><code>auto&amp; s = static_cast&lt;const std::string&amp;&gt;(text);\n</code></pre>\n<p>,then you would correctly be calling the explicit conversion operator <code>operator const Noisy&amp;()</code>.</p>\n<h1>Let's try it out</h1>\n<pre><code>struct Noisy {\n    Noisy() { std::cout &lt;&lt; \"Default construct\" &lt;&lt; std::endl; }\n    Noisy(const Noisy&amp;) { std::cout &lt;&lt; \"Copy construct\" &lt;&lt; std::endl; }\n    Noisy(Noisy&amp;&amp;) { std::cout &lt;&lt; \"Move construct\" &lt;&lt; std::endl; }\n    Noisy&amp; operator=(const Noisy&amp;) { std::cout &lt;&lt; \"C-assign\" &lt;&lt; std::endl; return *this; }\n    Noisy&amp; operator=(Noisy&amp;&amp;) { std::cout &lt;&lt; \"M-assign\" &lt;&lt; std::endl; return *this; }\n    ~Noisy() { std::cout &lt;&lt; \"Destructor\" &lt;&lt; std::endl; }\n};\n\nclass Text {\npublic:\n    Text(Noisy&amp;&amp; text) : _text(std::move(text)) {}\n    operator const Noisy&amp;() const { return _text; }\nprivate:\n    Noisy _text;\n};\n</code></pre>\n<h3>Test 1</h3>\n<pre><code>int main() {\n    Text text(Noisy{});\n    const auto&amp; s = static_cast&lt;Noisy&gt;(text); // Needs 'const' to bind to temporary.\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34829036_34829557_0\">Default construct<br>\n  Move construct<br>\n  Destructor<br>\n  Copy construct<br>\n  Destructor<br>\n  Destructor</br></br></br></br></br></p>\n</blockquote>\n<h3>Test 2</h3>\n<pre><code>int main() {\n    Text text(Noisy{});\n    auto&amp; s = static_cast&lt;const Noisy&amp;&gt;(text);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34829036_34829557_1\">Default construct<br>\n     Move construct<br>\n     Destructor<br>\n     Destructor</br></br></br></p>\n</blockquote>\n<p><strong><sub>Note: Compiled using option <code>-fno-elide-constructors</code> to avoid copy elision optimizations.</sub></strong></p>\n", "LastActivityDate": "2016-01-16T16:53:50.897", "Id": "34829557", "CommentCount": "0", "CreationDate": "2016-01-16T16:53:50.897", "ParentId": "34829036", "Score": "9", "OwnerUserId": "873025"}});