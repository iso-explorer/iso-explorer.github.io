post_cb({"bq_ids": {"n4140": {"so_39340030_39340200_1": {"length": 7, "quality": 0.7, "section_id": 5809}, "so_39340030_39340191_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 3326}, "so_39340030_39340191_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 3326}}, "n3337": {"so_39340030_39340191_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 3196}, "so_39340030_39340200_1": {"length": 7, "quality": 0.7, "section_id": 5582}, "so_39340030_39340191_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 3196}}, "n4659": {"so_39340030_39340191_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 4092}, "so_39340030_39340200_1": {"length": 7, "quality": 0.7, "section_id": 7270}, "so_39340030_39340191_1": {"length": 56, "quality": 0.9032258064516129, "section_id": 4092}}}, "39340191": {"Id": "39340191", "PostTypeId": "2", "Body": "<p><strong>C++11 and later</strong></p>\n<p>The behavior is well-defined for <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\">list initialization</a>. According to the <a href=\"http://en.cppreference.com/w/cpp/language/eval_order#Rules\">sequenced-before rules</a> (since C++11):</p>\n<blockquote>\n<p id=\"so_39340030_39340191_0\">10) In list-initialization, every value computation and side effect of a given initializer clause is sequenced before every value computation and side effect associated with any initializer clause that follows it in the brace-enclosed comma-separated list of initalizers.</p>\n</blockquote>\n<p>So for <code>struct T t = { i, ++i };</code>, <code>i</code> will be evaluated at first, and then <code>++i</code>, the order is well-defined. And all the other samples would be fine too.</p>\n<p>Quotes from the C++ standard, <a href=\"http://eel.is/c++draft/dcl.init.list#4\">$8.6.4/4 List-initialization\n[dcl.init.list]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_39340030_39340191_1\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  ([temp.variadic]), are <strong>evaluated in the order in which they appear</strong>.\n  That is, every value computation and side effect associated with a\n  given initializer-clause is sequenced before every value computation\n  and side effect associated with any initializer-clause that follows it\n  in the comma-separated list of the initializer-list. [ Note: This\n  evaluation ordering holds regardless of the semantics of the\n  initialization; for example, it applies when the elements of the\n  initializer-list are interpreted as arguments of a constructor call,\n  even though ordinarily there are no sequencing constraints on the\n  arguments of a call.  \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-09-06T04:03:05.170", "Score": "14", "CreationDate": "2016-09-06T03:25:15.447", "ParentId": "39340030", "CommentCount": "4", "OwnerUserId": "3309790", "LastEditDate": "2016-09-06T04:03:05.170"}, "39340197": {"Id": "39340197", "PostTypeId": "2", "Body": "<h3>C</h3>\n<p>In C (not necessarily the same answer as for C++), there are no sequence points associated with the components of an initializer list.</p>\n<p>The C11 standard, ISO/IEC 9899:2011, says in section \u00a76.7.9 <strong>Initialization</strong>:</p>\n<blockquote>\n<p id=\"so_39340030_39340197_0\">\u00b619 The initialization shall occur in initializer list order, each initializer provided for a particular subobject overriding any previously listed initializer for the same subobject; <sup>151)</sup></p>\n<p id=\"so_39340030_39340197_1\"><sup>151)</sup> Any initializer for the subobject which is overridden and so not used to initialize that subobject might not be evaluated at all.</p>\n</blockquote>\n<p>That sounds promising, but\u2026</p>\n<blockquote>\n<p id=\"so_39340030_39340197_2\">\u00b623 The evaluations of the initialization list expressions are indeterminately sequenced with respect to one another and thus the order in which any side effects occur is unspecified.<sup>152)</sup></p>\n<p id=\"so_39340030_39340197_3\"><sup>152)</sup> In particular, the evaluation order need not be the same as the order of subobject initialization.</p>\n</blockquote>\n<p>So, (in C) the order of evaluation is indeterminately sequenced, and you cannot rely on when the increments occur (or, in extreme cases not illustrated by the code in the question, whether the increments occur).</p>\n<p>In C99 (ISO/IEC 9899:1999), the section number is \u00a76.7.8, but paragraphs 19 and 23 have essentially the same content, except that the footnote numbers are different.</p>\n<p>In C90 (ISO/IEC 9899:1990), the issue is not addressed explicitly.</p>\n<h3>C++</h3>\n<p>Judging from <a href=\"https://stackoverflow.com/users/3309790/songyuanyao\">songyuanyao</a>'s <a href=\"https://stackoverflow.com/a/39340191/\">answer</a>, the rules in C++11 (and later) are different from those in C11.  This sort of thing emphasizes that the languages C and C++ are different and makes writing comprehensive answers to questions tagged with both languages extremely difficult.</p>\n<h3>Closely related questions</h3>\n<p>There are at least two other questions related to side-effects (such as <code>++</code>) in contexts other than initializers.  They both should be read too.  The second, in particular, is of interest to C++ users; the first is tagged C and not C++ and so is of most relevance to those interested in C.</p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/949433/why-are-these-constructs-using-undefined-behavior\">Why are these constructs (using <code>++</code>) undefined behaviour?</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points\">Undefined behaviour and sequence points</a></p></li>\n</ul>\n<p>Both were pointed out by <a href=\"https://stackoverflow.com/users/1413395/%cf%80%ce%ac%ce%bd%cf%84%ce%b1-%e1%bf%a5%ce%b5%e1%bf%96\">\u03c0\u03ac\u03bd\u03c4\u03b1 \u1fe5\u03b5\u1fd6</a> in the comments.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-06T03:45:55.307", "Score": "13", "CreationDate": "2016-09-06T03:25:48.973", "ParentId": "39340030", "CommentCount": "3", "OwnerUserId": "15168", "LastEditDate": "2017-05-23T11:45:54.820"}, "39340030": {"ViewCount": "755", "Body": "<p>Edit: Not already answered - the linked question was about ordinary r-values, initializer lists are a separate, if related concept.</p>\n<p>Is this statement well-defined, or is using the prefix increment operator in an initializer list, on a variable that appears twice in the list, undefined behavior?</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct T t = { i, ++i };\n</code></pre>\n<p>I'm most interested in ANSI C, but it'd also be useful to know if other versions of C and/or C++ differ. And if similar constructs like the following are legal:</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct T t = { i, i++ };\n\nstruct T t = { ++i, ++i };\n\nstruct T t = { i++, ++i };\n\nstruct T t = { i++, i++ };\n</code></pre>\n", "AcceptedAnswerId": "39340197", "Title": "Incrementing a variable used twice in an initializer list - undefined behavior?", "CreationDate": "2016-09-06T03:04:13.637", "Id": "39340030", "CommentCount": "12", "LastEditDate": "2016-09-06T03:18:52.540", "PostTypeId": "1", "LastEditorUserId": "6797534", "LastActivityDate": "2016-09-06T04:03:05.170", "Score": "16", "OwnerUserId": "6797534", "Tags": "<c++><c><undefined-behavior><initializer>", "AnswerCount": "3"}, "39340200": {"Id": "39340200", "PostTypeId": "2", "Body": "<p>In C11 the behaviour of all these initialization is not undefined. See 6.7.9/23:</p>\n<blockquote>\n<p id=\"so_39340030_39340200_0\">The evaluations of the initialization list expressions are indeterminately sequenced with respect to one another and thus the order in which any side effects occur is unspecified.</p>\n</blockquote>\n<p>The term <em>indeterminately sequenced</em> is defined as such (5.1.2.3):</p>\n<blockquote>\n<p id=\"so_39340030_39340200_1\">Evaluations A and B are indeterminately sequenced when A is sequenced\n  either before or after B, but it is unspecified which.</p>\n</blockquote>\n<p>In C99 the language used was not clearly worded as to whether it is the same situation, or undefined behaviour. In C89 the issue is not mentioned at all, so we should probably assume that in C89 these are undefined.</p>\n", "LastActivityDate": "2016-09-06T03:26:54.647", "CommentCount": "2", "CreationDate": "2016-09-06T03:26:54.647", "ParentId": "39340030", "Score": "6", "OwnerUserId": "1505939"}});