post_cb({"bq_ids": {"n4140": {"so_34982357_34982780_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5986}}, "n3337": {"so_34982357_34982780_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5754}}, "n4659": {"so_34982357_34982780_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7486}}}, "34982780": {"Id": "34982780", "PostTypeId": "2", "Body": "<p>The standard defines the subscripting as follows: </p>\n<blockquote>\n<p id=\"so_34982357_34982780_0\"><strong>5.2.1/1</strong> (...) The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n<p>This is why, using a pointer <code>t</code> and an index <code>i</code>, <code>*(t+i)</code> and <code>t[i]</code> is the same.  The problem with your code in the context of struct fields, is a question of priority: you may write <code>(*(t+i)).name</code> or better <code>(t+i)-&gt;name</code>, or much clearer, as you did: <code>t[i].name</code>. </p>\n<p>P.S.: If you allocate a table with <code>new[...]</code> you have to free it with <code>delete[]</code>.  So yes: it's ok ! </p>\n", "LastActivityDate": "2016-01-24T23:14:58.763", "Score": "1", "CreationDate": "2016-01-24T23:14:58.763", "ParentId": "34982357", "CommentCount": "1", "OwnerUserId": "3723423"}, "34982357": {"ViewCount": "48", "Body": "<p>I have an exercise to write down data to a dynamic table of structures using a function. Here's my code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nstruct student{ char name[15], surname[20]; int age; };\n\nstudent * createTab(int tsize)\n{\n    student *t = new student[tsize];\n    return t;\n}\n\nvoid fill(student *t, int tsize)\n{\n    for (int i = 0; i&lt;2; i++)\n    {\n        cout &lt;&lt; \"Enter a name: \"; cin &gt;&gt; t[i].name;\n        cout &lt;&lt; \"Enter a surname: \"; cin &gt;&gt; t[i].surname;\n        cout &lt;&lt; \"Enter age: \"; cin &gt;&gt; t[i].age;\n    }\n}\n\nint main()\n{\n    student *t = createTab(10);\n    fill(t, 20);\n    cout &lt;&lt; t[0].surname &lt;&lt; endl;\n    cout &lt;&lt; t[1].name &lt;&lt; endl;\n    system(\"pause\");\n    delete[]t;\n    return 0;\n}\n</code></pre>\n<p>It works, okay. But here, in <code>fill()</code> function I use the index syntax with <code>student[].name</code>. I always worked on tables with pointers like that: <code>*(table+i)</code> in a for loop. <code>*(t+i).name</code> doesn't work. Can I iterate on structure fields using pointers?</p>\n<p>P.S - Am I freeing the memory correctly?</p>\n<p>And I guess P.S 2 - How is it possible, that when I insert a pointer to a first element of my table to a function, and then I can operate on whole table with indexes?</p>\n", "AcceptedAnswerId": "34982780", "Title": "Handle a dynamic table of structures with pointers", "CreationDate": "2016-01-24T22:33:14.877", "Id": "34982357", "CommentCount": "0", "LastEditDate": "2016-01-24T22:51:59.740", "PostTypeId": "1", "LastEditorUserId": "5172820", "LastActivityDate": "2016-01-24T23:14:58.763", "Score": "1", "OwnerUserId": "5172820", "Tags": "<c++><pointers><dynamic><struct>", "AnswerCount": "1"}});