post_cb({"11983430": {"ParentId": "11983231", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-08-16T08:38:29.007", "Score": "12", "LastEditorUserId": "366377", "LastEditDate": "2012-08-16T09:07:50.140", "Id": "11983430", "OwnerUserId": "366377", "Body": "<p>Answer will be different for C and C++, this is one for C.</p>\n<p>In C bitfields are restricted to <code>signed int</code>, <code>unsigned int</code>, <code>_Bool</code> and <code>int</code> which in this context can be any of the first two. Compiler implementors can add to that list to their liking but are required to document the types that they support.</p>\n<p>So to answer your question, if you want to be absolutely sure that your code is portable to all C compilers, no, using an <code>enum</code> type is not an option.</p>\n<p>The corresponding paragraph from the current standard reads:</p>\n<blockquote>\n<p id=\"so_11983231_11983430_0\">A bit-field shall have a type that is a qualified or unqualified\n  version of _Bool, signed\n       int, unsigned int, or some other implementation-defined type. It is\n        implementation-defined whether atomic types are permitted.</p>\n</blockquote>\n", "LastActivityDate": "2012-08-16T09:07:50.140"}, "26728946": {"ParentId": "11983231", "CommentCount": "0", "CreationDate": "2014-11-04T06:26:08.373", "OwnerUserId": "1736452", "PostTypeId": "2", "Id": "26728946", "Score": "4", "Body": "<p>No.</p>\n<p>Bit fields are implemented significantly differently between compilers. If you define a bit-field with two values, zero and one, and try to have an enum typed bit field then you may hit these problems:</p>\n<p>The bit field will be unsigned with gcc and clang, but signed with VC++. This means that in order to store zero and one you need a two-bit bit field (a one-bit signed bit field can only store zero and negative one).</p>\n<p>Then you have to worry about packing. VC++ will only pack adjacent bit fields into the same backing store if their sizes match. I'm not sure what the rules are for gcc and clang, but for VC++ the default backing store for a bit field is an int. So, a series of bit fields that are, for instance, a mixture of bool and enum will pack extremely poorly with VC++.</p>\n<p>You could try to solve this with C++ 11 typed enums:</p>\n<p>enum Foo : unsigned char { one, two };</p>\n<p>but then gcc complains if you use this in a one-bit bit field:</p>\n<p>warning: \u2018bitfieldTest::g\u2019 is too small to hold all values of \u2018enum Foo\u2019 [enabled by default]</p>\n<p>It seems there is no winning.</p>\n", "LastActivityDate": "2014-11-04T06:26:08.373"}, "11983231": {"CommentCount": "1", "AcceptedAnswerId": "11983430", "PostTypeId": "1", "LastEditorUserId": "520162", "CreationDate": "2012-08-16T08:23:46.810", "LastActivityDate": "2014-11-04T06:26:08.373", "LastEditDate": "2012-08-16T11:37:08.723", "ViewCount": "9852", "FavoriteCount": "2", "Title": "Is it safe to use an enum in a bit field?", "Id": "11983231", "Score": "23", "Body": "<p>Say, I've got the following struct:</p>\n<pre><code>typedef struct my_struct{\n    unsigned long       a;\n    unsigned long       b;\n    char*               c;\n    unsigned int        d1  :1;\n    unsigned int        d2  :4;\n    unsigned int        d3  :4;\n    unsigned int        d4  :23;\n} my_type, *p_type;\n</code></pre>\n<p>The field <code>d3</code> is currently defined by <code>#define</code>s that reach from <code>0x00</code> until <code>0x0D</code>.</p>\n<p>Actually, <code>d3</code> is an enumeration. So it's tempting to go ahead and replace </p>\n<pre><code>    unsigned int        d3  :4;\n</code></pre>\n<p>by</p>\n<pre><code>    my_enum             d3  :4;\n</code></pre>\n<p>Is this safe/allowed?</p>\n<p>The code has to compile with various</p>\n<ul>\n<li>compilers (GCC, Visual Studio, embedded stuff)</li>\n<li>platforms (Win32, Linux, embedded stuff)</li>\n<li>configurations (compile as C, compile as C++) </li>\n</ul>\n<p>Obviously, I could leave the definition of <code>d3</code> as it is and use the enum in my code, assign it to <code>d3</code> and so on but that's not going to work with C++.</p>\n", "Tags": "<c++><c><enums><bit-fields>", "OwnerUserId": "520162", "AnswerCount": "4"}, "11983423": {"ParentId": "11983231", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-08-16T08:38:02.303", "Score": "20", "LastEditorUserId": "1498580", "LastEditDate": "2012-08-16T08:51:57.403", "Id": "11983423", "OwnerUserId": "1498580", "Body": "<p>It's allowed in all C++ compilers, that supports standard.</p>\n<p>C++03 standard 9.6/3\n<blockquote>\n<p id=\"so_11983231_11983423_0\">\nA bit-field shall have integral or enumeration type (3.9.1). It is\nimplementation-defined whether a plain (neither explicitly signed nor unsigned) char, short, int or\nlong bit-field is signed or unsigned.</p></blockquote></p>\n<p>C++03 standard 9.6/4\n<blockquote><p id=\"so_11983231_11983423_1\">\nIf the value of an enu-\nmerator is stored into a bit-field of the same enumeration type and the number of bits in the bit-field is large\nenough to hold all the values of that enumeration type, the original enumerator value and the value of the bit-field shall compare equal.</p></blockquote></p>\n<p>example</p>\n<pre><code>enum BOOL { f=0, t=1 };\nstruct A {\nBOOL b:1;\n};\nA a;\nvoid f() {\na.b = t;\nif (a.b == t) // shall yield true\n{ /* ... */ }\n}\n</code></pre>\n<p>But you can't consider that enum has unsigned underlying type.</p>\n<p>C++03 standard 7.2/5\n<blockquote><p id=\"so_11983231_11983423_2\">\nThe underlying type of an enumeration is an integral type that can represent all the enumerator values\ndefined in the enumeration. It is implementation-defined which integral type is used as the underlying type\nfor an enumeration except that the underlying type shall not be larger than int unless the value of an enu-\nmerator cannot fit in an int or unsigned int</p></blockquote></p>\n", "LastActivityDate": "2012-08-16T08:51:57.403"}, "bq_ids": {"n4140": {"so_11983231_11983423_1": {"section_id": 5924, "quality": 0.9230769230769231, "length": 24}, "so_11983231_11983423_2": {"section_id": 5466, "quality": 0.7878787878787878, "length": 26}}, "n3337": {"so_11983231_11983423_0": {"section_id": 5695, "quality": 0.9047619047619048, "length": 19}, "so_11983231_11983423_1": {"section_id": 5696, "quality": 0.9230769230769231, "length": 24}, "so_11983231_11983423_2": {"section_id": 5252, "quality": 0.8181818181818182, "length": 27}}, "n4659": {"so_11983231_11983423_1": {"section_id": 7398, "quality": 0.9230769230769231, "length": 24}, "so_11983231_11983423_2": {"section_id": 6900, "quality": 0.7878787878787878, "length": 26}}}, "11983633": {"ParentId": "11983231", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-08-16T08:50:47.200", "Score": "0", "LastEditorUserId": "1126268", "LastEditDate": "2012-08-16T08:56:14.697", "Id": "11983633", "OwnerUserId": "1126268", "Body": "<p>In C it is an undefined behavior, because a bit-field can only have <code>signed int</code>, <code>int</code> or <code>unsigned int</code> types (or <code>_Bool</code> with C99).</p>\n<p><strong>6.5.2.1</strong> :</p>\n<blockquote>\n<p id=\"so_11983231_11983633_0\">A bit-field shall have a type that is a qualified or unqualified\n  version of one of int, unsigned int, or signed int. Whether the\n  high-order bit position of a (possibly qualified) \u201cplain\u201d int\n  bit-field is treated as a sign bit is implementation-defined. A\n  bit-field is interpreted as an integral type consisting of the\n  specified number of bits.</p>\n</blockquote>\n<p>Otherwise, some compilers accept it today as an extension (cf. implementation-defined behavior of the extensions in the standard).</p>\n", "LastActivityDate": "2012-08-16T08:56:14.697"}});