post_cb({"20832956": {"ParentId": "20832868", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You could use the following scheme (i.e., use pointers instead of concrete objects):</p>\n<pre><code>struct Foo;\nstruct Bar;\n\nstruct Foo \n  {\n  Bar *bar; \n  };\nstruct Bar \n  {\n  Foo *foo; \n  };\n</code></pre>\n<p>And allocate/deallocate <code>bar</code> and <code>foo</code> appropriately in your code.</p>\n<p>Reason: Although you forward declare your structs the compiler doesn't have any clue how to allocate the <code>Bar</code> concrete object in your <code>Foo</code> struct since it hasn't seen <code>Bar</code>'s reference yet.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2013-12-30T03:43:52.903", "Id": "20832956", "Score": "3", "CreationDate": "2013-12-30T03:35:10.137", "LastActivityDate": "2013-12-30T03:43:52.903"}, "20832868": {"CommentCount": "5", "ViewCount": "139", "CreationDate": "2013-12-30T03:24:03.117", "LastActivityDate": "2013-12-30T19:01:52.450", "Title": "Circular type dependency deadlock in C++", "AcceptedAnswerId": "20833051", "PostTypeId": "1", "Id": "20832868", "Score": "0", "Body": "<p>Let <code>Foo</code> and <code>Bar</code> be types. <code>Foo</code> has a <code>Bar bar</code> member, and <code>Bar</code> has a <code>Foo foo</code> member:</p>\n<pre><code>struct Foo;\nstruct Bar;\n\nstruct Foo { Bar bar; };\nstruct Bar { Foo foo; };\n</code></pre>\n<p>This can not compile, since <code>Foo</code> must be defined for <code>Bar</code> to be defined, but <code>Foo</code> cannot be defined until <code>Bar</code> is defined - a deadlock.</p>\n<p>Is there a solution to this problem?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "916907", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20832868_20833051_1": {"section_id": 5879, "quality": 1.0, "length": 25}, "so_20832868_20833051_0": {"section_id": 5869, "quality": 1.0, "length": 19}}, "n3337": {"so_20832868_20833051_0": {"section_id": 5640, "quality": 1.0, "length": 19}}, "n4659": {"so_20832868_20833051_1": {"section_id": 7363, "quality": 1.0, "length": 25}, "so_20832868_20833051_0": {"section_id": 7352, "quality": 1.0, "length": 19}}}, "20833051": {"ParentId": "20832868", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The almighty standard:</p>\n<p>\u00a7 9.2/9</p>\n<blockquote>\n<p id=\"so_20832868_20833051_0\">Non-static (9.4) data members shall not have incomplete types. In\n  particular, a class C shall not contain a non-static member of class\n  C, but it can contain a pointer or reference to an object of class C.</p>\n</blockquote>\n<p>And:</p>\n<p>\u00a7 9.2/19</p>\n<blockquote>\n<p id=\"so_20832868_20833051_1\">If a standard-layout class object has any non-static data members, its\n  address is the same as the address of its first non-static data\n  member. Otherwise, its address is the same as the address of its first\n  base class subobject (if any).</p>\n</blockquote>\n", "Id": "20833051", "LastEditDate": "2013-12-30T19:01:52.450", "OwnerDisplayName": "user1508519", "Score": "3", "CreationDate": "2013-12-30T03:48:35.500", "LastActivityDate": "2013-12-30T19:01:52.450", "LastEditorDisplayName": "user1508519"}});