post_cb({"4137115": {"Id": "4137115", "PostTypeId": "2", "Body": "<p>It's not as well defined as you probably want it to be.  Most of the relevant standardese from C++98 is in section 1.9, \"Program Execution\":</p>\n<blockquote>\n<p id=\"so_4136900_4137115_0\">The observable behavior of the abstract machine is its sequence of reads and writes to <code>volatile</code> data and calls to library I/O functions.</p>\n<p id=\"so_4136900_4137115_1\">Accessing an object designated by a <code>volatile</code> lvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all <em>side effects</em>, which are changes in the state of the execution environment. Evaluation of an expression might produce side effects. At certain specified points in the execution sequence called <em>sequence points</em>, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place.</p>\n<p id=\"so_4136900_4137115_2\">Once the execution of a function begins, no expressions from the calling function are evaluated until execution of the called function has completed.</p>\n<p id=\"so_4136900_4137115_3\">When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects with type other than <code>volatile sig_atomic_t</code> are unspecified, and the value of any object not of <code>volatile sig_atomic_t</code> that is modified by the handler becomes undefined.</p>\n<p id=\"so_4136900_4137115_4\">An instance of each object with automatic storage duration (3.7.2) is associated with each entry into its block. Such an object exists and retains its last-stored value during the execution of the block and while the block is suspended (by a call of a function or receipt of a signal).</p>\n<p id=\"so_4136900_4137115_5\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li><p id=\"so_4136900_4137115_6\">At sequence points, <code>volatile</code> objects are stable in the sense that previous evaluations are complete and subsequent evaluations have not yet occurred.</p></li>\n<li><p id=\"so_4136900_4137115_7\">At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</p></li>\n<li><p id=\"so_4136900_4137115_8\">The input and output dynamics of interactive devices shall take place in such a fashion that prompting messages actually appear prior to a program waiting for input. What constitutes an interactive device is implementation-defined.</p></li>\n</ul>\n</blockquote>\n<p>So what that boils down to is:</p>\n<ul>\n<li><p>The compiler cannot optimize away reads or writes to <code>volatile</code> objects.  For simple cases like the one casablanca mentioned, that works the way you might think. However, in cases like</p>\n<pre><code>volatile int a;\nint b;\nb = a = 42;\n</code></pre>\n<p>people can and do argue about whether the compiler has to generate code as if the last line had read</p>\n<pre><code>a = 42; b = a;\n</code></pre>\n<p>or if it can, as it normally would (in the absence of <code>volatile</code>), generate</p>\n<pre><code>a = 42; b = 42;\n</code></pre>\n<p>(C++0x may have addressed this point, I haven't read the whole thing.)</p></li>\n<li><p>The compiler may not reorder operations on two different <code>volatile</code> objects that occur in separate statements (every semicolon is a sequence point) but it is totally allowed to rearrange accesses to non-volatile objects relative to volatile ones.  This is one of the many reasons why you should not try to write your own spinlocks, and is the primary reason why John Dibling is warning you not to treat <code>volatile</code> as a panacea for multithreaded programming.</p></li>\n<li><p>Speaking of threads, you will have noticed the <strong>complete absence</strong> of any mention of threads in the standards text.  That is because <strong>C++98 has no concept of threads</strong>.  (C++0x does, and may well specify their interaction with <code>volatile</code>, but I wouldn't be assuming anyone implements those rules yet if I were you.)  Therefore, there is <em>no</em> guarantee that accesses to <code>volatile</code> objects from one thread are visible to another thread.  This is the other major reason <code>volatile</code> is not especially useful for multithreaded programming.</p></li>\n<li><p>There is no guarantee that <code>volatile</code> objects are accessed in one piece, or that modifications to <code>volatile</code> objects avoid touching other things right next to them in memory.  This is not explicit in what I quoted but is implied by the stuff about <code>volatile sig_atomic_t</code> -- the <code>sig_atomic_t</code> part would be unnecessary otherwise.  This makes <code>volatile</code> substantially less useful for access to I/O devices than it was probably intended to be, and compilers marketed for embedded programming often offer stronger guarantees, but it's not something you can count on.</p></li>\n<li><p>Lots of people try to make <em>specific accesses</em> to objects have <code>volatile</code> semantics, e.g. doing</p>\n<pre><code>T x;\n*(volatile T *)&amp;x = foo();\n</code></pre>\n<p>This is legit (because it says \"object <em>designated by a volatile lvalue</em>\" and not \"object <em>with a volatile type</em>\") but has to be done with great care, because remember what I said about the compiler being totally allowed to reorder non-volatile accesses relative to volatile ones?  That goes <strong>even if it's the same object</strong> (as far as I know anyway).</p></li>\n<li><p>If you are worried about reordering of accesses to more than one volatile value, you need to understand the <em>sequence point</em> rules, which are long and complicated and I'm not going to quote them here because this answer is already too long, but <a href=\"http://publications.gbdirect.co.uk/c_book/chapter8/sequence_points.html\" rel=\"noreferrer\">here's a good explanation which is only a little simplified</a>.  If you find yourself needing to worry about the differences in the sequence point rules between C and C++ you have already screwed up somewhere (for instance, as a rule of thumb, never overload <code>&amp;&amp;</code>).</p></li>\n</ul>\n", "LastEditorUserId": "388520", "LastActivityDate": "2010-11-09T19:50:15.013", "Score": "10", "CreationDate": "2010-11-09T18:25:23.557", "ParentId": "4136900", "CommentCount": "3", "OwnerUserId": "388520", "LastEditDate": "2010-11-09T19:50:15.013"}, "4137166": {"Id": "4137166", "PostTypeId": "2", "Body": "<p>A particular and very common optimization that is ruled out by <code>volatile</code> is to cache a value from memory into a register, and use the register for repeated access (because this is much faster than going back to memory every time). </p>\n<p>Instead the compiler <em>must</em> fetch the value from memory every time (taking a hint from Zach, I should say that \"every time\" is bounded by sequence points).</p>\n<p>Nor can a sequence of writes make use of a register and only write the final value back later on: every write <em>must</em> be pushed out to memory.</p>\n<p>Why is this useful? On some architectures certain IO devices map their inputs or outputs to a memory location (i.e. a byte written to that location actually goes out on the serial line). If the compiler redirects some of those writes to a register that is only flushed occasionally then most of the bytes <em>won't</em> go onto the serial line. Not good. Using <code>volatile</code> prevents this situation.</p>\n", "LastEditorUserId": "2509", "LastActivityDate": "2010-11-09T18:36:26.873", "Score": "2", "CreationDate": "2010-11-09T18:31:21.210", "ParentId": "4136900", "CommentCount": "0", "OwnerUserId": "2509", "LastEditDate": "2010-11-09T18:36:26.873"}, "4137088": {"Id": "4137088", "PostTypeId": "2", "Body": "<p>What you know is false.  Volatile is <em>not</em> used to synchronize memory access between threads, apply any kind of memory fences, or anything of the sort.  Operations on <code>volatile</code> memory are not atomic, and they are not guaranteed to be in any particular order.  <code>volatile</code> is one of the most misunderstood facilities in the entire language.  \"<a href=\"http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming/\" rel=\"noreferrer\">Volatile is almost useless for multi-threadded programming.</a>\"</p>\n<p>What <code>volatile</code> is used for is interfacing with memory-mapped hardware, signal handlers and the <code>setjmp</code> machine code instruction.</p>\n<p>It can also be used in a similar way that <code>const</code> is used, and this is how Alexandrescu uses it in <a href=\"http://www.drdobbs.com/184403766\" rel=\"noreferrer\">this article</a>.  But make no mistake.  <code>volatile</code> doesn't make your code magically thread safe.  Used in this specific way, it is simply a tool that can help the compiler tell you where you might have messed up.  It is still up to you to fix your mistakes, and <code>volatile</code> plays <em>no role</em> in fixing those mistakes.</p>\n<p>EDIT:  I'll try to elaborate a little bit on what I just said.</p>\n<p>Suppose you have a class that has a pointer to something that <em>cannot change</em>.  You might naturally make the pointer const:</p>\n<pre><code>class MyGizmo\n{ \npublic:\n  const Foo* foo_;\n};\n</code></pre>\n<p>What does <code>const</code> really do for you here?  It doesn't do anything to the memory.  It's not like the write-protect tab on an old floppy disc.  The memory itself it still writable.  You just can't write to it through the <code>foo_</code> pointer.  So <code>const</code> is really just a way to give the compiler another way to let you know when you might be messing up.  If you were to write this code:</p>\n<pre><code>gizmo.foo_-&gt;bar_ = 42;\n</code></pre>\n<p>...the compiler won't allow it, because it's marked <code>const</code>.  Obviously you can get around this by using <code>const_cast</code> to cast away the <code>const</code>-ness, but if you need to be convinced this is a bad idea then there is no help for you. :)</p>\n<p>Alexandrescu's use of <code>volatile</code> is exactly the same.  It doesn't do anything to make the memory somehow \"thread safe\" <em>in any way whatsoever</em>.  What it does is it gives the compiler another way to let you know when you may have screwed up.  You mark things that you have made truly \"thread safe\" (through the use of actual synchronization objects, like Mutexes or Semaphores) as being <code>volatile</code>.  Then the compiler won't let you use them in a non-<code>volatile</code> context.  It throws a compiler error you then have to think about and fix.  You could again get around it by casting away the <code>volatile</code>-ness using <code>const_cast</code>, but this is just as Evil as casting away <code>const</code>-ness.</p>\n<p>My advice to you is to completely abandon <code>volatile</code> as a tool in writing multithreadded applications (edit:) until you <em>really</em> know what you're doing and why.  It has some benefit but not in the way that most people think, and if you use it incorrectly, you could write dangerously unsafe applications.</p>\n", "LastEditorUserId": "241536", "LastActivityDate": "2010-11-12T21:18:00.720", "Score": "18", "CreationDate": "2010-11-09T18:21:42.907", "ParentId": "4136900", "CommentCount": "13", "OwnerUserId": "241536", "LastEditDate": "2010-11-12T21:18:00.720"}, "4136995": {"Id": "4136995", "PostTypeId": "2", "Body": "<p>Declaring a variable as <code>volatile</code> means the compiler can't make any assumptions about the value that it could have done otherwise, and hence prevents the compiler from applying various optimizations. Essentially it forces the compiler to re-read the value from memory on each access, even if the normal flow of code doesn't change the value. For example:</p>\n<pre><code>int *i = ...;\ncout &lt;&lt; *i; // line A\n// ... (some code that doesn't use i)\ncout &lt;&lt; *i; // line B\n</code></pre>\n<p>In this case, the compiler would normally assume that since the value at <code>i</code> wasn't modified in between, it's okay to retain the value from line A (say in a register) and print the same value in B. However, if you mark <code>i</code> as <code>volatile</code>, you're telling the compiler that some external source could have possibly modified the value at <code>i</code> between line A and B, so the compiler <em>must</em> re-fetch the current value from memory.</p>\n", "LastActivityDate": "2010-11-09T18:13:15.757", "CommentCount": "0", "CreationDate": "2010-11-09T18:13:15.757", "ParentId": "4136900", "Score": "7", "OwnerUserId": "381345"}, "bq_ids": {"n4140": {"so_4136900_4137115_5": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_4136900_4137115_8": {"length": 16, "quality": 0.7272727272727273, "section_id": 5804}, "so_4136900_4137115_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 5803}, "so_4136900_4137115_7": {"length": 17, "quality": 1.0, "section_id": 5804}, "so_4136900_4137115_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 5811}}, "n3337": {"so_4136900_4137115_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 5576}, "so_4136900_4137115_3": {"length": 18, "quality": 0.782608695652174, "section_id": 5575}, "so_4136900_4137115_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 5584}, "so_4136900_4137115_5": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_4136900_4137115_8": {"length": 16, "quality": 0.7272727272727273, "section_id": 5577}, "so_4136900_4137115_7": {"length": 17, "quality": 1.0, "section_id": 5577}}, "n4659": {"so_4136900_4137115_5": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_4136900_4137115_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 7261}, "so_4136900_4137115_7": {"length": 17, "quality": 1.0, "section_id": 7262}, "so_4136900_4137115_8": {"length": 16, "quality": 0.7272727272727273, "section_id": 7262}}}, "4136900": {"ViewCount": "3917", "Body": "<p>I know when reading from a location of memory which is written to by several threads or processes the <strong>volatile</strong> keyword should be used for that location like some cases below but I want to know more about what restrictions does it really make for compiler and basically what rules does compiler have to follow when dealing with such case and is there any exceptional case where despite simultaneous access to a memory location the volatile keyword can be ignored by programmer.</p>\n<pre><code>volatile SomeType * ptr = someAddress;\nvoid someFunc(volatile const SomeType &amp; input){\n //function body\n}\n</code></pre>\n", "AcceptedAnswerId": "4137166", "Title": "What Rules does compiler have to follow when dealing with volatile memory locations?", "CreationDate": "2010-11-09T18:01:14.943", "Id": "4136900", "CommentCount": "6", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2010-11-12T21:18:00.720", "Score": "10", "OwnerUserId": "388056", "Tags": "<c++><memory><compiler-construction><rules><volatile>", "AnswerCount": "5"}, "4137001": {"Id": "4137001", "PostTypeId": "2", "Body": "<p>The compiler is not allowed to optimize away reads of a volatile object in a loop, which otherwise it'd normally do (i.e. strlen()).</p>\n<p>It's commonly used in embedded programming when reading a hardware registry at a fixed address, and that value may change unexpectedly. (In contrast with \"normal\" memory, that doesn't change unless written to by the program itself...)</p>\n<p>That is it's main purpose.</p>\n<p>It could also be used to make sure one thread see the change in a value written by another, but it in no way guarantees atomicity when reading/writing to said object.</p>\n", "LastActivityDate": "2010-11-09T18:13:56.570", "CommentCount": "0", "CreationDate": "2010-11-09T18:13:56.570", "ParentId": "4136900", "Score": "1", "OwnerUserId": "72312"}});