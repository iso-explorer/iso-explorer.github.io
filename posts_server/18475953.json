post_cb({"18475953": {"CommentCount": "2", "AcceptedAnswerId": "18476032", "CreationDate": "2013-08-27T21:41:02.943", "LastActivityDate": "2013-08-28T14:35:49.663", "PostTypeId": "1", "ViewCount": "88", "FavoriteCount": "1", "Title": "Can user edit invalidate code before current token?", "Id": "18475953", "Score": "2", "Body": "<p>I'm working on a source editor for C++ and came up with simple optimization that I do not need to invalidate (e.g. highlighting, rebuild AST, do static analysis) the code before the currently edited statement (basically, before the previous semicolon/closing brace) but I am not sure if this is always true for C++.</p>\n<p>E.g. in Java it is possible to call functions declared/defined after the edit location. Hence, if the user adds an argument to the function then error marker should be placed in the code before the edit location. In C++ function should be declared before it is used (and if the declaration does not match definition the error will be on definition).</p>\n", "Tags": "<c++><parsing>", "OwnerUserId": "93961", "AnswerCount": "3"}, "18476032": {"ParentId": "18475953", "CommentCount": "7", "Body": "<p>Member function bodies defined inline in the class will be conceptually (and actually, in the compilers I know) parsed at the end of the class and can thus access members of the class declared after them.</p>\n", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "18476032", "Score": "3", "CreationDate": "2013-08-27T21:47:44.917", "LastActivityDate": "2013-08-27T21:47:44.917"}, "18489952": {"ParentId": "18475953", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In general, outside a template definition, the rules for name lookup in C++ require a name to be declared before the point at which it is used. Your idea would therefore work in most cases. Unfortunately - as pointed out by SebastianRedl - there is a special case in which this rule of thumb does not apply.</p>\n<p>Within a class definition, the declarations of all members of the class (and its enclosing class(es)) are visible during name lookup within the body of a member function (including a ctor-initializer-list or exception-specification), or in a default argument of a member function.</p>\n<p>An illustration:</p>\n<pre><code>struct A\n{\n    struct B\n    {\n        static void f(int i = M()) // uses 'A::M' declared later\n        {\n            A::f(); // calls A::f(int) declared later\n        }\n    };\n\n    static void f(void*)\n    {\n        f(); // calls A::f(int) declared later\n    }\n\n    static void f(int i = M()) // uses 'M' declared later\n    {\n    }\n\n    typedef int M;\n};\n</code></pre>\n<p>If the token that was modified occurs within a member function-body or a default argument, you would have to reparse all classes that enclose the token.</p>\n<p>From C++ Working Draft Standard N3337:</p>\n<blockquote>\n<h3>3.4.1 Unqualified name lookup [basic.lookup.unqual]</h3>\n<p id=\"so_18475953_18489952_0\">A name used in the definition of a member function (9.3) of class X following the function\u2019s declarator-id\n  or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of\n  the following ways:</p>\n<p id=\"so_18475953_18489952_1\">\u2014 before its use in the block in which it is used or in an enclosing block (6.3), or</p>\n<p id=\"so_18475953_18489952_2\">\u2014 shall be a member of class X or be a member of a base class of X (10.2), or</p>\n<p id=\"so_18475953_18489952_3\">\u2014 if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y\n  (this lookup applies in turn to Y\u2019s enclosing classes, starting with the innermost enclosing class), or</p>\n<p id=\"so_18475953_18489952_4\">\u2014 if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block\n  enclosing the definition of class X, or</p>\n<p id=\"so_18475953_18489952_5\">\u2014 if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class\n  or a nested class within a local class of a function that is a member of N, before the use of the name,\n  in namespace N or in one of N \u2019s enclosing namespaces.</p>\n</blockquote>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2013-08-28T14:35:49.663", "Id": "18489952", "Score": "1", "CreationDate": "2013-08-28T13:54:05.357", "LastActivityDate": "2013-08-28T14:35:49.663"}, "bq_ids": {"n4140": {"so_18475953_18489952_1": {"section_id": 7094, "quality": 1.0, "length": 6}, "so_18475953_18489952_5": {"section_id": 7094, "quality": 1.0, "length": 22}, "so_18475953_18489952_4": {"section_id": 7093, "quality": 1.0, "length": 13}, "so_18475953_18489952_0": {"section_id": 7092, "quality": 0.5294117647058824, "length": 9}, "so_18475953_18489952_3": {"section_id": 7093, "quality": 1.0, "length": 16}, "so_18475953_18489952_2": {"section_id": 187, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_18475953_18489952_1": {"section_id": 6838, "quality": 1.0, "length": 6}, "so_18475953_18489952_5": {"section_id": 6838, "quality": 1.0, "length": 22}, "so_18475953_18489952_4": {"section_id": 6837, "quality": 1.0, "length": 13}, "so_18475953_18489952_0": {"section_id": 6838, "quality": 1.0, "length": 17}, "so_18475953_18489952_3": {"section_id": 6837, "quality": 1.0, "length": 16}, "so_18475953_18489952_2": {"section_id": 181, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_18475953_18489952_1": {"section_id": 8595, "quality": 1.0, "length": 6}, "so_18475953_18489952_5": {"section_id": 8595, "quality": 1.0, "length": 22}, "so_18475953_18489952_4": {"section_id": 8594, "quality": 1.0, "length": 13}, "so_18475953_18489952_0": {"section_id": 8594, "quality": 0.5294117647058824, "length": 9}, "so_18475953_18489952_3": {"section_id": 8594, "quality": 1.0, "length": 16}, "so_18475953_18489952_2": {"section_id": 192, "quality": 0.8333333333333334, "length": 5}}}, "18489142": {"ParentId": "18475953", "CommentCount": "0", "Body": "<p>Templates are compiled in two phases. The first phase is where they're defined, the second where they're instantiated. The current compilers can blame you for template errors at the point of instantiation, when substituting the actual arguments leads to an error in the template. </p>\n<p>It would be entirely reasonable for your editor to follow the same logic. If the template definition looks good when you see it, it passes the first phase. When the code being edited instantiates a template, re-check, and blame any errors in the second phase on the instantiation.</p>\n<p>This hints at a more fundamental problem. Where do you say an error occurred? The C++ standard doesn't care. As far as it's concerned, \"syntax error somewhere\" is a sufficient diagnostic. So, if there's an inline method trying to access a non-existing member <code>this-&gt;a</code>, you can claim there's an error in the method. But with equal validity, you can claim at the final <code>};</code> that the class failed to define the necessary member <code>a</code>. </p>\n<p>The underlying cause of all these errors is that two pieces of code must agree on something. When they don't, you can choose who to blame. For your editor, you could blame the fragment which came last. It's just a matter of getting the diagnostic wording right. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "18489142", "Score": "1", "CreationDate": "2013-08-28T13:19:08.610", "LastActivityDate": "2013-08-28T13:19:08.610"}});