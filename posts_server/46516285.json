post_cb({"bq_ids": {"n4140": {"so_46516285_46516285_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 6169}, "so_46516285_46516285_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 6170}, "so_46516285_46516285_1": {"length": 19, "quality": 0.95, "section_id": 6169}}, "n3337": {"so_46516285_46516285_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 5930}, "so_46516285_46516285_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 5931}, "so_46516285_46516285_1": {"length": 19, "quality": 0.95, "section_id": 5930}}, "n4659": {"so_46516285_46516285_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 7667}, "so_46516285_46516285_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 7668}, "so_46516285_46516285_1": {"length": 11, "quality": 0.55, "section_id": 7667}}}, "46516285": {"ViewCount": "230", "Body": "<p>Should this program output 0 or 1? In my reading and understanding of the cited paragraphs from the C++14 standard, it should print 1, but both GCC and clang prints 0 (because the deduced type is <code>A const</code> instead of <code>A const&amp;</code>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {};\n\nint main()\n{\n    A a;\n    A const&amp; ra = std::move(a); // #1\n\n    std::cout &lt;&lt; std::is_same&lt;decltype(true ? ra : std::move(a)),\n                              A const&amp;&gt;::value; // Prints 0\n}\n</code></pre>\n<p>In this case, <code>ra</code> is a <code>A const</code> lvalue, and <code>std::move(a)</code> is a <code>A</code> xvalue, both of class-types. According to the standard about the conditional operator (emphasis mine), the result should be an <code>lvalue</code> of type <code>A const</code>, and thus the <code>decltype</code> result must be <code>A const&amp;</code>:</p>\n<blockquote>\n<p id=\"so_46516285_46516285_0\"><strong>[expr.cond]/3</strong> Otherwise, if the second and third operand have different types and <strong>either has (possibly cv-qualified) class\n  type</strong>, or if both are glvalues of the same value category and the same type except for cv-qualification, an\n  attempt is made to convert each of those operands to the type of the other. The process for determining\n  whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type\n  T2 is defined as follows:</p>\n<p id=\"so_46516285_46516285_1\">\u2014 If <strong>E2 is an lvalue</strong>: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the\n  type <strong>\u201clvalue reference to T2\u201d</strong>, subject to the constraint that in the conversion the reference <strong>must bind directly (8.5.3) to an lvalue</strong>.</p>\n<p id=\"so_46516285_46516285_2\">[...]</p>\n</blockquote>\n<p>In this case, <strong>E2</strong> is <code>ra</code>, which is a lvalue, and the other can be implicitely converted to <strong>\"lvalue reference to T2\"</strong>, as shown in line <code>// #1</code>. <strong>\"lvalue reference to T2\"</strong> is translated as <code>A const&amp;</code>, so, <code>std::move(a)</code> binds directly to a lvalue of type <code>A const</code>, and after the conversion, both operands have same type and value category, and thus:</p>\n<blockquote>\n<p id=\"so_46516285_46516285_3\"><strong>[expr.cond]/3</strong> If the second and third operands are glvalues of the same value category and have the same type, the result is of that type and value category [...].</p>\n</blockquote>\n<p>So, the operator result should be an lvalue and the <code>decltype</code> result should be a reference, and thus the program should print 1.</p>\n", "AcceptedAnswerId": "46516847", "Title": "Conditional operator with same underlying class type", "CreationDate": "2017-10-01T19:51:15.543", "Id": "46516285", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-10-02T02:18:49.223", "LastEditorUserId": "2069064", "LastActivityDate": "2017-10-02T02:18:49.223", "Score": "5", "OwnerUserId": "1794803", "Tags": "<c++><c++14><conditional-operator><decltype>", "AnswerCount": "1"}, "46516847": {"Id": "46516847", "PostTypeId": "2", "Body": "<p>The question is awkwardly worded. You should instead ask what the type and value category of the expression <code>true ? ra : std::move(a)</code> should be. The answer to that question is a prvalue of type <code>A const</code>. This subsequently means the program should print 0, as I think every compiler correctly does.</p>\n<hr/>\n<p>The rules for <code>?:</code> are fairly complex. In this case, we have two expressions of class type that we try to see if we can convert to each other, based on a limited subset of rules.</p>\n<p>Attempting the conversion <code>ra</code> \u2192 <code>std::move(a)</code> fails. We first try with a  <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#3.2\" rel=\"nofollow noreferrer\">target type</a> is <code>A&amp;&amp;</code> which can't bind directly to <code>ra</code>. We then try the backup plan in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#3.3.1\" rel=\"nofollow noreferrer\">(3.3.1)</a> since the two expressions have the same underlying class type, but our target expression is not at least as cv-qualified as the source expression, so this also fails. </p>\n<p>Attempting the conversion <code>std::move(a)</code> \u2192 <code>ra</code> fails <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#3.1\" rel=\"nofollow noreferrer\">(3.1)</a> because we need to bind directly to an lvalue (we can bind an rvalue to a const lvalue reference, but here we are <strong>required</strong> to bind an lvalue). But, the <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#3.3.1\" rel=\"nofollow noreferrer\">(3.3.1)</a> backup succeeds because now the target type <em>is</em> at least as cv-qualified as the source. </p>\n<p>Hence, we apply the conversion and we continue as if the second operand were an lvalue of type <code>A const</code> but the third operand is now a prvalue of type <code>A const</code> (instead of an xvalue of type <code>A</code>).</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#4\" rel=\"nofollow noreferrer\">(4)</a> fails, because they're not of the same value category.</p>\n<p>Hence, the <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#5\" rel=\"nofollow noreferrer\">result is a prvalue</a>. And since they have the same type, <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#6.1\" rel=\"nofollow noreferrer\">the result is of that type</a>: <code>A const</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-10-01T22:58:24.310", "Score": "6", "CreationDate": "2017-10-01T21:00:03.397", "ParentId": "46516285", "CommentCount": "8", "OwnerUserId": "2069064", "LastEditDate": "2017-10-01T22:58:24.310"}});