post_cb({"5503625": {"ParentId": "5503473", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you really, really wanted to, you could dynamically allocate an array and return a pointer to that array: </p>\n<pre><code>std::string* getArray() \n{\n  return (new std::string[10]);\n}\n</code></pre>\n<p>BUT you then need to cater for freeing up the memory you allocated using <code>delete[]</code> to avoid a memory leak. </p>\n<p>Ask yourself: </p>\n<ul>\n<li>Which bit of your code should be responsible for doing this? </li>\n<li>Will you remember that that pointer represents a dynamically-allocated array later on, elsewhere in your code? </li>\n<li>What happens if you pass that pointer around your program and accidentally use it somewhere after another bit of code has called <code>delete[]</code> on it? (Segmentation fault is the answer).</li>\n<li>If you pass a pointer to an array around, how does the code that uses that pointer know the size of your array? <code>std::vector</code> keeps count of the items for you, so no problem there.</li>\n</ul>\n<p>That's why using an <code>std::vector&lt;std::string&gt;</code> is a better idea. Returning a pointer to a dynamically allocated array introduces all sorts of problems that are better avoided than solved.</p>\n", "OwnerUserId": "27615", "LastEditorUserId": "27615", "LastEditDate": "2011-03-31T17:25:12.830", "Id": "5503625", "Score": "3", "CreationDate": "2011-03-31T17:12:04.680", "LastActivityDate": "2011-03-31T17:25:12.830"}, "5503492": {"ParentId": "5503473", "CommentCount": "0", "Body": "<p>Don't. Arrays are not copyable.</p>\n<p>Use a <code>std::vector&lt;std::string&gt;</code> instead.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "5503492", "Score": "14", "CreationDate": "2011-03-31T16:59:35.037", "LastActivityDate": "2011-03-31T16:59:35.037"}, "5504095": {"ParentId": "5503473", "CommentCount": "1", "Body": "<p>I'd advise against returning an <code>std::vector&lt;std::string&gt;</code> as well. Instead, I'd pass an iterator, and have the function write the data to wherever the iterator points. This way, the function can equally well write the data to a vector, or a deque, or (if you want) directly to an output stream.</p>\n<p>Using that, your function borders on trivial:</p>\n<pre><code>// I've changed the definition slightly, to let you pass it a filename instead\n// of hard-coding one.\n//\ntemplate &lt;class outIt&gt;\nvoid read_file(std::string const &amp;filename, outIt output) { \n     std::ifstream in(filename);\n     std::string line;\n\n     while (std::getline(in, line))\n         *output++ = line;\n}\n</code></pre>\n<p>To use this to copy the data to standard output, roughly as in the question, you'd do something like:</p>\n<pre><code>read_file(\"plik\", std::ostream_iterator&lt;std::string&gt;(std::cout, \"\\n\"));\n</code></pre>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "5504095", "Score": "2", "CreationDate": "2011-03-31T17:48:28.657", "LastActivityDate": "2011-03-31T17:48:28.657"}, "5503643": {"ParentId": "5503473", "CommentCount": "0", "Body": "<p>Standard 8.3.5p6:</p>\n<blockquote>\n<p id=\"so_5503473_5503643_0\">Functions shall not have a return type of type array or function, although they may have a return type of type pointer or reference to such things.</p>\n</blockquote>\n<p>As @Tomalak hinted, Just Say No to arrays.  They're related to all sorts of gotchas that you can usually avoid if you can use a <code>vector</code> instead.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "5503643", "Score": "3", "CreationDate": "2011-03-31T17:13:40.783", "LastActivityDate": "2011-03-31T17:13:40.783"}, "5503473": {"CommentCount": "0", "ViewCount": "9561", "PostTypeId": "1", "LastEditorUserId": "27615", "CreationDate": "2011-03-31T16:58:05.443", "LastActivityDate": "2011-03-31T17:48:28.657", "Title": "How to return array of strings?", "AcceptedAnswerId": "5503492", "LastEditDate": "2011-03-31T17:30:25.117", "Id": "5503473", "Score": "2", "Body": "<p>I have function:</p>\n<pre><code>int read_file() {\n  ifstream file(\"plik\");\n  if(!file.is_open()) {\n    throw -1;\n  }\n  int i = 0;\n  string line[MAXSIZE];\n  while(getline(plik, line[i])) {\n    cout&lt;&lt;line[i]&lt;&lt;endl;\n    i++;\n  }\n\n  return i; \n}\n</code></pre>\n<p>But i want to return array of strings: </p>\n<p><code>line[]</code></p>\n<p>How can I do this?</p>\n", "Tags": "<c++><arrays><string><return>", "OwnerUserId": "543327", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5503473_5503643_0": {"section_id": 3244, "quality": 1.0, "length": 18}}, "n3337": {"so_5503473_5503643_0": {"section_id": 3117, "quality": 1.0, "length": 18}}, "n4659": {"so_5503473_5503643_0": {"section_id": 4002, "quality": 1.0, "length": 18}}}});