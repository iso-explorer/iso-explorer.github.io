post_cb({"bq_ids": {"n4140": {"so_11288981_11289102_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 383}}, "n3337": {"so_11288981_11289102_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 374}}, "n4659": {"so_11288981_11289102_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 400}}}, "11288981": {"ViewCount": "3092", "Body": "<p>I think following code should generate an error:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstatic void pr(const std::string &amp;aStr)\n{\n    std::cout &lt;&lt; aStr &lt;&lt; \"\\n\";\n}\n\nint main(void)\n{\n    const char *a = \"Hellu\";\n\n    pr(a);\n\n    return 0;\n}\n</code></pre>\n<p>But gcc 4.1.2 compiles it successuflly.</p>\n<p>Is it that the constructor of std::string get in the way, creating an instance of std::string?</p>\n<p>I believe it shouldn't, because reference is merely an alias to a variable (in this case, there is no variable of type std::string that the reference is referring to).</p>\n<p>Is anybody out there to explain why the code compiles successfully?</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "11289054", "Title": "Conversion from const char * to const std::string &", "CreationDate": "2012-07-02T06:53:51.623", "Id": "11288981", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-07-02T07:27:30.330", "LastEditorUserId": "1085251", "LastActivityDate": "2012-07-02T07:27:30.330", "Score": "5", "OwnerUserId": "1085251", "Tags": "<c++>", "AnswerCount": "2"}, "11289054": {"Id": "11289054", "PostTypeId": "2", "Body": "<p>Yes, given a reference to a <em>constant</em>, the compiler can/will synthesize a temporary (in this case of type <code>std::string</code>) and bind the reference to that temporary.</p>\n<p>If the reference was not to a const object, however, that wouldn't work -- only a reference to const can bind to a temporary object like that (though at least widely used compiler allows a non-const reference to bind to a reference as well).</p>\n", "LastActivityDate": "2012-07-02T06:59:50.043", "CommentCount": "10", "CreationDate": "2012-07-02T06:59:50.043", "ParentId": "11288981", "Score": "10", "OwnerUserId": "179910"}, "11289102": {"Id": "11289102", "PostTypeId": "2", "Body": "<p>What you encounter is implicit conversion.</p>\n<p>Here is a quote from the C++ Standard (SC22-N-4411.pdf) </p>\n<blockquote>\n<p id=\"so_11288981_11289102_0\">1 Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are called user-defined conversions and are used for <strong>implicit</strong> type conversions (Clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n</blockquote>\n<p>So the compiler just works as intended and calls the <code>std::string</code> constructor you mentioned.</p>\n", "LastActivityDate": "2012-07-02T07:03:34.087", "CommentCount": "0", "CreationDate": "2012-07-02T07:03:34.087", "ParentId": "11288981", "Score": "2", "OwnerUserId": "1465785"}});