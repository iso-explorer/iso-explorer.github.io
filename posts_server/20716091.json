post_cb({"bq_ids": {"n4140": {"so_20716091_20716155_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 7136}, "so_20716091_20716155_2": {"length": 7, "quality": 0.875, "section_id": 7136}, "so_20716091_20716155_3": {"length": 7, "quality": 0.875, "section_id": 5768}, "so_20716091_20716155_5": {"length": 4, "quality": 1.0, "section_id": 369}}, "n3337": {"so_20716091_20716155_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 6880}, "so_20716091_20716155_2": {"length": 7, "quality": 0.875, "section_id": 6880}, "so_20716091_20716155_3": {"length": 7, "quality": 0.875, "section_id": 5541}, "so_20716091_20716155_5": {"length": 4, "quality": 1.0, "section_id": 359}}, "n4659": {"so_20716091_20716155_4": {"length": 12, "quality": 0.8, "section_id": 8637}, "so_20716091_20716155_2": {"length": 7, "quality": 0.875, "section_id": 8637}, "so_20716091_20716155_3": {"length": 7, "quality": 0.875, "section_id": 7225}, "so_20716091_20716155_5": {"length": 4, "quality": 1.0, "section_id": 382}}}, "20716091": {"ViewCount": "1258", "Body": "<p>When I declared and initialized a const object.</p>\n<pre><code>// ConstClass.h\nclass ConstClass\n{\n};\n\nconst ConstClass g_Const;\n</code></pre>\n<p>And two cpp files include this header.</p>\n<pre><code>// Unit1.cpp\n#include \"ConstClass.h\"\n#include \"stdio.h\"\n\nvoid PrintInUnit1( )\n{\n    printf( \"g_Const in Unit1 is %d.\\r\\n\", &amp;g_Const );\n}\n</code></pre>\n<p>and</p>\n<pre><code>// Unit2.cpp\n#include \"ConstClass.h\"\n#include \"stdio.h\"\n\nvoid PrintInUnit2( )\n{\n    printf( \"g_Const in Unit2 is %d.\\r\\n\", &amp;g_Const );\n}\n</code></pre>\n<p>When i build the solution, there was no link error, what you will get If g_Const is a non-const fundamental type!</p>\n<p>And PrintInUnit1() and PrintInUnit2() show that there are two independent \"g_Const\"s with different address in two compilation units, Why?</p>\n<p>==============</p>\n<p>I know how to fix it.(use extern keyword to declaration, and define it in one cpp file.)</p>\n<p>I wonder to know why I did't get redfined link error in this sample.</p>\n", "AcceptedAnswerId": "20716155", "Title": "Global const object shared between compilation units", "CreationDate": "2013-12-21T06:11:03.820", "Id": "20716091", "CommentCount": "0", "LastEditDate": "2013-12-21T07:29:56.467", "PostTypeId": "1", "LastEditorUserId": "3124700", "LastActivityDate": "2013-12-21T07:29:56.467", "Score": "4", "OwnerUserId": "3124700", "Tags": "<c++><hyperlink><global-variables><const>", "AnswerCount": "2"}, "20716184": {"Id": "20716184", "PostTypeId": "2", "Body": "<p>Because you put variable definition in header file. Including header file is just like replacing it with the content of the file. So, the first file:</p>\n<pre><code>// Unit1.cpp\n#include \"ConstClass.h\"  // this will be replace with the content of ConstClass.h\n#include \"stdio.h\"\n\nvoid PrintInUnit1( )\n{\n    printf( \"g_Const in Unit1 is %d.\\r\\n\", &amp;g_Const );\n}\n</code></pre>\n<p>will become (after preprocessing phase before compiling):</p>\n<pre><code>// Unit1.cpp\n// ConstClass.h\nclass ConstClass\n{\n};\n\nconst ConstClass g_Const;\n//this line is replaced with the content of \"stdio.h\"\n\nvoid PrintInUnit1( )\n{\n    printf( \"g_Const in Unit1 is %d.\\r\\n\", &amp;g_Const );\n}\n</code></pre>\n<p>And the second file will be:</p>\n<pre><code>// Unit2.cpp\n// ConstClass.h\nclass ConstClass\n{\n};\n\nconst ConstClass g_Const;\n//this line is replaced with the content of \"stdio.h\"\n\nvoid PrintInUnit2( )\n{\n    printf( \"g_Const in Unit2 is %d.\\r\\n\", &amp;g_Const );\n}\n</code></pre>\n<p>As you can see, each file has separate variable <code>g_Const</code> (this is just for the case of your code in here, there maybe no variable at all just like macro, see explanation in my last paragraph).</p>\n<p>If what you want is not the definition of the variable just the declaration in the header file, you should use <code>extern</code> keyword in the header file:</p>\n<pre><code>extern const ConstClass g_Const;\n</code></pre>\n<p>Then you can put the definition of <code>g_Const</code> variable in <code>ConstClass.c</code></p>\n<hr>\n<p>There is some catch in your code:</p>\n<ul>\n<li>there is no constant value assigned in your <code>g_Const</code> definition, you must assign it a constant value in the definition unless you want the default value (0).</li>\n<li>inside printf, you take the address of <code>const</code> variable of C++. This actually force the compiler to create the variable in stack. If you don't take the address it may be able to infer a compile time number behaving like macro in C (you can get the magic number directly put in the code where you use the <code>const</code> variable).</li>\n</ul>\n</hr>", "LastEditorUserId": "509150", "LastActivityDate": "2013-12-21T06:58:06.293", "Score": "5", "CreationDate": "2013-12-21T06:23:12.903", "ParentId": "20716091", "CommentCount": "0", "OwnerUserId": "509150", "LastEditDate": "2013-12-21T06:58:06.293"}, "20716155": {"Body": "<p><a href=\"https://stackoverflow.com/a/6173889/1508519\">https://stackoverflow.com/a/6173889/1508519</a></p>\n<blockquote>\n<p id=\"so_20716091_20716155_0\">const variable at namespace scope has internal linkage. So they're\n  basically two different variables. There is no redefinition.</p>\n<p id=\"so_20716091_20716155_1\">3.5/3 [basic.link]:</p>\n<p id=\"so_20716091_20716155_2\">A name having namespace scope (3.3.5) has internal linkage if it is\n  the name of</p>\n<p id=\"so_20716091_20716155_3\">\u2014 an object, reference, function or function template that is\n  explicitly declared static or,</p>\n<p id=\"so_20716091_20716155_4\">\u2014 an object or reference that is explicitly declared const and neither\n  explicitly declared extern nor previously declared to have external\n  linkage; or</p>\n<p id=\"so_20716091_20716155_5\">\u2014 a data member of an anonymous union.</p>\n</blockquote>\n<p>Use <code>extern</code> if you want it to have external linkage.</p>\n<hr/>\n<p>As stated in the other answer, header files are just pasted in cpp files. The same header file is included in both cpp files, but they are separate <em>translation units</em>. That means that one instance of a variable is different from the other instance. In other to let the compiler know that you have defined the variable elsewhere, use the <code>extern</code> keyword. This ensures only one instance is shared across translation units. However <code>extern const Test test</code> is just a declaration. You need a definition. It doesn't matter where you define it as long as it is defined once in some cpp file. You can declare it as many times as you want (which is convenient for placing it in a header file.)</p>\n<p>So for example:</p>\n<p>Constant.h</p>\n<pre><code>class Test\n{\n};\n\nextern const Test test;\n</code></pre>\n<p>Unit1.cpp</p>\n<pre><code>#include \"Constant.h\"\n#include &lt;iostream&gt;\n\nvoid print_one()\n{ std::cout &lt;&lt; &amp;test &lt;&lt; std::endl; }\n</code></pre>\n<p>Unit2.cpp</p>\n<pre><code>#include \"Constant.h\"\n#include &lt;iostream&gt;\n\nvoid print_two()\n{ std::cout &lt;&lt; &amp;test &lt;&lt; std::endl; }\n</code></pre>\n<p>main.cpp</p>\n<pre><code>extern void print_one();\nextern void print_two();\n\nint main()\n{\n   print_one();\n   print_two();\n}\n</code></pre>\n<p>Constant.cpp</p>\n<pre><code>#include \"Constant.h\"\nconst Test test = Test();\n</code></pre>\n<p>Makefile</p>\n<pre><code>.PHONY: all\nall:\n   g++ -std=c++11 -o test Constant.cpp Unit1.cpp Unit2.cpp main.cpp\n</code></pre>\n", "CreationDate": "2013-12-21T06:19:17.920", "ParentId": "20716091", "CommentCount": "2", "LastEditDate": "2017-05-23T10:30:43.420", "PostTypeId": "2", "LastEditorDisplayName": "user1508519", "OwnerDisplayName": "user1508519", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-21T06:40:15.613", "Id": "20716155", "Score": "7"}});