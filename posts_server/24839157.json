post_cb({"24841967": {"ParentId": "24839157", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-07-19T15:31:43.043", "Score": "1", "LastEditorUserId": "2673243", "LastEditDate": "2014-07-19T16:48:51.230", "Id": "24841967", "OwnerUserId": "2673243", "Body": "<p>From the C++11 Standard, 5.1.2 \"Lambda expressions\" [expr.prim.lambda] #7:</p>\n<blockquote id=\"so_24839157_24841967_0\">The <i>lambda-expression</i>\u2019s <i>compound-statement</i> yields the <i>function-body</i> (8.4) of the function call operator,\nbut for purposes of name lookup (3.4), determining the type and value of <code>this</code> (9.3.2) and transforming <i>id-expression</i>s\nreferring to non-static class members into class member access expressions using <code>(*this)</code> (9.3.1),\nthe <i>compound-statement</i> is considered in the context of the <i>lambda-expression</i>.</blockquote>\n<p>Also, from 3.3.3 \"Block scope\" [basic.scope.local] #2:</p>\n<blockquote id=\"so_24839157_24841967_1\">The potential scope of a function parameter name (including one appearing in a <i>lambda-declarator</i>) or of\na function-local predefined variable in a function definition (8.4) begins at its point of declaration.</blockquote>\n<p>Names in a capture list are not declarations and therefore do not affect name lookup. The capture list just allows you to use the local variables; it does not introduce their names into the lambda's scope. Example:</p>\n<pre><code>int i, j;\nint main()\n{\n    int i = 0;\n    [](){ i; }; // Error: Odr-uses non-static local variable without capturing it\n    [](){ j; }; // OK\n}\n</code></pre>\n<p>So, since the parameters to a lambda are in an inner block scope, and since name lookup is done in the context of the lambda expression (not, say, the generated class), the parameter names indeed hide the variable names in the enclosing function.</p>\n", "LastActivityDate": "2014-07-19T16:48:51.230"}, "24839696": {"ParentId": "24839157", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-07-19T11:07:32.227", "Score": "2", "LastEditorUserId": "3807729", "LastEditDate": "2014-07-19T13:23:55.473", "Id": "24839696", "OwnerUserId": "3807729", "Body": "<p>From my understanding of the c++11 standard's points below:</p>\n<blockquote>\n<p id=\"so_24839157_24839696_0\"><strong><em>5.1.2 Lambda expressions</em></strong></p>\n<p id=\"so_24839157_24839696_1\"><strong><em>3</em></strong> The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type \u2014 called\n  the closure type \u2014 whose properties are described below.</p>\n<p id=\"so_24839157_24839696_2\">...</p>\n<p id=\"so_24839157_24839696_3\"><strong><em>5</em></strong> The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are\n  described by the lambda-expression\u2019s parameter-declaration-clause and\n  trailing-return-type respectively. This function call operator is\n  declared const (9.3.1) if and only if the lambda-expression\u2019s\n  parameter-declaration-clause is not followed by mutable.</p>\n<p id=\"so_24839157_24839696_4\">...</p>\n<p id=\"so_24839157_24839696_5\"><strong><em>14</em></strong> For each entity captured by copy, an unnamed non static data member is declared in the closure type</p>\n</blockquote>\n<p>A lambda expression like this...</p>\n<pre><code>int c = 5;\n\n[c](int c){ std::cout &lt;&lt; c &lt;&lt; '\\n'; }  \n</code></pre>\n<p>...is roughly equivalent to a class/struct like this:</p>\n<pre><code>struct lambda\n{\n    int c; // captured c\n\n    void operator()(int c) const\n    {\n        std::cout &lt;&lt; c &lt;&lt; '\\n';\n    }\n};\n</code></pre>\n<p>So I would expect the parameter to hide the captured member.</p>\n<p><strong><em>EDIT:</em></strong></p>\n<p>In point <strong><em>14</em></strong> from the standard <em>(quoted above)</em> it would seem the data member created from the captured variable is <strong>* <em>unnamed</em> *</strong>. The mechanism by which is it referenced appears to be independent of the normal identifier lookups: </p>\n<blockquote>\n<p id=\"so_24839157_24839696_6\"><strong><em>17</em></strong> Every id-expression that is an odr-use (3.2) of an entity captured by copy is transformed into an access to the corresponding unnamed data member of the closure type.</p>\n</blockquote>\n<p>It is unclear from my reading of the standard if this transformation should take precedence over parameter symbol lookup.</p>\n<p>So perhaps this should be marked as <strong><em>UB</em></strong> <em>(undefined behaviour)</em>?</p>\n", "LastActivityDate": "2014-07-19T13:23:55.473"}, "24839157": {"CommentCount": "5", "ViewCount": "832", "PostTypeId": "1", "LastEditorUserId": "3593341", "CreationDate": "2014-07-19T10:07:27.060", "LastActivityDate": "2014-07-21T16:56:09.377", "Title": "Lambda expression in c++, OS X's clang vs GCC", "AcceptedAnswerId": "24841967", "LastEditDate": "2014-07-21T16:56:09.377", "Id": "24839157", "Score": "8", "Body": "<p>A particular property of c++'s lambda expressions is to capture the variables in the scope in which they are declared. For example I can use a declared and initialized variable c in a lambda function even if 'c' is not sent as an argument, but it's captured by '[ ]':</p>\n<pre><code> #include&lt;iostream&gt;\n int main ()\n {int c=5; [c](int d){std::cout&lt;&lt;c+d&lt;&lt;'\\n';}(5);}\n</code></pre>\n<p>The expected output is thus 10. The problem arises when at least 2 variables, one captured and the other sent as an argument, have the same name: </p>\n<pre><code> #include&lt;iostream&gt;\n int main ()\n {int c=5; [c](int c){std::cout&lt;&lt;c&lt;&lt;'\\n';}(3);}\n</code></pre>\n<p>I think that the 2011 standard for c++ says that the captured variable has the precedence on the arguments of the lambda expression in case of coincidence of names. In fact compiling the code using GCC 4.8.1 on Linux the output I get is the expected one, <code>5</code>. If I compile the same code using apple's version of clang compiler (clang-503.0.40, the one which comes with Xcode 5.1.1 on Mac OS X 10.9.4) I get the other answer, <code>3</code>.</p>\n<p>I'm trying to figure why this happens; is it just an apple's compiler bug (if the standard for the language really says that the captured 'c' has the precedence) or something similar? Can this issue be fixed?</p>\n<p><strong>EDIT</strong></p>\n<p>My teacher sent an email to GCC help desk, and they answered that it's clearly a bug of GCC compiler and to report it to Bugzilla. So Clang's behavior is the correct one!</p>\n", "Tags": "<osx><gcc><c++11><clang><lambda>", "OwnerUserId": "3593341", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24839157_24839696_3": {"section_id": 5964, "quality": 0.8666666666666667, "length": 26}, "so_24839157_24839696_5": {"section_id": 5974, "quality": 0.7692307692307693, "length": 10}, "so_24839157_24841967_0": {"section_id": 5966, "quality": 0.90625, "length": 29}, "so_24839157_24839696_6": {"section_id": 5977, "quality": 1.0, "length": 15}, "so_24839157_24841967_1": {"section_id": 7062, "quality": 0.9473684210526315, "length": 18}, "so_24839157_24839696_1": {"section_id": 5962, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_24839157_24839696_3": {"section_id": 5733, "quality": 0.8666666666666667, "length": 26}, "so_24839157_24839696_5": {"section_id": 5742, "quality": 0.7692307692307693, "length": 10}, "so_24839157_24841967_0": {"section_id": 5735, "quality": 0.90625, "length": 29}, "so_24839157_24839696_6": {"section_id": 5745, "quality": 1.0, "length": 15}, "so_24839157_24841967_1": {"section_id": 6806, "quality": 0.9473684210526315, "length": 18}, "so_24839157_24839696_1": {"section_id": 5731, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_24839157_24839696_3": {"section_id": 7453, "quality": 0.7333333333333333, "length": 22}, "so_24839157_24839696_5": {"section_id": 7473, "quality": 0.7692307692307693, "length": 10}, "so_24839157_24841967_0": {"section_id": 7460, "quality": 0.90625, "length": 29}, "so_24839157_24839696_6": {"section_id": 7474, "quality": 1.0, "length": 15}, "so_24839157_24841967_1": {"section_id": 8559, "quality": 0.9473684210526315, "length": 18}, "so_24839157_24839696_1": {"section_id": 7451, "quality": 0.8947368421052632, "length": 17}}}});