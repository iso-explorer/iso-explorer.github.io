post_cb({"47797105": {"ViewCount": "187", "Body": "<p>So I've read through this: <a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a></p>\n<p>And understand how Curiously Recurring Template Pattern (CRTP) works. But it seems like it depends upon the compiler implementation, specifically that the compiler:</p>\n<ol>\n<li>Defines the space required for each Template Class</li>\n<li>Then compiles the child class's methods</li>\n<li>Then compiles the parent class's methods</li>\n</ol>\n<p>While I can see how this order allows compilation I feel like it's an leveraging compiler construction rather than an order of compiler passes required by the standard. But I feel like an equally legitimate set of compiler passes would be to:</p>\n<ol>\n<li>Define the space required for the parent class</li>\n<li>Compile the parent classes methods</li>\n<li>Define the space required for the child class</li>\n<li>Compile the child classes methods</li>\n</ol>\n<p>If the compiler used these passes CRTP would fail on step 2 when it attempts to evaluate a child type.</p>\n<p>So I've just made up these compiler passes, but is there a standard requirement that places constraints on the compiler that it much adhere to the 3 passes of the 1<sup>st</sup>? Or does CRTP exist in a grey area of knowing how compilers are implemented currently?</p>\n<hr>\n<p>As I see it to allow that the standard would need to require a 1<sup>st</sup> pass that establishes object sizes, followed by a 2<sup>nd</sup> pass that compiles methods. But this 2<sup>nd</sup> pass wold have to be willing to build a child objects methods before the parent objects, which seems backwards.</p>\n</hr>", "AcceptedAnswerId": "47820588", "Title": "Is Curiously Recurring Template Pattern Implementation Specific?", "CreationDate": "2017-12-13T15:47:26.233", "LastActivityDate": "2017-12-30T13:00:01.560", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-30T13:00:01.560", "LastEditorUserId": "149392", "Id": "47797105", "Score": "3", "OwnerUserId": "2642059", "Tags": "<c++><metaprogramming><language-lawyer><crtp>", "AnswerCount": "3"}, "47798068": {"Id": "47798068", "PostTypeId": "2", "Body": "<p>No.  The CRTP is not implementation specific.  It must be supported by any standard compliant compiler.</p>\n<p>Proving this from the words of the standard is quite a laborious task.  I'll delete this answer if someone comes along with an answer with references (and makes a comment here to remind me to do so).</p>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/users/4832499/passer-by\">PasserBy</a> say:</p>\n<blockquote>\n<p id=\"so_47797105_47798068_0\">Strictly speaking, it works because the <em>injected class name</em> exists before the <em>base clause</em></p>\n</blockquote>\n<p>The <em>base clause</em> is everything after the colon in:</p>\n<pre><code>class Derived : CRTP&lt;Derived&gt;\n</code></pre>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/users/7359094/fran%c3%a7ois-andrieux\">Fran\u00e7ois Andrieux</a> and <a href=\"https://stackoverflow.com/users/2757035/underscore-d\">underscore_d</a> points out, we can indirectly prove that the standard requires CRTP to work, because it defines <a href=\"http://en.cppreference.com/w/cpp/memory/enable_shared_from_this\" rel=\"nofollow noreferrer\"><code>std::enable_shared_from_this</code></a> which uses the CRTP.  (However, it was well defined in C++89, and <code>enable_shared_from_this</code> wasn't added until C++11).</p>\n</hr></hr>", "LastEditorUserId": "771073", "LastActivityDate": "2017-12-14T10:28:17.267", "Score": "1", "CreationDate": "2017-12-13T16:35:49.923", "ParentId": "47797105", "CommentCount": "1", "OwnerUserId": "771073", "LastEditDate": "2017-12-14T10:28:17.267"}, "47820588": {"Id": "47820588", "PostTypeId": "2", "Body": "<p>CRTP was never implementation defined or conditionally supported, IIRC it was a pleasant surprise at the time of invention and has been accepted ever since.</p>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/class#2\" rel=\"nofollow noreferrer\">[class]</a></p>\n<blockquote>\n<p id=\"so_47797105_47820588_0\">A <em>class-name</em> is inserted into the scope in which it is declared immediately after the <em>class-name</em> is seen. The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.</p>\n</blockquote>\n<p>Where <em>class-name</em> is the name of the class being declared. Therefore the <em>class-name</em> is already visible before the <em>base-clause</em>, which is the list of bases, but the class is complete only after its full definition.</p>\n<p>However, templates are allowed to use incomplete types as its type-arguments, from <a href=\"https://timsong-cpp.github.io/cppwp/temp#arg.type-2\" rel=\"nofollow noreferrer\">[temp]</a></p>\n<blockquote>\n<p id=\"so_47797105_47820588_1\">A template type argument may be an incomplete type.</p>\n</blockquote>\n<p>Note the template is complete even if its type arguments aren't.</p>\n<pre><code>template&lt;typename&gt;\nstruct S {};\n\nstruct U     // U is visible after this line\n    : S&lt;U&gt;   // S&lt;U&gt; is a complete type\n{\n    S&lt;U&gt; s;  // well-formed\n};           // U is complete after this line\n</code></pre>\n<p>The reason the instantiated template can be complete is because the template type arguments may themselves be incomplete within the template, thereby avoiding cyclic logic</p>\n<pre><code>template&lt;typename T&gt;\nstruct A\n{\n    T t;  // ill-formed, incomplete type T in instantiation of A&lt;B&gt; from below\n};\n\nstruct B : A&lt;B&gt;  // implicit instantiation of the specialization A&lt;B&gt;\n{\n};\n</code></pre>\n<p>We conclude the pattern is valid. <em>How</em> the compiler manages to compile it is irrelevant, if it is standard conformant, it will compile that code.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-12-14T19:21:58.720", "Score": "4", "CreationDate": "2017-12-14T19:14:15.113", "ParentId": "47797105", "CommentCount": "0", "OwnerUserId": "4832499", "LastEditDate": "2017-12-14T19:21:58.720"}, "47798366": {"Id": "47798366", "PostTypeId": "2", "Body": "<p>This is well-defined. As noted in comments, even the standard utilizes the functionality.</p>\n<p>The way to think about it is that as soon as you write <code>class Child</code> the compiler considers that effectively a forward declaration of the type. So as long as the parent class template definition doesn't depend on the complete type of <code>Child</code> the parent it will compile successfully. [I believe that the size of the parent template class cannot depend on the definition of <code>Child</code> but I can't prove that to myself] Note that the parent template <em>method bodies</em> are free to rely on the complete type of child because they will be dependent types and thus their instantiation is delayed to the second phase of template compilation when the full definition of <code>Child</code> is available.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2017-12-13T17:06:30.413", "Score": "2", "CreationDate": "2017-12-13T16:51:27.123", "ParentId": "47797105", "CommentCount": "0", "OwnerUserId": "251738", "LastEditDate": "2017-12-13T17:06:30.413"}, "bq_ids": {"n4140": {"so_47797105_47820588_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5846}, "so_47797105_47820588_1": {"length": 6, "quality": 1.0, "section_id": 85}}, "n3337": {"so_47797105_47820588_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5616}, "so_47797105_47820588_1": {"length": 6, "quality": 1.0, "section_id": 80}}, "n4659": {"so_47797105_47820588_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7325}, "so_47797105_47820588_1": {"length": 6, "quality": 1.0, "section_id": 88}}}});