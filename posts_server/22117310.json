post_cb({"22120795": {"ParentId": "22117310", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You can always rewrite your program as this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint f(int x) {\n    ++x;\n    return x;\n}\n\nint main() {\n    printf(\"%d\\n\", f(22));\n}\n</code></pre>\n", "OwnerUserId": "2954323", "LastEditorUserId": "2954323", "LastEditDate": "2014-03-01T22:24:04.873", "Id": "22120795", "Score": "-4", "CreationDate": "2014-03-01T21:48:29.220", "LastActivityDate": "2014-03-01T22:24:04.873"}, "22117433": {"ParentId": "22117310", "CommentCount": "0", "Body": "<p>Also, consider:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f();\nint g();\n\nint a = f();\nint b = g();\n\nint main() {\n        cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b;\n}\n\nint f() {\n        b++;\n        cout &lt;&lt; \"f\" &lt;&lt; endl;\n        return 1;\n}\n\nint g() {\n        cout &lt;&lt; \"g\" &lt;&lt; endl;\n        return 2;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>f\ng\n1 2\n</code></pre>\n<p>Replacing <code>b = g();</code> with <code>b = 22;</code> causes <code>1 23</code> to be printed. Kerrek SB's answer explains why this is.</p>\n", "OwnerUserId": "1926018", "PostTypeId": "2", "Id": "22117433", "Score": "4", "CreationDate": "2014-03-01T17:04:12.033", "LastActivityDate": "2014-03-01T17:04:12.033"}, "22117407": {"ParentId": "22117310", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The issue is a little bit subtle; please refer to C++11 3.6.2 for details.</p>\n<p>What matters for us is that there are two phases of initialization of \"non-local variables with static storage duration\" (or \"global variables\" in colloquial parlance): the <em>static initialization phase</em> and the <em>dynamic initialization phase</em>. The static phase comes first. It looks like this:</p>\n<pre><code>int a = 0;\nint x = 22;\n</code></pre>\n<p>The dynamic initialization runs afterwards:</p>\n<pre><code>a = f();\n</code></pre>\n<p>The point is that static initialization doesn't \"run\" at all - it only consists of setting values that are known at compile time, so those values are already set before any execution happens. What makes the initialization <code>int x = 22;</code> static is that the initializer is a constant expression.</p>\n<hr>\n<p>There are cases where dynamic initialization <em>may</em> be hoisted to the static phase (but does not have to), but this is not one of those cases, because it does not meet the requirement that</p>\n<blockquote>\n<p id=\"so_22117310_22117407_0\">the dynamic version of the initialization does not change the value of any other object of namespace scope prior to its initialization</p>\n</blockquote>\n<p>When this hoisting happens, it is permissible that the resulting initial values can be different from if it didn't happen. There's an example in the standard for one such \"indeterminate\" initialization.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2014-03-01T21:37:06.337", "Id": "22117407", "Score": "33", "CreationDate": "2014-03-01T17:02:15.233", "LastActivityDate": "2014-03-01T21:37:06.337"}, "bq_ids": {"n4140": {"so_22117310_22117407_0": {"section_id": 7152, "quality": 1.0, "length": 13}}, "n3337": {"so_22117310_22117407_0": {"section_id": 6896, "quality": 1.0, "length": 13}}, "n4659": {"so_22117310_22117407_0": {"section_id": 8653, "quality": 0.8461538461538461, "length": 11}}}, "22117310": {"CommentCount": "0", "AcceptedAnswerId": "22117407", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-01T16:54:58.880", "LastActivityDate": "2015-12-20T13:35:44.587", "LastEditDate": "2017-05-23T12:26:00.663", "ViewCount": "15828", "FavoriteCount": "8", "Title": "C++ global variable initialization order", "Id": "22117310", "Score": "33", "Body": "<p>I don't understand what the following code example does and how it does it:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint f();\n\nint a = f(); // a exists just to call f\n\nint x = 22;\n\nint f() {\n    ++x;\n    return 123; // unimportant arbitrary number\n}\n\nint main() {\n    printf(\"%d\\n\", x);\n}\n</code></pre>\n<p>When this is ran it prints <code>23</code>, which is the intuitive answer.</p>\n<p>However in C++, global variables are <a href=\"https://stackoverflow.com/a/3746249/924313\">supposed to be</a> initialized in order of definition. That would mean that <code>a</code> should be initialized before <code>x</code>, because it is defined before <code>x</code>. If that was the case, then the function <code>f</code> would have to be called before <code>x</code> was initialized, because the call to <code>f</code> is a part of <code>a</code>'s definition.</p>\n<p>If <code>f</code> is indeed called before <code>x</code> is initialized, that would mean that <code>f</code> would try to increment <code>x</code> -- the result of which I'm not really certain of (most likely UB, or some gibberish value). Then, after <code>a</code> is initialized, <code>x</code> would be initialized to <code>22</code> and the program would print out <code>22</code>.</p>\n<p><strong>Evidently that's not what happens. But what does? What does that code actually do?</strong></p>\n<p>It definitely seems like <code>x</code> is set to <code>22</code> before <code>a = f()</code> is evaluated, but that would mean that the order of initialization is reversed (I could also be wrong about what initialization is, or when it happens).</p>\n", "Tags": "<c++><variables><initialization><declaration><definition>", "OwnerUserId": "924313", "AnswerCount": "3"}});