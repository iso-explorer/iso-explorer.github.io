post_cb({"bq_ids": {"n4140": {"so_18889028_18889029_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 677}, "so_18889028_18889029_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_18889028_18889029_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 667}, "so_18889028_18889029_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_18889028_18889029_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 706}, "so_18889028_18889029_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "18889029": {"Id": "18889029", "PostTypeId": "2", "Body": "<p>Yes, the code is standard conforming. The <code>+</code> triggers a conversion to a plain old function pointer for the lambda.</p>\n<p>What happens is this:</p>\n<p>The compiler sees the first lambda (<code>[]{}</code>) and generates a closure object according to \u00a75.1.2. As the lambda is a <strong>non-capturing</strong> lambda, the following applies:</p>\n<blockquote>\n<h3>5.1.2 Lambda expressions [expr.prim.lambda]</h3>\n<p id=\"so_18889028_18889029_0\"><sup>6</sup> The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>This is important as the unary operator <code>+</code> has a set of built-in overloads, specifically this one:</p>\n<blockquote>\n<h3>13.6 Built-in operators [over.built]</h3>\n<p id=\"so_18889028_18889029_1\"><sup>8</sup> For every type <code>T</code> there exist candidate operator functions of the form</p>\n<p id=\"so_18889028_18889029_2\">\u00a0\u00a0\u00a0\u00a0<code>T* operator+(T*);</code></p>\n</blockquote>\n<p>And with this, it's quite clear what happens: When operator <code>+</code> is applied to the closure object, the set of overloaded built-in candidates contains a conversion-to-any-pointer and the closure type contains exactly one candidate: The conversion to the function pointer of the lambda.</p>\n<p>The type of <code>test</code> in <code>auto test = +[]{};</code> is therefore deduced to <code>void(*)()</code>. Now the second line is easy: For the second lambda/closure object, an assignment to the function pointer triggers the same conversion as in the first line. Even though the second lambda has a different closure type, the resulting function pointer is, of course, compatible and can be assigned.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-09-19T08:55:28.923", "Score": "196", "CreationDate": "2013-09-19T07:51:31.910", "ParentId": "18889028", "CommentCount": "13", "LastEditDate": "2013-09-19T08:55:28.923", "OwnerUserId": "2073257"}, "18889028": {"ViewCount": "18525", "Body": "<p>In Stack Overflow question <em><a href=\"https://stackoverflow.com/questions/18755787\">Redefining lambdas not allowed in C++11, why?</a></em>, a small program was given that does not compile:</p>\n<pre><code>int main() {\n    auto test = []{};\n    test = []{};\n}\n</code></pre>\n<p>The question was answered and all seemed fine. Then came <a href=\"https://stackoverflow.com/users/34509\">Johannes Schaub</a> and made <a href=\"https://stackoverflow.com/questions/18755787/redefining-lambdas-not-allowed-in-c11-why#comment27726224_18755787\">an interesting observation</a>:</p>\n<blockquote>\n<p id=\"so_18889028_18889028_0\">If you put a <code>+</code> before the first lambda, it magically starts to work.</p>\n</blockquote>\n<p>So I'm curious: Why does the following work?</p>\n<pre><code>int main() {\n    auto test = +[]{}; // Note the unary operator + before the lambda\n    test = []{};\n}\n</code></pre>\n<p>It compiles fine with both <a href=\"http://en.wikipedia.org/wiki/GNU_Compiler_Collection\" rel=\"noreferrer\">GCC</a> 4.7+ and <a href=\"http://en.wikipedia.org/wiki/Clang\" rel=\"noreferrer\">Clang</a> 3.2+. Is the code standard conforming?</p>\n", "AcceptedAnswerId": "18889029", "Title": "A positive lambda: '+[]{}' - What sorcery is this?", "CreationDate": "2013-09-19T07:51:31.910", "Id": "18889028", "CommentCount": "8", "FavoriteCount": "82", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:47:08.517", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-23T16:40:34.967", "ClosedDate": "2013-09-30T00:35:25.467", "Score": "217", "OwnerUserId": "2073257", "Tags": "<c++><c++11><lambda><operator-overloading><language-lawyer>", "AnswerCount": "1"}});