post_cb({"bq_ids": {"n4140": {"so_29038703_29038703_3": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_29038703_29038703_4": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_29038703_29038703_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5962}, "so_29038703_29038870_1": {"length": 7, "quality": 1.0, "section_id": 662}, "so_29038703_29038870_0": {"length": 76, "quality": 0.9156626506024096, "section_id": 5964}, "so_29038703_29038703_2": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_29038703_29038703_1": {"length": 5, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_29038703_29038703_3": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_29038703_29038703_4": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_29038703_29038703_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5731}, "so_29038703_29038870_1": {"length": 7, "quality": 1.0, "section_id": 652}, "so_29038703_29038703_1": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_29038703_29038703_2": {"length": 6, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_29038703_29038703_3": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_29038703_29038703_4": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_29038703_29038703_0": {"length": 30, "quality": 0.967741935483871, "section_id": 7452}, "so_29038703_29038870_1": {"length": 7, "quality": 1.0, "section_id": 690}, "so_29038703_29038703_1": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_29038703_29038703_2": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_29038703_29038870_0": {"length": 76, "quality": 0.9156626506024096, "section_id": 7453}}}, "29038870": {"Id": "29038870", "PostTypeId": "2", "Body": "<p>This is covered in paragraph <code>5</code> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_29038703_29038870_0\">The closure type for a non-generic lambda-expression <strong>has a public inline function call operator (13.5.4)</strong>\n  whose parameters and return type are described by the lambda-expression\u2019s parameter-declaration-clause\n  and trailing-return-type respectively. For a generic lambda, the closure type has a public inline function call\n  operator member template (14.5.2) whose template-parameter-list consists of one invented type templateparameter\n  for each occurrence of auto in the lambda\u2019s parameter-declaration-clause, in order of appearance.\n  The invented type template-parameter is a parameter pack if the corresponding parameter-declaration declares\n  a function parameter pack (8.3.5). The return type and function parameters of the function call\n  operator template are derived from the lambda-expression\u2019s trailing-return-type and parameter-declarationclause\n  by replacing each occurrence of auto in the decl-specifiers of the parameter-declaration-clause with\n  the name of the corresponding invented template-parameter</p>\n</blockquote>\n<p>and we can see in <code>13.5.4</code>:</p>\n<blockquote>\n<p id=\"so_29038703_29038870_1\">operator() shall be a non-static member function with an arbitrary number of parameters[...]</p>\n</blockquote>\n", "LastActivityDate": "2015-03-13T17:55:53.227", "CommentCount": "1", "CreationDate": "2015-03-13T17:55:53.227", "ParentId": "29038703", "Score": "3", "OwnerUserId": "1708801"}, "29038703": {"ViewCount": "291", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;algorithm&gt; \n#include &lt;cstdlib&gt; \n#include &lt;iostream&gt; \n#include &lt;vector&gt;\n\nint main() \n{\n    std::vector&lt;int&gt; srcVec; \n    for (int val = 0; val &lt; 10; val++)\n    { \n        srcVec.push_back(val); \n    }\n\n    std::for_each(srcVec.begin(), srcVec.end(), [](int a){ std::cout &lt;&lt; a &lt;&lt; std::endl; }); \n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/9b3f28e1e30fa231\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>I thought the <code>Function</code> type of the </p>\n<pre><code>template&lt;class InputIterator, class Function&gt;\nFunction for_each(InputIterator first, InputIterator last, Function f);\n</code></pre>\n<p>should necessary overload <code>operator ()</code>. But <code>N4296::5.1.2/3 [expr.prim.lambda]</code> does not require that.</p>\n<blockquote>\n<p id=\"so_29038703_29038703_0\">The closure type is declared in the smallest block scope, class scope,\n  or namespace scope that contains the corresponding lambda-expression.\n  An implementation may define the closure type differently from what is\n  described below provided this does not alter the observable behavior\n  of the program other than by changing:</p>\n<p id=\"so_29038703_29038703_1\">(3.1) \u2014 the size and/or alignment of the closure type, </p>\n<p id=\"so_29038703_29038703_2\">(3.2) \u2014 whether the closure type is trivially copyable (Clause 9), </p>\n<p id=\"so_29038703_29038703_3\">(3.3) \u2014 whether the  closure type is a standard-layout class (Clause\n  9), or </p>\n<p id=\"so_29038703_29038703_4\">(3.4) \u2014 whether the closure type is a POD class (Clause 9).</p>\n</blockquote>\n<p>There was nothing said about the type should overload <code>operator ()</code>. So why should it?</p>\n", "AcceptedAnswerId": "29038870", "Title": "Understanding anonymous-functors and lambda", "CreationDate": "2015-03-13T17:44:48.617", "Id": "29038703", "CommentCount": "1", "LastEditDate": "2015-03-13T17:51:14.797", "PostTypeId": "1", "LastEditorDisplayName": "user2953119", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-03-13T17:55:53.227", "Score": "2", "Tags": "<c++><lambda>", "AnswerCount": "1"}});