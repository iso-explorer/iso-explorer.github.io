post_cb({"bq_ids": {"n4140": {"so_12067278_12068372_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 63}}, "n3337": {"so_12067278_12068372_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 58}}, "n4659": {"so_12067278_12068372_0": {"length": 16, "quality": 0.6153846153846154, "section_id": 65}}}, "12067278": {"ViewCount": "408", "Body": "<p>I'm trying to have a different template specialization for classes which have an inner class with a particular name present. I've taken a clue from <a href=\"http://www.boost.org/doc/libs/1_51_0/libs/utility/enable_if.html#sec%3aenable_if_classes\" rel=\"nofollow\">here</a> and tried the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; typename T, typename Check = void &gt; struct HasXYZ\n{ static const bool value = false; };\n\ntemplate&lt; typename T &gt; struct HasXYZ&lt; T, typename T::XYZ &gt;\n{ static const bool value = true; };\n\nstruct Foo\n{\n  class XYZ {};\n};\n\nstruct FooWithTypedef\n{\n  typedef void XYZ;\n};\n\nint main()\n{\n  // The following line prints 1, as expected\n  std::cout &lt;&lt; HasXYZ&lt; FooWithTypedef &gt;::value &lt;&lt; std::endl;\n  // The following line prints 0. Why?\n  std::cout &lt;&lt; HasXYZ&lt; Foo &gt;::value &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>As you can see, if I test for a <code>typedef</code>-defined type in <code>FooWithTypedef</code>, it works. However, it does not work if the type is a genuine inner class. It also only works when the <code>typedef</code>-ed type in <code>FooWithTypedef</code> matches the default value of the second argument in the initial template declaration (which is <code>void</code> in my example). Could one explain what is going on here? How does the specialization process work here?</p>\n", "AcceptedAnswerId": "12068372", "Title": "How to test for presence of an inner class in a class via SFINAE?", "CreationDate": "2012-08-22T06:15:49.097", "Id": "12067278", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-08-22T23:06:41.627", "LastEditorUserId": "882478", "LastActivityDate": "2012-08-23T02:51:47.680", "Score": "8", "OwnerUserId": "882478", "Tags": "<c++><template-specialization><sfinae>", "AnswerCount": "3"}, "12082334": {"Id": "12082334", "PostTypeId": "2", "Body": "<p><code>A::XYZ</code> would need to <code>void</code> to have the partial specialization selected, which can never be the case for a class type. One way to make it work is using a fake dependant <code>void</code> typename:</p>\n<pre><code>template&lt;class T&gt;\nstruct void_{ typedef void type; };\n\ntemplate&lt;class T, class = void&gt;\nstruct has_XYZ{ static bool const value = false; };\n\ntemplate&lt;class T&gt;\nstruct has_XYZ&lt;T, typename void_&lt;typename T::XYZ&gt;::type&gt;{\n  static bool const value = true;\n};\n</code></pre>\n<p>For an explanation on how this works, see <a href=\"https://stackoverflow.com/q/6543652/500104\">this question</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-22T22:35:32.810", "Score": "1", "CreationDate": "2012-08-22T22:35:32.810", "ParentId": "12067278", "CommentCount": "6", "LastEditDate": "2017-05-23T12:10:40.127", "OwnerUserId": "500104"}, "12068372": {"Id": "12068372", "PostTypeId": "2", "Body": "<p><strong>Answer to the initial question</strong></p>\n<p>The template specialization you defined here:</p>\n<pre><code>template &lt;typename T&gt; struct HasXYZ &lt;T,typename T::XYZ&gt;\n{ static const bool value = true; };\n</code></pre>\n<p>will take effect when somebody uses the data type <code>HasXYZ&lt;A,A::XYZ&gt;</code> for some data type <code>A</code>.</p>\n<p>Note that, whatever <code>A</code> is, <code>A::XYZ</code> is a data type totally independent of <code>A</code>. Inner classes are data types in their own right. When you use <code>A</code> as the first template argument, there is absolutely no reason for the compiler to assume that you want to use something called <code>A:XYZ</code> as the second argument, even if an inner class of that name exists, and even if doing so would lead the compiler to a template specialization that matches the template arguments exactly. Template specializations are found based on the template arguments provided by the coder, not based on further <em>possible</em> template arguments.</p>\n<p>Hence when you use <code>HasXYZ&lt;Foo&gt;</code>, it falls back to using the default template argument <code>void</code> for the second parameter.</p>\n<p>Needless to say that if you were to use <code>HasXYZ&lt;Foo,Foo:XYZ&gt;</code> explicitly, you'd get the expected output. But that obviously is not what you intended.</p>\n<p>I am afraid the only way to get what you need is <code>std::enable_if</code> (or something that works in a similar way).</p>\n<hr>\n<p><strong>Answer to the additional question (after update)</strong></p>\n<p>Consider the simplification below:</p>\n<pre><code>template &lt;typename T, typename Check = void&gt;\nstruct A\n{ static const bool value = false; };\n\ntemplate &lt;typename T&gt;\nstruct A&lt;T,void&gt;\n{ static const bool value = true; };\n</code></pre>\n<p>The <em>primary definition</em> specifies a default argument of <code>void</code> for the second template parameter. But the <em>specialization</em> (second definition above) defines what <code>class A</code> actually looks like if the second template parameter really <em>is</em> <code>void</code>.</p>\n<p>What this means is that if you use, say, <code>A&lt;int&gt;</code> in your code, the default argument will be supplemented so you get <code>A&lt;int,void&gt;</code>, and then the compiler finds the most fitting template specialization, which is the second one above.</p>\n<p>So, while default template arguments are defined as part of the primary template declaration, making use of them does not imply that the primary template definition is used. This is basically because default template arguments are part of the template declaration, not the template definition (*).</p>\n<p>This why in your example, when <code>typedef void XYZ</code> is included in <code>FooWithTypedef</code>, the second template parameter defaults to <code>void</code> and then the most fitting specialization is found. This works even if in the template specialization the second argument is defined as <code>T::XYZ</code> instead of <code>void</code>. If these are the same at the time of evaluation, the template specialization will be selected (\u00a714.4 \"Type equivalence\").</p>\n<p>(*) I didn't find a statement in the Standard that actually says it so clearly. But there is \u00a714.1/10, which describes the case where you have multiple declarations (but only one primary definition) of a template:</p>\n<blockquote>\n<p id=\"so_12067278_12068372_0\">(\u00a714.1/10) The set of default template-arguments available for use with a template declaration or definition is obtained by merging the default arguments from the definition (if in scope) and all declarations in scope in the same way default function arguments are (8.3.6). [ Example:  </p>\n<pre><code>  template&lt;class T1, class T2 = int&gt; class A;\n  template&lt;class T1 = int, class T2&gt; class A;\n</code></pre>\n<p id=\"so_12067278_12068372_1\">is equivalent to</p>\n<pre><code>  template&lt;class T1 = int, class T2 = int&gt; class A;\n</code></pre>\n<p id=\"so_12067278_12068372_2\">].</p>\n</blockquote>\n<p>This suggests that the mechanism behind default template arguments is independent of that used to identify the most fitting specialization of the template.</p>\n<p>In addition, there are two existing SO posts that refer to this mechanism as well:</p>\n<p><a href=\"https://stackoverflow.com/a/3009891/777186\">This reply</a> to <a href=\"https://stackoverflow.com/questions/3008571/template-specialization-to-use-default-type-if-class-member-typedef-does-not-exi\">Template specialization to use default type if class member typedef does not exist</a></p>\n<p><a href=\"https://stackoverflow.com/questions/11148845/default-values-of-template-parameters-in-the-class-template-specializations\">Default values of template parameters in the class template specializations</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-23T02:51:47.680", "Score": "4", "CreationDate": "2012-08-22T07:38:39.507", "ParentId": "12067278", "CommentCount": "4", "LastEditDate": "2017-05-23T11:54:59.400", "OwnerUserId": "777186"}, "12067661": {"Id": "12067661", "PostTypeId": "2", "Body": "<p>Here is another version that detects the presence of the inner class :</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; typename T &gt;\nstruct HasXYZ\n{\n  typedef char                 yes;\n  typedef struct{ char d[2]; } no;\n\n  template&lt;typename T1&gt;\n  static yes test( typename T1::XYZ * );\n  template&lt;typename T1&gt;\n  static no test(...);\n\n  static const bool value = ( sizeof( test&lt;T&gt;(0) ) == sizeof( yes ) );\n};\n\nstruct Foo\n{\n  class XYZ {};\n};\nstruct Bar\n{\n  class ABC {};\n};\n\nint main()\n{\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; HasXYZ&lt; Foo &gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; HasXYZ&lt; Bar &gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2012-08-22T06:47:56.150", "Score": "2", "CreationDate": "2012-08-22T06:47:56.150", "ParentId": "12067278", "CommentCount": "1", "OwnerUserId": "476681"}});