post_cb({"1588976": {"ViewCount": "2961", "Body": "<p>Is the pointer returned by the following function valid?</p>\n<pre><code>const char * bool2str( bool flg )\n{\n    return flg ? \"Yes\" : \"No\";\n}\n</code></pre>\n<p>It works well in Visual C++ and g++. What does C++ standard say about this?</p>\n", "AcceptedAnswerId": "1589073", "Title": "Do pointers to string literals remain valid after a function returns?", "CreationDate": "2009-10-19T14:24:51.947", "Id": "1588976", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2009-10-19T16:22:28.313", "LastEditorUserId": "33732", "LastActivityDate": "2009-10-19T18:34:20.413", "Score": "15", "OwnerUserId": "124161", "Tags": "<c++><pointers><standards>", "AnswerCount": "4"}, "1590329": {"Id": "1590329", "PostTypeId": "2", "Body": "<p>Technically Yes it is valid.<br>\nThe strings have static storage durataion.</br></p>\n<p>But that is not the whole story.</p>\n<p>These are C-Strings. The convention in C-Libraries and funcctions is to return a dynamically allocated string that should be freed. ie A pointer returned is implicitly passing ownership back to tha caller (As usuall in C there are also exceptions).</p>\n<p>If you do not follow these conventions you will confuse a lot of experienced C-Developers that would expect this convention. If you do not follow this standard expectation then it should be well documented in the code.</p>\n<p>Also this is C++ (as per your tags). So it is more conventional to return a std::string. The reason for this is that the passing of ownership via pointers is only implied (and this lead to a lot of errors in C code were the above expectation was broken but documented, unfortunately the documentaiton was never read by the user of the code). By using a std::string you are passing an object and their is no longer any question of ownership (the result is passed back as a value and thus yours), but because it is an object there is no questions or issues with resource allocation.</p>\n<p>If you are worried about effeciency I think that is a false concern.</p>\n<p>If you want this for printing via streams there is already a standard convention to do that:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; false &lt;&lt; std::endl;\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; true  &lt;&lt; std::endl;\n</code></pre>\n", "LastActivityDate": "2009-10-19T18:34:20.413", "CommentCount": "0", "CreationDate": "2009-10-19T18:34:20.413", "ParentId": "1588976", "Score": "5", "OwnerUserId": "14065"}, "1588985": {"Id": "1588985", "PostTypeId": "2", "Body": "<p>This code is perfectly valid and conformant. The only \"gotcha\" would be to ensure that the caller doesn't try to free the string.</p>\n", "LastActivityDate": "2009-10-19T14:26:53.423", "CommentCount": "7", "CreationDate": "2009-10-19T14:26:53.423", "ParentId": "1588976", "Score": "13", "OwnerUserId": "8078"}, "bq_ids": {"n4140": {"so_1588976_1589073_2": {"length": 16, "quality": 0.7272727272727273, "section_id": 7164}, "so_1588976_1589073_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5356}, "so_1588976_1589014_0": {"length": 9, "quality": 0.9, "section_id": 5356}}, "n3337": {"so_1588976_1589073_2": {"length": 16, "quality": 0.7272727272727273, "section_id": 6908}, "so_1588976_1589073_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5153}, "so_1588976_1589014_0": {"length": 9, "quality": 0.9, "section_id": 5153}}, "n4659": {"so_1588976_1589073_2": {"length": 16, "quality": 0.7272727272727273, "section_id": 8672}, "so_1588976_1589073_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6781}, "so_1588976_1589014_0": {"length": 9, "quality": 0.9, "section_id": 6781}}}, "1589073": {"Id": "1589073", "PostTypeId": "2", "Body": "<p>On storage duration:</p>\n<blockquote>\n<p id=\"so_1588976_1589073_0\"><strong>2.13.4</strong>\n  Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow\n  string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has\n  static storage duration</p>\n</blockquote>\n<p>read in conjunction with 3.7.1</p>\n<blockquote>\n<p id=\"so_1588976_1589073_1\"><strong>3.7.1.</strong></p>\n<p id=\"so_1588976_1589073_2\">All objects which do not have dynamic storage duration, do not have thread storage duration, and are\n  not local have static storage duration. The storage for these objects shall last for the duration of the\n  program (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>On type: </p>\n<blockquote>\n<p id=\"so_1588976_1589073_3\"><strong>Annex C</strong></p>\n<p id=\"so_1588976_1589073_4\"><strong>Subclause 2.13.4:</strong></p>\n<p id=\"so_1588976_1589073_5\"><strong>Change</strong>: String literals made const\n  The type of a string literal is changed from \u201carray of char \u201d to \u201carray of const char.\u201d The type of a\n  char16_t string literal is changed from \u201carray of some-integer-type \u201d to \u201carray of const char16_t.\u201d The\n  type of a char32_t string literal is changed from \u201carray of some-integer-type \u201d to \u201carray of const char32_-\n  t.\u201d The type of a wide string literal is changed from \u201carray of wchar_t \u201d to \u201carray of const wchar_t.\u201d</p>\n<p id=\"so_1588976_1589073_6\"><strong>Rationale:</strong> This avoids calling an inappropriate overloaded function, which might expect to be able to\n  modify its argument.</p>\n<p id=\"so_1588976_1589073_7\"><strong>Effect on original feature:</strong> Change to semantics of well-defined feature.\n  Difficulty of converting: Simple syntactic transformation, because string literals can be converted to\n  char*; (4.2). The most common cases are handled by a new but deprecated standard conversion:\n  char* p = \"abc\"; // valid in C, deprecated in C++\n  char* q = expr ? \"abc\" : \"de\"; // valid in C, invalid in C++</p>\n<p id=\"so_1588976_1589073_8\"><strong>How widely used:</strong> Programs that have a legitimate reason to treat string literals as pointers to potentially\n  modifiable memory are probably rare.</p>\n</blockquote>\n<p>Dynamically allocated (the word 'heap' is never used in context of an area of memory AFAIK in the standard) memory requires a function call that can happen as early as <code>main</code> much after the static memory is allocated.</p>\n", "LastActivityDate": "2009-10-19T14:42:31.040", "CommentCount": "4", "CreationDate": "2009-10-19T14:42:31.040", "ParentId": "1588976", "Score": "25", "OwnerUserId": "66692"}, "1589014": {"Id": "1589014", "PostTypeId": "2", "Body": "<p>This code is valid and standard compliant.</p>\n<p>String literals are stored in read-only memory, and the function just gets the address of the chosen string. </p>\n<p>C++ standard (2.13.4) says :</p>\n<blockquote>\n<p id=\"so_1588976_1589014_0\">An ordinary string literal has type\n  \u201carray of n const char\u201d and static\n  storage duration</p>\n</blockquote>\n<p>They key to understand your problem here, is the static storage duration : string literals are allocated when your program launch, and last for the duration of the program. Your function just gets the address and returns it.</p>\n", "LastEditorUserId": "191367", "LastActivityDate": "2009-10-19T14:44:58.690", "Score": "11", "CreationDate": "2009-10-19T14:32:21.760", "ParentId": "1588976", "CommentCount": "0", "OwnerUserId": "191367", "LastEditDate": "2009-10-19T14:44:58.690"}});