post_cb({"8025043": {"LastActivityDate": "2011-11-06T03:23:33.997", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_8024790_8025043_0\">Can I conclude from this that \"void\" (in the context of the 4th use) is simply a special type that any type can cast to it (whether it is c-style or cpp-style), and it can never be used as an lvalue or rvalue?</p>\n</blockquote>\n<p>James McNellis pointed out in <a href=\"https://stackoverflow.com/questions/8024790/understanding-the-exact-meaning-of-the-void-keyword-in-c-c/8024840#comment9823193_8024840\">a comment above</a> that <code>void</code> can be used as an rvalue via the expression <code>void()</code>.</p>\n<p>He quoted this from the current C++ standard:</p>\n<blockquote>\n<p id=\"so_8024790_8025043_1\"><strong>C++11 \u00a75.2.3/2:</strong><br>\n  \u201cThe expression <code>T()</code>, where <code>T</code> is a <em>simple-type-specifier</em> or <em>typename-specifier</em> for a non-array complete object type or the (possibly cv-qualified) <code>void</code> type, creates a prvalue of the specified type, which is value-initialized (no initialization is done for the <code>void()</code> case).\u201d</br></p>\n</blockquote>\n<p>This makes it possible to write code like \u2026</p>\n<pre><code>template&lt; class T &gt;\nT foo() { return T(); }\n</code></pre>\n<p>and use <code>foo&lt;void&gt;()</code> (most likely from other templated code, I would imagine).</p>\n<p>Formally <code>void</code> is just an incomplete type that <em>can never be completed</em>.</p>\n<p>Cheers &amp; hth.</p>\n", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:00:20.313", "ParentId": "8024790", "Id": "8025043", "OwnerUserId": "464581", "Score": "6", "CreationDate": "2011-11-06T03:23:33.997", "LastEditorUserId": "-1"}, "8024841": {"LastActivityDate": "2011-11-06T06:15:24.223", "CommentCount": "3", "Body": "<p>As for your <strong>2)</strong>, in C these:</p>\n<pre><code>int foo();\nint foo(void);\n</code></pre>\n<p>are <em>not</em> equivalent.</p>\n<p>The first is an old-style declaration (still supported in the latest C standard) that says <code>foo</code> takes a fixed <em>but unspecified</em> number and type of argument(s).  A call like <code>foo(42)</code> doesn't require a diagnostic, but its behavior is undefined unless the <em>definition</em> of <code>foo</code> says it has a single <code>int</code> parameter.</p>\n<p>The second says specifically that <code>foo</code> takes no arguments, and <code>foo(42)</code> requires a diagnostic.  The second declaration is a prototype; the first is not.  The <code>(void)</code> syntax was added because some special syntax was needed to be able to declare a parameterless function without writing something that looks like an old-style declaration.</p>\n<p>In new C code, you should <em>always</em> use prototypes.  Old-style declarations are kept in the language only to support old code.</p>\n<p>C++ dropped old-style declarations.  In C++, the two declarations of <code>foo</code> <em>are</em> equivalent; the <code>int foo(void)</code> form is supported only for compatibility with C.</p>\n<p>Your case <strong>4)</strong> really has nothing directly to do with conditional compilation.  Casting an expression to <code>void</code> is a way of evaluating the expression and explicitly discarding its value.  It's often used to inhibit warnings.  For example, if <code>foo()</code> returns an <code>int</code> result, then</p>\n<pre><code>foo();\n</code></pre>\n<p>as a standalone statement might trigger a warning that you're discarding the result, but</p>\n<pre><code>(void)foo();\n</code></pre>\n<p>probably tells the compiler that you intended to do so.</p>\n<p><code>void</code> is an incomplete type that cannot be completed.  That means that an expression of type <code>void</code> can <em>only</em> be used in a context that doesn't expect a value.  And you're right, an expression of type <code>void</code> cannot be used as an lvalue or rvalue.  <strong>EDIT</strong>: Except in the case Alf described, and only in C++.</p>\n", "PostTypeId": "2", "LastEditDate": "2011-11-06T06:15:24.223", "ParentId": "8024790", "Id": "8024841", "OwnerUserId": "827263", "Score": "4", "CreationDate": "2011-11-06T02:29:39.380", "LastEditorUserId": "827263"}, "8024840": {"LastActivityDate": "2011-11-06T12:04:05.753", "CommentCount": "4", "Body": "<p><code>void</code> is always an <em>incomplete</em> type, which means you can never instantiate any object of type <code>void</code>. <s>Consequently there can't be <em>any</em> values of this type, neither L nor R.</s> There can't be any lvalue of this type, though <code>void()</code> is an (p)rvalue. [Thanks to @James!]</p>\n<p>For <code>void*</code>, three common uses come to mind: 1) it's big enough to hold any object pointer. 2) dynamic-cast to void pointer yields a pointer to the most derived type. 3) it's the type of raw memory pointers, i.e. the result type of <code>std::malloc()</code> and <code>::operator new()</code>, the argument type of <code>std::free()</code> and <code>::operator delete()</code>, and of placement-new. It shouldn't be used for anything else in strict C++, though it's also used in the latter role as the buffer argument for <code>fread</code> and <code>fwrite</code> in the C library.</p>\n", "PostTypeId": "2", "LastEditDate": "2011-11-06T12:04:05.753", "ParentId": "8024790", "Id": "8024840", "OwnerUserId": "596781", "Score": "1", "CreationDate": "2011-11-06T02:29:28.660", "LastEditorUserId": "596781"}, "bq_ids": {"n4140": {"so_8024790_8025043_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 6000}}, "n3337": {"so_8024790_8025043_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 5768}}}, "8024790": {"FavoriteCount": "4", "ViewCount": "5413", "Id": "8024790", "AcceptedAnswerId": "8025043", "Score": "11", "Title": "Understanding the exact meaning of the \"void\" Keyword in C/C++", "LastEditorUserId": "701092", "CommentCount": "9", "Body": "<p>As explained, for example, <a href=\"http://msdn.microsoft.com/en-us/library/fxky5d0w.aspx\" rel=\"nofollow noreferrer\">here</a>, we all know of 3 main uses for the void keyword (more experienced C/C++ programmers can skip to the 4th use):</p>\n<p><strong>1) As a return type for function that doesn't return anything</strong>. This\n    will cause a code sample like this:</p>\n<pre><code>void foo();\nint i = foo();\n</code></pre>\n<p>to generate a compiler error.</p>\n<p><strong>2) As the only parameter in a function's parameter list</strong>. AFAIK, an empty function's parameter list is exactly the same to the compiler and therefore the following 2 lines are identical in meaning:\n(<strong>edit:</strong> it is only true in c++. The comments show the difference in c).</p>\n<pre><code>int foo();\nint foo(void);\n</code></pre>\n<p><strong>3) void* is a special type of generic pointer</strong>- it can point to any variable that is not declared with the const or volatile keyword, convert to/from any type of data pointer, and point to all non-member functions. In addition, it cannot be dereferenced. I will not give examples.</p>\n<p>There is also a 4th use that I don't fully understand:</p>\n<p><strong>4) In conditional compilation</strong> it is often used in the expression (void)0 as following:</p>\n<pre><code>// procedure that actually prints error message \nvoid _assert(char* file, int line, char* test); \n#ifdef NDEBUG \n#define assert(e) ((void)0) \n#else\n#define assert(e)     \\\n((e) ? (void)0 :   \\\n__assert(__FILE__, __LINE__, #e)) \n#endif\n</code></pre>\n<p>I try to understand the behavior of this expression through experiments. All the following are legal (compile well): </p>\n<pre><code>int foo(); // some function declaration\nint (*fooPtr)(); // function pointer\nvoid(foo);\nvoid(fooPtr);\nvoid(0);\n(void)0;\nvoid('a');\nvoid(\"blabla\");\nexampleClass e; //some class named exampleClass with a default ctor\nvoid(e);\nstatic_cast&lt;void&gt;(e);\n</code></pre>\n<p>but these are not:</p>\n<pre><code>void(0) // no semicolon\nint i = void(0);\n</code></pre>\n<p>Can I conclude from this that \"void\" <strong>(in the context of the 4th use)</strong> is simply a special type that any type can cast to it  (whether it is c-style or cpp-style), and it can never be used as an lvalue or rvalue?</p>\n", "Tags": "<c++><c>", "CreationDate": "2011-11-06T02:16:23.777", "LastEditDate": "2012-12-24T02:36:40.437", "LastActivityDate": "2012-12-24T02:36:40.437", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1014208"}, "8024845": {"CommentCount": "0", "CreationDate": "2011-11-06T02:30:09.967", "Body": "<p>Void is a type with no values.  Since it has no values, expressions of type <code>void</code> can only be used for their side effects.  Here are some corrections:</p>\n<p><strong>#1</strong> Yes.</p>\n<p><strong>#2</strong> As mentioned, is correct in C++ but incorrect in C.</p>\n<pre><code>int foo(); // In C, this is an \"old-style\" prototype\n           // which doesn't declare its parameters\n\n// Definition for the above function: valid in C, not valid in C++\nint foo(int x, int y) { return x + y; }\n</code></pre>\n<p><strong>#3</strong> <code>void*</code> is a special type of generic pointer: Not quite.  It is not portable to cast a function pointer to <code>void*</code> and back again.</p>\n<pre><code>void func(void);\nvoid *x = func;\nvoid (*f)(void) = func; // NOT portable\n</code></pre>\n<p>However, you can cast any function pointer to any other function pointer type in C, and back again, without worrying about portability.</p>\n<p><strong>#4</strong> Also used to explicitly indicate to the compiler that a value is not needed.</p>\n<pre><code>// Generates \"unused parameter warning\"\nint func(int x)\n{\n    return 3;\n}\n\n// Does not generate any warnings\nint func(int x)\n{\n    (void) x;\n    return 3;\n}\n</code></pre>\n<p>I recommend always turning unused parameter warnings on for your projects, because they often let you catch simple typos.</p>\n", "PostTypeId": "2", "ParentId": "8024790", "Id": "8024845", "LastActivityDate": "2011-11-06T02:30:09.967", "Score": "3", "OwnerUserId": "82294"}});