post_cb({"32283452": {"ParentId": "32282705", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>When you call some function <code>f</code> with some lvalue:</p>\n<pre><code>int a = 42;\nf(a);\n</code></pre>\n<p>Then <code>f</code> must be able to accept such an lvalue. This is the case when the first parameter of <code>f</code> is a (lvalue) reference type, or when it's not a reference at all:</p>\n<pre><code>auto f(int &amp;);\nauto f(int); // assuming a working copy constructor\n</code></pre>\n<p>This <em>won't</em> work when the parameter is a rvalue reference:</p>\n<pre><code>auto f(int &amp;&amp;); // error\n</code></pre>\n<p>Now, when you define a function with a forwarding reference as first parameter as you did in the first and third example ...</p>\n<pre><code>template&lt;typename T&gt;\nauto f(T&amp;&amp;); // Showing only declaration\n</code></pre>\n<p>... and you actually call this function with an lvalue, template type deduction turns <code>T</code> into an (lvalue) reference (that this happens can be seen in the example code I provide in a moment):</p>\n<pre><code>auto f(int &amp; &amp;&amp;); // Think of it like that\n</code></pre>\n<p>Surely, there are too much references involved above. So C++ has <a href=\"https://stackoverflow.com/q/13725747/1116364\"><em>collapsing rules</em></a>, which are actually quite simple:</p>\n<ul>\n<li><code>T&amp; &amp;</code> becomes <code>T&amp;</code></li>\n<li><strong><code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code></strong></li>\n<li><code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code></li>\n<li><code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></li>\n</ul>\n<p>Thanks to the second rule, the \"effective\" type of the first parameter of <code>f</code> is a lvalue reference, so you can bind your lvalue to it.</p>\n<p>Now when you define a function <code>g</code> like ...</p>\n<pre><code>template&lt;template&lt;class&gt; class T, typename A&gt;\nauto g(T&lt;A&gt;&amp;&amp;);\n</code></pre>\n<p>Then no matter what, template parameter deduction <strong>must</strong> turn the <code>T</code> into a <em>template</em>, <strong>not</strong> a type. After all, you specified exactly that when declaring the template parameter as <code>template&lt;class&gt; class</code> instead of <code>typename</code>.\n(This is an important difference, <code>foo</code> in your example is <strong>not</strong> a type, it's a template ... which you can see as type level function, but back to the topic)</p>\n<p>Now, <code>T</code> is some kind of template. You cannot have a reference to a template.\nA reference (type) is built from a (possibly incomplete) <em>type</em>. So no matter what, <code>T&lt;A&gt;</code> (which is a type, <em>but not</em> a template parameter which could be deduced) won't turn into an (lvalue) reference, which means <code>T&lt;A&gt; &amp;&amp;</code> doesn't need any collapsing and stays what it is: An rvalue reference. And of course, you cannot bind an lvalue to an rvalue reference.</p>\n<p>But if you pass it an rvalue, then even <code>g</code> will work.</p>\n<p>All of the above can be seen in the following example:</p>\n<pre><code>template&lt;typename X&gt;\nstruct thing {\n};\ntemplate&lt;typename T&gt;\ndecltype (auto) f(T&amp;&amp; t) {\n if (std::is_same&lt;typename std::remove_reference&lt;T&gt;::type, T&gt;::value) {\n  cout &lt;&lt; \"not \";\n }\n cout &lt;&lt; \"a reference\" &lt;&lt; endl;\n return std::forward&lt;T&gt;(t);\n}\ntemplate&lt;\n template&lt;class&gt; class T,\n typename A&gt;\ndecltype (auto) g(T&lt;A&gt;&amp;&amp; t) {\n return std::forward&lt;T&lt;A&gt;&gt;(t);\n}\nint main(int, char**) {\n thing&lt;int&gt; it {};\n\n f(thing&lt;int&gt; {}); // \"not a reference\"\n\n f(it);            // \"a reference\"\n // T = thing&lt;int&gt; &amp;\n // T&amp;&amp; = thing&lt;int&gt;&amp; &amp;&amp; = thing&lt;int&gt;&amp;\n\n g(thing&lt;int&gt; {}); // works\n\n //g(it);\n // T = thing\n // A = int\n // T&lt;A&gt;&amp;&amp; = thing&lt;int&gt;&amp;&amp;\n\n return 0;\n}\n</code></pre>\n<p>(<a href=\"http://ideone.com/RPrPA1\" rel=\"nofollow noreferrer\">Live here</a>)</p>\n<p><s>Concerning how one could \"overcome\" this: You cannot. At least not the way you seem to want it to, because</s> the natural solution is the third example you provide: Since you don't know the type passed (is it an lvalue reference, a rvalue reference or a reference at all?) you must keep it as generic as <code>T</code>. You could of course provide overloads, but that would somehow defeat the purpose of having perfect forwarding, I guess.</p>\n<hr>\n<p>Hm, turns out you actually <strong>can</strong> overcome this, using some traits class:</p>\n<pre><code>template&lt;typename&gt; struct traits {};\ntemplate&lt;\n template&lt;class&gt;class T,\n typename A&gt;\nstruct traits&lt;T&lt;A&gt;&gt; {\n using param = A;\n template&lt;typename X&gt;\n using templ = T&lt;X&gt;;\n};\n</code></pre>\n<p>You can then extract both the template and the type the template was instantiated with inside of the function:</p>\n<pre><code>template&lt;typename Y&gt;\ndecltype (auto) g(Y&amp;&amp; t) {\n // Needs some manual work, but well ...\n using trait = traits&lt;typename std::remove_reference&lt;Y&gt;::type&gt;;\n using A = typename trait::param;\n using T = trait::template templ\n // using it\n T&lt;A&gt; copy{t};\n A data;\n return std::forward&lt;Y&gt;(t);\n}\n</code></pre>\n<p>(<a href=\"http://ideone.com/6yyiGw\" rel=\"nofollow noreferrer\">Live here</a>)</p>\n<hr>\n<blockquote>\n<p id=\"so_32282705_32283452_0\">[...] can <em>you</em> explain why it is not an universal reference? what would the danger or the pitfall of it be, or is it too difficult to implement? I am sincerely interested.</p>\n</blockquote>\n<p><code>T&lt;A&gt;&amp;&amp;</code> isn't an universal reference because <code>T&lt;A&gt;</code> isn't a template parameter. It's (after deduction of both <code>T</code> and <code>A</code>) a simple (fixed / non generic) type.</p>\n<p>A serious pitfall of making this a forwarding reference would be that you could no longer express the current meaning of <code>T&lt;A&gt;&amp;&amp;</code>: An rvalue reference to some type built from the template <code>T</code> with parameter <code>A</code>.</p>\n</hr></hr>", "OwnerUserId": "1116364", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:34.133", "Id": "32283452", "Score": "7", "CreationDate": "2015-08-29T06:49:02.407", "LastActivityDate": "2015-08-29T14:32:51.057"}, "32282705": {"CommentCount": "3", "ViewCount": "478", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-29T04:30:10.467", "LastActivityDate": "2015-08-29T21:51:54.737", "Title": "A failure to instantiate function templates due to universal (forward) reference to a templated type", "AcceptedAnswerId": "32283452", "LastEditDate": "2017-05-23T11:54:34.133", "Id": "32282705", "Score": "11", "Body": "<p><a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"nofollow noreferrer\">Universal references</a> (i.e. \"forward references\", the <code>c++</code> standard name) and perfect forwarding in <code>c++11</code>, <code>c++14</code>, and beyond have many important advantages; see <a href=\"https://stackoverflow.com/questions/3582001/advantages-of-using-forward\">here</a>, and <a href=\"http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>In Scott Meyers' article referenced above (<a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"nofollow noreferrer\">link</a>), it is stated as a rule of thumb that:</p>\n<blockquote>\n<p id=\"so_32282705_32282705_0\">If a variable or parameter is declared to have type <strong>T&amp;&amp;</strong> for some <strong>deduced type</strong> T, that variable or parameter is a universal reference.</p>\n</blockquote>\n<h2>Example 1</h2>\n<p>Indeed, using clang++ we see that the following code snippet will successfully compile with <code>-std=c++14</code>:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\ndecltype(auto) f(T &amp;&amp; t)\n{\n    return std::forward&lt;T&gt;(t);\n}\n\nint        x1 = 1;\nint const  x2 = 1;\nint&amp;       x3 = x1;\nint const&amp; x4 = x2;\n\n// all calls to `f` result in a successful\n// binding of T&amp;&amp; to the required types\nauto r1 = f (x1);    // various lvalues okay, as expected\nauto r2 = f (x2);    // ...\nauto r3 = f (x3);\nauto r4 = f (x4);\nauto r5 = f (int()); // rvalues okay, as expected\n</code></pre>\n<p>Given any description of universal references (forward references) and type deduction (see, for instance, <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\">this explanation</a>) it is clear why the above works. Although, from the same explanation, it is not abundantly clear why the below fails to work as well.</p>\n<h2>(failed) Example 2</h2>\n<p><a href=\"https://stackoverflow.com/questions/21022724/universal-reference-to-template-template-parameter\">This question</a> addresses the same issue. The provided answers do not, however, explain why templated types are not categorized as being \"deduced\".</p>\n<p>What I am about to show (seemingly) satisfies the requirement stated above by Meyers. However, the following code snipped <strong>fails</strong> to compile, producing the error (among others for each call to <code>f</code>):</p>\n<blockquote>\n<p id=\"so_32282705_32282705_1\">test.cpp:23:11: error: no matching function for call to 'f'</p>\n<p id=\"so_32282705_32282705_2\">auto r1 = f (x1);</p>\n<p id=\"so_32282705_32282705_3\">test.cpp:5:16: note: candidate function [with T = foo, A = int] not \n  viable: no known conversion from 'struct foo&lt; int &gt;' to 'foo&lt; int &gt; &amp;&amp;' \n  for 1st argument</p>\n<p id=\"so_32282705_32282705_4\">decltype(auto) f (T&lt; A &gt; &amp;&amp; t)</p>\n</blockquote>\n<pre><code>#include &lt;utility&gt;\n\n//\n// It **seems** that the templated type T&lt;A&gt; should\n// behave the same as an bare type T with respect to\n// universal references, but this is not the case.\n//\ntemplate &lt;template &lt;typename&gt; typename T, typename A&gt;\ndecltype(auto) f (T&lt;A&gt; &amp;&amp; t)\n{\n    return std::forward&lt;T&lt;A&gt;&gt; (t);\n}\n\ntemplate &lt;typename A&gt;\nstruct foo\n{\n    A bar;\n};\n\nstruct foo&lt;int&gt;        x1 { .bar = 1 };\nstruct foo&lt;int&gt; const  x2 { .bar = 1 };\nstruct foo&lt;int&gt; &amp;      x3 = x1;\nstruct foo&lt;int&gt; const&amp; x4 = x2;\n\n// all calls to `f` **fail** to compile due\n// to **unsuccessful** binding of T&amp;&amp; to the required types\nauto r1 = f (x1);\nauto r2 = f (x2);\nauto r3 = f (x3);\nauto r4 = f (x4);\nauto r5 = f (foo&lt;int&gt; {1}); // only rvalue works\n</code></pre>\n<p>In context, since the type <code>T&lt;A&gt;</code> of <code>f</code>'s parameter <strong><em>is</em></strong> deduced, surely the parameter declaration <code>T&lt;A&gt;&amp;&amp; t</code> would behave as a universal reference (forward reference).</p>\n<h2>Example 3 (for clarity in describing the problem at hand)</h2>\n<p>Let me stress the following: the failure of the code in <code>Example 2</code> to compile is <strong>not</strong> due to the fact that <code>struct foo&lt;&gt;</code> is a templated type. The failure seems to be cause <strong>only</strong> by the declaration of <code>f</code>'s parameter as a templated type.</p>\n<p>Consider the following revision to the previous code, which now <strong>does</strong> compile:</p>\n<pre><code>#include &lt;utility&gt;\n\n//\n// If we re-declare `f` as before, where `T` is no longer a\n// templated type parameter, our code works once more.\n//\ntemplate &lt;typename T&gt;\ndecltype(auto) f (T &amp;&amp; t)\n{\n    return std::forward&lt;T&gt; (t);\n}\n\n//\n// Notice, `struct foo&lt;&gt;` is **still** a templated type.\n//\ntemplate &lt;typename A&gt;\nstruct foo\n{\n    A bar;\n};\n\nstruct foo&lt;int&gt;        x1 { .bar = 1 };\nstruct foo&lt;int&gt; const  x2 { .bar = 1 };\nstruct foo&lt;int&gt; &amp;      x3 = x1;\nstruct foo&lt;int&gt; const&amp; x4 = x2;\n\n// all calls to `f` (again) result in\n// a successful binding of T&amp;&amp; to the required types\nauto r1 = f (x1);\nauto r2 = f (x2);\nauto r3 = f (x3);\nauto r4 = f (x4);\n</code></pre>\n<p>It is astonishing to me that this simple change completely alters the behaviour of the type deduction for the template function <code>f</code>'s type parameter.</p>\n<h2>Questions:</h2>\n<p>Why does the second example not work as expected? Are there techniques to overcome this problem with templated types in <code>c++11/14</code>? Are there well known, extant codebases (in the wild) making successful use of <code>c++</code>'s forward references with templated types?</p>\n", "Tags": "<c++><templates><c++11><c++14><perfect-forwarding>", "OwnerUserId": "2601206", "AnswerCount": "4"}, "32284702": {"ParentId": "32282705", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_32282705_32284702_0\">Why does the second example not work as expected?</p>\n</blockquote>\n<p>You have two signatures:</p>\n<pre><code>template &lt;typename T&gt;                                                                                                                   \ndecltype(auto) f (T&amp;&amp; );\n\ntemplate &lt;template &lt;typename&gt; typename T, typename A&gt;                                                                                                                   \ndecltype(auto) f2 (T&lt;A&gt;&amp;&amp; );\n</code></pre>\n<p><code>f</code> takes a forwarding reference, but <code>f2</code> does not. The specific rule, from [temp.deduct.call] is, bold emphasis mine:</p>\n<blockquote>\n<p id=\"so_32282705_32284702_1\">A <em>forwarding reference</em> is an rvalue\n  reference to a cv-unqualified <strong>template parameter</strong>. If P is a forwarding reference and the argument is an\n  lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.</p>\n</blockquote>\n<p>With <code>f</code>, the argument is an rvalue reference to a template parameter (<code>T</code>). But with <code>f2</code>, <code>T&lt;A&gt;</code> is not a template parameter. Thus, that function simply takes as its argument an rvalue reference to <code>T&lt;A&gt;</code>. The calls fail to compile because all your arguments are lvalues and this case has no special exception for being called with an lvalue. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32284702", "Score": "2", "CreationDate": "2015-08-29T09:42:58.790", "LastActivityDate": "2015-08-29T09:42:58.790"}, "32285159": {"ParentId": "32282705", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As for overcoming the problem, I guess a more or less equivalent way would be to deduce it with a forward reference, and trigger the comparison with <code>T&lt;A&gt;</code> manually.</p>\n<pre><code>template&lt;typename T&gt;\nclass X;\n\ntemplate&lt;template&lt;typename&gt; class T, typename A&gt;\nclass X&lt;T&lt;A&gt;&gt; {\npublic:\n   using type = A;\n\n   template&lt;typename _&gt;\n   using template_ = T&lt;_&gt;;\n};\n\ntemplate&lt;typename T, typename R&gt;\nstruct copyref {\n  using type = T;\n};\ntemplate&lt;typename T, typename R&gt;\nstruct copyref&lt;T, R&amp;&gt; {\n   using type = T&amp;;\n};\ntemplate&lt;typename T, typename R&gt;\nstruct copyref&lt;T, R&amp;&amp;&gt; {\n   using type = T&amp;&amp;;\n};\n\ntemplate &lt;typename U, typename XX = X&lt;std::decay_t&lt;U&gt;&gt;, \n          typename = typename XX::type &gt;                                                                                                                   \ndecltype(auto) f (U &amp;&amp; t)                                                                                                               \n{                                                                                                                                      \n    return std::forward&lt;\n       typename copyref&lt;\n         typename XX::template template_&lt;typename XX::type&gt;, U\n       &gt;::type&gt;(t);\n}\n</code></pre>\n<p>If you don't actually want <code>T&lt;A&gt;</code> but a specific type, the best way is to use <code>std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;U&gt;, SpecificType&gt;&gt;</code>, which is way easier, I guess.</p>\n<pre><code>int main() {\n    static_assert(std::is_same&lt;decltype(f(std::declval&lt;X&lt;int&gt;&amp;&gt;())), \n                  X&lt;int&gt;&amp;&gt;::value, \"wrong\");\n    static_assert(std::is_same&lt;decltype(f(std::declval&lt;X&lt;int&gt;&gt;())), \n                  X&lt;int&gt;&amp;&amp;&gt;::value, \"wrong\");\n    // compile error\n    //f(std::declval&lt;int&gt;());\n}\n</code></pre>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2015-08-29T10:59:43.783", "Id": "32285159", "Score": "0", "CreationDate": "2015-08-29T10:45:33.890", "LastActivityDate": "2015-08-29T10:59:43.783"}, "32287935": {"ParentId": "32282705", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It is not enough to have type deduction. The form of the type declaration must be <strong>exactly <code>T&amp;&amp;</code></strong> (an rvalue reference to just a <strong>template parameter</strong>).  If it's not (or there is no type deduction) the parameter is an rvalue reference.  If the argument is an lvalue, it won't compile.  Since <code>T&lt;A&gt;&amp;&amp;</code> does not have that form, <code>f (T&lt;A&gt; &amp;&amp; t)</code> is unable to accept an lvalue (as an lvalue reference) and you get the error.  If you think that requires too much generality, consider that a simple <code>const</code> qualifier breaks it too:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(const T&amp;&amp; param); // rvalue reference because of const\n</code></pre>\n<p>(putting aside the relative uselessness of a const rvalue reference)</p>\n<p>The rules for reference collapsing simply do not kick in unless the most general form <code>T&amp;&amp;</code> is used.  Without the ability for <code>f</code> to recognize an <em>lvalue</em> argument was passed and treat the parameter as an <em>lvalue reference</em>, there is no reference collapsing to be done (i.e. collapsing <code>T&amp; &amp;&amp;</code> to <code>T&amp;</code> can't happen and it's just <code>T&lt;something&gt;&amp;&amp;</code>, an rvalue ref. to a templated type).  The needed mechanism for the function to determine whether an rvalue or an lvalue is passed as an argument is encoded in the deduced template parameter.  However, this encoding only occurs for a universal reference parameter, as strictly defined.</p>\n<p>Why is this level of generality is necessary (besides just being the rule)? <s>Without this specific definition format, universal references could not be super-greedy functions that instantiate to capture any type of argument... as they are designed to be.</s> <a href=\"https://stackoverflow.com/a/32283452/2778484\">Daniel's answer</a> gets to the point, I think: <strong>Suppose you want to define a function with a regular rvalue reference to a templated type parameter, <code>T&lt;A&gt;&amp;&amp;</code> (i.e. that does not accept an lvalue argument).</strong>  If the following syntax were treated as a universal reference, then how would you change it to specify a regular rvalue reference?</p>\n<pre><code>template &lt;template &lt;typename&gt; typename T, typename A&gt;\ndecltype(auto) f (T&lt;A&gt; &amp;&amp; t) // rv-ref - how else would you exclude lvalue arguments?\n</code></pre>\n<p><strong>There needs to be a way to explicitly define the parameter as an rvalue reference to exclude lvalue arguments.</strong>  This reasoning would seem to apply for other types of parameters, including cv qualifications.</p>\n<p>Also, there seem to be ways around this (see traits and SFINAE), but I can't answer that part.  :)</p>\n", "OwnerUserId": "2778484", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:39.053", "Id": "32287935", "Score": "0", "CreationDate": "2015-08-29T15:57:46.797", "LastActivityDate": "2015-08-29T21:51:54.737"}, "bq_ids": {"n4140": {"so_32282705_32284702_1": {"section_id": 304, "quality": 0.8235294117647058, "length": 14}, "so_32282705_32282705_0": {"section_id": 5451, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_32282705_32284702_1": {"section_id": 295, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_32282705_32284702_1": {"section_id": 311, "quality": 0.9411764705882353, "length": 16}}}});