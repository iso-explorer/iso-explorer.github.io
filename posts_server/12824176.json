post_cb({"12826028": {"ParentId": "12824176", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_12824176_12826028_0\">However, I am a bit surprised. As far as I know, there are several situations where exception objects might be copied, e.g. <code>std::current_exception()</code> and <code>std::rethrow_exception()</code>.</p>\n</blockquote>\n<p>But you don't call any of them. The standard is quite clear about how the exception object is initialized. From 15.1, p3:</p>\n<blockquote>\n<p id=\"so_12824176_12826028_1\">A throw-expression initializes a temporary object, called the exception object , the type of which is determined by removing any top-level cv-qualifier s from the static type of the operand of throw and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively. The temporary is an lvalue and is used to initialize the variable named in the matching handler (15.3). If the type of the exception object would be an incomplete type or a pointer to an incomplete type other than (possibly cv-qualified) void the program is ill-formed. Except for these restrictions and the restrictions on type matching mentioned in 15.3, the operand of throw is treated exactly as a function argument in a\n  call (5.2.2) or the operand of a return statement.</p>\n</blockquote>\n<p>In short, it acts like returning a type by value: the return value/exception object is initialized by the expression you provide. Because the expression you use is a temporary, it will act like returning a temporary from a function and invoke the move constructor. Granted, odds are good that this will be elided, but that's the point that 15.1, p5 makes:</p>\n<blockquote>\n<p id=\"so_12824176_12826028_2\">When the thrown object is a class object, the copy/move constructor and the destructor shall be accessible, even if the copy/move operation is elided (12.8).</p>\n</blockquote>\n<p>This is just as true for returning values: the return value is initialized by copy/move initialization, where appropriate. Thus, the appropriate constructors have to be accessible, even if they're elided.</p>\n<p>You can't throw your exception class in a way that would require copy-construction of the exception object. So you can't throw an lvalue; you can only throw a prvalue or an xvalue.</p>\n<p>Nowhere in the standard does it say that the system is allowed to <em>arbitrarily</em> copy the exception for no reason. A call to <code>std::current_exception</code> may copy it. A call to <code>std::rethrow_exception</code> will likely copy it.</p>\n<p>But if you don't call things that explicitly copy your exception objects, C++ is <em>not allowed</em> to do so willy-nilly.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-10-10T20:12:51.423", "Id": "12826028", "Score": "2", "CreationDate": "2012-10-10T18:32:52.093", "LastActivityDate": "2012-10-10T20:12:51.423"}, "12824376": {"ParentId": "12824176", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>current_exception</code> says it refers either to the current exception or to a copy of it it, but doesn't say which. This suggests to me that:</p>\n<ul>\n<li>it is unspecified whether it is or not it's copied[*]</li>\n<li>therefore, your exception class is not good (certainly not if anyone might call <code>current_exception</code> on it)</li>\n<li>also therefore, it's no great surprise that it works in some implementations. There probably wouldn't be provision for the current exception <em>not</em> to be copied unless there was either demand for that from implementers or hope that implementers would avoid copies.</li>\n</ul>\n<p>Just throwing the thing and catching it by reference is fine. The temporary in the <code>throw</code> expression is \"used to initialize\" the object used by the implementation to keep the current exception, so it can be moved or copied (according to which the class supports), and that move/copy can be elided.</p>\n<p>For what it's worth, <code>make_exception_ptr</code> is specified to <em>always</em> copy. You could perhaps argue that this is a defect: <code>e</code> can be a by-value parameter in which case moving might be better. But that's my impetuous and ignorant impression, I've never even seen these functions before now.</p>\n<p>[*] It's explicitly unspecified whether or not <code>current_exception</code> \"creates a new copy each time it's called\", but I'm not wholly certain whether that is intended to imply that it's unspecified whether it creates a new copy the first time it's called.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2012-10-10T16:57:30.787", "Id": "12824376", "Score": "2", "CreationDate": "2012-10-10T16:45:28.057", "LastActivityDate": "2012-10-10T16:57:30.787"}, "bq_ids": {"n4140": {"so_12824176_12826028_2": {"section_id": 3338, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_12824176_12826028_2": {"section_id": 3208, "quality": 0.9285714285714286, "length": 13}, "so_12824176_12826028_1": {"section_id": 3206, "quality": 0.8970588235294118, "length": 61}}, "n4659": {"so_12824176_12826028_2": {"section_id": 4105, "quality": 0.7857142857142857, "length": 11}}}, "12824176": {"CommentCount": "4", "ViewCount": "519", "PostTypeId": "1", "LastEditorUserId": "1305501", "CreationDate": "2012-10-10T16:32:00.423", "LastActivityDate": "2017-11-05T18:52:58.983", "Title": "Moveable but Non-Copyable Exceptions", "FavoriteCount": "1", "LastEditDate": "2017-11-05T18:52:58.983", "Id": "12824176", "Score": "3", "Body": "<p>I am thinking about writing non-copyable exception classes. I find it interesting, because then I don't have to worry about exceptions that could be thrown during allocations within the copy-constructor. If the creation of the exception object succeeds, everything is fine and there should be no issues with <code>std::terminate</code>.</p>\n<pre><code>struct exception\n{\n    exception() = default;\n    exception(const exception&amp;) = delete;\n    exception(exception&amp;&amp;) noexcept = default;\n    ~exception() noexcept = default;\n    auto operator=(const exception&amp;) -&gt; exception&amp; = delete;\n    auto operator=(exception&amp;&amp;) noexcept -&gt; exception&amp; = delete;\n};\n\nint main()\n{\n    try {\n        try {\n            throw exception{};\n        } catch (...) {\n            std::rethrow_exception(\n                std::current_exception());\n        }\n    } catch (const exception&amp; e) {\n        return 1;\n    }\n}\n</code></pre>\n<p>GCC-4.7 and Clang-3.2 accept the above code. However, I am a bit surprised. As far as I know, there are several situations where exception objects might be copied, e.g. <code>std::current_exception()</code> and <code>std::rethrow_exception()</code>.</p>\n<p><strong>Question:</strong> Is the above code correct according to C++11, i.e. will it be accepted by all compilers conforming to C++11?</p>\n<p><em>Edited:</em> Added <code>std::rethrow_exception</code> and <code>std::current_exception</code> to the example. Both compilers accept this version. This should make it clear, that if the compiler doesn't require a copy-constructor when an exception is thrown, the compiler won't require one when these two functions are used.</p>\n", "Tags": "<c++><exception><c++11>", "OwnerUserId": "1305501", "AnswerCount": "2"}});