post_cb({"bq_ids": {"n4140": {"so_15445593_15445593_0": {"length": 9, "quality": 1.0, "section_id": 5313}}, "n3337": {"so_15445593_15445593_0": {"length": 9, "quality": 1.0, "section_id": 5110}}, "n4659": {"so_15445593_15445593_0": {"length": 9, "quality": 1.0, "section_id": 6737}}}, "15446104": {"Id": "15446104", "PostTypeId": "2", "Body": "<p>The new lines it is talking about are the ones that still exist after comments are replaced by a single space character.  This is clearer when the snippet is viewed in the larger context of the paragraph it is contained in.</p>\n<p>So specifically the new lines in multi-line comments are <em>not</em> retained, and do not terminate preprocessing directives.</p>\n", "LastActivityDate": "2013-03-16T05:58:01.267", "CommentCount": "2", "CreationDate": "2013-03-16T05:58:01.267", "ParentId": "15445593", "Score": "2", "OwnerUserId": "1131467"}, "15445593": {"ViewCount": "416", "Body": "<p>In C++11, the standard say in 2.2.3:</p>\n<blockquote>\n<p id=\"so_15445593_15445593_0\">Each comment is replaced by one space character. New-line characters are retained.</p>\n</blockquote>\n<ol>\n<li><p>Is that phrase sequential, meaning retaining new-line for comment that terminates with new-line?</p></li>\n<li><p>If (1) is true then why Visual C++, gcc and clang keeps empty line for each line in a multi-comment.</p></li>\n</ol>\n<p>This questions are important because I'm writing a c++ preprocessor.</p>\n", "AcceptedAnswerId": "15446104", "Title": "Multi-line comments and new-lines", "CreationDate": "2013-03-16T04:31:11.883", "Id": "15445593", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-06-30T10:25:37.270", "LastEditorUserId": "4370109", "LastActivityDate": "2016-06-30T10:25:37.270", "Score": "4", "OwnerUserId": "235860", "Tags": "<c++><c++11><c-preprocessor>", "AnswerCount": "2"}, "15615046": {"Id": "15615046", "PostTypeId": "2", "Body": "<p>A C/C++ preprocessor strips all comments, but generally keeps source lines at the same line numbers when you look at the preprocessor output. </p>\n<p>This is so that a compiler which reads the preprocessor output can print correct line numbers for error messages and warnings. </p>\n<p>Preprocessors usually also keep all empty lines as they are.</p>\n<p>You also have to strictly differentiate between multiline macros being removed from the source and when they get expanded. They always get removed <em>while keeping all linefeeds</em>. They always get replaced with <em>all linefeeds stripped</em>. Both are totally independent operations which have nothing to do with each other. </p>\n<p>In the old days a C preprocessor would produce its output always on stdout and the C compiler would read it from stdin. The preprocessor emits internal <code>#&lt;N&gt; \"&lt;FILE&gt;\"</code> statements which the C compiler interprets as 'line number N is following'. So the preprocessor could in theory do without emitting empty lines in the output. But in practice this <code>#&lt;N&gt; \"&lt;FILE&gt;\"</code> feature is only used for lines following <code>#include</code> statements.</p>\n<p>Today the preprocessor is built into the C compiler for performance, but you can still look at the intermediate result if explicitly requested.</p>\n<p>Note: See also the good comment below: The standard does not really specify how the text output of a preprocessor looks like in terms of white-spaces. The text output is implementation specific. There is quite some room for interpretation. What is defined is where at least one space character must be and that all tokes stay on their original lines (or get tagged with their original line) so that error messages make sense.</p>\n", "LastEditorUserId": "2205033", "LastActivityDate": "2013-03-25T23:18:25.687", "Score": "2", "CreationDate": "2013-03-25T12:32:18.717", "ParentId": "15445593", "CommentCount": "1", "OwnerUserId": "2205033", "LastEditDate": "2013-03-25T23:18:25.687"}});