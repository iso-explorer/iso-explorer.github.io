post_cb({"45372988": {"ParentId": "45265690", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code shows undefined behavior according to <a href=\"http://eel.is/c++draft/dcl.link#1\" rel=\"nofollow noreferrer\">[dcl.link]/1</a> and <a href=\"http://eel.is/c++draft/expr.call#1\" rel=\"nofollow noreferrer\">[expr.call]/1</a> (emphases are mine):</p>\n<p>[dcl.link]/1:</p>\n<blockquote>\n<p id=\"so_45265690_45372988_0\">All function types, function names with external linkage, and variable names with external linkage have a language linkage. [\u2009Note: Some of the properties associated with an entity with language linkage are specific to each implementation and are not described here. For example, a particular language linkage may be associated with a particular form of representing names of objects and functions with external linkage, or with a particular calling convention, etc. \u2014\u2009end note\u2009] The default language linkage of all function types, function names, and variable names is C++ language linkage. <strong>Two function types with different language linkages are distinct types even if they are otherwise identical</strong>.</p>\n</blockquote>\n<p>[expr.call]/1:</p>\n<blockquote>\n<p id=\"so_45265690_45372988_1\">A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of initializer-clauses which constitute the arguments to the function. The postfix expression shall have function type or function pointer type. For a call to a non-member function or to a static member function, the postfix expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion is suppressed on the postfix expression), or it shall have function pointer type. <strong>Calling a function through an expression whose function type is different from the function type of the called function's definition results in undefined behavior</strong> ([dcl.link]). For a call to a non-static member function, the postfix expression shall be an implicit ([class.mfct.non-static], [class.static]) or explicit class member access whose id-expression is a function member name, or a pointer-to-member expression selecting a function member; the call is as a member of the class object referred to by the object expression. In the case of an implicit class member access, the implied object is the one pointed to by this. [\u2009Note: A member function call of the form f() is interpreted as (*this).f() (see [class.mfct.non-static]). \u2014\u2009end note\u2009] If a function or member function name is used, the name can be overloaded, in which case the appropriate function shall be selected according to the rules in [over.match]. If the selected function is non-virtual, or if the id-expression in the class member access expression is a qualified-id, that function is called. Otherwise, its final overrider in the dynamic type of the object expression is called; such a call is referred to as a virtual function call. [\u2009Note: The dynamic type is the type of the object referred to by the current value of the object expression. [class.cdtor] describes the behavior of virtual function calls when the object expression refers to an object under construction or destruction. \u2014\u2009end note\u2009]</p>\n</blockquote>\n", "OwnerUserId": "1042389", "LastEditorUserId": "2757035", "LastEditDate": "2017-07-28T12:05:26.023", "Id": "45372988", "Score": "1", "CreationDate": "2017-07-28T12:00:21.377", "LastActivityDate": "2017-07-28T12:05:26.023"}, "bq_ids": {"n4140": {"so_45265690_45372988_1": {"section_id": 5988, "quality": 0.8791208791208791, "length": 160}, "so_45265690_45372988_0": {"section_id": 5517, "quality": 0.9166666666666666, "length": 66}, "so_45265690_45265690_0": {"section_id": 5520, "quality": 0.9767441860465116, "length": 42}}, "n3337": {"so_45265690_45372988_1": {"section_id": 5756, "quality": 0.7692307692307693, "length": 140}, "so_45265690_45372988_0": {"section_id": 5303, "quality": 0.9166666666666666, "length": 66}, "so_45265690_45265690_0": {"section_id": 5306, "quality": 0.9767441860465116, "length": 42}}, "n4659": {"so_45265690_45372988_0": {"section_id": 6952, "quality": 0.9166666666666666, "length": 66}, "so_45265690_45265690_0": {"section_id": 6955, "quality": 0.9767441860465116, "length": 42}, "so_45265690_45372988_1": {"section_id": 7488, "quality": 0.9010989010989011, "length": 164}}}, "45265690": {"CommentCount": "4", "AcceptedAnswerId": "45372988", "PostTypeId": "1", "LastEditorUserId": "5479741", "CreationDate": "2017-07-23T13:36:07.253", "LastActivityDate": "2017-07-28T12:05:26.023", "LastEditDate": "2017-07-25T20:06:54.167", "ViewCount": "79", "FavoriteCount": "1", "Title": "Do GCC and clang show the same result as Visual Studio on this case, about language linkage?", "Id": "45265690", "Score": "1", "Body": "<p><a href=\"http://eel.is/c++draft/dcl.link#4\" rel=\"nofollow noreferrer\">[dcl.link]/4</a>:</p>\n<blockquote>\n<p id=\"so_45265690_45265690_0\">Linkage specifications nest. When linkage specifications nest, the\n  innermost one determines the language linkage. A linkage specification\n  does not establish a scope. A linkage-specification shall occur only\n  in namespace scope. In a linkage-specification, <strong>the specified\n  language linkage applies to the function types of all function\n  declarators</strong>, function names with external linkage, and variable\n  names with external linkage declared within the linkage-specification.\n  [\u2009Example:</p>\n<pre><code>extern \"C\"                      // the name f1 and its function type have C language linkage;\n  void f1(void(*pf)(int));      // pf is a pointer to a C function\n</code></pre>\n<p id=\"so_45265690_45265690_1\">...</p>\n<p id=\"so_45265690_45265690_2\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>Observe that the pointer <code>&amp;foo</code> passed to the function <code>c_f()</code> below is <strong>not</strong> a pointer to a C function. This code compiles and links normally in VS2017. But it shouldn't, according to [dcl.link]/4.</p>\n<p><strong>File</strong> <code>main.cpp</code>:</p>\n<pre><code>#include &lt;stdio.h&gt;\nextern \"C\"                          // the name c_f and its function type have C language linkage;\nvoid c_f(void(*pf)(int));           // pf is a pointer to a C function\n\nvoid foo(int i) {\n    printf(\"%d\\n\", i);\n}\n\nextern \"C\" void c_foo(int);\n\nint main() {\n    c_foo(1);       // Calls c_foo(int) defined in other.c\n    c_f(&amp;foo);      // Calls c_f(void(*)(int)) defined in other.c, but &amp;foo is not a pointer to a C function !! \n}\n</code></pre>\n<p><strong>File</strong> <code>other.c</code>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid c_f(void(*pf)(int)){\n    pf(2);\n}\n\nvoid c_foo(int i) {\n    printf(\"%d\\n\", i);\n}\n</code></pre>\n<p>I'm curious to know whether clang and GCC are compliant with the Standard, but I can't verify this in a web compiler.</p>\n<p><strong>Edit</strong></p>\n<p>It dawned on me that I really don't need two files to verify whether clang and GCC are compliant to the Standard, on the issue mentioned above. If the Standard requires the address of a C function, as an argument for the function <code>c_f()</code> and the code in <code>main.cpp</code> supplies the address of a C++ function, the C++ compiler has to complain<sup>1</sup> when compiling this file. But that doesn't happen neither in <a href=\"https://godbolt.org/g/VgAkhC\" rel=\"nofollow noreferrer\">clang</a> nor in <a href=\"https://godbolt.org/g/u22BPG\" rel=\"nofollow noreferrer\">GCC</a>. Then, I might as well say that both clang and GCC are also buggy on this regard.</p>\n<p><sub>1) If we assume that a diagnostic is required</sub></p>\n", "Tags": "<c++><language-lawyer><linkage>", "OwnerUserId": "5479741", "AnswerCount": "1"}});