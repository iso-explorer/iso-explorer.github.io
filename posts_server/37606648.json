post_cb({"37606648": {"CommentCount": "3", "ViewCount": "111", "CreationDate": "2016-06-03T05:34:55.413", "LastActivityDate": "2016-06-03T06:19:03.747", "Title": "In C++, is it allowed to cast a function pointer to one that gets as a parameter a pointer to a base or derived class?", "PostTypeId": "1", "Id": "37606648", "Score": "4", "Body": "<p>Will the following work as expected?:</p>\n<pre><code>struct A {};\n\nstruct B: public A {\n    int x;\n    };\n\nvoid f( B* o ) {\n    std::cout &lt;&lt; o-&gt;x &lt;&lt; std::endl;\n    }\n\nint main () {\n    B b;\n    b.x = 5;\n    reinterpret_cast&lt;void(*)(A*)&gt;(f)( &amp;b );\n    }\n</code></pre>\n", "Tags": "<c++><pointers><casting><function-pointers>", "OwnerUserId": "4583357", "AnswerCount": "2"}, "37606800": {"ParentId": "37606648", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>See <a href=\"http://eel.is/c++draft/expr.reinterpret.cast#6\" rel=\"nofollow\">5.2.10/6</a> [expr.reinterpret.cast]:</p>\n<blockquote>\n<p id=\"so_37606648_37606800_0\">A function pointer can be explicitly converted to a function pointer of a different type.\u00a0The effect of calling a function through a pointer to a function type that is not the same as the type used in the definition of the function is undefined.</p>\n</blockquote>\n<p>That said, note as an example that C++ allows you to dereference a null pointer, so maybe <em>allowed</em> is not the right term.<br>\nThe following command compiles too:</br></p>\n<pre><code>reinterpret_cast&lt;void(*)(A*, int)&gt;(f)( &amp;b, 42 );\n</code></pre>\n<p>It is allowed, as well as the one in the question, no matter if it works as expected or not (it mostly depends on your expectations, as noted by @luk32 in the comments).</p>\n<p>The answer to your question would be <em>yes, the cast is allowed, but the invokation of the function through the new pointer leads to an undefined behavior</em>.</p>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-06-03T05:54:02.127", "Id": "37606800", "Score": "5", "CreationDate": "2016-06-03T05:48:20.863", "LastActivityDate": "2016-06-03T05:54:02.127"}, "bq_ids": {"n4140": {"so_37606648_37606800_0": {"section_id": 6045, "quality": 0.9545454545454546, "length": 21}, "so_37606648_37606711_0": {"section_id": 6045, "quality": 0.6, "length": 18}}, "n3337": {"so_37606648_37606800_0": {"section_id": 5813, "quality": 0.9545454545454546, "length": 21}, "so_37606648_37606711_0": {"section_id": 5813, "quality": 0.6, "length": 18}}, "n4659": {"so_37606648_37606800_0": {"section_id": 7544, "quality": 0.9545454545454546, "length": 21}, "so_37606648_37606711_0": {"section_id": 7544, "quality": 0.6, "length": 18}}}, "37606711": {"ParentId": "37606648", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Its undefined behaviour to use such pointer after cast:</p>\n<blockquote>\n<p id=\"so_37606648_37606711_0\">Any pointer to function can be converted to a pointer to a different function type. Calling the function through a pointer to a different function type is undefined, but converting such pointer back to pointer to the original function type yields the pointer to the original function.</p>\n</blockquote>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language</a></p>\n<p>So the answer to your question is actually positive - you are allowed to cast but nothing more. </p>\n<p>You might ask \"what is the point of only casting?\" - this is usefull when you want to store various functions in single collection.</p>\n", "OwnerUserId": "471160", "LastEditorUserId": "471160", "LastEditDate": "2016-06-03T06:19:03.747", "Id": "37606711", "Score": "5", "CreationDate": "2016-06-03T05:41:19.223", "LastActivityDate": "2016-06-03T06:19:03.747"}});