post_cb({"bq_ids": {"n4140": {"so_20773783_20774847_0": {"length": 12, "quality": 0.631578947368421, "section_id": 6706}}, "n3337": {"so_20773783_20774847_0": {"length": 12, "quality": 0.631578947368421, "section_id": 6461}, "so_20773783_20774847_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 5650}}, "n4659": {"so_20773783_20774847_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 8181}}}, "20774847": {"Id": "20774847", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n\nstruct Containing {\n    struct {\n        Containing * get_containing () {\n            return reinterpret_cast&lt;Containing *&gt; (\n                (char *) this - offsetof (Containing, inner)\n            );\n        }\n    } inner;\n};\n\n\nint main () {\n    Containing c;\n    std::cout\n        &lt;&lt; (c.inner.get_containing () == &amp;c ? \"success\" : \"fail\")\n        &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The specific code you show, which I\u2019ve repeated above, is OK, because <code>reinterpret_cast</code> to/from first element of a POD is supported for C compatibility.</p>\n<p>As I recall C++11 extended the set of types where that <code>reinterpret_cast</code> works.</p>\n<p>However, as soon as you introduce a virtual function or other non-POD\u2019y stuff you exceed the operating regime of <code>offsetof</code>, as well as that guaranteed <code>reinterpret_cast</code>.</p>\n<hr>\n<p><strong>Standardese</strong>. By using the \u201cfind\u201d function in my PDF reader, applied to the document [N3290.pdf] (the final draft of C++11, identical to the standard), in three mouse clicks the following info about <code>offsetof</code> was offered:</p>\n<blockquote>\n<p id=\"so_20773783_20774847_0\">C++11 \u00a718.2/4:<br>\n  \u201cThe macro <code>offsetof</code>(<em>type</em>, <em>member-designator</em>) accepts a restricted set of <em>type</em> arguments in this International\n  Standard. If <em>type</em> is not a standard-layout class (Clause 9), the results are undefined.\u201d</br></p>\n</blockquote>\n<p>Similarly, by clicking on section heading 9 about \u201cClasses\u201d and then asking the PDF reader to search for <code>reinterpret_cast</code>, I found \u2026</p>\n<blockquote>\n<p id=\"so_20773783_20774847_1\">C++11 9.2/20:<br>\n  \u201cA pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa\u201d</br></p>\n</blockquote>\n<hr>\n<p><strong>In-practice</strong>. Using <code>offsetof</code> for the first member is bit meaningless since it's guaranteed to be at offset 0 (no padding before). In order to make this thing meaningful you have to mean some logical generalization of the given code, where \u2026</p>\n<ul>\n<li>The relevant member is not the first member.</li>\n<li>The pointer arithmetic is done with pointer to byte (e.g. <code>char</code>).</li>\n</ul>\n<p>Then for POD types, or C++11 more general standard-layout, the <code>offsetof</code> is fine, but the <code>reinterpret_cast</code> needs specific compiler support. With Visual C++ it\u2019s OK. With g++ you\u2019d better either, if possible, turn off its silly-warnings and associated silly-optimizations, or make a detour through a <code>void</code> pointer.</p>\n<p>Exeeding the limits of <code>offsetof</code> is not in general a good idea. E.g. with virtual inheritance the offsets can vary widely, not deducible from only static type information.</p>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2013-12-25T17:07:21.747", "Score": "3", "CreationDate": "2013-12-25T16:40:59.403", "ParentId": "20773783", "CommentCount": "0", "LastEditDate": "2013-12-25T17:07:21.747", "OwnerUserId": "464581"}, "20773783": {"ViewCount": "178", "Body": "<p>Is the following portable and standard-conforming C++, always returning \"success\"?</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n\nstruct Containing {\n    struct {\n        Containing * get_containing () {\n            return reinterpret_cast&lt;Containing *&gt; (\n                (char *) this - offsetof (Containing, inner)\n            );\n        }\n    } inner;\n};\n\n\nint main () {\n    Containing c;\n    std::cout\n        &lt;&lt; (c.inner.get_containing () == &amp;c ? \"success\" : \"fail\")\n        &lt;&lt; std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "20774847", "Title": "Calculating this pointer of containing object", "CreationDate": "2013-12-25T14:27:57.997", "Id": "20773783", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-12-25T14:47:12.397", "LastEditorUserId": "1419315", "LastActivityDate": "2013-12-25T17:07:21.747", "Score": "0", "OwnerUserId": "1419315", "Tags": "<c++><inner-classes><pointer-arithmetic>", "AnswerCount": "1"}});