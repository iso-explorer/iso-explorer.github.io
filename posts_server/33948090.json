post_cb({"bq_ids": {"n4140": {"so_33948090_33948222_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 302}}, "n3337": {"so_33948090_33948222_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 293}}, "n4659": {"so_33948090_33948222_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 309}}}, "33948090": {"ViewCount": "236", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">CPP reference</a> on list-initialisation:</p>\n<blockquote>\n<p id=\"so_33948090_33948090_0\">Otherwise, the constructors of T are considered, in two phases:</p>\n<ul>\n<li><p id=\"so_33948090_33948090_1\">All constructors that take std::initializer_list as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by overload resolution against a single argument of type std::initializer_list</p></li>\n<li><p id=\"so_33948090_33948090_2\">If the previous stage does not produce a match, all constructors of T participate in overload resolution against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all)</p></li>\n</ul>\n</blockquote>\n<p>So a constructor using <code>initializer_list</code> is considered first. Failing that, each element of the list is considered as arguments for constructors. However</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct A{\n    template &lt;typename... Args&gt; A(Args... li) { cout &lt;&lt; sizeof...(Args) &lt;&lt; endl;}\n};\n\nint main(){\n\n    A a = {2,3,4};\n\n}\n</code></pre>\n<p>The output is <code>3</code> which indicates that <code>Args...</code> unpacks as <code>int, int, int</code>. Why is it that Args... was not simply made the singular <code>initializer_list&lt;int&gt;</code>, which the details on list-initialisation indicated would be the first attempted type of constructor?</p>\n", "AcceptedAnswerId": "33948222", "Title": "List-initializer and variadic constructor", "CreationDate": "2015-11-26T22:52:30.377", "Id": "33948090", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-11-27T00:27:57.163", "Score": "3", "OwnerUserId": "3348786", "Tags": "<c++><templates><c++11><initializer-list><variadic>", "AnswerCount": "2"}, "33948222": {"Id": "33948222", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33948090_33948222_0\"><strong>[temp.deduct.call]/1</strong> Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with the type of the corresponding argument of the call (call it <code>A</code>) as described below. If removing references and cv-qualifiers from <code>P</code> gives <code>std::initializer_list&lt;P'&gt;</code> for some <code>P'</code> and the argument is an initializer list (8.5.4), then deduction is performed instead for each element of the initializer list, taking <code>P'</code> as a function template parameter type and the initializer element as its argument. Otherwise, <strong>an initializer list argument causes the parameter to be considered a non-deduced context (14.8.2.5).</strong></p>\n</blockquote>\n<p>Emphasis mine. For this reason, template argument deduction for the constructor from an argument of type <code>initializer_list&lt;int&gt;</code> fails.</p>\n", "LastActivityDate": "2015-11-26T23:07:23.157", "CommentCount": "3", "CreationDate": "2015-11-26T23:07:23.157", "ParentId": "33948090", "Score": "4", "OwnerUserId": "1670129"}, "33948779": {"Id": "33948779", "PostTypeId": "2", "Body": "<p>If you provide explicitly a constructor with <code>std::initializer_list</code>, it would be choose: \n<a href=\"https://ideone.com/9ta3BC\" rel=\"nofollow\">Demo</a>.</p>\n<p><code>template &lt;typename... Args&gt; A(Args...)</code> is not a constructor with first argument <code>std::initializer_list</code> (even if first argument may be an <code>std::initializer_list</code>).</p>\n<p>And in <code>A a = {2, 3, 4}</code>, <code>{2, 3, 4}</code> has no type. It is not a <code>std::initializer_list</code>.</p>\n", "LastActivityDate": "2015-11-27T00:27:57.163", "CommentCount": "0", "CreationDate": "2015-11-27T00:27:57.163", "ParentId": "33948090", "Score": "1", "OwnerUserId": "2684539"}});