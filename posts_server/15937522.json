post_cb({"bq_ids": {"n4140": {"so_15937522_15938175_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3328}}, "n4659": {"so_15937522_15938175_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4094}}}, "15938175": {"Id": "15938175", "PostTypeId": "2", "LastEditDate": "2013-04-10T23:26:09.083", "CommentCount": "1", "LastEditorUserId": "906773", "LastActivityDate": "2013-04-10T23:26:09.083", "CreationDate": "2013-04-10T23:17:56.543", "ParentId": "15937522", "Score": "4", "Body": "<p>Your current code <em>should not compile</em> according to current C++11 rules. When <a href=\"http://liveworkspace.org/code/3TRNX4%247\" rel=\"nofollow\">compiled with clang 3.2</a> I get the following error:</p>\n<pre><code>source.cpp:33:28: error: constexpr variable 'a' must be initialized by a constant\nexpression \nconstexpr array&lt;double&gt; a = { 1.0, 2.1, 3.2, 4.3, 5.4, 6.5 };\n                        ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n<p>This is because <code>std::initializer_list</code>s ctors and member functions <code>begin</code> and <code>end</code> are not labeled <code>constexpr</code>. However, <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3471.html\" rel=\"nofollow\">there already is a proposal to change this</a>. BTW, libstdc++ already marks these as <code>constexpr</code>.</p>\n<p>Now the next problem is the <strong>lifetime</strong> of the underlying array of <code>std::initializer_list</code>. This is explained in 8.5.4p6:</p>\n<blockquote>\n<p id=\"so_15937522_15938175_0\">The array has the same lifetime as any other temporary object (12.2),\n  except that initializing an initializer_list object from the array\n  extends the lifetime of the array exactly like binding a reference to\n  a temporary.</p>\n</blockquote>\n<p>This means that the underlying array has the same lifetime as <code>values</code> object, and expires at the end of your <code>array</code> constructor when it exits. Therefore, <code>_data</code> is pointing to expired memory and <code>_data[n]</code> is undefined behavior.</p>\n", "OwnerUserId": "906773"}, "15937522": {"ViewCount": "3029", "LastEditDate": "2013-04-21T16:48:18.507", "AcceptedAnswerId": "15938175", "Title": "constexpr array and std::initializer_list", "CreationDate": "2013-04-10T22:20:33.967", "LastActivityDate": "2013-04-21T16:48:18.507", "CommentCount": "0", "Body": "<p>I was trying to write an compile-time valarray that could be used like this:</p>\n<pre><code>constexpr array&lt;double&gt; a = { 1.0, 2.1, 3.2, 4.3, 5.4, 6.5 };\n\nstatic_assert(a[0] == 1.0, \"\");\nstatic_assert(a[3] == 4.3, \"\");\n\nstatic_assert(a.size() == 6, \"\");\n</code></pre>\n<p>I managed to do it with the following implementation and it works fine (with GCC 4.7):</p>\n<pre><code>#include &lt;initializer_list&gt;\n\ntemplate&lt;typename T&gt;\nstruct array\n{\n    private:\n\n        const std::size_t _size;\n        const T* _data;\n\n    public:\n\n        constexpr array(std::initializer_list&lt;T&gt; values):\n            _size(values.size()),\n            _data(values.begin())\n        {}\n\n        constexpr auto operator[](std::size_t n)\n            -&gt; T\n        {\n            return _data[n]\n        }\n\n        constexpr auto size() const\n            -&gt; std::size_t;\n        {\n            return _size;\n        }\n};\n</code></pre>\n<p>Even though it works fine for me, I am not sure about the behaviour of <code>std::initializer_list</code> and may use some that are undefined behaviour.</p>\n<p><code>constexpr</code> for <code>std::initializer_list</code> constructor, <code>begin</code> and <code>size</code> is fine even though it is not strictly speaking C++11 since N3471 recently got adopted and made it to the standard.</p>\n<p>Concerning the undefined behaviour, I am not sure whether the underlying array of the <code>std::initializer_list</code> will live or if not, whether there is a mean to have it live longer than only <code>array's</code> constructor. What do you think?</p>\n<p><strong>EDIT:</strong> I may not have been clear, but I do not really care about the actual array. What really interests me is the behaviour of <code>std::initializer_list</code> and its underlying array at compile-time.</p>\n", "PostTypeId": "1", "LastEditorUserId": "1364752", "Id": "15937522", "Score": "2", "OwnerUserId": "1364752", "Tags": "<c++><c++11><compile-time><initializer-list><constexpr>", "AnswerCount": "1"}});