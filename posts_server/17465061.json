post_cb({"17465132": {"ParentId": "17465061", "Score": "0", "CreationDate": "2013-07-04T08:13:26.477", "LastActivityDate": "2013-07-05T08:15:50.850", "LastEditDate": "2013-07-05T08:15:50.850", "OwnerUserId": "323547", "LastEditorUserId": "323547", "Body": "<p>using C is going to be the fastest solution. <strike>Split into tokens using <code>strtok</code> and then </strike> convert to float with <a href=\"http://www.cplusplus.com/reference/cstdlib/strtof/\" rel=\"nofollow\"><code>strtof</code></a>. Or if you know the exact format use <code>fscanf</code>.</p>\n", "Id": "17465132", "PostTypeId": "2", "CommentCount": "1"}, "17465112": {"ParentId": "17465061", "Score": "13", "CreationDate": "2013-07-04T08:12:38.917", "LastActivityDate": "2013-07-04T08:22:07.633", "LastEditDate": "2013-07-04T08:22:07.633", "OwnerUserId": "128645", "LastEditorUserId": "128645", "Body": "<p>Before you start, verify that this is the slow part of your application and get a test harness around it so you can measure improvements.</p>\n<p><code>boost::spirit</code> would be overkill for this in my opinion.  Try <code>fscanf</code></p>\n<pre><code>FILE* f = fopen(\"yourfile\");\nif (NULL == f) {\n   printf(\"Failed to open 'yourfile'\");\n   return;\n}\nfloat x,y,z;\nint nItemsRead = fscanf(f,\"%f %f %f\\n\", &amp;x, &amp;y, &amp;z);\nif (3 != nItemsRead) {\n   printf(\"Oh dear, items aren't in the right format.\\n\");\n   return;\n}\n</code></pre>\n", "Id": "17465112", "PostTypeId": "2", "CommentCount": "8"}, "17465061": {"Tags": "<c++><parsing><boost-spirit>", "ViewCount": "12043", "LastEditDate": "2013-07-04T08:13:26.800", "CreationDate": "2013-07-04T08:10:03.437", "LastEditorUserId": "1136195", "Title": "How to parse space-separated floats in C++ quickly?", "CommentCount": "10", "AcceptedAnswerId": "17465786", "Score": "30", "OwnerUserId": "443878", "Id": "17465061", "LastActivityDate": "2016-11-07T02:35:46.457", "Body": "<p>I have a file with millions of lines, each line has 3 floats separated by spaces. It takes a lot of time to read the file, so I tried to read them using memory mapped files only to find out that the problem is not with the speed of IO but with the speed of the parsing.</p>\n<p>My current parsing is to take the stream (called file) and do the following</p>\n<pre><code>float x,y,z;\nfile &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n</code></pre>\n<p>Someone in Stack Overflow recommended to use Boost.Spirit but I couldn't find any simple tutorial to explain how to use it.</p>\n<p>I'm trying to find a simple and efficient way to parse a line that looks like this:</p>\n<pre><code>\"134.32 3545.87 3425\"\n</code></pre>\n<p>I will really appreciate some help. I wanted to use strtok to split it, but I don't know how to convert strings to floats, and I'm not quite sure it's the best way.</p>\n<p>I don't mind if the solution will be Boost or not. I don't mind if it won't be the most efficient solution ever, but I'm sure that it is possible to double the speed.</p>\n<p>Thanks in advance.</p>\n", "PostTypeId": "1", "FavoriteCount": "22", "AnswerCount": "7"}, "17465786": {"ParentId": "17465061", "Score": "17", "CreationDate": "2013-07-04T08:45:37.390", "LastActivityDate": "2013-07-05T09:05:12.237", "LastEditDate": "2013-07-05T09:05:12.237", "OwnerUserId": "649665", "LastEditorUserId": "649665", "Body": "<p>If the conversion is the bottle neck (which is quite possible),\nyou should start by using the different possiblities in the\nstandard.  Logically, one would expect them to be very close,\nbut practically, they aren't always: </p>\n<ul>\n<li><p>You've already determined that <code>std::ifstream</code> is too slow.</p></li>\n<li><p>Converting your memory mapped data to an <code>std::istringstream</code>\nis almost certainly <em>not</em> a good solution; you'll first have to\ncreate a string, which will copy all of the data.</p></li>\n<li><p>Writing your own <code>streambuf</code> to read directly from the memory,\nwithout copying (or using the deprecated <code>std::istrstream</code>)\nmight be a solution, although if the problem really is the\nconversion... this still uses the same conversion routines. </p></li>\n<li><p>You can always try <code>fscanf</code>, or <code>scanf</code> on your memory mapped\nstream.  Depending on the implementation, they might be faster\nthan the various <code>istream</code> implementations.</p></li>\n<li><p>Probably faster than any of these is to use <code>strtod</code>.  No need\nto tokenize for this: <code>strtod</code> skips leading white space\n(including <code>'\\n'</code>), and has an out parameter where it puts the\naddress of the first character not read.  The end condition is\na bit tricky, your loop should probably look a bit like:</p></li>\n</ul>\n<pre>\n    char* begin;    //  Set to point to the mmap'ed data...\n                    //  You'll also have to arrange for a '\\0'\n                    //  to follow the data.  This is probably\n                    //  the most difficult issue.\n    char* end;\n    errno = 0;\n    double tmp = strtod( begin, &amp;end; );\n    while ( errno == 0 &amp;&amp; end != begin ) {\n        //  do whatever with tmp...\n        begin = end;\n        tmp = strtod( begin, &amp;end; );\n    }\n</pre>\n<p>If none of these are fast enough, you'll have to consider the\nactual data.  It probably has some sort of additional\nconstraints, which means that you can potentially write\na conversion routine which is faster than the more general ones;\ne.g. <code>strtod</code> has to handle both fixed and scientific, and it\nhas to be 100% accurate even if there are 17 significant digits.\nIt also has to be locale specific.  All of this is added\ncomplexity, which means added code to execute.  But beware:\nwriting an efficient and correct conversion routine, even for\na restricted set of input, is non-trivial; you really do have to\nknow what you are doing.</p>\n<p>EDIT:</p>\n<p>Just out of curiosity, I've run some tests.  In addition to the\nafore mentioned solutions, I wrote a simple custom converter,\nwhich only handles fixed point (no scientific), with at most\nfive digits after the decimal, and the value before the decimal\nmust fit in an <code>int</code>:</p>\n<pre><code>double\nconvert( char const* source, char const** endPtr )\n{\n    char* end;\n    int left = strtol( source, &amp;end, 10 );\n    double results = left;\n    if ( *end == '.' ) {\n        char* start = end + 1;\n        int right = strtol( start, &amp;end, 10 );\n        static double const fracMult[] \n            = { 0.0, 0.1, 0.01, 0.001, 0.0001, 0.00001 };\n        results += right * fracMult[ end - start ];\n    }\n    if ( endPtr != nullptr ) {\n        *endPtr = end;\n    }\n    return results;\n}\n</code></pre>\n<p>(If you actually use this, you should definitely add some error\nhandling.  This was just knocked up quickly for experimental\npurposes, to read the test file I'd generated, and <em>nothing</em>\nelse.)</p>\n<p>The interface is exactly that of <code>strtod</code>, to simplify coding.</p>\n<p>I ran the benchmarks in two environments (on different machines,\nso the absolute values of any times aren't relevant).  I got the\nfollowing results:</p>\n<p>Under Windows 7, compiled with VC 11 (/O2):</p>\n<pre><code>Testing Using fstream directly (5 iterations)...\n    6.3528e+006 microseconds per iteration\nTesting Using fscan directly (5 iterations)...\n    685800 microseconds per iteration\nTesting Using strtod (5 iterations)...\n    597000 microseconds per iteration\nTesting Using manual (5 iterations)...\n    269600 microseconds per iteration\n</code></pre>\n<p>Under Linux 2.6.18, compiled with g++ 4.4.2 (-O2, IIRC):</p>\n<pre><code>Testing Using fstream directly (5 iterations)...\n    784000 microseconds per iteration\nTesting Using fscanf directly (5 iterations)...\n    526000 microseconds per iteration\nTesting Using strtod (5 iterations)...\n    382000 microseconds per iteration\nTesting Using strtof (5 iterations)...\n    360000 microseconds per iteration\nTesting Using manual (5 iterations)...\n    186000 microseconds per iteration\n</code></pre>\n<p>In all cases, I'm reading 554000 lines, each with 3 randomly\ngenerated floating point in the range <code>[0...10000)</code>.</p>\n<p>The most striking thing is the enormous difference between\n<code>fstream</code> and <code>fscan</code> under Windows (and the relatively small\ndifference between <code>fscan</code> and <code>strtod</code>).  The second thing is\njust how much the simple custom conversion function gains, on\nboth platforms.  The necessary error handling would slow it down\na little, but the difference is still significant.  I expected\nsome improvement, since it doesn't handle a lot of things the\nthe standard conversion routines do (like scientific format,\nvery, very small numbers, Inf and NaN, i18n, etc.), but not this\nmuch.</p>\n", "Id": "17465786", "PostTypeId": "2", "CommentCount": "4"}, "38254122": {"ParentId": "17465061", "Score": "2", "CreationDate": "2016-07-07T19:49:35.247", "Id": "38254122", "OwnerUserId": "969968", "LastActivityDate": "2016-07-07T19:49:35.247", "Body": "<p>I would check out this related post <a href=\"https://stackoverflow.com/questions/22100662/using-ifstream-to-read-floats/22103121#22103121\">Using ifstream to read floats</a> or <a href=\"https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c/20981311#20981311\">How do I tokenize a string in C++</a> particularly the posts related to C++ String Toolkit Library.  I've used C strtok, C++ streams, Boost tokenizer and the best of them for the ease and use is C++ String Toolkit Library.</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "17479702": {"ParentId": "17465061", "Score": "44", "CreationDate": "2013-07-05T00:49:59.243", "LastActivityDate": "2016-11-07T02:35:46.457", "LastEditDate": "2017-05-23T12:26:19.870", "OwnerUserId": "85371", "LastEditorUserId": "-1", "Body": "<blockquote>\n<h3>UPDATE</h3>\n<p id=\"so_17465061_17479702_0\">Since Spirit X3 is available for testing, I've updated the benchmarks. Meanwhile I've used <a href=\"https://github.com/rmartinho/nonius\" rel=\"nofollow noreferrer\">Nonius</a> to get statistically sound benchmarks.</p>\n<p id=\"so_17465061_17479702_1\">All charts below are available <a href=\"http://stackoverflow-sehe.s3.amazonaws.com/7c513b34-6e06-4115-b3c3-ee040e7b13bd/bench_float_parsing.html\" rel=\"nofollow noreferrer\">interactive online</a></p>\n<p id=\"so_17465061_17479702_2\">Benchmark CMake project + testdata used is on github: <a href=\"https://github.com/sehe/bench_float_parsing\" rel=\"nofollow noreferrer\">https://github.com/sehe/bench_float_parsing</a></p>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/cMKkA.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/cMKkA.png\"/></a></p>\n<h3>Summary:</h3>\n<p>Spirit parsers are fastest. If you can use C++14 consider the experimental version Spirit X3:</p>\n<p><a href=\"https://i.stack.imgur.com/cdKQw.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/cdKQw.png\"/></a></p>\n<p>The above is measures using memory mapped files. Using IOstreams, it will be slower accross the board, </p>\n<p><a href=\"https://i.stack.imgur.com/Sf9Al.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Sf9Al.png\"/></a></p>\n<p>but not as slow as <code>scanf</code> using C/POSIX <code>FILE*</code> function calls:</p>\n<p><a href=\"https://i.stack.imgur.com/wDuBR.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/wDuBR.png\"/></a></p>\n<hr>\n<p>What follows is parts from the OLD answer</p>\n<hr>\n<blockquote>\n<p id=\"so_17465061_17479702_3\">I implemented the Spirit version, and ran a benchmark comparing to the other suggested answers. </p>\n<p id=\"so_17465061_17479702_4\">Here's my results, all tests run on the same body of input (515Mb of <code>input.txt</code>). See below for exact specs.</p>\n<p id=\"so_17465061_17479702_5\"><img src=\"https://i.stack.imgur.com/i1jkm.png\" width=\"200\"/>\n<br/>\n<sup>(wall clock time in seconds, average of 2+ runs)</sup></p>\n<p id=\"so_17465061_17479702_6\">To my own surprise, Boost Spirit turns out to be fastest, and most elegant:</p>\n<ul>\n<li>handles/reports errors</li>\n<li>supports +/-Inf and NaN and variable whitespace</li>\n<li>no problems at all detecting the end of input (as opposed to the other mmap answer)</li>\n<li><p id=\"so_17465061_17479702_7\">looks nice:</p>\n<pre><code>bool ok = phrase_parse(f,l,               // source iterators\n     (double_ &gt; double_ &gt; double_) % eol, // grammar\n     blank,                               // skipper\n     data);                               // output attribute\n</code></pre></li>\n</ul>\n<p id=\"so_17465061_17479702_8\">Note that <code>boost::spirit::istreambuf_iterator</code> was unspeakably much slower (15s+). I hope this helps!</p>\n<h2>Benchmark details</h2>\n<p id=\"so_17465061_17479702_9\">All parsing done into <code>vector</code> of <code>struct float3 { float x,y,z; }</code>.</p>\n<p id=\"so_17465061_17479702_10\">Generate input file using</p>\n<pre><code>od -f -A none --width=12 /dev/urandom | head -n 11000000\n</code></pre>\n<p id=\"so_17465061_17479702_11\">This results in a 515Mb file containing data like</p>\n<pre><code>     -2627.0056   -1.967235e-12  -2.2784738e+33\n  -1.0664798e-27  -4.6421956e-23   -6.917859e+20\n  -1.1080849e+36   2.8909405e-33   1.7888695e-12\n  -7.1663235e+33  -1.0840628e+36   1.5343362e-12\n  -3.1773715e-17  -6.3655537e-22   -8.797282e+31\n    9.781095e+19   1.7378472e-37        63825084\n  -1.2139188e+09  -5.2464635e-05  -2.1235992e-38\n   3.0109424e+08   5.3939846e+30  -6.6146894e-20\n</code></pre>\n<p id=\"so_17465061_17479702_12\">Compile the program using:</p>\n<pre><code>g++ -std=c++0x -g -O3 -isystem -march=native test.cpp -o test -lboost_filesystem -lboost_iostreams\n</code></pre>\n<p id=\"so_17465061_17479702_13\">Measure wall clock time using</p>\n<pre><code>time ./test &lt; input.txt \n</code></pre>\n</blockquote>\n<h2>Environment:</h2>\n<ul>\n<li>Linux desktop 4.2.0-42-generic #49-Ubuntu SMP x86_64</li>\n<li>Intel(R) Core(TM) i7-3770K CPU @ 3.50GHz</li>\n<li>32GiB RAM</li>\n</ul>\n<h2>Full Code</h2>\n<p>Full code to the old benchmark is in the <a href=\"https://stackoverflow.com/revisions/17479702/3\">edit history of this post</a>, the newest version is <a href=\"https://github.com/sehe/bench_float_parsing\" rel=\"nofollow noreferrer\">on github</a></p>\n</hr></hr>", "Id": "17479702", "PostTypeId": "2", "CommentCount": "13"}, "17465207": {"ParentId": "17465061", "Score": "0", "CreationDate": "2013-07-04T08:16:40.867", "LastActivityDate": "2013-07-04T08:44:27.317", "LastEditDate": "2013-07-04T08:44:27.317", "OwnerUserId": "958464", "LastEditorUserId": "958464", "Body": "<p>a nitty-gritty solution would be to throw more cores at the problem, spawning multiple threads.\nIf the bottleneck is just the CPU you can halve down the running time by spawning two threads (on multicore CPUs)</p>\n<p>some other tips:</p>\n<ul>\n<li><p>try to avoid parsing functions from library such boost and/or std. They are bloated with error checking conditions and much of the processing time is spent doing these checks. For just a couple conversions they are fine but fail miserably when it comes to process millions of values. If you already know that your data is well-formatted you can write (or find) a custom optimized C function which does only the data conversion</p></li>\n<li><p>use a large memory buffer (let's say 10 Mbytes) in which you load chunks of your file and do the conversion on there</p></li>\n<li><p>divide et impera: split your problem into smaller easier ones: preprocess your file, make it single line single float, split each line by the \".\" character and convert integers instead of float, then merge the two integers to create the float number</p></li>\n</ul>\n", "Id": "17465207", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_17465061_17479702_13": {"length": 4, "section_id": 6273, "quality": 0.8}}}, "17470745": {"ParentId": "17465061", "Score": "0", "CreationDate": "2013-07-04T12:47:44.460", "Id": "17470745", "OwnerUserId": "558502", "LastActivityDate": "2013-07-04T12:47:44.460", "Body": "<p>I believe one most important rule in the string processing is \"read only once, one character at a time\". It is always simpler, faster and more reliable, I think.</p>\n<p>I made simple benchmark program to show how simple it is. My test says this code runs 40% faster than <code>strtod</code> version.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n\nusing namespace std;\n\nstring test_generate(size_t n)\n{\n    srand((unsigned)time(0));\n    double sum = 0.0;\n    ostringstream os;\n    os &lt;&lt; std::fixed;\n    for (size_t i=0; i&lt;n; ++i)\n    {\n        unsigned u = rand();\n        int w = 0;\n        if (u &gt; UINT_MAX/2)\n            w = - (u - UINT_MAX/2);\n        else\n            w = + (u - UINT_MAX/2);\n        double f = w / 1000.0;\n        sum += f;\n\n        os &lt;&lt; f;\n        os &lt;&lt; \" \";\n    }\n    printf(\"generated %f\\n\", sum);\n    return os.str();\n}\n\nvoid read_float_ss(const string&amp; in)\n{\n    double sum = 0.0;\n    const char* begin = in.c_str();\n    char* end = NULL;\n    errno = 0;\n    double f = strtod( begin, &amp;end );\n    sum += f;\n\n    while ( errno == 0 &amp;&amp; end != begin )\n    {\n        begin = end;\n        f = strtod( begin, &amp;end );\n        sum += f;\n    }\n    printf(\"scanned %f\\n\", sum);\n}\n\ndouble scan_float(const char* str, size_t&amp; off, size_t len)\n{\n    static const double bases[13] = {\n        0.0, 10.0, 100.0, 1000.0, 10000.0,\n        100000.0, 1000000.0, 10000000.0, 100000000.0,\n        1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,\n    };\n\n    bool begin = false;\n    bool fail = false;\n    bool minus = false;\n    int pfrac = 0;\n\n    double dec = 0.0;\n    double frac = 0.0;\n    for (; !fail &amp;&amp; off&lt;len; ++off)\n    {\n        char c = str[off];\n        if (c == '+')\n        {\n            if (!begin)\n                begin = true;\n            else\n                fail = true;\n        }\n        else if (c == '-')\n        {\n            if (!begin)\n                begin = true;\n            else\n                fail = true;\n            minus = true;\n        }\n        else if (c == '.')\n        {\n            if (!begin)\n                begin = true;\n            else if (pfrac)\n                fail = true;\n            pfrac = 1;\n        }\n        else if (c &gt;= '0' &amp;&amp; c &lt;= '9')\n        {\n            if (!begin)\n                begin = true;\n            if (pfrac == 0)\n            {\n                dec *= 10;\n                dec += c - '0';\n            }\n            else if (pfrac &lt; 13)\n            {\n                frac += (c - '0') / bases[pfrac];\n                ++pfrac;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if (!fail)\n    {\n        double f = dec + frac;\n        if (minus)\n            f = -f;\n        return f;\n    }\n\n    return 0.0;\n}\n\nvoid read_float_direct(const string&amp; in)\n{\n    double sum = 0.0;\n    size_t len = in.length();\n    const char* str = in.c_str();\n    for (size_t i=0; i&lt;len; ++i)\n    {\n        double f = scan_float(str, i, len);\n        sum += f;\n    }\n    printf(\"scanned %f\\n\", sum);\n}\n\nint main()\n{\n    const int n = 1000000;\n    printf(\"count = %d\\n\", n);\n\n    string in = test_generate(n);    \n    {\n        struct timeval t1;\n        gettimeofday(&amp;t1, 0);\n        printf(\"scan start\\n\");\n\n        read_float_ss(in);\n\n        struct timeval t2;\n        gettimeofday(&amp;t2, 0);\n        double elapsed = (t2.tv_sec - t1.tv_sec) * 1000000.0;\n        elapsed += (t2.tv_usec - t1.tv_usec) / 1000.0;\n        printf(\"elapsed %.2fms\\n\", elapsed);\n    }\n\n    {\n        struct timeval t1;\n        gettimeofday(&amp;t1, 0);\n        printf(\"scan start\\n\");\n\n        read_float_direct(in);\n\n        struct timeval t2;\n        gettimeofday(&amp;t2, 0);\n        double elapsed = (t2.tv_sec - t1.tv_sec) * 1000000.0;\n        elapsed += (t2.tv_usec - t1.tv_usec) / 1000.0;\n        printf(\"elapsed %.2fms\\n\", elapsed);\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Below is console output from i7 Mac Book Pro (compiled in XCode 4.6).</p>\n<pre><code>count = 1000000\ngenerated -1073202156466.638184\nscan start\nscanned -1073202156466.638184\nelapsed 83.34ms\nscan start\nscanned -1073202156466.638184\nelapsed 53.50ms\n</code></pre>\n</hr>", "PostTypeId": "2", "CommentCount": "3"}});