post_cb({"8501773": {"CommentCount": "7", "Body": "<p><code>delete</code> on an already <code>delete</code>d non-null pointer is undefined behavior - your program will likely crash. You can safely use <code>delete</code> on a null pointer - it will yield a no-op.</p>\n<p>So the real problem is not <code>delete</code> on a null pointer. The real problem is here:</p>\n<pre><code> ptr = new Something();\n otherPtr = ptr;\n delete ptr;\n delete otherPtr;\n</code></pre>\n<p>This can happen if you have several pointers to the same object and it is quite dangerous. The possible solutions are:</p>\n<ul>\n<li>use smart pointers (no <code>delete</code> in your code) or</li>\n<li>only have one designated pointer for controlling each object lifetime and <code>delete</code> at exactly the right time.</li>\n</ul>\n", "CreationDate": "2011-12-14T09:00:31.127", "ParentId": "8501740", "Id": "8501773", "LastActivityDate": "2011-12-14T09:00:31.127", "PostTypeId": "2", "Score": "14", "OwnerUserId": "57428"}, "8501827": {"CommentCount": "0", "Body": "<p>Please note that deleting a pointer does not set it to NULL.</p>\n<pre><code>int* i = new int;\n*i = 42;\ndelete i;\ndelete i; // oops! i is still pointing to the same memory, but it has been deleted already\n</code></pre>\n<p>Deleting a null pointer doesn't do anything, deleting an already deleted object will result in undefined behaviour.</p>\n", "CreationDate": "2011-12-14T09:04:51.637", "ParentId": "8501740", "Id": "8501827", "LastActivityDate": "2011-12-14T09:04:51.637", "PostTypeId": "2", "Score": "1", "OwnerUserId": "280300"}, "8501794": {"CommentCount": "0", "Body": "<p>It results in <strong>Undefined Behavior</strong> if you call <code>delete</code> on already <code>delete</code>d pointer.<br>\nCalling <code>delete</code> on a <code>NULL</code> pointer has no-effect though.</br></p>\n<p><strong>Standard c++03 \u00a7 3.7.4.2-3</strong></p>\n<blockquote>\n<p id=\"so_8501740_8501794_0\">If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect. Otherwise, the value supplied\n  to operator <code>delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new(std::size_t)</code> or <code>operator new(std::size_t, const std::nothrow_-t&amp;)</code> in the standard library, and the value supplied to operator <code>delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](std::size_t)</code> or\n  <code>operator new[](std::size_t, const std::nothrow_t&amp;)</code> in the standard library.</p>\n</blockquote>\n<p>Using <strong>RAII &amp; Smart Pointers</strong> are your best weapons to avoid such problems.</p>\n", "CreationDate": "2011-12-14T09:02:21.700", "ParentId": "8501740", "Id": "8501794", "LastActivityDate": "2011-12-14T09:02:21.700", "PostTypeId": "2", "Score": "0", "OwnerUserId": "452307"}, "8501833": {"CommentCount": "0", "Body": "<p>the right way is: </p>\n<pre><code>if( my_object )\n{\n    delete my_object;\n    my_object = NULL;\n}\n</code></pre>\n<p>because, calling twice the way it was before will call <code>delete</code> on a <code>deleted</code> pointer.</p>\n", "CreationDate": "2011-12-14T09:05:04.663", "ParentId": "8501740", "Id": "8501833", "LastActivityDate": "2011-12-14T09:05:04.663", "PostTypeId": "2", "Score": "1", "OwnerUserId": "672689"}, "bq_ids": {"n4140": {"so_8501740_8501794_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 7182}}, "n3337": {"so_8501740_8501794_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 6926}}}, "8501740": {"FavoriteCount": "2", "ViewCount": "8134", "Id": "8501740", "AcceptedAnswerId": "8501773", "Score": "4", "Title": "Delete on already deleted object : behavior?", "LastEditorUserId": "4370109", "CommentCount": "3", "Body": "<p>I am wondering what will hapen if I try to do a <code>delete</code> on a pointer that is already deleted, or may have not been allocated ? I've read two things : first, that <code>delete</code> operator will do some checkings and we do not need to check if the pointer is null ; and then, I read that it can lead to unknown behaviors..</p>\n<p>I'm asking it, because I use some personal objects that contains Qt objects attributes ; I think that Qt delete all widgets associated when we close the window, but I'm not pretty sure and still : if the soft crash before the window's close, we have to delete all objects manually.</p>\n<p>So, what would be the best solution ? Something like that ?</p>\n<pre><code>if( my_object )\n    delete my_object;\n</code></pre>\n<p>Can it avoid dangerous behaviours ?</p>\n", "Tags": "<c++><pointers><memory-management><delete-operator>", "CreationDate": "2011-12-14T08:58:52.457", "LastEditDate": "2015-08-16T11:11:00.483", "LastActivityDate": "2015-08-16T11:11:00.483", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "1051410"}, "8501851": {"CommentCount": "0", "Body": "<p>Just to combine the answers above:</p>\n<ul>\n<li>if (my_object) checks the value of the pointer, not the existence of the object. If it is already deleted, the pointer may still point to that location.</li>\n<li>deleting an already deleted object is undefined behavior and will probably crash your program.</li>\n<li>deleting NULL is defined and does nothing. Together with point 1 this explains the answer of Luchian.</li>\n</ul>\n<p>To sum it up: You have to be clear on who owns the object and where the different pointer to the object are. When you delete an object, make sure to set all pointer pointing to that location to 0/NULL. Use managing objects like boost::shared_pointer or QPointer to help you in this task.</p>\n", "CreationDate": "2011-12-14T09:06:18.547", "ParentId": "8501740", "Id": "8501851", "LastActivityDate": "2011-12-14T09:06:18.547", "PostTypeId": "2", "Score": "0", "OwnerUserId": "79996"}, "8501768": {"LastActivityDate": "2011-12-14T09:09:58.297", "CreationDate": "2011-12-14T09:00:21.877", "CommentCount": "3", "Body": "<pre><code>if( my_object )\n    delete my_object;\n</code></pre>\n<p>is redundant. <code>delete</code> on a <code>NULL</code> pointer does nothing. This is guaranteed by the standard.</p>\n<p><code>delete</code> on a pointer that was already deleted causes undefined behavior. That's why you should always remember to assign your pointers to <code>NULL</code> after you delete them:</p>\n<pre><code>delete p;\np = NULL;\n</code></pre>\n<p>EDIT: As per the comments, I feel I should specify this. If you have multiple pointers to the same object, the assignment to NULL won't make the delete safe. Regardless, it's better to use smart pointers.</p>\n", "Id": "8501768", "LastEditDate": "2011-12-14T09:09:58.297", "ParentId": "8501740", "OwnerUserId": "673730", "PostTypeId": "2", "Score": "4", "LastEditorUserId": "673730"}});