post_cb({"10689887": {"ParentId": "10689709", "CommentCount": "4", "CreationDate": "2012-05-21T17:36:06.960", "PostTypeId": "2", "Id": "10689887", "Score": "2", "Body": "<p>Type deduction doesn't work for constructors. <code>auto</code> will deduce the type for the expression, yes, but <code>new Handler()</code> requires explicit type. Write a factory function instead:</p>\n<pre><code>// also don't use raw owning pointers\ntemplate &lt;typename L&gt;\nstd::unique_ptr&lt;Handler&lt;L&gt;&gt; make_handler(L lambda) {\n    return std::unique_ptr&lt;Handler&lt;L&gt;&gt;(new Handler&lt;L&gt;(lambda));\n}\n</code></pre>\n<p>Sure, it's repeating yourself a bit, but only once. Then you can do</p>\n<pre><code>auto l1 = make_handler([](...) { ... });\nauto l2 = make_handler([](...) { ... });\n</code></pre>\n<p>and it'll work fine.</p>\n", "OwnerUserId": "16102", "LastActivityDate": "2012-05-21T17:36:06.960"}, "bq_ids": {"n3337": {"so_10689709_10689970_0": {"section_id": 5242, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_10689709_10689970_0": {"section_id": 6875, "quality": 0.5714285714285714, "length": 8}}}, "10689709": {"CommentCount": "1", "AcceptedAnswerId": "10689970", "LastEditDate": "2012-05-21T17:36:42.980", "LastEditorUserId": "636019", "LastActivityDate": "2012-05-21T17:42:18.110", "Body": "<p>I'm trying to understand why this snippet fails:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\ntemplate &lt;typename Lambda&gt;\nstruct Handler\n{\n  bool _isCompleted;\n\n  bool isCompleted() { return _isCompleted; }\n\n  Lambda _l;\n  Handler(Lambda&amp;&amp; l) : _l(l) {}\n\n  void call() { _l(this); }\n};\n\nint main()\n{\n  auto l1 = new Handler( [&amp;](decltype(l1) obj )-&gt;\n{\n  obj-&gt;_isCompleted = true;\n  cout &lt;&lt; \" is completed?\" &lt;&lt; obj-&gt;isCompleted() &lt;&lt; endl;\n});\n  l1-&gt;call();\n};\n</code></pre>\n<p>g++ 4.5 fails with:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:21:17: error: expected type-specifier before \u2018Handler\u2019\ntest.cpp:21:17: error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018Handler\u2019\ntest.cpp:25:2: error: expected primary-expression before \u2018)\u2019 token\ntest.cpp:25:2: error: expected \u2018;\u2019 before \u2018)\u2019 token\ntest.cpp:26:7: error: request for member \u2018call\u2019 in \u2018* l1\u2019, which is of non-class type \u2018int\u2019\n</code></pre>\n<p>my understanding is that <code>auto l1</code> should resolve to <code>Handler&lt;lambdaType&gt;*</code> and lambdaType should have a public function signature <code>void( Handler&lt;LambdaType&gt;*)</code>. I don't see any blatantly wrong with the above example (you know, besides the ugliness and the slightly pathological cyclic dependency between the lambda and the handler type)</p>\n", "PostTypeId": "1", "ViewCount": "626", "Title": "why fails this template parameter inference?", "Id": "10689709", "Score": "1", "CreationDate": "2012-05-21T17:24:14.867", "Tags": "<c++><templates><lambda><c++11><type-inference>", "OwnerUserId": "170521", "AnswerCount": "2"}, "10689970": {"ParentId": "10689709", "CommentCount": "1", "CreationDate": "2012-05-21T17:42:18.110", "PostTypeId": "2", "Id": "10689970", "Score": "5", "Body": "<p>One problem is, as @Cat said, that template argument deduction just does not work for constructor calls. You always need to specify the template argument.</p>\n<p>The other problem is nicely illustrated by Clang with the following snippet:</p>\n<pre><code>struct X{\n  X(...){}\n};\n\nint main(){\n  auto l = X([](decltype(l)&amp; o){});\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>t.cpp:6:26: error: variable 'l' declared with 'auto' type cannot appear in its\n      own initializer\n  auto l = X([](decltype(l)&amp; o){});\n                         ^\n1 error generated.\n</code></pre>\n<p>Obligatory standard quote:</p>\n<p><code>\u00a77.1.6.4 [dcl.spec.auto] p3</code></p>\n<blockquote>\n<p id=\"so_10689709_10689970_0\">Otherwise, the type of the variable is deduced from its initializer. The name of the variable being declared shall not appear in the initializer expression. [...]</p>\n</blockquote>\n", "OwnerUserId": "500104", "LastActivityDate": "2012-05-21T17:42:18.110"}});