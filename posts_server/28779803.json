post_cb({"28779853": {"ParentId": "28779803", "CommentCount": "2", "Body": "<p>The result of <code>a - b</code> is well-defined as C++ guarantees two's complement semantics for them, if I recall correctly. However, the resulting underfklow would be outside the range of <code>signed long long</code> and therefore converting this value to a signed <code>long long</code> will be undefined behaviour.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "28779853", "Score": "-1", "CreationDate": "2015-02-28T08:48:21.287", "LastActivityDate": "2015-02-28T08:48:21.287"}, "28779876": {"ParentId": "28779803", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The subtraction of unsigned values is well-defined by (3.9.1) [basic.fundamental]/4:</p>\n<blockquote>\n<p id=\"so_28779803_28779876_0\">Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.<sup>46</sup></p>\n<p id=\"so_28779803_28779876_1\"><sup>46)</sup> This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n<p>However, the assignment causes <code>c</code> to have an implementation-defined value (that is to say, your mileage may vary). About assignment operators, (5.17) [expr.ass]/3 has to say</p>\n<blockquote>\n<p id=\"so_28779803_28779876_2\">If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualified type of the left operand.</p>\n</blockquote>\n<p>And Clause 4 ([conv]) says in (4.7) [conv.integral]/3 </p>\n<blockquote>\n<p id=\"so_28779803_28779876_3\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); <strong>otherwise, the value is implementation-defined.</strong></p>\n</blockquote>\n<p>To reiterate: <code>a - b</code> is well-defined, <code>c = a - b</code> is not because the result of <code>a - b</code> is not representable by <code>c</code>.</p>\n<p>The historical reason for this is that while today virtually all computers use two's complement representation for signed integers, back in the olden days there were machines that used <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations\" rel=\"nofollow\">other representations</a> (notably one's complement and signed magnitude) that do not have the same value range as two's complement. Had unsigned-to-signed conversion been defined in terms natural for two's complement representation, C++ would have been impossible (or  at least very difficult) to implement on such machines, and had it been defined in terms natural for one of those representations, we'd have a bigger problem today.</p>\n", "OwnerUserId": "4301306", "LastEditorUserId": "4301306", "LastEditDate": "2015-02-28T09:10:51.470", "Id": "28779876", "Score": "6", "CreationDate": "2015-02-28T08:53:05.370", "LastActivityDate": "2015-02-28T09:10:51.470"}, "28779803": {"CommentCount": "2", "AcceptedAnswerId": "28779876", "PostTypeId": "1", "LastEditorUserId": "3425536", "CreationDate": "2015-02-28T08:42:49.993", "LastActivityDate": "2015-02-28T09:10:51.470", "LastEditDate": "2015-02-28T08:47:30.297", "ViewCount": "447", "FavoriteCount": "1", "Title": "Is subtracting larger unsigned value from smaller in C++ undefined behaviour?", "Id": "28779803", "Score": "1", "Body": "<p>In a program below after \"integral promotions\" and \"usual arithmetic conversions\" both operands of operator <code>-</code> remain <code>unsigned long long</code>. Afterwards, C++11 standard says:</p>\n<blockquote>\n<p id=\"so_28779803_28779803_0\">5.7.3 The result of the binary - operator is the difference resulting from the subtraction of the second operand from the first.</p>\n</blockquote>\n<p>Does the standard define anywhere in more detail how exactly the subtraction is performed (or refers to some other document that defines it)?</p>\n<p>Does subtracting a larger unsigned integer from smaller unsigned integer produce an undefined behavior or not and why?</p>\n<p>Does performing an assignment <code>c=a-b</code> as in the example program below guarantee that <code>c</code> will be <code>-3</code> on ALL (even theoretically) possible machine architectures compliant with C++11 standard and why?</p>\n<pre><code>int main()\n{\n    unsigned long long a=2, b=5;\n    signed long long c=a-b;\n}\n</code></pre>\n", "Tags": "<c++><unsigned><signed><subtraction>", "OwnerUserId": "1997715", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28779803_28779876_3": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}, "so_28779803_28779876_1": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}, "so_28779803_28779876_0": {"section_id": 7213, "quality": 0.8125, "length": 13}, "so_28779803_28779876_2": {"section_id": 6175, "quality": 1.0, "length": 12}, "so_28779803_28779803_0": {"section_id": 6140, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_28779803_28779803_0": {"section_id": 5904, "quality": 0.8181818181818182, "length": 9}, "so_28779803_28779876_1": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}, "so_28779803_28779876_0": {"section_id": 6957, "quality": 0.9375, "length": 15}, "so_28779803_28779876_2": {"section_id": 5936, "quality": 1.0, "length": 12}, "so_28779803_28779876_3": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_28779803_28779876_3": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_28779803_28779876_1": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}, "so_28779803_28779876_0": {"section_id": 8722, "quality": 0.8125, "length": 13}, "so_28779803_28779876_2": {"section_id": 7677, "quality": 1.0, "length": 12}, "so_28779803_28779803_0": {"section_id": 7637, "quality": 0.8181818181818182, "length": 9}}}});