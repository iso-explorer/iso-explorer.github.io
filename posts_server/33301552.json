post_cb({"bq_ids": {"n4140": {"so_33301552_33302605_11": {"length": 4, "quality": 0.8, "section_id": 3321}, "so_33301552_33301552_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 90}, "so_33301552_33301552_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 87}, "so_33301552_33302605_10": {"length": 17, "quality": 1.0, "section_id": 6186}, "so_33301552_33302195_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6186}, "so_33301552_33302195_2": {"length": 12, "quality": 0.7058823529411765, "section_id": 6187}, "so_33301552_33302605_1": {"length": 5, "quality": 1.0, "section_id": 87}, "so_33301552_33301552_3": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_33301552_33302195_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 382}, "so_33301552_33301552_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 87}, "so_33301552_33302195_5": {"length": 11, "quality": 1.0, "section_id": 6185}, "so_33301552_33302195_4": {"length": 10, "quality": 1.0, "section_id": 6185}, "so_33301552_33302195_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 87}, "so_33301552_33302605_4": {"length": 13, "quality": 0.5909090909090909, "section_id": 87}, "so_33301552_33301552_7": {"length": 23, "quality": 0.8846153846153846, "section_id": 91}}, "n3337": {"so_33301552_33301552_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 85}, "so_33301552_33301552_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 82}, "so_33301552_33302605_10": {"length": 15, "quality": 0.8823529411764706, "section_id": 5947}, "so_33301552_33302195_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 373}, "so_33301552_33302195_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 5947}, "so_33301552_33302605_1": {"length": 5, "quality": 1.0, "section_id": 82}, "so_33301552_33301552_3": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_33301552_33302605_4": {"length": 16, "quality": 0.7272727272727273, "section_id": 82}, "so_33301552_33301552_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 82}, "so_33301552_33302195_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 5946}, "so_33301552_33302195_4": {"length": 7, "quality": 0.7, "section_id": 5946}, "so_33301552_33302195_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 82}, "so_33301552_33301552_7": {"length": 23, "quality": 0.8846153846153846, "section_id": 86}}, "n4659": {"so_33301552_33302195_3": {"length": 7, "quality": 1.0, "section_id": 7690}, "so_33301552_33302605_10": {"length": 15, "quality": 0.8823529411764706, "section_id": 7689}, "so_33301552_33302605_4": {"length": 20, "quality": 0.9090909090909091, "section_id": 90}, "so_33301552_33301552_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 90}, "so_33301552_33302195_5": {"length": 11, "quality": 1.0, "section_id": 7687}, "so_33301552_33302195_4": {"length": 7, "quality": 0.7, "section_id": 7687}, "so_33301552_33302195_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 90}, "so_33301552_33302195_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 7689}, "so_33301552_33302605_11": {"length": 5, "quality": 1.0, "section_id": 7689}, "so_33301552_33302195_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 7690}}}, "33302195": {"Id": "33302195", "PostTypeId": "2", "Body": "<p>Using the simplified wording introduced by N4268 (and now in the WD), </p>\n<blockquote>\n<p id=\"so_33301552_33302195_0\">A <em>template-argument</em> for a non-type template-parameter <strong>shall be a\n  converted constant expression (5.20) of the type of the <em>template-parameter</em></strong>. For a non-type <em>template-parameter</em> of reference [\u2026] type, the\n  value of the constant expression shall not refer to [\u2026]: [\u2026cases that don't apply\u2026]</p>\n</blockquote>\n<p>\"converted constant expression\" is defined in [expr.const]/4:</p>\n<blockquote>\n<p id=\"so_33301552_33302195_1\">A <em>converted constant expression</em> of type <code>T</code> is an expression,\n  implicitly converted to type <code>T</code>, where the converted expression is a\n  constant expression and the implicit conversion sequence contains\n  only [\u2026] and where the reference binding (if any) binds directly.</p>\n</blockquote>\n<p>Clearly, the reference binds directly. Are <code>x</code> and <code>p</code> constant expressions in this context?</p>\n<p>[expr.const]/5:</p>\n<blockquote>\n<p id=\"so_33301552_33302195_2\">A <em>constant expression</em> is either a glvalue core constant expression\n  whose value refers to an entity that is a permitted result of a\n  constant expression (as defined below), or [\u2026]</p>\n</blockquote>\n<p>A permitted result of a constant expression is defined in the next paragraph as</p>\n<blockquote>\n<p id=\"so_33301552_33302195_3\">\u2026an object with static storage duration that is either not a temporary object or [\u2026]</p>\n</blockquote>\n<p><code>x</code> and <code>p</code> do refer to an object with static storage duration, but are they core constant expressions in the given context? The answer is yes: As long as their <em>value</em> (or the value of the object <code>p</code> refers to) is not examined by the expression, which it isn't, everything's fine, even for <code>p</code>:</p>\n<blockquote>\n<p id=\"so_33301552_33302195_4\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code> [\u2026] would evaluate one of the following expressions:</p>\n<p id=\"so_33301552_33302195_5\">\u2014 an <em>id-expression</em> that refers to a variable or data member of\n  reference type unless the reference has a preceding initialization and\n  either</p>\n<ul>\n<li>it is initialized with a constant expression</li>\n</ul>\n</blockquote>\n<p><code>x</code> as the initializer of <code>p</code> is a constant expression (just as it is a valid template-argument for <code>int&amp;</code>), hence <code>p</code> as the template-argument is a constant expression as well.</p>\n<p>Note that <a href=\"http://melpon.org/wandbox/permlink/1Ev5WcKFEQokx81O\" rel=\"nofollow\">Clang as of version 3.6</a> compiles your snippet fine.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-10-23T12:44:35.160", "Score": "2", "CreationDate": "2015-10-23T12:19:32.237", "ParentId": "33301552", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-10-23T12:44:35.160"}, "33302605": {"Id": "33302605", "PostTypeId": "2", "Body": "<p>This is related to the previous question <a href=\"https://stackoverflow.com/q/27410465/1708801\">template instantiation with constexpr function failure</a> which I linked to a while ago in the comments, although your case is different.</p>\n<p>It looks the example was previously not allowed but support was added in to C++1z via the proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"nofollow noreferrer\">Allow constant evaluation for all non-type template arguments</a> which opens with:</p>\n<blockquote>\n<p id=\"so_33301552_33302605_0\">the syntactic restrictions for pointers, references, and pointers to\n  members are awkward and prevent reasonable refactorings. [...] The\n  historical reason for the restriction was most likely that C++\n  previously did not have a sufficiently strong specification for\n  constant expressions of pointer, reference, or pointer-to-member type.\n  However, that is no longer the case.  [...]</p>\n</blockquote>\n<p>The specific changes that seems relevant to your case is the rewording of the draft C++ standard section <code>14.3.2</code> Template non-type arguments [temp.arg.nontype]/p1 from:</p>\n<blockquote>\n<p id=\"so_33301552_33302605_1\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<p id=\"so_33301552_33302605_2\">[...]</p>\n<ul>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage durationtion\n  and external or internal linkage or a function with external or internal linkage, including function\n  templates and function template-ids but excluding non-static class members, expressed (ignoring parentheses)\n  as &amp; id-expression, where the id-expression is the name of an object or function, except that the\n  &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding\n  template-parameter is a reference; or</li>\n</ul>\n<p id=\"so_33301552_33302605_3\">[...]</p>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_33301552_33302605_4\">A template-argument for a non-type template-parameter shall be a converted constant expression (5.20) of\n  the type of the template-parameter. For a non-type template-parameter of reference or pointer type, the\n  value of the constant expression shall not refer to (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li><p id=\"so_33301552_33302605_5\">a subobject (1.8),</p></li>\n<li><p id=\"so_33301552_33302605_6\">a temporary object (12.2),</p></li>\n<li><p id=\"so_33301552_33302605_7\">a string literal (2.13.5),</p></li>\n<li><p id=\"so_33301552_33302605_8\">the result of a typeid expression (5.2.8), or</p></li>\n<li><p id=\"so_33301552_33302605_9\">a predefined <strong>func</strong> variable (8.4.1).</p></li>\n</ul>\n</blockquote>\n<p>and a change of section <code>5.20</code> Constant expressions [expr.const]/p4 has the following paragraph on converted constant expressions, which starts out:</p>\n<blockquote>\n<p id=\"so_33301552_33302605_10\">A converted constant expression of type T is an expression, implicitly converted to type T, where the converted\n  expression is a constant expression and the implicit conversion sequence contains only</p>\n</blockquote>\n<p>and this in particular was added:</p>\n<blockquote>\n<p id=\"so_33301552_33302605_11\">[...] and where the reference binding (if any) binds directly [...]</p>\n</blockquote>\n<p>Note, the current head version of clang compiles your code in C++1z mode, <a href=\"http://melpon.org/wandbox/permlink/9diCkvKpPBhJ6boQ\" rel=\"nofollow noreferrer\">see it live</a>.</p>\n<p>The updated version of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"nofollow noreferrer\">N4268</a> was the one applied and <a href=\"http://clang.llvm.org/cxx_status.html\" rel=\"nofollow noreferrer\">clang C++1z implementation status section</a> indicates this paper was support from clang 3.6. This code only works in C++1z mode for clang 3.6 and greater.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-24T03:24:01.113", "Score": "3", "CreationDate": "2015-10-23T12:41:44.730", "ParentId": "33301552", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:58:26.140"}, "33301552": {"ViewCount": "377", "Body": "<p>Why is it that the template argument of a non-type reference cannot be another reference (g++ 4.8.1):</p>\n<pre><code>template &lt;int&amp; N&gt; void test() { }\n\nint x = 5;\nint&amp; p = x;\n\nint main(){\n    test&lt;x&gt;(); //compiles fine\n    test&lt;p&gt;(); //error: could not convert template argument 'p' to 'int&amp;'|  \n}\n</code></pre>\n<p>I can't see where from the standard <code>p</code> is violating anything, these seemed the most relevant sections (N3337):</p>\n<blockquote>\n<p id=\"so_33301552_33301552_0\">[14.3.2] [.1] A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<p id=\"so_33301552_33301552_1\">\u2014 for a non-type template-parameter of integral or enumeration type, a converted constant expression (5.19) of the type of the template-parameter; or</p>\n<p id=\"so_33301552_33301552_2\">\u2014 the name of a non-type template-parameter; or</p>\n<p id=\"so_33301552_33301552_3\">\u2014 a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates\n  and function template-ids but excluding non-static class members, expressed (ignoring parentheses) as &amp; id-expression, except that the &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding template-parameter is a reference; or .....</p>\n<p id=\"so_33301552_33301552_4\">[.4] </p>\n<p id=\"so_33301552_33301552_5\">[ Note: Temporaries, unnamed lvalues, and named lvalues with no linkage are not acceptable templatearguments\n  when the corresponding template-parameter has reference type.</p>\n<p id=\"so_33301552_33301552_6\">[.5]</p>\n<p id=\"so_33301552_33301552_7\">\u2014 For a non-type template-parameter of type reference to object, no conversions apply. The type referred\n  to by the reference may be more cv-qualified than the (otherwise identical) type of the templateargument.\n  The template-parameter is bound directly to the template-argument, which shall be an\n  lvalue.</p>\n</blockquote>\n<p><code>p</code> should be considered an lvalue shouldn't it? The only other thing I could think of was maybe a lack of linkage for references but adding <code>extern int&amp; p = x</code> didn't fix it either. </p>\n", "AcceptedAnswerId": "33302605", "Title": "Non-type reference parameter/argument", "CreationDate": "2015-10-23T11:46:52.157", "Id": "33301552", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-10-24T03:24:01.113", "Score": "4", "OwnerUserId": "4338785", "Tags": "<c++><templates><c++11><reference><non-type>", "AnswerCount": "2"}});