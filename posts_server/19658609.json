post_cb({"bq_ids": {"n4140": {"so_19658609_19658743_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3289}, "so_19658609_19658739_2": {"length": 18, "quality": 0.9, "section_id": 7151}, "so_19658609_19658743_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 3285}, "so_19658609_19658743_1": {"length": 4, "quality": 1.0, "section_id": 3285}, "so_19658609_19658739_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7151}}, "n3337": {"so_19658609_19658743_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3159}, "so_19658609_19658739_2": {"length": 18, "quality": 0.9, "section_id": 6895}, "so_19658609_19658743_2": {"length": 7, "quality": 1.0, "section_id": 3155}, "so_19658609_19658743_1": {"length": 4, "quality": 1.0, "section_id": 3155}, "so_19658609_19658739_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6895}}, "n4659": {"so_19658609_19658743_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4051}, "so_19658609_19658739_2": {"length": 14, "quality": 0.7, "section_id": 8652}, "so_19658609_19658743_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 4047}, "so_19658609_19658739_0": {"length": 9, "quality": 0.6, "section_id": 4051}}}, "19658743": {"Id": "19658743", "PostTypeId": "2", "Body": "<p>Yes, the C++03 standard explains in [basic.start.init]:</p>\n<blockquote>\n<p id=\"so_19658609_19658743_0\">Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p>8.5.1 explains:</p>\n<blockquote>\n<p id=\"so_19658609_19658743_1\">To zero-initialize an object of type T means:</p>\n<p id=\"so_19658609_19658743_2\">\u2014 if T is a scalar type (3.9), the object is set to the value of 0 (zero) converted to T;</p>\n<p id=\"so_19658609_19658743_3\">[..]</p>\n</blockquote>\n", "LastActivityDate": "2013-10-29T12:51:26.967", "CommentCount": "0", "CreationDate": "2013-10-29T12:51:26.967", "ParentId": "19658609", "Score": "4", "OwnerUserId": "91757"}, "19658839": {"Id": "19658839", "PostTypeId": "2", "Body": "<p>Your code can cause errors. Linkers usually don't try to deeply understand initialization portions in seperate modules. Try better to provide the variable via static function, for example</p>\n<pre><code>namespace {\n    Foo* the_foo() {\n        static Foo* g_ = new Foo;\n        return g_;\n    }\n}\n</code></pre>\n", "LastActivityDate": "2013-10-29T12:55:55.467", "CommentCount": "2", "CreationDate": "2013-10-29T12:55:55.467", "ParentId": "19658609", "Score": "0", "OwnerUserId": "2932052"}, "19658609": {"ViewCount": "108", "Body": "<p>In file maybe_use_foo.cpp:</p>\n<pre><code>namespace {\n    class Foo { /* ... */ };\n    Foo* const the_foo = new Foo;\n}\n\nvoid funtion_callable_from_another_tu_during_process_wide_initialization() {\n    // If we haven't yet run static initialization for this TU,\n    // but some other static initializer called us, ignore the request.\n    if (!the_foo)\n      return;\n\n    // OK, static initializers for this TU have run, foo exists, use it.\n    the_foo-&gt;doSomething();\n}\n</code></pre>\n<p>So, independently of whether or not the above is advisable, does it always work? It seem to me that it assumes that statics are zero-initialized before the static initialization for the TU runs. Does the C++ standard (C++03? C++11?) guarantee that?</p>\n<p>Another way to ask the question would be to ask what sequence of values, when interpreted as a Foo*, are held in the storage for 'the_foo'. Is it definitely {NULL/nullptr, new Foo}, or is it {undefined, new Foo}, or even something else?</p>\n<p>Please don't suggest other ways of organizing: I'm not looking for suggestions on how to do this better, I'm looking for a deeper understanding of the legality of the technique.</p>\n", "AcceptedAnswerId": "19658739", "Title": "Are file scoped static objects zero initialized before static initialization occurs for the owning translation unit?", "CreationDate": "2013-10-29T12:45:34.313", "Id": "19658609", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-10-29T12:57:23.627", "Score": "3", "OwnerUserId": "776473", "Tags": "<c++><static><initialization><standards>", "AnswerCount": "3"}, "19658739": {"Id": "19658739", "PostTypeId": "2", "Body": "<p>C++11</p>\n<p>[basic.start.init]/2</p>\n<blockquote>\n<p id=\"so_19658609_19658739_0\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n<p id=\"so_19658609_19658739_1\">[...]</p>\n<p id=\"so_19658609_19658739_2\">Together, zero-initialization and constant initialization are called <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n<p>That is, yes, the variables are zero-initialized, but no, they're not zero-initialized <em>before</em> static initialization (but as part of static initialization).</p>\n<hr>\n<p>The function in the OP will only be called during during dynamic initialization, as it is not called during zero-initialization and had to be a <code>constexpr</code> function to be part of constant initialization.</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-10-29T12:57:23.627", "Score": "4", "CreationDate": "2013-10-29T12:51:19.620", "ParentId": "19658609", "CommentCount": "3", "OwnerUserId": "420683", "LastEditDate": "2013-10-29T12:57:23.627"}});