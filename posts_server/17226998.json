post_cb({"17227020": {"ParentId": "17226998", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is fine. According to the C99 specification, for unsigned long operations, <a href=\"http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf\" rel=\"nofollow\">the result is the same but reduced modulo 2<sup>32</sup> (\u00a76.2.5)</a>: </p>\n<pre><code>A computation involving unsigned operands can never over\ufb02ow, because a result \nthat cannot be represented by the resulting unsigned integer type is reduced \nmodulo the number that is one greater than the largest value that can be \nrepresented by the resulting type.\n</code></pre>\n<p>So this behaviour isn't actually \"overflow\", but I'll call it that for simplicity in this answer. Since for modular arithmetic we have</p>\n<pre><code>a1 \u2261 b1 (mod m)\na2 \u2261 b2 (mod m)\n</code></pre>\n<p>implies</p>\n<pre><code>a1 + a2 \u2261 b1 + b2 (mod m)\n</code></pre>\n<p>We have</p>\n<pre><code>Next * a \u2261 k (mod 2^32)\n</code></pre>\n<p>where <code>k</code> is <code>Next * a</code> with \"overflow\". So since <code>M = 2^32</code>, </p>\n<pre><code>Next * a + c \u2261 k + c (mod M)\n</code></pre>\n<p>The result with \"overflow\" is equivalent to the one without \"overflow\" under modular arithmetic, so the formula is fine. Once we reduce modulo <code>M = 2^32</code>, it will give the same result. </p>\n", "OwnerUserId": "1473751", "LastEditorUserId": "1473751", "LastEditDate": "2013-06-21T03:28:34.243", "Id": "17227020", "Score": "3", "CreationDate": "2013-06-21T02:58:47.017", "LastActivityDate": "2013-06-21T03:28:34.243"}, "17226998": {"CommentCount": "1", "ViewCount": "252", "CreationDate": "2013-06-21T02:55:42.673", "LastActivityDate": "2013-06-21T03:28:34.243", "Title": "int multiplication overflow in LCG", "AcceptedAnswerId": "17227020", "PostTypeId": "1", "Id": "17226998", "Score": "2", "Body": "<p>The following is copied from one Opensource project's rand(), it use LCG</p>\n<pre><code>rand_next = rand_next * 1103515245L + 12345L;  //unsigned long rand_next\n</code></pre>\n<p>The classic LCG is:</p>\n<blockquote>\n<p id=\"so_17226998_17226998_0\">Next = (Next * a + c) mod M</p>\n</blockquote>\n<p>Obviously, here M is 2^32.</p>\n<p>what make me confused is rand_next * 1103515245L, where I am pretty sure overflow will occur! I take a look several rand() implementations,  all take this way except using different a and c.</p>\n<p>Is that overflow harmful? if not why?</p>\n<p>Thanks</p>\n", "Tags": "<c++><c><integer-overflow>", "OwnerUserId": "544213", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17226998_17227099_0": {"section_id": 5943, "quality": 1.0, "length": 22}, "so_17226998_17227099_1": {"section_id": 5943, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_17226998_17227099_0": {"section_id": 5714, "quality": 1.0, "length": 22}, "so_17226998_17227099_1": {"section_id": 5714, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_17226998_17227099_0": {"section_id": 7428, "quality": 1.0, "length": 22}, "so_17226998_17227099_1": {"section_id": 7428, "quality": 0.9545454545454546, "length": 21}}}, "17227099": {"ParentId": "17226998", "CommentCount": "0", "Body": "<p>You multiply a <code>signed long</code> with an <code>unsigned long</code>. So, both operands of <code>*</code> have the same integer conversion rank. In this case, the rule below (C++11, \u00a75/9, item 5, sub-item 3) applies:</p>\n<blockquote>\n<p id=\"so_17226998_17227099_0\">[...] if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type.</p>\n</blockquote>\n<p>So both operands are implicitly converted to <code>unsigned long</code> before the multiplication is evaluated. Hence you get unsigned arithmetic and an unsigned result, and the same rule applies again for the addition operation.</p>\n<p>Integer overflow for unsigned is well-defined (see Zong Zhen Li's answer, which has just been expanded to cover this in detail), so there is no problem.</p>\n<hr>\n<p>Regarding C (as opposed to C++), C11 has an identical rule in \u00a76.3.1.8/1:</p>\n<blockquote>\n<p id=\"so_17226998_17227099_1\">[...] if the operand that has unsigned integer type has rank greater or\n  equal to the rank of the type of the other operand, then the operand with\n  signed integer type is converted to the type of the operand with unsigned\n  integer type.</p>\n</blockquote>\n</hr>", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "17227099", "Score": "1", "CreationDate": "2013-06-21T03:09:15.640", "LastActivityDate": "2013-06-21T03:09:15.640"}});