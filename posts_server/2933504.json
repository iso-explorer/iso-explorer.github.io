post_cb({"2933504": {"CommentCount": "3", "ViewCount": "235", "PostTypeId": "1", "LastEditorUserId": "145011", "CreationDate": "2010-05-29T02:21:02.320", "LastActivityDate": "2010-05-29T23:35:11.170", "Title": "Where in the standard is forwarding to a base class required in these situations?", "AcceptedAnswerId": "2933525", "LastEditDate": "2010-05-29T23:35:11.170", "Id": "2933504", "Score": "2", "Body": "<p>Maybe even better is: Why does the standard require forwarding to a base class in these situations? (yeah yeah yeah -  Why? - Because.)  </p>\n<pre><code>class B1 {\npublic:\n    virtual void f()=0;\n};\nclass B2 {\npublic:\n    virtual void f(){}\n};\nclass D : public B1,public B2{\n};\nclass D2 : public B1,public B2{\npublic:\n    using B2::f;\n};\nclass D3 : public B1,public B2{\npublic:\n    void f(){\n        B2::f();\n    }\n};\nD d;\nD2 d2;\nD3 d3;\n</code></pre>\n<p>MS gives:</p>\n<pre><code>sourceFile.cpp\nsourceFile.cpp(24) : error C2259: 'D' : cannot instantiate abstract class\n        due to following members:\n        'void B1::f(void)' : is abstract\n        sourceFile.cpp(6) : see declaration of 'B1::f'\nsourceFile.cpp(25) : error C2259: 'D2' : cannot instantiate abstract class\n        due to following members:\n        'void B1::f(void)' : is abstract\n        sourceFile.cpp(6) : see declaration of 'B\n</code></pre>\n<p>and similarly for the MS compiler.</p>\n<p>I <strong>might</strong> buy the first case,D. But in D2 - f is <strong>unambiguously</strong> defined by the using declaration, why is that not enough for the compiler to be required to fill out the vtable? </p>\n<p>Where in the standard is this situation defined?</p>\n<p><strong>added in reponse to answer</strong></p>\n<p>Regarding the answer below that I have accepted: </p>\n<p>Why does this not seem an error in the spec? - If one has an inheritance hierarchy with a series of non virtual f()'s, the use of which in derived classes being determined by using statements, and one changes the decl of f in a base class to virtual then that can change which f is called in derived classes with using statements to pick their f. It is a c++ \"gotcha\"of which I was unaware. It may be part of the language but such \"action at a distance\" makes me uneasy and to me seems a violation of some sort of correctness / maintenance principle (that I can't quite formulate right now). </p>\n<p>But I can give an example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\n\n\nnamespace NonVirtual_f{\n\nclass C0 {\npublic:\n    void f(){cout&lt;&lt;\"C0::f()\"&lt;&lt;'\\n';}\n};\n\nclass C1 : public C0{\npublic:\n    void f(){cout&lt;&lt;\"C1::f()\"&lt;&lt;'\\n';}\n};\n\nclass C2 : public virtual C1{\npublic:\n    void f(){cout&lt;&lt;\"C2::f()\"&lt;&lt;'\\n';}\n};\n\nclass D3 : public virtual C1, public C2{\npublic:\n    using C1::f;\n};\n\n\n}//namespace NonVirtual_f\n\nnamespace Virtual_f{\n\n\nclass C0 {\npublic:\n    virtual void f(){cout&lt;&lt;\"C0::f()\"&lt;&lt;'\\n';}\n};\n\nclass C1 : public C0{\npublic:\n    void f(){cout&lt;&lt;\"C1::f()\"&lt;&lt;'\\n';}\n};\n\nclass C2 : public virtual C1{\npublic:\n    void f(){cout&lt;&lt;\"C2::f()\"&lt;&lt;'\\n';}\n};\n\nclass D3 : public virtual C1, public C2{\npublic:\n    using C1::f;\n};\n\n\n\n}//namespace Virtual_f\n\n\n\n\nint main(int argc,const char* const*argv){\n\n    NonVirtual_f::D3 nv3;\n    nv3.f();\n\n    Virtual_f::D3 v3;\n    v3.f();\n\n    return 0;    \n} \n</code></pre>\n<p>Whence the output: </p>\n<pre><code>C1::f()\nC2::f()\n</code></pre>\n<p>All that is changed is the virtualness of f in C0. In particular once the non-virtualness of f in a base class is chosen, it cannot be changed without maintenance issues if some derived class (that in general one <strong><em>can't</em></strong> know about) has \"overridden\" as in the example immediately above.</p>\n<p>If you counter with \"Well, do not override that way in the NonVirtual case\", I agree it is bad practice but this seems more than just that. To me the language should:</p>\n<p>not allow the using in NonVirtual::D3 (not possible currently as there may be other overloaded f's to bring in [unless using allowed a signature in the function case]) </p>\n<p><em>or</em> </p>\n<p>disallow using statements of functions completely and force forwarding</p>\n<p><em>or</em> </p>\n<p>have using actually override in all cases</p>\n<p><em>or</em> </p>\n<p>allow some syntactical declarative for functions (essentially a function using) like: </p>\n<pre><code>void f(*signature*) = C2::f;\n</code></pre>\n<p>What, exactly, am I missing here? \nCan someone come up with a scenario that clarifies the \"why\" of this choice in the standard?</p>\n", "Tags": "<c++><override><multiple-inheritance><pure-virtual>", "OwnerUserId": "145011", "AnswerCount": "1"}, "2933525": {"ParentId": "2933504", "CommentCount": "2", "CreationDate": "2010-05-29T02:32:43.377", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "2933525", "Score": "3", "Body": "<p>The C++ standard says in \u00a710.3/2:</p>\n<blockquote>\n<p id=\"so_2933504_2933525_0\">The rules for member lookup (10.2) are used to determine the final overrider for a virtual function in the scope of a derived class but ignoring names introduced by <em>using-declarations</em>.</p>\n</blockquote>\n<p>So, even though you use <code>using B2::f;</code> to bring <code>B2::f()</code> into the derived class, it is not considered to override <code>B1::f()</code>.</p>\n<p>Thus, <code>D2</code> is abstract because of \u00a710.4/4:</p>\n<blockquote>\n<p id=\"so_2933504_2933525_1\">A class is abstract if it contains or inherits at least one pure virtual function for which the final overrider is pure virtual.</p>\n</blockquote>\n", "LastActivityDate": "2010-05-29T02:32:43.377"}, "bq_ids": {"n4140": {"so_2933504_2933525_1": {"section_id": 7021, "quality": 1.0, "length": 13}}, "n3337": {"so_2933504_2933525_1": {"section_id": 6767, "quality": 1.0, "length": 13}}, "n4659": {"so_2933504_2933525_1": {"section_id": 8518, "quality": 1.0, "length": 13}}}});