post_cb({"8219674": {"ParentId": "8219525", "LastEditDate": "2013-01-17T00:05:30.033", "CommentCount": "8", "CreationDate": "2011-11-21T22:52:14.980", "OwnerUserId": "845092", "LastEditorUserId": "845092", "PostTypeId": "2", "Id": "8219674", "Score": "7", "Body": "<p>No, <code>std::sort</code> from the C++ Standard Library is not allowed to do a binary copy on objects with non-trivial copy/assignment operators.  I don't see why it can't do binary copies on objects with trivial copy/assignment operators though.  Consider this object:</p>\n<pre><code>class Explosive {\n    Explosive* const self;\npublic:\n    Explosive() :self(this) {}\n    Explosive(const Explosive&amp;) :self(this) {}\n    ~Explosive() {assert(this==self);}\n    Explosive&amp; operator=(const Explosive&amp; rhs) {\n        assert(this==self &amp;&amp; rhs.self==&amp;rhs); \n        return *this;\n    }\n    bool operator&lt;(const Explosive&amp; rhs) const \n    {return std::less&lt;Explosive*&gt;(self,rhs.self);}\n};\n</code></pre>\n<p>The C++ algorithms are guaranteed to not set off either assert, which means a binary copy would not be valid.</p>\n", "LastActivityDate": "2013-01-17T00:05:30.033"}, "bq_ids": {"n4140": {"so_8219525_8219718_2": {"section_id": 6279, "quality": 0.8947368421052632, "length": 17}, "so_8219525_8219718_0": {"section_id": 1401, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_8219525_8219718_2": {"section_id": 6039, "quality": 0.8947368421052632, "length": 17}, "so_8219525_8219718_0": {"section_id": 1395, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_8219525_8219718_2": {"section_id": 7786, "quality": 0.8947368421052632, "length": 17}, "so_8219525_8219718_0": {"section_id": 1518, "quality": 0.6666666666666666, "length": 10}}}, "8219718": {"ParentId": "8219525", "LastEditDate": "2011-11-21T23:37:31.150", "CommentCount": "3", "CreationDate": "2011-11-21T22:56:19.017", "OwnerUserId": "85371", "LastEditorUserId": "85371", "PostTypeId": "2", "Id": "8219718", "Score": "3", "Body": "<p>I've seen before that <code>std::copy</code> employs <code>memmove</code> in GNU libstdc++, depending on whether the element type <strike>is POD</strike> <code>has_trivial_assignment_operator</code>. See the <a href=\"http://www.aoc.nrao.edu/php/tjuerges/ALMA/STL/html-3.4.6/stl__algobase_8h-source.html#l00256\" rel=\"nofollow\">source here</a>:</p>\n<pre><code>template&lt;typename _Tp&gt;\n   inline _Tp*\n   __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)\n   {\n      std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n      return __result + (__last - __first);\n   }\n</code></pre>\n<p>At least in SGI, <code>rotate</code>, <code>reverse</code>, <code>swap_ranges</code>, <code>random_shuffle</code>, <code>partition</code>, <code>next_permutation</code> all employ <code>swap</code>.</p>\n<p>See <a href=\"http://www.sgi.com/tech/stl/stl_algo.h\" rel=\"nofollow\">http://www.sgi.com/tech/stl/stl_algo.h</a></p>\n<p>Also, the c++11 standard doc for <code>std::sort</code> specificly mentions in \u00a7 25.4.1.1:</p>\n<blockquote>\n<p id=\"so_8219525_8219718_0\"><em>Requires</em>: <code>RandomAccessIterator</code> shall satisfy the requirements of <code>ValueSwappable</code> (17.6.3.2). The type of <code>*first</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 20) and of <code>MoveAssignable</code>\n  (Table 22).</p>\n</blockquote>\n<p>Now \u00a7 17.6.3.2 contains this:</p>\n<blockquote>\n<p id=\"so_8219525_8219718_1\">An object t is swappable with an object u if and only if:</p>\n<ul>\n<li>the expressions <code>swap(t, u)</code> and <code>swap(u, t)</code> are valid when evaluated in the context described below, and</li>\n<li>these expressions have the following effects:\n  <ul>\n<li>the object referred to by t has the value originally held by u and</li>\n<li>the object referred to by u has the value originally held by t.</li>\n</ul></li>\n</ul>\n<p id=\"so_8219525_8219718_2\">The context in which <code>swap(t, u)</code> and <code>swap(u, t)</code> are evaluated shall ensure that a binary non-member function named \u201cswap\u201d is selected via overload resolution (13.3) on a candidate set that includes:</p>\n<ul>\n<li>the two swap function templates defined in  (20.2) and</li>\n<li>the lookup set produced by argument-dependent lookup (3.4.2).</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2011-11-21T23:37:31.150"}, "8219525": {"CommentCount": "9", "CreationDate": "2011-11-21T22:38:30.903", "PostTypeId": "1", "AcceptedAnswerId": "8221565", "LastEditorUserId": "244941", "LastActivityDate": "2013-01-17T00:05:30.033", "LastEditDate": "2011-11-21T23:13:32.467", "ViewCount": "2046", "FavoriteCount": "1", "Title": "Does STL sort use swap or binary copy?", "Id": "8219525", "Score": "10", "Body": "<p>I'm having trouble finding a good answer to this. For some reason I thought STL sort would be implemented using swap for better support of complicated types, but as I ended up digging through the code a bit it appears it is actually doing a binary copy. Can someone confirm this? I guess binary copy would actually be preferred to swap.</p>\n<p><em>Side Question</em>: Are any of the STL algorithms or container operations implemented using swap? (Outside of <code>std::swap</code> obviously.) I want to be aware of when it is prudent to implement my own swap for complicated types.</p>\n<p>Edit: Reason I'm asking is if you have something like:</p>\n<pre><code>class MyClass {\n  vector&lt;int&gt; vec_data;\n  int a;\n  int b;\n}\nvector&lt;MyClass&gt; my_vec;\nsort(my_vec.begin(), my_vec.end(), MyCustomCompare);\n</code></pre>\n<p>I want to make sure the sort isn't calling the copy constructor of the vector, which would happen if you called the default Copy constructor of MyData. Hence my question is sort calling swap, copy assign, etc?</p>\n", "Tags": "<c++><sorting><stl><swap>", "OwnerUserId": "244941", "AnswerCount": "4"}, "8221565": {"ParentId": "8219525", "LastEditDate": "2011-11-28T22:19:08.783", "CommentCount": "1", "CreationDate": "2011-11-22T03:19:40.687", "OwnerUserId": "1059005", "LastEditorUserId": "1059005", "PostTypeId": "2", "Id": "8221565", "Score": "3", "Body": "<p>It depends on your STL implementation.  The <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.6/a01187.html#ga2056c15a25b660ed3f0004199e11dd40\" rel=\"nofollow\">GCC STL implementation</a> uses a combination of introsort and insertion sort.  It appears that <code>std::swap</code> (or your specialization) will be invoked in the introsort loop, but it will not be invoked by the insertion sort.</p>\n<p>If you don't have a specialization of <code>std::swap</code>, then the default <code>std::swap</code> implementation will use a temporary copy to implement swap.</p>\n<p>It does not use binary copy (except for some POD types, which may have specializations hidden deep within the STL libraries).</p>\n<p>Also, in C++0x, it seems likely that the insertion sort will use move semantics (rvalue references).</p>\n", "LastActivityDate": "2011-11-28T22:19:08.783"}, "8219611": {"ParentId": "8219525", "CommentCount": "3", "Body": "<p>It swaps, but since it's a template function it might inline the swapping code. The compiler can choose to do a binary swap as an optimization if it's a simple type.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "8219611", "Score": "2", "CreationDate": "2011-11-21T22:46:33.577", "LastActivityDate": "2011-11-21T22:46:33.577"}});