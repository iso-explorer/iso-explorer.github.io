post_cb({"27806748": {"ParentId": "27806504", "CommentCount": "2", "CreationDate": "2015-01-06T20:35:32.160", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "27806748", "Score": "0", "Body": "<p>The compiler is looking for a <code>Swap(int&amp;, double&amp;)</code>, because you supplied an <code>int</code> as the first parameter and a <code>double</code> as the second and it can't find one.  </p>\n<p>You could perform the following:  </p>\n<pre><code>int a = 5;\ndouble b = 10.3;\ndouble c = a * 1.0;\nSwap&lt;double&gt;(a, c);\n</code></pre>\n<p>Essentially, you declared a function that wants references to two <code>double</code>s.  When the compiler converts an <code>int</code> to a <code>double</code>, it creates a temporary.  You function doesn't want a temporary, because it may modify the value (which is what the reference means).  </p>\n<p><strong>Also, does it make sense to swap an integer with a floating point?</strong></p>\n", "LastActivityDate": "2015-01-06T20:35:32.160"}, "27806504": {"CommentCount": "12", "ViewCount": "699", "PostTypeId": "1", "LastEditorUserId": "1777235", "CreationDate": "2015-01-06T20:16:05.843", "LastActivityDate": "2015-01-06T21:40:34.207", "Title": "cannot convert 'a' (type 'int') to type 'double&", "LastEditDate": "2015-01-06T20:42:57.500", "Id": "27806504", "Score": "3", "Body": "<p>I'm following some C++ tutorials, and frustratingly, the source material states this particular function call cannot be made, but doesn't at all explain why;</p>\n<pre><code>template&lt;typename T&gt;\nvoid Swap(T &amp;a, T &amp;b){\n\n    T temp;\n    temp = a;\n    a = b;\n    b = temp;\n\n}\n</code></pre>\n<p>So now I create an explicit template function instantiation and pass in <code>a</code> and <code>b</code>;</p>\n<pre><code>int a = 5;\ndouble b = 10.3;\n\nSwap&lt;double&gt;(a, b);\n</code></pre>\n<p>Which then throws the following compiler error;</p>\n<blockquote>\n<p id=\"so_27806504_27806504_0\">cannot convert 'a' (type 'int') to type 'double&amp;'</p>\n</blockquote>\n<p>My only hunch is that this is because of the rule that states an rvalue can't be bound to a non-const reference, however, if <code>T &amp;a</code> is just an alias, it's not an rvalue itself, is it? My implicit cast is creating a temporary, which it can't bind to <code>T &amp;a</code>? Is that what's happening?</p>\n<p><code>temp</code> is an lvalue. It may only have function scope, but it does exist. So why wouldn't it allow the implicit cast to double, then assign the reference a to <code>temp</code>? The intention looks pretty clear. I don't quite understand references as parameters. If <code>a</code> is getting assigned to temp, which is an lvalue, then wouldn't this be allowed?</p>\n<p>That's assuming I'm even on the right track here.</p>\n<p><strong>Edit:</strong></p>\n<p>A second example;</p>\n<pre><code>int a = 5;\ndouble &amp;d = a; // invalid initialization of reference of type 'double&amp;' from expression of type 'int'\n</code></pre>\n<p>However;</p>\n<pre><code>int a = 5;\nconst double &amp;d = a; //valid\n</code></pre>\n", "Tags": "<c++><templates><casting>", "OwnerUserId": "1777235", "AnswerCount": "3"}, "27806823": {"ParentId": "27806504", "CommentCount": "1", "CreationDate": "2015-01-06T20:41:10.227", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "27806823", "Score": "3", "Body": "<p>What you're trying to do is effectively:</p>\n<pre><code>int a = 5;\ndouble&amp; dr = a;\n</code></pre>\n<p>The rules that govern reference initialization in the standard are in \u00a78.5.3. First, some definitions:</p>\n<blockquote>\n<p id=\"so_27806504_27806823_0\">(4) Given types \u201c<em>cv1</em> <code>T1</code>\u201d and \u201c<em>cv2</em> <code>T2</code>,\u201d \u201c<em>cv1</em> <code>T1</code>\u201d is <em>reference-related</em> to \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code>, or <code>T1</code> is a base class of <code>T2</code>. \u201c<em>cv1</em> <code>T1</code>\u201d is <em>reference-compatible</em> with \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is <em>reference-related</em> to <code>T2</code> and <em>cv1</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>.</p>\n</blockquote>\n<p>Then, we have:</p>\n<blockquote>\n<p id=\"so_27806504_27806823_1\">(5) A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression\n  <ul>\n<li>is an lvalue (but is not a bit-field), and \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>,\u201d</li>\n<li>..</li>\n</ul></li>\n</ul>\n<p id=\"so_27806504_27806823_2\">then the reference is bound to the initializer expression lvalue in the first case and to the lvalue result of the conversion in the second case</p>\n<p id=\"so_27806504_27806823_3\">\u2014 Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference.</p>\n</blockquote>\n<p>The \"then\" case does not apply, since <code>int</code> is not reference-compatible with <code>double</code>. So we go to the other case, which states that the result should be an <em>rvalue</em> reference. That is, the reference shall be either:</p>\n<pre><code>const double&amp; dcr = a; // lvalue reference to a non-volatile const type\ndouble&amp;&amp; drr = a;      // rvalue reference\n</code></pre>\n<p>But that is not what your code is doing - hence the error. In fact, what you want to do is explicitly mentioned in the standard as a counter-example in the same bullet point:</p>\n<pre><code>int i = 2;\ndouble&amp; rd3 = i; // error: type mismatch and reference not const\n</code></pre>\n", "LastActivityDate": "2015-01-06T20:41:10.227"}, "bq_ids": {"n4140": {"so_27806504_27806823_1": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_27806504_27806504_0": {"section_id": 91, "quality": 0.6666666666666666, "length": 4}, "so_27806504_27806823_3": {"section_id": 3321, "quality": 0.9166666666666666, "length": 11}, "so_27806504_27806823_0": {"section_id": 3320, "quality": 0.5454545454545454, "length": 12}, "so_27806504_27806823_2": {"section_id": 3321, "quality": 1.0, "length": 13}}, "n3337": {"so_27806504_27806823_1": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_27806504_27806504_0": {"section_id": 86, "quality": 0.6666666666666666, "length": 4}, "so_27806504_27806823_3": {"section_id": 3191, "quality": 0.9166666666666666, "length": 11}, "so_27806504_27806823_0": {"section_id": 3190, "quality": 0.5454545454545454, "length": 12}, "so_27806504_27806823_2": {"section_id": 3191, "quality": 1.0, "length": 13}}, "n4659": {"so_27806504_27806823_1": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_27806504_27806504_0": {"section_id": 3983, "quality": 0.6666666666666666, "length": 4}, "so_27806504_27806823_3": {"section_id": 4087, "quality": 0.9166666666666666, "length": 11}, "so_27806504_27806823_0": {"section_id": 4086, "quality": 0.5454545454545454, "length": 12}, "so_27806504_27806823_2": {"section_id": 4087, "quality": 1.0, "length": 13}}}, "27806710": {"ParentId": "27806504", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-01-06T20:32:14.773", "Score": "5", "LastEditorUserId": "25507", "LastEditDate": "2015-01-06T21:40:34.207", "Id": "27806710", "OwnerUserId": "25507", "Body": "<p>Intuitively, swapping <code>a</code> and <code>b</code> should work, because the compiler can convert between <code>int</code> and <code>double</code>. In practice, though, think about what the compiler has to do in order to do what you're asking.</p>\n<p>You start with a template:</p>\n<pre><code>template&lt;typename T&gt;\nvoid Swap(T &amp;a, T &amp;b){\n    T temp = a;\n    a = b;\n    b = temp;\n}\n</code></pre>\n<p>To instantiate it for <code>double</code>, the compiler creates a function something like this:</p>\n<pre><code>void Swap(double&amp; a, double&amp; b) {\n    double temp = a;\n    a = b;\n    b = temp;\n}\n</code></pre>\n<p>Those are <em>reference</em> parameters - they point to actual locations in memory, rather than being aliases or copies.  Under the hood, a reference behaves like a pointer, so you can think of your function similarly to this, if it helps:</p>\n<pre><code>void Swap(double* a, double *b);\n</code></pre>\n<p>In other words, <code>Swap</code> needs references (pointers) to two in-memory doubles - two 8-byte sections of memory (assuming a double takes 8 bytes).  As intelligent and intuitive humans, we know that <code>Swap</code>'s implementation doesn't really <em>need</em> two 8-byte sections of memory, but that's how it's declared, and so that's how the compiler enforces it.</p>\n<p>To make a version of Swap that can handle mixed arguments, you'd have to do something like this:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nvoid Swap(T1&amp; a, T2&amp; b) {\n    T1 tmp(a);\n    a = b;\n    b = tmp;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/LApyjz\" rel=\"nofollow\">Demo.</a></p>\n", "LastActivityDate": "2015-01-06T21:40:34.207"}});