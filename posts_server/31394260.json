post_cb({"31394260": {"CommentCount": "15", "AcceptedAnswerId": "31735126", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-07-13T22:04:30.237", "LastActivityDate": "2017-02-23T13:23:34.617", "LastEditDate": "2017-05-23T12:32:29.713", "ViewCount": "1002", "FavoriteCount": "7", "Title": "Template partial ordering - why does partial deduction succeed here", "Id": "31394260", "Score": "18", "Body": "<p>Consider the following simple (to the extent that template questions ever are) example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct identity;\n\ntemplate &lt;&gt;\nstruct identity&lt;int&gt; {\n    using type = int;\n};\n\ntemplate&lt;typename T&gt; void bar(T, T ) { std::cout &lt;&lt; \"a\\n\"; }\ntemplate&lt;typename T&gt; void bar(T, typename identity&lt;T&gt;::type) { std::cout &lt;&lt; \"b\\n\"; }\n\nint main ()\n{\n    bar(0, 0);\n}\n</code></pre>\n<p>Both clang and gcc print \"a\" there. According to the rules in [temp.deduct.partial] and [temp.func.order], to determine partial ordering, we need to synthesize some unique types. So we have two attempts at deduction: </p>\n<pre><code>+---+-------------------------------+-------------------------------------------+\n|   | Parameters                    | Arguments                                 |\n+---+-------------------------------+-------------------------------------------+\n| a | T, typename identity&lt;T&gt;::type | UniqueA, UniqueA                          |\n| b | T, T                          | UniqueB, typename identity&lt;UniqueB&gt;::type |\n+---+-------------------------------+-------------------------------------------+\n</code></pre>\n<p>For deduction on \"b\", according to <a href=\"https://stackoverflow.com/a/1193395/2069064\">Richard Corden's answer</a>, the expression <code>typename identity&lt;UniqueB&gt;::type</code> is treated as a type and is not evaluated. That is, this will be synthesized as if it were:</p>\n<pre><code>+---+-------------------------------+--------------------+\n|   | Parameters                    | Arguments          |\n+---+-------------------------------+--------------------+\n| a | T, typename identity&lt;T&gt;::type | UniqueA, UniqueA   |\n| b | T, T                          | UniqueB, UniqueB_2 |\n+---+-------------------------------+--------------------+\n</code></pre>\n<p>It's clear that deduction on \"b\" fails. Those are two different types so you cannot deduce <code>T</code> to both of them.</p>\n<p>However, it seems to me that the deduction on <code>A</code> should fail. For the first argument, you'd match <code>T == UniqueA</code>. The second argument is a non-deduced context - so wouldn't that deduction succeed iff <code>UniqueA</code> were convertible to <code>identity&lt;UniqueA&gt;::type</code>? The latter is a substitution failure, so I don't see how this deduction could succeed either. </p>\n<p>How and why do gcc and clang prefer the \"a\" overload in this scenario?</p>\n", "Tags": "<c++><templates><language-lawyer><overload-resolution><partial-ordering>", "OwnerUserId": "2069064", "AnswerCount": "2"}, "31558990": {"ParentId": "31394260", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>I believe the key is with the following statement:</p>\n<blockquote>\n<p id=\"so_31394260_31558990_0\">The second argument is a non-deduced context - so wouldn't that deduction succeed iff UniqueA were convertible to identity::type? </p>\n</blockquote>\n<p>Type deduction does not perform checking of \"conversions\".  Those checks take place using the real explicit and deduced arguments as part of overload resolution.</p>\n<p>This is my summary of the steps that are taken to select the function template to call (all references taken from N3937, ~ C++ '14):</p>\n<ol>\n<li>Explicit arguments are replaced and the resulting function type checked that it is valid. (14.8.2/2)</li>\n<li>Type deduction is performed and the resulting deduced arguments are replaced.  Again the resulting type must be valid. (14.8.2/5)</li>\n<li>The function templates that succeeded in Steps 1 and 2 are specialized and included in the overload set for overload resolution. (14.8.3/1)</li>\n<li>Conversion sequences are compared by overload resolution. (13.3.3)</li>\n<li>If the conversion sequences of two function specializations are not 'better' the partial ordering algorithm is used to find the more specialized function template. (13.3.3)</li>\n<li>The partial ordering algorithm checks only that type deduction succeeds. (14.5.6.2/2)</li>\n</ol>\n<p>The compiler already knows by step 4 that both specializations can be called when the real arguments are used.  Steps 5 and 6 are being used to determine which of the functions is more specialized.</p>\n", "OwnerUserId": "11698", "LastEditorUserId": "11698", "LastEditDate": "2015-07-22T13:32:14.380", "Id": "31558990", "Score": "5", "CreationDate": "2015-07-22T09:21:14.663", "LastActivityDate": "2015-07-22T13:32:14.380"}, "31735126": {"ParentId": "31394260", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As discussed in the comments, I believe there are several aspects of the function template partial ordering algorithm that are unclear or not specified at all in the standard, and this shows in your example.</p>\n<p>To make things even more interesting, MSVC (I tested 12 and 14) rejects the call as ambiguous. I don't think there's anything in the standard to conclusively prove which compiler is right, but I think I might have a clue about where the difference comes from; there's a note about that below.</p>\n<p>Your question (and <a href=\"https://stackoverflow.com/q/31497357/4326278\">this one</a>) challenged me to do some more investigation into how things work. I decided to write this answer not because I consider it authoritative, but rather to organize the information I have found in one place (it wouldn't fit in comments). I hope it will be useful.</p>\n<hr>\n<p>First, the proposed resolution for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1391\" rel=\"nofollow noreferrer\">issue 1391</a>. We discussed it extensively in comments and chat. I think that, while it does provide some clarification, it also introduces some issues. It changes [14.8.2.4p4] to (new text in bold):</p>\n<blockquote>\n<p id=\"so_31394260_31735126_0\">Each type nominated above from the parameter template and the\n  corresponding type from the argument template are used as the types of\n  <code>P</code> and <code>A</code>. <strong>If a particular <code>P</code> contains no <em>template-parameters</em> that\n  participate in template argument deduction, that <code>P</code> is not used to\n  determine the ordering.</strong></p>\n</blockquote>\n<p>Not a good idea in my opinion, for several reasons:</p>\n<ul>\n<li>If <code>P</code> is non-dependent, it doesn't contain any template parameters at all, so it doesn't contain any that participate in argument deduction either, which would make the bold statement apply to it. However, that would make <code>template&lt;class T&gt; f(T, int)</code> and <code>template&lt;class T, class U&gt; f(T, U)</code> unordered, which doesn't make sense. This is arguably a matter of interpretation of the wording, but it could cause confusion.</li>\n<li>It messes with the notion of <em>used to determine the ordering</em>, which affects [14.8.2.4p11]. This makes <code>template&lt;class T&gt; void f(T)</code> and <code>template&lt;class T&gt; void f(typename A&lt;T&gt;::a)</code> unordered (deduction succeeds from first to second, because <code>T</code> is not used in a type used for partial ordering according to the new rule, so it can remain without a value). Currently, all compilers I've tested report the second as more specialized.</li>\n<li><p>It would make <code>#2</code> more specialized than <code>#1</code> in the following example: </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt; struct A { using a = T; };\n\nstruct D { };\ntemplate&lt;class T&gt; struct B { B() = default; B(D) { } };\ntemplate&lt;class T&gt; struct C { C() = default; C(D) { } };\n\ntemplate&lt;class T&gt; void f(T, B&lt;T&gt;) { std::cout &lt;&lt; \"#1\\n\"; } // #1\ntemplate&lt;class T&gt; void f(T, C&lt;typename A&lt;T&gt;::a&gt;) { std::cout &lt;&lt; \"#2\\n\"; } // #2\n\nint main()\n{\n   f&lt;int&gt;(1, D());\n}\n</code></pre>\n<p>(<code>#2</code>'s second parameter is not used for partial ordering, so deduction succeeds from <code>#1</code> to <code>#2</code> but not the other way around). Currently, the call is ambiguous, and should arguably remain so.</p></li>\n</ul>\n<hr>\n<p>After looking at Clang's implementation of the partial ordering algorithm, here's how I think the standard text could be changed to reflect what actually happens. </p>\n<p>Leave [p4] as it is and add the following between [p8] and [p9]:</p>\n<blockquote>\n<p id=\"so_31394260_31735126_1\">For a <code>P</code> / <code>A</code> pair:</p>\n<ul>\n<li>If <code>P</code> is non-dependent, deduction is considered successful if and only if <code>P</code> and <code>A</code> are the same type.</li>\n<li>Substitution of deduced template parameters into the non-deduced contexts appearing in <code>P</code> is not performed and does not affect the outcome of the deduction process.</li>\n<li>If template argument values are successfully deduced for all template parameters of <code>P</code> except the ones that appear only in non-deduced contexts, then deduction is considered successful (even if some parameters used in <code>P</code> remain without a value at the end of the deduction process for that particular <code>P</code> / <code>A</code> pair).</li>\n</ul>\n</blockquote>\n<p>Notes:</p>\n<ul>\n<li>About the second bullet point: [14.8.2.5p1] talks about finding template argument values <em>that will make <code>P</code>, after substitution of the deduced values (call it the deduced <code>A</code>), compatible with <code>A</code></em>. This could cause confusion about what actually happens during partial ordering; there's no substitution going on.</li>\n<li>MSVC doesn't seem to implement the third bullet point in some cases. See the next section for details.</li>\n<li>The second and third bullet points are intented to also cover cases where <code>P</code> has forms like <code>A&lt;T, typename U::b&gt;</code>, which aren't covered by the wording in issue 1391.</li>\n</ul>\n<p>Change the current [p10] to:</p>\n<blockquote>\n<p id=\"so_31394260_31735126_2\">Function template <code>F</code> is at least as specialized as function template\n  <code>G</code> if and only if:</p>\n<ul>\n<li>for each pair of types used to determine the ordering, the type from <code>F</code> is at least as specialized as the type from <code>G</code>, and,</li>\n<li>when performing deduction using the transformed <code>F</code> as the argument template and <code>G</code> as the parameter template, after deduction is done\n  for all pairs of types, all template parameters used in the types from\n  <code>G</code> that are used to determine the ordering have values, and those\n  values are consistent across all pairs of types.</li>\n</ul>\n<p id=\"so_31394260_31735126_3\"><code>F</code> <em>is more specialized</em> than <code>G</code> if <code>F</code> is at least as specialized\n  as <code>G</code> and <code>G</code> is not at least as specialized as <code>F</code>.</p>\n</blockquote>\n<p>Make the entire current [p11] a note.</p>\n<p>(The note added by the resolution of 1391 to [14.8.2.5p4] needs to be adjusted as well - it's fine for [14.8.2.1], but not for [14.8.2.4].)</p>\n<hr>\n<p>For MSVC, in some cases, it looks like all template parameters in <code>P</code> need to receive values during deduction <em>for that specific <code>P</code> / <code>A</code> pair</em> in order for deduction to succeed from <code>A</code> to <code>P</code>. I think this could be what causes implementation divergence in your example and others, but I've seen at least one case where the above doesn't seem to apply, so I'm not sure what to believe.</p>\n<p>Another example where the statement above does seem to apply: changing <code>template&lt;typename T&gt; void bar(T, T)</code> to <code>template&lt;typename T, typename U&gt; void bar(T, U)</code> in your example swaps results around: the call is ambiguous in Clang and GCC, but resolves to <code>b</code> in MSVC.</p>\n<p>One example where it doesn't:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt; struct A { using a = T; };\ntemplate&lt;class, class&gt; struct B { };\n\ntemplate&lt;class T, class U&gt; void f(B&lt;U, T&gt;) { std::cout &lt;&lt; \"#1\\n\"; }\ntemplate&lt;class T, class U&gt; void f(B&lt;U, typename A&lt;T&gt;::a&gt;) { std::cout &lt;&lt; \"#2\\n\"; }\n\nint main()\n{\n   f&lt;int&gt;(B&lt;int, int&gt;());\n}\n</code></pre>\n<p>This selects <code>#2</code> in Clang and GCC, as expected, but MSVC rejects the call as ambiguous; no idea why.</p>\n<hr>\n<p>The partial ordering algorithm as described in the standard speaks of synthesizing <em>a unique type, value, or class template</em> in order to generate the arguments. Clang manages that by... not synthesizing anything. It just uses the original forms of the dependent types (as declared) and matches them both ways. This makes sense, as substituting the synthesized types doesn't add any new information. It can't change the forms of the <code>A</code> types, since there's generally no way to tell what concrete types the substituted forms could resolve to. The synthesized types are unknown, which makes them pretty similar to template parameters.</p>\n<p>When encountering a <code>P</code> that is a non-deduced context, Clang's template argument deduction algorithm simply skips it, by returning \"success\" for that particular step. This happens not only during partial ordering, but for all types of deductions, and not just at the top level in a function parameter list, but recursively whenever a non-deduced context is encountered in the form of a compound type. For some reason, I found that surprising the first time I saw it. Thinking about it, it does, of course, make sense, and is according to the standard (<em>[...] does not participate in type deduction [...]</em> in [14.8.2.5p4]).</p>\n<p>This is consistent with <a href=\"https://stackoverflow.com/users/11698/richard-corden\">Richard Corden's</a> comments to <a href=\"https://stackoverflow.com/a/31558990/4326278\">his answer</a>, but I had to actually see the compiler code to understand all the implications (not a fault of his answer, but rather of my own - programmer thinking in code and all that).</p>\n<p>I've included some more information about Clang's implementation in <a href=\"https://stackoverflow.com/a/31735144/4326278\">this answer</a>.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:29.713", "Id": "31735126", "Score": "21", "CreationDate": "2015-07-30T22:26:50.317", "LastActivityDate": "2015-07-30T22:26:50.317"}, "bq_ids": {"n4140": {"so_31394260_31735126_0": {"section_id": 323, "quality": 0.55, "length": 11}, "so_31394260_31735126_3": {"section_id": 328, "quality": 0.7142857142857143, "length": 5}, "so_31394260_31735126_2": {"section_id": 147, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_31394260_31735126_0": {"section_id": 313, "quality": 0.55, "length": 11}, "so_31394260_31735126_3": {"section_id": 318, "quality": 0.7142857142857143, "length": 5}, "so_31394260_31735126_2": {"section_id": 141, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_31394260_31735126_0": {"section_id": 331, "quality": 1.0, "length": 20}, "so_31394260_31735126_3": {"section_id": 98, "quality": 0.7142857142857143, "length": 5}, "so_31394260_31735126_2": {"section_id": 337, "quality": 0.8333333333333334, "length": 5}}}});