post_cb({"2003394": {"ParentId": "2003266", "CommentCount": "3", "Body": "<p>Yes it should compile. If the constructor is not used, then its explicitness is not an issue.</p>\n", "Id": "2003394", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "0", "CreationDate": "2010-01-05T00:37:12.520", "LastActivityDate": "2010-01-05T00:37:12.520"}, "2003695": {"ParentId": "2003266", "CommentCount": "2", "Body": "<p>This is a rather tricky question, and it might be the case that VisualStudio is right and Comeau wrong (this seems really hard to believe). </p>\n<p>The standard if read word by word, defines that vector constructor in terms of the <em>copy constructor</em> (see quote), and that literally means that the object obtained by dereferencing the iterator must first be converted into the type T and then the copy constructor should be called. At this point, with an explicit constructor the code should not compile.</p>\n<p>It seems reasonable to expect an implementation, on the other hand, to directly call a constructor taking as argument the dereferenced iterator, in which case the constructor call would be explicit and thus the code should compile. This would go against the exact wording in the quote below, as the <em>copy constructor</em> is defined for a given type T as a constructor that taking a single possibly constant reference to an object of type T.</p>\n<p>I cannot think of any reasonable argument not to use the Comeau approach, and my believe (this is just personal opinion) is that the wording in the standard with respect to the complexity of the vector constructor should probably be restated as requiring <em>only N calls to the appropriate T constructor</em>, where appropriate would have to be defined as the constructor that matches the call <code>T( *first )</code> (that is, either a constructor taking an <code>InputIterator::value_type</code> (by value or possibly constant reference), or the T copy constructor after an implicit conversion from <code>InputIterator::value_type</code> to T.</p>\n<p>23.2.4.1 [lib.vector.cons]/1</p>\n<blockquote>\n<p id=\"so_2003266_2003695_0\">Complexity: The constructor template  vector(InputIterator \n  first, InputIterator last) makes only\n  N calls to the copy constructor of T\n  (where N is the  distance between\n  first and last) and no reallocations\n  if iterators first and last are of\n  forward, bidirectional, or random\n  access categories. It makes order N\n  calls to the copy constructor of T and\n  order log N reallocations if they are\n  just input iterators.</p>\n</blockquote>\n<p>I would like to know how the VS compiler behaves when given:</p>\n<pre><code>struct T1;\nstruct T2 {\n   operator T1 ();\n};\nstruct T1 {\n   T1( T2 const &amp; ) { std::cout &lt;&lt; \"T1(T2)\" &lt;&lt; std::endl; }\n};\nT2::operator T1() {\n   std::cout &lt;&lt; \"T2::operator T1\" &lt;&lt; std::endl;\n   return T1(*this);\n}\nint main() {\n   std::vector&lt;T2&gt; v2;\n   v2.push_back( T2() );\n   std::vector&lt;T1&gt; v1( v2.begin(), v2.end() );\n}\n</code></pre>\n<p>With g++ the result is that <code>T2::operator T1</code> is not called, but rather the elements in <code>v1</code> are constructed directly from the elements in <code>v2</code>. I would assume that with VS the compiler would use <code>T2::operator T1</code> to convert from each element in <code>v2</code> to a T1 element and then call the copy constructor. Is that so?</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "2003695", "Score": "1", "CreationDate": "2010-01-05T01:57:33.357", "LastActivityDate": "2010-01-05T01:57:33.357"}, "2003337": {"ParentId": "2003266", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This code does not compile in Comeau:</p>\n<pre><code>class Foo\n{\npublic:\n explicit Foo(int bar)\n {\n }\n};\n\nclass Bar\n{\n void DoStuff(Foo foo){\n\n }\n void DoStuff2()\n {\n  DoStuff(4);\n }\n};\n</code></pre>\n<p>Error message:</p>\n<pre><code>\"ComeauTest.c\", line 16: error: no suitable constructor exists to convert from \"int\"\n          to \"Foo\"\n    DoStuff(4);\n            ^\n\n1 error detected in the compilation of \"ComeauTest.c\".\n</code></pre>\n<p>So at the rudimentary level the online compiler supports explicit constructors. Must be something to do with the vector/iterators.</p>\n<p><strong>EDIT</strong> This however compiles:</p>\n<pre><code>Foo foo = (Foo)5;\n</code></pre>\n<p>Which is an explicit conversion, so that's OK. My guess the Comeau vector class does an explicit cast in the constructor somewhere, where's Microsoft's library doesn't.</p>\n<p>More on explicit constructors - <a href=\"http://www.glenmccl.com/tip_023.htm\" rel=\"nofollow noreferrer\">http://www.glenmccl.com/tip_023.htm</a></p>\n", "OwnerUserId": "129404", "LastEditorUserId": "129404", "LastEditDate": "2010-01-05T00:31:52.070", "Id": "2003337", "Score": "0", "CreationDate": "2010-01-05T00:23:04.017", "LastActivityDate": "2010-01-05T00:31:52.070"}, "2003305": {"ParentId": "2003266", "CommentCount": "2", "Body": "<p>I think it would depend on how <code>std::vector&lt;A&gt; As(Iterator,Iterator)</code> is implemented in your particular implementation of the STL.</p>\n", "OwnerUserId": "237349", "PostTypeId": "2", "Id": "2003305", "Score": "1", "CreationDate": "2010-01-05T00:16:57.773", "LastActivityDate": "2010-01-05T00:16:57.773"}, "2004021": {"ParentId": "2003266", "CommentCount": "0", "Body": "<p>This really boils down to a question of how the STL library is implemented, not a language specification issue. There is nothing in the language spec that would prohibit this from working, nor is there anything that would require that it should work.</p>\n<p>If the stl::vector constructor were written to try an implicit conversion using the assignment operator, then it would fail. It is more likely that the Microsoft STL implementation makes use of return-value optimization during initialization via a constructor call, in which case this code would work fine.</p>\n<p>It is important to note that the only reason this works is because the stl::vector constructor is templated, and the only requirement is that it is an input_iterator, or more accurately that it supports all the required functionality of an input iterator.</p>\n<p>I'd also like to point out that this is a prime example of why it is often difficult to write cross-platform code. Sometimes you end up with issues where neither compiler necessarily deviates from the language standard, but code still isn't portable.</p>\n", "OwnerUserId": "233895", "PostTypeId": "2", "Id": "2004021", "Score": "1", "CreationDate": "2010-01-05T03:34:50.027", "LastActivityDate": "2010-01-05T03:34:50.027"}, "2004287": {"ParentId": "2003266", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I looked through GCC's STL implementation and it should have similar behavior. Here's why.</p>\n<ul>\n<li>Elements of a <code>vector</code> are initialized by a generic function template which accepts any two types <code>X</code> and <code>V</code> and calls <code>new( p ) X( v )</code> where <code>v</code> is a <code>V</code> (I'm paraphrasing a bit). This allows explicit conversion.</li>\n<li>Elements of a <code>set</code> or <code>map</code> are initialized by a private member function of <code>_tree&lt;T,\u2026&gt;</code> which specifically expects a <code>T const &amp;</code> to be passed in. This member function isn't a template (beyond being a member of a template), so if the initial value can't be implicitly converted to <code>T</code>, the call fails. (Again I'm simplifying the code.)</li>\n</ul>\n<p>The standard doesn't require that explicit conversion work or that implicit conversion not work when initializing a container with a range. It simply says that the range is copied into the container. Definitely ambiguous for your purpose.</p>\n<p>Surprising such ambiguity exists, considering how they've already refined the standard in consideration of problems like <a href=\"https://stackoverflow.com/questions/1943228/implicit-constructor-conversion-works-on-explicit-vectorvector-only-sometimes\">the one I had</a> a couple weeks ago.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:11.293", "Id": "2004287", "Score": "3", "CreationDate": "2010-01-05T05:10:09.317", "LastActivityDate": "2010-01-05T05:10:09.317"}, "bq_ids": {"n4140": {"so_2003266_2003695_0": {"section_id": 966, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_2003266_2003695_0": {"section_id": 954, "quality": 0.7368421052631579, "length": 28}}, "n4659": {"so_2003266_2003695_0": {"section_id": 1028, "quality": 0.7368421052631579, "length": 28}}}, "2003266": {"CommentCount": "3", "AcceptedAnswerId": "2004287", "PostTypeId": "1", "LastEditorUserId": "200783", "CreationDate": "2010-01-05T00:08:31.467", "LastActivityDate": "2010-01-05T05:10:09.317", "LastEditDate": "2010-01-05T01:07:19.650", "ViewCount": "3286", "FavoriteCount": "2", "Title": "C++ explicit constructors and iterators", "Id": "2003266", "Score": "7", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct A\n{\n    explicit A(int i_) : i(i_) {}\n    int i;\n};\n\nint main()\n{\n    std::vector&lt;int&gt; ints;\n    std::vector&lt;A&gt; As(ints.begin(), ints.end());\n}\n</code></pre>\n<p>Should the above compile? My feeling is that it should not, due to the constructor being marked <code>explicit</code>.</p>\n<p>Microsoft Visual C++ agrees, giving a clear error message: <code>cannot convert from 'int' to 'const A'; Constructor for struct 'A' is declared 'explicit'</code></p>\n<p>However, using <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"noreferrer\">Comeau's online compiler</a>, the code compiles successfully.</p>\n<p>Which is correct?</p>\n<p><strong>Edit:</strong></p>\n<p>Interestingly, changing <code>vector</code> to <code>set</code> (after adding an <code>operator &lt;</code> to A) causes both compilers to give an error.</p>\n<p>However, changing <code>vector&lt;int&gt;</code> to <code>map&lt;int, int&gt;</code> and <code>vector&lt;A&gt;</code> to <code>map&lt;A, A&gt;</code> causes both compilers to accept the code!</p>\n", "Tags": "<c++><constructor><iterator><explicit>", "OwnerUserId": "200783", "AnswerCount": "6"}});