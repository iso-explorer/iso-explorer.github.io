post_cb({"9024863": {"ParentId": "9024826", "CommentCount": "2", "Body": "<p>You may trigger some hardware safety feature. So no, you don't have any guarantee.</p>\n<p>Edit:\nNote that gcc has the <code>-ftrapv</code> option (but it doesn't seem to work for me).</p>\n", "OwnerUserId": "211659", "PostTypeId": "2", "Id": "9024863", "Score": "8", "CreationDate": "2012-01-26T20:28:27.523", "LastActivityDate": "2012-01-26T20:28:27.523"}, "9025098": {"ParentId": "9024826", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As pointed out by @Xeo in the comments (I actually brought it up in the <a href=\"http://chat.stackoverflow.com/transcript/message/2470538#2470538\">C++ chat</a> first): \n<br><strong>Undefined behavior really means it and it can hit you when you least expect it.</strong></br></p>\n<p>The best example of this is here: <a href=\"https://stackoverflow.com/q/7682477/922184\">Why does integer overflow on x86 with GCC cause an infinite loop?</a></p>\n<p>On x86, signed integer overflow is just a simple wrap-around. So normally, <em>you'd expect the same thing to happen in C or C++</em>. However, the compiler can intervene - and <strong>use undefined behavior as an opportunity to optimize</strong>.</p>\n<p>In the example taken from that question:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int i = 0x10000000;\n\n    int c = 0;\n    do{\n        c++;\n        i += i;\n        cout &lt;&lt; i &lt;&lt; endl;\n    }while (i &gt; 0);\n\n    cout &lt;&lt; c &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>When compiled with GCC, GCC optimizes out the loop test and makes this an infinite loop.</p>\n", "OwnerUserId": "922184", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:48:33.443", "Id": "9025098", "Score": "19", "CreationDate": "2012-01-26T20:47:53.817", "LastActivityDate": "2012-01-26T20:47:53.817"}, "9025335": {"ParentId": "9024826", "CommentCount": "2", "Body": "<p>There are two views about undefined behavior. There is the view it is there to gather for strange hardware and other special cases, but that usually it should behave sanely. And there is the view that anything can happen. And depending on the UB source, some hold different opinions.</p>\n<p>While the UB about overflow has probably been introduced for taking into account hardware which trap or saturate on overflow and the difference of result between representation, and so one can argue for the first view in this case, people writing optimizers hold very dearly the view that if the standard doesn't guarantee something, really anything can happen and they try to use every piece of liberty to generate machine code which runs more rapidly, even if the result doesn't make sense anymore.</p>\n<p>So when you see an undefined behavior, assume that anything can happen, however reasonable a given behavior may seem.</p>\n", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "9025335", "Score": "5", "CreationDate": "2012-01-26T21:05:45.987", "LastActivityDate": "2012-01-26T21:05:45.987"}, "9024826": {"CommentCount": "6", "AcceptedAnswerId": "9025098", "PostTypeId": "1", "LastEditorUserId": "777186", "CreationDate": "2012-01-26T20:25:53.343", "LastActivityDate": "2013-06-13T07:59:19.723", "LastEditDate": "2013-03-02T06:30:00.557", "ViewCount": "2976", "FavoriteCount": "5", "Title": "How disastrous is integer overflow in C++?", "Id": "9024826", "Score": "20", "Body": "<p>I was just wondering how disastrous integer overflow really is. Take the following example program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int a = 46341;\n    int b = a * a;\n    std::cout &lt;&lt; \"hello world\\n\";\n}\n</code></pre>\n<p>Since <code>a * a</code> overflows on 32 bit platforms, and integer overflow triggers undefined behavior, do I have any guarantees at all that <code>hello world</code> will actually appear on my screen?</p>\n<hr>\n<p>I removed the \"signed\" part from my question based on the following standard quotes:</p>\n<blockquote>\n<p id=\"so_9024826_9024826_0\">(\u00a75/5 C++03, \u00a75/4 C++11) If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p>\n<p id=\"so_9024826_9024826_1\">(\u00a73.9.1/4) Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2^n where n is the number of bits in the value representation of that particular size of integer. This implies that <strong>unsigned arithmetic does not overflow</strong> because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n</hr>", "Tags": "<c++><undefined-behavior><integer-overflow>", "OwnerUserId": "252000", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_9024826_9024826_0": {"section_id": 5937, "quality": 0.8666666666666667, "length": 13}, "so_9024826_9024826_1": {"section_id": 7213, "quality": 0.9111111111111111, "length": 41}}, "n3337": {"so_9024826_9024826_0": {"section_id": 5709, "quality": 0.8666666666666667, "length": 13}, "so_9024826_9024826_1": {"section_id": 6957, "quality": 0.9555555555555556, "length": 43}}, "n4659": {"so_9024826_9024826_0": {"section_id": 7421, "quality": 0.8666666666666667, "length": 13}, "so_9024826_9024826_1": {"section_id": 8722, "quality": 0.9111111111111111, "length": 41}}}});