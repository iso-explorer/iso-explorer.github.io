post_cb({"bq_ids": {"n4140": {"so_34717823_34721371_6": {"length": 23, "quality": 1.0, "section_id": 7043}, "so_34717823_34721371_5": {"length": 22, "quality": 0.88, "section_id": 7043}, "so_34717823_34721371_4": {"length": 23, "quality": 1.0, "section_id": 7043}, "so_34717823_34721371_3": {"length": 12, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_34717823_34721371_6": {"length": 23, "quality": 1.0, "section_id": 6788}, "so_34717823_34721371_5": {"length": 22, "quality": 0.88, "section_id": 6788}, "so_34717823_34721371_4": {"length": 23, "quality": 1.0, "section_id": 6788}, "so_34717823_34721371_3": {"length": 12, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_34717823_34721371_6": {"length": 23, "quality": 1.0, "section_id": 8540}, "so_34717823_34721371_5": {"length": 22, "quality": 0.88, "section_id": 8540}, "so_34717823_34721371_4": {"length": 23, "quality": 1.0, "section_id": 8540}, "so_34717823_34721371_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 6853}}}, "34717823": {"ViewCount": "3429", "Body": "<p>Can the following be written in a header file:</p>\n<pre><code>inline void f () { std::function&lt;void ()&gt; func = [] {}; }\n</code></pre>\n<p>or</p>\n<pre><code>class C { std::function&lt;void ()&gt; func = [] {}; C () {} };\n</code></pre>\n<p>I guess in each source file, the lambda's type may be different and therefore the contained type in <code>std::function</code> (<code>target_type</code>'s results will differ).</p>\n<p>Is this an ODR (<a href=\"https://en.wikipedia.org/wiki/One_Definition_Rule\">One Definition Rule</a>) violation, despite looking like a common pattern and a reasonable thing to do? Does the second sample violate the ODR every time or only if at least one constructor is in a header file?</p>\n", "AcceptedAnswerId": "34721371", "Title": "Can using a lambda in header files violate the ODR?", "CreationDate": "2016-01-11T09:19:35.010", "Id": "34717823", "CommentCount": "4", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2016-01-14T00:13:06.990", "LastEditorUserId": "3647361", "LastActivityDate": "2016-02-10T11:14:38.080", "Score": "63", "OwnerUserId": "3256948", "Tags": "<c++><c++11><lambda><language-lawyer><one-definition-rule>", "AnswerCount": "2"}, "34747130": {"Id": "34747130", "PostTypeId": "2", "Body": "<p><strong>UPDATED</strong></p>\n<p>After all I agree with @Columbo answer, but want to add the practical five cents :)</p>\n<p>Although the ODR violation sounds dangerous, it's not really a serious problem in this particular case. The lambda classes created in different TUs are equivalent except their typeids. So unless you have to cope with the typeid of a header-defined lambda (or a type depending on the lambda), you are safe.</p>\n<p>Now, when the ODR violation is reported as a bug, there is a big chance that it will be fixed in compilers that have the problem e.g. MSVC and probably some other ones which don't follow the Itanium ABI. Note that Itanium ABI conformant compilers (e.g. gcc and clang) are already producing ODR-correct code for header-defined lambdas.</p>\n", "LastEditorUserId": "2572774", "LastActivityDate": "2016-02-10T11:14:38.080", "Score": "6", "CreationDate": "2016-01-12T15:09:05.750", "ParentId": "34717823", "CommentCount": "0", "OwnerUserId": "2572774", "LastEditDate": "2016-02-10T11:14:38.080"}, "34721371": {"Id": "34721371", "PostTypeId": "2", "Body": "<p>This boils down to whether or not a lambda's type differs across translation units. If it does, it may affect template argument deduction and potentially cause different functions to be called - in what are meant to be consistent definitions. That would violate the ODR (see below).</p>\n<p>However, that isn't intended. In fact, this problem has already been touched on a while ago by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#765\"><strong>core issue 765</strong></a>, which specifically names inline functions with external linkage - such as <code>f</code>: </p>\n<blockquote>\n<p id=\"so_34717823_34721371_0\">7.1.2 [dcl.fct.spec] paragraph 4 specifies that local static variables and string literals appearing in the body of an inline function with\n  external linkage must be the same entities in every translation unit\n  in the program. <strong>Nothing is said, however, about whether local types\n  are likewise required to be the same.</strong></p>\n<p id=\"so_34717823_34721371_1\">Although a conforming program could always have determined this by use\n  of typeid, recent changes to C++ (<strong>allowing local types as template\n  type arguments, lambda expression closure classes</strong>) make this question\n  more pressing.</p>\n<h3>Notes from the July, 2009 meeting:</h3>\n<p id=\"so_34717823_34721371_2\">The types are intended to be the same.</p>\n</blockquote>\n<p>Now, the resolution incorporated the following wording into <a href=\"http://eel.is/c++draft/dcl.fct.spec#4\">[dcl.fct.spec]/4</a>:</p>\n<blockquote>\n<p id=\"so_34717823_34721371_3\">A type defined within the body of an <code>extern inline</code> function is the same type in every translation unit.</p>\n</blockquote>\n<p>(NB: MSVC isn't regarding the above wording yet, although <a href=\"https://www.reddit.com/r/cpp/comments/40lm8o/lambdas_are_dangerous/cywmh2c\">it might in the next release</a>).</p>\n<p>Lambdas inside such functions' bodies are therefore safe, since the closure type's definition is indeed at block scope (<a href=\"http://eel.is/c++draft/expr.prim.lambda#3\">[expr.prim.lambda]/3</a>).<br>\nHence multiple definitions of <code>f</code> were ever well-defined. </br></p>\n<p>This resolution certainly doesn't cover all scenarios, as there are many more kinds of entities with external linkage that can make use of lambdas, function templates in particular - this should be covered by another core issue.<br>\nIn the meantime, Itanium already contains <a href=\"https://mentorembedded.github.io/cxx-abi/abi.html#closure-types\">appropriate rules</a> to ensure that such lambdas' types coincide in more situations, hence Clang and GCC should already mostly behave as intended.</br></p>\n<hr>\n<p>Standardese on why differing closure types are an ODR violation follows. Consider bullet points (6.2) and (6.4) in <a href=\"http://eel.is/c++draft/basic.def.odr#6\">[basic.def.odr]/6</a>:</p>\n<blockquote>\n<p id=\"so_34717823_34721371_4\">There can be more than one definition of [\u2026]. Given such an entity named <code>D</code> defined in more than one translation unit, then each definition of <code>D</code> shall consist of the\n  same sequence of tokens; and</p>\n<p id=\"so_34717823_34721371_5\">(6.2) - in each definition of <code>D</code>, <strong>corresponding names, looked up\n  according to [basic.lookup], shall refer to an entity defined within\n  the definition of <code>D</code>, or shall refer to the same entity, after\n  overload resolution ([over.match])</strong> and after matching of partial\n  template specialization ([temp.over]), [\u2026]; and</p>\n<p id=\"so_34717823_34721371_6\">(6.4) - in each definition of <code>D</code>, the overloaded operators referred to,\n  the <strong>implicit calls to</strong> conversion functions, <strong>constructors</strong>,\n  operator new functions and operator delete functions, <strong>shall refer to\n  the same function, or to a function defined within the definition of\n  <code>D</code></strong>; [\u2026]</p>\n</blockquote>\n<p>What this effectively means is that any functions called in the entity's definition shall be the same in all translation units - <strong>or have been defined inside its definition</strong>, like local classes and their members. I.e. usage of a lambda per se is not problematic, but passing it to function templates clearly is, since these are defined outside the definition.</p>\n<p>In your example with <code>C</code>, the closure type is defined within the class (whose scope is the smallest enclosing one). If the closure type differs in two TUs, which the standard may unintentionally imply with the uniqueness of a closure type, the constructor instantiates and calls different specializations of <code>function</code>'s constructor template, violating (6.4) in the above quote.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2016-01-13T22:12:20.960", "Score": "37", "CreationDate": "2016-01-11T12:16:31.083", "ParentId": "34717823", "CommentCount": "7", "OwnerUserId": "3647361", "LastEditDate": "2016-01-13T22:12:20.960"}});