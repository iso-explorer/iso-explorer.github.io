post_cb({"30035547": {"CommentCount": "16", "ViewCount": "197", "PostTypeId": "1", "LastEditorUserId": "2877241", "CreationDate": "2015-05-04T16:53:12.197", "LastActivityDate": "2017-10-04T20:54:55.730", "Title": "How does C treat char sums?", "AcceptedAnswerId": "30035811", "LastEditDate": "2017-10-04T20:54:55.730", "Id": "30035547", "Score": "5", "Body": "<p>When I'm in C++, and I call an overloaded function foo, like so:</p>\n<pre><code>foo('e' - (char) 5)\n</code></pre>\n<p>it can output \"this is a char\" or \"this is an int\" based on the type result. I get \"this is an int\" from my program, like this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(char x)\n{\n    std::cout &lt;&lt; \"output is a char\" &lt;&lt; std::endl;\n}\nvoid foo(int x)\n{\n    std::cout &lt;&lt; \"output is an int\" &lt;&lt; std::endl;\n}\nint main()\n{\n    foo('a' + (char) 5);\n}\n</code></pre>\n<p>My instructor says that in C, the expression above, <code>('a' + (char) 5)</code>, evaluates as a char. I see in the C99 standard that chars are promoted to ints to find the sum, but does C recast them back to chars when it's done? I can't find any references that seem credible saying one way or another what C actually does after the promotion is completed, and the sum is found.</p>\n<p>Is the sum left as an int, or given as a char? How can I prove this in C, or is there a reference I'm not understanding/finding?</p>\n", "Tags": "<c++><c><char><int>", "OwnerUserId": "3236155", "AnswerCount": "8"}, "30036422": {"ParentId": "30035547", "CommentCount": "0", "Body": "<p>In C (unlike C++), the character literal <code>'a'</code> has type <code>int</code> (\u00a76.4.4.4\u00b610: \"An integer character constant has type <code>int</code>.\")</p>\n<p>Even if that were not the case, the C standard clearly states that prior to the evaluation of the operator <code>+</code>, \"[i]f both operands have arithmetic type, the usual arithmetic conversions are performed on them.\" (C11, \u00a76.5.6 \u00b64) In this respect, C and C++ have identical semantics. (See <code>[expr.add]</code> \u00a75.7\u00b61  of C++)</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "30036422", "Score": "0", "CreationDate": "2015-05-04T17:40:42.007", "LastActivityDate": "2015-05-04T17:40:42.007"}, "30035771": {"ParentId": "30035547", "CommentCount": "0", "Body": "<p>No, C does not recast them back to chars.</p>\n<p>The standard (ISO/IEC 9899:1999) says (6.3.1.8 Usual arithmetic conversions):</p>\n<blockquote>\n<p id=\"so_30035547_30035771_0\">Many operators that expect operands of arithmetic type cause conversions and yield result\n  types in a similar way. The purpose is to determine a common real type for the operands\n  and result. For the specified operands, each operand is converted, without change of type\n  domain, to a type whose corresponding real type is the common real type. <strong>Unless</strong>\n<strong>explicitly stated otherwise, the common real type is also the corresponding real type of</strong>\n<strong>the result</strong>, whose type domain is determined by the operator.</p>\n</blockquote>\n", "OwnerUserId": "2866898", "PostTypeId": "2", "Id": "30035771", "Score": "3", "CreationDate": "2015-05-04T17:05:00.843", "LastActivityDate": "2015-05-04T17:05:00.843"}, "30036087": {"ParentId": "30035547", "CommentCount": "0", "Body": "<p>Section 6.5.2.2/6 </p>\n<blockquote>\n<p id=\"so_30035547_30036087_0\">If the expression that denotes the called function has a type that\n  does not include a prototype, the integer promotions are performed on\n  each argument...</p>\n</blockquote>\n<p>So the answer to your question depends on the function prototype. If the function is declared as </p>\n<pre><code>void foo(int x)\n</code></pre>\n<p>or </p>\n<pre><code>void foo()\n</code></pre>\n<p>then the function argument will be passed as an <code>int</code>. </p>\n<p>OTOH, if the function is declared as </p>\n<pre><code>void foo( char x )\n</code></pre>\n<p>then the result of the expression will be implicitly cast to <code>char</code>.</p>\n", "OwnerUserId": "3386109", "PostTypeId": "2", "Id": "30036087", "Score": "0", "CreationDate": "2015-05-04T17:22:04.250", "LastActivityDate": "2015-05-04T17:22:04.250"}, "30035829": {"ParentId": "30035547", "CommentCount": "4", "Body": "<p>You can't determine the type of an expression as easily in C, but you can easily determine the size of an expression:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\n    printf(\"sizeof(char)==1\\n\");\n    printf(\"sizeof(int)==%u\\n\", sizeof(int));\n    printf(\"sizeof('a' + (char) 5)==%u\\n\", sizeof('a' + (char) 5));\n    return 0;\n}\n</code></pre>\n<p>This gives me:</p>\n<pre><code>sizeof(char)==1\nsizeof(int)==4\nsizeof('a' + (char) 5)==4\n</code></pre>\n<p>which at least proves that <code>'a' + (char) 5</code> is <em>not</em> of type <code>char</code>.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "30035829", "Score": "2", "CreationDate": "2015-05-04T17:07:42.730", "LastActivityDate": "2015-05-04T17:07:42.730"}, "30035720": {"ParentId": "30035547", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your instructor seems to be wrong. Additional to your standard find that the arithmetic promotes to <code>int</code>, we can use a simple test program to show the behavior (no standard prove of course, but the same level of proof as your C++ test):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main () {\n   printf(\"%g\",'c' - (char)5);\n}\n</code></pre>\n<p>produces </p>\n<blockquote>\n<p id=\"so_30035547_30035720_0\">Warning: format specifies type 'double' but argument has type 'int'</p>\n</blockquote>\n<p>with <a href=\"http://coliru.stacked-crooked.com/a/97380b3907f332c5\" rel=\"nofollow\">gcc</a> and <a href=\"http://coliru.stacked-crooked.com/a/88daee27b5e3fc41\" rel=\"nofollow\">clang</a>.</p>\n", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2015-05-04T17:44:48.810", "Id": "30035720", "Score": "2", "CreationDate": "2015-05-04T17:02:14.363", "LastActivityDate": "2015-05-04T17:44:48.810"}, "30035924": {"ParentId": "30035547", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From the C++ Standard (C++ Working Draft N3797, 5.7 Additive operators)</p>\n<blockquote>\n<p id=\"so_30035547_30035924_0\">1 The additive operators + and - group left-to-right. <strong>The usual\n  arithmetic conversions are performed for operands of arithmetic or\n  enumeration type.</strong></p>\n</blockquote>\n<p>and (5 Expressions)</p>\n<blockquote>\n<p id=\"so_30035547_30035924_1\">10 Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are defined as follows:</p>\n<p id=\"so_30035547_30035924_2\">...</p>\n<p id=\"so_30035547_30035924_3\">\u2014 Otherwise, <strong>the integral promotions (4.5) shall be performed on\n  both operands</strong>.62 Then the following rules shall be applied to the\n  promoted operands:</p>\n</blockquote>\n<p>Thus the expression in the function call</p>\n<pre><code>foo('a' + (char) 5);\n</code></pre>\n<p>has type <code>int</code>.\nTo call the overloaded function with parameter of type char you have to write for example</p>\n<pre><code>foo( char( 'a' + 5 ) );\n</code></pre>\n<p>or</p>\n<pre><code>foo( ( char )( 'a' + 5 ) );\n</code></pre>\n<p>or you can use C++ casting like</p>\n<pre><code>foo( static_cast&lt;char&gt;( 'a' + 5 ) );\n</code></pre>\n<p>The above quotes from the C++ Standard also are valid for C Standard. The visible difference is that in C++ character literals have type <code>char</code> while in C they have type <code>int</code>.</p>\n<p>So in C++ the output of the statement</p>\n<pre><code>std::cout &lt;&lt; sizeof( 'a' ) &lt;&lt; std::endl;\n</code></pre>\n<p>will be equal to 1.</p>\n<p>While in C the output of the statement</p>\n<pre><code>printf( \"%zu\\n\", sizeof( 'a' ) );\n</code></pre>\n<p>will be equal to <code>sizeof( int )</code> that is usually equal to 4.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-05-04T17:45:37.220", "Id": "30035924", "Score": "0", "CreationDate": "2015-05-04T17:12:38.607", "LastActivityDate": "2015-05-04T17:45:37.220"}, "30035811": {"ParentId": "30035547", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C Standard, 6.3.1.8 Usual arithmetic conversions, emphasis mine:</p>\n<blockquote>\n<p id=\"so_30035547_30035811_0\">Many operators that expect operands of arithmetic type cause conversions and yield result\n  types in a similar way. The purpose is to determine a common real type for the operands\n  and result. For the specified operands, each operand is converted, without change of type\n  domain, to a type whose corresponding real type is the common real type. <strong>Unless\n  explicitly stated otherwise, the common real type is also the corresponding real type of\n  the result</strong>, whose type domain is the type domain of the operands if they are the same,\n  and complex otherwise. This pattern is called the <em>usual arithmetic conversions</em>:  </p>\n<ul>\n<li>First, if the correspeonding real type of either operand is <code>long double</code>...</li>\n<li>Otherwise, if the corresponding real type of either operand is <code>double</code>...</li>\n<li>Otherwise, if the corresponding real type of either operand is <code>float</code>...</li>\n<li>Otherwise, <strong>the integer promotions are performed on both operands</strong>. Then the following rules are applied to the promoted operands:\n  <ul>\n<li>If both operands have the same type, then no further conversion is needed.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So you are exactly correct. The type of the expression <code>'a' + (char) 5</code> is <code>int</code>. There is no recasting back to <code>char</code>, unless explicitly asked for by the user. Note that <code>'a'</code> here has type <code>int</code>, so it's only the <code>(char)5</code> that needs to be promoted. This is stipulated in 6.4.4.4 Character Constants:</p>\n<blockquote>\n<p id=\"so_30035547_30035811_1\">An integer character constant is a sequence of one or more multibyte characters enclosed\n  in single-quotes, as in <code>'x'</code>.<br>\n  ...<br>\n  An integer character constant has type <code>int</code>.</br></br></p>\n</blockquote>\n<p>There is an example demonstrating the explicit recasting to <code>char</code>:</p>\n<blockquote>\n<p id=\"so_30035547_30035811_2\">In executing the fragment</p>\n<pre><code>char c1, c2;\n/* ... */\nc1 = c1 + c2\n</code></pre>\n<p id=\"so_30035547_30035811_3\">the \u2018\u2018integer promotions\u2019\u2019 require that the abstract machine promote the value of each variable to <code>int</code> size and then add the two <code>int</code>s and truncate the sum. Provided the addition of two <code>char</code>s can be done without overflow, or with overflow wrapping silently to produce the correct result, the actual execution need only produce the same result, possibly omitting the promotions.</p>\n</blockquote>\n<p>The truncation here only happens because we assign back to a <code>char</code>.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-05-04T17:51:28.837", "Id": "30035811", "Score": "5", "CreationDate": "2015-05-04T17:06:47.270", "LastActivityDate": "2015-05-04T17:51:28.837"}, "bq_ids": {"n4140": {"so_30035547_30035720_0": {"section_id": 3487, "quality": 0.5555555555555556, "length": 5}, "so_30035547_30035924_1": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_30035547_30035924_3": {"section_id": 5943, "quality": 0.9166666666666666, "length": 11}, "so_30035547_30035811_1": {"section_id": 5343, "quality": 0.5333333333333333, "length": 8}, "so_30035547_30035924_0": {"section_id": 6138, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_30035547_30035720_0": {"section_id": 3352, "quality": 0.5555555555555556, "length": 5}, "so_30035547_30035924_1": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_30035547_30035924_3": {"section_id": 5714, "quality": 0.9166666666666666, "length": 11}, "so_30035547_30035811_1": {"section_id": 5140, "quality": 0.5333333333333333, "length": 8}, "so_30035547_30035924_0": {"section_id": 5902, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_30035547_30035720_0": {"section_id": 4250, "quality": 0.5555555555555556, "length": 5}, "so_30035547_30035924_1": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_30035547_30035924_3": {"section_id": 7428, "quality": 0.9166666666666666, "length": 11}, "so_30035547_30035924_0": {"section_id": 7635, "quality": 0.8571428571428571, "length": 12}}}, "30035722": {"ParentId": "30035547", "CommentCount": "0", "Body": "<p>It's promoted to an <code>int</code>, and there's nothing to tell the compiler it should use anything else. You can convert back to a char like this:</p>\n<pre><code>foo((char)('a' + 5));\n</code></pre>\n<p>This tells the compiler to treat the result of the calculation as a <code>char</code>, otherwise it leaves it as an <code>int</code>.</p>\n", "OwnerUserId": "270280", "PostTypeId": "2", "Id": "30035722", "Score": "0", "CreationDate": "2015-05-04T17:02:19.023", "LastActivityDate": "2015-05-04T17:02:19.023"}});