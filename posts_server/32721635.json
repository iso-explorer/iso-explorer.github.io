post_cb({"bq_ids": {"n4140": {"so_32721635_32721797_0": {"length": 26, "quality": 1.0, "section_id": 1236}, "so_32721635_32721797_1": {"length": 67, "quality": 0.8481012658227848, "section_id": 1238}}, "n3337": {"so_32721635_32721797_0": {"length": 26, "quality": 1.0, "section_id": 1234}, "so_32721635_32721797_1": {"length": 72, "quality": 0.9113924050632911, "section_id": 1236}}, "n4659": {"so_32721635_32721797_0": {"length": 26, "quality": 1.0, "section_id": 1324}, "so_32721635_32721797_1": {"length": 64, "quality": 0.810126582278481, "section_id": 1326}}}, "32721635": {"ViewCount": "271", "Body": "<p>1) For a given <code>stl</code> algorithm, how does one find out what custom container/iterator features one needs to implement in order to use said container? </p>\n<p>2) What needs to be implemented to make container fully compatible with all <code>stl</code> algorithms?</p>\n", "AcceptedAnswerId": "32721797", "Title": "What does it take to be an `stl` algorithm compatible container?", "CreationDate": "2015-09-22T16:05:18.123", "Id": "32721635", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-09-22T16:44:10.593", "Score": "3", "OwnerUserId": "2540407", "Tags": "<c++><stl>", "AnswerCount": "2"}, "32722382": {"Id": "32722382", "PostTypeId": "2", "Body": "<p>STL algorithms use template types to describe the requirements of the function.  If you take <a href=\"http://en.cppreference.com/w/cpp/algorithm/sort\" rel=\"nofollow\"><code>std::sort</code></a> as an example</p>\n<pre><code>template&lt;class RandomAccessIterator&gt;\nvoid sort(RandomAccessIterator first, RandomAccessIterator last);\n</code></pre>\n<p>We can see that wee need to pass a random access compliant iterator.  So as long as the container you have has an iterator type of <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow\">RandomAccessIterator</a> or it supports all of the operations that RandomAccessIterator supports then you can use it with <code>std::sort</code>.  </p>\n<p>If we look at the iterator hierarchy on <a href=\"http://en.cppreference.com/w/cpp/iterator\" rel=\"nofollow\">cppreference</a>  We can see that in the current standard a <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow\">RandomAccessIterator</a> is a super-set of all other iterator types and supports all of the operations that the other iterators support.  So if a function calls for a InputIterator we can still give it an RandomAccessIterator.  </p>\n<p>So right now if your container has a RandomAccessIterator you can use it in any of the STL algorithms.</p>\n", "LastActivityDate": "2015-09-22T16:44:10.593", "CommentCount": "0", "CreationDate": "2015-09-22T16:44:10.593", "ParentId": "32721635", "Score": "0", "OwnerUserId": "4342498"}, "32721797": {"Id": "32721797", "PostTypeId": "2", "Body": "<p>In C++11 standard it is stated in \u00a725.1, in the footnotes:</p>\n<blockquote>\n<p id=\"so_32721635_32721797_0\">3 All of the algorithms are separated from the particular implementations of data structures and are parameterized by iterator types. Because of this, <strong>they can work with program-defined data structures, as long as these data structures have iterator types satisfying the assumptions on the algorithms.</strong></p>\n</blockquote>\n<p>and then:</p>\n<blockquote>\n<p id=\"so_32721635_32721797_1\">5 Throughout this Clause, the names of template parameters are used to express type requirements. If an algorithm\u2019s template parameter is <strong>InputIterator, InputIterator1, or InputIterator2, the actual template argument shall satisfy the requirements of an input iterator</strong> (24.2.3). If an algorithm\u2019s template parameter is <strong>OutputIterator, OutputIterator1, or OutputIterator2, the actual template argument shall satisfy the requirements of an output iterator</strong> (\u00a724.2.4). If an algorithm\u2019s template parameter is <strong>ForwardIterator, ForwardIterator1, or ForwardIterator2, the actual template argument shall satisfy the requirements of a forward iterator</strong> (\u00a724.2.5). If an algorithm\u2019s template parameter is <strong>BidirectionalIterator, Bidirectional-Iterator1, or BidirectionalIterator2, the actual template argument shall satisfy the requirements of a bidirectional iterator</strong> (\u00a724.2.6). If an algorithm\u2019s template parameter is <strong>RandomAccessIterator, Random- AccessIterator1, or RandomAccessIterator2, the actual template argument shall satisfy the requirements of a random-access iterator</strong> (\u00a724.2.7).</p>\n</blockquote>\n<p>So basically you need to provide your custom class a way to retrieve the usual iterators and these object must satisfy the requirement depending on which algorithm you want to support.</p>\n<p>For example, let's take <code>std::any_of</code>, you can see it's declared as</p>\n<pre><code>template &lt;class InputIterator, class Predicate&gt; \nbool any_of(InputIterator first, InputIterator last, Predicate pred);\n</code></pre>\n<p>So you need to provide it an input iterator, then you can see at \u00a724.2.3 the requirement for it and implement them:</p>\n<ul>\n<li>contextually convertible to bool (<code>a != b</code>)</li>\n<li>convertible to T (<code>*a</code>)</li>\n<li>dereferenceable (<code>a-&gt;m</code>)</li>\n<li>incrementable</li>\n</ul>\n<p>Same story for each kind of iterator.</p>\n", "LastActivityDate": "2015-09-22T16:13:15.417", "CommentCount": "0", "CreationDate": "2015-09-22T16:13:15.417", "ParentId": "32721635", "Score": "5", "OwnerUserId": "121747"}});