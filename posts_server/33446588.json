post_cb({"33446588": {"CommentCount": "14", "ViewCount": "143", "CreationDate": "2015-10-31T00:04:55.237", "LastActivityDate": "2015-10-31T01:03:29.717", "Title": "Why is the size of a native long primitive on 64-bit Windows only 4 bytes?", "AcceptedAnswerId": "33446727", "PostTypeId": "1", "Id": "33446588", "Score": "2", "Body": "<p>Will someone please tell me how this makes any sense, and how to make it stop?  Seriously, am I crazy or is the 64-bit Windows long type only 4 bytes?  How does that make any sense?  I thought the native long primitive size was supposed to be the same as the native register size.</p>\n<pre><code>[32-bit Linux]\n\nme@u32:~$ ./sizes32\nsizeof(char):      1\nsizeof(short):     2\nsizeof(int):       4\nsizeof(long):      4\nsizeof(long long): 8\n\n[64-bit Linux]\n\nme@u64:~$ ./sizes64\nsizeof(char):      1\nsizeof(short):     2\nsizeof(int):       4\nsizeof(long):      8\nsizeof(long long): 8\n\n[32-bit Windows]\n\nC:\\Users\\me\\Downloads&gt;sizes32.exe\nsizeof(char):      1\nsizeof(short):     2\nsizeof(int):       4\nsizeof(long):      4\nsizeof(long long): 8\n\n[64-bit Windows]\n\nC:\\Users\\me\\Downloads&gt;sizes64.exe\nsizeof(char):      1\nsizeof(short):     2\nsizeof(int):       4\nsizeof(long):      4\nsizeof(long long): 8\n</code></pre>\n", "Tags": "<c++><c><linux><windows><x86>", "OwnerUserId": "5203926", "AnswerCount": "3"}, "33446796": {"ParentId": "33446588", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You got already plenty of valid responses.  </p>\n<p>Just for the records, here the precise definition in the C++ standard: </p>\n<blockquote>\n<p id=\"so_33446588_33446796_0\"><strong>3.9.1/2:</strong> There are five standard signed integer types : \u201csigned char\u201d, \u201cshort\n  int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\u201d. In this list, <strong>each type\n  provides at least as much storage as those preceding it</strong> in the list.\n  (...)  Plain ints have the natural size suggested by the architecture\n  of the execution environment (44).</p>\n</blockquote>\n<p>The last sentence suggests that int is of the size corresponding to the register.  Unfortunately, rather than telling the full story of the origin of the universe, its footnote just says:  \"<em>(44) that is, large enough to contain any value in the range of INT_MIN and INT_MAX, as defined in the header <code>&lt;climits&gt;</code></em>\"  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2015-10-31T01:03:29.717", "Id": "33446796", "Score": "1", "CreationDate": "2015-10-31T00:34:47.547", "LastActivityDate": "2015-10-31T01:03:29.717"}, "33446727": {"ParentId": "33446588", "CommentCount": "5", "Body": "<p>Backward compatibility!</p>\n<p>Windows came from a 16-bit platform where <code>sizeof(long) == 4</code> and it makes extensive use of types like <code>LONG</code>, <code>DWORD</code>... and changing it would make a lot of code crash or not able to compile</p>\n<blockquote>\n<p id=\"so_33446588_33446727_0\">Over on Channel 9, member Beer28 wrote, \"I can't imagine there are too many problems with programs that have type widths changed.\" I got a good chuckle out of that and made a note to write up an entry on the Win64 data model.</p>\n<p id=\"so_33446588_33446727_1\">The Win64 team selected the LLP64 data model, in which all integral types remain 32-bit values and only pointers expand to 64-bit values. Why?</p>\n<p id=\"so_33446588_33446727_2\">In addition to the reasons give on that web page, another reason is that doing so avoids breaking persistence formats. For example, part of the header data for a bitmap file is defined by the following structure:</p>\n<pre><code>typedef struct tagBITMAPINFOHEADER {\n        DWORD      biSize;\n        LONG       biWidth;\n        LONG       biHeight;\n        WORD       biPlanes;\n        WORD       biBitCount;\n        DWORD      biCompression;\n        DWORD      biSizeImage;\n        LONG       biXPelsPerMeter;\n        LONG       biYPelsPerMeter;\n        DWORD      biClrUsed;\n        DWORD      biClrImportant;\n} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;\n</code></pre>\n<p id=\"so_33446588_33446727_3\">If a LONG expanded from a 32-bit value to a 64-bit value, it would not be possible for a 64-bit program to use this structure to parse a bitmap file.</p>\n</blockquote>\n<p><a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2005/01/31/363790.aspx\" rel=\"nofollow\">Why did the Win64 team choose the LLP64 model?</a></p>\n", "OwnerUserId": "995714", "PostTypeId": "2", "Id": "33446727", "Score": "4", "CreationDate": "2015-10-31T00:23:31.087", "LastActivityDate": "2015-10-31T00:23:31.087"}, "bq_ids": {"n4140": {"so_33446588_33446796_0": {"section_id": 7211, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_33446588_33446796_0": {"section_id": 6955, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_33446588_33446796_0": {"section_id": 8720, "quality": 0.9428571428571428, "length": 33}}}, "33446617": {"ParentId": "33446588", "CommentCount": "6", "Body": "<p><code>long</code> has to be at least 32-bits, at least as big as <code>int</code> and no bigger than <code>long long</code>. That's it. Period.</p>\n", "OwnerUserId": "2068573", "PostTypeId": "2", "Id": "33446617", "Score": "4", "CreationDate": "2015-10-31T00:08:32.573", "LastActivityDate": "2015-10-31T00:08:32.573"}});