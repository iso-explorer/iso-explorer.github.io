post_cb({"bq_ids": {"n4140": {"so_46242144_46242688_1": {"length": 38, "quality": 0.6666666666666666, "section_id": 224}}, "n3337": {"so_46242144_46242688_1": {"length": 41, "quality": 0.7192982456140351, "section_id": 217}}, "n4659": {"so_46242144_46242688_1": {"length": 38, "quality": 0.6666666666666666, "section_id": 232}}}, "46242144": {"ViewCount": "112", "Body": "<p>Why does the following code compile:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T in) { bar(in); }\n\nstruct type{};\nvoid bar(type) {}\nint main() { foo(type()); }\n</code></pre>\n<p>When the following does not:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T in) { bar(in); }\n\nvoid bar(int) {}\nint main() { foo(42); }\n</code></pre>\n<p>Compiling with GnuC++ 7:</p>\n<pre><code>a.cpp: In instantiation of 'void foo(T) [with T = int]':\na.cpp:9:20:   required from here\na.cpp:2:21: error: 'bar' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n void foo(T in) { bar(in); }\n                  ~~~^~~~\na.cpp:8:6: note: 'void bar(int)' declared here, later in the translation unit void bar(int) {}\n</code></pre>\n<p>I would assume that MSVC would compile both (as it does) but that GCC would reject both since GCC/Clang have proper two phase name lookup...</p>\n", "AcceptedAnswerId": "46242688", "Title": "Can't understand name lookup differences between an int and a user defined type - perhaps ADL related", "CreationDate": "2017-09-15T14:38:40.707", "Id": "46242144", "CommentCount": "6", "LastEditDate": "2017-09-15T22:30:33.307", "PostTypeId": "1", "LastEditorUserId": "5470596", "LastActivityDate": "2017-09-15T22:30:33.307", "Score": "9", "OwnerUserId": "3162383", "Tags": "<c++><templates><language-lawyer><argument-dependent-lookup><name-lookup>", "AnswerCount": "2"}, "46242605": {"Id": "46242605", "PostTypeId": "2", "Body": "<p>The 1st sample is valid, because ADL takes effect for the <a href=\"http://en.cppreference.com/w/cpp/language/unqualified_lookup#Template_definition\" rel=\"nofollow noreferrer\">name lookup</a> of dependent name in template definition; which makes it possible to find the function <code>bar</code>. (<code>bar(in)</code> depends on the template parameter <code>T</code>.)</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_46242144_46242605_0\">For a dependent name used in a template definition, the lookup is postponed until the template arguments are known, <strong>at which time ADL examines function declarations that are visible from the template definition context as well as in the template instantiation context</strong>, while non-ADL lookup only examines function declarations that are visible from the template definition context (in other words, <strong>adding a new function declaration after template definition does not make it visible except via ADL</strong>). </p>\n</blockquote>\n<p>And <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">ADL</a> doesn't work with fundamental types, that's why the 2nd sample fails.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-09-15T15:22:56.897", "Score": "4", "CreationDate": "2017-09-15T15:03:17.370", "ParentId": "46242144", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2017-09-15T15:22:56.897"}, "46242688": {"Id": "46242688", "PostTypeId": "2", "Body": "<p>The strange part is not that the <code>int</code> example fails to compile, it is that the <code>type</code> example does since <code>bar</code> is defined after <code>foo</code>. This is due to [temp.dep.candidate] (see third paragraph).  </p>\n<h3>Two-pass compilation of templates</h3>\n<p>When the compiler parses and compiles a template class or function, it looks up identifiers in two pass:</p>\n<ul>\n<li><em>Template argument independent name lookup</em>: everything that does not depend on the template arguments can be checked. Here, since <code>bar()</code> depends on a template argument, nothing is done. This lookup is done at the point of definition.</li>\n<li><em>Template argument dependent name lookup</em>: everything that could not be looked up in pass #1 is now possible. This lookup is done at the point of instantiation.</li>\n</ul>\n<p>You get an error during pass #2.</p>\n<hr>\n<h3>ADL lookup</h3>\n<p>When a function name is looked up, it is done within the current context and those of the parameters type. For instance, the following code is valid though <code>f</code> is defined in namespace <code>n</code>:</p>\n<pre><code>namespace n { struct type {}; void f(type) {}; }\nint main() { n::type t; f(t); } // f is found in ::n because type of t is in ::n\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">More about ADL (cppreference.com)</a>:</p>\n<blockquote>\n<p id=\"so_46242144_46242688_0\">Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in function-call expressions, including implicit function calls to overloaded operators. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual unqualified name lookup. </p>\n</blockquote>\n<hr>\n<h3>Two-pass compilation, ADL lookup and unqualified-id lookup</h3>\n<p>In your case, those three mechanisms collide. See [temp.dep.candidate]:</p>\n<blockquote>\n<p id=\"so_46242144_46242688_1\">For a function call that depends on a template parameter, if the function name is an unqualified-id but not a template-id, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that:<br>\n      \u2014 For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external linkage from the\n  template definition context are found.<br>\n      \u2014 For the part of the lookup using associated namespaces (3.4.2), only function declarations with external linkage found in either the\n  template definition context or the template instantiation context are\n  found.</br></br></p>\n</blockquote>\n<p>So, with <code>foo(type())</code> unqualified-id lookup kicks in and the lookup is done <em>\"in either the template definition context or the template instantiation\"</em>.<br>\nWith <code>foo(42)</code>, <code>42</code> being a fundamental type, ADL is not considered and only the <em>\"definition context\"</em> is considered.</br></p>\n</hr></hr>", "LastEditorUserId": "5470596", "LastActivityDate": "2017-09-15T15:15:08.290", "Score": "3", "CreationDate": "2017-09-15T15:09:38.150", "ParentId": "46242144", "CommentCount": "3", "OwnerUserId": "5470596", "LastEditDate": "2017-09-15T15:15:08.290"}});