post_cb({"37203478": {"Id": "37203478", "PostTypeId": "2", "Body": "<p>Your template function (i.e., <code>f</code>) takes as a parameter a <a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"nofollow noreferrer\"><em>forwarding reference</em></a> (a.k.a <em>universal reference</em>). The rules that determine the deduction of <code>T</code> are refereed as <a href=\"http://thbecker.net/articles/rvalue_references/section_08.html\" rel=\"nofollow noreferrer\"><em>reference collapsing rules</em></a>. These rules are summarized bellow:</p>\n<blockquote id=\"so_37202716_37203478_0\">\n<ol>\n<li><code>T&amp;</code> <code>&amp;</code>  becomes <code>T&amp;</code></li>\n<li><code>T&amp;</code> <code>&amp;&amp;</code> becomes <code>T&amp;</code></li>\n<li><code>T&amp;&amp;</code> <code>&amp;</code>  becomes <code>T&amp;</code></li>\n<li><code>T&amp;&amp;</code> <code>&amp;&amp;</code> becomes <code>T&amp;&amp;</code></li>\n</ol>\n</blockquote>\n<p>Now, according to the reference collapsing rules, when you supply as parameter to <code>f</code> <code>int const i</code>, <code>T</code> will be deducted to <code>int const&amp;</code>.</p>\n<p>According to the C++ standard table 52 <strong><code>is_const</code> would evaluate to <code>true</code> if <code>T</code> is <code>const</code> qualified</strong>. </p>\n<p><a href=\"https://i.stack.imgur.com/EJSV5.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/EJSV5.png\"/></a></p>\n<p>Furthermore, in the C++ standard <em>\u00a720.13.4.3/p5 Type properties [meta.unary.prop]</em> there's the following example of how <code>is_const</code> type trait works:</p>\n<blockquote>\n<p id=\"so_37202716_37203478_1\">[Example:</p>\n<pre><code>is_const&lt;const volatile int&gt;::value // true\nis_const&lt;const int*&gt;::value // false\nis_const&lt;const int&amp;&gt;::value // false\nis_const&lt;int[3]&gt;::value // false\nis_const&lt;const int[3]&gt;::value // true\n</code></pre>\n<p id=\"so_37202716_37203478_2\">\u2014 end example ]</p>\n</blockquote>\n<p>As you can see at the third line which is our case <code>is_const</code> evaluates to <code>false</code>. Why? Because the type passed in to <code>is_const</code> as a template parameter is a reference type. Now, references are inherently <code>const</code> in the sense that you can't change what they refer to, but they are not <code>const</code> qualified. Thus, <code>is_const</code> with a reference type will evaluate to <code>false</code>. </p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-05-13T07:40:39.013", "Score": "3", "CreationDate": "2016-05-13T07:11:19.293", "ParentId": "37202716", "CommentCount": "0", "LastEditDate": "2016-05-13T07:40:39.013", "OwnerUserId": "2352671"}, "bq_ids": {"n4140": {"so_37202716_37202863_0": {"length": 9, "quality": 0.5625, "section_id": 1532}, "so_37202716_37202863_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 3218}}, "n3337": {"so_37202716_37202863_0": {"length": 9, "quality": 0.5625, "section_id": 1526}, "so_37202716_37202863_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 3092}}, "n4659": {"so_37202716_37202863_0": {"length": 9, "quality": 0.5625, "section_id": 1682}, "so_37202716_37202863_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 3975}}}, "37202863": {"Id": "37202863", "PostTypeId": "2", "Body": "<p>See <a href=\"http://en.cppreference.com/w/cpp/types/is_const\" rel=\"nofollow noreferrer\">std::is_const</a>:</p>\n<blockquote>\n<p id=\"so_37202716_37202863_0\">If <code>T</code> is a const-qualified type (that is, const, or const volatile), provides the member constant value equal true. For any other type, value is false. </p>\n</blockquote>\n<p><code>t</code> is declared as a <a href=\"http://en.cppreference.com/w/cpp/language/reference#Forwarding_references\" rel=\"nofollow noreferrer\">forwarding references</a>. So for your code, <code>T</code> will be deduced as <code>const int&amp;</code>, which is a reference. Reference can't be <em>const-qualified</em>, it won't be const itself. Precisely, there's not <em>const reference</em> (i.e. <code>int&amp; const</code>), because reference couldn't be rebound again. <code>const int&amp;</code> is a reference <em>to <code>const int</code></em>; and note that <code>t</code> is thus not modifiable.</p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/dcl.ref#1\" rel=\"nofollow noreferrer\">$8.3.2/1 References [dcl.ref]</a></p>\n<blockquote>\n<p id=\"so_37202716_37202863_1\">Cv-qualified references are ill-formed except when the cv-qualifiers\n  are introduced through the use of a typedef-name ([dcl.typedef],\n  [temp.param]) or decltype-specifier ([dcl.type.simple]), in which case\n  the cv-qualifiers are ignored.</p>\n</blockquote>\n<p>More examples from <a href=\"http://en.cppreference.com/w/cpp/types/is_const#Example\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<pre><code>std::cout &lt;&lt; std::is_const&lt;int&gt;::value &lt;&lt; '\\n'; // false\nstd::cout &lt;&lt; std::is_const&lt;const int&gt;::value  &lt;&lt; '\\n'; // true\nstd::cout &lt;&lt; std::is_const&lt;const int*&gt;::value  &lt;&lt; '\\n'; // false\nstd::cout &lt;&lt; std::is_const&lt;int* const&gt;::value  &lt;&lt; '\\n'; // true\nstd::cout &lt;&lt; std::is_const&lt;const int&amp;&gt;::value  &lt;&lt; '\\n'; // false\n</code></pre>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-04-06T02:40:34.203", "Score": "14", "CreationDate": "2016-05-13T06:37:00.677", "ParentId": "37202716", "CommentCount": "0", "LastEditDate": "2017-04-06T02:40:34.203", "OwnerUserId": "3309790"}, "37209724": {"Id": "37209724", "PostTypeId": "2", "Body": "<p>The top-level answer is that <em>references</em> aren't cv-qualified. Only the types they refer to can be cv-qualified. </p>\n<p>But this is one of those times when the placement of the word <code>const</code> matters. When you call:</p>\n<pre><code>template&lt;class T&gt; \nvoid f(T&amp;&amp; t) \n</code></pre>\n<p>with an lvalue of type <code>const int</code>, what does <code>T</code> get deduced to? You might say <code>const int&amp;</code> (which is correct), but it looks like that type is <code>const (int&amp;)</code>. Hence the possible confusion about <code>T</code> being <code>const</code>.</p>\n<p>But if instead you said it deduced as <code>int const&amp;</code> (which is the same type as before), here there's no possible confusion and it's perhaps less surprising why <code>std::is_const&lt;int const&amp;&gt;</code> is <code>std::false_type</code>. </p>\n", "LastActivityDate": "2016-05-13T12:09:36.620", "CommentCount": "0", "CreationDate": "2016-05-13T12:09:36.620", "ParentId": "37202716", "Score": "0", "OwnerUserId": "2069064"}, "37202716": {"ViewCount": "717", "Body": "<p>I wrote a test program:</p>\n<pre><code>#include &lt;iostream&gt; \n#include &lt;type_traits&gt; \nusing namespace std; \ntemplate&lt;class T&gt; \nvoid f(T&amp;&amp; t) \n{ \n     cout&lt;&lt;is_const&lt;T&gt;()&lt;&lt;endl; \n     //++t; \n} \nint main() { \n     const int i=0; \n     f(i); \n     return 0; \n} \n</code></pre>\n<p>It outputs \"0\", showing <code>T</code> is not const! This is weird. Then I modified <code>f</code>:</p>\n<pre><code>template&lt;class T&gt; \nvoid f(T&amp;&amp; t) \n{ \n     cout&lt;&lt;is_const&lt;T&gt;()&lt;&lt;endl; \n     ++t; \n} \n</code></pre>\n<p>Then there's compiler error, saying we're modifying a read only <code>t</code>.\nSo is <code>t</code> modifiable or not, at all? Is there any mis-assumption in my program?</p>\n", "Title": "is_const doesn't work as expected for reference", "CreationDate": "2016-05-13T06:29:40.277", "LastActivityDate": "2017-04-06T02:40:34.203", "CommentCount": "6", "LastEditDate": "2017-04-06T01:57:15.487", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "37202716", "Score": "15", "OwnerUserId": "4927124", "Tags": "<c++><c++11><templates><const>", "AnswerCount": "5"}, "37202769": {"Id": "37202769", "PostTypeId": "2", "Body": "<p>Whether <code>t</code> is modifiable is dependent on the type of <code>T</code> which is deduced based on the type of variable passed in.  In this case you're passing in a <code>const int</code>, so <code>t</code> is of type <code>const int &amp;</code> because you're accepting it as a forwarding reference.</p>\n<p>As far as why <code>is_const</code> is returning false, that's because <code>T</code> a reference type and references are never const.</p>\n", "LastEditorUserId": "493106", "LastActivityDate": "2016-05-13T06:50:13.570", "Score": "4", "CreationDate": "2016-05-13T06:32:08.873", "ParentId": "37202716", "CommentCount": "0", "LastEditDate": "2016-05-13T06:50:13.570", "OwnerUserId": "493106"}, "37210573": {"Id": "37210573", "PostTypeId": "2", "Body": "<p>Possible solution could be to intercept const type in overload:</p>\n<pre><code>template&lt;class T&gt; \nvoid f(T&amp;&amp; t) \n{ \n     ++t; \n} \n\ntemplate&lt;class T&gt; \nvoid f(const T&amp; t) \n{ \n     std::cout &lt;&lt; \"const here\" &lt;&lt; std::endl;\n} \n</code></pre>\n<p>Then references to const objects will be handled by second function.</p>\n", "LastActivityDate": "2016-05-13T12:53:05.453", "CommentCount": "0", "CreationDate": "2016-05-13T12:53:05.453", "ParentId": "37202716", "Score": "0", "OwnerUserId": "432358"}});