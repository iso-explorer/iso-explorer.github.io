post_cb({"bq_ids": {"n4140": {"so_47492659_47492689_0": {"length": 14, "quality": 0.875, "section_id": 5361}, "so_47492659_47492689_1": {"length": 14, "quality": 0.5185185185185185, "section_id": 5361}}, "n3337": {"so_47492659_47492689_0": {"length": 14, "quality": 0.875, "section_id": 5157}, "so_47492659_47492689_1": {"length": 14, "quality": 0.5185185185185185, "section_id": 5157}}, "n4659": {"so_47492659_47492689_0": {"length": 14, "quality": 0.875, "section_id": 6789}, "so_47492659_47492689_1": {"length": 23, "quality": 0.8518518518518519, "section_id": 6789}}}, "47492710": {"Id": "47492710", "PostTypeId": "2", "Body": "<p>The other answers have pointed out the problem and how to resolve it.</p>\n<p>I want to point out that you can detect such errors by increasing the warning level on your compiler.</p>\n<p>With <code>g++ -Wall</code>, I get the following warning message:</p>\n<pre><code>socc.cc: In function \u2018int main()\u2019:\nsocc.cc:10:26: warning: ISO C++ forbids converting a string constant to \u2018char*\u2019 [-Wwrite-strings]\n     squeeze(\"qwiert\", 'i');\n</code></pre>\n", "LastActivityDate": "2017-11-26T03:21:27.737", "CommentCount": "1", "CreationDate": "2017-11-26T03:21:27.737", "ParentId": "47492659", "Score": "3", "OwnerUserId": "434551"}, "47492659": {"ViewCount": "45", "Body": "<p>I have picked up this program from somewhere and am trying to understand it.</p>\n<p>This line: <code>s[j++] = s[i];</code> is the cause of crash. My understanding is that for the first time at least the program should not crash because j will be incremented later on. First time j and i's value will be 0.</p>\n<p>So, this will be like s[0] = s[0];</p>\n<p>Why should this crash?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nvoid squeeze(char a[], char c);\n\nint main()\n{\n    squeeze(\"qwiert\", 'i');\n\n    return 0;\n}\n\nvoid squeeze(char s[], char c)\n{\n    int i, j;\n\n    for (i = j = 0; s[i] != '\\0'; i++)\n    {\n        if (s[i] != c)\n        {\n            std::cout &lt;&lt; \"\\ni: \" &lt;&lt; s[i];\n            s[j++] = s[i];\n            std::cout &lt;&lt; \"\\nj: \" &lt;&lt; s[j];\n\n            std::cout &lt;&lt; \"\\nj : \" &lt;&lt; j;\n            exit(0);\n        }\n    }\n\n    s[j] = '\\0';\n}\n</code></pre>\n<p>Output:</p>\n<p><code>i: q</code></p>\n<p>After this the program crashes.</p>\n<p>I have put the exit statement to stop the program that point to find the segfault.</p>\n", "AcceptedAnswerId": "47492689", "Title": "s[j] = s[i]; segmentaion fault while trying to copy characters", "CreationDate": "2017-11-26T03:12:40.790", "Id": "47492659", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-11-26T07:42:31.657", "Score": "2", "OwnerUserId": "462608", "Tags": "<c++><arrays><segmentation-fault>", "AnswerCount": "3"}, "47492689": {"Id": "47492689", "PostTypeId": "2", "Body": "<p>You are not permitted to change string <em>literals</em> such as with:</p>\n<pre><code>squeeze(\"qwiert\", 'i');\n</code></pre>\n<p>This is covered in pretty much all iterations of the standard<sup>(a)</sup>:</p>\n<ul>\n<li><code>C++03 2.13.4.String literals [lex.string] /2</code>;</li>\n<li><code>C++11 2.14.5.String literals [lex.string] /12</code>; and</li>\n<li><code>C++14 2.14.5.String literals [lex.string] /13</code>.</li>\n</ul>\n<p>The same wording exists in each:</p>\n<blockquote>\n<p id=\"so_47492659_47492689_0\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined. <strong><em>The effect of attempting to modify a string literal is undefined.</em></strong></p>\n</blockquote>\n<p>The wording has changed a little in the latest C++17 standard but amounts to much the same, currently <code>C++17 5.13.5.String literals [lex.string] /16</code>:</p>\n<blockquote>\n<p id=\"so_47492659_47492689_1\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a different object is unspecified. [Note: <strong><em>The effect of attempting to modify a string literal is undefined.</em></strong>  - end note]</p>\n</blockquote>\n<p>I suggest you try something like:</p>\n<pre><code>char str[] = \"qwiert\"; // Make a writable copy.\nsqueeze(str, 'i');     //   then fiddle with that.\n</code></pre>\n<hr>\n<p><sup>(a)</sup> The ISO quotes in this answer actually provides an inkling as to <em>why</em> this is the case.</p>\n<p>We haven't always had multi-gigabyte machines and it was often the case that certain steps had to be taken to optimise in early compilers (C mostly but carried forward into C++ due to it's initial implementations as a front end to C).</p>\n<p>To that end, two strings with the same characters (or overlapping characters in certain ways such as <code>\"successful\"</code> and <code>\"unsuccessful\"</code>) could share the same memory to reduce space.</p>\n<p>That, of course, meant you couldn't change one without affecting the other, which is why this rule was put in place.</p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2017-11-26T07:42:31.657", "Score": "4", "CreationDate": "2017-11-26T03:17:21.793", "ParentId": "47492659", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2017-11-26T07:42:31.657"}, "47492696": {"Id": "47492696", "PostTypeId": "2", "Body": "<p>You're passing the string constant <code>\"qwiert\"</code> to the <code>squeeze</code> function.  This function then attempts the modify that string constant, which is illegal.  This causes the core dump.</p>\n<p>For this to work, you need to pass in an array:</p>\n<pre><code>int main()\n{\n    char str[] = \"qwiert\";\n    squeeze(str, 'i');\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2017-11-26T03:17:53.813", "CommentCount": "1", "CreationDate": "2017-11-26T03:17:53.813", "ParentId": "47492659", "Score": "4", "OwnerUserId": "1687119"}});