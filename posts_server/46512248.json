post_cb({"46512580": {"ParentId": "46512248", "Score": "18", "CreationDate": "2017-10-01T12:57:25.910", "LastActivityDate": "2017-10-01T13:16:12.957", "LastEditDate": "2017-10-01T13:16:12.957", "OwnerUserId": "1120273", "LastEditorUserId": "153285", "Body": "<p>The standard doesn't say much about the <em>discarded statement</em> of an <code>if constexpr</code>. There are essentially two statements in [stmt.if] about these:</p>\n<ol>\n<li>In an enclosing template discarded statements are not instantiated.</li>\n<li>Names referenced from a discarded statement are not required ODR to be defined.</li>\n</ol>\n<p>Neither of these applies to your use: the compilers are correct to complain about the <code>constexpr</code> if initialisation. Note that you'll need to make the condition dependent on a template parameter when you want to take advantage of the <em>instantiation</em> to fail: if the value isn't dependent on a template parameter the failure happens when the template is <em>defined</em>. For example, this code still fails:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f() {\n    constexpr int x = -1;\n    if constexpr (x &gt;= 0){\n        constexpr int y = 1&lt;&lt;x;\n    }\n}\n</code></pre>\n<p>However, if you make <code>x</code> dependent on the type <code>T</code> it is OK, even when <code>f</code> is instantiated with <code>int</code>:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f() {\n    constexpr T x = -1;\n    if constexpr (x &gt;= 0){\n        constexpr int y = 1&lt;&lt;x;\n    }\n}\nint main() {\n    f&lt;int&gt;();\n}\n</code></pre>\n", "Id": "46512580", "PostTypeId": "2", "CommentCount": "4"}, "46512637": {"ParentId": "46512248", "Score": "10", "CreationDate": "2017-10-01T13:04:38.177", "Id": "46512637", "OwnerUserId": "3309790", "LastActivityDate": "2017-10-01T13:04:38.177", "Body": "<p>Note that for the statement discarded by <a href=\"http://en.cppreference.com/w/cpp/language/if#Constexpr_If\" rel=\"noreferrer\">Constexpr If</a>:</p>\n<blockquote>\n<p id=\"so_46512248_46512637_0\">the discarded statement can't be ill-formed for every possible specialization:</p>\n</blockquote>\n<p>To fix the issue you can make the statement depending on the template parameter, e.g.</p>\n<pre><code>template&lt;typename T, int X&gt; struct dependent_value { constexpr static int V = X; };\n\ntemplate &lt;typename T&gt;\nvoid foo() {\n    constexpr int x = -1;\n    if constexpr (x &gt;= 0){\n        constexpr int y = 1 &lt;&lt; dependent_value&lt;T, x&gt;::V;\n    }\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/2XPgvhpY1EGNI7ut\" rel=\"noreferrer\">LIVE</a></p>\n", "PostTypeId": "2", "CommentCount": "0"}, "46512248": {"Tags": "<c++><language-lawyer><c++1z><constexpr><if-constexpr>", "ViewCount": "925", "LastEditDate": "2017-10-01T12:58:10.950", "CreationDate": "2017-10-01T12:08:28.460", "LastEditorUserId": "817643", "Title": "Why doesn't an if constexpr make this core constant expression error dissappear?", "CommentCount": "8", "AcceptedAnswerId": "46512580", "Score": "26", "OwnerUserId": "817643", "Id": "46512248", "LastActivityDate": "2017-10-01T13:16:12.957", "Body": "<p>In reference to <a href=\"https://stackoverflow.com/questions/46510531/undefined-behavior-when-constexpr-evaluating-negative-bitshift\">this question</a>. The core constant expression that is used to initialize the <code>constexpr</code> variable <code>y</code> is ill-formed. So much is a given.</p>\n<p>But if I try to turn the <code>if</code> into an <code>if constexpr</code>:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo() {\n    constexpr int x = -1;\n    if constexpr (x &gt;= 0){\n        constexpr int y = 1 &lt;&lt; x;\n    }\n}\n\nint main(){\n    foo&lt;int&gt;();\n}\n</code></pre>\n<p>The error persists. With GCC 7.2 still giving:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error: right operand of shift expression '(1 &lt;&lt; -1)' is negative [-fpermissive]\n</code></pre>\n<p>But I thought that the semantic check should be left unpreformed on a discarded branch.</p>\n<p>Making an indirection via a <code>constexpr</code> lambda does help, however:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(){\n    constexpr int x = -1;\n    constexpr auto p = []() constexpr { return x; };\n    if constexpr (x &gt;= 0){\n        constexpr int y = 1&lt;&lt;p();\n    }\n}\n</code></pre>\n<p>The <code>constexpr</code> specifier on <code>y</code> seems to alter how the discarded branch is checked. Is this the intended behavior? </p>\n<hr>\n<p><strong>@max66</strong> was kind enough to check other implementations. He reports that the error is reproducible with both GCC (7.2.0 / Head 8.0.0) and Clang (5.0.0 / Head 6.0.0).</p>\n</hr>", "PostTypeId": "1", "FavoriteCount": "6", "AnswerCount": "3"}, "46512521": {"ParentId": "46512248", "Score": "5", "CreationDate": "2017-10-01T12:50:07.530", "Id": "46512521", "OwnerUserId": "596781", "LastActivityDate": "2017-10-01T12:50:07.530", "Body": "<p>I'm not sure why you expect the branch to not be checked. The only time an if branch is \"not checked\" is when it is part of a template and not <em>instantiated</em>, as per [stmt.if]p2:</p>\n<blockquote>\n<p id=\"so_46512248_46512521_0\">During the instantiation of an enclosing templated\n  entity (Clause 17), if the condition is not value-dependent after its instantiation, the discarded substatement\n  (if any) is not instantiated.</p>\n</blockquote>\n<p>Your code doesn't seem to be in a situation where this applies.</p>\n", "PostTypeId": "2", "CommentCount": "2"}, "bq_ids": {"n4659": {"so_46512248_46512521_0": {"length": 13, "section_id": 4773, "quality": 0.9285714285714286}}}});