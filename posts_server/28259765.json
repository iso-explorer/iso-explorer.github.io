post_cb({"28259765": {"CommentCount": "0", "ViewCount": "171", "OwnerDisplayName": "user2953119", "CreationDate": "2015-02-01T05:21:21.420", "LastActivityDate": "2016-02-21T03:10:54.867", "Title": "How is implied obeject parameter treated during the overload resolution?", "PostTypeId": "1", "Id": "28259765", "Score": "2", "Body": "<p><code>N4296::13.3.1/5 [over.match.funcs]</code> says:</p>\n<blockquote>\n<p id=\"so_28259765_28259765_0\">5 During overload resolution, the implied object argument is\n  indistinguishable from other arguments. The implicit object parameter,\n  however, retains its identity since conversions on the corresponding\n  argument shall obey these additional rules:</p>\n<p id=\"so_28259765_28259765_1\">(5.1) \u2014 no temporary object can be introduced to hold the argument for\n  the implicit object parameter; and </p>\n<p id=\"so_28259765_28259765_2\">(5.2) \u2014 no user-defined conversions\n  can be applied to achieve a type match with it.</p>\n</blockquote>\n<p>The last restriction is not clear to me, because I think it's impossible for the set of candidate functions to contain two or more functions which would have different implicit object parameters such that it's necessary to apply an implicit conversion to choose one of them. For example:</p>\n<pre><code>struct B\n{\n    void foo(int a){ }  \n};\n\nstruct C\n{\n    void foo(int a){ }\n};\n\nstruct A : B, C{ } a;\n\nint main(){ a.foo(3); }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/7cb2e2697965abdc\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>In the example the <em>implicit</em> <code>derived-to-base</code> class conversion may only be applied. Even if we define an explicit conversion it won't be applied to the implied object argument.</p>\n<p>So it's not clear what for the <code>5.2</code> rule was introduced?</p>\n", "Tags": "<c++><implicit-conversion>", "AnswerCount": "1"}, "28260767": {"ParentId": "28259765", "CommentCount": "4", "Body": "<p>The 5.2 point refers to the presence of a <em>user-defined</em> conversion operator. You did not present such a case, you just presented an ambiguous call to a member function that exists in two base classes, which involves a derived-to-base reference / pointer conversion, which is a standard conversion, not a user-defined one, and thus, has nothing to do with 5.2.</p>\n<p>What 5.2 is for is this case:</p>\n<pre><code>struct B\n{\n    void foo(int a){ }  \n};\n\nstruct A {\n    B b;\n    operator B&amp;() { return b; };\n} a;\n\nint main(){ \n    a.foo(3);                   // ERROR (because of 5.2)\n    static_cast&lt;B&amp;&gt;(a).foo(3);  // OK\n}\n</code></pre>\n<p>Point 5.2 simply means that the compiler cannot attempt to go through the implicit user-defined conversion operator (the <code>operator B&amp;()</code> member) to eventually find the candidate \"foo\" function. This is in contrast with the case where foo would be a free function like <code>void foo(B&amp;, int)</code> and being called with <code>foo(a,3)</code>, in which case, the compiler could perform the conversion of <code>a</code> to a <code>B&amp;</code> to find the foo function to be an acceptable candidate for the call. This is way this point is made, because the behaviour is different between the member function version and its equivalent free function version.</p>\n<blockquote>\n<p id=\"so_28259765_28260767_0\">because I think it's impossible for the set of candidate functions to contain two or more functions which would have different implicit object parameters </p>\n</blockquote>\n<p>BTW, you don't need to have \"two or more\" to make a set of candidate functions, a set of candidates can also be composed of only one function, or even none at all. And as Piotr S. showed, in this particular case, it is certainly possible to create a situation where multiple candidates could have different implicit object parameter types.</p>\n", "OwnerUserId": "491645", "PostTypeId": "2", "Id": "28260767", "Score": "0", "CreationDate": "2015-02-01T08:13:05.300", "LastActivityDate": "2015-02-01T08:13:05.300"}, "bq_ids": {"n4140": {"so_28259765_28259765_1": {"section_id": 569, "quality": 1.0, "length": 9}, "so_28259765_28259765_2": {"section_id": 569, "quality": 1.0, "length": 7}, "so_28259765_28259765_0": {"section_id": 569, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_28259765_28259765_1": {"section_id": 560, "quality": 1.0, "length": 9}, "so_28259765_28259765_2": {"section_id": 560, "quality": 1.0, "length": 7}, "so_28259765_28259765_0": {"section_id": 560, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_28259765_28259765_1": {"section_id": 592, "quality": 0.6666666666666666, "length": 6}, "so_28259765_28259765_2": {"section_id": 592, "quality": 1.0, "length": 7}, "so_28259765_28259765_0": {"section_id": 592, "quality": 0.7916666666666666, "length": 19}}}});