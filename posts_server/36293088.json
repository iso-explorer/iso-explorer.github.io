post_cb({"bq_ids": {"n4140": {"so_36293088_36293088_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 142}, "so_36293088_36293522_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 142}, "so_36293088_36293522_1": {"length": 10, "quality": 1.0, "section_id": 327}}, "n3337": {"so_36293088_36293522_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 136}, "so_36293088_36293522_1": {"length": 10, "quality": 1.0, "section_id": 317}}, "n4659": {"so_36293088_36293088_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 146}, "so_36293088_36293522_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 146}, "so_36293088_36293522_1": {"length": 8, "quality": 0.8, "section_id": 335}}}, "36293088": {"ViewCount": "210", "Body": "<p>The following code:</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate &lt;size_t N,\n          typename T,\n          T first,\n          T... rest&gt;\nstruct A {\n};\n\ntemplate&lt;typename T,\n         T... args&gt;\nstruct A&lt;0, T, args...&gt; {\n};\n\nint main () {\n    A&lt;0, int, 1&gt; a0;\n    A&lt;2, int, 1, 2&gt; a2;\n    return 0;\n}\n</code></pre>\n<p>...does not compile with <code>g++</code> (version <code>5.1.0</code> and <code>5.3.0</code>) due to:</p>\n<blockquote>\n<p id=\"so_36293088_36293088_0\">error: partial specialization is not more specialized than the primary template because it replaces multiple parameters with a pack expansion</p>\n</blockquote>\n<p>...but compiles with <code>clang</code>.</p>\n<p>Is it allowed to declare such partial specializations?</p>\n<p><em>Side note: Actually, the specialization is dangerous since <code>A&lt;0, int&gt;</code> fails to compile with both compiler (wrong number of template arguments).</em></p>\n", "AcceptedAnswerId": "36293522", "Title": "gcc vs clang behavior on partial specialization with variadic arguments plus extra argument of same type", "CreationDate": "2016-03-29T19:10:07.077", "Id": "36293088", "CommentCount": "4", "LastEditDate": "2016-03-29T19:13:24.733", "PostTypeId": "1", "LastEditorUserId": "2666289", "LastActivityDate": "2016-03-29T19:33:10.683", "Score": "8", "OwnerUserId": "2666289", "Tags": "<c++><c++11><variadic-templates><template-specialization>", "AnswerCount": "2"}, "36293525": {"Id": "36293525", "PostTypeId": "2", "Body": "<p>consider:</p>\n<pre><code>template &lt;class T, T first, T... rest&gt;\nstruct X{};\n\ntemplate&lt;class T, T... rest&gt;\nstruct X&lt;T, rest...&gt;{};\n</code></pre>\n<p>Exact same error.\nSince <code>first</code> can be interpreted as first element of the <code>rest</code> pack, it makes no difference in such specialization. If you add <code>first</code> in the specialization - well, that's the primary template. In your specialization though you can add <code>first</code>:</p>\n<pre><code>//specialization\ntemplate&lt;typename T,\n         T first,\n         T... args&gt;\nstruct A&lt;0, T, first, args...&gt; {\n};\n</code></pre>\n", "LastActivityDate": "2016-03-29T19:33:10.683", "Score": "0", "CreationDate": "2016-03-29T19:33:10.683", "ParentId": "36293088", "CommentCount": "0", "OwnerUserId": "5405086"}, "36293522": {"Id": "36293522", "PostTypeId": "2", "Body": "<p>gcc is correct, the code is ill-formed because the specialization isn't actually more specialized. </p>\n<hr/>\n<p>The rule, from [temp.class.spec] is (as a result of <a href=\"http://wg21.link/cwg1495\">DR 1495</a>, h/t T.C. for the link):</p>\n<blockquote>\n<p id=\"so_36293088_36293522_0\">Within the argument list of a class template partial specialization, the following restrictions apply: [...] The specialization shall be more specialized than the primary template (14.5.5.2).</p>\n</blockquote>\n<p>In order to determine that, we would rewrite the two as synthesized function templates:</p>\n<pre><code>template &lt;size_t N, class T, T first, T... rest&gt;\nvoid __f(A&lt;N, T, first, rest...&gt; );  // primary\n\ntemplate &lt;class T, T... args&gt;\nvoid __f(A&lt;0, T, args...&gt; );         // specialization\n</code></pre>\n<p>and then go through the partial ordering rules. That, in turn, involves synthesizing new types/values for each of the template parameters and seeing if deduction can succeed in either direction. </p>\n<p>Definitely, the deduction of the specialization fails with the primary (due to <code>N</code> vs <code>0</code>). In the other direction, from [temp.deduct.partial]:</p>\n<blockquote>\n<p id=\"so_36293088_36293522_1\">If <code>A</code> was transformed from a function parameter pack and <code>P</code> is not a parameter pack, type deduction fails.</p>\n</blockquote>\n<p>Since we're trying to deduce <code>T first</code> against a pack, deduction fails in this direction as well. This means that neither of the synthesized function templates is more specialized than other, which in turn means that the class template specialization is not more specialized than the primary template. Hence, gcc would be correct to reject.</p>\n", "LastActivityDate": "2016-03-29T19:33:04.277", "Score": "8", "CreationDate": "2016-03-29T19:33:04.277", "ParentId": "36293088", "CommentCount": "0", "OwnerUserId": "2069064"}});