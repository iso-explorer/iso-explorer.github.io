post_cb({"21059115": {"ViewCount": "16263", "Body": "<p>My programs looks like below</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nclass A {\npublic:\n    void foo(int n ) { std::cout &lt;&lt; n &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a;\n\n    std::thread t1(&amp;A::foo, std::ref(a), 100);\n\n    t1.join();\n    return 0;\n}\n</code></pre>\n<p>When I compile it using the following command I get errors</p>\n<pre><code>g++ -o main main.cc -lpthread -std=c++11\n</code></pre>\n<p>Error:</p>\n<pre><code>In file included from /usr/local/include/c++/4.8.2/thread:39:0,\n                  from check.cc:2:\n/usr/local/include/c++/4.8.2/functional: In instantiation of \u2018struct std::_Bind_simple&lt;std::_Mem_fn&lt;void (A::*)(int)&gt;(std::reference_wrapper&lt;A&gt;, int)&gt;\u2019:\n/usr/local/include/c++/4.8.2/thread:137:47:   required from \u2018std::thread::thread(_Callable&amp;&amp;, _Args&amp;&amp; ...) [with _Callable = void (A::*)(int); _Args = {std::reference_wrapper&lt;A&gt;, int}]\u2019\ncheck.cc:13:42:   required from here\n/usr/local/include/c++/4.8.2/functional:1697:61: error\uff1ano type named \u2018type\u2019 in \u2018class std::result_of&lt;std::_Mem_fn&lt;void (A::*)(int)&gt;(std::reference_wrapper&lt;A&gt;, int)&gt;\u2019\n        typedef typename result_of&lt;_Callable(_Args...)&gt;::type result_type;\n                                                              ^\n/usr/local/include/c++/4.8.2/functional:1727:9: error\uff1ano type named \u2018type\u2019 in \u2018class std::result_of&lt;std::_Mem_fn&lt;void (A::*)(int)&gt;(std::reference_wrapper&lt;A&gt;, int)&gt;\u2019\n          _M_invoke(_Index_tuple&lt;_Indices...&gt;)\n          ^\n</code></pre>\n", "AcceptedAnswerId": "21059146", "Title": "c++11 Thread class how to use a class member function", "CreationDate": "2014-01-11T06:05:29.273", "Id": "21059115", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-01-11T06:07:07.900", "LastEditorUserId": "596781", "LastActivityDate": "2017-04-04T23:43:22.770", "Score": "18", "OwnerUserId": "3182438", "Tags": "<c++><c++11>", "AnswerCount": "6"}, "21059616": {"Id": "21059616", "PostTypeId": "2", "Body": "<p><strong>EDIT: RETRACTION</strong></p>\n<p>Kerrek is correct here: I erroneously assumed that the <code>std::thread</code> constructor and <code>std::bind</code> were by design identical interfaces. However, the automatic conversion of arguments from <code>reference_wrapper&lt;A&gt;</code> to <code>A&amp;</code> is specified for only <code>std::bind</code> in [func.bind.bind]/10:</p>\n<blockquote>\n<p id=\"so_21059115_21059616_0\">The values of the <em>bound arguments</em> <code>v1, v2, ..., vN</code> and their corresponding types <code>V1, V2, ..., VN</code> depend on the types <code>TiD</code> derived from the call to <code>bind</code> and the <em>cv</em>-qualifiers <em>cv</em> of the call wrapper <code>g</code> as follows:</p>\n<ul>\n<li>if <code>TiD</code> is <code>reference_wrapper&lt;T&gt;</code>, the argument is <code>tid.get()</code> and its type <code>Vi</code> is <code>T&amp;</code>;</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>So this particular use of <code>reference_wrapper&lt;A&gt;</code> is <em>not</em> supported by <code>std::thread</code>, but <em>is</em> supported by <code>std::bind</code>. The fact that <code>std::thread</code> behaves identically to <code>std::bind</code> in this instance in other/older compilers is the bug, not the behavior of 4.8 line GCC releases.</p>\n<p>I'll leave the incorrect answer here with this explanation in hopes that others won't make this same mistake in the future.</p>\n<p><strong>Short (but INCORRECT) answer</strong></p>\n<p>This is apparently a bug in the standard library included with GCC 4.8. The code is correctly compiled by:</p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/32d2a69ced1eec67\" rel=\"nofollow noreferrer\">GCC 4.7</a></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/f1184cec183a6654\" rel=\"nofollow noreferrer\">GCC 4.6</a></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/aa54ac837830a10d\" rel=\"nofollow noreferrer\">clang r198621 (a post-3.4 release trunk revision)</a></li>\n<li><a href=\"http://rextester.com/CPODMR87328\" rel=\"nofollow noreferrer\">MSVC2013</a></li>\n</ul>\n<p><strong>Long (and also INCORRECT) answer:</strong></p>\n<p>The effects of the <code>std::thread</code> constructor</p>\n<pre><code>template &lt;class F, class ...Args&gt;\nexplicit thread(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre>\n<p>are detailed in C++11 30.3.1.2 [thread.thread.constr]/4:</p>\n<blockquote>\n<p id=\"so_21059115_21059616_1\">The new thread of execution executes</p>\n<pre><code>INVOKE(DECAY_COPY(std::forward&lt;F&gt;(f)),\n       DECAY_COPY(std::forward&lt;Args&gt;(args))...)\n</code></pre>\n<p id=\"so_21059115_21059616_2\">with the calls to <code>DECAY_COPY</code> being evaluated in the constructing thread.</p>\n</blockquote>\n<p><code>DECAY_COPY</code> is described in 30.2.6 [thread.decaycopy]/1:</p>\n<blockquote>\n<p id=\"so_21059115_21059616_3\">In several places in this Clause the operation <code>DECAY_COPY(x)</code> is used. All such uses mean call the function <code>decay_copy(x)</code> and use the result, where <code>decay_copy</code> is defined as follows:</p>\n<pre><code>template &lt;class T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)\n{ return std::forward&lt;T&gt;(v); }\n</code></pre>\n</blockquote>\n<p>In the invocation in the OP <code>std::thread t1(&amp;A::foo, std::ref(a), 100);</code> all three arguments are rvalues that <code>DECAY_COPY</code> will replicate into objects in the new thread's environment before the invocation, whose effect is described in 20.8.2 [func.require]/1:</p>\n<blockquote>\n<p id=\"so_21059115_21059616_4\">Define <code>INVOKE(f, t1, t2, ..., tN)</code> as follows:</p>\n<ul>\n<li><code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</li>\n<li><code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>For the code in the OP, <code>f</code> is a pointer to member function of class <code>A</code> with value <code>&amp;A::foo</code>, <code>t1</code> is an lvalue <code>reference_wrapper&lt;A&gt;</code> whose stored reference refers to <code>a</code>, and <code>t2</code> is an <code>int</code> with value <code>100</code>. The second bullet of 20.8.2/1 applies. Since <code>t1</code> is a <code>reference_wrapper</code>, <code>*t1</code> evaluates to the stored reference (per 20.8.3.3/1) and the invocation in the new thread is effectively</p>\n<pre><code>(a.*&amp;A::foo)(100);\n</code></pre>\n<p>So yes, the standard describes the behavior of the OP exactly as expected.</p>\n<p>EDIT: Oddly, <a href=\"http://coliru.stacked-crooked.com/a/e2fb813e412e9802\" rel=\"nofollow noreferrer\">GCC 4.8 correctly compiles the very similar example</a>:</p>\n<pre><code>class A {\npublic:\n    void foo(int n) { std::cout &lt;&lt; n &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a;\n    auto foo = std::bind(&amp;A::foo, std::ref(a), 100);\n    foo();\n}\n</code></pre>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-01-20T09:34:45.390", "Score": "10", "CreationDate": "2014-01-11T07:02:37.170", "ParentId": "21059115", "CommentCount": "4", "OwnerUserId": "923854", "LastEditDate": "2014-01-20T09:34:45.390"}, "21059146": {"Id": "21059146", "PostTypeId": "2", "Body": "<p>This isn't the right place for a reference wrapper. A simple pointer suffices, though, and achieves the desired result:</p>\n<pre><code>std::thread t1(&amp;A::foo, &amp;a, 100);\n</code></pre>\n", "LastActivityDate": "2014-01-11T06:08:22.107", "CommentCount": "1", "CreationDate": "2014-01-11T06:08:22.107", "ParentId": "21059115", "Score": "23", "OwnerUserId": "596781"}, "bq_ids": {"n4140": {"so_21059115_21059616_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 2689}, "so_21059115_21059616_1": {"length": 4, "quality": 0.8, "section_id": 2710}, "so_21059115_21059616_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 4641}, "so_21059115_21059616_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2710}}, "n3337": {"so_21059115_21059616_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 2651}, "so_21059115_21059616_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2671}, "so_21059115_21059616_1": {"length": 4, "quality": 0.8, "section_id": 2671}, "so_21059115_21059616_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 4452}}, "n4659": {"so_21059115_21059616_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 3429}, "so_21059115_21059616_1": {"length": 4, "quality": 0.8, "section_id": 3450}, "so_21059115_21059616_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6011}, "so_21059115_21059616_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3450}}}, "21239387": {"Id": "21239387", "PostTypeId": "2", "Body": "<p>Regarding your question title I would use a lambda for thread construction. With or without references, via calling member functions or binding parameters.</p>\n<pre><code> std::thread t1([&amp;] { a.foo(100); });\n</code></pre>\n", "LastActivityDate": "2014-01-20T16:37:34.250", "CommentCount": "1", "CreationDate": "2014-01-20T16:37:34.250", "ParentId": "21059115", "Score": "9", "OwnerUserId": "311618"}, "38410317": {"Id": "38410317", "PostTypeId": "2", "Body": "<p>Just wanted to add that i got the same error just by giving incompatible arguments to std::bind/std::thread. Like giving a pointer to a base class when a more specific pointer was in the signature of the actual function.</p>\n", "LastActivityDate": "2016-07-16T10:42:30.827", "CommentCount": "0", "CreationDate": "2016-07-16T10:42:30.827", "ParentId": "21059115", "Score": "0", "OwnerUserId": "1131588"}, "21066704": {"Id": "21066704", "PostTypeId": "2", "Body": "<p>GCC 4.8 is correct, <code>std::thread</code> and other components defined in terms of <em>INVOKE</em> must not be implemented in terms of <code>std::bind</code>.  They must not invoke nested bind expressions and must use perfect forwarding for bound arguments (rather than forwarding them as lvalues as <code>std::bind</code> does), and additionally as you discovered they do not unwrap <code>reference_wrapper</code> objects.  In GCC 4.8 I introduced an internal implementation detail, <code>__bind_simple</code>, for use by <code>std::thread</code> etc. that doesn't have the full <code>std::bind</code> behaviour.</p>\n<p>While the other differences from <code>std::bind</code> are desirable, I think the <em>INVOKE</em> operation should still support <code>reference_wrapper</code> objects, so I filed a defect report, see <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2219\" rel=\"nofollow noreferrer\">LWG 2219</a>.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2015-12-11T18:40:33.513", "Score": "7", "CreationDate": "2014-01-11T19:14:58.503", "ParentId": "21059115", "CommentCount": "3", "OwnerUserId": "981959", "LastEditDate": "2015-12-11T18:40:33.513"}, "32917916": {"Id": "32917916", "PostTypeId": "2", "Body": "<p>Ok the problem is ref(obj) returns a reference (alias) to an object not a pointer(address)! to work with threads we need pointers not references! See Below a handy program to use function pointers with threads:</p>\n<pre><code>    #include &lt;iostream&gt;\n    #include \"vector\"\n    #include \"string\"\n    #include \"thread\"\n    #include \"atomic\"\n    #include \"functional\"\n\n    #include \"stdlib.h\"\n    #include \"stdio.h\"\n    #include \"string.h\"\n    #include \"assert.h\"\n\n    using namespace std;\n    //__________________________Global variables_________________________________________________\n\n    atomic&lt;int&gt; var(0);\n\n    //__________________________class____________________________________________________________\n\n    class C\n    {\n    public:\n\n        C()\n        {}\n\n        static void addition (int a, int b)\n        {\n            for(int i= 0; i&lt; a+b; i++)\n                var++;\n        }\n\n        void subtraction (int a, int b)\n        {\n            for(int i= 0; i&lt; a+b; i++)\n                var--;\n        }\n    };\n\n    class D : std::atomic&lt;int&gt;\n    {\n    public:\n        D() : std::atomic&lt;int&gt;(0)\n        {}\n\n        void increase_member (int n)\n        {\n            for (int i=0; i&lt;n; ++i)\n                fetch_add(1);\n        }\n\n        int get_atomic_val()\n        {\n            return this-&gt;load();\n        }\n    };\n\n    //________________________________functions________________________________________________\n\n    void non_member_add (int a, int b)\n    {\n        for(int i= 0; i&lt; a+b; i++)\n            var++;\n    }\n\n    //__________________________________main____________________________________________________\n\n    int main ()\n    {\n        int a=1, b=5;\n\n    // (I)...........................................static public member function (with no inheritance).........................................\n\n        void (* add_member_func_ptr)(int,int) = C::addition;            // pointer to a static public member function\n\n        //defining thread pool for ststic public member_add_ptr\n\n        vector&lt;thread&gt; thread_pool;\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(add_member_func_ptr,a,b));\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"static public member function (with no inheritance)\\t\"&lt;&lt;var&lt;&lt;endl;\n\n        //defining thread pool for ststic public member function\n\n        var=0;\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(C::addition,a,b));             //void (* add_member_func_ptr)(int,int) is equal to C::addition\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"static public member function (with no inheritance)\\t\"&lt;&lt;var&lt;&lt;endl;\n\n    // (II)..............................................non-static public member function (with no inheritance)...................................\n\n        C bar;\n\n        void (C::* sub_member_func_ptr)(int,int) = &amp; C::subtraction;            // pointer to a non-static public member function\n\n        var=0;\n\n        //defining thread pool for non-ststic public member function\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(sub_member_func_ptr,bar,a,b));\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"non-static public member function (with no inheritance)\\t\"&lt;&lt;var&lt;&lt;endl;\n\n        var=0;\n\n        //defining thread pool for non-ststic public member function\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(&amp;C::subtraction,bar,a,b));         //void (C::* sub_member_func_ptr)(int,int) equals &amp; C::subtraction;\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"non-static public member function (with no inheritance)\\t\"&lt;&lt;var&lt;&lt;endl;\n\n\n    // (III)................................................non-member function .................................................\n\n        void (* non_member_add_ptr)(int,int) = non_member_add;              //pointer to a non-member function\n\n        var=0;\n\n        //defining thread pool for non_member_add\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(non_member_add,a,b));\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"non-member function\\t\"&lt;&lt;var&lt;&lt;endl&lt;&lt;endl;\n\n    // (IV)...........................................non-static public member function (with inheritance).........................\n\n        D foo;\n\n        void (D::* member_func_ptr) (int) = &amp; D::increase_member;                  //pointer to a non-static public member function of a derived class\n\n        //defining thread pool for non-ststic public member function of a derived class\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            thread_pool.push_back(thread(member_func_ptr,&amp;foo,10));                 //use &amp;foo because this is derived class!\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"non-static public member function (with inheritance)\\t\"&lt;&lt;foo.get_atomic_val()&lt;&lt;endl;\n\n        //defining thread pool for non-ststic public member function\n\n        D poo;\n\n        thread_pool.clear();\n\n        for (int i=0; i&lt;5; i++)\n        {\n            reference_wrapper&lt;D&gt; poo_ref= ref(poo);\n\n            D&amp; poo_ref_= poo_ref.get();             //ref(obj) returns a reference (alias) to an object not a pointer(address)!\n\n            D* d_ptr= &amp;poo;                         //to work with thread we need pointers not references!\n\n\n            thread_pool.push_back(thread(&amp;D::increase_member, d_ptr,10));             //void (D::* member_func_ptr) (int) equals &amp; D::increase_member;\n        }\n\n        for(thread&amp; thr: thread_pool)\n            thr.join();\n\n        cout&lt;&lt;\"non-static public member function (with inheritance)\\t\"&lt;&lt;poo.get_atomic_val()&lt;&lt;endl&lt;&lt;endl;\n\n\n        return 0;\n    }\n</code></pre>\n", "LastEditorUserId": "2545305", "LastActivityDate": "2017-04-04T23:43:22.770", "Score": "0", "CreationDate": "2015-10-03T01:08:29.487", "ParentId": "21059115", "CommentCount": "0", "OwnerUserId": "2545305", "LastEditDate": "2017-04-04T23:43:22.770"}});