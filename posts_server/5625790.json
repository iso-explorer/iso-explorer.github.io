post_cb({"5625834": {"ParentId": "5625790", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_5625790_5625834_0\">Why does assigning <code>d</code> to <code>c</code> not use the const overloaded assignment operator provided?</p>\n</blockquote>\n<p>The implicitly-declared copy assignment operator, which is declared as follows, is still generated:</p>\n<pre><code>Wrapper&amp; operator=(const Wrapper&amp;);\n</code></pre>\n<p>An operator template does not suppress generation of the implicitly-declared copy assignment operator.  Since the argument (a const-qualified <code>Wrapper</code>) is an exact match for the parameter of this operator (<code>const Wrapper&amp;</code>), it is selected during overload resolution.  </p>\n<p>The operator template is not selected and there is no ambiguity because--all other things being equal--a nontemplate is a better match during overload resolution than a template.</p>\n<blockquote>\n<p id=\"so_5625790_5625834_1\">Why does assigning <code>b</code> to <code>a</code> not use the default copy assignment operator?</p>\n</blockquote>\n<p>The argument (a non-const-qualified <code>Wrapper</code>) is a better match for the operator template that takes a <code>Wrapper&lt;U&gt;&amp;</code> than for the implicitly-declared copy assignment operator (which takes a <code>const Wrapper&lt;U&gt;&amp;</code>.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2011-04-11T19:42:10.353", "Id": "5625834", "Score": "18", "CreationDate": "2011-04-11T18:36:21.787", "LastActivityDate": "2011-04-11T19:42:10.353"}, "5625790": {"CommentCount": "0", "AcceptedAnswerId": "5625834", "PostTypeId": "1", "LastEditorUserId": "2023370", "CreationDate": "2011-04-11T18:32:56.307", "LastActivityDate": "2015-12-27T01:34:24.107", "LastEditDate": "2015-12-27T01:34:24.107", "ViewCount": "5428", "FavoriteCount": "3", "Title": "Template assignment operator overloading mystery", "Id": "5625790", "Score": "7", "Body": "<p>I have a simple struct <code>Wrapper</code>, distinguished by two templated assignment operator overloads:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Wrapper {\n\n  Wrapper() {}\n\n  template &lt;typename U&gt;\n  Wrapper &amp;operator=(const Wrapper&lt;U&gt; &amp;rhs) {\n    cout &lt;&lt; \"1\" &lt;&lt; endl;\n    return *this;\n  }\n  template &lt;typename U&gt;\n  Wrapper &amp;operator=(Wrapper&lt;U&gt; &amp;rhs) {\n    cout &lt;&lt; \"2\" &lt;&lt; endl;\n    return *this;\n  }\n};\n</code></pre>\n<p>I then declare a and b:</p>\n<pre><code>Wrapper&lt;float&gt; a, b;\na = b;\n</code></pre>\n<p>assigning <code>b</code> to <code>a</code> will use the non-const templated assignment operator overload from above, and the number \"2\" is displayed.</p>\n<p>What puzzles me is this: If I declare <code>c</code> and <code>d</code>,</p>\n<pre><code>Wrapper&lt;float&gt; c;\nconst Wrapper&lt;float&gt; d;\nc = d;\n</code></pre>\n<p>and assign <code>d</code> to <code>c</code>, neither of the two assignment operator overloads is used, and no output is displayed; so the default copy assignment operator is invoked. Why does assigning <code>d</code> to <code>c</code> not use the const overloaded assignment operator provided? Or instead, why does assigning <code>b</code> to <code>a</code> <em>not</em> use the default copy assignment operator?</p>\n", "Tags": "<c++><templates><assignment-operator>", "OwnerUserId": "2023370", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5625790_5625894_1": {"section_id": 467, "quality": 1.0, "length": 11}, "so_5625790_5625894_0": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}, "so_5625790_5625834_1": {"section_id": 469, "quality": 0.625, "length": 5}}, "n3337": {"so_5625790_5625894_1": {"section_id": 458, "quality": 1.0, "length": 11}, "so_5625790_5625894_0": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}, "so_5625790_5625834_1": {"section_id": 460, "quality": 0.625, "length": 5}}, "n4659": {"so_5625790_5625894_1": {"section_id": 490, "quality": 1.0, "length": 11}, "so_5625790_5625894_0": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}, "so_5625790_5625834_1": {"section_id": 492, "quality": 0.625, "length": 5}}}, "5625894": {"ParentId": "5625790", "CommentCount": "2", "Body": "<p>From the C++03 standard, \u00a712.8/9:</p>\n<blockquote>\n<p id=\"so_5625790_5625894_0\">A user-declared copy assignment operator <code>X::operator=</code> is a non-static <strong>non-template</strong> member function of class <code>X</code> with exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>.</p>\n</blockquote>\n<p>And \u00a712.8/10:</p>\n<blockquote>\n<p id=\"so_5625790_5625894_1\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly.</p>\n</blockquote>\n<p>The fact that your <code>operator=</code> is a template makes it <strong>not</strong> a copy assignment operator, so the class' implicit copy assignment operator is still generated by the compiler.</p>\n", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "5625894", "Score": "6", "CreationDate": "2011-04-11T18:41:35.467", "LastActivityDate": "2011-04-11T18:41:35.467"}});