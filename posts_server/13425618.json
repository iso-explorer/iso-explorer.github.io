post_cb({"13425618": {"CommentCount": "9", "ViewCount": "376", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-11-16T22:51:53.133", "LastActivityDate": "2012-11-17T01:01:10.263", "Title": "Function with default parameter as template type", "AcceptedAnswerId": "13425747", "LastEditDate": "2012-11-17T00:42:18.350", "Id": "13425618", "Score": "4", "Body": "<p>I am trying to use a function with a default argument as a function pointer template parameter:</p>\n<pre><code>template &lt;void (*F)()&gt;\nclass A {};\n\nvoid foo1(int a = 0) {}\nvoid foo2() {}\n\nint main() \n{\n    //A&lt;foo1&gt; a1;   &lt;-- doesn't work\n    A&lt;foo2&gt; a2;\n}\n</code></pre>\n<p>The compiler error is:</p>\n<blockquote>\n<p id=\"so_13425618_13425618_0\">main.cpp:7:7: error: could not convert template argument \u2018foo1\u2019 to \u2018void (*)()\u2019</p>\n</blockquote>\n<p>Is there specific syntax for this to work?  Or a specific language limitation?  Otherwise, the alternative is to have two separate functions instead of a default parameter:</p>\n<pre><code>void foo1(int a) {}\nvoid foo1() { foo1(0); }\n</code></pre>\n<p><strong>Update</strong>\nI understand that the signatures are different, but I'm wondering if there is a way to make this work conveniently without needing to modify all the functions with default parameters?</p>\n", "Tags": "<c++><templates><overloading>", "OwnerUserId": "507606", "AnswerCount": "5"}, "13425697": {"ParentId": "13425618", "CommentCount": "0", "Body": "<p>Default argument values are not part of the function type. You can't use <code>foo1</code> as a function taking no arguments, because it does take one argument. The argument gets filled in for you if you don't mention it, but it's still there.</p>\n<p>Your workaround involving a dispatching function sounds like a good solution. It could even be templated if you need it a lot.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "13425697", "Score": "2", "CreationDate": "2012-11-16T23:00:09.843", "LastActivityDate": "2012-11-16T23:00:09.843"}, "13425698": {"ParentId": "13425618", "CommentCount": "0", "Body": "<p>The signature of <code>foo1</code> is <code>void(int)</code>, not <code>void()</code>. This is why it isn't convertible to <code>void(*)()</code>.</p>\n<p>You are confusing default arguments with overloading.</p>\n", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "13425698", "Score": "3", "CreationDate": "2012-11-16T23:00:17.130", "LastActivityDate": "2012-11-16T23:00:17.130"}, "13425747": {"ParentId": "13425618", "LastEditDate": "2012-11-16T23:10:32.040", "CommentCount": "5", "CreationDate": "2012-11-16T23:05:24.157", "OwnerUserId": "335858", "LastEditorUserId": "335858", "PostTypeId": "2", "Id": "13425747", "Score": "2", "Body": "<p>According to section 8.3.6 of the C++ standard,</p>\n<blockquote>\n<p id=\"so_13425618_13425747_0\">If an expression is specified in a parameter declaration this expression is used as a default argument. Default arguments will be used in calls where trailing arguments are missing.</p>\n</blockquote>\n<p>Since <code>A&lt;foo1&gt;</code> is <em>not</em> a call of the function, default arguments are ignored. In fact, they are ignored in all contexts except the calls of the function, for example</p>\n<pre><code>typedef void (*FFF)();\nFFF x = foo1;\n</code></pre>\n<p>will not compile, and produce the same message that you get when trying to use <code>foo1</code> as a template parameter:</p>\n<pre><code>error: invalid conversion from \u2018void (*)(int)\u2019 to \u2018void (*)()\u2019\n</code></pre>\n<p>This makes sense, because evaluating default arguments is a separate step in the invocation:</p>\n<blockquote>\n<p id=\"so_13425618_13425747_1\">8.3.6.9: Default arguments will be evaluated each time the function is called.</p>\n</blockquote>\n<p>The presence of default arguments does not alter the signature of your function. For example, you cannot use a single-argument function with a default argument to override a no-argument virtual member function.</p>\n", "LastActivityDate": "2012-11-16T23:10:32.040"}, "13425738": {"ParentId": "13425618", "LastEditDate": "2012-11-16T23:20:45.430", "CommentCount": "1", "CreationDate": "2012-11-16T23:04:45.720", "OwnerUserId": "1428922", "LastEditorUserId": "1428922", "PostTypeId": "2", "Id": "13425738", "Score": "1", "Body": "<p>It won't compile because <code>foo1</code> has signature:</p>\n<pre><code>void foo1(int a);\n</code></pre>\n<p>which you're trying to stick into a pointer to:</p>\n<pre><code>void F()\n</code></pre>\n<p>The function signatures don't match. The fact that <code>foo1</code> has a default parameter doesn't change the function's signature (it still can take in an <code>int</code>).</p>\n<h2>A More Generic Solution</h2>\n<p>I'd say forget about the templates, they're only limiting you here.</p>\n<p>Personally, the way I solve the callback problem is using <strong>function objects</strong> with <strong>argument binding</strong>. It can be done using the <a href=\"http://www.boost.org/doc/libs/1_51_0/doc/html/function/tutorial.html\" rel=\"nofollow\">boost::function</a> library, and binding default arguments with <a href=\"http://www.boost.org/doc/libs/1_51_0/libs/bind/bind.html\" rel=\"nofollow\">boost::bind</a> (or <a href=\"http://www.cplusplus.com/reference/std/functional/bind1st/\" rel=\"nofollow\"><code>std::bind1st</code></a> and <code>std::bind2nd</code>).</p>\n<p>These boost libraries are also built-in to the new C++11 standard, as <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function\" rel=\"nofollow\"><code>std::function</code></a>, and <a href=\"http://en.cppreference.com/w/cpp/utility/functional/bind\" rel=\"nofollow\"><code>std::bind</code></a>.</p>\n<p>It's well worth taking a look at this, as it let's you do some very nice things, like providing default arguments to functions, or use class member functions as callbacks.</p>\n<p>The sites I've linked to all have lots of example code, and the boost links have tutorials.</p>\n", "LastActivityDate": "2012-11-16T23:20:45.430"}, "bq_ids": {"n4140": {"so_13425618_13425747_0": {"section_id": 3252, "quality": 0.7333333333333333, "length": 11}, "so_13425618_13425708_0": {"section_id": 3242, "quality": 0.8125, "length": 26}, "so_13425618_13425747_1": {"section_id": 3260, "quality": 0.5555555555555556, "length": 5}, "so_13425618_13425708_1": {"section_id": 3252, "quality": 1.0, "length": 6}}, "n3337": {"so_13425618_13425747_0": {"section_id": 3124, "quality": 0.7333333333333333, "length": 11}, "so_13425618_13425708_0": {"section_id": 3115, "quality": 0.8125, "length": 26}, "so_13425618_13425747_1": {"section_id": 3132, "quality": 0.7777777777777778, "length": 7}, "so_13425618_13425708_1": {"section_id": 3124, "quality": 1.0, "length": 6}}, "n4659": {"so_13425618_13425747_0": {"section_id": 4010, "quality": 0.7333333333333333, "length": 11}, "so_13425618_13425708_0": {"section_id": 4000, "quality": 0.75, "length": 24}, "so_13425618_13425708_1": {"section_id": 4010, "quality": 1.0, "length": 6}, "so_13425618_13425747_1": {"section_id": 4018, "quality": 0.5555555555555556, "length": 5}}}, "13425708": {"ParentId": "13425618", "LastEditDate": "2012-11-16T23:13:23.527", "CommentCount": "0", "CreationDate": "2012-11-16T23:01:12.697", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "PostTypeId": "2", "Id": "13425708", "Score": "2", "Body": "<p>I'm pretty sure that a function pointer has signature of the function with all default parameters expanded and function pointers cannot convert to a function pointer with a different signature. Finding this in the standard is a different matter, though...</p>\n<p>I think the relevant clause from the standard is 8.3.5 [dcl.fct] paragraph 6:</p>\n<blockquote>\n<p id=\"so_13425618_13425708_0\">... The return type, the parameter-type-list, the ref-qualifier, and the cv-qualifier-seq, but not the default arguments (8.3.6) or the exception specification (15.4), are part of the function type. [ Note: Function types are checked during the assignments and initializations of pointers to functions, references to functions, and pointers to member functions. \u2014end note ]</p>\n</blockquote>\n<p>Note that <em>default arguments</em> are the guys of the form <code>= value</code> according to 8.3.6 [dcl.fct.default] paragraph 1:</p>\n<blockquote>\n<p id=\"so_13425618_13425708_1\">If an initializer-clause is specified in a parameter-declaration this initializer-clause is used as a default argument. ...</p>\n</blockquote>\n", "LastActivityDate": "2012-11-16T23:13:23.527"}});