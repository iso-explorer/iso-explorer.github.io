post_cb({"34835035": {"ParentId": "34834986", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You'll need to add an <code>operator bool</code> to <code>second</code>.  The compiler will only look at one user-defined implicit conversion.</p>\n", "OwnerUserId": "5231607", "LastEditorUserId": "464581", "LastEditDate": "2016-01-17T12:27:23.487", "Id": "34835035", "Score": "1", "CreationDate": "2016-01-17T04:16:37.750", "LastActivityDate": "2016-01-17T12:27:23.487"}, "34834986": {"CommentCount": "1", "AcceptedAnswerId": "34838255", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2016-01-17T04:06:27.777", "LastActivityDate": "2016-01-17T12:34:23.843", "LastEditDate": "2016-01-17T12:26:18.700", "ViewCount": "70", "FavoriteCount": "1", "Title": "Second order implicit conversion", "Id": "34834986", "Score": "1", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass first\n{\n    public:\n        constexpr first(bool val) noexcept : _value{val} {}\n        constexpr operator bool() const noexcept {return _value;}\n    private:\n        bool _value;\n};\n\nclass second\n{\n    public:\n        constexpr second(first val) noexcept : _value{val} {}\n        constexpr operator first() const noexcept {return _value;}\n    private:\n        first _value;\n};\n\nint main(int argc, char** argv)\n{\n    first f{false};\n    second s{true};\n    bool b1 = f;\n    bool b2 = s; // Not compiling \n    return 0;\n}\n</code></pre>\n<p>Until recently, I was thinking that the standard and compilers were \"clever\" enough to find the required conversion sequence when it exists.</p>\n<p>In other words, I was thinking that <code>bool b2 = s</code> would convert <code>s</code> to <code>first</code>, and then to <code>bool</code>. But apparently it is not happening. </p>\n<p>What is the correct approach to obtain an equivalent behaviour for <code>first</code> and <code>second</code>?</p>\n", "Tags": "<c++><language-lawyer><c++14><implicit-conversion><conversion-operator>", "OwnerUserId": "882932", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34834986_34838255_1": {"section_id": 6, "quality": 0.7692307692307693, "length": 20}, "so_34834986_34838255_3": {"section_id": 386, "quality": 1.0, "length": 11}}, "n3337": {"so_34834986_34838255_1": {"section_id": 3, "quality": 0.7307692307692307, "length": 19}, "so_34834986_34838255_3": {"section_id": 377, "quality": 1.0, "length": 11}}, "n4659": {"so_34834986_34838255_1": {"section_id": 6, "quality": 0.7692307692307693, "length": 20}, "so_34834986_34838255_3": {"section_id": 403, "quality": 1.0, "length": 11}}}, "34838255": {"ParentId": "34834986", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>This is not possible because only a single user-defined conversion is allowed:</p>\n<blockquote>\n<p id=\"so_34834986_34838255_0\"><strong>4 Standard conversions [conv]</strong></p>\n<p id=\"so_34834986_34838255_1\">7 [ Note: For class types, user-defined conversions are considered as\n  well; see 12.3. In general, an implicit conversion sequence (13.3.3.1)\n  consists of a standard conversion sequence followed by a user-defined\n  conversion followed by another standard conversion sequence. \u2014 end\n  note ]</p>\n</blockquote>\n<p>as well as</p>\n<blockquote>\n<p id=\"so_34834986_34838255_2\"><strong>12.3 Conversions [class.conv]</strong> </p>\n<p id=\"so_34834986_34838255_3\">4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single\n  value.</p>\n</blockquote>\n<p>See also Items 5 (Be wary of user-defined conversion functions), 28 (smart pointers) and 30 (proxy classes) of More Effective C++.</p>\n<p>For standard conversions (using builtin types), there is no restriction on how many conversions there can be in the sequence.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2016-01-17T12:34:23.843", "Id": "34838255", "Score": "3", "CreationDate": "2016-01-17T12:22:12.317", "LastActivityDate": "2016-01-17T12:34:23.843"}});