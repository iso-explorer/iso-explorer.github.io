post_cb({"23541148": {"ParentId": "23540764", "CommentCount": "0", "Body": "<p>The friend declaration states that a function called <code>f</code> in the surrounding namespace is a friend of the class; but it does not introduce the name <code>f</code> into the namespace. It's not available (except by argument-dependent lookup) until it's been declared in the namespace.</p>\n<p>The relevant rule is C++11 7.3.1.2/3:</p>\n<blockquote>\n<p id=\"so_23540764_23541148_0\">If a <code>friend</code> declaration in a non-local class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found</strong> by unqualified lookup or by qualified lookup until a matching declaration is provided in that namespace scope.</p>\n</blockquote>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "23541148", "Score": "12", "CreationDate": "2014-05-08T12:01:41.003", "LastActivityDate": "2014-05-08T12:01:41.003"}, "23540764": {"CommentCount": "1", "AcceptedAnswerId": "23541148", "CreationDate": "2014-05-08T11:42:39.827", "LastActivityDate": "2014-12-08T21:14:13.837", "PostTypeId": "1", "ViewCount": "1058", "FavoriteCount": "2", "Title": "Friend function is not visible in the class", "Id": "23540764", "Score": "11", "Body": "<p>I have the following code:</p>\n<pre><code>struct M {\n    friend void f() {}\n    M() {\n        f(); // error: 'f' was not declared in this scope\n    }\n};\n\nint main() {\n    M m;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/424eddc9262c1e5d\" rel=\"noreferrer\">Live example</a></p>\n<p>Both g++4.8 and clang3.4 fail to compile it, because <code>f</code> is not visible inside <code>M</code>, or so they say.</p>\n<p>However, the Standard gives an example of a similar code </p>\n<pre><code>class M {\n  friend void f() { } // definition of global f, a friend of M,\n                      // not the definition of a member function\n};\n</code></pre>\n<p>and says that</p>\n<blockquote>\n<p id=\"so_23540764_23540764_0\">A <code>friend</code> function defined in a class is in the (lexical) scope of the\n  class in which it is defined.</p>\n</blockquote>\n<p>(ISO/IEC 14882:2011 11.3 Friends [class.friend] p6, p7)</p>\n<p>From this I can't understand how compiler can't find <code>f</code> which is defined in same class where it's used.</p>\n<p>It's kinda unlikely that both compilers have the same bug.<br>\nSo, what did I miss?</br></p>\n", "Tags": "<c++>", "OwnerUserId": "343443", "AnswerCount": "4"}, "23541097": {"ParentId": "23540764", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This quote from the C++ Standard</p>\n<blockquote>\n<p id=\"so_23540764_23541097_0\">A friend function defined in a class is in the (lexical) scope of the\n  class in which it is defined.</p>\n</blockquote>\n<p>means the following</p>\n<blockquote>\n<p id=\"so_23540764_23541097_1\">9 Name lookup for a name used in the definition of a friend function\n  (11.3) defined inline in the class granting friendship shall proceed\n  as described for lookup in member function definitions.</p>\n</blockquote>\n<p>That is any name used in the function is searched starting from the class scope.</p>\n<p>However the function itself is not visible in the namespace until it will be declared outside the class.</p>\n<p>So in your case it is enough to declare the function before the class definition</p>\n<pre><code>void f() {}\n\nstruct M {\n    friend void f();\n    M() {\n        f(); \n    }\n};\n\nint main() {\n    M m;\n}\n</code></pre>\n<p>Or</p>\n<pre><code>void f();\n\nstruct M {\n    friend void f() {}\n    M() {\n        f(); \n    }\n};\n\nint main() {\n    M m;\n}\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-08T21:14:13.837", "Id": "23541097", "Score": "3", "CreationDate": "2014-05-08T11:59:19.500", "LastActivityDate": "2014-12-08T21:14:13.837"}, "23541105": {"ParentId": "23540764", "PostTypeId": "2", "CommentCount": "1", "Body": "<pre><code>struct M {\n    friend void f() {}\n    M() {\n        f(); // error: 'f' was not declared in this scope\n    }\n};\n\nint main() {\n    M m;\n}\n</code></pre>\n<p>The above code works perfectly.(tried on DevC++)\nAlso try not to define the function inside the class as it might not have a scope outside it i.e. in <code>main()</code>.\nIn trying to call <code>f()</code> from <code>main()</code> you'll receive an error saying function doesn't exist.\nTherefore, define function outside classes using <code>::</code> operator (if necessary) so that there is no problem accessing the function from anywhere.\n<a href=\"https://stackoverflow.com/questions/7785886/access-friend-function-defined-in-class\">Access friend function defined in class</a></p>\n", "OwnerUserId": "3194746", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:24.403", "Id": "23541105", "Score": "-4", "CreationDate": "2014-05-08T11:59:49.110", "LastActivityDate": "2014-05-08T11:59:49.110"}, "23541158": {"ParentId": "23540764", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The critical question is under what circumstances is the compiler able/allowed to find your function declaration.\nFor a general <code>friend</code> function, you have to declare it outside of the class such that the compiler is able to find it.</p>\n<p>However there is a very useful exception: If the the <code>friend</code> function has an argument of class type, it is able to find the function without additional declaration due to <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">argument-dependent name lookup</a>.</p>\n<p>This case is actually very important because normally you would want a <code>friend</code> function to access an object of class type.</p>\n<hr>\n<p>Consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct M\n{\n    friend void printI(int a) {\n        std::cout &lt;&lt; a;\n    }\n    friend void print(const M&amp; m) { // friend takes object of class type!\n        std::cout &lt;&lt; \"M\";\n    }\n    void foo() {\n        printI(2); // ERROR - requires declaration!\n        print(*this); // OK!\n    }\n};\n\nint main()\n{\n    M m;\n    m.foo();\n    printI(2); // ERROR - requires declaration!\n    print(m); // OK\n}\n</code></pre>\n</hr>", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-05-08T12:08:26.580", "Id": "23541158", "Score": "2", "CreationDate": "2014-05-08T12:01:59.120", "LastActivityDate": "2014-05-08T12:08:26.580"}, "bq_ids": {"n4140": {"so_23540764_23541097_0": {"section_id": 6690, "quality": 1.0, "length": 8}, "so_23540764_23540764_0": {"section_id": 6690, "quality": 1.0, "length": 8}, "so_23540764_23541097_1": {"section_id": 7095, "quality": 0.9444444444444444, "length": 17}, "so_23540764_23541148_0": {"section_id": 5485, "quality": 0.8275862068965517, "length": 24}}, "n3337": {"so_23540764_23541097_0": {"section_id": 6445, "quality": 1.0, "length": 8}, "so_23540764_23540764_0": {"section_id": 6445, "quality": 1.0, "length": 8}, "so_23540764_23541097_1": {"section_id": 6839, "quality": 0.9444444444444444, "length": 17}, "so_23540764_23541148_0": {"section_id": 5271, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_23540764_23541097_0": {"section_id": 8165, "quality": 1.0, "length": 8}, "so_23540764_23540764_0": {"section_id": 8165, "quality": 1.0, "length": 8}, "so_23540764_23541097_1": {"section_id": 8596, "quality": 0.9444444444444444, "length": 17}, "so_23540764_23541148_0": {"section_id": 6920, "quality": 0.8275862068965517, "length": 24}}}});