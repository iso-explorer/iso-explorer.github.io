post_cb({"31946599": {"CommentCount": "1", "ViewCount": "136", "CreationDate": "2015-08-11T15:59:17.800", "LastActivityDate": "2015-08-11T16:09:45.837", "Title": "Correctness of using std::find this way", "AcceptedAnswerId": "31946751", "PostTypeId": "1", "Id": "31946599", "Score": "2", "Body": "<p>I have some structure like this:</p>\n<pre><code>struct SomeStruct{\n/* ...various members */\nstd::string some_data;\nbool operator==(const std::string&amp; s) { return s==some_data; }\n};\n</code></pre>\n<p>And at some point, I have used the <code>std::find</code> function on an iterable container (namely <code>std::vector</code>) like this:</p>\n<pre><code>auto it = std::find(v.begin(), v.end(), std::string(some_string));\n</code></pre>\n<p>where <code>v</code> is a <code>std::vector&lt;SomeStruct&gt;</code>. As the <code>operator==</code> is defined for the two types (<code>SomeStruct</code> and <code>std::string</code>), it does work for me, but I would like to know whether it is correct or the behaviour of the function in this case is implementation-dependent. In any case, I guess I should have used <code>std::find_if</code> with a custom predicate (maybe a lambda function), right?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4963162", "AnswerCount": "2"}, "31946802": {"ParentId": "31946599", "CommentCount": "0", "Body": "<p>From the C++11 standard 25.2.5</p>\n<blockquote>\n<p id=\"so_31946599_31946802_0\">Returns: The first iterator i in the range [first,last) for which the following corresponding conditions hold: *i == value[...]</p>\n</blockquote>\n<p>So the intended behavior of the function is to use the <code>==</code> operator.  As long as the types has on then the function will work.  If you do not have an <code>==</code> operator then you would need to use the overload that takes a predicate and do the comparison in the predicate.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "31946802", "Score": "0", "CreationDate": "2015-08-11T16:09:45.837", "LastActivityDate": "2015-08-11T16:09:45.837"}, "bq_ids": {"n4140": {"so_31946599_31946802_0": {"section_id": 1257, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_31946599_31946802_0": {"section_id": 1255, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_31946599_31946802_0": {"section_id": 1377, "quality": 0.7272727272727273, "length": 8}}}, "31946751": {"ParentId": "31946599", "CommentCount": "1", "Body": "<p>This is the correct behavior. However, unless you really want <code>SomeStruct</code> to be equitable to a <code>std::string</code> in all other contexts, using the <code>==</code> implementation to enable <code>std::find</code> may not be the best solution.</p>\n<p>A better approach would be using <a href=\"http://en.cppreference.com/w/cpp/algorithm/find\" rel=\"nofollow\"><code>find_if</code></a> with a lambda:</p>\n<pre><code>auto it = std::find_if(v.begin(), v.end(), [&amp;] (const SomeStruct&amp; s) {\n    return s.some_data==some_string;\n});\n</code></pre>\n<p>This way the string-to-SomeStruct comparison is explicit, and is limited in its scope to finding by <code>some_data</code>. </p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "31946751", "Score": "4", "CreationDate": "2015-08-11T16:06:57.660", "LastActivityDate": "2015-08-11T16:06:57.660"}});