post_cb({"29150981": {"CommentCount": "2", "ViewCount": "125", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2015-03-19T17:16:30.147", "LastActivityDate": "2015-03-19T18:00:16.843", "Title": "If in malloc object is not created then why does this code works?", "LastEditDate": "2015-03-19T17:40:59.577", "Id": "29150981", "Score": "-5", "Body": "<p>An object is not created when we use malloc/free for a class in c++. Then why does this code works?\nIf an object is not created then it must not give the output mentioned below.</p>\n<pre><code>class Test\n{\npublic:\n    Test()\n    {\n        cout &lt;&lt; \"Test : ctor\\r\\n\";\n    }\n    ~Test()\n    {\n        cout &lt;&lt; \"Test : dtor\\r\\n\";\n    }\n    void Hello()\n    {\n        cout &lt;&lt; \"Test : Hello World\\r\\n\";\n    }\n};\n\nint main()\n{\n\n    cout &lt;&lt; \"2\\n\";\n    Test* t2 = (Test*) malloc(sizeof Test);\n    t2-&gt;Hello();\n    free(t2);\n\n    return 0;\n}\n\n\nOUTPUT:\nHello World\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "4492619", "AnswerCount": "3"}, "29151020": {"ParentId": "29150981", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>Undefined Behavior</strong> is the short answer. The long answer is that because your class has no virtual methods calling them directly is just a function call with an implicit <code>this</code> parameter that points to the memory you've allocated. That said if any of your methods were to access <code>this</code> it would cause more <strong>undefined behavior</strong> because the object hasn't been constructed.</p>\n<p>blatantly stolen from Columbo and LRIO:</p>\n<blockquote>\n<p id=\"so_29150981_29151020_0\"><code>[C++11: 3.8/1]:</code> The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization if it is of a class or aggregate type and <strong>it or one of its members</strong> is initialized by a constructor other than a trivial default constructor. <em>[ Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. <em>\u2014end note ]</em> </p>\n</blockquote>\n<p>The critical bit there is the <strong>it</strong> the pointer to the object can contain data other than just a place where the members are stored. It is up to the implementation to decide what that is.</p>\n", "OwnerUserId": "332733", "LastEditorUserId": "332733", "LastEditDate": "2015-03-19T18:00:16.843", "Id": "29151020", "Score": "6", "CreationDate": "2015-03-19T17:18:25.807", "LastActivityDate": "2015-03-19T18:00:16.843"}, "29151144": {"ParentId": "29150981", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29150981_29151144_0\">An object is not created when we use malloc/free for a class in c++. Then why does this code works? </p>\n</blockquote>\n<p>It depends on how you define \"works\", an incredibly vague term that you should generally avoid in questions like this.</p>\n<p>I would consider that the code <em>doesn't</em> \"work\": it has a bug. It is broken. On any given run of execution it could fail. It could crash. It could open a wormhole.</p>\n<p>What is the bug? The bug is that you are invoking undefined behaviour. You allocated memory for a <code>Test</code> object, but you never created a <code>Test</code> object to put there. You then perform operations on the memory as if it contained a <code>Test</code> object, which it doesn't.</p>\n<blockquote>\n<p id=\"so_29150981_29151144_1\"><code>[C++11: 12.1/5]:</code> <em>[..]</em> A default constructor is trivial if it is not user-provided <em>[..]</em> <strong>Otherwise, the default constructor is non-trivial.</strong></p>\n<p id=\"so_29150981_29151144_2\"><code>[C++11: 3.8/1]:</code> The lifetime of an object is a runtime property of the object. <strong>An object is said to have non-trivial initialization if it is of a class or aggregate type and it</strong> or one of its members <strong>is initialized by a constructor other than a trivial default constructor.</strong> <em>[ Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. <em>\u2014end note ]</em> <strong>The lifetime of an object of type <code>T</code> begins when:</strong></p>\n<ul>\n<li><strong>storage with the proper alignment and size for type <code>T</code> is obtained, and</strong></li>\n<li><strong>if the object has non-trivial initialization, its initialization is complete</strong>.</li>\n</ul>\n<p id=\"so_29150981_29151144_3\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n<p id=\"so_29150981_29151144_4\"><code>[C++11: 3.8/3]:</code> <strong>The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime.</strong> <em>[..]</em></p>\n<p id=\"so_29150981_29151144_5\"><code>[C++11: 3.8/5]:</code> Before the lifetime of an object has started but after the storage which the object will occupy has been allocated <em>[..]</em> any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. <em>[..]</em> Such a pointer may be dereferenced but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>\n<ul>\n<li><em>[..]</em></li>\n<li>the pointer is used to access a non-static data member or call a non-static member function of the object</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>What you are seeing is <em>chance success</em>: the false appearance that your program does not have a bug. It is caused by the fact that your computer does not execute C++ programs, but machine code, and sometimes during the translation from the C++ abstraction to machine code, the breaking of preconditions is lost.</p>\n<p>More specifically, your computer doesn't care that your program is broken in this particular way, because it doesn't need to do anything that relies on your object existing. Those member functions do not touch any instance data so your computer never realises that the code is wrong.</p>\n<p>That doesn't mean the code \"works\".</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-03-19T17:56:33.110", "Id": "29151144", "Score": "4", "CreationDate": "2015-03-19T17:24:54.163", "LastActivityDate": "2015-03-19T17:56:33.110"}, "bq_ids": {"n4140": {"so_29150981_29151144_5": {"section_id": 7193, "quality": 0.8571428571428571, "length": 36}, "so_29150981_29151144_2": {"section_id": 7189, "quality": 0.8048780487804879, "length": 33}, "so_29150981_29151020_0": {"section_id": 7189, "quality": 0.8, "length": 28}, "so_29150981_29151643_0": {"section_id": 7189, "quality": 1.0, "length": 15}, "so_29150981_29151144_1": {"section_id": 369, "quality": 0.8, "length": 8}, "so_29150981_29151643_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_29150981_29151144_4": {"section_id": 7191, "quality": 0.7333333333333333, "length": 11}, "so_29150981_29151643_2": {"section_id": 7193, "quality": 0.9074074074074074, "length": 49}, "so_29150981_29151144_3": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_29150981_29151144_5": {"section_id": 6937, "quality": 0.9285714285714286, "length": 39}, "so_29150981_29151144_2": {"section_id": 6933, "quality": 0.8048780487804879, "length": 33}, "so_29150981_29151020_0": {"section_id": 6933, "quality": 0.8, "length": 28}, "so_29150981_29151643_0": {"section_id": 6933, "quality": 1.0, "length": 15}, "so_29150981_29151144_1": {"section_id": 359, "quality": 0.8, "length": 8}, "so_29150981_29151643_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_29150981_29151144_4": {"section_id": 6935, "quality": 0.7333333333333333, "length": 11}, "so_29150981_29151643_2": {"section_id": 6937, "quality": 0.9629629629629629, "length": 52}, "so_29150981_29151144_3": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_29150981_29151144_5": {"section_id": 8702, "quality": 0.8333333333333334, "length": 35}, "so_29150981_29151144_2": {"section_id": 8697, "quality": 0.7073170731707317, "length": 29}, "so_29150981_29151020_0": {"section_id": 8697, "quality": 0.6857142857142857, "length": 24}, "so_29150981_29151643_0": {"section_id": 8697, "quality": 0.8666666666666667, "length": 13}, "so_29150981_29151643_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_29150981_29151144_3": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_29150981_29151144_1": {"section_id": 383, "quality": 0.6, "length": 6}, "so_29150981_29151643_2": {"section_id": 8702, "quality": 0.8888888888888888, "length": 48}, "so_29150981_29151144_4": {"section_id": 8700, "quality": 0.7333333333333333, "length": 11}}}, "29151643": {"ParentId": "29150981", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><sub>All quotes from the C++11 FD.</sub></p>\n<p>Your code is almost fine. The problem is that your class has non-trivial initialization due to it having a user-provided and thus non-trivial default constructor - [basic.life]/1:</p>\n<blockquote>\n<p id=\"so_29150981_29151643_0\">An object is said to have non-trivial initialization if it is of a\n  class or aggregate type and <strong>it [..] is initialized by\n  a constructor other than a trivial default constructor.</strong></p>\n</blockquote>\n<p>Thus the object isn't alive throughout the program, which is clarified right after the above quote:</p>\n<blockquote>\n<p id=\"so_29150981_29151643_1\">The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the\n  proper alignment and size for type T is obtained, and </li>\n<li><strong>if the object\n  has non-trivial initialization, its initialization is complete.</strong></li>\n</ul>\n</blockquote>\n<p>... hence UB according to [basic.life]/5:</p>\n<blockquote>\n<p id=\"so_29150981_29151643_2\">Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated [..] any pointer that\n  refers to the storage location where the object will be or was located\n  may be used but only in limited ways. [..] Otherwise, such a pointer\n  refers to allocated storage (3.7.4.2), and using the pointer as if the\n  pointer were of type <code>void*</code>, is well-defined. Such a pointer may be\n  dereferenced but the resulting lvalue may only be used in limited\n  ways, as described below. The program has undefined behavior if:</p>\n<ul>\n<li><strong>the pointer is used to access a non-static data member or call a\n  non-static member function of the object, or</strong></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-03-19T17:57:21.993", "Id": "29151643", "Score": "3", "CreationDate": "2015-03-19T17:51:23.923", "LastActivityDate": "2015-03-19T17:57:21.993"}});