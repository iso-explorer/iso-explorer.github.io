post_cb({"33873047": {"ViewCount": "212", "Body": "<p>Given</p>\n<pre><code>struct Range{\n    Range(double from, double to) : from(from), to(to) {}\n    double from;\n    double to;\n    // if it matters to the compiler, we can add more fields here to make copying expensive\n};\n\nstruct Box{\n    Box(Range x, Range y) : x(x), y(y) {}\n    Range x;\n    Range y;\n};\n</code></pre>\n<p><a href=\"https://stackoverflow.com/a/33872152/827280\">someone said</a> that in <code>Box box(Range(0.0,1.0),Range(0.0,2.0))</code>, the compiler can avoid copying <code>Range</code> objects altogether by constructing them inside <code>box</code> to begin with.</p>\n<p>Does any compiler actually do this?</p>\n<p>My own attempts haven't succeeded.</p>\n", "AcceptedAnswerId": "33873923", "Title": "Will any compiler actually ever elide these copies?", "CreationDate": "2015-11-23T14:08:36.940", "Id": "33873047", "CommentCount": "15", "LastEditDate": "2017-05-23T10:28:27.750", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-23T19:53:31.987", "Score": "6", "OwnerUserId": "827280", "Tags": "<c++><pass-by-value><copy-elision>", "AnswerCount": "2"}, "33873923": {"Id": "33873923", "PostTypeId": "2", "Body": "<p>The compiler <em>can</em> - and normally does - elide the copies from the temporary to the argument. The compiler <em>cannot</em> elide the copy from the argument to members. While it may technically possible to elide these copies in some cases, the relevant permission isn't given. The section of the standard is 12.8 [class.copy] paragraph 31 which spells out 4 situations where a copy can be elided (the exact rules are a bit non-trivial):</p>\n<ol>\n<li>When returning a named, function local variable using it name.</li>\n<li>When using a named, function local variable in a <code>throw</code> expression.</li>\n<li>When copying a temporary object.</li>\n<li>When catching an exception by value.</li>\n</ol>\n<p>Passing a named argument as parameter to the construction of a member variable is, clearly, none of these situations.</p>\n<p>The essential background of the rules for copy elision is that in some contexts the declaration of functions suffice to determine when an object will be used. If it is clear upon construction time where the object can be constructed, it can be elided. The caller of a constructor <em>cannot</em> determine based only on the declaration of the constructor where the object will be used.</p>\n", "LastActivityDate": "2015-11-23T14:50:52.837", "CommentCount": "7", "CreationDate": "2015-11-23T14:50:52.837", "ParentId": "33873047", "Score": "8", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_33873047_33879489_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 480}}, "n3337": {"so_33873047_33879489_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 471}}, "n4659": {"so_33873047_33879489_0": {"length": 19, "quality": 0.6551724137931034, "section_id": 502}}}, "33879489": {"Id": "33879489", "PostTypeId": "2", "Body": "<p>That Someone is me. So let me clear my stand.</p>\n<p>I never said that in <code>Box box(Range(0.0,1.0),Range(0.0,2.0))</code>, the compiler can avoid copying Range objects <strong>altogether</strong> by constructing them inside box to begin with. What I said was:</p>\n<p>Yes it can, In particular this kind of copy elision context falls under the copy elision criterion specified in <em>12.8/p31.3 Copying and moving class objects [class.copy]</em> of the standard:</p>\n<blockquote>\n<p id=\"so_33873047_33879489_0\">(31.3) -- when a temporary class object that has not been bound to a reference\n  (12.2) would be copied/moved to a class object with the same type\n  (ignoring cv-qualification), the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move.</p>\n</blockquote>\n<p>The <em>Yes it can</em>, part goes for the temporary objects passed in the constructor (That can be elide per standard as mentioned above). I never said that the parameters can be elided all the way to the <code>Box</code> constructor's initializer list.</p>\n<p>After all, that case doesn't qualify for any of the criteria where copy elision can be applied as per standard.</p>\n<p>I also said that even if a certain context is qualified as a context where copy elision can be applied, the compiler is not obligated to follow. If you rely on that effects then your program is not considered portable.</p>\n", "LastActivityDate": "2015-11-23T19:53:31.987", "CommentCount": "0", "CreationDate": "2015-11-23T19:53:31.987", "ParentId": "33873047", "Score": "0", "OwnerUserId": "2352671"}});