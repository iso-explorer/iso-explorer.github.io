post_cb({"26299148": {"CommentCount": "15", "ViewCount": "445", "CreationDate": "2014-10-10T12:10:56.123", "LastActivityDate": "2014-10-10T12:25:56.563", "Title": "delete[] pointer being freed was not allocated", "AcceptedAnswerId": "26299338", "PostTypeId": "1", "Id": "26299148", "Score": "0", "Body": "<p>I am using the new operator to create a dynamically allocated array (I am using this one because I want to save on the memory overhead of using a vector). The error occurs in the destructor, saying the pointer being freed was not allocated although obviously it was. The constructors and destructors are as follows:</p>\n<pre><code>~Path() {\n    printf(\"Path Destructor\\n\");\n    if(points) {\n        delete[] points;\n    }\n}\nPath(const std::vector&lt;PathPoint&gt;&amp; points_) {\n    size = points_.size();\n    points = new PathPoint[size];\n    int i = 0;\n    for(const PathPoint&amp; p : points_) {\n        points[i++] = p;\n    }\n    printf(\"Path created\\n\");\n}\n</code></pre>\n", "Tags": "<c++><new-operator>", "OwnerUserId": "916382", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26299148_26299338_1": {"section_id": 477, "quality": 0.625, "length": 10}, "so_26299148_26299338_0": {"section_id": 464, "quality": 0.5714285714285714, "length": 8}}, "n3337": {"so_26299148_26299338_1": {"section_id": 468, "quality": 0.625, "length": 10}, "so_26299148_26299338_0": {"section_id": 455, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_26299148_26299338_1": {"section_id": 500, "quality": 0.625, "length": 10}, "so_26299148_26299338_0": {"section_id": 487, "quality": 0.5714285714285714, "length": 8}}}, "26299338": {"ParentId": "26299148", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You have to apply <a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">The Rule of Three</a> :</p>\n<p>The C++ standard says that :</p>\n<blockquote>\n<p id=\"so_26299148_26299338_0\">The implicitly-defined copy constructor for a non-union class X\n  performs a memberwise copy of its subobjects. [n3126.pdf section 12.8\n  \u00a716]</p>\n<p id=\"so_26299148_26299338_1\">The implicitly-defined copy assignment operator for a non-union class\n  X performs memberwise copy assignment of its subobjects. [n3126.pdf\n  section 12.8 \u00a730]</p>\n</blockquote>\n<p>So the implicitly-defined copy constructor and copy assignment operator for your <code>Path</code> class will not call <code>new[]</code> for you.</p>\n<p>Define a copy constructor and a copy assignment oerator that perform the required allocation.</p>\n<hr>\n<p><strong>Note:</strong> </p>\n<ul>\n<li>You can also make your type non copyable, declare them without definition :</li>\n</ul>\n<p>E.g. :</p>\n<pre><code> Path( const Path&amp; other );      // non construction-copyable\n Path&amp; operator=( const Path&amp; ); // non copyable\n</code></pre>\n<p>(or use <a href=\"http://www.boost.org/doc/libs/1_56_0/boost/noncopyable.hpp\" rel=\"nofollow noreferrer\"><code>boost::noncopyable</code></a>)</p>\n<ul>\n<li>The typical overhead of a <code>std::vector&lt;&gt;</code> is very very low, there are few contexts where it really matters : use it as much as you can to avoid such problems.</li>\n</ul>\n</hr>", "OwnerUserId": "3510483", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:27:21.237", "Id": "26299338", "Score": "3", "CreationDate": "2014-10-10T12:20:07.723", "LastActivityDate": "2014-10-10T12:25:56.563"}});