post_cb({"bq_ids": {"n4140": {"so_10369606_10376574_2": {"length": 10, "quality": 1.0, "section_id": 6187}, "so_10369606_10376574_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 6185}, "so_10369606_10376574_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 6126}}, "n3337": {"so_10369606_10376574_2": {"length": 10, "quality": 1.0, "section_id": 5947}, "so_10369606_10376574_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5890}}, "n4659": {"so_10369606_10376574_2": {"length": 10, "quality": 1.0, "section_id": 7690}, "so_10369606_10376574_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7687}, "so_10369606_10376574_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7623}}}, "10369606": {"ViewCount": "4309", "Body": "<p>I am trying to declare a constexpr pointer initialized to some constant integer value, but clang is foiling all my attempts:</p>\n<p>Attempt 1:</p>\n<pre><code>constexpr int* x = reinterpret_cast&lt;int*&gt;(0xFF);\n\ntest.cpp:1:20: note: reinterpret_cast is not allowed in a constant expression\n</code></pre>\n<p>Attempt 2:</p>\n<pre><code>constexpr int* x = (int*)0xFF;\n\ntest.cpp:1:20: note: cast which performs the conversions of a reinterpret_cast is not allowed in a constant expression\n</code></pre>\n<p>Attempt 3:</p>\n<pre><code>constexpr int* x = (int*)0 + 0xFF;\n\ntest.cpp:1:28: note: cannot perform pointer arithmetic on null pointer\n</code></pre>\n<p>Is what I'm trying to do not allowed by design? If so, why? If not, how can I do it?</p>\n<p>Note: gcc accepts all of these.</p>\n", "AcceptedAnswerId": "10376574", "Title": "Constexpr pointer value", "CreationDate": "2012-04-29T04:07:47.900", "Id": "10369606", "CommentCount": "6", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2014-07-08T19:45:48.157", "Score": "22", "OwnerUserId": "141719", "Tags": "<c++><pointers><c++11><clang><constexpr>", "AnswerCount": "2"}, "10370874": {"Id": "10370874", "PostTypeId": "2", "Body": "<p>The reason is the one given by the (for once, very helpful) error message: <code>reinterpret_cast</code> is not allowed in a constant expression. It's listed as one of the explicit exception in 5.19 (paragraph 2).</p>\n<p>Changing the <code>reinterpret_cast</code> into a C-style cast still ends up with the semantical equivalent of a <code>reinterpret_cast</code>, so that doesn't help (and again the message is very explicit).</p>\n<p>If you had a way to obtain a pointer with value <code>0</code> you could indeed use <code>p + 0xff</code> but I can't think of a way to obtain such a pointer with a constant expression. You could have relied on the null pointer value (<code>0</code> in a pointer context like you did, or <code>nullptr</code>) having a value of <code>0</code> on your implementation but as you've seen yourself your implementation refuses to do that. I think it's allowed to do that. (E.g. implementations are allowed to bail out for most constant expressions.)</p>\n", "LastActivityDate": "2012-04-29T08:47:33.177", "Score": "4", "CreationDate": "2012-04-29T08:47:33.177", "ParentId": "10369606", "CommentCount": "1", "OwnerUserId": "726300"}, "10376574": {"Id": "10376574", "PostTypeId": "2", "Body": "<p>As Luc Danton notes, your attempts are blocked by the rules in [expr.const]/2 which say that various expressions are not allowed in <i>core constant expressions</i>, including:</p>\n<blockquote>\n<p id=\"so_10369606_10376574_0\">-- a <code>reinterpret_cast</code><br>\n  -- an operation that would have undefined behavior [Note: including [...] certain pointer arithmetic [...] -- end note]</br></p>\n</blockquote>\n<p>The first bullet rules out your first example. The second example is ruled out by the first bullet above, plus the rule from [expr.cast]/4 that:</p>\n<blockquote>\n<p id=\"so_10369606_10376574_1\">The conversions performed by [...] a <code>reinterpret_cast</code> [...] can be performed using the cast notation of explicit type conversion. The same semantic restrictions and behaviors apply.</p>\n</blockquote>\n<p>The second bullet was added by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1313\" rel=\"noreferrer\">WG21 core issue 1313</a>, and clarifies that pointer arithmetic on a null pointer is not permitted in a constant expression. This rules out your third example.</p>\n<p>Even if these restrictions did not apply to core constant expressions, it would still not be possible to initialize a <code>constexpr</code> pointer with a value produced by casting an integer, since a constexpr pointer variable must be initialized by an <i>address constant expression</i>, which, by [expr.const]/3, must evaluate to</p>\n<blockquote>\n<p id=\"so_10369606_10376574_2\">the address of an object with static storage duration, the address of a function, or a null pointer value.</p>\n</blockquote>\n<p>An integer cast to pointer type is none of these.</p>\n<p>g++ does not yet strictly enforce these rules, but its recent releases have been getting closer to them, so we should assume that it will eventually fully implement them.</p>\n<p>If your goal is to declare a variable for which static initialization is performed, you can simply drop the <code>constexpr</code> -- both clang and g++ will emit a static initializer for this expression. If you need this expression to be part of a constant expression for some reason, you have two choices:</p>\n<ul>\n<li>Restructure your code so that an intptr_t is passed around instead of a pointer, and cast it to pointer type when you need to (outside of a constant expression), or</li>\n<li>Use <code>__builtin_constant_p((int*)0xFF) ? (int*)0xFF : (int*)0xFF</code>. This exact form of expression (with <code>__builtin_constant_p</code> on the left-hand-side of a conditional operator) disables strict constant expression checking in the arms of the conditional operator, and is a little-known, but <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-g_t_005f_005fbuiltin_005fconstant_005fp-3262\" rel=\"noreferrer\">documented</a>, non-portable GNU extension supported by both gcc and clang.</li>\n</ul>\n", "LastEditorUserId": "1041090", "LastActivityDate": "2014-07-08T19:45:48.157", "Score": "18", "CreationDate": "2012-04-29T22:31:16.530", "ParentId": "10369606", "CommentCount": "0", "LastEditDate": "2014-07-08T19:45:48.157", "OwnerUserId": "1041090"}});