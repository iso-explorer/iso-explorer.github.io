post_cb({"41509394": {"ParentId": "41509106", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-01-06T15:59:51.567", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:55.877", "Id": "41509394", "OwnerUserId": "3545273", "Body": "<p>@Borgleader way is enough:</p>\n<pre><code>constexpr int foo(bool cond) {\n    int a=0, b=0, c=0;\n    if (cond) {\n        a = 1;\n        b = 2;\n        c = 3;\n    }\n    else {\n        a = -1;\n        b = -2;\n        c = -3;\n    }\n\n    return a + b + c;\n}\n</code></pre>\n<p>compiles without error in C++11 and only warnings that <em>variable declaration in a constexpr function is a C++14 extension</em> and with no warning in C++14 mode (with CLang 3.4.1)</p>\n<p>This is clean, simple to read and write and close to original code. But undoubtly, <a href=\"https://stackoverflow.com/a/41509617/3545273\">@Barry's solution</a> is nicer.</p>\n", "LastActivityDate": "2017-01-06T16:30:16.110"}, "41509617": {"ParentId": "41509106", "CommentCount": "10", "CreationDate": "2017-01-06T16:11:34.310", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "41509617", "Score": "29", "Body": "<blockquote>\n<p id=\"so_41509106_41509617_0\">However, the compiler complains that I am using an uninitialized variables, despite the fact that the eventual initialization of the local variables is guaranteed.</p>\n</blockquote>\n<p>Initialize, or initialize not, there is no \"eventual initialization.\" And, for <code>constexpr</code> functions, there is a requirement that, in [dcl.constexpr]:</p>\n<blockquote>\n<p id=\"so_41509106_41509617_1\">The definition of a <code>constexpr</code> function shall satisfy the following requirements: [...] its <em>function-body</em> shall be <code>= delete</code>, <code>= default</code>, or a <em>compound-statement</em> that does not contain [...] a definition of a variable of non-literal type or of static or thread storage duration or <strong>for which no\n  initialization is performed</strong>.</p>\n</blockquote>\n<p>Can't have uninitialized variables in <code>constexpr</code> functions, which is what <code>a</code>, <code>b</code>, and <code>c</code> are for you. </p>\n<p>So what can you do? You could just zero-initialize <code>a</code>, <code>b</code>, and <code>c</code>. That gets around this requirement. Or you could initialize <code>a</code>, <code>b</code>, and <code>c</code> inside of each scope in the <code>if</code>. Or you could defer to another <code>constexpr</code> function to do the summing:</p>\n<pre><code>constexpr int f(int a, int b, int c) { return a+b+c; };\n\nconstexpr int foo(bool cond) {    \n    if (cond) {\n        return f(1,2,3);\n    }\n    else {\n        return f(-1,-2,-3);\n    }    \n}\n</code></pre>\n<p>There are lots of ways around this. </p>\n", "LastActivityDate": "2017-01-06T16:11:34.310"}, "41509106": {"CommentCount": "21", "ViewCount": "1042", "PostTypeId": "1", "LastEditorUserId": "4089452", "CreationDate": "2017-01-06T15:44:08.537", "LastActivityDate": "2017-01-07T14:52:16.020", "Title": "A constexpr function with delayed initialization of local variables", "AcceptedAnswerId": "41509617", "LastEditDate": "2017-01-07T14:52:16.020", "Id": "41509106", "Score": "17", "Body": "<p>I am trying to write a <code>constexpr</code> function of the form:</p>\n<pre><code>constexpr int foo(bool cond) {\n    int a, b, c;\n    if (cond) {\n        a = 1;\n        b = 2;\n        c = 3;\n    }\n    else {\n        a = -1;\n        b = -2;\n        c = -3;\n    }\n\n    return a + b + c;\n}\n</code></pre>\n<p>However, the compiler complains that I am using uninitialized variables, despite the fact that the eventual initialization of the local variables is guaranteed.</p>\n<p>I could re-write the function to use ternary operators, that is, <code>int a = cond ? 1 : -1;</code>, etc., but I would prefer not to. Is there a way to convince the compiler that the local variables will be initialized?</p>\n", "Tags": "<c++><constexpr>", "OwnerUserId": "4089452", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_41509106_41509252_4": {"section_id": 5419, "quality": 1.0, "length": 10}, "so_41509106_41509617_1": {"section_id": 5419, "quality": 0.9166666666666666, "length": 22}, "so_41509106_41509252_6": {"section_id": 5419, "quality": 1.0, "length": 7}, "so_41509106_41509252_3": {"section_id": 5419, "quality": 1.0, "length": 7}, "so_41509106_41509252_7": {"section_id": 5419, "quality": 1.0, "length": 10}, "so_41509106_41509252_5": {"section_id": 5419, "quality": 0.7142857142857143, "length": 5}, "so_41509106_41509252_2": {"section_id": 5419, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_41509106_41509252_6": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}, "so_41509106_41509252_4": {"section_id": 6895, "quality": 0.6, "length": 6}, "so_41509106_41509252_3": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}, "so_41509106_41509252_7": {"section_id": 6895, "quality": 0.6, "length": 6}, "so_41509106_41509252_5": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}, "so_41509106_41509252_2": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_41509106_41509252_4": {"section_id": 6841, "quality": 1.0, "length": 10}, "so_41509106_41509617_1": {"section_id": 6841, "quality": 0.9583333333333334, "length": 23}, "so_41509106_41509252_6": {"section_id": 6841, "quality": 1.0, "length": 7}, "so_41509106_41509252_2": {"section_id": 6841, "quality": 0.8571428571428571, "length": 6}, "so_41509106_41509252_7": {"section_id": 6841, "quality": 1.0, "length": 10}, "so_41509106_41509252_5": {"section_id": 6841, "quality": 0.8571428571428571, "length": 6}, "so_41509106_41509252_3": {"section_id": 6841, "quality": 1.0, "length": 7}}}, "41509252": {"ParentId": "41509106", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2017-01-06T15:52:14.960", "Score": "13", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:56.710", "Id": "41509252", "OwnerUserId": "598696", "Body": "<blockquote>\n<p id=\"so_41509106_41509252_0\">However, the compiler complains that I am using an uninitialized variables, despite the fact that the eventual initialization of the local variables is guaranteed.</p>\n</blockquote>\n<p>The standard requires all local variables in a <code>constexpr</code> function to be initialized. </p>\n<blockquote>\n<p id=\"so_41509106_41509252_1\">From <a href=\"https://timsong-cpp.github.io/cppwp/dcl.constexpr#3\" rel=\"nofollow noreferrer\"><strong>\u00a77.1.5</strong>, par. 3</a> <em>(<a href=\"https://timsong-cpp.github.io/cppwp/dcl.constexpr\" rel=\"nofollow noreferrer\">[dcl.constexpr]</a>)</em>:</p>\n<blockquote>\n<p id=\"so_41509106_41509252_5\">The definition of a <code>constexpr</code> function shall satisfy the following requirements: <em>[...]</em></p>\n<p id=\"so_41509106_41509252_6\">its function-body shall be <code>= delete</code>, <code>= default</code>, or a compound-statement that does not contain <em>[...]</em> </p>\n<p id=\"so_41509106_41509252_7\">a definition of a variable of non-literal type or of static or thread storage duration or for which no initialization is performed. <em>[...]</em> </p>\n<pre><code>constexpr int uninit() {\n    int a;     // error: variable is uninitialized\n    return a;\n}\n</code></pre>\n</blockquote>\n</blockquote>\n<hr>\n<p>In C++17, you can use <a href=\"http://en.cppreference.com/w/cpp/utility/tuple\" rel=\"nofollow noreferrer\"><code>std::tuple</code></a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf\" rel=\"nofollow noreferrer\"><em>structured bindings</em></a>, and <a href=\"https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\" rel=\"nofollow noreferrer\">IIFE <em>(immediately-invoked function expression)</em></a> to preserve your original structure:</p>\n<pre><code>constexpr int foo(bool cond) \n{\n    const auto [a, b, c] = [&amp;cond]\n    {\n        if (cond) \n        {\n            return std::tuple(1, 2, 3);\n        }\n        else\n        {\n            return std::tuple(-1, -2, -3);\n        }    \n    }();\n\n    return a + b + c;\n}\n</code></pre>\n<p>Since your condition and branching is trivial, a <em>ternary operator</em> will suffice. The code snippet above may help you if in the future your initialization logic becomes more complex, but the one below should be good enough: </p>\n<pre><code>constexpr int foo(bool cond) \n{\n    const auto [a, b, c] = cond ? std::tuple(1, 2, 3)\n                                : std::tuple(-1, -2, -3);\n\n    return a + b + c;\n}\n</code></pre>\n<hr>\n<p>In C++14, you can use <code>std::make_tuple</code> and <code>std::get</code> instead:</p>\n<pre><code>constexpr int foo(bool cond) \n{\n    const auto abc = cond ? std::make_tuple(1, 2, 3) \n                          : std::make_tuple(-1, -2, -3);\n\n    return std::get&lt;0&gt;(abc) + std::get&lt;1&gt;(abc) + std::get&lt;2&gt;(abc);\n}\n</code></pre>\n<hr>\n<p>In C++11 you can split the function in two smaller ones:</p>\n<pre><code>template &lt;typename TTuple&gt;\nconstexpr int sum3(const TTuple&amp; abc)\n{\n    return std::get&lt;0&gt;(abc) + std::get&lt;1&gt;(abc) + std::get&lt;2&gt;(abc);\n}\n\nconstexpr int foo(bool cond) \n{\n    return cond ? sum3(std::make_tuple(1, 2, 3)) \n                : sum3(std::make_tuple(-1, -2, -3));   \n}\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/41509106/constexpr-function-with-delayed-initialization-of-local-variables/41509617#41509617\">Barry's solution</a> is definitely better if you decide to go down that route, though.</p>\n<hr>\n<p>All the above solutions:</p>\n<ul>\n<li><p>Make your <code>a</code>, <code>b</code>, <code>c</code> variables <code>const</code>, which is always a good thing.</p></li>\n<li><p>Only perform a single check on <code>cond</code>, in order to closely resemble the structure of the code in the OP.</p></li>\n</ul>\n</hr></hr></hr></hr>", "LastActivityDate": "2017-01-06T16:34:35.937"}});