post_cb({"11911292": {"ParentId": "11911279", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-08-11T02:04:47.263", "Score": "2", "LastEditorUserId": "1459996", "LastEditDate": "2012-08-11T02:20:11.010", "Id": "11911292", "OwnerUserId": "1459996", "Body": "<p>Const is used in the following way:</p>\n<pre><code>Foo inst1;\nconst Foo inst2;\n\ninst1.fun();    // 1st fun\ninst2.fun();    // 2nd fun\n</code></pre>\n<p>Const after the name of the function refers to the implicit <code>this</code> parameter. So, for inst1 it will <code>Foo*</code> and for inst2 <code>const Foo*</code>. This will guide the overload.</p>\n<p>The return value is not used for selecting the overload. Methods/functions with the same set of params and different types of return value are not allowed on the same layer.</p>\n", "LastActivityDate": "2012-08-11T02:20:11.010"}, "11911331": {"ParentId": "11911279", "CommentCount": "0", "Body": "<p>For what it's worth, the language from the standard (\u00a713.3.1/3,4):</p>\n<blockquote>\n<p id=\"so_11911279_11911331_0\">Similarly, when appropriate, the context can construct an argument list that contains an implied object\n  argument to denote the object to be operated on. Since arguments and parameters are associated by position within their respective lists, the convention is that the implicit object parameter, if present, is\n  always the first parameter and the implied object argument, if present, is always the first argument.</p>\n<p id=\"so_11911279_11911331_1\">For non-static member functions, the type of the implicit object parameter is</p>\n<p id=\"so_11911279_11911331_2\">\u2014 \u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</p>\n<p id=\"so_11911279_11911331_3\">\u2014 \u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier\n  where X is the class of which the function is a member and cv is the cv-qualification on the member function declaration. [ Example: for a const member function of class X, the extra parameter is assumed to have type \u201creference to const X\u201d. \u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "11911331", "Score": "1", "CreationDate": "2012-08-11T02:12:39.190", "LastActivityDate": "2012-08-11T02:12:39.190"}, "11911294": {"ParentId": "11911279", "CommentCount": "2", "Body": "<p>Compiler cannot discriminate by return type because return values can undergo conversion before the assignment is performed. The object on which the function is invoked, on the other hand, is a parameter (albeit an implicit one) to the function, so the compiler can discriminate on it.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "11911294", "Score": "6", "CreationDate": "2012-08-11T02:05:43.583", "LastActivityDate": "2012-08-11T02:05:43.583"}, "bq_ids": {"n4140": {"so_11911279_11911331_0": {"section_id": 567, "quality": 0.9743589743589743, "length": 38}, "so_11911279_11911331_2": {"section_id": 568, "quality": 1.0, "length": 6}, "so_11911279_11911331_3": {"section_id": 568, "quality": 0.8888888888888888, "length": 24}, "so_11911279_11911331_1": {"section_id": 568, "quality": 0.875, "length": 7}}, "n3337": {"so_11911279_11911331_0": {"section_id": 558, "quality": 0.9743589743589743, "length": 38}, "so_11911279_11911331_2": {"section_id": 559, "quality": 1.0, "length": 6}, "so_11911279_11911331_3": {"section_id": 559, "quality": 0.8888888888888888, "length": 24}, "so_11911279_11911331_1": {"section_id": 559, "quality": 0.875, "length": 7}}, "n4659": {"so_11911279_11911331_0": {"section_id": 590, "quality": 0.9743589743589743, "length": 38}, "so_11911279_11911331_2": {"section_id": 591, "quality": 1.0, "length": 6}, "so_11911279_11911331_3": {"section_id": 591, "quality": 0.8888888888888888, "length": 24}, "so_11911279_11911331_1": {"section_id": 591, "quality": 0.875, "length": 7}}}, "11911279": {"CommentCount": "0", "AcceptedAnswerId": "11911294", "CreationDate": "2012-08-11T02:02:07.007", "LastActivityDate": "2012-08-11T02:20:11.010", "PostTypeId": "1", "ViewCount": "115", "FavoriteCount": "1", "Title": "How can const make a function overloads?", "Id": "11911279", "Score": "3", "Body": "<p>I wrote this code in C++:</p>\n<pre><code>class Foo\n{\npublic:\n    int&amp; fun(){return var;}       // 1st fun\n    int fun() const {return var;}  // 2rd fun\n private:\n    int var;\n};\nint main()\n{\n    Foo foo;\n    int i = foo.fun();\n    return 0;\n}\n</code></pre>\n<p>I know that C++ cannot discriminate overloading function by return value,but why when I added a const to 2rd function ,overloading can work ?\nWhat the 'const' have done ?</p>\n", "Tags": "<c++><const><overloading>", "OwnerUserId": "1145750", "AnswerCount": "3"}});