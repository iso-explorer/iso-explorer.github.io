post_cb({"29243062": {"Id": "29243062", "PostTypeId": "2", "Body": "<p>There's no <em>easy</em> way to do this. But you could do it with some work. Basically all you have to do is get pointers to the array and then move them to wherever you want the zero position to be.</p>\n<pre><code>#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, char* argv[]) {\n\n    const int minIndex = -5;\n    const int maxIndex = 5;\n    const int size = maxIndex - minIndex;\n\n    assert(minIndex &lt; maxIndex);\n\n    int arr[size][size];\n\n    // initialize the values in the array\n    for (int i = 0; i &lt; size; ++i) {\n        for (int j = 0; j &lt; size; ++j) {\n            arr[i][j] = size*i + j;\n        }\n    }\n\n    // first get the shifted versions of the inner arrays\n    int* shiftedInner[10]; \n    for (int i = 0; i &lt; size; ++i) {\n        shiftedInner[i] = arr[i] - minIndex;\n    }\n    // then shift the outer one \n    int** shifted = &amp;shiftedInner[-minIndex];\n\n\n    // and now you can work with it as if the\n    // base array were arranged like you want it\n    printf(\"%d\", shifted[minIndex][minIndex]);\n    printf(\"%d\", shifted[-3][-4]);\n}\n</code></pre>\n<p>This is gross and I don't recommend doing it in production code. But it is possible.</p>\n", "LastActivityDate": "2015-03-24T21:17:23.773", "CommentCount": "0", "CreationDate": "2015-03-24T21:17:23.773", "ParentId": "29242409", "Score": "0", "OwnerUserId": "1325329"}, "29242631": {"Id": "29242631", "PostTypeId": "2", "Body": "<p>Negative indices can be used in array subscripts, the index in <code>[]</code> is basically an offset from a pointer so if You write:</p>\n<pre><code> int array[5]={1,2,3,4,5};\n int *arr=&amp;array[2];\n int val=arr[-2];\n</code></pre>\n<p>You get 1.</p>\n", "LastEditorUserId": "4597023", "LastActivityDate": "2015-03-24T20:52:18.830", "Score": "0", "CreationDate": "2015-03-24T20:51:05.517", "ParentId": "29242409", "CommentCount": "1", "OwnerUserId": "4597023", "LastEditDate": "2015-03-24T20:52:18.830"}, "29243055": {"Id": "29243055", "PostTypeId": "2", "Body": "<p>This works (I'll explain in more depth in a moment):</p>\n<pre><code>int (*p)[3] = (int (*)[3])((int *)&amp;arr + 4);\n</code></pre>\n<p>First of all.  The expression <code>(int *)&amp;arr + 4</code> forms a pointer to the same location as <code>&amp;arr[1][1]</code>.  </p>\n<p>However I have chosen the first form to avoid the possible objection that <code>&amp;arr[1][1]</code> forms a pointer which may not be used to access outside of the bounds of the sub-array <code>arr[1]</code>. In C that is a valid objection, and in C++ it is less clear. The C++ standard uses different wording in this area. In any case, I avoid the topic entirely by using an offset into the single object <code>arr</code>.</p>\n<p>After that, it is cast as if it is a pointer to an array of arrays of 3 ints. (i.e. the same type as <code>&amp;arr[0]</code>). </p>\n<p>I think it is OK to use this to access any <code>int</code> which is inside <code>arr</code>, although I haven't seen a lot of discussion surrounding the use of pointer-to-array when it overlaps valid space and invalid space. (Am going to post a new question on that...)</p>\n", "LastActivityDate": "2015-03-24T21:16:42.227", "CommentCount": "0", "CreationDate": "2015-03-24T21:16:42.227", "ParentId": "29242409", "Score": "0", "OwnerUserId": "1505939"}, "bq_ids": {"n4140": {"so_29242409_29242623_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5986}}, "n3337": {"so_29242409_29242623_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5754}}, "n4659": {"so_29242409_29242623_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7486}}}, "29242993": {"Id": "29242993", "PostTypeId": "2", "Body": "<p>As I understand, what you are trying to achieve is that given a position in a 2D array (<code>[1][1]</code> in your code), you want to perform some operations for the neighbourhood of that position. One of readable ways to do it is the following, and I strongly advise it:</p>\n<pre><code>int row = 1;\nint col = 1;\nfor (int i = -1; i &lt; 2; i++) {\n    for (int j = -1; j &lt; 2; j++) {\n        std::cout &lt;&lt; arr[row + i][col + j] &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Though if you really want to mess with pointers, there is a way. You can treat <code>&amp;arr[1][1]</code> as a pointer to an array of length <code>3</code> (the last dimension of <code>arr</code>), and it will allow you to do the trick:</p>\n<pre><code>static cont int ROW_LEN = 3; // 3 here is the last dimension of arr\ntypedef int (*arrRowPtr)[ROW_LEN]; \narrRowPtr p = (arrRowPtr)&amp;arr[1][1];\n\nfor (int i = -1; i &lt; 2; i++) {\n    for (int j = -1; j &lt; 2; j++) {\n        std::cout &lt;&lt; p[i][j] &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Why it works: <code>p[i]</code> is the same as <code>*(p + i)</code>, and adding <code>i</code> to <code>p</code> means adding <code>i * ROW_LEN * sizeof(int)</code>, that is moving the position by <code>i</code> rows (forward or backward), preserving the column. The type of <code>*(p + i)</code> is <code>int[ROW_LEN]</code>, decaying for the purpose of pointer arithmetic to <code>int*</code>, which means that <code>p[i][j]</code> will add <code>j * sizeof(int)</code> to <code>p[i]</code>, that is change the column by <code>j</code>.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2015-03-24T21:26:49.647", "Score": "1", "CreationDate": "2015-03-24T21:12:52.207", "ParentId": "29242409", "CommentCount": "0", "OwnerUserId": "3959454", "LastEditDate": "2015-03-24T21:26:49.647"}, "29242623": {"Id": "29242623", "PostTypeId": "2", "Body": "<p>C++ standard defines:  </p>\n<blockquote>\n<p id=\"so_29242409_29242623_0\"><strong>5.2.1/1</strong>  (...) unscoped enumeration or integral type. (...) The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n<p>So it's not required to have postive integrals (unlike the size of an array which must be positive according to 8.3.4).  And 5.7 defines E1 + E2 when E1 is a pointer and E2 is a positive or negative integral.   </p>\n<p>So yes, in principle it should be valid. Example:  </p>\n<pre><code> int a[4][5] = { { 11, 12, 13, 14,15 }, { 21, 22, 23, 24,25 }, { 31, 32, 33, 34,35 }, { 41, 42, 43, 44,45 } };\n typedef int (*myarr)[5];\n myarr p  = (myarr) &amp;a[2][2];\n cout &lt;&lt; p[0][0] &lt;&lt; endl &lt;&lt; p[-2][-2]&lt;&lt;endl; \n</code></pre>\n<p>However it's not a good practice, because: </p>\n<ul>\n<li>it may create confusion as most people expect index being positive</li>\n<li><code>std::vectors</code>and <code>std::array</code> both have <code>operator[]</code> defined with an <strong>unsigned integral</strong> type.  So your negative indexing practice could not be easily converted to more advanced data structures</li>\n<li>it works for multidimensional arrays (thanks to contiguity of data), but it doesn't work at all with arrays of arrays such as <code>int**</code>.</li>\n</ul>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2015-03-24T21:47:22.610", "Score": "1", "CreationDate": "2015-03-24T20:50:36.827", "ParentId": "29242409", "CommentCount": "0", "OwnerUserId": "3723423", "LastEditDate": "2015-03-24T21:47:22.610"}, "29242409": {"ViewCount": "242", "Body": "<p>I am trying to access a two dimensional array in a program and also I am trying to use negative indexes (it helps me in mental steps). I wanted to use the neatest possible syntax for access array element viz <code>a[i][j]</code>.</p>\n<p>However when I run the program , I get segmentation fault.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main (void)\n{\n    int i,j;\n    int arr[3][3];\n    int ** p;\n\n    for( i=0; i&lt;3; i++)\n    {\n        for(j=0; j&lt;3; j++)\n        {\n            arr[i][j] = i+j;\n        }\n    }\n\n    p = (int **)&amp;(arr[1][1]);\n\n    for( i=-1; i&lt;2; i++)\n        {\n            for(j=-1; j&lt;2; j++)\n            {\n                std::cout &lt;&lt; p[i][j] &lt;&lt; std::endl;\n            }\n        }\n    return 0;\n}\n</code></pre>\n<p>I don't want to use something like <code>p[i*something + j]</code> for accessing array elements. Is it possible?</p>\n", "AcceptedAnswerId": "29243055", "Title": "Is it possible to access two dimensional array with negative indexing?", "CreationDate": "2015-03-24T20:37:47.840", "Id": "29242409", "CommentCount": "27", "LastEditDate": "2015-03-24T21:23:31.923", "PostTypeId": "1", "LastEditorUserId": "668279", "LastActivityDate": "2015-03-24T21:47:22.610", "Score": "0", "OwnerUserId": "668279", "Tags": "<c++><multidimensional-array>", "AnswerCount": "5"}});