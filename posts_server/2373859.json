post_cb({"8006859": {"LastActivityDate": "2011-11-04T17:33:28.530", "CommentCount": "1", "Body": "<p>Please note that possibility 3 is not thread safe.</p>\n<p>See for example \"C++ scoped static initialization is not thread-safe, on purpose!\" at <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/03/08/85901.aspx\" rel=\"nofollow\">http://blogs.msdn.com/b/oldnewthing/archive/2004/03/08/85901.aspx</a></p>\n", "CreationDate": "2011-11-04T08:57:26.263", "LastEditDate": "2011-11-04T17:33:28.530", "ParentId": "2373859", "Id": "8006859", "LastEditorUserId": "815724", "PostTypeId": "2", "Score": "1", "OwnerUserId": "1029366"}, "2373895": {"LastActivityDate": "2010-03-03T18:32:52.923", "CommentCount": "2", "Body": "<p>All of them, except possibility <code>3</code>, suffer from the static initialization order fiasco. This is because your class is not a POD. In C++0x, this problem can be solved by marking the constructor <code>constexpr</code>, but in C++03 there is no such solution. </p>\n<p>You can remove the constructor to solve the problem in C++03, and initialize using</p>\n<pre><code>const Vector2 Vector2::ONE = { 1.f, 1.f };\n</code></pre>\n<p>This is initializing a POD, and all initializers in the list are constant expression (for the purpose of static initialization). The intialization of them happen before any code is run that might access it before being initialized. </p>\n<p><code>3.6.2</code>:</p>\n<blockquote>\n<p id=\"so_2373859_2373895_0\">Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place. Zero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization. Objects of POD types (3.9) with static storage duration initialized with constant expressions (5.19) shall be initialized before any dynamic initialization takes place. </p>\n</blockquote>\n<p><code>8.5.1/14</code>:</p>\n<blockquote>\n<p id=\"so_2373859_2373895_1\">When an aggregate with static storage duration is initialized with a brace-enclosed initializer-list, if all the member initializer expressions are constant expressions, and the aggregate is a POD type, the initialization shall be done during the static phase of initialization (3.6.2); otherwise, it is unspecified whether the initialization of members with constant expressions takes place during the static phase or during the dynamic phase of initialization.</p>\n</blockquote>\n", "CreationDate": "2010-03-03T18:27:43.433", "LastEditDate": "2010-03-03T18:32:52.923", "ParentId": "2373859", "Id": "2373895", "LastEditorUserId": "34509", "PostTypeId": "2", "Score": "10", "OwnerUserId": "34509"}, "2373859": {"CreationDate": "2010-03-03T18:22:49.693", "ViewCount": "6259", "FavoriteCount": "1", "Id": "2373859", "AcceptedAnswerId": "2373895", "Score": "6", "Title": "C++ static const and initialization (is there a fiasco)", "CommentCount": "2", "Body": "<p>I am returning to C++ after a long absence and I am stumbling a little over my understanding of the fairly well known static initialization problem. </p>\n<p>Let's say I have a simple class Vector2 as given below (note that I am aware that x and y should be private with getters and setters, these have just been omitted for brevity):</p>\n<pre><code>class Vector2 {\n\npublic:\n  Vector2(float x, float y) :x(x), y(y) {};\n  float x,y;\n}\n</code></pre>\n<p>Now, if I want to specify a static const member to represent a Vector2 with x and y set to 1, I am unsure on how to proceed - will static const members fall foul of the static initialization problem or will the act of making them const mean they are ok? I am toying with the following possibilities:</p>\n<p>Possibility 1:</p>\n<pre><code>// .h\nclass Vector2 {\n\npublic:\n  Vector2(float x, float y) :x(x), y(y) {}\n  static const Vector2 ONE;\n  float x,y;\n};\n\n// .cpp\nconst Vector2 Vector2::ONE = Vector2(1.f, 1.f);\n</code></pre>\n<p>Possibility 2:</p>\n<pre><code>// .h\nclass Vector2 {\n\npublic:\n  Vector2(float x, float y) :x(x), y(y) {}\n  static const Vector2&amp; getOne();\n  float x,y;\nprivate: \n  static const Vector2 ONE;\n};\n\n// .cpp\nconst Vector2 Vector2::ONE = Vector2(1.f, 1.f);\n\nstatic const Vector2&amp; Vector2::getOne() {\n  return ONE;\n}\n</code></pre>\n<p>Possibility 3:</p>\n<pre><code>// .h\nclass Vector2 {\n\npublic:\n  Vector2(float x, float y) :x(x), y(y) {}\n  static const Vector2&amp; getOne();\n  float x,y;\n};\n\n// .cpp\nconst Vector2&amp; Vector2::getOne() {\n  static Vector2 one(1.f,1.f);\n  return one;\n}\n</code></pre>\n<p>Now, my preferred way to write this would be as in possibility 2, just because it is a more comfortable syntax for me. However, if I call the getOne() method from another static method in another class am I going to risk crashing and burning? As I say, it is because I am using a static const rather than a plain static that I am asking this question as I have found much on plain static class member issues, but nothing on const static issues. </p>\n<p>I suspect that I gain nothing by the fact that I am using static const and will need to go with Possibility 3 to be safe, but I just want to ask in case someone can shed some light on this for me.</p>\n<p>I realise I am probably opening myself up to a slew of links pointing to exactly what I am asking, but I have looked and not found before posting this.</p>\n<p>Any help will be gratefully appreciated.</p>\n", "Tags": "<c++><static><initialization><const>", "LastActivityDate": "2011-11-04T17:33:28.530", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "633883"}, "bq_ids": {"n4140": {"so_2373859_2373895_0": {"length": 25, "quality": 0.625, "section_id": 7151}}, "n3337": {"so_2373859_2373895_0": {"length": 25, "quality": 0.625, "section_id": 6895}}}});