post_cb({"20894120": {"ParentId": "20893816", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Just a guess here:</p>\n<p>Since the <code>enum</code> is technically a type, Foo::number could be treated as a const or static const by the compiler. What would happen if you:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum { number = 42 };\n\nint main()\n{\n    std::cout &lt;&lt; number &lt;&lt; endl;\n}\n</code></pre>\n<p>In this case, <code>number</code> <em>appears</em> to have been resolved to an immediate, and is valid within both <code>this-&gt;</code> and <code>type.</code> scopes.</p>\n<p>As I said, this is just a guess. @LightnessRacesInOrbit has spec quotes. He/She/Insanely-well-informed Turing Machine wins.</p>\n", "OwnerUserId": "135769", "LastEditorUserId": "135769", "LastEditDate": "2014-01-03T00:31:08.360", "Id": "20894120", "Score": "0", "CreationDate": "2014-01-02T23:50:48.423", "LastActivityDate": "2014-01-03T00:31:08.360"}, "20894013": {"ParentId": "20893816", "CommentCount": "0", "Body": "<p>It's perfectly valid:</p>\n<blockquote>\n<p id=\"so_20893816_20894013_0\"><code>[C++11: 7.2/10]:</code> Each <em>enum-name</em> and <strong>each unscoped enumerator is declared in the scope that immediately contains the <em>enum-specifier</em></strong>. Each scoped enumerator is declared in the scope of the enumeration. These names obey the scope rules defined for all names in (3.3) and (3.4). <em>[..]</em> <strong>An enumerator declared in class scope can be referred to using the class member access operators (<code>::</code>, <code>.</code> (dot) and <code>-&gt;</code> (arrow))</strong>, see 5.2.5.</p>\n</blockquote>\n<p>The same text (minus rules for scoped enums) can be found in the C++03 standard, at the same location.</p>\n<p>I have to admit, this surprises me somewhat as well. I'd have expected <code>::</code> to be the only valid mechanism.</p>\n<p>The warning you get in GCC is not about the use of the enum, but about the fact that you use nothing <em>but</em> the enum. In such a case, you'd typically write <code>Foo::number</code> and avoid instantiating a <code>Foo</code> instance.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "20894013", "Score": "10", "CreationDate": "2014-01-02T23:41:23.137", "LastActivityDate": "2014-01-02T23:41:23.137"}, "bq_ids": {"n4140": {"so_20893816_20894013_0": {"section_id": 5470, "quality": 0.9024390243902439, "length": 37}}, "n3337": {"so_20893816_20894013_0": {"section_id": 5256, "quality": 0.9024390243902439, "length": 37}}, "n4659": {"so_20893816_20894013_0": {"section_id": 6904, "quality": 0.9024390243902439, "length": 37}}}, "20893816": {"CommentCount": "3", "ViewCount": "200", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2014-01-02T23:23:31.127", "LastActivityDate": "2014-01-03T00:31:08.360", "Title": "Access anonymous enumerated value with dot", "AcceptedAnswerId": "20894013", "LastEditDate": "2014-01-02T23:54:27.050", "Id": "20893816", "Score": "9", "Body": "<p>This code compiles (and appears to work) with both GCC and Clang:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    enum { number = 42 };\n};\n\nint main()\n{\n    Foo bar;\n    std::cout &lt;&lt; bar.number &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ac01bf0cbac65514\" rel=\"nofollow noreferrer\">See it here.</a></p>\n<p>It was surprising to me that the compiler accepts <code>bar.number</code>; all text books I can find teach to use <code>Foo::number</code> to access the enumerated value.</p>\n<p>Is this code valid? Note that GCC gives a weird warning (\"variable 'bar' set but not used\"), while Clang doesn't complain about it.</p>\n", "Tags": "<c++>", "OwnerUserId": "1484212", "AnswerCount": "2"}});