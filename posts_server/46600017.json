post_cb({"46601357": {"ParentId": "46600017", "CommentCount": "0", "Body": "<p>If a <strong>rvalue</strong> is taken reference, it's <strong>no longer an rvalue</strong>. Taking reference of an rvalue causes it to be stored as if it were an lvalue.</p>\n<p>For example</p>\n<pre><code>int a=2, b=3;\nint *p1 = &amp;(a+b); // Wrong\nint &amp;&amp;r1 = a+b; // OK, but the result is no longer an rvalue\nint *p2 = &amp;r1; // OK\n</code></pre>\n<p>So definitely you can take the address of an lvalue.</p>\n", "OwnerUserId": "5958455", "PostTypeId": "2", "Id": "46601357", "Score": "0", "CreationDate": "2017-10-06T08:19:59.550", "LastActivityDate": "2017-10-06T08:19:59.550"}, "46600017": {"CommentCount": "5", "ViewCount": "84", "CreationDate": "2017-10-06T06:59:47.813", "LastActivityDate": "2017-10-06T11:27:43.483", "Title": "memory address of integer literal in c++", "PostTypeId": "1", "Id": "46600017", "Score": "1", "Body": "<p>pointer to integer literal is not allowed in c++.\nhowever, I can get the address of literal using address-of(&amp;) operator.</p>\n<pre><code>const int &amp; a = 5;\nconst int &amp; b = 5;\ncout &lt;&lt; &amp;a &lt;&lt; endl;\ncout &lt;&lt; &amp;b &lt;&lt; endl;\n</code></pre>\n<p>the result is &amp;a and &amp;b is different!!! \nwhy??? in case of string literal, one string literal has only one memory address. why the same integer literal has different memory address when they declared again?</p>\n", "Tags": "<c++>", "OwnerUserId": "8730666", "AnswerCount": "3"}, "46601362": {"ParentId": "46600017", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The two literals indeed do have the same address, and that address is <em>no-address</em>. Literals, with the exception of string literals, do not have an address.</p>\n<p>In your code, you are <strong>not</strong> taking the address of a literal, which is not possible at all. The address-of operator requires a lvalue, and a literal isn't one! Thus, if you indeed tried to take the literal's address as in <code>int* a = &amp;5;</code> the compiler wouldn't let you.</p>\n<p>You are creating a <code>const</code> reference to a rvalue (actually prvalue). Now if you tried compiling without the <code>const</code> keyword and wondered why that didn't work, it's for the same reason. Without constness, a lvalue is required to bind the reference, and a literal isn't one.</p>\n<p>Note 5.1.1:</p>\n<blockquote>\n<p id=\"so_46600017_46601362_0\">Literals [expr.prim.literal]\n  A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p>So that explains why it \"works\" for string literals, they're lvalues. You can take the address of a lvalue. It also explains why it doesn't work for integer literals.</p>\n<p>Note however that taking the address of two string literals which are identical does <strong>not necessarily</strong> yield the same address. You are wrong in that assumption.</p>\n<p>In optimized builds, or upon explicit request, many compilers will perform <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fmerge-constants\" rel=\"nofollow noreferrer\">string pooling</a>. Very, very strictly, from a logical point of view this is incorrect (since two string literals, whether the same or not, <em>are</em> two different objects, and with the exception of bitfields and nested objects, different object are expected to have different addresses), but surprisingly the standard indeed allows an implementation to weasle out of this completely legally.</p>\n<p>per 2.13.4/2 in C++98 and C++03, 2.14.12/11 in C++11, 2.14.5/12 respectively in C++14:</p>\n<blockquote>\n<p id=\"so_46600017_46601362_1\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>per 2.13.5/16 in C++17:</p>\n<blockquote>\n<p id=\"so_46600017_46601362_2\">[...] Whether all string literals are distinct (that is, are stored in nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a different object is <strong>unspecified</strong>.</p>\n</blockquote>\n<p>Thus, in versions prior to C++17, the compiler (the \"implementation\") may nevertheless choose to perform pooling, but within the constraints of \"implementation-defined\", this means that the particular compiler must adhere to whatever it choses, and what happens must be verifiable (documented).</p>\n<p>In C++17, the standard merely states it's unspecified. Which basically means... \"whatever\".</p>\n<p>Thus, a compiler <em>may</em> do string pooling (legitimately), but the general assumption that it <em>does</em> is wrong.</p>\n", "OwnerUserId": "572743", "LastEditorUserId": "572743", "LastEditDate": "2017-10-06T11:27:43.483", "Id": "46601362", "Score": "0", "CreationDate": "2017-10-06T08:20:26.330", "LastActivityDate": "2017-10-06T11:27:43.483"}, "bq_ids": {"n4140": {"so_46600017_46601362_0": {"section_id": 5947, "quality": 0.8333333333333334, "length": 15}, "so_46600017_46600272_0": {"section_id": 5795, "quality": 0.9464285714285714, "length": 53}, "so_46600017_46601362_1": {"section_id": 5361, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_46600017_46601362_0": {"section_id": 5717, "quality": 0.8333333333333334, "length": 15}, "so_46600017_46600272_0": {"section_id": 5568, "quality": 0.9464285714285714, "length": 53}, "so_46600017_46601362_1": {"section_id": 5157, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_46600017_46601362_0": {"section_id": 7433, "quality": 0.8333333333333334, "length": 15}, "so_46600017_46601362_2": {"section_id": 6789, "quality": 1.0, "length": 17}, "so_46600017_46601362_1": {"section_id": 6789, "quality": 0.8888888888888888, "length": 8}, "so_46600017_46600272_0": {"section_id": 7254, "quality": 0.9285714285714286, "length": 52}}}, "46600272": {"ParentId": "46600017", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>you're not taking the address of a literal: the '5' is a prvalue that is used to initialize a temporary of type int whose lifetime is bound to the const reference a. So <code>&amp;a!=&amp;b</code> must(*) hold true as far as I can tell:</p>\n<blockquote>\n<p id=\"so_46600017_46600272_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of di erent types; otherwise, <strong>they shall have distinct addresses</strong> ^4. 4 [ <strong>(*)</strong> <em>Under the \u201cas-if\u201d rule an implementation is allowed to store two objects at the same machine address or not store an\n  object at all if the program cannot observe the difference</em> ]</p>\n</blockquote>\n<p>moreover, as a demonstration of the <em>as if</em> rule, the program</p>\n<pre><code>int main(){\n  const int a = 5;\n  const int b = 5;\n  return &amp;b!=&amp;a;\n}\n</code></pre>\n<p>compiles to ( gcc 7.2 -O3 ):</p>\n<pre><code>main:\n  mov eax, 1\n  ret\n</code></pre>\n<p>:)</p>\n", "OwnerUserId": "8631381", "LastEditorUserId": "8631381", "LastEditDate": "2017-10-06T08:31:06.013", "Id": "46600272", "Score": "3", "CreationDate": "2017-10-06T07:16:38.717", "LastActivityDate": "2017-10-06T08:31:06.013"}});