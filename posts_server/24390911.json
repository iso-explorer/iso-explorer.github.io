post_cb({"bq_ids": {"n4140": {"so_24390911_24392099_4": {"length": 57, "quality": 0.95, "section_id": 333}, "so_24390911_24392099_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5965}, "so_24390911_24392099_3": {"length": 41, "quality": 0.9318181818181818, "section_id": 332}, "so_24390911_24392067_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 311}, "so_24390911_24392099_1": {"length": 19, "quality": 0.7916666666666666, "section_id": 311}}, "n3337": {"so_24390911_24392099_4": {"length": 57, "quality": 0.95, "section_id": 323}, "so_24390911_24392099_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 6848}, "so_24390911_24392099_3": {"length": 41, "quality": 0.9318181818181818, "section_id": 322}, "so_24390911_24392067_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 302}, "so_24390911_24392099_1": {"length": 19, "quality": 0.7916666666666666, "section_id": 302}}, "n4659": {"so_24390911_24392099_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 8605}, "so_24390911_24392099_4": {"length": 57, "quality": 0.95, "section_id": 342}, "so_24390911_24392099_3": {"length": 41, "quality": 0.9318181818181818, "section_id": 341}, "so_24390911_24392067_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 319}, "so_24390911_24392099_1": {"length": 19, "quality": 0.7916666666666666, "section_id": 319}}}, "24392067": {"Id": "24392067", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24390911_24392067_0\">C++11 14.8.2.2 Template arguments can be deduced from the type specified when taking the address of an overloaded function.</p>\n</blockquote>\n<p>Here, the type specified by the parameter type of <code>operator+</code> is <code>int (*)(int)</code>, the overloaded function is <code>twice</code>, so <code>int</code> is deduced as the template argument to give a matching function type. See 14.8.2.5 if you need the gory details of that deduction.</p>\n", "LastActivityDate": "2014-06-24T16:44:30.440", "CommentCount": "0", "CreationDate": "2014-06-24T16:44:30.440", "ParentId": "24390911", "Score": "4", "OwnerUserId": "204847"}, "24390911": {"ViewCount": "466", "Body": "<p>This is an offshoot of <a href=\"https://stackoverflow.com/a/24378020/434551\">an answer</a> to another <a href=\"https://stackoverflow.com/questions/24377892/why-is-stdendl-generating-this-cryptic-error-message\">SO post</a>.</p>\n<p>I have the following working code, with the expected output.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nT twice(T in)\n{\n   return 2*in;\n}\n\nstruct Foo\n{\n   Foo operator+(int (*func)(int in)) const\n   {\n      Foo ret{data};\n      ret.data += func(ret.data);\n      return ret;\n   }\n   int data;\n};\n\nint main()\n{\n   Foo f1{20};\n   Foo f2 = f1 + twice;\n   Foo f3 = f1 + twice&lt;int&gt;;\n   std::cout &lt;&lt; f2.data &lt;&lt; std::endl;\n   std::cout &lt;&lt; f3.data &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I did not know until yesterday that the compiler can deduce the type parameters of a function template even without an argument. In the code above, the expressions</p>\n<pre><code>f1 + twice\n</code></pre>\n<p>and</p>\n<pre><code>f1 + twice&lt;int&gt;\n</code></pre>\n<p>result in identical values.</p>\n<p>My question is: Where in the C++03/C++11 standard can we find the necessary supporting documentation for the compiler's auto type detection logic?</p>\n", "AcceptedAnswerId": "24392099", "Title": "Auto detection of template parameters without arguments", "CreationDate": "2014-06-24T15:41:27.933", "Id": "24390911", "CommentCount": "0", "LastEditDate": "2017-05-23T12:20:44.960", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-24T17:20:39.620", "Score": "4", "OwnerUserId": "434551", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "24392099": {"Id": "24392099", "PostTypeId": "2", "Body": "<p>This is closest to the actual c++11 standard but still openly available version of draft I've found: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a>.</p>\n<p>I believe the template parameter deduction is done when you write <code>Foo f2 = f1 + twice;</code> and pass <code>twice</code> as a function address. <code>twice</code> gets passed as an address of a function to the <code>operator+</code>. I believe the following mechanism kicks in:</p>\n<blockquote>\n<p id=\"so_24390911_24392099_0\"><strong>14.8.2.2</strong> Deducing template arguments taking the address of a function template\n  [temp.deduct.funcaddr]:</p>\n<p id=\"so_24390911_24392099_1\">Template arguments can be deduced from the type speci\ufb01ed when taking the address of an overloaded function (13.4). The function template\u2019s function type and the speci\ufb01ed type are used as the types of P and A, and the deduction is done as described in 14.8.2.5.</p>\n</blockquote>\n<p>So the actual template deduction will be done basing on the type of the <code>funct</code>. I believe the relevant paragraphs from <strong>14.8.2.5</strong> are <em>1</em> and <em>2</em>.</p>\n<blockquote>\n<p id=\"so_24390911_24392099_2\"><strong>14.8.2.5</strong> Deducing template arguments from a type [temp.deduct.type]`:</p>\n<p id=\"so_24390911_24392099_3\"><em>1</em> Template arguments can be deduced in several di\ufb00erent contexts, but in each case a type that is speci\ufb01ed in terms of template parameters (call it P) is compared with an actual type (call it A), and an attempt is made to \ufb01nd template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make P, after substitution of the deduced values (call it the deduced A), compatible with A.</p>\n<p id=\"so_24390911_24392099_4\"><em>2</em> In some cases, the deduction is done using a single set of types P and A, in other cases, there will be a set of corresponding types P and A. Type deduction is done independently for each P/A pair, and the deduced template argument values are then combined. If type deduction cannot be done for any P/A pair, or if for any pair the deduction leads to more than one possible set of deduced values, or if di\ufb00erent pairs yield di\ufb00erent deduced values, or if any template argument remains neither deduced nor explicitly speci\ufb01ed, template\n  argument deduction fails.</p>\n</blockquote>\n<p>Basically you pass <code>twice</code> as a pointer to the <code>operator+</code>, and then template arguments get deduced via type of the function as defined in <code>operator+</code>. So you have an actual type <code>A</code> that is <code>int (*)(int in)</code> and template types <code>P</code> of <code>twice</code> that gets matched against <code>A</code> and only <code>int twice(int)</code> fits.</p>\n<p><em>I hope I got everything right.</em></p>\n", "LastEditorUserId": "1133179", "LastActivityDate": "2014-06-24T17:20:39.620", "Score": "3", "CreationDate": "2014-06-24T16:45:42.067", "ParentId": "24390911", "CommentCount": "0", "OwnerUserId": "1133179", "LastEditDate": "2014-06-24T17:20:39.620"}});