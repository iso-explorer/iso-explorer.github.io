post_cb({"bq_ids": {"n4140": {"so_17388317_17388446_0": {"length": 19, "quality": 0.95, "section_id": 335}}, "n3337": {"so_17388317_17388446_0": {"length": 19, "quality": 0.95, "section_id": 325}}, "n4659": {"so_17388317_17388446_0": {"length": 19, "quality": 0.95, "section_id": 344}}}, "17389623": {"Id": "17389623", "PostTypeId": "2", "Body": "<p><strong>Yes</strong>, I managed to get the following work (since you allow <em>something similar</em>):</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nvoid foo(array&lt;T, N&gt; src) { ... }\n\n...\n\nfoo('a', 'b');\nfoo(1, 2, 3);\n</code></pre>\n<p>Here is how:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\ntemplate&lt;typename T, unsigned long N&gt;\nvoid foo(array&lt;T,N&gt; src) { \n\n  for (auto e : src)\n    cout &lt;&lt; e &lt;&lt; endl;\n}\n\ntemplate&lt;class T, class... Tail&gt;\nauto make_array(T head, Tail... tail) -&gt; std::array&lt;T, 1 + sizeof...(Tail)&gt;\n{\n     std::array&lt;T, 1 + sizeof...(Tail)&gt; a = {{ head, tail ... }};\n     return a;\n}\n\ntemplate&lt;class T, class... Tail&gt; \nvoid foo(T&amp;&amp; head, Tail&amp;&amp;... values) {\n\n    foo(make_array(std::forward&lt;T&gt;(head), std::forward&lt;Tail&gt;(values)...));\n}\n\nint main() {\n\n  foo('a', 'b');\n\n  foo(1, 2, 3);\n}\n</code></pre>\n<p>I have tested this with gcc 4.7.2 and with clang 3.4 (trunk 184647), they work as expected.<br>\nHere is an online version <a href=\"http://coliru.stacked-crooked.com/view?id=6763ae9f3d248efc1e32110937109c21-f674c1a6d04c632b71a62362c0ccfc51\" rel=\"nofollow noreferrer\">at Stacked-Crooked.</a> However, this code fails to compile at Ideone. Since I was unable to figure out the options passed to the compiler at Ideone, I've given up on that site.</br></p>\n<hr>\n<p>I have shamelessly stolen the <code>make_array</code> function from <a href=\"https://stackoverflow.com/users/111335/pavel-minaev\">@Pavel Minaev</a>'s answer to the <a href=\"https://stackoverflow.com/a/6114299/341970\">How to emulate C array initialization \u201cint arr[] = { e1, e2, e3, \u2026 }\u201d behaviour with std::array?</a> question. The other <code>make_array</code> suggestions caused compile errors that I couldn't fix.</p>\n<p>This <code>make_array</code> function has limitations, please read <a href=\"https://stackoverflow.com/q/6114067/341970\">the entire post</a>; in particular the discussion <a href=\"https://groups.google.com/forum/#!topic/comp.lang.c++.moderated/8aWhRRsAO-w\" rel=\"nofollow noreferrer\">std::array - if only it knew its size</a> on comp.lang.c++.moderated is referenced. Apparently, getting a reasonable <code>make_array</code> is quite tricky. <strong>I wouldn't recommend the simple-minded <code>make_array</code> in this answer to be used in production code.</strong> </p>\n<hr>\n<p>You wouldn't have any problems if the size was a template argument to <code>std::initializer_list</code>. Hence the question <a href=\"https://stackoverflow.com/q/7108425/341970\">Why is the size not a template argument of std::initializer_list?</a></p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-01T13:59:27.567", "Score": "6", "CreationDate": "2013-06-30T10:54:40.253", "ParentId": "17388317", "CommentCount": "2", "OwnerUserId": "341970", "LastEditDate": "2017-05-23T12:09:27.040"}, "17388317": {"ViewCount": "1758", "Body": "<p>In C++11, is it possible to do something similar to the following?</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nvoid foo(array&lt;T, N&gt; src) { ... }\n\n...\n\nfoo({1, 2, 3})\n</code></pre>\n<p>I'm currently running GCC 4.8.</p>\n", "AcceptedAnswerId": "17389623", "Title": "C++11 Implicit conversion from initialization list to array parameter", "CreationDate": "2013-06-30T07:52:47.457", "Id": "17388317", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-07-01T13:59:27.567", "Score": "4", "OwnerUserId": "156242", "Tags": "<c++><templates><c++11><initializer-list>", "AnswerCount": "3"}, "17388446": {"Id": "17388446", "PostTypeId": "2", "Body": "<p>Apparently not. The standard (14.8.2.5) calls this an non-deduced context; </p>\n<blockquote>\n<p id=\"so_17388317_17388446_0\">In certain contexts, however, the value does not participate in type deduction, but instead uses the values of template arguments that were either deduced elsewhere or explicitly speci\ufb01ed.</p>\n<p id=\"so_17388317_17388446_1\">...</p>\n<p id=\"so_17388317_17388446_2\">The non-deduced contexts are:</p>\n<p id=\"so_17388317_17388446_3\">...</p>\n<ul>\n<li>A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter does not have std::initializer_list or reference to possibly cv-quali\ufb01ed std::initializer_list type.  </li>\n</ul>\n<p id=\"so_17388317_17388446_4\">Example:</p>\n<p id=\"so_17388317_17388446_5\">template&lt;class T&gt; void g(T);<br>\n  g({1,2,3}); // error: no argument deduced for T</br></p>\n</blockquote>\n<p>EDIT: You <em>can</em> make the same thing work with <code>std::vector</code>, if you just use an <code>initializer_list</code> overload to make the deduction of the <em>type</em> work;</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;typename T&gt;\n  void foo(const std::vector&lt;T&gt;&amp; src) { ...your code here... }\ntemplate&lt;typename T&gt;\n  void foo(const std::initializer_list&lt;T&gt;&amp; src) { foo(std::vector&lt;T&gt;(src)); }\n\nfoo({1,2,3});  // Compiles\n</code></pre>\n<p>...but sadly, since the size of <code>initializer_list</code> is not a template argument, I can't think of a way to make it deduce and forward the array <em>size</em> from the <code>initializer_list</code> in the same way as the type.</p>\n", "LastEditorUserId": "477878", "LastActivityDate": "2013-06-30T08:59:10.013", "Score": "3", "CreationDate": "2013-06-30T08:10:28.417", "ParentId": "17388317", "CommentCount": "2", "OwnerUserId": "477878", "LastEditDate": "2013-06-30T08:59:10.013"}, "17388748": {"Id": "17388748", "PostTypeId": "2", "Body": "<p>You <em>could</em> use an initializer list directly to achieve that syntax. e.g.:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nvoid foo(std::initializer_list&lt;int&gt; il) {\n  for (auto i: il)\n    std::cout &lt;&lt; i &lt; std::endl;\n}\n\nint main() {\n  foo({1,2,3});\n}\n</code></pre>\n<p>or make it more generic:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(std::initializer_list&lt;T&gt; il) {\n  ...\n</code></pre>\n", "LastActivityDate": "2013-06-30T08:54:36.600", "CommentCount": "0", "CreationDate": "2013-06-30T08:54:36.600", "ParentId": "17388317", "Score": "1", "OwnerUserId": "923854"}});