post_cb({"bq_ids": {"n4140": {"so_24909652_24910057_5": {"length": 46, "quality": 0.9583333333333334, "section_id": 245}, "so_24909652_24910057_3": {"length": 45, "quality": 0.9183673469387755, "section_id": 300}, "so_24909652_24910057_1": {"length": 110, "quality": 0.9322033898305084, "section_id": 355}}, "n3337": {"so_24909652_24910057_5": {"length": 46, "quality": 0.9583333333333334, "section_id": 237}, "so_24909652_24910057_3": {"length": 39, "quality": 0.7959183673469388, "section_id": 291}, "so_24909652_24910057_1": {"length": 110, "quality": 0.9322033898305084, "section_id": 345}}, "n4659": {"so_24909652_24910057_5": {"length": 45, "quality": 0.9375, "section_id": 252}, "so_24909652_24910057_3": {"length": 45, "quality": 0.9183673469387755, "section_id": 307}, "so_24909652_24910057_1": {"length": 110, "quality": 0.9322033898305084, "section_id": 365}}}, "24910057": {"Id": "24910057", "PostTypeId": "2", "Body": "<p>The type <code>z</code> is an <code>int</code>, is not being deduced by the compiler, no room for SFINAE to take place. The value being used to initialise <code>z</code> is based on the default of <code>T::foo</code>, which doesn't exist; hence the error.</p>\n<p>If the type for <code>z</code> is elevated to the template itself, substitution can now fail, and SFINAE kicks in.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct My\n{\n   typedef int foo;\n};\n\nstruct My2\n{\n};\n\ntemplate &lt;typename T, typename I = typename T::foo&gt;\nvoid Bar(const T&amp;, I z = I())\n{\n    (void)z; // silence any warnings on unused\n    std::cout &lt;&lt; \"My\" &lt;&lt; std::endl; \n}\n\nvoid Bar(...)\n{\n    std::cout &lt;&lt; \"...\" &lt;&lt; std::endl; \n}\n\nint main() \n{\n    My my;\n    Bar(my);\n    My2 my2;\n    Bar(my2); // Compiles\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bef18bcde4a1c407\" rel=\"nofollow\">Live sample</a></p>\n<p>In order for a function template to be part of the overloaded list of candidate functions, the template argument deduction must succeed. If it fails, then the candidate is removed from the list. Hence, if no deduction failure occurs, it is added to the candidate list (but this does not preclude further errors if it is finally selected).</p>\n<blockquote>\n<p id=\"so_24909652_24910057_0\"><em>14.8.3/1 Overload resolution</em></p>\n<p id=\"so_24909652_24910057_1\">A function template can be overloaded either by (non-template) functions of its name or by (other) function templates of the same name. When a call to that name is written (explicitly, or implicitly using the operator notation), template argument deduction (14.8.2) and checking of any explicit template arguments (14.3) are performed for each function template to find the template argument values (if any) that can be used with that function template to instantiate a function template specialization that can be invoked with the call arguments. For each function template, if the argument deduction and checking succeeds, the template arguments (deduced and/or explicit) are used to synthesize the declaration of a single function template specialization which is added to the candidate functions set to be used in overload resolution. If, for a given function template, <strong>argument deduction fails, no such function is added to the set of candidate functions</strong> for that template. The complete set of candidate functions includes all the synthesized declarations and all of the non-template overloaded functions of the same name. The synthesized declarations are treated like any other functions in the remainder of overload resolution, except as explicitly noted in 13.3.3.</p>\n</blockquote>\n<p>Template argument deduction is performed on the function type and its template arguments themselves.</p>\n<blockquote>\n<p id=\"so_24909652_24910057_2\"><em>14.8.2/8 Template argument deduction</em></p>\n<p id=\"so_24909652_24910057_3\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note: If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution process. \u2014end note ] Only invalid types and expressions in the <strong>immediate context of the function type and its template parameter types</strong> can result in a deduction failure.</p>\n</blockquote>\n<p>From the OP, the function <code>Bar&lt;T&gt;</code> is added to the candidate list since it can be deduced what the type for <code>T</code> is. It is instantiated and the default arguments are checked, and hence it fails.</p>\n<blockquote>\n<p id=\"so_24909652_24910057_4\"><em>14.7.1/13 Implicit instantiation</em></p>\n<p id=\"so_24909652_24910057_5\">If a function template f is called in a way that requires a default argument to be used, the dependent names are looked up, <strong>the semantics constraints are checked, and the instantiation of any template used in the default argument is done as if the default argument had been an initializer used in a function template specialization with the same scope</strong>, the same template parameters and the same access as that of the function template <code>f</code> used at that point. This analysis is called default argument instantiation. The instantiated default argument is then used as the argument of <code>f</code>.</p>\n</blockquote>\n<p>Quotes taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">draft n3797</a></p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2014-07-23T21:46:23.737", "Score": "4", "CreationDate": "2014-07-23T12:05:26.250", "ParentId": "24909652", "CommentCount": "2", "OwnerUserId": "3747990", "LastEditDate": "2014-07-23T21:46:23.737"}, "24911415": {"Id": "24911415", "PostTypeId": "2", "Body": "<p>The type of <code>z</code> is not subject to template substitution, it is always <code>int</code>. This means there is no opportunity for SFINAE, and you instead get a compiler error when attempting to resolve <code>T::foo</code> for the default value. Default arguments do not participate in overload resolution, instead being instantiated only when missing from the function call. Section 14.7.1 (paragraphs 13/14) of the standard describes this behaviour, but does not give jusification for the lack of SFINAE here.</p>\n<p>SFINAE can be allowed to happen by making the type of <code>z</code> a template parameter, as below:</p>\n<p>(live example: <a href=\"http://ideone.com/JynMye\">http://ideone.com/JynMye</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct My\n{\n   typedef int foo;\n};\n\nstruct My2\n{\n};\n\ntemplate&lt;typename T, typename I=typename T::foo&gt; void Bar(const T&amp;, I z = I())\n{\n    std::cout &lt;&lt; \"My\\n\";\n}\n\nvoid Bar(...)\n{\n    std::cout &lt;&lt; \"...\\n\";\n}\n\nint main() \n{\n    My my;\n    Bar(my); // OK\n    My2 my2;\n    Bar(my2); // Also OK\n    return 0;\n}\n</code></pre>\n<p>This will use the \"My\" version for the first call, and the \"...\" version for the second call. The output is</p>\n<pre><code>My\n...\n</code></pre>\n<p>However, if void Bar(...) was a template, for whatever reason, the \"My\" version will never get a chance:</p>\n<p>(live example: <a href=\"http://ideone.com/xBQiIh\">http://ideone.com/xBQiIh</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct My\n{\n   typedef int foo;\n};\n\nstruct My2\n{\n};\n\ntemplate&lt;typename T, typename I=typename T::foo&gt; void Bar(const T&amp;, I z = I())\n{\n    std::cout &lt;&lt; \"My\\n\";\n}\n\ntemplate&lt;typename T&gt; void Bar(T&amp;)\n{\n    std::cout &lt;&lt; \"...\\n\";\n}\n\nint main() \n{\n    My my;\n    Bar(my); // OK\n    My2 my2;\n    Bar(my2); // Also OK\n    return 0;\n}\n</code></pre>\n<p>Here, the \"...\" version is called in both cases. The output is:</p>\n<pre><code>...\n...\n</code></pre>\n<p>One solution is to use class template (partial) specialisation; provide the \"...\" version as the base, with the type of the second parameter defaulted to <code>int</code>, and the \"My\" version as a specialisation where the second parameter is <code>typename T::foo</code>. In conjunction with a plain template function to deduce T and dispatch to the appropriate class' member function, this produces the desired effect:</p>\n<p>(live example: <a href=\"http://ideone.com/FanLPc\">http://ideone.com/FanLPc</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct My\n{\n   typedef int foo;\n};\n\nstruct My2\n{\n};\n\ntemplate&lt;typename T, typename I=int&gt; struct call_traits {\n    static void Bar(...)\n    {\n        std::cout &lt;&lt; \"...\\n\";\n    }\n};\n\ntemplate&lt;typename T&gt; struct call_traits&lt;T, typename T::foo&gt; {\n    static void Bar(const T&amp;, int z=typename T::foo())\n    {\n        std::cout &lt;&lt; \"My\\n\";\n    }\n};\n\ntemplate&lt;typename T&gt; void Bar(const T&amp; t)\n{\n    call_traits&lt;T&gt;::Bar(t);\n}\n\nint main() \n{\n    My my;\n    Bar(my); // OK\n    My2 my2;\n    Bar(my2); // Still OK\n    return 0;\n}\n</code></pre>\n<p>Here, the output is:</p>\n<pre><code>My\n...\n</code></pre>\n", "LastEditorUserId": "3852968", "LastActivityDate": "2014-07-23T14:16:14.173", "Score": "10", "CreationDate": "2014-07-23T13:11:09.167", "ParentId": "24909652", "CommentCount": "4", "OwnerUserId": "3852968", "LastEditDate": "2014-07-23T14:16:14.173"}, "24914425": {"Id": "24914425", "PostTypeId": "2", "Body": "<p>One more C++03 compatible option for you. Because in answers above default argument was used in template function and it is not permitted in standard.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct TypeWithFoo{\n   typedef int Foo;\n};\n\ntemplate&lt;typename T, bool&gt;\nstruct onFooAction;\n\ntemplate&lt;typename T&gt;\nstruct onFooAction&lt;T, false&gt;{\n   void operator ()(const T &amp;t){\n        std::cout &lt;&lt; \"No foo :(\\n\";\n   }\n};\n\ntemplate&lt;typename T&gt;\nstruct onFooAction&lt;T, true&gt;{\n   void operator ()(const T &amp;t){\n      std::cout &lt;&lt; \"Foo =)\\n\";\n   }\n};\n\ntemplate&lt;typename T&gt;\nstruct hasFoo{\n   typedef char yes[1];\n   typedef char no[2];\n\n   template&lt;typename C&gt;\n   static yes&amp; testForFoo(typename C::Foo*);\n\n   template&lt;typename&gt;\n   static no&amp; testForFoo(...);\n\n   static const bool value = sizeof(testForFoo&lt;T&gt;(0)) == sizeof(yes);\n};\n\ntemplate&lt;typename T&gt;\nvoid bar(const T &amp;t){\n   onFooAction&lt;T, hasFoo&lt;T&gt;::value&gt;()(t);\n}\n\nint main(){\n  bar(10);\n  bar(TypeWithFoo());\n}\n</code></pre>\n", "LastActivityDate": "2014-07-23T15:17:34.623", "CommentCount": "0", "CreationDate": "2014-07-23T15:17:34.623", "ParentId": "24909652", "Score": "2", "OwnerUserId": "3853514"}, "24909652": {"ViewCount": "539", "Body": "<p>I have this code:</p>\n<pre><code>struct My\n{\n   typedef int foo;\n};\n\nstruct My2\n{\n};\n\n\ntemplate &lt;typename T&gt;\nvoid Bar(const T&amp;, int z = typename T::foo())\n{\n    std::cout &lt;&lt; \"My\" &lt;&lt; std::endl; \n}\n\n\nvoid Bar(...)\n{\n    std::cout &lt;&lt; \"...\" &lt;&lt; std::endl; \n}\n\nint main() \n{\n    My my;\n    Bar(my); // OK\n    My2 my2;\n    Bar(my2); // Compile error: no type named \u2018foo\u2019 in \u2018struct My2\u2019\n    return 0;\n}\n</code></pre>\n<p>I suppose, that if some class T doesn't have typedef foo inside, compiler should exclude first overload and choose overload with ellipsis. But I check this code on MSVC, gcc and clang and I get compile error on those compilers. Why SFINAE doesn't work in this case?</p>\n", "AcceptedAnswerId": "24911415", "Title": "Why SFINAE doesn't work in right side in default function arguments?", "CreationDate": "2014-07-23T11:46:02.870", "Id": "24909652", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-23T12:42:44.160", "LastEditorUserId": "3290628", "LastActivityDate": "2014-07-23T21:46:23.737", "Score": "10", "OwnerUserId": "3290628", "Tags": "<c++><sfinae>", "AnswerCount": "3"}});