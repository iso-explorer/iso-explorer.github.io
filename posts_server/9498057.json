post_cb({"9498057": {"ViewCount": "1637", "Body": "<p>I can not overflow the bool variable becomes zero. The variables of type bool is 1 byte long\uff0cso I consider it will overflow when variables are stored 256\uff0cbut it's not like I expected.</p>\n<pre><code>#include&lt;iostream&gt;\n\n\nint main()\n{\n    bool b = 0;\n    std::cout &lt;&lt; sizeof(b) &lt;&lt; std::endl; // the result is 1 byte\n    std::cout &lt;&lt; b &lt;&lt; std::endl; // the result is 0\n\n\n    b = 256;\n    std::cout &lt;&lt; b &lt;&lt; std::endl; // the result is 1,rather than the desired zero\n\n    return 0;\n}\n</code></pre>\n<p><strong>Maybe I did not make it clear that when only 1 byte,both 0 and 256 are stored as 00000000(binary)</strong></p>\n", "Title": "Why bool variable can not be set to 0, in addition to the direct assignment of 0?", "CreationDate": "2012-02-29T11:15:16.277", "LastActivityDate": "2012-03-02T14:03:50.990", "CommentCount": "5", "LastEditDate": "2012-03-01T10:03:06.287", "PostTypeId": "1", "LastEditorUserId": "1213239", "Id": "9498057", "Score": "3", "OwnerUserId": "1213239", "Tags": "<c++>", "AnswerCount": "8"}, "9498102": {"Id": "9498102", "PostTypeId": "2", "Body": "<p>Probably 256 is not directly assigned but checked if it is 0. If so, the boolean will be false (0), otherwise it will be true (!= 0).</p>\n", "LastActivityDate": "2012-02-29T11:17:58.130", "CommentCount": "0", "CreationDate": "2012-02-29T11:17:58.130", "ParentId": "9498057", "Score": "0", "OwnerUserId": "1187220"}, "9498151": {"Id": "9498151", "PostTypeId": "2", "Body": "<p>Try</p>\n<pre><code>*reinterpret_cast&lt;unsigned char *&gt;(&amp;b) = 256;\n</code></pre>\n<p>It is, nonetheless, unsafe (<code>sizeof(bool)</code> can be 1 or 4 or anything else, depending on implementation).</p>\n", "LastActivityDate": "2012-02-29T11:21:14.653", "CommentCount": "2", "CreationDate": "2012-02-29T11:21:14.653", "ParentId": "9498057", "Score": "0", "OwnerUserId": "135669"}, "9498127": {"Id": "9498127", "PostTypeId": "2", "Body": "<p>A <code>bool</code> may use one byte in your platform, but its value representation has only one 1 bit, because there are only two values of type <code>bool</code>: <code>true</code> and <code>false</code>. Not 0, not 1, not 256.</p>\n<p>This is mentioned in section 3.9.1 of the C++ standard, paragraph 6:</p>\n<blockquote>\n<p id=\"so_9498057_9498127_0\">Values of type <code>bool</code> are either <code>true</code> or <code>false</code>. (...)</p>\n</blockquote>\n<p>You can assign 0 and 256 to a variable of type <code>bool</code> because there is an implicit conversion between <code>int</code> and <code>bool</code>. That conversion converts zero to <code>false</code> and anything else to <code>true</code>. That's what you're seeing here.</p>\n<p>This is specified in section 4.12:</p>\n<blockquote>\n<p id=\"so_9498057_9498127_1\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to\n  member type can be converted to a prvalue of type <code>bool</code>. A zero value,\n  null pointer value, or null member pointer value is converted to\n  <code>false</code>; any other value is converted to <code>true</code>. (...)</p>\n</blockquote>\n<p><code>b = 256</code> <em>is not storing <code>256</code></em>. It's storing <code>true</code>. You cannot store <code>256</code> in a <code>bool</code> variable because <code>256</code> is not a <code>bool</code> value. This is C++ <strong>not some form of assembly</strong>. <code>b = 256</code> does not mean \"write the lower 8 bits of 256 into the memory location referred to by variable <code>b</code>\". As the standard quotes above show, it means \"if 256 is zero, assign <code>false</code> to the variable <code>b</code>; otherwise assign <code>true</code>\".</p>\n<p>In common implementations the value <code>false</code> is represented as 00000000 in binary, but there is nothing preventing that. An implementation is free to choose different object representations as appropriate, because that's irrelevant: C++ code cannot see it without subverting the type system and wondering into implementation-defined behaviour. An implementation can be perfectly valid and pick 0xDEADBABE and 0xDEADD00D as the object representations of <code>true</code> and <code>false</code>: only one bit carries the value representation. The thing that matters is that <code>bool</code> is a type meant to represent simple truth values. It's not \"a bunch of bits that we can test against zero\".</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-02T01:55:32.457", "Score": "3", "CreationDate": "2012-02-29T11:19:49.073", "ParentId": "9498057", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2012-03-02T01:55:32.457"}, "9498116": {"Id": "9498116", "PostTypeId": "2", "Body": "<p>That is how bool type works, it can be zero or non-zero</p>\n", "LastActivityDate": "2012-02-29T11:18:44.173", "CommentCount": "0", "CreationDate": "2012-02-29T11:18:44.173", "ParentId": "9498057", "Score": "0", "OwnerUserId": "766022"}, "9498104": {"Id": "9498104", "PostTypeId": "2", "Body": "<p>The rule for converting numeric types to <code>bool</code> is simple: zero becomes <code>false</code>, all other values become <code>true</code>. The size and layout of the either type is irrelevant.</p>\n<p>If you want it in Standardese:</p>\n<blockquote>\n<p id=\"so_9498057_9498104_0\">C++11 4.12: A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>.</p>\n</blockquote>\n", "LastActivityDate": "2012-02-29T11:17:58.943", "CommentCount": "0", "CreationDate": "2012-02-29T11:17:58.943", "ParentId": "9498057", "Score": "8", "OwnerUserId": "204847"}, "9498235": {"Id": "9498235", "PostTypeId": "2", "Body": "<p>bool is a system defined type and can accept only true/false or alternately 1/0. The fact that it occupies one byte is because of the restrictions placed by the present storage mechanisms: It is not possible to address data of less than one byte in the present scenario.</p>\n<p>To make it simple to understand: think of bool as a system defined type that has an overridden assignment operator. The operator internally converts any assignment to 1/0 and hence, no overflow.</p>\n", "LastActivityDate": "2012-02-29T11:26:46.947", "CommentCount": "0", "CreationDate": "2012-02-29T11:26:46.947", "ParentId": "9498057", "Score": "0", "OwnerUserId": "1240105"}, "bq_ids": {"n4140": {"so_9498057_9498127_0": {"length": 6, "quality": 1.0, "section_id": 7215}, "so_9498057_9498127_1": {"length": 28, "quality": 1.0, "section_id": 44}, "so_9498057_9498104_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 44}}, "n3337": {"so_9498057_9498127_0": {"length": 6, "quality": 1.0, "section_id": 6959}, "so_9498057_9498127_1": {"length": 28, "quality": 1.0, "section_id": 41}, "so_9498057_9498104_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 41}}, "n4659": {"so_9498057_9498127_0": {"length": 6, "quality": 1.0, "section_id": 8724}, "so_9498057_9498127_1": {"length": 28, "quality": 1.0, "section_id": 45}, "so_9498057_9498104_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 45}}}, "9498111": {"Id": "9498111", "PostTypeId": "2", "Body": "<p>Becase the C++ standard says something like (too lazy to dig out the exact quote now) \"assigning a numeric value to a bool variable, a value of zero is converted to false, any other value is converted to true\".</p>\n", "LastActivityDate": "2012-02-29T11:18:21.743", "CommentCount": "0", "CreationDate": "2012-02-29T11:18:21.743", "ParentId": "9498057", "Score": "1", "OwnerUserId": "75652"}, "9498098": {"Id": "9498098", "PostTypeId": "2", "Body": "<p>Converting to <code>bool</code> any numeric value other than <code>0</code> yields <code>1</code>/<code>true</code>.</p>\n<p>Even though <code>sizeof(bool) == 1</code>, it's semantics are different from that of <code>char</code>.</p>\n", "LastActivityDate": "2012-02-29T11:17:52.517", "CommentCount": "0", "CreationDate": "2012-02-29T11:17:52.517", "ParentId": "9498057", "Score": "1", "OwnerUserId": "166749"}});