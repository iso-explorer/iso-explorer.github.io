post_cb({"bq_ids": {"n4140": {"so_47830449_47830449_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 6143}, "so_47830449_47830449_0": {"length": 26, "quality": 0.7647058823529411, "section_id": 6142}}, "n3337": {"so_47830449_47830449_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 5907}, "so_47830449_47830449_0": {"length": 26, "quality": 0.7647058823529411, "section_id": 5906}}, "n4659": {"so_47830449_47830449_1": {"length": 11, "quality": 1.0, "section_id": 7638}, "so_47830449_47830449_0": {"length": 34, "quality": 1.0, "section_id": 7638}}}, "47831523": {"Id": "47831523", "PostTypeId": "2", "Body": "<p>The pointer arithmetic should be legal according to the quotes. An <code>Object</code> instance <code>obj</code> can be viewed as <code>char[sizeof(Object)]</code>. So, it is an array of <code>n</code> elements (note that <code>n</code> is <code>sizeof(Object)</code>). Standard allows to do pointer arithmetic in bounds of this array <em>plus one hypothetical element beyond the bounds of this array</em>. This is due to <em>less or equal</em> sign in the </p>\n<blockquote>\n<p id=\"so_47830449_47831523_0\">0 \u2264 i + j \u2264 n</p>\n</blockquote>\n<p>expression. </p>\n<p>Literally, <code>reinterpret_cast&lt;char*&gt; (&amp;obj) + sizeof(Object)</code> is fine because it points to hypothetical element <code>a[j]</code>, where <code>j = sizeof(Object)</code> and it is <em>less or equal</em> than size of the array, which is <code>sizeof(Object)</code>.</p>\n<p>So, the answer is yes. </p>\n<p>Otherwise <code>std::end</code> for arrays would be UB.</p>\n", "LastEditorUserId": "1282773", "LastActivityDate": "2017-12-15T11:47:43.663", "Score": "1", "CreationDate": "2017-12-15T11:34:05.970", "ParentId": "47830449", "CommentCount": "6", "OwnerUserId": "1282773", "LastEditDate": "2017-12-15T11:47:43.663"}, "47830449": {"ViewCount": "193", "Body": "<p>This is a common way to read the bytes of an trivially copyable object</p>\n<pre><code>Object obj;\nauto p = reinterpret_cast&lt;char*&gt;(&amp;obj);\nfor(size_t i = 0; i &lt; sizeof(obj); i++)\n    consume(p[i]);\n</code></pre>\n<p>The problem isn't with strict-aliasing, <code>char*</code> is allowed to alias anything. The problem is with this passage from <a href=\"https://timsong-cpp.github.io/cppwp/expr.add#4\" rel=\"nofollow noreferrer\">[expr.add]</a></p>\n<blockquote>\n<p id=\"so_47830449_47830449_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the expression <code>P</code> points to element <code>x[i]</code> of an array object <code>x</code> with <code>n</code> elements, the expressions <code>P + J</code> and <code>J + P</code> (where <code>J</code> has the value <code>j</code>) point to the (possibly-hypothetical) element <code>x[i + j]</code> if <code>0 \u2264 i + j \u2264 n</code>; otherwise, the behavior is undefined. Likewise, the expression <code>P - J</code> points to the (possibly-hypothetical) element <code>x[i \u2212 j]</code> if <code>0 \u2264 i \u2212 j \u2264 n</code>; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>Where hypothetical element refers to</p>\n<blockquote>\n<p id=\"so_47830449_47830449_1\">A pointer past the last element of an array <code>x</code> of <code>n</code> elements is considered to be equivalent to a pointer to a hypothetical element <code>x[n]</code> for this purpose</p>\n</blockquote>\n<p>Which is to say, it is only legal if the arithmetic is on a pointer pointing at an array, and the result is still within its range.</p>\n<p>However, there is clearly no <code>char[sizeof(Object)]</code> here, can we do arithmetic on that pointer?</p>\n<p>Note that a legal solution to reading bytes of an object is to <code>std::memcpy</code> the object. But if that is the <em>only</em> solution, it begs to ask, why allow <code>char*</code> aliasing if you can barely do anything with it?</p>\n", "Title": "Can you do arithmetic on a char* pointing at another object", "CreationDate": "2017-12-15T10:33:00.067", "LastActivityDate": "2017-12-15T11:47:43.663", "CommentCount": "19", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-15T11:18:49.857", "LastEditorUserId": "4832499", "Id": "47830449", "ClosedDate": "2017-12-15T12:59:57.403", "Score": "7", "OwnerUserId": "4832499", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});