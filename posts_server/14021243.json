post_cb({"bq_ids": {"n4140": {"so_14021243_14021362_0": {"length": 76, "quality": 0.8735632183908046, "section_id": 260}, "so_14021243_14021362_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 251}}, "n3337": {"so_14021243_14021362_0": {"length": 76, "quality": 0.8735632183908046, "section_id": 251}, "so_14021243_14021362_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 242}}, "n4659": {"so_14021243_14021362_0": {"length": 76, "quality": 0.8735632183908046, "section_id": 267}, "so_14021243_14021362_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 258}}}, "14021243": {"ViewCount": "582", "Body": "<p>Is this a correct usage of extern template in C++11? (Can it be that the <code>extern template class</code> and respective <code>template class</code> is visible in the same translation unit?)</p>\n<pre><code>// example.hpp:\n#pragma once\ntemplate&lt; typename T &gt;\nclass C {\n    void f(T);\n};\n// question is about the next two lines\nextern template class C&lt; float &gt;;\nextern template class C&lt; double &gt;;\n// example_def.hpp:\n#include \"example.hpp\"\ntemplate&lt; typename T &gt;\nvoid C&lt; T &gt;::f(T) {\n    //... smth. practicable\n}\n// example.cpp:\n#include \"example_def.hpp\"\ntemplate class C&lt; float &gt;;\ntemplate class C&lt; double &gt;;\n// other.hpp:\n#pragma once\nvoid g();\n// other.cpp:\n#include \"other.hpp\"\n#include \"example.hpp\"\n// maybe those two lines should be here instead?\nvoid g() {\n    C&lt; float &gt;();\n    C&lt; double &gt;();\n}\n// main.cpp:\n#include \"example.hpp\"\n#include \"other.hpp\"\n// ...and here?\nint main() {\n    C&lt; float &gt;();\n    C&lt; double &gt;();\n    g();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "14021362", "Title": "template class and respective extern template class in same translation unit", "CreationDate": "2012-12-24T12:12:26.497", "Id": "14021243", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-12-24T13:08:50.760", "Score": "3", "OwnerUserId": "1430927", "Tags": "<c++><templates><c++11><extern>", "AnswerCount": "2"}, "14021775": {"Id": "14021775", "PostTypeId": "2", "Body": "<p>The basic idea of <code>extern</code> templates is to support explicit instantiation of commonly used instantiations while also supporting implicit instantiations for less commonly used parameters. For example, <code>std::basic_string&lt;char&gt;</code> could be explicitly instaniated but <code>std::basic_string&lt;signed char&gt;</code> could be left for implicit instantiation (the actual motivating examples were IOStreams which take substantial time to get instantiated but only two instantiations are actually used).</p>\n<p>To allow implicit instantiation the definition of the used templates needs to be visible in each translation unit where the template is used. If the template definition is visible the compiler assumes by default that it needs to provide an instantiation implicitly. Using an <code>extern</code> template declaration tells the compiler that the specific template instantiation will be provided by some translation unit.</p>\n<p>Although your case works it isn't even necessary to declare the <code>extern</code> templates: When the compiler uses an instantiation and doesn't find its definition it will assume that the instantiation is found in some translation unit.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-12-24T13:08:50.760", "Score": "3", "CreationDate": "2012-12-24T13:02:44.593", "ParentId": "14021243", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2012-12-24T13:08:50.760"}, "14021362": {"Id": "14021362", "PostTypeId": "2", "Body": "<p>Yes, both an <code>extern template class</code> specification (called <em>explicit instantiation <strong>declaration</strong></em> by the Standard) and a <code>template class</code> specification (called <em>explicit instantiation <strong>definition</strong></em> by the Standard) can be in the same translation unit, if the definition (without <code>extern</code>) follows the declaration (with <code>extern</code>):</p>\n<blockquote>\n<p id=\"so_14021243_14021362_0\">(\u00a714.7.2/11) <strong>If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation de\ufb01nition in the same translation unit, the de\ufb01nition shall follow the declaration.</strong> An entity that is the subject of an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit instantiation (14.7.1) in the translation unit shall be the subject of an explicit instantiation de\ufb01nition somewhere in the program; otherwise the program is ill-formed, no diagnostic required. [ Note: This rule does apply to inline functions even though an explicit instantiation declaration of such an entity has no other normative e\ufb00ect. This is needed to ensure that if the address of an inline function is taken in a translation unit in which the implementation chose to suppress the out-of-line body, another translation unit will supply the body. \u2014 end note ] An explicit instantiation declaration shall not name a specialization of a template with internal linkage.</p>\n</blockquote>\n<p>(Emphasis mine). The terms <em>explicit instantiation declaration</em> and <em>explicit instantiation definition</em> are defined here:</p>\n<blockquote>\n<p id=\"so_14021243_14021362_1\">(\u00a714.7.2/2) The syntax for explicit instantiation is:</p>\n<p id=\"so_14021243_14021362_2\">explicit-instantiation:<br>\n<code>extern</code><sub>opt</sub> <code>template</code> <em>declaration</em> </br></p>\n<p id=\"so_14021243_14021362_3\">There are two forms of explicit instantiation: an explicit instantiation de\ufb01nition and an explicit instantiation declaration. An explicit instantiation declaration begins with the extern keyword.</p>\n</blockquote>\n<hr>\n<p>The <strong>effect of these explicit instantiations</strong> is as follows:</p>\n<ol>\n<li><p>The explicit instantiation declaration (with <code>extern</code>) prevents all <em>implicit</em> instantiations to take effect (except for inline functions and class template <em>specializations</em>, \u00a714.7.2/10).</p></li>\n<li><p>The explicit instantiation definition (without <code>extern</code>) causes the instantiation to happen <em>no matter what</em>, i.e. it overrides the explicit instantiation declaration (this also follows from \u00a714.7.2/10).</p></li>\n</ol>\n<hr>\n<p><strong>General comments</strong><br>\nThe fact that your explicit instantiation declarations are located in the header file that defines the template implies that <em>anyone</em> who includes the header files in order to make use of the template will either have to also add an explicit instantiation <em>definition</em>, or, alternatively, needs to link to the code of another <code>.cpp</code> file that includes such an explicit instantiation definition.</br></p>\n<p>This can be confusing and is probably not a very good idea when you expect many different users to instantiate the template for many different types. But it can be sensible if the number of instantiations for distinct types is small and you can anticipate them all. Of course you must make sure that there is one (or several) <code>.cpp</code> file(s) that include explicit instantiation <em>definitions</em> for all the instantiations required, and that its corresponding object file is linked with the project at build time.</p>\n</hr></hr>", "LastEditorUserId": "777186", "LastActivityDate": "2012-12-24T12:50:35.433", "Score": "4", "CreationDate": "2012-12-24T12:23:40.427", "ParentId": "14021243", "CommentCount": "0", "OwnerUserId": "777186", "LastEditDate": "2012-12-24T12:50:35.433"}});