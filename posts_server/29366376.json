post_cb({"bq_ids": {"n4140": {"so_29366376_29366540_0": {"length": 16, "quality": 1.0, "section_id": 6109}}, "n3337": {"so_29366376_29366540_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_29366376_29366540_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "29366540": {"Id": "29366540", "PostTypeId": "2", "Body": "<p>From the standard (draft n3242) \u00a75.3.5/5:</p>\n<blockquote>\n<p id=\"so_29366376_29366540_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>If you don't include the header which defines <code>T</code> or <code>Problem</code> in this case, then you're deleting an object of incomplete type. If that type does not fulfill the requirements in that clause, then the deletion has undefined behaviour.</p>\n<blockquote>\n<p id=\"so_29366376_29366540_1\">Is that a compiler bug?</p>\n</blockquote>\n<p>No, compilers are not required to warn about undefined behaviour.</p>\n<p>You may want to require <code>T</code> of <code>Owner</code> to be complete. Something like <code>static_assert(sizeof(T) &gt; 0)</code> should fail to compile if <code>T</code> is incomplete. </p>\n<p>If you can't rely on the current standard, you can instead use <code>boost::checked_deleter</code> as your delete functor. It does the completeness check in pre c++11. If you for some reason don't want to include a boost header, then just reimplement it. This is the code which checks for completeness.</p>\n<pre><code>// intentionally complex - simplification causes regressions\ntypedef char type_must_be_complete[ sizeof(T)? 1: -1 ];\n(void) sizeof(type_must_be_complete);\ndelete x;\n</code></pre>\n<p>Note that you're effectively partially re-implementing <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> If you can use c++11, I recommend to use that instead.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2015-04-01T08:32:56.613", "Score": "4", "CreationDate": "2015-03-31T10:32:40.867", "ParentId": "29366376", "CommentCount": "5", "LastEditDate": "2015-04-01T08:32:56.613", "OwnerUserId": "2079303"}, "29366376": {"ViewCount": "218", "Body": "<p>Short: deleting a templatized pointer does not call the destructor. </p>\n<h1>include  solves the problem. Why?</h1>\n<p>I just ran into a situation that I can't explain. I try to break the more complex situation down here.</p>\n<p>File R.cpp</p>\n<pre><code>class R {\n      Owner&lt;Problem&gt; m_o;\n      void cleanUp() { m_o.clear(); }\n     }\n</code></pre>\n<p>File Owner.cpp</p>\n<pre><code>struct DeleteFunctor {\n  template&lt; class TPtr &gt; void operator()(TPtr* ptr) {  delete ptr; }\n};\n\ntemplate&lt; class T &gt;\nclass Owner { \nstd::vector&lt;T*&gt; m_objects; \n// here add and other stuff\nvoid clear() {\n  std::for_each( m_objects.begin(), m_objects.end(), DeleteFunctor() );\n  m_objects.clear();\n}\n</code></pre>\n<p>I now have a utility class that creates new Problem-objects on the heap and inserts them into m_o directly. I know that it's bad style to export references to internal types but that's not the point.</p>\n<p>If I call cleanUp() I can trace it down up to the call delete ptr in the Functor, with ptr having the correct Problem-type. But the Problem-destructor is not called!!</p>\n<p>However, including the Problem header in file R.cpp fixes the problem. The comiler does not complain. Is that a compiler bug?</p>\n<p>System:\ng++ (Ubuntu 4.8.2-19ubuntu1) 4.8.2</p>\n", "AcceptedAnswerId": "29366540", "Title": "C++: Destructor not called with embedded template", "CreationDate": "2015-03-31T10:24:55.183", "Id": "29366376", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-04-01T08:32:56.613", "Score": "3", "OwnerUserId": "4575239", "Tags": "<c++><templates><destructor>", "AnswerCount": "1"}});