post_cb({"bq_ids": {"n4140": {"so_26918903_26919328_3": {"length": 25, "quality": 0.9615384615384616, "section_id": 5809}, "so_26918903_26919328_0": {"length": 15, "quality": 0.6, "section_id": 5988}, "so_26918903_26919328_4": {"length": 14, "quality": 0.6363636363636364, "section_id": 3326}, "so_26918903_26919328_5": {"length": 15, "quality": 0.5357142857142857, "section_id": 5797}, "so_26918903_26919072_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5988}}, "n3337": {"so_26918903_26919328_3": {"length": 25, "quality": 0.9615384615384616, "section_id": 5582}, "so_26918903_26919328_0": {"length": 15, "quality": 0.6, "section_id": 5756}, "so_26918903_26919328_4": {"length": 14, "quality": 0.6363636363636364, "section_id": 3196}, "so_26918903_26919328_5": {"length": 15, "quality": 0.5357142857142857, "section_id": 5570}, "so_26918903_26919072_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 5756}}, "n4659": {"so_26918903_26919328_3": {"length": 25, "quality": 0.9615384615384616, "section_id": 7270}, "so_26918903_26919328_0": {"length": 15, "quality": 0.6, "section_id": 7488}, "so_26918903_26919328_4": {"length": 15, "quality": 0.6818181818181818, "section_id": 7270}, "so_26918903_26919328_5": {"length": 15, "quality": 0.5357142857142857, "section_id": 7256}, "so_26918903_26919072_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 7488}}}, "26919328": {"Id": "26919328", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/26919072/102937\">Christope's answer</a> is correct. This is to supplement.</p>\n<p>A function pointer <em>cannot</em> itself provide asynchronous behavior. The standards actually <em>bar</em> this. I'm far more familiar with the C standard than the C++ standard, so I'll use that. My understanding is that both should be approximately the same on this point.</p>\n<h3>What the C11 standard says about functions and function pointers</h3>\n<p>Let's start with the definition of a function call in C, given in 6.5.2.2 paragraph 3:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_0\">A postfix expression followed by parentheses () containing a possibly empty, comma- separated list of expressions is a function call. The postfix expression denotes the called function. The list of expressions specifies the arguments to the function.</p>\n</blockquote>\n<p>And modified by the constraint in paragraph 1:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_1\">The expression that denotes the called function (92) shall have type pointer to function returning void or returning a complete object type other than an array type.</p>\n</blockquote>\n<p>Importantly, the accompanying footnote 92 says:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_2\">Most often, this is the result of converting an identifier that is a function designator.</p>\n</blockquote>\n<p>So, the C11 standard basically defines a function call as something that calls a function pointer. And, for this purpose, named function identifiers are automatically converted into function pointers to the code in the identifier.  Thus, C sees no difference between functions and function pointers.</p>\n<h3>An experiment</h3>\n<p>While it's always good to refer to the standard, it's also pretty useful to just look at how solid implementations do things. Let's do a test where we write fairly simple code and then look at the underlying assembly</p>\n<p>The code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef void (*my_func_ptr)(int,int);\n\nvoid my_function(int x, int y)\n{\n  printf(\"x = %d, y = %d, x + y = %d\\n\",x,y,x+y);\n}\n\nint main()\n{\n  /* declared volatile so the compiler has to call the function through\n   * the pointer and cannot optimize it to call the function directly */\n  volatile my_func_ptr fp = my_function; \n\n  my_function(3,5);\n  fp(3,6);\n\n  return 0;\n}\n</code></pre>\n<p>I compiled the code using <code>gcc</code> on Mac OS X with default optimizations (<code>gcc -o fptr fptr.c</code>), which is actually a gcc frontend to the LLVM library. To look at the assembly, I ran the program under <code>lldb</code>, set a breakpoint at <code>main</code>, and issued the <code>disassemble -f</code> commmand, which disassembles the current function.  I use <code>settings set target.x86-disassembly-flavor intel</code> for Intel-style assembly. The default in <code>lldb</code> is AT&amp;T style, which looks a bit different.</p>\n<p>The <code>main</code> routine in assembly is this:</p>\n<pre><code>  push   rbp\n  mov    rbp, rsp\n  sub    rsp, 0x20                   ; sets up the stack frame\n  mov    edi, 0x3                    ; my_function(3,5). 1st arg: edi\n  mov    esi, 0x5                    ;                   2nd arg: esi\n  lea    rax, qword ptr [rip - 0x59] ; loads address of my_function into rax\n  mov    dword ptr [rbp - 0x4], 0x0  \n  mov    qword ptr [rbp - 0x10], rax ; saves address of my_function on stack\n  call   0x100000ed0                 ; explicit call to my_function\n  mov    eax, 0x0\n  mov    edi, 0x3                    ; fp(3,6). 1st arg: edi\n  mov    esi, 0x6                    ;          2nd arg: esi\n  mov    rcx, qword ptr [rbp - 0x10] ; rcx &lt;- address of my_function from stack\n  mov    dword ptr [rbp - 0x14], eax\n  call   rcx                         ; call address at rcx\n  mov    eax, dword ptr [rbp - 0x14]\n  add    rsp, 0x20\n  pop    rbp\n  ret    \n</code></pre>\n<p>Notice that both function calls are essentially the same. They use the same assembly. Both times the actual call is invoked with a <code>call</code> op.  The only difference is that the first time the address is hard coded and the second time, the address is stored in the <code>rcx</code> register. Also notice that there's nothing asynchronous about the code.</p>\n<h3>What C11 says about sequence points</h3>\n<p>When you start reasoning about sequence points, you actually find that, within a single thread, the standard <em>disallows</em> the kind of asynchronous behavior that you expected.  In most cases, C11 constrains the compiler to execute code that is separated by a sequence point in sequential order.  In Section 5.1.2.3 (program execution), the execution order of the program is defined as a series of sequence points. The relevant definition is essentially in paragraph 3:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_3\">Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single thread, which induces a partial order among those evaluations. Given any two evaluations A and B, if A is sequenced before B, then the execution of A shall precede the execution of B.</p>\n</blockquote>\n<p>And later in that paragraph:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_4\">The presence of a sequence point between the evaluation of expressions A and B implies that every value computation and side effect associated with A is sequenced before every value computation and side effect associated with B.</p>\n</blockquote>\n<p>Basically, this establishes that code separated by a sequence point must be executed synchronously (in order). However, the standard provides an out if the compiler can reason that two pieces of code cannot affect each other, in paragraph 4:</p>\n<blockquote>\n<p id=\"so_26918903_26919328_5\">In the abstract machine, all expressions are evaluated as specified by the semantics. An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).</p>\n</blockquote>\n<p>So, how do function pointers enter this? Appendix C clarifies what that a sequence point lies between expression statements, which are essentially statements that end with a semicolon (see 6.8.3). This includes function calls. </p>\n<h3>How this bars asynchronous execution of function pointers</h3>\n<p>Consider two sequential function calls:</p>\n<pre><code>f();\ng();\n</code></pre>\n<p>Neither takes an argument, so the reasoning is a bit simpler. The calls must be executed <em>in order</em> unless the compiler can reason that any side effect of <code>f()</code> is unused in <code>g()</code> and vice versa. The only way compilers can reason about this in a function is if the function's code is available to the compiler. In general, this is not possible for function pointers, because the pointer could point to any function that satisfies the constraints of the function pointer type.</p>\n<p>Note that in some cases the compiler can infer the correct function (if the function pointer is only assigned once and exists in local scope), but this is often not the case. Thus, the compiler must execute the functions in the order presented, and the first function must return before the second.</p>\n<h3>What about threading and coroutine libraries</h3>\n<p>The C11 standard has different rules for threading. Notice that Section 5.1.2.3 restricts itself to execution within a single thread.  Coroutine libraries that play with the stack essentially break the C11 machine model, and are bound to a particular set of implementations (ie: not necessary portable to any C environment). A coroutine library essentially has to supply its own set of sequential-ordering guarantees.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-14T06:34:33.120", "Score": "7", "CreationDate": "2014-11-13T22:05:38.300", "ParentId": "26918903", "CommentCount": "4", "OwnerUserId": "1430833", "LastEditDate": "2017-05-23T12:15:38.490"}, "26918903": {"ViewCount": "257", "Body": "<p>Assuming that I want to implement functions with an asynchronous behaviour or I just want to use function pointers anyway, does invoking a function pointer is something that is granted to result in an invocation of the associated function immediately followed by the next instruction ?</p>\n<p>Example</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\nint triple(int a) { return a * 3; }\nvoid foo() { std::cout &lt;&lt; \"executing foo()\" &lt;&lt; '\\n'; }\nusing fptrT = int (*)(int);\nint main()\n{\n    fptrT p = triple;\n    p(3);\n    foo();\n}\n</code></pre>\n<p>What both standards say about what happens when the expression <code>p(3)</code> get evaluated and when <code>foo()</code> will be executed ?</p>\n", "AcceptedAnswerId": "26919328", "Title": "Do function pointers return immediately in both C and C++?", "CreationDate": "2014-11-13T21:37:16.230", "Id": "26918903", "CommentCount": "18", "PostTypeId": "1", "LastActivityDate": "2014-11-14T06:34:33.120", "Score": "0", "OwnerUserId": "2485710", "Tags": "<c++><c><pointers><asynchronous><function-pointers>", "AnswerCount": "2"}, "26919072": {"Id": "26919072", "PostTypeId": "2", "Body": "<p>A function pointer is just another way to call a function, using a stored address instead of a fixed predetermined function name:  </p>\n<blockquote>\n<p id=\"so_26918903_26919072_0\">C++11, sect. 5.2.2.1:  A function call is a postfix expression followed \n  by parentheses containing (...) the arguments to the function. For an\n  ordinary function call, the postfix expression shall be either an\n  lvalue that refers to a function, or it shall have pointer to function type.</p>\n</blockquote>\n<p>For C, the wording is a little different (C11, sect. 6.5.2.2), but the principles are the same (except for pointer to member functions, which don't exist in C).</p>\n<p>Function pointers can be used for callback mecanisms, or to implement design patterns such as the <a href=\"http://en.wikipedia.org/wiki/Strategy_pattern\" rel=\"nofollow noreferrer\">strategy pattern</a> to customize dynamically a generic algorithm.  In C++ there are now more powerfull alternatives such as lambda functions or <a href=\"http://www.cplusplus.com/reference/functional/function/\" rel=\"nofollow noreferrer\">function</a> objects.</p>\n<p>If you look for aynchronous function call, you should have a look at <a href=\"http://www.cplusplus.com/reference/future/async/\" rel=\"nofollow noreferrer\"><code>std::async()</code></a>: </p>\n<pre><code>   std::future&lt;int&gt; ft = std::async (triple,3);   // invoque asynchronously\n   //... remaining code \n   bool myresult = ft.get();  // get result when it is needed\n</code></pre>\n<p><em>Note about your comment:  It's difficult to predict performance, as it depends on library implementation, OS and hardaware capability. But for me it proved to be rather efficient: on MSVC2013 for example, <a href=\"https://stackoverflow.com/a/26742904/3723423\">recent experiments</a> showed me that the threads created for async are reused when possible, thus reducing creation overhead to its bare minimum. By using multicore hardware async really permits to increase the overall throughput.</em> </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-13T22:43:15.943", "Score": "6", "CreationDate": "2014-11-13T21:48:45.303", "ParentId": "26918903", "CommentCount": "9", "OwnerUserId": "3723423", "LastEditDate": "2017-05-23T11:45:14.343"}});