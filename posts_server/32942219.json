post_cb({"bq_ids": {"n4140": {"so_32942219_32942869_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7223}, "so_32942219_32942595_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3318}, "so_32942219_32942595_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7223}}, "n3337": {"so_32942219_32942869_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6967}, "so_32942219_32942595_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3188}, "so_32942219_32942595_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6967}}, "n4659": {"so_32942219_32942595_1": {"length": 15, "quality": 0.6521739130434783, "section_id": 4084}}}, "32942595": {"Id": "32942595", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32942219_32942595_0\">what can I do with the pointer or reference that I can't do with the\n  other?</p>\n</blockquote>\n<pre><code>double *const piPnt = &amp;pi;\n</code></pre>\n<p>The above statement </p>\n<pre><code>marks piPnt as a read only variable in memory layout\n</code></pre>\n<p>So, <code>piPnt = &amp;xyz</code> would throw an error now.</p>\n<p>But changing the value at the address the pointer points to is still valid.</p>\n<p>That is , <code>*piPnt = 56</code> is fine.</p>\n<p>Const Pointers are useful in embedded systems that need to refer to the same memory (port mapping). It's a one time mapping and  constant pointers are helpful here.</p>\n<p>Now with regards to references:</p>\n<pre><code>double &amp;piRef = pi;\n</code></pre>\n<p>You cannot reinitialize a reference in C++. You can assign different value to the object it refers to. This is one and the same object for that reference forever. And this is what you did in your example.</p>\n<pre><code>piRef = 3.14159;\n</code></pre>\n<blockquote>\n<p id=\"so_32942219_32942595_1\">A reference cannot be changed to refer to another object after\n  initialization. Note that initialization of a reference is treated\n  very differently from assignment to it. Argument passing (5.2.2) and\n  function value return (6.6.3) are initializations.</p>\n</blockquote>\n<p>Some places where references are useful:</p>\n<ol>\n<li>Pointers cannot point to temporaries, the standard expressly forbids doing it.  References can bind to temporaries.</li>\n<li>A pointer can be NULL while a reference is assumed to always reference an object. You can still return null from a function returning a reference, the compiler would not complain about it, but that is suicidal.</li>\n</ol>\n", "LastEditorUserId": "635608", "LastActivityDate": "2015-10-05T10:36:17.140", "Score": "1", "CreationDate": "2015-10-05T06:38:06.700", "ParentId": "32942219", "CommentCount": "2", "OwnerUserId": "1163462", "LastEditDate": "2015-10-05T10:36:17.140"}, "32942869": {"Id": "32942869", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32942219_32942869_0\">what can I do with the pointer or reference that I can't do with the other?</p>\n</blockquote>\n<p>References allow you to write certain constructors and overload operators:</p>\n<pre><code>class X\n{\n    // copy constructor\n    X(const X&amp; a);\n\n    // move constructor\n    X(X&amp;&amp; a);\n\n    // copy assignment operator\n    X&amp; operator=(const X&amp; a);\n\n    // move assignment operator\n    X&amp; operator=(X&amp;&amp; a);\n}\n</code></pre>\n<p>(Indeed, operator overloading was the motivating use case for introducing references into C++.)</p>\n<p>What is often overlooked is the fact that modern C++ distinguishes between <code>X&amp;</code> (a reference to an lvalue) and <code>X&amp;&amp;</code> (a reference to an rvalue), but there is no such thing as a pointer to an rvalue.</p>\n", "LastActivityDate": "2015-10-05T06:57:21.277", "CommentCount": "0", "CreationDate": "2015-10-05T06:57:21.277", "ParentId": "32942219", "Score": "4", "OwnerUserId": "252000"}, "32942321": {"Id": "32942321", "PostTypeId": "2", "Body": "<p>From a functional point of view pointers and references are indeed the same thing... they reference an object and are not a copy of that object.</p>\n<p>The only real difference in addition to not being able to rebind a reference is that a pointer can be <code>NULL</code> (i.e. it can point to nothing) while a reference is assumed to always reference an object.</p>\n<p>You technically can actually end up with a reference that is referencing no object (e.g. passing <code>*p</code> to a function expecting a reference where <code>p</code> is the null pointer) but this is \"undefined behavior\".</p>\n<p>In other words pointers are more \"flexible\" than references and this allows the compiler to ignore</p>\n<ul>\n<li>That a reference can change the object it's referencing</li>\n<li>That a reference can have no object</li>\n</ul>\n<p>And this can in some cases produce faster code.</p>\n<p>The \"price\" to pay for the added flexibility of rebinding and having <code>NULL</code>s is that the syntax is (somewhat gratuitously) more annoying.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2015-10-05T06:22:30.947", "Score": "5", "CreationDate": "2015-10-05T06:16:47.367", "ParentId": "32942219", "CommentCount": "8", "OwnerUserId": "320726", "LastEditDate": "2015-10-05T06:22:30.947"}, "32942219": {"ViewCount": "526", "Body": "<p>I am currently learning C++ from C++ Primer, and it explains how a reference is an alias to another variable name. It also explains how a pointer points to another variable. It states that the difference between a pointer and a reference is that pointers can be reassigned and references can't. </p>\n<p>In the following code example, what can I do with the pointer or reference that I can't do with the other?</p>\n<pre><code>double pi = 3.14;\ndouble &amp;piRef = pi;\ndouble *const piPnt = &amp;pi;\n\n//both of these examples are valid and do the same thing\npiRef = 3.14159;\n*piPnt = 3.14159;\n\n//however, if I attempt to reassign what the pointer points to, it is illegal.\n//this is the same as with a reference, as a reference can't be reassigned either\ndouble tau = 6.28;\npiPnt = &amp;tau;\n</code></pre>\n<p>I am aware of the internal differences of each (such as that a pointer is an object, a reference isn't). I am interested in how those differences matter to the programmer beyond a slightly different syntax. As such, this is not a duplicate of <a href=\"https://stackoverflow.com/questions/2336230/difference-between-const-pointer-and-reference\">this</a> question in which the accepted answer only talks about internal differences.</p>\n", "AcceptedAnswerId": "32942321", "Title": "What is the functional difference between a const pointer (not a pointer to const) and a reference?", "CreationDate": "2015-10-05T06:08:52.700", "Id": "32942219", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:48.897", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-05T10:36:17.140", "Score": "9", "OwnerUserId": "2985951", "Tags": "<c++><pointers><reference><language-lawyer>", "AnswerCount": "3"}});