post_cb({"23372350": {"ParentId": "23371952", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The <code>case</code> statement did not (in C++03) and still does not (in C++11) introduce a scope.</p>\n<p>The standard says in <code>[stmt.switch]</code> (6.4.2/6):</p>\n<blockquote>\n<p id=\"so_23371952_23372350_0\">case and default labels in themselves do not alter the flow of\n  control, which continues unimpeded across such labels.</p>\n</blockquote>\n<p>Thus it is allowed to \"fall through\" <code>case</code> statements like this:</p>\n<pre><code>int x, a = 1;\nswitch(a) {\ncase 1:\n    x = 5;\n    // no break here!\ncase 10:\n    x *= 4; // x is now 20.\n}\n</code></pre>\n<p>If you would introduce a varible declaration for example below the first <code>case</code> statement, it could be skipped when a jump to the second <code>case</code> statement would happen.</p>\n<p>You can however declare a local variable right at the start of the <code>switch</code> block:</p>\n<pre><code>switch (i) \n{\n    int j;\ncase 0: j = 0; break; \ncase 1: j = 0; break; \ncase 2: j = 0; break; \n}\n</code></pre>\n<p>A <code>switch</code> is really more a jump table than a series of <code>if</code>/<code>else if</code> statements.</p>\n", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-04-29T20:50:39.637", "Id": "23372350", "Score": "4", "CreationDate": "2014-04-29T18:20:41.060", "LastActivityDate": "2014-04-29T20:50:39.637"}, "23372431": {"ParentId": "23371952", "CommentCount": "0", "Body": "<p>C++03 certainly allows you to define variables within the body of a switch statement. That body is not at all different from any other compound statement, the rules for jumping to a label apply the same way: you can only jump into scope of </p>\n<ul>\n<li>scalar types declared without initializers</li>\n<li>class types with trivial default constructors and trivial destructors declared without initializers</li>\n<li>arrays of the above</li>\n</ul>\n<p>these rules didn't change in C++11.</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n\n    switch(n)\n    {\n               int a;      // okay, scalar with no initializer\n       case 1: int b = 10; // okay, no more labels, no way jump into scope\n               a = b = 3*n;\n               break;\n    }\n</code></pre>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "23372431", "Score": "1", "CreationDate": "2014-04-29T18:24:22.613", "LastActivityDate": "2014-04-29T18:24:22.613"}, "23371952": {"CommentCount": "3", "ViewCount": "2321", "PostTypeId": "1", "LastEditorUserId": "2061081", "CreationDate": "2014-04-29T17:58:23.557", "LastActivityDate": "2014-04-30T09:08:04.163", "Title": "C++11: Declare variable within switch statement", "LastEditDate": "2014-04-30T09:08:04.163", "Id": "23371952", "Score": "2", "Body": "<p>I know that C++03 doesn't allow to define variables within switch block without using \ncurly braces.</p>\n<pre><code>const int i = ...\nswitch (i) { case 0: int j = 0; break; } // 1. error here\nswitch (i) { case 0: { int j = 0; } break; } // 2. ok\n</code></pre>\n<p>What is regarding new C++11 standard?\nDoes it allow first form?\nCan I also write something like this:</p>\n<pre><code>switch (i) \n{ \n  case 0: int j = 0; break; \n  case 1: int j = 0; break; \n  case 2: int j = 0; break; \n} \n</code></pre>\n", "Tags": "<c++><variables><c++11><switch-statement><definition>", "OwnerUserId": "2061081", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23371952_23372350_0": {"section_id": 3894, "quality": 1.0, "length": 12}}, "n3337": {"so_23371952_23372350_0": {"section_id": 3754, "quality": 1.0, "length": 12}}, "n4659": {"so_23371952_23372350_0": {"section_id": 4780, "quality": 1.0, "length": 12}}}, "23372130": {"ParentId": "23371952", "CommentCount": "1", "Body": "<p>You can not write this because of scope problem. Your code will lead to a redefinition of the variable <code>j</code></p>\n<p>In your code :</p>\n<pre><code>const int i = ...\nswitch (i) { case 0: int j = 0; break; } // the error should be linked to default statement that is not there\nswitch (i) { case 0: { int j = 0; } break; } // here  you define a local scope in which you can define `j` ; j will be destroyed after the closing bracket.\n</code></pre>\n<p>Even in c++11, trying to do this :</p>\n<pre><code>switch (i) \n{ \n  case 0: int j = 0; break; \n  case 1: int j = 0; break; \n  case 2: int j = 0; break; \n} \n</code></pre>\n<p>lead to the same error than if you want to write :</p>\n<pre><code>for ( ; ; ) {\n      int i = 0 ;\n      int i = 0 ;\n      int i = 0 ;\n}\n</code></pre>\n<p>That will lead to a redefinition error</p>\n", "OwnerUserId": "3457685", "PostTypeId": "2", "Id": "23372130", "Score": "0", "CreationDate": "2014-04-29T18:08:38.783", "LastActivityDate": "2014-04-29T18:08:38.783"}});