post_cb({"20981408": {"ParentId": "20980192", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>The reason it can't be found in the C++ standard is because it's actually prohibited in a delta from the C standard.</p>\n<p>In C.1.4 we have the following: <code>Change: Types must be declared in declarations, not in expressions In C, a sizeof expression or cast expression may create a new type.</code> which shows the prohibition in question.</p>\n<p>This is explicitly called out in 7.1.6/3:</p>\n<blockquote>\n<p id=\"so_20980192_20981408_0\">At least one type-specifier that is not a cv-qualifier is required in\n  a declaration unless it declares a constructor, destructor or\n  conversion function.92 A type-specifier-seq shall not define a class\n  or enumeration unless it appears in the type-id of an\n  alias-declaration (7.1.3) that is not the declaration of a\n  template-declaration.</p>\n</blockquote>\n<p>where the part of particular interest is that <code>A type-specifier-seq shall not define a class or enumeration unless...</code></p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2014-01-07T21:18:54.430", "Id": "20981408", "Score": "8", "CreationDate": "2014-01-07T20:38:48.997", "LastActivityDate": "2014-01-07T21:18:54.430"}, "20980192": {"CommentCount": "6", "AcceptedAnswerId": "20981408", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2014-01-07T19:34:28.557", "LastActivityDate": "2014-01-07T21:35:51.533", "LastEditDate": "2014-01-07T19:48:54.257", "ViewCount": "437", "FavoriteCount": "1", "Title": "C++11 standard ref for allowed type definitions in type specifier uses?", "Id": "20980192", "Score": "10", "Body": "<p>In C++11 a <em>type specifier</em> includes <em>class specifiers</em> and <em>enum specifiers</em>. (aka class definitions and enumeration definitions)</p>\n<p>According to the grammar/syntax - type specifiers can appear in several places in the language, but not in all those places are class specifiers and enum specifiers allowed.</p>\n<p>For example:</p>\n<pre><code>struct C{} c;\n// ok: types may be defined in the specifiers of a simple declaration\n\nvoid f(struct S{});\n// error: types may not be defined in parameter types\n\nconstexpr auto i = sizeof(enum E{});\n// error: types may not be defined in \u2018sizeof\u2019 expressions\n</code></pre>\n<p>Where in the standard does it partition these uses of type specifiers into those where types may and may not be defined?  For example, where is the rule that says types may not be defined in a sizeof expression?</p>\n", "Tags": "<c++><c++11><language-lawyer><specifier><type-declaration>", "OwnerUserId": "1131467", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20980192_20981414_0": {"section_id": 3245, "quality": 0.9090909090909091, "length": 30}, "so_20980192_20981414_3": {"section_id": 5428, "quality": 0.8181818181818182, "length": 9}, "so_20980192_20981414_2": {"section_id": 55, "quality": 0.8, "length": 4}, "so_20980192_20981414_1": {"section_id": 6685, "quality": 0.8, "length": 4}, "so_20980192_20981408_0": {"section_id": 5428, "quality": 0.6190476190476191, "length": 13}}, "n3337": {"so_20980192_20981414_0": {"section_id": 3118, "quality": 0.8787878787878788, "length": 29}, "so_20980192_20981414_3": {"section_id": 5223, "quality": 0.8181818181818182, "length": 9}, "so_20980192_20981414_1": {"section_id": 6440, "quality": 0.8, "length": 4}, "so_20980192_20981408_0": {"section_id": 5223, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_20980192_20981414_2": {"section_id": 57, "quality": 0.8, "length": 4}, "so_20980192_20981414_1": {"section_id": 8160, "quality": 0.8, "length": 4}, "so_20980192_20981414_3": {"section_id": 49, "quality": 0.5454545454545454, "length": 6}}}, "20981414": {"ParentId": "20980192", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>From N3797:</p>\n<blockquote>\n<p id=\"so_20980192_20981414_0\">8.3.5/9 Types shall not be defined in return or parameter types. The type of a parameter or the return type for a function definition shall\n  not be an incomplete class type (possibly cv-qualified) unless the\n  function is deleted (\n  8.4.3 ) or the definition is nested within the member-specification for that class (including definitions in nested classes defined within\n  the class).</p>\n</blockquote>\n<p>This blocks defining new types in a function declaration.</p>\n<p>The next two are other corner cases not mentioned by the OP:</p>\n<blockquote>\n<p id=\"so_20980192_20981414_1\">11.3/2 A class shall not be defined in a friend declaration. </p>\n<p id=\"so_20980192_20981414_2\">14.1/2 Types shall not be defined in a template-parameter declaration. </p>\n</blockquote>\n<p>Finally, this clause blocks it in <code>sizeof</code> and elsewhere:</p>\n<blockquote>\n<p id=\"so_20980192_20981414_3\">7.1.6/3 A type-specifier-seq shall not define a class or enumeration unless it appears in the type-id of an\n  alias-declaration (7.1.3) that is not the declaration of a template-declaration</p>\n</blockquote>\n<p>Note that C does not have that restriction (C.1.4)</p>\n<p>In addition, in a previous version of the C++ standard, we had:</p>\n<blockquote>\n<p id=\"so_20980192_20981414_4\">5.3.3p5 Types shall not be defined in a sizeof expression</p>\n</blockquote>\n<p>which I cannot find in the most recent version standard proposals, and it is redundant under N3797 as <code>sizeof</code>s route to define a type in the grammar is via <code>type-specifier-seq</code>, and blocked by 7.1.6/3:</p>\n<p><code>sizeof(type-id)</code> -&gt; <code>type-id</code> -&gt; <em><code>type-specifer-seq</code></em> -&gt; <code>type-specifier</code> -&gt; <code>class-specifier</code></p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-01-07T21:35:51.533", "Id": "20981414", "Score": "3", "CreationDate": "2014-01-07T20:39:09.240", "LastActivityDate": "2014-01-07T21:35:51.533"}});