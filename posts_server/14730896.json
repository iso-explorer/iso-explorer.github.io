post_cb({"14730896": {"CommentCount": "2", "AcceptedAnswerId": "14732625", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-02-06T13:59:32.140", "LastActivityDate": "2013-02-06T15:56:31.817", "LastEditDate": "2017-05-23T12:16:57.687", "ViewCount": "285", "FavoriteCount": "1", "Title": "Where does the C++ standard describe the casting of pointers to primitives?", "Id": "14730896", "Score": "9", "Body": "<p>In the excellent blog post <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow noreferrer\">What Every Programmer Should Know About Undefined Behavior</a>, the section \"Violating Type Rules\" says:</p>\n<blockquote>\n<p id=\"so_14730896_14730896_0\">It is undefined behavior to cast an int* to a float* and dereference it (accessing the \"int\" as if it were a \"float\"). C requires that these sorts of type conversions happen through memcpy: using pointer casts is not correct and undefined behavior results. The rules for this are quite nuanced and I don't want to go into the details here (there is an exception for char*, vectors have special properties, unions change things, etc).</p>\n</blockquote>\n<p>I'd like to understand the rules in their full nuancedness.  Where are they in the C++11 spec?  Or failing that, the C spec (C90, C99, C11)?</p>\n<p>In the C++11 spec linked from <a href=\"https://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents\">this Stack Overflow question</a>, N3485, I'm looking in 5.2.10 \"Reinterpret cast\" but don't see language for an exception for char* or unions. So that's probably not the right place.  So where is the right place?</p>\n", "Tags": "<c++><casting><language-lawyer>", "OwnerUserId": "3917", "AnswerCount": "3"}, "14732625": {"ParentId": "14730896", "CommentCount": "3", "Body": "<p>The rule you're looking for is in \u00a73.10/10 (in C++11): </p>\n<blockquote>\n<p id=\"so_14730896_14732625_0\">If a program attempts to access the stored value of an object\n  through a glvalue of other than one of the following types the\n  behavior is unde\ufb01ned:\n  \u2014 the dynamic type of the object,</p>\n<p id=\"so_14730896_14732625_1\">\u2014 a cv-quali\ufb01ed version of the dynamic type of the object,</p>\n<p id=\"so_14730896_14732625_2\">\u2014 a type similar (as de\ufb01ned in 4.4) to the dynamic type of the object,</p>\n<p id=\"so_14730896_14732625_3\">\u2014 a type that is the signed or unsigned type corresponding to the dynamic type of the object,\n  \u2014 a type that is the signed or unsigned type corresponding to a cv-quali\ufb01ed version of the dynamic type\n  of the object,</p>\n<p id=\"so_14730896_14732625_4\">\u2014 an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic\n  data members (including, recursively, an element or non-static data member of a subaggregate\n  or contained union),</p>\n<p id=\"so_14730896_14732625_5\">\u2014 a type that is a (possibly cv-quali\ufb01ed) base class type of the dynamic type of the object,</p>\n<p id=\"so_14730896_14732625_6\">\u2014 a char or unsignedchar type.</p>\n</blockquote>\n<p>There are different types (or motivations) for undefined\nbehavior.</p>\n<p>In the case of casting an <code>int*</code> to <code>float*</code> and then\ndereferencing it, it is clear that the standard cannot define\nit, since what might happen will depend on the architecture, and\nthe value of the <code>int</code>.  On the other hand, the quoted paragraph\nis completely wrong\u2014using <code>memcpy</code> to do the conversion is\nalso undefined behavior, for largely the same reasons.</p>\n<p>One of the motivations for undefined behavior is to\nallow implementations to define it, in a manner that makes sense\nfor the target architecture, <em>if</em> such exists.  This is such\na case.  A compiler which intentionally causes it to fail is\ndefective.  Of course, if we suppose 32 bit 2's complement\n<code>int</code>, and 32 bit IEEE <code>float</code>, we may expect certain values of\nthe <code>int</code> to correspond to trapping NaN, which will cause the program\nto fail.  This is part of the reason the behavior is\nundefined; to allow such things to happen.  But if we are\nfamiliar with the low level details of the hardware,\nit <em>should</em> work as expected, <em>provided</em> the compiler can see\nthe cast.\nIf it doesn't, this is a QoI problem with the compiler, and such\na compiler should be avoided for such types of work.</p>\n<p>As hinted at above, this particular case, and in fact, in all\ncases which involve type punning (writing to one member of\na union, and reading from another, for example), do pose\na problem, to which the standard has yet to find adequate\nwording.  The problem occurs because normally, the compiler is\nallowed to assume that pointers to different types (except\ncharacter types) do not alias; that an <code>int*</code> can never point to\nthe same object as a <code>float*</code>.  And proving that two pointers\ncannot alias is important for optimization.  A compiler that\nbreaks code where the pointer cast or the union is clearly visible is\njust broken, even if the standard says it is undefined behavior.\nA compiler that breaks code where all it sees are two pointers\nto unrelated types is understandable, even in cases where the\nstandard says the behavior is well defined.</p>\n<p>Using <code>memcpy</code> avoids this problem by using two different\nobjects, which don't alias.  It still encounters undefined\nbehavior because putting the bit pattern of an <code>int</code> into\na <code>float</code>, then accessing the float, doesn't have any defined\nbehavior.  (Or vice-versa; I know of at least one machine where\ncopying the bits of a <code>float</code> into an <code>int</code> may result in an\nillegal <code>int</code> value.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "14732625", "Score": "4", "CreationDate": "2013-02-06T15:27:55.487", "LastActivityDate": "2013-02-06T15:27:55.487"}, "14732445": {"ParentId": "14730896", "CommentCount": "2", "Body": "<p><code>reinterpret_cast</code> on pointers is defined in terms of <code>static_cast</code> on <code>void</code> pointers</p>\n<p><strong>5.2.10 Reinterpret cast [expr.reinterpret.cast]&gt;</strong> </p>\n<blockquote>\n<p id=\"so_14730896_14732445_0\">7 An object pointer can be explicitly converted to an object pointer\n  of a di\ufb00erent type. 70 When a prvalue v of type \u201cpointer to T1\u201d is\n  converted to the type \u201cpointer to cv T2\u201d, the result is <code>static_cast&lt;cv\n  T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both T1 and T2 are standard-layout\n  types (3.9) and the alignment requirements of T2 are no stricter than\n  those of T1, or if either type is void. Converting a prvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value. The result of any other such pointer\n  conversion is unspeci\ufb01ed.</p>\n</blockquote>\n<p><strong>5.2.9 Static cast [expr.static.cast]</strong></p>\n<blockquote>\n<p id=\"so_14730896_14732445_1\">13 A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a\n  prvalue of type \u201cpointer to cv2 T,\u201d where T is an object type and cv2\n  is the same cv-quali\ufb01cation as, or greater cv-quali\ufb01cation than, cv1.\n  The null pointer value is converted to the null pointer value of the\n  destination type. A value of type pointer to object converted to\n  \u201cpointer to cv void\u201d and back, possibly with di\ufb00erent cv-quali\ufb01cation,\n  shall have its original value.</p>\n</blockquote>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "14732445", "Score": "0", "CreationDate": "2013-02-06T15:18:39.200", "LastActivityDate": "2013-02-06T15:18:39.200"}, "bq_ids": {"n4140": {"so_14730896_14732445_1": {"section_id": 6039, "quality": 0.8043478260869565, "length": 37}, "so_14730896_14732625_3": {"section_id": 7239, "quality": 0.9444444444444444, "length": 17}, "so_14730896_14732625_1": {"section_id": 416, "quality": 0.8, "length": 4}, "so_14730896_14732445_0": {"section_id": 6046, "quality": 0.639344262295082, "length": 39}, "so_14730896_14732625_5": {"section_id": 7239, "quality": 0.8888888888888888, "length": 8}, "so_14730896_14732625_0": {"section_id": 7239, "quality": 0.9411764705882353, "length": 16}, "so_14730896_14732625_4": {"section_id": 7239, "quality": 1.0, "length": 22}, "so_14730896_14732625_2": {"section_id": 416, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_14730896_14732445_1": {"section_id": 5807, "quality": 0.8043478260869565, "length": 37}, "so_14730896_14732625_4": {"section_id": 6983, "quality": 1.0, "length": 22}, "so_14730896_14732625_0": {"section_id": 6983, "quality": 0.9411764705882353, "length": 16}, "so_14730896_14732625_1": {"section_id": 407, "quality": 0.8, "length": 4}, "so_14730896_14732445_0": {"section_id": 5814, "quality": 0.9180327868852459, "length": 56}, "so_14730896_14732625_5": {"section_id": 6983, "quality": 0.8888888888888888, "length": 8}, "so_14730896_14732625_3": {"section_id": 6983, "quality": 0.9444444444444444, "length": 17}, "so_14730896_14732625_2": {"section_id": 407, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_14730896_14732445_1": {"section_id": 7548, "quality": 0.5652173913043478, "length": 26}, "so_14730896_14732625_0": {"section_id": 8748, "quality": 0.9411764705882353, "length": 16}, "so_14730896_14732625_1": {"section_id": 434, "quality": 0.8, "length": 4}, "so_14730896_14732445_0": {"section_id": 7545, "quality": 0.6229508196721312, "length": 38}, "so_14730896_14732625_4": {"section_id": 8748, "quality": 1.0, "length": 22}, "so_14730896_14732625_3": {"section_id": 8748, "quality": 0.9444444444444444, "length": 17}, "so_14730896_14732625_5": {"section_id": 8748, "quality": 0.8888888888888888, "length": 8}, "so_14730896_14732625_2": {"section_id": 434, "quality": 0.8333333333333334, "length": 5}}}, "14731016": {"ParentId": "14730896", "CommentCount": "1", "Body": "<p>The C++ standard says that if a certain behavior is not explicitly described to be defined, then it is implicitly undefined. Since the standard does not define the behavior of casting an <code>int*</code> to <code>float*</code>, then it is implicitly undefined.</p>\n", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "14731016", "Score": "1", "CreationDate": "2013-02-06T14:05:56.920", "LastActivityDate": "2013-02-06T14:05:56.920"}});