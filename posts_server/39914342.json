post_cb({"39914727": {"ParentId": "39914342", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is UB.</p>\n<blockquote>\n<p id=\"so_39914342_39914727_0\">n4140 \u00a71.9 [intro.execution]/15</p>\n<p id=\"so_39914342_39914727_1\">Except where noted, evaluations of\n  operands of individual operators and of subexpressions of individual\n  expressions are unsequenced. [...] If a side effect on a scalar object\n  is unsequenced relative to [...] value computation using the value of\n  the same scalar object [...] the behavior is undefined.</p>\n</blockquote>\n<p>Multiplicative operators don't have sequencing explicitly noted.</p>\n", "OwnerUserId": "2456565", "LastEditorUserId": "2456565", "LastEditDate": "2016-10-07T10:28:24.903", "Id": "39914727", "Score": "4", "CreationDate": "2016-10-07T10:09:35.293", "LastActivityDate": "2016-10-07T10:28:24.903"}, "39915006": {"ParentId": "39914342", "CommentCount": "0", "Body": "<p>This is UB</p>\n<blockquote>\n<p id=\"so_39914342_39915006_0\">Order of evaluation of the operands of almost all C++ operators (including the order of evaluation of function arguments in a function-call expression and the order of evaluation of the subexpressions within any expression) is unspecified. The compiler can evaluate operands in any order, and may choose another order when the same expression is evaluated again.</p>\n<p id=\"so_39914342_39915006_1\">There are exceptions to this rule which are noted below.</p>\n<p id=\"so_39914342_39915006_2\">Except where noted below, there is no concept of left-to-right or\n  right-to-left evaluation in C++. This is not to be confused with\n  left-to-right and right-to-left associativity of operators: the\n  expression f1() + f2() + f3() is parsed as (f1() + f2()) + f3() due to\n  left-to-right associativity of operator+, but the function call to f3\n  may be evaluated first, last, or between f1() or f2() at run time.</p>\n</blockquote>\n", "OwnerUserId": "3207189", "PostTypeId": "2", "Id": "39915006", "Score": "2", "CreationDate": "2016-10-07T10:22:53.310", "LastActivityDate": "2016-10-07T10:22:53.310"}, "39914342": {"CommentCount": "1", "ViewCount": "85", "CreationDate": "2016-10-07T09:50:37.240", "LastActivityDate": "2016-10-07T10:28:24.903", "Title": "Calling function with side effects inside expression", "AcceptedAnswerId": "39914727", "PostTypeId": "1", "Id": "39914342", "Score": "6", "Body": "<p>I thought I understand how sequence points work in C++, but <a href=\"http://quiz.geeksforgeeks.org/c-plus-plus/references/\">this GeeksQuiz question</a> puzzled me:</p>\n<pre><code>int f(int &amp;x, int c) {\n    c = c - 1;\n    if (c == 0) return 1;\n    x = x + 1;\n    return f(x, c) * x;\n}\n\nint main() {\n    int p = 5;\n    cout &lt;&lt; f(p, p) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>The \u201ccorrect\u201d answer to this question says it prints 6561. Indeed, in VS2013 it does. But isn't it UB anyway because there is no guarantee which will be evaluated first: <code>f(x, c)</code> or <code>x</code>. We get 6561 if <code>f(x, c)</code> is evaluated first: the whole thing turns into five recursive calls: the first four (c = <code>5, 4, 3, 2</code>) continue on, the last one (c = 1) terminates and returns 1, which amounts to <code>9 ** 4</code> in the end.</p>\n<p>However, if <code>x</code> was evaluated first, then we'd get <code>6 * 7 * 8 * 9 * 1</code> instead. The funny thing is, in VS2013 even replacing <code>f(x, c) * x</code> with <code>x * f(x, c)</code> doesn't change the result. Not that it means anything.</p>\n<p>According to the standard, is this UB or not? If not, why?</p>\n", "Tags": "<c++><sequence-points>", "OwnerUserId": "540312", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39914342_39914727_1": {"section_id": 5811, "quality": 1.0, "length": 26}}, "n3337": {"so_39914342_39914727_1": {"section_id": 5584, "quality": 1.0, "length": 26}}, "n4659": {"so_39914342_39914727_1": {"section_id": 7272, "quality": 0.8461538461538461, "length": 22}}}});