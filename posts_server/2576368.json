post_cb({"2576395": {"ParentId": "2576368", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>There is nothing preventing you from doing that:</p>\n<pre><code>struct A {\n    virtual ~A() {}\n    virtual void f() = 0;\n    virtual void g() { f(); }\n};\n\nstruct B : A {\n    void f() { std::cout &lt;&lt; \"B::f()\" &lt;&lt; std::endl; }\n};\n\n// ...\nA* a = new B;\na-&gt;g(); // prints \"B::f()\"\n</code></pre>\n<hr>\n<p>As for calling a pure virtual function from the destructor (or constructor): <strong>Don't!</strong> It invokes undefined behaviour.</p>\n<p><em>\u00a710.4/6</em>:</p>\n<blockquote>\n<p id=\"so_2576368_2576395_0\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n</hr>", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2010-04-05T00:43:42.323", "Id": "2576395", "Score": "4", "CreationDate": "2010-04-05T00:17:40.563", "LastActivityDate": "2010-04-05T00:43:42.323"}, "bq_ids": {"n4140": {"so_2576368_2576395_0": {"section_id": 7023, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_2576368_2576395_0": {"section_id": 6769, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_2576368_2576395_0": {"section_id": 8520, "quality": 0.9615384615384616, "length": 25}}}, "2576368": {"CommentCount": "3", "AcceptedAnswerId": "2576395", "PostTypeId": "1", "LastEditorUserId": "54680", "CreationDate": "2010-04-05T00:11:22.803", "LastActivityDate": "2010-04-06T22:00:41.603", "LastEditDate": "2010-04-06T22:00:41.603", "ViewCount": "245", "FavoriteCount": "0", "Title": "Use abstract within base expecting it to be a derived class?", "Id": "2576368", "Score": "2", "Body": "<p>take this simple code:</p>\n<pre><code>class A{ \n  public: \n  virtual void foo() = 0; \n  void x(){ foo(); }\n};\nclass B: public A{ foo(){ ... } };\n\nmain(){\n  B b;\n  b.x();\n}\n</code></pre>\n<p>What I want is to build an abstract class that will have a function that will call a function expecting it to be implemented in the derived class</p>\n<p>The question is that I can't seem to make that work, the compiler says it can't compile because it can't find the reference(or something like that) to the foo() to be executed in x() of the base class. Can this work? Can anyone give me an example of this?</p>\n<p>EDIT: It seems that it just doesn't work when the \"foo();\" is inside the destructor of class A(the base one)...<br>\nIt just got me confused. =[</br></p>\n<p>EDIT2: how interesting this got. I just created a     callfoo(){ foo(); } and now it compiles ok, but if I try to call the pure abstract function directly from within the destructor of Base class A, it gives me errors... weird. Anyone has any idea of this? O_o</p>\n<p>any help on this please?</p>\n<p>Thanks,<br>\nJonathan</br></p>\n<p><strong>Update</strong></p>\n<p>It worked outside the destructor. Now I just got confused.</p>\n<p>Try putting the \"foo()\" inside the destructor of the A(base) class, at least for me is not compiling...</p>\n<p>any help plz?</p>\n", "Tags": "<c++><class><inheritance><abstract>", "OwnerUserId": "127735", "AnswerCount": "4"}, "2576384": {"ParentId": "2576368", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It should work with a few syntactic modifications.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A { \n  public: \n  virtual ~A() {}\n  virtual void foo() = 0; \n  void x() { foo(); }\n};\n\nclass B: public A{ \n    void foo(){ std::cerr &lt;&lt; \"bingo!\" &lt;&lt; std::endl; } \n};\n\nint main(){\n  B b;\n  b.x();\n  return 0;\n}\n\n$ g++ -Wall -Weffc++ derived.cc \n$ ./a.out \nbingo!\n</code></pre>\n<p>This technique is perfectly legal.</p>\n", "OwnerUserId": "295076", "LastEditorUserId": "295076", "LastEditDate": "2010-04-05T00:21:10.410", "Id": "2576384", "Score": "1", "CreationDate": "2010-04-05T00:15:16.663", "LastActivityDate": "2010-04-05T00:21:10.410"}, "2576407": {"ParentId": "2576368", "CommentCount": "0", "Body": "<p>Well in theory that works just as fine, you should though add a return type to foo() on class B</p>\n", "OwnerUserId": "192940", "PostTypeId": "2", "Id": "2576407", "Score": "0", "CreationDate": "2010-04-05T00:21:46.743", "LastActivityDate": "2010-04-05T00:21:46.743"}, "2576401": {"ParentId": "2576368", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Seems that what you are looking for is an implementation of the <a href=\"http://en.wikipedia.org/wiki/Template_method_pattern\" rel=\"nofollow noreferrer\">Template Method pattern.</a></p>\n<p>You need to use pointers, in order to take advantage of polymorphism (thus avoiding the message ... x is not a member of B)</p>\n<pre><code>#include &lt;iostream&gt;                                                             \n\nclass A{  \n  public: \n    virtual void foo() = 0;  \n    virtual void x(){ foo(); }\n};  \nclass B: public A{  \n        void foo(){ std::cout&lt;&lt;\"this is b\"&lt;&lt;std::endl; } \n};\n\nint main(){\n A* b= new B();\n b-&gt;x();\n\n return 0;\n }   \n</code></pre>\n", "OwnerUserId": "63309", "LastEditorUserId": "63309", "LastEditDate": "2010-04-05T00:27:12.983", "Id": "2576401", "Score": "1", "CreationDate": "2010-04-05T00:19:29.417", "LastActivityDate": "2010-04-05T00:27:12.983"}});