post_cb({"15090354": {"ParentId": "15090216", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This does output <code>true</code> with G++ 4.7:</p>\n<pre><code>class I1{};\nclass I2: public I1{};\nclass I3: public I2{};\n\nint main(int argc, const char* argv[])\n{\n  std::cout &lt;&lt; std::boolalpha\n            &lt;&lt; std::is_base_of&lt;I1, I3&gt;::value\n            &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p><sup>Note that <code>std::is_base_of&lt;I1, I3&gt;::value</code> is equivalent to instantiating an object of type <code>std::is_base_of&lt;I1, I3&gt;</code> and converting it to <code>bool</code>.</sup></p>\n<p>I believe it is accurate in doing so. <code>std::is_base_of&lt;Base, Derived&gt;</code> is defined as having the condition (\u00a720.9.6):</p>\n<blockquote>\n<p id=\"so_15090216_15090354_0\"><code>Base</code> is a base class of <code>Derived</code> (10) without regard to cv-qualifiers or <code>Base</code> and <code>Derived</code> are not unions and name the same class type without regard to cv-qualifiers</p>\n</blockquote>\n<p><em>Base class</em> is defined as so (\u00a710):</p>\n<blockquote>\n<p id=\"so_15090216_15090354_1\">A class <code>B</code> is a base class of a class <code>D</code> if it is a direct base class of <code>D</code> or a direct base class of one of <code>D</code>'s base classes.</p>\n</blockquote>\n<p>So yes, <code>I1</code> is a base class of <code>I3</code> and <code>std::is_base_of&lt;I1, I3&gt;::value</code> should be <code>true</code>.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-02-26T13:35:33.803", "Id": "15090354", "Score": "4", "CreationDate": "2013-02-26T13:30:25.107", "LastActivityDate": "2013-02-26T13:35:33.803"}, "15090216": {"CommentCount": "7", "ViewCount": "1013", "PostTypeId": "1", "LastEditorUserId": "529332", "CreationDate": "2013-02-26T13:22:55.707", "LastActivityDate": "2013-02-27T08:22:29.313", "Title": "std::is_base_of() depth", "LastEditDate": "2013-02-26T14:16:11.067", "Id": "15090216", "Score": "1", "Body": "<p>I have a such hierarchy:</p>\n<pre><code>namespace MyService{\nclass IBase\n{\npublic:\n    virtual ~IBase(){}\n\nprotected:\n    IPointer *_somePointer;\n\n};\n}\n</code></pre>\n<p><br/></p>\n<pre><code>class IInterface: public MyService::IBase\n{\npublic:\n    virtual ~IInterface(){}\n\n    virtual std::string get() const = 0;\n};\n</code></pre>\n<p><br/> </p>\n<pre><code>class ConcreteClass: public IInterface\n{\npublic: \n    std::string get() const\n    {\n        bool isNull = (_somePointer == NULL);\n        return \"Hello\";\n    }\n};\n</code></pre>\n<p><br/></p>\n<pre><code>bool isBase = std::is_base_of&lt;IBase, ConcreteClass&gt;::value;\n</code></pre>\n<p>I need to check is I3 is derived from I1. But std::is_base_of() doesn't work well for me - it return false.\nThe goal is to add to any class IBase and check any class is there IBase in it hierarchy</p>\n<p>Found the problem, but not solution. My code is:</p>\n<pre><code>template&lt;class Base, class Derived&gt;\n    bool IsDerivedFromBase()\n    {\n        if( std::tr1::is_fundamental&lt;Base&gt;::value )\n            throw MyService::Exceptions::ETypeTraitsInvalidArgument( \"Base class can't be POD\" );\n        if( std::tr1::is_fundamental&lt;Derived&gt;::value )\n            throw MyService::Exceptions::ETypeTraitsInvalidArgument( \"Derived class can't be POD\" );\n\n        bool a = std::tr1::is_base_of&lt;Base, Derived&gt;::value;\n        return a;\n    }\n</code></pre>\n<p>and i have a such</p>\n<pre><code>bool a = std::is_base_of&lt;MyService::IBase, SomeInterface&gt;::value; // true\na = IsDerivedFromBase&lt;MyService::IBase, SomeInterface&gt;(); // false\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "529332", "AnswerCount": "3"}, "15090371": {"ParentId": "15090216", "CommentCount": "0", "Body": "<p><a href=\"http://stacked-crooked.com/view?id=7d91ece11402bbade951cf49f211cbda\" rel=\"nofollow\">No, the code works:</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nclass A {};\nclass B : public A {};\nclass C : public B {};\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"a2b: \" &lt;&lt; std::is_base_of&lt;A, B&gt;() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b2a: \" &lt;&lt; std::is_base_of&lt;B, A&gt;() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"c2b: \" &lt;&lt; std::is_base_of&lt;C, B&gt;() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"a2c: \" &lt;&lt; std::is_base_of&lt;A, C&gt;() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>yields:</p>\n<pre><code>a2b: true\nb2a: false\nc2b: false\na2c: true\n</code></pre>\n<p>The above works on GCC 4.6 and 4.7. If you are using something else you need to specify that.</p>\n<p>Your error must be elsewhere.</p>\n", "OwnerUserId": "1968", "PostTypeId": "2", "Id": "15090371", "Score": "2", "CreationDate": "2013-02-26T13:31:06.743", "LastActivityDate": "2013-02-26T13:31:06.743"}, "bq_ids": {"n4140": {"so_15090216_15090354_1": {"section_id": 6975, "quality": 1.0, "length": 13}, "so_15090216_15090354_0": {"section_id": 4716, "quality": 1.0, "length": 15}}, "n3337": {"so_15090216_15090354_1": {"section_id": 6721, "quality": 1.0, "length": 13}, "so_15090216_15090354_0": {"section_id": 4523, "quality": 1.0, "length": 15}}, "n4659": {"so_15090216_15090354_1": {"section_id": 8474, "quality": 1.0, "length": 13}, "so_15090216_15090354_0": {"section_id": 6114, "quality": 1.0, "length": 15}}}, "15107217": {"ParentId": "15090216", "CommentCount": "3", "Body": "<p>I find the problem.\nI had a few .cpp files with unit tests, in which i defined locally classes with the same name.\nDidn't find in a standard tis yet, but reproducing code is something like:</p>\n<pre><code>/// 1.cpp\nclass IInterface{};\nclass Interface: public IInterface{};\n\n/// class 2.cpp\nclass IInterface: public MyService:IBase{};\nclass Interface: public IInterface{};\n\n/// facility.h\nnamespace a{ namespace b{\n    template&lt;class T, class B&gt;\n    bool IsBaseOf(){\n        return std::is_base_of&lt;T, B&gt;();\n    }\n}\n}\n}\n\n/// ...main\na::b::IsBaseOf&lt;MyService::IBase, Interface&gt;();\n</code></pre>\n<p>It should/can fail. But if i make classes names unique it alright.</p>\n", "OwnerUserId": "529332", "PostTypeId": "2", "Id": "15107217", "Score": "0", "CreationDate": "2013-02-27T08:22:29.313", "LastActivityDate": "2013-02-27T08:22:29.313"}});