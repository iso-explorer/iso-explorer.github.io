post_cb({"2836985": {"ParentId": "2836939", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>This declares an explicit default constructor:</p>\n<pre><code>struct A {\n  explicit A(int a1 = 0);\n};\n\nA a = 0; /* not allowed */\nA b; /* allowed */\nA c(0); /* allowed */\n</code></pre>\n<p>In case there is no parameter, like in the following example, the <code>explicit</code> is redundant. </p>\n<pre><code>struct A {\n  /* explicit is redundant. */\n  explicit A();\n};\n</code></pre>\n<p>In some C++0x draft, i believe it was n3035, it made a difference in the following way:</p>\n<pre><code>A a = {}; /* error! */\nA b{}; /* alright */\n\nvoid function(A a);\nvoid f() { function({}); /* error! */ }\n</code></pre>\n<p>But in the FCD, they <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#990\" rel=\"noreferrer\">changed this</a> (though, i suspect that they didn't have this particular reason in mind) in that all three cases <em>value-initialize</em> the respective object. Value-initialization doesn't do the overload-resolution dance and thus won't fail on explicit constructors. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-05-14T19:29:36.390", "Id": "2836985", "Score": "21", "CreationDate": "2010-05-14T19:24:15.807", "LastActivityDate": "2010-05-14T19:29:36.390"}, "2836939": {"CommentCount": "1", "AcceptedAnswerId": "2836985", "CreationDate": "2010-05-14T19:16:10.420", "LastActivityDate": "2010-05-14T19:29:36.390", "PostTypeId": "1", "ViewCount": "9126", "FavoriteCount": "3", "Title": "Purpose of Explicit Default Constructors", "Id": "2836939", "Score": "27", "Body": "<p>I recently noticed a class in C++0x that calls for an explicit default constructor.  However, I'm failing to come up with a scenario in which a default constructor can be called implicitly.  It seems like a rather pointless specifier.  I thought maybe it would disallow <code>Class c;</code> in favor of <code>Class c = Class();</code> but that does not appear to be the case.</p>\n<p>Some relevant quotes from the C++0x FCD, since it is easier for me to navigate [similar text exists in C++03, if not in the same places]</p>\n<blockquote>\n<p id=\"so_2836939_2836939_0\">12.3.1.3 [class.conv.ctor]</p>\n<p id=\"so_2836939_2836939_1\">A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or value initialization (8.5).</p>\n</blockquote>\n<p>It goes on to provide an example of an explicit default constructor, but it simply mimics the example I provided above.</p>\n<blockquote>\n<p id=\"so_2836939_2836939_2\">8.5.6 [decl.init]</p>\n<p id=\"so_2836939_2836939_3\">To default-initialize an object of type T means:</p>\n<p id=\"so_2836939_2836939_4\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p>\n<p id=\"so_2836939_2836939_5\">8.5.7 [decl.init]</p>\n<p id=\"so_2836939_2836939_6\">To value-initialize an object of type T means:</p>\n<p id=\"so_2836939_2836939_7\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p>\n</blockquote>\n<p>In both cases, the standard calls for the default constructor to be called.  But that is what would happen if the default constructor were non-explicit.  For completeness sake:</p>\n<blockquote>\n<p id=\"so_2836939_2836939_8\">8.5.11 [decl.init]</p>\n<p id=\"so_2836939_2836939_9\">If no initializer is specified for an object, the object is default-initialized;</p>\n</blockquote>\n<p>From what I can tell, this just leaves conversion from no data.  Which doesn't make sense.  The best I can come up with would be the following:</p>\n<pre><code>void function(Class c);\nint main() {\n  function(); //implicitly convert from no parameter to a single parameter\n}\n</code></pre>\n<p>But obviously that isn't the way C++ handles default arguments.  What else is there that would make <code>explicit Class();</code> behave differently from <code>Class();</code>?</p>\n<p>The specific example that generated this question was <code>std::function</code> [20.8.14.2 func.wrap.func].  It requires several converting constructors, none of which are marked explicit, but the default constructor is.</p>\n", "Tags": "<c++><explicit><default-constructor>", "OwnerUserId": "293791", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_2836939_2836939_6": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_2836939_2836939_7": {"section_id": 3286, "quality": 0.7058823529411765, "length": 12}, "so_2836939_2836939_9": {"section_id": 3291, "quality": 1.0, "length": 5}, "so_2836939_2836939_3": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_2836939_2836939_4": {"section_id": 3286, "quality": 0.9230769230769231, "length": 12}, "so_2836939_2836939_1": {"section_id": 389, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_2836939_2836939_6": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_2836939_2836939_7": {"section_id": 3157, "quality": 0.9411764705882353, "length": 16}, "so_2836939_2836939_9": {"section_id": 3161, "quality": 1.0, "length": 5}, "so_2836939_2836939_3": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_2836939_2836939_4": {"section_id": 3156, "quality": 1.0, "length": 13}, "so_2836939_2836939_1": {"section_id": 380, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_2836939_2836939_7": {"section_id": 4049, "quality": 0.6470588235294118, "length": 11}, "so_2836939_2836939_9": {"section_id": 4053, "quality": 1.0, "length": 5}, "so_2836939_2836939_4": {"section_id": 4049, "quality": 0.6923076923076923, "length": 9}, "so_2836939_2836939_1": {"section_id": 406, "quality": 0.8333333333333334, "length": 10}}}});