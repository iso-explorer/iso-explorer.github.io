post_cb({"35356210": {"CommentCount": "1", "ViewCount": "396", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-02-12T06:29:24.097", "LastActivityDate": "2016-02-12T10:39:32.433", "Title": "Any reason to declare constexpr for a function that returns void?", "LastEditDate": "2017-05-23T11:50:35.730", "Id": "35356210", "Score": "3", "Body": "<p>Here is what I read: <a href=\"https://stackoverflow.com/questions/28575700/using-alias-for-static-member-functions\">using alias for static member functions?</a></p>\n<p>In the answer I see a suggestion to use <code>constexpr</code>. What is the reason to use <code>constexpr</code> for <code>void</code> functions.</p>\n<p><strong>Please demonstrate a simple use case. I am new to <code>constexpr</code> so in complex examples I will not understand the gist.</strong></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "163394", "AnswerCount": "3"}, "35357497": {"ParentId": "35356210", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Rahul's answer cites the standard paragraph which allow <code>void</code> <code>constexpr</code> functions, but it doesn't give a use-case. One use-case that comes to my mind would be to have a <code>constexpr</code> class, and as usual factor out behavior common to method in helper methods. The standard explicitly mentions function doing checks, e.g. assertions. I don't have a concrete example at hand, but I can imagine something like</p>\n<pre><code>class A\n{\npublic:\n    constexpr X doSomething(Y arg1) {\n        checkInvariant();\n        constraintOnYArgument(arg1);\n        // ...\n        checkInvariant();        \n    }\n\n    constexpr X doSomethingElse(Y arg1) {\n        checkInvariant();\n        constraintOnYArgument(arg1);\n        // ...\n        checkInvariant();        \n    }\n\nprivate:\n    constexpr void constraintOnYArguments(Y arg) {\n    }\n\n    constexpr void checkInvariant() {\n        // some checks\n        if (!some condition) {\n            throw std::logic_error(\"Oh no!\");\n        }\n    }\n};\n</code></pre>\n", "OwnerUserId": "2169853", "LastEditorUserId": "2169853", "LastEditDate": "2016-02-12T10:39:32.433", "Id": "35357497", "Score": "3", "CreationDate": "2016-02-12T08:00:40.213", "LastActivityDate": "2016-02-12T10:39:32.433"}, "35356268": {"ParentId": "35356210", "CommentCount": "1", "Body": "<p>As per the C++ 14 standard, void is a literal type</p>\n<blockquote>\n<p id=\"so_35356210_35356268_0\">A type is a literal type if it is:</p>\n<p id=\"so_35356210_35356268_1\">\u2014 void; or</p>\n<p id=\"so_35356210_35356268_2\">\u2014 a scalar type; or</p>\n<p id=\"so_35356210_35356268_3\">\u2014 a reference type; or</p>\n<p id=\"so_35356210_35356268_4\">\u2014 an array of literal type; or</p>\n<p id=\"so_35356210_35356268_5\">\u2014 a class type (Clause 9) that has all of the following properties: \u2014\n  it has a trivial destructor,</p>\n<p id=\"so_35356210_35356268_6\">\u2014 it is an aggregate type (8.5.1) or has at least one constexpr\n  constructor or constructor template that is not a copy or move\n  constructor, and</p>\n<p id=\"so_35356210_35356268_7\">\u2014 all of its non-static data members and base classes are of\n  non-volatile literal types.</p>\n</blockquote>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3444.html\" rel=\"nofollow\">here</a>:</p>\n<blockquote>\n<p id=\"so_35356210_35356268_8\">An arbitrary expression-statement is permitted, in order to allow\n  calls to functions performing checks and to allow assert-like\n  constructs. void also becomes a literal type, so that constexpr\n  functions which exist only to perform such checks may return void.</p>\n</blockquote>\n", "OwnerUserId": "1501794", "PostTypeId": "2", "Id": "35356268", "Score": "2", "CreationDate": "2016-02-12T06:35:15.333", "LastActivityDate": "2016-02-12T06:35:15.333"}, "bq_ids": {"n4140": {"so_35356210_35356268_6": {"section_id": 7208, "quality": 0.9166666666666666, "length": 11}, "so_35356210_35356268_7": {"section_id": 7208, "quality": 1.0, "length": 10}, "so_35356210_35356268_5": {"section_id": 7208, "quality": 1.0, "length": 8}}, "n3337": {"so_35356210_35356268_6": {"section_id": 6952, "quality": 0.9166666666666666, "length": 11}, "so_35356210_35356268_7": {"section_id": 6952, "quality": 0.9, "length": 9}, "so_35356210_35356268_5": {"section_id": 6952, "quality": 1.0, "length": 8}}, "n4659": {"so_35356210_35356268_6": {"section_id": 8717, "quality": 0.9166666666666666, "length": 11}, "so_35356210_35356268_7": {"section_id": 8717, "quality": 1.0, "length": 10}, "so_35356210_35356268_5": {"section_id": 8717, "quality": 1.0, "length": 8}}}, "35356263": {"ParentId": "35356210", "CommentCount": "1", "Body": "<p>As long as parameter number is an integral constant, this constexpr version will compute the result at compile-time (C++11 compilers only). And when the number is a run-time integer, this same function is perfectly capable of computing the result at run-time. So you don't need two different versions of the same program: one for compile-time and another for run-time. One implementation does it all.</p>\n", "OwnerUserId": "5917067", "PostTypeId": "2", "Id": "35356263", "Score": "0", "CreationDate": "2016-02-12T06:34:50.290", "LastActivityDate": "2016-02-12T06:34:50.290"}});