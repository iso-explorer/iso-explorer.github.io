post_cb({"23973589": {"Id": "23973589", "PostTypeId": "2", "Body": "<p>Binding a temporary directly to a reference prolongs its lifetime.</p>\n<pre><code>struct Foo {};\nFoo f() { return {}; }\n\nvoid g() {\n    f(); // temporary destroyed at end of full-expression\n    const Foo&amp; r = f(); // temporary destroyed at end of scope\n    // r can still be used here ...\n    // ...\n    // all the way down to here\n}\n</code></pre>\n<p>However, it must bind <em>directly</em> to the temporary. Consider the following example:</p>\n<pre><code>struct Bar {\n    Bar(const Foo&amp; f): r(f) {}\n    const Foo&amp; r;\n};\n\nvoid h() {\n    Bar b(f());\n    // binding occurs through parameter \"f\" rather than directly to temporary \"f()\"\n    // b.r is now a dangling reference! lifetime not extended\n}\n</code></pre>\n<p>Which would make it quite useless to wrap a temporary, even if you could.</p>\n<p><em>Note</em>: an actual reference wrapper object uses a pointer, so that it can be reassigned:</p>\n<pre><code>struct Baz {\n    Baz(const Foo&amp; f): p(std::addressof(f)) {}\n    Baz&amp; operator=(const Foo&amp; f) { p = std::addressof(f); return *this; }\n    const Foo* p;\n};\n</code></pre>\n<p>The same still applies: the temporary passed into the constructor or assignment operator will be destroyed at the end of the full-expression containing the call.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2014-05-31T18:37:13.543", "Score": "8", "CreationDate": "2014-05-31T18:26:29.057", "ParentId": "23973439", "CommentCount": "3", "LastEditDate": "2014-05-31T18:37:13.543", "OwnerUserId": "481267"}, "23973857": {"Id": "23973857", "PostTypeId": "2", "Body": "<p>Since a <code>const T&amp;&amp;</code> variable can nor be moved, neither modified, there's no reason for using it (there's no adventages or differences over a <code>const T&amp;</code>). Even more, a posterior use of that reference can be dangerous if the corresponding temporary is no longer alive (actually, <strong>it's dangerous</strong>, because it invokes undefined behaviour in such a case).</p>\n<p>The deletion of its rvalue-reference constructor is not a bad idea after all.</p>\n", "LastActivityDate": "2014-05-31T19:10:31.430", "CommentCount": "0", "CreationDate": "2014-05-31T19:10:31.430", "ParentId": "23973439", "Score": "1", "OwnerUserId": "1794803"}, "bq_ids": {"n4140": {"so_23973439_23973577_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 382}, "so_23973439_23973577_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 382}, "so_23973439_23973577_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 382}, "so_23973439_23973577_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 382}, "so_23973439_23973577_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}, "so_23973439_23973577_8": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_23973439_23973577_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_23973439_23973577_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}}, "n3337": {"so_23973439_23973577_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}, "so_23973439_23973577_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 373}, "so_23973439_23973577_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 373}, "so_23973439_23973577_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 373}, "so_23973439_23973577_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 373}, "so_23973439_23973577_8": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_23973439_23973577_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_23973439_23973577_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}}, "n4659": {"so_23973439_23973577_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 397}, "so_23973439_23973577_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 397}, "so_23973439_23973577_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 397}, "so_23973439_23973577_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 397}, "so_23973439_23973577_8": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_23973439_23973577_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}}}, "23973577": {"Id": "23973577", "PostTypeId": "2", "Body": "<p><strong>INTRODUCTION</strong></p>\n<p>Normally <code>T const&amp;</code> and <code>T&amp;&amp;</code> can extend the lifetime of a temporary directly bound to it, but this is not applicable if the <em>reference</em> is \"hiding\" behind a constructor.</p>\n<p>Since <code>std::reference_wrapper</code> is copyable (by intention), the handle to the referenced object can outlive the temporary if the <code>std::reference_wrapper</code> is used in such a way that the handle escapes the scope where the temporary is created.</p>\n<p>This will lead to a lifetime mismatch between the <em>handle</em> and the referred to  <em>object</em> (ie. the temporary).</p>\n<hr>\n<p><strong>LET'S PLAY \"<em>MAKE BELIEVE</em>\"</strong></p>\n<p>Imagine having the below, illegal, snippet; where we pretend that <code>std::reference_wrapper</code> has a constructor that would accept a temporary.</p>\n<p>Let's also pretend that the temporary passed to the constructor will have its lifetime extended (even though this isn't the case, in real life it will be \"dead\" right after <code>(1)</code>).</p>\n<hr>\n<pre><code>typedef std::reference_wrapper&lt;std::string const&gt; string_ref;\n</code></pre>\n<p><sup></sup></p>\n<pre><code>string_ref get_ref () {\n  string_ref temp_ref { std::string { \"temporary\" } }; // (1)\n\n  return temp_ref; \n}\n</code></pre>\n<p><sup></sup></p>\n<pre><code>int main () {\n  string_ref val = get_ref ();\n\n  val.get (); // the temporary has been deconstructed, this is dangling reference!\n}\n</code></pre>\n<p>Since a temporary is created with <em>automatic storage duration</em>, it will be allocated on the storage bound to the scope inside <code>get_ref</code>.</p>\n<p>When <code>get_ref</code> later returns, our temporary will be destroyed. This means that our <code>val</code> in <code>main</code> would refer to an invalid object, since the original object is no longer in existance.</p>\n<p>The above is the reason why <code>std::reference_wrapper</code>'s constructor doesn't have an overload that accepts temporaries.</p>\n<hr>\n<p><strong>ANOTHER EXAMPLE</strong></p>\n<pre><code>struct A {\n  A (std::string const&amp; r)\n    : ref (r)\n  { }\n\n  std::string const&amp; ref;\n};\n\nA foo { std::string { \"temporary \" } };\n\nfoo.ref = ...; // DANGLING REFERENCE!\n</code></pre>\n<p>The lifetime of <code>std::string { \"temporary\" }</code> will not be extended, as can be read in the standard.</p>\n<blockquote>\n<p id=\"so_23973439_23973577_0\"><code>12.2p5</code> <strong>Temporary objects</strong> <code>[class.temporary]</code></p>\n<blockquote>\n<p id=\"so_23973439_23973577_5\">The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li><p id=\"so_23973439_23973577_6\">A temporary bound to a reference member in a constructor's ctor-initializer (12.6.2) persists until the constructor exits.</p></li>\n<li><p id=\"so_23973439_23973577_7\"><strong>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</strong></p></li>\n<li><p id=\"so_23973439_23973577_8\">The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is destroyed at the end of the full-expression in the return statement.</p>\n<ul>\n<li>A temporary bound to a reference in a <em>new-initializer</em> (5.3.4) persists until the completion of the full-expression containing the <em>new-initializer</em>.</li>\n</ul></li>\n</ul>\n</blockquote>\n</blockquote>\n<p><sup> <strong>Note</strong>: it's important to note that a constructor is nothing more than a <em>\"fancy\"</em> function, called upon object construction.</sup></p>\n</hr></hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-05-31T19:46:28.897", "Score": "7", "CreationDate": "2014-05-31T18:24:38.930", "ParentId": "23973439", "CommentCount": "0", "LastEditDate": "2014-05-31T19:46:28.897", "OwnerUserId": "1090079"}, "23973648": {"Id": "23973648", "PostTypeId": "2", "Body": "<p>You should not copy a const reference as it does not necessarily keep the referenced object alive. The following code shows the problem:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X { int x; };\n\nstruct Foo {\n    const X&amp; a;\n    Foo(const X&amp; na) : a(na) {} // here na is still OK\n};\n\nint main()\n{\n    Foo foo{X{3}}; // the temporary exists only for this expression\n    // now the temporary is no longer alive and foo.a is a dangling reference\n    std::cout &lt;&lt; foo.a.x &lt;&lt; std::endl; // undefined behavior\n}\n</code></pre>\n<p>The const reference keeps the temporary <code>X{3}</code> alive for the constructor of <code>Foo</code>, but not for the object itself. You get a dangling reference.</p>\n<p>To protected you from this problem the usage of temporary objects with <code>std::reference_wrapper</code> and <code>std::ref</code> has been disabled.</p>\n", "LastActivityDate": "2014-05-31T18:38:13.220", "CommentCount": "0", "CreationDate": "2014-05-31T18:38:13.220", "ParentId": "23973439", "Score": "1", "OwnerUserId": "316448"}, "23973439": {"ViewCount": "1948", "Body": "<p>Normally, rvalues can bind to const references (<code>const SomeType&amp;</code>). It's built into the language. However, <code>std::reference_wrapper&lt;const T&gt;</code> does not accept an rvalue as its constructor argument since the corresponding overload is deliberately deleted. What is the reason for this inconsistency? <code>std::reference_wrapper</code> is \"advertised\" as the alternative to a reference variable for cases when we must pass by value but would like to preserve reference semantics.</p>\n<p>In other words, if the rvalue to <code>const &amp;</code> binding is considered safe, since it's built into the language, why did the designers of C++11 not allow rvalues to be wrapped in <code>std::reference_wrapper&lt;const T&gt;</code>?</p>\n<p>When would this come handy, you may ask. For example:</p>\n<pre><code>class MyType{};\n\nclass Foo { \npublic:\n    Foo(const MyType&amp; param){} \n};\n\nclass MultiFoo {\npublic:\n    MultiFoo(std::initializer_list&lt;std::reference_wrapper&lt;const MyType&gt;&gt; params){} \n};\n\nint main()\n{\n    Foo foo{MyType{}}; //ok\n    MultiFoo multiFoo{MyType{}, MyType{}}; //error\n}\n</code></pre>\n", "Title": "Why does std::reference_wrapper<const T> not accept a temporary?", "CreationDate": "2014-05-31T18:02:32.813", "LastActivityDate": "2014-05-31T19:46:28.897", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-31T18:24:37.177", "LastEditorUserId": "1946465", "Id": "23973439", "Score": "10", "OwnerUserId": "1946465", "Tags": "<c++><c++11><const><rvalue><reference-wrapper>", "AnswerCount": "4"}});