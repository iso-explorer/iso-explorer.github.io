post_cb({"16100958": {"Id": "16100958", "PostTypeId": "2", "Body": "<p>First of all you should avoid using this kind of arrays in c++ you should use <code>std::vector&lt;unsigned char&gt;</code> instead.</p>\n<p>about the <code>const</code> keyword. It just tells the compiler and the one who reads the code that this member/variable/parameter should not be changed.</p>\n<p>With pointers there the position of the <code>const</code> keyword is important:</p>\n<p>(<strong>EDIT</strong>: found the answer of <a href=\"https://stackoverflow.com/a/8091846/1960455\">Greyson</a> where i borrowed this part)<br>\nThe <code>const</code> keyword marks the part on its left as constant (if it is at the beginning it is for the type right after it so <code>const unsigned char</code> and <code>unsigned char const</code> are equal)</br></p>\n<p>To mark the pointer as const you do this (content is still changeable):</p>\n<pre><code>unsigned char * const aConstantPointerToAMutableContent;\n</code></pre>\n<p>To mark the content as const you will do this:</p>\n<pre><code>const unsigned char * aPointerToAConstantContentA;\nunsigned char const * aPointerToAConstantContentB;\n</code></pre>\n<p>To mark both as constant:</p>\n<pre><code>const unsigned char * const aConstantPointerToAConstantContent;\n</code></pre>\n<p>It is a hint for the compiler and for the user so that it is clear what is done or not done with the data. if the parameter is <code>const unsigned char *</code>  then the user would know that this content would not be changed if it is passed.</p>\n<p>because the <code>const</code> keyword is only a mark if something is changeable it has no effect to the size itself, so for the <code>delete</code> it should no have an effect. (see answers and comments of <a href=\"https://stackoverflow.com/a/16100415/1960455\">Lightness Races in Orbit</a> and also \"<a href=\"https://stackoverflow.com/questions/357600/is-const-cast-safe\">Is const_cast safe?</a>\" could be for interrest ).</p>\n<p>But what i don't like about your code is that the constructor is public. I could call it directly, but because the parameter is <code>const unsigned char* array</code> i would not expect that the class would change the content or that it is deleted on destruction. (i would not expect that directly creating the object would behave in a different way to using the factory.)</p>\n<p>So i would make the factory method as a <code>static</code>method of the class and make the constructor <code>protected</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-08T08:34:04.973", "Score": "1", "CreationDate": "2013-04-19T09:01:46.920", "ParentId": "16100069", "CommentCount": "1", "OwnerUserId": "1960455", "LastEditDate": "2017-05-23T12:02:31.193"}, "16100069": {"ViewCount": "1763", "Body": "<p>Roughly speaking, I have a class that holds an array of const unsigned char.\nObjects of this class are created by a special factory function that also takes care of constructing the array (on the heap). When an object is created in the factory function, it will be given the pointer to the array. The array won't be copied, the object will just use the given pointer. On destruction, it will deallocate the chunk of memory that the array occupied.</p>\n<pre><code>class Foo\n{\nprivate:\n    const unsigned char* array;\n    size_t size;\n\npublic:\n    Foo(const unsigned char* array, size_t size) : array(array), size(size) {}\n    ~Foo() {delete [] array;}\n};\n\nFoo* factoryFunction(const void* data, size_t size)\n{\n    unsigned char* array = new unsigned char[size];\n    memcpy(array, data, size);\n    return new Foo(array, size);\n}\n</code></pre>\n<p>Now I wonder whether there are any side effects, because <code>new []</code> returns <code>unsigned char *</code>, but <code>delete []</code> is called for <code>const unsigned char *</code>. I don't get any segmentation faults though.</p>\n", "Title": "delete [] after casting unsigned char* to const unsigned char*", "CreationDate": "2013-04-19T08:05:31.933", "LastActivityDate": "2017-04-08T08:34:04.973", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-04-19T09:24:12.843", "LastEditorUserId": "2298132", "Id": "16100069", "Score": "8", "OwnerUserId": "2298132", "Tags": "<c++>", "AnswerCount": "3"}, "16100167": {"Id": "16100167", "PostTypeId": "2", "Body": "<p>Shouldn't be any problem since \"const\"-ness on \"unsigned char\"(or any datatype) makes it  read-only data. </p>\n<p>Using \"[]\" in delete tells that an array has to be deleted.</p>\n<p>To understand what goes behind \"delete\" vs \"delete []\", read <a href=\"http://web.archive.org/web/20080703153358/http://taossa.com/index.php/2007/01/03/attacking-delete-and-delete-in-c\" rel=\"nofollow\">this</a>.</p>\n", "LastActivityDate": "2013-04-19T08:13:20.907", "CommentCount": "3", "CreationDate": "2013-04-19T08:13:20.907", "ParentId": "16100069", "Score": "1", "OwnerUserId": "2110189"}, "16100415": {"Id": "16100415", "PostTypeId": "2", "Body": "<p>This is fine, and non-normative text in the standard suggests the same thing:</p>\n<blockquote>\n<p id=\"so_16100069_16100415_0\"><code>[C++11: 5.3.5/2]:</code> If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined. <strong>In the second alternative (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a pointer value that resulted from a previous array <em>new-expression</em>.</strong> If not, the behavior is undefined. <em>[ Note:</em> this means that the syntax of the <em>delete-expression</em> must match the type of the object allocated by <code>new</code>, not the syntax of the <em>new-expression</em>. <em>\u2014end note ]</em> <strong><em>[ Note:</em> a pointer to a const type can be the operand of a <em>delete-expression</em>; it is not necessary to cast away the constness (5.2.11) of the pointer expression before it is used as the operand of the <em>delete-expression</em>. <em>\u2014end note ]</em></strong></p>\n</blockquote>\n<hr>\n<p>There is a possible controversy stemming from the following passages:</p>\n<blockquote>\n<p id=\"so_16100069_16100415_1\"><code>[C++11: 5.3.5/3]:</code> In the first alternative (<em>delete object</em>), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined. <strong>In the second alternative (<em>delete\n  array</em>) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</strong></p>\n</blockquote>\n<p>Though the intent of this passage appears to me <em>only</em> to be handling polymorphism, combined with the following passage it may be interpreted to mean that, <em>strictly speaking</em>, your code actually invokes undefined behaviour:</p>\n<blockquote>\n<p id=\"so_16100069_16100415_2\"><code>[C++11: 3.9.3/1]:</code> <em>[..]</em> The cv-qualified or cv-unqualified versions of a type are distinct types; <em>[..]</em></p>\n</blockquote>\n<p>However, I'm reasonably confident that this can be treated as a wording defect in the standard; the intent seems clear to me.</p>\n<hr>\n<p>Likewise, this rule could even suggest that the program will not compile:</p>\n<blockquote>\n<p id=\"so_16100069_16100415_3\"><code>[C++11: 12.5.4]:</code> <em>[..]</em> If a delete-expression begins with a unary <code>::</code> operator, the deallocation function\u2019s name is looked up in global scope. Otherwise, if the <em>delete-expression</em> is used to deallocate a class object whose static type has a virtual destructor, the deallocation function is the one selected at the point of de\ufb01nition of the dynamic type\u2019s virtual destructor (12.4). Otherwise, if the <em>delete-expression</em> is used to deallocate an object of class <code>T</code> or array thereof, <strong>the static and dynamic types of the object shall be identical</strong> and the deallocation function\u2019s name is looked up in the scope of T. If this lookup fails to \ufb01nd the name, the name is looked up in the global scope. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a placement deallocation function, the program is ill-formed.</p>\n</blockquote>\n<p>But again, this is not the intent of the rule, which addresses polymorphism in the absence of a virtual destructor, and genuine ambiguities across multiple class declarations.</p>\n<hr>\n<p>To sum up, your best bet when interpreting the wording of these rules is still on the non-normative but very clear note we started with.</p>\n</hr></hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2013-04-22T09:54:54.507", "Score": "5", "CreationDate": "2013-04-19T08:27:19.653", "ParentId": "16100069", "CommentCount": "1", "OwnerUserId": "560648", "LastEditDate": "2013-04-22T09:54:54.507"}, "bq_ids": {"n4140": {"so_16100069_16100415_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 7225}, "so_16100069_16100415_3": {"length": 49, "quality": 0.7205882352941176, "section_id": 416}, "so_16100069_16100415_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 6106}, "so_16100069_16100415_1": {"length": 41, "quality": 0.9534883720930233, "section_id": 6107}}, "n3337": {"so_16100069_16100415_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 6969}, "so_16100069_16100415_3": {"length": 63, "quality": 0.9264705882352942, "section_id": 407}, "so_16100069_16100415_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 5872}, "so_16100069_16100415_1": {"length": 41, "quality": 0.9534883720930233, "section_id": 5873}}, "n4659": {"so_16100069_16100415_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 8735}, "so_16100069_16100415_3": {"length": 49, "quality": 0.7205882352941176, "section_id": 434}, "so_16100069_16100415_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 7603}, "so_16100069_16100415_1": {"length": 41, "quality": 0.9534883720930233, "section_id": 7604}}}});