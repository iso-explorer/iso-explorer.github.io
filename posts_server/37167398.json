post_cb({"37167505": {"ParentId": "37167398", "CommentCount": "0", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/decltype\">cppreference</a></p>\n<blockquote>\n<p id=\"so_37167398_37167505_0\">If the argument is an unparenthesized id-expression or an <b>unparenthesized class member access, then decltype yields the type of the entity named by this expression.</b> If there is no such entity, or if the argument names a set of overloaded functions, the program is ill-formed.</p>\n</blockquote>\n<p>This is the case in your example, so it will return the underlying type of the member, which is a <code>std::string</code>.</p>\n<p>If you want, you can add parenthesis so that <code>decltype</code> results in a reference:</p>\n<pre><code>//'str' is a std::string&amp;\ndecltype((p-&gt;name)) str = s.name;\n</code></pre>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "37167505", "Score": "9", "CreationDate": "2016-05-11T15:46:00.740", "LastActivityDate": "2016-05-11T15:46:00.740"}, "37167398": {"CommentCount": "1", "ViewCount": "143", "CreationDate": "2016-05-11T15:41:43.903", "LastActivityDate": "2016-05-11T15:53:51.280", "Title": "C++ arrow type yields lvalue", "AcceptedAnswerId": "37167521", "PostTypeId": "1", "Id": "37167398", "Score": "7", "Body": "<p>According to the C++ Primer, C++ arrow operator yields an lvalue. Additionally <code> decltype </code> of an expression which yields an lvalue will result in a reference type. So why the following decltype does <strong>not</strong> result in a reference type.</p>\n<pre><code>struct MyStruct {\n   string name\n};\nMyStruct s;\ns.name = \"aname\";\nMyStruct* p = &amp;s;\ndecltype (p -&gt; name) str = s.name; //type of str will be string and not &amp;string although p -&gt; name yields an lvalue\n</code></pre>\n", "Tags": "<c++><decltype><lvalue><rvalue>", "OwnerUserId": "493473", "AnswerCount": "2"}, "37167521": {"ParentId": "37167398", "LastEditDate": "2016-05-11T15:53:51.280", "CommentCount": "0", "CreationDate": "2016-05-11T15:46:41.603", "OwnerUserId": "2666289", "LastEditorUserId": "2666289", "PostTypeId": "2", "Id": "37167521", "Score": "5", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow\"><code>decltype</code></a> (which is from <em>\u00a77.1.6.2/4 [dcl.type.simple]</em>):</p>\n<blockquote>\n<p id=\"so_37167398_37167521_0\">If the argument is an unparenthesized id-expression or an <strong>unparenthesized class member access</strong>, then decltype yields the type of the entity named by this expression.</p>\n</blockquote>\n<p><code>p-&gt;name</code> falls in the above case, so the type of <code>decltype(p-&gt;name)</code> is the type of <code>p-&gt;name</code> which is <code>std::string</code> not <code>std::string&amp;</code>.</p>\n<p>On the other hand, <code>decltype((p-&gt;name))</code> is <code>std::string&amp;</code> because <code>(p-&gt;name)</code> is an lvalue expression.</p>\n", "LastActivityDate": "2016-05-11T15:53:51.280"}, "bq_ids": {"n4140": {"so_37167398_37167505_0": {"section_id": 5440, "quality": 0.7391304347826086, "length": 17}, "so_37167398_37167521_0": {"section_id": 5440, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_37167398_37167505_0": {"section_id": 5235, "quality": 0.7391304347826086, "length": 17}, "so_37167398_37167521_0": {"section_id": 5235, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_37167398_37167505_0": {"section_id": 6867, "quality": 0.7391304347826086, "length": 17}, "so_37167398_37167521_0": {"section_id": 6867, "quality": 0.6428571428571429, "length": 9}}}});