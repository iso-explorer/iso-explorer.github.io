post_cb({"13982128": {"ParentId": "13981993", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>foo</code> is returning some reference to an object of type \"int\". We won't care about where that \"int\" came from and we'll just assume it exists.</p>\n<p>The first line, <code>int&amp; intRef = foo()</code>, creates <code>intRef</code> which also refers to exactly the same object of type \"int\" as is referenced by the return value of <code>foo</code>.</p>\n<p>The second line, the value of <code>intVal</code> is replaced by the value of the object referred to by the returned reference.</p>\n<hr>\n<p>In response to your comments:</p>\n<p>You seem to be getting very confused between pointers and references. References are just like aliases for an object. Doing anything to a reference will actually affect the object it refers to.</p>\n<p>There is no such thing as dereferencing a reference. You can only dereference pointers. Dereferencing is the act of using the unary <code>*</code> operator to get the object pointed at by a point. For example, if you have a <code>int* p</code>, you can do <code>*p</code> to get the object that it points at. This is <em>dereferencing</em> <code>p</code>.</p>\n<p>The only time you can do <code>*</code> on a reference is if the object it refers to is a pointer (or if it overloads <code>operator*</code>). In your case, since <code>foo</code> returns an <code>int&amp;</code>, we can't dereference it. The expression <code>*foo()</code> just won't compile. That's because the return value of <code>foo</code> has type \"int\" which is not a pointer and doesn't overload <code>operator*</code>.</p>\n<p>For all intents and purposes, you can treat the reference returned from <code>foo</code> as simply being the object it refers to. Assigning this value to <code>intVal</code> is really no different to assigning <code>x</code> to <code>intVal</code> in the following code:</p>\n<pre><code>int intVal;\nint x = 5;\nintVal = x;\n</code></pre>\n<p>As I'm sure you understand, <code>intVal</code> is given the value of <code>x</code>. This is defined simply by the standard:</p>\n<blockquote>\n<p id=\"so_13981993_13982128_0\">In simple assignment (<code>=</code>), the value of the expression replaces that of the object referred to by the left operand.</p>\n</blockquote>\n<p>No conversion needs to occur at all because both sides of the operator are the same type.</p>\n<p>This is really no different to your situation. You just have:</p>\n<pre><code>intVal = some_ref_to_int;\n</code></pre>\n<p>Where <code>some_ref_to_int</code> is the expression <code>foo()</code>. The fact that it's a reference doesn't matter. <code>intVal</code> receives the value of the object that the reference denotes.</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-12-21T00:09:10.373", "Id": "13982128", "Score": "3", "CreationDate": "2012-12-20T23:25:40.767", "LastActivityDate": "2012-12-21T00:09:10.373"}, "13982675": {"ParentId": "13981993", "CommentCount": "1", "Body": "<p>Assigning to <code>intVal</code> is an <em>assignment-expression</em> defined in 5.17 [exp.ass] in the standard. The grammar rules for an <em>assignment-expression</em> are quite complicated, depending on several other grammar rules, but basically you need a modifiable lvalue on the left hand side of the <code>=</code> operator, and a prvalue expression on the right hand side.</p>\n<p>In the case of</p>\n<pre><code>intVal = foo();\n</code></pre>\n<p>the expression on the RHS is an lvalue of type <code>int</code>, so the built-in lvalue-to-rvalue conversion takes place ... this is barely a conversion, in that the value doesn't change and neither does the type (except that for fundamental types cv-qualifiers are removed, so if the lvalue is type <code>const int</code> the prvalue will be type <code>int</code>).  [conv.lval] says </p>\n<blockquote>\n<p id=\"so_13981993_13982675_0\">A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. [...] If <code>T</code> is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise, the type of the prvalue is <code>T</code>. [...]  the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>So the prvalue has type <code>int</code> and the same value as <code>foo()</code> i.e. the same value as the variable the returned reference is bound to.</p>\n<p>The rules of assignment expressions say:</p>\n<blockquote>\n<p id=\"so_13981993_13982675_1\">In simple assignment (<code>=</code>), the value of the expression replaces that of the object referred to by the left operand.  </p>\n</blockquote>\n<p>So the value of <code>intVal</code> will be replaced by the value of the prvalue. The rules continue:</p>\n<blockquote>\n<p id=\"so_13981993_13982675_2\">If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualified type of the left operand.</p>\n</blockquote>\n<p>So because <code>int</code> is not a class type (and therefore has no overloaded <code>operator=</code> it just uses the built-in assignment operator) the assignment will convert the RHS to <code>int</code>, which is the type it already has in your case.</p>\n<p>So the value of <code>intVal</code> gets set to the value of the prvalue, which we said is the value of the glvalue expression <code>foo()</code>, i.e. the value of the variable the reference is bound to.</p>\n<p>Note that the lvalue-to-rvalue conversion is nothing to do with the RHS being a reference. The same thing happens here:</p>\n<pre><code>int val = 0;\nintVal = val;\n</code></pre>\n<p><code>val</code> is an lvalue of type <code>int</code> so it's converted to a prvalue of type <code>int</code> and the value of <code>intVal</code> is set to the value of that prvalue.</p>\n<p>The rules are expressed in terms of an expression's \"value category\" (i.e. lvalue or rvalue)  not whether it's a reference or not. Any \"dereferencing\" of a reference that's needed is done implicitly and invisibly by the compiler in order to implement the required behaviour.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "13982675", "Score": "1", "CreationDate": "2012-12-21T00:30:38.240", "LastActivityDate": "2012-12-21T00:30:38.240"}, "13982047": {"ParentId": "13981993", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>At the language level there's no such concept as \"dereferencing a reference\". A reference implements the concept of an <em>lvalue</em>. A variable and a reference are basically the same thing. The only difference between a variable and a reference is that the variable is bound to its location in storage  automatically, by the compiler, while a reference is generally bound through user action at run time.</p>\n<p>In your example, there's no conceptual difference between <code>intRef</code> and <code>intVal</code>. Both are lvalues of type <code>int</code>. And at the conceptual level both are accessed through the same mechanism. You can even think of all variables in your program as references, which were implicitly pre-bound for you by the compiler. This is basically what Bjarne Stroustrup means in TC++PL when he says (not verbatim) that one can think of references as just alternative names for existing variables.</p>\n<p>The only moment when the difference between the two is perceptible is when you create these entities and initialize them. Initialization of a reference is an act of binding it to some location in storage. Initialization of a variable is an act of copying the initial value into the existing storage.</p>\n<p>But once a reference is initialized, it acts as an ordinary variable: an act of reading/writing a reference is an act of reading/writing the storage location it is bound to. Taking the address of a reference evaluates to the address of the storage location it is bound to. And so on.</p>\n<p>It is not a secret that in many cases a reference is implemented internally as a pointer in disguise, i.e. as an invisible pointer that is implicitly dereferenced for you every time you access it. In such cases (when it is really implemented through a pointer) the dereference is done, again, every time you access it. So, it is not the assignment operator that does it, as you ask in your question. It is the very fact that you mentioned the name of that reference in your code that causes the invisible pointer to get dereferenced.</p>\n<p>However, an entity that implements \"alternative name for existing variable\" does not necessarily require storage for itself, i.e. in a compiled language it is not required to be represented by anything material, like a hidden pointer. This is why the language standard states in 8.3.2 that \"It is unspecified whether or not a reference requires storage\".</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-12-20T23:48:18.477", "Id": "13982047", "Score": "9", "CreationDate": "2012-12-20T23:15:38.310", "LastActivityDate": "2012-12-20T23:48:18.477"}, "13981993": {"CommentCount": "8", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "849048", "CreationDate": "2012-12-20T23:09:48.453", "LastActivityDate": "2012-12-21T00:30:38.240", "Title": "Deferencing a returned reference", "LastEditDate": "2012-12-20T23:42:02.437", "Id": "13981993", "Score": "4", "Body": "<p>Given:</p>\n<pre><code>int&amp; foo(); // don't care what the reference is to\nint intVal;\n</code></pre>\n<p>In the following two cases the right hand side is the same function call</p>\n<pre><code>int&amp; intRef = foo();\nintVal = foo();  // a reference is returned... a value is assigned.\n</code></pre>\n<p>In the second case how is the returned reference \"converted\" into a value?  </p>\n<p>Is it done by the assignment operator for the int?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "849048", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13981993_13982675_0": {"section_id": 8, "quality": 0.6666666666666666, "length": 16}, "so_13981993_13982675_2": {"section_id": 6175, "quality": 1.0, "length": 12}, "so_13981993_13982128_0": {"section_id": 6174, "quality": 1.0, "length": 9}, "so_13981993_13982675_1": {"section_id": 6174, "quality": 1.0, "length": 9}}, "n3337": {"so_13981993_13982675_0": {"section_id": 5, "quality": 0.6666666666666666, "length": 16}, "so_13981993_13982128_0": {"section_id": 5935, "quality": 1.0, "length": 9}, "so_13981993_13982675_2": {"section_id": 5936, "quality": 1.0, "length": 12}, "so_13981993_13982675_1": {"section_id": 5935, "quality": 1.0, "length": 9}}, "n4659": {"so_13981993_13982675_0": {"section_id": 8, "quality": 0.6666666666666666, "length": 16}, "so_13981993_13982128_0": {"section_id": 7676, "quality": 1.0, "length": 9}, "so_13981993_13982675_2": {"section_id": 7677, "quality": 1.0, "length": 12}, "so_13981993_13982675_1": {"section_id": 7676, "quality": 1.0, "length": 9}}}});