post_cb({"bq_ids": {"n4140": {"so_36816245_36816463_0": {"length": 13, "quality": 0.8125, "section_id": 1257}}, "n3337": {"so_36816245_36816463_0": {"length": 13, "quality": 0.8125, "section_id": 1255}}, "n4659": {"so_36816245_36816463_0": {"length": 13, "quality": 0.8125, "section_id": 1377}}}, "36816522": {"Id": "36816522", "PostTypeId": "2", "Body": "<p>Unless your types are <s>PODs</s> fundamental types, you will need to provide an equality function, member or not.  </p>\n<p>There are two fundamental versions of <code>std::find</code>, one that assumes an equality operator and the other uses an equality function you supply.  </p>\n<p>I recommend that you add <code>operator==</code> and <code>operator&lt;</code> to any class that will be compared for equality or ordered.  </p>\n<p>Here's an updated version of your class:  </p>\n<pre><code>class Point\n{\n  int x;  // These are private by default.\n  int y; \n  public:  \n    Point(int new_x, int new_y) : x(new_x), y(new_y)\n    { ; }\n    bool operator==(const Point&amp; p) const\n    {\n      return (x == p.x) &amp;&amp; (y == p.y);\n    }\n};\n</code></pre>\n<p>The member method <code>operator==</code> allows comparison without exposing the values to friends or the public.</p>\n<p>If you want to use a free standing comparison function, you will need to either make the values public or make the function a friend:  </p>\n<pre><code>class Point\n{\n  int x;  // These are private by default.\n  int y; \n  public:  \n    Point(int new_x, int new_y) : x(new_x), y(new_y)\n    { ; }\n    friend bool operator==(const Point&amp; a, const Point&amp; b);\n};\n\nbool operator==(const Point&amp; a, const Point&amp; b)\n{\n    return (a.x == b.x) &amp;&amp; (a.y == b.y);\n}\n</code></pre>\n<p>If you want to use the free standing function with <code>std::find</code>, the example would be:  </p>\n<pre><code>std::vector&lt;Point&gt; point_container;\n//...\nPoint p;\nstd::vector&lt;Point&gt;::const_iterator iter;\niter = std::find(point_container.begin(), point_container.end(),\n                 p,\n                 Equal_Points);\n</code></pre>\n<p>Where <code>Equal_Points</code> is a free standing function that can compare the members of two Points.</p>\n", "LastEditorUserId": "225074", "LastActivityDate": "2016-04-23T21:26:18.840", "Score": "0", "CreationDate": "2016-04-23T21:16:19.207", "ParentId": "36816245", "CommentCount": "4", "LastEditDate": "2016-04-23T21:26:18.840", "OwnerUserId": "225074"}, "36816245": {"ViewCount": "312", "Body": "<p>If I have a class</p>\n<pre><code>class Point\n{\npublic:\n  Point() {}\n  Point(int _col, int _row) : row(_row), col(_col) {}\n  int row, col;\n};\n</code></pre>\n<p>how can I use std::find() to check whether the point is already in vector? DO I have to overload operator== ?</p>\n<p>I am trying to do this</p>\n<pre><code>#include &lt;algorithm&gt;\n\nif(std::find(v.begin(), v.end(), x) != v.end()) {\n    /* v contains x */\n} else {\n    /* v does not contain x */\n}\n</code></pre>\n<p>Almost every answer I find on Stack Overflow suggest using find to check whether the object is in <code>std::vector</code> but none of them explains whether it compares the pointer of objects or the actual values of the object.</p>\n", "AcceptedAnswerId": "36816463", "Title": "std::find how does it work? operator==", "CreationDate": "2016-04-23T20:48:44.110", "Id": "36816245", "CommentCount": "4", "LastEditDate": "2016-04-23T20:52:06.347", "PostTypeId": "1", "LastEditorUserId": "1287251", "LastActivityDate": "2016-04-23T21:26:18.840", "Score": "0", "OwnerUserId": "1680256", "Tags": "<c++><vector>", "AnswerCount": "2"}, "36816463": {"Id": "36816463", "PostTypeId": "2", "Body": "<p>The C++ standard (draft N3242) says (in section 25.2.5 [alg.find]) that <code>std::find</code>:</p>\n<blockquote>\n<p id=\"so_36816245_36816463_0\"><em>Returns</em>: The first iterator <code>i</code> in the range <code>[first,last)</code> for which the following corresponding conditions hold: <code>*i == value</code>[...]. Returns <code>last</code> if no such iterator is found.</p>\n</blockquote>\n<p>Your question of whether it will search based on the value or the address of the object depends on how <code>operator==</code> is implemented. The simple answer is: <code>std::find</code> will return an iterator to the object for which <code>operator==</code> returned true.</p>\n<p>Usually, this will just be a value-based comparison (because <code>operator==</code> is usually implemented to compare the values of two objects), and so you should generally expect <code>std::find</code> to search the range for the value you've provided (not the address of the object you provided).</p>\n<p>It's possible for <code>operator==</code> to be implemented such that it <a href=\"http://ideone.com/sAUWmr\" rel=\"nofollow\">compares based on address</a>, like so:</p>\n<pre><code>bool operator==(const Point&amp; left, const Point&amp; right) {\n    return &amp;left == &amp;right;\n}\n</code></pre>\n<p>Using this <code>operator==</code> will compare addresses, and so <code>std::find</code> will search for an object that has the same address as the one you've provided. It's generally a bad idea to implement <code>operator==</code> like this, though. Most people would implement <code>operator==</code> like so:</p>\n<pre><code>bool operator==(const Point&amp; left, const Point&amp; right) {\n    return left.row == right.row &amp;&amp; left.col == right.col;\n}\n</code></pre>\n<p>which, when used with <code>std::find</code>, will <a href=\"http://ideone.com/Mt3rOO\" rel=\"nofollow\">compare <code>Point</code>s based on their values</a>.</p>\n", "LastEditorUserId": "1287251", "LastActivityDate": "2016-04-23T21:20:14.997", "Score": "2", "CreationDate": "2016-04-23T21:10:47.697", "ParentId": "36816245", "CommentCount": "1", "LastEditDate": "2016-04-23T21:20:14.997", "OwnerUserId": "1287251"}});