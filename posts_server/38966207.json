post_cb({"bq_ids": {"n4140": {"so_38966207_38966413_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 299}, "so_38966207_38966207_0": {"length": 62, "quality": 0.8985507246376812, "section_id": 299}, "so_38966207_38966413_1": {"length": 45, "quality": 0.9, "section_id": 300}}, "n3337": {"so_38966207_38966207_0": {"length": 50, "quality": 0.7246376811594203, "section_id": 290}, "so_38966207_38966413_1": {"length": 45, "quality": 0.9, "section_id": 291}}, "n4659": {"so_38966207_38966413_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 306}, "so_38966207_38966207_0": {"length": 61, "quality": 0.8840579710144928, "section_id": 306}, "so_38966207_38966413_1": {"length": 41, "quality": 0.82, "section_id": 307}}}, "38966413": {"Id": "38966413", "PostTypeId": "2", "Body": "<p>The key points are, first,</p>\n<blockquote>\n<p id=\"so_38966207_38966413_0\">The substitution proceeds in lexical order and stops when a condition\n  that causes deduction to fail is encountered</p>\n</blockquote>\n<p>And second, instantiation of <code>A&lt;int&gt;</code>'s definition triggers a hard error, not a substitution failure, because that results in instantiating an ill-formed construct <code>typename T::X</code> (with <code>T == int</code>) outside the immediate context. <a href=\"http://eel.is/c++draft/temp.deduct#8\" rel=\"nofollow\">[temp.deduct]/8</a>:</p>\n<blockquote>\n<p id=\"so_38966207_38966413_1\">Only invalid types and expressions in the immediate context of the\n  function type and its template parameter types can result in a\n  deduction failure. [ <em>Note</em>: The evaluation of the substituted types\n  and expressions can result in side effects such as the instantiation\n  of class template specializations and/or function template\n  specializations, the generation of implicitly-defined functions, etc.\n  Such side effects are not in the \u201cimmediate context\u201d and can result in\n  the program being ill-formed. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>With the templates at issue, substituting into <code>typename T::X</code> in the function type results in a deduction failure (i.e., SFINAE); substituting into <code>typename A&lt;T&gt;::X</code> results in a hard error. Since substitution proceeds in lexical order, for <code>template &lt;class T&gt; typename T::X f(typename A&lt;T&gt;::X);</code> it substitutes into <code>typename T::X</code> first, resulting in a deduction failure, and further substitution is not attempted. For <code>template &lt;class T&gt; auto g(typename A&lt;T&gt;::X) -&gt; typename T::X;</code>, on the other hand, it substitutes into <code>typename A&lt;T&gt;::X</code> first, which results in a hard error.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-08-21T10:13:38.093", "Score": "4", "CreationDate": "2016-08-16T03:54:17.977", "ParentId": "38966207", "CommentCount": "6", "OwnerUserId": "2756719", "LastEditDate": "2016-08-21T10:13:38.093"}, "38966207": {"ViewCount": "150", "Body": "<p>C++ standard 14.8.2$7 says that:</p>\n<blockquote>\n<p id=\"so_38966207_38966207_0\">The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations. The expressions include not only constant expressions such as those that appear in array bounds or as nontype template arguments but also general expressions (i.e., non-constant expressions) inside <code>sizeof</code>, <code>decltype</code>, and other contexts that allow non-constant expressions. The substitution proceeds in lexical order and stops when a condition that causes deduction to fail is encountered. [ Note: The equivalent substitution in exception specifications is done only when the exception-specification is instantiated, at which point a program is ill-formed if the substitution results in an invalid type or expression.  \u2014 end note ]</p>\n</blockquote>\n<p>The standard provides an example here:</p>\n<pre><code>template &lt;class T&gt; struct A { using X = typename T::X; };\ntemplate &lt;class T&gt; typename T::X f(typename A&lt;T&gt;::X);\ntemplate &lt;class T&gt; void f(...) { }\ntemplate &lt;class T&gt; auto g(typename A&lt;T&gt;::X) -&gt; typename T::X;\ntemplate &lt;class T&gt; void g(...) { }\n\nvoid h() {\n  f&lt;int&gt;(0); // OK, substituting return type causes deduction to fail\n  g&lt;int&gt;(0); // error, substituting parameter type instantiates A&lt;int&gt;\n}\n</code></pre>\n<p>Why calling <code>g&lt;int&gt;(0)</code> is an error here? Doesn't the trailing-return-type <code>T::X</code> cause substitution failure? What's the difference between the template function <code>f</code> and <code>g</code>?</p>\n", "AcceptedAnswerId": "38966413", "Title": "How does substitution work in template argument deduction?", "CreationDate": "2016-08-16T03:29:37.717", "Id": "38966207", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-08-21T10:13:38.093", "Score": "6", "OwnerUserId": "5845611", "Tags": "<c++><substitution>", "AnswerCount": "1"}});