post_cb({"bq_ids": {"n4140": {"so_34005908_34006150_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 5811}}, "n3337": {"so_34005908_34006150_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 5584}}, "n4659": {"so_34005908_34006150_2": {"length": 28, "quality": 0.7368421052631579, "section_id": 7273}}}, "34006150": {"Id": "34006150", "PostTypeId": "2", "Body": "<p>It seems to be safe because your are using std::set</p>\n<p>See <a href=\"http://www.cplusplus.com/reference/set/set/erase\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/reference/set/set/erase</a></p>\n<blockquote>\n<p id=\"so_34005908_34006150_0\">Iterator validity:</p>\n<p id=\"so_34005908_34006150_1\">Iterators, pointers and references referring to elements removed by the function are invalidated. All other iterators, pointers and references keep their validity.</p>\n</blockquote>\n<p>The increment will happen before foo() is called, i.e. before the element is removed. In other words the increment is done while the iterator is valid and consequently it is safe. Note - that foo() is still called with the value the iterator had before the increment.</p>\n<p>The fact that the increment happens before comes from this:</p>\n<p>Quoth the [C++ standard][1] 1.9.16 (taken from the link below):</p>\n<blockquote>\n<p id=\"so_34005908_34006150_2\">When calling a function (whether or\n  not the function is inline), every\n  value computation and side effect\n  associated with any argument\n  expression, or with the postfix\n  expression designating the called\n  function, is sequenced before\n  execution of every expression or\n  statement in the body of the called\n  function.  (Note: Value computations\n  and side effects associated with the\n  different argument expressions are\n  unsequenced.)</p>\n</blockquote>\n<p>Much more can be found here: <a href=\"https://stackoverflow.com/questions/598148/is-it-legal-to-use-the-increment-operator-in-a-c-function-call\">Is it legal to use the increment operator in a C++ function call?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-01T09:00:19.673", "Score": "0", "CreationDate": "2015-11-30T19:13:43.053", "ParentId": "34005908", "CommentCount": "2", "LastEditDate": "2017-05-23T10:27:11.053", "OwnerUserId": "4386427"}, "34005908": {"ViewCount": "35", "Body": "<p>Take a look at this code excerpt:</p>\n<pre><code>while( *it &lt;= *it_end and it != myset.end() )\n    if(foo(*it++))\n        return true;\n</code></pre>\n<p><code>it</code> and <code>it_end</code> are valid iterators of std::set (an RB tree).</p>\n<p><code>foo</code> will either:</p>\n<ul>\n<li>Remove <code>it</code>, and insert again an element with the same value of <code>*it</code>, returing false;</li>\n<li>Remove <code>it</code> and return true.</li>\n</ul>\n<p>My question:</p>\n<p>Is it safe to run this loop? </p>\n<p>Before calling <code>foo</code>, <code>it</code> will be a valid iterator to the next element of the tree, however I'm afraid that some inner magic inside std::set makes that iterator invalid, like the self-balancing algorithms of the RB tree.</p>\n", "AcceptedAnswerId": "34006150", "Title": "Iterating over a tree while removing and reinserting an element", "CreationDate": "2015-11-30T18:57:48.467", "Id": "34005908", "CommentCount": "0", "LastEditDate": "2015-11-30T19:13:40.087", "PostTypeId": "1", "LastEditorUserId": "5451820", "LastActivityDate": "2015-12-01T09:00:19.673", "Score": "1", "OwnerUserId": "5451820", "Tags": "<c++><tree><red-black-tree>", "AnswerCount": "1"}});