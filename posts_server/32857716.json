post_cb({"32858013": {"Id": "32858013", "PostTypeId": "2", "Body": "<pre><code>char str[] = \"Hello\" ;\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>char str[] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n</code></pre>\n<p>The standard guarantees that <code>sizeof(char)</code> is <code>1</code>. Hence <code>sizeof(str)</code> is <code>6</code>.</p>\n<p>The size of a pointer and an <code>int</code> are always platform dependent.</p>\n", "LastActivityDate": "2015-09-30T04:48:06.493", "CommentCount": "0", "CreationDate": "2015-09-30T04:48:06.493", "ParentId": "32857716", "Score": "1", "OwnerUserId": "434551"}, "32859374": {"Id": "32859374", "PostTypeId": "2", "Body": "<p>In C++, if we pass an array to <code>sizeof</code> we get its length; not the pointer it decays to's size. A string literal is an array of <code>n</code> characters with a null terminator.</p>\n<p>So for</p>\n<pre><code>const char str[] = \"foobar\";\n</code></pre>\n<p><code>sizeof(str) == 7</code> because in reality it will be set out in memory like this:</p>\n<pre><code>const char str[] = {'f', 'o', 'o', 'b', 'a', 'r', '\\0'};\n</code></pre>\n<p>This is a compile-time constant and is known by the compiler as soon as the array is defined.</p>\n<p>If you take a pointer to that array <code>const char *strp = str</code> then <code>sizeof(strp) == sizeof(char*)</code>.</p>\n<hr>\n<p>As for the size of <code>int</code> or <code>T*</code> (where <code>T</code> is any object type), it is implementation defined. But <code>sizeof(T*) == sizeof(U*) == sizeof(void*)</code> where <code>T</code> and <code>U</code> are any object types.</p>\n<p>The only guarantee you get is <code>sizeof(char) == 1</code>. Anything else is up to the implementation.</p>\n<p>From <code>N4140</code> (C++14 draft standard)</p>\n<blockquote>\n<p id=\"so_32857716_32859374_0\"><b>\u00a7 3.9.1 Fundamental types</b><br>\n  2 - There are five standard signed integer types : \u201csigned char\u201d, \u201cshort int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong\n  long int\u201d. In this list, each type provides at least as much storage as those preceding it in the list.\n  There may also be implementation-defined extended signed integer types. The standard and extended signed\n  integer types are collectively called signed integer types. Plain ints have the natural size suggested by the\n  architecture of the execution environment<sup>46</sup>; the other signed integer types are provided to meet special\n  needs.</br></p>\n</blockquote>\n<p>So the actual guarantee you get is:</p>\n<pre><code>sizeof(signed char) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)\n</code></pre>\n<p><sup><i><code>signed char</code> is the same size as a <code>char</code> but is a distinct type and <code>unsigned char</code> is the same size as both but another distinct type again.</i></sup></p>\n<hr>\n<p>On another note, with most systems it will be like this:</p>\n<p>64-bit operating system, <code>sizeof(T*) == 8</code><br>\n32-bit operating system, <code>sizeof(T*) == 4</code></br></p>\n<p>and on 64 and 32-bit systems <code>sizeof(int)</code> <i>usually</i> <code>== 4</code>.  </p>\n<p><sup>where <code>T</code> is any <i>object</i> type</sup></p>\n</hr></hr>", "LastEditorUserId": "2297448", "LastActivityDate": "2015-10-01T00:49:50.743", "Score": "0", "CreationDate": "2015-09-30T06:36:48.990", "ParentId": "32857716", "CommentCount": "2", "OwnerUserId": "2297448", "LastEditDate": "2015-10-01T00:49:50.743"}, "bq_ids": {"n4140": {"so_32857716_32859374_0": {"length": 57, "quality": 0.9047619047619048, "section_id": 7211}}, "n3337": {"so_32857716_32859374_0": {"length": 57, "quality": 0.9047619047619048, "section_id": 6955}}, "n4659": {"so_32857716_32859374_0": {"length": 53, "quality": 0.8412698412698413, "section_id": 8720}}}, "32858738": {"Id": "32858738", "PostTypeId": "2", "Body": "<p>Ok its my first answer on stackoverflow</p>\n<p><strong>First Question :</strong></p>\n<pre><code> char str[] = \"Hello\";\n</code></pre>\n<p>in C/C++ character arrays need a null termination('\\0') or (NULL) to identify the end of the character array, whenever we are reading character array the pointer is placed at the first index and it loops till we find null termination character.Hence its Size is 6.</p>\n<p>Note the null termination character varies from compiler to compiler(as per my knowledge) in general they use '\\0'.\nyou can also use zero(0);</p>\n<pre><code>char s[] = {'H','E','L','L','O',0};\n</code></pre>\n<p>or 'NULL'</p>\n<pre><code>char s[] = {'H','E','L','L','O',NULL};\n</code></pre>\n<p><strong>Second Question:</strong></p>\n<pre><code>char *p = str \n</code></pre>\n<p>The character pointer 'p' stores the address of the character array 'str'\nit points to the first index of the character array and stores the address.\nwhich is of 4 bytes. hence you get</p>\n<ul>\n<li><code>sizeof ( p ) = 4 // p holds the address of str</code></li>\n</ul>\n<p>where as if you had used *p (value at p) then you would have received value as 1.</p>\n<pre><code> \u2022 sizeof ( *p ) = 1 // Now *p is value at p i.e first element in\n                 character array = 'H' which is of size 1 byte\n</code></pre>\n<p><strong>Third Question</strong></p>\n<pre><code>int n = 10\n</code></pre>\n<p>This obviously is going to give you size as 4 bytes (8 bits) on 32 bit system.</p>\n<p>Again the size of also varies from compiler to compiler.</p>\n<p>talking about your last question</p>\n<blockquote>\n<p id=\"so_32857716_32858738_0\">Does this mean all ints are 4 bytes regardless if its 10 or 10000, or\n  any other number</p>\n</blockquote>\n<p>The answer is yes and no\nFor a 16 bit compiler of C/C++ the range for signed int is -32768 to 32767.</p>\n<p>For 32 bit compiler the range is -2147483648 to +2147483647</p>\n<p>any number (of type signed int) between this range is going to take 4 bytes on a 32 bit compiler like Turbo C</p>\n<blockquote>\n<p id=\"so_32857716_32858738_1\">Any other important info on this topic is also greatly appreciated and\n  accepted with open arms</p>\n</blockquote>\n<p><strong>Fun Fact</strong>\nFor above if</p>\n<pre><code>int n = 2147483648 //note the extra 1 \n</code></pre>\n<p>is still going to print or store</p>\n<pre><code>2147483647 in n\n</code></pre>\n<p>Try it out (on 32 bit compiler)</p>\n<p>Secondly\nin C++ for strings i.e</p>\n<pre><code>string str = \"Hello\";\n\u2022 str.size() = 5 // note: its not 6 \n</code></pre>\n<p>I hope I answered your Question and provided additional information.</p>\n", "LastActivityDate": "2015-09-30T05:52:27.617", "CommentCount": "3", "CreationDate": "2015-09-30T05:52:27.617", "ParentId": "32857716", "Score": "1", "OwnerUserId": "3808898"}, "32858009": {"Id": "32858009", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32857716_32858009_0\">I noticed a pattern from other problems that there is always 1 byte\n  added to these types of strings. (5 letters +1). My question is, what\n  is this \"+1\" from?</p>\n</blockquote>\n<p>That 1 byte is for null termination ie '\\0'.\nThink about it.</p>\n<p>If you use strlen(calculates at run time) instead of sizeof(calculates at compile time), strlen() starts scanning the string at first character, increments the count,moves to next character, there has to be some character at which the string has to mark it's end,right?? that is what null termination is for.</p>\n<blockquote>\n<p id=\"so_32857716_32858009_1\">From what I know all ints are of size 4 bytes correct?</p>\n<p id=\"so_32857716_32858009_2\">The C++ standard does not specify the size of integral types in bytes,\n  but it specifies minimum ranges they must adhere to.</p>\n</blockquote>\n<p>This is already explained here.\n[<a href=\"https://stackoverflow.com/questions/589575/what-does-the-c-standard-state-the-size-of-int-long-type-to-be][1]\">What does the C++ standard state the size of int, long type to be?</a> </p>\n<p>Good practice is to always use standard defines to avoid such confusions.</p>\n<p>Look into </p>\n<blockquote>\n<p id=\"so_32857716_32858009_3\">\"stdint.h \" or \"cstdint\"</p>\n</blockquote>\n<p>header files if you are on linux. Not sure about windows.</p>\n<p>int8_t, int16_t, int32_t, uint8_t, uint16_t, uint32_t</p>\n<p>these make the code more readable.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-30T06:53:12.163", "Score": "0", "CreationDate": "2015-09-30T04:47:33.840", "ParentId": "32857716", "CommentCount": "3", "OwnerUserId": "1163462", "LastEditDate": "2017-05-23T10:28:44.217"}, "32857716": {"ViewCount": "295", "Body": "<p>Additional question (1 point): \nAssume we are using 32-bit Windows operating systems\nand C/C++ programs. Please estimate the sizeof() for the follows (unit: byte)</p>\n<pre><code>\u2022 char str[] = \u201cHello\u201d ;\n\u2022 char *p = str ;\n\u2022 int n = 10;\nPlease calculate:\n\u2022 sizeof ( str ) = __________\n\u2022 sizeof ( p ) = __________\n\u2022 sizeof ( n ) = __________\n</code></pre>\n<p>Hello All,</p>\n<p>I am trying to wrap my mind around this fairly fundamental concept in C++. I will tell you what I think the correct answers are to see if I am on the right track. For the first one, sizeof(str), I believe it is 6 bytes total. I noticed a pattern from other problems that there is always 1 byte added to these types of strings. (5 letters +1). My question is, what is this \"+1\" from? As for the second one down, this is just referring to the size of a pointer,p, correct? which is always 4 bytes in size? Finally, the third one, I believe is just referring to the size of an int, n. From what I know all ints are of size 4 bytes correct? Does this mean all ints are 4 bytes regardless if its 10 or 10000, or any other number. Any other important info on this topic is also greatly appreciated and accepted with open arms! Thanks!  </p>\n", "Title": "Explanation of sizeof() with various data types in C++", "CreationDate": "2015-09-30T04:18:33.817", "LastActivityDate": "2015-10-01T00:49:50.743", "CommentCount": "2", "LastEditDate": "2015-09-30T06:17:19.843", "PostTypeId": "1", "LastEditorUserId": "2776146", "Id": "32857716", "Score": "2", "OwnerUserId": "5391367", "Tags": "<c++><sizeof><string-literals>", "AnswerCount": "4"}});