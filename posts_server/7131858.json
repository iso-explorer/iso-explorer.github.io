post_cb({"bq_ids": {"n4140": {"so_7131858_7132065_5": {"length": 28, "quality": 0.875, "section_id": 6259}, "so_7131858_7132065_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 6331}, "so_7131858_7132065_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 1887}, "so_7131858_7132065_6": {"length": 7, "quality": 0.7, "section_id": 6431}, "so_7131858_7132065_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 1886}, "so_7131858_7132065_4": {"length": 9, "quality": 0.6923076923076923, "section_id": 2511}, "so_7131858_7132065_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 6261}}, "n3337": {"so_7131858_7132065_5": {"length": 28, "quality": 0.875, "section_id": 6019}, "so_7131858_7132065_6": {"length": 7, "quality": 0.7, "section_id": 6188}, "so_7131858_7132065_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 1876}, "so_7131858_7132065_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 6021}, "so_7131858_7132065_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 1875}, "so_7131858_7132065_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 6088}}, "n4659": {"so_7131858_7132065_5": {"length": 28, "quality": 0.875, "section_id": 7763}, "so_7131858_7132065_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 7841}, "so_7131858_7132065_6": {"length": 7, "quality": 0.7, "section_id": 7943}, "so_7131858_7132065_4": {"length": 9, "quality": 0.6923076923076923, "section_id": 3239}, "so_7131858_7132065_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 7765}}}, "7132065": {"Id": "7132065", "PostTypeId": "2", "Body": "<h3>Problem</h3>\n<pre><code>std::transform(\n    s.begin(),\n    s.end(),\n    std::back_inserter(out),\n    std::toupper\n);\n</code></pre>\n<blockquote>\n<p id=\"so_7131858_7132065_0\">no matching function for call to \u2018<code>transform(__gnu_cxx::__normal_iterator&lt;char*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;char*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, std::back_insert_iterator&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, &lt;unresolved overloaded function type&gt;)</code>\u2019</p>\n</blockquote>\n<p>This is a misleading error; the interesting part is not that there's \"no matching function\" for the call, but <em>why</em> there's no matching function.</p>\n<p>The <em>why</em> is that you're passing a function reference of an \"<code>&lt;unresolved overloaded function type&gt;</code>\" as an argument, and GCC prefers to error on the call rather than on this overload resolution failure.</p>\n<hr>\n<h3>Explanation</h3>\n<p>First, you should consider how the C library is inherited in C++. <code>&lt;ctype.h&gt;</code> has a function <code>int toupper(int)</code>.</p>\n<p>C++ inherits this:</p>\n<blockquote>\n<p id=\"so_7131858_7132065_1\"><code>[n3290: 21.7/1]:</code> Tables 74, 75, 76, 77, 78, and 79 describe headers\n  <code>&lt;cctype&gt;</code>, <code>&lt;cwctype&gt;</code>, <code>&lt;cstring&gt;</code>, <code>&lt;cwchar&gt;</code>, <code>&lt;cstdlib&gt;</code>\n  (character conversions), and <code>&lt;cuchar&gt;</code>, respectively.</p>\n<p id=\"so_7131858_7132065_2\"><code>[n3290: 21.7/2]:</code> The contents of these headers shall be the same as\n  the Standard C Library headers <code>&lt;ctype.h&gt;</code>, <code>&lt;wctype.h&gt;</code>,\n  <code>&lt;string.h&gt;</code>, <code>&lt;wchar.h&gt;</code>, and <code>&lt;stdlib.h&gt;</code> and the C Unicode TR\n  header <code>&lt;uchar.h&gt;</code>, respectively [..]</p>\n<p id=\"so_7131858_7132065_3\"><code>[n3290: 17.6.1.2/6]:</code>Names that are defined as functions in C shall\n  be defined as functions in the C++ standard library.</p>\n</blockquote>\n<p>But using <code>&lt;ctype.h&gt;</code> is deprecated:</p>\n<blockquote>\n<p id=\"so_7131858_7132065_4\"><code>[n3290: C.3.1/1]:</code> For compatibility with the Standard C library, the\n  C++ standard library provides the 18 C headers (D.5), but their use is\n  deprecated in C++.</p>\n</blockquote>\n<p>And the way to access the C <code>toupper</code> is through the C++ backwards-compatibility header <code>&lt;cctype&gt;</code>. For such headers, the contents are <em>either moved or copied</em> (depending on your implementation) into the <code>std</code> namespace: </p>\n<blockquote>\n<p id=\"so_7131858_7132065_5\"><code>[n3290: 17.6.1.2/4]:</code> [..] In the C++ standard library, however, the declarations\n  (except for names which are defined as macros in C) are within\n  namespace scope (3.3.6) of the namespace std. <strong>It is unspecified\n  whether these names are first declared within the global namespace\n  scope and are then injected into namespace std by explicit\n  using-declarations</strong> (7.3.3).</p>\n</blockquote>\n<p>But the C++ library also introduces a new, locale-specific function template in header <code>&lt;locale&gt;</code>, that's <em>also</em> called <code>toupper</code> (of course, in namespace <code>std</code>):</p>\n<blockquote>\n<p id=\"so_7131858_7132065_6\"><code>[n3290: 22.2]:</code> [..] <code>template &lt;class charT&gt; charT toupper(charT c,\n  const locale&amp; loc);</code> [..]</p>\n</blockquote>\n<p>So, when you use <code>std::toupper</code>, there are <em>two</em> overloads to choose from. Since you didn't tell GCC which function you wish to use, the overload cannot be resolved and your call to <code>std::transform</code> cannot be completed.</p>\n<hr>\n<h3>Disparity</h3>\n<p>Now, the OP of that original question did not run into this problem. He likely did not have the locale version of <code>std::toupper</code> in scope, but then again you didn't <code>#include &lt;locale&gt;</code> either!</p>\n<p>However:</p>\n<blockquote>\n<p id=\"so_7131858_7132065_7\"><code>[n3290: 17.6.5.2]:</code> A C++ header may include other C++ headers.</p>\n</blockquote>\n<p>So it <em>just so happens</em> that either your <code>&lt;iostream&gt;</code> or your <code>&lt;algorithm&gt;</code>, or headers that those headers include, or headers that <em>those</em> headers include (etc), lead to the inclusion of <code>&lt;locale&gt;</code> on your implementation.</p>\n<hr>\n<h3>Solution</h3>\n<p>There are two workarounds to this.</p>\n<ol>\n<li><p>You may provide a conversion clause to coerce the function pointer into referring to the overload that you wish to use:</p>\n<pre><code>std::transform(\n   s.begin(),\n   s.end(),\n   std::back_inserter(out),\n   (int (*)(int))std::toupper  // specific overload requested\n);\n</code></pre></li>\n<li><p>You may remove the locale version from the overload set by explicitly using the global <code>toupper</code>:</p>\n<pre><code>std::transform(\n   s.begin(),\n   s.end(),\n   std::back_inserter(out),\n   ::toupper                  // global scope\n);\n</code></pre>\n<p>However, recall that whether or not this function in <code>&lt;cctype&gt;</code> is available is unspecified (<code>[17.6.1.2/4]</code>), and using <code>&lt;ctype.h&gt;</code> is deprecated (<code>[C.3.1/1]</code>).</p>\n<p>Thus, this is not the option that I would recommend.</p></li>\n</ol>\n<hr>\n<p><sup>(<strong>Note:</strong> I despise writing angle brackets as if they were part of header names \u2014 they are part of <code>#include</code> syntax, not header names \u2014 but I've done it here for consistency with the FDIS quotes; and, to be honest, it <em>is</em> clearer...)</sup></p>\n</hr></hr></hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-08-20T13:54:40.477", "Score": "37", "CreationDate": "2011-08-20T13:34:46.467", "ParentId": "7131858", "CommentCount": "11", "OwnerUserId": "560648", "LastEditDate": "2011-08-20T13:54:40.477"}, "7131881": {"Id": "7131881", "PostTypeId": "2", "Body": "<p>Just use <code>::toupper</code> instead of <code>std::toupper</code>. That is, <code>toupper</code> defined in the global namespace, instead of the one defined in <code>std</code> namespace.</p>\n<pre><code>std::transform(s.begin(), s.end(), std::back_inserter(out), ::toupper);\n</code></pre>\n<p>Its working : <a href=\"http://ideone.com/XURh7\">http://ideone.com/XURh7</a></p>\n<p>Reason why your code is not working :  there is another overloaded function <code>toupper</code> in the namespace <code>std</code> which is causing problem when resolving the name, because compiler is unable to decide which overload you're referring to, when you simply pass <code>std::toupper</code>. That is why the compiler is saying <code>unresolved overloaded function type</code> in the error message, which indicates the presence of overload(s).</p>\n<p>So to help the compiler in resolving to the correct overload, you've to cast <code>std::toupper</code> as</p>\n<pre><code>(int (*)(int))std::toupper\n</code></pre>\n<p>That is, the following would work:</p>\n<pre><code>//see the last argument, how it is casted to appropriate type\nstd::transform(s.begin(), s.end(), std::back_inserter(out),(int (*)(int))std::toupper);\n</code></pre>\n<p>Check it out yourself: <a href=\"http://ideone.com/8A6iV\">http://ideone.com/8A6iV</a></p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-08-20T16:02:56.577", "Score": "56", "CreationDate": "2011-08-20T12:58:45.770", "ParentId": "7131858", "CommentCount": "16", "OwnerUserId": "415784", "LastEditDate": "2011-08-20T16:02:56.577"}, "7131858": {"ViewCount": "28088", "Body": "<p>I tried the code from this question <a href=\"https://stackoverflow.com/questions/1489313/c-stdtransform-and-toupper-why-does-this-fail\">C++ std::transform() and toupper() ..why does this fail?</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n  std::string s=\"hello\";\n  std::string out;\n  std::transform(s.begin(), s.end(), std::back_inserter(out), std::toupper);\n  std::cout &lt;&lt; \"hello in upper case: \" &lt;&lt; out &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Theoretically it should've worked as it's one of the examples in Josuttis' book, but it doesn't compile <a href=\"http://ideone.com/aYnfv\" rel=\"nofollow noreferrer\">http://ideone.com/aYnfv</a>.</p>\n<p>Why did GCC complain: </p>\n<pre><code>no matching function for call to \u2018transform(\n    __gnu_cxx::__normal_iterator&lt;char*, std::basic_string\n        &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, \n    __gnu_cxx::__normal_iterator&lt;char*, std::basic_string\n        &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, \n    std::back_insert_iterator&lt;std::basic_string\n        &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;,\n    &lt;unresolved overloaded function type&gt;)\u2019\n</code></pre>\n<p>Am I missing something here? Is it GCC related problem?</p>\n", "AcceptedAnswerId": "7131881", "Title": "std::transform() and toupper(), no matching function", "CreationDate": "2011-08-20T12:53:55.943", "Id": "7131858", "CommentCount": "4", "FavoriteCount": "19", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:26:21.290", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-20T16:02:56.577", "Score": "44", "OwnerUserId": "789116", "Tags": "<c++><algorithm><stl>", "AnswerCount": "2"}});