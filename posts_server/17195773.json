post_cb({"17196371": {"Id": "17196371", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17195773_17196371_0\">Is it possible to explicit instantiate one or more specializations of a template function?</p>\n</blockquote>\n<p>Yes, however,\n[temp.explicit]/5:</p>\n<blockquote>\n<p id=\"so_17195773_17196371_1\">For a given set of template arguments, if an explicit instantiation of a template appears after a declaration of an explicit specialization for that template, the explicit instantiation has no effect.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_17195773_17196371_2\">Second, does it matter if the function is a class member?</p>\n</blockquote>\n<p>No, AFAIK;\n[temp.explicit]/1:</p>\n<blockquote>\n<p id=\"so_17195773_17196371_3\">A class, a function or member template specialization can be explicitly instantiated from its template. <strong>A member function, member class or static data member of a class template can be explicitly instantiated from the member definition associated with its class template</strong>. An explicit instantiation of a function template or member function of a class template shall not use the inline or constexpr specifiers.</p>\n</blockquote>\n<p>Example from [temp.explicit]/3:</p>\n<pre><code>template&lt;class T&gt; class Array { void mf(); };\ntemplate class Array&lt;char&gt;;\n\ntemplate void Array&lt;int&gt;::mf();\n\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { /\u2217 ... \u2217/ }\ntemplate void sort(Array&lt;char&gt;&amp;);    // argument is deduced here\n\nnamespace N {\ntemplate&lt;class T&gt; void f(T&amp;) { }\n}\ntemplate void N::f&lt;int&gt;(int&amp;);\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_17195773_17196371_4\">Is it legal C++11 and also is it accepted by compilers so it doesn't come with problems?</p>\n</blockquote>\n<p>Well, yes, but for libraries there's always the problem of ABI compatibility; especially if different compilers have been used for library and library user (e.g. program including that library). The C++ Standard does not specify an ABI.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-06-19T16:28:08.390", "Score": "1", "CreationDate": "2013-06-19T16:21:46.990", "ParentId": "17195773", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2013-06-19T16:28:08.390"}, "bq_ids": {"n4140": {"so_17195773_17196371_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 254}, "so_17195773_17196371_3": {"length": 40, "quality": 1.0, "section_id": 250}, "so_17195773_17196371_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 5520}}, "n3337": {"so_17195773_17196371_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 245}, "so_17195773_17196371_3": {"length": 40, "quality": 1.0, "section_id": 241}, "so_17195773_17196371_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 5306}}, "n4659": {"so_17195773_17196371_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 261}, "so_17195773_17196371_3": {"length": 40, "quality": 1.0, "section_id": 257}, "so_17195773_17196371_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6955}}}, "17195773": {"ViewCount": "270", "Body": "<p>Is it possible to explicit instantiate one or more specializations of a template function?\nSecond, does it matter if the function is a class member?\nIs it legal C++11 and also is it accepted by compilers so it doesn't come with problems?</p>\n", "AcceptedAnswerId": "17196371", "Title": "C++ template function: explicit instantiate one or more specializations", "CreationDate": "2013-06-19T15:53:12.557", "Id": "17195773", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-06-19T16:28:08.390", "Score": "0", "OwnerUserId": "1717562", "Tags": "<c++><templates>", "AnswerCount": "1"}});