post_cb({"27741654": {"ParentId": "27741423", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The paper that introduced this was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf\">n4152</a>, which has the rationale (which generally boils down to \"make ScopeGuard work\")</p>\n<p>To quote,</p>\n<blockquote>\n<p id=\"so_27741423_27741654_0\">as documented at least since 1998 in Guru of the Week #47, it means code that is transitively called from a destructor that could itself be invoked during stack unwinding cannot correctly detect whether it itself is actually being called as part of unwinding. Once you\u2019re in unwinding of any exception, to <code>uncaught_exception</code> everything looks like unwinding, even if there is more than one active exception.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_27741423_27741654_1\">this uses information already present in major implementations, where current implementations of ScopeGuard resort to nonportable code that relies on undocumented compiler features to make ScopeGuard \u201cportable in practice\u201d today. This option proposes adding a single new function to expose the information that already present in compilers, so that these uses can be truly portable</p>\n</blockquote>\n<p>PS: Here's an example of how this function can be implemented using compiler-speicific information: <a href=\"https://github.com/panaseleus/stack_unwinding/blob/master/boost/exception/uncaught_exception_count.hpp\">https://github.com/panaseleus/stack_unwinding/blob/master/boost/exception/uncaught_exception_count.hpp</a></p>\n<p>And for a simple example where it's used, look no further than boost.log's \"record pump\" (see <a href=\"https://github.com/boostorg/log/blob/master/include/boost/log/detail/format.hpp#L295\">boost/log/detail/format.hpp</a> and <a href=\"https://github.com/boostorg/log/blob/master/include/boost/log/sources/record_ostream.hpp#L278\">boost/log/sources/record_ostream.hpp</a>): it makes it possible for <code>BOOST_LOG(lg) &lt;&lt; foo();</code> to log in the destructor of the guard object it creates if <code>foo</code> doesn't throw, that is, if the number of exceptions in flight when the destructor is called is not greater than when the constructor was called.</p>\n", "OwnerUserId": "273767", "LastEditorUserId": "273767", "LastEditDate": "2015-03-08T18:10:54.127", "Id": "27741654", "Score": "18", "CreationDate": "2015-01-02T11:43:55.773", "LastActivityDate": "2015-03-08T18:10:54.127"}, "bq_ids": {"n4140": {"so_27741423_27741423_0": {"section_id": 6932, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_27741423_27741423_0": {"section_id": 6680, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_27741423_27741423_0": {"section_id": 8429, "quality": 0.6666666666666666, "length": 8}}}, "27741423": {"CommentCount": "2", "AcceptedAnswerId": "27741654", "PostTypeId": "1", "LastEditorUserId": "103167", "CreationDate": "2015-01-02T11:27:02.953", "LastActivityDate": "2016-02-19T17:25:42.523", "LastEditDate": "2015-01-31T03:51:26.610", "ViewCount": "1084", "FavoriteCount": "3", "Title": "Why will std::uncaught_exception change to std::uncaught_exceptions?", "Id": "27741423", "Score": "9", "Body": "<p>I just noticed over on</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/error/uncaught_exception</a></p>\n<p>that C++17 will replace <code>std::uncaught_exception()</code>, which returns a <code>bool</code>, with <code>std::uncaught_exceptions()</code>, which returns an <code>int</code>.</p>\n<p>The addition to the standard describing this is here:</p>\n<p><a href=\"http://isocpp.org/files/papers/n4259.pdf\" rel=\"noreferrer\">http://isocpp.org/files/papers/n4259.pdf</a></p>\n<p>It doesn't provide the rationale but it does say</p>\n<blockquote>\n<p id=\"so_27741423_27741423_0\">[Note: When uncaught_exceptions() &gt; 0, throwing an exception can\n  result in a call of std::terminate() (15.5.1). \u2013 end note]</p>\n</blockquote>\n<p>which is oddly vague.</p>\n<p>What is the reason for this change? Will multiple active exceptions be possible in C++17 or some future version of the standard?</p>\n", "Tags": "<c++><exception><c++1z>", "OwnerUserId": "1128289", "AnswerCount": "2"}, "35511190": {"ParentId": "27741423", "CommentCount": "0", "Body": "<p>std::uncaught_exception() only detects whether the stack is unwinding. In a paper by Herb Sutter, he points out that this does not reliably indicate that there is an active exception. Herb opines that this is \"almost\" useful. I have encountered a situation where this is indeed ambiguous, which is what led me to this post.</p>\n<p>std::uncaught_exceptions() is specified as returning the number of active exceptions, which is actually useful.</p>\n", "OwnerUserId": "25823", "PostTypeId": "2", "Id": "35511190", "Score": "-1", "CreationDate": "2016-02-19T17:25:42.523", "LastActivityDate": "2016-02-19T17:25:42.523"}});