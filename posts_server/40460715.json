post_cb({"40461307": {"ParentId": "40460715", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, you need to explicitly define <code>operator-&gt;</code> even though you have an implicit conversion to a pointer.</p>\n<p>The standard states in \n[over.match.oper]/2</p>\n<blockquote>\n<p id=\"so_40460715_40461307_0\">If either operand has a type that is a class or an enumeration, a user-defined operator function might be\n  declared that implements this operator or a user-defined conversion can be necessary to convert the operand\n  to a type that is appropriate for a built-in operator. In this case, overload resolution is used to determine\n  which operator function or built-in operator is to be invoked to implement the operator. [...]</p>\n</blockquote>\n<p>Overload resolution is then described in [over.match.oper]/3, the relevant part for this case being [over.match.oper]/3.3:</p>\n<blockquote>\n<p id=\"so_40460715_40461307_1\">For the <code>operator,</code>, the unary <code>operator &amp;</code>, or the <code>operator -&gt;</code>, the built-in candidates set is empty. [...]</p>\n</blockquote>\n<p>This means that no conversions that would allow a call to the build-in <code>operator-&gt;</code> (in this case for <code>Dog*</code>) are considered, and there has to be a member or non-member definition of <code>operator-&gt;</code> for your class.</p>\n<p>Regarding the explicit annotation of the template arguments: \nYou can get around that by defining a templated helper function <code>make_paxref</code> similar to <code>make_tuple</code> or <code>make_pair</code> that does the type deduction. Or you can wait for C++17 where template argument deduction will also work for constructors of templated classes :)</p>\n", "OwnerUserId": "3601321", "LastEditorUserId": "3601321", "LastEditDate": "2016-11-07T09:21:47.057", "Id": "40461307", "Score": "1", "CreationDate": "2016-11-07T09:02:58.477", "LastActivityDate": "2016-11-07T09:21:47.057"}, "40460715": {"CommentCount": "1", "ViewCount": "25", "CreationDate": "2016-11-07T08:26:31.600", "LastActivityDate": "2016-11-07T09:21:47.057", "Title": "Class that converts converts to an index and pointer and referes to a container", "PostTypeId": "1", "Id": "40460715", "Score": "0", "Body": "<p>I try to write a class that accesses an element in a container by its index. I therefore will be able to re-route the container pointed to (but that is not really important for my current problem). It will help me to get rid of complicated copy constructors.</p>\n<p>This class should behave as if it's a number (i.e. the index) and as if it's a pointer (i.e. to which it points). I therefore have conversion. I however get compiler errors:</p>\n<pre><code>In instantiation of 'class paxRef&lt;Dog&amp;, std::vector&lt;Dog&gt; &gt;': \n34:47: required from here \n13:5: error: forming pointer to reference type 'Dog&amp;'\nIn function 'int main()': \n37:7: error: base operand of '-&gt;' has non-pointer type 'paxRef&lt;Dog&amp;, std::vector&lt;Dog&gt; &gt;' \n38:7: error: base operand of '-&gt;' has non-pointer type 'paxRef&lt;Dog&amp;, std::vector&lt;Dog&gt; &gt;' \n44:43: error: base operand of '-&gt;' has non-pointer type 'paxRef&lt;Dog&amp;, std::vector&lt;Dog&gt; &gt;' \n45:43: error: base operand of '-&gt;' has non-pointer type 'paxRef&lt;Dog&amp;, std::vector&lt;Dog&gt; &gt;'\n</code></pre>\n<p>What does <code>forming pointer to reference type 'Dog&amp;'</code> mean? Do I really need to define a <code>-&gt;</code>operator if I have an implicit conversion to a pointer? Is it possible to shorten the <code>paxRef&lt;decltype(v.back()), decltype(v)&gt;</code> syntax and is it causing the above errors?</p>\n<p>This is my code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T, class C&gt;\nclass paxRef\n{\npublic:\n    paxRef(size_t index, C* container) : _index(index), _container(container) { } \n    //implicit conversion\n    operator size_t() const { return _index; }\n    operator T*() { return &amp;(_container-&gt;at(_index)); }\n    //operator -&gt;() { return T*(); } // Do I need to define the -&gt; operator if I already have a pointer-conversion operator?\nprivate:\n    size_t _index;\n    C* _container;\n};\n\n\nclass Dog\n{\npublic:\n    std::string bark() { return _sound; }\n    void setName(std::string sound) { _sound=sound; }\nprivate:\n    std::string _sound = \"Wuff\";\n};\n\n\nint main()\n{\n    std::vector&lt;Dog&gt; v(5);\n    paxRef&lt;decltype(v.back()), decltype(v)&gt; r2(2, &amp;v); // Very verbos.\n    paxRef&lt;decltype(v.back()), decltype(v)&gt; r4(4, &amp;v); // Can I drop the &lt; ... &gt; part somehow?\n\n    r2-&gt;setName(\"Bello\");\n    r4-&gt;setName(\"Fatty\");\n\n    for(size_t i{ 0 }; i&lt;v.size(); ++i)\n        std::cout&lt;&lt;\"Dog at \"&lt;&lt;i&lt;&lt;\" says \"&lt;&lt;v.at(i).bark()&lt;&lt;std::endl;\n\n    std::cout&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"ref at \"&lt;&lt;r2&lt;&lt;\" says \"&lt;&lt;r2-&gt;bark()&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"ref at \"&lt;&lt;r4&lt;&lt;\" says \"&lt;&lt;r4-&gt;bark()&lt;&lt;std::endl;\n}\n</code></pre>\n", "Tags": "<c++><vector><type-conversion>", "OwnerUserId": "3392714", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40460715_40461307_1": {"section_id": 584, "quality": 0.8888888888888888, "length": 8}, "so_40460715_40461307_0": {"section_id": 583, "quality": 1.0, "length": 33}}, "n3337": {"so_40460715_40461307_1": {"section_id": 574, "quality": 0.8888888888888888, "length": 8}, "so_40460715_40461307_0": {"section_id": 573, "quality": 1.0, "length": 33}}, "n4659": {"so_40460715_40461307_1": {"section_id": 607, "quality": 0.8888888888888888, "length": 8}, "so_40460715_40461307_0": {"section_id": 606, "quality": 1.0, "length": 33}}}});