post_cb({"43890241": {"ParentId": "43890123", "CommentCount": "1", "CreationDate": "2017-05-10T10:47:23.957", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "43890241", "Score": "24", "Body": "<p>From 3.4.1 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_43890123_43890241_0\">In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the\n  respective categories; <b>name lookup ends as soon as a declaration is found for the name</b>. If no declaration is\n  found, the program is ill-formed.</p>\n</blockquote>\n<p>In this particular case the first scope to be searched is the function local scope. Foo is not found there. Then comes the class scope. Since the name Foo is found in it, the name lookup stops there and the other Foo does not participate in overload resolution at all.</p>\n", "LastActivityDate": "2017-05-10T10:47:23.957"}, "43890296": {"CommentCount": "8", "CreationDate": "2017-05-10T10:49:14.970", "CommunityOwnedDate": "2017-05-10T11:01:40.373", "LastEditorUserId": "817643", "LastActivityDate": "2017-05-10T11:03:55.803", "ParentId": "43890123", "PostTypeId": "2", "LastEditDate": "2017-05-10T11:03:55.803", "Id": "43890296", "Score": "18", "Body": "<p>If a function in a particular namespace shares the same name as one in a global namespace, then the one in the global namespace is not found.</p>\n<p>Unfortunately the C++ standard does not allow you to bring in the global namespace into the current one with an appropriate <code>using</code> statement, although you can use <code>using ::Foo;</code> to pull in that particular function:</p>\n<pre><code>void Foo(char)\n{\n}\n\nstruct Bar\n{\n    static void Foo(double) { }\n    static void Foo() {\n        using ::Foo;\n        Foo('c'); // correct overload is found since ::Foo is pulled into scope\n        Foo(3.0);\n    }\n};\n</code></pre>\n<p>Otherwise you need to use the scope resolution operator to find the global function:</p>\n<pre><code>struct Bar\n{\n    static void Foo() { ::Foo(1); }\n};\n</code></pre>\n", "OwnerUserId": "2380830"}, "bq_ids": {"n4140": {"so_43890123_43890241_0": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_43890123_43890241_0": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_43890123_43890241_0": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}}}, "43890123": {"CommentCount": "1", "ViewCount": "1664", "PostTypeId": "1", "LastEditorUserId": "333698", "CreationDate": "2017-05-10T10:41:30.247", "LastActivityDate": "2017-05-10T21:38:10.830", "Title": "Which look up rule prevents the compiler from finding the function?", "AcceptedAnswerId": "43890241", "LastEditDate": "2017-05-10T21:38:10.830", "Id": "43890123", "Score": "18", "Body": "<pre><code>void Foo(int i)\n{\n}\nstruct Bar\n{\n    static void Foo() { Foo(1); }\n};\n</code></pre>\n<p>The above code does not compile. It cannot find <code>Foo(int)</code>. Why? I know it has to do with having the same function name, but did not get further understanding the problem.</p>\n<p>Why do I need a qualified lookup?</p>\n", "Tags": "<c++>", "OwnerUserId": "7384437", "AnswerCount": "2"}});