post_cb({"bq_ids": {"n4140": {"so_47638649_47639007_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6000}}, "n3337": {"so_47638649_47639007_0": {"length": 19, "quality": 0.7037037037037037, "section_id": 5768}}}, "47639007": {"Id": "47639007", "PostTypeId": "2", "Body": "<p>The statement</p>\n<pre><code>void();\n</code></pre>\n<p>creates a void value and then discards it.  (You can't actually do much with a void value other than discard it or return it.)</p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">standard</a>\u2020 says in 5.2.3 [expr.type.conv</p>\n<blockquote>\n<p id=\"so_47638649_47639007_0\">The expression T(), where T is a simple-type-specifier or typename-specifier for a non-array complete object\n  type or the (possibly cv-qualified) void type, creates a prvalue of the specified type, whose value is that\n  produced by value-initializing (8.5) an object of type T; no initialization is done for the void() case</p>\n</blockquote>\n<p>Note that it explictaly calls out that <code>void()</code> is legal. </p>\n<p>\u2020 My link is to N4296 which was the last public committee draft before C++14, however the various versions of the standard do not vary here.</p>\n<hr>\n<p><strong>Edit</strong></p>\n<p>Is it useful?  Explicitly like this? No.  I can't see a use for it.  It <em>is</em> however, useful in template functions which sometimes do something like:</p>\n<pre><code>template &lt;typename T&gt;\nT foo() {\n    if (prepare_for_for()) {\n        return do_foo();\n    } else {\n        return T();\n    }\n}\n</code></pre>\n<p>And this will work, even for <code>T</code> == <code>void</code>.</p>\n</hr>", "LastEditorUserId": "771073", "Score": "4", "LastActivityDate": "2017-12-04T19:51:41.953", "CreationDate": "2017-12-04T17:40:58.143", "ParentId": "47638649", "CommentCount": "2", "LastEditDate": "2017-12-04T19:51:41.953", "OwnerUserId": "771073"}, "47638649": {"ViewCount": "141", "Body": "<p>You cannot declare a <code>void</code> variable:</p>\n<pre><code>void fn() {\n    void a; // ill-formed\n}\n</code></pre>\n<p>Yet this compiles:</p>\n<pre><code>void fn() {\n    void(); // a void object?\n}\n</code></pre>\n<p>What does <code>void()</code> mean? How is it useful? Why is <code>void a;</code> ill-formed, while <code>void()</code> OK?</p>\n<pre><code>void fn() {\n    void a = void(); // ill-formed\n}\n</code></pre>\n", "Title": "How is \"void()\" useful?", "CreationDate": "2017-12-04T17:19:35.500", "Id": "47638649", "CommentCount": "18", "LastEditDate": "2017-12-04T18:03:56.247", "PostTypeId": "1", "LastEditorUserId": "3982001", "LastActivityDate": "2017-12-06T03:04:17.343", "Score": "0", "OwnerUserId": "8157187", "Tags": "<c++><void><variable-declaration>", "AnswerCount": "2"}, "47639513": {"Id": "47639513", "PostTypeId": "2", "Body": "<p>Syntactically <code>void()</code> is an explict type conversion written in <em>functional notation</em> (see 5.2.3).</p>\n<p>Note that even in \"classic\" C (C89/90) explicit conversions to <code>void</code> were already allowed. Of course, in C one has to use \"classic\" C-style cast notation and supply an argument. Any expression can be cast to <code>void</code> in C, including expressions that are already <code>void</code>. This functionality migrated unchanged to <em>cast notation</em> of explicit type conversion in C++ (it is handled by <code>static_cast</code> branch of its functionality, i.e. you can <code>static_cast</code> to <code>void</code> in C++).</p>\n<p>Taking the above into account, it is not surprising that conversion to <code>void</code> is also consistently supported by the alternative C++ cast syntax - <em>functional notation</em>. And once you understand that, it is no surprise that it was extended to support the \"argument-less\" version - <code>void()</code>.</p>\n<p>The usefulness of this in C++ will include such contexts as generic functions </p>\n<pre><code>template &lt;typename T&gt;\nT foo() {\n  ...;\n  return T(); // remains valid even when `T == void`\n}\n</code></pre>\n<p>Note that in C++ it is perfectly legal to return <code>void</code> pseudo-values from <code>void</code> functions. The ability to create such <code>void()</code> pseudo-values eliminates the need to write dedicated <code>void</code> specializations for functions like the one above.</p>\n<hr>\n<p>As a side note, <code>void()</code> stands for explicit type conversion only if the context forces it to be interpreted as an <em>expression</em>, as in your example. When context calls for a type  name (e.g. <code>int foo(void())</code> or <code>using T = void();</code>) it actually declares a nameless function that returns <code>void</code> and takes no arguments.</p>\n</hr>", "LastEditorUserId": "187690", "Score": "3", "LastActivityDate": "2017-12-06T03:04:17.343", "CreationDate": "2017-12-04T18:16:29.820", "ParentId": "47638649", "CommentCount": "2", "LastEditDate": "2017-12-06T03:04:17.343", "OwnerUserId": "187690"}});