post_cb({"45847950": {"Id": "45847950", "PostTypeId": "2", "Body": "<p>You can try adding some type trait check to verify that arguments of second constructor are iterators over T elements:</p>\n<pre><code>template\n&lt;\n    typename InputIterator\n,   typename = typename ::std::enable_if\n    &lt;\n        ::std::is_same\n        &lt;\n            T &amp;\n        ,   typename ::std::remove_const\n            &lt;\n                decltype(*(::std::declval&lt; InputIterator &gt;()))\n            &gt;::type\n        &gt;::value\n    ,  void\n    &gt;::type\n&gt;\nNaiveVector(InputIterator first, InputIterator last) : v(first, last)\n{\n    cout &lt;&lt; \"(InputIterator first, InputIterator last)\" &lt;&lt; endl;\n}\n</code></pre>\n<p><a href=\"https://ideone.com/rf9qXv\" rel=\"nofollow noreferrer\">Run this code online</a></p>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-08-23T19:32:46.113", "Score": "1", "CreationDate": "2017-08-23T19:30:40.797", "ParentId": "45847787", "CommentCount": "4", "OwnerUserId": "7860670", "LastEditDate": "2017-08-23T19:32:46.113"}, "bq_ids": {"n4140": {"so_45847787_45848470_8": {"length": 12, "quality": 1.0, "section_id": 733}, "so_45847787_45848470_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 733}, "so_45847787_45847989_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 744}, "so_45847787_45848470_9": {"length": 15, "quality": 0.9375, "section_id": 734}}, "n3337": {"so_45847787_45848470_9": {"length": 15, "quality": 0.9375, "section_id": 723}, "so_45847787_45848470_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 722}, "so_45847787_45847989_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 733}, "so_45847787_45848470_8": {"length": 12, "quality": 1.0, "section_id": 722}}, "n4659": {"so_45847787_45848470_9": {"length": 15, "quality": 0.9375, "section_id": 747}, "so_45847787_45848470_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 763}, "so_45847787_45847989_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 802}, "so_45847787_45848470_8": {"length": 12, "quality": 1.0, "section_id": 763}}}, "45847787": {"ViewCount": "135", "Body": "<p>I suspect the prototypes of fill constructor and range constructor of <code>std::vector</code> (and many other STL types) given in this <a href=\"http://www.cplusplus.com/reference/vector/vector/vector/\" rel=\"nofollow noreferrer\">webpage</a> are not right, so I implement a <code>NaiveVector</code> to mimic these two prototypes.</p>\n<p>My code is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct NaiveVector {\n  vector&lt;T&gt; v;\n  NaiveVector(size_t num, const T &amp;val) : v(num, val) { // fill\n    cout &lt;&lt; \"(int num, const T &amp;val)\" &lt;&lt; endl;\n  }\n\n  template &lt;typename InputIterator&gt;\n  NaiveVector(InputIterator first, InputIterator last) : v(first, last) { // range\n    cout &lt;&lt; \"(InputIterator first, InputIterator last)\" &lt;&lt; endl;\n  }\n\n  size_t size() const { return v.size(); }\n};\n\nint main() {\n  NaiveVector&lt;int&gt; myVec1(5,1);                   // A\n  cout &lt;&lt; \"size = \" &lt;&lt; myVec1.size() &lt;&lt; endl;\n  for (auto n : myVec1.v) { cout &lt;&lt; n &lt;&lt; \" \"; }\n  cout &lt;&lt; endl;\n\n  cout &lt;&lt; \"-----\" &lt;&lt; endl;\n\n  vector&lt;int&gt; vec({1,2,3,4,5});               \n  NaiveVector&lt;int&gt; myVec2(vec.begin(), vec.end());// B\n  cout &lt;&lt; \"size = \" &lt;&lt; myVec2.size() &lt;&lt; endl;\n  for (auto n : myVec2.v) { cout &lt;&lt; n &lt;&lt; \" \"; }\n  cout &lt;&lt; endl;\n}\n</code></pre>\n<p>And the output is:</p>\n<pre><code>$ g++ overload.cc -o overload -std=c++11\n$ ./overload\n(InputIterator first, InputIterator last) // should be: (int num, const T &amp;val)\nsize = 5\n1 1 1 1 1\n-----\n(InputIterator first, InputIterator last)\nsize = 5\n1 2 3 4 5\n</code></pre>\n<p>As I suspected from the beginning, the compiler cannot differentiate the two constructors properly. Then <strong>my question</strong> is: how does <code>std::vector</code>'s fill constructor and range constructor differentiate from each other?</p>\n<p><strong>Rephrase</strong>: how to implement the two constructors of this <code>NaiveVector</code>?</p>\n<blockquote>\n<p id=\"so_45847787_45847787_0\">This question seems to be a duplicate of <a href=\"https://stackoverflow.com/q/21042872/8385554\">this</a> question but the answer is not satisfying. Additionally, C++11 itself doesn't provide a <code>is_iterator&lt;&gt;</code>.. (MSVC has lots of hacks).</p>\n</blockquote>\n<p>Edit: it is allowed to bind an rvalue to a constant lvalue reference, so the first constructor of <code>NaiveVector</code> is valid for <code>A</code>.</p>\n", "AcceptedAnswerId": "45848470", "Title": "How to differentiate fill constructor and range constructor in C++11?", "CreationDate": "2017-08-23T19:19:09.733", "Id": "45847787", "CommentCount": "11", "LastEditDate": "2017-08-23T20:09:08.173", "PostTypeId": "1", "LastEditorUserId": "44729", "LastActivityDate": "2017-08-23T20:09:08.173", "Score": "1", "OwnerUserId": "8385554", "Tags": "<c++><c++11><constructor><overloading>", "AnswerCount": "3"}, "45848470": {"Id": "45848470", "PostTypeId": "2", "Body": "<p><strong>C++03</strong></p>\n<p>[lib.sequence.reqmts]/9</p>\n<blockquote>\n<p id=\"so_45847787_45848470_0\">For every sequence defined in this clause and in clause 21:</p>\n<ul>\n<li><p id=\"so_45847787_45848470_1\">the constructor</p>\n<pre><code>template &lt;class InputIterator&gt;\nX(InputIterator f, InputIterator l, const Allocator&amp; a = Allocator())\n</code></pre>\n<p id=\"so_45847787_45848470_2\">shall have the same effect as:</p>\n<pre><code>X(static_cast&lt;typename X::size_type&gt;(f),\n  static_cast&lt;typename X::value_type&gt;(l),\n  a)\n</code></pre>\n<p id=\"so_45847787_45848470_3\">if <code>InputIterator</code> is an integral type.</p></li>\n</ul>\n<p id=\"so_45847787_45848470_4\">...</p>\n</blockquote>\n<p>[lib.sequence.reqmts]/11</p>\n<blockquote>\n<p id=\"so_45847787_45848470_5\">One way that sequence implementors can satisfy this requirement is to specialize the member template for\n  every integral type. Less cumbersome implementation techniques also exist.</p>\n</blockquote>\n<p>In other words, the standard says that if the range constructor gets selected by overload resolution but the \"iterator\" type is actually an integral type, it has to delegate to the fill constructor by casting its argument types to force the latter to be an exact match.</p>\n<p><strong>C++11/C++14</strong></p>\n<p>[sequence.reqmts]/14</p>\n<blockquote>\n<p id=\"so_45847787_45848470_6\">For every sequence container defined in this clause and in clause 21:</p>\n<ul>\n<li><p id=\"so_45847787_45848470_7\">If the constructor</p>\n<pre><code>template &lt;class InputIterator&gt;\nX(InputIterator first, InputIterator last,\n  const allocator_type&amp; alloc = allocator_type())\n</code></pre>\n<p id=\"so_45847787_45848470_8\">is called with a type <code>InputIterator</code> that does not qualify as an input iterator, then the constructor shall not participate in overload resolution.\n  ...</p></li>\n</ul>\n</blockquote>\n<p>[sequence.reqmts]/15</p>\n<blockquote>\n<p id=\"so_45847787_45848470_9\">The extent to which an implementation determines that a type cannot be an input iterator is unspecified,\n  except that as a minimum integral types shall not qualify as input iterators.</p>\n</blockquote>\n<p>This is more or less the way the standard hints to you to use SFINAE (which works reliably in C++11 as opposed to C++03).</p>\n<p><strong>C++17</strong></p>\n<p>The wording is similar, except that the paragraph about integral types not being iterators has been moved to <a href=\"http://eel.is/c++draft/container.requirements.general#17\" rel=\"noreferrer\">[container.requirements.general]/17</a>.</p>\n<p><strong>Conclusion</strong></p>\n<p>You can write your range constructor to look something like this:</p>\n<pre><code>template &lt;typename InputIterator,\n          typename = std::enable_if&lt;is_likely_iterator&lt;InputIterator&gt;&gt;::type&gt;\nNaiveVector(InputIterator first, InputIterator last)\n</code></pre>\n<p>The <code>is_iterator</code> helper template might simply disqualify integral types and accept all other types, or it might do something more sophisticated such as checking whether there is an <code>std::iterator_traits</code> specialization that indicates that the type is an input iterator (or stricter). See <a href=\"https://github.com/gcc-mirror/gcc/blob/7b35a939b8cb869efb830701cef4fa1dc5ff4020/libstdc%2B%2B-v3/include/bits/stl_iterator_base_types.h#L230\" rel=\"noreferrer\">libstdc++ source</a>, <a href=\"https://github.com/llvm-mirror/libcxx/blob/24047fd4a7e8231b2220abc1d20b16bc5de3ee87/include/iterator#L512\" rel=\"noreferrer\">libc++ source</a></p>\n<p>Both approaches are consistent with the standard's mandated behaviour of <code>std::vector</code> in C++11 and later. The latter approach is recommended (and will be consistent with what the real <code>std::vector</code> is likely to do on typical implementations), because if you pass arguments that are implicitly convertible to the types expected by the fill constructor, you would hope that the class would \"do the right thing\" and not select the range constructor only to have it fail to compile. (Although I suspect this is fairly uncommon.) Relative to the C++03 <code>std::vector</code>, it is a \"conforming extension\" since in that case the constructor call would not compile.</p>\n", "LastActivityDate": "2017-08-23T20:08:31.867", "CommentCount": "1", "CreationDate": "2017-08-23T20:08:31.867", "ParentId": "45847787", "Score": "5", "OwnerUserId": "481267"}, "45847989": {"Id": "45847989", "PostTypeId": "2", "Body": "<p>If you read the documentation at <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/container/vector/vector</a> carefully, you will notice the following (emphasis mine):</p>\n<blockquote>\n<p id=\"so_45847787_45847989_0\">4) Constructs the container with the contents of the range <code>[first, last)</code>.</p>\n<p id=\"so_45847787_45847989_1\">This constructor has the same effect as <code>vector(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last), a)</code> if <code>InputIt</code> is an integral type.    (until C++11)</p>\n<p id=\"so_45847787_45847989_2\"><strong>This overload only participates in overload resolution if <code>InputIt</code> satisfies <code>InputIterator</code>, to avoid ambiguity with the overload (2)</strong>.</p>\n</blockquote>\n<p>The confusion is not with the <code>std::vector</code> but your expectation of which of your constructors gets called. Your code doesn't have the checks to make sure that the second constructor gets called only if the above condition of <code>std::vector</code> is met.</p>\n<p>In your case, when you use</p>\n<pre><code>NaiveVector&lt;int&gt; myVec1(5,1);\n</code></pre>\n<p>the second constructor can be called by using <code>int</code> as the template parameter without requiring any conversion. The compiler needs to convert an <code>int</code> to a <code>size_t</code> in order to be able to call the first constructor. Hence, the second constructor is a better fit.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2017-08-23T19:39:36.403", "Score": "2", "CreationDate": "2017-08-23T19:33:20.800", "ParentId": "45847787", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2017-08-23T19:39:36.403"}});