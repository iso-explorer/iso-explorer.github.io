post_cb({"bq_ids": {"n4140": {"so_47712965_47712965_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 615}, "so_47712965_47713725_5": {"length": 21, "quality": 0.875, "section_id": 639}, "so_47712965_47713725_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 639}, "so_47712965_47713725_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}, "so_47712965_47713725_3": {"length": 19, "quality": 0.8636363636363636, "section_id": 639}}, "n3337": {"so_47712965_47712965_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 605}, "so_47712965_47713725_5": {"length": 21, "quality": 0.875, "section_id": 629}, "so_47712965_47713725_0": {"length": 26, "quality": 0.7647058823529411, "section_id": 629}, "so_47712965_47713725_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}, "so_47712965_47713725_3": {"length": 19, "quality": 0.8636363636363636, "section_id": 629}}, "n4659": {"so_47712965_47712965_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 641}, "so_47712965_47713725_5": {"length": 21, "quality": 0.875, "section_id": 667}, "so_47712965_47713725_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 667}, "so_47712965_47713725_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}, "so_47712965_47713725_3": {"length": 19, "quality": 0.8636363636363636, "section_id": 667}}}, "47713725": {"Id": "47713725", "PostTypeId": "2", "Body": "<p><strong>N4713 16.3.3.2:</strong></p>\n<blockquote>\n<p id=\"so_47712965_47713725_0\">3.3 \n  User-defined conversion sequence U1 is a <strong>better conversion</strong> sequence than another user-defined conversion sequence U2 if they contain the same user-defined conversion function or constructor or they initialize the same class in an aggregate initialization and in either case the second <strong>standard conversion</strong>sequence of U1 is better than the second <strong>standard conversion</strong> sequence of U2. \n  [Example</p>\n</blockquote>\n<pre><code>struct A {\n    operator short();\n} a;\nint f(int);\nint f(float);\nint i = f(a); // calls f(int), because short\u2192int is // better than short \u2192float\n</code></pre>\n<blockquote>\n<p id=\"so_47712965_47713725_1\">end example]</p>\n</blockquote>\n<p>So, <strong>standard conversion</strong> is the key: </p>\n<blockquote>\n<p id=\"so_47712965_47713725_2\"><strong>3.2</strong>\n  Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if</p>\n<p id=\"so_47712965_47713725_3\"><strong>3.2.3</strong> \n  S1 and S2 are reference bindings (11.6.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference [ Example:</p>\n</blockquote>\n<pre><code>int i;\nint f1();\nint&amp;&amp; f2();\nint g(const int&amp;);\nint g(const int&amp;&amp;);\nint j = g(i); // calls g(const int&amp;)\nint k = g(f1()); // calls g(const int&amp;&amp;)\nint l = g(f2()); // calls g(const int&amp;&amp;)\nstruct A {\n    A&amp; operator&lt;&lt;(int);\n    void p() &amp;;\n    void p() &amp;&amp;;\n};\nA&amp; operator&lt;&lt;(A&amp;&amp;, char);\nA() &lt;&lt; 1; // calls A::operator&lt;&lt;(int)\nA() &lt;&lt; \u2019c\u2019; // calls operator&lt;&lt;(A&amp;&amp;, char)\nA a;\na &lt;&lt; 1; // calls A::operator&lt;&lt;(int)\na &lt;&lt; \u2019c\u2019; // calls A::operator&lt;&lt;(int)\nA().p(); // calls A::p()&amp;&amp;\na.p(); // calls A::p()&amp;\n</code></pre>\n<blockquote>\n<p id=\"so_47712965_47713725_4\">end example]</p>\n<p id=\"so_47712965_47713725_5\"><strong>3.2.6</strong>: \n  S1 and S2 are reference bindings (11.6.3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers. \n  [Example: </p>\n</blockquote>\n<pre><code>int f(const int &amp;);\nint f(int &amp;);\nint g(const int &amp;);\nint g(int);\nint i;\nint j = f(i); // calls f(int &amp;)\nint k = g(i); // ambiguous\nstruct X {\n    void f() const;\n    void f();\n};\nvoid g(const X&amp; a, X b) {\n    a.f(); // calls X::f() const\n    b.f(); // calls X::f()\n}\n</code></pre>\n<blockquote>\n<p id=\"so_47712965_47713725_6\">\u2014 end example]</p>\n</blockquote>\n<p>So <code>gcc</code> meets the standards's requirement. </p>\n", "LastEditorUserId": "6949852", "LastActivityDate": "2017-12-08T12:33:40.793", "Score": "1", "CreationDate": "2017-12-08T11:42:18.120", "ParentId": "47712965", "CommentCount": "1", "OwnerUserId": "6949852", "LastEditDate": "2017-12-08T12:33:40.793"}, "47712965": {"ViewCount": "141", "Body": "<p>I am trying to understand <em>overload resolution</em>.</p>\n<p>First let's consider this first case:</p>\n<pre><code>struct int1{\n   int val;\n   operator int&amp;()&amp;{\n      return val;\n      }\n   operator const int &amp;() const&amp;{\n      return val;\n      }\n    };\n\nvoid f(int &amp;){}       //f#1\nvoid f(const int&amp;){}  //f#2\n\nvoid test1(){\n  int1 x;\n  f(x);\n   //Conversion sequence for f#1: \n   //   - int_wrapper&amp; --&gt; int1::operator int&amp;\n   //   =&gt; Ranking: user defined conversion rank\n   //Converison sequence for f#2:\n   //   - int1&amp; --&gt; int1::operator int &amp; --&gt; const int&amp;\n   //   - int1&amp; --&gt; const int1 &amp;         --&gt; int1::operator const int&amp; \n   //   =&gt; Ranking: ambiguous because 2 conversion sequence [over.best.ics]/10 \n   //            =&gt; user defined conversion rank \n   //\n   //=&gt; No best viable overload, 2 user defined conversion rank \n}\n</code></pre>\n<p><strong>Unlike my wrong analysis</strong>, compilers agrees: <strong>the call to <code>f</code> is not ambiguous</strong>. Why?</p>\n<hr>\n<p>Now consider this second case, which is very similar, I just replace the <code>int&amp;</code> by <code>int &amp;&amp;</code>:</p>\n<pre><code>struct int2{\n   int val;\n   operator int&amp;&amp;()&amp;&amp;{\n      return std::move(val);\n      }\n   operator const int &amp;() const&amp;{\n      return val;\n      }\n    };\n\nvoid g(int &amp;&amp;){}     // g#1 \nvoid g(const int&amp;){} // g#2\n\nvoid test2(){\n  int2 x;\n  g(std::move(x));\n  //Conversions sequence for g#1 \n  //   - int2&amp;&amp; --&gt; int2::operator int&amp;&amp;\n  //   =&gt; Ranking: user defined conversion rank\n  //Conversion sequence for g#2 \n  //   - int2&amp;&amp; --&gt; const int2&amp;           --&gt; int2::operator const int&amp;\n  //   - int2&amp;&amp; --&gt; int2::operator int&amp;&amp;  --&gt; const int&amp;\n  //   =&gt; Ranking: ambiguous because 2 conversion sequence [over.best.ics]/10 \n  //            =&gt; user defined conversion rank \n  //\n  //=&gt; No best viable overload, 2 user defined conversion rank \n  }\n</code></pre>\n<p>My analysis (which is certainly wrong in this case too) concludes similarly that the call to <code>g</code> is ambiguous. Unfortunatly, in this second case, compilers do not agree:</p>\n<ul>\n<li>Clang (3.4.1 to 5.0), MSVC 19 2017 RTW, Zapcc 190308 (Clang derivate), ellcc (0.1.33, 0.1.34)(Clang derivate) =&gt; call to <code>g</code> is <strong>ambiguous</strong>;</li>\n<li>GCC (4.8.1 to 7.2), icc (16 to 18) =&gt; call to <code>g</code> is <strong>not ambiguous</strong>.</li>\n</ul>\n<p>What is the right analysis and which compiler is right?</p>\n<hr>\n<p>Could you precise why the rule below does not apply, or when is it applied?</p>\n<p><strong>[over.best.ics]/10:</strong></p>\n<blockquote>\n<p id=\"so_47712965_47712965_0\">If several different sequences of conversions exist that each convert the argument to the parameter type, the\n  implicit conversion sequence associated with the parameter is defined to be the unique conversion sequence\n  designated the\n  ambiguous conversion sequence\n  . For the purpose of ranking implicit conversion sequences as\n  described in 16.3.3.2, the ambiguous conversion sequence is treated as a user-defined conversion sequence\n  that is indistinguishable from any other user-defined conversion sequence</p>\n</blockquote>\n</hr></hr>", "AcceptedAnswerId": "47715364", "Title": "Understanding overload resolution ranking involving user defined conversion", "CreationDate": "2017-12-08T10:58:34.447", "LastActivityDate": "2017-12-08T18:46:38.030", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-08T18:46:38.030", "LastEditorUserId": "5632316", "Id": "47712965", "Score": "6", "OwnerUserId": "5632316", "Tags": "<c++><overloading><language-lawyer>", "AnswerCount": "2"}, "47715364": {"Id": "47715364", "PostTypeId": "2", "Body": "<p>Both of these examples are more complicated representations of simpler underlying concepts:</p>\n<pre><code>void f(int&amp; );        // #1\nvoid f(int const&amp; );  // #2\nvoid g(int&amp;&amp; );       // #3\nvoid g(int const&amp; );  // #4\n\nint i;\nf(i); // calls #1\ng(0); // calls #3\n</code></pre>\n<p>For the first call, we favor the the <a href=\"http://eel.is/c++draft/over#ics.rank-3.2.6\" rel=\"nofollow noreferrer\">less <em>cv</em>-qualified type</a>, so <code>int&amp;</code> is better than <code>int const&amp;</code>.  For the second call, we favor <a href=\"http://eel.is/c++draft/over#ics.rank-3.2.3\" rel=\"nofollow noreferrer\">binding to rvalue reference</a> over binding to lvalue reference, so <code>int&amp;&amp;</code> is better than <code>int const&amp;</code>.</p>\n<p>In the specific example, these preferences manifest themselves over the choice of conversion function used by way of the implicit object parameter. For the first example, because we're binding the implicit object parameter to <code>int1&amp;</code> for converting to <code>int&amp;</code>, but <code>int1 const&amp;</code> for converting to <code>int const&amp;</code>. Likewise, in the second example, we're binding the implicit object parameter to <code>int2&amp;&amp;</code> for converting to <code>int&amp;&amp;</code>, but <code>int2 const&amp;</code> for converting to <code>int const&amp;</code>.  </p>\n<p>I'd call this a clang bug. </p>\n", "LastActivityDate": "2017-12-08T13:28:12.647", "Score": "3", "CreationDate": "2017-12-08T13:28:12.647", "ParentId": "47712965", "CommentCount": "3", "OwnerUserId": "2069064"}});