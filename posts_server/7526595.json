post_cb({"7526836": {"ParentId": "7526595", "CommentCount": "0", "Body": "<p>The standard has this to say about \"object lifetime\" (\u00a73.8 in N3290):</p>\n<blockquote>\n<p id=\"so_7526595_7526836_0\">The lifetime of an object of type T ends when:<br>\n  \u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or<br>\n  \u2014 the storage which the object occupies is reused or released.</br></br></p>\n</blockquote>\n<p>After you've <code>free</code>'d the block pointed to by <code>memory1</code>, that object is dead. It has ceased to exist. Dereferencing that pointer would be undefined behavior.</p>\n<p><code>memory2</code> could be assigned the same memory address, but it wouldn't \"alias\" anything: what was at that location has passed away.</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "7526836", "Score": "3", "CreationDate": "2011-09-23T09:23:05.707", "LastActivityDate": "2011-09-23T09:23:05.707"}, "7526631": {"ParentId": "7526595", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Because once you free(memory1), accessing anything via the memory1 pointer is undefined behavior (nasal demons, and so forth), and hence the compiler can optimize assuming that memory2 is not aliased by any other pointer after the malloc() call.</p>\n<p>As for why this matters, assuming the compiler itself has no internal information about the semantics of malloc(), i.e. that it treats it just like any other function, then it cannot assume that the pointer returned is not aliased by any other pointer. The <code>__declspec(restrict)</code> (or equivalently, <code>__attribute__((malloc))</code> in GCC) tells the compiler that the pointer is not aliased by any other pointer, which allows some optimizations not possible otherwise.</p>\n", "OwnerUserId": "75652", "LastEditorUserId": "75652", "LastEditDate": "2011-09-23T09:25:08.180", "Id": "7526631", "Score": "4", "CreationDate": "2011-09-23T09:05:46.677", "LastActivityDate": "2011-09-23T09:25:08.180"}, "7526595": {"CommentCount": "2", "ViewCount": "119", "CreationDate": "2011-09-23T09:02:32.157", "LastActivityDate": "2011-09-23T09:25:08.180", "Title": "What's the duration of \"pointer not aliased by any other pointer\" implication?", "AcceptedAnswerId": "7526836", "PostTypeId": "1", "Id": "7526595", "Score": "2", "Body": "<p>Currently Visual C++ is shipped with runtime where <code>malloc()</code> is decorated with <a href=\"http://msdn.microsoft.com/en-us/library/8bcxafdh%28v=vs.80%29.aspx\" rel=\"nofollow\"><code>__declspec( restrict )</code></a>.</p>\n<p>MSDN says this decoration states to the compiler that <strong><em>a pointer returned by <code>malloc()</code> cannot be aliased by any other pointer</em></strong>. Okay, two subsequent calls to <code>malloc()</code> indeed return distinct pointers. But what happens if I call</p>\n<pre><code>void* memory1 = malloc( 10 );\nfree( memory1 );\nvoid* memory2 = malloc( 10 );\n//here memory1 may be equal to memory2\n</code></pre>\n<p>In this case the two pointers can point to the very same location. How does this correlate with <em>cannot be aliased by any other pointer</em> implication of <code>__declspec( restrict )</code>?</p>\n", "Tags": "<c++><visual-c++><memory-management><pointers><aliasing>", "OwnerUserId": "57428", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7526595_7526836_0": {"section_id": 7189, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_7526595_7526836_0": {"section_id": 6933, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_7526595_7526836_0": {"section_id": 8697, "quality": 0.8421052631578947, "length": 16}}}});