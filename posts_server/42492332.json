post_cb({"42492369": {"Id": "42492369", "PostTypeId": "2", "Body": "<p><strong>TL;DR</strong> because, different data types occupy different size in memory and has different alignment requirement.</p>\n<p>To elaborate, a pointer variable holds an address which points to some type of data. Without the type associated, there would be no way to dereference the pointer and get the <em>value</em>.</p>\n<p>In other words, to access the data pointed to by a pointer, the associated data type must be known.</p>\n<p>The size of the pointer itself, has little connection to the actual data it points to.</p>\n<p>There exists a pointer , <code>void *</code> which is considered a <em>generic</em> pointer, but then, you can't dereference it, as the result of dereference would attempt to produce an incomplete type. You need to cast it to a complete type to be able to dereference or apply pointer arithmetic on a void pointer.</p>\n<p>The reason behind considering <code>void *</code> a <em>generic</em> pointer is as below, quoting from the <code>C11</code> standard, chapter \u00a76.3.2.3</p>\n<blockquote>\n<p id=\"so_42492332_42492369_0\">A pointer to <code>void</code> may be converted to or from a pointer to any object type. A pointer to\n  any object type may be converted to a pointer to <code>void</code> and back again; the result shall\n  compare equal to the original pointer.</p>\n</blockquote>\n<p>So, a <code>void *</code> can be used as a generic <em>container</em> which can hold any pointer type, but to make some operation on the pointer (which includes the knowledge of the data type), you need to cast it to a complete type first.</p>\n", "LastEditorUserId": "2173917", "LastActivityDate": "2017-02-27T17:55:14.970", "Score": "13", "CreationDate": "2017-02-27T17:44:14.790", "ParentId": "42492332", "CommentCount": "2", "OwnerUserId": "2173917", "LastEditDate": "2017-02-27T17:55:14.970"}, "42492418": {"Id": "42492418", "PostTypeId": "2", "Body": "<p>A <code>void *</code> pointer can be viewed as a \"generalized\" pointer.</p>\n<p>It can't be dereferenced, though, because by being generic it doesn't point to any one type of object.  To actually <em>use</em> a <code>void *</code> pointer and access whatever it's pointing to, you need to cast it to the type of object you're accessing.</p>\n<p>And since it doesn't point to any one type of object, there's no proper way to perform pointer arithmetic on a <code>void *</code> pointer.</p>\n", "LastActivityDate": "2017-02-27T17:46:42.817", "CommentCount": "1", "CreationDate": "2017-02-27T17:46:42.817", "ParentId": "42492332", "Score": "2", "OwnerUserId": "4756299"}, "42492429": {"Id": "42492429", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42492332_42492429_0\">Then,why can't we generalize a pointer declaration like this</p>\n<pre><code> pointer p;  //where p is an object of pointer class.\n</code></pre>\n</blockquote>\n<p>You actually can using <code>void*</code>. But the consequence is that all type (and size information) is lost at that point. </p>\n<p>You'll have to keep track of that somehow (hard-coded type casts or whatever), to make that useful.</p>\n", "LastActivityDate": "2017-02-27T17:47:29.383", "CommentCount": "3", "CreationDate": "2017-02-27T17:47:29.383", "ParentId": "42492332", "Score": "0", "OwnerUserId": "1413395"}, "42492332": {"ViewCount": "274", "Body": "<p>The size of pointer is same irrespective of datatype it is pointing to.Then why do we need to declare the datatype it points to?</p>\n<p>For example,</p>\n<pre><code>int *p;  //p will point to an integer data type.\nchar *p;  //p will point to a character\n</code></pre>\n<p>Then,why can't we generalize a pointer declaration like this</p>\n<pre><code>pointer p;  //where p is an object of pointer class.\n</code></pre>\n", "AcceptedAnswerId": "42492369", "Title": "Why can't we generalize the pointer declaration?", "CreationDate": "2017-02-27T17:42:18.553", "Id": "42492332", "CommentCount": "6", "LastEditDate": "2017-02-27T18:29:49.763", "PostTypeId": "1", "LastEditorUserId": "2173917", "LastActivityDate": "2017-07-20T11:05:32.663", "Score": "4", "OwnerUserId": "7631254", "Tags": "<c++><c><pointers>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_42492332_42493240_2": {"length": 13, "quality": 0.8125, "section_id": 7223}, "so_42492332_42492369_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 6039}}, "n3337": {"so_42492332_42493240_2": {"length": 13, "quality": 0.8125, "section_id": 6967}, "so_42492332_42492369_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 5807}}, "n4659": {"so_42492332_42493240_2": {"length": 13, "quality": 0.8125, "section_id": 8732}, "so_42492332_42492369_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7548}}}, "42493240": {"Id": "42493240", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42492332_42493240_0\">The size of pointer is same irrespective of data type it is pointing to.</p>\n</blockquote>\n<p>This is not necessarily true - pointers to different types <em>may</em> have different sizes and representations:</p>\n<blockquote id=\"so_42492332_42493240_1\">\nA pointer to <code>void</code> shall have the same representation and alignment requirements as a\npointer to a character type.<sup>48)</sup> Similarly, pointers to qualified or unqualified versions of\ncompatible types shall have the same representation and alignment requirements. All\npointers to structure types shall have the same representation and alignment requirements\nas each other. All pointers to union types shall have the same representation and\nalignment requirements as each other. <em>Pointers to other types need not have the same\nrepresentation or alignment requirements</em>.\n</blockquote>\n<p><sup><em><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow noreferrer\">C 2011 Online Draft</a>, \u00a76.2.5 \u00b628</em></sup></p>\n<blockquote id=\"so_42492332_42493240_2\">The value representation of pointer types\nis implementation-defined. Pointers to layout-compatible types shall have the same value representation and\nalignment requirements (3.11).\n</blockquote>\n<p><sup><em><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++ 2014 Working Draft</a>, \u00a73.9.2, \u00b63</em></sup></p>\n<p>On most modern desktop and servers they're the same, but don't expect it to be universally true.</p>\n<blockquote>\n<p id=\"so_42492332_42493240_3\">Then why do we need to declare the data type it is pointing to?</p>\n</blockquote>\n<p>Pointer arithmetic depends on the pointed-to type - if <code>p</code> points to an object of type <code>T</code>, then <code>p + 1</code> points to the next object of type <code>T</code>.  Since different types have different sizes, you need to know the pointed-to type to compute the offset correctly.  </p>\n", "LastActivityDate": "2017-02-27T18:31:58.223", "CommentCount": "0", "CreationDate": "2017-02-27T18:31:58.223", "ParentId": "42492332", "Score": "1", "OwnerUserId": "134554"}, "42492397": {"Id": "42492397", "PostTypeId": "2", "Body": "<p>You <em>can</em> generalize pointers using <code>void*</code>. <code>void*</code> is a pointer to some address without any type information associated. However, there is little you can do with these pointers without casting them to an explicit pointer type first.</p>\n<p>Consider the following example. It will not compile, because it's impossible to deduce the \"value\" pointed to by <code>ptr</code> is. You can't even know how many bytes constitute the value.</p>\n<pre><code>void print(const void * ptr) {\n    std::cout &lt;&lt; *ptr; // What's the \"value\" of ptr?\n}\n</code></pre>\n", "LastEditorUserId": "7359094", "LastActivityDate": "2017-06-01T13:39:01.767", "Score": "6", "CreationDate": "2017-02-27T17:45:58.940", "ParentId": "42492332", "CommentCount": "1", "OwnerUserId": "7359094", "LastEditDate": "2017-06-01T13:39:01.767"}, "42492361": {"Id": "42492361", "PostTypeId": "2", "Body": "<p>Pointer arithmetic.</p>\n<p>Explanation:</p>\n<pre><code>int arr[] = {4, 6, 9, 10};\nint* x = arr;\n\n*(x+0) = 4\n*(x+1) = 6\n</code></pre>\n<p>Compiler knows that x+1 is actually x+sizeof(int) and not 1.</p>\n<p>To read the second element the compiler has to skip sizeof(int) each time. Without knowing the actual type you can't dereference it and extract the data correctly. </p>\n<p>Plus types differ in size, and the compiler needs to know how many bytes to read from the memory pointed to. A char will be 1 byte and int will be more than 1 byte.</p>\n", "LastEditorUserId": "6530695", "LastActivityDate": "2017-07-20T11:05:32.663", "Score": "6", "CreationDate": "2017-02-27T17:43:36.917", "ParentId": "42492332", "CommentCount": "1", "OwnerUserId": "6530695", "LastEditDate": "2017-07-20T11:05:32.663"}});