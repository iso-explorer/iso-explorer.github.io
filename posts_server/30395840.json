post_cb({"30396103": {"ParentId": "30395840", "CommentCount": "0", "Body": "<p>C++ has a <em>memory model</em> that considers computer memory as byte-addressible:</p>\n<blockquote>\n<p id=\"so_30395840_30396103_0\">The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address.</p>\n</blockquote>\n<p>-- C++ Standard, <strong>[intro.memory]</strong>/1</p>\n<p>For historical reasons, rather than having a <code>byte</code> type to access bytes of memory byte-wise, C++ uses the <em>character types</em> <code>char</code>, <code>unsigned char</code> and <code>signed char</code>:</p>\n<blockquote>\n<p id=\"so_30395840_30396103_1\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <code>N</code> <code>unsigned char</code> objects taken up by\n  the object of type <code>T</code>, where <code>N</code> equals <code>sizeof(T)</code>.</p>\n</blockquote>\n<p>-- ibid., <strong>[basic.types]</strong>/4</p>\n<p>That means that it is always legal to access program memory by casting a data pointer to <code>unsigned char *</code>.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "30396103", "Score": "0", "CreationDate": "2015-05-22T11:56:56.650", "LastActivityDate": "2015-05-22T11:56:56.650"}, "30395840": {"CommentCount": "5", "ViewCount": "70", "PostTypeId": "1", "LastEditorUserId": "1935759", "CreationDate": "2015-05-22T11:44:25.077", "LastActivityDate": "2015-05-22T12:13:18.753", "Title": "Assignment between pointers of different types is working and I dont know why", "FavoriteCount": "1", "LastEditDate": "2015-05-22T12:13:18.753", "Id": "30395840", "Score": "2", "Body": "<p>I am a computer vision engineer and use the OpenCV library a whole lot. I often work with raw data of type <code>unsigned short</code> and have to assign it to <code>cv::Mat</code> object of OpenCV.</p>\n<p>This <code>cv::Mat</code> object has a field called data, and this field is of type <code>unsigned char*</code> regardless of the type of the data. </p>\n<p>So, what I do to assign <code>unsigned short*</code> data to the <code>unsigned char*</code> Mat.data is the following:</p>\n<pre><code>// Obtain raw data from the hardware\nconst unsigned short* rawData = engine-&gt;getRawData();\n\n// Create Mat with right dimensions and of type 16 Bit unsigned and 1 channel (unsigned short)\ncv::Mat Test = cv::Mat::zeros(480, 640, CV_16UC1);\n\n// Assign data by casting rawData to unsigned char* type\nTest.data = (unsigned char*) rawData;\n\n// Convert Test to 8Bit unsigned so I can visualize it\nTest.convertTo(irIm, CV_8UC1);\n</code></pre>\n<p>I use this method in a lot of situations and it works fine, but I never really understood why it works. I have a block of data of type unsigned short, and then I just cast it to <code>unsigned char*</code> and the program doesn't crash and no data is lost. </p>\n<p>Can anyone help me understanding this?</p>\n<p>EDIT: </p>\n<p>Regarding the answers I got. \nI understand that the data will still be valid but interpreted differently, but it still does not make sense in my head.</p>\n<p>Imagine I have the following short: 0010000100001000 . Now, I used a calculator to realize that this short represents 8456 in decimal. If then I interpret this as unsigned char, I will read it as two bytes, then I have 00100001 byte and then 00001000, which in no way represent the previous short value.</p>\n<p>So my question still stands. The only thing that makes sense in my head is that OpenCV is somehow expecting these casts and will internally transform data so it doesn't lose meaning. </p>\n", "Tags": "<c++><pointers><opencv>", "OwnerUserId": "1935759", "AnswerCount": "3"}, "30396019": {"ParentId": "30395840", "CommentCount": "0", "Body": "<p>People usually define raw bytes buffers as <code>unsigned char*</code>, because <code>unsigned char</code> is semantically a byte. A little better probably would be to use standardized integer type such as <code>uint8_t</code>, but both are seen.</p>\n<p>Casting from one pointer type to another just changes the <em>interpretation</em> of the data it points to. It does not touch the data itself.</p>\n<p>A similar situation is with <code>void*</code> sometimes people use this type to pass around buffers of unspecified content. With <code>void*</code>, however, you cannot use standard syntax for pointer arithmetics, internally such pointers are often cast to an appropriate type (or treated as separate bytes).</p>\n", "OwnerUserId": "1133179", "PostTypeId": "2", "Id": "30396019", "Score": "1", "CreationDate": "2015-05-22T11:53:12.633", "LastActivityDate": "2015-05-22T11:53:12.633"}, "bq_ids": {"n4140": {"so_30395840_30396103_1": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}, "so_30395840_30396103_0": {"section_id": 5785, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_30395840_30396103_1": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}, "so_30395840_30396103_0": {"section_id": 5558, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_30395840_30396103_1": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}, "so_30395840_30396103_0": {"section_id": 7242, "quality": 0.9230769230769231, "length": 12}}}, "30396033": {"ParentId": "30395840", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>the <code>data</code> field is a pointer to the matrix data. </p>\n<p>it is expected in <code>(unsigned char*)</code>. You can cast a pointer of different type to <code>(unsigned char*)</code>. Still they point to the same memory address where your <code>rawData</code> are stored in.</p>\n<p>But the important thing is when you create the matrix you specify the data type to be <code>CV_16UC1</code>. (one element is 16bit and unsigned. see <a href=\"http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=convertto#mat-depth\" rel=\"nofollow\">Documentation</a>). </p>\n<p>So if in your machine a <code>short</code> is of 2 bytes then <code>(unsigned short*)</code> can be casted to <code>(unsigned char*)</code> and still the matrix is valid.</p>\n", "OwnerUserId": "614656", "LastEditorUserId": "614656", "LastEditDate": "2015-05-22T12:00:47.620", "Id": "30396033", "Score": "0", "CreationDate": "2015-05-22T11:53:46.527", "LastActivityDate": "2015-05-22T12:00:47.620"}});