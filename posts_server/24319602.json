post_cb({"bq_ids": {"n4140": {"so_24319602_24319682_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 5510}}, "n3337": {"so_24319602_24319682_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 5296}}, "n4659": {"so_24319602_24319682_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 6945}}}, "24319602": {"ViewCount": "72", "Body": "<p>The following code is rejected by VC++ and clang.</p>\n<p>Why does <code>using A::f</code> not work as expected?</p>\n<p>Is there any way to hide some names in a given name space?</p>\n<pre><code>namespace A\n{\n    int f()\n    {\n        return 1;\n    }\n};\n\nnamespace B\n{\n    int f()\n    {\n        return 2;\n    }\n};\n\nusing namespace A;\nusing namespace B;\n\nusing A::f; // I want to hide B::f and only use A::f, how to do?\n\nint main()\n{\n    auto n = f(); // error : call to 'f' is ambiguous\n}\n</code></pre>\n", "Title": "Why does `using A::f` not work as expected?", "CreationDate": "2014-06-20T03:46:56.860", "LastActivityDate": "2014-06-20T04:01:26.863", "CommentCount": "4", "LastEditDate": "2014-06-20T03:56:10.727", "PostTypeId": "1", "LastEditorUserId": "508343", "Id": "24319602", "Score": "0", "OwnerUserId": "508343", "Tags": "<c++><namespaces><using>", "AnswerCount": "2"}, "24319653": {"Id": "24319653", "PostTypeId": "2", "Body": "<p>Because of this:</p>\n<pre><code>using namespace A;\nusing namespace B;\n</code></pre>\n<p>Both <code>f</code> functions are in scope.  They have the same signature, so what would you expect to happen?</p>\n<p>This using directive:</p>\n<pre><code>using A::f();\n</code></pre>\n<p>Is redundant.</p>\n", "LastActivityDate": "2014-06-20T03:53:16.343", "CommentCount": "4", "CreationDate": "2014-06-20T03:53:16.343", "ParentId": "24319602", "Score": "2", "OwnerUserId": "1053"}, "24319682": {"Id": "24319682", "PostTypeId": "2", "Body": "<p>The standard specifies the interpretation of the <code>using</code> directive. Emphasis mine:</p>\n<blockquote>\n<p id=\"so_24319602_24319682_0\">A <em>using-directive</em> specifies that the names in the nominated namespace can be used in the scope in which the\n   <em>using-directive</em> appears after the <em>using-directive</em>. <strong>During unqualified name lookup (3.4.1), the names appear\n    as if they were declared in the nearest enclosing namespace which contains both the <em>using-directive</em> and the\n   nominated namespace.</strong> [ <em>Note:</em> In this context, \u201ccontains\u201d means \u201ccontains directly or indirectly\u201d. \u2014 end\n            note ]</p>\n</blockquote>\n<p>(C++11 \u00a77.3.4/2)</p>\n<p>Thus, after</p>\n<pre><code>using namespace A;\nusing namespace B;\n</code></pre>\n<p>an unqualified lookup for the name <code>f</code> finds <code>A::f</code> and <code>B::f</code> <em>as though they have been declared in the global namespace</em>. The declaration <code>using A::f</code> introduces the name <code>f</code> into the global namespace in the same way (although it differs in that it actually makes <code>A::f</code> a member of the global namespace), so it is redundant as far as unqualified lookup goes. The point is that unqualified name lookup for <code>f</code> finds both <code>A::f</code> and <code>B::f</code> in the same declarative region.</p>\n<p><strong>Solution?</strong></p>\n<pre><code>int main()\n{\n    using A::f;\n    auto n = f(); // no longer ambiguous; finds A::f\n}\n</code></pre>\n<p>The first place that unqualified name lookup looks in is the block scope of <code>main</code>, so it will find only <code>A::f</code>, even though <code>A::f</code> and <code>B::f</code> would both be found in the enclosing namespace scope if searched.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2014-06-20T04:01:26.863", "Score": "4", "CreationDate": "2014-06-20T03:55:55.340", "ParentId": "24319602", "CommentCount": "0", "OwnerUserId": "481267", "LastEditDate": "2014-06-20T04:01:26.863"}});