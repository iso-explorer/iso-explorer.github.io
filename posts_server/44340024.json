post_cb({"44345747": {"ParentId": "44340024", "CommentCount": "18", "Body": "<blockquote id=\"so_44340024_44345747_0\">\n<ol>\n<li>The second overload will never be preferred over the first one (<strong>since that is now a forwarding reference overload</strong>, instead of being an rvalue reference overload), so what is supposed to happen here?</li>\n</ol>\n</blockquote>\n<p>No, it is <em>not</em> a forwarding reference. This is a key distinction. From <a href=\"http://eel.is/c++draft/temp#deduct.call-3\" rel=\"nofollow noreferrer\">[temp.deduct.call]</a>:</p>\n<blockquote>\n<p id=\"so_44340024_44345747_1\">A <em>forwarding reference</em> is an rvalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template (during class template argument deduction ([over.match.class.deduct])).</p>\n</blockquote>\n<p>Your candidates are:</p>\n<pre><code>template &lt;typename T&gt;\nSomething&lt;T&gt; F(T&amp;&amp;);       // this ONLY matches non-const rvalues\n\ntemplate &lt;typename T&gt;\nSomething&lt;T&gt; F(const T&amp;);  // this matches everything\n\ntemplate &lt;typename T, typename U, typename EnableIfNotT&lt;U, T&gt;*&gt;\nSomething&lt;T&gt; F(U&amp;&amp;);       // this matches nothing\n</code></pre>\n<p>When you write:</p>\n<pre><code>auto something = Something{std::shared_ptr&lt;int&gt;{}};\n</code></pre>\n<p>The <code>T&amp;&amp;</code> constructor is preferred, with <code>T=std::shared_ptr&lt;int&gt;</code>, so you end up with <code>Something&lt;std::shared_ptr&lt;int&gt;&gt;</code> as your class template specialization. If had instead written:</p>\n<pre><code>std::shared_ptr&lt;int&gt; p;\nauto something = Something{p};\n</code></pre>\n<p>then the <code>T const&amp;</code> constructor is preferred (indeed it is the only viable candidate). Although we end up in the same place: <code>Something&lt;std::shared_ptr&lt;int&gt;&gt;</code>.</p>\n<blockquote id=\"so_44340024_44345747_2\">\n<ol start=\"2\">\n<li>And it seems like the last one can never be called without explicitly specifying the T parameter, is this the intended behavior?</li>\n</ol>\n</blockquote>\n<p>Correct, <code>T</code> is a non-deduced context. This makes sense - this constructor exists to do conversions, but you need to specify what you're converting <em>to</em> in order to do the conversion. It would never make sense to have this \"just work\" for you.</p>\n<blockquote id=\"so_44340024_44345747_3\">\n<ol start=\"4\">\n<li>Further are user defined deduction guides required to be after the class definition?</li>\n</ol>\n</blockquote>\n<p>Yes. That's just where they go, by rule. It doesn't make sense to have trailing return type in the constructor - the constructor doesn't \"return\" anything.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "44345747", "Score": "1", "CreationDate": "2017-06-03T15:45:35.647", "LastActivityDate": "2017-06-03T15:45:35.647"}, "44340024": {"CommentCount": "11", "ViewCount": "154", "PostTypeId": "1", "LastEditorUserId": "5501675", "CreationDate": "2017-06-03T03:44:58.280", "LastActivityDate": "2017-06-03T15:45:35.647", "Title": "Gotchas with template argument deduction for class templates", "AcceptedAnswerId": "44345747", "LastEditDate": "2017-06-03T15:05:39.263", "Id": "44340024", "Score": "3", "Body": "<p>I was reading the paper regarding template argument deduction for class templates here <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html</a>.  This feature is in the C++17 standard, and some things had confused me.</p>\n<pre><code>template &lt;typename T&gt;\nclass Something {\npublic:\n\n    // delete the copy and move constructors for simplicity\n    Something(const Something&amp;) = delete;\n    Something(Something&amp;&amp;) = delete;\n\n    explicit Something(T&amp;&amp;) { ... }\n    explicit Something(const T&amp;) { ... }\n\n    template &lt;typename U, typename EnableIfNotT&lt;U, T&gt;* = nullptr&gt;\n    Something(U&amp;&amp;) { ... }\n};\n</code></pre>\n<p>Given the above code, if someone tries to instantiate an instance of the above template like this</p>\n<pre><code>auto something = Something{std::shared_ptr&lt;int&gt;{}};\n</code></pre>\n<p>will the rvalue reference overload always be called?  Since the overload set considered for deduction is </p>\n<pre><code>template &lt;typename T&gt;\nSomething&lt;T&gt; F(T&amp;&amp;) { ... }\ntemplate &lt;typename T&gt;\nSomething&lt;T&gt; F(const T&amp;) { ... }\ntemplate &lt;typename T, typename U, typename EnableIfNotT&lt;U, T&gt;*&gt;\nSomething&lt;T&gt; F(U&amp;&amp;) { ... }\n</code></pre>\n<ol>\n<li>The second overload will never be preferred over the first one (since that is now a forwarding reference overload, instead of being an rvalue reference overload), so what is supposed to happen here?  </li>\n<li>And it seems like the last one can never be called without explicitly specifying the <code>T</code> parameter, is this the intended behavior?</li>\n<li>Also are there any other gotchas or style guidelines that one should keep in mind when using template argument deduction for class templates?</li>\n<li>Further are user defined deduction guides required to be after the class definition?  For example, can you have the trailing return type in the declaration of the class constructor within the class definition itself? (Unlike the iterator constructor here <a href=\"http://en.cppreference.com/w/cpp/language/class_template_deduction\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/class_template_deduction</a>)</li>\n</ol>\n", "Tags": "<c++><templates><c++1z><forwarding><forwarding-reference>", "OwnerUserId": "5501675", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44340024_44345747_1": {"section_id": 341, "quality": 0.5263157894736842, "length": 10}}, "n3337": {"so_44340024_44345747_1": {"section_id": 331, "quality": 0.5263157894736842, "length": 10}}, "n4659": {"so_44340024_44345747_1": {"section_id": 311, "quality": 0.8947368421052632, "length": 17}}}});