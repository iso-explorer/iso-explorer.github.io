post_cb({"bq_ids": {"n4140": {"so_19611037_19612530_0": {"length": 30, "quality": 0.6521739130434783, "section_id": 710}}, "n3337": {"so_19611037_19612530_0": {"length": 30, "quality": 0.6521739130434783, "section_id": 699}}}, "19611098": {"PostTypeId": "2", "Body": "<p><strong>Update:</strong> Using a <code>std::unique_ptr</code> as a holder for the container is the canonical generic solution - simply don't move the container, just transfer the ownership and swap the iterators. As you already said you can special-case this as an optimization, although I'd expect the generic solution to be also quite efficient and I'd only accept more complexity (aka bug-potential) to the code after proving that it's a real performance win for your use-case.</p>\n<p>I'll leave the former answer below for future readers: Read it and the comments to see why other solutions are not really working and in which cases they cause trouble.</p>\n<hr>\n<p>The obvious way to update the iterator would be:</p>\n<pre><code>Container c = ...;\nContainer::iterator it = ...;\n\nconst auto d = std::distance( c.begin(), it );\nContainer n = std::move(c);\nit = n.begin();\nstd::advance( it, d );\n</code></pre>\n<p>which is generally linear, but constant when the iterator is a random access iterator.</p>\n<p>Since you probably don't want to do that, you have two options which should help: Either default construct the new container and use <code>swap</code> without invalidating the iterators or put the container into a <code>std::unique_ptr</code> and move that instead.</p>\n<p>The first approach (<code>swap</code>) requires both instances to have the container instance and this might be a bit larger than the simple, single pointer stored inside a <code>std::unique_ptr</code>. When you move your instances around very often, the <code>std::unique_ptr</code>-based approach seems preferable to me, although each access requires one more pointer indirection. Judge (and measure) for yourself what fits best in your case.</p>\n</hr>", "LastActivityDate": "2013-10-26T23:05:34.750", "LastEditorUserId": "2073257", "Id": "19611098", "CommentCount": "15", "CreationDate": "2013-10-26T19:45:06.637", "ParentId": "19611037", "Score": "3", "OwnerUserId": "2073257", "LastEditDate": "2013-10-26T23:05:34.750"}, "19612530": {"PostTypeId": "2", "Body": "<p>I think the implicit guarantee on iterator invalidation holds for the move ctor. That is, the following should work for all containers but <code>std::array</code>:</p>\n<pre><code>template&lt;class Container&gt;\nstruct foo_base\n{\n    Container c;\n    Container::iterator i;\n\n    foo_base(foo_base&amp;&amp; rhs, bool is_end)\n    : c( std::move(rhs.c) )\n    , i( get_init(is_end, rhs.i) )\n    {}\n\n    Container::iterator get_init(bool is_end, Container::iterator ri)\n    {\n        using std::end; // enable ADL\n        return is_end ? end(c) : ri;\n    }\n};\n\ntemplate&lt;class Container&gt;\nstruct foo : private foo_base&lt;Container&gt;\n{\n    foo(foo&amp;&amp; rhs)\n    : foo_base(std::move(rhs), rhs.i == end(rhs.c))\n    {}\n};\n</code></pre>\n<p>The complicated initialization via a base class is necessary as move assignment isn't required to move if the allocator doesn't propagate for move-assignment. The check for the iterator is required as the <code>end()</code> iterator may be invalidated; this check has to be performed before the container is moved. If you can ensure however that the allocator propagates (or otherwise the move-assignment doesn't invalidate iterators for your cases), you can use the simpler version below, replacing the <code>swap</code> with a move-assignment.</p>\n<p>N.B. The sole purpose of the <code>get_init</code> function is to enable ADL. It is possible that <code>foo_base</code> has a member function <code>end</code>, which would disable ADL. The <em>using-declaration</em> stops unqualified lookup to find a possible member function, therefore ADL is always performed. You could as well use <code>std::end(c)</code> and get rid of <code>get_init</code>, if you're comfortable with losing ADL here.</p>\n<p>If it should turn out that there is no such implicit guarantee for the move ctor, there's still the explicit guarantee for <code>swap</code>. For this, you can use:</p>\n<pre><code>template&lt;class Container&gt;\nstruct foo\n{\n    Container c;\n    Container::iterator i;\n\n    foo(foo&amp;&amp; rhs)\n    {\n        using std::end; // enable ADL\n        bool const is_end = (rhs.i == end(rhs.c));\n\n        c.swap( rhs.c );\n\n        i = get_init(is_end, rhs.i);\n    }\n\n    Container::iterator get_init(bool is_end, Container::iterator ri)\n    {\n        using std::end; // enable ADL\n        return is_end ? end(c) : ri;\n    }\n};\n</code></pre>\n<p>However, a swap has some requirements, defined in [container.requirements.general]/7+8:</p>\n<blockquote>\n<p id=\"so_19611037_19612530_0\">The behavior of a call to a container's <code>swap</code> function is undefined unless the objects being swapped have allocators that compare equal or <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> is <code>true</code>\n  [...]\n  Any <code>Compare</code>, <code>Pred</code>, or <code>Hash</code> objects belonging to <code>a</code> and <code>b</code> shall be swappable and shall be exchanged by unqualified calls to non-member <code>swap</code>. If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> is <code>true</code>, then the allocators of <code>a</code> and <code>b</code> shall also be exchanged using an unqualified call to non-member <code>swap</code>. Otherwise, they shall not be swapped, and the behavior is undefined unless\n  <code>a.get_allocator() == b.get_allocator()</code>.</p>\n</blockquote>\n<p>I.e. both containers should (but not have to) have equal allocators.</p>\n<p>Move construction OTOH only requires that no exception is thrown (for allocator-aware containers); the allocator is always moved.</p>\n", "LastActivityDate": "2013-10-28T11:19:50.300", "LastEditorUserId": "420683", "Id": "19612530", "CommentCount": "1", "CreationDate": "2013-10-26T22:18:58.430", "ParentId": "19611037", "Score": "1", "OwnerUserId": "420683", "LastEditDate": "2013-10-28T11:19:50.300"}, "19611037": {"ViewCount": "225", "Body": "<p>I've got a class which holds in it a container, and an iterator into that container. How can I correctly implement the move constructor? I seem to recall that by Standard, you can't rely on the iterators remaining valid after moving (which is so silly). Is there some means by which I can \"update\" the iterator if it was invalidated or something? Or will I have to dynamically allocate the container, move it, and then have the iterators remain valid that way?</p>\n", "AcceptedAnswerId": "19611098", "Title": "Iterator into container which is moved", "CreationDate": "2013-10-26T19:39:52.010", "Id": "19611037", "CommentCount": "23", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-28T11:19:50.300", "Score": "6", "OwnerUserId": "298661", "Tags": "<c++><c++11><iterator>", "AnswerCount": "2"}});