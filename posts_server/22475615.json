post_cb({"bq_ids": {"n4140": {"so_22475615_22477750_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6037}}, "n3337": {"so_22475615_22477750_0": {"length": 19, "quality": 1.0, "section_id": 5805}}, "n4659": {"so_22475615_22477750_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7536}}}, "22477750": {"Id": "22477750", "PostTypeId": "2", "Body": "<p>As to the technical side: It is of course forbidden by the 2011 standard, 5.2.9.11, static cast. Let B  be a base of D:</p>\n<blockquote>\n<p id=\"so_22475615_22477750_0\">If the prvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object of type D. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n<p>On the other hand I'd be surprised if somebody could find an implementation which doesn't just do it, because of the obvious implementations of classes, methods and static casts.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2014-03-18T11:29:01.147", "Score": "1", "CreationDate": "2014-03-18T11:17:25.433", "ParentId": "22475615", "CommentCount": "2", "OwnerUserId": "3150802", "LastEditDate": "2014-03-18T11:29:01.147"}, "22478378": {"Id": "22478378", "PostTypeId": "2", "Body": "<p>Your existing code has undefined behaviour, as stated in the other answers. You can avoid that, if you don't mind some truly horrible code, by destroying the object at <code>baseA</code> and creating a <code>DerivedA</code> at the same location, so the downcast is valid:</p>\n<pre><code>#include &lt;new&gt;\n\nstruct DerivedB : public BaseB\n{\n  DerivedB()\n  {\n    static_assert( sizeof(BaseA) == sizeof(DerivedA), \"same size\" );\n    baseA.~BaseA();\n    ::new(&amp;baseA) DerivedA();\n  }\n  ~DerivedB()\n  {\n    getA().~DerivedA();\n    ::new(&amp;baseA) BaseA();\n  }\n\n    DerivedA&amp; getA() {return *static_cast&lt;DerivedA*&gt;(&amp;baseA);}\n\n    double foo(double z) {return getA().bar(z);} \n};\n</code></pre>\n<p>The destructor restores an object of the original type, so that when the <code>BaseB</code> destructor destroys its <code>baseA</code> member it runs the destructor of the correct type on the object.</p>\n<p>But I would avoid doing this and redesign your classes to solve it another way.</p>\n", "LastActivityDate": "2014-03-18T11:44:06.240", "CommentCount": "3", "CreationDate": "2014-03-18T11:44:06.240", "ParentId": "22475615", "Score": "0", "OwnerUserId": "981959"}, "22475615": {"ViewCount": "383", "Body": "<p>I am interested if it is safe, to <strong>DOWNCAST</strong> (thanks Mike) an instance of a base class to a derived class under certain conditions. I think a sample is the most easy way to explain:</p>\n<pre><code>struct BaseA\n{\n    void foo() const {}     \n    double bar_member;\n    // no virtuals here\n};\n\nstruct DerivedA : public BaseA\n{\n    double bar(double z) {bar_member = z;return bar_member;}\n    // DerivedA does not add ANY member variables to BaseA.\n    // It also does not introduce ANY virtual functions.\n};    \n\nstruct BaseB\n{\n    BaseA baseA;\n};\n\n// add extra functionality to B, to do this,\n// i also need more functionality on baseA.\nstruct DerivedB : public BaseB\n{\n    // is this \"safe\"? since BaseA and DerivedA\n    // should have the same memory layout?!?\n    DerivedA&amp; getA() {return *static_cast&lt;DerivedA*&gt;(&amp;baseA);}\n\n    double foo(double z) {return getA().bar(z);} \n};\n\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv)\n{\n    DerivedB b;\n    // compiles and prints expected result\n    std::cout &lt;&lt; b.foo(argc) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In my case, the classes BaseA and BaseB implement some kind of view concept. However, they also hold all the data members required to add further functionality in the derived classes. I know that I could implement the view to hold only a reference to the class providing the functionality. However, that would comes with some drawbacks:</p>\n<ul>\n<li>I need to rewrite the whole interface for the view classes.</li>\n<li>In my case, the Derived classes possesses an extra template argument (a callback type), which I want to have erased in the view. Hence, the view must not hold a direct reference to the classes providing functionality. </li>\n</ul>\n<p>I tested my code, it works, however, I don't really trust the approach. And yes, I know I could achieve some of this with virtuals etc. but it is <strong>really</strong> performance critical...</p>\n<p>Any ideas, hints, are welcome</p>\n<p>Martin</p>\n<p>for the interested people:\ni changed my design the following way:</p>\n<pre><code>struct DerivedB : public BaseB\n{\n    // encapsule the required extended functionality of BaseA member\n    struct OperateOnBaseA\n    {\n         OperateOnBaseA(BaseA&amp; a);\n         double dosomething(double);\n    };\n\n    OperateOnBaseA a_extension;\n\n    DerivedB() :a_extension(baseA) {}\n\n    double foo(double z) {return a_extension.dosomething();} \n}; \n</code></pre>\n", "AcceptedAnswerId": "22477750", "Title": "Downcasting instance of base class to derived class", "CreationDate": "2014-03-18T09:49:50.720", "Id": "22475615", "CommentCount": "5", "LastEditDate": "2014-03-21T11:45:11.630", "PostTypeId": "1", "LastEditorUserId": "2160256", "LastActivityDate": "2014-03-21T11:45:11.630", "Score": "0", "OwnerUserId": "2160256", "Tags": "<c++><casting><memory-layout>", "AnswerCount": "3"}, "22477757": {"Id": "22477757", "PostTypeId": "2", "Body": "<p>I don't find your approad clean enough for what you're trying to do. Assuming there's a \"data source type\" <code>SourceA</code> and a \"data view type\" <code>ViewB</code>, I would go more like this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass SourceA_base\n{\nprotected:\n    T data;\npublic:\n    using value_type = T;\n    SourceA_base(T&amp;&amp; a) : data(std::move(a)) { }\n    SourceA_base(T const&amp; a) : data() { }\n    void foo() const {}\n};\n\ntemplate&lt;typename T&gt;\nclass SourceA : public SourceA_base&lt;T&gt;\n{\n    using B = SourceA_base&lt;T&gt;;\npublic:\n    using B::B;\n    T bar(T z) { return B::data = z; }\n};\n\ntemplate&lt;typename U&gt;\nclass ViewB_base\n{\nprotected:\n    U&amp;&amp; source;\npublic:\n    using value_type = typename std::remove_reference&lt;U&gt;::type::value_type;\n    ViewB_base(U&amp;&amp; a) : source(std::forward&lt;U&gt;(a)) { }\n};\n\ntemplate&lt;typename U&gt;\nclass ViewB : public ViewB_base&lt;U&gt;\n{\n    using B = ViewB_base&lt;U&gt;;\n    using T = typename B::value_type;\npublic:\n    using B::B;\n    T foo(T z) { return B::source.bar(z); }\n};\n\nint main ()\n{\n    using S = SourceA&lt;double&gt;;\n    S a{3.14};\n    ViewB&lt;S&amp;&gt; b{a};\n    std::cout &lt;&lt; b.foo(6.28) &lt;&lt; std::endl; // compiles and prints expected result\n    std::cout &lt;&lt; ViewB&lt;S&gt;{S{2}}.foo(4) &lt;&lt; std::endl; // still works\n}\n</code></pre>\n<p>That is, all (source/view) types are templated, views contain references, and there are no downcasts. On your reservations for the use of references:</p>\n<ul>\n<li>Re-writing the whole interface: No need now, thanks to templates.</li>\n<li>Erasing callback types: First, type erasure and performance critical applications are not always good friends. Second, you'd better have the callback erase its own underlying type(s), not the view erase the type of the callback. Each class should do its own job. Or, don't erase types and make them template parameters.</li>\n</ul>\n<p>I used rvalue-references so that the whole thing works for temporaries as well, as shown in my second example. Maybe constructors are not always complete/correct here. e.g. for <code>const</code> references; I reality would have fully templated constructors (accepting universal references), but to make this cooperate with one-argument implicitly defined copy/move constructors is a bit trickier (needs type traits and <code>enable_if</code>) and I only wanted to hightlight the idea here.</p>\n<p>You may also consider using tuples to hold data, taking advantage of their empty base optimization.</p>\n<p>As for your original question, this downcast is something I would never do; for the technical side, see Peter Schneider's answer.</p>\n", "LastEditorUserId": "2644390", "LastActivityDate": "2014-03-18T11:53:20.787", "Score": "0", "CreationDate": "2014-03-18T11:17:44.960", "ParentId": "22475615", "CommentCount": "1", "OwnerUserId": "2644390", "LastEditDate": "2014-03-18T11:53:20.787"}});