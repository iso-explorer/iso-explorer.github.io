post_cb({"41516179": {"ParentId": "41515989", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The rule GCC is enforcing is in [basic.scope.class]:</p>\n<blockquote>\n<p id=\"so_41515989_41516179_0\">2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p>The standard says violating this doesn't require a diagnostic, so it's possible that both GCC and Clang are conforming, because (if GCC is right) the code is not valid, but the compiler is not required to diagnose it.</p>\n<p>The purpose of this rule is so that names used in a class always mean the same thing, and re-ordering members doesn't alter how they are interpreted e.g.</p>\n<pre><code>struct N { };\n\nstruct S {\n  int array[sizeof(N)];\n\n  struct N { char buf[100]; };\n};\n</code></pre>\n<p>In this example the name <code>N</code> changes meaning, and reordering the members would change the size of <code>S::array</code>. When <code>S::array</code> is defined <code>N</code> refers to the type <code>::N</code> but in the completed scope of <code>S</code> it refers to <code>S::N</code> instead. This violates the rule quoted above.</p>\n<p>In your example the name <code>Foo</code> changes in a far less dangerous way, because it still refers to the same type, however strictly speaking it does change from referring to the declaration of <code>::Foo</code> to the declaration of <code>S::Foo</code>. The rule is phrased in terms of referring to declarations, so I think GCC is right.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "4342498", "LastEditDate": "2017-01-07T01:04:06.823", "Id": "41516179", "Score": "7", "CreationDate": "2017-01-06T23:45:17.923", "LastActivityDate": "2017-01-07T01:04:06.823"}, "bq_ids": {"n4140": {"so_41515989_41516179_0": {"section_id": 7070, "quality": 1.0, "length": 15}}, "n3337": {"so_41515989_41516179_0": {"section_id": 6814, "quality": 1.0, "length": 15}}, "n4659": {"so_41515989_41516179_0": {"section_id": 8568, "quality": 1.0, "length": 15}}}, "41515989": {"CommentCount": "2", "AcceptedAnswerId": "41516179", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-01-06T23:24:52.393", "LastActivityDate": "2017-01-07T01:04:06.823", "LastEditDate": "2017-05-23T11:45:46.413", "ViewCount": "196", "FavoriteCount": "2", "Title": "May I declare a member type alias to a type in a surrounding scope, using the same name?", "Id": "41515989", "Score": "8", "Body": "<p>I want a struct to contain a type alias to another type for metaprogramming purposes:</p>\n<pre><code>struct Foo {};\n\nstruct WithNestedTypeAlias {\n    using Foo = Foo;\n};\n</code></pre>\n<p>Then I can do stuff like <code>WithNestedTypeAlias::Foo</code> in a template etc.</p>\n<p>As I understand, this type alias is valid because it does not change the meaning of the <code>Foo</code> type. Clang compiles this happily.</p>\n<p>However, GCC complains:</p>\n<pre><code>test-shadow-alias.cpp:4:20: error: declaration of \u2018using Foo = struct Foo\u2019 [-fpermissive]\n     using Foo = Foo;\n                    ^\ntest-shadow-alias.cpp:1:8: error: changes meaning of \u2018Foo\u2019 from \u2018struct Foo\u2019 [-fpermissive]\n struct Foo {};\n        ^\n</code></pre>\n<p>Now I'm confused because I'm explicitly not changing the meaning of <code>Foo</code> from <code>struct Foo</code>.</p>\n<p>What is the correct behaviour for C++14? I know I can work around this by renaming the <code>struct Foo</code>, but I'd like to understand whether GCC's error is correct here.</p>\n<p>Notes:</p>\n<ul>\n<li><p>Tested with clang++ 3.8 and gcc 5.4, but <a href=\"https://godbolt.org/g/Pbc41X\" rel=\"nofollow noreferrer\">Godbolt suggests this hasn't changed in more recent GCC versions</a>.</p></li>\n<li><p>I looked at <a href=\"https://stackoverflow.com/q/26681873/1521179\">Interaction between decltype and class member name shadowing an external name</a>, where the name of a <em>variable</em> may refer to either a variable in the outer scope or to a class member. In contrast, my question here is about a type alias. There is no ambiguity since <code>Foo</code> always refers to <code>::Foo</code> within the class scope. I don't see how the answer there applies to my problem.</p></li>\n<li><p>This is probably due to a misunderstanding of what type aliases actually are.</p></li>\n</ul>\n", "Tags": "<c++><g++><c++14><clang++><type-alias>", "OwnerUserId": "1521179", "AnswerCount": "1"}});