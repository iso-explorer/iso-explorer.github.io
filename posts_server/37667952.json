post_cb({"37668348": {"ParentId": "37667952", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If you want the order of evaluation to be in line with the order of the arguments for <code>doSomething</code> you can expand the arguments into an initializer:</p>\n<pre><code>template &lt;typename ...Args, std::size_t ...N&gt;\nvoid doSomethingImpl(std::index_sequence&lt;N...&gt;, \n  std::tuple&lt;Args...&gt; &amp;&amp; args)\n{\n  using std::get;\n  int t_[] = { 0, (static_cast&lt;void&gt;(oneCommand(\n    get&lt;N&gt;(std::forward&lt;decltype(args)&gt;(args)), N)), 0)... };\n  static_cast&lt;void&gt;(t_); // \"use\" t_ to silence warnings \n}\n\ntemplate &lt;typename ...Args&gt;\nvoid doSomething(Args &amp;&amp;... args)\n{\n  doSomethingImpl(std::make_index_sequence&lt;sizeof...(Args)&gt;(),\n    std::forward_as_tuple(std::forward&lt;Args&gt;(args)...));\n}\n</code></pre>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2016-06-06T23:41:32.763", "Id": "37668348", "Score": "1", "CreationDate": "2016-06-06T23:30:59.937", "LastActivityDate": "2016-06-06T23:41:32.763"}, "37667994": {"ParentId": "37667952", "CommentCount": "6", "Body": "<p>You could add a helper function:</p>\n<pre><code>template &lt;typename ...Args&gt;\nvoid doSomething(Args &amp;&amp;... args)\n{\n    doSomethingImpl(std::make_index_sequence&lt;sizeof...(Args)&gt;(),\n                    std::forward&lt;Args&gt;(args)...);\n}\n\ntemplate &lt;typename ...Args, std::size_t ...N&gt;\nvoid doSomethingImpl(std::index_sequence&lt;N...&gt;, Args &amp;&amp;... args)\n{\n    bar(oneCommand(std::forward&lt;Args&gt;(args), N)...);\n}\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "37667994", "Score": "4", "CreationDate": "2016-06-06T22:49:43.997", "LastActivityDate": "2016-06-06T22:49:43.997"}, "37668941": {"ParentId": "37667952", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You might utilize list-initializatio in conjunction with a comma operator to sequence the function calls:</p>\n<pre><code>template&lt;class T&gt;\nvoid doSomethingWithOneArg(const T&amp;, std::size_t counter)\n{\n    std::cout &lt;&lt; counter &lt;&lt; \": \" &lt;&lt; typeid(T).name() &lt;&lt; '\\n';\n}\n\ntemplate&lt;class ... Args&gt;\nvoid doSomething(Args ... args)\n{\n    std::size_t counter = 0;\n    std::initializer_list&lt;int&gt;{ ( doSomethingWithOneArg(args, counter++), 0) ... };\n}\n\nint main() {\n    doSomething(char(0), int(0), long(0));\n}\n</code></pre>\n<p><em>8.5.4 List-initialization (N4296)</em></p>\n<blockquote>\n<p id=\"so_37667952_37668941_0\"><em>4</em>\n  Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are evaluated in the order in which they appear. That is,\n  every value computation and side effect associated with a given\n  initializer-clause is sequenced before every value computation and\n  side effect associated with any initializer-clause that follows it in\n  the comma-separated list of the initializer-list.</p>\n</blockquote>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2016-06-07T09:38:47.873", "Id": "37668941", "Score": "1", "CreationDate": "2016-06-07T00:57:32.307", "LastActivityDate": "2016-06-07T09:38:47.873"}, "bq_ids": {"n4140": {"so_37667952_37668941_0": {"section_id": 3326, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_37667952_37668941_0": {"section_id": 3196, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_37667952_37668941_0": {"section_id": 4092, "quality": 0.9428571428571428, "length": 33}}}, "37667952": {"CommentCount": "6", "ViewCount": "101", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2016-06-06T22:44:53.113", "LastActivityDate": "2016-06-07T09:38:47.873", "Title": "C++11: Parameter Pack Expansion Counter", "AcceptedAnswerId": "37667994", "LastEditDate": "2016-06-06T22:46:53.277", "Id": "37667952", "Score": "0", "Body": "<p>I'd like to increment a counter for each parameter during parameter pack expansion.\nHere is some pseudo code of what I want to achieve:</p>\n<pre><code>    template&lt;class ... Args&gt;\n    void doSomething(Args ... _args)\n    {\n        std::size_t counter = 0;\n        bar(doSomethingWithOneArg(_args, counter++)...);\n    }\n</code></pre>\n<p>The problem with this code is, that while the order of the <code>Args</code>is preserved, the order in which the function parameters are evaluated is not defined, i.e. on <code>clang</code> the order in which the counter expressions are evaluated is the same as the order of <code>Args</code> while in <code>gcc</code> it is reversed. What is a portable, standard way of achieving this?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><templates><c++11><parameter-passing>", "OwnerUserId": "300713", "AnswerCount": "3"}});