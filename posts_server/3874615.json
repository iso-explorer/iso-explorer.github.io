post_cb({"3874745": {"Id": "3874745", "PostTypeId": "2", "Body": "<p>\u00a75.3.4/10:</p>\n<blockquote>\n<p id=\"so_3874615_3874745_0\">A new-expression passes the amount of\n  space requested to the allocation\n  function as the first argument of type\n  <code>std::size_t</code>. That argument shall be\n  no less than the size of the object\n  being created; it may be greater than\n  the size of the object being created\n  only if the object is an array. For\n  arrays of char and unsigned char, the\n  difference between the result of the\n  new-expression and the address\n  returned by the allocation function\n  shall be an integral multiple of the\n  most stringent alignment requirement\n  (3.9) of any object type whose size is\n  no greater than the size of the array\n  being created.</p>\n</blockquote>\n<p>This allows using char arrays allocated with new for placement-construction of\nappropriately sized objects of other types. The pre-allocated buffer has to be allocated on the heap. Otherwise you might run into <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"nofollow\">alignment</a> problems. </p>\n", "LastEditorDisplayName": "user405725", "OwnerDisplayName": "user405725", "LastActivityDate": "2012-11-12T01:00:46.443", "Score": "0", "CreationDate": "2010-10-06T16:26:20.747", "ParentId": "3874615", "CommentCount": "0", "LastEditDate": "2012-11-12T01:00:46.443"}, "3874709": {"Id": "3874709", "PostTypeId": "2", "Body": "<p><code>T</code> may be aligned different from a char.</p>\n<p>also, itanium abi (for example) specifies cookies for non-pod array, so it knows how many elements to walk across at deletion (to call the destructors). the allocation via new is like this (iirc):</p>\n<pre><code>size_t elementCount;\n// padding to get native alignment for 1st element\nT elements[elementCount];\n</code></pre>\n<p>so the allocation for a 16 byte aligned object is:</p>\n<pre><code>size_t elementCount; // 4\nchar padding[16 - sizeof(elementCount)];\nT elements[elementCount]; // naturally aligned\n</code></pre>\n<p>char can be aligned to 1 on some systems so... you see where the misalignment and size issues fit in. builtin types don't need their dtors called, but everything else does.</p>\n", "LastActivityDate": "2010-10-06T16:22:41.627", "CommentCount": "3", "CreationDate": "2010-10-06T16:22:41.627", "ParentId": "3874615", "Score": "0", "OwnerUserId": "191596"}, "3874704": {"Id": "3874704", "PostTypeId": "2", "Body": "<p>A <code>T x[size]</code> array will always fit exactly into <code>size * sizeof(T)</code> bytes, meaning that <code>char buffer[size*sizeof(T)]</code> is always precisely enough to store such an array. </p>\n<p>The problem in that answer, as I understood it, was that your <code>char</code> array is not guaranteed to be properly <em>aligned</em> for storing the object of type <code>T</code>. Only <code>malloc</code>-ed/<code>new</code>-ed buffers are guaranteed to be aligned properly to store any standard data type of smaller or equal size (or data type composed of standard data types), but if you just explicitly declare a <code>char</code> array (as a local object or member subobject), there's no such guarantee.</p>\n<p>Alignment means that on some platform it might be strictly (or not so strictly) required to allocate, say, all <code>int</code> objects on, say, a 4-byte boundary. E.g. you can place an <code>int</code> object at the address <code>0x1000</code> or <code>0x1004</code>, but you cannot place an <code>int</code> object at the address<code>0x1001</code>. Or, more precisely, you can, but any attempts to access this memory location as an object of type <code>int</code> will result in a crash. </p>\n<p>When you create an arbitrary <code>char</code> array, the compiler does not know what you are planning to use it for. It can decide to place that array at the address <code>0x1001</code>. For the above reason, a naive attempt to create an <code>int</code> array in such an unaligned buffer will fail.</p>\n<p>The alignment requirements on some platform are strict, meaning that any attempts to work with misaligned data will result in run-time failure. On some other platforms they are less strict: the code will work, but the performance will suffer. </p>\n<p>The need for the proper alignment sometimes means that when you want to create an <code>int</code> array in an arbitrary <code>char</code> array, you might have to <em>shift</em> the beginning of an <code>int</code> array forward from the beginning of the <code>char</code> array. For example, if the <code>char</code> array resides at <code>0x1001</code>, you have no choice but to start your constructed-in-place <code>int</code> array from the address <code>0x1004</code> (which is the <code>char</code> element with the index 3). In order to accommodate the tail portion of the  shifted <code>int</code> array, the <code>char</code> array would have to be 3 bytes larger than what the <code>size * sizeof(T)</code> evaluates to. This is why the original size might not be enough.</p>\n<p>Generally, if your <code>char</code> array is not aligned in any way, you will really need an array of <code>size * sizeof(T) + A - 1</code> bytes to accommodate an aligned (i.e. possibly shifted) array of objects of type <code>T</code> that must be aligned at A-byte boundary.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-10-06T16:39:43.187", "Score": "13", "CreationDate": "2010-10-06T16:22:20.787", "ParentId": "3874615", "CommentCount": "11", "OwnerUserId": "187690", "LastEditDate": "2010-10-06T16:39:43.187"}, "3874773": {"Id": "3874773", "PostTypeId": "2", "Body": "<p>On some systems, memory access must be \"aligned\". For the sake of simplicity, this means that the address must be a multiple of some integer called the \"alignemnt requirement\" of the type (see 3.9/5 of the C++ standard).</p>\n<p>So, for example, suppose <code>sizeof(int) == 4</code>:</p>\n<pre><code>int *intarray = new int[2];        // 8 bytes\nchar *charptr = (char *)intarray;  // legal reinterpret_cast\ncharptr += 1;                      // still 7 bytes available\n*((int*)charptr) = 1;              // BAD!\n</code></pre>\n<p>The address of charptr is not a multiple of 4, so if <code>int</code> has an alignment requirement of 4 on your platform, then the program has undefined behavior.</p>\n<p>Similarly:</p>\n<pre><code>char ra[8];\nint *intptr = reinterpret_cast&lt;int*&gt;(ra);\nintptr[0] = 1;  // BAD!\n</code></pre>\n<p>The address of <code>ra</code> is not guaranteed to be a multiple of 4.</p>\n<p>This is OK, though:</p>\n<pre><code>char ra = new char[8];\nint *intptr = reinterpret_cast&lt;int*&gt;(ra);\nintptr[0] = 1;  // NOT BAD!\n</code></pre>\n<p>because <code>new</code> guarantees that char array allocations are aligned for any type that is small enough to fit in the allocation (5.3.4/10).</p>\n<p>Moving away from automatics, it's easy to see why the compiler is free not to align data members. Consider:</p>\n<pre><code>struct foo {\n    char first[1];\n    char second[8];\n    char third[3];\n};\n</code></pre>\n<p>If the standard guaranteed that <code>second</code> was 4-aligned (still assuming that <code>int</code> is 4-aligned), then the size of this struct would have to be at least 16 (and its alignment requirement at least 4). As the standard is actually written, a compiler is permitted to give this struct size 12, with no padding and no alignment requirement.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2010-10-06T16:56:29.853", "Score": "0", "CreationDate": "2010-10-06T16:29:50.817", "ParentId": "3874615", "CommentCount": "4", "OwnerUserId": "13005", "LastEditDate": "2010-10-06T16:56:29.853"}, "3874788": {"Id": "3874788", "PostTypeId": "2", "Body": "<p><code>char x[size*sizeof(T)];</code> might not take <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"nofollow\">alignment</a> into account, where as T x[size]; will. <a href=\"http://www.songho.ca/misc/alignment/dataalign.html\" rel=\"nofollow\">alignment(2)</a> can also be very important when working with SSE types, that require 16 byte alignment</p>\n", "LastActivityDate": "2010-10-06T16:31:10.550", "CommentCount": "0", "CreationDate": "2010-10-06T16:31:10.550", "ParentId": "3874615", "Score": "0", "OwnerUserId": "255049"}, "bq_ids": {"n4140": {"so_3874615_3874745_0": {"length": 52, "quality": 0.9122807017543859, "section_id": 6092}}, "n3337": {"so_3874615_3874745_0": {"length": 52, "quality": 0.9122807017543859, "section_id": 5859}}, "n4659": {"so_3874615_3874745_0": {"length": 53, "quality": 0.9298245614035088, "section_id": 7588}}}, "3874615": {"ViewCount": "796", "Body": "<p>In this <a href=\"https://stackoverflow.com/questions/3873625/i-need-c-array-class-template-which-is-fixed-size-stack-based-and-doesnt-req/3873706#3873706\">I need C++ array class template, which is fixed-size, stack-based and doesn't require default constructor</a> answer I posted a piece of code, that is using placement new with char array. For me, this is something absolutely normal. But according to comments this code is wrong.</p>\n<p>Can anyone explain in more detail?</p>\n<p>Specifically what can go wrong with the array. What I understand from the comments is that <code>T x[size];</code> might not fit into <code>char x[size*sizeof(T)];</code>. I don't believe this is true.</p>\n<p>EDIT:</p>\n<p>I'm just more and more confused. I know what alignment is in case of structures. Yes, when you have a structure the attributes start on different offsets then you might think.</p>\n<p>OK, now we are back to arrays. You are telling me that <code>T x[size];</code> is the same size as <code>char x[size*sizeof(T)];</code>, yet I cannot access the char array as T array because there might be some alignment. How can there be alignment when the arrays have the same size?</p>\n<p>EDIT 2:</p>\n<p>OK I finally get it, it may start on a wrong address.</p>\n<p>EDIT 3:</p>\n<p>Thx everyone, you can stop posting :-) Phew, this total blew my mind. I just never realized this was possible.</p>\n", "AcceptedAnswerId": "3874704", "Title": "Placement new issue", "CreationDate": "2010-10-06T16:13:42.340", "Id": "3874615", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:43.127", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-12T01:00:46.443", "Score": "8", "OwnerUserId": "211659", "Tags": "<c++>", "AnswerCount": "5"}});