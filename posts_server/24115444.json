post_cb({"24115444": {"CommentCount": "3", "ViewCount": "799", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2014-06-09T07:18:06.477", "LastActivityDate": "2014-06-09T08:08:30.660", "Title": "Auto deduced return types in forward declaration and mixing with old function syntax", "AcceptedAnswerId": "24115958", "LastEditDate": "2014-06-09T08:02:18.130", "Id": "24115444", "Score": "7", "Body": "<h2>Intro</h2>\n<p>In C++11 it's fine to declare a function like</p>\n<pre><code>auto times2(double num) -&gt; double; // A\n</code></pre>\n<p>and define it like </p>\n<pre><code>double times2(double num) { // B\n    return num*2;\n}\n</code></pre>\n<p>The pair <code>A, B</code> can also be mixed the other way around. </p>\n<p>C++14 introduces a third way </p>\n<pre><code>auto times2(double num) { // C\n    return num;\n}\n</code></pre>\n<h2>Q</h2>\n<ol>\n<li>Can style <code>C</code> be <strong>mixed</strong> with <code>A / B</code> in a <strong>declaration/definition</strong> pair ?</li>\n<li><p>Can <code>C</code> <strong>stand alone as a signature</strong> (when the body of the function is not yet provided) ? </p>\n<pre><code>// waiting for the definition to provide info on return type\nauto times2(double); \n</code></pre></li>\n</ol>\n", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "2567683", "AnswerCount": "1"}, "24115958": {"ParentId": "24115444", "PostTypeId": "2", "CommentCount": "2", "Body": "<h3>Mixing the new- and old-school</h3>\n<blockquote>\n<p id=\"so_24115444_24115958_0\"><code>7.1.6.4p13</code> <strong><code>auto</code> specifier</strong> <code>[dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_24115444_24115958_2\">Redeclarations or specializations of a function or function template with a declared return type that uses a placeholder type shall also use that placeholder, not a deduced type.</p>\n</blockquote>\n</blockquote>\n<p>The above quotation makes it ill-formed to mix the <em>new</em> with the <em>old</em>.</p>\n<p>More specifically any such mixing introduces an ambiguating since the only difference in the two declarations is the <em>return-type</em> of the function; two declarations where one uses <code>auto</code> and the other a non-deduced type <code>T</code> are, in other words, not referring to the same function.</p>\n<pre><code>auto f ();\nauto f () { return 123; } // legal, return type is `int`\n\nauto g ();\nauto g () -&gt; int;         // ill-formed, an invalid overload of `g` introduced\n\nint  h ();\nauto h ();                // ill-formed, an invalid overload of `h` introduced\n</code></pre>\n<hr>\n<h3>Is a function declaration using C++14's return-type deduction equivalent of a forward declaration?</h3>\n<p>There are rules related to <em>automatic return-type deduction</em> in <em>C++14</em> that states that a function which yet hasn't had its return-type deduced is not usable in a context where such is required, that means that (<em>A</em>) below is not equivalent of an old-school declaration (ie. that a function can be used without yet having the definition).</p>\n<pre><code>auto foobar (double); // (A)\n\nint main () {\n  auto ret = foobar(3.14f); // ill-formed, return type is not known (yet)\n}\n\n...\n</code></pre>\n<blockquote>\n<p id=\"so_24115444_24115958_3\"><code>7.1.6.4p9</code> <strong><code>auto</code> specifier</strong> <code>[dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_24115444_24115958_5\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression the program is ill-formed. <em>...</em></p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>Are you saying that a declaration where the return-type is <code>auto</code> is... useless?</h3>\n<p>No, far from it, there are cases where a forward declaration certainly is required and contexts where the return-type mustn't be known until a later time, such as inside a template.</p>\n<pre><code>template&lt;class T&gt;\nauto foobar (T);\n\ntemplate&lt;class T&gt;\nauto barbaz (T val) { return foobar (val); }\n\ntemplate&lt;class T&gt;\nauto foobar (T val) { return      val * 2; }\n\nint main () {\n  barbaz (1234); // return-type is int\n  barbaz (3.1f); // return-tupe is float\n}\n</code></pre>\n<p>Inside <code>barbaz</code> we must not know the return-type of <code>foobar</code> until we have actually instantiated <code>barbaz</code>, but without the a forward declaration of <code>auto foobar(T)</code> we couldn't refer to such name inside our template.</p>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-09T08:08:30.660", "Id": "24115958", "Score": "6", "CreationDate": "2014-06-09T07:54:39.570", "LastActivityDate": "2014-06-09T08:08:30.660"}, "bq_ids": {"n4140": {"so_24115444_24115958_4": {"section_id": 5455, "quality": 1.0, "length": 10}, "so_24115444_24115958_5": {"section_id": 5455, "quality": 1.0, "length": 10}, "so_24115444_24115958_2": {"section_id": 5457, "quality": 1.0, "length": 16}, "so_24115444_24115958_1": {"section_id": 5457, "quality": 1.0, "length": 16}}, "n3337": {"so_24115444_24115958_4": {"section_id": 3191, "quality": 0.6, "length": 6}, "so_24115444_24115958_5": {"section_id": 3191, "quality": 0.6, "length": 6}}, "n4659": {"so_24115444_24115958_4": {"section_id": 6881, "quality": 1.0, "length": 10}, "so_24115444_24115958_5": {"section_id": 6881, "quality": 1.0, "length": 10}, "so_24115444_24115958_2": {"section_id": 6883, "quality": 1.0, "length": 16}, "so_24115444_24115958_1": {"section_id": 6883, "quality": 1.0, "length": 16}}}});