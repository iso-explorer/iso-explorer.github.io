post_cb({"bq_ids": {"n4140": {"so_19529241_19532050_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6975}, "so_19529241_19532050_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5861}}, "n3337": {"so_19529241_19532050_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5631}, "so_19529241_19532050_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6721}}, "n4659": {"so_19529241_19532050_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 8474}}}, "19532050": {"Id": "19532050", "PostTypeId": "2", "Body": "<p><code>Base::Foo</code> and <code>Derived::Foo</code> are indeed the same <em>type</em>, a class is just a <em>compound type</em>(from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>3.9.2</code>) and we would not expect a <em>type</em> inherited from a <em>base class</em> to be a different type in the <em>derived class</em>. For example if <code>Base</code> contained:</p>\n<pre><code>typedef int newType1 ;\n</code></pre>\n<p>as long as <code>Derived</code> did not redeclare <code>newType1</code> then we would expect <code>Base::newType1</code> and <code>Derived::newType1</code> to be the same <em>type</em> and a <em>nested class</em> is no different. If we refer to the draft standard section <code>9.2</code> <em>Class members</em> paragraph <em>1</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19529241_19532050_0\">[...]<strong>Members of a class are</strong> data members, member functions (9.3), <strong>nested types</strong>, and\n  enumerators. Data members and member functions are static or non-static; see 9.4. <strong>Nested types are\n  classes (9.1, 9.7) and enumerations (7.2) defined in the class, and arbitrary types declared as members by use of a typedef declaration (7.1.3)</strong>.</p>\n</blockquote>\n<p>That confirms that intuition <em>nested classes</em> are just <em>types</em>(and also members), for completeness sake section <code>9.7</code> referenced above is the <em>nested class</em> section and from section <code>10</code> <em>Derived classes</em> paragraph <em>1</em> we see:</p>\n<blockquote>\n<p id=\"so_19529241_19532050_1\">[...]Unless redeclared in the derived class, members of a base class are also considered to be members of the derived class.[...]</p>\n</blockquote>\n<p>Since they are the same type the <em>catch</em> will work fine.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-10-24T22:12:26.403", "Score": "2", "CreationDate": "2013-10-23T03:05:23.227", "ParentId": "19529241", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-10-24T22:12:26.403"}, "19529346": {"Id": "19529346", "PostTypeId": "2", "Body": "<p><code>Derived::Foo</code> is just accessing <code>Base::Foo</code>, therefore these are just two ways to refer to the same type. You can easily check it with <a href=\"http://en.cppreference.com/w/cpp/types/is_same\" rel=\"noreferrer\"><code>std::is_same</code></a>:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct Base\n{\n    class Foo {};\n};\n\nstruct Derived : Base {};\n\nstatic_assert( std::is_same&lt; Base::Foo, Derived::Foo &gt;::value, \"Oops\" );\n\nint main()\n{\n    try {\n        throw Derived::Foo();\n    }\n    catch( const Base::Foo&amp; ) {}\n}\n</code></pre>\n<p>As you can see, this also means throwing it by one name and catching it by the other works as well.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/804689622d87914b\" rel=\"noreferrer\"><strong>Live example</strong></a></p>\n", "LastActivityDate": "2013-10-22T22:13:40.473", "CommentCount": "0", "CreationDate": "2013-10-22T22:13:40.473", "ParentId": "19529241", "Score": "10", "OwnerUserId": "2073257"}, "19529241": {"ViewCount": "807", "Body": "<p>Say I have these classes:</p>\n<pre><code>class Base\n{\n    public:\n\n        class Foo { ... };\n\n        ...\n};\n</code></pre>\n<p>Then another class derives from the base:</p>\n<pre><code>class Derived : public Base\n{\n    // no mention or redefinition of nested class \"Foo\" anywhere in \"Derived\"\n};\n</code></pre>\n<p>Does this mean we now have a distinct <code>Derived::Foo</code>, or is <code>Derived::Foo</code> the exact same as <code>Base::Foo</code>?</p>\n<p>Here is a twist on this scenario:  what if someone throws an instance of <code>Derived::Foo</code>?  Would it be caught in this scenario:</p>\n<pre><code>catch ( const Base::Foo &amp;ex )\n{\n    // would this also catch an instance of Derived::Foo?\n}\n</code></pre>\n", "AcceptedAnswerId": "19532050", "Title": "When inheriting from a base class, what happens with nested classes?", "CreationDate": "2013-10-22T22:04:14.213", "Id": "19529241", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-10-24T02:52:53.417", "LastEditorUserId": "1708801", "LastActivityDate": "2013-10-24T22:12:26.403", "Score": "9", "OwnerUserId": "13022", "Tags": "<c++><inheritance><try-catch><nested-class>", "AnswerCount": "2"}});