post_cb({"bq_ids": {"n4140": {"so_48002450_48002763_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 224}}, "n3337": {"so_48002450_48002763_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}}, "n4659": {"so_48002450_48002763_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 232}}}, "48002763": {"Id": "48002763", "PostTypeId": "2", "Body": "<p>I'm afraid the book is not painting the complete picture (and it's a bit aged). Yes, <code>foo(member)</code> is a function call that is dependent on the template parameter. But the specific way in which functions are looked up in templates is described in the C++ standard at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.dep.candidate\" rel=\"nofollow noreferrer\">[temp.dep.candidate]</a>:</p>\n<blockquote>\n<p id=\"so_48002450_48002763_0\">For a function call where the postfix-expression is a dependent name,\n  the candidate functions are found using the usual lookup rules\n  ([basic.lookup.unqual], [basic.lookup.argdep]) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup, only function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces ([basic.lookup.argdep]), only function declarations found in either\n  the template definition context or the template instantiation context\n  are found.</li>\n</ul>\n</blockquote>\n<p><code>foo</code>'s overloads can be looked up in one of two ways. By direct unqualified lookup, and by <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">argument dependent lookup</a> (aka ADL). Simple unqualified lookup considers only the names that are known at the point of the template definition. Since you only declared <code>foo(double)</code>, that is the only overload found at the point of the template definition.</p>\n<p>At the point of instantiation, the compiler <em>will</em> try to do ADL to find more <code>foo</code>'s, but fundamental types don't contribute to ADL. <code>int</code> cannot be used to find <code>foo(int)</code>. So the compiler can do only one thing, convert the integer to a double, and call <code>foo(double)</code>.</p>\n<p>If you want to test your compilers ADL, you just need to add a simple user defined type and overload. For instance:</p>\n<pre><code>enum E{};\nE foo(E) {\n  cout &lt;&lt; \"foo E is called\\n\";\n  return {};\n}\n\nint main() {\n    Test&lt;E&gt; fi;\n    fi.fun1();\n    fi.fun2(); \n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-28T08:18:57.243", "Score": "3", "CreationDate": "2017-12-28T06:37:30.037", "ParentId": "48002450", "CommentCount": "1", "OwnerUserId": "817643", "LastEditDate": "2017-12-28T08:18:57.243"}, "48002450": {"ViewCount": "36", "Body": "<p>In Chapter 7 of \"Inside the C++ Object Model,\" it was written that the resolution of a nomember name depends on whether the use of name is related to \"the type of parameter used to instantiate the template.\"\nI write a test:</p>\n<pre><code>/// -------------Test.h---------------\n#ifndef TEST_H\n#define TEST_H\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nextern double foo(double t);\n\ntemplate &lt;typename T&gt;\nclass Test {\n    public:\n        void fun1() {\n            member = foo(val);\n        }\n        T fun2() {\n            return foo(member);\n        }\n    private:\n        int val;\n        T member;\n};\n\n#endif\n</code></pre>\n<p>and</p>\n<pre><code>/// -------------test1.cc-------------\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ndouble foo(double t) {\n    cout &lt;&lt; \"foo doule is called\" &lt;&lt; endl;\n    return t;\n}\n\nint foo(int t) {\n    cout &lt;&lt; \"foo int is called\" &lt;&lt; endl;\n    return t;\n}\n-------------test.cc--------------\n#include \"Test.h\"\n\nextern int foo(int t);\n\nint main() {\n    Test&lt;int&gt; fi;\n    fi.fun1();\n    fi.fun2();\n    return 0;\n}\n</code></pre>\n<p>I expect  \"foo double is called\\n\n           foo int is called\", \nbut I got \"foo double is called\\n\n           foo double is called\".\nMy g++ version is bellow. I'll be appreciate it if you can help me.</p>\n<p><a href=\"https://i.stack.imgur.com/7Yt7G.jpg\" rel=\"nofollow noreferrer\"><img alt=\"My g++ version\" src=\"https://i.stack.imgur.com/7Yt7G.jpg\"/></a></p>\n", "AcceptedAnswerId": "48002763", "Title": "Template Resolution in <Inside The C++ Object Model>", "CreationDate": "2017-12-28T06:12:56.460", "LastActivityDate": "2017-12-28T08:18:57.243", "CommentCount": "0", "LastEditDate": "2017-12-28T06:21:05.383", "PostTypeId": "1", "LastEditorUserId": "841108", "Id": "48002450", "Score": "3", "OwnerUserId": "7825561", "Tags": "<c++><templates><resolution>", "AnswerCount": "1"}});