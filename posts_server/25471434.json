post_cb({"25471485": {"Id": "25471485", "PostTypeId": "2", "Body": "<p>There are two issues with the code.</p>\n<p>Firstly, <code>main</code> function is not supposed to be a template. You can just remove the <code>template</code> line</p>\n<pre><code>template&lt;class Type, class Type2&gt;\nint main()\n</code></pre>\n<hr>\n<p>Secondly, you are passing temporaries as <code>non-const</code> references. This is <a href=\"http://msdn.microsoft.com/en-us/library/cfbk5ddc%28v=vs.90%29.aspx\" rel=\"nofollow\">not allowed</a>. You may try to change template function signature adding <code>const</code>:</p>\n<pre><code>void function(const Type &amp; a, const Type2 &amp; b)\n</code></pre>\n<p>(Well, VS <em>sometimes</em> allows <code>non-const</code> reference to temporary binding, although it should not. But perhaps not in your case anyway.)</p>\n<hr>\n<p>In addition, <code>function</code> may collide with <code>std::function</code>. Consider renaming.</p>\n</hr></hr>", "LastEditorUserId": "3246555", "LastActivityDate": "2014-08-24T12:13:49.603", "Score": "4", "CreationDate": "2014-08-24T12:02:37.037", "ParentId": "25471434", "CommentCount": "0", "OwnerUserId": "3246555", "LastEditDate": "2014-08-24T12:13:49.603"}, "25471452": {"Id": "25471452", "PostTypeId": "2", "Body": "<p><code>main</code> function can't be templated:</p>\n<pre><code>int main()\n{\n    function(1, 2.0);\n}\n</code></pre>\n", "LastActivityDate": "2014-08-24T11:57:12.433", "CommentCount": "0", "CreationDate": "2014-08-24T11:57:12.433", "ParentId": "25471434", "Score": "2", "OwnerUserId": "3953764"}, "bq_ids": {"n4140": {"so_25471434_25472906_0": {"length": 7, "quality": 1.0, "section_id": 7145}}, "n3337": {"so_25471434_25472906_0": {"length": 7, "quality": 1.0, "section_id": 6889}}, "n4659": {"so_25471434_25472906_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 8646}}}, "25471434": {"ViewCount": "71", "Body": "<p>I have a very simple question.</p>\n<pre><code>template&lt;class Type, class Type2&gt;\nvoid function(Type &amp; a, Type2 &amp; b)\n{\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n}\n\ntemplate&lt;class Type, class Type2&gt;\nint main()\n{\n    function(1, 2.0);\n}\n</code></pre>\n<p>I am using Visual Studio 2012, nothing is underlined with red. I try to compile but it gives \"1 unresolved external\" error.</p>\n", "Title": "C++ Templating Unresolved Externals", "CreationDate": "2014-08-24T11:54:48.707", "LastActivityDate": "2014-08-25T08:08:25.453", "CommentCount": "1", "PostTypeId": "1", "Id": "25471434", "Score": "0", "OwnerUserId": "3948701", "Tags": "<c++><templates><overloading>", "AnswerCount": "4"}, "25472906": {"Id": "25472906", "PostTypeId": "2", "Body": "<p>While you've gotten a number of answers that contain correct information, none of them has addressed what looks to me like the underlying question: how is it that your program doesn't compile/link, but the IDE doesn't underline anything in red indicating an error?</p>\n<p>The answer to that is fairly simple: the code you've written doesn't contain any real errors. It's just incomplete.</p>\n<p>That probably doesn't help much by itself though. To understand it, you probably need to understand a little more about how your development tools work together to produce a program.</p>\n<p>Although you may not have worked with larger projects much (if at all) yet, in anything but the smallest of programs, it's fairly typical to break your code up into multiple files. In this case, one (and only one) of those files will contain a <code>main</code> function. The rest contain other code--function definitions, class definitions, and so on. Each of those can be compiled independently of the others (assuming the code is written correctly, of course). Then, when they're all compiled the linker runs to put those pieces together into a complete program.</p>\n<p>As it stands right now, your code is compiling correctly. It's only when it gets to that linking phase that things fall apart. As noted above, the reason for that is fairly simple: because your program is incomplete. The specific requirement is (\u00a73.6.1/1):</p>\n<blockquote>\n<p id=\"so_25471434_25472906_0\">A program shall contain a global function called main, which is the designated start of the program.</p>\n</blockquote>\n<p>Now, you might react by (quite correctly) pointing out that your code <em>does</em> contain a <code>main</code> that you intend to be used as the start of the program. The problem with that (as others have sort of pointed out, but none really stated directly) is that while you've defined <em>something</em> named <code>main</code>, what you've defined is <em>not</em> a function--it's a function <em>template</em>. A function template isn't a function itself--it's a piece of code that can <strong>generate</strong> a template when you instantiate it.</p>\n<p>When you instantiate a <em>class</em> template, the instantiation is fairly visible:</p>\n<pre><code>std::vector&lt;int&gt; data;\n</code></pre>\n<p>In the case of function templates, the intantiation is usually less visible--you define a function template, and then make calls as if that were a function. The compiler sorts out what template parameters to use based on the types of the parameters you passed.</p>\n<p>There's a limitation to that though: to figure out the types of the parameters that are being passed in the function call, the compiler must \"see\" both the function template <em>and</em> the (source code to the) call to that function template. Then it can look at the types of the parameters being passed, substitute them for the template parameters, and based on those it creates an instantiation of that function template for those parameters.</p>\n<p>The compiler needs to see both the function template itself <em>and</em> the call to that function template to put the two together and create an actual function for that call. Calling the template as a function really involves three steps:</p>\n<ol>\n<li>examine the source code to both the call and the template</li>\n<li>instantiate the template based on the types of the parameters being passed</li>\n<li>generate code to call the generated function for the types being passed</li>\n</ol>\n<p>Now comes the crucial point: to call a template function, those three steps have to take place <em>in that order</em>. First it has to look at both the call and the template, <em>then</em> it instantiates the template, <em>then</em> it can generate code to call the function instantiated from the template. Different calls may result in the template being instantiated differently, which (in turn) requires different code to be generated to call the generated function.</p>\n<p>The code that calls <code>main</code> doesn't allow that set of steps. It's pre-compiled into a library, so when it's compiled, the compiler can't take any function templates into account--they simply don't exist at that time/place.</p>\n", "LastActivityDate": "2014-08-24T14:49:30.923", "CommentCount": "0", "CreationDate": "2014-08-24T14:49:30.923", "ParentId": "25471434", "Score": "0", "OwnerUserId": "179910"}, "25471491": {"Id": "25471491", "PostTypeId": "2", "Body": "<p>You can't template the <code>main()</code> function, as it is the entry point to the program. However, if you want to template another function the syntax is pretty straightforward: </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class Type, class Type2&gt;\nvoid function(Type a, Type2 b)\n{\n    std::cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; std::endl;\n}\n\n\nint main()\n{      \n    function(1, 1);\n    function(1, 2.0);\n}\n</code></pre>\n", "LastEditorUserId": "240950", "LastActivityDate": "2014-08-25T08:08:25.453", "Score": "0", "CreationDate": "2014-08-24T12:03:04.140", "ParentId": "25471434", "CommentCount": "2", "OwnerUserId": "240950", "LastEditDate": "2014-08-25T08:08:25.453"}});