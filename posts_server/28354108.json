post_cb({"bq_ids": {"n4140": {"so_28354108_28354108_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 71}, "so_28354108_28354898_0": {"length": 18, "quality": 1.0, "section_id": 5322}, "so_28354108_28354898_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5338}, "so_28354108_28354898_1": {"length": 16, "quality": 1.0, "section_id": 5322}, "so_28354108_28354108_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 71}}, "n3337": {"so_28354108_28354898_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5135}, "so_28354108_28354108_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 66}, "so_28354108_28354898_0": {"length": 18, "quality": 1.0, "section_id": 5119}, "so_28354108_28354898_1": {"length": 16, "quality": 1.0, "section_id": 5119}, "so_28354108_28354108_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 66}}, "n4659": {"so_28354108_28354108_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 73}, "so_28354108_28354898_0": {"length": 18, "quality": 1.0, "section_id": 6743}, "so_28354108_28354898_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 6759}, "so_28354108_28354898_1": {"length": 15, "quality": 0.9375, "section_id": 6743}, "so_28354108_28354108_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 73}}}, "28354898": {"Id": "28354898", "PostTypeId": "2", "Body": "<p>This an effect of the <a href=\"http://en.wikipedia.org/wiki/Maximal_munch\" rel=\"nofollow noreferrer\">maximal munch principle</a>, which has the lexical analyzer take as many characters as possible to form a valid token. This is covered in draft C++ standard section <code>2.5</code> <em>[lex.pptoken]</em> which says:</p>\n<blockquote>\n<p id=\"so_28354108_28354898_0\">Otherwise, the next preprocessing token is the longest sequence of\n  characters that could constitute a preprocessing token, even if that\n  would cause further lexical analysis to fail.</p>\n</blockquote>\n<p>Any cases such as the one you cite above need a specific exception carved out such as this case for <code>&lt;::</code>, we can see an example in the following code:</p>\n<pre><code>template&lt;typename T&gt; class SomeClass;\nclass Class;\n\nSomeClass&lt;::Class&gt;* cls;\n</code></pre>\n<p>which is covered in <a href=\"https://stackoverflow.com/q/3952648/1708801\">this question</a>, the exception is listed in the bullet just above the maximal munch rule:</p>\n<blockquote>\n<p id=\"so_28354108_28354898_1\">Otherwise, if the next three characters are &lt;:: and the subsequent character is neither : nor &gt;, the &lt;\n  is treated as a preprocessor token by itself and not as the first character of the alternative token &lt;:.</p>\n</blockquote>\n<p>and of course the non-nested <code>&gt;</code> which you cite in your question. </p>\n<p>Note we can see that <code>&gt;=</code> is a preprocessor token from section <code>2.13</code> <em>[lex.operators]</em> which says:</p>\n<blockquote>\n<p id=\"so_28354108_28354898_2\">The lexical representation of C++ programs includes a number of preprocessing tokens which are used in\n  the syntax of the preprocessor or are converted into tokens for operators and punctuators:</p>\n</blockquote>\n<p>and includes <code>&gt;=</code> in the list.</p>\n<p><b> The &gt;&gt; fix </b></p>\n<p>We can see from the proposal that fixed the <code>&gt;&gt;</code> case: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html\" rel=\"nofollow noreferrer\">N1757: Right Angle Brackets</a> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_28354108_28354898_3\">Ever since the introduction of angle brackets, C++ programmers have\n  been surprised by the fact that two consecutive right angle brackets\n  must be separated by whitespace:</p>\n<pre><code>#include &lt;vector&gt;\ntypedef std::vector&lt;std::vector&lt;int&gt; &gt; Table;  // OK\ntypedef std::vector&lt;std::vector&lt;bool&gt;&gt; Flags;  // Error\n</code></pre>\n<p id=\"so_28354108_28354898_4\">The problem is an <strong>immediate consequence of the the \u201cmaximum munch\u201d\n  principle</strong> and the fact that &gt;&gt; is a valid token (right shift) in C++.</p>\n<p id=\"so_28354108_28354898_5\">This issue is a minor, but persisting, annoying, and somewhat\n  embarrassing problem. If the cost is reasonable, it seems therefore\n  worthwhile to eliminate the surprise.</p>\n<p id=\"so_28354108_28354898_6\">The purpose of this document is to explain ways to allow &gt;&gt; to be\n  treated as two closing angle brackets, as well as to discuss the\n  resulting issues. A specific option is proposed along with wording\n  that would implement the proposal in the current working paper.</p>\n</blockquote>\n<p>Also points out the <code>&gt;=</code> case:</p>\n<blockquote>\n<p id=\"so_28354108_28354898_7\">It is also worth noting that the problem can <strong>also occur with the &gt;&gt;=\n  and &gt;= tokens</strong>. For example</p>\n<pre><code>void func(List&lt;B&gt;= default_val1);\nvoid func(List&lt;List&lt;B&gt;&gt;= default_val2);\n</code></pre>\n<p id=\"so_28354108_28354898_8\">Both of these forms are currently ill-formed. It may be desirable to\n  also address this issue, but this paper does not propose to do so.</p>\n</blockquote>\n<p>Note, this change <a href=\"https://stackoverflow.com/a/23063914/1708801\">broke backward compatibility with C++03</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-30T12:10:33.497", "Score": "18", "CreationDate": "2015-02-05T22:01:44.260", "ParentId": "28354108", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:08:53.373"}, "28354108": {"ViewCount": "495", "Body": "<pre><code>template &lt;int&gt;\nusing A = int;\n\nvoid f(A&lt;0&gt;=0);   // Attempting to declare a function f taking int,\n                  // with the default argument 0\n\n// Works as expected:\n// void f(A&lt;0&gt; = 0);\n</code></pre>\n<p>This neither compiles on <a href=\"http://coliru.stacked-crooked.com/a/ca537ab1efae307e\">GCC 4.9.2 nor Clang 3.5</a> - let alone ICC or VC++.  Apparently the <code>&gt;=</code> bit is parsed as a greater-or-equal-than operator. However, this seems to be incorrect regarding [temp.names]/3:</p>\n<blockquote>\n<p id=\"so_28354108_28354108_0\">After name lookup (3.4) finds that a name is a <em>template-name</em> or that\n  an <em>operator-function-id</em> or a <em>literal-  operator-id</em> refers to a set\n  of overloaded functions any member of which is a function template, if\n  this is followed by a <code>&lt;</code>, the <code>&lt;</code> is always taken as the delimiter of\n  a <em>template-argument-list</em> and never as the less-than operator.\n  <strong>When parsing a <em>template-argument-list</em>, the first non-nested\n  <code>&gt;</code><sup>138</sup> is taken as the ending delimiter</strong> rather than a\n  greater-than operator. [..] [ <em>Example:</em></p>\n<pre><code>template&lt;int i&gt; class X { /* ...*/ };\n\nX&lt; 1&gt;2 &gt; x1; // syntax error\nX&lt;(1&gt;2)&gt; x2; // OK\n</code></pre>\n<p id=\"so_28354108_28354108_1\"><em>\u2014 end example</em> ]</p>\n<p id=\"so_28354108_28354108_2\"><sup>138) A <code>&gt;</code> that encloses the <em>type-id</em> of a <code>dynamic_cast</code>,\n  <code>static_cast</code>, <code>reinterpret_cast</code> or <code>const_cast</code>, or which encloses\n  the\n  <em>template-argument</em>s of a subsequent <em>template-id</em>, is considered nested for the purpose of this description.</sup></p>\n</blockquote>\n<p>Am I missing something or is this a compiler bug?</p>\n", "AcceptedAnswerId": "28354898", "Title": "Why does the template-id in \"A<0>=0\" not compile without space because of the greater-or-equal-than operator \">=\"?", "CreationDate": "2015-02-05T21:13:38.580", "Id": "28354108", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-09T17:45:28.697", "LastEditorUserId": "895245", "LastActivityDate": "2016-05-09T17:45:28.697", "Score": "27", "OwnerUserId": "3647361", "Tags": "<c++><templates><c++11><language-lawyer>", "AnswerCount": "1"}});