post_cb({"30418814": {"CommentCount": "11", "ViewCount": "1912", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-24T00:09:13.923", "LastActivityDate": "2015-05-24T01:55:34.110", "Title": "storing mutexes in a vector/deque c++", "AcceptedAnswerId": "30419060", "LastEditDate": "2017-05-23T11:51:05.997", "Id": "30418814", "Score": "2", "Body": "<p>I would like to store a variable number of mutexes in a container like vector or deque.</p>\n<p>In one of the use cases, I need to reliably and deadlock-free lock all of the mutexes. I would also like to have exception safety guarantee, that if an exception is thrown, all of the mutexes are as if no locking occured.</p>\n<p>I am trying to do something like:</p>\n<pre><code>std::vector&lt;std::mutex&gt; locks_(n);\nstd::vector&lt;std::lock_guard&lt;std::mutex&gt; &gt; guards(n);\nfor(int i = 0; i &lt; n; i++) {\n    std::lock_guard&lt;std::mutex&gt; guard(locks_[i]);\n    guards.emplace_back(std::move(guard));\n}\n</code></pre>\n<p>but it doesn't compile, giving me:</p>\n<blockquote>\n<p id=\"so_30418814_30418814_0\">/usr/include/c++/4.8/ext/new_allocator.h:120:4: error: use of deleted \n  function \u2018std::lock_guard&lt;_Mutex&gt;::lock_guard(const\n  std::lock_guard&lt;_Mutex&gt;&amp;) [with _Mutex = std::mutex]\u2019</p>\n</blockquote>\n<p>I guess there might also be a problem when lock_guards are destroyed, because the order must be reversed as compared to construction, but the standard saves us with:</p>\n<blockquote>\n<p id=\"so_30418814_30418814_1\">The delete-expression will invoke the destructor (if any) for the\n  object or the elements of the array being deleted. In the case of an\n  array, the elements will be destroyed in order of decreasing address\n  (that is, in reverse order of the completion of their constructor; see\n  12.6.2).</p>\n</blockquote>\n<p>Are there any potential pitfalls with this approach and how can one make it work?</p>\n<h1>Edit</h1>\n<p>actually I am wrong, it seems vector does not guarantee a particular order of destruction. See this question: <a href=\"https://stackoverflow.com/questions/6169125/order-of-destruction-of-elements-of-an-stdvector\">Order of destruction of elements of an std::vector</a></p>\n<h1>Edit2</h1>\n<p><strong>Q</strong>: What if the use case is: </p>\n<p>All the mutexes are locked/unlocked in any order by different threads (however each of those threads uses only 1 mutex at a time), \nbut at some point I need to lock all of the mutexes in a safe manner in another thread.</p>\n", "Tags": "<c++11><mutex>", "OwnerUserId": "1514922", "AnswerCount": "2"}, "30419060": {"ParentId": "30418814", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>With a firm and low upper bound on <code>n</code> you could reasonably do something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\n\nint\nmain()\n{\n    constexpr unsigned n_max = 5;\n    unsigned n;\n    std::cout &lt;&lt; \"Enter n: \";\n    std::cin &gt;&gt; n;\n    if (std::cin.fail())\n        throw \"oops\";\n    if (n &gt; n_max)\n        throw \"oops\";\n    std::vector&lt;std::mutex&gt; mutexes(n);\n    std::vector&lt;std::unique_lock&lt;std::mutex&gt;&gt; locks;\n    for (auto&amp; m : mutexes)\n        locks.emplace_back(m, std::defer_lock);\n    switch (locks.size())\n    {\n    case 0:\n        break;\n    case 1:\n        locks.front().lock();\n        break;\n    case 2:\n        std::lock(locks[0], locks[1]);\n        break;\n    case 3:\n        std::lock(locks[0], locks[1], locks[2]);\n        break;\n    case 4:\n        std::lock(locks[0], locks[1], locks[2], locks[3]);\n        break;\n    case 5:\n        std::lock(locks[0], locks[1], locks[2], locks[3], locks[4]);\n        break;\n    default:\n        throw \"oops\";\n    }\n}\n</code></pre>\n<p>It isn't that pretty.  But it is easy to reason about and thus reliable.</p>\n<p>Notes:</p>\n<ol>\n<li><p>You need to use <code>std::lock(m1, m2, ...)</code> to reliably lock more than one <code>mutex</code>, or re-invent an algorithm such as <code>std::lock</code> to avoid deadlock.  One such alternative algorithm is if you can guarantee that everyone always locks the mutexes in <code>mutexes</code> in the same order (say by index), then you don't need <code>std::lock</code> at all, just loop thru and lock `em.</p></li>\n<li><p><code>lock_guard</code> is problematic to put in <code>vector</code> one at a time as <code>vector&lt;T&gt;::emplace_back</code> requires <code>T</code> to be move constructible.  That is one of the reasons why <code>unique_lock</code> works here and <code>lock_guard</code> doesn't.  <code>mutexes</code> gets away with holding non-movable mutexes because it constructs the <code>vector</code> all at once instead of adding to it with <code>emplace_back</code>.</p></li>\n<li><p>In this example <code>locks</code> holds references into <code>mutexes</code>.  Make sure you don't have lifetime issues between these two containers (<code>mutexes</code> must outlive <code>locks</code>).</p></li>\n<li><p>If you need to add non-movable items to the end of a sequence, switch to <code>deque</code>, that will work where <code>vector</code> won't.</p></li>\n<li><p>Unlocking order doesn't matter, don't worry about it.  Locking order matters only if different threads might lock in different orders.  If all threads always lock in the same order, don't worry about it.  But if all threads always lock in the same order, consider replacing the n mutexes with a single mutex, as that sounds equivalent.</p></li>\n<li><p>The code above assumes that somehow different threads might be locking in a different order, and perhaps a subset of <code>mutexes</code>.  And obviously it won't scale to large <code>n</code>.</p></li>\n</ol>\n<p>With <strong>Edit2</strong> in the question, I believe this code to be viable.  It will reliably work with different threads locking <code>mutexes</code> in different orders.  Each thread should form its own local copy of <code>locks</code> and send that through the <code>switch</code>.  If a thread for some reason needs its <code>locks</code> to be a subset of <code>mutexes</code>, or to build it in a different order, no problem.  That is what this solution is designed for.</p>\n<p><strong>Plug</strong></p>\n<p>If you are interested in the algorithm behind <code>std::lock</code>, here are performance tests for a variety of potential implementations of it, including test code that you can run on your own platform:</p>\n<p><a href=\"http://howardhinnant.github.io/dining_philosophers.html\" rel=\"nofollow\">Dining Philosophers Rebooted</a></p>\n<p>If you find that your implementation of <code>std::lock</code> is suboptimal, have a talk with your implementor. :-)</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2015-05-24T01:55:34.110", "Id": "30419060", "Score": "1", "CreationDate": "2015-05-24T00:54:20.343", "LastActivityDate": "2015-05-24T01:55:34.110"}, "30419068": {"ParentId": "30418814", "CommentCount": "5", "Body": "<p>It is ok to construct the lock_guards with <code>new</code> and putting them into <code>unique_ptr</code>s?</p>\n<p>Then the vector would hold <code>std::unique_ptr&lt;std::lock_guard&lt;std::mutex&gt;&gt;</code> instead of just <code>std::lock_guard&lt;std::mutex&gt;</code>:</p>\n<pre><code>std::vector&lt;std::mutex&gt; locks_(n);\nstd::vector&lt;std::unique_ptr&lt;std::lock_guard&lt;std::mutex&gt;&gt;&gt; guards(n);\nfor (int i = 0; i &lt; n; i++) {\n  typedef std::lock_guard&lt;std::mutex&gt; LockGuardType;\n  std::unique_ptr&lt;LockGuardType&gt; guard(new LockGuardType(locks_[i]));\n  guards.emplace_back(std::move(guard));\n}\n</code></pre>\n<p>That should compile fine.</p>\n", "OwnerUserId": "3042070", "PostTypeId": "2", "Id": "30419068", "Score": "0", "CreationDate": "2015-05-24T00:56:08.023", "LastActivityDate": "2015-05-24T00:56:08.023"}, "bq_ids": {"n4140": {"so_30418814_30418814_1": {"section_id": 6110, "quality": 0.92, "length": 23}}, "n3337": {"so_30418814_30418814_1": {"section_id": 5876, "quality": 0.92, "length": 23}}, "n4659": {"so_30418814_30418814_1": {"section_id": 7607, "quality": 0.92, "length": 23}}}});