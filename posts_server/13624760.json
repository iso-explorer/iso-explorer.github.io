post_cb({"29095311": {"Id": "29095311", "PostTypeId": "2", "Body": "<p>This code here (<a href=\"https://gist.github.com/klange/4042963\" rel=\"nofollow\">https://gist.github.com/klange/4042963</a>) shows how to access anonymous unions inside struct. You just access the members of nested union as if they are members of the struct.</p>\n<pre><code>typedef struct {\n    union {\n        char * company;\n        char * school;\n        char * project;\n    };\n    union {\n        char * location;\n        char * url;\n    };\n    union {\n        char * title;\n        char * program;\n    };\n\n    time_t started;\n    time_t left;\n\n    char * description[];\n} thing_t;\n\ntypedef thing_t job_t;\n\njob_t yelp = {\n    .company  = \"Yelp, Inc.\",\n    .location = \"San Francisco, CA\",\n    .title    = \"Software Engineer, i18n\",\n    .started  = 1339977600,\n    .left     = CURRENT,\n    .description = {\n        \"Developed several internal tools and libraries\",\n        \"Provided critical input and design work for Yelp's launch in Japan\",\n        NULL\n    }\n};\n</code></pre>\n", "LastActivityDate": "2015-03-17T09:19:53.357", "CommentCount": "0", "CreationDate": "2015-03-17T09:19:53.357", "ParentId": "13624760", "Score": "3", "OwnerUserId": "1590190"}, "13624830": {"Id": "13624830", "PostTypeId": "2", "Body": "<p>Without being sure and without having tried:</p>\n<p>The union itself is not accessible, but it's members are.</p>\n<p>Therefore you should be able to do refer to <code>obj.block</code> and <code>obj.grid</code></p>\n", "LastActivityDate": "2012-11-29T11:30:58.307", "CommentCount": "1", "CreationDate": "2012-11-29T11:30:58.307", "ParentId": "13624760", "Score": "8", "OwnerUserId": "146003"}, "13625189": {"Id": "13625189", "PostTypeId": "2", "Body": "<p>first of all i want to say that <strong>A union, is a collection of variables of different types, just like a structure. However, with unions, you can only store information in one field at any one time.</strong></p>\n<p>The unions are basically used for memory saving &amp; <strong>it's size is equal to the largest member of the union.</strong></p>\n<p><strong>And for accessing the data fields of a union, use the dot operator(.) just as you would for a structure and explained by @Atmocreations. When a value is assigned to one member, the other member(s) get whipped out since they share the same memory.</strong> </p>\n<p>as an example where the unions may be useful is </p>\n<pre><code>union time    \n        {\n        long time_in_sec;\n        double time_in_mili_sec;\n        }mytime;\n</code></pre>\n<p>....\nThe union above could be used to either store the current time (in seconds) to hold time accurate to a second. Or it could be used to hold time accurate to a millisecond. Presumably there are times when you would want one or the other, but not both. This declaration should look familiar. It is the same as a struct definition, but with the keyword union instead of struct.</p>\n<p>for more info <a href=\"http://msdn.microsoft.com/en-us/library/5dxy4b7b(v=vs.80).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/5dxy4b7b(v=vs.80).aspx</a></p>\n", "LastEditorUserId": "1788471", "LastActivityDate": "2012-11-29T11:58:47.667", "Score": "-4", "CreationDate": "2012-11-29T11:50:03.797", "ParentId": "13624760", "CommentCount": "5", "OwnerUserId": "1788471", "LastEditDate": "2012-11-29T11:58:47.667"}, "35388572": {"Id": "35388572", "PostTypeId": "2", "Body": "<p>To elaborate on the answer provided by Angew quoting the standard concerning anonymous unions and structs, I thought to provide an sample of C source code with the output generated by that sample showing how values are allocated within a <code>struct</code> and a <code>union</code> composed of <code>struct</code> and <code>union</code> components.</p>\n<p>The standard quoted by Angew is:</p>\n<blockquote>\n<p id=\"so_13624760_35388572_0\">For the purpose of name lookup, after the anonymous union definition,\n  the members of the anonymous union are considered to have been defined\n  in the scope in which the anonymous union is declared.</p>\n</blockquote>\n<p>The source code of a <code>struct</code> composed of named and anonymous structs and unions looks like the following. This is using Visual Studio 2005 and the <code>#pragma (pack, 1)</code> is used to align everything on a <code>char</code> boundary in order for there to be no memory holes. There is also a simple C Preprocessor macro defined to make the output more legible and easier to code.</p>\n<pre><code>typedef unsigned char UCHAR;\n\n// use of Microsoft Visual Studio pragma to force char alignment for the struct.\n#pragma pack(push, 1)\nconst struct {\n    union {\n        const UCHAR myArray[];  // this array shares memory with struct following\n        struct {\n            const UCHAR iOne;\n            const UCHAR iTwo;\n            const UCHAR iThree;\n        };  // anonymous struct accessed by specifying Things.\n    };      // anonymous union accessed by specifying Things.\n//  const UCHAR myArray[];   // will cause error - \"error C2020: 'myArray' : 'struct' member redefinition\"\n    union {\n        const UCHAR myArray[];  // this array shares memory with struct following\n        struct {\n            const UCHAR iOne;\n            const UCHAR iTwo;\n            const UCHAR iThree;\n        } s;    // named struct accessed by specifying Things.u.s\n    } u;        // named union accessed by specifying Things.u\n} Things = {1, 2, 4, 8, 9, 10, 22, 23, 24, 25};\n#pragma pack(pop)\n\n// a little helper macro to make the output easier to code.\n#define PRINTF_VAL(x) printf (\"%s %d \\n\", #x, x)\n\nint itSelf (UCHAR iMask)\n{\n    int iMatch = -1;\n\n    int jj = 0;\n    jj = Things.myArray[0]; PRINTF_VAL(Things.myArray[0]);\n    jj = Things.myArray[1]; PRINTF_VAL(Things.myArray[1]);\n    jj = Things.myArray[2]; PRINTF_VAL(Things.myArray[2]);\n    jj = Things.myArray[3]; PRINTF_VAL(Things.myArray[3]);\n    jj = Things.myArray[4]; PRINTF_VAL(Things.myArray[4]);\n    jj = Things.iOne; PRINTF_VAL(Things.iOne);\n    jj = Things.iTwo; PRINTF_VAL(Things.iTwo);\n    jj = Things.iThree; PRINTF_VAL(Things.iThree);\n\n    jj = Things.u.myArray[0]; PRINTF_VAL(Things.u.myArray[0]);\n    jj = Things.u.myArray[1]; PRINTF_VAL(Things.u.myArray[1]);\n    jj = Things.u.myArray[2]; PRINTF_VAL(Things.u.myArray[2]);\n    jj = Things.u.myArray[3]; PRINTF_VAL(Things.u.myArray[3]);\n    jj = Things.u.myArray[4]; PRINTF_VAL(Things.u.myArray[4]);\n    jj = Things.u.s.iOne; PRINTF_VAL(Things.u.s.iOne);\n    jj = Things.u.s.iTwo; PRINTF_VAL(Things.u.s.iTwo);\n    jj = Things.u.s.iThree; PRINTF_VAL(Things.u.s.iThree);\n\n    return iMatch + 1;\n}\n</code></pre>\n<p>The output generated by this function looks like:</p>\n<pre><code>Things.myArray[0] 1\nThings.myArray[1] 2\nThings.myArray[2] 4\nThings.myArray[3] 8\nThings.myArray[4] 9\nThings.iOne 1\nThings.iTwo 2\nThings.iThree 4\nThings.u.myArray[0] 8\nThings.u.myArray[1] 9\nThings.u.myArray[2] 10\nThings.u.myArray[3] 22\nThings.u.myArray[4] 23\nThings.u.s.iOne 8\nThings.u.s.iTwo 9\nThings.u.s.iThree 10\n</code></pre>\n<p>The output shows the overlap between the various components of the main <code>struct</code>, <code>Things</code> caused by the use of unions. You can also see how the components of the anonymous <code>struct</code> and <code>union</code> are referenced versus those components of the named <code>struct</code> and <code>union</code>.</p>\n<p>Also just for fun I tried adding an array definition of <code>const UCHAR myArray[];</code> after the anonymous <code>union</code> containing <code>const UCHAR myArray[];</code> to see what would happen. The compiler complained with an error of <code>error C2020: 'myArray' : 'struct' member redefinition</code>. The addition is commented out in the <code>struct</code> definition of <code>Things</code> above. However since the second use of <code>const UCHAR myArray[];</code> is in a named <code>union</code> the compile works because second use is accessed by specifying the name of the union.</p>\n", "LastActivityDate": "2016-02-14T05:09:05.177", "CommentCount": "0", "CreationDate": "2016-02-14T05:09:05.177", "ParentId": "13624760", "Score": "2", "OwnerUserId": "1466970"}, "bq_ids": {"n4140": {"so_13624760_13624921_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5917}, "so_13624760_35388572_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5917}}, "n3337": {"so_13624760_13624921_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5689}, "so_13624760_35388572_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5689}}, "n4659": {"so_13624760_13624921_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7410}, "so_13624760_35388572_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7410}}}, "13624760": {"ViewCount": "21110", "Body": "<p>I'm working on the so called Hotspot open source project, and looking at the implementation I found a nasty nested union in struct looking like that:</p>\n<pre><code>typedef struct RC_model_t_st\n{\n    union\n    {\n        struct block_model_t_st *block;\n        struct grid_model_t_st *grid;\n    };\n    /* block model or grid model    */\n    int type;\n    thermal_config_t *config;\n}RC_model_t;\n</code></pre>\n<p>As far as I'm aware in C/C++ that union is unaccesible. So how someone can make use of union declared in such manner and for what purpose?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "13625189", "Title": "How to use c union nested in struct with no name", "CreationDate": "2012-11-29T11:27:55.347", "Id": "13624760", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-04-23T09:07:48.983", "LastEditorUserId": "49246", "LastActivityDate": "2016-02-14T05:09:05.177", "Score": "7", "OwnerUserId": "1649291", "Tags": "<c++><c><unions><anonymous>", "AnswerCount": "6"}, "13624921": {"Id": "13624921", "PostTypeId": "2", "Body": "<p>This is an <em>anonymous union.</em> In C++, as per [class.union], paragraph 5:</p>\n<blockquote>\n<p id=\"so_13624760_13624921_0\">For the purpose of name lookup, after the anonymous union definition,\n  the members of the anonymous union are considered to have been defined\n  in the scope in which the anonymous union is declared</p>\n</blockquote>\n<p>This means you can access its members as if they were members of <code>RC_model_t_st</code>.</p>\n", "LastActivityDate": "2012-11-29T11:36:32.257", "CommentCount": "3", "CreationDate": "2012-11-29T11:36:32.257", "ParentId": "13624760", "Score": "17", "OwnerUserId": "1782465"}, "13625130": {"Id": "13625130", "PostTypeId": "2", "Body": "<p>Names declared in an anonymous union are used directly, like nonmember variables.\nA good reason to do this is to save memory.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(int argc, char **argv) {\n   union {\n      double first;\n      double second;\n   };\n\n   first = 10.001;\n   second = 3.141592;\n   std::cout &lt;&lt; first &lt;&lt; \" \" &lt;&lt; second &lt;&lt; std::endl;\n\n   first = 10.002;\n   std::cout &lt;&lt; first &lt;&lt; \" \" &lt;&lt; second &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2012-11-29T11:47:39.873", "CommentCount": "0", "CreationDate": "2012-11-29T11:47:39.873", "ParentId": "13624760", "Score": "2", "OwnerUserId": "392995"}});