post_cb({"bq_ids": {"n4140": {"so_37829849_37831395_0": {"length": 40, "quality": 1.0, "section_id": 5058}, "so_37829849_37831395_3": {"length": 18, "quality": 0.72, "section_id": 5058}}, "n3337": {"so_37829849_37831395_0": {"length": 40, "quality": 1.0, "section_id": 4855}, "so_37829849_37831395_3": {"length": 18, "quality": 0.72, "section_id": 4855}}, "n4659": {"so_37829849_37831395_0": {"length": 40, "quality": 1.0, "section_id": 6479}, "so_37829849_37831395_3": {"length": 18, "quality": 0.72, "section_id": 6479}}}, "37829849": {"ViewCount": "188", "Body": "<p>after upgrading gcc from version 4.8.5 to version 5.3.1 I thought I\ncould get rid of boost's regex-implementation (boost version 1.54.0) and\nuse the one provided by gcc (it didn't work with gcc before version 4.9\nAFAIK). However, this turned out to be a problem because those two\nimplementations behave differently:</p>\n<pre><code>#include &lt;regex&gt;\n#include &lt;boost/regex.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string s=\"\\\\needs_another_backslash\";\n    std::string reg(\"^(\\\\\\\\)(needs)(.+)\");\n    std::string rep(\"\\\\\\\\got$3\");\n    std::regex sr(reg);\n    boost::regex br(reg);\n    std::cout&lt;&lt;\"string before replacement:\\n\"&lt;&lt;s&lt;&lt;std::endl&lt;&lt;\n        \"regular expression:\\n\"&lt;&lt;reg&lt;&lt;std::endl&lt;&lt;\n        \"replacement string:\\n\"&lt;&lt;rep&lt;&lt;std::endl&lt;&lt;\n        \"std::regex_replace:\\n\"&lt;&lt;std::regex_replace(s,sr,rep)&lt;&lt;std::endl&lt;&lt;\n        \"boost::regex_replace:\\n\"&lt;&lt;boost::regex_replace(s,br,rep)&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>This gives the following output:</p>\n<p><code>string before replacement:\n\\needs_another_backslash\nregular expression:\n^(\\\\)(needs)(.+)\nreplacement string:\n\\\\got$3\nstd::regex_replace:\n\\\\got_another_backslash\nboost::regex_replace:\n\\got_another_backslash</code></p>\n<p>It seems as if boost treats the '\\' in a replacement string specially\nwhereas gcc does not. Since the magical character for backreference in the replacement string for std::regex_replace is '$' (which it also is in boost as the example proofs), I tend to think that gcc is right. However, in many other programs (like vim e.g.) it is '\\'. Therefore, boost might have a point in treating '\\' specially. So who is right?</p>\n", "Title": "different treatment of '\\' in regex_replace() replacement string in g++ and boost", "CreationDate": "2016-06-15T08:21:15.960", "LastActivityDate": "2016-06-17T14:10:16.277", "CommentCount": "2", "LastEditDate": "2016-06-15T14:45:37.217", "PostTypeId": "1", "LastEditorUserId": "6265172", "Id": "37829849", "Score": "1", "OwnerUserId": "6265172", "Tags": "<c++><c++11><gcc><boost>", "AnswerCount": "1"}, "37831395": {"Id": "37831395", "PostTypeId": "2", "Body": "<p>First, the std example actually is not a matter of gcc, but of C++ standard, to which gcc (in this case) is compliant. The standard states in 28.5.2:</p>\n<blockquote>\n<p id=\"so_37829849_37831395_0\">When a regular expression match is to be replaced by a new string, the new\n  string shall be constructed using the rules used by the ECMAScript replace\n  function in ECMA-262, part 15.5.4.11 String.prototype.replace. In addition,\n  during search and replace operations all non-overlapping occurrences of the\n  regular expression shall be located and replaced, and sections of the input\n  that did not match the expression shall be copied unchanged to the output\n  string.</p>\n</blockquote>\n<p>And <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.11\" rel=\"nofollow\">ECMA</a> states:</p>\n<blockquote>\n<p id=\"so_37829849_37831395_1\">Otherwise, let newstring denote the result of converting replaceValue to a String. The result is a String value derived from the original input String by replacing each matched substring with a String derived from newstring by replacing characters in newstring by replacement text as specified in Table 22. These $ replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements. For example, \"$1,$2\".replace(/(\\$(\\d))/g, \"$$1-$1$2\") returns \"$1-$11,$1-$22\". A $ in newstring that does not match any of the forms below is left as is.</p>\n</blockquote>\n<p>(If part: replaceValue is a function.)</p>\n<p>Nothing mentioned about escape sequences being replaced. Tried out with firefox:\n</p>\n<pre><code>var test = \"\\\\needs_another_backslash\";\ntest = test.replace(/^(\\\\)(needs)(.+)/, \"\\\\\\\\got$3\");\nalert(test);\n</code></pre>\n<p>Result: <code>\\\\got_another_backslash</code>.</p>\n<p>boost <a href=\"http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/boost_regex/ref/match_results.html#boost_regex.match_results_format\" rel=\"nofollow\">documentation</a> states:</p>\n<blockquote>\n<p id=\"so_37829849_37831395_2\">Effects: If fmt is either a null-terminated string, or a container of char_type's, then copies the character sequence [fmt.begin(), fmt.end()) to OutputIterator out. For each format specifier or escape sequence in fmt, replace that sequence with either the character(s) it represents, or the sequence of characters within *this to which it refers. The bitmasks specified in flags determines what format specifiers or escape sequences are recognized, by default this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace. </p>\n</blockquote>\n<p>Additionally, it states for <a href=\"http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/boost_regex/ref/match_flag_type.html\" rel=\"nofollow\">match_type_flags</a>:</p>\n<blockquote>\n<p id=\"so_37829849_37831395_3\">Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace. (FWD.1).</p>\n<p id=\"so_37829849_37831395_4\">This is functionally identical to the Perl format string rules.</p>\n<p id=\"so_37829849_37831395_5\">[...]</p>\n</blockquote>\n<p>Tried with perl 5.18.2 on linux:\n</p>\n<pre><code>my $test = \"\\\\needs_another_backslash\";\n$test =~ s/^(\\\\)(needs)(.+)/\\\\\\\\got$3/;\nprint \"$test\\n\";\n</code></pre>\n<p>Resulted in <code>\\\\got_another_backslash</code>.</p>\n<p>With <code>std::string reg(\"^(\\\\\\\\)(needs)(.+)\");</code>, as a string literal is passed, reg holds a string <code>^(\\\\)(needs)(.+)</code> (not a literal, so left out the quotes!), and with <code>std::string rep(\"\\\\\\\\got$3\");</code>, rep holds <code>\\\\got$3</code>.</p>\n<p>But there is obviously a difference in interpretation. Assume we had for both std and boost one and the same ECMAScript engine.</p>\n<p>Then, what both std and boost yet do consistently, is compiling the <code>reg</code> string as regular expression:\n</p>\n<pre><code>sprintf(b, \"/%s/\", reg);\nsr /* br, respectively */ = ECMAScriptEngine::compileFromSource(b);\n</code></pre>\n<p>I think this is reflected quite nicely by creating an instance of std/boost::regex class.</p>\n<p>Then comes the difference, however: std passes <code>s</code>, <code>sr</code> and <code>rep</code> to the ECMAScript engine such that it calls directly <code>s.(String.prototype.replace)(sr, rep);</code> (of course there is no such  function for s in reality \u2013 just lets assume we could do it this way).</p>\n<p>boost lets compile the rep string, too (side note: I haven't installed boost, so I did not verify this behaviour myself...):\n</p>\n<pre><code>sprintf(b, \"'%s'\", rep); // note: '', not //!\necma_rep = ECMAScriptEngine::compileFromSource(b);\n</code></pre>\n<p>and then makes the engine call <code>s.(String.prototype.replace)(sr, ecma_rep);</code>.</p>\n<p>Interestingly, boost does not compile the source string s, where it again agrees with std...</p>\n<p>In the end, I think, however, the standard implementation reflects closer what we actually want to do:</p>\n<pre><code>s.replace(regex, string);\ns.replace(/reg/, rep);\n(std::string).replace(std::regex(std::string), std::string);\nstd::regex_replace(s, std::regex(reg), rep);\n</code></pre>\n<p>vs</p>\n<pre><code>s.replace(regex, string);\ns.replace(/reg/, \"rep\");\n(std::string).replace(boost::regex(std::string), boost::???(std::string));\nboost::regex_replace(s, boost::regex(reg), rep); // not boost::???(rep)!\n</code></pre>\n<p>Not sure if this is sufficient to say one is right and the other wrong, however (would mean that the wrong one is buggy!). Possibly we even have to remain with a third option: Both approaches are valid (so both are right and none is wrong) and, unfortunately, they are incompatible...</p>\n", "LastEditorUserId": "1312382", "LastActivityDate": "2016-06-17T14:10:16.277", "Score": "0", "CreationDate": "2016-06-15T09:27:01.483", "ParentId": "37829849", "CommentCount": "10", "OwnerUserId": "1312382", "LastEditDate": "2016-06-17T14:10:16.277"}});