post_cb({"bq_ids": {"n4140": {"so_26200827_26201529_2": {"length": 37, "quality": 0.9024390243902439, "section_id": 6185}, "so_26200827_26201529_3": {"length": 4, "quality": 1.0, "section_id": 6185}, "so_26200827_26201529_1": {"length": 5, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_26200827_26201529_2": {"length": 41, "quality": 1.0, "section_id": 5946}, "so_26200827_26201529_3": {"length": 4, "quality": 1.0, "section_id": 5946}, "so_26200827_26201529_1": {"length": 4, "quality": 0.8, "section_id": 291}}, "n4659": {"so_26200827_26201529_2": {"length": 38, "quality": 0.926829268292683, "section_id": 7687}, "so_26200827_26201529_1": {"length": 4, "quality": 0.8, "section_id": 307}}}, "26200827": {"ViewCount": "3190", "Body": "<p>In c++11, a <code>constexpr</code> expression cannot contain reinterpret casts. So for instance, if one wanted to manipulate the bits in a floating point number, say to find the mantissa of the number:</p>\n<pre><code>constexpr unsigned int mantissa(float x) { \n    return ((*(unsigned int*)&amp;x &lt;&lt; 9) &gt;&gt; 9); \n};\n</code></pre>\n<p>The above code would fail to be <code>constexpr</code>.  In theory, I can't see how a reinterpret cast in this or similar cases can be any different from arithmetic operators, but the complier (and the standard) don't allow it.</p>\n<p>Is there any clever way of getting around this limitation? </p>\n", "AcceptedAnswerId": "26201529", "Title": "Getting around the reinterpret cast limitation with constexpr", "CreationDate": "2014-10-05T08:11:07.450", "Id": "26200827", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-03-20T08:44:41.990", "Score": "12", "OwnerUserId": "1045622", "Tags": "<c++><c++11><constexpr><reinterpret-cast>", "AnswerCount": "2"}, "36111603": {"Id": "36111603", "PostTypeId": "2", "Body": "<p>Your particular example of getting a mantissa of a <code>float</code> number is actually quite simple to implement for <em>numbers</em> without type punning at all, and thus implement it in a <code>constexpr</code> fashion. The only problem would be when you want to hack on NaNs.</p>\n<p>Since you already rely on <code>float</code> being the <code>binary32</code> from IEEE 754, we can assume the same, but in another way \u2014 to present results. See the following code:</p>\n<pre><code>#include &lt;limits&gt;\nconstexpr float abs(float x) { return x&lt;0 ? -x : x; }\n\nconstexpr int exponent(float x)\n{\n    return abs(x)&gt;=2 ? exponent(x/2)+1 :\n           abs(x)&lt;1  ? exponent(x*2)-1 : 0;\n}\n\nconstexpr float scalbn(float value, int exponent)\n{\n    return exponent==0 ? value : exponent&gt;0 ? scalbn(value*2,exponent-1) :\n                                              scalbn(value/2,exponent+1);\n}\n\nconstexpr unsigned mantissa(float x)\n{\n    return abs(x)&lt;std::numeric_limits&lt;float&gt;::infinity() ?\n                // remove hidden 1 and bias the exponent to get integer\n                scalbn(scalbn(abs(x),-exponent(x))-1,23) : 0;\n}\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    constexpr float x=-235.23526f;\n    std::cout &lt;&lt; std::hex &lt;&lt; std::setfill('0');\n    // Show non-constexpr result to compare with\n    unsigned val; std::memcpy(&amp;val,&amp;x,sizeof val);\n    std::cout &lt;&lt; std::setw(8) &lt;&lt; (val&amp;0x7fffff) &lt;&lt; \"\\n\";\n    // Now the sought-for constexpr result\n    constexpr auto constexprMantissa=mantissa(x);\n    std::cout &lt;&lt; std::setw(8) &lt;&lt; constexprMantissa &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/868f5a07dd65ccb6\" rel=\"noreferrer\">its live demo</a>.</p>\n", "LastEditorUserId": "673852", "LastActivityDate": "2016-03-20T08:44:41.990", "Score": "6", "CreationDate": "2016-03-20T08:18:43.623", "ParentId": "26200827", "CommentCount": "0", "OwnerUserId": "673852", "LastEditDate": "2016-03-20T08:44:41.990"}, "26201529": {"Id": "26201529", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26200827_26201529_0\">I can't see how a reinterpret cast in this or similar cases can be any\n  different from arithmetic operators</p>\n</blockquote>\n<p>It isn't portable.</p>\n<p>You are probably aware of the fact that your code causes undefined behavior, since you dereference a type punned pointer and thus break strict aliasing. Moreover, since C++14, operations that would invoke undefined behavior aren't even constant expressions anymore and should thus produce a compiler error.</p>\n<p>What you are basically trying to do is alias the <code>float</code> object with an integral glvalue. The first step is to obtain that glvalue; the second  to perform an lvalue-to-rvalue conversion.</p>\n<p>In C++14, the first step is impossible to accomplish in constant expressions. <code>reinterpret_cast</code> is explicitly forbidden. And casts to and from <code>void*</code>, like <code>static_cast&lt;char const*&gt;(static_cast&lt;void const*&gt;(&amp;x))</code>, don't work either (N3797, [expr.const]/2*):</p>\n<blockquote>\n<p id=\"so_26200827_26201529_1\">\u2014 a conversion from type <em>cv</em> <code>void *</code> to a pointer-to-object type;</p>\n</blockquote>\n<p>Keep in mind that a c-style cast like <code>(char*)</code> is reduced to either <code>static_cast</code> or <code>reinterpret_cast</code> whose limitations are listed above. <code>(unsigned*)&amp;x</code> therefore reduces to <code>reinterpret_cast&lt;unsigned*&gt;(&amp;x)</code> and doesn't work.</p>\n<p>In C++11, the cast to <code>void const*</code> and then to <code>char const*</code> does not constitute a problem (according to standard; Clang still complains about the latter). The lvalue-to-rvalue conversion is one nonetheless:</p>\n<blockquote>\n<p id=\"so_26200827_26201529_2\">an lvalue-to-rvalue conversion (4.1) unless it is applied to <br>\u2014 a\n  glvalue of integral or enumeration type that refers to a non-volatile\n  const object with a preceding initialization, initialized with a\n  constant expression, or <br>\u2014 a glvalue of literal type that refers to a\n  non-volatile object defined with <code>constexpr</code>, or that refers to a\n  sub-object of such an object, or <br>\u2014 a glvalue of literal type that\n  refers to a non-volatile temporary object whose lifetime has not\n  ended, initialized with a constant expression;</br></br></br></p>\n</blockquote>\n<p>The first two bullets can't apply here; Neither has any <code>char</code>/<code>unsigned</code>/etc. object been initialized precedingly, nor did we define any such object with <code>constexpr</code>.</p>\n<p>The third bullet doesn't apply either. If we write</p>\n<pre><code>char ch = *(char const*)(void const*)&amp;x;\n</code></pre>\n<p>we don't create a <code>char</code> object in the initializer. We access the stored value of <code>x</code> through a glvalue of type <code>char</code>, and use that value to initialize <code>ch</code>.</p>\n<p>Therefore I'd say that such aliasing isn't possible in constant expressions. You may get around this in some implementations with relaxed rules.</p>\n<hr>\n<p>* The paragraph is a list that starts with something like</p>\n<blockquote>\n<p id=\"so_26200827_26201529_3\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless [...]</p>\n</blockquote>\n<p><sub>(The text differs from N3337 to N3797.)</sub></p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-03T17:03:48.760", "Score": "7", "CreationDate": "2014-10-05T09:56:56.197", "ParentId": "26200827", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2016-03-03T17:03:48.760"}});