post_cb({"34328800": {"Id": "34328800", "PostTypeId": "2", "Body": "<p><code>B b = (B) a</code> won't work because no conversion (constructor or conversion operator) was defined.\n<code>B b = (B&amp;) a</code> works because it cast <code>a</code> to a reference to B (downcast by a <code>static_cast</code>), then call copy constructor of B. However in this case, <code>a</code> is not an actual object of <code>B</code> so this is undefined behavior.\nSee [expr.static.cast] in C++ standard</p>\n<blockquote>\n<p id=\"so_34328457_34328800_0\">If the object of type \u201ccv1 B\u201d is actually a subobject of an object of type D, the result refers to the enclosing\n  object of type D. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>and [expr.cast] in C++ standard or <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/explicit_cast</a> and <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/cast_operator</a></p>\n", "LastActivityDate": "2015-12-17T07:20:10.387", "CommentCount": "3", "CreationDate": "2015-12-17T07:20:10.387", "ParentId": "34328457", "Score": "1", "OwnerUserId": "4115625"}, "34328645": {"Id": "34328645", "PostTypeId": "2", "Body": "<p>Class A has private/public members.\nClass B is derived from Class A and may have added more private/public members.</p>\n<p>Class B \"is a\" derivative of Class A. However Class A \"is not a\" derivative of Class B. (IE: You can downcast A-&gt;B but not upcast B-A.) </p>\n<p>The reason is that while B is a kind of A, A is not a kind of B so B's methods/members will not be present (even if a method has the same name in the source code it will not be the same method compiled due to name being obscured by the compiler).</p>\n", "LastActivityDate": "2015-12-17T07:09:38.000", "CommentCount": "2", "CreationDate": "2015-12-17T07:09:38.000", "ParentId": "34328457", "Score": "-1", "OwnerUserId": "5689571"}, "34328623": {"Id": "34328623", "PostTypeId": "2", "Body": "<p>Because the implicit conversion from <code>A</code> to <code>B</code> doesn't exist, and you didn't define an explicit one either.</p>\n<p>Reference casting, on the other hand, is valid because it is allowed for inherited types. More precisely, you can cast both ways between different classes in the same inheritance hierarchy. Same goes for pointers. The related concept is called <em>polymorphism</em>, if you'd like some pointers for further study.</p>\n<p>Do note, however, that it only makes sense for an object that <strong>is</strong> of type <code>B</code>to be cast to <code>B</code>. E. g.:</p>\n<pre><code>B b;\nA&amp; aRef = B; // equivalent of A&amp; ref = (A&amp;)B;\nB&amp; bRef = (B&amp;)aRef;\n</code></pre>\n<p>What you did will fail at runtime as soon as you try to access some data or method of <code>B</code> that does not exist in <code>A</code>. Because your actual object is <code>A</code>, not <code>B</code>.</p>\n<p>Upcasting (from an descendant to an ascendant) is always safe because any object of a class that inherits the base class <strong>is</strong> a valid base object. The downcasting, however, is dangerous for the exact reason I explained above, and should never be done using a C-style cast. Instead, use <code>dynamic_cast</code>:</p>\n<pre><code>B b;\nA&amp; aRef = B;\nB&amp; bRef = dynamic_cast&lt;B&amp;&gt;(aRef);\n</code></pre>\n<p><code>dynamic_cast</code> uses RTTI (run-time type information) to validate the operation and will throw an <code>std::bad_cast</code> exception if the conversion is not valid. This is unlike <code>dynamic_cast</code>ing pointers, in which case the cast returns <code>nullptr</code> instead of throwing an exception.</p>\n", "LastEditorUserId": "634821", "LastActivityDate": "2015-12-17T08:54:25.493", "Score": "1", "CreationDate": "2015-12-17T07:08:02.507", "ParentId": "34328457", "CommentCount": "8", "OwnerUserId": "634821", "LastEditDate": "2015-12-17T08:54:25.493"}, "bq_ids": {"n4140": {"so_34328457_34328800_0": {"length": 15, "quality": 1.0, "section_id": 6028}}, "n3337": {"so_34328457_34328800_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5796}}, "n4659": {"so_34328457_34328800_0": {"length": 15, "quality": 1.0, "section_id": 7527}}}, "34328457": {"ViewCount": "159", "Body": "<p>Precisely, why does <code>B b = (B&amp;) a</code> compile and work whereas <code>B b = (B) a</code> does not in the below program?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {public: void f(){ cout&lt;&lt;\"A\"&lt;&lt;endl;} };\n\nclass B : public A { public: void f(){cout&lt;&lt;\"B\"&lt;&lt;endl;} };\n\nvoid g(A a){  B b = (B&amp;) a; b.f(); }\n\nint main() {\n    B b; g(b);\n    return 0;\n}\n</code></pre>\n<p>Is there something about casting to a derived type with reference that I am missing here ? If I just cast to B, it gives a compile time error that the constructor B(A a) does not exist.</p>\n", "AcceptedAnswerId": "34328623", "Title": "In C++, why does casting to reference of derived type work?", "CreationDate": "2015-12-17T06:58:26.617", "Id": "34328457", "CommentCount": "3", "LastEditDate": "2015-12-17T07:18:50.273", "PostTypeId": "1", "LastEditorUserId": "634821", "LastActivityDate": "2015-12-17T08:54:25.493", "Score": "3", "OwnerUserId": "974766", "Tags": "<c++><inheritance><casting><reference><derived-instances>", "AnswerCount": "3"}});