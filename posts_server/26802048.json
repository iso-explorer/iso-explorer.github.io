post_cb({"bq_ids": {"n4140": {"so_26802048_26802048_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 382}}, "n3337": {"so_26802048_26802048_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 373}}, "n4659": {"so_26802048_26802048_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 397}}}, "26802483": {"Id": "26802483", "PostTypeId": "2", "Body": "<p>Consider this absurd example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    void bar() { std::cout &lt;&lt; \"bar [\" &lt;&lt; i &lt;&lt; \"]\" &lt;&lt; std::endl; }\n    ~A() { std::cout &lt;&lt; \"dtor\" &lt;&lt; std::endl; }\n\n    int i;\n};\n\nA&amp; foo(A&amp;&amp; a) { return a; }\n\nint main()\n{\n    foo(A{4}).bar();\n}\n</code></pre>\n<p>If the lifetime of the temporary wasn't extended to the completion of the full-expression, <code>.bar()</code> would be called on an already-destroyed object, since the lifetime of <code>a</code> ends when <code>foo</code> is complete. As is, this will print: </p>\n<pre><code>bar [4]\ndtor\n</code></pre>\n", "LastActivityDate": "2014-11-07T13:35:07.900", "CommentCount": "1", "CreationDate": "2014-11-07T13:35:07.900", "ParentId": "26802048", "Score": "3", "OwnerUserId": "2069064"}, "26802048": {"ViewCount": "119", "Body": "<p>\u00a712.2/5 (my emphasis)</p>\n<blockquote>\n<p id=\"so_26802048_26802048_0\">The second context is when a reference is bound to a temporary. The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference <strong>except</strong>:</p>\n<ul>\n<li>A temporary bound to a reference ...</li>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</li>\n</ul>\n</blockquote>\n<p>In the snippet below (<a href=\"http://coliru.stacked-crooked.com/a/19b2fe60720d31bf\" rel=\"nofollow\">live example</a>) one can see that the temporary <code>A()</code> is bound to the reference <code>a</code> for the lifetime of the reference, that is, the destructor <code>~A()</code> is invoked at the end of the function <code>f</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A{\n    A() { std::cout &lt;&lt; \"A()\" &lt;&lt; '\\n'; }\n    ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; '\\n'; }\n};\n\nvoid f(A&amp;&amp; a) { std::cout &lt;&lt; \"f()\" &lt;&lt; '\\n'; }\n\nint main()\n{\n    f(A());\n}\n</code></pre>\n", "AcceptedAnswerId": "26802483", "Title": "Why the second bullet point in \u00a712.2/5 is considered an exception to the rule explicited in this paragraph?", "CreationDate": "2014-11-07T13:11:44.317", "Id": "26802048", "CommentCount": "1", "LastEditDate": "2014-11-07T13:13:22.640", "PostTypeId": "1", "LastEditorUserId": "635608", "LastActivityDate": "2014-11-07T13:35:07.900", "Score": "1", "OwnerUserId": "3694387", "Tags": "<c++><c++11><reference><language-lawyer>", "AnswerCount": "1"}});