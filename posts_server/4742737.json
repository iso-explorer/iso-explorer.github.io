post_cb({"4742737": {"ViewCount": "670", "Body": "<p>I am very confused about the standard 10.2/13,</p>\n<blockquote>\n<p id=\"so_4742737_4742737_0\">[ Note: Even if the result of name lookup is unambiguous, use of a name found in multiple subobjects might still be ambiguous (4.11, 5.2.5, 5.3.1, 11.2).\u2014end note ] [ Example:</p>\n</blockquote>\n<pre><code>struct B1 {\n  void f();\n  static void f(int);\n  int i;\n};\nstruct B2 {\n  void f(double);\n};\nstruct I1: B1 { };\nstruct I2: B1 { };\nstruct D: I1, I2, B2 {\n  using B1::f;\n  using B2::f;\n  void g() {\n    f(); // Ambiguous conversion of this\n    f(0); // Unambiguous (static)\n    f(0.0); // Unambiguous (only one B2)\n    int B1::* mpB1 = &amp;D::i; // Unambiguous\n    int D::* mpD = &amp;D::i; // Ambiguous conversion\n  }\n};\n</code></pre>\n<p>I cannot see why this is unambiguous int B1::* mpB1 = &amp;D::i; // Unambiguous</p>\n<p>Visual C++, Gcc  and CLang all say that it is ambiguous access to D::i!</p>\n<p>The wording seems to be related to the core issue #39\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39</a>, and the final proposal is here: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf</a></p>\n<p>I now find that the new algorithm-based wordings (10.2/3-10.2/6) are even more confusing because none of the note in 10.2/9, 10.2/10, 10.2/11, and 10.2/13 fully complies to 10.2/3-10.2/6. I can take 10.2/9-10.2/11 as exceptions, but I am especially confused about 10.2/13. I have no idea on the intention of 10.2/13.</p>\n<p>How should the example in 10.2/13 be looked-up according to the 10.2/3-10.2/6? What's the intention of 10.2/13, i.e., what's the situation that 10.2/13 is considered as an exception of 10.2/3-10.2/6?</p>\n<p>Please give me some hints. Thank you very much.</p>\n<hr>\n<p>After some thinking, I think the intention of 10.2/13 is clearer to me.</p>\n<p>int B1::* mpB1 = &amp;D::i; // Unambiguous</p>\n<p>This should be unambiguous and the current compilers are wrong on this. This is unambiguous because pointer to class members initialization doesn't involve in accessing the object yet.</p>\n<p>int D::* mpD = &amp;D::i; // Ambiguous conversion</p>\n<p>This actually means when convert from int B1::*mpB1 to int D::*mpD, the conversion is ambiguous due to ambiguous base classes.</p>\n</hr>", "AcceptedAnswerId": "4742952", "Title": "C++ class member name lookup issues (regarding the wording of standard n3225)", "CreationDate": "2011-01-20T01:49:10.223", "Id": "4742737", "CommentCount": "1", "LastEditDate": "2011-10-02T10:47:23.537", "PostTypeId": "1", "LastEditorUserId": "34509", "LastActivityDate": "2011-10-02T10:47:23.537", "Score": "2", "OwnerUserId": "534498", "Tags": "<c++><c++11><name-lookup>", "AnswerCount": "4"}, "4742952": {"Id": "4742952", "PostTypeId": "2", "Body": "<p>This:</p>\n<pre><code>int B1::* mpB1 = &amp;D::i; // Unambiguous\n</code></pre>\n<p>Is unambiguous because the result is being assigned to a <code>pointer to member</code> of class B.<br>\nSo it don't matter which <code>i</code> is chosen as the offset is relative to a B member (not the parent D class).</br></p>\n<p>So it is unambiguous to you and me but I don't think the compiler can handle it.</p>\n", "LastEditorUserId": "8123", "LastActivityDate": "2011-01-20T02:42:47.930", "Score": "2", "CreationDate": "2011-01-20T02:35:01.993", "ParentId": "4742737", "CommentCount": "5", "OwnerUserId": "14065", "LastEditDate": "2011-01-20T02:42:47.930"}, "4753813": {"Id": "4753813", "PostTypeId": "2", "Body": "<p>FWIW, I'm copying over my answer I gave to the usenet copy of this question:</p>\n<blockquote>\n<p id=\"so_4742737_4753813_0\">Hi all,<br>\n  \u00a0<br>\n  I am very confused about the standard n3225 10.2/13,\n  \u00a0<br>\n  [ Note: Even if the result of name lookup is unambiguous, use of a\n  name found in multiple subobjects might still be ambiguous (4.11,\n  5.2.5, 5.3.1, 11.2).\u2014end note ] [ Example:\n  \u00a0</br></br></br></p>\n</blockquote>\n<pre><code>struct B1 {\n\u00a0\u00a0void f();\n\u00a0\u00a0static void f(int);\n\u00a0\u00a0int i;\n};\nstruct B2 {\n\u00a0\u00a0void f(double);\n};\nstruct I1: B1 { };\nstruct I2: B1 { };\nstruct D: I1, I2, B2 {\n\u00a0\u00a0using B1::f;\n\u00a0\u00a0using B2::f;\n\u00a0\u00a0void g() {\n\u00a0\u00a0\u00a0\u00a0f(); // Ambiguous conversion of this\n\u00a0\u00a0\u00a0\u00a0f(0); // Unambiguous (static)\n\u00a0\u00a0\u00a0\u00a0f(0.0); // Unambiguous (only one B2)\n\u00a0\u00a0\u00a0\u00a0int B1::* mpB1 = &amp;D::i; // Unambiguous\n\u00a0\u00a0\u00a0\u00a0int D::* mpD = &amp;D::i; // Ambiguous conversion\n\u00a0\u00a0}\n};\n</code></pre>\n<blockquote>\n<p id=\"so_4742737_4753813_1\">I cannot see why this is unambiguous int B1::* mpB1 = &amp;D::i; //\n  Unambiguous\n  \u00a0</p>\n</blockquote>\n<p><code>&amp;D::i</code> has type <code>int B1::*</code>, and unambiguously refers to data member <code>i</code> of\u00a0\n<code>B1</code>. If you dereference it with a <code>D</code> object or if you assign it to a <code>int\u00a0\nD::*</code>, you will get an ambiguity as needed.\u00a0</p>\n<blockquote>\n<p id=\"so_4742737_4753813_2\">Visual C++, Gcc and CLang all say that it is ambiguous access to D::i!\n  \u00a0</p>\n</blockquote>\n<p>None of those compilers implement 10.2 yet.\u00a0</p>\n<blockquote>\n<p id=\"so_4742737_4753813_3\">The wording seems to be related to the core issue #39\n  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39</a>, and\n  the final proposal is here:\n  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf</a>\n  \u00a0\n  I now find that the new algorithm-based wordings (10.2/3-10.2/6) are\n  even more confusing because none of the note in 10.2/9, 10.2/10,\n  10.2/11, and 10.2/13 fully complies with 10.2/3-10.2/6. I can take\n  10.2/9-10.2/11 as exceptions, but I am especially confused about\n  10.2/13. I have no idea on the intention of 10.2/13.\n  \u00a0</p>\n</blockquote>\n<p>You need to give examples that show what you don't understand.\u00a0</p>\n<blockquote>\n<p id=\"so_4742737_4753813_4\">How should the example in 10.2/13 be looked-up according to the\n  10.2/3-10.2/6? What's the intention of 10.2/13, i.e., what's the\n  situation of which 10.2/13 is considered as an exception of\n  10.2/3-10.2/6?\n  \u00a0</p>\n</blockquote>\n<p>The new algorithm based lookup rules decouples runtime concerns (finding an\u00a0\nunique object) from compile time/lookup concerns (finding a declaration that\u00a0\na name refers to).\u00a0</p>\n<p>The following is well-formed with the new wording:</p>\n<pre><code>struct Z { int z; };\nstruct X : Z { };\nstruct Y : Z { };\nstruct A : X, Y { };\n\nstruct B : A {\n\u00a0\u00a0using A::z;\n};\n</code></pre>\n<p>The declaration <code>using A::x;</code> introduces a member name into B that refers to\u00a0\nthe declaration <code>Z::z</code>. In a declarative context, this is perfectly fine. An\u00a0\nerror is risen only when you access <code>B::z</code> as a member access expression\u00a0\n(5.2.5).\u00a0</p>\n<p>Don't feel bad about having mistaken this about the member pointer case. <a href=\"https://groups.google.com/group/comp.std.c++/browse_thread/thread/08a0300a0b7641e2\" rel=\"nofollow\">I did so too</a> in the past, and the corresponding <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#983\" rel=\"nofollow\">issue report</a> actually made it into a C++0x draft. They luckily <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1121\" rel=\"nofollow\">changed it back</a> when they noticed that change was wrong. </p>\n", "LastActivityDate": "2011-01-20T23:21:55.410", "CommentCount": "0", "CreationDate": "2011-01-20T23:21:55.410", "ParentId": "4742737", "Score": "0", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_4742737_4742737_0": {"length": 13, "quality": 0.65, "section_id": 7001}}, "n3337": {"so_4742737_4742737_0": {"length": 13, "quality": 0.65, "section_id": 6747}}, "n4659": {"so_4742737_4742737_0": {"length": 13, "quality": 0.65, "section_id": 8498}}}, "4743028": {"Id": "4743028", "PostTypeId": "2", "Body": "<p>For the B1::* case, the interpretation is unambiguous, simply being the offset from the start of B1 to i.</p>\n<p>In 5.3.1/3:</p>\n<pre><code>struct A { int i; };\nstruct B : A { };\n... &amp;B::i ... // has type int A::*\n</code></pre>\n<p>So the trick is to make &amp;D::i be of type B1::* in the first place. Then:</p>\n<pre><code>int B1::* mpB1 = &amp;D::i; // Unambiguous\n</code></pre>\n<p>is simple. The interest then comes in:</p>\n<pre><code>int D::* mpD = &amp;D::i; // Ambiguous conversion\n</code></pre>\n<p>Here the RHS is of type B1::* and needs a conversion as we need to determine which base is being referred to.</p>\n", "LastEditorUserId": "540026", "LastActivityDate": "2011-01-20T22:43:26.207", "Score": "4", "CreationDate": "2011-01-20T02:55:22.287", "ParentId": "4742737", "CommentCount": "2", "OwnerUserId": "540026", "LastEditDate": "2011-01-20T22:43:26.207"}, "4742798": {"Id": "4742798", "PostTypeId": "2", "Body": "<p>A quick check on ISO IEC 14882 2003 Section 10 does not have this example, or anything similar to this. C++0x is <em>draft</em> standard, and VC++/GCC/CLang are not compliant to it.</p>\n<p>My Guess: This is some byproduct of the new <code>auto</code> typing and not found in older C++ standard.  </p>\n", "LastActivityDate": "2011-01-20T02:00:44.960", "CommentCount": "0", "CreationDate": "2011-01-20T02:00:44.960", "ParentId": "4742737", "Score": "0", "OwnerUserId": "88442"}});