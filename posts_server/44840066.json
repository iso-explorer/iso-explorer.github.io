post_cb({"44841232": {"Id": "44841232", "PostTypeId": "2", "Body": "<p>According to the standard <em>\u00a76.6.2/p2 Static initialization [basic.start.static]</em>:</p>\n<blockquote>\n<p id=\"so_44840066_44841232_0\">Constant initialization is performed if a variable or temporary object\n  with static or thread storage duration is initialized by a constant\n  initializer for the entity.</p>\n</blockquote>\n<p>Now, at the moment of <code>d</code>'s initialization the compiler sees that <code>c</code> is not statically initialized yet (i.e., not defined yet). Therefore, the initializer of <code>d</code> doesn't qualify as a constant expression and consequently the initialization of <code>d</code> qualifies as a dynamic initialization. Because static initialization happens before dynamic initialization, <code>c</code> is going to be initialized before <code>d</code> and therefore at the time of <code>d</code>'s. initialization <code>c</code> is already initialized and therefore the code qualifies as valid.</p>\n<p>Now, if you change the order of initialization or you initialize <code>c</code> inline, the initializer of <code>d</code> qualifies as a constant expression because the compiler at the moment of <code>d</code>'s initialization has already seen the static initialization of <code>c</code> (i.e., the definition of <code>c</code>).</p>\n<p>Now, the answer as to why in the first case the initializer of <code>d</code> is not a constant expression is given by <em>\u00a78.20/p2 Constant expressions [expr.const]</em> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44840066_44841232_1\"><sub>2</sub> An expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (4.6),\n  would evaluate one of the following expressions:</p>\n<p id=\"so_44840066_44841232_2\">...</p>\n<p id=\"so_44840066_44841232_3\"><sub>2.7</sub> \u2014 an lvalue-to-rvalue conversion (7.1) unless it is applied to</p>\n<p id=\"so_44840066_44841232_4\"><sub>2.7.1</sub>\u2014 a non-volatile glvalue of integral or enumeration type that refers <em>to a complete non-volatile const object with a preceding initialization</em>, initialized with a constant expression.</p>\n</blockquote>\n<p>In the expression 10 * c, c has no preceding initialization therefore is not a constant expression.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2017-06-30T21:25:27.120", "Score": "4", "CreationDate": "2017-06-30T07:43:16.560", "ParentId": "44840066", "CommentCount": "2", "LastEditDate": "2017-06-30T21:25:27.120", "OwnerUserId": "2352671"}, "bq_ids": {"n4140": {"so_44840066_44841232_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6185}, "so_44840066_44841232_4": {"length": 14, "quality": 0.875, "section_id": 6185}, "so_44840066_44841232_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7151}}, "n3337": {"so_44840066_44841232_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6895}, "so_44840066_44841232_4": {"length": 13, "quality": 0.8125, "section_id": 5946}}, "n4659": {"so_44840066_44841232_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 7687}, "so_44840066_44841232_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8652}, "so_44840066_44841232_4": {"length": 15, "quality": 0.9375, "section_id": 7687}}}, "44840066": {"ViewCount": "208", "Body": "<p>Considering the <a href=\"http://en.cppreference.com/w/cpp/language/constant_initialization\" rel=\"noreferrer\">example from this page</a>, reproduced below </p>\n<pre><code>struct S {\n    static const int c;\n};\nconst int d = 10 * S::c; // not a constant expression: S::c has no preceding\n                         // initializer, this initialization happens after const\nconst int S::c = 5;      // constant initialization, guaranteed to happen first\n</code></pre>\n<p>Why is the initialization of <code>d</code> not a constant expression (and therefore not a part of the constant initialization process)?  The comment seems to say that it is because it uses a value that does not have a preceding initializer, but that does not seem to be mentioned in the list of conditions that qualify an expression to be a constant expression (The conditions are listed <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"noreferrer\">here</a>).  In particular which condition that qualifies something to be a constant expression does it violate?    </p>\n<p>If it has something to do with the fact that constant intialization has to be evaluated at compile time, then the standard mentions that constant initialization does not need to happen at compile time, and can even happen at say for example load time.  Then why not just initialize <code>c</code> at compile time and just <code>d</code> at load time?  (I might be thinking myself into a circle here)</p>\n<hr>\n<p><a href=\"https://stackoverflow.com/questions/44840066/why-does-this-using-another-constant-variable-defined-later-qualify-an-expressio#comment76660699_44840066\">Thanks to Jayesh</a> I was able to find a similar question <a href=\"https://stackoverflow.com/questions/7625952/surprising-constant-initialization-because-of-definition-order\">\"surprising\" constant initialization because of definition order</a> but the answer seems to talk about an lvalue to rvalue conversion,  where is the lvalue to rvalue conversion here?  Other than that there was no quote from the standard there about which condition was being violated here.   The answers also don't explain why the initialization is not split up into being at load time and at compile time.  </p>\n</hr>", "Title": "Why does this using another constant variable defined later qualify an expression as a non constant expression", "CreationDate": "2017-06-30T06:35:09.043", "LastActivityDate": "2017-06-30T21:25:27.120", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-06-30T07:13:44.493", "LastEditorUserId": "5501675", "Id": "44840066", "Score": "10", "OwnerUserId": "5501675", "Tags": "<c++><c++14><language-lawyer><c++1z>", "AnswerCount": "1"}});