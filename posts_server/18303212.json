post_cb({"18303212": {"ViewCount": "583", "Body": "<p>Assume you've got the following definitions:</p>\n<pre><code>struct X\n{\n  char a, b;\n};\n\nX x;\n</code></pre>\n<p>And now assume you have two threads, one of which reads and writes <code>x.a</code> but never accesses <code>x.b</code> while the other one reads and writes <code>x.b</code> but never accesses <code>x.a</code>. Neither thread uses any locks or other synchronization primitives. Is this guaranteed to work in C++11? Or does it count as accessing the same object, and therefore need a lock?</p>\n", "AcceptedAnswerId": "18303363", "Title": "C++11 memory model and accessing different members of the same struct in different threads", "CreationDate": "2013-08-18T20:12:29.487", "Id": "18303212", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-08-18T20:31:23.920", "Score": "16", "OwnerUserId": "1032073", "Tags": "<c++><multithreading><c++11><memory-model>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18303212_18303363_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 5789}, "so_18303212_18303363_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5787}}, "n3337": {"so_18303212_18303363_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 5562}, "so_18303212_18303363_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5560}}, "n4659": {"so_18303212_18303363_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 7246}, "so_18303212_18303363_0": {"length": 41, "quality": 0.8723404255319149, "section_id": 7244}}}, "18303363": {"Id": "18303363", "PostTypeId": "2", "Body": "<p>It's safe. Quoting C++11:</p>\n<p>[intro.memory]p3:</p>\n<blockquote>\n<p id=\"so_18303212_18303363_0\">A <em>memory location</em> is either an object of scalar type or a maximal sequence of adjacent bit-fields all having non-zero width. [ <em>Note:</em> Various features of the language, such as references and virtual functions, might involve additional memory locations that are not accessible to programs but are managed by the implementation. <em>\u2014end note</em> ] Two threads of execution (1.10) can update and access separate memory locations without interfering with each other.</p>\n</blockquote>\n<p>[intro.memory]p5:</p>\n<blockquote>\n<p id=\"so_18303212_18303363_1\">[ <em>Example:</em> A structure declared as</p>\n</blockquote>\n<pre><code>struct {\n  char a;\n  int b:5,\n  c:11,\n  :0,\n  d:8;\n  struct {int ee:8;} e;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_18303212_18303363_2\">contains four separate memory locations: The field <code>a</code> and bit-fields <code>d</code> and <code>e.ee</code> are each separate memory locations, and can be modified concurrently without interfering with each other. The bit-fields <code>b</code> and <code>c</code> together constitute the fourth memory location. The bit-fields <code>b</code> and <code>c</code> cannot be concurrently modified, but <code>b</code> and <code>a</code>, for example, can be. <em>\u2014end example</em> ]</p>\n</blockquote>\n<p>These together mean that the members <code>a</code> and <code>b</code> of <code>X</code> are separate memory locations, and can thus be accessed concurrently.</p>\n", "LastActivityDate": "2013-08-18T20:31:23.920", "CommentCount": "6", "CreationDate": "2013-08-18T20:31:23.920", "ParentId": "18303212", "Score": "23", "OwnerUserId": "1782465"}});