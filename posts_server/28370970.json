post_cb({"bq_ids": {"n4140": {"so_28370970_28371763_0": {"section_id": 302, "quality": 0.9, "length": 27}}, "n3337": {"so_28370970_28371763_0": {"section_id": 293, "quality": 0.9, "length": 27}}, "n4659": {"so_28370970_28371763_0": {"section_id": 309, "quality": 0.9, "length": 27}}}, "28371080": {"ParentId": "28370970", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's not that it can't bind to the parameter of your function; it's just that the compiler is unable to detect the type of your template. This compiles:</p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nvoid foo(T&amp;&amp; v)\n{\n  std::vector&lt;int&gt;(std::forward&lt;T&gt;(v));\n}\n\nint main()\n{\n  foo(std::initializer_list&lt;int&gt;{1, 2, 3});\n}\n</code></pre>\n", "OwnerUserId": "1147772", "LastEditorUserId": "63550", "LastEditDate": "2017-10-06T19:05:38.977", "Id": "28371080", "Score": "10", "CreationDate": "2015-02-06T17:10:29.893", "LastActivityDate": "2017-10-06T19:05:38.977"}, "28370970": {"CommentCount": "7", "AcceptedAnswerId": "28371080", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2015-02-06T17:04:29.347", "LastActivityDate": "2017-10-06T19:05:38.977", "LastEditDate": "2017-10-06T19:04:48.630", "ViewCount": "1675", "FavoriteCount": "1", "Title": "Forwarding initializer list expressions", "Id": "28370970", "Score": "10", "Body": "<p>Initializer list expressions are really convenient for initializing C++ containers:</p>\n<pre><code>std::vector&lt;int&gt;({1, 2, 3})\n</code></pre>\n<p>...but it seems that a brace-enclosed initializer list expression, like <code>{1,2,3}</code> will <em>only</em> bind to a function that takes a <code>std::initializer_list&lt;int&gt;</code> - it <em>doesn't</em> seem to bind to a <em>universal (forwarding) reference</em>:</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T&amp;&amp; v)\n{\n  std::vector&lt;int&gt;(std::forward&lt;T&gt;(v));\n}\n\nint main()\n{\n  foo({1, 2, 3})\n}\n</code></pre>\n<p>This outputs:</p>\n<pre><code>test2.cpp:11:6: note: template&lt;class U&gt; void foo(U&amp;&amp;)\ntest2.cpp:11:6: note:   template argument deduction/substitution failed:\ntest2.cpp:33:13: note:   couldn't deduce template parameter \u2018U\u2019\n</code></pre>\n<p>(This was the result with GCC 4.7.2.)</p>\n<p>This unfortunately means we can't forward an initializer list expression.  Since it would be very convenient to do that, I'd like to ask why is it that this doesn't work? Why can't a brace enclosed initializer list expression bind to a forwarding reference? Or is this allowed, and perhaps my compiler is just too old?</p>\n", "Tags": "<c++><templates><c++11><initializer-list>", "OwnerUserId": "2923952", "AnswerCount": "2"}, "28371763": {"ParentId": "28370970", "CommentCount": "0", "Body": "<p>The initializer list cannot be deduced in this case. This is actually covered explicitly by the standard in [temp.deduct.call]:</p>\n<blockquote>\n<p id=\"so_28370970_28371763_0\">Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with\n  the type of the corresponding argument of the call (call it <code>A</code>) as described below. If <code>P</code> is a dependent type,\n  [...].  Otherwise, an initializer list argument causes the parameter to be considered a non-deduced\n  context (14.8.2.5). [ Example:  </p>\n<pre><code>template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);\nf({1,2,3}); // T deduced to int\nf({1,\"asdf\"}); // error: T deduced to both int and const char*\n\ntemplate&lt;class T&gt; void g(T);\ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n</blockquote>\n<p>The example here for <code>g</code> is exactly your case - <code>T</code> is not a dependent type, so this is considered to be a non-deduced context. The compiler is correct to reject your code.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "28371763", "Score": "3", "CreationDate": "2015-02-06T17:50:44.160", "LastActivityDate": "2015-02-06T17:50:44.160"}});