post_cb({"7269099": {"ViewCount": "4583", "Body": "<p>Consider the following code:</p>\n<pre><code>int a[25][80];\na[0][1234] = 56;\nint* p = &amp;a[0][0];\np[1234] = 56;\n</code></pre>\n<p>Does the second line invoke undefined behavior? How about the fourth line?</p>\n", "AcceptedAnswerId": "7273599", "Title": "May I treat a 2D array as a contiguous 1D array?", "CreationDate": "2011-09-01T10:35:14.940", "Id": "7269099", "CommentCount": "4", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2014-06-20T00:26:59.910", "Score": "29", "OwnerUserId": "252000", "Tags": "<c++><arrays><pointers><multidimensional-array><undefined-behavior>", "AnswerCount": "5"}, "7269136": {"PostTypeId": "2", "Body": "<p>You're free to reinterpret the memory any way you'd like. As long as the multiple does not exceed the linear memory. You can even move a to 12, 40 and use negative indexes.</p>\n", "LastActivityDate": "2011-09-01T10:39:10.473", "Id": "7269136", "CommentCount": "0", "CreationDate": "2011-09-01T10:39:10.473", "ParentId": "7269099", "Score": "0", "OwnerUserId": "664328"}, "bq_ids": {"n4140": {"so_7269099_24318220_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 7190}}, "n3337": {"so_7269099_24318220_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 6934}}}, "24318220": {"Id": "24318220", "PostTypeId": "2", "Body": "<p>The memory referenced by <code>a</code> is both a <code>int[25][80]</code> and a <code>int[2000]</code>.  So says the Standard, 3.8p2:</p>\n<blockquote>\n<p id=\"so_7269099_24318220_0\">[ Note:  The lifetime of an array object starts as soon as storage with proper size and alignment is obtained, and its lifetime ends when the storage which the array occupies is reused or released.  12.6.2 describes the lifetime of base and member subobjects.  \u2014 end note ]</p>\n</blockquote>\n<p><code>a</code> has a particular type, it is an lvalue of type <code>int[25][80]</code>.  But <code>p</code> is just <code>int*</code>.  It is not \"<code>int*</code> pointing into a <code>int[80]</code>\" or anything like that.  So in fact, the <code>int</code> pointed to is an element of <code>int[25][80]</code> named <code>a</code>, and also an element of <code>int[2000]</code> occupying the same space.</p>\n<p>Since <code>p</code> and <code>p+1234</code> are both elements of the same <code>int[2000]</code> object, the pointer arithmetic is well-defined.  And since <code>p[1234]</code> means <code>*(p+1234)</code>, it too is well-defined.</p>\n<p>The effect of this rule for array lifetime is that you can freely use pointer arithmetic to move through a complete object.</p>\n<hr>\n<p>Since <code>std::array</code> got mentioned in the comments:</p>\n<p>If one has <code>std::array&lt;std::array&lt;int, 80&gt;, 25&gt; a;</code> then there <strong>does not exist</strong> a <code>std::array&lt;int, 2000&gt;</code>.  There does exist a <code>int[2000]</code>.  I'm looking for anything that requires <code>sizeof (std::array&lt;T,N&gt;) == sizeof (T[N])</code> (and <code>== N * sizeof (T)</code>).  Absent that, you have to assume that there could be gaps which mess up traversal of nested <code>std::array</code>.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2014-06-20T00:26:59.910", "CommentCount": "16", "CreationDate": "2014-06-20T00:19:12.703", "ParentId": "7269099", "Score": "1", "OwnerUserId": "103167", "LastEditDate": "2014-06-20T00:26:59.910"}, "7273599": {"PostTypeId": "2", "Body": "<p>It's up to interpretation. While the contiguity requirements of arrays don't leave much to the imagination in terms of how to layout a multidimensional arrays (this has been pointed out before), notice that when you're doing <code>p[1234]</code> you're indexing the 1234th element of the zeroth row of only 80 columns. Some interpret the only valid indices to be 0..79 (<code>&amp;p[80]</code> being a special case).</p>\n<p>Information from the <a href=\"http://c-faq.com/aryptr/ary2dfunc2.html\" rel=\"noreferrer\">C FAQ</a> which is the collected wisdom of Usenet on matters relevant to C. (I do not think C and C++ differ on that matter and that this is very much relevant.)</p>\n", "LastActivityDate": "2011-09-01T16:47:25.447", "Id": "7273599", "CommentCount": "1", "CreationDate": "2011-09-01T16:47:25.447", "ParentId": "7269099", "Score": "6", "OwnerUserId": "726300"}, "7269121": {"PostTypeId": "2", "Body": "<p>Yes, you can(no, it's not UB), it is indirectly guaranteed by the standard. Here's how: a 2D array is an array of arrays. An array is guaranteed to have contiguous memory and <code>sizeof(array)</code> is <code>sizeof(elem)</code> times number of elements. From these it follows that what you're trying to do is perfectly legal.</p>\n", "LastActivityDate": "2011-09-01T10:37:47.050", "Id": "7269121", "CommentCount": "7", "CreationDate": "2011-09-01T10:37:47.050", "ParentId": "7269099", "Score": "9", "OwnerUserId": "469935"}, "7269223": {"PostTypeId": "2", "Body": "<p>Your compiler will throw a bunch of warnings/errors because of subscript out of range (line 2) and incompatioble types (line 3), but as long as the actual variable (int in this case) is one of the intrinsic base-types this is save to do in C and C++.\n(If the variable is a class/struct it will probably still work in C, but in C++ all bets are off.) </p>\n<p>Why you would want to do this.... \nFor the 1st variant: If your code relies on this sort of messing about it will be error-prone and hard to maintain in the long run.</p>\n<p>I can see a some use for the second variant when performance optimizing loops over 2D arrays by replacing them by a 1D pointer run over the data-space, but a good optimizing compiler will often do that by itself anyway.\nIf the body of the loop is so big/complex the compiler can't optimize/replace the loop by a 1D run on it's own, the performance gain by doing it manually will most likely not be significant either.</p>\n", "LastActivityDate": "2011-09-01T10:46:50.540", "Id": "7269223", "CommentCount": "1", "CreationDate": "2011-09-01T10:46:50.540", "ParentId": "7269099", "Score": "0", "OwnerUserId": "658762"}});