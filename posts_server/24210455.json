post_cb({"24210455": {"ViewCount": "240", "Body": "<p>Do lambda function have a signature so that I can pass them around?</p>\n<pre><code>template&lt;class Fn&gt; \nHRESULT foreach(Fn _fuction)\n{\n\n}\n\n\nobject-&gt;foreach(\n    [param1, param2] (int item) \n    {\n    }\n);\n\nobject-&gt;foreach(\n    [param1, param2, param3] (int item) \n    {\n    }\n);\n</code></pre>\n<p>I want to use a typedef function instead of templates, I think the type of the function will strict the formal parameters but will allow captured list to vary.</p>\n<p>can I use typedef instead of templates to pass lambda functions around?</p>\n<p>something like:</p>\n<pre><code>typedef void (*Fn)(int);\n</code></pre>\n<p>but allows lambda not function pointer.</p>\n<p>I tried using std::fuction but seems not working.</p>\n", "Title": "Passing lambda functions to other methods", "CreationDate": "2014-06-13T17:03:43.187", "LastActivityDate": "2014-06-13T17:23:10.240", "CommentCount": "4", "PostTypeId": "1", "Id": "24210455", "Score": "0", "OwnerUserId": "506952", "Tags": "<c++><lambda>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24210455_24210746_0": {"length": 13, "quality": 0.8125, "section_id": 5962}}, "n3337": {"so_24210455_24210746_0": {"length": 13, "quality": 0.8125, "section_id": 5731}}, "n4659": {"so_24210455_24210746_0": {"length": 12, "quality": 0.75, "section_id": 7451}}}, "24210486": {"Id": "24210486", "PostTypeId": "2", "Body": "<p>The actual type of a lambda is unspecified. But they are convertible to <code>function</code>; in your case, <code>std::function&lt;void(int)&gt;</code> (<code>void</code> is the return type, the parameter types go in the parentheses).</p>\n", "LastActivityDate": "2014-06-13T17:05:42.050", "CommentCount": "2", "CreationDate": "2014-06-13T17:05:42.050", "ParentId": "24210455", "Score": "0", "OwnerUserId": "3549027"}, "24210746": {"Id": "24210746", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24210455_24210746_0\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a <strong>unique</strong>, unnamed non-\n  union class type \u2014 called the <em>closure type</em> ...</p>\n</blockquote>\n<p>(C++11 \u00a75.1.2/3, emphasis mine)</p>\n<p>My reading of this is that even if two lambda-expressions have the same parameter list, return type, and capture list, they nevertheless have different types.</p>\n<pre><code>auto f = []{};\ntypedef decltype(f) lambda_type;\nvoid g(lambda_type lambda) { lambda(); }\nint main() {\n    g(f);    // OK\n    g([]{}); // error: type mismatch\n}\n</code></pre>\n<p>So no, what you are trying to do cannot be done. As others have suggested, try using <code>std::function</code>, or retain the template (what's wrong with templates, anyway?)</p>\n", "LastActivityDate": "2014-06-13T17:23:10.240", "CommentCount": "0", "CreationDate": "2014-06-13T17:23:10.240", "ParentId": "24210455", "Score": "1", "OwnerUserId": "481267"}});