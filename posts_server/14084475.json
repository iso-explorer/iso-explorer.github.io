post_cb({"bq_ids": {"n4140": {"so_14084475_14084616_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 817}}, "n3337": {"so_14084475_14084616_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 806}}, "n4659": {"so_14084475_14084616_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 876}}}, "14084616": {"Id": "14084616", "PostTypeId": "2", "Body": "<p>The problem is that you're inserting item to <code>std::deque</code> which invalidates the iterator which you're incrementing in the <code>for</code> loop:</p>\n<p>The Standard (draft n3485) says in \u00a723.3.3.4/1 (emphasize mine),</p>\n<blockquote>\n<p id=\"so_14084475_14084616_0\">Effects: <strong>An insertion</strong> in the middle of the deque <strong>invalidates all the iterators</strong> and references to elements of the deque. <strong>An insertion</strong> at either end of the deque <strong>invalidates all the iterators</strong> to the deque, but has no effect on the validity of references to elements of the deque.</p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2012-12-29T18:28:44.353", "Score": "2", "CreationDate": "2012-12-29T18:21:21.183", "ParentId": "14084475", "CommentCount": "0", "LastEditDate": "2012-12-29T18:28:44.353", "OwnerUserId": "415784"}, "14084573": {"Id": "14084573", "PostTypeId": "2", "Body": "<p>Segfaults can come from any number of sources, and don't always manifest immediately.  Chances are you're overflowing an array, using the stl containers in an invalid manner, or the like -- when you corrupt areas of memory you don't own that might be used for e.g. allocation accounting, it can make future allocations, frees, moves, or any other indirect accesses fail spectacularly.</p>\n<p>Bringing out the big guns may help solve this quickly!  You can use <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">valgrind</a>'s memcheck module if you're on a system that will run valgrind, or you can use something like <a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=20028\" rel=\"nofollow noreferrer\">Application Verifier</a> on Windows.</p>\n<p>Your compiler or libraries may have standard library / STL debugging functionality -- if you're in an IDE, poke around to see what options you have available.  For libstdc++ (often used with gcc/g++), you can look at the <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/debug.html\" rel=\"nofollow noreferrer\">libstdc++ Debugging Support options</a>.</p>\n<p>Here's my <a href=\"https://stackoverflow.com/questions/1010106/how-to-debug-heap-corruption-errors/1010811#1010811\">earlier answer to a question about heap corruption</a> which discusses such tools, and my <a href=\"https://stackoverflow.com/questions/1152511/any-reason-to-overload-global-new-and-delete/1215807#1215807\">list of reasons you might want to overload operator new and delete</a> also has another list of tools.  (Shameless self-promotion, here, but I think these are pretty good lists!)</p>\n<hr>\n<p>Based on your code I'd say you're invalidating the loop iterator.  From <a href=\"http://www.sgi.com/tech/stl/Deque.html\" rel=\"nofollow noreferrer\">http://www.sgi.com/tech/stl/Deque.html</a>:</p>\n<blockquote>\n<p id=\"so_14084475_14084573_0\">The semantics of iterator invalidation for deque is as follows. Insert\n  (including push_front and push_back) invalidates all iterators that\n  refer to a deque. Erase in the middle of a deque invalidates all\n  iterators that refer to the deque. Erase at the beginning or end of a\n  deque (including pop_front and pop_back) invalidates an iterator only\n  if it points to the erased element.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-29T18:16:44.950", "Score": "1", "CreationDate": "2012-12-29T18:16:44.950", "ParentId": "14084475", "CommentCount": "0", "LastEditDate": "2017-05-23T11:56:41.870", "OwnerUserId": "80074"}, "14084475": {"ViewCount": "954", "Body": "<p>I have a <code>deque&lt;rect*&gt; rects</code> where <code>rect</code> is a user-defined class. When I try to <code>insert</code> a <code>rect*</code> into it, I get a segmentation fault. <code>gdb</code> traces the problem back to a function called <code>__memmove_sse3()</code> from my calling <code>rects.insert(it,new rect([constructor parameters]));</code>  where <code>it</code> is a <code>deque&lt;rect*&gt;::iterator</code>. What could cause this error?</p>\n<p>EDIT:\nhere is a snippet of my code:</p>\n<pre><code>for(deque&lt;rect*&gt;::iterator it=rects.begin();it!=rects.end();++it)\n        {\n            rect r=*r1;\n            rect r2=*(*it);\n            if(!r2.there)\n                continue;\n            if(r.down&gt;r2.up || r.up&lt;r2.down || r.right&lt;r2.left || r.left&gt;r2.right)\n                continue;\n            if(r.left&gt;r2.left)\n                rects.insert(it,new rect(r2.left,r2.down,r.left,r2.up,r2.color));\n            if(r.right&lt;r2.right)\n                rects.insert(it,new rect(r.right,r2.down,r2.right,r2.up,r2.color));\n            if(r.up&lt;r2.up)\n                rects.insert(it,new rect(max(r.left,r2.left),r.up,min(r.right,r2.right),r2.up,r2.color));\n            if(r.down&gt;r2.down)\n                rects.insert(it,new rect(max(r.left,r2.left),r2.down,min(r.right,r2.right),r.down,r2.color));\n            r2.there=false;\n        }\n</code></pre>\n", "AcceptedAnswerId": "14084616", "Title": "Segmentation faults in deque of user-defined pointers", "CreationDate": "2012-12-29T18:03:50.210", "Id": "14084475", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-12-29T18:17:23.673", "LastEditorUserId": "931721", "LastActivityDate": "2012-12-29T18:28:44.353", "Score": "0", "OwnerUserId": "931721", "Tags": "<c++><segmentation-fault><deque>", "AnswerCount": "2"}});