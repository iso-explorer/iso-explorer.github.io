post_cb({"13506734": {"CommentCount": "5", "CreationDate": "2012-11-22T06:05:42.767", "PostTypeId": "1", "AcceptedAnswerId": "13507227", "LastEditorUserId": "1498580", "LastActivityDate": "2012-11-25T18:58:43.270", "LastEditDate": "2012-11-22T06:12:30.877", "ViewCount": "166", "FavoriteCount": "2", "Title": "sizeof of two template types, when both are derived from one base", "Id": "13506734", "Score": "7", "Body": "<p>Sample code</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct base {};\n\ntemplate&lt;typename Type&gt;\nstruct left : base {\n\n   Type value;\n};\n\ntemplate&lt;typename Type&gt;\nstruct right : base {\n\n   Type value;\n}; \n\nint main() {\n   std::cout &lt;&lt; \"sizeof left&lt;base&gt; = \" &lt;&lt; sizeof(left&lt;base&gt;) &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"sizeof left&lt;right&lt;base&gt;&gt;    = \" &lt;&lt; sizeof(left&lt;right&lt;base&gt;&gt;) &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"sizeof left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt; = \" &lt;&lt; sizeof(left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt;) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output</p>\n<p>With GCC 4.6 is</p>\n<pre><code>sizeof left&lt;base&gt; = 2  \nsizeof left&lt;right&lt;base&gt;&gt;    = 3  \nsizeof left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt; = 6\n</code></pre>\n<p>With clang 3.1</p>\n<pre><code>sizeof left&lt;base&gt; = 2  \nsizeof left&lt;right&lt;base&gt;&gt;    = 3  \nsizeof left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt; = 6\n</code></pre>\n<p>With MSVC 2012</p>\n<pre><code>sizeof left&lt;base&gt; = 1\nsizeof left&lt;right&lt;base&gt;&gt;    = 1\nsizeof left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt; = 1\n</code></pre>\n<p>So, question is, is it bug in GCC/clang, or is it implementation defined, or is it right output (quotes from standard, or explanations of such behaviour will be nice)</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1498580", "AnswerCount": "2"}, "13507081": {"ParentId": "13506734", "CommentCount": "0", "Body": "<p>the GCC behavior is strange but sizeof is totally a compiler issue, so it merely depends on how the compiler as said \nyou may try </p>\n<pre><code>#pragma pack(1) \n</code></pre>\n<p>and see the results again</p>\n", "OwnerUserId": "2079852", "PostTypeId": "2", "Id": "13507081", "Score": "0", "CreationDate": "2012-11-22T06:35:41.410", "LastActivityDate": "2012-11-22T06:35:41.410"}, "bq_ids": {"n4140": {"so_13506734_13507227_0": {"section_id": 5795, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_13506734_13507227_0": {"section_id": 5568, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_13506734_13507227_0": {"section_id": 7254, "quality": 0.9487179487179487, "length": 37}}}, "13507227": {"ParentId": "13506734", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The relevant quote is 1.8 [intro.object] paragraph 6:</p>\n<blockquote>\n<p id=\"so_13506734_13507227_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>In your <code>right&lt;T&gt;</code> and <code>left&lt;T&gt;</code> object (why have to different class templates? One should have been enough) you each have a member <code>value</code> (of type <code>T</code>). Each one needs to get its own unique address. Thus,</p>\n<pre><code>sizeof(left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt;) == 1\n</code></pre>\n<p>is definitely wrong! There are 6 distinct objects:</p>\n<ul>\n<li>5 <code>value</code>s</li>\n<li>one <code>left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt;</code></li>\n</ul>\n<p>and only the <code>left&lt;right&lt;left&lt;right&lt;left&lt;base&gt;&gt;&gt;&gt;&gt;</code> and one of its subjects the (the first <code>value</code> if I recall other rules) can share an address. That is, the size of the object needs to be at least 5. Since objects work best when aligned it seems to get padded to 6 bytes (which is odd; I'd expect it to be padded to a multiple of 4).</p>\n<p>Even size of <code>left&lt;base&gt;</code> could't be <code>1</code>: There are two <code>base</code> objects involved already! One in the form of the base class of <code>lef&lt;base&gt; and one in form of a member of this class. These two</code>base` objects need distinct addresses and, thus, the size needs to be at least 2.</p>\n<p>In any case, object sizes only have requirements how big they are at least. They don't have any requirement that they shall not be bigger than something. This is considered a quality of implementation issue. Based on this, the only compiler being wrong (assuming the sizes quotes are, indeed, correct) is MSVC++. The other sizes may sometimes be slightly bigger than desired but this isn't an error.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2012-11-25T18:58:43.270", "Id": "13507227", "Score": "3", "CreationDate": "2012-11-22T06:49:02.400", "LastActivityDate": "2012-11-25T18:58:43.270"}});