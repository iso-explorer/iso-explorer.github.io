post_cb({"bq_ids": {"n4140": {"so_35039927_35039927_3": {"length": 18, "quality": 1.0, "section_id": 6909}, "so_35039927_35043080_3": {"length": 18, "quality": 1.0, "section_id": 6909}, "so_35039927_35039927_2": {"length": 56, "quality": 0.9824561403508771, "section_id": 3376}}, "n3337": {"so_35039927_35039927_3": {"length": 18, "quality": 1.0, "section_id": 6655}, "so_35039927_35043080_3": {"length": 18, "quality": 1.0, "section_id": 6655}, "so_35039927_35039927_2": {"length": 49, "quality": 0.8596491228070176, "section_id": 3246}}, "n4659": {"so_35039927_35039927_3": {"length": 18, "quality": 1.0, "section_id": 8407}, "so_35039927_35043080_3": {"length": 18, "quality": 1.0, "section_id": 8407}}}, "35039927": {"ViewCount": "319", "Body": "<p>All of GCC 4.8.4, 4.9.3, 5.3.0 pass the tests for <code>std::exception</code> (for any of -std=c++11/1y/14/1z/17 options, where available):</p>\n<pre><code>static_assert(std::is_nothrow_copy_constructible&lt;std::exception&gt;::value, \"test exception\");\nstatic_assert(std::is_nothrow_copy_assignable   &lt;std::exception&gt;::value, \"test exception\");\n</code></pre>\n<p>Which is fine, since <code>std::exception</code> has noexcept special members (C++14 18.8.1):</p>\n<blockquote id=\"so_35039927_35039927_0\">\n<pre><code>namespace std {\n  class exception {\n  public:\n    exception() noexcept;\n    exception(const exception&amp;) noexcept;\n    exception&amp; operator=(const exception&amp;) noexcept;\n    virtual ~exception();\n    virtual const char* what() const noexcept;\n  };\n}\n</code></pre>\n</blockquote>\n<p>Unfortunately, all of the compilers above fail on the following <code>static_assert</code>s:</p>\n<pre><code>static_assert(std::is_nothrow_copy_constructible&lt;std::runtime_error&gt;::value, \"test runtime_error\");\nstatic_assert(std::is_nothrow_copy_assignable   &lt;std::runtime_error&gt;::value, \"test runtime_error\");\n</code></pre>\n<p>The standard contains only the following about <code>std::runtime_error</code> in 19.2.6:</p>\n<blockquote id=\"so_35039927_35039927_1\">\n<pre><code>namespace std {\n  class runtime_error : public exception {\n  public:\n    explicit runtime_error(const string&amp; what_arg);\n    explicit runtime_error(const char* what_arg);\n  };\n}\n</code></pre>\n</blockquote>\n<p>But nothing is said about the <code>noexcept</code>ness of the other (implicitly declared special) members nor the storage implementation requirements of <code>what_arg</code>.</p>\n<p>The standard (C++14) says the following in 15.4/14:</p>\n<blockquote>\n<p id=\"so_35039927_35039927_2\">An inheriting constructor (12.9) and an implicitly declared special\n  member function (Clause 12) have an exception-specification. If f is\n  an inheriting constructor or an implicitly declared default\n  constructor, copy constructor, move constructor, destructor, copy\n  assignment operator, or move assignment operator, its implicit\n  exception-specification specifies the type-id T if and only if T is\n  allowed by the exception-specification of a function directly invoked\n  by f\u2019s implicit definition; f allows all exceptions if any function it\n  directly invokes allows all exceptions, and f has the\n  exception-specification noexcept(true) if every function it directly\n  invokes allows no exceptions.</p>\n</blockquote>\n<p>And the following in 18.8.1/2:</p>\n<blockquote>\n<p id=\"so_35039927_35039927_3\">Each standard library class T that derives from class exception shall\n  have a publicly accessible copy constructor and a publicly\n  accessible copy assignment operator that do not exit with an\n  exception.</p>\n</blockquote>\n<p>Since <code>std::runtime_error</code> does not expose the implementation of the <code>what_arg</code> storage, we do not know whether it's (special) members are noexcept or not, so the noexceptness of <code>std::runtime_error</code>'s copy constructor or copy assignment members are undecidable. Our only bet is 18.8.1 above.</p>\n<p>Question 1/a) We consider <code>std::runtime_error</code>'s copy constructor or copy assignment to be noexcept (<a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/ERR60-CPP.+Exception+objects+must+be+nothrow+copy+constructible\">1</a>, <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/NiPG1hmo4ik/DePB57IPmJwJ\">2</a>). Is this true / state-of-the-art / best practice?</p>\n<p>Question 1/b) Do not we need to explicitly state this in the standard? (Like in 18.8.2, Class <code>bad_exception</code>)</p>\n<p>Question 1/c) Is it a bug in GCC that it fails the static_assert tests above?</p>\n<p>Question 2) If the above deduction is wrong, could someone point me to the section(s) in the standard which state that std::runtime_error has noexcept copy constructor (and copy assignment)? (Or where it states that they are not.)</p>\n", "AcceptedAnswerId": "35043080", "Title": "Are the copy constructor and copy assignment of std::runtime_error noexcept?", "CreationDate": "2016-01-27T14:23:29.073", "Id": "35039927", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-01-27T14:30:05.203", "LastEditorUserId": "2547845", "LastActivityDate": "2016-01-27T16:40:30.910", "Score": "10", "OwnerUserId": "2547845", "Tags": "<c++><exception-handling><c++14>", "AnswerCount": "1"}, "35043080": {"Id": "35043080", "PostTypeId": "2", "Body": "<p>Consider <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1371\" rel=\"nofollow\"><strong>LWG 1371</strong></a>:</p>\n<blockquote>\n<p id=\"so_35039927_35043080_0\">None of the exception types defined in clause 19 are allowed to throw an exception on copy or move operations, but there is no clear specification that the operations have an exception specification to prove it. Note that the implicitly declared constructors, taking the exception specification from their base class (ultimately <code>std::exception</code>) will implicitly generate a <code>noexcept</code> exception specification if all of their data members similarly declare <code>noexcept</code> operations. As the representation is unspecified, we cannot assume nonthrowing operations unless we explicitly state this as a constraint on the implementation.</p>\n<p id=\"so_35039927_35043080_1\"><em>[ Resolution proposed by ballot comment: ]</em></p>\n<p id=\"so_35039927_35043080_2\">Add a global guarantee that all exception types defined in clause 19\n  that rely on implicitly declared operations have a non-throwing\n  exception specification on those operations.</p>\n</blockquote>\n<p>In the 2010 Batavia meeting, it was found that <a href=\"http://eel.is/c++draft/exception#2\" rel=\"nofollow\">[exception]/2</a> \"covered this\":</p>\n<blockquote>\n<p id=\"so_35039927_35043080_3\">Each standard library class T that derives from class <code>exception</code> shall have a publicly accessible copy constructor and a publicly accessible copy assignment operator that do not exit with an exception.</p>\n</blockquote>\n<p>Therefore it still isn't mandated that these special member functions are <code>noexcept</code>. And according to the way that implicit exception specifications  are determined in <a href=\"http://eel.is/c++draft/except.spec#16\" rel=\"nofollow\">[except.spec]/16</a>, since an implementation can add both arbitrary parameters with default arguments and members, it's implementation-specific whether or not these special member functions are <code>noexcept</code>.</p>\n<hr>\n</hr>", "LastActivityDate": "2016-01-27T16:40:30.910", "CommentCount": "0", "CreationDate": "2016-01-27T16:40:30.910", "ParentId": "35039927", "Score": "1", "OwnerUserId": "3647361"}});