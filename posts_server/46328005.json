post_cb({"bq_ids": {"n4140": {"so_46328005_46345014_1": {"length": 13, "quality": 0.6190476190476191, "section_id": 87}, "so_46328005_46345014_0": {"length": 69, "quality": 0.8734177215189873, "section_id": 94}, "so_46328005_46345014_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 91}}, "n3337": {"so_46328005_46345014_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 82}, "so_46328005_46345014_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 86}, "so_46328005_46345014_0": {"length": 46, "quality": 0.5822784810126582, "section_id": 89}}, "n4659": {"so_46328005_46345014_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 90}, "so_46328005_46345014_2": {"length": 13, "quality": 0.7647058823529411, "section_id": 90}, "so_46328005_46345014_0": {"length": 78, "quality": 0.9873417721518988, "section_id": 97}}}, "46328005": {"ViewCount": "146", "Body": "<p>Yet another <code>decltype(auto)</code> template <em>template-parameter</em> question. This time minimal code I was able to create to reproduce the error looks like this:</p>\n<pre><code>template &lt;template &lt;decltype(auto)&gt; class TT, decltype(auto) V&gt;\nvoid foo(TT&lt;V&gt;) {\n};\n\ntemplate &lt;decltype(auto)&gt;\nstruct Bar{};\n\nint x;\n\nint main() {\n    foo(Bar&lt;(x)&gt;{});\n}\n</code></pre>\n<p>This in <a href=\"https://wandbox.org/permlink/VSbNzcgxE7KCWnvw\" rel=\"noreferrer\">[clang]</a> results in:</p>\n<pre><code>prog.cc:11:5: error: no matching function for call to 'foo'\n    foo(Bar&lt;(x)&gt;{});\n    ^~~\nprog.cc:2:6: note: candidate template ignored: substitution failure [with TT = Bar]: non-type template argument is not a constant expression\nvoid foo(TT&lt;V&gt;) {\n     ^\n1 error generated.\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/3jeDfwTpWDLLMqO7\" rel=\"noreferrer\">[gcc]</a> accepts the code.</p>\n<p>To my understanding the code is well-formed and clang is buggy in its interpretation, but need the confirmation before submitting a bug to lvvm. Am I right?</p>\n", "Title": "Are reference non-type template parameters deduced by decltype(auto) forwardable in case of template template parameter", "CreationDate": "2017-09-20T17:09:00.157", "LastActivityDate": "2017-09-21T13:18:12.737", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "Id": "46328005", "Score": "9", "OwnerUserId": "4324224", "Tags": "<c++><templates><language-lawyer><c++1z><template-templates>", "AnswerCount": "1"}, "46345014": {"Id": "46345014", "PostTypeId": "2", "Body": "<p>According to error clang does not have a problem with deducing template <em>template-parameter</em> which is also standard compliant - <a href=\"http://eel.is/c++draft/temp.arg.template#3\" rel=\"nofollow noreferrer\">[temp.arg.template]/3</a> (empasis mine): </p>\n<blockquote>\n<p id=\"so_46328005_46345014_0\"><strong>A template-argument matches a template template-parameter P when P is\n  at least as specialized as the template-argument A</strong>. If P contains a\n  parameter pack, then A also matches P if each of A's template\n  parameters matches the corresponding template parameter in the\n  template-parameter-list of P. <strong>Two template parameters match if they\n  are of the same kind (type, non-type, template), for non-type\n  template-parameters, their types are equivalent ([temp.over.link])</strong>,\n  and for template template-parameters, each of their corresponding\n  template-parameters matches, recursively. When P's\n  template-parameter-list contains a template parameter pack, the\n  template parameter pack will match zero or more template parameters or\n  template parameter packs in the template-parameter-list of A with the\n  same type and form as the template parameter pack in P (ignoring\n  whether those template parameters are template parameter packs)</p>\n</blockquote>\n<p>Now lets make sure the <code>Bar&lt;(x)&gt;{}</code> should be deduced as reference. This is covered by <a href=\"http://eel.is/c++draft/dcl.type.auto.deduct#5\" rel=\"nofollow noreferrer\">[dcl.type.auto.deduct]/5</a> and <a href=\"http://eel.is/c++draft/dcl.type.simple#4\" rel=\"nofollow noreferrer\">[dcl.type.simple]/4</a>.</p>\n<p>Finally lets check if we actually can use the reference to the variable with linkage as a template argument <a href=\"http://eel.is/c++draft/temp.arg.nontype#2\" rel=\"nofollow noreferrer\">[temp.arg.nontype]/2</a>:</p>\n<blockquote>\n<p id=\"so_46328005_46345014_1\">A template-argument for a non-type template-parameter shall be a\n  converted constant expression of the type of the template-parameter.\n  <strong>For a non-type template-parameter of reference or pointer type, the\n  value of the constant expression shall not refer to (or for a pointer\n  type, shall not be the address of)</strong>:</p>\n<ul>\n<li><strong>a subobject,</strong></li>\n<li><strong>a temporary object,</strong></li>\n<li><strong>a string literal,</strong></li>\n<li><strong>the result of a typeid expression, or</strong></li>\n<li><strong>a predefined <em>\u00ad</em>\u00adfunc_\u00ad_\u00ad variable.</strong></li>\n</ul>\n<p id=\"so_46328005_46345014_2\">[\u2009Note: If the template-argument represents a set of overloaded\n  functions (or a pointer or member pointer to such), the matching\n  function is selected from the set ([over.over]). \u2014\u2009end note \u2009]</p>\n</blockquote>\n<p>The deduced argument fulfils the requirements. This makes the code well-formed and suggests clang's bug.</p>\n<p><a href=\"https://bugs.llvm.org/show_bug.cgi?id=34690\" rel=\"nofollow noreferrer\">Filed bug 34690</a></p>\n", "LastActivityDate": "2017-09-21T13:18:12.737", "CommentCount": "0", "CreationDate": "2017-09-21T13:18:12.737", "ParentId": "46328005", "Score": "1", "OwnerUserId": "4324224"}});