post_cb({"48124043": {"Id": "48124043", "PostTypeId": "2", "Body": "<p>Obviously we wouldn\u2019t want to have <em>only</em> indices that are compile-time constants.  If you\u2019re asking \u201cwhy not <em>also</em> have a function template for safe access with constant-expression indices?\u201d, I can say only that the use case seems not very common (unlike for <code>std::tuple</code>) and that the client can implement it themselves with no difficulty or loss of performance (which is one of the usual criteria for inclusion in the standard library).</p>\n<p>Re comments: even in a <code>constexpr</code> function, you can\u2019t use a normal function parameter ad a template argument.</p>\n", "LastActivityDate": "2018-01-06T03:41:30.983", "Score": "0", "CreationDate": "2018-01-06T03:41:30.983", "ParentId": "48124016", "CommentCount": "0", "OwnerUserId": "8586227"}, "48124056": {"Id": "48124056", "PostTypeId": "2", "Body": "<p>You can use <a href=\"http://en.cppreference.com/w/cpp/container/array/get\" rel=\"nofollow noreferrer\"><code>std::get</code></a> for that purpose:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    constexpr std::array&lt;int, 4&gt; foo { 1, 2, 3, 4 };\n    std::cout &lt;&lt; std::get&lt;2&gt;(foo) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Also note that both <code>operator[]</code> and <code>at</code> are <code>constexpr</code>:</p>\n<pre><code>constexpr std::array&lt;int, 4&gt; foo { 1, 2, 3, 4 };\nstd::cout &lt;&lt; std::get&lt;foo[2]&gt;(foo) &lt;&lt; std::endl;\nstd::cout &lt;&lt; std::get&lt;foo.at(2)&gt;(foo) &lt;&lt; std::endl;\n</code></pre>\n<p>This evaluates to <code>std::get&lt;3&gt;(foo)</code> (which evaluates to 4, since it's also a <code>constexpr</code>).</p>\n<p>Compilation already fails if you try to use an index out of the array's bounds in a <code>constexpr</code>.</p>\n<p>Finally, as multiple people have already pointed out, one major benefit of arrays is that you can read at dynamic indices from them. IMO, you are overstating the usefulness of static indexing.</p>\n", "LastEditorUserId": "251153", "LastActivityDate": "2018-01-06T03:55:04.957", "Score": "2", "CreationDate": "2018-01-06T03:46:34.123", "ParentId": "48124016", "CommentCount": "1", "OwnerUserId": "251153", "LastEditDate": "2018-01-06T03:55:04.957"}, "48124038": {"Id": "48124038", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48124016_48124038_0\">So why is it not implemented as such?</p>\n</blockquote>\n<p>Because in your way can works only with values known at compile time.</p>\n<p>I mean... with <code>at()</code> defined as receiving a parameter (not template), you can write</p>\n<pre><code>for ( auto i = 0U ; i &lt; 4U ; ++i )\n   std::cout &lt;&lt; a.at(i) &lt;&lt; std::endl;\n</code></pre>\n<p>But you can't write</p>\n<pre><code>for ( auto i = 0U ; i &lt; 4U ; ++i )\n   std::cout &lt;&lt; a.at&lt;i&gt;() &lt;&lt; std::endl;\n</code></pre>\n<p>because <code>i</code> isn't known (fixed) ar compile time.</p>\n<p><strong>-- EDIT--</strong></p>\n<p>The OP write</p>\n<blockquote>\n<p id=\"so_48124016_48124038_1\">What I really wanted is to enforce the bound checking at compile time</p>\n</blockquote>\n<p>If you write <code>at()</code> as follows</p>\n<pre><code>constexpr T &amp; at (std::size_t pos)\n { return pos &lt; N ? m_data[pos] : throw std::range_error(\"out of range\"); }\n</code></pre>\n<p>you get a bound checking compile time, when the method is <code>constexpr</code> executed compile time, and run time otherwise.</p>\n", "LastEditorUserId": "6022656", "LastActivityDate": "2018-01-06T03:57:12.290", "Score": "1", "CreationDate": "2018-01-06T03:40:32.127", "ParentId": "48124016", "CommentCount": "6", "OwnerUserId": "6022656", "LastEditDate": "2018-01-06T03:57:12.290"}, "48124016": {"ViewCount": "75", "Body": "<p><strong>Edit:</strong> I forgot to mention that this would be in a <code>constexpr</code> context where there aren't any dynamical indices. </p>\n<p>Consider the following (very naive) implementation:</p>\n<pre><code>template &lt;class T, std::size_t N&gt;\nclass array\n{\n    // ...\n\n    template &lt;size_type pos&gt;\n    reference at()\n    {\n        static_assert(pos &lt; N, \"Index out of range.\");\n        return m_data[pos];\n    }\n}\n</code></pre>\n<p>With the following usage:</p>\n<pre><code>int main()\n{\n    array&lt;int, 5&gt; a{1, 2, 3, 4, 5};\n\n    cout &lt;&lt; a.at(10) &lt;&lt; \"\\n\";   // will throw at runtime\n\n    cout &lt;&lt; a.at&lt;10&gt;() &lt;&lt; \"\\n\"; // static assert error; index out of range\n    return 0;\n}\n</code></pre>\n<p>This effectively prevents out of range access for the types and any nasty segfaults or exceptions that would be thrown. An error would be thrown by the compiler that looks like this:</p>\n<pre><code>error: static assertion failed: Index out of range\n             static_assert(pos &lt; N, \"Index out of range\");\n</code></pre>\n<p>And most IDEs would catch the erroneous access. So why is it not implemented as such?</p>\n<p><strong>Note:</strong> I'm sorry if this is obvious but I'm planning on writing my own <code>array</code> class for performance and safety, and this thought popped into my head.</p>\n", "AcceptedAnswerId": "48124037", "Title": "Why is `std::array::at()` not implemented as a template function?", "CreationDate": "2018-01-06T03:35:21.517", "LastActivityDate": "2018-01-06T03:59:35.343", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-06T03:41:31.280", "LastEditorUserId": "4577422", "Id": "48124016", "Score": "0", "OwnerUserId": "4577422", "Tags": "<c++><c++11><c++14>", "AnswerCount": "5"}, "48124058": {"Id": "48124058", "PostTypeId": "2", "Body": "<p>Beyond what has been pointed out about <code>at</code> having to take a runtime argument, and std::get as an alternative: if you use <code>operator[]</code> in a constexpr context and go out of bounds you will get a compile time error in C++14 as you seem to want, as long as you invoke it on a const array:</p>\n<pre><code>const std::array&lt;int, 5&gt; a{};\nconstexpr int v = a[10];\n</code></pre>\n<p>gcc gives the error:</p>\n<pre><code>error: array subscript value \u201810\u2019 is outside the bounds of array type \u2018std::__array_traits&lt;int, 5&gt;::_Type {aka int [5]}\u2019\n   constexpr int v = a[10];\n</code></pre>\n", "LastActivityDate": "2018-01-06T03:47:13.007", "Score": "0", "CreationDate": "2018-01-06T03:47:13.007", "ParentId": "48124016", "CommentCount": "0", "OwnerUserId": "1013719"}, "bq_ids": {"n4140": {"so_48124016_48124037_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 736}}, "n3337": {"so_48124016_48124037_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 725}}, "n4659": {"so_48124016_48124037_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 765}}}, "48124037": {"Id": "48124037", "PostTypeId": "2", "Body": "<p>You need to be able to access the elements dynamically.  Only because the size is known at compile-time does not mean that the accessed indices are known at compile-time.  Consider <code>a.at(i)</code> where <code>i</code> is user input.</p>\n<p>Furthermore, the <code>at</code> function is required to do a runtime-check by the standard, see <a href=\"http://eel.is/c++draft/container.requirements#sequence.reqmts-15\" rel=\"nofollow noreferrer\">[sequence.reqmts]</a></p>\n<blockquote>\n<p id=\"so_48124016_48124037_0\">The member function <code>at()</code> provides bounds-checked access to container elements. <code>at()</code> throws <code>out_\u00adof_\u00adrange</code> if <code>n &gt;= a.size()</code>.</p>\n</blockquote>\n<p>Also, starting with C++17 the <code>at</code> member function is marked constexpr, so for an index which is constant at compile-time there is no difference to the templated function in your question.</p>\n<pre><code>#include &lt;array&gt;\n\nint main() {\n    constexpr std::array&lt;int,5&gt; a = { 1, 2, 3, 4, 5 };\n    constexpr int b = a.at(2);\n    constexpr int c = a.at(10);\n}\n</code></pre>\n<p><kbd><a href=\"https://wandbox.org/permlink/yavwu8n2JmrNz2xL\" rel=\"nofollow noreferrer\">Live on Wandbox</a></kbd> (Error message is meh...)</p>\n<p>If you known the index at compile-time and do not want to pay the extra cost that <code>at</code> incurs before C++17, you can just use <code>std::get&lt;10&gt;(a)</code>.  This variant has zero-overhead, because the compiler can inline the array access entirely</p>\n<pre><code>#include &lt;array&gt;\n\nint test(std::array&lt;int,5&gt; const &amp;a) {\n  return std::get&lt;1&gt;(a);\n}\n</code></pre>\n<p><kbd><a href=\"https://godbolt.org/g/hwgghv\" rel=\"nofollow noreferrer\">Live on Godbolt</a></kbd></p>\n", "LastEditorUserId": "1944004", "LastActivityDate": "2018-01-06T03:59:35.343", "Score": "4", "CreationDate": "2018-01-06T03:40:18.163", "ParentId": "48124016", "CommentCount": "6", "OwnerUserId": "1944004", "LastEditDate": "2018-01-06T03:59:35.343"}});