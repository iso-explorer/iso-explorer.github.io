post_cb({"14941777": {"ParentId": "14941723", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code is not a polymorphism sample. You are just casting object pointers to each other.</p>\n<p>You forgotten to extend (inherit) your classes from each other, since polymorphism is related to inheritance.</p>\n<p>For example try this:</p>\n<pre><code>class Class1\n{\n   public:\n      virtual void f()\n      {\n    cout &lt;&lt; \"Function f() in Class1\\n\";\n      }\n\n     void g()\n     {\n    cout &lt;&lt; \"Function g() in Class1\\n\";\n     }\n };\n\n\n class Class2 : public Class1\n {\n    public:\n   virtual void f()\n   {\n    cout &lt;&lt; \"Function f() in Class2\\n\";\n   }\n\n   void g()\n   {\n    cout &lt;&lt; \"Function g() in Class2\\n\";\n   }\n };\n\n\nclass Class3 : public Class2\n{\n    public:\n\n    virtual void h()\n    {\n    cout &lt;&lt; \"Function h() in Class3\\n\";\n    }\n  };\n</code></pre>\n", "OwnerUserId": "952747", "LastEditorUserId": "952747", "LastEditDate": "2013-02-18T17:32:13.280", "Id": "14941777", "Score": "1", "CreationDate": "2013-02-18T17:18:28.447", "LastActivityDate": "2013-02-18T17:32:13.280"}, "14941872": {"ParentId": "14941723", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are using an evil C-style cast, equivalent in this case to <code>reinterpret_cast</code>, to take a pointer to one class and pretend it's pointing to an unrelated class.</p>\n<blockquote>\n<p id=\"so_14941723_14941872_0\">I was expecting some compilation error/crash</p>\n</blockquote>\n<p>There is no compilation error, because you have deliberately prevented the compiler from checking the type conversion - that is the purpose of <code>reinterpret_cast</code>, and the reason to avoid it (and C-style casts even more so) except when it's really necessary. There could be a crash, or any other type of undefined runtime behaviour.</p>\n<p>In your case, it appears that the class layouts are similar enough for the virtual function call to succeed even though the pointer type is completely wrong. This is not surprising, since your class definitions are all very similar; but this is very much not guaranteed behaviour, and in principle it could fail in many catastrophic ways.</p>\n<p>If you want polymorphic behaviour, then <code>Class2</code> and <code>Class3</code> should inherit from <code>Class1</code>. The pointer conversions will then be valid with no cast, and the polymorphic behaviour will be well defined - <code>f()</code> will be dispatched virtually according to the object type, and <code>g()</code> non-virtually according to the pointer type.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-02-18T17:29:04.957", "Id": "14941872", "Score": "4", "CreationDate": "2013-02-18T17:22:46.473", "LastActivityDate": "2013-02-18T17:29:04.957"}, "14941807": {"ParentId": "14941723", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code has <strong>Undefined Behavior</strong>. </p>\n<p>When a program has Undefined Behavior, everything could happen. You <em>could</em> get a crash, but this is not necessary. From Paragraph 1.3.24:</p>\n<blockquote>\n<p id=\"so_14941723_14941807_0\">[...] Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). [...]</p>\n</blockquote>\n<hr>\n<p><em>Why do you have Undefined Behavior?</em></p>\n<p>You are performing a brutal C-style cast (which resorts to a <code>reinterpret_cast&lt;&gt;</code>) of a pointer to an object of type <code>Class3</code> to a pointer to an object of type <code>Class1</code>. This is allowed, but the behavior is undefined.</p>\n<p>From Paragraph 5.2.10/7 of the C++11 Standard about <code>reinterpret_cast&lt;&gt;</code>:</p>\n<blockquote>\n<p id=\"so_14941723_14941807_1\"><strong>An object pointer can be explicitly converted to an object pointer of a different type</strong>.70  [..]</p>\n</blockquote>\n<p>This makes the explicit cast legal. However (same paragraph):</p>\n<blockquote>\n<p id=\"so_14941723_14941807_2\">[...] When a prvalue v of type \u201cpointer to T1\u201d is converted to the type\n  \u201cpointer to cv T2\u201d, the result is static_cast(static_cast(v)) <strong>if both T1 and T2 are standard-layout types</strong> (3.9) and the\n  alignment requirements of T2 are no stricter than those of T1, or if\n  either type is void. [...]</p>\n</blockquote>\n<p>Your classes <code>Class1</code> and <code>Class3</code> are <strong>not</strong> standard-layout types. Per Paragraph 9/7, in fact:</p>\n<blockquote>\n<p id=\"so_14941723_14941807_3\">A standard-layout class is a class that:</p>\n<p id=\"so_14941723_14941807_4\">\u2014 has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p>\n<p id=\"so_14941723_14941807_5\">\u2014 has <strong>no virtual functions</strong> (10.3) and no virtual base classes (10.1), </p>\n<p id=\"so_14941723_14941807_6\">[...]</p>\n</blockquote>\n<p>Therefore, the second part of 5.2.10/7 applies:</p>\n<blockquote>\n<p id=\"so_14941723_14941807_7\">[...] Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer\n  value. <strong>The result of any other such pointer conversion is unspecified</strong>.</p>\n</blockquote>\n<p>Since the result of converting that pointer is unspecified, trying to invoke a function on it results in Undefined Behavior.</p>\n</hr>", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-02-18T17:32:53.360", "Id": "14941807", "Score": "3", "CreationDate": "2013-02-18T17:19:40.237", "LastActivityDate": "2013-02-18T17:32:53.360"}, "bq_ids": {"n4140": {"so_14941723_14941807_0": {"section_id": 5768, "quality": 1.0, "length": 26}, "so_14941723_14941807_7": {"section_id": 6046, "quality": 0.7666666666666667, "length": 23}, "so_14941723_14941807_5": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_14941723_14941807_1": {"section_id": 6046, "quality": 0.8888888888888888, "length": 8}, "so_14941723_14941807_4": {"section_id": 5851, "quality": 1.0, "length": 10}, "so_14941723_14941807_2": {"section_id": 6046, "quality": 0.7, "length": 14}}, "n3337": {"so_14941723_14941807_0": {"section_id": 5541, "quality": 1.0, "length": 26}, "so_14941723_14941807_7": {"section_id": 5814, "quality": 0.9666666666666667, "length": 29}, "so_14941723_14941807_5": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_14941723_14941807_1": {"section_id": 5814, "quality": 0.8888888888888888, "length": 8}, "so_14941723_14941807_4": {"section_id": 5621, "quality": 1.0, "length": 10}, "so_14941723_14941807_2": {"section_id": 5814, "quality": 0.95, "length": 19}}, "n4659": {"so_14941723_14941807_0": {"section_id": 7225, "quality": 1.0, "length": 26}, "so_14941723_14941807_7": {"section_id": 7545, "quality": 0.7666666666666667, "length": 23}, "so_14941723_14941807_5": {"section_id": 383, "quality": 0.7142857142857143, "length": 5}, "so_14941723_14941807_1": {"section_id": 7545, "quality": 0.8888888888888888, "length": 8}, "so_14941723_14941807_4": {"section_id": 7330, "quality": 1.0, "length": 10}, "so_14941723_14941807_2": {"section_id": 7545, "quality": 0.7, "length": 14}}}, "14941723": {"CommentCount": "2", "ViewCount": "218", "CreationDate": "2013-02-18T17:15:03.410", "LastActivityDate": "2013-02-18T17:32:53.360", "Title": "Visual studio 2008 : Polymorphic behavior of C++", "AcceptedAnswerId": "14941807", "PostTypeId": "1", "Id": "14941723", "Score": "0", "Body": "<p>I am trying to understand Polymorphism behavior in C++ code. I got surprised by seeing the output of the the below program. </p>\n<p>The output of the below code I was expecting some compilation error/crash at following programming statement. But output of this program quite surprised me.</p>\n<pre><code>p = (Class1*) &amp;object3;\np-&gt;f();\np-&gt;g();\n</code></pre>\n<p>I couldn't understand why. I am using Visual studio 2008.</p>\n<p>Code Snippet.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Class1\n{\n   public:\n      virtual void f()\n      {\n    cout &lt;&lt; \"Function f() in Class1\\n\";\n      }\n\n     void g()\n     {\n    cout &lt;&lt; \"Function g() in Class1\\n\";\n     }\n };\n\n\n class Class2\n {\n    public:\n   virtual void f()\n   {\n    cout &lt;&lt; \"Function f() in Class2\\n\";\n   }\n\n   void g()\n   {\n    cout &lt;&lt; \"Function g() in Class2\\n\";\n   }\n };\n\n\nclass Class3\n{\n    public:\n\n    virtual void h()\n    {\n    cout &lt;&lt; \"Function h() in Class3\\n\";\n    }\n  };\n\n\n  int _tmain(int argc, _TCHAR* argv[])\n  {\n   Class1 object1, *p;\n   Class2 object2;\n   Class3 object3;\n\n  p = &amp;object1;\n\n  p-&gt;f();\n  p-&gt;g();\n\n  p = (Class1*) &amp;object2;\n\n  p-&gt;f();\n  p-&gt;g();\n\n  p = (Class1*) &amp;object3;\n\n  p-&gt;f();\n  p-&gt;g();\n\n  //p-&gt;h();      Compilation error\n\n  return 0;\n\n   }\n</code></pre>\n<p>O/P:</p>\n<p>Function f() in Class1</p>\n<p>Function g() in Class1</p>\n<p>Function f() in Class2</p>\n<p>Function g() in Class1</p>\n<p>Function h() in Class3</p>\n<p>Function g() in Class1</p>\n", "Tags": "<c++><polymorphism>", "OwnerUserId": "1347306", "AnswerCount": "3"}});