post_cb({"bq_ids": {"n4140": {"so_39872246_39873599_2": {"length": 18, "quality": 1.0, "section_id": 31}, "so_39872246_39873599_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 7239}, "so_39872246_39873599_1": {"length": 9, "quality": 1.0, "section_id": 30}, "so_39872246_39873599_0": {"length": 47, "quality": 0.94, "section_id": 7177}}, "n3337": {"so_39872246_39873599_2": {"length": 18, "quality": 1.0, "section_id": 28}, "so_39872246_39873599_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 6983}, "so_39872246_39873599_1": {"length": 9, "quality": 1.0, "section_id": 27}, "so_39872246_39873599_0": {"length": 47, "quality": 0.94, "section_id": 6921}}, "n4659": {"so_39872246_39873599_2": {"length": 18, "quality": 1.0, "section_id": 31}, "so_39872246_39873599_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 8748}, "so_39872246_39873599_1": {"length": 9, "quality": 1.0, "section_id": 30}, "so_39872246_39873599_0": {"length": 44, "quality": 0.88, "section_id": 8685}}}, "39873599": {"Id": "39873599", "PostTypeId": "2", "Body": "<p>It may not be a recommended practice, but AFAIK, it is safe. It is true that in general, taking a pointer to P, casting it to a pointer to Q and using it as a pointer to Q leads to undefined behaviour. Here it looks even worse, because the alignment requirement of <code>char</code> are known to be the weakest possible.</p>\n<p>But the <code>char * tBuf</code> pointer has been obtained through a new expression. Such a new expression internally rely on a allocation function to obtain storage, and draft n4296 for c++14 says in 3.7.4.1 Allocation functions [basic.stc.dynamic.allocation] \u00a72:</p>\n<blockquote>\n<p id=\"so_39872246_39873599_0\">The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall\n  return the address of the start of a block of storage whose length in bytes shall be at least as large as\n  the requested size... The pointer returned shall be suitably aligned so that <strong>it can be converted\n  to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used\n  to access the object or array</strong> in the storage allocated (until the storage is explicitly deallocated by a call\n  to a corresponding deallocation function).</p>\n</blockquote>\n<p>So this line <code>*(WORD*)tBuf = htons((WORD)numToSend);</code> only does perfectly defined operations:</p>\n<ul>\n<li><p>convert <code>numToSend</code> from an integer type to an unsigned type, and 4.7 Integral conversions [conv.integral] says:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_39872246_39873599_1\">A prvalue of an integer type can be converted to a prvalue of another integer type...</p></li>\n<li><p id=\"so_39872246_39873599_2\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the unsigned type)</p></li>\n</ol>\n</blockquote></li>\n<li><p>call <code>htons</code> with a WORD or uint16_t as parameter to return a uint16_t or WORD</p></li>\n<li>converts a pointer obtained by new to a <code>WORD *</code> and uses that pointer to access the object in the storage allocated</li>\n</ul>\n<p>Simply, the value of the first two bytes of the allocated array is now unspecified. More exactly it is the byte representation of the WORD in the particular implementation.</p>\n<p>But it is still allowed to access the allocated array as a character array, even if the first bytes now contain a WORD, because it is explicitely allowed per the so called <em>strict aliasing rule</em> 3.10 Lvalues and rvalues [basic.lval] \u00a710 :</p>\n<blockquote>\n<p id=\"so_39872246_39873599_3\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined:<br/>...<br/>\n  (10.8) \u2014 a char or unsigned char type.</p>\n</blockquote>\n<hr>\n<p>If the <code>tBuf</code> pointer had not been obtained through a new expression, the only correct way would have been to do a <code>memcpy</code>:</p>\n<pre><code>WORD n_numToSend = htons(numToSend);\nmemcpy(tBuf, &amp;n_numToSend, sizeof(WORD));\n</code></pre>\n<p>As this one is allowed for any pointer provided the storage is big enough, it is what I would call the recommended practice.</p>\n</hr>", "LastActivityDate": "2016-10-05T12:10:17.390", "Score": "2", "CreationDate": "2016-10-05T12:10:17.390", "ParentId": "39872246", "CommentCount": "0", "OwnerUserId": "3545273"}, "39872246": {"ViewCount": "75", "Body": "<p>I'm fairly new to C++ and I'm having difficulty wrapping my head around what is going on in the final line of the below:</p>\n<pre><code>int numToSend = bs-&gt;GetSize();\nchar *  tBuf = new char[NUM_LENGTH_BYTES + numToSend];\n*(WORD*)tBuf = htons((WORD)numToSend);\n</code></pre>\n<p>So htons is returning a u_short or WORD, but the cast on tBuf is somewhat confusing to me. Is it something along the lines of \"the value pointed to by tBuf is cast as a WORD pointer and assigned the return from htons\"?</p>\n<p>I believe this is a fairly unsafe operation in most cases, what would be the best practice here?</p>\n", "AcceptedAnswerId": "39873599", "Title": "Pointer cast into char* array", "CreationDate": "2016-10-05T11:03:00.263", "Id": "39872246", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-10-05T12:10:17.390", "Score": "1", "OwnerUserId": "996911", "Tags": "<c++><pointers>", "AnswerCount": "1"}});