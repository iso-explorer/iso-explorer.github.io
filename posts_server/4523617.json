post_cb({"4571810": {"ParentId": "4523617", "CommentCount": "4", "Body": "<p>Many programming languages including Ocaml and Felix can deduce the return type of a function and do not require it to be specified. In Ocaml you can and must specify it in an interface. In Felix I have found for some functions it is wise to specify it in library code to make it easier to use. </p>\n<p>I am surprised \"auto\" doesn't work for return types, it was certainly on the plate. Was this considered too hard to implement? [It isn't trivial given that a function can be recursive].</p>\n<p>Ohhh .. now I see. The problem is the stupid template design feature \"dependent names\":</p>\n<pre><code>template&lt;class T&gt; auto f(T a) { return a.f(); }\n</code></pre>\n<p>So whilst it is a bit tricky to compute the return type of an ordinary function due to overloading, it is impossible with templates due to dependent name lookup: it could only be done after instantiation. But overloading must happen before that. So auto return types can't go in the language because it doesn't generalise to templates.</p>\n", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "4571810", "Score": "2", "CreationDate": "2010-12-31T18:53:42.970", "LastActivityDate": "2010-12-31T18:53:42.970"}, "4544741": {"ParentId": "4523617", "CommentCount": "0", "Body": "<p>If you are simply trying to set the return type, make it a template argument.  This way you can change everything related to the return type without actually changing the function.  You can put a default return type if you want like in this example.</p>\n<pre><code>template &lt;class R = int, class T&gt;\nR f(T&amp;&amp; x)\n{\n   ...\n   return h2(y2, y3);\n}\n</code></pre>\n<hr>\n<p>The code below demonstrates it's effectiveness.</p>\n<p><strong>DEMO CODE:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\ntemplate &lt;class T, class S&gt;\nT h2(T&amp; x, S&amp; y)\n{\n  return x + y;\n}\n\ntemplate &lt;class R = int, class T&gt;\nR f(T&amp; x)\n{\n  auto y2 = x;\n  auto y3 = x;\n  return h2(y2, y3);\n}\n\nint main(int argc, char** argv)\n{\n  int x = 7;\n  std::string str = \"test! \";\n\n  auto d = f&lt;double&gt;(x);\n  auto i = f(x); // use default type (int)\n  auto s = f&lt;std::string&gt;(str);\n\n  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);\n  std::cout &lt;&lt; \"double: \" &lt;&lt; d &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"int: \" &lt;&lt; i &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"string: \" &lt;&lt; s &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<hr>\n<p><strong>OUTPUT:</strong></p>\n<pre><code>double: 14.0000\nint: 14\nstring: test! test!\n</code></pre>\n<hr>\n<p>Unfortunately, the exact functionality you are looking for does not exist (yet) and is not part of the C++0x spec.  However, it is possible this may be part of the C++1x spec when it is drafted.  until then, stick to templates.</p>\n</hr></hr></hr>", "OwnerUserId": "454237", "PostTypeId": "2", "Id": "4544741", "Score": "7", "CreationDate": "2010-12-28T08:38:00.390", "LastActivityDate": "2010-12-28T08:38:00.390"}, "7656414": {"ParentId": "4523617", "CommentCount": "1", "Body": "<p>I agree with Yttrill. Return type deduction has already been proved to be a feasible practice in languages like Haskell, and since C++ has already achieved 'auto', it is just one step further to achieve return type deduction. This deduction should happens at the time of specialization, not template definition, since information of the real type supplied to the template is needed. The separate of declaration and definition is no longer a common practice in generic C++, because template body must be written in header files, and hence template bodies almost always go with template declarations. In situations where there are multiple return statements and types of them do not match, the compiler can happily report en error. In summary, return type deduction is totally possible in C++, if the committee wants to. And it's VERY important, because the duplication of manually writing return types hinders the pervasive use of small generic helper functions, which is such a common practice in functional and generic programming.</p>\n", "OwnerUserId": "979633", "PostTypeId": "2", "Id": "7656414", "Score": "3", "CreationDate": "2011-10-05T03:32:02.607", "LastActivityDate": "2011-10-05T03:32:02.607"}, "4574734": {"ParentId": "4523617", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>EDIT: oops, I just realized that there's a scoping difference between the <em>trailing-return-type</em> specifier and the return statement.  Specifically:</p>\n<pre><code>auto f(int a)\n{\n    char r[sizeof(f(a))+1];\n    return r;\n}\n</code></pre>\n<p>Kaboom!</p>\n<hr>\n<p>Previous answer:</p>\n<p>It's unfortunate that the language does not provide a syntax to have the compiler infer the return type in this case, because it's trivial to show that inference is possible.</p>\n<p>Specifically, we are talking about the case where there is exactly one return statement inside the function.</p>\n<p>Independent of where in the function that return statement is, or how complex the preceding code is, it should be clear that the following transformation is possible:</p>\n<pre><code>return (ugly expression);\n</code></pre>\n<p>into</p>\n<pre><code>auto return_value = (ugly expression);\nreturn return_value;\n</code></pre>\n<p>If the compiler can infer the type of <code>return_value</code> (and according to the C++0x rules, it can), then the inferred type of <code>return_value</code> can be chosen as the return type of the function.</p>\n<p>It therefore seems to me that a modification to C++0x where the trailing return type specifier should only be required when the multiplicity of return statements is not exactly one would be feasible and solve the problem.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-02-06T21:44:35.973", "Id": "4574734", "Score": "6", "CreationDate": "2011-01-01T16:38:47.600", "LastActivityDate": "2012-02-06T21:44:35.973"}, "4523617": {"CommentCount": "11", "AcceptedAnswerId": "9878792", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2010-12-24T01:05:45.897", "LastActivityDate": "2012-03-26T19:54:18.940", "LastEditDate": "2011-12-19T01:19:04.730", "ViewCount": "15413", "FavoriteCount": "5", "Title": "Omit return type in C++11", "Id": "4523617", "Score": "41", "Body": "<p>I've recently found myself using the following macro with gcc 4.5 in C++11 mode:</p>\n<pre><code>#define RETURN(x) -&gt; decltype(x) { return x; }\n</code></pre>\n<p>And writing functions like this:</p>\n<pre><code>template &lt;class T&gt;\nauto f(T&amp;&amp; x) RETURN (( g(h(std::forward&lt;T&gt;(x))) ))\n</code></pre>\n<p>I've been doing this to avoid the inconvenience having to effectively write the function body twice, and having keep changes in the body and the return type in sync (which in my opinion is a disaster waiting to happen).</p>\n<p>The problem is that this technique only works on one line functions. So when I have something like this (convoluted example):</p>\n<pre><code>template &lt;class T&gt;\nauto f(T&amp;&amp; x) -&gt; ...\n{\n   auto y1 = f(x);\n   auto y2 = h(y1, g1(x));\n   auto y3 = h(y1, g2(x));\n   if (y1) { ++y3; }\n   return h2(y2, y3);\n}\n</code></pre>\n<p>Then I have to put something horrible in the return type.</p>\n<p>Furthermore, whenever I update the function, I'll need to change the return type, and if I don't change it correctly, I'll get a compile error if I'm lucky, or a runtime bug in the worse case. Having to copy and paste changes to two locations and keep them in sync I feel is not good practice.</p>\n<p>And I can't think of a situation where I'd want an implicit cast on return instead of an explicit cast.</p>\n<p>Surely there is a way to ask the compiler to deduce this information. What is the point of the compiler keeping it a secret? I thought C++11 was designed so such duplication would not be required.</p>\n", "Tags": "<c++><c++11><return-value>", "OwnerUserId": "525980", "AnswerCount": "7"}, "4533836": {"ParentId": "4523617", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Does your return type really change that often? Why can't you just specify it explicitly?\nExample:</p>\n<pre><code>template&lt;class T&gt;\nint f(T&amp;&amp; x)\n{\n...\n}\n</code></pre>\n<p>People did that for over twenty years...</p>\n", "OwnerUserId": "106104", "LastEditorUserId": "106104", "LastEditDate": "2010-12-26T13:02:45.593", "Id": "4533836", "Score": "-3", "CreationDate": "2010-12-26T12:39:36.870", "LastActivityDate": "2010-12-26T13:02:45.593"}, "4574567": {"ParentId": "4523617", "CommentCount": "0", "Body": "<p>The rationale for this behavior is given in the draft, 8.3.5p12:</p>\n<blockquote>\n<p id=\"so_4523617_4574567_0\">A trailing-return-type is most useful\n  for a type that would be more\n  complicated to specify before the\n  declarator-id:</p>\n</blockquote>\n<pre><code>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);\n</code></pre>\n<blockquote>\n<p id=\"so_4523617_4574567_1\">rather than </p>\n</blockquote>\n<pre><code>template &lt;class T, class U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);\n</code></pre>\n<p>So this is really only meant to simplify the case where referring to the parameter names helps.</p>\n<p>If you assume that C++ could <em>always</em> infer the return type of functions from the function body: this is not going to fly. It's a goal of C++ (and C) to allow modularity by separating declaration from implementation, so at the point of the call, you may not have the body of the function available. However, every caller needs to know the parameter types <em>and the return type</em> of every function/method being called.</p>\n", "OwnerUserId": "33006", "PostTypeId": "2", "Id": "4574567", "Score": "11", "CreationDate": "2011-01-01T15:47:19.357", "LastActivityDate": "2011-01-01T15:47:19.357"}, "bq_ids": {"n4140": {"so_4523617_4574567_0": {"section_id": 3248, "quality": 1.0, "length": 10}}, "n3337": {"so_4523617_4574567_0": {"section_id": 3121, "quality": 1.0, "length": 10}}, "n4659": {"so_4523617_4574567_0": {"section_id": 4006, "quality": 1.0, "length": 10}}}, "9878792": {"ParentId": "4523617", "CommentCount": "1", "Body": "<p>It would appear that <a href=\"http://gcc.gnu.org/ml/gcc-patches/2012-03/msg01599.html\">g++ 4.8</a> is getting an implementation of auto return type deduction.\nThe patch was put in by Jason Merrill who is also sending a paper for C++-1Y for the feature.  The feature is available with -std=c++1y.</p>\n<p>Still playing with it.</p>\n", "OwnerUserId": "680359", "PostTypeId": "2", "Id": "9878792", "Score": "23", "CreationDate": "2012-03-26T19:54:18.940", "LastActivityDate": "2012-03-26T19:54:18.940"}});