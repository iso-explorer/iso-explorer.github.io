post_cb({"36393902": {"ParentId": "36393588", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>This is not allowed:</p>\n<pre><code>constexpr int i = b[2];\n</code></pre>\n<p><code>b[2]</code> is not a constant expression because it contains (ref: N4140 [expr.const]/2.8)</p>\n<blockquote>\n<p id=\"so_36393588_36393902_0\">an lvalue-to-rvalue conversion (4.1) or modification (5.17, 5.2.6, 5.3.2) that is applied to a glvalue that refers to a non-active member of a union or a subobject thereof;</p>\n</blockquote>\n<p>The active member of the union is the struct because you initialized that member.  The int array is inactive.</p>\n<p>If you changed the <code>operator[]</code> function to <code>switch</code> and return a member of the struct instead, it should work.</p>\n<p><em>Note:</em> accessing the inactive member causes undefined behaviour.  Although common compilers support union aliasing as an extension,  it would avoid some trouble if you could design your code to not use union aliasing.</p>\n<hr>\n<p>There are issues with the anonymous struct and its initializer too. Specifically, [class.union]/5:</p>\n<blockquote>\n<p id=\"so_36393588_36393902_1\">A union of the form <code>union { member-specification } ;</code> is called an <em>anonymous union</em>; it defines an unnamed object of unnamed type. The member-specification of an anonymous union shall only define non-static data members. [Note: Nested types, anonymous unions, and functions cannot be declared within an anonymous union. \u2014end note ]</p>\n</blockquote>\n<p>So you cannot have the anonymous struct inside the anonymous union. You need to make one of them non-anonymous. For example:</p>\n<pre><code>struct A\n{\n    struct AU { int a, b, c; };\n    union\n    {\n        AU a;\n        int vals[3];\n    };\n};\n</code></pre>\n<p>which works with the initializer <code>: A({x, x, x})</code>.  The inconsistent behaviour around the <code>A</code> initializer that you saw might be a gcc bug.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2016-04-04T03:01:21.863", "Id": "36393902", "Score": "9", "CreationDate": "2016-04-04T02:55:06.677", "LastActivityDate": "2016-04-04T03:01:21.863"}, "36393588": {"CommentCount": "13", "AcceptedAnswerId": "36393984", "PostTypeId": "1", "LastEditorUserId": "2430597", "CreationDate": "2016-04-04T02:08:19.007", "LastActivityDate": "2016-04-08T18:58:50.437", "LastEditDate": "2016-04-08T18:58:50.437", "ViewCount": "589", "FavoriteCount": "2", "Title": "constexpr reference to a variable of an anonymous struct", "Id": "36393588", "Score": "12", "Body": "<p>Given <code>struct B</code>, which inherits an anonymous <code>union</code> data member from <code>struct A</code>:</p>\n<pre><code>#include &lt;cstddef&gt;\n\nstruct A\n{\n    union\n    {\n        struct { int a, b, c; };\n        int vals[3];\n    };\n};\n\nstruct B: A\n{\n    constexpr B(int x)\n    :\n        A{{{ x, x, x }}}\n    {}\n\n    constexpr int&amp; operator[](size_t i)\n    {\n        return this-&gt;vals[i];\n    }\n\n    constexpr const int&amp; operator[](size_t i) const\n    {\n        return this-&gt;vals[i];\n    }\n};\n</code></pre>\n<p>I declare a <code>constexpr</code> variable of type <code>B</code>, then calling its <code>operator[]</code> to assign the return value to a <code>constexpr int</code>:</p>\n<pre><code>int main()\n{\n    constexpr B b(7);\n    constexpr int i = b[2];\n\n    return 0;\n}\n</code></pre>\n<p>However Clang 3.8 gives me the error message</p>\n<pre><code>constexpr variable 'i' must be initialized by a constant expression\n</code></pre>\n<p>The issue is related to the anonymous <code>union</code>, since when I simply use <code>int vals[3]</code> then everything works fine.</p>\n<p>Is there a C++14 <code>constexpr</code> restriction I'm missing?</p>\n", "Tags": "<c++><c++11><c++14><unions><c++1z>", "OwnerUserId": "2430597", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_36393588_36393902_0": {"section_id": 6185, "quality": 0.7857142857142857, "length": 11}, "so_36393588_36393902_1": {"section_id": 5917, "quality": 0.8181818181818182, "length": 27}}, "n3337": {"so_36393588_36393902_0": {"section_id": 5946, "quality": 0.7142857142857143, "length": 10}, "so_36393588_36393902_1": {"section_id": 5689, "quality": 0.7878787878787878, "length": 26}}, "n4659": {"so_36393588_36393902_0": {"section_id": 7687, "quality": 0.7142857142857143, "length": 10}, "so_36393588_36393902_1": {"section_id": 7410, "quality": 0.7575757575757576, "length": 25}}}, "36393984": {"ParentId": "36393588", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In addition to M.M's answer, according to the <a href=\"http://en.cppreference.com/w/cpp/language/union\" rel=\"nofollow\">C++ union initialization</a> rules the aggregate initializer always initializes the first union member only, which becomes the active member of that union.</p>\n<p>So changing <code>A</code> to be <code>int vals[3]</code> the first declaration in the <code>union</code>:</p>\n<pre><code>struct A\n{\n    union\n    {\n        int vals[3];\n        struct { int a, b, c; };\n    };\n};\n</code></pre>\n<p>or defining a constructor which initializes the member <code>int vals[3]</code> instead of the aggregate initialization which initializes the first <code>union</code> member:</p>\n<pre><code>struct A\n{\n    A(int a, int b, int c)\n    : vals{ a, b c }\n    {}\n\n    union\n    {\n        struct { int a, b, c; };\n        int vals[3];\n    };\n};\n</code></pre>\n<p>solves the problem of reading anonymous <code>union</code> member <code>int vals[3]</code> in a <code>constexpr</code> expression.</p>\n", "OwnerUserId": "2430597", "LastEditorUserId": "2430597", "LastEditDate": "2016-04-04T06:12:04.633", "Id": "36393984", "Score": "4", "CreationDate": "2016-04-04T03:07:51.020", "LastActivityDate": "2016-04-04T06:12:04.633"}});