post_cb({"34120422": {"CommentCount": "1", "ViewCount": "221", "CreationDate": "2015-12-06T17:30:24.513", "LastActivityDate": "2015-12-07T04:27:31.090", "Title": "Why does std::condition_variable::wait_for() throw an operation not permitted std::system_error on Windows with VS2013?", "AcceptedAnswerId": "34121629", "PostTypeId": "1", "Id": "34120422", "Score": "0", "Body": "<p>I have a simple test of having background threads on a GUI program that asynchronously pushes display work back onto the GUI thread once a second. It does not work on Windows, with <code>std::condition_variable::wait_for()</code> throwing a <code>std::system_error</code> of type <code>operation not permitted.</code>.</p>\n<p><strong>This is with Visual Studio 2013 on Windows 7 x64. It is not with gcc on Linux, so <code>-lpthread</code> does not count here. Existing questions on the issue (both on Stack Overflow and elsewhere) are all for gcc/Linux/<code>-lpthread</code>.</strong> In fact, I have an equivalent test on Linux (with GTK+) and it works just fine.</p>\n<p>Here's an example. It opens a window with a button and a multiline edit box. Every second, you should see the line <code>One second passed</code> added to the edit box. Clicking the button adds the line <code>Saying something</code> immediately. Lines should never mix.</p>\n<p>Instead, if you run this program, you should see</p>\n<pre><code>class std::system_error caught: operation not permitted: operation not permitted\n</code></pre>\n<p>on the command line, and the <code>One second passed</code> messages never show up.</p>\n<p>I am building with</p>\n<pre><code>cl /TP wincondvartest.cpp /W4 /Zi /EHsc /link /incremental:no user32.lib kernel32.lib gdi32.lib\n</code></pre>\n<p>What's going on? Thanks.</p>\n<pre><code>// 6 december 2015\n#define UNICODE\n#define _UNICODE\n#define STRICT\n#define STRICT_TYPED_ITEMIDS\n// get Windows version right; right now Windows Vista\n#define WINVER 0x0600               /* according to Microsoft's winnls.h */\n#define _WIN32_WINNT 0x0600     /* according to Microsoft's sdkddkver.h */\n#define _WIN32_WINDOWS 0x0600       /* according to Microsoft's pdh.h */\n#define _WIN32_IE 0x0700            /* according to Microsoft's sdkddkver.h */\n#define NTDDI_VERSION 0x06000000    /* according to Microsoft's sdkddkver.h */\n#include &lt;windows.h&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;typeinfo&gt;\n#include &lt;time.h&gt;\n\nHWND mainwin;\nstd::condition_variable cv;\nstd::mutex m;\nstd::unique_lock&lt;std::mutex&gt; ourlock(m);\nstd::thread *timeThread;\n\nbool wait(void)\ntry {\n    return cv.wait_for(ourlock, std::chrono::seconds(1)) == std::cv_status::timeout;\n} catch (const std::exception &amp;e) {\n    fprintf(stderr, \"%s caught: %s\\n\", typeid (e).name(), e.what());\n    return false;       // kill the thread\n}\n\nvoid threadproc(void)\n{\n    while (wait())\n        PostMessageW(mainwin, WM_APP, 0, 0);\n}\n\nHWND edit;\n\nvoid appendline(const WCHAR *wc)\n{\n    LRESULT n;\n\n    n = SendMessageW(edit, WM_GETTEXTLENGTH, 0, 0);\n    SendMessageW(edit, EM_SETSEL, n, n);\n    SendMessageW(edit, EM_REPLACESEL, FALSE, (LPARAM) wc);\n}\n\nHWND button;\n\nLRESULT CALLBACK wndproc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n    switch (uMsg) {\n    case WM_COMMAND:\n        if (lParam == (LPARAM) button)\n            appendline(L\"Saying something\\n\");\n        break;\n    case WM_APP:\n        appendline(L\"One second passed\\n\");\n        break;\n    case WM_CLOSE:\n        cv.notify_all();\n        timeThread-&gt;join();\n        PostQuitMessage(0);\n        break;\n    }\n    return DefWindowProcW(hwnd, uMsg, wParam, lParam);\n}\n\nint main(void)\n{\n    WNDCLASSW wc;\n    RECT r;\n    MSG msg;\n\n    ZeroMemory(&amp;wc, sizeof (WNDCLASSW));\n    wc.lpszClassName = L\"mainwin\";\n    wc.lpfnWndProc = wndproc;\n    wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);\n    RegisterClassW(&amp;wc);\n\n    r.left = 0;\n    r.top = 0;\n    r.right = 10 + 300 + 10;\n    r.bottom = 10 + 20 + 5 + 195 + 10;\n    AdjustWindowRectEx(&amp;r, WS_OVERLAPPEDWINDOW, FALSE, 0);\n    mainwin = CreateWindowExW(0,\n        L\"mainwin\", L\"mainwin\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, CW_USEDEFAULT,\n        r.right - r.left, r.bottom - r.top,\n        NULL, NULL, NULL, NULL);\n\n    button = CreateWindowExW(0,\n        L\"button\", L\"Say Something\",\n        BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE,\n        10, 10,\n        300, 20,\n        mainwin, NULL, NULL, NULL);\n\n    edit = CreateWindowExW(WS_EX_CLIENTEDGE,\n        L\"edit\", L\"\",\n        ES_AUTOVSCROLL | ES_LEFT | ES_MULTILINE | ES_READONLY | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_VSCROLL,\n        10, 10 + 20 + 5,\n        300, 195,\n        mainwin, NULL, NULL, NULL);\n\n    timeThread = new std::thread(threadproc);\n\n    ShowWindow(mainwin, SW_SHOWDEFAULT);\n    UpdateWindow(mainwin);\n\n    while (GetMessageW(&amp;msg, NULL, 0, 0)) {\n        TranslateMessage(&amp;msg);\n        DispatchMessageW(&amp;msg);\n    }\n    return 0;\n}\n</code></pre>\n", "Tags": "<windows><multithreading><c++11><visual-c++><visual-studio-2013>", "OwnerUserId": "3408572", "AnswerCount": "1"}, "34121629": {"ParentId": "34120422", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Your program exhibits undefined behavior, by trying to unlock a mutex locked by a different thread. <code>ourlock</code> is originally constructed on the main thread, being a global variable, at which point it locks <code>m</code>. Then you pass it to <code>cv.wait_for</code> on the second thread. This is explicitly prohibited:</p>\n<blockquote>\n<p id=\"so_34120422_34121629_0\"><strong>[thread.condition.condvar]</strong></p>\n<pre><code>template &lt;class Rep, class Period&gt;\n    cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,\n                       const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);\n</code></pre>\n<p id=\"so_34120422_34121629_1\"><strong>25</strong> <em>Requires:</em> <code>lock.owns_lock()</code> is true and <code>lock.mutex()</code> is <strong>locked by the calling thread</strong>...</p>\n</blockquote>\n<p>Emphasis mine.</p>\n", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "LastEditDate": "2015-12-07T04:27:31.090", "Id": "34121629", "Score": "3", "CreationDate": "2015-12-06T19:23:57.963", "LastActivityDate": "2015-12-07T04:27:31.090"}, "bq_ids": {"n4140": {"so_34120422_34121629_1": {"section_id": 2995, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_34120422_34121629_1": {"section_id": 2865, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_34120422_34121629_1": {"section_id": 3754, "quality": 0.8571428571428571, "length": 6}}}});