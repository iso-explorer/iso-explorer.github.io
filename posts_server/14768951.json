post_cb({"14768951": {"CommentCount": "4", "AcceptedAnswerId": "14788106", "CreationDate": "2013-02-08T09:00:15.623", "LastActivityDate": "2017-04-19T06:38:18.350", "PostTypeId": "1", "ViewCount": "2611", "FavoriteCount": "1", "Title": "Variadic function template with pack expansion not in last parameter", "Id": "14768951", "Score": "9", "Body": "<p>I am wondering why the following code doesn't compile:</p>\n<pre><code>struct S\n{\n    template &lt;typename... T&gt;\n    S(T..., int);\n};\n\nS c{0, 0};\n</code></pre>\n<p>This code fails to compile with both clang and GCC 4.8. Here is the error with clang:</p>\n<pre><code>test.cpp:7:3: error: no matching constructor for initialization of 'S'\nS c{0, 0};\n  ^~~~~~~\ntest.cpp:4:5: note: candidate constructor not viable: requires 1 argument, but 2 were provided\n    S(T..., int);\n    ^\n</code></pre>\n<p>It seems to me that this should work, and T should be deduced to be a pack of length 1.</p>\n<p>If the standards forbids doing things like this, does anyone know why?</p>\n", "Tags": "<c++><templates><c++11><variadic-templates><function-templates>", "OwnerUserId": "141719", "AnswerCount": "4"}, "14781795": {"ParentId": "14768951", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>So, there should be a workaround.  Something along these lines:</p>\n<pre><code>// Extract the last type in a parameter pack.\n// 0, the empty pack has no last type (only called if 1 and 2+ don't match)\ntemplate&lt;typename... Ts&gt;\nstruct last_type {};\n\n// 2+ in pack, recurse:\ntemplate&lt;typename T0, typename T1, typename... Ts&gt;\nstruct last_type&lt;T0, T1, Ts...&gt;:last_type&lt;T1, Ts...&gt;{};\n\n// Length 1, last type is only type:\ntemplate&lt;typename T0&gt;\nstruct last_type&lt;T0&gt; {\n  typedef T0 type;\n};\n\n\nstruct S\n{\n    // We accept any number of arguments\n    // So long as the type of the last argument is an int\n    // probably needs some std::decay to work right (ie, to implicitly work out that\n    // the last argument is an int, and not a const int&amp; or whatever)\n    template &lt;typename... T, typename=typename std::enable_if&lt;std::is_same&lt;int, typename last_type&lt;T...&gt;::type&gt;&gt;::type&gt;\n    S(T...);\n\n};\n</code></pre>\n<p>where we check that the last type of a parameter pack is an <code>int</code>, or that we where only passesd an <code>int</code>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-09-05T11:25:31.253", "Id": "14781795", "Score": "5", "CreationDate": "2013-02-08T21:40:41.260", "LastActivityDate": "2014-09-05T11:25:31.253"}, "14788106": {"ParentId": "14768951", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Because when a function parameter pack is not the last parameter, then the template parameter pack cannot be deduced from it and it will be ignored by template argument deduction. </p>\n<p>So the two arguments <code>0, 0</code> are compared against <code>, int</code>, yielding a mismatch.</p>\n<p>Deduction rules like this need to cover many special cases (like what happens when two parameter packs appear next to each other). Since parameter packs are a new feature in C++11, the authors of the respective proposal drafted the rules conservatively. </p>\n<p>Note that a trailing template parameter pack will be empty if it is not otherwise deduced. So when you call the constructor with one argument, things will work (notice the difference of template parameter pack and function parameter pack here. The former is trailing, the latter is not). </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2013-02-09T12:45:37.350", "Id": "14788106", "Score": "8", "CreationDate": "2013-02-09T12:22:31.437", "LastActivityDate": "2013-02-09T12:45:37.350"}, "43484957": {"ParentId": "14768951", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I am actually a little interested in the same thing (wanting to specialize templated parameter packs based on the final arguments).</p>\n<p>I believe there may be a path forward by combining tuple reversal (<code>std::make_tuple</code>, back-port <code>std::apply</code> for C++14, etc):</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/15904288/how-to-reverse-the-order-of-arguments-of-a-variadic-template-function/15908420#15908420\">How to reverse the order of arguments of a variadic template function?</a></li>\n</ul>\n<p>Will get back on here if it is successful.</p>\n<p>Related posts:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/42026891/parameters-after-parameter-pack-in-function?noredirect=1&amp;lq=1\">Parameters after parameter pack in function</a></li>\n<li><a href=\"https://stackoverflow.com/questions/41262641/parameter-with-non-deduced-type-after-parameter-pack\">Parameter with non-deduced type after parameter pack</a></li>\n</ul>\n<p><strong>EDIT</strong>:\nYup, figured it out after a bit; not perfect, as there are extra copies flying around, but it's a start.</p>\n<p>If you know a simpler way than what I list below, please don't hesitate to post!</p>\n<h2>TL;DR</h2>\n<p>Can do stuff like this:</p>\n<pre><code>auto my_func_callable = [] (auto&amp;&amp; ... args) {\n    return my_func(std::forward&lt;decltype(args)&gt;(args)...);\n};\nauto my_func_reversed =\n    stdcustom::make_callable_reversed(my_func_callable);\n</code></pre>\n<p>And then implement this pseduo code:</p>\n<pre><code>template&lt;typename ... Args&gt;\nvoid my_func(Args&amp;&amp; ... args, const my_special_types&amp; x);\n</code></pre>\n<p>By doing something like:</p>\n<pre><code>template&lt;typename... Args&gt;\nvoid my_func(Args&amp;&amp; ... args)\n    -&gt; call my_func_reversed(args...)\ntemplate&lt;typename... RevArgs&gt;\nvoid my_func_reversed(const my_special_types&amp; x, RevArgs&amp;&amp;... revargs)\n    -&gt; do separate things with revargs and my_special_types\n    -&gt; sub_func_reversed(revargs...)\n</code></pre>\n<p>Using the above utilities.</p>\n<p>Has some (a lot of) drawbacks. Will list them below.</p>\n<h2>Scope</h2>\n<p>This is for users of C++14 (maybe C++11), who want to borrow from the future (C++17).</p>\n<h2>Step 1: Reverse arguments</h2>\n<p>There are a few different ways to do this. I've listed out some alternatives in this example:</p>\n<ul>\n<li><a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple.cc\" rel=\"nofollow noreferrer\">tuple.cc</a> - Playground for two alternatives (credits in the source code):\n\n<ol>\n<li>Use foldable expressions and manipulate the index passed via <code>std::apply_impl</code> (credit: Orient).</li>\n<li>Use recursive templates to construct a reversed <code>index_sequence</code> (credit: Xeo)</li>\n</ol></li>\n<li><p><a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple.output.txt\" rel=\"nofollow noreferrer\">tuple.output.txt</a> - Example output</p>\n<ul>\n<li><p>This prints out the <code>reversed_index_sequence</code> template from Xeo's example. I needed this for debugging.</p>\n<pre><code>&gt;&gt;&gt; name_trait&lt;std::make_index_sequence&lt;5&gt;&gt;::name()\nstd::index_sequence&lt;0, 1, 2, 3, 4&gt;\n&gt;&gt;&gt; name_trait&lt;make_reversed_index_sequence&lt;5&gt;&gt;::name()\nstd::index_sequence&lt;4, 3, 2, 1, 0&gt;\n</code></pre></li>\n</ul></li>\n</ul>\n<p>I chose Alternative 1, as it's easier for me to digest.\nI then tried to formalize it right quick:</p>\n<ul>\n<li><a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple_future.h\" rel=\"nofollow noreferrer\">tuple_future.h</a> - Borrowing from the future (<code>namespace stdfuture</code>), and making an extension (<code>namespace stdcustom</code>)</li>\n<li><a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple_future_main.cc\" rel=\"nofollow noreferrer\">tuple_future_main.cc</a> - Simple, advanced, and useful (see below) examples using the above</li>\n<li><a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple_future_main.output.txt\" rel=\"nofollow noreferrer\">tuple_future_main.output.txt</a> - Example output</li>\n</ul>\n<p>Definition Snippets (adaptation of C++17 possible implementation of <code>std::apply</code> on cppreference.com):</p>\n<pre><code>namespace detail {\ntemplate &lt;class F, class Tuple, std::size_t... I&gt;\nconstexpr decltype(auto) apply_reversed_impl(F &amp;&amp;f,\n    Tuple &amp;&amp;t, std::index_sequence&lt;I...&gt;) \n{\n    // @ref https://stackoverflow.com/a/31044718/7829525\n    // Credit: Orient\n    constexpr std::size_t back_index = sizeof...(I) - 1;\n    return f(std::get&lt;back_index - I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\n} // namespace detail\ntemplate &lt;class F, class Tuple&gt;\nconstexpr decltype(auto) apply_reversed(F &amp;&amp;f, Tuple &amp;&amp;t) \n{\n    // Pass sequence by value to permit template inference\n    // to parse indices as parameter pack\n    return detail::apply_reversed_impl(\n        std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),\n        std::make_index_sequence&lt;\n            std::tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;{});\n}\n</code></pre>\n<p>Usage Snippets: (from <code>tuple_future_main.output.txt</code>, copied from above)</p>\n<pre><code>auto my_func_callable = [] (auto&amp;&amp; ... args) {\n    return my_func(std::forward&lt;decltype(args)&gt;(args)...);\n};\nauto my_func_reversed =\n    stdcustom::make_callable_reversed(my_func_callable);\n</code></pre>\n<h2>Step 2: Buckle your shoe (with reversed parameter packs)</h2>\n<p>First, establish the patterns for the final arguments that you wish to use. You will have to explicitly enumerate these, as you can only have one parameter pack.</p>\n<p>(Taken from <a href=\"https://github.com/EricCousineau-TRI/repro/blob/fa514e1/cpp_quick/tuple_future_main.cc#L58\" rel=\"nofollow noreferrer\">tuple_future_main.cc</a>):</p>\n<p>Example Scenario:</p>\n<p>We like to add things to containers with a name, something of the form:</p>\n<pre><code>add_item(const Item&amp; item, const string&amp; name, Container&amp; c)\n</code></pre>\n<p>We can also construct an Item with a [awfully large] number of overloads, and \nwe have convenenience overloads:</p>\n<pre><code>add_item(${ITEM_CTOR_ARGS}, const string&amp; name, Container&amp; c)\n</code></pre>\n<p>To do so, we can declare the following:</p>\n<pre><code>void add_item_direct(const Item&amp; item, const string&amp; name, Container&amp; c)\nItem create_item(Args&amp;&amp;... args)\n</code></pre>\n<p>And then define our generic interfaces:</p>\n<pre><code>template&lt;typename... Args&gt;\nvoid add_item(Args&amp;&amp;... args) {\n    ...\n    auto reversed = stdcustom::make_callable_reversed(callable);\n    reversed(std::forward&lt;Args&gt;(args)...);\n}\ntemplate&lt;typename ... RevArgs&gt;\nvoid add_item_reversed(Container&amp; c, const string&amp; name, RevArgs&amp;&amp;... revargs)\n{\n    ...\n    static auto ctor = VARIADIC_CALLABLE(create_item,);\n    ...\n    auto item = ctor_reversed(std::forward&lt;RevArgs&gt;(revargs)...);\n    add_item_direct(item, name, c);\n}\n</code></pre>\n<p>Now we can do stuff like: (taken from <code>tuple_future_main.output.txt</code>)</p>\n<pre><code>&gt;&gt;&gt; (add_item(Item(\"attribute\", 12), \"bob\", c));\n&gt;&gt;&gt; (add_item(\"attribute\", 12, \"bob\", c));\n&gt;&gt;&gt; (add_item(Item(2, 2.5, \"twelve\"), \"george\", c));\n&gt;&gt;&gt; (add_item(2, 2.5, \"twelve\", \"george\", c));\n&gt;&gt;&gt; (add_item(Item(2, 15.), \"again\", c));\n&gt;&gt;&gt; (add_item(2, 15., \"again\", c));\n&gt;&gt;&gt; c\nbob - ctor3: ctor3: ctor1: attribute (12, 10)\nbob - ctor3: ctor1: attribute (12, 10)\ngeorge - ctor3: ctor3: ctor2: 2, 2.5 (twelve)\ngeorge - ctor3: ctor2: 2, 2.5 (twelve)\nagain - ctor3: ctor3: ctor2: 2, 15 ()\nagain - ctor3: ctor2: 2, 15 ()\n</code></pre>\n<p>Note the extra copy constructors... :(</p>\n<h2>Drawbacks</h2>\n<ul>\n<li>Ugly as hell</li>\n<li>May not be useful\n\n<ul>\n<li>It could be easier to just refactor your interfaces\n\n<ul>\n<li>However, this could be used as a stop-gap to transition to a more generalized interface.</li>\n<li>Possibly fewer lines to delete.</li>\n</ul></li>\n<li>Especially if it plugs your development process with template explosions</li>\n</ul></li>\n<li>Can't nail down where the extra copies are coming from.\n\n<ul>\n<li>It may be due to judicious usage of variadic lambdas</li>\n</ul></li>\n<li>You have to carefully craft your base functionality\n\n<ul>\n<li>You shouldn't try to extend an existing function.</li>\n<li>Parameter packs will be greedy in how they match to functions</li>\n<li>You either need to explicitly spell out each overload you want, or bow down and let the variadic parameter pack dispatch to your desired functionality\n\n<ul>\n<li>If you find an elegant way around this, please let me know.</li>\n</ul></li>\n</ul></li>\n<li>Template errors are shitty.\n\n<ul>\n<li>Granted, not too shitty. But it's hard to infer that you missed an available overload.</li>\n</ul></li>\n<li>Wraps a lot of simple functionality in lambdas\n\n<ul>\n<li>You may be able to use <code>make_reversed_index_sequence</code> and directly dispatch to the function (mentioned in other SO posts). But that's painful to repeat.</li>\n</ul></li>\n</ul>\n<h2>Todo</h2>\n<ul>\n<li>Get rid of extra copies</li>\n<li>Minimize the need for all the lambdas\n\n<ul>\n<li>Not necessary if you have a <code>Callable</code></li>\n</ul></li>\n<li><p>Try to combat parameter pack greediness</p>\n<ul>\n<li><p>Is there a generalized <code>std::enable_if</code> matching that matches to both lvalue- and rvalue-references, and possibly handle forwarding compatible implicit copy constructors?</p>\n<pre><code>template&lt;typename ... Args&gt;\nvoid my_func(Args&amp;&amp; ... args) // Greedy\nvoid my_func(magical_ref_match&lt;string&gt;::type, ...)\n    // If this could somehow automatically snatch `const T&amp;` and `T&amp;&amp;` from the parameter pack...\n    // And if it can be used flexible with multiple arguments, combinatorically\n</code></pre></li>\n</ul></li>\n</ul>\n<h2>Hopes</h2>\n<ul>\n<li>Maybe C++17 will support non-final parameter pack arguments, such that all of this can be discarded... <em>fingers crossed</em></li>\n</ul>\n", "OwnerUserId": "7829525", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:55.110", "Id": "43484957", "Score": "1", "CreationDate": "2017-04-19T01:52:08.450", "LastActivityDate": "2017-04-19T06:38:18.350"}, "14769093": {"ParentId": "14768951", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>From the working draft of the standard N3376 \u00a7 14.1 is a probable section to read about this.</p>\n<p>Below is \u00a7 14.1.11</p>\n<blockquote>\n<p id=\"so_14768951_14769093_0\">If a template-parameter of a class template or alias template has a\n  default template-argument, each subsequent template-parameter shall\n  either have a default template-argument supplied or be a template\n  parameter pack. If a template-parameter of a primary class template or\n  alias template is a template parameter pack, it shall be the last\n  template-parameter. A template parameter pack of a function template\n  shall not be followed by another template parameter unless that\n  template parameter can be deduced from the parameter-type-list of the\n  function template or has a default argument.</p>\n</blockquote>\n", "OwnerUserId": "1381108", "LastEditorUserId": "560648", "LastEditDate": "2013-02-09T13:07:56.900", "Id": "14769093", "Score": "0", "CreationDate": "2013-02-08T09:09:45.663", "LastActivityDate": "2013-02-09T13:07:56.900"}, "bq_ids": {"n4140": {"so_14768951_14769093_0": {"section_id": 64, "quality": 1.0, "length": 47}}, "n3337": {"so_14768951_14769093_0": {"section_id": 59, "quality": 0.9361702127659575, "length": 44}}, "n4659": {"so_14768951_14769093_0": {"section_id": 66, "quality": 1.0, "length": 47}}}});