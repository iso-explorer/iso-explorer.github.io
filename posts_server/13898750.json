post_cb({"13898805": {"ParentId": "13898750", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-12-16T05:11:52.980", "Score": "2", "LastEditorUserId": "951890", "LastEditDate": "2012-12-16T05:40:29.893", "Id": "13898805", "OwnerUserId": "951890", "Body": "<p>Section 8.5.3.5 of the C++03 standard states that this is implementation-defined:</p>\n<blockquote>\n<p id=\"so_13898750_13898805_0\">If the initializer expression is an rvalue, with T2 a class type, and \"cv1 T1\" is reference-compatible with \"cv2 T2,\" the reference is bound in one of the following ways (the choice is implementation-defined):</p>\n<p id=\"so_13898750_13898805_1\">-- The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</p>\n<p id=\"so_13898750_13898805_2\">-- A temporary of type \"cv1 T2\" [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary.  The reference is bound to the temporary or to a sub-object within the temporary.</p>\n<p id=\"so_13898750_13898805_3\">The constructor that would be used to make the copy shall be callable whether or not the copy is actually done.</p>\n</blockquote>\n<p>So it appears that both implementations are consistent with the C++03 standard.</p>\n<p>The last sentence is a little confusing, but the way I read it, it means that the implementation may choose the second way, but still optimize away the copy.  In that case, the copy constructor would have to be accessible even though the copy wasn't actually done, similar to return value optimization.</p>\n<p>With the C++11 standard, the second way is no longer an option.</p>\n", "LastActivityDate": "2012-12-16T05:40:29.893"}, "13898867": {"ParentId": "13898750", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-12-16T05:23:40.527", "Score": "4", "LastEditorUserId": "452307", "LastEditDate": "2012-12-16T06:08:46.453", "Id": "13898867", "OwnerUserId": "452307", "Body": "<blockquote>\n<p id=\"so_13898750_13898867_0\"><strong>So is it necessary to have a copy constructor accessible when binding a temporary to a reference?</strong></p>\n</blockquote>\n<p>Post C++11 - No<br>\nPre C++11 - Yes. </br></p>\n<hr>\n<p>This code compiles fine with GCC 4.7.2 because it is compliant with the C++11 standard.      </p>\n<p>C++11 standard mandates that when a const reference is initialized from <code>prvalue</code>, it must be bound directly to the reference object and no temporary is permitted to be created. Also, the copy constructor is not used or required.</p>\n<p>Prior to C++11 the rules were different. And this behavior(<em>whether copy constructor will be called</em>) is implementation defined. C++03 allowed the copy constructor being called while binding a const reference to an temporary and hence post C++11 the copy constructor needs to be accessible. Visual C++2010 adheres to the C++03 standard.</p>\n</hr>", "LastActivityDate": "2012-12-16T06:08:46.453"}, "13898750": {"CommentCount": "8", "ViewCount": "417", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-16T04:59:49.477", "LastActivityDate": "2012-12-16T06:08:46.453", "Title": "Does binding temporary to a reference require a copy constructor in C++?", "AcceptedAnswerId": "13898867", "LastEditDate": "2017-05-23T11:52:19.650", "Id": "13898750", "Score": "7", "Body": "<p>Consider the following code:</p>\n<pre><code>class A {\n  A(const A&amp;);\n public:\n  A() {}\n};\n\nint main() {\n  const A &amp;a = A();\n}\n</code></pre>\n<p>This code compiles fine with GCC 4.7.2, but fails to compile with Visual C++ 2010 with the following error:</p>\n<pre><code>test.cc(8) : error C2248: 'A::A' : cannot access private member declared in class 'A'\n        test.cc(2) : see declaration of 'A::A'\n        test.cc(1) : see declaration of 'A'\n</code></pre>\n<p>So is it necessary to have a copy constructor accessible when binding a temporary to a reference?</p>\n<p>This is somewhat related to my previous question:</p>\n<p><a href=\"https://stackoverflow.com/q/13823626/471164\">Is there a way to disable binding a temporary to a const reference?</a></p>\n", "Tags": "<c++><reference><copy-constructor><temporary>", "OwnerUserId": "471164", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13898750_13898805_1": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}, "so_13898750_13898867_0": {"section_id": 480, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_13898750_13898867_0": {"section_id": 471, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_13898750_13898805_1": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}, "so_13898750_13898805_0": {"section_id": 4087, "quality": 0.5333333333333333, "length": 8}}}, "13898775": {"ParentId": "13898750", "CommentCount": "0", "CreationDate": "2012-12-16T05:06:39.627", "OwnerUserId": "726361", "PostTypeId": "2", "Id": "13898775", "Score": "0", "Body": "<p>Visual C++ is incorrect; the Standard does not indicate that the copy constructor must be accessible to bind a <code>const</code> reference to a temporary.</p>\n", "LastActivityDate": "2012-12-16T05:06:39.627"}});