post_cb({"37575546": {"ParentId": "37575219", "CommentCount": "1", "Body": "<p>The expression <code>function_with_side_effects() &amp;&amp; false</code> is the same as <code>function_with_side_effects()</code> except that the result value is unconditionally false. The function call cannot be eliminated. The left operand of <code>&amp;&amp;</code> is always evaluated; it is only the right operand whose evaluation is conditional.</p>\n<p>Perhaps you're really asking about <code>false &amp;&amp; function_with_side_effects()</code>?</p>\n<p>In this expression, the function call must not happen. This is obvious statically, from the <code>false</code>. Since it must not happen, the translation of the code can be such that the function isn't referenced in the generated code.</p>\n<p>However, suppose that we have <code>false &amp;&amp; nonexistent_function()</code> which is the only reference to <code>nonexistent_function</code>, and that function isn't defined anywhere. If this is completely optimized away, then the program will link. Thereby, the implementation will fail to diagnose a violation of the One Definition Rule.</p>\n<p>So I suspect that, for conformance, the symbol still has to be referenced, even if it isn't used in the code.</p>\n", "OwnerUserId": "1250772", "PostTypeId": "2", "Id": "37575546", "Score": "0", "CreationDate": "2016-06-01T17:47:58.740", "LastActivityDate": "2016-06-01T17:47:58.740"}, "37575537": {"ParentId": "37575219", "CommentCount": "0", "Body": "<p><strong>No.</strong></p>\n<hr>\n<p>In general, the C++ Standard specifies the result of the computation in terms of observable effects and as long as your code is written in a Standard-compliant way (avoid Undefined Behavior, Unspecified Behavior and Implementation-Defined Behavior) then a compliant compiler has to produce the observable effects in the order they are specified.</p>\n<p>There are only <em>two</em> caveats in the Standard: Copy Elision when returning a value allows the compiler to omit a call to the Copy Constructor or to the Move Constructor without a care for their (potential) observable effects.</p>\n<p>The compiler is otherwise only allowed to optimize non-observable behavior, such as for example using less CPU registers or not writing a value in a memory location you never read afterward.</p>\n<p><em>Note: in C++, the address of an object can be observed, and is thus considered observable; it's low-level like that.</em></p>\n<hr>\n<p>In your particular case, let's refer to <a href=\"https://github.com/cplusplus/draft/blob/6be63b64af6c2a6cb40ddf76268dd6d5297f5394/source/expressions.tex#L4364\" rel=\"nofollow\">the Standard</a>:</p>\n<blockquote>\n<p id=\"so_37575219_37575537_0\"><strong>[expr.log.and] Logical AND operator</strong></p>\n<ol>\n<li><p id=\"so_37575219_37575537_1\">The <code>&amp;&amp;</code> operator groups left-to-right. The operands are both contextually converted to <code>bool</code> (Clause 4). The result is <code>true</code> if both operands are <code>true</code> and <code>false</code> otherwise. Unlike <code>&amp;</code>, <code>&amp;&amp;</code> guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is <code>false</code>.</p></li>\n<li><p id=\"so_37575219_37575537_2\">The result is a <code>bool</code>. If the second expression is evaluated, every value computation and side effect associated with the first expression is sequenced before every value computation and side effect associated with the second expression.</p></li>\n</ol>\n</blockquote>\n<p>The key here is (2): <em>sequenced after</em>/<em>sequenced before</em> is standardese speak for ordering the observable events.</p>\n</hr></hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "37575537", "Score": "4", "CreationDate": "2016-06-01T17:47:31.080", "LastActivityDate": "2016-06-01T17:47:31.080"}, "37575376": {"ParentId": "37575219", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>A compiler is allowed to optimise out anything, as long as it doesn't break the <strong>as-if rule</strong>. The as-if rule states that with respect to <em>observable behaviour,</em> a program must behave <em>as if</em> it was executed by the exact rules of the C++ abstract machine (basically normal, unoptimised semantics of code).</p>\n<p>Observable behaviour is:</p>\n<ul>\n<li>Access to <code>volatile</code> objects</li>\n<li>Writing to files</li>\n<li>Input &amp; output on interactive devices</li>\n</ul>\n<p>As long as the program does the three things above in correct order, it is allowed to deviate from other source code functionality as much as it wants.</p>\n<p>Of course, in practice, the number of operations which must be left intact by the compiler is much larger than the above, simply because the compiler has to assume that any function whose code it cannot see can, potentially, have an observable effect.</p>\n<p>So, in your case, unless the compiler can <em>prove</em> that no action inside <code>function_with_side_effects</code> can ever affect observable behaviour (directly or indirectly by e.g. setting a flag tested later), it has to execute a call of <code>function_with_side_effects</code>, because it could violate the as-if rule if it didn't.</p>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/users/2756719/t-c\">@T.C.</a> correctly pointed out in comments, there are a few exceptions to the as-if rule, when a compiler is allowed to perform optimisations which change observable behaviour; the most commonly encountered among these exceptions being copy elision. However, none of the exceptions come into play in the code in question.</p>\n</hr>", "OwnerUserId": "1782465", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:28:58.260", "Id": "37575376", "Score": "9", "CreationDate": "2016-06-01T17:38:06.830", "LastActivityDate": "2016-06-01T17:59:10.260"}, "37575345": {"ParentId": "37575219", "CommentCount": "0", "Body": "<p>According to <a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">standard</a>:</p>\n<p>5.14 Logical AND operator:</p>\n<p>1 The &amp;&amp; operator groups left-to-right. The operands are both contextually converted to bool.\nThe result is true if both operands are true and false otherwise. Unlike &amp;, &amp;&amp; <strong>guarantees left-to-right evaluation</strong>: the second operand is not evaluated if the first operand is false.</p>\n<p>2 The result is a bool. If the second expression is evaluated, every value computation and <strong>side effect associated with the first expression</strong> is sequenced <strong>before</strong> every value computation and side effect associated with the\nsecond expression.</p>\n<p>So, according to these rules compiler will generate code where <code>function_with_side_effects()</code> will be evaluated.</p>\n", "OwnerUserId": "210971", "PostTypeId": "2", "Id": "37575345", "Score": "1", "CreationDate": "2016-06-01T17:36:35.600", "LastActivityDate": "2016-06-01T17:36:35.600"}, "37575219": {"CommentCount": "1", "ViewCount": "133", "CreationDate": "2016-06-01T17:29:06.530", "LastActivityDate": "2016-06-01T17:59:10.260", "Title": "C++ short circuit evaluation w.r.t optimization", "AcceptedAnswerId": "37575376", "PostTypeId": "1", "Id": "37575219", "Score": "3", "Body": "<p>Simple question, but surprisingly hard to search for.\nFor the statement <code>A &amp;&amp; B</code> I know there is a sequence point between the evaluation of <code>A</code> and <code>B</code>, and I know that the order of evaluation is left-to-right, but what is a compiler allowed to do when it can prove that <code>B</code> is always false (perhaps even explicitly so)?</p>\n<p>Namely, for <code>function_with_side_effects() &amp;&amp; false</code> is the compiler allowed to optimize away the function call?</p>\n", "Tags": "<c++>", "OwnerUserId": "1837688", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_37575219_37575537_2": {"section_id": 6164, "quality": 0.9583333333333334, "length": 23}, "so_37575219_37575537_1": {"section_id": 6163, "quality": 0.896551724137931, "length": 26}}, "n3337": {"so_37575219_37575537_2": {"section_id": 5925, "quality": 0.9583333333333334, "length": 23}, "so_37575219_37575537_1": {"section_id": 5924, "quality": 0.896551724137931, "length": 26}}, "n4659": {"so_37575219_37575537_2": {"section_id": 7661, "quality": 0.9583333333333334, "length": 23}, "so_37575219_37575537_1": {"section_id": 7660, "quality": 0.896551724137931, "length": 26}}}});