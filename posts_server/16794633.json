post_cb({"bq_ids": {"n4140": {"so_16794633_16794743_2": {"length": 11, "quality": 1.0, "section_id": 303}, "so_16794633_16794743_1": {"length": 11, "quality": 1.0, "section_id": 303}, "so_16794633_16794743_4": {"length": 20, "quality": 0.8695652173913043, "section_id": 5938}, "so_16794633_16794743_3": {"length": 9, "quality": 1.0, "section_id": 303}}, "n3337": {"so_16794633_16794743_2": {"length": 11, "quality": 1.0, "section_id": 294}, "so_16794633_16794743_1": {"length": 11, "quality": 1.0, "section_id": 294}, "so_16794633_16794743_4": {"length": 20, "quality": 0.8695652173913043, "section_id": 5710}, "so_16794633_16794743_3": {"length": 9, "quality": 1.0, "section_id": 294}}, "n4659": {"so_16794633_16794743_2": {"length": 11, "quality": 1.0, "section_id": 310}, "so_16794633_16794743_1": {"length": 11, "quality": 1.0, "section_id": 310}, "so_16794633_16794743_4": {"length": 20, "quality": 0.8695652173913043, "section_id": 7422}, "so_16794633_16794743_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 310}}}, "16795774": {"Id": "16795774", "PostTypeId": "2", "Body": "<p>Seems to me a simpler solution would be to just exclude one of the two arguments from trying to deduce A, and the second one is the better candidate:</p>\n<pre><code>template &lt;typename A&gt;\nvoid call(void (T::*f)(A), typename std::identity&lt;A&gt;::type a)\n{\n    (o_.*f)(a);\n}\n</code></pre>\n<p>If you don't have <code>std::identity</code> in your type traits, use this one:</p>\n<pre><code>template &lt;typename T&gt;\nstruct identity { typedef T type; };\n</code></pre>\n<p>Here's why this works: the compiler cannot deduce A from the second argument, since it's just a template parameter to something that a nested type is taken of. Basically, it can't pattern-match any incoming type against something_that_contains_A::type - due to template specialization, it can't reverse-engineer the argument from the definition of the left side. The net result is that the second argument is an \"undeduced context\". The compiler will not attempt to deduce A from there.</p>\n<p>This leaves the first argument as the only place where A can be deduced from. With only one deduction result for A, it is not ambiguous and deduction succeeds. The compiler then proceeds to substitute the deduction result into every place where A was used, including the second argument.</p>\n", "LastEditorUserId": "8922", "LastActivityDate": "2013-05-29T11:15:34.713", "Score": "4", "CreationDate": "2013-05-28T15:23:36.203", "ParentId": "16794633", "CommentCount": "5", "LastEditDate": "2013-05-29T11:15:34.713", "OwnerUserId": "8922"}, "16794633": {"ViewCount": "1568", "Body": "<p>I have the following template class which acts as a proxy. It has a method named <code>call</code> which is supposed to be used to call methods on the wrapped object. There's a problem with it. The type deduction fails and I cannot understand why.</p>\n<p><code>Hudsucker::f</code> takes an <code>std::string</code> and then no matter if I pass an <code>std::string</code> or a <code>const</code> reference to it the compiler is able to call the right method.</p>\n<p>But in case of <code>Hudsucker::g</code> with takes a <code>const</code> reference to <code>std::string</code> type deduction fails in both cases with both GCC and Clang.</p>\n<p><strong>GCC error for the first line:</strong></p>\n<pre><code>main.cpp:36:28: error: no matching function for call to \u2018Proxy&lt;Hudsucker&gt;::call(void (Hudsucker::*)(const string&amp;), const string&amp;)\u2019\nmain.cpp:36:28: note: candidate is:\nmain.cpp:10:10: note: template&lt;class A&gt; void Proxy::call(void (T::*)(A), A) [with A = A; T = Hudsucker]\nmain.cpp:10:10: note:   template argument deduction/substitution failed:\nmain.cpp:36:28: note:   deduced conflicting types for parameter \u2018A\u2019 (\u2018const std::basic_string&lt;char&gt;&amp;\u2019 and \u2018std::basic_string&lt;char&gt;\u2019)\n</code></pre>\n<p>Especially this bit is strange: <code>no matching function for call to  Proxy&lt;Hudsucker&gt;::call(void (Hudsucker::*)(const string&amp;), const string&amp;)</code>. That is exactly the signature I would expect to see work.</p>\n<p><strong>Clang error for the first line:</strong></p>\n<pre><code>main.cpp:36:7: error: no matching member function for call to 'call'\n    p.call(&amp;Hudsucker::g, s); // &lt;- Compile error\n    ~~^~~~\nmain.cpp:10:10: note: candidate template ignored: deduced conflicting types for parameter 'A' ('const std::basic_string&lt;char&gt; &amp;' vs. 'std::basic_string&lt;char&gt;')\n    void call(void (T::*f)(A), A a)\n</code></pre>\n<p><strong>Code:</strong></p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; class Proxy\n{\npublic:\n    Proxy(T &amp;o): o_(o) {}\n\n    template &lt;typename A&gt;\n    void call(void (T::*f)(A), A a)\n    {\n        (o_.*f)(a);\n    }\n\nprivate:\n    T &amp;o_;\n};\n\nclass Hudsucker\n{\npublic:\n    void f(std::string s) {}\n    void g(std::string const &amp;s) {}\n};\n\nint main()\n{\n    Hudsucker h;\n    Proxy&lt;Hudsucker&gt; p(h);\n    std::string const s = \"For kids, you know.\";\n    std::string const &amp;r = s;\n\n    p.call(&amp;Hudsucker::f, s);\n    p.call(&amp;Hudsucker::f, r);\n\n    p.call(&amp;Hudsucker::g, s); // &lt;- Compile error\n    p.call(&amp;Hudsucker::g, r); // &lt;- Compile error\n\n    return 0;\n}\n</code></pre>\n<p>Could you explain why the type deduction fails in that way? Is there a way to get this to compile with <code>const</code> references?</p>\n", "AcceptedAnswerId": "16794743", "Title": "Type deduction fails with pointer to member method", "CreationDate": "2013-05-28T14:28:13.897", "Id": "16794633", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-10-08T19:50:50.677", "Score": "3", "OwnerUserId": "362938", "Tags": "<c++><templates><type-deduction>", "AnswerCount": "3"}, "16794743": {"Id": "16794743", "PostTypeId": "2", "Body": "<p>The compiler cannot deduce the type <code>A</code>, since it has contrasting information. From the type of the member function, it would deduce <code>A</code> to be <code>std::string const&amp;</code>, while from the type of the second argument, it would deduce it to be <code>std::string</code>.</p>\n<p>Change your function template into one that allows different types for the parameter of the member function and the argument actually provided, and then SFINAE-constrain the latter to be convertible to the former:</p>\n<pre><code>template &lt;typename A, typename B,\n    typename std::enable_if&lt;std::is_convertible&lt;B, A&gt;::value&gt;::type* = nullptr&gt;\nvoid call(void (T::*f)(A), B a)\n{\n    (o_.*f)(a);\n}\n</code></pre>\n<p>If you are wondering why from this function call:</p>\n<pre><code>std::string const s = \"For kids, you know.\";\n// ...\np.call(&amp;Hudsucker::g, s);\n</code></pre>\n<p>The compiler would deduce <code>std::string</code>, that's because of paragraph 14.8.2.1/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16794633_16794743_0\"><strong>If <code>P</code> is not a reference type</strong>:</p>\n<p id=\"so_16794633_16794743_1\">\u2014 If <code>A</code> is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is\n  used in place of <code>A</code> for type deduction; otherwise,</p>\n<p id=\"so_16794633_16794743_2\">\u2014 If <code>A</code> is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)\n  is used in place of <code>A</code> for type deduction; otherwise,</p>\n<p id=\"so_16794633_16794743_3\">\u2014 <strong>If A is a cv-qualified type, the top level cv-qualifiers of <code>A</code>\u2019s type are ignored for type deduction</strong>.</p>\n</blockquote>\n<p>In the quoted paragraph, <code>P</code> is your <code>A</code> (from your function template) and <code>A</code> is <code>std::string const</code>. This means the <code>const</code> in <code>std::string const</code> is ignored for type deduction. To see this better, consider this simpler example:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nvoid foo(T t)\n{\n    // Does NOT fire!\n    static_assert(std::is_same&lt;T, int&gt;::value, \"!\");\n}\n\nint main()\n{\n    int const x = 42;\n    foo(x);\n}\n</code></pre>\n<p>Considering the second function call:</p>\n<pre><code>std::string const &amp;r = s;\n// ...\np.call(&amp;Hudsucker::g, r);\n</code></pre>\n<p>The reason is that the type of the <em>id-expression</em> <code>r</code> is <code>std::string const</code>. The reference is dropped because of paragraph 5/5:</p>\n<blockquote>\n<p id=\"so_16794633_16794743_4\"><strong>If an expression initially has the type \u201creference to <code>T</code>\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to\n  any further analysis</strong>. The expression designates the object or function denoted by the reference, and the\n  expression is an lvalue or an xvalue, depending on the expression.</p>\n</blockquote>\n<p>And now we're back to the same situation as for the first function call.</p>\n<hr>\n<p>As pointed out by Mike Vine in the comments, you may want to <em>perfectly-forward</em> your second argument when giving it in input to the first (member function) argument during the function call:</p>\n<pre><code>#include &lt;utility&gt; // For std::forward&lt;&gt;()\n\ntemplate &lt;typename A, typename B,\n    typename std::enable_if&lt;std::is_convertible&lt;B, A&gt;::value&gt;::type* = nullptr&gt;\nvoid call(void (T::*f)(A), B&amp;&amp; a)\n{\n    (o_.*f)(std::forward&lt;B&gt;(a));\n}\n</code></pre>\n<hr>\n<p>If you cannot afford C++11, then you won't be allowed to use default arguments for template parameters. In that case, you can use the SFINAE-constraint on the return type:</p>\n<pre><code>template &lt;typename A, typename B&gt;\ntypename enable_if&lt;is_convertible&lt;B, A&gt;::value&gt;::type \n//       ^^^^^^^^^ ^^^^^^^^^^^^^^\n//       But how about these traits?\n    call(void (T::*f)(A), B a)\n{\n    (o_.*f)(a);\n}\n</code></pre>\n<p>Notice, that <code>std::enable_if</code> and <code>std::is_convertible</code> are not part of the C++03 Standard Library. Fortunately, Boost has its own version of <code>enable_if</code> and <code>is_convertible</code>, so:</p>\n<pre><code>#include &lt;boost/utility/enable_if.hpp&gt;\n#include &lt;boost/type_traits/is_convertible.hpp&gt;\n\ntemplate &lt;typename T&gt; class Proxy\n{\npublic:\n    Proxy(T &amp;o): o_(o) {}\n\n    template &lt;typename A, typename B&gt;\n    typename boost::enable_if&lt;boost::is_convertible&lt;B, A&gt;&gt;::type \n        call(void (T::*f)(A), B a)\n    {\n        (o_.*f)(a);\n    }\n\nprivate:\n    T &amp;o_;\n};\n</code></pre>\n<p>Notice, that <code>boost::enable_if</code> accepts as its first template argument a <em>type</em> which defines a <code>value</code> boolean member, whereas <code>std::enable_if</code> accepts a boolean value. The equivalent of <code>std::enable_if</code> in Boost is <code>boost::enable_if_c</code>.</p>\n</hr></hr>", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-28T15:19:20.800", "Score": "11", "CreationDate": "2013-05-28T14:33:13.210", "ParentId": "16794633", "CommentCount": "9", "LastEditDate": "2013-05-28T15:19:20.800", "OwnerUserId": "1932150"}, "26263793": {"Id": "26263793", "PostTypeId": "2", "Body": "<p>You just need to pass template argument to template function when calling it in your main.</p>\n<pre><code>int main()\n{\n    Hudsucker h;\n    Proxy&lt;Hudsucker&gt; p(h);\n    std::string const s = \"For kids, you know.\";\n    std::string const &amp;r = s;\n\n    p.call(&amp;Hudsucker::f, s);\n    p.call(&amp;Hudsucker::f, r);\n\n    //just add template argument to template function call !!!\n    p.call&lt; const std::string &amp; &gt; (&amp;Hudsucker::g, s); // &lt;- NO  Compile error !!!!\n    p.call&lt; const std::string &amp; &gt; (&amp;Hudsucker::g, r); // &lt;- NO Compile error !!!**\n\n   return 0;\n</code></pre>\n<p>}</p>\n", "LastEditorUserId": "2264070", "LastActivityDate": "2014-10-08T19:50:50.677", "Score": "1", "CreationDate": "2014-10-08T18:22:47.393", "ParentId": "16794633", "CommentCount": "0", "LastEditDate": "2014-10-08T19:50:50.677", "OwnerUserId": "2264070"}});