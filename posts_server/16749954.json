post_cb({"16749996": {"Id": "16749996", "PostTypeId": "2", "Body": "<p>you can pass the value as argument to initialize the memory in heap.</p>\n<pre><code> int *iptr = new int(20);\n</code></pre>\n<p>it is initialized with value 20;</p>\n<p>stack: contains local variables. so when you create a pointer and assign it with local objects. its pointing to variables in stack. we are not creating pointer on heap\n.</p>\n", "LastEditorUserId": "1559201", "LastActivityDate": "2013-05-25T13:34:15.110", "Score": "0", "CreationDate": "2013-05-25T13:24:20.200", "ParentId": "16749954", "CommentCount": "0", "OwnerUserId": "1559201", "LastEditDate": "2013-05-25T13:34:15.110"}, "bq_ids": {"n4140": {"so_16749954_16750072_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 6082}}, "n3337": {"so_16749954_16750072_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5850}}, "n4659": {"so_16749954_16750072_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7578}}}, "16750028": {"Id": "16750028", "PostTypeId": "2", "Body": "<p><strong>Is there a way to create an initialize a pointer with one instruction?</strong> </p>\n<p>yes:</p>\n<pre><code>int * a = new int(20); //initialized with 20;\n</code></pre>\n<p><strong>How can I create a pointer on the stack?</strong></p>\n<pre><code>int myVar = 20;\nint* pVar = &amp;myVar;    //copied your code snipped It's alright\n</code></pre>\n", "LastActivityDate": "2013-05-25T13:27:49.410", "CommentCount": "3", "CreationDate": "2013-05-25T13:27:49.410", "ParentId": "16749954", "Score": "2", "OwnerUserId": "856007"}, "16750072": {"Id": "16750072", "PostTypeId": "2", "Body": "<pre><code>int* max = new int;\n</code></pre>\n<p>The above line creates a pointer on the stack and initializes it with an integer stored on the heap. Whenever <code>new</code> is involved in an expression, it will return a pointer to its dynamically-created operand:</p>\n<p>Per Paragraph 5.3.4/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16749954_16750072_0\">Entities created by a <code>new</code>-expression have dynamic storage duration (3.7.4). <em>[ -- ]</em> If the entity is a non-array object, the new-expression returns a pointer to the object created. If it is an array, the <code>new</code>-expression returns a pointer to the initial element of the array.</p>\n</blockquote>\n<pre><code>int myVar = 20;\nint* pVar = &amp;myVar;\n</code></pre>\n<p>In this example, both the pointer and its value is stored on the stack. A <code>new</code>-expression was not involved in the assignment, so nothing is created on the heap in this situation.</p>\n<p>If you want to initialize the value of the pointed-to object in one line, you'd have to <em>value-initialize</em> it like so:</p>\n<pre><code>int* max = new int(5);\n</code></pre>\n<p>or in C++11 you can use uniform-initialization:</p>\n<pre><code>int* max = new int{5};\n</code></pre>\n<p>It is also important that you remember to <code>delete</code> that which you created with <code>new</code>. Since the memory is in dynamic allocation, its lifetime is not dependent by the scope in which it was created. If you forget to <code>delete</code> your program will get a memory leak.</p>\n<pre><code>delete max;\n</code></pre>\n<p>And if <code>max</code> was a pointer set to an array created by a <code>new</code>-expression, you'd use <code>delete[]</code>:</p>\n<pre><code>delete[] max;\n</code></pre>\n<p><sub>Note: If a pointer was <em>not</em> initialized by a <code>new</code>-expression, then there is no need to delete.</sub></p>\n<p>It's typically recommended that you use containers to mangage the memory for you. Something like <code>std::unique_ptr</code> will do. Once its destructor is called, the memory it holds is deleted:</p>\n<pre><code>std::unique_ptr&lt;int&gt; max{new int{5}};\n</code></pre>\n<p>In C++14 we have <code>make_unique</code>:</p>\n<pre><code>auto max = std::make_unique&lt;int&gt;(5);\n</code></pre>\n", "LastEditorUserId": "701092", "LastActivityDate": "2013-05-25T14:27:18.970", "Score": "6", "CreationDate": "2013-05-25T13:32:00.610", "ParentId": "16749954", "CommentCount": "0", "OwnerUserId": "701092", "LastEditDate": "2013-05-25T14:27:18.970"}, "16750014": {"Id": "16750014", "PostTypeId": "2", "Body": "<p>Pointers are normal variables, which content is a memory address. This memory can be heap memory or stack memory. Don't confuse the pointer with the memory space it points to.</p>\n<p>Your first code allocates space <em>on the heap</em> which can hold an int. You store a pointer to that memory <em>on the stack</em>.</p>\n<p>Your second code allocates space <em>on the stack</em> which can hold an int. You store a pointer to that memory <em>on the stack</em>.</p>\n<p>So <strong>both</strong> pointers are on the stack, but only the second <em>points to the stack</em>.</p>\n<p>In both cases, the type you allocate is a primitive type. Primitive types aren't initialized per default, unless you immediately assign a value to it (your second code), or use the constructor syntax, which also works with heap-allocated values:</p>\n<pre><code>int *max = new int(0);\n</code></pre>\n<p>The same syntax can be used in your second code, by the way:</p>\n<pre><code>int myVar(20);\n</code></pre>\n<hr>\n<p>In case you're interested: You can also define pointers on the heap. <code>int*</code> is the type of pointers to <code>int</code>s, so just go ahead and allocate such  a type on the heap:</p>\n<pre><code>new int*();\n</code></pre>\n<p>This expression returns an <code>int**</code>, which you can then store somewhere. Again, you typically store this pointer-to-pointer on the stack:</p>\n<pre><code>int **pointerToPointer = new int*();\n</code></pre>\n<p>As with <code>int</code>s, you can initialize an <code>int*</code> in the new-expression to some pointer-to-int (here, the <code>max</code> pointer from above):</p>\n<pre><code>int **pointerToPointer = new int*(max);\n</code></pre>\n<p>Now you have <em>two pointers</em> with the same address: <code>max</code> (pointer on the stack) and some pointer on the heap which you point to using <code>pointerToPointer</code>, i.e. the following holds (I dereference `pointerToPointer, which leads to the value stored behind this pointer, which is a pointer to an int):</p>\n<pre><code>max == *pointerToPointer\n</code></pre>\n</hr>", "LastEditorUserId": "592323", "LastActivityDate": "2013-05-25T13:37:46.043", "Score": "8", "CreationDate": "2013-05-25T13:26:39.467", "ParentId": "16749954", "CommentCount": "0", "OwnerUserId": "592323", "LastEditDate": "2013-05-25T13:37:46.043"}, "16749954": {"ViewCount": "3120", "Body": "<p>I'm learning C++ and I have a question about pointers.</p>\n<p>I have this code:</p>\n<pre><code>int* max = new int;\n*max = 0;\n</code></pre>\n<p>I think, I have created a pointer on the heap (if I'm not right, please, tell me).</p>\n<p>One question:</p>\n<p><strong>Is there a way to create an initialize a pointer with one instruction?</strong> (now, I'm using two instructions).</p>\n<p>Another question:</p>\n<p><strong>How can I create a pointer on the stack?</strong></p>\n<p>I see code like this one:</p>\n<pre><code>int myVar = 20;\nint* pVar = &amp;myVar;\n</code></pre>\n<p>I think I haven't created a pointer on the stack but I think it is the only way to not create a pointer on the heap.</p>\n<p>I'm very very very new on C++ development.</p>\n", "AcceptedAnswerId": "16750072", "Title": "Create a pointer on the Stack", "CreationDate": "2013-05-25T13:19:03.143", "Id": "16749954", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-05-25T15:36:11.433", "Score": "2", "OwnerUserId": "68571", "Tags": "<c++>", "AnswerCount": "5"}, "16750101": {"Id": "16750101", "PostTypeId": "2", "Body": "<p>Your first example</p>\n<pre><code>int* max = new int;\n*max = 0;\n</code></pre>\n<p>is indeed creating a new int on the heap, and your variable <code>max</code> saves a pointer to that int. If you're going to use this you're going to have to use <code>delete max;</code> when you no longer need it to avoid memory leaks.</p>\n<p>The second example</p>\n<pre><code>int myVar = 20;\nint* pVar = &amp;myVar;\n</code></pre>\n<p>is creating a int on the stack, <code>pVar</code> now is a pointer to the address where the int is saved in the memory. However if you're using this you don't have to delete the <code>pVar</code> because its not on the heap (you didn't use the <code>new</code> keyword).</p>\n<p>The main difference between the two variables (created on heap and stack) is that the stack variable is going to get deleted automatically when it leaves the scopes. The scope is defined by curly braces <code>{}</code>:</p>\n<pre><code>int* somefnc()\n{\n    int e1\n\n    {\n        int* e2 = new int(0);\n        int e3 = 0;\n    } // int e3 gets automatically deleted here\n\n    return e2;\n} // e1 gets automatically deleted here\n\n// e2 still exists and has to be manually deleted.\n</code></pre>\n<p>One of the advantage of pointers is when dealing with arrays. If you were to make a char array of x elements on the stack you have to know the number of elements at compile time. If you want to make a char array of x elements at runtime with a dynamic number of elements you'd have to use <code>char* ar = new char[x];</code> and then access it by <code>ar[x-1] = '\\n';</code>.</p>\n<hr>\n<p>In order to initialise a variable when creating it on heap you can use <code>var x = new var(args);</code>.</p>\n</hr>", "LastActivityDate": "2013-05-25T13:36:13.847", "CommentCount": "0", "CreationDate": "2013-05-25T13:36:13.847", "ParentId": "16749954", "Score": "0", "OwnerUserId": "1312672"}});