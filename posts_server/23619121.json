post_cb({"23619357": {"Id": "23619357", "PostTypeId": "2", "Body": "<p>The compiler will look for the implementation of function <code>f</code> in class <code>B</code>.  The compiler found such an implementation, which has two arguments.  You provided only one argument, so there is your error.  </p>\n", "LastActivityDate": "2014-05-12T21:41:32.553", "CommentCount": "2", "CreationDate": "2014-05-12T21:41:32.553", "ParentId": "23619121", "Score": "0", "OwnerUserId": "3133316"}, "bq_ids": {"n4140": {"so_23619121_23619395_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6993}}, "n3337": {"so_23619121_23619395_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6739}}, "n4659": {"so_23619121_23619395_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 8491}}}, "23619395": {"Id": "23619395", "PostTypeId": "2", "Body": "<p>The reason you get a compiler error is that <code>f</code> from class <code>A</code> is hidden by the <code>f</code> in class <code>B</code>.</p>\n<p>When the compiler does member name lookup, it uses base classes only if the name is not found in the object's class, so it doesn't matter if you have a member in a base class that has a proper parameter list for your call.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_23619121_23619395_0\">10.2.5 Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f, C) is\n  initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi\n  ,\n  and merge each such lookup set S(f, Bi) in turn into S(f, C).</p>\n</blockquote>\n", "LastActivityDate": "2014-05-12T21:43:52.103", "CommentCount": "0", "CreationDate": "2014-05-12T21:43:52.103", "ParentId": "23619121", "Score": "1", "OwnerUserId": "1707560"}, "23619121": {"ViewCount": "103", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/1628768/why-does-an-overridden-function-in-the-derived-class-hide-other-overloads-of-the\">this</a> thread the author of the accepted answer explains why the overridden method in the derived class can not be resolved by the compiler. However the example is relative to a type cast resolution, that is both the base and derived overloaded method have one parameter only and the ambiguity is limited to that parameter type.</p>\n<p>But where is the ambiguity when the overloaded methods have a different number of parameters, like in this example?</p>\n<p><strong>Note that I'm not asking why the example produces a compile error, I'm asking why the language was designed this way.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n   inline int f(int x) { return x; }\n};\n\nclass B: public A\n{\npublic:\n   inline int f(int x, int y) { return x+y; }\n};\n\n\nint main()\n{\n  B b;\n\n  cout &lt;&lt; b.f(1) &lt;&lt; endl; // COMPILE ERROR\n  cout &lt;&lt; b.f(1,2) &lt;&lt; endl;\n}\n</code></pre>\n", "Title": "Derived class overriding base class functions again", "CreationDate": "2014-05-12T21:25:00.103", "LastActivityDate": "2014-05-12T23:40:37.570", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:53.543", "LastEditorUserId": "-1", "Id": "23619121", "Score": "5", "OwnerUserId": "382271", "Tags": "<c++>", "AnswerCount": "4"}, "23620654": {"Id": "23620654", "PostTypeId": "2", "Body": "<p>How would you take away overloads that make no sense in a derived class?  Even in your example, assume that if you have a B instance, you wanted to forbid the use of the single-parameter function.  As it is written now, you've removed the single-parameter version (well, at least removed it from name resolution in the context of a B instance).  But if you wanted to still have that version available, you can specify <code>using A::F;</code> in your class to bring in the single-parameter version.</p>\n", "LastActivityDate": "2014-05-12T23:40:37.570", "CommentCount": "0", "CreationDate": "2014-05-12T23:40:37.570", "ParentId": "23619121", "Score": "0", "OwnerUserId": "1987633"}, "23619428": {"Id": "23619428", "PostTypeId": "2", "Body": "<p>In C++, name lookup will stop looking for other names as soon as it find the requested name in one of the base classes. \nIn your case, the name <code>f</code> is defined in <code>B</code>, so the compiler stop looking in the other base classes.\nYou can make A::f visible with a <em>using</em> declaration :</p>\n<pre><code>class B: public A\n{\n public:\n  using A::f;\n  int f(int x, int y) { return x+y; }\n};\n</code></pre>\n", "LastActivityDate": "2014-05-12T21:46:47.843", "CommentCount": "5", "CreationDate": "2014-05-12T21:46:47.843", "ParentId": "23619121", "Score": "1", "OwnerUserId": "3531284"}});