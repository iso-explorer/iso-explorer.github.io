post_cb({"13139346": {"ParentId": "13139235", "CommentCount": "1", "Body": "<p>I believe this is a duplicate question (can't find), but if not, observe that this compiles:</p>\n<pre><code>class C\n{\n   int i;\n};\nvoid C() {}\n\nclass C x;\n</code></pre>\n<p>while this won't:</p>\n<pre><code>typedef class\n{\n   int i;\n} C;\nvoid C() {}\n\nC x;\n</code></pre>\n<p>The name spaces are different.</p>\n", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "13139346", "Score": "2", "CreationDate": "2012-10-30T12:49:45.253", "LastActivityDate": "2012-10-30T12:49:45.253"}, "13139431": {"ParentId": "13139235", "CommentCount": "0", "Body": "<p>Here is yet another difference: the latter can be forward-declared, the former can't.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "13139431", "Score": "0", "CreationDate": "2012-10-30T12:54:26.473", "LastActivityDate": "2012-10-30T12:54:26.473"}, "13139291": {"ParentId": "13139235", "LastEditDate": "2012-10-30T12:52:27.200", "CommentCount": "1", "CreationDate": "2012-10-30T12:46:51.880", "OwnerUserId": "50079", "LastEditorUserId": "50079", "PostTypeId": "2", "Id": "13139291", "Score": "2", "Body": "<p>From a practical standpoint yes, because the standard says (9.1/5) that</p>\n<blockquote>\n<p id=\"so_13139235_13139291_0\">A typedef-name (7.1.3) that names a class type, or a cv-qualified version thereof, is also &gt; a class-name. If a typedef-name that names a cv-qualified class type is used where a\n  class-name is required, the cv-qualifiers are ignored.</p>\n</blockquote>\n<p>7.1/3 says:</p>\n<blockquote>\n<p id=\"so_13139235_13139291_1\">A name declared with the typedef specifier becomes a typedef-name.\n  Within the scope of its declaration, a typedef-name is syntactically\n  equivalent to a keyword and names the type associated with the\n  identifier in the way described in Clause 8. A typedef-name is thus a\n  synonym for another type.</p>\n</blockquote>\n<p>From a theoretical standpoint no, because you could (and indeed I see people already have) draft programs that are valid or invalid depending on which version was used, since 7.1/3 continues from where I cut it off to say:</p>\n<blockquote>\n<p id=\"so_13139235_13139291_2\">A typedef-name does\n  not introduce a new type the way a class declaration (9.1) or enum declaration does.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-30T12:52:27.200"}, "13139344": {"ParentId": "13139235", "CommentCount": "0", "Body": "<p>They're not equivalent. In particular,</p>\n<pre><code>int main()\n{\n    class C c;\n}\n</code></pre>\n<p>will only compile for one of the two definitions.</p>\n", "OwnerUserId": "89847", "PostTypeId": "2", "Id": "13139344", "Score": "0", "CreationDate": "2012-10-30T12:49:41.513", "LastActivityDate": "2012-10-30T12:49:41.513"}, "13139419": {"ParentId": "13139235", "LastEditDate": "2012-10-30T13:05:52.980", "CommentCount": "6", "CreationDate": "2012-10-30T12:53:41.873", "OwnerUserId": "241536", "LastEditorUserId": "241536", "PostTypeId": "2", "Id": "13139419", "Score": "4", "Body": "<p>In this isolated example they are functionally the same, at least from the outside.</p>\n<p>However there are differences.  One instance in particular, you cannot declare a constructor for a <code>struct</code> or a <code>class</code> declared in this way, simply because the <code>class</code> is unnamed.  Similarly you cannot declare any function that involves the class' name.  Here are some examples:</p>\n<pre><code>typedef class\n{\npublic:\n  Gizmo() : n_(42) {}; // NOT OK\n  ~Gizmo();\n  Gizmo&amp; operator&lt;&lt;(int n);    \nprivate:\n  int n_;\n} Gizmo;\n</code></pre>\n<p>You also cannot forward declare an anonymous class:</p>\n<pre><code>class Gizmo;\n</code></pre>\n<p>In C++ I have never seen a case where <code>typedef</code>ing an anonymous <code>struct</code> or a <code>class</code> is preferable to simply declaring a <code>class</code> or a <code>struct</code> that is named.  In some cases the traditional method is definitely preferred.  The moral of the story is:  don't use <code>typedef class {} Name;</code> in C++.  It buys you nothing, and costs you something.</p>\n", "LastActivityDate": "2012-10-30T13:05:52.980"}, "13139235": {"CommentCount": "1", "ViewCount": "325", "PostTypeId": "1", "ClosedDate": "2012-10-30T14:21:03.100", "LastEditorUserId": "-1", "CreationDate": "2012-10-30T12:43:39.310", "LastActivityDate": "2012-10-30T13:05:52.980", "LastEditDate": "2017-05-23T10:25:10.900", "AcceptedAnswerId": "13139419", "Title": "Equivalancy of using typedef and an anonymous class definition to conventional class definition", "Id": "13139235", "Score": "2", "Body": "<blockquote>\n<p id=\"so_13139235_13139235_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c\">Difference between \u2018struct\u2019 and \u2018typedef struct\u2019 in C++?</a> </br></p>\n</blockquote>\n<p>An answer to <a href=\"https://stackoverflow.com/questions/13138605/why-class-int-i-is-not-fully-standard-conformant\">this question</a> led me to wonder about the following:</p>\n<p>I presume that defining a class as follows:</p>\n<pre><code>typedef class {int i;} C;\n</code></pre>\n<p>would be completely equivalent to defining it in the conventional manner:</p>\n<pre><code>class C\n{\n   int i;\n};\n</code></pre>\n<p>Is this presumption correct?</p>\n", "Tags": "<c++><typedef><anonymous-class>", "OwnerUserId": "141997", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_13139235_13139291_0": {"section_id": 5860, "quality": 0.95, "length": 19}, "so_13139235_13139291_1": {"section_id": 5407, "quality": 1.0, "length": 26}, "so_13139235_13139291_2": {"section_id": 5407, "quality": 1.0, "length": 11}}, "n3337": {"so_13139235_13139291_2": {"section_id": 5202, "quality": 1.0, "length": 11}, "so_13139235_13139291_1": {"section_id": 5202, "quality": 1.0, "length": 26}, "so_13139235_13139291_0": {"section_id": 5630, "quality": 0.95, "length": 19}}, "n4659": {"so_13139235_13139291_0": {"section_id": 7339, "quality": 0.95, "length": 19}, "so_13139235_13139291_2": {"section_id": 6829, "quality": 1.0, "length": 11}, "so_13139235_13139291_1": {"section_id": 6829, "quality": 1.0, "length": 26}}}});