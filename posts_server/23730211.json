post_cb({"bq_ids": {"n4140": {"so_23730211_23745649_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5462}}, "n3337": {"so_23730211_23745649_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5249}}, "n4659": {"so_23730211_23745649_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 6896}}}, "23745649": {"Id": "23745649", "PostTypeId": "2", "Body": "<p>Your code compiles with VC++ 2010 and later by virtue of MS language extensions\nthat you can disable with the compiler flag <code>/Za</code>.</p>\n<p>At first sight,</p>\n<pre><code>enum E;\nenum E; \n</code></pre>\n<p>looks just like two forward declarations of <code>enum E</code>. In that light, the duplication does not appear\nrelevant. <em>N</em> forward declarations of something are no more or less legal than one, so the effect of\nenabling the MS extensions (<code>/Ze</code>) would appear to include enabling forward <code>enum</code> declarations,\nwhich are illegal per C++03 <em>or</em> C++11.</p>\n<p>But that appearance is misleading, as the following program shows:</p>\n<pre><code>#include &lt;iostream&gt;\nenum E;\n//enum E;\nenum E e;\nint main()\n{\n    std::cout &lt;&lt; (e == 0) &lt;&lt; std::endl;\n    return e;\n}\n</code></pre>\n<p>This also compiles clean with VC++ 2010 or later, proving that\nthe compiler parses <code>enum E;</code> not as <em>forward declaration</em> of <code>E</code> but as a <em>definition</em>.</p>\n<p>The language extension here is that <code>enum E;</code>, on first sight, is equated with <code>enum E {}</code>.</p>\n<p>If we uncomment <code>//enum E;</code> in the program, it still compiles clean, showing that on second sight\nand subsequently, <code>enum E;</code> is not <em>again</em> parsed as a definition, just as a redeclaration of <code>E</code>.</p>\n<p>VC++ 2013 supports the C++11 concepts of <em>scoped</em> and <em>based enums</em>. With extensions disabled,\nit will compile and reject declarations as indicated by this piece of code:</p>\n<pre><code>enum UnscopedBasedEnum : int; // :)\nenum UnscopedBasedEnum : int; // :)\nUnscopedBasedEnum ube; // :)\n\nenum struct ScopedBaselessEnum; // :)\nenum struct ScopedBaselessEnum; // :)\nScopedBaselessEnum sbe;\n\n//enum UnscopedBaseLessEnum; // :(\n</code></pre>\n<p>all of which is C++11 compliant.</p>\n<p>The declarations of <code>ube</code> and <code>sbe</code> prove, however, that <em>none of the\ndeclarations here is a forward declaration</em>, if <em>foward declaration</em> has the customary meaning\nof <em>declaration of an incomplete type</em>. If <code>UnscopedBasedEnum</code>|<code>ScopedBaselessEnum</code>\nwas an incomplete type in these declarations then the declaration of <code>ube</code>|<code>sbe</code> would\nwould declare an <em>object</em> of incomplete type, and would not compile. Per C++11, the declarations\nof <code>UnscopedBasedEnum</code> and <code>ScopedBaselessEnum</code> are <em>opaque enum declarations</em>, meaning\nthat no enumerator-list is present or implied. But they nevertheless declare complete\ntypes: <strong>p 7.2.3</strong> </p>\n<blockquote>\n<p id=\"so_23730211_23745649_0\">An opaque-enum-declaration is either a redeclaration of an enumeration in the current scope or a declaration\n  of a new enumeration. [ Note: An enumeration declared by an opaque-enum-declaration has fixed underlying\n  type and is a complete type. The list of enumerators can be provided in a later redeclaration with an enum-specifier.\n  \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2014-05-19T19:24:05.607", "CommentCount": "0", "CreationDate": "2014-05-19T19:24:05.607", "ParentId": "23730211", "Score": "0", "OwnerUserId": "1362568"}, "23734909": {"Id": "23734909", "PostTypeId": "2", "Body": "<p>What you are doing here is enum forward declaration. Some compilers (like VS) provide language extensions which enable this behaviour for pre-C++11 standard. You can verify this by disabling the language extensions in your project settings which will result in a compiler error. G++ does not have such extensions but it should compile your code with -std=c++11 after adding size specifiers or when using <code>enum class</code> instead.</p>\n<p><strong>Valid in Visual Studio with compiler extensions enabled</strong></p>\n<pre><code>enum E;\nenum E;\n</code></pre>\n<p><strong>Valid in all compilers supporting C++11</strong></p>\n<pre><code>enum class E;\nenum class E;\n\n// or\n\nenum E : short;\nenum E : short;\n</code></pre>\n", "LastEditorUserId": "1680318", "LastActivityDate": "2014-05-19T10:28:43.717", "Score": "0", "CreationDate": "2014-05-19T10:03:50.743", "ParentId": "23730211", "CommentCount": "0", "OwnerUserId": "1680318", "LastEditDate": "2014-05-19T10:28:43.717"}, "23730211": {"ViewCount": "113", "Body": "<p>In the following code there are no errors or warnings at compile/link-time</p>\n<pre><code>enum E;\nenum E;\nint _tmain(int argc, _TCHAR* argv[]){ }\n</code></pre>\n<p>Is it VS2010 bug?</p>\n", "AcceptedAnswerId": "23745649", "Title": "Visual studio 2010 unscoped opaque-enum-declarartion with omitted base", "CreationDate": "2014-05-19T05:24:55.007", "LastActivityDate": "2014-05-19T19:24:05.607", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-05-19T06:57:01.387", "OwnerDisplayName": "user2889159", "LastEditorUserId": "241631", "Id": "23730211", "Score": "1", "Tags": "<c++><visual-c++><enums>", "AnswerCount": "2"}});