post_cb({"6495969": {"Id": "6495969", "PostTypeId": "2", "Body": "<p>If they aren't UB, they should be. In example 1 you are using <code>delete[]</code> where the underlying mechanism has no clue of how many objects are to be destructed. If the implementation of <code>new[]</code> and <code>delete[]</code> uses cookies, this will fail. The code in example 2 assumes that the address <code>q</code> is the correct address to pass to <code>operator delete[]</code>, and this is not the case in an implementation that uses cookies.</p>\n", "LastActivityDate": "2011-06-27T16:31:33.623", "CommentCount": "1", "CreationDate": "2011-06-27T16:31:33.623", "ParentId": "6495632", "Score": "2", "OwnerUserId": "774499"}, "6496004": {"Id": "6496004", "PostTypeId": "2", "Body": "<p>Correct would be:</p>\n<pre><code>X* p = static_cast&lt;X*&gt;(new char[3 * sizeof(X)]);\n// ...\ndelete[] static_cast&lt;char*&gt;(p);\n</code></pre>\n<p>or</p>\n<pre><code>X* p = static_cast&lt;X*&gt;(operator new[](3 * sizeof(X)));\n// ...\noperator delete[](p);\n</code></pre>\n<p>The type of the array delete expression has to match the new expression exactly.</p>\n<hr>\n<p>The first example is UB because section 5.3.5 (<code>[expr.delete]</code>) says</p>\n<blockquote>\n<p id=\"so_6495632_6496004_0\">In the first alternative (<em>delete object</em>), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined.  In the second alternative (<em>delete array</em>) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>My corrected version is ok because (section 3.9 <code>[basic.life]</code>):</p>\n<blockquote>\n<p id=\"so_6495632_6496004_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor.  For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has unde\ufb01ned\n  behavior.</p>\n</blockquote>\n<hr>\n<p>The second example is not allowed iff <code>X</code> has a non-trivial destructor because (also 3.9 <code>[basic.life]</code>):</p>\n<blockquote>\n<p id=\"so_6495632_6496004_2\">Before the lifetime of an object has started but after the storage which the object will occupy has been\n  allocated 38 or, after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released, any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise,\n  such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>,\n  is well-de\ufb01ned.  Such a pointer may be dereferenced but the resulting lvalue may only be used in limited\n  ways, as described below.</p>\n<p id=\"so_6495632_6496004_3\">The program has undefined behavior if:</p>\n<ul>\n<li>the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a delete-expression,</li>\n</ul>\n</blockquote>\n</hr></hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-06-27T16:44:41.363", "Score": "2", "CreationDate": "2011-06-27T16:34:36.457", "ParentId": "6495632", "CommentCount": "3", "OwnerUserId": "103167", "LastEditDate": "2011-06-27T16:44:41.363"}, "6495917": {"Id": "6495917", "PostTypeId": "2", "Body": "<p>I'm pretty sure both give UB. </p>\n<p>\u00a75.3.4/12 says the array form of a new expression may add some arbitrary amount of overhead to the amount of memory allocated. The array delete can/could then do something with the extra memory it expects to be there, but isn't since you didn't allocate the extra space it expects. At the very least it's normally going to at least compensate for the amount of extra memory it expected to be allocated to get back to the address it believes was returned from <code>operator new</code> -- but since you haven't allocated extra memory or applied an offset, when it does to it'll pass a pointer to <code>operator delete[]</code> that wasn't returned from <code>operator new[]</code>, leading to UB (and, in fact, even attempting to form the address before the beginning of the returned address is technically UB).</p>\n<p>The same section says that if it allocates extra memory, it has to offset the returned pointer by the amount of that overhead. When/if you call <code>operator delete[]</code> with the pointer that was returned from the new expression without compensating for the offset, you're calling <code>operator delete[]</code> with a pointer that's different from the one <code>operator new[]</code> returned, giving UB again.</p>\n<p>\u00a75.3.4/12 is a non-normative note, but I don't see anything in the normative text to contradict it.</p>\n", "LastActivityDate": "2011-06-27T16:26:16.533", "CommentCount": "0", "CreationDate": "2011-06-27T16:26:16.533", "ParentId": "6495632", "Score": "7", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_6495632_6496004_2": {"length": 61, "quality": 0.8970588235294118, "section_id": 7193}, "so_6495632_6495913_2": {"length": 19, "quality": 1.0, "section_id": 6106}, "so_6495632_6495913_6": {"length": 18, "quality": 0.8571428571428571, "section_id": 6846}, "so_6495632_6495913_8": {"length": 26, "quality": 0.9285714285714286, "section_id": 6092}, "so_6495632_6496004_0": {"length": 41, "quality": 1.0, "section_id": 6107}, "so_6495632_6496004_1": {"length": 48, "quality": 0.9411764705882353, "section_id": 7192}, "so_6495632_6495913_4": {"length": 5, "quality": 1.0, "section_id": 6820}}, "n3337": {"so_6495632_6495913_6": {"length": 18, "quality": 0.8571428571428571, "section_id": 6596}, "so_6495632_6496004_1": {"length": 48, "quality": 0.9411764705882353, "section_id": 6936}, "so_6495632_6495913_2": {"length": 19, "quality": 1.0, "section_id": 5872}, "so_6495632_6496004_2": {"length": 64, "quality": 0.9411764705882353, "section_id": 6937}, "so_6495632_6495913_8": {"length": 26, "quality": 0.9285714285714286, "section_id": 5859}, "so_6495632_6496004_0": {"length": 41, "quality": 1.0, "section_id": 5873}, "so_6495632_6495913_4": {"length": 5, "quality": 1.0, "section_id": 6575}}, "n4659": {"so_6495632_6496004_0": {"length": 41, "quality": 1.0, "section_id": 7604}, "so_6495632_6495913_2": {"length": 19, "quality": 1.0, "section_id": 7603}, "so_6495632_6495913_6": {"length": 15, "quality": 0.7142857142857143, "section_id": 8315}, "so_6495632_6495913_8": {"length": 27, "quality": 0.9642857142857143, "section_id": 7588}, "so_6495632_6496004_2": {"length": 60, "quality": 0.8823529411764706, "section_id": 8702}, "so_6495632_6496004_1": {"length": 48, "quality": 0.9411764705882353, "section_id": 8701}, "so_6495632_6495913_4": {"length": 5, "quality": 1.0, "section_id": 8312}}}, "6495956": {"Id": "6495956", "PostTypeId": "2", "Body": "<p>I think that cannot be legal. Because that implies these equations:</p>\n<pre><code>new-expression    = allocation-function  +  constructor\ndelete-expression = destructor  +  deallocation-function\n</code></pre>\n<p>Nothing more, nothing less. But the Standard does <strong>not</strong> say exactly that, as far as  I know. It might be possible that <code>new-expression</code> does more than <code>allocation-function + constructor</code> together do. That is, the actual equations could be this, and the Standard doesn't forbid it explicitly anywhere:</p>\n<pre><code>new-expression    = allocation-function  +  constructor   +  some-other-work\ndelete-expression = destructor  +  deallocation-function  +  some-other-work\n</code></pre>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-06-27T16:37:06.110", "Score": "2", "CreationDate": "2011-06-27T16:29:13.547", "ParentId": "6495632", "CommentCount": "0", "OwnerUserId": "415784", "LastEditDate": "2011-06-27T16:37:06.110"}, "6495913": {"Id": "6495913", "PostTypeId": "2", "Body": "<p>From 5.3.5 [expr.delete] in n3242:</p>\n<blockquote>\n<p id=\"so_6495632_6495913_0\"><em>2</em></p>\n<p id=\"so_6495632_6495913_1\">[...]</p>\n<p id=\"so_6495632_6495913_2\">In the second alternative (<em>delete\n  array</em>), the value of the operand of\n  delete may be a null pointer value or\n  a pointer value that resulted from a\n  previous array new-expression. If\n  not, the behavior is undefined. [...]</p>\n</blockquote>\n<p>which means that for <code>delete[] p</code>, <code>p</code> must have been the result of something of the form <code>new[] p</code> (a new expression), or 0. Seeing as the result of <code>operator new</code> is not listed here, I think the first case is right out.</p>\n<hr>\n<p>I believe the second case is Ok.\nFrom 18.6.1.2 [new.delete.array]:</p>\n<blockquote>\n<p id=\"so_6495632_6495913_3\"><em>11</em></p>\n<p id=\"so_6495632_6495913_4\"><code>void operator delete[](void* ptr) noexcept;</code></p>\n<p id=\"so_6495632_6495913_5\">[...]</p>\n<p id=\"so_6495632_6495913_6\"><em>Requires:</em> ptr shall be a null pointer\n  or its value shall be the value\n  returned by an earlier call to\n  operator new or\n  operator new[](std::size_t,const\n  std::nothrow_t&amp;) which has not been\n  invalidated by an intervening call to\n  operator delete. [...]</p>\n</blockquote>\n<p>(there is similar text in 3.7.4.2 [basic.stc.dynamic.deallocation], paragraph 3)</p>\n<p>So as long as the de/allocation functions match (e.g. <code>delete[] (new[3] T)</code> is well-formed) nothing bad happens. <strong>[ or does it? see below ]</strong></p>\n<hr>\n<p>I think I tracked the normative text of what Jerry is warning about, in 5.3.4 [expr.new]:</p>\n<blockquote>\n<p id=\"so_6495632_6495913_7\"><em>10</em></p>\n<p id=\"so_6495632_6495913_8\">A new-expression passes the amount of\n  space requested to the allocation\n  function as the first argument of type\n  std::size_t. That argument shall be no\n  less than the size of the object being\n  created; it may be greater than the\n  size of the object being created only\n  if the object is an array. [...]</p>\n</blockquote>\n<p>Following in the same paragraph is an example (so non-normative) which underlines that the new expressions of an implementation are indeed free to ask more from the allocation function than the space the array takes (storing the optional <code>std::size_t</code> parameter available to deallocation function comes to mind), and that they can offset into the result. So all bets are off in the array case. The non-array case seems fine though:</p>\n<pre><code>auto* p = new T;\n// Still icky\np-&gt;~T();\noperator delete(p);\n</code></pre>\n</hr></hr>", "LastEditorUserId": "726300", "LastActivityDate": "2011-06-27T17:27:11.280", "Score": "5", "CreationDate": "2011-06-27T16:26:03.243", "ParentId": "6495632", "CommentCount": "9", "OwnerUserId": "726300", "LastEditDate": "2011-06-27T17:27:11.280"}, "6495632": {"ViewCount": "382", "Body": "<p>Just out of curiosity, is the following legal?</p>\n<pre><code>X* p = static_cast&lt;X*&gt;(operator new[](3 * sizeof(X)));\nnew(p + 0) X();\nnew(p + 1) X();\nnew(p + 2) X();\n\ndelete[] p;   // Am I allowed to use delete[] here? Or is it undefined behavior?\n</code></pre>\n<p>Similarly:</p>\n<pre><code>X* q = new X[3]();\n\n(q + 2)-&gt;~X();\n(q + 1)-&gt;~X();\n(q + 0)-&gt;~X();\noperator delete[](q);\n</code></pre>\n", "AcceptedAnswerId": "6495917", "Title": "Mixing operator new[] and placement new with ordinary delete[]", "CreationDate": "2011-06-27T16:02:34.387", "Id": "6495632", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-06-27T17:27:11.280", "Score": "17", "OwnerUserId": "252000", "Tags": "<c++><arrays><initialization><dynamic-memory-allocation><placement-new>", "AnswerCount": "5"}});