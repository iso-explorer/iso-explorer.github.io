post_cb({"19609187": {"ParentId": "19609186", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>After reading the standard a bit more and thinking about this, I believe I have the best answer, but I am not certain.</p>\n<p>First, the definition of <code>digits</code>, taken from the latest C++14 draft standard, N3797, \u00a7 18.3.2.4:</p>\n<blockquote>\n<p id=\"so_19609186_19609187_0\"><code>static constexpr int digits;</code></p>\n<p id=\"so_19609186_19609187_1\">8 Number of <code>radix</code> digits that can be represented without change.</p>\n<p id=\"so_19609186_19609187_2\">9 For integer types, the number of non-sign bits in the representation.</p>\n<p id=\"so_19609186_19609187_3\">10 For floating point types, the number of <code>radix</code> digits in the mantissa</p>\n</blockquote>\n<p>The case of <code>bounded::integer&lt;-100, 5&gt;</code> is the same as for <code>bounded::integer&lt;0, 5&gt;</code>, which would give a value of <code>2</code>.</p>\n<p>For the case of <code>bounded::integer&lt;16, 19&gt;</code>, <code>digits</code> should be defined as <code>0</code>. Such a class cannot even represent a 1-bit number (since <code>0</code> and <code>1</code> aren't in the range), and according to 18.3.2.7.1:</p>\n<blockquote>\n<p id=\"so_19609186_19609187_4\">All members shall be provided for all specializations. However, many values are only required to be meaningful under certain conditions (for example, <code>epsilon()</code> is only meaningful if <code>is_integer</code> is <code>false</code>). Any value that is not \"meaningful\" shall be set to 0 or false.</p>\n</blockquote>\n<p>I believe that any integer-like class which does not have <code>0</code> as a possible value cannot meaningfully compute <code>digits</code> and <code>digits10</code>.</p>\n<p>Another possible answer is to use an information theoretic definition of digits. However, this is not consistent with the values for the built-in integers. The description explicitly leaves out sign bits, but those would still be considered a single bit of information, so I feel that rules out this interpretation. It seems that this exclusion of the sign bit also means that I have to take the smaller in magnitude of the negative end and the positive end of the range for the first number, which is why I believe that the first question is equivalent to <code>bounded::integer&lt;0, 5&gt;</code>. This is because you are only guaranteed 2 bits can be stored without loss of data. You can potentially store up to 6 bits as long as your number is negative, but in general, you only get 2.</p>\n<p><code>bounded::integer&lt;16, 19&gt;</code> is much trickier, but I believe the interpretation of \"not meaningful\" makes more sense than shifting the value over and giving the same answer as if it were <code>bounded::integer&lt;0, 3&gt;</code>, which would be <code>2</code>.</p>\n<p>I believe this interpretation follows from the standard, is consistent with other integer types, and is the least likely to confuse the users of such a class.</p>\n<p>To answer the question of the use cases of <code>digits</code>, a commenter mentioned radix sort. A base-2 radix sort might expect to use the value in <code>digits</code> to sort a number. This would be fine if you set <code>digits</code> to <code>0</code>, as that indicates an error condition for attempting to use such a radix sort, but can we do better while still being in line with built-in types?</p>\n<p>For unsigned integers, radix sort that depends on the value of <code>digits</code> works just fine. <code>uint8_t</code> has <code>digits == 8</code>. However, for signed integers, this wouldn't work: <code>std::numeric_limits&lt;int8_t&gt;::digits == 7</code>. You would also need to sort on that sign bit, but <code>digits</code> doesn't give you enough information to do so.</p>\n", "OwnerUserId": "852254", "LastEditorUserId": "852254", "LastEditDate": "2014-07-30T02:58:00.177", "Id": "19609187", "Score": "5", "CreationDate": "2013-10-26T16:42:59.083", "LastActivityDate": "2014-07-30T02:58:00.177"}, "19610815": {"ParentId": "19609186", "CommentCount": "0", "Body": "<p>You are over-thinking it. There are two simple options for <code>digits</code> specializations for your own <code>ranged_integer</code></p>\n<ul>\n<li><code>log2(Last-First)</code> when you are representing the range <code>[First, Last)</code>. </li>\n<li>the value of <code>N * numeric_limits&lt;U&gt;::digits</code> which corresponds to the smallest underlying storage <code>std::array&lt;U, N&gt;</code> in which you can store your range.</li>\n</ul>\n<p>Note that your class <code>ranged_integer</code> can internally do a transformation to map a range of e.g. <code>[-100, 5]</code> onto <code>[0, 105]</code> so that you don't have to worry about sign-bits etc.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "19610815", "Score": "0", "CreationDate": "2013-10-26T19:16:16.490", "LastActivityDate": "2013-10-26T19:16:16.490"}, "19609186": {"CommentCount": "0", "AcceptedAnswerId": "19609187", "PostTypeId": "1", "LastEditorUserId": "852254", "CreationDate": "2013-10-26T16:42:59.083", "LastActivityDate": "2014-07-30T02:58:00.177", "LastEditDate": "2014-07-30T02:57:07.127", "ViewCount": "710", "FavoriteCount": "1", "Title": "What is std::numeric_limits<T>::digits supposed to represent?", "Id": "19609186", "Score": "5", "Body": "<p>I am writing an integer-like class that represents a value that lies somewhere in a range. For instance, the value of <code>bounded::integer&lt;0, 10&gt;</code> is somewhere in the range [0, 10]. For this class, I have defined <code>radix</code> to be <code>2</code>.</p>\n<p>What should the value of <code>digits</code> be for <code>bounded::integer&lt;-100, 5&gt;</code>?</p>\n<p>What about <code>bounded::integer&lt;16, 19&gt;</code>?</p>\n", "Tags": "<c++><c++11><std><c++14>", "OwnerUserId": "852254", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19609186_19609187_2": {"section_id": 6727, "quality": 0.8571428571428571, "length": 6}, "so_19609186_19609187_4": {"section_id": 6789, "quality": 0.9565217391304348, "length": 22}, "so_19609186_19609187_1": {"section_id": 6726, "quality": 1.0, "length": 6}, "so_19609186_19609187_3": {"section_id": 6728, "quality": 0.875, "length": 7}, "so_19609186_19609187_0": {"section_id": 6725, "quality": 1.0, "length": 4}}, "n3337": {"so_19609186_19609187_2": {"section_id": 6482, "quality": 0.8571428571428571, "length": 6}, "so_19609186_19609187_4": {"section_id": 6544, "quality": 0.9565217391304348, "length": 22}, "so_19609186_19609187_1": {"section_id": 6481, "quality": 1.0, "length": 6}, "so_19609186_19609187_3": {"section_id": 6483, "quality": 0.875, "length": 7}, "so_19609186_19609187_0": {"section_id": 6480, "quality": 1.0, "length": 4}}, "n4659": {"so_19609186_19609187_2": {"section_id": 8221, "quality": 0.8571428571428571, "length": 6}, "so_19609186_19609187_0": {"section_id": 8219, "quality": 1.0, "length": 4}, "so_19609186_19609187_4": {"section_id": 8281, "quality": 0.9565217391304348, "length": 22}, "so_19609186_19609187_3": {"section_id": 8222, "quality": 0.625, "length": 5}, "so_19609186_19609187_1": {"section_id": 8220, "quality": 1.0, "length": 6}}}});