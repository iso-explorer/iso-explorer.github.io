post_cb({"37706858": {"CommentCount": "0", "ViewCount": "108", "PostTypeId": "1", "LastEditorUserId": "4801801", "CreationDate": "2016-06-08T15:30:01.307", "LastActivityDate": "2016-06-10T07:38:35.187", "Title": "Partial construction & destruction of an object of a child class in hierarchy", "AcceptedAnswerId": "37709753", "LastEditDate": "2016-06-09T11:53:09.657", "Id": "37706858", "Score": "0", "Body": "<p><strong>EDIT1: Question edited in order to fix the UB pointed out in Yakk's answer (which is a valid answer regarding the original question).</strong></p>\n<p>Consider the following code:</p>\n<pre><code>class C\n{\nprotected:\n    C(bool) : c(0)  { s = new char[10]; /* init C members... */ }\n    void cleanup()  { delete[s]; /* cleanup C members... */ }   //EDIT1\n    C()             { /* do nothing, keep C members unchanged */ }\n    // EDIT1: removed dtor: ~C()    { /* do nothing, keep C members unchanged */ }\n    // EDIT1: implicitly defined default (trivial) dtor\n    int   c;\n    char* s;\n};\n\nclass Child1 : public C\n{\npublic:\n    Child1(bool) : C(true)  { }\n    void cleanup()          { C::cleanup(); }   //EDIT1\n    Child1()                { c ++; }\n    // EDIT1: removed dtor: ~Child1()   { }\n    // EDIT1: implicitly defined default (trivial) dtor\n};\n\nclass Child2 : public C\n{\npublic:\n    Child2()                { c --; }\n    void cleanup()          { C::cleanup(); }   //EDIT1\n    // EDIT1: removed dtor: ~Child2()   { }\n    // EDIT1: implicitly defined default (trivial) dtor\n};\n\nint main()\n{\n    char storage[sizeof(Child1)];           // (0) storage for any C child instance\n    C* child = new(&amp;storage) Child1(true);  // (1) create in-place Child1 instance and initialize C members\n    //EDIT1: removed: static_cast&lt;Child1*&gt;(child)-&gt;~Child1(); // (2) destroy Child1 instance, keeping C members unchanged\n    child = new(&amp;storage) Child2;           // (3) create in-place Child2 instance, keeping C members unchanged, overwritting Child1 members\n    //EDIT1: removed: static_cast&lt;Child2*&gt;(child)-&gt;~Child2(); // (4) destroy Child2 instance, keeping C members unchanged\n    child = new(&amp;storage) Child1(true); // (5) create in-place Child1 instance, keeping C members unchanged, overwritting Child2 members\n    //EDIT1: removed: static_cast&lt;Child1*&gt;(child)-&gt;~Child1(); // (6) destroy Child1 instance, keeping C members unchanged\n    child-&gt;cleanup();                       // (7) cleanup Child1 &amp; C members [EDIT1]\n    return 0;\n}\n</code></pre>\n<ul>\n<li>At line (1), a <code>Child1</code> instance is 'in-place' created using the non-default ctor <code>Child1(bool)</code>. This leads to initialization of parent class <code>C</code> members through the non-default ctor <code>C(bool)</code>.</li>\n<li><del>At line (2), the <code>Child1</code> instance is destroyed. This will call the dtor of parent class <code>C</code>, which is voluntarily implemented empty in order to keep <code>C</code> members unchanged.</del> [EDIT1]</li>\n<li>At line (3), a <code>Child2</code> instance is 'in-place' created using the default ctor of <code>Child2</code>. This <strong>overwrites the Child1 instance</strong>[EDIT1] and call the default-ctor of parent class <code>C</code>, which is voluntarily implemented empty in order to keep <code>C</code> members unchanged.</li>\n</ul>\n<p>At this step, the <code>Child2</code> instance had been able to access the parent class <code>C</code> protected members, kept unaltered <del>although the <code>Child1</code> instance has been destroyed</del> in the overwrite operation performed at line (3). [EDIT1]</p>\n<p>The pattern described above allows me to achieve my main objectives: create <del>and destroy</del>[EDIT1] instances of any child of class <code>C</code>, keeping the <code>C</code> members unchanged. Moreover, using a non-default ctor, I have a way to initialize the <code>C</code> members (such as at line (1)).</p>\n<p>However, this pattern has several drawbacks:</p>\n<ul>\n<li><del>class <code>C</code> members cannot be const or reference, and must have trivial default ctor and dtor. (The same rule applies for any sub-member.)</del></li>\n<li><del>a cleanup destructor cannot be easily implemented (it could be in the same way as the initialization non-default ctor <code>C(bool)</code>, if C++ supported non-default dtor, but sadly C++ does not.</del></li>\n<li>class <code>C</code> members cannot be const or reference. [EDIT1]</li>\n<li>class <code>C</code>, parent of class <code>C</code>, and class <code>C</code> members must have an explicitly defined default ctor implemented empty (i.e. trivial-like) [EDIT1]</li>\n<li>class <code>C</code> must have a trivial dtor. [EDIT1]</li>\n</ul>\n<p><strong>My questions</strong>:</p>\n<ul>\n<li>is the pattern described above Defined Behavior ?[EDIT1]</li>\n<li>is there any other way to achieve the same objectives (<del>[in-place]</del>[EDIT1] create <del>and destroy</del>[EDIT1] children classes instances of a parent class <code>C</code>, keeping  the parent class <code>C</code> members unchanged) without the drawbacks <del>(especially the 1st one)</del>[EDIT1] listed above ?</li>\n</ul>\n<p><del>Ideally, if I had a way to prevent the parent class <code>C</code> ctor and dtor from being called during the child construction/destruction process, this would be perfect.</del>[EDIT1]</p>\n<p>Note1: in the real application, the <code>C</code> class may be quite big and the construction<del>/destruction</del>[EDIT1] of <code>C</code> children have to occur intensively; the in-place construction is intended to optimize performance in such operations.</p>\n<p>Note2[EDIT1]: the trivial dtor in class <code>C</code> and children is required to prevent from Undefined Behavior in case of mistaken call of the destructor; as per \u00a73.8/1 of the C++ standard, lifetime of an object with trivial dtor does not end when destructor is called.</p>\n", "Tags": "<c++><inheritance><c++14>", "OwnerUserId": "4801801", "AnswerCount": "2"}, "37742564": {"ParentId": "37706858", "CommentCount": "0", "Body": "<p>After an exhaustive read of the standard, I can answer the 1st part of my own question.</p>\n<p>As mentioned by Yakk, the 1st scheme I proposed (original question) was UB, because calling the destructor of an object ends its lifetime, unless the destructor is trivial. \u00a73.8/1 of the standard states that :</p>\n<blockquote>\n<p id=\"so_37706858_37742564_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<p id=\"so_37706858_37742564_1\">\u2014 if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_37706858_37742564_2\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>In the updated scheme I proposed (EDIT1), the destructor of the object is not called at all, and the object is overwritten by a new one instead. I though this would get rid of the UB, however the same \u00a73.8/1 of the standard clearly states that lifetime of an object ends when its destructor is called <strong>or if the storage it occupies is reused</strong>, that is exactly what is done in overwrite. (In concrete terms, this makes use of the <strong>child</strong> pointer UB.)</p>\n<p>Then, the updated scheme I proposed is as UB as the 1st scheme.</p>\n<p>Regarding the 2nd part of my question, Yakk provided a valid solution.</p>\n", "OwnerUserId": "4801801", "PostTypeId": "2", "Id": "37742564", "Score": "1", "CreationDate": "2016-06-10T07:38:35.187", "LastActivityDate": "2016-06-10T07:38:35.187"}, "bq_ids": {"n4140": {"so_37706858_37742564_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_37706858_37742564_2": {"section_id": 7189, "quality": 1.0, "length": 5}, "so_37706858_37742564_1": {"section_id": 7189, "quality": 0.875, "length": 7}}, "n3337": {"so_37706858_37742564_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_37706858_37742564_2": {"section_id": 6933, "quality": 1.0, "length": 5}, "so_37706858_37742564_1": {"section_id": 6933, "quality": 0.875, "length": 7}}, "n4659": {"so_37706858_37742564_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_37706858_37742564_2": {"section_id": 8701, "quality": 1.0, "length": 5}, "so_37706858_37742564_1": {"section_id": 8697, "quality": 0.875, "length": 7}}}, "37709753": {"ParentId": "37706858", "CommentCount": "1", "Body": "<p>What you are doing is undefined behavior.</p>\n<p>To have a well formed program, you can only destroy an object by its proper type.  After it is destroyed, you can only access its storage as an uninitialized buffer.  When recreated, there are no guarantees asto the state of your variables, and definitely no guarantee that they share the state they had before.</p>\n<p>If you need such behavior, you can implement a manual inheritance scheme, such as what C programmers use when they want a OO-heiarchy.</p>\n<p>This permits state data to be stored independently of the OO-identity of the data, and lets you change the OO-identity of an object on the fly.</p>\n<p>Here is a toy example:</p>\n<pre><code>struct Base_vtable {\n  void(*display)(Base const*);\n};\nstruct Base {\n  static init_vtable(Base_vtable* vtable) {\n    vtable-&gt;display = display_raw;\n  }\n  static Base_vtable make_vtable() {\n    Base_vtable vtable;\n    init_vtable(&amp;vtable);\n    return vtable;\n  }\n  static Base_vtable const* get_vtable() {\n    static const auto vtable = make_vtable();\n    return &amp;vtable;\n  }\n  Base_vtable const* vtable_data = nullptr;\n  Base_vtable const* vtable() const { return vtable_data; }\n  std::array&lt;char, 1000*1000&gt; big_buffer;\n  std::string name;\n  static void display_raw(Base const* self) {\n    std::cout &lt;&lt; self-&gt;name;\n  }\n  void display() {\n    vtable()-&gt;display(this);\n  }\n  static void ctor(Base* self) {\n    self-&gt;vtable_data = get_vtable();\n  }\n  static void dtor(Base* self) {\n  }\n};\nstruct Derived_vtable:Base_vtable {\n  int(*sum)(Derived const*);\n};\n\nstruct Derived:Base {\n  Derived_vtable const* vtable() {\n    return static_cast&lt;Derived_vtable const*&gt;(vtable_data);\n  }\n  static void init_vtable(Derived_vtable* vtable) {\n    vtable-&gt;print = display_raw;\n    vtable-&gt;sum = sum_raw;\n  }\n  static Derived_vtable make_vtable() {\n    Derived_vtable d;\n    init_vtable(&amp;d);\n    return d;\n  }\n  static Derived_vtable const* get_vtable() {\n    static const Derived_vtable vtable = make_vtable();\n    return &amp;vtable;\n  }\n  static int sum_raw(Derived const* self) {\n    int r = 0;\n    for (auto&amp;&amp; c:big_buffer)\n      r+=c;\n    return r;\n  }\n  static void display_raw(Derived const* self) {\n    std::cout &lt;&lt; \"Derived: \";\n    Base::display_raw(self);\n  }\n  int sum() const {\n    return vtable()-&gt;sum(this);\n  }\n  static void ctor(Derived* self) {\n    Base::ctor(self);\n    self-&gt;vtable_data = get_vtable();\n  }\n  static void dtor(Derived* self) {\n    Base::dtor(self);\n  }\n};\n</code></pre>\n<p>This is very similar to what C++ does <em>for you</em> when you want to use the default C++ OO system.  Except now we have fine-grained control, where we can change what our various ctors do.</p>\n<p>I can divorce my state from my virtual type, allowing <code>Derived</code> to have multiple different vtables, and have its behavior change when I want it to.  The transition between such states can do whatever I want it to do.</p>\n<p>The problem with your solution is that the compiler is permitted to use the state of the destroyed object for any purpose it chooses -- it could use it as space to swap registers.  It could presume that the object stored in a destroyed structure are dangling pointers, prove that a pointer is either null or points to that storage, determine that we will dereference it if not null and that the behavior if dereferenced is UB, and then correctly optimize your code to <em>know</em> the pointer <em>must</em> be null and not check it, eliminating the dead code branch.</p>\n<p>Once you delve into undefined behavior, you are forced to maintain your code against every iteration of the compiler in the future that could break your code by doing things perfectly legal under the standard.  This is a really heavy load to carry unless you are writing throw-away code.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "37709753", "Score": "1", "CreationDate": "2016-06-08T18:03:11.847", "LastActivityDate": "2016-06-08T18:03:11.847"}});