post_cb({"24080167": {"CommentCount": "0", "ViewCount": "134", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-06-06T10:57:07.743", "LastActivityDate": "2014-06-06T13:46:26.220", "LastEditDate": "2014-06-06T13:29:45.527", "AcceptedAnswerId": "24083086", "OwnerDisplayName": "user1814023", "Title": "C++11 Threads: Exception when called using lambdas", "Id": "24080167", "Score": "2", "Body": "<p>I was reading about threads in C++11 and I did</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nvoid doSomething() { cout &lt;&lt; \"Inside doSomething \" &lt;&lt; endl; }\nvoid doSomethingElse() { cout &lt;&lt; \"Inside doSomethingElse \" &lt;&lt; endl; }\n\nint main(void)\n{\n    // Using LAMBDA expressions to call the functions.\n    thread my_thread([](){ doSomething(); doSomethingElse(); });\n    //my_thread.join(); ---------------&gt; 1\n\n    return 0;\n}\n</code></pre>\n<p>I tried to execute the code without calling <code>my_thread.join()</code>, Visual Studio 2013 is throwing \"abort() has been called\".\nWhat is the reason?</p>\n", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "1"}, "24083086": {"ParentId": "24080167", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This has nothing to do with lambdas. If a <code>thread</code> is <code>joinable</code> when its destructor executes <code>std::terminate</code> will be called. To avoid this you <strong>must</strong> call <code>thread::join</code> or <code>thread::detach</code>. The standard even goes on to provide the rationale for this decision in a note.</p>\n<p>From <em>\u00a730.3.1.3/1 [thread.thread.destr]</em></p>\n<blockquote>\n<pre><code> ~thread();\n</code></pre>\n<p id=\"so_24080167_24083086_0\">If <code>joinable()</code>, calls <code>std::terminate()</code>. Otherwise, has no effects. [ <em>Note:</em> Either implicitly detaching or joining a <code>joinable()</code> thread in its destructor could result in difficult to debug correctness (for detach) or performance (for join) bugs encountered only when an exception is raised. Thus the programmer must ensure that the destructor is never executed while the thread is still joinable. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>In early C++0x drafts the wording used to be</p>\n<blockquote>\n<p id=\"so_24080167_24083086_1\">If <code>joinable()</code> then <code>detach()</code>, otherwise no effects. ...</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2008/n2802.html\" rel=\"nofollow\">N2802</a> contains additional details of why implicit invocation of <code>detach()</code> in the destructor was later removed.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-06-06T13:46:26.220", "Id": "24083086", "Score": "5", "CreationDate": "2014-06-06T13:29:34.513", "LastActivityDate": "2014-06-06T13:46:26.220"}, "bq_ids": {"n4140": {"so_24080167_24083086_0": {"section_id": 2717, "quality": 0.925, "length": 37}}, "n3337": {"so_24080167_24083086_0": {"section_id": 2678, "quality": 0.925, "length": 37}}, "n4659": {"so_24080167_24083086_0": {"section_id": 3457, "quality": 0.875, "length": 35}}}});