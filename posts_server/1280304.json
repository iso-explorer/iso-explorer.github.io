post_cb({"1280304": {"CommentCount": "7", "ViewCount": "1227", "PostTypeId": "1", "LastEditorUserId": "18882", "CreationDate": "2009-08-14T21:24:52.850", "LastActivityDate": "2009-08-15T02:27:09.440", "Title": "Why is *= different regarding loss of data on conversion?", "AcceptedAnswerId": "1280362", "LastEditDate": "2009-08-15T02:00:49.923", "Id": "1280304", "Score": "5", "Body": "<p>I have the following example, compiled in VS2005, warning level 4:</p>\n<pre><code>int main(int argc, char *argv[])\n{\n    short s = 2;\n    short t = 3;\n\n    t *= s;    // warning C4244: '*=' : conversion from 'int' to 'short', possible loss of data\n    t = t * s;\n}\n</code></pre>\n<p>It doesn't seem to me there should be a warning on either line. </p>\n<p>Does *= create an implicit conversion to int for some reason?</p>\n<p>EDIT:</p>\n<p>Seems like the lack of warning on the second line (and in VS2008) are the <em>real</em> questions.</p>\n<p>Thanks for the answers.</p>\n", "Tags": "<c++>", "OwnerUserId": "18882", "AnswerCount": "4"}, "1280346": {"ParentId": "1280304", "CommentCount": "0", "CreationDate": "2009-08-14T21:34:50.240", "OwnerUserId": "101197", "PostTypeId": "2", "Id": "1280346", "Score": "3", "Body": "<p>I believe the answer is <a href=\"http://msdn.microsoft.com/en-us/library/3t4w2bkb(VS.80).aspx\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>Quote:</p>\n<blockquote>\n<p id=\"so_1280304_1280346_0\">Most C operators perform type\n  conversions to bring the operands of\n  an expression to a common type or to\n  extend short values to the integer\n  size used in machine operations.</p>\n</blockquote>\n", "LastActivityDate": "2009-08-14T21:34:50.240"}, "1280353": {"ParentId": "1280304", "CommentCount": "0", "CreationDate": "2009-08-14T21:35:51.127", "OwnerUserId": "52534", "PostTypeId": "2", "Id": "1280353", "Score": "4", "Body": "<p>The result of a short * short could overflow a short, so it's probably storing the intermediate result in an int in the second example. If anything they both should have warnings.</p>\n<p>The first one is probably complaining because it's storing the result directly in the original short value, while the second one is creating an intermediate int and then casting that to a short (still a lossy operation, but many compilers won't complain).</p>\n", "LastActivityDate": "2009-08-14T21:35:51.127"}, "1280999": {"ParentId": "1280304", "CommentCount": "0", "CreationDate": "2009-08-15T02:27:09.440", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "1280999", "Score": "0", "Body": "<p>This seems to be a very weird warning in general. Some observations:</p>\n<pre><code>short s = 12345;\ns *= 0xffff;       // no warning\ns *= (int)0xffff;  // no warning\ns *= 0x10000;      // C4244\ns *= -0x8000;      // no warning\ns *= -0x8001;      // C4244\n\nshort t = -12345;\ns *= t;            // no warning\ns *= (int)t;       // no warning\ns *= (unsigned)t;  // no warning\n\ns *= (int)t * 0xffff;  // no warning\ns *= (int)t * 0x10000; // C4244\n</code></pre>\n<p>It doesn't seem to care about specific operators - all of <code>+-*/</code> give the same results. It seems to not actually look at expression types alone, but also at literals involved, and as soon as you cross the magic threshold, the warning pops up.</p>\n", "LastActivityDate": "2009-08-15T02:27:09.440"}, "1280362": {"ParentId": "1280304", "CommentCount": "0", "CreationDate": "2009-08-14T21:39:50.713", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "1280362", "Score": "12", "Body": "<p>Yes. All arithmetic operators in C++ are defined on <code>int</code> and wider. When you multiply two <code>short</code>s (doesn't matter if you use <code>*</code> or <code>*=</code>) they are both converted to <code>int</code> first. This is covered by ISO C++ 5[expr]/9:</p>\n<blockquote>\n<p id=\"so_1280304_1280362_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n<ul>\n<li>If either operand is of type long double, the other shall be converted to long double.</li>\n<li>Otherwise, if either operand is double, the other shall be converted to double.</li>\n<li>Otherwise, if either operand is float, the other shall be converted to float.</li>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands.</li>\n<li>Then, if either operand is unsigned long the other shall be converted to unsigned long.</li>\n<li>Otherwise, if one operand is a long int and the other unsigned int, then if a long int can represent all the values of an unsigned int, the unsigned int shall be converted to a long int; otherwise both operands shall be converted to unsigned long int.</li>\n<li>Otherwise, if either operand is long, the other shall be converted to long.</li>\n<li>Otherwise, if either operand is unsigned, the other shall be converted to unsigned. </li>\n</ul>\n<p id=\"so_1280304_1280362_1\">[Note: otherwise, the only remaining case is that both operands are int]</p>\n</blockquote>\n<p>and 4.5[conv.prom]:</p>\n<blockquote>\n<p id=\"so_1280304_1280362_2\">1 An rvalue of type char, signed char, unsigned char, short int, or unsigned short int can be converted to an rvalue of type int if int can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type unsigned int.</p>\n<p id=\"so_1280304_1280362_3\">2 An rvalue of type wchar_t (3.9.1) or an enumeration type (7.2) can be converted to an rvalue of the first of the following types that can represent all the values of its underlying type: int, unsigned int, long, or unsigned long.</p>\n<p id=\"so_1280304_1280362_4\">3 An rvalue for an integral bit-field (9.6) can be converted to an rvalue of type int if int can represent all the values of the bit-field; otherwise, it can be converted to unsigned int if unsigned int can represent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.</p>\n<p id=\"so_1280304_1280362_5\">4 An rvalue of type bool can be converted to an rvalue of type int, with false becoming zero and true becoming one.</p>\n<p id=\"so_1280304_1280362_6\">5 These conversions are called integral promotions.</p>\n</blockquote>\n<p>Why it only gives a warning on one line but not both is unclear, however.</p>\n", "LastActivityDate": "2009-08-14T21:39:50.713"}, "bq_ids": {"n4140": {"so_1280304_1280362_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_1280304_1280362_3": {"section_id": 22, "quality": 0.76, "length": 19}, "so_1280304_1280362_5": {"section_id": 26, "quality": 0.8571428571428571, "length": 12}, "so_1280304_1280362_6": {"section_id": 5943, "quality": 0.8, "length": 4}, "so_1280304_1280362_4": {"section_id": 25, "quality": 0.9512195121951219, "length": 39}, "so_1280304_1280362_2": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}}, "n3337": {"so_1280304_1280362_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_1280304_1280362_3": {"section_id": 19, "quality": 0.76, "length": 19}, "so_1280304_1280362_5": {"section_id": 23, "quality": 0.8571428571428571, "length": 12}, "so_1280304_1280362_6": {"section_id": 5714, "quality": 0.8, "length": 4}, "so_1280304_1280362_4": {"section_id": 22, "quality": 0.9512195121951219, "length": 39}, "so_1280304_1280362_2": {"section_id": 18, "quality": 0.6060606060606061, "length": 20}}, "n4659": {"so_1280304_1280362_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_1280304_1280362_3": {"section_id": 22, "quality": 0.76, "length": 19}, "so_1280304_1280362_5": {"section_id": 26, "quality": 0.8571428571428571, "length": 12}, "so_1280304_1280362_6": {"section_id": 7428, "quality": 0.8, "length": 4}, "so_1280304_1280362_4": {"section_id": 25, "quality": 0.9512195121951219, "length": 39}, "so_1280304_1280362_2": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}}}});