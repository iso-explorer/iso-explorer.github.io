post_cb({"8664429": {"ParentId": "8664295", "CommentCount": "0", "Body": "<p><strong>C++11 standard: \u00a7 23.2.5/8</strong> </p>\n<blockquote>\n<p id=\"so_8664295_8664429_0\">The elements of an unordered associative container are organized into buckets. Keys with the same hash code appear in the same bucket. The number of buckets is automatically increased as elements are added to an unordered associative container, so that the average number of elements per bucket is kept below a bound. <strong>Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. For unordered_multiset and unordered_multimap, rehashing preserves the relative ordering of equivalent elements.</strong></p>\n</blockquote>\n<p>In short for <code>unordered_map</code>,<br>\nIn case of <strong>Insert/Erase</strong> operations,      </br></p>\n<ul>\n<li>All iterators are invalidated when rehashing occurs, but references remain unaffected.</li>\n</ul>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "8664429", "Score": "7", "CreationDate": "2011-12-29T05:47:22.003", "LastActivityDate": "2011-12-29T05:47:22.003"}, "8664295": {"CommentCount": "0", "ViewCount": "1854", "CreationDate": "2011-12-29T05:24:01.893", "LastActivityDate": "2014-05-24T09:12:21.013", "Title": "Does unordered_map copy/release contained objects if there is insert/remove/rehash operation?", "AcceptedAnswerId": "8664429", "PostTypeId": "1", "Id": "8664295", "Score": "5", "Body": "<p>I wanna store small objects in unordered_map, just wondering if it may copy/release contained objects if there is any insert/remove/rehash operation? I think unordered_map uses link list to store key/value pair, it should not need to copy/release objects like vector for memory reallocation.</p>\n", "Tags": "<c++><boost><stl>", "OwnerUserId": "1120405", "AnswerCount": "2"}, "23843265": {"ParentId": "8664295", "CommentCount": "0", "Body": "<p>I made a test using this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;unordered_map&gt;\n\nstruct A\n{\n    static int copies;\n\n    A(int a): a(a){}\n    A(A const&amp; pA){std::cout &lt;&lt; \"A copy\" &lt;&lt; std::endl; ++copies; a = pA.a;}\n    A&amp; operator=(A const&amp; pA){std::cout &lt;&lt; \"= operator\" &lt;&lt; std::endl; a = pA.a; ++copies; return *this;}\n\n    int a;\n\n\n\n    bool operator==(A const&amp; pA)const{return pA.a == a;}\n    bool operator!=(A const&amp; pA)const{return pA.a != a;}\n    bool operator&gt;(A const&amp; pA)const{return pA.a &gt; a;}\n    bool operator&lt;(A const&amp; pA)const{return pA.a &lt; a;}\n};\nint A::copies = 0;\n\n\nnamespace std{\ntemplate&lt;&gt;\nclass hash&lt;A&gt;\n{\npublic:\n    size_t operator()(A const&amp; pA) const\n    {\n        return pA.a;\n    }\n};\n}\n\n\nint main()\n{\n\n    std::unordered_map&lt;A, A&gt; map;\n    std::unordered_set&lt;A&gt; set;\n\n    for(int i=0; i&lt;1000000; ++i)\n    {\n        set.insert(A(i));\n        map.insert(std::pair&lt;A, A&gt;(A(i), A(i)));\n    }\n    std::cout &lt;&lt; A::copies &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The copy constructor for set was called 1 mln times - which means every object was copied only once (into the set). For the map copy constructor was called 4 mln times - 2 times pet object (note that map needs 2 A objects for every insert). Moreover when i run test in which i insert only one object (for i &lt; 1) then copy construcotr was called once for set and 4 times fot map.</p>\n<p>Conclusions:\nIt seems that reshash and inserting objects doesn't realloc objects in unordered_set nor unordered_map. I think this is true because i do not belive that there wasn't even one rehash for so many insertions. Copy constructor was called once for set (to copy object into a set node) - obvious. Why then copy construcotr was called 4 times for every map insert call? Map key is an A object and also value is an A object. Objects was created then copied into std::pair (first 2 copies) and then pair was copied into the map (2 more copies) - I think it is how it works. </p>\n<p>So it seems that objects in unordered map and set are never reallocated so pointers and references stays valid but iterators probably not - @Alok Save answer. I made this test because i was wondering if keys reallocate when rehash occures. @Alok Save wrote about elements but not about keys (or i didn't understand his answer correctly and element means value and key). </p>\n<p>Question:\nDoes standard says anything about keys (if they aren't considered as elements)?</p>\n<p>PS:\nFor test i used g++ 4.8.</p>\n", "OwnerUserId": "1719911", "PostTypeId": "2", "Id": "23843265", "Score": "-1", "CreationDate": "2014-05-24T09:12:21.013", "LastActivityDate": "2014-05-24T09:12:21.013"}, "bq_ids": {"n4140": {"so_8664295_8664429_0": {"section_id": 761, "quality": 0.9322033898305084, "length": 55}}, "n3337": {"so_8664295_8664429_0": {"section_id": 748, "quality": 0.9322033898305084, "length": 55}}, "n4659": {"so_8664295_8664429_0": {"section_id": 821, "quality": 0.9322033898305084, "length": 55}}}});