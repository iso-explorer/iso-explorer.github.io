post_cb({"5106280": {"ViewCount": "26772", "Body": "<p>is it possible to concatenate strings during preprocessing?</p>\n<p>I found this example</p>\n<pre><code>#define H \"Hello \"\n#define W \"World!\"\n#define HW H W\n\nprintf(HW); // Prints \"Hello World!\"\n</code></pre>\n<p>However it does not work for me - prints out \"Hello\" when I use <code>gcc -std=c99</code></p>\n<p><strong>UPD</strong> This example looks like working now. However, is it a normal feature of c preprocessor?</p>\n", "AcceptedAnswerId": "5106345", "Title": "String concatenation using preprocessor", "CreationDate": "2011-02-24T14:55:06.120", "Id": "5106280", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-12-15T13:58:25.083", "Score": "15", "OwnerUserId": "272865", "Tags": "<c++><c><string>", "AnswerCount": "4"}, "5106665": {"Id": "5106665", "PostTypeId": "2", "Body": "<p>You can indeed concatenate tokens in the preprocessor, but be careful because it's tricky.  The key is the ## operator.  If you were to throw this at the top of your code:</p>\n<pre><code>#define myexample(x,y,z) int example_##x##_##y##_##z## = x##y##z \n</code></pre>\n<p>then basically, what this does, is that during preprocessing, it will take any call to that macro, such as the following:</p>\n<pre><code>myexample(1,2,3);\n</code></pre>\n<p>and it will literally turn into</p>\n<pre><code>int example_1_2_3 = 123;\n</code></pre>\n<p>This allows you a ton of flexibility while coding if you use it correctly, but it doesn't exactly apply how you are trying to use it.  With a little massaging, you could get it to work though.</p>\n<p>One possible solution for your example might be:</p>\n<pre><code>#define H \"Hello \"\n#define W \"World!\"\n#define concat_and_print(a, b) cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl\n</code></pre>\n<p>and then do something like</p>\n<pre><code>concat_and_print(H,W);\n</code></pre>\n", "LastEditorUserId": "632532", "LastActivityDate": "2011-02-24T15:32:48.913", "Score": "16", "CreationDate": "2011-02-24T15:24:21.587", "ParentId": "5106280", "CommentCount": "2", "OwnerUserId": "632532", "LastEditDate": "2011-02-24T15:32:48.913"}, "5106337": {"Id": "5106337", "PostTypeId": "2", "Body": "<p>From <a href=\"http://gcc.gnu.org/onlinedocs/cpp/Concatenation.html\" rel=\"noreferrer\">gcc online docs</a>:</p>\n<blockquote>\n<p id=\"so_5106280_5106337_0\">The '##' preprocessing operator performs token pasting. When a macro is expanded, the two tokens on either side of each '##' operator are combined into a single token, which then replaces the '##' and the two original tokens in the macro expansion. </p>\n<p id=\"so_5106280_5106337_1\">Consider a C program that interprets named commands. There probably needs to be a table of commands, perhaps an array of structures declared as follows:</p>\n<pre><code> struct command\n {\n   char *name;\n   void (*function) (void);\n };\n\n struct command commands[] =\n {\n   { \"quit\", quit_command },\n   { \"help\", help_command },\n   ...\n };\n</code></pre>\n<p id=\"so_5106280_5106337_2\">It would be cleaner not to have to give each command name twice, once in the string constant and once in the function name. A macro which takes the name of a command as an argument can make this unnecessary. The string constant can be created with stringification, and the function name by concatenating the argument with <code>_command</code>. Here is how it is done:</p>\n<pre><code> #define COMMAND(NAME)  { #NAME, NAME ## _command }\n\n struct command commands[] =\n {\n   COMMAND (quit),\n   COMMAND (help),\n   ...\n };\n</code></pre>\n</blockquote>\n", "OwnerDisplayName": "user173973", "LastEditorUserId": "277136", "LastActivityDate": "2012-01-31T16:58:31.020", "Score": "9", "CreationDate": "2011-02-24T14:58:57.763", "ParentId": "5106280", "CommentCount": "0", "LastEditDate": "2012-01-31T16:58:31.020"}, "5106345": {"Id": "5106345", "PostTypeId": "2", "Body": "<p>Concatenation of adjacent string litterals isn't a feature of the preprocessor, it is a feature of the core languages (both C and C++).  You could write:</p>\n<pre><code>printf(\"Hello \"\n       \" world\\n\");\n</code></pre>\n", "LastEditorUserId": "136208", "LastActivityDate": "2011-02-24T15:20:03.513", "Score": "34", "CreationDate": "2011-02-24T14:59:41.573", "ParentId": "5106280", "CommentCount": "0", "OwnerUserId": "136208", "LastEditDate": "2011-02-24T15:20:03.513"}, "bq_ids": {"n4140": {"so_5106280_27485711_0": {"length": 5, "quality": 1.0, "section_id": 5313}, "so_5106280_27485711_2": {"length": 8, "quality": 0.6666666666666666, "section_id": 5313}, "so_5106280_27485711_1": {"length": 5, "quality": 1.0, "section_id": 5313}, "so_5106280_27485711_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5313}}, "n3337": {"so_5106280_27485711_0": {"length": 5, "quality": 1.0, "section_id": 5110}, "so_5106280_27485711_2": {"length": 8, "quality": 0.6666666666666666, "section_id": 5110}, "so_5106280_27485711_1": {"length": 5, "quality": 1.0, "section_id": 5110}, "so_5106280_27485711_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5110}}, "n4659": {"so_5106280_27485711_2": {"length": 8, "quality": 0.6666666666666666, "section_id": 6737}, "so_5106280_27485711_0": {"length": 5, "quality": 1.0, "section_id": 6737}, "so_5106280_27485711_1": {"length": 5, "quality": 1.0, "section_id": 6737}, "so_5106280_27485711_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 6737}}}, "27485711": {"Id": "27485711", "PostTypeId": "2", "Body": "<p>I just thought I would add an answer that cites the source as to why this works. </p>\n<p>The C99 standard \u00a75.1.1.2 defines translation phases for C code. Subsection 6 states:</p>\n<blockquote id=\"so_5106280_27485711_0\">\n<blockquote id=\"so_5106280_27485711_1\">\n<ol start=\"6\">\n<li>Adjacent string literal tokens are concatenated.</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>Similarly, in the C++ standards (ISO 14882) \u00a72.1 defines the Phases of translation. Here Subsection 6 states:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_5106280_27485711_3\">6 Adjacent ordinary string literal tokens are concatenated. Adjacent wide string literal tokens are concatenated.</p>\n</blockquote>\n</blockquote>\n<p>This is why you can concatenate strings simply by placing them adjacent to one another:</p>\n<pre><code>printf(\"string\"\" one\\n\");\n\n&gt;&gt; ./a.out\n&gt;&gt; string one\n</code></pre>\n<p>The preprocessing part of the question is simply the usage of the <code>#define</code> preprocessing directive which does the substitution from identifier (<code>H</code>) to string (<code>\"Hello \"</code>). </p>\n", "LastActivityDate": "2014-12-15T13:58:25.083", "CommentCount": "0", "CreationDate": "2014-12-15T13:58:25.083", "ParentId": "5106280", "Score": "4", "OwnerUserId": "1348709"}});