post_cb({"bq_ids": {"n4140": {"so_25002044_25002044_0": {"length": 8, "quality": 1.0, "section_id": 6092}, "so_25002044_25002044_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 6092}}, "n3337": {"so_25002044_25002044_0": {"length": 5, "quality": 0.625, "section_id": 5870}, "so_25002044_25002044_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 5859}}, "n4659": {"so_25002044_25002044_0": {"length": 8, "quality": 1.0, "section_id": 7588}, "so_25002044_25002044_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 7588}}}, "25002044": {"ViewCount": "83", "Body": "<p>Section 5.3.4/10 of N3797 said:</p>\n<blockquote>\n<p id=\"so_25002044_25002044_0\">When a new-expression calls an allocation function and that allocation\n  has not been extended</p>\n<p id=\"so_25002044_25002044_1\">[...]</p>\n<p id=\"so_25002044_25002044_2\">For arrays of char and unsigned char, the\n  difference between the result of the new-expression and the address\n  returned by the allocation function shall be an integral multiple of\n  the strictest fundamental alignment requirement (3.11) of any object\n  type whose size is no greater than the size of the array being\n  created.</p>\n</blockquote>\n<p>I don't understand that restriction.</p>\n<p>Consider the following new-expression result assigned to char *p:</p>\n<pre><code>char *p = new char[5];\n</code></pre>\n<p>Let during evaluation of the new-expression allocation function return pointer to address <code>a1</code>. What is the algorithm determining the strictest fundamental alignment <code>a</code> of type T which <code>sizeof(T)&lt;=5</code>? How does implementation determine whether address <code>a1+a</code> exists?</p>\n", "AcceptedAnswerId": "25002587", "Title": "Array of char created by non extended allocation function", "CreationDate": "2014-07-28T18:41:02.377", "Id": "25002044", "CommentCount": "3", "LastEditDate": "2014-07-28T18:45:41.563", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "33213", "LastActivityDate": "2014-07-28T19:13:55.287", "Score": "2", "Tags": "<c++>", "AnswerCount": "1"}, "25002587": {"Id": "25002587", "PostTypeId": "2", "Body": "<p>When you do an array <code>new</code>, the size passed to the allocation function is the size of the array you are allocating plus an unspecified amount of array allocation overhead. The allocation function is required to return a pointer to an address aligned for any type with fundamental alignment:</p>\n<pre><code>  ---------------------------------------\n  |  overhead  | actual array           |\n  ---------------------------------------\n  ^            ^\n  |            |\n  |            What the array new expression returns\n  | \n  What the allocation function returns\n  (correctly aligned for any object type with fundamental alignment)\n</code></pre>\n<p>Thus, the \"difference between the result of the new-expression and the address returned by the allocation function\" is the size of the array allocation overhead.</p>\n<p>Fundamental alignment is alignment less than or equal to <code>alignof(std::max_align_t)</code> (\u00a73.11 [basic.align]/p2), and alignments must be a power of two (p4). Thus it's quite easy to determine \"strictest fundamental alignment <code>a</code> of type <code>T</code> which <code>sizeof(T)</code>\" is not greater than any given number. There are only so many possible fundamental alignments.</p>\n<p>The requirement you quoted requires the return value of the array <code>new</code> expression to be properly aligned for any type with fundamental alignment that can fit inside the buffer. The implementation can easily do so by adjusting the size of the array allocation overhead to be a multiple of that alignment requirement. It can trivially accomplish this by making the overhead size a multiple of <code>alignof(std::max_align_t)</code> so that the pointer returned by the array <code>new</code> is always aligned for any type with fundamental alignment.</p>\n", "LastActivityDate": "2014-07-28T19:13:55.287", "CommentCount": "3", "CreationDate": "2014-07-28T19:13:55.287", "ParentId": "25002044", "Score": "2", "OwnerUserId": "2756719"}});