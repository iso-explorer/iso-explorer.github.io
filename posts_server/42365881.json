post_cb({"42365881": {"CommentCount": "5", "ViewCount": "43", "PostTypeId": "1", "ClosedDate": "2017-02-21T14:36:13.013", "LastEditorUserId": "877329", "CreationDate": "2017-02-21T11:20:50.013", "LastActivityDate": "2017-02-21T12:23:43.743", "Title": "When can symbol accessed from template be declared later", "LastEditDate": "2017-02-21T12:23:43.743", "Id": "42365881", "Score": "1", "Body": "<p>This example compiles:</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate&lt;class T&gt;\nint foo(const T* bar,size_t N)\n{\n   return test(T{}); \n}\n\nstruct Type\n{\n};\n\ninline constexpr int test(Type)\n{return 0;}\n\nint main()\n{\n    Type vals[4];\n    return foo(vals,4);\n}\n</code></pre>\n<p>For other similar situations I get </p>\n<blockquote>\n<p id=\"so_42365881_42365881_0\">... declared here, later in the translation unit</p>\n</blockquote>\n<p>Conclusion: Sometimes it is possible to declare the symbol late, but not always. What are the rules for making this work?</p>\n<p>Example compiler log for non-working case:</p>\n<pre><code>In file included from scene.hpp:9:0,\n                 from scene.cpp:6:\nangle/texture2d.hpp: In instantiation of \u2018void Angle::Texture2D::dataSet(const T*, GLsizei, GLsizei) [with T = PageComposer::Surface::Pixel; GLsizei = int]\u2019:\nscene.cpp:26:68:   required from here\nangle/texture2d.hpp:138:68: error: \u2018gl_format\u2019 was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n     glTextureSubImage2D(m_handle,0,0,0,width_in,height_in,gl_format(T{}),gl_type(T{})\n                                                                    ^\nscene.cpp:9:23: note: \u2018constexpr auto gl_format(PageComposer::Surface::Pixel)\u2019 declared here, later in the translation unit\n inline constexpr auto gl_format(PageComposer::Surface::Pixel)\n                       ^\nIn file included from scene.hpp:9:0,\n                 from scene.cpp:6:\nangle/texture2d.hpp:138:81: error: \u2018gl_type\u2019 was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n     glTextureSubImage2D(m_handle,0,0,0,width_in,height_in,gl_format(T{}),gl_type(T{})\n                                                                                 ^\nscene.cpp:12:23: note: \u2018constexpr auto gl_type(PageComposer::Surface::Pixel)\u2019 declared here, later in the translation unit\n inline constexpr auto gl_type(PageComposer::Surface::Pixel) \n</code></pre>\n<p>The definition of Angle::Texture::dataSet looks like this:</p>\n<pre><code>template&lt;class T&gt;\nvoid dataSet(const T* data,GLsizei width_in,GLsizei height_in)\n  {\n  if(m_width!=width_in || m_height!=height_in)\n    {realloc(width_in,height_in);} //Recreate the texture if resized.\n  glTextureSubImage2D(m_handle,0,0,0,width_in,height_in,gl_format(T{}),gl_type(T{})\n    ,data);\n  if(m_levels&gt;1)\n    {glGenerateTextureMipmap(m_handle);}\n  }\n</code></pre>\n<p>It cannot be this function alone, because this also compiles and works correctly:</p>\n<pre><code>#include \"vertexarray.hpp\"\n#include \"program.hpp\"\n#include \"init.hpp\"\n#include \"contextguard.hpp\"\n#include \"texture2d.hpp\"\n\n#include &lt;geosimd/point.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\n\nstruct GLFWContext\n    {\n    GLFWContext(const Angle::VersionRequest&amp; version)\n        {\n        glfwInit();\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, version.major);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, version.minor);\n        switch(version.profile)\n            {\n            case Angle::VersionRequest::Profile::CORE:\n                glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n                break;\n            case Angle::VersionRequest::Profile::COMPAT:\n                glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);\n                break;\n            case Angle::VersionRequest::Profile::ANY:\n            default:\n                glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_ANY_PROFILE);\n                break;\n            }\n        if(version.forward_compatible)\n            {glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);}\n        }\n    ~GLFWContext()\n        {glfwTerminate();}\n    };\n\nclass Window\n    {\n    public:\n        typedef GLFWwindow* ContextHandle;\n\n        Window(const Window&amp;)=delete;\n        Window&amp; operator=(const Window&amp;)=delete;\n\n        Window()\n            {m_handle=glfwCreateWindow(800,600,\"\",nullptr,nullptr);}\n\n        ~Window()\n            {glfwDestroyWindow(m_handle);}\n\n        auto contextCapture() noexcept\n            {\n            auto ret=glfwGetCurrentContext();\n            glfwMakeContextCurrent(m_handle);\n            return ret;\n            }\n\n        static void contextRelease(GLFWwindow* window) noexcept\n            {glfwMakeContextCurrent(window);}\n\n        auto handle() noexcept\n            {return m_handle;}\n\n        bool shouldClose() const noexcept\n            {return glfwWindowShouldClose(m_handle);}\n\n    private:\n        GLFWwindow* m_handle;\n    };\n\nstatic constexpr GeoSIMD::Point&lt;float&gt; verts[]=\n    {\n     GeoSIMD::Point&lt;float&gt;{0.5f,  0.5f, 0.0f}\n    ,GeoSIMD::Point&lt;float&gt;{0.5f, -0.5f, 0.0f}\n    ,GeoSIMD::Point&lt;float&gt;{-0.5f, -0.5f, 0.0f}\n    ,GeoSIMD::Point&lt;float&gt;{-0.5f,  0.5f, 0.0f}\n    };\n\nstatic constexpr uint16_t faces[]=\n    {\n     0,1,3\n    ,1,2,3\n    };\n\ntemplate&lt;class T&gt;\nstatic constexpr const GeoSIMD::vec4_t&lt;T&gt;* native_type(const GeoSIMD::Point&lt;T&gt;* point_ptr)\n    {return reinterpret_cast&lt;const GeoSIMD::vec4_t&lt;T&gt;*&gt;(point_ptr);}\n\nstruct MyShaderLayout\n    {\n    static constexpr Angle::VertexAttribute attributes[]=\n        {\n            {4,Angle::ConstantGet&lt;float&gt;::value}\n        };\n    };\n\nconstexpr Angle::VertexAttribute MyShaderLayout::attributes[];\n\nstruct RGB\n    {\n    uint8_t B;\n    uint8_t G;\n    uint8_t R;\n    uint8_t A;\n    };\n\nstatic RGB g_texture[1200][1920];\n\nstatic void textureFill()\n    {\n    for(size_t k=0;k&lt;1200;++k)\n        {\n        for(size_t l=0;l&lt;1920;++l)\n            {\n            g_texture[k][l].R=uint8_t(255*k/1200.0f);\n            g_texture[k][l].G=uint8_t(255*l/1920.0f);\n            g_texture[k][l].B=0;\n            g_texture[k][l].A=255;\n            }\n        }\n    }\n\ninline constexpr auto gl_format(RGB)\n    {return GL_BGRA;}\n\ninline constexpr auto gl_type(RGB)\n    {return GL_UNSIGNED_INT_8_8_8_8_REV;}\n\nint main()\n    {\n    textureFill();\n    GLFWContext glfw(Angle::gl_version_requirements());\n    try\n        {\n        Window mainwin;\n        Angle::ContextGuard&lt;Window&gt; context(mainwin);\n        auto version=Angle::init();\n\n        printf(\"%s, %s, %s, %s\\n\"\n            ,version.vendor\n            ,version.renderer\n            ,version.version\n            ,version.glsl_version);\n\n        Angle::VertexBuffer&lt;GeoSIMD::vec4_t&lt;float&gt;&gt; vertbuff(4);\n        vertbuff.bufferData(native_type(verts),4);\n        Angle::VertexBuffer&lt;uint16_t&gt; facebuff(6);\n        facebuff.bufferData(faces,6);\n\n        Angle::Texture2D texture(1,Angle::TextureFormat::SRGB8_ALPHA8 ,1920,1200);\n\n        Angle::Program prgm(\nR\"EOF(#version 450 core\nlayout(location=0) in vec4 position;\nout vec2 tex_coords;\nvoid main()\n    {\n    gl_Position=position;\n    tex_coords=position.xy + vec2(0.5,0.5);\n    }\n)EOF\"_vert,R\"EOF(#version 450 core\nout vec4 color;\nin vec2 tex_coords;\nlayout(location=0) uniform sampler2D texture_data;\n\nvoid main()\n    {\n    color=texture(texture_data,tex_coords);\n    }\n)EOF\"_frag);\n\n        Angle::VertexArray&lt;MyShaderLayout&gt; vertex_array;\n        vertex_array.vertexBuffer&lt;0&gt;(vertbuff).enableVertexAttrib&lt;0&gt;()\n            .elementBuffer(facebuff);\n\n        texture.dataSet(&amp;g_texture[0][0],1920,1200);\n\n        texture.bind(1);\n        glEnable(GL_FRAMEBUFFER_SRGB);\n\n        while(!mainwin.shouldClose())\n            {\n            glfwPollEvents();\n            vertex_array.bind();\n            prgm.bind();\n            glUniform1i(0,1);\n            Angle::drawElements(Angle::DrawMode::TRIANGLES,0,6);\n            glfwSwapBuffers(mainwin.handle());\n            }\n\n        }\n    catch(const Angle::Error&amp; err)\n        {\n        fprintf(stderr,\"Error: %s\\n\",err.message());\n        return -1;\n        }\n    return 0;\n    }\n</code></pre>\n<p>Output:</p>\n<pre><code>NVIDIA Corporation, GeForce GTX 1050 Ti/PCIe/SSE2, 4.5.0 NVIDIA 375.20, 4.50 NVIDIA\nOpenGL: Buffer detailed info: Buffer object 1 (bound to NONE, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\nOpenGL: Buffer detailed info: Buffer object 2 (bound to NONE, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/UFOmp.png\" rel=\"nofollow noreferrer\"><img alt=\"Working example\" src=\"https://i.stack.imgur.com/UFOmp.png\"/></a></p>\n", "Tags": "<c++><templates><translation-unit>", "OwnerUserId": "877329", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_42365881_42365881_0": {"section_id": 7204, "quality": 0.8, "length": 4}}, "n3337": {"so_42365881_42365881_0": {"section_id": 6948, "quality": 0.8, "length": 4}}, "n4659": {"so_42365881_42365881_0": {"section_id": 8713, "quality": 0.8, "length": 4}}}});