post_cb({"25783872": {"ParentId": "25783417", "LastEditDate": "2014-09-11T09:38:39.080", "CommentCount": "2", "CreationDate": "2014-09-11T09:31:22.460", "Score": "18", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "25783872", "OwnerUserId": "2756719", "Body": "<p>The C++14 standard (N3936) guarantees that <code>iterator</code> and <code>const_iterator</code> are freely comparable (\u00a723.2.1 [container.requirements.general]/p7):</p>\n<blockquote>\n<p id=\"so_25783417_25783872_0\">In the expressions</p>\n<pre><code>i == j\ni != j\ni &lt; j\ni &lt;= j\ni &gt;= j\ni &gt; j\ni - j\n</code></pre>\n<p id=\"so_25783417_25783872_1\">where <code>i</code> and <code>j</code> denote objects of a container\u2019s <code>iterator</code> type,\n  either or both may be replaced by an object of the container\u2019s\n  <code>const_iterator</code> type referring to the same element with no change in\n  semantics.</p>\n</blockquote>\n<p>In addition, the container member functions take <code>const_iterator</code> parameters as of C++11 (\u00a7C.2.13 [diff.cpp03.containers] - as might be inferred from the tag, this is a change from C++03):</p>\n<blockquote>\n<p id=\"so_25783417_25783872_2\"><strong>Change</strong>: Signature changes: from <code>iterator</code> to <code>const_iterator</code> parameters</p>\n<p id=\"so_25783417_25783872_3\"><strong>Rationale</strong>: Overspecification. <em>Effects</em>: The signatures of the following member functions changed from taking an <code>iterator</code> to taking\n  a <code>const_iterator</code>:</p>\n<ul>\n<li><code>insert(iter, val)</code> for <code>vector</code>, <code>deque</code>, <code>list</code>, <code>set</code>, <code>multiset</code>, <code>map</code>, <code>multimap</code></li>\n<li><code>insert(pos, beg, end)</code> for <code>vector</code>, <code>deque</code>, <code>list</code>, <code>forward_list</code></li>\n<li><code>erase(iter) for</code>set<code>,</code>multiset<code>,</code>map<code>,</code>multimap`</li>\n<li><code>erase(begin, end) for</code>set<code>,</code>multiset<code>,</code>map<code>,</code>multimap`</li>\n<li>all forms of <code>list::splice</code></li>\n<li>all forms of <code>list::merge</code></li>\n</ul>\n</blockquote>\n<p>The container requirements have been similarly changed to take const iterators. In addition, it is easy to obtain the underlying iterator from a <code>std::reverse_iterator</code> via its <code>.base()</code> member function. Thus, neither of the concerns noted in the question should be an issue in a conforming compiler.</p>\n", "LastActivityDate": "2014-09-11T09:38:39.080"}, "25822764": {"ParentId": "25783417", "CommentCount": "0", "CreationDate": "2014-09-13T11:31:02.550", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "25822764", "Score": "7", "Body": "<p>The advice has been reversed, as can be seen from Item 13 of the upcoming <a href=\"http://rads.stackoverflow.com/amzn/click/1491903996\"><strong>Effective Modern C++</strong></a> which is titled: </p>\n<blockquote>\n<p id=\"so_25783417_25822764_0\">Prefer const_iterators to iterators</p>\n</blockquote>\n<p>The reason is that C++11 and C++14 add several tweaks that make <code>const_iterators</code> a lot more practical: </p>\n<p>C++11 adds</p>\n<ul>\n<li>member functions <code>cbegin()</code> and <code>cend()</code> (and their reverse counterparts) for all Standard Library containers</li>\n<li>member functions using iterators to identify positions (e.g. <code>insert()</code>, <code>erase()</code>) now take a <code>const_iterator</code> instead of an <code>iterator</code></li>\n</ul>\n<p>C++14 completes that by adding non-member <code>cbegin()</code> and <code>cend()</code>  (and their reverse counterparts)</p>\n", "LastActivityDate": "2014-09-13T11:31:02.550"}, "bq_ids": {"n4140": {"so_25783417_25783872_1": {"section_id": 708, "quality": 1.0, "length": 19}}, "n4659": {"so_25783417_25783872_1": {"section_id": 737, "quality": 1.0, "length": 19}}}, "25783417": {"CommentCount": "6", "ViewCount": "657", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2014-09-11T09:09:38.917", "LastActivityDate": "2014-09-13T11:31:02.550", "LastEditDate": "2014-09-11T09:15:03.373", "AcceptedAnswerId": "25783872", "FavoriteCount": "3", "Title": "Are const iterators still evil in C++14", "Id": "25783417", "Score": "18", "Body": "<p>Item 26 from Scott Mayers's \"Effective STL\" is labeled \"Prefer <code>iterator</code> to <code>const_iterator</code>, <code>reverse_iterator</code> and <code>const reverse iterator</code>\". </p>\n<p>The reasoning is that some forms of <code>insert()</code> and <code>erase()</code> require exactly <code>iterator</code> and converting from the other types is tedious and error-prone. Furthermore, comparing <code>iterator</code> and <code>const_iterator</code> could be problematic, depending on the STL implementation.</p>\n<p>The book was released at 2001. Is the advice in Item 26 still valid with the current state of gcc?</p>\n", "Tags": "<c++><iterator><c++14>", "OwnerUserId": "1145760", "AnswerCount": "2"}});