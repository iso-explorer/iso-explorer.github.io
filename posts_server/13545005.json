post_cb({"13545065": {"ParentId": "13545005", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The members of <code>enum</code> classes are not meant to convert to <code>int</code> implicitly or vice versa. You can either make sure that your bitmask type is converted to <code>int</code> or use the zero value of the <code>enum</code> class. I'd think the latter is preferable:</p>\n<pre><code>(std::launch::async &amp; std::launch::async) != std::launch()\n</code></pre>\n<p>(I have also added parenthesis around the bitwise <code>and</code> operation since it has higher precedence than the comparison and it doesn't really make much sense to bitwise <code>and</code> a Boolean value with a bitmask type).</p>\n<p>The easiest way to see this is 7.2 [enum.dcl] paragraph 9:</p>\n<blockquote>\n<p id=\"so_13545005_13545065_0\">... Note that this implicit enum to int conversion is not provided for a scoped enumeration: ...</p>\n</blockquote>\n<p>This is, however, within a non-normative Example. Tracking the rules for scoped rules in the standard may require ruling out all the cases where conversions are allowed and currently don't quite fancy this exercise.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2012-11-24T20:10:34.827", "Id": "13545065", "Score": "4", "CreationDate": "2012-11-24T20:04:01.510", "LastActivityDate": "2012-11-24T20:10:34.827"}, "bq_ids": {"n4140": {"so_13545005_13545005_0": {"section_id": 6236, "quality": 0.8333333333333334, "length": 5}, "so_13545005_13545065_0": {"section_id": 5469, "quality": 1.0, "length": 8}}, "n3337": {"so_13545005_13545005_0": {"section_id": 5996, "quality": 0.8333333333333334, "length": 5}, "so_13545005_13545065_0": {"section_id": 5255, "quality": 1.0, "length": 8}}, "n4659": {"so_13545005_13545005_0": {"section_id": 7740, "quality": 0.8333333333333334, "length": 5}, "so_13545005_13545065_0": {"section_id": 6903, "quality": 1.0, "length": 8}}}, "13545005": {"CommentCount": "0", "ViewCount": "145", "PostTypeId": "1", "LastEditorUserId": "893693", "CreationDate": "2012-11-24T19:55:32.793", "LastActivityDate": "2012-11-24T20:10:34.827", "Title": "Proper way to compare BitmaskType with zero?", "AcceptedAnswerId": "13545065", "LastEditDate": "2012-11-24T20:01:49.367", "Id": "13545005", "Score": "2", "Body": "<p>According to the <code>BitmaskType</code> concept, the implementation has to assure that the following statement is well formend: (listed in \u00a717.5.2.1.3.4)</p>\n<blockquote>\n<p id=\"so_13545005_13545005_0\">The value Y is set in the object X if the expression X &amp; Y is nonzero.</p>\n</blockquote>\n<p>where X and Y are of concept-type <code>BitmaskType</code>.</p>\n<p>When trying the following simple code snippet with gcc 4.7 I get template deduction errors:</p>\n<pre><code>#include &lt;future&gt;\n\nint main() {\n    (std::launch::async &amp; std::launch::async) != 0;\n}\n</code></pre>\n<p>Error:</p>\n<pre><code>error: no match for 'operator!=' in '(std::launch)1 != 0'\n... followed by tons of deduction errors\n</code></pre>\n<p>Is this a bug in gcc or am I just getting something wrong here? If yes, what is the proper way to perform this kind of check?</p>\n<p>I already checked gcc buglist but couldn't find anything covering this topic.</p>\n", "Tags": "<c++><c++11><bitmask><c++-concepts>", "OwnerUserId": "893693", "AnswerCount": "1"}});