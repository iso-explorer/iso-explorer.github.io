post_cb({"4023794": {"CommentCount": "4", "ViewCount": "3650", "CreationDate": "2010-10-26T12:49:28.570", "LastActivityDate": "2016-09-01T15:46:02.013", "Title": "Forward declaration just won't do", "AcceptedAnswerId": "4023878", "PostTypeId": "1", "Id": "4023794", "Score": "5", "Body": "<p>Below are two fragments (ready to compile) of code. In first fragment in which I'm using only forward declaration for a struct while deleting pointer to this struct from a Base class dtor for a Guest class isn't invoked.<br>\nIn the second fragment when instead of forward declaration I use full definition of this Guest class using delete in Base works ase intended.<br>\nWhy? Why does it make a difference? Isn't forward declaration suppose to be just a note for a compiler saying that the definition of this class/struct is somewhere else?<br>\nI'm very surprised that it just doesn't work intuitively. </br></br></br></p>\n<pre><code>//First just forward dclr  \n#include \"stdafx.h\"\n#include &lt;iostream&gt;\nusing std::cout;\n\nstruct Guest;\n\nstruct Base\n{\n    Guest* ptr_;\n    Base(Guest* ptr):ptr_(ptr)\n    {\n        cout &lt;&lt; \"Base\\n\";\n    }\n    ~Base()\n    {\n        cout &lt;&lt; \"~Base\\n\";\n        delete ptr_;\n    }\n};\n\nstruct Guest\n{\n    Guest()\n    {\n        cout &lt;&lt; \"Guest\\n\";\n        throw std::exception();\n    }\n    Guest(int)\n    {\n        cout &lt;&lt; \"Guest(int)\\n\";\n    }\n    ~Guest()\n    {\n        cout &lt;&lt; \"~Guest\\n\";\n    }\n};\n\nstruct MyClass : Base\n{\n    Guest g;\n    MyClass(Guest* g):Base(g)\n    {\n        cout &lt;&lt; \"MyClass\\n\";\n\n    }\n    ~MyClass()\n    {\n        cout &lt;&lt; \"~MyClass\\n\";\n    }\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    try\n    {\n        Guest* g = new Guest(1);\n    MyClass mc(g);\n    }\n    catch(const std::exception&amp; e)\n    {\n        std::cerr &lt;&lt; e.what();\n    }\n    return 0;\n}\n</code></pre>\n<p>//Second - full def</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\nusing std::cout;\n\nstruct Guest\n{\n    Guest()\n    {\n        cout &lt;&lt; \"Guest\\n\";\n        throw std::exception();\n    }\n    Guest(int)\n    {\n        cout &lt;&lt; \"Guest(int)\\n\";\n    }\n    ~Guest()\n    {\n        cout &lt;&lt; \"~Guest\\n\";\n    }\n};\n\nstruct Base\n{\n    Guest* ptr_;\n    Base(Guest* ptr):ptr_(ptr)\n    {\n        cout &lt;&lt; \"Base\\n\";\n    }\n    ~Base()\n    {\n        cout &lt;&lt; \"~Base\\n\";\n        delete ptr_;\n    }\n};\n\n\n\nstruct MyClass : Base\n{\n    Guest g;\n    MyClass(Guest* g):Base(g)\n    {\n        cout &lt;&lt; \"MyClass\\n\";\n\n    }\n    ~MyClass()\n    {\n        cout &lt;&lt; \"~MyClass\\n\";\n    }\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    try\n    {\n        Guest* g = new Guest(1);\n    MyClass mc(g);\n    }\n    catch(const std::exception&amp; e)\n    {\n        std::cerr &lt;&lt; e.what();\n    }\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><forward-declaration>", "OwnerUserId": "207177", "AnswerCount": "6"}, "4023871": {"ParentId": "4023794", "CommentCount": "1", "Body": "<p>(The stdafx.h header is not standard c++.)\nIf I compile with g++, the compiler generates:</p>\n<pre><code> warning: possible problem detected in invocation of delete operator:\n warning: invalid use of incomplete type \u2018struct Guest\u2019\n warning: forward declaration of \u2018struct Guest\u2019\n note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined.\n</code></pre>\n<p>Configure your compiler to compile at proper warning and error levels.</p>\n", "OwnerUserId": "280300", "PostTypeId": "2", "Id": "4023871", "Score": "2", "CreationDate": "2010-10-26T12:57:36.750", "LastActivityDate": "2010-10-26T12:57:36.750"}, "4023846": {"ParentId": "4023794", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C++ standard (5.3.5/5):</p>\n<blockquote>\n<p id=\"so_4023794_4023846_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>So you cannot use delete on your incomplete type. It would call the destructor and the compiler is not yet aware of it.</p>\n", "OwnerUserId": "264338", "LastEditorUserId": "3980929", "LastEditDate": "2016-09-01T15:46:02.013", "Id": "4023846", "Score": "16", "CreationDate": "2010-10-26T12:55:02.963", "LastActivityDate": "2016-09-01T15:46:02.013"}, "4023847": {"ParentId": "4023794", "CommentCount": "0", "Body": "<p>You cannot delete a pointer to an incomplete type. Delete is one of the operations which requires the type to be complete. HTH</p>\n", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "4023847", "Score": "3", "CreationDate": "2010-10-26T12:55:24.767", "LastActivityDate": "2010-10-26T12:55:24.767"}, "4023878": {"ParentId": "4023794", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Informally: the compiler needs the class definition in order to delete the object correctly, because it needs to know how to call the destructor and/or <code>operator delete</code> for that class.</p>\n<p>Formally, 5.3.5/5:</p>\n<blockquote>\n<p id=\"so_4023794_4023878_0\">If the object being deleted has\n  incomplete class type at the point of\n  deletion and the complete class has a\n  non-trivial destructor or a\n  deallocation function, the behavior is\n  undefined.</p>\n</blockquote>\n<p>You'd be OK if (for example) <code>Guest</code> was POD, but you gave it a destructor, so you're not OK.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-10-26T13:09:00.353", "Id": "4023878", "Score": "3", "CreationDate": "2010-10-26T12:59:23.847", "LastActivityDate": "2010-10-26T13:09:00.353"}, "4023866": {"ParentId": "4023794", "CommentCount": "0", "Body": "<p>The type of <code>ptr_</code> is incomplete when you invoke <code>delete</code> on it. This leads to undefined behavior. So your destructor may not be called. You can use <a href=\"http://www.boost.org/doc/libs/1_43_0/libs/utility/checked_delete.html\" rel=\"nofollow\">Boost.checked_delete</a> to avoid such scenarios.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "4023866", "Score": "2", "CreationDate": "2010-10-26T12:57:08.507", "LastActivityDate": "2010-10-26T12:57:08.507"}, "bq_ids": {"n4140": {"so_4023794_4023846_0": {"section_id": 6109, "quality": 1.0, "length": 16}, "so_4023794_4023878_0": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_4023794_4023846_0": {"section_id": 5875, "quality": 1.0, "length": 16}, "so_4023794_4023878_0": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_4023794_4023846_0": {"section_id": 7606, "quality": 1.0, "length": 16}, "so_4023794_4023878_0": {"section_id": 7606, "quality": 1.0, "length": 16}}}, "4023844": {"ParentId": "4023794", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You can't delete the Guest unless you know its definition. It's destructor won't be called.\nAlso, if Guest has defined a custom operator delete, it would be ignored.</p>\n", "OwnerUserId": "63832", "LastEditorUserId": "63832", "LastEditDate": "2010-10-26T13:13:04.800", "Id": "4023844", "Score": "3", "CreationDate": "2010-10-26T12:55:01.240", "LastActivityDate": "2010-10-26T13:13:04.800"}});