post_cb({"bq_ids": {"n4140": {"so_44415152_44505505_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 344}}, "n3337": {"so_44415152_44505505_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 334}}, "n4659": {"so_44415152_44505505_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 309}}}, "44415330": {"Id": "44415330", "PostTypeId": "2", "Body": "<p>You can use an <code>auto</code> template parameter in C++17:</p>\n<pre><code>template &lt;auto T&gt;\nconstexpr auto f()\n{\n    return std::integral_constant&lt;decltype(T), T&gt;{};\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>f&lt;3&gt;(); // integral_constant&lt;int, 3&gt;\n</code></pre>\n<hr>\n<p>Alternatively, you need to wrap your value in a compile-time friendly way:</p>\n<pre><code>template &lt;int X&gt;\nstruct int_ \n{ \n    using type = int;\n    static constexpr value = X; \n};\n\ntemplate &lt;typename T&gt;\nconstexpr auto f(T)\n{\n    return std::integral_constant&lt;typename T::type, T::value&gt;{};\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>f(int_&lt;3&gt;{});\n</code></pre>\n</hr>", "LastActivityDate": "2017-06-07T14:21:36.830", "CommentCount": "1", "CreationDate": "2017-06-07T14:21:36.830", "ParentId": "44415152", "Score": "2", "OwnerUserId": "598696"}, "44416557": {"Id": "44416557", "PostTypeId": "2", "Body": "<p>Since c++11 you can declare your own literals (I used here <code>std::index_sequence</code> and it's c++14 but you can easily find c++11 implementation of aforesaid): </p>\n<pre><code>#include &lt;utility&gt; // for std::index_sequence and std::size_t\n\nconstexpr std::size_t ipow(std::size_t base, int exp, std::size_t result = 1) {\n  return exp &lt; 1 ? result : ipow(base*base, exp/2, (exp % 2) ? result*base : result);\n}\n\nconstexpr std::size_t vdot(std::index_sequence&lt;&gt;, std::index_sequence&lt;&gt;) {\n    return 0;\n}\n\ntemplate &lt;std::size_t C, std::size_t... Cs, std::size_t I, std::size_t... Is&gt;\nconstexpr std::size_t vdot(std::index_sequence&lt;C, Cs...&gt;, std::index_sequence&lt;I, Is...&gt;) {\n    return C*ipow(10, I) + vdot(std::index_sequence&lt;Cs...&gt;{}, std::index_sequence&lt;Is...&gt;{});\n}\n\ntemplate &lt;char... Cs&gt;\nstd::integral_constant&lt;std::size_t, vdot(std::index_sequence&lt;static_cast&lt;std::size_t&gt;(Cs - '0')...&gt;{}, std::make_index_sequence&lt;sizeof...(Cs)&gt;{})&gt; operator \"\"_ic() {\n    return {};\n}\n\nint main() {\n   auto ic = 3_ic;\n   static_cast&lt;void&gt;(ic);\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/XVtVpsiSqekSn2nH\" rel=\"nofollow noreferrer\">[live demo]</a></p>\n", "LastActivityDate": "2017-06-07T15:12:35.660", "CommentCount": "1", "CreationDate": "2017-06-07T15:12:35.660", "ParentId": "44415152", "Score": "2", "OwnerUserId": "4324224"}, "44505505": {"Id": "44505505", "PostTypeId": "2", "Body": "<p>In C++11 and C++14 this is impossible as per</p>\n<p>\u00a714.8.2.5 [temp.deduct.type] 13 and 14 </p>\n<blockquote>\n<p id=\"so_44415152_44505505_0\">A template type argument cannot be deduced from the type of a non-type\n  <em>template-argument</em>. [Example:<br/> </p>\n</blockquote>\n<pre><code>template&lt;class T, T i&gt; void f(double a[10][i]); \nint v[10][20]; \nf(v); // error: argument for template-parameter T cannot be deduced \n</code></pre>\n<blockquote>\n<p id=\"so_44415152_44505505_1\">\u2014end example ]</p>\n</blockquote>\n<p>So you are forced to specify a type. e.g. <code>f&lt;int, 3&gt;(/*...*/)</code></p>\n<p>I give full credit to @Barry for teaching me this <a href=\"https://stackoverflow.com/a/44265134/27678\">in his answer to my last question</a></p>\n<h3><a href=\"https://wandbox.org/permlink/6YxpVsYf6FjJ6oLM\" rel=\"nofollow noreferrer\">Demo</a></h3>\n", "LastActivityDate": "2017-06-12T17:35:24.800", "CommentCount": "1", "CreationDate": "2017-06-12T17:35:24.800", "ParentId": "44415152", "Score": "1", "OwnerUserId": "27678"}, "44415152": {"ViewCount": "132", "Body": "<p>is it possible to do something like:</p>\n<pre><code>template&lt;class T, T type&gt;\nconstexpr auto f(/* type used in some way... */) // -&gt; decltype (etc. in case of C++11)\n  {\n  return std::integral_constant&lt;T,t&gt;{};\n  }\n\nconstexpr auto z = f(3); // z is deduced as an integral_constant&lt;int,3&gt;;\n</code></pre>\n<p>It's for sure not possible using a runtime value, but 3 in this case is a compile time value. Maybe someone knows some trick I'm not aware of...</p>\n<p>[edit]\n  constexpr auto z2 = f&lt;3&gt;(); // This would be ok too</p>\n<p>I just would like to avoid to repeat the type..  </p>\n", "Title": "Dependent type automatic deduction", "CreationDate": "2017-06-07T14:13:32.297", "LastActivityDate": "2017-06-12T17:35:24.800", "CommentCount": "0", "LastEditDate": "2017-06-07T15:52:23.107", "PostTypeId": "1", "LastEditorUserId": "3233393", "Id": "44415152", "Score": "1", "OwnerUserId": "3770392", "Tags": "<c++><c++11><templates><template-meta-programming><type-deduction>", "AnswerCount": "3"}});