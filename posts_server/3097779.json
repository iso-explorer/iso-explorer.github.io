post_cb({"3097803": {"ParentId": "3097779", "CommentCount": "4", "CreationDate": "2010-06-22T23:10:24.950", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "3097803", "Score": "35", "Body": "<p>Just above that example, it says</p>\n<blockquote id=\"so_3097779_3097803_0\">\n<ul>\n<li>if e is an unparenthesized id-expression or a class member access (5.2.5), decltype(e) is the type of the entity named by e.</li>\n<li>if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;</li>\n</ul>\n</blockquote>\n<p>I think <code>decltype(a-&gt;x)</code> is an example of the \"class member access\" and <code>decltype((a-&gt;x))</code> is an example of lvalue.</p>\n", "LastActivityDate": "2010-06-22T23:10:24.950"}, "3097804": {"ParentId": "3097779", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-06-22T23:10:58.760", "Score": "8", "LastEditorUserId": "37558", "LastEditDate": "2010-06-22T23:18:24.910", "Id": "3097804", "OwnerUserId": "37558", "Body": "<p>The added parens are turning it into a lvalue.</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/dd537655.aspx\" rel=\"noreferrer\">MSDN says</a><br>\nThe inner parentheses cause the statement to be evaluated as an expression instead of a member access. And because a  is declared as a const pointer, the type is a reference to const double. </br></p>\n", "LastActivityDate": "2010-06-22T23:18:24.910"}, "3097814": {"ParentId": "3097779", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-06-22T23:12:13.173", "Score": "15", "LastEditorUserId": "151292", "LastEditDate": "2010-06-22T23:18:45.377", "Id": "3097814", "OwnerUserId": "151292", "Body": "<pre><code>decltype(a-&gt;x)\n</code></pre>\n<p>This gives you the type of the member variable <code>A::x</code>, which is <code>double</code>.</p>\n<pre><code>decltype((a-&gt;x))\n</code></pre>\n<p>This gives you the type of the expression <code>(a-&gt;x)</code>, which is an lvalue expression (hence why it is a const reference--<code>a</code> is a <code>const A*</code>).</p>\n", "LastActivityDate": "2010-06-22T23:18:45.377"}, "3097779": {"CommentCount": "0", "AcceptedAnswerId": "3097803", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2010-06-22T23:03:48.710", "LastActivityDate": "2014-06-09T06:40:54.383", "LastEditDate": "2014-06-09T06:40:54.383", "ViewCount": "3116", "FavoriteCount": "18", "Title": "decltype and parentheses", "Id": "3097779", "Score": "42", "Body": "<p>I don't understand the last line of the example on page 148 of the FCD (\u00a77.6.1.2/4):</p>\n<pre><code>const int&amp;&amp; foo();\nint i;\nstruct A { double x; };\nconst A* a = new A();\ndecltype(foo()) x1 = i;     // type is const int&amp;&amp;\ndecltype(i) x2;             // type is int\ndecltype(a-&gt;x) x3;          // type is double\ndecltype((a-&gt;x)) x4 = x3;   // type is const double&amp;\n</code></pre>\n<p>Why do the parentheses make a difference here? Shouldn't it simply be <code>double</code> like in the line above?</p>\n", "Tags": "<c++><c++11><type-inference><decltype>", "OwnerUserId": "252000", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3097779_3097803_0": {"section_id": 5440, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_3097779_3097803_0": {"section_id": 5235, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_3097779_3097803_0": {"section_id": 6867, "quality": 0.9285714285714286, "length": 13}}}});