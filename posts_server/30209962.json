post_cb({"30209962": {"CommentCount": "7", "AcceptedAnswerId": "30210182", "CreationDate": "2015-05-13T08:50:42.953", "LastActivityDate": "2016-05-06T11:51:28.793", "PostTypeId": "1", "ViewCount": "1926", "FavoriteCount": "1", "Title": "How to create temporary object in C++", "Id": "30209962", "Score": "14", "Body": "<p>I have the following piece of code.</p>\n<pre><code>class A {\n public:\n  A(int) {\n  }\n};\n\nint a;\nint main() {\n  A(a);  // Line 'a\n  return 0;\n}\n</code></pre>\n<p>What I want to do on line 'a is to create a temporary <code>A</code> with constructor <code>A::A(int)</code>. I know it's going to destruct immediately. That's what I want. But it seems the compiler is doing something equivalent to <code>A a</code>, defining variable <code>a</code> as of class <code>A</code> and initialize it using constructor <code>A::A()</code>. Of course it doesn't exist, hence the compiler error.</p>\n<p>However, if I change my code to the following.</p>\n<pre><code>class A {\n public:\n  A(int) {\n  }\n};\n\nvoid f(A) {\n}\n\nint a;\nint main() {\n  f(A(a));\n  return 0;\n}\n</code></pre>\n<p>It works fine now. The compiler constructs a temporary <code>A</code> and use it to call <code>f</code>.</p>\n<p>Why is <code>A(a)</code> different in both contexts? How is it stated in the standard or for some obscure reason? How can I construct a temporary object as in the first code sample?</p>\n", "Tags": "<c++>", "OwnerUserId": "1595430", "AnswerCount": "2"}, "30210182": {"ParentId": "30209962", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-05-13T09:02:01.667", "Score": "19", "LastEditorUserId": "2756719", "LastEditDate": "2015-05-13T09:07:56.017", "Id": "30210182", "OwnerUserId": "2756719", "Body": "<p>This is another instance of the \"everything that can be a declaration is a declaration\" rule. [stmt.ambig]/p1:</p>\n<blockquote>\n<p id=\"so_30209962_30210182_0\">There is an ambiguity in the grammar involving <em>expression-statement</em>s\n  and declarations: An <em>expression-statement</em> with a function-style\n  explicit type conversion (5.2.3) as its leftmost subexpression can be\n  indistinguishable from a <em>declaration</em> where the first <em>declarator</em>\n  starts with a <code>(</code>. In those cases the <em>statement</em> is a <em>declaration</em>.</p>\n</blockquote>\n<p>The standard provides the following examples:</p>\n<blockquote>\n<p id=\"so_30209962_30210182_1\">Assuming T is a <em>simple-type-specifier</em>,</p>\n<pre><code>T(a)-&gt;m = 7;       // expression-statement\nT(a)++;            // expression-statement\nT(a,5)&lt;&lt;c;         // expression-statement\nT(*d)(int);        // declaration\nT(e)[5];           // declaration\nT(f) = { 1, 2 };   // declaration\nT(*g)(double(3));  // declaration\n</code></pre>\n<p id=\"so_30209962_30210182_2\">In the last example above, <code>g</code>, which is a pointer to <code>T</code>, is initialized\n  to <code>double(3)</code>. This is of course ill-formed for semantic reasons, but\n  that does not affect the syntactic analysis.</p>\n</blockquote>\n<p>and also:</p>\n<blockquote id=\"so_30209962_30210182_3\">\n<pre><code>class T {\n// ...\npublic:\n    T();\n    T(int);\n    T(int, int);\n};\n\nT(a);          // declaration\nT(*b)();       // declaration\nT(c)=7;        // declaration\nT(d),e,f=3;    // declaration\nextern int h;\nT(g)(h,2);     // declaration\n</code></pre>\n</blockquote>\n<p>The simplest way to disambiguate is probably an extra set of parentheses. <code>(A(a));</code> is unambiguously an <em>expression-statement</em>.</p>\n", "LastActivityDate": "2015-05-13T09:07:56.017"}, "30210135": {"ParentId": "30209962", "CommentCount": "1", "CreationDate": "2015-05-13T08:59:50.330", "OwnerUserId": "268", "PostTypeId": "2", "Id": "30210135", "Score": "4", "Body": "<p>I could not think of a way to create a temporary without using it in some call, like you did with the function.</p>\n<p>Why don't you want to create a named variable instead? It's lifecycle will be exactly the same as your \"temporary\", given how you try to declare it.</p>\n<p>If you really want to control the destruction of your object, you could always encapsulate it in a block: <code>{ A tmp(a); } // temporary A object</code></p>\n<hr>\n<p>The thing is... I don't see the point of doing that. Why would you want to create a temporary object without using it? It usually means that your object creation or destruction has some side effects that you want to trigger. This is a really bad idea! You should move the side effects to a function and simply call it.</p>\n</hr>", "LastActivityDate": "2015-05-13T08:59:50.330"}, "bq_ids": {"n4140": {"so_30209962_30210182_2": {"section_id": 3922, "quality": 0.9375, "length": 15}, "so_30209962_30210182_0": {"section_id": 3921, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_30209962_30210182_2": {"section_id": 3781, "quality": 0.9375, "length": 15}, "so_30209962_30210182_0": {"section_id": 3781, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_30209962_30210182_2": {"section_id": 4808, "quality": 0.9375, "length": 15}, "so_30209962_30210182_0": {"section_id": 4807, "quality": 0.9615384615384616, "length": 25}}}});