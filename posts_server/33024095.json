post_cb({"33024116": {"ParentId": "33024095", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-10-08T19:13:29.537", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:48.723", "Id": "33024116", "OwnerUserId": "4342498", "Body": "<pre><code>MyImage&amp; image = MyImage(-1); // initialized with invalid handle\n</code></pre>\n<p>Should not compile as you cannot take a non const reference to a temporary variable.  If you had</p>\n<pre><code>const MyImage&amp; image = MyImage(-1); // initialized with invalid handle\n</code></pre>\n<p>Then the liftime would be extended untill the reference's lifetime ends.  Since the reference variable is an automatic object the lifetime will end when it goes out of scope.  From [basic.stc.auto]</p>\n<blockquote>\n<p id=\"so_33024095_33024116_0\">Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration. The storage for these entities lasts until the block in which they are created exits.</p>\n</blockquote>\n<p>As for why Visual studio is allowing this see <a href=\"https://stackoverflow.com/questions/16380966/non-const-reference-bound-to-temporary-visual-studio-bug\">Non-const reference bound to temporary, Visual Studio bug?</a></p>\n", "LastActivityDate": "2015-10-08T20:13:26.370"}, "33024095": {"CommentCount": "6", "ViewCount": "68", "PostTypeId": "1", "LastEditorUserId": "1925996", "CreationDate": "2015-10-08T19:12:09.490", "LastActivityDate": "2015-10-08T20:13:26.370", "Title": "Are objects bound to local references automatically destructed?", "AcceptedAnswerId": "33024116", "LastEditDate": "2015-10-08T19:49:50.600", "Id": "33024095", "Score": "2", "Body": "<p>Consider the following code.</p>\n<pre><code>struct MyImage\n{\n    MyImage(const int handle);\n    MyImage(const CString&amp; filePath);\n    virtual ~MyImage();\n\n    void Process();\n    void SaveAs(const CString&amp; filePath);\n\n    // No copying!\n    MyImage(const MyImage&amp; other) = delete;\n    MyImage&amp; operator=(const MyImage&amp; other) = delete;\n}\n\nvoid ProcessImageFile(const CString&amp; inFilePath, const CString&amp; outFilePath)\n{\n    MyImage&amp; image = MyImage(-1); // initialized with invalid handle\n\n    if (DecryptionRequired())\n    {\n        const CString tempFilePath = ::GetTempFileName();\n        Decrypt(inFilePath, tempFilePath);\n        image = MyImage(tempFilePath);\n        _tremove(tempFilePath);\n    }\n    else\n    {\n        image = MyImage(inFilePath);\n    }\n\n    image.Process();\n    image.SaveAs(outFilePath);\n}\n</code></pre>\n<p>Will the object referenced by <code>image</code> be destructed when <code>ProcessImageFile()</code> returns?</p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "1925996", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33024095_33024116_0": {"section_id": 7170, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_33024095_33024116_0": {"section_id": 6914, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_33024095_33024116_0": {"section_id": 8678, "quality": 0.7727272727272727, "length": 17}}}});