post_cb({"24832212": {"ParentId": "24832143", "CommentCount": "0", "Body": "<p>There is no such thing as a templated copy constructor.  The regular (non-templated) copy constructor is still generated and a better match than the templated one with the signature you provided (things get more complicated with \"universal\" references thrown in the mix, but that is off-topic).</p>\n", "OwnerUserId": "1082038", "PostTypeId": "2", "Id": "24832212", "Score": "3", "CreationDate": "2014-07-18T19:16:00.120", "LastActivityDate": "2014-07-18T19:16:00.120"}, "24832219": {"ParentId": "24832143", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The answer is simple - There is no (!) template copy constructor. Even if the template parameter matches the parameter of a copy constructor it is no copy constructor.</p>\n<p>See 12.8 Copying and moving class objects</p>\n<blockquote>\n<p id=\"so_24832143_24832219_0\">A non-template constructor for class X is a copy constructor if its\n  first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile\n  X&amp;, and either there are no other parameters or else all other\n  parameters have default arguments (8.3.6). [ Example: X::X(const X&amp;)\n  and X::X(X&amp;,int=1) are copy constructors.</p>\n</blockquote>\n<p>Similar applies to the move constructor</p>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2014-07-18T19:25:48.270", "Id": "24832219", "Score": "4", "CreationDate": "2014-07-18T19:16:29.333", "LastActivityDate": "2014-07-18T19:25:48.270"}, "24832271": {"ParentId": "24832143", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Copy constructors, and move constructors, are not templated. The C++ standard is specific on what constitutes a copy constructor.</p>\n<p>From: <a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/copy_constructor</a></p>\n<blockquote>\n<p id=\"so_24832143_24832271_0\">A copy constructor of class T is a non-template constructor whose first parameter is T&amp;, const T&amp;, volatile T&amp;, or const volatile T&amp;, and either there are no other parameters, or the rest of the parameters all have default values.</p>\n</blockquote>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2014-07-20T18:24:30.973", "Id": "24832271", "Score": "2", "CreationDate": "2014-07-18T19:20:02.487", "LastActivityDate": "2014-07-20T18:24:30.973"}, "bq_ids": {"n4140": {"so_24832143_24832271_0": {"section_id": 451, "quality": 0.7272727272727273, "length": 16}, "so_24832143_24832219_0": {"section_id": 451, "quality": 0.9, "length": 27}}, "n3337": {"so_24832143_24832271_0": {"section_id": 442, "quality": 0.7272727272727273, "length": 16}, "so_24832143_24832219_0": {"section_id": 442, "quality": 0.9, "length": 27}}, "n4659": {"so_24832143_24832271_0": {"section_id": 474, "quality": 0.7727272727272727, "length": 17}, "so_24832143_24832219_0": {"section_id": 474, "quality": 0.9, "length": 27}}}, "24832143": {"CommentCount": "0", "ViewCount": "201", "CreationDate": "2014-07-18T19:10:55.107", "LastActivityDate": "2014-07-20T18:24:30.973", "Title": "Template \"copy constructor\" does not prevent compiler-generated move constructor", "AcceptedAnswerId": "24832219", "PostTypeId": "1", "Id": "24832143", "Score": "1", "Body": "<p>Consider the following program and the comments in it:</p>\n<pre><code>template&lt;class T&gt;\nstruct S_ {\n    S_() = default;\n\n    // The template version does not forbid the compiler\n    // to generate the move constructor implicitly\n    template&lt;class U&gt; S_(const S_&lt;U&gt;&amp;) = delete;\n\n    // If I make the \"real\" copy constructor\n    // user-defined (by deleting it), then the move\n    // constructor is NOT implicitly generated\n    // S_(const S_&amp;) = delete;\n};\n\nusing S = S_&lt;int&gt;;\n\nint main() {\n    S s;\n    S x{static_cast&lt;S&amp;&amp;&gt;(s)};\n}\n</code></pre>\n<p>The question is: why does not <em>user-defining</em> the template constructor (which effectively acts as a copy constructor when U = T) prevent the compiler from generating the move constructor, while, on the contrary, if I <em>user define</em> the \"real\" copy constructor (by deleting it), then the move constructor is not generated implicitly (the program would not compile)? (Probably the reason is that \"template version\" does not respect the standard definition of copy-constructor also when T = U?).</p>\n<p>The good thing is that that seems to apparently be what I want. In facts, I need <strong>all</strong> the copy and move constructors <strong>and</strong> <strong>all</strong> the move and copy assignment operators that the compiler would generate implicitly as if S was simply defined as <code>template&lt;class U&gt; S{};</code> plus the template constructor for the conversions from other <code>S&lt;U&gt;</code>. By standard, can I rely on the above definition of S to have all the mentioned stuff I need? If yes, I could then avoid to \"default'ing\" them explicitly.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "989331", "AnswerCount": "3"}});