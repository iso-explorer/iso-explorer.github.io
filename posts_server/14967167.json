post_cb({"bq_ids": {"n4140": {"so_14967167_14967452_4": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}, "so_14967167_14967452_3": {"length": 81, "quality": 0.9204545454545454, "section_id": 3296}, "so_14967167_14967452_2": {"length": 17, "quality": 0.68, "section_id": 3294}}, "n3337": {"so_14967167_14967452_2": {"length": 17, "quality": 0.68, "section_id": 3164}, "so_14967167_14967452_3": {"length": 81, "quality": 0.9204545454545454, "section_id": 3166}, "so_14967167_14967452_4": {"length": 73, "quality": 0.948051948051948, "section_id": 472}}, "n4659": {"so_14967167_14967452_2": {"length": 17, "quality": 0.68, "section_id": 4056}, "so_14967167_14967452_3": {"length": 60, "quality": 0.6818181818181818, "section_id": 4058}, "so_14967167_14967452_4": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}}}, "14967167": {"ViewCount": "1483", "Body": "<p>Please consider the code below, which compiles in VS2012 but fails in VS2010 with the error</p>\n<pre><code>    1&gt;------ Build started: Project: testconstinit, Configuration: Debug Win32 ------\n1&gt;  testconstinit.cpp\n1&gt;c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory(48): error C2248: 'std::unique_ptr&lt;_Ty&gt;::unique_ptr' : cannot access private member declared in class 'std::unique_ptr&lt;_Ty&gt;'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=int\n1&gt;          ]\n1&gt;          c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\memory(2347) : see declaration of 'std::unique_ptr&lt;_Ty&gt;::unique_ptr'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=int\n1&gt;          ]\n1&gt;          c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory(197) : see reference to function template instantiation 'void std::_Construct&lt;std::unique_ptr&lt;_Ty&gt;,const std::unique_ptr&lt;_Ty&gt;&amp;&gt;(_Ty1 *,_Ty2)' being compiled\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=int,\n1&gt;              _Ty1=std::unique_ptr&lt;int&gt;,\n1&gt;              _Ty2=const Movable &amp;\n1&gt;          ]\n1&gt;          c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory(196) : while compiling class template member function 'void std::allocator&lt;_Ty&gt;::construct(std::unique_ptr&lt;int&gt; *,const _Ty &amp;)'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Movable\n1&gt;          ]\n1&gt;          c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector(421) : see reference to class template instantiation 'std::allocator&lt;_Ty&gt;' being compiled\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Movable\n1&gt;          ]\n1&gt;          c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector(481) : see reference to class template instantiation 'std::_Vector_val&lt;_Ty,_Alloc&gt;' being compiled\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Movable,\n1&gt;              _Alloc=std::allocator&lt;Movable&gt;\n1&gt;          ]\n1&gt;          c:\\users\\zadirion\\documents\\visual studio 2010\\projects\\testconstinit\\testconstinit\\testconstinit.cpp(34) : see reference to class template instantiation 'std::vector&lt;_Ty&gt;' being compiled\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Movable\n1&gt;          ]\n1&gt;          c:\\users\\zadirion\\documents\\visual studio 2010\\projects\\testconstinit\\testconstinit\\testconstinit.cpp(81) : see reference to class template instantiation 'LazyValue&lt;T&gt;' being compiled\n1&gt;          with\n1&gt;          [\n1&gt;              T=Container\n1&gt;          ]\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n</code></pre>\n<p>The code:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;functional&gt;\n#include &lt;deque&gt;\n\n\nusing namespace std;\n\n\n\ntypedef std::unique_ptr&lt;int&gt; Movable;\ntypedef vector&lt;Movable&gt; Container;\n\ntypedef vector&lt;Movable&gt; (*MakeType)();\n\n\ntemplate &lt;class T, class Initializer = function&lt;T(void)&gt; &gt;\nstruct LazyValue\n{\n  LazyValue(Initializer aInit) : mInit(aInit) {}\n\n\n  void Init() const\n  {\n    m = mInit();\n  }\n\nprivate:\n\n  mutable T m; // &lt;-- compiler error at this line\n  Initializer mInit;\n\n  LazyValue operator=(const LazyValue &amp; aOther)\n  {\n\n  }\n};\n\ntemplate &lt;class T&gt;\nstruct GenericList\n{\n    std::deque&lt;T&gt; mValues;\n\n    GenericList(){}\n\n    GenericList &amp; operator()(T &amp;&amp; aValue)\n    {\n        mValues.push_back(std::move(aValue));\n        return *this;\n    }\n\n    template &lt;class Container&gt;\n    operator Container()\n    {\n        auto it = mValues.begin();\n        auto endIt = mValues.end();\n\n        Container c;\n\n        for ( ; it != endIt; it++ )\n        {\n            c.push_back(std::move(*it));\n        }\n        return std::move(c);\n    }\n};\n\ntemplate &lt;class T&gt;\nGenericList&lt;T&gt; ListOfRValues()\n{\n    return GenericList&lt;T&gt;();\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\n  const LazyValue&lt;Container&gt; s = []()-&gt;Container{\n      return ListOfRValues&lt;Movable&gt;()\n        (Movable(new int) )\n        (Movable(new int) )\n        (Movable(new int) );\n  };\n\n  return 0;\n}\n</code></pre>\n<p>Can anyone point with a link to the bug submitted to Microsoft maybe, or an explanation on what the compiler bug is actually, I am trying to understand which part of the code exactly is troubling the compiler. Also, what workaround do we have for this?</p>\n<p>Thank you!</p>\n", "AcceptedAnswerId": "14967452", "Title": "What is the bug exactly and what workaround is there for copy constructor erroneously called for Movable and Non-copyable member", "CreationDate": "2013-02-19T20:51:49.580", "Id": "14967167", "CommentCount": "10", "LastEditDate": "2013-02-19T21:03:51.183", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2013-02-19T22:44:40.357", "Score": "2", "OwnerUserId": "911325", "Tags": "<c++><visual-c++><c++11><compiler-errors><move-semantics>", "AnswerCount": "1"}, "14967452": {"Id": "14967452", "PostTypeId": "2", "Body": "<p><strong>This code should not compile.</strong></p>\n<p>The problem is in the fact that you are using <em>copy-initialization</em>, which may require (if the compiler is not eliding it) the construction of a temporary object of type <code>LazyValue&lt;Container&gt;</code>, which is then moved into the initialized object <code>s</code>. </p>\n<p>From Paragraph 8.5/14 of the C++11 Standard: </p>\n<blockquote>\n<p id=\"so_14967167_14967452_0\">The initialization that occurs in the form</p>\n<p id=\"so_14967167_14967452_1\">T x = a;</p>\n<p id=\"so_14967167_14967452_2\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization</em>. [ Note: Copy-initialization may invoke a move (12.8). \u2014end note ]</p>\n</blockquote>\n<p>Moreover, according to Paragraph 8.5/16:</p>\n<blockquote>\n<p id=\"so_14967167_14967452_3\">[...] Otherwise (i.e., for the remaining <strong>copy-initialization</strong> cases), <strong>user-defined conversion sequences that can convert from the source type to the destination type</strong> or (when a conversion function is used) to a derived class thereof <strong>are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3)</strong>. If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function selected is called with the initializer expression as its argument; <strong>if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type</strong>. The temporary is a prvalue. <strong>The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization</strong>. In certain cases, an implementation <strong>is permitted</strong> to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>Let's assume for the moment that your compiler does <em>not</em> elide the copy/move (the compiler is allowed, but not required, to do so).</p>\n<p>Your class template doesn't define any move constructor, and the implicitly generated copy constructor will be selected for constructing the object <code>s</code> from the temporary which has been constructed from the lambda on the right side of the initialization. </p>\n<p>Unfortunately, your class has a member variable of type <code>Container</code>, which is a container of <em>non-copyable</em> elements. Hence, instantiation of the implicitly generated copy-construction will fail, which explains the error you are getting.</p>\n<p>You should use <em>direct-initialization</em> instead:</p>\n<pre><code>const LazyValue&lt;Container&gt; s([]() -&gt; Container {\n  return ListOfRValues&lt;Movable&gt;()\n    (Movable(new int) )\n    (Movable(new int) )\n    (Movable(new int) );\n});\n</code></pre>\n<p>Let's now consider the case where the compiler <em>does</em> choose to elide the copy/move. There is a requirement in the C++11 Standard on this behavior, coming from Paragraph 12.8/32:</p>\n<blockquote>\n<p id=\"so_14967167_14967452_4\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ Note: <strong>This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be <em>accessible</em> even if the call is elided.</strong> \u2014end note ]</p>\n</blockquote>\n<p>The key term here is <em>accessible</em>. The instantiation of the implicitly generated copy-constructor cannot succeed, because the object to be copied contains a non-copyable sub-object; which necessarily makes the copy-constructor inaccessible, because it can never be instantiated. Hence, a conforming compiler shall refuse to compile the code, and I believe this is qualifies as a bug in VS2012.</p>\n<hr>\n<p>P.S.: Also, mind the fact that you are violating the so-called <strong><a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">Rule of Three</a></strong> (apart from having an overloaded copy-assignment operator that returns nothing, while it should probably return <code>*this</code>).</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-19T22:44:40.357", "Score": "5", "CreationDate": "2013-02-19T21:08:15.867", "ParentId": "14967167", "CommentCount": "5", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:12:31.510"}});