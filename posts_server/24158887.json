post_cb({"24159201": {"ParentId": "24158887", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-11T09:23:35.980", "Score": "3", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-11T09:28:59.083", "Id": "24159201", "OwnerUserId": "1090079", "Body": "<p><em>MSVC</em> is not conformant, the snippet is ill-formed; we must explicitly write <code>typename T::iterator</code> to refer to a type-name <code>iterator</code> inside  <code>T</code>, since it's a <em>dependent-type</em>.</p>\n<p>This is a known bug in the compiler, see the relevant bug report:</p>\n<ul>\n<li><a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/743927/msvc-allows-omitting-typename-keyword-before-dependent-type-name\" rel=\"nofollow\"><strong>[bug report]</strong> MSVC allows omitting typename keyword before dependent type name</a></li>\n</ul>\n<hr>\n<h3>What does the standard say? (<a href=\"http://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c++2003std.pdf\" rel=\"nofollow\">14882-2003</a>)</h3>\n<blockquote>\n<p id=\"so_24158887_24159201_0\"><code>14.6.2.2p1</code> <strong>Dependent types</strong> <code>[temp.dep.type]</code></p>\n<blockquote>\n<p id=\"so_24158887_24159201_5\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_24158887_24159201_6\">a template parameter,</p></li>\n<li><p id=\"so_24158887_24159201_7\">a <em>qualified-id</em> with a <em>nested-name-specifier</em> which contains a <em>class-names</em> that names a dependent type or whose <em>unqualified-id</em> names a dependent type,</p></li>\n<li><p id=\"so_24158887_24159201_8\">...</p></li>\n</ul>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_24158887_24159201_9\"><code>14.6.2.4p1</code> <strong>Dependent template arguments</strong> <code>[temp.dep.temp]</code></p>\n<blockquote>\n<p id=\"so_24158887_24159201_11\">A type <em>template-argument</em> is dependent if the type it specifies is dependent.</p>\n</blockquote>\n</blockquote>\n</hr>", "LastActivityDate": "2014-06-11T09:28:59.083"}, "24158887": {"CommentCount": "5", "ViewCount": "70", "PostTypeId": "1", "ClosedDate": "2014-06-11T10:36:08.240", "LastEditorUserId": "1090079", "CreationDate": "2014-06-11T09:09:11.467", "LastActivityDate": "2014-06-11T09:30:05.760", "Title": "Is it required to qualify a dependent name with typename if it is used as a template argument?", "AcceptedAnswerId": "24159201", "LastEditDate": "2014-06-11T09:30:05.760", "Id": "24158887", "Score": "2", "Body": "<pre><code>template&lt;class mapT, class K, class V&gt;\nvoid f(mapT&amp; m, const K&amp; k, const V&amp; v)\n{\n    pair&lt;mapT::iterator, bool&gt; p = m.insert(make_pair(k, v));\n}\n</code></pre>\n<p>MSVC accepts this code with no errors or warnings. What does the standard have to say about this? Are we allowed to (optional), not allowed to (forbidden), or required to (mandatory) qualify T::iterator with typename in the example above? I am particularly interested in C++03 rules although if anything has changed for 11 it would be nice to know. Thank you.</p>\n", "Tags": "<c++><templates><language-lawyer><c++03><dependent-name>", "OwnerUserId": "469935", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24158887_24159201_10": {"section_id": 210, "quality": 1.0, "length": 6}, "so_24158887_24159201_11": {"section_id": 210, "quality": 1.0, "length": 6}}, "n3337": {"so_24158887_24159201_10": {"section_id": 204, "quality": 1.0, "length": 6}, "so_24158887_24159201_11": {"section_id": 204, "quality": 1.0, "length": 6}}, "n4659": {"so_24158887_24159201_10": {"section_id": 218, "quality": 1.0, "length": 6}, "so_24158887_24159201_11": {"section_id": 218, "quality": 1.0, "length": 6}}}});