post_cb({"48233875": {"ParentId": "48233615", "LastActivityDate": "2018-01-12T21:04:21.533", "OwnerUserId": "5245033", "Id": "48233875", "CreationDate": "2018-01-12T20:53:52.553", "LastEditorUserId": "5245033", "Body": "<p>I believe it is correct, because the point of SFINAE usage there is to make sure constructor is only available when elements are default-constructible, and not to allow selection of different overloads of said constructor.</p>\n<p>By definition, there is only one version of constructor (or any other function for that matter) which accepts 0 arguments, so overload resolution is not a problem here.</p>\n", "LastEditDate": "2018-01-12T21:04:21.533", "PostTypeId": "2", "CommentCount": "0", "Score": "0"}, "48233615": {"Tags": "<c++><templates><stl>", "ViewCount": "74", "AnswerCount": "3", "CreationDate": "2018-01-12T20:32:08.723", "Title": "MSVC std::pair implementation: is SFINAE applied correctly here?", "CommentCount": "1", "AcceptedAnswerId": "48233782", "Score": "4", "OwnerUserId": "5507349", "Id": "48233615", "LastActivityDate": "2018-01-12T21:04:21.533", "Body": "<p>Consider the following code of <code>std::pair</code> default constructor from the <em>STL</em> implementation shipped with <em>Microsoft Visual Studio 15.4.5</em>:</p>\n<pre><code>template&lt;class _Uty1 = _Ty1,\n    class _Uty2 = _Ty2,\n    class = enable_if_t&lt;is_default_constructible&lt;_Uty1&gt;::value\n                    &amp;&amp; is_default_constructible&lt;_Uty2&gt;::value&gt;&gt;\n    constexpr pair()\n    : first(), second()\n    {   // default construct\n    }\n</code></pre>\n<p>I set <code>/std:c++latest</code> option, so, according to the standard (I use the draft <em>n4659</em> here) I expect that this constructor will be excluded from the overload resolution if either <code>_Ty1</code> or <code>_Ty1</code> is not default constructible:</p>\n<blockquote>\n<p id=\"so_48233615_48233615_0\">23.4.2 Class template pair [pairs.pair]</p>\n<p id=\"so_48233615_48233615_1\">EXPLICIT constexpr pair();</p>\n<p id=\"so_48233615_48233615_2\">Effects: Value-initializes first and second.</p>\n<p id=\"so_48233615_48233615_3\">Remarks: This constructor shall not participate in overload resolution\n  unless <code>is_default_constructible_v&lt;first_type&gt;</code> is true and\n  <code>is_default_constructible_v&lt;second_type&gt;</code> is true. [ Note: This behavior\n  can be implemented by a constructor template with default template\n  arguments.]</p>\n</blockquote>\n<p>In the implementation above the exclusion is performed as follows:</p>\n<pre><code>class = enable_if_t&lt;is_default_constructible&lt;_Uty1&gt;::value\n                    &amp;&amp; is_default_constructible&lt;_Uty2&gt;::value&gt;\n</code></pre>\n<p>As far as I know, <em>SFINAE</em> <a href=\"https://stackoverflow.com/questions/15427667/sfinae-working-in-return-type-but-not-as-template-parameter\">does not work</a> for template type parameters default values.</p>\n<p>Interestingly enough, in <em>Microsoft Visual Studio 15.5.3</em> the constructor has been changed to the \"right version\" (\"right\" based on my limited template knowledge):</p>\n<pre><code>template&lt;class _Uty1 = _Ty1,\n    class _Uty2 = _Ty2,\n    enable_if_t&lt;conjunction_v&lt;\n        is_default_constructible&lt;_Uty1&gt;,\n        is_default_constructible&lt;_Uty2&gt;\n    &gt;, int&gt; = 0&gt;\n    constexpr pair()\n    : first(), second()\n    {   // default construct\n    }\n</code></pre>\n<p>So I am wondering whether the first implementation is correct, and, if it is correct, what is the point of changing it to the second one.</p>\n", "PostTypeId": "1"}, "48233869": {"ParentId": "48233615", "LastActivityDate": "2018-01-12T20:53:28.323", "OwnerUserId": "1491485", "Id": "48233869", "CreationDate": "2018-01-12T20:53:28.323", "Body": "<p>I think they are both right , but second more flexible.</p>\n", "PostTypeId": "2", "CommentCount": "1", "Score": "0"}, "48233782": {"ParentId": "48233615", "LastActivityDate": "2018-01-12T20:45:48.920", "OwnerUserId": "2756719", "Id": "48233782", "CreationDate": "2018-01-12T20:45:48.920", "Body": "<p>It's not that SFINAE doesn't work inside default template arguments; it's that they do not count as part of the signature and so putting your SFINAE machinery there means that you have to make the signature different in some other way if you want to build an overload set.</p>\n<p>Thus, this is fine:</p>\n<pre><code>template&lt;class T, class=std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nT meow();\n\ntemplate&lt;class T, class=std::enable_if_t&lt;!std::is_integral_v&lt;T&gt;&gt;&gt;\nvoid meow();\n</code></pre>\n<p>because the signatures are different (return type is part of the signature of function templates - but not functions); so is this:</p>\n<pre><code>template&lt;class T, class=std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nvoid meow(T);\n\ntemplate&lt;class T, class=std::enable_if_t&lt;!std::is_integral_v&lt;T&gt;&gt;&gt;\nvoid meow(const T&amp;);\n</code></pre>\n<p>but this isn't (it redeclares the same function template and so tries to give the same template parameter a default template argument twice):</p>\n<pre><code>template&lt;class T, class=std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nvoid meow(const T&amp;);\n\ntemplate&lt;class T, class=std::enable_if_t&lt;!std::is_integral_v&lt;T&gt;&gt;&gt;\nvoid meow(const T&amp;);\n</code></pre>\n<p>With respect to that <code>pair</code> constructor template in particular, you can't really tell if it's correct without knowing what the other constructor templates are. That said, I'd be greatly surprised if they got it wrong; any problem should be easily catchable with simple unit tests.</p>\n", "PostTypeId": "2", "CommentCount": "1", "Score": "6"}, "bq_ids": {"n4659": {"so_48233615_48233615_3": {"length": 15, "section_id": 4873, "quality": 0.75}}}});