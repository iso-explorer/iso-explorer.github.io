post_cb({"bq_ids": {"n4140": {"so_46065337_46065337_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 8}, "so_46065337_46065337_2": {"length": 17, "quality": 0.7391304347826086, "section_id": 9}}, "n3337": {"so_46065337_46065337_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5}, "so_46065337_46065337_2": {"length": 16, "quality": 0.6956521739130435, "section_id": 6}}, "n4659": {"so_46065337_46065337_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 8}}}, "46065337": {"ViewCount": "139", "Body": "<p>In the C++14 standard (n3797), the section on lvalue to rvalue conversions reads as follows (emphasis mine):</p>\n<blockquote>\n<p id=\"so_46065337_46065337_0\">4.1 Lvalue-to-rvalue-conversion [conv.lval]</p>\n<ol>\n<li><p id=\"so_46065337_46065337_1\">A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If <code>T</code> is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise the type of the prvalue is <code>T</code>.</p></li>\n<li><p id=\"so_46065337_46065337_2\">When an lvalue-to-rvalue conversion occurs in an unevaluated operand\n  or a subexpression thereof (Clause 5) the value contained in the\n  referenced object is not accessed. In all other cases, the result of the \n  conversion is determined according to the following rules:</p>\n<ul>\n<li>If <code>T</code> is a (possibly cv-qualified) <code>std::nullptr_t</code> then the result is a null pointer constant.</li>\n<li>Otherwise, if <code>T</code> has class type, the conversion copy-initializes a temporary of type <code>T</code> from the glvalue and the result of the conversion is a prvalue for the temporary.</li>\n<li>Otherwise, if the object to which the glvalue refers contains an invalid pointer value, the behavior is implementation-defined.</li>\n<li><strong>Otherwise, if <code>T</code> is a (possibly cv-qualified) unsigned character type, and the object to which the glvalue refers contains an indeterminate value, and that object does not have automatic storage duration or the glvalue was the operand of a unary <code>&amp;</code> operator or it was bound to a reference, the result is an unspecified value.</strong></li>\n<li>Otherwise, if the object to which the glvalue refers has an indeterminate value, the behavior is undefined.</li>\n<li>Otherwise, the object indicated by the glvalue is the prvalue result.</li>\n</ul></li>\n<li>[<em>Note:</em> See also 3.10]</li>\n</ol>\n</blockquote>\n<p>What's the significance of this paragraph (in bold)?</p>\n<p>If this paragraph were not here, then the situations in which it applies would lead to undefined behavior. Normally, I would expect that accessing an <code>unsigned char</code> value while it has an indeterminate value leads to undefined behavior. But, with this paragraph it means that</p>\n<ul>\n<li>If I'm not actually accessing the character value, i.e. I'm immediately passing it to <code>&amp;</code> or binding it to a reference, or</li>\n<li>If the <code>unsigned char</code> does not have automatic storage duration,</li>\n</ul>\n<p>then the conversion yields an unspecified value, and not undefined behavior.</p>\n<p>Am I correct to conclude that this program:</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;iostream&gt;\n\n// using T = int;\nusing T = unsigned char;\n\nint main() {\n  T * array = new T[500];\n  for (int i = 0; i &lt; 500; ++i) {\n    std::cout &lt;&lt; static_cast&lt;int&gt;(array[i]) &lt;&lt; std::endl;\n  }\n  delete[] array;\n}\n</code></pre>\n<p>is well-defined by the standard, and must output a sequence of 500 unspecified ints, while the same program where <code>T = int</code>, would have undefined behavior?</p>\n<hr>\n<p>IIUC, one of the reasons to make it UB to read things with indeterminate values, is to allow aggressive dead store elimination by the optimizer. So, this paragraph may mean that a conforming compiler can't do as much optimization when working with <code>unsigned char</code> or arrays of <code>unsigned char</code>.</p>\n<p>Assuming I understand correctly, what is the rationale for this rule? When is it useful to be able to read <code>unsigned char</code> that have indeterminate values, and get unspecified results instead of UB? I have this feeling that if they put this much effort into crafting this part of the rule, they had some motivation to help certain code examples that they cared about, or to be consistent with some other part of the standard, or simplify some other issue. But I have no idea what that might be.</p>\n</hr>", "Title": "What is the significance of special language in standard for lvalue-to-rvalue conversions for unsigned character types of indeterminate value", "CreationDate": "2017-09-06T01:10:31.327", "LastActivityDate": "2017-09-07T21:23:34.163", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-06T01:52:04.967", "LastEditorUserId": "3598119", "Id": "46065337", "Score": "8", "OwnerUserId": "3598119", "Tags": "<c++><c++14><language-lawyer><undefined-behavior><lvalue-to-rvalue>", "AnswerCount": "1"}, "46080337": {"Id": "46080337", "PostTypeId": "2", "Body": "<p>In many situations, code will write some parts of a PODS or array without writing everything, and then use functions like <code>memcpy</code> or <code>fwrite</code> to copy or write the entire thing without regard for which parts had assigned values and which did not.  Although it is not terribly common for C++ code to use byte-based operations to copy or write out the contents of aggregates, the ability to do so is a fundamental part of the language.  Requiring that a program write definite values to all portions of an object, including those nothing will ever \"care\" about, would needlessly impair efficiency.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2017-09-07T21:23:34.163", "Score": "1", "CreationDate": "2017-09-06T16:36:07.770", "ParentId": "46065337", "CommentCount": "0", "OwnerUserId": "363751", "LastEditDate": "2017-09-07T21:23:34.163"}});