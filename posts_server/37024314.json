post_cb({"bq_ids": {"n4140": {"so_37024314_37025347_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 599}, "so_37024314_37025347_1": {"length": 21, "quality": 0.75, "section_id": 599}}, "n3337": {"so_37024314_37025347_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 589}, "so_37024314_37025347_1": {"length": 21, "quality": 0.75, "section_id": 589}}, "n4659": {"so_37024314_37025347_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 622}, "so_37024314_37025347_1": {"length": 21, "quality": 0.75, "section_id": 622}}}, "37024314": {"ViewCount": "451", "Body": "<p>The following code</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;cassert&gt;\n\n    struct       AV {\n        explicit AV(std::string const&amp;) {}\n    };\n\n#if 1\n    static void check_cache_item(\n        std::map&lt;std::string, std::string&gt; const&amp; items) // FIXME remove\n    {\n        assert(!items.empty());\n    }\n#endif\n    static void check_cache_item(\n        std::map&lt;std::string, AV&gt; const&amp; items)\n    {\n        assert(!items.empty());\n    }\n\n\nint main()\n{\n    check_cache_item({ { \"id\", \"0\" }, { \"pk\", \"#0\" } });\n    check_cache_item({ { \"id\", \"0\" }, { \"pk\", \"#1\" } });\n    check_cache_item({ { \"id\", AV{\"0\"} }, { \"pk\", AV{\"#1\"} } });\n}\n</code></pre>\n<p>is accepted by g++ 4.8.4, g++ 5.3.0, clang++ 3.9.0; but g++ 6.1.0 gives an error:</p>\n<pre><code>cci.cc: In function \u2018int main()\u2019:\ncci.cc:25:55: error: call of overloaded \u2018check_cache_item(&lt;brace-enclosed initializer list&gt;)\u2019 is ambiguous\n     check_cache_item({ { \"id\", \"0\" }, { \"pk\", \"#0\" } });\n                                                       ^\ncci.cc:10:17: note: candidate: void check_cache_item(const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt;&amp;)\n     static void check_cache_item(\n                 ^~~~~~~~~~~~~~~~\ncci.cc:16:17: note: candidate: void check_cache_item(const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, AV&gt;&amp;)\n     static void check_cache_item(\n                 ^~~~~~~~~~~~~~~~\ncci.cc:26:55: error: call of overloaded \u2018check_cache_item(&lt;brace-enclosed initializer list&gt;)\u2019 is ambiguous\n     check_cache_item({ { \"id\", \"0\" }, { \"pk\", \"#1\" } });\n                                                       ^\ncci.cc:10:17: note: candidate: void check_cache_item(const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt;&amp;)\n     static void check_cache_item(\n                 ^~~~~~~~~~~~~~~~\ncci.cc:16:17: note: candidate: void check_cache_item(const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, AV&gt;&amp;)\n     static void check_cache_item(\n                 ^~~~~~~~~~~~~~~~\ncci.cc: At global scope:\ncci.cc:10:17: warning: \u2018void check_cache_item(const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt;&amp;)\u2019 defined but not used [-Wunused-function]\n     static void check_cache_item(\n                 ^~~~~~~~~~~~~~~~\n</code></pre>\n<p>If I #ifdef out the first constructor, then every compiler throws an error (rightly, because the AV constructor is explicit).</p>\n<p>Is this a regression in G++ 6.1.0 ?</p>\n", "AcceptedAnswerId": "37025347", "Title": "Possible regression in G++ 6.1.0", "CreationDate": "2016-05-04T09:55:47.950", "Id": "37024314", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-05-09T14:14:00.790", "Score": "22", "OwnerUserId": "2064196", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "37025347": {"Id": "37025347", "PostTypeId": "2", "Body": "<p>This is a surprising and somewhat unfortunate aspect of the Standard (I would go so far as to call it a defect); it is the result of a collision between the overload resolution rules for copy-list-initialization (<strong>[over.match.list]</strong> as confirmed in <a href=\"http://wg21.cmeerw.net/cwg/issue1228\" rel=\"nofollow noreferrer\">CWG 1228</a>), and the element-forwarding constructor of <code>pair</code> (as per <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387\" rel=\"nofollow noreferrer\">n4387</a>).</p>\n<p>gcc (&gt;= 6.1.0) is correct to reject your program; clang is incorrect to accept it. Earlier versions of gcc accept your program because they had not yet implemented n4387; clang accepts your program because it <a href=\"https://llvm.org/bugs/show_bug.cgi?id=27642\" rel=\"nofollow noreferrer\">excludes explicit constructors from consideration for overload resolution for copy-list-initialization</a>, which violates <strong>[over.match.list]</strong> according to the Standard (<a href=\"https://stackoverflow.com/questions/34622076/calling-an-explicit-constructor-with-a-braced-init-list-ambiguous-or-not?rq=1\">Calling an explicit constructor with a braced-init list: ambiguous or not?</a>)</p>\n<hr>\n<p>If we peel away the extraneous aspects of your program it comes down to a simple question of overload resolution:</p>\n<pre><code>struct A { explicit A(int, int); };\nstruct B { B(int, int); };\n\nvoid f(A);\nvoid f(B);\n\nint main() { f({0, 0}); }\n</code></pre>\n<p>Here <code>A</code> is standing in for <code>pair&lt;std::string const, AV&gt;</code> and <code>B</code> is standing in for <code>pair&lt;string const, string&gt;</code>. The constructor of <code>A</code> is explicit because pace n4387 it involves the explicit constructor of <code>AV</code>; but per CWG 1228 the rules for copy-list-initialization:</p>\n<blockquote>\n<p id=\"so_37024314_37025347_0\">[...] include all constructors but state that the program is ill-formed if an explicit constructor is selected by overload resolution. [...]</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/over.match.list\" rel=\"nofollow noreferrer\"><strong>[over.match.list]</strong></a>:</p>\n<blockquote>\n<p id=\"so_37024314_37025347_1\">[...] In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed. [ <em>Note:</em> This differs from other situations ([over.match.ctor], [over.match.copy]), where only converting constructors are considered for copy-initialization. This restriction only applies if this initialization is part of the final result of overload resolution.  <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>Thus your program is correctly considered (under the Standard as it currently is) to be ambiguous.</p>\n<p>Further reading: <a href=\"https://stackoverflow.com/questions/9157041/what-could-go-wrong-if-copy-list-initialization-allowed-explicit-constructors\">What could go wrong if copy-list-initialization allowed explicit constructors?</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-09T14:14:00.790", "Score": "14", "CreationDate": "2016-05-04T10:38:44.397", "ParentId": "37024314", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T12:08:32.480"}});