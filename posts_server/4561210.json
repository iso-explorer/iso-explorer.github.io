post_cb({"4561210": {"CommentCount": "3", "ViewCount": "289", "PostTypeId": "1", "LastEditorUserId": "597607", "CreationDate": "2010-12-30T08:46:38.067", "LastActivityDate": "2011-08-21T22:44:40.173", "Title": "Are these pointer conversions using static_cast ok?", "AcceptedAnswerId": "4561509", "LastEditDate": "2011-08-21T22:44:40.173", "Id": "4561210", "Score": "1", "Body": "<p>Suppose we have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    virtual void f() { \n        std::cout &lt;&lt; \"A::f()\" &lt;&lt; std::endl;\n    }\n};\n\nstruct B: A\n{\n    void f() { \n        std::cout &lt;&lt; \"B::f()\" &lt;&lt; std::endl;\n    }\n};\n\nvoid to_A(void* voidp) {\n    A* aptr = static_cast&lt;A*&gt;(voidp);\n    aptr-&gt;f();\n}\n\nvoid to_B(void* voidp) {\n    B* bptr2 = static_cast&lt;B*&gt;(voidp);\n    bptr2-&gt;f();\n}\n\nint main() {\n    B* bptr = new B;\n    void* voidp = bptr; \n    to_A(voidp); // prints B::f()\n    to_B(voidp); // prints B::f()\n}\n</code></pre>\n<p>is this code guaranteed to <em>always</em> work as in the code comments or is it UB? AFAIK it should be ok, but I'd like to be reassured.</p>\n<p><strong>EDIT</strong><br>\nOk, so it seems there's a consensus that this code is UB, as one can only cast to the exact type. So, what if the <code>main()</code> changes to:</br></p>\n<pre><code>int main() {\n    B* bptr = new B;\n    to_A(static_cast&lt;A*&gt;(bptr)); // still prints B::f()\n    to_B(bptr); // still prints B::f()\n}\n</code></pre>\n<p>is it still UB?</p>\n", "Tags": "<c++>", "OwnerUserId": "347137", "AnswerCount": "4"}, "4561253": {"ParentId": "4561210", "CommentCount": "3", "Body": "<p>In this specific case it works, but there are other cases in which it doesn't work.</p>\n<p>The problem is the place where you cast the B-pointer to void-pointer to A-pointer.\nIn this case the pointers will all have the same value, but in the following conditions this isn't true anymore:</p>\n<ul>\n<li>the base class has no virtual methods (therefore, no vptr), but the subclass has virtual methods (I once encountered such a bug in my company's software)</li>\n<li>the subclass uses multiple inheritance</li>\n</ul>\n<p>The only safe way is to cast it exactly back to the same type as where you came from.  So if you cast a B-pointer to void-pointer, cast it back to a B-pointer, not to a pointer to another class, even if they belong to the same inheritance tree.</p>\n", "OwnerUserId": "163551", "PostTypeId": "2", "Id": "4561253", "Score": "3", "CreationDate": "2010-12-30T08:54:28.520", "LastActivityDate": "2010-12-30T08:54:28.520"}, "4561509": {"ParentId": "4561210", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your first code example invokes undefined behaviour.</p>\n<p>You can use a <code>static_cast</code> to reverse a standard conversion of pointer to object type to pointer to <code>void</code> but the result is only guaranteed if the value of the pointer to <code>void</code> being converted back to the original object type is the result of the standard conversion of a pointer to the original type to pointer to <code>void</code>.</p>\n<p>Your second code example is OK because you only reverse conversions from pointer-to-type to pointer-to-void by casting back to the original type that the conversion was made from. This is guaranteed in 5.2.9 [expr.static.cast] of the standard (C++03).</p>\n<blockquote>\n<p id=\"so_4561210_4561509_0\">... A value of type pointer to object converted to \u201cpointer to cv void\u201d and back to the original pointer type will have its original value.</p>\n</blockquote>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2010-12-30T10:42:18.667", "Id": "4561509", "Score": "3", "CreationDate": "2010-12-30T09:35:15.990", "LastActivityDate": "2010-12-30T10:42:18.667"}, "4561933": {"ParentId": "4561210", "CommentCount": "0", "Body": "<p>This is actually quite a common thing to try to do, especially in functions that require a C callback, so one has to be careful. A typical C API callback looks like:</p>\n<pre><code>void pfnCallback( void * );\n</code></pre>\n<p>In your C++ code you decide to use a base class to always handle this particular callback and we call it</p>\n<pre><code>struct BaseCallback\n{\n virtual ~BaseCallback();\n virtual call();\n};\n</code></pre>\n<p>We also write a single function that we always use for this C API:</p>\n<pre><code>void OurCallback( void * var )\n{\n   BaseCallback * ourBase = static_cast&lt; BaseCallback * &gt;)(var);\n   ourBase-&gt;call();\n}\n</code></pre>\n<p>As we are going to be casting always from void* to BaseCallback * we must be careful when we first supply the parameters the other way that we are always going to cast the BaseCallback* to void*.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "4561933", "Score": "1", "CreationDate": "2010-12-30T10:42:31.213", "LastActivityDate": "2010-12-30T10:42:31.213"}, "bq_ids": {"n4140": {"so_4561210_4561509_0": {"section_id": 6044, "quality": 0.75, "length": 12}}, "n3337": {"so_4561210_4561509_0": {"section_id": 5812, "quality": 0.75, "length": 12}}, "n4659": {"so_4561210_4561509_0": {"section_id": 7543, "quality": 0.75, "length": 12}}}, "4561231": {"ParentId": "4561210", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>I think, you're not using casting properly. I would recommend you to read first two responses from here:</p>\n<p><a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used\">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></p>\n<p>Let's first know when which cast should be used!</p>\n<hr>\n<p>EDIT:</p>\n<p>As for your question,</p>\n<blockquote>\n<p id=\"so_4561210_4561231_0\">is this code guaranteed to always work\n  as in the code comments or is it UB?\n  AFAIK it should be ok, but I'd like to\n  be reassured.</p>\n</blockquote>\n<p>If you want to pass pointer of ANY type to your <code>to_A()</code> function, then I think <code>static_cast</code> is not the one you should use. You should use <code>reinterpret_cast</code>. But if you want to pass only pointer to <code>B</code> ( or any derived class of <code>A</code>) to <code>to_A()</code> function, then it would <em>always</em> work. If by \"work\" you meant whether it will return non-null value.</p>\n<p>Similar argument for <code>to_B()</code> function. I think, passing <code>A*</code> to <code>to_B()</code> <em>might</em> fail. That means, it could simply return NULL, Or if not null, <code>A::f()</code> will be called from <code>to_B()</code>. </p>\n<p>See this interesting output: <a href=\"http://www.ideone.com/2FZzw\" rel=\"nofollow noreferrer\">http://www.ideone.com/2FZzw</a> (it prints <strong>A::f()</strong>, not <strong>B::f()</strong> !!!)</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:28.703", "Id": "4561231", "Score": "-2", "CreationDate": "2010-12-30T08:51:29.153", "LastActivityDate": "2010-12-30T09:13:20.577"}});