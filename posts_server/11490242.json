post_cb({"11490727": {"ParentId": "11490242", "CommentCount": "0", "Body": "<p>The <code>reverse_iterator</code>, just like the normal <code>iterator</code>, points to a certain position in the vector. Implementation details are irrelevant, but if you must know, they both are (in a typical implementation) just plain old pointers inside. The difference is the direction. The reverse iterator has its <code>+</code> and <code>-</code> reversed w.r.t. the regular iterator (and also <code>++</code> and <code>--</code>, <code>&gt;</code> and <code>&lt;</code> etc).</p>\n<p>This is interesting to know, but doesn't really imply an answer to the main question.</p>\n<p>If you read the language carefully, it says:</p>\n<blockquote>\n<p id=\"so_11490242_11490727_0\">Invalidates iterators <em>and references</em> at or after the point of the erase.</p>\n</blockquote>\n<p>References do not have a built-in sense of direction. Hence, the language clearly refers to the container's own sense of direction. Positions after the point of the erase are those with higher indices. Hence, the iterator's direction is irrelevant here.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "11490727", "Score": "0", "CreationDate": "2012-07-15T09:09:03.887", "LastActivityDate": "2012-07-15T09:09:03.887"}, "11490389": {"ParentId": "11490242", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From a standardese point of view (and I'll admit, I'm not an expert on the standard): From \u00a724.5.1.1:</p>\n<pre><code>namespace std {\n    template &lt;class Iterator&gt;\n    class reverse_iterator ...\n    {\n        ...\n            Iterator base() const; // explicit\n        ...\n        protected:\n            Iterator current;\n        ...\n    };\n}\n</code></pre>\n<p>And from \u00a724.5.1.3.3:</p>\n<pre><code>Iterator base() const; // explicit\n    Returns: current.\n</code></pre>\n<p>Thus it seems to me that so long as you don't erase anything in the <code>vector</code> before what one of your <code>reverse_iterator</code>s points to, said <code>reverse_iterator</code> should remain valid.</p>\n<p>Of course, given your description, there is one catch:  if you have two contiguous elements in your vector that you end up wanting to delete, the fact that you <code>vector.erase(--vector_rit.base())</code> means that you've invalidated the <code>reverse_iterator</code> \"pointing\" to the immediately preceeding element, and so your next <code>vector.erase(...)</code> is undefined behavior.  </p>\n<p>Just in case that's clear as mud, let me say that differently:</p>\n<pre><code>std::vector&lt;T&gt; v=...;\n...\n// it_1 and it_2 are contiguous\nstd::vector&lt;T&gt;::reverse_iterator it_1=v.rend();\nstd::vector&lt;T&gt;::reverse_iterator it_2=it_1;\n--it_2;\n\n// Erase everything after it_1's pointee:\n\n// convert from reverse_iterator to iterator\nstd::vector&lt;T&gt;::iterator tmp_it=it_1.base();\n\n// but that points one too far in, so decrement;\n--tmp_it;\n\n// of course, now tmp_it points at it_2's base:\nassert(tmp_it == it_2.base());\n\n// perform erasure\nv.erase(tmp_it);  // invalidates all iterators pointing at or past *tmp_it\n                  // (like, say it_2.base()...)\n\n// now delete it_2's pointee:\nstd::vector&lt;T&gt;::iterator tmp_it_2=it_2.base(); // note, invalid iterator!\n\n// undefined behavior:\n--tmp_it_2;\nv.erase(tmp_it_2);\n</code></pre>\n<hr>\n<p>In practice, I suspect that you'll run into two possible implementations: more commonly, the underlying <code>iterator</code> will be little more than a (suitably wrapped) raw pointer, and so everything will work perfectly happily.  Less commonly, the iterator might actually try to track invalidations/perform bounds checking (didn't Dinkumware STL do such things when compiled in debug mode at one point?), and just might yell at you.</p>\n</hr>", "OwnerUserId": "161144", "LastEditorUserId": "161144", "LastEditDate": "2012-07-15T08:52:19.163", "Id": "11490389", "Score": "3", "CreationDate": "2012-07-15T08:01:18.987", "LastActivityDate": "2012-07-15T08:52:19.163"}, "11490242": {"CommentCount": "5", "AcceptedAnswerId": "11490804", "PostTypeId": "1", "LastEditorUserId": "4858", "CreationDate": "2012-07-15T07:25:55.193", "LastActivityDate": "2013-11-13T20:46:08.540", "LastEditDate": "2013-11-13T20:46:08.540", "ViewCount": "6763", "FavoriteCount": "1", "Title": "vector::erase and reverse_iterator", "Id": "11490242", "Score": "5", "Body": "<p>I have a collection of elements in a std::vector that are sorted in a descending order starting from the first element. I have to use a vector because I need to have the elements in a contiguous chunk of memory. And I have a collection holding many instances of vectors with the described characteristics (always sorted in a descending order).</p>\n<p>Now, sometimes, when I find out that I have too many elements in the greater collection (the one that holds these vectors), I discard the smallest elements from these vectors some way similar to this pseudo-code: </p>\n<pre><code>grand_collection: collection that holds these vectors\nT: type argument of my vector\nC: the type that is a member of T, that participates in the &lt; comparison (this is what sorts data before they hit any of the vectors).\n\nstd::map&lt;C, std::pair&lt;T::const_reverse_iterator, std::vector&lt;T&gt;&amp;&gt;&gt; what_to_delete;\niterate(it = grand_collection.begin() -&gt; grand_collection.end())\n{\n     iterate(vect_rit = it-&gt;rbegin() -&gt; it-&gt;rend())\n     {\n         // ...\n          what_to_delete &lt;- (vect_rit-&gt;C, pair(vect_rit, *it))\n          if (what_to_delete.size() &gt; threshold)\n               what_to_delete.erase(what_to_delete.begin());\n         // ...  \n     }\n}\n</code></pre>\n<p>Now, after running this code, in <code>what_to_delete</code> I have a collection of iterators pointing to the original vectors that I want to remove from these vectors (overall smallest values). Remember, the original vectors are sorted before they hit this code, which means that for any <code>what_to_delete[0 - n]</code> there is no way that an iterator on position <code>n - m</code> would point to an element further from the beginning of the same vector than <code>n</code>, where <code>m &gt; 0</code>.</p>\n<p>When erasing elements from the original vectors, I have to convert a reverse_iterator to iterator. To do this, I rely on C++11's \u00a724.4.1/1: </p>\n<blockquote>\n<p id=\"so_11490242_11490242_0\">The relationship between reverse_iterator and iterator is\n  &amp;*(reverse_iterator(i)) == &amp;*(i- 1)</p>\n</blockquote>\n<p>Which means that to delete a <code>vect_rit</code>, I use:</p>\n<pre><code>vector.erase(--vect_rit.base());\n</code></pre>\n<p>Now, according to C++11 standard <code>\u00a723.3.6.5/3</code>:</p>\n<blockquote>\n<p id=\"so_11490242_11490242_1\">iterator erase(const_iterator position); Effects: Invalidates\n  iterators and references at or after the point of the erase.</p>\n</blockquote>\n<p>How does this work with reverse_iterators? Are reverse_iterators internally implemented with a reference to a vector's real beginning (<code>vector[0]</code>) and transforming that vect_rit to a classic iterator so then erasing would be safe? Or does reverse_iterator use rbegin() (which is <code>vector[vector.size()]</code>) as a reference point and deleting anything that is further from vector's 0-index would still invalidate my reverse iterator?</p>\n<p><strong>Edit:</strong></p>\n<p>Looks like reverse_iterator uses rbegin() as its reference point. Erasing elements the way I described was giving me errors about a non-deferenceable iterator after the first element was deleted. Whereas when storing classic iterators (converting to <code>const_iterator</code>) while inserting to <code>what_to_delete</code> worked correctly.</p>\n<p>Now, for future reference, does The Standard specify what should be treated as a reference point in case of a random-access reverse_iterator? Or this is an implementation detail?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><stl><vector><iterator>", "OwnerUserId": "2753", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11490242_11490242_1": {"section_id": 988, "quality": 0.6, "length": 6}, "so_11490242_11490727_0": {"section_id": 988, "quality": 1.0, "length": 6}}, "n3337": {"so_11490242_11490242_1": {"section_id": 973, "quality": 0.6, "length": 6}, "so_11490242_11490727_0": {"section_id": 973, "quality": 1.0, "length": 6}}, "n4659": {"so_11490242_11490242_1": {"section_id": 1051, "quality": 0.6, "length": 6}, "so_11490242_11490727_0": {"section_id": 1051, "quality": 1.0, "length": 6}}}, "11490804": {"ParentId": "11490242", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In the question you have already quoted exactly what the standard says a <code>reverse_iterator</code> is:</p>\n<blockquote>\n<p id=\"so_11490242_11490804_0\">The relationship between reverse_iterator and iterator is &amp;*(reverse_iterator(i)) == &amp;*(i- 1)</p>\n</blockquote>\n<p>Remember that a <code>reverse_iterator</code> is just an 'adaptor' on top of the underlying iterator (<code>reverse_iterator::current</code>). The 'reference point', as you put it, for a <code>reverse_iterator</code> is that wrapped iterator, <code>current</code>. All operations on the <code>reverse_iterator</code> really occur on that underlying iterator. You can obtain that iterator using the <code>reverse_iterator::base()</code> function.</p>\n<p>If you erase <code>--vect_rit.base()</code>, you are in effect erasing <code>--current</code>, so <code>current</code> will be invalidated.</p>\n<p>As a side note, the expression <code>--vect_rit.base()</code> might not always compile. If the iterator is actually just a raw pointer (as might be the case for a <code>vector</code>), then <code>vect_rit.base()</code> returns an rvalue (a prvalue in C++11 terms), so the pre-decrement operator won't work on it since that operator needs a modifiable lvalue. See \"Item 28: Understand how to use a <code>reverse_iterator</code>'s base <code>iterator</code>\" in \"Effective STL\" by Scott Meyers. (an early version of the item can be found online in \"Guideline 3\" of <a href=\"http://www.drdobbs.com/three-guidelines-for-effective-iterator/184401406\" rel=\"nofollow\">http://www.drdobbs.com/three-guidelines-for-effective-iterator/184401406</a>).</p>\n<p>You can use the even uglier expression, <code>(++vect_rit).base()</code>, to avoid that problem.  Or since you're dealing with a vector and random access iterators: <code>vect_rit.base() - 1</code></p>\n<p>Either way, <code>vect_rit</code> is invalidated by the erase because <code>vect_rit.current</code> is invalidated.</p>\n<p>However, remember that <code>vector::erase()</code> returns a valid iterator to the new location of the element that followed the one that was just erased.  You can use that to 're-synchronize' <code>vect_rit</code>:</p>\n<pre><code>vect_rit = vector_type::reverse_iterator( vector.erase(vect_rit.base() - 1));\n</code></pre>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2012-07-15T09:34:40.833", "Id": "11490804", "Score": "2", "CreationDate": "2012-07-15T09:21:56.237", "LastActivityDate": "2012-07-15T09:34:40.833"}});