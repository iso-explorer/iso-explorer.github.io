post_cb({"44815376": {"ViewCount": "110", "Body": "<p>To prevent any confusion, I very much understand the difference between arrays and pointers, the concept of decay-to-pointer, and the concept of passing an array by <em>reference</em> in C++, etc.  </p>\n<p>My question here is <em>specifically</em> about the rules used by the compiler to select a function from a set of function <em>overload</em> candidates, when one overload takes an array reference, and the other overload takes a pointer.</p>\n<p>For example, suppose we have:</p>\n<pre><code>template &lt;class T, std::size_t N&gt;\nvoid foo(const T (&amp;arr)[N])\n{\n    std::cout &lt;&lt; \"Array-reference overload!\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;class T&gt;\nvoid foo(const T* ptr)\n{\n    std::cout &lt;&lt; \"Pointer overload!\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>If we attempt to invoke function template <code>foo()</code> as follows:</p>\n<pre><code>const char arr[2] = \"A\";\nfoo(arr);\n</code></pre>\n<p>... then my expectation would be that the <strong><em>first</em></strong> overload, the one that takes an array reference, would be selected by the compiler.</p>\n<p>However, using GCC 4.9.2, if I compile the above code, I get an error:</p>\n<pre><code>test.cpp:28:9: error: call of overloaded \u2018foo(const char [2])\u2019 is ambiguous\n</code></pre>\n<p>It's unclear to me why both overloads are considered equally good candidates by the compiler here, since the first overload matches the type exactly, whereas the second overload requires an extra decay-to-pointer step.</p>\n<p>Now, I am able to get the above overload working by explicitly using <code>type_traits</code> as follows:</p>\n<pre><code>template &lt;class T, std::size_t N&gt;\nvoid foo(const T (&amp;arr)[N])\n{\n    std::cout &lt;&lt; \"Array-reference overload!\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;class T&gt;\nvoid foo(T ptr, typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type* = 0)\n{\n    std::cout &lt;&lt; \"Pointer overload!\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In this case, the program compiles and the overload that takes an array reference is selected.  However, I don't understand why this solution should be necessary.  I'd like to understand why the compiler considers a function that requires decay-to-pointer an equally likely overload candidate as the array reference, when the argument passed is very much an array.</p>\n", "AcceptedAnswerId": "44815571", "Title": "Function argument binding rules for passing an array by reference vs passing pointer", "CreationDate": "2017-06-29T02:24:46.040", "Id": "44815376", "CommentCount": "0", "LastEditDate": "2017-06-29T02:55:27.720", "PostTypeId": "1", "LastEditorUserId": "3309790", "LastActivityDate": "2017-06-29T03:08:09.823", "Score": "4", "OwnerUserId": "2923952", "Tags": "<c++><arrays><pointers><language-lawyer><decay>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44815376_44815571_1": {"length": 10, "quality": 0.625, "section_id": 619}}, "n3337": {"so_44815376_44815571_1": {"length": 10, "quality": 0.625, "section_id": 609}}, "n4659": {"so_44815376_44815571_1": {"length": 9, "quality": 0.5625, "section_id": 645}}}, "44815571": {"Id": "44815571", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44815376_44815571_0\">the first overload matches the type exactly, whereas the second overload requires an extra decay-to-pointer step.</p>\n</blockquote>\n<p>Because when checking the <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences\" rel=\"nofollow noreferrer\">ranking of implicit conversion sequences</a> in <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow noreferrer\">overload resolution</a>, the <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Array_to_pointer_conversion\" rel=\"nofollow noreferrer\">array-to-pointer conversion</a> is considered as an exact match, thus the 2nd overload has the same rank with the 1st one.</p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/over.ics.scs#tab:over.conversions\" rel=\"nofollow noreferrer\">$16.3.3.1.1 Standard conversion sequences [over.ics.scs] Table 13 \u2014 Conversions</a></p>\n<blockquote id=\"so_44815376_44815571_1\">\n<pre><code>Conversion                   Category               Rank         Subclause\nNo conversions required      Identity               Exact Match\n... ...\nArray-to-pointer conversion  Lvalue Transformation  Exact Match  [conv.array]\n... ...\n</code></pre>\n</blockquote>\n<p>It's worth noting that the rank of \"No conversions required\" (i.e. the case for the 1st overload) is \"Exact Match\" too.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-06-29T03:08:09.823", "Score": "3", "CreationDate": "2017-06-29T02:48:03.423", "ParentId": "44815376", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2017-06-29T03:08:09.823"}});