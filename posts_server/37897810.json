post_cb({"37897810": {"CommentCount": "0", "ViewCount": "566", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2016-06-18T14:01:34.310", "LastActivityDate": "2016-06-18T15:05:07.757", "Title": "Redeclaration in a namespace that does not enclose the original declaration", "AcceptedAnswerId": "37898353", "LastEditDate": "2016-06-18T15:02:08.257", "Id": "37897810", "Score": "5", "Body": "<p>Namespace member can be defined in a namespace that encloses the declaration\u2019s namespace:</p>\n<blockquote>\n<p id=\"so_37897810_37897810_0\"><strong>Members of a named namespace can also be defined outside that namespace</strong> by explicit qualification (3.4.3.2)\n  of the name being defined, provided that the entity being defined was already declared in the namespace\n  and the definition appears after the point of declaration <strong>in a namespace that encloses the declaration\u2019s\n  namespace</strong>.</p>\n</blockquote>\n<pre><code>void f();\n\nnamespace N { void ::f() {} }       // illegal for definition\n\nnamespace N { void ::f(); }         // what about redeclaration?\n</code></pre>\n<p>Class can be defined in a namespace that encloses the declaration\u2019s namespace:</p>\n<blockquote>\n<p id=\"so_37897810_37897810_1\"><strong>If a class-head-name contains a nested-name-specifier, the class-specifier shall refer to a class that was\n  previously declared</strong> directly in the class or namespace to which the nested-name-specifier refers, or in an\n  element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or introduced by\n  a using-declaration), <strong>and the class-specifier shall appear in a namespace enclosing the previous declaration</strong>.\n  In such cases, the nested-name-specifier of the class-head-name of the definition shall not begin with a\n  decltype-specifier.</p>\n</blockquote>\n<pre><code>struct A;\n\nnamespace N { struct ::A {}; }      // illegal for definition\n\nnamespace N { struct ::A; }         // what about redeclaration?\n</code></pre>\n<p>Also we have the same rule for member function definition and static data member definition.</p>\n<p>So my question is whether redeclaration (not definition) is legal in a namespace that does not enclose the original declaration?</p>\n", "Tags": "<c++><namespaces><language-lawyer><definition><redeclaration>", "OwnerUserId": "1812165", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37897810_37898353_0": {"section_id": 5442, "quality": 0.8666666666666667, "length": 13}, "so_37897810_37897810_0": {"section_id": 5484, "quality": 0.967741935483871, "length": 30}, "so_37897810_37898353_2": {"section_id": 3208, "quality": 0.8918918918918919, "length": 33}, "so_37897810_37897810_1": {"section_id": 5855, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_37897810_37898353_0": {"section_id": 5237, "quality": 0.8666666666666667, "length": 13}, "so_37897810_37897810_0": {"section_id": 5270, "quality": 0.967741935483871, "length": 30}, "so_37897810_37898353_2": {"section_id": 3082, "quality": 0.8918918918918919, "length": 33}, "so_37897810_37897810_1": {"section_id": 5625, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_37897810_37898353_0": {"section_id": 6869, "quality": 0.8666666666666667, "length": 13}, "so_37897810_37897810_0": {"section_id": 6919, "quality": 0.967741935483871, "length": 30}, "so_37897810_37897810_1": {"section_id": 7334, "quality": 0.972972972972973, "length": 36}, "so_37897810_37898353_2": {"section_id": 3965, "quality": 0.8918918918918919, "length": 33}}}, "37898353": {"ParentId": "37897810", "LastEditDate": "2016-06-18T15:05:07.757", "CommentCount": "0", "CreationDate": "2016-06-18T14:59:58.043", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "37898353", "Score": "1", "Body": "<p>Concerning <code>struct ::A;</code>, <a href=\"http://eel.is/c++draft/dcl.type.elab#1\" rel=\"nofollow\">[dcl.type.elab]/1</a> makes your declaration ill-formed:</p>\n<blockquote>\n<p id=\"so_37897810_37898353_0\">If an <em>elaborated-type-specifier</em> is the sole constituent of a\n  declaration, <strong>the declaration is ill-formed unless</strong> it is an explicit\n  specialization (14.7.3), an explicit instantiation (14.7.2) or <strong>it\n  has one of the following forms</strong>:</p>\n<p id=\"so_37897810_37898353_1\">\u2003\u2003<strong><em>class-key attribute-specifier-seq<sub>opt</sub>\n  \u2002identifier</em> <code>;</code></strong><br> \u2003\u2003<code>friend</code> <em>class-key</em>\n<code>::</code><sub>opt</sub> <em>identifier</em> <code>;</code><br> \u2003\u2003<code>friend</code>\n<em>class-key</em> <code>::</code><sub>opt</sub> <em>simple-template-id</em> <code>;</code><br> \u2003\u2003<code>friend</code> <em>class-key nested-name-specifier identifier</em>\n<code>;</code><br> \u2003\u2003<code>friend</code> <em>class-key nested-name-specifier</em>\n<code>template</code><sub>opt</sub> <em>simple-template-id</em> <code>;</code></br></br></br></br></p>\n</blockquote>\n<p>I don't see a problem in the function case; <a href=\"http://eel.is/c++draft/dcl.meaning#1\" rel=\"nofollow\">[dcl.meaning]/1</a> does permit it:</p>\n<blockquote>\n<p id=\"so_37897810_37898353_2\">When the\n  <em>declarator-id</em> is qualified, the declaration shall refer to a previously declared member of the class or namespace\n  to which the qualifier refers (or, in the case of a namespace, of an element of the inline namespace set of that namespace (7.3.1)) or to a specialization thereof; [\u2026]\n  [ <em>Note</em>: If the qualifier is the global <code>::</code> scope resolution operator, the <em>declarator-id</em> refers to a name declared\n  in the global namespace scope. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>However, both GCC and Clang insist that redeclarations, as definitions, must occur in an enclosing namespace. </p>\n", "LastActivityDate": "2016-06-18T15:05:07.757"}});