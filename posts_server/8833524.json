post_cb({"bq_ids": {"n4140": {"so_8833524_8834196_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 5313}, "so_8833524_8834196_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5313}}, "n3337": {"so_8833524_8834196_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 5110}, "so_8833524_8834196_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5110}}, "n4659": {"so_8833524_8834196_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 6737}, "so_8833524_8834196_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6737}}}, "8833524": {"ViewCount": "8921", "Body": "<p>Are the stages of compilation of a C++ program specified by the standard?</p>\n<p>If so, what are they? </p>\n<p><strong>If not, an answer for a widely-used compiler</strong> (I'd prefer MSVS) <strong>would be great.</strong></p>\n<p>I'm talking about preprocessing, tokenization, parsing and such. What is the order in which they are executed and what do they do in particular?</p>\n<p>EDIT: I know what compilation, linking and preprocessing do, I'm mostly interested in the others and the order. Explanations for these are, of course, also welcomed since I might not be the only one interested in an answer.</p>\n", "AcceptedAnswerId": "8834196", "Title": "What are the stages of compilation of a C++ program?", "CreationDate": "2012-01-12T10:29:11.850", "Id": "8833524", "CommentCount": "6", "FavoriteCount": "19", "PostTypeId": "1", "LastEditDate": "2012-09-25T08:13:21.620", "LastEditorUserId": "140719", "LastActivityDate": "2012-09-25T08:13:21.620", "Score": "20", "OwnerUserId": "673730", "Tags": "<c++><compiler-construction><compilation><c++-faq>", "AnswerCount": "3"}, "8833837": {"Id": "8833837", "PostTypeId": "2", "Body": "<p>The 9 so-called \"phases of translation\" are listed in the standard in <code>[lex.phases]</code> (2.2 in C++11, 2.1 in C++03).</p>\n<p>The detail demanded in the standard varies: preprocessing is split up into several phases, because it's important at various points in the standard exactly what has \"already been done\" and what is \"left to do\" when a particular bit of behavior is defined. So although it doesn't tell you how to write a lexer, it gives you a pretty clear roadmap.</p>\n<p>Linking on the other hand is left mostly to the implementation to decide how it's actually achieved, because the standard doesn't care <em>how</em> a given name is looked up, just what it refers to.</p>\n<p>It doesn't give any detail on parsing, either, it just says \"The resulting tokens are syntactically and semantically analyzed and translated\". That's because the whole of chapters 3-15 are required to fill in that detail.</p>\n<p>It doesn't mention internal representations during parsing/translation at all, and neither does it mention optimization phases -- they're important to the design of compilers, but they're not important to the standard. Optimization can occur in different places in different compilers. For a long time, optimization was almost entirely in the compilation phase, before emitting object files, and linkers were dumb as a post. I think now serious C++ implementations can all do at least some optimization across multiple TUs. So \"the others\" aren't just left out of the standard, they do actually change over time.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-01-12T11:04:37.710", "Score": "6", "CreationDate": "2012-01-12T10:51:41.217", "ParentId": "8833524", "CommentCount": "0", "OwnerUserId": "13005", "LastEditDate": "2012-01-12T11:04:37.710"}, "8833927": {"Id": "8833927", "PostTypeId": "2", "Body": "<p>The C++ specification is intentionally vague in many respects, mostly to remain implementation independent. A lot of the areas where the language is vague aren't a large concern anymore - for example, you can usually rely on a char being 8 bits. However, other issues such as layout of structures which use multiple inheritance is a real concern, as is the implications of virtual functions on classes. These issues impact the compatibility of code generated with different compilers. The Application Binary Interface (or ABI) of C++, isn't rigorously defined and as a result you occasionally have to dip into C where this becomes problematic. Writing a plugin interface is a good example.</p>\n<p>Similarly, the standard doesn't give a detailed description of how a compiler should be built because there are many key decisions and features that differentiate compilers. For example, MSVC can perform partial builds (allowing edit and continue), which GCC doesn't. Generally speaking though, all compilers perform similar stages: preprocessing, syntax parsing, determining program flow, producing a symbol table, and producing a linear series of instructions which can subsequently be linked to produce an executable. Oh, and linking those object files, this is usually done by a linker.</p>\n<p>I had a brief look, it's rather hard to find descriptions of individual compilers. I doubt there's much out there on commercial compilers like Microsoft's offering, purely for commercial reasons. GCC is your best bet, <a href=\"http://msdn.microsoft.com/en-us/library/bxss3ska.aspx\" rel=\"nofollow\">although Microsoft is happy to describe the process.</a> This is pretty banal stuff though: compilers all work pretty much the same way. The real gold is in how they execute these stages, the algorithms and data structures they use. In that respect, <a href=\"http://rads.stackoverflow.com/amzn/click/0534939724\" rel=\"nofollow\">I recommend this book</a>. I bought a brand new copy for a university course a few years back, and I borrowed most of my textbooks from the library :).</p>\n", "LastEditorUserId": "366904", "LastActivityDate": "2012-01-13T00:26:18.900", "Score": "3", "CreationDate": "2012-01-12T10:58:39.720", "ParentId": "8833524", "CommentCount": "0", "OwnerUserId": "1021915", "LastEditDate": "2012-01-13T00:26:18.900"}, "8834196": {"Id": "8834196", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8833524_8834196_0\">Are the stages of compilation of a C++ program specified by the standard?</p>\n</blockquote>\n<p>Yes and no.</p>\n<p>The C++ standard defines 9 \"phases of translation\".  Quoting from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">the N3242 draft</a> (10MB PDF), dated 2011-02-28 (prior to the release of the official C++11 standard), section 2.2:</p>\n<blockquote>\n<p id=\"so_8833524_8834196_1\">The precedence among the syntax rules of translation is specified by the following phases <em>[see footnote]</em>.</p>\n<ol>\n<li>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary. <em>[SNIP]</em></li>\n<li>Each instance of a backslash character (\\) immediately followed by a new-line character is deleted, splicing physical source lines to\n  form logical source lines. <em>[SNIP]</em></li>\n<li>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). <em>[SNIP]</em></li>\n<li>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. <em>[SNIP]</em></li>\n<li>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name\n  in a character literal or a non-raw string literal, is converted to\n  the corresponding member of the execution character set; <em>[SNIP]</em></li>\n<li>Adjacent string literal tokens are concatenated.</li>\n<li>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The\n  resulting tokens are syntactically and semantically analyzed and\n  translated as a translation unit. <em>[SNIP]</em></li>\n<li>Translated translation units and instantiation units are combined as follows: <em>[SNIP]</em></li>\n<li>All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the\n  current translation. All such translator output is collected into a\n  program image which contains information needed for execution in its\n  execution environment.</li>\n</ol>\n<p id=\"so_8833524_8834196_2\"><em>[footnote]</em> Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</p>\n</blockquote>\n<p>As indicated by the <em>[SNIP]</em> markers, I haven't quoted the entire section, just enough to get the idea across.</p>\n<p>To emphasize, compilers are <em>not</em> required to follow this exact model, as long as the final result is as if they did.</p>\n<p>Phases 1-6 correspond more or less to the preprocessor, 7 to what you might normally think of as compilation, 8 deals with templates, and 9 corresponds to linking.</p>\n<p>(C's translation phases are similar, but #8 is omitted.)</p>\n", "LastEditorUserId": "8747", "LastActivityDate": "2012-01-12T21:26:44.107", "Score": "33", "CreationDate": "2012-01-12T11:17:50.557", "ParentId": "8833524", "CommentCount": "3", "OwnerUserId": "827263", "LastEditDate": "2012-01-12T21:26:44.107"}});