post_cb({"10693913": {"CommentCount": "2", "AcceptedAnswerId": "10694924", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2012-05-21T23:25:19.777", "LastActivityDate": "2016-06-08T12:23:29.137", "LastEditDate": "2012-08-26T17:56:55.513", "ViewCount": "15730", "FavoriteCount": "9", "Title": "C++11 anonymous union with non-trivial members", "Id": "10693913", "Score": "24", "Body": "<p>I'm updating a struct of mine and I was wanting to add a std::string member to it.  The original struct looks like this:</p>\n<pre><code>struct Value {\n  uint64_t lastUpdated;\n\n  union {\n    uint64_t ui;\n    int64_t i;\n    float f;\n    bool b;\n  };\n};\n</code></pre>\n<p>Just adding a std::string member to the union, of course, causes a compile error, because one would normally need to add the non-trivial constructors of the object.  <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=556\">In the case of std::string (text from informit.com)</a></p>\n<blockquote>\n<p id=\"so_10693913_10693913_0\">Since std::string defines all of the six special member functions, U will have an implicitly deleted default constructor, copy constructor, copy assignment operator, move constructor, move assignment operator and destructor. Effectively, this means that you can't create instances of U unless you define some, or all of the special member functions explicitly.</p>\n</blockquote>\n<p>Then the website goes on to give the following sample code:</p>\n<pre><code>union U\n{\nint a;\nint b;\nstring s;\nU();\n~U();\n};\n</code></pre>\n<p>However, I'm using an anonymous union within a struct.  I asked ##C++ on freenode and they told me the correct way to do that was to put the constructor in the struct instead and gave me this example code:</p>\n<pre><code>#include &lt;new&gt;\n\nstruct Point  {\n    Point() {}\n    Point(int x, int y): x_(x), y_(y) {}\n    int x_, y_;\n};\n\nstruct Foo\n{\n  Foo() { new(&amp;p) Point(); }\n  union {\n    int z;\n    double w;\n    Point p;\n  };\n};\n\nint main(void)\n{\n}\n</code></pre>\n<p>But from there I can't figure how to make the rest of the special functions that std::string needs defined, and moreover, I'm not entirely clear on how the ctor in that example is working.</p>\n<p>Can I get someone to explain this to me a bit clearer?</p>\n", "Tags": "<c++><constructor><c++11><anonymous><unions>", "OwnerUserId": "483486", "AnswerCount": "2"}, "10694924": {"ParentId": "10693913", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There is no need for placement new here.</p>\n<p>Variant members won't be initialized by the compiler-generated constructor, but there should be no trouble picking one and initializing it using the normal <em>ctor-initializer-list</em>.  Members declared inside anonymous unions are actually members of the containing class, and can be initialized in the containing class's constructor.</p>\n<p>This behavior is described in section 9.5. <code>[class.union]</code>:</p>\n<blockquote>\n<p id=\"so_10693913_10694924_0\">A <em>union-like</em> class is a union or a class that has an anonymous union as a direct member.  A union-like class <code>X</code> has a set of <em>variant members</em>. If <code>X</code> is a union its variant members are the non-static data members; otherwise, its variant members are the non-static data members of all anonymous unions that are members of <code>X</code>.</p>\n</blockquote>\n<p>and in section 12.6.2 <code>[class.base.init]</code>:</p>\n<blockquote>\n<p id=\"so_10693913_10694924_1\">A <em>ctor-initializer</em> may initialize a variant member of the constructor\u2019s class. If a <em>ctor-initializer</em> specifies more than one <em>mem-initializer</em> for the same member or for the same base class, the <em>ctor-initializer</em> is ill-formed.</p>\n</blockquote>\n<p>So the code can be simply:</p>\n<pre><code>#include &lt;new&gt;\n\nstruct Point  {\n    Point() {}\n    Point(int x, int y): x_(x), y_(y) {}\n    int x_, y_;\n};\n\nstruct Foo\n{\n  Foo() : p() {} // usual everyday initialization in the ctor-initializer\n  union {\n    int z;\n    double w;\n    Point p;\n  };\n};\n\nint main(void)\n{\n}\n</code></pre>\n<p>Of course, placement new should still be used when vivifying a variant member other than the other initialized in the constructor.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "-1", "LastEditDate": "2016-05-29T15:12:35.050", "Id": "10694924", "Score": "20", "CreationDate": "2012-05-22T02:07:51.833", "LastActivityDate": "2016-05-29T15:12:35.050"}, "bq_ids": {"n4140": {"so_10693913_10694924_0": {"section_id": 5920, "quality": 0.5806451612903226, "length": 18}, "so_10693913_10693913_0": {"section_id": 5915, "quality": 0.5128205128205128, "length": 20}, "so_10693913_10694924_1": {"section_id": 432, "quality": 1.0, "length": 20}}, "n3337": {"so_10693913_10694924_0": {"section_id": 5692, "quality": 0.967741935483871, "length": 30}, "so_10693913_10693913_0": {"section_id": 5687, "quality": 0.5128205128205128, "length": 20}, "so_10693913_10694924_1": {"section_id": 424, "quality": 1.0, "length": 20}}, "n4659": {"so_10693913_10694924_0": {"section_id": 7413, "quality": 0.5483870967741935, "length": 17}, "so_10693913_10694924_1": {"section_id": 450, "quality": 1.0, "length": 20}, "so_10693913_10693913_0": {"section_id": 7407, "quality": 0.5128205128205128, "length": 20}}}, "10694818": {"ParentId": "10693913", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>That <code>new (&amp;p) Point()</code> example is a call to the Standard placement <code>new</code> operator (via a placement new expression), hence why you need to include <code>&lt;new&gt;</code>. That particular operator is special in that it does <em>not</em> allocate memory, it only returns what you passed to it (in this case it's the <code>&amp;p</code> parameter). The net result of the expression is that an object has been constructed.</p>\n<p>If you combine this syntax with explicit destructor calls then you can achieve complete control over the lifetime of an object:</p>\n<pre><code>// Let's assume storage_type is a type\n// that is appropriate for our purposes\nstorage_type storage;\n\nstd::string* p = new (&amp;storage) std::string;\n// p now points to an std::string that resides in our storage\n// it was default constructed\n\n// *p can now be used like any other string\n*p = \"foo\";\n\n// Needed to get around a quirk of the language\nusing string_type = std::string;\n\n// We now explicitly destroy it:\np-&gt;~string_type();\n// Not possible:\n// p-&gt;~std::string();\n\n// This did nothing to our storage however\n// We can even reuse it\np = new (&amp;storage) std::string(\"foo\");\n\n// Let's not forget to destroy our newest object\np-&gt;~string_type();\n</code></pre>\n<p>When and where you should construct and destroy the <code>std::string</code> member (let's call it <code>s</code>) in your <code>Value</code> class depends on your usage pattern for <code>s</code>. In this minimal example you never construct (and hence destruct) it in the special members:</p>\n<pre><code>struct Value {\n    Value() {}\n\n    Value(Value const&amp;) = delete;\n    Value&amp; operator=(Value const&amp;) = delete;\n\n    Value(Value&amp;&amp;) = delete;\n    Value&amp; operator=(Value&amp;&amp;) = delete;\n\n    ~Value() {}\n\n    uint64_t lastUpdated;\n\n    union {\n        uint64_t ui;\n        int64_t i;\n        float f;\n        bool b;\n        std::string s;\n    };\n};\n</code></pre>\n<p>The following is thus a valid use of <code>Value</code>:</p>\n<pre><code>Value v;\nnew (&amp;v.s) std::string(\"foo\");\nsomething_taking_a_string(v.s);\nusing string_type = std::string;\nv.s.~string_type();\n</code></pre>\n<p>As you may have noticed, I disabled copying and moving <code>Value</code>. The reason for that is that we can't copy or move the appropriate active member of the union without knowing which one it is that is active, if any.</p>\n", "OwnerUserId": "726300", "LastEditorUserId": "1312382", "LastEditDate": "2016-06-08T12:23:29.137", "Id": "10694818", "Score": "13", "CreationDate": "2012-05-22T01:48:44.820", "LastActivityDate": "2016-06-08T12:23:29.137"}});