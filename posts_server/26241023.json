post_cb({"bq_ids": {"n4140": {"so_26241023_26241023_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 7041}, "so_26241023_26241098_0": {"length": 55, "quality": 0.8208955223880597, "section_id": 7043}, "so_26241023_26241098_2": {"length": 6, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_26241023_26241023_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 6786}, "so_26241023_26241098_0": {"length": 55, "quality": 0.8208955223880597, "section_id": 6788}, "so_26241023_26241098_2": {"length": 6, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_26241023_26241023_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 8538}, "so_26241023_26241098_0": {"length": 55, "quality": 0.8208955223880597, "section_id": 8540}, "so_26241023_26241098_2": {"length": 6, "quality": 1.0, "section_id": 8540}}}, "26241093": {"Id": "26241093", "PostTypeId": "2", "Body": "<p>You need to finish reading that subclause. \u00a73.2 [basic.def.odr]/p6 documents the requirements for multiple definitions of inline functions with external linkage. The whole list of requirements with half a dozen items occupies a whole page, but basically boils down to \"they must have exactly the same sequence of tokens and mean exactly the same thing\". </p>\n<p>In your case the multiple definitions of <code>foo</code> don't even satisfy the first requirement - that the definitions consist of the same sequence of tokens. Undefined behavior results.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-07T16:54:51.647", "Score": "4", "CreationDate": "2014-10-07T16:45:58.963", "ParentId": "26241023", "CommentCount": "0", "LastEditDate": "2014-10-07T16:54:51.647", "OwnerUserId": "2756719"}, "26241098": {"Id": "26241098", "PostTypeId": "2", "Body": "<p>ISO C++ 2003 \u00a7 3.2 paragraph 5 says</p>\n<blockquote>\n<p id=\"so_26241023_26241098_0\">There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function\n  with external linkage (7.1.2), class template (clause 14), non-static function template (14.5.5), static data\n  member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template special-\n  ization for which some template parameters are not specified (14.7, 14.5.4) in a program provided that each\n  definition appears in a different translation unit, and provided the definitions satisfy the following require-\n  ments. Given such an entity named D defined in more than one translation unit, then</p>\n<ul>\n<li><strong>each definition of D shall consist of the same sequence of tokens</strong></li>\n<li>(more requirements follow)</li>\n</ul>\n<p id=\"so_26241023_26241098_1\">...</p>\n<p id=\"so_26241023_26241098_2\">If the definitions of D do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>So, no, non-equivalent definitions are illegal. Since the behaviour is undefined the compiler is pretty much free to do anything, including picking his favorite implementation and ignoring others.</p>\n", "LastActivityDate": "2014-10-07T16:46:33.560", "Score": "9", "CreationDate": "2014-10-07T16:46:33.560", "ParentId": "26241023", "CommentCount": "0", "OwnerUserId": "675646"}, "26244924": {"Id": "26244924", "PostTypeId": "2", "Body": "<p>There is no explicit statement in the standard that says that an inline function should have one, and only one implementation body. \nOf course, in production code, you have to make sure there's only one body .. imagine the debugging/maintenance fiasco if you have to work with code like the one you give in example !</p>\n<p>This is obviously not code you would run in production ; I hear you, you are curious about the language.</p>\n<p>Because the standard is not explicit, this leads to a gray area and compilers do whatever they want.\nActually, Stroustrup himself wrote in 1994 in \"Design &amp; Evolution of C++\" that <em>most compilers don't check for this</em> , and this situation hasn't improved to this day !</p>\n", "LastActivityDate": "2014-10-07T20:42:19.897", "Score": "-1", "CreationDate": "2014-10-07T20:42:19.897", "ParentId": "26241023", "CommentCount": "4", "OwnerUserId": "1390164"}, "26241023": {"ViewCount": "196", "Body": "<p>The C++ standard says this about ODR, as it applies to inline functions (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26241023_26241023_0\"><strong>3.2 One definition rule</strong></p>\n<p id=\"so_26241023_26241023_1\">3 Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). <strong>An inline function shall be defined in every translation unit in which it is odr-used</strong>.</p>\n</blockquote>\n<p>It doesn't say anything about whether the inline functions can have different implementations in different translation units. I tried the following:</p>\n<p><strong>test-1.cc</strong></p>\n<pre><code>#include &lt;iostream&gt; \ninline std::ostream&amp; foo(std::ostream&amp; os)\n{\n   return os &lt;&lt; \"Foo_1\";\n}\n\nvoid test_1()\n{\n   foo(std::cout) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>test-2.cc</strong></p>\n<pre><code>#include &lt;iostream&gt; \ninline std::ostream&amp; foo(std::ostream&amp; os)\n{\n   return os &lt;&lt; \"Foo_2\";\n}\n\nvoid test_2()\n{\n   foo(std::cout) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>main.cc</strong></p>\n<pre><code>extern void test_1();\nextern void test_2();\n\nint main()\n{\n   test_1();\n   test_2();\n   return 0;\n}\n</code></pre>\n<p>I was expecting to see the following output:</p>\n<pre><code>Foo_1\nFoo_2\n</code></pre>\n<p>Instead, I saw:</p>\n<pre><code>Foo_1\nFoo_1\n</code></pre>\n<p>I tested it using <code>g++ 4.7.3</code>.</p>\n<p>Is g++ correct in choosing to pick one of the inline implementations? Is it not possible to provide different implementations of inline functions in different translation units?</p>\n", "AcceptedAnswerId": "26241098", "Title": "Different implementations of inline functions in different translation units", "CreationDate": "2014-10-07T16:41:22.230", "Id": "26241023", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-07T16:50:55.700", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-07T20:42:19.897", "Score": "1", "OwnerUserId": "434551", "Tags": "<c++><inline><language-lawyer>", "AnswerCount": "3"}});