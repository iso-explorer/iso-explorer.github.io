post_cb({"16912880": {"ViewCount": "3883", "Body": "<p>I have a <code>vector&lt;unsigned char&gt;</code> and want to put a 4 byte <code>Integer</code> into the first 4 elements.\nIs there a simpler way in C++ than masking like this:</p>\n<pre><code>myVector.at(0) = myInt &amp; 0x000000FF;\nmyVector.at(1) = myInt &amp; 0x0000FF00;\nmyVector.at(2) = myInt &amp; 0x00FF0000;\nmyVector.at(3) = myInt &amp; 0xFF000000;\n</code></pre>\n", "Title": "Put a 4 Byte Integer into the first 4 char elements of vector", "CreationDate": "2013-06-04T08:17:49.750", "LastActivityDate": "2013-06-04T11:57:14.807", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "Id": "16912880", "Score": "3", "OwnerUserId": "338476", "Tags": "<c++><vector><integer><bitmask>", "AnswerCount": "5"}, "16913070": {"PostTypeId": "2", "Body": "<p>Your solution is incorrect as you currently have it. Something like:</p>\n<pre><code>std::vector&lt;unsigned char&gt; v(sizeof(int));\nint myInt = 0x12345678;\n\nfor(unsigned i = 0; i &lt; sizeof(int); ++i) {\n    v[i] = myInt &amp; 0xFF;\n    myInt &gt;&gt;= 8;\n}\n</code></pre>\n<p>Should work. It's also more portable (doesn't assume <code>int</code> is 4 bytes).</p>\n", "LastActivityDate": "2013-06-04T08:28:49.003", "Id": "16913070", "CommentCount": "0", "CreationDate": "2013-06-04T08:28:49.003", "ParentId": "16912880", "Score": "1", "OwnerUserId": "1085573"}, "16912978": {"PostTypeId": "2", "Body": "<p>You have to binary shift your values for this to work:</p>\n<pre><code>myVector.at(0) = (myInt &amp; 0xFF);\nmyVector.at(1) = (myInt &gt;&gt; 8) &amp; 0xFF;\nmyVector.at(2) = (myInt &gt;&gt; 16) &amp; 0xFF;\nmyVector.at(3) = (myInt &gt;&gt; 24) &amp; 0xFF;\n</code></pre>\n<p>Your code is wrong:</p>\n<pre><code>int myInt = 0x12345678;\nmyVector.at(0) = myInt &amp; 0x000000FF; // puts 0x78 \nmyVector.at(1) = myInt &amp; 0x0000FF00; // tries to put 0x5600 but puts 0x00\nmyVector.at(2) = myInt &amp; 0x00FF0000; // tries to put 0x340000 but puts 0x00\nmyVector.at(3) = myInt &amp; 0xFF000000; // tries to put 0x12000000 but puts 0x00\n</code></pre>\n", "LastActivityDate": "2013-06-04T08:23:35.533", "Id": "16912978", "CommentCount": "0", "CreationDate": "2013-06-04T08:23:35.533", "ParentId": "16912880", "Score": "3", "OwnerUserId": "389405"}, "bq_ids": {"n4140": {"so_16912880_16913043_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_16912880_16913043_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}}, "16913549": {"PostTypeId": "2", "Body": "<p>Here is the most compact way:</p>\n<pre><code>myVector.at(0) = *((char*)&amp;myInt+0);\nmyVector.at(1) = *((char*)&amp;myInt+1);\nmyVector.at(2) = *((char*)&amp;myInt+2);\nmyVector.at(3) = *((char*)&amp;myInt+3);\n</code></pre>\n", "LastActivityDate": "2013-06-04T08:54:07.737", "Id": "16913549", "CommentCount": "1", "CreationDate": "2013-06-04T08:54:07.737", "ParentId": "16912880", "Score": "1", "OwnerUserId": "2183287"}, "16913043": {"PostTypeId": "2", "Body": "<p>A <code>std::vector</code> is guaranteed to be stored as one contiguous block of data<sup>(&amp;ddagger;)</sup>. Hence it is possible to treat a <code>std::vector&lt;unsigned char&gt;</code> in basically the same way as an <code>unsigned char</code> buffer. This means, you can <code>memcpy</code> your data into the vector, provided you are sure it is large enough:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n  std::int32_t k = 1294323;\n  std::vector&lt;unsigned char&gt; charvec;\n\n  if (charvec.size() &lt; sizeof(k))\n    charvec.resize(sizeof(k));\n\n  std::memcpy(charvec.data(), &amp;k, sizeof(k));\n\n  return 0;\n}\n</code></pre>\n<p>Note: The <code>data()</code> function of <code>std::vector</code> returns a <code>void*</code> to the internal buffer of the vector. It is available in C++11 \u2013 in earlier versions it is possible to use the address of the first element of the vector, <code>&amp;charvec[0]</code>, instead.</p>\n<p>Of course this is a very unusual way of using a <code>std::vector</code>, and (due to the necessary <code>resize()</code>) slightly dangerous. I trust you have good reasons for wanting to do it.</p>\n<hr>\n<p><sup>(&amp;ddagger;)</sup> Or, as the Standard puts it:</p>\n<blockquote>\n<p id=\"so_16912880_16913043_0\">(\u00a723.3.6.1/1) [...] The elements of a vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity</p>\n<pre><code>       &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size().\n</code></pre>\n</blockquote>\n</hr>", "LastActivityDate": "2013-06-04T11:57:14.807", "LastEditorUserId": "701092", "Id": "16913043", "CommentCount": "1", "CreationDate": "2013-06-04T08:27:18.483", "ParentId": "16912880", "Score": "11", "OwnerUserId": "777186", "LastEditDate": "2013-06-04T11:57:14.807"}, "16913052": {"PostTypeId": "2", "Body": "<p>you can do something similar to the following:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstdio&gt;\n\nvoid\ninsert_int(std::vector&lt;unsigned char&gt;* container, int integer)\n{\n    char* chars = reinterpret_cast&lt;char*&gt;(&amp;integer);\n    container-&gt;insert(container-&gt;end(), chars, chars+sizeof(int));\n}\n\nint main(void)\n{\n    std::vector&lt;unsigned char&gt; test_vector;\n    int test_int = 0x01020304;\n\n    insert_int(&amp;test_vector, test_int);\n\n    return 0;\n}\n</code></pre>\n<p>just remember to account for endieness. My machine prints the int in reverse order.\n<code>4,3,2,1</code></p>\n", "LastActivityDate": "2013-06-04T08:34:49.763", "LastEditorUserId": "958051", "Id": "16913052", "CommentCount": "0", "CreationDate": "2013-06-04T08:27:45.320", "ParentId": "16912880", "Score": "1", "OwnerUserId": "958051", "LastEditDate": "2013-06-04T08:34:49.763"}});