post_cb({"29797882": {"ParentId": "19720064", "CommentCount": "1", "Body": "<p>It's actually interesting... I bumped into this question while using MSVC++. What I'm trying to do is:</p>\n<pre><code>static std::unordered_map&lt;Fun, std::string&gt; FunctionMap()\n{\n    static std::unordered_map&lt;Fun, std::string&gt; map;\n    return map;\n}\n</code></pre>\n<p>with Fun a function pointer type.</p>\n<p>During compilation, I get the following error:</p>\n<pre><code>error C2338: The C++ Standard doesn't provide a hash for this type.\n....\n_Kty=int (__thiscall Testje::* )(int,int)\n</code></pre>\n<p>In a previous attempt I attempted to cast the function pointer to <code>void*</code>, which isn't allowed and doesn't compile (see: <a href=\"https://isocpp.org/wiki/faq/pointers-to-members#cant-cvt-memfnptr-to-voidptr\" rel=\"nofollow\">https://isocpp.org/wiki/faq/pointers-to-members#cant-cvt-memfnptr-to-voidptr</a> for details). The reason is that a void* is a data pointer, while a function pointer is a code pointer. </p>\n<p>My conclusion so far is that it isn't allowed and it won't compile on MSVC++. </p>\n", "OwnerUserId": "1031591", "PostTypeId": "2", "Id": "29797882", "Score": "-1", "CreationDate": "2015-04-22T12:39:47.543", "LastActivityDate": "2015-04-22T12:39:47.543"}, "19851499": {"ParentId": "19720064", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I found the following:</p>\n<blockquote>\n<h3>17.6.3.4 Hash requirements</h3>\n<p id=\"so_19720064_19851499_0\">A type H meets the Hash requirements if: </p>\n<ul>\n<li>it is a function object type (20.8)</li>\n</ul>\n<p id=\"so_19720064_19851499_1\">[...]</p>\n</blockquote>\n<p>And then, the referenced 20.8 states:</p>\n<blockquote>\n<p id=\"so_19720064_19851499_2\">A function object type is an object type (3.9) that can be the type of\n  the postfix-expression in a function call (5.2.2, 13.3.1.1).228 A\n  function object is an object of a function object type. In the places\n  where one would expect to pass a pointer to a function to an\n  algorithmic template (Clause 25), the interface is specified to accept\n  a function object. This not only makes algorithmic templates work with\n  pointers to functions, but also enables them to work with arbitrary\n  function objects.</p>\n</blockquote>\n<p>It kind of states it backwards... but the statement <em>not only makes algorithmic templates work with pointers to functions...</em> seems appropriate for your question.</p>\n", "OwnerUserId": "104427", "LastEditorUserId": "104427", "LastEditDate": "2013-11-08T17:33:40.830", "Id": "19851499", "Score": "1", "CreationDate": "2013-11-08T04:17:17.380", "LastActivityDate": "2013-11-08T17:33:40.830"}, "19720201": {"ParentId": "19720064", "CommentCount": "2", "Body": "<p>Great question. I don't know the answer for sure, and I'm happy to defer to anyone with better knowledge than me, but my thinking is that even though function pointers aren't the same as data pointers, they are pointers nonetheless: so the <code>std::hash&lt;T*&gt;</code> partial specialisation should be applied.</p>\n<p>For what it's worth, the following compiles without warnings even with <code>-pendantic</code> in g++ 4.8.1 and clang 3.3, and works as expected:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nvoid func1(int) {}\nvoid func2(int) {}\n\nint main()\n{\n    typedef void (*func_type) (int);\n\n    std::hash&lt;func_type&gt; hash;\n\n    std::cout &lt;&lt; hash(func1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; hash(func2) &lt;&lt; std::endl;\n\n}\n</code></pre>\n<p>I'd be really interested if anyone has any references to the standard to back this up though.</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "19720201", "Score": "11", "CreationDate": "2013-11-01T03:14:50.817", "LastActivityDate": "2013-11-01T03:14:50.817"}, "bq_ids": {"n4140": {"so_19720064_19851499_2": {"section_id": 4548, "quality": 0.9183673469387755, "length": 45}, "so_19720064_19851499_0": {"section_id": 755, "quality": 1.0, "length": 4}}, "n3337": {"so_19720064_19851499_2": {"section_id": 4378, "quality": 0.9183673469387755, "length": 45}, "so_19720064_19851499_0": {"section_id": 743, "quality": 1.0, "length": 4}}, "n4659": {"so_19720064_19851499_2": {"section_id": 5922, "quality": 0.9183673469387755, "length": 45}, "so_19720064_19851499_0": {"section_id": 815, "quality": 1.0, "length": 4}}}, "19720064": {"CommentCount": "7", "ViewCount": "2112", "PostTypeId": "1", "LastEditorUserId": "134841", "CreationDate": "2013-11-01T02:54:09.507", "LastActivityDate": "2015-04-30T13:50:17.870", "Title": "Can std::hash be used to hash function pointers?", "FavoriteCount": "2", "LastEditDate": "2015-04-30T13:50:17.870", "Id": "19720064", "Score": "20", "Body": "<p>Can the C++11 <code>std::hash</code> type be used to hash function pointers? There is a <code>hash</code> partial specialization defined as</p>\n<pre><code>template &lt;typename T&gt; struct hash&lt;T*&gt;;\n</code></pre>\n<p>but since function pointers are different from other pointer types in C++ (e.g. they can't be cast to <code>void*</code>), I'm not sure whether it is safe to use it for types like <code>int(*)()</code> or <code>void(*)(int, int)</code>.</p>\n<p>Is this permitted? Is there any specific wording in the new ISO spec that supports or refutes this?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><pointers><c++11><hash><stdhash>", "OwnerUserId": "501557", "AnswerCount": "3"}});