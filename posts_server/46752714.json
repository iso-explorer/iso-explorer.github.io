post_cb({"46763686": {"ParentId": "46752714", "CommentCount": "5", "Body": "<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4340.html\" rel=\"nofollow noreferrer\">N4340</a>:</p>\n<blockquote>\n<p id=\"so_46752714_46763686_0\">A storage-class-specifier othe than thread_local shall not be\n  specified in an explicit specialization (14.7.3) or an explicit\n  instantiation (14.7.2) directive.</p>\n</blockquote>\n<p>So, This happens with the <code>extern</code> specifier. Just remove any storage specifier on the specialization.In your code remove <code>extern</code> specifier. Such as :</p>\n<pre><code>template&lt;&gt; \nint constexpr i&lt;0&gt; = 42;\n</code></pre>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "46763686", "Score": "0", "CreationDate": "2017-10-16T05:50:09.613", "LastActivityDate": "2017-10-16T05:50:09.613"}, "46753679": {"ParentId": "46752714", "PostTypeId": "2", "CommentCount": "18", "Body": "<blockquote>\n<p id=\"so_46752714_46753679_0\">The primary variable template must be declared extern since it is const and I don't want initializers in the header file (just like with ordinary \"extern int const i;\"). Instead I want specialization definitions in some source file.</p>\n</blockquote>\n<p>the solution should be to drop the 'extern' in the specialization.</p>\n<p>because</p>\n<blockquote>\n<p id=\"so_46752714_46753679_1\">[declarations/specifiers-7.1.1]A storage-class-specifier shall not be specified in an explicit specialization</p>\n</blockquote>\n<p>the rationale being that all specializations should have the same linkage ( see for example <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#605\" rel=\"nofollow noreferrer\">defect report 605</a>). So, it seems clang's wrong here.</p>\n<p>Anyway, given that compilers turn out behaving wildly on this, a workaround could be something like</p>\n<pre><code>// i.h\ntemplate&lt;int I&gt; struct i_impl{ static const int value; };\ntemplate&lt;int I&gt; int const i = i_impl&lt;I&gt;::value;\n\n// i.cpp\n#include &lt;i.h&gt;\ntemplate&lt;&gt; const int i_impl&lt;0&gt;::value = 42;\n</code></pre>\n", "OwnerUserId": "8631381", "LastEditorUserId": "8631381", "LastEditDate": "2017-10-16T12:25:47.653", "Id": "46753679", "Score": "1", "CreationDate": "2017-10-15T09:43:03.637", "LastActivityDate": "2017-10-16T12:25:47.653"}, "bq_ids": {"n4140": {"so_46752714_46753679_1": {"section_id": 5391, "quality": 0.8, "length": 4}, "so_46752714_46763686_0": {"section_id": 5391, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_46752714_46753679_1": {"section_id": 5185, "quality": 0.8, "length": 4}, "so_46752714_46763686_0": {"section_id": 5185, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_46752714_46753679_1": {"section_id": 6817, "quality": 0.8, "length": 4}, "so_46752714_46763686_0": {"section_id": 6817, "quality": 0.75, "length": 9}}}, "46752714": {"CommentCount": "7", "ViewCount": "196", "CreationDate": "2017-10-15T07:26:53.320", "LastActivityDate": "2017-10-20T07:58:16.680", "Title": "erroneous explicit template specialization of variable template in gcc", "FavoriteCount": "0", "PostTypeId": "1", "Id": "46752714", "Score": "5", "Body": "<p>// i.h</p>\n<pre><code>template&lt;int&gt; extern int const i;\n</code></pre>\n<p>// i.cpp</p>\n<pre><code>#include \"i.h\"\ntemplate&lt;&gt; extern int constexpr i&lt;0&gt; = 42;\n</code></pre>\n<p>// main.cpp</p>\n<pre><code>#include \"i.h\"\nint main()\n{\n  return i&lt;0&gt;;\n}\n</code></pre>\n<p>In C++14/17 mode this returns 42 with clang, but is an error with gcc: \"explicit template specialization cannot have a storage class\".</p>\n<p>Is this a bug in gcc?</p>\n", "Tags": "<c++><gcc><clang><c++14><c++1z>", "OwnerUserId": "8731417", "AnswerCount": "3"}, "46844684": {"ParentId": "46752714", "CommentCount": "0", "Body": "<p>There is a rather simple solution to this whole issue. Please additionally see <a href=\"https://groups.google.com/a/isocpp.org/forum/embed/?place=forum%2Fstd-discussion&amp;showsearch=true&amp;showpopout=true&amp;parenturl=https%3A%2F%2Fisocpp.org%2Fforums%2Fiso-c-standard-discussion#!topic/std-discussion/RBTtlBjxxgU\" rel=\"nofollow noreferrer\">this</a> post on the ISO C++ Standard - Discussion forum and the reply from Richard Smith.</p>\n<p>1.\n<code>extern</code> must not be specified in an explicit specialization</p>\n<p>So to answer the original question: <strong>no, it is not a bug in gcc</strong>, it is correct to report an error (as Massimiliano Janes already answered).</p>\n<p>In contrast <strong>clang actually has a bug here</strong> (as Massimiliano Janes already guessed) because <code>extern</code> is accepted. Maybe clang accepts it silently because it is the same as that of the primary template.</p>\n<p>2.\nTheoretically (according to the standard) the solution is to drop <code>extern</code> because with templates linkage is by name and so the specialization 'inherits' the linkage of the primary template (again see Massimiliano Janes' answer)</p>\n<p>But in practice <strong>it does not work because both compilers are incorrect</strong> here and the explicit specialization incorrectly has internal linkage instead of the linkage of the primary template which is external.</p>\n<p>3.\nIn summary:</p>\n<p>gcc never compiles which is correct in (1) but incorrect in (2).\nclang compiles in (1) which is incorrect but does not compile in (2) which is also incorrect.</p>\n<p>I'll file a bug report for clang. If someone is interested please feel free to file a bug for gcc. I won't do this because (unfortunately) I can't use gcc in my development environment Visual Studio.</p>\n", "OwnerUserId": "8731417", "PostTypeId": "2", "Id": "46844684", "Score": "2", "CreationDate": "2017-10-20T07:58:16.680", "LastActivityDate": "2017-10-20T07:58:16.680"}});