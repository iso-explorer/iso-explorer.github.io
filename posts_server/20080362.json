post_cb({"20080517": {"ParentId": "20080362", "CommentCount": "0", "Body": "<p>The standard (\u00a71.9/8) requires that:</p>\n<blockquote>\n<p id=\"so_20080362_20080517_0\">The least requirements on a conforming implementation are:<br>\n  \u2014 Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</br></p>\n</blockquote>\n<p>\"Access\" is defined as either reading or writing, so yes, your <code>*vaddr = *vaddr;</code> must read a value from <code>*vaddr</code>, and then write the same value back to <code>*vaddr</code>.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "20080517", "Score": "1", "CreationDate": "2013-11-19T19:37:29.360", "LastActivityDate": "2013-11-19T19:37:29.360"}, "20080362": {"CommentCount": "4", "ViewCount": "683", "CreationDate": "2013-11-19T19:29:12.153", "LastActivityDate": "2013-11-19T19:37:29.360", "Title": "Is 'volatile' sufficient to prevent C++ compilers from optimizing out a silent write?", "AcceptedAnswerId": "20080517", "PostTypeId": "1", "Id": "20080362", "Score": "4", "Body": "<p>I would like to write a function that triggers copy-on-write of a page, without having to modify any values in that page. A simple implementation:</p>\n<pre><code>void trigger_cow(char* addr){\n    *addr = *addr;\n}\n</code></pre>\n<p>doesn't work because GCC will optimize out the line. If I use volatile,</p>\n<pre><code>void trigger_cow(char* addr){\n    volatile char* vaddr = (volatile char*) addr;\n    *vaddr = *vaddr;\n}\n</code></pre>\n<p>then this works under -O3. </p>\n<p>Will this \"hack\" work under other compilers or optimization settings?</p>\n<p>The description of volatile in most sites I've seen doesn't seem to describe what happens when you write to a volatile pointer, only what happens when you read from one. Thanks!</p>\n", "Tags": "<c++><volatile>", "OwnerUserId": "1767890", "AnswerCount": "3"}, "20080387": {"ParentId": "20080362", "CommentCount": "2", "Body": "<p>That is exactly what <code>volatile</code> does... it forces reads and writes to happen exactly once each time a variable is accessed, and in the same order as the reads and writes appear in the program (they cannot be reordered).</p>\n<p>Note that the <em>processor</em> can still reorder reads and writes<sup>*</sup>, so <code>volatile</code> is not particularly useful for multithreaded programming.</p>\n<p><sup>*</sup>Except on the Itanium ABI, but that's unique.</p>\n", "OwnerUserId": "82294", "PostTypeId": "2", "Id": "20080387", "Score": "4", "CreationDate": "2013-11-19T19:30:41.583", "LastActivityDate": "2013-11-19T19:30:41.583"}, "bq_ids": {"n4140": {"so_20080362_20080517_0": {"section_id": 5804, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_20080362_20080517_0": {"section_id": 5577, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_20080362_20080517_0": {"section_id": 7262, "quality": 0.7857142857142857, "length": 11}}}, "20080430": {"ParentId": "20080362", "CommentCount": "0", "Body": "<p>Formally, any access to <code>volatile</code> variables constitutes <em>observable behavior</em> of the program. It cannot be optimized out and it cannot be reordered with regard to other elements of observable behavior.</p>\n<p>Optimizations in C++ programs are carried out under that \"as if\" rule, which basically gives the compiler permission to do anything as long as it does not change the observable behavior of the program.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "20080430", "Score": "2", "CreationDate": "2013-11-19T19:33:18.983", "LastActivityDate": "2013-11-19T19:33:18.983"}});