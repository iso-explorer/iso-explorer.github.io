post_cb({"37298580": {"ParentId": "37298365", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-05-18T11:42:27.643", "Score": "4", "LastEditorUserId": "2666289", "LastEditDate": "2016-05-18T17:01:24.423", "Id": "37298580", "OwnerUserId": "2666289", "Body": "<p>You need to construct the element in place using the constructor:</p>\n<pre><code>Foo_typedef Func::static_array[2] = { {2, 3}, {2, 3} };\n</code></pre>\n<p>With this, there are no copy or move because the two elements are constructed <em>in place</em>.</p>\n<p>The standard says (\u00a78.5.1/2 [dcl.init.aggr], emphasis is mine):</p>\n<blockquote>\n<p id=\"so_37298365_37298580_0\">When an aggregate is initialized by an initializer list, [...] the elements of the initializer list are taken as <strong>initializers for the members of the aggregate</strong> [...].</p>\n</blockquote>\n<p>In your case, it means that <code>Foo_typedef(2,3)</code> will be taken as an <em>initializer</em> for your <code>Foo_typedef</code> and thus a copy will be needed. In the code I gave, <code>{2, 3}</code> will be taken as an <em>initializer</em> and the corresponding constructor will be called (no copy).</p>\n", "LastActivityDate": "2016-05-18T17:01:24.423"}, "bq_ids": {"n4140": {"so_37298365_37298580_0": {"section_id": 3299, "quality": 1.0, "length": 12}}, "n3337": {"so_37298365_37298580_0": {"section_id": 3169, "quality": 1.0, "length": 12}}, "n4659": {"so_37298365_37298580_0": {"section_id": 4065, "quality": 0.9166666666666666, "length": 11}}}, "37298365": {"CommentCount": "2", "ViewCount": "111", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-05-18T11:33:07.947", "LastActivityDate": "2016-05-18T17:01:24.423", "Title": "Initialize an array member of class when class's copy constructor is deleted", "AcceptedAnswerId": "37298580", "LastEditDate": "2017-05-23T10:28:35.743", "Id": "37298365", "Score": "0", "Body": "<p>Here is a smaller version of a use case that I am working on.</p>\n<pre><code>#include &lt;mutex&gt;\ntemplate&lt;typename T = float&gt;\nclass Foo\n{\npublic:\n    Foo(int x, int y):m_mutex(){}\nprivate:\n    std::mutex  m_mutex; // This is must have in my project\n};\n\ntypedef Foo&lt;float&gt; Foo_typedef;\n\nclass Func\n{\npublic:     \n    static Foo_typedef static_array[2];\n};\n\nFoo_typedef Func::static_array[2] = { Foo_typedef(2,3), Foo_typedef(2,3) };\n\nint main()\n{   \n    return 0;\n}\n</code></pre>\n<p>After compiling this VS 2015 Update 2 emits following errors.</p>\n<pre><code>error C2280: 'Foo&lt;float&gt;::Foo(const Foo&lt;float&gt; &amp;)': attempting to reference a deleted function\nnote: see declaration of 'Foo&lt;float&gt;::Foo'\n</code></pre>\n<p>I looked around and I suspected that there might one of the two reasons this.</p>\n<p>1) Copy constructor member for <code>std::mutex</code> is deleted</p>\n<p>2) <a href=\"https://stackoverflow.com/questions/32784399/possible-bug-in-handling-the-default-keyword-in-vs2015-c\">This</a> which I thought might be similar to what I am seeing.</p>\n<p>Which one is it? What can I do to bypass this error thrown by VS 2015 Update 2 compiler? </p>\n<p><strong>UPDATE</strong>:Updated the constructor which takes in some parameters that are needed to be passed to <code>Foo_typedef</code>.</p>\n", "Tags": "<c++><visual-c++><visual-c++-2015>", "OwnerUserId": "1410711", "AnswerCount": "1"}});