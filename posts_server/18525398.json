post_cb({"bq_ids": {"n4140": {"so_18525398_18525472_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1396}, "so_18525398_18525472_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 1395}, "so_18525398_18525472_2": {"length": 28, "quality": 0.875, "section_id": 1396}}, "n3337": {"so_18525398_18525472_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1390}, "so_18525398_18525472_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 1389}, "so_18525398_18525472_2": {"length": 28, "quality": 0.875, "section_id": 1390}}, "n4659": {"so_18525398_18525472_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 1514}, "so_18525398_18525472_0": {"length": 23, "quality": 0.7666666666666667, "section_id": 1513}, "so_18525398_18525472_2": {"length": 28, "quality": 0.875, "section_id": 1514}}}, "18525472": {"Id": "18525472", "PostTypeId": "2", "Body": "<p>Your comparison function must provide a <a href=\"http://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings\" rel=\"noreferrer\">strict-weak ordering</a>.  If it does not, then your call to sort exhibits undefined behavior.</p>\n<p>25.4/3 &amp; 4</p>\n<blockquote>\n<p id=\"so_18525398_18525472_0\">3) For all algorithms that take Compare, there is a version that uses\n  operator&lt; instead. That is, comp(*i,*j) != false defaults to *i &lt; *j\n  != false. For algorithms other than those described in 25.4.3 to work\n  correctly, comp has to induce a strict weak ordering on the values.</p>\n<p id=\"so_18525398_18525472_1\">4) The term strict refers to the requirement of an irreflexive\n  relation (!comp(x, x) for all x), and the term weak to requirements\n  that are not as strong as those for a total ordering, but stronger\n  than those for a partial ordering. If we define equiv(a, b) as\n  !comp(a, b) &amp;&amp; !comp(b, a), then the requirements are that comp and\n  equiv both be transitive relations:</p>\n<blockquote id=\"so_18525398_18525472_2\">\n<pre><code>\u2014 comp(a, b) &amp;&amp; comp(b, c) implies comp(a, c)\n\u2014 equiv(a, b) &amp;&amp; equiv(b, c) implies equiv(a, c) [ Note: Under these conditions,\n  it can be shown that\n    \u2014 equiv is an equivalence relation\n    \u2014 comp induces a well-defined relation on the equivalence classes determined\n      by equiv\n    \u2014 The induced relation is a strict total ordering. \u2014end note ]\n</code></pre>\n</blockquote>\n</blockquote>\n", "LastEditorUserId": "440119", "LastActivityDate": "2013-08-30T05:36:11.453", "Score": "6", "CreationDate": "2013-08-30T05:17:41.080", "ParentId": "18525398", "CommentCount": "4", "OwnerUserId": "440119", "LastEditDate": "2013-08-30T05:36:11.453"}, "18525468": {"Id": "18525468", "PostTypeId": "2", "Body": "<p>It likely crashes because a comparison function for sort must follow a <a href=\"http://en.wikipedia.org/wiki/Weak_ordering\" rel=\"noreferrer\">strict weak ordering</a>. Your comparison fails on just about all accounts:</p>\n<blockquote>\n<p id=\"so_18525398_18525468_0\">For all x, it is not the case that x &lt; x</p>\n</blockquote>\n<p>This will obviously fail.</p>\n<blockquote>\n<p id=\"so_18525398_18525468_1\">For all x, y, if x &lt; y then it is not the case that y &lt; x</p>\n</blockquote>\n<p><code>compare_4sum(x, y)</code> will be <code>true</code>, as will <code>compare_4sum(y, x)</code>, hence breaking this.</p>\n<p>And so on down the list. You must be very careful when writing predicates for use in <code>std::sort</code> that they do not break this contract, otherwise you're likely to get crashes.</p>\n<p>Also, any comparison function should never modify the values it operates on, hence you should always be passing by <code>const &amp;</code>, not <code>&amp;</code>.</p>\n", "LastActivityDate": "2013-08-30T05:17:34.100", "CommentCount": "1", "CreationDate": "2013-08-30T05:17:34.100", "ParentId": "18525398", "Score": "6", "OwnerUserId": "1085573"}, "18525398": {"ViewCount": "142", "Body": "<p>I wrote a compare() function to sort <code>vector&lt; vector &lt; int &gt; &gt;</code> and it crashes.    </p>\n<p>Specifically, if I call <code>sort(u.begin(),u.end());</code> no crash happens. However if I call <code>sort(u.begin(),u.end(), compare);</code> It crashed, even if <code>compare()</code> simply returns <code>true</code> with no more code. What is wrong with my code?     </p>\n<pre><code>bool compare_4sum(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){\n    return true;\n}\n\nvoid test(){    \n    vector&lt;int&gt; x; \n    x.push_back(1);\n    x.push_back(2);\n    vector&lt;int&gt; x2;\n    x2.push_back(2);\n    x2.push_back(4);    \n    vector&lt;vector&lt;int&gt;&gt; u;    \n    u.push_back(x);\n    u.push_back(x2);\n    sort(u.begin(),u.end(), compare);\n}\n</code></pre>\n", "AcceptedAnswerId": "18525472", "Title": "how to sort vector<vector<int>>", "CreationDate": "2013-08-30T05:12:14.817", "Id": "18525398", "CommentCount": "2", "LastEditDate": "2013-08-30T05:18:32.947", "PostTypeId": "1", "LastEditorUserId": "1085573", "LastActivityDate": "2013-08-30T05:36:11.453", "Score": "0", "OwnerUserId": "389955", "Tags": "<c++><stl>", "AnswerCount": "2"}});