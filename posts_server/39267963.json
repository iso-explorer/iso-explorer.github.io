post_cb({"bq_ids": {"n4140": {"so_39267963_39273340_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_39267963_39273340_8": {"length": 12, "quality": 1.0, "section_id": 3304}, "so_39267963_39273340_3": {"length": 9, "quality": 1.0, "section_id": 3323}, "so_39267963_39273340_5": {"length": 22, "quality": 0.9565217391304348, "section_id": 3299}, "so_39267963_39273340_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 3304}}, "n3337": {"so_39267963_39273340_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_39267963_39273340_5": {"length": 22, "quality": 0.9565217391304348, "section_id": 3169}, "so_39267963_39273340_3": {"length": 9, "quality": 1.0, "section_id": 3193}, "so_39267963_39273340_8": {"length": 9, "quality": 0.75, "section_id": 3174}, "so_39267963_39273340_6": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}}, "n4659": {"so_39267963_39273340_1": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}, "so_39267963_39273340_5": {"length": 17, "quality": 0.7391304347826086, "section_id": 4065}, "so_39267963_39273340_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 4089}, "so_39267963_39273340_8": {"length": 12, "quality": 1.0, "section_id": 4070}, "so_39267963_39273340_6": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}}}, "39273340": {"Id": "39273340", "PostTypeId": "2", "Body": "<p>The preferred method should be one of:</p>\n<pre><code>structName structVar{};\nstructName structVar = {};\nauto structName = structVar{};\n</code></pre>\n<p><sub>there are subtle differences, but not for aggregates as in your example</sub></p>\n<p>This has the added advantage that it initializes <code>structVar</code> for <strong>any type</strong> of <code>structName</code> or if it cannot perform an initialization it makes the program ill-formed (the code doesn't compile) (plus it doesn't allow narrowing).</p>\n<p>In your specific example, <code>structName</code> is an agregate:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">C++14 draft standard:</a></p>\n<blockquote>\n<p id=\"so_39267963_39273340_0\">\u00a78.5.1 Aggregates [dcl.init.aggr]</p>\n<p id=\"so_39267963_39273340_1\">(1) An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3)</p>\n</blockquote>\n<p>The initialization syntax I used is called List-initialization:</p>\n<blockquote>\n<p id=\"so_39267963_39273340_2\">\u00a78.5.4 List-initialization [dcl.init.list]</p>\n<p id=\"so_39267963_39273340_3\">(1) List-initialization is\n  initialization of an object or reference from a braced-init-list.\n  [...] An initializer list may be empty. [...]</p>\n</blockquote>\n<p>For our aggregate this means:</p>\n<blockquote>\n<p id=\"so_39267963_39273340_4\">\u00a78.5.1 Aggregates [dcl.init.aggr]</p>\n<p id=\"so_39267963_39273340_5\">(2) When an aggregate is initialized by an initializer list, as\n  specified in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is copy-initialized from the\n  corresponding initializer-clause</p>\n<p id=\"so_39267963_39273340_6\">(7) If there are fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from its brace-or-equal-initializer or, if there\n  is no brace-or-equalinitializer, from an empty initializer list\n  (8.5.4).</p>\n<p id=\"so_39267963_39273340_7\">[ Example:</p>\n<pre><code>struct S { int a; const char* b; int c; int d = b[a]; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_39267963_39273340_8\">initializes ss.a with 1, ss.b with \"asdf\", ss.c with the value of an\n  expression of the form <strong>int{} (that is, 0)</strong>, and ss.d with the value\n  of ss.b[ss.a] (that is, \u2019s\u2019)</p>\n<p id=\"so_39267963_39273340_9\">[...]</p>\n<p id=\"so_39267963_39273340_10\">end example ]</p>\n</blockquote>\n<p>So all of these are valid and do the exact same thing:</p>\n<pre><code>structName structVar = {};\nstructName structVar = {0};\nstructName structVar = {0, 0};\n</code></pre>\n<p>However if there is at least one <code>initializer-clauses</code> and less than there are members in the aggregate, <code>gcc</code> and <code>clang</code> emit a warning. It might be that you intended to initialize all members, but missed some. So the empty initializer list is the safest choice.</p>\n<hr>\n<p>As a side note <code>struct</code> is not needed and universally not used in a declaration. So replace this:</p>\n<pre><code>struct structName structVar\n</code></pre>\n<p>with:</p>\n<pre><code>structName structVar\n</code></pre>\n</hr>", "LastEditorUserId": "2805305", "LastActivityDate": "2016-09-01T14:16:14.770", "Score": "1", "CreationDate": "2016-09-01T13:49:43.620", "ParentId": "39267963", "CommentCount": "0", "OwnerUserId": "2805305", "LastEditDate": "2016-09-01T14:16:14.770"}, "39267963": {"ViewCount": "109", "Body": "<p>I am using a C-style structure which does not have any constructor, like this:</p>\n<pre><code>struct structName {\n    int  mem1;\n    int  mem2;\n    char mem3;\n    char mem4;\n}\n</code></pre>\n<p>I am creating a variable of this structure and I want to initialize all members of the structure to zero.  I found the following methods.</p>\n<ol>\n<li><pre><code>struct structName structVar = {};\n</code></pre></li>\n<li><pre><code>struct structName structVar = {0};\n</code></pre></li>\n<li><pre><code>struct structName structVar = struct structName();\n</code></pre></li>\n</ol>\n<p>For the first two methods, my compiler is giving \"missing initializer for member\" warning.</p>\n<p>The third approach compiles without warnings.</p>\n<ul>\n<li>Is it a valid C++ statement?</li>\n<li>Am I missing some genuine warning/error by using method 3?</li>\n<li>Is there any better alternative method, apart from memset()?</li>\n</ul>\n", "AcceptedAnswerId": "39273340", "Title": "How to initialize structure in C++?", "CreationDate": "2016-09-01T09:38:18.760", "Id": "39267963", "CommentCount": "11", "LastEditDate": "2016-10-13T13:47:35.300", "PostTypeId": "1", "LastEditorUserId": "6284997", "LastActivityDate": "2016-10-13T13:47:35.300", "Score": "0", "OwnerUserId": "6284997", "Tags": "<c++><compiler-errors><compiler-warnings>", "AnswerCount": "1"}});