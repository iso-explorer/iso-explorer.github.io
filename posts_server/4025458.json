post_cb({"4025548": {"ParentId": "4025458", "CommentCount": "3", "CreationDate": "2010-10-26T16:05:11.700", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "4025548", "Score": "8", "Body": "<p>STL deals with strings as simply a wrapper for an array of characters therefore size() or length() on an STL string will tell you how many char or wchar_t elements it contains and not necessarily the number of printable characters it would be in a string.</p>\n", "LastActivityDate": "2010-10-26T16:05:11.700"}, "4025781": {"ParentId": "4025458", "CommentCount": "1", "CreationDate": "2010-10-26T16:33:14.703", "OwnerUserId": "8899", "PostTypeId": "2", "Id": "4025781", "Score": "4", "Body": "<p>Two things:</p>\n<ol>\n<li>There is no \"Microsoft STL implementation\". The C++ Standard Library shipped with Visual C++ is licensed from Dinkumware.</li>\n<li>The current C++ Standard knows nothing about Unicode and its encoding forms. std::wstring is merely a container for wchar_t units which happen to be 16-bit on Windows. In practice, if you want to store a UTF-16 encoded string into a wstring, just take into account that you are really storing code units and not code points.</li>\n</ol>\n", "LastActivityDate": "2010-10-26T16:33:14.703"}, "4032019": {"ParentId": "4025458", "PostTypeId": "2", "CommentCount": "15", "CreationDate": "2010-10-27T10:08:44.063", "Score": "14", "LastEditorUserId": "15416", "LastEditDate": "2010-11-02T08:59:15.560", "Id": "4032019", "OwnerUserId": "15416", "Body": "<p>Here's how Microsoft's STL implementation handles the variable-length encoding:</p>\n<p><code>basic_string&lt;wchar_t&gt;::operator[])(</code> can return a low or a high surrogate, in isolation.</p>\n<p><code>basic_string&lt;wchar_t&gt;::size()</code> returns the number of <code>wchar_t</code> objects. A surrogate pair (one Unicode character) uses two wchar_t's and therefore adds two to the size.</p>\n<p><code>basic_string&lt;wchar_t&gt;::resize()</code> can truncate a string in the middle of a surrogate pair.</p>\n<p><code>basic_string&lt;wchar_t&gt;::insert()</code> can insert in the middle of a surrogate pair.</p>\n<p><code>basic_string&lt;wchar_t&gt;::erase()</code> can erase either half of a surrogate pair.</p>\n<p>In general, the pattern should be clear: the STL does not assume that a <code>std::wstring</code> is in UTF-16, nor enforce that it remains UTF-16.</p>\n", "LastActivityDate": "2010-11-02T08:59:15.560"}, "4025458": {"CommentCount": "10", "AcceptedAnswerId": "4032019", "PostTypeId": "1", "LastEditorUserId": "1505120", "CreationDate": "2010-10-26T15:54:55.017", "LastActivityDate": "2014-09-24T04:04:17.987", "LastEditDate": "2014-09-24T00:59:23.623", "ViewCount": "698", "FavoriteCount": "2", "Title": "How does Microsoft handle the fact that UTF-16 is a variable length encoding in their C++ standard library implementation", "Id": "4025458", "Score": "10", "Body": "<p>Having a variable length encoding is indirectly forbidden in the standard.</p>\n<p>So I have several questions:</p>\n<p>How is the following part of the standard handled?</p>\n<blockquote>\n<p id=\"so_4025458_4025458_0\">17.3.2.1.3.3 Wide-character sequences</p>\n<p id=\"so_4025458_4025458_1\">A wide-character sequence is an array object (8.3.4) A that can be declared as T A[N], where T is type wchar_t (3.9.1), optionally qualified by any combination of const or volatile. The initial elements of the array have defined contents up to and including an element determined by some predicate. A character sequence can be designated by a pointer value S that designates its first element. </p>\n<p id=\"so_4025458_4025458_2\">The length of an NTWCS is the number of elements that precede the terminating null wide character. An empty NTWCS has a length of zero.</p>\n</blockquote>\n<p>Questions:</p>\n<p><code>basic_string&lt;wchar_t&gt;</code></p>\n<ul>\n<li>How is <code>operator[]</code> implemented and what does it return?\n<ul>\n<li>standard: <code>If pos &lt; size(), returns data()[pos]. Otherwise, if pos == size(), the const version returns charT(). Otherwise, the behavior is undefined.</code></li>\n</ul></li>\n<li>Does <code>size()</code> return the number of elements or the length of the string?\n<ul>\n<li>standard: <code>Returns: a count of the number of char-like objects currently in the string.</code></li>\n</ul></li>\n<li>How does <code>resize()</code> work?\n<ul>\n<li>unrelated to standard, just what does it do</li>\n</ul></li>\n<li>How are the position in <code>insert()</code>, <code>erase()</code> and others handled?</li>\n</ul>\n<p><code>cwctype</code></p>\n<ul>\n<li>Pretty much everything in here. How is the variable encoding handled?</li>\n</ul>\n<p><code>cwchar</code></p>\n<ul>\n<li><code>getwchar()</code> obviously can't return a whole platform-character, so how does this work?</li>\n</ul>\n<p>Plus all the rest of the character function (the theme is the same).</p>\n<p>Edit: I will be opening a bounty to get some confirmation. I want to get some clear answers or at least a clearer distribution of votes.</p>\n<p>Edit: This is starting to get pointless. This is full of totally conflicting answers. Some of you talk about external encodings (I don't care about those, UTF-8 encoded will still be stored as UTF-16 once read into the string, the same for output), the rest simply contradicts each other. :-/</p>\n", "Tags": "<c++><utf-16>", "OwnerUserId": "211659", "AnswerCount": "5"}, "26008337": {"ParentId": "4025458", "CommentCount": "0", "CreationDate": "2014-09-24T04:04:17.987", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "26008337", "Score": "0", "Body": "<p>MSVC stores <code>wchar_t</code> in <code>wstring</code>s.  These can be interpreted as unicode 16 bit words, or anything else really.</p>\n<p>If you want to get access to unicode characters or glyphs, you'll have to process said raw string by the unicode standard.  You probably also want to handle common corner cases without breaking.</p>\n<p>Here is a sketch of such a library.  It is about half as memory efficient as it could be, but it does give you in-place access to unicode glyphs in a <code>std::string</code>.  It relies on having a decent <code>array_view</code> class, but you want to write one of those anyhow:</p>\n<pre><code>struct unicode_char : array_view&lt;wchar_t const&gt; {\n  using array_view&lt;wchar_t const&gt;::array_view&lt;wchar_t const&gt;;\n\n  uint32_t value() const {\n    if (size()==1)\n      return front();\n    Assert(size()==2);\n    if (size()==2)\n    {\n      wchar_t high = front()-0xD800;\n      wchar_T low = back()-0xDC00;\n      return (uint32_t(high)&lt;&lt;10) + uint32_t(low);\n    }\n    return 0; // error\n  }\n  static bool is_high_surrogate( wchar_t c ) {\n    return (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDBFF);\n  }\n  static bool is_low_surrogate( wchar_t c ) {\n    return (c &gt;= 0xDC00 &amp;&amp; c &lt;= 0xDFFF);\n  }\n  static unicode_char extract( array_view&lt;wchar_t const&gt; raw )\n  {\n    if (raw.empty())\n      return {};\n    if (raw.size()==1)\n      return raw;\n    if (is_high_surrogate(raw.front()) &amp;&amp; is_low_surrogate(*std::next(raw.begin())))\n      return {raw.begin(), raw.begin()+2);\n    return {raw.begin(), std::next(raw.begin())};\n  }\n};\nstatic std::vector&lt;unicode_char&gt; as_unicode_chars( array_view&lt;wchar_t&gt; raw )\n{\n  std::vector&lt;unicode_char&gt; retval;\n  retval.reserve( raw.size() ); // usually 1:1\n  while(!raw.empty())\n  {\n    retval.push_back( unicode_char::extract(raw) );\n    Assert( retval.back().size() &lt;= raw.size() );\n    raw = {raw.begin() + retval.back().size(), raw.end()};\n  }\n  return retval;\n}\nstruct unicode_glyph {\n  std::array&lt; unicode_char, 3 &gt; buff;\n  std::size_t count=0;\n  unicode_char const* begin() const {\n    return buff.begin();\n  }\n  unicode_char const* end() const {\n    return buff.begin()+count;\n  }\n  std::size_t size() const { return count; }\n  bool empty() { return size()==0; }\n  unicode_char const&amp; front() const { return *begin(); }\n  unicode_char const&amp; back() const { return *std::prev(end()); }\n  array_view&lt; unicode_char const &gt; chars() const { return {begin(), end()}; }\n  array_view&lt; wchar_t const &gt; wchars() const {\n    if (empty()) return {};\n    return { front().begin(), back().end() };\n  }\n\n  void append( unicode_char next ) {\n    Assert(count&lt;3);\n    buff[count++] = next;\n  }\n  unicode_glyph() {}\n\n  static bool is_diacrit(unicode_char c) const {\n    auto v = c.value();\n    return is_diacrit(v);\n  }\n  static bool is_diacrit(uint32_t v) const {\n    return\n      ((v &gt;= 0x0300) &amp;&amp; (v &lt;= 0x0360))\n    || ((v &gt;= 0x1AB0) &amp;&amp; (v &lt;= 0x1AFF))\n    || ((v &gt;= 0x1DC0) &amp;&amp; (v &lt;= 0x1DFF))\n    || ((v &gt;= 0x20D0) &amp;&amp; (v &lt;= 0x20FF))\n    || ((v &gt;= 0xFE20) &amp;&amp; (v &lt;= 0xFE2F));\n  }\n  static size_t diacrit_count(unicode_char c) const {\n    auto v = c.value();\n    if (is_diacrit(v))\n      return 1 + ((v &gt;= 0x035C)&amp;&amp;(v&lt;=0x0362));\n    else\n      return 0;\n  }\n  static unicode_glyph extract( array_view&lt;const unicode_char&gt; raw ) {\n    unicode_glyph retval;\n    if (raw.empty())\n      return retval;\n    if (raw.size()==1)\n    {\n      retval.append(raw.front());\n      return retval;\n    }\n    retval.count = diacrit_count( *std::next(raw.begin()) )+1;\n    std::copy( raw.begin(), raw.begin()+retval.count, retval.buff.begin() );\n    return retval;\n  }\n};\nstatic std::vector&lt;unicode_glyph&gt; as_unicode_glyphs( array_view&lt;unicode_char&gt; raw )\n{\n  std::vector&lt;unicode_glyph&gt; retval;\n  retval.reserve( raw.size() ); // usually 1:1\n  while(!raw.empty())\n  {\n    retval.push_back( unicode_glyph::extract(raw) );\n    Assert( retval.back().size() &lt;= raw.size() );\n    raw = {raw.begin() + retval.back().size(), raw.end()};\n  }\n  return retval;\n}\nstatic std::vector&lt;unicode_glyph&gt; as_unicode_glyphs( array_view&lt;wchar_t&gt; raw )\n{\n  return as_unicode_glyphs( as_unicode_chars( raw ) );\n}\n</code></pre>\n<p>a smarter bit of code would generate the <code>unicode_char</code>s and <code>unicode_glyph</code>s on the fly with a factory iterator of some kind.  A more compact implementation would keep track of the fact that the end pointer of the previous and begin pointer of the next are always identical, and alias them together.  Another optimization would be to use a small object optimization on glyph based off the assumption that most glyphs are one character, and use dynamic allocation if they are two.</p>\n<p>Note that I treat CGJ as a standard diacrit, and the double-diacrits as a set of 3 characters that form one (unicode), but half-diacrits don't merge things into one glyph.  These are all questionable choices.</p>\n<p>This was written in a bout of insomnia.  Hope it at least somewhat works.</p>\n", "LastActivityDate": "2014-09-24T04:04:17.987"}, "4025562": {"ParentId": "4025458", "CommentCount": "9", "CreationDate": "2010-10-26T16:06:34.480", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "4025562", "Score": "7", "Body": "<p>Assuming that you're talking about the <code>wstring</code> type, there would be no handling of the encoding - it just deals with <code>wchar_t</code> elements without knowing anything about the encoding. It's just a sequence of <code>wchar_t</code>'s.  You'll need to deal with encoding issues using functionality of other functions.</p>\n", "LastActivityDate": "2010-10-26T16:06:34.480"}, "bq_ids": {"n4140": {"so_4025458_4025458_1": {"section_id": 6237, "quality": 0.8157894736842105, "length": 31}, "so_4025458_4025458_2": {"section_id": 6239, "quality": 0.5714285714285714, "length": 8}}, "n3337": {"so_4025458_4025458_1": {"section_id": 5997, "quality": 0.8157894736842105, "length": 31}, "so_4025458_4025458_2": {"section_id": 5999, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_4025458_4025458_1": {"section_id": 7741, "quality": 0.8157894736842105, "length": 31}, "so_4025458_4025458_2": {"section_id": 7743, "quality": 0.5714285714285714, "length": 8}}}});