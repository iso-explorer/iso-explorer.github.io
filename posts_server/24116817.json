post_cb({"24116818": {"ParentId": "24116817", "PostTypeId": "2", "CommentCount": "15", "Body": "<h2>TL;DR</h2>\n<p>Extra parentheses change the meaning of a C++ program in the following contexts:</p>\n<ul>\n<li>preventing argument-dependent name lookup</li>\n<li>enabling the comma operator in list contexts</li>\n<li>ambiguity resolution of vexing parses</li>\n<li>deducing referenceness in <code>decltype</code> expressions</li>\n<li>preventing preprocessor macro errors</li>\n</ul>\n<h2>Preventing argument-dependent name lookup</h2>\n<p>As is detailed in Annex A of the Standard, a <code>post-fix expression</code> of the form <code>(expression)</code> is a <code>primary expression</code>, but not an <code>id-expression</code>, and therefore not an <code>unqualified-id</code>. This means that argument-dependent name lookup is prevented in function calls of the form <code>(fun)(arg)</code> compared to the conventional form <code>fun(arg)</code>.</p>\n<p><strong>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116818_0\">1 When <strong>the postfix-expression in a function call (5.2.2) is an\n  unqualified-id</strong>, other namespaces not considered during the usual\n  unqualified lookup (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function or function template declarations\n  (11.3) not otherwise visible may be found. These modifications to the\n  search depend on the types of the arguments (and for template template\n  arguments, the namespace of the template argument). [ Example:</p>\n</blockquote>\n<pre><code>namespace N {\n    struct S { };\n    void f(S);\n}\n\nvoid g() {\n    N::S s;\n    f(s);   // OK: calls N::f\n    (f)(s); // error: N::f not considered; parentheses\n            // prevent argument-dependent lookup\n}\n</code></pre>\n<blockquote>\n<p id=\"so_24116817_24116818_1\">\u2014end example ]</p>\n</blockquote>\n<h2>Enabling the comma operator in list contexts</h2>\n<p>The comma operator has a special meaning in most list-like contexts (function and template arguments, initializer lists etc.). Parentheses of the form <code>a, (b, c), d</code> in such contexts can enable the comma operator compared to the regular form <code>a, b, c, d</code> where the comma operator does not apply.</p>\n<p><strong>5.18 Comma operator [expr.comma]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116818_2\">2 In contexts where comma is given a special meaning, [ Example: <strong>in\n  lists of arguments to functions (5.2.2) and lists of initializers\n  (8.5)</strong> \u2014end example ] the comma operator as described in Clause 5 can\n  appear only in parentheses. [ Example:</p>\n</blockquote>\n<pre><code>f(a, (t=3, t+2), c);\n</code></pre>\n<blockquote>\n<p id=\"so_24116817_24116818_3\">has three arguments, the second of which has the value 5. \u2014end example\n  ]</p>\n</blockquote>\n<h2>Ambiguity resolution of vexing parses</h2>\n<p>Backward compatibility with C and its arcane function declaration syntax can lead to surprising parsing ambiguities, known as vexing parses. Essentially, <strong>anything that can be parsed as a declaration will be parsed as one</strong>, even though a competing parse would also apply.</p>\n<p><strong>6.8 Ambiguity resolution [stmt.ambig]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116818_4\">1 <strong>There is an ambiguity in the grammar involving expression-statements\n  and declarations</strong>: An expression-statement with a function-style\n  explicit type conversion (5.2.3) as its leftmost subexpression can be\n  indistinguishable from a declaration where the first declarator starts\n  with a (. <strong>In those cases the statement is a declaration</strong>.</p>\n</blockquote>\n<p><strong>8.2 Ambiguity resolution [dcl.ambig.res]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116818_5\">1 <strong>The ambiguity arising from the similarity between a function-style\n  cast and a declaration mentioned in 6.8 can also occur in the context\n  of a declaration</strong>. In that context, the choice is between a function\n  declaration with a redundant set of parentheses around a parameter\n  name and an object declaration with a function-style cast as the\n  initializer. Just as for the ambiguities mentioned in 6.8, the\n  resolution is to <strong>consider any construct that could possibly be a\n  declaration a declaration</strong>. [ Note: A declaration can be explicitly\n  disambiguated by a nonfunction-style cast, by an = to indicate\n  initialization or by removing the redundant parentheses around the\n  parameter name. \u2014end note ] [ Example:</p>\n</blockquote>\n<pre><code>struct S {\n    S(int);\n};\n\nvoid foo(double a) {\n    S w(int(a));  // function declaration\n    S x(int());   // function declaration\n    S y((int)a);  // object declaration\n    S z = int(a); // object declaration\n}\n</code></pre>\n<blockquote>\n<p id=\"so_24116817_24116818_6\">\u2014end example ]</p>\n</blockquote>\n<p>A famous example of this is the <a href=\"https://stackoverflow.com/q/1424510/819272\"><strong>Most Vexing Parse</strong></a>, a name popularized by Scott Meyers in Item 6 of his <a href=\"http://rads.stackoverflow.com/amzn/click/0201749629\" rel=\"nofollow noreferrer\"><strong>Effective STL</strong></a> book:</p>\n<pre><code>ifstream dataFile(\"ints.dat\");\nlist&lt;int&gt; data(istream_iterator&lt;int&gt;(dataFile), // warning! this doesn't do\n               istream_iterator&lt;int&gt;());        // what you think it does\n</code></pre>\n<p>This declares a function, <code>data</code>, whose return type is <code>list&lt;int&gt;</code>. The\nfunction data takes two parameters:</p>\n<ul>\n<li>The first parameter is named <code>dataFile</code>. It's type is <code>istream_iterator&lt;int&gt;</code>. The\nparentheses around <code>dataFile</code> are superfluous and are ignored.</li>\n<li>The second parameter has no name. Its type is pointer to function taking\nnothing and returning an <code>istream_iterator&lt;int&gt;</code>.</li>\n</ul>\n<p>Placing extra parentheses around the first function argument (parentheses around the second argument are illegal) will resolve the ambiguity</p>\n<pre><code>list&lt;int&gt; data((istream_iterator&lt;int&gt;(dataFile)), // note new parens\n                istream_iterator&lt;int&gt;());          // around first argument\n                                                  // to list's constructor\n</code></pre>\n<p>C++11 has brace-initializer syntax that allows to side-step such parsing problems in many contexts.</p>\n<h2>Deducing referenceness in <code>decltype</code> expressions</h2>\n<p>In contrast to <code>auto</code> type deduction, <code>decltype</code> allows referenceness (lvalue and rvalue references) to be deduced. The rules distinguish between <code>decltype(e)</code> and <code>decltype((e))</code> expressions:</p>\n<p><strong>7.1.6.2 Simple type specifiers [dcl.type.simple]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116818_7\">4 For an expression <code>e</code>, <strong>the type denoted by <code>decltype(e)</code></strong> is defined as\n  follows: </p>\n<p id=\"so_24116817_24116818_8\">\u2014 if <code>e</code> is an unparenthesized id-expression or an\n  unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type\n  of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a\n  set of overloaded functions, the program is ill-formed; </p>\n<p id=\"so_24116817_24116818_9\">\u2014 otherwise,\n  if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>; </p>\n<p id=\"so_24116817_24116818_10\">\u2014\n  otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type\n  of <code>e</code>; </p>\n<p id=\"so_24116817_24116818_11\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>. </p>\n<p id=\"so_24116817_24116818_12\">The operand of the\n  decltype specifier is an unevaluated operand (Clause 5). [ Example:</p>\n</blockquote>\n<pre><code>const int&amp;&amp; foo();\nint i;\nstruct A { double x; };\nconst A* a = new A();\ndecltype(foo()) x1 = 0;   // type is const int&amp;&amp;\ndecltype(i) x2;           // type is int\ndecltype(a-&gt;x) x3;        // type is double\ndecltype((a-&gt;x)) x4 = x3; // type is const double&amp;\n</code></pre>\n<blockquote>\n<p id=\"so_24116817_24116818_13\">\u2014end example ] [ Note: The rules for determining types involving\n  <code>decltype(auto)</code> are specified in 7.1.6.4. \u2014end note ]</p>\n</blockquote>\n<p>The rules for <code>decltype(auto)</code> have a similar meaning for extra parentheses in the RHS of the initializing expression. Here's an example from the <a href=\"https://isocpp.org/wiki/faq/cpp14-language#decltype-auto\" rel=\"nofollow noreferrer\"><strong>C++FAQ</strong></a> and <a href=\"https://stackoverflow.com/q/24121708/819272\"><strong>this related Q&amp;A</strong></a></p>\n<pre><code>decltype(auto) look_up_a_string_1() { auto str = lookup1(); return str; }  //A\ndecltype(auto) look_up_a_string_2() { auto str = lookup1(); return(str); } //B\n</code></pre>\n<p>The first returns <code>string</code>, the second returns <code>string &amp;</code>, which is a reference to the local variable <code>str</code>.</p>\n<h2>Preventing preprocessor macro related errors</h2>\n<p>There is a host of subtleties with preprocessor macros in their interaction with the C++ language proper, the most common of which are listed below</p>\n<ul>\n<li>using parentheses around macro parameters inside the macro definition <code>#define TIMES(A, B) (A) * (B);</code> in order to avoid unwanted operator precedence (e.g. in <code>TIMES(1 + 2, 2 + 1)</code> which yields 9 but would yield 6 without the parentheses around <code>(A)</code> and <code>(B)</code></li>\n<li>using parentheses around macro arguments having commas inside: <code>assert((std::is_same&lt;int, int&gt;::value));</code> which would otherwise not compile</li>\n<li>using parentheses around a function to protect against macro expansion in included headers: <code>(min)(a, b)</code> (with the unwanted side effect of also disabling ADL)</li>\n</ul>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:52.840", "Id": "24116818", "Score": "91", "CreationDate": "2014-06-09T08:56:47.247", "LastActivityDate": "2014-06-10T21:43:20.607"}, "24122412": {"ParentId": "24116817", "CommentCount": "1", "Body": "<p>In general, in programming languages, \"extra\" parentheses implies that they are <em>not</em> changing the syntactical parsing order or meaning. They are being added to clarify the order (operator precedence) for the benefit of people reading the code, and their only effect would be to slightly slow the compile process, and reduce human errors in understanding the code (probably speeding up the overall development process).</p>\n<p>If a set of parentheses actually <em>changes</em> the way an expression is parsed, then they are by definition <strong>not</strong> extra. Parentheses that turn an illegal/invalid parse into a legal one are not \"extra\", although that <em>may</em> point out a poor language design.</p>\n", "OwnerUserId": "2433987", "PostTypeId": "2", "Id": "24122412", "Score": "4", "CreationDate": "2014-06-09T14:27:23.800", "LastActivityDate": "2014-06-09T14:27:23.800"}, "bq_ids": {"n4140": {"so_24116817_24116818_9": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_24116817_24116818_0": {"section_id": 7103, "quality": 0.8780487804878049, "length": 36}, "so_24116817_24116818_5": {"section_id": 3201, "quality": 0.9122807017543859, "length": 52}, "so_24116817_24116818_3": {"section_id": 6183, "quality": 0.6666666666666666, "length": 4}, "so_24116817_24116817_0": {"section_id": 5952, "quality": 0.9444444444444444, "length": 34}, "so_24116817_24116818_12": {"section_id": 5440, "quality": 0.75, "length": 6}, "so_24116817_24116818_10": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_24116817_24116818_2": {"section_id": 6183, "quality": 0.782608695652174, "length": 18}, "so_24116817_24116818_7": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}, "so_24116817_24116818_8": {"section_id": 5440, "quality": 0.9473684210526315, "length": 18}, "so_24116817_24116818_4": {"section_id": 3921, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_24116817_24116818_9": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_24116817_24116818_0": {"section_id": 6847, "quality": 0.8292682926829268, "length": 34}, "so_24116817_24116818_5": {"section_id": 3075, "quality": 0.9122807017543859, "length": 52}, "so_24116817_24116818_3": {"section_id": 5944, "quality": 0.6666666666666666, "length": 4}, "so_24116817_24116817_0": {"section_id": 5722, "quality": 0.9444444444444444, "length": 34}, "so_24116817_24116818_12": {"section_id": 5235, "quality": 0.75, "length": 6}, "so_24116817_24116818_10": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_24116817_24116818_2": {"section_id": 5944, "quality": 0.782608695652174, "length": 18}, "so_24116817_24116818_7": {"section_id": 5235, "quality": 0.7142857142857143, "length": 5}, "so_24116817_24116818_8": {"section_id": 5235, "quality": 0.9473684210526315, "length": 18}, "so_24116817_24116818_4": {"section_id": 3781, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_24116817_24116818_3": {"section_id": 7685, "quality": 0.6666666666666666, "length": 4}, "so_24116817_24116818_12": {"section_id": 6867, "quality": 0.75, "length": 6}, "so_24116817_24116818_5": {"section_id": 3962, "quality": 0.7719298245614035, "length": 44}, "so_24116817_24116818_9": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_24116817_24116817_0": {"section_id": 7438, "quality": 0.6388888888888888, "length": 23}, "so_24116817_24116818_7": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}, "so_24116817_24116818_0": {"section_id": 8604, "quality": 0.8780487804878049, "length": 36}, "so_24116817_24116818_10": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_24116817_24116818_8": {"section_id": 6867, "quality": 0.9473684210526315, "length": 18}, "so_24116817_24116818_4": {"section_id": 4807, "quality": 0.9615384615384616, "length": 25}, "so_24116817_24116818_2": {"section_id": 7685, "quality": 0.782608695652174, "length": 18}}}, "24116817": {"CommentCount": "5", "AcceptedAnswerId": "24116818", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-09T08:56:47.247", "LastActivityDate": "2014-07-11T05:35:28.980", "LastEditDate": "2017-05-23T12:17:49.537", "ViewCount": "5016", "FavoriteCount": "32", "Title": "When do extra parentheses have an effect, other than on operator precedence?", "Id": "24116817", "Score": "77", "Body": "<p>Parentheses in C++ are used in many places: e.g. in function calls and grouping expressions to override operator precedence. <strong>Apart from illegal extra parentheses</strong> (such as around function call argument lists), a general -but not absolute- rule of C++ is that <strong>extra parentheses never hurt</strong>:</p>\n<p><strong>5.1 Primary expressions [expr.prim]</strong></p>\n<p><strong>5.1.1 General [expr.prim.general]</strong></p>\n<blockquote>\n<p id=\"so_24116817_24116817_0\">6 A parenthesized expression is a primary expression whose type and\n  value are identical to those of the enclosed expression. The presence\n  of parentheses does not affect whether the expression is an lvalue.\n  The parenthesized expression can be used in exactly the same contexts\n  as those where the enclosed expression can be used, and with the same\n  meaning, <strong>except as otherwise indicated</strong>.</p>\n</blockquote>\n<p><strong>Question</strong>: in which contexts do extra parentheses change the meaning of a C++ program, other than overriding basic operator precedence?</p>\n<p><strong>NOTE</strong>: I consider the restriction of <strong>pointer-to-member</strong> syntax to <code>&amp;qualified-id</code> without parentheses to be outside the scope because it <a href=\"https://stackoverflow.com/a/7135001/819272\"><strong>restricts syntax</strong></a> rather than allowing two syntaxes with different meanings. Similarly, the use of <strong>parentheses inside preprocessor macro definitions</strong> also guards against unwanted operator precedence.</p>\n", "Tags": "<c++><c++11><language-lawyer><parentheses><c++-faq>", "OwnerUserId": "819272", "AnswerCount": "2"}});