post_cb({"24216202": {"CommentCount": "1", "ViewCount": "264", "PostTypeId": "1", "LastEditorUserId": "481267", "CreationDate": "2014-06-14T02:57:00.477", "LastActivityDate": "2014-06-14T03:23:39.593", "Title": "Initialization by null pointer constant: which behaviour is correct?", "AcceptedAnswerId": "24216284", "LastEditDate": "2014-06-14T03:03:17.207", "Id": "24216202", "Score": "6", "Body": "<pre><code>int main() {\n    const int x = 0;\n    int* y = x;   // line 3\n    int* z = x+x; // line 4\n}\n</code></pre>\n<p>Quoth the standard (C++11 \u00a74.10/1)</p>\n<blockquote>\n<p id=\"so_24216202_24216202_0\">A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type that evaluates to\n  zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; ...</p>\n</blockquote>\n<p>There are four possibilities:</p>\n<ol>\n<li><p>Line 4 is OK, but line 3 isn't. This is because <code>x</code> and <code>x+x</code> are both constant expressions that evaluate to 0, but only <code>x+x</code> is a prvalue. It appears that gcc takes this interpretation (<a href=\"http://coliru.stacked-crooked.com/a/6df2b4b41e849f14\">live demo</a>)</p></li>\n<li><p>Lines 3 and 4 are both OK. Although <code>x</code> is an lvalue, the lvalue-to-rvalue conversion is applied, giving a prvalue constant expression equal to 0. The clang on my system (clang-3.0) accepts both lines 3 and 4.</p></li>\n<li><p>Lines 3 and 4 are both not OK. clang-3.4 errors on both lines (<a href=\"http://coliru.stacked-crooked.com/a/95d790bb50e1bda4\">live demo</a>).</p></li>\n<li><p>Line 3 is OK, but line 4 isn't. (Included for the sake of completeness even though no compiler I tried exhibits this behaviour.)</p></li>\n</ol>\n<p>Who is right? Does it depend on which version of the standard we are considering?</p>\n", "Tags": "<c++><pointers><c++11><language-lawyer>", "OwnerUserId": "481267", "AnswerCount": "1"}, "24216284": {"ParentId": "24216202", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The wording in the standard changed as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#903\">DR 903</a>. The new wording is</p>\n<blockquote>\n<p id=\"so_24216202_24216284_0\">A null pointer constant is an <em>integer literal (2.14.2) with value zero</em> or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Issue 903 involves a curious corner case where it is impossible to produce the \"correct\" overload resolution in certain cases where a template parameter is a (possibly 0) integer constant.</p>\n<p>Apparently a number of possible resolutions were considered, but</p>\n<blockquote>\n<p id=\"so_24216202_24216284_1\">There was a strong consensus among the CWG that only the literal 0 should be considered a null pointer constant, not any arbitrary zero-valued constant expression as is currently specified.</p>\n</blockquote>\n<p>So, yes, it depends on whether the compiler has implemented the resolution to DR 903 or not.</p>\n", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2014-06-14T03:23:39.593", "Id": "24216284", "Score": "10", "CreationDate": "2014-06-14T03:17:32.723", "LastActivityDate": "2014-06-14T03:23:39.593"}, "bq_ids": {"n4140": {"so_24216202_24216202_0": {"section_id": 39, "quality": 0.6363636363636364, "length": 14}, "so_24216202_24216284_0": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_24216202_24216202_0": {"section_id": 36, "quality": 0.9090909090909091, "length": 20}, "so_24216202_24216284_0": {"section_id": 5947, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_24216202_24216202_0": {"section_id": 39, "quality": 0.6363636363636364, "length": 14}, "so_24216202_24216284_0": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}}});