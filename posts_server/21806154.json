post_cb({"21806154": {"CommentCount": "2", "CreationDate": "2014-02-16T01:39:19.290", "PostTypeId": "1", "AcceptedAnswerId": "21806862", "LastEditorUserId": "1708801", "LastActivityDate": "2015-09-01T19:12:28.683", "LastEditDate": "2014-02-17T00:43:15.453", "ViewCount": "550", "FavoriteCount": "1", "Title": "C++1y/C++14: Assignment to object outside its lifetime is not allowed in a constant expression?", "Id": "21806154", "Score": "17", "Body": "<p>Is the following C++14/C++1y program ill-formed according to the current draft?</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate&lt;typename T, size_t n&gt;\nstruct literal_array\n{\n    T data[n];\n};\n\ntemplate&lt;typename T, size_t n, size_t m&gt;\nconstexpr literal_array&lt;T, n+m&gt; operator+(literal_array&lt;T, n&gt; a,\n                                          literal_array&lt;T, m&gt; b)\n{\n    literal_array&lt;T, n+m&gt; x;\n\n    for (size_t i = 0; i &lt; n; i++)\n        x.data[i] = a.data[i];\n\n    for (size_t i = 0; i &lt; m; i++)\n        x.data[n+i] = b.data[i];\n\n    return x;\n}\n\nint main()\n{\n    constexpr literal_array&lt;int, 3&gt; a = { 1, 2, 3 };\n    constexpr literal_array&lt;int, 2&gt; b = { 4, 5 };\n\n    constexpr auto c = a + b;\n}\n</code></pre>\n<p>Clang trunk (at time of writing) gives:</p>\n<pre><code>error: constexpr variable 'c' must be initialized by a constant expression\n        constexpr auto c = a + b;\n                       ^   ~~~~~\nassignment to object outside its lifetime is not allowed in a constant expression\n                x.data[i] = a.data[i];\n                          ^\nin call to 'operator+({{1, 2, 3}}, {{4, 5}})'\n        constexpr auto c = a + b;\n                           ^\n</code></pre>\n<p>What does it mean \"assignment to object outside its lifetime\"?  The lifetime of x and its subobjects encloses the function, so what is it on about?</p>\n", "Tags": "<c++><language-lawyer><constexpr><c++14>", "OwnerUserId": "1131467", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21806154_21806862_0": {"section_id": 5419, "quality": 0.8571428571428571, "length": 6}, "so_21806154_21806862_3": {"section_id": 7189, "quality": 0.8461538461538461, "length": 33}, "so_21806154_21806862_1": {"section_id": 5419, "quality": 1.0, "length": 7}, "so_21806154_21806862_2": {"section_id": 5419, "quality": 1.0, "length": 10}}, "n3337": {"so_21806154_21806862_0": {"section_id": 5214, "quality": 0.8571428571428571, "length": 6}, "so_21806154_21806862_3": {"section_id": 6933, "quality": 0.8461538461538461, "length": 33}, "so_21806154_21806862_1": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}, "so_21806154_21806862_2": {"section_id": 6895, "quality": 0.6, "length": 6}}, "n4659": {"so_21806154_21806862_0": {"section_id": 6841, "quality": 0.7142857142857143, "length": 5}, "so_21806154_21806862_3": {"section_id": 8697, "quality": 0.7435897435897436, "length": 29}, "so_21806154_21806862_1": {"section_id": 6841, "quality": 1.0, "length": 7}, "so_21806154_21806862_2": {"section_id": 6841, "quality": 1.0, "length": 10}}}, "21806862": {"ParentId": "21806154", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The program is <em>ill-formed</em> because you are not initializing <code>x</code>, if you change the definition to:</p>\n<pre><code>literal_array&lt;T, n+m&gt; x = {{0}};\n</code></pre>\n<p><code>clang</code> no longer complains and it compiles without error. Another solution would be to create <em>constexpr consrtuctors</em>.</p>\n<p>We can find this in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">draft standard</a> section <code>7.1.5</code> <em>The constexpr specifier</em> paragraph <em>3</em> which says:</p>\n<blockquote>\n<p id=\"so_21806154_21806862_0\">The definition of a <code>constexpr</code> function shall satisfy the following\n  constraints:</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_21806154_21806862_1\">its <em>function-body</em> shall be <code>= delete</code>, <code>= default</code>, or a\n  <em>compound-statement</em> that does not contain</p>\n</blockquote>\n<p>which contains this bullet (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21806154_21806862_2\">a definition of a variable of non-literal type or of static or thread\n  storage duration <strong>or for which no initialization is performed</strong>.</p>\n</blockquote>\n<p>and later on we have the following example:</p>\n<pre><code>constexpr int uninit() {\n  int a; // error: variable is uninitialized\n  return a;\n}\n</code></pre>\n<p>The complaint about the lifetime of <code>x</code> does not seem founded in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">draft standard</a>. The correct reason as far as I can tell should be something along the lines of <code>object is not initialized</code>.</p>\n<p>The relevant quote from the draft standard on object lifetime would be section <code>3.8</code> <em>Object lifetime</em> paragraph <em>1</em> which says:</p>\n<blockquote>\n<p id=\"so_21806154_21806862_3\">The <em>lifetime</em> of an object is a runtime property of the object. An\n  object is said to have non-trivial initialization if it is of a class\n  or aggregate type and it or one of its members is initialized by a\n  constructor other than a trivial default constructor. [ <em>Note:</em>\n  initialization by a trivial copy/move constructor is non-trivial\n  initialization. \u2014 <em>end note</em> ] The lifetime of an object of type <code>T</code> begins\n  when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>Just in case I was missing something I also checked using <a href=\"http://en.cppreference.com/w/cpp/types/is_trivial\" rel=\"nofollow\">std::is_trivial</a>:</p>\n<pre><code>std::cout &lt;&lt;  std::boolalpha &lt;&lt; std::is_trivial&lt;literal_array&lt;int, 3&gt;&gt;::value &lt;&lt; std::endl ;\n</code></pre>\n<p>and the result as expected in <code>true</code>,.</p>\n<p><b>Update</b></p>\n<p>I filed a <a href=\"http://llvm.org/bugs/show_bug.cgi?id=18874\" rel=\"nofollow\">bug report</a> for this and the reply includes this statement:</p>\n<blockquote>\n<p id=\"so_21806154_21806862_4\">[...]The problem is that we don't yet implement the implied rule that such a function can't be invoked in a constant expression.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-09-01T19:12:28.683", "Id": "21806862", "Score": "10", "CreationDate": "2014-02-16T03:18:26.453", "LastActivityDate": "2015-09-01T19:12:28.683"}});