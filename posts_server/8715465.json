post_cb({"8715465": {"Tags": "<c++><gcc><sizeof><variable-length-array>", "ViewCount": "236", "LastEditDate": "2012-01-03T16:44:43.287", "CreationDate": "2012-01-03T16:39:51.367", "LastEditorUserId": "149530", "Title": "Is the sizeof operator evaluated differently for VLAs by gcc?", "CommentCount": "1", "AcceptedAnswerId": "8715599", "Score": "2", "OwnerUserId": "514235", "Id": "8715465", "LastActivityDate": "2014-11-03T06:47:27.810", "Body": "<p><code>g++</code> allows <em>Variable Length Arrays (VLA)</em> as an extension. The results of <code>sizeof</code> operator on VLAs are interesting:</p>\n<pre><code>int main ()\n{\n  char size = 20, a[10], b[size];\n  cout&lt;&lt;\"sizeof(a) = \"&lt;&lt;sizeof(a)&lt;&lt;endl;  // sizeof(a) = 10, (can be used as template param)\n  cout&lt;&lt;\"sizeof(b) = \"&lt;&lt;sizeof(b)&lt;&lt;endl;  // sizeof(b) = 20 !! (can't used be as template param)\n}\n</code></pre>\n<p>In case of <code>sizeof(b)</code>, is g++ not following the standard where <code>sizeof</code> is evaluated only at compile time? Is <code>sizeof</code> <a href=\"http://www2.research.att.com/~bs/bs_faq2.html#overload-dot\" rel=\"nofollow\">overloaded</a>?</p>\n", "PostTypeId": "1", "AnswerCount": "3"}, "8715601": {"ParentId": "8715465", "Score": "3", "CreationDate": "2012-01-03T16:48:33.513", "LastActivityDate": "2012-01-03T16:57:53.073", "LastEditDate": "2012-01-03T16:57:53.073", "OwnerUserId": "201270", "LastEditorUserId": "201270", "Body": "<p>Variable Length Arrays are a part of C99, which is not in C++. Gcc allows them as an extension in C++ using the behaviour from C99, which does indeed say that <code>sizeof</code> returns the actual size of the array (and is therefore evaluated at runtime). <a href=\"http://en.wikipedia.org/wiki/Sizeof\" rel=\"nofollow\">The wikipedia article about sizeof</a> gives a nice summary of its behaviour.</p>\n", "Id": "8715601", "PostTypeId": "2", "CommentCount": "0"}, "8715606": {"ParentId": "8715465", "Score": "4", "CreationDate": "2012-01-03T16:48:50.020", "Id": "8715606", "OwnerUserId": "367273", "LastActivityDate": "2012-01-03T16:48:50.020", "Body": "<p>VLAs were introduced in C99. In C99, <code>sizeof(vla)</code> is not a compile-time constant, but takes into account the run-time size of the array.</p>\n<p><code>gcc/g++</code> allow VLAs in non-C99 code, as an extension. When doing so, the compilers follow the C99 semantics. This is what you're observing.</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "8715599": {"ParentId": "8715465", "Score": "4", "CreationDate": "2012-01-03T16:48:19.430", "LastActivityDate": "2014-11-03T06:47:27.810", "LastEditDate": "2014-11-03T06:47:27.810", "OwnerUserId": "204847", "LastEditorUserId": "1505939", "Body": "<p>VLAs are an exception to the rule that the operand of <code>sizeof</code> is not evaluated, as specified in C99, 6.5.3.4/2:</p>\n<blockquote>\n<p id=\"so_8715465_8715599_0\">If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.</p>\n</blockquote>\n<p>This behaviour is a g++ extension; in Standard C++ (up to and including C++14) the operand of <code>sizeof</code> is never evaluated (and VLAs are not permitted).</p>\n", "Id": "8715599", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_8715465_8715599_0": {"length": 8, "section_id": 6103, "quality": 0.5714285714285714}}}});