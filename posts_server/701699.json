post_cb({"701699": {"ViewCount": "714", "Body": "<p>after doing some test-code for this link :<br>\n<a href=\"https://stackoverflow.com/questions/701313/is-it-safe-to-call-temporary-objects-methods\">Is it safe to call temporary object's methods?</a><br>\nI found a rather strange feature of the c++ language, which I'm not sure how it works :</br></br></p>\n<pre><code>struct Test{\n    int i;\n    Test(int ii):i(ii){}\n    Test&amp; operator=(int ii){\n        i = ii;\n        return *this;\n    }\n    Test operator+(const Test&amp; rhs){\n        return Test(i + rhs.i);\n    }\n    void non_const_function(){\n        i *= i;\n    }\n};\n\nint main(){\n        //code below gives errors, builtin types don't allow evil code\n        //int i = 5+5 = 8;\n        //int&amp; iRef = 5+5;\n        //int* iPtr = &amp;(5+5);\n        //5 = 10;\n\n        Test x = Test(5) + Test(5) = 8;//assign to a temporary\n        Test&amp; xRef = Test(5) + Test(5);//reference to a temporary\n        Test* xPtr = &amp;(Test(5) + Test(5));//address of a temporary\n        Test(5) = Test(10);//assign to a temporary\n        Test(8).non_const_function();//call a non-const function\n        return 0;\n}\n</code></pre>\n<p>xRef and xPtr are both working pointers, with the expected values.<br>\nOf course I wouldn't write such code in a real project, but I'm still interested how / why this works.<br>\nThe only info I found on google about this was that \"if you create a reference to a temporary, the temporaries lifetime is linked to the lifetime of the reference\"  </br></br></p>\n<p>Note :<br>\n-not all compilers are that forgiving, e.g. Metrowerks ARM (does it use GCC ?) only allows const reference to temporaries.<br>\nEDIT :<br>\n-increasing the warning to W4 in VC++ 2008 showed lots of errors - good to know.  </br></br></br></p>\n<p>EDIT 2:<br>\nThank you all for the help. I'm back to work, fixing 100's of warnings.<br>\nCONCLUSION : use highest warning from start (I even found a REAL bug thanks to /G4)</br></br></p>\n", "AcceptedAnswerId": "701768", "Title": "Assigning to temporary (like 5 = 10 but for user-defined types)", "CreationDate": "2009-03-31T15:53:09.003", "Id": "701699", "CommentCount": "0", "LastEditDate": "2017-05-23T12:01:27.050", "PostTypeId": "1", "LastEditorDisplayName": "qwerty", "OwnerDisplayName": "qwerty", "LastEditorUserId": "-1", "LastActivityDate": "2009-03-31T16:56:27.807", "Score": "1", "OwnerUserId": "79182", "Tags": "<c++>", "AnswerCount": "6"}, "701745": {"Body": "<p>This kind of thing is ubiquitous in many object-oriented programming languages, especially those with object overloading.</p>\n<p>If the first statement were written</p>\n<pre><code>Text x = Test(5).add(Test(5)).set(8);\n</code></pre>\n<p>where .add and .set return the lefthand Test instances with the expected values, would you still be confused?</p>\n<p>To break this example down, you're creating a Test object with value 5, then adding another Test object with value 5 to it, and returning the first Test object, now with value 10. Then you're setting its value to 8, and assigning that object to x (well actually it's not assignment, again you're creating a Test object named x, then setting its value to the temporary's value).</p>\n", "CreationDate": "2009-03-31T16:02:23.630", "ParentId": "701699", "CommentCount": "0", "LastEditDate": "2009-03-31T16:12:20.487", "PostTypeId": "2", "LastEditorDisplayName": "Welbog", "LastActivityDate": "2009-03-31T16:12:20.487", "LastEditorUserId": "52443", "Id": "701745", "OwnerDisplayName": "Welbog", "Score": "3", "OwnerUserId": "52443"}, "701775": {"Body": "<p>My reading of your question tells me you are confused with the lifetime of temporaries more than anything else. I think it will help if you put a couple of <code>cout</code>s as below:</p>\n<pre><code>struct Test{\n    int i;\n    Test(int ii):i(ii){ std::cout &lt;&lt; \"new object\\n\"; }\n    Test&amp; operator=(int ii){\n        i = ii;\n        return *this;\n    }\n    Test operator+(const Test&amp; rhs){\n        return Test(i + rhs.i);\n    }\n    void non_const_function(){\n        i *= i;\n    }\n    ~Test() { std::cout &lt;&lt; \"deleting ...\\n\"; }\n};\n</code></pre>\n<p>Now run, and you should be able to see what exactly is going on under the hoods. (Style Check:Not checking for self-assignment is not a good thing.)</p>\n<p>It will also help if you refer the standard: It discusses something similar to what you have posted:</p>\n<blockquote>\n<p id=\"so_701699_701775_0\"><strong>12.2 Temporary objects</strong></p>\n<p id=\"so_701699_701775_1\">4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument expression is sequenced before the construction of the next array element, if any.</p>\n<p id=\"so_701699_701775_2\">5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits. A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call. A temporary bound to the returned value in a function return statement (6.6.3) persists until the function exits. A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the\n  full-expression containing the new-initializer.</p>\n</blockquote>\n<pre><code> struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };\n S a { 1, {2,3} };\n S* p = new S{ 1, {2,3} }; // Creates dangling reference\n</code></pre>\n<blockquote>\n<p id=\"so_701699_701775_3\">[ Note: This may introduce a dangling reference, and implementations are encouraged to\n  issue a warning in such a case. \u2014end note ] The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced before the destruction of every temporary which is constructed earlier in the same full-expression. If the lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to references shall take into account the ordering of destruction of objects with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if <code>obj1</code> is an object with the same storage duration as the temporary and created before the temporary is created the temporary shall be destroyed before <code>obj1</code> is destroyed; if <code>obj2</code> is an object with the same storage duration as the temporary and created after the temporary is created the temporary shall be destroyed after <code>obj2</code> is destroyed. <em>Example:</em></p>\n</blockquote>\n<pre><code> struct S {\n    S();\n    S(int);\n    friend S operator+(const S&amp;, const S&amp;);\n    ~S();\n };\n S obj1;\n const S&amp; cr = S(16)+S(23);\n S obj2;\n</code></pre>\n<blockquote>\n<p id=\"so_701699_701775_4\">the expression <code>C(16)+C(23)</code> creates three temporaries. A first temporary <code>T1</code> to hold the result of the expression <code>C(16)</code>, a second temporary <code>T2</code> to hold the result of the expression <code>C(23)</code>, and a third temporary <code>T3</code> to hold the result of the addition of these two expressions. The temporary <code>T3</code> is then bound to the reference <code>cr</code>. It is unspecified whether <code>T1</code> or <code>T2</code> is created first. On an implementation where <code>T1</code> is created before <code>T2</code>, it is guaranteed that <code>T2</code> is destroyed before <code>T1</code>. The temporaries <code>T1</code> and <code>T2</code> are bound to the reference parameters of <code>operator+</code>; these temporaries are destroyed at the end of the full-expression containing the call to <code>operator+</code>. The  temporary <code>T3</code> bound to the reference <code>cr</code> is destroyed at the end of <code>cr</code>\u2019s lifetime,\n  that is, at the end of the program. In addition, the order in which <code>T3</code> is destroyed takes into account the destruction order of other objects with static storage duration. That is, because <code>obj1</code> is constructed before <code>T3</code>, and <code>T3</code> is constructed before <code>obj2</code>, it is guaranteed that <code>obj2</code> is destroyed before <code>T3</code>, and that <code>T3</code> is destroyed before <code>obj1</code>.</p>\n</blockquote>\n", "CreationDate": "2009-03-31T16:07:50.217", "ParentId": "701699", "CommentCount": "3", "LastEditDate": "2009-03-31T16:18:34.823", "PostTypeId": "2", "LastEditorDisplayName": "dirkgently", "LastActivityDate": "2009-03-31T16:18:34.823", "LastEditorUserId": "66692", "Id": "701775", "OwnerDisplayName": "dirkgently", "Score": "1", "OwnerUserId": "66692"}, "bq_ids": {"n4140": {"so_701699_701775_4": {"length": 81, "quality": 0.9, "section_id": 382}, "so_701699_701775_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 381}, "so_701699_701775_2": {"length": 58, "quality": 0.8285714285714286, "section_id": 382}, "so_701699_701775_3": {"length": 90, "quality": 0.9090909090909091, "section_id": 382}}, "n3337": {"so_701699_701775_4": {"length": 83, "quality": 0.9222222222222223, "section_id": 373}, "so_701699_701775_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 372}, "so_701699_701775_2": {"length": 58, "quality": 0.8285714285714286, "section_id": 373}, "so_701699_701775_3": {"length": 90, "quality": 0.9090909090909091, "section_id": 373}}, "n4659": {"so_701699_701775_4": {"length": 81, "quality": 0.9, "section_id": 399}, "so_701699_701775_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 396}, "so_701699_701775_2": {"length": 47, "quality": 0.6714285714285714, "section_id": 397}, "so_701699_701775_3": {"length": 80, "quality": 0.8080808080808081, "section_id": 398}}}, "701969": {"Id": "701969", "PostTypeId": "2", "Body": "<p>Take a look at the <a href=\"http://www.gotw.ca/gotw/004.htm\" rel=\"nofollow noreferrer\">GotW #4</a> which discusses the mechanics creating a user-defined class that most closely mirrors built-in arithmetic types.  If you take his advice, your Test struct would look more like this:</p>\n<pre><code>struct Test{\n    ...\n    Test&amp; operator+=( const Test&amp; other ) {\n        i += other.i;\n        return *this;\n    }\n    ...\n};\n\nconst Test operator+( const Test&amp; lhs, const Test&amp; rhs ) {\n    Test ret( lhs );\n    ret += rhs;\n    return ret;\n}\n</code></pre>\n<p>Now Test behaves much better in the addition situations (lines 1, 2, and 3 fail to compile).   This is one of the rare instances where returning a const copy is actually useful,</p>\n", "OwnerDisplayName": "Josh", "LastActivityDate": "2009-03-31T16:47:59.777", "Score": "0", "CreationDate": "2009-03-31T16:47:59.777", "ParentId": "701699", "CommentCount": "0", "OwnerUserId": "8701"}, "701883": {"Id": "701883", "PostTypeId": "2", "Body": "<p>Regarding the first case, assigning to a temporary, I recall from my Effective C++ that it is good practice to declare your operators like</p>\n<pre><code>const Test operator+(const Test&amp;) const\n</code></pre>\n<p>This will make the objects behave like built-in types in that respect, at least.</p>\n", "OwnerDisplayName": "CAdaker", "LastActivityDate": "2009-03-31T16:26:52.357", "Score": "3", "CreationDate": "2009-03-31T16:26:52.357", "ParentId": "701699", "CommentCount": "0", "OwnerUserId": "30579"}, "701768": {"Id": "701768", "PostTypeId": "2", "Body": "<p>Let's go line by line:</p>\n<pre><code>    Test x = Test(5) + Test(5) = 8;//assign to a temporary\n</code></pre>\n<p>There's no big deal here.  Temporaries are still just normal objects, and thus the assignment operator works on them just as it would on anything else.</p>\n<pre><code>    Test&amp; xRef = Test(5) + Test(5);//reference to a temporary\n</code></pre>\n<p>Like Metroworks, my GCC doesn't allow a non-const reference to a temporary.</p>\n<pre><code>    Test* xPtr = &amp;(Test(5) + Test(5));//address of a temporary\n</code></pre>\n<p>In addition, GCC warns about taking the address of a temporary, for obvious reasons.</p>\n<pre><code>   Test(5) = Test(10);//assign to a temporary\n</code></pre>\n<p>Again, this is just assignment, which, as I explained above, is no big deal.</p>\n<pre><code>    Test(8).non_const_function();//call a non-const function\n</code></pre>\n<p>Temporary objects aren't constant.  There's nothing stopping them from calling non-const functions.</p>\n", "OwnerDisplayName": "Pesto", "LastActivityDate": "2009-03-31T16:06:20.487", "Score": "7", "CreationDate": "2009-03-31T16:06:20.487", "ParentId": "701699", "CommentCount": "0", "OwnerUserId": "23921"}, "701725": {"Id": "701725", "PostTypeId": "2", "Body": "<p>The assignment operator is just a function with a funny name. If you can call a function on a temporary (which you can), then you can assign to a temporary, given a suitable operator=().</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2009-03-31T15:58:28.837", "Score": "1", "CreationDate": "2009-03-31T15:58:28.837", "ParentId": "701699", "CommentCount": "0"}});