post_cb({"27336766": {"CommentCount": "5", "ViewCount": "104", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-08T21:02:45.183", "Body": "<p>I'm making a Linked list which is generic in nature and have some basic functionality. Then I'm trying to make another template class called \"Set\" which is inheriting from LinkedList. But when I try to access \"head\" which is a  Node&lt;&gt;* defined in Linked List. It's giving an error. My files are:</p>\n<p>LinkedList.h</p>\n<pre><code>template &lt;typename T&gt;\nstruct Node {\n        T data;\n        Node&lt;T&gt; *next;\n};\n\ntemplate &lt;typename T&gt;\nclass LinkedList {\npublic:\n        Node&lt;T&gt;* head;\n        int size;\n\n        LinkedList();\n        LinkedList(const LinkedList&lt;T&gt; &amp;lst);\n        ~LinkedList();\n\n        Node&lt;T&gt;* getHead();\n        Node&lt;T&gt;* getTail();\n};\n\ntemplate &lt;typename T&gt;\nclass Set:public LinkedList&lt;T&gt; {\npublic:\n        void insert(T item);\n        friend ostream&amp;(ostream&amp; out, const Set&lt;T&gt; set)\n};\n</code></pre>\n<p>and an implementation of insert is:</p>\n<pre><code>template &lt;typename T&gt;\nvoid Set&lt;T&gt;::insert(T item) {\n       Node&lt;T&gt;* temp = head;\n       bool present = false;\n\n       while (temp != NULL) {\n                if (temp-&gt;data == item) {\n                        present = true;\n                }\n\n                temp = temp-&gt;next;\n       }\n\n        if (present == false) {\n                /*Node&lt;T&gt; *tail = getTail();\n                Node&lt;T&gt;* newTail = new Node&lt;T&gt;(item);\n                newTail-&gt;next = NULL;\n                tail-&gt;next = newTail;*/\n        }\n}\n</code></pre>\n<p>It says:</p>\n<blockquote>\n<p id=\"so_27336766_27336766_0\"><code>error: \"head\" was not declared in this scope in line \"Node&lt;T&gt;* temp = head\"</code></p>\n</blockquote>\n", "Title": "Template class not inheriting the protected variable from another Template class", "FavoriteCount": "1", "LastEditDate": "2014-12-06T22:11:08.177", "Id": "27336766", "Score": "-1", "CreationDate": "2014-12-06T21:29:34.637", "Tags": "<c++><templates><linked-list><set>", "OwnerUserId": "3813179", "AnswerCount": "2"}, "27336802": {"ParentId": "27336766", "LastEditDate": "2017-05-23T12:06:55.837", "CommentCount": "8", "CreationDate": "2014-12-06T21:32:47.577", "OwnerUserId": "701092", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27336802", "Score": "2", "Body": "<p>You're inheriting from a dependent base class so member access needs to be qualified with <code>this</code>:</p>\n<pre><code>Node&lt;T&gt;* temp = this-&gt;head;\n</code></pre>\n<p>For more information, see <a href=\"https://stackoverflow.com/questions/4643074/why-do-i-have-to-access-template-base-class-members-through-the-this-pointer\">this thread</a>.</p>\n", "LastActivityDate": "2014-12-06T21:45:00.557"}, "bq_ids": {"n4140": {"so_27336766_27336844_0": {"section_id": 190, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_27336766_27336844_0": {"section_id": 184, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_27336766_27336844_0": {"section_id": 195, "quality": 0.7586206896551724, "length": 22}}}, "27336844": {"ParentId": "27336766", "LastEditDate": "2017-05-23T12:19:30.567", "CommentCount": "6", "CreationDate": "2014-12-06T21:37:12.240", "OwnerUserId": "560648", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27336844", "Score": "3", "Body": "<p>This C++ oddity is due to two-phase lookup and the fact that <code>head</code> is a dependant name (as a member of a base class that depends on the \"current\" class's template arguments):</p>\n<blockquote>\n<p id=\"so_27336766_27336844_0\"><code>[C++11: 14.6.2/3]:</code> In the definition of a class or class template, if a base class depends on a template-parameter, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member. <em>[..]</em></p>\n</blockquote>\n<p>Bypass unqualified lookup by introducing <code>this</code> into the expression (per <code>[C++11: 3.4.5</code>]):</p>\n<pre><code>Node&lt;T&gt;* temp = this-&gt;head;\n//              ^^^^^^\n</code></pre>\n<p>There's a longer explanation on this previous Stack Overflow answer:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/4643074/560648\">Why do I have to access template base class members through the this pointer?</a></li>\n</ul>\n<hr>\n<p>Here's a minimal(ish) testcase:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct Base\n{\n    int x = 42;\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n    void foo();\n};\n\ntemplate &lt;typename T&gt;\nvoid Derived&lt;T&gt;::foo()\n{\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\nint main()\n{\n    Derived&lt;void&gt; d;\n    d.foo();\n}\n// main.cpp: In member function 'void Derived&lt;T&gt;::foo()':\n// main.cpp:18:18: error: 'x' was not declared in this scope\n//      std::cout &lt;&lt; x &lt;&lt; '\\n';\n//                   ^\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/8b60fff2efe76a9f\" rel=\"nofollow noreferrer\">live demo</a>)</p>\n<p>To fix, change <code>foo</code> thus:</p>\n<pre><code>template &lt;typename T&gt;\nvoid Derived&lt;T&gt;::foo()\n{\n    std::cout &lt;&lt; this-&gt;x &lt;&lt; '\\n';\n}\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/260d06482f90647d\" rel=\"nofollow noreferrer\">live demo</a>)</p>\n</hr>", "LastActivityDate": "2014-12-06T21:45:23.860"}});