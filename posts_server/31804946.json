post_cb({"bq_ids": {"n4140": {"so_31804946_31810042_2": {"length": 9, "quality": 0.9, "section_id": 304}, "so_31804946_31810042_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5938}}, "n3337": {"so_31804946_31810042_2": {"length": 9, "quality": 0.9, "section_id": 295}, "so_31804946_31810042_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5710}}, "n4659": {"so_31804946_31810042_2": {"length": 10, "quality": 1.0, "section_id": 311}, "so_31804946_31810042_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7422}}}, "31805329": {"Id": "31805329", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\n\ntemplate&lt;typename T&gt;\nauto func(T arg)\n{\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"T if ref: \" &lt;&lt; std::is_reference&lt;decltype(arg)&gt;::value &lt;&lt; \"\\n\";\n}\n\ntemplate&lt;class T&gt;\nauto func_wrapper(T&amp; arg)\n{\n    func&lt;T&amp;&gt;(arg);\n}\n\n#define func func_wrapper\n\nauto main() -&gt; int\n{\n    auto x = 5;\n    func(x);\n\n    auto&amp; y = x;\n    func(y);\n\n    return 0;\n}\n</code></pre>\n<p>expected output (sic):</p>\n<pre><code>T if ref: true\nT if ref: true\n</code></pre>\n", "LastActivityDate": "2015-08-04T09:18:37.377", "CommentCount": "5", "CreationDate": "2015-08-04T09:18:37.377", "ParentId": "31804946", "Score": "0", "OwnerUserId": "2015579"}, "31805114": {"Id": "31805114", "PostTypeId": "2", "Body": "<p><strong>Note:</strong> this anwer has been invalidated by the late edit stating that OP could not modify the function.</p>\n<hr>\n<p>Type deduction and reference collapsing are what you need :</p>\n<pre><code>template&lt;class T&gt;\nauto func(T&amp;&amp;) {\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"T is ref: \" &lt;&lt; std::is_reference&lt;T&gt;::value &lt;&lt; '\\n';\n}\n\nint main() {\n    func(5);\n    int i = 7;\n    func(i);\n    int const j = 9;\n    func(j);\n}\n</code></pre>\n<p>Output :</p>\n<pre><code>T is ref: false\nT is ref: true\nT is ref: true\n</code></pre>\n</hr>", "LastEditorUserId": "3233393", "LastActivityDate": "2015-08-04T13:12:46.673", "Score": "4", "CreationDate": "2015-08-04T09:09:00.130", "ParentId": "31804946", "CommentCount": "6", "OwnerUserId": "3233393", "LastEditDate": "2015-08-04T13:12:46.673"}, "31804946": {"ViewCount": "80", "Body": "<p>Say I have a function <code>func</code>:</p>\n<pre><code>template&lt;typename T&gt;\nauto func(T arg){\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"T is ref: \" &lt;&lt; std::is_reference&lt;T&gt;::value &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Is there a way I can force <code>T</code> to be deduced as a reference type without explicitly specifying the template parameters?</p>\n<p>Like being able to write something like:</p>\n<pre><code>auto main() -&gt; int{\n    auto x = 5;\n    func(std::ref(x));\n}\n</code></pre>\n<p>but without having to specialize for <code>std::reference_wrapper</code>.</p>\n<p><code>static_cast</code>ing does not stop the decay of <code>int&amp;</code> into <code>int</code> for <code>T</code>.</p>\n<p>Imagine that I <strong>can not</strong> change the function signature.</p>\n", "AcceptedAnswerId": "31810042", "Title": "forcing template type to be reference by deduction", "CreationDate": "2015-08-04T09:01:25.953", "Id": "31804946", "CommentCount": "2", "LastEditDate": "2015-08-04T09:14:08.680", "PostTypeId": "1", "LastEditorUserId": "2297448", "LastActivityDate": "2015-08-04T13:12:46.673", "Score": "0", "OwnerUserId": "2297448", "Tags": "<c++><templates><c++14>", "AnswerCount": "3"}, "31810042": {"Id": "31810042", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_31804946_31810042_0\">Imagine that I can not change the function signature.</p>\n</blockquote>\n<p>The signature</p>\n<pre><code>template&lt;typename T&gt;\nauto func(T arg) { ... }\n</code></pre>\n<p>will never <em>deduce</em> a reference because type deduction works on the type of the expression of the arguments, and from [expr]:</p>\n<blockquote>\n<p id=\"so_31804946_31810042_1\">If an expression initially has the type \u201creference to <code>T</code>\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to\n  any further analysis.</p>\n</blockquote>\n<p>That said, template deduction only happens if the template parameters are not explicitly provided. So you can explicitly specify <code>T</code>:</p>\n<pre><code>auto main() -&gt; int{\n    auto x = 5;\n    func&lt;int&amp;&gt;(x); // T = int&amp;\n}\n</code></pre>\n<p>Otherwise, you could add a middle step in between:</p>\n<pre><code>template &lt;typename T&gt;\nauto func_helper(T&amp;&amp; arg) {\n    return func&lt;T&gt;(std::forward&lt;T&gt;(arg));\n               \u2191\u2191\u2191\n}\n</code></pre>\n<p>Because, in [temp.deduct.call]:</p>\n<blockquote>\n<p id=\"so_31804946_31810042_2\">If P is a forwarding reference and the argument is an\n  lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.</p>\n</blockquote>\n<p>So if <code>func_helper</code> is called with an lvalue, the template parameter P will be deduced as a reference. In your example:</p>\n<pre><code>func_helper(x);\n</code></pre>\n<p><code>T</code> will be deduced as <code>int&amp;</code>, so we explicitly call the same function as we did before: <code>func&lt;int&amp;&gt;</code>.</p>\n<pre><code>func_helper(5);\n</code></pre>\n<p><code>T</code> would be deduced as <code>int</code>, and we would call <code>func&lt;int&gt;</code>, the same as would have happened if we had called <code>func</code> directly. </p>\n", "LastActivityDate": "2015-08-04T12:59:13.940", "CommentCount": "0", "CreationDate": "2015-08-04T12:59:13.940", "ParentId": "31804946", "Score": "1", "OwnerUserId": "2069064"}});