post_cb({"bq_ids": {"n4140": {"so_33957274_33958291_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 87}, "so_33957274_33958291_4": {"length": 17, "quality": 1.0, "section_id": 6186}}, "n3337": {"so_33957274_33958291_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 82}, "so_33957274_33958291_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 5947}}, "n4659": {"so_33957274_33958291_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 90}, "so_33957274_33958291_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 7689}}}, "33958187": {"Id": "33958187", "PostTypeId": "2", "Body": "<p>The user-defined conversion is allowed by <a href=\"http://eel.is/c++draft/expr.const#4\" rel=\"nofollow\">[expr.const]/(4.1)</a>, and I don't see a single applicable bullet point in <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow\">[expr.const]/2</a> that would prevent your expression from being a constant one. In fact, the requirements are so loose that declaring <code>a</code> as</p>\n<pre><code>A a;\n</code></pre>\n<p>is <a href=\"http://coliru.stacked-crooked.com/a/1953c90933f97b60\" rel=\"nofollow\">still giving a well-formed program</a>, even if <code>a</code> didn't have a <code>constexpr</code> default constructor etc., since the conversion operator is <code>constexpr</code> and no members are evaluated. </p>\n<p>As you saw yourself, GCC is contradictory in that it allows <code>a</code> in the <code>static_assert</code> condition but not a template-argument.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-27T13:14:31.350", "Score": "5", "CreationDate": "2015-11-27T13:12:02.590", "ParentId": "33957274", "CommentCount": "2", "LastEditDate": "2015-11-27T13:14:31.350", "OwnerUserId": "3647361"}, "33957274": {"ViewCount": "216", "Body": "<p>Consider the following code:</p>\n<pre><code>struct A {\n    constexpr operator int() { return 42; }\n};\n\ntemplate &lt;int&gt;\nvoid foo() {}\n\nvoid bar(A a) {\n    foo&lt;a&gt;();\n}\n\nint main() {\n    foo&lt;A{}&gt;();\n\n    const int i = 42;\n    foo&lt;i&gt;();  // (1)\n\n    A a{};\n\n    static_assert(i == a, \"\");\n    bar(a);\n    foo&lt;a&gt;();  // error here\n}\n</code></pre>\n<p>Clang 3.7 with c++14 accepts this, while gcc 5.2.0 with c++14 does not, producing the following message:</p>\n<blockquote id=\"so_33957274_33957274_0\">\n<pre><code>/tmp/gcc-explorer-compiler1151027-68-1f801jf/example.cpp: In function 'int main()':\n26 : error: the value of 'a' is not usable in a constant expression\nfoo&lt;a&gt;();\n^\n23 : note: 'a' was not declared 'constexpr'\nA a{};\n^\nCompilation failed\n</code></pre>\n</blockquote>\n<p>Changing <code>a</code> to be <code>constexpr</code> as suggested by gcc fixes the gcc compilation error, but without <code>constexpr</code>, which compiler is right?</p>\n<p>For me, it seems that <code>a</code> should be \"usable in constant expression\", as <code>static_assert</code> ceritifies. Moreover, the fact that <code>i</code> can be used the same way (marked <code>(1)</code>), and the fact that <code>bar()</code> compiles, also makes me think that gcc is wrong.</p>\n<p><strong>UPD</strong>: reported a bug against gcc: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68588\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68588</a></p>\n", "AcceptedAnswerId": "33958187", "Title": "Type conversion at template non-type argument without constexpr", "CreationDate": "2015-11-27T12:17:55.170", "Id": "33957274", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-27T15:20:53.810", "LastEditorUserId": "3216312", "LastActivityDate": "2015-11-27T15:20:53.810", "Score": "5", "OwnerUserId": "3216312", "Tags": "<c++><templates><gcc><clang><c++14>", "AnswerCount": "3"}, "33958291": {"Id": "33958291", "PostTypeId": "2", "Body": "<p>I would say that Clang is correct.</p>\n<p>Draft for current C++ (n4296) says:</p>\n<blockquote>\n<p id=\"so_33957274_33958291_0\">14.3.2 Template non-type arguments [temp.arg.nontype]</p>\n<p id=\"so_33957274_33958291_1\">A template-argument for a non-type template-parameter shall be a converted constant expression (5.20) of\n  the type of the template-parameter</p>\n</blockquote>\n<p>And 5.20 \u00a74 says (emphasize mine):</p>\n<blockquote>\n<p id=\"so_33957274_33958291_2\">5.20 Constant expressions [expr.const]</p>\n<p id=\"so_33957274_33958291_3\">...</p>\n<p id=\"so_33957274_33958291_4\">(4) A converted constant expression of type T is an expression, implicitly converted to type T, <strong>where the converted\n  expression is a constant expression</strong> and the implicit conversion sequence contains only</p>\n<p id=\"so_33957274_33958291_5\">(4.1) \u2014 user-defined conversions, ...</p>\n</blockquote>\n<p>IFAIK in <code>foo&lt;a&gt;();</code> a is converted to int with a constexpr user-defined conversion and as such <strong>is</strong> a converted constant expression.</p>\n<p>That being said, we are not far from a edge case here, and my advice would be: do not play with such a construct in production code :-)</p>\n", "LastActivityDate": "2015-11-27T13:17:59.453", "Score": "2", "CreationDate": "2015-11-27T13:17:59.453", "ParentId": "33957274", "CommentCount": "0", "OwnerUserId": "3545273"}, "33957524": {"Id": "33957524", "PostTypeId": "2", "Body": "<p>As @Jarod42 suggests <code>a</code> should be <code>constexpr</code>. This is because templates are deduced at compile time, and so non-type arguments also have to be available at compile time. <code>constexpr</code> is a promise that they will be available at compile time.</p>\n", "LastActivityDate": "2015-11-27T12:32:38.370", "Score": "-2", "CreationDate": "2015-11-27T12:32:38.370", "ParentId": "33957274", "CommentCount": "2", "OwnerUserId": "2103122"}});