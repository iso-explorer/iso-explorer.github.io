post_cb({"bq_ids": {"n4140": {"so_39757246_39757263_0": {"length": 19, "quality": 1.0, "section_id": 5913}}, "n3337": {"so_39757246_39757263_0": {"length": 19, "quality": 1.0, "section_id": 5685}}, "n4659": {"so_39757246_39757263_0": {"length": 19, "quality": 1.0, "section_id": 7404}}}, "39757263": {"Id": "39757263", "PostTypeId": "2", "Body": "<p>Reading from inactive member of a union is undefined in C++. (It's legit in C99 and C11).</p>\n<p>So, all in all, the compiler isn't required to assume/remember anything.</p>\n<p>Standardese:</p>\n<blockquote>\n  N4140 \u00a79.5[class.union]/1\n  \n  <p id=\"so_39757246_39757263_0\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time.</p>\n</blockquote>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-09-28T20:48:59.487", "Score": "5", "CreationDate": "2016-09-28T20:41:33.603", "ParentId": "39757246", "CommentCount": "5", "OwnerUserId": "2456565", "LastEditDate": "2016-09-28T20:48:59.487"}, "39757246": {"ViewCount": "92", "Body": "<p>I think I'm really asking: is aliasing \"transitive\"? If the compiler knows that A might alias B, and B might alias C, then surely it should remember that A might therefore alias C. Perhaps this \"obvious\" transitive logic isn't required however?</p>\n<p>An example, for clarity. The most interesting example, to me, of a strict-aliasing issue:</p>\n<pre><code>// g++    -fstrict-aliasing -std=c++11 -O2\n#include &lt;iostream&gt;\n\nunion\n{   \n    int i;\n    short s;\n} u;\nint     * i = &amp;u.i;\n\nint main()\n{   \n\n    u.i = 1; // line 1\n    *i += 1; // line 2\n\n    short   &amp; s =  u.s;\n    s += 100; // line 3\n\n    std::cout\n        &lt;&lt; \" *i\\t\" &lt;&lt;  *i &lt;&lt; std::endl // prints 2\n        &lt;&lt; \"u.i\\t\" &lt;&lt; u.i &lt;&lt; std::endl // prints 101\n        ;\n\n    return 0;\n}\n</code></pre>\n<p>g++ 5.3.0, on x86_64 (but not clang 3.5.0) gives the above output, where <code>*i</code> and <code>u.i</code> give different numbers. But they should give exactly the same number, because <code>i</code> is defined at <code>int * i = &amp;u.i;</code> and <code>i</code> doesn't change.</p>\n<p>I have a theory: When 'predicting' the value of <code>u.i</code>, the compiler asks which lines might affect the contents of <code>u.i</code>. That includes line 1 obviously. And line 2 because <code>int*</code> can alias an <code>int</code> member of a union. And line 3 also, because anything that can affect one union member (<code>u.s</code>) can affect another member of the same union. But when predicting <code>*i</code> it doesn't realise that line 3 can affect the <code>int</code> lvalue at <code>*i</code>.</p>\n<p>Does this theory seem reasonable?</p>\n<p>I find this example funny because I don't have any casting in it. I managed to break strict-aliasing with doing any casting.</p>\n", "AcceptedAnswerId": "39757263", "Title": "Violating strict-aliasing, even without any casting?", "CreationDate": "2016-09-28T20:40:12.673", "Id": "39757246", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-09-28T20:58:25.737", "Score": "1", "OwnerUserId": "146041", "Tags": "<c++><strict-aliasing>", "AnswerCount": "2"}, "39757539": {"Id": "39757539", "PostTypeId": "2", "Body": "<p>It is only allowed to read from the union member that was last written to in C++.</p>\n<p>Aliasing outside unions is only allowed between 'similar' types (for details please see <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">this Q/A</a>), and <code>char</code>/<code>unsigned char</code>. It is only allowed to alias another type through <code>char</code>/<code>unsigned char</code>, but it is not allowed to alias <code>char</code>/<code>unsigned char</code> through other types. If the latter was allowed, then all objects would have to be treated as possibly aliasing any other object, because they could be 'transitively aliased' like you describe through <code>char</code>/<code>unsigned char</code>.</p>\n<p>But because this is not the case, the compiler can safely assume that only objects of 'similar' types and <code>char</code>/<code>unsigned char</code> alias each other.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-28T20:58:25.737", "Score": "1", "CreationDate": "2016-09-28T20:58:25.737", "ParentId": "39757246", "CommentCount": "11", "OwnerUserId": "3435400", "LastEditDate": "2017-05-23T12:15:08.750"}});