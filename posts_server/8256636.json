post_cb({"8256685": {"ParentId": "8256636", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Found it:</p>\n<pre><code>newResult.template set&lt;Criterion&gt;( criterion() );\n\nif(newResult.template get&lt;Criterion&gt;() &gt;= oldResult.template get&lt;Criterion&gt;())\n    return false;\n</code></pre>\n<p>You have to qualify the member function templates for the compiler in this case.\nThe lexer wouldn't be able to decide (at the time of template <em>declaration</em>, not <em>instantiation</em>) whether <code>&lt;Criterion</code> means the start of a <em>template parameter list</em> or, instead, a comparison operator.</p>\n<p>See </p>\n<ul>\n<li><p><a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fkeyword_template_qualifier.htm\" rel=\"noreferrer\">Using the template keyword as qualifier</a></p></li>\n<li><p><a href=\"http://www.comeaucomputing.com/techtalk/templates/#templateprefix\" rel=\"noreferrer\">What is the .template and ::template syntax about?</a> (Comeau)</p></li>\n<li><p>Standard, \u00a7 14.2, sub <strong>4.</strong> and <strong>5.</strong>, noteworthy:</p>\n<blockquote>\n<p id=\"so_8256636_8256685_0\">[ Note: As is the case with the typename prefix, the template prefix is allowed in cases where it is\n  not strictly necessary; i.e., when the nested-name-specifier or the expression on the left of the -&gt; or . is not\n  dependent on a template-parameter, or the use does not appear in the scope of a template. \u2014end note ]</p>\n</blockquote></li>\n</ul>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2011-11-24T12:14:46.193", "Id": "8256685", "Score": "8", "CreationDate": "2011-11-24T11:59:27.070", "LastActivityDate": "2011-11-24T12:14:46.193"}, "8256636": {"CommentCount": "2", "AcceptedAnswerId": "8256685", "CreationDate": "2011-11-24T11:55:45.400", "LastActivityDate": "2011-11-24T12:14:46.193", "PostTypeId": "1", "ViewCount": "3060", "FavoriteCount": "1", "Title": "\"expected primary expression\" error on template method using", "Id": "8256636", "Score": "5", "Body": "<p>I have some generic code which implements Pareto rule. It seems like well-formed code.</p>\n<p>GCC 4.4 compiler messages about errors for <code>newResult.set&lt;Criterion&gt;( criterion() );</code> expression. But I can't found problem.</p>\n<p>Full error log:</p>\n<pre><code>trunk$ g++ -std=c++0x -o test test.cpp \nt6.cpp: In member function \u2018bool Pareto&lt;Minimize&lt;T&gt;, Types ...&gt;::operator()(Map&amp;, Map&amp;)\u2019:\nt6.cpp:24: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:26: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:26: error: expected primary-expression before \u2018)\u2019 token\nt6.cpp:26: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:26: error: expected primary-expression before \u2018)\u2019 token\nt6.cpp: In member function \u2018bool Pareto&lt;Maximize&lt;T&gt;, Types ...&gt;::operator()(Map&amp;, Map&amp;)\u2019:\nt6.cpp:43: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:45: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:45: error: expected primary-expression before \u2018)\u2019 token\nt6.cpp:45: error: expected primary-expression before \u2018&gt;\u2019 token\nt6.cpp:45: error: expected primary-expression before \u2018)\u2019 token\n</code></pre>\n<p>Full code listing:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// TypeMap\ntemplate &lt; typename ... Tail &gt;\nstruct Holder;\n\ntemplate &lt;typename ValueType, typename Head, typename ... Tail &gt;\nstruct Holder&lt;ValueType, Head, Tail ... &gt; :\n    public Holder&lt;ValueType, Head&gt;,\n    public Holder&lt;ValueType, Tail ... &gt;\n{};\n\ntemplate &lt;typename ValueType, typename Head &gt;\nstruct Holder&lt;ValueType, Head&gt;\n{\n    ValueType value;\n};\n\ntemplate &lt; typename ... Types &gt;\nstruct TypeMap;\n\ntemplate &lt;typename ValueType, typename ... Types &gt;\nstruct TypeMap&lt;ValueType, Types ... &gt; :\n    public Holder&lt;ValueType, Types ... &gt;\n{\n    template &lt;typename T&gt;\n    void set(const ValueType&amp; value)\n    {\n        ((Holder&lt;ValueType, T&gt;*)this)-&gt;value = value;\n    }\n\n    template &lt;typename T&gt;\n    ValueType get()\n    {\n        return ((Holder&lt;ValueType, T&gt;*)this)-&gt;value;\n    }\n};\n\n// Objectives\ntemplate &lt;typename Criterion&gt; struct Maximize : public Criterion {};\ntemplate &lt;typename Criterion&gt; struct Minimize : public Criterion {};\n\n// Criteria\nstruct Criterion1{ double operator()(){ return 0; }};\nstruct Criterion2{ double operator()(){ return 0; }};\n\n// Pareto rule\ntemplate &lt; typename ... Types &gt; struct Pareto;\n\ntemplate &lt; typename T, typename ... Types &gt;\nstruct Pareto&lt;Minimize&lt;T&gt;, Types ... &gt;\n{\n    template&lt; typename Map &gt;\n    bool operator()(Map&amp; oldResult, Map&amp; newResult)\n    {\n        typedef Minimize&lt;T&gt; Criterion;\n        Criterion criterion;\n\n        // ERROR HERE !!!\n        newResult.set&lt;Criterion&gt;( criterion() );\n\n        if(newResult.get&lt;Criterion&gt;() &gt;= oldResult.get&lt;Criterion&gt;())\n            return false;\n\n        Pareto&lt;Types ... &gt; pareto;\n        return pareto(oldResult, newResult);\n    }\n};\n\ntemplate &lt; typename T, typename ... Types &gt;\nstruct Pareto&lt;Maximize&lt;T&gt;, Types ... &gt;\n{\n    template&lt; typename Map &gt;\n    bool operator()(Map&amp; oldResult, Map&amp; newResult)\n    {\n        typedef Maximize&lt;T&gt; Criterion;\n        Criterion criterion;\n\n        // ERROR HERE !!!\n        newResult.set&lt;Criterion&gt;( criterion() );\n\n        if(newResult.get&lt;Criterion&gt;() &lt;= oldResult.get&lt;Criterion&gt;())\n            return false;\n\n        Pareto&lt;Types ... &gt; pareto;\n        return pareto(oldResult, newResult);\n    }\n};\n\ntemplate&lt;&gt;\nstruct Pareto&lt;&gt;\n{\n    template&lt;typename Map&gt;\n    bool operator()(Map&amp; oldResult, Map&amp; newResult)\n    {\n        oldResult = newResult;\n        return true;\n    }\n};\n\nint main()\n{\n    TypeMap&lt;double, Minimize&lt;Criterion1&gt;, Maximize&lt;Criterion2&gt;&gt; oldResult, newResult;\n\n    Pareto&lt;Minimize&lt;Criterion1&gt;, Maximize&lt;Criterion2&gt;&gt; pareto;\n    pareto(oldResult, newResult);\n}\n</code></pre>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "1062636", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8256636_8256685_0": {"section_id": 73, "quality": 0.875, "length": 21}}, "n3337": {"so_8256636_8256685_0": {"section_id": 68, "quality": 0.875, "length": 21}}, "n4659": {"so_8256636_8256685_0": {"section_id": 75, "quality": 0.875, "length": 21}}}});