post_cb({"31664064": {"ViewCount": "64", "Body": "<p>According to the standard, polymorphism with a missing virtual destructor leads to undefined behavior. In practice, it really leads to the destructor for the derived class not being called when the parent class is deleted. However, does it also lead to memory leaks in any common compilers/systems? I'm particularly interested in <code>g++</code> on Android/Linux.</p>\n<p>Specifically, I'm referring to whether the deletion of memory <em>for the derived class</em> will somehow leak. Consider:</p>\n<pre><code>class Base {}\nclass Derived {\n    int x;\n}\n</code></pre>\n<p>If I delete a <code>Base*</code> to a <code>Derived</code>, will I leak 4 bytes? Or does the memory allocator already know how many bytes to free based on the allocation?</p>\n", "AcceptedAnswerId": "31664134", "Title": "Missing Virtual Destructor Memory Effects", "CreationDate": "2015-07-27T21:59:55.733", "Id": "31664064", "CommentCount": "2", "LastEditDate": "2015-07-27T22:13:28.643", "PostTypeId": "1", "LastEditorUserId": "2460632", "LastActivityDate": "2015-07-27T22:38:55.397", "Score": "0", "OwnerUserId": "2460632", "Tags": "<android><c++><virtual>", "AnswerCount": "3"}, "31664151": {"Id": "31664151", "PostTypeId": "2", "Body": "<p>A missing destructor will cause undefined behavior specifically because it's implausible for the compiler to know exactly what the side effects might be.</p>\n<p>Think of it as the cleanup side of RAII. In that case, if you manage to not clean up despite claiming that you did, side effects might be:</p>\n<ul>\n<li>Leaked memory (you allocated something... when do you deallocate it now?)</li>\n<li>Deadlocks (you locked something... when do you unlock it now?)</li>\n<li>Sockets remaining open (you opened it sometime... but now when do you close it?)</li>\n<li>Files remaining open (you opened it sometime... but now when do you flush it?)</li>\n<li>Accessing invalid pointers (for example, you updated a pointer to some member... but now when do you unset it?)</li>\n<li>Your hard drive gets erased (technically this is a valid answer for <em>any</em> undefined behavior)</li>\n</ul>\n", "LastActivityDate": "2015-07-27T22:07:39.657", "CommentCount": "2", "CreationDate": "2015-07-27T22:07:39.657", "ParentId": "31664064", "Score": "0", "OwnerUserId": "1111557"}, "31664134": {"Id": "31664134", "PostTypeId": "2", "Body": "<p>It certainly can do. Consider:</p>\n<pre><code>class A\n{\npublic:\n virtual void func() {}\n};\n\nclass B : public A\n{\npublic:\n   void func() { s = \"Some Long String xxxxxx\"; }\nprivate:\n   std::string s;\n   // destructor of B will call `std::string` destructor.\n};\n\nA* func(bool b)\n{\n   if (b)\n       return new B;\n   return new A;\n}\n\n... \n   A* a = func(true);\n...\n   delete a;\n</code></pre>\n<p>Now, this will create a memory leak, as <code>std::string s</code> in the <code>B</code> object is not freed by <code>A::~A</code> - you need to call <code>B::~B</code>, which will only happen if the destructor is virtual. </p>\n<p>Note that this applies to ALL compilers and all runtime systems that I'm aware of (which is all the common ones and some not so common ones).</p>\n<p><strong>Edit:</strong> </p>\n<p>Based on the updated actual question: Memory de-allocation happens based on the allocated size, so if you can GUARANTEE that there NEVER is a single allocation happening because of the construction/use of the class, then it's safe to not have a virtual destructor. However, this leads to interesting issues if a \"customer\" of the base-class can make his/her own extension classes. Marking derived classes as <code>final</code> will protect against them being further derived, but if the base class is visible in a header-file that others can include, then you run the risk of someone deriving their own class from <code>Base</code> that does something that allocates.</p>\n<p>So, in other words, in something like a <code>PImpl</code>, where the <code>Impl</code> class is hidden inside a source file that nobody else derives from, it's plausible to have this. For most other cases, probably a bad idea.</p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2015-07-27T22:25:43.350", "Score": "3", "CreationDate": "2015-07-27T22:05:40.483", "ParentId": "31664064", "CommentCount": "2", "OwnerUserId": "1919155", "LastEditDate": "2015-07-27T22:25:43.350"}, "bq_ids": {"n4140": {"so_31664064_31664530_0": {"length": 41, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_31664064_31664530_0": {"length": 41, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_31664064_31664530_0": {"length": 41, "quality": 1.0, "section_id": 7604}}}, "31664530": {"Id": "31664530", "PostTypeId": "2", "Body": "<p>This should cause Undefined Behaviour which means it might also cause memory leaks. In 5.3.5/3 (n4296 c++14) for <code>delete</code> you have:</p>\n<blockquote>\n<p id=\"so_31664064_31664530_0\">In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete\n  array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2015-07-27T22:38:55.397", "CommentCount": "0", "CreationDate": "2015-07-27T22:38:55.397", "ParentId": "31664064", "Score": "0", "OwnerUserId": "471160"}});