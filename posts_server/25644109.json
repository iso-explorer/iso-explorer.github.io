post_cb({"25644665": {"ParentId": "25644109", "CommentCount": "0", "Body": "<p>Mike Seymour already answered why it doesn't work, here's how to workaround it:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;boost/utility.hpp&gt;\n\nstruct some_policy {\n    typedef boost::integral_constant&lt;bool, false&gt; condition;\n};\n\nstruct other_policy {\n    typedef boost::integral_constant&lt;bool, true&gt; condition;\n};\n\ntemplate &lt;typename policy&gt;\nclass test {\nprivate:\n\n   template&lt;typename P&gt;\n   void do_something_impl(typename boost::enable_if&lt;typename P::condition&gt;::type* = 0) {}\n\npublic:\n   void do_something()\n   {\n       do_something_impl&lt;policy&gt;();      \n   }\n};\n\nint main() {\n    test&lt;other_policy&gt; p1;\n    test&lt;some_policy&gt;  p2;\n}\n</code></pre>\n<p>Quick rule of thumb: If you want to do SFINAE, you need a member function <em>template</em>.</p>\n", "OwnerUserId": "947836", "PostTypeId": "2", "Id": "25644665", "Score": "6", "CreationDate": "2014-09-03T12:43:35.917", "LastActivityDate": "2014-09-03T12:43:35.917"}, "25644109": {"CommentCount": "0", "ViewCount": "438", "CreationDate": "2014-09-03T12:17:19.383", "LastActivityDate": "2014-09-03T14:02:04.023", "Title": "Are members of a class template instantiated when the class is instantiated?", "AcceptedAnswerId": "25644427", "PostTypeId": "1", "Id": "25644109", "Score": "9", "Body": "<p>Supposedly members of a template class shouldn't be instantiated unless they are used.\nHowever this sample seems to instantiate the <code>do_something</code> member and the <code>enable_if</code> fails (which would be expected if we'd instantiated it - but AFAIK we did not).</p>\n<p>Am I missing something really basic here?</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;boost/utility.hpp&gt;\n\nstruct some_policy {\n    typedef boost::integral_constant&lt;bool, false&gt; condition;\n};\n\nstruct other_policy {\n    typedef boost::integral_constant&lt;bool, true&gt; condition;\n};\n\n\ntemplate &lt;typename policy&gt;\nclass test {\n   void do_something(typename boost::enable_if&lt;typename policy::condition&gt;::type* = 0) {}\n};\n\nint main() {\n    test&lt;other_policy&gt; p1;\n    test&lt;some_policy&gt;  p2;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a06163a630cbdb41\">coliru</a></p>\n", "Tags": "<c++><c++98>", "OwnerUserId": "996886", "AnswerCount": "3"}, "25644243": {"ParentId": "25644109", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>SFINAE happens only on template function/method (here, it is your class which is template),</p>\n<p>You may do in C++11 (default template parameter for function/method):</p>\n<pre><code>template &lt;typename policy&gt;\nclass test {\n   template &lt;typename T = policy&gt;\n   void do_something(typename boost::enable_if&lt;typename T::condition&gt;::type* = 0) {}\n};\n</code></pre>\n<p>You may alternatively use specialization, something like</p>\n<pre><code>template &lt;bool&gt; struct helper_do_something {};\ntemplate &lt;&gt; struct helper_do_something&lt;true&gt;\n{\n    void do_something() { /* Your implementation */ }\n};\n\ntemplate &lt;typename policy&gt;\nclass test : helper_do_something&lt;T::condition::value&gt;\n{\n    // do_something is inherited (and it is present only when T::condition::value is true)\n};\n</code></pre>\n", "OwnerUserId": "2684539", "LastEditorUserId": "2684539", "LastEditDate": "2014-09-03T14:02:04.023", "Id": "25644243", "Score": "4", "CreationDate": "2014-09-03T12:23:39.573", "LastActivityDate": "2014-09-03T14:02:04.023"}, "bq_ids": {"n4140": {"so_25644109_25644427_0": {"section_id": 233, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_25644109_25644427_0": {"section_id": 226, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_25644109_25644427_0": {"section_id": 243, "quality": 0.9411764705882353, "length": 16}}}, "25644427": {"ParentId": "25644109", "CommentCount": "2", "Body": "<p>From C++11 14.7.1/1:</p>\n<blockquote>\n<p id=\"so_25644109_25644427_0\">The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of the class member functions</p>\n</blockquote>\n<p>So the function declaration is instantiated; that fails since it depends on an invalid type.</p>\n<p><sub>(Unfortunately, I don't have any historic versions of the standard to hand, but I imagine this rule was similar in C++98)</sub></p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "25644427", "Score": "8", "CreationDate": "2014-09-03T12:32:33.523", "LastActivityDate": "2014-09-03T12:32:33.523"}});