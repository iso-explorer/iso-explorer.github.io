post_cb({"31989455": {"ParentId": "24104814", "CommentCount": "0", "Body": "<p>Going to answer the asked question here instead of addressing the problem with the op's code. Especially since this took me a while to figure out.</p>\n<p><a href=\"https://gist.github.com/rstackhouse/67087c47a197dd70edd\" rel=\"nofollow\">Use a string in a function invocation in lldb in C++</a></p>\n<p>(This post helped greatly, and is a good read: <a href=\"http://www.objc.io/issues/19-debugging/lldb-debugging/\" rel=\"nofollow\">Dancing in The Debugger</a>)</p>\n", "OwnerUserId": "726378", "PostTypeId": "2", "Id": "31989455", "Score": "0", "CreationDate": "2015-08-13T13:20:04.227", "LastActivityDate": "2015-08-13T13:20:04.227"}, "24105421": {"ParentId": "24104814", "PostTypeId": "2", "CommentCount": "7", "Body": "<h3>THE PROBLEM</h3>\n<p>This is due to a subtle problem with your code, that boils down to the following wording from the C++ Standard:</p>\n<blockquote>\n<p id=\"so_24104814_24105421_0\"><code>7.1.2p3-4</code> <strong>Function specifiers</strong> <code>[dcl.fct.spec]</code></p>\n<blockquote>\n<p id=\"so_24104814_24105421_4\">A function defined within a class definition is an inline function.</p>\n<p id=\"so_24104814_24105421_5\">... </p>\n<p id=\"so_24104814_24105421_6\">An inline function shall be defined in every translation unit in which it is odr-used, and shall have exactly the same definition in every case (3.2).</p>\n</blockquote>\n</blockquote>\n<p>Your constructor, <code>lldbtest(std::string)</code> is defined within the body of <code>lldbtest</code> which means that it will <em>implicitly</em> be inline, which further means that the compiler will not generate any code for it, unless it is used in the <em>translation unit</em>.</p>\n<p>Since the definition must be present in <em>every</em> translation unit that potentially calls it we can imagine the compiler saying; \"<em>heck, I don't need to do this.. if someone else uses it, they will generate the code</em>\".</p>\n<p><em>lldb</em> will look for a function definition which doesn't exist, since <code>gcc</code> didn't generate one; because you didn't use it.</p>\n<hr>\n<h3>THE SOLUTION</h3>\n<p>If we change the definition of <code>lldbtest</code> to the following I bet it will work as you intended:</p>\n<pre><code>struct lldbtest{\n  int bar=5;\n  lldbtest();\n  lldbtest(int foo);\n  lldbtest(string fum);\n};\n\nlldbtest::lldbtest() { bar=6; }\nlldbtest::lldbtest(int) { bar=7; }\nlldbtest::lldbtest(string) { bar=8; }\n</code></pre>\n<hr>\n<p><strong>But.. what about</strong> <code>p lldbtest(name)</code><strong>?</strong></p>\n<p>The command <code>p</code> in <code>lldb</code> is used to <code>print*</code> information, but it can also be used to evaluate <em>expressions</em>.</p>\n<p><code>lldbtest(name)</code> will not call the constructor of <code>lldbtest</code> with a variable called <em>name</em>, it's equivalent of <strong>declaring</strong> a variable called <em>name</em> of type <code>lldbtest</code>; ie. <code>lldbtest name</code> is sementically equivalent.</p>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-08T10:59:27.037", "Id": "24105421", "Score": "2", "CreationDate": "2014-06-08T10:53:54.773", "LastActivityDate": "2014-06-08T10:59:27.037"}, "bq_ids": {"n4140": {"so_24104814_24105421_4": {"section_id": 5403, "quality": 1.0, "length": 7}, "so_24104814_24105421_3": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_24104814_24105421_1": {"section_id": 5403, "quality": 1.0, "length": 7}, "so_24104814_24105421_6": {"section_id": 5404, "quality": 1.0, "length": 13}}, "n3337": {"so_24104814_24105421_4": {"section_id": 5198, "quality": 1.0, "length": 7}, "so_24104814_24105421_3": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_24104814_24105421_1": {"section_id": 5198, "quality": 1.0, "length": 7}, "so_24104814_24105421_6": {"section_id": 5199, "quality": 1.0, "length": 13}}, "n4659": {"so_24104814_24105421_4": {"section_id": 6851, "quality": 1.0, "length": 7}, "so_24104814_24105421_3": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_24104814_24105421_6": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_24104814_24105421_1": {"section_id": 6851, "quality": 1.0, "length": 7}}}, "24104814": {"CommentCount": "0", "AcceptedAnswerId": "24105421", "PostTypeId": "1", "LastEditorUserId": "3597589", "CreationDate": "2014-06-08T09:35:20.620", "LastActivityDate": "2015-08-13T13:20:04.227", "LastEditDate": "2014-06-08T09:38:46.460", "ViewCount": "1024", "FavoriteCount": "1", "Title": "Invoking function with string argument with lldb: how?", "Id": "24104814", "Score": "3", "Body": "<p>I am unable to use lldb to invoke simple, non-templated functions that take string arguments. Is there any way to get lldb to understand the C++ datatype \"string\", which is a commonly used datatype in C++ programs?</p>\n<p>The sample source code here just creates a simple class with a few constructors, and then calls them (includes of \"iostream\" and \"string\" omitted):</p>\n<pre><code>using namespace std;\n\nstruct lldbtest{\n  int bar=5;\n  lldbtest(){bar=6;}\n  lldbtest(int foo){bar=foo;}\n  lldbtest(string fum){bar=7;}\n};\n\nint main(){\n  string name=\"fum\";\n  lldbtest x,y(3);\n  cout&lt;&lt;x.bar&lt;&lt;y.bar&lt;&lt;endl;\n  return 0;\n}\n</code></pre>\n<p>When compiled on Mac Maverick with </p>\n<pre><code>g++ -g -std=c++11 -o testconstructor testconstructor.cpp\n</code></pre>\n<p>the program runs and prints the expected output of \"63\".</p>\n<p>However, when a breakpoint is set in main just before the return statement, and attempt to invoke the constructor fails with a cryptic error message:</p>\n<pre><code>p lldbtest(string(\"hey there\"))\nerror: call to a function              'lldbtest::lldbtest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;)' ('_ZN8lldbtestC1ENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE') that is not present in the target\nerror: The expression could not be prepared to run in the target\n</code></pre>\n<p>Possibly relevant as well, the command:</p>\n<pre><code> p lldbtest(name)\n</code></pre>\n<p>prints nothing at all.</p>\n<p>Also, calling the constructor with a string literal also failed, the standard way:</p>\n<pre><code>p lldbtest(\"foo\")\n</code></pre>\n<p>gives a similar long error:</p>\n<pre><code> error: call to a function \n'lldbtest::lldbtest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;)' ('_ZN8lldbtestC1ENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE') that is not present in the targeterror: The expression could not be prepared to run in the target\n</code></pre>\n<p>Is there any way to get lldb to understand and use the C++ \"string\" datatype? I have a number of functions taking string arguments and need a way to invoke these functions from the debugger. On a Mac.</p>\n", "Tags": "<c++><string><c++11><lldb>", "OwnerUserId": "3597589", "AnswerCount": "2"}});