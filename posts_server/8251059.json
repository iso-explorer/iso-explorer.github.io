post_cb({"24914464": {"Id": "24914464", "PostTypeId": "2", "Body": "<p>This code produces errors where expected:</p>\n<pre><code>constexpr int a = 255;\nunsigned char b = a;      // OK\nunsigned char c = a + 1;  // Error... expected\n</code></pre>\n<p>This results in a narrowing error because:<br>\n1. (a + 1) results in an int rvalue<br>\n2.  the rvalue does not fit in the valid range of the char type</br></br></p>\n<pre><code>int d = 256;\nunsigned char e = d;  // Maybe OK because 'd' is not constexpr\n</code></pre>\n<p>This code is not an rvalue being narrowed. It's an implicit cast from int to unsigned char. </p>\n", "LastActivityDate": "2014-07-23T15:19:16.103", "CommentCount": "0", "CreationDate": "2014-07-23T15:19:16.103", "ParentId": "8251059", "Score": "0", "OwnerUserId": "1272843"}, "bq_ids": {"n4140": {"so_8251059_8251081_0": {"length": 7, "quality": 0.7, "section_id": 3329}, "so_8251059_8251075_0": {"length": 19, "quality": 0.76, "section_id": 37}}, "n3337": {"so_8251059_8251081_0": {"length": 7, "quality": 0.7, "section_id": 3199}, "so_8251059_8251075_0": {"length": 19, "quality": 0.76, "section_id": 34}}, "n4659": {"so_8251059_8251081_0": {"length": 7, "quality": 0.7, "section_id": 4095}, "so_8251059_8251075_0": {"length": 18, "quality": 0.72, "section_id": 37}}}, "8251075": {"Id": "8251075", "PostTypeId": "2", "Body": "<p>Floating points can get converted to ints:</p>\n<blockquote>\n<p id=\"so_8251059_8251075_0\">A prvalue of a \ufb02oating point type can be converted to a prvalue of an integer type. The conversion trun-\n  cates; that is, the fractional part is discarded. The behavior is unde\ufb01ned if the truncated value cannot be\n  represented in the destination type.</p>\n</blockquote>\n<pre><code>int f = 42.0;  // Equal to 42, 42 fits into int\nint g = 42.1;  // Equal to 42, 42 fits\nconstexpr float h = 42.7;\nint i = h;     // 42\n</code></pre>\n<p>Narrowing rules only applies to initializer lists.</p>\n<pre><code>unsigned char c = { 2.4 }; // narrowing\n\nwarning: narrowing conversion of \u20182.3999999999999999e+0\u2019 from \u2018double\u2019 to \u2018unsigned char\u2019 inside { } [-Wnarrowing]\n</code></pre>\n", "LastEditorUserId": "964135", "LastActivityDate": "2011-11-24T01:10:36.350", "Score": "1", "CreationDate": "2011-11-24T00:57:58.123", "ParentId": "8251059", "CommentCount": "3", "OwnerUserId": "964135", "LastEditDate": "2011-11-24T01:10:36.350"}, "8251081": {"Id": "8251081", "PostTypeId": "2", "Body": "<p>To be honest, with your samples I see little wrong.</p>\n<p>However, there are a number of cases where the compiler seems to accept 'violations' of the standard conversion rules...:</p>\n<h3>Initializer lists (\u00a7 8.5.4)</h3>\n<p>However I spotted this one in the standard: </p>\n<p>For initialzer lists, the following is not allowed (\u00a7 8.5.4, under <strong>3.</strong>)</p>\n<pre><code>int ai[] = { 1, 2.0 }; // error narrowing\n</code></pre>\n<p>Under <strong>6.</strong> it goes on to give a general list of examples:</p>\n<blockquote>\n<p id=\"so_8251059_8251081_0\"><em>[ Note: As indicated above, such conversions are not allowed at the top level in list-initializations.\u2014end\n  note ]</em></p>\n</blockquote>\n<pre><code>int x = 999; // x is not a constant expression\nconst int y = 999;\nconst int z = 99;\nchar c1 = x; // OK, though it might narrow (in this case, it does narrow)\nchar c2{x}; // error: might narrow\nchar c3{y}; // error: narrows (assuming char is 8 bits)\nchar c4{z}; // OK: no narrowing needed\nunsigned char uc1 = {5}; // OK: no narrowing needed\nunsigned char uc2 = {-1}; // error: narrows\nunsigned int ui1 = {-1}; // error: narrows\nsigned int si1 =\n{ (unsigned int)-1 }; // error: narrows\nint ii = {2.0}; // error: narrows\nfloat f1 { x }; // error: might narrow\nfloat f2 { 7 }; // OK: 7 can be exactly represented as a float\nint f(int);\nint a[] = { 2, f(2), f(2.0) }; // OK: the double-to-int conversion is not at the top level\n</code></pre>\n<p>Interestingly, g++ 4.6.1 with <code>--std=c++0x -Wall -pedantic</code> catches <strong>only one</strong> of these violations:</p>\n<pre><code>    char c3{y}; // warning: overflow in implicit constant conversion [-Woverflow]\n</code></pre>\n<hr>\n<h3>Outside initializer lists...</h3>\n<p>I don't think the truncation of a float to an int is considered <code>narrowing</code>. </p>\n<p>It is just a well-defined conversion, much like</p>\n<pre><code>int i = 31;\ni /= 4;   // well defined loss of precision...   \ni /= 4.0; // equally well-defined conversion from floating point to int\n</code></pre>\n</hr>", "LastEditorUserId": "85371", "LastActivityDate": "2011-11-24T01:09:33.723", "Score": "9", "CreationDate": "2011-11-24T00:58:28.840", "ParentId": "8251059", "CommentCount": "4", "OwnerUserId": "85371", "LastEditDate": "2011-11-24T01:09:33.723"}, "8251059": {"ViewCount": "4725", "Body": "<p>The concept of narrowing seems pretty straight-forward. However, could someone please explain why some of the code below causes \"narrowing\" compiler errors and others don't?</p>\n<p>This code produces errors where expected:</p>\n<pre><code>constexpr int a = 255;\nunsigned char b = a;      // OK\nunsigned char c = a + 1;  // Error... expected\n</code></pre>\n<p>This code doesn't produce errors, but may be ok:</p>\n<pre><code>int d = 256;\nunsigned char e = d;  // Maybe OK because 'd' is not constexpr\n</code></pre>\n<p>This code should generate errors (unless I'm missing something):</p>\n<pre><code>int f = 42.0;  // Maybe OK because no fractional part\nint g = 42.1;  // OK... should fail!!\nconstexpr float h = 42.7;\nint i = h;     // OK... should fail???\n</code></pre>\n<p>I'm using g++ 4.6.2. I searched the GCC bug database and didn't find anything related. Thanks!</p>\n", "AcceptedAnswerId": "8251081", "Title": "C++11 Variable narrowing with no GCC compiler warning", "CreationDate": "2011-11-24T00:54:51.137", "Id": "8251059", "CommentCount": "5", "LastEditDate": "2011-11-24T00:57:17.993", "PostTypeId": "1", "LastEditorUserId": "46642", "LastActivityDate": "2014-07-23T15:19:16.103", "Score": "4", "OwnerUserId": "228408", "Tags": "<c++><c++11>", "AnswerCount": "3"}});