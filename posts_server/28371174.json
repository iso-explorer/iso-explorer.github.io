post_cb({"28371621": {"Id": "28371621", "PostTypeId": "2", "Body": "<pre><code>const B&amp; b = a;\n</code></pre>\n<p>doesn't invoke <code>A::operator const B&amp;()</code>. This behavior exists since C++03 days.<br>\nIt's a simple <strong>upcasting</strong> which happens from a derived type to a base type. This upcasting throws compiler error because the base (<code>class B</code>) is privately inherited by the derived (<code>class A</code>) in a global scope.</br></p>\n<p>Had there been no such inheritance relationship between <code>B</code> and <code>A</code>, then definitely the mentioned <code>operator const B&amp;()</code> would have been instantiated as per your expectation.</p>\n", "LastActivityDate": "2015-02-06T17:41:29.567", "CommentCount": "0", "CreationDate": "2015-02-06T17:41:29.567", "ParentId": "28371174", "Score": "3", "OwnerUserId": "514235"}, "bq_ids": {"n4140": {"so_28371174_28371523_2": {"length": 20, "quality": 1.0, "section_id": 3321}, "so_28371174_28371523_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_28371174_28371523_1": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_28371174_28371523_3": {"length": 33, "quality": 0.7674418604651163, "section_id": 3320}}, "n3337": {"so_28371174_28371523_2": {"length": 20, "quality": 1.0, "section_id": 3191}, "so_28371174_28371523_3": {"length": 33, "quality": 0.7674418604651163, "section_id": 3190}, "so_28371174_28371523_1": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_28371174_28371523_0": {"length": 8, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_28371174_28371523_2": {"length": 20, "quality": 1.0, "section_id": 4087}, "so_28371174_28371523_3": {"length": 39, "quality": 0.9069767441860465, "section_id": 4086}, "so_28371174_28371523_1": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_28371174_28371523_0": {"length": 8, "quality": 1.0, "section_id": 4087}}}, "28371523": {"Id": "28371523", "PostTypeId": "2", "Body": "<p>[dcl.init.ref]/5:</p>\n<blockquote>\n<p id=\"so_28371174_28371523_0\">A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of\n  type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n<ul>\n<li><p id=\"so_28371174_28371523_1\">If the reference is an lvalue reference and the initializer\n  expression</p>\n<ul>\n<li>is an lvalue (but is not a bit-field), and \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>,\u201d or</li>\n<li>has a class type (i.e., <code>T2</code> is a class type), <strong>where <code>T1</code> is not reference-related to <code>T2</code></strong>, [..]</li>\n</ul>\n<p id=\"so_28371174_28371523_2\">then the reference is bound to the initializer expression lvalue in\n  the first case and to the lvalue result of the conversion in the\n  second case (or, in either case, to the appropriate base class\n  subobject of the object).</p></li>\n</ul>\n</blockquote>\n<p>The conversion function would be covered in the second bullet point. However, <code>B</code> is reference-related to (and -compatible with) <code>A</code> even though it's a private base class, so the first bullet point applies. Now [dcl.init.ref]/4 defines this scenario to be ill-formed:</p>\n<blockquote>\n<p id=\"so_28371174_28371523_3\">Given types \u201c<em>cv1</em> <code>T1</code>\u201d and \u201c<em>cv1</em> <code>T2</code>\u201d, \u201c<em>cv1</em> <code>T1</code>\u201d is\n  <em>reference-related</em> to \u201c<em>cv1</em> <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code>,\n  or <code>T1</code> is a base class of <code>T2</code>. \u201c<em>cv1</em> <code>T1</code>\u201d is <em>reference-compatible</em> with \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is reference-related to <code>T2</code> and <em>cv1</em>\n                        is the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>. <strong>In all cases where the reference-related\n                           or reference-compatible relationship of two types is used to establish the validity of a reference binding, and\n                          <code>T1</code> is a base class of <code>T2</code>, a program that necessitates such a binding is ill-formed if <code>T1</code> is an inaccessible [..] base class of <code>T2</code></strong>.</p>\n</blockquote>\n<p>Such reference bindings will thus always fail, regardless of any conversion functions available. Reference binding cannot work with private inheritance. </p>\n<p>Your explicit call is the solution of this problem, though there is no need for a conversion operator anymore: Simply define a getter that returns a <code>const</code>-reference. E.g.</p>\n<pre><code>const B&amp; b = a.getB();\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-02-06T17:59:18.967", "Score": "5", "CreationDate": "2015-02-06T17:35:39.527", "ParentId": "28371174", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-02-06T17:59:18.967"}, "28371174": {"ViewCount": "133", "Body": "<p>I would like to have a class which allows access to the const interface of it's base case, but not otherwise.  In particular:</p>\n<pre><code>class B\n{};\n\nclass A : private class B\n{\npublic:\n  operator const B&amp;() { return *this; }\n};\n\nint main()\n{\n  A a;\n  const B&amp; b = a; // Should this line be an error?\n}\n</code></pre>\n<p>g++ gives an inaccessible base class error.  Do you language experts out there think that this error is correct in C++11/C++14?</p>\n<p>And yes, I realize I can (and will) just do this:</p>\n<pre><code>int main()\n{\n  A a;\n  const B&amp; b = a.operator const B&amp;();\n}\n</code></pre>\n<p>Any suggestions on another method for this construct? </p>\n", "Title": "Should a operator const Base&() be used for an inaccessible base class?", "CreationDate": "2015-02-06T17:15:56.997", "LastActivityDate": "2015-02-06T18:01:12.563", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "28371174", "Score": "5", "OwnerUserId": "3233529", "Tags": "<c++><c++11><c++14>", "AnswerCount": "3"}, "28371626": {"Id": "28371626", "PostTypeId": "2", "Body": "<p>The error is correct. An implicit conversion (in this case, via your operator) is only considered if the types are not reference-related. The inheritance relationship means they are, so the reference would bind directly without conversion, but that fails due to the private inheritance.</p>\n<p>Unless you have a good reason for inheritance, you might make the <code>A</code> a member rather than a base class. In that case, a conversion operator returning a reference to that member would do what you want.</p>\n<p>If you do need the inheritance, then a suitably named function might be nicer than requiring an explicit operator call.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2015-02-06T18:00:47.667", "Score": "2", "CreationDate": "2015-02-06T17:41:37.540", "ParentId": "28371174", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2015-02-06T18:00:47.667"}});