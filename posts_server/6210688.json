post_cb({"6210726": {"ParentId": "6210688", "CommentCount": "5", "CreationDate": "2011-06-02T05:18:28.747", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "6210726", "Score": "4", "Body": "<p>I guess this would be safe:</p>\n<pre><code>std::vector&lt;int&gt; a(1);\na.push_back(1);\na.push_back(int(a[0]));\n</code></pre>\n", "LastActivityDate": "2011-06-02T05:18:28.747"}, "6212163": {"ParentId": "6210688", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2011-06-02T08:29:48.773", "Score": "5", "LastEditorUserId": "36565", "LastEditDate": "2011-10-03T11:21:37.047", "Id": "6212163", "OwnerUserId": "36565", "Body": "<p><strong>EDIT</strong>: Technically, the standard does not mandate that this is correct if the contained type has a no-throw copy constructor. I don't know any implementation where this does not hold anyway, as it would require producing two implementations of <code>push_back</code> when the generic one is just as efficient in all cases.</p>\n<p>Aliasing is a problem in general, but not in this particular case. The code:</p>\n<pre><code>assert( v.size() &gt; 0 );\nv.push_back( v[0] );\n</code></pre>\n<p>Is guaranteed to be correct by the standard (C++03) through the exception guarantees (which are a really good reason not to implement your own containers, you will probably not get them right). In particular \u00a723.1 [lib.container.requirements] / 10 dictattes:</p>\n<blockquote>\n<p id=\"so_6210688_6212163_0\">Unless otherwise specified (see 23.2.1.3 and 23.2.4.3) [<em>NOTE: both those references refer to <code>insert</code> on <code>deque</code> and <code>vector</code> respectively</em>] all container types defined in this clause meet the following additional requirements:</p>\n<p id=\"so_6210688_6212163_1\">\u2014 if an exception is thrown by a push_back() or push_front() function, that function has <strong>no effects</strong>.</p>\n</blockquote>\n<p>Where the important bit is that if <em>any</em> exception is thrown in the operation, the container is left <strong>untouched</strong>, and that means that no iterator gets invalidated, which in turns means that the original region of memory is left untouched until it is guaranteed that no exceptions will be thrown (with the <em>exception</em> pun intended, of destructors). Because in general copy constructors <em>can</em> throw, the implementation must ensure that all copies are performed before destroying any object.</p>\n<p>This becomes more evident in C++0x, when objects are not copied from one location to another, but rather <em>moved</em>. Because the copy of the new element might throw, it has to be performed <em>before</em> any of the moves are executed, or else you would be left in a situation where some of the objects in the original container have been invalidated.</p>\n", "LastActivityDate": "2011-10-03T11:21:37.047"}, "6210688": {"CommentCount": "9", "ViewCount": "295", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-02T05:13:40.697", "LastActivityDate": "2011-10-03T11:21:37.047", "Title": "What is the \"right\" way to avoid Aliasing (e.g. when adding an element of a container to itself) in C++?", "FavoriteCount": "2", "LastEditDate": "2017-05-23T12:09:17.770", "Id": "6210688", "Score": "11", "Body": "<pre><code>std::vector&lt;int&gt; a;\na.push_back(1);\na.push_back(a[0]);\n</code></pre>\n<p>I <a href=\"https://stackoverflow.com/questions/4705593/int-vs-const-int/4705871#4705871\">just learned</a> that the code above can be very dangerous.</p>\n<p>(If it's not obvious why, you're not alone... it wasn't obvious to me either.)</p>\n<h3>My questions:</h3>\n<ol>\n<li><p>What is the \"standard\" way of dealing with it? Making a new variable and then assigning it immediately to something afterward seems a bit weird to me. Is there a better way of dealing with it?</p></li>\n<li><p><strong>How do you train yourself</strong> to watch out for aliasing issues like this? What pattern(s) do you look for? I have no idea to recognize this situation; I only learned about aliasing when I learned about the <code>restrict</code> keyword in C, and only now do I understand what the issue really is.</p></li>\n</ol>\n<hr>\n<h2>Edit:</h2>\n<p>I'd love to accept an answer, but it doesn't seem like part (2) of the question has been answered. I'm wondering what strategies people use to locate aliasing mistakes in code they have written.</p>\n<p>One strategy I've come up with so far is to avoid passing in the same value for in two parameters. (In this case, one parameter is implicit and one explicit.)</p>\n<p>Are there any other easy things to notice and watch out for?</p>\n</hr>", "Tags": "<c++><lifetime><aliasing>", "OwnerUserId": "541686", "AnswerCount": "5"}, "6222176": {"ParentId": "6210688", "CommentCount": "3", "CreationDate": "2011-06-03T01:45:14.117", "OwnerUserId": "131930", "PostTypeId": "2", "Id": "6222176", "Score": "0", "Body": "<p>This probably isn't a useful answer for you, but IMHO the \"right\" way is that the container class should handle aliasing correctly, so that the caller doesn't have to worry about it.  In particular, push_back() (or equivalent) should do the following:</p>\n<pre><code>// C++-ish pseudo-code, exception-safety left as an exercise for the reader\nvoid push_back(const T &amp; t)\n{\n   if (current_size == alloced_size)\n   {\n      // Oops, our data array is full.  Time to trade it in for a bigger one\n      T * newArray = new T[alloced_size*2];\n      copy_items(newArray, current_array, current_size);\n      newArray[current_size++] = t;\n      delete [] current_array;    // delete old array only AFTER all references to t\n      current_array = new_array;\n      alloced_size *= 2;\n   }\n   else current_array[current_size++] = t;\n}\n</code></pre>\n", "LastActivityDate": "2011-06-03T01:45:14.117"}, "6210743": {"ParentId": "6210688", "CommentCount": "5", "CreationDate": "2011-06-02T05:20:56.210", "OwnerUserId": "421163", "PostTypeId": "2", "Id": "6210743", "Score": "0", "Body": "<p>In <code>push_back(const T&amp; el);</code> implementation to check if <code>el</code> is inside array or other internal storage. That is the only politically correct way of dealing with such problems. </p>\n<p>Container should handle this as different containers - different safety rules.</p>\n", "LastActivityDate": "2011-06-02T05:20:56.210"}, "6210727": {"ParentId": "6210688", "CommentCount": "2", "CreationDate": "2011-06-02T05:18:38.073", "OwnerUserId": "273088", "PostTypeId": "2", "Id": "6210727", "Score": "-2", "Body": "<p>I'm just winging this, so please don't consider it gospel, but would this work?</p>\n<pre><code>a.push_back(1);\na.push_back(&amp;(new int(a[0])));\n</code></pre>\n", "LastActivityDate": "2011-06-02T05:18:38.073"}, "bq_ids": {"n4140": {"so_6210688_6212163_1": {"section_id": 712, "quality": 1.0, "length": 7}}, "n3337": {"so_6210688_6212163_1": {"section_id": 701, "quality": 1.0, "length": 7}}, "n4659": {"so_6210688_6212163_1": {"section_id": 741, "quality": 1.0, "length": 7}}}});