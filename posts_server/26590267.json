post_cb({"26590267": {"CommentCount": "0", "AcceptedAnswerId": "26590268", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-10-27T14:50:23.100", "LastActivityDate": "2015-03-18T15:07:33.263", "LastEditDate": "2014-10-28T03:24:19.260", "ViewCount": "683", "FavoriteCount": "2", "Title": "Given that p is a pointer is \"p > nullptr\" well-formed?", "Id": "26590267", "Score": "21", "Body": "<p>Given a pointer <code>p</code>:</p>\n<pre><code>char *p ; // Could be any type\n</code></pre>\n<p>assuming <code>p</code> is properly initialized is the following well-formed:</p>\n<pre><code>if (p &gt; 0) // or p &gt; nullptr\n</code></pre>\n<p>More generally is it well-formed to use a relational operator when one operand is a pointer and the other is a null pointer constant? </p>\n", "Tags": "<c++><pointers><c++11><language-lawyer><c++14>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "26590268": {"ParentId": "26590267", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In C++14 this code is ill-formed but prior to the C++14 this was well-formed code(<em>but the result is unspecified</em>), as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3714.html#583\" rel=\"nofollow noreferrer\">defect report 583: Relational pointer comparisons against the null pointer constant</a> notes:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_0\">In C, this is ill-formed (cf C99 6.5.8):</p>\n<pre><code>void f(char* s) {\n    if (s &lt; 0) { }\n}\n</code></pre>\n<p id=\"so_26590267_26590268_1\">...but in C++, it's not. Why? Who would ever need to write (s &gt; 0)\n  when they could just as well write (s != 0)?</p>\n<p id=\"so_26590267_26590268_2\">This has been in the language since the ARM (and possibly earlier);\n  apparently it's because the pointer conversions (4.10 [conv.ptr]) need\n  to be performed on both operands whenever one of the operands is of\n  pointer type. So it looks like the \"null-ptr-to-real-pointer-type\"\n  conversion is hitching a ride with the other pointer conversions.</p>\n</blockquote>\n<p>In C++14 this was made ill-formed when <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3624.html\" rel=\"nofollow noreferrer\">N3624</a> was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3692.html\" rel=\"nofollow noreferrer\">applied to the draft C++14 standard</a>, which is a revision of <code>N3478</code>. The proposed resolution to <code>583</code> notes:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_3\">This issue is resolved by the resolution of issue 1512.</p>\n</blockquote>\n<p>and issue <code>1512</code> proposed resolution is <code>N3478</code>(<em>N3624 is a revision of N3478</em>):</p>\n<blockquote>\n<p id=\"so_26590267_26590268_4\">The proposed wording is found in document N3478.</p>\n</blockquote>\n<p><b>Changes to section 5.9 from C++11 to C++14</b></p>\n<p>Section <code>5.9</code> <em>Relational operators</em> changed a lot between the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11 draft standard</a> and the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow noreferrer\">C++14 draft standard</a>, the following highlights the most relevant differences (<em>emphasis mine going forward</em>), from paragraph <code>1</code>:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_5\">The operands shall have arithmetic, enumeration, or pointer type, <strong>or\n  type std::nullptr_t</strong>.</p>\n</blockquote>\n<p>changes to:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_6\">The operands shall have arithmetic, enumeration, or pointer type</p>\n</blockquote>\n<p>So the type <a href=\"http://en.cppreference.com/w/cpp/types/nullptr_t\" rel=\"nofollow noreferrer\">std::nullptr_t</a> is no longer a valid operand but that still leaves <code>0</code> which is a <em>null pointer constant</em> and therefore can be converted(<em>section <code>4.10</code></em>) to a <em>pointer type</em>.</p>\n<p>This is covered by paragraph <code>2</code> which in C++11 says:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_7\">[...]<strong>Pointer conversions</strong> (4.10) and qualification conversions (4.4)\n  are performed on pointer operands (<strong>or on a pointer operand and a null\n  pointer constant, or on two null pointer constants, at least one of\n  which is non-integral</strong>) to bring them to their composite pointer type.\n  If one operand is a null pointer constant, the composite pointer type\n  is std::nullptr_t if the other operand is also a null pointer constant\n  or, if the other operand is a pointer, the type of the other\n  operand.[...]</p>\n</blockquote>\n<p>this explicitly provides an exception for a <em>null pointer constant</em> operand, changes to the following in C++14:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_8\">The usual arithmetic conversions are performed on operands of\n  arithmetic or enumeration type. <strong>If both operands are pointers</strong>, pointer\n  conversions (4.10) and qualification conversions (4.4) are performed\n  to bring them to their composite pointer type (Clause 5). <strong>After\n  conversions, the operands shall have the same type.</strong></p>\n</blockquote>\n<p>In which there is no case that allows <code>0</code> to be converted to a <em>pointer type</em>. Both operands must be pointers in order for pointer conversions to be applied and it is required that the operands have the same type after conversions. Which is not satisfied in the case where one operand is a <em>pointer type</em> and the other is a <em>null pointer constant</em> <code>0</code>. </p>\n<p><b>What if both operands are pointers but one is a null pointer value?</b></p>\n<p>R Sahu asks, is the following code well-formed?:</p>\n<pre><code>char* p = \"\";\nchar* q = nullptr;\nif ( p &gt; q ) {}\n</code></pre>\n<p>Yes, in C++14 this code is well formed, both <code>p</code> and <code>q</code> are pointers but the result of the comparison is unspecified. The defined comparisons for two pointers is set out in paragraph <code>3</code> and says:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_9\">Comparing pointers to objects is defined as follows:</p>\n<ul>\n<li><p id=\"so_26590267_26590268_10\">If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher\n  subscript compares greater.</p></li>\n<li><p id=\"so_26590267_26590268_11\">If one pointer points to an element of an array, or to a subobject thereof, and another pointer points one past the last element of the\n  array, the latter pointer compares greater.</p></li>\n<li><p id=\"so_26590267_26590268_12\">If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the\n  pointer to the later declared member compares greater provided the two\n  members have the same access control (Clause 11) and provided their\n  class is not a union.</p></li>\n</ul>\n</blockquote>\n<p>Null pointers values are not defined here and later on in paragraph <code>4</code> it says:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_13\">[...]Otherwise, the result of each of the operators is unspecified.</p>\n</blockquote>\n<p>In C++11 it specifically makes the results unspecified in paragraph <code>3</code>:</p>\n<blockquote>\n<p id=\"so_26590267_26590268_14\">If two pointers p and q of the same type point to different objects\n  that are not members of the same object or elements of the same array\n  or to different functions, <strong>or if only one of them is null, the results\n  of p&lt;q, p&gt;q, p&lt;=q, and p&gt;=q are unspecified.</strong></p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-03-18T15:07:33.263", "Id": "26590268", "Score": "27", "CreationDate": "2014-10-27T14:50:23.100", "LastActivityDate": "2015-03-18T15:07:33.263"}, "bq_ids": {"n4140": {"so_26590267_26590268_11": {"section_id": 6151, "quality": 1.0, "length": 19}, "so_26590267_26590268_6": {"section_id": 6138, "quality": 0.8571428571428571, "length": 6}, "so_26590267_26590268_13": {"section_id": 6152, "quality": 1.0, "length": 5}, "so_26590267_26590268_10": {"section_id": 6151, "quality": 1.0, "length": 15}, "so_26590267_26590268_9": {"section_id": 6151, "quality": 1.0, "length": 5}, "so_26590267_26590268_5": {"section_id": 6154, "quality": 0.8888888888888888, "length": 8}, "so_26590267_26590268_12": {"section_id": 6151, "quality": 1.0, "length": 31}, "so_26590267_26590268_8": {"section_id": 6150, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_26590267_26590268_11": {"section_id": 5906, "quality": 0.5789473684210527, "length": 11}, "so_26590267_26590268_12": {"section_id": 5913, "quality": 1.0, "length": 31}, "so_26590267_26590268_13": {"section_id": 517, "quality": 0.8, "length": 4}, "so_26590267_26590268_14": {"section_id": 5913, "quality": 1.0, "length": 20}, "so_26590267_26590268_10": {"section_id": 5913, "quality": 0.8, "length": 12}, "so_26590267_26590268_5": {"section_id": 5912, "quality": 0.8888888888888888, "length": 8}, "so_26590267_26590268_7": {"section_id": 5913, "quality": 0.9574468085106383, "length": 45}, "so_26590267_26590268_8": {"section_id": 5913, "quality": 0.6774193548387096, "length": 21}, "so_26590267_26590268_6": {"section_id": 5902, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_26590267_26590268_13": {"section_id": 7649, "quality": 1.0, "length": 5}, "so_26590267_26590268_6": {"section_id": 7635, "quality": 0.8571428571428571, "length": 6}, "so_26590267_26590268_12": {"section_id": 7648, "quality": 1.0, "length": 31}, "so_26590267_26590268_11": {"section_id": 7638, "quality": 0.5263157894736842, "length": 10}, "so_26590267_26590268_10": {"section_id": 7648, "quality": 1.0, "length": 15}, "so_26590267_26590268_9": {"section_id": 7648, "quality": 1.0, "length": 5}, "so_26590267_26590268_5": {"section_id": 7651, "quality": 0.8888888888888888, "length": 8}, "so_26590267_26590268_8": {"section_id": 7647, "quality": 0.9354838709677419, "length": 29}}}});