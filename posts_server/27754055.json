post_cb({"27754523": {"Id": "27754523", "PostTypeId": "2", "Body": "<p>No it is not reliable, in C++11, just do</p>\n<pre><code>for (/* const */ Foo&amp; foo : data) {\n    // stuff with foo.\n}\n</code></pre>\n", "LastActivityDate": "2015-01-03T11:52:17.633", "CommentCount": "0", "CreationDate": "2015-01-03T11:52:17.633", "ParentId": "27754055", "Score": "0", "OwnerUserId": "2684539"}, "27754055": {"ViewCount": "83", "Body": "<p>Consider</p>\n<pre><code>Foo data[]={{...},{...},{...}};\nFoo data_end={...};\n</code></pre>\n<p>If the end marker is defined right after the array, is it guaranteed that</p>\n<pre><code>&amp;data[3]==&amp;data_end\n</code></pre>\n<p>I do not want having to count the number of elements in data manually.</p>\n<p>It happens to look OK in gdb without any optimization option, but before using it I need to know that the compiler cannot move <code>data_end</code>. If it can, how can I do instead.</p>\n", "AcceptedAnswerId": "27754228", "Title": "Memory layout of globals", "CreationDate": "2015-01-03T10:54:49.260", "Id": "27754055", "CommentCount": "1", "LastEditDate": "2015-01-03T11:30:47.953", "PostTypeId": "1", "LastEditorUserId": "2642204", "LastActivityDate": "2015-01-03T14:12:02.047", "Score": "0", "OwnerUserId": "877329", "Tags": "<c++><memory-layout>", "AnswerCount": "3"}, "27754228": {"Id": "27754228", "PostTypeId": "2", "Body": "<p>No. It is not a reliable assumption that the compiler places the variables in any order or any alignment. There can be gaps between the variables for alignment and I've already seen compilers that order variables alphabetically.</p>\n<p>If you want to know the pointer to the element that is <em>not</em> in the array you need to know the number of array elements.</p>\n<pre><code>#define _dimof(a) (sizeof(a)/sizeof(a[0]))\nFoo data[] = ... ;\n// The type of the variable has been changed.\nFoo* data_end = &amp;data[_dimof(data)];\n</code></pre>\n<p>You may remove this paragraph since it has been added in order to fix a syntax error in the code.</p>\n", "LastEditorUserId": "877329", "LastActivityDate": "2015-01-03T14:12:02.047", "Score": "1", "CreationDate": "2015-01-03T11:16:09.487", "ParentId": "27754055", "CommentCount": "2", "OwnerUserId": "266487", "LastEditDate": "2015-01-03T14:12:02.047"}, "bq_ids": {"n4140": {"so_27754055_27754244_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 6155}, "so_27754055_27754244_3": {"length": 33, "quality": 0.9166666666666666, "section_id": 7223}, "so_27754055_27754244_1": {"length": 12, "quality": 0.5714285714285714, "section_id": 6155}}, "n3337": {"so_27754055_27754244_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 5917}, "so_27754055_27754244_3": {"length": 33, "quality": 0.9166666666666666, "section_id": 6967}, "so_27754055_27754244_1": {"length": 15, "quality": 0.7142857142857143, "section_id": 5917}}, "n4659": {"so_27754055_27754244_2": {"length": 11, "quality": 0.6111111111111112, "section_id": 7652}, "so_27754055_27754244_3": {"length": 19, "quality": 0.5277777777777778, "section_id": 8732}}}, "27754244": {"Id": "27754244", "PostTypeId": "2", "Body": "<p>Not only what you request is not guaranteed, but moreover, a C++03-compliant implementation <em>must</em> ensure that <code>&amp;data[3] != &amp;data_end</code>:</p>\n<blockquote>\n<p id=\"so_27754055_27754244_0\">5.10 Equality operators[expr.eq] </p>\n<p id=\"so_27754055_27754244_1\">1 \u2026 Two pointers of the same type compare equal if and only if they are both null, both point to the same object or function, or both point one past the end of the same array.</p>\n</blockquote>\n<p>In C++11, it is a little more complicated:</p>\n<blockquote>\n<p id=\"so_27754055_27754244_2\">Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address (3.9.2).</p>\n</blockquote>\n<p>3.9.2 notes:</p>\n<blockquote>\n<p id=\"so_27754055_27754244_3\">\u2026 If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the address <code>A</code> is said to point to that object, regardless of how the value was obtained. [Note: for instance, the address one past the end of an array (5.7) would be considered to point to an unrelated object of the array\u2019s element type that might be located at that address. \u2026 \u2014end note]</p>\n</blockquote>\n<p>Thus, the new standard allows that a complying implementation <em>might</em> yield true in your comparison; still, there are no guarantees.</p>\n<p>If you need to count the number of elements of an array, use the following stock macro:</p>\n<pre><code>#define countof(ARR) (sizeof (ARR) / sizeof *(ARR))\n</code></pre>\n<p>Or if you don't like macros, use the following function:</p>\n<pre><code>template&lt;class T, std::size_t N&gt;\nconstexpr std::size_t countof(T (&amp;)[N])\n{\n    return N;\n}\n</code></pre>\n<p>The latter option, however, needs that your compiler support the <code>constexpr</code> keyword to be full functional equivalent of the former.</p>\n", "LastEditorUserId": "2623659", "LastActivityDate": "2015-01-03T11:24:31.940", "Score": "4", "CreationDate": "2015-01-03T11:17:43.223", "ParentId": "27754055", "CommentCount": "6", "OwnerUserId": "2623659", "LastEditDate": "2015-01-03T11:24:31.940"}});