post_cb({"42957361": {"Id": "42957361", "PostTypeId": "2", "Body": "<p>Your version of <code>operator&lt;&lt;</code> here is templated on one argument, and so is the version supplied by the standard. </p>\n<p>The problem lies in that your version (We'll call it function <em>a</em>) is templated on one argument:</p>\n<pre><code>template&lt;class T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, T const&amp; t)\n{       \n    return os;\n}\n</code></pre>\n<p>and from <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2\" rel=\"nofollow noreferrer\">cppreference</a>, you can see the standard's overload for <code>const char*</code> (we'll call it <em>b</em>) is templated on the other:</p>\n<pre><code>template&lt; class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,  \n                                        const char* s );\n</code></pre>\n<p>You can get the behavior you expect by making your version of <code>operator&lt;&lt;</code> use the same template argument for the first argument (this one is <em>c</em>):</p>\n<pre><code>template&lt;class T, class CharT, class Traits&gt;\ninline std::basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt;&amp; os, T const&amp; t)\n{       \n        return os;\n}\n</code></pre>\n<p>compiles happily, as you can see <a href=\"http://coliru.stacked-crooked.com/a/503a53af124b175b\" rel=\"nofollow noreferrer\">on coliru</a>.</p>\n<p>This is because template overload selection chooses the most specialized template when selecting an overload with multiple candidate template functions.</p>\n<p>Specifically, first the template is transformed:</p>\n<p><a href=\"http://eel.is/c++draft/temp.func.order\" rel=\"nofollow noreferrer\">[temp.func.order]:</a></p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_42957146_42957361_0\"><strong>Partial ordering selects which of two function templates is more specialized</strong> than the other by transforming each template in turn (see next paragraph) and performing template argument deduction using the function type. The deduction process determines whether one of the templates is more specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process.</p></li>\n<li><p id=\"so_42957146_42957361_1\">To produce the transformed template, for each type, non-type, or template template parameter (including template parameter packs thereof) synthesize a unique type, value, or class template respectively and substitute it for each occurrence of that parameter in the function type of the template. <em>[\u2009Note: The type replacing the placeholder in the type of the value synthesized for a non-type template parameter is also a unique synthesized type. \u2009\u2014\u2009end note\u2009]</em> ...</p></li>\n</ol>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/temp.deduct.partial\" rel=\"nofollow noreferrer\">[temp.deduct.partial]:</a></p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_42957146_42957361_2\">Two sets of types are used to determine the partial ordering. For each of the templates involved there is the original function type and the transformed function type. <em>[\u2009Note: The creation of the transformed type is described in [temp.func.order]. \u2009\u2014\u2009end note\u2009]</em> The deduction process uses the transformed type as the argument template and the original type of the other template as the parameter template. This process is done twice for each type involved in the partial ordering comparison: once using the transformed template-1 as the argument template and template-2 as the parameter template and again using the transformed template-2 as the argument template and template-1 as the parameter template.</p></li>\n<li><p id=\"so_42957146_42957361_3\">The types used to determine the ordering depend on the context in which the partial ordering is done:</p>\n<ol>\n<li>In the context of a function call, the types used are those function parameter types for which the function call has arguments.</li>\n</ol></li>\n</ol>\n<p id=\"so_42957146_42957361_4\">...</p>\n<ol start=\"10\">\n<li>Function template F is at least as specialized as function template G if, for each pair of types used to determine the ordering, the type from F is at least as specialized as the type from G. F is more specialized than G if F is at least as specialized as G and G is not at least as specialized as F.</li>\n</ol>\n</blockquote>\n<p>So, we want the parts of the templates that are the function arguments.</p>\n<pre><code>a) T                 =&gt;  std::ostream&amp;,                     T const&amp;\nb) CharT, Traits     =&gt;  std::basic_ostream&lt;CharT, Traits&gt;, const char*\nc) T, CharT, Traits  =&gt;  std::basic_ostream&lt;CharT, Traits&gt;, T const&amp;\n</code></pre>\n<p>For the first argument of these functions, <em>a</em> is more specialized than <em>b</em> and <em>c</em>. </p>\n<p>For the second argument of these functions, <em>b</em> is more specialized than <em>a</em> and <em>c</em>.</p>\n<p>As we learned in [temp.deduct.partial]/10, argument deduction requires all relevant arguments of a function <em>f1</em> to be at least as specialized as all arguments of a function <em>f2</em> for the function <em>f1</em> to be at least as specialized as <em>f2</em>, <em>a</em> cannot here be more specialized than <em>b</em>, since each have one argument more specialized than the other's matching argument.</p>\n<p>This isn't the case with <em>c</em>, as both <em>a</em> and <em>c</em> have all arguments at least as specialized as the arguments in <em>c</em>.</p>\n<p>Thus, overload resolution will be ambiguous in choosing between <em>a</em> and <em>b</em> because <em>a</em> is at least as specialized as <em>b</em> and <em>b</em> is at least as specialized as <em>a</em>. The ambiguity is removed by using <em>c</em> instead of <em>a</em> because <em>b</em> is at least as specialized as <em>c</em>, but the reverse is not true.</p>\n<p>As we know from [temp.func.order]/2, the more specialized function wins overload resolution, and with the use of <em>c</em> rather than <em>a</em>, the winner is <em>b</em>, and the line <code>std::cout &lt;&lt; \"hello\";</code> prints <code>hello</code> to the console.</p>\n", "LastEditorUserId": "4892076", "LastActivityDate": "2017-03-22T17:25:12.817", "Score": "3", "CreationDate": "2017-03-22T16:20:19.470", "ParentId": "42957146", "CommentCount": "3", "OwnerUserId": "4892076", "LastEditDate": "2017-03-22T17:25:12.817"}, "bq_ids": {"n4140": {"so_42957146_42957361_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}, "so_42957146_42957361_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 322}, "so_42957146_42957361_1": {"length": 31, "quality": 0.6888888888888889, "section_id": 162}, "so_42957146_42957361_2": {"length": 60, "quality": 0.8823529411764706, "section_id": 321}}, "n3337": {"so_42957146_42957361_2": {"length": 60, "quality": 0.8823529411764706, "section_id": 311}, "so_42957146_42957361_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_42957146_42957361_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}, "so_42957146_42957361_1": {"length": 30, "quality": 0.6666666666666666, "section_id": 156}}, "n4659": {"so_42957146_42957361_2": {"length": 60, "quality": 0.8823529411764706, "section_id": 329}, "so_42957146_42957361_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 330}, "so_42957146_42957361_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}, "so_42957146_42957361_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 166}}}, "42957146": {"ViewCount": "82", "Body": "<p>I defined a function template in global scope as</p>\n<pre><code>template&lt;class T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, T const&amp; t)\n{       \n    return os;\n}\n</code></pre>\n<p>Then</p>\n<pre><code>std::cout &lt;&lt; \"\\n\";\n</code></pre>\n<p>doesn't compile because of ambiguity. I think it is function overloading and the compile can resolve it, and choose the more specific version for <code>char const*</code>. Why doesn't compile?</p>\n", "AcceptedAnswerId": "42957361", "Title": "Why operator<< is ambiguous?", "CreationDate": "2017-03-22T16:10:37.387", "Id": "42957146", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2017-03-22T17:33:10.640", "Score": "2", "OwnerUserId": "1899020", "Tags": "<c++><function-overloading>", "AnswerCount": "2"}, "42958566": {"Id": "42958566", "PostTypeId": "2", "Body": "<p>There is a function template</p>\n<pre><code>template &lt;class Traits&gt;\n... operator&lt;&lt;(basic_ostream&lt;char, Traits&gt; &amp;, const char *); // @1\n</code></pre>\n<p>declared in the standard library.</p>\n<p>After substitution, the conversion required to call standard's specialization and yours, a.k.a.</p>\n<pre><code>template&lt;class T&gt;\n... operator&lt;&lt;(std::ostream&amp; os, T const&amp; t); // @2\n</code></pre>\n<p>is both ranked as <strong>exact match</strong>.</p>\n<p>Then the compiler try to solve this call by <a href=\"http://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading\" rel=\"nofollow noreferrer\">partial ordering rules</a>:</p>\n<pre><code>@1 from transformed @2 :\n(basic_ostream&lt;char, T&gt; &amp;, const char *) from (std::ostream&amp; os, U const&amp; t)\n: P2 = const char *, A2 = U const &amp; : deduction fails\n\n@2 from transformed @1 :\n(std::ostream&amp; os, T const&amp; t) from (basic_ostream&lt;char, U&gt; &amp;, const char *)\n: P1 = std::ostream&amp;, A1 = basic_ostream&lt;char, U&gt; &amp; : deduction fails\n</code></pre>\n<p>thus neither is more specialized, the call is ambiguous.</p>\n<hr>\n<p>There are some other candidates:</p>\n<pre><code>operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;, const char*)\noperator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;, const _CharT*)\n</code></pre>\n<p>But sadly, they both are less specialized than the big brother @1 in this case. So I kicked them out...</p>\n<p>And some more, but these two are just for making the error message less readable.</p>\n<pre><code>operator&lt;&lt;(bool __n)\noperator&lt;&lt;(const void* __p)\n</code></pre>\n</hr>", "LastEditorUserId": "7038446", "LastActivityDate": "2017-03-22T17:33:10.640", "Score": "0", "CreationDate": "2017-03-22T17:19:34.273", "ParentId": "42957146", "CommentCount": "0", "OwnerUserId": "7038446", "LastEditDate": "2017-03-22T17:33:10.640"}});