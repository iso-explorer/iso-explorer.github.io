post_cb({"4807643": {"CommentCount": "12", "AcceptedAnswerId": "4807726", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-01-26T17:19:22.283", "LastActivityDate": "2012-10-24T15:24:03.353", "LastEditDate": "2017-05-23T12:15:28.880", "ViewCount": "3055", "FavoriteCount": "3", "Title": "Container covariance in C++", "Id": "4807643", "Score": "16", "Body": "<p>I know that C++ doesn't support covariance for containers elements, as in Java or C#. So the following code probably is undefined behavior:</p>\n<pre><code>#include &lt;vector&gt;\nstruct A {};\nstruct B : A {};\nstd::vector&lt;B*&gt; test;\nstd::vector&lt;A*&gt;* foo = reinterpret_cast&lt;std::vector&lt;A*&gt;*&gt;(&amp;test);\n</code></pre>\n<p>Not surprisingly, I received downvotes when suggesting this a solution to <a href=\"https://stackoverflow.com/questions/4806848/c-faster-downcasting-children-of-a-tree-node/4806932#4806932\">another question</a>.</p>\n<p>But what part of the C++ standard exactly tells me that this will result in undefined behavior? It's guaranteed that both <code>std::vector&lt;A*&gt;</code> and <code>std::vector&lt;B*&gt;</code> store their pointers in a continguous block of memory. It's also guaranteed that <code>sizeof(A*) == sizeof(B*)</code>. Finally, <code>A* a = new B</code> is perfectly legal.</p>\n<p>So what bad spirits in the standard did I conjure (except style)?</p>\n", "Tags": "<c++><covariance>", "OwnerUserId": "454406", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_4807643_4807726_6": {"section_id": 7239, "quality": 1.0, "length": 9}, "so_4807643_4807726_4": {"section_id": 7239, "quality": 1.0, "length": 10}, "so_4807643_4807726_0": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}, "so_4807643_4807726_5": {"section_id": 7239, "quality": 1.0, "length": 16}, "so_4807643_4807726_7": {"section_id": 45, "quality": 1.0, "length": 4}, "so_4807643_4807726_2": {"section_id": 7239, "quality": 1.0, "length": 5}, "so_4807643_4807726_3": {"section_id": 7239, "quality": 1.0, "length": 8}}, "n3337": {"so_4807643_4807726_6": {"section_id": 6983, "quality": 1.0, "length": 9}, "so_4807643_4807726_4": {"section_id": 6983, "quality": 1.0, "length": 10}, "so_4807643_4807726_0": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_4807643_4807726_5": {"section_id": 6983, "quality": 1.0, "length": 16}, "so_4807643_4807726_7": {"section_id": 42, "quality": 1.0, "length": 4}, "so_4807643_4807726_2": {"section_id": 6983, "quality": 1.0, "length": 5}, "so_4807643_4807726_3": {"section_id": 6983, "quality": 1.0, "length": 8}}, "n4659": {"so_4807643_4807726_6": {"section_id": 8748, "quality": 1.0, "length": 9}, "so_4807643_4807726_3": {"section_id": 8748, "quality": 1.0, "length": 8}, "so_4807643_4807726_0": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}, "so_4807643_4807726_5": {"section_id": 8748, "quality": 1.0, "length": 16}, "so_4807643_4807726_7": {"section_id": 46, "quality": 1.0, "length": 4}, "so_4807643_4807726_2": {"section_id": 8748, "quality": 1.0, "length": 5}, "so_4807643_4807726_4": {"section_id": 8748, "quality": 1.0, "length": 10}}}, "4807836": {"ParentId": "4807643", "CommentCount": "0", "Body": "<p>You are invoking the bad spirit of reinterpret_cast&lt;&gt;.</p>\n<p>Unless you really know what you do (I mean not proudly and not pedantically) reinterpret_cast is one of the gates of evil. </p>\n<p>The only safe use I know of is managing classes and structures between C++ and C functions calls.\nThere maybe some others however.</p>\n", "OwnerUserId": "356440", "PostTypeId": "2", "Id": "4807836", "Score": "3", "CreationDate": "2011-01-26T17:35:26.023", "LastActivityDate": "2011-01-26T17:35:26.023"}, "4807726": {"ParentId": "4807643", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The rule violated here is documented in C++03 3.10/15 [basic.lval], which specifies what is referred to informally as the \"strict aliasing rule\"</p>\n<blockquote>\n<p id=\"so_4807643_4807726_0\">If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li><p id=\"so_4807643_4807726_1\">the dynamic type of the object,</p></li>\n<li><p id=\"so_4807643_4807726_2\">a cv-qualified version of the dynamic type of the object,</p></li>\n<li><p id=\"so_4807643_4807726_3\">a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p></li>\n<li><p id=\"so_4807643_4807726_4\">a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</p></li>\n<li><p id=\"so_4807643_4807726_5\">an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</p></li>\n<li><p id=\"so_4807643_4807726_6\">a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</p></li>\n<li><p id=\"so_4807643_4807726_7\">a char or unsigned char type.</p></li>\n</ul>\n</blockquote>\n<p>In short, given an object, you are only allowed to access that object via an expression that has one of the types in the list.  For a class-type object that has no base classes, like <code>std::vector&lt;T&gt;</code>, basically you are limited to the types named in the first, second, and last bullets.</p>\n<p><code>std::vector&lt;Base*&gt;</code> and <code>std::vector&lt;Derived*&gt;</code> are entirely unrelated types and you can't use an object of type <code>std::vector&lt;Base*&gt;</code> as if it were a <code>std::vector&lt;Derived*&gt;</code>.  The compiler could do all sorts of things if you violate this rule, including:</p>\n<ul>\n<li><p>perform different optimizations on one than on the other, or </p></li>\n<li><p>lay out the internal members of one differently, or </p></li>\n<li><p>perform optimizations assuming that a <code>std::vector&lt;Base*&gt;*</code> can never refer to the same object as a <code>std::vector&lt;Derived*&gt;*</code></p></li>\n<li><p>use runtime checks to ensure that you aren't violating the strict aliasing rule</p></li>\n</ul>\n<p>[It might also do none of these things and it might \"work,\" but there's no guarantee that it will \"work\" and if you change compilers or compiler versions or compilation settings, it might all stop \"working.\"  I use the scare-quotes for a reason here.  :-)]</p>\n<p>Even if you just had a <code>Base*[N]</code> you could not use that array as if it were a <code>Derived*[N]</code> (though in that case, the use would probably be safer, where \"safer\" means \"still undefined but less likely to get you into trouble).</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2011-01-26T17:31:39.303", "Id": "4807726", "Score": "16", "CreationDate": "2011-01-26T17:26:37.980", "LastActivityDate": "2011-01-26T17:31:39.303"}, "4808683": {"ParentId": "4807643", "CommentCount": "2", "Body": "<p>The general problem with covariance in containers is the following:</p>\n<p>Let's say your cast would work and be legal (it isn't but let's assume it is for the following example):</p>\n<pre><code>#include &lt;vector&gt;\nstruct A {};\nstruct B : A { public: int Method(int x, int z); };\nstruct C : A { public: bool Method(char y); };\nstd::vector&lt;B*&gt; test;\nstd::vector&lt;A*&gt;* foo = reinterpret_cast&lt;std::vector&lt;A*&gt;*&gt;(&amp;test);\nfoo-&gt;push_back(new C);\ntest[0]-&gt;Method(7, 99); // What should happen here???\n</code></pre>\n<p>So you have also reinterpret-casted a C* to a B*...</p>\n<p>Actually I don't know how .NET and Java manage this (I think they throw an exception when trying to insert a C).</p>\n", "OwnerUserId": "44086", "PostTypeId": "2", "Id": "4808683", "Score": "3", "CreationDate": "2011-01-26T18:56:43.927", "LastActivityDate": "2011-01-26T18:56:43.927"}, "4807971": {"ParentId": "4807643", "CommentCount": "2", "Body": "<p>I think it'll be easier to show than tell:</p>\n<pre><code>struct A { int a; };\n\nstruct Stranger { int a; };\n\nstruct B: Stranger, A {};\n\nint main(int argc, char* argv[])\n{\n  B someObject;\n  B* b = &amp;someObject;\n\n  A* correct = b;\n  A* incorrect = reinterpret_cast&lt;A*&gt;(b);\n\n  assert(correct != incorrect); // troubling, isn't it ?\n\n  return 0;\n}\n</code></pre>\n<p>The (specific) issue showed here is that when doing a \"proper\" conversion, the compiler adds some pointer ajdustement depending on the memory layout of the objects. On a <code>reinterpret_cast</code>, no adjustement is performed.</p>\n<p>I suppose you'll understand why the use of <code>reinterpet_cast</code> should <em>normally</em> be banned from the code...</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "4807971", "Score": "2", "CreationDate": "2011-01-26T17:47:10.013", "LastActivityDate": "2011-01-26T17:47:10.013"}});