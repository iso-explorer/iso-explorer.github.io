post_cb({"46770274": {"CommentCount": "2", "ViewCount": "59", "PostTypeId": "1", "LastEditorUserId": "3063", "CreationDate": "2017-10-16T12:24:42.390", "LastActivityDate": "2017-10-16T19:45:40.013", "Title": "Is it legal to construct an unordered_map holding references?", "AcceptedAnswerId": "46777886", "LastEditDate": "2017-10-16T19:45:40.013", "Id": "46770274", "Score": "0", "Body": "<p>In general STL containers cannot hold non-<code>CopyAssignable</code> types such as references. If I construct the container in a way that no copy should take place, then is the code valid. It compiles with <code>std=c++11</code> and <code>c++14</code> with some version of gcc-7.2, but is the following valid or can I expect it to break with a library upgrade? Should I use <code>reference_wrapper</code> in this case?</p>\n<pre><code>#include &lt;unordered_map&gt;\n\nstruct S {};\n\nvoid use (S&amp;) {}\n\nvoid test() {\n    S s1, s2;\n    const std::unordered_map&lt;int, S&amp;&gt; m{{0, s1}, {1, s2}};\n    use(m.at(0));\n}\n</code></pre>\n<hr>\n<p><strong>Edit</strong> I really do need a reference to the standard. Works for me too is not enough, if a standard-conforming update of the compiler/standard library can break the code. So the answer given for <a href=\"https://stackoverflow.com/questions/24719044/unordered-map-with-reference-as-value\">\"unordered_map with reference as value\"</a> is not enough for me.</p>\n</hr>", "Tags": "<c++><reference><containers><unordered-map>", "OwnerUserId": "3063", "AnswerCount": "1"}, "46777886": {"ParentId": "46770274", "CommentCount": "0", "Body": "<p>I think I found an answer myself for this specific use case:</p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11</a> standard at clause 23.5.4.3 for unordered_map element access specifically omits listing any requirements for the <code>mapped_type</code>, that is <code>S&amp;</code>, while with <code>operator[]</code> it must be <code>DefaultConstructible</code>.</p>\n<blockquote>\n<pre><code>mapped_type&amp; at(const key_type&amp; k);\nconst mapped_type&amp; at(const key_type&amp; k) const;\n</code></pre>\n<p id=\"so_46770274_46777886_0\"><em>Returns</em>: A reference to <code>x.second</code>, where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>\n<p id=\"so_46770274_46777886_1\"><em>Throws</em>: An exception object of type <code>out_of_range</code> if no such element is present.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">C++17</a> also indirectly says something to this effect in 26.5.4.3 and 26.5.4.4.</p>\n<p>Therefore, the above code <strong>should</strong> work with any standard implementation.</p>\n<p><strong>However</strong>, it is true \u2013 as pointed out in the comments \u2013 that mutating the container after construction or applying any algorithm that requires constructing or assigning the container's <code>value_type</code> or <code>mapped_type</code> will not work.</p>\n", "OwnerUserId": "3063", "PostTypeId": "2", "Id": "46777886", "Score": "1", "CreationDate": "2017-10-16T19:39:54.917", "LastActivityDate": "2017-10-16T19:39:54.917"}, "bq_ids": {"n4140": {"so_46770274_46777886_1": {"section_id": 1016, "quality": 0.875, "length": 7}, "so_46770274_46777886_0": {"section_id": 1057, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_46770274_46777886_1": {"section_id": 1001, "quality": 0.875, "length": 7}, "so_46770274_46777886_0": {"section_id": 1042, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_46770274_46777886_1": {"section_id": 1073, "quality": 0.875, "length": 7}, "so_46770274_46777886_0": {"section_id": 1129, "quality": 0.8888888888888888, "length": 8}}}});