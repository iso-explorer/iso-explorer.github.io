post_cb({"22259261": {"Id": "22259261", "PostTypeId": "2", "Body": "<p>That solution seems like a pretty reasonable way to solve the problem you're faced with. It's perfectly fine to <code>#define</code> <code>override</code> in C++98 because it's not a keyword there.</p>\n", "LastActivityDate": "2014-03-07T19:43:10.040", "CommentCount": "2", "CreationDate": "2014-03-07T19:43:10.040", "ParentId": "22259199", "Score": "1", "OwnerUserId": "251738"}, "bq_ids": {"n4140": {"so_22259199_22259253_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 6306}}, "n3337": {"so_22259199_22259253_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 6063}}, "n4659": {"so_22259199_22259253_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 7817}}}, "22259253": {"Id": "22259253", "PostTypeId": "2", "Body": "<p>I'd do it slightly differently</p>\n<pre><code>#ifndef DETECTCXX0X\n#define OVERRIDE\n#else\n#define OVERRIDE override\n#endif\n</code></pre>\n<p>And then define the function as</p>\n<pre><code>void foo() OVERRIDE;\n</code></pre>\n<p>Doing so avoids flouting the rules. From <em>\u00a717.6.4.3.1/2 [macro.names]</em></p>\n<blockquote>\n<p id=\"so_22259199_22259253_0\">A translation unit shall not <code>#define</code> or <code>#undef</code> names lexically\n  identical to keywords, to the identifiers listed in Table 3, or to the\n  <em>attribute-tokens</em> described in 7.6.</p>\n</blockquote>\n<p><em>Table 3</em> includes <code>override</code> and <code>final</code>. In your case, your macro should be fine too, because in C++03 <code>override</code> is not a keyword, so defining a macro does not violate the rule above, and a C++11 compiler will never see that macro definition. But I still prefer the method above.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-03-07T19:49:43.363", "Score": "5", "CreationDate": "2014-03-07T19:42:49.880", "ParentId": "22259199", "CommentCount": "1", "OwnerUserId": "241631", "LastEditDate": "2014-03-07T19:49:43.363"}, "22259199": {"ViewCount": "682", "Body": "<p>I have some code that has optional built in code that attempts to detect C++0X. Lets pretend that that works (discussing how bad and how not cross platform that is is out of scope for this question). Lets say it has a #define <code>DETECTCXX0X</code>. iff it is C++0X.</p>\n<p>How awful of an idea is it to do this:</p>\n<pre><code>#ifndef DETECTCXX0X\n#define override\n#endif\n</code></pre>\n<p>And do you have any alternatives?</p>\n<p>(I suppose the correct thing to do is to just not use explicit overriding).</p>\n", "AcceptedAnswerId": "22260023", "Title": "Elegant way to deal with override in C++98,C++11 cross-compilable code?", "CreationDate": "2014-03-07T19:39:47.163", "Id": "22259199", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-03-31T19:40:16.757", "Score": "0", "OwnerUserId": "1756405", "Tags": "<c++><c++11><macros><override>", "AnswerCount": "3"}, "22260023": {"Id": "22260023", "PostTypeId": "2", "Body": "<p>As Igor Tandetnik points out it's legal in C++11 and C++98 to say:</p>\n<pre><code>int override = 10;\n</code></pre>\n<p>Because <code>override</code> is not really a keyword even in C++11. If your code does this then your macro will mangle it in C++98 mode. If you prohibit using such identifiers and then your method will work fine. The only problem being that you may forget that rule and get hard to understand error messages. If you're using some kind of linter that you can customize then you can add a rule that eliminates this problem.</p>\n<p>Another option is Praetorian's solution:</p>\n<pre><code>#ifndef DETECTCXX0X\n#define OVERRIDE\n#else\n#define OVERRIDE override\n#endif\n</code></pre>\n<p>This, however, makes for ugly and difficult to read code, IMO.</p>\n<p>If you have the luxury to do the following then this is what I recommend:</p>\n<pre><code>#ifndef DETECTCXX0X\n#error C++11 support required\n#endif\n</code></pre>\n<p>If you can't avoid non-C++11 compilers then a second best option, if you have that linter, is to use it with <code>#define override</code>. Third best would be to not use this particular C++11 feature at all. In my view the least desirable option is <code>#define OVERRIDE override</code>.</p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2014-03-31T19:40:16.757", "Score": "0", "CreationDate": "2014-03-07T20:25:38.833", "ParentId": "22259199", "CommentCount": "0", "OwnerUserId": "365496", "LastEditDate": "2014-03-31T19:40:16.757"}});