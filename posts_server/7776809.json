post_cb({"13877731": {"Id": "13877731", "PostTypeId": "2", "Body": "<p>If <code>vector</code> is <code>std::vector</code>, then this code has undefined behaviour as <code>[res.on.functions]</code> states (with similar wording in both C++03 and C++11):</p>\n<blockquote>\n<p id=\"so_7776809_13877731_0\">... In particular, the effects are undefined in the following cases: ... if an incomplete type is used as a template argument when instantiating a template component, unless specifically allowed for that component.</p>\n</blockquote>\n<p>If you want to do this, use an implementation of <code>vector</code> that explicitly allows recursive instantiations, such as <a href=\"http://www.boost.org/doc/libs/1_52_0/doc/html/boost/container/vector.html\" rel=\"nofollow\">boost::container::vector</a>.</p>\n", "LastActivityDate": "2012-12-14T11:23:48.533", "CommentCount": "0", "CreationDate": "2012-12-14T11:23:48.533", "ParentId": "7776809", "Score": "0", "OwnerUserId": "485561"}, "7776835": {"Id": "7776835", "PostTypeId": "2", "Body": "<p>Won't making <code>children</code> a pointer to a vector of Nodes help with the copying cascade?</p>\n", "LastActivityDate": "2011-10-15T09:00:34.580", "CommentCount": "0", "CreationDate": "2011-10-15T09:00:34.580", "ParentId": "7776809", "Score": "0", "OwnerUserId": "279028"}, "bq_ids": {"n4140": {"so_7776809_13877731_0": {"length": 16, "quality": 1.0, "section_id": 6324}}, "n3337": {"so_7776809_13877731_0": {"length": 16, "quality": 1.0, "section_id": 6081}}, "n4659": {"so_7776809_13877731_0": {"length": 16, "quality": 1.0, "section_id": 7834}}}, "7776809": {"ViewCount": "131", "Body": "<p>Is it a bad idea in C++ to do something like:</p>\n<pre><code>struct Node\n{\n    string name;\n    vector&lt;Node&gt; children;\n};\n</code></pre>\n<p>I'm asking because it looks to me like resizing <code>children</code> for any reason could potentially cause an exponential copying cascade. But on the other hand, <code>vector&lt;Node*&gt;</code> has its own problems, and things like <code>vector&lt;shared_ptr&lt;Node&gt;&gt;</code>, while safe, have poor memory locality (due to too many indirections), which starts hurting when you're trying to e.g. build a gigantic tree in memory.</p>\n<p>So, in general, is it a bad idea to have a container of your own type in C++ (03)? Are there other reasons to avoid (or prefer) this idiom, instead of using containers of pointers?</p>\n", "AcceptedAnswerId": "7776883", "Title": "Is having a container of a type as a field a bad idea in C++?", "CreationDate": "2011-10-15T08:53:29.373", "Id": "7776809", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-12-14T11:23:48.533", "Score": "1", "OwnerUserId": "541686", "Tags": "<c++><containers>", "AnswerCount": "4"}, "7776874": {"Id": "7776874", "PostTypeId": "2", "Body": "<p>Depends on several things:</p>\n<ul>\n<li>does your compiler support move semantics (and if so, have you added move constructor/move assignment operator to the <code>Node</code> class)</li>\n<li>how likely are you to resize the vector?</li>\n<li>how deep is your data structure going to be? How many levels of nodes are going to have to be copied/moved if one of them has its vector resized?</li>\n</ul>\n<p>You're right, it could <em>potentially</em> have this effect, but only if your data structure is deep and wide enough for the cascade to actually be noticeable.</p>\n<p>Adding move semantics to your class would solve the problem entirely, but alternatively, you could modify the data structure. One option might be to not store the vectors inside nodes at all. Perhaps keep one single large vector which is shared between all nodes, and let each node store two iterators pointing to the range of elements that belong to it.</p>\n", "LastActivityDate": "2011-10-15T09:07:34.383", "CommentCount": "0", "CreationDate": "2011-10-15T09:07:34.383", "ParentId": "7776809", "Score": "2", "OwnerUserId": "33213"}, "7776883": {"Id": "7776883", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7776809_7776883_0\">Is having a container of a type as a field a bad idea in C++?</p>\n</blockquote>\n<p>It's not bad as a general rule. It really comes down to the context.</p>\n<p>In this case, the indirections of a shared pointer should not be significant compared to nontrivial resize operations, and the cascading (assuming that will be a problem).</p>\n<p>If you can reserve the proper sizes prior to populating the vector or make copying trivial, then there's not much to worry about here.</p>\n<p>If it's really gigantic, you could base your nodes of an external store, which handled (and potentially shared) the nodes. Then your resizing ops would be trivial, as your <code>children</code> would all be pointers.</p>\n<p>Depending on the size of the Nodes, this:</p>\n<pre><code>struct Node\n{\n    string name;\n    shared_pointer&lt;vector&lt;Node&gt; &gt; children;\n};\n</code></pre>\n<p>may be better than shared nodes. It really depends on the size, depth, how often you resize. A container isn't bad, but you will have to know how your program will execute to choose the best strategy (profiling can also help here, even in cases when you figure you know the fastest).</p>\n<p>If you know you have a lot of objects and a lot of resizing to do, then an fast external store will be a good choice; jalf's answer outlines a good strategy for this.</p>\n<p>You could also use a <code>list</code> of node <code>vector</code>s on a backing store if you will have a lot of mutations, and pointers to list elements for the children.</p>\n<p>Support for these more complex implementations also takes more time than your current design, but they are worth trying if you do need to perform a lot of mutations. Simplicity to implement and maintain would then be a bonus to your original design.</p>\n<p>If your graph really doesn't grow very large, another approach would be to use custom allocators which either referred to a backing store of nodes, or shrank less often than the default allocators.</p>\n", "LastEditorUserId": "191596", "LastActivityDate": "2011-10-15T09:29:23.707", "Score": "2", "CreationDate": "2011-10-15T09:08:41.207", "ParentId": "7776809", "CommentCount": "2", "OwnerUserId": "191596", "LastEditDate": "2011-10-15T09:29:23.707"}});