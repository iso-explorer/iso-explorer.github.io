post_cb({"26667845": {"ParentId": "26667756", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Lets add a <em>static</em> member to the class as:</p>\n<pre><code> class foo{\n    public:\n         void bar()     { cout&lt;&lt;\"hey there\"&lt;&lt;endl; }\n         static void bar(foo*) { cout&lt;&lt;\"STATIC MEMBER\"&lt;&lt;endl; }\n};\n</code></pre>\n<p>Now if you write this:</p>\n<pre><code> foo::bar(&amp;obj); //static or non-static?\n</code></pre>\n<p>Which function should be called? In such situation, how would you call <em>both</em> of them? What would be the syntax? If you allow one function to have this syntax, you've to abandon it (i.e syntax) for other function. The Standard decided to have <em>foo::bar(&amp;obj)</em> syntax for <code>static</code> member function, while abandoning it for <em>non-static</em> member function.</p>\n<hr>\n<p>Anyway, if you want to pass <code>&amp;obj</code> as argument to the non-static member function, then you can use type-erasure facilitated by <code>std::function</code> as:</p>\n<pre><code> void (foo::*pbar)() = &amp;foo::bar; //non-static member function   #1\n\n std::function&lt;void(foo*)&gt; bar(pbar); \n\n bar(&amp;obj); //same as obj.bar();\n</code></pre>\n<p>Likewise, you could call static member function as:</p>\n<pre><code> void (*pbar)(foo*) = &amp;foo::bar; //static member function            #2\n\n std::function&lt;void(foo*)&gt; bar(pbar); \n\n bar(&amp;obj); //same as foo::bar(&amp;obj);\n</code></pre>\n<p>Note that at lines <code>#1</code> and <code>#2</code>, the types of the object <code>pbar</code> makes the compiler to choose the correct member function \u2014 in the first case, it takes the pointer to the <em>non-static</em> member-function while in the latter case, it takes the pointer to the <em>static</em> member function.</p>\n<p>Hope that helps.</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2014-10-31T05:22:40.587", "Id": "26667845", "Score": "6", "CreationDate": "2014-10-31T05:04:41.600", "LastActivityDate": "2014-10-31T05:22:40.587"}, "26667756": {"CommentCount": "3", "AcceptedAnswerId": "26667845", "CreationDate": "2014-10-31T04:53:37.147", "LastActivityDate": "2014-10-31T05:22:40.587", "PostTypeId": "1", "ViewCount": "657", "FavoriteCount": "1", "Title": "Why can't I pass the this pointer explicitly to a member function?", "Id": "26667756", "Score": "5", "Body": "<p>The c++ standard (ISO c++11) mentions in <strong>Section 9.3.1</strong> that</p>\n<blockquote>\n<p id=\"so_26667756_26667756_0\">A non-static member function may be called for an object of its class\n  type, or for an object of a class derived (Clause 10) from its class\n  type, using the class member access syntax (5.2.5, 13.3.1.1).</p>\n</blockquote>\n<p>An attempt to compile this code with g++ (version 4.8.2)</p>\n<pre><code> class foo{\n    public:\n         void bar(){\n            cout&lt;&lt;\"hey there\"&lt;&lt;endl;\n         }\n};\nint main(){\n    foo obj;\n    foo::bar(&amp;obj);\n}\n</code></pre>\n<p>gives a compile time error because it couldn't match the function's signature. I guess that is expected given what the standard states about calling member functions. \nSince the method will eventually take a form similar to <strong>bar(foo*)</strong> during some stage of compilation, why does the standard asks for member access syntax to call the member function?</p>\n", "Tags": "<c++><c++11><this>", "OwnerUserId": "1043773", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26667756_26667756_0": {"section_id": 5889, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_26667756_26667756_0": {"section_id": 5660, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_26667756_26667756_0": {"section_id": 7372, "quality": 0.9130434782608695, "length": 21}}}});