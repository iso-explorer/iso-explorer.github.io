post_cb({"bq_ids": {"n4140": {"so_48044512_48044548_0": {"length": 40, "quality": 0.8888888888888888, "section_id": 6044}}, "n3337": {"so_48044512_48044548_0": {"length": 40, "quality": 0.8888888888888888, "section_id": 5812}}, "n4659": {"so_48044512_48044548_0": {"length": 40, "quality": 0.8888888888888888, "section_id": 7543}}}, "48044548": {"Id": "48044548", "PostTypeId": "2", "Body": "<p>Your interpretation is correct. The relevant paragraph of the standard is [expr.reinterpret.cast]/5 in C++17:</p>\n<blockquote>\n<p id=\"so_48044512_48044548_0\">A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to\n  an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type\n  will have its original value; mappings between pointers and integers are otherwise implementation-defined.\n  [ <em>Note:</em> Except as described in 6.7.4.3, the result of such a conversion will not be a safely-derived pointer\n  value. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Thus, while the mapping from pointers to integers is guaranteed to have a left inverse (and therefore be injective), no guarantee is made that it is bijective; whether or not it is part of the \"implementation-defined\" behaviour. As cppreference points out, there may be several integers that convert to the same pointer.</p>\n", "LastActivityDate": "2017-12-31T17:34:56.607", "CommentCount": "2", "CreationDate": "2017-12-31T17:34:56.607", "ParentId": "48044512", "Score": "3", "OwnerUserId": "481267"}, "48053835": {"Id": "48053835", "PostTypeId": "2", "Body": "<p>There might not be an integral type that exactly matches the width of the platform's address space.  <code>intptr_t</code> has to be big enough to hold any pointer value, meaning it is as big or bigger than a pointer, and when it is bigger, the pigeonhole principle guarantees that it won't be possible for each integer value to have a unique <code>void*</code> value.</p>\n", "LastActivityDate": "2018-01-01T22:39:53.940", "CommentCount": "2", "CreationDate": "2018-01-01T22:39:53.940", "ParentId": "48044512", "Score": "0", "OwnerUserId": "103167"}, "48044512": {"ViewCount": "109", "Body": "<p>In <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">this article</a> the following is mentioned regarding <strong><code>reinterpret_cast</code></strong> of integers and pointers:</p>\n<blockquote>\n<p id=\"so_48044512_48044512_0\">(the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations)</p>\n</blockquote>\n<p>Do I understand correctly that the following is then not guaranteed by the standard:</p>\n<pre><code>intptr_t x = 5; \nvoid* y = reinterpret_cast&lt;void*&gt;(x);\nassert(x == reinterpret_cast&lt;intptr_t&gt;(y));\n</code></pre>\n<p>Can someone confirm?</p>\n", "AcceptedAnswerId": "48044548", "Title": "Round-trip safety of storing integer in void pointer", "CreationDate": "2017-12-31T17:28:08.533", "LastActivityDate": "2018-01-01T22:39:53.940", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-01-01T18:25:32.613", "LastEditorUserId": "8465774", "Id": "48044512", "Score": "4", "OwnerUserId": "7735326", "Tags": "<c++><pointers><language-lawyer><reinterpret-cast>", "AnswerCount": "2"}});