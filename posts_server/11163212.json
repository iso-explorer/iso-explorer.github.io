post_cb({"11163345": {"ParentId": "11163212", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_11163212_11163345_0\">Because people are always saying it, there must be some truth to what they say, so I assume that the destructor must be called when obj goes out of scope, before AnotherFuncCall. Is that a fair assumption?</p>\n</blockquote>\n<p>This is correct. Note that this final question says nothing about a stack\". Whether an implementation uses a stack, or something else, is up to the implementation.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "11163345", "Score": "1", "CreationDate": "2012-06-22T20:05:01.853", "LastActivityDate": "2012-06-22T20:05:01.853"}, "11163347": {"ParentId": "11163212", "CommentCount": "7", "Body": "<p>Your local variables on stack do not take extra memory. The system provides some memory from each thread's stack, and the variables on the stack just use part of it. After running out of the scope, the compiler can reuse the same part of the stack for other variables (used later in the same function).</p>\n", "OwnerUserId": "917880", "PostTypeId": "2", "Id": "11163347", "Score": "0", "CreationDate": "2012-06-22T20:05:06.770", "LastActivityDate": "2012-06-22T20:05:06.770"}, "11163410": {"ParentId": "11163212", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Objects created \"on the stack\" in local scope have what is called <em>automatic storage duration</em>.  The Standard says:</p>\n<h2>C++03 3.7.2 Automatic storage duration</h2>\n<blockquote>\n<p id=\"so_11163212_11163410_0\">1/ Local objects explicitly declared auto or register or not\n  explicitly declared static or extern have automatic storage duration.\n  The storage for these objects lasts until the block in which they are\n  created exits.</p>\n<p id=\"so_11163212_11163410_1\">2/ [Note: these objects are initialized and destroyed as described in\n  6.7. ]</p>\n</blockquote>\n<p>On the destruction of these objects:</p>\n<h2>6.7 Declaration statement</h2>\n<blockquote>\n<p id=\"so_11163212_11163410_2\">2/ Variables with automatic storage duration (3.7.2) are initialized\n  each time their declaration-statement is executed. Variables with\n  automatic storage duration declared in the block are destroyed on exit\n  from the block (6.6).</p>\n</blockquote>\n<p>Hence, according to the Standard, when object with local scope fall out of scope, the destructor is called and the storage is released.</p>\n<p>Weather or not that storage is on a stack the Standard doesn't say.  It just says the storage is released, wherever it might be.</p>\n<p>Some architectures don't have stacks in the same sense a PC has.  C++ is meant to work on any kind of programmable device.  That's why it never mentions anything about stacks, heaps, etc.</p>\n<p>On a typical PC-type platform running Windows and user-mode code, these automatic variables are stored on a stack.  These stacks are fixed-size, and are created when the thread starts.  As they become instantiated, they take up more of the space on the stack, and the stack pointer moves.  If you allocate enough of these variables, you will overflow the stack and your program will die an ugly death.  </p>\n<p>Try running this on a Windows PC and see what happens for an example:</p>\n<pre><code>int main()\n{\n    int boom[10000000];\n    for( int* it = &amp;boom[0]; it != &amp;boom[sizeof(boom)/sizeof(boom[0])]; ++it )\n        *it = 42;\n}\n</code></pre>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2012-06-22T20:19:35.783", "Id": "11163410", "Score": "1", "CreationDate": "2012-06-22T20:10:28.817", "LastActivityDate": "2012-06-22T20:19:35.783"}, "11163466": {"ParentId": "11163212", "CommentCount": "0", "Body": "<pre><code>how do we know that it is no longer taking up space in the stack?\n</code></pre>\n<p>We don't. There are way to see whether they do or don't, but those are architecture and ABI specific. Generally, functions do pop whatever they pushed to the stack when they return control to the caller. What C/C++ guarantees is that it will call a destructor of high-level objects when they leave the scope (though some older C++ like MSVC 6 had terrible bugs at a time when they did not).</p>\n<pre><code>Is it guaranteed that obj will not be saved on the stack when AnotherFuncCall is executed? \n</code></pre>\n<p>No. It is up to the compiler to decide when and how to push and pop stack frames as long as that way complies with ABI requirements.</p>\n", "Id": "11163466", "PostTypeId": "2", "OwnerDisplayName": "user405725", "Score": "0", "CreationDate": "2012-06-22T20:15:05.557", "LastActivityDate": "2012-06-22T20:15:05.557"}, "11163310": {"ParentId": "11163212", "CommentCount": "4", "Body": "<p>Your stack is not dynamically allocated and deallocated, it's just there.  Your objects constructors and destructors will get called but you don't get the memory back.</p>\n", "OwnerUserId": "428916", "PostTypeId": "2", "Id": "11163310", "Score": "1", "CreationDate": "2012-06-22T20:02:29.623", "LastActivityDate": "2012-06-22T20:02:29.623"}, "11163370": {"ParentId": "11163212", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What people say is indeed true. The object <strong>still remains in the memory location</strong>. However, the way stack works means that the object does <strong>not</strong> take any memory space from stack.</p>\n<p>What <strong>usually</strong> happens when memory is allocated on the stack is that the <em>stack pointer</em> is <em>decremented</em> by <code>sizeof(type)</code> and when the variable goes out of scope and the object is freed, the <em>stack pointer</em> is <em>incremented</em>, thus <strong>shrinking</strong> the effective <em>size</em> of data allocated on the stack. Indeed, the data <em>still</em> resides in it's original address, it is <strong>not</strong> destroyed or <em>deleted</em> at all. </p>\n<p>And just to clarify, the C++ standard says absolutely <strong>nothing</strong> about this! The C++ standard is completely unaware of anything called stack or heap in sense of memory allocation because they are <strong>platform specific</strong> <em>implementation details</em>.</p>\n", "OwnerUserId": "537252", "LastEditorUserId": "537252", "LastEditDate": "2012-10-31T18:55:51.300", "Id": "11163370", "Score": "1", "CreationDate": "2012-06-22T20:07:03.857", "LastActivityDate": "2012-10-31T18:55:51.300"}, "11163318": {"ParentId": "11163212", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You are confusing two different concepts.</p>\n<p>Yes, your object's destructor will be called when it leaves its enclosing scope.  This is guaranteed by the standard.</p>\n<p>No, there is no guarantee that an implementation of the language uses a stack to implement automatic storage (i.e., what you refer to as \"stack allocated objects\".)</p>\n<p>Since most compilers use a fixed size stack I'm not even sure what your question is.  It is typically implemented as a fixed size memory region where a pointer move is all that is required to \"clean up\" the stack as that memory will be used again soon enough.</p>\n<p>So, since the memory region used to implement a stack is fixed in size there is no need to set the memory your object took to 0 or something else.  It can live there until it is needed again, no harm done.</p>\n", "OwnerUserId": "1053", "LastEditorUserId": "1053", "LastEditDate": "2012-06-22T20:04:31.730", "Id": "11163318", "Score": "3", "CreationDate": "2012-06-22T20:03:25.863", "LastActivityDate": "2012-06-22T20:04:31.730"}, "11163212": {"CommentCount": "3", "ViewCount": "1160", "CreationDate": "2012-06-22T19:54:58.340", "LastActivityDate": "2012-10-31T18:55:51.300", "Title": "Stack-allocated objects still taking memory after going out of scope?", "PostTypeId": "1", "Id": "11163212", "Score": "1", "Body": "<p>People always talk about how objects created without the <code>new</code> keyword are destroyed when they go out of scope, but when I think about this, it seems like that's wrong.  Perhaps the destructor is called when the variable goes out of scope, but how do we know that it is no longer taking up space in the stack?  For example, consider the following:</p>\n<pre><code>void DoSomething()\n{\n  {\n    My_Object obj;\n    obj.DoSomethingElse();\n  }\n  AnotherFuncCall();\n}\n</code></pre>\n<p>Is it guaranteed that <code>obj</code> will not be saved on the stack when <code>AnotherFuncCall</code> is executed? Because people are always saying it, there must be some truth to what they say, so I assume that the destructor must be called when <code>obj</code> goes out of scope, before <code>AnotherFuncCall</code>.  Is that a fair assumption?</p>\n", "Tags": "<c++><scope><destructor>", "OwnerUserId": "864027", "AnswerCount": "8"}, "11163280": {"ParentId": "11163212", "CommentCount": "2", "Body": "<p>I believe it depends where in the stack the object was created. If it was on the bottom (assuming stack grows down) then I think the second function may overwrite the destroyed objects space. If the object was inside the stack, then probably that space is wasted, since all further objects would have to be shifted.</p>\n", "OwnerUserId": "767843", "PostTypeId": "2", "Id": "11163280", "Score": "1", "CreationDate": "2012-06-22T19:59:19.213", "LastActivityDate": "2012-06-22T19:59:19.213"}, "bq_ids": {"n4140": {"so_11163212_11163410_0": {"section_id": 7170, "quality": 0.7391304347826086, "length": 17}, "so_11163212_11163410_2": {"section_id": 3917, "quality": 0.95, "length": 19}}, "n3337": {"so_11163212_11163410_0": {"section_id": 6914, "quality": 0.7391304347826086, "length": 17}, "so_11163212_11163410_2": {"section_id": 3777, "quality": 0.95, "length": 19}}, "n4659": {"so_11163212_11163410_0": {"section_id": 8678, "quality": 0.6086956521739131, "length": 14}, "so_11163212_11163410_2": {"section_id": 4803, "quality": 0.95, "length": 19}}}});