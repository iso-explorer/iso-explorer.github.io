post_cb({"426746": {"ParentId": "426737", "CommentCount": "1", "CreationDate": "2009-01-09T01:30:16.043", "OwnerUserId": "23072", "Id": "426746", "PostTypeId": "2", "OwnerDisplayName": "Uri", "Score": "7", "Body": "<p>An object of type Foo takes the size of 100 ints stored in sequence. \nIf you create it on the stack, you will be getting it all on the stack.\nIf you do it with new, it'll be on the heap as part of the object. </p>\n<p>This is part of the language specification, I'm not sure what your question is. </p>\n", "LastActivityDate": "2009-01-09T01:30:16.043"}, "426737": {"CommentCount": "0", "ViewCount": "1352", "PostTypeId": "1", "LastEditorUserId": "3824100", "CreationDate": "2009-01-09T01:27:52.103", "LastActivityDate": "2017-02-06T07:42:19.520", "AnswerCount": "5", "LastEditDate": "2017-02-06T07:42:19.520", "AcceptedAnswerId": "426768", "LastEditorDisplayName": "jleedev", "Title": "Does this type of memory get allocated on the heap or the stack?", "Id": "426737", "Score": "4", "Body": "<p>In the context of C++ (not that it matters):</p>\n<pre><code>class Foo{\n    private:\n        int x[100];\n    public:\n        Foo();\n}\n</code></pre>\n<p>What I've learnt tells me that if you create an instance of Foo like so:</p>\n<pre><code>Foo bar = new Foo();\n</code></pre>\n<p>Then the array x is allocated on the heap, but if you created an instance of Foo like so:</p>\n<pre><code>Foo bar;\n</code></pre>\n<p>Then it's created on the stack.</p>\n<p>I can't find resources online to confirm this.</p>\n", "Tags": "<c++><memory-management><stack><heap>", "OwnerUserId": "46555", "OwnerDisplayName": "Majd Taby"}, "426750": {"ParentId": "426737", "CommentCount": "0", "CreationDate": "2009-01-09T01:32:46.913", "OwnerUserId": "48684", "PostTypeId": "2", "Id": "426750", "Score": "1", "Body": "<p>You mean </p>\n<pre><code>Foo* bar = new Foo(); \n</code></pre>\n<p>I suppose. <em>That</em> is created in the heap.</p>\n", "LastActivityDate": "2009-01-09T01:32:46.913"}, "426764": {"CommentCount": "0", "CreationDate": "2009-01-09T01:38:33.843", "LastEditorUserId": "12711", "LastActivityDate": "2009-01-09T02:31:17.810", "ParentId": "426737", "PostTypeId": "2", "LastEditorDisplayName": "Michael Burr", "LastEditDate": "2009-01-09T02:31:17.810", "Id": "426764", "Score": "2", "Body": "<p>Yes, the member array <code>x</code> will be created on the heap if you create the <code>Foo</code> object on the heap.  When you allocate dynamic memory for <code>Foo</code> you are asking for memory of length <code>sizeof(Foo)</code> (plus possibly some memory overhead, but let's ignore that for the time being), which in your sample code implies the size of 100 <code>int</code>s.  This <em>has</em> to be case for the lifespan of objects of type <code>Foo</code> (and their internal data) to cross scopes.</p>\n<p>If you don't create the <code>Foo</code> object on the heap, and the internal array of <code>Foo</code> isn't a pointer to which you allocate memory with <code>new</code> in <code>Foo</code>'s constructor then that internal array will be created on the stack.  Again, this has to be the case in order for the array to automatically be cleaned without any <code>delete</code>s when the scope ends.  Specifically,</p>\n<pre><code>struct Foo {\n    int* y;\n    Foo() : y(new int()) { }\n    ~Foo() { delete y; }\n};\n</code></pre>\n<p>will create <code>y</code> on the heap regardless of whether a <code>Foo</code> object was created on the stack or on the heap.</p>\n", "OwnerUserId": "456", "OwnerDisplayName": "wilhelmtell"}, "426768": {"CommentCount": "1", "CreationDate": "2009-01-09T01:39:51.533", "LastEditorUserId": "3153", "LastActivityDate": "2009-01-09T01:50:32.370", "ParentId": "426737", "PostTypeId": "2", "LastEditorDisplayName": "Brian R. Bondy", "LastEditDate": "2009-01-09T01:50:32.370", "Id": "426768", "Score": "10", "Body": "<p>Given a slight modification of your example:</p>\n<pre><code>class Foo{\n    private:\n        int x[100];\n        int *y;\n    public:\n        Foo()\n        {\n           y = new int[100];\n        }\n        ~Foo()\n        { \n           delete[] y; \n        }\n\n}\n</code></pre>\n<p>Example 1:</p>\n<pre><code>Foo *bar = new Foo();\n</code></pre>\n<ul>\n<li>x and y are on the heap:</li>\n<li>sizeof(Foo*) is created on the stack.</li>\n<li>sizeof(int) * 100 * 2  + sizeof(int *) is on the heap</li>\n</ul>\n<hr>\n<p>Example 2:</p>\n<pre><code>Foo bar;\n</code></pre>\n<ul>\n<li>x is on the stack, and y is on the heap</li>\n<li>sizeof(int) * 100 is on the stack (x) + sizeof(int*) </li>\n<li>sizeof(int) * 100 is on the heap (y)</li>\n</ul>\n<p>Actual sizes may differ slightly due to class/struct alignment depending on your compiler and platform.</p>\n</hr>", "OwnerUserId": "3153", "OwnerDisplayName": "Brian R. Bondy"}, "426787": {"ParentId": "426737", "CommentCount": "0", "CreationDate": "2009-01-09T01:53:46.560", "OwnerUserId": "12711", "Id": "426787", "PostTypeId": "2", "OwnerDisplayName": "Michael Burr", "Score": "10", "Body": "<p>Strictly speaking, according to the standard the object need not exist on a stack or heap.  The standard defines 3 types of 'storage duration', but doesn't state exactly how the storage must be implemented:</p>\n<ol>\n<li>static storage duration</li>\n<li>automatic storage duration</li>\n<li>dynamic storage duration</li>\n</ol>\n<p>Automatic storage duration is typically (nearly always) implemented using the stack.</p>\n<p>Dynamic storage duration is typically implemented using the heap (ultimately via <code>malloc()</code>), though this can be overridden even by the compiler's user.</p>\n<p>Static storage duration is what it typically known as globals (or static storage).</p>\n<p>The standard has this to say about these things (the following are excerpts form various bits of 3.7 - Storage Duration):</p>\n<blockquote>\n<p id=\"so_426737_426787_0\">Static and automatic storage durations\n  are associated with objects introduced\n  by declarations (3.1) and implicitly\n  created by the implementation (12.2).\n  The dynamic storage duration is\n  associated with objects created with\n  operator new (5.3.4).</p>\n<p id=\"so_426737_426787_1\">...</p>\n<p id=\"so_426737_426787_2\">All objects which neither have dynamic\n  storage duration nor are local have\n  static storage duration. The storage\n  for these objects shall last for the\n  duration of the program (3.6.2,\n  3.6.3).</p>\n<p id=\"so_426737_426787_3\">...</p>\n<p id=\"so_426737_426787_4\">Local objects explicitly declared auto\n  or register or not explicitly declared\n  static or extern have automatic\n  storage duration. The storage for\n  these objects lasts until the block in\n  which they are created exits.</p>\n<p id=\"so_426737_426787_5\">...</p>\n<p id=\"so_426737_426787_6\">Objects can be created dynamically\n  during program execution (1.9), using\n  new-expressions (5.3.4), and destroyed\n  using delete-expressions (5.3.5). A C\n  + + implementation provides access to, and management of, dynamic storage via\n  the global allocation functions\n  operator new and operator new[] and\n  the global deallocation functions\n  operator delete and operator delete[].</p>\n<p id=\"so_426737_426787_7\">...</p>\n<p id=\"so_426737_426787_8\">The library provides default\n  definitions for the global allocation\n  and deallocation functions. Some\n  global allocation and deallocation\n  functions are replaceable (18.4.1)</p>\n</blockquote>\n<p>And finally (regarding the array in your example class):</p>\n<blockquote>\n<p id=\"so_426737_426787_9\">3.7.4 Duration of sub-objects [basic.stc.inherit]</p>\n<p id=\"so_426737_426787_10\">The storage duration of member subobjects, base class subobjects and array elements is that of their complete\n  object (1.8).</p>\n</blockquote>\n", "LastActivityDate": "2009-01-09T01:53:46.560"}, "bq_ids": {"n4140": {"so_426737_426787_0": {"section_id": 7162, "quality": 0.8636363636363636, "length": 19}, "so_426737_426787_2": {"section_id": 7164, "quality": 0.6, "length": 12}, "so_426737_426787_8": {"section_id": 7174, "quality": 0.875, "length": 14}, "so_426737_426787_6": {"section_id": 7173, "quality": 0.8823529411764706, "length": 30}, "so_426737_426787_10": {"section_id": 7188, "quality": 0.9230769230769231, "length": 12}, "so_426737_426787_4": {"section_id": 7170, "quality": 0.7391304347826086, "length": 17}}, "n3337": {"so_426737_426787_0": {"section_id": 6906, "quality": 0.8636363636363636, "length": 19}, "so_426737_426787_2": {"section_id": 6908, "quality": 0.6, "length": 12}, "so_426737_426787_8": {"section_id": 6918, "quality": 0.875, "length": 14}, "so_426737_426787_6": {"section_id": 6917, "quality": 0.8823529411764706, "length": 30}, "so_426737_426787_10": {"section_id": 6932, "quality": 0.9230769230769231, "length": 12}, "so_426737_426787_4": {"section_id": 6914, "quality": 0.7391304347826086, "length": 17}}, "n4659": {"so_426737_426787_0": {"section_id": 8669, "quality": 0.7727272727272727, "length": 17}, "so_426737_426787_2": {"section_id": 8672, "quality": 0.6, "length": 12}, "so_426737_426787_8": {"section_id": 8682, "quality": 0.875, "length": 14}, "so_426737_426787_6": {"section_id": 8681, "quality": 0.8823529411764706, "length": 30}, "so_426737_426787_4": {"section_id": 8678, "quality": 0.6086956521739131, "length": 14}}}});