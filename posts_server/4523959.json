post_cb({"4523959": {"ViewCount": "12429", "Body": "<p>Recently, I was confused by the std::map operator[] function.\nIn the MSDN library, it says: \"If the argument key value is not found, then it is inserted along with the default value of the data type.\"\nI tryed to search much more exactly explanation for this issue. For example here:\n<a href=\"https://stackoverflow.com/questions/2333728/stdmap-default-value\">std::map default value</a>\nIn this page, Michael Anderson said that \"the default value is constructed by the default constructor(zero parameter constructor)\".</p>\n<p>Now my quest comes to this:\"what the default value for the build-in type?\". Was it compiler related? Or is there a standard for this issue by the c++ stardard committee?</p>\n<p>I did a test on visual studio 2008 for the \"int\" type, and found the \"int\" type is construted with the value 0.</p>\n", "AcceptedAnswerId": "4524064", "Title": "std::map default value for build-in type", "CreationDate": "2010-12-24T03:12:00.127", "Id": "4523959", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:56.753", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-19T00:15:21.800", "Score": "22", "OwnerUserId": "552942", "Tags": "<c++><default-value><stdmap>", "AnswerCount": "4"}, "12965621": {"Id": "12965621", "PostTypeId": "2", "Body": "<p>The C++11 standard still requires that std::map zero-initializes built in types (as did the previous standard), but the reasons are a bit different to those in Luke Halliwell's answer. In particular, to 'default-initialize' a built-in data type <em>doesn't</em> mean zero-initialize in the C++11 standard, but rather it would mean 'do nothing'. What actually happens in <code>std::map::operator[]</code> is a 'value-initialization'.</p>\n<p>Nevertheless, the end result in the new standard is the same as in Luke's answer. The values will be zero-initialized. Here are the relevant parts of the standard:</p>\n<p>Section 23.4.4.3 \"map element access\" says</p>\n<blockquote>\n<p id=\"so_4523959_12965621_0\">T&amp; operator[](const key_type&amp; x);</p>\n<p id=\"so_4523959_12965621_1\">Effects: If there is no key equivalent to x in the map, inserts <code>value_type(x, T())</code> into the map.</p>\n<p id=\"so_4523959_12965621_2\">...</p>\n</blockquote>\n<p>The expression <code>T()</code> is described in section 8.5</p>\n<blockquote>\n<p id=\"so_4523959_12965621_3\">An object whose initializer is an empty set of parentheses, i.e., (), shall be <strong>value-initialized</strong>.</p>\n<p id=\"so_4523959_12965621_4\"><code>X a();</code></p>\n</blockquote>\n<p>And this kind of 'value-initialization' is described in the same section</p>\n<blockquote>\n<p id=\"so_4523959_12965621_5\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T\n  is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</li>\n<li>if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if\n  T\u2019s implicitly-declared default constructor is non-trivial, that\n  constructor is called.</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li><strong>otherwise, the object is zero-initialized.</strong></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2012-10-19T00:15:21.800", "CommentCount": "0", "CreationDate": "2012-10-19T00:15:21.800", "ParentId": "4523959", "Score": "14", "OwnerUserId": "475491"}, "bq_ids": {"n4140": {"so_4523959_4524064_0": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_4523959_12965621_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 1007}, "so_4523959_4524064_1": {"length": 4, "quality": 0.8, "section_id": 3285}, "so_4523959_12965621_5": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_4523959_12965621_3": {"length": 7, "quality": 1.0, "section_id": 3290}}, "n3337": {"so_4523959_4524064_0": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_4523959_12965621_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 992}, "so_4523959_12965621_3": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_4523959_12965621_5": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_4523959_4524064_1": {"length": 4, "quality": 0.8, "section_id": 3155}}, "n4659": {"so_4523959_12965621_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 802}, "so_4523959_12965621_3": {"length": 7, "quality": 1.0, "section_id": 4052}}}, "4524021": {"Id": "4524021", "PostTypeId": "2", "Body": "<pre><code> |expression:   | POD type T                               | non-POD type T\n ==================================================================================================\n | new T         | not initialized                          | default-initialized\n | new T()       | always default-initialized               | always default-initialized\n | new T(x)      | always initialized via a constructor     | always initialized via a constructor\n</code></pre>\n<p>As far as i know, stl uses new T() for default values, so it will be default-initialized, in case of int to 0.</p>\n", "LastActivityDate": "2010-12-24T03:33:04.640", "CommentCount": "2", "CreationDate": "2010-12-24T03:33:04.640", "ParentId": "4523959", "Score": "2", "OwnerUserId": "455304"}, "4524002": {"Id": "4524002", "PostTypeId": "2", "Body": "<p>The default value of class-type objects is that set by the default constructor of the class. For built-in types the default value is 0.</p>\n<p>But note that there is a difference between a built-in variable that isn't initialized, and one initialized to its default value. A built-in that is not initialized will probably hold whatever value was in that variable's memory address at the time.</p>\n<pre><code>int i;          // i has an arbitrary undefined value\nint x = int();  // x is 0\n</code></pre>\n", "LastActivityDate": "2010-12-24T03:25:48.663", "CommentCount": "1", "CreationDate": "2010-12-24T03:25:48.663", "ParentId": "4523959", "Score": "6", "OwnerUserId": "456"}, "4524064": {"Id": "4524064", "PostTypeId": "2", "Body": "<p>This is defined in the standard, yes.  map is performing \"default initialization\" in this case.  As you say, for class types, that calls a no-arguments constructor.</p>\n<p>For built-in types, in the '98 standard, see section 8.5, \"Initializers\":</p>\n<blockquote>\n<p id=\"so_4523959_4524064_0\">To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a non-POD ...</li>\n<li>if T is an array type ...</li>\n<li>otherwise, the storage for the object is zero-initialized</li>\n</ul>\n</blockquote>\n<p>And, previously,</p>\n<blockquote>\n<p id=\"so_4523959_4524064_1\">To zero-initialize storage for an object of type T means:</p>\n<ul>\n<li>if T is a scalar type, the storage is set to the value 0 (zero) converted to T</li>\n</ul>\n</blockquote>\n<p>Scalar types are:</p>\n<ul>\n<li>Arithmetic types (integer, floating point)</li>\n<li>Enumeration types</li>\n<li>Pointer types</li>\n<li>Pointer to member types</li>\n</ul>\n<p>In particular, the behaviour you see with an integer (initialized to zero) is defined by the standard, and you can rely on it.</p>\n", "LastActivityDate": "2010-12-24T03:47:00.650", "CommentCount": "1", "CreationDate": "2010-12-24T03:47:00.650", "ParentId": "4523959", "Score": "21", "OwnerUserId": "3974"}});