post_cb({"bq_ids": {"n4140": {"so_33970892_33978450_3": {"length": 7, "quality": 1.0, "section_id": 3325}, "so_33970892_33978450_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 599}, "so_33970892_33978450_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}, "so_33970892_33970892_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 3325}, "so_33970892_33978450_2": {"length": 13, "quality": 0.8125, "section_id": 3296}}, "n3337": {"so_33970892_33978450_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3195}, "so_33970892_33978450_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 589}, "so_33970892_33978450_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}, "so_33970892_33970892_0": {"length": 14, "quality": 0.5833333333333334, "section_id": 3195}, "so_33970892_33978450_2": {"length": 13, "quality": 0.8125, "section_id": 3166}}, "n4659": {"so_33970892_33978450_3": {"length": 7, "quality": 1.0, "section_id": 660}, "so_33970892_33978450_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 622}, "so_33970892_33978450_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}, "so_33970892_33970892_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 4091}, "so_33970892_33978450_2": {"length": 13, "quality": 0.8125, "section_id": 4058}}}, "33970892": {"ViewCount": "124", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\nusing namespace std;\n\nstruct CL\n{\n    CL(){}\n    CL (std::initializer_list&lt;CL&gt;){cout&lt;&lt;1;}\n    CL (const CL&amp;){cout&lt;&lt;2;}\n};\n\nint main()\n{\n    CL cl1;\n    CL cl2 {cl1}; //prints 21\n}\n</code></pre>\n<p>Here is <em>CL</em> struct with copy constructor and initializer-list constructor. I think only copy constructor must be called here, because according to C++ 14 Standard, 8.5.4/3</p>\n<blockquote>\n<p id=\"so_33970892_33970892_0\">List-initialization of an object or reference of type T is defined as\n  follows:<br>\n  \u2014 If T is a class type and the initializer list has a\n  single element of type cv U, where U is T or a class derived from T,\n  the object is initialized from <strong>that element</strong> (by copy-initialization\n  for copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).<br>\n  \u2014 Otherwise, ...</br></br></p>\n</blockquote>\n<p>In other words, the initialization of <em>cl2</em> must be performed from <em>cl1</em> element, but not from the initializer-list <em>{cl1}</em>. Clang and gcc both print \"21\", only Visual Studio prints \"2\" and I think it's correct.<br>\nThere are two candidate constructors for taking an argument <em>cl1</em> of type CL:<br>\n1) Constructor with <code>std::initializer_list&lt;CL&gt;</code> (passes because no such conversion from CL to <code>std::initializer_list&lt;CL&gt;</code>)<br>\n2) Copy constructor with const CL&amp; (exact match with only qualification conversion non-const-&gt;const)</br></br></br></p>\n<p>Who is right? Whose behavior is correct?  </p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "33978450", "Title": "List-initialization priority from object of same type", "CreationDate": "2015-11-28T11:38:12.323", "Id": "33970892", "CommentCount": "7", "LastEditDate": "2015-11-29T02:37:05.527", "PostTypeId": "1", "LastEditorUserId": "1505939", "LastActivityDate": "2015-11-29T02:37:05.527", "Score": "1", "OwnerUserId": "3514538", "Tags": "<c++><constructor><language-lawyer><overload-resolution><list-initialization>", "AnswerCount": "1"}, "33978450": {"Id": "33978450", "PostTypeId": "2", "Body": "<p><strong>tl;dr:</strong> The published C++14 text specified output <code>21</code>. However, the behaviour of this code was changed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\" rel=\"nofollow\">CWG Issue 1467</a>, which gained the status of Defect in November 2014.  </p>\n<p>Defect Reports are considered to apply retroactively. clang 3.7 and VS2015 have applied the resolution suggested by this defect report, which appears in C++17 drafts as of N4296.</p>\n<hr>\n<p>Prior to this defect report, the behaviour was covered by this text from N4140 [over.match.list]:</p>\n<blockquote>\n<p id=\"so_33970892_33978450_0\">When objects of <strong>non-aggregate</strong> class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>\n</ul>\n<p id=\"so_33970892_33978450_1\">If the initializer list has no elements and T has a default constructor, the first phase is omitted. In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed. [Note: This differs from other situations (13.3.1.3, 13.3.1.4), where only converting constructors are considered for copy-initialization. This restriction only applies if this initialization is part of the final result of overload resolution.\n  \u2014end note ]</p>\n</blockquote>\n<p>Your class is not an aggregate because it has a user-provided constructor.</p>\n<p>The above text is directed-to by the following bullet point in [dcl.init.list]/3:</p>\n<blockquote id=\"so_33970892_33978450_2\">\n<ul>\n<li>Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). </li>\n</ul>\n</blockquote>\n<p>So, in the published C++14, the initializer-list constructor should actually be preferred to the copy-constructor, if it matches. C++11 had the same text.</p>\n<hr>\n<p>In your question you say that C++14 contains:</p>\n<blockquote>\n<p id=\"so_33970892_33978450_3\">If <code>T</code> is a class type and the initializer list has a single element of type [...]</p>\n</blockquote>\n<p>This text was not in C++14, but applied at a later date by a defect report. In the updated standard with the defect report applied (N4296), this appears as a bullet point higher up in the list of bullet points in [dcl.init.list]/3; so now the copy-constructor is selected ealier in the process and we do not get so far as the above [over.match.list] step.</p>\n<p>Note that although the defect is titled <em>List-initialization of aggregate from same-type object</em>, the resolution actually affects initialization of both aggregates and non-aggregates.</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-11-29T02:31:02.240", "Score": "2", "CreationDate": "2015-11-29T01:32:42.883", "ParentId": "33970892", "CommentCount": "2", "OwnerUserId": "1505939", "LastEditDate": "2015-11-29T02:31:02.240"}});