post_cb({"37521337": {"Id": "37521337", "PostTypeId": "2", "Body": "<p>You should remove the <code>&amp;&amp;</code> from <code>C</code>.</p>\n<p>The code is not as expensive as you imagine: <code>f</code>'s return value is a <a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization\">copy elision</a> context.  So the compiler is allowed to construct just a single <code>BigObject</code> directly in the memory space for <code>C</code>.  Even if a compiler doesn't perform this , it is still a move context so as worst case scenario the object will be moved.</p>\n<p>If somehow your object is copyable but not movable then you do have to rely on copy elision but it's hard to imagine a valid use case for such an object.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-30T08:46:33.473", "Score": "5", "CreationDate": "2016-05-30T08:46:33.473", "ParentId": "37521150", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T12:08:12.580"}, "bq_ids": {"n4140": {"so_37521150_37521808_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 382}}, "n3337": {"so_37521150_37521808_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 373}}, "n4659": {"so_37521150_37521808_0": {"length": 23, "quality": 0.6764705882352942, "section_id": 397}}}, "37521150": {"ViewCount": "77", "Body": "<p>For example I have a class that call a function in its consturctor that returns local object. I'm trying to use rvalue references to get access to this object to avoid expensive move of it in memory.</p>\n<pre><code>   class MyClass\n    {\n        BigObject&amp;&amp; C;\n        MyClass() : C(f())\n        {\n        };\n    };\n   BigObject f()\n   {\n       return BigObject();\n   }\n</code></pre>\n<p>But compiller tells me that reference member is initialized to a temporary that doesn't persist after the construction exits.</p>\n<p>I don't get it. I understand that local objects, created in a scope of a function, exists only in a scope of function. Reaching the end of the scope - destructors of local objects are called. And here I initialize rvalue reference with local object , and I have access to it, while I'm in the body of constuctor.</p>\n<p>Can someone explain, what is going on here? And is there a way to return a local object and use it as any ligetable class member, without moving it in memory?</p>\n", "Title": "How to use object that created locally in a function without copying it in memory?", "CreationDate": "2016-05-30T08:37:07.483", "LastActivityDate": "2016-05-31T02:02:21.407", "CommentCount": "7", "PostTypeId": "1", "Id": "37521150", "Score": "3", "OwnerUserId": "1972060", "Tags": "<c++><class><memory><rvalue-reference><rvalue>", "AnswerCount": "2"}, "37521808": {"Id": "37521808", "PostTypeId": "2", "Body": "<p>To quote it from the standard,<br/></p>\n<blockquote>\n<p id=\"so_37521150_37521808_0\">Section 12.2.5<br/> The second context is when a reference is bound to\n  a temporary. The temporary to which the reference is bound or the\n  temporary that is the complete object of a subobject to which the\n  reference is bound persists for the lifetime of the reference except:\n  \u2014 A temporary bound to a reference member in a constructor\u2019s\n  ctor-initializer (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n<p>So, in your case 'C(f())', C gets bound to the temporary only till the constructor exits and after that it's kind of UB and is upto your luck. You should be thankful that the compiler reported a warning :).</p>\n<p>Anyhow, there is no need to do such acrobatics, but you can always move from the temporary into 'C'.</p>\n<pre><code>class BigObject\n{\npublic:\n  BigObject() {std::cout &lt;&lt; \"Cons\" &lt;&lt; std::endl;}\n  BigObject(const BigObject&amp; other) {std::cout &lt;&lt; \"Copy Cons\" &lt;&lt; std::endl;}\n  BigObject(BigObject&amp;&amp; other) {std::cout &lt;&lt; \"Move Cons\" &lt;&lt; std::endl;}\n};\n\nBigObject f()\n{\n  return BigObject();\n}\n\nclass MyClass\n{\npublic:\n  BigObject C;\n\n  MyClass() : C(f())\n  {\n  };\n\n};\n</code></pre>\n<p>In this case compiler can very well elide the copy making the code as efficient as possible by just having to construct 'BigObject' once at the target site.</p>\n<p>So, in this particular case <em>it</em> <em>could</em> <em>be</em> <em>possible</em> that your object is not moved at all or even copied. Perhaps that answers your final question.</p>\n", "LastActivityDate": "2016-05-30T09:11:16.690", "CommentCount": "0", "CreationDate": "2016-05-30T09:11:16.690", "ParentId": "37521150", "Score": "1", "OwnerUserId": "434233"}});