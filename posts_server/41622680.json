post_cb({"bq_ids": {"n4140": {"so_41622680_41623145_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2189}}, "n3337": {"so_41622680_41623145_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2177}}, "n4659": {"so_41622680_41623145_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2462}}}, "41623145": {"Id": "41623145", "PostTypeId": "2", "Body": "<p>The standard requires that if the input value is out of range, the nearest available value is written to the destination, and the stream's <code>failbit</code> is set. The specific requirement (from [istream.formatted.arithmetic]/3) is:</p>\n<blockquote>\n<pre><code>operator&gt;&gt;(int&amp; val);\n</code></pre>\n<p id=\"so_41622680_41623145_0\">The conversion occurs as if performed by the following code fragment [...]:</p>\n<pre><code>iostate err = ios_base::goodbit;\nlong lval;\nuse_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);\nif (lval &lt; numeric_limits&lt;int&gt;::min()) {\n    err |= ios_base::failbit;\n    val = numeric_limits&lt;int&gt;::min();\n}\nelse if (numeric_limits&lt;int&gt;::max() &lt; lval) {\n    err |= ios_base::failbit;\n    val = numeric_limits&lt;int&gt;::max();\n}\nelse\n    val = static_cast&lt;int&gt;(lval);\nsetstate(err);\n</code></pre>\n</blockquote>\n<p>Once the stream's failbit is set, it's \"sticky\", so further attempts at extracting data will all fail immediately until the failbit is cleared.</p>\n", "LastActivityDate": "2017-01-12T21:16:38.797", "CommentCount": "0", "CreationDate": "2017-01-12T21:16:38.797", "ParentId": "41622680", "Score": "5", "OwnerUserId": "179910"}, "41622680": {"ViewCount": "188", "Body": "<p>I'm pulling numbers from a text file and filling an array of type int with them.</p>\n<p>I'm inserting the values into the array while looping through the .txt file with those lines of code (where k is the amount of numbers in the .txt file):</p>\n<pre><code>for (int j = 0; j &lt; k; j++)\n  inputFile &gt;&gt; tab[j];\n</code></pre>\n<p>When the numbers in the text file are less than 2,147,483,647 which is the maximum size of an integer type everything goes smooth.</p>\n<p>When the number is bigger than this the program as i assume overflows and fails to insert it but it also fails to insert any number after that.</p>\n<p>What is causing it to not insert any more numbers after the overflow happens?</p>\n", "AcceptedAnswerId": "41623168", "Title": "What happens when >> operator is trying to input a value bigger than a variable can contain?", "CreationDate": "2017-01-12T20:47:43.853", "Id": "41622680", "CommentCount": "1", "LastEditDate": "2017-01-12T20:49:46.363", "PostTypeId": "1", "LastEditorUserId": "23501", "LastActivityDate": "2017-01-12T23:25:54.430", "Score": "4", "OwnerUserId": "5953034", "Tags": "<c++><arrays><ifstream><integer-overflow>", "AnswerCount": "3"}, "41622719": {"Id": "41622719", "PostTypeId": "2", "Body": "<p>Undefined behaviour. Arithmetical overflow may be silently ignored or may cause a signal to be raised which terminates the program, depending on quality of implementation.</p>\n", "LastActivityDate": "2017-01-12T20:50:31.603", "CommentCount": "2", "CreationDate": "2017-01-12T20:50:31.603", "ParentId": "41622680", "Score": "-5", "OwnerUserId": "3310281"}, "41623168": {"Id": "41623168", "PostTypeId": "2", "Body": "<p>On <a href=\"http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt\" rel=\"nofollow noreferrer\"><code>std::istream&amp; std::istream::operator&gt;&gt;(std::istream&amp;, int&amp;)</code></a>, cppreference says:</p>\n<blockquote>\n<p id=\"so_41622680_41623168_0\">Behaves as a FormattedInputFunction. After constructing and checking the sentry object, which may skip leading whitespace, extracts an integer value by calling <code>std::num_get::get()</code></p>\n<p id=\"so_41622680_41623168_1\">...</p>\n<p id=\"so_41622680_41623168_2\">If extraction fails, zero is written to value and failbit is set. If extraction results in the value too large or too small to fit in value, <code>std::numeric_limits&lt;T&gt;::max()</code> or <code>std::numeric_limits&lt;T&gt;::min()</code> is written and failbit flag is set. <sup>(since c++11)</sup></p>\n</blockquote>\n<p>It's not normative, but it does provide a decent summary of what is happening here.</p>\n<p>FormattedInputFunctions will construct a sentry from the stream and check the value. If the sentry object evaluates as <code>false</code>, then <a href=\"http://en.cppreference.com/w/cpp/concept/FormattedInputFunction\" rel=\"nofollow noreferrer\">no input is performed</a>.</p>\n<p>The sentry object will evaluate as <code>false</code> if, <a href=\"http://en.cppreference.com/w/cpp/io/basic_istream/sentry\" rel=\"nofollow noreferrer\">among other situations</a>, the stream being operated on has the failbit set.</p>\n<hr>\n<p>So, what's happening is this:</p>\n<ol>\n<li>The stream tries to read in an integer too large to hold in the <code>int</code> data type. </li>\n<li>The <code>int</code> passed into its function is set to the maximum possible value an <code>int</code> can store.</li>\n<li>The stream passed into the function has its failbit set.</li>\n<li>Further reads to the stream fail and do nothing, because the stream's failbit is set.</li>\n</ol>\n<p>You can detect these overflow errors by checking the failbit and value of the integer after the read operation you are performing, as mentioned in the accepted answer to the question <a href=\"https://stackoverflow.com/questions/17116690/c-read-int-from-istream-detect-overflow\"><em>Read int from istream, detect overflow</em></a>.</p>\n<p>You can recover from these errors by <em>unsetting</em> the failbit with <a href=\"http://en.cppreference.com/w/cpp/io/basic_ios/clear\" rel=\"nofollow noreferrer\"><code>std::basic_ios::clear</code></a>. Following a call to <code>clear</code> which unsets the failbit, further reads will behave as you expect.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-12T23:25:54.430", "Score": "5", "CreationDate": "2017-01-12T21:18:00.477", "ParentId": "41622680", "CommentCount": "0", "OwnerUserId": "4892076", "LastEditDate": "2017-05-23T12:07:20.130"}});