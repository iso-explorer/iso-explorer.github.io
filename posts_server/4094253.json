post_cb({"4094253": {"CommentCount": "3", "AcceptedAnswerId": "4094438", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2010-11-04T06:01:24.353", "LastActivityDate": "2011-10-02T10:47:37.983", "LastEditDate": "2011-10-02T10:47:37.983", "ViewCount": "595", "FavoriteCount": "1", "Title": "Name lookup Clarification", "Id": "4094253", "Score": "2", "Body": "<blockquote>\n<p id=\"so_4094253_4094253_0\">$10.2/4- \"[ Note: Looking up a name in\n  an elaborated-type-specifier (3.4.4)\n  or base-specifier (Clause 10), for\n  instance, ignores all nontype\n  declarations, while looking up a name\n  in a nested-name-specifier (3.4.3)\n  ignores function, variable, and\n  enumerator declarations.\"</p>\n</blockquote>\n<p>I have found this statement to be very confusing in this section while describing about name lookup.</p>\n<pre><code>void S(){}\n\nstruct S{\n   S(){cout &lt;&lt; 1;}\n   void f(){}\n   static const int x = 0;\n}; \n\nint main(){ \n   struct S *p = new struct ::S;  // here ::S refers to type\n   p-&gt;::S::f();\n\n   S::x;  // base specifier, ignores the function declaration 'S'\n\n   ::S(); // nested name specifier, ignores the struct declaration 'S'.\n   delete p;\n} \n</code></pre>\n<p>My questions: </p>\n<ol>\n<li><p>Is my understanding of the rules correct? </p></li>\n<li><p>Why <code>::S</code> on the line doing new treated automatically to mean struct <code>S</code>, whereas in the last line <code>::S</code> means the functions <code>S</code> in the global namespace. </p></li>\n<li><p>Does this point to an ambiguity in the documentation, or is it yet another day for me to stay away from C++ Standard document?</p></li>\n</ol>\n", "Tags": "<c++><c++11><name-lookup>", "OwnerUserId": "418110", "AnswerCount": "2"}, "4094438": {"ParentId": "4094253", "CommentCount": "0", "Body": "<p>Q1: I think so.</p>\n<p>Q2: Compatibility with C.  When you declare a <code>struct</code> in C, the tag name is just that, a tag name.  To be able to use it in a standalone way, you need a <code>typedef</code>.  In C++ you don't need the typedef, that makes live easier.  But C++ rules have been complicated by the need to be able to import already existing C headers which \"overloaded\" the tag name with a function name.  The canonical example of that is the Unix <code>stat()</code> function which uses a <code>struct stat*</code> as argument.</p>\n<p>Q3: Standard reading is usually quite difficult... you need to already know that there is no place elsewhere modifying what you are reading.  It isn't strange that people knowing how to do that are language lawyer...</p>\n", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "4094438", "Score": "1", "CreationDate": "2010-11-04T06:43:08.247", "LastActivityDate": "2010-11-04T06:43:08.247"}, "bq_ids": {"n4140": {"so_4094253_4094253_0": {"section_id": 6992, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_4094253_4094253_0": {"section_id": 6738, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_4094253_4094253_0": {"section_id": 8490, "quality": 0.8260869565217391, "length": 19}}}, "7066748": {"ParentId": "4094253", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are mistaken about the second comment. In <code>S::x</code>, the <code>S</code> is a name in a nested name specifier. What the Standard refers to with \"base-specifier\" is the following</p>\n<pre><code>namespace B { struct X { }; void X() }\nstruct A : B::X { }; // B::X is a base-specifier\n</code></pre>\n<p>You are also not correct about this:</p>\n<blockquote>\n<p id=\"so_4094253_7066748_0\"><code>::S();</code> <em>// nested name specifier, ignores the struct declaration 'S'.`</em></p>\n</blockquote>\n<p>That code calls the function not because <code>::S</code> would be a nested-name-specifier (it isn't a nested-name-specifier!), but because function names hide class or enumeration names if both the function and the class/enumeration are declared in the same scope.</p>\n<p>FWIW, the following code would be equally valid for line 2 of your main</p>\n<pre><code>p-&gt;S::f();\n</code></pre>\n<p>What's important is that <code>S</code> preceedes a <code>::</code>, which makes lookup ignore the function. That you put <code>::</code> <em>before</em> <code>S</code> has no effect in your case. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-08-15T15:23:12.303", "Id": "7066748", "Score": "0", "CreationDate": "2011-08-15T15:17:53.720", "LastActivityDate": "2011-08-15T15:23:12.303"}});