post_cb({"bq_ids": {"n4140": {"so_32100245_32100749_1": {"length": 14, "quality": 0.5384615384615384, "section_id": 7223}, "so_32100245_32100749_0": {"length": 17, "quality": 1.0, "section_id": 7223}}, "n3337": {"so_32100245_32100749_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 5913}, "so_32100245_32100749_0": {"length": 17, "quality": 1.0, "section_id": 6967}}, "n4659": {"so_32100245_32100749_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 8732}, "so_32100245_32100749_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 8732}, "so_32100245_32100749_2": {"length": 48, "quality": 0.9411764705882353, "section_id": 8732}}}, "32100960": {"Id": "32100960", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32100245_32100960_0\">What I really want to understand is: what does \"p points to object x\" means.</p>\n</blockquote>\n<p>The object <code>p</code> contains a value that corresponds to the location of the object <code>x</code> in memory.  </p>\n<p>That's it.  That's all it means.  You seem determined to make this more complicated than it needs to be.  </p>\n<p>Pointer types are not arithmetic types, and aren't meant to be arbitrarily munged like that.  Valid pointer values are obtained by using the unary <code>&amp;</code> operator on an lvalue, using an array expression that isn't the operand of the <code>sizeof</code> or unary <code>&amp;</code> operator, or calling a library function that returns a pointer value.  </p>\n<p><em>Everything</em> beyond that (size, representation, physical vs. virtual, etc.) is an <strong>implementation detail</strong>, and implementations vary <em>widely</em> when it comes to representing addresses.  That's why the standards don't say <em>anything</em> about what to expect when you play Dr. Frankenstein with pointer values.  </p>\n<p>If you are intimately familiar with your platform's addressing conventions (both virtual and physical), and you know how your implementation lays out items in memory and how it represents pointer types, and you have a <em>valid use case</em> for hacking your pointer values this way, then hack away to your heart's content - neither language standard has anything to say on the subject.  </p>\n", "LastActivityDate": "2015-08-19T16:27:24.533", "CommentCount": "3", "CreationDate": "2015-08-19T16:27:24.533", "ParentId": "32100245", "Score": "3", "OwnerUserId": "134554"}, "32100245": {"ViewCount": "1178", "Body": "<p>This is a new question in my \"I don't understand pointers in C and C++\" collection. </p>\n<p>If I mix the bits of two pointers with equal values (pointing to the same memory address), that happen to have exactly the same bit representation, when one is dereferenceable and one is one past the end, what does the standard say should happen?</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n\n// required: a == b\n// returns a copy of both a and b into dest \n// (half of the bytes of either pointers)\nint *copy2to1 (int *a, int *b) {\n    // check input: \n    // not only the pointers must be equal\n    assert (a == b);\n    // also the representation must match exactly\n    int *dest;\n    size_t s = sizeof(dest);\n    assert(memcmp(&amp;a, &amp;b, s) == 0); \n\n    // copy a and b into dest:\n    // on \"exotic\" architectures, size does't have to be dividable by 2\n    size_t half = s/2; // = floor(s/2), \n    char *pa = (char*)&amp;a, *pb = (char*)&amp;b, *pd = (char*)&amp;dest;\n\n    // copy half of a into dest:\n    memcpy (pd, pa, half);\n    // copy half of b into dest:\n    memcpy (pd+half, pb+half, s-half); // s-half = ceil(s/2)\n\n    //printf (\"a:%p b:%p dest:%p \\n\", a, b, dest);    \n\n    // check result\n    assert(memcmp(&amp;dest, &amp;a, s) == 0);\n    assert(memcmp(&amp;dest, &amp;b, s) == 0);\n\n    return dest;\n}\n\n#define S 1 // size of inner array\n\nint main(void) {\n    int a[2][S] = {{1},{2}};\n    int *past = a[0] + S, // one past the end of inner array a[0]\n        *val = &amp;a[1][0], // valid dereferenceable pointer\n        *mix = copy2to1 (past, val);\n    #define PRINT(x) printf (\"%s=%p, *%s=%d\\n\",#x,x,#x,*x)\n    PRINT(past);\n    PRINT(mix);\n    PRINT(val);\n    return 0;\n}\n</code></pre>\n<p>What I really want to understand is: <strong>what does \"p points to object x\" mean?</strong></p>\n<p>SEE ALSO</p>\n<p>This question is a better version of my previous questions about array of arrays: </p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/32048698/963864\">Is memcpy of a pointer the same as assignment?</a> which is a variation on my other question:</li>\n<li><a href=\"https://stackoverflow.com/q/32043795/963864\">Dereferencing an out of bound pointer that contains the address of an object (array of array)</a> </li>\n</ul>\n<p>and other related questions about pointer validity:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/32045888/963864\">Are pointer variables just integers with some operators or are they \"mystical\"?</a></li>\n<li>and the C++ question: <a href=\"https://stackoverflow.com/q/32043314/963864\">Overwriting an object with an object of same type</a></li>\n</ul>\n", "Title": "Dereferencing a 50% out of bound pointer (array of array)", "CreationDate": "2015-08-19T15:49:43.970", "LastActivityDate": "2017-03-07T17:58:16.243", "CommentCount": "43", "LastEditDate": "2017-05-23T12:25:13.667", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "32100245", "Score": "-1", "OwnerUserId": "963864", "Tags": "<c++><c><arrays><pointers><language-lawyer>", "AnswerCount": "3"}, "32103759": {"Id": "32103759", "PostTypeId": "2", "Body": "<p>The second assert</p>\n<pre><code>assert(memcmp(&amp;a, &amp;b, s) == 0); \n</code></pre>\n<p>can legitimately fail, as pointers that compare equal are not required to have identical representation.</p>\n<p>Once this assert is passed, everything else is OK, because <code>memcpy</code> is a legitimate way to copy pointers. In modern C++-speak, pointers are trivially copyable. It is permitted to assemble such objects from bytes and it doesn't matter where these bytes come from. </p>\n<p>If two such objects are <code>memcmp</code>'d equal, they hold the same value (which is stronger than \"compare equal\": they are interchangeable, while pointers that compare equal need not be). A least such is the spirit of the standard, I won't vouch for the letter.</p>\n", "LastActivityDate": "2015-08-19T19:11:48.893", "CommentCount": "0", "CreationDate": "2015-08-19T19:11:48.893", "ParentId": "32100245", "Score": "3", "OwnerUserId": "775806"}, "32100749": {"Id": "32100749", "PostTypeId": "2", "Body": "<p>In [basic.compound]:</p>\n<blockquote>\n<p id=\"so_32100245_32100749_0\">If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the\n  address <code>A</code> is said to point to that object, <strong>regardless of how the value was obtained</strong>.</p>\n</blockquote>\n<p><code>past</code> and <code>val</code> have the same address, so they point to the same object. It doesn't matter that one is \"one past the end\" of the first row and the second is the first element of the second row. There is a valid object at that address, so everything here is perfectly reasonable. </p>\n<hr/>\n<p>In C++17, as of <a href=\"http://wg21.link/p0137\" rel=\"nofollow noreferrer\">P0137</a>, this changes a lot. Now, [basic.compound] defines pointers as:</p>\n<blockquote>\n<p id=\"so_32100245_32100749_1\">Every value of pointer type is one of the following:<br>\n  \u2014 a <em>pointer to</em> an object or function (the pointer is said to <em>point</em> to the object or function), or<br>\n  \u2014 <em>a pointer past the end of</em> an object (5.7), or<br>\n  \u2014 the <em>null pointer value</em> (4.11) for that type, or<br>\n  \u2014 an <em>invalid pointer value</em>.</br></br></br></br></p>\n</blockquote>\n<p>So now, <code>past</code> is a value of the 2nd type (a pointer past the end of), but <code>val</code> is a value of the 1st type (a pointer to). Those are different categories of values and are not comparable:</p>\n<blockquote>\n<p id=\"so_32100245_32100749_2\">A value of a pointer type that is a pointer to or past the end of an object represents the address of the first byte in memory (1.7) occupied by the object or the first byte in memory after the end of the storage occupied by the object, respectively. <em>[ Note:</em> A pointer past the end of an object (5.7) is not considered to point to an unrelated object of the object\u2019s type that might be located at that address. A pointer value becomes invalid when the storage it denotes reaches the end of its storage duration; see 3.7. <em>\u2014end note ]</em></p>\n</blockquote>\n<p><code>past</code> doesn't point to something, so viewing its contents as if it were the same as <code>val</code> is no longer meaningful. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-07T17:58:16.243", "Score": "9", "CreationDate": "2015-08-19T16:14:11.170", "ParentId": "32100245", "CommentCount": "11", "OwnerUserId": "2069064", "LastEditDate": "2017-03-07T17:58:16.243"}});