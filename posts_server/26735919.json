post_cb({"bq_ids": {"n4140": {"so_26735919_26736262_0": {"length": 11, "quality": 0.6875, "section_id": 263}}, "n3337": {"so_26735919_26736262_0": {"length": 11, "quality": 0.6875, "section_id": 254}}, "n4659": {"so_26735919_26736262_0": {"length": 11, "quality": 0.6875, "section_id": 270}}}, "26735919": {"ViewCount": "382", "Body": "<p>I have some code that boils down to this:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct CByteArray {};\n\nstruct CIODevice {\n    template &lt;typename T&gt;\n    CIODevice&amp; operator&lt;&lt; (T value)\n    {\n        static_assert(std::is_pod&lt;T&gt;::value, \"This method is only intended for POD types\");\n        return *this;\n    }\n\n    template &lt;&gt;\n    CIODevice&amp; operator&lt;&lt; (CByteArray data)\n    {\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n    CIODevice&amp; operator&gt;&gt; (T&amp; value)\n    {\n        static_assert(std::is_pod&lt;T&gt;::value, \"This method is only intended for POD types\");\n        return *this;\n    }\n};\n\nint main()\n{\n    CIODevice device;\n    int i = 0;\n    device &lt;&lt; i;\n    device &gt;&gt; i;\n    return 0;\n}\n</code></pre>\n<p>It compiles in MSVC, but in GCC I get this: </p>\n<pre class=\"lang-none prettyprint-override\"><code>prog.cpp:13:12: error: explicit specialization in non-namespace scope \u2018struct CIODevice\u2019\n  template &lt;&gt;\n            ^\nprog.cpp:20:11: error: too many template-parameter-lists\n  CIODevice&amp; operator&gt;&gt; (T&amp; value)\n           ^\nprog.cpp: In function \u2018int main()\u2019:\nprog.cpp:32:9: error: no match for \u2018operator&gt;&gt;\u2019 (operand types are \u2018CIODevice\u2019 and \u2018int\u2019)\n  device &gt;&gt; i;\n     ^\n</code></pre>\n<p><a href=\"http://ideone.com/We5PYn\" rel=\"nofollow\">Live sample</a>.</p>\n<p>I don't get it, what's the mistake here?</p>\n", "AcceptedAnswerId": "26736262", "Title": "Specializing a template method of a non-template class - works in MSVC, compilation error in GCC", "CreationDate": "2014-11-04T13:06:53.920", "Id": "26735919", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-04T13:49:40.267", "LastEditorUserId": "3747990", "LastActivityDate": "2014-11-04T15:14:08.573", "ClosedDate": "2014-11-04T16:09:29.827", "Score": "2", "OwnerUserId": "634821", "Tags": "<c++><templates><gcc><template-specialization>", "AnswerCount": "2"}, "26736262": {"Id": "26736262", "PostTypeId": "2", "Body": "<p>C++ specification \u00a7 14.7.3 (excerpt);</p>\n<blockquote id=\"so_26735919_26736262_0\">\n<ol>\n<li>An explicit specialization of any of the following: ...<br>\n<ul>\n<li>member function template of a class or class template ...   </li>\n</ul></br></li>\n<li>An explicit specialization shall be declared in a namespace enclosing the specialized template.</li>\n</ol>\n</blockquote>\n<p>Basically, it must be declared in the namespace scope (as GCC and Clang require).</p>\n<pre><code>struct CIODevice {\n    template &lt;typename T&gt;\n    CIODevice&amp; operator&lt;&lt; (T value)\n    {\n        static_assert(std::is_pod&lt;T&gt;::value, \"This method is only intended for POD types\");\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n    CIODevice&amp; operator&gt;&gt; (T&amp; value)\n    {\n        static_assert(std::is_pod&lt;T&gt;::value, \"This method is only intended for POD types\");\n        return *this;\n    }\n};\n\ntemplate &lt;&gt;\nCIODevice&amp; CIODevice::operator&lt;&lt; (CByteArray data)\n{\n    return *this;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2e7f72ca25c0ad9c\" rel=\"nofollow\"><strong>Sample code</strong></a>.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2014-11-04T15:14:08.573", "Score": "4", "CreationDate": "2014-11-04T13:24:57.927", "ParentId": "26735919", "CommentCount": "3", "OwnerUserId": "3747990", "LastEditDate": "2014-11-04T15:14:08.573"}, "26736144": {"Id": "26736144", "PostTypeId": "2", "Body": "<p>See also <a href=\"https://stackoverflow.com/questions/3052579/explicit-specialization-in-non-namespace-scope\">this</a>.</p>\n<p>Basically, MSVC is wrong and GCC is right, you can not do that.</p>\n<p>Why don't you use overloading instead of specialization? Try:</p>\n<pre><code>template &lt;typename T&gt;\nCIODevice&amp; operator&lt;&lt; (T value)\n{\n    static_assert(std::is_pod&lt;T&gt;::value, \"This method is only intended for POD types\");\n    return *this;\n}\n\n// template &lt;&gt; // &lt;--- Remove this\nCIODevice&amp; operator&lt;&lt; (CByteArray data)\n{\n    return *this;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-04T13:19:29.087", "Score": "1", "CreationDate": "2014-11-04T13:19:29.087", "ParentId": "26735919", "CommentCount": "1", "OwnerUserId": "666785", "LastEditDate": "2017-05-23T12:24:28.467"}});