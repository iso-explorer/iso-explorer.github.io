post_cb({"41670800": {"CommentCount": "4", "ViewCount": "267", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-01-16T06:44:32.257", "LastActivityDate": "2017-01-16T12:37:55.397", "Title": "Does redefining a function from the standard library violate the one-definition rule?", "AcceptedAnswerId": "41672338", "LastEditDate": "2017-05-23T11:45:49.073", "Id": "41670800", "Score": "4", "Body": "<pre><code>#include &lt;cmath&gt;\n\ndouble log(double) {return 1.0;}\nint main() {\n  log(1.0);\n}\n</code></pre>\n<p>Suppose the function <code>log()</code> in <code>&lt;cmath&gt;</code> is declared in global namespace (this is unspecified in fact, and we just make this assumption), then it refers to the same function as the <code>log()</code> function we defined.<br>\nSo does this code violate the one-definition rule (see <a href=\"http://www.eel.is/c++draft/basic.def.odr#4\" rel=\"nofollow noreferrer\">here</a>, since no diagnostic required, this code may compile in some compiler and we cannot assert if it is correct)?</br></p>\n<p><strong>Note</strong>: After recent edits, this is not a duplicate of: <a href=\"https://stackoverflow.com/q/4192170/514235\">What exactly is One Definition Rule in C++?</a></p>\n", "Tags": "<c++><standards><c++-standard-library><one-definition-rule><c-standard-library>", "OwnerUserId": "5376789", "AnswerCount": "3"}, "41672338": {"ParentId": "41670800", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-01-16T08:39:56.277", "Score": "3", "LastEditorUserId": "153285", "LastEditDate": "2017-01-16T08:48:00.140", "Id": "41672338", "OwnerUserId": "153285", "Body": "<h1>Typical scenario.</h1>\n<p>If <code>extern \"C\" double log(double)</code> is initially declared in the global namespace, then you have redeclared it and provided a definition. The implementation's previous mention of <code>extern \"C\"</code> carries over to your matching redeclaration. Your definition applies to the function belonging to the implementation, and it is an ODR violation.</p>\n<p>As for the manifestation of UB: It's apparently common to treat <code>log</code> as a weak linker symbol. Your implementation overrides <code>libc.so</code> according to ABI rules.</p>\n<p>(If the implementation doesn't do <code>extern \"C\"</code>, it's still basically all the same.)</p>\n<h1>Other likely scenario.</h1>\n<p>If <code>log</code> is declared in <code>namespace std</code> and then brought into the global namespace, then your declaration will conflict with it. (Actually, a <code>using</code> declaration is technically a declaration.) This error is diagnosed.</p>\n<h1>Assumption-violating scenario.</h1>\n<blockquote>\n<p id=\"so_41670800_41672338_0\">then it refers to the same function as the <code>log</code> function we defined</p>\n</blockquote>\n<p>One way for the implementation to put <code>&lt;cmath&gt;</code> names into the global namespace would be to declare <code>extern \"C\"</code> functions inside <code>namespace std</code>, then do <code>using namespace std</code>, and to ensure that this always happens as the first thing when any standard header is included. Since <code>using namespace</code> isn't \"sticky\" \u2014 it only applies to preceding declarations in the nominated namespace \u2014 the rest of the standard library would not be made visible. (This would not <em>declare</em> the names in the global namespace, but the standard only says \"placed within the global namespace scope.\")</p>\n<p>In such an implementation, your declaration would hide the standard one and declare a new function with a new mangled name (say <code>_Z3logd</code> instead of simply <code>log</code>) and a new fully-qualified name (<code>::log</code> instead of <code>::std::log</code>). Then there would be no ODR violation (unless some inline function uses one <code>log</code> in one TU and the other in a different TU).</p>\n", "LastActivityDate": "2017-01-16T08:48:00.140"}, "41670857": {"ParentId": "41670800", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2017-01-16T06:48:40.473", "Score": "3", "LastEditorUserId": "817643", "LastEditDate": "2017-01-16T08:30:34.127", "Id": "41670857", "OwnerUserId": "817643", "Body": "<p><strong>The following addresses a previous revision of the OP. I leave it here in case future readers come here with a similar query.</strong></p>\n<blockquote>\n<p id=\"so_41670800_41670857_0\">I guess that two names refer to the same entity if and only if they have the same declarative region, where the concept \"declarative region\" is defined in the standard [...] Is this guess correct? Is there any word in the standard supporting this?</p>\n</blockquote>\n<p>It's called variable hiding or shadowing colloquially. And the standard says what you said almost verbatim. <a href=\"http://eel.is/c++draft/basic.scope.hiding#1\" rel=\"nofollow noreferrer\">\u00a73.3.10 \u00b61</a> in the current C++17 standard draft:</p>\n<blockquote>\n<p id=\"so_41670800_41670857_1\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_41670800_41670857_2\">So does this code violate the one-definition rule (see here, since no diagnostic required, this code may compile in some compiler and we cannot assert it is correct)?</p>\n</blockquote>\n<p>I won't expect it to. The standard requires that <em>all</em> <code>cheader</code> headers (and in particular <code>cmath</code>) introduce their symbols in the <code>std</code> namespace. An implementation that also pours it into the global namespace is standard conforming (since the standard leaves that bit as unspecified), but I would find in bad form. You are correct that it <em>could</em> happen. Now if you were to include <code>math.h</code> (against sage advice) then that would definitely result in a violation of the one definition rule. </p>\n</hr>", "LastActivityDate": "2017-01-16T08:30:34.127"}, "bq_ids": {"n4140": {"so_41670800_41672455_0": {"section_id": 5313, "quality": 1.0, "length": 29}, "so_41670800_41670857_1": {"section_id": 7078, "quality": 1.0, "length": 12}, "so_41670800_41672338_0": {"section_id": 5404, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_41670800_41672455_0": {"section_id": 5110, "quality": 1.0, "length": 29}, "so_41670800_41670857_1": {"section_id": 6822, "quality": 1.0, "length": 12}, "so_41670800_41672338_0": {"section_id": 5199, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_41670800_41672455_0": {"section_id": 6737, "quality": 1.0, "length": 29}, "so_41670800_41670857_1": {"section_id": 8579, "quality": 1.0, "length": 12}, "so_41670800_41672338_0": {"section_id": 8540, "quality": 0.8571428571428571, "length": 6}}}, "41672455": {"ParentId": "41670800", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-01-16T08:48:31.293", "Score": "2", "LastEditorUserId": "3545273", "LastEditDate": "2017-01-16T12:37:55.397", "Id": "41672455", "OwnerUserId": "3545273", "Body": "<p>Beware. The ODR only concerns definitions that will be included in the resulting program. That means that is does not concern symbols that could be present in libraries, because a (normal) linker does not load the whole libraries, but only the parts that are required to resolve symbols. For example in this code:</p>\n<pre><code>#include &lt;cmath&gt;\n\ndouble log(double) {return 1.0;}\n\nint main()\n{\n    log(1.0);\n}\n</code></pre>\n<p>There is no violation of the ODR:</p>\n<ul>\n<li>either the log symbol from the C standard library was only included in the <code>std</code> namespace and there is no collision at all</li>\n<li>or it is also included in global namespace</li>\n</ul>\n<p>In latter case, the <em>declaration</em> <code>double log(double)</code> does not conflict with the one from cmath because it is the same. And as the symbol <code>log</code> is already defined, its <em>definition</em> from the standard library will not be included in the program. As such, only one definition for the <code>log</code> function exists in the program, that one: <code>double log(double) {return 1.0;}</code>.</p>\n<p>Things would be different if you extracted the object module containing <code>log</code> from the math library and explicitely link it in your program. Because object modules are always included in the resulting program whereas object modules in libraries are only <em>conditionaly</em> included if they resolve undefined symbols.</p>\n<hr>\n<p>References from standard:</p>\n<p>Draft n3337 for C++11 or n4296 for C++14 (or n4618 for last revision) are explicit in paragraph 2.2 Phases of translation [lex.phases]: </p>\n<blockquote>\n<p id=\"so_41670800_41672455_0\">\u00a79. All external entity references are resolved. <strong>Library components are linked to satisfy external references\n  to entities not defined in the current translation</strong>. All such translator output is collected into a program\n  image which contains information needed for execution in its execution environment.</p>\n</blockquote>\n<p>As shown code uses only one translation unit and as <code>log</code> is already defined in it, the definition from the library will not be used.</p>\n</hr>", "LastActivityDate": "2017-01-16T12:37:55.397"}});