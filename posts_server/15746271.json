post_cb({"15747274": {"Id": "15747274", "PostTypeId": "2", "Body": "<p>variable scope \nIn front of x will be overwritten.\nint x = x;\nThis one there are two processes.\nOne: int x;(define variable x and allocate memory and specify the initial value : x = 0);\nthis moment , the front x will be hidden.\nTwo: x = x;(Do not find the value x);</p>\n", "LastEditorUserId": "1942767", "LastActivityDate": "2015-01-27T07:23:48.437", "Score": "0", "CreationDate": "2013-04-01T16:29:27.163", "ParentId": "15746271", "CommentCount": "0", "OwnerUserId": "1942767", "LastEditDate": "2015-01-27T07:23:48.437"}, "bq_ids": {"n4140": {"so_15746271_15746272_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 7049}}, "n3337": {"so_15746271_15746272_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 6794}}, "n4659": {"so_15746271_15746272_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 8546}}}, "15746271": {"ViewCount": "1328", "Body": "<p>Why isn't the output <code>101</code> while I assigned the previous <code>x</code> to the new <code>x</code>?</p>\n<pre><code>int x = 101;\n{\n    int x = x;\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output (garbage):</p>\n<blockquote>\n<p id=\"so_15746271_15746271_0\">422634</p>\n</blockquote>\n<p>I thought the second <code>x</code> would be initialized to <code>101</code>  but it isn't initialized.</p>\n<p>Note: The solution in this case is <code>int x = ::x</code> but the question is <em>why</em> it happens.</p>\n", "AcceptedAnswerId": "15746272", "Title": "Point of declaration in C++", "CreationDate": "2013-04-01T15:26:28.280", "Id": "15746271", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-10-02T07:04:56.730", "LastEditorUserId": "952747", "LastActivityDate": "2015-01-27T07:23:48.437", "Score": "32", "OwnerUserId": "952747", "Tags": "<c++>", "AnswerCount": "3"}, "15746501": {"Id": "15746501", "PostTypeId": "2", "Body": "<p>There's another way to do it.</p>\n<pre><code>#include &lt;iostream&gt;\nint x = 101;\nint main()\n{\n  int x = ::x;\n  std::cout &lt;&lt; x &lt;&lt; std::endl;\n  std::cin.get();\n}\n</code></pre>\n", "LastActivityDate": "2013-04-01T15:39:00.780", "CommentCount": "2", "CreationDate": "2013-04-01T15:39:00.780", "ParentId": "15746271", "Score": "9", "OwnerUserId": "2232025"}, "15746272": {"Id": "15746272", "PostTypeId": "2", "Body": "<h2><em>Point of declaration</em></h2>\n<blockquote>\n<p id=\"so_15746271_15746272_0\">The point of declaration for a name is immediately after its complete\n  declarator and before its initializer... [C++ Standard \u00a7 3.3.2/1]</p>\n</blockquote>\n<p>Compiler completes the declaration when it knows enough about declarator.</p>\n<p>Above code is equal to the below one:</p>\n<pre><code>int x = 101;\n{\n  int x;\n  x = x; &lt;------------------// Self assignment, assigns an indeterminate value.\n  std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Because, the declaration of inner <code>x</code> completed before <code>=</code> (assignment)</p>\n<pre><code>int x = x; &lt;--// Now, we have the new `x` which hides the older one, \n     ^        // so it assigns itself to itself\n     |\n     +---// Point of declaration,\n         // here compiler knows everything to declare `x`.\n         // then declares it.\n</code></pre>\n<p>\u00a0</p>\n<p>On the other hand, when we declaring complex objects, the point of declaration is farther. So, the behavior is different.</p>\n<p>For example, below code is OK</p>\n<pre><code>const int i = 2;\n{\n  int i[i];\n         ^\n         |\n         +----// Point of declaration\n              // compiler has to reach to \"]\"\n              // therefore before declaring `i` as an array\n              // there is just one `i`, the `i` of `const int i=2`\n}\n</code></pre>\n<p>In above code, compiler has to know the actual size of the array to complete the declaration, so the point of declaration is <code>]</code>. Therefore the <code>i</code> within <code>[i]</code> is the outer <code>i</code> because declaration of the <code>i</code> of <code>int i[...</code> isn't completed yet. Thus, it declares an array with <code>2</code> elements (<code>int i[2];</code>).</p>\n<p>\u00a0</p>\n<p>Also, this example shows the point of declaration for an enumerator</p>\n<pre><code>const int x = 12;\n{\n  enum { x = x };\n               ^\n               |\n               +---// Point of declaration\n                   // compiler has to reach to \"}\" then\n                   // there is just one `x`, the `x` of `const int x=12`\n\n}\n</code></pre>\n<p>The enumerator <code>x</code> is initialized with the value of the constant <code>x</code>, namely <code>12</code>.</p>\n", "LastEditorUserId": "952747", "LastActivityDate": "2014-11-06T10:02:48.917", "Score": "43", "CreationDate": "2013-04-01T15:26:28.280", "ParentId": "15746271", "CommentCount": "2", "OwnerUserId": "952747", "LastEditDate": "2014-11-06T10:02:48.917"}});