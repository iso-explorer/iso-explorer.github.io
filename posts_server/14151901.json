post_cb({"14151961": {"ParentId": "14151901", "CommentCount": "2", "CreationDate": "2013-01-04T06:06:39.750", "OwnerUserId": "1520364", "PostTypeId": "2", "Id": "14151961", "Score": "1", "Body": "<pre><code>template class A&lt;true&gt;;\ntemplate class A&lt;false&gt;;\n</code></pre>\n<p>The <strong>same reason</strong> why it is typically expected that template code is defined in the header itself. To perform explicit instantiation, you (the compiler) need to be able to <strong>see the entire definition</strong> of the template class, which isn't possible from your <code>main.cpp</code>.</p>\n<p>However <code>a.cpp</code> has access to all of the definition of the class (here the print method) so explicit instantiation works there.</p>\n", "LastActivityDate": "2013-01-04T06:06:39.750"}, "14152081": {"ParentId": "14151901", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-01-04T06:16:55.773", "Score": "8", "LastEditorUserId": "777186", "LastEditDate": "2013-01-04T10:22:00.857", "Id": "14152081", "OwnerUserId": "777186", "Body": "<p>I don't think there is a good <em>natural</em> explanation for why this is so. Clearly, the compiler could see the definition of the member function even if it is provided after the explicit instantiation \u2013 because it is located in the same file.</p>\n<p>However, compilers are not required to this; it is in fact explicitly forbidden by the Standard:</p>\n<blockquote>\n<p id=\"so_14151901_14152081_0\">(\u00a714.7.2/9) An explicit instantiation definition that names a class template specialization explicitly instantiates the class template specialization and is an explicit instantiation definition of only those members that have been defined at the point of instantiation.</p>\n</blockquote>\n<p>I guess the reasons for this include the following:</p>\n<ul>\n<li><p>There could be several distinct explicit specializations for <em>some</em> of the member functions later in the translation unit; it makes sense, also in the programmer's interest, to have an explicit rule about which of these will be instantiated;</p></li>\n<li><p>When a template is <em>implicitly</em> instantiated, only specializations defined before the point of instantiation are taken into account; so the rule is the same for implicit and explicit instantiations.</p></li>\n</ul>\n", "LastActivityDate": "2013-01-04T10:22:00.857"}, "14151901": {"CommentCount": "4", "ViewCount": "1008", "PostTypeId": "1", "LastEditorUserId": "1406686", "CreationDate": "2013-01-04T06:01:29.757", "LastActivityDate": "2013-01-04T10:22:00.857", "Title": "Why does position of explicit template instantiation matter", "AcceptedAnswerId": "14152081", "LastEditDate": "2013-01-04T06:17:21.253", "Id": "14151901", "Score": "5", "Body": "<p>Say I declare a template class <code>A</code> in <code>a.h</code></p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;bool b&gt;\nclass A { \npublic:\n  void print(std::ostream&amp; out);\n};\n</code></pre>\n<p>And define the print method in <code>a.cpp</code> (with explicit instatiation for <code>true</code> and <code>false</code>) </p>\n<pre><code>#include \"a.h\"\n\ntemplate&lt;bool b&gt;\nvoid A&lt;b&gt;::print(std::ostream&amp; out) {\n  out &lt;&lt; \"A\" &lt;&lt; b;\n}\n\ntemplate class A&lt;true&gt;;\ntemplate class A&lt;false&gt;;\n</code></pre>\n<p>An example main main program in <code>main.cpp</code> could be</p>\n<pre><code>#include \"a.h\"\n\nint main() {\n  A&lt;true&gt; a;\n  a.print(std::cout);\n}\n</code></pre>\n<p>The small project above compiles just fine. </p>\n<p><strong>Question</strong>: If I put the explicit instantiations above the definition of the <code>print</code> method (in <code>a.cpp</code>), the code doesn't compile anymore, with the usual <code>undefined reference to A&lt;true&gt;::print(...)</code> error.</p>\n<pre><code>#include \"a.h\"\n\ntemplate class A&lt;true&gt;;\ntemplate class A&lt;false&gt;;\n\ntemplate&lt;bool b&gt;\nvoid A&lt;b&gt;::print(std::ostream&amp; out) {\n  out &lt;&lt; \"A\" &lt;&lt; b;\n}\n</code></pre>\n<p>Why is this the case? </p>\n<p><strong>Edit</strong>: Makefile to compile</p>\n<pre><code>main : main.o a.o\n    g++ main.o a.o -o main\n\nmain.o : main.cpp\n    g++ -c main.cpp\n\na.o : a.cpp \n    g++ -c a.cpp\n</code></pre>\n", "Tags": "<c++><templates><explicit>", "OwnerUserId": "1406686", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14151901_14152081_0": {"section_id": 258, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_14151901_14152081_0": {"section_id": 249, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_14151901_14152081_0": {"section_id": 265, "quality": 0.9565217391304348, "length": 22}}}});