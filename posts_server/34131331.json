post_cb({"bq_ids": {"n4140": {"so_34131331_34131610_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5806}, "so_34131331_34131331_1": {"length": 20, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_34131331_34131610_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5579}}, "n4659": {"so_34131331_34131610_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 7267}, "so_34131331_34131331_1": {"length": 18, "quality": 0.9, "section_id": 8652}}}, "34131331": {"ViewCount": "118", "Body": "<p>This question is about the code (at namespace scope):</p>\n<pre><code>std::vector&lt;int&gt; v1;\nstd::vector&lt;int&gt; v2(4);\n</code></pre>\n<p>In section 3.6.2 of C++14 (N4140) there is defined a term <em>Constant initialization</em>:</p>\n<blockquote>\n<p id=\"so_34131331_34131331_0\">Constant initialization is performed:</p>\n<ul>\n<li>[omitted - about reference initialization]</li>\n<li>if an object with static or thread storage duration is initialized by a constructor call, and if the initialization full-expression is a constant initializer for the object;</li>\n<li>if an object with static or thread storage duration is not initialized by a constructor call and if either the object is value-initialized or every full-expression that appears in its initializer is a constant expression.</li>\n</ul>\n</blockquote>\n<p>Further, the term <em>constant initializer</em> is defined just earlier:</p>\n<blockquote>\n<p id=\"so_34131331_34131331_1\">A <em>constant initializer</em> for an object <code>o</code> is an expression that is a\n  constant expression, except that it may also invoke constexpr constructors for <code>o</code> and its subobjects even if those objects are of non-literal class types.</p>\n</blockquote>\n<p>So, looking at <code>std::vector&lt;int&gt; v2(4)</code>.</p>\n<p>This object is initialized by a constructor call so it's covered by the second bullet point. The initialization full-expression is <code>4</code>.  <code>4</code> is a constant expression, therefore it is a <em>constant initializer</em> . So the second bullet point is satisfied and this should be a case of <em>constant initialization</em>.</p>\n<p>However, I tested with a few compilers and all of them seem to treat <code>v2</code> as <em>dynamic initialization</em>.</p>\n<p>For the <code>v1</code> case, it's not clear whether this counts as \"initialized by a constructor call\"; and if so, what the <em>initialization full-expression</em> would be.</p>\n<p>My question is: are <code>v1</code> and <code>v2</code> <em>constant initialization</em>, or <em>dynamic initialization</em>; and if the latter, could it be explained how these quotes from the standard are meant to be interpreted?</p>\n", "AcceptedAnswerId": "34131610", "Title": "Are these vector definitions \"constant initialization\"?", "CreationDate": "2015-12-07T10:26:45.987", "Id": "34131331", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-07T10:46:55.063", "Score": "2", "OwnerUserId": "1505939", "Tags": "<c++><initialization><language-lawyer><c++14>", "AnswerCount": "1"}, "34131610": {"Id": "34131610", "PostTypeId": "2", "Body": "<p>As per 1.9/10, the full expression of an initialization includes the call to the constructor:</p>\n<blockquote>\n<p id=\"so_34131331_34131610_0\">A <em>full-expression</em> is an expression that is not a subexpression of another expression. ... If a language construct is defined to produce an implicit call of a function, a use of the language\n  construct is considered to be an expression for the purposes of this definition. ... Conversions applied to the result of an expression in order to satisfy the requirements of the language\n  construct in which the expression appears are also considered to be part of the full-expression.<br>\n  [ <em>Example:</em><br>\n  ...</br></br></p>\n<pre><code>S s1(1); // full-expression is call of S::S(int)\n</code></pre>\n</blockquote>\n<p>Then, per 8.5/17, direct initialisation (which both <code>v1</code> and <code>v2</code> use) involves a constructor call.</p>\n<p>Therefore, the constructor call is part of the \"initialization full-expression\" per the 2nd bullet point you quote. So the constructor call, and not just the <code>4</code>, is the full-expression. This in turn means that such a constructor must be <code>constexpr</code> to qualify as a <em>constant initializer</em> (per its definition, as you quoted). And since neither the default constructor nor the <code>size_t</code> constructor of <code>std::vector</code> are <code>constexpr</code>, the initialisation is not constant.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2015-12-07T10:46:55.063", "Score": "7", "CreationDate": "2015-12-07T10:40:53.633", "ParentId": "34131331", "CommentCount": "2", "OwnerUserId": "1782465", "LastEditDate": "2015-12-07T10:46:55.063"}});