post_cb({"bq_ids": {"n4140": {"so_23334719_23335067_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 3291}, "so_23334719_23335067_10": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_23334719_23335067_3": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_23334719_23335067_11": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}, "so_23334719_23335294_1": {"length": 15, "quality": 1.0, "section_id": 3287}, "so_23334719_23335294_0": {"length": 7, "quality": 1.0, "section_id": 3290}, "so_23334719_23335067_13": {"length": 6, "quality": 1.0, "section_id": 3287}, "so_23334719_23335067_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 3286}, "so_23334719_23335067_5": {"length": 5, "quality": 1.0, "section_id": 3286}, "so_23334719_23335067_8": {"length": 7, "quality": 1.0, "section_id": 3290}, "so_23334719_23335067_12": {"length": 12, "quality": 0.75, "section_id": 3287}}, "n3337": {"so_23334719_23335067_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3161}, "so_23334719_23335067_10": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_23334719_23335067_3": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_23334719_23335067_11": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}, "so_23334719_23335294_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 3157}, "so_23334719_23335294_0": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_23334719_23335067_13": {"length": 6, "quality": 1.0, "section_id": 3157}, "so_23334719_23335067_4": {"length": 13, "quality": 1.0, "section_id": 3156}, "so_23334719_23335067_5": {"length": 5, "quality": 1.0, "section_id": 3156}, "so_23334719_23335067_8": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_23334719_23335067_12": {"length": 16, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_23334719_23335067_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 4053}, "so_23334719_23335067_5": {"length": 5, "quality": 1.0, "section_id": 4048}, "so_23334719_23335067_11": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}, "so_23334719_23335294_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4049}, "so_23334719_23335294_0": {"length": 7, "quality": 1.0, "section_id": 4052}, "so_23334719_23335067_13": {"length": 6, "quality": 1.0, "section_id": 4049}, "so_23334719_23335067_4": {"length": 9, "quality": 0.6923076923076923, "section_id": 4049}, "so_23334719_23335067_8": {"length": 7, "quality": 1.0, "section_id": 4052}, "so_23334719_23335067_12": {"length": 11, "quality": 0.6875, "section_id": 4049}}}, "23335067": {"Id": "23335067", "PostTypeId": "2", "Body": "<p><code>Parent</code> is a <em>POD</em>-type (plain old data type). It has no constructors or destructors (besides the implicit, which are trivial), complex members, etc. Its just a struct with scalars or other POD-type members. When you do this:</p>\n<pre><code>struct Child : Parent \n{\n    int b;\n    Child () {\n        printf(\"child constructor\\n\");\n    }\n}\n</code></pre>\n<p>you're simply constructing the child object. No relevant construction of <code>Parent</code> is taking place. The base type undergoes <em>default initialization</em>:</p>\n<blockquote>\n<p id=\"so_23334719_23335067_0\"><strong>C++11 \u00a7 8.5,p11</strong></p>\n<p id=\"so_23334719_23335067_1\">If no initializer is specified for an object, the object is <strong>default-initialized</strong>; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value. [ Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2.</p>\n</blockquote>\n<p>For your POD-type, this means:</p>\n<blockquote>\n<p id=\"so_23334719_23335067_2\"><strong>C++11 \u00a7 8.5,p6</strong></p>\n<p id=\"so_23334719_23335067_3\">To default-initialize an object of type T means:</p>\n<ul>\n<li><p id=\"so_23334719_23335067_4\">if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p></li>\n<li><p id=\"so_23334719_23335067_5\">if T is an array type, each element is default-initialized;</p></li>\n<li><p id=\"so_23334719_23335067_6\">otherwise, no initialization is performed.</p></li>\n</ul>\n</blockquote>\n<p>But when you do <em>this</em>:</p>\n<pre><code>struct Child : Parent \n{\n    int b;\n    Child () : Parent () {\n        printf(\"child constructor\\n\");\n    }\n}\n</code></pre>\n<p>something different happens: You're invoking <em>value-initialization</em> of the <code>Parent</code> base type. due to the <strong><code>()</code></strong>. </p>\n<blockquote>\n<p id=\"so_23334719_23335067_7\"><strong>C++11 \u00a7 8.5,p10</strong></p>\n<p id=\"so_23334719_23335067_8\">An object whose initializer is an empty set of parentheses, i.e., <strong>()</strong>, shall be <strong>value-initialized</strong>.</p>\n</blockquote>\n<p>For POD-types (of which <code>Parent</code> is one) value-initialization will eventually <em>zero-initialize</em> the members. </p>\n<blockquote>\n<p id=\"so_23334719_23335067_9\"><strong>C++11 \u00a7 8.5,p7</strong></p>\n<p id=\"so_23334719_23335067_10\">To value-initialize an object of type T means:</p>\n<ul>\n<li><p id=\"so_23334719_23335067_11\">if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p></li>\n<li><p id=\"so_23334719_23335067_12\">if T is a (possibly cv-qualified) non-union class type <em>without a user-provided constructor</em>, then the object is <strong>zero-initialized</strong> and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</p></li>\n<li><p id=\"so_23334719_23335067_13\">if T is an array type, then each element is value-initialized;</p></li>\n<li><p id=\"so_23334719_23335067_14\">otherwise, the object is zero-initialized.</p></li>\n</ul>\n</blockquote>\n<p>Thus <code>a</code> is zero in the second case, but not in the first. (well, it <em>could</em> be zero in the first, you can't really say; its value is <em>indeterminate</em> until you assign <em>something</em> to it).</p>\n", "LastEditorUserId": "1322972", "LastActivityDate": "2014-04-28T08:04:41.953", "Score": "5", "CreationDate": "2014-04-28T07:32:28.937", "ParentId": "23334719", "CommentCount": "7", "OwnerUserId": "1322972", "LastEditDate": "2014-04-28T08:04:41.953"}, "23334719": {"ViewCount": "841", "Body": "<p>As I know, if the programmer doesn't implement any constructor, the compiler automatically generates default constructor that does nothing.\nI think it works for struct as well.</p>\n<p>I used this with inheritance.</p>\n<pre><code>struct Parent {\n    int a;\n};\n\nstruct Child : Parent {\n    int b;\n    Child () {\n        printf(\"child constructor\\n\");\n    }\n}\n\nint main () {\n    Child c;\n    printf(\"%d\\n\", c.a);        // c.a = dummy value\n    printf(\"%d\\n\", c.b);        // c.b = 0\n    return 0;\n}\n</code></pre>\n<p>In the above code, <em>c.a</em> was dummy value. However, when I change the Child constructor, it was zero.\nThe only difference is that the Child explicitly calls parent's constructor in its constructor.</p>\n<pre><code>struct Parent {\n    int a;\n};\n\nstruct Child : Parent {\n    int b;\n    Child () : Parent () {\n        printf(\"child constructor\\n\");\n    }\n}\n\nint main () {\n    Child c;\n    printf(\"%d\\n\", c.a);        // c.a = 0\n    printf(\"%d\\n\", c.b);        // c.b = 0\n    return 0;\n}\n</code></pre>\n<p></p>\n<p>What happens?\nI spend some time but cannot find any reason.\nThe compiler I used is VS2008.\nThank you in advance.</p>\n", "Title": "C++ struct default constructor behavior", "CreationDate": "2014-04-28T07:13:13.450", "LastActivityDate": "2014-04-28T08:04:41.953", "CommentCount": "1", "PostTypeId": "1", "Id": "23334719", "Score": "3", "OwnerUserId": "3580124", "Tags": "<c++><struct><constructor>", "AnswerCount": "2"}, "23335294": {"Id": "23335294", "PostTypeId": "2", "Body": "<p>According to the C++ STandard</p>\n<blockquote>\n<p id=\"so_23334719_23335294_0\">11 An object whose initializer is an empty set of parentheses, i.e.,\n  (), shall be value-initialized.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_23334719_23335294_1\">8 To value-initialize an object of type T means: \u2014 if T is a (possibly\n  cv-qualified) class type without a user-provided or deleted default\n  constructor, then the object is zero-initialized</p>\n</blockquote>\n<p>So in code snippet</p>\n<pre><code>struct Parent {\n    int a;\n};\n\nstruct Child : Parent {\n    int b;\n    Child () : Parent () {\n        printf(\"child constructor\\n\");\n    }\n</code></pre>\n<p>class Parent is zero initialized. Its members of scalar types that is data member a is zero initialized.\n}</p>\n", "LastActivityDate": "2014-04-28T07:44:37.000", "CommentCount": "0", "CreationDate": "2014-04-28T07:44:37.000", "ParentId": "23334719", "Score": "2", "OwnerUserId": "2877241"}});