post_cb({"bq_ids": {"n4140": {"so_3662450_3662567_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 245}, "so_3662450_3662492_0": {"length": 49, "quality": 0.9245283018867925, "section_id": 235}, "so_3662450_3662567_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 246}}, "n3337": {"so_3662450_3662567_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 237}, "so_3662450_3662492_0": {"length": 49, "quality": 0.9245283018867925, "section_id": 228}, "so_3662450_3662567_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 238}}, "n4659": {"so_3662450_3662567_0": {"length": 44, "quality": 0.8627450980392157, "section_id": 252}, "so_3662450_3662492_0": {"length": 49, "quality": 0.9245283018867925, "section_id": 245}, "so_3662450_3662567_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 253}}}, "3662567": {"Id": "3662567", "PostTypeId": "2", "Body": "<p>I am not sure on what your dilemma is. If you are wondering how the template can be instantiated when there is no default constructor, that is fine. The defaulted first argument of the template constructor is only required if no argument is provided. The compiler is happy with <code>C</code> not having a default constructor as it does not need to use it.</p>\n<p>On the other hand, if you tried </p>\n<pre><code>A&lt;C&gt; a;\n</code></pre>\n<p>The compiler would have to match the constructor call to <code>A&lt;C&gt;::A( C )</code> with the default argument <code>C()</code>, and that will trigger a compile time error as the type <code>C</code> does not have a default constructor.</p>\n<p>The actual quote from the standard is from \u00a714.7.1[temp.inst]/11:</p>\n<blockquote>\n<p id=\"so_3662450_3662567_0\">If a function template f is called in a way that requires a default argument expression to be used, the dependent names are looked up, the semantics constraints are checked, and the instantiation of any template used in the default argument expression is done  as if the default argument expression had been an expression used in a function template specialization with the same scope, the same template parameters and the same access as that of the function template f used at that point. This analysis is called default argument instantiation. The instantiated default argument is then used as the argument of f.</p>\n</blockquote>\n<p>There is an actual example in the next paragraph \u00a714.7.1[temp.inst]/12:</p>\n<blockquote>\n<p id=\"so_3662450_3662567_1\">Each default argument is instantiated independently. [Example:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; \nvoid f(T x, T y = ydef(T()), T z = zdef(T()));\nclass A { }; \nA zdef(A);\nvoid g(A a, A b, A c) { \n   f(a, b, c);         // no default argument instantiation\n   f(a, b);            // default argument z = zdef(T()) instantiated\n   f(a);               // ill-formed; ydef is not declared\n}\n</code></pre>\n<blockquote>\n<p id=\"so_3662450_3662567_2\">\u2014end example]</p>\n</blockquote>\n", "LastEditorUserId": "36565", "LastActivityDate": "2010-09-07T21:00:22.237", "Score": "3", "CreationDate": "2010-09-07T20:43:07.657", "ParentId": "3662450", "CommentCount": "0", "LastEditDate": "2010-09-07T21:00:22.237", "OwnerUserId": "36565"}, "3662492": {"Id": "3662492", "PostTypeId": "2", "Body": "<p>If you don't use the default argument (that is, you supply a value), then it is not instantiated at all.</p>\n<p>14.7.1/2:</p>\n<blockquote>\n<p id=\"so_3662450_3662492_0\">Unless a function template\n  specialization has been explicitly\n  instantiated or explicitly\n  specialized, the func- tion template\n  specialization is implicitly\n  instantiated when the specialization\n  is referenced in a context that\n  requires a function definition to\n  exist. Unless a call is to a function\n  template explicit specialization or to\n  a member function of an explicitly\n  specialized class template, a default\n  argument for a function template or a\n  member function of a class template is\n  implicitly instantiated when the\n  function is called in a context that\n  requires the value of the default\n  argument.</p>\n</blockquote>\n<p>What a mouthful. Actually, default arguments of both functions and templates have specific instantiation rules all to themselves.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-09-07T20:48:42.597", "Score": "4", "CreationDate": "2010-09-07T20:33:11.697", "ParentId": "3662450", "CommentCount": "2", "LastEditDate": "2010-09-07T20:48:42.597", "OwnerUserId": "153285"}, "3662450": {"ViewCount": "526", "Body": "<p>what does standard say about such case:</p>\n<pre><code>template&lt;class C&gt;\nstruct A {\n    A(C c = C());\n};\n\nstruct C {\n    C(int);\n};\n\nA&lt;C&gt; a(C(1));\n</code></pre>\n<p>btw, Comeau does not raise error.  </p>\n", "AcceptedAnswerId": "3662492", "Title": "C++, default parameter with no default constructor", "CreationDate": "2010-09-07T20:27:37.417", "Id": "3662450", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-09-07T21:00:22.237", "Score": "1", "OwnerUserId": "206328", "Tags": "<c++>", "AnswerCount": "3"}, "3662573": {"Id": "3662573", "PostTypeId": "2", "Body": "<p>If the default argument is never used, then this is fine, as its never actually evaluated by the compiler until it is used. However, as soon as you use the default argument such as:</p>\n<pre><code>A&lt;C&gt; a;\n</code></pre>\n<p>you should get a compile error.</p>\n", "LastActivityDate": "2010-09-07T20:43:39.510", "Score": "3", "CreationDate": "2010-09-07T20:43:39.510", "ParentId": "3662450", "CommentCount": "0", "OwnerUserId": "438237"}});