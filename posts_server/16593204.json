post_cb({"16593618": {"ParentId": "16593204", "CommentCount": "5", "Body": "<p>No, it's not safe -- if you can manage to get it to compile, it's undefined behavior.  It directly violates the <strong>One Definition Rule</strong>, in particular C++03 \u00a73.2/5, which says:</p>\n<blockquote>\n<p id=\"so_16593204_16593618_0\">There can be more than one definition of a class type (clause 9), [...] , in a program provided that each\n  definition appears in a different translation unit, and provided the definitions satisfy the following requirements.\n  Given such an entity named <code>D</code> defined in more than one translation unit, then<br>\n  \u2014 each definition of <code>D</code> shall consist of the same sequence of tokens; and<br>\n<em>... More conditions omitted ...</em></br></br></p>\n<p id=\"so_16593204_16593618_1\">[...] If the\n  definitions of <code>D</code> satisfy all these requirements, then the program shall behave as if there were a single\n  definition of <code>D</code>. If the definitions of D do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>Since your two class definitions do <em>not</em> consist of the same sequence of tokens, the behavior is undefined.</p>\n<p>The C++11 behavior is identical here.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "16593618", "Score": "2", "CreationDate": "2013-05-16T17:19:00.990", "LastActivityDate": "2013-05-16T17:19:00.990"}, "16593376": {"ParentId": "16593204", "CommentCount": "9", "Body": "<p>You have a strange mix of declarations and definitions.</p>\n<p>First, it looks like your class declaration (which you should put in a header file, to be included in <code>main</code>) should look something like this:</p>\n<pre><code>struct s\n{\n  unsigned long long a;\n  s(unsigned long long b);\n  unsigned long long get();\n};\n</code></pre>\n<p>Then, your implementations should look something like</p>\n<pre><code>s::s(unsigned long long b) a(b) {}\n\nunsigned long long  s::get() { return a; }\n</code></pre>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "16593376", "Score": "2", "CreationDate": "2013-05-16T17:02:40.713", "LastActivityDate": "2013-05-16T17:02:40.713"}, "16593451": {"ParentId": "16593204", "CommentCount": "3", "Body": "<p>This issue here is that the member functions of <code>s</code> are implicitly defined <code>inline</code> in s.cpp. This restricts these member functions to only being defined in the translation unit for s.cpp. In main.cpp, the compiler only gets to see the declarations. Hence the linker error. (I believe this is referred to as having \"internal linkage\" or something like that, if someone could verify?).</p>\n<p>As mentioned, moving the function's definition <em>outside</em> of <code>s</code> solve the compiler error. The reason is that the definitions are no longer <code>inline</code>. Thus, the definition can now be linked to and used in main.cpp. So the new code is well-defined c++.</p>\n<p>The thing about <code>inline</code> functions is that they must be defined in every translation unit in which they are used. For this reason, <code>inline</code> functions are usually placed in a header file, so that a simple <code>#include</code> suffices.</p>\n", "OwnerUserId": "616815", "PostTypeId": "2", "Id": "16593451", "Score": "0", "CreationDate": "2013-05-16T17:08:00.727", "LastActivityDate": "2013-05-16T17:08:00.727"}, "16593461": {"ParentId": "16593204", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You are mixing two different structs with the same name, probably in the same namespace, which is likely to cause problems.</p>\n<p>In s.cpp (I modified the code a bit to be easier to understand):</p>\n<pre><code>struct s{ //I'll refer to this struct as S1 below\n    int _a;\n    s(int a) : _a(a) {}\n    int get() {return _a;}\n};\n</code></pre>\n<p>In main.cpp</p>\n<pre><code>// you added this struct declaration because otherwise it desn't compile\n// (providing there is no silly #include \"s.cpp\")\n// But it actually declares ANOTHER struct called s as well\nstruct s{ // I will refer to this struct as S2 below\n    s(int a);\n    int get();\n};\n\ns my_s(123);\n//some code\nint c = my_s.get(); // the compiler checks that S2 contains a get function: OK\n</code></pre>\n<p>Now, what happens is that the linker will see two <code>s</code> symbols in the same namespace, and here start problems that will be really annoying to debug. You may get your <code>123</code> value back, everything seems to work fine but then you compile in release (or change the compiler, or change the platform, or restart your machine, or any other thing that you think shouldn't change the behaviour of your code) and it doesn't work anymore...</p>\n<p>To avoid that kind of problem, when you want to use a struct, it needs to be declared before the line that uses it. Declare it in the s.h and define it in s.cpp (I guess that it is what you tried to do in your .cpp file but you need to define every function separately):</p>\n<pre><code>// s.h\nstruct s{\n    unsigned long long a;\n\n    s(unsigned long long b);\n    unsigned long long get();\n};\n\n// s.cpp\ns::s(unsigned long long b) : a(b) {}\n\nunsigned long long s::get() { return a; }\n</code></pre>\n<p>Or inline everything in your .h file and include it in your main.cpp.</p>\n", "OwnerUserId": "831673", "LastEditorUserId": "831673", "LastEditDate": "2013-05-16T17:38:26.653", "Id": "16593461", "Score": "0", "CreationDate": "2013-05-16T17:08:20.307", "LastActivityDate": "2013-05-16T17:38:26.653"}, "16593204": {"CommentCount": "5", "ViewCount": "164", "PostTypeId": "1", "LastEditorUserId": "2170324", "CreationDate": "2013-05-16T16:52:11.887", "LastActivityDate": "2013-05-16T23:03:34.360", "Title": "is this struct undefined behaviour from source file", "FavoriteCount": "1", "LastEditDate": "2013-05-16T23:03:34.360", "Id": "16593204", "Score": "-2", "Body": "<p>I have a struct from a source file s.cpp:</p>\n<pre><code>struct s{\nunsigned long long a;\ns(unsigned long long b){a=b;}\nunsigned long long get(){return a;}\n};\n</code></pre>\n<p>And in main file, compiled of course with g++ main.cpp s.cpp brief syntax</p>\n<pre><code>struct s{\ns(unsigned long long b);\nunsigned long long get();\n};\n\ns s1(123456);\n//some code\nunsigned long long c=s1.get();\n</code></pre>\n<p>Now I know it will not compile returning undefined reference, wich is a shame. Have to define ctor and get(), outside of brackets in s.cpp. I wonder if there's a g++ flag to possibly not having to.\nBut the main question is, is the s1.get() safe or is undefined behaviour?</p>\n<p><strong>EDIT</strong></p>\n<p>Thanks for your responses, but I still don't understand well the mechanism.\nSo in this case in s.cpp:</p>\n<pre><code>struct teste{\n    int a=0;\n    teste(int b);\n    int g();\n};\nteste::teste(int b){a+=b;}\nint teste::g(){ return a;}\n</code></pre>\n<p>and in main:</p>\n<pre><code>struct teste{\n    int c=1;\n    teste(int b);\n    int g();\n};\n\nteste ato(8);\nprintf(\"\\n%d\",ato.g());\n</code></pre>\n<p>Considering the memory allocation, shouldn't return 9 instead of 8 as it actual perform?\nEven if I change c to a, making it exactly equal but the 1, it seems to look always for the a and its init value from s.cpp always.\nSugesting that declaration of other thing than method to main is superflous.</p>\n", "Tags": "<c++><c++11><struct><g++><undefined-behavior>", "OwnerUserId": "2170324", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_16593204_16593618_0": {"section_id": 7043, "quality": 0.9024390243902439, "length": 37}, "so_16593204_16593618_1": {"section_id": 7043, "quality": 0.9375, "length": 15}}, "n3337": {"so_16593204_16593618_0": {"section_id": 6788, "quality": 0.9024390243902439, "length": 37}, "so_16593204_16593618_1": {"section_id": 6788, "quality": 1.0, "length": 16}}, "n4659": {"so_16593204_16593618_0": {"section_id": 8540, "quality": 0.9024390243902439, "length": 37}, "so_16593204_16593618_1": {"section_id": 8540, "quality": 0.9375, "length": 15}}}, "16593651": {"ParentId": "16593204", "CommentCount": "0", "Body": "<p>If I understand it correctly, the question is whether it is legal to have the declaration and definition in one file and the different declaration in a different translation unit, compared to say having the declaration in a header file.</p>\n<p>If, and only if, all of the declarations for the same type are exactly the same in all of the translation units <sup>*</sup>, then it is legal. But it will be error prone, if you modify one of the declarations, or any other change affects the exact definition you will break the ODR and cause undefined behavior.</p>\n<p><sup>*</sup>: Not only the declarations must be textually the same, but lookup for each one of the symbols must yield the same entities, and basically they must really refer to exactly one and only one thing.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "16593651", "Score": "1", "CreationDate": "2013-05-16T17:21:03.363", "LastActivityDate": "2013-05-16T17:21:03.363"}});