post_cb({"3357727": {"ParentId": "3357614", "CommentCount": "11", "Body": "<p><code>int</code> is supposed to be the natural word size for any given machine architecture and many machines have instructions that only (or at least optimally) perform arithmetic operations on machine words.</p>\n<p>If the language were defined without integer promotion, many multistep calculations which could otherwise naturally be mapped directly into machine instructions might have to be interspersed with masking operations performed on the intermediates in order to generate 'correct' results.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "3357727", "Score": "0", "CreationDate": "2010-07-28T21:41:27.947", "LastActivityDate": "2010-07-28T21:41:27.947"}, "3357687": {"ParentId": "3357614", "CommentCount": "1", "Body": "<p>It seems this is the same thing as in Java:</p>\n<p>Short and char (and other integers smaller than an int) are weaker types than int. Every operation on these weaker types is therefore automatically unboxed into an int.</p>\n<p>If you really want to get a short, you will have to typecast it.</p>\n<p>Unfortunately I can't tell you why this was done, but it seems this is a relatively common language decision...</p>\n", "OwnerUserId": "405058", "PostTypeId": "2", "Id": "3357687", "Score": "0", "CreationDate": "2010-07-28T21:34:53.797", "LastActivityDate": "2010-07-28T21:34:53.797"}, "3357780": {"ParentId": "3357614", "CommentCount": "0", "Body": "<p>Neither C nor C++ ever perform any arithmetic operations on types smaller than <code>int</code>. Any time you specify a smaller operand (any flavor of <code>char</code> or <code>short</code>), the operand gets promoted to either <code>int</code> or <code>unsigned int</code>, depending on the range.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "3357780", "Score": "0", "CreationDate": "2010-07-28T21:46:37.260", "LastActivityDate": "2010-07-28T21:46:37.260"}, "3357614": {"CommentCount": "0", "ViewCount": "2463", "CreationDate": "2010-07-28T21:23:29.303", "LastActivityDate": "2010-07-28T22:18:33.780", "Title": "Result of bitwise operator in C++", "AcceptedAnswerId": "3357684", "PostTypeId": "1", "Id": "3357614", "Score": "10", "Body": "<p>Testing a couple of compilers (Comeau, g++) confirms that the result of a bitwise operator of some \"integer type\" is an int:</p>\n<pre><code>void foo( unsigned char );\nvoid foo( unsigned short );\n\nunsigned char a, b;\n\nfoo (a | b);\n</code></pre>\n<p>I would have expected the type of \"a | b\" to be an unsigned char, as both operands are unsigned char, but the compilers say that the result is an int, and the call to foo() is ambiguous.  Why is the language designed so that the result is an int, or is this implementation dependent?</p>\n<p>Thanks,</p>\n", "Tags": "<c++>", "OwnerUserId": "405051", "AnswerCount": "6"}, "3358012": {"ParentId": "3357614", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3357614_3358012_0\">I would have expected the type of \"a | b\" to be an unsigned char, as both operands are unsigned char,</p>\n</blockquote>\n<p>My reading of some beginner C books in past left the impression that bitwise operators were left in the language solely for the purpose of the system programming and generally should be avoided.</p>\n<p>The operators are performed by the CPU itself. CPU uses for operands registers (which are surely larger than char) and thus compiler cannot know how much bits of a register would be affected by the operation. To not to loose the full result of the operation, compiler upcasts the result to the proper operation. AFAICT.</p>\n<blockquote>\n<p id=\"so_3357614_3358012_1\">Why is the language designed so that the result is an int, or is this implementation dependent?</p>\n</blockquote>\n<p>Bit-level representation of data types is in fact implementation defined. That might be the reason why apparently bit-wise operations are also implementation defined.</p>\n<p>Though C99 defines in <code>6.2.6.2 Integer types</code> how they should appear and behave (and later how bitwise operations should work) the particular chapter gives a lot of freedom to the implementation.</p>\n", "OwnerUserId": "360695", "PostTypeId": "2", "Id": "3358012", "Score": "1", "CreationDate": "2010-07-28T22:18:33.780", "LastActivityDate": "2010-07-28T22:18:33.780"}, "3357684": {"ParentId": "3357614", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is in fact standard C++ behavior (ISO/IEC 14882):</p>\n<blockquote>\n<p id=\"so_3357614_3357684_0\"><strong>5.13/1 Bitwise inclusive OR operator</strong></p>\n<p id=\"so_3357614_3357684_1\">The usual arithmetic conversions are\n  performed; the result is the bitwise\n  inclusive OR function of its operands.\n  The operator applies only to integral\n  or enumeration operands.</p>\n<p id=\"so_3357614_3357684_2\"><strong>5/9 Usual arithmetic conversions</strong></p>\n<p id=\"so_3357614_3357684_3\">Many binary operators that expect\n  operands of arithmetic or enumeration\n  type cause conversions and yield\n  result types in a similar way. The purpose\n  is to yield a common type, which is also\n  the type of the result. This\n  pattern is called the <em>usual arithmetic\n  conversions</em>, which are defined as\n  follows:</p>\n<ul>\n<li>If either operand is of type <code>long double</code>,\n  the other shall be converted to <code>long double</code>.</li>\n<li>Otherwise, if either operand is <code>double</code>,\n  the other shall be converted to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>,\n  the other shall be converted to <code>float</code>.</li>\n<li>Otherwise, the integral promotions\n  shall be performed on both operands.</li>\n<li>...</li>\n</ul>\n<p id=\"so_3357614_3357684_4\"><strong>4.5/1 Integral Promotions</strong></p>\n<p id=\"so_3357614_3357684_5\">An rvalue of type <code>char</code>, <code>signed char</code>,\n  <code>unsigned char</code>, <code>short int</code>, or <code>unsigned\n  short int</code> can be converted to an\n  rvalue of type <code>int</code> if <code>int</code> can\n  represent all the values of the source\n  type; otherwise, the source rvalue can be\n  converted to an rvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>I think it has to do with <code>int</code> supposedly being the \"natural\" size for the execution environment to allow for efficient arithmetic (see <a href=\"https://stackoverflow.com/questions/3357614/result-of-bitwise-operator-in-c/3357727#3357727\">Charles Bailey's answer</a>).</p>\n", "OwnerUserId": "308661", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:58.903", "Id": "3357684", "Score": "9", "CreationDate": "2010-07-28T21:34:34.407", "LastActivityDate": "2010-07-28T22:16:59.910"}, "3357717": {"ParentId": "3357614", "CommentCount": "1", "Body": "<p>Isn't <code>short</code> the same as <code>short int</code>? in the same way that <code>long</code> is synonymous with <code>int</code>. eg. a <code>short</code> is an <code>int</code> taking up less memory then a standard <code>int</code>?</p>\n", "OwnerUserId": "17540", "PostTypeId": "2", "Id": "3357717", "Score": "0", "CreationDate": "2010-07-28T21:39:47.420", "LastActivityDate": "2010-07-28T21:39:47.420"}, "bq_ids": {"n4140": {"so_3357614_3357684_5": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}, "so_3357614_3357684_3": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_3357614_3357684_1": {"section_id": 6162, "quality": 0.8823529411764706, "length": 15}, "so_3357614_3358012_0": {"section_id": 45, "quality": 0.6, "length": 6}}, "n3337": {"so_3357614_3357684_5": {"section_id": 18, "quality": 0.6060606060606061, "length": 20}, "so_3357614_3357684_1": {"section_id": 5923, "quality": 0.8823529411764706, "length": 15}, "so_3357614_3357684_3": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_3357614_3358012_0": {"section_id": 42, "quality": 0.6, "length": 6}}, "n4659": {"so_3357614_3357684_5": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}, "so_3357614_3357684_3": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_3357614_3357684_1": {"section_id": 7659, "quality": 0.8823529411764706, "length": 15}, "so_3357614_3358012_0": {"section_id": 46, "quality": 0.6, "length": 6}}}});