post_cb({"35943728": {"ParentId": "35943551", "PostTypeId": "2", "CommentCount": "12", "Body": "<blockquote>\n<p id=\"so_35943551_35943728_0\">Does the C++ standard guarantee that <code>(x!=y)</code> always has the same truth value as <code>!(x==y)</code>?</p>\n</blockquote>\n<p>No it doesn't. Absolutely nothing stops me from writing:</p>\n<pre><code>struct Broken {\n    bool operator==(const Broken&amp; ) const { return true; }\n    bool operator!=(const Broken&amp; ) const { return true; }\n};\n\nBroken x, y;\n</code></pre>\n<p>That is perfectly well-formed code. Semantically, it's broken (as the name might suggest), but there's certainly nothing wrong from it from a pure C++ code functionality perspective. </p>\n<p>The standard also clearly indicates this is okay in <a href=\"http://eel.is/c++draft/over.oper#7\" rel=\"nofollow noreferrer\">[over.oper]/7</a>:</p>\n<blockquote>\n<p id=\"so_35943551_35943728_1\">The identities among certain predefined operators applied to basic types (for example, <code>++a \u2261 a+=1</code>) need not hold for operator functions. Some predefined operators, such as <code>+=</code>, require an operand to be an lvalue when applied to basic types; this is not required by operator functions.</p>\n</blockquote>\n<p>In the same vein, nothing in the C++ standard guarantees that <code>operator&lt;</code> actually implements a valid Ordering (or that <code>x&lt;y &lt;==&gt; !(x&gt;=y)</code>, etc.). Some standard library implementations will actually add instrumentation to attempt to debug this for you in the ordered containers, but that is just a quality of implementation issue and not a standards-compliant-based decision. </p>\n<hr/>\n<p>Library solutions like <a href=\"http://www.boost.org/doc/libs/1_60_0/libs/utility/operators.htm\" rel=\"nofollow noreferrer\">boost operators</a> exist to at least make this a little easier on the programmer's side:</p>\n<pre><code>struct Fixed : equality_comparable&lt;Fixed&gt; {\n    bool operator==(const Fixed&amp;) const;\n    // a consistent operator!= is provided for you\n};\n</code></pre>\n<p>Although now <code>Fixed</code> can no longer be an aggregate. So it's still not an ideal solution. Though <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r1.html\" rel=\"nofollow noreferrer\">P0017</a> has apparently been accepted for C++17, which would allow list-initialization for <code>Fixed</code>.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-03-13T12:41:49.760", "Id": "35943728", "Score": "19", "CreationDate": "2016-03-11T15:15:28.363", "LastActivityDate": "2016-03-13T12:41:49.760"}, "35943805": {"ParentId": "35943551", "CommentCount": "0", "Body": "<p>No. You can write operator overloads for <code>==</code> and <code>!=</code> that do whatever you wish. It probably would be a bad idea to do so, but the definition of C++ does not constrain those operators to be each other's logical opposites.</p>\n", "OwnerUserId": "2098932", "PostTypeId": "2", "Id": "35943805", "Score": "3", "CreationDate": "2016-03-11T15:18:57.797", "LastActivityDate": "2016-03-11T15:18:57.797"}, "35947501": {"ParentId": "35943551", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In general, I don't think you can rely on it, because it doesn't always make sense for <code>operator ==</code> and <code>operator!=</code> to <em>always</em> correspond, so I don't see how the standard could ever require it.</p>\n<p><strong>For example,</strong> consider the built-in floating point types, like doubles, for which <strong>NaNs</strong> always compare false, so operator== and operator!= can both return false at the same time.  (Edit: Oops, this is wrong; see hvd's comment.)</p>\n<p>As a result, if I'm writing a new class with floating point semantics (maybe a really_long_double), I <em>have</em> to implement the same behaviour to be consistent with the primitive types, so my <code>operator==</code> would have to behave the same and compare two NaNs as false, even though <code>operator!=</code> also compares them as false.</p>\n<p>This might crop up in other circumstances, too.  For example, if I was writing a class to represent a database nullable value I might run into the same issue, because all comparisons to database NULL are false.  I might choose to implement that logic in my C++ code to have the same semantics as the database.</p>\n<p>In practice, though, for your use case, it might not be worth worrying about these edge cases.  Just document that your function compares the objects using <code>operator== (or operator !=)</code> and leave it at that.</p>\n", "OwnerUserId": "2387521", "LastEditorUserId": "2387521", "LastEditDate": "2016-03-17T14:40:27.987", "Id": "35947501", "Score": "13", "CreationDate": "2016-03-11T18:35:20.730", "LastActivityDate": "2016-03-17T14:40:27.987"}, "bq_ids": {"n4140": {"so_35943551_35943728_1": {"section_id": 654, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_35943551_35943728_1": {"section_id": 644, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_35943551_35943728_1": {"section_id": 682, "quality": 0.9642857142857143, "length": 27}}}, "35943551": {"CommentCount": "13", "AcceptedAnswerId": "35943728", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-11T15:06:28.940", "LastActivityDate": "2016-03-17T14:40:27.987", "LastEditDate": "2017-05-23T10:29:06.880", "ViewCount": "1042", "FavoriteCount": "0", "Title": "Equality operator overloads: Is (x!=y) == (!(x==y))?", "Id": "35943551", "Score": "25", "Body": "<p><sub>I hope this is not a duplicate - I searched for other questions regarding the equality operators, but apart from some comments in related questions, I did not find a definite statement</sub></p>\n<hr>\n<p><strong>tl;dr:</strong></p>\n<p>Does the C++ standard guarantee that <code>(x!=y)</code> always has the same truth value as <code>!(x==y)</code>? </p>\n<hr>\n<p>I know there are <em>many</em> subtleties involved here: The operators <code>==</code> and <code>!=</code> may be overloaded. They may be overloaded to have different return types (which only have to be implicitly convertible to <code>bool</code>). Even the <code>!</code>-operator might be overloaded on the return type. That's why I handwavingly referred to the \"truth value\" above, but trying to elaborate it further, exploiting the implicit conversion to <code>bool</code>, and trying to eliminate possible ambiguities:</p>\n<pre><code>bool ne = (x!=y);\nbool e = (x==y);\nbool result = (ne == (!e));\n</code></pre>\n<p><strong>Is <code>result</code> guaranteed to be <code>true</code> here?</strong></p>\n<p>The C++ standard specifies the equality operators in section 5.10, but mainly seems to define them <em>syntactically</em> (and some semantics regarding pointer comparisons). The <em>concept</em> of being <a href=\"http://en.cppreference.com/w/cpp/concept/EqualityComparable\" rel=\"nofollow noreferrer\">EqualityComparable</a> exists, but there is no dedicated statement about the relationship of its operator <code>==</code> to the <code>!=</code> operator.</p>\n<p>There exist <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3950.html\" rel=\"nofollow noreferrer\">related documents from C++ working groups</a>, saying that...</p>\n<blockquote>\n<p id=\"so_35943551_35943551_0\">It is vital that equal/unequal [...] behave as boolean negations of each other. After all, the world would make no sense if both operator==() and operator!=() returned false! As such, it is common to implement these operators in terms of each other  </p>\n</blockquote>\n<p>However, this only reflects the Common Sense\u2122, and does not <em>specify</em> that they have to be implemented like this.</p>\n<hr>\n<p><sub>Some background: I'm just trying to write a function that checks whether two values (of unknown type) are equal, and print an error message if this is not the case. I'd like to say that the required concept here is that the types are <code>EqualityComparable</code>. But for this, one would still have to write <code>if (!(x==y)) {...}</code> and could <strong>not</strong> write <code>if (x!=y) {...}</code>, because this would use a different operator, which is not covered with the concept of <code>EqualityComparable</code> at all, and which might even be overloaded differently...</sub></p>\n<hr>\n<h1>Update</h1>\n<p>I know that the programmer basically <em>can</em> do whatever he wants in his custom overloads. I just wondered whether he is really <em>allowed</em> to do everything, or whether there are rules imposed by the standard. Maybe one of these subtle statements that suggest that deviating from the usual implementation causes undefined behavior, like the one that <a href=\"https://stackoverflow.com/questions/35943551/equality-operator-overloads-is-x-y-x-y/35943728?noredirect=1#comment59544090_35943728\">NathanOliver mentioned in a comment, but which seemed to only refer to certain types</a>. For example, the standard <strong>explicitly</strong> states that for <em>container types</em>, <code>a!=b</code> is equivalent to <code>!(a==b)</code> (section 23.2.1, table 95, \"Container requirements\").</p>\n<p>But for general, user-defined types, it currently seems that there are no such requirements. The question is tagged <code>language-lawyer</code>, because I hoped for a definite statement/reference, but I know that this may nearly be impossible: While one could point out the section where it said that the operators <em>have</em> to be negations of each other, one can hardly prove that none of the ~1500 pages of the standard says something like this...</p>\n<p>In doubt, and unless there are further hints, I'll upvote/accept the corresponding answers later, and for now assume that for comparing not-equality for <code>EqualityComparable</code> types should be done with <code>if (!(x==y))</code> to be on the safe side.</p>\n</hr></hr></hr></hr>", "Tags": "<c++><language-lawyer><equals-operator>", "OwnerUserId": "3182664", "AnswerCount": "3"}});