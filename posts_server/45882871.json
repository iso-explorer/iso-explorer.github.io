post_cb({"45882871": {"CommentCount": "0", "ViewCount": "159", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-08-25T13:47:36.473", "LastActivityDate": "2017-08-25T14:43:37.953", "Title": "Gcc 7.2 c++17 constexpr", "AcceptedAnswerId": "45882988", "LastEditDate": "2017-08-25T13:55:11.643", "Id": "45882871", "Score": "1", "Body": "<p>I try to implement a constexpr stack only for understand constexpr.\nI get a compile error from the following code that i don't understand:</p>\n<ol>\n<li>If I correctly understand constexpr does not imply const</li>\n<li>It compiles the init-list constexpr  constructor that contains calls to push</li>\n<li>It compiles the lambda spop that perform a pop</li>\n</ol>\n<p>What am I missing?</p>\n<p><a href=\"https://wandbox.org/permlink/rP7kBLhj3kjdDXPy\" rel=\"nofollow noreferrer\">live example</a></p>\n<pre><code>g++ prog.cc -Wall -Wextra -I/opt/wandbox/boost-1.65.0/gcc-7.2.0/include -std=gnu++1z\n\n#include &lt;array&gt;\n#include &lt;stdexcept&gt;\n#include &lt;type_traits&gt;\n\nnamespace ds {\n    template &lt;typename T, std::size_t N&gt;\n    class array_stack final {\n    public:\n        using value_type = T;\n        using reference = value_type&amp;;\n        using const_reference = value_type const&amp;;\n        using size_type = std::size_t;\n\n        constexpr bool empty () const\n        {\n          return items_ == size_type{0};\n        }\n\n        constexpr bool full () const\n        {\n          return top_item_ == N;\n        }\n\n        constexpr size_type size () const\n        {\n          return items_;\n        }\n\n        constexpr reference top () &amp;\n        {\n          if (empty())\n            throw std::logic_error{\"Attempting top() on empty stack\"};\n\n          return array_[top_item_ - 1];\n        }\n\n        constexpr const_reference top () const&amp;\n        {\n          if (empty())\n            throw std::logic_error{\"Attempting top() on empty stack\"};\n\n          return array_[top_item_ - 1];\n        }\n\n        constexpr void push (value_type const&amp; value)\n        {\n          if (full())\n            throw std::logic_error{\"Attempting push() on full stack\"};\n\n          array_[top_item_] = value;\n          top_item_++;\n          items_++;\n        }\n\n        constexpr void push (value_type&amp;&amp; value)\n        {\n          if (full())\n            throw std::logic_error{\"Attempting push() on full stack\"};\n\n          array_[top_item_] = std::move(value);\n          top_item_++;\n          items_++;\n        }\n\n        constexpr void pop ()\n        {\n          if (empty())\n            throw std::logic_error{\"Attempting pop() on empty stack\"};\n\n          top_item_--;\n          items_--;\n        }\n\n        constexpr void clear ()\n        {\n          items_ = size_type{0};\n          top_item_ = size_type{0};\n        }\n\n        constexpr array_stack ()\n            : items_{size_type{0}}, top_item_{size_type{0}}, array_{}\n        {}\n\n        constexpr array_stack (std::initializer_list&lt;value_type&gt; values) : array_stack ()\n        {\n          for (auto const&amp; v : values)\n            push(v);\n        }\n\n        constexpr array_stack (array_stack const&amp; rhs) : array_stack ()\n        {\n          array_ = rhs.array_;\n          items_ = rhs.items_;\n          top_item_ = rhs.top_item_;\n        }\n\n        constexpr array_stack (array_stack&amp;&amp; rhs)\n            : items_ {rhs.items_}, top_item_ {rhs.top_item_}, array_ {std::move(rhs.array_)}\n        {\n          rhs.items_ = size_type{0};\n          rhs.top_item_ = size_type{0};\n        }\n\n        constexpr array_stack&amp; operator= (array_stack rhs)\n        {\n          array_ = std::move(rhs.array_);\n          items_ = std::move(rhs.items_);\n          top_item_ = std::move(rhs.top_item_);\n          return *this;\n        }\n\n        ~array_stack () = default;\n\n        void swap (array_stack&amp; rhs) noexcept(std::is_nothrow_swappable_v&lt;value_type&gt;)\n        {\n          using std::swap;\n          swap(items_, rhs.items_);\n          swap(top_item_, rhs.top_item_);\n          swap(array_, rhs.array_);\n        }\n\n    private:\n        size_type items_;\n        size_type top_item_;\n        std::array&lt;value_type, N&gt; array_;\n    };\n\n    template &lt;typename T, std::size_t N&gt;\n    void swap (array_stack&lt;T, N&gt;&amp; lhs, array_stack&lt;T, N&gt;&amp; rhs) noexcept(noexcept(lhs.swap(rhs)))\n    {\n        lhs.swap(rhs);\n    }\n}\n\nconstexpr bool f()\n{\n  constexpr ds::array_stack &lt;int, 10&gt; dstack{0,1,2,3,4,5,6,7,8,9};\n  constexpr ds::array_stack &lt;int, 10&gt; dstack2{dstack};\n  constexpr auto spop =[](auto s){ s.pop(); return s.size(); };\n  static_assert(dstack.size() == 10);\n  static_assert(!dstack.empty());\n  static_assert(dstack.full());\n  static_assert(dstack.top() == 9);\n  static_assert(dstack2.size() == 10);\n  static_assert(spop(dstack) == 9);\n  dstack2.pop();\n  return true;\n}\n\n\nint main()\n{\n  constexpr ds::array_stack &lt;int, 10&gt; cstack;\n  static_assert(cstack.size() == 0);\n  static_assert(cstack.empty());\n  static_assert(!cstack.full());\n\n  static_assert(f());\n\n  return 0;\n}\n</code></pre>\n<p>I get this error (i understand what it means but why?)</p>\n<pre><code>prog.cc: In function 'constexpr bool f()':\nprog.cc:147:15: error: passing 'const ds::array_stack&lt;int, 10&gt;' as 'this' argument discards qualifiers [-fpermissive]\n   dstack2.pop();\n               ^\nprog.cc:66:24: note:   in call to 'constexpr void ds::array_stack&lt;T, N&gt;::pop() [with T = int; long unsigned int N = 10]'\n         constexpr void pop ()\n                        ^~~\n</code></pre>\n", "Tags": "<c++><gcc><compiler-errors><c++1z>", "OwnerUserId": "4456672", "AnswerCount": "2"}, "45882988": {"ParentId": "45882871", "CommentCount": "4", "CreationDate": "2017-08-25T13:54:10.247", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "45882988", "Score": "3", "Body": "<blockquote id=\"so_45882871_45882988_0\">\n<ol>\n<li>If I correctly understand constexpr does not imply const</li>\n</ol>\n</blockquote>\n<p>No. Objects declared <code>constexpr</code> <a href=\"http://eel.is/c++draft/dcl.constexpr#9.sentence-1\" rel=\"nofollow noreferrer\">are indeed <code>const</code></a>. That's why <code>dstack2.pop()</code> is ill-formed - the very boring and C++03 reason that you're calling a non-<code>const</code> member function on a <code>const</code> object. </p>\n<p>Once you remove the <code>dstack2.pop()</code> line, everything compiles. </p>\n<blockquote id=\"so_45882871_45882988_1\">\n<ol start=\"2\">\n<li>It compiles the init-list constexpr constructor that contains calls to push</li>\n<li>It compiles the lambda spop that perform a pop</li>\n</ol>\n</blockquote>\n<p>In both of these cases, you're allowed to modify the object. In the first case, you're still in the constructor - so modifications are fine, the object is never <code>const</code> <em>during</em> construction (otherwise you couldn't construct it). In the lambda case, the argument isn't <code>const</code> - it's just <code>auto</code>. </p>\n", "LastActivityDate": "2017-08-25T13:54:10.247"}, "45883965": {"ParentId": "45882871", "CommentCount": "0", "CreationDate": "2017-08-25T14:43:37.953", "OwnerUserId": "4672588", "PostTypeId": "2", "Id": "45883965", "Score": "1", "Body": "<p><a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow noreferrer\">[expr.const]/2</a>:</p>\n<blockquote>\n<p id=\"so_45882871_45883965_0\">An expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine, would evaluate one of the following expressions:</p>\n<ul>\n<li>[...]</li>\n<li>modification of an object unless it is applied to a non-volatile lvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of e;</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2017-08-25T14:43:37.953"}, "bq_ids": {"n4140": {"so_45882871_45883965_0": {"section_id": 6185, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_45882871_45883965_0": {"section_id": 7687, "quality": 0.8571428571428571, "length": 12}}}});