post_cb({"33010352": {"CommentCount": "1", "ViewCount": "173", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-10-08T08:21:33.977", "LastActivityDate": "2015-10-08T09:02:07.940", "Title": "C++11 alias templates in CUDA", "AcceptedAnswerId": "33011069", "LastEditDate": "2015-10-08T09:02:07.940", "Id": "33010352", "Score": "2", "Body": "<p>The essential question is are <a href=\"http://en.cppreference.com/w/cpp/language/type_alias\" rel=\"nofollow\">alias templates</a> supported by the CUDA compiler?</p>\n<p>I am using CUDA 7.5 on Ubuntu with gcc-4.8. All of my template classes are defined in header files and <code>#include</code>d into a single translation unit during compilation.</p>\n<p>I have a simple <code>cuda_array</code> class that provides a thin wrapper around a <code>std::vector</code>. It's essentially a very simple version of <code>thrust::host_vector</code> combined with a <code>thrust::device_vector</code>. Its declaration is</p>\n<pre><code>template &lt;typename T, const size_t N&gt;\nclass cuda_array {\n    std::vector&lt;T&gt; host;\n    T *device;\npublic:\n    // lots of type aliases to meet container requirements\n    void push() { /* cudaMemcpy(...,H2D); */ }\n    void pull() { /* cudaMemcpy(...,D2H); */ }\n    // a few others that aren't relevant here\n};\n</code></pre>\n<p>To make a matrix, I just made a quick template alias.</p>\n<pre><code>template &lt;typename T, const size_t M, const size_t N&gt;\nusing cuda_matrix = cuda_array&lt;T, M * N&gt;;\n</code></pre>\n<p>I want to map my matrix-vector multiplication CUDA kernel onto the overloaded <code>operator*</code> for type safety and easy use (it is left to the caller to ensure that <code>push</code> and <code>pull</code> are called correctly).</p>\n<pre><code>template &lt;typename T, const size_t rows, const size_t cols&gt;\n__global__ void matrix_vector_mul(T *A, T *b, T *result) {\n     __shared__ T shared_b[cols];\n    // rest of it\n}\n\ntemplate &lt;typename T, const size_t M, const size_t N&gt;\n__host__ cuda_array&lt;T, M&gt; operator*(cuda_matrix&lt;T, M, N&gt; &amp;m, cuda_array&lt;T, N&gt; &amp;v) {\n    cuda_array&lt;T, M&gt; result;\n    matrix_vector_mul&lt;T, M, N&gt;&lt;&lt;&lt;16, 32&gt;&gt;&gt;(m.device_data(), v.device_data(), result.device_data());\n    return result;\n}\n</code></pre>\n<p>In my 'main.cpp', I then have</p>\n<pre><code>cuda_matrix&lt;int,16,32&gt; A;\ncuda_array&lt;int,32&gt; b;\nauto result = A * b;\n</code></pre>\n<p>The last line throws an error saying</p>\n<pre><code>error: no operator \"*\" matches these operands\n        operand types are: cuda_matrix&lt;int, 16UL, 32UL&gt; * cuda_array&lt;int, 32UL&gt;\n</code></pre>\n<p>I chased down all of the usual suspects for template type deduction errors I could think of, but nothing worked. In desperation, I converted my <code>cuda_matrix</code> alias template into a template class.</p>\n<pre><code>template &lt;typename T, const size_t M, const size_t N&gt;\nclass cuda_matrix : public cuda_array&lt;T, M * N&gt; {};\n</code></pre>\n<p>And the compile error disappears! It therefore seems that CUDA does not yet support alias templates. Or did I do something silly that I can't figure out?</p>\n", "Tags": "<c++><templates><c++11><cuda><template-aliases>", "OwnerUserId": "2981588", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33010352_33011069_1": {"section_id": 347, "quality": 1.0, "length": 18}, "so_33010352_33011069_0": {"section_id": 166, "quality": 0.88, "length": 22}}, "n3337": {"so_33010352_33011069_1": {"section_id": 337, "quality": 1.0, "length": 18}, "so_33010352_33011069_0": {"section_id": 160, "quality": 0.88, "length": 22}}, "n4659": {"so_33010352_33011069_1": {"section_id": 356, "quality": 1.0, "length": 18}, "so_33010352_33011069_0": {"section_id": 170, "quality": 0.88, "length": 22}}}, "33011069": {"ParentId": "33010352", "CommentCount": "1", "Body": "<p>You must remember that:</p>\n<p>\u00a7 14.5.7 [temp.alias]/p2:</p>\n<blockquote>\n<p id=\"so_33010352_33011069_0\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated type\n  obtained by substitution of its template-arguments for the template-parameters in the <em>type-id</em> of the alias\n  template. [ <em>Note</em>: An alias template name is never deduced. \u2014 <em>end note</em> ] </p>\n</blockquote>\n<p>This means that deduction is not performed for:</p>\n<pre><code>template &lt;typename T, const size_t M, const size_t N&gt;\n__host__ cuda_array&lt;T, M&gt; operator*(cuda_matrix&lt;T, M, N&gt; &amp;m, cuda_array&lt;T, N&gt; &amp;v)\n</code></pre>\n<p>but for:</p>\n<pre><code>template &lt;typename T, const size_t M, const size_t N&gt;\n__host__ cuda_array&lt;T, M&gt; operator*(cuda_array&lt;T, M * N&gt; &amp;m, cuda_array&lt;T, N&gt; &amp;v)\n//                                  ~~~~~~~~~~~~~~~~~~~^\n</code></pre>\n<p>And so:</p>\n<p>\u00a7 14.8.2.5 [temp.deduct.type]/p16:</p>\n<blockquote>\n<p id=\"so_33010352_33011069_1\">If, in the declaration of a function template with a non-type template parameter, the non-type template\n  parameter is used in a subexpression in the function parameter list, <strong>the expression is a non-deduced context</strong>\n  as specified above.</p>\n</blockquote>\n<p><code>M</code> is in a non-deducible context, hence this <code>operator*</code> is not considered as a viable overload.</p>\n<p>As one of the workarounds, you can instead verify the deduced value for <code>cuda_array</code> itself:</p>\n<pre><code>template &lt;typename T, std::size_t MN, std::size_t N&gt;\nauto operator*(const cuda_array&lt;T, MN&gt;&amp; m, const cuda_array&lt;T, N&gt;&amp; v)\n    -&gt; typename std::enable_if&lt;(MN/N)*N==MN, cuda_array&lt;T, MN/N&gt;&gt;::type;\n</code></pre>\n<p>or use the inheritance trick that you  already have; then <code>M</code> and <code>N</code> are separate non-type template parameters of <code>cuda_matrix</code>.</p>\n", "OwnerUserId": "3953764", "PostTypeId": "2", "Id": "33011069", "Score": "4", "CreationDate": "2015-10-08T08:55:11.063", "LastActivityDate": "2015-10-08T08:55:11.063"}});