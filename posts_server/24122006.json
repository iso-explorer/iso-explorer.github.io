post_cb({"24122305": {"ParentId": "24122006", "CommentCount": "0", "CreationDate": "2014-06-09T14:21:56.520", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "24122305", "Score": "2", "Body": "<p>The compiler warning is incorrect; it is actually performing value-initialization as required by the standard.</p>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B {\n    B() : member{}{};\n    int member[10];\n};\n\nint main() {\n    int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    B &amp;b = *new (a) B;\n    std::cout &lt;&lt; b.member[9];  // prints '0'\n}\n</code></pre>\n", "LastActivityDate": "2014-06-09T14:21:56.520"}, "24122245": {"ParentId": "24122006", "CommentCount": "1", "CreationDate": "2014-06-09T14:18:47.167", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "24122245", "Score": "7", "Body": "<p>It seems to be an incorrectly worded warning message (and I'm surprised it is printing a warning in the first place), but the <strong>behavior is correct</strong>. <code>B::member</code> is being value initialized, which for an array of <code>int</code> turns into zero initialization. This can be demonstrated using the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B\n{\n    B() : member{}{};\n    int member[10];\n};\n\nstruct C\n{\n    C() {};\n    int member[10];\n};\n\nint main()\n{\n    B b;\n    for(auto const&amp; a : b.member) std::cout &lt;&lt; a &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n\n    C c;\n    for(auto const&amp; a : c.member) std::cout &lt;&lt; a &lt;&lt; ' ';\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>If you compile and run in <em>Debug</em> mode this results in the output:</p>\n<pre><code>0 0 0 0 0 0 0 0 0 0\n-858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460\n</code></pre>\n<p>The numbers in the second line are <code>0xCCCCCCCC</code>, the debug pattern the VC++ compiler fills memory with in Debug mode. Thus <code>B::member</code> is being zero-initialized, while no initialization is performed for <code>C::member</code>.</p>\n<p><em>Disclaimer:</em> I know that reading from an uninitialized variable is undefined behavior, but this is the best <em>proof</em> I could come up with.</p>\n", "LastActivityDate": "2014-06-09T14:18:47.167"}, "40898626": {"ParentId": "24122006", "CommentCount": "0", "CreationDate": "2016-11-30T21:33:20.537", "OwnerUserId": "264822", "PostTypeId": "2", "Id": "40898626", "Score": "0", "Body": "<p>The <a href=\"https://msdn.microsoft.com/en-us/library/1ywe7hcy.aspx\" rel=\"nofollow noreferrer\">MSDN page</a> says:</p>\n<blockquote>\n<p id=\"so_24122006_40898626_0\">C4351 means that you should inspect your code... If you want the new\n  behavior, which is likely, because the array was explicitly added to\n  the constructor's member initialization list, use the <a href=\"https://msdn.microsoft.com/en-us/library/2c8f766e.aspx\" rel=\"nofollow noreferrer\">warning</a> pragma\n  to disable the warning. The new behavior should be fine for most\n  users.</p>\n</blockquote>\n<p>So you have to add <code>#pragma warning (suppress:4351)</code> for one line or <code>#pragma warning (disable:4351)</code> for the whole file.</p>\n", "LastActivityDate": "2016-11-30T21:33:20.537"}, "bq_ids": {"n4140": {"so_24122006_24122006_4": {"section_id": 3304, "quality": 0.8181818181818182, "length": 9}, "so_24122006_24122006_1": {"section_id": 3286, "quality": 0.9722222222222222, "length": 35}, "so_24122006_24122006_2": {"section_id": 3325, "quality": 0.8095238095238095, "length": 17}, "so_24122006_24122006_3": {"section_id": 3304, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_24122006_24122006_4": {"section_id": 3174, "quality": 0.8181818181818182, "length": 9}, "so_24122006_24122006_1": {"section_id": 3156, "quality": 1.0, "length": 36}, "so_24122006_24122006_2": {"section_id": 3195, "quality": 0.9523809523809523, "length": 20}, "so_24122006_24122006_3": {"section_id": 3174, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_24122006_24122006_4": {"section_id": 4070, "quality": 0.8181818181818182, "length": 9}, "so_24122006_24122006_1": {"section_id": 4048, "quality": 0.6111111111111112, "length": 22}, "so_24122006_24122006_2": {"section_id": 4091, "quality": 0.8095238095238095, "length": 17}, "so_24122006_24122006_3": {"section_id": 4070, "quality": 0.7894736842105263, "length": 15}}}, "24122006": {"CommentCount": "2", "AcceptedAnswerId": "24122245", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-06-09T14:05:31.953", "LastActivityDate": "2016-11-30T21:33:20.537", "LastEditDate": "2016-01-12T17:12:39.403", "ViewCount": "2573", "FavoriteCount": "1", "Title": "VS2013 default initialization vs value initialization", "Id": "24122006", "Score": "9", "Body": "<p>Consider the code below</p>\n<pre><code>struct B\n{\n    B() : member{}{};\n    int member[10];\n};\n\nint main()\n{\n    B b;\n}\n</code></pre>\n<p>VS2013 compiler gives the following warning:</p>\n<blockquote>\n<p id=\"so_24122006_24122006_0\">warning C4351: new behavior: elements of array 'B::member' will be\n  default initialized 1&gt;  test.vcxproj -&gt;\n  C:\\Users\\asaxena2\\documents\\visual studio\n  2013\\Projects\\test\\Debug\\test.exe</p>\n</blockquote>\n<p>This is documented <a href=\"http://msdn.microsoft.com/en-us/library/1ywe7hcy.aspx\" rel=\"nofollow noreferrer\">here</a></p>\n<p>With C++11, and applying the concept of 'default initialization', means that elements of B.member will not be initialized.</p>\n<p>But I believe that <code>member{}</code> should perform value initialization and not default initialization. Is the VS2013 compiler broken?</p>\n<p>$8.5/6</p>\n<blockquote>\n<p id=\"so_24122006_24122006_1\">To default-initialize an object of type <code>T</code> means:\n  \u2014 if <code>T</code> is a (possibly cv-qualified) class type (Clause 9), the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);<br/>\n  \u2014 if <code>T</code> is an array type, each element is default-initialized;<br/>\n  \u2014 otherwise, no initialization is performed.<br/>\n  If a program calls for the default initialization of an object of a <code>const</code>-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>$8.5.1</p>\n<blockquote>\n<p id=\"so_24122006_24122006_2\">List-initialization of an object or reference of type <code>T</code> is defined as follows:<br/>\n  \u2014 If the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.<br/>\n  \u2014 Otherwise, if <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</p>\n<p id=\"so_24122006_24122006_3\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4). [ <em>Example:</em></p>\n<pre><code>  struct S { int a; const char* b; int c; };\n  S ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_24122006_24122006_4\">initializes <code>ss.a</code> with <code>1</code>, <code>ss.b</code> with <code>\"asdf\"</code>, and <code>ss.c</code> with the value of an expression of the form <code>int()</code>, that is, <code>0</code>. <em>\u2014end example</em> ]\n  </p>\n</blockquote>\n", "Tags": "<c++><c++11><visual-studio-2013><constructor><value-initialization>", "OwnerUserId": "3701522", "AnswerCount": "3"}});