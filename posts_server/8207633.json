post_cb({"8304007": {"ParentId": "8207633", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>\"The C++ Programming Language 3rd Edition (Stroustrap)\" : p279:</p>\n<p>I. \"Like a member declaration, a friend declaration does not introduce a name into an enclosing scope\"</p>\n<p>II. \"A friend class must be previously declared in an enclosing scope or defined in the nonclass\nscope immediately enclosing the class that is declaring it a friend\"</p>\n<p>III. \"A friend function can be explicitly declared just like friend classes, or it can be found through its argument types (\u00a78.2.6) as if it was declared in the nonclass\nscope immediately enclosing its class.\"</p>\n<p>IV. \"It follows that a friend function should either be explicitly declared in an enclosing scope or take an argument of its class. If not, the friend cannot be called. For example:\"</p>\n<pre><code>//no f() here\nvoid g();\nclass X{\n    friend void f();          //useless\n    friend void g();          //can be found because it is declared outside of class scope\n    friend void h(const X&amp;);  //can be found because the arguments access class members\n};\n\nvoid f() { }                 //enemy of X :)\n</code></pre>\n<p>But in your case there is more to it that has to do with the namespace, because if you put the proper declaration in foo e.g.:</p>\n<pre><code>namespace foo{\n  struct bar{\n    friend void baz(const &amp;bar){};\n    void call_friend();\n  }\n}\n</code></pre>\n<p>does not compile. However, if you declare it outside foo is works like a charm. Now consider that in fact, global, local, struct, and classes are in fact namespaces. Now this leads to the conclusion that the <code>baz(const &amp;)</code> is implicitly defined in the global scope. </p>\n<p>This compiles:</p>\n<pre><code>namespace foo{\n  struct bar{\n    friend void baz(const bar&amp;){};\n    void call_friend();\n  };\n}\n\nint main(){\n    foo::bar k;\n    baz(k);\n    return 0;\n}\n</code></pre>\n<p>Therefore, there are two issues:</p>\n<ol>\n<li>The friend declaration does not introduce a name in an enclosing scope, unless IV. Thus the original program cannot find baz() because it has not been properly declared.</li>\n<li>If IV , i.e. ADL, then the function is found in foo, but cannot be accessed as foo::baz(k), due to ADL. You will have to explicitely define baz(const bar&amp;) in foo to access it by qualified name. </li>\n</ol>\n<p>Thanks, hope it helps, but certainly, I liked the challenge :) .</p>\n", "Id": "8304007", "LastEditDate": "2011-11-29T13:38:02.393", "OwnerDisplayName": "user677656", "Score": "3", "CreationDate": "2011-11-28T23:46:00.880", "LastActivityDate": "2011-11-29T13:38:02.393", "LastEditorDisplayName": "user677656"}, "8207698": {"ParentId": "8207633", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I think you are confusing <code>friend</code> and <code>private</code>. By declaring function a <code>friend</code> you are granting it access to your private members, and not grating other functions access to it.  Anyway, any member function of a <code>struct</code> is accessible by any object because <code>struct</code> members are public by default.</p>\n<p>However, in your case <code>baz</code> isn't accessible because by doing <code>friend void baz(){}</code> you didn't really declare the function <code>baz</code>, you just said that it is a <code>friend</code> function. You can just remove the <code>friend</code> keyword, and it will solve all the issues.</p>\n", "OwnerUserId": "44673", "LastEditorUserId": "44673", "LastEditDate": "2011-11-21T05:40:03.373", "Id": "8207698", "Score": "-1", "CreationDate": "2011-11-21T05:33:48.250", "LastActivityDate": "2011-11-21T05:40:03.373"}, "8284809": {"ParentId": "8207633", "CommentCount": "2", "Body": "<p>When you declare a <code>friend</code> function with an unqualified id in a class it names a function in the nearest enclosing namespace scope.</p>\n<p>If that function hasn't previously been declared then the <code>friend</code> declaration doesn't make that function visible in that scope for normal lookup. It does make the declared function visible to argument-dependent lookup.</p>\n<p>This is emphasised in many notes, but the definitive statement is in 7.3.1.2/3 (of ISO/IEC 14882:2011):</p>\n<blockquote>\n<p id=\"so_8207633_8284809_0\">Every name first declared in a namespace is a member of that namespace. If a <code>friend</code> declaration in a non-local class <strong>first</strong> declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a matching declaration is provided in that namespace scope</strong> (either before or after the class definition granting friendship). If a friend function is called, its name may be found by the name lookup that considers functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the name in a <code>friend</code> declaration is neither qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace.</p>\n</blockquote>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "8284809", "Score": "28", "CreationDate": "2011-11-27T10:09:58.327", "LastActivityDate": "2011-11-27T10:09:58.327"}, "8207877": {"ParentId": "8207633", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Interesting!</p>\n<p>It seems that the compiler does not know what scope it belongs to (and to be honest there are no clues) and thus puts in in no scope. Some standard digging coming up I suppose.</p>\n<p>Note: If you explicitly add a declaration to a particular scope then it starts to work as expected.</p>\n<pre><code>namespace foo\n{\n  void baz();   // declare it here and now it works in foo namespace etc.\n  struct bar\n  {\n    friend void baz(){}\n    void call_friend();\n  };\n}\n</code></pre>\n<p>Digging the standard I find:</p>\n<h2>11.3 Friends  [class.friend]</h2>\n<h3>Paragraph 6</h3>\n<blockquote>\n<p id=\"so_8207633_8207877_0\">A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8), <strong>the function name is unqualified, and the function has namespace scope</strong>.</p>\n</blockquote>\n<pre><code>[ Example:\nclass M { friend void f() { }       // definition of global f, a friend of M,\n                                    // not the definition of a member function\n};\n\u2014 end example ]\n</code></pre>\n<h3>Paragraph 7</h3>\n<blockquote>\n<p id=\"so_8207633_8207877_1\">Such a function is implicitly inline. A friend function defined in a class <strong>is in the (lexical) scope of the class</strong> in which it is defined. A friend function defined outside the class is not (3.4.1).</p>\n</blockquote>\n<h3>Note:</h3>\n<p>A free standing function that does not take a parameter is not much use as a friend. As it will have no object on which to take advantage of its friendship (I suppose file scope static storage duration objects).</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "147192", "LastEditDate": "2011-11-21T07:36:27.310", "Id": "8207877", "Score": "2", "CreationDate": "2011-11-21T06:01:21.213", "LastActivityDate": "2011-11-21T07:36:27.310"}, "8208027": {"ParentId": "8207633", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In this Example,</p>\n<pre><code>namespace foo{\n  struct bar{\n    friend void baz(){}\n    void call_friend();\n  };\n}\n\nint main(){\n  foo::baz();           // can't access through enclosing scope of the class\n  foo::bar::baz();    // can't access through class scope\n}\n\nnamespace foo{\n  void bar::call_friend(){\n    baz();    // can't access through member function\n  }\n}\n</code></pre>\n<ol>\n<li><p><code>foo::baz()</code> is inaccessible because the name <code>baz</code> is not visible in scope of namespace <code>foo</code>.  If I remember correctly (\u00a7 3.4/2) applies here. </p></li>\n<li><p><code>foo::bar::baz()</code> is inaccessible because friends aren't members of class and the scope of inline friend function is namespace or class in which their definition exists therefore, you can't access them outside of that scope.</p></li>\n</ol>\n<p>If you put the declaration of <code>baz()</code> in <code>foo</code> the name of function <code>baz</code> will be visible in <code>foo</code> and the definition will be looked up in the nested scope of <code>bar</code>.</p>\n<pre><code>namespace foo{\n  void baz();  // declaration at namespace scope\n  struct bar{\n    friend void baz(){}\n  };\n\n  void call_friend() {\n     baz();  // ok\n  }\n}\n\nint main()\n{\n    foo::baz(); // ok, bar will be looked up in the nested scope of foo::bar.\n}\n</code></pre>\n", "OwnerUserId": "187543", "LastEditorUserId": "187543", "LastEditDate": "2011-11-21T09:53:30.963", "Id": "8208027", "Score": "0", "CreationDate": "2011-11-21T06:24:17.090", "LastActivityDate": "2011-11-21T09:53:30.963"}, "bq_ids": {"n4140": {"so_8207633_8207877_1": {"section_id": 6690, "quality": 0.9444444444444444, "length": 17}, "so_8207633_8207877_0": {"section_id": 6689, "quality": 1.0, "length": 15}, "so_8207633_8284809_0": {"section_id": 5485, "quality": 0.9058823529411765, "length": 77}}, "n3337": {"so_8207633_8207877_1": {"section_id": 6445, "quality": 0.9444444444444444, "length": 17}, "so_8207633_8207877_0": {"section_id": 6444, "quality": 1.0, "length": 15}, "so_8207633_8284809_0": {"section_id": 5271, "quality": 0.9529411764705882, "length": 81}}, "n4659": {"so_8207633_8207877_1": {"section_id": 8165, "quality": 0.9444444444444444, "length": 17}, "so_8207633_8207877_0": {"section_id": 8164, "quality": 1.0, "length": 15}, "so_8207633_8284809_0": {"section_id": 6920, "quality": 0.8235294117647058, "length": 70}}}, "8207633": {"CommentCount": "11", "AcceptedAnswerId": "8284809", "PostTypeId": "1", "LastEditorUserId": "211563", "CreationDate": "2011-11-21T05:26:11.680", "LastActivityDate": "2011-11-29T13:38:02.393", "LastEditDate": "2011-11-21T05:30:36.557", "ViewCount": "5070", "FavoriteCount": "12", "Title": "What's the scope of inline friend functions?", "Id": "8207633", "Score": "27", "Body": "<p>After searching aroung SO, one question taught me that the <em>lexical</em> scope of an inline friend function is the class it's defined in, meaning it can access e.g. the <code>typedef</code>s in the class without qualifying them. But then I wondered <strong>what is the actual scope of such a function?</strong> GCC at least rejects all my attempts to call it. Can a function such as in the example ever be called through means other than ADL, which is not possible here thanks to no arguments?</p>\n<p>Standard quotations are appreciated, as I currently can't access my copy of it.</p>\n<p><a href=\"http://ideone.com/K0mds\">The following code</a></p>\n<pre><code>namespace foo{\n  struct bar{\n    friend void baz(){}\n    void call_friend();\n  };\n}\n\nint main(){\n  foo::baz();           // can't access through enclosing scope of the class\n  foo::bar::baz();    // can't access through class scope\n}\n\nnamespace foo{\n  void bar::call_friend(){\n    baz();    // can't access through member function\n  }\n}\n</code></pre>\n<p>results in these errors:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:9: error: \u2018baz\u2019 is not a member of \u2018foo\u2019\nprog.cpp:10: error: \u2018baz\u2019 is not a member of \u2018foo::bar\u2019\nprog.cpp: In member function \u2018void foo::bar::call_friend()\u2019:\nprog.cpp:15: error: \u2018baz\u2019 was not declared in this scope\n</code></pre>\n", "Tags": "<c++><scope><inline><friend>", "OwnerUserId": "500104", "AnswerCount": "5"}});