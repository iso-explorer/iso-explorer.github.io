post_cb({"19870357": {"ParentId": "19870192", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-11-08T23:29:25.557", "Score": "3", "LastEditorUserId": "2877241", "LastEditDate": "2013-11-08T23:37:51.747", "Id": "19870357", "OwnerUserId": "2877241", "Body": "<p>size_t is an alias of some implementation-defined unsigned integral type. In C++ opposite to C where sizeof operator may be applied to VLA arrays the operand of sizeof operator is not evaluated (at run time). It is a constant. If the value of sizeof operator can be fit into int type the compiler does not issue a warning.\nIn the second example std::strlen is evaluated at run time so its result can do not fit into int so the compiler issues a warning.\nYou could substitute std:;strlen with your own constexpr function (some recursive function). In this case if the result can fit into int I think that the compiler will not issue a warning.</p>\n", "LastActivityDate": "2013-11-08T23:37:51.747"}, "19870192": {"CommentCount": "6", "ViewCount": "33601", "PostTypeId": "1", "LastEditorUserId": "2877241", "CreationDate": "2013-11-08T23:13:22.357", "LastActivityDate": "2017-07-13T15:32:42.917", "Title": "What is the return type of sizeof operator?", "LastEditDate": "2017-07-13T15:32:42.917", "Id": "19870192", "Score": "29", "Body": "<p>What is the return type of sizeof operator? cppreference.com &amp; msdn  says sizeof returns size_t. Does it really return a size_t?\nI'm using VS2010 Professional, and targeting for x64.</p>\n<pre><code>int main()\n{\n    int size   = sizeof(int);     // No warning\n    int length = strlen(\"Expo\");  //warning C4267: 'initializing' : conversion from 'size_t' to 'int', possible loss of data\n    return 0;\n}\n</code></pre>\n<p>I have this question because first line is not issuing any warning, whereas the second does. Even if I change it to char size, I don't get any warnings.</p>\n", "Tags": "<c++><visual-studio-2010><sizeof>", "OwnerUserId": "1937526", "AnswerCount": "3"}, "19870347": {"ParentId": "19870192", "CommentCount": "1", "Body": "<p>The sizeof operator is used to get the size of types or variable in bytes. Returns an unsigned integer type of at least 16 bit. It's used to get portability.</p>\n<p>This warning is because of the unsigned integer where is defined the size_t.</p>\n", "OwnerUserId": "2956812", "PostTypeId": "2", "Id": "19870347", "Score": "0", "CreationDate": "2013-11-08T23:28:26.297", "LastActivityDate": "2013-11-08T23:28:26.297"}, "19870234": {"ParentId": "19870192", "CommentCount": "4", "Body": "<p>C++11, \u00a75.3.3 \u00b66</p>\n<blockquote>\n<p id=\"so_19870192_19870234_0\">The result of <code>sizeof</code> and <code>sizeof...</code> is a constant of type <code>std::size_t</code>. [ Note: std::size_t is defined in\n  the standard header  (18.2). \u2014 end note ]</p>\n</blockquote>\n<p>You can also do a quick check:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    std::cout&lt;&lt;(typeid(sizeof(int))==typeid(std::size_t))&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>which correctly outputs <code>1</code> on my machine.</p>\n<p>As <em>@Adam D. Ruppe</em> said in the comment, probably the compiler does not complain because, since it already knows the result, it knows that such \"conversion\" is not dangerous</p>\n", "OwnerUserId": "214671", "PostTypeId": "2", "Id": "19870234", "Score": "21", "CreationDate": "2013-11-08T23:17:31.640", "LastActivityDate": "2013-11-08T23:17:31.640"}, "bq_ids": {"n4140": {"so_19870192_19870234_0": {"section_id": 6081, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_19870192_19870234_0": {"section_id": 5849, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_19870192_19870234_0": {"section_id": 7577, "quality": 0.6428571428571429, "length": 9}}}});