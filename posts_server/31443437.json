post_cb({"31443437": {"CommentCount": "4", "AcceptedAnswerId": "31443577", "PostTypeId": "1", "LastEditorUserId": "3217070", "CreationDate": "2015-07-16T00:24:04.523", "LastActivityDate": "2015-07-16T01:37:56.927", "LastEditDate": "2015-07-16T01:37:56.927", "ViewCount": "282", "FavoriteCount": "2", "Title": "Why is the order of destruction of these function-local static objects NOT the inverse of their order of initialization?", "Id": "31443437", "Score": "4", "Body": "<p>I have two function-local static objects, One and Two. One's constructor and destructor both access Two through GetTwo():</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct One;\nstruct Two;\n\nconst One&amp; GetOne();\nconst Two&amp; GetTwo();\n\nstruct Two {\n  const char* value = \"It's two!\";\n  Two() { std::cout &lt;&lt; \"Two construct\" &lt;&lt; std::endl; }\n  ~Two() { std::cout &lt;&lt; \"Two destruct\" &lt;&lt; std::endl; }\n};\n\nstruct One {\n  One() {\n    std::cout &lt;&lt; \"One construct\" &lt;&lt; std::endl;\n    const char* twoval = GetTwo().value;\n    std::cout &lt;&lt; \"twoval is: \" &lt;&lt; twoval &lt;&lt; std::endl;\n  }\n  ~One() {\n    std::cout &lt;&lt; \"One destruct\" &lt;&lt; std::endl;\n    const char* twoval = GetTwo().value;\n    std::cout &lt;&lt; \"twoval is: \" &lt;&lt; twoval &lt;&lt; std::endl;\n  }\n};\n\nconst One&amp; GetOne() {\n  static One one;\n  return one;\n}\n\nconst Two&amp; GetTwo() {\n  static Two two;\n  return two;\n}\n\nint main(void) {\n  GetOne();\n}\n</code></pre>\n<p>I compile this with g++ 4.8.4:\n    g++ -std=c++11 [filename]</p>\n<p>And it outputs:</p>\n<pre><code>One construct\nTwo construct\ntwoval is: It's two!\nOne destruct\ntwoval is: It's two!\nTwo destruct\n</code></pre>\n<p>They are constructed and destructed in the same order! I read that for static variables of C++ classes in the same translation unit, the order of destruction is always the inverse of the order of construction. But I guess not? Or, is this undefined behavior?</p>\n<p>Also, I heard that for C++11, the C++ committee added some fancy guarantees for function-local static variables, like thread safety. If not undefined, then is this behavior a part of those guarantees? (Which would be pretty nice, since it would stop you from shooting yourself in the foot with One's destructor using a destructed instance of Two.) And what's guaranteed if GetOne and GetTwo are in different translation units?</p>\n<p>EDIT:</p>\n<p>Thanks for the comments so far, I see now that an object is considered constructed only after its constructor returns, not when it is first entered, so Two is actually constructed before One.</p>\n<p>Also I've attempted to read the standard and found this in the C++11 standard, section 6.7 item 4:</p>\n<blockquote>\n<p id=\"so_31443437_31443437_0\">The zero-initialization (8.5) of all block-scope variables with static\n  storage duration (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. Constant\n  initialization (3.6.2) of a block-scope entity with static storage\n  duration, if applicable, is performed before its block is first\n  entered. ...<strong>such a variable\n  is initialized the first time control passes through its declaration;\n  such a variable is considered initialized upon the completion of its\n  initialization.</strong></p>\n</blockquote>\n<p>And for destruction, 6.7 points us to 3.6.3, which says:</p>\n<blockquote>\n<p id=\"so_31443437_31443437_1\">If the completion of the constructor or dynamic initialization of an\n  object with static storage duration is sequenced before that of\n  another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>So if I'm reading this right: For function-local static objects, their construction is \"sequenced\" at runtime, based on the order the functions are called. And, no matter what translation unit they are defined in, they will be destructed in the inverse of that runtime-dependent order.</p>\n<p>Does this sound right? That would make this a nice solution to the static order initialization fiasco. That said, I think you could still shoot yourself in the foot with the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct One;\nstruct Two;\n\nconst One&amp; GetOne();\nconst Two&amp; GetTwo();\nvoid PrintOneValue(const One&amp; one);\n\nstruct Two {\n  Two() { std::cout &lt;&lt; \"Two construct\" &lt;&lt; std::endl; }\n  ~Two() {\n    std::cout &lt;&lt; \"start Two destruct\" &lt;&lt; std::endl;\n    PrintOneValue(GetOne());\n    std::cout &lt;&lt; \"end Two destruct\" &lt;&lt; std::endl;\n  }\n};\n\nstruct One {\n  const char* value = \"It's one!\";\n  One() {\n    std::cout &lt;&lt; \"start One construct\" &lt;&lt; std::endl;\n    GetTwo();\n    std::cout &lt;&lt; \"end One construct\" &lt;&lt; std::endl;\n  }\n  ~One() {\n    std::cout &lt;&lt; \"One destruct\" &lt;&lt; std::endl;\n  }\n};\n\nvoid PrintOneValue(const One&amp; one) {\n  std::cout &lt;&lt; \"One's value is: \" &lt;&lt; one.value &lt;&lt; std::endl;\n}\n\nconst One&amp; GetOne() {\n  static One one;\n  return one;\n}\n\nconst Two&amp; GetTwo() {\n  static Two two;\n  return two;\n}\n\nint main(void) {\n  GetOne();\n}\n</code></pre>\n<p>Which outputs:</p>\n<pre><code>start One construct\nTwo construct\nend One construct\nOne destruct\nstart Two destruct\nOne's value is: It's one!\nend Two destruct\n</code></pre>\n<p>It accesses One's data after it is destructed, so undefined behavior. But at least it's deterministic.</p>\n", "Tags": "<c++><c++11><static-initialization>", "OwnerUserId": "3217070", "AnswerCount": "2"}, "31443577": {"ParentId": "31443437", "CommentCount": "0", "Body": "<p>The actual Standard text in C++14 [basic.start.term] is:</p>\n<blockquote>\n<p id=\"so_31443437_31443577_0\">If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first. [Note: This definition permits concurrent destruction. \u2014end note ]</p>\n</blockquote>\n<p>In your code, <code>two</code> is constructed during the constructor of <code>one</code>. Therefore the <em>completion</em> of constructor of <code>two</code> is sequenced-before the completion of constructor of <code>one</code>.</p>\n<p>So the completion of the destructor of <code>one</code> is sequenced-before the completion of the destructor of <code>two</code>, which explains what you are seeing.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "31443577", "Score": "4", "CreationDate": "2015-07-16T00:41:53.293", "LastActivityDate": "2015-07-16T00:41:53.293"}, "bq_ids": {"n4140": {"so_31443437_31443437_1": {"section_id": 7156, "quality": 1.0, "length": 19}, "so_31443437_31443437_0": {"section_id": 3919, "quality": 0.9215686274509803, "length": 47}, "so_31443437_31443577_0": {"section_id": 7156, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_31443437_31443437_1": {"section_id": 6900, "quality": 1.0, "length": 19}, "so_31443437_31443437_0": {"section_id": 3779, "quality": 0.9215686274509803, "length": 47}, "so_31443437_31443577_0": {"section_id": 6900, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_31443437_31443437_1": {"section_id": 8663, "quality": 1.0, "length": 19}, "so_31443437_31443577_0": {"section_id": 8663, "quality": 0.7407407407407407, "length": 20}}}, "31443529": {"ParentId": "31443437", "CommentCount": "0", "Body": "<p>Change your ctor to:</p>\n<pre><code>  One() {\n    std::cout &lt;&lt; \"Start One construct\" &lt;&lt; std::endl;\n    const char* twoval = GetTwo().value;\n    std::cout &lt;&lt; \"twoval is: \" &lt;&lt; twoval &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Finish One construct\" &lt;&lt; std::endl;\n  }\n</code></pre>\n<p>now you'll see that <code>Two</code> finishes construction before <code>One</code> does.  So <code>Two</code> gets registered to be destroyed before <code>One</code> does, and gets destroyed after, because it was actually constructed (completely) first.</p>\n<pre><code>Start One construct\nTwo construct\ntwoval is: It's two!\nFinish One construct\nOne destruct\ntwoval is: It's two!\nTwo destruct\n</code></pre>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "31443529", "Score": "3", "CreationDate": "2015-07-16T00:35:31.563", "LastActivityDate": "2015-07-16T00:35:31.563"}});