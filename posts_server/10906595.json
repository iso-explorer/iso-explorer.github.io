post_cb({"10907208": {"ParentId": "10906595", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your...</p>\n<pre><code>int n = 1;\n</code></pre>\n<p>...ensures <code>n</code> exists in read/write memory; it's a non-<code>const</code> variable, so a later attempt to modify it will have defined behaviour.  Given such a variable, you can have a mix of <code>const</code> and/or non-<code>const</code> pointers and references to it - the constness of each is simply a way for the programmer to guard against accidental change in that \"branch\" of code.  I say \"branch\" because you can visualise the access given to <code>n</code> as being a tree in which - once a branch is marked <code>const</code>, all the sub-branches (further pointers/references to <code>n</code> whether additional local variables, function parameters etc. initialised therefrom) will need to remain <code>const</code>, unless of course you explicitly cast that notion of constness away.  Casting away <code>const</code> is safe (if potentially confusing) for variables that are mutable like your <code>n</code>, because they're ultimately still writing back into a memory address that is modifiable/mutable/non-<code>const</code>.  All the bizarre optimisations and caching you could imagine causing trouble in these scenarios aren't allowed as the Standard requires and guarantees sane behaviour in the case I've just described.</p>\n<p>Sadly it's also possible to cast away constness of genuinely inherently <code>const</code> variables like say <code>const int o = 1;</code>, and any attempt to modify them <em>will</em> have undefined behaviour.  There are many practical reasons for this, including the compiler's right to place them in memory it then marks read only (e.g. see UNIX <code>mprotect(2)</code>) such that an attempted write will cause a CPU trap/interrupt, or read from the variable whenever the originally-set value is needed (even if the variable's identifier was never mentioned in the code using the value), or use an inlined-at-compile-time copy of the original value - ignoring any runtime change to the variable itself.  So, the Standard leaves the behaviour undefined.  Even if they happen to be modified as you might have intended, the rest of the program will have undefined behaviour thereafter.</p>\n<p>But, that shouldn't be surprising.  It's the same situation with types - if you have...</p>\n<pre><code>double d = 1;\n*(int*)&amp;d = my_int;\nd += 1;\n</code></pre>\n<p>...have you have lied to the compiler about the type of <code>d</code>?  Ultimately <code>d</code> occupies memory that's probably untyped at a hardware level, so all the compiler ever has is a perspective on it, shuffling bit patterns in and out.  But, depending on the value of <code>my_int</code> and the double representation on your hardware, you may have created an invalid combination of bits in <code>d</code> that don't represent any valid double value, such that subsequent attempts to read the memory back into a CPU register and/or do something with <code>d</code> such as <code>+= 1</code> have undefined behaviour and might, for example, generate a CPU trap / interrupt.</p>\n<p>This is not a bug in C or C++... they're designed to let you make dubious requests of your hardware so that if you know what you're doing you can do some weird but useful things and rarely need to fall back on assembly language to write low level code, even for device drivers and Operating Systems.</p>\n<p>Still, it's precisely because casts can be unsafe that a more explicit and targeted casting notation has been introduced in C++.  There's no denying the risk - you just need to understand what you're asking for, why it's ok sometimes and not others, and live with it.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2015-02-27T10:01:18.020", "Id": "10907208", "Score": "6", "CreationDate": "2012-06-06T01:42:27.497", "LastActivityDate": "2015-02-27T10:01:18.020"}, "10906595": {"CommentCount": "7", "AcceptedAnswerId": "10906616", "PostTypeId": "1", "ClosedDate": "2012-06-06T03:22:33.817", "LastEditorUserId": "-1", "LastEditorDisplayName": "user166390", "CreationDate": "2012-06-05T23:57:05.153", "LastActivityDate": "2015-02-27T10:01:18.020", "LastEditDate": "2017-05-23T10:30:16.657", "ViewCount": "1374", "FavoriteCount": "3", "Title": "Is const a lie? (since const can be cast away)", "Id": "10906595", "Score": "25", "Body": "<blockquote>\n<p id=\"so_10906595_10906595_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/136880/sell-me-on-const-correctness\">Sell me on const correctness</a> </br></p>\n</blockquote>\n<p>What is the usefulness of keyword <code>const</code> in <code>C</code> or <code>C++</code> since it's allowed such a thing?</p>\n<pre><code>void const_is_a_lie(const int* n)\n{ \n    *((int*) n) = 0;\n}\n\nint main()\n{\n    int n = 1;\n    const_is_a_lie(&amp;n);\n    printf(\"%d\", n);\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_10906595_10906595_1\">Output: 0</p>\n</blockquote>\n<p>It is clear that <code>const</code> cannot guarante the non-modifiability of the argument.</p>\n", "Tags": "<c++><c><const>", "OwnerUserId": "995246", "AnswerCount": "5"}, "10906616": {"ParentId": "10906595", "PostTypeId": "2", "CommentCount": "14", "Body": "<p><code>const</code> is a promise you make to the compiler, not something it guarantees you.</p>\n<p>For example,</p>\n<pre><code>void const_is_a_lie(const int* n)\n{ \n    *((int*) n) = 0;\n}\n\n#include &lt;stdio.h&gt;\nint main()\n{\n    const int n = 1;\n    const_is_a_lie(&amp;n);\n    printf(\"%d\", n);\n    return 0;\n}\n</code></pre>\n<p>Output shown at <a href=\"http://ideone.com/Ejogb\" rel=\"nofollow\">http://ideone.com/Ejogb</a> is</p>\n<blockquote>\n<p id=\"so_10906595_10906616_0\">1</p>\n</blockquote>\n<p>Because of the <code>const</code>, the compiler is allowed to assume that the value won't change, and therefore it can skip rereading it, if that would make the program faster.</p>\n<p>In this case, since <code>const_is_a_lie()</code> violates its contract, weird things happen.  Don't violate the contract.  And be glad that the compiler gives you help keeping the contract.  Casts are evil.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-10-08T00:54:34.603", "Id": "10906616", "Score": "44", "CreationDate": "2012-06-05T23:59:40.760", "LastActivityDate": "2014-10-08T00:54:34.603"}, "10906645": {"ParentId": "10906595", "CommentCount": "8", "Body": "<p>Never did <code>const</code> guarantee immutability: the standard defines a <code>const_cast</code> that allows modifying const data.</p>\n<p><code>const</code> is useful for you to declare more intent and avoid changing data that is <em>you</em> meant to be read only. You'll get a compilation error asking you to think twice if you do otherwise. You can change your mind, but that's not recommended.</p>\n<p>As mentionned by other answers the compiler <strong>may</strong> optimize a bit more if you use const-ness but the benefits are not always significant.</p>\n", "OwnerUserId": "628361", "PostTypeId": "2", "Id": "10906645", "Score": "1", "CreationDate": "2012-06-06T00:03:13.337", "LastActivityDate": "2012-06-06T00:03:13.337"}, "10906639": {"ParentId": "10906595", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In this case, <code>n</code> is a pointer to a constant <code>int</code>.  When you cast it to <code>int*</code> you remove the <code>const</code> qualifier, and so the operation is allowed.</p>\n<p>If you tell the compiler to remove the <code>const</code> qualifier, it will happily do so.  The compiler will help ensure that your code is correct, if you let it do its job.  By casting the const-ness away, you are telling the compiler that you know that the target of <code>n</code> is non-constant and you really do want to change it.</p>\n<p>If the thing that your pointer points to was in fact declared <code>const</code> in the first place, then you are invoking <em>undefined behavior</em> by attempting to change it, and <em>anything could happen</em>.  It might work.  The write operation might not be visible.  The program could crash.  Your monitor could punch you.  (Ok, probably not that last one.)</p>\n<pre><code>void const_is_a_lie(const char * c) {\n    *((char *)c) = '5';\n}\n\nint main() {\n    const char * text = \"12345\";\n    const_is_a_lie(text);\n    printf(\"%s\\n\", text);\n\n    return 0;\n}\n</code></pre>\n<p>Depending on your specific environment, there may be a segfault (aka access violation) in <code>const_is_a_lie</code> since the compiler/runtime may store string literal values in memory pages that are not writable.</p>\n<p>The Standard has this to say about modifying const objects.</p>\n<blockquote>\n<p id=\"so_10906595_10906639_0\">7.1.6.1/4 The cv-qualifiers [dcl.type.cv]</p>\n<p id=\"so_10906595_10906639_1\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior</p>\n</blockquote>\n<p>\"Doctor, it hurts when I do this!\"  \"So don't do that.\"</p>\n", "OwnerUserId": "501250", "LastEditorUserId": "4082723", "LastEditDate": "2014-11-20T03:08:42.593", "Id": "10906639", "Score": "10", "CreationDate": "2012-06-06T00:02:31.947", "LastActivityDate": "2014-11-20T03:08:42.593"}, "bq_ids": {"n4140": {"so_10906595_10906639_1": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_10906595_10906639_1": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_10906595_10906639_1": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}, "10907759": {"ParentId": "10906595", "CommentCount": "0", "Body": "<p>The type system is there to help, not to babysit you. You can circumvent the type system in many ways, not only regarding const, and each time that you do that what you are doing is taking one safety out of your program. You can ignore const-correctness or even the basic type system by passing <code>void*</code> around and casting as needed. That does not mean that <em>const</em> or <em>types</em> are a lie, only that you can force your way over the compiler's.</p>\n<p><code>const</code> is there as a way of making the compiler aware of the contract of your function, and let it help you not violate it. In the same way that a variable being typed is there so that you don't need to <em>guess</em> how to interpret the data as the compiler will help you. But it won't baby sit, and if you force your way and tell it to remove const-ness, or how the data is to be retrieved the compiler will just let you, after all you did design the application, who is it to second guess your judgement...</p>\n<p>Additionally, in some cases, you might actually cause undefined behavior and your application might even crash (for example if you cast away const from an object that is really const and you modify the object you might find out that the side effects are not seen in some places (the compiler assumed that the value would not change and thus performed constant folding) or your application might crash if the constant was loaded into a read-only memory page.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "10907759", "Score": "2", "CreationDate": "2012-06-06T03:20:18.193", "LastActivityDate": "2012-06-06T03:20:18.193"}});