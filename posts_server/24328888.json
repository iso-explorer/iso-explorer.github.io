post_cb({"24329404": {"ParentId": "24328888", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Here is all simple though is written in the confusing manner. Either a name is a member of the namespace or its inlined namespaces or the name is a name introduced by a using directive of some other namespace. If such a name is exactly one name then it will be used.</p>\n<p>In your code example S( global, i ) has two members that is one is defined in the inlined namespace A and the other is introduced by using declaration. So there is an ambiguity.</p>\n<p>So the order of considering namespaces is the following.\nAt first there is considered the namespace itself and its inlining namespaces. If the name is exactly one then it is used.</p>\n<p>Otherewise the compiler considers using directives. If again the name is exactly one it is used.</p>\n<p>In all other cases the program is ill-formed.</p>\n<p>You have to consider the previous paragraph of the Standard</p>\n<blockquote>\n<p id=\"so_24328888_24329404_0\">2 For a namespace X and name m, the namespace-qualified lookup set\n  S(X,m) is defined as follows: Let S0(X,m) be the set of all\n  declarations of m in X and the inline namespace set of X (7.3.1). <strong>If\n  S0(X,m) is not empty, S(X,m) is S0(X,m);</strong> otherwise, S(X,m) is the\n  union of S(Ni,m) for all namespaces Ni nominated by using-directives\n  in X and its inline namespace set.</p>\n</blockquote>\n<p>EDIT: I am sorry. I mixed using declarations and using directive. In your example there is a using declarations. So the name is ambiguous. Id instead of</p>\n<pre><code>using B::i;\n</code></pre>\n<p>there would be</p>\n<pre><code>using namespace B;\n</code></pre>\n<p>then there would not be ambiguity.</p>\n<p>You should compare two examples</p>\n<p>The first one is exactly that you showed.</p>\n<pre><code>#include &lt;iostream&gt;\n\ninline namespace A\n{\n    int i = 42;\n};\n\nnamespace B \n{\n    static const int i = 5;\n};\n\nusing B::i;\n\nint g= ::i;\n\nint main() \n{\n    std::cout &lt;&lt; g &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The code will not be compiled because S( global, i ) contains two members.</p>\n<p>And the other example</p>\n<pre><code>#include &lt;iostream&gt;\n\ninline namespace A\n{\n    int i = 42;\n};\n\nnamespace B \n{\n    static const int i = 5;\n};\n\nusing namespace B;\n\nint g= ::i;\n\nint main() \n{\n    std::cout &lt;&lt; g &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The code will be compiled because the name i in namespace B will not be considered.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-06-20T14:43:38.927", "Id": "24329404", "Score": "0", "CreationDate": "2014-06-20T14:18:08.020", "LastActivityDate": "2014-06-20T14:43:38.927"}, "24328888": {"CommentCount": "3", "AcceptedAnswerId": "24329404", "OwnerDisplayName": "user2953119", "CreationDate": "2014-06-20T13:51:17.037", "LastActivityDate": "2014-06-20T14:43:38.927", "PostTypeId": "1", "ViewCount": "44", "FavoriteCount": "1", "Title": "How does context of reference determined", "Id": "24328888", "Score": "0", "Body": "<p>I'm trying to understand the rule of the section 3.4.3.2/3 of N3797 c++14 final working draft:</p>\n<blockquote>\n<p id=\"so_24328888_24328888_0\">Given X::m (where X is a user-declared namespace), or given ::m (where\n  X is the global namespace), if S(X, m) is the empty set, the program\n  is ill-formed. Otherwise, if S(X, m) has exactly one member, or if the\n  context of the reference is a using-declaration (7.3.3), S(X, m) is\n  the required set of declarations of m. Otherwise if the use of m is\n  not one that allows a unique declaration to be chosen from S(X, m),\n  the program is ill-formed.</p>\n</blockquote>\n<p>I've written the following code:</p>\n<pre><code>inline namespace A\n{\n    int i = 42;\n};\n\nnamespace B \n{\n    static const int i = 5;\n};\n\nusing B::i;\n\nint g= ::i //S(X, i)={using B::i, A::i}\n\nint main() { }\n</code></pre>\n<p>As said in the quote cited above we have:</p>\n<blockquote>\n<p id=\"so_24328888_24328888_1\">[...]if S(X, m) is the empty set[...]</p>\n</blockquote>\n<p>S(X,m) is not empty, further:</p>\n<blockquote>\n<p id=\"so_24328888_24328888_2\">Otherwise, if S(X, m) has exactly one member</p>\n</blockquote>\n<p>is not true, further:</p>\n<blockquote>\n<p id=\"so_24328888_24328888_3\">or if the context of the reference is a using-declaration</p>\n</blockquote>\n<p>I don't understand how does that constraint checked for my example. I would like to understand how does context of reference determined depends on the using of that reference?</p>\n", "Tags": "<c++><reference><namespaces>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24328888_24328888_2": {"section_id": 7118, "quality": 1.0, "length": 4}, "so_24328888_24329404_0": {"section_id": 7117, "quality": 0.7352941176470589, "length": 25}, "so_24328888_24328888_0": {"section_id": 7118, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_24328888_24328888_2": {"section_id": 6862, "quality": 1.0, "length": 4}, "so_24328888_24329404_0": {"section_id": 6861, "quality": 0.7352941176470589, "length": 25}, "so_24328888_24328888_0": {"section_id": 6862, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_24328888_24328888_2": {"section_id": 4048, "quality": 1.0, "length": 4}, "so_24328888_24329404_0": {"section_id": 8618, "quality": 0.7352941176470589, "length": 25}, "so_24328888_24328888_0": {"section_id": 8619, "quality": 0.9666666666666667, "length": 29}}}});