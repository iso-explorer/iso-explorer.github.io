post_cb({"13223315": {"Id": "13223315", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13223278_13223315_0\">If not, does anyone have a good idea for a work-around? </p>\n</blockquote>\n<p>At the point where you define that template, the only <code>F()</code> that is known to the compiler is <code>void F(int x,char y)</code>, which obviously doesn't match the usage in <code>G(T t)</code>.</p>\n<p>The solution is simple: Define or declare <code>void F(int x)</code> <strong>before</strong> defining <code>template&lt;typename T&gt; void G(T t)</code>.</p>\n", "LastActivityDate": "2012-11-04T21:50:55.577", "CommentCount": "2", "CreationDate": "2012-11-04T21:50:55.577", "ParentId": "13223278", "Score": "0", "OwnerUserId": "774499"}, "13223306": {"Id": "13223306", "PostTypeId": "2", "Body": "<p>One possible workaround is to ensure that the declaration of <code>void F(int x)</code> is available before that of <code>template&lt;typename T&gt; void G(T t);</code></p>\n<pre><code>void F(int x);\n\ntemplate&lt;typename T&gt; void G(T t) { .... }\n</code></pre>\n<p>In your example, <code>F(int)</code> dependent name, so is looked up during the second phase of the <em>two-phase lookup</em>. However, the rules of the look-up. specified in \u00a714.6.4 of draft n3337, specify that the name must be visible at the point of definition of the template, or in a namespace associated with the types of the function arguments (argument dependent look-up):</p>\n<blockquote>\n<p id=\"so_13223278_13223306_0\">In resolving dependent names, names from the following sources are considered:</p>\n<p id=\"so_13223278_13223306_1\">\u2014 Declarations that are visible at the point of definition of the template.</p>\n<p id=\"so_13223278_13223306_2\">\u2014 Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</p>\n</blockquote>\n<p>So an alternative work-around to is to bring the function into the namespace of <code>T</code>.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2012-11-05T09:38:44.157", "Score": "1", "CreationDate": "2012-11-04T21:49:43.093", "ParentId": "13223278", "CommentCount": "4", "OwnerUserId": "661519", "LastEditDate": "2012-11-05T09:38:44.157"}, "13223278": {"ViewCount": "205", "Body": "<p>The following code is not accepted by GCC 4.6:</p>\n<pre><code>void F(int x,char y)\n{\n}\ntemplate&lt;typename T&gt;\nvoid G(T t)\n{\n    F(t);\n}\nvoid F(int x)\n{\n}\n\nint main()\n{\n    G(5);\n    return 0;\n}\n</code></pre>\n<p>Should it be?</p>\n<p>If not, does anyone have a good idea for a work-around? The real world scenario where this occurs is where G is part of a library for solving a particular kind of problem, needing a user-supplied helper function called F. However, for different kinds of problems, F takes different number of parameters. A few sample implementations of F are shipped with the library.</p>\n<p>What is happening is that depending on the #include-order used by the client, only the \"wrong kind\" of F may be visible at template declaration time, and GCC then gives up, without waiting until the user-provided, correct, F is defined. This is even though template instantiation happens after the correct F is defined.</p>\n<p>Update: Yes I know it works if all declarations of F happen before G, or if all declarations of F happen after G. However, that doesn't really help me very much.</p>\n<p>Update: In the code this minimal example is adapted from, F is really called 'read'. And the first declaration of read has nothing at all to do with the second. The first declaration is in one header file, and the second in another. I don't want to introduce 'strange' rules regarding include-file order, especially when the versions of 'read' have nothing to do with one another.</p>\n", "AcceptedAnswerId": "13223477", "Title": "Template function call confused by function with wrong signature declared before template", "CreationDate": "2012-11-04T21:46:56.170", "Id": "13223278", "CommentCount": "2", "LastEditDate": "2012-11-04T22:03:30.390", "PostTypeId": "1", "LastEditorUserId": "395763", "LastActivityDate": "2012-11-05T09:38:44.157", "Score": "4", "OwnerUserId": "395763", "Tags": "<c++><templates>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_13223278_13223306_0": {"length": 6, "quality": 1.0, "section_id": 215}, "so_13223278_13223306_1": {"length": 5, "quality": 1.0, "section_id": 215}, "so_13223278_13223306_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 215}}, "n3337": {"so_13223278_13223306_0": {"length": 6, "quality": 1.0, "section_id": 209}, "so_13223278_13223306_1": {"length": 5, "quality": 1.0, "section_id": 209}, "so_13223278_13223306_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 209}}, "n4659": {"so_13223278_13223306_0": {"length": 6, "quality": 1.0, "section_id": 223}, "so_13223278_13223306_1": {"length": 5, "quality": 1.0, "section_id": 223}, "so_13223278_13223306_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 223}}}, "13223477": {"Id": "13223477", "PostTypeId": "2", "Body": "<p>At instantiation, only argument dependent lookup is done. You can fix your case by using an argument whose type resides in the namespace of your <code>F</code></p>\n<pre><code>void F(int x,char y)\n{\n}\ntemplate&lt;typename T&gt;\nvoid G(T t)\n{\n    F(t);\n}\nvoid F(int x)\n{\n}\n\ntemplate&lt;typename T&gt;\nstruct wrapper {\n operator T() const { return t; }\n T t;\n};\n\ntemplate&lt;typename T&gt; wrapper&lt;T&gt; make_wrapper(T t) {\n  wrapper&lt;T&gt; w = { t };\n  return w;\n}\n\nint main()\n{\n    G(make_wrapper(5));\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2012-11-04T22:13:39.430", "CommentCount": "4", "CreationDate": "2012-11-04T22:13:39.430", "ParentId": "13223278", "Score": "4", "OwnerUserId": "34509"}, "13223305": {"Id": "13223305", "PostTypeId": "2", "Body": "<p>Try placing the <code>F(int)</code> overload <em>above</em> <code>G</code>.</p>\n<pre><code>void F(int x) {}\n\ntemplate &lt;typename T&gt; void G(T t) { F(t); } // works\n</code></pre>\n<p>Functions aren't hoisted; you must either prototype or define them before they are used.</p>\n", "LastActivityDate": "2012-11-04T21:49:39.363", "CommentCount": "6", "CreationDate": "2012-11-04T21:49:39.363", "ParentId": "13223278", "Score": "0", "OwnerUserId": "701092"}});