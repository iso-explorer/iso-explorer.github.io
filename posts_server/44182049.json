post_cb({"bq_ids": {"n4140": {"so_44182049_44182938_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 7183}, "so_44182049_44182938_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 7183}, "so_44182049_44182938_1": {"length": 4, "quality": 0.8, "section_id": 7183}, "so_44182049_44182938_2": {"length": 42, "quality": 0.9130434782608695, "section_id": 7183}}, "n3337": {"so_44182049_44182938_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6927}, "so_44182049_44182938_2": {"length": 29, "quality": 0.6304347826086957, "section_id": 6927}, "so_44182049_44182938_1": {"length": 5, "quality": 1.0, "section_id": 6927}, "so_44182049_44182938_3": {"length": 7, "quality": 0.5833333333333334, "section_id": 6927}}, "n4659": {"so_44182049_44182938_2": {"length": 24, "quality": 0.5217391304347826, "section_id": 8671}, "so_44182049_44182938_1": {"length": 4, "quality": 0.8, "section_id": 8671}, "so_44182049_44182938_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 8671}}}, "44182049": {"ViewCount": "652", "Body": "<p>After reading many posts about this, I want to clarify the next point:</p>\n<pre><code>A* a = new A();\nA* b = a;\n\ndelete a;\n\nA* c = a; //illegal - I know it (in c++ 11)\nA* d = b; //I suppose it's legal, is it true?\n</code></pre>\n<p>So the question is about using the <strong>value</strong> of <strong>copy</strong> of deleted pointer.</p>\n<p>I've read, that in c++ 11 reading the value of a leads to undefined behavour - but what about reading the value of b?</p>\n<blockquote>\n<p id=\"so_44182049_44182049_0\">Trying to read the value of the pointer (note: this is different to\n  dereferencing it) causes implementation-defined behaviour since C++14,\n  which may include generating a runtime fault. (In C++11 it was\n  undefined behaviour)\n  <a href=\"https://stackoverflow.com/questions/23621677/what-happens-to-the-pointer-itself-after-delete\">What happens to the pointer itself after delete?</a></p>\n</blockquote>\n", "Title": "Pointers in c++ after delete", "CreationDate": "2017-05-25T13:38:24.627", "LastActivityDate": "2017-05-26T05:43:53.830", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-25T14:08:40.207", "LastEditorUserId": "1413395", "Id": "44182049", "Score": "9", "OwnerUserId": "8065280", "Tags": "<c++><c++11><pointers><c++14>", "AnswerCount": "3"}, "44182938": {"Id": "44182938", "PostTypeId": "2", "Body": "<p>Both:</p>\n<pre><code>A* c = a;\nA* d = b;\n</code></pre>\n<p>are undefined in C++11 and implementation defined in C++14. This is because <code>a</code> and <code>b</code> are both \"invalid pointer values\" (as they point to deallocated storage space), and \"using an invalid pointer value\" is either undefined or implementation defined, depending on the C++ version. (\"Using\" includes \"copying the value of\").</p>\n<p>The relevant section (<code>[basic.stc.dynamic.deallocation]/4</code>) in C++11 reads (emphasis added):</p>\n<blockquote>\n<p id=\"so_44182049_44182938_0\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid <strong>all</strong> pointers referring to any part of the deallocated storage. The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.</p>\n</blockquote>\n<p>with a non-normative note stating:</p>\n<blockquote>\n<p id=\"so_44182049_44182938_1\">On some implementations, it causes a system-generated runtime</p>\n</blockquote>\n<p>In C++14 the same section reads:</p>\n<blockquote>\n<p id=\"so_44182049_44182938_2\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid <strong>all</strong> pointers referring to any part of the deallocated storage. Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have unde\ufb01ned behavior. Any other use of an invalid pointer value has implementation-de\ufb01ned behavior.</p>\n</blockquote>\n<p>with a non-normative note stating:</p>\n<blockquote>\n<p id=\"so_44182049_44182938_3\">Some implementations might de\ufb01ne that copying an invalid pointer value causes a system-generated runtime fault</p>\n</blockquote>\n", "LastEditorUserId": "485561", "LastActivityDate": "2017-05-25T14:28:15.267", "Score": "22", "CreationDate": "2017-05-25T14:22:41.850", "ParentId": "44182049", "CommentCount": "4", "OwnerUserId": "485561", "LastEditDate": "2017-05-25T14:28:15.267"}, "44186548": {"Id": "44186548", "PostTypeId": "2", "Body": "<p>You <strong>should not</strong> use the pointer after <code>delete</code>. My below example with acessing <code>a</code> is based on <strong>implementation-defined behaviour</strong>.\n(thanks to for M.M and Mankarse for pointing this)</p>\n<p>I feel that it is not the variable <code>a</code> (or <code>b</code>, <code>c</code>, <code>d</code>) that is important here, but that the value (=the memory address of a deallocated block) which in some implementations can trigger a runtime fault when used in some 'pointer context'.</p>\n<p>This value may be an rvalue/expression, not necessarily the value stored in a variable - so I do not believe the value of <code>a</code> ever changes (I am using the loose 'pointer context' to distinguish from using the same value, i.e. the same set of bits, in non-pointer related expressions - which will not cause a runtime fault).</p>\n<p>------------My original post is below.---------------</p>\n<p><s>\nWell, you are almost there with your experiment. Just add some <code>cout</code>'s like here:</s></p>\n<pre><code>class A {};\nA* a = new A();\nA* b = a;\nstd::cout &lt;&lt; a &lt;&lt; std::endl;   // &lt;--- added here\ndelete a;\nstd::cout &lt;&lt; a &lt;&lt; std::endl;   // &lt;--- added here. Note 'a' can still be used! \nA* c = a; \nA* d = b; \n</code></pre>\n<p></p>\n<p>Calling <code>delete a</code> does not do anything to the variable <code>a</code>. This is just a library call. The library that manages dynamic memory allocation keeps a list of allocated memory blocks and uses the value passed by variable <code>a</code> to mark one of the previously allocated blocks as freed. </p>\n<p>While it is true what Mankarse cites from C++ documentation, about: \"rendering invalid all pointers referring to any part of the deallocated storage\" - note that the value of variable <code>a</code> remains untouched (you did not pass it by reference, but by value !). </p>\n<p>So to sum up and to try to answer your question:</p>\n<p>Variable <code>a</code> still exists in the scope after <code>delete</code>. The variable <code>a</code> still contains the same value, which is the address of the beginning of the memory block allocated (and now already deallocated) for an object of <code>class A</code>. <s>This value of <code>a</code> technically can be used - you can e.g. print it like in my above example \u2013 however it is hard to find a more reasonable use for it than printing/logging the past...\nWhat you should not do is trying to de-reference this value (which you also keep in variables <code>b</code>, <code>c</code>, and <code>d</code>) \u2013 as this value is not a valid memory pointer any longer. </s></p>\n<p>You should never rely on the object being in the deallocated storage (while it is quite probable that it will remain there for some while, as C++ does not require to clear the storage freed after use) - you have no guarantees and no safe way to check this).</p>\n", "LastEditorUserId": "6308879", "LastActivityDate": "2017-05-26T05:43:53.830", "Score": "-1", "CreationDate": "2017-05-25T17:35:03.117", "ParentId": "44182049", "CommentCount": "11", "OwnerUserId": "6308879", "LastEditDate": "2017-05-26T05:43:53.830"}, "44182329": {"Id": "44182329", "PostTypeId": "2", "Body": "<p>These 2 lines do not have any difference (meaning legality for C++):</p>\n<pre><code>A* c = a; //illegal - I know it (in c++ 11)\nA* d = b; //I suppose it's legal, is it true?\n</code></pre>\n<p>Your mistake (and it is pretty common) to think if you call <code>delete</code> on <code>a</code> it makes it any different than <code>b</code>. You should remember that when you call <code>delete</code> on a pointer you pass argument by value, so memory, where <code>a</code> points to after <code>delete</code> is not usable anymore, but that call does not make <code>a</code> any different than <code>b</code> in your example.</p>\n", "LastActivityDate": "2017-05-25T13:52:50.683", "CommentCount": "24", "CreationDate": "2017-05-25T13:52:50.683", "ParentId": "44182049", "Score": "-1", "OwnerUserId": "432358"}});