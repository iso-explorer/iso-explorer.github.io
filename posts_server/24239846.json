post_cb({"24239846": {"CommentCount": "0", "ViewCount": "128", "PostTypeId": "1", "LastEditorUserId": "3744088", "CreationDate": "2014-06-16T08:53:09.440", "LastActivityDate": "2014-06-17T18:52:29.750", "Title": "Namespace of a function declaration nested in function", "AcceptedAnswerId": "24250341", "LastEditDate": "2014-06-17T07:46:52.637", "Id": "24239846", "Score": "3", "Body": "<p>For odd reasons, I want to declare a function inside a function scope.\nSo I get the following code :</p>\n<pre><code>namespace NS\n{\n    void foo()\n    {\n        void bar();\n        bar();\n    }\n}\n</code></pre>\n<p>In another compilation unit, I want to define bar.\nDepending on the compiler I'm using, I need to put bar in namespace NS or in the global namespace to be able to link:</p>\n<p>On clang:</p>\n<pre><code>namespace NS\n{\n    void bar() {}\n}\n</code></pre>\n<p>On MSVC:</p>\n<pre><code>void bar() {}\n</code></pre>\n<p>What's the good behavior, if any ?</p>\n<p>As a side question, why is none of the following code compiling (on my 2 compilers):</p>\n<pre><code>namespace NS\n{\n    void foo()\n    {\n        void bar();\n        ::bar(); // bar declared in global namespace\n    }\n}\n</code></pre>\n<p>or</p>\n<pre><code>namespace NS\n{\n    void foo()\n    {\n        void bar();\n        ::NS::bar(); // bar declared in NS namespace\n    }\n}\n</code></pre>\n<p>Thank you for your help.</p>\n<p>GiSylbe</p>\n", "Tags": "<c++><namespaces><language-lawyer><forward-declaration>", "OwnerUserId": "3744088", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24239846_24250341_2": {"section_id": 7139, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_6": {"section_id": 7140, "quality": 1.0, "length": 27}, "so_24239846_24250341_3": {"section_id": 7139, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_5": {"section_id": 7140, "quality": 1.0, "length": 27}}, "n3337": {"so_24239846_24250341_2": {"section_id": 6883, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_6": {"section_id": 6884, "quality": 1.0, "length": 27}, "so_24239846_24250341_3": {"section_id": 6883, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_5": {"section_id": 6884, "quality": 1.0, "length": 27}}, "n4659": {"so_24239846_24250341_2": {"section_id": 8640, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_6": {"section_id": 8641, "quality": 1.0, "length": 27}, "so_24239846_24250341_3": {"section_id": 8640, "quality": 0.9333333333333333, "length": 56}, "so_24239846_24250341_5": {"section_id": 8641, "quality": 1.0, "length": 27}}}, "24250341": {"ParentId": "24239846", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_24239846_24250341_0\"><sup><strong>Note</strong>: Long story, short; <em>msvc</em> is doing it wrong, and <em>clang</em> is correct. This post will explain why by showing relevant snippets, and having standard quotations to back up the claims.</sup></p>\n</blockquote>\n<h1>About the first snippet/question</h1>\n<hr>\n<h3>Introduction</h3>\n<p>A function-declaration in block scope is said to refer to an entity in the innermost enclosing namespace, so in the below <em>bar</em> is referring to <em>NS::bar</em>.</p>\n<pre><code>namespace NS {\n  void foo () {\n    void bar (); // (A), forward-declaration of `NS::bar`\n\n    bar ();      // call (A)\n  }\n}\n</code></pre>\n<p>This means that you, upon defining <em>bar</em>, must do so in either namespace <em>N</em>, or by using a <em>qualified-id</em> to refer to said entity.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void f ():     // some other `void f()`;  _not_ (A)\n\nvoid NS::f (); // same `f` as being declared at (A)\n\nnamespace NS {\n  void f ();   // same `f` as being declared at (A)\n}\n</code></pre>\n<hr>\n<h3>What does the standard say? (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">n3337</a>)</h3>\n<blockquote>\n<p id=\"so_24239846_24250341_1\"><code>3.5p6</code> <strong>Program and linkage</strong> <code>[basic.link]</code></p>\n<blockquote>\n<p id=\"so_24239846_24250341_3\">The name of a function declared in block scope and the name of a variale declared by a block scope <code>extern</code> declaration have linkage. If there is a visible declaration of an enity with linkage having the same name and type, ignoring entities declared outside the innermost enclosing namespace scope, the block scope declaration declares the same entitiy and receives the linkage of the previous declaration. If there is more than one such matching entity, the program is ill-formed. Otherwise, if no matching entity is found, the block scope entity receives external linkage.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>Conclusion</h3>\n<p><code>msvc</code> is doing it wrong, the behavior shown by <code>clang</code> is the correct one.</p>\n<hr>\n<hr>\n<h1>About the second snippet/question</h1>\n<hr>\n<h3>Explanation</h3>\n<p>When a block-scope declaration is encountered it is referring to an entity in the closest enclosing namespace, but it does <strong>not</strong> introduce such name in that namespace.</p>\n<blockquote>\n<p id=\"so_24239846_24250341_4\"><code>3.5p7</code> <strong>Program and linkage</strong> <code>[basic.link]</code></p>\n<blockquote>\n<p id=\"so_24239846_24250341_6\">When a block scope declaration of an entity with linkage is not found to refer to some other declaration, then that entity is a member of the innermost enclosing namespace. However such a declaration does not introduce the member name in its namespace scope.</p>\n</blockquote>\n</blockquote>\n<p>See the below example:</p>\n<pre><code>namespace NS {\n  void foo() {\n    void bar();  // (A), forward-declaration of `NS::bar`\n    ::NS::bar(); //      ill-formed, there is no `::NS::bar` yet\n    bar ();      //           legal, call the `bar` being forward-declared by (A)\n  }\n}\n</code></pre>\n<p>In the above (A) refers to an upcoming declaration of <code>::NS::bar</code>, but since a forward-declaration does not make <em>namespace NS</em> have an entity named <em>bar</em> we can only refer to the entity that will be known as <code>::NS::bar</code> through <em>bar</em>.</p>\n<pre><code>void bar ();    // (A), `::bar`\n\nnamespace NS {\n  void foo() {\n    void bar();   // (B), forward-declaration of `NS::bar`\n\n    ::bar();      // call (A)\n    bar ();       // call (B), `NS::bar`\n\n    ::NS::bar (); // ill-formed, `namespace NS` doesn't have an entity named bar (yet) \n  }\n\n  void bar ();    // (C), make `NS` have an entity named bar, this is the one\n                  //      being referred to by (B)\n\n  void baz () {\n    ::NS::bar (); // legal, `namespace NS` now have an entity named `bar`, as being\n                  //        declared in (C)\n  }\n}\n</code></pre>\n</hr></hr></hr></hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-17T18:52:29.750", "Id": "24250341", "Score": "1", "CreationDate": "2014-06-16T18:58:08.153", "LastActivityDate": "2014-06-17T18:52:29.750"}});