post_cb({"27118551": {"ParentId": "27118535", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In C++11 having in-class member initializers makes the struct/class not an aggregate \u2014 this was changed in C++14, however. This is something I found surprising when I first ran into it, the rationale for this restriction is that in-class initializers are pretty similar to a user defined constructor but the counter argument is that no one really expects that adding in-class initializers should make their class/struct a non-aggregate, I sure did not.</p>\n<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++11 standard</a> section <code>8.5.1</code> <em>Aggregates</em> (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_27118535_27118551_0\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), <strong>no brace-or-equal initializers for non-static\n  data members</strong> (9.2), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>and in <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"noreferrer\">C++14</a> the same paragraph reads:</p>\n<blockquote>\n<p id=\"so_27118535_27118551_1\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>This change is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html\" rel=\"noreferrer\">N3605: Member initializers and aggregates</a> which has the following abstract:</p>\n<blockquote>\n<p id=\"so_27118535_27118551_2\">Bjarne Stroustrup and Richard Smith raised an issue about aggregate\n  initialization and member-initializers not working together. This\n  paper <strong>proposes to fix the issue by adopting Smith's proposed wording\n  that removes a restriction that aggregates can't have\n  member-initializers</strong>.</p>\n</blockquote>\n<p>This comment basically sums up the reluctance to allowing them to be aggregates:</p>\n<blockquote>\n<p id=\"so_27118535_27118551_3\">Aggregates cannot have user-defined constructors and\n  <strong>member-initializers are essentially some kind of user-defined\n  constructor (element)</strong> (see also Core Defect 886). I'm not against this\n  extension, but it also has implications on what our model of\n  aggregates actually is. After acceptance of this extension <strong>I would\n  like to know how to teach what an aggregate is.</strong></p>\n</blockquote>\n<p>The revised version <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html\" rel=\"noreferrer\">N3653</a> was adopted in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/\" rel=\"noreferrer\">May 2013</a>.</p>\n<p><b>Update</b></p>\n<p>emsr points out that <a href=\"https://gcc.gnu.org/gcc-5/changes.html\" rel=\"noreferrer\">G++ 5.0 now supports C++14 aggregates with non-static data member initializers</a> using either <code>std=c++1y</code> or <code>-std=c++14</code>:</p>\n<pre><code>struct A { int i, j = i; };\nA a = { 42 }; // a.j is also 42\n</code></pre>\n<p>See it working <a href=\"http://melpon.org/wandbox/permlink/oB5O8XE3DjHjOT2V\" rel=\"noreferrer\">live</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-12-15T03:26:40.320", "Id": "27118551", "Score": "36", "CreationDate": "2014-11-25T03:52:55.373", "LastActivityDate": "2014-12-15T03:26:40.320"}, "bq_ids": {"n4140": {"so_27118535_27118551_0": {"section_id": 3298, "quality": 0.6666666666666666, "length": 16}, "so_27118535_27118551_1": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_27118535_27118551_0": {"section_id": 3168, "quality": 0.7916666666666666, "length": 19}, "so_27118535_27118551_1": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_27118535_27118551_1": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}}}, "27118535": {"CommentCount": "0", "CreationDate": "2014-11-25T03:51:29.443", "PostTypeId": "1", "AcceptedAnswerId": "27118551", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-14T12:36:05.827", "LastEditDate": "2015-12-14T12:36:05.827", "ViewCount": "4461", "FavoriteCount": "5", "Title": "C++11 aggregate initialization for classes with non-static member initializers", "Id": "27118535", "Score": "28", "Body": "<p>Is it allowed in standard:</p>\n<pre><code>struct A\n{\n  int a = 3;\n  int b = 3;\n};\n\nA a{0,1}; // ???\n</code></pre>\n<p>Is this class still aggregate?\n<code>clang</code> accepts this code, but <code>gcc</code> doesn't.</p>\n", "Tags": "<c++><c++11><gcc><c++14><aggregate-initialization>", "OwnerUserId": "3120079", "AnswerCount": "1"}});