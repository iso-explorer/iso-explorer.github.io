post_cb({"34311475": {"Id": "34311475", "PostTypeId": "2", "Body": "<p>I agree with other answerers that it is a very bad idea to modify the standard library in place.</p>\n<p>The question is how to minimize changes to existing code when changing a collection member type from value-type to pointer-type. I can think of the following solutions:</p>\n<ol>\n<li>Change the iterator-type used by the container-type to some form of\nindirect iterator which automatically dereferences the pointer it\npoints to. This is basically what your modifications to std::vector\namount to.  A better way to do it, would be to derive a class from\nvector and change the type of iterators returned by <code>begin()</code>,\n<code>end()</code>, etc. Or even better (if some modification of existing code\nis allowed), add functions <code>ibegin()</code>, <code>iend()</code>, which return the\nnecessary indirect iterators. If even more modification is allowed,\nthen you should consider using something like the indirect iterator\ntransformers defined by Boost, per TartanLlama's answer. In the long run this is probably where you want to be.</li>\n<li>Change the pointer-type that you are planning to substitute for the\nvalue-type in the container. This is an uglier solution which\nrequires a certain amount of code duplication, but can function with\nno modifications to existing code. See my code below to make your\ngiven example work with no changes other than to remove use of\n_tchar.</li>\n</ol>\n<p>See below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt;\nclass pass_thru_ptr{\n  T* ptr;\npublic:\n  T&amp; operator*() { return *ptr; }\n  pass_thru_ptr&amp; operator=(T* p) { ptr = p; return *this; }\n  //  define other operators, such as:\n  //  pass_thru_ptr&amp; operator=(T p) { *ptr = p; return *this; }\n};\n\ntemplate&lt;class T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; out, pass_thru_ptr&lt;T&gt; p){\n  return out &lt;&lt; (*p);\n}\n\ntypedef struct udf {\n  static int auto_m; int _m;\n  udf(): _m(++auto_m) {}\n} * udf_ptr;\nint udf::auto_m = 0;\n\n// or template specialization?\nstruct pass_thru_udf_ptr : public pass_thru_ptr&lt;udf&gt; {\n  pass_thru_ptr&lt;int&gt; _m;\n  pass_thru_udf_ptr&amp; operator=(udf* p) { pass_thru_ptr&lt;udf&gt;::operator=(p); _m = &amp;(p-&gt;_m); return *this; }\n};\n\nint main(int argc, char* argv[]) {\n  using namespace std;\n  typedef vector&lt;pass_thru_udf_ptr&gt; udf_p_v;\n  typedef vector&lt;udf&gt; udf_v;\n  udf_v s(1); udf_p_v p(1);\n  p[0] = &amp;s[0];\n  udf_v::iterator s_i(s.begin()); udf_p_v::iterator p_i(p.begin());\n\n  // Now, the indirection on p_i is not needed\n  // in order to access the member data _m:\n      cout\n        &lt;&lt; \"s_i: \" &lt;&lt; s_i-&gt;_m &lt;&lt; endl\n        &lt;&lt; \"p_i: \" &lt;&lt; p_i-&gt;_m &lt;&lt; endl;\n\n      return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-12-16T11:59:19.707", "CommentCount": "0", "CreationDate": "2015-12-16T11:59:19.707", "ParentId": "34307129", "Score": "0", "OwnerUserId": "5600363"}, "34307300": {"Id": "34307300", "PostTypeId": "2", "Body": "<p>You don't need to write any code for this--Boost already has it!  See here: <a href=\"http://www.boost.org/doc/libs/1_59_0/libs/ptr_container/doc/tutorial.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_59_0/libs/ptr_container/doc/tutorial.html</a></p>\n<p>Their example:</p>\n<pre><code>typedef boost::ptr_vector&lt;animal&gt;  ptr_vec;\nptr_vec vec;\nptr_vec::iterator i = vec.begin();\ni-&gt;eat(); // no indirection needed\n</code></pre>\n", "LastActivityDate": "2015-12-16T08:39:22.110", "CommentCount": "3", "CreationDate": "2015-12-16T08:39:22.110", "ParentId": "34307129", "Score": "3", "OwnerUserId": "4323"}, "34307533": {"Id": "34307533", "PostTypeId": "2", "Body": "<ol>\n<li><p>I don't think that this is a good idea. The standard library is standard for a reason and people expect it to function in a standard way. Breaking that expectation can be dangerous. I would say making your own iterators or container classes, or using ones provided by other libraries is a far superior solution.</p></li>\n<li><p>I imagine that doing this may break some of the standard algorithms. </p></li>\n</ol>\n<p>Another Boost-provided solution to this problem is <a href=\"http://www.boost.org/doc/libs/1_59_0/libs/iterator/doc/indirect_iterator.html\" rel=\"nofollow noreferrer\"><code>boost::indirect_iterator</code></a>. Here's what the code <a href=\"https://stackoverflow.com/a/34307300/496161\">John Zwinck</a> posted would look like:</p>\n<pre><code>std::vector&lt;animal*&gt; vec;\nvec.push_back(new animal{});\nauto i = boost::make_indirect_iterator(std::begin(vec));\ni-&gt;eat(); // no indirection needed\n</code></pre>\n<p>This would even work for <code>std::vector&lt;std::unique_ptr&lt;animal&gt;&gt;</code>, which can be very handy if you want to iterate over a member container and hide the fact that you are storing <code>std::unique_ptr</code>s.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-16T08:55:56.067", "Score": "1", "CreationDate": "2015-12-16T08:52:52.893", "ParentId": "34307129", "CommentCount": "8", "OwnerUserId": "496161", "LastEditDate": "2017-05-23T12:30:56.943"}, "bq_ids": {"n4140": {"so_34307129_34311044_10": {"length": 7, "quality": 1.0, "section_id": 6300}, "so_34307129_34311044_11": {"length": 9, "quality": 1.0, "section_id": 6300}, "so_34307129_34311044_8": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}, "so_34307129_34311044_5": {"length": 9, "quality": 1.0, "section_id": 6300}, "so_34307129_34311044_6": {"length": 10, "quality": 1.0, "section_id": 6300}, "so_34307129_34311044_4": {"length": 7, "quality": 1.0, "section_id": 6300}, "so_34307129_34311044_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}, "so_34307129_34311044_12": {"length": 10, "quality": 1.0, "section_id": 6300}}, "n3337": {"so_34307129_34311044_10": {"length": 7, "quality": 1.0, "section_id": 6057}, "so_34307129_34311044_11": {"length": 9, "quality": 1.0, "section_id": 6057}, "so_34307129_34311044_8": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}, "so_34307129_34311044_6": {"length": 10, "quality": 1.0, "section_id": 6057}, "so_34307129_34311044_5": {"length": 9, "quality": 1.0, "section_id": 6057}, "so_34307129_34311044_4": {"length": 7, "quality": 1.0, "section_id": 6057}, "so_34307129_34311044_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}, "so_34307129_34311044_12": {"length": 10, "quality": 1.0, "section_id": 6057}}, "n4659": {"so_34307129_34311044_10": {"length": 7, "quality": 1.0, "section_id": 7809}, "so_34307129_34311044_11": {"length": 9, "quality": 1.0, "section_id": 7809}, "so_34307129_34311044_8": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}, "so_34307129_34311044_6": {"length": 10, "quality": 1.0, "section_id": 7809}, "so_34307129_34311044_5": {"length": 9, "quality": 1.0, "section_id": 7809}, "so_34307129_34311044_4": {"length": 7, "quality": 1.0, "section_id": 7809}, "so_34307129_34311044_2": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}, "so_34307129_34311044_12": {"length": 10, "quality": 1.0, "section_id": 7809}}}, "34309402": {"Id": "34309402", "PostTypeId": "2", "Body": "<p>The C++ standard defines the semantics of <code>std::vector&lt;T&gt;</code> and its iterator. It specifies what the types of the various types involved in <code>std::vector&lt;T&gt;</code>'s iterators are. Changing the implementation would break standard compliance.</p>\n<p>There is another twist anyway: while <code>T*</code> is the obvious pointer type, it isn't uncommon that the <code>std::vector&lt;T&gt;</code> actually contains a sequence of smart pointers, e.g., <code>std::unique_ptr&lt;T&gt;</code>. Similar, what applies to <code>std::vector&lt;T&gt;</code> also applies to <code>std::deque&lt;T&gt;</code>, <code>std::list&lt;T&gt;</code>, etc.</p>\n<p>Although the logic could be folded into the implementation of the various containers, it is actually simpler and generally more flexible (as other customization may be desirable) to rather use a suitable iterator adaptor and suitable functions to obtain these.</p>\n<p>The first step towards the pointer generality is to detect smart pointers. That's easily done with a simple trait:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_pointer_like_test {\n    template &lt;typename S, typename = decltype(std::declval&lt;S&gt;().operator-&gt;())&gt;\n    static std::true_type  test(S*);\n    template &lt;typename S&gt;\n    static std::true_type  test(S**);\n    static std::false_type test(void*);\n};\n\ntemplate &lt;typename T&gt;\nstruct is_pointer_like\n    : decltype(is_pointer_like_test&lt;T&gt;::test(static_cast&lt;T*&gt;(0))) {\n};\n</code></pre>\n<p>This traits considers raw pointers and anything overloading <code>operator-&gt;()</code> to be pointer types and everything else to be non-pointer types. There are probably a few variations on the same theme which are more clever.</p>\n<p>Since the type and access to pointers is different to values but both variations need to compile in an iterator adaptor (unless the iterator adaptor is specialized), it is convenient to abstract out the differences:</p>\n<pre><code>template &lt;typename T, bool = is_pointer_like&lt;T&gt;::value&gt;\nstruct pointer_helper {\n    using type = T;\n    template &lt;typename S&gt;\n    static S value(S&amp;&amp; arg) { return std::forward&lt;S&gt;(arg); }\n};\ntemplate &lt;typename T&gt;\nstruct pointer_helper&lt;T, true&gt; {\n    using type = typename std::decay&lt;decltype(*std::declval&lt;T&gt;())&gt;::type;\n    template &lt;typename S&gt;\n    static auto value(S&amp;&amp; arg) -&gt; decltype(*arg) { return *arg; }\n};\n</code></pre>\n<p>The idea is to get the pointee type for a pointer but stay with the type itself it isn't a pointer. Likewise, pointers get dereferenced to access a value while non-pointers don't. This is done relatively quickly and I guess it can be improved.</p>\n<p>The next step is to put these building blocks together to create a pointer adaptor and a few factory functions:</p>\n<pre><code>template &lt;typename Iterator&gt;\nclass ptr_iterator {\n    Iterator it;\n    using original_value = typename std::iterator_traits&lt;Iterator&gt;::value_type;\n\npublic:\n    using iterator_category = typename std::iterator_traits&lt;Iterator&gt;::iterator_category;\n    using difference_type = typename std::iterator_traits&lt;Iterator&gt;::difference_type;\n    using value_type = typename pointer_helper&lt;original_value&gt;::type;\n    using reference  = typename std::add_lvalue_reference&lt;value_type&gt;::type;\n    using pointer    = typename std::add_pointer&lt;value_type&gt;::type;\n\n    explicit ptr_iterator(Iterator it): it(it) {}\n    bool operator==(ptr_iterator const&amp; other) const { return this-&gt;it == other.it; }\n    bool operator!=(ptr_iterator const&amp; other) const { return !(*this == other); }\n    ptr_iterator&amp; operator++() { ++this-&gt;it; return *this; }\n    ptr_iterator  operator++(int) { ptr_iterator rc(*this); ++this-&gt;it; return rc; }\n\n    reference operator*() { return pointer_helper&lt;original_value&gt;::value(*it); }\n    pointer   operator-&gt;() { return &amp;**this; }\n    // other iterator operations\n};\n\ntemplate &lt;typename Cont&gt;\nauto ptr_begin(Cont&amp;&amp; cont) -&gt; ptr_iterator&lt;decltype(cont.begin())&gt; {\n    return ptr_iterator&lt;decltype(cont.begin())&gt;(cont.begin());\n}\n\ntemplate &lt;typename Cont&gt;\nauto ptr_end(Cont&amp;&amp; cont) -&gt; ptr_iterator&lt;decltype(cont.end())&gt; {\n    return ptr_iterator&lt;decltype(cont.begin())&gt;(cont.end());\n}\n</code></pre>\n<p>I think the above should be a viable forward iterator but it is, obviously, missing the various operations to turn it into a bidirectional or a random access iterator. As with the <code>pointer_helper</code> this adaptor is done to demonstrate roughly how it could look like rather than being a solid, tested solution.</p>\n<p>With these in place (and assuming a suitable set of standard header includes) it should be possible to treat containers of [smart] pointers and values the same, e.g.:</p>\n<pre><code>struct foo {\n    int value;\n    foo(int value): value(value) {}\n    void bar() { std::cout &lt;&lt; \"foo(\" &lt;&lt; value &lt;&lt; \")\\n\"; }\n};\n\ntemplate &lt;typename Cont&gt;\nvoid print(Cont&amp;&amp; cont) {\n    for (auto it = ptr_begin(cont), end = ptr_end(cont); it != end; ++it) {\n        it-&gt;bar();\n    }\n}\n\nint main()\n{\n    std::vector&lt;foo&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    print(v);\n\n    std::vector&lt;foo*&gt; p;\n    p.push_back(&amp;v[2]);\n    p.push_back(&amp;v[1]);\n    p.push_back(&amp;v[0]);\n    print(p);\n\n    std::vector&lt;std::unique_ptr&lt;foo&gt; &gt; s;\n    s.push_back(std::unique_ptr&lt;foo&gt;(new foo(4)));\n    s.push_back(std::unique_ptr&lt;foo&gt;(new foo(5)));\n    s.push_back(std::unique_ptr&lt;foo&gt;(new foo(6)));\n    print(s);\n}\n</code></pre>\n<p>The code isn't particularly well-tested beyond getting the use-case two work.</p>\n", "LastActivityDate": "2015-12-16T10:22:15.920", "CommentCount": "0", "CreationDate": "2015-12-16T10:22:15.920", "ParentId": "34307129", "Score": "1", "OwnerUserId": "1120273"}, "34311044": {"Id": "34311044", "PostTypeId": "2", "Body": "<p>There are some great answers here, but I feel something in your question and proposed solution have not been addressed.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_0\">Please quote the standard</p>\n</blockquote>\n<p>Sure, by all means (emphasis mine)</p>\n<blockquote>\n<blockquote>\n<p id=\"so_34307129_34311044_7\">17.6.4.2.1 Namespace std [namespace.std]</p>\n<p id=\"so_34307129_34311044_8\">The behavior of a C++ program is <strong>undefined if it adds declarations or definitions to namespace std</strong> or to a namespace within namespace std unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n<p id=\"so_34307129_34311044_9\">2 The behavior of a C++ program is undefined if it declares</p>\n<p id=\"so_34307129_34311044_10\">(2.1) \u2014 an explicit specialization of any member function of a standard library class template, or</p>\n<p id=\"so_34307129_34311044_11\">(2.2) \u2014 an explicit specialization of any member function template of a standard library class or class template,\n    or</p>\n<p id=\"so_34307129_34311044_12\">(2.3) \u2014 an explicit or partial specialization of any member class template of a standard library class or class template.</p>\n</blockquote>\n</blockquote>\n<p>There is more, the link is <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">here</a> (page 459)</p>\n<p>I think clauses 2.2 and 2.3 cover this nicely.</p>\n<p>None of this is personal - it's meant to be read in a humorous way. However, the message is incredibly serious.</p>\n<p>In case any young developers have the same idea...</p>\n<blockquote>\n<p id=\"so_34307129_34311044_13\">I've just inserted the following extension into <code>&lt;utility&gt;</code>.</p>\n</blockquote>\n<p>Congratulations, <strike>you just broke c++</strike> invented a new language which looks a lot like c++ but has some subtle, undocumented differences and is not backed by an international standard. Let's call it Aleksey++ :-)</p>\n<p>In C++, the only thing you may do in the <code>std::</code> namespace is specialise templates for your own user-defined types. You may not add, remove or modify any of the concepts therein. You may not do that by modifying the standard library's files. They should be read-only!</p>\n<blockquote>\n<p id=\"so_34307129_34311044_14\">I've replaced the original implementation of the member selection <code>operator -&gt;</code> in <code>&lt;vector&gt;</code> for <code>_Vector_const_iterator</code> and <code>_Vector_iterator</code> by my extended implementation</p>\n</blockquote>\n<p>What you did was broke your installation of c++ (see above). You are a very naughty boy.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_15\">Yes, replacing the original implementation of STL templates is a bad thing if the code should be compiled by someone else. </p>\n</blockquote>\n<p>It's a truly evil thing you have done.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_16\">It could be solved by providing the extended versions of <code>&lt;utility&gt;</code> and <code>&lt;vector&gt;</code>, if the copyright owner or license allows that. </p>\n</blockquote>\n<p>The c++ standard itself does not allow that.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_17\">Otherwise it will be impossible to distribute such software.</p>\n</blockquote>\n<p>It will always be impossible to distribute such software, at least in source code form.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_18\">So, is it correct to extend the original implementation of the member selection operator on a pointer in the described way? </p>\n</blockquote>\n<p>No, no and thrice no!</p>\n<blockquote>\n<p id=\"so_34307129_34311044_19\">In case of in-house software, it is probably correct. </p>\n</blockquote>\n<p>No, it's absolutely incorrect. What if someone else in-house wants to write another standards-conforming program, you know, like the ones everyone else always writes? You've broken their compiler!</p>\n<blockquote>\n<p id=\"so_34307129_34311044_20\">And it is not, if the source code should be open or used by someone who cannot get these extended versions. What are such cases? Are there other cases?</p>\n</blockquote>\n<p>Simply write your software according to the standard and other people will not have to destroy their compiler installations. If your code relies on 'non standard extensions' to the standard library, no-one will ever touch it with a barge pole.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_21\">Are there cases when the proposed extended implementation will not function? </p>\n</blockquote>\n<p>Every time you upgrade your compiler suite, move to another machine, get a new version of the standard library, share your software. In 5 years time when you have left the company and some poor fellow is trying to maintain your software, he will think very bad thoughts about you.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_22\">what do you mean? All the code of all in-house projects is compiled successfully</p>\n</blockquote>\n<p>They may well compile in-house at the moment, but they're not being compiled with standards-compliant c++. This makes them non-portable and fragile. For example, if one of your colleagues upgrades his compiler to a later version, the code will no longer compile.</p>\n<p>If he then comes on here and asks \"why doesn't this code compile?\" we'll all plug his code into our compilers and conclude that the code is written wrongly. He will then protest, saying that it always worked before - that maybe his compiler is broken. We'll all be mystified. A bug report will be filed. The compiler vendor will (eventually) reply that the compiler is fine, the code is in error.</p>\n<p>At this point your colleague will realise that it wasn't his toolset at all. It was the fact that the code is written in Aleksey++ and not C++ after all.</p>\n<p>He will not be happy with you...</p>\n<blockquote>\n<p id=\"so_34307129_34311044_23\">insert other protestation here</p>\n</blockquote>\n<p>The whole point of the standard library is that it is, well... standard. If you want to make a library that looks a lot like the standard library, but is different in parts, you should put it in a new namespace, like <code>namespace aleksey { }</code>. </p>\n<p>The <code>std</code> namespace is absolutely reserved for the standard library and it should conform exactly to the standard (which is published, amongst other places, <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\" title=\"here\">here</a>).    </p>\n<p>Extensions are by definition, not standard and therefore should not be in the <code>std</code> namespace. </p>\n<p>This namespace has a very intimate relationship with the compiler. You can prove this by using <code>typeid</code> without including the standard header <code>type_info</code>. On clang you'll get a warning. This is because the <em>standard says</em> that in order to use <code>typeid</code> <em>you must</em> include <code>&lt;type_info&gt;</code> first. Not to do so makes the program <em>ill formed</em> and it's behaviour will thereafter be <em>undefined</em>. </p>\n<p>These terms are in italics because they refer to specific meanings in the standard.</p>\n<blockquote>\n<p id=\"so_34307129_34311044_24\">OK, how do we move forward?</p>\n</blockquote>\n<p>Define the functionality you want in a new namespace. Who knows, it might be so awesome that we'll all want to use it all the time. The very well known library <code>boost</code> is like this. Many features in boost went on to be included in <em>the standard</em> because after being used by millions of developers in millions of projects, they were proven to be awesome.</p>\n<p>Some of those features are: (non-exhaustive list)</p>\n<pre><code>boost::shared_ptr&lt;&gt; -&gt; adopted as std::shared_ptr\nboost::thread -&gt; adopted as std::thread\nboost::hash -&gt; adopted (in part) as std::hash\nboost::unordered_map -&gt; std::...\nboost::unordered_set -&gt; std::...\nboost::lambda -&gt; incorportated directly into the language\nboost::move -&gt; incorportated directly into the language\n</code></pre>\n<p>The list is long and continues to grow.</p>\n", "LastEditorUserId": "1016716", "LastActivityDate": "2015-12-21T17:47:38.517", "Score": "2", "CreationDate": "2015-12-16T11:37:59.317", "ParentId": "34307129", "CommentCount": "11", "OwnerUserId": "2015579", "LastEditDate": "2015-12-21T17:47:38.517"}, "34307129": {"ViewCount": "110", "Body": "<h3>Problem</h3>\n<p>If <code>value_type</code> is a pointer type, then the member selection operator <code>-&gt;</code> of an iterator is useless because the indirection is required to access a member: <code>(*_It)-&gt;member</code>. And if there is code doing something like <code>_It-&gt;method()</code>, changing the type of contained items to a pointer type becomes trouble.</p>\n<p>This is because the original implementation of the member selection operator <code>-&gt;</code> is:<br/></p>\n<pre><code>// return pointer to class object\npointer operator-&gt;() const { return (&amp;**this); }\n</code></pre>\n<h3>Proposed solution</h3>\n<p>If <code>value_type</code> is a pointer type, the member selection operator should return <code>reference</code> instead of <code>pointer</code>.</p>\n<p>Elaborated implementation:<br>\nI've just inserted the followning extension into <code>&lt;utility&gt;</code>.</br></p>\n<pre><code>template&lt;typename val, typename ref, typename ptr&gt;\nstruct ref_or_ptr {\n    // To know if value_type is a pointer\n    enum {RES=false};\n    // By default, operator -&gt; should return a pointer\n    typedef ptr res; // return pointer\n    // The translation function sould be used to return proper type\n    // in both the cases, otherwise the complier results in the conversion error.\n    static res get(ref v) { return &amp;v; }\n};\n\n// Specialization for the case when value_type is a pointer\ntemplate&lt;typename val, typename ref, typename ptr&gt;\nstruct ref_or_ptr&lt;val *, ref, ptr&gt; {\n    enum {RES=true}; // value_type is a pointer type\n    typedef ref res; // return reference\n    // In this case, the reference is returned instead of the pointer.\n    // But here value_type is a pointer type, and the address-of operator is not needed:\n    static res get(ref v) { return v; }\n};\n</code></pre>\n<p>I've replaced the original implementation of the member selection operator <code>-&gt;</code> in <code>&lt;vector&gt;</code> for <code>_Vector_const_iterator</code> and <code>_Vector_iterator</code> by my extended implementation:<br/></p>\n<pre><code>typename ref_or_ptr&lt;value_type, reference, pointer&gt;::res\noperator-&gt;() const {\n    return (ref_or_ptr&lt;value_type, reference, pointer&gt;::get(**this));\n}\n</code></pre>\n<p>And now, the following became possible, preserving the original behavior of the member selection operator:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntypedef struct udf {\n    static int auto_m; int _m;\n    udf(): _m(++auto_m) {}\n} * udf_ptr;\nint udf::auto_m = 0;\n\nint _tmain(int argc, _TCHAR* argv[]) {\n    using namespace std;\n    typedef vector&lt;udf_ptr&gt; udf_p_v;\n    typedef vector&lt;udf&gt; udf_v;\n    udf_v s(1); udf_p_v p(1);\n    p[0] = &amp;s[0];\n    udf_v::iterator s_i(s.begin()); udf_p_v::iterator p_i(p.begin());\n\n    // Now, the indirection on p_i is not needed\n    // in order to access the member data _m:\n    cout\n        &lt;&lt; \"s_i: \" &lt;&lt; s_i-&gt;_m &lt;&lt; endl\n        &lt;&lt; \"p_i: \" &lt;&lt; p_i-&gt;_m &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<h3>Output:</h3>\n<pre><code>s_i: 1\np_i: 1\n</code></pre>\n<h2>Two questions</h2>\n<p>Yes, replacing the original implementation of STL templates is a bad thing if the code should be compiled by someone else. It could be solved by providing the extended versions of <code>&lt;utility&gt;</code> and <code>&lt;vector&gt;</code>, if the copyright owner or license allows that. Otherwise it will be impossible to distribute such software.</p>\n<ol>\n<li><p>So, is it correct to extend the original implementation of the member selection operator on a pointer in the described way? In case of in-house software, it is probably correct. And it is not, if the source code should be open or used by someone who cannot get these extended versions. What are such cases? Are there other cases?</p></li>\n<li><p>Are there cases when the proposed extended implementation will not function?</p></li>\n</ol>\n", "Title": "Is it correct to extend the implementation of the member selection operator `->` of iterators on std::vector?", "CreationDate": "2015-12-16T08:29:06.963", "LastActivityDate": "2015-12-21T17:47:38.517", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "Id": "34307129", "Score": "3", "OwnerUserId": "2527301", "Tags": "<c++><pointers><iterator><operators><stdvector>", "AnswerCount": "5"}});