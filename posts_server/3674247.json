post_cb({"3674759": {"ParentId": "3674247", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>\u00a723.3.1:</p>\n<blockquote>\n<p id=\"so_3674247_3674759_0\">An array is an aggregate (8.5.1) that can be initialized with the syntax <code>array a&lt;T, N&gt; = { initializer-list };</code>\n  where initializer-list is a comma separated list of up to N elements whose types are convertible to T.</p>\n</blockquote>\n<p>In C++03, POD was defined in terms of aggregate: a class where every subobject is native or an aggregate is POD. So, by backwards compatibility, a C++0x <code>std::array</code> is POD.</p>\n<p>Or, to be anal, one can compare the bullet-points of \u00a79/5 (defining trivial class) 9/6 (defining standard-layout) and 9/9 (combining preceding requirements into POD) with those of 8.5.1/1, which defines aggregates.</p>\n<p>8.5.1:</p>\n<blockquote>\n<p id=\"so_3674247_3674759_1\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal- initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Indeed the requirements in Clause 9 cover <code>array</code> as long as its element type is also POD and the implementation does not declare <code>operator=</code> or <code>move</code> inside <code>array</code> in addition to the specifications.</p>\n<p>To be <em>really</em> anal, 17.5.2.2 says</p>\n<blockquote id=\"so_3674247_3674759_2\">\n<ol>\n<li>For the sake of exposition, Clauses 18 through 30 and Annex D do not describe copy/move constructors, assignment operators, or (non-virtual) destructors with the same apparent semantics as those that can be generated by default (12.1, 12.4, 12.8).</li>\n<li>It is unspecified whether the implementation provides explicit definitions for such member function signa- tures, or for virtual destructors that can be generated by default.</li>\n</ol>\n</blockquote>\n<p>The note in the pseudo-code for <code>template class array</code> is</p>\n<blockquote>\n<p id=\"so_3674247_3674759_3\"><code>// No explicit construct/copy/destroy for aggregate type</code></p>\n</blockquote>\n<p>Does <code>construct/copy/destroy</code> include <code>operator=</code> (assignment) or <code>move</code>? It probably should, but I don't think, by the strictest reading, it does.</p>\n<p>Note that this \"affects\" not only POD-ness, but also trivial copyability as Johannes mentions.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-09-09T21:34:08.190", "Id": "3674759", "Score": "9", "CreationDate": "2010-09-09T08:02:04.083", "LastActivityDate": "2010-09-09T21:34:08.190"}, "3679872": {"CommentCount": "2", "CreationDate": "2010-09-09T19:26:00.037", "CommunityOwnedDate": "2010-09-09T21:46:22.227", "LastEditorUserId": "34509", "LastActivityDate": "2010-09-09T21:46:22.227", "ParentId": "3674247", "PostTypeId": "2", "LastEditDate": "2010-09-09T21:46:22.227", "Id": "3679872", "Score": "1", "Body": "<p>Potatoswatter found an error in my conclusions. C++ explicitly allows an implementation to explicitly define an assignment operator \"with the same apparent semantics\". This will make it a non-trivially copyable type. Making it community wiki...</p>\n<hr>\n<p><strike>\nIt seems to me you don't want to test against PODnes, but against <em>trivially copyable</em>, which is way less restricting. Because that is how C++0x constraints types that can be used with <code>memcpy</code> and friends. </strike></p>\n<p></p></hr>And while I don't think there are any guarantees about PODness of <code>std::array</code><strike>, there <em>are</em> guarantees about trivial copyability, as the following shows (if I haven't got an error in the conclusions). As we know <code>std::array</code> is an aggregate, and aggregates are</strike>\n<blockquote>\n<p id=\"so_3674247_3679872_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-\n  initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11),\n  no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>While trivially copyability is defined for a class that has class that</p>\n<blockquote id=\"so_3674247_3679872_1\">\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n</blockquote>\n<p><code>std::array</code> has no destructor (as a comment in the definition of <code>std::array</code> says). This does not seem to follow from the definition of aggregate classes though, even though the comment in <code>std::array</code>'s class definition claims that. </p>\n<p>The remaining 4 requirements follow from the absence of bases, virtual functions and user provided versions for those 4 special member functions for aggregates. </p>\n", "OwnerUserId": "34509"}, "3674414": {"ParentId": "3674247", "CommentCount": "0", "Body": "<p>By definition of POD:</p>\n<blockquote>\n<p id=\"so_3674247_3674414_0\"><strong>9 Classes</strong></p>\n<p id=\"so_3674247_3674414_1\"><strong>9</strong> A POD struct is a class that is both a <em>trivial class</em> and a <em>standard-layout class</em>, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>[Emphasis mine]</p>\n<p><code>std::array</code> does satisfy all the requirements of being a trivial, standard-layout class template. So the answer to your question is yes.</p>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "3674414", "Score": "6", "CreationDate": "2010-09-09T06:58:45.757", "LastActivityDate": "2010-09-09T06:58:45.757"}, "bq_ids": {"n4140": {"so_3674247_3674759_1": {"section_id": 3298, "quality": 0.6666666666666666, "length": 16}, "so_3674247_3679872_0": {"section_id": 3298, "quality": 0.6666666666666666, "length": 16}, "so_3674247_3674414_1": {"section_id": 5854, "quality": 0.9148936170212766, "length": 43}, "so_3674247_3679872_1": {"section_id": 5850, "quality": 0.6956521739130435, "length": 16}, "so_3674247_3674759_0": {"section_id": 775, "quality": 0.6470588235294118, "length": 11}}, "n3337": {"so_3674247_3679872_0": {"section_id": 3168, "quality": 0.7916666666666666, "length": 19}, "so_3674247_3674759_1": {"section_id": 3168, "quality": 0.7916666666666666, "length": 19}, "so_3674247_3674414_1": {"section_id": 5624, "quality": 0.9361702127659575, "length": 44}, "so_3674247_3679872_1": {"section_id": 5620, "quality": 0.6956521739130435, "length": 16}, "so_3674247_3674759_0": {"section_id": 762, "quality": 0.6470588235294118, "length": 11}}, "n4659": {"so_3674247_3674414_1": {"section_id": 7333, "quality": 0.9148936170212766, "length": 43}, "so_3674247_3674759_2": {"section_id": 7748, "quality": 0.8461538461538461, "length": 33}}}, "3674247": {"CommentCount": "0", "ViewCount": "3133", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2010-09-09T06:21:48.063", "LastActivityDate": "2011-08-24T22:53:17.630", "Title": "Is std::array<T, S> guaranteed to be POD if T is POD?", "AcceptedAnswerId": "3674759", "LastEditDate": "2011-08-24T22:53:17.630", "Id": "3674247", "Score": "14", "Body": "<p>I'm currently writing a C++ memory editing library and for the read/write APIs I use type traits (std::is_pod, std::is_same) and boost::enable_if to provide 3 overloads:</p>\n<ol>\n<li>POD types. e.g. MyMem.Read(SomeAddress);</li>\n<li>String types. e.g. MyMem.Read&gt;(SomeAddress); (This doesn't actually read out a C++ string, it reads out a C-style string and converts it to a C++ string.)</li>\n<li>Vector types. e.g. MyMem.Read&gt;(SomeAddress, NumElem); (This doesn't actually read out a vector, rather it reads out a C-style array and converts it to a vector.)</li>\n</ol>\n<p>Overloads 2 and 3 are simply 'wrappers' around overload 1. (So if you're reading a std::vector or std::basic_string and T is not POD it will fail, as it should.)</p>\n<p>Recently I wanted to use std::array for a bunch of reads and writes because I knew the size of the data I wanted to read and write at compile time (I was writing a wrapper around the PE file format).</p>\n<p>I wrote the code to use std::array, and then intended to add another overload for detection and handling of std::array types, but I accidentally hit compile and to my surprise it worked!</p>\n<p>I'm currently using MSVC 10 and it turns out that for std::array if T is POD then std::array is POD. (Which means I can just use overload 1 and it works.)</p>\n<p>My question is whether this is guaranteed by the C++ standard or left up to the implementation.</p>\n<p>I know I could check the standard myself, but I don't trust myself as much as I trust some of the language lawyers on this site, so I figured it would be best to get a 'second opinion'. ;)</p>\n<p>Thanks</p>\n<p>P.S. Code available here (it's a header-only lib):\n<a href=\"http://code.google.com/p/hadesmem/source/browse/trunk/HadesMem-v2/Hades-Memory/Hades-Memory/MemoryMgr.h#86\" rel=\"noreferrer\">http://code.google.com/p/hadesmem/source/browse/trunk/HadesMem-v2/Hades-Memory/Hades-Memory/MemoryMgr.h#86</a></p>\n", "Tags": "<c++><templates><stl><tr1><c++11>", "OwnerUserId": "75002", "AnswerCount": "3"}});