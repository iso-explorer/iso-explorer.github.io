post_cb({"38703073": {"ParentId": "38702943", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>You can use <code>std::fill</code> to fill the string with trash:</p>\n<pre><code>std::fill(str.begin(),str.end(), 0);\n</code></pre>\n<p>Do note that simply clearing or shrinking the string (with methods such <code>clear</code> or <code>shrink_to_fit</code>) does not guarantee that the string data will be deleted from the process memory. Malicious processes may dump the process memory and can extract the secret if the string is not overwritten correctly.</p>\n<p>Bonus: Interestingly, the ability to trash the string data for security reasons forces some programming languages like Java to return passwords as <code>char[]</code> and not <code>String</code>. In Java, <code>String</code> is immutable, so \"trashing\" it will make a new copy of the string. Hence, you need a modifiable object like <code>char[]</code> which does not use copy-on-write. </p>\n<p>Edit: if your compiler <strong>does</strong> optimize this call out, you can use specific compiler flags to make sure a trashing function will not be optimized out:</p>\n<pre><code>#ifdef WIN32\n\n#pragma optimize(\"\",off)\nvoid trashString(std::string&amp; str){\n   std::fill(str.begin(),str.end(),0);\n}\n#pragma optimize(\"\",on)\n\n#endif\n\n#ifdef __GCC__\n\nvoid __attribute__((optimize(\"O0\"))) trashString(std::string&amp; str) {\n       std::fill(str.begin(),str.end(),0);\n}\n\n\n#endif\n\n#ifdef __clang__\n\nvoid __attribute__ ((optnone))  trashString(std::string&amp; str) {\n       std::fill(str.begin(),str.end(),0);\n}\n\n#endif\n</code></pre>\n", "OwnerUserId": "3613500", "LastEditorUserId": "3613500", "LastEditDate": "2016-08-01T16:16:31.043", "Id": "38703073", "Score": "11", "CreationDate": "2016-08-01T15:48:14.317", "LastActivityDate": "2016-08-01T16:16:31.043"}, "38705138": {"ParentId": "38702943", "CommentCount": "8", "Body": "<p>There's a better answer: <strong>don't</strong>!</p>\n<p><code>std::string</code> is a class which is designed to be userfriendly and efficient.  It was not designed with cryptography in mind, so there are few guarantees written into it to help you out.  For example, there's no guarantees that your data hasn't been copied elsewhere.  At best, you could hope that a particular compiler's implementation offers you the behavior you want.</p>\n<p>If you actually want to treat a secret as a secret, you should handle it using tools which are designed for handling secrets.  In fact, you should develop a threat model for what capabilities your attacker has, and choose your tools accordingly.</p>\n", "OwnerUserId": "2728148", "PostTypeId": "2", "Id": "38705138", "Score": "5", "CreationDate": "2016-08-01T17:50:55.700", "LastActivityDate": "2016-08-01T17:50:55.700"}, "38703373": {"ParentId": "38702943", "CommentCount": "18", "Body": "<p>std::string is a poor choice to store secrets. Since strings are copyable and sometimes copies go unnoticed, your secret may \"get legs\". Furthermore, string expansion techniques may cause multiple copies of fragments (or all of) your secrets. </p>\n<p>Experience dictates a movable, non-copyable, wiped clean on destroy, unintelligent (no tricky copies under-the-hood) class. </p>\n", "OwnerUserId": "1212565", "PostTypeId": "2", "Id": "38703373", "Score": "13", "CreationDate": "2016-08-01T16:05:31.847", "LastActivityDate": "2016-08-01T16:05:31.847"}, "38703454": {"ParentId": "38702943", "CommentCount": "7", "Body": "<p>It is probably safe. But not guaranteed.</p>\n<p>However, since <code>C++11</code>, a <code>std::string</code> must be implemented as contiguous data so you can safely access its internal array using the address of its first element <code>&amp;secretString[0]</code>.</p>\n<pre><code>if(!secretString.empty()) // avoid UB\n{\n    char* modifiable = &amp;secretString[0];\n    OpenSSL_cleanse(modifiable, secretString.size());\n}\n</code></pre>\n", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "38703454", "Score": "17", "CreationDate": "2016-08-01T16:10:25.673", "LastActivityDate": "2016-08-01T16:10:25.673"}, "38703971": {"ParentId": "38702943", "CommentCount": "6", "Body": "<p>The standard explicitly says you must not write to the <code>const char*</code> returned by <code>data()</code>, so don't do that.</p>\n<p>There are perfectly safe ways to get a modifiable pointer instead:</p>\n<pre><code>if (secretString.size())\n  OpenSSL_cleanse(&amp;secretString.front(), secretString.size());\n</code></pre>\n<p>Or if the string might have been shrunk already and you want to ensure its entire capacity is wiped:</p>\n<pre><code>if (secretString.capacity()) {\n  secretString.resize(secretString.capacity());\n  OpenSSL_cleanse(&amp;secretString.front(), secretString.size());\n}\n</code></pre>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "38703971", "Score": "14", "CreationDate": "2016-08-01T16:41:19.293", "LastActivityDate": "2016-08-01T16:41:19.293"}, "46768395": {"ParentId": "38702943", "CommentCount": "0", "Body": "<p>Tested solution on CentOS 6, Debian 8 and Ubuntu 16.04 (g++/clang++, O0, O1, O2, O3):</p>\n<pre><code>secretString.resize(secretString.capacity(), '\\0');\nOPENSSL_cleanse(&amp;secretString[0], secretString.size());\nsecretString.clear();\n</code></pre>\n", "OwnerUserId": "2682012", "PostTypeId": "2", "Id": "46768395", "Score": "0", "CreationDate": "2017-10-16T10:40:48.053", "LastActivityDate": "2017-10-16T10:40:48.053"}, "bq_ids": {"n4140": {"so_38702943_38702943_0": {"section_id": 6057, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_38702943_38702943_0": {"section_id": 5825, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_38702943_38702943_0": {"section_id": 7555, "quality": 0.8260869565217391, "length": 19}}}, "38702943": {"CommentCount": "7", "AcceptedAnswerId": "38703454", "PostTypeId": "1", "LastEditorUserId": "3657206", "CreationDate": "2016-08-01T15:41:55.073", "LastActivityDate": "2017-10-16T10:40:48.053", "LastEditDate": "2016-08-01T18:21:50.523", "ViewCount": "1565", "FavoriteCount": "3", "Title": "How to cleanse (overwrite with random bytes) std::string internal buffer?", "Id": "38702943", "Score": "25", "Body": "<p>Consider a scenario, where <code>std::string</code> is used to store <em>a secret</em>. Once it is consumed and is no longer needed, it would be good to cleanse it, i.e overwrite the memory that contained it, thus hiding the <em>secret</em>.</p>\n<p><code>std::string</code> provides a function <code>const char* data()</code> returning a pointer to (since C++11) continous memory. </p>\n<p>Now, since the memory is continous <strong>and</strong> the variable will be destroyed right after the cleanse due to scope end, would it be safe to:</p>\n<pre><code>char* modifiable = const_cast&lt;char*&gt;(secretString.data());\nOpenSSL_cleanse(modifiable, secretString.size());\n</code></pre>\n<p>According to standard quoted here:</p>\n<blockquote>\n<p id=\"so_38702943_38702943_0\">$5.2.11/7 - Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member resulting from a <code>const_cast</code> that casts away a <code>const-qualifier</code><sup>68</sup> may produce undefined behavior (7.1.5.1).</p>\n</blockquote>\n<p>That would advise otherwise, but do the conditions above (continuous, to-be-just-removed) make it safe?</p>\n", "Tags": "<c++><c++11><stdstring>", "OwnerUserId": "754407", "AnswerCount": "6"}});