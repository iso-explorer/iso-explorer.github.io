post_cb({"6939989": {"ViewCount": "6575", "Body": "<p>Many C++ programmers have suffered from the fierce clashes with the global C++ objects initialization/cleanup. Eventually I've found a good enough solution to this problem, I've been using (and anjoying) it for years now. My question is: does this solution fully comply to the C++ standard, or it's \"platform/implementation-dependent\"?</p>\n<p><strong>The problem</strong></p>\n<p>Generally-speaking there are two major problems with global objects:</p>\n<ul>\n<li>Unpredictable order of their construction/destruction. This bites if those objects depend on each other.</li>\n<li>The construction/destruction code is executed during the CRT initialization/cleanup <strong>outside</strong> the main program entry point. There's no way to wrap this code with <code>try</code>/<code>catch</code>, or perform any preliminary initialization.</li>\n</ul>\n<p>One way to overcome those issues is <strong>not</strong> using global objects at all. Instead one may use static/global <strong>pointers</strong> to those objects. During the program initialization those objects are either allocated dynamically or instantiated as automatic variables within the entry point function (<code>main</code>), and their pointers stored in those pointers. By such you have the full control over your \"global\" objects lifetime.</p>\n<p>However this method also has some drawbacks. It's related to the fact that not only the creation/destruction of those objects is different, but also their <strong>access</strong> is different. Normally a global object resides in the data section, which is allocated by the loader, and its virtual address is known at the build time. Using global pointers leads to the following drawbacks:</p>\n<ul>\n<li>Somewhat slower object access, extra pointer dereferencing. During the runtime instead of assuming the object is at the specified address the compiler generates the code that dereferences the global pointer.</li>\n<li>Weaker optimizations. The compiler may not realize that the pointer always points to the same object.</li>\n<li>If the actual objects are allocated on heap:</li>\n<li><ul>\n<li>Worse performance (heap allocations are \"heavy\")</li>\n</ul></li>\n<li><ul>\n<li>Memory fragmentation</li>\n</ul></li>\n<li><ul>\n<li>Chance of out-of-memory exception</li>\n</ul></li>\n<li>If the actual objects are allocated on stack (auto variables in <code>main</code>):</li>\n<li><ul>\n<li>Stack size is usually limited. In some circumstances its consumption by \"fat\" objects is suboptimal.</li>\n</ul></li>\n</ul>\n<p><strong>The solution</strong></p>\n<p>The solution I've found is to override the object's <code>new</code>/<code>delete</code> operatiors.</p>\n<pre><code>// class definition\nclass MyObject\n{\n    // some members\n    // ...\n\n    static char s_pMyPlaceholder[];\n\npublic:\n\n    // methods\n    // ...\n\n    static MyObject&amp; Instance()\n    {\n        return *(MyObject*) s_pMyPlaceholder;\n    }\n\n    void* operator new (size_t) { return s_pMyPlaceholder; }\n    void operator delete (void*) {}\n};\n\n// object placeholder instantiated\nchar MyObject::s_pMyPlaceholder[sizeof(MyObject)];\n\nvoid main()\n{\n    // global initialization\n    std::auto_ptr&lt;MyObject&gt; pMyObj(new MyObject);\n\n    // run the program\n    // ...\n\n}\n</code></pre>\n<p>The trick is to allocate enough space in the global memory (by declaring a global array of the adequate size), and then use fictive memory allocation for the needed object, that will \"allocate\" this global memory\". By such we achieve the following:</p>\n<ul>\n<li>Semantically we allocate the object dynamically. Hence we have the full control over its lifetime.</li>\n<li>Actually the object resides in the <strong>global</strong> memory. Hence all the drawbacks related to the \"pointer-wise\" method are inapplicable to our case.</li>\n<li>The object is visible everywhere in the program. One calls <code>MyObject::Instance()</code> to get the reference to it. And, BTW, this function call is easily inlined by the compiler.</li>\n</ul>\n<p>So that everything seems ok with this method. I'm just curious if it's legal from the C++ standard perspective.</p>\n", "AcceptedAnswerId": "6940372", "Title": "Global C++ object initialization", "CreationDate": "2011-08-04T10:42:34.850", "Id": "6939989", "CommentCount": "16", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-08-04T12:45:09.993", "Score": "2", "OwnerUserId": "1560850", "Tags": "<c++><global>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_6939989_6940763_0": {"length": 24, "quality": 0.96, "section_id": 7177}}, "n3337": {"so_6939989_6940763_0": {"length": 24, "quality": 0.96, "section_id": 6921}}, "n4659": {"so_6939989_6940763_0": {"length": 24, "quality": 0.96, "section_id": 8685}}}, "6940372": {"Id": "6940372", "PostTypeId": "2", "Body": "<p>I don't think you have a formal guarantee that your solution works on every compliant implementation, because the C++ standard doesn't guarantee that statically allocated arrays of char are aligned as would be required by any object of the same size.</p>\n", "LastActivityDate": "2011-08-04T11:13:25.860", "CommentCount": "3", "CreationDate": "2011-08-04T11:13:25.860", "ParentId": "6939989", "Score": "2", "OwnerUserId": "838975"}, "6940356": {"Id": "6940356", "PostTypeId": "2", "Body": "<p>I see two problems with this, one a legality problem and one a usability problem.</p>\n<p>The first problem is alignment: <code>MyObject::s_pMyPlaceholder</code> is not guaranteed to be suitably aligned to hold a <code>MyObject</code>.</p>\n<p>The second problem is that you have restricted yourself to a single object of type <code>MyObject</code>. Create a second and you have overwritten the first with no warning.</p>\n<p>I would suggest using <code>boost::optional</code> to delay initialisation of objects.</p>\n", "LastActivityDate": "2011-08-04T11:12:22.550", "CommentCount": "4", "CreationDate": "2011-08-04T11:12:22.550", "ParentId": "6939989", "Score": "3", "OwnerUserId": "611142"}, "6940763": {"Id": "6940763", "PostTypeId": "2", "Body": "<p>From 3.7.3.1 (Allocation functions, [basic.stc.dynamic.allocation]) (ISO/IEC 14882/2003):</p>\n<blockquote>\n<p id=\"so_6939989_6940763_0\">2/ [...] The pointer returned shall be suitably aligned so that it can be\n  converted to a pointer of any complete object type and then used to\n  access the object or array in the storage allocated (until the storage\n  is explicitly deallocated by a call to a corresponding deallocation\n  function).</p>\n</blockquote>\n<p>My doubt is that you cannot guarantee portably that the address of <code>s_MyPlaceHolder[0]</code> is aligned correctly.</p>\n<p>I don't see anything bad (in a single threaded environment) with:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nclass MyObject\n{\n    static MyObject* instance;\n\n    static void release_instance() { delete instance; }\n\npublic:\n    static MyObject&amp; get_instance()\n    {\n        if (!instance) \n        {\n            instance = new MyObject();\n            std::atexit(&amp;release_instance);\n        }\n\n        return *instance;\n    }\n};\n</code></pre>\n<p>except that singletons and globals are usually a poor idea (they tend to marry your code with the presence of such objects, which tightens coupling between parts of your code).</p>\n<p>Since you're interested in controlling the lifetime of the object, you can use RAII:</p>\n<pre><code>class MyObject\n{\n    MyObject() { ... }\n    ~MyObject() { ... }\n\n    // Never defined\n    MyObject(const MyObject&amp;);\n    void operator=(const MyObject&amp;);\n\n\n    static MyObject* instance = 0;\n    static void create_instance()\n    {\n        if (instance) throw std::logic_error(\"Instance already created\");\n        else instance = new MyObject();\n    }\n\n    static void release_instance() { delete instance; }\n\npublic:\n    struct InstanceKeeper\n    {\n        InstanceKeeper(InstanceKeeper&amp; x) : must_clean(x.must_clean)\n        { x.must_clean = false; }\n\n        ~InstanceKeeper() { if (must_clean) release_instance(); }\n\n    private:\n        friend class MyObject;\n        InstanceKeeper() : must_clean(true) { create_instance(); }  \n\n        bool must_clean;\n    };\n\n    friend struct InstanceKeeper;\n    static InstanceKeeper instance_keeper() { return InstanceKeeper(); }  \n\n    static MyObject&amp; instance()\n    {\n        if (!instance) throw std::logic_error(\"Instance not created\");\n        return *instance;\n    }\n};\n</code></pre>\n<p>Usage:</p>\n<pre><code>int main()\n{ \n    MyObject::InstanceKeeper k = MyObject::instance_keeper();\n\n    MyObject::instance().do_something();\n    ...\n\n}\n</code></pre>\n<p>You can even pass the <code>InstanceKeeper</code> object around to functions, it has the same behavior as <code>std::auto_ptr</code>.</p>\n<p>Any performance concerns that you may have are cases of premature optimization.</p>\n", "LastEditorUserId": "373025", "LastActivityDate": "2011-08-04T12:45:09.993", "Score": "1", "CreationDate": "2011-08-04T11:37:39.310", "ParentId": "6939989", "CommentCount": "9", "OwnerUserId": "373025", "LastEditDate": "2011-08-04T12:45:09.993"}});