post_cb({"bq_ids": {"n4140": {"so_27679002_27679053_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 466}, "so_27679002_27679053_3": {"length": 13, "quality": 1.0, "section_id": 639}, "so_27679002_27679053_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_27679002_27679053_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 457}, "so_27679002_27679053_3": {"length": 13, "quality": 1.0, "section_id": 629}, "so_27679002_27679053_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_27679002_27679053_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 489}, "so_27679002_27679053_3": {"length": 13, "quality": 1.0, "section_id": 667}, "so_27679002_27679053_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "27679072": {"Id": "27679072", "PostTypeId": "2", "Body": "<p>The default assignment operator accepts the argument as a const reference: <a href=\"http://en.cppreference.com/w/cpp/language/as_operator\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/as_operator</a>.</p>\n<p>You have defined a version without <code>const</code>, and your version is better in the context of overload resolution (no conversion required).</p>\n<p>Try with <a href=\"http://ideone.com/FC7Oyi\" rel=\"noreferrer\">the following change</a>:</p>\n<pre><code>int main()\n{\n    Pair&lt;int&gt;P1(10,20);\n    Pair&lt;int&gt;P2(1,2);\n    const Pair&lt;int&gt;&amp; x = P1;\n    P2=x;\n    cout&lt;&lt;P2.pair1&lt;&lt;' '&lt;&lt;P2.pair2&lt;&lt;endl;\n    return 1;\n}\n</code></pre>\n<p>to see the expected result.</p>\n", "LastActivityDate": "2014-12-28T17:56:55.230", "CommentCount": "0", "CreationDate": "2014-12-28T17:56:55.230", "ParentId": "27679002", "Score": "6", "OwnerUserId": "2642204"}, "27679053": {"Id": "27679053", "PostTypeId": "2", "Body": "<p>The copy assignment operator is indeed implicitly declared and considered by overload resolution.  </p>\n<blockquote>\n<p id=\"so_27679002_27679053_0\">A user-declared copy assignment operator <code>X::operator=</code> is a\n  non-static <strong>non-template member function</strong> of class <code>X</code> [..]. <br><br><strong>If the class definition does not explicitly\n  declare a copy assignment operator, one is declared <em>implicitly</em></strong>. [..]\n  The implicitly-declared copy assignment operator for a class <code>X</code> will\n  have the form</br></br></p>\n<pre><code>X&amp; X::operator=(const X&amp;)\n</code></pre>\n<p id=\"so_27679002_27679053_1\">if</p>\n<ul>\n<li>each direct base class <code>B</code> of <code>X</code> has a copy assignment operator whose parameter is of type <code>const B&amp;</code>, <code>const volatile B&amp;</code> or <code>B</code>, and</li>\n<li>for all the non-static data members of <code>X</code> that are of a class type <code>M</code> (or array thereof), each such class type has a copy assignment\n  operator whose parameter is of type <code>const M&amp;</code>, <code>const volatile M&amp;</code> or\n  <code>M</code>.</li>\n</ul>\n<p id=\"so_27679002_27679053_2\">Otherwise, [..]</p>\n</blockquote>\n<p>As you can see the implicitly-declared copy assignment operator for <code>Pair&lt;int&gt;</code> has one parameter of type <code>Pair&lt;int&gt; const&amp;</code> - note the <code>const</code> in particular! Overload resolution favours non-<code>const</code> references over <code>const</code> ones if both can be bound to the argument, [over.ics.rank]/3:</p>\n<blockquote>\n<p id=\"so_27679002_27679053_3\">Two implicit conversion sequences of the same form are\n  indistinguishable conversion sequences unless one of the following\n  rules applies:</p>\n<p id=\"so_27679002_27679053_4\">\u2014\n   Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence\n  <code>S2</code> if</p>\n<ul>\n<li>[..]</li>\n<li><code>S1</code> and <code>S2</code> are reference bindings (8.5.3), and the types to which the\n  references refer are the same type except for top-level cv-qualifiers,\n  <strong>and the type to which the reference initialized by <code>S2</code> refers is more\n  cv-qualified than the type to which the reference initialized by <code>S1</code>\n  refers.</strong></li>\n</ul>\n</blockquote>\n<p>The specialization of the template lacks a <code>const</code> in the reference parameter, thus it's a better match and is selected.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-28T19:18:35.503", "Score": "13", "CreationDate": "2014-12-28T17:54:18.610", "ParentId": "27679002", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-12-28T19:18:35.503"}, "27679002": {"ViewCount": "1323", "Body": "<p>In <em>C++ Templates The Complete Guide</em> in  <em>section 5.3 Member Templates</em> it's written:</p>\n<blockquote>\n<p id=\"so_27679002_27679002_0\">Note that a template assignment operator doesn't replace the default\n  assignment operator. For assignments of stacks of the same type, the\n  default assignment operator is still called.</p>\n</blockquote>\n<p>Is this correct, because when I ran below code:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass Pair\n{\n    public:\n            T pair1,pair2;\n            Pair(T i,T j):pair1(i),pair2(j){}\n            template&lt;typename T1&gt;Pair&lt;T&gt;&amp; operator=(Pair&lt;T1&gt;&amp;);             \n};\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename T1&gt;\nPair&lt;T&gt;&amp; Pair&lt;T&gt;::operator=(Pair&lt;T1&gt;&amp; temp)\n{\n\n    this-&gt;pair1 =temp.pair1*10;//At this point\n    this-&gt;pair2=temp.pair2;\n    return *this;\n}\n\nint main()\n{\n\n    Pair&lt;int&gt;P1(10,20);\n    Pair&lt;int&gt;P2(1,2);\n    P2=P1;\n    cout&lt;&lt;P2.pair1&lt;&lt;' '&lt;&lt;P2.pair2&lt;&lt;endl;\n    return 1;\n}\n</code></pre>\n<p>I got answer 100 20.</p>\n<p>It didn't give the default assignment answer.</p>\n<p>Is that a typing mistake in <em>C++ Templates the Complete Guide</em>?</p>\n<blockquote>\n<p id=\"so_27679002_27679002_1\">C++ Templates: The Complete Guide By David Vandevoorde, Nicolai M. \n  Josuttis </p>\n<p id=\"so_27679002_27679002_2\">Publisher : Addison Wesley </p>\n<p id=\"so_27679002_27679002_3\">Pub Date : November 12, 2002  ISBN : 0-201-73484-2 Pages : 552</p>\n</blockquote>\n", "AcceptedAnswerId": "27679053", "Title": "Template assignment operator doesn't replace the default assignment operator", "CreationDate": "2014-12-28T17:48:48.287", "Id": "27679002", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-28T17:53:50.910", "LastEditorUserId": "3880254", "LastActivityDate": "2014-12-28T19:18:35.503", "Score": "10", "OwnerUserId": "3880254", "Tags": "<c++><templates>", "AnswerCount": "2"}});