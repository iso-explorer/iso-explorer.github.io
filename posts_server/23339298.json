post_cb({"23339298": {"CommentCount": "0", "AcceptedAnswerId": "23339498", "PostTypeId": "1", "LastEditorUserId": "485561", "CreationDate": "2014-04-28T10:57:45.507", "LastActivityDate": "2014-04-28T11:10:45.453", "LastEditDate": "2014-04-28T11:10:45.453", "ViewCount": "629", "FavoriteCount": "3", "Title": "std::hash template partial specialization", "Id": "23339298", "Score": "5", "Body": "<p>I wrote some class with template:</p>\n<pre><code> template &lt;class T, class Allocator = ::std::allocator&lt;T&gt; &gt;\n class my_list;\n</code></pre>\n<p>I should write ::std::hash specializtion for this class. How can I do that?\nSimple partial specialization:</p>\n<pre><code>namespace std {\n  template &lt;class T, class Allocator&gt;\n      class hash&lt;my_list&lt;T, Allocator&gt; &gt;{\n      public :\n      size_t operator()(const my_list&lt;T, Allocator&gt; &amp;x ) const{\n          return ...;\n      }\n  };\n}\n</code></pre>\n<p>But I can't write simple partial specialization, because it forbidden by C++ ISO:</p>\n<blockquote>\n<p id=\"so_23339298_23339298_0\">ISO/IEC 14882 Third edition 2011-09-01</p>\n<p id=\"so_23339298_23339298_1\">17.6.4.2.1 Namespace std [namespace.std]</p>\n<p id=\"so_23339298_23339298_2\">2 The behavior of a C++ program is undefined if it declares ... an explicit or partial specialization of any member class template of a standard library class or class template.</p>\n</blockquote>\n<p>What can I do?</p>\n", "Tags": "<c++><templates><c++11><std><language-lawyer>", "OwnerUserId": "3098730", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23339298_23339498_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}, "so_23339298_23339298_2": {"section_id": 6300, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_23339298_23339298_2": {"section_id": 6057, "quality": 0.9285714285714286, "length": 13}, "so_23339298_23339498_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_23339298_23339498_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}, "so_23339298_23339298_2": {"section_id": 7809, "quality": 0.9285714285714286, "length": 13}}}, "23339498": {"ParentId": "23339298", "CommentCount": "2", "Body": "<p>The paragraph you're quoting does not apply. You're partialy specialising a <em>class template</em> (<code>std::hash</code>), not a <em><b>member class template</b> of a standard library class or class template.</em> <code>std::hash</code> is not a member of any class or class template.</p>\n<p>For your case, paragraph 1 of the same section applies, and that allows specialisation when at least one user-defined type is involved (emphasis mine):</p>\n<blockquote>\n<p id=\"so_23339298_23339498_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a\n  namespace within namespace std unless otherwise specified. <strong>A program may add a template specialization\n  for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type</strong>\n  and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "23339498", "Score": "11", "CreationDate": "2014-04-28T11:07:55.800", "LastActivityDate": "2014-04-28T11:07:55.800"}});