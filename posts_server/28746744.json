post_cb({"41528436": {"Id": "41528436", "PostTypeId": "2", "Body": "<p>I know this a little bit old..</p>\n<p>But i wanted to add: </p>\n<p><strong>Lambda expression (even captured ones) can be handled as a function pointer!</strong></p>\n<p>It is tricky because an Lambda expression is not a simple function. It is actually an object with an operator().</p>\n<p>When you are creative, you can use this! \nThink of an \"function\" class in style of std::function. \nIf you save the object! </p>\n<p>You also can use the function pointer.</p>\n<p>To use the function pointer, you can use the following:</p>\n<pre><code>int first = 5;\nauto lambda = [=](int x, int z) {\n    return x + z + first;\n};\nint(decltype(lambda)::*ptr)(int, int)const = &amp;decltype(lambda)::operator();\nstd::cout &lt;&lt; \"test = \" &lt;&lt; (lambda.*ptr)(2, 3) &lt;&lt; std::endl;\n</code></pre>\n<p>To build a class that can start working like a \"std::function\" i will just do short example. First you need a class/struct than can store object and function pointer also you need an operator() to execute it:</p>\n<pre><code>// OT =&gt; Object Type\n// RT =&gt; Return Type\n// A ... =&gt; Arguments\ntemplate&lt;typename OT, typename RT, typename ... A&gt;\nstruct lambda_expression {\n    OT _object;\n    RT(OT::*_function)(A...)const;\n\n    lambda_expression(const OT &amp; object)\n        : _object(object), _function(&amp;decltype(_object)::operator()) {}\n\n    RT operator() (A ... args) const {\n        return (_object.*_function)(args...);\n    }\n};\n</code></pre>\n<p>With this you can now run captured, noncaptured lambdas, just like you are using the original:</p>\n<pre><code>auto capture_lambda() {\n    int first = 5;\n    auto lambda = [=](int x, int z) {\n        return x + z + first;\n    };\n    return lambda_expression&lt;decltype(lambda), int, int, int&gt;(lambda);\n}\n\nauto noncapture_lambda() {\n    auto lambda = [](int x, int z) {\n        return x + z;\n    };\n    return lambda_expression&lt;decltype(lambda), int, int, int&gt;(lambda);\n}\n\nvoid refcapture_lambda() {\n    int test;\n    auto lambda = [&amp;](int x, int z) {\n        test = x + z;\n    };\n    lambda_expression&lt;decltype(lambda), void, int, int&gt;f(lambda);\n    f(2, 3);\n\n    std::cout &lt;&lt; \"test value = \" &lt;&lt; test &lt;&lt; std::endl;\n}\n\nint main(int argc, char **argv) {\n    auto f_capture = capture_lambda();\n    auto f_noncapture = noncapture_lambda();\n\n    std::cout &lt;&lt; \"main test = \" &lt;&lt; f_capture(2, 3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"main test = \" &lt;&lt; f_noncapture(2, 3) &lt;&lt; std::endl;\n\n    refcapture_lambda();\n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n<p>This code works with VS2015\nHope it helps : )</p>\n<p>Greets!</p>\n<p>Edit: removed needles template FP, removed function pointer parameter, renamed to lambda_expression</p>\n<p>Update 04.07.17:</p>\n<pre><code>template &lt;typename CT, typename ... A&gt; struct function\n: public function&lt;decltype(&amp;CT::operator())(A...)&gt; {};\n\ntemplate &lt;typename C&gt; struct function&lt;C&gt; {\nprivate:\n    C mObject;\n\npublic:\n    function(const C &amp; obj)\n        : mObject(obj) {}\n\n    template&lt;typename... Args&gt; typename \n    std::result_of&lt;C(Args...)&gt;::type operator()(Args... a) {\n        return this-&gt;mObject.operator()(a...);\n    }\n\n    template&lt;typename... Args&gt; typename \n    std::result_of&lt;const C(Args...)&gt;::type operator()(Args... a) const {\n        return this-&gt;mObject.operator()(a...);\n    }\n};\n\nnamespace make {\n    template&lt;typename C&gt; auto function(const C &amp; obj) {\n        return ::function&lt;C&gt;(obj);\n    }\n}\n\nint main(int argc, char ** argv) {\n   auto func = make::function([](int y, int x) { return x*y; });\n   std::cout &lt;&lt; func(2, 4) &lt;&lt; std::endl;\n   system(\"PAUSE\");\n   return 0;\n}\n</code></pre>\n", "LastEditorUserId": "4981172", "LastActivityDate": "2017-07-17T16:34:23.207", "Score": "11", "CreationDate": "2017-01-08T01:17:26.360", "ParentId": "28746744", "CommentCount": "11", "OwnerUserId": "4981172", "LastEditDate": "2017-07-17T16:34:23.207"}, "34373548": {"Id": "34373548", "PostTypeId": "2", "Body": "<p>As it was mentioned by the others you can substitute Lambda function instead of function pointer. I am using this method in my C++ interface to F77 ODE solver RKSUITE.</p>\n<pre><code>//C interface to Fortran subroutine UT\nextern \"C\"  void UT(void(*)(double*,double*,double*),double*,double*,double*,\ndouble*,double*,double*,int*);\n\n// C++ wrapper which calls extern \"C\" void UT routine\nstatic  void   rk_ut(void(*)(double*,double*,double*),double*,double*,double*,\ndouble*,double*,double*,int*);\n\n//  Call of rk_ut with lambda passed instead of function pointer to derivative\n//  routine\nmathlib::RungeKuttaSolver::rk_ut([](double* T,double* Y,double* YP)-&gt;void{YP[0]=Y[1]; YP[1]= -Y[0];}, TWANT,T,Y,YP,YMAX,WORK,UFLAG);\n</code></pre>\n", "LastEditorUserId": "794749", "LastActivityDate": "2015-12-19T18:42:54.743", "Score": "0", "CreationDate": "2015-12-19T17:38:14.517", "ParentId": "28746744", "CommentCount": "0", "OwnerUserId": "4822725", "LastEditDate": "2015-12-19T18:42:54.743"}, "28747100": {"Id": "28747100", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/28746827/1392132\">Shafik Yaghmour's answer</a> correctly explains why the lambda cannot be passed as a function pointer.  I'd like to show two simple fixes for the problem.</p>\n<ol>\n<li><p><strong>Use <code>std::function</code> instead of raw function pointers.</strong></p>\n<p>This is a very clean solution.  Note however that it includes some additional overhead for the type erasure (probably a virtual function call).</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;utility&gt;\n\nstruct Decide\n{\n  using DecisionFn = std::function&lt;bool()&gt;;\n  Decide(DecisionFn dec) : dec_ {std::move(dec)} {}\n  DecisionFn dec_;\n};\n\nint\nmain()\n{\n  int x = 5;\n  Decide greaterThanThree { [x](){ return x &gt; 3; } };\n}\n</code></pre></li>\n<li><p><strong>Use a lambda expression that doesn't capture anything.</strong></p>\n<p>Since your predicate is really just a boolean constant, the following would quickly work around the current issue.  See <a href=\"https://stackoverflow.com/a/27989291/1392132\">this answer</a> for a good explanation why and how this is working.</p>\n<pre><code>// Your 'Decide' class as in your post.\n\nint\nmain()\n{\n  int x = 5;\n  Decide greaterThanThree {\n    (x &gt; 3) ? [](){ return true; } : [](){ return false; }\n  };\n}\n</code></pre></li>\n</ol>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-23T16:37:58.530", "Score": "52", "CreationDate": "2015-02-26T16:02:27.597", "ParentId": "28746744", "CommentCount": "6", "OwnerUserId": "1392132", "LastEditDate": "2017-05-23T12:26:35.830"}, "bq_ids": {"n4140": {"so_28746744_28746827_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_28746744_28746827_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_28746744_28746827_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "45365798": {"Id": "45365798", "PostTypeId": "2", "Body": "<p>Capturing lambdas cannot be converted to function pointers, as <a href=\"https://stackoverflow.com/a/28746827/4832499\">this answer</a> pointed out.</p>\n<p>However, it is often quite a pain to supply a function pointer to an API that only accepts one. The most often cited method to do so is to provide a function and call a static object with it.</p>\n<pre><code>static Callable callable;\nstatic bool wrapper()\n{\n    return callable();\n}\n</code></pre>\n<p>This is tedious. We take this idea further and automate the process of creating <code>wrapper</code> and make life much easier.</p>\n<pre><code>#include&lt;type_traits&gt;\n#include&lt;utility&gt;\n\ntemplate&lt;typename Callable&gt;\nunion storage\n{\n    storage() {}\n    std::decay_t&lt;Callable&gt; callable;\n};\n\ntemplate&lt;int, typename Callable, typename Ret, typename... Args&gt;\nauto fnptr_(Callable&amp;&amp; c, Ret (*)(Args...))\n{\n    static bool used = false;\n    static storage&lt;Callable&gt; s;\n    using type = decltype(s.callable);\n\n    if(used)\n        s.callable.~type();\n    new (&amp;s.callable) type(std::forward&lt;Callable&gt;(c));\n    used = true;\n\n    return [](Args... args) -&gt; Ret {\n        return Ret(s.callable(args...));\n    };\n}\n\ntemplate&lt;typename Fn, int N = 0, typename Callable&gt;\nFn* fnptr(Callable&amp;&amp; c)\n{\n    return fnptr_&lt;N&gt;(std::forward&lt;Callable&gt;(c), (Fn*)nullptr);\n}\n</code></pre>\n<p>And use it as</p>\n<pre><code>void foo(void (*fn)())\n{\n    fn();   \n}\n\nint main()\n{\n    int i = 42;\n    auto fn = fnptr&lt;void()&gt;([i]{std::cout &lt;&lt; i;});\n    foo(fn);  // compiles!\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/95fa363082823d82\" rel=\"nofollow noreferrer\">Live</a></p>\n<p>This is essentially declaring an anonymous function at each occurrence of <code>fnptr</code>.</p>\n<p>Note that invocations of <code>fnptr</code> overwrite the previously written <code>callable</code> given callables of the same type. We remedy this, to a certain degree, with the <code>int</code> parameter <code>N</code>.</p>\n<pre><code>std::function&lt;void()&gt; func1, func2;\nauto fn1 = fnptr&lt;void(), 1&gt;(func1);\nauto fn2 = fnptr&lt;void(), 2&gt;(func2);  // different function\n</code></pre>\n<p>If you are crazy enough, <code>N</code> can be defaulted to a <a href=\"https://stackoverflow.com/questions/44267673/is-stateful-metaprogramming-ill-formed-yet\">constexpr counter</a> to ease the use even further.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-07-28T06:28:24.607", "Score": "0", "CreationDate": "2017-07-28T05:51:44.550", "ParentId": "28746744", "CommentCount": "0", "OwnerUserId": "4832499", "LastEditDate": "2017-07-28T06:28:24.607"}, "28746827": {"Id": "28746827", "PostTypeId": "2", "Body": "<p>A lambda can only be converted to a function pointer if it does not capture, from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++11 standard</a> section <code>5.1.2</code> <em>[expr.prim.lambda]</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_28746744_28746827_0\">The closure type for a lambda-expression <strong>with no lambda-capture</strong> has a\n  public non-virtual non-explicit const <strong>conversion function to pointer\n  to function</strong> having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Note, cppreference also covers this in their section on <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"noreferrer\">Lambda functions </a>.</p>\n<p>So the following alternatives would work:</p>\n<pre><code>typedef bool(*DecisionFn)(int);\n\nDecide greaterThanThree{ []( int x ){ return x &gt; 3; } };\n</code></pre>\n<p>and so would this:</p>\n<pre><code>typedef bool(*DecisionFn)();\n\nDecide greaterThanThree{ [](){ return true ; } };\n</code></pre>\n<p>and as <a href=\"https://stackoverflow.com/a/28747100/1708801\">5gon12eder</a> points out, you can also use <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function\" rel=\"noreferrer\">std::function</a>, but note that <a href=\"https://stackoverflow.com/a/9054802/1708801\">std::function is heavy weight</a>, so it is not a cost-less trade-off.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-27T13:54:36.417", "Score": "108", "CreationDate": "2015-02-26T15:49:39.713", "ParentId": "28746744", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:34:45.403"}, "28746744": {"ViewCount": "54347", "Body": "<p>Is it possible to pass a lambda function as a function pointer? If so, I must be doing something incorrectly because I am getting a compile error.</p>\n<p>Consider the following example</p>\n<pre><code>using DecisionFn = bool(*)();\n\nclass Decide\n{\npublic:\n    Decide(DecisionFn dec) : _dec{dec} {}\nprivate:\n    DecisionFn _dec;\n};\n\nint main()\n{\n    int x = 5;\n    Decide greaterThanThree{ [x](){ return x &gt; 3; } };\n    return 0;\n}\n</code></pre>\n<p>When I <a href=\"http://cpp.sh/5x5r\">try to compile this</a>, I get the following compilation error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>In function 'int main()':\n17:31: error: the value of 'x' is not usable in a constant expression\n16:9:  note: 'int x' is not const\n17:53: error: no matching function for call to 'Decide::Decide(&lt;brace-enclosed initializer list&gt;)'\n17:53: note: candidates are:\n9:5:   note: Decide::Decide(DecisionFn)\n9:5:   note: no known conversion for argument 1 from 'main()::&lt;lambda()&gt;' to 'DecisionFn {aka bool (*)()}'\n6:7:   note: constexpr Decide::Decide(const Decide&amp;)\n6:7:   note: no known conversion for argument 1 from 'main()::&lt;lambda()&gt;' to 'const Decide&amp;'\n6:7:   note: constexpr Decide::Decide(Decide&amp;&amp;)\n6:7:   note: no known conversion for argument 1 from 'main()::&lt;lambda()&gt;' to 'Decide&amp;&amp;'\n</code></pre>\n<p>That's one heck of an error message to digest, but I think what I'm getting out of it is that the lambda cannot be treated as a <code>constexpr</code> so therefore I cannot pass it as a function pointer? I've tried making <code>x</code> const as well, but that doesn't seem to help.</p>\n", "AcceptedAnswerId": "28746827", "Title": "Passing lambda as function pointer", "CreationDate": "2015-02-26T15:45:23.263", "Id": "28746744", "CommentCount": "2", "FavoriteCount": "18", "PostTypeId": "1", "LastEditDate": "2016-01-23T16:35:11.507", "LastEditorUserId": "1392132", "LastActivityDate": "2017-07-28T06:28:24.607", "Score": "110", "OwnerUserId": "2296458", "Tags": "<c++><c++11><lambda><function-pointers>", "AnswerCount": "5"}});