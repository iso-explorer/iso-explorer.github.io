post_cb({"20973417": {"ViewCount": "486", "Body": "<p>For the aggregate</p>\n<pre><code>struct S{int i, j;};\n</code></pre>\n<p>the declarations <code>S s({1, 2});</code> and <code>S s({1});</code> perform <em>direct-initialization</em> according to N3797 \u00a78.5 p16:</p>\n<blockquote>\n<p id=\"so_20973417_20973417_0\">The initialization that occurs in the forms</p>\n<pre><code>T x(a);\nT x{a};\n</code></pre>\n<p id=\"so_20973417_20973417_1\">as well as in <code>new</code> expressions (5.3.4), <code>static_cast</code> expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called <em>direct-initialization</em>.</p>\n</blockquote>\n<p>But \u00a78.5 p17 doesn't seem to characterize them:</p>\n<blockquote>\n<p id=\"so_20973417_20973417_2\">The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly\n  parenthesized) expression, the source type is not defined.</p>\n<ul>\n<li><p id=\"so_20973417_20973417_3\">If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</p></li>\n<li><p id=\"so_20973417_20973417_4\">If the destination type is a reference type, see 8.5.3.</p></li>\n<li><p id=\"so_20973417_20973417_5\">If the destination type is an array of characters, an array of <code>char16_t</code>, an array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a string literal, see 8.5.2.</p></li>\n<li><p id=\"so_20973417_20973417_6\">If the initializer is <code>()</code>, the object is value-initialized.</p></li>\n<li><p id=\"so_20973417_20973417_7\">Otherwise, if the destination type is an array, the program is ill-formed.</p></li>\n<li><p id=\"so_20973417_20973417_8\">If the destination type is a (possibly cv-qualified) class type:</p>\n<ul>\n<li><p id=\"so_20973417_20973417_9\">If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or <em>expression-list</em> as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p></li>\n<li><p id=\"so_20973417_20973417_10\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified\n  version of the destination type. The temporary is a prvalue. The result of the call (which is the\n  temporary for the constructor case) is then used to direct-initialize, according to the rules above,\n  the object that is the destination of the copy-initialization. In certain cases, an implementation\n  is permitted to eliminate the copying inherent in this direct-initialization by constructing the\n  intermediate result directly into the object being initialized; see 12.2, 12.8.</p></li>\n</ul></li>\n<li><p id=\"so_20973417_20973417_11\">Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered. The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer expression into the object being initialized. If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</p></li>\n<li><p id=\"so_20973417_20973417_12\">Otherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression. Standard conversions (Clause 4) will be used, if necessary, to convert the initializer expression to the cv-unqualified version of the destination type; no user-defined conversions are considered. If the conversion cannot be done, the initialization is ill-formed. [<em>Note:</em> An expression of type \u201c<em>cv1</em> <code>T</code>\u201d can initialize an object of type \u201c<em>cv2</em> <code>T</code>\u201d independently of the cv-qualifiers <em>cv1</em> and <em>cv2</em>.</p>\n<pre><code> int a;\n const int b = a;\n int c = b;\n</code></pre>\n<p id=\"so_20973417_20973417_13\">\u2014 <em>end note</em> ]</p></li>\n</ul>\n</blockquote>\n<p>The subject declarations, <code>S s({1, 2});</code> and <code>S s({1});</code>:</p>\n<ul>\n<li>are not <em>list-initialization</em>, since each initializer is a parenthesized <em>braced-init-list</em>.</li>\n<li>the destination types are not references</li>\n<li>the destination types are not array of characters, in general.</li>\n<li>the initializers are not <code>()</code></li>\n<li>the destination types are not arrays.</li>\n</ul>\n", "Title": "Is there a case missing in \u00a78.5 p17 (semantics of initializers) of N3797?", "CreationDate": "2014-01-07T13:54:24.963", "LastActivityDate": "2014-01-13T18:14:16.407", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-09T17:01:04.433", "LastEditorUserId": "420683", "Id": "20973417", "Score": "9", "OwnerUserId": "2548699", "Tags": "<c++><c++11><initialization><language-lawyer><c++14>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20973417_20973417_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 3296}, "so_20973417_21044373_2": {"length": 38, "quality": 0.95, "section_id": 626}, "so_20973417_20973417_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 3295}, "so_20973417_20973417_2": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_20973417_21044373_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 633}, "so_20973417_20973417_7": {"length": 5, "quality": 1.0, "section_id": 3296}, "so_20973417_21044373_0": {"length": 6, "quality": 1.0, "section_id": 3296}, "so_20973417_20973417_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}, "so_20973417_20973417_9": {"length": 41, "quality": 0.9111111111111111, "section_id": 3296}, "so_20973417_20973417_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 3296}, "so_20973417_20973417_10": {"length": 81, "quality": 0.9204545454545454, "section_id": 3296}, "so_20973417_21044373_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 634}, "so_20973417_20973417_11": {"length": 36, "quality": 0.9, "section_id": 3296}, "so_20973417_20973417_12": {"length": 37, "quality": 0.8604651162790697, "section_id": 3296}, "so_20973417_20973417_8": {"length": 6, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_20973417_20973417_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 3166}, "so_20973417_21044373_3": {"length": 18, "quality": 0.75, "section_id": 623}, "so_20973417_20973417_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 3165}, "so_20973417_20973417_7": {"length": 5, "quality": 1.0, "section_id": 3166}, "so_20973417_21044373_0": {"length": 6, "quality": 1.0, "section_id": 3166}, "so_20973417_20973417_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_20973417_21044373_2": {"length": 38, "quality": 0.95, "section_id": 616}, "so_20973417_20973417_9": {"length": 41, "quality": 0.9111111111111111, "section_id": 3166}, "so_20973417_20973417_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 3166}, "so_20973417_20973417_2": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_20973417_20973417_10": {"length": 81, "quality": 0.9204545454545454, "section_id": 3166}, "so_20973417_21044373_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 624}, "so_20973417_20973417_11": {"length": 36, "quality": 0.9, "section_id": 3166}, "so_20973417_20973417_8": {"length": 6, "quality": 1.0, "section_id": 3166}, "so_20973417_20973417_12": {"length": 37, "quality": 0.8604651162790697, "section_id": 3166}}, "n4659": {"so_20973417_20973417_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 4058}, "so_20973417_21044373_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 661}, "so_20973417_20973417_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 4057}, "so_20973417_20973417_7": {"length": 5, "quality": 1.0, "section_id": 4058}, "so_20973417_21044373_0": {"length": 6, "quality": 1.0, "section_id": 4058}, "so_20973417_20973417_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_20973417_21044373_2": {"length": 35, "quality": 0.875, "section_id": 652}, "so_20973417_20973417_9": {"length": 41, "quality": 0.9111111111111111, "section_id": 4058}, "so_20973417_20973417_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 4058}, "so_20973417_20973417_2": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_20973417_20973417_10": {"length": 60, "quality": 0.6818181818181818, "section_id": 4058}, "so_20973417_21044373_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 662}, "so_20973417_20973417_11": {"length": 36, "quality": 0.9, "section_id": 4058}, "so_20973417_20973417_8": {"length": 6, "quality": 1.0, "section_id": 4058}, "so_20973417_20973417_12": {"length": 41, "quality": 0.9534883720930233, "section_id": 4058}}}, "21034867": {"Id": "21034867", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20973417_21034867_0\">The declarations <code>S s({1, 2});</code> and <code>S s({1});</code> perform direct-initialization according to N3797 \u00a78.5 p16</p>\n</blockquote>\n<p>Well, yes and no. In the first case, and similarly in the second, an <code>S</code> x-value object is constructed with <code>{1, 2}</code> and then passed to the implicitly-declared copy constructor of the <code>s</code> l-value.</p>\n<p>This is not the case \u00a78.5 p16 is discussing, because the initialization is not in the form:</p>\n<pre><code>S s(a);\nS s{a};\n</code></pre>\n<p>unless the standard consider <code>a</code> to be anything. And even then, it's not part of the rest of the cases  he defines right after (<code>new</code>, <code>static_cast</code>, etc..).</p>\n<blockquote>\n<p id=\"so_20973417_21034867_1\">The subject declarations, <code>S s({1, 2});</code> and <code>S s({1});</code> are not list-initialization, since each initializer is a parenthesized braced-init-list.</p>\n</blockquote>\n<p>The expressions <code>{1, 2}</code> and <code>{1}</code> are definitely list-initializations of temporary/expiring <code>S</code> objects.</p>\n", "LastActivityDate": "2014-01-10T01:55:58.553", "Score": "1", "CreationDate": "2014-01-10T01:55:58.553", "ParentId": "20973417", "CommentCount": "4", "OwnerUserId": "493122"}, "21044373": {"Id": "21044373", "PostTypeId": "2", "Body": "<p>This case <strong>is covered</strong> in the Standard: It's \u00a78.5/17 6th bullet (emphasis mine):</p>\n<blockquote>\n<p id=\"so_20973417_21044373_0\">If the <strong>destination type is a (possibly cv-qualified) class type</strong>:</p>\n<ul>\n<li><strong>If the initialization is direct-initialization</strong>, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, <strong>constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s)</strong>. If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n</ul>\n</blockquote>\n<p><strong>Explanation:</strong> We first note that <code>S</code> is an aggregate (by \u00a78.5.1/1). But an aggregate is also a <strong>class</strong> and hence has an <strong>implicitely declared defaulted copy/move constructor</strong> (by \u00a712.8). Both constructors take one argument and hence are <strong>viable</strong> (by \u00a713.3.2). Their signatures are as usual:</p>\n<pre><code>S(const S&amp;) //copy\nS(S&amp;&amp;)      //move\n</code></pre>\n<p>Now we have to determine the conversion sequence to convert the initializer-list <code>{1,2}</code> to the parameter types. \u00a713.3.3.1.5/6 states:</p>\n<blockquote>\n<p id=\"so_20973417_21044373_1\">Otherwise, if the parameter is a reference, see 13.3.3.1.4. [ Note: The rules in this section will apply for initializing the underlying temporary for the reference. \u2014end note ]</p>\n</blockquote>\n<p>Since the parameter types are references, \u00a713.3.3.1.4/2 applies:</p>\n<blockquote>\n<p id=\"so_20973417_21044373_2\">When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the underlying type of the reference according to 13.3.3.1. <strong>Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the underlying type with the argument expression</strong>. Any difference in top-level cv-qualification is subsumed by\n  the initialization itself and does not constitute a conversion.</p>\n</blockquote>\n<p>Since <code>S</code> is an aggregate, we have to apply \u00a713.3.3.1.5/5 to initialize this temporary object:</p>\n<blockquote>\n<p id=\"so_20973417_21044373_3\">Otherwise, if the parameter has an aggregate type which can be initialized from the initializer list according to the rules for <strong>aggregate initialization (8.5.1)</strong>, the implicit conversion sequence is a user-defined conversion sequence with the second standard conversion sequence an identity conversion.</p>\n</blockquote>\n<p>Hence, we finally arrive at <strong>aggregate initialization</strong> of this temporary object. To determine which of these two constructors is the best viable function one has to consult \u00a713.3.3.2 (which is left to the reader). Since the reference is bound to a temporary object the move constructor will actually be chosen.</p>\n", "LastEditorUserId": "1770418", "LastActivityDate": "2014-01-13T18:14:16.407", "Score": "4", "CreationDate": "2014-01-10T12:26:11.860", "ParentId": "20973417", "CommentCount": "8", "LastEditDate": "2014-01-13T18:14:16.407", "OwnerUserId": "1770418"}});