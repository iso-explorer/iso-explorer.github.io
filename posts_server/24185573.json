post_cb({"24185998": {"ParentId": "24185573", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The elements of a <code>set</code> can't be duplicates. If you'd be allowed to change an element, then all this logic wouldn't be maintained. Therefore, you need to erase the existing element and insert the new one.</p>\n<p>So unless you use <code>const_cast</code>, there's no other way to do it. However, as mentioned, doing so may break the <code>set</code>, allowing it to have potential duplicate values.</p>\n<p>Here's how one would do it for a <code>std::set&lt;int&gt;</code> (I know it's not a QT set, but the logic should be the same):</p>\n<pre><code>std::set&lt;int&gt; mySet;\nmySet.insert(3);\nmySet.insert(4);\nfor (auto i = mySet.begin(); i != mySet.end(); i++)\n{\n    int* elem = const_cast&lt;int*&gt;(&amp;*i);\n    *elem = 6;\n}\n</code></pre>\n", "OwnerUserId": "840678", "LastEditorUserId": "840678", "LastEditDate": "2014-06-12T13:52:44.697", "Id": "24185998", "Score": "0", "CreationDate": "2014-06-12T13:42:07.360", "LastActivityDate": "2014-06-12T13:52:44.697"}, "24186122": {"ParentId": "24185573", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Modifying  <code>QSet</code> elements is not allowed, since it could break set internal structure of the container by modifying one of the hash result.</p>\n<p>As for the standard associative containers, this in the standard section \u00a7 23.2.4</p>\n<blockquote>\n<p id=\"so_24185573_24186122_0\">iterator of an associative container is of the bidirectional iterator\n  category. For associative containers where the value type is the same\n  as the key type, both iterator and const_iterator are constant\n  iterators. It is unspecified whether or not iterator and\n  const_iterator are the same type.</p>\n</blockquote>\n<p>If you know that your modification has no impact on the sorted position element, the use of a <code>const_cast</code> is one of those rare case where it is ok.</p>\n<p>However, the idiomatic way is to use an <strong>hint insertion</strong> :</p>\n<ol>\n<li>Locate the element to be modified</li>\n<li>Make a copy of the element</li>\n<li>Modify the copy</li>\n<li>Remove the element</li>\n<li>Insert the copy, using the hint insertion when available (there is non for a <code>QSet</code>)</li>\n</ol>\n<p><strong>Example:</strong></p>\n<pre><code>  s.erase(original);\n  // modify p ...\n  s.insert(copy, hint);\n</code></pre>\n<p>Notes :</p>\n<ol>\n<li>The same apply for the other associate containers.</li>\n<li>This issue is extensively discussed in \"<em>Effective STL , Item 22</em>\", Scott Meyers.</li>\n<li>It is sometimes a good idea to consider <code>std::vector</code> as a substitute for <code>std::set</code></li>\n</ol>\n", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-06-13T11:13:41.917", "Id": "24186122", "Score": "3", "CreationDate": "2014-06-12T13:47:00.603", "LastActivityDate": "2014-06-13T11:13:41.917"}, "24185573": {"CommentCount": "0", "ViewCount": "386", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2014-06-12T13:23:47.320", "LastActivityDate": "2014-06-13T11:13:41.917", "Title": "Change element in a set via iterator", "AcceptedAnswerId": "24186122", "LastEditDate": "2014-06-12T14:54:37.757", "Id": "24185573", "Score": "0", "Body": "<p>I want to change an element in a set (QSet):</p>\n<pre><code>for(PSet::iterator pIt = P.begin(); pIt != P.end(); ++pIt)\n  pIt-&gt;xp = 0;\n</code></pre>\n<p>The compiler won't let me do this (\"C3892: 'var' : you cannot assign to a variable that is const\"). It seems like a set iterator is always constant due to fear that changing the element might corrupt its proper position in the set. </p>\n<p>In my case PSet is a set of structs for which I defined my own hash function:</p>\n<pre><code>struct P\n{\n  P(int id, const Data_t&amp; data)\n     :xp(_INFINITY_)\n     ,id(id)\n     ,data(data){}\n\n  int xp;  \n  const int id;\n  const Data_t data;\n};\n</code></pre>\n<p>My hash function does not consider the non-const member xp, so my above assignment should be perfectly safe concerning the element's order in the set. I do not want to remove the element and re-insert it, since performance is actually an issue here. </p>\n<p>I guess I could use const-casts but that would hurt my code's readability and look like a nasty hack. \nDo I have any other options?</p>\n", "Tags": "<c++><compiler-errors><set>", "OwnerUserId": "1376260", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24185573_24186122_0": {"section_id": 742, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_24185573_24186122_0": {"section_id": 731, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_24185573_24186122_0": {"section_id": 800, "quality": 0.9615384615384616, "length": 25}}}});