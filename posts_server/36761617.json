post_cb({"bq_ids": {"n4140": {"so_36761617_36761957_2": {"length": 19, "quality": 0.95, "section_id": 5364}, "so_36761617_36761692_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 5313}}, "n3337": {"so_36761617_36761957_2": {"length": 19, "quality": 0.95, "section_id": 5160}, "so_36761617_36761692_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 5110}}, "n4659": {"so_36761617_36761957_2": {"length": 19, "quality": 0.95, "section_id": 6788}, "so_36761617_36761692_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 6737}}}, "36761719": {"Id": "36761719", "PostTypeId": "2", "Body": "<p><code>\\'</code> is a valid character escape sequence in both C and C++. Hence, the lines</p>\n<pre><code>char* str1 = \"Tom's cat\";\nchar* str2 = \"Tom\\'s cat\";\n</code></pre>\n<p>produce equivalent string literals, both in C and C++.</p>\n", "LastActivityDate": "2016-04-21T06:49:16.420", "CommentCount": "0", "CreationDate": "2016-04-21T06:49:16.420", "ParentId": "36761617", "Score": "2", "OwnerUserId": "434551"}, "36761692": {"Id": "36761692", "PostTypeId": "2", "Body": "<p>Yes, within a string literal, both are the same.</p>\n<p>The escaped version is required for a character literal:</p>\n<pre><code>char x = '\\'';\n</code></pre>\n<p>The standard references are two sources. First, translation phases. From C.11 \u00a75.1.1.2 (C++.11 [<strong>lex.phases</strong>] has similar language):</p>\n<blockquote id=\"so_36761617_36761692_0\">\n<ol start=\"5\">\n<li><strong>Each source character set member and escape sequence in character constants and string literals is converted to the corresponding member of the execution character set</strong>; if there is no corresponding member, it is converted to an implementation defined member other than the null (wide) character.</li>\n</ol>\n</blockquote>\n<p>Next is in the grammar definition for a character constant and for string literals, which allow for escape sequences. And <em>simple-escape-sequence</em> is an escape sequence in the grammar. C.11 \u00a76.4.4.4 defines it (C++.11 [<strong>lex.ccon</strong>] has the same definition):</p>\n<blockquote>\n<p id=\"so_36761617_36761692_1\"><em>simple-escape-sequence:</em> one of</p>\n<pre><code>\\' \\\" \\? \\\\\n\\a \\b \\f \\n \\r \\t \\v\n</code></pre>\n</blockquote>\n<p>Finally, for string literals, the standard specifies the interpretation of characters in the literal is the same as if each were a character constant, and then makes an exception of <code>'</code>. From C.11 \u00a76.4.5 (C++.11 [<strong>lex.string</strong>] has similar language):</p>\n<blockquote>\n<p id=\"so_36761617_36761692_2\">The same considerations apply to each element of the sequence in a string literal as if it\n  were in an integer character constant (for a character or UTF\u22128 string literal) or a wide\n  character constant (for a wide string literal), except that the single-quote <code>'</code> is\n  representable either by itself or by the escape sequence <code>\\'</code>, but the double-quote \" shall be represented by the escape sequence <code>\\\"</code>.</p>\n</blockquote>\n", "LastEditorUserId": "315052", "LastActivityDate": "2016-04-21T07:10:25.917", "Score": "4", "CreationDate": "2016-04-21T06:48:13.493", "ParentId": "36761617", "CommentCount": "0", "OwnerUserId": "315052", "LastEditDate": "2016-04-21T07:10:25.917"}, "36761617": {"ViewCount": "126", "Body": "<pre><code>int main()\n{\n    char* str1 = \"Tom's cat\";\n    char* str2 = \"Tom\\'s cat\";\n}\n</code></pre>\n<p>The code can be compiled with VS 2015.</p>\n<p>I just wonder: </p>\n<p><strong>Are both of the two ways compliant to the C and/or the C++ standard?</strong></p>\n", "AcceptedAnswerId": "36761957", "Title": "Is \"'\" identical to \"\\'\" as per the C/C++ standard?", "CreationDate": "2016-04-21T06:44:04.087", "Id": "36761617", "CommentCount": "0", "LastEditDate": "2016-04-21T06:54:31.600", "PostTypeId": "1", "LastEditorUserId": "508343", "LastActivityDate": "2016-04-21T07:10:25.917", "Score": "5", "OwnerUserId": "508343", "Tags": "<c++><c><escaping><standards><language-specifications>", "AnswerCount": "4"}, "36761957": {"Id": "36761957", "PostTypeId": "2", "Body": "<p>From the <code>C++11 ISO Standard</code></p>\n<blockquote>\n<p id=\"so_36761617_36761957_0\"><strong>\u00a7 2.14.5 String Literals</strong> [lex.string]</p>\n<p id=\"so_36761617_36761957_1\">...</p>\n<p id=\"so_36761617_36761957_2\"><strong>15</strong> Escape sequences and universal-character-names in non-raw string literals have the same meaning as in character literals (2.14.3), except that the single quote \u2019 is representable either by itself or by the escape\n  sequence \\\u2019</p>\n</blockquote>\n", "LastActivityDate": "2016-04-21T06:58:53.127", "CommentCount": "0", "CreationDate": "2016-04-21T06:58:53.127", "ParentId": "36761617", "Score": "6", "OwnerUserId": "3807729"}, "36761735": {"Id": "36761735", "PostTypeId": "2", "Body": "<p>Yes, they're identical.</p>\n<p>From the c++ standard, $2.13.3/7 Character literals [lex.ccon]</p>\n<blockquote>\n<p id=\"so_36761617_36761735_0\">Table 6 \u2014 Escape sequences</p>\n<pre><code>new-line         NL(LF) \\n\nhorizontal tab   HT     \\t\nvertical tab     VT     \\v\nbackspace        BS     \\b\ncarriage return  CR     \\r\nform feed        FF     \\f\nalert            BEL    \\a\nbackslash        \\      \\\\\nquestion mark    ?      \\?\nsingle quote     \u2019      \\\u2019\ndouble quote     \"      \\\"\noctal number     ooo    \\ooo\nhex number       hhh    \\xhhh\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-04-21T06:56:18.567", "Score": "2", "CreationDate": "2016-04-21T06:50:01.783", "ParentId": "36761617", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-04-21T06:56:18.567"}});