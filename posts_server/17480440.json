post_cb({"bq_ids": {"n4140": {"so_17480440_17480596_1": {"length": 16, "quality": 0.8, "section_id": 5988}, "so_17480440_17480596_0": {"length": 25, "quality": 1.0, "section_id": 5425}, "so_17480440_17480790_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6185}}, "n3337": {"so_17480440_17480596_1": {"length": 16, "quality": 0.8, "section_id": 5756}, "so_17480440_17480596_0": {"length": 25, "quality": 1.0, "section_id": 5220}, "so_17480440_17480790_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 5946}}, "n4659": {"so_17480440_17480596_1": {"length": 16, "quality": 0.8, "section_id": 7488}, "so_17480440_17480596_0": {"length": 18, "quality": 0.72, "section_id": 6847}, "so_17480440_17480790_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7687}}}, "17480440": {"ViewCount": "211", "Body": "<p>As expected, I can compile the sample below without any problems</p>\n<pre><code>// first_sample.cpp\nstruct sample_struct\n{\n    constexpr int \n    sample_method() \n    { return 5; }\n};\n\nint main() \n{\n    sample_struct sample_object;\n    constexpr int sample_variable = sample_object.sample_method();\n    return 0;\n}\n</code></pre>\n<p>But i cannot compile the following sample for the reason </p>\n<blockquote>\n<p id=\"so_17480440_17480440_0\">'this' is not a constant expression</p>\n</blockquote>\n<pre><code>// second_sample.cpp\nstruct sample_struct\n{\n    constexpr int \n    sample_method_first() \n    { return 5; }\n\n    void \n    sample_method_second() \n    {   constexpr int sample_variable = sample_method_first(); \n        /* Do something with sample_variable */ }\n};\n\nint main() \n{ return 0; }\n</code></pre>\n<p>I already know how to solve this <em>\"problem\"</em> so i am not asking for a solution.\nI am asking for a reasonable explanation why i am allowed to call a constexpr method from a\nnon-constexpr object <strong>while i am not allowed</strong> to call the same constexpr method inside another method (from non-constexpr 'this').</p>\n", "AcceptedAnswerId": "17480596", "Title": "Using a constexpr method inside another method of the same class in C++", "CreationDate": "2013-07-05T02:54:50.003", "Id": "17480440", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-07-05T05:39:41.530", "Score": "4", "OwnerUserId": "2464690", "Tags": "<c++>", "AnswerCount": "2"}, "17480790": {"Id": "17480790", "PostTypeId": "2", "Body": "<p>A <code>constexpr</code> function may be called in any context, constant expression or not. (And your <code>sample_method_second</code> isn't even <code>constexpr</code>.) But a <code>constexpr</code> object must be evaluated at compile time.</p>\n<p>So what <code>sample_method_second</code> does is ask the compiler to use <code>this</code> to get the result of <code>sample_method_first</code> at compile time. Clearly that's impossible.</p>\n<p>The difference is that in the first example, the scope of <code>main</code> allows the compiler to call the method <em>on <code>sample_object</code></em>. But being able to evaluate the value of one object does not extend to all potential objects in the program, which is what <code>sample_method_second</code> does.</p>\n<p>The solution (well, aside from making <code>sample_method_first</code> independent of <code>this</code> using <code>static</code>) is not to declare <code>sample_variable</code> as <code>constexpr</code>. If you're using it in a way that requires <code>constexpr</code>, then your design is flawed because the one member function would actually need multiple (potentially infinite) implementations in the final program.</p>\n<p>Remember, each potential different value of a legitimately <code>constexpr</code> variable may produce a new template instantiation, a differently-organized <code>switch</code>, or halt compilation with a <code>static_assert</code>. Try doing that retroactively at runtime!</p>\n<hr>\n<p>As for why the first case is allowed:</p>\n<pre><code>sample_struct sample_object;\nconstexpr int sample_variable = sample_object.sample_method();\n</code></pre>\n<p>What's happening here is <code>constexpr</code> function invocation, and the rule for that excludes</p>\n<blockquote>\n<p id=\"so_17480440_17480790_0\">\u2014 an invocation of a function other than a constexpr constructor for a literal class, a constexpr function, or an implicit invocation of a trivial destructor (12.4)</p>\n</blockquote>\n<p>There simply isn't a requirement that the object be <code>constexpr</code> because if something needs to be constant to evaluate the inside of the function, or use the result of the function, the evaluation will go awry according to one of the other rules such as lvalue-to-rvalue conversion. You won't be able to modify <code>sample_method</code> to actually access anything, and doing so will complain that <code>sample_object</code> is not declared <code>constexpr</code>, or that its address is not constant if you try to use the value of <code>this</code> directly.</p>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2013-07-05T04:49:08.397", "Score": "0", "CreationDate": "2013-07-05T03:49:02.727", "ParentId": "17480440", "CommentCount": "11", "OwnerUserId": "153285", "LastEditDate": "2013-07-05T04:49:08.397"}, "17480596": {"Id": "17480596", "PostTypeId": "2", "Body": "<p>In the C++ Standard, [dcl.constexpr]/9:</p>\n<blockquote>\n<p id=\"so_17480440_17480596_0\">A constexpr specifier used in an object declaration declares the object as const. Such an object shall have literal type and shall be initialized. [...] Otherwise, or if a constexpr specifier is used in a reference declaration, every full-expression that appears in its initializer shall be a constant expression.</p>\n</blockquote>\n<p>Now, the compiler implicitly adds a <code>this-&gt;</code> to the member function call, as specified by [expr.call]/1</p>\n<blockquote>\n<p id=\"so_17480440_17480596_1\">In the case of an implicit class member access, the implied object is the one pointed to by this. [Note: a member function call of the form <code>f()</code> is interpreted as <code>(*this).f()</code> (see 9.3.1). \u2014end note ]</p>\n</blockquote>\n<p>As <a href=\"https://stackoverflow.com/users/777186/jogojapan\">jogojapan</a> has pointed out (see <a href=\"http://chat.stackoverflow.com/rooms/32920/discussion-between-dyp-and-jogojapan\">chat discussion</a>), in the official C++11 Standard, <code>this</code> may occur as postfix-expression in a class member access as per [expr.const]/2, which is the case here. But the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1369\" rel=\"nofollow noreferrer\">Issue 1369</a> disallowed any use of <code>this</code> in constant expressions; however function invocation substitution can allow using <code>this</code> within the context of a <code>constexpr</code> function by replacing it with a prvalue pointer.</p>\n<p>The C++14 draft removes the sub-paragraph about <em>function invocation substitution</em> in favour of an exception to [expr.const]/2, explicitly allowing the use of <code>this</code> within the context of a <code>constexpr</code> function (in this case effectively the same as what function invocation substitution allowed).</p>\n<hr>\n<p>Well, this isn't very \"reasonable\" as it doesn't provide the <em>reason why it is specified in this way</em>, it only provides the reason why the compiler rejects it.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-05T05:39:41.530", "Score": "3", "CreationDate": "2013-07-05T03:17:33.447", "ParentId": "17480440", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T11:56:31.330"}});