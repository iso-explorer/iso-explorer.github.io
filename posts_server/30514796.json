post_cb({"30514941": {"ParentId": "30514796", "CommentCount": "2", "Body": "\n<p>An enumeration with an <em>enum-key</em> of <code>class</code> or <code>struct</code> is a <em>scoped enumeration</em>. Scoped enumerations don't have an implicit conversion to <code>int</code>.</p>\n<blockquote>\n<p id=\"so_30514796_30514941_0\">The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by integral promotion (4.5). <em>[ Example:</em></p>\n<pre class=\"lang-c++ prettyprint-override\"><code>enum color { red, yellow, green=20, blue };\ncolor col = red;\ncolor* cp = &amp;col;\nif (*cp == blue) // ...\n</code></pre>\n<p id=\"so_30514796_30514941_1\">makes color a type describing various colors, and then declares <code>col</code> as an object of that type, and <code>cp</code> as a pointer to an object of that type. The possible values of an object of type <code>color</code> are <code>red</code>, <code>yellow</code>, <code>green</code>,\n  <code>blue</code>; these values can be converted to the integral values <code>0</code>, <code>1</code>, <code>20</code>, and <code>21</code>. Since enumerations are distinct types, objects of type <code>color</code> can be assigned only values of type <code>color</code>.</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>color c = 1; // error: type mismatch,\n// no conversion from int to color\nint i = yellow; // OK: yellow converted to integral value 1\n// integral promotion\n</code></pre>\n<p id=\"so_30514796_30514941_2\"><strong>Note that this implicit <code>enum</code> to <code>int</code> conversion is not provided for a scoped enumeration:</strong></p>\n<pre class=\"lang-c++ prettyprint-override\"><code>enum class Col { red, yellow, green };\nint x = Col::red; // error: no Col to int conversion\nCol y = Col::red;\nif (y) { } // error: no Col to bool conversion\n</code></pre>\n<p id=\"so_30514796_30514941_3\"><em>\u2014 end example ]</em></p>\n</blockquote>\n<p>You can explicitly cast the enumerator to <code>int</code> instead:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>cout &lt;&lt; employeeArray[static_cast&lt;int&gt;(Employees::RYAN)].name;\n</code></pre>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "30514941", "Score": "7", "CreationDate": "2015-05-28T18:56:10.020", "LastActivityDate": "2015-05-28T18:56:10.020"}, "bq_ids": {"n4140": {"so_30514796_30514941_1": {"section_id": 5469, "quality": 0.975609756097561, "length": 40}, "so_30514796_30514941_0": {"section_id": 5469, "quality": 0.8333333333333334, "length": 10}, "so_30514796_30514936_0": {"section_id": 5986, "quality": 1.0, "length": 20}, "so_30514796_30514941_2": {"section_id": 5469, "quality": 1.0, "length": 8}}, "n3337": {"so_30514796_30514941_1": {"section_id": 5255, "quality": 0.975609756097561, "length": 40}, "so_30514796_30514941_0": {"section_id": 5255, "quality": 0.8333333333333334, "length": 10}, "so_30514796_30514936_0": {"section_id": 5754, "quality": 0.95, "length": 19}, "so_30514796_30514941_2": {"section_id": 5255, "quality": 1.0, "length": 8}}, "n4659": {"so_30514796_30514941_1": {"section_id": 6903, "quality": 0.975609756097561, "length": 40}, "so_30514796_30514941_0": {"section_id": 6903, "quality": 0.8333333333333334, "length": 10}, "so_30514796_30514936_0": {"section_id": 7486, "quality": 0.9, "length": 18}, "so_30514796_30514941_2": {"section_id": 6903, "quality": 1.0, "length": 8}}}, "30514936": {"ParentId": "30514796", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C++ Standard (5.2.1 Subscripting)</p>\n<blockquote>\n<p id=\"so_30514796_30514936_0\">1 A postfix expression followed by an expression in square brackets is\n  a postfix expression. One of the expressions shall have the type\n  \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have <strong>unscoped\n  enumeration or integral type</strong>....</p>\n</blockquote>\n<p>There is no implicit conversion from a scoped enumeration to an integral type.</p>\n<p>If you want to use a scoped enumeration as an index you have explicitly cast it to some integral type. \nFor example</p>\n<pre><code>cout &lt;&lt; employeeArray[static_cast&lt;int&gt;( Employees::RYAN )].name;\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-05-28T19:03:03.233", "Id": "30514936", "Score": "0", "CreationDate": "2015-05-28T18:55:59.253", "LastActivityDate": "2015-05-28T19:03:03.233"}, "30514796": {"CommentCount": "1", "ViewCount": "285", "CreationDate": "2015-05-28T18:48:43.443", "LastActivityDate": "2015-05-28T19:03:03.233", "Title": "Using enumerated class values to call an array element in C++", "AcceptedAnswerId": "30514941", "PostTypeId": "1", "Id": "30514796", "Score": "5", "Body": "<p>My code:</p>\n<p>Enumerations.h</p>\n<pre><code>#ifndef ENUMERATIONS_H\n#define ENUMERATIONS_H\n\nenum class Employees\n{\n    ERIC,\n    RYAN,\n    EMILY\n};\n\n#endif\n</code></pre>\n<p>Structs.h</p>\n<pre><code>struct Employee\n{\n    std::string name;\n    double wage;\n};\n</code></pre>\n<p>Review.cpp</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include \"Enumerations.h\"\n#include \"Structs.h\"\n\nEmployee employeeArray[3];\n\n    employeeArray[0] = { \"Eric Sartor\", 18.75 };\n    employeeArray[1] = { \"Ryan Ulch\", 20.36 };\n    employeeArray[2] = { \"Emily Gover\", 18.75 };\n\ncout &lt;&lt; employeeArray[Employees::RYAN].name;\n</code></pre>\n<p>So I'm trying to do something that I read in my C++ tutorial, where you call an array element (a struct) via an enumerated value.  Earlier in the tutorial, it's recommended that if you compiler is C++11 compliant (which mine is) that is it better to use an enumerated class rather than a regular enumeration. </p>\n<p>I'm noticing that when trying to call my element from my array via the <code>Employees::RYAN</code> enumerated value, it gives me an error that says \"expression must have integral or unscoped enum type\".  If I remove the class keyword from my enumeration so it's just <code>enum Employees</code> and I change the array index to <code>RYAN</code>, it works fine.  Am I missing something, or does this just not work with an enumerated class?</p>\n<p>Hopefully I was clear enough.  In the example on the tutorial, he actually DID NOT use an enumerated class, just a regular enumeration, even though he explicitly said earlier to always do that if you can...hopefully someone can clarify this for me!</p>\n", "Tags": "<c++><arrays><c++11><struct><enums>", "OwnerUserId": "4648089", "AnswerCount": "2"}});