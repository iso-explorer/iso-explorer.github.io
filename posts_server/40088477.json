post_cb({"40089037": {"ParentId": "40088477", "CommentCount": "0", "Body": "<p>The first example shouldn't compile because you cannot have compiletime-only constexpr functions (or overload on compiletime-ness, like D's <a href=\"https://dlang.org/spec/function.html#interpretation\" rel=\"nofollow\"><code>__cfte</code></a>).</p>\n<p>Following this reasoning, if you called first example's <code>f</code> at runtime, what would its return type be?</p>\n<p>As to the side question: Boost Hana, despite supporting only the newest standard, only uses string literals for runtime stuff, so it may not be possible.</p>\n", "OwnerUserId": "2456565", "PostTypeId": "2", "Id": "40089037", "Score": "0", "CreationDate": "2016-10-17T14:27:31.390", "LastActivityDate": "2016-10-17T14:27:31.390"}, "40088477": {"CommentCount": "5", "ViewCount": "63", "CreationDate": "2016-10-17T14:01:38.113", "LastActivityDate": "2016-10-17T14:28:27.030", "Title": "Templates, arrays and constant expressions", "AcceptedAnswerId": "40089058", "PostTypeId": "1", "Id": "40088477", "Score": "3", "Body": "<p>Consider the code below:</p>\n<pre><code>template&lt;char&gt;\nstruct S { }; \n\ntemplate&lt;int N&gt;\nconstexpr auto f(const char (&amp;ref) [N]) {\n    return S&lt;ref[0]&gt;{};\n}\n\nint main() {\n    constexpr auto v = f(\"foo\");\n    (void)v;\n}\n</code></pre>\n<p>It doesn't compile for <code>ref[0]</code> is not a constant expression.</p>\n<p>Anyway, the code below compiles fine:</p>\n<pre><code>template&lt;int N&gt;\nconstexpr auto f(const char (&amp;ref) [N]) {\n    return ref[0];\n}\n\nint main() {\n    constexpr auto v = f(\"foo\");\n    (void)v;\n}\n</code></pre>\n<p>Should both of them compile or fail to do that for more or less the same reason?</p>\n<p>From <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow\">[expr.const]</a> we have that:</p>\n<blockquote>\n<p id=\"so_40088477_40088477_0\">A conditional-expression <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code> [...] would evaluate one of the following expressions:<br>\n  [...]<br>\n  - an id-expression that refers to a variable or data member of reference type unless the reference has a preceding initialization and either<br>\n  \u00a0\u00a0\u00a0\u00a0- it is initialized with a constant expression or<br>\n  \u00a0\u00a0\u00a0\u00a0- its lifetime began within the evaluation of <code>e</code>;</br></br></br></br></p>\n</blockquote>\n<p>Anyway, in this case, it is initialized with a constant expression <strong>and</strong> the lifetime is the same of <code>e</code>, thus the rule doesn't apply.</p>\n<p>What's wrong in my reasoning?</p>\n<p>As a side question, I would ask if it's possible to use such an array or part of it as a template argument.</p>\n", "Tags": "<c++><templates><constant-expression><template-deduction>", "OwnerUserId": "4987285", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40088477_40088477_0": {"section_id": 6185, "quality": 0.9310344827586207, "length": 27}, "so_40088477_40089058_1": {"section_id": 6185, "quality": 0.7910447761194029, "length": 53}, "so_40088477_40089058_0": {"section_id": 87, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_40088477_40088477_0": {"section_id": 5946, "quality": 0.6551724137931034, "length": 19}, "so_40088477_40089058_1": {"section_id": 5946, "quality": 0.5970149253731343, "length": 40}, "so_40088477_40089058_0": {"section_id": 82, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_40088477_40088477_0": {"section_id": 7687, "quality": 0.896551724137931, "length": 26}, "so_40088477_40089058_1": {"section_id": 7687, "quality": 0.8805970149253731, "length": 59}, "so_40088477_40089058_0": {"section_id": 90, "quality": 0.8888888888888888, "length": 8}}}, "40089058": {"ParentId": "40088477", "CommentCount": "0", "Body": "<p>This:</p>\n<pre><code>template&lt;int N&gt;\nconstexpr auto f(const char (&amp;ref) [N]) {\n    return S&lt;ref[0]&gt;{};\n}\n</code></pre>\n<p>is ill-formed because according to [temp.arg.nontype]:</p>\n<blockquote>\n<p id=\"so_40088477_40089058_0\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a converted constant expression (5.20) of\n  the type of the <em>template-parameter</em>.</p>\n</blockquote>\n<p>and from [expr.const]:</p>\n<blockquote>\n<p id=\"so_40088477_40089058_1\">A <em>conditional-expression</em> e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions: [...]<br>\n  (2.7) \u2014 an lvalue-to-rvalue conversion (4.1) unless it is applied to<br>\n  (2.7.1) \u2014 a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile const\n  object with a preceding initialization, initialized with a constant expression, or<br>\n  (2.7.2) \u2014 a non-volatile glvalue that refers to a subobject of a string literal (2.13.5), or<br>\n  (2.7.3) \u2014 a non-volatile glvalue that refers to a non-volatile object defined with constexpr, or that refers to\n  a non-mutable sub-object of such an object, or<br>\n  (2.7.4) \u2014 a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within\n  the evaluation of e;</br></br></br></br></br></p>\n</blockquote>\n<p><code>ref[0]</code> requires an lvalue-to-rvalue conversion and none of those sub-bullets apply. Note that <code>ref</code> is not a string literal, so 2.7.2 doesn't apply, nor is it defined with <code>constexpr</code>, because it's a function argument and we don't have that capability. </p>\n<p>We basically need the ability to pass string literals <em>as literals</em>, which doesn't exist yet. </p>\n<hr/>\n<p>The other example:</p>\n<pre><code>template&lt;int N&gt;\nconstexpr auto f(const char (&amp;ref) [N]) {\n    return ref[0];\n}\n</code></pre>\n<p>doesn't have the converted constant expression required - that one was brought in by the template non-type argument. This code is fine, and would only be problematic if you tried to initialize a <code>constexpr</code> variable with a non-<code>constexpr</code> array value. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "40089058", "Score": "1", "CreationDate": "2016-10-17T14:28:27.030", "LastActivityDate": "2016-10-17T14:28:27.030"}});