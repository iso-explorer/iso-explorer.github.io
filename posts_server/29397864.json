post_cb({"29397864": {"CommentCount": "4", "AcceptedAnswerId": "29404063", "PostTypeId": "1", "LastEditorUserId": "938111", "CreationDate": "2015-04-01T18:13:08.883", "LastActivityDate": "2016-06-14T07:57:05.647", "LastEditDate": "2016-06-14T07:57:05.647", "ViewCount": "3721", "FavoriteCount": "2", "Title": "Why does constexpr static member (of type class) require a definition?", "Id": "29397864", "Score": "6", "Body": "<p>==&gt; See the full snippet code and compilation on <a href=\"http://coliru.stacked-crooked.com/a/e6ebe0ef8a87b601\" rel=\"nofollow\">coliru</a>.</p>\n<p>I have a <a href=\"http://en.cppreference.com/w/cpp/concept/LiteralType\" rel=\"nofollow\">LiteralType</a> class filling <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\"><code>constexpr</code> requirements</a>:</p>\n<pre><code>struct MyString\n{\n    constexpr MyString(char const* p, int s) : ptr(p), sz(s) {}\n    constexpr char const* data() const { return ptr; }\n    constexpr int         size() const { return sz;  }\n\n    char const *ptr = 0;\n    int  const  sz  = 0;\n};\n</code></pre>\n<p>I use it as a <a href=\"http://en.cppreference.com/w/cpp/language/static#Constant_static_members\" rel=\"nofollow\"><code>constexpr static</code></a> member variable:</p>\n<pre><code>struct Foo\n{\n    int size() { return str_.size(); }\n\n    constexpr static MyString str_{\"ABC\",3};\n};\n\nint main()\n{\n  Foo foo;\n  return ! foo.size();\n}\n</code></pre>\n<p>But the linker says:<br>\n<sup>(Clang-3.5 and GCC-4.9)</sup></br></p>\n<pre><code>undefined reference to `Foo::str_'\n</code></pre>\n<p>I have to define the <code>constexpr static</code> member!<br>\n<sup>(I do not specify the constructor parameters)</sup></br></p>\n<pre><code>constexpr MyString Foo::str_;\n</code></pre>\n<p>However if the <code>constexpr static</code> member had been an <code>int</code> the member would not have to be defined outside the class definition. This is my understanding, but I am not sure...</p>\n<h3>Questions:</h3>\n<ul>\n<li>Why <code>int</code> does not need to be defined outside the class declaration but <code>MyString</code> requires this?</li>\n<li>Is there a disadvantage to define a <code>constexpr static</code> member in a header file? <br> (I provide my library as header files only)</br></li>\n</ul>\n", "Tags": "<c++><c++11><static-members><c++14><constexpr>", "OwnerUserId": "938111", "AnswerCount": "1"}, "29404063": {"ParentId": "29397864", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">One Definition rule</a> tells us that we can not have more than one definition of an <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">odr-used</a> variable in a program. So if a variable is odr-used then you need to define it but you can not define it the header file since it may be included more than once with the whole program. Odr-use violations do not require a diagnostic message and so you can violate this rule and the compiler is not obliged to notify you.</p>\n<p>In your case you are indeed odr-using <code>str_</code>, and you can not include the definition in the header file because that would violate the one definiton rule since it can be included more than once within the program.</p>\n<p>It is interesting to note that if you had done the following it would not have been odr-used:</p>\n<pre><code>return str_.size_;\n</code></pre>\n<p>You would therefore not need to define the variable, <a href=\"https://stackoverflow.com/q/28506342/1708801\">which can have some odd consequences in some examples</a>. I doubt that really solves your problem long-term.</p>\n<p>The odr rules are covered in the draft C++ standard section <code>3.2</code> and they say:</p>\n<blockquote>\n<p id=\"so_29397864_29404063_0\">A variable x whose name appears as a potentially-evaluated expression\n  ex is odr-used unless applying the lvalue-to-rvalue conversion (4.1)\n  to x yields a constant expression (5.19) that does not invoke any\n  non-trivial functions and, if x is an object, ex is an element of the\n  set of potential results of an expression e, where either the\n  lvalue-to-rvalue conversion (4.1) is applied to e, or e is a\n  discarded-value expression (Clause 5). this is odr-used if it appears\n  as a potentially-evaluated expression (including as the result of the\n  implicit transformation in the body of a non-static member function\n  (9.3.1)).[...]</p>\n</blockquote>\n<p>So <code>str_</code> yield a constant expression, the lvalue-to-rvalue conversion is not applied the expression <code>str_.size()</code> and it is not a discarded value expression, so it is odr-used and therefore <code>str_</code> is required to be defined.</p>\n<p>On the other hand the lvalue-to-rvalue conversion is applied to the expression <code>str_.size_</code>, so it is not odr-used and does not require <code>str_</code> to be defined.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:21.377", "Id": "29404063", "Score": "4", "CreationDate": "2015-04-02T02:29:29.717", "LastActivityDate": "2015-04-02T19:29:35.647"}, "bq_ids": {"n4140": {"so_29397864_29404063_0": {"section_id": 7040, "quality": 0.8888888888888888, "length": 40}}, "n3337": {"so_29397864_29404063_0": {"section_id": 6785, "quality": 0.5111111111111111, "length": 23}}, "n4659": {"so_29397864_29404063_0": {"section_id": 8537, "quality": 0.8888888888888888, "length": 40}}}});