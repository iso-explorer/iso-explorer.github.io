post_cb({"13485256": {"CommentCount": "2", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "1456962", "CreationDate": "2012-11-21T01:59:29.307", "LastActivityDate": "2012-11-21T02:54:01.037", "Title": "Extracting two signed integers from one given integer?", "AcceptedAnswerId": "13485394", "LastEditDate": "2012-11-21T02:16:32.667", "Id": "13485256", "Score": "0", "Body": "<p>I have the following structure:</p>\n<pre><code>struct\n{\n   int a:4;\n   int b:7;\n   int c:21;\n} example;\n</code></pre>\n<p>I would like to combine a and b to form an integer d in C++. For instance, I would like the bit values of a to be on the left of the bit values of b in order to form integer d. How is this implemented in c++? </p>\n<p>Example:</p>\n<p>a= 1001</p>\n<p>b = 1010101</p>\n<p>I would like int d  =  10011010101 xxxxxxxxxxxxxxxxxxxxx</p>\n<p>where x can be 21 bits that belonged to d previously. I would like the values of a and b to be put in bit positions 0-3 and 4-10 respectively since a occupies the first 4 bits and b occupies the next 7 bits in the struct \"example\".</p>\n<p>The part that I am confused about is that variable a and variable b both have a \"sign\" bit at the most significant bit. Does this affect the outcome? Are all bits in variable a and variable b used in the end result for integer d? Will integer d look like a concatenation of variable a's bits and variable b's bits?</p>\n<p>Thanks</p>\n", "Tags": "<c++><bit-manipulation>", "OwnerUserId": "1456962", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13485256_13485394_0": {"section_id": 5439, "quality": 0.72, "length": 18}}, "n3337": {"so_13485256_13485394_0": {"section_id": 5234, "quality": 0.84, "length": 21}, "so_13485256_13485394_1": {"section_id": 5695, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_13485256_13485394_0": {"section_id": 6866, "quality": 0.68, "length": 17}}}, "13485394": {"ParentId": "13485256", "LastEditDate": "2012-11-21T02:54:01.037", "CommentCount": "3", "CreationDate": "2012-11-21T02:17:55.463", "OwnerUserId": "15168", "LastEditorUserId": "15168", "PostTypeId": "2", "Id": "13485394", "Score": "2", "Body": "<p>Note that whether an <code>int</code> bit-field is signed or unsigned is implementation-defined.  The C++ standard says this, and the C standard achieves the same net result with different wording:</p>\n<h2>ISO/IEC 14882:2011 \u2014 C++</h2>\n<blockquote>\n<h3>\u00a77.1.6.2 Simple type specifiers</h3>\n<p id=\"so_13485256_13485394_0\">\u00b63 ... [ Note: It is implementation-defined whether objects of <code>char</code> type and certain bit-fields (9.6) are\n  represented as signed or unsigned quantities. The <code>signed</code> specifier forces <code>char</code> objects and bit-fields to be\n  signed; it is redundant in other contexts. \u2014end note ]</p>\n<h3>\u00a79.6 Bit-fields</h3>\n<p id=\"so_13485256_13485394_1\">\u00b63 ... A bit-field shall have integral or enumeration type (3.9.1). It is\n  implementation-defined whether a plain (neither explicitly signed nor unsigned) <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>,\n  or <code>long long</code> bit-field is signed or unsigned.</p>\n</blockquote>\n<h2>ISO/IEC 9899:2011 \u2014 C</h2>\n<blockquote>\n<h3>\u00a76.7.2.1 Structure and union specifiers</h3>\n<p id=\"so_13485256_13485394_2\">\u00b610 A bit-field is interpreted as having a signed or unsigned integer type consisting of the specified number of bits.<sup>125)</sup></p>\n<p id=\"so_13485256_13485394_3\"><sup>125)</sup> As specified in 6.7.2 above, if the actual type specifier used is int or a typedef-name defined as int, then it is implementation-defined whether the bit-field is signed or unsigned. </p>\n<h3>\u00a76.7.2 Type specifiers</h3>\n<p id=\"so_13485256_13485394_4\">\u00b65 ... for bit-fields, it is implementation-defined whether the specifier <code>int</code> designates the same type as <code>signed int</code> or the same type as <code>unsigned int</code>.</p>\n</blockquote>\n<p>The context of \u00a76.7.2 shows that <code>int</code> can be combined with <code>short</code>, <code>long</code> etc and the rule will apply; C++ specifies that a bit more clearly.  The signedness of plain <code>char</code> is implementation-defined already, of course.</p>\n<hr>\n<h2>Unsigned bit-fields</h2>\n<p>If the type of the bit-fields are unsigned, then the expression is fairly straight-forward:</p>\n<pre><code>int d = (example.a &lt;&lt; 7) | example.b;\n</code></pre>\n<h2>Signed bit-fields</h2>\n<p>If the values are signed, then you have a major interpretation exercise to undertake, deciding what the value should be if <code>example.a</code> is negative and <code>example.b</code> is positive, or vice versa.  To some extent, the problem arises even if the values are both negative or both positive.</p>\n<p>Suppose <code>example.a = 7;</code> and <code>example.b = 12;</code> \u2014 what should be the value of <code>d</code>?  Probably the same expression applies, but you could argue that it would be better to shift by 1 fewer places:</p>\n<pre><code>assert(example.a &gt;= 0 &amp;&amp; example.b &gt;= 0);\nint d = (example.a &lt;&lt; 6) | example.b;      // Alternative interpretation\n</code></pre>\n<p>The other cases are left for you to decide; it depends on the interpretation you want to place on the values.  For example:</p>\n<pre><code>int d = ((example.a &amp; 0x0F) &lt;&lt; 7) | (example.b &amp; 0x7F);\n</code></pre>\n<p>This forces the signed values to be treated as unsigned. It probably isn't what you're after.</p>\n<hr>\n<h2>Modified question</h2>\n<blockquote>\n<pre><code>example.a = 1001     // binary\n\nexample.b = 1010101  // binary\n\nd = 10011010101 xxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<p id=\"so_13485256_13485394_5\">where x can be 21 bits that belonged to d previously.</p>\n</blockquote>\n<p>For this to work, then you need:</p>\n<pre><code>  d = (d &amp; 0x001FFFFF) | ((((example.a &amp; 0x0F) &lt;&lt; 7) | (example.b &amp; 0x7F)) &lt;&lt; 21);\n</code></pre>\n<p>You probably can use fewer parentheses; I'm not sure I'd risk doing so.</p>\n<h2>Union</h2>\n<p>However, with this revised specification, you might well be tempted to look at a <code>union</code> such as:</p>\n<pre><code>union u\n{\n    struct\n    {\n       int a:4;\n       int b:7;\n       int c:21;\n    } y;\n    int x;\n} example;\n</code></pre>\n<p>However, the layout of the bits in the bit-fields w.r.t the bits in the <code>int x;</code> is not specified (they could be most significant bits first or least significant bits first), and there are always mutterings about 'if you access a value in a union that wasn't the last one assigned to you invoke undefined behaviour'.   Thus you have multiple platform-defined aspects of the bit field to deal with.  In fact, this sort of conundrum generally means that bit-fields are closely tied to one specific type of machine (CPU) and compiler and operating system.  They are very, very non-portable at the level of detail you're after.</p>\n</hr></hr>", "LastActivityDate": "2012-11-21T02:54:01.037"}});