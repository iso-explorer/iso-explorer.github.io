post_cb({"bq_ids": {"n4140": {"so_4213523_4213523_6": {"length": 6, "quality": 0.6, "section_id": 5818}, "so_4213523_4213523_1": {"length": 20, "quality": 0.7142857142857143, "section_id": 1148}, "so_4213523_4213523_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 1226}}, "n3337": {"so_4213523_4213523_6": {"length": 6, "quality": 0.6, "section_id": 5589}, "so_4213523_4213523_1": {"length": 20, "quality": 0.7142857142857143, "section_id": 1145}, "so_4213523_4213523_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 1224}}, "n4659": {"so_4213523_4213523_6": {"length": 6, "quality": 0.6, "section_id": 7279}, "so_4213523_4213523_1": {"length": 20, "quality": 0.7142857142857143, "section_id": 1242}, "so_4213523_4213523_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 1315}}}, "4214294": {"Id": "4214294", "PostTypeId": "2", "Body": "<p>The answer here is not trivial. Exactly what happens and what is meant is dependent on many things.  For basic understanding of cache coherence/memory perhaps my recent blog entries might be helpful:</p>\n<ul>\n<li><a href=\"http://mortoray.wordpress.com/2010/11/18/cpu-reordering-what-is-actually-being-reordered/\" rel=\"nofollow\">CPU Reordering \u2013 What is actually being reordered?</a></li>\n<li><a href=\"http://mortoray.wordpress.com/2010/11/18/cpu-memory-why-do-i-need-a-mutex/\" rel=\"nofollow\">CPU Memory \u2013 Why do I need a mutex?</a></li>\n</ul>\n<p>But that aside, let me try to answer a few questions. First off the below instruction is being very hopeful as to what is supported.</p>\n<pre><code>compare_swap( C&amp; expected, C desired,\n        memory_order success, memory_order failure )\n</code></pre>\n<p>Architectures won't all be able to implement this exactly as you requested. When you specify memory_order you are specifying how reordering may work. To use intel's terms you will be specifying what type of fence you want, there are three of them, the full fence, load fence, and store fence. Just because you want a particular fence on that operation won't mean it is supported, in which I'd hope it always falls back to a full fence.</p>\n<p>The compiler will likely use the <code>CMPXCHG</code> instructuion to implement the call. If you have specified something other than relaxed it will mark this with <code>lock</code> to indicate the function should be atomic. Whether this is \"lock-free\" depends very much on what you are thinking about in terms of a \"lock.</p>\n<p>In terms of memory sync you need to understand how cache-coherence works (my blog may help a bit).  New CPUs use a ccNUMA architecture (previously SMP). Essentially the \"view\" on the memory never gets out-of-sync. The fences used in the code don't actually force any flushing to happen per-se. If two cores both have the same memory location cached in a cache-line, one will get marked dirty and the other will reload as necessary. <em>A very simple explanation for a very complex process</em></p>\n<p>To answer your last question you should always use the memory semantics that you logically need to be correct. Most architectures won't support all the combinations you use in your program. However, in many cases you'll get great optimizations, especially in cases where the order you requested is guaranteed without a fence (which is quite common).</p>\n<p><em>-- Answers to some comments:</em></p>\n<p>You have to distinguish between what it means to execute a write instruction and write to a memory location. This is what I attempt to explain in my blog post. By the time the \"0\" is committed to 0x100, all cores see that zero.  Writing integers is also atomic, that is even without a lock, when you write to a location all cores will immediately have that value if they wish to use it.  </p>\n<p>The trouble is that to use the value you have likely loaded it into a register first, any changes to the location after that obviously won't touch the register. This is why one needs mutexes despite a cache coherent memory.</p>\n<p>As to contradictory claims, generally you'll see all sorts of claims. Whether they are contradictory comes right down to exactly what \"see\" \"load\" \"execute\" mean in the context. If you write \"1\" to 0x100, does that mean you executed the write instruction or did the CPU actually commit that value. The difference comes from the reordering. The CPU can delay writing the \"1\", but you can be sure that the moment it does finally commit that \"1\" all cores see it. The fences control this ordering.</p>\n", "LastEditorUserId": "229686", "LastActivityDate": "2010-11-18T15:17:23.803", "Score": "7", "CreationDate": "2010-11-18T11:34:32.967", "ParentId": "4213523", "CommentCount": "6", "OwnerUserId": "229686", "LastEditDate": "2010-11-18T15:17:23.803"}, "4213523": {"ViewCount": "2131", "Body": "<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html#Introduction\" rel=\"noreferrer\">C++0x proposal</a> on C++ Atomic Types and Operations:</p>\n<blockquote>\n<h2>29.1 Order and Consistency [atomics.order]</h2>\n<p id=\"so_4213523_4213523_0\">Add a new sub-clause with the following paragraphs.</p>\n<p id=\"so_4213523_4213523_1\">The enumeration <code>memory_order</code> specifies the detailed regular (non-atomic) memory synchronization order as defined in [the new section added by N2334 or its adopted successor] and may provide for operation ordering. Its enumerated values and their meanings are as follows.</p>\n<ul>\n<li><code>memory_order_relaxed</code></li>\n</ul>\n<p id=\"so_4213523_4213523_2\">The operation does not order memory.</p>\n<ul>\n<li><code>memory_order_release</code></li>\n</ul>\n<p id=\"so_4213523_4213523_3\">Performs a release operation on the affected memory locations, thus making regular memory writes visible to other threads through the atomic variable to which it is applied.</p>\n<ul>\n<li><code>memory_order_acquire</code></li>\n</ul>\n<p id=\"so_4213523_4213523_4\">Performs an acquire operation on the affected memory locations, thus making regular memory writes in other threads released through the atomic variable to which it is applied, visible to the current thread.</p>\n<ul>\n<li><code>memory_order_acq_rel</code></li>\n</ul>\n<p id=\"so_4213523_4213523_5\">The operation has both acquire and release semantics.</p>\n<ul>\n<li><code>memory_order_seq_cst</code></li>\n</ul>\n<p id=\"so_4213523_4213523_6\">The operation has both acquire and release semantics, and in addition, has sequentially-consistent operation ordering.</p>\n</blockquote>\n<p>Lower in the proposal:</p>\n<blockquote>\n<pre><code>bool A::compare_swap( C&amp; expected, C desired,\n        memory_order success, memory_order failure ) volatile\n</code></pre>\n<p id=\"so_4213523_4213523_7\">where one can specify memory order for the CAS.</p>\n</blockquote>\n<hr>\n<p>My understanding is that \u201c<code>memory_order_acq_rel</code>\u201d will only necessarily synchronize those memory locations which are needed for the operation, while other memory locations may remain unsynchronized (it will not behave as a memory fence).</p>\n<p>Now, my question is - if I choose \u201c<code>memory_order_acq_rel</code>\u201d and apply <code>compare_swap</code> to integral types, for instance, integers, how is this typically translated into machine code on modern consumer processors such as a multicore Intel i7? What about the other commonly used architectures (x64, SPARC, ppc, arm)?</p>\n<p>In particular (assuming a concrete compiler, say gcc):</p>\n<ol>\n<li>How to compare-and-swap an integer location with the above operation?</li>\n<li>What instruction sequence will such a code produce?</li>\n<li>Is the operation lock-free on i7?</li>\n<li>Will such an operation run a full cache coherence protocol, synchronizing caches of different processor cores as if it were a memory fence on i7? Or will it just synchronize the memory locations needed by this operation?</li>\n<li>Related to previous question - is there any performance advantage to using <code>acq_rel</code> semantics on i7? What about the other architectures?</li>\n</ol>\n<p>Thanks for all the answers.</p>\n</hr>", "AcceptedAnswerId": "4214294", "Title": "Compare and swap C++0x", "CreationDate": "2010-11-18T09:54:29.270", "Id": "4213523", "CommentCount": "0", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2010-11-18T11:00:43.867", "LastEditorUserId": "301832", "LastActivityDate": "2010-11-18T15:17:23.803", "Score": "16", "OwnerUserId": "453594", "Tags": "<c++><multithreading><gcc><concurrency><compare-and-swap>", "AnswerCount": "1"}});