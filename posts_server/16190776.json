post_cb({"16190776": {"CommentCount": "0", "AcceptedAnswerId": "16190777", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-24T11:27:39.937", "LastActivityDate": "2015-07-22T15:00:56.917", "LastEditDate": "2017-05-23T11:51:09.570", "ViewCount": "289", "FavoriteCount": "1", "Title": "Do we still need to separately define static members, even if they are initialised inside the class definition?", "Id": "16190776", "Score": "2", "Body": "<p>In C++03, we had the ability to initialize <code>const</code> <code>static</code> class data members inline within the class definition, <a href=\"https://stackoverflow.com/a/7092830/560648\">but still had to <em>define</em> the member</a> <a href=\"https://stackoverflow.com/q/9786029/560648\">if it were to be <em>odr-used</em></a>.</p>\n<p>Is this still the case in C++11?</p>\n<pre><code>struct Foo\n{\n   static const int x = 3;\n};\n\nconst int Foo::x;\n// ^ required?\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "560648", "AnswerCount": "1"}, "16190777": {"ParentId": "16190776", "CommentCount": "2", "Body": "<h2>Yes.</h2>\n<blockquote>\n<p id=\"so_16190776_16190777_0\"><code>[C++11: 9.4.2/3]:</code> <strong>If a non-volatile <code>const</code> <code>static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression</strong> (5.19). A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. <em>[ Note:</em> In both these cases, the member may appear in constant expressions. <em>\u2014end note ]</em> <strong>The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an <em>initializer</em>.</strong></p>\n</blockquote>\n<p>This is comparable to the wording in C++03:</p>\n<blockquote>\n<p id=\"so_16190776_16190777_1\"><code>[C++03: 9.4.2/2]:</code> If a static data member is of <code>const</code> integral or <code>const</code> enumeration type, its declaration in the class definition can specify a <em>constant-initializer</em> which shall be an integral constant expression (5.19). In that case, the member can appear in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and the namespace scope definition shall not contain an <em>initializer</em>.</p>\n</blockquote>\n<p>As you can see, the rule itself hasn't changed at all, beyond the introduction of rules for <code>constexpr</code>.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "16190777", "Score": "6", "CreationDate": "2013-04-24T11:27:39.937", "LastActivityDate": "2013-04-24T11:27:39.937"}, "bq_ids": {"n4140": {"so_16190776_16190777_0": {"section_id": 5908, "quality": 0.8923076923076924, "length": 58}, "so_16190776_16190777_1": {"section_id": 5908, "quality": 0.717948717948718, "length": 28}}, "n3337": {"so_16190776_16190777_0": {"section_id": 5680, "quality": 0.8923076923076924, "length": 58}, "so_16190776_16190777_1": {"section_id": 5680, "quality": 0.717948717948718, "length": 28}}, "n4659": {"so_16190776_16190777_1": {"section_id": 7390, "quality": 0.6153846153846154, "length": 24}}}});