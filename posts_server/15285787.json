post_cb({"15285835": {"ParentId": "15285787", "Score": "1", "CreationDate": "2013-03-08T02:46:39.653", "Id": "15285835", "OwnerUserId": "1919155", "LastActivityDate": "2013-03-08T02:46:39.653", "Body": "<p>Names in C++ must start with a 'letter', where letter is all the upper and lower case 'A-Z, a-z'. '_' also counts as a 'letter'. It can then be followed by any combination of letters and digits. </p>\n", "PostTypeId": "2", "CommentCount": "3"}, "15285823": {"ParentId": "15285787", "Score": "5", "CreationDate": "2013-03-08T02:44:51.133", "Id": "15285823", "OwnerUserId": "892256", "LastActivityDate": "2013-03-08T02:44:51.133", "Body": "<p>Simple answer is no. For you example why not call it OneDArray?</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "15286474": {"ParentId": "15285787", "Score": "3", "CreationDate": "2013-03-08T04:01:30.107", "Id": "15286474", "OwnerUserId": "777186", "LastActivityDate": "2013-03-08T04:01:30.107", "Body": "<p>Since, surprisingly, I wasn't able to find a duplicate, or more general version, of this question, here is an answer based on what the Standard (C++11) says.</p>\n<p>First of all, by \u00a79/1, a class name is an <em>identifier</em> (or a <em>simple-template-id</em> in the case of a template specialization, but a <em>simple-template-id</em> is also composed of <em>identifiers</em>).</p>\n<p>\u00a72.11 defines what a valid <em>identifier</em> is. It first introduces a few basic concepts:</p>\n<p>A <em>digit</em> is one of these: <code>0 1 2 3 4 5 6 7 8 9</code><br>\nA <em>nondigit</em> is one of these: <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code><br>\nA <em>universal-character-name</em> is a sequence of type <code>\\unnnn</code> or <code>\\Unnnnnnnn</code> (where each <code>n</code> is a hexadecimal digit)  </br></br></p>\n<p>The Standard then defines an <em>identifier-nondigit</em> as</p>\n<ul>\n<li>either a <em>nondigit</em></li>\n<li>or a <em>universal-character-name</em></li>\n<li>or an implementation-defined special character<sup>(&amp;ddagger;)</sup></li>\n</ul>\n<p>Finally, <em>identifier</em> is defined recursively as</p>\n<blockquote>\n<p id=\"so_15285787_15286474_0\"><em>identifier</em>:<br>\n  \u00a0\u00a0<em>identifier-nondigit</em><br>\n  \u00a0\u00a0<em>identifier</em>\u00a0<em>identifier-nondigit</em><br>\n  \u00a0\u00a0<em>identifier</em>\u00a0<em>digit</em></br></br></br></p>\n</blockquote>\n<p><strong>Summary: In other words, an identifier must start with a (non-digit!) alphabetical character, which can be followed by anything made up of alphanumerical characters, underscores and <code>\\unnnn</code>-like character references. Anything else is implementation-specific.</strong></p>\n<hr>\n<p><sup>(&amp;ddagger;)</sup> Whether any are supported depends on your compiler, and using them generally means you lose portability to other compilers or compiler versions.</p>\n</hr>", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_15285787_15285827_5": {"length": 6, "section_id": 6754, "quality": 1.0}, "so_15285787_15285827_3": {"length": 7, "section_id": 6754, "quality": 1.0}, "so_15285787_15285827_9": {"length": 14, "section_id": 6754, "quality": 1.0}, "so_15285787_15285827_4": {"length": 7, "section_id": 6754, "quality": 1.0}}}, "15285827": {"ParentId": "15285787", "Score": "22", "CreationDate": "2013-03-08T02:45:16.323", "LastActivityDate": "2014-06-29T01:43:29.980", "LastEditDate": "2014-06-29T01:43:29.980", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "Body": "<p>Rules for identifier names in <em>C++</em> are:</p>\n<ol>\n<li>It can not start with a number</li>\n<li>Can be composed of letters, numbers, underscore, universal character names<sup>1</sup> and <em>implementation defined</em> characters</li>\n<li>Can not be a <a href=\"http://en.cppreference.com/w/cpp/keyword\" rel=\"noreferrer\">keyword</a>.</li>\n</ol>\n<p>The sections in the <a href=\"http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CCoQFjAA&amp;url=http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2012%2Fn3485.pdf&amp;ei=z0bLUfHdNuno0wH744HADQ&amp;usg=AFQjCNHADNpAEY3AIbLLCRGSrJcS5QWcEg&amp;bvm=bv.48340889,d.dmQ&amp;cad=rja\" rel=\"noreferrer\">C++ draft standard</a> that cover this are <code>2.11</code> <em>Identifiers</em> which includes the following grammar:</p>\n<pre><code>identifier:\n  identifier-nondigit            &lt;- Can only start with a non-digit\n  identifier identifier-nondigit &lt;- Next two rules allows for subsequent \n  identifier digit               &lt;-  characters to be those outlined in 2 above\nidentifier-nondigit:\n  nondigit                       &lt;- a-z, A-Z and _ \n  universal-character-name\n  other implementation-defined characters\n[...]\n</code></pre>\n<p>and <code>2.12</code> <em>Keywords</em> explains all the <em>identifier</em> reserved for use as keywords.</p>\n<p>Finally, the following names are also reserved:</p>\n<ol>\n<li>Names that contain a double underscore <code>__</code>, or start with either an underscore followed by an uppercase letter (like <code>_Apple</code>) in any scope, </li>\n<li>Names that start with an underscore in the global namespace (like <code>_apple</code> in the global namespace) are reserved.</li>\n</ol>\n<p>The section that covers this in the <em>draft standard</em> is <code>17.6.4.3.2</code>. We can find a rationale for why these are reserved from <a href='http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\"' rel=\"noreferrer\">Rationale for International Standard\u2014Programming Languages\u2014C</a> which says:</p>\n<blockquote>\n<p id=\"so_15285787_15285827_0\">[...]This gives a name space for writing the numerous behind-the-scenes non-external macros and functions a library needs to do its job properly[...]</p>\n</blockquote>\n<p>In <em>C++</em> this also applies to  <a href=\"http://en.wikipedia.org/wiki/Name_mangling\" rel=\"noreferrer\">name mangling</a> as this <a href=\"http://en.wikipedia.org/wiki/Name_mangling#Complex_example\" rel=\"noreferrer\">example</a> shows.</p>\n<hr>\n<p>Footnotes</p>\n<ul>\n<li><b>1. Allowed universal characters</b></li>\n</ul>\n<p>The universal characters that are allowed is covered in <code>Annex E.1</code>:</p>\n<blockquote>\n<p id=\"so_15285787_15285827_1\">E.1 Ranges of characters allowed [charname.allowed]</p>\n<p id=\"so_15285787_15285827_2\">00A8, 00AA, 00AD,</p>\n<p id=\"so_15285787_15285827_3\">00AF, 00B2-00B5, 00B7-00BA, 00BC-00BE, 00C0-00D6, 00D8-00F6, 00F8-00FF</p>\n<p id=\"so_15285787_15285827_4\">0100-167F, 1681-180D, 180F-1FFF 200B-200D, 202A-202E, 203F-2040, 2054,</p>\n<p id=\"so_15285787_15285827_5\">2060-206F 2070-218F, 2460-24FF, 2776-2793, 2C00-2DFF, 2E80-2FFF</p>\n<p id=\"so_15285787_15285827_6\">3004-3007, 3021-302F, 3031-303F</p>\n<p id=\"so_15285787_15285827_7\">3040-D7FF F900-FD3D, FD40-FDCF,</p>\n<p id=\"so_15285787_15285827_8\">FDF0-FE44, FE47-FFFD </p>\n<p id=\"so_15285787_15285827_9\">10000-1FFFD, 20000-2FFFD, 30000-3FFFD,\n  40000-4FFFD, 50000-5FFFD, 60000-6FFFD, 70000-7FFFD, 80000-8FFFD,\n  90000-9FFFD, A0000-AFFFD, B0000-BFFFD, C0000-CFFFD, D0000-DFFFD, \n  E0000-EFFFD</p>\n</blockquote>\n</hr>", "Id": "15285827", "PostTypeId": "2", "CommentCount": "5"}, "15285787": {"Tags": "<c++><class><naming>", "ViewCount": "9806", "LastEditDate": "2013-10-23T17:38:17.140", "CreationDate": "2013-03-08T02:40:00.923", "LastEditorUserId": "1708801", "Title": "Can you start a class name with a numeric digit?", "CommentCount": "2", "AcceptedAnswerId": "15285827", "Score": "10", "OwnerUserId": "1237053", "Id": "15285787", "LastActivityDate": "2014-06-29T01:43:29.980", "Body": "<p>In <em>C++</em>, is it possible to start a class name with a <em>digit</em>?  For example,</p>\n<pre><code>template &lt;class T&gt; class 2DArray {\n\npublic:\n    // 1D ARRAY CLASS\n    class 1DArray {\n    public:\n        1DArray() { Create(); }\n        1DArray(iterator arr) : array1d_(arr) { }\n        explicit 1DArray(size_type cols, const T&amp; t = T()) { Create(cols, t); }\n        1DArray(const 1DArray&amp; arr) { Create(arr.begin(), arr.end()); }\n        1DArray&amp; operator=(const 2DArray&amp;);\n        ~1DArray() { Uncreate(); }\n\n        T&amp; operator[](size_type n) {\n            return array1d_[n];\n        }\n        const T&amp; operator[](size_type n) const {\n            return array1d_[n];\n        }\n}\n</code></pre>\n", "PostTypeId": "1", "FavoriteCount": "3", "AnswerCount": "4"}});