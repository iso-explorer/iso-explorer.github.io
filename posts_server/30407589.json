post_cb({"bq_ids": {"n4140": {"so_30407589_30407641_0": {"length": 30, "quality": 0.9375, "section_id": 6147}}, "n3337": {"so_30407589_30407641_0": {"length": 23, "quality": 0.71875, "section_id": 5910}}, "n4659": {"so_30407589_30407641_0": {"length": 30, "quality": 0.9375, "section_id": 7643}}}, "30407589": {"ViewCount": "209", "Body": "<p>I am trying to clearly understand the behaviour of the shift operators (especially for the boundary cases), so I devised a little test written in C++.</p>\n<pre><code>    int a = odd_value; //321 in my case but it should not matter (the last bit to be 1)\n    print(0, a);\n\n    a = a &lt;&lt; 31; // (this gives a segmentation fault, as normal because it tries the sign bit becomes 1 but all the other bits are 0).\n    print(0, a); //the segmentation fault happens here - it prints the minimum integer value and then gives the fault\n    a = (a &lt;&lt; 1) + 1; // but if then I do this, shouldn't it set a to -1 ??\n    print(a); //gives 0\n\n   void print(int stackCallIndex, int nb)\n   {\n     if(nb)\n     {\n        print(++stackCallIndex, nb &gt;&gt; 1);\n        if(nb &amp; 1) printf(\"%d\", 1);\n        else       printf(\"%d\", 0);\n\n        if(stackCallIndex % 8 == 0) printf(\" \");\n     }\n   }\n</code></pre>\n", "AcceptedAnswerId": "30407756", "Title": "Need some help - left shift bitwise operator", "CreationDate": "2015-05-23T00:16:41.203", "Id": "30407589", "CommentCount": "9", "LastEditDate": "2015-05-23T00:46:15.667", "PostTypeId": "1", "LastEditorUserId": "4799108", "LastActivityDate": "2015-05-23T00:49:05.600", "Score": "1", "OwnerUserId": "4799108", "Tags": "<c++><bit-manipulation><operators>", "AnswerCount": "3"}, "30407669": {"Id": "30407669", "PostTypeId": "2", "Body": "<p>When I try that I get -214783648 which is the smallest known value in integer... this means that you are making an integer bigger than the allowed range that's why in your case you get a segmentation fault...</p>\n", "LastActivityDate": "2015-05-23T00:30:48.363", "Score": "1", "CreationDate": "2015-05-23T00:30:48.363", "ParentId": "30407589", "CommentCount": "7", "OwnerUserId": "4905579"}, "30407641": {"Id": "30407641", "PostTypeId": "2", "Body": "<p>If you want the <em>standard</em> behavior, then it's undefined. According to [expr.shift]:</p>\n<blockquote>\n<p id=\"so_30407589_30407641_0\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned\n  type, [...]. Otherwise, if <code>E1</code> has a signed type and non-negative value, and <code>E1</code>\u00d7<code>2</code><sup>E2</sup> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the\n  resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>Any (odd number &gt; 1) x 2<sup>31</sup> is not representable by <code>uint32_t</code>, so the behavior is undefined. Your compiler apparently chooses to implement this as a segmentation fault, which is perfectly conforming behavior (edit: er, at least it would be, if that were where it is happening). </p>\n<p>A more typical approach would be just to let bits \"fall off\" the end. That is, <code>a &lt;&lt; 31</code> for an odd number would become <code>0x80000000</code>. But even in that case, another left-shift of 1 would result in <code>0</code>, so you'd have to subtract 1 to get <code>-1</code>, not add <code>1</code>. </p>\n", "LastActivityDate": "2015-05-23T00:26:06.953", "Score": "3", "CreationDate": "2015-05-23T00:26:06.953", "ParentId": "30407589", "CommentCount": "3", "OwnerUserId": "2069064"}, "30407756": {"Id": "30407756", "PostTypeId": "2", "Body": "<p>According to your code I'd bet on a stackoverflow due to infinite recursion if you try to print negative values.</p>\n<pre><code>   void print(int stackCallIndex, int nb)\n   {\n     if(number)\n     {\n        print(++stackCallIndex, nb &gt;&gt; 1); // likely an infinite recursion here.\n        if(nb &amp; 1) printf(\"%d\", 1);\n        else       printf(\"%d\", 0);\n\n        if(stackCallIndex % 8 == 0) printf(\" \");\n     }\n   }\n</code></pre>\n<p>so why would it be infinite recursion? Strictly according to standard right shifting negative signed integers is implementation defined.</p>\n<p>In most implementations it will do an <a href=\"https://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow\">arithmetic right shift</a>, meaning that <code>1111 1100</code> (-4 in two's complement 8bit) shifted to the right by 1 would result in <code>1111 1110</code> (-2 in two's complement 8bit) as you can see you always fill up the sign bit again so your number would never get to 0 and the if condition is always true.</p>\n<hr>\n<p>Generally doing bit manipulation on signed values is a bad idea, they involve implementation/undefined behavior in a few cases. Better cast all values to unsigned before using bit manipulation.</p>\n</hr>", "LastEditorUserId": "1942027", "LastActivityDate": "2015-05-23T00:49:05.600", "Score": "3", "CreationDate": "2015-05-23T00:45:26.963", "ParentId": "30407589", "CommentCount": "5", "LastEditDate": "2015-05-23T00:49:05.600", "OwnerUserId": "1942027"}});