post_cb({"30891329": {"Id": "30891329", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30888851_30891329_0\">I have no clue about what the [] option does in cout</p>\n</blockquote>\n<p>This is actually not a <code>cout</code> option, what is happening is that <code>\"\\n\"</code> is a <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"noreferrer\"><em>string literal</em></a>. A string literal has the type <em>array of n const char</em>, the <code>[]</code> is simply an index into an array of characters which in this case contains:</p>\n<pre><code>\\n\\0\n</code></pre>\n<p>note <code>\\0</code> is appended to all string literals.</p>\n<p>The <code>==</code> operator results in either <em>true</em> or <em>false</em>, so the index will be:</p>\n<ul>\n<li><code>0</code> if false, if <code>a</code> does not equal <code>N</code> resulting in <code>\\n</code></li>\n<li><code>1</code> if true, if <code>a</code> equals <code>N</code> resulting in <code>\\0</code></li>\n</ul>\n<p>This is rather cryptic and could have been replaced with a simple <code>if</code>.</p>\n<p>For reference the C++14 standard(<em>Lightness confirmed the draft matches the actual standard</em>) with the closest draft being <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"noreferrer\">N3936</a> in section <code>2.14.5</code> String literals <em>[lex.string]</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30888851_30891329_1\">string literal <strong>has type \u201carray of n const char\u201d</strong>, where n is the\n  size of the string as defined below, and has static storage duration\n  (3.7).</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_2\">After any necessary concatenation, in translation phase 7 (2.2),\n  <strong>\u2019\\0\u2019 is appended to every string literal</strong> so that programs that scan a string can find its end.</p>\n</blockquote>\n<p>section <code>4.5</code> <em>[conv.prom]</em> says:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_3\">A prvalue of type bool can be converted to a prvalue of type int, with\n  false becoming zero and true becoming one.</p>\n</blockquote>\n<p><b>Writing a null character to a text stream</b></p>\n<p>The claim was made that writing a null character(<code>\\0</code>) to a text stream is undefined behavior.</p>\n<p>As far as I can tell this is a reasonable conclusion, <code>cout</code> is defined in terms of C stream, as we can see from <code>27.4.2</code> <em>[narrow.stream.objects]</em> which says:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_4\">The object cout controls output to a stream buffer associated with the object stdout, declared in\n  &lt;cstdio&gt; (27.9.2).</p>\n</blockquote>\n<p>and the C11 draft standard in section <code>7.21.2</code> <em>Streams</em> says:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_5\">[...]Data read in from a text stream will necessarily compare equal to the data\n  that were earlier written out to that stream only if: the data consist only of printing\n  characters and the control characters horizontal tab and new-line;</p>\n</blockquote>\n<p>and <em>printing characters</em> are covered in <code>7.4</code> <em>Character handling &lt;ctype.h&gt;</em>:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_6\">[...]the term control character\n  refers to a member of a locale-specific set of characters that are not printing\n  characters.199) All letters and digits are printing characters.</p>\n</blockquote>\n<p>with footnote <code>199</code> saying:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_7\">In an implementation that uses the seven-bit US ASCII character set, the printing characters are those\n  whose values lie from 0x20 (space) through 0x7E (tilde); the control characters are those whose\n  values lie from 0 (NUL) through 0x1F (US), and the character 0x7F (DEL).</p>\n</blockquote>\n<p>and finally we can see that the result of sending a null character is not specified and we can see this is undefined behavior from section <code>4</code> Conformance which says:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_8\">[...]Undefined behavior is otherwise\n  indicated in this International Standard by the words \u2018\u2018undefined behavior\u2019\u2019 or by the\n  omission of any explicit definition of behavior.[...]</p>\n</blockquote>\n<p>We can also look to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"noreferrer\">C99 rationale</a> which says:</p>\n<blockquote>\n<p id=\"so_30888851_30891329_9\">The set of characters required to be preserved in text stream I/O are those needed for writing C\n  programs; the intent is that the Standard should permit a C translator to be written in a maximally\n  portable fashion. Control characters such as backspace are not required for this purpose, so their\n  handling in text streams is not mandated.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-06-22T20:04:15.510", "Score": "70", "CreationDate": "2015-06-17T12:15:39.273", "ParentId": "30888851", "CommentCount": "11", "OwnerUserId": "1708801", "LastEditDate": "2015-06-22T20:04:15.510"}, "30896285": {"Id": "30896285", "PostTypeId": "2", "Body": "<p>Each of the following lines will generate exactly the same output:</p>\n<pre><code>cout &lt;&lt; \"\\n\"[a==N];     // Never do this.\ncout &lt;&lt; (a==N)[\"\\n\"];   // Or this.\ncout &lt;&lt; *((a==N)+\"\\n\"); // Or this.\ncout &lt;&lt; *(\"\\n\"+(a==N)); // Or this.\n</code></pre>\n<p><br>\nAs the other answers have specified, this has nothing to do with <code>std::cout</code>. It instead is a consequence of</br></p>\n<ul>\n<li><p>How the primitive (non-overloaded) subscripting operator is implemented in C and C++.<br>\nIn both languages, if <code>array</code> is a C-style array of primitives, <code>array[42]</code> is syntactic sugar for <code>*(array+42)</code>. Even worse, there's no difference between <code>array+42</code> and <code>42+array</code>. This leads to interesting obfuscation: Use <code>42[array]</code> instead of <code>array[42]</code> if your goal is to utterly obfuscate your code. It goes without saying that writing <code>42[array]</code> is a terrible idea if your goal is to write understandable, maintainable code.</br></p></li>\n<li><p>How booleans are transformed to integers.<br>\nGiven an expression of the form <code>a[b]</code>, either <code>a</code> or <code>b</code> must be a pointer expression and the other; the other must be an integer expression. Given the expression <code>\"\\n\"[a==N]</code>, the <code>\"\\n\"</code> represents the pointer part of that expression and the <code>a==N</code> represents the integer part  of the expression. Here, <code>a==N</code> is a boolean expression that evaluates to <code>false</code> or <code>true</code>. The integer promotion rules specify that <code>false</code> becomes 0 and <code>true</code> becomes 1 on promotion to an integer.</br></p></li>\n<li><p>How string literals degrade into pointers.<br>\nWhen a pointer is needed, arrays in C and C++ readily degrade into a pointer that points to the first element of the array.</br></p></li>\n<li><p>How string literals are implemented.<br>\nEvery C-style string literal is appended with the null character <code>'\\0'</code>. This means the internal representation of your <code>\"\\n\"</code> is the array <code>{'\\n', '\\0'}</code>.</br></p></li>\n</ul>\n<p><br>\nGiven the above, suppose <code>a==N</code> evaluates to <code>false</code>. In this case, the behavior is well-defined across all systems: You'll get a newline. If, on the other hand, <code>a==N</code> evaluates to <code>true</code>, the behavior is highly system dependent. Based on comments to answers to the question, Windows will not like that. On Unix-like systems where <code>std::cout</code> is piped to the terminal window, the behavior is rather benign. Nothing happens.</br></p>\n<p><br>\nJust because you can write code like that doesn't mean you should. Never write code like that.</br></p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2015-06-24T02:31:29.177", "Score": "8", "CreationDate": "2015-06-17T15:42:03.367", "ParentId": "30888851", "CommentCount": "6", "OwnerUserId": "774499", "LastEditDate": "2015-06-24T02:31:29.177"}, "30888904": {"Id": "30888904", "PostTypeId": "2", "Body": "<blockquote>\n<pre><code>cout&lt;&lt;\"\\n\"[a==N];\n</code></pre>\n<p id=\"so_30888851_30888904_0\">I have no clue about what the [] option does in cout</p>\n</blockquote>\n<p>In <a href=\"http://en.cppreference.com/w/cpp/language/operator_precedence\">C++ operator Precedence table</a>, <code>operator []</code> binds tighter than <code>operator &lt;&lt;</code>, so your code is equivalent to:</p>\n<pre><code>cout &lt;&lt; (\"\\n\"[a==N]);  // or cout.operator &lt;&lt;(\"\\n\"[a==N]);\n</code></pre>\n<p>Or in other words, <code>operator []</code> does nothing directly with <code>cout</code>. It is used only for indexing of string literal <code>\"\\n\"</code></p>\n<p>For example <code>for(int i = 0; i &lt; 3; ++i) std::cout &lt;&lt; \"abcdef\"[i] &lt;&lt; std::endl;</code> will print characters a, b and c on consecutive lines on the screen.</p>\n<hr>\n<p>Because <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\">string literals</a> in <code>C++</code> are <strong>always</strong> terminated with null character(<code>'\\0'</code>, <code>L'\\0'</code>, <code>char16_t()</code>, etc), a string literal <code>\"\\n\"</code> is a <code>const char[2]</code> holding the characters <code>'\\n'</code> and <code>'\\0'</code></p>\n<p>In memory layout this looks like:</p>\n<pre><code>+--------+--------+\n|  '\\n'  |  '\\0'  |\n+--------+--------+\n0        1          &lt;-- Offset\nfalse    true       &lt;-- Result of condition (a == n)\na != n   a == n     &lt;-- Case\n</code></pre>\n<p>So if <code>a == N</code> is true (promoted to 1), expression <code>\"\\n\"[a == N]</code> results in <code>'\\0'</code> and <code>'\\n'</code> if result is false.</p>\n<p>It is functionally similar (not same) to:</p>\n<pre><code>char anonymous[] = \"\\n\";\nint index;\nif (a == N) index = 1;\nelse index = 0;\ncout &lt;&lt; anonymous[index];\n</code></pre>\n<p>valueof <code>\"\\n\"[a==N]</code> is <code>'\\n'</code> or <code>'\\0'</code></p>\n<p>typeof <code>\"\\n\"[a==N]</code> is <code>const char</code></p>\n<hr>\n<p>If the intention is to print nothing (Which may be different from printing <code>'\\0'</code> depending on platform and purpose), prefer the following line of code:</p>\n<pre><code>if(a != N) cout &lt;&lt; '\\n';\n</code></pre>\n<p><strong>Even if</strong> your intention is to write either <code>'\\0'</code> or <code>'\\n'</code> on the stream, prefer a readable code for example:</p>\n<pre><code>cout &lt;&lt; (a == N ? '\\0' : '\\n');\n</code></pre>\n</hr></hr>", "LastEditorUserId": "2659313", "LastActivityDate": "2015-06-17T19:16:19.943", "Score": "39", "CreationDate": "2015-06-17T10:28:43.813", "ParentId": "30888851", "CommentCount": "3", "OwnerUserId": "2659313", "LastEditDate": "2015-06-17T19:16:19.943"}, "30888851": {"ViewCount": "2806", "Body": "<p>In the following example:</p>\n<pre><code>cout&lt;&lt;\"\\n\"[a==N];\n</code></pre>\n<p>I have no clue about what the <code>[]</code> option does in <code>cout</code>, but it does not print a newline when the value of <code>a</code> is equal to <code>N</code>.</p>\n", "AcceptedAnswerId": "30891329", "Title": "what does cout << \"\\n\"[a==N]; do?", "CreationDate": "2015-06-17T10:26:00.803", "Id": "30888851", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2015-06-18T02:37:53.963", "LastEditorUserId": "2659313", "LastActivityDate": "2015-06-24T02:31:29.177", "Score": "60", "OwnerUserId": "3949667", "Tags": "<c++><cout><string-literals>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_30888851_30891329_3": {"length": 14, "quality": 1.0, "section_id": 26}, "so_30888851_30891329_4": {"length": 11, "quality": 0.8461538461538461, "section_id": 1925}, "so_30888851_30891329_1": {"length": 14, "quality": 1.0, "section_id": 5356}, "so_30888851_30891329_2": {"length": 16, "quality": 1.0, "section_id": 5363}}, "n3337": {"so_30888851_30891329_3": {"length": 14, "quality": 1.0, "section_id": 23}, "so_30888851_30891329_4": {"length": 11, "quality": 0.8461538461538461, "section_id": 1914}, "so_30888851_30891329_1": {"length": 14, "quality": 1.0, "section_id": 5153}, "so_30888851_30891329_2": {"length": 16, "quality": 1.0, "section_id": 5159}}, "n4659": {"so_30888851_30891329_3": {"length": 14, "quality": 1.0, "section_id": 26}, "so_30888851_30891329_4": {"length": 11, "quality": 0.8461538461538461, "section_id": 2196}, "so_30888851_30891329_1": {"length": 14, "quality": 1.0, "section_id": 6781}, "so_30888851_30891329_2": {"length": 16, "quality": 1.0, "section_id": 6787}}}, "30889091": {"Id": "30889091", "PostTypeId": "2", "Body": "<p>It is not an option of <code>cout</code> but an array index of <code>\"\\n\"</code></p>\n<p>The array index <code>[a==N]</code> evaluates to [0] or [1], and indexes the character array represented by <code>\"\\n\"</code> which contains a newline and a nul character.</p>\n<p>However passing nul to the iostream will have undefined results, and it would be better to pass a string:</p>\n<pre><code>cout &lt;&lt; &amp;(\"\\n\"[a==N]) ;\n</code></pre>\n<p>However, the code in either case is not particularly advisable and serves no particular purpose other than to obfuscate; do not regard it as an example of good practice.  The following is preferable in most instances:</p>\n<pre><code>cout &lt;&lt; (a != N ? \"\\n\" : \"\") ;\n</code></pre>\n<p>or just:</p>\n<pre><code>if( a != N ) cout &lt;&lt; `\\n` ;\n</code></pre>\n", "LastEditorUserId": "168986", "LastActivityDate": "2015-06-20T07:49:56.767", "Score": "8", "CreationDate": "2015-06-17T10:37:23.867", "ParentId": "30888851", "CommentCount": "2", "OwnerUserId": "168986", "LastEditDate": "2015-06-20T07:49:56.767"}, "30889004": {"Id": "30889004", "PostTypeId": "2", "Body": "<p>It's probably intended as a bizarre way of writing</p>\n<pre><code>if ( a != N ) {\n    cout&lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>The <code>[]</code> operator selects an element from an array. The string <code>\"\\n\"</code> is actually an array of two characters: a new line <code>'\\n'</code> and a string terminator <code>'\\0'</code>. So <code>cout&lt;&lt;\"\\n\"[a==N]</code> will print either a <code>'\\n'</code> character or a <code>'\\0'</code> character.</p>\n<p>The trouble is that you're not allowed to send a <code>'\\0'</code> character to an I/O stream in text mode. The author of that code might have noticed that nothing seemed to happen, so he assumed that <code>cout&lt;&lt;'\\0'</code> is a safe way to do nothing.</p>\n<p>In C and C++, that is a very poor assumption because of the notion of <em>undefined behavior.</em> If the program does something that is not covered by the specification of the standard or the particular platform, anything can happen. A fairly likely outcome in this case is that the stream will stop working entirely \u2014 no more output to <code>cout</code> will appear at all.</p>\n<p>In summary, the effect is,</p>\n<blockquote>\n<p id=\"so_30888851_30889004_0\">\"Print a newline if <code>a</code> is not equal to <code>N</code>. Otherwise, I don't know. Crash or something.\"</p>\n</blockquote>\n<p>\u2026 and the moral is, don't write things so cryptically.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-06-17T10:35:05.960", "Score": "9", "CreationDate": "2015-06-17T10:33:41.923", "ParentId": "30888851", "CommentCount": "17", "OwnerUserId": "153285", "LastEditDate": "2015-06-17T10:35:05.960"}});