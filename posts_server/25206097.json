post_cb({"25206097": {"AcceptedAnswerId": "25206506", "Tags": "<java><c#><c++><c><expression>", "Id": "25206097", "OwnerUserId": "3626698", "Body": "<p>Have a look at the following code : <br/></p>\n<p><b>Case 1 : </b></p>\n<pre><code>char a = 'x' ^ 'y';\n</code></pre>\n<p>It is working fine.\nBut when I use variable instead of constants as here : </p>\n<p><b>Case 2:</b></p>\n<pre><code>char x = 'x';\nchar y = 'y';\nchar a = x ^ y; // Error!\n</code></pre>\n<blockquote>\n<p id=\"so_25206097_25206097_0\">In java language : case 1 is working and value of <b>a</b> comes out to be 1 but case 2 is not working.</p>\n<p id=\"so_25206097_25206097_1\">In C and C++ : both cases are working, and the value of <b>a</b> comes out to be 1</p>\n<p id=\"so_25206097_25206097_2\">In C# : both the cases are not working.</p>\n<p id=\"so_25206097_25206097_3\">In javascript : both cases are working, which is not a HLL, and value of <b>a</b> comes out to be 0.</p>\n</blockquote>\n<p><br/>\nI understand that java is converting variables to integer to do binary operation, but why it is working in case 1 and not in case 2, Why same is not working in C# And why the values are different in the case of javascript.</p>\n<p><b>Updated</b>\nWhen I made the variables final than it is working in java, but still not in C#  </p>\n<pre><code>final char x = 'x';\nfinal char y = 'y';\nchar a = x ^ y;\n</code></pre>\n<p>But still I cannot understand why constants are working but when using variable they are not. And why same is not happening with other high level programming language.<br/>\nI think it is a basic operation and should be working in all programming languages with same behaviour.</p>\n<blockquote>\n<p id=\"so_25206097_25206097_4\"><b>Note</b> To test all above cases in javascript I am replacing 'char' with 'var' in all cases and they are working.</p>\n</blockquote>\n", "CommentCount": "20", "CreationDate": "2014-08-08T14:42:28.427", "ViewCount": "282", "FavoriteCount": "3", "LastActivityDate": "2014-08-09T05:39:52.670", "LastEditorUserId": "3626698", "PostTypeId": "1", "Title": "Why xor operation on constants (character) is working differently when used variables in its place", "AnswerCount": "3", "Score": "3", "ClosedDate": "2014-08-10T22:26:20.057", "LastEditDate": "2014-08-09T05:39:52.670"}, "25206506": {"LastActivityDate": "2014-08-08T15:03:47.690", "ParentId": "25206097", "CommentCount": "1", "Score": "5", "Body": "<p>Answering for Java only.</p>\n<p>The expression <code>'x' ^ 'y'</code> is a <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28\" rel=\"noreferrer\">constant expression</a>; <code>x ^ y</code> is not, unless both variables are declared <code>final</code>. Furthermore, the result is an <code>int</code>; <code>^</code> is an <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.22.1\" rel=\"noreferrer\">integral bitwise operator</a>, meaning that both operands have to be <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2\" rel=\"noreferrer\">promoted</a> to an integral type before being evaluated. <code>char</code> promotes to <code>int</code>.</p>\n<p>So you have this <code>int</code> expression, and you try to narrow it to a <code>char</code>. In the general case, this could lead to a loss of precision (ints are 4 bytes, chars are 2), so the compiler doesn't let you do that without you explicitly stating it's what you want to do (via a cast to <code>char</code>). <em>However</em>, you can implicitly narrow constant expressions, if their value would fit into the new type. From <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.2\" rel=\"noreferrer\">JLS 5.2</a>:</p>\n<blockquote id=\"so_25206097_25206506_0\">\n<ul>\n<li>A narrowing primitive conversion may be used if the type of the variable is <code>byte</code>, <code>short</code>, or <code>char</code>, and the <strong>value of the constant expression is representable in the type of the variable</strong>.</li>\n</ul>\n</blockquote>\n<p>(Emphasis added)</p>\n<p>Intuitively, this makes total sense: the error is there to tell you that you may lose precision, and so it wants you to confirm that you know that; in a sense, it's a loud warning. But if the compiler can know absolutely that this <em>won't</em> happen, as it can for a constant expression, then it makes things a bit easier for you and \"hides\" that warning.</p>\n", "Id": "25206506", "CreationDate": "2014-08-08T15:03:47.690", "OwnerUserId": "1076640", "PostTypeId": "2"}, "25211121": {"LastActivityDate": "2014-08-08T19:48:39.017", "LastEditorUserId": "2877241", "ParentId": "25206097", "CommentCount": "0", "PostTypeId": "2", "Score": "1", "Body": "<p>I will consider C languages that is C, C++ and C#.</p>\n<p>In C# there is no implicit conversion from an integral type to type char. According to section \"11.1.5 Integral types\" of the ECMA 334 Standard \"C# Specification\" </p>\n<blockquote>\n<p id=\"so_25206097_25211121_0\">\u2022 There are no implicit conversions from other types to the char type.\n  In particular, even though the sbyte, byte, and ushort types have\n  ranges of values that are fully representable using the char type,\n  implicit conversions from sbyte, byte, or ushort to char do not exist.</p>\n</blockquote>\n<p>So you need explicitly to cast the result of the operator to type char. For example</p>\n<pre><code>using System;\n\nnamespace ExclusiveOr\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            char a = ( char )('x' ^ 'y' );\n            char c = 'x', d = 'y';\n            char b = ( char )( c ^ d );\n\n            Console.WriteLine(\"a = {0}, b = {1}\", (int)a, (int)b);\n        }\n    }\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>a = 1, b = 1\n</code></pre>\n<p>According to the C Standard (section 6.7.9 Initialization)</p>\n<blockquote>\n<p id=\"so_25206097_25211121_1\">4 All the expressions in an initializer for an object that has static\n  or thread storage duration shall be constant expressions or string\n  literals</p>\n</blockquote>\n<p>So for example this code will be compiled</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nchar a = 'x' ^ 'y';\n\nint main(void) \n{\n    printf( \"a = %d\\n\", a );\n\n    return 0;\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>a = 1\n</code></pre>\n<p>However this code will not be compiled</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nchar c = 'x';\nchar d = 'y';\n\nchar b = c ^ d;\n\nint main(void) \n{\n    printf( \"b = %d\\n\", b );\n\n    return 0;\n}\n</code></pre>\n<p>will not be compiled. The GCC compiler will issue error</p>\n<p>prog.c:8:1: error: initializer element is not constant  char b = c ^ d;</p>\n<p>However if you will make varaible b local then the code will be compiled successfully</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nchar c = 'x';\nchar d = 'y';\n\n\nint main(void) \n{\n    char b = c ^ d;\n    printf( \"b = %d\\n\", b );\n\n    return 0;\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>b = 1\n</code></pre>\n<p>In C++ there is no such a restriction for objects with the static storage duration so all examples of programs similar to C programs showed above will be compiled.</p>\n", "Id": "25211121", "LastEditDate": "2014-08-08T19:48:39.017", "OwnerUserId": "2877241", "CreationDate": "2014-08-08T19:42:45.413"}, "bq_ids": {"n4659": {"so_25206097_25211121_1": {"section_id": 8652, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_25206097_25211121_1": {"section_id": 5947, "quality": 0.5833333333333334, "length": 7}}}, "25206520": {"LastActivityDate": "2014-08-08T15:11:23.717", "LastEditorUserId": "139985", "ParentId": "25206097", "CommentCount": "0", "PostTypeId": "2", "Score": "0", "Body": "<p>Under normal circumstances, the operands of the following binary operators are \"widened\" before the operation is performed.</p>\n<p>(From the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.1\" rel=\"nofollow\">JLS 5.6.1</a>)</p>\n<ul>\n<li><p>The multiplicative operators *, /, and % (\u00a715.17)</p></li>\n<li><p>The addition and subtraction operators for numeric types + and - (\u00a715.18.2)</p></li>\n<li><p>The numerical comparison operators &lt;, &lt;=, &gt;, and &gt;= (\u00a715.20.1)</p></li>\n<li><p>The numerical equality operators == and != (\u00a715.21.1)</p></li>\n<li><p>The integer bitwise operators &amp;, ^, and | (\u00a715.22.1)</p></li>\n<li><p>In certain cases, the conditional operator ? : (\u00a715.25)</p></li>\n</ul>\n<p>In the case of <code>char</code> operands, widening will convert the operands to <code>int</code>.</p>\n<p>For the arithmetic and bitwise operations, the type of the operation's result is the same as the \"wider\" of the two operands.</p>\n<p>When <code>x</code> and <code>y</code> have type <code>char</code>, the expression <code>x ^ y</code> gives you an <code>int</code> value.  That can't be assigned back to a <code>char</code> without a type cast, and hence you get a compilation error.</p>\n<hr>\n<p>For the case where you are using <code>char</code> literals, the same widening process happens.  But there is a \"special exception\" in the language which <em>allows</em> the value of a constant expression to be implicitly narrowed, <em>provided that the constant expression's value will fit into the type</em>.  In this case, <code>'x' ^ 'y'</code> will \"fit\" into a <code>char</code>, so the assignment is allowed.</p>\n<p>The JLS reference for this exception for constant expressions is <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.2\" rel=\"nofollow\">JLS 5.2</a>.</p>\n</hr>", "Id": "25206520", "LastEditDate": "2014-08-08T15:11:23.717", "OwnerUserId": "139985", "CreationDate": "2014-08-08T15:04:26.583"}});