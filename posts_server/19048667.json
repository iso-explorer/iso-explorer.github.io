post_cb({"19048781": {"Id": "19048781", "PostTypeId": "2", "Body": "<p>The standard says you are allowed to take the address of an object that isn't an array and treat it as an array of size 1 (so you can take a pointer to past-the-end).</p>\n<p>See section \u00a75.7.4 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_19048667_19048781_0\">For the purposes of these operators, a pointer to a nonarray object\n  behaves the same as a pointer to the first element of an array of\n  length one with the type of the object as its element type.</p>\n</blockquote>\n", "LastEditorUserId": "2491746", "LastActivityDate": "2013-09-27T10:49:39.653", "Score": "7", "CreationDate": "2013-09-27T10:41:59.853", "ParentId": "19048667", "CommentCount": "0", "OwnerUserId": "2491746", "LastEditDate": "2013-09-27T10:49:39.653"}, "19065567": {"Id": "19065567", "PostTypeId": "2", "Body": "<p>Here we face 2 blocks of code.</p>\n<ul>\n<li>A large block of code that is designed to take an array and work\nthrough it.  </li>\n<li>A piece of code which uses previous block of code with\nsome data.</li>\n</ul>\n<p><strong>Structure your code.</strong></p>\n<p>The large block of code should be a function possibly divided in several subfunctions.\nThe other piece of code will call to this function.</p>\n<p><strong>Parameters of the function. Array or single char.</strong></p>\n<pre><code>  (a) void work( char  c );\n  (b) void work( char&amp; c );\n  (c) void work( const char v[], size_t size);\n  (d) void work(       char v[], size_t size);\n</code></pre>\n<p>Options (a) and (b) should be used if the kind of work makes no sense for an array. Which is not the case.<br/>\nOptions (c) and (d) should be used if work makes sense for an array.</p>\n<p>So use an array.</p>\n<p><strong>Variable which holds the data. Array or single char.</strong></p>\n<p>If you only need to hold a single char then use a single non-array char. You can still call the array function.</p>\n<pre><code>char c;\nc = 'b';\nwork( &amp;c, 1 );\n//////\nchar a[1];\na[0] = 'b';\nwork( a, 1 );\n</code></pre>\n<p>The work function sees the single variable and the array as an array of size 1. Code will work fine in both cases and with no efficiency concerns.</p>\n<p><strong>Testing</strong></p>\n<p>Let's see if real code holds my previous statements.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;vector&gt;\n#include &lt;cstddef&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\n\nunsigned long miliTime()\n{\n    return std::chrono::system_clock::now().time_since_epoch() /\n           std::chrono::milliseconds(1);\n}\n// An hypotetical work function with arrays\nvoid workArray( char v[], size_t size )\n{\n  for ( size_t n=0; n&lt;size; ++n )\n  {\n    // large block of code\n    for ( int i=0; i&lt;1000; ++i )\n    {\n      v[n] += 3 + i;\n      if (v[n] == '3' )\n        v[n] = 'J' - v[n];\n      v[n] = toupper( v[n] ) + '-';\n    }\n  }\n}\n\n// Same function just for a single character\nvoid workSingle( char&amp; c )\n{\n  // large block of code\n  for ( int i=0; i&lt;1000; ++i )\n  {\n    c += 3 + i;\n    if (c == '3' )\n      c = 'J' - c;\n    c = toupper( c ) + '-';\n  }\n}\n\nint main(void)\n{\n  const long int repeats =1000000;\n  long int n;\n  unsigned long start;\n  double dif;\n\n  start = miliTime();\n  char c;\n  c = 'b';\n  for ( n=0; n&lt;repeats; ++n)\n    workArray( &amp;c, 1 );\n  dif = miliTime() - start;\n  cout &lt;&lt; \"Result = \" &lt;&lt; c &lt;&lt; endl;\n  cout &lt;&lt; \"Non-array var passed to array code = \" &lt;&lt; dif &lt;&lt; \" ms\" &lt;&lt; endl;\n\n  start = miliTime();\n  char a[1];\n  a[0] = 'b';\n  for ( n=0; n&lt;repeats; ++n)\n    workArray( a, 1 );\n  dif = miliTime() - start;\n  cout &lt;&lt; \"Result = \" &lt;&lt; a[0] &lt;&lt; endl;\n  cout &lt;&lt; \"Array var passed to array code = \" &lt;&lt; dif &lt;&lt; \"ms\" &lt;&lt; endl;\n\n  start = miliTime();\n  char c2;\n  c2 = 'b';\n  for ( n=0; n&lt;repeats; ++n)\n    workSingle( c2 );\n  dif = miliTime() - start;\n  cout &lt;&lt; \"Result = \" &lt;&lt; c2 &lt;&lt; endl;\n  cout &lt;&lt; \"Non-array var passed to non-array code = \" &lt;&lt; dif &lt;&lt; \"ms\" &lt;&lt; endl;\n\n  start = miliTime();\n  char a2[1];\n  a2[0] = 'b';\n  for ( n=0; n&lt;repeats; ++n)\n    workSingle( a2[0] );\n  dif = miliTime() - start;\n  cout &lt;&lt; \"Result = \" &lt;&lt; a2[0] &lt;&lt; endl;\n  cout &lt;&lt; \"Array var passed to non-array code = \" &lt;&lt; dif &lt;&lt; \"ms\" &lt;&lt; endl;\n}\n</code></pre>\n<p>When compiled under gcc-4.7 with this command line and executed in my computer :</p>\n<pre><code>g++ -O2 -Wall -std=c++11 x.cpp -o x.out &amp;&amp; ./x.out\n</code></pre>\n<p>I get this output :<br/>\nResult = z<br/>\nNon-array var passed to array code = 5520 ms<br/>\nResult = z<br/>\nArray var passed to array code = 5515ms<br/>\nResult = z<br/>\nNon-array var passed to non-array code = 5203ms<br/>\nResult = z<br/>\nArray var passed to non-array code = 5203ms<br/></p>\n<p>As expected the result is always the same.\nThere is no significative difference in passing an array or a non-array variable to the work function for both implementations.<br/></p>\n<p>workSingle is 6% faster than workArray. <br/>\nThe execution of the outer loop (which does not exist in workSingle) is unlikely to be the cause since the inner loop executes 1000 times. The cause is probably due to access to v[n] being slower than access to c due to the indirection.<br/>\nThough if you change the 1000 in the inner loop for a global variable read from std::cin then workSingle actually gives slower times than workArray!</p>\n<p>Some kind of optimizations, cache misses or other low level stuff may be the cause. I would not sacrifice the reusability of workArray for the uncertain efficiency of workSingle unless time is so critical that you are willing to go to assembly level.</p>\n<p><strong>Conclusion.</strong></p>\n<p>Declare your variable as non-array since it only has to hold a single character.<br/>\nImplement your large section of code as a function that takes an array parameter. Possibly divided in several subsections if its so large.</p>\n", "LastActivityDate": "2013-09-28T09:47:20.750", "CommentCount": "2", "CreationDate": "2013-09-28T09:47:20.750", "ParentId": "19048667", "Score": "0", "OwnerUserId": "956880"}, "19049059": {"Id": "19049059", "PostTypeId": "2", "Body": "<p>First, your code is valid, but if you care about drawbacks, I can see the issues listed below:</p>\n<p>Using array, you increase the chance of accessing it with out-of-boundaries access when you loop through the array without being careful. </p>\n<p>Another drawback is that array doesn't interact with polymorphism. Sometimes you try to store derived object into an array of base type, object will be sliced and you may not notice.</p>\n<p>So I wouldn't write array[1] code. Hope this answers some of your questions.</p>\n", "LastEditorUserId": "752976", "LastActivityDate": "2013-09-27T11:22:18.943", "Score": "3", "CreationDate": "2013-09-27T10:58:16.270", "ParentId": "19048667", "CommentCount": "4", "OwnerUserId": "951757", "LastEditDate": "2013-09-27T11:22:18.943"}, "19048681": {"Id": "19048681", "PostTypeId": "2", "Body": "<p>Sounds like a good strategy, and there are no drawbacks. You are defintely not wasting memory in either C or C++. The memory taken by an array of size one is the same as the memory taken by a variable of the same type.</p>\n<p>It's possible the compiler will generate microscopically less efficient code, but that is really not worth worrying about.</p>\n", "LastActivityDate": "2013-09-27T10:36:31.467", "CommentCount": "0", "CreationDate": "2013-09-27T10:36:31.467", "ParentId": "19048667", "Score": "8", "OwnerUserId": "882003"}, "bq_ids": {"n4140": {"so_19048667_19048781_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6141}}, "n3337": {"so_19048667_19048781_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5905}}, "n4659": {"so_19048667_19048781_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 7603}}}, "19048667": {"ViewCount": "318", "Body": "<p>I have a large block of code that is designed to take an array and work through it. In the current project there will be only one element so instead of changing the variable to a char i declared it as char array[1]. This way i do not need to modify my code and risk adding any bugs and can easily increase it if the requirements grow. </p>\n<p>It appears to compile ok but i have become curious about what is happening under the hood, am i wasting memory ? is this adding extra processing time, will the compiler optimise it all away so it would be no different if i typed it out ?</p>\n<p>can anyone explain any possible drawbacks to using arrays is this way. </p>\n<p>I use c and c++, would it be any different between them ?</p>\n", "AcceptedAnswerId": "19049059", "Title": "What happens to array[1]", "CreationDate": "2013-09-27T10:35:38.257", "Id": "19048667", "CommentCount": "0", "LastEditDate": "2013-09-27T12:33:17.017", "PostTypeId": "1", "LastEditorUserId": "2818099", "LastActivityDate": "2013-09-28T09:47:20.750", "Score": "4", "OwnerUserId": "686054", "Tags": "<c++><c><arrays><optimization>", "AnswerCount": "4"}});