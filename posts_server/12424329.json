post_cb({"12424329": {"CommentCount": "7", "ViewCount": "2064", "CreationDate": "2012-09-14T12:13:08.323", "LastActivityDate": "2012-09-14T12:39:56.770", "Title": "Erase by iterator on a C++ STL map", "AcceptedAnswerId": "12424757", "PostTypeId": "1", "Id": "12424329", "Score": "2", "Body": "<p>I'm curious about the rationale behind the following code. For a given map, I can delete a range up to, but not including, <code>end()</code> (obviously,) using the following code:</p>\n<pre><code>map&lt;string, int&gt; myMap;\nmyMap[\"one\"] = 1;\nmyMap[\"two\"] = 2;\nmyMap[\"three\"] = 3;\n\nmap&lt;string, int&gt;::iterator it = myMap.find(\"two\");\n\nmyMap.erase( it, myMap.end() );\n</code></pre>\n<p>This erases the last two items using the range. However, if I used the single iterator version of erase, I half expected passing <code>myMap.end()</code> to result in no action as the iterator was clearly at the end of the collection. This is as distinct from a corrupt or invalid iterator which would clearly lead to undefined behaviour.</p>\n<p>However, when I do this:</p>\n<pre><code>myMap.erase( myMap.end() );\n</code></pre>\n<p>I simply get a segmentation fault. I wouldn't have thought it difficult for map to check whether the iterator equalled <code>end()</code> and not take action in that case. Is there some subtle reason for this that I'm missing? I noticed that even this works:</p>\n<pre><code>myMap.erase( myMap.end(), myMap.end() );\n</code></pre>\n<p>(i.e. does nothing)</p>\n<p>The reason I ask is that I have some code which receives a valid iterator to the collection (but which could be <code>end()</code>) and I wanted to simply pass this into erase rather than having to check first like this:</p>\n<pre><code>if ( it != myMap.end() )\n    myMap.erase( it );\n</code></pre>\n<p>which seems a bit clunky to me. The alternative is to re code so I can use the by-key-type erase overload but I'd rather not re-write too much if I can help it.</p>\n", "Tags": "<c++><stl><map><iterator><erase>", "OwnerUserId": "258009", "AnswerCount": "3"}, "12424575": {"ParentId": "12424329", "CommentCount": "0", "CreationDate": "2012-09-14T12:27:45.280", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "12424575", "Score": "1", "Body": "<p>When you use two iterators to specify a range, the range consists of the elements from the element that the first iterator points to up to but not including the element that the second iterator points to. So <code>erase(it, myMap.end())</code> says to erase everything from <code>it</code> up to but not including <code>end()</code>. You could equally well pass an iterator that points to a \"real\" element as the second one, and the element that that iterator points to would not be erased.</p>\n<p>When you use <code>erase(it)</code> it says to erase the element that <code>it</code> points to. The <code>end()</code> iterator does not point to a valid element, so <code>erase(end())</code> doesn't do anything sensible. It would be possible for the library to diagnose this situation, and a debugging library will do that, but it imposes a cost on every call to <code>erase</code> to check what the iterator points to. The standard library doesn't impose that cost on users. You're on your own. <code>&lt;g&gt;</code></p>\n", "LastActivityDate": "2012-09-14T12:27:45.280"}, "12424757": {"ParentId": "12424329", "CommentCount": "0", "CreationDate": "2012-09-14T12:39:56.770", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "12424757", "Score": "5", "Body": "<p>The key is that in the standard library ranges determined by two iterators are half-opened ranges. In math notation <code>[a,b)</code> They include the first but not the last iterator (if both are the same, the range is empty). At the same time, <code>end()</code> returns an iterator that is <em>one beyond the last</em> element, which perfectly matches the half-open range notation.</p>\n<p>When you use the range version of <code>erase</code> it will never try to delete the element referenced by the last iterator. Consider a modified example:</p>\n<pre><code>map&lt;int,int&gt; m;\nfor (int i = 0; i &lt; 5; ++i)\n   m[i] = i;\nm.erase( m.find(1), m.find(4) );\n</code></pre>\n<p>At the end of the execution the map will hold two keys <code>0</code> and <code>4</code>. Note that the element referred by the second iterator was <em>not</em> erased from the container.</p>\n<p>On the other hand, the single iterator operation will erase the element referenced by the iterator. If the code above was changed to:</p>\n<pre><code>for (int i = 1; i &lt;= 4; ++i ) \n   m.erase( m.find(i) );\n</code></pre>\n<p>The element with key <code>4</code> will be deleted. In your case you will attempt to delete the end iterator that does not refer to a valid object.</p>\n<blockquote>\n<p id=\"so_12424329_12424757_0\">I wouldn't have thought it difficult for map to check whether the iterator equalled end() and not take action in that case.</p>\n</blockquote>\n<p>No, it is not hard to do, but the function was designed with a different contract in mind: the caller must pass in an iterator into an element in the container. Part of the reason for this is that in C++ most of the features are designed so that the incur the minimum cost possible, allowing the user to balance the safety/performance on their side. The user can test the iterator before calling <code>erase</code>, but if that test was inside the library then the user would not be able to opt out of testing when she knows that the iterator is valid.</p>\n", "LastActivityDate": "2012-09-14T12:39:56.770"}, "12424421": {"ParentId": "12424329", "CommentCount": "2", "CreationDate": "2012-09-14T12:18:05.790", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "12424421", "Score": "1", "Body": "<p>n3337 23.2.4 Table 102</p>\n<pre><code>a.erase( q1, q2)\n</code></pre>\n<p><blockquote><p id=\"so_12424329_12424421_0\">\nerases all the elements in the <strong>range [q1,q2)</strong>. Returns q2.</p></blockquote></p>\n<p>So, <code>iterator</code> returning from <code>map::end()</code> is not in range in case of <code>myMap.erase(myMap.end(), myMap.end())</code>;</p>\n<pre><code>a.erase(q)\n</code></pre>\n<p><blockquote><p id=\"so_12424329_12424421_1\">\nerases the element pointed to by q. Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns a.end().</p></blockquote></p>\n<blockquote>\n<p id=\"so_12424329_12424421_2\">I wouldn't have thought it difficult for map to check whether the\n  iterator equalled end() and not take action in that case. Is there\n  some subtle reason for this that I'm missing?</p>\n</blockquote>\n<p>Reason is same, that <code>std::vector::operator[]</code> can don't check, that index is in range, of course.</p>\n", "LastActivityDate": "2012-09-14T12:18:05.790"}, "bq_ids": {"n4140": {"so_12424329_12424421_0": {"section_id": 744, "quality": 0.8333333333333334, "length": 5}, "so_12424329_12424421_1": {"section_id": 744, "quality": 1.0, "length": 18}}, "n3337": {"so_12424329_12424421_0": {"section_id": 733, "quality": 0.8333333333333334, "length": 5}, "so_12424329_12424421_1": {"section_id": 733, "quality": 1.0, "length": 18}}, "n4659": {"so_12424329_12424421_0": {"section_id": 802, "quality": 0.8333333333333334, "length": 5}, "so_12424329_12424421_1": {"section_id": 802, "quality": 1.0, "length": 18}}}});