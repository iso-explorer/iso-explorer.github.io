post_cb({"35912322": {"ViewCount": "148", "Body": "<p>Many times I see (and sometimes write) code similar to this example:</p>\n<pre><code>int a=0, b=2;\nif( a &amp;&amp; (b=func())!=0 ) {\n//...\n</code></pre>\n<p>The question is: does the standard guarantee these statements?</p>\n<ol>\n<li><code>b</code> will be not touched (and remain value <code>2</code>)</li>\n<li><code>func()</code> will not be called</li>\n</ol>\n<p>And vice-versa, if we write <code>if( func()!=0 &amp;&amp; a )</code> - does the standard guarantee <code>func()</code> will be called?</p>\n<p>I'm interested in the particular standard paragraph defining this is legitimate.</p>\n<p><strong>UPD:</strong> my typo, changed from <code>int a=1</code> to <code>int a=0</code></p>\n", "AcceptedAnswerId": "35912619", "Title": "C and C++ operand resolution order", "CreationDate": "2016-03-10T09:26:10.977", "Id": "35912322", "CommentCount": "6", "LastEditDate": "2016-03-10T10:06:33.387", "PostTypeId": "1", "LastEditorUserId": "1671032", "LastActivityDate": "2016-03-10T10:13:01.867", "Score": "1", "OwnerUserId": "1671032", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "5"}, "35912501": {"Id": "35912501", "PostTypeId": "2", "Body": "<p>From the C-90 standard.</p>\n<blockquote>\n<p id=\"so_35912322_35912501_0\">6.5.13 Logical AND operator</p>\n<p id=\"so_35912322_35912501_1\">....</p>\n<p id=\"so_35912322_35912501_2\">4 Unlike the bitwise binary &amp; operator, the &amp;&amp; operator guarantees left-to-right evaluation;\n  there is a sequence point after the evaluation of the first operand. If the first operand\n  compares equal to 0, the second operand is not evaluated.</p>\n</blockquote>\n<p>Similarly for the Logical OR operator.</p>\n", "LastActivityDate": "2016-03-10T09:33:06.030", "CommentCount": "0", "CreationDate": "2016-03-10T09:33:06.030", "ParentId": "35912322", "Score": "4", "OwnerUserId": "3555525"}, "35912431": {"Id": "35912431", "PostTypeId": "2", "Body": "<p>The standard guarantees that the statements in a sequence of <code>&amp;&amp;</code> are evaluated from left to right, and that as soon as one of them evaluates to false, the ones to the right of that will not be evaluated.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2016-03-10T10:13:01.867", "Score": "2", "CreationDate": "2016-03-10T09:30:42.123", "ParentId": "35912322", "CommentCount": "0", "OwnerUserId": "4847311", "LastEditDate": "2016-03-10T10:13:01.867"}, "35912455": {"Id": "35912455", "PostTypeId": "2", "Body": "<p>The <code>&amp;&amp;</code> operator requires both operands to be true. If the first operand evaluates to false, then the second operand will not be evaluated. But beause <code>a</code> is 1, it is considered true and the second expression (operand) is evaluated. Thus <code>func()</code> is called and its result assigned to <code>b</code> and then <code>b</code> is tested to be non-zero.</p>\n", "LastActivityDate": "2016-03-10T09:31:37.193", "CommentCount": "0", "CreationDate": "2016-03-10T09:31:37.193", "ParentId": "35912322", "Score": "2", "OwnerUserId": "3100312"}, "35912619": {"Id": "35912619", "PostTypeId": "2", "Body": "<p>To the exact question;</p>\n<blockquote>\n<p id=\"so_35912322_35912619_0\">The question is: does standard guarantee these statements?</p>\n</blockquote>\n<p>To the updated question; given <code>a=0</code>. If <code>a==0</code>, then yes, the short circuit evaluation would kick in and <code>func()</code> would not be called; the second operand would not be evaluated.</p>\n<p>If <code>a=1</code> (as it was originally), the opposite; <code>func()</code> will be called - <code>a</code> is <code>1</code> thus \"true\", as a result the second operand is evaluated (it is a logical AND), <code>b</code> will change. If the operator had been <code>||</code> (logical OR), then short circuit evaluation would kick in and <code>func()</code> would not be called.</p>\n<blockquote>\n<p id=\"so_35912322_35912619_1\">And vice-versa, if we write <code>if( func()!=0 &amp;&amp; a )</code> -- does standard guarantee <code>func()</code> will be called?</p>\n</blockquote>\n<p>Yes, the first operand is always evaluated.</p>\n<hr>\n<p>Yes, short circuit evaluation is guaranteed for C++;</p>\n<p><em>\u00a75.14 Logical AND operator</em></p>\n<blockquote>\n<p id=\"so_35912322_35912619_2\">1 The <code>&amp;&amp;</code> operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). The result is true if both operands are true and false otherwise. Unlike <code>&amp;</code>, <code>&amp;&amp;</code> guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is false.</p>\n<p id=\"so_35912322_35912619_3\">2 The result is a bool. If the second expression is evaluated, every value computation and side effect associated with the first expression is sequenced before every value computation and side effect associated with the second expression.</p>\n</blockquote>\n<p><em>\u00a75.15 Logical OR operator</em></p>\n<blockquote>\n<p id=\"so_35912322_35912619_4\">1 The <code>||</code> operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). It returns true if either of its operands is true, and false otherwise. Unlike <code>|</code>, <code>||</code> guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to true.</p>\n<p id=\"so_35912322_35912619_5\">2 The result is a bool. If the second expression is evaluated, every value computation and side effect associated with the first expression is sequenced before every value computation and side effect associated with the second expression.</p>\n</blockquote>\n<hr>\n<p>The corresponding quotes for C are;</p>\n<p><em>\u00a76.5.13 Logical AND operator</em></p>\n<blockquote>\n<p id=\"so_35912322_35912619_6\">4 Unlike the bitwise binary <code>&amp;</code> operator, the <code>&amp;&amp;</code> operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares equal to 0, the second operand is not evaluated.</p>\n</blockquote>\n<p><em>\u00a76.5.14 Logical OR operator</em></p>\n<blockquote>\n<p id=\"so_35912322_35912619_7\">4 Unlike the bitwise <code>|</code> operator, the <code>||</code> operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares unequal to 0, the second operand is not evaluated.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2016-03-10T10:08:12.027", "Score": "4", "CreationDate": "2016-03-10T09:37:01.363", "ParentId": "35912322", "CommentCount": "5", "OwnerUserId": "3747990", "LastEditDate": "2016-03-10T10:08:12.027"}, "bq_ids": {"n4140": {"so_35912322_35912619_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 6165}, "so_35912322_35912619_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 6164}, "so_35912322_35912619_2": {"length": 26, "quality": 0.896551724137931, "section_id": 6163}, "so_35912322_35912619_5": {"length": 23, "quality": 0.9583333333333334, "section_id": 6164}}, "n3337": {"so_35912322_35912619_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 5926}, "so_35912322_35912619_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 5925}, "so_35912322_35912619_2": {"length": 26, "quality": 0.896551724137931, "section_id": 5924}, "so_35912322_35912619_5": {"length": 23, "quality": 0.9583333333333334, "section_id": 5925}}, "n4659": {"so_35912322_35912619_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 7662}, "so_35912322_35912619_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 7661}, "so_35912322_35912619_2": {"length": 26, "quality": 0.896551724137931, "section_id": 7660}, "so_35912322_35912619_5": {"length": 23, "quality": 0.9583333333333334, "section_id": 7661}}}, "35912546": {"Id": "35912546", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35912322_35912546_0\">The question is: does standard guarantee these statements?</p>\n<p id=\"so_35912322_35912546_1\">b will be not touched (and remain value 2)</p>\n<p id=\"so_35912322_35912546_2\">func() will not be called</p>\n</blockquote>\n<p>No, in fact both of them wrong in this case. Because it's operator <code>&amp;&amp;</code> so no shortcut logic can be applied in this particular case.</p>\n<p>If you change it to <code>||</code> then your statements are correct - only then the evaluation of the first operand (<code>a = 1</code> in this case) will be enough and the rest is ignored. </p>\n<hr>\n<p>As the question changed to <code>a = 0</code> then yes, both statements are correct and guaranteed.</p>\n</hr>", "LastEditorUserId": "4975822", "LastActivityDate": "2016-03-10T10:10:30.930", "Score": "-1", "CreationDate": "2016-03-10T09:34:28.780", "ParentId": "35912322", "CommentCount": "4", "OwnerUserId": "4975822", "LastEditDate": "2016-03-10T10:10:30.930"}});