post_cb({"21680686": {"ParentId": "21680251", "CommentCount": "1", "Body": "<p>The simple answer is no.  There is no requirement that the\nelement comparisons be done in order.  But since you're using\n<code>std::string</code>, which have random access iterators (and\na <code>size()</code> function), it's trivial to check beforehand that the\nlength is enough:</p>\n<pre><code>if ( ip_list[i].size() &gt;= my_ip_prefix\n        &amp;&amp; std::equal( my_ip_prefix.begin(), my_ip_prefix.end(), ip_list[i].begin() ) ) {\n    //  ...\n}\n</code></pre>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "21680686", "Score": "2", "CreationDate": "2014-02-10T15:07:11.347", "LastActivityDate": "2014-02-10T15:07:11.347"}, "21680251": {"CommentCount": "3", "ViewCount": "235", "PostTypeId": "1", "LastEditorUserId": "700825", "CreationDate": "2014-02-10T14:47:08.663", "LastActivityDate": "2014-02-11T14:15:17.547", "Title": "Is it safe to call std::equal on potentially shorter input if I know there will be difference detected within size of input", "AcceptedAnswerId": "21680371", "LastEditDate": "2014-02-10T18:36:53.350", "Id": "21680251", "Score": "4", "Body": "<p>While doing some nw programming I stumbled upon the following dilemma:</p>\n<p>Im doing something like:</p>\n<pre><code>static const string my_ip_prefix = \"111.222.233\";\n\n//going through list of IPs where one might have prefix my_ip_prefix\n\nif (equal(my_ip_prefix .begin(), my_ip_prefix .end(), ip_list[i].begin())))\n{\n//\n}\n</code></pre>\n<p>If I know IPs from <code>ip_list</code> can be shorter than my_ip_prefix, but that in that case they differ from <code>my_ip_prefix</code> on at least one position in them is it safe to call equal? \nExample : is it safe to call it with ip <code>\"10.20.30.4\"</code></p>\n<p>Aka does standard mandates sequential checks starting from front and <code>break;</code> in <code>std::equal</code>?</p>\n<p>It might seem obvious that A is yes, but maybe ISO ppl wanted to give option implementations to parallelize...  </p>\n", "Tags": "<c++><stl>", "OwnerUserId": "700825", "AnswerCount": "3"}, "21680416": {"ParentId": "21680251", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If we look at the <a href=\"http://en.cppreference.com/w/\" rel=\"nofollow\">cppreference</a> entry for <a href=\"http://en.cppreference.com/w/cpp/algorithm/equal\" rel=\"nofollow\">std::equal</a> it says:</p>\n<blockquote>\n<p id=\"so_21680251_21680416_0\">[...]where last2 denotes first2 + (last1 - first1)</p>\n</blockquote>\n<p>which means that <code>ip_list[i]</code> will need to be at least as long. This corresponds with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> which in section <code>25.2.11</code> <em>Equal</em> says:</p>\n<pre><code>template&lt;class InputIterator1, class InputIterator2&gt;\n  bool equal(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2);\n</code></pre>\n<blockquote>\n<p id=\"so_21680251_21680416_1\">Returns: true if for every iterator i in the range [first1,last1) the following corresponding conditions hold: *i == *(first2 + (i - first1)), [...]</p>\n</blockquote>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">C++14</a> you have a version of that takes a end iterator for the second input, same section as <em>C++11</em>:</p>\n<pre><code>template&lt;class InputIterator1, class InputIterator2&gt;\n  bool equal(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2);\n</code></pre>\n<p>and it says:</p>\n<blockquote>\n<p id=\"so_21680251_21680416_2\">If last1 - first1 != last2 - first2, return false. [...]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-02-11T14:15:17.547", "Id": "21680416", "Score": "5", "CreationDate": "2014-02-10T14:55:11.630", "LastActivityDate": "2014-02-11T14:15:17.547"}, "bq_ids": {"n4140": {"so_21680251_21680416_2": {"section_id": 1273, "quality": 1.0, "length": 6}, "so_21680251_21680416_1": {"section_id": 1273, "quality": 0.8333333333333334, "length": 10}, "so_21680251_21680416_0": {"section_id": 1269, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_21680251_21680416_2": {"section_id": 1259, "quality": 0.6666666666666666, "length": 4}, "so_21680251_21680416_1": {"section_id": 1269, "quality": 0.8333333333333334, "length": 10}, "so_21680251_21680416_0": {"section_id": 1259, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_21680251_21680416_2": {"section_id": 1393, "quality": 1.0, "length": 6}, "so_21680251_21680416_1": {"section_id": 1393, "quality": 0.8333333333333334, "length": 10}, "so_21680251_21680416_0": {"section_id": 1389, "quality": 0.8333333333333334, "length": 5}}}, "21680371": {"ParentId": "21680251", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>C++03 <code>std::equal()</code> requires the second sequence to be at least as long as the first one.</p>\n<p>In C++14 there is another overload of <a href=\"http://en.cppreference.com/w/cpp/algorithm/equal\" rel=\"nofollow\"><code>std::equal()</code></a> that takes two iterators for the second sequence.</p>\n<hr>\n<p>You should convert the IP addresses into <code>uint32_t</code> and compare those instead, e.g.:</p>\n<pre><code>auto ip_prefix = ::inet_addr(\"111.222.233.0\");\nauto ip_mask = ::inet_addr(\"255.255.255.0\");\n\nbool compare(in_addr_t a, in_addr_t b, in_addr_t mask) {\n    return (a &amp; mask) == (b &amp; mask);\n}\n\nint main() {\n    std::cout &lt;&lt; compare(ip_prefix, ::inet_addr(\"1.1.1.1\"), ip_mask) &lt;&lt; '\\n';\n    std::cout &lt;&lt; compare(ip_prefix, ::inet_addr(\"111.222.233.3\"), ip_mask) &lt;&lt; '\\n';\n}\n</code></pre>\n</hr>", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2014-02-10T15:11:24.377", "Id": "21680371", "Score": "4", "CreationDate": "2014-02-10T14:52:54.987", "LastActivityDate": "2014-02-10T15:11:24.377"}});