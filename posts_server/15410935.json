post_cb({"15410996": {"ParentId": "15410935", "CommentCount": "4", "Body": "<p>That is a bug. At the end of the complete expression <code>const int &amp;myIntRef = f()[0];</code> the temporary vector will be destroyed and the memory released. Any later use of <code>myIntRef</code> is undefined behavior.</p>\n<p>Under some circumstances, binding a reference to a temporary can extend the lifetime of the temporary. This is not one of such cases, the compiler does not know whether the reference returned by <code>std::vector&lt;int&gt;::operator[]</code> is part of the temporary or a reference to an <code>int</code> with static storage duration or any other thing, and it won't extend the lifetime.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "15410996", "Score": "11", "CreationDate": "2013-03-14T13:42:25.973", "LastActivityDate": "2013-03-14T13:42:25.973"}, "bq_ids": {"n4140": {"so_15410935_15411077_1": {"section_id": 380, "quality": 1.0, "length": 14}}, "n3337": {"so_15410935_15411077_1": {"section_id": 371, "quality": 1.0, "length": 14}}, "n4659": {"so_15410935_15411077_1": {"section_id": 395, "quality": 1.0, "length": 14}}}, "15410935": {"CommentCount": "2", "ViewCount": "1364", "PostTypeId": "1", "LastEditorUserId": "2170028", "CreationDate": "2013-03-14T13:39:51.463", "LastActivityDate": "2013-03-14T14:12:09.100", "Title": "Reference to element of vector returned by a function in C++", "AcceptedAnswerId": "15411077", "LastEditDate": "2013-03-14T14:00:13.783", "Id": "15410935", "Score": "7", "Body": "<p>Can someone verify that the following is a BUG, and explain why? I think I know, but am unclear about the details. (My actual problem involved a vector of enums, not ints, but I don't think it should matter.) Suppose I have the following code:</p>\n<pre><code>std::vector&lt;int&gt; f (void) {\n  std::vector&lt;int&gt; v;\n  v.push_back(5);\n  return v;\n}\n\nvoid g (void) {\n  const int &amp;myIntRef = f()[0];\n  std::cout &lt;&lt; myIntRef &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Am I correct that myIntRef is immediately a dangling reference, because the return value of f is saved nowhere on the stack?</p>\n<p>Also, is the following a valid fix, or is it still a bug?</p>\n<pre><code>  const int myIntCopy = f()[0];  // copy, not a reference\n</code></pre>\n<p>In other words, is the return result of f() thrown away before the 0th element can be copied?</p>\n", "Tags": "<c++><memory-management><reference><return><return-by-value>", "OwnerUserId": "2170028", "AnswerCount": "2"}, "15411077": {"ParentId": "15410935", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes, it is wrong thing to do indeed. When you call:</p>\n<pre><code>return v;\n</code></pre>\n<p>temporary copy of object <code>v</code> is being created and</p>\n<pre><code>const int &amp;myIntRef = f()[0];\n</code></pre>\n<p>initializes your reference with the first element of this temporary copy. After this line, the temporary copy no longer exists, meaning that <code>myIntRef</code> is an invalid reference, using of which produces <strong>undefined behavior</strong>.</p>\n<p>What you should do is:</p>\n<pre><code>std::vector&lt;int&gt; myVector = f();\nconst int &amp;myIntRef = myVector[0];\nstd::cout &lt;&lt; myIntRef &lt;&lt; std::endl;\n</code></pre>\n<p>which (thanks to <em>copy elision</em>) uses an assignment operator to initialize <code>myVector</code> object by using <code>v</code> without copy of <code>v</code> being created. In this case the lifetime of your reference is equal to the lifetime of <code>myVector</code> object, making it perfectly valid code.</p>\n<hr>\n<p>And to your second question:</p>\n<blockquote>\n<p id=\"so_15410935_15411077_0\"><em>\"Also, is the following a valid fix, or is it still a bug?\"</em></p>\n<pre><code> const int myIntCopy = f()[0];  // copy, not a reference\n</code></pre>\n</blockquote>\n<p>Yes, this is another possible solution. <code>f()[0]</code> will access the first element of the temporary copy and use its value to initialize <code>myIntCopy</code> variable. It is guaranteed that the copy of <code>v</code> returned by <code>f()</code> exists at least until the whole expression is executed, see <em>C++03 Standard 12.2 Temporary objects \u00a73</em>:</p>\n<blockquote>\n<p id=\"so_15410935_15411077_1\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>\n</blockquote>\n</hr>", "OwnerUserId": "1168156", "LastEditorUserId": "1168156", "LastEditDate": "2013-03-14T14:12:09.100", "Id": "15411077", "Score": "2", "CreationDate": "2013-03-14T13:46:16.093", "LastActivityDate": "2013-03-14T14:12:09.100"}});