post_cb({"bq_ids": {"n4140": {"so_8464400_8585258_0": {"length": 6, "quality": 1.0, "section_id": 3296}, "so_8464400_8585258_1": {"length": 15, "quality": 1.0, "section_id": 6030}, "so_8464400_8585258_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}, "so_8464400_8585258_3": {"length": 8, "quality": 1.0, "section_id": 6126}}, "n3337": {"so_8464400_8585258_0": {"length": 6, "quality": 1.0, "section_id": 3166}, "so_8464400_8585258_1": {"length": 15, "quality": 1.0, "section_id": 5798}, "so_8464400_8585258_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}, "so_8464400_8585258_3": {"length": 8, "quality": 1.0, "section_id": 5890}}, "n4659": {"so_8464400_8585258_0": {"length": 6, "quality": 1.0, "section_id": 4058}, "so_8464400_8585258_3": {"length": 8, "quality": 1.0, "section_id": 7623}, "so_8464400_8585258_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 2}, "so_8464400_8585258_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}}}, "8464443": {"Id": "8464443", "PostTypeId": "2", "Body": "<p>The template argument deduction is not possible, in case of user-defined conversion function:</p>\n<pre><code>template &lt;class T1&gt;\noperator Point2D&lt;T1&gt;()\n{\n    return Point2D&lt;T1&gt;(x,y);\n}\n</code></pre>\n<p>How the template argument <code>T1</code> will be deduced by the compiler? It is not participating in the parameter list. Template argument deduction is possible only if the template parameter participates in the function parameter list.</p>\n<p>Since the template argument deduction is not possible, the constructor is invoked instead.</p>\n<p>Hope that helps.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-12-21T04:43:04.483", "Score": "1", "CreationDate": "2011-12-11T13:52:05.803", "ParentId": "8464400", "CommentCount": "5", "LastEditDate": "2011-12-21T04:43:04.483", "OwnerUserId": "415784"}, "8585258": {"Id": "8585258", "PostTypeId": "2", "Body": "<p>Section <code>[dcl.init]</code> of the standard specifies that constructors are preferred during initialization:</p>\n<blockquote>\n<p id=\"so_8464400_8585258_0\">If the destination type is a (possibly cv-qualified) class type:</p>\n<ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, <strong>constructors are considered</strong>. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n<li><strong>Otherwise</strong> (i.e.,  for the remaining copy-initialization cases),  user-de\ufb01ned conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed.  The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type. The temporary is a prvalue. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization.  In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</li>\n</ul>\n</blockquote>\n<p>This rule means that user-defined conversion sequences are only considered if no constructor applies.</p>\n<p>Casts use the same rule as initialization, see <code>[expr.static.cast]</code>:</p>\n<blockquote>\n<p id=\"so_8464400_8585258_1\">an expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5).</p>\n</blockquote>\n<p>and <code>[expr.cast]</code>:</p>\n<blockquote>\n<p id=\"so_8464400_8585258_2\">The conversions performed by</p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,</li>\n</ul>\n<p id=\"so_8464400_8585258_3\">can be performed using the cast notation of explicit type conversion.</p>\n</blockquote>\n<p>Also note <code>[class.conv.ctor]</code>:</p>\n<blockquote>\n<p id=\"so_8464400_8585258_4\">An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9,  5.4) are  explicitly used.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-21T04:59:35.877", "Score": "3", "CreationDate": "2011-12-21T04:59:35.877", "ParentId": "8464400", "CommentCount": "0", "OwnerUserId": "103167"}, "8464400": {"ViewCount": "3027", "Body": "<p>I have this code. In main I want use type conversion, but with using debug I understand that in this line\n<code>ob2=(Point2D&lt;double&gt;)ob1;</code> </p>\n<p>constructor <code>template &lt;class T1&gt; Point2D(Point2D&lt;T1&gt;&amp; ob)</code> is invoked regardless of <code>explicit</code> before i.e. <code>template &lt;class T1&gt; explicit Point2D(Point2D&lt;T1&gt;&amp; ob)</code> Why does this happen? I expect that <code>operator Point2D&lt;T1&gt;()</code> is invoked.</p>\n<pre><code>template &lt;class T&gt;\nclass Point2D\n{\npublic:\n    T x;\n    T y;\n    Point2D(T _x=0,T _y=0):x(_x),y(_y)\n    {\n    }\n    Point2D(Point2D&amp; ob)\n    {\n        x=ob.x;\n        y=ob.y;\n    }\n    template &lt;class T1&gt;\n    Point2D(Point2D&lt;T1&gt;&amp; ob)\n    {\n        x=ob.x;\n        y=ob.y;\n    }\n    template &lt;class T1&gt;\n    operator Point2D&lt;T1&gt;()\n    {\n        return Point2D&lt;T1&gt;(x,y);\n    }\n};\nint main()\n{\n    Point2D&lt;int&gt; ob1(10,10);\n    Point2D&lt;double&gt; ob2(20,20);\n    ob2=(Point2D&lt;double&gt;)ob1;\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "8585258", "Title": "Type conversion operator in template class - invoked regardless of explicit", "CreationDate": "2011-12-11T13:45:28.277", "Id": "8464400", "CommentCount": "0", "LastEditDate": "2011-12-11T13:48:20.550", "PostTypeId": "1", "LastEditorUserId": "964135", "LastActivityDate": "2011-12-21T04:59:35.877", "Score": "5", "OwnerUserId": "1072878", "Tags": "<c++><templates><type-conversion>", "AnswerCount": "2"}});