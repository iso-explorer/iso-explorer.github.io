post_cb({"bq_ids": {"n4140": {"so_27840925_27881306_3": {"length": 13, "quality": 1.0, "section_id": 5990}, "so_27840925_27840925_0": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_27840925_27881306_9": {"length": 14, "quality": 0.7, "section_id": 3321}, "so_27840925_27881306_4": {"length": 23, "quality": 0.8846153846153846, "section_id": 5954}, "so_27840925_27881306_6": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_27840925_27881306_8": {"length": 15, "quality": 0.8333333333333334, "section_id": 3321}, "so_27840925_27840925_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_27840925_27881306_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 3321}, "so_27840925_27881306_2": {"length": 21, "quality": 1.0, "section_id": 5997}}, "n3337": {"so_27840925_27881306_6": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_27840925_27840925_0": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_27840925_27881306_9": {"length": 13, "quality": 0.65, "section_id": 3191}, "so_27840925_27881306_4": {"length": 23, "quality": 0.8846153846153846, "section_id": 5724}, "so_27840925_27881306_3": {"length": 13, "quality": 1.0, "section_id": 5758}, "so_27840925_27881306_8": {"length": 14, "quality": 0.7777777777777778, "section_id": 3191}, "so_27840925_27840925_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_27840925_27881306_2": {"length": 21, "quality": 1.0, "section_id": 5765}, "so_27840925_27881306_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 3191}}, "n4659": {"so_27840925_27881306_3": {"length": 13, "quality": 1.0, "section_id": 7490}, "so_27840925_27840925_0": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_27840925_27881306_4": {"length": 22, "quality": 0.8461538461538461, "section_id": 7441}, "so_27840925_27881306_6": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_27840925_27881306_8": {"length": 11, "quality": 0.6111111111111112, "section_id": 4087}, "so_27840925_27840925_1": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_27840925_27881306_2": {"length": 21, "quality": 1.0, "section_id": 7498}, "so_27840925_27881306_7": {"length": 12, "quality": 0.8571428571428571, "section_id": 4087}}}, "27881306": {"Id": "27881306", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27840925_27881306_0\">the initializer expression is an lvalue and <code>int</code> is reference-compatible with <code>int</code> (or with <code>int&amp;</code> - I don't know for sure which one I should use here).</p>\n</blockquote>\n<p>Reference-compatibility is a relation applied to the type referred to, not the reference type. For example, [dcl.init.ref]/5 talks about intializing \"a reference to type <em>cv1</em> <code>T1</code> by an expression of type <em>cv2</em> <code>T2</code>\", and later compares e.g. \"where <code>T1</code> is not reference-related to <code>T2</code>\".</p>\n<p>The type of the expression <code>f()</code> is just <code>int</code>, despite the fact that the return type of <code>f</code> is <code>int&amp;</code>. Expressions simply do not have reference type when we observe them<sup>(*)</sup>; the reference is stripped and used to determine the value category (see [expr]/5). For <code>int&amp; f()</code>, the expression <code>f()</code> is an lvalue; for <code>int g()</code>, the expression <code>g()</code> is an rvalue.</p>\n<p><sub><sup>(*)</sup>To be perfectly precise, expressions <a href=\"http://scottmeyers.blogspot.de/2015/02/expressions-can-have-reference-type.html\" rel=\"nofollow\">can have reference type in the Standard</a>, but only as the \"initial\" resulting type. The reference is dropped \"prior to any further analysis\", which implies that this referencess is simply not observable through the type.</sub></p>\n<hr>\n<blockquote>\n<p id=\"so_27840925_27881306_1\">Now suppose I change the left value reference in the declaration <code>int&amp; r = f();</code> by a right value reference, i.e., <code>int&amp;&amp; r = f();</code>. I know the code won't compile, as an rvalue reference doesn't bind to an lvalue. But what I'm curious is, how to reach this conclusion using the Standard?</p>\n</blockquote>\n<p>The confusion, as it seems from the discussion in the comments, seems to be that <code>f()</code> is not a function lvalue. Value categories such as \"lvalue\" and \"rvalue\" are properties of expressions. The term \"function lvalue\" must therefore refer to an expression, namely an <em>expression of function type with the value category \"lvalue\"</em>.</p>\n<p>But the expression <code>f()</code> is a <strong><em>function call expression</em></strong>. Grammatically, it's a <em>postfix-expression</em>, the postfix being the function argument list. As per [expr.call]/10:</p>\n<blockquote>\n<p id=\"so_27840925_27881306_2\">A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n<p>And [expr.call]/3</p>\n<blockquote>\n<p id=\"so_27840925_27881306_3\">If the <em>postfix-expression</em> designates a destructor [...]; otherwise, the type of the function call expression is the return type of the statically chosen function [...]</p>\n</blockquote>\n<p>That is, the (observed <sup>see above</sup>) type of the expression <code>f()</code> is <code>int</code>, and the value category is \"lvalue\". Note that the (observed) type is <strong>not</strong> <code>int&amp;</code>.</p>\n<p>A function lvalue is for example an <em>id-expression</em> like <code>f</code>, the result of indirecting a function pointer, or an expression yielding any kind of reference to function:</p>\n<pre><code>using ft = void();\nvoid f();\nft&amp;  l();\nft&amp;&amp; r();\nft*  p();\n\n// function lvalue expressions:\nf\nl()\nr()\n*p()\n</code></pre>\n<p>[expr.prim.general]/8 specifies that those identifiers like <code>f</code> are, as <em>id-expressions</em>, lvalues:</p>\n<blockquote>\n<p id=\"so_27840925_27881306_4\">An <em>identifier</em> is an <em>id-expression</em> provided it has been suitably declared. [...] The type of the expression is the type of the <em>identifier</em>. The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable, or data member and a prvalue otherwise.</p>\n</blockquote>\n<hr>\n<p>Back to the example <code>int&amp;&amp; r = f();</code>. Using some post-N4296 draft.</p>\n<blockquote>\n<p id=\"so_27840925_27881306_5\">[dcl.init.ref]</p>\n<p id=\"so_27840925_27881306_6\"><sup>5</sup> A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of type\n  \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n<ul>\n<li>(5.1) If the reference is an lvalue reference and the initializer expression</li>\n</ul>\n</blockquote>\n<p>The reference is an rvalue reference. 5.1 does not apply.</p>\n<blockquote id=\"so_27840925_27881306_7\">\n<ul>\n<li>(5.2) Otherwise, the reference shall be an lvalue reference to a\n  non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference\n   shall be an rvalue reference. [example omitted]</li>\n</ul>\n</blockquote>\n<p>This applies, the reference is an rvalue-reference.</p>\n<blockquote id=\"so_27840925_27881306_8\">\n<ul>\n<li>(5.2.1) If the initializer expression\n  <ul>\n<li>(5.2.1.1) is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and [...], or</li>\n<li>(5.2.1.2) has a class type (i.e., <code>T2</code> is a class type) [...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>The initializer is an lvalue of type <code>int</code>. 5.2.1 does not apply.</p>\n<blockquote id=\"so_27840925_27881306_9\">\n<ul>\n<li>(5.2.2) Otherwise:\n  <ul>\n<li>(5.2.2.1) If <code>T1</code> or <code>T2</code> is a class type [...]</li>\n<li>(5.2.2.2) Otherwise, a temporary of type \u201c<em>cv1</em> <code>T1</code>\u201d is created and copy-initialized (dcl.init) from the initializer expression. The reference is then bound to the temporary.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Finally, 5.2.2.2 applies. However:</p>\n<blockquote>\n<p id=\"so_27840925_27881306_10\">If <code>T1</code> is reference-related to <code>T2</code>:</p>\n<ul>\n<li>(5.2.2.3) <em>cv1</em> shall be the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>; and</li>\n<li>(5.2.2.4) if the reference is an rvalue reference, the initializer expression shall not be an lvalue.</li>\n</ul>\n</blockquote>\n<p><code>T1</code> and <code>T2</code> are <code>int</code> (the reference of the return type of <code>f()</code> is removed and used only to determine the value category), so they're reference-related. <em>cv1</em> and <em>cv2</em> are both empty. <strong>The reference is an rvalue reference, and <code>f()</code> is an lvalue, hence 5.2.2.4 renders the program ill-formed.</strong></p>\n<hr>\n<p>The reason why the term \"function lvalue\" appears in 5.2.1.1 might be related to the problem of \"function rvalues\" (see, for example, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3010.pdf\" rel=\"nofollow\">N3010 - Rvalue References as \"Funny\" Lvalues</a>). There were no function rvalues in C++03, and it seems the committee didn't want to introduce them in C++11. Without rvalue references, I think it's impossible to get a function rvalue. For example, you may not cast to a function type, and you may not return function types from a function.</p>\n<p>Probably for consistency, function lvalues can be bound to rvalue references to function types via a cast:</p>\n<pre><code>template&lt;typename T&gt;\nvoid move_and_do(T&amp; t)\n{\n    T&amp;&amp; r = static_cast&lt;T&amp;&amp;&gt;(t); // as if moved\n}\n\nint i = 42;\nmove_and_do(i);\n\nmove_and_do(f);\n</code></pre>\n<p>But for <code>T</code> being a function type like <code>void()</code>, the value category of <code>static_cast&lt;T&amp;&amp;&gt;(t)</code> is <em>lvalue</em> (there are no rvalues of function type). Hence, rvalue references to function types can bind to function lvalues.</p>\n</hr></hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2015-04-11T21:58:44.750", "Score": "5", "CreationDate": "2015-01-10T21:17:04.673", "ParentId": "27840925", "CommentCount": "3", "OwnerUserId": "420683", "LastEditDate": "2015-04-11T21:58:44.750"}, "27840925": {"ViewCount": "174", "Body": "<p>The snippet below compiles</p>\n<pre><code>#include &lt;iostream&gt;\nint&amp; f() { static int i = 100; std::cout &lt;&lt; i &lt;&lt; '\\n'; return i; }\n\nint main()\n{\n    int&amp; r = f();\n    r = 101;\n    f();\n}\n</code></pre>\n<p>and print the values (<a href=\"http://coliru.stacked-crooked.com/a/35b0b00dc085463f\" rel=\"nofollow\">live example</a>)</p>\n<pre><code>100\n101\n</code></pre>\n<p>Now, reading \u00a78.5.3/5 in N4140, I can see that it compiles because of bullet point (5.1.1), that is, the reference is an lvalue reference, the initializer expression is an lvalue and <code>int</code> is reference-compatible with <code>int</code> (or with <code>int&amp;</code> - I don't know for sure which one I should use here).</p>\n<p>Bullet points (5.1) and (5.1.1):</p>\n<blockquote>\n<p id=\"so_27840925_27840925_0\">\u2014 If the reference is an lvalue reference and the initializer expression</p>\n<pre><code> \u2014 is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with\n   \u201ccv2 T2,\u201d or ...\n</code></pre>\n</blockquote>\n<p>Now suppose I change the left value reference in the declaration <code>int&amp; r = f();</code> by a right value reference, i.e., <code>int&amp;&amp; r = f();</code>. I know the code won't compile, as an rvalue reference doesn't bind to an lvalue. But what I'm curious is, how to reach this conclusion using the Standard?</p>\n<p>I'll explain what are my difficulties:</p>\n<ol>\n<li>Clearly <code>int&amp;&amp; r = f();</code> is covered by bullet point (5.2), because the reference is an rvalue reference.</li>\n</ol>\n<p>Bullet point (5.2):</p>\n<blockquote>\n<p id=\"so_27840925_27840925_1\">\u2014 Otherwise, the reference shall be an lvalue reference to a\n  non-volatile const type (i.e., cv1 shall be const), or the reference\n  shall be an rvalue reference.</p>\n</blockquote>\n<ol start=\"2\">\n<li>In principle, I would say that (5.2.1.1) supports this initialization as the initializer is a function lvalue and <code>int</code> is reference compatible with <code>int</code> (or with <code>int&amp;</code>).</li>\n</ol>\n<p>Bullet points (5.2.1) and (5.2.1.1):</p>\n<blockquote>\n<p id=\"so_27840925_27840925_2\">\u2014 If the initializer expression</p>\n<pre><code>\u2014 is an xvalue (but not a bit-field), class prvalue, array prvalue or function\n  lvalue and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d, or ...\n</code></pre>\n</blockquote>\n<p><strong>Edit</strong></p>\n<p>I've included the bullet points verbatim from N4140 (C++14), which are equivalent to similar bullet points in N3337 (C++11).</p>\n", "AcceptedAnswerId": "27881306", "Title": "I'm having some difficulty interpreting bullet point (5.2.1.1) in paragraph \u00a78.5.3/5 of N4140", "CreationDate": "2015-01-08T13:09:50.197", "Id": "27840925", "CommentCount": "9", "LastEditDate": "2015-01-08T20:26:47.740", "PostTypeId": "1", "LastEditorUserId": "1042389", "LastActivityDate": "2015-04-11T21:58:44.750", "Score": "3", "OwnerUserId": "1042389", "Tags": "<c++><reference><initialization><language-lawyer><c++14>", "AnswerCount": "1"}});