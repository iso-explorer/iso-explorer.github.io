post_cb({"25486033": {"ViewCount": "1583", "Body": "<p>I have a templatized class like so :</p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\n    protected:\n    std::vector&lt;T&gt; myVector;\n\n    public:\n    /*\n    constructors + a bunch of member functions here\n    */\n}\n</code></pre>\n<p>I would like to add just ONE member function that would work only for 1 given type of T. Is it possible to do that at all without having to specialize the class and reimplement all the other already existing methods?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "25486107", "Title": "c++ class template specialization, without having to reimplement everything", "CreationDate": "2014-08-25T12:32:27.100", "Id": "25486033", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-06-27T19:51:12.883", "Score": "24", "OwnerUserId": "3975337", "Tags": "<c++><class><templates><specialization>", "AnswerCount": "5"}, "25491059": {"Id": "25491059", "PostTypeId": "2", "Body": "<p>The <code>static_assert</code> technique by @PiotrS. works nicely. But it's also nice to know that you can specialize a single member function without code duplication. Just give the generic <code>onlyForInts()</code> an empty no-op implementation, and specialize it out-of-class for <code>int</code></p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nclass A\n{\npublic:\n    void onlyForInts(T t)\n    {\n        // no-op\n    }\n\nprotected:\n    std::vector&lt;T&gt; myVector;\n};\n\ntemplate&lt;&gt;\nvoid A&lt;int&gt;::onlyForInts(int t)\n{\n    // works  \n}\n\nint main()\n{\n    A&lt;int&gt; i;\n    i.onlyForInts(1); // works !\n\n    A&lt;float&gt; f;\n    f.onlyForInts(3.14f); // compiles, but does nothing !\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2f790496fb1b3cf3\" rel=\"nofollow\"><strong>Live Example</strong></a>.</p>\n<p>This technique comes in handy if you want to have <code>int</code> specific behavior without completely disabling the generic behavior.</p>\n", "LastActivityDate": "2014-08-25T17:18:04.887", "CommentCount": "1", "CreationDate": "2014-08-25T17:18:04.887", "ParentId": "25486033", "Score": "2", "OwnerUserId": "819272"}, "25486166": {"Id": "25486166", "PostTypeId": "2", "Body": "<p>Yes, it's possible in C++03 with CRTP (<a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\">Curiously recurring template pattern</a>):</p>\n<pre><code>#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename Derived, typename T&gt;\nstruct Base\n{\n};\n\ntemplate&lt;typename Derived&gt;\nstruct Base&lt;Derived, int&gt;\n{\n    int Sum() const\n    {\n        return std::accumulate(static_cast&lt;Derived const*&gt;(this)-&gt;myVector.begin(), static_cast&lt;Derived const*&gt;(this)-&gt;myVector.end(), int());\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass A : public Base&lt;A&lt;T&gt;, T&gt;\n{\n    friend class Base&lt;A&lt;T&gt;, T&gt;;\n\nprotected:\n    std::vector&lt;T&gt; myVector;\n\npublic:\n    /*\n    constructors + a bunch of member functions here\n    */\n};\n\nint main()\n{\n    A&lt;int&gt; Foo;\n    Foo.Sum();\n}\n</code></pre>\n", "LastEditorUserId": "3903983", "LastActivityDate": "2014-08-25T13:26:42.443", "Score": "11", "CreationDate": "2014-08-25T12:38:52.283", "ParentId": "25486033", "CommentCount": "3", "OwnerUserId": "3903983", "LastEditDate": "2014-08-25T13:26:42.443"}, "bq_ids": {"n4140": {"so_25486033_25486107_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 236}, "so_25486033_25486107_0": {"length": 50, "quality": 0.9615384615384616, "section_id": 235}}, "n3337": {"so_25486033_25486107_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 229}, "so_25486033_25486107_0": {"length": 50, "quality": 0.9615384615384616, "section_id": 228}}, "n4659": {"so_25486033_25486107_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 246}, "so_25486033_25486107_0": {"length": 50, "quality": 0.9615384615384616, "section_id": 245}}}, "25486107": {"Id": "25486107", "PostTypeId": "2", "Body": "<p>The simplest and cleanest solution is to use a <code>static_assert()</code> in the body of a method, rejecting other types than the selected one (in the below example only integers are accepted):</p>\n<pre><code>#include &lt;type_traits&gt;  \n#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nclass A\n{\npublic:\n    void onlyForInts(T t)\n    {\n        static_assert(std::is_same&lt;T, int&gt;::value, \"Works only with ints!\");\n    }\n\nprotected:\n    std::vector&lt;T&gt; myVector;\n};\n\nint main()\n{\n    A&lt;int&gt; i;\n    i.onlyForInts(1); // works !\n\n    A&lt;float&gt; f;\n    //f.onlyForInts(3.14f); // does not compile !\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d606f228f18a2ae1\" rel=\"nofollow\"><kbd><strong>OK CASE DEMO</strong></kbd></a>\n<a href=\"http://coliru.stacked-crooked.com/a/7684e608271e73a1\" rel=\"nofollow\"><kbd><strong>NOK CASE DEMO</strong></kbd></a></p>\n<p>This utilizes the fact that a compiler instantiates a member function of a class template only when one is actually used <strong>(not when the class template is instantiated itself)</strong>. And with the above solution, when a compiler tries to do so, it fails due to the execution of a <code>static_assert</code>.</p>\n<p><em>C++ Standard Reference:</em></p>\n<blockquote>\n<h3>\u00a7 14.7.1 Implicit instantiation <code>[temp.inst]</code></h3>\n<ol start=\"3\">\n<li><p id=\"so_25486033_25486107_0\">Unless a function template specialization has been explicitly instantiated or explicitly specialized, the <strong>function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist</strong>. Unless a call is to a function template explicit specialization or to a member function of an explicitly specialized class template, a default argument for a function template or a member function of a class template is implicitly instantiated when the function is called in a context that requires the value of the default argument.</p></li>\n<li><p id=\"so_25486033_25486107_1\">[ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; struct Z {\n  void f();\n  void g();\n};\n\nvoid h() {\n  Z&lt;int&gt; a;     // instantiation of class Z&lt;int&gt; required\n  Z&lt;char&gt;* p;   // instantiation of class Z&lt;char&gt; not required\n  Z&lt;double&gt;* q; // instantiation of class Z&lt;double&gt; not required\n  a.f();        // instantiation of Z&lt;int&gt;::f() required\n  p-&gt;g();       // instantiation of class Z&lt;char&gt; required, and\n                // instantiation of Z&lt;char&gt;::g() required\n}\n</code></pre>\n<p id=\"so_25486033_25486107_2\">Nothing in this example requires <code>class Z&lt;double&gt;</code>, <code>Z&lt;int&gt;::g()</code>, or <code>Z&lt;char&gt;::f()</code> to be implicitly\n  instantiated. \u2014 <em>end example</em> ]</p></li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-27T19:51:12.883", "Score": "17", "CreationDate": "2014-08-25T12:36:09.000", "ParentId": "25486033", "CommentCount": "6", "OwnerUserId": "3953764", "LastEditDate": "2015-06-27T19:51:12.883"}, "25496789": {"Id": "25496789", "PostTypeId": "2", "Body": "<p>One approach not given yet in the answers is using the standard library <code>std::enable_if</code> to perform <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"nofollow\">SFINAE</a> on a base class that you inherit to the main class that defines appropriate member functions.</p>\n<p>Example code:</p>\n<pre><code>template&lt;typename T, class Enable = void&gt;\nclass A_base;\n\ntemplate&lt;typename T&gt;\nclass A_base&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;{\n    public:\n        void only_for_ints(){/* integer-based function */}\n};\n\ntemplate&lt;typename T&gt;\nclass A_base&lt;T, typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type&gt;{\n    public:\n        // maybe specialize for non-int\n};\n\ntemplate&lt;typename T&gt;\nclass A: public A_base&lt;T&gt;{\n    protected:\n        std::vector&lt;T&gt; my_vector;\n};\n</code></pre>\n<p>This approach would be better than an empty function because you are being more strict about your API and better than a <code>static_cast</code> because it simply won't make it to the inside of the function (it won't exist) and will give you a nice error message at compile time (GCC shows \"has no member named \u2018only_for_ints\u2019\" on my machine).</p>\n<p>The downside to this method would be compile time and code bloat, but I don't think it's too hefty.</p>\n<p>(don't you dare say that C++11 requirement is a down-side, we're in 2014 god-damnit and the next standard has even be finalized already!)</p>\n<p>Also, I noticed, you will probably have to define <code>my_vector</code> in the base class instead of the final because you probably want to handle that data within the member function.</p>\n<p>A nice way to do that without duplicating a bunch of code is to create a base base class (good god) and inherit that class in the base class.</p>\n<p>Example:</p>\n<pre><code>template&lt;typename T&gt;\nclass base_data{\n    protected:\n        std::vector&lt;T&gt; my_vector;\n};\n\ntemplate&lt;typename T&gt;\nclass A_base&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;: public base_bata&lt;T&gt;{\n    public:\n        void only_for_ints(){/* phew, finally. fiddle around with my_vector! */}\n};\n\n// non-integer A-base\n\ntemplate&lt;typename T&gt;\nclass A: public A_base&lt;T&gt;{\n    protected:\n        // helper functions not available in base\n};\n</code></pre>\n<p>That does leave a horrible looking multiple-inheritance scheme, but it is very workable and makes it easy to define members based on template parameters (for future proofing).</p>\n<p>People often don't like multiple-inheritance or how complicated/messy SFINAE looks, but I couldn't live without it now that I know of it: the speed of static code with the polymorphism of dynamic code!</p>\n", "LastActivityDate": "2014-08-26T01:42:33.980", "CommentCount": "0", "CreationDate": "2014-08-26T01:42:33.980", "ParentId": "25486033", "Score": "1", "OwnerUserId": "2297448"}, "25486308": {"Id": "25486308", "PostTypeId": "2", "Body": "<p>As an alternative solution, which works also in plain C++03 (as opposed to <code>static_assert</code> or <code>enable_if</code> solutions), you may add extra defaulted template argument which will let you have both\nspecialized and unspecialized version of class. Then you can inherit your specialized version from the unspecialized one.</p>\n<p>Here is a sample snippet:</p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate&lt;typename T, bool unspecialized = false&gt;\nclass A\n{\n  protected:\n    std::vector&lt;T&gt; myVector;\n\n  public:\n    void setVec(const std::vector&lt;T&gt;&amp; vec) { myVector = vec; }\n    /*\n    constructors + a bunch of member functions here\n    */\n};\n\ntemplate&lt;&gt;\nclass A&lt;int, false&gt; : public A&lt;int, true&gt;\n{\n  public: \n   int onlyForInt() {\n      return 25;\n   }\n};\n\nint main() {\n  // your code goes here\n  std::vector&lt;int&gt; vec;\n  A&lt;int&gt; a;\n  a.setVec(vec);\n  a.onlyForInt();\n  return 0;\n}\n</code></pre>\n<p>The drawbacks of this solution is the need to add constructor forwarders, if class\nhas non-trivial constructors.</p>\n", "LastEditorUserId": "1381108", "LastActivityDate": "2014-08-26T00:27:30.090", "Score": "6", "CreationDate": "2014-08-25T12:46:54.687", "ParentId": "25486033", "CommentCount": "4", "OwnerUserId": "1076305", "LastEditDate": "2014-08-26T00:27:30.090"}});