post_cb({"37981656": {"ParentId": "37981617", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is <em>possibly</em> undefined (but certainly unwise) behaviour and you can prevent it in much the same way you prevent people writing to random addresses, or prevent inexperienced people from cutting off limbs with a chainsaw. In other words, not at all.</p>\n<p>Caveat Coder.</p>\n<p>The reason I say <em>possibly</em> in the above paragraph is that it's not entirely clear. In language-lawyer terms, refer to <code>C++14 5.7 Additive operators /4</code>:</p>\n<blockquote>\n<p id=\"so_37981617_37981656_0\">For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</p>\n</blockquote>\n<p>and <code>/5</code> when discussing adding an integral value to a pointer:</p>\n<blockquote>\n<p id=\"so_37981617_37981656_1\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>In your case, your pointer is actually pointing \"one past the last element\" so the addition itself doesn't generate undefined behaviour.</p>\n<p>You may think that dereferencing the object would be undefined but, as per a note in <code>3.9.2 Compound types /3</code>, it appears it may be valid:</p>\n<blockquote>\n<p id=\"so_37981617_37981656_2\">For instance, the address one past the end of an array (5.7) would be considered to point to an unrelated object of the array\u2019s element type that might be located at that address.</p>\n</blockquote>\n<p>However, undefined or not, it's still unwise to dereference since you don't actually <em>know</em> that there is a variable of the correct type there. Implementations are free to pad structures as they see fit so there's no guarantee that <code>price</code> will be the same as <code>*(year + 1)</code>.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2016-06-23T05:22:44.593", "Id": "37981656", "Score": "3", "CreationDate": "2016-06-23T03:07:08.770", "LastActivityDate": "2016-06-23T05:22:44.593"}, "bq_ids": {"n4140": {"so_37981617_37981656_0": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_37981617_37981656_1": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_37981617_37981656_2": {"section_id": 7223, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_37981617_37981656_0": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_37981617_37981656_1": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_37981617_37981656_2": {"section_id": 6967, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_37981617_37981656_0": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_37981617_37981656_2": {"section_id": 8732, "quality": 0.5882352941176471, "length": 10}, "so_37981617_37981656_1": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}}}, "37981617": {"CommentCount": "2", "ViewCount": "77", "CreationDate": "2016-06-23T03:02:03.490", "LastActivityDate": "2016-06-23T05:22:44.593", "Title": "Using the address of a public member variable to access a private member", "AcceptedAnswerId": "37981656", "PostTypeId": "1", "Id": "37981617", "Score": "2", "Body": "<p>I created the following simple test program to show that I can use the address of public integer to access the value of a private integer:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass CarType{\n  public:\n    int year;\n    CarType(int price, int year){this -&gt; year = year; this -&gt; price = price;};\n  private: \n    int price;\n};\n\nint main(){\n  //Create new CarType object\n  CarType a = CarType(15000, 1999);\n  //Increment the memory address of public member variable, year by 1 and save the result\n  int* pricePointer = &amp;a.year+1;\n  //De-reference the memory address and output it\n  cout &lt;&lt; \"PRICE: \"&lt;&lt; *pricePointer &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The output shows that I can access the price variable just by knowing the address of year. Is there a way to prevent against this? Is this just an edge case or is this true for all types of objects?</p>\n", "Tags": "<c++><pointers><memory-management>", "OwnerUserId": "2826926", "AnswerCount": "1"}});