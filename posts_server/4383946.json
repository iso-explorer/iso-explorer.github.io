post_cb({"bq_ids": {"n4140": {"so_4383946_4383946_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5364}, "so_4383946_4383946_1": {"length": 12, "quality": 0.8, "section_id": 5360}, "so_4383946_4383946_5": {"length": 15, "quality": 0.9375, "section_id": 5364}, "so_4383946_4383946_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 5364}, "so_4383946_4383946_4": {"length": 12, "quality": 1.0, "section_id": 5360}}, "n3337": {"so_4383946_4383946_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5160}, "so_4383946_4383946_1": {"length": 12, "quality": 0.8, "section_id": 5156}, "so_4383946_4383946_5": {"length": 15, "quality": 0.9375, "section_id": 5160}, "so_4383946_4383946_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 5160}, "so_4383946_4383946_4": {"length": 12, "quality": 1.0, "section_id": 5156}}, "n4659": {"so_4383946_4383946_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 6788}, "so_4383946_4383946_1": {"length": 12, "quality": 0.8, "section_id": 6785}, "so_4383946_4383946_5": {"length": 15, "quality": 0.9375, "section_id": 6788}, "so_4383946_4383946_6": {"length": 21, "quality": 0.9545454545454546, "section_id": 6788}, "so_4383946_4383946_4": {"length": 12, "quality": 1.0, "section_id": 6785}}}, "4385245": {"Id": "4385245", "PostTypeId": "2", "Body": "<p>Windows knows nothing about wchar_t, because wchar_t is a programming concept. Conversely, wchar_t is just storage, and it knows nothing about the semantic value of the data you store in it (that is, it knows nothing about Unicode or ASCII or whatever.)</p>\n<p>If a compiler or SDK that targets Windows defines wchar_t to be 16 bits, then that compiler may be in conflict with the C++0x standard. (I don't know whether there are some get-out clauses that allow wchar_t to be 16 bits.) But in any case the compiler could define wchar_t to be 32 bits (to comply with the standard) and provide runtime functions to convert to/from UTF-16 for when you need to pass your wchar_t* to Windows APIs.</p>\n", "LastActivityDate": "2010-12-08T07:49:11.000", "CommentCount": "0", "CreationDate": "2010-12-08T07:49:11.000", "ParentId": "4383946", "Score": "1", "OwnerUserId": "387490"}, "4384925": {"Id": "4384925", "PostTypeId": "2", "Body": "<p>The standard requires that <code>wchar_t</code> be large enough to hold any character in the supported character set. Based on this, I think your premise is correct -- it is wrong for VC++ to represent the single character <code>\\U000E0005</code> using two <code>wchar_t</code> units.</p>\n<p>Characters outside the BMP are rarely used, and Windows itself internally uses UTF-16 encoding, so it is simply convenient (even if incorrect) for VC++ to behave this way. However, rather than \"banning\" such characters, it is likely that the size of <code>wchar_t</code> will increase in the future while <code>char16_t</code> takes its place in the Windows API.</p>\n<p>The answer you linked to is somewhat misleading as well:</p>\n<blockquote>\n<p id=\"so_4383946_4384925_0\">On Linux, a <code>wchar_t</code> is 4-bytes, while on Windows, it's 2-bytes</p>\n</blockquote>\n<p>The size of <code>wchar_t</code> depends solely on the compiler and has nothing to do with the operating system. It just happens that VC++ uses 2 bytes for <code>wchar_t</code>, but once again, this could very well change in the future.</p>\n", "LastActivityDate": "2010-12-08T06:53:19.143", "CommentCount": "6", "CreationDate": "2010-12-08T06:53:19.143", "ParentId": "4383946", "Score": "3", "OwnerUserId": "381345"}, "4383946": {"ViewCount": "4523", "Body": "<blockquote>\n<p id=\"so_4383946_4383946_0\"><strong>From c++2003 2.13</strong></p>\n<p id=\"so_4383946_4383946_1\">A wide string literal has type \u201c<strong>array of n const wchar_t</strong>\u201d and has static storage duration, where n is the size of the string as defined below</p>\n<p id=\"so_4383946_4383946_2\">The size of a wide string literal is the total number of escape sequences, universal-character-names, and other characters, plus one for the terminating L\u2019\\0\u2019.</p>\n<p id=\"so_4383946_4383946_3\"><strong>From c++0x 2.14.5</strong></p>\n<p id=\"so_4383946_4383946_4\">A wide string literal has type \u201c<strong>array of n const wchar_t</strong>\u201d, where n is the size of the string as defined below</p>\n<p id=\"so_4383946_4383946_5\">The size of a char32_t or wide string literal is the total number of escape sequences, universal-character-names, and other characters, plus one for the terminating U\u2019\\0\u2019 or L\u2019\\0\u2019. </p>\n<p id=\"so_4383946_4383946_6\">The size of a char16_t string literal is the total number of escape sequences, universal-character-names, and other characters, plus one for each character requiring a surrogate pair, plus one for the terminating u\u2019\\0\u2019.</p>\n</blockquote>\n<p>The statement in C++2003 is quite vague. But in C++0x, when counting the length of the string, the wide string literal wchar_t shall be treated as same as char32_t, and different from char16_t.</p>\n<p>There's a post that states clearly how windows implements wchar_t in <a href=\"https://stackoverflow.com/questions/402283?tab=votes%23tab-top\">https://stackoverflow.com/questions/402283?tab=votes%23tab-top</a></p>\n<p>In short, wchar_t in windows is 16bits and encoded using UTF-16. The statement in standard apparently leaves something conflicting in Windows. </p>\n<p>for example,</p>\n<pre><code>wchar_t kk[] = L\"\\U000E0005\";\n</code></pre>\n<p>This exceeds 16bits and for UTF-16 it needs two 16 bits to encode it (a surrogate pair).</p>\n<p>However, from standard, kk is an array of 2 wchar_t  (1 for the universal-name \\U000E005, 1 for \\0).</p>\n<p>But in the internal storage, Windows need 3 16-bit wchar_t objects to store it, 2 wchar_t for the surrogate pair, and 1 wchar_t for the \\0. Therefore, from array's definition, kk is an array of 3 wchar_t.</p>\n<p>It's apparently conflicting to each other.</p>\n<p>I think one simplest solution for Windows is to \"ban\" anything that requires surrogate pair in wchar_t (\"ban\" any unicode outside BMP). </p>\n<p>Is there anything wrong with my understanding? </p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "4384925", "Title": "conflicts: definition of wchar_t string in C++ standard and Windows implementation?", "CreationDate": "2010-12-08T03:39:18.463", "Id": "4383946", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:51:56.120", "LastEditorUserId": "-1", "LastActivityDate": "2010-12-08T07:49:11.000", "Score": "7", "OwnerUserId": "534498", "Tags": "<c++><unicode><c++11><string-literals><wchar-t>", "AnswerCount": "2"}});