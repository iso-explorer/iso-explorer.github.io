post_cb({"15064420": {"ParentId": "15064247", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Short answer: No, this is not allowed or better put it's not overriding but <em>overwriting</em>, i.e. you are not overriding <code>Base::method()</code> but creating a new method with the same name. Most compilers will warn you about that. With your example code, but assuming that <code>Base::method</code> is <em>not</em> pure virtual, consider this:</p>\n<pre><code>void callMethod(Base const&amp; b)\n{\n  auto a1 = b.method();  //what should the type of a1 be? -&gt; it's int. Every time.\n  std::cout &lt;&lt; a1 &lt;&lt; '\\n';\n}\n\nint main()\n{\n  Der1 d1;\n  auto a2 = d1.method(); //a2 is ret1_1 of type ret1\n  callMethod(d1);        //calls Base::method and prints that int, not Der1::method\n}\n</code></pre>\n<p>You are right wrt that return types are not part of the function signature. But when overriding virtual functions, the signature is not all that matters. <strong>\u00a710.3,7</strong> explicitly states:</p>\n<blockquote>\n<p id=\"so_15064247_15064420_0\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or <em>covariant</em> with the\n  classes of the functions. If a function <code>D::f</code> overrides a function\n  <code>B::f</code>, the return types of the functions are covariant if they satisfy\n  the following criteria:</p>\n<p id=\"so_15064247_15064420_1\">\u2014 both are pointers to classes, both are\n  lvalue references to classes, or both are rvalue references to\n  classes</p>\n<p id=\"so_15064247_15064420_2\">\u2014 the class in the return type of <code>B::f</code> is the same class as\n  the class in the return type of <code>D::f</code>, or is an unambiguous and\n  accessible direct or indirect base class of the class in the return\n  type of <code>D::f</code></p>\n<p id=\"so_15064247_15064420_3\">\u2014 both pointers or references have the same\n  cv-qualification and the class type in the return type of <code>D::f</code> has the\n  same cv-qualification as or less cv-qualification than the class type\n  in the return type of <code>B::f</code>.</p>\n</blockquote>\n", "OwnerUserId": "1838266", "LastEditorUserId": "1838266", "LastEditDate": "2013-02-25T10:11:51.850", "Id": "15064420", "Score": "4", "CreationDate": "2013-02-25T10:04:15.070", "LastActivityDate": "2013-02-25T10:11:51.850"}, "15064311": {"ParentId": "15064247", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You can override functions with different return types but only <b>covariant return types</b> are allowed. </p>\n<p>Function Overriding means that either the Base class method or the Derived class method will be called at run-time depending on the actual object pointed by the pointer.<br>\nIt implies that:<br>\ni.e: Every place where the Base class method can be called can be replaced by call to Derived class method without any change to calling code.     </br></br></p>\n<p>In order to achieve this the only possible way is to restrict the return types of the overriding virtual methods to return the same type as the Base class or a type derived from that(co-variant return types) and so the Standard enforces this condition.     </p>\n<p>Without this condition the existing code will break by addition of new functionality(new overriding functions).</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "4531346", "LastEditDate": "2017-08-30T05:41:09.707", "Id": "15064311", "Score": "4", "CreationDate": "2013-02-25T09:58:26.470", "LastActivityDate": "2017-08-30T05:41:09.707"}, "15064402": {"ParentId": "15064247", "CommentCount": "0", "Body": "<p>We should not alter the return type of a function in the base class by overriding it. Alteration of the return type by hiding the base member with another is not recommended, because it results into something weird that can't be used in a polymorphic way.</p>\n", "OwnerUserId": "646210", "PostTypeId": "2", "Id": "15064402", "Score": "1", "CreationDate": "2013-02-25T10:03:11.323", "LastActivityDate": "2013-02-25T10:03:11.323"}, "15064247": {"CommentCount": "1", "AcceptedAnswerId": "15064311", "PostTypeId": "1", "LastEditorUserId": "1838266", "CreationDate": "2013-02-25T09:55:07.930", "LastActivityDate": "2017-08-30T05:41:09.707", "LastEditDate": "2013-02-25T09:58:39.107", "ViewCount": "3785", "FavoriteCount": "2", "Title": "function overriding with different return types", "Id": "15064247", "Score": "5", "Body": "<p>Does the return type influence on function overriding? (As far as I know return typde is not a part of a function/method signature)\nIn a base class I have a function, which doesn't get arguments, returns <code>int</code> and is pure virtual. In each derived class, I define an enum for the return type.The function is overridden in the derived classes, i.e. it has the same signature but different behavior.\nThe question is: Is that legal for overriding and return type is not a part of function overriding?</p>\n<p><em>Code example:</em></p>\n<pre><code>class Base\n{\n  public:\n  typedef int ret;\n  virtual ret method() = 0;\n};\n\nclass Der1\n{\npublic:\n  enum ret1{\n    ret1_0,\n    ret1_1\n  };\n  ret1 method() { return ret1_1;}\n};\n\nclass Der1\n{\npublic:\n  enum ret2{\n    ret2_0,\n    ret2_1\n  };\n  ret1 method() { return ret2_0;}\n};\n</code></pre>\n", "Tags": "<c++><override><return-type>", "OwnerUserId": "466056", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_15064247_15064420_1": {"section_id": 7008, "quality": 1.0, "length": 11}, "so_15064247_15064420_2": {"section_id": 7008, "quality": 1.0, "length": 17}, "so_15064247_15064420_0": {"section_id": 7008, "quality": 0.92, "length": 23}, "so_15064247_15064420_3": {"section_id": 7008, "quality": 1.0, "length": 19}}, "n3337": {"so_15064247_15064420_1": {"section_id": 6754, "quality": 1.0, "length": 11}, "so_15064247_15064420_2": {"section_id": 6754, "quality": 1.0, "length": 17}, "so_15064247_15064420_0": {"section_id": 6754, "quality": 0.92, "length": 23}, "so_15064247_15064420_3": {"section_id": 6754, "quality": 1.0, "length": 19}}, "n4659": {"so_15064247_15064420_1": {"section_id": 8505, "quality": 1.0, "length": 11}, "so_15064247_15064420_2": {"section_id": 8505, "quality": 1.0, "length": 17}, "so_15064247_15064420_0": {"section_id": 8505, "quality": 0.92, "length": 23}, "so_15064247_15064420_3": {"section_id": 8505, "quality": 1.0, "length": 19}}}, "15064367": {"ParentId": "15064247", "CommentCount": "0", "Body": "<p>what you have are not overrides.</p>\n<p>c++ supports covariant return types for raw pointers and raw references.</p>\n<p>but that's all.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "15064367", "Score": "1", "CreationDate": "2013-02-25T10:00:58.267", "LastActivityDate": "2013-02-25T10:00:58.267"}});