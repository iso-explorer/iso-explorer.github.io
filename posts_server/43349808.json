post_cb({"43350082": {"ParentId": "43349808", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Quoting from a <a href=\"https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow noreferrer\">GOTW article</a></p>\n<blockquote>\n<p id=\"so_43349808_43350082_0\">A temporary object lasts only until the end of the full expression in which it appears. However, C++ deliberately specifies that binding a temporary object to a reference to const (or ravlue reference) on the stack lengthens the lifetime of the temporary to the lifetime of the reference itself, and thus avoids what would otherwise be a common dangling-reference error. </p>\n</blockquote>\n<pre><code>string f() { return \"abc\"; }\n\nvoid g() {\nconst string&amp; s = f();\n  cout &lt;&lt; s &lt;&lt; endl;    // can we still use the \"temporary\" object?\n}\n</code></pre>\n<blockquote>\n<p id=\"so_43349808_43350082_1\">In the example above, the temporary returned by f() lives until the closing curly brace. (Note this only applies to stack-based references. It doesn\u2019t work for references that are members of objects.)</p>\n</blockquote>\n<p>For legalese, read <a href=\"https://stackoverflow.com/a/2784304/955273\">this SO answer</a></p>\n<p>The answer applies to <em>both</em> local const references and rvalue references</p>\n", "OwnerUserId": "955273", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:54.457", "Id": "43350082", "Score": "0", "CreationDate": "2017-04-11T15:21:43.813", "LastActivityDate": "2017-04-11T15:21:43.813"}, "bq_ids": {"n4140": {"so_43349808_43350607_1": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_43349808_43350607_3": {"section_id": 382, "quality": 0.9375, "length": 15}, "so_43349808_43350607_2": {"section_id": 382, "quality": 1.0, "length": 13}, "so_43349808_43350607_4": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_43349808_43349808_0": {"section_id": 382, "quality": 0.5263157894736842, "length": 10}, "so_43349808_43350607_5": {"section_id": 382, "quality": 0.75, "length": 12}}, "n3337": {"so_43349808_43350607_1": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_43349808_43350607_3": {"section_id": 373, "quality": 0.9375, "length": 15}, "so_43349808_43350607_2": {"section_id": 373, "quality": 1.0, "length": 13}, "so_43349808_43350607_4": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_43349808_43349808_0": {"section_id": 373, "quality": 0.5263157894736842, "length": 10}, "so_43349808_43350607_5": {"section_id": 373, "quality": 0.75, "length": 12}}, "n4659": {"so_43349808_43350607_1": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_43349808_43350607_3": {"section_id": 397, "quality": 0.9375, "length": 15}, "so_43349808_43350607_2": {"section_id": 397, "quality": 1.0, "length": 13}, "so_43349808_43350607_4": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_43349808_43349808_0": {"section_id": 397, "quality": 0.5263157894736842, "length": 10}, "so_43349808_43350607_5": {"section_id": 397, "quality": 0.6875, "length": 11}}}, "43349808": {"CommentCount": "11", "AcceptedAnswerId": "43350607", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2017-04-11T15:09:49.217", "LastActivityDate": "2017-04-11T17:00:40.010", "LastEditDate": "2017-04-11T17:00:40.010", "ViewCount": "235", "FavoriteCount": "3", "Title": "Extended lifetime of an object returned from function", "Id": "43349808", "Score": "6", "Body": "<p>There are some unclear for me informations about extension of lifetime of an object returned from function and bound to rvalue/const lvalue reference. Information from <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary\" rel=\"nofollow noreferrer\">here</a>.  </p>\n<blockquote>\n<p id=\"so_43349808_43349808_0\">a temporary bound to a return value of a function in a return statement is not extended: it is destroyed immediately at the end of the return expression. Such function always returns a dangling reference.  </p>\n</blockquote>\n<p>If I understand correctly, the quote claims that lifetime of objects returned by return statements is not extendable. But last sentence suggest, that it only applies to functions returning references.<br>\nOn GCC, from the code below I get following ouput:  </br></p>\n<pre><code>struct Test\n{\n  Test() { std::cout &lt;&lt; \"creation\\n\"; }\n  ~Test() { std::cout &lt;&lt; \"destruction\\n\"; }\n};\n\nTest f()\n{\n    return Test{};   \n}\n\nint main()\n{\n    std::cout &lt;&lt; \"before f call\\n\";\n    Test &amp;&amp; t = f();\n    std::cout &lt;&lt; \"after f call\\n\";\n}\n</code></pre>\n<hr>\n<pre><code>before f call\ncreation\nafter f call\ndestruction\n</code></pre>\n<p>So it looks like the lifetime got extended.<br>\nShould the lifetime of temporary object bound to such reference be extended? Also could you provide any more clear source of informations?</br></p>\n</hr>", "Tags": "<c++><reference><language-lawyer><lifetime><temporary>", "OwnerUserId": "5538150", "AnswerCount": "2"}, "43350607": {"ParentId": "43349808", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_43349808_43350607_0\">So it looks like the lifetime got extended.</p>\n</blockquote>\n<p>The code is pretty valid, but note that the object whose lifetime got extended is not the temporary object created inside the function <code>f()</code> by <code>Test{}</code>, it's the returned object by the function <code>f()</code>. That returned object is move-constructed from the temporary object, then gets bound to <code>t</code> and lifetime gets extended. BTW the returned object is returned by value, and it's a temporary too.</p>\n<p>For observation you can add move constructor manually:</p>\n<pre><code>struct Test\n{\n  Test() { std::cout &lt;&lt; \"creation\\n\"; }\n  ~Test() { std::cout &lt;&lt; \"destruction\\n\"; }\n  Test(Test&amp;&amp;) { std::cout &lt;&lt; \"move\\n\"; }\n};\n</code></pre>\n<p>and compile and run with forbidding <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">copy elision</a> mode, the result is:</p>\n<pre><code>before f call\ncreation      // the temporary created inside f\nmove          // return object move-constructed\ndestruction   // the temporary destroyed\nafter f call\ndestruction   // the returned object destroyed\n</code></pre>\n<p><a href=\"http://rextester.com/DCF22988\" rel=\"nofollow noreferrer\">LIVE</a></p>\n<hr>\n<p>Quotes from the standard, <a href=\"http://eel.is/c++draft/class.temporary#6\" rel=\"nofollow noreferrer\">$15.2/6 Temporary objects [class.temporary]</a>:</p>\n<blockquote>\n<p id=\"so_43349808_43350607_1\">The temporary to which the reference is bound or the temporary that is\n  the complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except:</p>\n<p id=\"so_43349808_43350607_2\">(6.1) A temporary object bound to a reference parameter in a function\n  call persists until the completion of the full-expression containing\n  the call.</p>\n<p id=\"so_43349808_43350607_3\">(6.2) The lifetime of a temporary bound to the returned value in a\n  function return statement is not extended; the temporary is destroyed\n  at the end of the full-expression in the return statement.</p>\n<p id=\"so_43349808_43350607_4\">(6.3) A temporary bound to a reference in a new-initializer persists\n  until the completion of the full-expression containing the\n  new-initializer. [\u2009Example:</p>\n<pre><code>struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };\nS a { 1, {2,3} };\nS* p = new S{ 1, {2,3} };   // Creates dangling reference\n</code></pre>\n<p id=\"so_43349808_43350607_5\">\u2009\u2014\u2009end example\u2009] [\u2009Note: This may introduce a dangling reference, and\n  implementations are encouraged to issue a warning in such a case.\n  \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n</hr>", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-04-11T16:58:53.233", "Id": "43350607", "Score": "6", "CreationDate": "2017-04-11T15:44:14.847", "LastActivityDate": "2017-04-11T16:58:53.233"}});