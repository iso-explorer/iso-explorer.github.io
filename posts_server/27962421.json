post_cb({"27962421": {"CommentCount": "1", "AcceptedAnswerId": "27963240", "PostTypeId": "1", "LastEditorUserId": "472610", "CreationDate": "2015-01-15T11:30:34.170", "LastActivityDate": "2015-01-15T12:25:31.640", "LastEditDate": "2015-01-15T12:18:23.517", "ViewCount": "196", "FavoriteCount": "1", "Title": "Does returning a bound local function object cause undefined behaviour?", "Id": "27962421", "Score": "3", "Body": "<p>I am giving an example below. The program compiles and runs fine, but I am wondering whether it is theoretically undefined behaviour according to the C++11 standard; can I return the result of binding a (temporary) local function object?</p>\n<p>Example code (edited for short):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct MyFunctionObject\n{\n    inline void operator() ( const std::string&amp; name )\n        { std::cout&lt;&lt; \"Hello \" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; std::endl; }\n};\n\nstd::function&lt; void () &gt; my_greeter( const std::string&amp; name )\n{\n    MyFunctionObject fun;\n    return std::bind( fun, name );\n}\n\nint main()\n{\n    auto g = my_greeter(\"sheljohn\");\n    g();\n}\n</code></pre>\n<hr>\n<p><strong>EDIT</strong> Original example:</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\n\n\n        /********************     **********     ********************/\n        /********************     **********     ********************/\n\n\n\nnamespace foo {\n\n\n/**\n * Type of the generator returned by the method 'bind' below.\n */\ntemplate &lt;class _dist&gt;\nusing generator_type = std::function&lt; typename _dist::result_type () &gt;;\n\n// ------------------------------------------------------------------------\n\n/**\n * Wrapper for C++11 random library.\n */\ntemplate &lt;\n    class _engine = std::mt19937_64,\n    class _device = std::random_device\n&gt;\nstruct random\n{\n    typedef _engine engine_type;\n    typedef _device device_type;\n    typedef random&lt;_engine,_device&gt; self;\n\n    template &lt;class _dist&gt;\n    static inline generator_type&lt;_dist&gt;\n    bind( _dist&amp; distribution )\n        { return std::bind( distribution, self::engine ); }\n\n    template &lt;class _dist&gt;\n    static inline generator_type&lt;_dist&gt;\n    bind( _dist&amp;&amp; distribution )\n        { return std::bind( distribution, self::engine ); }\n\n    static engine_type engine;\n    static device_type device;\n};\n\n// Initialize static engine\ntemplate &lt;class _engine,class _device&gt;\n_device random&lt;_engine,_device&gt;::device;\n\ntemplate &lt;class _engine,class _device&gt;\n_engine random&lt;_engine,_device&gt;::engine = _engine( device() );\n\n// ------------------------------------------------------------------------\n\n/**\n * Generic binder to standard random distributions.\n *\n * SO QUESTION: does this cause undefined behaviour?\n */\n\ntemplate &lt;class _dist, class... Args&gt;\nconstexpr generator_type&lt;_dist&gt; random_generator( Args&amp;&amp;... args )\n    { return random&lt;&gt;::bind( _dist( std::forward&lt;Args&gt;(args)... ) ); }\n\n\n}; // namespace: foo\n\n\n\n        /********************     **********     ********************/\n        /********************     **********     ********************/\n\n\n\nint main()\n{\n    auto ngen = foo::random_generator&lt; std::normal_distribution&lt;double&gt; &gt;( 0.0, 1.0 );\n\n    for(unsigned i=0; i&lt;10; ++i) \n        std::cout&lt;&lt; ngen() &lt;&lt; \" \" &lt;&lt; std::endl;\n}\n</code></pre>\n</hr>", "Tags": "<c++><c++11><undefined-behavior><function-object>", "OwnerUserId": "472610", "AnswerCount": "2"}, "27963240": {"ParentId": "27962421", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-01-15T12:16:07.290", "Score": "2", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-15T12:25:31.640", "Id": "27963240", "OwnerUserId": "2069064", "Body": "<p>The standard actually has a specific bit about calling <code>bind()</code> with a random number generator, in \u00a726.5:</p>\n<blockquote>\n<p id=\"so_27962421_27963240_0\">[ <em>Note:</em> These entities are specified in such a way as to permit the binding of any uniform random number generator object e as the argument to any random number distribution object d, thus producing a zero-argument function object such as given by\n  bind(d,e). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So what you're doing is explicitly allowed for. </p>\n<p>Also from <code>[func.bind.bind]</code>, the description states that when you call <code>bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args)</code> that (emphasis mine):</p>\n<blockquote>\n<ul>\n<li><code>FD</code> is the type <strong><code>decay_t&lt;F&gt;</code>,</strong></li>\n<li><code>fd</code> is an lvalue of type <code>FD</code> constructed from <strong><code>std::forward&lt;F&gt;(f)</code></strong></li>\n<li><code>Ti</code> is the <em>ith</em> type in the template parameter pack <code>BoundArgs</code></li>\n<li><code>TiD</code> is the type <strong><code>decay_t&lt;Ti&gt;</code></strong></li>\n<li><code>ti</code> is the <em>ith</em> type in the function parameter pack <code>bound_args</code></li>\n<li><code>tid</code> is an lvalue of type <code>TiD</code> constructed from <strong><code>std::forward&lt;Ti&gt;(ti)</code></strong></li>\n<li>..</li>\n</ul>\n<p id=\"so_27962421_27963240_1\"><em>Returns</em>: A forwarding call wrapper <code>g</code>... The effect of <code>g(,u1, u2, ..., uM)</code> shall be <code>INVOKE(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(V2), ... std::forward&lt;VN&gt;(vN), result_of_t&lt;FD cv &amp; (V1, V2, ..., VN)&gt;)</code></p>\n</blockquote>\n<p>The section is a little confusing to me, but basically the functor and the arguments you pass in is forwarded (copied/move) into local version, <code>fd</code> and <code>tid...</code>. <code>bind</code> won't keep a reference to the functor (<code>FD</code> is <strong>not</strong> a reference type!), and the same is true of all of the arguments (the <code>TiD</code> types for the <code>BoundArgs</code> are <strong>not</strong> reference types either). So in your new example, even if <code>fun</code> and the string that <code>name</code> is a reference to both go out of scope, the <code>bind()</code> result is still a valid callable.</p>\n<p>There is no UB here.</p>\n", "LastActivityDate": "2015-01-15T12:25:31.640"}, "bq_ids": {"n4140": {"so_27962421_27963240_1": {"section_id": 4634, "quality": 0.6666666666666666, "length": 8}, "so_27962421_27963240_0": {"section_id": 3483, "quality": 0.8571428571428571, "length": 24}}, "n3337": {"so_27962421_27963240_0": {"section_id": 3348, "quality": 0.8571428571428571, "length": 24}}, "n4659": {"so_27962421_27963240_0": {"section_id": 4246, "quality": 0.8214285714285714, "length": 23}}}, "27962987": {"ParentId": "27962421", "CommentCount": "3", "CreationDate": "2015-01-15T12:02:29.643", "OwnerUserId": "657412", "PostTypeId": "2", "Id": "27962987", "Score": "0", "Body": "<p>You don't have an UB, but you really have more luck than reason.</p>\n<p>There's no undefined behavior here, but only because this here:</p>\n<pre><code>return std::bind( distribution, self::engine );\n</code></pre>\n<p>you pass 'distribution' by value, which means that passed is a copy of it (despite <em>distribution</em> being a mutable reference). As a function cannot be overloaded for both value and reference of the same type at specified position, there must exist various tricks in functions where you'd like to do that - and here it is so: bind() requires <em>std::reference_wrapper</em>-wrapped type to pass a reference. So you'd definitely have an undefined behavior if you did:</p>\n<pre><code>return std::bind( ref(distribution), self::engine );\n</code></pre>\n<p>which is available for you here. And in this case you'd pass a <strong>real reference</strong> to bind, which in this case would be a reference to a local variable passed to outside a function that embraces it.</p>\n", "LastActivityDate": "2015-01-15T12:02:29.643"}});