post_cb({"35128552": {"Id": "35128552", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35128267_35128552_0\">Considering the following code, <strong>is it possible that the threads may see the state of an object differently</strong>, despite they both refer by the same pointer?</p>\n</blockquote>\n<p>Answer: No. </p>\n<p>Explanation: Acquiring a mutex is an acquire operation and releasing it is a release operation.</p>\n<p>When <code>dummy</code> is pushed onto the queue, the construction must take place prior to the push in order to maintain correct sequencing from the point of view of the pushing thread. The subsequent release of the mutex will ensure that a fence is issued to make the contents of the queue (and all other data you altered up until that point) visible to the other threads.  </p>\n<p>Similarly in the consumer thread, the sequencing of the assignment to dummy from the queue will be correctly ordered from the point of view of this thread. The acquisition of the mutex will ensure that memory in the <code>DummyObject</code> is valid.</p>\n<p>supporting quote from \u00a71.10.7:</p>\n<blockquote>\n<p id=\"so_35128267_35128552_1\">A synchronization operation without an associated memory location is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_35128267_35128552_2\">For example, a call that acquires a mutex will perform an acquire operation on the locations comprising the mutex. Correspondingly, a call that releases the same mutex will perform a release operation on those same locations.</p>\n</blockquote>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-02-01T11:13:54.100", "Score": "8", "CreationDate": "2016-02-01T10:46:40.840", "ParentId": "35128267", "CommentCount": "2", "LastEditDate": "2016-02-01T11:13:54.100", "OwnerUserId": "2015579"}, "bq_ids": {"n4140": {"so_35128267_35128552_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5818}, "so_35128267_35128552_1": {"length": 16, "quality": 1.0, "section_id": 5818}}, "n3337": {"so_35128267_35128552_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5589}, "so_35128267_35128552_1": {"length": 16, "quality": 1.0, "section_id": 5589}}, "n4659": {"so_35128267_35128552_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 7279}, "so_35128267_35128552_1": {"length": 16, "quality": 1.0, "section_id": 7279}}}, "35128267": {"ViewCount": "94", "Body": "<p>Considering the following code, is it possible that the threads may see the state of an object differently, despite they both refer by the same pointer?</p>\n<pre><code>using namespace std;\n\nclass ProducerAndConsumer{\n\n  class DummyObject {\n  public:\n    DummyObject() {\n      sprintf(a, \"%d\", rand());\n    }\n  private:\n    char a[1000];\n  };\n\n  mutex queue_mutex_;\n  queue&lt;DummyObject *&gt; queue_;\n  thread *t1, *t2;\n\n  void Produce() {\n    while (true) {\n      Sleep(1);\n      // constructing object without any explicit synchronization\n      DummyObject *dummy = new DummyObject();\n      {\n        lock_guard&lt;mutex&gt; guard(queue_mutex_);\n        if (queue_.size() &gt; 1000) {\n          delete dummy;\n          continue;\n        }\n        queue_.push(dummy);\n      }\n    }\n  }\n\n  void Consume() {\n    while (true) {\n      Sleep(1);\n      DummyObject *dummy;\n      {\n        lock_guard&lt;mutex&gt; guard(queue_mutex_);\n        if (queue_.empty())\n          continue;\n        dummy = queue_.front();\n        queue_.pop();\n      }\n      // Do we have dummy object's visibility issues here?\n      delete dummy;\n    }\n  }\n\n public:\n\n  ProducerAndConsumer() {\n    t1 = new thread(bind(&amp;ProducerAndConsumer::Consume, this));\n    t2 = new thread(bind(&amp;ProducerAndConsumer::Produce, this));\n  }\n\n};\n</code></pre>\n<p>Could you say that this example is thread safe? Do mutexes enforce cache trashing? Do mutexes provide more functionality than memory barriers together with atomics?</p>\n", "AcceptedAnswerId": "35128552", "Title": "Can mutexes ensure thread visibility of objects while not explicitly protecting them?", "CreationDate": "2016-02-01T10:31:32.580", "Id": "35128267", "CommentCount": "2", "LastEditDate": "2016-02-01T11:30:02.310", "PostTypeId": "1", "LastEditorUserId": "5857674", "LastActivityDate": "2016-03-24T21:13:29.313", "Score": "4", "OwnerUserId": "5857674", "Tags": "<c++><multithreading>", "AnswerCount": "1"}});