post_cb({"9025970": {"Id": "9025970", "PostTypeId": "2", "Body": "<p>From C++11 standard, section <em>\u00a7 20.3.2</em></p>\n<pre><code>constexpr pair();\n...\nEffects: Value-initializes first and second.\n</code></pre>\n<p>So it is well-defined that the default initialization of an <code>std::pair&lt;int, int&gt;</code> object will result in both members being set to 0.</p>\n", "LastActivityDate": "2012-01-26T21:55:31.197", "CommentCount": "0", "CreationDate": "2012-01-26T21:55:31.197", "ParentId": "9025792", "Score": "4", "OwnerUserId": "241631"}, "9025792": {"ViewCount": "6516", "Body": "<p>After writing:</p>\n<pre><code>std::pair&lt;int, int&gt; x;\n</code></pre>\n<p>Am I guaranteed that x.first and x.second are both zero?  Or could they have any value?  </p>\n<p>The reason why I care is because I'm trying to determine whether a map whose values are pointers is guaranteed to return NULL if I access an element that's not in the map.  I.e., if I do:</p>\n<pre><code>std::map&lt;int, void*&gt; my_map;\nstd::cout &lt;&lt; int(my_map[5]) &lt;&lt; std::endl;\n</code></pre>\n<p>then am I guaranteed to get zero (NULL)?  Or is the behavior undefined?</p>\n", "AcceptedAnswerId": "9025981", "Title": "Does the default constructor of std::pair<> set basic types (int, etc) to zero?", "CreationDate": "2012-01-26T21:41:11.493", "Id": "9025792", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-01-26T22:03:18.107", "Score": "29", "OwnerUserId": "222329", "Tags": "<c++>", "AnswerCount": "4"}, "9026054": {"Id": "9026054", "PostTypeId": "2", "Body": "<p>Yes, they are zero-initialized. A citation of Bjarne Stroustrup's \"The C++ Programming Language\" (from German 3rd edn, Ch. 17.4.1.7):</p>\n<blockquote>\n<p id=\"so_9025792_9026054_0\">The result of <code>m[k]</code> is equivalent to the result of <code>*(m.insert(make_pair(k,V())).first).second</code>, where <code>V()</code> is the default value of the value type. Who is understanding that equivalence, also understands associative containers.</p>\n</blockquote>\n<p>For standard citations what default-initialized means look at the others answers. </p>\n", "LastActivityDate": "2012-01-26T22:02:42.277", "CommentCount": "3", "CreationDate": "2012-01-26T22:02:42.277", "ParentId": "9025792", "Score": "4", "OwnerUserId": "831725"}, "9025903": {"Id": "9025903", "PostTypeId": "2", "Body": "<p>Yes, pair will call the default constructors. </p>\n", "LastActivityDate": "2012-01-26T21:50:02.263", "CommentCount": "0", "CreationDate": "2012-01-26T21:50:02.263", "ParentId": "9025792", "Score": "2", "OwnerUserId": "1159604"}, "bq_ids": {"n4140": {"so_9025792_9025981_3": {"length": 5, "quality": 1.0, "section_id": 3285}, "so_9025792_9025981_2": {"length": 4, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_9025792_9025981_3": {"length": 5, "quality": 1.0, "section_id": 3155}, "so_9025792_9025981_2": {"length": 4, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_9025792_9025981_3": {"length": 4, "quality": 0.8, "section_id": 653}}}, "9025981": {"Id": "9025981", "PostTypeId": "2", "Body": "<p>Yes, that guarantee holds true. Quoting the C++11 standard, \u00a720.3.2/2-3:</p>\n<blockquote>\n<p id=\"so_9025792_9025981_0\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<code>constexpr pair();</code></p>\n<p id=\"so_9025792_9025981_1\">2 <em>Requires:</em> <code>is_default_constructible&lt;first_type&gt;::value</code> is <code>true</code> and <code>is_default_constructible&lt;second_type&gt;::value</code> is <code>true</code>.<br>\n  3 <em>Effects:</em> Value-initializes <code>first</code> and <code>second</code>.</br></p>\n</blockquote>\n<p>And \u00a78.5/7:</p>\n<blockquote>\n<p id=\"so_9025792_9025981_2\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type with a user-provided constructor, then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);  </li>\n<li>if <code>T</code> is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if <code>T</code>'s implicitly-declared default constructor is non-trivial, that constructor is called.  </li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;  </li>\n<li><strong>otherwise, the object is zero-initialized</strong>.</li>\n</ul>\n</blockquote>\n<p>And lastly, \u00a78.5/5:</p>\n<blockquote>\n<p id=\"so_9025792_9025981_3\">To <em>zero-initialize</em> an object or reference of type <code>T</code> means:</p>\n<ul>\n<li><strong>if <code>T</code> is a scalar type, the object is set to the value <code>0</code> (zero), taken as an integral constant expression, converted to <code>T</code></strong>;  </li>\n<li>if <code>T</code> is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class subobject is zero-initialized and padding is initialized to zero bits;  </li>\n<li>if <code>T</code> is a (possibly cv-qualified) union type, the object\u2019s first non-static named data member is zero-initialized and padding is initialized to zero bits;  </li>\n<li>if <code>T</code> is an array type, each element is zero-initialized;  </li>\n<li>if <code>T</code> is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "636019", "LastActivityDate": "2012-01-26T22:03:18.107", "Score": "24", "CreationDate": "2012-01-26T21:56:48.360", "ParentId": "9025792", "CommentCount": "2", "OwnerUserId": "636019", "LastEditDate": "2012-01-26T22:03:18.107"}});