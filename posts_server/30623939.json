post_cb({"30624710": {"ParentId": "30623939", "CommentCount": "1", "CreationDate": "2015-06-03T15:39:33.183", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "30624710", "Score": "2", "Body": "<p>In your example <code>foo</code> names a set of overloaded functions, and template argument deduction is unable to select one overload over another because they're both matches of equal rank.</p>\n<p>Your SFINAE constraint check doesn't kick in until after <code>F</code> has been deduced, so it's of no help in dropping <code>float foo(float)</code> from the overload resolution set. </p>\n<p>Say you renamed the function returning <code>float</code> to <code>foof</code>, then your example would compile. But if you tried calling <code>proxy</code> with <code>foof</code> as the function argument, the code would again fail to compile, this time because of the <code>enable_if</code> constraint.</p>\n<p>To get your example to compile in its current state you must disambiguate which <code>foo</code> you are passing to <code>proxy</code></p>\n<pre><code>proxy(static_cast&lt;int(*)(int)&gt;(foo), 5);\n</code></pre>\n", "LastActivityDate": "2015-06-03T15:39:33.183"}, "30623939": {"CommentCount": "1", "AcceptedAnswerId": "30624239", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2015-06-03T15:06:03.627", "LastActivityDate": "2015-06-03T22:47:12.510", "LastEditDate": "2015-06-03T20:16:00.490", "ViewCount": "734", "FavoriteCount": "2", "Title": "Cannot deduce template argument that is a function", "Id": "30623939", "Score": "6", "Body": "<p>Why cannot <code>F</code> be deduced for <code>proxy()</code>?</p>\n<p>It should be possible because I am restricting it - only for functions that return an <code>int</code>.</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\n\nint foo(int bar) {\n    cout &lt;&lt; \"int\" &lt;&lt; endl;\n    return 2;\n}\n\nfloat foo(float bar) {\n    cout &lt;&lt; \"float\" &lt;&lt; endl;\n    return 1;\n}\n\ntemplate &lt;typename F, typename... Args&gt;\ntypename enable_if&lt;\n    is_same&lt;\n        typename result_of&lt;F(Args...)&gt;::type,\n        int\n        &gt;::value,\n    typename result_of&lt;F(Args...)&gt;::type\n    &gt;::type\nproxy(F func, Args&amp;&amp;... args) {\n    return func(forward&lt;Args&gt;(args)...);\n}\n\nint main() {\n    proxy(foo, 5);\n}\n</code></pre>\n<p>Here is the error:</p>\n<pre><code>b.cpp:29:17: error: no matching function for call to 'proxy(&lt;unresolved overloaded function type&gt;, int)'\nb.cpp:24:1: note:   template argument deduction/substitution failed:\nb.cpp:29:17: note:   couldn't deduce template parameter 'F'\n</code></pre>\n", "Tags": "<c++><templates><c++11><overloading><typetraits>", "OwnerUserId": "3162383", "AnswerCount": "2"}, "30624239": {"ParentId": "30623939", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2015-06-03T15:19:28.180", "Score": "4", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:06.340", "Id": "30624239", "OwnerUserId": "3093378", "Body": "<p>The problem is this:</p>\n<pre><code>proxy(foo, 5);\n</code></pre>\n<p>The compiler tries to deduce the type of <code>foo</code>, but there are 2 overloads. Of course, it can deduce <code>Args...</code> from <code>5</code>, but the type of <code>foo</code> is still non-deducible, since the compiler doesn't know which overload to pick when doing the type deduction. </p>\n<p>Note that the compiler needs to know the type of <code>F</code> in the signature of the function, i.e. here, so SFINAE do its magic:</p>\n<pre><code>is_same&lt;\n    typename result_of&lt;F(Args...)&gt;::type,\n    int\n&gt;::value,\n</code></pre>\n<p>There is absolutely no way for it to correctly deduce the type of <code>F</code> from the <code>proxy(foo, 5)</code> call, so SFINAE cannot kick in. As a side note, remark that C++ cannot overload based on the return type only. So you won't be able to differentiate two functions with the same name based on the return type alone. You'll need somehow to force a parameter matching which will SFINAE out the non-candidate overloads.</p>\n<p>Somehow related: <a href=\"https://stackoverflow.com/q/30316244/3093378\">Deducing the return type of a standalone function</a></p>\n<p>And a relevant quote from the standard, emphasize mine (thanks to @T.C. for pointing it out):</p>\n<p><strong>14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]/(6.2)</strong></p>\n<blockquote>\n<p id=\"so_30623939_30624239_0\">(6) When P is a function type, pointer to function type, or pointer to member function type:</p>\n<ul>\n<li><p id=\"so_30623939_30624239_1\">(6.1) If the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.</p></li>\n<li><p id=\"so_30623939_30624239_2\"><strong>(6.2) If the argument is an overload set</strong> (not containing function\n  templates), trial argument deduction is attempted using each of the\n  members of the set. If deduction succeeds for only one of the overload\n  set members, that member is used as the argument value for the\n  deduction. <strong>If deduction succeeds for more than one member of the\n  overload set the parameter is treated as a non-deduced context</strong>.</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2015-06-03T22:47:12.510"}, "bq_ids": {"n4140": {"so_30623939_30624239_2": {"section_id": 307, "quality": 1.0, "length": 36}, "so_30623939_30624239_0": {"section_id": 307, "quality": 1.0, "length": 10}, "so_30623939_30624239_1": {"section_id": 307, "quality": 1.0, "length": 12}}, "n3337": {"so_30623939_30624239_2": {"section_id": 298, "quality": 1.0, "length": 36}, "so_30623939_30624239_0": {"section_id": 298, "quality": 1.0, "length": 10}, "so_30623939_30624239_1": {"section_id": 298, "quality": 1.0, "length": 12}}, "n4659": {"so_30623939_30624239_2": {"section_id": 314, "quality": 1.0, "length": 36}, "so_30623939_30624239_0": {"section_id": 314, "quality": 0.9, "length": 9}, "so_30623939_30624239_1": {"section_id": 314, "quality": 1.0, "length": 12}}}});