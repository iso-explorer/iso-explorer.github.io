post_cb({"bq_ids": {"n4140": {"so_34381236_34381236_0": {"length": 30, "quality": 0.8333333333333334, "section_id": 6186}, "so_34381236_34381236_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6185}, "so_34381236_34381236_1": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_34381236_34381236_0": {"length": 20, "quality": 0.5555555555555556, "section_id": 5947}}, "n4659": {"so_34381236_34381236_0": {"length": 26, "quality": 0.7222222222222222, "section_id": 7688}, "so_34381236_34381236_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7687}, "so_34381236_34381236_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}}}, "34381309": {"Id": "34381309", "PostTypeId": "2", "Body": "<p>The following non-standard code</p>\n<pre><code>int x = std::rand();\nint r[x] = { 1,2,3 };\n</code></pre>\n<p>compiles under g++, not because <code>g++</code> mistakenly treats <code>std::rand()</code> as a constant expression, but because it implements VLAs by default. Use <code>-pedantic</code> or <code>-Wvla</code> to warn about them, <code>-Werror=vla</code> to turn these warnings into errors.</p>\n", "LastEditorUserId": "775806", "LastActivityDate": "2015-12-20T13:14:37.927", "Score": "2", "CreationDate": "2015-12-20T13:09:03.140", "ParentId": "34381236", "CommentCount": "9", "OwnerUserId": "775806", "LastEditDate": "2015-12-20T13:14:37.927"}, "34381236": {"ViewCount": "209", "Body": "<p>But it compiles in gcc 4.9.0. See <a href=\"https://goo.gl/50WU30\" rel=\"nofollow\">live example</a>:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A {\n    constexpr A(): i(5) {}\n    int&amp;&amp; f() { return std::move(i); }\n    int i;\n} a;\n\nA&amp;&amp; f(A&amp; a) { return std::move(a); } \n\nint main() {\n    A a;\n    int b[a.f()]{ 0, 1, 2, 3, 4 };\n    std::cout &lt;&lt; b[4] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>From \u00a75.19/3 we have:</p>\n<blockquote>\n<p id=\"so_34381236_34381236_0\">An integral constant expression is an expression of integral or\n  unscoped enumeration type, implicitly converted to a prvalue, <strong>where\n  the converted expression is a core constant expression</strong>. [ Note: Such\n  expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field\n  lengths (9.6), as enumerator initializers if the underlying type is\n  not fixed (7.2), and as alignments (7.6.2). \u2014end note]</p>\n</blockquote>\n<p>The expression <code>a.f()</code>is an expression of integral type. It seems to me (although I need some clarification on this point) that this expression is also convertible to a prvalue, because it is an xvalue. But I think the real problem here is that the expression <code>a.f()</code> is <strong>not</strong> a core constant expression, as it satisfies bullet point (2.1) in \u00a75.19/2.</p>\n<p>\u00a75.19/2:</p>\n<blockquote>\n<p id=\"so_34381236_34381236_1\">A conditional-expression <code>e</code> is a core constant expression unless the\n  evaluation of <code>e</code>, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:  </p>\n<p id=\"so_34381236_34381236_2\">(2.1) \u2014 <code>this</code> (5.1.1), except in a <code>constexpr</code> function or a\n  constexpr constructor that is being evaluated as part of <code>e</code>;</p>\n</blockquote>\n", "AcceptedAnswerId": "34381287", "Title": "As far as I can tell, this code should not compile, according to \u00a75.19/3 and \u00a75.19/2 in C++14", "CreationDate": "2015-12-20T13:01:19.367", "Id": "34381236", "CommentCount": "5", "LastEditDate": "2015-12-20T13:57:29.577", "PostTypeId": "1", "LastEditorUserId": "411165", "LastActivityDate": "2015-12-20T13:57:29.577", "Score": "7", "OwnerUserId": "411165", "Tags": "<c++><language-lawyer><c++14><constexpr>", "AnswerCount": "2"}, "34381287": {"Id": "34381287", "PostTypeId": "2", "Body": "<p>You're correct, <code>a.f()</code> is not a constant expression. And variable length arrays are not allowed by the c++ standard. The GNU compiler, however, supports them as a <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" rel=\"nofollow\">language extension</a>. You can ask the compiler to give you a warning when you use non-standard extensions with the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\" rel=\"nofollow\"><code>-pedantic</code> option</a>, or an error with <code>-pedantic-errors</code>.</p>\n<p>Edit: Apparently, GCC 4.9 <a href=\"https://gcc.gnu.org/gcc-4.9/changes.html#cxx\" rel=\"nofollow\">added</a> the official support for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639.html\" rel=\"nofollow\">N3639</a>, the proposal to add variable length arrays to the C++14 standard. In the end, the proposal was not included in the standard, but GCC 4.9 was released before C++14, so that change was not reflected. So, VLA's are supported by GCC 4.9 on purpose in C++14 mode and the above options don't disable them. Note that the C++14 mode is still experimental (even in GCC 5).</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2015-12-20T13:43:51.163", "Score": "7", "CreationDate": "2015-12-20T13:07:30.483", "ParentId": "34381236", "CommentCount": "11", "OwnerUserId": "2079303", "LastEditDate": "2015-12-20T13:43:51.163"}});