post_cb({"34381287": {"ParentId": "34381236", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>You're correct, <code>a.f()</code> is not a constant expression. And variable length arrays are not allowed by the c++ standard. The GNU compiler, however, supports them as a <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" rel=\"nofollow\">language extension</a>. You can ask the compiler to give you a warning when you use non-standard extensions with the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\" rel=\"nofollow\"><code>-pedantic</code> option</a>, or an error with <code>-pedantic-errors</code>.</p>\n<p>Edit: Apparently, GCC 4.9 <a href=\"https://gcc.gnu.org/gcc-4.9/changes.html#cxx\" rel=\"nofollow\">added</a> the official support for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639.html\" rel=\"nofollow\">N3639</a>, the proposal to add variable length arrays to the C++14 standard. In the end, the proposal was not included in the standard, but GCC 4.9 was released before C++14, so that change was not reflected. So, VLA's are supported by GCC 4.9 on purpose in C++14 mode and the above options don't disable them. Note that the C++14 mode is still experimental (even in GCC 5).</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2015-12-20T13:43:51.163", "Id": "34381287", "Score": "7", "CreationDate": "2015-12-20T13:07:30.483", "LastActivityDate": "2015-12-20T13:43:51.163"}, "bq_ids": {"n4140": {"so_34381236_34381236_2": {"section_id": 6185, "quality": 0.8888888888888888, "length": 8}, "so_34381236_34381236_0": {"section_id": 6186, "quality": 0.8055555555555556, "length": 29}, "so_34381236_34381236_1": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_34381236_34381236_0": {"section_id": 5947, "quality": 0.5277777777777778, "length": 19}}, "n4659": {"so_34381236_34381236_2": {"section_id": 7687, "quality": 0.8888888888888888, "length": 8}, "so_34381236_34381236_0": {"section_id": 7688, "quality": 0.7222222222222222, "length": 26}, "so_34381236_34381236_1": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}}}, "34381236": {"CommentCount": "5", "ViewCount": "209", "PostTypeId": "1", "LastEditorUserId": "411165", "CreationDate": "2015-12-20T13:01:19.367", "LastActivityDate": "2015-12-20T13:57:29.577", "Title": "As far as I can tell, this code should not compile, according to \u00a75.19/3 and \u00a75.19/2 in C++14", "AcceptedAnswerId": "34381287", "LastEditDate": "2015-12-20T13:57:29.577", "Id": "34381236", "Score": "7", "Body": "<p>But it compiles in gcc 4.9.0. See <a href=\"https://goo.gl/50WU30\" rel=\"nofollow\">live example</a>:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A {\n    constexpr A(): i(5) {}\n    int&amp;&amp; f() { return std::move(i); }\n    int i;\n} a;\n\nA&amp;&amp; f(A&amp; a) { return std::move(a); } \n\nint main() {\n    A a;\n    int b[a.f()]{ 0, 1, 2, 3, 4 };\n    std::cout &lt;&lt; b[4] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>From \u00a75.19/3 we have:</p>\n<blockquote>\n<p id=\"so_34381236_34381236_0\">An integral constant expression is an expression of integral or\n  unscoped enumeration type, implicitly converted to a prvalue, <strong>where\n  the converted expression is a core constant expression</strong>. [ Note: Such\n  expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field\n  lengths (9.6), as enumerator initializers if the underlying type is\n  not fixed (7.2), and as alignments (7.6.2). \u2014end note]</p>\n</blockquote>\n<p>The expression <code>a.f()</code>is an expression of integral type. It seems to me (although I need some clarification on this point) that this expression is also convertible to a prvalue, because it is an xvalue. But I think the real problem here is that the expression <code>a.f()</code> is <strong>not</strong> a core constant expression, as it satisfies bullet point (2.1) in \u00a75.19/2.</p>\n<p>\u00a75.19/2:</p>\n<blockquote>\n<p id=\"so_34381236_34381236_1\">A conditional-expression <code>e</code> is a core constant expression unless the\n  evaluation of <code>e</code>, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:  </p>\n<p id=\"so_34381236_34381236_2\">(2.1) \u2014 <code>this</code> (5.1.1), except in a <code>constexpr</code> function or a\n  constexpr constructor that is being evaluated as part of <code>e</code>;</p>\n</blockquote>\n", "Tags": "<c++><language-lawyer><c++14><constexpr>", "OwnerUserId": "411165", "AnswerCount": "2"}, "34381309": {"ParentId": "34381236", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The following non-standard code</p>\n<pre><code>int x = std::rand();\nint r[x] = { 1,2,3 };\n</code></pre>\n<p>compiles under g++, not because <code>g++</code> mistakenly treats <code>std::rand()</code> as a constant expression, but because it implements VLAs by default. Use <code>-pedantic</code> or <code>-Wvla</code> to warn about them, <code>-Werror=vla</code> to turn these warnings into errors.</p>\n", "OwnerUserId": "775806", "LastEditorUserId": "775806", "LastEditDate": "2015-12-20T13:14:37.927", "Id": "34381309", "Score": "2", "CreationDate": "2015-12-20T13:09:03.140", "LastActivityDate": "2015-12-20T13:14:37.927"}});