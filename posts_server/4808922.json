post_cb({"4809101": {"ParentId": "4808922", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It's because of \u00a7 8.5.3 5 of C++03:</p>\n<blockquote id=\"so_4808922_4809101_0\">\nA reference to type \u201c<i>cv1</i> T1\u201d is initialized by an expression of type \u201c<i>cv2</i> T2\u201d as follows:\n<ul>\n<li>If the initializer expression<ul>\n<li>is an lvalue (but is not a bit-field), and \u201c<i>cv1</i> T1\u201d is reference-compatible with \u201c<i>cv2</i> T2,\u201d or</li>\n<li>has a class type (i.e., T2 is a class type) and can be implicitly converted to an lvalue of type \u201c<i>cv3</i> T3,\u201d where \u201c<i>cv1</i> T1\u201d is reference-compatible with \u201c<i>cv3</i> T3\u201d 92) (this conversion is selected by enumerating the applicable conversion functions (13.3.1.6) and choosing the best one through over- load resolution (13.3)),</li>\n</ul>\n  then the reference is bound directly to the initializer expression lvalue in the first case, and the reference is bound to the lvalue result of the conversion in the second case. In these cases the reference is said to <em>bind directly</em> to the initializer expression. [<em>Note:</em> the usual lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are not needed, and therefore are suppressed, when such direct bindings to lvalues are done. ]\n  <li>Otherwise, the reference shall be to a non-volatile const type (i.e., <i>cv1</i> shall be const).\n    <ul>\n<li>If the initializer expression is an rvalue, with T2 a class type, and \u201c<i>cv1</i> T1\u201d is reference-compatible with \u201c<i>cv2</i> T2,\u201d the reference is bound in one of the following ways (the choice is implementation-defined.\n        <ul>\n<li>The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</li>\n<li>A temporary of type \u201c<i>cv1</i> T2\u201d [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</li>\n</ul>\n</li>\n<li>Otherwise, a temporary of type \u201c<i>cv1</i> T1\u201d is created and initialized from the initializer expression using the rules for a non-reference copy initialization (8.5). The reference is then bound to the temporary. If T1 is reference-related to T2, <i>cv1</i> must be the same cv-qualification as, or greater cv- qualification than, <i>cv2</i>; otherwise, the program is ill-formed.\n      </li>\n</ul>\n</li>\n</li></ul>\n</blockquote>\n<p>Above, \"<i>cv</i>*\" refers to the modifiers \"const\" and \"volatile\", and \"T*\" refer to type names. For example, <code>const int</code> (<i>cv</i> = \"const\", T = \"int\"), <code>const volatile std::string</code> (<i>cv</i> = \"const volatile\", T = \"std::string\"), <code>char*</code> (<i>cv</i> = \"\", T = \"char*\").</p>\n<p>In short, <a href=\"http://accu.org/index.php/journals/227\" rel=\"nofollow\">rvalues</a> are allowed to bind only to const references.</p>\n<h1>Update</h1>\n<p>If your <code>square</code> now returns void (code or it didn't happen), then the new error is because there is no <code>operator&lt;&lt;(std::out&amp;, void)</code>.</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2011-01-26T19:53:27.100", "Id": "4809101", "Score": "2", "CreationDate": "2011-01-26T19:34:40.987", "LastActivityDate": "2011-01-26T19:53:27.100"}, "4808947": {"ParentId": "4808922", "CommentCount": "0", "Body": "<p>Compiler creates a temporary object for constant <code>4</code> which can not be passed to a function as a non-const reference.  Create a <code>int</code> object in <code>main</code> and pass it to the function or take the function parameter by const-reference or by copy.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "4808947", "Score": "1", "CreationDate": "2011-01-26T19:22:53.763", "LastActivityDate": "2011-01-26T19:22:53.763"}, "4808982": {"ParentId": "4808922", "CommentCount": "0", "Body": "<p>A reference aliases another variable. \"4\" is not a variable, and therefore your reference has nothing to alias. The compiler therefore complains.</p>\n", "OwnerUserId": "8123", "PostTypeId": "2", "Id": "4808982", "Score": "0", "CreationDate": "2011-01-26T19:25:17.050", "LastActivityDate": "2011-01-26T19:25:17.050"}, "4808922": {"CommentCount": "10", "ViewCount": "921", "PostTypeId": "1", "LastEditorUserId": "588855", "CreationDate": "2011-01-26T19:20:39.893", "LastActivityDate": "2011-01-26T20:02:49.290", "Title": "C++ pass-by-reference", "AcceptedAnswerId": "4808937", "LastEditDate": "2011-01-26T19:30:48.413", "Id": "4808922", "Score": "0", "Body": "<p>I'm trying C++ pass-by-reference using this simple code:</p>\n<pre><code>#include &lt;iostream&gt;\nint square(int &amp;x)\n{\nreturn x*x;\n}\nint main()\n{\nstd::cout&lt;&lt;\"Square of 4 is: \"&lt;&lt;square(4)&lt;&lt;std::endl;\nreturn 0;\n}\n</code></pre>\n<p>But, when I try to run it, I get the following:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Sl54P.png\"/></p>\n<p><strong>UPDATE</strong></p>\n<p>I get the following error after modifying the code based on @Pablo Santa Cruz's answer (I just screen captured part of the error):</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Swe9Q.png\"/></p>\n<p>Why is that?</p>\n<p>Thanks.</p>\n", "Tags": "<c++><pass-by-reference>", "OwnerUserId": "588855", "AnswerCount": "8"}, "4809030": {"ParentId": "4808922", "CommentCount": "0", "Body": "<p>The declaration</p>\n<pre><code>int square(int&amp; x);\n</code></pre>\n<p>says that the function <code>square</code> may change its argument (although it doesn't really).  So to call <code>square(4)</code> is ridiculous: the program needs to be ready to change the number 4.</p>\n<p>As people have noted, you can either change the function to specify that it won't change its argument:</p>\n<pre><code>int square(const int&amp; x); // pass reference to const type\n// OR\nint square(int x);        // pass by value\n</code></pre>\n<p>Or you can call your original <code>square</code> using a value that can be modified.</p>\n<pre><code>int square(int&amp; x);\n// ...\nint num = 4;\nsquare(num);\n// now (as far as the compiler knows) num might no longer be 4!\n</code></pre>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "4809030", "Score": "1", "CreationDate": "2011-01-26T19:28:08.390", "LastActivityDate": "2011-01-26T19:28:08.390"}, "4808937": {"ParentId": "4808922", "CommentCount": "2", "Body": "<p>You can't pass a constant (<code>4</code>) if you are expecting a reference.</p>\n<p>You <strong>must</strong> pass a variable:</p>\n<pre><code>int n = 4;\nsquare(n);\n</code></pre>\n<p>Having said that, you probably want something like this:</p>\n<pre><code>void square(int &amp;x)\n{\n   x = x*x;\n}\n</code></pre>\n<p>Not a function returning an int.</p>\n", "OwnerUserId": "67606", "PostTypeId": "2", "Id": "4808937", "Score": "5", "CreationDate": "2011-01-26T19:21:52.867", "LastActivityDate": "2011-01-26T19:21:52.867"}, "4808944": {"ParentId": "4808922", "CommentCount": "2", "Body": "<p>You cannot pass temporaries to non-constant references.</p>\n<p>Make <code>square</code> accept a <code>const int &amp;</code>:</p>\n<pre><code>int square(const int &amp;x)\n{\n    return x*x;\n}\n</code></pre>\n", "OwnerUserId": "300805", "PostTypeId": "2", "Id": "4808944", "Score": "10", "CreationDate": "2011-01-26T19:22:33.937", "LastActivityDate": "2011-01-26T19:22:33.937"}, "4809408": {"ParentId": "4808922", "CommentCount": "0", "Body": "<p>What you want is this:</p>\n<pre><code>#include &lt;iostream&gt;\nint square(int x)\n{\n    return(x * x);\n}\nint main()\n{\n    std::cout &lt;&lt; \"Square of 4 is: \"&lt;&lt; square(4) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Did you notice how I got rid of the <code>&amp;</code> in <code>int square(int &amp;x)</code>? The <code>&amp;</code> means pass-by-reference. It takes a variable. The <code>4</code> in <code>square(4)</code> is a constant.</p>\n<p>Using pass-by-reference, you can change the value of x:</p>\n<pre><code>void square2(int &amp;x)\n{\n    x = x * x;\n    return;\n}\n</code></pre>\n<p>Now:</p>\n<pre><code>int x = 5;\nsquare2(x);\n// x == 25\n</code></pre>\n<p>Although, I don't think you want this. (Do you??) The first method is a lot better.</p>\n", "OwnerUserId": "365102", "PostTypeId": "2", "Id": "4809408", "Score": "0", "CreationDate": "2011-01-26T20:02:49.290", "LastActivityDate": "2011-01-26T20:02:49.290"}, "4808954": {"ParentId": "4808922", "CommentCount": "0", "Body": "<p>A reference must be an l-value-- basically, something you can see on the left side of an assignment statement.</p>\n<p>So basically, you need to assign to a variable in <code>main</code> first. Then you can pass it into <code>square</code>.</p>\n", "OwnerUserId": "129655", "PostTypeId": "2", "Id": "4808954", "Score": "0", "CreationDate": "2011-01-26T19:23:20.620", "LastActivityDate": "2011-01-26T19:23:20.620"}, "bq_ids": {"n4140": {"so_4808922_4809101_0": {"section_id": 3321, "quality": 0.5393939393939394, "length": 89}}, "n3337": {"so_4808922_4809101_0": {"section_id": 3191, "quality": 0.5757575757575758, "length": 95}}, "n4659": {"so_4808922_4809101_0": {"section_id": 4087, "quality": 0.5151515151515151, "length": 85}}}});