post_cb({"bq_ids": {"n4140": {"so_26474272_26474344_0": {"length": 21, "quality": 0.875, "section_id": 6148}}, "n3337": {"so_26474272_26474344_0": {"length": 21, "quality": 0.875, "section_id": 5911}}, "n4659": {"so_26474272_26474344_0": {"length": 21, "quality": 0.875, "section_id": 7644}}}, "26474351": {"Id": "26474351", "PostTypeId": "2", "Body": "<p>This is legal, insofaras it doesn't cause undefined behaviour.</p>\n<p>The behaviour of right-shift of negative values is <em>implementation-defined</em>.  The C and C++ standards do not guarantee it to be either arithmetic or logical; although so far as I know there has never been a CPU that didn't pick one or the other. </p>\n", "LastActivityDate": "2014-10-20T20:28:36.067", "Score": "3", "CreationDate": "2014-10-20T20:28:36.067", "ParentId": "26474272", "CommentCount": "7", "OwnerUserId": "1505939"}, "26474272": {"ViewCount": "193", "Body": "<p>Is it legal to do the following in C11, C++11 and C++14?</p>\n<pre><code>static_assert(((-4) &gt;&gt; 1) == -2, \"my code assumes sign-extending right shift\");\n</code></pre>\n<p>or the C equivalent:</p>\n<pre><code>_Static_assert(((-4) &gt;&gt; 1) == -2, \"my code assumes sign-extending right shift\");\n</code></pre>\n<p>I don't know the rules for constant-expressions regarding whether you can use implementation-defined operations like the above.</p>\n<p>I'm aware that the opposite, signed shift left of negative numbers, is undefined regardless of machine type.</p>\n", "Title": "Is it legal to static_assert that signed shift right has two's-complement behavior?", "CreationDate": "2014-10-20T20:24:27.160", "LastActivityDate": "2014-10-20T20:37:04.250", "CommentCount": "6", "PostTypeId": "1", "Id": "26474272", "Score": "3", "OwnerUserId": "2958774", "Tags": "<c++><c><c++11><language-lawyer><c11>", "AnswerCount": "2"}, "26474344": {"Id": "26474344", "PostTypeId": "2", "Body": "<p>Yes. The C++11 standard says in [expr.shift]/3:</p>\n<blockquote>\n<p id=\"so_26474272_26474344_0\">The value of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. If\n  <code>E1</code> has an unsigned type or if <code>E1</code> has a signed type and a non-negative\n  value, the  value of the result is the integral part of the quotient of\n  <code>E1/2^E2</code>. <strong>If E1 has a signed type and a negative value, the\n  resulting value is implementation-defined.</strong></p>\n</blockquote>\n<p>And nowhere in [expr.const]/2 it is said that such a shift, or expressions with implementation-defined values in general, are not constant expressions. \nYou will thus get a constant expression that has an implementation-defined value.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-20T20:37:04.250", "Score": "6", "CreationDate": "2014-10-20T20:28:07.550", "ParentId": "26474272", "CommentCount": "0", "LastEditDate": "2014-10-20T20:37:04.250", "OwnerUserId": "3647361"}});