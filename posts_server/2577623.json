post_cb({"2577623": {"ViewCount": "1548", "Body": "<p>First: where are <code>std::move</code> and <code>std::forward</code> defined?  I know what they do, but I can't find proof that any standard header is required to include them.  In gcc44 sometimes <code>std::move</code> is available, and sometimes its not, so a definitive include directive would be useful.</p>\n<p>When implementing move semantics, the source is presumably left in an undefined state.  Should this state necessarily be a valid state for the object?  Obviously, you need to be able to call the object's destructor, and be able to assign to it by whatever means the class exposes.  But should other operations be valid?  I suppose what I'm asking is, if your class guarantees certain invariants, should you strive to enforce those invariants when the user has said they don't care about them anymore?</p>\n<p>Next: when you don't care about move semantics, are there any limitations that would cause a non-const reference to be preferred over an rvalue reference when dealing with function parameters?  <code>void function(T&amp;);</code> over <code>void function(T&amp;&amp;);</code> From a caller's perspective, being able to pass functions temporary values is occasionally useful, so it seems as though one should grant that option whenever it is feasible to do so.  And rvalue references are themselves lvalues, so you can't inadvertently call a move-constructor instead of a copy-constructor, or something like that.  I don't see a downside, but I'm sure there is one.</p>\n<p>Which brings me to my final question.  You still can not bind temporaries to non-const references.  But you can bind them to non-const rvalue references.  And you can then pass along that reference as a non-const reference in another function.</p>\n<pre><code>void function1(int&amp; r) { r++; }\nvoid function2(int&amp;&amp; r) { function1(r); }\nint main() { \n    function1(5); //bad\n    function2(5); //good\n}\n</code></pre>\n<p>Besides the fact that it doesn't do anything, is there anything wrong with that code?  My gut says of course not, since changing rvalue references is kind of the whole point to their existence.  And if the passed value is legitimately const, the compiler will catch it and yell at you.  But by all appearances, this is a runaround of a mechanism that was presumably put in place for a reason, so I'd just like confirmation that I'm not doing anything foolish.</p>\n", "AcceptedAnswerId": "2577764", "Title": "Some clarification on rvalue references", "CreationDate": "2010-04-05T09:08:01.957", "Id": "2577623", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-10-01T15:03:32.957", "LastEditorUserId": "34509", "LastActivityDate": "2016-02-03T15:25:42.940", "Score": "10", "OwnerUserId": "293791", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2577623_2577764_4": {"length": 26, "quality": 0.9629629629629629, "section_id": 328}, "so_2577623_2577764_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 715}, "so_2577623_2577764_5": {"length": 30, "quality": 1.0, "section_id": 329}}, "n3337": {"so_2577623_2577764_4": {"length": 26, "quality": 0.9629629629629629, "section_id": 318}, "so_2577623_2577764_5": {"length": 30, "quality": 1.0, "section_id": 319}}, "n4659": {"so_2577623_2577764_4": {"length": 23, "quality": 0.8518518518518519, "section_id": 336}, "so_2577623_2577764_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 745}}}, "2577727": {"Id": "2577727", "PostTypeId": "2", "Body": "<p>included by <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a02026.html\" rel=\"nofollow noreferrer\">utility</a></p>\n<hr>\n<p><a href=\"http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx\" rel=\"nofollow noreferrer\">Here</a> is the article I read about rvalues.</p>\n<p>I can't help you with rest, sorry.</p>\n</hr>", "LastEditorUserId": "14114", "LastActivityDate": "2010-04-05T09:55:01.273", "Score": "2", "CreationDate": "2010-04-05T09:42:27.667", "ParentId": "2577623", "CommentCount": "0", "OwnerUserId": "14114", "LastEditDate": "2010-04-05T09:55:01.273"}, "2577764": {"Id": "2577764", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2577623_2577764_0\">First: where are std::move and std::forward defined?</p>\n</blockquote>\n<p>See <code>20.3</code> Utility components, <code>&lt;utility&gt;</code>. </p>\n<hr>\n<blockquote>\n<p id=\"so_2577623_2577764_1\">When implementing move semantics, the source is presumably left in an undefined state. Should this state necessarily be a valid state for the object? </p>\n</blockquote>\n<p>Obviously, the object should still be destructibly. But further than that, I think it's a good idea to be still assignable. The Standard says for objects that satisfy \"MoveConstructible\" and \"MoveAssignable\":</p>\n<blockquote>\n<p id=\"so_2577623_2577764_2\">[ Note: rv remains a valid object. Its state is unspecified. \u2014 end note ]</p>\n</blockquote>\n<p>This would mean, I think, that the object can still participate in any operation that doesn't state any precondition. This includes CopyConstructible, CopyAssignable, Destructible and other things. Notice that this won't require anything for your own objects from a core language perspective. The requirements only take place once you touch Standard library components that state these requirements. </p>\n<hr>\n<blockquote>\n<p id=\"so_2577623_2577764_3\">Next: when you don't care about move semantics, are there any limitations that would cause a non-const reference to be preferred over an rvalue reference when dealing with function parameters? </p>\n</blockquote>\n<p>This, unfortunately, crucially depends on whether the parameter is in a function template and uses a template parameter:</p>\n<pre><code>void f(int const&amp;); // takes all lvalues and const rvalues\nvoid f(int&amp;&amp;); // can only accept nonconst rvalues\n</code></pre>\n<p>However for a function template</p>\n<pre><code>template&lt;typename T&gt; void f(T const&amp;);\ntemplate&lt;typename T&gt; void f(T&amp;&amp;);\n</code></pre>\n<p>You can't say that, because the second template will, after being called with an lvalue, have as parameter of the synthesized declaration the type <code>U&amp;</code> for nonconst lvalues (and be a better match), and <code>U const&amp;</code> for const lvalues (and be ambiguous). <strike>To my knowledge, there is no partial ordering rule to disambiguate that second ambiguity.</strike> However, this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1014\" rel=\"nofollow noreferrer\">is already known</a>. </p>\n<p><strong><code>--</code> Edit <code>--</code></strong></p>\n<p>Despite that issue report, I don't think that the two templates are ambiguous. Partial ordering will make the first template more specialized, because after taking away the reference modifiers and the <code>const</code>, we will find that both types are the same, and then notice that the first template had a reference to const. The Standard says (<code>14.9.2.4</code>)</p>\n<blockquote>\n<p id=\"so_2577623_2577764_4\">If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transfor-mations above) and if the type from the argument template is more cv-quali\ufb01ed than the type from the parameter template (as described above) that type is considered to be more specialized than the other. </p>\n<p id=\"so_2577623_2577764_5\">If for each type being considered a given template is at least as specialized for all types and more specialized for some set of types and the other template is not more specialized for any types or is not at least as specialized for any types, then the given template is more specialized than the other template. </p>\n</blockquote>\n<p>This makes the <code>T const&amp;</code> template the winner of partial ordering (and GCC is indeed correct to choose it).</p>\n<p><strong><code>--</code> Edit End <code>--</code></strong></p>\n<hr>\n<blockquote>\n<p id=\"so_2577623_2577764_6\">Which brings me to my final question. You still can not bind temporaries to non-const references. But you can bind them to non-const rvalue references. </p>\n</blockquote>\n<p>This is nicely explained in <a href=\"http://cpp-next.com/archive/2009/09/move-it-with-rvalue-references/\" rel=\"nofollow noreferrer\">this article</a>. The second call using <code>function2</code> only takes nonconst rvalues. The rest of the program won't notice if they are modified, because they won't be able to access those rvalues afterwards anymore! And the <code>5</code> you pass is not a class type, so a hidden temporary is created and then passed to the <code>int&amp;&amp;</code> rvalue reference. The code calling <code>function2</code> won't be able to access that hidden object here, so it won't notice any change. </p>\n<p>A different situation is if you do this one:</p>\n<pre><code>SomeComplexObject o;\nfunction2(move(o));\n</code></pre>\n<p>You have explicitly requested that <code>o</code> is moved, so it will be modified according to its move specification. However moving is a <em>logically non-modifying operation</em> (see the article). This means whether you move or not shouldn't be observable from the calling code:</p>\n<pre><code>SomeComplexObject o;\nmoveit(o); // #1\no = foo;\n</code></pre>\n<p>If you erase the line that moves, behavior will still be the same, because it's overwritten anyway. This however means that code that uses the value of <code>o</code> after it has been moved from is <em>bad</em>, because it breaks this implicit contract between <code>moveit</code> and the calling code. Thus, the Standard makes no specification about the concrete value of a moved from container. </p>\n</hr></hr></hr>", "LastEditorUserId": "452775", "LastActivityDate": "2016-02-03T15:25:42.940", "Score": "10", "CreationDate": "2010-04-05T09:52:32.683", "ParentId": "2577623", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2016-02-03T15:25:42.940"}, "2577730": {"Id": "2577730", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2577623_2577730_0\">where are std::move and std::forward defined?</p>\n</blockquote>\n<p><code>std::move</code> and <code>std::forward</code> are declared in <code>&lt;utility&gt;</code>. See the synopsis at the beginning of section 20.3[utility].</p>\n<blockquote>\n<p id=\"so_2577623_2577730_1\">When implementing move semantics, the source is presumably left in an undefined state.</p>\n</blockquote>\n<p>It of course depends on how you implement the move-constructor and move-assignment operator. If you want to use your objects in standard containers, however, you have to follow the <code>MoveConstructible</code> and <code>MoveAssignable</code> concepts, which says that the object remains valid, but is left in <em>unspecified</em> state, i.e. you definitely can destroy it.</p>\n", "LastEditorUserId": "89847", "LastActivityDate": "2010-04-05T09:56:33.147", "Score": "4", "CreationDate": "2010-04-05T09:43:14.587", "ParentId": "2577623", "CommentCount": "0", "OwnerUserId": "89847", "LastEditDate": "2010-04-05T09:56:33.147"}});