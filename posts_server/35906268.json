post_cb({"35906884": {"ParentId": "35906268", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The correct answer depends on which C++ standard you are talking about.</p>\n<p>If we are talking about C++11, clang is correct (an explicit move is needed).  If we are talking about C++14, gcc is correct (an explicit move is not needed).</p>\n<p>C++11 says in N3290/[class.copy]/p32:</p>\n<blockquote>\n<p id=\"so_35906268_35906884_0\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue. If overload resolution\n  fails, ...</p>\n</blockquote>\n<p>This demands that you only get the implicit move when the return expression has the same type as the function return type.</p>\n<p>But <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow noreferrer\">CWG 1579</a> changed this, and this defect report was accepted after C++11, and in time for C++14.  This same paragraph now reads:</p>\n<blockquote>\n<p id=\"so_35906268_35906884_1\">When the criteria for elision of a copy/move operation are met, but\n  not for an <em>exception-declaration</em>, and the object to be copied is\n  designated by an lvalue, or when the <em>expression</em> in a <code>return</code> statement\n  is a (possibly parenthesized) <em>id-expression</em> that names an object with\n  automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or\n  <em>lambda-expression</em>, overload resolution to select the constructor for\n  the copy is first performed as if the object were designated by an\n  rvalue. If the first overload resolution fails or was not performed, ...</p>\n</blockquote>\n<p>This modification basically allows the return expression type to be <em>convertible-to</em> the function return type and still be eligible for implicit move.</p>\n<p><strong>Does this mean that the code needs a <code>#if</code>/<code>#else</code> based on the value of <code>__cplusplus</code>?</strong></p>\n<p>One could do that, but I wouldn't bother.  If I were targeting C++14, I would just:</p>\n<pre><code>return i;\n</code></pre>\n<p>If the code is unexpectedly run under a C++11 compiler, you will be notified at compile-time of the error, and it is trivial to fix:</p>\n<pre><code>return std::move(i);\n</code></pre>\n<p>If you are just targeting C++11, use the <code>move</code>.</p>\n<p>If you want to target both C++11 and C++14 (and beyond), use the <code>move</code>.  The downside of using <code>move</code> gratuitously is that you can inhibit RVO (Return Value Optimization).  However, in this case, RVO is not even legal (because of the conversion from the <code>return</code> statement to the return type of the function).  And so the gratuitous <code>move</code> does not hurt anything.</p>\n<p>The one time you might lean towards a gratuitous <code>move</code> even when targeting C++14 is if without it, things still compile in C++11, and invoke an expensive <em>copy</em> conversion, as opposed to a <em>move</em> conversion.  In this case, accidentally compiling under C++11 would introduce a silent performance bug.  And when compiled under C++14 the gratuitous <code>move</code> still has no detrimental effects.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2016-03-10T14:44:02.213", "Id": "35906884", "Score": "17", "CreationDate": "2016-03-10T03:12:49.327", "LastActivityDate": "2016-03-10T14:44:02.213"}, "35906378": {"ParentId": "35906268", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>std::unique_ptr</code> could be used to construct <code>std::shared_ptr</code> only when it's a rvalue. See the constructor declaration of <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\"><code>std::shared_ptr</code></a>:</p>\n<pre><code>template&lt; class Y, class Deleter &gt;\nshared_ptr( std::unique_ptr&lt;Y,Deleter&gt;&amp;&amp; r );\n</code></pre>\n<p>So you need to use <code>std::move</code> to make the 1st case work, otherwise it should fail.</p>\n<pre><code>return std::move(i);\n</code></pre>\n<p>BTW: I compiled the code with <a href=\"http://rextester.com/BNHC81313\">gcc 4.9.3</a> it failed either.</p>\n<pre><code>source_file.cpp:14:12: error: cannot bind \u2018std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;\u2019 \nlvalue to \u2018std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;&amp;\u2019\n     return i;\n            ^\n</code></pre>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-03-10T02:39:49.133", "Id": "35906378", "Score": "9", "CreationDate": "2016-03-10T02:14:56.913", "LastActivityDate": "2016-03-10T02:39:49.133"}, "bq_ids": {"n4140": {"so_35906268_35906884_1": {"section_id": 481, "quality": 0.9791666666666666, "length": 47}, "so_35906268_35906884_0": {"section_id": 481, "quality": 0.71875, "length": 23}}, "n3337": {"so_35906268_35906884_0": {"section_id": 472, "quality": 1.0, "length": 32}}, "n4659": {"so_35906268_35906884_1": {"section_id": 504, "quality": 0.75, "length": 36}, "so_35906268_35906884_0": {"section_id": 504, "quality": 0.59375, "length": 19}}}, "35906268": {"CommentCount": "2", "CreationDate": "2016-03-10T02:03:32.240", "PostTypeId": "1", "AcceptedAnswerId": "35906884", "LastEditorUserId": "2104697", "LastActivityDate": "2016-10-10T02:19:07.480", "LastEditDate": "2016-10-10T02:19:07.480", "ViewCount": "697", "FavoriteCount": "3", "Title": "Returning local unique_ptr as a shared_ptr", "Id": "35906268", "Score": "15", "Body": "<p>I'm used to not use <code>std::move</code> when returning a <code>std::unique_ptr</code>, because doing so prohibits RVO. I have this case where I have a local <code>std::unique_ptr</code>, but the return type is a <code>std::shared_ptr</code>.\nHere's a sample of the code:</p>\n<pre><code>shared_ptr&lt;int&gt; getInt1() {\n    auto i = make_unique&lt;int&gt;();\n\n    *i = 1;\n\n    return i;\n}\n\nshared_ptr&lt;int&gt; getInt2() {\n    return make_unique&lt;int&gt;(2);\n}\n\nunique_ptr&lt;int&gt; getInt3() {\n    auto ptr = make_unique&lt;int&gt;(2);\n\n    return ptr;\n}\n\nint main() {\n    cout &lt;&lt; *getInt1() &lt;&lt; endl &lt;&lt; *getInt2() &lt;&lt; *getInt3() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>GCC accepts both cases, but Clang refuses the <code>getInt1()</code> With this error:</p>\n<pre><code>main.cpp:10:13: error: no viable conversion from 'std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;' to 'shared_ptr&lt;int&gt;'\n    return i;\n           ^\n</code></pre>\n<p>Here's both cases on coliru: <a href=\"http://coliru.stacked-crooked.com/a/58b889ffc9495cec\" rel=\"nofollow\">GCC</a>, <a href=\"http://coliru.stacked-crooked.com/a/9ea02839b2557d57\" rel=\"nofollow\">Clang</a></p>\n<p>Both compiler accept the third case.</p>\n<p>Which one is wrong? Thanks.</p>\n", "Tags": "<c++><gcc><clang><language-lawyer><c++14>", "OwnerUserId": "2104697", "AnswerCount": "2"}});