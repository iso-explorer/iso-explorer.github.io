post_cb({"16323119": {"ParentId": "16323032", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>The reason <code>[&amp;this]</code> doesn't work is because it is a syntax error.  Each comma-seperated parameter in the <code>lambda-introducer</code> is a <code>capture</code>:</p>\n<pre><code>capture:\n    identifier\n    &amp; identifier\n    this\n</code></pre>\n<p>You can see that <code>&amp;this</code> isn't allowed syntactically.  The reason it isn't allowed is because you would never want to capture <code>this</code> by reference, as it is a small const pointer.  You would only ever want to pass it by value - so the language just doesn't support capturing <code>this</code> by reference.</p>\n<p>To capture <code>this</code> explicitly you can use <code>[this]</code> as the <code>lambda-introducer</code>.</p>\n<p>The first <code>capture</code> can be a <code>capture-default</code> which is:</p>\n<pre><code>capture-default:\n    &amp;\n    =\n</code></pre>\n<p>This means capture automatically whatever I use, by reference (<code>&amp;</code>) or by value (<code>=</code>) respectively - however the treatment of <code>this</code> is special - in both cases it is captured by value for the reasons given previously (even with a default capture of <code>&amp;</code>, which usually means capture by reference).</p>\n<p>5.1.2.7/8:</p>\n<blockquote>\n<p id=\"so_16323032_16323119_0\">For purposes of name lookup (3.4), determining the type and value of <code>this</code> (9.3.2) and transforming id-\n  expressions referring to non-static class members into class member access expressions using <code>(*this)</code> (9.3.1),\n  the compound-statement [OF THE LAMBDA] is considered in the context of the lambda-expression.</p>\n</blockquote>\n<p>So the lambda acts as if it is part of the enclosing member function when using member names (like in your example the use of the name <code>x</code>), so it will generate \"implicit usages\" of <code>this</code> just like a member function does.</p>\n<blockquote>\n<p id=\"so_16323032_16323119_1\">If a lambda-capture includes a capture-default that is <code>&amp;</code>, the identifiers in the lambda-capture shall not be\n  preceded by <code>&amp;</code>. If a lambda-capture includes a capture-default that is <code>=</code>, the lambda-capture shall not contain\n  <code>this</code> and each identifier it contains shall be preceded by <code>&amp;</code>. An identifier or <code>this</code> shall not appear more than\n  once in a lambda-capture.</p>\n</blockquote>\n<p>So you can use <code>[this]</code>, <code>[&amp;]</code>, <code>[=]</code> or <code>[&amp;,this]</code> as a <code>lambda-introducer</code> to capture the <code>this</code> pointer by value.</p>\n<p>However <code>[&amp;this]</code> and <code>[=, this]</code> are ill-formed.  In the last case gcc forgivingly warns for <code>[=,this]</code> that <code>explicit by-copy capture of \u2018this\u2019 redundant with by-copy capture default</code> rather than errors.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-05-01T18:06:53.813", "Id": "16323119", "Score": "61", "CreationDate": "2013-05-01T17:24:22.107", "LastActivityDate": "2013-05-01T18:06:53.813"}, "16323032": {"CommentCount": "1", "CreationDate": "2013-05-01T17:19:05.450", "PostTypeId": "1", "AcceptedAnswerId": "16323119", "LastEditorUserId": "194894", "LastActivityDate": "2016-08-11T10:56:16.720", "LastEditDate": "2016-08-11T10:56:16.720", "ViewCount": "27572", "FavoriteCount": "11", "Title": "Why can't I capture this by-reference ('&this') in lambda?", "Id": "16323032", "Score": "45", "Body": "<p>I understand the correct way to capture <code>this</code> (to modify object properties) in a lambda is as follows:</p>\n<pre><code>auto f = [this] () { /* ... */ };\n</code></pre>\n<p>But I'm curious as to the following peculiarity I've seen:</p>\n<pre><code>class C {\n    public:\n        void foo() {\n            // auto f = [] () { // this not captured\n            auto f = [&amp;] () { // why does this work?\n            // auto f = [&amp;this] () { // Expected ',' before 'this'\n            // auto f = [this] () { // works as expected\n                x = 5;\n            };\n            f();\n        }\n\n    private:\n        int x;\n};\n</code></pre>\n<p>The oddity that I am confused by (and would like answered) is why the following works:</p>\n<pre><code>auto f = [&amp;] () { /* ... */ }; // capture everything by reference\n</code></pre>\n<p>And why I cannot explicitly capture <code>this</code> by reference:</p>\n<pre><code>auto f = [&amp;this] () { /* ... */ }; // a compiler error as seen above.\n</code></pre>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "812183", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16323032_16323119_0": {"section_id": 5966, "quality": 0.7692307692307693, "length": 20}, "so_16323032_16323119_1": {"section_id": 5967, "quality": 0.7142857142857143, "length": 15}}, "n3337": {"so_16323032_16323119_0": {"section_id": 5735, "quality": 0.7692307692307693, "length": 20}, "so_16323032_16323119_1": {"section_id": 5736, "quality": 1.0, "length": 21}}, "n4659": {"so_16323032_16323119_0": {"section_id": 7460, "quality": 0.7692307692307693, "length": 20}, "so_16323032_16323119_1": {"section_id": 7465, "quality": 0.7142857142857143, "length": 15}}}});