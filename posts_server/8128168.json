post_cb({"8128168": {"CommentCount": "5", "AcceptedAnswerId": "8128390", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2011-11-14T21:11:47.103", "LastActivityDate": "2016-04-12T07:25:18.380", "LastEditDate": "2015-10-19T13:52:27.340", "ViewCount": "2557", "FavoriteCount": "6", "Title": "Is the behavior of subtracting two NULL pointers defined?", "Id": "8128168", "Score": "73", "Body": "<p>Is the difference of two non-void pointer variables defined (per C99 and/or C++98) if they are both <code>NULL</code> valued?</p>\n<p>For instance, say I have a buffer structure that looks like this:</p>\n<pre><code>struct buf {\n  char *buf;\n  char *pwrite;\n  char *pread;\n} ex;\n</code></pre>\n<p>Say, <code>ex.buf</code> points to an array or some malloc'ed memory. If my code always ensures that <code>pwrite</code> and <code>pread</code> point within that array or one past it, then I am fairly confident that <code>ex.pwrite - ex.pread</code> will always be defined. However, what if <code>pwrite</code> and <code>pread</code> are both NULL. Can I just expect subtracting the two is defined as <code>(ptrdiff_t)0</code> or does strictly compliant code need to test the pointers for NULL? Note that the only case I am interested in is when <em>both</em> pointers are NULL (which represents a buffer not initialized case). The reason has to do with a fully compliant \"available\" function given the preceding assumptions are met:</p>\n<pre><code>size_t buf_avail(const struct s_buf *b)\n{     \n    return b-&gt;pwrite - b-&gt;pread;\n}\n</code></pre>\n", "Tags": "<c++><c><c99><c89>", "OwnerUserId": "1026289", "AnswerCount": "4"}, "8128295": {"ParentId": "8128168", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I found this in the C++ standard (5.7 [expr.add] / 7):</p>\n<blockquote>\n<p id=\"so_8128168_8128295_0\">If two pointers [...] both are null, and the two pointers are\n  subtracted, the result compares equal to the value 0 converted to the\n  type std::ptrdiff_t</p>\n</blockquote>\n<p>As others have said, C99 requires addition/subtraction between 2 pointers be of the same array object. NULL does not point to a valid object which is why you cannot use it in subtraction.</p>\n", "OwnerUserId": "964135", "LastEditorUserId": "964135", "LastEditDate": "2011-11-14T21:42:20.870", "Id": "8128295", "Score": "35", "CreationDate": "2011-11-14T21:22:41.857", "LastActivityDate": "2011-11-14T21:42:20.870"}, "8128390": {"ParentId": "8128168", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In C99, it's technically undefined behavior.  C99 \u00a76.5.6 says:</p>\n<blockquote>\n<p id=\"so_8128168_8128390_0\">7) For the purposes of these operators, a pointer to an object that is not an element of an\n  array behaves the same as a pointer to the first element of an array of length one with the\n  type of the object as its element type.</p>\n<p id=\"so_8128168_8128390_1\">[...]</p>\n<p id=\"so_8128168_8128390_2\">9) When two pointers are subtracted, both shall point to elements of the same array object,\n  or one past the last element of the array object; the result is the difference of the\n  subscripts of the two array elements. [...]</p>\n</blockquote>\n<p>And \u00a76.3.2.3/3 says:</p>\n<blockquote>\n<p id=\"so_8128168_8128390_3\">An integer constant expression with the value 0, or such an expression cast to type\n  <code>void *</code>, is called a null pointer constant.<sup>55)</sup> If a null pointer constant is converted to a pointer type, the resulting pointer, called a <em>null pointer</em>, is guaranteed to compare unequal to a pointer to any object or function.</p>\n</blockquote>\n<p>So since a null pointer is unequal to any object, it violates the preconditions of 6.5.6/9, so it's undefined behavior.  But in practicality, I'd be willing to bet that pretty much every compiler will return a result of 0 without any ill side effects.</p>\n<p>In C89, it's also undefined behavior, though the wording of the standard is slightly different.</p>\n<p>C++03, on the other hand, does have defined behavior in this instance.  The standard makes a special exception for subtracting two null pointers.  C++03 \u00a75.7/7 says:</p>\n<blockquote>\n<p id=\"so_8128168_8128390_4\">If the value 0 is added to or subtracted from a pointer value, the result compares equal to the original pointer value. If two pointers point to the same object or both point one past the end of the same array or both are null, and the two pointers are subtracted, the result compares equal to the value 0 converted to the type <code>ptrdiff_t</code>.</p>\n</blockquote>\n<p>C++11 (as well as the latest draft of C++14, n3690) have identical wording to C++03, with just the minor change of <code>std::ptrdiff_t</code> in place of <code>ptrdiff_t</code>.</p>\n", "OwnerUserId": "9530", "LastEditorUserId": "9530", "LastEditDate": "2013-10-15T15:44:27.423", "Id": "8128390", "Score": "93", "CreationDate": "2011-11-14T21:28:15.033", "LastActivityDate": "2013-10-15T15:44:27.423"}, "36566355": {"ParentId": "8128168", "CommentCount": "0", "Body": "<p>The C Standard does not impose any requirements on the behavior, however many implementations do specify the behavior of pointer arithmetic in many cases beyond the bare minimums required by the Standard, including the behavior of subtracting one null pointer from another.  There are very few architectures where there should ever be any reason for such a subtraction to do anything other than yield zero, but unfortunately it is now fashionable for compilers to--in the name of \"optimization\"--require that programmers manually write code to handle corner cases which platforms would previously have handled correctly.  For example, if code which is supposed to output <code>n</code> characters starting at address <code>p</code> is written as:</p>\n<pre><code>void out_characters(unsigned char *p, int n)\n{\n  unsigned char *end = p+n;\n  while(p &lt; end)\n    out_byte(*p++);\n}\n</code></pre>\n<p>older compilers would generate code that would reliably output nothing, with\nno side-effect, if p==NULL and n==0, with no need to special-case n==0.  On\nnewer compilers, however, one would have to add extra code:</p>\n<pre><code>void out_characters(unsigned char *p, int n)\n{\n  if (n)\n  {\n    unsigned char *end = p+n;\n    while(p &lt; end)\n      out_byte(*p++);\n  }\n}\n</code></pre>\n<p>which an optimizer may or may not be able to get rid of.  Failing to include the extra code may cause some compilers to figure that since p \"can't possibly be null\", any subsequent null pointer checks may be omitted, thus causing the code to break in a spot unrelated to the actual \"problem\".</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "36566355", "Score": "1", "CreationDate": "2016-04-12T07:25:18.380", "LastActivityDate": "2016-04-12T07:25:18.380"}, "bq_ids": {"n4140": {"so_8128168_8128295_0": {"section_id": 6145, "quality": 1.0, "length": 14}, "so_8128168_8128390_0": {"section_id": 6141, "quality": 0.85, "length": 17}, "so_8128168_8128390_2": {"section_id": 6143, "quality": 0.7272727272727273, "length": 16}, "so_8128168_8128390_4": {"section_id": 6145, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_8128168_8128295_0": {"section_id": 5908, "quality": 1.0, "length": 14}, "so_8128168_8128390_3": {"section_id": 36, "quality": 0.5333333333333333, "length": 16}, "so_8128168_8128390_0": {"section_id": 5905, "quality": 0.85, "length": 17}, "so_8128168_8128390_2": {"section_id": 5907, "quality": 0.7272727272727273, "length": 16}, "so_8128168_8128390_4": {"section_id": 5908, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_8128168_8128295_0": {"section_id": 7641, "quality": 0.7142857142857143, "length": 10}, "so_8128168_8128390_0": {"section_id": 7603, "quality": 0.55, "length": 11}}}, "8128225": {"ParentId": "8128168", "PostTypeId": "2", "CommentCount": "16", "Body": "<p><em>Edit</em>: This answer is only valid for C, I didn't see the C++ tag when I answered.</p>\n<p>No, pointer arithmetic is only allowed for pointers that point within the same object. Since by definition of the C standard null pointers don't point to any object, this is undefined behavior.</p>\n<p>(Although, I'd guess that any reasonable compiler will return just <code>0</code> on it, but who knows.)</p>\n", "OwnerUserId": "366377", "LastEditorUserId": "366377", "LastEditDate": "2011-11-14T22:16:55.540", "Id": "8128225", "Score": "23", "CreationDate": "2011-11-14T21:16:31.933", "LastActivityDate": "2011-11-14T22:16:55.540"}});