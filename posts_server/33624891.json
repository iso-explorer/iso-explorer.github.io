post_cb({"bq_ids": {"n4140": {"so_33624891_39406298_2": {"length": 36, "quality": 1.0, "section_id": 307}, "so_33624891_39406298_1": {"length": 12, "quality": 1.0, "section_id": 307}, "so_33624891_39406298_0": {"length": 9, "quality": 0.9, "section_id": 307}}, "n3337": {"so_33624891_39406298_2": {"length": 36, "quality": 1.0, "section_id": 298}, "so_33624891_39406298_1": {"length": 12, "quality": 1.0, "section_id": 298}, "so_33624891_39406298_0": {"length": 9, "quality": 0.9, "section_id": 298}}, "n4659": {"so_33624891_39406298_2": {"length": 36, "quality": 1.0, "section_id": 314}, "so_33624891_39406298_1": {"length": 12, "quality": 1.0, "section_id": 314}, "so_33624891_39406298_0": {"length": 10, "quality": 1.0, "section_id": 314}}}, "33818078": {"Id": "33818078", "PostTypeId": "2", "Body": "<p>Some kind of the general answer is here: <a href=\"https://stackoverflow.com/questions/27523684/\">Expression SFINAE to overload on type of passed function pointer</a></p>\n<p>For the practical case, there's no need to use type traits or <code>decltype()</code> - the good old overload resolution will select the most appropriate function for you and break it into 'arguments' and 'return type'. Just enumerate all possible calling conventions</p>\n<pre><code>// Common functions\ntemplate &lt;class T, typename R&gt; void foo2(R(*)(T*)) {}\n\n// Different calling conventions\n#ifdef _W64\ntemplate &lt;class T, typename R&gt; void foo2(R(__vectorcall *)(T*)) {}\n#else\ntemplate &lt;class T, typename R&gt; void foo2(R(__stdcall *)(T*)) {}\n#endif\n\n// Lambdas\ntemplate &lt;class T, class D&gt;\nauto foo2(const D &amp;d) -&gt; void_t&lt;decltype(d(std::declval&lt;T*&gt;()))&gt; {}\n</code></pre>\n<p>It could be useful to wrap them in a templated structure</p>\n<pre><code>template&lt;typename... T&gt;\nstruct Foo2 {\n    // Common functions\n    template &lt;typename R&gt; static void foo2(R(*)(T*...)) {}\n    ...\n};\nZoo2&lt;Baz&gt;::foo2(bar);\n</code></pre>\n<p>Although, it will require more code for member functions as they have modifiers (<code>const</code>, <code>volatile</code>, <code>&amp;&amp;</code>)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-20T02:38:07.863", "Score": "0", "CreationDate": "2015-11-20T02:38:07.863", "ParentId": "33624891", "CommentCount": "0", "OwnerUserId": "473359", "LastEditDate": "2017-05-23T12:01:43.247"}, "39406298": {"Id": "39406298", "PostTypeId": "2", "Body": "<p>As mentioned in the comments, <a href=\"http://eel.is/c++draft/temp.deduct#call-6\" rel=\"nofollow\">[14.8.2.1/6]</a> (working draft, <em>deducing template arguments from a function call</em>) rules in this case (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33624891_39406298_0\"><strong>When\u00a0P\u00a0is a</strong> function type, <strong>function pointer type</strong>, or pointer to member function type:</p>\n<ul>\n<li><p id=\"so_33624891_39406298_1\">If the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.</p></li>\n<li><p id=\"so_33624891_39406298_2\"><strong>If the argument is an overload set (not containing function templates)</strong>, trial argument deduction is attempted using each of the members of the set. If deduction succeeds for only one of the overload set members, that member is used as the argument value for the deduction. <strong>If deduction succeeds for more than one member of the overload set the parameter is treated as a non-deduced context.</strong></p></li>\n</ul>\n</blockquote>\n<p>SFINAE takes its part to the game once the deduction is over, so it doesn't help to work around the standard's rules.<br>\nFor further details, you can see the examples at the end of the bullet linked above.</br></p>\n<p>About your last question:</p>\n<blockquote>\n<p id=\"so_33624891_39406298_3\">Is there a way to make\u00a0<code>foo2&lt;Baz&gt;(bar);</code> (or something similar) compile ?</p>\n</blockquote>\n<p>Two possible alternatives:</p>\n<ul>\n<li><p>If you don't want to modify the definition of <code>foo2</code>, you can invoke it as:</p>\n<pre><code>foo2&lt;Baz&gt;(static_cast&lt;void(*)(Baz *)&gt;(bar));\n</code></pre>\n<p>This way you explicitly pick a function out of the overload set.</p></li>\n<li><p>If modifying <code>foo2</code> is allowed, you can rewrite it as:</p>\n<pre><code>template &lt;class T, class R&gt;\nauto foo2(R(*d)(T*)) {}\n</code></pre>\n<p>It's more or less what you had before, no <code>decltype</code> in this case and a return type you can freely ignore.<br>\nActually you don't need to use any SFINAE'd function to do that, deduction is enough.<br>\nIn this case <code>foo2&lt;Baz&gt;(bar);</code> is correctly resolved.</br></br></p></li>\n</ul>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-09-09T07:53:27.257", "Score": "1", "CreationDate": "2016-09-09T07:39:28.840", "ParentId": "33624891", "CommentCount": "0", "OwnerUserId": "4987285", "LastEditDate": "2016-09-09T07:53:27.257"}, "33624891": {"ViewCount": "315", "Body": "<p>I'm experimenting with resolving the address of an overloaded function (<code>bar</code>) in the context of another function's parameter (<code>foo1</code>/<code>foo2</code>).</p>\n<pre><code>struct Baz {};\n\nint bar() { return 0; }\nfloat bar(int) { return 0.0f; }\nvoid bar(Baz *) {}\n\nvoid foo1(void (&amp;)(Baz *)) {}\n\ntemplate &lt;class T, class D&gt;\nauto foo2(D *d) -&gt; void_t&lt;decltype(d(std::declval&lt;T*&gt;()))&gt; {}\n\nint main() {\n    foo1(bar);      // Works\n    foo2&lt;Baz&gt;(bar); // Fails\n}\n</code></pre>\n<p>There's no trouble with <code>foo1</code>, which specifies <code>bar</code>'s type explicitly.</p>\n<p>However, <code>foo2</code>, which disable itself via SFINAE for all but one version of <code>bar</code>, fails to compile with the following message :</p>\n<pre><code>main.cpp:19:5: fatal error: no matching function for call to 'foo2'\n    foo2&lt;Baz&gt;(bar); // Fails\n    ^~~~~~~~~\nmain.cpp:15:6: note: candidate template ignored: couldn't infer template argument 'D'\nauto foo2(D *d) -&gt; void_t&lt;decltype(d(std::declval&lt;T*&gt;()))&gt; {}\n     ^\n1 error generated.\n</code></pre>\n<p>It is my understanding that C++ cannot resolve the overloaded function's address and perform template argument deduction at the same time.</p>\n<p>Is that the cause ? Is there a way to make <code>foo2&lt;Baz&gt;(bar);</code> (or something similar) compile ?</p>\n", "Title": "SFINAE and the address of an overloaded function", "CreationDate": "2015-11-10T07:33:24.603", "LastActivityDate": "2016-09-09T07:53:27.257", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "Id": "33624891", "Score": "11", "OwnerUserId": "3233393", "Tags": "<c++><sfinae><function-overloading><c++1z><template-deduction>", "AnswerCount": "2"}});