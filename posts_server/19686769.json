post_cb({"19688690": {"ParentId": "19686769", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First, an example:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n\nstruct S\n{\n    S(int i) { if(i &gt; 42) throw \"up\"; }\n\n    static void* operator new(std::size_t s, int i, double d, char c)\n    {\n        std::cout &lt;&lt; \"allocated with arguments: \"\n                  &lt;&lt;i&lt;&lt;\", \"&lt;&lt;d&lt;&lt;\", \"&lt;&lt;c&lt;&lt;std::endl;\n        return new char[s];\n    }\n\n    static void operator delete(void* p, int i, double d, char c)\n    {\n        std::cout &lt;&lt; \"deallocated with arguments: \"\n                  &lt;&lt;i&lt;&lt;\", \"&lt;&lt;d&lt;&lt;\", \"&lt;&lt;c&lt;&lt;std::endl;\n        delete[] (char*)p;\n    }\n\n    static void operator delete(void* p)\n    {\n        std::cout &lt;&lt; \"deallocated w/o arguments\"&lt;&lt;std::endl;\n        delete[] (char*)p;\n    }\n};\n\nint main()\n{\n    auto p0 = new(1, 2.0, '3') S(42);\n\n    S* p1 = nullptr;\n    try\n    {\n        p1 = new(4, 5.0, '6') S(43);\n    }catch(const char* msg)\n    {\n        std::cout &lt;&lt; \"exception: \"&lt;&lt;msg&lt;&lt;std::endl;\n    }\n\n    delete p1;\n    delete p0;\n}\n</code></pre>\n<p>Output:</p>\n<pre>allocated with arguments: 1, 2, 3\nallocated with arguments: 4, 5, 6\ndeallocated with arguments: 4, 5, 6\nexception: up\ndeallocated w/o arguments\n</pre>\n<hr>\n<blockquote>\n<p id=\"so_19686769_19688690_0\">The canonical definition of an operator new overload is <code>void *operator new(std::size_t, heap h)</code></p>\n</blockquote>\n<p><strike>I don't see how this is canonical, since it's not allowed:</strike>\nOk, now it's a valid placement-form of <code>new</code> :)</p>\n<p>[basic.stc.dynamic.allocation]/1</p>\n<blockquote>\n<p id=\"so_19686769_19688690_1\">An allocation function shall be a class member function or a global function; a program is ill-formed if an allocation function is declared in a namespace scope other than global scope or declared static in global scope. The return type shall be <code>void*</code>. <strong>The first parameter shall have type <code>std::size_t</code></strong>. The first parameter shall not have an associated default argument. <strong>The value of the first parameter shall be interpreted as the requested size of the allocation.</strong></p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>You can overload the allocation function to be called for the placement-form of <code>new</code>, see [expr.new] (it's not explicitly allowed in [basic.stc.dynamic.allocation] for non-template functions, but also not forbidden). The placement given in <code>new(placement)</code> is generalized here to an <em>expression-list</em>. Each <em>expression</em> in the <em>expression-list</em> for a specific <em>new-expression</em> is passed as an additional arguments to the allocation function. If the deallocation function is called (e.g. because the called ctor throws an exception), the same arguments plus a leading <code>void*</code> (the return value of the allocation function) are passed to the deallocation function.</p>\n<p>[expr.new]/18 states:</p>\n<blockquote>\n<p id=\"so_19686769_19688690_2\">If any part of the object initialization described above terminates by throwing an exception, storage has been obtained for the object, and a suitable deallocation function can be found, the deallocation function is called to free the memory in which the object was being constructed, after which the exception continues to propagate in the context of the <em>new-expression</em>. If no unambiguous matching deallocation function can be found, propagating the exception does not cause the object\u2019s memory to be freed. [<em>Note:</em> This is appropriate when the called allocation function does not allocate memory; otherwise, it is likely to result in a memory leak. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>and /21</p>\n<blockquote>\n<p id=\"so_19686769_19688690_3\">If a <em>new-expression</em> calls a deallocation function, it passes the value returned from the allocation function call as the first argument of type <code>void*</code>. If a placement deallocation function is called, it is passed the same additional arguments as were passed to the placement allocation function, that is, the same arguments as those specified with the new-placement syntax.</p>\n</blockquote>\n<p>and /20</p>\n<blockquote>\n<p id=\"so_19686769_19688690_4\">A declaration of a placement deallocation function matches the declaration of a placement allocation function if it has the same number of parameters and, after parameter transformations, all parameter types except the first are identical. Any non-placement deallocation function matches a non-placement allocation function. If the lookup finds a single matching deallocation function, that function will be called; otherwise, no deallocation function will be called. If the lookup finds the two-parameter form of a usual deallocation function and that function, considered as a placement deallocation function, would have been selected as a match for the allocation function, the program is ill-formed. [<em>Example:</em></p>\n<pre><code>struct S {\n    // Placement allocation function:\n    static void* operator new(std::size_t, std::size_t);\n    // Usual (non-placement) deallocation function:\n    static void operator delete(void*, std::size_t);\n};\n\nS* p = new (0) S; // ill-formed: non-placement deallocation function matches\n                  // placement allocation function\n</code></pre>\n<p id=\"so_19686769_19688690_5\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Going back to [basic.stc.dynamic.deallocation]:</p>\n<blockquote>\n<p id=\"so_19686769_19688690_6\">1 Deallocation functions shall be class member functions or global functions; a program is ill-formed if deallocation functions are declared in a namespace scope other than global scope or declared static in global scope.</p>\n<p id=\"so_19686769_19688690_7\">2 Each deallocation function shall return <code>void</code> and its first parameter shall be <code>void*</code>. A deallocation function can have more than one parameter.</p>\n</blockquote>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-10-30T16:59:24.560", "Id": "19688690", "Score": "1", "CreationDate": "2013-10-30T16:36:16.427", "LastActivityDate": "2013-10-30T16:59:24.560"}, "19687593": {"ParentId": "19686769", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>When a constructor throws an exception the matching delete is called.  The destructor is not called for the class that threw but any components of the class that have successfully had their constructors called will have their destructors called.</p>\n", "OwnerUserId": "92601", "LastEditorUserId": "92601", "LastEditDate": "2013-10-31T13:26:26.297", "Id": "19687593", "Score": "1", "CreationDate": "2013-10-30T15:50:21.363", "LastActivityDate": "2013-10-31T13:26:26.297"}, "19687679": {"ParentId": "19686769", "CommentCount": "0", "Body": "<p>When the construction of the object being constructed as a part of the <em>new-expression</em> fails, a corresponding deallocation function -- if there is one -- will be called. For instance</p>\n<pre><code>new X;\n</code></pre>\n<p>will use the following pair of allocation/deallocation functions.</p>\n<pre><code>void * operator new(std::size_t);\nvoid operator delete(void *);\n</code></pre>\n<p>Similarly, for a placement new of the form</p>\n<pre><code>new(&amp;a) X;\n</code></pre>\n<p>the placement versions of <code>operator new</code> and <code>operator delete</code> function will be used.</p>\n<pre><code>void * operator new(std::size_t, void *);\nvoid operator delete(void *, void *);\n</code></pre>\n<p>Note that the last function intentionally performs no action.</p>\n", "OwnerUserId": "89847", "PostTypeId": "2", "Id": "19687679", "Score": "0", "CreationDate": "2013-10-30T15:53:48.497", "LastActivityDate": "2013-10-30T15:53:48.497"}, "19686769": {"CommentCount": "6", "AcceptedAnswerId": "19687593", "PostTypeId": "1", "LastEditorUserId": "168868", "CreationDate": "2013-10-30T15:19:18.360", "LastActivityDate": "2013-10-31T13:26:26.297", "LastEditDate": "2013-10-30T17:14:39.323", "ViewCount": "1452", "FavoriteCount": "1", "Title": "How does C++ free the memory when a constructor throws an exception and a custom new is used", "Id": "19686769", "Score": "12", "Body": "<p>I see the following constructs:</p>\n<ul>\n<li><p><code>new X</code> will free the memory if <code>X</code> constructor throws.</p></li>\n<li><p><code>operator new()</code> can be overloaded.</p></li>\n</ul>\n<p>The canonical definition of an operator new overload is <code>void *operator new(size_t c, heap h)</code> and the corresponding <code>operator delete</code>.</p>\n<p>The most common operator new overload is placement new, which is <code>void *operator new(void *p) { return p; }</code></p>\n<p>You almost always cannot call <code>delete</code> on the pointer given to placement <code>new</code>.</p>\n<p>This leads to a single question:  How is memory cleaned up when <code>X</code> constructor throws and an overloaded <code>new</code> is used?</p>\n", "Tags": "<c++><exception><new-operator><language-lawyer>", "OwnerUserId": "14768", "AnswerCount": "5"}, "19687609": {"ParentId": "19686769", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Fundamentally, if there is no <code>delete</code> operator which corresponds to the <code>new</code> operator, then nothing is done. Nothing is done also in the case of placement new, because the corresponding placement delete operator is a no-op. The exception is not diverted: it continues its course, so the caller of the new has the opportunity (and responsibility) for freeing the memory allocated.</p>\n<p>Placement new is called that because it is used to place the object in memory otherwise acquired; since the memory was not acquired by the new operator, it would be unlikely that it could be released by the delete operator. In practice, the question is moot because (since C++03, at least) it is not permitted to replace the placement new operator (which has prototype <code>operator new(size_t, void*)</code> or delete (<code>operator delete(void*, void*)</code>). The supplied placement new operator returns its second argument, and the supplied placement delete operator is a no-op.</p>\n<p>Other <code>new</code> and <code>delete</code> operators may be replaced, either globally or for a specific class. If a custom <code>new</code> operator is called, and the constructor throws an exception, and there is a corresponding <code>delete</code> operator, then that delete operator will be called to clean up before the exception is propagated. However, it is not an error if there is no corresponding <code>delete</code> operator.</p>\n", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2013-10-30T19:26:52.060", "Id": "19687609", "Score": "5", "CreationDate": "2013-10-30T15:51:01.500", "LastActivityDate": "2013-10-30T19:26:52.060"}, "bq_ids": {"n4140": {"so_19686769_19688690_2": {"section_id": 6101, "quality": 0.9354838709677419, "length": 58}, "so_19686769_19688690_4": {"section_id": 6103, "quality": 0.8571428571428571, "length": 54}, "so_19686769_19688690_3": {"section_id": 6104, "quality": 1.0, "length": 33}, "so_19686769_19688690_1": {"section_id": 7176, "quality": 0.9130434782608695, "length": 42}, "so_19686769_19688690_7": {"section_id": 7181, "quality": 1.0, "length": 17}, "so_19686769_19688690_6": {"section_id": 7180, "quality": 1.0, "length": 21}}, "n3337": {"so_19686769_19688690_2": {"section_id": 5867, "quality": 0.8709677419354839, "length": 54}, "so_19686769_19688690_4": {"section_id": 5869, "quality": 0.9682539682539683, "length": 61}, "so_19686769_19688690_3": {"section_id": 5870, "quality": 1.0, "length": 33}, "so_19686769_19688690_1": {"section_id": 6920, "quality": 0.9130434782608695, "length": 42}, "so_19686769_19688690_7": {"section_id": 6925, "quality": 1.0, "length": 17}, "so_19686769_19688690_6": {"section_id": 6924, "quality": 1.0, "length": 21}}, "n4659": {"so_19686769_19688690_4": {"section_id": 7600, "quality": 0.8253968253968254, "length": 52}, "so_19686769_19688690_2": {"section_id": 7598, "quality": 0.8709677419354839, "length": 54}, "so_19686769_19688690_7": {"section_id": 8689, "quality": 0.9411764705882353, "length": 16}, "so_19686769_19688690_1": {"section_id": 8684, "quality": 0.9130434782608695, "length": 42}, "so_19686769_19688690_3": {"section_id": 7601, "quality": 1.0, "length": 33}, "so_19686769_19688690_6": {"section_id": 8688, "quality": 1.0, "length": 21}}}, "19687632": {"ParentId": "19686769", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>'placement new' is not an overloaded version of new, but one of the variants of operator new , and also one that cannot be overloaded.</p>\n<p>See can see the list of new operators <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow\">here</a> along with a description on how overloading them works.</p>\n<p>If a constructor throws an exception when using placement new the compiler knows what new operator was used and call placement delete.</p>\n", "OwnerUserId": "617834", "LastEditorUserId": "617834", "LastEditDate": "2013-10-30T16:16:52.740", "Id": "19687632", "Score": "1", "CreationDate": "2013-10-30T15:51:53.380", "LastActivityDate": "2013-10-30T16:16:52.740"}});