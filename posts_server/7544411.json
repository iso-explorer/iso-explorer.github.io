post_cb({"bq_ids": {"n4140": {"so_7544411_7544444_2": {"length": 21, "quality": 0.875, "section_id": 6148}, "so_7544411_7544444_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 6147}, "so_7544411_7544444_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}}, "n3337": {"so_7544411_7544444_2": {"length": 21, "quality": 0.875, "section_id": 5911}, "so_7544411_7544444_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5910}, "so_7544411_7544444_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}}, "n4659": {"so_7544411_7544444_2": {"length": 21, "quality": 0.875, "section_id": 7644}, "so_7544411_7544444_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 7643}, "so_7544411_7544444_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}}}, "7544411": {"ViewCount": "243", "Body": "<p>My question is, within C++, is the following code defined?  Some of it?  And if it is, what's it supposed to do in these four scenarios?</p>\n<pre><code>word &lt;&lt;  100;\nword &gt;&gt;  100;\nword &lt;&lt; -100;\nword &gt;&gt; -100;\n</code></pre>\n<p>word is a <code>uint32_t</code></p>\n<p>(This is for a bottleneck in a 3d lighting renderer.  One of the more minor improvements in the inner most loop I wanna make is eliminating needless conditional forks.  One of those forks is checking to see if a left shift should be done on several 32 bit words as part of a hamming weight count.  If the left shift accepts absurd values, the checks don't need done at all)</p>\n", "AcceptedAnswerId": "7544444", "Title": "C++: Are left/right bitshifts for negative and large values defined?", "CreationDate": "2011-09-25T08:17:36.000", "Id": "7544411", "CommentCount": "0", "LastEditDate": "2011-09-25T08:38:10.080", "PostTypeId": "1", "LastEditorUserId": "620863", "LastActivityDate": "2011-09-25T09:13:15.607", "Score": "2", "OwnerUserId": "620863", "Tags": "<c++><bit-manipulation>", "AnswerCount": "2"}, "7544444": {"Id": "7544444", "PostTypeId": "2", "Body": "<p>In the C++0X draft N3290, \u00a75.8:</p>\n<blockquote>\n<p id=\"so_7544411_7544444_0\">The behavior is undefined if the right operand is negative,\n  or greater than or equal to the length in bits of the promoted left\n  operand.</p>\n</blockquote>\n<p>Note: the above paragraph is identical in the C++03 standard.</p>\n<p>So the last two are undefined. The others, I believe depend on whether <code>word</code> is signed or not, if <code>word</code> is at least 101bits long. If <code>word</code> is \"smaller\" than 101bits, the above applies and the behavior is undefined.</p>\n<p>Here are the next two sections of that paragraph in C++0X (these do differ in C++03):</p>\n<blockquote>\n<p id=\"so_7544411_7544444_1\">The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned\n  type, the value of the result is E1 \u00d7 2E2 , reduced modulo one more than the maximum value representable\n  in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1 \u00d7 2E2 is representable\n  in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n<p id=\"so_7544411_7544444_2\">The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed\n  type and a non-negative value, the value of the result is the integral part of the quotient of E1/2E2 . If E1\n  has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n", "LastEditorUserId": "635608", "LastActivityDate": "2011-09-25T09:13:15.607", "Score": "10", "CreationDate": "2011-09-25T08:27:51.527", "ParentId": "7544411", "CommentCount": "9", "OwnerUserId": "635608", "LastEditDate": "2011-09-25T09:13:15.607"}, "7544521": {"Id": "7544521", "PostTypeId": "2", "Body": "<p>The C standard doesn't say what should happen when shift count is negative or greater than (or even equal) to the precision of the variable.</p>\n<p>The reason is that the C standard didn't want to impose a behavior that would require extra code to be emitted in case of parametric shift. Since different CPUs do different things the standard says that anything can happen.</p>\n<p>With x86 hardware the shift operator only uses last 5 bits of the shift counter to decide the shift amount (this can be seen by reading the <a href=\"http://www.intel.com/design/intarch/manuals/243191.htm\" rel=\"nofollow noreferrer\">CPU reference manual</a>) so this is what most probably will happen with any C or C++ compiler on that platform.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/7401888/why-doesnt-left-bit-shift-for-32-bit-integers-work-as-expected-when-used/7402129#7402129\">this answer</a> for a similar question.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-25T08:45:23.780", "Score": "7", "CreationDate": "2011-09-25T08:45:23.780", "ParentId": "7544411", "CommentCount": "2", "OwnerUserId": "320726", "LastEditDate": "2017-05-23T11:45:33.953"}});