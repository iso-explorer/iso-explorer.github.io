post_cb({"26190364": {"CommentCount": "22", "AcceptedAnswerId": "26195437", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-10-04T06:37:29.097", "LastActivityDate": "2014-10-08T03:01:04.617", "LastEditDate": "2017-05-23T12:08:13.070", "ViewCount": "2752", "FavoriteCount": "16", "Title": "Is it legal for a C++ optimizer to reorder calls to clock()?", "Id": "26190364", "Score": "63", "Body": "<p><em><a href=\"http://en.wikipedia.org/wiki/The_C%2B%2B_Programming_Language\" rel=\"nofollow noreferrer\">The C++ Programming Language</a></em> 4th edition, page 225 reads: <em>A compiler may reorder code to improve performance as long as the result is identical to that of the simple order of execution</em>. Some compilers, e.g. Visual C++ in release mode, will reorder this code:</p>\n<pre><code>#include &lt;time.h&gt;\n...\nauto t0 = clock();\nauto r  = veryLongComputation();\nauto t1 = clock();\n\nstd::cout &lt;&lt; r &lt;&lt; \"  time: \" &lt;&lt; t1-t0 &lt;&lt; endl;\n</code></pre>\n<p>into this form:</p>\n<pre><code>auto t0 = clock();\nauto t1 = clock();\nauto r  = veryLongComputation();\n\nstd::cout &lt;&lt; r &lt;&lt; \"  time: \" &lt;&lt; t1-t0 &lt;&lt; endl;\n</code></pre>\n<p>which guarantees different result than original code (zero vs. greater than zero time reported). See <a href=\"https://stackoverflow.com/q/26189166/219153\">my other question</a> for detailed example. Is this behavior compliant with the C++ standard?</p>\n", "Tags": "<c++><optimization><clock>", "OwnerUserId": "219153", "AnswerCount": "7"}, "26197080": {"ParentId": "26190364", "CommentCount": "3", "Body": "<p>If <code>veryLongComputation()</code> internally performs any opaque function call, then no, because the compiler cannot guarantee that its side effects would be interchangeable with those of <code>clock()</code>.</p>\n<p>Otherwise, yes, it is interchangeable.<br>\nThis is the price you pay for using a language in which time isn't a first-class entity.</br></p>\n<p>Note that memory allocation (such as <code>new</code>) can fall in this category, as allocation function can be defined in a different translation unit and not compiled until the current translation unit is already compiled. So, if you merely allocate memory, the compiler is forced to treat the allocation and deallocation as worst-case barriers for everything -- <code>clock()</code>, memory barriers, and everything else -- unless it already has the code for the memory allocator and can prove that this is not necessary. In practice I don't think any compiler actually looks at the allocator code to try to prove this, so these types of function calls serve as barriers in practice.</p>\n", "OwnerUserId": "541686", "PostTypeId": "2", "Id": "26197080", "Score": "3", "CreationDate": "2014-10-04T20:53:14.693", "LastActivityDate": "2014-10-04T20:53:14.693"}, "26195437": {"ParentId": "26190364", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The compiler cannot exchange the two <code>clock</code> calls. <code>t1</code> must be set after <code>t0</code>. Both calls are observable side effects. The compiler may reorder anything between those observable effects, and even over an observable side effect, as long as the observations are consistent with possible observations of an abstract machine. </p>\n<p>Since the C++ abstract machine is not formally restricted to finite speeds, it could execute <code>veryLongComputation()</code> in zero time. Execution time itself is not defined as an observable effect. Real implementations may match that.</p>\n<p>Mind you, a lot of this answer depends on the C++ standard <em>not</em> imposing restrictions on compilers.</p>\n", "OwnerUserId": "15416", "LastEditorUserId": "15416", "LastEditDate": "2014-10-04T22:36:28.153", "Id": "26195437", "Score": "8", "CreationDate": "2014-10-04T17:43:53.417", "LastActivityDate": "2014-10-04T22:36:28.153"}, "26190572": {"ParentId": "26190364", "CommentCount": "9", "Body": "<p>Yes, it is legal - <strong>if</strong> the compiler can see the entirety of the code that occurs between the <code>clock()</code> calls.</p>\n", "OwnerUserId": "1405588", "PostTypeId": "2", "Id": "26190572", "Score": "7", "CreationDate": "2014-10-04T07:13:29.660", "LastActivityDate": "2014-10-04T07:13:29.660"}, "26190816": {"ParentId": "26190364", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Well, there is something called <code>Subclause 5.1.2.3 of the C Standard [ISO/IEC 9899:2011]</code> which states:</p>\n<blockquote>\n<p id=\"so_26190364_26190816_0\">In the abstract machine, all expressions are evaluated as specified by\n  the semantics. An actual implementation need not evaluate part of an\n  expression if it can deduce that its value is not used and that no\n  needed side effects are produced (including any caused by calling a\n  function or accessing a volatile object).</p>\n</blockquote>\n<p>Therefore I really suspect that <strong>this behaviour</strong> - the one you described - <strong>is compliant with the standard</strong>.</p>\n<p>Furthermore - the reorganization indeed has an impact on the computation result, but if you look at it from compiler perspective - it lives in the <code>int main()</code> world and when doing time measurements - it peeps out, asks the kernel to give it the current time, and goes back into the main world where the actual time of the outside world doesn't really matter. <strong>The clock() itself won't affect the program and variables and program behaviour won't affect that clock() function.</strong></p>\n<p>The clocks values are used to calculate difference between them - that is what you asked for. If there is something going on, between the two measuring, is not relevant from compilers perspective since what you asked for was clock difference and the code between the measuring won't affect the measuring as a process.</p>\n<p>This however doesn't change the fact that the described behaviour is very unpleasant.</p>\n<p>Even though inaccurate measurements are unpleasant, it could get much more worse and even dangerous. </p>\n<p>Consider the following code taken from <a href=\"https://www.owasp.org/index.php/Insecure_Compiler_Optimization\">this site</a>: </p>\n<pre><code>void GetData(char *MFAddr) {\n    char pwd[64];\n    if (GetPasswordFromUser(pwd, sizeof(pwd))) {\n        if (ConnectToMainframe(MFAddr, pwd)) {\n              // Interaction with mainframe\n        }\n    }\n    memset(pwd, 0, sizeof(pwd));\n}\n</code></pre>\n<p>When compiled normally, everything is OK, but if optimizations are applied, the memset call will be optimized out which may result in a serious security flaw. Why does it get optimized out? It is very simple; the compiler again thinks in its <code>main()</code> world and considers the memset to be a dead store since the variable <code>pwd</code> is not used afterwards and won't affect the program itself.</p>\n", "OwnerUserId": "1474847", "LastEditorUserId": "63550", "LastEditDate": "2014-10-05T09:21:10.513", "Id": "26190816", "Score": "16", "CreationDate": "2014-10-04T07:51:36.463", "LastActivityDate": "2014-10-05T09:21:10.513"}, "26194574": {"ParentId": "26190364", "CommentCount": "4", "Body": "<p>It is certainly <strong>not</strong> allowed, since it changes, as you have noted, the observeable behavior (different output) of the program (I won't go into the hypothetical case that <code>veryLongComputation()</code> might not consume any measurable time -- given the function's name, is presumably not the case. But even if that was the case, it wouldn't really matter). You wouldn't expect that it is allowable to reorder <code>fopen</code> and <code>fwrite</code>, would you.</p>\n<p>Both <code>t0</code> and <code>t1</code> are used in outputting <code>t1-t0</code>. Therefore, the initializer expressions for both <code>t0</code> and <code>t1</code> must be executed, and doing so must follow all standard rules. The result of the function is used, so it is not possible to optimize out the function call, though it doesn't <em>directly</em> depend on <code>t1</code> or vice versa, so one might naively be inclined to think that it's legal to move it around, why not. Maybe after the initialization of <code>t1</code>, which doesn't depend on the calculation?<br>\nIndirectly, however, the result of <code>t1</code> <strong>does of course</strong> depend on side effects by <code>veryLongComputation()</code> (notably the computation taking time, if nothing else), which is exactly one of the reasons that there exist such a thing as \"sequence point\".</br></p>\n<p>There are three \"end of expression\" sequence points (plus three \"end of function\" and \"end of initializer\" SPs), and at every sequence point it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed.<br>\nThere is no way you can keep this promise if you move around the three statements, since the possible side effects of all functions called <strong>are not known</strong>. The compiler is only allowed to optimize if it can guarantee that it will keep the promise up. It can't, since the library functions are opaque, their code isn't available (nor is the code within <code>veryLongComputation</code>, <em>necessarily</em> known in that translation unit).</br></p>\n<p>Compilers do however sometimes have \"special knowledge\" about library functions, such as some functions will not return or may return twice (think <code>exit</code> or <code>setjmp</code>).<br>\nHowever, since every non-empty, non-trivial function (and <code>veryLongComputation</code> is quite non-trivial from its name) <em>will</em> consume time, a compiler having \"special knowledge\" about the otherwise opaque <code>clock</code> library function would in fact have to be explicitly disallowed from reordering calls around this one, knowing that doing so not only may, but <em>will</em> affect the results.</br></p>\n<p>Now the interesting question is <em>why</em> does the compiler do this anyway? I can think of two possibilities. Maybe your code triggers a \"looks like benchmark\" heuristic and the compiler is trying to cheat, who knows. It wouldn't be the first time (think SPEC2000/179.art, or SunSpider for two historic examples). The other possibility would be that somewhere inside <code>veryLongComputation()</code>, you inadvertedly invoke undefined behavior. In that case, the compiler's behavior would even be legal.</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "26194574", "Score": "-1", "CreationDate": "2014-10-04T16:03:42.950", "LastActivityDate": "2014-10-04T16:03:42.950"}, "26194081": {"ParentId": "26190364", "CommentCount": "24", "Body": "<p>At least by my reading, no, this is not allowed. The requirement from the standard is (\u00a71.9/14):</p>\n<blockquote>\n<p id=\"so_26190364_26194081_0\">Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>The degree to which the compiler is free to reorder beyond that is defined by the \"as-if\" rule (\u00a71.9/1):</p>\n<blockquote>\n<p id=\"so_26190364_26194081_1\">This International Standard places no requirement on the structure of conforming implementations.\n  In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.</p>\n</blockquote>\n<p>That leaves the question of whether the behavior in question (the output written by <code>cout</code>) is officially observable behavior. The short answer is that yes, it is (\u00a71.9/8):</p>\n<blockquote>\n<p id=\"so_26190364_26194081_2\">The least requirements on a conforming implementation are:<br>\n  [...]<br>\n  \u2014 At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</br></br></p>\n</blockquote>\n<p>At least as I read it, that means the calls to <code>clock</code> could be rearranged compared to the execution of your long computation if and only if it still produced identical output to executing the calls in order. </p>\n<p>If, however, you wanted to take extra steps to ensure correct behavior, you could take advantage of one other provision (also \u00a71.9/8):</p>\n<blockquote>\n<p id=\"so_26190364_26194081_3\">\u2014 Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</p>\n</blockquote>\n<p>To take advantage of this, you'd modify your code slightly to become something like:</p>\n<pre><code>auto volatile t0 = clock();\nauto volatile r  = veryLongComputation();\nauto volatile t1 = clock();\n</code></pre>\n<p>Now, instead of having to base the conclusion on three separate sections of the standard, and still having only a <em>fairly</em> certain answer, we can look at exactly one sentence, and have an <em>absolutely</em> certain answer--with this code, re-ordering uses of <code>clock</code> vs., the long computation is <em>clearly</em> prohibited.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "26194081", "Score": "2", "CreationDate": "2014-10-04T15:07:07.643", "LastActivityDate": "2014-10-04T15:07:07.643"}, "26248559": {"ParentId": "26190364", "CommentCount": "1", "Body": "<p>Let's suppose that the sequence is in a loop, and the veryLongComputation () randomly throws an exception. Then how many t0s and t1s will be calculated? Does it pre-calculate the random variables and reorder based on the precalculation - sometimes reordering and sometimes not?</p>\n<p>Is the compiler smart enough to know that just a memory read is a read from shared memory. The read is a measure of how far the control rods have moved in a nuclear reactor. The clock calls are used to control the speed at which they are moved.</p>\n<p>Or maybe the timing is controlling the grinding of a Hubble telescope mirror. LOL</p>\n<p>Moving clock calls around seems too dangerous to leave to the decisions of compiler writers. So if it is legal, perhaps the standard is flawed.</p>\n<p>IMO.</p>\n", "OwnerUserId": "2317533", "PostTypeId": "2", "Id": "26248559", "Score": "0", "CreationDate": "2014-10-08T03:01:04.617", "LastActivityDate": "2014-10-08T03:01:04.617"}, "bq_ids": {"n4140": {"so_26190364_26194081_3": {"section_id": 5804, "quality": 1.0, "length": 9}, "so_26190364_26194081_2": {"section_id": 5804, "quality": 0.9545454545454546, "length": 21}, "so_26190364_26190816_0": {"section_id": 5797, "quality": 0.5357142857142857, "length": 15}, "so_26190364_26194081_0": {"section_id": 5810, "quality": 1.0, "length": 18}, "so_26190364_26194081_1": {"section_id": 5797, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_26190364_26194081_3": {"section_id": 5577, "quality": 1.0, "length": 9}, "so_26190364_26194081_2": {"section_id": 5577, "quality": 0.9545454545454546, "length": 21}, "so_26190364_26190816_0": {"section_id": 5570, "quality": 0.5357142857142857, "length": 15}, "so_26190364_26194081_0": {"section_id": 5583, "quality": 1.0, "length": 18}, "so_26190364_26194081_1": {"section_id": 5570, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_26190364_26194081_0": {"section_id": 7271, "quality": 1.0, "length": 18}, "so_26190364_26194081_3": {"section_id": 7262, "quality": 0.7777777777777778, "length": 7}, "so_26190364_26194081_2": {"section_id": 7262, "quality": 0.9545454545454546, "length": 21}, "so_26190364_26190816_0": {"section_id": 7256, "quality": 0.5357142857142857, "length": 15}, "so_26190364_26194081_1": {"section_id": 7256, "quality": 0.9259259259259259, "length": 25}}}});