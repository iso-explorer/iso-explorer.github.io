post_cb({"bq_ids": {"n4140": {"so_22430998_22431501_3": {"length": 4, "quality": 1.0, "section_id": 5785}, "so_22430998_22431501_6": {"length": 20, "quality": 0.9523809523809523, "section_id": 5940}}, "n3337": {"so_22430998_22431501_3": {"length": 4, "quality": 1.0, "section_id": 5558}, "so_22430998_22431501_6": {"length": 20, "quality": 0.9523809523809523, "section_id": 5711}}, "n4659": {"so_22430998_22431501_3": {"length": 4, "quality": 1.0, "section_id": 7242}, "so_22430998_22431501_6": {"length": 20, "quality": 0.9523809523809523, "section_id": 7424}}}, "22430998": {"ViewCount": "362", "Body": "<p>According to this document:</p>\n<p><a href=\"http://www.stroustrup.com/terminology.pdf\" rel=\"nofollow\">http://www.stroustrup.com/terminology.pdf</a></p>\n<ol>\n<li>l-values have identity and are not movable.</li>\n<li>pr-values are movable but don't have identity.</li>\n<li>x-values have identity and are movable.</li>\n</ol>\n<p>I have a couple of questions around these.</p>\n<p>a. What's the example of an x-value having identity? The following isn't legal:</p>\n<pre><code>Foo f;\n&amp;std::move(f);\n</code></pre>\n<p>b. I could overload the &amp;-operator of class Foo and make it return <strong>this</strong> so that the following becomes legal:</p>\n<pre><code>&amp;Foo(5);\n</code></pre>\n<p>But pr-values like Foo(5) cannot have identity. Or is there a subtler interpretation of identity?</p>\n", "AcceptedAnswerId": "22431501", "Title": "Is it correct to say that xvalues have identity and are movable?", "CreationDate": "2014-03-15T23:20:29.683", "Id": "22430998", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-15T23:28:24.763", "LastEditorUserId": "951757", "LastActivityDate": "2016-03-29T16:55:38.440", "Score": "4", "OwnerUserId": "422131", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "2"}, "36290475": {"Id": "36290475", "PostTypeId": "2", "Body": "<p>This line from Stroutrup's The C++ Programming Language might clear this question up:</p>\n<blockquote>\n<p id=\"so_22430998_36290475_0\">... std::move(vs) is an xvalue: it clearly has identity (we can refer to it as vs), but we have explicitly given permission for it to be moved from by calling std::move() (\u00a73.3.2, \u00a735.5.1).</p>\n</blockquote>\n", "LastActivityDate": "2016-03-29T16:55:38.440", "CommentCount": "0", "CreationDate": "2016-03-29T16:55:38.440", "ParentId": "22430998", "Score": "4", "OwnerUserId": "1408005"}, "22431501": {"Id": "22431501", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22430998_22431501_0\">Or is there a subtler interpretation of identity?</p>\n</blockquote>\n<p>The document you linked contains these two definitions:</p>\n<blockquote id=\"so_22430998_22431501_1\">\n<ul>\n<li>\u201chas identity\u201d \u2013 i.e. and address, a pointer, the user can determine whether two copies are \n  identical, etc. </li>\n<li>\u201ccan be moved from\u201d \u2013 i.e. we are allowed to leave to source of a \u201ccopy\u201d in some indeterminate, \n  but valid state </li>\n</ul>\n</blockquote>\n<p>Taking a look at the Standard we can gather the definition of an <em>object</em> (as per \u00a71.8/1) is:</p>\n<blockquote>\n<p id=\"so_22430998_22431501_2\">An object is a region of storage.</p>\n</blockquote>\n<p>that as per, \u00a71.7/1:</p>\n<blockquote>\n<p id=\"so_22430998_22431501_3\">Every byte has a unique address.</p>\n</blockquote>\n<p>has an <em>address</em>. This means that the definition is awfully broad and includes pretty much every object of any type of value (rvalue, xvalue, prvalue, lvalue, etc..).</p>\n<hr>\n<blockquote>\n<p id=\"so_22430998_22431501_4\">What's the example of an x-value having identity?</p>\n</blockquote>\n<p>The standard itself gives a list of expressions that generates xvalues (at \u00a75/7):</p>\n<blockquote>\n<p id=\"so_22430998_22431501_5\">An expression is an xvalue if it is:</p>\n<ul>\n<li>the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference\n  to object type,</li>\n<li>a cast to an rvalue reference to object type,</li>\n<li>a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</li>\n<li>a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</li>\n</ul>\n<p id=\"so_22430998_22431501_6\">In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether namedornot.</p>\n</blockquote>\n<p>And as a follow up few examples are given. Here's an extension to them:</p>\n<pre><code>struct A { int m; };\n\nA&amp;&amp; operator+(A, A);\nA a;\nA b;\na + b;   // xvalue\n\nA&amp;&amp; f();\nf();     // xvalue\nf().m;   // xvalue\n\nA a;\nstatic_cast&lt;A&amp;&amp;&gt;(a);  // xvalue\nstd::move(a);         // xvalue\n</code></pre>\n</hr>", "LastEditorUserId": "493122", "LastActivityDate": "2014-03-16T00:46:52.570", "Score": "4", "CreationDate": "2014-03-16T00:28:01.860", "ParentId": "22430998", "CommentCount": "3", "OwnerUserId": "493122", "LastEditDate": "2014-03-16T00:46:52.570"}});