post_cb({"bq_ids": {"n4140": {"so_34596933_34599085_1": {"section_id": 6057, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_34596933_34599085_1": {"section_id": 5825, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_34596933_34599085_1": {"section_id": 7555, "quality": 0.8695652173913043, "length": 20}}}, "34617224": {"ParentId": "34596933", "CommentCount": "0", "Body": "<p>I have actually only ever seen your first version before, so from my experience it is the more common idiom.</p>\n<p>The first version seems correct to me while the second version can result in undefined behavior if (A) you pass an actual const object to the function and (B) the <code>long code</code> writes to that object. Given that in the first case the compiler will tell you if you're trying to write to the object I would never recommend option 2 as it is. You could consider a standalone function that takes/returns const however.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "34617224", "Score": "0", "CreationDate": "2016-01-05T17:02:57.400", "LastActivityDate": "2016-01-05T17:02:57.400"}, "34596933": {"CommentCount": "17", "ViewCount": "266", "PostTypeId": "1", "LastEditorUserId": "1232841", "CreationDate": "2016-01-04T17:53:45.357", "LastActivityDate": "2016-01-05T17:02:57.400", "Title": "const and non-const versions of *static* member functions", "LastEditDate": "2016-01-04T18:13:58.670", "Id": "34596933", "Score": "8", "Body": "<p>I have two versions of the same static member function: one  takes a pointer-to-const parameter and that takes a pointer-to-non-const parameter. I want to avoid code duplication.<br>\nAfter reading some stack overflow questions (these were all about <strong>non-static</strong> member functions though) I came up with this:</br></p>\n<pre><code>class C {\nprivate:\n  static const type* func(const type* x) {\n    //long code\n  }\n\n  static type* func(type* x) {\n      return const_cast&lt;type*&gt;(func(static_cast&lt;const type*&gt;(x)));\n  }\npublic:\n  //some code that uses these functions\n};\n</code></pre>\n<p>(I know juggling with pointers is generally a bad idea, but I'm implementing a data structure.)</p>\n<p>I found some code in libstdc++ that looks like this:<br>\nNOTE: these are not member functions</br></p>\n<pre><code>static type* local_func(type* x)\n{\n  //long code\n}\n\ntype* func(type* x)\n{\n  return local_func(x);\n}\n\nconst type* func(const type* x)\n{\n  return local_func(const_cast&lt;type*&gt;(x));\n}\n</code></pre>\n<p>In the first approach the code is in a function that takes a pointer-to-const parameter.<br>\nIn the second approach the code is in a function that takes a pointer-to-non-const parameter.<br>\nWhich approach should generally be used? Are both correct?</br></br></p>\n", "Tags": "<c++><const>", "OwnerUserId": "1232841", "AnswerCount": "2"}, "34599085": {"ParentId": "34596933", "LastEditDate": "2017-05-23T10:28:18.557", "CommentCount": "3", "CreationDate": "2016-01-04T20:15:32.703", "OwnerUserId": "1908347", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "34599085", "Score": "1", "Body": "<p>The most important rule is that an interface function (public method, a free function other than one in a detail namespace, etc), should not cast away the constness of its input. Scott Meyer was one of the first to talk about preventing duplication using const_cast, here's a typical example (<a href=\"https://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func\">How do I remove code duplication between similar const and non-const member functions?</a>):</p>\n<pre><code>struct C {\n  const char &amp; get() const {\n    return c;\n  }\n  char &amp; get() {\n    return const_cast&lt;char &amp;&gt;(static_cast&lt;const C &amp;&gt;(*this).get());\n  }\n  char c;\n</code></pre>\n<p>};</p>\n<p>This refers to instance methods rather than static/free functions, but the principle is the same. You notice that the non-const version adds const to call the other method (for an instance method, the <code>this</code> pointer is the input). It then casts away constness at the end; this is safe because it knows the original input was not const.</p>\n<p>Implementing this the other way around would be extremely dangerous. If you cast <em>away</em> constness of a function parameter you receive, you are taking a big risk in UB if the object passed to you is actually const. Namely, if you call any methods that actually mutate the object (which is very easy to do by accident now that you've cast away constness), you can easily get UB:</p>\n<blockquote>\n<p id=\"so_34596933_34599085_0\">C++ standard, section \u00a7 5.2.11/7 [const cast]</p>\n<p id=\"so_34596933_34599085_1\">[ Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member resulting from a\n  const_cast that casts away a const-qualifier may produce undefined\n  behavior. \u2014end note ]</p>\n</blockquote>\n<p>It's not as bad in private methods/implementation functions because perhaps you carefully control how/when its called, but why do it this way? It's more dangerous to no benefit.</p>\n<p>Conceptually, it's often the case that when you have a const and non-const version of the same function, you are just passing along internal references of the object (<code>vector::operator[]</code> is a canonical example), and not actually mutating anything, which means that it will be safe either way you write it. But it's still more dangerous to cast away the constness of the input; although you might be unlikely to mess it up yourself, imagine a team setting where you write it the wrong way around and it works fine, and then someone changes the implementation to mutate something, giving you UB.</p>\n<p>In summary, in many cases it may not make a practical difference, but there is a correct way to do it that's strictly better than the alternative: <em>add</em> constness to the <em>input</em>, and <em>remove</em> constness from the <em>output</em>.</p>\n", "LastActivityDate": "2016-01-04T21:27:41.357"}});