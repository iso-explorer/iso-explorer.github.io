post_cb({"39668976": {"Id": "39668976", "PostTypeId": "2", "Body": "<p>It is ok, but only if you use a <code>char</code> array or an <code>unsigned char</code> array, because of the special alignment guarantees for these types:</p>\n<blockquote>\n<p id=\"so_39668561_39668976_0\"><strong>5.3.4 New</strong><br>\n  11  When a new-expression calls an allocation function and that\n  allocation has not been extended, the new- expression passes the\n  amount of space requested to the allocation function as the first\n  argument of type std::size_t. That argument shall be no less than the\n  size of the object being created; it may be greater than the size of\n  the object being created only if the object is an array. <strong>For arrays of\n  char and unsigned char</strong>, the difference between the result of the\n  new-expression and the address returned by the allocation function\n  shall be an integral multiple of the strictest fundamental alignment\n  requirement (3.11) of any object type whose size is no greater than\n  the size of the array being created. [ Note: Because allocation\n  functions are assumed to return pointers to storage that is\n  appropriately aligned for objects of any type with fundamental\n  alignment, <strong>this constraint on array allocation overhead permits the\n  common idiom of allocating character arrays into which objects of\n  other types will later be placed.</strong> \u2014 end note ]</br></p>\n</blockquote>\n<p>emphasis by me.</p>\n<p>Another requirement is that you only use primitive types or PODs, because you don't call a constructor, but the (trivial) destructor (through <code>delete</code>).</p>\n", "LastEditorUserId": "3435400", "LastActivityDate": "2016-09-23T21:09:43.157", "Score": "4", "CreationDate": "2016-09-23T20:24:47.460", "ParentId": "39668561", "CommentCount": "0", "OwnerUserId": "3435400", "LastEditDate": "2016-09-23T21:09:43.157"}, "bq_ids": {"n4140": {"so_39668561_39668976_0": {"length": 91, "quality": 0.8921568627450981, "section_id": 6092}}, "n3337": {"so_39668561_39668976_0": {"length": 84, "quality": 0.8235294117647058, "section_id": 5859}}, "n4659": {"so_39668561_39668976_0": {"length": 92, "quality": 0.9019607843137255, "section_id": 7588}}}, "39668713": {"Id": "39668713", "PostTypeId": "2", "Body": "<p>Maybe will be better to use the std vector? No need to manually free memory..</p>\n<pre><code>std::vector&lt;uint8_t&gt; vdest(n);\nuint8_t * dest = vdest.data();\n\nstd::memcpy(dest, src, n);\n\nfloat * ptr = reinterpret_cast&lt;float*&gt;(dest);\n...\n</code></pre>\n<p>EDIT:\nAs @alain pointed out: \"There is no guarantee that an array of uint8_t is properly aligned for the new type\"</p>\n<p>So if you want use this approach It will be a good idea to look this question:  <a href=\"https://stackoverflow.com/questions/19542545/is-it-good-practice-to-used-stdvector-as-a-simple-buffer\">Is it good practice to use std::vector as a simple buffer?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-24T13:03:51.707", "Score": "1", "CreationDate": "2016-09-23T20:03:37.370", "ParentId": "39668561", "CommentCount": "2", "OwnerUserId": "6869585", "LastEditDate": "2017-05-23T10:27:31.467"}, "39669359": {"Id": "39669359", "PostTypeId": "2", "Body": "<p>According to the specification of the <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow\"><code>new expression</code></a> execution of <code>new int8_t[n]</code> calls <code>operator new[](sizeof(int8_t)*n + overhead)</code>. </p>\n<p>Important note about overhead:</p>\n<blockquote>\n<p id=\"so_39668561_39669359_0\">Many implementations use the array overhead to store the number of objects in the array which is used by the delete[] expression to call the correct number of destructors. </p>\n</blockquote>\n<p>In its turn, <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow\"><code>operator new[](std::size_t count)</code></a> returns the <code>void*</code> pointer to the allocated memory block. This pointer further should be used in <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow\"><code>delete []</code></a> expression. </p>\n<p>You have simple types with no destructors, so <code>delete[]</code> only need to deallocate memory block. It can do it safely with both <code>int8_t* dest</code> or <code>float* ptr</code>.</p>\n<p><em>UPDATE</em>: \nIt's better to change array type from <code>int8_t</code> to <code>char</code> or <code>unsigned char</code>. For arrays with such types C++ standard garantees that you will get the proper aligment for further data placement. Thanks @alain. More details together with standard quote can be found in his answer.</p>\n", "LastEditorUserId": "1249472", "LastActivityDate": "2016-09-24T14:54:37.713", "Score": "2", "CreationDate": "2016-09-23T20:51:29.370", "ParentId": "39668561", "CommentCount": "4", "OwnerUserId": "1249472", "LastEditDate": "2016-09-24T14:54:37.713"}, "39668561": {"ViewCount": "591", "Body": "<p>I want to dynamically allocate known size of memory (just memory, not bothering about type) and fill it with exactly the same amount of data but any type (I'm only sure it will be primitive type). Ofc later I'm going to free it.</p>\n<p>Is it ok? :</p>\n<pre><code>auto dest = new int8_t[n];\nstd::memcpy(dest, src, n);\ndelete[] dest;\n</code></pre>\n<p><code>src</code> is ptr to an array of size <code>n</code> (Bytes). \nI've ofc chosen <code>int8_t</code> becuase it's the clearest way to allocate certain amount of memory. \nIn fact the code above isn't exaclt what it will be. <code>delete[]</code> will be called on pointer of type which <strong>actually</strong> it points to.\nSo for example if src was an array of floats (forget about last line of above code):</p>\n<pre><code>float * ptr = dest;\ndelete[] ptr;\n</code></pre>\n<p>So again. Will it be ok?</p>\n", "Title": "Allocate n bytes by new[] and fill it with any type?", "CreationDate": "2016-09-23T19:53:10.877", "LastActivityDate": "2016-09-24T14:54:37.713", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "Id": "39668561", "Score": "9", "OwnerUserId": "5538150", "Tags": "<c++><memory>", "AnswerCount": "3"}});