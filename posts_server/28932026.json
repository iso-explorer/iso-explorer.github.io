post_cb({"28932026": {"CommentCount": "0", "ViewCount": "110", "CreationDate": "2015-03-08T21:20:01.880", "LastActivityDate": "2015-03-12T21:42:23.377", "Title": "Where in the C++ Standard the lookup for an unqualified *mem-initializer-id* is defined?", "AcceptedAnswerId": "28932420", "PostTypeId": "1", "Id": "28932026", "Score": "2", "Body": "<p>This is the very first sentence in \u00a712.6.2/2 (C++14):</p>\n<blockquote>\n<p id=\"so_28932026_28932026_0\">In a <em>mem-initializer-id</em> an initial unqualified identifier is looked\n  up in the scope of the constructor\u2019s class and, if not found in that\n  scope, it is looked up in the scope containing the constructor\u2019s\n  definition.</p>\n</blockquote>\n<p>I would like to know where, in <strong>\u00a73.4.1 Unqualified Name Lookup</strong>, is the lookup mentioned above (\"in the scope of the constructor's class\") defined? If it's not there, where can I find this definition in the spec?</p>\n<p>My first guess was \u00a73.4.1/7 but I don't think that is correct, because a non-static data member of the constructor's class, which is initialized in a <em>mem-initializer-id</em>, doesn't seem to fit the conditions imposed in the 4 bullet points in this paragraph.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "2548699", "AnswerCount": "2"}, "28932231": {"ParentId": "28932026", "CommentCount": "0", "CreationDate": "2015-03-08T21:42:19.560", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "28932231", "Score": "0", "Body": "<p>It's a bit of a disappointing answer, and I welcome an answer that proves me wrong, but I don't think it's there.</p>\n<p>3.4 starts as (emphasis mine):</p>\n<blockquote>\n<p id=\"so_28932026_28932231_0\"><strong>3.4 Name lookup [basic.lookup]</strong></p>\n<p id=\"so_28932026_28932231_1\">The name lookup rules apply uniformly to all names (including <em>typedef-names</em> (7.1.3), <em>namespace-names</em> (7.3), and <em>class-names</em> (9.1)) <strong>wherever the grammar allows such names in the context discussed by a particular rule</strong>. [...]</p>\n</blockquote>\n<p>If 12.6.2 says an unqualified identifier is not looked up according to the ordinary unqualified name lookup rules in that context, if 12.6.2 says an unqualified identifier in that context gets different lookup rules, then it isn't necessary for 3.4 to explicitly exclude that context, because it's already implicitly excluded.</p>\n<p>There is a note in 3.4.1p11 that refers back to 12.6.2, but it only covers the expressions used in a constructor initialisation list, not the members.</p>\n", "LastActivityDate": "2015-03-08T21:42:19.560"}, "28932420": {"ParentId": "28932026", "PostTypeId": "2", "CommentCount": "19", "CreationDate": "2015-03-08T21:59:38.143", "Score": "2", "LastEditorUserId": "103167", "LastEditDate": "2015-03-12T21:42:23.377", "Id": "28932420", "OwnerUserId": "103167", "Body": "<p>It is 3.4.1/8.  What you have probably missed is that the <em>mem-initializer-list</em> is part of the function body for the constructor.  See the grammar production for <em>function-body</em>:</p>\n<blockquote>\n<p id=\"so_28932026_28932420_0\"><em>function-body</em>:</p>\n<ul>\n<li><p id=\"so_28932026_28932420_1\"><em>ctor-initializer</em><sub>opt</sub> <em>compound-statement</em></p></li>\n<li><p id=\"so_28932026_28932420_2\"><em>function-try-block</em></p></li>\n<li><p id=\"so_28932026_28932420_3\"><code>=  default  ;</code></p></li>\n<li><p id=\"so_28932026_28932420_4\"><code>=  delete  ;</code></p></li>\n</ul>\n</blockquote>\n<p>It then follows from 3.3.7/1 that this is in the potential scope of all class members, including those whose point of definition comes after the constructor definition.</p>\n<blockquote>\n<p id=\"so_28932026_28932420_5\">The potential scope of a name declared in a class consists not only of the declarative region following the name\u2019s point of declaration, but also of all function bodies, default arguments, <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> of non-static data members in that class (including such things in nested classes).</p>\n</blockquote>\n", "LastActivityDate": "2015-03-12T21:42:23.377"}, "bq_ids": {"n4140": {"so_28932026_28932026_0": {"section_id": 429, "quality": 1.0, "length": 15}, "so_28932026_28932420_5": {"section_id": 7070, "quality": 0.967741935483871, "length": 30}, "so_28932026_28932231_1": {"section_id": 7083, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_28932026_28932026_0": {"section_id": 421, "quality": 1.0, "length": 15}, "so_28932026_28932420_5": {"section_id": 6814, "quality": 0.8709677419354839, "length": 27}, "so_28932026_28932231_1": {"section_id": 6827, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_28932026_28932026_0": {"section_id": 447, "quality": 1.0, "length": 15}, "so_28932026_28932420_5": {"section_id": 8567, "quality": 0.9354838709677419, "length": 29}, "so_28932026_28932231_1": {"section_id": 8584, "quality": 0.9090909090909091, "length": 20}}}});