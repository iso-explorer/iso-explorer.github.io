post_cb({"bq_ids": {"n4140": {"so_18570632_18571345_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 241}, "so_18570632_18571345_0": {"length": 34, "quality": 0.918918918918919, "section_id": 233}}, "n3337": {"so_18570632_18571345_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 233}, "so_18570632_18571345_0": {"length": 34, "quality": 0.918918918918919, "section_id": 226}}, "n4659": {"so_18570632_18571345_0": {"length": 34, "quality": 0.918918918918919, "section_id": 243}}}, "18571345": {"Id": "18571345", "PostTypeId": "2", "Body": "<p>If the compiler implicitly instantiates a class template that contains static members, those static members are not implicitly instantiated. The compiler will instantiate a static member only when the compiler needs the static member's definition.</p>\n<p>This behaviour is backed by the C++ standard and here is the passage</p>\n<blockquote>\n<p id=\"so_18570632_18571345_0\">14.7.1p1 ... The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations,\n  but not of the definitions or default arguments, of the class member\n  functions, member classes, scoped member enumerations, static\n  dataembers and member templates; and it causes the implicit\n  instantiation of the definitions of unscoped member enumerations and\n  member anonymous unions.</p>\n</blockquote>\n<p>and another relevant section found by @gx_</p>\n<blockquote>\n<p id=\"so_18570632_18571345_1\">14.7.1p8 The implicit instantiation of a class template does not cause any static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<p>A work around is the one mentioned by @gx_: Simply add</p>\n<pre><code>         ExportToLua() { (void)&amp;m_registered; }\n</code></pre>\n<p>to the constructor. Taking the address forces the instantiation of the static variable m_registered.</p>\n", "LastEditorUserId": "944786", "LastActivityDate": "2013-09-02T11:16:21.210", "Score": "4", "CreationDate": "2013-09-02T10:45:56.697", "ParentId": "18570632", "CommentCount": "3", "OwnerUserId": "944786", "LastEditDate": "2013-09-02T11:16:21.210"}, "18570632": {"ViewCount": "1953", "Body": "<p>Currently I am working on a C++ project in which I plan to embed Lua scripts. For that reason certain classes need to be exported to Lua and I wanted to make this more convenient therefore I created a template class:</p>\n<pre><code>template &lt;class T&gt;\nclass ExportToLua {\n    public:\n        ExportToLua() {}\n        ~ExportToLua() {}\n    private:\n        static int m_registered;\n};\ntemplate &lt;class T&gt; int ExportToLua&lt;T&gt;::m_registered = T::exportToLua();\n</code></pre>\n<p>Now every class that needs to be exported is derived from <code>ExportToLua&lt;T&gt;</code> with <code>T</code>=\"the class to be exported\". Example:</p>\n<pre><code> class Example: public ExportToLua&lt;Example&gt; {\n public:\n     Example();\n     virtual ~Example();\n     static int exportToLua();\n private:\n };\n</code></pre>\n<p>where <code>Example</code>'s static member function <code>exportToLua()</code> holds the class-specific registration code. My understanding is that an instance of the static member variable <code>ExportToLua&lt;T&gt;::m_registered</code> exists for every compile unit - that is - for every <code>T</code>.</p>\n<p>But when I start my program the registration code never gets called. For example in example.cpp:</p>\n<pre><code> int Example::exportToLua() {\n     std::cout &lt;&lt; \"int Example::exportToLua()\" &lt;&lt; std::endl;\n     return -2;\n }\n</code></pre>\n<p>however I never see this message when I run my program.</p>\n<p>Any idea why? Is the compiler some \"optimizing away\" the static variable <code>m_registered</code>, because I am not using it anywhere?</p>\n<p>Thanks for your input,</p>\n<p>Best,\nChristoph</p>\n", "AcceptedAnswerId": "18571351", "Title": "Implicit initialization of static member variables for template classes", "CreationDate": "2013-09-02T10:09:45.777", "Id": "18570632", "CommentCount": "17", "LastEditDate": "2013-09-02T11:17:47.060", "PostTypeId": "1", "LastEditorUserId": "944786", "LastActivityDate": "2013-09-03T22:10:29.640", "Score": "6", "OwnerUserId": "944786", "Tags": "<c++><templates><inheritance><static-members>", "AnswerCount": "2"}, "18571351": {"Id": "18571351", "PostTypeId": "2", "Body": "<p>You already found the reason in the standard why the behavior is the way it is. So as a workaround, you can 'trick' the compiler into instantiating that static member by referencing it from either the template constructor or destructor.</p>\n<pre><code>#define FORCE_INSTANTIATE(x) (x)\n// or (avoids -Wall and -pedantic warnings)\n// template &lt;typename T&gt; inline void FORCE_INSTANTIATE(T) {}\n\ntemplate &lt;class T&gt;\nclass ExportToLua\n{\n  public:\n    ExportToLua() {}\n    virtual ~ExportToLua() { FORCE_INSTANTIATE(m_registered); }\n  private:\n      static int m_registered;\n};\n</code></pre>\n<p>It seems to work in <strong><a href=\"http://ideone.com/MutzOf\" rel=\"nofollow\">this demo</a></strong>.</p>\n<p><strong>Edit:</strong> As DyP correctly pointed out, the <em>One-Defintion-Rule</em> comes into play here in whether <code>ExportToLua&lt;T&gt;::m_registered</code> gets instantiated or not.</p>\n<p>To guarantee implicit instantiation, make sure you meet at least one of the following conditions:</p>\n<ul>\n<li>Provide a <em>definition</em> for either the constructor or destructor of the class that's to be exported.</li>\n<li>You create an instance of that class that's used elsewhere in other parts of your code. This will force the compiler to provide a default ctor if you didn't provide one thereby triggering the necessary template instantiations.</li>\n</ul>\n<p>If none of those conditions can be met for whatever reason then you'll need to explicitly instantiate the members you want from the template. For example,</p>\n<pre><code>class Example: public ExportToLua&lt;Example&gt;\n{\npublic:\n  // ...\n  static int exportToLua();\n  // etc.\n};\ntemplate int ExportToLua&lt;Example&gt;::m_registered;\n</code></pre>\n<p>You can wrap that into a macro to make it nicer to use if desired.</p>\n", "LastEditorUserId": "234175", "LastActivityDate": "2013-09-03T22:10:29.640", "Score": "3", "CreationDate": "2013-09-02T10:46:11.437", "ParentId": "18570632", "CommentCount": "28", "OwnerUserId": "234175", "LastEditDate": "2013-09-03T22:10:29.640"}});