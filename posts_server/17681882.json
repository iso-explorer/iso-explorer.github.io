post_cb({"17687578": {"ParentId": "17681882", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The standard requires the <strong>default-constructed</strong> <code>std::ctype&lt;char&gt;</code> to match the minimal \"C\" locale via <code>\u00a722.4.1.3.3[facet.ctype.char.statics]/1</code></p>\n<blockquote>\n<p id=\"so_17681882_17687578_0\"><code>static const mask* classic_table() noexcept;</code></p>\n<p id=\"so_17681882_17687578_1\"><em>Returns:</em> A pointer to the initial element of an array of size <code>table_size</code> which represents the classifications of characters in the \"C\" locale</p>\n</blockquote>\n<p>the classification member function <code>is()</code> is defined in terms of <code>table()</code> which is defined in terms of <code>classic_table()</code> unless another table was provided to the <code>ctype&lt;char&gt;</code>'s constructor</p>\n<p>I've updated cppreference to match these requirements more properly (it was saying \"C\" for <code>std::ctype&lt;wchar_t&gt;</code> too)</p>\n<p>To answer your second question, the locale constructed with <code>std::locale loc(std::locale(\"en_US.UTF8\"), new std::ctype&lt;char&gt;);</code> will use the ctype facet you specified (and, therefore, \"C\") to classify narrow characters, but it's redundant: narrow character classification of a plain <code>std::locale(\"en_US.UTF8\")</code> (at least in GNU implementation) is exactly the same:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;locale&gt;\nint main()\n{\n\n    std::locale loc1(\"en_US.UTF8\");\n    const std::ctype_base::mask* tbl1 =\n         std::use_facet&lt;std::ctype&lt;char&gt;&gt;(loc1).table();\n\n    std::locale loc2(std::locale(\"en_US.UTF8\"), new std::ctype&lt;char&gt;);\n    const std::ctype_base::mask* tbl2 =\n         std::use_facet&lt;std::ctype&lt;char&gt;&gt;(loc2).table();\n\n    for(size_t n = 0; n &lt; 256; ++n)\n        assert(tbl1[n] == tbl2[n]);\n}\n</code></pre>\n", "OwnerUserId": "273767", "LastEditorUserId": "273767", "LastEditDate": "2013-07-16T22:01:12.723", "Id": "17687578", "Score": "2", "CreationDate": "2013-07-16T21:45:45.550", "LastActivityDate": "2013-07-16T22:01:12.723"}, "bq_ids": {"n4140": {"so_17681882_17682059_2": {"section_id": 6419, "quality": 1.0, "length": 5}, "so_17681882_17682059_3": {"section_id": 6420, "quality": 0.7631578947368421, "length": 29}, "so_17681882_17687578_1": {"section_id": 6504, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_17681882_17682059_2": {"section_id": 6176, "quality": 1.0, "length": 5}, "so_17681882_17682059_3": {"section_id": 6177, "quality": 0.7631578947368421, "length": 29}, "so_17681882_17687578_1": {"section_id": 6259, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_17681882_17682059_2": {"section_id": 7931, "quality": 1.0, "length": 5}, "so_17681882_17682059_3": {"section_id": 7932, "quality": 0.7894736842105263, "length": 30}, "so_17681882_17687578_1": {"section_id": 7986, "quality": 0.9090909090909091, "length": 10}}}, "17681882": {"CommentCount": "0", "ViewCount": "702", "PostTypeId": "1", "LastEditorUserId": "1594090", "CreationDate": "2013-07-16T16:19:28.230", "LastActivityDate": "2013-07-16T22:01:12.723", "Title": "Does std::ctype always classify characters by the \"C\" locale?", "AcceptedAnswerId": "17687578", "LastEditDate": "2013-07-16T16:51:14.917", "Id": "17681882", "Score": "5", "Body": "<p>cppreference says <code>std::ctype</code> provides character classification based on the classic \"C\" locale. Is this even true when we create a locale like this:</p>\n<pre><code>std::locale loc(std::locale(\"en_US.UTF8\"), new std::ctype&lt;char&gt;);\n</code></pre>\n<p>Will the facet of <code>loc</code> still classify characters based on the \"C\" locale or the Unicode one? If it classifies by the former, why do we even specify the locale name as \"en_US.UTF8\"?</p>\n", "Tags": "<c++><unicode><character-encoding><locale>", "OwnerUserId": "1594090", "AnswerCount": "3"}, "17682059": {"ParentId": "17681882", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In C, the C locale applies until you change the locale with <code>setlocale()</code> from <code>&lt;locale.h&gt;</code>.  The same is likely true of C++, though you also probably have other mechanisms for setting the locale.</p>\n<p>Your statement appears to create a locale; it is not clear that it makes that locale into the default locale, though.  That locale can then be used to specify the comparison:</p>\n<p>ISO/IEC 14882:2011 (the C++ 2011 standard) has section 22.3 entitled <strong>Locales</strong>.  It says, in part:</p>\n<pre><code>// 22.3.3, convenience interfaces:\ntemplate &lt;class charT&gt; bool isspace (charT c, const locale&amp; loc);\ntemplate &lt;class charT&gt; bool isprint (charT c, const locale&amp; loc);\n</code></pre>\n<p>Also, a little later in the standard, it says:</p>\n<blockquote>\n<p id=\"so_17681882_17682059_0\"><strong>22.3.1.5 <code>locale</code> static members [locale.statics]</strong></p>\n<p id=\"so_17681882_17682059_1\"><code>static locale global(const locale&amp; loc);</code></p>\n<p id=\"so_17681882_17682059_2\">1 Sets the global locale to its argument.</p>\n<p id=\"so_17681882_17682059_3\">2 <em>Effects:</em> Causes future calls to the constructor locale() to return a copy of the argument. If the\n     argument has a name, does\n  <code>std::setlocale(LC_ALL, loc.name().c_str());</code>\n  otherwise, the effect on the C locale, if any, is implementation-defined. No library function other\n  than <code>locale::global()</code> shall affect the value returned by <code>locale()</code>. [ <em>Note:</em> See 22.6 for data race\n  considerations when <code>setlocale</code> is invoked. \u2014 <em>end note</em> ]</p>\n<p id=\"so_17681882_17682059_4\">3 <em>Returns:</em> The previous value of <code>locale()</code>.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_17681882_17682059_5\">So I have to change the global locale before running the above line if I want <code>std::ctype</code> to classify based on \"en_US.UTF8\"?</p>\n</blockquote>\n<p>What I read from the initial quote is that, given your <code>loc</code> you could write:</p>\n<pre><code>if (isspace(ch, loc)) { ... }\n</code></pre>\n<p>specifying the locale to be used explicitly.  If you don't want to do that, then you need to call <code>std::locale::global(loc)</code> to set the global locale, so unadorned invocations of <code>isspace()</code> will work:</p>\n<pre><code>if (isspace(ch)) { ... }\n</code></pre>\n</hr>", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2013-07-16T16:36:26.520", "Id": "17682059", "Score": "0", "CreationDate": "2013-07-16T16:28:20.893", "LastActivityDate": "2013-07-16T16:36:26.520"}, "17682140": {"ParentId": "17681882", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>From what I read in the working draft I have for C++11 N3376 \u00a722.4.1.1, <code>std::ctype&lt;char&gt;</code> is supposed to do this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Class ctype encapsulates the C library &lt;cctype&gt; features. istream members \nare required to use ctype&lt;&gt; for character classing during input parsing.\n\nThe specializations required in Table 81 (22.3.1.1.1), namely ctype&lt;char&gt; and \nctype&lt;wchar_t&gt;, implement character classing appropriate to the \nimplementation\u2019s native character set.\n</code></pre>\n<p>It has no mention of the C locale anywhere in there, chances are cppreference might be referring to the functions found in <code>&lt;cctype&gt;</code>.</p>\n", "OwnerUserId": "1381108", "LastEditorUserId": "1381108", "LastEditDate": "2013-07-16T16:37:34.973", "Id": "17682140", "Score": "1", "CreationDate": "2013-07-16T16:31:53.717", "LastActivityDate": "2013-07-16T16:37:34.973"}});