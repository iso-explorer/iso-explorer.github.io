post_cb({"bq_ids": {"n4140": {"so_27972087_27972412_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6300}}, "n3337": {"so_27972087_27972412_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6057}}, "n4659": {"so_27972087_27972412_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7809}}}, "27972087": {"ViewCount": "81", "Body": "<p>Is it possible to provide a custom definition of one of the methods of a template class.  Or is it all or nothing, meaning either I have to use all the provided definitions  as is or I have to create / define template specialization of the whole class.</p>\n<p>I am writing some test code to better understand writing a custom allocator.  I want to provide a custom definition of allocator::allocate().   Do I have to forward declare allocator.  Or do I have the prototype of allocate() wrong?  Or do I have to provide template specialization for allocator just so I can provide my own definition of allocate().</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;&gt;\nstd::allocator&lt;int&gt;::pointer \nstd::allocator&lt;int&gt;::allocate(size_type n, std::allocator&lt;void&gt;::const_pointer hint)\n{\n    cout &lt;&lt; \"Doing an alloc for an int allocator\" &lt;&lt; endl;\n    return nullptr;\n}\n\nint main()\n{\n    std::allocator&lt;int&gt; a1; // default allocator for ints\n    int* a = a1.allocate(10); // space for 10 ints\n}\n</code></pre>\n<p>Getting the following error:</p>\n<pre><code>$ g++ -std=c++11 ./t1.cc\n./t1.cc:6:78: error: no member function 'allocate' declared in 'std::allocator&lt;int&gt;'\n</code></pre>\n<p>I am using g++ 4.7.2.  I looked into the header file \"bits/allocator.h\" (included from \"memory\" where class allocator is defined.  Not seeing the method allocate().  Is the method prototype in one of the base class?</p>\n", "Title": "Provide definition of one method of a template class", "CreationDate": "2015-01-15T20:07:32.907", "LastActivityDate": "2015-01-15T20:30:44.113", "CommentCount": "2", "LastEditDate": "2015-01-15T20:30:44.113", "PostTypeId": "1", "LastEditorUserId": "241631", "Id": "27972087", "Score": "0", "OwnerUserId": "1348939", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}, "27972412": {"Id": "27972412", "PostTypeId": "2", "Body": "<p>Looking through the libstdc++ headers shipped with MinGW g++4.9, the definition of the <code>allocate</code> member function is present in the class <code>new_allocator</code> which is defined in the header <code>ext/new_allocator.h</code>. <code>std::allocator</code> publicly inherits from <code>new_allocator</code>.</p>\n<p>Had libstdc++ chosen to define <code>allocate</code> as a member function of <code>std::allocator</code> itself, your code would've compiled (it compiles on VS2013 because that implementation of <code>std::allocator</code> does define the <code>allocate</code> member function), but even so, it would be undefined behavior.</p>\n<p>From N3337, <em>\u00a717.6.4.2.1/2</em> <strong>[namespace.std]</strong></p>\n<blockquote>\n<p id=\"so_27972087_27972412_0\">The behavior of a C++ program is undefined if it declares<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 an explicit specialization of any member function of a standard library class template, or<br/>\n<code>...</code></p>\n</blockquote>\n<p>You'll need to provide your own allocator implementation if you want to customize the behavior.</p>\n", "LastActivityDate": "2015-01-15T20:29:42.373", "CommentCount": "4", "CreationDate": "2015-01-15T20:29:42.373", "ParentId": "27972087", "Score": "0", "OwnerUserId": "241631"}, "27972395": {"Id": "27972395", "PostTypeId": "2", "Body": "<p>That's because in gcc, <code>allocator</code> is defined thusly:</p>\n<pre><code>template&lt;typename _Tp&gt;\nclass allocator: public __glibcxx_base_allocator&lt;_Tp&gt;\n{ .. };\n</code></pre>\n<p>Where the <code>allocate()</code> method itself comes from <code>__glibcxx_base_allocator</code>. Now that base is, a few lines later, just removed:</p>\n<pre><code>// Undefine.\n#undef __glibcxx_base_allocator\n</code></pre>\n<p>as discouragement to prevent people like you from mucking around in the code!</p>\n<p>But, and let me preface this with <strong>DO NOT DO THIS EVER OMG</strong>, in the interest of mucking about, you can find that <code>__glibcxx_base_allocator</code> is <code>#define</code>d as <code>__gnu_cxx::new_allocator</code>, and you can use that knowledge to specialize your function thusly (note that it has to be in the same namespace as the original template - per specialization rules):</p>\n<pre><code>namespace __gnu_cxx {\n\n    template &lt;&gt;\n    new_allocator&lt;int&gt;::pointer\n    new_allocator&lt;int&gt;::allocate(\n        new_allocator&lt;int&gt;::size_type n,\n        std::allocator&lt;void&gt;::const_pointer hint)\n    {\n        std::cout &lt;&lt; \"Doing an alloc for an int allocator\" &lt;&lt; std::endl;\n        return nullptr;\n    }\n\n}\n</code></pre>\n<p>I really cannot stress enough to <strong>NOT DO THIS</strong>. But it was fun to track down. </p>\n", "LastActivityDate": "2015-01-15T20:28:14.203", "CommentCount": "1", "CreationDate": "2015-01-15T20:28:14.203", "ParentId": "27972087", "Score": "0", "OwnerUserId": "2069064"}});