post_cb({"bq_ids": {"n4140": {"so_40811399_40811706_1": {"length": 5, "quality": 1.0, "section_id": 2707}, "so_40811399_40811706_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 2711}}, "n3337": {"so_40811399_40811706_1": {"length": 5, "quality": 1.0, "section_id": 2669}, "so_40811399_40811706_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 2672}}, "n4659": {"so_40811399_40811706_1": {"length": 5, "quality": 1.0, "section_id": 3447}, "so_40811399_40811706_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 3451}}}, "40811399": {"ViewCount": "39", "Body": "<p>If I have one thread, the \"main\" thread, initialize a global variable and that thread later spawns some threads that access that variable, do I need to do any work, such as a call to std::atomic_thread_fence(memory_order_seq_cst), to guarantee that the variable appears initialized to the new threads? I suspect that the fact that the main thread creates the new threads establishes a \"synchronized-with\" relationship that is sufficient to prevent any races, but I'm not certain.</p>\n<p>Here's some pseudocode for what I'm describing:</p>\n<pre><code>class MyApi {\npublic:\n    static void init(Foo *foo) {\n        MyApi::foo = foo;\n    }\n\n    static Foo* getSharedFoo() {\n        return foo;\n    }\n\nprivate:\n    static Foo* foo;\n};\n\nvoid main() {\n    Foo* foo = new Foo();\n    MyApi::init(foo);\n    // Spawn threads that will call MyApi::getSharedFoo() and expect\n    // to receive the same foo that is created above.\n}\n</code></pre>\n", "AcceptedAnswerId": "40811475", "Title": "C++ memory semantics and globals that are set at the start of a program", "CreationDate": "2016-11-25T19:36:53.810", "Id": "40811399", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-11-25T20:09:48.943", "Score": "3", "OwnerUserId": "5405070", "Tags": "<c++><multithreading>", "AnswerCount": "2"}, "40811706": {"Id": "40811706", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40811399_40811706_0\">30.3.1.2 thread constructors</p>\n<p id=\"so_40811399_40811706_1\">[ ... ] template  explicit thread(F&amp;&amp; f,\n  Args&amp;&amp;... args);</p>\n<p id=\"so_40811399_40811706_2\">[ ... ]</p>\n<p id=\"so_40811399_40811706_3\">Synchronization: The completion of the invocation of the constructor\n  synchronizes with the beginning of the invocation of the copy of f.</p>\n</blockquote>\n<p>This specifies that <code>f</code> sees everything that occurred prior to the construction of the <code>std::thread</code> object that spawned the thread.</p>\n", "LastActivityDate": "2016-11-25T20:09:48.943", "CommentCount": "0", "CreationDate": "2016-11-25T20:09:48.943", "ParentId": "40811399", "Score": "0", "OwnerUserId": "3943312"}, "40811475": {"Id": "40811475", "PostTypeId": "2", "Body": "<p>No, you don't have to do anything special. New threads see all memory changes up to the point where they were constructed.</p>\n", "LastActivityDate": "2016-11-25T19:44:10.653", "CommentCount": "0", "CreationDate": "2016-11-25T19:44:10.653", "ParentId": "40811399", "Score": "2", "OwnerUserId": "1593860"}});