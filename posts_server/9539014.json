post_cb({"bq_ids": {"n4140": {"so_9539014_9539344_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 1401}}, "n3337": {"so_9539014_9539344_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 1395}}, "n4659": {"so_9539014_9539344_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 1518}}}, "9539706": {"Id": "9539706", "PostTypeId": "2", "Body": "<p>I'm posting this as an answer because I don't have reputation to comment.</p>\n<p>As @FredOverflow pointed out, libstdc++ uses move constructors and assignment operators when sorting. However, I find it strange that it doesn't use ADL for pre c++11 code so people can plug optimized swapping functions.</p>\n", "LastActivityDate": "2012-03-02T20:10:07.347", "CommentCount": "8", "CreationDate": "2012-03-02T20:10:07.347", "ParentId": "9539014", "Score": "6", "OwnerUserId": "643370"}, "9539014": {"ViewCount": "437", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct A {\n   int val;\n\n   bool operator&lt;(const A&amp; other) const {\n      std::cout &lt;&lt; \"operator\\n\";\n      return val &lt; other.val;\n   }\n};\n\nvoid swap(A&amp; a, A&amp; b) {\n   std::cout &lt;&lt; \"foo\\n\";\n   std::swap(a.val, b.val);\n}\n\nint main()\n{\n   std::vector&lt;A&gt; a(2);\n   a[0].val = 10;\n   a[1].val = -1;\n\n   std::sort(a.begin(), a.end());\n}\n</code></pre>\n<p>C++11's <code>std::sort</code> places <em>ValueSwappable</em> requirements on the iterator arguments, move semantics and nothing else, implying that <code>std::sort</code> is \"guaranteed\" to perform a swap if elements need to be moved around. And <code>17.6.3.2/3</code> suggests that my overload definitely ought to be picked in this case.</p>\n<ul>\n<li>Is this correct?</li>\n</ul>\n<p>clang 3.1 SVN's libc++ picks my <code>swap</code> (that is, I see \"foo\"); GCC 4.6.3's libstdc++ does not.</p>\n<ul>\n<li>Is this a GCC bug (assuming my standard interpretation is correct)? Or am I missing something?</li>\n</ul>\n", "AcceptedAnswerId": "9539344", "Title": "Is my `swap` overload supposed to be used? Is this a libstdc++ (GCC) bug?", "CreationDate": "2012-03-02T19:13:18.690", "Id": "9539014", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2012-03-02T20:10:07.347", "Score": "2", "OwnerUserId": "560648", "Tags": "<c++><gcc><clang><std>", "AnswerCount": "2"}, "9539344": {"Id": "9539344", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9539014_9539344_0\">C++11's <code>std::sort</code> places <em>ValueSwappable</em> requirements on the iterator arguments, move semantics and nothing else, <strong>implying that <code>std::sort</code> is \"guaranteed\" to perform a swap if elements need to be moved around</strong>.</p>\n</blockquote>\n<p>I don't see that guarantee. Who says <code>std::sort</code> cannot use move semantics instead of swaps? In fact, after browsing the standard for the verbatim specification, I believe this is exactly what happens:</p>\n<blockquote>\n<p id=\"so_9539014_9539344_1\">Requires: <code>RandomAccessIterator</code> shall satisfy the requirements of <code>ValueSwappable</code> (17.6.3.2). <strong>The type of <code>*first</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 20) and of <code>MoveAssignable</code> (Table 22).</strong></p>\n</blockquote>\n<p>Note that the <em>iterators</em> shall be <code>ValueSwappable</code>, not the elements they point to.</p>\n", "LastEditorUserId": "252000", "LastActivityDate": "2012-03-02T19:45:11.553", "Score": "6", "CreationDate": "2012-03-02T19:39:57.563", "ParentId": "9539014", "CommentCount": "8", "OwnerUserId": "252000", "LastEditDate": "2012-03-02T19:45:11.553"}});