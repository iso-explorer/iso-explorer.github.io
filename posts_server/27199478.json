post_cb({"27199571": {"ParentId": "27199478", "PostTypeId": "2", "CommentCount": "11", "Body": "<p><code>decltype({1, 2})</code> is illegal, however, the type of <code>a</code> has already been deduced. From the <em>closest</em> draft to the C++11 standard, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a>:</p>\n<p>\u00a77.1.6.4/6</p>\n<blockquote>\n<p id=\"so_27199478_27199571_0\">Once the type of a <em>declarator-id</em> has been determined according to\n  8.3, the type of the declared variable using the <em>declarator-id</em> is determined from the type of its initializer using the rules for\n  template argument deduction. Let <code>T</code> be the type that has been\n  determined for a variable identifier <code>d</code>. Obtain <code>P</code> from <code>T</code> by\n  replacing the occurrences of <code>auto</code> with either a new invented type\n  template parameter <code>U</code> or, if the initializer is a <em>braced-init-list</em>\n  (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>. The type deduced for the\n  variable <code>d</code> is then the deduced <code>A</code> determined using the rules of\n  template argument deduction from a function call (14.8.2.1), where <code>P</code>\n  is a function template parameter type and the initializer for <code>d</code> is\n  the corresponding argument. If the deduction fails, the declaration is\n  ill-formed. [ <em>Example:</em></p>\n<pre><code>auto x1 = { 1, 2 };   // decltype(x1) is std::initializer_list&lt;int&gt;\nauto x2 = { 1, 2.0 }; // error: cannot deduce element type\n</code></pre>\n<p id=\"so_27199478_27199571_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>In the context of your question, the <em>braced-init-list</em> is deduced to be an <code>std::initializer_list&lt;int&gt;</code>, and subsequently, <code>decltype(a)</code> yields the same type. </p>\n", "Id": "27199571", "LastEditDate": "2014-11-29T07:00:34.460", "OwnerDisplayName": "user3920237", "Score": "3", "CreationDate": "2014-11-29T06:27:35.940", "LastActivityDate": "2014-11-29T07:00:34.460", "LastEditorDisplayName": "user3920237"}, "27199584": {"ParentId": "27199478", "CommentCount": "0", "Body": "<p>From the c++ Standard (7.1.6.4 auto specifier)</p>\n<blockquote>\n<p id=\"so_27199478_27199584_0\">7....If the placeholder is the auto type-specifier, the deduced type is determined using the rules for template argument deduction. If the\n  deduction is for a return statement and the initializer is a\n  braced-init-list (8.5.4), the program is ill-formed. Otherwise, obtain\n  P from T by replacing the occurrences of auto with either a new\n  invented type template parameter U or, if the initializer is a\n  <strong>braced-init-list, with std::initializer_list</strong>. Deduce a value for U\n  using the rules of template argument deduction from a function call\n  (14.8.2.1), where P is a function template parameter type and the\n  initializer is the corresponding argument. If the deduction fails, the\n  declaration is ill-formed. Otherwise, the type deduced for the\n  variable or return type is obtained by substituting the deduced U into\n  P. [</p>\n</blockquote>\n<pre><code>Example:\nauto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list&lt;int&gt;\n</code></pre>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "27199584", "Score": "1", "CreationDate": "2014-11-29T06:29:18.687", "LastActivityDate": "2014-11-29T06:29:18.687"}, "bq_ids": {"n4140": {"so_27199478_27199571_0": {"section_id": 5451, "quality": 0.5882352941176471, "length": 40}, "so_27199478_27199584_0": {"section_id": 5451, "quality": 0.9384615384615385, "length": 61}}, "n3337": {"so_27199478_27199571_0": {"section_id": 5245, "quality": 0.9117647058823529, "length": 62}, "so_27199478_27199584_0": {"section_id": 5245, "quality": 0.5692307692307692, "length": 37}}, "n4659": {"so_27199478_27199571_0": {"section_id": 6889, "quality": 0.5147058823529411, "length": 35}, "so_27199478_27199584_0": {"section_id": 6889, "quality": 0.6923076923076923, "length": 45}}}, "27199478": {"CommentCount": "0", "ViewCount": "99", "OwnerDisplayName": "user2953119", "CreationDate": "2014-11-29T06:10:53.500", "LastActivityDate": "2014-11-29T07:00:34.460", "PostTypeId": "1", "AcceptedAnswerId": "27199571", "Title": "Why does {1, 2} has no a type, but decltype(a) is well-formed?", "Id": "27199478", "Score": "2", "Body": "<p>The Standard says that <code>braced-init-list</code> has no a type. So I expected that something like <code>auto a = {1, 2};</code> is ill-formed. But it's not true at all.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nusing namespace std;\n\nauto a = {1, 2};\n\nstd::initializer_list&lt;int&gt; init_list = {1, 3, 6, 7};\n\ndecltype(a) b = init_list;\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/f12e748e208416aa\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>Moreover <code>decltype(a)</code> is <code>std::initializer_list&lt;int&gt;</code>. To me, it contradicts the initializer list has no the type. What's wrong?</p>\n", "Tags": "<c++><initializer-list>", "AnswerCount": "2"}});