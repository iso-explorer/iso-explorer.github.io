post_cb({"32924499": {"ParentId": "32924282", "CommentCount": "4", "Body": "<p>Yes, as has been said already, your program has undefined behaviour. You just can't hack around with pointers like this and expect consistent behaviour.</p>\n<p>Why? Because compilers are complicated creatures that do all sorts of weird magic that would ruin your expectations of memory layout.</p>\n<p>In this case, you are just <em>assuming</em> that <code>i2</code> will sit immediately before <code>i</code> in memory. This assumption is baseless. Although it <em>happens</em> to be the case in your working example, when your program isn't forcing <code>i2</code> to occupy memory by taking its address (the <code>&amp;i2</code> in your \"print statement\") the variable is evidently <em>completely optimised out</em>. It doesn't exist in memory <em>at all</em>!</p>\n<p>So no wonder trying to guess at its memory location and print the value underneath said memory location is not working as you expect.</p>\n<p>C++ is an <em>abstraction</em>. It's deliberately designed with the knowledge that this sort of thing is really the choice of your compiler and cannot be predicted ahead of time. That's why C++ says that your code has <em>undefined behaviour</em>: because it might appear to do what you want it to do, or it might skin a cat and teleport the body into your car boot, or it might transfer all your hard-earned savings into my bank account; if you want to code to standards, just avoid undefined behaviour, assume <em>only</em> the guarantees of the standard, and then all this uncertainty vanishes in a poof of catnip.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "32924499", "Score": "4", "CreationDate": "2015-10-03T15:51:08.937", "LastActivityDate": "2015-10-03T15:51:08.937"}, "32924282": {"CommentCount": "4", "ViewCount": "328", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2015-10-03T15:30:32.940", "LastActivityDate": "2015-10-03T17:04:55.313", "Title": "Why does the print statement change the value of pointer?", "FavoriteCount": "1", "LastEditDate": "2015-10-03T16:34:04.153", "Id": "32924282", "Score": "4", "Body": "<p>I wrote a c++ code like this:</p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 2;\n    int i2 = 0;\n    void *pi = &amp;i - 1;\n    cout &lt;&lt; \"by cout - the value of *pi is: \" &lt;&lt; *(int*)pi &lt;&lt; endl;\n    printf(\"by printf - the value of *pi is: %d\\n\", *(int*)pi);\n    printf(\"the address of pi is: %p\\n\", pi);\n    printf(\"the address of i2 is: %p\\n\", (void*)&amp;i2);\n    printf(\"the value of i2 is: %d\\n\", i2);\n    return 0;\n}\n</code></pre>\n<p>and the output is:</p>\n<pre><code>by cout - the value of *pi is: 0\nby printf - the value of *pi is: 0\nthe address of pi is: 0029fe94\nthe address of i2 is: 0029fe94\nthe value of i2 is: 0\n</code></pre>\n<hr>\n<p>now if I remove the statement which will print the address.</p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 2;\n    int i2 = 0;\n    void *pi = &amp;i - 1;\n    cout &lt;&lt; \"by cout - the value of *pi is: \" &lt;&lt; *(int*)pi &lt;&lt; endl;\n    printf(\"by printf - the value of *pi is: %d\\n\", *(int*)pi);\n    // printf(\"the address of pi is: %p\\n\", pi);\n    // printf(\"the address of i2 is: %p\\n\", (void*)&amp;i2);\n    printf(\"the value of i2 is: %d\\n\", i2);\n    return 0;\n}\n</code></pre>\n<p>now the output is:</p>\n<pre><code>by cout - the value of *pi is: 2004212408\nby printf - the value of *pi is: 2004212408\nthe value of i2 is: 0\n</code></pre>\n<p>notice that the value was totally different.</p>\n<p>update:\nIf I add some assignment after the print:</p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 2;\n    int i2 = 0;\n    void *pi = &amp;i - 1;\n    cout &lt;&lt; \"by cout - the value of *pi is: \" &lt;&lt; *(int*)pi &lt;&lt; endl;\n    printf(\"by printf - the value of *pi is: %d\\n\", *(int*)pi);\n    // printf(\"the address of pi is: %p\\n\", pi);\n    // printf(\"the address of i2 is: %p\\n\", (void*)&amp;i2);\n    pi = &amp;i2;\n    printf(\"the value of i2 is: %d\\n\", i2);\n    return 0;\n}\n</code></pre>\n<p>the output been normal again:</p>\n<pre><code>by cout - the value of *pi is: 0\nby printf - the value of *pi is: 0\nthe value of i2 is: 0\n</code></pre>\n<p>use \"g++ -std=c++11 -pedantic -Wall\" to compile, version is 4.9.2.</p>\n<p>Why could that happen?</p>\n</hr>", "Tags": "<c++><pointers><c++11>", "OwnerUserId": "4869088", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32924282_32924330_1": {"section_id": 6142, "quality": 1.0, "length": 57}}, "n3337": {"so_32924282_32924330_1": {"section_id": 5906, "quality": 1.0, "length": 57}}, "n4659": {"so_32924282_32924330_0": {"section_id": 7562, "quality": 0.8888888888888888, "length": 16}}}, "32924330": {"ParentId": "32924282", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Accessing <code>pi</code> is undefined behaviour due to the fact that <code>&amp;i - 1</code> might not be a valid pointer value.</p>\n<p>In standardese (from the C++ standard), at \u00a75.3.1/3 we have:</p>\n<blockquote>\n<p id=\"so_32924282_32924330_0\">[...] For purposes of pointer arithmetic (5.7) and comparison (5.9, 5.10), an object that is not an array element whose address is taken in this way is considered to belong to an array with one element of type T.</p>\n</blockquote>\n<p>which leads us to \u00a75.7/4:</p>\n<blockquote>\n<p id=\"so_32924282_32924330_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. [...] If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "493122", "LastEditorUserId": "560648", "LastEditDate": "2015-10-03T15:48:01.083", "Id": "32924330", "Score": "8", "CreationDate": "2015-10-03T15:33:55.087", "LastActivityDate": "2015-10-03T15:48:01.083"}});