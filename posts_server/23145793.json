post_cb({"bq_ids": {"n4140": {"so_23145793_23799618_1": {"length": 26, "quality": 1.0, "section_id": 5356}, "so_23145793_23799618_3": {"length": 8, "quality": 0.8, "section_id": 5361}}, "n3337": {"so_23145793_23799618_1": {"length": 26, "quality": 1.0, "section_id": 5153}, "so_23145793_23799618_3": {"length": 8, "quality": 0.8, "section_id": 5157}}, "n4659": {"so_23145793_23799618_1": {"length": 26, "quality": 1.0, "section_id": 6781}, "so_23145793_23799618_3": {"length": 8, "quality": 0.8, "section_id": 6789}}}, "23798505": {"Id": "23798505", "PostTypeId": "2", "Body": "<p>The best way to answer your question is to rewrite it as a Program that compiles identically when using a \"C\" or \"C++\" Compiler, I will assume you are using GCC but other (<strong>correctly written</strong>)  Compiler Toolchains should provide similar results.</p>\n<p>First I will address each point you posed then I will give a Program that provides the answer (and Proof).</p>\n<ul>\n<li>As far as I can tell, before C++11, string literals were handled in almost exactly the same way between C and C++.</li>\n</ul>\n<p>They still can be handled the same way using various Command Line Parameters, in this example I will use \"-fpermissive\" (a Cheat). You are better off finding out why you are getting Warnings and writing NEW Code to avoid ANY Warning; only use CLP 'cheats' to compile OLD Code.</p>\n<p><strong>Write new Code correctly</strong> (no cheats and no Warnings, that there be no Errors goes without saying).</p>\n<ul>\n<li>Now, I acknowledge that there are differences between C and C++ in the handling of wide string literals.</li>\n</ul>\n<p>There does not have to be (many differences)  since you can cheat most or all of them away depending on the circumstances. Cheating is wrong, learn to program correctly and follow modern Standards not the mistakes (or awkwardness) of the past. Things are done a certain way to be helpful both to you, and to the Compiler in some cases (remember YOU are not the only one who 'sees' your Code).</p>\n<p>In <strong>this</strong> case the Compiler wants enough space allocated to terminate the String with a '0' (zero byte). That permits the use of a print (and some other) Function without specifying the length of the String.</p>\n<p>IF you are simply trying to compile an existing Program you obtained from somewhere and do not want to re-write it, you simply want to compile it and run it, then use the cheats (if you must) to get past the Warnings and force the compilation to an executable.</p>\n<ul>\n<li>The rest of what you wrote ...</li>\n</ul>\n<p>No.</p>\n<p>.</p>\n<p>See this example Program. I slightly modified your question to make it into a Program. The result of compiling this Program with a \"C\" or C++\" Compiler is identical.</p>\n<p>Copy-and-Paste the example Program text below to a File called \"test.c\", then follow the instructions at the start. Simply 'cat' the File so you can backscroll it (and see it) without opening a Text Editor, then Copy-and-Paste each Line beginning with the Compiler Commands (the next three).</p>\n<p>Note, that as pointed out in the Comments, that running this Line \"g++ -S -o test_c++.s test.c\" produces an Error (using a modern g++ Compiler) since the container is not long enough to hold the String.</p>\n<p>You should be able to read this Program and not actually need to compile it to see the Answer but it will compile and produce the Output for you to examine should you desire to do so.</p>\n<p>As you can see the Varable \"str1\" is not long enough to hold the String when it is null terminated, that produces an Error on a modern (and correctly written) g++ Compiler.</p>\n<hr>\n<pre><code>/* Answer for: http://stackoverflow.com/questions/23145793/string-literal-differences-between-c-and-c\n *\n * cat test.c\n * gcc -S -o test_c.s test.c\n * g++ -S -o test_c++.s test.c\n * g++ -S -fpermissive -o test_c++.s test.c\n *\n */\n\nchar str1[3] = \"1ab\";\nchar str2[4] = \"2ab\";\nchar str3[]  = \"3ab\";\n\nmain(){return 0;}\n\n\n/* Comment: Executing \"g++ -S -o test_c++.s test.c\" produces this Error:\n *\n * test.c:10:16: error: initializer-string for array of chars is too long [-fpermissive]\n * char str1[3] = \"1ab\";\n *                ^\n *\n */\n\n\n/* Resulting Assembly Language Output */\n\n/*      .file   \"test.c\"\n *      .globl  _str1\n *      .data\n * _str1:\n *      .ascii \"1ab\"\n *      .globl  _str2\n * _str2:\n *      .ascii \"2ab\\0\"\n *      .globl  _str3\n * _str3:\n *      .ascii \"3ab\\0\"\n *      .def    ___main;    .scl    2;  .type   32; .endef\n *      .text\n *      .globl  _main\n *      .def    _main;  .scl    2;  .type   32; .endef\n * _main:\n * LFB0:\n *      .cfi_startproc\n *      pushl   %ebp\n *      .cfi_def_cfa_offset 8\n *      .cfi_offset 5, -8\n *      movl    %esp, %ebp\n *      .cfi_def_cfa_register 5\n *      andl    $-16, %esp\n *      call    ___main\n *      movl    $0, %eax\n *      leave\n *      .cfi_restore 5\n *      .cfi_def_cfa 4, 4\n *      ret\n *      .cfi_endproc\n * LFE0:\n *      .ident  \"GCC: (GNU) 4.8.2\"\n *\n */\n</code></pre>\n</hr>", "LastActivityDate": "2014-05-22T05:32:04.587", "CommentCount": "4", "CreationDate": "2014-05-22T05:32:04.587", "ParentId": "23145793", "Score": "-1", "OwnerUserId": "3648282"}, "23799618": {"Id": "23799618", "PostTypeId": "2", "Body": "<h3>Raw strings</h3>\n<p>A noticeable difference is that C++'s string literals are a superset of C ones. Specifically C++ now supports <a href=\"http://www.stroustrup.com/C++11FAQ.html#raw-strings\" rel=\"nofollow noreferrer\"><em>raw strings</em></a> (<a href=\"http://coliru.stacked-crooked.com/a/bfe6aad38cd69d73\" rel=\"nofollow noreferrer\">not supported</a> in C), technically defined at \u00a72.14.15 and generally used in HTML and XML where <code>\"</code> is often encountered.</p>\n<p>Raw strings allow you to specify your own delimiter (up to 16 characters) in the form:</p>\n<pre><code>R\"delimiter(char sequence)delimiter\"\n</code></pre>\n<p>This is particularly useful to avoid unnecessary escaping characters by providing your own string delimiter. The following two examples show how you can avoid escaping of <code>\"</code> and <code>(</code> respectively:</p>\n<pre><code>std::cout &lt;&lt; R\"(a\"b\"c\")\";      // empty delimiter\nstd::cout &lt;&lt; '\\n';\nstd::cout &lt;&lt; R\"aa(a(\"b\"))aa\";  // aa delimiter\n// a\"b\"c\"\n// a(\"b\")\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1bfb25b515e5d92c\" rel=\"nofollow noreferrer\"><kbd>Live demo</kbd></a></p>\n<hr>\n<h3><code>char</code> vs <code>const char</code></h3>\n<p>Another difference, pointed out in the comments, is that string literals have type <code>char [n]</code> in C, as specified at \u00a76.4.5/6:</p>\n<blockquote>\n<p id=\"so_23145793_23799618_0\">For character string literals, the array elements have type char, and are initialized with the individual bytes of the multibyte character sequence.</p>\n</blockquote>\n<p>while in C++ they have type <code>const char [n]</code>, as defined in \u00a72.14.5/8:</p>\n<blockquote>\n<p id=\"so_23145793_23799618_1\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow\n  string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has\n  static storage duration (3.7).</p>\n</blockquote>\n<p>This doesn't change the fact that in both standard (at \u00a76.4.5/7 and 2.14.5/13 for C and C++ respectively) attempting to modify a string literal results in undefined behavior.</p>\n<hr>\n<h3>Unspecified vs Implementation defined (<a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\">ref</a>)</h3>\n<p>Another subtle difference is that in C, wether the character arrays of string literals are different is unspecified, as per \u00a76.4.5/7:</p>\n<blockquote>\n<p id=\"so_23145793_23799618_2\">It is unspecified whether these arrays are distinct provided their elements have the appropriate values.</p>\n</blockquote>\n<p>while in C++ this is implementation defined, as per \u00a72.14.5/13:</p>\n<blockquote>\n<p id=\"so_23145793_23799618_3\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation- defined.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-22T07:28:46.670", "Score": "6", "CreationDate": "2014-05-22T06:46:09.973", "ParentId": "23145793", "CommentCount": "2", "OwnerUserId": "493122", "LastEditDate": "2017-05-23T11:50:23.690"}, "23145793": {"ViewCount": "2068", "Body": "<p>As far as I can tell, before C++11, string literals were handled in almost exactly the same way between C and C++.</p>\n<p>Now, I acknowledge that there are differences between C and C++ in the handling of wide string literals.</p>\n<p>The only differences that I have been able to find are in the initialization of an array by string literal.</p>\n<pre><code>char str[3] = \"abc\"; /* OK in C but not in C++ */\nchar str[4] = \"abc\"; /* OK in C and in C++. Terminating zero at str[3] */\n</code></pre>\n<p>And a technical difference that only matters in C++. In C++ <code>\"abc\"</code> is <code>const char [4]</code> while in C it is <code>char [4]</code>. However, C++ has a special rule that allows the conversion to <code>const char *</code> and then to <code>char *</code> to retain C compatibility up until C++11 when that special rule is no longer applied.</p>\n<p>And a difference in allowed lengths of literals. However, as a practical matter any compiler that compiles both C and C++ code will not enforce the lower C limit.</p>\n<p>I have some interesting links that apply:</p>\n<ul>\n<li><a href=\"http://david.tribble.com/text/cdiffs.htm\">http://david.tribble.com/text/cdiffs.htm</a></li>\n<li><a href=\"http://www.coding-guidelines.com/cbook/c90c++.pdf\">http://www.coding-guidelines.com/cbook/c90c++.pdf</a></li>\n</ul>\n<p>Are there any <em>other</em> differences?</p>\n", "Title": "String Literal Differences Between C and C++", "CreationDate": "2014-04-18T00:53:28.020", "LastActivityDate": "2014-05-22T07:28:46.670", "CommentCount": "20", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2014-04-18T01:06:58.670", "LastEditorUserId": "13422", "Id": "23145793", "Score": "15", "OwnerUserId": "13422", "Tags": "<c++><c><string><string-literals>", "AnswerCount": "2"}});