post_cb({"bq_ids": {"n4140": {"so_17585191_17585259_0": {"length": 24, "quality": 0.96, "section_id": 3245}, "so_17585191_17585259_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 5862}}, "n3337": {"so_17585191_17585259_0": {"length": 24, "quality": 0.96, "section_id": 3118}, "so_17585191_17585259_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 5632}}, "n4659": {"so_17585191_17585259_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 7345}}}, "17585259": {"Id": "17585259", "PostTypeId": "2", "Body": "<p>The logic is not the same. The difference is that in your second example function <code>Base::test()</code> uses objects of its own class <code>Base</code> (as opposed to a completely foreign class <code>Derived</code>).</p>\n<p>The language gives a special treatment to this situation in 8.3.5/6 (C++03)</p>\n<blockquote>\n<p id=\"so_17585191_17585259_0\">The type of a parameter or the return type for a function definition\n  shall not be an incomplete class type (possibly cv-qualified) unless\n  the function definition is nested within the member-specification for\n  that class (including definitions in nested classes defined within the\n  class).</p>\n</blockquote>\n<p>This rule can be seen as a \"satellite\" for another similar rule - the one that says that the class type is always seen in its entirety (and as complete type) from bodies of class member functions, default arguments and constructor initializer lists. See 9.2/2 (C++03)</p>\n<blockquote>\n<p id=\"so_17585191_17585259_1\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the\n  class-specifier. Within the class member-specification, the class is regarded as complete within function\n  bodies, default arguments and constructor ctor-initializers (including such things in nested classes). Otherwise\n  it is regarded as incomplete within its own class member-specification.</p>\n</blockquote>\n<p>Note that in all other contexts before the closing <code>}</code> the class is considered to be incomplete </p>\n<pre><code>struct S {\n  S foo(S s) // &lt;- OK, due to 8.3.5/6\n    { return s; } \n\n  void bar(int a = sizeof(S)) // &lt;- OK, due to 9.2/2\n    { S s; } // &lt;- OK, due to 9.2/2\n\n  int (*baz())[sizeof(S)] // &lt;- ERROR: incomplete type in `sizeof`\n    { return NULL; }\n\n  void qux(int a[sizeof(S)]) // &lt;- ERROR: incomplete type in `sizeof`\n    {}\n};\n</code></pre>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-07-11T05:54:58.617", "Score": "3", "CreationDate": "2013-07-11T04:47:17.923", "ParentId": "17585191", "CommentCount": "1", "LastEditDate": "2013-07-11T05:54:58.617", "OwnerUserId": "187690"}, "17585191": {"ViewCount": "349", "Body": "<p>I know we can not define functions taking incomplete type as parameter, so it is expected the below code fails to compile with <em>error C2027: use of undefined type 'Derived'</em></p>\n<pre><code>class Derived;\nclass Base{\npublic:\n   void test(Derived d){ cout&lt;&lt;\"test\"&lt;&lt;endl; }\n};\nclass Derived : public Base{\n   int j;\n};\n</code></pre>\n<p>By the same logic, I would expect compilation to fail when test() takes an object of Base, which is of incomplete-type till that point. However, it does not, and the following code compiles fine</p>\n<pre><code>class Derived;\nclass Base{\npublic:\n    void test(Base b){ cout&lt;&lt;\"test\"&lt;&lt;endl; }\n};\nclass Derived : public Base{\n    int j;\n};\n</code></pre>\n<p>Is there a difference between the incomplete class type we have while a class is being defined and the incomplete-type exposed by a forward declaration?</p>\n", "AcceptedAnswerId": "17585259", "Title": "Incomplete type: class usage before definition vs. forward declaration", "CreationDate": "2013-07-11T04:40:38.560", "Id": "17585191", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-07-11T05:54:58.617", "Score": "1", "OwnerUserId": "1462314", "Tags": "<c++><incomplete-type>", "AnswerCount": "1"}});