post_cb({"bq_ids": {"n4140": {"so_9184280_9184285_1": {"length": 36, "quality": 0.972972972972973, "section_id": 721}}, "n3337": {"so_9184280_9184285_1": {"length": 36, "quality": 0.972972972972973, "section_id": 710}}, "n4659": {"so_9184280_9184285_1": {"length": 36, "quality": 0.972972972972973, "section_id": 752}}}, "9184334": {"Id": "9184334", "PostTypeId": "2", "Body": "<p>Yes it's possible. </p>\n<p>do you know rope? it's what you describe, for strings (big string == rope, got the joke?). Rope is not part of the standard, but for practical purposes: it's available on modern compilers. You could use it to represent the complete content of a text editor.</p>\n<p>Take a look here: <a href=\"https://stackoverflow.com/questions/2826431/stl-rope-when-and-where-to-use\">STL Rope - when and where to use</a> </p>\n<p>And always remember: </p>\n<ul>\n<li>the first rule of (performance) optimizations is: don't do it</li>\n<li>the second rule (for experts only): don't do it now.</li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-07T21:44:27.510", "Score": "1", "CreationDate": "2012-02-07T21:35:54.900", "ParentId": "9184280", "CommentCount": "0", "OwnerUserId": "313145", "LastEditDate": "2017-05-23T11:56:40.077"}, "9184280": {"ViewCount": "402", "Body": "<p>I'm wondering if it would be possible to implement an stl-like vector where the storage is done in blocks, and rather than allocate a larger block and copy from the original block, you could keep different blocks in different places, and overload the operator[] and the iterator's operator++ so that the user of the vector wasn't aware that the blocks weren't contiguous. </p>\n<p>This could save a copy when moving beyond the existing capacity. </p>\n", "Title": "vector implemented with many blocks and no resize copy", "CreationDate": "2012-02-07T21:31:37.353", "LastActivityDate": "2012-02-07T21:44:27.510", "CommentCount": "1", "PostTypeId": "1", "Id": "9184280", "Score": "5", "OwnerUserId": "500093", "Tags": "<c++><data-structures>", "AnswerCount": "2"}, "9184285": {"Id": "9184285", "PostTypeId": "2", "Body": "<p>You would be looking for std::deque</p>\n<p>See <a href=\"http://www.gotw.ca/gotw/054.htm\" rel=\"nofollow\"><strong>GotW #54</strong> Using Vector and Deque</a></p>\n<blockquote>\n<p id=\"so_9184280_9184285_0\">In Most Cases, Prefer Using deque (Controversial)</p>\n</blockquote>\n<p>Contains benchmarks to demonstrate the behaviours</p>\n<p>The latest C++11 standard says:</p>\n<blockquote>\n<h2>\u00a7 23.2.3 Sequence containers</h2>\n<p id=\"so_9184280_9184285_1\">[2] The sequence containers offer the programmer different complexity trade-offs and should be used accordingly.\n  vector or array is the type of sequence container that should be used by default. list or forward_list\n  should be used when there are frequent insertions and deletions from the middle of the sequence. deque is\n  the data structure of choice when most insertions and deletions take place at the beginning or at the end of\n  the sequence.</p>\n</blockquote>\n<p><a href=\"http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1073086407&amp;answer=1069897449\" rel=\"nofollow\">FAQ &gt; Prelude's Corner &gt; Vector or Deque? (intermediate)</a> Says:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_9184280_9184285_2\">A vector can only add items to the end efficiently, any attempt to insert an item in the middle of the vector or at the beginning can be and often is very inefficient. <strong>A deque can insert items at both the beginning and then end in constant time</strong>, O(1), which is very good. Insertions in the middle are still inefficient, <strong>but if such functionality is needed a list should be used</strong>. A deque's method for inserting at the front is push_front(), the insert() method can also be used, but push_front is more clear.</p></li>\n<li><p id=\"so_9184280_9184285_3\">Just like insertions, erasures at the front of a vector are inefficient, <strong>but a deque offers constant time erasure from the front as well</strong>.</p></li>\n<li><p id=\"so_9184280_9184285_4\">A deque uses memory more effectively. Consider memory fragmentation, a vector requires N consecutive blocks of memory to hold its items where N is the number of items and a block is the size of a single item. This can be a problem if the vector needs 5 or 10 megabytes of memory, but the available memory is fragmented to the point where there are not 5 or 10 megabytes of consecutive memory. <strong>A deque does not have this problem, if there isn't enough consecutive memory, the deque will use a series of smaller blocks.</strong></p></li>\n</ul>\n<p id=\"so_9184280_9184285_5\">[...]</p>\n</blockquote>\n", "LastEditorUserId": "85371", "LastActivityDate": "2012-02-07T21:39:41.587", "Score": "4", "CreationDate": "2012-02-07T21:32:20.497", "ParentId": "9184280", "CommentCount": "3", "OwnerUserId": "85371", "LastEditDate": "2012-02-07T21:39:41.587"}});