post_cb({"15040829": {"ParentId": "15040784", "CommentCount": "3", "CreationDate": "2013-02-23T13:03:24.333", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "15040829", "Score": "2", "Body": "<p>Using <code>std::move( tmp(...) )</code> is completely pointless, the temporary <code>tmp</code> is already an rvalue, you don't need to use <code>std::move</code> to cast it to an rvalue.</p>\n<p>Read this series of articles: <a href=\"http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/\" rel=\"nofollow\">Want Speed? Pass By Value</a></p>\n<p>You'll learn more and understand better than you will by asking a question on Stackoverflow</p>\n", "LastActivityDate": "2013-02-23T13:03:24.333"}, "15040784": {"CommentCount": "1", "ViewCount": "191", "PostTypeId": "1", "LastEditorUserId": "893819", "CreationDate": "2013-02-23T12:57:51.457", "LastActivityDate": "2013-02-23T13:19:55.353", "Title": "How to write move so that it can potentially be optimized away?", "AcceptedAnswerId": "15040860", "LastEditDate": "2013-02-23T13:19:55.353", "Id": "15040784", "Score": "1", "Body": "<p>Given the following code:</p>\n<pre><code>struct obj {\n    int i;\n    obj() : i(1) {}\n    obj(obj &amp;&amp;other) : i(other.i) {}\n};\n\nvoid f() {\n    obj o2(obj(obj(obj{})));\n}\n</code></pre>\n<p>I expect release builds to only really create one object and never call a move constructor because the result is the same <strong>as if</strong> my code was executed. Most code is not that simple though, I can think of a few hard to predict side effects that could stop the optimizer from proving the \"as if\":</p>\n<ol>\n<li>changes to global or \"outside\" things in either the move constructor or destructor.</li>\n<li>potential exceptions in the move constructor or destructor (probably bad design anyway)</li>\n<li>internal counting or caching mechanisms changing.</li>\n</ol>\n<p>Since I don't use any of these often can I expect most of my moves in and out of functions which are later inlined to be optimized away or am I forgetting something?</p>\n<p>P.S. I know that just because an optimization is possible does not mean it will be made by any given compiler.</p>\n", "Tags": "<c++><optimization><c++11><move>", "OwnerUserId": "893819", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15040784_15040860_0": {"section_id": 480, "quality": 0.95, "length": 19}}, "n3337": {"so_15040784_15040860_0": {"section_id": 471, "quality": 1.0, "length": 20}}, "n4659": {"so_15040784_15040860_0": {"section_id": 502, "quality": 0.95, "length": 19}}}, "15040860": {"ParentId": "15040784", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-02-23T13:06:55.070", "Score": "7", "LastEditorUserId": "150634", "LastEditDate": "2013-02-23T13:19:26.777", "Id": "15040860", "OwnerUserId": "150634", "Body": "<p>This doesn't really have anything to do with the as-if rule. The compiler is allowed to elide moves and copies even if they have some side effect. It is the single optimization that a compiler is allowed to do that might change the result of your program. From \u00a712.8/31:</p>\n<blockquote>\n<p id=\"so_15040784_15040860_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects.</p>\n</blockquote>\n<p>So the compiler doesn't have to bother inspecting what happens inside your move constructor, it will likely get rid of any moves here anyway. To demonstrate this, consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct bad_mover\n{\n  static int move_count;\n  bad_mover() = default;\n  bad_mover(bad_mover&amp;&amp; other) { move_count++; }\n};\n\nint bad_mover::move_count = 0;\n\nint main(int argc, const char* argv[])\n{\n  bad_mover b{bad_mover(bad_mover(bad_mover()))};\n  std::cout &lt;&lt; \"Move count: \" &lt;&lt; bad_mover::move_count &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<ol>\n<li><p>Compiled with <code>g++ -std=c++0x</code>:</p>\n<pre><code>Move count: 0\n</code></pre></li>\n<li><p>Compiled with <code>g++ -std=c++0x -fno-elide-constructors</code>:</p>\n<pre><code>Move count: 3\n</code></pre></li>\n</ol>\n<p>However, I would question any reason you have for providing a move constructor that has additional side effects. The idea in allowing this optimization regardless of side effects is that a copy or move constructor <em>shouldn't</em> do anything other than copy or move. The program with the copy or move should be exactly the same as without.</p>\n<p>Nonetheless, your calls to <code>std::move</code> are unnecessary. <code>std::move</code> is used to change an lvalue expression to an rvalue expression, but an expression that creates a temporary object is already an rvalue expression.</p>\n", "LastActivityDate": "2013-02-23T13:19:26.777"}});