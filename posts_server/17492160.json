post_cb({"bq_ids": {"n4140": {"so_17492160_17492236_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 5561}}, "n3337": {"so_17492160_17492236_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 5343}}, "n4659": {"so_17492160_17492236_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 7008}}}, "17492160": {"ViewCount": "869", "Body": "<p>Given two std::iterators of the same type, how is it possible to test if the come from the same object (not class)? Note, I'm not asking how to compare their values.</p>\n<pre><code>std::string foo = \"foo\";\nstd::string bar = \"bar\";\n\nstd::string::iterator iter1 = foo.begin();\nstd::string::iterator iter2 = bar.begin();\n\nif ( iter1 == iter2 )\n{\n    ...\n}\n</code></pre>\n<p>The above should and does fail. How can I check for this at runtime? Looking into the source code, I see that the relevant methods call on <code>iterator::_Compat()</code> this is a void method that does the check I want but on failure it issues a debug assertation. It will go unnoticed in release builds.</p>\n<p>Looking further I see that the iterator (for string at least) has a public <code>_GetCont()</code> method. So</p>\n<pre><code>if ( iter1._GetCont() == iter2._GetCont() )\n</code></pre>\n<p>works. But, this is undocumented leading me to believe it's not safe to use.</p>\n<p>My question is how can I accomplish the above in a portable manner?</p>\n<p>Also to note, this is part of an iterator template class. I will have no control over the second iterator.</p>\n", "AcceptedAnswerId": "17492236", "Title": "Test if two iterators come from same object", "CreationDate": "2013-07-05T15:18:02.253", "Id": "17492160", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-10-19T16:28:56.013", "Score": "4", "OwnerUserId": "1479092", "Tags": "<c++><templates><iterator>", "AnswerCount": "2"}, "17492236": {"Id": "17492236", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17492160_17492236_0\">My question is how can I accomplish the above in a portable manner?</p>\n</blockquote>\n<p>You cannot. </p>\n<p>In general, iterators are not required to know (or let <em>you</em> know) about the container they point into. Iterators are a generalization of pointers, and all they are required to do is to behave like pointers.</p>\n<p>So they may allow dereferencing, incrementing, decrementing, summing, and so on, depending on their category, but there is no iterator requirement in the C++ Standard about letting their user know what container they point into, or whether they point into the same container as another iterator.</p>\n<p>In other words, the validity of an iterator range should be a <em>precondition</em> of a function that works on that iterator range. It is a responsibility of the client to ensure the provided iterators point into the same container (and that the second iterator is reachable from the first).</p>\n<p>For instance, here is how the Standard Library deals with this matter (paragraph 24.2.1/7 of the C++11 Standard):</p>\n<blockquote>\n<p id=\"so_17492160_17492236_1\">Most of the library\u2019s algorithmic templates that operate on data structures have interfaces that use ranges.\n  A range is a pair of iterators that designate the beginning and end of the computation. A range <code>[i,i)</code> is an\n  empty range; in general, a range <code>[i,j)</code> refers to the elements in the data structure starting with the element\n  pointed to by <code>i</code> and up to but not including the element pointed to by <code>j</code>. Range <code>[i,j)</code> is valid if and only if\n  <code>j</code> is reachable from <code>i</code>. <strong>The result of the application of functions in the library to invalid ranges is undefined</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-07-05T15:27:59.730", "Score": "6", "CreationDate": "2013-07-05T15:22:52.550", "ParentId": "17492160", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-07-05T15:27:59.730"}, "26451816": {"Id": "26451816", "PostTypeId": "2", "Body": "<p>You may want to compare pointers</p>\n<pre><code>if ( &amp;(*iter1) == &amp;(*iter2) )\n{\n    ...\n}\n</code></pre>\n", "LastEditorUserId": "361205", "LastActivityDate": "2014-10-19T16:28:56.013", "Score": "0", "CreationDate": "2014-10-19T15:00:53.510", "ParentId": "17492160", "CommentCount": "1", "OwnerUserId": "4159069", "LastEditDate": "2014-10-19T16:28:56.013"}});