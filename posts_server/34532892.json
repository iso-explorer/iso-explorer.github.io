post_cb({"bq_ids": {"n4140": {"so_34532892_34532892_0": {"section_id": 7070, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_34532892_34532892_0": {"section_id": 6814, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_34532892_34532892_0": {"section_id": 8570, "quality": 0.9545454545454546, "length": 21}}}, "34532892": {"CommentCount": "11", "ViewCount": "106", "CreationDate": "2015-12-30T16:03:28.503", "LastActivityDate": "2015-12-30T16:03:28.503", "Title": "Is \u00a73.3.7/4 from N4567 redundant?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "34532892", "Score": "3", "Body": "<p>According to N4567, 3.3.7 paragraph 4 says,</p>\n<blockquote>\n<p id=\"so_34532892_34532892_0\">The potential scope of a declaration that extends to or past the end of a class definition also extends to the regions defined by its member definitions, <strong>even if the members are defined lexically outside the class</strong>...</p>\n</blockquote>\n<p>However, I don't see a need for making it clear because such a member definition must be in the scope of that declaration regardless of its lexical positioning. In other words, it seems there is no case where such a member definition dwells outside the scope of the declaration. See the following example:</p>\n<pre><code>int always_visible=10;\n\nclass some {\n    int foo(void);\n};\n\nint some::foo(void) {\n    // no ambiguity occurs because its member definition\n    // is always in the scope of always_visible.\n    return always_visible;\n}\n</code></pre>\n<p>I don't think it's possible for its member definition to precede the declaration of always_visible, in which case the wording above might be useful. Then, why is that clarification needed?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "5645940", "AnswerCount": "0"}});