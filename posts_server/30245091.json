post_cb({"30245375": {"Id": "30245375", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30245091_30245375_0\">What is the difference between type and name</p>\n</blockquote>\n<p>A type has none, one or several names. Typedef <a href=\"https://stackoverflow.com/questions/18287151/difference-between-typedef-and-c11-type-alias\">and alias</a> are simply means of creating a new name for a type. </p>\n<p><code>public</code> and <code>private</code> keywords relate to names not to the underlying types or members.</p>\n<p>In order to explicitly declare an object of a particular type you need a name for that type. <code>auto</code> doesn't need this. If you for example use an unnamed class <a href=\"https://stackoverflow.com/a/8030933/3243563\">as a return type</a>, this class has no name but auto can still be used on it. </p>\n<p>An type will always have at most one '<a href=\"http://tvtropes.org/pmwiki/pmwiki.php/Main/IKnowYourTrueName\" rel=\"nofollow noreferrer\">true name</a>'. Even when using it through a typedef or alias, the compiler uses it under this name (or actually the raw version of this name). So:</p>\n<pre><code>class A {};\ntypedef A B;\nstd::cout &lt;&lt; typeid(B).name();\n</code></pre>\n<p>Prints \"class A\". An unnamed object cannot be given a 'true name'. However, when using <code>typedef</code> and <code>decltype</code>. A new name can be created. If this name is then used to create objects. <code>typeid().name</code> will print the newly assigned name. If the object wasn't unnamed to start with the 'true name' name will be printed.</p>\n<hr>\n<p><strong>The scenarios:</strong></p>\n<ol>\n<li><p>The difference is that in the first you are using a privately declared name. Which is illegal. This has to do with how the different ways of type deduction work. As Scott Meyers explains <a href=\"https://youtu.be/wQxj20X-tIU?t=4m20s\" rel=\"nofollow noreferrer\">here</a>. Since a public function call provides this type, the return type is public. However, <code>Bar</code> on itself is not public. It's a small difference, but that is the reason.\n<br>\n<br>\nThis simply is a decision that has been made in the design. It makes sense, sometimes you only want a struct to be used when you return it. </br></br></p></li>\n<li><p>The same goes here. There is no difference, however <code>Foo::Bar</code> simply is inaccessible. </p></li>\n</ol>\n<hr>\n<p><strong>Edit</strong></p>\n<blockquote>\n<p id=\"so_30245091_30245375_1\">Can you give an example that type has none names? is the unnamed union in the above comment a example of this?  </p>\n</blockquote>\n<p>As described <a href=\"https://stackoverflow.com/questions/8026579/can-anonymous-class-be-used-as-return-types-in-c\">here</a> I use a lambda function as follows:</p>\n<pre><code>auto f = [] () -&gt; struct {int x, y ; } { return { 99, 101 } ; } ;\n</code></pre>\n<p>Without using auto or decltype there would be no way of creating variable <code>f</code>. Since it's type has no name. Another example of a type without a name.</p>\n<pre><code>struct foo\n{\n    struct{\n        int x;\n        int y;\n    } memberVar;\n};\n</code></pre>\n<p>Would allow you to do the following:</p>\n<pre><code>foo bar;\n\nauto baz = bar.memberVar;\n\nstd::cout &lt;&lt; baz.x;\n</code></pre>\n<p>Which results in a bunch of initialized stuff of course, but you get the idea:). The type of <code>memberVar</code> here is unnamed. Making it impossible to define <code>baz</code> explicitly. </p>\n<blockquote>\n<p id=\"so_30245091_30245375_2\">And is int considered to be a name for type of int? </p>\n</blockquote>\n<p><code>int</code> is a bit special, being a <a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow noreferrer\">fundamental type</a>. 'int' indeed is the name of the type int. But it's by no means the only name, <code>int32_t</code>, for example is another name for the exact same type on most compilers(on other systems <code>int16_t</code>  is equivalent to <code>int</code>). </p>\n<pre><code>std::cout &lt;&lt; typeid(int32_t).name(); \n</code></pre>\n<p>Prints \"int\".</p>\n<p><strong>Notes:</strong> </p>\n<ul>\n<li><p>I've refrained from using alias as an indicator for other names of an object, since this might cause confusion with the alias keyword.</p></li>\n<li><p>Most of this I have gathered from experience. So I might have missed some bits. </p></li>\n<li><p>By lack for a better word i have used the expression 'true name'. If anybody knows the official or a better word for this i'd be happy to hear it:).</p></li>\n</ul>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-15T12:03:40.733", "Score": "22", "CreationDate": "2015-05-14T19:07:58.790", "ParentId": "30245091", "CommentCount": "5", "OwnerUserId": "3243563", "LastEditDate": "2017-05-23T11:51:48.900"}, "bq_ids": {"n4140": {"so_30245091_30245730_1": {"length": 38, "quality": 0.926829268292683, "section_id": 7083}, "so_30245091_30245730_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 78}, "so_30245091_30245730_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 6667}, "so_30245091_30245730_0": {"length": 11, "quality": 1.0, "section_id": 5451}}, "n3337": {"so_30245091_30245730_1": {"length": 38, "quality": 0.926829268292683, "section_id": 6827}, "so_30245091_30245730_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 73}, "so_30245091_30245730_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 6422}, "so_30245091_30245730_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5245}}, "n4659": {"so_30245091_30245730_1": {"length": 38, "quality": 0.926829268292683, "section_id": 8584}, "so_30245091_30245730_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 80}, "so_30245091_30245730_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 8142}, "so_30245091_30245730_0": {"length": 11, "quality": 1.0, "section_id": 6889}}}, "30245730": {"Id": "30245730", "PostTypeId": "2", "Body": "<p><sub><em>[Some standardese ahead]</em></sub></p>\n<p>Let's agree that <code>auto</code> deduction works in the same way as template argument deduction:</p>\n<p><em>[dcl.spec.auto]/p7</em></p>\n<blockquote>\n<p id=\"so_30245091_30245730_0\">If the placeholder is the auto\n  type-specifier, the deduced type is determined using the rules for template argument deduction</p>\n</blockquote>\n<p>Templates are subject to the <a href=\"https://stackoverflow.com/questions/7767626/two-phase-lookup-explanation-needed\">two-phase lookup</a> during compilation. Access control is applied to name lookup in the first phase</p>\n<p><em>[basic.lookup]/p1</em></p>\n<blockquote>\n<p id=\"so_30245091_30245730_1\">Overload resolution (13.3) takes place after name lookup has succeeded. The access rules (Clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access checking have succeeded are the attributes introduced by the name\u2019s declaration used further in expression processing</p>\n</blockquote>\n<p><code>auto</code> and <code>decltype(auto)</code> are usually a placeholder for a deduced type, and it is true that <em>[temp.arg]/p3</em> says</p>\n<blockquote>\n<p id=\"so_30245091_30245730_2\">The name of a template-argument shall be accessible at the point where it is used as a template-argument</p>\n</blockquote>\n<p>but <strong>names aren't involved here</strong>, only the types. Access control applies to names, a type can be mapped to 0, 1 or multiple names and that's what you're dealing with when using <code>auto</code> in the code above: it is semantically equivalent to the semantics of template deduction and this is by design.</p>\n<p><em>[class.access]/p4</em></p>\n<blockquote>\n<p id=\"so_30245091_30245730_3\">Access control is applied uniformly to all names, whether the names are referred to from declarations or\n  expressions.  [...] The accessibility\n  of the entity referred to by the typedef is not considered. For example</p>\n</blockquote>\n<pre><code>class A {\n  class B { };\npublic:\n  typedef B BB;\n};\nvoid f() {\n  A::BB x; // OK, typedef name A::BB is public\n  A::B y; // access error, A::B is private\n}\n</code></pre>\n<p>To convince yourself of the following take a look at the same code with template argument deduction involved (conceptually equivalent to the <code>auto</code> version)</p>\n<pre><code>template&lt;class T&gt; \nT deduce(T t) {\n    return t;\n} \n\nclass Foo {\n    struct Bar{ \n        int i; \n        Bar(int a = 5):i(a){}; \n    };\npublic:\n\n  Bar *getB() { return new Bar(5); } // Leaks, doesn't matter for clarity's sake\n};\n\nint main() {\n    Foo f;\n    std::cout &lt;&lt;\"b.i=\"&lt;&lt; deduce(f.getB())-&gt;i &lt;&lt;std::endl; // Prints 'b.i=5'\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/29bab645f423b6a1\" rel=\"nofollow noreferrer\">Live example</a></p>\n<p>In the code above names aren't involved and thus access control doesn't apply. Types are indeed involved.</p>\n<p>The semantics of <code>auto</code> is like implicit template deduction (the normative wording also directly refers to it).</p>\n<p><a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/zlVUsEAXta8\" rel=\"nofollow noreferrer\">Someone else had this doubt before</a>.</p>\n<hr>\n<p>Now for the answers:</p>\n<p><code>Case 1</code> is easy to agree with if you consider that the caller has no access to the name <code>Foo::Bar</code>.</p>\n<p><code>Case 2</code> exposes the name to the caller as well, so if you use the typedef'd name your code will happily compile.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-14T19:56:26.033", "Score": "6", "CreationDate": "2015-05-14T19:29:37.987", "ParentId": "30245091", "CommentCount": "0", "OwnerUserId": "1938163", "LastEditDate": "2017-05-23T12:14:10.920"}, "30245405": {"Id": "30245405", "PostTypeId": "2", "Body": "<p>The question you link explains a lot but as a supplement to what is being written there...</p>\n<ol>\n<li><p>The main difference is that in the second line <code>auto b=...</code> you let the compiler deduce the type of the expression. You can't specify the type, as the name of the type is hidden. The type though is usable (at least from the compiler)</p></li>\n<li><p>You expose the name of the type publicly so it can be used. </p></li>\n</ol>\n<p>This is a very nice answer <a href=\"https://stackoverflow.com/a/13532882/3037915\">https://stackoverflow.com/a/13532882/3037915</a></p>\n<p>To try to answer the question in the header, you may consider type as a shape and the name of the type as the name you use to refer to a particular shape. Even if the name of the \"shape\" is hidden, the shape still exists and can be used.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-14T19:10:11.587", "Score": "3", "CreationDate": "2015-05-14T19:10:11.587", "ParentId": "30245091", "CommentCount": "0", "OwnerUserId": "3037915", "LastEditDate": "2017-05-23T12:06:41.070"}, "30245091": {"ViewCount": "1020", "Body": "<p>I am reading <a href=\"https://stackoverflow.com/questions/13532784/why-can-i-use-auto-on-a-private-type\">this Stack\u00a0Overflow question</a>, and I added a constructor to the code from that question as the follwing,</p>\n<pre><code>class Foo {\n    struct Bar { \n        int i; \n        Bar(int a = 5) :i(a) {}; \n    };\n\n  public:\n    Bar Baz() { return Bar(); }\n};\n\nint main() {\n    Foo f;\n    // Foo::Bar b = f.Baz();  // error\n    auto b = f.Baz();         // ok\n    std::cout &lt;&lt;\"b.i=\"&lt;&lt; b.i&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>The code outputs <code>b.i=5</code>. In that question it concludes that the name of the private is not accessible but the type is. So what's the difference between type and name, generally? </p>\n<p>And say I have two specific scenarios. </p>\n<ol>\n<li><p>What's the difference between the following two declarations? Why can I get the output <code>b.i=5</code> from <code>auto b = f.Baz();</code>?</p>\n<pre><code>Foo::Bar b = f.Baz();\nauto b = f.Baz();\n</code></pre></li>\n<li><p>If I add <code>typedef Bar B;</code> in the public part of <code>Foo</code>, what is the difference between the following?</p>\n<pre><code> Foo::Bar b = f.Baz();\n Foo::B   b = f.Baz(); \n</code></pre></li>\n</ol>\n<p>If there a difference between scenario 1 and 2?</p>\n", "AcceptedAnswerId": "30245375", "Title": "What's the difference between type and name in C++?", "CreationDate": "2015-05-14T18:52:22.207", "Id": "30245091", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:14:10.920", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-15T12:03:40.733", "Score": "23", "OwnerUserId": "2345484", "Tags": "<c++><c++11><types>", "AnswerCount": "3"}});