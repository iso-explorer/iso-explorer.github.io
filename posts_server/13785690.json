post_cb({"13785690": {"CommentCount": "0", "ViewCount": "97", "CreationDate": "2012-12-09T08:02:01.623", "LastActivityDate": "2012-12-09T08:31:15.650", "Title": "Is one allowed to call allocator::deallocate() in a different order than one called allocator::allocate()?", "AcceptedAnswerId": "13785737", "PostTypeId": "1", "Id": "13785690", "Score": "2", "Body": "<p>N3485 20.6.9.1 [allocator.members]/1 says:</p>\n<blockquote>\n<p id=\"so_13785690_13785690_0\">Calls to these functions that allocate or deallocate a particular unit of storage shall occur in a single total order, and each such deallocation call shall happen before the next allocation (if any) in this order.</p>\n</blockquote>\n<p>This last requirement confuses me. It looks like the standard is saying that if one allocates a block of memory (let's call it block <code>a</code>), and then allocates another block (let's call it block <code>b</code>), then it is not allowed to deallocate block <code>a</code> until it has deallocated block <code>b</code>.</p>\n<p>If this is indeed what this paragraph entails, I don't see how one could implement something like <code>vector</code>'s growing in a space efficient manner; because one couldn't allocate a bigger buffer and then deallocate the previously allocated (too small) buffer.</p>\n<p>Is this actually what this paragraph means, or am I misreading this section?</p>\n", "Tags": "<c++><allocator>", "OwnerUserId": "82320", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13785690_13785737_0": {"section_id": 4235, "quality": 1.0, "length": 20}, "so_13785690_13785690_0": {"section_id": 4235, "quality": 1.0, "length": 20}}, "n3337": {"so_13785690_13785737_0": {"section_id": 4076, "quality": 1.0, "length": 20}, "so_13785690_13785690_0": {"section_id": 4076, "quality": 1.0, "length": 20}}, "n4659": {"so_13785690_13785737_0": {"section_id": 5497, "quality": 1.0, "length": 20}, "so_13785690_13785690_0": {"section_id": 5497, "quality": 1.0, "length": 20}}}, "13785737": {"ParentId": "13785690", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-12-09T08:11:46.837", "Score": "2", "LastEditorUserId": "499214", "LastEditDate": "2012-12-09T08:31:15.650", "Id": "13785737", "OwnerUserId": "499214", "Body": "<blockquote>\n<p id=\"so_13785690_13785737_0\">Calls to these functions that allocate or deallocate a <strong>particular unit of storage</strong> shall occur in a single total order, and each such deallocation call shall happen before the next allocation (if any) in this order.</p>\n</blockquote>\n<p>From what it seems to me, it only establishes a happens-before relationship between allocations and deallocations (to prevent concurrency issues arising from incorrect compiler optimisations, possibly). It definitely does not establish a relationship between <code>a</code> and <code>b</code> where <code>a</code> and <code>b</code> are different allocated regions.</p>\n<p>Remember that compilers follow the specification, not human logic. The specification aids the compiler programmers remember all the details that need to be taken care of (if it follows specification, it's correct). This is why the specification contains details that one would consider obvious. One of the details is that the deallocation/allocation constitutes a memory barrier.</p>\n<p>Compare </p>\n<pre><code>reads -&gt; deallocation -&gt; allocation -&gt; writes\n</code></pre>\n<p>with </p>\n<pre><code>reads -&gt; deallocation\nallocation -&gt; writes\n</code></pre>\n<p>Without a happens-before relationship, two threads may use the same memory region (unit of storage) concurrently, as observed by the memory region. With a happens-before relationship, all access from the deallocating thread must be flushed before the allocating thread gets to use it.</p>\n", "LastActivityDate": "2012-12-09T08:31:15.650"}});