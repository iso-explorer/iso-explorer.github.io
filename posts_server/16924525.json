post_cb({"18565937": {"ParentId": "16924525", "CommentCount": "1", "CreationDate": "2013-09-02T05:00:10.367", "OwnerUserId": "2364204", "PostTypeId": "2", "Id": "18565937", "Score": "1", "Body": "<p>The store to e.valid needs to a release and the load in the condition needs to be an acquire.  Otherwise, the compiler/processor are free to order setting e.valid above writing the payload.\nThere is an opensource tool, CDSChecker, for verifying code like this against the C/C++11 memory model.</p>\n", "LastActivityDate": "2013-09-02T05:00:10.367"}, "16924704": {"ParentId": "16924525", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2013-06-04T18:12:18.307", "Score": "5", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:33.097", "Id": "16924704", "OwnerUserId": "201270", "Body": "<p>Inside the <code>else</code> branch <code>valid</code> should be protected by the acquire/release semantics imposed by the operations on <code>waiting</code>. However this does not obliviate the need to make <code>valid</code> an atomic:</p>\n<p>You forgot to include the first line (<code>if (e.valid)</code>) in your analysis. If <code>valid</code> was an <code>bool</code> instead of <code>atomic&lt;bool&gt;</code> this access would be completely unprotected. Therefore you could have the situation where a change of <code>valid</code> becomes visible to other threads before the <code>payload</code> is completely written/visible. This means that a thread <code>B</code> could evaluate <code>e.valid</code> to <code>true</code> and enter the <code>do something with e.payload</code> branch while the <code>payload</code> isn't completely written yet. </p>\n<p>Other then that your analysis seems somewhat reasonable but not entirely correct to me. The thing to remember with memory ordering is that acquire and release semantics will pair up. Everything written before a release operation can safely be read after an acquire operation on the same veriable reads the modified value. With that in mind the release semantics on <code>waiting.clear(...)</code> ensure that the write to <code>valid</code> must be visible when the loop on <code>writing.test_and_set(...)</code> exits, since the later reads the change of waiting<code>(the write done in</code>waiting.clear(...)`) with acquire semantics and doesn't exit before that change is visible.</p>\n<p>Regarding \u00a729.3.12: It is relevant to the correctness of your code, but unrelated to the reading a stale <code>valid</code> flag. You can't set the flag before the clear, so acquire-release semantics will ensure correctness there. \u00a729.3.12 protects you from the following scenario:</p>\n<blockquote id=\"so_16924525_16924704_0\">\n<ol>\n<li>Both A and B enter the else branch, because valid is false</li>\n<li>A sets the writing flag</li>\n<li>B sees a stale value for writing and also sets it</li>\n<li>Both A and B read the valid flag (which is false), enter the if block and write the payload creating a race condition</li>\n</ol>\n</blockquote>\n<p>Edit: For the minimal Ordering constraints: acquire for the loads and release for the stores should probably do the job, however depending on your target hardware you might as well stay with sequential consistency. For the difference between those semantics look <a href=\"https://stackoverflow.com/a/14864466/201270\">here</a>.</p>\n", "LastActivityDate": "2013-06-05T14:27:49.033"}, "16924831": {"ParentId": "16924525", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-06-04T18:19:41.317", "Score": "1", "LastEditorUserId": "1760345", "LastEditDate": "2013-06-04T20:22:42.247", "Id": "16924831", "OwnerUserId": "981959", "Body": "<p>If <code>valid</code> is not atomic then the initial read of <code>e.valid</code> on the first line conflicts with the assignment to <code>e.valid</code>.</p>\n<p>There is no guarantee both threads have already done that read before one of them gets the spinlock, i.e steps 1 and 6 are not ordered.</p>\n", "LastActivityDate": "2013-06-04T20:22:42.247"}, "16926274": {"ParentId": "16924525", "CommentCount": "5", "CreationDate": "2013-06-04T19:49:34.110", "OwnerUserId": "2209313", "PostTypeId": "2", "Id": "16926274", "Score": "2", "Body": "<p>Section 29.3.12 has nothing to do with why this code is correct or incorrect.  The section you want (in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">the draft version of the standard available online</a>) is Section 1.10: \"Multi-threaded executions and data races.\"  Section 1.10 defines a happens-before relation on atomic operations, and on non-atomic operations with respect to atomic operations.</p>\n<p>Section 1.10 says that if there are two non-atomic operations where you can not determine the happens-before relationship then you have a data-race.  It further declares (Paragraph 21) that any program with a data-race has undefined behavior.</p>\n<p>If <code>e.valid</code> is not atomic then you have a data race between the first line of code and the line <code>e.valid=true</code>.  So all of your reasoning about the behavior in the <code>else</code> clause is incorrect (the program has no defined behavior so there is nothing to reason about.)</p>\n<p>On the other hand if all of your accesses to <code>e.valid</code> were protected by atomic operations on <code>e.writing</code> (like if the <code>else</code> clause was your whole program) then your reasoning would be correct.  Event 9 in your list could not happen.  But the reason is not Section 29.3.12, it is again Section 1.10, which says that your non-atomic operations will <em>appear</em> to be sequentially consistent if there are no dataraces.</p>\n<p>The pattern you are using is called <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\" rel=\"nofollow\">double checked locking\u200c\u200b</a>. Before C++11 it was impossible to implement double checked locking portably. In C++11 you can make double checked locking work correctly and portably. The way you do it is by declaring <code>valid</code> to be <code>atomic</code>. </p>\n", "LastActivityDate": "2013-06-04T19:49:34.110"}, "bq_ids": {"n4140": {"so_16924525_16924525_0": {"section_id": 1159, "quality": 1.0, "length": 11}, "so_16924525_16924525_1": {"section_id": 1158, "quality": 1.0, "length": 15}}, "n3337": {"so_16924525_16924525_0": {"section_id": 1157, "quality": 1.0, "length": 11}, "so_16924525_16924525_1": {"section_id": 1156, "quality": 1.0, "length": 15}}, "n4659": {"so_16924525_16924525_0": {"section_id": 1253, "quality": 1.0, "length": 11}, "so_16924525_16924525_1": {"section_id": 1252, "quality": 1.0, "length": 15}}}, "16924525": {"CommentCount": "1", "AcceptedAnswerId": "16924704", "PostTypeId": "1", "LastEditorUserId": "671092", "CreationDate": "2013-06-04T18:02:40.027", "LastActivityDate": "2013-09-02T05:13:35.433", "LastEditDate": "2013-06-04T22:48:56.903", "ViewCount": "1256", "FavoriteCount": "4", "Title": "C++11 atomic: why does this code work?", "Id": "16924525", "Score": "5", "Body": "<p>Let's take this struct:</p>\n<pre><code>struct entry {\n    atomic&lt;bool&gt; valid;\n    atomic_flag writing;\n    char payload[128];\n}\n</code></pre>\n<p>Two treads A and B concurrently access this struct this way (let <code>e</code> be an instance of <code>entry</code>):</p>\n<pre><code>if (e.valid) {\n    // do something with e.payload...\n} else {\n    while (e.writing.test_and_set(std::memory_order_acquire));\n    if (!e.valid) {\n       // write e.payload one byte at a time\n       // (the payload written by A may be different from the payload written by B)\n       e.valid = true;\n       e.writing.clear(std::memory_order_release);\n    }\n}\n</code></pre>\n<p>I guess that this code is correct and does not present issues, but I want to understand why it works.</p>\n<p>Quoting the C++ standard (29.3.13):</p>\n<blockquote>\n<p id=\"so_16924525_16924525_0\">Implementations should make atomic stores visible to atomic loads\n  within a <em>reasonable amount of time</em>.</p>\n</blockquote>\n<p>Now, bearing this in mind, imagine that both thread A and B enter the <code>else</code> block. Is this interleave possible?</p>\n<ol>\n<li>Both <code>A</code> and <code>B</code> enter the <code>else</code> branch, because <code>valid</code> is <code>false</code></li>\n<li><code>A</code> sets the <code>writing</code> flag</li>\n<li><code>B</code> starts to spin lock on the <code>writing</code> flag</li>\n<li><code>A</code> reads the <code>valid</code> flag (which is <code>false</code>) and enters the <code>if</code> block</li>\n<li><code>A</code> writes the payload</li>\n<li><code>A</code> writes <code>true</code> on the valid flag; obviously, if <code>A</code> reads <code>valid</code> again, it would read <code>true</code></li>\n<li><code>A</code> clears the <code>writing</code> flag</li>\n<li><code>B</code> sets the <code>writing</code> flag</li>\n<li><strong><code>B</code> reads a stale value of the valid flag (<code>false</code>) and enters the <code>if</code> block</strong></li>\n<li><code>B</code> writes its payload</li>\n<li><code>B</code> writes <code>true</code> on the <code>valid</code> flag</li>\n<li><code>B</code> clears the <code>writing</code> flag</li>\n</ol>\n<p>I hope this is not possible but when it comes to actually answer the question \"why it is not possible?\", I'm not sure of the answer. Here is my idea.</p>\n<p>Quoting from the standard again (29.3.12):</p>\n<blockquote>\n<p id=\"so_16924525_16924525_1\">Atomic read-modify-write operations shall always read the last value\n  (in the modification order) written before the write associated with\n  the read-modify-write operation.</p>\n</blockquote>\n<p><code>atomic_flag::test_and_set()</code> is an atomic read-modify-write operation, as stated in 29.7.5.</p>\n<p>Since <code>atomic_flag::test_and_set()</code> always reads a \"fresh value\", and I'm calling it with the <code>std::memory_order_acquire</code> memory ordering, <strong>then</strong> I cannot read a stale value of the <code>valid</code> flag, because I must see all the side-effects caused by <code>A</code> before the <code>atomic_flag::clear()</code> call (which uses <code>std::memory_order_release</code>).</p>\n<p>Am I correct?</p>\n<p><strong>Clarification</strong>. My whole reasoning (<em>wrong or correct</em>) relies on 29.3.12. For what I understood so far, if we ignore the <code>atomic_flag</code>, reading stale data from <code>valid</code> is possible even if it's <code>atomic</code>. <code>atomic</code> doesn't seem to mean \"always immediately visible\" to every thread. The maximum guarantee you can ask for is a consistent order in the values you read, but you can still read stale data before getting the fresh one. Fortunately, <code>atomic_flag::test_and_set()</code> and every <code>exchange</code> operation have this crucial feature: they always read fresh data. So, only if you acquire/release on the <code>writing</code> flag (not only on <code>valid</code>), then you get the expected behavior. Do you see my point (correct or not)?</p>\n<hr>\n<p><strong>EDIT</strong>: my original question included the following few lines that gained too much attention if compared to the <em>core</em> of the question. I leave them for consistency with the answers that have been already given, but please ignore them if you are reading the question right now.</p>\n<blockquote>\n<p id=\"so_16924525_16924525_2\"><s>Is there any point in <code>valid</code> being an <code>atomic&lt;bool&gt;</code> and</s>\n<s>not a plain <code>bool</code>? Moreover, if it should be an <code>atomic&lt;bool&gt;</code>,</s>\n<s>what is its 'minimum' memory ordering constraint that will not present</s>\n<s>issues?</s></p>\n</blockquote>\n</hr>", "Tags": "<c++><multithreading><c++11><atomic><race-condition>", "OwnerUserId": "671092", "AnswerCount": "4"}});