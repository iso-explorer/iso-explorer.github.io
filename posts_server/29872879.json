post_cb({"bq_ids": {"n4140": {"so_29872879_29879700_1": {"length": 6, "quality": 0.75, "section_id": 49}, "so_29872879_29879700_0": {"length": 38, "quality": 0.926829268292683, "section_id": 261}}, "n3337": {"so_29872879_29879700_1": {"length": 6, "quality": 0.75, "section_id": 44}, "so_29872879_29879700_0": {"length": 38, "quality": 0.926829268292683, "section_id": 252}}, "n4659": {"so_29872879_29879700_1": {"length": 6, "quality": 0.75, "section_id": 50}, "so_29872879_29879700_0": {"length": 38, "quality": 0.926829268292683, "section_id": 268}}}, "29872879": {"ViewCount": "88", "Body": "<p>I was asked, using this code and only writing in the <code>extractMultAdd()</code> function, to return <code>variable.x</code> <code>variable.y</code> <code>variable.add()</code> and <code>variable.multiply</code>. I understand that the basic concept of virtual tables and when they are created, but despite my best efforts, I'm not quite sure how to leverage them to access the private virtual functions. Any help would be appreciated. </p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\nclass MultAdd\n{\n\nprivate:\n    int x;\n    int y;\n    virtual int add()   //virtual fuction so vtable created for Thing class\n    {\n            return x+y;\n    }\n    virtual int multiply()\n    {\n            return x*y;\n    }\npublic:\n    MultAdd(){\n            x = 2;\n            y = 10;\n    }\n};\n\nint extractMultAdd(void* math)\n{\n    return 0;\n}\n\nint main()\n{\n    MultAdd variable;\n    printf(\"%d\\n\", extractMultAdd(&amp;variable));\n    return 0;\n}\n</code></pre>\n", "Title": "Accessing private virtual functions within same class", "CreationDate": "2015-04-26T02:08:00.160", "LastActivityDate": "2015-04-26T15:54:21.493", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "Id": "29872879", "Score": "0", "OwnerUserId": "3079130", "Tags": "<c++><pointers><virtual-functions>", "AnswerCount": "2"}, "29879700": {"Id": "29879700", "PostTypeId": "2", "Body": "<p>Well, if you're looking for a portable way, I could offer the following, which a C++ compiler <a href=\"http://bloglitb.blogspot.com.au/2010/07/access-to-private-members-thats-easy.html\" rel=\"nofollow noreferrer\">must support</a>. It is discussed further <a href=\"https://stackoverflow.com/questions/12993219/access-private-member-using-template-trick\">here</a>. In short, it leverages the fact that access checking rules are bypassed in explicit template instantiations as per 14.7.2p8:</p>\n<blockquote>\n<p id=\"so_29872879_29879700_0\">14.7.2p8 The usual access checking rules do not apply to names used to specify explicit instantiations. [Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception specifications) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible.]</p>\n</blockquote>\n<p>It does <em>almost</em> what you want to do; the only caveat with this is that template declarations cannot be at the function scope as per 14.2:</p>\n<blockquote>\n<p id=\"so_29872879_29879700_1\">A template declaration can appear only as a namespace or class scope declaration</p>\n</blockquote>\n<p>This might break the spirit of the question though the way it is phrased.\nI don't know of any way to weasle the template structs into the function scope, but if there is a similar trick, this could do 100% what you want.</p>\n<pre><code>////////////////////////////////////////////////////////////////////////////////////////\n//// The template classes can unfortunately not be declared inside extractMultAdd ()\n////////////////////////////////////////////////////////////////////////////////////////\n\n#define ROB_PRIVATE_MEMBER_INST(CLASS, TYPE, MEMBER)    \\\ntemplate&lt;typename T&gt;                                    \\\nstruct CLASS##_##MEMBER##_rob_tag {                     \\\n  typedef T CLASS::*type;                               \\\n  friend type get(CLASS##_##MEMBER##_rob_tag);          \\\n};                                                      \\\ntemplate&lt;typename Tag, typename Tag::type M&gt;            \\\nstruct CLASS##_##MEMBER##_rob_private                   \\\n{                                                       \\\n    friend typename Tag::type get(Tag) { return M; }    \\\n};                                                      \\\ntemplate struct CLASS##_##MEMBER##_rob_private&lt;         \\\nCLASS##_##MEMBER##_rob_tag&lt;TYPE&gt; , &amp;CLASS::MEMBER&gt;;     \\\n\n#define ROB_PRIVATE_MEMBER_INST_FN(CLASS, TYPE, MEMBER) \\\ntemplate&lt;typename T&gt;                                    \\\nstruct CLASS##_##MEMBER##_rob_tag {                     \\\n  typedef T type;                                       \\\n  friend type get(CLASS##_##MEMBER##_rob_tag);          \\\n};                                                      \\\ntemplate&lt;typename Tag, typename Tag::type M&gt;            \\\nstruct CLASS##_##MEMBER##_rob_private                   \\\n{                                                       \\\n    friend typename Tag::type get(Tag) { return M; }    \\\n};                                                      \\\ntemplate struct CLASS##_##MEMBER##_rob_private&lt;         \\\nCLASS##_##MEMBER##_rob_tag&lt;TYPE&gt; , &amp;CLASS::MEMBER&gt;;     \\\n\n#define ROB_PRIVATE_MEMBER_ACCESS(CLASS, INSTANCE, TYPE, MEMBER) \\\n    (INSTANCE.*get(CLASS##_##MEMBER##_rob_tag&lt;TYPE&gt;()))          \\\n\n////////////////////////////////////////////////////////////////////////////////////////\n//// Actually use the macros\n////////////////////////////////////////////////////////////////////////////////////////\n\nROB_PRIVATE_MEMBER_INST(MultAdd, int, x);\nROB_PRIVATE_MEMBER_INST(MultAdd, int, y);\nROB_PRIVATE_MEMBER_INST_FN(MultAdd, int(MultAdd::*)(), add);\nROB_PRIVATE_MEMBER_INST_FN(MultAdd, int(MultAdd::*)(), multiply);\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n//ROB_PRIVATE_MEMBER_INST_FN(MultAdd, int(__thiscall *)(), add);\nint extractMultAdd(void* math)\n{\n    // No need to pass as void*\n    MultAdd *pMA(reinterpret_cast&lt;MultAdd*&gt;(math));\n\n    // ROB_PRIVATE_MEMBER_INST(MultAdd, int, x); // Note that unfortunately this isn't possible\n\n    // The 4 values, retrieved in a portable way\n    int robbed_x = ROB_PRIVATE_MEMBER_ACCESS(MultAdd, *pMA, int, x);\n    int robbed_y = ROB_PRIVATE_MEMBER_ACCESS(MultAdd, *pMA, int, y);\n    int robbed_add = ROB_PRIVATE_MEMBER_ACCESS(MultAdd, *pMA, int(MultAdd::*)(), add)();      // Note we're calling function with ()\n    int robbed_mul = ROB_PRIVATE_MEMBER_ACCESS(MultAdd, *pMA, int(MultAdd::*)(), multiply)(); // Note we're calling function with ()\n\n\n    return 0;\n}\n</code></pre>\n<p>Ignore the friend declaration warnings and scroll to output:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b2e61ceff0832fd6\" rel=\"nofollow noreferrer\">Run example</a></p>\n<p>Of course \"only writing in the extractMultAdd() function\" might leave some room for this semantic trickery:</p>\n<pre><code>int extractMultAdd(void* math)\n{\n    return extractMultAdd_impl(math);\n}\n\n// structs\n\nint extractMultAdd_impl(void* math)\n{\n    // original code ...\n} // &lt;== Original brace :)\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-26T15:54:21.493", "Score": "0", "CreationDate": "2015-04-26T15:39:08.687", "ParentId": "29872879", "CommentCount": "0", "OwnerUserId": "1641845", "LastEditDate": "2017-05-23T12:28:18.240"}, "29873283": {"Id": "29873283", "PostTypeId": "2", "Body": "<p>I give you two versions to choose. They do not follow the standard, and are by no means portable, but both work on MSVC 2013, GCC 4.9, and clang 3.5 as I test it. The second version is relatively safer and more portable than the first one. In fact, I expect it to be rather robust.</p>\n<p><strong>Version 1:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nclass MultAdd {\nprivate:\n  int x;\n  int y;\n  virtual int add() { return x + y; }\n  virtual int multiply() { return x * y; }\npublic:\n  MultAdd() {\n    x = 2;\n    y = 10;\n  }\n};\n\nstruct MultAddCracker: MultAdd {\n  int add();\n  int multiply();\n};\n\nvoid extractMultAdd(MultAdd&amp; v) {\n  char* p = (char*)&amp;v;\n  std::cout &lt;&lt; *(int*)(p + sizeof(void*)) &lt;&lt; '\\n';\n  std::cout &lt;&lt; *(int*)(p + sizeof(void*) + sizeof(int)) &lt;&lt; '\\n';\n  MultAddCracker* pcracker = (MultAddCracker*)&amp;v;\n  std::cout &lt;&lt; pcracker-&gt;add() &lt;&lt; '\\n';\n  std::cout &lt;&lt; pcracker-&gt;multiply() &lt;&lt; '\\n';\n}\n\nint main() {\n  MultAdd v;\n  extractMultAdd(v);\n}\n</code></pre>\n<p><strong>Version 2:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nclass MultAdd {\nprivate:\n  int x;\n  int y;\n  virtual int add() { return x + y; }\n  virtual int multiply() { return x * y; }\npublic:\n  MultAdd() {\n    x = 2;\n    y = 10;\n  }\n};\n\nstruct MultAddCracker {\n  int x;\n  int y;\n  virtual int add();\n  virtual int multiply();\n};\n\nvoid extractMultAdd(MultAdd&amp; v) {\n  MultAddCracker&amp; w = (MultAddCracker&amp;)v;\n  std::cout &lt;&lt; w.x &lt;&lt; '\\n';\n  std::cout &lt;&lt; w.y &lt;&lt; '\\n';\n  std::cout &lt;&lt; w.add() &lt;&lt; '\\n';\n  std::cout &lt;&lt; w.multiply() &lt;&lt; '\\n';\n}\n\nint main() {\n  MultAdd v;\n  extractMultAdd(v);\n}\n</code></pre>\n", "LastEditorUserId": "1348273", "LastActivityDate": "2015-04-26T03:44:39.050", "Score": "0", "CreationDate": "2015-04-26T03:13:00.107", "ParentId": "29872879", "CommentCount": "3", "OwnerUserId": "1348273", "LastEditDate": "2015-04-26T03:44:39.050"}});