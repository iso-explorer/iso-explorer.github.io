post_cb({"bq_ids": {"n4140": {"so_17957838_17958848_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7107}, "so_17957838_17958848_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 7113}, "so_17957838_17958848_1": {"length": 11, "quality": 1.0, "section_id": 7110}, "so_17957838_17958848_3": {"length": 9, "quality": 1.0, "section_id": 5861}}, "n3337": {"so_17957838_17958848_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6851}, "so_17957838_17958848_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 6857}, "so_17957838_17958848_1": {"length": 11, "quality": 1.0, "section_id": 6854}, "so_17957838_17958848_3": {"length": 9, "quality": 1.0, "section_id": 5631}}, "n4659": {"so_17957838_17958848_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 8608}, "so_17957838_17958848_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 8614}, "so_17957838_17958848_1": {"length": 11, "quality": 1.0, "section_id": 8611}, "so_17957838_17958848_3": {"length": 9, "quality": 1.0, "section_id": 7340}}}, "17958848": {"Id": "17958848", "PostTypeId": "2", "Body": "<p><strong>Take 2</strong></p>\n<p><code>struct a ::b;</code> is a well-formed declaration of <code>struct a::b</code>.</p>\n<p>It is not a <em>forward</em> declaration because <code>struct a::b</code> has already been\ndefined. The Standard does not formally define <em>forward declaration</em> but it \nis universally accepted to mean a declaration of something that precedes and \nis separate from its definition.</p>\n<p>Nor is it a declaration of the global variable <code>b</code>.</p>\n<p>The whitespace is insignificant, so in order for the putative declaration to\nhave the suggested ambiguity,</p>\n<pre><code>/*A*/ struct a::b;\n</code></pre>\n<p>would of course have to have the same ambiguity. Rewritten like that, we might \nwell agree that it is perfectly obvious what the declaration should mean; but we'd\nlike to know whether that obvious meaning is vindicated by the Standard.</p>\n<p>I will confine my consideration to the C++11 Standard. (I think a resolution\nof the question from the C++03 Standard is actually more straightforward).</p>\n<p>The Standard distinguishes the <em>unary scope operator</em> <code>::</code> from the <em>scope\nresolution operator</em> <code>::</code>.</p>\n<p>\u00a7 3.4.3 <strong>Qualified name lookup</strong>, para 1:</p>\n<blockquote>\n<p id=\"so_17957838_17958848_0\">The name of a class or namespace member or enumerator can be referred to after the :: scope resolution\n  operator (5.1) applied to a nested-name-specifier that denotes its class, namespace, or enumeration.</p>\n</blockquote>\n<p>\u00a7 3.4.3 <strong>Qualified name lookup</strong>, para 4:</p>\n<blockquote>\n<p id=\"so_17957838_17958848_1\">A name prefixed by the unary scope operator :: (5.1) is looked up in global scope, in the translation unit\n  where it is used.</p>\n</blockquote>\n<p>These citations are not offered to <em>explain</em> the distinction, just to show that\nit exists. But they deliver right away the point that in <code>/*A*/</code>\nthe operator would have to be the <em>unary scope operator</em> for \u00a7 3.4.3/4 to\nsustain the global-<code>::b</code> interpretation of <code>/*A*/</code>.</p>\n<p>It might well again be obvious that the scope operator in <code>/*A*/</code> is <em>not</em>\nthe unary one. But we are referred to \u00a7 5.1 <strong>Primary expressions</strong> for\nthe grammatical definitions of the <em>unary scope operator</em> and <em>scope\nresolution operator</em>, and in any case we have yet to see what is said about the\nlookup of <code>b</code> when if is the right-hand operand of the <em>scope\nresolution operator</em>.</p>\n<p>At \u00a7 5.1.1/8 we find that the operator <code>::</code> is defined as the\ninfix operator of \u00a7 3.4.3/1 and also as the unary operator of \n\u00a7 3.4.3/4 in the grammar of  <em>qualified-id</em>:</p>\n<pre><code>qualified-id:\n    nested-name-specifier template[opt] unqualified-id\n   :: identifier\n   :: operator-function-id\n   :: literal-operator-id\n   :: template-id\nnested-name-specifier:\n    ::[opt] type-name ::\n    ::[opt] namespace-name ::\n    decltype-specifier ::\n    nested-name-specifier identifier ::\n    nested-name-specifier template[opt] simple-template-id ::\n</code></pre>\n<p>It is the infix operator when it is the final token of a \n<em>nested-name-specifier</em> followed, optionally by <code>template</code>, and\nthen an <em>unqualified-id</em> and otherwise it is the unary operator in\nthe contexts:</p>\n<pre><code>:: identifier\n:: operator-function-id\n:: literal-operator-id\n:: template-id\n</code></pre>\n<p>According to this grammar, the <code>::</code> operator must left-associate with a \n<em>nested-name-specifier</em> (forming the scope resolution operator) if\nit can. According to the grammar, <code>a::</code> in <code>/*A*/</code> is a <em>nested-name-specifier</em>\nand <code>a::b</code> is a <em>qualified-id</em> of the first form \n<em>nested-name-specifier template[opt] unqualified-id</em>.</p>\n<p>So we are assured that \u00a7 3.4.3 <strong>Qualified name lookup</strong> applies to <code>b</code> in\n<code>/*A*/</code> and can refer to \u00a7 3.4.3.1 <strong>Class members</strong>, para 1,\nfor the conclusion that <code>b</code> in that context is to be looked up in <code>a</code>, not globally:</p>\n<blockquote>\n<p id=\"so_17957838_17958848_2\">If the nested-name-specifier of a qualified-id nominates a class, the name specified after the nested-name-\n  specifier is looked up in the scope of the class (10.2), except for the cases listed below.</p>\n</blockquote>\n<p>None of \"the cases listed below\" applies to <code>/*A*/</code>, and if there is any doubt that\nthe nested class <code>a::b</code> counts as a <em>member</em> of <code>a</code>, \u00a7 9.2 <strong>Class members</strong>, \npara 1, removes it:</p>\n<blockquote>\n<p id=\"so_17957838_17958848_3\">Members of a class are data members, member functions (9.3), nested types, and\n  enumerators.</p>\n</blockquote>\n<p>Having found that <code>a::b</code> unamiguously requires <code>b</code> to be looked up in <code>a</code>,\nthe question of the well-formed-ness of <code>/*A*/</code> becomes the question of whether\n<code>/*A*/</code> is a <em>declaration</em> per Standard (as certainly <code>struct a;</code> in the same\nplace would be).</p>\n<p>It is, and we can make sure of this by several steps down through the\n<em>declaration</em>-grammar:-</p>\n<ul>\n<li><p>Per \u00a7 7 <strong>Declarations</strong>, para 1, a <em>declaration</em> may be a <em>simple-declaration</em>,\nand a <em>simple-declaration</em> may be a <em>decl-specifier-seq</em>.</p></li>\n<li><p>Per \u00a7 7.1 <strong>Specifiers</strong>, para 1, a <em>decl-specifier-seq</em> may be a <em>decl-specifier</em>,\nand <em>decl-specifier</em> may be a <em>type-specifier</em>.</p></li>\n<li><p>Per \u00a7 7.1.6 <strong>Type Specifiers</strong>, para 1, a <em>type-specifier</em> may be an\n<em>elaborated-type-specifier</em>.</p></li>\n<li><p>Per \u00a7 7.1.6.3 <strong>Elaborated type specifiers</strong>, para 0, an <em>elaborated-type-specifier</em>\nmay be:</p>\n<p><code>class-key attribute-specifier-seq[opt] nested-name-specifier[opt] identifier</code></p></li>\n</ul>\n<p>where <em>class-key</em> is <code>class</code>, <code>struct</code> or <code>union</code> (per \u00a7 9 <strong>Classes</strong>, para 1)\nand the optional <em>attribute-specifier-seq</em> does not matter because we do not\nneed it.</p>\n<p><code>/*A*/</code> satisfies:</p>\n<pre><code>class-key nested-name-specifier identifier\n</code></pre>\n<p>So it is a declaration.</p>\n<p>Per Standard, <code>/*A*/</code> is a redeclaration of <code>a::b</code>.</p>\n<p><strong>Some comments on GCC and CLANG</strong></p>\n<p>Clang 3.3 diagnoses the posted code:</p>\n<pre><code>error: forward declaration of struct cannot have a nested name specifier\n</code></pre>\n<p>This is wrong because the declaration is not forward. If we move the offending \ndeclaration so that it <em>does</em> precede the definition of <code>a::b</code> then clang does not\nfault an ill-formed forward declaration but instead diagnoses:</p>\n<pre><code>error: use of undeclared identifier 'a'\n</code></pre>\n<p>And if we replace <code>struct a ::b;</code> in the program with <code>struct a ::b x;</code> then\nclang finds no fault with the line, therefore having found a definition of\n<code>a::b</code> at the same point where previously it held that type to be (illegally)\nforward-declared.</p>\n<p>GCC 4.8.1 diagnoses:</p>\n<pre><code>warning: declaration \u2018struct a::b\u2019 does not declare anything\nundefined reference to `b'\n</code></pre>\n<p>The warning, being just a warning, is consistent with the declaration\nbeing a well-formed redeclaration but might more helpfully append the\nword \"new\". If we move the offending declaration so that it\nactually is forward then GCC, naturally, gives the same error as clang.</p>\n<p>The second linkage error refers to the undefined <code>extern struct b</code>\nthat is called through in <code>main</code>, and which was correctly <em>not</em> supplied\nwith a definition by <code>struct a ::b;</code>.</p>\n", "LastEditorUserId": "1362568", "LastActivityDate": "2013-07-31T19:40:47.390", "Score": "-3", "CreationDate": "2013-07-30T22:51:49.637", "ParentId": "17957838", "CommentCount": "5", "OwnerUserId": "1362568", "LastEditDate": "2013-07-31T19:40:47.390"}, "17957838": {"ViewCount": "646", "Body": "<p>Is the following C++11 program ill-formed?</p>\n<pre><code>struct a\n{\n    struct b {  };\n\n    void f() {};\n};\n\nextern struct a b;\n\nstruct a ::b;\n\nint main()\n{\n    b.f();\n}\n</code></pre>\n<p>Why / why not?</p>\n<p>The thing of interest here is this line:</p>\n<pre><code>struct a ::b;\n</code></pre>\n<p>Is this a forward declaration of the inner class <code>a::b</code>?</p>\n<p>Or is this a definition of the global variable <code>b</code>?  Equivalent to:</p>\n<pre><code>struct a (::b);\n</code></pre>\n", "Title": "C++11 ambiguity between single qualified name and two consecutive?", "CreationDate": "2013-07-30T21:33:34.257", "LastActivityDate": "2013-07-31T19:40:47.390", "CommentCount": "12", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-07-30T21:49:44.057", "LastEditorUserId": "1131467", "Id": "17957838", "Score": "10", "OwnerUserId": "1131467", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "17957928": {"Id": "17957928", "PostTypeId": "2", "Body": "<p><code>struct a ::b;</code> doesn't declare a variable named <code>b</code> of type <code>a</code>, if that's what you are asking. It's a (redundant) forward declaration of the nested type <code>a::b</code>. Whitespace is not generally significant in a C++ program. So your program declares, but never defines, a variable named <code>b</code>. That's a violation of One Definition Rule: the program is therefore ill-formed, and the linker will tell you as much.</p>\n", "LastActivityDate": "2013-07-30T21:39:44.707", "CommentCount": "22", "CreationDate": "2013-07-30T21:39:44.707", "ParentId": "17957838", "Score": "1", "OwnerUserId": "1670129"}});