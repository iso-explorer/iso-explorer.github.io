post_cb({"bq_ids": {"n4140": {"so_47844058_47845780_4": {"length": 97, "quality": 0.8083333333333333, "section_id": 7177}, "so_47844058_47845780_3": {"length": 7, "quality": 0.875, "section_id": 7242}, "so_47844058_47845780_2": {"length": 7, "quality": 1.0, "section_id": 7242}, "so_47844058_47845780_8": {"length": 41, "quality": 0.8723404255319149, "section_id": 6095}, "so_47844058_47845780_0": {"length": 94, "quality": 0.8952380952380953, "section_id": 7177}, "so_47844058_47845780_1": {"length": 15, "quality": 1.0, "section_id": 7241}}, "n3337": {"so_47844058_47845780_4": {"length": 95, "quality": 0.7916666666666666, "section_id": 6921}, "so_47844058_47845780_3": {"length": 7, "quality": 0.875, "section_id": 6986}, "so_47844058_47845780_2": {"length": 7, "quality": 1.0, "section_id": 6986}, "so_47844058_47845780_8": {"length": 41, "quality": 0.8723404255319149, "section_id": 5861}, "so_47844058_47845780_0": {"length": 95, "quality": 0.9047619047619048, "section_id": 6921}, "so_47844058_47845780_1": {"length": 15, "quality": 1.0, "section_id": 6985}}, "n4659": {"so_47844058_47845780_4": {"length": 112, "quality": 0.9333333333333333, "section_id": 8685}, "so_47844058_47845780_5": {"length": 5, "quality": 1.0, "section_id": 7592}, "so_47844058_47845780_3": {"length": 7, "quality": 0.875, "section_id": 8751}, "so_47844058_47845780_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 8751}, "so_47844058_47845780_8": {"length": 45, "quality": 0.9574468085106383, "section_id": 7592}, "so_47844058_47845780_0": {"length": 91, "quality": 0.8666666666666667, "section_id": 8685}, "so_47844058_47845780_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 8750}}}, "47845780": {"Id": "47845780", "PostTypeId": "2", "Body": "<p>basic.stc.dynamic.allocation/2 of N3337 (basically C++11):</p>\n<blockquote>\n<p id=\"so_47844058_47845780_0\">The allocation function attempts to allocate the requested amount of\n  storage. If it is successful, it shall return the address of the start\n  of a block of storage whose length in bytes shall be at least as large\n  as the requested size. There are no constraints on the contents of the\n  allocated storage on return from the allocation function. The order,\n  contiguity, and initial value of storage allocated by successive calls\n  to an allocation function are unspeci\ufb01ed. <strong>The pointer returned shall\n  be suitably aligned so that it can be converted to a pointer of any\n  complete object type with a fundamental alignment requirement</strong> (3.11)\n  and then used to access the object or array in the storage allocated\n  (until the storage is explicitly deallocated by a call to a\n  corresponding deallocation function). Even if the size of the space\n  requested is zero, the request can fail. If the request succeeds, the\n  value returned shall be a non-null pointer value (4.10) p0 di\ufb00erent\n  from any previously returned value p1, unless that value p1 was\n  subsequently passed to an operator delete. The e\ufb00ect of dereferencing\n  a pointer returned as a request for zero size is unde\ufb01ned.</p>\n</blockquote>\n<p>Fundamental alignment (basic.align/2):</p>\n<blockquote>\n<p id=\"so_47844058_47845780_1\">A fundamental alignment is represented by an alignment less than or\n  equal to the greatest alignment supported by the implementation in\n  all contexts, which is equal to alignof(std::max_align_t)</p>\n</blockquote>\n<p>Extended alignment (basic.align/3):</p>\n<blockquote>\n<p id=\"so_47844058_47845780_2\">An extended alignment is represented by an alignment greater than\n  alignof(std::max_align_t).</p>\n<p id=\"so_47844058_47845780_3\">It is implementation-de\ufb01ned whether any extended alignments are\n  supported and the contexts in which they are supported</p>\n</blockquote>\n<p>So, the returned pointer by <code>operator new</code> must have fundamental alignment. Even if zero size specified. And it is implementation defined, whether 8 is fundamental or extended alignment. If it is fundamental, then <code>Foo</code> is OK. If it is extended, then it is implementation defined that <code>Foo</code> is supported with <code>operator new</code>.</p>\n<p>Note, that for C++17, the situation is improved:</p>\n<hr>\n<p><a href=\"http://eel.is/c++draft/basic.stc.dynamic#allocation-2\" rel=\"noreferrer\">basic.stc.dynamic.allocation/2 of C++17</a>:</p>\n<blockquote>\n<p id=\"so_47844058_47845780_4\">The allocation function attempts to allocate the requested amount of\n  storage. If it is successful, it shall return the address of the start\n  of a block of storage whose length in bytes shall be at least as large\n  as the requested size. There are no constraints on the contents of the\n  allocated storage on return from the allocation function. The order,\n  contiguity, and initial value of storage allocated by successive calls\n  to an allocation function are unspecified. <strong>The pointer returned shall\n  be suitably aligned so that it can be converted to a pointer to any\n  suitable complete object type</strong> ([new.delete.single]) and then used to\n  access the object or array in the storage allocated (until the storage\n  is explicitly deallocated by a call to a corresponding deallocation\n  function). Even if the size of the space requested is zero, the\n  request can fail. If the request succeeds, the value returned shall be\n  a non-null pointer value ([conv.ptr]) p0 different from any previously\n  returned value p1, unless that value p1 was subsequently passed to an\n  operator delete. Furthermore, for the library allocation functions in\n  [new.delete.single] and [new.delete.array], p0 shall represent the\n  address of a block of storage disjoint from the storage for any other\n  object accessible to the caller. The effect of indirecting through a\n  pointer returned as a request for zero size is undefined.</p>\n</blockquote>\n<p>I've put emphasis on the relevant part. That sentence means that the returned pointer of <code>void *operator new(...)</code> should have suitable alignment. It doesn't mention zero size as a special case (but, of course, it is UB to dereference the returned pointer).</p>\n<p>So the answer is the usual, there is no special handling of zero: </p>\n<ol>\n<li><code>void *operator new(std::size_t)</code> must return an aligned pointer of <code>alignof(std\u200b::\u200bmax_\u00adalign_\u00adt)</code></li>\n<li><code>void *operator new(std::size_t, std::align_val_t align)</code> must return an aligned pointer of <code>align</code>)</li>\n</ol>\n<p>Note that it is implementation defined, which version will be called for <code>Foo</code>. It depends on whether 8 is equal or less than <code>alignof(std\u200b::\u200bmax_\u00adalign_\u00adt)</code>. If it is less, then the 1st version is called (because it doesn't have <em>extended alignment</em>). Otherwise the 2nd is called.</p>\n<hr>\n<p>UPDATE: As Massimiliano Janes comments, these paragraphs apply to the result of <code>operator new</code>, not to the result of new expression. An implementation could add an arbitrary offset to the result of <code>operator new[]</code>. And the standard is silent about the value of this <code>x</code> offset:</p>\n<blockquote>\n<p id=\"so_47844058_47845780_5\">new T[5] results in one of the following calls:</p>\n<p id=\"so_47844058_47845780_6\">operator new[](sizeof(T) * 5 + x)</p>\n<p id=\"so_47844058_47845780_7\">operator new[](sizeof(T) * 5 + x, std::align_val_t(alignof(T)))</p>\n<p id=\"so_47844058_47845780_8\">Here, each instance of x is a non-negative unspecified value\n  representing array allocation overhead; the result of the\n  new-expression will be offset by this amount from the value returned\n  by operator new[]. This overhead may be applied in all array\n  new-expressions, including those referencing the library function\n  operator new[](std\u200b::\u200bsize_\u00adt, void*) and other placement allocation\n  functions. The amount of overhead may vary from one invocation of new\n  to another.</p>\n</blockquote>\n<p>However, in my opinion, this <code>x</code> offset cannot be arbitrary. If it is not a multiple of alignment, then the new expression would return a non-aligned pointer (in all cases. Not just the zero, but the non-zero size parameter as well). That's clearly not we want.</p>\n<p>So I think this is a hole in the standard. Value of <code>x</code> should be constrained to be a multiple of alignment (at least in the non-zero allocation case). But because of this omission, it seems that the standard doesn't guarantee that a <code>new[]</code> expression returns an aligned pointer at all (in the non-zero case as well).</p>\n</hr></hr>", "LastEditorUserId": "8157187", "LastActivityDate": "2017-12-16T16:41:31.747", "Score": "8", "CreationDate": "2017-12-16T12:41:09.783", "ParentId": "47844058", "CommentCount": "7", "OwnerUserId": "8157187", "LastEditDate": "2017-12-16T16:41:31.747"}, "47844058": {"ViewCount": "379", "Body": "<p>C++ <a href=\"https://herbsutter.com/2009/09/02/when-is-a-zero-length-array-okay/\" rel=\"noreferrer\">allows dynamic allocation of zero-sized arrays</a>:</p>\n<pre><code>int* p = new int[0];\ndelete[] p;\n</code></pre>\n<p>I can't do much with such a pointer (as the array has no elements), but the new expression is required to give me back a valid (<code>!= nullptr</code>) pointer which I then have to <code>delete[]</code> again as if it was an actual array.</p>\n<p>Are there any requirements regarding the alignment of the memory returned by such a new expression? Consider:</p>\n<pre><code>struct alignas(8) Foo {\n    int x;\n};\n\nFoo* p = new Foo[0];\ndelete[] p;\n</code></pre>\n<p>Is <code>p</code> guaranteed to point to an 8-aligned address? Furthermore, if I write a custom allocator, am I required to return pointers to aligned addresses in such a case?</p>\n", "Title": "Alignment of array with 0 elements", "CreationDate": "2017-12-16T08:53:39.750", "LastActivityDate": "2017-12-16T16:41:31.747", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-12-16T09:06:17.287", "LastEditorUserId": "577603", "Id": "47844058", "Score": "22", "OwnerUserId": "577603", "Tags": "<c++><c++11><language-lawyer><allocator>", "AnswerCount": "1"}});