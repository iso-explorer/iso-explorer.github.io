post_cb({"24343032": {"ParentId": "24342941", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>From the standard Ch. 12 - Special member functions </p>\n<p>Par 12.8 <strong>Copying and moving class objects</strong> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_24342941_24343032_0\">9 . If the definition of a class X does not explicitly declare a move constructor, <strong>one will be implicitly declared as defaulted if and only if</strong></p>\n<p id=\"so_24342941_24343032_1\">\u2014 X does not have a user-declared copy constructor,</p>\n<p id=\"so_24342941_24343032_2\">\u2014 X does not have a user-declared copy assignment operator,</p>\n<p id=\"so_24342941_24343032_3\">\u2014 X does not have a user-declared move assignment operator, and</p>\n<p id=\"so_24342941_24343032_4\">\u2014 X does not have a user-declared destructor.</p>\n<p id=\"so_24342941_24343032_5\">[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that\n  otherwise would have invoked the move constructor may instead invoke a copy constructor. \u2014end note ]</p>\n</blockquote>\n<p>Then <code>11</code> explains the rules for deleting the defaulted move constructor</p>\n<blockquote>\n<p id=\"so_24342941_24343032_6\">11 . An implicitly-declared copy/move constructor is an inline public member of its class. <strong>A defaulted copy/ move constructor for a class X is defined as deleted (8.4.3) if X has:</strong></p>\n<p id=\"so_24342941_24343032_7\">\u2014 a variant member with a non-trivial corresponding constructor and X is a union-like class,</p>\n<p id=\"so_24342941_24343032_8\">\u2014 a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</p>\n<p id=\"so_24342941_24343032_9\">\u2014 a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</p>\n<p id=\"so_24342941_24343032_10\">\u2014 any direct or virtual base class or non-static data member of a type with a destructor that is deleted or inaccessible from the defaulted constructor, or,</p>\n<p id=\"so_24342941_24343032_11\">\u2014 for the copy constructor, a non-static data member of rvalue reference type. A defaulted move constructor that is defined as deleted is ignored by overload resolution (13.3, 13.4).</p>\n<p id=\"so_24342941_24343032_12\">[ Note: A deleted move constructor would otherwise interfere with initialization from an rvalue which can use the copy constructor instead. \u2014end note ]</p>\n</blockquote>\n<hr>\n<h2>On the complexity of it all *</h2>\n<p>The rules can be somewhat overwhelming. It's good to use some technique to <strong>bypass the complexity</strong>. Examples are : </p>\n<ol>\n<li>Make use of the <a href=\"http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html\" rel=\"nofollow noreferrer\">rule of zero</a> to simplify the writing of the majority of your classes.  </li>\n<li>(On implicitly deleted) Explicitly default the special member function in question; if it would have been implicitly defined as deleted, the compiler will complain.</li>\n</ol>\n<p><sup>* points made in the comments by myself (1) and <a href=\"https://stackoverflow.com/users/420683/dyp\">dyp</a> (2)</sup></p>\n</hr>", "OwnerUserId": "2567683", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:33.110", "Id": "24343032", "Score": "25", "CreationDate": "2014-06-21T15:22:59.787", "LastActivityDate": "2014-07-01T06:35:58.880"}, "24512883": {"ParentId": "24342941", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Nikos Athanasiou gave a good answer but I wanted to add this tool that I think is very useful.</p>\n<p>Here is a screenshot of Howard Hinnant's presentation <a href=\"http://accu.org/content/conf2014/Howard_Hinnant_Accu_2014.pdf\" rel=\"noreferrer\">\"Everything You Ever Wanted To Know About Move Semantics (and then some)\"</a> from ACCU 2014 conference which I think is a very good reminder of the rules of automatic generation of special members:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/b2VBV.png\"/></p>\n<p>Clarification from Mr Hinnant from the comments: </p>\n<blockquote>\n<p id=\"so_24342941_24512883_0\">The slide doesn't say it, but the red squares indicate deprecated\n  behavior. I.e. if you don't want to depend upon deprecated behavior,\n  then declare both of your copy members if you declare your destructor,\n  or one of the copy members (basically follow the C++98/03 \"rule of 3\")</p>\n</blockquote>\n<p>I recommend reading <a href=\"http://accu.org/content/conf2014/Howard_Hinnant_Accu_2014.pdf\" rel=\"noreferrer\">the slides</a> to get the progressive construction of this table and have a detailed explanation of how and why we have this now.</p>\n<p>Other presentations can be found there: <a href=\"http://accu.org/index.php/articles/1901\" rel=\"noreferrer\">http://accu.org/index.php/articles/1901</a></p>\n", "OwnerUserId": "2368", "LastEditorUserId": "2368", "LastEditDate": "2014-07-01T18:40:48.057", "Id": "24512883", "Score": "34", "CreationDate": "2014-07-01T14:32:33.303", "LastActivityDate": "2014-07-01T18:40:48.057"}, "24342941": {"CommentCount": "5", "AcceptedAnswerId": "24343032", "CreationDate": "2014-06-21T15:12:28.910", "LastActivityDate": "2014-07-01T18:40:48.057", "PostTypeId": "1", "ViewCount": "3285", "FavoriteCount": "20", "Title": "What are the rules for automatic generation of move operations?", "Id": "24342941", "Score": "24", "Body": "<p>In C++98, the C++ compiler could <em>automatically</em> generate copy constructor and copy assignment operator via member-wise copy, e.g.</p>\n<pre><code>struct X {\n    std::string s;\n    std::vector&lt;int&gt; v;\n    int n;\n};\n</code></pre>\n<p>The compiler <em>automatically</em> generates copy constructor and copy assignment operator for <code>X</code>, using member-wise copy.</p>\n<p>But how do things change in C++11 with move semantics?</p>\n<p>Are the <strong><em>move</em></strong> <strong>constructor</strong> and <strong><em>move</em></strong> <strong>assignment operator</strong> <em>automatically</em> generated, like copy constructors and copy assignment operators?</p>\n<p>Are there cases in which move operations are <em>not</em> automatically generated?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "1629821", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24342941_24343032_4": {"section_id": 458, "quality": 1.0, "length": 4}, "so_24342941_24343032_0": {"section_id": 458, "quality": 1.0, "length": 12}, "so_24342941_24343032_9": {"section_id": 460, "quality": 0.8, "length": 16}, "so_24342941_24343032_10": {"section_id": 369, "quality": 0.7692307692307693, "length": 10}, "so_24342941_24343032_2": {"section_id": 458, "quality": 1.0, "length": 6}, "so_24342941_24343032_1": {"section_id": 458, "quality": 1.0, "length": 5}, "so_24342941_24343032_12": {"section_id": 460, "quality": 0.8125, "length": 13}, "so_24342941_24343032_8": {"section_id": 460, "quality": 0.8695652173913043, "length": 20}, "so_24342941_24343032_11": {"section_id": 460, "quality": 0.8888888888888888, "length": 16}, "so_24342941_24343032_5": {"section_id": 458, "quality": 0.8636363636363636, "length": 19}, "so_24342941_24343032_6": {"section_id": 460, "quality": 0.875, "length": 14}, "so_24342941_24343032_3": {"section_id": 458, "quality": 1.0, "length": 6}, "so_24342941_24343032_7": {"section_id": 460, "quality": 1.0, "length": 7}}, "n3337": {"so_24342941_24343032_4": {"section_id": 449, "quality": 1.0, "length": 4}, "so_24342941_24343032_0": {"section_id": 449, "quality": 1.0, "length": 12}, "so_24342941_24343032_9": {"section_id": 451, "quality": 0.95, "length": 19}, "so_24342941_24343032_10": {"section_id": 359, "quality": 1.0, "length": 13}, "so_24342941_24343032_2": {"section_id": 449, "quality": 1.0, "length": 6}, "so_24342941_24343032_1": {"section_id": 449, "quality": 1.0, "length": 5}, "so_24342941_24343032_8": {"section_id": 451, "quality": 0.9565217391304348, "length": 22}, "so_24342941_24343032_3": {"section_id": 449, "quality": 1.0, "length": 6}, "so_24342941_24343032_11": {"section_id": 451, "quality": 0.5555555555555556, "length": 10}, "so_24342941_24343032_5": {"section_id": 449, "quality": 0.8636363636363636, "length": 19}, "so_24342941_24343032_6": {"section_id": 451, "quality": 0.875, "length": 14}, "so_24342941_24343032_7": {"section_id": 451, "quality": 1.0, "length": 7}}, "n4659": {"so_24342941_24343032_4": {"section_id": 481, "quality": 1.0, "length": 4}, "so_24342941_24343032_0": {"section_id": 481, "quality": 1.0, "length": 12}, "so_24342941_24343032_9": {"section_id": 483, "quality": 0.8, "length": 16}, "so_24342941_24343032_10": {"section_id": 382, "quality": 0.7692307692307693, "length": 10}, "so_24342941_24343032_3": {"section_id": 481, "quality": 1.0, "length": 6}, "so_24342941_24343032_2": {"section_id": 481, "quality": 1.0, "length": 6}, "so_24342941_24343032_12": {"section_id": 483, "quality": 0.8125, "length": 13}, "so_24342941_24343032_8": {"section_id": 483, "quality": 0.8695652173913043, "length": 20}, "so_24342941_24343032_11": {"section_id": 483, "quality": 0.8888888888888888, "length": 16}, "so_24342941_24343032_5": {"section_id": 481, "quality": 0.8636363636363636, "length": 19}, "so_24342941_24343032_6": {"section_id": 483, "quality": 0.875, "length": 14}, "so_24342941_24343032_7": {"section_id": 483, "quality": 1.0, "length": 7}, "so_24342941_24343032_1": {"section_id": 481, "quality": 1.0, "length": 5}}}});