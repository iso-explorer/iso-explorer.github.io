post_cb({"48464023": {"Id": "48464023", "PostTypeId": "2", "Body": "<p>Use an constexpr array of pointer-to-member:</p>\n<pre><code>#include &lt;math.h&gt;\n\nstruct Point {\n    double x;\n    double y;\n    double z;\n};\n\ndouble dist(struct Point *p1, struct Point *p2) {\n    constexpr double Point::* coords[3] = {&amp;Point::x, &amp;Point::y, &amp;Point::z};\n\n    double d2 = 0;\n    for (int i=0; i&lt;3; i++) {\n        double d = p1-&gt;*coords[i] - p2-&gt;*coords[i];\n        d2 += d * d;\n    }\n    return sqrt(d2);\n}\n</code></pre>\n", "LastEditorUserId": "9167702", "LastActivityDate": "2018-01-26T15:11:36.820", "Score": "22", "CreationDate": "2018-01-26T15:05:32.317", "ParentId": "48463521", "CommentCount": "8", "OwnerUserId": "9167702", "LastEditDate": "2018-01-26T15:11:36.820"}, "48463521": {"ViewCount": "1475", "Body": "<p>This is a C++ followup for <a href=\"https://stackoverflow.com/q/48384399/3545273\">another question of mine</a></p>\n<p>In the old days of pre-ISO C, the following code would have surprised nobody:</p>\n<pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n};\ndouble dist(struct Point *p1, struct Point *p2) {\n    double d2 = 0;\n    double *coord1 = &amp;p1-&gt;x;\n    double *coord2 = &amp;p2-&gt;x;\n    int i;\n    for (i=0; i&lt;3; i++) {\n        double d = coord2[i]  - coord1[i];    // THE problem\n        d2 += d * d;\n    }\n    return sqrt(d2);\n}\n</code></pre>\n<p>Unfortunately, this problematic line uses pointer arithmetic (<code>p[i]</code> being <em>by definition</em> <code>*(p + i))</code> outside of any array which is explicitely not allowed by the standard. Draft 4659 for C++17 says in 8.7 [expr.add]:</p>\n<blockquote>\n<p id=\"so_48463521_48463521_0\">If the expression P points to element x[i] of an array object x with n elements,\n  the expressions P + J and J + P (where J has the value j) point to the (possibly-hypothetical) element\n  x[i + j] if 0 &lt;= i + j &lt;= n; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>And the (non-normative) note 86 makes it even more explicit:</p>\n<blockquote>\n<p id=\"so_48463521_48463521_1\">An object that is not an array element is considered to belong to a single-element array for this purpose. A\n  pointer past the last element of an array x of n elements is considered to be equivalent to a pointer to a hypothetical element\n  x[n] for this purpose.</p>\n</blockquote>\n<p>The accepted answer of the referenced question uses the fact that the C language accepts <em>type punning</em> through unions, but I could never find the equivalent in the C++ standard. So I assume that a union containing an anonymous struct member and an array would lead to <code>Undefined Behaviour</code> in C++ \u2014 they <strong>are</strong> different languages...</p>\n<h2>Question:</h2>\n<p>What could be a conformant way to iterate through members of a struct as if they were members of an array in C++? I am searching for a way in current (C++17) versions, but solutions for older versions are also welcome.</p>\n<h3>Disclaimer:</h3>\n<p>It obviously only applies to elements of same type, and padding can be detected with a simple <code>assert</code> as shown in that other <a href=\"https://stackoverflow.com/q/48148477/3545273\">question</a>, so padding, alignment, and mixed types are not my problem here.</p>\n", "AcceptedAnswerId": "48464023", "Title": "Aliasing struct and array the C++ way", "CreationDate": "2018-01-26T14:36:56.923", "LastActivityDate": "2018-01-29T10:11:53.827", "CommentCount": "13", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2018-01-29T10:11:53.827", "LastEditorUserId": "4944425", "Id": "48463521", "Score": "24", "OwnerUserId": "3545273", "Tags": "<c++><c><arrays><struct><language-lawyer>", "AnswerCount": "4"}, "48464377": {"Id": "48464377", "PostTypeId": "2", "Body": "<p>You could use the fact that casting a pointer to <code>intptr_t</code> doing arithmetic and then casting the value back to the pointer type is <em>implemetation defined behavior</em>. I believe it will work on most of the compilers: </p>\n<pre><code>template&lt;class T&gt;\nT* increment_pointer(T* a){\n  return reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;intptr_t&gt;(a)+sizeof(T));\n  }\n</code></pre>\n<p>This technic is the most efficient, optimizers seems not to be able to produce optimal if one use table look up: <a href=\"https://godbolt.org/g/vmJLjX\" rel=\"nofollow noreferrer\">assemblies-comparison</a></p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-26T18:09:58.547", "Score": "0", "CreationDate": "2018-01-26T15:26:41.140", "ParentId": "48463521", "CommentCount": "10", "OwnerUserId": "5632316", "LastEditDate": "2018-01-26T18:09:58.547"}, "bq_ids": {"n4140": {"so_48463521_48463521_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6142}}, "n3337": {"so_48463521_48463521_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 5906}}, "n4659": {"so_48463521_48463521_1": {"length": 18, "quality": 1.0, "section_id": 7638}, "so_48463521_48463521_0": {"length": 15, "quality": 1.0, "section_id": 7638}}}, "48463806": {"Id": "48463806", "PostTypeId": "2", "Body": "<p>IMHO the easiest way is to just implement <code>operator[]</code>. You can make a helper array like this or just create a switch...</p>\n<pre><code>struct Point\n{\n    double const&amp; operator[] (std::size_t i) const \n    {\n        const std::array coords {&amp;x, &amp;y, &amp;z};\n        return *coords[i];\n    }\n\n    double&amp; operator[] (std::size_t i) \n    {\n        const std::array coords {&amp;x, &amp;y, &amp;z};\n        return *coords[i];\n    }\n\n    double x;\n    double y;\n    double z;\n};\n\nint main() \n{\n    Point p {1, 2, 3};\n    std::cout &lt;&lt; p[2] - p[1];\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "683905", "LastActivityDate": "2018-01-27T14:24:52.007", "Score": "16", "CreationDate": "2018-01-26T14:52:55.053", "ParentId": "48463521", "CommentCount": "12", "OwnerUserId": "683905", "LastEditDate": "2018-01-27T14:24:52.007"}, "48463923": {"Id": "48463923", "PostTypeId": "2", "Body": "<pre><code>struct Point {\n  double x;\n  double y;\n  double z;\n  double&amp; operator[]( std::size_t i ) {\n    auto self = reinterpret_cast&lt;uintptr_t&gt;( this );\n    auto v = self+i*sizeof(double);\n    return *reinterpret_cast&lt;double*&gt;(v);\n  }\n  double const&amp; operator[]( std::size_t i ) const {\n    auto self = reinterpret_cast&lt;uintptr_t&gt;( this );\n    auto v = self+i*sizeof(double);\n    return *reinterpret_cast&lt;double const*&gt;(v);\n  }\n};\n</code></pre>\n<p>this relies on there being no packing between the <code>double</code>s in your `struct.  Asserting that is difficult.</p>\n<p>A POD struct is a sequence of bytes guaranteed.</p>\n<p>A compiler should be able to compile <code>[]</code> down to the same instructions (or lack thereof) as a raw array access or pointer arithmetic.  There <em>may</em> be some problems where this optimization happens \"too late\" for other optimzations to occur, so double-check in performance sensitive code.</p>\n<p>It is possible that converting to <code>char*</code> or <code>std::byte*</code> insted of <code>uintptr_t</code> would be valid, but <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1701\" rel=\"nofollow noreferrer\">there is a core issue</a> about if pointer arithmetic is permitted in this case.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2018-01-26T15:54:04.893", "Score": "2", "CreationDate": "2018-01-26T14:58:20.897", "ParentId": "48463521", "CommentCount": "5", "OwnerUserId": "1774667", "LastEditDate": "2018-01-26T15:54:04.893"}});