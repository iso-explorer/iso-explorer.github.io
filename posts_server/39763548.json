post_cb({"39780208": {"ParentId": "39763548", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2016-09-29T21:20:28.227", "Score": "2", "LastEditorUserId": "1774667", "LastEditDate": "2016-10-04T15:17:07.267", "Id": "39780208", "OwnerUserId": "1774667", "Body": "<h1>[class.union]/5:</h1>\n<blockquote>\n<p id=\"so_39763548_39780208_0\">In a union, a non-static data member is active if its name refers to an object whose lifetime has begun and has not ended ([basic.life]). At most one of the non-static data members of an object of union type can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time.</p>\n</blockquote>\n<p>At most one member of a union can be active at any one time.</p>\n<p>An active member is one whose lifetime has begun and not ended.</p>\n<p>Thus, if you end the lifetime of a member of your union, it is no longer active.</p>\n<p>If you have no active members, causing the lifetime of another member of the union to begin is well-defined under the standard, and causes it to become active.</p>\n<p>The union has allocated storage sufficient for all of its members.  They all are allocated as if they where alone, and they are pointer-interconvertible.  <a href=\"http://eel.is/c++draft/class.union#2\" rel=\"nofollow\"><code>[class.union]/2</code></a>.</p>\n<h1>[basic.life]/6</h1>\n<blockquote>\n<p id=\"so_39763548_39780208_1\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated<sup>40</sup> or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that represents the address of the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see <strong>[class.cdtor]</strong>. Otherwise, such a pointer refers to allocated storage (<strong>[basic.stc.dynamic.deallocation]</strong>), and using the pointer as if the pointer were of type void*, is well-defined.</p>\n</blockquote>\n<p>So you can take a pointer to a union member and treat it as a pointer to allocated storage.  Such a pointer may be used to construct an object there, if such a construction is legal.</p>\n<p>Placement new is a valid way to construct an object there.  <code>memcpy</code> of trivially copyable types (including POD types) is a valid way to construct an object there.</p>\n<p>But, constructing an object there is only valid <em>if it does not violate the rule of there being one active member of the union</em>.</p>\n<p>If you assign to a member of a union under certain conditions <a href=\"http://eel.is/c++draft/basic.life#6\" rel=\"nofollow\"><code>[class.union]/6</code></a> it first ends the lifetime of the currently active member, then starts the lifetime of the assigned-to member.  So your <code>u.u32_in_a_union = 0xaaaabbbb;</code> is legal even if there is another member active in the union (and it makes <code>u32_in_a_union</code> active).</p>\n<p>This isn't the case with placement new or <code>memcpy</code>, there is no explicit \"the lifetime of the active member end\" in the union specification.  We must look elsewhere:</p>\n<h1>[basic.life]/5</h1>\n<blockquote>\n<p id=\"so_39763548_39780208_2\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor.</p>\n</blockquote>\n<p>The question is, is starting the lifetime of a different member of the union \"reusing the storage\", thus ending the other union members lifetime?  In practice, obviously (they are pointer-interconvertable, they share the same address, etc).  <a href=\"http://eel.is/c++draft/class.union#2\" rel=\"nofollow\"><code>[class.union]/2</code></a>.</p>\n<p>So I would argue yes.</p>\n<p>So creating another object through a <code>void*</code> pointer (placement new, or <code>memcpy</code> if legal for the type) ends the lifetime of the alternative members of the <code>union</code> (if any) (not calling their destructor, but that is usually ok), and makes the pointed-to object active and alive, at once.</p>\n<p>It is legal to begin the lifetime of a <code>double</code> or an array of <code>int16_t</code> or similar via <code>memcpy</code> over storage.</p>\n<p>The legality of copying an array of two <code>uint16_t</code> over an <code>uint32_t</code> or vice versa I will leave to others to argue.  Apparently it is legal in C++17.  But this object being a union has nothing to do with that legality.</p>\n<hr>\n<p>This answer is based off of discussion with @Lorehead below their answer.  I felt I should provide an answer that aims directly at I think the core of the problem.</p>\n</hr>", "LastActivityDate": "2016-10-04T15:17:07.267"}, "bq_ids": {"n4140": {"so_39763548_39764671_1": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_39763548_39764671_4": {"section_id": 5916, "quality": 0.7647058823529411, "length": 13}, "so_39763548_39771930_0": {"section_id": 7192, "quality": 1.0, "length": 33}, "so_39763548_39780208_0": {"section_id": 5913, "quality": 0.5428571428571428, "length": 19}, "so_39763548_39763548_0": {"section_id": 5913, "quality": 0.8636363636363636, "length": 19}, "so_39763548_39764671_3": {"section_id": 7201, "quality": 0.967741935483871, "length": 30}, "so_39763548_39764671_2": {"section_id": 7200, "quality": 0.975609756097561, "length": 40}, "so_39763548_39780208_2": {"section_id": 7192, "quality": 1.0, "length": 16}, "so_39763548_39780208_1": {"section_id": 7193, "quality": 0.8947368421052632, "length": 51}, "so_39763548_39764671_0": {"section_id": 5849, "quality": 0.9, "length": 9}}, "n3337": {"so_39763548_39764671_1": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_39763548_39764671_4": {"section_id": 5688, "quality": 0.7647058823529411, "length": 13}, "so_39763548_39771930_0": {"section_id": 6936, "quality": 1.0, "length": 33}, "so_39763548_39780208_0": {"section_id": 5685, "quality": 0.5428571428571428, "length": 19}, "so_39763548_39763548_0": {"section_id": 5685, "quality": 0.8636363636363636, "length": 19}, "so_39763548_39764671_3": {"section_id": 6945, "quality": 0.967741935483871, "length": 30}, "so_39763548_39764671_2": {"section_id": 6944, "quality": 0.975609756097561, "length": 40}, "so_39763548_39780208_2": {"section_id": 6936, "quality": 1.0, "length": 16}, "so_39763548_39780208_1": {"section_id": 6937, "quality": 0.8947368421052632, "length": 51}, "so_39763548_39764671_0": {"section_id": 5619, "quality": 0.9, "length": 9}}, "n4659": {"so_39763548_39764671_4": {"section_id": 7409, "quality": 0.6470588235294118, "length": 11}, "so_39763548_39764671_3": {"section_id": 8710, "quality": 0.967741935483871, "length": 30}, "so_39763548_39771930_0": {"section_id": 8701, "quality": 1.0, "length": 33}, "so_39763548_39764671_1": {"section_id": 6103, "quality": 1.0, "length": 4}, "so_39763548_39780208_0": {"section_id": 7404, "quality": 0.9428571428571428, "length": 33}, "so_39763548_39763548_0": {"section_id": 7404, "quality": 0.8636363636363636, "length": 19}, "so_39763548_39780208_2": {"section_id": 8701, "quality": 1.0, "length": 16}, "so_39763548_39764671_2": {"section_id": 8709, "quality": 0.9024390243902439, "length": 37}, "so_39763548_39780208_1": {"section_id": 8702, "quality": 0.9298245614035088, "length": 53}, "so_39763548_39764671_0": {"section_id": 7328, "quality": 0.9, "length": 9}}}, "39764671": {"ParentId": "39763548", "PostTypeId": "2", "CommentCount": "31", "CreationDate": "2016-09-29T08:03:52.223", "Score": "4", "LastEditorUserId": "346335", "LastEditDate": "2016-09-29T08:32:46.783", "Id": "39764671", "OwnerUserId": "346335", "Body": "<p>My reading of the standard is that <code>std::memcpy</code> is safe whenever the type is <em>trivially copyable</em>.</p>\n<p>From 9 Classes, we can see that <code>union</code>s are class types and so <em>trivially copyable</em> applies to them.</p>\n<blockquote>\n<p id=\"so_39763548_39764671_0\">A <em>union</em> is a class defined with the <em>class-key</em> union; it holds only one data member at a time (9.5).</p>\n<p id=\"so_39763548_39764671_1\">A <em>trivially copyable class</em> is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n</blockquote>\n<p>The exact meaning of <em>trivially copyable</em> is given in 3.9 Types:</p>\n<blockquote>\n<p id=\"so_39763548_39764671_2\">For any object (other than a base-class subobject) of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes (1.7) making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value.</p>\n<p id=\"so_39763548_39764671_3\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>.</p>\n</blockquote>\n<p>The standard also gives an explicit example of both.</p>\n<p>So, if you were copying the entire union, the answer would be unequivocally yes, the active member will be \"copied\" along with the data.  (This is relevant because it indicates that <code>std::memcpy</code> <em>must</em> be regarded as a valid means of changing the active element of a union, since using it is explicitly allowed for whole union copying.)</p>\n<p>Now, you are instead copying into a <em>member</em> of the union.  The standard doesn't appear to require any particular method of assigning to a union member (and hence making it active).  All it does is specify (9.5) that</p>\n<blockquote>\n<p id=\"so_39763548_39764671_4\"><em>[ Note:</em> In general, one must use explicit destructor class and placement new operators to change the active member of a union. <em>\u2014 end note]</em></p>\n</blockquote>\n<p>which it says, of course, because C++11 allows objects of non-trivial type in unions.  Note the \"in general\" on the front, which quite clearly indicates that other methods of changing the active member are permissible in specific cases; we already know this to be the case because assignment is clearly permitted.  Certainly there is no prohibition on using <code>std::memcpy</code>, where its use would otherwise be valid.</p>\n<p>So my answer is yes, this is safe, and yes, it changes the active member.</p>\n", "LastActivityDate": "2016-09-29T08:32:46.783"}, "39763548": {"CommentCount": "44", "ViewCount": "626", "PostTypeId": "1", "LastEditorUserId": "146041", "CreationDate": "2016-09-29T07:02:29.623", "LastActivityDate": "2016-10-04T15:17:07.267", "Title": "memcpy/memmove to a union member, does this set the 'active' member?", "FavoriteCount": "4", "LastEditDate": "2016-09-30T06:41:10.673", "Id": "39763548", "Score": "16", "Body": "<p><em>Important clarification: some commenters seem to think that I am copying from a union. Look carefully at the <code>memcpy</code>, it copies from the address of a plain old <code>uint32_t</code>, which is not contained within a union. Also, I am copying (via <code>memcpy</code>) to a specific member of a union (<code>u.a16</code> or <code>&amp;u.x_in_a_union</code>, not directly to the entire union itself (<code>&amp;u</code>)</em></p>\n<p>C++ is quite strict about unions - you should read from a member only if that was the last member that was written to:</p>\n<blockquote>\n<p id=\"so_39763548_39763548_0\">9.5 Unions [class.union] <em>[[c++11]]</em> In a union, at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time.</p>\n</blockquote>\n<p>(Of course, the compiler doesn't track which member is active. It's up to the developer to ensure they track this themselves)</p>\n<hr>\n<p><em>Update: This following block of code is the main question, directly reflecting the text in the question title. If this code is OK, I have a follow up regarding other types, but I now realize that this first block of code is interesting itself.</em></p>\n<pre><code>#include &lt;cstdint&gt;\nuint32_t x = 0x12345678;\nunion {\n    double whatever;\n    uint32_t x_in_a_union; // same type as x\n} u;\nu.whatever = 3.14;\nu.x_in_a_union = x; // surely this is OK, despite involving the inactive member?\nstd::cout &lt;&lt; u.x_in_a_union;\nu.whatever = 3.14; // make the double 'active' again\nmemcpy(&amp;u.x_in_a_union, &amp;x); // same types, so should be OK?\nstd::cout &lt;&lt; u.x_in_a_union; // OK here? What's the active member?\n</code></pre>\n<p><strong><em>The block of code immediately above this is probably the main issue in the comments and answers. In hindsight, I didn't need to mix types in this question! Basically, is <code>u.a = b</code> the same as <code>memcpy(&amp;u.a,&amp;b, sizeof(b))</code>, assuming the types are identical?</em></strong></p>\n<hr>\n<p>First, a relatively simple <code>memcpy</code> allowing us to read a <code>uint32_t</code> as an array of <code>uint16_t</code>:</p>\n<pre><code>#include &lt;cstdint&gt; # to ensure we have standard versions of these two types\nuint32_t x = 0x12345678;\nuint16_t a16[2];\nstatic_assert(sizeof(x) == sizeof(a16), \"\");\nstd:: memcpy(a16, &amp;x, sizeof(x));\n</code></pre>\n<p>The precise behaviour depends on the endianness of your platform, and you must beware of trap representations and so on. But it is generally agreed here (I think? Feedback appreciated!) that, with care to avoid problematic values, the above code can be perfectly standards-complaint in the right context on the right platform.</p>\n<p><em>(If you have a problem with the above code, please comment or edit the question accordingly. I want to be sure we have a non-controversial version of the above before proceeding to the \"interesting\" code below.)</em></p>\n<hr>\n<p>If, <em>and only if</em>, both blocks of code above are not-UB, then I would like to combine them as follows:</p>\n<pre><code>uint32_t x = 0x12345678;\nunion {\n    double whatever;\n    uint16_t a16[2];\n} u;\nu.whatever = 3.14; // sets the 'active' member\nstatic_assert(sizeof(u.a16) == sizeof(x)); //any other checks I should do?\nstd:: memcpy(u.a16, &amp;x, sizeof(x));\n\n// what is the 'active member' of u now, after the memcpy?\ncout &lt;&lt; u.a16[0] &lt;&lt; ' ' &lt;&lt; u.a16[1] &lt;&lt; endl; // i.e. is this OK?\n</code></pre>\n<p>Which member of the union, <code>u.whatever</code> or <code>u.a16</code> , is the 'active member'?</p>\n<hr>\n<p>Finally, my own guess is that the reason why we care about this, in practice, is that an optimizing compiler might fail to notice that the <code>memcpy</code> happened and therefore make false assumptions (but allowable assumptions, by the standard) about which member is active and which data types are 'active', therefore leading to mistakes around aliasing. The compiler might reorder the <code>memcpy</code> in strange ways. <em>Is this an appropriate summary of why we care about this?</em></p>\n</hr></hr></hr></hr>", "Tags": "<c++><c++11><language-lawyer><unions>", "OwnerUserId": "146041", "AnswerCount": "3"}, "39771930": {"ParentId": "39763548", "PostTypeId": "2", "CommentCount": "44", "CreationDate": "2016-09-29T13:39:16.983", "Score": "2", "LastEditorUserId": "4474419", "LastEditDate": "2016-09-30T00:08:13.253", "Id": "39771930", "OwnerUserId": "4474419", "Body": "<p>At most one member of a union can be active, and it is active during its lifetime.</p>\n<p>In the C++14 standard (\u00a7 9.3, or 9.5 in the draft), all non-static union members are allocated as if they were the sole member of a <code>struct</code>, and share the same address.  This does not begin the lifetime, but a non-trivial default constructor (which only one union member can have) does.  There is a special rule that assigning to a union member activates it, even though you could not normally do this to an object whose lifetime has not begun.  If the union is trivial, it and its members have no non-trivial destructors to worry about.  Otherwise, you need to worry about when the lifetime of the active member ends.  From the standard (\u00a7 3.8.5):</p>\n<blockquote>\n<p id=\"so_39763548_39771930_0\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. [... I]f there is no explicit call to the destructor or if a delete-expression is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>It is safer in general to explicitly call the destructor of the currently-active member, and make another member active with placement <code>new</code>.  The standard gives the example:</p>\n<pre><code>u.m.~M();\nnew (&amp;u.n) N;\n</code></pre>\n<p>You can check at compile time whether the first line is necessary with <code>std::is_trivially_destructible</code>.  By a strict reading of the standard, you can only begin the lifetime of a union member by initializing the union, assigning to it, or placement <code>new</code>, but once you have, you can safely copy a trivially-copyable object over another using <code>memcpy()</code>. (\u00a7 3.9.3, 3.8.8)</p>\n<p>For trivially-copyable types, the value representation is a set of bits in the object representation that determines the value, and the object interpretation of <em>T</em> is a sequence of <code>sizeof(T)</code> <code>unsigned char</code> objects.  The <code>memcpy()</code> function copies this object representation.  All non-static union members have the same address, and you can use that address as a <code>void*</code> to storage after it has been allocated and before the object\u2019s lifetime begins (\u00a7 3.8.6), so you can pass it to <code>memcpy()</code> when the member is inactive.  If the union is a standard-layout union, the address of the union itself is the same as the address of its first non-static member, and therefore all of them.  (If not, it is interconvertible with <code>static_cast</code>.)  </p>\n<p>If a type <code>has_unique_object_representations</code>, it is trivially-copyable, and no two distinct values share the same object representation; that is, no bits are padding.</p>\n<p>If a type <code>is_pod</code> (Plain Old Data), then it is trivially-copyable and has standard layout, so its address is also the same as the address of its first non-static member.</p>\n<p>In <strong>C</strong>, we have a guarantee that we can read inactive union members of a compatible type to the last one written.  In <strong>C++</strong>, we do not.  There are a few special cases where it works, such as pointers containing addresses of objects of the same type, signed and unsigned integral types of the same width, and layout-compatible structures.  However, the types you used in your example have some extra guarantees: if they exist at all, <code>uint16_t</code> and <code>uint32_t</code> have exact widths and no padding, each object representation is a unique value, and all array elements are contiguous in memory, so any object representation of a <code>uint32_t</code> is also a valid object representation of some <code>uint16_t[2]</code> even though this object representation is technically undefined.  What you get depends on endianness.  (If you actually want to split up 32 bits safely, you can use bit shifts and bitmasks.)</p>\n<p>To generalize, if the source object <code>is_pod</code>, then it can be copied strictly by its object representation and laid over another layout-compatible object at the new address, and if the destination object is the same size and <code>has_unique_object_representations</code>, it is trivially-copyable as well and will not throw away any of the bits\u2014however, there might be a trap representation.  If your union is not trivial, you need to delete the active member (only one member of a non-trivial union can have a non-trivial default constructor, and it will be active by default) and use placement <code>new</code> to make the target member active.</p>\n<p>Whenever you copy arrays in C or C++, you always want to check for buffer overflow.  In this case, you took my suggestion and used <code>static_assert()</code>.  This has no run-time overhead.  You can also use <code>memcpy_s()</code>: <code>memcpy_s( &amp;u, sizeof(u), &amp;u32, sizeof(u32) );</code> will work if the source and destination are POD (trivially-copyable with standard layout) and if the union has standard layout.  It will never overflow or underflow a union.  It will pad out any remaining bytes of the union with zeroes, which can make a lot of the bugs you\u2019re worried about visible and reproducible.</p>\n", "LastActivityDate": "2016-09-30T00:08:13.253"}});