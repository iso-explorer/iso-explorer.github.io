post_cb({"bq_ids": {"n4140": {"so_15755632_15756233_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 3326}}, "n3337": {"so_15755632_15756233_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 3196}}, "n4659": {"so_15755632_15756233_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 4092}}}, "15756014": {"Id": "15756014", "PostTypeId": "2", "Body": "<p>This seems to work. You'd just have to adapt a couple of things:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n\nvoid foo(int a, float b, int c) {\n    std::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \", \" &lt;&lt; c &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\nT getColumn(int index) {\n    return T(index);\n}\n\ntemplate&lt;size_t... indexes&gt;\nstruct index_tuple {};\n\ntemplate&lt;size_t head, size_t... indexes&gt;\nstruct index_tuple&lt;head, indexes...&gt; {\n    typedef typename index_tuple&lt;head-1, head-1, indexes...&gt;::type type;\n};\n\ntemplate&lt;size_t... indexes&gt;\nstruct index_tuple&lt;0, indexes...&gt; {\n    typedef index_tuple&lt;indexes...&gt; type;\n};\n\ntemplate&lt;typename... Args&gt;\nstruct make_index_tuple {\n    typedef typename index_tuple&lt;sizeof...(Args)&gt;::type type;\n};\n\ntemplate&lt;typename... ColumnTypes, size_t... indexes&gt;\nvoid execute(const std::function&lt;void(ColumnTypes...)&gt; &amp;callback, index_tuple&lt;indexes...&gt;) {\n    // this should be done for every row in your query result\n    callback(getColumn&lt;ColumnTypes&gt;(indexes)...);\n}\n\ntemplate&lt;typename... ColumnTypes&gt;\nvoid execute(const std::function&lt;void(ColumnTypes...)&gt; &amp;callback) {\n    execute(\n        callback, \n        typename make_index_tuple&lt;ColumnTypes...&gt;::type()\n    );\n}\n\nint main() {\n    std::function&lt;void(int, float, int)&gt; fun(foo);\n    execute(fun);\n}\n</code></pre>\n<p>Demo <a href=\"http://liveworkspace.org/code/lhYgQ$0\" rel=\"noreferrer\">here</a>. Note that the function <code>foo</code> is only used to show that the indexes are correctly incremented, just like the <code>return T(index);</code> in <code>getColumn</code>.</p>\n", "LastActivityDate": "2013-04-02T04:21:03.117", "CommentCount": "1", "CreationDate": "2013-04-02T04:21:03.117", "ParentId": "15755632", "Score": "5", "OwnerUserId": "525217"}, "15756233": {"Id": "15756233", "PostTypeId": "2", "Body": "<p>While mfontanini's solution works and is good because it performs the calculation of the incrementing column index at compile time, I think it's worthwhile pointing out that there is also a direct answer to question of <em>how to increment an int in a variadic pack expansion</em>. (Unfortunately it does not seem to work on GCC due to a bug, see the caveat at the end.)</p>\n<p>The answer is based on the fact that while the evaluations of arguments in a function call are unsequenced, the evaluations of arguments in a <strong>list initialization</strong> are not:</p>\n<blockquote>\n<p id=\"so_15755632_15756233_0\">(\u00a78.5.4/4) Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and side effect associated with a given initializer-clause is sequenced before every value computation and side effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.<br>\n  [ Note: This evaluation ordering holds regardless of the semantics of the initialization; for example, it applies when the elements of the initializer-list are interpreted as arguments of a constructor call, even though ordinarily there are no sequencing constraints on the arguments of a call. \u2014 end note ]</br></p>\n</blockquote>\n<p>Therefore, if you transform your function call into something based on a brace-init-list, you'll get the desired effect:</p>\n<pre><code>rowCallback(std::tuple&lt;ColumnTypes...&gt; { getColumn&lt;ColumnTypes&gt;(column++)... });\n</code></pre>\n<p>This initializes a <code>std::tuple</code> using list-initialization (notice the braces <code>{ ... }</code>), hence the <code>column++</code> side effect will be performed in left-to-right order.</p>\n<p>If written as above, this means you need to change <code>rowCallback()</code> to make it accept a <code>std::tuple</code> instead of a list of arguments. If you don't like this, you can create a separate template function <code>call_on_tuple(fun,tup)</code>, which calls any function <code>fun</code> on the arguments that result from expanding tuple <code>tup</code>. I once described how to do this <a href=\"https://stackoverflow.com/a/14089944/777186\">here</a>, or if you like, you could use <code>rlxutil::call_on_tuple</code> from <a href=\"https://github.com/jogojapan/sufex/blob/master/src/util/tupletools.hpp\" rel=\"nofollow noreferrer\">my GitHub repository</a>.</p>\n<p>Your <code>execute</code> function then looks like this:</p>\n<pre><code>template &lt;typename... ColumnTypes&gt;\nvoid execute(function&lt;void(ColumnTypes...)&gt; rowCallback)\n{\n  using std::tuple;\n  using rlxutil::call_on_tuple;\n\n  int column = 0;\n  call_on_tuple(rowCallback,\n                tuple&lt;ColumnTypes...&gt; { getColumn&lt;ColumnTypes&gt;(column++)... });\n}\n</code></pre>\n<p><strong>Caveat: This is does not work as expected with GCC. I believe this is because of the bug reported here: <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51253\" rel=\"nofollow noreferrer\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51253</a>.</strong></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-02T04:40:53.353", "Score": "4", "CreationDate": "2013-04-02T04:40:53.353", "ParentId": "15755632", "CommentCount": "2", "OwnerUserId": "777186", "LastEditDate": "2017-05-23T12:14:34.787"}, "15755632": {"ViewCount": "514", "Body": "<p>I am trying to implement a C++11 wrapper around an SQL library written in C. The C library has separate functions for getting different data types from an SQL statement which require a column index. A simple approach is prototyped below but has a critical flaw: it relies on the order of argument execution, which is not safe (may also have compiler errors, haven't tested it).</p>\n<p><strong>Question:</strong> What is a platform-independent way to safely increment a variable in a variadic template expansion?</p>\n<pre><code>template&lt; typename... ColumnTypes &gt;\nvoid SQLStatement::execute( std::function&lt; void( ColumnTypes... ) &gt; rowCallback ){\n    while( this-&gt;nextRow() ){\n        int column = 0;\n        rowCallback( this-&gt;getColumn&lt; ColumnTypes &gt;( column++ )... );\n        //                            unreliable increment ^\n    }\n}\n\ntemplate&lt; typename T &gt;\nT SQLStatement::getColumn( const int columnIdx ){}\n\ntemplate&lt;&gt;\ninline int SQLStatement::getColumn&lt; int &gt;( const int columnIdx ){\n    return sql_library_column_int( this-&gt;nativeHandle, columnIdx );\n}\n\n// Other getColumn specializations here...\n</code></pre>\n", "AcceptedAnswerId": "15756233", "Title": "What is a safe way to increment an int in a variadic template expansion?", "CreationDate": "2013-04-02T03:35:26.447", "Id": "15755632", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-04-02T04:40:53.353", "Score": "6", "OwnerUserId": "321937", "Tags": "<c++><c++11><variadic-templates>", "AnswerCount": "2"}});