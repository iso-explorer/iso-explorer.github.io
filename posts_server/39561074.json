post_cb({"39578354": {"ParentId": "39561074", "CommentCount": "0", "CreationDate": "2016-09-19T16:58:18.087", "OwnerUserId": "1316462", "PostTypeId": "2", "Id": "39578354", "Score": "1", "Body": "<p><code>decltype</code> evaluate it argument as it is, <code>decltype(i)</code> where <code>i</code> is <em>cv-qualified</em> lvalue, results in declaring type cv-qualified, but the expression of <code>i*i</code> in <code>decltype(i*i)</code> create a non materialized prvalue with type of <code>i</code> with non <em>cv-qualified</em>, prvalue don't have an explicit notion of constness. your code produce the same as:</p>\n<pre><code>using T = const int;\nstatic_assert(is_same&lt;int, decltype(0)&gt;(), \"Failed\");\n</code></pre>\n<p>The fact that <code>typeid</code> is not showing the cv-qualification is because they a ignored:</p>\n<blockquote>\n<p id=\"so_39561074_39578354_0\"><a href=\"http://eel.is/c++draft/expr.typeid\" rel=\"nofollow\">5.2.8.5</a> - If the type of the expression or type-id is a cv-qualified type, the result of the typeid expression refers to a std::type_info object representing the cv-unqualified type.</p>\n</blockquote>\n", "LastActivityDate": "2016-09-19T16:58:18.087"}, "39561074": {"CommentCount": "14", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "978524", "CreationDate": "2016-09-18T18:17:43.937", "LastActivityDate": "2016-09-19T16:58:18.087", "Title": "clarification of decltype output when multiplying 2 const ints", "FavoriteCount": "0", "LastEditDate": "2016-09-18T18:41:05.323", "Id": "39561074", "Score": "5", "Body": "<pre><code>int main()\n{\n const int a = 1;\n const int b = 2;\n typedef decltype(a*b) multiply_type;\n cout &lt;&lt; typeid(multiply_type).name() &lt;&lt; endl;\n return 0;\n}\n</code></pre>\n<p>The return value of the program is that multiply_type is int. I'm quite surprised. I expected the type deduction to yield const int and since the expression yields a pr value, the resultant type would be const int. </p>\n<p>PS: With auto the return value would be int as it drops the const qualifier. </p>\n<p>Any ideas why multiply_type is int instead of const int with decltype ?</p>\n<p>Edit: Added an addition example which is also related to cv-qualifier.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;typeinfo&gt;\n\n\nusing namespace std;\n\nstruct Details\n{\n    int m_age;\n};\n\nint main()\n{\n const Details* detail = new Details();\n typedef decltype((detail-&gt;m_age)) age_type;\n cout &lt;&lt; typeid(age_type).name() &lt;&lt; endl;\n\n int a = 1;\n age_type age = a;\n age = 10; // This is not possible. Read only. \n cout &lt;&lt; typeid(age).name() &lt;&lt; endl; // This returns the type as int though. Then why is 20 not possble ?\n return 0;\n\n}\n</code></pre>\n<p>Edit 2: Check our the link. \n<a href=\"http://thbecker.net/articles/auto_and_decltype/section_07.html\" rel=\"nofollow\">http://thbecker.net/articles/auto_and_decltype/section_07.html</a>\n`</p>\n<pre><code>int x;\nconst int&amp; crx = x;\n/ The type of (cx) is const int. Since (cx) is an lvalue,\n// decltype adds a reference to that: cx_with_parens_type\n// is const int&amp;.\ntypedef decltype((cx)) cx_with_parens_type;` \n</code></pre>\n", "Tags": "<c++><c++11><c++14><decltype>", "OwnerUserId": "978524", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39561074_39578354_0": {"section_id": 6024, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_39561074_39578354_0": {"section_id": 5791, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_39561074_39578354_0": {"section_id": 7523, "quality": 0.9333333333333333, "length": 14}}}});