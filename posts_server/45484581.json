post_cb({"45484581": {"CommentCount": "2", "AcceptedAnswerId": "45485116", "CreationDate": "2017-08-03T12:44:04.153", "LastActivityDate": "2017-08-03T13:06:26.957", "PostTypeId": "1", "ViewCount": "219", "FavoriteCount": "2", "Title": "Can I always safely cast into the underlying type of a fixed (scoped) enumeration?", "Id": "45484581", "Score": "10", "Body": "<p><strong>TL;DR:</strong> Is the following always safe? Or does it lead to undefined, unspecified or implementation defined behaviour?</p>\n<pre><code>template &lt;class T&gt; \nusing ut = typename std::underlying_type&lt;T&gt;::type;\n\ntemplate &lt;typename E&gt; ut&lt;E&gt; identity(ut&lt;E&gt; value) {\n  return static_cast&lt;ut&lt;E&gt;&gt;(static_cast&lt;E&gt;(value));\n}\n</code></pre>\n<hr>\n<p>If I have a scoped enumeration I can always cast it into the underlying type:</p>\n<pre><code>#include &lt;cassert&gt;             // if you want to follow along\n#include &lt;initializer_list&gt;    // copy everything and remove my text\n\nenum class priority : int { \n  low = 0, \n  normal = 1,\n  high = 2 \n};\n\n// works fine\nint example = static_cast&lt;int&gt;(priority::high);\n</code></pre>\n<p>For all values that are defined in the enumeration I can also expect that I get the value back:</p>\n<pre><code>constexpr priority identity_witness(priority p) {\n  return static_cast&lt;priority&gt;(static_cast&lt;int&gt;(p));\n}\n\nvoid test_enum() {\n  for (const auto p : {priority::low, priority::normal, priority::high}) {\n    assert(p == identity_witness(p));\n  }\n}\n</code></pre>\n<p>According to N3337 (C++11), 5.2.9 Static cast [expr.static.cast] \u00a7 9-10 this is fine:</p>\n<blockquote id=\"so_45484581_45484581_0\">\n<ol start=\"9\">\n<li>A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. The value is unchanged if the original value can be represented by the specified type. \u2026</li>\n<li>A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). \u2026</li>\n</ol>\n</blockquote>\n<p>However, I'm interested in the other way round. What happens if I cast to an enum and back to the underlying type?</p>\n<pre><code>constexpr int identity_witness(int i) {\n  return static_cast&lt;int&gt;(static_cast&lt;priority&gt;(i));\n}\n\nvoid test_int() {\n  for (const auto p : {0, 1, 2, 3, 4, 5}) {\n    assert(p == identity_witness(p));\n  }\n}\n\nint main() {\n  test_enum();\n  test_int();\n}\n</code></pre>\n<p>This compiles and works fine, since a <code>static_cast</code> to the underlying type won't change the memory at all (probably). However, the standard says that the behaviour is unspecified if the value is not in the range:</p>\n<blockquote id=\"so_45484581_45484581_1\">\n<ol start=\"10\">\n<li>[continued] Otherwise, the resulting value is unspecified (and might not be in that range).</li>\n</ol>\n</blockquote>\n<p>The <em>range</em> of the enumerations isn't clear to me. According to 7.2\u00a77, \"the values of the enumeration are the values of the underlying type\" if the enumeration's underlying type is fixed. Therefore, for any <code>std::underlying_type&lt;my_enumeration_type&gt;</code>, the property above should hold.</p>\n<p>Does this argument hold, or did I miss some strange clause in the standard so that a cast into the underlying type of the enumeration might lead to undefined or unspecified behaviour?</p>\n</hr>", "Tags": "<c++><c++11><casting><language-lawyer>", "OwnerUserId": "1139697", "AnswerCount": "1"}, "45485116": {"ParentId": "45484581", "CommentCount": "4", "Body": "<p>The standard seems determined to allow you to use arbitrary integral values of a given type as values for an enumeration fixed to that type, even if they're not named as enumeration values. The caveat in 5.2.9.10 is presumably meant to limit enumerations without a fixed underlying type. The standard doesn't define the \"range\" of a fixed-type enumeration's values as anything separate from the enumeration's values. In particular, it says:</p>\n<blockquote>\n<p id=\"so_45484581_45485116_0\">It is possible to define an enumeration that has values not defined by any of its enumerators.</p>\n</blockquote>\n<p>So \"is within the range of the enumeration values\" cannot be understood as anything other than \"is one of the enumeration values\". There's no other definition of the range of an enumeration's values.</p>\n<p>So you're safe for enumerations with a fixed underlying type. For untyped enumerations, you're only safe if you stick to the safe number of bits.</p>\n", "OwnerUserId": "787480", "PostTypeId": "2", "Id": "45485116", "Score": "3", "CreationDate": "2017-08-03T13:06:26.957", "LastActivityDate": "2017-08-03T13:06:26.957"}, "bq_ids": {"n4140": {"so_45484581_45484581_1": {"section_id": 6036, "quality": 0.8571428571428571, "length": 6}, "so_45484581_45485116_0": {"section_id": 5467, "quality": 1.0, "length": 7}, "so_45484581_45484581_0": {"section_id": 6035, "quality": 0.6666666666666666, "length": 24}}, "n3337": {"so_45484581_45484581_1": {"section_id": 5804, "quality": 0.8571428571428571, "length": 6}, "so_45484581_45485116_0": {"section_id": 5253, "quality": 1.0, "length": 7}, "so_45484581_45484581_0": {"section_id": 5803, "quality": 0.6666666666666666, "length": 24}}, "n4659": {"so_45484581_45484581_1": {"section_id": 7534, "quality": 0.5714285714285714, "length": 4}, "so_45484581_45485116_0": {"section_id": 6901, "quality": 1.0, "length": 7}, "so_45484581_45484581_0": {"section_id": 7534, "quality": 0.6666666666666666, "length": 24}}}});