post_cb({"24921299": {"ParentId": "24920218", "CommentCount": "4", "Body": "<p>This requires a hack. A downcast requires math since multiple inheritance may put the base class in some arbitrary position within the derived class. However, if you know the base class is virtually inherited, then there should only be one instance of it in the derived class. This means you can create a conversion function:</p>\n<pre><code>struct MostDerived : Base1, Base2, virtual ViBase\n{\n  bool ok;\n  template &lt;typename T&gt; static MostDerived * somehow_cast (T *v) {\n    static MostDerived derived;\n    static T &amp;from = derived;\n    static size_t delta\n      = reinterpret_cast&lt;char *&gt;(&amp;from) - reinterpret_cast&lt;char *&gt;(&amp;derived);\n    char *to = reinterpret_cast&lt;char *&gt;(v);\n    return reinterpret_cast&lt;MostDerived *&gt;(to - delta);\n  }\n};\n</code></pre>\n<p>What the special C++ casts give you that this function does not is type safety. This function blindly assumes that the passed in <code>ViBase</code> has an appropriate derived child to cast into, which is generally not the case.</p>\n", "OwnerUserId": "315052", "PostTypeId": "2", "Id": "24921299", "Score": "2", "CreationDate": "2014-07-23T21:25:06.510", "LastActivityDate": "2014-07-23T21:25:06.510"}, "24920749": {"ParentId": "24920218", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><del>There is an implicit unambigious conversion from <code>MostDerived&amp;</code> to its <code>ViBase&amp;</code>. A <code>static_cast</code> can express such a conversion explicitly, and can also do the opposite conversion. That\u2019s the kinds of conversions that <code>static_cast</code> does.</del></p>\n<p>As the OP noted a <code>static_cast</code> down from virtual base is invalid.</p>\n<p>The source code below illustrates why:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct B { virtual ~B(){} };\nstruct D: virtual B {};\nstruct E: virtual B {};\nstruct X: D, E {};\n\nauto main() -&gt; int\n{\n    X   x;\n    B&amp;  b = static_cast&lt;E&amp;&gt;( x );\n\n    // Can't do the following for the address adjustment that would work for\n    // D sub-object won't work for E sub-object, yet declarations of D and E\n    // are identical -- so the address adjustment can't be inferred from that.\n    //\n    //static_cast&lt;D&amp;&gt;( b );\n\n    // This is OK:\n    dynamic_cast&lt;D&amp;&gt;( b );\n}\n</code></pre>\n<p>Essentially, as this shows, you can't infer the address adjustment from the declaration of <code>D</code> (or <code>E</code>) alone. And neither can the compiler. This also rules out <code>reinterpret_cast</code>.</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-07-23T21:12:31.257", "Id": "24920749", "Score": "4", "CreationDate": "2014-07-23T20:54:00.463", "LastActivityDate": "2014-07-23T21:12:31.257"}, "24920218": {"CommentCount": "13", "AcceptedAnswerId": "24920749", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2014-07-23T20:21:20.267", "LastActivityDate": "2014-07-24T05:13:44.673", "LastEditDate": "2014-07-24T05:13:44.673", "ViewCount": "515", "FavoriteCount": "1", "Title": "How to downcast from non-polymorphic virtual base class?", "Id": "24920218", "Score": "5", "Body": "<p>Is there a way to downcast from a virtual base class to a derived class when there are no virtual functions involved? Here's some code to demonstrate what I'm talking about:</p>\n<pre><code>struct Base1\n{\n  int data;\n};\n\nstruct Base2\n{\n  char odd_size[9];\n};\n\nstruct ViBase\n{\n  double value;\n};\n\n\nstruct MostDerived : Base1, Base2, virtual ViBase\n{\n  bool ok;\n};\n\n\nvoid foo(ViBase &amp;v)\n{\n  MostDerived &amp;md = somehow_cast&lt;MostDerived&amp;&gt;(v);  //but HOW?\n  md.ok = true;\n}\n\n\nint main()\n{\n  MostDerived md;\n  foo(md);\n}\n</code></pre>\n<p>Please note that the code is for demonstration only. My real scenario is fairly complex and involves template parameters and casting from one to another, knowing only that the first one is a base of the second one; it can be a normal or virtual base and it may or may not have virtual functions. (See simplified example at the bottom). I can detect the polymorphic case and the virtual/non-virtual base case using type traits, and solve all of them except the non-polymorphic virtual base. So that's what I'm asking about.</p>\n<p>I can't really think of a way to do the cast:</p>\n<ul>\n<li><p>Implicit conversions are right out; these only do upcasts.</p></li>\n<li><p><code>static_cast</code> is explicitly forbidden for casting from a virtual base class:</p>\n<blockquote>\n<p id=\"so_24920218_24920218_0\"><strong>5.2.9/2</strong> ... and <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. ...</p>\n</blockquote></li>\n<li><p><code>dynamic_cast</code> can't do it either, as downcasts require a polymorphic class</p>\n<blockquote>\n<p id=\"so_24920218_24920218_1\"><strong>5.2.7/6</strong> Otherwise, <code>v</code> shall be a pointer to or a glvalue of a polymorphic type (10.3).</p>\n<p id=\"so_24920218_24920218_2\"><strong>10.3/1</strong> ... A class that declares or inherits a virtual function is called a <em>polymorphic class.</em></p>\n</blockquote></li>\n<li><p><code>reinterpret_cast</code> doesn't apply here at all.</p></li>\n</ul>\n<p>If <code>MostDerived</code> had at least one virtual function, this could of course be solved with <code>dynamic_cast</code>. But when it does not, is there a way to do the cast?</p>\n<p><sup>(NOTE All quotes are taken from C++11 draft N3485)</sup></p>\n<hr>\n<p>In light of comments focusing on the above example code too much, here's a sketch of what my real situation is:</p>\n<pre><code>template &lt;class T_MostDerived&gt;\nstruct Bar\n{\n  template &lt;class T_Base&gt;\n  void foo(T_Base &amp;b, typename std::enable_if&lt;std::is_base_of&lt;T_Base, T_MostDerived&gt;::value&gt;::type * = nullptr)\n  {\n    T_MostDerived &amp;md = somehow_cast&lt;T_MostDerived&gt;(b);\n    do_stuff_with(md);\n  }\n};\n</code></pre>\n<p>That is, I know that <code>T_Base</code> is a base class of <code>T_MostDerived</code> (and I know that <code>T_MostDerived</code> is really the most derived type), but I don't know anything else about them; <code>Bar</code> is my code, part of a library, which unknown clients can use. I can <em>detect</em> that it's a non-polymorphic virtual base, but I can't <em>cast</em> it in such case.</p>\n</hr>", "Tags": "<c++><downcasting><virtual-inheritance>", "OwnerUserId": "1782465", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24920218_24920218_2": {"section_id": 7002, "quality": 0.7777777777777778, "length": 7}, "so_24920218_24920218_0": {"section_id": 6028, "quality": 0.9090909090909091, "length": 10}, "so_24920218_24920218_1": {"section_id": 6016, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_24920218_24920218_2": {"section_id": 6748, "quality": 0.7777777777777778, "length": 7}, "so_24920218_24920218_0": {"section_id": 5796, "quality": 0.9090909090909091, "length": 10}, "so_24920218_24920218_1": {"section_id": 5784, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_24920218_24920218_2": {"section_id": 8499, "quality": 0.7777777777777778, "length": 7}, "so_24920218_24920218_0": {"section_id": 43, "quality": 0.7272727272727273, "length": 8}, "so_24920218_24920218_1": {"section_id": 7515, "quality": 0.7142857142857143, "length": 5}}}});