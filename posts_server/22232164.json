post_cb({"22232164": {"CommentCount": "0", "AcceptedAnswerId": "22232165", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-03-06T17:49:39.177", "LastActivityDate": "2015-03-02T13:29:10.133", "LastEditDate": "2014-12-16T03:52:55.437", "ViewCount": "3124", "FavoriteCount": "3", "Title": "Why are lambda expressions not allowed in an unevaluated operands but allowed in the unevaluated portions of constant expressions?", "Id": "22232164", "Score": "8", "Body": "<p>If we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.1.2</code> <em>Lambda expressions</em> paragraph <em>2</em> says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_22232164_22232164_0\">The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the closure object. <strong>A lambda-expression shall not appear in an unevaluated operand</strong> (Clause 5). [ Note: A closure object behaves like a function object (20.8).\u2014end note ]</p>\n</blockquote>\n<p>and section <code>5.19</code> <em>Constant expressions</em> paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_22232164_22232164_1\">A conditional-expression <strong>is a core constant expression unless</strong> it involves one of the following as a potentially evaluated subexpression (3.2), <strong>but subexpressions of logical AND (5.14), logical OR (5.15), and conditional (5.16) operations that are not evaluated are not considered</strong> [...]</p>\n</blockquote>\n<p>and has the following bullet:</p>\n<blockquote>\n<p id=\"so_22232164_22232164_2\">\u2014 a lambda-expression (5.1.2);</p>\n</blockquote>\n<p>So why are lambdas expressions not allowed in an unevaluated operand but are allowed in the unevaluated portions of constant expressions?</p>\n<p>I can see how for unevaluated operands the type information in several cases(<em><a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow\">decltype</a> or <a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\">typeid</a></em>) is not very useful since each lambda has a unique type. Although why we would want to allow them in the unevaluated context of a constant expression is not clear, perhaps to allow for <a href=\"http://en.cppreference.com/w/cpp/language/sfinae\" rel=\"nofollow\">SFINAE</a>?</p>\n", "Tags": "<c++><c++11><lambda><c++14><constant-expression>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22232164_22232164_0": {"section_id": 5961, "quality": 0.7307692307692307, "length": 19}, "so_22232164_22232165_1": {"section_id": 5961, "quality": 0.75, "length": 30}}, "n3337": {"so_22232164_22232164_0": {"section_id": 5730, "quality": 0.7307692307692307, "length": 19}, "so_22232164_22232164_1": {"section_id": 5946, "quality": 0.7619047619047619, "length": 16}}, "n4659": {"so_22232164_22232164_0": {"section_id": 7448, "quality": 0.5769230769230769, "length": 15}, "so_22232164_22232165_1": {"section_id": 7448, "quality": 0.75, "length": 30}}}, "22232165": {"ParentId": "22232164", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The core reason for the <em>unevaluated operands</em> exclusion is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1607\" rel=\"nofollow noreferrer\">C++ Standard Core Language Defect Reports and Accepted Issues #1607. Lambdas in template parameters</a> which seeks to clarify this restriction and states the intention of the restriction in section <code>5.1.2</code> was to:</p>\n<blockquote>\n<p id=\"so_22232164_22232165_0\">[...] avert the need to deal with them in function template signatures [...]</p>\n</blockquote>\n<p>As the issue documents the current wording actually has a hole since <em>costant expressions</em> allows them in an unevaluated context. But it does not outright state the rationale for this restriction. The desire to avoid name mangling stands out and you can infer that avoiding extending <em>SFINAE</em> was also desired since the proposed resolution seeks to tighten the restriction even though several viable alternatives would have allowed <em>SFINAE</em>. The modified version of <code>5.1.2</code> paragraph <em>2</em> as follows:</p>\n<blockquote>\n<p id=\"so_22232164_22232165_1\">A lambda-expression shall not appear in an unevaluated operand (Clause 5 [expr]), <strong>in a template-argument, in an alias-declaration, in a typedef declaration, or in the declaration of a function or function template outside its function body and default arguments [Note: The intention is to prevent lambdas from appearing in a signature \u2014end note]</strong>. [Note: A closure object behaves like a function object (20.10 [function.objects]). \u2014end note] </p>\n</blockquote>\n<p>This proposal was accepted and is in <code>N3936</code>(<em><a href=\"https://stackoverflow.com/a/4653479/1708801\">see this answer for a link</a></em>)</p>\n<p>For a more explicit discussion of the rationale to avoid having lambdas as an <em>unevaluated operand</em>. The discussion titled <a href=\"https://groups.google.com/d/msg/comp.lang.c++.moderated/J9MbhcOrAzY/XjKeWEbU1EcJ\" rel=\"nofollow noreferrer\">Rationale for lambda-expressions not being allowed in unevaluated contexts</a> on comp.lang.cpp.moderated <em>Daniel Kr\u00fcgler</em> lays out three reasons:</p>\n<ol>\n<li><p>The <em>extreme extension</em> of possible <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"nofollow noreferrer\">SFINAE</a> cases :</p>\n<blockquote>\n<p id=\"so_22232164_22232165_2\">[...]The reason why they became excluded was due to exactly this extreme extension of sfinae cases (you were opening a Pandora box for the compiler)[...]</p>\n</blockquote></li>\n<li><p>In many cases it just useless since each lambda has a unique type, the hypothetical example given:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid g(T, U, decltype([](T x, T y) { return x + y; }) func);\n\ng(1, 2, [](int x, int y) { return x + y; });\n</code></pre>\n<p>The type of the lambda in the declaration and the call are different(<em>by definition</em>) and therefore this can not work.  </p></li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Name_mangling\" rel=\"nofollow noreferrer\">Name mangling</a> also becomes a problem since once you allow a <em>lambda</em> in a function signature the bodies of the <em>lambda</em> will have to be mangled as well. This means coming up with rules to mangle every possible <em>statement</em>, which would burdensome for at least some implementations.</p></li>\n</ol>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:03.420", "Id": "22232165", "Score": "11", "CreationDate": "2014-03-06T17:49:39.177", "LastActivityDate": "2015-03-02T13:29:10.133"}});