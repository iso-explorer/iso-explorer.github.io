post_cb({"21948373": {"ParentId": "21948280", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>No.</p>\n<p>In this case, <code>num</code> is the name of an object of type <code>double</code>. Its declaration does not explicitly or implicitly create a pointer. It creates a floating-point object, initialized to <code>32.53</code>.</p>\n<p>You can obtain a pointer <em>value</em> (not a pointer object) by taking the address of the object, as in<code>&amp;num</code>, but you can that for any object.</p>\n<p>As for <code>*num</code>, that's illegal if <code>num</code> is of type <code>double</code>.</p>\n<p>The <em>name</em> of an object is something that refers to the object itself; in that sense, if I squint really hard, I can think of that as a kind of \"pointer\". But a pointer in the C++ sense is a value or object containing a memory address, and it exists while the program is executing; an identifier exists only in the C++ source code. A C++ compiler will have some internal compile-time data structure that refers to a declared variable, that will include (or refer to) information about its name and type, but IMHO it's not reasonable to call that data structure a \"pointer\". It's likely to be something far more complex than a memory address. And the name of a variable declared inside a function will refer to different objects, or to none at all, at different times during the execution of the program.</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2014-02-22T02:02:05.353", "Id": "21948373", "Score": "1", "CreationDate": "2014-02-22T01:23:06.813", "LastActivityDate": "2014-02-22T02:02:05.353"}, "21960689": {"ParentId": "21948280", "CommentCount": "0", "Body": "<p>No. The value <code>num</code> is probably stored in a register, for such a simple example. And on todays CPU's, registers do not have an address.</p>\n<p><code>num</code> is a name of an object. C++ pretends that the object lives at a specific place in memory, but that's not very efficient on modern architectures. Most operations require the value to be in a register, so if the compiler can keep it in a register it will. If not, the compiler may benefit from putting the value in a cache-friendly location. This may not be the same location every time, so value may move around in memory.</p>\n<p>So, the name is far more powerful that a pointer: it follows the value as it moves around in memory. Creating and storing a pointer <code>&amp;num</code> disallows such movements, as moving <code>num</code> would then invalidate the pointer.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "21960689", "Score": "0", "CreationDate": "2014-02-22T21:16:15.313", "LastActivityDate": "2014-02-22T21:16:15.313"}, "21948428": {"ParentId": "21948280", "CommentCount": "1", "Body": "<p>Yes, in the sense that, like a pointer, an identifier is a handle for an object, and not the object itself.  But it is still one fewer level of indirection than a pointer variable (whose name is a handle to the address which is a handle to the object).</p>\n<p>In fact, the compiler will maintain a symbol table which is a mapping from identifier to location of the object (here location is typically not memory address, but offset from the bottom of the stack, or from the beginning of the data segment -- but then again C++ pointers aren't physical addresses either on virtual memory systems)  Normally this symbol table is output by the compiler for use during debugging.  Dynamic languages would actually use the symbol table during execution, to support late-binding and <code>eval()</code>.  But C++ doesn't use identifiers at runtime.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "21948428", "Score": "0", "CreationDate": "2014-02-22T01:30:12.640", "LastActivityDate": "2014-02-22T01:30:12.640"}, "21948441": {"ParentId": "21948280", "CommentCount": "1", "Body": "<p>I think variables in assembly work like that, i.e. that a name is actually a human-readable label for an address. (This article would indicate so, at least: <a href=\"http://www.friedspace.com/assembly/memory.php\" rel=\"nofollow\">http://www.friedspace.com/assembly/memory.php</a> ) In C/C++, however, the name of the variable is actually a dereferenced address. To get the address, you have to use the <code>&amp;</code> operator.</p>\n<p>Pointers in C/C++ are actually variables that contain an address--something that most likely has its own address (though it doesn't need to if the compiler chooses to store the pointer in a CPU register and you don't try to get its address--if you do, then, you're guaranteed to get one).</p>\n", "OwnerUserId": "1084774", "PostTypeId": "2", "Id": "21948441", "Score": "0", "CreationDate": "2014-02-22T01:31:53.587", "LastActivityDate": "2014-02-22T01:31:53.587"}, "21948531": {"ParentId": "21948280", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No.</p>\n<p>From the definition of <em>pointer type</em> of the C standard (at \u00a76.2.5/20):</p>\n<blockquote>\n<p id=\"so_21948280_21948531_0\">A pointer type may be derived from a function type or an object type, called the referenced type. A pointer type <strong>describes an object whose value provides a reference to an entity of the referenced type</strong>. </p>\n</blockquote>\n<p>(emphasis mine).</p>\n<p>In your case:</p>\n<pre><code>double num (32.53);\n</code></pre>\n<p>you have a <code>double</code>, with identifier <code>num</code>, whose value is <code>32.53</code>, which is not intended to use as a pointer value. Not even the type of <code>num</code> is a pointer type. </p>\n<p>Therefore no, <code>num</code> is not a pointer and as the compiler would have told you, if you had tried to compile:</p>\n<pre><code>*num;\n</code></pre>\n<p>you can't dereference it.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-02-22T01:47:43.547", "Id": "21948531", "Score": "1", "CreationDate": "2014-02-22T01:42:27.310", "LastActivityDate": "2014-02-22T01:47:43.547"}, "21948427": {"ParentId": "21948280", "CommentCount": "2", "Body": "<p>If you extend the definition of <em>pointer</em> to \"any conceptual device that refers to some information in memory\" then, yes, absolutely.</p>\n<p>However, nobody does.</p>\n<p>You'd be closer to the money if you used the term <em>handle</em> which has, variably, been used to mean \"pointer\", \"reference\", \"variable\", \"resource object\", \"name\" in source code, \"accessor\", \"identifier\", and myriad other things.</p>\n<p>One generally comes to the conclusion that general terms are too ambiguous, and end up sticking with terms that are either language-specific (such as C++'s \"pointer\", with its very specific semantics, <em>not</em> including those which you have posited), or unambiguous and commonly accepted across the realm of the industry. There are very few of those.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "21948427", "Score": "4", "CreationDate": "2014-02-22T01:30:06.090", "LastActivityDate": "2014-02-22T01:30:06.090"}, "21948280": {"CommentCount": "17", "ViewCount": "183", "PostTypeId": "1", "LastEditorUserId": "2836797", "CreationDate": "2014-02-22T01:12:23.450", "LastActivityDate": "2014-02-22T21:16:15.313", "Title": "In C++ are all names essentialy \"under-the-hood\" pointers?", "AcceptedAnswerId": "21948487", "LastEditDate": "2014-02-22T01:50:18.123", "Id": "21948280", "Score": "0", "Body": "<p>In C++ are names actually pointers-under-the-hood?  For example:</p>\n<pre><code>// num is a name that points to the address of the \n// memory location containing 32.53\ndouble num (32.53);\n\n*num; // so can we deference it and get 32.53?\n\n num; // same as *num but the compiler automatically \n      // dereferences the name for us?\n</code></pre>\n<h2>Clarification:</h2>\n<p>This question was kind of an odd mix of \"What's happening at the machine level?\" and also about the C++ language semantics of pointers.  Thus, I can see why the answers are yes/no.  \"Yes\" because outside of the language semantics, an identifier could be thought of as referring to a location in memory; and \"No\" because that is still not a C++ pointer and it is incorrect to deference a non-pointer double as shown in the code.  </p>\n<p>So I think both camps have successfully answered my question.  It could perhaps be restated as, \"Since names refer to memory locations, why can't they be treated as implicit pointers?\" But such a question might generate fuzzy debates or just not be worth answering. I will carefully go over the answers and try to find the one that (I feel) answers the question the best from both angles.  In other words, one that doesn't just say \"That's not a C++ pointer dummy!\" or \"of course the name points to memory <em>somehow</em>\".</p>\n", "Tags": "<c++><c><pointers>", "OwnerUserId": "2836797", "AnswerCount": "8"}, "21949211": {"ParentId": "21948280", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>What you're talking about really comes down to the definition of an \"lvalue\".</p>\n<p>Let's consider a simple variable like you gave in the question:</p>\n<pre><code>double num = 32.53;\n</code></pre>\n<p><code>num</code> is an <code>lvalue</code>, which roughly translates to the fact that it refers to some location in memory.</p>\n<p>When it's used in an expression, an lvalue can be converted to an rvalue, which translates (roughly) to retrieving the value from that memory location. For example, given an expression like:</p>\n<pre><code>num = num + 1.5;\n</code></pre>\n<p><code>num</code> starts out as an lvalue, but where it's used on the right side of the assignment, it's converted to an rvalue. That basically means the value from that location in memory is fetched, then 1.5 is added to it, then the resulting value is written back to the location in memory that <code>num</code> refers to.</p>\n<p>That does <em>not</em>, however, mean that <code>num</code> is a pointer. <code>num</code> does refer to a location in memory. A pointer is different: it's a variable that refers to some <em>other</em> location in memory. A pointer variable is itself an lvalue. It has a location in memory, and its name refers to that location in memory. The value stored in that location in memory, however, is itself a reference to some location in memory (normally some location <em>other</em> than the pointer itself).</p>\n<p>Perhaps a picture would help:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/35W8o.png\"/></p>\n<p>Here I'm using a solid arrow-line to indicate an association that can't be changed. The rectangles stand for the names of variables, and the sideways diamonds to memory locations. So, <code>num</code> is immutably associated with one location in memory. It can't be modified to refer any other location, and it can't be dereferenced.</p>\n<p>If we define something like:</p>\n<pre><code>double num2 = 12.34;\ndouble *ptr = &amp;num2;\n</code></pre>\n<p>Then we get roughly the situation depicted in the second part of the picture. We've defined <code>num2</code> as a double, just like <code>num</code> is (but holding a different value). We've then defined a pointer (named <code>pointer</code>) that points to <code>num2</code>. In other words, when we dereference <code>pointer</code>, we get <code>num2</code>. The connection from <code>pointer</code> to <code>num2</code> is a dashed line though--indicating that if we chose to, we <em>could</em> change this--we could assign the address of some other <code>double</code> to <code>pointer</code>, which would make <code>pointer</code> refer to that other variable's location.</p>\n<p>Though you haven't asked about it (yet) the third part of the picture shows what we'd get if we defined something like:</p>\n<pre><code>double num3 = 98.76;\ndouble &amp;reference = num3;\n</code></pre>\n<p>In this case, we've created a third object in memory (<code>num3</code>), and we've created a reference (named <code>reference</code>) that refers to <code>num3</code>. I've drawn the location for <code>reference</code> in a lighter color to signify the fact that there may or may not be an actual location in memory used to store the reference itself--it could just be a second name that refers (more or less) directly to the <code>num3</code>. Unlike the pointer, this has a solid line from the reference to the object to which it refers, because it can't be changed--once the reference is created, it always refers to that same location.</p>\n<p>To answer your other question, with a definition like you gave (<code>double num = 32.53;</code>), no you <em>cannot</em> dereference <code>num</code>. An expression like <code>*num = 10.2;</code> simply won't compile. Since the name of the variable always refers to that variable's location, trying to use <code>*</code> to refer to its location simply isn't necessary, supported, or allowed.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2014-02-22T15:53:03.137", "Id": "21949211", "Score": "0", "CreationDate": "2014-02-22T03:21:58.417", "LastActivityDate": "2014-02-22T15:53:03.137"}, "bq_ids": {"n4140": {"so_21948280_21948531_0": {"section_id": 7223, "quality": 0.5909090909090909, "length": 13}}, "n3337": {"so_21948280_21948531_0": {"section_id": 6967, "quality": 0.5909090909090909, "length": 13}}, "n4659": {"so_21948280_21948531_0": {"section_id": 8732, "quality": 0.5454545454545454, "length": 12}}}, "21948487": {"ParentId": "21948280", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A pointer is a programmer-visible <strong>value</strong> which holds the location of some object (or else a null value that doesn't point to an object, or an indeterminate value).</p>\n<p>Although addressing is involved in resolving name references at run-time, names of variables are not pointers in C++. This is because variable names are not run-time values which represent locations; they are compile-time (and in the case of external names with linkage, link-time) <strong>symbols</strong> that denote locations.</p>\n<blockquote>\n<p id=\"so_21948280_21948487_0\">\"Pointer\" and \"address\" are not the same thing. For instance, when we call a function, assuming it is not tail-call optimized or inlined, typically a \"return address\" is stored somewhere so that the function can return to the caller. This address is not a pointer; or at least not a C++ pointer. It is a \"no user serviceable component\" managed behind the scenes by the implementation, just like the stack pointer (if there is such a thing), stack frame pointer and other machine-level features. C++ references, at least in some cases, are also implemented using run-time addresses. C++ references are also not pointers. </p>\n</blockquote>\n<p>There is a run-time pointer value associated with a variable name, and you can access this property using the address-of operator:</p>\n<pre><code>double *pnum = &amp;num;\n</code></pre>\n<p>but not like this:</p>\n<pre><code>*num; // so can we deference it and get 32.53?\n</code></pre>\n<p>Have you tried it? The unary dereference operator requires an expression of pointer type; it won't work with an expression of type <code>double</code>. (It can work with an expression of class type, if suitably overloaded, which is something else.)</p>\n<p>Though by means of the <code>&amp;</code> operator we can get a pointer to the storage location named by <code>num</code>, the name <code>num</code> itself isn't that pointer.</p>\n<p>When we evaluate code like <code>num = 3</code>, quite likely an address is involved. Or maybe not. For instance, if <code>num</code> is optimized into a register, then this just loads <code>3</code> into that register. Even if <code>num</code> has a memory address, that address is not programmer-visible in that situation. Pointers are programmer-visible: the programmer creates them, displaces them, dereferences them, stores them in variables, passes them into functions, and so on.</p>\n<p>In fact a name isn't anything in C++; names need not be retained at run time and are not accessible in any portable way. (Implementations have ways of retaining information about names after compilation, for the sake of symbolic debugging, and platforms that support dynamic linking have ways of looking dynamic symbols from strings.)</p>\n", "OwnerUserId": "1250772", "LastEditorUserId": "1250772", "LastEditDate": "2014-02-22T02:07:52.583", "Id": "21948487", "Score": "4", "CreationDate": "2014-02-22T01:36:50.630", "LastActivityDate": "2014-02-22T02:07:52.583"}});