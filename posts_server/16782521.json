post_cb({"bq_ids": {"n4140": {"so_16782521_16782590_0": {"length": 12, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_16782521_16782590_0": {"length": 12, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_16782521_16782590_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 8653}}}, "16782566": {"Id": "16782566", "PostTypeId": "2", "Body": "<p>The order is undefined.</p>\n<p><a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"noreferrer\">C++ FAQ</a>:</p>\n<blockquote>\n<p id=\"so_16782521_16782566_0\">suppose you have two static objects x and y which exist in separate\n  source files, say x.cpp and y.cpp. Suppose further that the\n  initialization for the y object (typically the y object's constructor)\n  calls some method on the x object.</p>\n<p id=\"so_16782521_16782566_1\">That's it. It's that simple.</p>\n<p id=\"so_16782521_16782566_2\">The tragedy is that you have a 50%-50% chance of dying. If the\n  compilation unit for x.cpp happens to get initialized first, all is\n  well. But if the compilation unit for y.cpp get initialized first,\n  then y's initialization will get run before x's initialization, and\n  you're toast. E.g., y's constructor could call a method on the x\n  object, yet the x object hasn't yet been constructed.</p>\n</blockquote>\n<p>and see <a href=\"http://www.parashift.com/c++-faq/static-init-order-on-first-use.html\" rel=\"noreferrer\">How do I prevent the \"static initialization order fiasco\"?</a>.</p>\n", "LastActivityDate": "2013-05-28T01:28:57.117", "CommentCount": "1", "CreationDate": "2013-05-28T01:28:57.117", "ParentId": "16782521", "Score": "5", "OwnerUserId": "2289509"}, "16782590": {"Id": "16782590", "PostTypeId": "2", "Body": "<p>It's undefined; cf. <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\">What's the \"static initialization order fiasco\"?</a>. The relevant part in the Standard is \u00a73.6.2 \"Initialization of non-local variables\", which says</p>\n<blockquote>\n<p id=\"so_16782521_16782590_0\">Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-28T01:33:12.990", "CommentCount": "1", "CreationDate": "2013-05-28T01:33:12.990", "ParentId": "16782521", "Score": "3", "OwnerUserId": "1873944"}, "16782521": {"ViewCount": "110", "Body": "<p>Assume that I have the following code:</p>\n<pre><code>extern std::string first_string; //defined in another file\nstd::string another_string(first_string + \"some other string\");\n</code></pre>\n<p>My question is:</p>\n<p><strong>Is it guaranteed by the standard that <code>first_string</code> will always be initialized before <code>another_string</code>?</strong></p>\n<p><strong>If not, should code like this be avoided in practice?</strong></p>\n<p>I tried to figure this out by reading C++ standard N3485 Section 3.6 and 3.7. But I did not find a good answer. My great appreciation if you could point me to section of the standard when you draft the answer.\nThank you for your help.</p>\n", "AcceptedAnswerId": "16782566", "Title": "what is the order of initialization between dependence variables across files?", "CreationDate": "2013-05-28T01:23:22.160", "Id": "16782521", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-05-28T01:33:12.990", "Score": "4", "OwnerUserId": "1760345", "Tags": "<c++>", "AnswerCount": "2"}});