post_cb({"bq_ids": {"n4140": {"so_10775361_10775667_8": {"length": 4, "quality": 1.0, "section_id": 3329}, "so_10775361_10775667_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 35}, "so_10775361_10775667_7": {"length": 10, "quality": 0.9090909090909091, "section_id": 36}, "so_10775361_10775667_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}, "so_10775361_10775667_1": {"length": 65, "quality": 0.9285714285714286, "section_id": 7217}, "so_10775361_10775667_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 29}}, "n3337": {"so_10775361_10775667_8": {"length": 4, "quality": 1.0, "section_id": 3199}, "so_10775361_10775667_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 32}, "so_10775361_10775667_7": {"length": 10, "quality": 0.9090909090909091, "section_id": 33}, "so_10775361_10775667_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 25}, "so_10775361_10775667_1": {"length": 65, "quality": 0.9285714285714286, "section_id": 6961}, "so_10775361_10775667_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 26}}, "n4659": {"so_10775361_10775667_8": {"length": 4, "quality": 1.0, "section_id": 4095}, "so_10775361_10775667_6": {"length": 34, "quality": 0.8717948717948718, "section_id": 35}, "so_10775361_10775667_1": {"length": 63, "quality": 0.9, "section_id": 8726}, "so_10775361_10775667_7": {"length": 6, "quality": 0.5454545454545454, "section_id": 34}, "so_10775361_10775667_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}}}, "10775667": {"Id": "10775667", "PostTypeId": "2", "Body": "<p>About <code>long double</code> the draft says:</p>\n<blockquote>\n<p id=\"so_10775361_10775667_0\"><strong>3.9.1 Fundamental Types</strong></p>\n<p id=\"so_10775361_10775667_1\"><strong>8</strong> There are three floating point types: float, double, and long double. The type double provides at least\n  as much precision as float, and the type long double provides at least as much precision as double.\n  The set of values of the type float is a subset of the set of values of the type double; the set of values\n  of the type double is a subset of the set of values of the type long double. The value representation of\n  floating-point types is implementation-defined. Integral and floating types are collectively called arithmetic\n  types. Specializations of the standard template std::numeric_limits (18.3) shall specify the maximum\n  and minimum values of each arithmetic type for an implementation.</p>\n</blockquote>\n<p>As for <em>promotions</em> which is the next most interesting bit:</p>\n<blockquote>\n<p id=\"so_10775361_10775667_2\"><strong>4.6 Floating point promotion</strong></p>\n<p id=\"so_10775361_10775667_3\"><strong>1</strong> A prvalue of type float can be converted to a prvalue of type\n  double. The value is unchanged.</p>\n<p id=\"so_10775361_10775667_4\"><strong>2</strong> This conversion is called floating\n  point promotion.</p>\n</blockquote>\n<p>Note there is nothing being said about <code>double</code> to <code>long double</code>. I'd hazard this as a slip though.</p>\n<p>Next about conversions which is what we are interested when you go from <code>long double</code> to <code>double</code>:</p>\n<blockquote>\n<p id=\"so_10775361_10775667_5\"><strong>4.8 Floating point conversions</strong></p>\n<p id=\"so_10775361_10775667_6\"><strong>1</strong> A prvalue of floating point type can be converted to a prvalue of\n  another floating point type. If the source value can be exactly\n  represented in the destination type, the result of the conversion is\n  that exact representation. If the source value is between two adjacent\n  destination values, the result of the conversion is an\n  implementation-defined choice of either of those values. Otherwise,\n  the behavior is undefined.</p>\n<p id=\"so_10775361_10775667_7\"><strong>2</strong> The conversions allowed as floating point\n  promotions are excluded from the set of floating point conversions.</p>\n</blockquote>\n<p>Now, let's see the effects of <em>narrowing</em>:</p>\n<blockquote>\n<p id=\"so_10775361_10775667_8\"><strong>6</strong>. A narrowing conversion is an implicit conversion</p>\n<p id=\"so_10775361_10775667_9\">[...]</p>\n<ul>\n<li>from long double to double or float, or from double to float, except where the source is a constant expression and the actual value after\n  conversion is within the range of values that can be represented (even\n  if it cannot be represented exactly)</li>\n</ul>\n</blockquote>\n<p>There are two takeaways from all this standardese:</p>\n<ul>\n<li>Combining the bit about narrowing with the bit about implementation defined conversions there may be changes in your results across platforms. </li>\n<li>If your intermediate results (considering multiple such results) in <code>long double</code> are in a range that cannot be represented accurately by a <code>double</code> (high or low), these can accumulate to return a different final result which you will want to return back as a <code>double</code>.</li>\n</ul>\n<p>As for which is <em>more accurate</em>, I think that depends entirely on your application.</p>\n", "LastActivityDate": "2012-05-27T16:53:25.580", "CommentCount": "0", "CreationDate": "2012-05-27T16:53:25.580", "ParentId": "10775361", "Score": "0", "OwnerUserId": "66692"}, "10778136": {"Id": "10778136", "PostTypeId": "2", "Body": "<p>Yes. Proof: Let c = 0x1p-53 + 0x1p-64. Evaluate 1+c-c-1 in double and in long double (of the common Intel format, with a 64-bit significand). In double, the result is 0, which is the mathematically exact answer. In long double, the result is -0x1p-64, which is wrong (and remains wrong when cast to double).</p>\n<p>In double, 1+c adds slightly more than half the ULP (unit of least precision) of 1 to 1, so it produces 1 plus an ULP. Subtracting c subtracts slightly more than half an ULP, so the closest representable number (in double) to the result is 1, so 1 is produced. Then subtracting 1 yields 0.</p>\n<p>In long double, 1+c adds 0x1p-53 plus half an ULP of 1.  (In long double, the ULP of 1 is 0x1p-63.)  Since the result is exactly the same distance from the two nearest representable numbers (in long double), the one with the low bit zero is returned, 1+0x1p-53. Then the exact result of subtracting c is 1 - 0x1p-64. This is exactly representable, so it is returned. Finally, subtracting 1 yields -0x1p-64.</p>\n", "LastActivityDate": "2012-05-28T00:06:47.583", "CommentCount": "0", "CreationDate": "2012-05-28T00:06:47.583", "ParentId": "10775361", "Score": "5", "OwnerUserId": "298225"}, "10775361": {"ViewCount": "298", "Body": "<p>Consider two way of computing something:</p>\n<ol>\n<li>data in double precision<br>\n-&gt; apply a function with double precision temporaries<br>\n-&gt; return result</br></br></li>\n<li>data in double precision<br>\n-&gt; cast to long double<br>\n-&gt; apply a function with long double precision temporaries<br>\n-&gt; cast to double<br>\n-&gt; return result</br></br></br></br></li>\n</ol>\n<p>Can the second solution give a less accurate result compared to the first one and if yes in what case?</p>\n", "AcceptedAnswerId": "10778136", "Title": "C++ cast to a more precise type and lose accuracy?", "CreationDate": "2012-05-27T16:04:59.257", "Id": "10775361", "CommentCount": "8", "LastEditDate": "2012-05-27T16:18:31.950", "PostTypeId": "1", "LastEditorUserId": "635608", "LastActivityDate": "2012-05-28T00:06:47.583", "Score": "3", "OwnerUserId": "882932", "Tags": "<c++><floating-point><precision>", "AnswerCount": "2"}});