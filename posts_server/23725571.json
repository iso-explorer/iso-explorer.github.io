post_cb({"23725687": {"ParentId": "23725571", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-05-18T18:53:46.760", "Score": "2", "LastEditorUserId": "947836", "LastEditDate": "2014-05-18T19:00:05.723", "Id": "23725687", "OwnerUserId": "947836", "Body": "<p>The text (I'm assuming) you're reffering to is this:</p>\n<blockquote>\n<p id=\"so_23725571_23725687_0\"><strong>3.3.4 Function prototype scope [basic.scope.proto]</strong> </p>\n<p id=\"so_23725571_23725687_1\">1 In a function declaration, or in any function declarator except the declarator of a\n  function de\ufb01nition (8.4), names of parameters (if supplied) have\n  function prototype scope, which terminates at the end of the nearest\n  enclosing function declarator.</p>\n</blockquote>\n<p>In a function declaration, for example <code>void foo(int x, int y);</code>, the scope of parameter <code>x</code> is, as per <code>3.3.2</code>, immediately after its complete declarator (that is, immediately after <code>x</code>). Its scope ends at the end of the enclosing function declarator, that is the <code>;</code> that's ending the declaration.</p>\n<p>When talking about function definitions, the scope of parameters is <em>block scope</em> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_23725571_23725687_2\"><strong>3.3.3 Block scope [basic.scope.local]</strong> </p>\n<p id=\"so_23725571_23725687_3\">1 A name declared in a block (6.3) is local to that block; it has\n  <em>block scope</em>. Its potential scope begins at its point of declaration\n  (3.3.2) and ends at the end of its block. A variable declared at block\n  scope is a <em>local variable</em>.  </p>\n<p id=\"so_23725571_23725687_4\">2 <strong>The potential scope of a function parameter name</strong> (including one\n  appearing in a <em>lambda-declarator</em>) or of a function-local prede\ufb01ned\n  variable in a function de\ufb01nition (8.4) <strong>begins at its point of\n  declaration. If the function has a <em>function-try-block</em> the potential\n  scope of a parameter or of a function-local prede\ufb01ned variable ends at\n  the end of the last associated handler, otherwise it ends at the end\n  of the outermost block of the function de\ufb01nition.</strong> A parameter name\n  shall not be redeclared in the outermost block of the function\n  de\ufb01nition nor in the outermost block of any handler associated with a\n  <em>function-try-block</em>.</p>\n</blockquote>\n<p>Basically, it says that the scope of a parameter ends at the closing brace of the definition.</p>\n", "LastActivityDate": "2014-05-18T19:00:05.723"}, "23725571": {"CommentCount": "2", "ViewCount": "158", "CreationDate": "2014-05-18T18:43:44.060", "LastActivityDate": "2014-05-18T20:01:56.840", "Title": "Scope of function parameter name", "AcceptedAnswerId": "23725687", "PostTypeId": "1", "Id": "23725571", "Score": "0", "Body": "<p>What is the scope of function parameter names in c++? I've found that this scope is</p>\n<pre><code>function prototype scope\n</code></pre>\n<p>But what does function prototype scope mean?</p>\n", "Tags": "<c++><scope>", "OwnerUserId": "2786156", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23725571_23725633_0": {"section_id": 7065, "quality": 1.0, "length": 21}, "so_23725571_23725687_3": {"section_id": 7061, "quality": 0.88, "length": 22}, "so_23725571_23725687_4": {"section_id": 7062, "quality": 0.8846153846153846, "length": 46}, "so_23725571_23725687_1": {"section_id": 7065, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_23725571_23725633_0": {"section_id": 6809, "quality": 1.0, "length": 21}, "so_23725571_23725687_3": {"section_id": 6805, "quality": 0.88, "length": 22}, "so_23725571_23725687_1": {"section_id": 6809, "quality": 0.9523809523809523, "length": 20}, "so_23725571_23725687_4": {"section_id": 6806, "quality": 0.8846153846153846, "length": 46}}, "n4659": {"so_23725571_23725633_0": {"section_id": 8562, "quality": 1.0, "length": 21}, "so_23725571_23725687_3": {"section_id": 8558, "quality": 0.88, "length": 22}, "so_23725571_23725687_1": {"section_id": 8562, "quality": 0.9523809523809523, "length": 20}, "so_23725571_23725687_4": {"section_id": 8559, "quality": 0.8846153846153846, "length": 46}}}, "23725633": {"ParentId": "23725571", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-05-18T18:50:33.947", "Score": "2", "LastEditorUserId": "420683", "LastEditDate": "2014-05-18T20:01:56.840", "Id": "23725633", "OwnerUserId": "420683", "Body": "<p>From the C++2011 International Standard</p>\n<blockquote>\n<h3>3.3.4 Function prototype scope [basic.scope.proto]</h3>\n<p id=\"so_23725571_23725633_0\"><sup>1</sup> In a function declaration, or in any function declarator except the declarator of a\n  function definition (8.4), names of parameters (if supplied) have\n  function prototype scope, which terminates at the end of the nearest\n  enclosing function declarator.</p>\n</blockquote>\n<p>For example,</p>\n<pre><code>auto bar(void (*x)(int y)) -&gt; decltype(y);\n</code></pre>\n<p>is illegal since the scope of <code>y</code> ends at the end of <code>void (*x)(int y)</code> (the nearest enclosing function declarator).</p>\n<p>On the other hand,</p>\n<pre><code>void bar(auto (*x)(int y) -&gt; decltype(y));\n</code></pre>\n<p>is legal.</p>\n", "LastActivityDate": "2014-05-18T20:01:56.840"}});