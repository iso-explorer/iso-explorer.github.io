post_cb({"13037837": {"ParentId": "13037490", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>An obvious approach is to use a simple decorator for your stream providing the type and the necessary interface. Here is how this could look like:</p>\n<pre><code>template &lt;typename T&gt;\nstruct irange\n{\n    irange(std::istream&amp; in): d_in(in) {}\n    std::istream&amp; d_in;\n};\ntemplate &lt;typename T&gt;\nstd::istream_iterator&lt;T&gt; begin(irange&lt;T&gt; r) {\n    return std::istream_iterator&lt;T&gt;(r.d_in);\n}\ntemplate &lt;typename T&gt;\nstd::istream_iterator&lt;T&gt; end(irange&lt;T&gt;) {\n    return std::istream_iterator&lt;T&gt;();\n}\n\nfor (auto const&amp; x: irange&lt;std::string&gt;(std::ifstream(\"file\") &gt;&gt; std::skipws)) {\n    ...\n}\n</code></pre>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2014-01-13T21:06:50.663", "Id": "13037837", "Score": "4", "CreationDate": "2012-10-23T19:32:55.137", "LastActivityDate": "2014-01-13T21:06:50.663"}, "13039796": {"ParentId": "13037490", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I attempted to pursue the idea of specializing <code>std::begin</code> and <code>std::end</code> for classes derived  from <code>std::basic_istream</code> (I'm not so great at this template metaprogramming business):</p>\n<pre><code>namespace std\n{\n  template &lt;typename C&gt;\n  typename\n  std::enable_if&lt;\n    std::is_base_of&lt;std::basic_istream&lt;typename C::char_type&gt;, C&gt;::value,\n    std::istream_iterator&lt;std::string&gt;&gt;::type\n  begin(C&amp; c)\n  {\n    return {c};\n  }\n\n  template &lt;typename C&gt;\n  typename\n  std::enable_if&lt;\n    std::is_base_of&lt;std::basic_istream&lt;typename C::char_type&gt;, C&gt;::value,\n    std::istream_iterator&lt;std::string&gt;&gt;::type\n  end(C&amp; c)\n  {\n    return {};\n  }\n}\n</code></pre>\n<p>Actually, it works pretty well. I didn't create versions that take <code>const C&amp;</code> because I don't think it makes sense to extract from a const stream (and I had errors when I tried to do so). I'm also not sure if I can make this more move friendly. So now I can print out the contents of <code>myfile</code> like so::</p>\n<pre><code>std::ifstream file(\"myfile\");\nstd::copy(begin(file), end(file), std::ostream_iterator&lt;std::string&gt;(std::cout, \" \"));\n</code></pre>\n<p>So these <code>begin</code> and <code>end</code> functions work as expected. However, it falls flat when used in a range-based <code>for</code> loop. <code>std::basic_istream</code> classes are derived from <code>std::ios_base</code> which already has a member called <code>end</code> (it's a flag for seeking within a stream). Once the range-based <code>for</code> loop finds this, it just gives up because it can't find a corresponding <code>begin</code> (not to mention that <code>end</code> is not the right kind of entity):</p>\n<blockquote>\n<p id=\"so_13037490_13039796_0\">main.cpp:35:33: error: range-based \u2018for\u2019 expression of type \u2018std::basic_ifstream\u2019 has an \u2018end\u2019 member but not a \u2018begin\u2019</p>\n</blockquote>\n<p>The only alternative that works in both situations, as others have mentioned, is to create a wrapper object. Unfortunately that <code>end</code> member in <code>std::ios_base</code> completely ruins any chance of implementing this in a nice way.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-10-24T17:38:54.267", "Id": "13039796", "Score": "0", "CreationDate": "2012-10-23T21:44:36.610", "LastActivityDate": "2012-10-24T17:38:54.267"}, "13037556": {"ParentId": "13037490", "CommentCount": "4", "Body": "<p>It doesn't matter whether they will be found by argument-dependent lookup, because you are allowed to put specializations of classes and functions in the <code>std</code> namespace.</p>\n", "OwnerUserId": "726361", "PostTypeId": "2", "Id": "13037556", "Score": "1", "CreationDate": "2012-10-23T19:15:34.857", "LastActivityDate": "2012-10-23T19:15:34.857"}, "13037740": {"ParentId": "13037490", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Here is one possible solution. Sadly, it does require an extra structure:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n\nstruct S {\n  std::istream&amp; is;\n  typedef std::istream_iterator&lt;std::string&gt; It;\n  S(std::istream&amp; is) : is(is) {}\n  It begin() { return It(is); }\n  It end() { return It(); }\n};\n\nint main () {\n  std::ifstream file(\"myfile\");\n  for(auto&amp; string : S(file)) {\n    std::cout &lt;&lt; string &lt;&lt; \"\\n\";\n  }\n}\n</code></pre>\n<p>Another solution is to derive from <code>std::ifstream</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n\n\nstruct ifstream : std::ifstream {\n  // using std::ifstream::ifstream; I wish g++4.7 supported inheriting constructors!\n  ifstream(const char* fn) : std::ifstream(fn) {}\n  typedef std::istream_iterator&lt;std::string&gt; It;\n  It begin() { return It(*this); }\n  It end() { return It(); }\n};\n\nint main () {\n  ifstream file(\"myfile\");\n  for(auto&amp; string : file) {\n    std::cout &lt;&lt; string &lt;&lt; \"\\n\";\n  }\n}\n</code></pre>\n", "OwnerUserId": "8747", "LastEditorUserId": "8747", "LastEditDate": "2012-10-23T19:42:06.593", "Id": "13037740", "Score": "1", "CreationDate": "2012-10-23T19:26:46.830", "LastActivityDate": "2012-10-23T19:42:06.593"}, "bq_ids": {"n4140": {"so_13037490_13037490_1": {"section_id": 3906, "quality": 0.9230769230769231, "length": 24}, "so_13037490_13037490_0": {"section_id": 3906, "quality": 0.9047619047619048, "length": 19}, "so_13037490_13039796_0": {"section_id": 3906, "quality": 0.6, "length": 6}}, "n3337": {"so_13037490_13037490_1": {"section_id": 3766, "quality": 0.9230769230769231, "length": 24}, "so_13037490_13037490_2": {"section_id": 3766, "quality": 0.8571428571428571, "length": 18}, "so_13037490_13037490_0": {"section_id": 3766, "quality": 0.9047619047619048, "length": 19}, "so_13037490_13039796_0": {"section_id": 3766, "quality": 0.6, "length": 6}}, "n4659": {"so_13037490_13037490_1": {"section_id": 4792, "quality": 0.7692307692307693, "length": 20}, "so_13037490_13037490_0": {"section_id": 4792, "quality": 0.7619047619047619, "length": 16}, "so_13037490_13039796_0": {"section_id": 4792, "quality": 0.6, "length": 6}}}, "13037490": {"CommentCount": "4", "ViewCount": "2027", "CreationDate": "2012-10-23T19:10:29.173", "LastActivityDate": "2014-01-13T21:06:50.663", "Title": "Range-based loop over an input stream", "FavoriteCount": "4", "PostTypeId": "1", "Id": "13037490", "Score": "6", "Body": "<p>To iterate over an input stream, we would usually use a <code>std::istream_iterator</code> like so:</p>\n<pre><code>typedef std::istream_iterator&lt;std::string&gt; input_iterator;\n\nstd::ifstream file(\"myfile\");\nfor (input_iterator i(file); i != input_iterator(); i++) {\n  // Here, *i denotes each element extracted from the file\n}\n</code></pre>\n<p>It'd be nice if we could use the range-based <code>for</code> statement to iterate over input streams. However, for objects of class type, range-based <code>for</code> requires the object to have <code>begin()</code> and <code>end()</code> member functions (\u00a76.5.4, bold emphasis added):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_13037490_13037490_0\">if <code>_RangeT</code> is an array type, <em>begin-expr</em> and <em>end-expr</em> are <code>__range</code> and <code>__range + __bound</code>, respectively, where <code>__bound</code> is the array bound. If <code>_RangeT</code> is an array of unknown size or an array of incomplete type, the program is ill-formed;</p></li>\n<li><p id=\"so_13037490_13037490_1\"><strong>if <code>_RangeT</code> is a class type</strong>, the <em>unqualified-ids</em> <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <em>begin-expr</em> and <em>end-expr</em> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;  </p></li>\n<li><p id=\"so_13037490_13037490_2\">otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup, namespace <code>std</code> is an associated namespace.</p></li>\n</ul>\n</blockquote>\n<p>The input streams don't have these member functions (they are not Containers) and so range-based <code>for</code> won't work on them. This makes sense anyway because you would need some way to specify the type to extract (<code>std::string</code> in the case above).</p>\n<p>But if we know what we want to extract, is it possible to define our own <code>begin()</code> and <code>end()</code> functions (perhaps specializations or overloads of <code>std::begin()</code> and <code>std::end()</code>) for input streams such that they would be found by class member access lookup as described above?</p>\n<p>It's unclear (at least to me) from \u00a76.5.4 whether the functions will then be looked up with argument-dependent lookup if the previous lookup fails. Another thing to consider is that <code>std::ios_base</code> and its derivatives already have a member called <code>end</code> which is a flag for seeking.</p>\n<p>Here's the intended result:</p>\n<pre><code>std::ifstream file(\"myfile\");\nfor (const std::string&amp; str : file) {\n  // Here, str denotes each element extracted from the file\n}\n</code></pre>\n<p>Or:</p>\n<pre><code>std::ifstream file(\"myfile\");\nfor (auto i = begin(file); i != end(file); i++) {\n  // Here, *i denotes each element extracted from the file\n}\n</code></pre>\n", "Tags": "<c++><c++11><iterator><inputstream>", "OwnerUserId": "150634", "AnswerCount": "4"}});