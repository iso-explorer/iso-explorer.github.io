post_cb({"28659950": {"Id": "28659950", "PostTypeId": "2", "Body": "<p><em>enum class</em> is also called scoped enum.</p>\n<p>enum is pretty much necessary for backwards compatibility reasons.  scoped enum (or enum class) was added, among other reasons, to pin down the underlying type of the enum.</p>\n<p>The details are as follows.  When you do something like this:</p>\n<pre><code>enum MyEnumType {\n   Value1, Value2, Value3\n };\n</code></pre>\n<p>The compiler is free to choose the underlying numeric type of MyEnumType as long as all your values can fit into that type.  This means that the compiler is free to choose char, short, int, long, or another numeric type as the underlying type of MyEnumType.  One practice that's done often is to add a last value to the enumeration to force a minimum size of the underlying type.  For example:</p>\n<pre><code>enum MyEnumType2 {\n   Value1, Value2, Value3, LastValue=0xffffff\n };\n</code></pre>\n<p>is guaranteed to have an underlying type of at least as large as unsigned 32-bit, but it could be larger (for example, 64-bit unsigned).  This flexibility on the compiler's part is good and bad.</p>\n<p>It is good in that you don't have to think about the underlying type.  It is bad in that this is now an uncertainty that is up to the compiler, and if you do think about the underlying type, you can't do anything about it.  This means that the same piece of code can mean different things on different compilers, which may, for example, be a problem if you wanted to do something like this:</p>\n<pre><code> MyEnumType a = ...;\n fwrite(&amp;a, sizeof(a), 1, fp);\n</code></pre>\n<p>Where you're writing the enum to a file.  In this case, switching compiler or adding a new value to the enumeration can cause the file to be misaligned.</p>\n<p>The new scoped enumeration solves this issue,  among other things.  In order to do this, when you declare a scoped enum, there must be a way for the language to fix the underlying type.  The standard is, then, that:</p>\n<pre><code> enum class MyEnumType {\n   ....\n }\n</code></pre>\n<p>defaults to type int.  The underlying type can be explicitly changed by deriving your enum class from the appropriate numeric type.</p>\n<p>For example:</p>\n<pre><code> enum class MyEnumType : char {\n   ....\n }\n</code></pre>\n<p>changes the underlying type to char.  </p>\n<p>For this reason, default underlying type of an enum can change based on how many items and what literal values are assigned to the items in the enumeration.  On the other hand, the default underlying type of an enum class is always int.</p>\n", "LastEditorUserId": "1779316", "LastActivityDate": "2015-02-22T16:57:17.833", "Score": "6", "CreationDate": "2015-02-22T16:02:27.427", "ParentId": "28659804", "CommentCount": "11", "OwnerUserId": "1779316", "LastEditDate": "2015-02-22T16:57:17.833"}, "28659804": {"ViewCount": "2377", "Body": "<p>I am asking why the following code yields an error in Visual Studio 2014 update 4.</p>\n<pre><code>enum A\n{   a = 0xFFFFFFFF };\n\nenum class B\n{   b = 0xFFFFFFFF };\n</code></pre>\n<p>I know that I can use <code>enum class B : unsigned int</code>. But why is the default underlying type of <code>enum</code> different that the default underlying type of <code>enum class</code>? There should be a design decision.</p>\n<hr>\n<p><em>Clarifications</em>\nI forgot to mention the error:</p>\n<blockquote>\n<p id=\"so_28659804_28659804_0\">error C3434: enumerator value '4294967295' cannot be represented as 'int', value is '-1'</p>\n</blockquote>\n<p>That suggests that the <strong>default</strong> underlying type of <code>enum class</code> is <code>signed int</code> while the default type of <code>enum</code> is <code>unsigned int</code>. This question is about the sign part.</p>\n</hr>", "AcceptedAnswerId": "28660475", "Title": "why is the default type of enum class different than the underlying type of enum?", "CreationDate": "2015-02-22T15:49:04.603", "Id": "28659804", "CommentCount": "3", "LastEditDate": "2015-02-22T16:16:26.910", "PostTypeId": "1", "LastEditorUserId": "2549876", "LastActivityDate": "2015-02-22T16:57:30.863", "Score": "2", "OwnerUserId": "2549876", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "28660553": {"Id": "28660553", "PostTypeId": "2", "Body": "<p>That's what the standard requires.  A scoped enum always has an explicit\nunderlying type, which defaults to <code>int</code> unless you say otherwise.</p>\n<p>As for the motivation: superficially, it doesn't make sense to conflate\nthe underlying type with whether the enum is scoped or not.  I suspect\nthat this is done only because the authors want to always be able to\nforward declare scoped enums; at least in theory, the size and\nrepresentation of a pointer to the enum may depend on the underlying\ntype. (The standard calls such forward declarations opaque enum types.)</p>\n<p>And no, I don't think this is really a valid reason for conflating\nscoping and underlying type.  But I'm not the whole committee, and\npresumably, a majority don't feel the way I do about it.  I can't see\nmuch use for specifying the underlying type unless you are forward\ndeclaring the enum; it doesn't help with anything else.  Where as I want\nto use scoped enum pretty much everywhere I'm dealing with a real\nenumeration.  (Of course, a real enumeration will never have values\nwhich won't fit in an <code>int</code>; those really only come up when you're using\nan enum to define bitmasks.)</p>\n", "LastActivityDate": "2015-02-22T16:57:30.863", "CommentCount": "1", "CreationDate": "2015-02-22T16:57:30.863", "ParentId": "28659804", "Score": "1", "OwnerUserId": "649665"}, "bq_ids": {"n4140": {"so_28659804_28660475_6": {"length": 4, "quality": 0.8, "section_id": 6169}, "so_28659804_28660475_1": {"length": 51, "quality": 0.9444444444444444, "section_id": 5466}, "so_28659804_28660475_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 5464}, "so_28659804_28660475_13": {"length": 4, "quality": 0.8, "section_id": 6169}}, "n3337": {"so_28659804_28660475_6": {"length": 4, "quality": 0.8, "section_id": 5930}, "so_28659804_28660475_13": {"length": 4, "quality": 0.8, "section_id": 5930}, "so_28659804_28660475_1": {"length": 51, "quality": 0.9444444444444444, "section_id": 5252}, "so_28659804_28660475_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 5251}, "so_28659804_28659804_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5251}}, "n4659": {"so_28659804_28660475_1": {"length": 51, "quality": 0.9444444444444444, "section_id": 6900}, "so_28659804_28660475_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 6898}}}, "28660475": {"Id": "28660475", "PostTypeId": "2", "Body": "<p>As far as N4140 is concerned, MSVC is correct:</p>\n<blockquote>\n<p id=\"so_28659804_28660475_0\">\u00a77.2/5 Each enumeration defines a type that is different from all\n  other types. Each enumeration also has an underlying type. The\n  underlying type can be explicitly specified using an <em>enum-base</em>. For\n  a scoped enumeration type, the underlying type is <code>int</code> if it is not\n  explicitly specified. [...]</p>\n</blockquote>\n<p>For rationale, you can read the proposal entitled <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf\" rel=\"nofollow\">Strongly Typed Enums (Revision 3) N2347</a>. Namely, section <strong>2.2.2 Predictable/specifiable type (notably signedness)</strong> explains that the underlying type of <code>enum</code> is implementation-defined. For example, N4140 again:</p>\n<blockquote>\n<p id=\"so_28659804_28660475_1\">\u00a77.2/7 For an enumeration whose underlying type is not fixed, the\n  underlying type is an integral type that can represent all the\n  enumerator values defined in the enumeration. If no integral type can\n  represent all the enumerator values, the enumeration is ill-formed. It\n  is implementation-defined which integral type is used as the\n  underlying type except that the underlying type shall not be larger\n  than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or\n  <code>unsigned int</code>. If the <em>enumerator-list</em> is empty, the underlying type\n  is as if the enumeration had a single enumerator with value <code>0</code>.</p>\n</blockquote>\n<p>And N2347's proposed solutions:</p>\n<blockquote>\n<p id=\"so_28659804_28660475_2\">This proposal is in two parts, following the EWG direction to date:</p>\n<p id=\"so_28659804_28660475_3\">\u2022 provide a distinct new enum type having all the features that are\n  considered desirable:</p>\n<blockquote>\n<p id=\"so_28659804_28660475_11\">o enumerators are in the scope of their enum</p>\n<p id=\"so_28659804_28660475_12\">o enumerators and enums do not implicitly convert to int</p>\n<p id=\"so_28659804_28660475_13\">o enums have a defined underlying type</p>\n</blockquote>\n<p id=\"so_28659804_28660475_7\">\u2022 provide pure backward-compatible extensions for plain enums with a\n  subset of those features</p>\n<blockquote>\n<p id=\"so_28659804_28660475_14\">o the ability to specify the underlying type</p>\n<p id=\"so_28659804_28660475_15\">o the ability to qualify an enumerator with the name of the enum</p>\n</blockquote>\n<p id=\"so_28659804_28660475_10\">The proposed syntax and wording for the distinct new enum type is\n  based on the C++/CLI [C++/CLI] syntax for this feature. The proposed\n  syntax for extensions to existing enums is designed for similarity.</p>\n</blockquote>\n<p>So they went with the solution to give scoped enums a defined underlying type.</p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2015-02-22T16:48:44.563", "Score": "2", "CreationDate": "2015-02-22T16:48:44.563", "ParentId": "28659804", "CommentCount": "0"}});