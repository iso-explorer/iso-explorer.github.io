post_cb({"18597656": {"ParentId": "18596412", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This looks like a bug in g++ and VS to me. In your example, your type <code>R</code> is <code>int</code> (because the right-hand operand is <code>int</code>). This then makes the signature of the function <code>Greater&lt;Const&lt;int&gt;, R&gt; operator &gt; (int lhs, int rhs)</code> <em>which is the same (parameter) signature as the builtin <code>operator&lt;</code> for ints</em>. Note that it has to consider both templates (and attempt to deduce types separately for each) when deciding which <code>operator&gt;</code> to use: It can't just look at one of them and decide to ignore the other one.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2013-09-03T17:05:08.077", "Id": "18597656", "Score": "0", "CreationDate": "2013-09-03T16:58:59.223", "LastActivityDate": "2013-09-03T17:05:08.077"}, "18596809": {"ParentId": "18596412", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I must admit, I don't really know why clang complains here, it looks like a bug (of the compiler). Btw, clang 3.3 also exhibits the problem.</p>\n<p>You can suppress it using SFINAE:</p>\n<pre><code>template&lt;typename L&gt;\ntypename std::enable_if&lt;std::is_class&lt;L&gt;::value || std::is_enum&lt;L&gt;::value,\n                        Greater&lt;L, Const&lt;int&gt;&gt;&gt;::type\noperator &gt; (L lhs, int rhs) { \n    return Greater&lt;L, Const&lt;int&gt; &gt;(lhs, Const&lt;int&gt;(rhs));\n}\n\ntemplate&lt;typename R&gt;\ntypename std::enable_if&lt;std::is_class&lt;R&gt;::value || std::is_enum&lt;R&gt;::value,\n                        Greater&lt;Const&lt;int&gt;,R&gt;&gt;::type\noperator &gt; (int lhs, R rhs) { \n    return Greater&lt;Const&lt;int&gt;, R&gt;(Const&lt;int&gt;(lhs), rhs);\n}\n</code></pre>\n", "OwnerUserId": "1023390", "LastEditorUserId": "1023390", "LastEditDate": "2013-09-03T16:12:04.077", "Id": "18596809", "Score": "0", "CreationDate": "2013-09-03T16:06:17.130", "LastActivityDate": "2013-09-03T16:12:04.077"}, "18600649": {"ParentId": "18596412", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Clang is right: operator overloading requires at least one class or enum type parameter, otherwise the program is ill-formed (13.5/1). To see why this error even appears, we have to parse some more Standard legalese.</p>\n<p>Recall the Holy Trinity of Name Lookup, Argument Deduction and Overload Resolution. The first step finds two  overloaded <code>operator&gt;</code>. The second step deduces template arguments for each version. You might think that the second overload would fall victim to the SFINAE rule (14.8.2), so that only the first survives to the third step. However, there is no substition failure (as in e.g. a missing nested typedef), but an illegal construct (see the earlier mentioned 13.5/1). That itself renders the program ill-formed (14.3/6)</p>\n<blockquote>\n<p id=\"so_18596412_18600649_0\">6 If the use of a template-argument gives rise to an ill-formed construct in the instantiation of a template specialization, the program is ill-formed.</p>\n</blockquote>\n<p>In 14.8.3 it is mentioned that this check on the deduced arguments happens before overload resolution, so your preferred operator has no chance of being selected.</p>\n<p>As a C++03 work-around, you could define two friend non-template <code>operator&gt;</code> inside your <code>Var&lt;T&gt;</code> class template. These would be injected into the surrounding (global, in this example) namespace as non-template functions with one class type parameter, so the above error should not occur.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2014-10-26T06:02:07.987", "Id": "18600649", "Score": "7", "CreationDate": "2013-09-03T20:09:52.270", "LastActivityDate": "2014-10-26T06:02:07.987"}, "bq_ids": {"n4140": {"so_18596412_18600649_0": {"section_id": 81, "quality": 1.0, "length": 10}}, "n3337": {"so_18596412_18600649_0": {"section_id": 76, "quality": 1.0, "length": 10}}, "n4659": {"so_18596412_18600649_0": {"section_id": 83, "quality": 1.0, "length": 10}}}, "18596412": {"CommentCount": "6", "ViewCount": "750", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-09-03T15:46:47.383", "LastActivityDate": "2014-10-26T06:02:07.987", "Title": "Strange error with a templated operator overload", "AcceptedAnswerId": "18600649", "LastEditDate": "2013-09-03T20:23:35.350", "Id": "18596412", "Score": "10", "Body": "<p>When I compile the following snippet, I get a compiler error with clang, but not with g++/MSVC:</p>\n<pre><code>#include &lt;string&gt;\n\ntemplate&lt;typename T&gt; struct Const { \n    explicit Const(T val) : value(val) {}\n    T value;\n};\n\ntemplate&lt;typename T&gt; struct Var {\n    explicit Var(const std::string &amp;n) : name(n) {}\n\n    std::string name;\n};\n\ntemplate&lt;typename L, typename R&gt; struct Greater {\n    Greater(L lhs, R rhs) : left(lhs), right(rhs) {}\n\n    L left;\n    R right;\n};\n\ntemplate&lt;typename L&gt;\nGreater&lt;L, Const&lt;int&gt; &gt; operator &gt; (L lhs, int rhs) { \n    return Greater&lt;L, Const&lt;int&gt; &gt;(lhs, Const&lt;int&gt;(rhs));\n}\n\ntemplate&lt;typename R&gt;\nGreater&lt;Const&lt;int&gt;, R&gt; operator &gt; (int lhs, R rhs) { \n    return Greater&lt;Const&lt;int&gt;, R&gt;(Const&lt;int&gt;(lhs), rhs);\n}\n\nVar&lt;double&gt; d(\"d\");\n\nint main() {\n     d &gt; 10;\n     return 0;\n}\n</code></pre>\n<p>The error reported is the following:</p>\n<pre><code>error: overloaded 'operator&gt;' must have at least one parameter of\n      class or enumeration type\nGreater&lt;Const&lt;int&gt;, R&gt; operator &gt; (int lhs, R rhs) { \n                       ^\n./val.h:31:24: note: in instantiation of function template specialization\n      'operator&gt;&lt;int&gt;' requested here\nGreater&lt;Const&lt;int&gt;, R&gt; operator &gt; (int lhs, R rhs) { \n                       ^\n1 error generated.\n</code></pre>\n<p>which is about the operator function that is not used. If, instead, I write 10 &gt; d instead of d &gt; 10, then I get the same error about the other operator &gt; function. The above compiles fine under gcc 4.4.6 and VS2012. What is my mistake ? </p>\n<p>Thank you. </p>\n", "Tags": "<c++><templates><operator-overloading><clang><sfinae>", "OwnerUserId": "227427", "AnswerCount": "3"}});