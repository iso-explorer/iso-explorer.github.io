post_cb({"bq_ids": {"n4140": {"so_14637356_14637534_0": {"length": 33, "quality": 0.825, "section_id": 175}}, "n3337": {"so_14637356_14637534_0": {"length": 36, "quality": 0.9, "section_id": 169}}, "n4659": {"so_14637356_14637534_0": {"length": 25, "quality": 0.625, "section_id": 180}}}, "14637372": {"Id": "14637372", "PostTypeId": "2", "Body": "<p>That's because the condition does not depend in any way on the template parameters. Therefore, the compiler can evaluate it even before instantiating that template, and produces the associated compilation error message if it the evaluation yields <code>false</code>.</p>\n<p>In other words, this is not a bug. Although many things can only be checked once a template is instantiated, there are other validity checks that a compiler can perform even before. This is why C++ has a two-phase name lookup, for instance. The compiler is just trying to help you finding errors that are 100% likely to occur.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-01T00:07:16.897", "Score": "17", "CreationDate": "2013-01-31T23:56:27.290", "ParentId": "14637356", "CommentCount": "10", "OwnerUserId": "1932150", "LastEditDate": "2013-02-01T00:07:16.897"}, "14637356": {"ViewCount": "6018", "Body": "<p>I use g++ 4.6.3, (currently default package for ubuntu 12.04) with the flag c++0x, and I stumble across this:</p>\n<pre><code>template &lt;typename T&gt;\ninline T getValue(AnObject&amp;)\n{\n    static_assert(false , \"this function has to be implemented for desired type\");\n}\n</code></pre>\n<p>with the compilation error:</p>\n<pre><code>static_assertion failed \"this function has to be implemented for the desired type\"\n</code></pre>\n<p><strong>even though I don't call this function anywhere yet</strong>.</p>\n<p>Is it a g++ bug ? Shouldn't this function be instanciated only if it is called somewhere in the code. </p>\n", "AcceptedAnswerId": "14637372", "Title": "static_assert fails compilation even though template function is called nowhere", "CreationDate": "2013-01-31T23:55:00.260", "Id": "14637356", "CommentCount": "0", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2013-02-06T23:32:02.007", "LastEditorUserId": "636019", "LastActivityDate": "2013-02-06T23:32:02.007", "Score": "22", "OwnerUserId": "356440", "Tags": "<c++><templates><c++11><g++><static-assert>", "AnswerCount": "3"}, "14637509": {"Id": "14637509", "PostTypeId": "2", "Body": "<p>This is really a comment, but requiring a code example.</p>\n<p>The holy standard's wording for <code>static_assert</code> does not limit its effect to instantiated code.</p>\n<p>However, the code</p>\n<pre><code>template &lt;typename T&gt;\ninline T getValue(int&amp;)\n{\n    typedef char blah[-1];  // Common C++03 static assert, no special semantics.\n}\n\nint main()\n{}\n</code></pre>\n<p>also fails to compile with MinGW g++ 4.7.2, which accentuates the question.</p>\n<p>I <em>think</em> the answer is that g++ is right, and that Visual C++ 11.0, which does not produce a compilation error for this, is wrong, but I'd be hard pressed to provide the relevant analysis in terms of the Holy Standard's verses.</p>\n<p>A practical consequence of the compiler difference is that presently you can not <em>rely</em> on the behavior.</p>\n", "LastActivityDate": "2013-02-01T00:09:37.243", "CommentCount": "4", "CreationDate": "2013-02-01T00:09:37.243", "ParentId": "14637356", "Score": "3", "OwnerUserId": "464581"}, "14637534": {"Id": "14637534", "PostTypeId": "2", "Body": "<p>The standard says in [temp.res]/8</p>\n<blockquote>\n<p id=\"so_14637356_14637534_0\">No diagnostic shall be issued for a template definition for which a valid specialization can be generated. If no valid specialization can be generated for a template definition, and that template is not instantiated, the template definition is ill-formed, no diagnostic required. ... <em>[ Note:</em> If a template is instantiated, errors will be diagnosed according to the other\n  rules in this Standard. Exactly when these errors are diagnosed is a quality of implementation issue. <em>\u2014 end note ]</em></p>\n</blockquote>\n<p>There is no possible way to instantiate your function template that will compile, so the template definition is ill-formed and so the compiler is allowed (but not required) to reject it even if it isn't instantiated.</p>\n<p>You could make it work like this:</p>\n<pre><code>template&lt;typename T&gt;\nstruct foobar : std::false_type\n{ };\n\ntemplate &lt;typename T&gt;\ninline T getValue(AnObject&amp;)\n{\n    static_assert( foobar&lt;T&gt;::value , \"this function has to be implemented for desired type\");\n}\n</code></pre>\n<p>Now the compiler cannot reject the function template immediately, because until it is instantiated it doesn't know whether there will be a specialization of <code>foobar</code> that has <code>value == true</code>.  When instantiated the relevant specialization of <code>foobar&lt;T&gt;</code> will be instantiated and the static assertion will still fail, as desired.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-02-01T00:16:29.933", "Score": "32", "CreationDate": "2013-02-01T00:11:09.520", "ParentId": "14637356", "CommentCount": "3", "OwnerUserId": "981959", "LastEditDate": "2013-02-01T00:16:29.933"}});