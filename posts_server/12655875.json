post_cb({"12655876": {"Id": "12655876", "PostTypeId": "2", "Body": "<p>Among the normative references listed in <code>[C++11: 1.2]</code> is \"ISO/IEC 9899:1999, Programming languages \u2014 C\".</p>\n<p>In turn, this standard says:</p>\n<blockquote>\n<p id=\"so_12655875_12655876_0\"><code>[C99: 3.5]:</code>\n<strong>1</strong> bit\n  unit of data storage in the execution environment <em>large enough to hold an object that may\n  have one of two values</em></p>\n</blockquote>\n<p>This doesn't preclude a bit being a unit of data storage that's even larger, so C++ as a language indeed could support tri-state bits.</p>\n", "LastActivityDate": "2012-09-29T19:41:43.610", "CommentCount": "26", "CreationDate": "2012-09-29T19:41:43.610", "ParentId": "12655875", "Score": "6", "OwnerUserId": "560648"}, "bq_ids": {"n4140": {"so_12655875_12656129_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7216}, "so_12655875_12655875_0": {"length": 49, "quality": 0.875, "section_id": 5785}, "so_12655875_12656129_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 7216}}, "n3337": {"so_12655875_12656129_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 6960}, "so_12655875_12655875_0": {"length": 49, "quality": 0.875, "section_id": 5558}, "so_12655875_12656129_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 6960}}, "n4659": {"so_12655875_12656129_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 8725}, "so_12655875_12655875_0": {"length": 49, "quality": 0.875, "section_id": 7242}, "so_12655875_12656129_0": {"length": 34, "quality": 0.8292682926829268, "section_id": 8725}}}, "12656129": {"Id": "12656129", "PostTypeId": "2", "Body": "<p>3.9.1.7 says </p>\n<blockquote>\n<p id=\"so_12655875_12656129_0\">Types bool, char, wchar_t, and the signed and unsigned integer types\n  are collectively called integral types.48) A synonym for integral type\n  is integer type. The representations of integral types shall define\n  values by use of a pure  binary numeration system.49) [ Example: this\n  International Standard permits 2\u2019s complement, 1\u2019s complement and\n      signed magnitude representations for integral types. \u2014 end example ]\"</p>\n</blockquote>\n<p>The note <code>49</code> reads</p>\n<blockquote>\n<p id=\"so_12655875_12656129_1\">A positional representation for integers that uses the binary digits 0\n  and 1, in which the values represented by successive bits are\n  additive, begin with 1, and are multiplied by successive integral\n  power of 2, except perhaps for the bit with the highest position.\n  (Adapted from the American National Dictionary for Information\n  Processing Systems.)</p>\n</blockquote>\n", "LastActivityDate": "2012-09-29T20:15:45.100", "CommentCount": "9", "CreationDate": "2012-09-29T20:15:45.100", "ParentId": "12655875", "Score": "2", "OwnerUserId": "126769"}, "12655875": {"ViewCount": "328", "Body": "<p><code>[C++11: 1.7]</code> talks about <em>bytes</em> in terms of bits:</p>\n<blockquote>\n<p id=\"so_12655875_12655875_0\">The fundamental storage unit in the C++ memory model is the byte. A byte is at least large enough to contain any member of the basic execution character set (2.3) and the eight-bit code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address.</p>\n</blockquote>\n<p>However, I cannot find anywhere in the standard that defines \"bit\".</p>\n<p><strong>So is it true to say that C++ does not place limitations on the number of values that may be represented by a single bit?</strong></p>\n<p>Does it allow, say, tri-state bits?</p>\n", "AcceptedAnswerId": "12656129", "Title": "Does C++, as an abstraction, support \"bits\" representing one of more than two values?", "CreationDate": "2012-09-29T19:41:43.610", "Id": "12655875", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-01-04T23:52:15.137", "Score": "12", "OwnerUserId": "560648", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "14166718": {"Id": "14166718", "PostTypeId": "2", "Body": "<p>I'm going to disagree with the accepted answer, since that is emulatable by a ternary machine, which is expressly allowed by the spec.</p>\n<blockquote>\n<p id=\"so_12655875_14166718_0\">\u00a7 3.9.1/4 Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer.<br>\n  \u00a7 1.8/5 An object of trivially copyable or standard-layout type (3.9) shall occupy contiguous bytes of storage.<br>\n  \u00a7 3.9/9 Arithmetic types (3.9.1)... are collectively called scalar types. Scalar types, ... arrays of such types... are collectively called POD types. Scalar types ..., arrays of such types... are collectively called trivially copyable types.<br>\n  \u00a7 3.8/2 For any object... of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value.</br></br></br></p>\n</blockquote>\n<p>The problem here is that at all points, the state of all trivially copiable multibyte objects must be copiable to an array of <code>char</code> and back without loss.  This means that a ternary machine emulating a base 2 machine (as is required by the basic arithmetic types having modulo \"rollovers\"), must emulate those rollovers from each emulated byte to the next in each and every <em>unsigned</em> multibyte arithmetic operation.</p>\n<p>Even this is emulatable on a ternary machine, slowly, but if all primitive types are made of exactly 41 trits than all a compiler has to worry about is unsigned rollover/under, which might be viable.    (Obviously, emulating <code>^</code>, <code>|</code> and <code>&amp;</code> is also slow, but that's less of an issue in my mind)I think it <em>could</em> be done, but is amazingly impracticable to make a standard conforming C++ compiler for a ternary machine. </p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2013-01-04T23:52:15.137", "Score": "1", "CreationDate": "2013-01-04T23:29:17.820", "ParentId": "12655875", "CommentCount": "0", "OwnerUserId": "845092", "LastEditDate": "2013-01-04T23:52:15.137"}});