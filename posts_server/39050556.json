post_cb({"39050556": {"CommentCount": "1", "ViewCount": "50", "PostTypeId": "1", "LastEditorUserId": "1840861", "CreationDate": "2016-08-20T04:44:04.980", "LastActivityDate": "2016-11-06T02:55:40.707", "Title": "Why is the result of uint32_t becoming octal number automatically?", "LastEditDate": "2016-11-06T02:55:40.707", "Id": "39050556", "Score": "-3", "Body": "<pre><code>int main()\n{\n    uint32_t n1 = 00000000000000000000000000001000;\n    uint32_t n2 = 00000000000000000000000000000100;\n    cout &lt;&lt; n2; \n}\n</code></pre>\n<p>When I use Visual Studio 2013 (C++), I am getting the result as 64.  </p>\n<p>Why is this turning to octal number system instead of binary?</p>\n", "Tags": "<c++><uint32-t>", "OwnerUserId": "6737160", "AnswerCount": "2"}, "39050571": {"ParentId": "39050556", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-20T04:46:52.100", "Score": "2", "LastEditorUserId": "14860", "LastEditDate": "2016-08-20T05:08:02.183", "Id": "39050571", "OwnerUserId": "14860", "Body": "<p>Starting a numeric literal with <code>0</code> means you want it interpreted as octal, which is what I assume you meant when you used \"octonary\", a word I haven't seen before and, while it appears to be a real word, you'll probably get some blank stares if you use it :-)</p>\n<p>This treatment as octal is as per the standard, <code>C++11 2.14.2 Integer literals /1</code>:</p>\n<blockquote>\n<p id=\"so_39050556_39050571_0\">An octal integer literal (base eight) begins with the digit 0 and consists of a sequence of octal digits.</p>\n</blockquote>\n<p>For binary numbers, probably the easiest way to do it is with bit shifting (pre C++14):</p>\n<pre><code>uint32_t n1 = 1u &lt;&lt; 3;\nuint32_t n2 = 1u &lt;&lt; 2;\n</code></pre>\n<p>C++14 provides the <code>0b</code> prefix, akin to the <code>0x</code> one for hexadecimal numbers but I'm not entirely convinced that's as readable as the other option if you still use a large number of leading zeros:</p>\n<pre><code>uint32_t n1 = 0b00000000000000000000000000001000;\nuint32_t n2 = 0b00000000000000000000000000000100;\n</code></pre>\n<p>Seasoned coders, of course, can instantly map from binary to hex so would probably just use:</p>\n<pre><code>uint32_t n1 = 0x00000008;\nuint32_t n2 = 0x00000004;\n</code></pre>\n", "LastActivityDate": "2016-08-20T05:08:02.183"}, "bq_ids": {"n4140": {"so_39050556_39050571_0": {"section_id": 5340, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_39050556_39050571_0": {"section_id": 5137, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_39050556_39050571_0": {"section_id": 6761, "quality": 0.9090909090909091, "length": 10}}}, "39050577": {"ParentId": "39050556", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-08-20T04:47:30.417", "Score": "3", "LastEditorUserId": "65863", "LastEditDate": "2016-08-20T05:16:22.923", "Id": "39050577", "OwnerUserId": "3980929", "Body": "<p>That's because a number with a leading <code>0</code> is considered to be an octal number:</p>\n<pre><code>auto num = 04; //Octal number\n</code></pre>\n<p>In C++14 and later, if you want to specify binary numbers, you will have to use the <code>0b</code> prefix:</p>\n<pre><code>uint32_t n2 = 0b00000000000000000000000000000100;\n              ^^\n</code></pre>\n<p>If you can't use C++14, you will have to use bit shifts or similar techniques to get the desired result.</p>\n<p>For decimal numbers, you will <em>have</em> to get rid of the leading <code>0</code>s.</p>\n", "LastActivityDate": "2016-08-20T05:16:22.923"}});