post_cb({"bq_ids": {"n4140": {"so_7670000_7670544_1": {"length": 9, "quality": 0.9, "section_id": 7043}, "so_7670000_7670541_0": {"length": 15, "quality": 0.9375, "section_id": 7043}, "so_7670000_7670544_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 7043}}, "n3337": {"so_7670000_7670544_1": {"length": 10, "quality": 1.0, "section_id": 6788}, "so_7670000_7670541_0": {"length": 16, "quality": 1.0, "section_id": 6788}, "so_7670000_7670544_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 6788}}, "n4659": {"so_7670000_7670544_1": {"length": 9, "quality": 0.9, "section_id": 8540}, "so_7670000_7670541_0": {"length": 15, "quality": 0.9375, "section_id": 8540}, "so_7670000_7670544_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 8540}}}, "7670541": {"Id": "7670541", "PostTypeId": "2", "Body": "<p>This is guaranteed by the standard as it does not violate the one definition rule. In essence, if the declaration and definition of an inline function or template function is the same in multiple translation units, the program shall behave as though there is one definition of it, which extends to its address, when taken. <a href=\"https://stackoverflow.com/questions/7562096/compile-time-constant-id/7562583#7562583\">See my answer to another question that involved static members of template classes.</a></p>\n<p>As for the relevant section of the standard <code>[basic.def.odr]</code>:</p>\n<blockquote>\n<p id=\"so_7670000_7670541_0\">... If the definitions of D satisfy all these requirements, then the\n  program shall behave as if there were a single definition of D. If the\n  definitions of D do not satisfy these requirements, then the behavior\n  is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-06T05:19:36.603", "Score": "4", "CreationDate": "2011-10-06T05:19:36.603", "ParentId": "7670000", "CommentCount": "2", "OwnerUserId": "6210", "LastEditDate": "2017-05-23T11:56:50.540"}, "7670000": {"ViewCount": "928", "Body": "<p>Why does this work?</p>\n<p>I see similar SO questions stating that it does, but could someone explain it in more detail?  Particularly, is this behavior protected by a standard?</p>\n<p><strong>i.h</strong></p>\n<pre><code>#ifndef I_H_\n#define I_H_\n\ntypedef void (*FuncPtr)();\n\ntemplate&lt;typename T&gt;\nvoid FuncTemplate() {}\n\nclass C {};\n\n#endif\n</code></pre>\n<p><strong>a.cc</strong></p>\n<pre><code>#include \"i.h\"\n\nFuncPtr a() {\n  return &amp;FuncTemplate&lt;C&gt;;\n}\n</code></pre>\n<p><strong>b.cc</strong></p>\n<pre><code>#include \"i.h\"\n\nFuncPtr b() {\n  return &amp;FuncTemplate&lt;C&gt;;\n}\n</code></pre>\n<p><strong>m.cc</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\n#include \"i.h\"\n\nFuncPtr a();\nFuncPtr b();\n\nint main() {\n  std::cout &lt;&lt; (a() == b() ? \"equal\" : \"not equal\") &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>Then</p>\n<pre><code>$ g++ -c -o a.o a.cc\n$ g++ -c -o b.o b.cc\n$ g++ -c -o m.o m.cc\n$ g++ a.o b.o m.o -o prog\n$ ./prog\nequal\n</code></pre>\n<p>Tossing <code>-Wall -Wextra -Werror -ansi</code> onto all the <code>g++</code> calls produces the same.</p>\n<p>My (naive) understanding is that <code>FuncTemplate</code> is instantiated once in each of the <code>a.o</code> and <code>b.o</code> compilation units, and so the addresses should each point to one copy.  How do these end up the same after all, and is this behavior portable or protected?</p>\n<p><strong>EDIT</strong> The shared library case:</p>\n<pre><code>$ g++ -shared -o liba.so a.cc\n$ g++ -shared -o libb.so b.cc\n$ g++ -c -o m.o m.cc\n$ g++ -L. -la -lb m.o -o prog\n$ ./prog\nequal\n</code></pre>\n", "AcceptedAnswerId": "7670544", "Title": "Addresses of identical function template instantiations across compilation units", "CreationDate": "2011-10-06T03:15:38.730", "Id": "7670000", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-06-21T16:26:23.237", "LastEditorUserId": "1048862", "LastActivityDate": "2013-06-21T16:26:23.237", "Score": "7", "OwnerUserId": "580412", "Tags": "<c++><function><templates><linker><c++-address>", "AnswerCount": "2"}, "7670544": {"Id": "7670544", "PostTypeId": "2", "Body": "<p>This is covered under the one definition rule:</p>\n<h2>3.2   One definition rule [basic.def.odr]</h2>\n<h3>Paragraph 5:</h3>\n<blockquote>\n<p id=\"so_7670000_7670544_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), <strong>non-static function template (14.5.6)</strong>, static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>\n</blockquote>\n<p>There is a whole list of criteria that follow that have to be-adhered to or its undefined behavior. In the above these do hold. Then ...</p>\n<blockquote>\n<p id=\"so_7670000_7670544_1\">If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D.</p>\n</blockquote>\n<p>So technically you can have a copy of the function in each translation unit.</p>\n<p>It looks like the wording in the last phrase though makes it a requirement that they all behave the same. This means taking the address of any of these objects should result in the same address.</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2011-10-06T05:32:18.737", "Score": "5", "CreationDate": "2011-10-06T05:19:53.890", "ParentId": "7670000", "CommentCount": "2", "OwnerUserId": "14065", "LastEditDate": "2011-10-06T05:32:18.737"}});