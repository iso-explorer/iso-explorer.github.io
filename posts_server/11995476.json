post_cb({"11995783": {"Id": "11995783", "PostTypeId": "2", "Body": "<p>Yes, your assumptions are correct. I may have missed something but I don't get why you can't have something like this:</p>\n<pre><code>struct node\n{\n   T[n];\n   node* next;\n};\n</code></pre>\n", "LastActivityDate": "2012-08-16T21:35:48.663", "CommentCount": "5", "CreationDate": "2012-08-16T21:35:48.663", "ParentId": "11995476", "Score": "1", "OwnerUserId": "1604451"}, "bq_ids": {"n4140": {"so_11995476_11995476_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 6812}}, "n3337": {"so_11995476_11995476_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 6567}, "so_11995476_11995476_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 5650}}, "n4659": {"so_11995476_11995476_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 8304}}}, "11995476": {"ViewCount": "179", "Body": "<p>I'm writing a slice allocator in <strong>C++98</strong>. The allocator will consist of two template classes:</p>\n<ol>\n<li>Low-level allocator class which would allocate the actual memory,</li>\n<li>High-level allocator class which will wrap requested objects as <code>char[]</code> arrays of appropriate length.</li>\n</ol>\n<p>I would like to know whether the assumptions I make below about alignment are valid.</p>\n<hr>\n<p>First of all, I assume that within an array of objects (of type <code>T</code>), each object is properly aligned. I don't see anything specific about that in the standard but it seems like a reasonable assumption to me.</p>\n<p>Considering that, if I take <code>sizeof(T[n])</code>, the returned size should contain any padding necessary and thus be suitable for storing the array <code>T[n]</code>.</p>\n<hr>\n<p>Secondly, <em>18.4.1.1</em> (<code>operator new</code>) states:</p>\n<blockquote>\n<p id=\"so_11995476_11995476_0\">1 <strong>Effects:</strong> The <em>allocation function</em> (3.7.3.1) called by a <em>new-expression</em> (5.3.4) to allocate <em><code>size</code></em> bytes of storage suitably aligned to represent any object of that size.</p>\n</blockquote>\n<p>Thus, I assume that <code>::operator new(sizeof(T[n]))</code> should create a memory block suitably aligned for the array <code>T[n]</code>.</p>\n<hr>\n<p>Finally, <em>9.2</em> (<em>class members</em>) states:</p>\n<blockquote>\n<p id=\"so_11995476_11995476_1\">17 A pointer to a POD-struct object, suitably converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [<em>Note:</em> There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment. ]</p>\n</blockquote>\n<p>Thus, I would assume that in a <code>struct</code> like:</p>\n<pre><code>struct node\n{\n    char data[sizeof(T[n])];\n    node* next;\n};\n</code></pre>\n<p>allocated via <code>new node</code>, the <code>data</code> member will be properly aligned for the array <code>T[n]</code>.</p>\n<hr>\n<p>Are the above assumptions correct or am I missing something? I believe that I have to implement the linked list manually since the C++ standard doesn't give any guarantees about node member order.</p>\n</hr></hr></hr></hr>", "AcceptedAnswerId": "11995783", "Title": "Object array as char array in a linked list -- are my assumptions about alignment valid?", "CreationDate": "2012-08-16T21:10:11.290", "Id": "11995476", "CommentCount": "2", "LastEditDate": "2012-08-16T21:38:04.907", "PostTypeId": "1", "LastEditorUserId": "165333", "LastActivityDate": "2012-08-16T21:38:04.907", "Score": "0", "OwnerUserId": "165333", "Tags": "<c++><alignment>", "AnswerCount": "1"}});