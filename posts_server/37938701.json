post_cb({"37938946": {"ParentId": "37938701", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_37938701_37938946_0\">Is this guaranteed behavior across compilers and platforms though?</p>\n</blockquote>\n<p>No, the behavior is undefined. The standard says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_37938701_37938946_1\"><strong>5 Expressions</strong><br>....<br>\n  If during the evaluation of an expression, the result is not mathematically defined or not in the range of\n  representable values for its type, <strong><em>the behavior is undefined</em></strong>. [ <em>Note</em>: most existing implementations of C++\n  ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and <strong><em>all\n  floating point exceptions vary among machines</em></strong>, and is usually adjustable by a library function. \u2014<em>end note</em> ]</br></br></p>\n</blockquote>\n<p>As <strong>@user2079303</strong> mentioned, in  practice we can be less restricted:</p>\n<blockquote>\n<p id=\"so_37938701_37938946_2\">it is <strong><em>not undefined if</em></strong> <code>std::numeric_limits&lt;float&gt;::has_infinity</code>. Which is often true. In that case, the result is <strong><em>merely unspecified</em></strong>.</p>\n</blockquote>\n", "OwnerUserId": "3246555", "LastEditorUserId": "3246555", "LastEditDate": "2016-06-21T08:56:55.170", "Id": "37938946", "Score": "3", "CreationDate": "2016-06-21T08:12:06.670", "LastActivityDate": "2016-06-21T08:56:55.170"}, "37938701": {"CommentCount": "2", "ViewCount": "108", "CreationDate": "2016-06-21T08:00:33.193", "LastActivityDate": "2016-06-21T08:56:55.170", "Title": "Is maximum float + x defined behavior?", "AcceptedAnswerId": "37938946", "PostTypeId": "1", "Id": "37938701", "Score": "2", "Body": "<p>I did a quick test using the following:</p>\n<pre><code>float x = std::numeric_limits&lt;float&gt;::max();\nx += 0.1;\n</code></pre>\n<p>that resulted in x == std::numeric_limits::max() so it didn't get any bigger than the limit.</p>\n<p>Is this guaranteed behavior across compilers and platforms though? What about HLSL?</p>\n", "Tags": "<c++><hlsl>", "OwnerUserId": "4049658", "AnswerCount": "2"}, "37939208": {"ParentId": "37938701", "CommentCount": "0", "Body": "<p>The value of <code>std::numeric_limits&lt;T&gt;::max()</code> is defined to be the maximum finite value representable by type <code>T</code> (see 18.3.2.4 [numeric.limits.members] paragraph 4). Thus, the question actually becomes multiple subquestions:</p>\n<ol>\n<li>Is it possible to create a value bigger than <code>std::numeric_limits&lt;T&gt;::max()</code>, i.e., is there an infinity?</li>\n<li>If so, which value needs to be added to <code>std::numeric_limits&lt;T&gt;::max()</code> to get the infinity?</li>\n<li>If not, is the behavior defined?</li>\n</ol>\n<p>C++ does not specify the floating point format and different formats may disagree on what the result is. In particular, I don't think floating point formats need to define a value for infinity. For example, <a href=\"https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture\" rel=\"nofollow\">IBM Floating Points</a> do not have an infinity. On the other hand the <a href=\"https://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow\">IEEE 754</a> does have an infinity representation.</p>\n<p>Since overflow of arithmetic types may be undefined behavior (see 5 [expr] paragraph 4) and I don't see any exclusion for floating point types. Thus, the behavior would be undefined behavior if there is no infinity. At least, it can be tested whether a type does have an infinity (see 18.3.2.3 [numeric.limits] paragraph 35) in which case the operation can't overflow.</p>\n<p>If there is an infinity I <em>think</em> adding any value to <code>std::numeric_limits&lt;T&gt;::max()</code> would get you infinity. However, determining whether that is, indeed, the case would require to dig through the respective floating point specification. I could imagine that IEEE 754 might ignore additions if the value is too small to be relevant as is the case for adding <code>0.1</code> to <code>std::numeric_limits&lt;T&gt;::max()</code>. I could also imagine that it decides that it always overflows to infinity.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "37939208", "Score": "1", "CreationDate": "2016-06-21T08:27:07.287", "LastActivityDate": "2016-06-21T08:27:07.287"}, "bq_ids": {"n4140": {"so_37938701_37938946_1": {"section_id": 5937, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_37938701_37938946_1": {"section_id": 5709, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_37938701_37938946_1": {"section_id": 7421, "quality": 0.6904761904761905, "length": 29}}}});