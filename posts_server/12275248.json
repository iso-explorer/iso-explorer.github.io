post_cb({"12275269": {"Id": "12275269", "PostTypeId": "2", "Body": "<p>No, overflow in signed integral types results in undefined behavior.</p>\n<p>EDIT: In addition to paxdiablo's quote:</p>\n<p>3.9.1.</p>\n<blockquote>\n<p id=\"so_12275248_12275269_0\">Note 46) This implies that unsigned arithmetic does not overflow because a\n  result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest\n  value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-09-05T06:05:25.880", "Score": "3", "CreationDate": "2012-09-05T05:57:15.703", "ParentId": "12275248", "CommentCount": "1", "OwnerUserId": "673730", "LastEditDate": "2012-09-05T06:05:25.880"}, "12275248": {"ViewCount": "769", "Body": "<blockquote>\n<p id=\"so_12275248_12275248_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/10011372/c-underflow-and-overflow\">C++ underflow and overflow</a> </br></p>\n</blockquote>\n<p>I have following code in c++:</p>\n<pre><code>int temp = std::numeric_limits&lt;int&gt;::max();\ntemp++;\n</code></pre>\n<p>Am I sure that after incrementation the result will always be &lt;0?</p>\n<p>Thanks</p>\n", "Title": "What happens when i++ causes an integer overflow?", "CreationDate": "2012-09-05T05:55:49.413", "Id": "12275248", "CommentCount": "0", "LastEditDate": "2017-05-23T12:04:47.400", "PostTypeId": "1", "LastEditorDisplayName": "user166390", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-05T06:12:39.530", "ClosedDate": "2012-09-05T06:08:12.770", "Score": "2", "OwnerUserId": "1332475", "Tags": "<c++>", "AnswerCount": "2"}, "12275310": {"Id": "12275310", "PostTypeId": "2", "Body": "<p>No, it's not guaranteed. C++03 has this to say in <code>5 Expressions, paragraph 5</code>:</p>\n<blockquote>\n<p id=\"so_12275248_12275310_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined, unless such an expression is a constant expression, in which case the program is ill-formed. [Note: most existing implementations of C + + ignore integer overflows].</p>\n</blockquote>\n<p>Further, there is nothing in <code>5.7 Additive operators</code> that modifies this behaviour. This is unchanged in C++11.</p>\n<p>That's for signed types, which is what you asked about in your question.</p>\n<hr>\n<p>If you're also interested in unsigned types, section <code>3.9.1 Fundamental types, paragraph 4</code> states:</p>\n<blockquote>\n<p id=\"so_12275248_12275310_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer (see footnote 41).</p>\n<p id=\"so_12275248_12275310_2\">Footnote 41: This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2012-09-05T06:12:39.530", "Score": "4", "CreationDate": "2012-09-05T06:00:04.060", "ParentId": "12275248", "CommentCount": "12", "OwnerUserId": "14860", "LastEditDate": "2012-09-05T06:12:39.530"}, "bq_ids": {"n4140": {"so_12275248_12275310_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 5937}, "so_12275248_12275310_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 7213}, "so_12275248_12275310_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 7213}, "so_12275248_12275269_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7213}}, "n3337": {"so_12275248_12275269_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 6957}, "so_12275248_12275310_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 6957}, "so_12275248_12275310_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 6957}, "so_12275248_12275310_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 5709}}, "n4659": {"so_12275248_12275269_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 8722}, "so_12275248_12275310_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 8722}, "so_12275248_12275310_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 8722}}}});