post_cb({"bq_ids": {"n4140": {"so_24706911_24706911_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3228}}, "n3337": {"so_24706911_24706911_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}}, "n4659": {"so_24706911_24706911_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3985}}}, "24707087": {"Id": "24707087", "PostTypeId": "2", "Body": "<p>This is a Visual C++ language extension: <a href=\"http://msdn.microsoft.com/en-us/library/d88dx3xf\" rel=\"nofollow\">Declaring Unsized Arrays in Member Lists</a>. From the linked MSDN page:</p>\n<blockquote>\n<p id=\"so_24706911_24707087_0\">Unsized arrays can be declared as the last data member in class member lists if the program is not compiled with the ANSI-compatibility option (<code>/Za</code>)</p>\n</blockquote>\n<hr>\n<p>Edit: If the member has been declared as a <em>zero-sized array</em> (like <code>int somearray[0];</code>) instead of an array of unknown bounds (like <code>int somearray[];</code>), this is <em>still</em> a language extension, albeit <a href=\"http://msdn.microsoft.com/en-us/library/7wkxxx2e%28v=vs.71%29.ASPX\" rel=\"nofollow\">a different one</a></p>\n<blockquote>\n<p id=\"so_24706911_24707087_1\">A zero-sized array is legal only when the array is the last field in a struct or union and when the Microsoft extensions (/Ze) are enabled.</p>\n</blockquote>\n<hr>\n<p>This extension is similar to C99's <em>flexible array members</em> C11/n1570 \u00a76.7.2.1/18</p>\n<blockquote>\n<p id=\"so_24706911_24707087_2\">As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a <em>flexible array member</em>.</p>\n</blockquote>\n<p>and /20 contains an example:</p>\n<blockquote>\n<p id=\"so_24706911_24707087_3\">EXAMPLE 2 \u00a0\u00a0 After the declaration:</p>\n<pre><code>struct s { int n; double d[]; };\n</code></pre>\n<p id=\"so_24706911_24707087_4\">the structure <code>struct s</code> has a flexible array member <code>d.</code> A typical\n  way to use this is:</p>\n<pre><code>int m = /* some value */;\nstruct s *p = malloc(sizeof (struct s) + sizeof (double [m]));\n</code></pre>\n<p id=\"so_24706911_24707087_5\">and assuming that the call to <code>malloc</code> succeeds, the object pointed to\n  by <code>p</code> behaves, for most purposes, as if <code>p</code> had been declared as:</p>\n<pre><code>struct { int n; double d[m]; } *p;\n</code></pre>\n<p id=\"so_24706911_24707087_6\">[...]</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-07-11T21:52:57.317", "Score": "3", "CreationDate": "2014-07-11T21:47:45.170", "ParentId": "24706911", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2014-07-11T21:52:57.317"}, "24706957": {"Id": "24706957", "PostTypeId": "2", "Body": "<p>The keyword in \"If the constant-expression (5.19) is present,\" is <strong>if</strong>. It's not, so the first version compiles.</p>\n<p>However, such variant arrays are only permissible (and sane) when they are the <em>last</em> element in a <code>struct</code> or <code>class</code>, where it's expected that they'll use extra space allocated to the struct on a case-by-case basis.</p>\n<p>If an unknown-length array were allowed <em>before</em> other elements, how would other code know <em>where</em> in memory to find those elements?</p>\n", "LastActivityDate": "2014-07-11T21:37:21.433", "CommentCount": "3", "CreationDate": "2014-07-11T21:37:21.433", "ParentId": "24706911", "Score": "6", "OwnerUserId": "1324"}, "24706911": {"ViewCount": "178", "Body": "<p>From ISO/IEC 14882:2003 8.3.4/1:</p>\n<blockquote>\n<p id=\"so_24706911_24706911_0\">If the constant-expression (5.19) is present, it shall be an integral\n  constant expression and its       value shall be greater than zero.</p>\n</blockquote>\n<p>Therefore the following should not compile:</p>\n<pre><code>#pragma once\nclass IAmAClass\n{\npublic:\n    IAmAClass();\n    ~IAmAClass();\n\nprivate:\n    int somearray[0];    // Zero sized array\n};\n</code></pre>\n<p>But it does. However, the following:</p>\n<pre><code>#pragma once\nclass IAmAClass\n{\npublic:\n    IAmAClass();\n    ~IAmAClass();\n\nprivate:\n    int somearray[0];\n    int var = 23;     // Added this expression\n};\n</code></pre>\n<p>does not compile, with the following error (as what would be expected) (Visual C++)</p>\n<pre><code>error C2229: class 'IAmAClass' has an illegal zero-sized array\n</code></pre>\n<p>When the code is in a function, it, in accordance with the standard, will never compile.</p>\n<p>So, why does the code behave in such a way in a header file, where the difference of the compilation passing or failing appears to be down to whether a statement proceeds the zero sized array declaration or not.</p>\n", "AcceptedAnswerId": "24706957", "Title": "C++ Zero Length Arrays in Header File", "CreationDate": "2014-07-11T21:33:58.197", "Id": "24706911", "CommentCount": "6", "LastEditDate": "2014-07-11T21:44:39.900", "PostTypeId": "1", "LastEditorDisplayName": "user1998032", "OwnerDisplayName": "user1998032", "LastActivityDate": "2014-07-11T21:52:57.317", "Score": "2", "Tags": "<c++>", "AnswerCount": "2"}});