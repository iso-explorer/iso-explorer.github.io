post_cb({"7052718": {"ParentId": "7052677", "CommentCount": "0", "Body": "<p>I can't really see through your question or your code, but in general, the containers in the standard C++ library offer you a loose guarantee that concurrent access at different elements is thread-safe. Be sure to understand the implications and limitations of that, though: If you have a random-access container, or iterators to elements, and you only use those to read or change an element value, then as long as you're doing that at different elements, the result should be well-defined. What isn't OK is changing the container itself, so any erase or insert operations have to be serialized (e.g. by locking access to the entire container), and be sure to understand your container's iterator and reference invalidation rules when you do that.</p>\n<p>For individual containers you might be able to say a bit more - for example, insert/erase in a tree-based container, and insert/erase in the middle of a random-access container almost certainly requires a global lock. In a vector/deque you'll need to reacquire iterators. In a list, you <em>might</em> get away with performing insertions concurrently at distinct locations.</p>\n<p>Any global operations like <code>size()</code> and <code>empty()</code> need to be serialized as well.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "7052718", "Score": "3", "CreationDate": "2011-08-13T19:16:25.587", "LastActivityDate": "2011-08-13T19:16:25.587"}, "7052677": {"CommentCount": "4", "CreationDate": "2011-08-13T19:08:27.347", "PostTypeId": "1", "AcceptedAnswerId": "7052863", "LastEditorUserId": "325519", "LastActivityDate": "2011-08-14T02:32:41.487", "LastEditDate": "2011-08-13T19:18:13.333", "ViewCount": "5174", "FavoriteCount": "1", "Title": "STL and multithread", "Id": "7052677", "Score": "2", "Body": "<p>I'm aware, that I need to use mutex, when I perform operations on single STL container inside multiple threads. However I want to know if there are any exceptions from this rule. Please consider simplified scenario I'm trying to implement.</p>\n<p>I have multiple threads adding elements to container and operation is surrounded with mutex lock/unlock. Then threads notify somehow (e.g. using eventfd on linux) single thread dedicated to dispatch elements in this container. What I want to do is to access first element in container without using mutex. Sample code based on deque but note that I ca use any container with queue capability:</p>\n<pre><code>std::mutex     locker;\nstd:deque&lt;int&gt; int_queue;\nint            fd; // eventfd\neventfd_t      buffer;\nbool           some_condition;\n</code></pre>\n<p>Thread 1, 2, 3, etc.</p>\n<pre><code>locker.lock ();\nint_queue.push_back (1);\nlocker.unlock ();\n\neventfd_write (fd, 1);\n</code></pre>\n<p>Thread dedicated to dispatch elements:</p>\n<pre><code>while (true)\n{\n    bool some_condition (true);\n\n    locker.lock ();\n    if (int_quque.empty () == false)\n    {\n        locker.unlock ();\n    }\n    else\n    {\n        locker.unlock ();\n        eventfd_read (fd, &amp;buffer);\n    }\n\n    while (some_condition)\n    {\n        int&amp; data (int_queue.front ());\n\n        some_condition = some_operation (data); // [1]\n    }\n\n    locker.lock ();\n    int_queue.pop ();\n    locker.unlock ();\n}\n</code></pre>\n<p>[1] I will do some_operation() on signle element many times, that's why I want to avoid mutex locking here. It's to expensive.</p>\n<p>I want to know if this code can lead to any synchronisation problems or something.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "325519", "AnswerCount": "5"}, "7053824": {"ParentId": "7052677", "CommentCount": "1", "Body": "<p>Why do you want to do this? Why does the consumer thread not extract the object within the lock, and then process it out of band? </p>\n<p>Assuming that what you want to avoid is having to <em>copy</em> the object outside of the container, a simpler easier to maintain approach could be dynamically allocating the objects, using a container of (smart) pointers and extracting it within the lock (minimal cost). Then you no longer need to consider thread safety issues.</p>\n<p>Note that even if you might be able to pull this off in this particular scenario, you cannot use more than one consumer thread. I would recommend against the approach and just find a different approach where you can meet your requirements without walking over the bleeding edge. Multithreading is hard to do right, and very hard to debug or even detect that there is an issue. By adhering to common patterns you make your code easier to reason about and to maintain.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "7053824", "Score": "0", "CreationDate": "2011-08-13T22:56:41.860", "LastActivityDate": "2011-08-13T22:56:41.860"}, "7054620": {"ParentId": "7052677", "CommentCount": "0", "Body": "<p>If you do want to a lock free queue, I also recommend you look at <a href=\"http://drdobbs.com/cpp/210604448?pgno=2\" rel=\"nofollow\">http://drdobbs.com/cpp/210604448?pgno=2</a></p>\n", "OwnerUserId": "862231", "PostTypeId": "2", "Id": "7054620", "Score": "0", "CreationDate": "2011-08-14T02:32:41.487", "LastActivityDate": "2011-08-14T02:32:41.487"}, "7052835": {"ParentId": "7052677", "LastEditDate": "2011-08-13T20:31:35.223", "CommentCount": "2", "CreationDate": "2011-08-13T19:43:22.347", "OwnerUserId": "61289", "LastEditorUserId": "61289", "PostTypeId": "2", "Id": "7052835", "Score": "0", "Body": "<p>For this particular example this is <em>not</em> safe</p>\n<pre><code>int&amp; data (int_queue.front ());\n</code></pre>\n<p><strike>You take a reference to the first element, it could be moved by another thread adding element adding to the queue forcing it to re allocate (deques are typically implemented as \"wrap-around\" arrays).</strike> If you copy the value as opposed to taking a reference, depending on the implementation you <em>might</em> get away with it. If you want to be able to do this, a std::deque doesn't come with any standard \"exceptions\" to this rule. It's certainly possible to write a data structure similar to a deque where this would be safe, but a deque is not guaranteed to be written like (and is unlikley to be written like) that.</p>\n", "LastActivityDate": "2011-08-13T20:31:35.223"}, "7052863": {"ParentId": "7052677", "LastEditDate": "2011-08-13T20:03:23.657", "CommentCount": "0", "CreationDate": "2011-08-13T19:48:33.333", "OwnerUserId": "576911", "LastEditorUserId": "576911", "PostTypeId": "2", "Id": "7052863", "Score": "6", "Body": "<p>What you need is <em>reference stability</em>.  I.e. you can use containers this way if the reference to the first element is not invalidated when the container is push_back'd.  And even then, you'll want to obtain the reference to the front element under the lock.</p>\n<p>I'm more familiar with <code>std::condition_variable</code> for the event notification, so I'll use that:</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n#include &lt;deque&gt;\n\nstd::mutex              locker;\nstd::deque&lt;int&gt;         int_queue;\nstd::condition_variable cv;\n\nvoid thread_1_2_3()\n{\n    // use lock_guard instead of explicit lock/unlock\n    //    for exception safety\n    std::lock_guard&lt;std::mutex&gt; lk(locker);\n    int_queue_.push_back(1);\n    cv.notify_one();\n}\n\nvoid dispatch()\n{\n    while (true)\n    {\n        bool some_condition = true;\n        std::unique_lock&lt;std::mutex&gt; lk(locker);\n        while (int_queue.empty())\n            cv.wait(lk);\n        // get reference to front under lock\n        int&amp; data = int_queue.front();\n        lk.unlock();\n        // now use the reference without worry\n        while (some_condition)\n            some_condition = some_operation(data);\n        lk.lock();\n        int_queue.pop_front();\n    }\n}\n</code></pre>\n<p>23.3.3.4 [deque.modifiers] says this about <code>push_back</code>:</p>\n<blockquote>\n<p id=\"so_7052677_7052863_0\">An insertion at either end of the deque invalidates all the iterators\n  to the deque, but has no effect on the validity of references to\n  elements of the deque.</p>\n</blockquote>\n<p>That is the key to allowing you to hang onto that reference outside of the lock.  If <code>thread_1_2_3</code>  starts inserting or erasing in the middle, then you can no longer hang on to this reference.</p>\n<p>You can't use a <code>vector</code> this way.  But you could use a <code>list</code> this way.  Check each container you want to use this way for reference stability.</p>\n", "LastActivityDate": "2011-08-13T20:03:23.657"}, "bq_ids": {"n4140": {"so_7052677_7052863_0": {"section_id": 817, "quality": 1.0, "length": 14}}, "n3337": {"so_7052677_7052863_0": {"section_id": 806, "quality": 1.0, "length": 14}}, "n4659": {"so_7052677_7052863_0": {"section_id": 876, "quality": 1.0, "length": 14}}}});