post_cb({"44161611": {"ViewCount": "80", "Body": "<p>I am trying to compile C++14 project of mine with gcc 6.3 and I am getting:</p>\n<pre><code>hm3/pairblob.cc: In static member function 'static std::unique_ptr&lt;hm3::PairBlob&gt; hm3::PairBlob::create(const hm3::PairBlob*)':\nhm3/pairblob.cc:64:44: error: exception cleanup for this placement new selects non-placement operator delete [-fpermissive]\n  std::unique_ptr&lt;PairBlob&gt; pair{ new(size) PairBlob };\n                                            ^~~~~~~~\nIn file included from /usr/include/c++/6.3.1/ext/new_allocator.h:33:0,\n                 from /usr/include/c++/6.3.1/armv7l-unknown-linux-gnueabihf/bits/c++allocator.h:33,\n                 from /usr/include/c++/6.3.1/bits/allocator.h:46,\n                 from /usr/include/c++/6.3.1/memory:63,\n                 from hm3/pairblob.h:10,\n                 from hm3/pairblob.cc:1:\n/usr/include/c++/6.3.1/new:125:6: note: 'void operator delete(void*, std::size_t)' is a usual (non-placement) deallocation function in C++14 (or with -fsized-deallocation)\n void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT\n      ^~~~~~~~\n</code></pre>\n<p>Code is relatively complicated but this is the part in question:</p>\n<pre><code>std::unique_ptr&lt;PairBlob&gt; PairBlob::create(const PairBlob *src){\n    if (src == nullptr)\n        return {};\n\n    size_t const size = src-&gt;getBytes();\n\n    std::unique_ptr&lt;PairBlob&gt; pair{ new(size) PairBlob };\n\n    memcpy(pair.get(), src, size);\n\n    return pair;\n}\n</code></pre>\n<p>This <code>PairBlob::create</code> is a static method. <code>PairBlob</code> is a POD and have private default c-tor and have no d-tor:</p>\n<pre><code>struct PairBlob{\nprivate:\n    PairBlob() = default;\n\n    static void *operator new(size_t, size_t const size){\n        return ::operator new(size);\n    }\n\n    static void *operator new(size_t, size_t const size, const std::nothrow_t){\n        return ::operator new(size, std::nothrow);\n    }\n\n// ...\n</code></pre>\n<p>Error appear only on C++14, compiling with C++11 is without error.\nI am currently working on 32 bit ARM but I do not think this is related.</p>\n<p><strong>UPDATE</strong></p>\n<p>I found if I comment out the c-tor, code works. But in this case the c-tor is public and this is not what I want.</p>\n<p>If I do code like this, it does give same error</p>\n<pre><code>PairBlob() noexcept = default;\n</code></pre>\n<p><strong>UPDATE</strong></p>\n<p>I because I am providing <code>new</code> operators, I decided to provide <code>delete</code> as well. Now it compiles correctly. I did put some <code>noexcept</code> but they are not really required.</p>\n<pre><code>struct PairBlob{\nprivate:\n    PairBlob() = default;\n\n    static void *operator new(size_t, size_t const size){\n        return ::operator new(size);\n    }\n\n    static void *operator new(size_t, size_t const size, const std::nothrow_t) noexcept{\n        return ::operator new(size, std::nothrow);\n    }\n\npublic:\n    // fixing C++14 error\n    static void operator delete(void* memory){\n        ::operator delete(memory);\n    }\n</code></pre>\n<p>I am not posting this as answer, because I still do not understand why gcc can not use \"normal\" operator delete.</p>\n", "AcceptedAnswerId": "44167468", "Title": "exception cleanup error on gcc 6.3 with C++14", "CreationDate": "2017-05-24T14:39:28.557", "Id": "44161611", "CommentCount": "6", "LastEditDate": "2017-05-24T15:44:03.100", "PostTypeId": "1", "LastEditorUserId": "964080", "LastActivityDate": "2017-05-25T15:30:05.300", "Score": "1", "OwnerUserId": "964080", "Tags": "<gcc><c++14>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44161611_44167468_0": {"length": 12, "quality": 1.0, "section_id": 6829}, "so_44161611_44167468_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 7181}, "so_44161611_44167468_3": {"length": 9, "quality": 1.0, "section_id": 6820}, "so_44161611_44167468_1": {"length": 22, "quality": 0.7857142857142857, "section_id": 6850}, "so_44161611_44167468_5": {"length": 13, "quality": 0.8666666666666667, "section_id": 7181}, "so_44161611_44167468_6": {"length": 41, "quality": 1.0, "section_id": 7181}}, "n3337": {"so_44161611_44167468_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6581}, "so_44161611_44167468_4": {"length": 11, "quality": 0.8461538461538461, "section_id": 6925}, "so_44161611_44167468_3": {"length": 5, "quality": 0.5555555555555556, "section_id": 6581}, "so_44161611_44167468_6": {"length": 41, "quality": 1.0, "section_id": 6925}}, "n4659": {"so_44161611_44167468_0": {"length": 12, "quality": 1.0, "section_id": 8321}, "so_44161611_44167468_5": {"length": 13, "quality": 0.8666666666666667, "section_id": 8689}, "so_44161611_44167468_4": {"length": 9, "quality": 0.6923076923076923, "section_id": 8689}, "so_44161611_44167468_3": {"length": 9, "quality": 1.0, "section_id": 8312}, "so_44161611_44167468_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 8312}}}, "44167468": {"Id": "44167468", "PostTypeId": "2", "Body": "<h2>Short answer:</h2>\n<p>As of C++14, global function <code>void operator delete(void*, size_t) noexcept</code> is defined as a usual (non-placement) <code>delete</code> function, and thus is no longer considered a placement <code>delete</code> function (this behaviour matches <code>static</code> member function <code>void T::operator delete(void*, size_t) noexcept</code>, which is a usual <code>delete</code> function).  This means it can't match any placement <code>new</code> functions, causing the error when lookup discovers it while looking for <code>void* PairBlob::operator new(size_t, size_t)</code>'s match.</p>\n<p>Adding <code>void PairBlob::operator delete(void*)</code> prevents lookup from discovering the aforementioned global <code>operator delete()</code> overload, and thus the placement <code>new</code> won't call a placement <code>delete</code> if the constructor throws.</p>\n<hr>\n<h2>Long answer:</h2>\n<p>Compare the functions described in <code>[new.delete.single]</code> in C++11 and C++14 (all information other than <code>delete</code> function signatures omitted for brevity).</p>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n3337/new.delete.single\" rel=\"nofollow noreferrer\">C++11</a></h3>\n<blockquote id=\"so_44161611_44167468_0\">\n<pre><code>void operator delete(void* ptr) noexcept;\nvoid operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;\n</code></pre>\n</blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4140/new.delete.single\" rel=\"nofollow noreferrer\">C++14</a></h3>\n<blockquote id=\"so_44161611_44167468_1\">\n<pre><code>void operator delete(void* ptr) noexcept;\nvoid operator delete(void* ptr, std::size_t size) noexcept;\nvoid operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;\nvoid operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;\n</code></pre>\n</blockquote>\n<p><sup>Examination of <a href=\"https://timsong-cpp.github.io/cppwp/n4140/new.delete.single#14\" rel=\"nofollow noreferrer\">C++14 <code>[new.delete.single/14]</code></a> appears to indicate that if present, <code>size</code> must be the value implicitly passed to the usual <code>void* operator new(size_t)</code>, when called as <code>new Whatever</code>.</sup></p>\n<p>As specified in <code>[basic.stc.dynamic/2]</code>, out of these single-object <code>delete</code> functions, the following are implicitly declared, in global scope, in all translation units:</p>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.stc.dynamic#2\" rel=\"nofollow noreferrer\">C++11</a></h3>\n<blockquote id=\"so_44161611_44167468_2\">\n<pre><code>void operator delete(void*);\n</code></pre>\n</blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.stc.dynamic#2\" rel=\"nofollow noreferrer\">C++14</a></h3>\n<blockquote id=\"so_44161611_44167468_3\">\n<pre><code>void operator delete(void*) noexcept;\nvoid operator delete(void*, std::size_t) noexcept;\n</code></pre>\n</blockquote>\n<hr>\n<p>Similarly, in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.stc.dynamic.deallocation#2\" rel=\"nofollow noreferrer\">C++14</a>, <code>[basic.stc.dynamic.deallocation/2]</code> contains this clause:</p>\n<blockquote>\n<p id=\"so_44161611_44167468_4\">The global <code>operator delete</code> with exactly two parameters, the second of which has type <code>std::size_t</code>, is a usual deallocation function.</p>\n</blockquote>\n<p>This clause isn't present in the <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.stc.dynamic.deallocation#2\" rel=\"nofollow noreferrer\">C++11</a> version of <code>[basic.stc.dynamic.deallocation/2]</code>.</p>\n<p>Furthermore, <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.stc.dynamic#footnote-37\" rel=\"nofollow noreferrer\">footnote 37 in the C++14</a> version, referring to <code>operator delete(void* ptr, size_t) noexcept</code> and <code>operator delete[](void* ptr, size_t) noexcept</code>, states that:</p>\n<blockquote>\n<p id=\"so_44161611_44167468_5\">This deallocation function precludes use of an allocation function <code>void operator new(std::size_t, std::size_t)</code> as a placement allocation function (<a href=\"https://timsong-cpp.github.io/cppwp/n4140/diff.cpp11.basic\" rel=\"nofollow noreferrer\">[diff.cpp11.basic]</a>).</p>\n</blockquote>\n<p>The linked page notes that this change may break valid C++11 code which relies on global function <code>void operator delete(void*, size_t) noexcept</code> being a placement <code>delete</code> function, causing the program to be ill-formed when compiled as C++14.  This matches the sized <code>delete</code> function's behaviour as a class member, where code that relies on <code>static</code> member function <code>void T::operator delete(void*, size_t) noexcept</code> being a placement <code>delete</code> function is ill-formed.</p>\n<p>In regards to <code>static</code> member function <code>void T::operator delete(void*, size_t)</code>, <code>[basic.stc.dynamic.deallocation/2]</code> states, in both <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.stc.dynamic.deallocation#2\" rel=\"nofollow noreferrer\">C++11</a> and <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.stc.dynamic.deallocation#2\" rel=\"nofollow noreferrer\">C++14</a>, that:</p>\n<blockquote>\n<p id=\"so_44161611_44167468_6\">If a class <code>T</code> has a member deallocation function named <code>operator delete</code> with exactly one parameter, then that function is a usual deallocation function. If class <code>T</code> does not declare such an <code>operator delete</code> but does declare a member deallocation function named <code>operator delete</code> with exactly two parameters, the second of which has type <code>std::size_t</code>, then this function is a usual deallocation function.</p>\n</blockquote>\n<p><sup>Quote taken from C++14 version.  The C++11 version clarifies that \"usual\" means \"non-placement\", and links to <code>[support.types]</code> for a definition of <code>std::size_t</code>.  The C++14 version clarifies the meaning of \"usual\" before reaching this clause, and omits the link to <code>[support.types]</code>.</sup></p>\n<hr>\n<p><code>[expr.new]</code> (specifically, <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.new#20\" rel=\"nofollow noreferrer\"><code>[expr.new/20]</code> in C++11</a>, and <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.new#22\" rel=\"nofollow noreferrer\"><code>[expr.new/22]</code> in C++14</a>) indicates that for a call to any placement <code>new</code> function, it will try to find a corresponding placement <code>delete</code> function via lookup, which will be called if the constructor throws when using that placement <code>new</code>; an <code>operator delete()</code> will be considered a match if its parameter list matches the <code>operator new()</code>'s parameter list (with the exception of the first parameter, which must always be <code>size_t</code> for <code>operator new()</code> and <code>void*</code> for <code>operator delete()</code>).  As deallocation functions <a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.stc.dynamic#deallocation-1\" rel=\"nofollow noreferrer\">must be either global or class members</a>, name lookup rules state that when matching <code>T::operator new()</code>, it will fall back to the global <code>operator delete()</code>s if no member <code>operator delete()</code>s are found.  [See <a href=\"http://coliru.stacked-crooked.com/a/a95473693dc773c9\" rel=\"nofollow noreferrer\">here</a> for a demonstration of this behaviour.]</p>\n<p>If a corresponding function is discovered by lookup, and that function is a placement <code>delete</code> function, all is well and good; if it's not, however, then the program is ill-formed.  Therein lies the rub; since <code>PairBlob</code> doesn't originally contain an <code>operator delete()</code>, lookup falls back to the global scope, and locates <code>void operator delete(void*, size_t)</code> (if present).  This is a placement <code>delete</code> function in C++11 or earlier (and may not even be present, in which case see the below paragraph), but an implicitly declared usual <code>delete</code> function in C++14 or later (and thus always present), meaning that any code which relies on it as a placement <code>delete</code> becomes ill-formed during the transition from C++11 to C++14.</p>\n<p>If no corresponding function is discovered by lookup, however, then no placement <code>delete</code> function will be called if the constructor throws.  This is why adding <code>void PairBlob::operator delete(void*)</code> removes the error; as lookup stops when it finds this function, the global <code>operator delete(void*, size_t) noexcept</code> will not be discovered, and thus the program won't become ill-formed by trying to use it as a placement <code>delete</code> function.  [Note, however, that adding <code>void PairBlob::operator delete(void*, size_t)</code> would cause the same error as relying on the global one, as <code>static void T::operator delete(void*, size_t) noexcept</code> is also a usual delete function.]</p>\n<p>GCC 6 defaults to C++14, <a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=812058\" rel=\"nofollow noreferrer\">which has caused this to occur before</a>.  MSVC 2015 and later will also catch this, and emit error C2956; it doesn't appear to have a corresponding MSDN page at the moment, but <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/1351894\" rel=\"nofollow noreferrer\">this bug report</a> explicitly refers to <code>[expr.new/22]</code> (albeit by its number, \u00a7 5.3.4/22, rather than its name).  Surprisingly, however, Clang fails to catch it, and will continue to treat <code>void operator delete(void*, size_t) noexcept</code> as a placement <code>delete</code>.  [Compare them <a href=\"https://godbolt.org/g/o7QvdO\" rel=\"nofollow noreferrer\">here</a>, if you want.]</p>\n<p>As mentioned on the GCC link above, the best solution is to modify the code to be compatible with C++14, but compiling with a previous C++ standard is a viable workaround.  Adding a member <code>operator delete()</code> that prevents name lookup from finding the global one does indeed prevent this problem, but I'm not sure whether it would be better to modify the placement <code>new</code> instead.</p>\n</hr></hr></hr>", "LastEditorUserId": "5386374", "LastActivityDate": "2017-05-25T15:30:05.300", "Score": "1", "CreationDate": "2017-05-24T20:00:14.450", "ParentId": "44161611", "CommentCount": "0", "OwnerUserId": "5386374", "LastEditDate": "2017-05-25T15:30:05.300"}});