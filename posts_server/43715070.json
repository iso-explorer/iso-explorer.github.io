post_cb({"bq_ids": {"n4140": {"so_43715070_43715191_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7213}}, "n3337": {"so_43715070_43715191_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6957}}, "n4659": {"so_43715070_43715191_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8722}}}, "43715070": {"ViewCount": "23", "Body": "<pre><code>unsigned int BKDRHash(const std::string&amp; str){\nunsigned int seed = 131; // 31 131 1313 13131 131313 etc..\nunsigned int hash = 0;\n\nfor(std::size_t i = 0; i &lt; str.length(); i++)\n{\n    hash = (hash * seed) + str[i];\n}\n\nreturn hash;}\n</code></pre>\n<p>Why we don't need to care about if hash goes out of the range of <code>unsigned int</code> in the above code? I've seen several example code that did nothing about the overflow problem. Why it still works? What will happen when the value <code>hash</code> go out of the range of <code>unsigned int</code>?</p>\n", "AcceptedAnswerId": "43715191", "Title": "Why BKDFHash doesn't care about out of range issue?", "CreationDate": "2017-05-01T06:13:53.913", "Id": "43715070", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-05-01T06:26:48.217", "Score": "1", "OwnerUserId": "6246322", "Tags": "<c++><hash><hashcode>", "AnswerCount": "1"}, "43715191": {"Id": "43715191", "PostTypeId": "2", "Body": "<p>It works because overflow doesn't actually happen for <code>unsigned</code> integer types per the standard:</p>\n<blockquote>\n<p id=\"so_43715070_43715191_0\"><strong>3.9.1 Fundamental types [basic.fundamental]</strong></p>\n<p id=\"so_43715070_43715191_1\">Unsigned integers shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the\n  number of bits in the value representation of that particular size of\n  integer.<sup>48</sup></p>\n<ol start=\"48\">\n<li>This implies that unsigned arithmetic <strong>does not overflow</strong> because a result that cannot be represented by the resulting\n  unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</li>\n</ol>\n</blockquote>\n<p>Ex: if an <code>unsigned int</code> arithmetic result <code>x</code> would otherwise exceed <code>UINT_MAX</code>, the result is exactly:</p>\n<pre><code>x % (UINT_MAX+1)\n</code></pre>\n<p>thereby leaving you a result within <code>0...UINT_MAX</code></p>\n", "LastActivityDate": "2017-05-01T06:26:48.217", "Score": "1", "CreationDate": "2017-05-01T06:26:48.217", "ParentId": "43715070", "CommentCount": "0", "OwnerUserId": "1322972"}});