post_cb({"30492927": {"CommentCount": "4", "AcceptedAnswerId": "30493617", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2015-05-27T20:53:45.623", "LastActivityDate": "2015-05-29T12:28:04.660", "LastEditDate": "2015-05-27T21:31:33.530", "ViewCount": "993", "FavoriteCount": "2", "Title": "Constructor and copy-constructor for class containing union with non-trivial members", "Id": "30492927", "Score": "6", "Body": "<p>I am trying to implement a custom variant type which uses a union to store data of various different types. In the field <code>type_id</code> I plan to store which type the data stored in the union is of. The union contains non-trivial members. Here is my current implementation:</p>\n<pre><code>struct MyVariant {\n  enum { t_invalid, t_string, t_int, t_double, t_ptr, t_dictionary } type_id;\n  union {\n    int                             as_int;\n    double                          as_double;\n    std::string                     as_string;\n    std::unique_ptr&lt;int&gt;            as_ptr;\n    std::map&lt;int, double&gt;           as_dictionary;\n  };\n};\n</code></pre>\n<p>I try to create an instance of <code>MyVariant</code> like follows:</p>\n<pre><code>MyVariant v;\n</code></pre>\n<p>I get the error message: <em>Call to implicitly-deleted default constructor of MyVariant</em>. So, I tried to implement the constructor manually like follows:</p>\n<pre><code>MyVariant() : type_id{t_int}, as_int{0} {}\n</code></pre>\n<p>That gives me a similar error message: <em>Attempt to use a deleted function</em>.\nNext, I tried to implement the following constructor:</p>\n<pre><code>MyVariant(int value) : type_id{t_int}, as_int{value} {}\n</code></pre>\n<p>and construct my instance like follows: </p>\n<pre><code>MyVariant v{123};\n</code></pre>\n<p>=&gt; same error message: <em>Attempt to use a deleted function</em>.</p>\n<p>I've also started to implement a copy constructor, it looks like follows. However, of course this doesn't help with the compiler errors.</p>\n<pre><code>MyVariant::MyVariant(const MyVariant&amp; other)\n{\n    type_id = other.type_id;\n    switch (type_id) {\n        case t_invalid:\n            break;\n        case t_string:\n            new (&amp;as_string) std::string();\n            as_string = other.as_string;\n            break;\n        case t_int:\n            as_int = other.as_int;\n            break;\n        case t_double:\n            as_double = other.as_double;\n            break;\n        case t_ptr:\n            new (&amp;as_ptr) std::unique_ptr&lt;int&gt;(nullptr);\n            as_ptr = std::make_unique&lt;int&gt;(*other.as_ptr);\n            break;\n        case t_dictionary:\n            new (&amp;as_dictionary) std::map&lt;int, double&gt;();\n            // TODO: copy values from other\n            break;\n    }\n}\n</code></pre>\n<p>I am using Xcode and Apple LLVM 6.1 as compiler.</p>\n<p>The main question is: Why do I get the compiler errors which I'm getting and how do I have to modify my code to make it compile?</p>\n<p>The additional question is: Am I on the right way with my implementations for the constructor and copy constructor?</p>\n", "Tags": "<c++><c++11><constructor><c++14><unions>", "OwnerUserId": "387023", "AnswerCount": "1"}, "30493617": {"ParentId": "30492927", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Your union has data members of type <code>string</code>, <code>unique_ptr</code> and <code>map</code>, all of which have non-trivial default/copy/move constructors, copy/move assignment operators and destructors. Hence all of these are implicitly deleted for your union.</p>\n<p><em>\u00a79.5/2 [class.union]</em></p>\n<blockquote>\n<p id=\"so_30492927_30493617_0\">... [ <em>Note</em>: If any non-static data member\n  of a union has a non-trivial default constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4), the corresponding\n  member function of the union must be user-provided or it will be implicitly deleted (8.4.3) for the union. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So you must manually implement these for your union. At a minimum, for you to be able to create an instance of <code>MyVariant</code>, the class needs to be constructible and destructible. So you need</p>\n<pre><code>MyVariant() : type_id{t_int}, as_int{0} {}\n~MyVariant()\n{\n  switch(type_id)\n  {\n      case t_int:\n      case t_double:\n        // trivially destructible, no need to do anything\n        break;\n      case t_string:\n        as_string.~basic_string();\n        break;\n      case t_ptr:\n        as_ptr.~unique_ptr();\n        break;\n      case t_dictionary:\n        as_dictionary.~map();\n        break;\n      case t_invalid:\n        // do nothing\n        break;\n      default:\n        throw std::runtime_error(\"unknown type\");\n  }\n}\n</code></pre>\n<p>Your copy constructor implementation looks valid, but what I'd do differently is instead of first default constructing the member, and then copying from the source object, just copy construct in the placement new call itself.</p>\n<pre><code>MyVariant(const MyVariant&amp; other)\n{\n  type_id = other.type_id;\n  switch (type_id) {\n      case t_invalid:\n          break;\n      case t_string:\n          new (&amp;as_string) auto(other.as_string);\n          break;\n      case t_int:\n          as_int = other.as_int;\n          break;\n      case t_double:\n          as_double = other.as_double;\n          break;\n      case t_ptr:\n          new (&amp;as_ptr) auto(std::make_unique&lt;int&gt;(*other.as_ptr));\n          break;\n      case t_dictionary:\n          new (&amp;as_dictionary) auto(other.as_dictionary);\n          break;\n  }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0f37480f56036e6e\" rel=\"nofollow\">Live demo</a></p>\n<p>Note that if the <code>unique_ptr</code> member is active, and is storing a pointer to some derived class instance via a base class pointer, then your copy constructor implementation will only copy the base class part.</p>\n<p>Finally, unless you're doing this as a learning exercise, I'd strongly urge you to use <a href=\"http://www.boost.org/doc/libs/release/doc/html/boost/variant.html\" rel=\"nofollow\">Boost.Variant</a> instead of rolling your own.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2015-05-29T12:28:04.660", "Id": "30493617", "Score": "6", "CreationDate": "2015-05-27T21:38:59.663", "LastActivityDate": "2015-05-29T12:28:04.660"}, "bq_ids": {"n4140": {"so_30492927_30493617_0": {"section_id": 5914, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_30492927_30493617_0": {"section_id": 5686, "quality": 0.7368421052631579, "length": 28}}, "n4659": {"so_30492927_30493617_0": {"section_id": 7406, "quality": 0.7368421052631579, "length": 28}}}});