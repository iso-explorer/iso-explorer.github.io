post_cb({"26951989": {"ParentId": "26951007", "CommentCount": "0", "Body": "<p><strong>What does the stanard say and suggest ?</strong> </p>\n<p>Let's first look at the <code>exit()</code> definition </p>\n<blockquote>\n<p id=\"so_26951007_26951989_0\"><strong>18.5/8:</strong> First, objects with thread storage duration and associated with the current thread are destroyed. Next, objects with static\n  storage duration are destroyed and functions registered by calling\n  atexit [footnote 221: A function is called for every time it is registered.]  </p>\n</blockquote>\n<p>Then a little bit above we remind that:   </p>\n<blockquote>\n<p id=\"so_26951007_26951989_1\"><strong>18.5/5</strong>: The atexit() functions register the function pointed to by f to be called without arguments at normal program termination.</p>\n</blockquote>\n<p>Looking then at the order of operation in termination in <strong>3.6.3/3</strong>, we discover that at termination, the functions registered with <code>atexit()</code> are called in the inverse order of their registration.  Doesn't this sound familiar ? And there's more ! The standard gives a guarantee that the the sequencing of calls to destructor and calls to functions registered with <code>atexit</code> also in the reverse order.  </p>\n<p>So strictly speaking, the standard doesn't say that static destructors are managed with atexit funtions, but it suggests that there is a very strong link.  This is certainly why <strong><em>many C++ implementations use the atexit mechanim for destroying statics</em></strong>.      </p>\n<p><strong>How to demonstrate this for a perticular implementation ?</strong></p>\n<p>It's difficult to separate in your example the code generated by the compiler specifically for the static destruction from other typical code generated in the termination sequence. I propose you the following experience:  </p>\n<p>Change your code to define your structure in a distinct header, and put the implementation of the member functions in a diferent file.  Then add to your project a simple cpp file containing only the definition of a global (i.e. static storage) variable:</p>\n<pre><code>#include \"Header.h\"  // our declaration for A without implementation \nA a(3); \n</code></pre>\n<p>Compile all your code with assembler output.  As in this compilation unit there is only code related to the construction, initialisation and destruction of one instance of A, it will be pretty easy to understand.  </p>\n<p>With MSVC 2013, there is initialisation code (comments added by me):  </p>\n<pre><code>??__Ea@@YAXXZ PROC                  ; `dynamic initializer for 'a'', COMDAT\n; 3    :  A a(3);\n...\n    push    3                           ; parameter for the intialisation \n    mov ecx, OFFSET ?a@@3UA@@A          ; adress of a\n    call    ??0A@@QAE@H@Z               ; call to constructor A::A\n</code></pre>\n<p>The code generated for this initalisation is immediately followed by the following ( comment is from MSVC):   </p>\n<pre><code>     push   OFFSET ??__Fa@@YAXXZ            ; `dynamic atexit destructor for 'a''\n     call   _atexit\n</code></pre>\n<p>So here it is clearly written !  The compiler generates a call to <code>atexit()</code> that registers a generated function, the \"dynamic atexit destructor\" for this specific variable.  This function is defined elsewhere in the assembler code:  </p>\n<pre><code>??__Fa@@YAXXZ PROC                  ; `dynamic atexit destructor for 'a'', COMDAT\n...\n    mov ecx, OFFSET ?a@@3UA@@A          ; a        ===&gt; tell which object \n    call    ??1A@@QAE@XZ                ; A::~A    ===&gt; and tell to call destructor\n...\n</code></pre>\n<p>And there is almost no other code in this basic compilation unit.  </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "26951989", "Score": "0", "CreationDate": "2014-11-15T23:29:01.623", "LastActivityDate": "2014-11-15T23:29:01.623"}, "26951008": {"ParentId": "26951007", "CommentCount": "0", "Body": "<p>GCC 4.8.1 with <code>-std=c++11</code> produces the following <code>f1</code>:</p>\n<pre><code>push   %rbp\nmov    %rsp,%rbp\nmov    $0x6021c0,%eax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x400a1d &lt;f1()+80&gt;\nmov    $0x6021c0,%edi\ncallq  0x400830 &lt;__cxa_guard_acquire@plt&gt;\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0x400a1d &lt;f1()+80&gt;\nmov    $0x1,%esi\nmov    $0x6021d0,%edi\ncallq  0x400b3a &lt;A::A(int)&gt;\nmov    $0x6021c0,%edi\ncallq  0x4008a0 &lt;__cxa_guard_release@plt&gt;\nmov    $0x602080,%edx\nmov    $0x6021d0,%esi\nmov    $0x400b50,%edi\ncallq  0x400870 &lt;__cxa_atexit@plt&gt;\nmov    0x2017ad(%rip),%eax        # 0x6021d0 &lt;_ZZ2f1vE1a&gt;\npop    %rbp\nretq   \n</code></pre>\n<p>After the thread-safe construction of <code>a</code>, <code>__cxa_atexit</code> is called;\n<code>%edi</code> points to the desctructor of <code>A</code>, <code>%esi</code> holds the address of <code>a</code>.\nUpon exit, the implementation calls the given functions with the given argument,\n(in this case, it acts as <code>this</code> in the destructor) in reverse order.</p>\n", "OwnerUserId": "116273", "PostTypeId": "2", "Id": "26951008", "Score": "0", "CreationDate": "2014-11-15T21:37:40.360", "LastActivityDate": "2014-11-15T21:37:40.360"}, "bq_ids": {"n4140": {"so_26951007_26951007_0": {"section_id": 7156, "quality": 0.95, "length": 19}, "so_26951007_26951989_1": {"section_id": 6802, "quality": 0.8181818181818182, "length": 9}, "so_26951007_26951989_0": {"section_id": 6805, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_26951007_26951007_0": {"section_id": 6900, "quality": 0.95, "length": 19}, "so_26951007_26951989_1": {"section_id": 6557, "quality": 0.8181818181818182, "length": 9}, "so_26951007_26951989_0": {"section_id": 6560, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_26951007_26951007_0": {"section_id": 8663, "quality": 0.95, "length": 19}, "so_26951007_26951989_1": {"section_id": 8293, "quality": 0.8181818181818182, "length": 9}, "so_26951007_26951989_0": {"section_id": 8296, "quality": 0.8888888888888888, "length": 24}}}, "26951007": {"CommentCount": "1", "ViewCount": "97", "PostTypeId": "1", "LastEditorUserId": "207421", "CreationDate": "2014-11-15T21:37:40.360", "LastActivityDate": "2014-11-15T23:45:05.610", "Title": "How static object destruction order is calculated?", "LastEditDate": "2014-11-15T23:45:05.610", "Id": "26951007", "Score": "0", "Body": "<p>The standard requires the implementation do the following:</p>\n<blockquote>\n<p id=\"so_26951007_26951007_0\"><strong>3.6.3.1</strong> If the completion of the constructor or dynamic initialization of an\n  object with static storage duration is sequenced before that of\n  another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>The following demo demonstrates this:</p>\n<pre><code>struct A\n{\n  A(int i) :i(i) {}\n  ~A() { std::cout &lt;&lt; \"destruct A(\" &lt;&lt; i &lt;&lt; \")\\n\"; }\n\n  int i;\n};\n\nvoid f1() { static A a(1); } \nvoid f2() { static A a(2); } \n\nint main(int argc, char* argv[]) {\n  if (argc &lt;= 1) {\n    std::cout &lt;&lt; \"f1/f2\\n\";\n    f1();\n    f2();\n  } else {\n    std::cout &lt;&lt; \"f2/f1\\n\";\n    f2();\n    f1();\n  }\n\n  return 0;\n}\n</code></pre>\n<p>The <strong>question</strong> is: How the implementation is able to comply? How each construction is tracked?</p>\n", "Tags": "<c++><static>", "OwnerUserId": "116273", "AnswerCount": "2"}});