post_cb({"bq_ids": {"n4140": {"so_14820835_14820933_0": {"length": 10, "quality": 1.0, "section_id": 986}}, "n3337": {"so_14820835_14820933_0": {"length": 10, "quality": 1.0, "section_id": 971}}, "n4659": {"so_14820835_14820933_0": {"length": 10, "quality": 1.0, "section_id": 1049}}}, "14820835": {"ViewCount": "2024", "Body": "<p>Answering <a href=\"https://stackoverflow.com/questions/14781264/how-to-self-copy-a-vector/\">How to self-copy a vector?</a> has got me a bit confused about iterator invalidation. Some literature says \"if you use insert, push_back, etc. consider all iterators invalid\". Thats clear, it might cause the vector to grow which invalidates iterators. What about the special case where I know there is going to be enough room?</p>\n<p>first try:</p>\n<pre><code>myvec.reserve(myvec.size()*3);  //does this protect me from iterator invalidation?\nvector&lt;string&gt;::iterator it = myvec.end();    \nmyvec.insert(myvec.end(), myvec.begin(), it);\nmyvec.insert(myvec.end(), myvec.begin(), it);\n</code></pre>\n<p>After some excellent answers second try:</p>\n<pre><code>auto size = myvec.size();\nmyvec.reserve(size*3);  //does this protect me from iterator invalidation?  \nmyvec.insert(myvec.end(), myvec.begin(), myvec.begin()+size);\nmyvec.insert(myvec.end(), myvec.begin(), myvec.begin()+size);\n</code></pre>\n<p>After more excellent answers third try:</p>\n<pre><code>auto size = myvec.size();\nmyvec.reserve(size*3);  //does this protect me from iterator invalidation?  \nback_insert_iterator&lt; vector&lt;string&gt; &gt; back_it (myvec);\ncopy (myvec.begin(),myvec.begin()+size,back_it);\ncopy (myvec.begin(),myvec.begin()+size,back_it);\n</code></pre>\n<p>This quote from Josuttis' \"C++ Standard Library Reference\":</p>\n<blockquote>\n<p id=\"so_14820835_14820835_0\">Inserting or removing elements\n  invalidates references, pointers, and\n  iterators that refer to the following\n  element.  If an insertion causes\n  reallocation, it invalidates all\n  references, iterators, and pointers.</p>\n</blockquote>\n<p>suggests that my code is safe and defined behavior. Is there a passage in the standard which guaranties this?</p>\n", "AcceptedAnswerId": "14820933", "Title": "Does std::vector::insert() invalidate iterators if the vector has enough room (created through reserve)?", "CreationDate": "2013-02-11T21:05:23.973", "Id": "14820835", "CommentCount": "2", "LastEditDate": "2017-05-23T12:08:42.383", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-05T22:57:12.457", "Score": "1", "OwnerUserId": "893819", "Tags": "<c++><vector><stl><iterator><c++-standard-library>", "AnswerCount": "3"}, "14820967": {"Id": "14820967", "PostTypeId": "2", "Body": "<p>Although it is true that insertions into a vector won't cause reallocation as long as the capacity is not exceeded, and won't invalidate iterators to elements <em>before</em> the insertion point (which is arguably the case of <code>end()</code>, as @KerrekSB pointed out), Table 100 of the C++11 Standard (Paragraph 23.2.3) specifies the following <strong>precondition</strong> for the <code>a.insert(p,i,j)</code> function for sequence containers:</p>\n<blockquote>\n<p id=\"so_14820835_14820967_0\">[...] pre: i and j are not iterators into a. [...]</p>\n</blockquote>\n<p>In your case, they clearly are, which makes me think that program has Undefined Behavior.</p>\n", "LastActivityDate": "2013-02-11T21:14:34.093", "CommentCount": "2", "CreationDate": "2013-02-11T21:14:34.093", "ParentId": "14820835", "Score": "2", "OwnerUserId": "1932150"}, "23452783": {"Id": "23452783", "PostTypeId": "2", "Body": "<p>Iterators should not be invalidated mid function. The idea that memory may be <em>relocated</em> doesn't hold up, because you cannot use <code>realloc</code> on objects with non-trivial constructors. Even if construction was a not an issue, it would still have to copy the initial sequence twice in the worst case, negating any benefits in the average case.\n<p>Point being, it doesn't make sense to implement it that way; an <code>alloc</code>, <code>copy</code>, <code>free</code> is almost certainly done, regardless of what the standard says.</p>\n<p>This is safe because <code>v.begin()</code> and <code>v.end()</code> are always current.</p>\n<pre><code>v.insert(v.end(), v.begin(), v.end());\nv.insert(v.end(), v.begin(), v.end());\n</code></pre>\n<p>This is not.</p>\n<pre><code>vector&lt;foo&gt;::iterator i = v.begin();\nvector&lt;foo&gt;::iterator j = v.end();\nv.insert(v.end(), i, j);\nv.insert(v.end(), i, j);\n</code></pre>\n<p>However, self insertion can be wonky. Try the following under GCC. The self insertion gives an incorrect result <em>only</em> if enough memory is available (not sure if this is a bug).</p>\n<pre><code>int main()\n{\n    int position = 1, first = 2, last = 3;\n    // enforce error condition.\n    assert(position &lt; first);\n    int size = 8;\n    // sanity check.\n    assert(first &lt; last &amp;&amp; last &lt;= size);\n\n    std::vector&lt;int&gt; right, wrong;\n    // force resize during insertion.\n    right.reserve(size);\n    // avoid resize during insertion.\n    wrong.reserve(size + (last - first));\n\n    for ( int i = 0; i &lt; size; i++ )\n     {\n       right.push_back(i);\n       wrong.push_back(i);\n     }\n\n    std::vector&lt;int&gt;::iterator i;\n    i = right.begin();\n    right.insert(i + position, i + first, i + last);\n    i = wrong.begin();\n    wrong.insert(i + position, i + first, i + last);\n\n    assert(right == wrong);\n    return 0;\n}\n</code></pre>\n<p><b>Note:</b> The above opinion applies to <code>vector</code> specifically, not containers in general. Also, the suggestion that the above behavior may be a bug has nothing to do with the standard, rather the ease of implementing a robust self insertion for <code>vector</code>.</p>\n</p>", "LastEditorUserId": "2574586", "LastActivityDate": "2014-05-05T22:57:12.457", "Score": "0", "CreationDate": "2014-05-04T04:55:35.207", "ParentId": "14820835", "CommentCount": "0", "OwnerUserId": "2574586", "LastEditDate": "2014-05-05T22:57:12.457"}, "14820933": {"Id": "14820933", "PostTypeId": "2", "Body": "<p>The past-the-end iterator is always a bit special. I'd be careful. The standard says this (23.3.6.5):</p>\n<blockquote>\n<p id=\"so_14820835_14820933_0\">If no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>The key here is \"before the insertion point\". Since your original <code>it</code> is not before the insertion point (since it <em>is</em> the insertion point), I wouldn't bank on it remaining valid.</p>\n", "LastActivityDate": "2013-02-11T21:11:50.310", "CommentCount": "4", "CreationDate": "2013-02-11T21:11:50.310", "ParentId": "14820835", "Score": "6", "OwnerUserId": "596781"}});