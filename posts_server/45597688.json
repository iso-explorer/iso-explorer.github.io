post_cb({"45597738": {"ParentId": "45597688", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, this would work in the sense that you will not be subjecting yourself to race conditions - assuming you do not modify the same element from more than one thread.</p>\n<p><code>find</code> is a rare example of the container member function which is not marked <code>const</code> (because it returns modifiable iterator) but still is safe to be called from multiple threads simultaneously. </p>\n<p>To get more information on container thread-safety, I strongly recommend memorizing this page: <a href=\"http://en.cppreference.com/w/cpp/container\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/container</a></p>\n", "OwnerUserId": "5245033", "LastEditorUserId": "5245033", "LastEditDate": "2017-08-09T18:48:23.043", "Id": "45597738", "Score": "1", "CreationDate": "2017-08-09T18:04:30.637", "LastActivityDate": "2017-08-09T18:48:23.043"}, "45597688": {"CommentCount": "9", "ViewCount": "53", "CreationDate": "2017-08-09T18:01:17.127", "LastActivityDate": "2017-08-13T20:09:01.163", "Title": "Update values corresponding to different existing keys in unordred_map from multiple threads", "AcceptedAnswerId": "45597738", "PostTypeId": "1", "Id": "45597688", "Score": "1", "Body": "<p>I have an unordered map looks like this:</p>\n<pre><code>unordered_map&lt;string, MyClass*&gt; idToMyClassMap;\n</code></pre>\n<p>Now I understand that I cannot do insert/delete and etc to this map from multiple threads without synchronization. But can I pre-populate this map with the largest possible entries that I will use with an list of pre-known string key and all nullptr for MyClass. When I actually want to \"insert\" to this map, I will just iterate through the map, find which key is nullptr and use that. When I am deleting, I will set the value to nullptr again.</p>\n<p>Would this work?</p>\n", "Tags": "<c++><multithreading>", "OwnerUserId": "6182843", "AnswerCount": "2"}, "45603488": {"ParentId": "45597688", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your approach triggers undefined behavior since you have a potential situation where multiple threads access the <code>MyClass</code> pointer in an existing map element while at least one of them is modifying it.</p>\n<p>Reading and writing to a single memory location is forbidden by the standard in the section about data races (1.10.1-2):</p>\n<blockquote>\n<p id=\"so_45597688_45603488_0\">Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the same memory location.</p>\n</blockquote>\n<p>This problem has many aspects and one of them is that a thread may access a partially constructed <code>MyClass</code> object since object creation is not synchronized between threads.  </p>\n<p>Consider using a <code>std::shared_mutex</code> (C++17) for read/write access on the map; pre-allocating elements will not be necessary then</p>\n", "OwnerUserId": "6651824", "LastEditorUserId": "6651824", "LastEditDate": "2017-08-13T20:09:01.163", "Id": "45603488", "Score": "0", "CreationDate": "2017-08-10T02:28:57.580", "LastActivityDate": "2017-08-13T20:09:01.163"}, "bq_ids": {"n4140": {"so_45597688_45603488_0": {"section_id": 5817, "quality": 0.875, "length": 14}}, "n3337": {"so_45597688_45603488_0": {"section_id": 5588, "quality": 0.875, "length": 14}}, "n4659": {"so_45597688_45603488_0": {"section_id": 7278, "quality": 0.9375, "length": 15}}}});