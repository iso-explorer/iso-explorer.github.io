post_cb({"40371119": {"Id": "40371119", "PostTypeId": "2", "Body": "<p>The dereference operator works exactly the same way as an overloaded operator as it does as an ordinary operator.</p>\n<pre><code>int foo(int *p)\n{\n     return *p;\n}\n</code></pre>\n<p>In the statement <code>return *p;</code>, the dereference operator applies to the pointer <code>p</code>. It is passed to it on the right side:</p>\n<p>As an overloaded operator, it works the same way.</p>\n<pre><code>class bar {\n\n     int *some_internal_ptr;\n\npublic:\n     int operator*() const {\n          return *some_internal_ptr;\n     }\n\n     // Other class members and methods...\n};\n\nint foo(bar p)\n{\n     return *p;\n}\n</code></pre>\n<p>When the right-hand side of the <code>*</code> operator is class with an operator*` member, it gets invoked as an overloaded method of the class, no different than any other member, in order to resolve the dereference.</p>\n<p>It is because the usage is identical is why many C++ library algorithms work equally well with either pointers or C++ library operators. For example, <code>std::copy()</code> <strong><em>could</em></strong> be implemented as follows (I am trimming away some irrelevant complexity that's not germane here):</p>\n<pre><code>template&lt;typename iter_type&gt;\niter_type copy(iter_type b, iter_type e, iter_type t)\n{\n    while (b != e)\n    {\n       *t=*b;\n       ++t;\n       ++b;\n    }\n    return t;\n}\n</code></pre>\n<p>You can pass native pointers to <code>std::copy</code>, or pass classes like iterators, with overloaded <code>*</code> operators, and because an overloaded <code>*</code> operator is used with the same syntax as an ordinary <code>*</code> operator, the same algorithm works with the overloaded operator as well.</p>\n", "LastActivityDate": "2016-11-02T01:25:46.007", "Score": "0", "CreationDate": "2016-11-02T01:25:46.007", "ParentId": "40371000", "CommentCount": "0", "OwnerUserId": "3943312"}, "40371068": {"Id": "40371068", "PostTypeId": "2", "Body": "<p>Prefix <code>*</code> operates on the operand that follows it.</p>\n<p>For a user defined <code>operator*</code> expressed as a member function, that's the object that's referred to by a <code>this</code>-expression.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct S\n{\n    auto operator*() const -&gt; char const* { return \"Hi there!\"; }\n};\n\nauto main()\n    -&gt; int\n{ cout &lt;&lt; *S() &lt;&lt; endl; }\n</code></pre>\n<p>Result:</p>\n<pre>\nHi there!\n</pre>\n", "LastActivityDate": "2016-11-02T01:18:57.673", "Score": "0", "CreationDate": "2016-11-02T01:18:57.673", "ParentId": "40371000", "CommentCount": "2", "OwnerUserId": "464581"}, "40371000": {"ViewCount": "148", "Body": "<p>When I looked up books and stack overflow article on <a href=\"https://stackoverflow.com/questions/23881126/\">operator overloading</a>, I found the following:</p>\n<blockquote>\n<p id=\"so_40371000_40371000_0\">When an overloaded operator is a member function, this is bound to the\n  left-hand operand. Member operator functions have one less (explicit)\n  parameter than the number of operands.</p>\n</blockquote>\n<p>(Addison Wesley, C++ Primer)</p>\n<p>So my question is, since the <code>*</code> (dereference) operator does not have any left operand, how does it get its parameter (which is the object itself or <code>this</code>)?</p>\n", "AcceptedAnswerId": "40371240", "Title": "How does dereference operator (*) work when overloaded as a member function of a class?", "CreationDate": "2016-11-02T01:09:50.437", "Id": "40371000", "CommentCount": "3", "LastEditDate": "2017-05-23T12:06:47.030", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-03T10:04:40.437", "Score": "2", "OwnerUserId": "4781064", "Tags": "<c++><operator-overloading><smart-pointers><dereference><template-function>", "AnswerCount": "3"}, "40371240": {"Id": "40371240", "PostTypeId": "2", "Body": "<p>For all prefix unary operator, it operates on the operand that follows it.</p>\n<blockquote>\n<p id=\"so_40371000_40371240_0\">As an added question would there be any difference in how the overloaded * operator is used if it is defined as a non-member function vs a member function</p>\n</blockquote>\n<p>For the most part, no, except that non-member function can't access private member of that class and if both the member function and non-member function existed, compiler needs to use <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow noreferrer\">overload resolution</a> to pick the higher rank function, if there're no better function, it's ambigious call, see <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">ADL</a></p>\n<p>For the reliable source, you can take a look at <a href=\"http://en.cppreference.com/w/cpp/language/operators\" rel=\"nofollow noreferrer\">operator overloading</a>, or, better, section 13.5.1 [over.unary] in the standard C++:</p>\n<blockquote>\n<p id=\"so_40371000_40371240_1\">A prefix unary operator shall be implemented by a non-static member function (9.3) with no parameters or\n  a non-member function with one parameter. Thus, for any prefix unary operator @, @x can be interpreted\n  as either x.operator@() or operator@(x). If both forms of the operator function have been declared, the\n  rules in 13.3.1.2 determine which, if any, interpretation is used. See 13.5.7 for an explanation of the postfix\n  unary operators ++ and --.\n  2 The unary and binary forms of the same operator are considered to have the same name. [ Note: Consequently,\n  a unary operator can hide a binary operator from an enclosing scope, and vice versa. \u2014end\n  note ]</p>\n</blockquote>\n<p>For the selection if there are both member and non-member, see 13.3.1.2 [over.match.oper]</p>\n", "LastEditorUserId": "4115625", "LastActivityDate": "2016-11-03T10:04:40.437", "Score": "2", "CreationDate": "2016-11-02T01:42:00.663", "ParentId": "40371000", "CommentCount": "0", "LastEditDate": "2016-11-03T10:04:40.437", "OwnerUserId": "4115625"}, "bq_ids": {"n4140": {"so_40371000_40371240_1": {"length": 35, "quality": 0.5737704918032787, "section_id": 657}}, "n3337": {"so_40371000_40371240_1": {"length": 35, "quality": 0.5737704918032787, "section_id": 647}}, "n4659": {"so_40371000_40371240_1": {"length": 35, "quality": 0.5737704918032787, "section_id": 685}}}});