post_cb({"25559940": {"ParentId": "25559918", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Destroying a <code>std::thread</code> object associated with a <code>joinable()</code> thread causes <code>std::terminate()</code> to be called. \u00a730.3.1.3 [thread.thread.destr]:</p>\n<blockquote>\n<pre><code>~thread();\n</code></pre>\n<p id=\"so_25559918_25559940_0\">If <code>joinable()</code>, calls <code>std::terminate()</code>. Otherwise, has no\n  effects. [ <em>Note</em>: Either implicitly detaching or joining a <code>joinable()</code>\n  thread in its destructor could result in difficult to debug\n  correctness (for detach) or performance (for join) bugs encountered\n  only when an exception is raised. Thus the programmer must ensure that\n  the destructor is never executed while the thread is still joinable.\n  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>There are a multitude of possible fixes:</p>\n<ul>\n<li>Allocate the thread on the heap and having your function return a smart pointer to the thread object</li>\n<li>Or have it return a <code>std::thread</code> (move <code>serverConnect</code> into the return value)</li>\n<li>Move <code>serverConnect</code> into something that won't be destroyed when <code>connectToServer()</code> returns (e.g., a global variable)</li>\n<li><code>join()</code> the thread before you return</li>\n<li><code>detach()</code> the thread before you return</li>\n</ul>\n<p>The correct choice depends on your particular use case.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-29T00:33:52.577", "Id": "25559940", "Score": "4", "CreationDate": "2014-08-29T00:25:22.823", "LastActivityDate": "2014-08-29T00:33:52.577"}, "25559918": {"CommentCount": "1", "ViewCount": "2421", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2014-08-29T00:21:15.033", "LastActivityDate": "2014-08-29T06:28:28.140", "Title": "C++ - std::thread crashes upon execution", "AcceptedAnswerId": "25559940", "LastEditDate": "2014-08-29T06:28:28.140", "Id": "25559918", "Score": "1", "Body": "<p>I am using VS2012 and I can't execute a thread in my program without it crashing. It should be noted that my program contains OpenGL and SOIL.</p>\n<p>I simply call a blank thread, a function with no statements, in one of my functions and it immediately crashes:</p>\n<pre><code>void service(){\n\n}\n\n/* Connect to server */\nvoid connectToServer(){\n\n    cout &lt;&lt; \"~CLIENT~\\n\" &lt;&lt; endl;\n\n    std::thread serverConnect(service);\n}\n</code></pre>\n<p>When the program calls <code>connectToServer()</code> it breaks at the call statement <code>std::thread serverConnect(service);</code> with the following call-stack:</p>\n<pre class=\"lang-none prettyprint-override\"><code>msvcr110.dll!_crt_debugger_hook(int _Reserved) Line 60  C\nmsvcr110.dll!_call_reportfault(int nDbgHookCode, unsigned long dwExceptionCode, unsigned long dwExceptionFlags) Line 152    C++\nmsvcr110.dll!abort() Line 90    C\nmsvcr110.dll!terminate() Line 96    C++\nIRC.exe!connectToServer() Line 449  C++\nIRC.exe!handleKeypress(unsigned char key, int x, int y) Line 936    C++\nglut32.dll!1000e054()   Unknown\n[Frames below may be incorrect and/or missing, no symbols loaded for glut32.dll]    \nglut32.dll!1000d5de()   Unknown\nuser32.dll!753962fa()   Unknown\nuser32.dll!75396d3a()   Unknown\nuser32.dll!75396ce9()   Unknown\nuser32.dll!753a0d27()   Unknown\nuser32.dll!753a0d4d()   Unknown\nopengl32.dll!18f160fb() Unknown\nuser32.dll!753962fa()   Unknown\nuser32.dll!75396d3a()   Unknown\nuser32.dll!75396ce9()   Unknown\nuser32.dll!753977c4()   Unknown\nuser32.dll!753bd62a()   Unknown\nuser32.dll!75397bca()   Unknown\nglut32.dll!10004970()   Unknown\nglut32.dll!10004a7a()   Unknown\nglut32.dll!1000491f()   Unknown\nIRC.exe!main(int argc, char * * argv) Line 1683 C++\nIRC.exe!__tmainCRTStartup() Line 536    C\nkernel32.dll!7551338a() Unknown\nntdll.dll!77049f72()    Unknown\nntdll.dll!77049f45()    Unknown\n</code></pre>\n<p>The program works perfectly without the thread call statement. Also, my VS environment has no problem running simple example thread programs like this one:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing namespace std;\n//This function will be called from a thread\n\nvoid call_from_thread() {\n    std::cout &lt;&lt; \"Hello, World\" &lt;&lt; std::endl;\n}\n\nint main() {\n    //Launch a thread\n    thread t1(call_from_thread);\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>It's only when I use threads in my program that it crashes.</p>\n", "Tags": "<c++><multithreading><opengl>", "OwnerUserId": "1626090", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25559918_25559940_0": {"section_id": 2717, "quality": 0.925, "length": 37}}, "n3337": {"so_25559918_25559940_0": {"section_id": 2678, "quality": 0.925, "length": 37}}, "n4659": {"so_25559918_25559940_0": {"section_id": 3457, "quality": 0.875, "length": 35}}}});