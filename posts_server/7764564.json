post_cb({"7764564": {"CommentCount": "3", "AcceptedAnswerId": "7764680", "CreationDate": "2011-10-14T07:45:33.117", "LastActivityDate": "2011-10-14T07:57:51.303", "PostTypeId": "1", "ViewCount": "8772", "FavoriteCount": "11", "Title": "C++11 lambdas: member variable capture gotcha", "Id": "7764564", "Score": "34", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    A(int data) : data_(data)\n    { std::cout &lt;&lt; \"A(\" &lt;&lt; data_ &lt;&lt; \")\" &lt;&lt; std::endl; }\n    ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n    void a() { std::cout &lt;&lt; data_ &lt;&lt; std::endl; }\nprivate:\n    int data_;\n};\n\nclass B\n{\npublic:\n    B(): a_(new A(13)) { std::cout &lt;&lt; \"B()\" &lt;&lt; std::endl; }\n    ~B() { std::cout &lt;&lt; \"~B()\" &lt;&lt; std::endl; }\n    std::function&lt;void()&gt; getf()\n    {\n        return [=]() { a_-&gt;a(); };\n    }\nprivate:\n    std::shared_ptr&lt;A&gt; a_;\n};\n\nint main()\n{\n    std::function&lt;void()&gt; f;\n    {\n        B b;\n        f = b.getf();\n    }\n    f();\n    return 0;\n}\n</code></pre>\n<p>Here it looks like I'm capturing <code>a_</code> shared pointer by value, but when I run it on Linux (GCC 4.6.1), this is printed:</p>\n<pre><code>A(13)\nB()\n~B()\n~A()\n0\n</code></pre>\n<p>Obviously, 0 is wrong, because A is already destroyed. It looks like <code>this</code> is actually captured and is used to look up <code>this-&gt;a_</code>. My suspicion is confirmed when I change the capture list from <code>[=]</code> to <code>[=,a_]</code>. Then the correct output is printed and the lifetime of the objects is as expected:</p>\n<pre><code>A(13)\nB()\n~B()\n13\n~A()\n</code></pre>\n<p><strong>The question:</strong></p>\n<p>Is this behaviour specified by the standard, implementation-defined, or undefined? Or I'm crazy and it's something entirely different?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "23643", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7764564_7764680_1": {"section_id": 5966, "quality": 0.90625, "length": 29}}, "n3337": {"so_7764564_7764680_1": {"section_id": 5735, "quality": 0.90625, "length": 29}}, "n4659": {"so_7764564_7764680_1": {"section_id": 7460, "quality": 0.90625, "length": 29}}}, "7764680": {"ParentId": "7764564", "CommentCount": "14", "Body": "<blockquote>\n<p id=\"so_7764564_7764680_0\">Is this behaviour specified by the standard</p>\n</blockquote>\n<p>Yes. Capturing member variables is always done via capturing <code>this</code>; it is the only way to access a member variable. In the scope of a member function <code>a_</code> is equivalent to <code>(*this).a_</code>. This is true in Lambdas as well.</p>\n<p>Therefore, if you use <code>this</code> (implicitly or explicitly), then you must ensure that the object remains alive while the lambda instance is around.</p>\n<p>If you want to capture it by value, you must explicitly do so:</p>\n<pre><code>std::function&lt;void()&gt; getf()\n{\n    auto varA = a_;\n    return [=]() { varA-&gt;a(); };\n}\n</code></pre>\n<p>If you need a spec quote:</p>\n<blockquote>\n<p id=\"so_7764564_7764680_1\">The lambda-expression\u2019s compound-statement yields the function-body ( 8.4 ) of the function call operator, but for purposes of name lookup (3.4), determining the type and value of this (9.3.2) and transforming id-expressions referring to non-static class members into class member access expressions using (*this) ( 9.3.1 ),\n  the compound-statement is considered in the context of the lambda-expression.</p>\n</blockquote>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7764680", "Score": "35", "CreationDate": "2011-10-14T07:57:51.303", "LastActivityDate": "2011-10-14T07:57:51.303"}});