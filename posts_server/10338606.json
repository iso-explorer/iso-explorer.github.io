post_cb({"bq_ids": {"n4140": {"so_10338606_32201462_0": {"length": 12, "quality": 0.6, "section_id": 4503}, "so_10338606_10338606_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 4503}}, "n3337": {"so_10338606_32201462_0": {"length": 12, "quality": 0.6, "section_id": 4334}, "so_10338606_10338606_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 4334}}}, "32201462": {"PostTypeId": "2", "Body": "<p>I agree this is a hole in the specification, thus a defect. It's basically the same as <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2179\" rel=\"nofollow\">http://open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2179</a> although that issue comes at it from a slightly different (and IMHO more obviously broken) angle.</p>\n<p>I'm not sure I agree that this is a misuse of <code>shared_ptr</code>, I think it's fine to do that with shared_ptrs, because unlike the code in issue 2179 you use no-op deleters. I think the problem is when you try to combine that kind of use of <code>shared_ptr</code> with <code>enable_shared_from_this</code>.</p>\n<p>So my first thought was to fix it by extending the requirements of <code>shared_from_this</code>:</p>\n<blockquote>\n<p id=\"so_10338606_32201462_0\"><em>Requires:</em> <code>enable_shared_from_this&lt;T&gt;</code> shall be an accessible base class of <code>T</code>. <code>*this</code> shall be a subobject of an object <code>t</code> of type <code>T</code>.  There shall be at least one <code>shared_ptr</code> instance <code>p</code> that <em>owns</em> <code>&amp;t</code> <strong>and any other <code>shared_ptr</code> instances that own <code>&amp;t</code> shall share ownership with <code>p</code></strong>.</p>\n</blockquote>\n<p>This isn't quite sufficient though, because your example meets that requirement: at the second call to <code>shared_from_this()</code> there is only one owner (<code>p1</code>) but you've already \"corrupted\" the state of the <code>enable_shared_from_this</code> base class by calling <code>lock2()</code>.</p>\n<p>A smaller form of the program is:</p>\n<pre><code>#include &lt;memory&gt;\nusing namespace std;\n\nint main()\n{\n  struct X : public enable_shared_from_this&lt;X&gt; { };\n  auto xraw = new X;\n  shared_ptr&lt;X&gt; xp1(xraw);   // #1\n  {\n    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2\n  }\n  xraw-&gt;shared_from_this();  // #3\n}\n</code></pre>\n<p>All three of libstdc++, libc++ and VC++ (Dinkumware) behave the same and throw <code>bad_weak_ptr</code> at #3, because at #2 they update the <code>weak_ptr&lt;X&gt;</code> member of the base class to make it share ownership with <code>xp2</code>, which goes out of scope leaving the <code>weak_ptr&lt;X&gt;</code> in the expired state.</p>\n<p>Interestingly <code>boost::shared_ptr</code> doesn't throw, instead #2 is a no-op and #3 returns a <code>shared_ptr</code> that shares ownership with <code>xp1</code>. This was done in response to a <a href=\"https://svn.boost.org/trac/boost/ticket/2584\" rel=\"nofollow\">bug report</a> with almost exactly the same example as the one above.</p>\n", "LastActivityDate": "2015-08-25T11:34:13.840", "LastEditorUserId": "981959", "Id": "32201462", "CommentCount": "0", "CreationDate": "2015-08-25T10:23:29.590", "ParentId": "10338606", "Score": "4", "OwnerUserId": "981959", "LastEditDate": "2015-08-25T11:34:13.840"}, "10339436": {"PostTypeId": "2", "Body": "<p>Yes, there is a defect here in C++11. In allowing this:</p>\n<blockquote>\n<p id=\"so_10338606_10339436_0\">It's a bit unusual to have two shared_ptr objects store the same pointer &amp;x but not share ownership, and to use \"deleters\" that do not end the lifetime of *get(), but nothing forbids it.</p>\n</blockquote>\n<p>This should be explicitly stated to be undefined behavior, <em>regardless</em> of what the \"deleters\" do. Sure, it may be technically not illegal to do things that way.</p>\n<p>However, you are <em>lying</em> to people who use the code. The expectation of anyone who receives a <code>shared_ptr</code> is that they now have ownership of the object. So long as they keep that <code>shared_ptr</code> (or a copy thereof) around, the object it points to will still exists.</p>\n<p>That is not the case with your code. So I would say that it is syntactically correct but semantically invalid.</p>\n<p>The language for <code>shared_from_this</code> is fine. It's the language for <code>shared_ptr</code> that needs changing. It should state that it is undefined behavior to create two separate unique pointers that \"own\" the same pointer.</p>\n", "LastActivityDate": "2012-04-26T18:48:54.110", "LastEditorUserId": "734069", "Id": "10339436", "CommentCount": "6", "CreationDate": "2012-04-26T18:40:32.587", "ParentId": "10338606", "Score": "3", "OwnerUserId": "734069", "LastEditDate": "2012-04-26T18:48:54.110"}, "10338606": {"ViewCount": "2403", "Body": "<p>Consider this program:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nclass X\n  : public std::enable_shared_from_this&lt;X&gt;\n{\npublic:\n  struct Cleanup1 { void operator()(X*) const; };\n  struct Cleanup2 { void operator()(X*) const; };\n  std::shared_ptr&lt;X&gt; lock1();\n  std::shared_ptr&lt;X&gt; lock2();\n};\n\nstd::shared_ptr&lt;X&gt; X::lock1()\n{\n  std::cout &lt;&lt; \"Resource 1 locked\" &lt;&lt; std::endl;\n  return std::shared_ptr&lt;X&gt;(this, Cleanup1());\n}\n\nstd::shared_ptr&lt;X&gt; X::lock2()\n{\n  std::cout &lt;&lt; \"Resource 2 locked\" &lt;&lt; std::endl;\n  return std::shared_ptr&lt;X&gt;(this, Cleanup2());\n}\n\nvoid X::Cleanup1::operator()(X*) const\n{\n  std::cout &lt;&lt; \"Resource 1 unlocked\" &lt;&lt; std::endl;\n}\n\nvoid X::Cleanup2::operator()(X*) const\n{\n  std::cout &lt;&lt; \"Resource 2 unlocked\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n  std::cout &lt;&lt; std::boolalpha;\n\n  X x;\n  std::shared_ptr&lt;X&gt; p1 = x.lock1();\n  {\n    std::shared_ptr&lt;X&gt; p2 = x.lock2();\n  }\n}\n</code></pre>\n<p>I don't see anything in the C++11 Standard section 20.7.2 suggesting any of this is invalid.  It's a bit unusual to have two <code>shared_ptr</code> objects store the same pointer <code>&amp;x</code> but not share ownership, and to use \"deleters\" that do not end the lifetime of <code>*get()</code>, but nothing forbids it.  (And if either of those are entirely unintended, it would be difficult to explain why some <code>shared_ptr</code> member functions accept a <code>std::nullptr_t</code> value.)  And as expected, the program outputs:</p>\n<pre><code>Resource 1 locked\nResource 2 locked\nResource 2 unlocked\nResource 1 unlocked\n</code></pre>\n<p>But now if I add a bit to <code>main()</code>:</p>\n<pre><code>int main()\n{\n  std::cout &lt;&lt; std::boolalpha;\n\n  X x;\n  std::shared_ptr&lt;X&gt; p1 = x.lock1();\n  bool test1( x.shared_from_this() );\n  std::cout &lt;&lt; \"x.shared_from_this() not empty: \" &lt;&lt; test1 &lt;&lt; std::endl;\n  {\n    std::shared_ptr&lt;X&gt; p2 = x.lock2();\n  }\n  try {\n    bool test2( x.shared_from_this() );\n    std::cout &lt;&lt; \"x.shared_from_this() not empty: \" &lt;&lt; test2 &lt;&lt; std::endl;\n  } catch (std::exception&amp; e) {\n    std::cout &lt;&lt; \"caught: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n  }\n}\n</code></pre>\n<p>then things get trickier.  With g++ 4.6.3, I get the output:</p>\n<pre><code>Resource 1 locked\nx.shared_from_this() not empty: true\nResource 2 locked\nResource 2 unlocked\ncaught: std::bad_weak_ptr\nResource 1 unlocked\n</code></pre>\n<p>Why would the second call to <code>shared_from_this()</code> fail?  All the requirements of 20.7.2.4p7 are met:</p>\n<blockquote>\n<p id=\"so_10338606_10338606_0\"><em>Requires:</em> <code>enable_shared_from_this&lt;T&gt;</code> shall be an accessible base class of <code>T</code>. <code>*this</code> shall be a subobject of an object <code>t</code> of type <code>T</code>.  There shall be at least one <code>shared_ptr</code> instance <code>p</code> that <em>owns</em> <code>&amp;t</code>.</p>\n</blockquote>\n<p>[<code>T</code> is <code>X</code>, <code>t</code> is <code>x</code>, <code>p</code> is <code>p1</code>.]</p>\n<p>But g++'s <code>enable_shared_from_this</code> essentially follows the suggested implementation from the (non-normative) \"Note\" in 20.7.2.4p10, using a private <code>weak_ptr</code> member in class <code>enable_shared_from_this</code>.  And it seems impossible to account for this sort of issue without doing something considerably more complicated in <code>enable_shared_from_this</code>.</p>\n<p>Is this a defect in the Standard?  (If so, no comment is needed here on what the solution \"should\" be: add a requirement so the example program invokes Undefined Behavior, change the Note to not suggest such a simple implementation would be sufficient,....)</p>\n", "AcceptedAnswerId": "32201462", "Title": "Multiple shared_ptr storing same pointer", "CreationDate": "2012-04-26T17:43:35.910", "Id": "10338606", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-04-26T17:52:24.310", "LastEditorUserId": "636019", "LastActivityDate": "2015-08-25T11:34:13.840", "Score": "8", "OwnerUserId": "459640", "Tags": "<c++><c++11><shared-ptr>", "AnswerCount": "2"}});