post_cb({"33999044": {"ParentId": "33993100", "CommentCount": "5", "Body": "<p>It appears to be valid code as explained in a note inside 7.1.5 of the draft Standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf\" rel=\"nofollow\"><strong>N4567</strong></a></p>\n<blockquote>\n<p id=\"so_33993100_33999044_0\"><strong>7.1.5 The constexpr specifier [dcl.constexpr]</strong> </p>\n<p id=\"so_33993100_33999044_1\">1 The constexpr specifier shall be applied only to the definition of a variable or\n  variable template, the declaration of a function or function template,\n  or the declaration of a static data member of a literal type (3.9). If\n  any declaration of a function or function template has a constexpr\n  specifier, then all its declarations shall contain the constexpr\n  specifier. [ Note: <strong>An explicit specialization can differ from the\n  template declaration with respect to the constexpr specifier.</strong> \u2014 end\n  note ] [ Note: Function parameters cannot be declared constexpr. \u2014 end\n  note ]</p>\n</blockquote>\n<p>So gcc appears to be correct. </p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "33999044", "Score": "0", "CreationDate": "2015-11-30T12:47:32.840", "LastActivityDate": "2015-11-30T12:47:32.840"}, "33993100": {"CommentCount": "11", "ViewCount": "521", "PostTypeId": "1", "LastEditorUserId": "1776279", "CreationDate": "2015-11-30T07:04:34.927", "LastActivityDate": "2016-09-01T03:16:08.977", "Title": "Remove constexpr from C++14 template specialization?", "FavoriteCount": "0", "LastEditDate": "2016-09-01T03:16:08.977", "Id": "33993100", "Score": "1", "Body": "<p>The basic question is if it should be possible to add or remove constexpr from specialized template methods or not.</p>\n<p>Let's assume the following code:</p>\n<pre><code>//this is my general vector template with a constexpr default ctor\ntemplate&lt;typename T, typename STORE&gt;\nstruct alignas(16) vec {\n    union {\n        STORE st;\n        struct { T x; T y; T z; T w; };\n    };\n\n    inline explicit constexpr vec() noexcept :\n        x{0}, y{0}, z{0}, w{0} {\n    }\n};\n\n//and this is the SSE enabled version, where we cannot use\n//constexpr because of _mm_setzero_ps, so let's remove it...\ntemplate&lt;&gt;\ninline vec&lt;float, __m128&gt;::vec() noexcept :\n    st(_mm_setzero_ps()) {\n}\n</code></pre>\n<p>GCC has no problem compiling it, however clang complains that a \"non-constexpr declaration of 'vec' follows constexpr declaration\". I wonder which compiler does it right and why..? (I couldn't test MSVC so far)</p>\n<p>EDIT: Because folks are very picky about copy and paste errors, I corrected the code so that it compiles.</p>\n", "Tags": "<c++><gcc><clang><template-specialization><constexpr>", "OwnerUserId": "1776279", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33993100_33999044_1": {"section_id": 5417, "quality": 0.8627450980392157, "length": 44}}, "n3337": {"so_33993100_33999044_1": {"section_id": 5212, "quality": 0.8235294117647058, "length": 42}}, "n4659": {"so_33993100_33999044_1": {"section_id": 6839, "quality": 0.803921568627451, "length": 41}}}});