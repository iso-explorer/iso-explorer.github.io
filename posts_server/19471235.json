post_cb({"19471412": {"Id": "19471412", "PostTypeId": "2", "Body": "<p>Looking at the ANSI C specification, <a href=\"http://eli-project.sourceforge.net/c_html/c.html#s6.3.6\" rel=\"nofollow\">here</a> is how additive expressions are parsed.</p>\n<p>More elaboration on how this is parsed and how operands are read: </p>\n<blockquote>\n<p id=\"so_19471235_19471412_0\">The integral operand of an additive operator involving a pointer and an integer is specified to be a TypeIs_unsigned_long. Any integral type can be converted to TypeIs_unsigned_long by means of implicit conversions, so this specification is equivalent to that of the standard. The main reason for using TypeIs_unsigned_long is that OIL does not permit sets as operand specifications within a class definition, but a secondary reason is that this approach reduces the total number of operators in the compiler's database.</p>\n</blockquote>\n", "LastActivityDate": "2013-10-19T21:33:28.007", "CommentCount": "2", "CreationDate": "2013-10-19T21:33:28.007", "ParentId": "19471235", "Score": "3", "OwnerUserId": "356307"}, "19471633": {"Id": "19471633", "PostTypeId": "2", "Body": "<p>The reason for this promotion is historical: when C was invented, 40+ years ago, processors did math on a single integral type; you could store smaller types, but there was no byte-level arithmetic. So the promotion rule reflects reality at the time: types smaller than the processor's integer type would be promoted by the hardware to that integer type. Sure, you could do the math in software (which is how <code>long</code> was often implemented), but that would have been much slower (as <code>long</code> often was).</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2013-10-19T23:55:37.523", "Score": "-1", "CreationDate": "2013-10-19T21:59:37.400", "ParentId": "19471235", "CommentCount": "2", "OwnerUserId": "1593860", "LastEditDate": "2013-10-19T23:55:37.523"}, "19471235": {"ViewCount": "13055", "Body": "<p>In C/C++ when I want to find sum of two chars - I get result in int.<br>\nFor example:</br></p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(){\n   char a = 'a', b = 'b';\n   printf(\"%d + %d = %d\\n\", sizeof(a), sizeof(b), sizeof(a + b));\n   return 0;\n}\n</code></pre>\n<p>Prints</p>\n<pre><code>1 + 1 = 4\n</code></pre>\n<p>Why?</p>\n", "AcceptedAnswerId": "19471301", "Title": "Sum of two chars in C/C++", "CreationDate": "2013-10-19T21:15:59.923", "Id": "19471235", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-10-19T23:55:37.523", "Score": "8", "OwnerUserId": "2898778", "Tags": "<c++><c>", "AnswerCount": "7"}, "19471288": {"Id": "19471288", "PostTypeId": "2", "Body": "<p>1)  This just prints out the text string \"something + something else\": you're not actually <em>adding</em> anything: <code>printf(\"%d + %d = %d\\n\",..)</code></p>\n<p>2) <code>sizeof(&lt;some char&gt;)</code> will always be \"1\".  That's what \"sizeof()\" means - it can never be anything <em>besides</em> \"1\".</p>\n<p>3) Yes, adding type \"char\" (which is an integer subtype) will give an integral result.</p>\n<p>For further details:</p>\n<blockquote>\n<p id=\"so_19471235_19471288_0\"><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</a></p>\n<p id=\"so_19471235_19471288_1\">The type char, the signed and unsigned integer types, and the\n  enumerated types are collectively called integer types. The integer\n  and real floating types are collectively called real types.</p>\n</blockquote>\n", "LastEditorUserId": "421195", "LastActivityDate": "2013-10-19T21:26:47.333", "Score": "2", "CreationDate": "2013-10-19T21:20:49.803", "ParentId": "19471235", "CommentCount": "0", "OwnerUserId": "421195", "LastEditDate": "2013-10-19T21:26:47.333"}, "bq_ids": {"n4140": {"so_19471235_19471288_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 7212}, "so_19471235_19471347_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_19471235_19471347_1": {"length": 31, "quality": 0.5081967213114754, "section_id": 5943}, "so_19471235_19471347_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5943}}, "n3337": {"so_19471235_19471288_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 6956}, "so_19471235_19471347_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_19471235_19471347_1": {"length": 31, "quality": 0.5081967213114754, "section_id": 5714}, "so_19471235_19471347_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5714}}, "n4659": {"so_19471235_19471288_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 8721}, "so_19471235_19471347_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_19471235_19471347_1": {"length": 31, "quality": 0.5081967213114754, "section_id": 7428}, "so_19471235_19471347_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7428}}}, "19471301": {"Id": "19471301", "PostTypeId": "2", "Body": "<p>Because although <code>a</code> and <code>b</code> are each of type <code>char</code>, the expression <code>a + b</code> is of type <code>int</code>. Anytime you do math with char types, they are converted to int before doing the actual calculations.</p>\n", "LastActivityDate": "2013-10-19T21:21:57.320", "CommentCount": "5", "CreationDate": "2013-10-19T21:21:57.320", "ParentId": "19471235", "Score": "14", "OwnerUserId": "2192494"}, "19471347": {"Id": "19471347", "PostTypeId": "2", "Body": "<p>Section 4.5 Integral promotions</p>\n<blockquote>\n<p id=\"so_19471235_19471347_0\">A prvalue of an integer type other than bool, char16_t, char32_t, or\n  wchar_t whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be\n  converted to a prvalue of type unsigned int.</p>\n</blockquote>\n<p>The conversion is mandated by the standard in what is called \"The usual arithmetic conversions\"  Clause 5 [expr] point 10:</p>\n<blockquote>\n<p id=\"so_19471235_19471347_1\">Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a\n  similarMany binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are defined as follows:  way. The purpose is to yield a common\n  type, which is also the type of the result. This pattern is called the\n  usual arithmetic conversions, which are defined as follows:</p>\n</blockquote>\n<p>Unless for a few select types. <code>long double, double</code> and <code>float</code></p>\n<blockquote>\n<p id=\"so_19471235_19471347_2\">Otherwise, the integral promotions (4.5) shall be performed on both\n  operands.59</p>\n</blockquote>\n<p>The (char)+(char) results in an int. </p>\n<p>Also note that a char+char is tricky. The char can be signed or unsigned depending on implementation; so the result might easily overflow for normal values which is likely why it is not included in the standard as an exception. </p>\n", "LastEditorUserId": "451600", "LastActivityDate": "2013-10-19T21:56:18.910", "Score": "2", "CreationDate": "2013-10-19T21:26:51.963", "ParentId": "19471235", "CommentCount": "2", "OwnerUserId": "451600", "LastEditDate": "2013-10-19T21:56:18.910"}, "19471439": {"Id": "19471439", "PostTypeId": "2", "Body": "<p>This is how C and C++ work: before doing anything on variables of type <code>char</code>, the compiler converts them to <code>int</code> first. This is called integer promotion. Note: <em>anything</em> is defined by the C and C++ Standards; it doesn't include <code>sizeof</code> but includes most of other operations (I cannot remember any exceptions besides the <code>sizeof</code> one).</p>\n<p>As to the reason for this maybe surprising behavior - this is probably a decision taken in ancient times, resulting in modern C and C++ behaving in that way since then, for compatibility.</p>\n<p>People often had large arrays of <code>char</code>s, which were not really characters, but small numbers. When doing arithmetic with these, it was natural to convert each number to <code>int</code> automatically and doing arithmetic on these, because <code>int</code> is the type for which arithmetic works the fastest. There is also the pleasant side-effect that overflow is much less likely to happen when promotion is in effect (consider <code>a*b</code> when <code>a</code> and <code>b</code> are of <code>char</code> type).</p>\n<p>In addition, <code>printf</code> relies on integer promotion to implement printing ASCII values for characters: <code>printf(\"%d\", a)</code> expects the <code>char</code>-typed parameter to be promoted to <code>int</code> when <code>printf</code> is called.</p>\n", "LastActivityDate": "2013-10-19T21:36:17.650", "CommentCount": "2", "CreationDate": "2013-10-19T21:36:17.650", "ParentId": "19471235", "Score": "0", "OwnerUserId": "509868"}, "19471366": {"Id": "19471366", "PostTypeId": "2", "Body": "<p>Because, if not promoted, the result <strong>can overflow</strong>.</p>\n<p>A single byte char cannot hold value greater than <strong>255 (unsigned)</strong> or <strong>+127 (signed)</strong>. When you sum two instances, there is <em>always the possibility</em> of overflow i.e. result exceeding 255. This means it cannot be stored in a <em>single byte</em>. Hence int is used which cannot over flow max sum of two chars or bytes.</p>\n", "LastActivityDate": "2013-10-19T21:28:43.097", "CommentCount": "3", "CreationDate": "2013-10-19T21:28:43.097", "ParentId": "19471235", "Score": "2", "OwnerUserId": "986760"}});