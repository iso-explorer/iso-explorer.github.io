post_cb({"7420351": {"ParentId": "7420314", "PostTypeId": "2", "CommentCount": "4", "Body": "<pre><code>Base &amp;b = *static_cast&lt;Base *&gt;(d); // does this work by standard?\n</code></pre>\n<p>Yes.</p>\n<p>But you can simply do this:</p>\n<pre><code>Base &amp;b = *d;\n\n//use b polymorphically!\nb.do_something(); //calls Derived::do_something()\n</code></pre>\n<p>No need to use <code>static_cast</code>. After all, <code>Derived</code> is derived from <code>Base</code>. </p>\n<hr>\n<p>Reply to your edit:</p>\n<pre><code>foo2(d); // does this work by standard?\n</code></pre>\n<p>Yes. Pointer of type <code>Base*</code> can be initialized with pointer of type <code>Derived*</code>. </p>\n<p>--</p>\n<pre><code>Base &amp;b = *b; // how this work by standard?\n</code></pre>\n<p>No. They're same name. If you mean, <code>Base &amp;b1 = *b</code>, then yes, that works. <code>b1</code> refers to the object pointed to by <code>b</code>. </p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-09-14T17:45:52.023", "Id": "7420351", "Score": "4", "CreationDate": "2011-09-14T17:20:12.240", "LastActivityDate": "2011-09-14T17:45:52.023"}, "7420314": {"CommentCount": "3", "ViewCount": "1229", "PostTypeId": "1", "LastEditorUserId": "527197", "CreationDate": "2011-09-14T17:17:01.827", "LastActivityDate": "2011-09-14T18:12:10.560", "Title": "C++ ISO Standard interpretation of dereferencing pointer to base", "AcceptedAnswerId": "7420351", "LastEditDate": "2011-09-14T18:12:10.560", "Id": "7420314", "Score": "0", "Body": "<p>I would like to know standard's view on dereferencing pointer to base, but I'm not making any progress finding it. Take these two classes for example:</p>\n<pre><code>class Base\n{\n  public:\n    virtual void do_something() = 0;\n};\n\nclass Derived : public Base\n{\n  public:\n    virtual void do_something();\n};\n\nvoid foo2(Base *b)\n{\n     Base &amp;b1 = *b; // how this work by standard?\n}\n\nvoid foo()\n{\n  Derived *d = new Derived();\n  foo2(d); // does this work by standard?\n}\n</code></pre>\n<p>So, basically, if pointer of type B to an object of type D is dereferenced, will slicing happen in place, or temporary will emerge? I'm prone to believe that temporary is not an option, because that would mean that temporary is instance of abstract class.</p>\n<p>Whatever the truth, I would appreciate any pointers to the ISO standard that says one or the other. (Or third, for that matter. :) )</p>\n<p>EDIT:</p>\n<p>I threw the point with temporary not being an option as a possible line of reasoning why it behaves the way it does, which is quite logical, but I can't find confirmation in standard, and I'm not a regular reader.</p>\n<p>EDIT2:</p>\n<p>Through discussion, it became obvious that my question was actually about dereferencing a pointer mechanism, and not about splicing or temporaries. I thank everyone for trying to dumb it down for me, and I finally got answer to the question the puzzled me the most: Why I can't find anything in the standard about this... Obviously it was the wrong question, but I've got the right answer.</p>\n<p>Thnx</p>\n", "Tags": "<c++><pointers><standards><iso><dereference>", "OwnerUserId": "527197", "AnswerCount": "3"}, "7420562": {"ParentId": "7420314", "CommentCount": "2", "Body": "<p>Object slicing only occurs when the copy constructor or the assignment operator of the base class gets involved somehow, like in parameter passing by value. You can easily avoid these errors by inheriting from Boost's <code>noncopyable</code> for example, even if only in DEBUG mode.</p>\n<p>Neither casting pointers or references nor dereferencing involve any copy construction or assignment. Making a Base reference from a Derived reference is perfectly safe, it's even a standard implicit conversion.</p>\n", "OwnerUserId": "801651", "PostTypeId": "2", "Id": "7420562", "Score": "2", "CreationDate": "2011-09-14T17:37:18.673", "LastActivityDate": "2011-09-14T17:37:18.673"}, "7420417": {"ParentId": "7420314", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In my C++11 draft, 10 [class.derived] /1 says </p>\n<blockquote>\n<p id=\"so_7420314_7420417_0\">[ Note: The scope resolution operator :: (5.1) can be used to refer to\n  a direct or indirect base member explicitly. This allows access to a\n  name that has been redeclared in the derived class. A derived class\n  can itself serve as a base class subject to access control; see 11.2.\n  A pointer to a derived class can be implicitly converted to a pointer\n  to an accessible unambiguous base class (4.10). <strong>An lvalue of a\n  derived class type can be bound to a reference to an accessible\n  unambiguous base class</strong> (8.5.3). \u2014end note ]</p>\n</blockquote>\n<p>In most implementations, your foo2 function will store <code>Base&amp; b</code> as a <code>Base*</code>.  It obviously can't be a <code>Base</code> itself, because that would be a copy, not a reference.  Since it acts (at runtime, not syntactically) like a pointer instead of a copy, there's no splicing concerns.</p>\n<p>In your code before your edit, the compiler would know that <code>Base&amp; b</code> was actually <code>d</code>, it would be syntactic sugar, and wouldn't even generate a pointer in the assembly.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2011-09-14T17:52:23.757", "Id": "7420417", "Score": "2", "CreationDate": "2011-09-14T17:26:36.400", "LastActivityDate": "2011-09-14T17:52:23.757"}, "bq_ids": {"n4140": {"so_7420314_7420417_0": {"section_id": 6975, "quality": 0.8620689655172413, "length": 50}}, "n3337": {"so_7420314_7420417_0": {"section_id": 6721, "quality": 0.8620689655172413, "length": 50}}, "n4659": {"so_7420314_7420417_0": {"section_id": 8474, "quality": 0.8620689655172413, "length": 50}}}});