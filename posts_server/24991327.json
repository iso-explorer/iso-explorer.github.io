post_cb({"bq_ids": {"n4140": {"so_24991327_24991657_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 761}}, "n3337": {"so_24991327_24991657_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 748}}, "n4659": {"so_24991327_24991657_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 821}}}, "24991327": {"ViewCount": "209", "Body": "<p>If I insert the same (size and value) elements in two unordered containers, will traversing the containers with two iterators always give the same element in the same position?</p>\n<p>If yes, can a (single!) hash function be made to break this determinism ? </p>\n", "Title": "Determinism with insert in unordered containers", "CreationDate": "2014-07-28T08:38:09.427", "LastActivityDate": "2014-07-28T08:58:03.867", "CommentCount": "1", "PostTypeId": "1", "Id": "24991327", "Score": "6", "OwnerUserId": "2567683", "Tags": "<c++><c++11><unordered-map><unordered-set>", "AnswerCount": "1"}, "24991657": {"Id": "24991657", "PostTypeId": "2", "Body": "<p>It depends: if you insert the same elements in the same order into two different unordered containers, then the order should be the same across both containers, <strong>even though the order itself is unspecified</strong>.</p>\n<p>The reasoning is a little convoluted: all operations like <code>hash(k)</code> and the reallocations are deterministic. There is no actual quote in the Standard though,  but the ability to do a <code>find()</code> in <code>O(1)</code> after an <code>insert()</code> seems to rule out any kind of randomized or otherwise non-deterministic insertion.</p>\n<p>However, if you change the order of insertion, then all bets are off because internal reallocations will change the order of elements:</p>\n<p><strong>23.2.5 Unordered associative containers [unord.req]</strong></p>\n<blockquote>\n<p id=\"so_24991327_24991657_0\">9 The elements of an unordered associative container are organized\n  into buckets. Keys with the same hash code appear in the same bucket.\n  The number of buckets is automatically increased as elements are added\n  to an unordered associative container, so that the average number of\n  elements per bucket is kept below a bound. Rehashing invalidates\n  iterators, <strong>changes ordering between elements</strong>, and changes which\n  buckets elements appear in, but does not invalidate pointers or\n  references to elements. For unordered_multiset and unordered_multimap,\n  rehashing preserves the relative ordering of equivalent elements.</p>\n</blockquote>\n", "LastActivityDate": "2014-07-28T08:58:03.867", "CommentCount": "0", "CreationDate": "2014-07-28T08:58:03.867", "ParentId": "24991327", "Score": "3", "OwnerUserId": "819272"}});