post_cb({"22235528": {"ParentId": "22233769", "CommentCount": "0", "CreationDate": "2014-03-06T20:43:40.267", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "22235528", "Score": "2", "Body": "<p>Since someone asked for a standard citation in a comment...</p>\n<p>This is called an \"expression statement\".  The C++11 standard says this about it:</p>\n<blockquote>\n<p id=\"so_22233769_22235528_0\">6.2 Expression statement [stmt.expr]</p>\n<p id=\"so_22233769_22235528_1\">Expression statements have the form</p>\n<pre><code>expression-statement:\n    expression (opt);\n</code></pre>\n<p id=\"so_22233769_22235528_2\">The expression is a discarded-value expression (Clause 5). All side\n  e\ufb00ects from an expression statement are completed before the next\n  statement is executed. An expression statement with the expression\n  missing is called a null statement. [Note: Most statements are\n  expression statements \u2014 usually assignments or function calls. A null\n  statement is useful to carry a label just before the } of a compound\n  statement and to supply a null body to an iteration statement such as\n  a while statement (6.5.1). \u2014 end note]</p>\n</blockquote>\n<p>Regarding the \"discarded-value expression\", Clause 5 says:</p>\n<blockquote>\n<p id=\"so_22233769_22235528_3\">In some contexts, an expression only appears for its side e\ufb00ects. Such an expression is called a discarded-value expression. The expression is evaluated and its value is discarded. ...</p>\n</blockquote>\n", "LastActivityDate": "2014-03-06T20:43:40.267"}, "bq_ids": {"n4140": {"so_22233769_22235528_2": {"section_id": 3880, "quality": 0.8823529411764706, "length": 45}, "so_22233769_22235528_3": {"section_id": 5944, "quality": 0.8333333333333334, "length": 15}, "so_22233769_22235528_1": {"section_id": 3880, "quality": 1.0, "length": 4}}, "n3337": {"so_22233769_22235528_2": {"section_id": 3740, "quality": 0.8823529411764706, "length": 45}, "so_22233769_22235528_3": {"section_id": 5715, "quality": 0.8333333333333334, "length": 15}, "so_22233769_22235528_1": {"section_id": 3740, "quality": 1.0, "length": 4}}, "n4659": {"so_22233769_22235528_2": {"section_id": 4769, "quality": 0.8627450980392157, "length": 44}, "so_22233769_22235528_3": {"section_id": 7429, "quality": 0.8333333333333334, "length": 15}, "so_22233769_22235528_1": {"section_id": 4769, "quality": 1.0, "length": 4}}}, "22233804": {"ParentId": "22233769", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-03-06T19:13:32.637", "Score": "7", "LastEditorUserId": "437768", "LastEditDate": "2014-03-06T21:00:10.617", "Id": "22233804", "OwnerUserId": "437768", "Body": "<p>This is called a \"fluent syntax\", \"fluent interface\", or \"method chaining\".  You are utterly free to ignore/throw-away/don't bother with a return value if it is provided (but you're not interested in it).  It makes chaining function calls together easier (and which boat you sit in on whether that is good or bad is entirely up to you).</p>\n<p>Therefore, each method is returning <code>*this</code> to allow you to chain these calls together, but the last one is just dumped, ignored, not used.</p>\n<p>This is perfectly fine.</p>\n", "LastActivityDate": "2014-03-06T21:00:10.617"}, "22233846": {"ParentId": "22233769", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-03-06T19:15:44.343", "Score": "10", "LastEditorUserId": "103167", "LastEditDate": "2014-03-07T00:05:56.363", "Id": "22233846", "OwnerUserId": "103167", "Body": "<p>The value of the expression which is used as a statement is discarded.  It's the same thing that happens when you write</p>\n<pre><code>scanf(\"%d\", &amp;i);\n</code></pre>\n<p>You did know that <code>scanf</code> has a return value, right?  And so does <code>++i</code> in </p>\n<pre><code>for( int i = 0; i &lt; 10; ++i )\n</code></pre>\n<p>And even</p>\n<pre><code>x = 5;\n</code></pre>\n<p>is throwing away the result of the expression.</p>\n<p>There are lots of expressions and functions with return values that are only marginally useful.  If you want to write the code in a way that makes it clear the return value is ignored intentionally and not by accident, cast to void:</p>\n<pre><code>(void) scanf(\"%d\", &amp;i);\n</code></pre>\n<p>This should silence compiler warnings about ignored return values.</p>\n<p>These variations are also valid but a bit sillier:</p>\n<pre><code>(void)++i;\n(void)(x = 5);\n</code></pre>\n", "LastActivityDate": "2014-03-07T00:05:56.363"}, "22233769": {"CommentCount": "3", "ViewCount": "219", "CreationDate": "2014-03-06T19:11:09.193", "LastActivityDate": "2014-03-07T00:05:56.363", "Title": "what happens to the last return *this c++?", "AcceptedAnswerId": "22233846", "PostTypeId": "1", "Id": "22233769", "Score": "7", "Body": "<pre><code>  Time &amp;Time::setHour( int h ) \n  {\n     hour = ( h &gt;= 0 &amp;&amp; h &lt; 24 ) ? h : 0; \n     return *this; \n  } \n\n\n  Time &amp;Time::setMinute( int m ) \n  {\n     minute = ( m &gt;= 0 &amp;&amp; m &lt; 60 ) ? m : 0; \n     return *this;  \n  } \n\n\n  Time &amp;Time::setSecond( int s ) \n  {\n     second = ( s &gt;= 0 &amp;&amp; s &lt; 60 ) ? s : 0; \n    return *this; \n   }\n\nint main()\n{\n    Time t;     \n    t.setHour( 18 ).setMinute( 30 ).setSecond( 22 );\n    return 0;\n}\n</code></pre>\n<p>I understand the cascaded member function call, but I don't understand how t.setHour( 18 ).setMinute( 30 ).setSecond( 22 );  is left hanging, doesn't it have to be assigned to something since it still returns *this after it's done cascading? Why is it ok to leave it like that?</p>\n", "Tags": "<c++><pointers><this><cascade>", "OwnerUserId": "3348712", "AnswerCount": "4"}, "22234081": {"ParentId": "22233769", "CommentCount": "0", "CreationDate": "2014-03-06T19:26:44.760", "OwnerUserId": "2579220", "PostTypeId": "2", "Id": "22234081", "Score": "1", "Body": "<p>It is just an expression statement, doing meaningful stuff via the side effects within the function calls. </p>\n<p>You don't have to do anything with the value of an expression. </p>\n<pre><code>int f(int x) { return x * x; } \nint main(int argc, char* argv[]) { f(2); } \n</code></pre>\n<p>is legal C++.</p>\n<p>If you want to verify it, check a C++ grammar, e.g. <a href=\"http://homepages.e3.net.nz/~djm/cppgrammar.html\" rel=\"nofollow\">http://homepages.e3.net.nz/~djm/cppgrammar.html</a></p>\n<pre><code>statement:\n  labeled-statement\n  expression-statement\n  compound-statement\n  selection-statement\n  iteration-statement\n  jump-statement\n  declaration-statement\n  try-block\n// ..\nexpression-statement:\n    expression;  // opt.\n</code></pre>\n", "LastActivityDate": "2014-03-06T19:26:44.760"}});