post_cb({"8849970": {"ParentId": "8849823", "CommentCount": "1", "Body": "<p>Just to answer the 2nd part. The ambiguity is due to the default parameter <code>int i = 0</code>, which allows that constructor to be called with only the first argument <code>const X&amp; x</code>, which allows it to be used as a copy constructor as well because it is compatible with the signature <code>X(const X&amp; x)</code> (\u00a712.8/2 for the exact text). This conflicts with the implicit copy constructor, thus the ambiguity.</p>\n", "OwnerUserId": "224671", "PostTypeId": "2", "Id": "8849970", "Score": "3", "CreationDate": "2012-01-13T11:36:17.117", "LastActivityDate": "2012-01-13T11:36:17.117"}, "8849975": {"ParentId": "8849823", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It seems to be clarifying the role of the move constructor and how it affects the copy constructor. It's saying that if you declare a move constructor or a move assignment operator, then there will be no implicit copy constructor. If you've defined your own copy constructor or copy assignment operator, you can disregard the  bit you've placed in <strong>bold</strong> text.</p>\n<p>I think the point of the example was to show that for the class:</p>\n<pre><code>struct X {\n   X(const X&amp;, int);\n};\n</code></pre>\n<p>A copy constructor is implicitly defined, because there is no user defined copy constructor. However if you provide a default value for the second int argument (as they've done), then a call to:</p>\n<pre><code>X newX(oldX);\n</code></pre>\n<p>Could be a call to the user defined constructor or the copy constructor: This is the ambiguity they speak of.</p>\n", "OwnerUserId": "1021915", "LastEditorUserId": "1021915", "LastEditDate": "2012-01-13T11:42:02.010", "Id": "8849975", "Score": "2", "CreationDate": "2012-01-13T11:36:37.140", "LastActivityDate": "2012-01-13T11:42:02.010"}, "8849823": {"CommentCount": "4", "AcceptedAnswerId": "8850262", "CreationDate": "2012-01-13T11:25:39.283", "LastActivityDate": "2012-01-13T12:01:38.520", "PostTypeId": "1", "ViewCount": "533", "FavoriteCount": "2", "Title": "Does [C++11: 12.8/7] make sense?", "Id": "8849823", "Score": "4", "Body": "<blockquote>\n<p id=\"so_8849823_8849823_0\"><code>[C++11: 12.8/7]:</code> If the class definition does not explicitly declare a copy constructor, one is declared implicitly. <strong>If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; <em>otherwise, it is defined as defaulted (8.4)</em></strong>. The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor. Thus, for the class definition</p>\n<pre><code>struct X {\n   X(const X&amp;, int);\n};\n</code></pre>\n<p id=\"so_8849823_8849823_1\">a copy constructor is implicitly-declared. If the user-declared constructor is later defined as</p>\n<pre><code>X::X(const X&amp; x, int i =0) { /* ... */ }\n</code></pre>\n<p id=\"so_8849823_8849823_2\">then any use of <code>X</code>\u2019s copy constructor is ill-formed because of the <strong>ambiguity</strong>; no diagnostic is required.</p>\n</blockquote>\n<p>This doesn't make a lot of sense to me.</p>\n<p>How does the code sample introduced by \"thus\" have anything to do with the \"latter\" case that I highlighted in italics?</p>\n<p>My understanding so far is that:</p>\n<ul>\n<li>If the class definition does not explicitly declare a copy constructor, and</li>\n<li>the class definition does not declare a move constructor or move assignment operator, and</li>\n<li>the class has a use-declared copy assignment operator or a user-declared destructor, then</li>\n<li><em>the implicitly-defined copy constructor is defined as <code>default</code>ed, and this is deprecated</em>.</li>\n</ul>\n<p>This seems odd in itself, that a standard-mandated behaviour is \u2014 in the same breath \u2014 deprecated. Does this mean that having a class that satisfies those three conditions is deprecated?</p>\n<p>And what does the code sample have to do with it? That constructor is not a copy constructor, move constructor, move assignment operator, copy assignment operator or a user-declared destructor; it's just a user-declared constructor, no? Where's this \"ambiguity\"?</p>\n<p>Could someone decode this passage for me?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "560648", "AnswerCount": "3"}, "8850262": {"ParentId": "8849823", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_8849823_8850262_0\">Does this mean that having a class that satisfies those three conditions is deprecated?</p>\n</blockquote>\n<p>Yes; if you have a use-declared copy-assignment operator or destructor, you should also declare a copy constructor. It's basically just saying that your class should follow the <a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">Rule of Three</a> (or Five, or whatever it's called in C++11).</p>\n<blockquote>\n<p id=\"so_8849823_8850262_1\">This seems odd in itself, that a standard-mandated behaviour is \u2014 in the same breath \u2014 deprecated. </p>\n</blockquote>\n<p>The behaviour is mandated by the standard because that was the behaviour in C++03 - changing it would break legacy code. Just as the standard defines the behaviour of (for example) dynamic exception specifications, and also deprecates them.</p>\n<blockquote>\n<p id=\"so_8849823_8850262_2\">How does the code sample introduced by \"thus\" have anything to do with the \"latter\" case that I highlighted in italics?</p>\n</blockquote>\n<p>It doesn't have anything to do with the \"latter\" case.</p>\n<p>It is an illustration of a potential problem caused by the normal behaviour defined by the clause: there will be a conflict between an implicitly-declared copy constructor, and a user-declared constructor with default arguments such that it can be called like a copy constructor.</p>\n<blockquote>\n<p id=\"so_8849823_8850262_3\">Where's this \"ambiguity\"?</p>\n</blockquote>\n<p>Consider the code:</p>\n<pre><code>X x1;  // assume there's also a default constructor\nX x2(x);\n</code></pre>\n<p>Should <code>x2</code> be initialised with the user-declared constructor (with the second argument taking its default value), or the implicitly-declared copy constructor? Both are an equally good match for the usage. That is the ambiguity.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:03:14.970", "Id": "8850262", "Score": "3", "CreationDate": "2012-01-13T12:01:38.520", "LastActivityDate": "2012-01-13T12:01:38.520"}, "bq_ids": {"n4140": {"so_8849823_8849823_1": {"section_id": 5979, "quality": 0.7142857142857143, "length": 5}, "so_8849823_8849823_0": {"section_id": 456, "quality": 0.8372093023255814, "length": 36}}, "n3337": {"so_8849823_8849823_2": {"section_id": 447, "quality": 1.0, "length": 9}, "so_8849823_8849823_1": {"section_id": 447, "quality": 1.0, "length": 7}, "so_8849823_8849823_0": {"section_id": 447, "quality": 0.9069767441860465, "length": 39}}, "n4659": {"so_8849823_8849823_1": {"section_id": 479, "quality": 0.5714285714285714, "length": 4}, "so_8849823_8849823_0": {"section_id": 479, "quality": 0.8372093023255814, "length": 36}}}});