post_cb({"31036066": {"ViewCount": "399", "Body": "<p>I have a class as:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass Object {\n    std::shared_ptr&lt;void&gt; object_ptr;\npublic:\n    Object() {}\n\n    template&lt;typename T&gt;\n    Object(T&amp;&amp; object) \n        : object_ptr {new T {std::move(object)} } {}\n\n    virtual ~Object() {};\n};\n</code></pre>\n<p>My main cpp file is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"Object.hpp\"\n\nclass Foo {};\n\n\nint main() {\n    Object o {Foo{}};\n}\n</code></pre>\n<p>It gives me error:</p>\n<pre><code>test/test.cpp:13:20:   required from here\ninclude/Object.hpp:24:49: error: could not convert \u2018{std::move&lt;Foo&amp;&gt;((* &amp; object))}\u2019 from \u2018&lt;brace-enclosed initializer list&gt;\u2019 to \u2018Foo\u2019\n         : object_ptr {new T {std::move(object)} } {}\n                                                 ^\ninclude/Object.hpp:24:49: error: no matching function for call to \u2018std::shared_ptr&lt;void&gt;::shared_ptr(&lt;brace-enclosed initializer list&gt;)\u2019\ninclude/Object.hpp:24:49: note: candidates are:\nIn file included from /usr/include/c++/4.8/memory:82:0,\n                 from include/Object.hpp:7,\n                 from test/test.cpp:2:\n/usr/include/c++/4.8/bits/shared_ptr.h:314:2: note: template&lt;class _Alloc, class ... _Args&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...)\n  shared_ptr(_Sp_make_shared_tag __tag, const _Alloc&amp; __a,\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:314:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:265:17: note: constexpr std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::nullptr_t) [with _Tp = void; std::nullptr_t = std::nullptr_t]\n       constexpr shared_ptr(nullptr_t __p) noexcept\n                 ^\n/usr/include/c++/4.8/bits/shared_ptr.h:265:17: note:   no known conversion for argument 1 from \u2018&lt;type error&gt;\u2019 to \u2018std::nullptr_t\u2019\n/usr/include/c++/4.8/bits/shared_ptr.h:257:2: note: template&lt;class _Tp1, class _Del&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::unique_ptr&lt;_Up, _Ep&gt;&amp;&amp;)\n  shared_ptr(std::unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r)\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:257:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:253:2: note: template&lt;class _Tp1&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::auto_ptr&lt;_Up&gt;&amp;&amp;)\n  shared_ptr(std::auto_ptr&lt;_Tp1&gt;&amp;&amp; __r);\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:253:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:248:11: note: template&lt;class _Tp1&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(const std::weak_ptr&lt;_Tp1&gt;&amp;)\n  explicit shared_ptr(const weak_ptr&lt;_Tp1&gt;&amp; __r)\n           ^\n/usr/include/c++/4.8/bits/shared_ptr.h:248:11: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:236:2: note: template&lt;class _Tp1, class&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::shared_ptr&lt;_Tp1&gt;&amp;&amp;)\n  shared_ptr(shared_ptr&lt;_Tp1&gt;&amp;&amp; __r) noexcept\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:236:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:226:7: note: std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::shared_ptr&lt;_Tp&gt;&amp;&amp;) [with _Tp = void]\n       shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n       ^\n/usr/include/c++/4.8/bits/shared_ptr.h:226:7: note:   no known conversion for argument 1 from \u2018&lt;type error&gt;\u2019 to \u2018std::shared_ptr&lt;void&gt;&amp;&amp;\u2019\n/usr/include/c++/4.8/bits/shared_ptr.h:218:2: note: template&lt;class _Tp1, class&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(const std::shared_ptr&lt;_Tp1&gt;&amp;)\n  shared_ptr(const shared_ptr&lt;_Tp1&gt;&amp; __r) noexcept\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:218:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:206:2: note: template&lt;class _Tp1&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(const std::shared_ptr&lt;_Tp1&gt;&amp;, _Tp*)\n  shared_ptr(const shared_ptr&lt;_Tp1&gt;&amp; __r, _Tp* __p) noexcept\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:206:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:184:2: note: template&lt;class _Deleter, class _Alloc&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::nullptr_t, _Deleter, _Alloc)\n  shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:184:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:165:2: note: template&lt;class _Tp1, class _Deleter, class _Alloc&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(_Tp1*, _Deleter, _Alloc)\n  shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:165:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:146:2: note: template&lt;class _Deleter&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::nullptr_t, _Deleter)\n  shared_ptr(nullptr_t __p, _Deleter __d)\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:146:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:129:2: note: template&lt;class _Tp1, class _Deleter&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(_Tp1*, _Deleter)\n  shared_ptr(_Tp1* __p, _Deleter __d)\n  ^\n/usr/include/c++/4.8/bits/shared_ptr.h:129:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:112:11: note: template&lt;class _Tp1&gt; std::shared_ptr&lt;_Tp&gt;::shared_ptr(_Tp1*)\n  explicit shared_ptr(_Tp1* __p)\n           ^\n/usr/include/c++/4.8/bits/shared_ptr.h:112:11: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/bits/shared_ptr.h:103:7: note: std::shared_ptr&lt;_Tp&gt;::shared_ptr(const std::shared_ptr&lt;_Tp&gt;&amp;) [with _Tp = void]\n       shared_ptr(const shared_ptr&amp;) noexcept = default;\n       ^\n/usr/include/c++/4.8/bits/shared_ptr.h:103:7: note:   no known conversion for argument 1 from \u2018&lt;type error&gt;\u2019 to \u2018const std::shared_ptr&lt;void&gt;&amp;\u2019\n/usr/include/c++/4.8/bits/shared_ptr.h:100:17: note: constexpr std::shared_ptr&lt;_Tp&gt;::shared_ptr() [with _Tp = void]\n       constexpr shared_ptr() noexcept\n                 ^\n/usr/include/c++/4.8/bits/shared_ptr.h:100:17: note:   candidate expects 0 arguments, 1 provided\nmake: *** [test.o] Error 1\n</code></pre>\n<p>However if I change <code>new T {std::move(object)}</code> to <code>new T (std::move(object))</code>. It works:</p>\n<pre><code>class Object {\n    std::shared_ptr&lt;void&gt; object_ptr;\npublic:\n    Object() {}\n\n    template&lt;typename T&gt;\n    Object(T&amp;&amp; object) \n        : object_ptr {new T (std::move(object)) } {}\n\n    virtual ~Object() {};\n};\n</code></pre>\n<p>Why curly brace uniform initialization does not work here? Why is considered an initializater list in this case? Foo does not even have a constructor taking initializer list?</p>\n", "AcceptedAnswerId": "31036612", "Title": "Uniform Initialization with curly brace is mistaken as Initializer List", "CreationDate": "2015-06-24T20:11:36.250", "Id": "31036066", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-06-24T20:17:56.657", "LastEditorUserId": "1270003", "LastActivityDate": "2015-06-24T20:43:33.560", "Score": "5", "OwnerUserId": "1270003", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31036066_31036612_0": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_31036066_31036612_0": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_31036066_31036612_0": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "31036612": {"Id": "31036612", "PostTypeId": "2", "Body": "<p>This was a known issue, and a defect in the standard (see <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\" rel=\"nofollow\"><strong>CWG #1467</strong></a>). The proposal has been applied to the latest working paper (\u00a78.5.4 [dcl.init.list]/3):</p>\n<blockquote>\n<p id=\"so_31036066_31036612_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If <code>T</code> is a class type and the initializer list has a single element of type <code>cv U</code>, where <code>U</code> is <code>T</code> or a class derived\n  from <code>T</code>, the object is initialized from that element (by copy-initialization for copy-list-initialization, or\n  by direct-initialization for direct-list-initialization).</li>\n</ul>\n</blockquote>\n<p>Note that trunk versions of <a href=\"http://melpon.org/wandbox/permlink/Exa3mNJmnifAQ7Ct\" rel=\"nofollow\">Clang</a> and <a href=\"http://melpon.org/wandbox/permlink/qLEWrt3cCp3aoiP2\" rel=\"nofollow\">GCC</a> accept this code.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2015-06-24T20:43:33.560", "Score": "4", "CreationDate": "2015-06-24T20:41:06.337", "ParentId": "31036066", "CommentCount": "4", "OwnerUserId": "701092", "LastEditDate": "2015-06-24T20:43:33.560"}});