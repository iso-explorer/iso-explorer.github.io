post_cb({"bq_ids": {"n4140": {"so_19200528_19200789_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 1317}, "so_19200528_19200789_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 1320}}, "n3337": {"so_19200528_19200789_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 1311}, "so_19200528_19200789_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 1314}}, "n4659": {"so_19200528_19200789_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 1446}, "so_19200528_19200789_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 1450}}}, "19200528": {"ViewCount": "972", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/735204/convert-a-string-in-c-to-upper-case\">this post</a> one of the answers recommends changing a <code>std::string</code> case this way:</p>\n<pre><code>std::string str = \"Hello World\";\nstd::transform(str.begin(), str.end(),str.begin(), ::toupper);\n</code></pre>\n<p>I've used it and it works so far in Visual Studio 2010.  But is it guaranteed by the standard to always work?  My concern is that I can imagine the possibility of implementations where writing to the output iterator (the third argument) could invalidate the input iterators (arguments one and two).</p>\n<p>So, in summary, is the above method safe and portable?</p>\n", "AcceptedAnswerId": "19200789", "Title": "Is it safe for the input iterator and output iterator in std::transform to be from the same container?", "CreationDate": "2013-10-05T17:19:25.037", "Id": "19200528", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:29:34.220", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-03T23:58:04.243", "Score": "6", "OwnerUserId": "502556", "Tags": "<c++><stl>", "AnswerCount": "3"}, "19200745": {"Id": "19200745", "PostTypeId": "2", "Body": "<p>If you look into the <a href=\"http://en.cppreference.com/w/cpp/algorithm/transform\" rel=\"nofollow\"><strong>first possible implementation</strong></a> of <code>std::transform</code> </p>\n<pre><code>template&lt;class InputIt, class OutputIt, class UnaryOperation&gt;\nOutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, \n                   UnaryOperation unary_op)\n{\n    while (first1 != last1) {\n        *d_first++ = unary_op(*first1++);\n    }\n    return d_first;\n}\n</code></pre>\n<p>It may appear that its not \"safe\".</p>\n<p>However, with <code>std::transform(str.begin(), str.end(),str.begin(), ::toupper);</code></p>\n<p><code>d_first</code> and <code>first1</code> point to the same place, but they are not the same iterator !</p>\n<p>There isn't any problem with incrementing both those iterators in a single statement.</p>\n<p>Another implementation is some what like this (from MingW header file), which is <strong>equivalent</strong>, but looks bit cleaner</p>\n<pre><code>template&lt;class InputIt, class OutputIt, class UnaryOperation&gt;\nOutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, \n                   UnaryOperation unary_op)\n{\n\n  for (; first1 != last1; ++first1, ++d_first)\n    *d_first = unary_op(*first1);\n\n    return d_first;\n}\n</code></pre>\n<p><strong>Edited</strong> thanks to John Bartholomew </p>\n", "LastEditorUserId": "1870232", "LastActivityDate": "2013-10-05T19:13:41.970", "Score": "3", "CreationDate": "2013-10-05T17:40:06.467", "ParentId": "19200528", "CommentCount": "5", "OwnerUserId": "1870232", "LastEditDate": "2013-10-05T19:13:41.970"}, "19200801": {"Id": "19200801", "PostTypeId": "2", "Body": "<p>Yes, you can use the input iterator as the output iterator also, on a modifying algorithm it just means the modification will be done inline (on the source container) rather than on some other destination container. </p>\n", "LastActivityDate": "2013-10-05T17:44:20.803", "CommentCount": "0", "CreationDate": "2013-10-05T17:44:20.803", "ParentId": "19200528", "Score": "2", "OwnerUserId": "2804295"}, "19200789": {"Id": "19200789", "PostTypeId": "2", "Body": "<p>Yes, this is guaranteed to be safe (as long as operation itself doesn't modify the elements or invalidate iterators).<br>\nFrom chapter <code>[alg.transform]</code> from draft n3337:</br></p>\n<pre><code>template&lt;class InputIterator, class OutputIterator,  \n    class UnaryOperation&gt;  \nOutputIterator  \ntransform(InputIterator first, InputIterator last,  \n    OutputIterator result, UnaryOperation op);  \n\ntemplate&lt;class InputIterator1, class InputIterator2,  \n    class OutputIterator, class BinaryOperation&gt;  \nOutputIterator  \ntransform(InputIterator1 first1, InputIterator1 last1,  \n    InputIterator2 first2, OutputIterator result,  \n    BinaryOperation binary_op);  \n</code></pre>\n<blockquote>\n<p id=\"so_19200528_19200789_0\">2 Requires: <code>op</code> and <code>binary_op</code> shall not invalidate iterators or subranges, or modify elements in the\n  ranges <code>[first1,last1]</code>, <code>[first2,first2 + (last1 - first1)]</code>, and <code>[result,result + (last1 -first1)]</code>.</p>\n<p id=\"so_19200528_19200789_1\">[...]  </p>\n<p id=\"so_19200528_19200789_2\">5 Remarks: <code>result</code> may be equal to <code>first</code> in case of unary transform, or to <code>first1</code> or first2 in case\n  of binary transform.</p>\n</blockquote>\n", "LastEditorUserId": "4928", "LastActivityDate": "2016-07-03T23:58:04.243", "Score": "9", "CreationDate": "2013-10-05T17:43:41.240", "ParentId": "19200528", "CommentCount": "0", "OwnerUserId": "947836", "LastEditDate": "2016-07-03T23:58:04.243"}});