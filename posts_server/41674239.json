post_cb({"41993391": {"ParentId": "41674239", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-02-02T02:44:35.223", "Score": "1", "LastEditorUserId": "14860", "LastEditDate": "2017-02-03T01:49:39.010", "Id": "41993391", "OwnerUserId": "14860", "Body": "<p>No, this is not permitted by the standard. Keep in mind the C++ standard defers to C for this particular area, for example, C++11 defers to C99, as per <code>C++11 1.1 /2</code>. Specifically, <code>C++11 18.4.1 Header &lt;cstdint&gt; synopsis /2</code> states:</p>\n<blockquote>\n<p id=\"so_41674239_41993391_0\">The header defines all functions, types, and macros the same as 7.18 in the C standard.</p>\n</blockquote>\n<p>So let's get your first contention out of the way, you state:</p>\n<blockquote>\n<p id=\"so_41674239_41993391_1\">Implementations of the C++ standard typedef the (u)int_fastX types as one of their built in types. This requires research in which type is the fastest, but there cannot be one fastest type for every case.</p>\n</blockquote>\n<p>The C standard has this to say, in <code>c99 7.18.1.3 Fastest minimum-width integer types</code> (my italics):</p>\n<blockquote>\n<p id=\"so_41674239_41993391_2\">Each of the following types designates an integer type that is <em>usually</em> fastest to operate with among all integer types that have at least the specified width.</p>\n<p id=\"so_41674239_41993391_3\">The designated type is not guaranteed to be fastest for <em>all</em> purposes; if the implementation has no clear grounds for choosing one type over another, it will simply pick some integer type satisfying the signedness and width requirements.</p>\n</blockquote>\n<p>So you're indeed correct that a type cannot be fastest for all possible uses but this seems to not be what the authors had in mind in defining these aspects.</p>\n<p>The introduction of the fixed-width types was (in my opinion) to solve the problem all those developers had in having different <code>int</code> widths across the various implementations.</p>\n<p>Similarly, once a developer knows the range of values they want, the fast minimum-width types give them a way to do arithmetic on those values at the maximum possible speed.</p>\n<p>Covering your three specific questions in your final paragraph (in bold below):</p>\n<hr>\n<p><strong>(1) Is such compile time resolution permitted by the standard?</strong></p>\n<p>I don't believe so. The relevant part of the C standard has this little piece of text:</p>\n<blockquote>\n<p id=\"so_41674239_41993391_4\">For each type described herein that the implementation provides, <code>&lt;stdint.h&gt;</code> shall declare that <code>typedef</code> name and define the associated macros.</p>\n</blockquote>\n<p>That seems to indicate that it must be a <code>typedef</code> provided by the implementation and, since there are no \"variable\" typedefs, it has to be fixed.</p>\n<p>There <em>may</em> be wiggle room because it could be possible to provide a different <code>typedef</code> depending on certain environmental considerations but the difficulty in actually implementing this seems very high (see my answer to your third question below).</p>\n<p>Chief amongst these is that these adaptable types, should they have external linkage, would require agreement amongst <em>all</em> the compiled translation units when linked together. Having one unit with a 16-bit type and another with a 32-bit type is going to cause all sorts of problems.</p>\n<hr>\n<p><strong>(2) If yes, why isn't it implemented as of today?</strong></p>\n<p>I'm pushing \"no\" as an answer to your first question so I'm not going to speculate on this other than by referring you to the answer to the third question below (it's probably not implemented because it's very hard, with dubious benefits).</p>\n<hr>\n<p><strong>(3) If no, why isn't it in the standard?</strong></p>\n<p>A standard is a contract between the implementor and the user and describes what the implementor will provide. It's usual that the standards committees tend to be more populated by the former (who aren't that keen on making <em>too</em> much extra work for themselves) than the latter.</p>\n<p>For example, I would <em>love</em> to have all the you-beaut C++ data structures in C but this would have the consequence that standards versions would be decades apart rather than years :-)</p>\n</hr></hr></hr>", "LastActivityDate": "2017-02-03T01:49:39.010"}, "41674239": {"CommentCount": "7", "ViewCount": "101", "PostTypeId": "1", "LastEditorUserId": "7350842", "CreationDate": "2017-01-16T10:27:31.310", "LastActivityDate": "2017-02-03T01:49:39.010", "Title": "Resolve (u)int_fastX_t at compile time", "AcceptedAnswerId": "41993391", "LastEditDate": "2017-01-16T12:14:00.610", "Id": "41674239", "Score": "4", "Body": "<p>Implementations of the C++ standard typedef the (u)int_fastX types as one of their built in types. This requires research in which type is the fastest, but there cannot be one fastest type for every case.</p>\n<p>Wouldn't it increase performance to resolve such types at compile time to account for the case by chosing the optimal type for the actual use? The compiler would analyze the use of a _fast variable and then chose the optimal type. Factors coming into play could be alignment and the kind of operations used with the variable.</p>\n<p>This would effectively make those types a language feature. </p>\n<p>This could introduce bugs when the compiler suddenly decides to choose another width for such a variable. But one shouldn't use a _fast type in such use cases, where the behaviour depends on the width, anyways.</p>\n<p>Is such compile time resolval permitted by the standard?\nIf yes, why isn't it implemented as of today?\nIf no, why isn't it in the standard?</p>\n", "Tags": "<c++>", "OwnerUserId": "7350842", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41674239_41993391_0": {"section_id": 6797, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_41674239_41993391_0": {"section_id": 6552, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_41674239_41993391_0": {"section_id": 8287, "quality": 0.6666666666666666, "length": 6}}}});