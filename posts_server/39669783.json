post_cb({"bq_ids": {"n4140": {"so_39669783_39670474_0": {"length": 9, "quality": 0.6, "section_id": 5941}}, "n3337": {"so_39669783_39670474_0": {"length": 8, "quality": 0.5333333333333333, "section_id": 5712}}, "n4659": {"so_39669783_39670474_0": {"length": 9, "quality": 0.6, "section_id": 7425}}}, "39669783": {"ViewCount": "154", "Body": "<p>I tried to provide structures for checking is <code>A</code> is (choose cast)-castable to <code>B</code>. \nAll four casts would have exact same implementation, expect their names (local-macro-able definitions would be possible, but not necessary). I wrote many check-for operators structures, for example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;string&gt;\n\ntemplate&lt;class, class, class, class = void&gt;\nstruct is_valid_ternary_operator : std::false_type\n{ };\n\ntemplate&lt;class T, class S, class R&gt;\nstruct is_valid_ternary_operator &lt;T, S, R, \n                                  std::void_t&lt;decltype(std::declval&lt;T&gt;() ?\n                                                       std::declval&lt;S&gt;() :\n                                                       std::declval&lt;R&gt;())&gt;&gt; : std::true_type\n{ };\n\nint main()\n{\n                                          //true? 1 : 0 //is ok\n    std::cout &lt;&lt; is_valid_ternary_operator&lt;bool, int, int&gt;::value &lt;&lt; std::endl;\n                                          //true? 1 : std::string(\"0\") //would be error\n    std::cout &lt;&lt; is_valid_ternary_operator&lt;bool, int, std::string&gt;::value &lt;&lt; std::endl;\n                                          //true? std::string(\"1\") : std::string(\"0\") //ok\n    std::cout &lt;&lt; is_valid_ternary_operator&lt;bool, std::string, std::string&gt;::value &lt;&lt; std::endl;\n                                          //std::string(\"1\")? 1 : 0 //error\n    std::cout &lt;&lt; is_valid_ternary_operator&lt;std::string, int, int&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f3bceabfe478caaf\" rel=\"nofollow\">Live example</a></p>\n<p>Expected output is displayed. But now consider doing the same with casts:</p>\n<pre><code>template&lt;class T, class S, class = void&gt;\nstruct is_static_cast_able : std::false_type\n{ };\n\ntemplate&lt;class T, class S&gt;\nstruct is_static_cast_able&lt;T, S, \n                           std::void_t&lt;decltype(static_cast&lt;std::declval&lt;S&gt;()&gt;\n                                                           (std::declval&lt;T&gt;()))&gt;&gt; : std::true_type\n{ };\n</code></pre>\n<p>But it generates errors:</p>\n<pre><code>main.cpp:12:84: error: template argument 1 is invalid\n    (std::declval&lt;T&gt;()))&gt;&gt; : std::true_type\n                        ^~\nmain.cpp:12:94: error: template argument 3 is invalid\n    (std::declval&lt;T&gt;()))&gt;&gt; : std::true_type\n                                  ^~~~~~~~~\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cb4401c17fbb1812\" rel=\"nofollow\">Live</a></p>\n<p>Is using casts in unevaluated context not allowed?</p>\n", "AcceptedAnswerId": "39670128", "Title": "Can static/dynamic/const/reinterpret_cast be used in unevaluated context?", "CreationDate": "2016-09-23T21:27:04.043", "Id": "39669783", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-09-27T17:48:50.460", "Score": "3", "OwnerUserId": "5405086", "Tags": "<c++><casting><c++14><c++1z>", "AnswerCount": "2"}, "39670474": {"Id": "39670474", "PostTypeId": "2", "Body": "<p><code>is_static_castable&lt;T, S&gt;</code> sounds like something already existing in the C++ standard library. as <a href=\"http://en.cppreference.com/w/cpp/types/is_convertible\" rel=\"nofollow\"><code>std::is_convertible</code></a>.</p>\n<p>And to your question: <code>static_cast</code> doesn't always mean compile time. For example, in the conversions of integer and floating point types, the compiler may chose to emit code for the conversion if it cannot do so at compile-time. Though. it can very much appear in an unevaluated context.</p>\n<p>Unevaluated operands in C++ are very limited:\nThe contexts are:</p>\n<ul>\n<li><code>decltype</code></li>\n<li><code>sizeof</code></li>\n<li><code>typeid</code></li>\n<li><code>noexcept</code></li>\n</ul>\n<p>To quote C++ standard draft, <a href=\"http://eel.is/c++draft/expr#8\" rel=\"nofollow\">[expr/8]</a></p>\n<blockquote>\n<p id=\"so_39669783_39670474_0\">In some contexts, unevaluated operands appear (<code>[expr.typeid]</code>,\n  <code>[expr.sizeof]</code>, <code>[expr.unary.noexcept]</code>, <code>[dcl.type.simple]</code>). An\n  unevaluated operand is not evaluated. An unevaluated operand is\n  considered a full-expression.</p>\n</blockquote>\n<hr>\n<p>NOTE: <code>std::is_convertible</code> doesn't cover all cases of <code>static_cast</code></p>\n<p>Therefore, for completeness, this is what you want to do with <code>is_static_cast_able</code>, covering virtually all cases of <code>static_cast</code>:</p>\n<pre><code>template&lt;class T, class S, class = void&gt;\nstruct is_static_cast_able : std::false_type\n{ };\n\ntemplate&lt;class T, class S&gt;\nstruct is_static_cast_able&lt;T, S,\n        std::enable_if_t&lt;\n            std::is_convertible&lt;T, S&gt;::value ||\n            std::is_base_of&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;S&gt;&gt;::value ||\n            std::is_base_of&lt;std::decay_t&lt;S&gt;, std::decay_t&lt;T&gt;&gt;::value ||\n            std::is_base_of&lt;std::remove_pointer_t&lt;T&gt;, std::remove_pointer_t&lt;S&gt;&gt;::value ||\n            std::is_base_of&lt;std::remove_pointer_t&lt;S&gt;, std::remove_pointer_t&lt;T&gt;&gt;::value ||\n            (std::is_same&lt;T, void*&gt;::value &amp;&amp; std::is_pointer&lt;S&gt;::value) ||\n            (std::is_same&lt;S, void*&gt;::value &amp;&amp; std::is_pointer&lt;T&gt;::value)\n        &gt;\n    &gt;\n: std::true_type { };\n</code></pre>\n<p>The following test code passes:</p>\n<pre><code>struct A {};\nstruct B : public A {};\n\nint main()\n{\n    static_assert(is_static_cast_able&lt;int, char&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;double, int&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;int, double&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;void*, double*&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;double*, void*&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;B, A&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;A, B&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;B&amp;, A&amp;&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;B*, A*&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;A&amp;, B&amp;&gt;::value, \"\");\n    static_assert(is_static_cast_able&lt;A*, B*&gt;::value, \"\");\n}\n</code></pre>\n<p>See it <a href=\"http://coliru.stacked-crooked.com/a/f31fcca7d33fc50f\" rel=\"nofollow\">Live on Coliru</a></p>\n</hr>", "LastEditorUserId": "1621391", "LastActivityDate": "2016-09-23T22:39:35.813", "Score": "2", "CreationDate": "2016-09-23T22:34:08.127", "ParentId": "39669783", "CommentCount": "0", "OwnerUserId": "1621391", "LastEditDate": "2016-09-23T22:39:35.813"}, "39670128": {"Id": "39670128", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39669783_39670128_0\">Is using casts in unevaluated context not allowed?</p>\n</blockquote>\n<p>Short answer: yes, it is allowed.</p>\n<hr>\n<p>Anyway, I would try to reduce the example to a minimal, working one.<br>\nNote that <em>casts</em> are <em>expressions</em> and they are expected to work with operators the operands of which are unevaluated (<code>sizeof</code>, <code>noexcept</code>, <code>decltype</code>, <code>typeid</code>), unless explicitly stated the opposite.</br></p>\n<p>As an example, <code>sizeof</code> is an unevaluated context:</p>\n<pre><code>int main() {\n    unsigned int i;\n    sizeof(static_cast&lt;int&gt;(i));\n}\n</code></pre>\n<p>Far easier an example, and it works.<br>\nThe same can be shown using <code>decltype</code>, the operands of which are unevaluated as well:</br></p>\n<pre><code>int main() {\n    unsigned int i;\n    decltype(static_cast&lt;int&gt;(i)) j = i;\n}\n</code></pre>\n<p>And so on, we can do something similar both with <code>noexcept</code>:</p>\n<pre><code>int main() {\n    unsigned int i;\n    bool b = noexcept(static_cast&lt;int&gt;(i));\n}\n</code></pre>\n<p>And with <code>typeid</code>:</p>\n<pre><code>#include &lt;typeinfo&gt;\n\nint main() {\n    unsigned int i;\n    auto b = typeid(static_cast&lt;int&gt;(i)).name();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "4987285", "LastActivityDate": "2016-09-27T17:48:50.460", "Score": "3", "CreationDate": "2016-09-23T21:58:09.180", "ParentId": "39669783", "CommentCount": "2", "OwnerUserId": "4987285", "LastEditDate": "2016-09-27T17:48:50.460"}});