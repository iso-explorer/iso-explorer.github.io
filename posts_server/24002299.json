post_cb({"24002299": {"CommentCount": "8", "ViewCount": "439", "PostTypeId": "1", "OwnerDisplayName": "user2080767", "CreationDate": "2014-06-02T20:01:00.017", "LastActivityDate": "2014-06-03T10:20:55.230", "LastEditDate": "2014-06-03T10:20:55.230", "AcceptedAnswerId": "24002611", "LastEditorDisplayName": "user2080767", "Title": "C++ - Return multidimensional array from function", "Id": "24002299", "Score": "2", "Body": "<p>I am writing a code for Cellular Automata and I need an evolution function to calculate the state of the automata after a time step.\nI choose to call this function evol, to test it I created an elementary function in C++. Unfortunately it does not compile since the compiler cannot understand that I need it to return an array. Here is the code :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nconst int N = 51; // Size of the grid; two columns/rows are added at the beginning and the end of the array (no evolution of the CA on the boundaries)\n\nclass Cell{\n    //defining whats a cell here        \n};\n\nvoid showCA(Cell CA[N+2][N+2]){\n    //function to print the CA grid in the terminal         \n}\n\n\nCell[N+2][N+2] evol(Cell CA[N+2][N+2]){\n    return CA;\n}\n\nint main()\n{\n     // Initialisation\n    cout &lt;&lt; \"Initialisation\" &lt;&lt; endl;\n    static Cell CA[N+2][N+2];\n    // some code here to initialize properly the Cell array.\n    showCA(CA);\n    CA = evol(CA);\n    showCA(CA);\n    return 0;\n} \n</code></pre>\n<p>The compiler returns this error :</p>\n<pre><code>error: expected unqualified-id\nCell[N+2][N+2] evol(Cell CA[N+2][N+2]){\n</code></pre>\n<p>Any idea on how I should implement this ? </p>\n", "Tags": "<c++><function><multidimensional-array>", "AnswerCount": "5"}, "24002611": {"ParentId": "24002299", "PostTypeId": "2", "CommentCount": "12", "Body": "\n<p><strong>You cannot return arrays from functions:</strong></p>\n<blockquote>\n<p id=\"so_24002299_24002611_0\"><strong>\u00a7 8.3.5/8</strong> </p>\n<p id=\"so_24002299_24002611_1\">Functions shall not have a return type of type array or function, although they may have a return type of type pointer or reference to such things.</p>\n</blockquote>\n<p>If you are wishing to return raw, C-style arrays from functions, then you have to use a reference or pointer. For example, here's how it is done using a reference (you can do the same using a pointer by replacing <code>&amp;</code> with <code>*</code>):</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>Cell (&amp;evol(Cell (&amp;CA)[N+2][N+2]))[N+2][N+2];\n</code></pre>\n<p>However, this is very unintuitive and hard to read. If your compiler supports the latest standard (C++11) the return type can be cleaned up using a trailing return type:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>auto evol(Cell (&amp;CA)[N+2][N+2]) -&gt; Cell(&amp;)[N+2][N+2];\n</code></pre>\n<p>But again, this is probably still harder to read.</p>\n<hr>\n<p>C++11 facilitates the handling of C-style arrays with the container <code>std::array&lt;&gt;</code>. Non-C++11 code should use <code>std::vector&lt;&gt;</code>:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>using Cells = std::array&lt;std::array&lt;Cell, N+2&gt;, N+2&gt;;\n\nCells const&amp; evol(Cells const&amp; CA);\n</code></pre>\n</hr>", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2014-06-02T21:10:12.000", "Id": "24002611", "Score": "3", "CreationDate": "2014-06-02T20:21:35.397", "LastActivityDate": "2014-06-02T21:10:12.000"}, "24002463": {"ParentId": "24002299", "CommentCount": "2", "Body": "<p>You can use </p>\n<pre><code>typedef std::vector&lt;std::vector&lt;Cell&gt;&gt; CellArray;\nCellArray Cells(N+2);  // resize main dimension\nfor (size_t i=0; i&lt;N+2; i++)\n    Cells[i].resize(N+2); // resize all cells of main dimension\n</code></pre>\n<p>to hold your cell array, but you also need to add a copy constructor and operator= in Cell class</p>\n<pre><code>class Cell {\npublic:\n    Cell() { ... default ctor code here ... }\n    Cell(const Cell &amp;c) { *this = c; }\n\n    Cell &amp;operator=(const Cell&amp;c)\n    {\n        if (this != &amp;c)\n        {\n            ... copy data from c members to this members here ...\n        }\n        return *this;\n    }\n};\n</code></pre>\n<p>Your evol function then can return a CellArray:</p>\n<pre><code>CellArray evol(CellArray &amp;c)\n{\n   CellArray r;\n   ... do some calculations with c and r ...\n   return r;\n}\n</code></pre>\n", "OwnerUserId": "1763310", "PostTypeId": "2", "Id": "24002463", "Score": "0", "CreationDate": "2014-06-02T20:11:39.357", "LastActivityDate": "2014-06-02T20:11:39.357"}, "24002473": {"ParentId": "24002299", "CommentCount": "0", "Body": "<p>once you have declared a variable using the array syntax like you have:</p>\n<pre><code>Cell CA[N+2][N+2];\n</code></pre>\n<p>you cannot assign <code>CA</code> to be something else. You can only assign values to its contents. Hence,</p>\n<pre><code>CA = evol(CA);\n</code></pre>\n<p>is wrong.</p>\n<p>You can do the following:</p>\n<pre><code>Cell (*CA2)[N+2] = evol(CA);\n</code></pre>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "24002473", "Score": "0", "CreationDate": "2014-06-02T20:12:19.063", "LastActivityDate": "2014-06-02T20:12:19.063"}, "24002757": {"ParentId": "24002299", "CommentCount": "0", "Body": "<p>I would strongly suggest encapsulate your array into a class. You cannot return an array, but you can return an object that contains an array.</p>\n", "OwnerUserId": "2540407", "PostTypeId": "2", "Id": "24002757", "Score": "0", "CreationDate": "2014-06-02T20:31:27.903", "LastActivityDate": "2014-06-02T20:31:27.903"}, "24002486": {"ParentId": "24002299", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As the number of elements seems to be fixed, I suggest you use the <code>std::array</code> container:</p>\n<pre><code>const int N = 51;\ntypedef std::array&lt;std::array&lt;Cell,N+2&gt;, N+2&gt; datatype;\n</code></pre>\n<p>You can then use this type as a return type:</p>\n<pre><code>datatype Evol( const datatype&amp; d );\n</code></pre>\n<p>You can access elements just as if it was a \"C\" array:</p>\n<pre><code>datatype d;\nCell c;\nd[10][20] = c;\n</code></pre>\n", "OwnerUserId": "193789", "LastEditorUserId": "193789", "LastEditDate": "2014-06-02T20:22:28.557", "Id": "24002486", "Score": "0", "CreationDate": "2014-06-02T20:13:07.287", "LastActivityDate": "2014-06-02T20:22:28.557"}, "bq_ids": {"n4140": {"so_24002299_24002611_1": {"section_id": 3244, "quality": 1.0, "length": 18}}, "n3337": {"so_24002299_24002611_1": {"section_id": 3117, "quality": 1.0, "length": 18}}, "n4659": {"so_24002299_24002611_1": {"section_id": 4002, "quality": 1.0, "length": 18}}}});