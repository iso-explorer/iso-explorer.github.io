post_cb({"41583036": {"ParentId": "30393285", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Another way to deal with this is with a generic lambda in C++14:</p>\n<pre><code>int main() {\n    std::function &lt;void(int, int)&gt; func = [](auto &amp;&amp;... args) { add(std::forward&lt;decltype(args)&gt;(args)...);\n}\n</code></pre>\n<p>That will create a lambda function that will resolve things with no ambiguity.\nI did not forward arguments,</p>\n", "OwnerUserId": "429879", "LastEditorUserId": "429879", "LastEditDate": "2017-06-12T13:30:24.257", "Id": "41583036", "Score": "1", "CreationDate": "2017-01-11T05:00:06.683", "LastActivityDate": "2017-06-12T13:30:24.257"}, "37011575": {"ParentId": "30393285", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As far as I can see, it's a Visual Studio problem.</p>\n<p>c++11 standard (20.8.11) </p>\n<pre><code>std::function synopsis\ntemplate&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;\n</code></pre>\n<p>but VisualStudio doesn't have that specialization</p>\n<p>clang++ and g++ are perfectly fine with overloading std::functions</p>\n<p>prior answers explain why VS doesn't work, but they didn't mention that it's VS' bug</p>\n", "OwnerUserId": "3740987", "LastEditorUserId": "3740987", "LastEditDate": "2016-05-07T01:29:42.730", "Id": "37011575", "Score": "-2", "CreationDate": "2016-05-03T18:20:12.503", "LastActivityDate": "2016-05-07T01:29:42.730"}, "30393589": {"ParentId": "30393285", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>While it's obvious what you want, the problem is that <code>std::function</code> cannot influence overload resolution of <code>&amp;add</code>. If you were to initialize a raw function pointer (<code>void (*func)(int,int) = &amp;add</code>), it does work. That's because function pointer initialization is a context in which overload resolution is done. The target type is exactly known. But <code>std::function</code> will take almost any argument that's callable. That flexibility in accepting arguments does mean that you can't do overload resolution on <code>&amp;add</code>. Multiple overloads of <code>add</code> might be suitable.</p>\n<p>An explicit cast will work, i.e. <code>static_cast&lt;void(*)(int, int)&gt; (&amp;add)</code>.</p>\n<p>This can be wrapped in a <code>template&lt;typename F&gt; std::function&lt;F&gt; make_function(F*)</code> which would allow you to write <code>auto func = make_function&lt;int(int,int)&gt; (&amp;add)</code></p>\n", "OwnerUserId": "15416", "LastEditorUserId": "15416", "LastEditDate": "2015-05-22T10:04:37.573", "Id": "30393589", "Score": "16", "CreationDate": "2015-05-22T09:51:27.323", "LastActivityDate": "2015-05-22T10:04:37.573"}, "30393285": {"CommentCount": "5", "AcceptedAnswerId": "30394755", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-22T09:37:21.400", "LastActivityDate": "2017-06-12T13:30:24.257", "LastEditDate": "2017-05-23T12:26:15.837", "ViewCount": "4141", "FavoriteCount": "2", "Title": "std::function fails to distinguish overloaded functions", "Id": "30393285", "Score": "29", "Body": "<p>I am trying to understand why <code>std::function</code> is not able to distinguish between overloaded functions.</p>\n<pre><code>#include &lt;functional&gt;\n\nvoid add(int,int){}\n\nclass A {};\n\nvoid add (A, A){}\n\nint main(){\n        std::function &lt;void(int, int)&gt; func = add;\n}\n</code></pre>\n<p>In the code shown above, <code>function&lt;void(int, int)&gt;</code> can match only one of these functions and yet it fails. Why is this so? I know I can work around this by using a lambda or a function pointer to the actual function and then storing the function pointer in function. But why does this fail? Isn't the context clear on which function I want to be chosen? Please help me understand why this fails as I am not able to understand why template matching fails in this case.</p>\n<p>The compiler errors that I get on clang for this are as follows:</p>\n<pre><code>test.cpp:10:33: error: no viable conversion from '&lt;overloaded function type&gt;' to\n      'std::function&lt;void (int, int)&gt;'\n        std::function &lt;void(int, int)&gt; func = add;\n                                       ^      ~~~\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03:1266:31: note: \n      candidate constructor not viable: no overload of 'add' matching\n      'std::__1::nullptr_t' for 1st argument\n    _LIBCPP_INLINE_VISIBILITY function(nullptr_t) : __f_(0) {}\n                              ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03:1267:5: note: \n      candidate constructor not viable: no overload of 'add' matching 'const\n      std::__1::function&lt;void (int, int)&gt; &amp;' for 1st argument\n    function(const function&amp;);\n    ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03:1269:7: note: \n      candidate template ignored: couldn't infer template argument '_Fp'\n      function(_Fp,\n      ^\n1 error generated.\n</code></pre>\n<p>EDIT - In addition to MSalters' answer, I did some searching on this forum and found the exact reason why this fails. I got the answer from Nawaz's reply in this <a href=\"https://stackoverflow.com/questions/10111042/wrap-overloaded-function-via-stdfunction?rq=1\">post</a>.</p>\n<p>I have copy pasted from his answer here: </p>\n<pre><code>    int test(const std::string&amp;) {\n        return 0;\n    }\n\n    int test(const std::string*) {\n        return 0;\n    }\n\n    typedef int (*funtype)(const std::string&amp;);\n\n    funtype fun = test; //no cast required now!\n    std::function&lt;int(const std::string&amp;)&gt; func = fun; //no cast!\n</code></pre>\n<p>So why <code>std::function&lt;int(const std::string&amp;)&gt;</code> does not work the way <code>funtype fun = test</code> works above?</p>\n<p>Well the answer is, because <code>std::function</code> can be initialized with any object, <strong>as its constructor is templatized which is independent of the template argument you passed to <code>std::function</code>.</strong></p>\n", "Tags": "<c++><c++11><overload-resolution><std-function>", "OwnerUserId": "3493289", "AnswerCount": "5"}, "30393415": {"ParentId": "30393285", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Try:</p>\n<pre><code>std::function &lt;void(int, int)&gt; func = static_cast&lt;void(*)(int, int)&gt; (add);\n</code></pre>\n<p>Addresses to <code>void add(A, A)</code> and <code>void add(int, int)</code> obvoiusly differes. When you point to the function by name it is pretty much imposible for compiler to know which function address do you need. <code>void(int, int)</code> here is not a hint.</p>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2015-05-22T09:55:31.773", "Id": "30393415", "Score": "4", "CreationDate": "2015-05-22T09:43:34.807", "LastActivityDate": "2015-05-22T09:55:31.773"}, "30394755": {"ParentId": "30393285", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It's obvious to us which function you intend to be chosen, but the compiler has to follow the rules of C++ not use clever leaps of logic (or even not so clever ones, as in simple cases like this!)</p>\n<p>The relevant constructor of <code>std::function</code> is:</p>\n<pre><code>template&lt;class F&gt; function(F f);\n</code></pre>\n<p>which is a template that accepts <em>any</em> type.</p>\n<p>The C++14 standard does constrain the template (since <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2132\">LWG DR 2132</a>) so that it:</p>\n<blockquote>\n<p id=\"so_30393285_30394755_0\">shall not participate in overload resolution unless <code>f</code> is Callable (20.9.12.2) for argument types <code>ArgTypes...</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>which means that the compiler will only allow the constructor to be called when <code>Functor</code> is compatible with the call signature of the <code>std::function</code> (which is <code>void(int, int)</code> in your example). In theory that should mean that <code>void add(A, A)</code> is not a viable argument and so \"obviously\" you intended to use <code>void add(int, int)</code>.</p>\n<p><em>However</em>, the compiler can't test the \"<code>f</code> is Callable for argument types ...\" constraint until it knows the type of <code>f</code>, which means it needs to have already disambiguated between <code>void add(int, int)</code> and <code>void add(A, A)</code> <em>before</em> it can apply the constraint that would allow it to reject one of those functions!</p>\n<p>So there's a chicken and egg situation, which unfortunately means that you need to help the compiler out by specifying exactly which overload of <code>add</code> you want to use, and <em>then</em> the compiler can apply the constraint and (rather redundantly) decide that it is an acceptable argument for the constructor.</p>\n<p>It is conceivable that we could change C++ so that in cases like this <em>all</em> the overloaded functions are tested against the constraint (so we don't need to know which one to test before testing it) and if only one is viable then use that one, but that's not how C++ works.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-05-22T10:52:57.053", "Id": "30394755", "Score": "20", "CreationDate": "2015-05-22T10:48:39.620", "LastActivityDate": "2015-05-22T10:52:57.053"}, "bq_ids": {"n4140": {"so_30393285_30394755_0": {"section_id": 4660, "quality": 0.9, "length": 9}}, "n3337": {"so_30393285_30394755_0": {"section_id": 4470, "quality": 0.6, "length": 6}}, "n4659": {"so_30393285_30394755_0": {"section_id": 6030, "quality": 0.8, "length": 8}}}});