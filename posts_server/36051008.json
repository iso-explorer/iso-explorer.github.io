post_cb({"36101569": {"ParentId": "36051008", "CommentCount": "0", "CreationDate": "2016-03-19T12:12:29.440", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "36101569", "Score": "1", "Body": "<p>We can argue as follows; <a href=\"http://eel.is/c++draft/expr.reinterpret.cast#11\" rel=\"nofollow\">[expr.reinterpret.cast]/11</a>:</p>\n<blockquote>\n<p id=\"so_36051008_36101569_0\">A glvalue expression of type <code>T1</code> can be cast to the type \u201creference\n  to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly\n  converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>.\n  <strong>The result refers to the same object as the source glvalue, but with the specified type.</strong></p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/conv.array\" rel=\"nofollow\">[conv.array]</a>:</p>\n<blockquote>\n<p id=\"so_36051008_36101569_1\">An lvalue or rvalue of type \u201carray of <code>N T</code>\u201d [\u2026] can be converted to a\n  prvalue of type \u201cpointer to <code>T</code>\u201d. <strong>The result is a pointer to the\n  first element of the array.</strong></p>\n</blockquote>\n<p>I.e. arguably, we have a pointer that <em>points</em> to (not just merely represents the address of) the first element. And it is of that element's type. Thus accessing <code>ref[0]</code> should be defined.</p>\n<p>By this logic, it is also  fine to write</p>\n<pre><code>auto&amp; ref = reinterpret_cast&lt;unsigned(&amp;)[200]&gt;(arr);\nstd::cout &lt;&lt; ref[0];\n</code></pre>\n", "LastActivityDate": "2016-03-19T12:12:29.440"}, "36051008": {"CommentCount": "1", "ViewCount": "126", "PostTypeId": "1", "LastEditorUserId": "2684539", "CreationDate": "2016-03-17T03:12:17.877", "LastActivityDate": "2016-03-19T12:12:29.440", "Title": "Is type punning arrays of same type but different size allowed?", "FavoriteCount": "1", "LastEditDate": "2016-03-18T20:11:28.683", "Id": "36051008", "Score": "3", "Body": "<p>Is type punning arrays of the same type but with a different size still a violation of strict aliasing?</p>\n<pre><code>int arr[4];\nint(&amp;ref)[2] = reinterpret_cast&lt;int(&amp;)[2]&gt;(arr);\n\narr[0] = 0; //write to original\nref[0]; //read from pun\n</code></pre>\n", "Tags": "<c++><arrays><language-lawyer><type-punning>", "OwnerUserId": "4756309", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36051008_36101569_0": {"section_id": 6050, "quality": 0.9629629629629629, "length": 26}, "so_36051008_36101569_1": {"section_id": 11, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_36051008_36101569_0": {"section_id": 5818, "quality": 0.8518518518518519, "length": 23}, "so_36051008_36101569_1": {"section_id": 8, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_36051008_36101569_0": {"section_id": 7549, "quality": 0.9629629629629629, "length": 26}, "so_36051008_36101569_1": {"section_id": 12, "quality": 0.9333333333333333, "length": 14}}}});