post_cb({"43745569": {"ViewCount": "116", "Body": "<p>The following code :</p>\n<pre><code>    auto getConnection(const std::string &amp;name) {\n        constexpr const std::size_t id{findFactoryId(_factories, name)};\n        const auto factory = std::get&lt;std::integral_constant&lt;std::size_t, id&gt;{}&gt;(_factories).second;\n        for (auto &amp;connection : _connections[id])\n            if (connection.first) {\n                connection.first = false;\n                decltype(factory()) &amp;res = std::experimental::any_cast(connection.second);\n                return res;\n            }\n        _connections[id].emplace_back(std::make_pair&lt;bool, std::experimental::any&gt;(false, factory()));\n        decltype(factory()) &amp;res = std::experimental::any_cast(_connections[id].back().second);\n        return res;\n    }\n</code></pre>\n<p>compile with clang++, but with g++ gives this error:</p>\n<pre><code>In file included from main.cpp:2:0:\nsrc/core/include/connectionpool.h: Dans la fonction membre \u00ab\u00a0auto Core::ConnectionPool&lt;Connectors&gt;::getConnection(const string&amp;)\u00a0\u00bb:\nsrc/core/include/connectionpool.h:28:79: erreur\u00a0: the value of \u00ab\u00a0id\u00a0\u00bb is not usable in a constant expression\n             const auto factory = std::get&lt;std::integral_constant&lt;std::size_t, id&gt;{}&gt;(_factories).second;\n                                                                               ^~\nsrc/core/include/connectionpool.h:27:41: note\u00a0: \u00ab\u00a0id\u00a0\u00bb used in its own initializer\n             constexpr const std::size_t id{findFactoryId(_factories, name)};\n                                         ^~\nsrc/core/include/connectionpool.h:28:81: erreur\u00a0: the value of \u00ab\u00a0id\u00a0\u00bb is not usable in a constant expression\n             const auto factory = std::get&lt;std::integral_constant&lt;std::size_t, id&gt;{}&gt;(_factories).second;\n                                                                                 ^\nsrc/core/include/connectionpool.h:27:41: note\u00a0: \u00ab\u00a0id\u00a0\u00bb used in its own initializer\n             constexpr const std::size_t id{findFactoryId(_factories, name)};\n                                         ^~\nsrc/core/include/connectionpool.h:28:81: note\u00a0: in template argument for type \u00ab\u00a0unsigned int\u00a0\u00bb \n             const auto factory = std::get&lt;std::integral_constant&lt;std::size_t, id&gt;{}&gt;(_factories).second;\n                                                                                 ^\n</code></pre>\n<p>I'm using those command to compile:</p>\n<pre><code>(clan)g++ -std=c++14 -O2 -Wall -pedantic -Wextra main.cpp\n</code></pre>\n<p>with <code>g++ v6.3.1</code> and <code>clang++ v3.9.1</code></p>\n<p>The only link that look like to correspond to my issue is a bug report for gcc4.9 (which is solved) : <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59937\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59937</a>.</p>\n<p>A minimal working example is available <a href=\"http://coliru.stacked-crooked.com/a/2f1478ab1a02ed45\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>From what I've understood of <code>gcc</code> error message, I should not have any error: <code>id</code> isn't used to initialise itself.</p>\n<p>Should this code yield an error or not ?</p>\n<p>If it should raise an error, what could I do to solve the error ?</p>\n<p>Thank you for your answers.</p>\n<p>The complete code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;functional&gt;\n#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n#include &lt;experimental/any&gt;\n\ntemplate &lt;class F, class... Ts&gt;\nconstexpr void for_each_in_tuple(const std::tuple&lt;Ts...&gt; &amp;tuple, F f) {\n    for_each_in_tuple(tuple, f, std::make_index_sequence&lt;sizeof...(Ts)&gt;());\n}\n\n\ntemplate &lt;class F, class... Ts, std::size_t... Is&gt;\nconstexpr void for_each_in_tuple(const std::tuple&lt;Ts...&gt; &amp;tuple, F f, std::index_sequence&lt;Is...&gt;) {\n    using expander = int[];\n    (void) expander{0, ((void)f(Is, std::get&lt;Is&gt;(tuple)), 0)...};\n}\n\ntemplate &lt;typename... Connectors&gt;\nclass ConnectionPool {\n    public:\n        auto getConnection(const std::string &amp;name) {\n            constexpr const std::size_t id{findFactoryId(_factories, name)};\n            const auto factory = std::get&lt;std::integral_constant&lt;std::size_t, id&gt;{}&gt;(_factories).second;\n            return factory();\n        }\n\n    private:\n        struct foo {\n            constexpr foo(std::size_t &amp;i, const std::string &amp;name) : i(i), name(name) {}\n            template &lt;class T&gt;\n            constexpr void operator()(const std::size_t is, const T pair) {\n                i = name == pair.first ? is : i;\n            }\n            std::size_t &amp;i;\n            const std::string &amp;name;\n        };\n\n        template &lt;class Tuple&gt;\n        static constexpr std::size_t findFactoryId(Tuple &amp;tup, const std::string &amp;name) {\n            std::size_t i = 0;\n            for_each_in_tuple(tup, foo(i, name));\n            return i;\n        }\n\n        std::tuple&lt;std::pair&lt;std::string, std::function&lt;Connectors()&gt;&gt;...&gt; _factories;\n};\n\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>Change link to minimal working example: a function was missing.</p>\n<p><strong>EDIT 2</strong></p>\n<p>Add minimal working example in the post</p>\n", "Title": "var used in its own initializer", "CreationDate": "2017-05-02T19:14:59.930", "LastActivityDate": "2017-05-03T14:02:49.157", "CommentCount": "2", "LastEditDate": "2017-05-02T19:32:11.537", "PostTypeId": "1", "LastEditorUserId": "4534275", "Id": "43745569", "Score": "1", "OwnerUserId": "4534275", "Tags": "<c++><templates><gcc><clang>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43745569_43748514_1": {"length": 10, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_43745569_43748514_1": {"length": 7, "quality": 0.7, "section_id": 5946}}, "n4659": {"so_43745569_43748514_1": {"length": 7, "quality": 0.7, "section_id": 7687}}}, "43748514": {"Id": "43748514", "PostTypeId": "2", "Body": "<p>The problem is on this line:</p>\n<pre><code>constexpr const std::size_t id{findFactoryId(_factories, name)};\n</code></pre>\n<p>The initializer of a <code>constexpr</code> variable must be a constant expression. In a constant expression you can not use the <code>this</code> pointer. You are implicitly using the <code>this</code> pointer by referring to <code>_factories</code>, which is a data member.</p>\n<blockquote>\n<p id=\"so_43745569_43748514_0\">N4296 [expr.const] \u00b62</p>\n<p id=\"so_43745569_43748514_1\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code>... would evaluate one of the following expressions:</p>\n<ul>\n<li><code>this</code>, except in a <code>constexpr</code> function or a <code>constexpr</code> constructor that is being evaluated as part of <code>e</code>;</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>Surprisingly, both compilers are happy if we simply use an explicit <code>this</code>:</p>\n<pre><code>constexpr const std::size_t id{findFactoryId(this-&gt;_factories, name)};\n</code></pre>\n<p>But I do not believe that is conformant. Here is a portable workaround:</p>\n<pre><code>const auto _this = this;\nconstexpr const std::size_t id{findFactoryId(_this-&gt;_factories, name)};\n</code></pre>\n", "LastEditorUserId": "1639256", "LastActivityDate": "2017-05-03T14:02:49.157", "Score": "4", "CreationDate": "2017-05-02T22:58:50.457", "ParentId": "43745569", "CommentCount": "4", "LastEditDate": "2017-05-03T14:02:49.157", "OwnerUserId": "1639256"}});