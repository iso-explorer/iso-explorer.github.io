post_cb({"bq_ids": {"n4140": {"so_28005135_28021381_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 2763}}, "n3337": {"so_28005135_28021381_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 2724}}, "n4659": {"so_28005135_28021381_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 3501}}}, "28021381": {"Id": "28021381", "PostTypeId": "2", "Body": "<p>The Standard says the following:</p>\n<p>30.4.1.2/14  [thread.mutex.requirements.mutex]  </p>\n<blockquote>\n<p id=\"so_28005135_28021381_0\">An implementation\n  may fail to obtain the lock even if it is not held by any other thread. [ Note: This spurious failure is\n  normally uncommon, but allows interesting implementations based on a simple compare and exchange\n  (Clause 29). \u2014end note ]</p>\n</blockquote>\n<p>So you can even get <code>0</code> if all of <code>try_lock</code> fail.</p>\n<p>Also, please do not use cplusplus.com, it has a <a href=\"https://stackoverflow.com/questions/11972076/why-is-the-cplusplus-website-bad\">long history</a> of having lots of mistakes.<br>\nIt's safer to use cppreference.com which is <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/try_lock\" rel=\"nofollow noreferrer\">much closer</a> to the Standard</br></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-19T09:27:00.330", "Score": "2", "CreationDate": "2015-01-19T09:27:00.330", "ParentId": "28005135", "CommentCount": "0", "OwnerUserId": "343443", "LastEditDate": "2017-05-23T11:51:21.067"}, "28005709": {"Id": "28005709", "PostTypeId": "2", "Body": "<p>You can never get 0:</p>\n<p>When first call to <code>try_lock()</code> happens (doesn't matter which thread is here first) the mutex is unlocked. This means that 1 of the 10 threads will manage to lock the mutex, meaning <code>try_lock()</code> will succeed.</p>\n<p>You can get 1:</p>\n<ul>\n<li>Lets say thread 0 manages to lock the mutex:</li>\n</ul>\n<p><code>\nvoid attempt_10k_increases () {\n  for (int i=0; i&lt;10000; ++i) {\n    if (mtx.try_lock()) {  // thread 1 to 9 are here\n      ++counter; // thread 0 is here\n      mtx.unlock();\n    }\n  }\n}\n</code></p>\n<ul>\n<li><p>Now we say that the OS scheduler chose to not run thread 0 for a little while. In the meantime, thread 1 to 9 keep running, calling <code>try_lock()</code> and failing, because thread 0 holds the mutex.</p>\n<ul>\n<li>Thread 1 to 9 are now done. They failed to acquire the mutex even once.</li>\n<li>Thread 0 gets reschuled. It unlock the mutex and finish.</li>\n<li>Counter is now 1. </li>\n</ul></li>\n</ul>\n", "LastActivityDate": "2015-01-17T23:58:56.147", "CommentCount": "2", "CreationDate": "2015-01-17T23:58:56.147", "ParentId": "28005135", "Score": "-1", "OwnerUserId": "865281"}, "28005135": {"ViewCount": "1153", "Body": "<p>On follow link (<a href=\"http://www.cplusplus.com/reference/mutex/mutex/try_lock/\" rel=\"nofollow\">http://www.cplusplus.com/reference/mutex/mutex/try_lock/</a>) we have declared that sample can return only values from 1 to 100000. Does it is declared that 0 can't be in output?</p>\n<pre><code>// mutex::try_lock example\n#include &lt;iostream&gt;       // std::cout\n#include &lt;thread&gt;         // std::thread\n#include &lt;mutex&gt;          // std::mutex\n\nvolatile int counter (0); // non-atomic counter\nstd::mutex mtx;           // locks access to counter\n\nvoid attempt_10k_increases () {\n  for (int i=0; i&lt;10000; ++i) {\n    if (mtx.try_lock()) {   // only increase if currently not locked:\n      ++counter;\n      mtx.unlock();\n    }\n  }\n}\n\nint main ()\n{\n  std::thread threads[10];\n  // spawn 10 threads:\n  for (int i=0; i&lt;10; ++i)\n    threads[i] = std::thread(attempt_10k_increases);\n\n  for (auto&amp; th : threads) th.join();\n  std::cout &lt;&lt; counter &lt;&lt; \" successful increases of the counter.\\n\";\n\n  return 0;\n}\n</code></pre>\n<p>In any case, it's easy to answer 'How to get 2?', but really not clear about how to get 1 and never get 0.</p>\n<p>The try_lock can \"fail spuriously when no other thread has a lock on the mutex, but repeated calls in these circumstances shall succeed at some point\", but if it true, then sample can return 0 (and also can return 1 in some case).</p>\n<p>But, if this specification sample declared true and 0 cannot be in output, then words about \"fail spuriously\" maybe not true then?</p>\n", "AcceptedAnswerId": "28021381", "Title": "Mistake in cpp specification about mutex try_lock?", "CreationDate": "2015-01-17T22:40:51.960", "Id": "28005135", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-01-19T09:27:00.330", "Score": "2", "OwnerUserId": "1766488", "Tags": "<c++>", "AnswerCount": "3"}, "28005184": {"Id": "28005184", "PostTypeId": "2", "Body": "<p>try_lock can fail if another thread held a lock and just released it, for example. You read that \"repeated calls in these circumstances shall succeed at some point\". Doing 10,000 calls to try_lock will count as \"repeated calls\" and one of them will succeed. </p>\n", "LastActivityDate": "2015-01-17T22:47:12.150", "CommentCount": "1", "CreationDate": "2015-01-17T22:47:12.150", "ParentId": "28005135", "Score": "0", "OwnerUserId": "3255455"}});