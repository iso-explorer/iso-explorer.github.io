post_cb({"1404797": {"ViewCount": "2612", "Body": "<p>I would expect that if <code>foo</code> is declared in class <code>D</code>, but not marked virtual, then the following code would call the implementation of <code>foo</code> in <code>D</code> (regardless of the dynamic type of <code>d</code>).</p>\n<pre><code>D&amp; d = ...;\nd.foo();\n</code></pre>\n<p>However, in the following program, that is not the case. Can anyone explain this? Is a method automatically virtual if it overrides a virtual function?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass C {\npublic:\n        virtual void foo() { cout &lt;&lt; \"C\" &lt;&lt; endl; }\n};\n\nclass D : public C {\npublic:\n        void foo() { cout &lt;&lt; \"D\" &lt;&lt; endl; }\n};\n\nclass E : public D {\npublic:\n        void foo() { cout &lt;&lt; \"E\" &lt;&lt; endl; }\n};\n\nint main(int argc, char **argv)\n{\n        E&amp; e = *new E;\n        D&amp; d = *static_cast&lt;D*&gt;(&amp;e);\n        d.foo();\n        return 0;\n}\n</code></pre>\n<p>The output of the above program is:</p>\n<pre><code>E\n</code></pre>\n", "AcceptedAnswerId": "1404843", "Title": "In C++, is a function automatically virtual if it overrides a virtual function?", "CreationDate": "2009-09-10T11:44:02.537", "Id": "1404797", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2009-09-10T11:59:51.927", "Score": "20", "OwnerUserId": "171394", "Tags": "<c++><virtual><override>", "AnswerCount": "4"}, "1404836": {"Id": "1404836", "PostTypeId": "2", "Body": "<p>The output (\"E\") behaves exactly as one would expect it to behave.</p>\n<p>The reason:\nThe dynamic (i.e. runtime) type of that reference is E. You are doing a static upcast to D, but that does not change the actual type of the object of course.</p>\n<p>That's the very idea behind virtual methods and dynamic dispatches: You see the behavior of the type you were instantiating, which is E, in this case.</p>\n", "LastActivityDate": "2009-09-10T11:51:34.003", "CommentCount": "0", "CreationDate": "2009-09-10T11:51:34.003", "ParentId": "1404797", "Score": "-1", "OwnerUserId": "127013"}, "1404843": {"Id": "1404843", "PostTypeId": "2", "Body": "<p>Standard 10.3.2 (class.virtual) says:</p>\n<blockquote>\n<p id=\"so_1404797_1404843_0\">If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly from Base, a member function vf with the same name and same parameter list as Base::vf is declared, then Derived::vf is also virtual (whether or not it is so declared) and it overrides*</p>\n<p id=\"so_1404797_1404843_1\">[Footnote: A function with the same name but a different parameter list (clause over) as a virtual function is not necessarily virtual and does not override. The use of the virtual specifier in the declaration of an overriding function is legal but redundant (has empty semantics). Access control (clause class.access) is not considered in determining overriding. --- end foonote]</p>\n</blockquote>\n", "LastActivityDate": "2009-09-10T11:53:54.920", "CommentCount": "0", "CreationDate": "2009-09-10T11:53:54.920", "ParentId": "1404797", "Score": "22", "OwnerUserId": "113662"}, "bq_ids": {"n4140": {"so_1404797_1404843_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 7003}, "so_1404797_1404843_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 7003}}, "n3337": {"so_1404797_1404843_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6749}, "so_1404797_1404843_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 6749}}, "n4659": {"so_1404797_1404843_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 8500}, "so_1404797_1404843_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 8500}}}, "1404815": {"Id": "1404815", "PostTypeId": "2", "Body": "<p>Quick answer may be no, but correct answer is <strong>yes</strong></p>\n<p>C++ doesn't know about function hiding, so overriding virtual function without virtual keyword marks that function virtual too.</p>\n", "LastActivityDate": "2009-09-10T11:46:32.690", "CommentCount": "3", "CreationDate": "2009-09-10T11:46:32.690", "ParentId": "1404797", "Score": "17", "OwnerUserId": "74261"}, "1404823": {"Id": "1404823", "PostTypeId": "2", "Body": "<p>You are not creating any copy of the object of e and putting it in d. So d.foo() follows normal polymorphic behavior and calls derived class method. A method which is declared as virtual in the base class becomes automatically virtual in the derived class also.</p>\n", "LastEditorUserId": "39742", "LastActivityDate": "2009-09-10T11:59:51.927", "Score": "0", "CreationDate": "2009-09-10T11:48:08.600", "ParentId": "1404797", "CommentCount": "0", "OwnerUserId": "39742", "LastEditDate": "2009-09-10T11:59:51.927"}});