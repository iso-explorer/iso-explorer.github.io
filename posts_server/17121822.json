post_cb({"17121822": {"ViewCount": "186", "Body": "<p>I would like to save typing in some loop, creating reference to an array element, which might not exist. Is it legal to do so? A short example:</p>\n<pre><code>#include&lt;vector&gt;\n#include&lt;iostream&gt;\n#include&lt;initializer_list&gt;\nusing namespace std;\nint main(void){\n    vector&lt;int&gt; nn={0,1,2,3,4};\n    for(size_t i=0; i&lt;10; i++){\n        int&amp; n(nn[i]); // this is just to save typing, and is not used if invalid\n        if(i&lt;nn.size()) cout&lt;&lt;n&lt;&lt;endl;\n    }\n};\n</code></pre>\n<p><a href=\"https://ideone.com/nJGKdW\" rel=\"nofollow\">https://ideone.com/nJGKdW</a> compiles and runs the code just fine (I tried locally with both g++ and clang++), but I am not sure if I can count on that.</p>\n<p><strong>PS:</strong> Neither gcc not clang complain, even when compiled+run with <code>-Wall</code> and <code>-g</code>.</p>\n<p><strong>EDIT 2:</strong> The discussion focuses on array indexing. The real code actually uses <code>std::list</code> and a fragment would look like this:</p>\n<pre><code>std::list&lt;int&gt; l;\n// the list contains something or not, don't know yet\nconst int&amp; i(*l.begin());\nif(!l.empty()) /* use i here */ ;\n</code></pre>\n<p><strong>EDIT 3:</strong> Legal solution to what I was doing is to use iterator:</p>\n<pre><code>std::list&lt;int&gt; l;\nconst std::list&lt;int&gt;::iterator I(l.begin()); // if empty, I==l.end()\nif(!l.empty()) /* use (*I) here */ ;\n</code></pre>\n", "AcceptedAnswerId": "17122450", "Title": "Is it legal to initialize a possibly invalid reference without using it?", "CreationDate": "2013-06-15T08:49:37.530", "Id": "17121822", "CommentCount": "2", "LastEditDate": "2013-06-16T07:29:48.030", "PostTypeId": "1", "LastEditorUserId": "761090", "LastActivityDate": "2013-06-18T15:35:59.010", "Score": "1", "OwnerUserId": "761090", "Tags": "<c++><c++11><reference>", "AnswerCount": "3"}, "17121906": {"Id": "17121906", "PostTypeId": "2", "Body": "<p>No it's <strong>not</strong> legal. You are reading data out of bounds from the vector in the declaration of <code>n</code> and therefore your program have undefined behavior.</p>\n", "LastActivityDate": "2013-06-15T08:58:53.433", "CommentCount": "2", "CreationDate": "2013-06-15T08:58:53.433", "ParentId": "17121822", "Score": "3", "OwnerUserId": "440558"}, "17121909": {"Id": "17121909", "PostTypeId": "2", "Body": "<p>I'd be surprised if this is \"allowed\" by the specification. However, what it does is store the address of an element that is outside the range of its allocation, which shouldn't in itself cause a problem in most cases - in extreme cases, it may overflow the pointer type, which could cause problems, I suppose. </p>\n<p>In other words, if <code>i</code> is WAY outside the size of <code>nn</code>, it could be a problem, not necessarily saying <code>i</code> has to be enormous - if each element in the vector is several megabytes (or gigabytes in a 64-bit machine), you can quite quickly run into problems with address range. </p>\n<p>But don't ask me to quote the specification - someone else will probably do that. </p>\n<p>Edit: As per comment, since you are requesting the address of a value outside of the valid size, at least in debug builds, this may well cause the <code>vector</code> implementation to assert or otherwise \"warn you that this is wrong\". </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2013-06-15T09:31:51.003", "Score": "0", "CreationDate": "2013-06-15T08:59:28.520", "ParentId": "17121822", "CommentCount": "3", "OwnerUserId": "1919155", "LastEditDate": "2013-06-15T09:31:51.003"}, "bq_ids": {"n4140": {"so_17121822_17122450_0": {"length": 6, "quality": 1.0, "section_id": 3222}}, "n3337": {"so_17121822_17122450_0": {"length": 6, "quality": 1.0, "section_id": 3096}}, "n4659": {"so_17121822_17122450_0": {"length": 6, "quality": 1.0, "section_id": 3979}}}, "17122450": {"Id": "17122450", "PostTypeId": "2", "Body": "<p>No, for two reasons:</p>\n<ol>\n<li><p>The standard states (8.3.2):</p>\n<blockquote>\n<p id=\"so_17121822_17122450_0\">A reference shall be initialized to refer to a valid object or function</p>\n</blockquote></li>\n<li><p><code>std::vector::operator[]</code> guarantees that even if <code>N</code> exceeds the container size, the function never throws exceptions (no-throw guarantee, no bounds checking other than <code>at()</code>). However, in that case, the behavior is undefined.</p></li>\n</ol>\n<p>Therefore, your program is not well-formed (bullet point 1) and invoke undefined behaviour (bullet point 2).</p>\n", "LastEditorUserId": "87234", "LastActivityDate": "2013-06-18T15:35:59.010", "Score": "0", "CreationDate": "2013-06-15T10:07:42.907", "ParentId": "17121822", "CommentCount": "8", "OwnerUserId": "572743", "LastEditDate": "2013-06-18T15:35:59.010"}});