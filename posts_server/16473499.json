post_cb({"16473499": {"CommentCount": "0", "ViewCount": "409", "PostTypeId": "1", "LastEditorUserId": "525217", "CreationDate": "2013-05-10T00:48:18.597", "LastActivityDate": "2013-05-10T02:21:46.753", "Title": "Specializing a base class' member function in a derived class template", "AcceptedAnswerId": "16473692", "LastEditDate": "2013-05-10T01:10:37.470", "Id": "16473499", "Score": "1", "Body": "<p>Have a look at this code:</p>\n<pre><code>struct foo {\n    virtual int bleh() {\n        return 42;\n    }\n};\n\n\ntemplate&lt;typename T&gt;\nstruct bar : public foo {\n\n};\n\n// ERROR\ntemplate&lt;&gt;\nint bar&lt;char&gt;::bleh() {\n    return 12;\n}\n</code></pre>\n<p>I'm trying to provide a definition of <code>base::bleh</code> only for <code>bar&lt;char&gt;</code>, but the compiler(gcc 4.7.2) <a href=\"http://ideone.com/WDs8CS\" rel=\"nofollow\">rejects</a> my code with the following diagnostic:</p>\n<pre><code>template-id \u2018bleh&lt;&gt;\u2019 for \u2018int bar&lt;char&gt;::bleh()\u2019 does not match any template declaration\n</code></pre>\n<p>It seems like <code>base::bleh</code> is somehow hidden in <code>bar</code>. I've fixed this using the following definition in <code>bar</code>:</p>\n<pre><code>template&lt;typename T&gt;\nstruct bar : public foo {\n    // doesn't work\n    //using foo::bleh; \n\n    // this works\n    int bleh() {\n        return foo::bleh();\n    }\n};\n</code></pre>\n<p>But I'm curious as of why this fails to compile. Why is the compiler rejecting my code?</p>\n", "Tags": "<c++><templates><specialization>", "OwnerUserId": "525217", "AnswerCount": "1"}, "16473692": {"ParentId": "16473499", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-10T01:15:34.863", "Score": "3", "LastEditorUserId": "649233", "LastEditDate": "2013-05-10T02:21:46.753", "Id": "16473692", "OwnerUserId": "649233", "Body": "<p>In your non-compiling example, you're attempting to specialize and define a function that hasn't been declared in the template definition of <code>bar</code> ... In your later example you have actually declared as well as defined the non-specialized version of the function inside the template definition of <code>bar</code>, which is why it compiles.  From what I can tell, here is the associated language in the standard concerning why the first version won't compile (14.7.3/4):</p>\n<blockquote>\n<p id=\"so_16473499_16473692_0\">A member function, a member function template, a member class, a\n  member enumeration, a member class template, or a static data member\n  of a class template may be explicitly specialized for a class\n  specialization that is implicitly instantiated; in this case, the\n  definition of the class template shall precede the explicit\n  specialization for the member of the class template</p>\n</blockquote>\n", "LastActivityDate": "2013-05-10T02:21:46.753"}, "bq_ids": {"n4140": {"so_16473499_16473692_0": {"section_id": 266, "quality": 1.0, "length": 34}}, "n3337": {"so_16473499_16473692_0": {"section_id": 257, "quality": 1.0, "length": 34}}, "n4659": {"so_16473499_16473692_0": {"section_id": 273, "quality": 1.0, "length": 34}}}});