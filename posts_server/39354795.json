post_cb({"bq_ids": {"n4140": {"so_39354795_39354911_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 5959}, "so_39354795_39354911_0": {"length": 10, "quality": 1.0, "section_id": 5959}, "so_39354795_39354911_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5959}}, "n3337": {"so_39354795_39354911_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 5728}, "so_39354795_39354911_0": {"length": 10, "quality": 1.0, "section_id": 5728}, "so_39354795_39354911_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5728}}, "n4659": {"so_39354795_39354911_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7440}, "so_39354795_39354911_0": {"length": 10, "quality": 1.0, "section_id": 7440}, "so_39354795_39354911_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 7440}}}, "39354795": {"ViewCount": "662", "Body": "<p>I have compilers that disagree on sizeof.  For the following code, Clang and GCC will compile it, but other compilers that I have to use fail claiming \"illegal sizeof operand\".  My reading of the standard says this is illegal, since <code>sizeof</code> can only take an expression (I don't think that S::a is an expression) or a type-id, but it is unusual for GCC and Clang to both be wrong.  I can obviously replace it with <code>sizeof(S().a)</code>, which works with all my compilers.</p>\n<pre><code>struct S\n{\n   int a[32];\n   int b;\n   int c;\n   int d[32];\n};\n\nint main()\n{\n   return sizeof(S::a);\n}\n</code></pre>\n<p>Are Clang and GCC wrong, or am I misreading the standard?</p>\n", "AcceptedAnswerId": "39354911", "Title": "Clang and GCC accept questionable sizeof", "CreationDate": "2016-09-06T17:33:49.130", "Id": "39354795", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-09-06T20:53:46.270", "Score": "18", "OwnerUserId": "2012007", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "39354911": {"Id": "39354911", "PostTypeId": "2", "Body": "<p>\u00a7 5.1.1 [expr.prim.general] 13</p>\n<blockquote>\n<p id=\"so_39354795_39354911_0\">An id-expression that denotes a non-static data member or non-static member function of a class can only be used:</p>\n<p id=\"so_39354795_39354911_1\">\u2014 as part of a class member access (5.2.5) in which the object expression refers to the member\u2019s class[63] or a class derived from that class, or</p>\n<p id=\"so_39354795_39354911_2\">\u2014 to form a pointer to member (5.3.1), or</p>\n<p id=\"so_39354795_39354911_3\">\u2014 if that id-expression denotes a non-static data member and it appears in an unevaluated operand\n  <em>[Example:</em></p>\n<pre><code>struct S {\n    int m;\n};\n\nint i = sizeof(S::m);      // OK\nint j = sizeof(S::m + 42); // OK\n</code></pre>\n<p id=\"so_39354795_39354911_4\"><em>-end example]</em></p>\n</blockquote>\n<p>Edit:\nAs @Praetorian points out in comments to the question itself: This was introduced in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html\">C++11</a></p>\n", "LastEditorUserId": "257645", "LastActivityDate": "2016-09-06T20:53:46.270", "Score": "26", "CreationDate": "2016-09-06T17:41:24.873", "ParentId": "39354795", "CommentCount": "0", "OwnerUserId": "257645", "LastEditDate": "2016-09-06T20:53:46.270"}});