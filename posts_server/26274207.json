post_cb({"26274207": {"CommentCount": "8", "CreationDate": "2014-10-09T08:52:49.497", "PostTypeId": "1", "AcceptedAnswerId": "26274688", "LastEditorUserId": "2756719", "LastActivityDate": "2016-01-13T10:05:23.113", "LastEditDate": "2016-01-13T10:05:23.113", "ViewCount": "566", "FavoriteCount": "1", "Title": "gcc can compile a variadic template while clang cannot", "Id": "26274207", "Score": "8", "Body": "<p>I'm reading some slides named <a href=\"https://github.com/CppCon/CppCon2014/tree/master/Presentations/An%20Overview%20of%20C%2B%2B11%20and%20C%2B%2B14\" rel=\"nofollow\">An Overview of C++11 and C++14</a> presented by Mr. Leor Zolman. At Page 35 he introduces a way to do the sum operation with <code>decltype</code>.</p>\n<pre><code>struct Sum {\n  template &lt;typename T&gt;\n  static T sum(T n) {\n    return n;\n  }\n  template &lt;typename T, typename... Args&gt;\n  /// static T sum(T n, Args... rest) {\n  static auto sum(T n, Args... rest) -&gt; decltype(n + sum(rest...)) {\n    return n + sum(rest...);\n  }\n};\n</code></pre>\n<p>When using this snippets for<code>Sum::sum(1, 2.3, 4, 5);</code> clang-3.6(from svn) fails to compile this with <code>-std=c++11</code>/<code>-std=c++1y</code> but gcc-4.9 succeeds. Of course without type deduction for the return type both compile, but that involves type conversion and cannot get the expected result. </p>\n<p>So does this indicate a clang bug, or is because of a gcc extension(in respect of c++11 or c++14)?</p>\n", "Tags": "<c++><templates><c++11><gcc><clang>", "OwnerUserId": "528929", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26274207_26274688_0": {"section_id": 7049, "quality": 0.875, "length": 14}, "so_26274207_26274688_3": {"section_id": 7070, "quality": 0.967741935483871, "length": 30}, "so_26274207_26274688_2": {"section_id": 7070, "quality": 0.875, "length": 7}, "so_26274207_26274688_1": {"section_id": 7054, "quality": 1.0, "length": 12}}, "n3337": {"so_26274207_26274688_0": {"section_id": 6794, "quality": 0.875, "length": 14}, "so_26274207_26274688_3": {"section_id": 6814, "quality": 0.8709677419354839, "length": 27}, "so_26274207_26274688_2": {"section_id": 6814, "quality": 0.875, "length": 7}, "so_26274207_26274688_1": {"section_id": 6798, "quality": 1.0, "length": 12}}, "n4659": {"so_26274207_26274688_0": {"section_id": 8546, "quality": 0.875, "length": 14}, "so_26274207_26274688_3": {"section_id": 8567, "quality": 0.9354838709677419, "length": 29}, "so_26274207_26274688_1": {"section_id": 8551, "quality": 1.0, "length": 12}}}, "26274688": {"ParentId": "26274207", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Clang's behavior is correct. This is a GCC bug (and the claim in the presentation is also incorrect). \u00a73.3.2 [basic.scope.pdecl]/p1,6:</p>\n<blockquote>\n<p id=\"so_26274207_26274688_0\">1 The <em>point of declaration</em> for a name is immediately after its\n  complete declarator (Clause 8) and before its <em>initializer</em> (if any),\n  except as noted below.</p>\n<p id=\"so_26274207_26274688_1\">6 After the point of declaration of a class member, the member name can\n  be looked up in the scope of its class.</p>\n</blockquote>\n<p>And \u00a73.3.7 [basic.scope.class]/p1 says</p>\n<blockquote>\n<p id=\"so_26274207_26274688_2\">The following rules describe the scope of names declared in classes.</p>\n<p id=\"so_26274207_26274688_3\">1) The potential scope of a name declared in a class consists not only\n  of the declarative region following the name\u2019s point of declaration,\n  but also of all function bodies, default arguments,\n  <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> of\n  non-static data members in that class (including such things in nested\n  classes).</p>\n</blockquote>\n<p><em>trailing-return-types</em> are not in that list.</p>\n<p>The trailing return type is part of the declarator (\u00a78 [dcl.decl]/p4):</p>\n<pre><code>declarator:\n    ptr-declarator\n    noptr-declarator parameters-and-qualifiers trailing-return-type\n</code></pre>\n<p>and so the variadic version of <code>sum</code> isn't in scope within its own <em>trailing-return-type</em> and cannot be found by name lookup.</p>\n<p>In C++14, simply use actual return type deduction (and omit the trailing return type). In C++11, you may use a class template instead and a function template that simply forwards:</p>\n<pre><code>template&lt;class T, class... Args&gt;\nstruct Sum {\n    static auto sum(T n, Args... rest) -&gt; decltype(n + Sum&lt;Args...&gt;::sum(rest...)) {\n        return n + Sum&lt;Args...&gt;::sum(rest...);\n    }\n};\n\ntemplate&lt;class T&gt;\nstruct Sum&lt;T&gt;{\n    static T sum(T n) { return n; }\n};\n\ntemplate&lt;class T, class... Args&gt;\nauto sum(T n, Args... rest) -&gt; decltype(Sum&lt;T, Args...&gt;::sum(n, rest...)){\n    return Sum&lt;T, Args...&gt;::sum(n, rest...);\n}\n</code></pre>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-10-09T09:35:31.277", "Id": "26274688", "Score": "10", "CreationDate": "2014-10-09T09:18:19.620", "LastActivityDate": "2014-10-09T09:35:31.277"}});