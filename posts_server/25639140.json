post_cb({"25639304": {"Id": "25639304", "PostTypeId": "2", "Body": "<p>According to the C++ Standard (12.4 Destructors)</p>\n<blockquote>\n<p id=\"so_25639140_25639304_0\">8 <strong>After executing the body of the destructor and destroying any\n  automatic objects allocated within the body</strong>, a destructor for class\n  X calls the destructors for X\u2019s direct non-variant non-static data\n  members, the destructors for X\u2019s direct base classes and, if X is the\n  type of the most derived class (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base classes.</p>\n</blockquote>\n<p>So your code is well-formed. All destructors of non-static data members and base classes are called after executing the body of the destructor.</p>\n", "LastActivityDate": "2014-09-03T08:06:22.513", "Score": "7", "CreationDate": "2014-09-03T08:06:22.513", "ParentId": "25639140", "CommentCount": "0", "OwnerUserId": "2877241"}, "25639442": {"Id": "25639442", "PostTypeId": "2", "Body": "<p>Inside the destructor the <code>this</code> pointer is well defined, as are all the members and bases (that will be destroyed in construction reverse order after the destructor return). So printing the address it refers is not UB.</p>\n<p>The only thing is that the object itself cannot be assumed anymore as \"polymorphic\", since the <em>derived</em> components had already been destroyed.</p>\n<pre><code>class A\n{\npublic:\n    virtual void fn() { std::cout &lt;&lt; \"A::fn\" &lt;&lt; std::endl; }\n    virtual ~A() { fn(); } //&lt; will call A::fn(), even if B is destroying\n};\n\nclass B: public A\n{\npublic:\n    virtual void fn() { std::cout &lt;&lt; \"B::fn\" &lt;&lt; std::endl; }\n    virtual ~B() {}    \n};\n\nint main()\n{\n    B b;\n    A&amp; a = b;\n    a.fn(); //&lt; will print B::fn(), being A::fn virtual and being B the runtime-type of the a's referred object\n    return 0; //&lt; will print A::fn() from b's A's component destructor\n}\n</code></pre>\n", "LastEditorUserId": "4928", "LastActivityDate": "2016-08-02T02:27:12.650", "Score": "0", "CreationDate": "2014-09-03T08:15:01.160", "ParentId": "25639140", "CommentCount": "0", "LastEditDate": "2016-08-02T02:27:12.650", "OwnerUserId": "924727"}, "25639140": {"ViewCount": "621", "Body": "<p>On the last line of a destructor, I have a diagnostic type message which takes a <code>printf</code>-like form:</p>\n<pre><code>\"object destroyed at %p\", this\n</code></pre>\n<p>I have concerns though about how well <code>this</code> is defined at such a point.</p>\n<p>Should I have such reservations? Is the behaviour well-defined?</p>\n", "AcceptedAnswerId": "25639304", "Title": "Validity of \"this\" in destructor", "CreationDate": "2014-09-03T07:56:56.480", "Id": "25639140", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-08-02T02:27:12.650", "Score": "6", "OwnerUserId": "3415258", "Tags": "<c++>", "AnswerCount": "5"}, "25639190": {"Id": "25639190", "PostTypeId": "2", "Body": "<p>Well, the pointer itself certainly still exists (it's just an address, after all). There should be no problem to print the pointer value.</p>\n<p>On the other hand, everything that you did in the destructor has already happened. Attributes may already have been <code>delete</code>'d, etc, so you have to avoid anything that accesses those.</p>\n", "LastActivityDate": "2014-09-03T08:00:10.257", "Score": "2", "CreationDate": "2014-09-03T08:00:10.257", "ParentId": "25639140", "CommentCount": "1", "OwnerUserId": "987792"}, "bq_ids": {"n4140": {"so_25639140_25639304_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 404}}, "n3337": {"so_25639140_25639304_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 395}}, "n4659": {"so_25639140_25639304_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 422}}}, "25639207": {"Id": "25639207", "PostTypeId": "2", "Body": "<p>As you might now, you can access your class members from the destructor. This would not be working if the <code>this</code> pointer was invalid. So you can safely assume that the address <code>this</code> points to is still the same that you might have printed in the constructor.</p>\n", "LastActivityDate": "2014-09-03T08:00:49.517", "Score": "0", "CreationDate": "2014-09-03T08:00:49.517", "ParentId": "25639140", "CommentCount": "0", "OwnerUserId": "3497050"}, "25639302": {"Id": "25639302", "PostTypeId": "2", "Body": "<p>This has perfectly well defined behaviour.  Consider that the <code>this</code> pointer can be used implicitly or explicitly throughout the destructor, e.g. whenever you access a member variable for things like <code>delete ptr_;</code>.  <strong><em>After</em></strong> the destructor returns, the members are destroyed in reverse order of declaration/creation then the base destructors invoked.</p>\n", "LastActivityDate": "2014-09-03T08:06:17.267", "Score": "1", "CreationDate": "2014-09-03T08:06:17.267", "ParentId": "25639140", "CommentCount": "0", "OwnerUserId": "410767"}});