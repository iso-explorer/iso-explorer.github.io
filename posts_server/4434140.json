post_cb({"4690988": {"Id": "4690988", "PostTypeId": "2", "Body": "<p>I ran into this breaking change when I used GCC.  The compiler printed an error for code like this:</p>\n<pre><code>void foo(const unsigned long long &amp;i)\n{\n    unsigned int a[2] = {i &amp; 0xFFFFFFFF, i &gt;&gt; 32};\n}\n</code></pre>\n<blockquote>\n<p id=\"so_4434140_4690988_0\">In function <code>void foo(const long long unsigned int&amp;)</code>:</p>\n<p id=\"so_4434140_4690988_1\">error: narrowing conversion of <code>(((long long unsigned int)i) &amp; 4294967295ull)</code> from <code>long long unsigned int</code> to <code>unsigned int</code> inside { }</p>\n<p id=\"so_4434140_4690988_2\">error: narrowing conversion of <code>(((long long unsigned int)i) &gt;&gt; 32)</code> from <code>long long unsigned int</code> to <code>unsigned int</code> inside { }</p>\n</blockquote>\n<p>Fortunately, the error messages were straightforward and the fix was simple:</p>\n<pre><code>void foo(const unsigned long long &amp;i)\n{\n    unsigned int a[2] = {static_cast&lt;unsigned int&gt;(i &amp; 0xFFFFFFFF),\n            static_cast&lt;unsigned int&gt;(i &gt;&gt; 32)};\n}\n</code></pre>\n<p>The code was in an external library, with only two occurrences in one file.  I don't think the breaking change will affect much code.  Novices might <a href=\"https://stackoverflow.com/questions/4490111/have-narrowing-conversion-error-in-c-arm-from-android-ndk\" title=\"Have narrowing conversion error in C++ arm from Android NDK - Stack Overflow\">get</a> <a href=\"https://stackoverflow.com/questions/3719848/char-and-initializer-lists\" title=\"conversion - char and initializer lists - Stack Overflow\">confused,</a> though.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-01-14T12:25:07.177", "Score": "37", "CreationDate": "2011-01-14T12:25:07.177", "ParentId": "4434140", "CommentCount": "0", "OwnerUserId": "501771", "LastEditDate": "2017-05-23T11:47:25.103"}, "13212549": {"Id": "13212549", "PostTypeId": "2", "Body": "<p>A practical instance that I have encountered:</p>\n<pre><code>float x = 4.2; // an input argument\nfloat a[2] = {x-0.5, x+0.5};\n</code></pre>\n<p>The numeric literal is implicitly <code>double</code> which causes promotion.</p>\n", "LastActivityDate": "2012-11-03T19:13:02.353", "CommentCount": "2", "CreationDate": "2012-11-03T19:13:02.353", "ParentId": "4434140", "Score": "4", "OwnerUserId": "33208"}, "9837229": {"Id": "9837229", "PostTypeId": "2", "Body": "<p>Narrowing conversion errors interact badly with implicit integer promotion rules.</p>\n<p>I had an error with code which looked like</p>\n<pre><code>struct char_t {\n    char a;\n}\n\nvoid function(char c, char d) {\n    char_t a = { c+d };\n}\n</code></pre>\n<p>Which produces an narrowing conversion error (which is correct according to the standard). The reason is that <code>c</code> and <code>d</code> implicitly get promoted to <code>int</code> and the resulting <code>int</code> isn't allowed to be narrowed back to char in an initializer list.</p>\n<p>OTOH</p>\n<pre><code>void function(char c, char d) {\n    char a = c+d;\n}\n</code></pre>\n<p>is of course still fine (otherwise all hell would break loose). But surprisingly, even</p>\n<pre><code>template&lt;char c, char d&gt;\nvoid function() {\n    char_t a = { c+d };\n}\n</code></pre>\n<p>is ok and compiles without a warning if the sum of c and d is less than CHAR_MAX. I still think this is a defect in C++11, but the people there think otherwise - possibly because it isn't easy to fix without get rid of either implicit integer conversion (which is a relict from the past, when people wrote code like <code>char a=b*c/d</code> and expected it to work even if (b*c) &gt; CHAR_MAX) or narrowing conversion errors (which are possibly a good thing).</p>\n", "LastEditorUserId": "154980", "LastActivityDate": "2012-08-14T20:46:12.633", "Score": "4", "CreationDate": "2012-03-23T10:02:24.140", "ParentId": "4434140", "CommentCount": "1", "OwnerUserId": "154980", "LastEditDate": "2012-08-14T20:46:12.633"}, "10795894": {"Id": "10795894", "PostTypeId": "2", "Body": "<p>It looks like GCC-4.7 no longer gives errors for narrowing conversions, but warnings instead.</p>\n", "LastActivityDate": "2012-05-29T08:49:58.917", "CommentCount": "0", "CreationDate": "2012-05-29T08:49:58.917", "ParentId": "4434140", "Score": "1", "OwnerUserId": "70514"}, "44087345": {"Id": "44087345", "PostTypeId": "2", "Body": "<p>Try adding -Wno-narrowing to your CFLAGS, for example :</p>\n<pre><code>CFLAGS += -std=c++0x -Wno-narrowing\n</code></pre>\n", "LastActivityDate": "2017-05-20T14:56:13.363", "CommentCount": "0", "CreationDate": "2017-05-20T14:56:13.363", "ParentId": "4434140", "Score": "1", "OwnerUserId": "2034823"}, "bq_ids": {"n4140": {"so_4434140_4434140_0": {"length": 4, "quality": 1.0, "section_id": 3329}, "so_4434140_4690988_1": {"length": 9, "quality": 0.6, "section_id": 5341}, "so_4434140_4690988_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5341}, "so_4434140_4690988_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 1872}}, "n3337": {"so_4434140_4434140_0": {"length": 4, "quality": 1.0, "section_id": 3199}, "so_4434140_4690988_1": {"length": 9, "quality": 0.6, "section_id": 5138}, "so_4434140_4690988_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5138}, "so_4434140_4690988_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 1866}}, "n4659": {"so_4434140_4434140_0": {"length": 4, "quality": 1.0, "section_id": 4095}, "so_4434140_4690988_1": {"length": 9, "quality": 0.6, "section_id": 6762}, "so_4434140_4690988_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 6762}, "so_4434140_4690988_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 2044}}}, "4435027": {"Body": "<p>I wouldn't be all that surprised if somebody gets caught out by something like:</p>\n<pre><code>float ra[] = {0, CHAR_MAX, SHORT_MAX, INT_MAX, LONG_MAX};\n</code></pre>\n<p>(on my implementation, the last two don't produce the same result when converted back to int/long, hence are narrowing)</p>\n<p>I don't remember ever writing this, though. It's only useful if an approximation to the limits is useful for something.</p>\n<p>This seems at least vaguely plausible too:</p>\n<pre><code>void some_function(int val1, int val2) {\n    float asfloat[] = {val1, val2};    // not in C++0x\n    double asdouble[] = {val1, val2};  // not in C++0x\n    int asint[] = {val1, val2};        // OK\n    // now do something with the arrays\n}\n</code></pre>\n<p>but it isn't entirely convincing, because if I know I have exactly two values, why put them in arrays rather than just <code>float floatval1 = val1, floatval1 = val2;</code>? What's the motivation, though, why that should compile (and work, provided the loss of precision is within acceptable accuracy for the program), while <code>float asfloat[] = {val1, val2};</code> shouldn't? Either way I'm initializing two floats from two ints, it's just that in one case the two floats happen to be members of an aggregate.</p>\n<p>That seems particularly harsh in cases where a non-constant expression results in a narrowing conversion even though (on a particular implementation), all values of the source type are representable in the destination type and convertible back to their original values:</p>\n<pre><code>char i = something();\nstatic_assert(CHAR_BIT == 8);\ndouble ra[] = {i}; // how is this worse than using a constant value?\n</code></pre>\n<p>Assuming there's no bug, presumably the fix is always to make the conversion explicit. Unless you're doing something odd with macros, I think an array initializer only appears close to the type of the array, or at least to something representing the type, which could be dependent on a template parameter. So a cast should be easy, if verbose.</p>\n", "CreationDate": "2010-12-14T01:07:53.290", "ParentId": "4434140", "CommentCount": "1", "LastEditDate": "2010-12-14T01:48:55.470", "Id": "4435027", "PostTypeId": "2", "LastActivityDate": "2010-12-14T01:48:55.470", "LastEditorUserId": "13005", "CommunityOwnedDate": "2010-12-14T01:07:53.290", "Score": "7", "OwnerUserId": "13005"}, "4434140": {"ViewCount": "53976", "Body": "<p>C++0x is going to make the following code and similar code ill-formed, because it requires a so-called <em>narrowing conversion</em> of a <code>double</code> to a <code>int</code>. </p>\n<pre><code>int a[] = { 1.0 };\n</code></pre>\n<p>I'm wondering whether this kind of initialization is used much in real world code. How many code will be broken by this change? Is it much effort to fix this in your code, if your code is affected at all?</p>\n<hr>\n<p>For reference, see 8.5.4/6 of n3225</p>\n<blockquote>\n<p id=\"so_4434140_4434140_0\">A narrowing conversion is an implicit conversion</p>\n<ul>\n<li>from a floating-point type to an integer type, or</li>\n<li>from long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented (even if it cannot be represented exactly), or</li>\n<li>from an integer type or unscoped enumeration type to a \ufb02oating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type, or</li>\n<li>from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type.</li>\n</ul>\n</blockquote>\n</hr>", "AcceptedAnswerId": "4690988", "Title": "Narrowing conversions in C++0x. Is it just me, or does this sound like a breaking change?", "CreationDate": "2010-12-13T22:33:18.553", "Id": "4434140", "CommentCount": "15", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2011-10-03T13:14:42.680", "LastEditorUserId": "34509", "LastActivityDate": "2017-05-20T14:56:13.363", "Score": "72", "OwnerUserId": "34509", "Tags": "<c++><c++11><survey><aggregate-initialization>", "AnswerCount": "7"}, "4434258": {"Id": "4434258", "PostTypeId": "2", "Body": "<p>I would be surprised and disappointed in myself to learn that any of the C++ code I wrote in the last 12 years had this sort of problem.  But most compilers would have spewed warnings about any compile-time \"narrowings\" all along, unless I'm missing something.</p>\n<p>Are these also narrowing conversions?</p>\n<pre><code>unsigned short b[] = { -1, INT_MAX };\n</code></pre>\n<p>If so, I think they might come up a bit more often than your floating-type to integral-type example.</p>\n", "LastActivityDate": "2010-12-13T22:49:13.927", "CommentCount": "1", "CreationDate": "2010-12-13T22:49:13.927", "ParentId": "4434140", "Score": "8", "OwnerUserId": "459640"}});