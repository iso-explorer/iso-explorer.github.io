post_cb({"2838143": {"Id": "2838143", "PostTypeId": "2", "Body": "<p>8.5.1/12 \"Aggregates\" says:</p>\n<blockquote>\n<p id=\"so_2838107_2838143_0\">All implicit type conversions (clause 4) are considered when initializing the aggregate member with an initializer from an initializer-list.</p>\n</blockquote>\n<p>So </p>\n<pre><code>A a = {0};\n</code></pre>\n<p>will get initialized with a NULL <code>char*</code> (as <a href=\"https://stackoverflow.com/questions/2838107/initialising-structs-in-c/2838133#2838133\">AndreyT</a> and <a href=\"https://stackoverflow.com/questions/2838107/initialising-structs-in-c/2838120#2838120\">Johannes</a> indicated), and </p>\n<pre><code>A a = {42};\n</code></pre>\n<p>will fail at compile time since there's no implicit conversion that'll match up with a <code>std::string</code> constructor.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-05-14T22:53:27.587", "Score": "8", "CreationDate": "2010-05-14T22:53:27.587", "ParentId": "2838107", "CommentCount": "0", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T12:18:35.920"}, "2838107": {"ViewCount": "7103", "Body": "<p>As an addendum to <a href=\"https://stackoverflow.com/questions/2837854/initializing-an-object-to-all-zeroes\">this question</a>, what is going on here:</p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n\nstruct A {\n    string s;\n};\n\nint main() {\n    A a = {0};\n}\n</code></pre>\n<p>Obviously, you can't set a std::string to zero. Can someone provide an explanation (backed with references to the C++ Standard, please) about what is actually supposed to happen here? And then explain for example):</p>\n<pre><code>int main() {\n    A a = {42};\n}\n</code></pre>\n<p>Are either of these well-defined? </p>\n<p>Once again an embarrassing question for me - I always give my structs constructors, so the issue has never arisen before.</p>\n", "AcceptedAnswerId": "2838133", "Title": "Initializing structs in C++", "CreationDate": "2010-05-14T22:45:49.493", "LastActivityDate": "2010-05-15T06:02:53.900", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:35.920", "OwnerDisplayName": "anon", "LastEditorUserId": "-1", "Id": "2838107", "Score": "28", "Tags": "<c++><struct>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_2838107_2838143_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 3309}, "so_2838107_2838701_5": {"length": 11, "quality": 0.5238095238095238, "section_id": 3294}, "so_2838107_2838701_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 3298}, "so_2838107_2838701_1": {"length": 12, "quality": 1.0, "section_id": 39}}, "n3337": {"so_2838107_2838143_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 3179}, "so_2838107_2838701_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 36}, "so_2838107_2838701_5": {"length": 11, "quality": 0.5238095238095238, "section_id": 3164}, "so_2838107_2838701_1": {"length": 12, "quality": 1.0, "section_id": 36}, "so_2838107_2838701_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 3168}}, "n4659": {"so_2838107_2838143_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 4075}, "so_2838107_2838701_5": {"length": 11, "quality": 0.5238095238095238, "section_id": 4056}, "so_2838107_2838701_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 4063}, "so_2838107_2838701_1": {"length": 12, "quality": 1.0, "section_id": 39}}}, "2838312": {"Id": "2838312", "PostTypeId": "2", "Body": "<p>In 21.3.1/9 the standard forbids the <code>char*</code> argument of the relevant constructor of a <code>std::basic_string</code> from being a null pointer. This should throw a <code>std::logic_error</code>, but I have yet to see where in the standard is the guarantee that violating a precondition throws a <code>std::logic_error</code>.</p>\n", "LastActivityDate": "2010-05-14T23:49:05.433", "CommentCount": "2", "CreationDate": "2010-05-14T23:49:05.433", "ParentId": "2838107", "Score": "1", "OwnerUserId": "456"}, "2838701": {"Id": "2838701", "PostTypeId": "2", "Body": "<p><strong>0 is a null pointer constant</strong></p>\n<p>S.4.9: </p>\n<blockquote>\n<p id=\"so_2838107_2838701_0\">A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to\n  zero. </p>\n</blockquote>\n<p><strong>A null pointer constant can be converted to any other pointer type:</strong></p>\n<p>S.4.9:</p>\n<blockquote>\n<p id=\"so_2838107_2838701_1\">A null pointer constant can be converted to a pointer type; the result is the null pointer value of that\n  type</p>\n</blockquote>\n<p><strong>What you gave for the definition of <code>A</code> is considered an aggregate:</strong></p>\n<p>S.8.5.1:</p>\n<blockquote>\n<p id=\"so_2838107_2838701_2\">An aggregate is an array or a class with no user-declared constructors, no private or protected\n  non-static data members, no base classes, and no virtual functions.</p>\n</blockquote>\n<p><strong>You are specifying an initializer clause:</strong></p>\n<p>S.8.5.1:</p>\n<blockquote>\n<p id=\"so_2838107_2838701_3\">When an aggregate is initialized the initializer can contain an initializer-clause consisting of a brace enclosed,\n  comma-separated list of initializer-clauses for the members of the aggregate</p>\n</blockquote>\n<p><strong><code>A</code> contains a member of the aggregate of type <code>std::string</code>, and the initializer clause applies to it.</strong></p>\n<p><strong>Your aggregate is copy-initialized</strong></p>\n<blockquote>\n<p id=\"so_2838107_2838701_4\">When an aggregate (whether class or array) contains members of class type and is initialized by a brace enclosed\n  initializer-list, each such member is copy-initialized.</p>\n</blockquote>\n<p><strong>Copy initializing means that you have the equivalent to <code>std::string s = 0</code> or <code>std::string s = 42</code>;</strong></p>\n<p>S.8.5-12</p>\n<blockquote>\n<p id=\"so_2838107_2838701_5\">The initialization that occurs in argument passing, function return, throwing an exception (15.1), handling\n  an exception (15.3), and brace-enclosed initializer lists (8.5.1) is called copy-initialization and is equivalent\n  to the form T x = a;</p>\n</blockquote>\n<p><strong><code>std::string s = 42</code> will not compile because there is no implicit conversion, <code>std::string s = 0</code> will compile (because an implicit conversion exists) but results in undefined behavior.</strong> </p>\n<p><code>std::string</code>'s constructor for <code>const char*</code> is not defined as <code>explicit</code> which means you can do this:  <code>std::string s = 0</code></p>\n<p>Just to show that things are actually being copy-initialized, you could do this simple test:</p>\n<pre><code>class mystring\n{\npublic:\n\n  explicit mystring(const char* p){}\n};\n\nstruct A {\n  mystring s;\n};\n\n\nint main()\n{\n    //Won't compile because no implicit conversion exists from const char*\n    //But simply take off explicit above and everything compiles fine.\n    A a = {0};\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2010-05-15T02:40:42.850", "CommentCount": "0", "CreationDate": "2010-05-15T02:40:42.850", "ParentId": "2838107", "Score": "3", "OwnerUserId": "3153"}, "2838228": {"Body": "<p>As people have pointed out, this \"works\" because string has a constructor that can take 0 as a parameter. If we say:</p>\n<pre><code>#include &lt;map&gt;\nusing namespace std;\n\nstruct A {\n    map &lt;int,int&gt; m;\n};\n\nint main() {\n    A a = {0};\n}\n</code></pre>\n<p>then we get a compilation error, as the map class does not have such a constructor.</p>\n", "CreationDate": "2010-05-14T23:22:45.467", "ParentId": "2838107", "CommentCount": "5", "LastEditDate": "2010-05-14T23:43:07.470", "CommunityOwnedDate": "2010-05-14T23:23:06.277", "PostTypeId": "2", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastActivityDate": "2010-05-14T23:43:07.470", "Id": "2838228", "Score": "2"}, "2838133": {"Id": "2838133", "PostTypeId": "2", "Body": "<p>Your struct is an <em>aggregate</em>, so the ordinary rules for aggregate initialization work for it. The process is described in 8.5.1. Basically the whole 8.5.1 is dedicated to it, so I don't see the reason to copy the whole thing here. The general idea is virtually the same it was in C, just adapted to C++: you take an initializer from the right, you take a member from the left and you initialize the member with that initializer. According to 8.5/12, this shall be a <em>copy-initialization</em>.</p>\n<p>When you do</p>\n<pre><code>A a = { 0 };\n</code></pre>\n<p>you are basically copy-initializing <code>a.s</code> with <code>0</code>, i.e. for <code>a.s</code> it is semantically equivalent to</p>\n<pre><code>string s = 0;\n</code></pre>\n<p>The above compiles because <code>std::string</code> is convertible from a <code>const char *</code> pointer. (And it is undefined behavior, since null pointer is not a valid argument in this case.)</p>\n<p>Your <code>42</code> version will not compile for the very same reason the</p>\n<pre><code>string s = 42;\n</code></pre>\n<p>will not compile. <code>42</code> is not a null pointer constant, and <code>std::string</code> has no means for conversion from <code>int</code> type.</p>\n<p><strong>P.S.</strong> Just in case: note that the definition of <em>aggregate</em> in C++ is not recursive (as opposed to the definition of POD, for example). <code>std::string</code> is not an aggregate, but it doesn't change anything for your <code>A</code>. <code>A</code> is still an aggregate.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-05-15T06:02:53.900", "Score": "29", "CreationDate": "2010-05-14T22:50:53.360", "ParentId": "2838107", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2010-05-15T06:02:53.900"}});