post_cb({"24381006": {"ViewCount": "209", "Body": "<p>I've got a class <code>ByteArray</code> defined like this:</p>\n<pre><code>class ByteArray\n{\npublic:\n    explicit ByteArray( unsigned int uiSize = 0 );\n    explicit ByteArray( const char * ucSource );\n    ByteArray( const ByteArray &amp; other );\n\n    ByteArray &amp; operator=( const char * ucSource );\n    ByteArray &amp; operator=( const ByteArray &amp; other );\n}\n</code></pre>\n<p>While almost everything works, constructing a <code>ByteArray</code> by assignment doesn't compile.</p>\n<pre><code>ByteArray ba1( 5 );     // works\nByteArray ba2( ba1 );   // works\nByteArray ba3( \"ABC\" ); // works\nByteArray ba4;          // works\nba4 = \"ABC\";            // works\nByteArray ba5 = \"ABC\";  // &lt;&lt;&lt;----- doesn't compile!\n</code></pre>\n<p>The compiler gives me a <em>Cannot convert 'const char *' to 'ByteArray'.</em><br>\nHowever, the \"assignment-constructor\" should be the same as the copy-constuktor, ie. the <code>ba5</code> line should compile just as the <code>ba3</code> line--- in contrast to the construction of <code>ba4</code> and subsequent assignment. So, I'm not quite sure what problem the compiler is having.</br></p>\n<p>I know that a solution would be to remove the <code>explicit</code> in front of the 3rd ctor. I would rather understand what's going on first, though...</p>\n<p>Edit:<br>\nThe answer states it nicely: <code>ByteArray ba5 = \"ABC\";</code> would get compiled as <code>ByteArray ba5( ByteArray(\"ABC\") );</code> --- NOT as <code>ByteArray ba5(\"ABC\");</code> as I thought it would. Obvious, but sometimes you need someone to point it out. Thanks everyone for your answers!</br></p>\n<p>Why use 'explicit' anyway? Because there is an ambiguity between <code>unsigned int</code> and <code>const char *</code>. If I call <code>ByteArray ba( 0 );</code> both ctors would be able to handle that, so I need to forbid the implicit conversion and make it <code>explicit</code>.</p>\n", "AcceptedAnswerId": "24381127", "Title": "ctor: Why does 'explicit' prevent assignment construction?", "CreationDate": "2014-06-24T07:40:59.917", "Id": "24381006", "CommentCount": "1", "LastEditDate": "2014-06-24T08:38:38.027", "PostTypeId": "1", "LastEditorUserId": "295002", "LastActivityDate": "2014-06-24T08:38:38.027", "Score": "5", "OwnerUserId": "295002", "Tags": "<c++><constructor>", "AnswerCount": "4"}, "24381467": {"Id": "24381467", "PostTypeId": "2", "Body": "<p>C++ has two types of initialization, copy initialization and\ndirect initialization.  In the case of copy initialization, the\nformal rules say that the copy constructor should be used; if\nthe expression doesn't have the correct type, it will be\nconverted.  (The compiler is allowed to elide the extra copy,\nbut it still must ensure that the code is legal without the\neliding.)  The initialization signaled by an <code>=</code> sign (which in\nthis case is <em>not</em> the assignment operator) uses copy\ninitialization, as does passing a parameter or returning\na value, or throwing or catching an exception.  The \ninitialization which is marked by parentheses or braces (in\nC++11) is direct initialization, as is the initialization in\na <code>new</code> expression, base and member initialization, and the\nvarious explicit conversions (<code>static_cast</code>, etc.).</p>\n<p>For actual assignment, of course, the rules are those of\na function call (which is what it is\u2014no new variable is\nconstructed).  In your case, <code>ba4 = \"ABC\";</code> works because you\nhave an assignment operator which takes a <code>char const*</code>; no\nimplicit conversion is necessary.</p>\n<p>(And while I'm at it: I'd avoid <code>explicit</code> on a copy\nconstructor.  I'm not sure exactly what it means, and I'm not\nsure that anyone else is either\u2014the purpose of <code>explicit</code>\nis to prevent the constructor from being used in implicit\nconversions, and of course, the copy constructor can't be used\nin any conversions anyway.)</p>\n", "LastActivityDate": "2014-06-24T08:10:03.237", "CommentCount": "0", "CreationDate": "2014-06-24T08:10:03.237", "ParentId": "24381006", "Score": "1", "OwnerUserId": "649665"}, "24381110": {"Id": "24381110", "PostTypeId": "2", "Body": "<p>If you don't use explicit keyword, compiler is allowed to convert initialization using <code>=</code> (copy initialization) into initialization using constructor. But sometimes you don't want this behavior and thus you use <code>explicit</code> keyword to avoid this conversion. So you are actually getting the intended result.</p>\n<p>Some examples that can be restricted with explicit constructor are</p>\n<pre><code>explicit T(const other_type &amp;other);\nT object = other;\nf(other); // if f recieves object by value\nreturn other;  // if function returns object by value\ncatch ( T other);\nT array [ N ] = { other };\n</code></pre>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2014-06-24T08:01:13.367", "Score": "2", "CreationDate": "2014-06-24T07:46:59.653", "ParentId": "24381006", "CommentCount": "4", "OwnerUserId": "2659313", "LastEditDate": "2014-06-24T08:01:13.367"}, "bq_ids": {"n4140": {"so_24381006_24381472_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}}, "n3337": {"so_24381006_24381472_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}}, "n4659": {"so_24381006_24381472_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}}}, "24381472": {"Id": "24381472", "PostTypeId": "2", "Body": "<p>C++11 12.3.1/2 \"Conversion by constructor\" says:</p>\n<blockquote>\n<p id=\"so_24381006_24381472_0\">An explicit constructor constructs objects just like non-explicit constructors, but <strong>does so only</strong> where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote>\n<p>The form:</p>\n<pre><code>ByteArray ba5 = \"ABC\";\n</code></pre>\n<p>Is copy-initialization (per 8.5/14), not direct-initialization (<code>ByteArray ba3( \"ABC\" )</code>) (per 8.5/15), so an explicit constructor cannot be used.</p>\n", "LastEditorUserId": "12711", "LastActivityDate": "2014-06-24T08:15:51.417", "Score": "2", "CreationDate": "2014-06-24T08:10:12.260", "ParentId": "24381006", "CommentCount": "0", "OwnerUserId": "12711", "LastEditDate": "2014-06-24T08:15:51.417"}, "24381127": {"Id": "24381127", "PostTypeId": "2", "Body": "<p><code>ByteArray ba5 = \"ABC\";</code> is copy initialization, not assignment.</p>\n<p>Think of it as</p>\n<pre><code>ByteArray ba5(ByteArray(\"ABC\"));\n</code></pre>\n<p>or at least that's what the compiler sees. It's illegal in your case because of the <code>explicit</code> property of the constructor - the compiler wants to use that conversion constructor to perform copy initialization, but it can't because you didn't explicitly use it.</p>\n", "LastActivityDate": "2014-06-24T07:47:40.567", "CommentCount": "1", "CreationDate": "2014-06-24T07:47:40.567", "ParentId": "24381006", "Score": "9", "OwnerUserId": "673730"}});