post_cb({"bq_ids": {"n4140": {"so_46628553_46628630_1": {"section_id": 481, "quality": 1.0, "length": 35}, "so_46628553_46628630_3": {"section_id": 481, "quality": 0.82, "length": 41}, "so_46628553_46628630_2": {"section_id": 480, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_46628553_46628630_1": {"section_id": 472, "quality": 0.9142857142857143, "length": 32}, "so_46628553_46628630_3": {"section_id": 472, "quality": 1.0, "length": 50}, "so_46628553_46628630_2": {"section_id": 471, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_46628553_46628630_3": {"section_id": 504, "quality": 0.74, "length": 37}, "so_46628553_46628630_1": {"section_id": 504, "quality": 1.0, "length": 35}, "so_46628553_46628630_0": {"section_id": 504, "quality": 1.0, "length": 9}, "so_46628553_46628630_2": {"section_id": 502, "quality": 0.9428571428571428, "length": 33}}}, "46634980": {"ParentId": "46628553", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>StoryTeller didn't answer the question: Why is the move c'tor not called? (And not: Why is there no copy elision?)</p>\n<p>Here's my go: The move c'tor will be called if and only if:</p>\n<ul>\n<li>Copy elision (RVO) is not performed. Your use of the ternary operator is indeed a way to prevent copy elision. Let me point out though that <code>return (0, q);</code> is a simpler way to do this if you just want to return <code>q</code> while suppressing copy elision. This uses the (in-)famous comma operator. Possibly <code>return ((q));</code> might work, too, but I am not enough of a language lawyer to tell for sure.</li>\n<li>The argument to <code>return</code> is an rvalue. This could be a temporary (more precisely, a prvalue), but these are also eligible for copy elision. Therefore, the argument to <code>return</code> must be an xvalue, such as <code>std::move(q)</code> if you want to ensure the move c'tor is called.</li>\n</ul>\n<p>See also: <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">C++ value categories</a></p>\n<p>Some more technicalities of your example:</p>\n<ul>\n<li><code>q</code> and <code>e</code> are objects of type <code>Qwe</code>.</li>\n<li><code>q.x &gt; x ? q : e</code> is an lvalue expression of type <code>Qwe</code>. This is because the <em>expressions</em> <code>q</code> and <code>e</code> are lvalues of type <code>Qwe</code>. The ternary operator just selects either of them.</li>\n<li><code>std::move(q.x &gt; x ? q : e)</code> is an xvalue expression of type <code>Qwe</code>. The <code>std::move</code> simply turns (casts) the lvalue into an xvalue. As an aside, <code>q.x &gt; x ? std::move(q) : std::move(e)</code> would also work.</li>\n<li>The copy c'tor gets called in <code>return q.x &gt; x ? q : e;</code> because it can be called with an lvalue of type <code>Qwe</code> (constness is optional), while, on the other hand, the move c'tor cannot be called with an lvalue and is therefore eliminated from the candidate set.</li>\n</ul>\n<p>UPDATE: Addressing the comments by going into more depth\u2026 this is a really confusing aspect of C++!</p>\n<p>Conceptually, in C++98, returning an object by value meant returning a <em>copy</em> of the object, so the copy c'tor would be called. However, the standard's authors considered that a compiler should be free to perform an optimization such that this potentially expensive copy (e.g. of a container) could be elided under suitable circumstances.</p>\n<p>This copy elision means that, instead of creating the object in one place and then copying it to a memory address controlled by the caller, the callee creates the object directly in the memory controlled by the caller. Therefore, <em>only</em> the \"normal\" constructor, e.g. a default c'tor, is called.</p>\n<p>Therefore, they added a passage such that the compiler is <em>required</em> to check that the copy c'tor \u2014 whether generated or user-defined \u2013 exists and is accessible (there was no notion yet of deleted functions for that matter), and must ensure that the object is initialized <em>as-if</em> it had been first created in a different place and then copied (cf. as-if rule), but the compiler was not required to ensure that any <em>side effects</em> of the copy c'tor would be observable, such as the stream output in your example.</p>\n<p>The reason why the c'tor was still required to be there was that they wanted to avoid a scenario where a compiler was able to accept code that another would have to reject, simply because the former implemented an optional optimization that the latter did not.</p>\n<p>In C++11, move semantics were added, and the committee very much wanted to use this in such a manner that a lot of existing return-by-value functions e.g. involving strings or containers would become more efficient. This was done in such a way that conditions were given under which the compiler was actually required to perform a move instead of a copy. However, the idea of copy elision remained important, so basically there were now four different categories:</p>\n<ol>\n<li>The compiler is required to check for a usable (see above) move c'tor, but is allowed to elide it.</li>\n<li>The compiler is required to check for a usable move c'tor, and has to call it.</li>\n<li>The compiler is required to check for a usable copy c'tor, but is allowed to elide it.</li>\n<li>The compiler is required to check for a usable copy c'tor, and has to call it.</li>\n</ol>\n<p>\u2026 which in turn lead to four possible outcomes:</p>\n<ol>\n<li>Compiler checks for move c'tor, but then elides it. (relates to 1. above)</li>\n<li>Compiler checks for move c'tor and actually emits a call to it. (relates to 1. <em>or</em> 2. above)</li>\n<li>Compiler checks for copy c'tor, but then elides it. (relates to 3. above)</li>\n<li>Compiler checks for copy c'tor and actually emits a call to it. (relates to 3. <em>or</em> 4. above)</li>\n</ol>\n<p>And the long optimization story doesn't end here, because, in C++17, the compiler is <em>required</em> to elide certain c'tor calls. In these cases, the compiler is not even allowed to demand that a copy or move c'tor is available.</p>\n<p>Note that a compiler has always been free to elide even such c'tor calls that do not meet the standard requirements, under the protection of the as-if rule, for instance by function inlining and the following optimization steps. Anyway, a function call, conceptually, does not have to be backed by the actual machine instruction for the execution of a subroutine. The compiler is just not allowed to remove observable, otherwise defined behavior.</p>\n<p>By now you should have noticed that, at least prior to C++17, it is very well possible for the same well-formed program to behave differently, depending on the compiler used and even optimization settings, <em>if</em> the copy rsp. move constructor has observable side effects. Also, a compiler that implements copy/move elision may do so for a subset of the conditions under which the standard allows it to happen. This makes your question almost impossible to answer in detail. Why is the copy/move c'tor called here, but not there? Well, it may be because of the requirements of the C++ standard, but it also may be the preference of your compiler. Maybe the compiler authors had time and leisure implementing the one optimization but not the other. Maybe they found it too difficult in the latter case. Maybe they just had more important stuff to do. Who knows?</p>\n<p>What matters 99% of the time for me as a developer is to write my code in such a way that the compiler can apply the best optimizations. Sticking to common cases and standard practice is one thing. Knowing NRVO and RVO of temporaries is another thing, and writing the code such that the standard allows (or, in C++17, requires) copy/move elision, and ensuring that a move c'tor is available where it is beneficial (in case elision does not occur). Don't rely on side effects such as writing a log message or incrementing a global counter. These are <em>not</em> what a copy or move c'tor should commonly do anyway, except possibly for debugging or scholarly interest.</p>\n", "OwnerUserId": "4083309", "LastEditorUserId": "4083309", "LastEditDate": "2017-10-09T13:45:14.703", "Id": "46634980", "Score": "0", "CreationDate": "2017-10-08T19:04:49.437", "LastActivityDate": "2017-10-09T13:45:14.703"}, "46628630": {"ParentId": "46628553", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You did not write your function in a way that allows copy/move elision to occur. The requirements for a copy to be replaced by a move are as follows:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.copy.elision#3\" rel=\"noreferrer\">[class.copy.elision]/3</a>:</p>\n<blockquote>\n<p id=\"so_46628553_46628630_0\">In the following <em>copy-initialization</em> contexts, a move operation might\n  be used instead of a copy operation:</p>\n<ul>\n<li><strong>If the expression in a return statement is a (possibly parenthesized) <em>id-expression</em> that names an object with automatic\n  storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em></strong></li>\n</ul>\n<p id=\"so_46628553_46628630_1\">overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. If the first\n  overload resolution fails or was not performed, or if the type of the\n  first parameter of the selected constructor is not an rvalue reference\n  to the object's type (possibly cv-qualified), overload resolution is\n  performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>The above is from C++17, but the C++11 wording is pretty much the same. The conditional operator <strong>is not</strong> an id-expression that names an object in the scope of the function.</p>\n<p>An id-expression would be something like <code>q</code> or <code>e</code> in your particular case. You need to <em>name</em> an object in that scope. A conditional expression doesn't qualify as naming an object, so it must preform a copy.</p>\n<hr>\n<p>If you want to exercise your English comprehension abilities on a difficult wall of text, then this is how it's written in C++11. Takes some effort to see IMO, but it's the same as the clarified version above:</p>\n<blockquote>\n<p id=\"so_46628553_46628630_2\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the copy/move\n  constructor and/or destructor for the object have side effects. [...]\n  This elision of copy/move operations, called copy elision, is\n  permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other\n  than a function or catch-clause parameter) with the same\n  cv-unqualified type as the function return type, the copy/move\n  operation can be omitted by constructing the automatic object directly\n  into the function's return value</li>\n</ul>\n<p id=\"so_46628553_46628630_3\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue. If overload resolution\n  fails, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object's type (possibly\n  cv-qualified), overload resolution is performed again, considering the\n  object as an lvalue.</p>\n</blockquote>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-10-08T08:25:48.753", "Id": "46628630", "Score": "13", "CreationDate": "2017-10-08T07:39:43.157", "LastActivityDate": "2017-10-08T08:25:48.753"}, "46628553": {"CommentCount": "3", "ViewCount": "781", "PostTypeId": "1", "LastEditorUserId": "4584421", "CreationDate": "2017-10-08T07:29:26.157", "LastActivityDate": "2017-10-09T13:45:14.703", "Title": "Return by value copies instead of moving", "FavoriteCount": "4", "LastEditDate": "2017-10-08T18:39:51.390", "Id": "46628553", "Score": "14", "Body": "<p>Why does this program call the copy constructor instead of the move constructor?</p>\n<pre><code>class Qwe {\npublic:\n    int x=0;\n    Qwe(int x) : x(x){}\n    Qwe(const Qwe&amp; q) {\n        cout&lt;&lt;\"copy ctor\\n\";\n    }\n    Qwe(Qwe&amp;&amp; q) {\n        cout&lt;&lt;\"move ctor\\n\";\n    }    \n};\n\nQwe foo(int x) {\n    Qwe q=42;\n    Qwe e=32;\n    cout&lt;&lt;\"return!!!\\n\";\n    return q.x &gt; x ? q : e;\n}\n\nint main(void)\n{\n    Qwe r = foo(50);\n}\n</code></pre>\n<p>The result is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>return!!!\ncopy ctor\n</code></pre>\n<p><code>return q.x &gt; x ? q : e;</code> is used to disable nrvo. When I wrap it in <code>std::move</code>, it is indeed moved. But in \"A Tour of C++\" the author said that the move c'tor must be called when it available.</p>\n<p>What have I done wrong?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "8739906", "AnswerCount": "2"}});