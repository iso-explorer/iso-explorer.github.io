post_cb({"bq_ids": {"n4140": {"so_36133311_36133565_1": {"length": 36, "quality": 0.972972972972973, "section_id": 5811}}, "n3337": {"so_36133311_36133565_1": {"length": 31, "quality": 0.8378378378378378, "section_id": 5584}}, "n4659": {"so_36133311_36133565_1": {"length": 30, "quality": 0.8108108108108109, "section_id": 7272}}}, "36133311": {"ViewCount": "143", "Body": "<p>I am calling the factorial function defined in the following manner by reference. </p>\n<pre><code>int factorial(int &amp;n) {\n    n--;\n    if (n&gt;0) return factorial(n)*(n+1);\n    else return 1;\n}\n</code></pre>\n<p>when I pass the value 5 it returns the value 1 as I'd expected. But when I define the factorial function in the following way it returns the factorial of 5 that is 120.</p>\n<pre><code>int factorial(int &amp;n) {\n     n--;\n     if (n&gt;0) return (n+1)*factorial(n);\n     else return 1;\n}\n</code></pre>\n<p>I conjectured that the expression is evaluated in linear order and when a function is invoked in the expression all the values of local variables and the component expressions that have been evaluated so far in the original expression are stored and when the function returns control back to the caller these values  that are retained are used in computation of the expression and not their modified values. </p>\n<p>Is my hypothesis correct? Kindly enlighten me.  </p>\n", "AcceptedAnswerId": "36133565", "Title": "Why code is implemented differently on changing order in the assignment statement?", "CreationDate": "2016-03-21T14:11:27.140", "Id": "36133311", "CommentCount": "11", "LastEditDate": "2016-03-21T14:17:26.247", "PostTypeId": "1", "LastEditorUserId": "5657600", "LastActivityDate": "2016-03-21T14:29:13.057", "Score": "4", "OwnerUserId": "5657600", "Tags": "<c++><recursion>", "AnswerCount": "1"}, "36133565": {"Id": "36133565", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36133311_36133565_0\">I conjectured that the expression is evaluated in linear order [...]</p>\n</blockquote>\n<p>Yes and no. The order of evaluation is typically done in linear order (either first to last or last to first), but is unspecified. When you write <code>factorial(n)*(n+1)</code>, the compiler is allowed to evaluate <code>(n+1)</code> first or <code>factorial(n)</code> first. Different compilers will do it differently. Moreover, different versions of the same compiler could even change orderings, so that's not something you should ever rely on. The standardese is in <a href=\"http://eel.is/c++draft/intro.execution#15\" rel=\"nofollow\">[intro.execution]</a>:</p>\n<blockquote>\n<p id=\"so_36133311_36133565_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, and they are not potentially concurrent (1.10), <strong>the behavior is undefined.</strong></p>\n</blockquote>\n<p>(The exceptions are things like <code>&amp;&amp;</code>, <code>||</code>, <code>,</code>, and  <code>?:</code>)</p>\n<p>In this case, you can easily avoid relying on the order dependency completely by just removing the reference:</p>\n<pre><code>int factorial(int n) {\n    if (n&gt;0) return factorial(n-1)*(n);\n    else return 1;\n}\n</code></pre>\n<p>Now <code>factorial(n-1) * n</code> and <code>n * factorial(n-1)</code>, regardless of which order they're evaluated in, both work and give you the same correct answer. This also has the added benefit that nobody would expect <code>factorial</code> to actually modify its argument anyway:</p>\n<pre><code>int i = 6;\nint f = factorial(i);\n// now i is 1??\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-21T14:29:13.057", "Score": "10", "CreationDate": "2016-03-21T14:22:17.790", "ParentId": "36133311", "CommentCount": "8", "LastEditDate": "2016-03-21T14:29:13.057", "OwnerUserId": "2069064"}});