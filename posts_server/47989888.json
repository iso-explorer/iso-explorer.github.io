post_cb({"bq_ids": {"n4140": {"so_47989888_47989996_1": {"length": 17, "quality": 1.0, "section_id": 7008}, "so_47989888_47989996_0": {"length": 24, "quality": 0.96, "section_id": 7008}}, "n3337": {"so_47989888_47989996_1": {"length": 17, "quality": 1.0, "section_id": 6754}, "so_47989888_47989996_0": {"length": 24, "quality": 0.96, "section_id": 6754}}, "n4659": {"so_47989888_47989996_1": {"length": 17, "quality": 1.0, "section_id": 8505}, "so_47989888_47989996_0": {"length": 23, "quality": 0.92, "section_id": 8505}}}, "47989888": {"ViewCount": "38", "Body": "<p>I have a first class A that contain an iterator nested class with virtual methods:</p>\n<pre><code>template &lt;typename T &gt;\nclass A {\n  public:\n      class iterator {\n      public:\n          virtual ~iterator() {};\n          virtual T&amp; operator++();\n       };\n\n      virtual iterator begin() const = 0;\n};\n</code></pre>\n<p>I have a second class B, that override virtuals methods:</p>\n<pre><code>template &lt;typename T &gt;\nclass B : public A&lt;T&gt; {\n   public:\n      class iterator : A&lt;T&gt;::iterator {\n          T&amp; operator++() override { \n              iterator p(*this);\n              return p; //for exemple\n          }\n      };\n\n   iterator begin() const override {\n       return iterator(this);// for exemple \n   } \n};\n</code></pre>\n<p>But when i use B class :</p>\n<pre><code>B&lt;int&gt; test;\n</code></pre>\n<p>I have something like this, compilation error:</p>\n<pre><code>error: invalid covariant return type for 'B&lt;T&gt;::iterator B&lt;T&gt;::begin() const [with T = int]'\nerror:  overriding 'B&lt;T&gt;::iterator V&lt;T&gt;::begin() const [with T = int]'\n</code></pre>\n<p>How to implements iterator in B class ?</p>\n", "Title": "invalid covariant return type, nested class c++", "CreationDate": "2017-12-27T09:50:14.693", "LastActivityDate": "2017-12-27T11:01:22.930", "CommentCount": "2", "LastEditDate": "2017-12-27T10:01:38.887", "PostTypeId": "1", "LastEditorUserId": "3668037", "Id": "47989888", "Score": "3", "OwnerUserId": "8524880", "Tags": "<c++><virtual><covariance><covariant-return-types>", "AnswerCount": "1"}, "47989996": {"Id": "47989996", "PostTypeId": "2", "Body": "<p>Co-variant return types have a couple of constraints they need to satisfy according to <a href=\"http://eel.is/c++draft/class.virtual#8\" rel=\"nofollow noreferrer\">[class.virtual]/8</a>.</p>\n<blockquote>\n<p id=\"so_47989888_47989996_0\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or covariant with the\n  classes of the functions. If a function D\u200b::\u200bf overrides a function\n  B\u200b::\u200bf, the return types of the functions are covariant if they\n  satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes</li>\n<li><p id=\"so_47989888_47989996_1\">the class in the return type of B\u200b::\u200bf is the same class as the class in the return type of D\u200b::\u200bf, or is an unambiguous and\n  accessible direct or indirect base class of the class in the return\n  type of D\u200b::\u200bf</p></li>\n<li><p id=\"so_47989888_47989996_2\">[...]</p></li>\n</ul>\n</blockquote>\n<p>Yours doesn't inherit publicly, so the base isn't accessible. And you aren't returning a pointer or a reference.</p>\n<p>Returning a type with value semantics is good! You should not give up on that. You can substitute the attempt at a co-variant return type with the pimpl idiom. Have <code>iterator</code> manage a polymorphic \"iterator implementation\" class via pointer.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-27T11:01:22.930", "Score": "6", "CreationDate": "2017-12-27T09:57:13.883", "ParentId": "47989888", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-12-27T11:01:22.930"}});