post_cb({"bq_ids": {"n4140": {"so_472530_472530_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5439}, "so_472530_472530_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 3228}}, "n3337": {"so_472530_472530_1": {"length": 9, "quality": 0.75, "section_id": 5234}, "so_472530_472530_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}, "so_472530_472750_0": {"length": 27, "quality": 1.0, "section_id": 338}}, "n4659": {"so_472530_472530_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 6866}, "so_472530_472530_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 3985}}}, "472750": {"Body": "<p>Hmm, the Standard says in <code>14.8.2.4 / 15</code>:</p>\n<blockquote>\n<p id=\"so_472530_472750_0\">If, in the declaration of a function template with a non-type template-parameter, the non-type template-parameter is used in an expression in the function parameter-list and, if the corresponding template-argument is deduced, the template-argument type shall match the type of the template-parameter exactly, <em>except that a template-argument deduced from an array bound may be of any integral type.</em></p>\n</blockquote>\n<p>Providing this example:</p>\n<pre><code>template&lt;int i&gt; class A { /* ... */ };\ntemplate&lt;short s&gt; void f(A&lt;s&gt;);\nvoid k1() {\n    A&lt;1&gt; a;\n    f(a);    // error: deduction fails for conversion from int to short\n    f&lt;1&gt;(a); // OK\n}\n</code></pre>\n<p>That suggests that the compilers that fail to compile your code (apparently GCC and Digital Mars) do it wrong. I tested the code with Comeau, and it compiles your code fine. I don't think there is a different to whether the type of the non-type template parameter depends on the type of the type-parameter or not. <code>14.8.2.4/2</code> says the template arguments should be deduced independent from each other, and then combined into the type of the function-parameter. Combined with /15, which allows the type of the dimension to be of different integral type, i think your code is all fine. As always, i take the c++-is-complicated-so-i-may-be-wrong card :) </p>\n<p><strong>Update</strong>: I've looked into the passage in GCC where it spits out that error message:</p>\n<pre><code>  ...\n  type = TREE_TYPE (size);\n  /* The array bound must be an integer type.  */\n  if (!dependent_type_p (type) &amp;&amp; !INTEGRAL_TYPE_P (type))\n    {\n      if (name)\n    error (\"size of array %qD has non-integral type %qT\", name, type);\n      else\n    error (\"size of array has non-integral type %qT\", type);\n      size = integer_one_node;\n      type = TREE_TYPE (size);\n    }\n  ...\n</code></pre>\n<p>It seems to have missed to mark the type of the size as dependent in an earlier code block. As that type is a template parameter, it is a dependent type (see <code>14.6.2.1</code>).</p>\n<p><strong>Update:</strong> GCC developers fixed it: <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38950\" rel=\"noreferrer\">Bug #38950</a></p>\n", "CreationDate": "2009-01-23T12:46:56.620", "ParentId": "472530", "CommentCount": "7", "LastEditDate": "2009-02-18T17:16:55.540", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-02-18T17:16:55.540", "LastEditorUserId": "34509", "Id": "472750", "OwnerDisplayName": "litb", "Score": "13", "OwnerUserId": "34509"}, "472530": {"ViewCount": "10304", "Body": "<p>My compiler behaves oddly when I try to pass a fixed-size array to a template function. The code looks as follows:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\ntemplate &lt;typename TSize, TSize N&gt;\nvoid f(TSize (&amp; array)[N]) {\n    std::copy(array, array + N, std::ostream_iterator&lt;TSize&gt;(std::cout, \" \"));\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    int x[] = { 1, 2, 3, 4, 5 };\n    unsigned int y[] = { 1, 2, 3, 4, 5 };\n    f(x);\n    f(y); //line 15 (see the error message)\n}\n</code></pre>\n<p>It produces the following compile error in GCC 4.1.2:</p>\n<blockquote id=\"so_472530_472530_0\">\n<pre><code>test.cpp|15| error: size of array has non-integral type \u2018TSize\u2019\ntest.cpp|15| error: invalid initialization of reference of type\n  \u2018unsigned int (&amp;)[1]\u2019 from expression of type \u2018unsigned int [5]\u2019\ntest.cpp|6| error: in passing argument 1 of \u2018void f(TSize (&amp;)[N])\n  [with TSize = unsigned int, TSize N = ((TSize)5)]\u2019\n</code></pre>\n</blockquote>\n<p>Note that the first call compiles and succeeds. This seems to imply that while <code>int</code> is integral, <code>unsigned int</code> isn't.</p>\n<p>However, if I change the declaration of my above function template to</p>\n<pre><code>template &lt;typename TSize, unsigned int N&gt;\nvoid f(TSize (&amp; array)[N])\n</code></pre>\n<p>the problem just goes away! Notice that the only change here is from <code>TSize N</code> to <code>unsigned int N</code>.</p>\n<p>Section [<code>dcl.type.simple</code>] in the final draft ISO/IEC FDIS 14882:1998 seems to imply that an \"integral type\" is either signed or unsigned:</p>\n<blockquote>\n<p id=\"so_472530_472530_1\">The <code>signed</code> specifier forces <code>char</code> objects and bit-fields to be signed; it is redundant with other integral types.</p>\n</blockquote>\n<p>Regarding fixed-size array declarations, the draft says [<code>dcl.array</code>]:</p>\n<blockquote>\n<p id=\"so_472530_472530_2\">If the <em>constant-expression</em> (<code>expr.const</code>) is present, it shall be an integral constant expression and its value shall be greater than zero.</p>\n</blockquote>\n<p>So why does my code work with an explicit <code>unsigned</code> size type, with an inferred <code>signed</code> size type but not with an inferred <code>unsigned</code> size type?</p>\n<p><strong>EDIT</strong> Serge wants to know where I'd need the first version. First, this code example is obviously simplified. My real code is a bit more elaborate. The array is actually an array of indices/offsets in another array. <del>So, logically, the type of the array should be the same as its size type for maximum correctness.</del> Otherwise, I might get a type mismatch (e.g. between <code>unsigned int</code> and <code>std::size_t</code>). Admittedly, this shouldn't be a problem in practice since the compiler implicitly converts to the larger of the two types.</p>\n<p><strong>EDIT 2</strong> I stand corrected (thanks, litb): size and offset are of course logically different types, and offsets into C arrays in particular are of type <code>std::ptrdiff_t</code>.</p>\n", "AcceptedAnswerId": "472750", "Title": "How to pass an array size as a template with template type?", "CreationDate": "2009-01-23T10:56:19.043", "Id": "472530", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-12-17T12:23:45.823", "LastEditorDisplayName": "Konrad Rudolph", "OwnerDisplayName": "Konrad Rudolph", "LastEditorUserId": "415784", "LastActivityDate": "2012-12-17T12:23:45.823", "Score": "12", "OwnerUserId": "1968", "Tags": "<c++><arrays><templates><type-inference>", "AnswerCount": "1"}});