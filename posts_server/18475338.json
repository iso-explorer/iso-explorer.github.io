post_cb({"18475338": {"CommentCount": "4", "ViewCount": "127", "PostTypeId": "1", "LastEditorUserId": "1228", "CreationDate": "2013-08-27T20:57:12.213", "LastActivityDate": "2013-09-10T20:01:47.010", "Title": "Is this defined behavior? Store data as char array", "AcceptedAnswerId": "18475470", "LastEditDate": "2013-09-10T20:01:47.010", "Id": "18475338", "Score": "0", "Body": "<p>I was playing with an idea for dynamic size memory pool, and playing, I end up with some code that I was certain that will fail, but didn't. Here's the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct largeStruct\n{\n    largeStruct()\n    {\n        X = 123456789;\n        Y = 987654321;\n        str = \"Hy! Here I am, a c string, out in the wild c++, the place where your pointers dangle and your friends play with your privates\";\n    }\n    unsigned long long X;\n    unsigned long long Y;\n    char* str;\n};\n\nint main()\n{\n    void* ptr = new unsigned char[sizeof(largeStruct)];\n\n    largeStruct a;\n    *((largeStruct*)ptr) = a;\n\n    cout &lt;&lt; \"Size of data: \" &lt;&lt; sizeof(largeStruct) &lt;&lt; endl;\n    cout &lt;&lt; \"Data: \" &lt;&lt; endl;\n    cout &lt;&lt; ((largeStruct*)ptr)-&gt;X &lt;&lt; endl\n         &lt;&lt; ((largeStruct*)ptr)-&gt;Y &lt;&lt; endl\n         &lt;&lt; ((largeStruct*)ptr)-&gt;str &lt;&lt; endl\n         &lt;&lt; endl;\n\n    delete[] ptr;\n}\n</code></pre>\n<p>That works in my pc ( Windows 8, MSVC Express 2012). Putting some more though into it, i think that, while a hack, it makes some sense.\nA array in memory is like this:</p>\n<pre><code>===================================\n... ||  a0  ||  a1  ||  a2   || ...\n===================================\n</code></pre>\n<p>So when you try to store a values that is bigger than one of your array members, it access the memory on the side. So try to store a value of 3 chunks size will work, and end up as this:</p>\n<pre><code>====================================\n... || data  data  data  data || ...\n====================================\n</code></pre>\n<p>So, is this dangerous, or is some kind of obscure harmless hack?</p>\n", "Tags": "<c++><arrays><memory>", "OwnerUserId": "1739672", "AnswerCount": "1"}, "18475470": {"ParentId": "18475338", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2013-08-27T21:06:05.167", "Score": "4", "LastEditorUserId": "845092", "LastEditDate": "2013-08-27T21:49:50.880", "Id": "18475470", "OwnerUserId": "845092", "Body": "<blockquote>\n<p id=\"so_18475338_18475470_0\">\u00a7 3.8 ...any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways... using the pointer as if the pointer were of type void*,\n  is well-defined. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:<br>\n  \u2014 the pointer is used as the operand of a static_cast (5.2.9) (except when the conversion is to void*, or to void* and subsequently to char*, or unsigned char*)</br></p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_18475338_18475470_1\">\u00a7 3.9 The object representation of an object of type T is the sequence of N unsigned char objects taken up by the object of type T, where N equals sizeof(T).</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_18475338_18475470_2\">\u00a7 3.10/10 If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:<br>\n  \u2014 a char or unsigned char type.</br></p>\n</blockquote>\n<p>These are very confusing, but seem to call out your pointer bits as legal.  However, you're calling the assignment operator on an object that hasn't been constructed which is illegal.  The best workaround is something like this:</p>\n<pre><code>std::allocator&lt;largeStruct&gt; al;\nlargeStruct a;\nunsigned char* ptr = new char[sizeof(largeStruct)]; //allocate memory\nal.construct((largeStruct*)ptr, a); //call the copy constructor\n\n....\n\nal.destroy((largeStruct*)ptr); //destroy the object\ndelete[] ptr; //deallocate memory\n</code></pre>\n<p><code>std::allocator</code> is the standard allocator used by default by all of the C++ standard containers. <code>allocate</code> and <code>deallocate</code> simply call <code>new char[]</code> and <code>delete[]</code> respectively. <code>construct</code> constructs the object in place via placement new, and <code>destroy</code> destructs it by manually calling the destructor. You can do both yourself in one line of code each, but using allocators is better practice.</p>\n<p>Alternatively, instead of constructing a copy of a local instance that was default constructed, simply default construct the <code>largeStruct</code> in place with <code>al.construct((largeStruct*)ptr);</code></p>\n", "LastActivityDate": "2013-08-27T21:49:50.880"}, "bq_ids": {"n4140": {"so_18475338_18475470_1": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}, "so_18475338_18475470_2": {"section_id": 7239, "quality": 0.9473684210526315, "length": 18}, "so_18475338_18475470_0": {"section_id": 7193, "quality": 0.8958333333333334, "length": 43}}, "n3337": {"so_18475338_18475470_1": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}, "so_18475338_18475470_2": {"section_id": 6983, "quality": 0.9473684210526315, "length": 18}, "so_18475338_18475470_0": {"section_id": 6937, "quality": 0.9583333333333334, "length": 46}}, "n4659": {"so_18475338_18475470_1": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}, "so_18475338_18475470_2": {"section_id": 8748, "quality": 0.8947368421052632, "length": 17}, "so_18475338_18475470_0": {"section_id": 8702, "quality": 0.7916666666666666, "length": 38}}}});