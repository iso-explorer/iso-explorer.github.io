post_cb({"bq_ids": {"n4140": {"so_27976403_27976798_3": {"length": 15, "quality": 1.0, "section_id": 337}, "so_27976403_28391532_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 302}, "so_27976403_27976798_2": {"length": 7, "quality": 1.0, "section_id": 336}}, "n3337": {"so_27976403_27976798_3": {"length": 15, "quality": 1.0, "section_id": 327}, "so_27976403_28391532_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 293}, "so_27976403_27976798_2": {"length": 7, "quality": 1.0, "section_id": 293}}, "n4659": {"so_27976403_27976798_3": {"length": 15, "quality": 1.0, "section_id": 346}, "so_27976403_28391532_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 309}, "so_27976403_27976798_2": {"length": 7, "quality": 1.0, "section_id": 345}}}, "27976403": {"ViewCount": "349", "Body": "<p>In the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base {\n    virtual ~Base() = default;\n    template &lt;typename T, typename... Args&gt; void helper (void (T::*)(Args..., int), Args...);\n    void bar (int n) {std::cout &lt;&lt; \"bar \" &lt;&lt; n &lt;&lt; std::endl;}\n};\n\nstruct Derived : Base {\n    void baz (double d, int n) {std::cout &lt;&lt; \"baz \" &lt;&lt; d &lt;&lt; ' ' &lt;&lt; n &lt;&lt; std::endl;}\n};\n\ntemplate &lt;typename T, typename... Args&gt;\nvoid Base::helper (void (T::*f)(Args..., int), Args... args) {\n    // A bunch on lines here (hence the motivation for the helper function)\n    for (int n = 0;  n &lt; 5;  n++)\n        (dynamic_cast&lt;T*&gt;(this)-&gt;*f)(args..., n);\n    // ...\n}\n\nint main() {\n    Base b;\n    Derived d;\n    b.helper(&amp;Base::bar);  // GCC 4.8.1 will accept this, Visual Studio 2013 won't.\n    d.helper&lt;Derived, double&gt;(&amp;Derived::baz, 3.14);  // Visual Studio 2013 will accept this, GCC 4.8.1 won't\n}\n</code></pre>\n<p>I can't get either GCC4.8.1 or VS2013 to compile both lines above.  They will compile only one but not the other (and they don't agree on which line is correct and incorrect either).  The error message states template deduction failed by both compilers.  So what's actually wrong?  I've put all the template parameters in the last line (which I thought would be deducible), but it still cannot be deduced by GCC, though VS can.  Yet VS cannot deduce the template arguments for the <code>b.foo(&amp;Base::bar);</code> line when I place the template arguments for that, yet GCC can deduce them without any template arguments.  Totally bewildered here.  Are both compilers bugged here?  Any fix possible on the programmer's part?</p>\n", "AcceptedAnswerId": "28391532", "Title": "Variadic helper function with partial argument pack", "CreationDate": "2015-01-16T02:29:08.143", "Id": "27976403", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-02-08T03:40:25.357", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-08T07:12:09.783", "Score": "5", "OwnerUserId": "3089350", "Tags": "<c++><templates><c++11><variadic-templates><variadic>", "AnswerCount": "3"}, "28391532": {"Id": "28391532", "PostTypeId": "2", "Body": "<p>I wouldn't write the first argument as a pointer to member function at all. </p>\n<p>In your particular case, it required putting the first <code>Args...</code> into a non-deduced context - and the standard is clear as mud about what is supposed to happen afterwards, especially given the rule in  [temp.deduct.call]/p1 that </p>\n<blockquote>\n<p id=\"so_27976403_28391532_0\">When a function parameter pack appears in a non-deduced context\n  (14.8.2.5), the type of that parameter pack is never deduced.</p>\n</blockquote>\n<p>I have no idea what the implications of this rule are when you write <code>void (T::*)(typename identity&lt;Args&gt;::type..., int)</code> instead. The compilers disagree with each other, too.</p>\n<p>Even in the normal case, you'll have to write some 12 overloads to match all possible forms of member function pointers (4 possible <em>cv-qualifier-seq</em>s times 3 possible <em>ref-qualifiers</em>). In your case it's probably safe to skip some (such as <code>volatile</code> and <code>&amp;&amp;</code>), but it's still annoying code duplication. In addition, if you use <code>Args...</code> twice in deduced contexts, they are deduced independently and the deduced types must match exactly, which can get messy for the end user. (<code>std::max(1, 2.5)</code>, anyone?)</p>\n<p>Instead, I would just write it as a pointer-to-member:</p>\n<pre><code>template &lt;typename T, typename... Args, typename R&gt;\nvoid Base::helper (R T::*f, Args... args) {\n    // A bunch of lines here (hence the motivation for the helper function)\n    for (int n = 0;  n &lt; 5;  n++)\n        (dynamic_cast&lt;T*&gt;(this)-&gt;*f)(args..., n);\n    // ...\n}\n</code></pre>\n<p><code>R T::*</code> matches all pointers to members; when you pass a pointer to member function, <code>R</code> gets deduced to be a function type. If you want to enforce R-must-be-a-function, you can <code>static_assert</code> on <code>std::is_function&lt;R&gt;::value</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d84e8d0c956af556\" rel=\"nofollow\">Demo</a>.</p>\n", "LastActivityDate": "2015-02-08T07:12:09.783", "Score": "2", "CreationDate": "2015-02-08T07:12:09.783", "ParentId": "27976403", "CommentCount": "2", "OwnerUserId": "2756719"}, "27976798": {"Id": "27976798", "PostTypeId": "2", "Body": "<p>I think both calls are invalid because both involve a non-deduced context. From \u00a714.8.2.5:</p>\n<blockquote>\n<p id=\"so_27976403_27976798_0\">The non-deduced contexts are:</p>\n<p id=\"so_27976403_27976798_1\">\u2014 [ .. ]</p>\n<p id=\"so_27976403_27976798_2\">\u2014 A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>.</p>\n<p id=\"so_27976403_27976798_3\">When a type name is specified in a way that includes a non-deduced context, all of the types that comprise that type name are also non-deduced.</p>\n</blockquote>\n<p>When you have <code>void (T::*f)(Args..., int)</code>, that is in a non-deduced context because the function parameter pack inside the function does not occur at the end. The fact that the pointer-to-member's argument list is non-deduced makes the entire function call non-deduced. Thus this call cannot be deduced:</p>\n<pre><code>b.helper(&amp;Base::bar);\n</code></pre>\n<p>For the second one, even though it looks though you are explicitly specifying <code>Args...</code>, the argument <code>void (T::*f)(Args..., int)</code> is still in a non-deduced context, so the compiler has no way of knowing if <em>more</em> <code>Args</code> are necessary.</p>\n<p>One solution is thus to force that argument to not have to be deduced, by using, say, the identity trick backwards:</p>\n<pre><code>template &lt;typename T, typename... Args&gt; \nvoid foo (void (T::*)(typename identity&lt;Args&gt;::type..., int), Args...);\n</code></pre>\n<p>That way, both of these lines compile:</p>\n<pre><code>b.helper(&amp;Base::bar);\nd.helper&lt;Derived, double&gt;(&amp;Derived::baz, 3.14);\n</code></pre>\n<p>Although now you have to make sure that you get <code>Args...</code> exactly right if you don't explicitly specify it. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-01-16T03:24:35.110", "Score": "5", "CreationDate": "2015-01-16T03:19:27.523", "ParentId": "27976403", "CommentCount": "7", "LastEditDate": "2015-01-16T03:24:35.110", "OwnerUserId": "2069064"}, "27976823": {"Id": "27976823", "PostTypeId": "2", "Body": "<p>Parameter pack must be placed at the end of parameter list in order to be deduced automatically.</p>\n<p>Compiler cannot deduce <code>(Args..., int)</code> from given parameter list, use <code>(int, Args...)</code> instead and the program will compile.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base {\n    virtual ~Base() = default;\n    template &lt;typename T, typename... Args&gt; void helper (void (T::*)(int, Args...), Args...);\n    void bar (int n) {std::cout &lt;&lt; \"bar \" &lt;&lt; n &lt;&lt; std::endl;}\n};\n\nstruct Derived : Base {\n    void baz (int n, double d) {std::cout &lt;&lt; \"baz \" &lt;&lt; d &lt;&lt; ' ' &lt;&lt; n &lt;&lt; std::endl;}\n};\n\ntemplate &lt;typename T, typename... Args&gt;\nvoid Base::helper (void (T::*f)(int, Args...), Args... args) {\n    // A bunch on lines here (hence the motivation for the helper function)\n    for (int n = 0;  n &lt; 5;  n++)\n        (dynamic_cast&lt;T*&gt;(this)-&gt;*f)(n, args...);\n    // ...\n}\n\nint main() {\n    Base b;\n    Derived d;\n    b.helper(&amp;Base::bar);\n    d.helper&lt;Derived, double&gt;(&amp;Derived::baz, 3.14);\n}\n</code></pre>\n<p>If you have to put <code>int</code> at the end of parameter list, you can use <code>identity</code> trick as @Barry said.</p>\n<p>A barebone <code>identity</code> implementation can be as simple as:</p>\n<pre><code>template&lt;typename T&gt;\nstruct identity {\n    typedef T type;\n};\n</code></pre>\n<p>Then you can manually deduce parameter types:</p>\n<pre><code>template &lt;typename T, typename... Args&gt;\nvoid Base::helper (void (T::*f)(typename identity&lt;Args&gt;::type..., int), typename identity&lt;Args&gt;::type... args) {\n    // A bunch on lines here (hence the motivation for the helper function)\n    for (int n = 0;  n &lt; 5;  n++)\n        (dynamic_cast&lt;T*&gt;(this)-&gt;*f)(args..., n);\n    // ...\n}\n\nb.helper&lt;Base&gt;(&amp;Base::bar);\nd.helper&lt;Derived, double&gt;(&amp;Derived::baz, 3.14);\n</code></pre>\n", "LastEditorUserId": "1580875", "LastActivityDate": "2015-01-16T06:32:48.190", "Score": "6", "CreationDate": "2015-01-16T03:23:47.130", "ParentId": "27976403", "CommentCount": "2", "LastEditDate": "2015-01-16T06:32:48.190", "OwnerUserId": "1580875"}});