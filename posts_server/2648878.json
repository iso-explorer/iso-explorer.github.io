post_cb({"2648912": {"ParentId": "2648878", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This avoids a corner-case with ADL:</p>\n<pre><code>namespace other {\n  struct T {};\n  int begin(T*) { return 42; }\n}\n\nother::T a[3];\nfor (auto v : a) {}\n</code></pre>\n<p>Because ADL finds other::begin when calling <code>begin(a)</code>, the equivalent code would break causing a confusing compile error (along the lines of \"can't compare int to other::T*\" as <code>end(a)</code> would return a T*) or different behavior (if other::end was defined and did something likewise unexpected).</p>\n", "Id": "2648912", "LastEditDate": "2010-04-16T15:52:54.150", "OwnerDisplayName": "Roger Pate", "Score": "20", "CreationDate": "2010-04-15T20:54:39.913", "LastActivityDate": "2010-04-16T15:52:54.150", "LastEditorDisplayName": "Roger Pate"}, "bq_ids": {"n4140": {"so_2648878_2648878_0": {"section_id": 3906, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_2648878_2648878_1": {"section_id": 3766, "quality": 0.8571428571428571, "length": 18}, "so_2648878_2648878_0": {"section_id": 3766, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_2648878_2648878_0": {"section_id": 4792, "quality": 0.7619047619047619, "length": 16}}}, "2648878": {"CommentCount": "0", "AcceptedAnswerId": "2648912", "PostTypeId": "1", "LastEditorUserId": "636019", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2010-04-15T20:49:45.070", "LastActivityDate": "2011-10-29T17:38:42.353", "LastEditDate": "2011-10-29T17:38:42.353", "ViewCount": "2767", "FavoriteCount": "1", "Title": "Range-based for statement definition redundancy", "Id": "2648878", "Score": "17", "Body": "<p>Looking at n3092, in \u00a76.5.4 we find the equivalency for a range-based for loop. It then goes on to say what <code>__begin</code> and <code>__end</code> are equal to. It differentiates between arrays and other types, and I find this redundant (aka confusing).</p>\n<p>It says for arrays types that <code>__begin</code> and <code>__end</code> are what you expect: a pointer to the first and a pointer to one-past the end. Then for other types, <code>__begin</code> and <code>__end</code> are equal to <code>begin(__range)</code> and <code>end(__range)</code>, with ADL. Namespace <code>std</code> is associated, in order to find the <code>std::begin</code> and <code>std::end</code> defined in <code>&lt;iterator&gt;</code>, \u00a724.6.5.</p>\n<p>However, if we look at the definition of <code>std::begin</code> and <code>std::end</code>, they are both defined for arrays as well as container types. And the array versions do exactly the same as above: pointer to the first, pointer to one-past the end.</p>\n<p>Why is there a need to differentiate arrays from other types, when the definition given for other types would work just as well, finding <code>std::begin</code> and <code>std::end</code>?</p>\n<hr>\n<p><sub>Some abridged quotes for convenience:</sub></p>\n<blockquote>\n<h3>\u00a76.5.4 The range-based <code>for</code> statement</h3>\n<p id=\"so_2648878_2648878_0\">\u2014 if _RangeT is an array type, begin-expr and end-expr are __range and __range + __bound, respectively, where __bound is the array bound. If _RangeT is an array of unknown size or an array of incomplete type, the program is ill-formed.  </p>\n<p id=\"so_2648878_2648878_1\">\u2014 otherwise, begin-expr and end-expr are begin(__range) and end(__range), respectively, where begin and end are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup, namespace std is an associated namespace.</p>\n</blockquote>\n<p><b></b></p>\n<blockquote>\n<h3>\u00a724.6.5 range access</h3>\n<pre><code>template &lt;class T, size_t N&gt; T* begin(T (&amp;array)[N]);\n</code></pre>\n<p id=\"so_2648878_2648878_2\">Returns: array.</p>\n<pre><code>template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);\n</code></pre>\n<p id=\"so_2648878_2648878_3\">Returns: array + N.</p>\n</blockquote>\n</hr>", "Tags": "<c++><for-loop><range><c++11><argument-dependent-lookup>", "OwnerUserId": "87234", "AnswerCount": "1"}});