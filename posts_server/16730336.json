post_cb({"16730336": {"CommentCount": "2", "CreationDate": "2013-05-24T08:04:16.913", "PostTypeId": "1", "AcceptedAnswerId": "16730438", "LastEditorUserId": "759866", "LastActivityDate": "2013-12-15T01:02:46.923", "LastEditDate": "2013-12-15T01:02:46.923", "ViewCount": "1793", "FavoriteCount": "1", "Title": "C++ template class static const variable member as map key gives undefined reference", "Id": "16730336", "Score": "3", "Body": "<p>I have a bunch of classes that have a static member that is an enum value. And I have a map somewhere else with this enum as key. Now if I use a template parameter in a function to access the map, I get an undefined reference.</p>\n<p>To make it clear, here is a simplified non-working example :</p>\n<pre><code>template&lt;int T&gt;\nstruct A\n  {\n    static const int Type = T;\n  }\n\ntemplate&lt;class T&gt;\nvoid fun()\n  {\n    cout &lt;&lt; map_[T::Type] &lt;&lt; endl;\n  }\n\nmap&lt;int, string&gt; map_{{1337, \"1337\"}};\n</code></pre>\n<p>main :</p>\n<pre><code>fun&lt;A&lt;1337&gt;();\n</code></pre>\n<p>gives me (g++ 4.7) :</p>\n<pre><code>undefined reference to `(anonymous namespace)::A&lt;1337&gt;::Type'\n</code></pre>\n<p>However this :</p>\n<pre><code>template&lt;class T&gt;\nvoid fun()\n  {\n    auto key = T::Type;\n    cout &lt;&lt; map_[key] &lt;&lt; endl;\n  }\n</code></pre>\n<p>Compile and prints <code>1337</code></p>\n<p>Can someone explain me this behavior?</p>\n", "Tags": "<c++><templates><c++11><g++><undefined-reference>", "OwnerUserId": "1024122", "AnswerCount": "2"}, "16730439": {"ParentId": "16730336", "LastEditDate": "2013-05-24T08:25:20.547", "CommentCount": "0", "CreationDate": "2013-05-24T08:10:54.630", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "16730439", "Score": "3", "Body": "<p>That is because <a href=\"http://en.cppreference.com/w/cpp/container/map/operator_at\" rel=\"nofollow\"><code>std::map::operator[]</code></a> takes its argument <strong>by reference</strong>, which makes your variable <strong>odr-used</strong> (see paragraph 3.2/3 of the C++11 Standard). </p>\n<p>In short, the whole thing boils down to the fact that the compiler needs to know the <em>address</em> of an object when it needs to bind a reference to it, and that makes it impossible for it to treat that object just like a pure value and perform inlining.</p>\n<p>In that case, you need to provide a <em>definition</em> of your static data member at global namespace scope, so that the compiler knows what region of storage that object occupies (i.e. what its address is):</p>\n<pre><code>template&lt;int T&gt;\nconst int A::Type;\n</code></pre>\n<p>Per paragraph 9.4.2/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16730336_16730439_0\">If a non-volatile <code>const</code> static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em>\n  is a constant expression (5.19). [ ... ] <strong>The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer</strong>.</p>\n</blockquote>\n<p>In the first version of your program, on the other hand, you were only using the <em>value</em> of your static data member, which means <code>Type</code> was not odr-used, and a definition at namespace scope was not needed.</p>\n", "LastActivityDate": "2013-05-24T08:25:20.547"}, "16730438": {"ParentId": "16730336", "LastEditDate": "2013-05-24T08:17:04.243", "CommentCount": "0", "CreationDate": "2013-05-24T08:10:51.217", "OwnerUserId": "560648", "LastEditorUserId": "560648", "PostTypeId": "2", "Id": "16730438", "Score": "6", "Body": "<p>When you use <code>T::Type</code>, you must <em>define</em> it:</p>\n<pre><code>template&lt;int T&gt;\nstruct A\n{\n   static const int Type = T;\n}\n\ntemplate &lt;int T&gt;\nconst int A&lt;T&gt;::Type;\n</code></pre>\n<p>Yes, even though you provided its initialiser inline within <code>A&lt;T&gt;</code>!</p>\n<p>The reason that you may not have been aware of this, is the same reason that you don't get the same problem in your second case \u2014 due to the immediate lvalue-to-rvalue conversion, the standard allows the compiler to <em>optimize</em> the requirement to refer to <code>Type</code> at runtime, able instead to pick out the value at compile-time. The linker then has no need to search for the definition, and you get no error.</p>\n<hr>\n<blockquote>\n<p id=\"so_16730336_16730438_0\"><code>[C++11: 9.4.2/2]:</code> <strong>The declaration of a static data member in its class definition is not a definition</strong> and may be of an incomplete type other than cv-qualified void. <strong>The definition for a static data member shall appear in a namespace scope enclosing the member\u2019s class definition</strong>. In the definition at namespace scope, the name of the static\n  data member shall be qualified by its class name using the :: operator. The initializer expression in the definition of a static data member is in the scope of its class (3.3.7). <em>[..]</em></p>\n<p id=\"so_16730336_16730438_1\"><code>[C++11: 9.4.2/3]:</code> <strong>If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em></strong> in which every initializer-clause that is an assignment-expression\n  is a constant expression (5.19). A <code>static data</code> member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every initializer-clause that is an <em>assignment-expression</em> is a constant expression. <em>[ Note:</em> In both these cases, the member may appear in constant expressions. <em>\u2014end note ]</em> <strong>The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an initializer.</strong></p>\n<p id=\"so_16730336_16730438_2\"><code>[C++11: 3.2/2]:</code> <em>[..]</em> A variable whose name appears as a potentially-evaluated expression is odr-used unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied. <em>[..]</em></p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-05-24T08:17:04.243"}, "bq_ids": {"n4140": {"so_16730336_16730439_0": {"section_id": 5908, "quality": 0.9393939393939394, "length": 31}, "so_16730336_16730438_0": {"section_id": 5907, "quality": 0.8888888888888888, "length": 48}, "so_16730336_16730438_1": {"section_id": 5908, "quality": 0.8923076923076924, "length": 58}}, "n3337": {"so_16730336_16730439_0": {"section_id": 5680, "quality": 0.9393939393939394, "length": 31}, "so_16730336_16730438_0": {"section_id": 5679, "quality": 0.8888888888888888, "length": 48}, "so_16730336_16730438_2": {"section_id": 6785, "quality": 0.8, "length": 16}, "so_16730336_16730438_1": {"section_id": 5680, "quality": 0.8923076923076924, "length": 58}}, "n4659": {"so_16730336_16730439_0": {"section_id": 7390, "quality": 0.9393939393939394, "length": 31}, "so_16730336_16730438_0": {"section_id": 7389, "quality": 0.8518518518518519, "length": 46}}}});