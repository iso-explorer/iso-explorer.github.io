post_cb({"1714984": {"ParentId": "1714874", "CommentCount": "0", "Body": "<p>There are two questions here.</p>\n<p>First, returning a reference is allowed of course, an example:</p>\n<pre><code>struct myclass\n{\n    myclass&amp; foo()\n    { cout &lt;&lt; \"myclass::foo()\"; return *this }\n    myclass&amp; bar()\n    { cout &lt;&lt; \"myclass::bar()\"; return *this }\n};\n...\nmyclass obj;\nobj.foo().bar();\n</code></pre>\n<p>Second, passing a temporary object to a non-const reference is not allowed in C++ (discussed a lot on SO, just search for it):</p>\n<pre><code>// passing string(\"this is a test\") is wrong\nstring text = erase_whitespace(string(\"this is a test\"));\n</code></pre>\n<p>Unfortunately, some compilers (e.g. VC) allow this behavior, although it is not standard. If you turn your compiler warning level, you should get a warning at least.</p>\n", "OwnerUserId": "127893", "PostTypeId": "2", "Id": "1714984", "Score": "4", "CreationDate": "2009-11-11T12:48:00.407", "LastActivityDate": "2009-11-11T12:48:00.407"}, "1715072": {"ParentId": "1714874", "CommentCount": "1", "Body": "<p>I'm not sure how representative your example is, but your function looks fine, as long as you document that it modifies the passed-in object.  It's the calling that is bogus.  I don't see why you can't just write:</p>\n<pre><code>std::string text(\"this is a test\");\nerase_whitespace(text);\ncout &lt;&lt; test;\n</code></pre>\n<p>Which does <em>exactly</em> the same thing as what you would hope happens in your original code, i.e. make a <code>std::string</code>, strip its whitespace, and output it, while keeping the <code>std::string</code> object itself on the stack instead of in the heap, and minimizing copies. Of course, the <code>std::string</code>'s real storage is still on the heap, but you get the benefit of C++ disposing of the thing when the function or block is done.</p>\n<p>I don't see why you need to save that line of code when it translates into no actual compiled code savings.</p>\n<p>Now if you really needed this to, say, get stuffed into an equation, the usual thing to do is something like what Skizz wrote above (which works in regular C++, not just Visual C):</p>\n<pre><code>std::string erase_whitespace (const string &amp;input)\n{\n    std::string output(input);\n    output.erase (...);\n    return output;\n}\n</code></pre>\n<p>What's nice about this is that you can pass a <code>const char*</code> as the parameter, and C++ will automatically create a temporary <code>std::string</code> from it, since <code>std::string</code> has a constructor that takes a <code>const char*</code>.  Also, this doesn't mess with the passed-in object.  And as Skizz pointed out, optimizers like this kind of construct for return values.</p>\n", "OwnerUserId": "208664", "PostTypeId": "2", "Id": "1715072", "Score": "2", "CreationDate": "2009-11-11T13:07:12.937", "LastActivityDate": "2009-11-11T13:07:12.937"}, "1714963": {"ParentId": "1714874", "CommentCount": "4", "Body": "<p>If you're using Visual C, then it would be better to do the following:</p>\n<pre><code>string erase_whitespace (const string &amp;input)\n{\n  string output = input.erase (...);\n  return output;\n}\n</code></pre>\n<p>It may look worse but the compiler, when building an optimised version, can utilise <a href=\"http://msdn.microsoft.com/en-us/library/ms364057%28VS.80%29.aspx\" rel=\"noreferrer\">Named Return Value Optimisations</a> which eliminates the overhead of returning by value (i.e. eliminates the copy constructors involved in returning by value). So, not only does it look right, it is probably more efficent.</p>\n", "OwnerUserId": "1898", "PostTypeId": "2", "Id": "1714963", "Score": "7", "CreationDate": "2009-11-11T12:42:34.327", "LastActivityDate": "2009-11-11T12:42:34.327"}, "1714967": {"ParentId": "1714874", "CommentCount": "2", "Body": "<p>I concur with Mike, but let me also mention that I don't think passing references to <code>string</code> around is a good idea in the first place. I'm pretty sure the string class is light-weight to pass by value since it stores the actual character array by reference internally.</p>\n", "OwnerUserId": "102715", "PostTypeId": "2", "Id": "1714967", "Score": "0", "CreationDate": "2009-11-11T12:43:31.507", "LastActivityDate": "2009-11-11T12:43:31.507"}, "1714889": {"ParentId": "1714874", "CommentCount": "1", "Body": "<p>Better would probably be to explicitly make it a heap allocation w/pointer:</p>\n<pre><code>string* erase_whitespace(string* text)\n{\n    text-&gt;erase(**etc.**);\n    return text;\n}\n\nstring* text = erase_whitespace(new string(\"this is a test\"));\ncout &lt;&lt; *text;\ndelete text;\n</code></pre>\n", "OwnerUserId": "148870", "PostTypeId": "2", "Id": "1714889", "Score": "0", "CreationDate": "2009-11-11T12:29:24.090", "LastActivityDate": "2009-11-11T12:29:24.090"}, "bq_ids": {"n4140": {"so_1714874_1714974_1": {"section_id": 381, "quality": 0.8181818181818182, "length": 9}, "so_1714874_1714974_0": {"section_id": 380, "quality": 1.0, "length": 14}, "so_1714874_1714974_2": {"section_id": 382, "quality": 0.8108108108108109, "length": 30}}, "n3337": {"so_1714874_1714974_1": {"section_id": 372, "quality": 0.8181818181818182, "length": 9}, "so_1714874_1714974_0": {"section_id": 371, "quality": 1.0, "length": 14}, "so_1714874_1714974_2": {"section_id": 373, "quality": 0.8108108108108109, "length": 30}}, "n4659": {"so_1714874_1714974_1": {"section_id": 396, "quality": 0.7272727272727273, "length": 8}, "so_1714874_1714974_0": {"section_id": 395, "quality": 1.0, "length": 14}, "so_1714874_1714974_2": {"section_id": 397, "quality": 0.7567567567567568, "length": 28}}}, "1714874": {"CommentCount": "5", "ViewCount": "1020", "CreationDate": "2009-11-11T12:26:08.420", "LastActivityDate": "2009-11-11T16:56:04.660", "Title": "Is returning a temp-object by reference possible", "AcceptedAnswerId": "1714974", "PostTypeId": "1", "Id": "1714874", "Score": "3", "Body": "<p>is it possible to return a reference from a function like in this example code:</p>\n<pre><code>string &amp;erase_whitespace(string &amp;text)\n{\n    text.erase(**etc.**);\n    return text;\n}\n</code></pre>\n<p>Call:</p>\n<pre><code>string text = erase_whitespace(string(\"this is a test\"));\ncout &lt;&lt; test;\n</code></pre>\n<p>Does this code work? On Visual C++ it does not crash but it looks wrong.</p>\n<p>Thanks</p>\n", "Tags": "<c++>", "OwnerUserId": "21683", "AnswerCount": "10"}, "1714974": {"ParentId": "1714874", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>From \u00a7 12.2.3 of the C++ 2003 standard (draft)</p>\n<blockquote>\n<p id=\"so_1714874_1714974_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>\n</blockquote>\n<p>\u00a7 12.2.4:</p>\n<blockquote>\n<p id=\"so_1714874_1714974_1\">There are two contexts in which temporaries are destroyed at a different point than the end of the full- \n  expression. ...</p>\n</blockquote>\n<p>\u00a7 12.2.5:</p>\n<blockquote>\n<p id=\"so_1714874_1714974_2\">The second context is when a reference is bound to a temporary. The temporary to which the reference is \n  bound or the temporary that is the complete object to a subobject of which the temporary is bound persists \n  for the lifetime of the reference except as specified below. ... A temporary bound to a reference \n  parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n<p>\u00a78.5.3.5 is what determines when the reference must be a const type. It is possible for a temporary to be bound to a non-const reference if the temporary is an instance of a class that has a conversion operator that returns an appropriate reference (that's a mouthful). An example might be easier to understand:</p>\n<pre><code>class Foo {\n    ...\n    operator Bar&amp;() const;\n...\nvoid baz(Bar &amp;b);\n...\n    baz(Foo()); // valid\n    baz(Bar()); // not valid\n</code></pre>\n<p>The last line isn't valid because of \u00a7 12.3.2.1, which states \"A conversion function is never used to convert [an ...] object to the [...] same object type (or a reference to \nit)\". You might be able to make it work using casting via an ancestor of Bar and a virtual conversion function.</p>\n<p>An assignment is an expression (\u00a7 5.17), thus the full-expression (\u00a7 1.9.12) in your code is the assignment. This gives the following sequence (forgetting for the moment that a temporary string probably can't be bound to a non-const reference):</p>\n<ol>\n<li>A temporary string is created</li>\n<li>The temporary is bound to the <code>string&amp; text</code> argument of <code>erase_whitespace</code></li>\n<li><code>erase_whitespace</code> does its thang.</li>\n<li><code>erase_whitespace</code> returns a reference to the temporary</li>\n<li>The temporary is copied to <code>string text</code></li>\n<li>The temporary is destroyed.</li>\n</ol>\n<p>So all is kosher in this case. The problem case, as Mike Seymour points out, would be assigning the result of <code>erase_whitespace</code> to a reference. Note that this likely wouldn't cause an immediate problem, as the area that stored the string probably contains the same data it did before the temporary was destroyed. The next time something is allocated on the stack or heap, however...</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2009-11-11T16:56:04.660", "Id": "1714974", "Score": "9", "CreationDate": "2009-11-11T12:44:47.723", "LastActivityDate": "2009-11-11T16:56:04.660"}, "1715086": {"ParentId": "1714874", "CommentCount": "2", "Body": "<p>Well in the situation you give it DOES work.  Your problem comes when you try and use the return as a reference.  ie:</p>\n<pre><code>string&amp; text = erase_whitespace(string(\"this is a test\"));\n</code></pre>\n<p>This is perfectly valid VC++ code but you are now well into \"undefined\" territory.  Your main problem comes from the fact that anyone else using this code will not know, without looking at the implementation, that they cannot do this.</p>\n<p>All in its a very dangerous bit off code that will only work on VC++.</p>\n<p>Skizz's response gives you code that will work perfectly as a drop-in replacement and fix ALL the problem's mentioned above.</p>\n", "OwnerUserId": "131140", "PostTypeId": "2", "Id": "1715086", "Score": "0", "CreationDate": "2009-11-11T13:10:03.697", "LastActivityDate": "2009-11-11T13:10:03.697"}, "1715087": {"ParentId": "1714874", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It looks wrong and it <em>is</em> wrong since non-const references are not allowed to bind to rvalues. In your case the compiler seems to accept it as an <em>extension</em>. You shouldn't rely on it.</p>\n<p>As for possible chrashes: No this works fine with this compiler extension enabled. But this would not:</p>\n<pre><code>string const&amp; dangling_reference =\n    erase_whitespace(string(\"this is a test\"));\n</code></pre>\n<p>because the function returns a reference to a temporary object that will be destroyed. If you return by value instead, this line will be safe due to a special C++ rule (the life of the temporary will be extended).</p>\n<p>Another disadvantage is that the function is mutating its argument. This might be an unexpected behaviour for a function which takes a string and also returns a string.</p>\n<p>In case you wrote the function this way to improve performance you could try this one and measure it:</p>\n<pre><code>string erase_whitespace(string text)\n{\n    text.erase(**etc.**);\n    string ret; ret.swap(text);\n    return ret;\n}\n</code></pre>\n<p>If you have a good compiler that can elide unnecessary copies this should perform very well. To be specific, a compiler could elide the copy for accepting the parameter by value if the function is invoked with an rvalue. Your compiler might also be smart enough to apply NRVO (named return value optimization). If it is that smart, the following code</p>\n<pre><code>string foo = erase_whithespace(\"  blah  \");\n</code></pre>\n<p>will not call any copy ctor of std::string. Swapping is only done because no compiler is currently able to apply NRVO when a parameter is returned.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2009-11-11T15:09:57.890", "Id": "1715087", "Score": "3", "CreationDate": "2009-11-11T13:10:12.687", "LastActivityDate": "2009-11-11T15:09:57.890"}, "1714897": {"ParentId": "1714874", "CommentCount": "1", "Body": "<p>Your return parameter as well as the function parameter needs to const-reference. VC++ is non-compliant compiler in this regard and allows a temporary to be passed as a nonconst-reference.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "1714897", "Score": "0", "CreationDate": "2009-11-11T12:31:25.587", "LastActivityDate": "2009-11-11T12:31:25.587"}, "1714929": {"ParentId": "1714874", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Ya definately it should work ..</p>\n<p>since string text = erase_whitespace(string(\"this is a test\")) </p>\n<p>is converted to following code by compiler :</p>\n<p>string temp(\"this is a test\");</p>\n<p>string text = erase_whitespace(temp);</p>\n", "OwnerUserId": "303986", "LastEditorUserId": "303986", "LastEditDate": "2009-11-11T12:47:52.670", "Id": "1714929", "Score": "0", "CreationDate": "2009-11-11T12:36:48.307", "LastActivityDate": "2009-11-11T12:47:52.670"}});