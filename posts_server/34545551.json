post_cb({"34545551": {"CommentCount": "0", "ViewCount": "141", "CreationDate": "2015-12-31T11:08:13.810", "LastActivityDate": "2015-12-31T11:36:48.357", "Title": "Compiler-deduced type for generic lambdas", "AcceptedAnswerId": "34545653", "PostTypeId": "1", "Id": "34545551", "Score": "9", "Body": "<p>In <a href=\"http://www.drdobbs.com/cpp/the-c14-standard-what-you-need-to-know/240169034\">this article</a>, the following code is presented:</p>\n<pre><code>std::vector&lt;int&gt; ivec = { 1, 2, 3, 4};\nstd::vector&lt;std::string&gt; svec = { \"red\", \"green\", \"blue\" };\nauto adder = [](auto op1, auto op2){ return op1 + op2; };\nstd::cout &lt;&lt; \"int result : \"\n          &lt;&lt; std::accumulate(ivec.begin(),\n                             ivec.end(),\n                             0,\n                             adder)\n          &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"string result : \"\n          &lt;&lt; std::accumulate(svec.begin(),\n                             svec.end(),\n                             std::string(\"\"),\n                             adder)\n          &lt;&lt; \"\\n\";\n</code></pre>\n<p>If I understand correctly, the compiler will generate an internal class much like this one:</p>\n<pre><code>template&lt;class T&gt;\nclass _lambda\n{\n  public:\n  T operator()(T lhs, T rhs) { return lhs + rhs; }\n};\n</code></pre>\n<p>But what I don't understand is, in this section of the code, adder seems to have two types at the same time: <code>_lambda&lt;int&gt;</code> and <code>_lambda&lt;string&gt;</code>. How is this possible?</p>\n", "Tags": "<c++><lambda><c++14><type-deduction>", "OwnerUserId": "748175", "AnswerCount": "3"}, "34545590": {"ParentId": "34545551", "LastEditDate": "2015-12-31T11:16:06.203", "CommentCount": "3", "CreationDate": "2015-12-31T11:11:44.573", "Score": "8", "LastEditorUserId": "2805305", "PostTypeId": "2", "Id": "34545590", "OwnerUserId": "2805305", "Body": "<p>Nope. It generates something like this:</p>\n<pre><code>class _lambda {\npublic:\n    template&lt;class T1, class T2&gt;\n    auto operator()(T1 lhs, T2 rhs) const { return lhs + rhs; }\n};\n</code></pre>\n<p>The class isn't templated. The <code>operator()</code> is.</p>\n", "LastActivityDate": "2015-12-31T11:16:06.203"}, "bq_ids": {"n4140": {"so_34545551_34545653_0": {"section_id": 5964, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_34545551_34545653_0": {"section_id": 7453, "quality": 0.9259259259259259, "length": 25}}}, "34545671": {"ParentId": "34545551", "LastEditDate": "2015-12-31T11:36:48.357", "CommentCount": "2", "CreationDate": "2015-12-31T11:18:47.443", "Score": "1", "LastEditorUserId": "5470596", "PostTypeId": "2", "Id": "34545671", "OwnerUserId": "5470596", "Body": "<p>As a matter of fact, the compiler will generate a class looking like this:</p>\n<pre><code>class _lambda {\npublic:\n    template&lt;class T, class U&gt;\n    auto operator()(T lhs, U rhs) const { return lhs + rhs; }\n};\n</code></pre>\n<p>The two arguments are not necessarily of the same type, the only condition is the existance of a <code>operator+()</code> with the regarding argument types.</p>\n<p>Look at the demo on <a href=\"http://coliru.stacked-crooked.com/a/450140658c098e94\" rel=\"nofollow\">coliru</a>.</p>\n", "LastActivityDate": "2015-12-31T11:36:48.357"}, "34545653": {"ParentId": "34545551", "CommentCount": "1", "CreationDate": "2015-12-31T11:17:07.553", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "34545653", "Score": "8", "Body": "<p>According to the standard 5.1.2/p5 Lambda expressions [expr.prim.lambda]:</p>\n<blockquote>\n<p id=\"so_34545551_34545653_0\">For a generic lambda, the closure type has a public inline function\n  call operator member template (14.5.2) whose template-parameter-list\n  consists of one invented type template-parameter for each occurrence of\n  auto in the lambda\u2019s parameter-declaration-clause, in order of\n  appearance.</p>\n</blockquote>\n<p>Consequently, what is actually generated is:</p>\n<pre><code>class _lambda {\npublic:\n    template&lt;typename T1, typename T2&gt;\n    auto operator()(T1 lhs, T2 rhs) const { return lhs + rhs; }\n};\n</code></pre>\n", "LastActivityDate": "2015-12-31T11:17:07.553"}});