post_cb({"bq_ids": {"n4140": {"so_24173910_24174026_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3919}}, "n3337": {"so_24173910_24174026_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3779}}, "n4659": {"so_24173910_24174026_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4805}}}, "24174026": {"Id": "24174026", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24173910_24174026_0\">... leading me to believe the static variable as been initialized again.</p>\n</blockquote>\n<p>This might be a right perception in terms you allow <code>Machine</code> and <code>Pc</code> instances to be publicly constructed (or copied).</p>\n<p>Well, your code here </p>\n<pre><code>Pc* Pc::getInstance() {\n    static Pc* pc = new Pc();\n    return pc;\n}\n</code></pre>\n<p>and the signature of the method</p>\n<pre><code>static Machine* getInstance();\n</code></pre>\n<p>should better be</p>\n<pre><code>Pc&amp; Pc::getInstance() {\n    static Pc theInstance;\n    return theInstance;\n}\n\nstatic Machine&amp; getInstance();\n</code></pre>\n<p>also make default, copy constructors, assignment operators for both classes <code>Machine</code> and <code>Pc</code> private.\nThus only reference variables can be actually used, to access the singleton instance</p>\n<pre><code>Machine&amp; mach = Pc::getInstance();\nMachine m2; // Fails to compile\n</code></pre>\n<p><strong>UPDATE:</strong><br>\nBut I see a general problem here, that makes your whole design a bit questionable:</br></p>\n<pre><code>Machine&amp; Machine::getInstance() {\n    return Pc::getInstance();\n}\n</code></pre>\n<p>This makes the <code>Machine</code> class dependent on it's derived class, which makes a base class pretty useless at all.</p>\n<hr>\n<p>What about using a template class for solving this problem?</p>\n<pre><code>template&lt;class Derived&gt;\nclass Machine {\npublic:\n     static Derived&amp; getInstance() {\n          static Derived theInstance;\n          return theInstance;\n     }\nprotected:\n     Machine() {\n         Derived* self = static_cast&lt;Derived*&gt;(this); // Ensure that Derived\n                                                      // inherits from Machine\n         (void)self; // suppress compiler warning for unused variable\n     }\nprivate:\n     Machine(const Machine&amp;);\n     Machine&amp; operator=(const Machine&amp;);\n};\n\nclass Pc : public Machine&lt;Pc&gt; {\n    friend class Machine&lt;Pc&gt;;\n    Pc() : Machine&lt;Pc&gt;() {}\n};\n\nint main() {\n    Pc&amp; pc = Pc::getInstance(); // Get a reference of the Pc singleton\n    return 0;\n}\n</code></pre>\n<p>See a <a href=\"http://ideone.com/ypmUev\" rel=\"nofollow\">fully working sample here</a>.</p>\n<hr>\n<p>As for your mentions of the <code>-ffreestanding</code> compiler options:  </p>\n<p>First, it's a c compiler option (shouldn't affect your c++ code), second as I found in the <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Standards.html#Standards\" rel=\"nofollow\">GCC documentation</a> </p>\n<blockquote>\n<p id=\"so_24173910_24174026_1\">GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it will act as the compiler for a hosted implementation, defining <strong>STDC_HOSTED</strong> as 1 and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option -ffreestanding; it will then define <strong>STDC_HOSTED</strong> to 0 and not make assumptions about the meanings of function names from the standard library, with exceptions noted below. To build an OS kernel, you may well still need to make your own arrangements for linking and startup. See <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/C-Dialect-Options.html#C-Dialect-Options\" rel=\"nofollow\">Options Controlling C Dialect</a>.</p>\n</blockquote>\n<p>This doesn't give me any points about a undefined behavior of local static initialization.</p>\n</hr></hr>", "LastEditorUserId": "1413395", "LastActivityDate": "2014-06-12T09:05:31.130", "Score": "3", "CreationDate": "2014-06-11T23:05:32.763", "ParentId": "24173910", "CommentCount": "8", "LastEditDate": "2014-06-12T09:05:31.130", "OwnerUserId": "1413395"}, "24173910": {"ViewCount": "521", "Body": "<p>I have a virtual singleton that i want to implement the <code>getInstance()</code> static function for, however each time it is called, the static object gets re-initialised, so i get a new instance each time, any help will be appreciated - this has me very confused.</p>\n<p>The class I want to implement the method in:</p>\n<pre><code>class Pc : public Machine\n{\n  private:\n    ... members ...\n\n  public:\n    static Pc* getInstance();\n\n    Pc() {};\n    virtual ~Pc() {}\n\n    ... other functions ...\n};\n</code></pre>\n<p>The parent class:</p>\n<pre><code>class Machine\n{\n  public:\n    static Machine* getInstance();\n\n    Machine() { }\n    Machine(const Machine&amp;) = delete;\n    virtual ~Machine() { }\n\n    ... methods ...\n\n    void operator=(const Machine&amp;) = delete;\n};\n</code></pre>\n<p>Bridge from Machine -&gt; Pc singleton</p>\n<pre><code>Machine* Machine::getInstance()\n{\n    return Pc::getInstance();\n}\n</code></pre>\n<p>I have two sets of code for PC, one which i belive should work, and my current workaround code...</p>\n<p>Non working code:</p>\n<pre><code>Pc* Pc::getInstance()\n{\n    static Pc* pc = new Pc();\n    return pc;\n}\n</code></pre>\n<p>Working (but bodged) <code>getInstance()</code> code:</p>\n<pre><code>static Pc* pc = nullptr;\nPc* Pc::getInstance()\n{\n    if(pc == nullptr) {\n        pc = new Pc();\n    }\n    return pc;\n}\n</code></pre>\n<p>While both compile successfully, after break pointing my code i can see that my expected code returns the same pointer, however after manipulating the object the second call returns a new object, leading me to believe the static variable as been initialized again.</p>\n<p>Compiled with the flags:</p>\n<pre><code>-ffreestanding -Wall -Wextra -fno-exceptions -fno-rtti -std=gnu++11 -lgcc\n</code></pre>\n<p>(this is for an OS project)</p>\n", "AcceptedAnswerId": "24190853", "Title": "Static local variable gets reinitialized", "CreationDate": "2014-06-11T22:53:06.763", "Id": "24173910", "CommentCount": "9", "LastEditDate": "2014-06-12T05:06:20.520", "PostTypeId": "1", "LastEditorUserId": "434551", "LastActivityDate": "2014-06-12T17:52:12.823", "Score": "1", "OwnerUserId": "3105639", "Tags": "<c++><gcc><c++11><singleton>", "AnswerCount": "2"}, "24190853": {"Id": "24190853", "PostTypeId": "2", "Body": "<p>Ok! After 3 days of head scratching i have found the cause of the error! GCC expects you to supply a few functions for yourself if you use <code>--ffreestanding</code> to compile your code, incase anyone else has this (granted very obscure) error, i have put the code i used below (a huge thanks to <a href=\"http://osdev.org/\" rel=\"nofollow\">osdev.org</a> for this code!!)</p>\n<pre><code>__extension__ typedef int __guard __attribute__((mode(__DI__)));\n\nextern \"C\" int __cxa_guard_acquire(__guard* g)\n{\n    return !*(char*)(g);\n}\n\nextern \"C\" void __cxa_guard_release(__guard* g)\n{\n    *(char *)g = 1;\n}\n\nextern \"C\" void __cxa_guard_abort (__guard*)\n{\n}\n</code></pre>\n", "LastActivityDate": "2014-06-12T17:52:12.823", "CommentCount": "0", "CreationDate": "2014-06-12T17:52:12.823", "ParentId": "24173910", "Score": "0", "OwnerUserId": "3105639"}});