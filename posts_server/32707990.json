post_cb({"bq_ids": {"n4140": {"so_32707990_32708142_0": {"length": 30, "quality": 0.967741935483871, "section_id": 7070}}, "n3337": {"so_32707990_32708142_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 6814}}, "n4659": {"so_32707990_32708142_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 8567}}}, "32708142": {"Id": "32708142", "PostTypeId": "2", "Body": "<p>[basic.scope.class]/p1:</p>\n<blockquote>\n<p id=\"so_32707990_32708142_0\">1) The potential scope of a name declared in a class consists not only of\n  the declarative region following the name\u2019s point of declaration, but\n  also of all function bodies, default arguments,\n  <em>exception-specification</em>s, and <em>brace-or-equal-initializer</em>s of\n  non-static data members in that class (including such things in nested\n  classes).</p>\n</blockquote>\n<p><em>trailing-return-type</em>s are not in the list. Therefore, the normal rules apply - <code>f1</code> and <code>f2</code> must be declared before they are used. </p>\n<p>In C++14, you can return <code>decltype(auto)</code> and drop the trailing return type. Otherwise, you can move them up or use <code>declval</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-09-22T04:06:07.230", "Score": "4", "CreationDate": "2015-09-22T04:03:22.770", "ParentId": "32707990", "CommentCount": "3", "OwnerUserId": "2756719", "LastEditDate": "2015-09-22T04:06:07.230"}, "32707990": {"ViewCount": "114", "Body": "<pre><code>int f() {\n    return 1;\n}\n\nint g(int i) {\n    return i;\n}\ntemplate &lt;typename F1, typename F2&gt;\nclass Composer {\npublic:\n    Composer(F1 *ff1, F2 *ff2): f1(ff1), f2(ff2) {}\n    /*\n    auto operator() () const -&gt; \n    // if i insert this code, \n    // here compiler complains \"use undeclared identifier 'f1'\"\n    decltype(f2(f1())) {\n        return f2(f1());\n    }\n    */\n    template&lt;typename... Ps&gt;\n    auto operator() (Ps... ps) const -&gt; decltype(f2(f1(ps...))) {\n        return f2(f1(ps...));\n    }\nprivate:\n    F1 *f1;\n    F2 *f2;\n};\nint main() {\n    Composer&lt;decltype(f), decltype(g)&gt; c(f, g);\n    // compiler complains here \"no matching function for call to \n    // object of type Composer&lt;decltype(f), decltype(g)&gt;\"\n    c();\n}\n</code></pre>\n<p>i wanna know what's wrong with above code. why does compiler complains no match function for calling c()? why does compiler complains f1 undeclared if i insert the non-template function \"operator() () const\"? thanks for reading, i'm anxious to know the answer, please help me!</p>\n", "AcceptedAnswerId": "32708142", "Title": "why compiler complains use undeclared identifier 'f1'", "CreationDate": "2015-09-22T03:43:52.997", "Id": "32707990", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-09-22T04:06:07.230", "Score": "1", "OwnerUserId": "2184663", "Tags": "<c++><templates>", "AnswerCount": "1"}});