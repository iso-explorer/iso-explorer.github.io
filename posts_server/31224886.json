post_cb({"31234579": {"ParentId": "31224886", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-07-05T20:16:02.297", "Score": "6", "LastEditorUserId": "1041090", "LastEditDate": "2015-07-06T00:59:49.167", "Id": "31234579", "OwnerUserId": "1041090", "Body": "<p>Clang and MSVC are correct; this code is valid. As Alf notes, <strong>[namespace.udecl] (7.3.3)/10</strong> says</p>\n<blockquote>\n<p id=\"so_31224886_31234579_0\">A <em>using-declaration</em> is a <em>declaration</em> and can therefore be used repeatedly where (and only where) multiple declarations are allowed. </p>\n</blockquote>\n<p>However, there is no restriction on multiple declarations of the same entity in block scope, so the original example is valid. A corresponding case not involving <em>using-declaration</em>s is:</p>\n<pre><code>int n;\nvoid f() {\n  extern int n;\n  extern int n;\n}\n</code></pre>\n<p>This is valid (and is accepted by GCC, EDG, Clang, and MSVC), therefore (by the above-quoted rule) the original example is also valid.</p>\n<p>It is worth noting that the example in <strong>[namespace.udecl] (7.3.3)/10</strong> contains an error. It says:</p>\n<pre><code>namespace A {\n  int i;\n}\n\nvoid f() {\n  using A::i;\n  using A::i; // error: double declaration\n}\n</code></pre>\n<p>... but the comment is not correct; there is no error on the second declaration. See the discussion in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#36\" rel=\"nofollow\">core issue 36</a>. I've <a href=\"https://github.com/cplusplus/draft/commit/299ec33999ca8d57ce40d5663373d8da46de0baa\" rel=\"nofollow\">removed the example</a> from the standard so that it won't confuse more people.</p>\n", "LastActivityDate": "2015-07-06T00:59:49.167"}, "31224886": {"CommentCount": "2", "AcceptedAnswerId": "31234579", "PostTypeId": "1", "LastEditorUserId": "1272610", "CreationDate": "2015-07-04T20:30:13.333", "LastActivityDate": "2015-07-06T03:25:35.567", "LastEditDate": "2015-07-04T20:42:08.107", "ViewCount": "357", "FavoriteCount": "4", "Title": "Program with chaining of using-declarations compiles on MSVS and clang but not on GCC", "Id": "31224886", "Score": "19", "Body": "<p>Is the following program well-formed or ill-formed according to the c++ standard?</p>\n<pre><code>namespace X { int i; }\n\nnamespace Y { using X::i; }\n\nint main() { using X::i; using Y::i; }\n</code></pre>\n<p>I'm getting different results with different compilers:</p>\n<ul>\n<li>MSVS: Compiles ( <a href=\"http://webcompiler.cloudapp.net/\" rel=\"noreferrer\">http://webcompiler.cloudapp.net/</a> )</li>\n<li>Clang: Compiles ( <a href=\"http://melpon.org/wandbox/permlink/KloDufJ5h1DalK4v\" rel=\"noreferrer\">http://melpon.org/wandbox/permlink/KloDufJ5h1DalK4v</a> )</li>\n<li>GCC: Compile error ( <a href=\"http://melpon.org/wandbox/permlink/IKuuQGE1THofuUTr\" rel=\"noreferrer\">http://melpon.org/wandbox/permlink/IKuuQGE1THofuUTr</a> )</li>\n</ul>\n<p>I don't want to fix this program to make it compile on GCC. I just want to know what the c++ standard says about this and why the three compilers behave differently. Also I want to if this is a result of a bug in any of these compilers.</p>\n", "Tags": "<c++><declaration><language-lawyer><using-declaration>", "OwnerUserId": "1272610", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31224886_31225016_6": {"section_id": 5861, "quality": 0.9166666666666666, "length": 22}, "so_31224886_31234579_0": {"section_id": 5499, "quality": 1.0, "length": 10}, "so_31224886_31225016_3": {"section_id": 7047, "quality": 1.0, "length": 11}, "so_31224886_31225016_0": {"section_id": 5499, "quality": 0.9090909090909091, "length": 10}, "so_31224886_31225016_5": {"section_id": 7047, "quality": 0.8863636363636364, "length": 39}, "so_31224886_31225016_4": {"section_id": 7047, "quality": 1.0, "length": 10}}, "n3337": {"so_31224886_31225016_6": {"section_id": 5631, "quality": 0.9166666666666666, "length": 22}, "so_31224886_31234579_0": {"section_id": 5285, "quality": 1.0, "length": 10}, "so_31224886_31225016_3": {"section_id": 6792, "quality": 1.0, "length": 11}, "so_31224886_31225016_0": {"section_id": 5285, "quality": 0.9090909090909091, "length": 10}, "so_31224886_31225016_5": {"section_id": 6792, "quality": 0.8863636363636364, "length": 39}, "so_31224886_31225016_4": {"section_id": 6792, "quality": 1.0, "length": 10}}, "n4659": {"so_31224886_31225016_6": {"section_id": 7344, "quality": 0.875, "length": 21}, "so_31224886_31234579_0": {"section_id": 6933, "quality": 1.0, "length": 10}, "so_31224886_31225016_3": {"section_id": 8544, "quality": 1.0, "length": 11}, "so_31224886_31225016_0": {"section_id": 6933, "quality": 0.9090909090909091, "length": 10}, "so_31224886_31225016_5": {"section_id": 8544, "quality": 0.8863636363636364, "length": 39}, "so_31224886_31225016_4": {"section_id": 8544, "quality": 1.0, "length": 10}}}, "31225016": {"ParentId": "31224886", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-07-04T20:49:25.373", "Score": "12", "LastEditorUserId": "464581", "LastEditDate": "2015-07-06T03:25:35.567", "Id": "31225016", "OwnerUserId": "464581", "Body": "<p><del>The program should not compile because it declares <code>X::i</code> twice in the same block scope.</del></p>\n\nC++14 \u00a77.3.3/10:\n\n<blockquote>\n<p id=\"so_31224886_31225016_0\"><strong>\u201d</strong> A using-declaration is a <em>declaration</em> and can therefore be used repeatedly where (and only where) multiple\n  declarations are allowed. [<em>Example:</em></p>\n<pre><code>namespace A {\n    int i;\n}\n\nnamespace A1 {\n    using A::i;\n    using A::i;           // OK: double declaration\n}\n\nvoid f() {\n    using A::i;\n    using A::i;           // error: double declaration\n}\n</code></pre>\n</blockquote>\n<p><strong>Edit:</strong> The <em>non-normative</em> comment quoted above, and which I thought answered the question, was there originally in C++98 and has survived through Technical Corrigendum 1 (C++03), C++11 and C++14. But apparently it's <strong>wrong</strong>. Richard Smith in his answer cites <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#36\" rel=\"nofollow\">core issue 36</a> about it, first raised by Andrew Koenig on 2<sup>nd</sup> August 1998 (less than a month after ANSI approval of the first standard), which apparently means that a known incorrect comment can survive three revisions of the standard.</p>\n<p>Citing the core issue itself about that:</p>\n\nC++ Standard Core Language Active Issues, issue 36:\n\n<blockquote>\n<p id=\"so_31224886_31225016_1\"><strong>\u201d</strong> <strong>Notes from 04/00 meeting:</strong><br>\n  The core language working group was unable to come to consensus over what kind of declaration a <em>using-declaration</em> should emulate. In a straw poll, 7 members favored allowing <em>using-declarations</em> wherever a non-definition declaration could appear, while 4 preferred to allow multiple <em>using-eclarations</em> only in namespace scope (the rationale being that the permission for multiple <em>using-declarations</em> is primarily to support its use in multiple header files, which are seldom included anywhere other than namespace scope). John Spicer pointed out that <code>friend</code> declarations can appear multiple times in class scope and asked if <em>using-declarations</em> would have the same property under the \"like a declaration\" resolution.</br></p>\n<p id=\"so_31224886_31225016_2\">As a result of the lack of agreement, the issue was returned to \"open\" status.</p>\n</blockquote>\n<p>The general discussion of multiple declarations of the same name is in \u00a73.3.1/4 in both C++98 and C++14. As far as I can see the C++14 text is verbatim identical to the original C++98 text. And by itself it allows declaring the same name multiple times in the same declarative region in a number of cases, one of which is that all the declarations refer to the same entity:</p>\n\nC++14 \u00a73.3.1/4:\n\n<blockquote>\n<p id=\"so_31224886_31225016_3\"><strong>\u201d</strong> Given a set of declarations in a single declarative region, each of which specifies the same unqualified name,  </p>\n<ul>\n<li><p id=\"so_31224886_31225016_4\">they shall all refer to the same entity, or all refer to functions and function templates; or</p></li>\n<li><p id=\"so_31224886_31225016_5\">exactly one declaration shall declare a class name or enumeration name that is not a typedef name\n  and the other declarations shall all refer to the same variable or enumerator, or all refer to functions\n  and function templates; in this case the class name or enumeration name is hidden (3.3.10). [<em>Note:</em> A\n  namespace name or a class template name must be unique in its declarative region (7.3.2, Clause 14). <em>\u2014end note</em>] </p></li>\n</ul>\n</blockquote>\n<p>However, the wording here only says what is not directly invalid. A declaration can be disallowed by other rules even if it's not disallowed by this one. For example, there is such a restriction for class member declarations:</p>\n\nC++14 \u00a79.2/1:\n\n<blockquote>\n<p id=\"so_31224886_31225016_6\"><strong>\u201d</strong> [\u2026] A member shall not be declared twice in the <em>member-\n  specification</em>, except that a nested class or member class template can be declared and then later defined,\n  and except that an enumeration can be introduced with an <em>opaque-enum-declaration</em> and later redeclared\n  with an <em>enum-specifier</em>.</p>\n</blockquote>\n<p>I fail to find such a restriction that supports the apparently incorrect comment in C++14 \u00a77.3.3/10 quoted at the start above, i.e. I fail to find any special treatment of block scopes or namespace scopes, and so a tentative conclusion (keeping in mind the comment's survival in spite of being contested already in 1998) is that the contested comment actually is wrong and that this question's code, where two declarations in the same declarative region refer to the same entity, is valid and should be accepted by all compilers.</p>\n", "LastActivityDate": "2015-07-06T03:25:35.567"}});