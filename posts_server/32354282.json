post_cb({"32358211": {"ParentId": "32354282", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-09-02T16:19:46.557", "Score": "0", "LastEditorUserId": "4451432", "LastEditDate": "2015-09-03T13:12:26.450", "Id": "32358211", "OwnerUserId": "4451432", "Body": "<p>Implementation is allowed to put definitions into the global namespace in some cases.</p>\n<p>First, a C++ library header is allowed to include other C++ headers:</p>\n<p>N3337 17.6.5.2 Headers [res.on.headers] P1:</p>\n<blockquote>\n<p id=\"so_32354282_32358211_0\">A C++ header may include other C++ headers. A C++ header shall provide the declarations and definitions\n  that appear in its synopsis. A C++ header shown in its synopsis as including other C++ headers shall provide\n  the declarations and definitions that appear in the synopses of those other headers.</p>\n</blockquote>\n<p>The included C++ header can be a wrapper for a C library. Names of these C++ headers start with <code>c</code>, like <code>&lt;cstdlib&gt;</code>.\nThese headers are allowed to put corresponding C-library definitions in the global namespace first, and then inject them into <code>std</code> namespace.</p>\n<p>17.6.1.2 Headers [headers] P4:</p>\n<blockquote>\n<p id=\"so_32354282_32358211_1\">Except as noted in Clauses 18 through 30 and Annex D, the contents of each header cname shall be the same\n  as that of the corresponding header name.h, as specified in the C standard library (1.2) or the C Unicode\n  TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for\n  names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace std. It is\n  unspecified whether these names are first declared within the global namespace scope and are then injected\n  into namespace std by explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>Thus, the functions defined in the C standard library can end up in the global namespace.</p>\n<p>The <code>clone</code> function, however, in not part of C standard library (it is part of POSIX standard) and thus not formally allowed to appear in the global namespace by the C++ standard.</p>\n", "LastActivityDate": "2015-09-03T13:12:26.450"}, "32354282": {"CommentCount": "6", "ViewCount": "434", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2015-09-02T13:16:24.880", "LastActivityDate": "2015-09-03T13:12:26.450", "Title": "pollution of global namespace by standard header files", "AcceptedAnswerId": "32372973", "LastEditDate": "2015-09-03T09:47:53.387", "Id": "32354282", "Score": "1", "Body": "<p>Time and again I run into problems from namespace pollution due to indirect inclusion of C-header files from C++ standard headers. For example, on my linux system gcc's (version 5.1.1) <code>&lt;thread&gt;</code> includes <code>usr/include/bits/sched.h</code>, which declares</p>\n<pre><code>extern \"C\" {\n  extern int clone(int (*__fn) (void *__arg), void *__child_stack, int __flags, void *__arg, ...) throw();\n}\n</code></pre>\n<p>In the following minimal example</p>\n<pre><code>#include &lt;thread&gt;                              // indirect inclusion of &lt;sched.h&gt;\n\nnamespace {\n  struct foo\n  { virtual foo*clone() const=0; };\n\n  foo*clone(std::unique_ptr&lt;foo&gt; const&amp;);      // function intended\n\n  struct bar : foo\n  {\n    std::unique_ptr&lt;foo&gt; daughter;\n    bar(foo*d) : daughter(d) {}\n    foo*clone() const\n    { return new bar(::clone(daughter)); }     // to be called here\n  };\n}\n</code></pre>\n<p>the compiler complains about the call to <code>::clone()</code> not matching the definition from <code>bits/sched.h</code> (ignoring the definition just before). (Note that simply calling <code>clone</code> instead of <code>::clone</code> clashes with the member.)</p>\n<p>So, the questions are:</p>\n<ol>\n<li>Is gcc correct to discard my version of <code>clone()</code> when trying to resolve the function call <code>::clone(daughter)</code>?</li>\n<li>Is the pollution of the global namespace in this way standard compliant?</li>\n<li>In the above example, can I resolve the problem without renaming my <code>clone()</code> functions (or the anonymous namespace) but still including <code>&lt;thread&gt;</code>?</li>\n</ol>\n", "Tags": "<c++><namespaces><language-lawyer><standards-compliance>", "OwnerUserId": "1023390", "AnswerCount": "3"}, "32356172": {"ParentId": "32354282", "CommentCount": "2", "CreationDate": "2015-09-02T14:39:10.490", "OwnerUserId": "2079393", "PostTypeId": "2", "Id": "32356172", "Score": "1", "Body": "<ol>\n<li>yes, because <code>::clone</code> looks for <code>clone</code> first in the global (outermost) namespace, and then in the anonymous namespace.</li>\n<li>Nothing prevents you (or library providers) to pollute any namespace (global included) but 'std' which is reserved for the standard.</li>\n<li>Naming the anonymous namespace could be a way out.</li>\n</ol>\n<p>If the question #2 is \"Does the standard allow the pollution of global namespace by including a standard header, i.e. making available more symbols than the standard require?\". Then I guess the answer is yes, otherwise the constraint imposed on standard library vendors could be too stringent.</p>\n", "LastActivityDate": "2015-09-02T14:39:10.490"}, "bq_ids": {"n4140": {"so_32354282_32358211_1": {"section_id": 6259, "quality": 0.9166666666666666, "length": 44}, "so_32354282_32358211_0": {"section_id": 6331, "quality": 1.0, "length": 27}}, "n3337": {"so_32354282_32358211_1": {"section_id": 6019, "quality": 0.9166666666666666, "length": 44}, "so_32354282_32358211_0": {"section_id": 6088, "quality": 1.0, "length": 27}}, "n4659": {"so_32354282_32358211_1": {"section_id": 7763, "quality": 0.8541666666666666, "length": 41}, "so_32354282_32358211_0": {"section_id": 7841, "quality": 1.0, "length": 27}}}, "32372973": {"ParentId": "32354282", "CommentCount": "0", "CreationDate": "2015-09-03T10:20:04.803", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "32372973", "Score": "4", "Body": "<blockquote id=\"so_32354282_32372973_0\">\n<ol>\n<li>Is gcc correct to discard my version of clone() when trying to resolve the function call ::clone(daughter)?</li>\n</ol>\n</blockquote>\n<p>Yes, I think so.</p>\n<blockquote id=\"so_32354282_32372973_1\">\n<ol start=\"2\">\n<li>Is the pollution of the global namespace in this way standard compliant?</li>\n</ol>\n</blockquote>\n<p>It's arguable. For a pure C++ implementation, no, but there aren't many of them. In practice most are \"C++ on POSIX\" or \"C++ on Windows\" implementations and declare lots of names that are not in the C++ standard.</p>\n<p>The namespace pollution problem is well known (<a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=11196\" rel=\"nofollow\">11196</a>, <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51749\" rel=\"nofollow\">51749</a> and others), with no simple solution.</p>\n<p>The problem is that most C++ standard library implementations don't control the C library and just include the platform's native C headers, which pull in other names.</p>\n<blockquote id=\"so_32354282_32372973_2\">\n<ol start=\"3\">\n<li>In the above example, can I resolve the problem without renaming my clone() functions (or the anonymous namespace) but still including ?</li>\n</ol>\n</blockquote>\n<p>In your specific case you can solve the name lookup problem by putting your <code>clone</code> overload in the global namespace so lookup finds it at the same time as the function in <code>&lt;sched.h&gt;</code> and by making it static to give it internal linkage again.</p>\n", "LastActivityDate": "2015-09-03T10:20:04.803"}});