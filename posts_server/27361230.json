post_cb({"27361572": {"ParentId": "27361230", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>\u00a713.3.1.2 [over.match.oper]/p3 (emphasis added):</p>\n<blockquote>\n<p id=\"so_27361230_27361572_0\">for a binary operator <code>@</code> with a left operand of a type whose\n  cv-unqualified version is <code>T1</code> and a right operand of a type whose\n  cv-unqualified version is <code>T2</code>, three sets of candidate functions,\n  designated <em>member candidates</em>, <em>nonmember candidates</em> and <em>built-in\n  candidates</em>, are constructed as follows:</p>\n<ul>\n<li>[...]</li>\n<li>The set of non-member candidates is the result of the unqualified lookup of <code>operator@</code> in the context of the expression according to\n  the usual rules for name lookup in unqualified function calls (3.4.2)\n  except that all member functions are ignored. <strong>However, if no operand\n  has a class type, only those non-member functions in the lookup set\n  that have a first parameter of type <code>T1</code> or \u201creference to (possibly\n  cv-qualified) T1\u201d, when <code>T1</code> is an enumeration type, or (if there is a\n  right operand) a second parameter of type <code>T2</code> or \u201creference to\n  (possibly cv-qualified) <code>T2</code>\u201d, when <code>T2</code> is an enumeration type, are\n  candidate functions.</strong></li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>In plainer English, if neither operand has a class type, then you need to have an exact match on an enumeration operand for the overload to be considered, which is why <code>my = MyEnum::zero + MyEnum::two;</code> does not work. <code>my = MyEnum::zero + MyEnum(MyEnum::two);</code>, oddly enough, compiles in GCC but not Clang. I can't find anything that makes it not legal, so I'm suspecting that this might be a compiler bug.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-12-08T16:55:08.017", "Id": "27361572", "Score": "3", "CreationDate": "2014-12-08T15:45:53.717", "LastActivityDate": "2014-12-08T16:55:08.017"}, "27361230": {"CommentCount": "1", "ViewCount": "202", "CreationDate": "2014-12-08T15:27:04.997", "LastActivityDate": "2014-12-08T16:55:08.017", "Title": "Implicit conversion of lefthand argument in in-class declared friend operator", "AcceptedAnswerId": "27361572", "PostTypeId": "1", "Id": "27361230", "Score": "2", "Body": "<p>I am using CRTP to provide template-argument dependent addition of functions to a class, in this case the addition of <code>operator +</code> and <code>operator +=</code>, using the template class <code>ImplAdd</code>. For the former, implicit conversions should be performed on both arguments, which means I have to use an in-class friend operator like this:</p>\n<pre><code>template&lt;class Type, bool active&gt;\nstruct ImplAdd{\n    virtual int get_val_() const = 0;\n    virtual void set_val_(int) = 0;\n};\n\n//if activated is true, the operators + and += will be defined\ntemplate&lt;class Type&gt;\nclass ImplAdd &lt; Type, true &gt; {\n    virtual int get_val_() const = 0;\n    virtual void set_val_(int) = 0;\n    Type* this_(){ return (Type*)this; }\npublic:\n    Type&amp; operator +=(const Type&amp; x){\n        set_val_(get_val_() + x.get_val_());\n        return *this_();\n    }\n\n    //This should enable conversions on the lefthand argument\n    friend Type&amp; operator+(const Type&amp; lhs, const Type&amp; rhs){\n        Type ret = lhs;\n        return ret += rhs;\n    }\n};\n</code></pre>\n<p>This is needed because classes that actually inherit from <code>ImplAdd</code> define constant values and a unique value type for those constants, much like a scoped enum.</p>\n<pre><code>//by using true as the template argument, the operators + and += will be defined\nclass MyEnum : public ImplAdd&lt;MyEnum, true&gt;{\n    int get_val_() const override{\n        return (int)value;\n    }\n    void set_val_(int v) override{\n        value = (ValueT)v;\n    }\npublic:\n    enum class ValueT{\n        zero, one, two\n    };\nprivate:\n    typedef  int UnderlyingT;\n    ValueT value;\npublic:\n    static const ValueT zero = ValueT::zero;\n    static const ValueT one = ValueT::one;\n    static const ValueT two = ValueT::two;\n    MyEnum(ValueT x) : value(x){}\n    MyEnum(const MyEnum&amp; other) : value(other.value){}\n};\n</code></pre>\n<p>From my perspective, the following code should now easily compile, but it doesn't.</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    MyEnum my = MyEnum::zero;                //works\n    my += MyEnum::one;                       //works\n    my = MyEnum(MyEnum::zero) + MyEnum::two; //works\n    my = MyEnum::zero + MyEnum(MyEnum::two); //ERROR C2676\n    my = MyEnum::zero + MyEnum::two;         //ERROR C2676\n    MyEnum my2 = my + my;                    //works\n    return 0;\n}\n</code></pre>\n<p>For both lines marked with C2676, the following error message is printed:</p>\n<pre><code>error C2676: binary '+' : 'const MyEnum::ValueT' does not define this operator or a conversion to a type acceptable to the predefined operator\n</code></pre>\n<p>What am I doing wrong? Isn't the use of defining an operator as an in-class friend the common way to enable implicit conversion on both arguments? If not, how can I do it in this case?</p>\n", "Tags": "<c++><c++11><operator-overloading><friend><crtp>", "OwnerUserId": "2533467", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27361230_27361572_0": {"section_id": 584, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_27361230_27361572_0": {"section_id": 574, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_27361230_27361572_0": {"section_id": 607, "quality": 0.8888888888888888, "length": 24}}}});