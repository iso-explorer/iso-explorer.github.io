post_cb({"34614967": {"ParentId": "34614869", "CommentCount": "0", "Body": "<p>Using <code>A::x</code> in this case is valid, but I think <code>this-&gt;x</code> is more idiomatic and less error-prone (the reader of the code can immediately see that <code>x</code> is a member of the class, without thinking what <code>A</code> is).</p>\n", "OwnerUserId": "459565", "PostTypeId": "2", "Id": "34614967", "Score": "2", "CreationDate": "2016-01-05T15:12:10.947", "LastActivityDate": "2016-01-05T15:12:10.947"}, "34615030": {"ParentId": "34614869", "CommentCount": "0", "Body": "<p>According to the C++ Standard (3.3.7 Class scope)</p>\n<blockquote>\n<p id=\"so_34614869_34615030_0\">2 The name of a class member shall only be used as follows:</p>\n<p id=\"so_34614869_34615030_1\">\u2014 in the scope of its class (as described above) or a class derived\n  (Clause 10) from its class,</p>\n<p id=\"so_34614869_34615030_2\">\u2014 after the . operator applied to an expression of the type of its\n  class (5.2.5) or a class derived from its class,</p>\n<p id=\"so_34614869_34615030_3\">\u2014 after the -&gt; operator applied to a pointer to an object of its class\n  (5.2.5) or a class derived from its class,</p>\n<p id=\"so_34614869_34615030_4\">\u2014 after the :: scope resolution operator (5.1) applied to the name of\n  its class or a class derived from its class.</p>\n</blockquote>\n<p>For example data members of methods of a derived class can hide data members and/or methods of its base class. To access data members and nethods of the base class you can use the scope resolution operator.</p>\n<pre><code>struct Base\n{\n    virtual ~Base() {};\n    virtual void Hello() const { std::cout &lt;&lt; \"Base\" &lt;&lt; std::endl; }\n};\n\n\nstruct Derived : Base\n{\n    virtual void Hello() const \n    { \n        Base::Hello();\n        std::cout &lt;&lt; \"and Derived\" &lt;&lt; std::endl; \n    }\n};\n\nDerived d;\n\nd.Hello();\n</code></pre>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "34615030", "Score": "2", "CreationDate": "2016-01-05T15:15:27.117", "LastActivityDate": "2016-01-05T15:15:27.117"}, "34614869": {"CommentCount": "3", "ViewCount": "491", "CreationDate": "2016-01-05T15:07:05.210", "LastActivityDate": "2016-01-05T15:15:27.117", "Title": "Using scope operator to access non-static member variables", "AcceptedAnswerId": "34614967", "PostTypeId": "1", "Id": "34614869", "Score": "0", "Body": "<p>It's a fact that you can explicitly access member variables (inside a member function, and not particularly a constructor) using this syntax : <code>this-&gt;member_name</code> (i.e. to distinguish with a function argument with the same name).</p>\n<p>Besides this, I thought that the syntax <code>ClassName::static_member</code> was reserved to access static members outside of a class.</p>\n<p>Then I was surprised when I realized that the following <code>set_2()</code> method was working as one could expect:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    int x;\n    // The two following methods seem to act similarly:\n    void set_1(int x) { this-&gt;x = x; }\n    void set_2(int x) { A::x = x; }\n};\n\nint main ()\n{\n    A a;\n\n    a.set_1(13);\n    std::cout &lt;&lt; a.x &lt;&lt; std::endl;\n\n    a.set_2(17);\n    std::cout &lt;&lt; a.x &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Is is a good and valid practice to use the scope operator (<code>A::x</code>) in this case? I would personnally prefer it, instead of using the <code>this-&gt;x</code> syntax.</p>\n", "Tags": "<c++><scope>", "OwnerUserId": "3271687", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_34614869_34615030_1": {"section_id": 7071, "quality": 1.0, "length": 10}, "so_34614869_34615030_0": {"section_id": 7071, "quality": 0.8, "length": 4}, "so_34614869_34615030_2": {"section_id": 7071, "quality": 0.9166666666666666, "length": 11}, "so_34614869_34615030_4": {"section_id": 7071, "quality": 1.0, "length": 12}, "so_34614869_34615030_3": {"section_id": 7071, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_34614869_34615030_1": {"section_id": 6815, "quality": 1.0, "length": 10}, "so_34614869_34615030_0": {"section_id": 6815, "quality": 0.8, "length": 4}, "so_34614869_34615030_2": {"section_id": 6815, "quality": 0.9166666666666666, "length": 11}, "so_34614869_34615030_4": {"section_id": 6815, "quality": 1.0, "length": 12}, "so_34614869_34615030_3": {"section_id": 6815, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_34614869_34615030_1": {"section_id": 8572, "quality": 1.0, "length": 10}, "so_34614869_34615030_2": {"section_id": 8572, "quality": 0.9166666666666666, "length": 11}, "so_34614869_34615030_4": {"section_id": 8572, "quality": 1.0, "length": 12}, "so_34614869_34615030_0": {"section_id": 8572, "quality": 0.8, "length": 4}, "so_34614869_34615030_3": {"section_id": 8572, "quality": 0.9166666666666666, "length": 11}}}, "34614942": {"ParentId": "34614869", "CommentCount": "0", "Body": "<p>The <code>A::x</code>, in your case, still refers to your regular member variable; it just explicitly specifies <em>which</em> <code>x</code> you mean.  Consider a class that derives from two other classes which have a member of the same name (not that that's very good coding style):</p>\n<pre><code>struct A { int x; };\nstruct B { int x; };\nstruct C : A, B\n{\n  int foo() const\n  {\n    // return x;  // ambiguous: which x do you mean?\n    return A::x;  // unambiguous\n  }\n};\n</code></pre>\n", "OwnerUserId": "3233921", "PostTypeId": "2", "Id": "34614942", "Score": "0", "CreationDate": "2016-01-05T15:10:48.233", "LastActivityDate": "2016-01-05T15:10:48.233"}});