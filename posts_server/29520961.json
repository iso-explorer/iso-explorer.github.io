post_cb({"bq_ids": {"n4140": {"so_29520961_29521080_0": {"section_id": 398, "quality": 0.9444444444444444, "length": 34}}, "n3337": {"so_29520961_29521080_0": {"section_id": 389, "quality": 0.9444444444444444, "length": 34}}, "n4659": {"so_29520961_29521080_0": {"section_id": 415, "quality": 0.9444444444444444, "length": 34}}}, "29522440": {"ParentId": "29520961", "CommentCount": "1", "Body": "<p>Destructor is supposed to do the cleanup of its members/ This, in a sense, destructor is supposed tomodify the contents of the current object whole doing the cleanup. So, destructor has to be non-const. And, a non-const mnember function can call all non-const member function only. This explains. </p>\n", "OwnerUserId": "2032021", "PostTypeId": "2", "Id": "29522440", "Score": "3", "CreationDate": "2015-04-08T18:22:38.927", "LastActivityDate": "2015-04-08T18:22:38.927"}, "29521089": {"ParentId": "29520961", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I like this question. </p>\n<p>Destructors can't be const. They behave like any non-const method. A non-const method calls non-const methods. </p>\n<p>But, there are good reasons to call const methods in destructors. (Logging for instance). Having both, a non-const and a const version, called from a non-const method, the non-const is called. </p>\n<p>To call the const, it is possible to use static_cast. But... you cannot determine when to cast. (In other words: You don't know if you are const yourself). </p>\n", "OwnerUserId": "3945388", "LastEditorUserId": "3945388", "LastEditDate": "2015-04-08T18:16:38.233", "Id": "29521089", "Score": "2", "CreationDate": "2015-04-08T17:11:01.720", "LastActivityDate": "2015-04-08T18:16:38.233"}, "29521080": {"ParentId": "29520961", "PostTypeId": "2", "CommentCount": "5", "Body": "\n<p>The reason the non-const overload is being called when on a <code>const</code> instance is because cv-qualifiers on the current instance aren't considered during destruction.  [class.dtor]/p2:</p>\n<blockquote>\n<p id=\"so_29520961_29521080_0\">A destructor is used to destroy objects of its class type. The address of a destructor shall not be taken.\n  A destructor can be invoked for a const, volatile or const volatile object. <strong><code>const</code> and <code>volatile</code>\n  semantics (7.1.6.1) are not applied on an object under destruction.</strong> They stop being in effect when the\n  destructor for the most derived object (1.8) starts.</p>\n</blockquote>\n<p>You can use a simply bind <code>*this</code> to a reference to <code>const</code> to get the behavior you need:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>~My_type() { \n    My_type const&amp; ref(*this);\n    ref.show();\n}\n</code></pre>\n<p>Or maybe you can use a wrapper that stores a reference and calls <code>show()</code> in its own destructor:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;class T&gt;\nstruct MyTypeWrapper : std::remove_cv_t&lt;T&gt; {\n    using Base = std::remove_cv_t&lt;T&gt;;\n    using Base::Base;\n\n    T&amp;       get()       { return ref; }\n    T const&amp; get() const { return ref; }\n\n    ~MyTypeWrapper() { ref.show(); }\nprivate:\n    T&amp; ref = static_cast&lt;T&amp;&gt;(*this);\n};\n</code></pre>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2015-04-10T13:58:20.320", "Id": "29521080", "Score": "18", "CreationDate": "2015-04-08T17:10:26.410", "LastActivityDate": "2015-04-10T13:58:20.320"}, "29520961": {"CommentCount": "11", "AcceptedAnswerId": "29521080", "CreationDate": "2015-04-08T17:04:19.257", "LastActivityDate": "2015-04-10T13:58:20.320", "PostTypeId": "1", "ViewCount": "1119", "FavoriteCount": "4", "Title": "How can I call const member function from destructor", "Id": "29520961", "Score": "28", "Body": "<p>Is there any possible way to invoke const member function from destructor, when const object is destroyed?</p>\n<p>Consider:</p>\n<pre><code>struct My_type { \n    ~My_type () { \n        show ();\n    }\n\n    void show () { \n        cout &lt;&lt; \"void show ()\" &lt;&lt; endl;\n    }\n    void show () const { \n        cout &lt;&lt; \"void show () const\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>And usage:</p>\n<pre><code>My_type mt;\nconst My_type cmt;\nmt.show ();\ncmt.show ();\n</code></pre>\n<p>Output:</p>\n<pre><code>void show ()\nvoid show () const\nvoid show ()\nvoid show ()\n</code></pre>\n<p>Can someone explain me why const version of show has not been invoked when <strong>cmt</strong> is destroyed?</p>\n", "Tags": "<c++><c++11><destructor>", "OwnerUserId": "3671410", "AnswerCount": "3"}});