post_cb({"42649844": {"CommentCount": "3", "ViewCount": "240", "CreationDate": "2017-03-07T13:40:10.690", "LastActivityDate": "2017-03-07T13:49:45.993", "Title": "Calling function in a namespace without qualification", "AcceptedAnswerId": "42650066", "PostTypeId": "1", "Id": "42649844", "Score": "7", "Body": "<p>Looking at the source code of <code>boost::polygon</code>, I have seen many applications of the following theme:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace B {\n\nstruct A {\n  void foo() const { std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\n};\n\nvoid bar(const A &amp;a) { a.foo(); }\nvoid baz() { std::cout &lt;&lt; \"baz\" &lt;&lt; std::endl; }\n\n}\n\nint main(int argc, char **argv) {\n  B::A a;\n  bar(a);\n  B::baz(); // simply calling baz() does not work\n\n  return 0;\n}\n</code></pre>\n<p>How is it that <code>bar(a)</code> can be called without extra qualifications? I would have expected that only <code>B::bar(a)</code> would compile.</p>\n<p>When the function does not have an argument inside the namespace, this does not occur.</p>\n", "Tags": "<c++><c++11><namespaces>", "OwnerUserId": "4634174", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42649844_42650066_1": {"section_id": 7104, "quality": 0.9230769230769231, "length": 24}, "so_42649844_42650066_2": {"section_id": 7104, "quality": 1.0, "length": 25}, "so_42649844_42650066_0": {"section_id": 7103, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_42649844_42650066_1": {"section_id": 6848, "quality": 0.9230769230769231, "length": 24}, "so_42649844_42650066_2": {"section_id": 6848, "quality": 0.96, "length": 24}, "so_42649844_42650066_0": {"section_id": 6847, "quality": 0.918918918918919, "length": 34}}, "n4659": {"so_42649844_42650066_1": {"section_id": 8605, "quality": 0.7692307692307693, "length": 20}, "so_42649844_42650066_0": {"section_id": 8604, "quality": 0.972972972972973, "length": 36}, "so_42649844_42650066_2": {"section_id": 8605, "quality": 1.0, "length": 25}}}, "42650066": {"ParentId": "42649844", "CommentCount": "0", "Body": "<p>According to ISO C++14 standard, at \u00a73.4.2:</p>\n<blockquote>\n<p id=\"so_42649844_42650066_0\">When the postfix-expression in a function call is an unqualified-id, <strong>other namespaces not considered during the usual unqualified lookup may be searched, and in those namespaces, namespace-scope friend function or function template declarations not otherwise visible may be found</strong>. These modifications to the search <strong>depend on the types of the arguments</strong> (and for template template arguments, the namespace of the template argument).</p>\n</blockquote>\n<p>And following:</p>\n<blockquote>\n<p id=\"so_42649844_42650066_1\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments..</p>\n<p id=\"so_42649844_42650066_2\">If <code>T</code> is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. <strong>Its associated namespaces are the innermost enclosing namespaces of its associated classes</strong>.</p>\n</blockquote>\n<p>Actually you can even prevent this from happening by enclosing the function name:</p>\n<pre><code>(bar)(a); // doens't compile\n</code></pre>\n<p>while</p>\n<pre><code>(B::bar)(a); // does compile\n</code></pre>\n<p>Mind also that this applies only to the innermost namespace, which means that in the following situation you need to qualify the namespace:</p>\n<pre><code>namespace B {\n   namespace C {\n     struct A {};\n   }\n\n   void bar(const C::A&amp; a) { ... }\n}\n</code></pre>\n", "OwnerUserId": "121747", "PostTypeId": "2", "Id": "42650066", "Score": "6", "CreationDate": "2017-03-07T13:49:45.993", "LastActivityDate": "2017-03-07T13:49:45.993"}});