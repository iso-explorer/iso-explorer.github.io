post_cb({"24789811": {"ParentId": "24789576", "LastEditDate": "2014-07-16T20:41:50.543", "CommentCount": "2", "CreationDate": "2014-07-16T20:14:23.433", "OwnerUserId": "432358", "LastEditorUserId": "432358", "PostTypeId": "2", "Id": "24789811", "Score": "2", "Body": "<p>When you create a class, compiler implicitly generates following functions (unless you specify some of them explicitly see <a href=\"http://en.wikipedia.org/wiki/Special_member_functions\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Special_member_functions</a> ):</p>\n<ul>\n<li>default constructor</li>\n<li>copy constructor</li>\n<li>move constructor (since c++11)</li>\n<li>copy assignment operator</li>\n<li>move assignment operator (since c++11)</li>\n<li>destructor</li>\n</ul>\n<p>In your case copy assignment operator signature is:</p>\n<pre><code>struct Foo {\n   Foo &amp;operator=( const Foo &amp;f ); // either this\n   Foo &amp;operator=( Foo f ); // does not make much sense but will work too\n};\n</code></pre>\n<p>When you create assignment operator for class <code>Derived</code>, you do not explicitly replace implicit copy assignment operator but create a new one. To understand the issue easier modify your code to this:</p>\n<pre><code>class Derived : public Base\n{\npublic:\n    Derived(){}\n    Derived &amp;operator=(const Base &amp;ob2)\n    {\n        std::cout &lt;&lt; \"Using Derived operator=(Base) \" &lt;&lt; '\\n';\n        return *this;\n    }\n    Derived &amp;operator=(const Derived &amp;ob2)\n    {\n        std::cout &lt;&lt; \"Using Derived operator=(Derived) \" &lt;&lt; '\\n';\n        return *this;\n    }\n};\n</code></pre>\n<p>Issue should become obvious.</p>\n", "LastActivityDate": "2014-07-16T20:41:50.543"}, "24789689": {"ParentId": "24789576", "LastEditDate": "2014-07-16T22:34:30.340", "CommentCount": "5", "CreationDate": "2014-07-16T20:07:16.667", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "24789689", "Score": "15", "Body": "<p><strong>Short version</strong>: Overload resolution didn't select <code>Base::operator=(Base)</code>. It selected the implicitly declared <code>Derived::operator=(const Derived &amp;)</code>, which calls <code>Base::operator=(Base)</code> to copy-assign the base-class subobject.</p>\n<p><strong>Long version</strong> with standard quotes: </p>\n<p>First, copy assignment operator is defined in the standard in \u00a712.8 [class.copy]/p17:</p>\n<blockquote>\n<p id=\"so_24789576_24789689_0\">A user-declared copy assignment operator <code>X::operator=</code> is a non-static non-template member function of class X with exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>.</p>\n</blockquote>\n<p>Second, if you don't provide a copy assignment operator, one will always be implicitly declared for you. From \u00a712.8 [class.copy]/p18:</p>\n<blockquote>\n<p id=\"so_24789576_24789689_1\">If the class definition does not explicitly declare a copy assignment\n  operator, one is declared implicitly. If the class definition declares\n  a move constructor or move assignment operator, the implicitly\n  declared copy assignment operator is defined as deleted; otherwise, it\n  is defined as defaulted (8.4). The latter case is deprecated if the\n  class has a user-declared copy constructor or a user-declared\n  destructor. The implicitly-declared copy assignment operator for a\n  class X will have the form</p>\n<pre><code>X&amp; X::operator=(const X&amp;) \n</code></pre>\n<p id=\"so_24789576_24789689_2\">if</p>\n<ul>\n<li>each direct base class <code>B</code> of <code>X</code> has a copy assignment operator whose parameter is of type <code>const B&amp;</code>, <code>const volatile B&amp;</code> or <code>B</code>, and</li>\n<li>for all the non-static data members of <code>X</code> that are of a class type M (or array thereof), each such class type has a copy assignment\n  operator whose parameter is of type <code>const M&amp;</code>, <code>const volatile M&amp;</code> or <code>M</code>.</li>\n</ul>\n<p id=\"so_24789576_24789689_3\">Otherwise, the implicitly-declared copy assignment operator will have\n  the form</p>\n<pre><code>X&amp; X::operator=(X&amp;)\n</code></pre>\n</blockquote>\n<p>Note that one of the results of these rules is that (\u00a712.8 [class.copy]/p24):</p>\n<blockquote>\n<p id=\"so_24789576_24789689_4\">Because a copy/move assignment operator is implicitly declared for a\n  class if not declared by the user, a base class copy/move assignment\n  operator is always hidden by the corresponding assignment operator of\n  a derived class.</p>\n</blockquote>\n<p>In other words, overload resolution can <em>never</em> select the copy assignment operator of <code>Base</code> for an assignment from one <code>Derived</code> to another. It is <em>always</em> hidden and isn't even in the set of candidate functions.</p>\n<p>Finally, \u00a712.8 [class.copy]/p28 provides that </p>\n<blockquote>\n<p id=\"so_24789576_24789689_5\">The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-/move assignment of its subobjects.</p>\n</blockquote>\n<p>In the case in the question, no copy assignment operator is provided for <code>Derived</code>, so one will be implicitly declared as defaulted (since <code>Derived</code> has no user-declared move constructor or move assignment operator). This implicit copy assignment operator will be selected by overload resolution, and performs copy assignment of, among other things, the base class subobject, which calls the copy assignment operator you defined for <code>Base</code>.</p>\n", "LastActivityDate": "2014-07-16T22:34:30.340"}, "bq_ids": {"n4140": {"so_24789576_24789689_3": {"section_id": 467, "quality": 1.0, "length": 8}, "so_24789576_24789689_5": {"section_id": 477, "quality": 0.9230769230769231, "length": 12}, "so_24789576_24789689_4": {"section_id": 473, "quality": 1.0, "length": 21}, "so_24789576_24789689_1": {"section_id": 467, "quality": 0.9375, "length": 45}, "so_24789576_24789689_0": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_24789576_24789689_3": {"section_id": 458, "quality": 1.0, "length": 8}, "so_24789576_24789689_5": {"section_id": 468, "quality": 0.9230769230769231, "length": 12}, "so_24789576_24789689_4": {"section_id": 464, "quality": 1.0, "length": 21}, "so_24789576_24789689_1": {"section_id": 458, "quality": 0.9375, "length": 45}, "so_24789576_24789689_0": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_24789576_24789689_5": {"section_id": 500, "quality": 0.9230769230769231, "length": 12}, "so_24789576_24789689_4": {"section_id": 496, "quality": 1.0, "length": 21}, "so_24789576_24789689_3": {"section_id": 490, "quality": 1.0, "length": 8}, "so_24789576_24789689_0": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}, "so_24789576_24789689_1": {"section_id": 490, "quality": 0.9375, "length": 45}}}, "24789576": {"CommentCount": "2", "CreationDate": "2014-07-16T19:59:34.700", "PostTypeId": "1", "AcceptedAnswerId": "24789689", "LastEditorUserId": "1597119", "LastActivityDate": "2014-07-29T05:00:41.307", "LastEditDate": "2014-07-29T05:00:41.307", "ViewCount": "1032", "FavoriteCount": "2", "Title": "How does the assignment operator overload resolution work in this example? The result is unexpected for me", "Id": "24789576", "Score": "13", "Body": "<p>Here is the code that I do not understand:</p>\n<pre><code>class Base\n{\npublic:\n    Base(){}\n\n    Base operator=(Base ob2)\n    {\n        std::cout &lt;&lt; \"Using Base operator=() \" &lt;&lt; '\\n';\n        return *this;\n    }\n};\n\nclass Derived : public Base\n{\npublic:\n    Derived(){}\n    Derived operator=(Base ob2)\n    {\n        std::cout &lt;&lt; \"Using Derived operator=() \" &lt;&lt; '\\n';\n        return *this;\n    }\n};\n\nint main()\n{\n    Derived derived1, derived2;\n    Base base1;\n\n    derived1 = derived2;  // Uses base operator=()\n\n    derived1 = base1;  // Uses derived operator=()\n\n    return 0;\n}\n</code></pre>\n<p>What are the language rules that determine, that the first assignment uses the operator of the Base class and the second the operator of the Derived class?</p>\n<p>Yes and I know that one normally does not declare an assignment operator like this. That is why I called it accademical.</p>\n", "Tags": "<c++><operator-overloading><overload-resolution>", "OwnerUserId": "2466043", "AnswerCount": "2"}});