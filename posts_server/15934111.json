post_cb({"15934166": {"ParentId": "15934111", "CommentCount": "27", "Body": "<p>I would use something like:</p>\n<pre><code>unsigned char* bytePtr = reinterpret_cast&lt;unsigned char*&gt;(ptr);\nbytePtr += offset;\n</code></pre>\n", "OwnerUserId": "2011195", "PostTypeId": "2", "Id": "15934166", "Score": "6", "CreationDate": "2013-04-10T18:58:16.437", "LastActivityDate": "2013-04-10T18:58:16.437"}, "37805684": {"ParentId": "15934111", "CommentCount": "0", "Body": "<p>Please note that, <code>NULL</code> is special. Adding an offset on it is dangerous.<br><code>reinterpret_cast</code> can't remove <code>const</code> or <code>volatile</code> qualifiers. More portable way is C-style cast.<br><code>reinterpret_cast</code> with traits like @user2218982's answer, seems more safer.</br></br></p>\n<pre><code>template &lt;typename T&gt;\ninline void addOffset( std::ptrdiff_t offset, T *&amp;ptr ) { \n    if ( !ptr )\n        return;\n    ptr = (T*)( (unsigned char*)ptr + offset );\n} \n</code></pre>\n", "OwnerUserId": "3758879", "PostTypeId": "2", "Id": "37805684", "Score": "1", "CreationDate": "2016-06-14T07:32:39.013", "LastActivityDate": "2016-06-14T07:32:39.013"}, "15934111": {"CommentCount": "18", "AcceptedAnswerId": "15934166", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-10T18:55:14.820", "LastActivityDate": "2016-06-14T07:32:39.013", "LastEditDate": "2017-05-23T12:24:15.773", "ViewCount": "13399", "FavoriteCount": "5", "Title": "Portable and safe way to add byte offset to any pointer", "Id": "15934111", "Score": "13", "Body": "<p>I'm quite new at working with C++ and haven't grasped all the intricacies and subtleties of the language.</p>\n<p><strong>What is the most <em>portable, correct and safe</em> way to add an arbitrary byte offset to a pointer of any type in C++11?</strong></p>\n<pre><code>SomeType* ptr;\nint offset = 12345 /* bytes */;\nptr = ptr + offset;             // &lt;--\n</code></pre>\n<hr>\n<p>I found many answers on Stack Overflow and Google, but they all propose different things. Some variants I have encountered:</p>\n<ol>\n<li><p><a href=\"https://stackoverflow.com/q/6449935/146622\">Cast to <code>char *</code></a>:</p>\n<pre><code>ptr = (SomeType*)(((char*)ptr) + offset);\n</code></pre></li>\n<li><p>Cast to <code>unsigned int</code>:</p>\n<pre><code>ptr = (SomeType*)((unsigned int)ptr) + offset);\n</code></pre></li>\n<li><p><a href=\"https://stackoverflow.com/a/14453183/146622\">Cast to <code>size_t</code></a>:</p>\n<pre><code>ptr = (SomeType*)((size_t)ptr) + offset);\n</code></pre></li>\n<li><p>\"The size of <code>size_t</code> and <code>ptrdiff_t</code> always coincide with the pointer's size. Because of this, it is these types that should be used as indexes for large arrays, for storage of pointers and pointer arithmetic.\" - <a href=\"http://www.codeproject.com/Articles/60082/About-size_t-and-ptrdiff_t\" rel=\"nofollow noreferrer\">About size_t and ptrdiff_t</a> on CodeProject</p>\n<pre><code>ptr = (SomeType*)((size_t)ptr + (ptrdiff_t)offset);\n</code></pre></li>\n<li><p>Or like the previous, but with <a href=\"https://stackoverflow.com/a/1464194/146622\"><code>intptr_t</code> instead of <code>size_t</code></a>, which is signed instead of unsigned:</p>\n<pre><code>ptr = (SomeType*)((intptr_t)ptr + (ptrdiff_t)offset);\n</code></pre></li>\n<li><p>Only cast to <code>intptr_t</code>, since <code>offset</code> is already a signed integer and <a href=\"https://stackoverflow.com/a/1464194/146622\"><code>intptr_t</code> is not <code>size_t</code></a>:</p>\n<pre><code>ptr = (SomeType*)((intptr_t)ptr) + offset);\n</code></pre></li>\n</ol>\n<p>And in all these cases, is it safe to use old C-style casts, or is it safer or more portable to use <code>static_cast</code> or <code>reinterpret_cast</code> for this?</p>\n<p>Should I assume the pointer value itself is unsigned or signed?</p>\n</hr>", "Tags": "<c++><pointers><c++11><pointer-arithmetic>", "OwnerUserId": "146622", "AnswerCount": "4"}, "15943751": {"ParentId": "15934111", "CommentCount": "0", "Body": "<p>Using <code>reinterpret_cast</code> (or C-style cast) means circumventing the type system and is not portable and not safe. Whether it is correct, depends on your architecture.\nIf you (must) do it, you insinuate that <em>you know what you do</em> and you are basically on your own from then on. So much for the warning.</p>\n<p>If you add a number <code>n</code> to a pointer or type <code>T</code>, you move this pointer by <code>n</code> <strong>elements</strong> of type <code>T</code>. What you are looking for is a type where 1 element means 1 byte.</p>\n<p>From the <code>sizeof</code> section 5.3.3.1.:</p>\n<blockquote>\n<p id=\"so_15934111_15943751_0\">The sizeof operator yields the <strong>number of bytes</strong> in the object\n  representation of its operand. [...] <code>sizeof(char)</code>, <code>sizeof(signed\n  char)</code> and <code>sizeof(unsigned char)</code> are <strong>1</strong>. The result of sizeof\n  applied to any other fundamental type (3.9.1) is\n  implementation-defined.</p>\n</blockquote>\n<p>Note, that there is no statement about <code>sizeof(int)</code>, etc.</p>\n<p>Definition of <em>byte</em> (section 1.7.1.):</p>\n<blockquote>\n<p id=\"so_15934111_15943751_1\">The fundamental storage unit in the C++ memory model is the byte. A\n  byte is at least large enough to contain any member of the basic\n  execution character set (2.3) and the eight-bit code units of the\n  Unicode UTF-8 encoding form and is composed of a contiguous sequence\n  of bits, the number of which is implementation-defined. [...] The\n  memory available to a C++ program consists of one or more sequences of\n  contiguous bytes. <strong>Every byte has a unique address.</strong></p>\n</blockquote>\n<p>So, if <code>sizeof</code> returns the number of bytes and <code>sizeof(char)</code> is 1, than <code>char</code> has the size of one byte to C++. Therefore, <code>char</code> is <em>logically</em> a byte to C++ but not necessarily the de facto standard 8-bit byte.\nAdding <code>n</code> to a <code>char*</code> will return a pointer that is <code>n</code> bytes (in terms of the C++ memory model) away. Thus, if you want to play the dangerous game of manipulating an object's pointer bytewise, you should cast it to one of the <code>char</code> variants.\nIf your type also has qualifiers like <code>const</code>, you should transfer them to your \"byte type\" too.</p>\n<pre><code>    template &lt;typename Dst, typename Src&gt;\n    struct adopt_const {\n        using type = typename std::conditional&lt; std::is_const&lt;Src&gt;::value,\n            typename std::add_const&lt;Dst&gt;::type, Dst&gt;::type;\n    };\n\n    template &lt;typename Dst, typename Src&gt;\n    struct adopt_volatile {\n        using type = typename std::conditional&lt; std::is_volatile&lt;Src&gt;::value,\n            typename std::add_volatile&lt;Dst&gt;::type, Dst&gt;::type;\n    };\n\n    template &lt;typename Dst, typename Src&gt;\n    struct adopt_cv {\n        using type = typename adopt_const&lt;\n            typename adopt_volatile&lt;Dst, Src&gt;::type, Src&gt;::type;\n    };\n\n    template &lt;typename T&gt;\n    T*  add_offset(T* p, std::ptrdiff_t delta) noexcept {\n        using byte_type = typename adopt_cv&lt;unsigned char, T&gt;::type;\n        return reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;byte_type*&gt;(p) + delta);\n    }\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/18m0O9%242\">Example</a></p>\n", "Id": "15943751", "PostTypeId": "2", "OwnerDisplayName": "user2218982", "Score": "8", "CreationDate": "2013-04-11T08:13:08.630", "LastActivityDate": "2013-04-11T08:13:08.630"}, "bq_ids": {"n4140": {"so_15934111_15943751_1": {"section_id": 5785, "quality": 0.9069767441860465, "length": 39}, "so_15934111_15943751_0": {"section_id": 6076, "quality": 0.875, "length": 21}}, "n3337": {"so_15934111_15943751_1": {"section_id": 5558, "quality": 0.9069767441860465, "length": 39}, "so_15934111_15943751_0": {"section_id": 5844, "quality": 0.875, "length": 21}}, "n4659": {"so_15934111_15943751_1": {"section_id": 7242, "quality": 0.9069767441860465, "length": 39}, "so_15934111_15943751_0": {"section_id": 7572, "quality": 0.875, "length": 21}}}, "15934226": {"ParentId": "15934111", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>if you have:</p>\n<pre><code>myType *ptr;\n</code></pre>\n<p>and you do:</p>\n<pre><code>ptr+=3;\n</code></pre>\n<p>The compiler will most certainly increment your variable by:</p>\n<pre><code>3*sizeof(myType)\n</code></pre>\n<p>And it's the standard way to do it as far as I know.</p>\n<p>If you want to iterate over let's say an array of elements of type myType that's the way to do it.</p>\n<p>Ok, if you wanna cast do that using </p>\n<pre><code>myNewType *newPtr=reinterpret_cast &lt; myNewType * &gt; ( ptr )\n</code></pre>\n<p>Or stick to plain old C and do:</p>\n<pre><code>myNewType *newPtr=(myNewType *) ptr;\n</code></pre>\n<p>And then increment</p>\n", "OwnerUserId": "611295", "LastEditorUserId": "611295", "LastEditDate": "2013-04-10T19:09:33.070", "Id": "15934226", "Score": "-2", "CreationDate": "2013-04-10T19:01:37.653", "LastActivityDate": "2013-04-10T19:09:33.070"}});