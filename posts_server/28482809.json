post_cb({"28483256": {"ParentId": "28482809", "PostTypeId": "2", "CommentCount": "35", "CreationDate": "2015-02-12T16:54:57.077", "Score": "20", "LastEditorUserId": "3647361", "LastEditDate": "2015-12-23T14:41:22.900", "Id": "28483256", "OwnerUserId": "3647361", "Body": "<p><strong>TL;DR</strong>: Your example is well-defined. Merely dereferencing a null pointer is not invoking UB.</p>\n<p>There is a lot of debate over this topic, which basically boils down to  whether indirection through a null pointer is itself UB.<br>\nThe only questionable thing that happens in your example is the evaluation of the object expression. In particular, <code>d-&gt;a</code> is equivalent to <code>(*d).a</code> according to [expr.ref]/2:</br></p>\n<blockquote>\n<p id=\"so_28482809_28483256_0\">The expression <code>E1-&gt;E2</code> is converted to the equivalent form\n  <code>(*(E1)).E2</code>; the remainder of 5.2.5 will address only the first\n  option (dot).</p>\n</blockquote>\n<p><code>*d</code> is just evaluated:</p>\n<blockquote>\n<p id=\"so_28482809_28483256_1\">The postfix expression before the dot or arrow is evaluated;<sup>65</sup> the\n  result of that evaluation, together with the <em>id-expression</em>, determines\n  the result of the entire postfix expression.</p>\n<p id=\"so_28482809_28483256_2\"><sup>65) If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary\n  to determine the value of the entire postfix expression, for example if the <em>id-expression</em> denotes a static member.</sup></p>\n</blockquote>\n<p>Let's extract the critical part of the code. Consider the expression statement</p>\n<pre><code>*d;\n</code></pre>\n<p>In this statement, <code>*d</code> is a discarded value expression according to [stmt.expr]. So <code>*d</code> is solely evaluated<sup>1</sup>, just as in <code>d-&gt;a</code>.<br>\nHence if <code>*d;</code> is valid, or in other words the evaluation of the expression <code>*d</code>, so is your example.</br></p>\n<h2>Does indirection through null pointers inherently result in undefined behavior?</h2>\n<p>There is the open CWG issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow\"><strong>#232</strong></a>, created over fifteen years ago, which concerns this exact question. A very important argument is raised. The report starts with</p>\n<blockquote>\n<p id=\"so_28482809_28483256_3\">At least a couple of places in the IS state that indirection through a\n  null pointer produces undefined behavior: 1.9 [intro.execution]\n  paragraph 4 gives \"dereferencing the null pointer\" as an example of\n  undefined behavior, and 8.3.2 [dcl.ref] paragraph 4 (in a note) uses\n  this supposedly undefined behavior as justification for the\n  nonexistence of \"null references.\"</p>\n</blockquote>\n<p>Note that the example mentioned was changed to cover modifications of <code>const</code> objects instead, and the note in [dcl.ref] - while still existing - is not normative. The normative passage was removed to avoid commitment. </p>\n<blockquote>\n<p id=\"so_28482809_28483256_4\">However, 5.3.1 [expr.unary.op] paragraph 1, which describes the unary\n  \"<code>*</code>\" operator, does not say that the behavior is undefined if the\n  operand is a null pointer, as one might expect. Furthermore, at least\n  one passage gives dereferencing a null pointer well-defined behavior:\n  5.2.8 [expr.typeid] paragraph 2 says</p>\n<blockquote>\n<p id=\"so_28482809_28483256_7\">If the lvalue expression is obtained by applying the unary * operator\n    to a pointer and the pointer is a null pointer value (4.10\n    [conv.ptr]), the typeid expression throws the bad_typeid exception\n    (18.7.3 [bad.typeid]). </p>\n</blockquote>\n<p id=\"so_28482809_28483256_6\">This is inconsistent and should be cleaned up.</p>\n</blockquote>\n<p>The last point is especially important. The quote in [expr.typeid] still exists and appertains to glvalues of polymorphic class type, which is the case in the following example:</p>\n<pre><code>int main() try {\n\n    // Polymorphic type\n    class A\n    {\n        virtual ~A(){}\n    };\n\n    typeid( *((A*)0) );\n\n}\ncatch (std::bad_typeid)\n{\n    std::cerr &lt;&lt; \"bad_exception\\n\";\n}\n</code></pre>\n<p>The behavior of this program is well-defined (an exception will be thrown and catched), and <strong>the expression <code>*((A*)0)</code>  is evaluated</strong> as it isn't part of an unevaluated operand. Now if indirection through null pointers induced UB, then the expression written as</p>\n<pre><code>*((A*)0);\n</code></pre>\n<p>would be doing just that, inducing UB, which seems nonsensical when compared to the <code>typeid</code> scenario. <strong>If the above expression is merely evaluated as every discarded-value expression is<sup>1</sup>, where is the crucial difference that makes the evaluation in the second snippet UB?</strong> There is no existing implementation that analyzes the <code>typeid</code>-operand, finds the innermost, corresponding dereference and surrounds its operand with a check - there would be a performance loss, too.</p>\n<p>A note in that issue then ends the short discussion with:</p>\n<blockquote>\n<p id=\"so_28482809_28483256_8\">We agreed that the approach in the standard seems okay: <strong><code>p = 0; *p;</code>\n  is not inherently an error.</strong> An lvalue-to-rvalue conversion would give\n  it undefined behavior.</p>\n</blockquote>\n<p>I.e. the committee agreed upon this. Although the proposed resolution of this report, which introduced so-called \"<em>empty lvalues</em>\", was never adopted\u2026</p>\n<blockquote>\n<p id=\"so_28482809_28483256_9\">However, \u201cnot modifiable\u201d is a compile-time concept, while in fact\n  this deals with runtime values and thus should produce undefined\n  behavior instead. Also, there are other contexts in which lvalues can\n  occur, such as the left operand of . or .*, which should also be\n  restricted. Additional drafting is required.</p>\n</blockquote>\n<p>\u2026<strong>that does not affect the rationale</strong>. Then again, it should be noted that this issue even precedes C++03, which makes it less convincing while we approach C++17.</p>\n<hr>\n<p>CWG-issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#315\" rel=\"nofollow\"><strong>#315</strong></a> seems to cover your case as well:</p>\n<blockquote>\n<p id=\"so_28482809_28483256_10\">Another instance to consider is that of invoking a member function\n  from a null pointer:</p>\n<pre><code>  struct A { void f () { } };\n  int main ()\n  {\n    A* ap = 0;\n    ap-&gt;f ();\n  }\n</code></pre>\n<p id=\"so_28482809_28483256_11\">[\u2026]</p>\n<p id=\"so_28482809_28483256_12\">Rationale (October 2003):</p>\n<p id=\"so_28482809_28483256_13\"><strong>We agreed the example should be allowed. <code>p-&gt;f()</code> is rewritten as\n  <code>(*p).f()</code> according to 5.2.5 [expr.ref]. <code>*p</code> is not an error when\n  <code>p</code> is null unless the lvalue is converted to an rvalue (4.1\n  [conv.lval]), which it isn't here.</strong></p>\n</blockquote>\n<p>According to this rationale, indirection through a null pointer per se does not invoke UB without further lvalue-to-rvalue conversions (=accesses to stored value), reference bindings, value computations or the like. (Nota bene: Calling a <em>non-static</em> member function with a null pointer should invoke UB, albeit merely hazily disallowed by [class.mfct.non-static]/2. The rationale is outdated in this respect.)</p>\n<p>I.e. a mere evaluation of <code>*d</code> does not suffice to invoke UB. The identity of the object is not required, and neither is its previously stored value. On the other hand, e.g.</p>\n<pre><code>*p = 123;\n</code></pre>\n<p>is undefined since there is a value computation of the left operand, [expr.ass]/1:</p>\n<blockquote>\n<p id=\"so_28482809_28483256_14\">In all cases, the assignment is sequenced after <strong>the value computation\n  of the right and left operands</strong></p>\n</blockquote>\n<p>Because the left operand is expected to be a glvalue, the identity of the object referred to by that glvalue must be determined as mentioned by the definition of evaluation of an expression in [intro.execution]/12, which is impossible (and thus leads to UB).  </p>\n<hr>\n<p><sup>1</sup> [expr]/11:</p>\n<blockquote>\n<p id=\"so_28482809_28483256_15\">In some contexts, an expression only appears for its side effects.\n  Such an expression is called a <em>discarded-value expression</em>. <strong>The\n  expression is evaluated and its value is discarded.</strong> [\u2026]. The lvalue-to-rvalue conversion (4.1) is\n  applied if and only if the expression is a glvalue of\n  volatile-qualified type and [\u2026]</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2015-12-23T14:41:22.900"}, "bq_ids": {"n4140": {"so_28482809_28483254_1": {"section_id": 5900, "quality": 0.967741935483871, "length": 30}, "so_28482809_28483256_10": {"section_id": 91, "quality": 0.5714285714285714, "length": 4}, "so_28482809_28483256_5": {"section_id": 6021, "quality": 0.7, "length": 14}, "so_28482809_28483256_15": {"section_id": 5944, "quality": 0.8846153846153846, "length": 23}, "so_28482809_28483256_0": {"section_id": 6005, "quality": 0.7857142857142857, "length": 11}, "so_28482809_28483256_2": {"section_id": 6004, "quality": 1.0, "length": 21}, "so_28482809_28483254_3": {"section_id": 6007, "quality": 1.0, "length": 14}, "so_28482809_28483256_14": {"section_id": 6173, "quality": 1.0, "length": 10}, "so_28482809_28483254_4": {"section_id": 6007, "quality": 0.9333333333333333, "length": 14}, "so_28482809_28483256_1": {"section_id": 6004, "quality": 0.875, "length": 14}, "so_28482809_28483256_7": {"section_id": 6021, "quality": 0.7, "length": 14}}, "n3337": {"so_28482809_28483254_1": {"section_id": 5672, "quality": 0.967741935483871, "length": 30}, "so_28482809_28483256_10": {"section_id": 86, "quality": 0.5714285714285714, "length": 4}, "so_28482809_28483256_5": {"section_id": 5789, "quality": 0.7, "length": 14}, "so_28482809_28483256_15": {"section_id": 5715, "quality": 0.8461538461538461, "length": 22}, "so_28482809_28483256_0": {"section_id": 5773, "quality": 0.7857142857142857, "length": 11}, "so_28482809_28483256_2": {"section_id": 5772, "quality": 1.0, "length": 21}, "so_28482809_28483254_3": {"section_id": 5775, "quality": 1.0, "length": 14}, "so_28482809_28483256_14": {"section_id": 5934, "quality": 1.0, "length": 10}, "so_28482809_28483254_4": {"section_id": 5775, "quality": 0.9333333333333333, "length": 14}, "so_28482809_28483256_1": {"section_id": 5772, "quality": 0.875, "length": 14}, "so_28482809_28483256_7": {"section_id": 5789, "quality": 0.7, "length": 14}}, "n4659": {"so_28482809_28483254_1": {"section_id": 7382, "quality": 0.967741935483871, "length": 30}, "so_28482809_28483254_3": {"section_id": 7506, "quality": 1.0, "length": 14}, "so_28482809_28483256_5": {"section_id": 7520, "quality": 0.7, "length": 14}, "so_28482809_28483254_4": {"section_id": 7506, "quality": 0.9333333333333333, "length": 14}, "so_28482809_28483256_0": {"section_id": 7504, "quality": 0.7857142857142857, "length": 11}, "so_28482809_28483256_2": {"section_id": 7503, "quality": 1.0, "length": 21}, "so_28482809_28483256_10": {"section_id": 2706, "quality": 0.5714285714285714, "length": 4}, "so_28482809_28483256_14": {"section_id": 7675, "quality": 1.0, "length": 10}, "so_28482809_28483256_15": {"section_id": 7429, "quality": 0.6923076923076923, "length": 18}, "so_28482809_28483256_1": {"section_id": 7503, "quality": 0.875, "length": 14}, "so_28482809_28483256_7": {"section_id": 7520, "quality": 0.7, "length": 14}}}, "28483254": {"ParentId": "28482809", "CommentCount": "10", "CreationDate": "2015-02-12T16:54:52.350", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "28483254", "Score": "5", "Body": "<p>From the C++ Draft Standard N3337:</p>\n<blockquote>\n<p id=\"so_28482809_28483254_0\"><strong>9.4 Static members</strong></p>\n<p id=\"so_28482809_28483254_1\">2 A <code>static</code> member s of class <code>X</code> may be referred to using the <em>qualified-id expression</em> <code>X::s</code>; it is not necessary to use the class member access syntax (5.2.5) to refer to a <code>static</code> member. A <code>static</code> member may be referred\n  to using the class member access syntax, in which case the object expression is evaluated.</p>\n</blockquote>\n<p>And in the section about object expression...</p>\n<blockquote>\n<p id=\"so_28482809_28483254_2\"><strong>5.2.5 Class member access</strong></p>\n<p id=\"so_28482809_28483254_3\">4 If E2 is declared to have type \u201creference to T,\u201d then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise,\n  one of the following rules applies.</p>\n<p id=\"so_28482809_28483254_4\">\u2014 If <code>E2</code> is a <code>static</code> data member and the type of <code>E2</code> is <code>T</code>, then <code>E1.E2</code> is an lvalue; the expression designates the named member of the class. The type of <code>E1.E2</code> is T.</p>\n</blockquote>\n<p>Based on the last paragraph of the standard, the expressions:</p>\n<pre><code>  d-&gt;fun();\n  std::cout &lt;&lt; d-&gt;a;\n</code></pre>\n<p>work because they both designate the named member of the class regardless of the value of <code>d</code>.</p>\n", "LastActivityDate": "2015-02-12T16:54:52.350"}, "28483477": {"ParentId": "28482809", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-02-12T17:04:51.813", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:33:13.693", "Id": "28483477", "OwnerUserId": "6345", "Body": "<blockquote>\n<p id=\"so_28482809_28483477_0\">runs fine and produces expected output instead of any runtime error.</p>\n</blockquote>\n<p>That's a basic assumption error. What you are doing is <strong>undefined behavior</strong>, which means that your claim for <strong>any kind</strong> of \"expected output\" is faulty.</p>\n<p><strong>Addendum:</strong> Note that, while there is a CWG defect (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#315\" rel=\"nofollow noreferrer\" title=\"#315\">#315</a>) report that is closed as \"in agreement\" of <em>not</em> making the above UB, it relies on the positive closing of <em>another</em> CWG defect (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\" title=\"#232\">#232</a>) that is still active, and hence none of it is added to the standard.</p>\n<p>Let me quote a part of a comment from <a href=\"https://stackoverflow.com/users/151292/james-mcnellis\" title=\"James McNellis\">James McNellis</a> to <a href=\"https://stackoverflow.com/a/2474021/6345\">an answer</a> to a similar Stack Overflow question:</p>\n<blockquote>\n<p id=\"so_28482809_28483477_1\">I don't think CWG defect 315 is as \"closed\" as its presence on the \"closed issues\" page implies. The rationale says that it should be allowed because \"*p is not an error when p is null unless the lvalue is converted to an rvalue.\" However, that relies on the concept of an \"empty lvalue,\" which is part of the proposed resolution to CWG defect 232, but which has not been adopted.</p>\n</blockquote>\n", "LastActivityDate": "2015-02-12T19:09:48.240"}, "28482809": {"CommentCount": "12", "AcceptedAnswerId": "28483256", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-02-12T16:34:29.110", "LastActivityDate": "2016-03-18T11:43:05.877", "LastEditDate": "2016-03-18T11:43:05.877", "ViewCount": "2180", "FavoriteCount": "2", "Title": "c++ access static members using null pointer", "Id": "28482809", "Score": "16", "Body": "<p>Recently tried the following program and it compiles, runs fine and produces expected output instead of any runtime error.</p>\n<pre><code>#include &lt;iostream&gt;\nclass demo\n{\n    public:\n        static void fun()\n        {\n            std::cout&lt;&lt;\"fun() is called\\n\";\n        }\n        static int a;\n};\nint demo::a=9;\nint main()\n{\n    demo* d=nullptr;\n    d-&gt;fun();\n    std::cout&lt;&lt;d-&gt;a;\n    return 0;\n}\n</code></pre>\n<p>If an uninitialized pointer is used to access class and/or struct members behaviour is undefined, but why it is allowed to access static members using null pointers also. Is there any harm in my program?</p>\n", "Tags": "<c++><c++11><language-lawyer><static-members><nullptr>", "OwnerUserId": "3777958", "AnswerCount": "4"}, "28483131": {"ParentId": "28482809", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-02-12T16:49:25.387", "Score": "1", "LastEditorUserId": "773113", "LastEditDate": "2015-02-13T21:17:42.263", "Id": "28483131", "OwnerUserId": "773113", "Body": "<p>What you are seeing here is what I would consider an ill-conceived and unfortunate design choice in the specification of the C++ language and many other languages that belong to the same general family of programming languages.</p>\n<p>These languages allow you to refer to static members of a class using a reference to an instance of the class.  The actual value of the instance reference is of course ignored, since no instance is required to access static members.</p>\n<p>So, in <code>d-&gt;fun();</code> the the compiler uses the <code>d</code> pointer <em>only during compilation</em> to figure out that you are referring to a member of the <code>demo</code> class, and then it ignores it. No code is emitted by the compiler to dereference the pointer, so the fact that it is going to be NULL during runtime does not matter.</p>\n<p>So, what you see happening is in perfect accordance to the specification of the language, and in my opinion the specification suffers in this respect, because it allows an illogical thing to happen: to use an instance reference to refer to a static member.</p>\n<p>P.S. Most compilers in most languages are actually capable of issuing warnings for that kind of stuff.  I do not know about your compiler, but you might want to check, because the fact that you received no warning for doing what you did might mean that you do not have enough warnings enabled. </p>\n", "LastActivityDate": "2015-02-13T21:17:42.263"}});