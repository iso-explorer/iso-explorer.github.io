post_cb({"bq_ids": {"n4140": {"so_8459424_8459520_1": {"length": 40, "quality": 0.9090909090909091, "section_id": 6044}, "so_8459424_8459520_0": {"length": 42, "quality": 0.84, "section_id": 6043}}, "n3337": {"so_8459424_8459520_1": {"length": 40, "quality": 0.9090909090909091, "section_id": 5812}, "so_8459424_8459520_0": {"length": 42, "quality": 0.84, "section_id": 5811}}, "n4659": {"so_8459424_8459520_1": {"length": 40, "quality": 0.9090909090909091, "section_id": 7543}, "so_8459424_8459520_0": {"length": 42, "quality": 0.84, "section_id": 7542}}}, "8459520": {"Id": "8459520", "PostTypeId": "2", "Body": "<p>Reading the documentation in the standard it is very explicit about different types. But for the basic pointer we have:</p>\n<blockquote>\n<p id=\"so_8459424_8459520_0\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined. [ <strong>Note: It is intended to be unsurprising to those who know the addressing structure of the underlying machine. \u2014 end note</strong> ] A value of type std::nullptr_t can be converted to an integral type; the conversion has the same meaning and validity as a conversion of (void*)0 to the integral type. [Note: A reinterpret_cast cannot be used to convert a value of any type to the type std::nullptr_t. \u2014 end note ]</p>\n</blockquote>\n<p>For integers:</p>\n<blockquote>\n<p id=\"so_8459424_8459520_1\">A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation-defined. [Note: Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer value. \u2014endnote]</p>\n</blockquote>\n", "LastActivityDate": "2011-12-10T20:13:07.023", "CommentCount": "2", "CreationDate": "2011-12-10T20:13:07.023", "ParentId": "8459424", "Score": "1", "OwnerUserId": "14065"}, "8459424": {"ViewCount": "641", "Body": "<p>How can I know how will reinterpret cast work on GCC compiler? Is it mentioned in the documentation? May I know any reference or link if it exist?</p>\n", "Title": "GCC implementation for behavior of reinterpret cast", "CreationDate": "2011-12-10T19:57:18.150", "LastActivityDate": "2011-12-10T20:15:49.633", "CommentCount": "13", "LastEditDate": "2011-12-10T20:06:32.680", "PostTypeId": "1", "LastEditorUserId": "964135", "Id": "8459424", "Score": "2", "OwnerUserId": "1086635", "Tags": "<c++><gcc><reinterpret-cast>", "AnswerCount": "2"}, "8459546": {"Id": "8459546", "PostTypeId": "2", "Body": "<p>I have used <code>reinterpret_cast</code> many times with g++. In embedded programming, it's useful for mapping a <code>struct</code> that represents a peripheral's registers to its (fixed) address:</p>\n<pre><code>struct DEV_Registers\n{\nvolatile uint32_t REGA;\nvolatile uint32_t REGB;\n// ...\n};\n\nstatic DEV_Registers&amp; DEV(*reinterpret_cast&lt;DEV_Registers&gt;(0x40000000));\n</code></pre>\n<p>This lets me write code like:</p>\n<pre><code>DEV.REGB = 0x12345678;\n</code></pre>\n<p>which does the right thing (set the register at 0x40000004 to the value 0x12345678) and is quite legible.</p>\n<p>It's hard to tell if your question is asking for details beyond this.</p>\n", "LastActivityDate": "2011-12-10T20:15:49.633", "CommentCount": "6", "CreationDate": "2011-12-10T20:15:49.633", "ParentId": "8459424", "Score": "1", "OwnerUserId": "2624511"}});