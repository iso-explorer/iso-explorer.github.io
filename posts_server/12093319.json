post_cb({"12093663": {"LastActivityDate": "2012-08-23T15:05:13.037", "LastEditorUserId": "179910", "ParentId": "12093319", "LastEditDate": "2012-08-23T15:05:13.037", "Id": "12093663", "Score": "31", "Body": "<p>Because, as Bjarne puts it, C++ is designed to protect against Murphy, not Machiavelli.</p>\n<p>In other words, it's supposed to protect you from accidents -- but if you go to any work at all to subvert it (such as using a cast) it's not even going to attempt to stop you.</p>\n<p>When I think of it, I have a somewhat different analogy in mind: it's like the lock on a bathroom door. It gives you a warning that you probably don't <em>want</em> to walk in there right now, but it's trivial to unlock the door from the outside if you decide to.</p>\n<p>Edit: as to the question @Xeo discusses, about why the standard says \"have the same access control\" instead of \"have all public access control\", the answer is long and a little tortuous.</p>\n<p>Let's step back to the beginning and consider a struct like:</p>\n<pre><code>struct X {\n    int a;\n    int b;\n};\n</code></pre>\n<p>C always had a few rules for a struct like this. One is that in an instance of the struct, the address of the struct itself has to equal the address of <code>a</code>, so you can cast a pointer to the struct to a pointer to <code>int</code>, and access <code>a</code> with well defined results. Another is that the members have to be arranged in the same order in memory as they are defined in the struct (though the compiler is free to insert padding between them).</p>\n<p>For C++, there was an intent to maintain that, especially for existing C structs. At the same time, there was an apparent intent that <em>if</em> the compiler wanted to enforce <code>private</code> (and <code>protected</code>) at run-time, it should be easy to do that (reasonably efficiently).</p>\n<p>Therefore, given something like:</p>\n<pre><code>struct Y { \n    int a;\n    int b;\nprivate:\n    int c;\n    int d;\npublic:\n    int e;\n\n    // code to use `c` and `d` goes here.\n};\n</code></pre>\n<p>The compiler should be required to maintain the same rules as C with respect to <code>Y.a</code> and <code>Y.b</code>. At the same time, if it's going to enforce access at run time, it may want to move all the public variables together in memory, so the layout would be more like:</p>\n<pre><code>struct Z { \n    int a;\n    int b;\n    int e;\nprivate:\n    int c;\n    int d;\n    // code to use `c` and `d` goes here.\n};\n</code></pre>\n<p>Then, when it's enforcing things at run-time, it can basically do something like <code>if (offset &gt; 3 * sizeof(int)) access_violation();</code></p>\n<p>To my knowledge nobody's ever done this, and I'm not sure the rest of the standard really allows it, but there does seem to have been at least the half-formed germ of an idea along that line.</p>\n<p>To enforce both of those, the C++98 said <code>Y::a</code> and <code>Y::b</code> had to be in that order in memory, and <code>Y::a</code> had to be at the beginning of the struct (i.e., C-like rules). But, because of the intervening access specifiers, <code>Y::c</code> and <code>Y::e</code> no longer had to be in order relative to each other. In other words, all the consecutive variables defined without an access specifier between them were grouped together, the compiler was free to rearrange those groups (but still had to keep the first one at the beginning).</p>\n<p>That was fine until some jerk (i.e., me) pointed out that the way the rules were written had another little problem. If I wrote code like:</p>\n<pre><code>struct A { \n    int a;\npublic:\n    int b;\npublic:\n    int c;\npublic:\n    int d;\n};\n</code></pre>\n<p>...you ended up with a little bit of self contradition. On one hand, this was still officially a POD struct, so the C-like rules were supposed to apply -- but since you had (admittedly meaningless) access specifiers between the members, it also gave the compiler permission to rearrange the members, thus breaking the C-like rules they intended.</p>\n<p>To cure that, they re-worded the standard a little so it would talk about the members all having the same access, rather than about whether or not there was an access specifier between them. Yes, they could have just decreed that the rules would only apply to public members, but it would appear that nobody saw anything to be gained from that. Given that this was modifying an existing standard with lots of code that had been in use for quite a while, the opted for the smallest change they could make that would still cure the problem.</p>\n", "CommentCount": "4", "PostTypeId": "2", "OwnerUserId": "179910", "CreationDate": "2012-08-23T14:13:21.740"}, "bq_ids": {"n3337": {"so_12093319_12093590_1": {"section_id": 5650, "quality": 1.0, "length": 19}}}, "12093912": {"LastActivityDate": "2012-08-23T14:26:16.773", "ParentId": "12093319", "Id": "12093912", "Score": "1", "Body": "<p>The whole purpose of <code>reinterpret_cast</code> (and a C style cast is even more powerful than a <code>reinterpret_cast</code>) is to provide an escape path around safety measures.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "136208", "CreationDate": "2012-08-23T14:26:16.773"}, "12093393": {"LastActivityDate": "2012-08-23T13:59:44.207", "ParentId": "12093319", "Id": "12093393", "Score": "0", "Body": "<p>This is because you are manipulating the memory where your class is located in memory. In your case it just happen to store the private member at this memory location so you change it. It is not a very good idea to do because you do now know how the object will be stored in memory.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1589914", "CreationDate": "2012-08-23T13:59:44.207"}, "12093851": {"LastActivityDate": "2012-08-23T14:42:24.003", "LastEditorUserId": "567292", "ParentId": "12093319", "LastEditDate": "2012-08-23T14:42:24.003", "Id": "12093851", "Score": "2", "Body": "<p>A good reason is to allow compatibility with C but extra access safety on the C++ layer.</p>\n<p>Consider:</p>\n<pre><code>struct S {\n#ifdef __cplusplus\nprivate:\n#endif // __cplusplus\n    int i, j;\n#ifdef __cplusplus\npublic:\n    int get_i() const { return i; }\n    int get_j() const { return j; }\n#endif // __cplusplus\n};\n</code></pre>\n<p>By requiring that the C-visible <code>S</code> and the C++-visible <code>S</code> be <em>layout-compatible</em>, <code>S</code> can be used across the language boundary with the C++ side having greater access safety.  The <code>reinterpret_cast</code> access safety subversion is an unfortunate but necessary corollary.</p>\n<p>As an aside, the restriction on having all members with the same access control is because the implementation is permitted to rearrange members relative to members with different access control.  Presumably some implementations put members with the same access control together, for the sake of tidiness; it could also be used to reduce padding, although I don't know of any compiler that does that.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "567292", "CreationDate": "2012-08-23T14:22:18.960"}, "12093590": {"LastActivityDate": "2012-08-23T14:15:22.723", "LastEditorUserId": "500104", "ParentId": "12093319", "LastEditDate": "2012-08-23T14:15:22.723", "Id": "12093590", "Score": "14", "Body": "<p>Because of backwards-compatability with C, where you can do the same thing.</p>\n<hr>\n<p>For all people wondering, here's why this is not UB and is actually allowed by the standard:</p>\n<p>First, <code>TestClass</code> is a <em>standard-layout class</em> (<code>\u00a79 [class] p7</code>):</p>\n<blockquote>\n<p id=\"so_12093319_12093590_0\">A <em>standard-layout class</em> is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference, <strong>// OK: non-static data member is of type 'int'</strong></li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1), <strong>// OK</strong></li>\n<li>has the same access control (Clause 11) for all non-static data members, <strong>// OK, all non-static data members (1) are 'private'</strong></li>\n<li>has no non-standard-layout base classes, <strong>// OK, no base classes</strong></li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and <strong>// OK, no base classes again</strong></li>\n<li>has no base classes of the same type as the first non-static data member. <strong>// OK, no base classes again</strong></li>\n</ul>\n</blockquote>\n<p>And with that, you can are allowed to <code>reinterpret_cast</code> the class to the type of its first member (<code>\u00a79.2 [class.mem] p20</code>):</p>\n<blockquote>\n<p id=\"so_12093319_12093590_1\">A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>In your case, the C-style <code>(int*)</code> cast resolves to a <code>reinterpret_cast</code> (<code>\u00a75.4 [expr.cast] p4</code>).</p>\n</hr>", "CommentCount": "3", "PostTypeId": "2", "OwnerUserId": "500104", "CreationDate": "2012-08-23T14:09:42.663"}, "12093319": {"ViewCount": "1223", "AcceptedAnswerId": "12093663", "Tags": "<c++><private-members>", "AnswerCount": "6", "OwnerUserId": "1342730", "Body": "<p>After seeing <a href=\"https://stackoverflow.com/questions/12092873/explicit-type-casting-of-object-to-int\">this question </a> a few minutes ago, I wondered why the language designers allow it as it allows indirect modification of private data. As an example</p>\n<pre><code> class TestClass {\n   private:\n    int cc;\n   public:\n     TestClass(int i) : cc(i) {};\n };\n\n TestClass cc(5);\n int* pp = (int*)&amp;cc;\n *pp = 70;             // private member has been modified\n</code></pre>\n<p>I tested the above code and indeed the private data has been modified. Is there any explanation of why this is allowed to happen or this just an oversight in the language? It seems to directly undermine the use of private data members. </p>\n", "CommentCount": "8", "PostTypeId": "1", "CreationDate": "2012-08-23T13:56:23.833", "FavoriteCount": "2", "LastActivityDate": "2012-08-23T15:05:13.037", "Id": "12093319", "LastEditorUserId": "-1", "Title": "Why does C++ allow private members to be modified using this approach?", "Score": "18", "LastEditDate": "2017-05-23T11:45:33.393"}, "12093793": {"LastActivityDate": "2012-08-23T14:46:18.063", "LastEditorUserId": "597607", "ParentId": "12093319", "LastEditDate": "2012-08-23T14:46:18.063", "Id": "12093793", "Score": "1", "Body": "<p>The compiler would have given you an error if you had tried <code>int *pp = &amp;cc.cc</code>, the compiler would have told you that you cannot access a private member.</p>\n<p>In your code you are reinterpreting the address of cc as a pointer to an int. You wrote it the C style way, the C++ style way would have been <code>int* pp = reinterpret_cast&lt;int*&gt;(&amp;cc);</code>. The reinterpret_cast always is a warning that you are doing a cast between two pointers that are not related. In such a case you must make sure that you are doing right. You must know the underlying memory (layout). The compiler does not prevent you from doing so, because this if often needed.</p>\n<p>When doing the cast you throw away all knowledge about the class. From now on the compiler only sees an int pointer. Of course you can access the memory the pointer points to. In your case, on your platform the compiler happened to put cc in the first n bytes of a TestClass object, so a TestClass pointer also points to the cc member.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1023911", "CreationDate": "2012-08-23T14:19:20.000"}});