post_cb({"695744": {"CommentCount": "3", "CreationDate": "2009-03-30T01:08:57.717", "LastEditorUserId": "3153", "LastActivityDate": "2009-03-30T01:16:43.643", "ParentId": "695734", "LastEditDate": "2009-03-30T01:16:43.643", "LastEditorDisplayName": "Brian R. Bondy", "PostTypeId": "2", "Id": "695744", "Score": "0", "Body": "<p>I think you would have 'undefined behavior' in this case. </p>\n<p>From the <a href=\"http://c0x.coding-guidelines.com/6.3.2.3.html\" rel=\"nofollow noreferrer\">C standard</a>: (I would assume it's the same in C++)</p>\n<blockquote>\n<p id=\"so_695734_695744_0\">768 If\n  a converted pointer is used to call a\n  function whose type is not compatible\n  with the pointed-to type, the behavior\n  is undefined.</p>\n</blockquote>\n<p>Edit: On most operating system, this type of error would not cause problems in your whole operating system.  But it would cause undefined problems in your program.  It would be very hard for a user mode program to be able to cause a blue-screen.</p>\n", "OwnerUserId": "3153", "OwnerDisplayName": "Brian R. Bondy"}, "695783": {"ParentId": "695734", "CommentCount": "1", "CreationDate": "2009-03-30T01:42:04.487", "OwnerUserId": "3631", "Id": "695783", "PostTypeId": "2", "OwnerDisplayName": "Rob Walker", "Score": "2", "Body": "<p>You are calling the function as if it is _cdecl which means the caller pushes the arguments and cleans up the stack.</p>\n<p>The receiving function is _stdcall which implies the callee cleans up the stack.  The callee is expecting a single argument so will pop 4 bytes off the stack.</p>\n<p>When the function returns the caller will then pop off two pointers (having previously pushed on two pointers), so your stack is being corrupted by 4 bytes.</p>\n<p>Both calling conventions use the same return mechanism, and have the same register rules (eax, ecx and edx are not preserved).  See <a href=\"http://en.wikipedia.org/wiki/X86_calling_conventions\" rel=\"nofollow noreferrer\">wikipedia</a> for more details.</p>\n<p>Depending on the stack frame layout and alignment this mismatch could cause a number of effects.  If you are lucky then you get away with it.  If not you might mess up the return address of your main function, causing the program to crash when it branches to who-knows-where.  If the compiler has injected some kind of stack guard to catch corruption then it will likely detect this and abort the program.</p>\n", "LastActivityDate": "2009-03-30T01:42:04.487"}, "695753": {"ParentId": "695734", "CommentCount": "0", "Body": "<p>No, it will definitely not cause a blue screen. No user-mode process is able to do that. Even if such bug were in kernel-mode code, the BSOD would occur only after accessing invalid memory or passing wrong arguments to a function.</p>\n<p>You are simply corrupting private memory of your process, and the corruption may (or may not) later result in an invalid operation (eg. dereferencing a pointer pointing to invalid memory). When this happens, the OS terminates your process, but no sooner.</p>\n", "Id": "695753", "PostTypeId": "2", "OwnerDisplayName": "user83286", "Score": "1", "CreationDate": "2009-03-30T01:20:08.113", "LastActivityDate": "2009-03-30T01:20:08.113"}, "bq_ids": {"n4140": {"so_695734_695744_0": {"section_id": 5988, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_695734_695744_0": {"section_id": 7537, "quality": 0.5833333333333334, "length": 7}}}, "695734": {"CommentCount": "2", "ViewCount": "915", "PostTypeId": "1", "LastEditorUserId": "84407", "CreationDate": "2009-03-30T01:01:45.147", "LastActivityDate": "2009-03-30T01:51:11.097", "AnswerCount": "3", "LastEditDate": "2009-03-30T01:51:11.097", "AcceptedAnswerId": "695783", "LastEditorDisplayName": "GRB", "Title": "Thought experiment with __stdcall and corrupted stack (C++)", "Id": "695734", "Score": "-1", "Body": "<p>My mind was wandering today on the topic of function pointers, and I came up with the following scenario in my head:</p>\n<pre><code>__stdcall int function (int)\n{\n    return 0;\n}\n\nint main()\n{\n    (*(int(*)(char*,char*))function)(\"thought\", \"experiment\");\n    return 0;\n}\n</code></pre>\n<p>AFAIK this code would corrupt the stack, so what types of issues could I be looking at if I ran this code?</p>\n<p>I'd do this investigating myself however I'm away from my dev machine for a week.</p>\n<p>EDIT: Hold on a second, I've been thinking a bit more. As has been observed in the comments, the intent of this code was to have a parameter left on the stack when all is said and done (caller puts two params on the stack, callee -- expecting only one param -- pops only one off). However, since my cast doesn't make mention of the calling convention, am I casting away stdcall, at least from the view of the caller? <em>int function(int)</em> will still pop a param off the stack, but does the caller revert to thinking the function is __cdecl (the default) because of the cast? (i.e. three total params popped?)</p>\n<p>EDIT2: The answer to that second question, as confirmed by Rob, is yes. I would have to restate __stdcall if I wanted to leave a param on the stack:</p>\n<pre><code>(*(__stdcall int(*)(char*,char*))function)(\"thought\", \"experiment\");\n</code></pre>\n", "Tags": "<c++><windows><stack><corrupt><stdcall>", "OwnerUserId": "84407", "OwnerDisplayName": "GRB"}});