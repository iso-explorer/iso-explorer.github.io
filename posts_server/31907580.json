post_cb({"31907715": {"ParentId": "31907580", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_31907580_31907715_0\">[...] is it permittable to apply <code>std::distance</code> for any pair of <code>ForwardIterator</code>-s?</p>\n</blockquote>\n<p>If you want to stick to the standard, then clearly <strong>no, it's not permitted</strong>:</p>\n<blockquote>\n<pre><code>template &lt;class InputIterator&gt;\ntypename iterator_traits&lt;InputIterator&gt;::difference_type distance(\n  InputIterator first, InputIterator last);\n</code></pre>\n<p id=\"so_31907580_31907715_1\">[...]\n  Requires: If <code>InputIterator</code> meets the requirements of random access iterator, <code>last</code> shall be reachable from <code>first</code> or <code>first</code> shall be reachable from <code>last</code>; otherwise, <em><code>last</code> shall be reachable from <code>first</code></em>.</p>\n<p id=\"so_31907580_31907715_2\">[N4431 \u00a724.4.4/5]</p>\n</blockquote>\n<p>The reason is that for forward iterators the function is repeatedly applying <code>operator++</code> to get from <code>first</code> to <code>last</code>:</p>\n<blockquote>\n<p id=\"so_31907580_31907715_3\">Since only random access iterators provide + and -operators, the library provides two function templates <code>advance</code> and <code>distance</code>. These function templates use <code>+</code> and <code>-</code> for random access iterators (and are, therefore, constant time for them); for input, forward and bidirectional iterators they use <code>++</code> to provide linear time implementations.</p>\n<p id=\"so_31907580_31907715_4\">[N4431 \u00a724.4.4/1]</p>\n</blockquote>\n", "OwnerUserId": "1116364", "LastEditorUserId": "1116364", "LastEditDate": "2015-08-09T19:04:17.510", "Id": "31907715", "Score": "2", "CreationDate": "2015-08-09T18:52:47.037", "LastActivityDate": "2015-08-09T19:04:17.510"}, "31907728": {"ParentId": "31907580", "CommentCount": "0", "Body": "<p>From the documentaton you linked \"If <code>InputIt</code> is not <code>RandomAccessIterator</code>, the behavior is undefined if <code>last</code> is not reachable from <code>first</code> by (possibly repeatedly) incrementing <code>first</code>\".</p>\n<p>Undefined behaviour does not mean an access violation; it means anything at all, including returning some positive number.</p>\n", "OwnerUserId": "212870", "PostTypeId": "2", "Id": "31907728", "Score": "2", "CreationDate": "2015-08-09T18:53:45.090", "LastActivityDate": "2015-08-09T18:53:45.090"}, "31907580": {"CommentCount": "0", "AcceptedAnswerId": "31907715", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2015-08-09T18:38:03.647", "LastActivityDate": "2015-08-09T19:08:18.877", "LastEditDate": "2015-08-09T19:08:18.877", "ViewCount": "205", "FavoriteCount": "1", "Title": "std::distance for iterators worse then RandomAccessIterator", "Id": "31907580", "Score": "1", "Body": "<p>I recently reviewed not long ago implemented <a href=\"https://github.com/tomilov/quickhull/blob/master/include/quickhull.hpp\" rel=\"nofollow\">algorithm</a> and found, that <a href=\"https://github.com/tomilov/quickhull/commit/7a9735cbdcea040f5a9e3db5e190164683341e81\" rel=\"nofollow\">it can be improved</a> to be able to operate on not just only RandomAccessIterator input range, but even on ForwardIterator one (<em>multipass guarantee</em> is still the requirement).</p>\n<p>I decide to simply downgrade the requirement by modifying all the places in the code, that currently uses simple difference between iterators, in a way to use <code>std::distance</code> instead. The <code>std::distance</code> <a href=\"http://en.cppreference.com/w/cpp/iterator/distance\" rel=\"nofollow\">algorithm described here</a>. Due to very nature of <code>std::distance</code> algorithm the modifications was not just a <em>search and replace</em> one, namely:</p>\n<ul>\n<li>For ordered containers internally used in the algorithm I replaced all occurences of <code>operator &lt;</code> or <code>std::less&lt; iterator &gt;</code>/<code>std::less&lt;&gt;</code> with:</li>\n</ul>\n<pre><code>auto const less = [ibeg = std::cbegin(input)] (iterator const &amp; l, iterator const &amp; r)\n                   {\n                       return std::distance(ibeg, l) &lt; std::distance(ibeg, r);\n                   };\n</code></pre>\n<p>Say, <code>std::set&lt; iterator &gt; x;</code> modified to be <code>std::set&lt; iterator, decltype(less) &gt; x{less};</code>.</p>\n<ul>\n<li>For unordered containers internally used in the algorithm (<code>value_type</code> is <code>iterator</code>) I use <code>std::hash&lt; std::intptr_t &gt; h;</code> hash function for simple difference <code>h(lhs - rhs)</code> (actually <em>xor</em> combination of hash values, but it not matters here) for some fixed <code>iterator lhs</code> and a number of varying <code>iterator rhs</code>. It modified to be <code>h(std::distance(lhs, rhs))</code>.</li>\n</ul>\n<p>The former point is correct, but the latter is evidently no. Due to <code>rhs</code> can be unrecheable from <code>lhs</code> just only by means of simple incrementation and there is no way to know what to do a priori: to increment <code>lhs</code> to reach <code>rhs</code> or to increment <code>rhs</code> to reach <code>lhs</code>.</p>\n<p>But above hash still works. It is strange... because sometimes, when <code>lhs &gt; rhs</code> (in some sense), there should be access violation (sometimes). Say, if:</p>\n<pre><code>std::list&lt; int &gt; input{1, 2, 3, 4};\nauto a = std::begin(input), b = std::next(lhs, 2);\n</code></pre>\n<p>then increments, contained into <code>std::distance(b, a)</code>, should never stop and eventually reaches boundary of not yet allocated memory page. But AV never happens in my program. <code>std::distance</code> always return non-negative number.</p>\n<p>Is it undefined behaviour or is it permittable to apply <code>std::distance</code> for any pair of ForwardIterator-s? The <code>-stdlib=</code> is <code>libc++</code>.</p>\n", "Tags": "<c++><algorithm><c++11><stl><c++14>", "OwnerUserId": "1430927", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31907580_31907715_3": {"section_id": 5593, "quality": 0.9705882352941176, "length": 33}, "so_31907580_31907715_1": {"section_id": 5597, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_31907580_31907715_3": {"section_id": 5376, "quality": 0.9705882352941176, "length": 33}, "so_31907580_31907715_1": {"section_id": 5380, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_31907580_31907715_3": {"section_id": 7037, "quality": 0.9705882352941176, "length": 33}, "so_31907580_31907715_1": {"section_id": 7041, "quality": 0.9411764705882353, "length": 16}}}});