post_cb({"44587814": {"CommentCount": "10", "ViewCount": "66", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-06-16T11:10:24.947", "LastActivityDate": "2017-06-16T11:33:07.550", "Title": "Dynamic cast used for validating type", "AcceptedAnswerId": "44588120", "LastEditDate": "2017-06-16T11:12:51.810", "Id": "44587814", "Score": "2", "Body": "<p>To avoid an X Y situation , I'm trying to validate if a <code>void*</code> pointer cast is valid.</p>\n<p>In order to solve this I wanted to use the properties of <code>dynamic_cast</code>.</p>\n<p>Given the following code:</p>\n<pre><code>class A\n{\n  virtual void foo(){}\n};\nclass B\n{\n  virtual void bar(){}\n};\n\nvoid* createA() { return new A();}\nvoid* createB() { return new B();}\n\nint main()\n{\n   A* ptr =reinterpret_cast&lt;A*&gt;(createA());\n   A* ptr2 = reinterpret_cast&lt;A*&gt; (createB());\n\n   ptr = dynamic_cast&lt;A*&gt;(ptr); // not NULL as expected\n   ptr2 = dynamic_cast&lt;A*&gt; (ptr2); // was expecting NULL, however it's a valid pointer\n}\n</code></pre>\n<p>Wasn't dynamic_cast supposed to fail with NULL if the RTTI isn't as the expected type ?</p>\n", "Tags": "<c++><casting><dynamic-cast>", "OwnerUserId": "746569", "AnswerCount": "2"}, "44588251": {"ParentId": "44587814", "CommentCount": "0", "Body": "<p><code>dynamic_cast</code> can not be used to inspect whether a pointer to arbitrary memory address points to an object of particular kind. <code>dynamic_cast</code> will perform conversion by inspecting RTTI of the object being pointed to only at scenarios when type of this object may be in the inheritance chain of the type being cast to. In your example casting <code>B *</code> to <code>A *</code> will always produce a nullptr even if <code>B *</code> actually points to <code>A</code>:</p>\n<pre><code>A * a_ptr = dynamic_cast&lt;A*&gt;(reinterpret_cast&lt; B* &gt;(createA()));\nassert(nullptr == a_ptr);\n</code></pre>\n<p>Moreover, you are trying to cast <code>A *</code> to a <code>A *</code> which basically results in noop:</p>\n<blockquote>\n<p id=\"so_44587814_44588251_0\">5.2.7 Dynamic cast [expr.dynamic.cast]</p>\n<p id=\"so_44587814_44588251_1\">3 If the type of v is the same as T , or it is the same as T except that the class object type in T is more cv-qualified than the class object type in v, the result is v (converted if necessary).</p>\n</blockquote>\n", "OwnerUserId": "7860670", "PostTypeId": "2", "Id": "44588251", "Score": "2", "CreationDate": "2017-06-16T11:33:07.550", "LastActivityDate": "2017-06-16T11:33:07.550"}, "44588120": {"ParentId": "44587814", "CommentCount": "2", "Body": "<p>The usual way to solve such problems is to give <code>A</code> and <code>B</code> a common tag base class/interface. <code>void*</code> doesn't preserve any type information. Also <code>reinterpret_cast&lt;&gt;</code> would simply override any potentially present type information.</p>\n<p>You can do something like this:</p>\n<pre><code>class Base {\npublic:\n    virtual ~Base() {}\n};\nclass A : public Base\n{\n  virtual void foo(){}\n};\nclass B : public Base\n{\n  virtual void bar(){}\n};\n\nBase* createA() { return new A();}\nBase* createB() { return new B();}\n\nint main()\n{\n   Base* ptr = createA();\n   Base* ptr2 = createB();\n\n   ptr = dynamic_cast&lt;A*&gt;(ptr); // not NULL as expected\n   ptr2 = dynamic_cast&lt;A*&gt; (ptr2); // NULL pointer now\n}\n</code></pre>\n", "OwnerUserId": "1413395", "PostTypeId": "2", "Id": "44588120", "Score": "3", "CreationDate": "2017-06-16T11:26:50.367", "LastActivityDate": "2017-06-16T11:26:50.367"}, "bq_ids": {"n4140": {"so_44587814_44588251_1": {"section_id": 6013, "quality": 1.0, "length": 16}}, "n3337": {"so_44587814_44588251_1": {"section_id": 5781, "quality": 1.0, "length": 16}}, "n4659": {"so_44587814_44588251_1": {"section_id": 7512, "quality": 1.0, "length": 16}}}});