post_cb({"15067160": {"CommentCount": "4", "AcceptedAnswerId": "15067564", "CreationDate": "2013-02-25T12:38:33.757", "LastActivityDate": "2013-02-25T15:52:24.537", "PostTypeId": "1", "ViewCount": "24634", "FavoriteCount": "5", "Title": "std::map thread-safety", "Id": "15067160", "Score": "12", "Body": "<p>Is reference to object in std::map is thread safe?</p>\n<pre><code>std::map&lt; std::string, Object &gt;   _objects;\n</code></pre>\n<p>map can be changed from many threads and this access is synchronized, but reference to value (Object &amp;) accessable just from 1 instance and thread. is write operations with Object &amp; is safe if another thread will add items to map? will it reallocate?</p>\n", "Tags": "<c++><multithreading><map><stdmap>", "OwnerUserId": "529332", "AnswerCount": "2"}, "15067273": {"ParentId": "15067160", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Elements in a map are stable, they do not get moved or invalidated unless the element is erased from the map.  If only one thread is writing to a given object, and changes to the map itself are correctly synchronized, then <strong>I believe</strong> it will be safe. I'm sure it's safe in practice, and I think it's safe in theory too.</p>\n<p>The standard guarantees that distinct elements can be modified by different threads, in  [container.requirements.dataraces]</p>\n<blockquote>\n<p id=\"so_15067160_15067273_0\">Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n</blockquote>\n<p>This only allows you to modify the elements, not to insert new elements into the map while modifying elements.  For some containers, such as <code>std::vector</code>, modifying the vector itself might also modify elements by reallocating and moving them, but [associative.reqmts]/9 ensures <code>std::map</code> won't invalidate existing elements.</p>\n<p>Since no member function of <code>std::map</code> is required to access the second member of its elements (i.e. the <code>mapped_type</code>) I think [res.on.data.races]/5 says no other thread will conflict with writes to that member when modifying the map. (Thanks to Yakk for that final piece of the puzzle)</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2013-02-25T15:46:27.167", "Id": "15067273", "Score": "5", "CreationDate": "2013-02-25T12:43:53.550", "LastActivityDate": "2013-02-25T15:46:27.167"}, "15067564": {"ParentId": "15067160", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The C++11 standard guarantees that <code>const</code> method access to containers is safe from different threads (ie, both use <code>const</code> methods).</p>\n<p>In addition, [container.requirements.dataraces] states</p>\n<blockquote>\n<p id=\"so_15067160_15067564_0\">implementations are required to avoid data races when the contents of\n  the contained object in different elements in the same sequence,\n  excepting <code>vector&lt;bool&gt;</code></p>\n</blockquote>\n<p>In other words, except for <code>vector&lt;bool&gt;</code> modifying distinct contents is not a data race.</p>\n<p>Now, if one thread invalidates an iterator used by another thread, clearly this is a data race (and results in undefined behavior).  If one thread does non-<code>const</code> access to a container, and another does <code>const</code> access, that is a data race (and undefined behavior). (Note: a number of functions are \"considered <code>const</code>\" for the purpose of multithreading, including <code>begin</code>, <code>end</code> and other functions (and methods) that are non-<code>const</code> simply because they return non-<code>const</code> iterators.  <code>[]</code> is included in this set of pseudo-<code>const</code> for thread safety reasons, except for <code>map</code> and <code>unordered_set</code> etc -- 23.2.2.1).</p>\n<p>However, it appears that if you have a reference to an element within the container, and engage in operations that do not invalidate that reference in another thread, and never write to that element in another thread, you can safely read from that reference.  Similarly, if other threads never even read from the element, then writing to that element shouldn't result in undefined behavior.</p>\n<p>For standards references, 17.6.5.9.5 seems to guarantee that functions from the standard library won't run away and read/write elements needlessly.</p>\n<p>So the short answer: you are safe, so long as the other thread doesn't directly mess with that particular entry in the <code>map</code>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2013-02-25T15:52:24.537", "Id": "15067564", "Score": "12", "CreationDate": "2013-02-25T12:58:36.253", "LastActivityDate": "2013-02-25T15:52:24.537"}, "bq_ids": {"n4140": {"so_15067160_15067273_0": {"section_id": 718, "quality": 0.8947368421052632, "length": 17}, "so_15067160_15067564_0": {"section_id": 718, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_15067160_15067273_0": {"section_id": 707, "quality": 0.9473684210526315, "length": 18}, "so_15067160_15067564_0": {"section_id": 707, "quality": 1.0, "length": 15}}, "n4659": {"so_15067160_15067273_0": {"section_id": 749, "quality": 0.8947368421052632, "length": 17}, "so_15067160_15067564_0": {"section_id": 749, "quality": 0.9333333333333333, "length": 14}}}});