post_cb({"43361845": {"ViewCount": "87", "Body": "<p><a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rf-reference-capture\" rel=\"nofollow noreferrer\">CppCoreGuideline F.52</a> states that it is more correct to capture by reference for lambdas that are used in algorithms.</p>\n<p>I fail to see why - the algorithms are mostly defined with value semantics.</p>\n<p>In what situations <em>is</em> capturing by reference more correct?</p>\n", "Title": "Where is capture by reference more correct in the standard algorithms?", "CreationDate": "2017-04-12T06:25:08.307", "LastActivityDate": "2017-04-13T13:22:31.303", "CommentCount": "1", "PostTypeId": "1", "Id": "43361845", "Score": "2", "OwnerUserId": "6610", "Tags": "<c++><algorithm><lambda>", "AnswerCount": "4"}, "43362050": {"Id": "43362050", "PostTypeId": "2", "Body": "<p>Note that the guideline doesn't say \"for correctness,\" it says \"for efficiency and correctness.\" It's certainly more efficient to capture by reference, since the functors and predicates used in standard algorithms are passed by value. If you need access to big(gish) local objects in them, capturing by value would mean copying them with each copy of the functor. Capture by reference lets you work on the local variables directly.</p>\n<p>I confess that I cannot actually think of a scenario where using references would help <em>correctness.</em> The reason is simple: entities captured by value are <code>const</code>-qualified by default, so if you intend to modify a local variable in the lambda and accidentally capture it by copy instead of reference, you'll get a compilation error (unless you mark the lambda's call operator <code>mutable</code>, at which point you're obviously paying enough attention not to need a rule of thumb).</p>\n", "LastActivityDate": "2017-04-12T06:36:41.263", "CommentCount": "4", "CreationDate": "2017-04-12T06:36:41.263", "ParentId": "43361845", "Score": "4", "OwnerUserId": "1782465"}, "43367564": {"Id": "43367564", "PostTypeId": "2", "Body": "<p>What makes you think that \"The algorithms are mostly defined with value semantics\"?  </p>\n<p>If you look for the algrorithms that need to store an internal value, e.g. <code>std::find</code>, <code>std::fill</code>, <code>std::count</code> etc - they all capture their inputs by const reference.  </p>\n<p>I would agree however that lambdas in general can be used outside of the scope they are defined in, which as you mentioned in your github issue can lead to having dangling references - this is why the guideline specifically mentions lambdas used in algorithms.  </p>\n<p>It's safe to say that capturing local object by reference would enable the algorithm to use that object with pretty much no overhead and of course with no unnecessary copies.</p>\n<p>The \"corectness\" argument obviously refers to lambdas that mutate the captured value. Capturing by value in this case is easy to overlook as it would still compile. Essentialy the guideline says \"Instead of trying to decide what kind of capture this specific case requires, simply always capture by reference\".</p>\n<p>It's important to notice that all that reasoning does not apply to iterators and functor objects - they are not the part of lambda closure. Take a look at <code>std::find</code> declaration:  </p>\n<pre><code>template&lt; class InputIt, class T &gt;\nInputIt find( InputIt first, InputIt last, const T&amp; value );  \n</code></pre>\n<p><code>const T&amp; value</code> is what matters here - it is what your lambda would've captured if you implemented the same logic with <code>find_if</code>.<br>\n  Iterators are just a part of looping mechanics and the fact that they are passed by value is completely irrelevant to the guideline in question. </br></p>\n", "LastEditorUserId": "6350858", "LastActivityDate": "2017-04-13T13:22:31.303", "Score": "0", "CreationDate": "2017-04-12T10:54:07.987", "ParentId": "43361845", "CommentCount": "4", "OwnerUserId": "6350858", "LastEditDate": "2017-04-13T13:22:31.303"}, "bq_ids": {"n4140": {"so_43361845_43364126_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 5974}, "so_43361845_43364126_5": {"length": 30, "quality": 0.75, "section_id": 5974}}, "n3337": {"so_43361845_43364126_5": {"length": 29, "quality": 0.725, "section_id": 5742}}, "n4659": {"so_43361845_43364126_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 7473}, "so_43361845_43364126_5": {"length": 37, "quality": 0.925, "section_id": 7473}}}, "43364126": {"Id": "43364126", "PostTypeId": "2", "Body": "<p>The guideline states:</p>\n<blockquote>\n<p id=\"so_43361845_43364126_0\">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</p>\n<p id=\"so_43361845_43364126_1\">For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.</p>\n</blockquote>\n<p>For what concerns <em>efficiency</em> capturing by reference can ensure you're not copying around large objects and wasting precious resources away (since the lambda itself can also be copied around). Plus sometimes it's the only viable way if your objects are non-copyable.</p>\n<p>Regarding <em>correctness</em> I'd be inclined to agree with the other answers, anyway paying attention to the fact that </p>\n<blockquote>\n<p id=\"so_43361845_43364126_2\">lambdas [..] will be used locally</p>\n</blockquote>\n<p>(so that we don't get to deal with dangling references), one might speculate that there are corner cases where capture by value might be (arguably) behaving unintuitively:</p>\n<pre><code>int the_variable = 42;\n\nvoid test( int&amp; value ) {\n    auto modify_the_variable = [value] () mutable {\n        value = 2; // Not actually a reference this one\n    };\n    modify_the_variable();\n}\n\nint main()\n{\n    test(the_variable);\n    std::cout &lt;&lt; the_variable; // Still 42\n}\n</code></pre>\n<p>One might expect that since capturing by value is in effect and the lambda is marked as <code>mutable</code>, the type of the captured <code>value</code> would be <code>int&amp;</code>. Anyway \u00a75.1.5/16 says otherwise</p>\n<blockquote>\n<p id=\"so_43361845_43364126_3\">An entity is captured by copy if</p>\n<p id=\"so_43361845_43364126_4\">(16.1) \u2014 it is implicitly captured, the capture-default is =, and the captured entity is not *this, or\n  (16.2) \u2014 it is explicitly captured with a capture that is not of the form this, &amp; identifier, or &amp; identifier\n  initializer.</p>\n<p id=\"so_43361845_43364126_5\">For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The\n  declaration order of these members is unspecified. <strong>The type of such a data member is the referenced type\n  if the entity is a reference to an object</strong>, an lvalue reference to the referenced function type if the entity\n  is a reference to a function, or the type of the corresponding captured entity otherwise</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>In this case capturing by reference would do the right thing. Note that the guideline says: </p>\n<blockquote>\n<p id=\"so_43361845_43364126_6\">including passed to algorithms</p>\n</blockquote>\n<p>i.e. not only limited to standard library algorithms.</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2017-04-12T08:30:53.870", "Score": "1", "CreationDate": "2017-04-12T08:22:55.470", "ParentId": "43361845", "CommentCount": "2", "OwnerUserId": "1938163", "LastEditDate": "2017-04-12T08:30:53.870"}, "43362279": {"Id": "43362279", "PostTypeId": "2", "Body": "<p>For one, capturing by value is not always possible. The objects in the example e.g. contain threads.and are hence most likely not copy constructible.</p>\n<p>Another example would be random number generators in a loop: Usually you want to ensure you don't get the same sequence over and over again, which is what happens, if you capture by value (As angw points out however, your lambda would have to be mutable to work in the first place).</p>\n", "LastEditorUserId": "2881849", "LastActivityDate": "2017-04-12T07:08:50.760", "Score": "2", "CreationDate": "2017-04-12T06:48:53.790", "ParentId": "43361845", "CommentCount": "2", "OwnerUserId": "2881849", "LastEditDate": "2017-04-12T07:08:50.760"}});