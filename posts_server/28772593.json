post_cb({"bq_ids": {"n4140": {"so_28772593_28772593_0": {"length": 27, "quality": 0.9, "section_id": 233}}, "n3337": {"so_28772593_28772593_0": {"length": 27, "quality": 0.9, "section_id": 226}}, "n4659": {"so_28772593_28772593_0": {"length": 27, "quality": 0.9, "section_id": 242}}}, "28772669": {"Id": "28772669", "PostTypeId": "2", "Body": "<p>This is invalid code, because <code>A&lt;1&gt;</code> has incomplete type at the point of usage. Your quote from the standard is not relevant (<code>A&lt;1&gt;</code> cannot be instantinated at the point of usage).</p>\n<p>The situation would be different if instead you had</p>\n<pre><code>template&lt;int&gt; struct A;\ntemplate&lt;&gt; struct A&lt;1&gt; { static int a; };\ntemplate&lt;&gt; struct A&lt;2&gt;\n{\n  int a=A&lt;1&gt;::a;                    // fine: A&lt;1&gt; has complete type\n};\n</code></pre>\n<p>Moreover, in your original code, what do you think that the value of <code>A&lt;1&gt;::a</code> or <code>A&lt;0&gt;::a</code> should be? Nowhere is there a way to assign a value to it. You claim that gcc compiles this, but what's <code>A&lt;1&gt;:a</code>? garbage? null?</p>\n<hr>\n<p>As R Sahu pointed out in the comments, your code also suffers from the fact that you cannot access the member <code>A&lt;1&gt;::a</code> without an object (unless it's a <code>static</code> member).</p>\n<hr>\n<p>Regarding the access to members.</p>\n<p>In the code referred to by your comment, the member was accessed implicitly as member of the object <code>*this</code>. Thus within class <code>A&lt;1&gt;</code> (or any derived classes), <code>A&lt;1&gt;::a</code> is the same as <code>this-&gt;a</code>. But outside you must provide an object.</p>\n</hr></hr>", "LastEditorUserId": "1023390", "LastActivityDate": "2015-03-01T10:04:39.883", "Score": "5", "CreationDate": "2015-02-27T19:20:38.640", "ParentId": "28772593", "CommentCount": "7", "OwnerUserId": "1023390", "LastEditDate": "2015-03-01T10:04:39.883"}, "28772593": {"ViewCount": "45", "Body": "<p>The code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;int N&gt;\nstruct A\n{\n    int a = A&lt;1&gt;::a;\n};\n\n\nint main() { }\n</code></pre>\n<p>Is invalid for <strong><a href=\"http://coliru.stacked-crooked.com/a/b3b08b3f6a7ec5c8\" rel=\"nofollow\">CLANG</a></strong>, but valid for <strong><a href=\"http://coliru.stacked-crooked.com/a/c8d203f2379ba814\" rel=\"nofollow\">GCC</a></strong>. What behavior is actually correct? The Standard wasn't pretty clear about that:</p>\n<p><code>N4296::14.7.1/1 [temp.inst]</code></p>\n<blockquote>\n<p id=\"so_28772593_28772593_0\">Unless a class template specialization has been explicitly\n  instantiated (14.7.2) or explicitly specialized (14.7.3), the class\n  template specialization is implicitly instantiated when the\n  specialization is referenced in a context that requires a\n  completely-defined object type or when the completeness of the class\n  type affects the semantics of the program.</p>\n</blockquote>\n", "Title": "What should be right behavior when we're trying to instantiate a template?", "CreationDate": "2015-02-27T19:14:56.743", "LastActivityDate": "2015-03-01T10:04:39.883", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "28772593", "Score": "0", "Tags": "<c++><templates><specialization>", "AnswerCount": "1"}});