post_cb({"14366166": {"ParentId": "14365615", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Consider some function:</p>\n<pre><code>void f(LibraryVersion1* p)\n{\n    p-&gt;doSomething1();\n}\n</code></pre>\n<p>This will compile before LibraryVersion2 is even written.</p>\n<p>So now you implement LibraryVersion2 with the deleted virtual.</p>\n<p>f has already been compiled.  It doesn't know until runtime which LibraryVersion1 subclass it has been called with.</p>\n<p>This is why a deleted virtual isn't legal, it doesn't make any sense.</p>\n<p>Best you can do is:</p>\n<pre><code>class LibraryVersion2 : public LibraryVersion1\n{\npublic:\n    virtual void doSomething1() override\n    {\n         throw DeletedFunctionException();\n    }\n}\n</code></pre>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-01-16T19:43:21.573", "Id": "14366166", "Score": "2", "CreationDate": "2013-01-16T19:25:08.913", "LastActivityDate": "2013-01-16T19:43:21.573"}, "14365615": {"CommentCount": "5", "AcceptedAnswerId": "14366169", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2013-01-16T18:54:04.240", "LastActivityDate": "2017-01-22T13:11:24.843", "LastEditDate": "2017-01-22T13:11:24.843", "ViewCount": "4804", "FavoriteCount": "1", "Title": "C++11 Delete overridden Method", "Id": "14365615", "Score": "11", "Body": "<p><b>Preface:</b></p>\n<p>This is a question about best practices regarding a new meaning of the delete operator introduced with C++11 when applied to a child class overriding an inherited parent's virtual method.</p>\n<p><b>Background:</b></p>\n<p>Per the standard, the first use case cited is to explicitly disallow calling functions for certain types where conversions would otherwise be implicit such as the example from \u00a78.4.3 of the latest <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">C++11 standard draft</a>:</p>\n<pre><code>struct sometype {\n    sometype() = delete; // OK, but redundant\n    some_type(std::intmax_t) = delete;\n    some_type(double);\n};\n</code></pre>\n<p>The above example is clear and purposeful. However, the following example where the new operator is overridden and prevented from being called by defining it as deleted started me thinking about other scenarios that I later identify in the question section (the example below is from \u00a78.4.3 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">C++11 standard draft</a>):</p>\n<pre><code>struct sometype {\n    void *operator new(std::size_t) = delete;\n    void *operator new[](std::size_t) = delete;\n};\nsometype *p = new sometype; // error, deleted class operator new\nsometype *q = new sometype[3]; // error, deleted class operator new[]\n</code></pre>\n<p><b>Question:</b></p>\n<p>By extension of this thought to inheritance, I am curious to other's thoughts regarding whether the following usage example is a clear and valid use-case or if it is an unclear abuse of the newly added feature. Please provide justification for your answer (the example that provides the most compelling reasoning will be accepted). In the example that follows, the design attempts to maintain two versions of library (the library is required to be instantiated) by having the second version of the library inherit from the first. The idea is to allow bug fixes or changes made to the first library version to automatically propagate to the second library version while allowing the second library version to focus only on its differences from the first version. To deprecate a function in the second library version, the delete operator is used to disallow a call to the overridden function:</p>\n<pre><code>class LibraryVersion1 {\npublic:\n    virtual void doSomething1() { /* does something */ }\n    // many other library methods\n    virtual void doSomethingN() { /* does something else */ }\n};\n\nclass LibraryVersion2 : public LibraryVersion1 {\npublic:\n    // Deprecate the doSomething1 method by disallowing it from being called\n    virtual void doSomething1() override = delete;\n\n    // Add new method definitions\n    virtual void doSomethingElse() { /* does something else */ }\n};\n</code></pre>\n<p>Though I can see many benefits to such an approach, I think I tend more toward the thought that it is an abuse of the feature. The primary pitfall I see in the above example is that the classic \"is-a\" relationship of inheritance is broken. I have read many articles that strongly recommend against any use of inheritance to express a \"sort-of-is-a\" relationship and to instead use composition with wrapper functions to clearly identify the relationships of the classes. While the following often-frowned-upon example requires more effort to implement and maintain (regarding the number of lines written for this piece of code, since every inherited function to be available publicly must be explicitly called out by the inheriting class), the use of delete as depicted above is very similar in many ways:</p>\n<pre><code>class LibraryVersion1 {\npublic:\n    virtual void doSomething1() { /* does something */ }\n    virtual void doSomething2() { /* does something */ }\n    // many other library methods\n    virtual void doSomethingN() { /* does something */ }\n};\n\nclass LibraryVersion2 : private LibraryVersion1 {\n    // doSomething1 is inherited privately so other classes cannot call it\npublic:\n    // Explicitly state which functions have not been deprecated\n    using LibraryVersion1::doSomething2();\n    //  ... using (many other library methods)\n    using LibraryVersion1::doSomethingN();\n\n    // Add new method definitions\n    virtual void doSomethingElse() { /* does something else */ }\n};\n</code></pre>\n<p>Thank you in advance for your answers and further insight into this potential use-case of delete.</p>\n", "Tags": "<c++><inheritance><c++11><override>", "OwnerUserId": "1689844", "AnswerCount": "3"}, "14366900": {"ParentId": "14365615", "CommentCount": "1", "Body": "<p>10.3p16:</p>\n<blockquote>\n<p id=\"so_14365615_14366900_0\">A function with a deleted definition (8.4) shall not override a function that does not have a deleted definition.  Likewise, a function that does not have a deleted definition shall not override a function with a deleted definition.</p>\n</blockquote>\n<p>The other answers explain why pretty well, but there you have the official Thou Shalt Not.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "14366900", "Score": "4", "CreationDate": "2013-01-16T20:08:48.140", "LastActivityDate": "2013-01-16T20:08:48.140"}, "bq_ids": {"n4140": {"so_14365615_14366900_0": {"section_id": 7017, "quality": 1.0, "length": 19}}, "n3337": {"so_14365615_14366900_0": {"section_id": 6763, "quality": 1.0, "length": 19}}, "n4659": {"so_14365615_14366900_0": {"section_id": 8514, "quality": 1.0, "length": 19}}}, "14366169": {"ParentId": "14365615", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Paragraph 8.4.3/2 of the C++ Standard <em>indirectly</em> forbids deleting a function which overrides a virtual function:</p>\n<p><em>\"A program that refers to a deleted function <strong>implicitly or explicitly</strong>, other than to declare it, is ill-formed. [ Note: This <strong>includes calling the function implicitly</strong> or explicitly and forming a pointer or pointer-to-member to the function\"</em></p>\n<p>Invoking an overriding virtual function through a pointer to the base class is an attempt to <strong>implicitly</strong> invoke the function. Therefore, per 8.4.3/2, a design that allows this is illegal. Also notice that no C++11 conforming compiler will let you delete an overriding virtual function.</p>\n<p>More explicitly, the same is mandated by Paragraph 10.3/16:</p>\n<p><em>\"A function with a deleted definition (8.4) shall not override a function that does not have a deleted definition. Likewise, a function that does not have a deleted definition shall not override a function with a deleted definition.</em>\"</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-01-16T20:20:43.040", "Id": "14366169", "Score": "5", "CreationDate": "2013-01-16T19:25:17.947", "LastActivityDate": "2013-01-16T20:20:43.040"}});