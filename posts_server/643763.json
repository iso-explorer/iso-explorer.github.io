post_cb({"643927": {"PostTypeId": "2", "Body": "<p>The following is from the standard.</p>\n<p>14.3.2.1:</p>\n<blockquote>\n<p id=\"so_643763_643927_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>an integral constant-expression of integral or enumeration type; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>the address of an object or function with external linkage, including function templates and function template-ids but excluding non-static class members, expressed as &amp; id-expression where the &amp; is optional if the name refers to a function or array, or if the corresponding template-parameter is a reference; or</li>\n<li>a pointer to member expressed as described in 5.3.1 .</li>\n</ul>\n</blockquote>\n<p>5.19.1:</p>\n<blockquote>\n<p id=\"so_643763_643927_1\">In several places, C++ requires expressions that evaluate to an integral or enumeration constant: as array bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2), as static member initializers (9.4.2), and as integral or enumeration non-type template arguments (14.3).</p>\n<pre><code> constant-expression:\n            conditional-expression\n</code></pre>\n<p id=\"so_643763_643927_2\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and sizeof expressions. Floating literals (2.13.3) can appear only if they are cast to integral or enumeration types. Only type conversions to integral or enumera-\n  tion types can be used. In particular, except in sizeof expressions, functions, class objects, pointers, or references shall not be used, and assignment, increment, decrement, function-call, or comma operators shall not be used.</p>\n</blockquote>\n<p>With respect to your previous post I believe the essence in the part \"const variables ... <em>initialised</em> with ...\" (and I don't think initialised externally counts).</p>\n", "OwnerDisplayName": "mweerden", "LastActivityDate": "2009-03-13T18:12:58.277", "Id": "643927", "CommentCount": "0", "CreationDate": "2009-03-13T18:12:58.277", "ParentId": "643763", "Score": "13", "OwnerUserId": "4285"}, "bq_ids": {"n4140": {"so_643763_643927_1": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}, "so_643763_643927_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_643763_643927_0": {"length": 5, "quality": 1.0, "section_id": 82}}}, "643936": {"Body": "<p>It has to be a integral constant expression. That's explained by the Standard document at <code>5.19</code>:</p>\n<blockquote>\n<p id=\"so_643763_643936_0\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and sizeof expressions. Floating literals (2.13.3) can appear only if they are cast to integral or enumeration types. Only type conversions to integral or enumeration types can be used. </p>\n</blockquote>\n<p>Note that \"integral\" is another term for \"integer\", but is not the same as \"int\". \"char\" for example has integer/integral type, but is not the int type, obviously. So concretely, the following is allowed</p>\n<ul>\n<li><code>10 or 10L or anything like that</code></li>\n<li><code>enum { THIS, OR, THAT };</code></li>\n<li><code>int const this_one = 10;</code></li>\n<li><code>sizeof(char)</code> </li>\n<li>of course, any other template parameter as detailed above</li>\n</ul>\n<p>Any of those can be used as a template argument for a parameter that has an integral type of the corresponding type. Some conversions are still applied though. So if it wants an int and you pass a char, it automatically promotes the char to the int. Same if you provide an enumerator and it wants an int. </p>\n<p>So by those rules, if you have</p>\n<pre><code>extern const int SomeName;\n</code></pre>\n<p>And it does not see a definition which initializes that constant with a integral constant expression, it can't be used as a template argument. But it can be used as a function argument, of course. Those don't need to be known at compile time because those are not part of a type. The moment you name a template specialization, the arguments you used become part of the type:</p>\n<pre><code>MyGreatStack&lt;int, 4&gt; // 4 is now part of the type MyGreatStack&lt;int, 4&gt;!\n</code></pre>\n<p>Note that there <em>are</em> other ways to pass <code>SomeName</code> as an argument. However, all of which can <em>not</em> be accepted by an integer template parameter. You can accept the above by a reference parameter, for example</p>\n<pre><code>template&lt;const int&amp; V&gt; struct NowItWorks { };\n</code></pre>\n<p>And it would accept the <code>SomeName</code> of above. Now, rather than a value, a particular location that is unique across the whole program (as the variable has <code>extern</code> linkage) has been chosen. </p>\n", "CreationDate": "2009-03-13T18:14:58.753", "ParentId": "643763", "CommentCount": "0", "LastEditDate": "2009-03-13T18:44:06.580", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-03-13T18:44:06.580", "LastEditorUserId": "34509", "Id": "643936", "OwnerDisplayName": "litb", "Score": "4", "OwnerUserId": "34509"}, "643763": {"ViewCount": "10495", "Body": "<p>If you are using a template in C++ that takes an integer value as a parameter, are there any requirements on an integer variable used as the parameter that are different than if the variable was used as a parameter in a function call? </p>\n<p>This is a follow-up to question  <a href=\"https://stackoverflow.com/questions/641397/c-best-way-to-define-cross-file-constants/641431#641431\">here</a> .  I specifically want to address if there is a difference WRT variables declared as \"extern const int\" for functions or templates?</p>\n<p>I can see that for some template cases the parameter value would be needed at compile time.  Is this always true?  Is there a way to specify, maybe for only certain uses of the parameter value, that the value be used at runtime? </p>\n", "Title": "What are the requirements for C++ template parameters?", "CreationDate": "2009-03-13T17:27:34.453", "LastActivityDate": "2009-03-14T06:10:57.130", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:22:20.300", "LastEditorDisplayName": "jeffD", "OwnerDisplayName": "jeffD", "LastEditorUserId": "-1", "Id": "643763", "Score": "8", "OwnerUserId": "54822", "Tags": "<c++><templates><parameters><const><extern>", "AnswerCount": "3"}, "643780": {"PostTypeId": "2", "Body": "<p>It is always the case that the value of the int is needed at compile time.</p>\n<p>Since each template instantiation is a separate piece of compiled code (even for integer template paramaters) that integer needs to be available when compiled (and it must be guaranteed to never change).</p>\n<p>This is also why it's a good idea to not use integer template parameters when you are going to be using a large number of unique values - you can quickly end up with a huge executable file.</p>\n", "OwnerDisplayName": "Josh", "LastActivityDate": "2009-03-13T17:30:43.667", "Id": "643780", "CommentCount": "0", "CreationDate": "2009-03-13T17:30:43.667", "ParentId": "643763", "Score": "3", "OwnerUserId": "8701"}});