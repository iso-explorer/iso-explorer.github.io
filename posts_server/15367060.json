post_cb({"15367324": {"ParentId": "15367060", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>17.6.4.7p4 says:</p>\n<blockquote>\n<p id=\"so_15367060_15367324_0\">Calling the <code>set_*</code> and <code>get_*</code> functions shall not incur a data race. A call to any of the <code>set_*</code> functions shall synchronize with subsequent calls to the same <code>set_*</code> function and to the corresponding <code>get_*</code> function.</p>\n</blockquote>\n<p>This strongly implies that the <code>set_*</code> and <code>get_*</code> functions are operating on the same global state even when called from different threads.  All the paragraphs under 18.8.3 discuss \"<em>the current handler function</em>\", with no other mention of threading; this indicates that the handler function is a property of the program as a whole; similarly, 17.6.4.7 has:</p>\n<blockquote>\n<p id=\"so_15367060_15367324_1\">2 - A C++ program may install different handler functions during execution [...]<br/>\n  3 - A C++ program can get a pointer to the current handler function by calling the following functions [...]</p>\n</blockquote>\n<p>These paragraphs discuss <em>the current handler function</em> in the context of a program, indicating that it is program-scope and not thread-local.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "196561", "LastEditDate": "2013-03-12T17:09:02.150", "Id": "15367324", "Score": "9", "CreationDate": "2013-03-12T16:52:55.667", "LastActivityDate": "2013-03-12T17:09:02.150"}, "15368020": {"ParentId": "15367060", "CommentCount": "1", "Body": "<p>C2003 has no threads, any thread support is a vendor extension so only vendor-supplied documentation has the answer. If the handler is per thread, the documentation ought to say that. No implementation I know does it.</p>\n<p>C++2011 says nothing about per-thread nature of the terminate handler. It would make little sense to maintain it per thread, because you cannot kill a thread in C++11. And for a good reason too (google kill+thread+c++11). So whatever you do, the program must terminate. It looks like having different ways to terminate the program depending on the thread that requested it is not a feature anyone needs.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "15368020", "Score": "2", "CreationDate": "2013-03-12T17:27:49.510", "LastActivityDate": "2013-03-12T17:27:49.510"}, "15367344": {"ParentId": "15367060", "CommentCount": "5", "Body": "<p>In the Standard it says under</p>\n<p><strong>18.8.3.2 set_terminate [set.terminate]</strong></p>\n<p><code>terminate_handler set_terminate(terminate_handler f) noexcept;</code></p>\n<blockquote>\n<p id=\"so_15367060_15367344_0\">1 Effects: Establishes the function designated by f as the current handler function for <strong>terminating</strong> exception processing.</p>\n</blockquote>\n<p><code>[[noreturn]] void terminate() noexcept;</code></p>\n<blockquote>\n<p id=\"so_15367060_15367344_1\">2 Effects: Calls the current terminate_handler function. [ Note: A default terminate_handler is <strong>always considered</strong> a callable handler in this context. \u2014end note ]</p>\n</blockquote>\n<p>You can see that <code>terminate()</code>  calls the <strong>current</strong> terminate handler, which in the <code>set_handler</code> section it quite clearly says it is used for <strong>terminating</strong> a process.  This gets called when all other exception handling has failed, irrespective from which thread is running.</p>\n<p>There is only one terminate handler, and it always gets called from wherever the program is terminating.</p>\n", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "15367344", "Score": "3", "CreationDate": "2013-03-12T16:54:09.087", "LastActivityDate": "2013-03-12T16:54:09.087"}, "bq_ids": {"n4140": {"so_15367060_15367344_1": {"section_id": 6930, "quality": 0.7142857142857143, "length": 10}, "so_15367060_15367324_1": {"section_id": 6320, "quality": 0.5625, "length": 9}, "so_15367060_15367344_0": {"section_id": 6925, "quality": 0.9, "length": 9}, "so_15367060_15367324_0": {"section_id": 6322, "quality": 1.0, "length": 19}}, "n3337": {"so_15367060_15367344_1": {"section_id": 6678, "quality": 0.7142857142857143, "length": 10}, "so_15367060_15367324_1": {"section_id": 6077, "quality": 0.5625, "length": 9}, "so_15367060_15367344_0": {"section_id": 6673, "quality": 0.9, "length": 9}, "so_15367060_15367324_0": {"section_id": 6079, "quality": 1.0, "length": 19}}, "n4659": {"so_15367060_15367344_1": {"section_id": 8427, "quality": 0.7142857142857143, "length": 10}, "so_15367060_15367324_1": {"section_id": 7830, "quality": 0.5625, "length": 9}, "so_15367060_15367344_0": {"section_id": 8422, "quality": 0.9, "length": 9}, "so_15367060_15367324_0": {"section_id": 7832, "quality": 1.0, "length": 19}}}, "15367060": {"CommentCount": "1", "AcceptedAnswerId": "15367324", "PostTypeId": "1", "LastEditorUserId": "196561", "CreationDate": "2013-03-12T16:40:26.037", "LastActivityDate": "2013-03-12T17:27:49.510", "LastEditDate": "2013-03-12T17:05:31.577", "ViewCount": "2242", "FavoriteCount": "4", "Title": "C++, is set_terminate local to every thread?", "Id": "15367060", "Score": "9", "Body": "<p>Should <code>set_terminate</code>/<code>get_terminate</code> set a different terminate exception processor for several threads in C++ 2011 or C++ 2003?</p>\n<p>E.g. if I have program and sets terminate handler to <code>func_1</code>; then I start 3 threads. What are terminate handlers in new threads? What if in every thread I will set terminate handler to <code>func_2</code> in first thread, <code>func_3</code> in second thread and so on. </p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">N3242</a> (C++ 2011 draft) says nothing about it in <code>[handler.functions]</code> or in <code>[support.exception]</code>/<code>[exception.terminate]</code></p>\n<p>PS: You may answer for C++2011 or for C++2003 of for any popular implementation of these standards</p>\n<p>PPS: There is FCD Comment for this... <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3249.html\" rel=\"noreferrer\">C++ FCD Comment Status Rev. 5 N3249 (2011)</a>:</p>\n<pre><code>GB 71    18.6.2.4 / 18.8.2.2 / 18.8.3.2   \n</code></pre>\n<blockquote>\n<p id=\"so_15367060_15367060_0\">The thread safety of <code>std::set_new_handler()</code>, <code>std::set_unexpected()</code>, <code>std::set_terminate()</code>, is unspecified making the the functions impossible to use in a thread safe manner.    </p>\n<p id=\"so_15367060_15367060_1\">The thread safety guarantees for the functions must be specified and new interfaces should be provided to make it possible to query and install handlers in a thread safe way. </p>\n<p id=\"so_15367060_15367060_2\">LWG   <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html#1365\" rel=\"noreferrer\">1365</a>    ACCEPTED with MODIFICATIONS </p>\n<p id=\"so_15367060_15367060_3\">See paper  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.htm\" rel=\"noreferrer\">N3189</a></p>\n</blockquote>\n", "Tags": "<c++><exception-handling><c++11><language-lawyer><c++03>", "OwnerUserId": "196561", "AnswerCount": "3"}});