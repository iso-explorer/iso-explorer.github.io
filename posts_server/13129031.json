post_cb({"13129226": {"ParentId": "13129031", "CommentCount": "2", "Body": "<p>I believe that is not a valid definition of <code>std::swap</code> because <code>std::swap</code> is defined to take lvalue references, not rvalue references (20.2.2 [utility.swap])</p>\n", "OwnerUserId": "16406", "PostTypeId": "2", "Id": "13129226", "Score": "0", "CreationDate": "2012-10-29T20:35:10.373", "LastActivityDate": "2012-10-29T20:35:10.373"}, "13129446": {"ParentId": "13129031", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>[res.on.arguments] is a statement about how the client should use the std::lib.  When the client sends an xvalue to a std::lib function, the client has to be willing to pretend that the xvalue is really a prvalue, and expect the std::lib to take advantage of that.</p>\n<p>However when the client calls std::swap(x, x), the client isn't sending an xvalue to a std::lib function.  It is the implementation that is doing so instead.  And so the onus is on the implementation to make std::swap(x, x) work.</p>\n<p>That being said, the std has given the implementor a guarantee:  X shall satisfy <code>MoveAssignable</code>.  Even if in a moved-from state, the client must ensure that X is MoveAssignable.  Furthermore, the implementation of <code>std::swap</code> doesn't really care what self-move-assignment does, as long as it is not undefined behavior for X.  I.e. as long as it doesn't crash.</p>\n<pre><code>a = std::move(b);\n</code></pre>\n<p>When &amp;a == &amp;b, both the source and target of this assignment have an unspecified (moved-from) value.  This can be a no-op, or it can do something else.  As long as it doesn't crash, std::swap will work correctly.  This is because in the next line:</p>\n<pre><code>b = std::move(tmp);\n</code></pre>\n<p>Whatever value went into <code>a</code> from the previous line is going to be given a new value from <code>tmp</code>.  And <code>tmp</code> has the original value of <code>a</code>.  So besides burning up a lot of cpu cycles, <code>swap(a, a)</code> is a no-op.</p>\n<p><strong>Update</strong></p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4618.pdf\" rel=\"nofollow noreferrer\">latest working draft, N4618</a> has been modified to clearly state that in the <code>MoveAssignable</code> requirements the expression:</p>\n<pre><code>t = rv\n</code></pre>\n<p>(where <code>rv</code> is an rvalue), <code>t</code> need only be the equivalent value of <code>rv</code> prior to the assignment if <code>t</code> and <code>rv</code> do not reference the same object.  And regardless, <code>rv</code>'s state is unspecified after the assignment.  There is an additional note for further clarification:</p>\n<blockquote>\n<p id=\"so_13129031_13129446_0\"><code>rv</code> must still meet the requirements of the library component that is using it, whether or not <code>t</code> and <code>rv</code> refer to the same object.</p>\n</blockquote>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2017-02-12T17:09:32.867", "Id": "13129446", "Score": "6", "CreationDate": "2012-10-29T20:50:54.910", "LastActivityDate": "2017-02-12T17:09:32.867"}, "13129031": {"CommentCount": "5", "ViewCount": "1475", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-29T20:21:28.013", "LastActivityDate": "2017-02-12T17:09:32.867", "Title": "On implementing std::swap in terms of move assignment and move constructor", "FavoriteCount": "6", "LastEditDate": "2017-05-23T12:34:41.050", "Id": "13129031", "Score": "9", "Body": "<p>Here is a possible definition of <code>std::swap</code>:</p>\n<pre><code>template&lt;class T&gt;\nvoid swap(T&amp; a, T&amp; b) {\n  T tmp(std::move(a));\n  a = std::move(b);\n  b = std::move(tmp);\n}\n</code></pre>\n<p>I believe that</p>\n<ol>\n<li><code>std::swap(v,v)</code> is guaranteed to have no effects and</li>\n<li><code>std::swap</code> can be implemented as above.</li>\n</ol>\n<p>The following quote seems to me to imply that these beliefs are contradictory.</p>\n<p><strong>17.6.4.9 Function arguments [res.on.arguments]</strong></p>\n<blockquote>\n<p id=\"so_13129031_13129031_0\">1 Each of the following applies to all arguments to functions defined\n  in the C++ standard library, unless explicitly stated otherwise.</p>\n<p id=\"so_13129031_13129031_1\">...</p>\n<ul>\n<li>If a function argument binds to an rvalue reference parameter, the implementation may assume that this parameter is a unique reference to\n  this argument. [ Note: If the parameter is a generic parameter of the\n  form T&amp;&amp; and an lvalue of type A is bound, the argument binds to an\n  lvalue reference (14.8.2.1) and thus is not covered by the previous\n  sentence. \u2014 end note ] [ Note: If a program casts an lvalue to an\n  xvalue while passing that lvalue to a library function (e.g. by\n  calling the function with the argument move(x)), the program is\n  effectively asking that function to treat that lvalue as a temporary.\n  The implementation is free to optimize away aliasing checks which\n  might be needed if the argument was an lvalue. \u2014endnote]</li>\n</ul>\n</blockquote>\n<p>(thanks to <a href=\"https://stackoverflow.com/users/576911/howard-hinnant\">Howard Hinnant</a> for <a href=\"https://stackoverflow.com/questions/13127455/what-does-the-standard-library-guarantee-about-self-move-assignment\">providing the quote</a>)</p>\n<p>Let <code>v</code> be an object of some movable type taken from the Standard Template Library and consider the call <code>std::swap(v, v)</code>. In the line <code>a = std::move(b);</code> above, it is the case inside <code>T::operator=(T&amp;&amp; t)</code> that <code>this == &amp;b</code>, so the parameter is <strong>not</strong> a unique reference. That is a violation of the requirement made above, so the line <code>a = std::move(b)</code> invokes undefined behavior when called from <code>std::swap(v, v)</code>.</p>\n<p>What is the explanation here?</p>\n", "Tags": "<c++><stl><c++11><move-semantics>", "OwnerUserId": "822360", "AnswerCount": "4"}, "29067984": {"ParentId": "13129031", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I agree with your analysis, and in fact the libstdc++ Debug Mode has an assertion that will fire on self-swap of standard containers:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;utility&gt;\n\nstruct S {\n  std::vector&lt;int&gt; v;\n};\n\nint main()\n{\n  S s;\n  std::swap(s, s);\n}\n</code></pre>\n<p>The wrapper type <code>S</code> is needed because swapping vector directly uses the specialization that calls <code>vector::swap()</code> and so doesn't use the generic <code>std::swap</code>, but <code>S</code> will use the generic one, and when compiled as C++11 that will result in a self-move-assignment of the vector member, which will abort:</p>\n<pre><code>/home/toor/gcc/4.8.2/include/c++/4.8.2/debug/vector:159:error: PST.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0x7fffe8fecc00 {\n  type = NSt7__debug6vectorIiSaIiEEE;\n}\nAborted (core dumped)\n</code></pre>\n<p>(I don't know what \"PST\" is supposed to mean there! I think something is wrong with the installation I tested it with.)</p>\n<p>I believe GCC's behaviour here is conforming, because the standard says that the implementation can assume that self-move-assignment never happens, therefore the assertion will never fail in a valid program.</p>\n<p>However, I agree with Howard that this needs to work (and can be made to work without too much trouble - for libstdc++ we just need to delete the debug mode assertion!), and so we need to fix the standard to make an exception for self-move, or at least self-swap. I have been promising to write a paper about this issue for some time, but haven't done so yet.</p>\n<p>I believe that since writing his answer here Howard now agrees there is a problem with the current wording in the standard, and we need to fix it to forbid libstdc++ from making that assertion that fails.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-03-16T00:43:02.333", "Id": "29067984", "Score": "2", "CreationDate": "2015-03-16T00:37:10.850", "LastActivityDate": "2015-03-16T00:43:02.333"}, "bq_ids": {"n4140": {"so_13129031_13129031_0": {"section_id": 6325, "quality": 1.0, "length": 11}, "so_13129031_13129446_0": {"section_id": 6276, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_13129031_13129031_0": {"section_id": 6082, "quality": 1.0, "length": 11}, "so_13129031_13129446_0": {"section_id": 6036, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_13129031_13129031_0": {"section_id": 7835, "quality": 1.0, "length": 11}, "so_13129031_13129446_0": {"section_id": 7783, "quality": 1.0, "length": 11}}}, "13129284": {"ParentId": "13129031", "CommentCount": "6", "Body": "<p>Then the expression <code>a = std::move(b);</code> gets executed, the object is already empty, in a state where only destruction is well defined. That will effectively be a no-op, as the object on the left and right hand sides is already empty. The state of the object after the move is still unknown but destructible. The next statement moves the contents back from <code>tmp</code> and that sets the object back to a known state.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "13129284", "Score": "3", "CreationDate": "2012-10-29T20:39:10.540", "LastActivityDate": "2012-10-29T20:39:10.540"}});