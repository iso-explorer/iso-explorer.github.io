post_cb({"8311457": {"CommentCount": "2", "AcceptedAnswerId": "8311472", "PostTypeId": "1", "LastEditorUserId": "673730", "CreationDate": "2011-11-29T13:23:21.077", "LastActivityDate": "2011-12-22T09:41:12.787", "LastEditDate": "2011-12-22T09:41:12.787", "ViewCount": "12428", "FavoriteCount": "10", "Title": "Are destructors called after a throw in C++?", "Id": "8311457", "Score": "33", "Body": "<p>I ran a sample program and indeed destructors for stack-allocated objects are called, but is this guaranteed by the standard?</p>\n", "Tags": "<c++><exception-handling><try-catch><raii>", "OwnerUserId": "673730", "AnswerCount": "2"}, "8311540": {"ParentId": "8311457", "CommentCount": "6", "Body": "<p>Yes, destructors are guaranteed to be called on stack unwinding, including unwinding due to exception being thrown. There are only few tricks with exceptions that you have to remember:</p>\n<ul>\n<li>Destructor of the class is not called if exception is thrown in its constructor.</li>\n<li>Exception is automatically re-thrown if caught in construction initialization list catch block.</li>\n</ul>\n", "Id": "8311540", "PostTypeId": "2", "OwnerDisplayName": "user405725", "Score": "5", "CreationDate": "2011-11-29T13:29:19.477", "LastActivityDate": "2011-11-29T13:29:19.477"}, "8311472": {"ParentId": "8311457", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-11-29T13:24:26.993", "Score": "49", "LastEditorUserId": "367273", "LastEditDate": "2011-11-29T16:41:52.680", "Id": "8311472", "OwnerUserId": "367273", "Body": "<p>Yes, it is guaranteed (provided the exception is caught), down to <em>the order</em> in which the destructors are invoked:</p>\n<blockquote>\n<p id=\"so_8311457_8311472_0\">C++11 <strong>15.2 Constructors and destructors [except.ctor]</strong></p>\n<p id=\"so_8311457_8311472_1\">1 As control passes from a throw-expression to a handler, destructors are invoked for all\n  automatic objects constructed since the try block was entered. The\n  automatic objects are destroyed in the reverse order of the completion\n  of their construction.</p>\n</blockquote>\n<p>Furthermore, if the exception is thrown during object construction, the subobjects of the partially-constructed object are guaranteed to be correctly destroyed:</p>\n<blockquote>\n<p id=\"so_8311457_8311472_2\">2 An object of any storage duration whose initialization or\n  destruction is terminated by an exception will have destructors\n  executed for all of its fully constructed subobjects (excluding the\n  variant members of a union-like class), that is, for subobjects for\n  which the principal constructor (12.6.2) has completed execution and\n  the destructor has not yet begun execution. Similarly, if the\n  non-delegating constructor for an object has completed execution and a\n  delegating constructor for that object exits with an exception, the\n  object\u2019s destructor will be invoked. If the object was allocated in a\n  new-expression, the matching deallocation function (3.7.4.2, 5.3.4,\n  12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<p>This whole process is known as \"stack unwinding\":</p>\n<blockquote>\n<p id=\"so_8311457_8311472_3\">3 The process of calling destructors for automatic objects constructed\n  on the path from a try block to a throw-expression is called \u201cstack\n  unwinding.\u201d If a destructor called during stack unwinding exits with\n  an exception, std::terminate is called (15.5.1).</p>\n</blockquote>\n<p>Stack unwinding forms the basis of the widely-used technique called <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"noreferrer\">Resource Acquisition Is Initialization (RAII)</a>.</p>\n<p>Note that stack unwinding is not necessarily done if the exception is not caught. In this case it's up to the implementation whether stack unwinding is done. But whether stack unwinding is done or not, in this case you're  guaranteed a final call to <code>std::terminate</code>.</p>\n<blockquote>\n<p id=\"so_8311457_8311472_4\">C++11 <strong>15.5.1 The std::terminate() function [except.terminate]</strong></p>\n<p id=\"so_8311457_8311472_5\">2 \u2026 In the situation where no matching handler is found,\n  it is implementation-defined whether or not the stack is unwound before <code>std::terminate()</code> is called.</p>\n</blockquote>\n", "LastActivityDate": "2011-11-29T16:41:52.680"}, "bq_ids": {"n4140": {"so_8311457_8311472_1": {"section_id": 3343, "quality": 0.9166666666666666, "length": 22}, "so_8311457_8311472_3": {"section_id": 3345, "quality": 0.7916666666666666, "length": 19}, "so_8311457_8311472_2": {"section_id": 3344, "quality": 0.9354838709677419, "length": 58}, "so_8311457_8311472_5": {"section_id": 3383, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_8311457_8311472_1": {"section_id": 3213, "quality": 0.9583333333333334, "length": 23}, "so_8311457_8311472_3": {"section_id": 3215, "quality": 0.8333333333333334, "length": 20}, "so_8311457_8311472_2": {"section_id": 3214, "quality": 0.9354838709677419, "length": 58}, "so_8311457_8311472_5": {"section_id": 3252, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_8311457_8311472_1": {"section_id": 4109, "quality": 0.625, "length": 15}, "so_8311457_8311472_5": {"section_id": 4143, "quality": 0.9166666666666666, "length": 11}}}});