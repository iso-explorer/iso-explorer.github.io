post_cb({"11301742": {"ParentId": "11301514", "LastEditDate": "2012-07-03T08:05:10.570", "CommentCount": "3", "CreationDate": "2012-07-02T21:58:01.960", "OwnerUserId": "981959", "LastEditorUserId": "981959", "PostTypeId": "2", "Id": "11301742", "Score": "3", "Body": "<p>I believe the intention of that wording is that some casts can be done at compile-time, e.g. upcasts or <code>dynamic_cast&lt;Y*&gt;((X*)0)</code>, but that others need a run-time check (in which case a polymorphic type is needed.)</p>\n<p>If your code snippet was well-formed it would need a run-time check to see if it's a null pointer value, which contradicts the idea that a run-time check should only happen for the polymorphic case.</p>\n<p>See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#665\" rel=\"nofollow\">DR 665</a> which clarified that certain casts are ill-formed at compile-time, rather than postponed to run-time.</p>\n", "LastActivityDate": "2012-07-03T08:05:10.570"}, "11302549": {"ParentId": "11301514", "LastEditDate": "2012-07-02T23:51:18.340", "CommentCount": "6", "CreationDate": "2012-07-02T23:29:21.963", "OwnerUserId": "491645", "LastEditorUserId": "491645", "PostTypeId": "2", "Id": "11302549", "Score": "1", "Body": "<p>To me, it seems pretty clear cut. I think the confusion comes when you make the wrong interpretation that the enumeration of requirements is an \"else if .. else if ..\" type of thing.</p>\n<p>Points (1) and (2) simply define what the static input and output types are allowed to be, in terms of cv-qualification and lvalue-rvalue-prvalue-- etc. So that's trivial and applies to all cases.</p>\n<p>Point (3) is pretty clear, if both the input and output type are the same (added cv-qualifiers aside), then the conversion is trivial (none, or just added cv-qualifiers).</p>\n<p>Point (4) clearly requires that if the input pointer is null, then the output pointer is null too. This point needs to be made as a requirement, not as a matter of rejecting or accepting the cast (via static analysis), but as a matter of stressing the fact that if the conversion from input pointer to output pointer would normally entail an offset to the actual pointer value (as it can, under multiple-inheritance class hierarchies), then that offset must not be applied if the input pointer is null, in order to preserve the \"nullness\" of the pointer. This just means that when the dynamic-cast is performed, the pointer is checked for nullity, and if it is null, the resulting pointer must also have a null-value.</p>\n<p>Point (5) simply states that if it is an upcast (from derived to base), then the cast is resolved statically (equivalent to <code>static_cast&lt;T&gt;(v)</code>). This is mostly to handle the case (as the footnote indicates) where the upcast is well-formed, but that there could be the potential for an ill-formed cast if one were to go to the most-derived object pointed to by v (e.g., if v actual points to derived object with multiple base classes in which the class T appears more than once). In other words, this means, if it's an upcast, do it statically, without a run-time mechanism (thus, avoiding a potential failure, where it shouldn't happen). Under this case, the compiler should reject the cast on the same basis as if it was a <code>static_cast&lt;T&gt;(v)</code>.</p>\n<p>In Point (6), clearly, the \"otherwise\" refers directly to Point (5) (and surely to the trivial case of Point (3)). Meaning (together with Point (7)), that if the cast is not an upcast (and not an identity-cast (Point (3))), then it is a down-cast, and it should be resolved at run-time, with the explicit requirement that the type (of v) be a polymorphic type (has a virtual function).</p>\n<p>Your code should be rejected by a standard-compliant compiler. To me, there's no doubts about it. Because, the cast is a down-cast, and the type of v is not polymorphic. It doesn't meet the requirements set out by the standard. The null-pointer clause (point (4)) really has nothing to do with whether it is accepted code or not, it just has to do with preserving a null pointer-value across the cast (otherwise, some implementations could make the (stupid) choice to still apply the pointer-offset of the cast even if the value is null).</p>\n<p>Of course, they could have made a different choice, and allowed the cast to behave as a static-cast from base to derived (i.e., without a run-time check), when the base type is not polymorphic, but I think that breaks the semantics of the dynamic-cast, which is clearly to say \"I want a run-time check on this cast\", otherwise you wouldn't use a dynamic-cast!</p>\n", "LastActivityDate": "2012-07-02T23:51:18.340"}, "11301514": {"CommentCount": "11", "ViewCount": "297", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-03T08:05:10.570", "Body": "<p>This question is inspired by comments <a href=\"https://stackoverflow.com/questions/11301161/is-it-ok-to-dynamic-cast-this-as-a-return-value\">here</a>.</p>\n<p>Consider the following code snippet:</p>\n<pre><code>struct X {}; // no virtual members\nstruct Y : X {}; // may or may not have virtual members, doesn't matter\n\nY* func(X* x) { return dynamic_cast&lt;Y*&gt;(x); }\n</code></pre>\n<p>Several people suggested that their compiler would reject the body of <code>func</code>.</p>\n<p>However, it appears to me that whether this is defined by the Standard depends on the run-time value of <code>x</code>.  From section 5.2.7 (<code>[expr.dynamic.cast]</code>):</p>\n<blockquote>\n<ol>\n<li><p id=\"so_11301514_11301514_0\">The result of the expression <code>dynamic_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression <code>v</code> to type <code>T</code>. <code>T</code> shall be a pointer or\n  reference to a complete class type, or \"pointer to <em>cv</em> <code>void</code>.\" The\n  <code>dynamic_cast</code> operator shall not cast away constness.</p></li>\n<li><p id=\"so_11301514_11301514_1\">If <code>T</code> is a pointer type, <code>v</code> shall be a prvalue of a pointer to complete class\n  type, and the result is a prvalue of type <code>T</code>. If <code>T</code> is an lvalue\n  reference type, <code>v</code> shall be an lvalue of a complete class type, and the\n  result is an lvalue of the type referred to by <code>T</code>. If <code>T</code> is an rvalue\n  reference type, <code>v</code> shall be an expression having a complete class type,\n  and the result is an xvalue of the type referred to by <code>T</code>.</p></li>\n<li><p id=\"so_11301514_11301514_2\">If the\n  type of <code>v</code> is the same as <code>T</code>, or it is the same as <code>T</code> except that the\n  class object type in <code>T</code> is more cv-qualified than the class object type\n  in <code>v</code>, the result is <code>v</code> (converted if necessary).</p></li>\n<li><p id=\"so_11301514_11301514_3\"><strong>If the value of <code>v</code> is a null pointer value in the pointer case, the result is the null pointer value of type <code>T</code>.</strong></p></li>\n<li><p id=\"so_11301514_11301514_4\">If T is \"pointer to <em>cv1</em> <code>B</code>\" and <code>v</code> has type\n  'pointer to <em>cv2</em> <code>D</code>\" such that <code>B</code> is a base class of <code>D</code>, the result is a\n  pointer to the unique <code>B</code> subobject of the <code>D</code> object pointed to by <code>v</code>.\n  Similarly, if T is \"reference to <em>cv1</em> <code>B</code>\" and <code>v</code> has type <em>cv2</em> <code>D</code> such that\n  <code>B</code> is a base class of <code>D</code>, the result is the unique <code>B</code> subobject of the <code>D</code>\n  object referred to by <code>v</code>. The result is an lvalue if <code>T</code> is an lvalue\n  reference, or an xvalue if <code>T</code> is an rvalue reference. In both the\n  pointer and reference cases, the program is ill-formed if <em>cv2</em> has\n  greater cv-qualification than <em>cv1</em> or if <code>B</code> is an inaccessible or\n  ambiguous base class of <code>D</code>.</p></li>\n<li><p id=\"so_11301514_11301514_5\"><strong>Otherwise, <code>v</code> shall be a pointer to or an lvalue of a polymorphic type.</strong></p></li>\n<li><p id=\"so_11301514_11301514_6\">If <code>T</code> is\n  \"pointer to <em>cv</em> <code>void</code>,\" then the result is a pointer to the most derived\n  object pointed to by <code>v</code>. Otherwise, a run-time check is applied to see\n  if the object pointed or referred to by <code>v</code> can be converted to the type\n  pointed or referred to by <code>T</code>.) The most derived object pointed\n  or referred to by <code>v</code> can contain other <code>B</code> objects as base classes, but\n  these are ignored. </p></li>\n<li><p id=\"so_11301514_11301514_7\">If <code>C</code> is the class type to which <code>T</code> points or refers,\n  the run-time check logically executes as follows:</p>\n<ul>\n<li><p id=\"so_11301514_11301514_8\">If, in the most\n  derived object pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a\n  <code>public</code> base class subobject of a <code>C</code> object, and if only one object of\n  type <code>C</code> is derived from the subobject pointed (referred) to by <code>v</code> the\n  result points (refers) to that <code>C</code> object.</p></li>\n<li><p id=\"so_11301514_11301514_9\">Otherwise, if <code>v</code> points\n  (refers) to a <code>public</code> base class subobject of the most derived object,\n  and the type of the most derived object has a base class, of type <code>C</code>,\n  that is unambiguous and <code>public</code>, the result points (refers) to the <code>C</code>\n  subobject of the most derived object.</p></li>\n<li><p id=\"so_11301514_11301514_10\">Otherwise, the run-time check\n  <em>fails</em>.</p></li>\n</ul></li>\n<li><p id=\"so_11301514_11301514_11\">The value of a failed cast to pointer type is the null\n  pointer value of the required result type. A failed cast to reference\n  type throws <code>std::bad_cast</code>.</p></li>\n</ol>\n</blockquote>\n<p>The way I read this, the requirement of a polymorphic type only applies if none of the above conditions are met, and one of those conditions depends on the runtime value.</p>\n<p>Of course, in a few cases the compiler can positively determine that the input cannot properly be NULL (for example, when it is the <code>this</code> pointer), but I still think the compiler cannot reject the code unless it can determine that the statement will be reached (normally a run-time question).</p>\n<p>A warning diagnostic is of course valuable here, but is it Standard-compliant for the compiler to reject this code with an error?</p>\n", "Title": "Can a standard-compliant compiler reject code containing dynamic_cast downcast from non-polymorphic type?", "FavoriteCount": "5", "LastEditDate": "2017-05-23T12:02:19.143", "Id": "11301514", "Score": "15", "CreationDate": "2012-07-02T21:33:48.943", "Tags": "<c++><polymorphism><virtual><language-lawyer><dynamic-cast>", "OwnerUserId": "103167", "AnswerCount": "3"}, "11301637": {"ParentId": "11301514", "CommentCount": "5", "Body": "<p>A very good point. </p>\n<p>Note that in C++03 the wording of 5.2.7/3 and 5.2.7/4 is as follows</p>\n<blockquote>\n<p id=\"so_11301514_11301637_0\"><strong>3</strong> If the type of <strong>v</strong> is the same as the required result type (which, for\n  convenience, will be called <strong>R</strong> in this description), or it is the same\n  as <strong>R</strong> except that the class object type in <strong>R</strong> is more cv-qualified than\n  the class object type in <strong>v</strong>, the result is <strong>v</strong> (converted if necessary).</p>\n<p id=\"so_11301514_11301637_1\"><strong>4</strong> If the value of <strong>v</strong> is a null pointer value in the pointer case, the\n  result is the null pointer value of type <strong>R</strong>.</p>\n</blockquote>\n<p>The reference to type <code>R</code> introduced in 5.2.7/3 seems to imply that 5.2.7/4 is intended to be a sub-clause of 5.2.7/3. In other words, it appears that 5.2.7/4 is intended to apply only under the conditions described in 5.2.7/3, i.e. when types are the same.</p>\n<p>However, the wording in C++11 is different and no longer involves <code>R</code>, which no longer suggests any special relationship between 5.2.7/3 and 5.2.7/4. I wonder whether it was changed intentionally...</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "11301637", "Score": "3", "CreationDate": "2012-07-02T21:46:01.220", "LastActivityDate": "2012-07-02T21:46:01.220"}, "bq_ids": {"n4140": {"so_11301514_11301514_6": {"section_id": 6017, "quality": 0.6111111111111112, "length": 22}, "so_11301514_11301637_1": {"section_id": 6014, "quality": 1.0, "length": 11}, "so_11301514_11301514_7": {"section_id": 6018, "quality": 1.0, "length": 9}, "so_11301514_11301514_8": {"section_id": 6018, "quality": 1.0, "length": 23}, "so_11301514_11301514_3": {"section_id": 6014, "quality": 1.0, "length": 11}, "so_11301514_11301514_4": {"section_id": 6015, "quality": 0.8571428571428571, "length": 42}, "so_11301514_11301637_0": {"section_id": 6013, "quality": 0.6956521739130435, "length": 16}, "so_11301514_11301514_9": {"section_id": 6018, "quality": 1.0, "length": 26}, "so_11301514_11301514_0": {"section_id": 6011, "quality": 0.9047619047619048, "length": 19}, "so_11301514_11301514_5": {"section_id": 6016, "quality": 0.8, "length": 4}, "so_11301514_11301514_11": {"section_id": 6019, "quality": 0.9444444444444444, "length": 17}, "so_11301514_11301514_1": {"section_id": 6012, "quality": 1.0, "length": 33}, "so_11301514_11301514_2": {"section_id": 6013, "quality": 1.0, "length": 16}}, "n3337": {"so_11301514_11301514_6": {"section_id": 5785, "quality": 0.6111111111111112, "length": 22}, "so_11301514_11301637_1": {"section_id": 5782, "quality": 1.0, "length": 11}, "so_11301514_11301514_7": {"section_id": 5786, "quality": 1.0, "length": 9}, "so_11301514_11301514_8": {"section_id": 5786, "quality": 1.0, "length": 23}, "so_11301514_11301514_3": {"section_id": 5782, "quality": 1.0, "length": 11}, "so_11301514_11301514_4": {"section_id": 5783, "quality": 0.8571428571428571, "length": 42}, "so_11301514_11301637_0": {"section_id": 5781, "quality": 0.6956521739130435, "length": 16}, "so_11301514_11301514_9": {"section_id": 5786, "quality": 1.0, "length": 26}, "so_11301514_11301514_0": {"section_id": 5779, "quality": 0.9047619047619048, "length": 19}, "so_11301514_11301514_5": {"section_id": 5784, "quality": 1.0, "length": 5}, "so_11301514_11301514_11": {"section_id": 5787, "quality": 0.9444444444444444, "length": 17}, "so_11301514_11301514_1": {"section_id": 5780, "quality": 1.0, "length": 33}, "so_11301514_11301514_2": {"section_id": 5781, "quality": 1.0, "length": 16}}, "n4659": {"so_11301514_11301514_6": {"section_id": 7516, "quality": 0.6111111111111112, "length": 22}, "so_11301514_11301637_1": {"section_id": 7513, "quality": 1.0, "length": 11}, "so_11301514_11301514_4": {"section_id": 7514, "quality": 0.7142857142857143, "length": 35}, "so_11301514_11301514_8": {"section_id": 7517, "quality": 1.0, "length": 23}, "so_11301514_11301514_3": {"section_id": 7513, "quality": 1.0, "length": 11}, "so_11301514_11301514_7": {"section_id": 7517, "quality": 1.0, "length": 9}, "so_11301514_11301514_0": {"section_id": 7510, "quality": 0.9047619047619048, "length": 19}, "so_11301514_11301514_9": {"section_id": 7517, "quality": 1.0, "length": 26}, "so_11301514_11301637_0": {"section_id": 7512, "quality": 0.6956521739130435, "length": 16}, "so_11301514_11301514_5": {"section_id": 7515, "quality": 0.8, "length": 4}, "so_11301514_11301514_11": {"section_id": 7518, "quality": 0.9444444444444444, "length": 17}, "so_11301514_11301514_1": {"section_id": 7511, "quality": 0.9696969696969697, "length": 32}, "so_11301514_11301514_2": {"section_id": 7512, "quality": 1.0, "length": 16}}}});