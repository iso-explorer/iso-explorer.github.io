post_cb({"bq_ids": {"n4140": {"so_26256174_26256294_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 3304}, "so_26256174_26256294_3": {"length": 9, "quality": 1.0, "section_id": 3304}, "so_26256174_26256294_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 633}, "so_26256174_26256294_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_26256174_26256294_5": {"length": 9, "quality": 1.0, "section_id": 3325}, "so_26256174_26256294_4": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_26256174_26256294_1": {"length": 4, "quality": 0.8, "section_id": 3325}}, "n3337": {"so_26256174_26256294_3": {"length": 9, "quality": 1.0, "section_id": 3174}, "so_26256174_26256294_2": {"length": 17, "quality": 0.7391304347826086, "section_id": 3174}, "so_26256174_26256294_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 3195}, "so_26256174_26256294_4": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_26256174_26256294_5": {"length": 9, "quality": 1.0, "section_id": 3195}, "so_26256174_26256294_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_26256174_26256294_1": {"length": 4, "quality": 0.8, "section_id": 3195}}, "n4659": {"so_26256174_26256294_3": {"length": 9, "quality": 1.0, "section_id": 4070}, "so_26256174_26256294_2": {"length": 16, "quality": 0.6956521739130435, "section_id": 4070}, "so_26256174_26256294_6": {"length": 5, "quality": 0.8333333333333334, "section_id": 4091}, "so_26256174_26256294_4": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_26256174_26256294_5": {"length": 9, "quality": 1.0, "section_id": 4091}, "so_26256174_26256294_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_26256174_26256294_1": {"length": 4, "quality": 0.8, "section_id": 4091}}}, "26256174": {"ViewCount": "255", "Body": "<p>If I have a common linux struct like:</p>\n<pre><code>struct sockaddr_in\n{\n  sa_family_t    sin_family;   \n  in_port_t      sin_port;     \n  struct in_addr sin_addr;     \n\n  unsigned char  __pad[__SOCK_SIZE__ - sizeof(short int)\n                        - sizeof(unsigned short int) - sizeof(struct in_addr)];\n};\n#define sin_zero        __pad\n</code></pre>\n<p>and I perform aggregate initialization:</p>\n<pre><code>struct sockaddr_in my_addr = { 0 };\n</code></pre>\n<p>how come that this initializes every member to 0?</p>\n<p>I mean: documentation says:</p>\n<blockquote>\n<p id=\"so_26256174_26256174_0\">If the number of initializer clauses is less than the number of\n  members or initializer clauses is completely empty, the remaining\n  members are initialized by their brace-or-equal initializers, if\n  provided in the class definition, and otherwise (since C++14) by empty\n  lists, which performs value-initialization.</p>\n</blockquote>\n<p>to make it easy: why does this code print 0?</p>\n<pre><code>struct sockaddr_in my_addr = {2, 2}; // initialize sin_family and sin_port to 2, everything else value-initialized\n\nmy_addr = {0};\n\nstd::cout &lt;&lt; my_addr.sin_port; // Why is this 0?\n</code></pre>\n", "AcceptedAnswerId": "26256294", "Title": "Structure aggregate initialization with less clauses, why does it initialize everything?", "CreationDate": "2014-10-08T11:47:06.650", "Id": "26256174", "CommentCount": "9", "LastEditDate": "2014-10-08T14:48:03.797", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-09T01:54:39.600", "Score": "3", "OwnerUserId": "3834459", "Tags": "<c++><initialization><list-initialization>", "AnswerCount": "2"}, "26256294": {"Id": "26256294", "PostTypeId": "2", "Body": "<p>This is covered in the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">draft C++14 standard</a> section <code>8.5.4</code> <em>List-initialization</em> which says:</p>\n<blockquote>\n<p id=\"so_26256174_26256294_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_26256174_26256294_1\">If T is an aggregate, aggregate initialization is performed (8.5.1).</p>\n</blockquote>\n<p>and has the following example:</p>\n<pre><code>struct S2 {\n    int m1;\n    double m2, m3;\n}\nS2 s21 = { 1, 2, 3.0 }; // OK\nS2 s22 { 1.0, 2, 3 }; // error: narrowing\nS2 s23 { }; // OK: default to 0,0,0\n</code></pre>\n<p>and <code>8.5.1</code> <em>Aggregates</em> which says:</p>\n<blockquote>\n<p id=\"so_26256174_26256294_2\">If there are fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member\n  not explicitly initialized shall be initialized from its\n  brace-or-equal-initializer or, if there is no\n  brace-or-equalinitializer, from an empty initializer list (8.5.4). [\n  Example:</p>\n<pre><code>struct S { int a; const char* b; int c; int d = b[a]; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_26256174_26256294_3\">initializes ss.a with 1, ss.b with \"asdf\", ss.c with the value of an\n  expression of the form int{} (that is, 0)</p>\n</blockquote>\n<p>Note that <code>8.5.4</code> is slightly different in C++11, it says:</p>\n<blockquote>\n<p id=\"so_26256174_26256294_4\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n<ul>\n<li><p id=\"so_26256174_26256294_5\">If the initializer list has no elements and T is a class\n  type with a default constructor, the object is value-initialized.</p></li>\n<li><p id=\"so_26256174_26256294_6\">Otherwise, if T is an aggregate, aggregate initialization is performed\n  (8.5.1).</p></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-09T01:54:39.600", "Score": "2", "CreationDate": "2014-10-08T11:52:56.473", "ParentId": "26256174", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-10-09T01:54:39.600"}, "26256508": {"Id": "26256508", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26256174_26256508_0\">how come that this initializes every member to 0?</p>\n</blockquote>\n<p>Because that's what C does when initializing structs, and C++ does the same for aggregate initialization for compatibility.</p>\n<p>C does it because it's more convenient (it's usually what you want for members that you don't give an explicit value to) and safer that way (it doesn't leave dangerously uninitialized variables lying around).</p>\n<p>If you really want the other members of the struct to remain uninitialized you can do it like this:</p>\n<pre><code>struct sockaddr_in s; // entirely uninitialized\ns.sin_family = 0;     // only initialize one member\n</code></pre>\n", "LastActivityDate": "2014-10-08T12:07:05.520", "CommentCount": "2", "CreationDate": "2014-10-08T12:07:05.520", "ParentId": "26256174", "Score": "1", "OwnerUserId": "981959"}});