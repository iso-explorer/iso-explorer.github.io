post_cb({"bq_ids": {"n4140": {"so_10539140_10539616_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6141}}, "n3337": {"so_10539140_10539616_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5905}}, "n4659": {"so_10539140_10539616_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 7603}}}, "10539233": {"Id": "10539233", "PostTypeId": "2", "Body": "<p>You take <code>&amp;v1</code> into c.p and later using operator ++ you advance it. You cannot rely on the ordering of the stack, therefore comes undefined behavior (<code>(&amp;v1)+1 != &amp;v2</code>)</p>\n", "LastActivityDate": "2012-05-10T17:25:44.857", "Score": "-3", "CreationDate": "2012-05-10T17:25:44.857", "ParentId": "10539140", "CommentCount": "7", "OwnerUserId": "362589"}, "10539140": {"ViewCount": "655", "Body": "<p>I am experiencing strange crashes. And I wonder whether it is a bug in my code, or the compiler.\nWhen I compile the following C++ code with Microsoft Visual Studio 2010 as an optimized release build, it crashes in the marked line:</p>\n<pre><code>struct tup { int x; int y; };\n\nclass C \n{\npublic:\n  struct tup* p;\n\n  struct tup* operator--() { return --p; }\n  struct tup* operator++(int) { return p++; }\n\n  virtual void Reset() { p = 0;}\n};\n\nint main ()\n{\n  C c;\n  volatile int x = 0;\n  struct tup v1;\n  struct tup v2 = {0, x};\n\n  c.p = &amp;v1;\n  (*(c++)) = v2;\n\n  struct tup i = (*(--c));   // crash! (dereferencing a NULL-pointer)\n  return i.x;\n}\n</code></pre>\n<p>Looking into the disassembly, it's obvious that it must crash:</p>\n<pre><code>int _tmain(int argc, _TCHAR* argv[])\n{\n00CE1000  push        ebp  \n00CE1001  mov         ebp,esp  \n00CE1003  sub         esp,0Ch  \n  C c;\n  volatile int x = 0;\n00CE1006  xor         eax,eax  \n00CE1008  mov         dword ptr [x],eax  \n  struct tup v1;\n  struct tup v2 = {0, x};\n00CE100B  mov         ecx,dword ptr [x]  \n\n  c.p = &amp;v1;\n  (*(c++)) = v2;\n00CE100E  mov         dword ptr [ebp-8],ecx  \n\n  struct tup i = (*(--c));\n00CE1011  mov         ecx,dword ptr [x]  \n00CE1014  mov         dword ptr [v1],eax  \n00CE1017  mov         eax,dword ptr [ecx]  \n00CE1019  mov         ecx,dword ptr [ecx+4]  \n00CE101C  mov         dword ptr [ebp-8],ecx  \nreturn i.x;\n}\n00CE101F  mov         esp,ebp  \n00CE1021  pop         ebp  \n00CE1022  ret  \n</code></pre>\n<p>At offset 00CE1008 it writes a 0 into x.</p>\n<p>At offset 00CE100B it reads x (the 0) into ecx</p>\n<p>At offset 00CE1017 it dereferences that 0-pointer.</p>\n<p>I see two possible reasons:</p>\n<ul>\n<li><p>Either there is some subtle (or not so subtle?) case of undefined behaviour in my code\nand the compiler \"optimizes\" this undefined behaviour into a crash.</p></li>\n<li><p>or there is a compiler bug</p></li>\n</ul>\n<p>Does anyone see what might cause the problem?</p>\n<p>Thank you,</p>\n<p>Jonas</p>\n<p><strong>EDIT: To address the comments regarding \"pointer to invalid location\"</strong></p>\n<p>If I change <code>v1</code> to be <code>struct tup v1[10];</code> and set <code>c.p = &amp;v1[0];</code>, then there will be no pointer to an invalid location. But I can still observe the same behaviour. The disassembly looks marginally different, but there is still a crash and it is still caused by loading 0 into ecx and dereferencing it.</p>\n<p><strong>EDIT: Conclusion</strong></p>\n<p>So, probably it is a bug. I found out that the crash vanishes if I change</p>\n<pre><code>struct tup* operator--() { return --p; }\n</code></pre>\n<p>to</p>\n<pre><code>struct tup* operator--() { --p; return p; }\n</code></pre>\n<p>As bames53 tells us, the crash does not occur in VS2011 and concludes that it must have been fixed.</p>\n<p>Nontheless, I decided to file that bug for two reasons:</p>\n<ul>\n<li><p>The bug might still be present in VS2011. Maybe the optimizer just has changed in a way that my code doesn't trigger the bug anymore. (the bug seems to be very subtle, it doesn't occur when I remove the <code>volative</code> or the <code>virtual void Reset()</code>)</p></li>\n<li><p>I want to know if my workaround is a reliable way to rule out the crashes, or if code changes in other places can reintroduce the bug.</p></li>\n</ul>\n<p>Here is the link:</p>\n<p><a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/741628/error-in-code-generation-for-x86\" rel=\"nofollow\">https://connect.microsoft.com/VisualStudio/feedback/details/741628/error-in-code-generation-for-x86</a></p>\n", "AcceptedAnswerId": "10539616", "Title": "Crash in C++ code due to undefined behaviour or compiler bug?", "CreationDate": "2012-05-10T17:20:18.217", "Id": "10539140", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-05-11T08:52:30.143", "LastEditorUserId": "859211", "LastActivityDate": "2012-05-11T08:52:30.143", "Score": "16", "OwnerUserId": "859211", "Tags": "<c++><visual-studio-2010><visual-c++><crash><compiler-optimization>", "AnswerCount": "3"}, "10539409": {"Id": "10539409", "PostTypeId": "2", "Body": "<p>It doesn't have to be UB or compiler bug. It can be neither due to the way that VS2010 was produced.</p>\n<p>Strictly speaking, your program exhibits well-defined behaviour. However, that might only be according to the newest C++ Standard. VS2010 is only implemented against a draft Standard which may not have included this provision. If it did not, then your code is not UB, but VS is not incorrect to produce UB, as those were the requirements of the time it was made.</p>\n<p>Of course, if it's been legal to treat stack objects as an array of one object in C++03, then it is a compiler bug.</p>\n<p>Edit: If you still get the crash for an array as you state, then that is definitely a compiler bug.</p>\n", "LastActivityDate": "2012-05-10T17:39:18.650", "Score": "1", "CreationDate": "2012-05-10T17:39:18.650", "ParentId": "10539140", "CommentCount": "0", "OwnerUserId": "298661"}, "10539616": {"Id": "10539616", "PostTypeId": "2", "Body": "<p>The code is fine. It's a compiler bug.</p>\n<p>The code <code>*(c++) = v2</code> will post-increment <code>c.p</code> yielding the original value. That value was assigned in the previous line and is <code>&amp;v1</code>. So, in effect, it does <code>v1 = v2;</code>, which is perfectly fine.</p>\n<p><code>c.p</code> now behaves as a one-past-the-end of a one element array that holds only <code>v1</code>, per \u00a75.7p4 of the standard:</p>\n<blockquote>\n<p id=\"so_10539140_10539616_0\">For the purposes of these operators [<code>+</code> and <code>-</code>], a pointer to a\n  nonarray object behaves the same as a pointer to the first element of\n  an array of length one with the type of the object as its element\n  type.</p>\n</blockquote>\n<p>Then <code>*(--c)</code> moves that pointer back to <code>&amp;v1</code> and dereferences it, which is also fine.</p>\n", "LastActivityDate": "2012-05-10T17:54:01.337", "Score": "17", "CreationDate": "2012-05-10T17:54:01.337", "ParentId": "10539140", "CommentCount": "3", "OwnerUserId": "46642"}});