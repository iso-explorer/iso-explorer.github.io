post_cb({"648398": {"CommentCount": "6", "CreationDate": "2009-03-15T19:38:45.770", "LastEditorUserId": "75192", "LastActivityDate": "2009-03-15T19:48:38.600", "ParentId": "648380", "PostTypeId": "2", "LastEditorDisplayName": "Julian Aubourg", "LastEditDate": "2009-03-15T19:48:38.600", "Id": "648398", "Score": "1", "Body": "<p>++i should be performed before allocation AND call.</p>\n<p>EDIT: (and I may have answered a bit too quickly)</p>\n", "OwnerUserId": "75192", "OwnerDisplayName": "Julian Aubourg"}, "648404": {"CommentCount": "0", "CreationDate": "2009-03-15T19:39:26.097", "LastEditorUserId": "-1", "LastActivityDate": "2009-03-15T19:39:26.097", "ParentId": "648380", "LastEditDate": "2017-05-23T10:32:49.587", "OwnerDisplayName": "JaredPar", "PostTypeId": "2", "Id": "648404", "Score": "4", "Body": "<p>In general, the C++ compiler is free to re-order function parameters as long as it does not alter the meaning. </p>\n<p>See Martin's answer here: <a href=\"https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about\">What are all the common undefined behaviours that a C++ programmer should know about?</a></p>\n<p>There are actually 2 function calls going on here under the hood.</p>\n<ol>\n<li>operator new</li>\n<li>constructor call for X</li>\n</ol>\n<p>Even though it's two separate calls, I do not believe there is a sequence point between these two operations.  Wikipedia appears to <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">support this point</a>.  Therefore the Compiler is free to reorder evaluation as it sees fit.</p>\n", "OwnerUserId": "23283"}, "648380": {"CommentCount": "0", "AcceptedAnswerId": "648442", "OwnerDisplayName": "Curious", "CreationDate": "2009-03-15T19:27:35.547", "LastActivityDate": "2009-03-15T20:14:07.900", "PostTypeId": "1", "ViewCount": "472", "FavoriteCount": "2", "Title": "Evaluation order of new expression?", "Id": "648380", "Score": "7", "Body": "<p>In the following code sample, do the C++ standard guarantee that '++i' is evaluated after the memory allocation (call to operator new) but before the call to X\u2019s constructor?</p>\n<pre><code>new X( ++i )\n</code></pre>\n", "Tags": "<c++>", "AnswerCount": "5"}, "648442": {"CommentCount": "5", "CreationDate": "2009-03-15T20:01:40.677", "LastEditorUserId": "66692", "LastActivityDate": "2009-03-15T20:14:07.900", "ParentId": "648380", "PostTypeId": "2", "LastEditorDisplayName": "dirkgently", "LastEditDate": "2009-03-15T20:14:07.900", "Id": "648442", "Score": "12", "Body": "<p>From my copy of n2798:</p>\n<blockquote>\n<p id=\"so_648380_648442_0\"><strong>5.3.4 New</strong></p>\n<p id=\"so_648380_648442_1\">21 Whether the allocation function is called before evaluating the constructor arguments or after evaluating the constructor arguments but before entering the constructor is unspecified. It is also unspecified whether the arguments to a constructor are evaluated if the allocation function returns the null pointer or exits using an exception.</p>\n</blockquote>\n<p>Read in conjunction with (to avoid ambiguities):</p>\n<blockquote>\n<p id=\"so_648380_648442_2\"><strong>5.3.4 New</strong></p>\n<p id=\"so_648380_648442_3\">8 A new-expression obtains storage for the object by calling an allocation function (3.7.4.1). If the newexpression terminates by throwing an exception, it may release storage by calling a deallocation function (3.7.4.2). If the allocated type is a non-array type, the allocation function\u2019s name is operator new and the deallocation function\u2019s name is operator delete. If the allocated type is an array type, the allocation\n  function\u2019s name is operator new[] and the deallocation function\u2019s name is operator  delete[]. [...]</p>\n</blockquote>\n<p>This pretty much answers the question. The answer is 'No'.</p>\n", "OwnerUserId": "66692", "OwnerDisplayName": "dirkgently"}, "648399": {"ParentId": "648380", "CommentCount": "1", "Body": "<p>In a word, no.</p>\n<p>There is no sequence point between \"new\" and \"++i\"</p>\n", "OwnerUserId": "66341", "Id": "648399", "PostTypeId": "2", "OwnerDisplayName": "zildjohn01", "Score": "2", "CreationDate": "2009-03-15T19:38:48.127", "LastActivityDate": "2009-03-15T19:38:48.127"}, "648440": {"ParentId": "648380", "CommentCount": "1", "Body": "<p>new X( ++i )</p>\n<p>The syntax for new operator wrt C++ standard:</p>\n<p>[::] \"new\" [\"(\" expression-list \")\"] {new-type-id | \"(\" type-id \")\"} [\"(\" expression-list \")\"] </p>\n<p>So,</p>\n<ol>\n<li>Allocates memory for object X.</li>\n<li>The expression list will evaluated to be passed into the constructor of the object allocated.</li>\n</ol>\n<p>so, we can sure that, ++i will be evaluated, before the constructor of Object X is invoked.</p>\n<p>Cheers..</p>\n", "OwnerUserId": "75021", "Id": "648440", "PostTypeId": "2", "OwnerDisplayName": "Vijay", "Score": "1", "CreationDate": "2009-03-15T20:00:23.660", "LastActivityDate": "2009-03-15T20:00:23.660"}, "bq_ids": {"n4140": {"so_648380_648442_3": {"section_id": 6089, "quality": 0.9148936170212766, "length": 43}}, "n3337": {"so_648380_648442_3": {"section_id": 5857, "quality": 0.9361702127659575, "length": 44}}, "n4659": {"so_648380_648442_3": {"section_id": 7585, "quality": 0.9361702127659575, "length": 44}}}});