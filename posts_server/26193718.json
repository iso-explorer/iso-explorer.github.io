post_cb({"26193853": {"ParentId": "26193718", "CommentCount": "0", "Body": "<p><code>c2</code> is not an aggregate in C++11, but is in C++14. So the code should not compile in the former, and should in the latter. It looks like clang is compiling in C++14 mode.</p>\n<p><code>c3</code> is not an aggregate due to the presence of a <code>private</code> data member, so it should not compile, regardless of the standard..</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "26193853", "Score": "2", "CreationDate": "2014-10-04T14:37:17.200", "LastActivityDate": "2014-10-04T14:37:17.200"}, "26193854": {"ParentId": "26193718", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is aggregate initialization.</p>\n<p>C++11 paragraph that defines an aggregate says (n3337, \u00a78.5.1/1):</p>\n<blockquote>\n<p id=\"so_26193718_26193854_0\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), <em>no brace-or-equal</em> initializers for non-static data\n  members (9.2), no private or protected non-static data members (Clause\n  11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>This means that <code>c2</code> is not an aggregate and <code>auto c2_ = c2{true, '0', 0};</code> should trigger a diagnostic in C++11 (and gcc is right).</p>\n<p>However, with clang, you seem to compile in C++14 mode, which removed the \"no brace-or-equal initializers\" limitation (n3690, \u00a78.5.1/1):</p>\n<blockquote>\n<p id=\"so_26193718_26193854_1\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>So, <code>auto c2_ = c2{true, '0', 0};</code> is okay in C++14.</p>\n<p>About <code>auto c2__ = c2{true, '0'};</code>, \u00a78.5.1/7 (n3690) says:</p>\n<blockquote>\n<p id=\"so_26193718_26193854_2\">If there are fewer <em>initializer-clauses</em> in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from its <em>brace-or-equal-initializer</em> or, if there\n  is no <em>brace-or-equal-initializer</em>, from an empty initializer list\n  (8.5.4).</p>\n</blockquote>\n<p>Which means it's ok and clang is right to compile it in C++14 mode.</p>\n<p><code>c3</code> is not an aggregate (because of private member) neither in C++11 nor in C++14 so all compilers are correct to reject it.</p>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2014-10-04T14:47:29.470", "Id": "26193854", "Score": "4", "CreationDate": "2014-10-04T14:37:45.853", "LastActivityDate": "2014-10-04T14:47:29.470"}, "26193718": {"CommentCount": "0", "ViewCount": "720", "PostTypeId": "1", "LastEditorUserId": "1293787", "CreationDate": "2014-10-04T14:20:20.700", "LastActivityDate": "2014-10-04T14:47:29.470", "Title": "Clang vs GCC vs MSVC - using brace-enclosed initializer list to create user defined type?", "AcceptedAnswerId": "26193854", "LastEditDate": "2014-10-04T14:30:14.387", "Id": "26193718", "Score": "2", "Body": "<p>Was experimenting with brace-enclosed initializer list and compilers seems to behave differently (well, it's a fairly new feature), but was wondering what should be the correct behavior and especially if 'c3' mentioned below should actually compiles with private, default initialized variable?</p>\n<pre><code>int main() {\n    struct c1 {\n        bool b;\n        char c;\n        int i;\n    };\n\n    auto c1_ = c1{true, '0', 0};\n    //clang-3.6 - okay\n    //gcc-4.9   - okay\n    //vs-2013   - okay\n\n    // ------------------------------------------\n\n    struct c2 {\n        bool b;\n        char c;\n        int i = 0; // with default value\n    };\n\n    auto c2_ = c2{true, '0', 0};\n    //clang-3.6 - okay\n    //gcc-4.9   - error: no matching function for call to \u2018c2::c2(&lt;brace-enclosed initializer list&gt;)\u2019\n    //vs-2013   - error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'initializer-list' to 'c2'\n\n    auto c2__ = c2{true, '0'};\n    //clang-3.6 - okay\n    //gcc-4.9   - error: no matching function for call to \u2018c2::c2(&lt;brace-enclosed initializer list&gt;)\u2019\n    //vs-2013   - error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'initializer-list' to 'c2'\n\n    // ------------------------------------------\n\n    struct c3 {\n        bool b;\n        char c;\n    private:\n        int i = 0; // with private default value\n    };\n\n    auto c3_ = c3{true, '0'};\n    //clang-3.6 - error: no matching constructor for initialization of 'c3'\n    //gcc-4.9   - error: no matching function for call to \u2018c3::c3(&lt;brace-enclosed initializer list&gt;)\u2019\n    //vs-2013   - error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'initializer-list' to 'c3'\n}\n</code></pre>\n", "Tags": "<c++><visual-c++><gcc><c++11><clang>", "OwnerUserId": "1293787", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26193718_26193854_0": {"section_id": 3298, "quality": 0.6666666666666666, "length": 16}, "so_26193718_26193854_1": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}, "so_26193718_26193854_2": {"section_id": 3304, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_26193718_26193854_0": {"section_id": 3168, "quality": 0.7916666666666666, "length": 19}, "so_26193718_26193854_1": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}, "so_26193718_26193854_2": {"section_id": 3174, "quality": 0.7727272727272727, "length": 17}}, "n4659": {"so_26193718_26193854_1": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}, "so_26193718_26193854_2": {"section_id": 4070, "quality": 0.7272727272727273, "length": 16}}}, "26193852": {"ParentId": "26193718", "CommentCount": "0", "Body": "<pre><code> auto c2_ = c2{true, '0', 0};\n auto c2__ = c2{true, '0'};\n</code></pre>\n<p>These are fine in C++14. The in-class initialization does not stop the type from being an aggregate in C++14, and the in-class value will be used when a value is not provided by the brace-initializer.</p>\n<pre><code>auto c3_ = c3{true, '0'};\n</code></pre>\n<p>This is an error, because aggregates cannot have <code>private:</code> or <code>protected:</code> members. Since it's not an aggregate you only have the implicitly declared default constructor. You can do the following:</p>\n<pre><code>auto c3_ = c3{};\n</code></pre>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "26193852", "Score": "2", "CreationDate": "2014-10-04T14:37:14.680", "LastActivityDate": "2014-10-04T14:37:14.680"}});