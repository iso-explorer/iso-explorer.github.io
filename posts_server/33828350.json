post_cb({"33829487": {"ParentId": "33828350", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-20T14:46:27.303", "Score": "5", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-23T17:50:57.393", "Id": "33829487", "OwnerUserId": "1708801", "Body": "<p>So what we have here is aggregate initialization covered in section <code>8.5.1</code> of the draft C++ standard and it says:</p>\n<blockquote>\n<p id=\"so_33828350_33829487_0\">An aggregate is an array or a class [...]</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_33828350_33829487_1\">When an aggregate is initialized by an initializer list, as specified\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is copy-initialized from the\n  corresponding initializer-clause [...]</p>\n</blockquote>\n<p>The problem is that although it seems reasonable that side effects from initializing each member of the aggregate should be sequenced before the next, since each element in the initializer list is a full expression. The standard does not actually guarantee this we can see this from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1343\" rel=\"nofollow\">defect report 1343</a> which says:</p>\n<blockquote>\n<p id=\"so_33828350_33829487_2\">The current wording does not indicate that initialization of a non-class object is a full-expression, but presumably should do so.</p>\n</blockquote>\n<p>and also notes:</p>\n<blockquote>\n<p id=\"so_33828350_33829487_3\">Aggregate initialization could also involve more than one full-expression, so the limitation above to \u201cinitialization of a non-class object\u201d is not correct. </p>\n</blockquote>\n<p>and we can see from a related <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/lH86B0MhbAc/Kedqd0qwEMgJ\" rel=\"nofollow\">std-discussion topic</a> Richard Smith says:</p>\n<blockquote>\n<p id=\"so_33828350_33829487_4\">[intro.execution]p10: \"A full-expression is an expression that is not\n  a subexpression of another expression. [...] If a language construct\n  is defined to produce an implicit call of a function, a use of the\n  language construct is considered to be an expression for the purposes\n  of this definition.\"</p>\n<p id=\"so_33828350_33829487_5\">Since a braced-init-list is not an expression, and in this case it\n  does not result in a function call, 5 and s.i are separate\n  full-expressions. Then:</p>\n<p id=\"so_33828350_33829487_6\">[intro.execution]p14: \"Every value computation and side effect\n  associated with a full-expression is sequenced before every value\n  computation and side effect associated with the next full-expression\n  to be evaluated.\"</p>\n<p id=\"so_33828350_33829487_7\">So the only question is, is the side-effect of initializing s.i\n  \"associated with\" the evaluation of the full-expression \"5\"? I think\n  the only reasonable assumption is that it is: if 5 were initializing a\n  member of class type, the constructor call would obviously be part of\n  the full-expression by the definition in [intro.execution]p10, so it\n  is natural to assume that the same is true for scalar types.</p>\n<p id=\"so_33828350_33829487_8\">However, I don't think the standard actually explicitly says this\n  anywhere.</p>\n</blockquote>\n<p>So this is currently not specified by the standard and can not be relied upon, although I would be surprised if an implementation did not treat it the way you expect.</p>\n<p>For a simple case like this something similar to this seems a better alternative:</p>\n<pre><code>constexpr int value = 13 ;\nconst int foo[2] = {value, value+42};\n</code></pre>\n", "LastActivityDate": "2015-11-23T17:50:57.393"}, "bq_ids": {"n4140": {"so_33828350_33829487_1": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}, "so_33828350_33829487_6": {"section_id": 5810, "quality": 0.9473684210526315, "length": 18}, "so_33828350_33829487_4": {"section_id": 5806, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_33828350_33829487_1": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}, "so_33828350_33829487_6": {"section_id": 5583, "quality": 0.9473684210526315, "length": 18}, "so_33828350_33829487_4": {"section_id": 5579, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_33828350_33829487_6": {"section_id": 7271, "quality": 0.9473684210526315, "length": 18}, "so_33828350_33829487_1": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}, "so_33828350_33829487_4": {"section_id": 7267, "quality": 0.8947368421052632, "length": 17}}}, "33828350": {"CommentCount": "6", "ViewCount": "104", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-20T13:49:46.817", "LastActivityDate": "2015-11-23T17:50:57.393", "Title": "Can I Reference Previous Members of an Initializer List?", "AcceptedAnswerId": "33829487", "LastEditDate": "2015-11-23T01:12:11.113", "Id": "33828350", "Score": "2", "Body": "<p>Say I want to refer to a member of an <code>initializer_list</code> that I already defined. Can I do it?</p>\n<p>This code compiles and gives the expected: \"13 55 \" in both Visual Studio and <a href=\"http://ideone.com/ntPcVl\" rel=\"nofollow\">gcc</a>, I'd just like to know that it's legal:</p>\n<pre><code>const int foo[2] = {13, foo[0] + 42};\n</code></pre>\n", "Tags": "<c++><arrays><language-lawyer><initializer-list><aggregate-initialization>", "OwnerUserId": "2642059", "AnswerCount": "1"}});