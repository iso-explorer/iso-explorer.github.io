post_cb({"6331561": {"ParentId": "6331394", "CommentCount": "1", "Body": "<p>A superior solution would be to compose of <code>Foo&lt;void*&gt;</code>. After all, you don't want the raw <code>void*</code> interface cluttering up your stuff, and you <em>don't</em> want a <code>Foo&lt;T*&gt;</code> to be convertible to a <code>Foo&lt;void*&gt;</code>.</p>\n<p>Alternatively, you could fully specialize <code>Foo&lt;void*&gt;</code> beforehand.</p>\n<p>Assuming, of course, that you're doing this for type folding, instead of because you actually <em>want</em> inheritance.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6331561", "Score": "0", "CreationDate": "2011-06-13T14:08:57.750", "LastActivityDate": "2011-06-13T14:08:57.750"}, "6331394": {"CommentCount": "1", "AcceptedAnswerId": "6332066", "PostTypeId": "1", "LastEditorUserId": "7116", "CreationDate": "2011-06-13T13:55:30.403", "LastActivityDate": "2011-06-13T15:40:07.677", "LastEditDate": "2011-06-13T15:40:07.677", "ViewCount": "885", "FavoriteCount": "1", "Title": "C++ Inheriting from Undefined Template Type", "Id": "6331394", "Score": "5", "Body": "<p>This code:</p>\n<pre><code>template &lt;class T&gt;\nclass Foo {};\n\ntypedef Foo&lt;void*&gt; Bar;\n\ntemplate &lt;class T&gt;\nclass Foo&lt;T*&gt; : public Bar {};\n\n// use Foo&lt;int*&gt; somewhere.\n</code></pre>\n<p>Compiles and works fine in MSVC 9.0, but doesn't compile in GCC 4.1.1 or GCC 4.3.4, with the error:</p>\n<pre><code>error: invalid use of undefined type 'class Bar'\n</code></pre>\n<p>Is this illegal C++ that MSVC accepts incorrectly, or a limitation of GCC?</p>\n<p>Either way, how can I work around this get the desired behaviour: pointer specialisations of <code>Foo</code> that inherit from unspecialised <code>Foo&lt;void*&gt;</code>?</p>\n", "Tags": "<c++><templates><inheritance><gcc>", "OwnerUserId": "235825", "AnswerCount": "3"}, "6331423": {"ParentId": "6331394", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The <code>typedef</code> is a red herring.</p>\n<p>The following code is equivalent:</p>\n<pre><code>template &lt;class T&gt;\nclass Foo {};\n\ntemplate &lt;class T&gt;\nclass Foo&lt;T*&gt; : public Foo&lt;void*&gt; {};\n</code></pre>\n<p>It should be clear that, although <code>Foo&lt;T*&gt;</code> is declared at this point, it is not defined. And thus you may not use it as a base.</p>\n<hr>\n<p><code>[class.name]</code> (2003 wording, 9.1/2):</p>\n<blockquote>\n<p id=\"so_6331394_6331423_0\">A class definition introduces the class name into the scope where it is defined</p>\n</blockquote>\n<p><code>[class.mem]</code> (2003 wording, 9.2/2):</p>\n<blockquote>\n<p id=\"so_6331394_6331423_1\">A class is considered a\n  completely-defined object type (3.9)\n  (or complete type) at the closing } of\n  the class-specifier. Within the class\n  member-specification, the class is\n  regarded as complete within function\n  bodies, default arguments and\n  constructor ctor-initializers\n  (including such things in nested\n  classes). <strong>Otherwise it is regarded as\n  incomplete within its own class\n  member-specification.</strong></p>\n</blockquote>\n<p><code>[class.derived]</code> (2003 wording, 10/1):</p>\n<blockquote>\n<p id=\"so_6331394_6331423_2\">The class-name in a base-specifier <strong>shall not be an incompletely defined class</strong> (clause 9);</p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-06-13T14:05:05.597", "Id": "6331423", "Score": "3", "CreationDate": "2011-06-13T13:57:30.200", "LastActivityDate": "2011-06-13T14:05:05.597"}, "bq_ids": {"n4140": {"so_6331394_6331423_0": {"section_id": 5857, "quality": 0.7777777777777778, "length": 7}, "so_6331394_6331423_1": {"section_id": 5862, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_6331394_6331423_0": {"section_id": 5627, "quality": 0.7777777777777778, "length": 7}, "so_6331394_6331423_1": {"section_id": 5632, "quality": 0.9411764705882353, "length": 32}}, "n4659": {"so_6331394_6331423_0": {"section_id": 7336, "quality": 0.7777777777777778, "length": 7}, "so_6331394_6331423_1": {"section_id": 7345, "quality": 0.9411764705882353, "length": 32}}}, "6332066": {"ParentId": "6331394", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You cannot do that, except by writing the specialization for all <code>T*</code>, except when <code>T</code> is <code>void</code>. Otherwise, you will derive the class from itself, which for obvious reasons can't work. </p>\n<p>Instantiating the primary class template for arguments that have an explicit or partial specialization is not possible. If you try to, by provoking an instantiation before the explicit or partial specialization is visible (note that your code did not provoke such an instantiation), your program is ill-formed, with no diagnostic being required (which effectively renders the behavior undefined).</p>\n<p>To achieve the above work-around, you can use SFINAE</p>\n<pre><code>template &lt;class T&gt;\nstruct isnt_void { typedef void type; };\n\ntemplate&lt;&gt; struct isnt_void&lt;void&gt; { };\n\ntemplate &lt;class T, class = void&gt;\nclass Foo {};\n\ntemplate &lt;class T&gt;\nclass Foo&lt;T*, typename isnt_void&lt;T&gt;::type&gt; : public Foo&lt;void*&gt; {};\n</code></pre>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-06-13T15:00:20.667", "Id": "6332066", "Score": "5", "CreationDate": "2011-06-13T14:51:25.490", "LastActivityDate": "2011-06-13T15:00:20.667"}});