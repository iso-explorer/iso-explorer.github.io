post_cb({"35162392": {"ParentId": "35162259", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In your particular example, it seems prudent to change signature of string version to </p>\n<pre><code>std::string GetNodeValue(const std::string&amp; nodePath, const std::string defaultValue)\n</code></pre>\n<p>This will remove any ambiguity.</p>\n", "OwnerUserId": "5245033", "LastEditorUserId": "5245033", "LastEditDate": "2016-02-02T19:44:47.777", "Id": "35162392", "Score": "-1", "CreationDate": "2016-02-02T19:38:59.923", "LastActivityDate": "2016-02-02T19:44:47.777"}, "35162401": {"ParentId": "35162259", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is, because 0 is the literal for an empty pointer (which in modern C++ is replaced by \"nullptr\").</p>\n<p>So 0 can be either an int or an empty pointer, especially a char*</p>\n<p>Edit to add some reference:\nYou can find this in the standard as </p>\n<blockquote>\n<p id=\"so_35162259_35162401_0\">4.10 Pointer conversions \n  A null pointer constant is an integer literal (2.13.2) with value zero or a prvalue of type std::nullptr_t</p>\n</blockquote>\n<p>(the last one is the reference to <code>nullptr</code>)</p>\n", "OwnerUserId": "3193464", "LastEditorUserId": "3193464", "LastEditDate": "2016-02-02T19:48:31.340", "Id": "35162401", "Score": "2", "CreationDate": "2016-02-02T19:39:29.563", "LastActivityDate": "2016-02-02T19:48:31.340"}, "35163197": {"ParentId": "35162259", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Both overloads are considered equally viable for</p>\n<pre><code>configurationReaderPtr-&gt;GetNodeValue(\"other_node\", 0);\n</code></pre>\n<p>because:</p>\n<ol>\n<li><p>requires an implicit conversion from <code>0</code>, which is of type <code>int</code> to <code>const char *</code>.</p></li>\n<li><p>requires an implicit conversion from <code>ConfigurationReader*</code> to <code>ConfigurationReader const*</code> (to call <code>const</code>-qualified member function)</p></li>\n</ol>\n<p>After making both overloads (equally) <code>const</code>-qualified, the code compiles (the function template is preferred). The 1st overload also does not modify any members in the first place.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/72df7eab48ebb4a4\" rel=\"nofollow\"><strong>Live on Coliru</strong></a></p>\n", "OwnerUserId": "3552770", "LastEditorUserId": "3552770", "LastEditDate": "2016-02-02T20:50:11.600", "Id": "35163197", "Score": "1", "CreationDate": "2016-02-02T20:28:53.160", "LastActivityDate": "2016-02-02T20:50:11.600"}, "35162259": {"CommentCount": "5", "ViewCount": "223", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-02-02T19:31:35.373", "LastActivityDate": "2016-02-02T20:50:11.600", "Title": "Error: \"2 overloads have similar conversions\"", "AcceptedAnswerId": "35163197", "LastEditDate": "2017-05-23T11:52:26.090", "Id": "35162259", "Score": "1", "Body": "<p><strong><em>EDIT:</em></strong> As I was writing the question I noticed that the method <code>std::string GetNodeValue(const std::string&amp; nodePath, const char * defaultValue)</code> wasn't const. As <em>LogicStuff</em> also mentioned in his comment, adding the <code>const</code> qualification resolved the ambiguity.</p>\n<p>I know this question was already been asked and answered properly <a href=\"https://stackoverflow.com/questions/3723112/2-overloads-have-similar-conversions\">here</a> and several other times. I understand the underlying problem but I can't quite figure out why it is happening in this particular case and it has awoken my curious self.</p>\n<p>I have the following class:</p>\n<pre><code>class ConfigurationReader\n{\npublic:\n    // ...   \n    std::string GetNodeValue(const std::string&amp; nodePath, const char * defaultValue)\n    {\n        const std::string temp(defaultValue);\n        return GetNodeValue(nodePath, temp); \n    }    \n\n    template &lt;typename T&gt; T GetNodeValue(const std::string &amp; nodePath, T defaultValue) const \n    {\n        boost::optional&lt;T&gt; nodeValue = configuration.getNodeValueNothrow&lt;T&gt;(nodePath);\n        if ( nodeValue ) \n        {\n            return *nodeValue;\n        }\n        LogConfigurationProblemsCri(logger, \"Node not found: \" &lt;&lt; nodePath &lt;&lt; \", Default value: \" &lt;&lt; defaultValue);\n        return defaultValue;\n    }\n    // ...    \n};\n</code></pre>\n<p>The template method has also several specializations for the types <code>int16_t</code>, <code>uint16_t</code>, and so on up to <code>uint64_t</code>.</p>\n<p>It works like a charm when used:</p>\n<pre><code>string someValue = configurationReaderPtr-&gt;GetNodeValue(\"some_noe\", \"\");\nuint32_t otherValue = configurationReaderPtr-&gt;GetNodeValue(\"other_node\", 11000);\nbool yetAnother = configurationReaderPtr-&gt;GetNodeValue(\"other_node\", true);\n</code></pre>\n<p>Except in one case:</p>\n<pre><code>uint32_t otherValue = configurationReaderPtr-&gt;GetNodeValue(\"other_node\", 0);\n</code></pre>\n<p>The error I keep getting is:\n\"2 overloads have similar conversions\ncould be '<em>std::string ConfigurationReader::GetNodeValue(const std::string &amp;,const char</em> *)' or '<em>uint32_t ConfigurationReader::GetNodeValue(const std::string &amp;,uint32_t) const</em>'\"</p>\n<p>I tried casting the \"default\" value: <code>uint32_t(0)</code>, <code>static_cast&lt;uint32_t&gt;(0)</code>, <code>0U</code> without any luck.</p>\n<p>I should point out that I already found a <strong>workaround</strong>:</p>\n<pre><code>uint32_t otherValue = 0;\notherValue = configurationReaderPtr-&gt;GetNodeValue(\"other_node\", otherValue);\n</code></pre>\n<p>But this doesn't answer my curiosity. I am currently using Microsoft Visual Studio 2012 Express and boost 1.54 libraries. </p>\n<p>Any thoughts?</p>\n", "Tags": "<c++><templates><c++11><method-overloading>", "OwnerUserId": "5583153", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_35162259_35162401_0": {"section_id": 39, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_35162259_35162401_0": {"section_id": 5947, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_35162259_35162401_0": {"section_id": 39, "quality": 0.6428571428571429, "length": 9}}}});