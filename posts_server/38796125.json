post_cb({"38796125": {"CommentCount": "6", "ViewCount": "58", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-08-05T18:58:49.220", "LastActivityDate": "2016-08-05T22:34:57.237", "Title": "Using inheritance or templates for special case behavior", "LastEditDate": "2016-08-05T22:29:47.990", "Id": "38796125", "Score": "0", "Body": "<p>I have two classes <code>A</code> and <code>B</code>, which are subclasses of an <code>Operator</code> class which has an <code>operate()</code> method.</p>\n<pre><code>class Operator {\n     // ...\n     virtual void operate() = 0;\n};\nclass A : public Operator {\n     void operate() { /* ... */ }\n};\nclass B : public Operator {\n     void operate() { /* ... */ }\n};\n</code></pre>\n<p>I want to create a class that performs two operations, but has a unique behavior when both operations are of type <code>B</code>. Something like</p>\n<pre><code> class DoubleOperator {\n     Operator* operator1;\n     Operator* operator2;\n     // ...\n\n public:\n     void operateTwice() {\n         if (/* operator1 and operator2 are of type B */) {\n             // Do a special combined operation.\n         } else { // Otherwise, do the operations separately.\n             operator1-&gt;operate();\n             operator2-&gt;operate();\n         }\n     }\n};\n</code></pre>\n<p>Is there a simple way to use inheritance or templates to produce this behavior?</p>\n", "Tags": "<c++><templates><inheritance>", "OwnerUserId": "6683800", "AnswerCount": "2"}, "38796437": {"ParentId": "38796125", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can <em>type-erase</em> the operators with an intermediate function and a bit of <em>SFINAE</em>.<br>\nIt follows a minimal, working example (C++14, easily convertible to C++11):</br></p>\n<pre><code>#include&lt;type_traits&gt;\n#include&lt;iostream&gt;\n\nclass Operator {\n     // ...\n     virtual void operate() = 0;\n};\nclass A : public Operator {\n     void operate() { /* ... */ }\n};\nclass B : public Operator {\n     void operate() { /* ... */ }\n};\n\nclass DoubleOperator {\n    template&lt;typename T, typename U&gt;\n    static\n    std::enable_if_t&lt;std::is_same&lt;T,U&gt;::value&gt;\n    proto() {\n        std::cout &lt;&lt; \"same\" &lt;&lt; std::endl;\n        // Do a special combined operation.\n    }\n\n    template&lt;typename T, typename U&gt;\n    static\n    std::enable_if_t&lt;not std::is_same&lt;T,U&gt;::value&gt;\n    proto() {\n        std::cout &lt;&lt; \"not same\" &lt;&lt; std::endl;\n        // Otherwise, do the operations separately.\n    }\n\n     Operator* operator1;\n     Operator* operator2;\n     void(*internalOperatorTwice)(void);\n     // ...\n\npublic:\n    template&lt;typename T, typename U&gt;\n    DoubleOperator(T *t, U *u): operator1{t}, operator2{u} {\n        internalOperatorTwice = &amp;proto&lt;T, U&gt;;\n    }\n\n     void operateTwice() {\n         internalOperatorTwice();\n     }\n};\n\nint main() {\n    A a1;\n    A a2;\n    B b;\n    DoubleOperator do1{&amp;a1, &amp;a2};\n    do1.operateTwice();\n    DoubleOperator do2{&amp;a1, &amp;b};\n    do2.operateTwice();\n}\n</code></pre>\n<p>You can extend/modify the <code>proto</code> accordingly with your needs.</p>\n<p><strong>EDIT</strong></p>\n<p>I've read once more the question and here is a refinement of the answer.<br>\nWhat I said above is still valid. Anyway, if you want to do <em>something different</em> only when you have two instances of <code>B</code>, you can use the following <code>proto</code> functions:</br></p>\n<pre><code>template&lt;typename T, typename U&gt;\nstatic\nstd::enable_if_t&lt;std::is_same&lt;T,B&gt;::value and std::is_same&lt;U,B&gt;::value&gt;\nproto() {\n    std::cout &lt;&lt; \"same\" &lt;&lt; std::endl;\n    // Do a special combined operation.\n}\n\ntemplate&lt;typename T, typename U&gt;\nstatic\nstd::enable_if_t&lt;not (std::is_same&lt;T,B&gt;::value and std::is_same&lt;U,B&gt;::value)&gt;\nproto() {\n    std::cout &lt;&lt; \"not same\" &lt;&lt; std::endl;\n    // Otherwise, do the operations separately.\n}\n</code></pre>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-08-05T22:34:57.237", "Id": "38796437", "Score": "1", "CreationDate": "2016-08-05T19:20:41.743", "LastActivityDate": "2016-08-05T22:34:57.237"}, "bq_ids": {"n4140": {"so_38796125_38796304_0": {"section_id": 6021, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_38796125_38796304_0": {"section_id": 5789, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_38796125_38796304_0": {"section_id": 7520, "quality": 0.9583333333333334, "length": 23}}}, "38796304": {"ParentId": "38796125", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Whar you're asking is:</p>\n<p><strong>How to check if <code>Derived</code> is <em>dynamic type</em> of variable with <em>static type</em> <code>Base&amp;</code>\n?</strong></p>\n<pre><code>struct Base\n{\n    virtual void f(){}\n};\nstruct Derived:Base{};\n\nDerived d;\nBase&amp; b = d;\n\nif (typeid(b)==typeid(Derived))\n{\n    //...\n}\n</code></pre>\n<p>Explanation:</p>\n<p>5.2.8/2 says:</p>\n<blockquote>\n<p id=\"so_38796125_38796304_0\">When typeid is applied to a glvalue expression whose type is a <strong>polymorphic class type</strong> (10.3), the result refers\n  to a std::type_info object representing the type of the most derived object (1.8) (that is, <strong>the dynamic\n  type</strong>) to which the glvalue refers. [...].</p>\n</blockquote>\n<p>So, we made <code>Base</code> polymorphic class type by adding <code>virtual</code> function to it and the we applied <code>typeid</code>, which then returned dynamic type.</p>\n", "OwnerUserId": "4932834", "LastEditorUserId": "4932834", "LastEditDate": "2016-08-05T19:18:07.713", "Id": "38796304", "Score": "0", "CreationDate": "2016-08-05T19:12:04.663", "LastActivityDate": "2016-08-05T19:18:07.713"}});