post_cb({"6322400": {"Id": "6322400", "PostTypeId": "2", "Body": "<p>The following compiles fine with GCC 4.5 and Visual Studio 10. If you say it doesn't compile in GCC 4.5.2 then it sounds like a compiler bug which you should report (but make sure that it really happens it's more likely that you made some sort of typo).</p>\n<pre><code>#include &lt;memory&gt;\nclass A{};\nclass B{};\nclass Bla {\npublic:\n    void foo(std::shared_ptr&lt;A&gt;) {}\n    void foo(std::shared_ptr&lt;B&gt;) {}\n};\n\nint main()\n{\n    Bla bla;\n    std::shared_ptr&lt;A&gt; a;\n    bla.foo(a);\n}\n</code></pre>\n", "LastEditorUserId": "3848", "LastActivityDate": "2011-06-12T14:27:10.250", "Score": "6", "CreationDate": "2011-06-12T14:11:36.780", "ParentId": "6322364", "CommentCount": "3", "OwnerUserId": "3848", "LastEditDate": "2011-06-12T14:27:10.250"}, "8692779": {"Id": "8692779", "PostTypeId": "2", "Body": "<p><a href=\"http://bytes.com/topic/c/answers/832994-shared_ptr-derived-classes-ambiguitity-overloaded-functions\" rel=\"nofollow\">http://bytes.com/topic/c/answers/832994-shared_ptr-derived-classes-ambiguitity-overloaded-functions</a></p>\n<pre><code>struct yes_type { char dummy; };\nstruct no_type { yes_type a; yes_type b; };\n\ntemplate &lt; typename From, typename To &gt;\nclass is_convertible\n{\n    private:\n        static From* dummy ( void );\n\n        static yes_type check ( To );\n\n        static no_type check ( ... );\n\n    public:\n\n        static bool const value = sizeof( check( *dummy() ) ) == sizeof( yes_type );\n\n}; // is_convertible\n</code></pre>\n<p>An in boost's shared_ptr.h, change the constructor signature to:</p>\n<pre><code>template&lt;class Y&gt;\nshared_ptr(shared_ptr&lt;Y&gt; const &amp; r,\n    typename enable_if&lt;is_convertible&lt;Y*, T*&gt;::value, void*&gt;::type = 0\n    ): px(r.px), pn(r.pn) // never throws\n{\n}\n</code></pre>\n", "LastActivityDate": "2012-01-01T10:59:35.923", "CommentCount": "0", "CreationDate": "2012-01-01T10:59:35.923", "ParentId": "6322364", "Score": "0", "OwnerUserId": "1105466"}, "bq_ids": {"n4140": {"so_6322364_6324146_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4394}}, "n3337": {"so_6322364_6324146_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4231}}, "n4659": {"so_6322364_6324146_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4289}}}, "6324146": {"Id": "6324146", "PostTypeId": "2", "Body": "<p><code>shared_ptr</code> has a template single-argument constructor, which is considered for the conversion here.  That's what allows an actual parameter <code>shared_ptr&lt;Derived&gt;</code> to be supplied where a <code>shared_ptr&lt;Base&gt;</code> is needed.</p>\n<p>Since both <code>shared_ptr&lt;const A&gt;</code> and <code>shared_ptr&lt;const B&gt;</code> have this implicit conversion, it's ambiguous.</p>\n<p>At least in C++0x, the standard requires that <code>shared_ptr</code> use some SFINAE tricks to make sure that the template constructor only matches types that actually can be converted.</p>\n<p>The signature is (see section <code>[util.smartptr.shared.const]</code>):</p>\n<pre><code>shared_ptr&lt;T&gt;::shared_ptr(const shared_ptr&lt;T&gt;&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr&lt;T&gt;::shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_6322364_6324146_0\">Requires: The second constructor shall not participate in the overload resolution unless <code>Y*</code> is implicitly convertible to <code>T*</code>.</p>\n</blockquote>\n<p>Possibly the library hasn't yet been updated to comply with that requirement.  You might try a newer version of libc++.</p>\n<p>Boost won't work, because it's missing that requirement.</p>\n<p>Here's a simpler test case: <a href=\"http://ideone.com/v4boA\" rel=\"nofollow\">http://ideone.com/v4boA</a>  (This test case will fail on a conforming compiler, if it compiles successfully, it means the original case will be incorrectly reported as ambiguous.)</p>\n<p>VC++ 2010 gets it right (for <code>std::shared_ptr</code>).</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2011-06-13T00:58:55.587", "Score": "7", "CreationDate": "2011-06-12T19:31:11.043", "ParentId": "6322364", "CommentCount": "9", "OwnerUserId": "103167", "LastEditDate": "2011-06-13T00:58:55.587"}, "6322364": {"ViewCount": "2949", "Body": "<p>Suppose I have two <strong>unrelated</strong> classes <code>A</code> and <code>B</code>. I also have a class <code>Bla</code> that uses <code>boost::shared_ptr</code> like this:</p>\n<pre><code>class Bla {\npublic:\n    void foo(boost::shared_ptr&lt;const A&gt;);\n    void foo(boost::shared_ptr&lt;const B&gt;);\n}\n</code></pre>\n<p>Notice the <strong>const</strong>. That's the important part which the original version of this question lacked. This compiles, and the following code works:</p>\n<pre><code>Bla bla;\nboost::shared_ptr&lt;A&gt; a;\nbla.foo(a);\n</code></pre>\n<p>However, if I switch from using <code>boost::shared_ptr</code> to using <code>std::shared_ptr</code> in the above examples, I get a compilation error that says:</p>\n<pre><code>\"error: call of overloaded 'foo(std::shared_ptr&lt;A&gt;)' is ambiguous\nnote: candidates are: void foo(std::shared_ptr&lt;const A&gt;)\n                      void foo(std::shared_ptr&lt;const B&gt;)\n</code></pre>\n<p>Can you help me figure out why the compiler can't figure out which function to use in the std::shared_ptr case, and can in the boost::shared_ptr case? I'm using the default GCC and Boost versions from the Ubuntu 11.04 package repository which are currently GCC 4.5.2 and Boost 1.42.0.</p>\n<p>Here is the full code that you can try compiling:</p>\n<pre><code>#include &lt;boost/shared_ptr.hpp&gt;\nusing boost::shared_ptr;\n// #include &lt;memory&gt;\n// using std::shared_ptr;\n\nclass A {};\nclass B {};\n\nclass Bla {\npublic:\n    void foo(shared_ptr&lt;const A&gt;) {}\n    void foo(shared_ptr&lt;const B&gt;) {}\n};\n\nint main() {\n    Bla bla;\n    shared_ptr&lt;A&gt; a;\n\n    bla.foo(a);\n\n    return 0;\n}\n</code></pre>\n<p>By the way, this issue motivated me to ask <a href=\"https://stackoverflow.com/questions/6322245/should-i-switch-from-using-boostshared-ptr-to-stdshared-ptr\">this question</a> about whether I should be using <code>std::shared_ptr</code> at all yet ;-)</p>\n", "AcceptedAnswerId": "6324146", "Title": "C++0x Error: overloading a function with std::shared_ptr to const argument is ambiguous", "CreationDate": "2011-06-12T14:04:03.437", "Id": "6322364", "CommentCount": "7", "LastEditDate": "2017-05-23T10:34:35.317", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-01T10:59:35.923", "Score": "6", "OwnerUserId": "627517", "Tags": "<c++><boost><stl><overloading><shared-ptr>", "AnswerCount": "4"}, "6324400": {"Id": "6324400", "PostTypeId": "2", "Body": "<p>You can use <code>std::static_pointer_cast</code> to add the <code>const</code> qualification:</p>\n<pre><code>bla.foo(std::static_pointer_cast&lt;const A&gt;(a));\n</code></pre>\n", "LastEditorUserId": "246886", "LastActivityDate": "2011-06-12T21:01:14.533", "Score": "2", "CreationDate": "2011-06-12T20:18:43.163", "ParentId": "6322364", "CommentCount": "2", "OwnerUserId": "246886", "LastEditDate": "2011-06-12T21:01:14.533"}});