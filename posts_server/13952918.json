post_cb({"bq_ids": {"n4140": {"so_13952918_13953061_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 3293}}, "n3337": {"so_13952918_13953061_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 3163}}}, "13953130": {"PostTypeId": "2", "Body": "<p>The terms <em>copy-initialization</em> and <em>direct-initialization</em> are part of the <em>grammar</em> of C++. they don't immediately tell you what sort of code generation happens. The meaning of any grammatical construction is described by the standard, and the context of initialization there are lots of different particular consequences depending on the types of the things that are being initialized.</p>\n<p>In particular, for primitive types, pointer types and reference types, both direct- and copy-initialization (the grammatical construct!) have the exact same effect. That is, fundamental and pointer types are initialized with the value of the initializer, and references are bound to the object referred to by the initializer:</p>\n<pre><code>int a1 = 5;\nint a2(5);      // same thing\n\nFoo * p1 = &amp;x;\nFoo * p2(&amp;x);   // same thing\n\nBar &amp; b1 = y;\nBar &amp; b2(y);    // same thing\n</code></pre>\n<p>(However, for <em>user-defined types</em> there <em>is</em> a distinction between direct- and copy-initialization, although it is a subtle one that is usually not important.)</p>\n", "LastActivityDate": "2012-12-19T13:08:29.353", "Id": "13953130", "CommentCount": "0", "CreationDate": "2012-12-19T13:08:29.353", "ParentId": "13952918", "Score": "4", "OwnerUserId": "596781"}, "13953061": {"Id": "13953061", "PostTypeId": "2", "Body": "<p>The main differences between direct-initialization and copy-initialization are covered in section 8.5, paragraph 17 of the standard.  In general, the difference is that for class types  in copy-initialization, explicit constructors are not considered (only converting constructors are considered) and a possibly elided copy is made; in direct-initialization explicit constructors are considered and the target is constructed directly.  From section 8.5 of the standard:</p>\n<blockquote>\n<p id=\"so_13952918_13953061_0\">14 - The form of initialization (using parentheses or <code>=</code>) is generally insignificant, but does matter when the initializer or the entity being initialized has a class type [...]</p>\n</blockquote>\n<p>For non-class types (including references), direct-initialization and copy-initialization have similar semantics; for references, a reference binding occurs in either case, as specified in <strong>8.5.3 References [dcl.init.ref]</strong>.  Direct-initialization and copy-initialization of a reference only have different semantics where a conversion function is involved (<strong>13.3.1.6 Initialization by conversion function for direct reference binding [over.match.ref]</strong>); again, direct-initialization is allowed to invoke explicit conversion functions where copy-initialization is not.</p>\n<p>So, in</p>\n<pre><code>int &amp;j = i;\n</code></pre>\n<p>8.5.3p5 applies and the reference <code>j</code> is bound directly to the lvalue <code>i</code>.  No temporaries are invoked.</p>\n<p>In terms of complexity, references are closer to fundamental (primitive) types than to class types.  Primitives are initialized without a temporary being constructed (8.5p17, last bullet) and in general references are too.  This is probably why the book only uses the <code>=</code> form for initialization of references; as with primitives, there is usually no difference and writing <code>int i = x;</code> is usually clearer than <code>int i(x);</code>.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-12-19T13:37:36.550", "CommentCount": "2", "CreationDate": "2012-12-19T13:03:55.897", "ParentId": "13952918", "Score": "6", "OwnerUserId": "567292", "LastEditDate": "2012-12-19T13:37:36.550"}, "13952983": {"Id": "13952983", "PostTypeId": "2", "Body": "<p>A reference in C++ is just a pointer wearing a funny hat. The statement:</p>\n<pre><code>TYPE&amp; x = y;\n</code></pre>\n<p>is always equivalent to:</p>\n<pre><code>TYPE* const x = &amp;y;\n</code></pre>\n<p>All references do is save you typing <code>*</code> characters and declare your belief that there will never be a null. So the initialization is trivial, since it is an initialization of a pointer, not an object, and there is no complexity of objects, temporary or otherwise, to deal with.</p>\n<p>This is the conceptual model; of course, there are optimizations. If you declare a function like:</p>\n<pre><code>void takeARef(FOO const&amp; ref) { ... }\n</code></pre>\n<p>and call it, then the compiler is just going to pass a pointer into the function, and create nothing.</p>\n", "LastEditorUserId": "131433", "LastActivityDate": "2012-12-19T16:24:19.260", "CommentCount": "6", "CreationDate": "2012-12-19T12:58:15.520", "ParentId": "13952918", "Score": "3", "OwnerUserId": "131433", "LastEditDate": "2012-12-19T16:24:19.260"}, "13952918": {"ViewCount": "347", "Body": "<p>I have been reading \"C++ primer\". For the initialization of object, C++ supports 2 forms of initialization: direct and copy.\nbut the book does not refer the initialization of reference. And in the book I have never seen the direct initialize(if exists) of a reference. All is the copy one like:</p>\n<pre><code>int i;\nint &amp;j = i;//but not int &amp;j(i);which also works in my experiment\n</code></pre>\n<p>I want to know that is it the same that are going  on underneath for the initialization of a reference.\nfor the following codes:</p>\n<pre><code>string null_book = \"9-999-99999-9\";\n</code></pre>\n<p>the initialization progress is first create a temporary string object tmp(for instance) that will direct initialized with a c style string parameter, and then initialize the variable null_book with the copy Constructor. That make sense to me.\nfor this one:</p>\n<pre><code>int &amp;j = i;\n</code></pre>\n<p>will ref j be initialized the same way? That will be a temp reference it &amp;t(for example) initialized by i and then initialize j with t? that doesnt make sense??? Why the book never use the direct initialization for reference?\nThanks for your attention!</p>\n", "AcceptedAnswerId": "13953061", "Title": "direct initialization and copy initialization of reference", "CreationDate": "2012-12-19T12:54:51.650", "Id": "13952918", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-12-19T16:24:19.260", "Score": "7", "OwnerUserId": "1547399", "Tags": "<c++>", "AnswerCount": "3"}});