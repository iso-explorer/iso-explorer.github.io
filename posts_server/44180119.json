post_cb({"bq_ids": {"n4140": {"so_44180119_44180119_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3399}, "so_44180119_44180119_3": {"length": 11, "quality": 1.0, "section_id": 3401}, "so_44180119_44180119_6": {"length": 4, "quality": 0.8, "section_id": 3402}, "so_44180119_44180119_4": {"length": 5, "quality": 1.0, "section_id": 3402}, "so_44180119_44180119_7": {"length": 4, "quality": 0.8, "section_id": 3402}, "so_44180119_44180119_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 3400}}, "n3337": {"so_44180119_44180119_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3268}, "so_44180119_44180119_4": {"length": 5, "quality": 1.0, "section_id": 3271}, "so_44180119_44180119_6": {"length": 4, "quality": 0.8, "section_id": 3271}, "so_44180119_44180119_3": {"length": 11, "quality": 1.0, "section_id": 3270}, "so_44180119_44180119_7": {"length": 4, "quality": 0.8, "section_id": 3271}, "so_44180119_44180119_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 3269}}, "n4659": {"so_44180119_44180119_4": {"length": 4, "quality": 0.8, "section_id": 4087}, "so_44180119_44180119_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 4156}, "so_44180119_44180119_3": {"length": 11, "quality": 1.0, "section_id": 4158}, "so_44180119_44180119_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 4157}}}, "44180334": {"Id": "44180334", "PostTypeId": "2", "Body": "<p>You  problem is you are trying to cast to a value instead of a reference.  The standard guarantees that</p>\n<pre><code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)\n</code></pre>\n<p>Is well formed.  It does not say</p>\n<pre><code>reinterpret_cast&lt;cv T[2]&gt;(z)\n</code></pre>\n<p>Is valid.  To make you code compile you need to change the cast to cast to a reference which gives you</p>\n<pre><code>cfunc(reinterpret_cast&lt;float(&amp;)[2]&gt;(z));\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/1787ef126acd4c79\" rel=\"nofollow noreferrer\">Live Example</a></kbd></p>\n", "LastActivityDate": "2017-05-25T12:14:23.050", "CommentCount": "7", "CreationDate": "2017-05-25T12:14:23.050", "ParentId": "44180119", "Score": "4", "OwnerUserId": "4342498"}, "44180119": {"ViewCount": "119", "Body": "<p>I have some C DSP libraries which use <code>complex [T]</code> types for complex numbers.  I want to call these from a C++ application which uses <code>std::complex&lt;T&gt;</code>.</p>\n<p>After reading <a href=\"https://stackoverflow.com/a/10540346/1156377\">this SO answer</a> and <a href=\"https://stackoverflow.com/a/25348164/1156377\">this one</a>, and \u00a726.4 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a>, I tried an experiment:</p>\n<pre><code>extern \"C\" {\n#include &lt;complex.h&gt;\n// Using _Complex or __complex__ since C's \"complex\" type doesn't exist in C++\nvoid cfunc(_Complex float x);\n}\n#include &lt;complex&gt;\n\nvoid test()\n{\n        std::complex&lt;float&gt; z;\n        cfunc(reinterpret_cast&lt;float[2]&gt;(z));\n}\n</code></pre>\n<p>And tried to compile it with <code>CXXFLAGS=\"-std=c++11\"</code>.  I got the following from GCC 6.3.1:</p>\n<pre><code>error: invalid cast from type \u2018std::complex&lt;float&gt;\u2019 to type \u2018float [2]\u2019\n  cfunc(reinterpret_cast&lt;float[2]&gt;(z));\n</code></pre>\n<p>Is this a compiler bug or am I misunderstanding something?  How would one use C functions which take <code>complex [T]</code> arguments, given C++ code using <code>std::complex&lt;T&gt;</code> types?  Currently, I use a dirty hack to work around this issue but I'd prefer a clean way.</p>\n<p>I tried compiling with <code>-std=c++14</code> just in case this feature had missed C++11 somehow (despite posts quoting it from the C++11 standard) but I get the same result.</p>\n<hr>\n<blockquote>\n<p id=\"so_44180119_44180119_0\">26.4 Complex numbers [complex.numbers]</p>\n<ol>\n<li><p id=\"so_44180119_44180119_1\">The header <code>&lt;complex&gt;</code> defines a class template, and numerous functions for representing and manipulating\n  complex numbers.</p></li>\n<li><p id=\"so_44180119_44180119_2\">The effect of instantiating the template complex for any type other than float, double, or long double\n  is unspecified. The specializations <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, and <code>complex&lt;long double&gt;</code> are\n  literal types (3.9).</p></li>\n<li><p id=\"so_44180119_44180119_3\">If the result of a function is not mathematically defined or not in the range of representable values for its\n  type, the behavior is undefined.</p></li>\n<li><p id=\"so_44180119_44180119_4\">If z is an lvalue expression of type cv <code>std::complex&lt;T&gt;</code> then:</p>\n<p id=\"so_44180119_44180119_5\">4.1. the expression <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</code> shall be well-formed,</p>\n<p id=\"so_44180119_44180119_6\">4.2. <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</code> shall designate the real part of z, and</p>\n<p id=\"so_44180119_44180119_7\">4.3. <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</code> shall designate the imaginary part of z.</p></li>\n</ol>\n</blockquote>\n</hr>", "AcceptedAnswerId": "44180334", "Title": "C/C++ interop between _Complex and std::complex", "CreationDate": "2017-05-25T12:01:12.467", "Id": "44180119", "CommentCount": "3", "LastEditDate": "2017-05-25T12:15:13.417", "PostTypeId": "1", "LastEditorUserId": "4342498", "LastActivityDate": "2017-05-25T12:15:13.417", "Score": "1", "OwnerUserId": "1156377", "Tags": "<c++><c><c++11>", "AnswerCount": "1"}});