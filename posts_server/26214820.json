post_cb({"26218260": {"PostTypeId": "2", "Body": "<p>This is certainly not clear to read. Someone could arrive and modify your code by adding new variables in only one constructor without understanding the usefulness of the second one.\nYou should think of using <a href=\"http://www.cplusplus.com/reference/memory/unique_ptr/?kw=unique_ptr\" rel=\"nofollow\" title=\"unique_ptr&lt;T&gt;\">std::unique_ptr</a> </p>\n<pre><code>class TwoResources \n{\n    TwoResources(int x, int y) : m_a( new A( x ) ), m_b( new B( y ) )\n    {\n    }\n    std::unique_ptr&lt;A&gt; m_a;\n    std::unique_ptr&lt;B&gt; m_b;\n};\n</code></pre>\n<p>Also, take a look to <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\" rel=\"nofollow\">std::make_unique</a> which is safer than manually using new and delete operators :</p>\n<pre><code>class TwoResources \n{\n    TwoResources(int x, int y):m_a( std::make_unique&lt;A&gt;( x ) ), m_b( std::make_unique&lt;B&gt;(B( y ) )\n    {\n    }\n    std::unique_ptr&lt;A&gt; m_a;\n    std::unique_ptr&lt;B&gt; m_b;\n};\n</code></pre>\n", "LastActivityDate": "2014-10-06T14:19:07.350", "Id": "26218260", "CommentCount": "0", "CreationDate": "2014-10-06T14:19:07.350", "ParentId": "26214820", "Score": "1", "OwnerUserId": "1758142"}, "26215216": {"PostTypeId": "2", "Body": "<p>Just because something is safe doesn't mean doing it is a good idea.</p>\n<p>For instance, using that delegating constructor call is crucial to exception safety, but that's far from clear to a casual reader of the code who is not familiar with the intricacies of the language. A month later, someone else looking at your code might think \"why are you setting it to null if you are setting it in the constructor body again?\" and remove it. Ouch.</p>\n<p>Moreover, when you are managing lifetime manually, you'll need to write your own copy/move constructors/assignment operators. Miss one and havoc results. If you use a <code>unique_ptr</code> to manage the lifetime, then the compiler-generated move constructor/assignment operator and destructor will do the right thing, and it will complain if you attempt to copy without implementing a copy constructor yourself.</p>\n", "LastActivityDate": "2014-10-06T11:25:30.067", "Id": "26215216", "CommentCount": "0", "CreationDate": "2014-10-06T11:25:30.067", "ParentId": "26214820", "Score": "6", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_26214820_26214820_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 3344}}, "n3337": {"so_26214820_26214820_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 3214}}}, "26214820": {"ViewCount": "139", "Body": "<p>In a talk the following code has been shown to be unsafe because if the constructor throws, the destructor will not be called and leak resources:</p>\n<pre><code>class TwoResources {\n    TwoResources(int x, int y)\n        : m_a(nullptr), m_b(nullptr) {\n        m_a = new A(x); m_b = new B(y);\n    }\n    ~TwoResources() {\n        delete m_b; delete m_a;\n    }\n    A * m_a; B * m_b;\n};\n</code></pre>\n<p>A suggestion solution is use a delegating constructor, like so:</p>\n<pre><code>class TwoResources {\n    TwoResources() : m_a(nullptr), m_b(nullptr) { }\n    TwoResources(int x, int y) : TwoResources() {\n        m_a = new A(x); m_b = new B(y);\n    }\n    ~TwoResources() {\n        delete m_b; delete m_a;\n    }\n    A * m_a; B * m_b;\n};\n</code></pre>\n<p>This is safe because of:</p>\n<blockquote>\n<p id=\"so_26214820_26214820_0\">C++11 15.2 [except.ctor]/2: \"if the non-delegating constructor for an\n  object has completed execution and a delegating constructor for that\n  object exists with an exception, the object's destructor will be\n  invoked.\"</p>\n</blockquote>\n<p>However in the same slide, it says:</p>\n<blockquote>\n<p id=\"so_26214820_26214820_1\">Just because you can take advantage of this rule doesn't mean you should!</p>\n</blockquote>\n<p>If this code is guaranteed to be safe, then what are some potential issues with it?</p>\n", "AcceptedAnswerId": "26215216", "Title": "Using a delegating constructor to avoid leaks", "CreationDate": "2014-10-06T11:00:49.160", "Id": "26214820", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-10-06T14:19:07.350", "Score": "4", "OwnerUserId": "4112979", "Tags": "<c++><c++11><memory-leaks>", "AnswerCount": "2"}});