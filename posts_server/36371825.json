post_cb({"bq_ids": {"n4140": {"so_36371825_36373803_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6815}}, "n3337": {"so_36371825_36373803_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6570}}, "n4659": {"so_36371825_36373803_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 8307}}}, "36371825": {"ViewCount": "160", "Body": "<p>For example:</p>\n<pre><code>int *a, *b;\na = new int[10];\nb = new int(12);\nb = a; // I know there's memory leak, but let's ignore it first\ndelete [] b; // line L\n</code></pre>\n<p>What will happen? Will the entire array be deleted successfully?</p>\n<p>What if line L is replaced by this:\n    b = a + 1;\n    delete [] b;</p>\n<p>Or by this:\n    a++;\n    delete [] a;</p>\n<p>And, lastly, if the length of an dynamic array is associated with the starting address, or in other words, associated with the array itself, do we have any way to get the length of it without using another variable to store the length?</p>\n<p>Thanks a lot!</p>\n", "Title": "In C++, is the length information of a dynamic array associated with the pointer or the address of the first element?", "CreationDate": "2016-04-02T10:00:51.580", "LastActivityDate": "2016-04-02T13:37:55.433", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "36371825", "Score": "4", "OwnerUserId": "6093747", "Tags": "<c++><arrays><dynamic-arrays><dynamic-variables>", "AnswerCount": "3"}, "36371849": {"Id": "36371849", "PostTypeId": "2", "Body": "<p>The memory block size and array length information is associated with the address of the object, which is the address of the first item of the array.</p>\n<p>I.e. your <code>delete[]</code> is safe in the given code</p>\n<pre><code>int *a, *b;\na = new int[10];\nb = new int(12);\nb = a; // I know there's memory leak, but let's ignore it first\ndelete [] b; // line L\n</code></pre>\n<p>However, there is no portable way to <sup>1</sup><em>access</em> the associated information. It's an implementation detail. Use a <code>std::vector</code> if you need such info.</p>\n<hr>\n<p>To understand why the info can't be accessed, note first that memory block size, needed for deallocation, can be larger than the array length times size of array item. So we're dealing here with two separate values. And for an array of POD item type, where item destructor calls are not necessary, there needs not be an explicitly stored array length value.</p>\n<p>Even for an array where destructor calls are necessary, there needs not be an explicitly stored array length value associated with array. For example, in code of the pattern <code>p = new int[n]; whatever(); delete[] p;</code>, the compiler can in principle choose to put the array length in some unrelated place where it can easily be accessed by the code generated for the <code>delete</code> expression. E.g. it could be put in a processor register.</p>\n<p>Depending on how smart the compiler is, there needs not necessarily be an explicitly stored memory block size either. For example, the compiler can note that in some function <code>f</code>, three arrays <code>a</code>, <code>b</code> and <code>c</code> are allocated, with their sizes known at the first allocation, and all three deallocated at the end. So the compiler can replace the three allocations with a single one, and ditto replace the three deallocations with a single one (this optimization is explicitly permitted by <sup>2</sup>C++14 \u00a75.3.4/10).</p>\n<hr>\n<p><sup>\n<sup>1</sup> Except,  in C++14 and later, in a deallocation function, which is a bit late.<br>\n<sup>2</sup> C++14 \u00a75.3.4/10: \u201cAn implementation is allowed to omit a call to a replaceable global allocation function (18.6.1.1, 18.6.1.2).\nWhen it does so, the storage is instead provided by the implementation or provided by extending the\nallocation of another <em>new-expression</em>. The implementation may extend the allocation of a <em>new-expression</em> <code>e1</code>\nto provide storage for a <em>new-expression</em> <code>e2</code> if \u2026\u201d\n</br></sup></p>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-04-02T10:41:37.060", "Score": "5", "CreationDate": "2016-04-02T10:03:26.820", "ParentId": "36371825", "CommentCount": "3", "LastEditDate": "2016-04-02T10:41:37.060", "OwnerUserId": "464581"}, "36373803": {"Id": "36373803", "PostTypeId": "2", "Body": "<pre><code>int *a, *b;\na = new int[10];\nb = new int(12);\nb = a; // I know there's memory leak, but let's ignore it first\ndelete [] b; // line L\n</code></pre>\n<blockquote>\n<p id=\"so_36371825_36373803_0\">Will the entire array be deleted successfully?</p>\n</blockquote>\n<p>Yes, memory will successfully be freed since the pointer <code>a</code> was set to point to an array of 10 integers</p>\n<pre><code>a = new int[10];\n</code></pre>\n<p>then the same memory location address is stored into <code>b</code></p>\n<pre><code>b = a;\n</code></pre>\n<p>therefore the <code>delete[]</code> line correctly deallocates the array chunk</p>\n<pre><code>delete [] b;\n</code></pre>\n<p>As you stated the code also leaks the integer variable 12 that was originally allocated and pointed to by <code>b</code>.</p>\n<p>As a sidenote calling <code>delete[]</code> to free memory not associated with an array (specifically with a static type mismatch - see <em>[expr.delete]/p3</em>) would have triggered undefined behavior.</p>\n<hr>\n<p>Now for some internals on where is the size information stored when allocating memory.</p>\n<p>Compilers have some degree of freedom (cfr. \u00a75.3.4/10) when it comes to memory allocation requests (e.g. they can \"group\" memory allocation requests).</p>\n<p>When you call <code>new</code> without a supplied allocator, whether it will call <code>malloc</code> or not, it is implementation defined</p>\n<p><em>[new.delete.single]</em></p>\n<blockquote>\n<p id=\"so_36371825_36373803_1\">Executes a loop: Within the loop, the function first attempts to allocate the requested storage.\n  Whether the attempt involves a call to the Standard C library function malloc is unspecified.</p>\n</blockquote>\n<p>Assuming it calls <code>malloc()</code> (on recent Windows systems it calls the <a href=\"https://blogs.msdn.microsoft.com/vcblog/2015/03/03/introducing-the-universal-crt/\" rel=\"nofollow\">UCRT</a>), attempting to allocate space means doing book-keeping with <a href=\"https://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory\" rel=\"nofollow\">paged virtual memory</a>, and that's what malloc usually does.</p>\n<p>Your size information gets passed along together with other data on how to allocate the memory you requested.</p>\n<p>C libraries like <a href=\"https://en.wikipedia.org/wiki/GNU_C_Library\" rel=\"nofollow\">glibc</a> take care of alignment, memory guards and allocation of a new page (if necessary) so this might end up in the kernel via a system call.</p>\n<p>There is no \"standard\" way to get that info back from the address only since it's an implementation detail. As many have suggested, if you were to need such an info you could</p>\n<ul>\n<li>store the size somewhere</li>\n<li>use <code>sizeof()</code> with an array type</li>\n<li>even better for C++: use a <code>std::vector&lt;&gt;</code></li>\n</ul>\n<p>That info is furthermore associated with a memory allocation, both of your secondary cases (i.e. substituting the <code>L</code> line with </p>\n<pre><code>b = a + 1; delete [] b;\n</code></pre>\n<p>or</p>\n<pre><code>a++; delete [] a;\n</code></pre>\n<p>will end in tears since those addresses aren't associated with a valid allocation.</p>\n</hr>", "LastEditorUserId": "1938163", "LastActivityDate": "2016-04-02T13:37:55.433", "Score": "2", "CreationDate": "2016-04-02T13:21:15.490", "ParentId": "36371825", "CommentCount": "2", "LastEditDate": "2016-04-02T13:37:55.433", "OwnerUserId": "1938163"}, "36371927": {"Id": "36371927", "PostTypeId": "2", "Body": "<p>The c++ standard just says that using <code>delete[]</code> on a pointer allocated with <code>new</code>, and using <code>delete</code> on a pointer allocated with <code>new[]</code> is undefined behavior.</p>\n<p>So doing this may work, or may not, depending on implementations. It may set your house on fire.</p>\n<p>For instance, just suppose that these functions are based on an underlying buffer using malloc() and free().</p>\n<p><code>new</code> and <code>delete</code> will, in most implementations, use a buffer which has exactly the size and address of the item (here an <code>int</code>)</p>\n<p><code>new[]</code> and <code>delete[]</code> are more complex. They must store in the buffer not only <code>size</code> items, but also the value of <code>size</code>. An implementation could store <code>size</code> before the actual items. This would mean that the pointer of the underlying buffer is not the same as the pointer to the first item, which is the value returned by <code>new[]</code></p>\n<p>Mixing array and non array versions would then call free() on invalid pointers, ie pointers that were never returned by malloc. This will crash or trigger an exception</p>\n<p>Of course, all this is implementation defined.</p>\n", "LastEditorUserId": "2042388", "LastActivityDate": "2016-04-02T11:05:24.320", "Score": "1", "CreationDate": "2016-04-02T10:12:48.427", "ParentId": "36371825", "CommentCount": "5", "LastEditDate": "2016-04-02T11:05:24.320", "OwnerUserId": "2042388"}});