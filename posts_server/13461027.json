post_cb({"13461382": {"ParentId": "13461027", "CommentCount": "6", "Body": "<p>Because they <em>don't</em> do the exact same thing. As stated in 13.3.1.7 [over.match.list]:</p>\n<blockquote>\n<p id=\"so_13461027_13461382_0\">In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>In short, you can only use implicit conversion in copy-list-initialization contexts.</p>\n<p>This was explicitly added to make uniform initialization not, um, uniform. Yeah, I know how stupid that sounds, but bear with me.</p>\n<p>In 2008, <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2640.pdf\" rel=\"noreferrer\">N2640 was published (PDF)</a>, taking a look at the current state of uniform initialization. It looked specifically at the difference between direct initialization (<code>T{...}</code>) and copy-initialization (<code>T = {...}</code>).</p>\n<p>To summarize, the concern was that <code>explicit</code> constructors would effectively become pointless. If I have some type <code>T</code> that I want to be able to be constructed from an integer, but I don't want implicit conversion, I label the constructor explicit.</p>\n<p>Then somebody does this:</p>\n<pre><code>T func()\n{\n  return {1};\n}\n</code></pre>\n<p>Without the current wording, this will call my <code>explicit</code> constructor. So what good is it to make the constructor <code>explicit</code> if it doesn't change much?</p>\n<p>With the current wording, you need to at least use the name directly:</p>\n<pre><code>T func()\n{\n  return T{1};\n}\n</code></pre>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "13461382", "Score": "25", "CreationDate": "2012-11-19T20:10:24.397", "LastActivityDate": "2012-11-19T20:10:24.397"}, "bq_ids": {"n4140": {"so_13461027_13461382_0": {"section_id": 599, "quality": 1.0, "length": 6}, "so_13461027_13461027_0": {"section_id": 3323, "quality": 1.0, "length": 16}}, "n3337": {"so_13461027_13461382_0": {"section_id": 589, "quality": 1.0, "length": 6}, "so_13461027_13461027_0": {"section_id": 3193, "quality": 1.0, "length": 16}}, "n4659": {"so_13461027_13461382_0": {"section_id": 622, "quality": 1.0, "length": 6}, "so_13461027_13461027_0": {"section_id": 4089, "quality": 0.875, "length": 14}}}, "13461027": {"CommentCount": "2", "CreationDate": "2012-11-19T19:47:51.650", "PostTypeId": "1", "AcceptedAnswerId": "13461382", "LastEditorUserId": "1938163", "LastActivityDate": "2015-09-08T08:39:23.997", "LastEditDate": "2015-09-08T08:39:23.997", "ViewCount": "1769", "FavoriteCount": "13", "Title": "Why does the standard differentiate between direct-list-initialization and copy-list-initialization?", "Id": "13461027", "Score": "27", "Body": "<p>We know that <code>T v(x);</code> is called <em>direct-initialization</em>, while <code>T v = x;</code> is called <em>copy-initialization</em>, meaning that it will construct a temporary <code>T</code> from <code>x</code> that will get copied / moved into <code>v</code> (which is most likely elided).</p>\n<p>For list-initialization, the standard differentiates between two forms, depending on the context. <code>T v{x};</code> is called <em>direct-list-initialization</em> while <code>T v = {x};</code> is called <em>copy-list-initialization</em>:</p>\n<p><code>\u00a78.5.4 [dcl.init.list] p1</code></p>\n<blockquote>\n<p id=\"so_13461027_13461027_0\">[...] List-initialization can occur in direct-initialization or copy-initialization\n  contexts; list-initialization in a direct-initialization context is called <em>direct-list-initialization</em> and list-initialization in a copy-initialization context is called <em>copy-list-initialization</em>. [...]</p>\n</blockquote>\n<p>However, there are only two more references each in the whole standard. For direct-list-initialization, it's mentioned when creating temporaries like <code>T{x}</code> (<code>\u00a75.2.3/3</code>). For copy-list-initialization, it's for the expression in return statements like <code>return {x};</code> (<code>\u00a76.6.3/2</code>).</p>\n<p>Now, what about the following snippet?</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nstruct X{\n  X(X const&amp;) = delete; // no copy\n  X(X&amp;&amp;) = delete; // no move\n  X(std::initializer_list&lt;int&gt;){} // only list-init from 'int's\n};\n\nint main(){\n  X x = {42};\n}\n</code></pre>\n<p>Normally, from the <code>X x = expr;</code> pattern, we expect the code to fail to compile, because the move constructor of <code>X</code> is defined as <code>delete</code>d. However, the latest versions of Clang and GCC compile the above code just fine, and after digging a bit (and finding the above quote), that seems to be correct behaviour. The standard only ever defines the behaviour for the whole of list-initialization, and doesn't differentiate between the two forms at all except for the above mentioned points. Well, atleast as far as I can see, anyways.</p>\n<p>So, to summarize my question again:</p>\n<p><strong>What is the use of splitting list-initialization into its two forms if they (apparently) do the exact same thing?</strong></p>\n", "Tags": "<c++><c++11><language-lawyer><list-initialization>", "OwnerUserId": "500104", "AnswerCount": "1"}});