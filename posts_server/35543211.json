post_cb({"35543548": {"ParentId": "35543211", "CommentCount": "8", "Body": "<p>If you take a look in [over.over], there are a few specific contexts in which you can use the name/address of an overloaded function:</p>\n<blockquote>\n<p id=\"so_35543211_35543548_0\">The target can be<br>\n  \u2014(1.1) an object or reference being initialized (8.5, 8.5.3, 8.5.4),<br>\n  \u2014(1.2) the left side of an assignment (5.18),<br>\n  \u2014(1.3) a parameter of a function (5.2.2),<br>\n  \u2014(1.4) a parameter of a user-de\ufb01ned operator (13.5),<br>\n  \u2014(1.5) the return value of a function, operator function, or conversion (6.6.3),<br>\n  \u2014(1.6) an explicit type conversion (5.2.3, 5.2.9, 5.4), or<br>\n  \u2014(1.7) a non-type template-parameter (14.3.2).</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>In laymans terms, you can use <code>example</code> in contexts where there is exactly one overload that \"fits.\" That you can't do <code>decltype(example)</code> makes sense - there isn't one, unique type of example. But what you're probably looking for is that penultimate option: you can always cast overloaded functions to specific types:</p>\n<pre><code>auto example_i = static_cast&lt;int(*)(int, int, int)&gt;(example);\nauto example_f = static_cast&lt;float(*)(float, float, float)&gt;(example);\n</code></pre>\n<p>Or variable assignment:</p>\n<pre><code>template &lt;class T&gt;\nusing F3 = T(*)(T, T, T);\n\nF3&lt;int&gt; example_i = example;\nF3&lt;float&gt; example_f = example;\n</code></pre>\n<p>Or non-type template parameter:</p>\n<pre><code>template &lt;class T, F3&lt;T&gt; Func&gt;\nstruct Foo { ... };\n\nFoo&lt;int, example&gt; f;\n</code></pre>\n<p>etc.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "35543548", "Score": "4", "CreationDate": "2016-02-21T23:36:03.593", "LastActivityDate": "2016-02-21T23:36:03.593"}, "bq_ids": {"n4140": {"so_35543211_35543211_0": {"section_id": 5440, "quality": 0.7391304347826086, "length": 17}, "so_35543211_35543548_0": {"section_id": 641, "quality": 0.6857142857142857, "length": 24}}, "n3337": {"so_35543211_35543211_0": {"section_id": 5235, "quality": 0.7391304347826086, "length": 17}, "so_35543211_35543548_0": {"section_id": 631, "quality": 0.6857142857142857, "length": 24}}, "n4659": {"so_35543211_35543211_0": {"section_id": 6867, "quality": 0.7391304347826086, "length": 17}, "so_35543211_35543548_0": {"section_id": 669, "quality": 0.6857142857142857, "length": 24}}}, "35543211": {"CommentCount": "2", "ViewCount": "225", "PostTypeId": "1", "LastEditorUserId": "5386374", "CreationDate": "2016-02-21T22:57:50.540", "LastActivityDate": "2016-02-22T17:33:29.970", "Title": "When attempting to generate a function pointer to an overloaded function with decltype, why is there no way to specify the appropriate overload?", "LastEditDate": "2016-02-22T17:33:29.970", "Id": "35543211", "Score": "0", "Body": "<p>I was experimenting with functors, and unintentionally discovered something about <code>decltype</code> that I found interesting: As far as I can tell, there's no way to use it to generate a function pointer to an overloaded function, or supply it with the information needed to resolve said overload when attempting to do so.</p>\n<pre><code>// Simple test code.\n// Please ignore the possibility of attempting to dereference a nullptr function pointer,\n//  proper checking was omitted for brevity.\ntemplate&lt;typename... Ts&gt; struct Functor;\n\ntemplate&lt;typename F, typename R, typename... Ts&gt;\nstruct Functor&lt;F, R(*)(Ts...)&gt; {\n    Functor() : func(nullptr) { }\n    Functor(F f) : func(f) { }\n\n    R operator()(F f, Ts... ts) { return 2 * f(ts...); }\n    R operator()(Ts... ts) { return 2 * func(ts...); }\n\n    private:\n        F func;\n};\n\ntemplate&lt;typename F&gt;\ndecltype(auto) functorReturner(F f = nullptr) {\n    return ((f) ? Functor&lt;F, F&gt;{f} : Functor&lt;F, F&gt;{});\n}\n\nint example(int a, int b, int c) {\n    return (8 * a) * ((b ^ c) - (c ^ b));\n}\n\nfloat example(float a, float b, float c) {\n    return (4.2 / a) * ((b + c) * (c - b));\n}\n\n// Wrappers to avoid overload when using decltype.\nauto example_i(int a, int b, int c) { return example(a, b, c); }\nauto example_f(float a, float b, float c) { return example(a, b, c); }\n\nint main() {\n  // Valid:\n    // Automatic template deduction, no overloads.\n    std::cout &lt;&lt; functorReturner(example_f)(1., 2.8, 0.6) &lt;&lt; std::endl; // Outputs -62.832.\n    // Explicit template specification, no overloads.\n    std::cout &lt;&lt; functorReturner&lt;decltype(&amp;example_f)&gt;()(example_f, 1., 2.8, 0.6)\n              &lt;&lt; std::endl;\n    // Explicit template specification, determines correct overload.\n    std::cout &lt;&lt; functorReturner&lt;decltype(&amp;example_f)&gt;(example)(1., 2.8, 0.6)\n              &lt;&lt; std::endl;\n    // Explicit template specification, determines correct overload.\n    std::cout &lt;&lt; functorReturner&lt;decltype(&amp;example_f)&gt;()(example, 1., 2.8, 0.6)\n              &lt;&lt; std::endl;\n  // Invalid:\n    // Attempting to pass proper version of overloaded function to decltype, without using\n    // a non-overloaded function with an identical signature.\n    // Explicit template specification, could theoretically determine correct overload.\n    std::cout &lt;&lt; functorReturner&lt;decltype(&amp;example(float, float, float))&gt;(example)(1., 2.8, 0.6)\n              &lt;&lt; std::endl;\n\n  // Valid:\n    // Determine type from non-overloaded function.\n    decltype(example_f(1., 2.8, 0.6)) ex;\n\n    // Determine type from overloaded function, with arguments explicitly specified.\n    decltype(example(1.f, 2.8f, 0.6f)) ex2;\n\n    // Determine type from overloaded function, with Rvalues to aid in resolution.\n    decltype(example(float{}, float{}, float{})) ex3;\n\n    std::cout &lt;&lt; typeid(ex).name() &lt;&lt; \" \"\n              &lt;&lt; typeid(ex2).name() &lt;&lt; \" \"\n              &lt;&lt; typeid(ex3).name()\n              &lt;&lt; std::endl;\n    // Output is:\n    //  MSVC: \"float float float\"\n    //  GCC: \"f f f\"\n    // Return type deduced correctly in all three examples, even when overload resolution\n    // is required.\n\n  // Valid:\n    // Determine function type via decltype.\n    // Automatically resolves overload, as only one version of example() is the same type\n    // as example_f():\n    // \"float (*)(float, float, float)\".\n    decltype(&amp;example_f) exfp = example;\n    std::cout &lt;&lt; (2 * example(1., 2.8, 0.6)) &lt;&lt; std::endl;\n  // Invalid:\n    // Explicitly specify which version of overloaded function we mean.\n    decltype(&amp;example(float, float, float)) exfp_inv = example;\n    // or...\n    decltype(&amp;example(1.f, 2.8f, 0.6f) exfp_inv2 = example;\n    // or...\n    decltype(&amp;example(float{}, float{}, float{})) exfp_inv3 = example;\n}\n</code></pre>\n<p>Considering the above, my question is this: In the case of using <code>decltype</code> to obtain the signature of an overloaded function, why can't the function parameters, or at least the types thereof, be specified to allow for overload resolution?</p>\n<p>As per the standard, quoting <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_35543211_35543211_0\">1) If the argument is an unparenthesized id-expression or an unparenthesized class member access, then decltype yields the type of the <em>entity</em> named by this expression. If there is no such entity, or if the argument names a set of overloaded functions, the program is ill-formed.</p>\n</blockquote>\n<p>I feel that in this case, where the argument names a set of overloaded functions, syntax that allows the programmer to specify parameter types would allow programs to be properly formed even when using <code>decltype</code> with overloaded functions, and I'm honestly curious as to why it isn't allowed.  I don't see it being of much use (it's easy enough to use templates to create a valid function pointer or to strip one down to determine the return and parameter types, which would account for overloads and allow mostly the same functionality as being able to use <code>decltype</code> on overloaded functions directly; in situations where you <em>can't</em> easily determine said information, something was likely coded poorly, rendering the point moot), but with how easy it should be to implement, I'm surprised it wasn't.</p>\n<p>A possible implementation:</p>\n<pre><code>// Currently legal syntax, which will be used as a basis.\ndecltype(example(1.f, 2.8f, 0.6f)) e;\n// decltype properly deduces that we want the return type of\n//  \"float example(float, float, float)\".\n\n// Possible implementation, based on the above.\ndecltype(&amp;example(1.f, 2.8f, 0.6f)) ep;\n// decltype is currently unable to deduce that we want a function pointer with a signature of\n//  \"float example(float, float, float)\".\n// However, this syntax would allow it to deduce this if the standard allowed it.\n</code></pre>\n<p>...If there is a method to allow <code>decltype</code> to correctly resolve overloads when creating a function pointer that I'm not aware of, I'd also be interested in learning about it, now that my curiosity is piqued.  It just seems <em>weird</em> that it was omitted.</p>\n<p>[My apologies if this is a duplicate.  Most similar questions that I've seen appear to be on how to work around this, while mine is about the logic behind it.]</p>\n<hr>\n<p>Edit: For clarification, the question is this: For any given overloaded function, why is <code>decltype(function_name(appropriate_parameters))</code> able to successfully resolve the overload to the correct version of the function and evaluate to its return type, while <code>decltype(&amp;function_name(appropriate_parameters))</code>, or a similar syntax, is unable to successfully resolve the overload to the correct version of the function and evaluate to its signature?  It seems inconsistent to me, especially since it would, in theory, be trivial to implement.</p>\n<p>Using <code>int example(int, int, int)</code> and <code>float example(float, float, float)</code> as an example, if <code>decltype(example(1.f, 2.8f, 0.6f))</code> is able to successfully resolve the overload to <code>float example(float, float, float)</code> and evaluate to <code>float</code>, why is <code>decltype(&amp;example(1.f, 2.8f, 0.6f))</code> unable to successfully resolve the overload to <code>float example(float, float, float)</code> and evaluate to <code>float (*)(float, float, float)</code>?</p>\n</hr>", "Tags": "<c++><c++11><function-pointers><decltype>", "OwnerUserId": "5386374", "AnswerCount": "1"}});