post_cb({"bq_ids": {"n4140": {"so_24253799_24253832_3": {"length": 18, "quality": 1.0, "section_id": 7151}, "so_24253799_24253900_0": {"length": 21, "quality": 0.875, "section_id": 6348}, "so_24253799_24253900_1": {"length": 22, "quality": 0.7857142857142857, "section_id": 6349}, "so_24253799_24253832_4": {"length": 18, "quality": 0.9, "section_id": 7151}}, "n3337": {"so_24253799_24253832_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 6895}, "so_24253799_24253900_0": {"length": 21, "quality": 0.875, "section_id": 6105}, "so_24253799_24253900_1": {"length": 22, "quality": 0.7857142857142857, "section_id": 6106}, "so_24253799_24253832_4": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_24253799_24253900_0": {"length": 21, "quality": 0.875, "section_id": 7857}, "so_24253799_24253900_1": {"length": 22, "quality": 0.7857142857142857, "section_id": 7858}, "so_24253799_24253832_4": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "24253832": {"Id": "24253832", "PostTypeId": "2", "Body": "<p><code>vector</code> doesn't depend on anything preventing its use in dynamic initialisation of statics.  The only issue with your code is a lack of thread safety - no particular reason to think you should care about that, unless you have statics whose construction spawns threads....</p>\n<blockquote>\n<p id=\"so_24253799_24253832_0\">Initializing <code>result</code> (see code below) could end up calling the vector constructor before that class is fully initialized, leading to access to uninitialized memory.</p>\n</blockquote>\n<p>No... initialising <code>result</code> calls <code>AddQuery</code> which checks <code>if (pending == NULL)</code> - the initialisation to <code>NULL</code> will certainly have been done before any dynamic initialisation, per 3.6.2/2:</p>\n<blockquote>\n<p id=\"so_24253799_24253832_1\"><strong><em>Constant initialization is performed:</em></strong></p>\n<p id=\"so_24253799_24253832_2\">...</p>\n<p id=\"so_24253799_24253832_3\">\u2014 <strong><em>if</em></strong> an <strong><em>object with static</em></strong> or thread <strong><em>storage duration</em></strong> is not initialized by a constructor call and if either the object is value-initialized or <strong><em>every full-expression that appears in its initializer is a constant expression</em></strong></p>\n</blockquote>\n<p>So even if the <code>result</code> assignment is in a different translation unit it's safe.  See 3.6.2/2:</p>\n<blockquote>\n<p id=\"so_24253799_24253832_4\">Together, zero-initialization and constant initialization are called <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-06-17T00:17:46.330", "Score": "2", "CreationDate": "2014-06-16T23:51:33.480", "ParentId": "24253799", "CommentCount": "6", "OwnerUserId": "410767", "LastEditDate": "2014-06-17T00:17:46.330"}, "24253799": {"ViewCount": "452", "Body": "<p>I have C++ code which declares static-lifetime variables which are initialized by function calls. The called function constructs a <code>vector</code> instance and calls its <code>push_back</code> method. Is the code risking doom via the C++ static initialization order fiasco? If not, why not?</p>\n<p>Supplementary information:</p>\n<ol>\n<li><p>What's the \"static initialization order fiasco\"?</p>\n<p>It's explained in <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\">C++ FAQ 10.14</a></p></li>\n<li><p>Why would I think use of vector could trigger the fiasco?</p>\n<p>It's possible that the <code>vector</code> constructor makes use of the value of another static-lifetime variable initialized dynamically. If so, then there is nothing to ensure that <code>vector</code>'s variable is initialized before I use <code>vector</code> in my code. Initializing <code>result</code> (see code below) could end up calling the <code>vector</code> constructor before <code>vector</code>'s dependencies are fully initialized, leading to access to uninitialized memory.</p></li>\n<li><p>What does this code look like anyway?</p>\n<pre><code>struct QueryEngine {\n  QueryEngine(const char *query, string *result_ptr)\n    : query(query), result_ptr(result_ptr) { }\n\n  static void AddQuery(const char *query, string *result_ptr) {\n    if (pending == NULL)\n      pending = new vector&lt;QueryEngine&gt;;\n    pending-&gt;push_back(QueryEngine(query, result_ptr));\n  }\n\n  const char *query;\n  string *result_ptr;\n\n  static vector&lt;QueryEngine&gt; *pending;\n};\n\nvector&lt;QueryEngine&gt; *QueryEngine::pending = NULL;\n\nvoid Register(const char *query, string *result_ptr) {\n  QueryEngine::AddQuery(query, result_ptr);\n}\n\nstring result = Register(\"query\", &amp;result);\n</code></pre></li>\n</ol>\n", "Title": "Is it safe to create and use vectors during static initialization?", "CreationDate": "2014-06-16T23:46:43.683", "LastActivityDate": "2014-06-17T08:44:19.350", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-17T00:38:31.170", "LastEditorUserId": "928894", "Id": "24253799", "Score": "8", "OwnerUserId": "928894", "Tags": "<c++><stdvector><static-initialization>", "AnswerCount": "2"}, "24253900": {"Id": "24253900", "PostTypeId": "2", "Body": "<p>Fortunately, <code>static</code> objects are zero-initialised even before <em>any</em> other initialisation is performed (even before the \"true\" initialisation of the same objects), so you know that the <code>NULL</code> will be set on that pointer long before <code>Register</code> is first invoked.<sup>1</sup></p>\n<p>Now, in terms of operating on your vector, it appears that (technically) you <em>could</em> run into such a problem:</p>\n<blockquote>\n<p id=\"so_24253799_24253900_0\"><code>[C++11: 17.6.5.9/3]:</code> A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including <code>this</code>.</p>\n<p id=\"so_24253799_24253900_1\"><code>[C++11: 17.6.5.9/4]:</code> <em>[Note:</em> This means, for example, that implementations can\u2019t use a static object for internal purposes without synchronization because it could cause a data race even in programs that do not explicitly share objects between threads. <em>\u2014end note]</em></p>\n</blockquote>\n<p>Notice that, although synchronisation is being required in this note, that's been mentioned within a passage that ultimately acknowledges that <code>static</code> implementation details are otherwise allowed.</p>\n<p>That being said, it seems like the standard should further state that user code should avoid operating on standard containers during static initialisation, if the intent were that the semantics of such code could not be guaranteed; I'd consider this a defect in the standard, either way. It should be clearer.</p>\n<p><sub><sup>1</sup> <a href=\"https://stackoverflow.com/a/21964142/560648\">And it <em>is</em> a NULL pointer, whatever the bit-wise representation of that may be, rather than a blot to all-zero-bits.</a></sub></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-17T08:44:19.350", "Score": "4", "CreationDate": "2014-06-16T23:59:58.207", "ParentId": "24253799", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T11:49:34.010"}});