post_cb({"43268997": {"CommentCount": "0", "ViewCount": "72", "CreationDate": "2017-04-07T03:12:52.487", "LastActivityDate": "2017-04-07T08:05:14.847", "Title": "Forward iterator/random acces iterator and `operator*` over temporary iterators", "PostTypeId": "1", "Id": "43268997", "Score": "2", "Body": "<p>Is this:</p>\n<pre><code>auto&amp; ref1 = *it++;\nref1 = expression; // (1)\n</code></pre>\n<p>one of the required semantics of a forward iterator? And what about a random access iterator?</p>\n<pre><code>auto&amp; ref1 = it[3];\nref1 = expression; // (2)\n</code></pre>\n<p>According to <code>cppreference</code>, a forward iterator is required to:</p>\n<pre><code>// Return reference, which equals to (const) value_type &amp;\n*it++ === value_type&amp;\n</code></pre>\n<p>and for a random access iterator:</p>\n<pre><code>it[n] === *(it + n)\n</code></pre>\n<p>which is the same situation, which means that in both situations you are dereferencing a temporary (the iterator). In my case, my iterator stores by copy an index which allows to access a container which doesn't provide direct access to the stored elements, only through the index.</p>\n<p>That works fine:</p>\n<pre><code>*it++ = value;\n</code></pre>\n<p>since the temporary copy of <code>it</code> has sentence scope.</p>\n<p>But in this case:</p>\n<pre><code>type&amp; val = *it++;\nval = 3;\n</code></pre>\n<p>we get undefined behaviour, since the copy is already destroyed in the second line.</p>\n<p>In my situation, I have a <code>QModelIndex</code> wrapper to get data/save from/to a <code>QAbstractItemModel</code>. The model only gives you copies of the <code>QVariant</code>s stored on the model.</p>\n<p>My wrapper class (the <code>value_type</code> with the <code>operator=</code> overloaded) saves an instance of a <code>QModelIndex</code> (to manipulate the model), and the iterator an instance of that wrapper. So, if the iterator is destroyed, the wrapper and the index too.</p>\n<p>I think I can solve both problems as far as lines <code>(1)</code> and <code>(2)</code> don't need to be supported.</p>\n<p><em>NOTE:</em> My implementation is more or less like that (simplified):</p>\n<pre><code>// The value type\nstruct index\n{\n    QModelIndex qidx;\n\n    index&amp; operator=(QVariant const&amp; val)\n    {\n        if (qidx.isValid())\n            qidx.model()-&gt;setData(qidx, val);\n\n        return *this;\n    }\n};\n\n// Private class actually. The \"movements\" cannot be done\n// over the value type because it will cause, in functions\n// returning references to the value type, to increase the chaos.\n// So, I make the index points to different model items using\n// this class.\nstruct index_manipulator\n{\n    QModelIndex&amp; qidx;\n\n    void move(int rows, int cols)\n    {\n        if (qidx.isValid())\n            qidx = qidx.model()-&gt;index(qidx.row() + rows,\n                                       qidx.column() + cols);\n    }\n};\n\nstruct index_safe_ref\n{\n    mutable index idx;\n    operator index&amp;() const { return idx; }\n};\n\nstruct my_row_it\n{\n    index idx;\n    index_manipulator manip = {idx.qidx};\n\n    my_row_it(QAbstractItemModel* m, int col)\n        : idx(m ? m-&gt;index(0, col) : QModelIndex())\n    {}\n\n    index&amp; operator*() const { return idx; }\n\n    my_row_it operator++(int) const\n    {\n        auto copy = it;\n        manip.move(1, 0);\n        return copy;\n    }\n\n    index_safe_ref my_row_it::operator[](difference_type n) const\n    {\n       auto it = it + n; // Operator+ is over there.\n       return { it.idx };\n    }\n};\n</code></pre>\n", "Tags": "<c++><iterator><random-access><temporary-objects>", "OwnerUserId": "1794803", "AnswerCount": "2"}, "43270195": {"ParentId": "43268997", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is covered by a general statement about iterators:</p>\n<blockquote>\n<p id=\"so_43268997_43270195_0\">Destruction of an iterator may invalidate pointers and references previously obtained from that iterator.</p>\n<p id=\"so_43268997_43270195_1\">\u00a724.2.1/9 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a></p>\n</blockquote>\n<p>But, as T.C. points out in the <a href=\"https://stackoverflow.com/a/43270580/1116364\">other answer</a> your iterator cannot be a valid forward iterator (or anything more strict then) if you return a reference to an object contained within the iterator object.</p>\n<p>I see two solutions: Return that <code>index</code> object by value, or return a reference to a heap allocated <code>index</code> object.</p>\n<hr>\n<p>As a note, an <em>input iterator</em> needs to support this:</p>\n<pre><code>value_type temp = *iterator++; // or *iterator; ++iterator;\n// use temp\n</code></pre>\n<p>So in your case this must work (but should as far as I can see):</p>\n<pre><code>index temp = *iterator++;\ntemp = expression.\n</code></pre>\n<p>This is not the same as line <code>(1)</code> because above code involves a conversion to the value_type (and not a reference to it).</p>\n</hr>", "OwnerUserId": "1116364", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:25.357", "Id": "43270195", "Score": "0", "CreationDate": "2017-04-07T05:16:32.453", "LastActivityDate": "2017-04-07T08:05:14.847"}, "bq_ids": {"n4140": {"so_43268997_43270195_0": {"section_id": 5563, "quality": 1.0, "length": 9}}, "n3337": {"so_43268997_43270195_0": {"section_id": 5345, "quality": 1.0, "length": 9}}, "n4659": {"so_43268997_43270195_0": {"section_id": 7010, "quality": 1.0, "length": 9}}}, "43270580": {"ParentId": "43268997", "CommentCount": "2", "Body": "<p>A stashing iterator (that is, an iterator that returns a reference to something within itself) is never a valid forward iterator.</p>\n<p>Iterators in general must be <a href=\"https://timsong-cpp.github.io/cppwp/utility.arg.requirements#tab:copyconstructible\" rel=\"nofollow noreferrer\"><code>CopyConstructible</code></a> (<a href=\"https://timsong-cpp.github.io/cppwp/iterators#iterator.iterators-2.1\" rel=\"nofollow noreferrer\">[iterator.iterators]/2.1</a>, which requires, among other things, that a copy of the iterator be equivalent to the original. It follows that a forward iterator and its copy must necessarily compare equal, and <a href=\"https://timsong-cpp.github.io/cppwp/iterators#forward.iterators-6\" rel=\"nofollow noreferrer\">[forward.iterators]/6</a> requires that that for two equal dereferenceable iterators <code>a</code> and <code>b</code>, <code>*a</code> and <code>*b</code> must be bound to the same object, which cannot be satisfied for stashing iterators.</p>\n<p>If you need to ignore a requirement, I suggest ignoring the one that says <code>reference</code> must be an actual reference type, turning your stashing iterator into a proxy iterator. There's established practice for that in the standard library (<code>vector&lt;bool&gt;::iterator</code>) and any breakage is likely to be a loud compile-time error, rather than silent runtime mischief.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "43270580", "Score": "0", "CreationDate": "2017-04-07T05:49:40.957", "LastActivityDate": "2017-04-07T05:49:40.957"}});