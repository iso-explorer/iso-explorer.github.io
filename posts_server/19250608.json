post_cb({"19250659": {"Id": "19250659", "PostTypeId": "2", "Body": "<p><code>a a1();</code> is a function declaration return type as <code>a</code> which has nothing to do with the calling constructor</p>\n<p><code>a a ;</code> is simple statement works fine will call the constructor</p>\n", "LastEditorUserId": "1870232", "LastActivityDate": "2013-10-08T14:41:30.170", "Score": "0", "CreationDate": "2013-10-08T14:35:11.533", "ParentId": "19250608", "CommentCount": "1", "OwnerUserId": "1870232", "LastEditDate": "2013-10-08T14:41:30.170"}, "19250664": {"Id": "19250664", "PostTypeId": "2", "Body": "<p>When you write <code>a a1();</code> it is actually being parsed as a function declaration not a call to the default constructor.  </p>\n<p><code>a a1;</code> </p>\n<p>will call the default constructor correctly</p>\n<p>When you write <code>a a;</code> it works because the variable name takes preference over the class name in what is called name hiding, but even though it works it will only lead to confusion and I would avoid doing it.  </p>\n<p>And for all those people who like standards quotes here you go</p>\n<blockquote>\n<p id=\"so_19250608_19250664_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.</p>\n</blockquote>\n", "LastEditorUserId": "2167655", "LastActivityDate": "2013-10-08T14:46:45.740", "Score": "20", "CreationDate": "2013-10-08T14:35:18.570", "ParentId": "19250608", "CommentCount": "5", "OwnerUserId": "2167655", "LastEditDate": "2013-10-08T14:46:45.740"}, "19250608": {"ViewCount": "1183", "Body": "<ol>\n<li>To my surprise, I found that the name of a c++ object can be the same as class name. Can someone explain to me the reason why?</li>\n<li>When I declare an object of class <code>a</code> as <code>a a1()</code>, it does not raise an error, but doesn't call the constructor. Why is this happening?</li>\n</ol>\n<p>My code:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass a \n{\n    public:\n    a() \n    {\n        cout &lt;&lt; \"in a\\n\";\n    }\n};\n\nint main()\n{\n    a a1();\n    a a;\n}\n</code></pre>\n", "Title": "How is this possible to use in c++?", "CreationDate": "2013-10-08T14:33:03.060", "LastActivityDate": "2013-10-19T13:09:09.253", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-08T19:24:52.603", "LastEditorUserId": "819272", "Id": "19250608", "Score": "17", "OwnerUserId": "2798234", "Tags": "<c++><class><function-declaration><variable-initialization>", "AnswerCount": "5"}, "19250829": {"Id": "19250829", "PostTypeId": "2", "Body": "<p>It is valid to hide the name of a class with a variable in fact if you look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">C++draft standard section</a> <code>3.3.10</code> <em>Name hiding</em> paragraph <em>2</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19250608_19250829_0\"><strong>A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable</strong>, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is\n  visible.</p>\n</blockquote>\n<p>I don't think it is good practice and it would lead to hard to maintain code. This line of code is actually declaring a function:</p>\n<pre><code>a a1();\n</code></pre>\n<p>you can alternatively use this pre-<em>C++11</em>:</p>\n<pre><code>a a1 ;\n</code></pre>\n<p>or <a href=\"http://www.stroustrup.com/C++11FAQ.html#uniform-init\" rel=\"nofollow noreferrer\">uniform initialization</a> introduced in <em>C++11</em> :</p>\n<pre><code>a a1{} ;\n</code></pre>\n<p>Circling back to <em>name hiding</em>, I was pleasantly surprised to see that <code>clang</code> will warn you about this with this code regardless of the warning levels set:</p>\n<pre><code>int main()\n{\n   a a;\n   a a2 ;\n}\n</code></pre>\n<p>I receive this message:</p>\n<pre><code>main.cpp:12:10: note: class 'a' is hidden by a non-type declaration of 'a' here\n   a a;\n     ^\n</code></pre>\n<p>although I can't see to obtain a similar warning from <code>gcc</code>. </p>\n<p><b>Update</b></p>\n<p>Thinking about this comments I made earlier on <a href=\"https://stackoverflow.com/questions/19250608/how-is-this-possible-to-use-in-c#comment28502613_19250758\">warts of uniform initialization</a>, I realized that had you suspected that <code>a1</code> was somehow not the correct type you could have have used <a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow noreferrer\">typeid</a> to debug what was going on. For example this code:</p>\n<pre><code>std::cout &lt;&lt; typeid(a).name() &lt;&lt; std::endl ;\nstd::cout &lt;&lt; typeid(a1).name() &lt;&lt; std::endl ;\n</code></pre>\n<p>results in this output on <a href=\"http://coliru.stacked-crooked.com/a/6bfdca5df91e8cc5\" rel=\"nofollow noreferrer\">Coliru live example</a>:</p>\n<pre><code>1a\nF1avE\n</code></pre>\n<p>and passing it through <a href=\"http://linux.die.net/man/1/c++filt\" rel=\"nofollow noreferrer\">c++filt</a> you receive this output:</p>\n<pre><code>a ()     // A function that returns type a\na        // type a\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-08T19:17:10.580", "Score": "4", "CreationDate": "2013-10-08T14:41:40.453", "ParentId": "19250608", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:45:12.387"}, "bq_ids": {"n4140": {"so_19250608_19250829_0": {"length": 41, "quality": 1.0, "section_id": 7079}, "so_19250608_19250664_0": {"length": 41, "quality": 1.0, "section_id": 7079}}, "n3337": {"so_19250608_19250829_0": {"length": 41, "quality": 1.0, "section_id": 6823}, "so_19250608_19250664_0": {"length": 41, "quality": 1.0, "section_id": 6823}}, "n4659": {"so_19250608_19250829_0": {"length": 41, "quality": 1.0, "section_id": 8580}, "so_19250608_19250664_0": {"length": 41, "quality": 1.0, "section_id": 8580}}}, "19466346": {"Id": "19466346", "PostTypeId": "2", "Body": "<p>This is what I got from your code when tried to compile it with <code>clang</code>, I think it says everything.</p>\n<pre><code>test.cpp:15:9: warning: empty parentheses interpreted as a function declaration\n      [-Wvexing-parse]\n    a a1();\n        ^~\ntest.cpp:15:9: note: remove parentheses to declare a variable\n    a a1();\n        ^~\n1 warning generated.\n</code></pre>\n", "LastActivityDate": "2013-10-19T13:09:09.253", "CommentCount": "0", "CreationDate": "2013-10-19T13:09:09.253", "ParentId": "19250608", "Score": "0", "OwnerUserId": "823738"}, "19250758": {"Id": "19250758", "PostTypeId": "2", "Body": "<p><code>a a1();</code> is a function declaration.</p>\n<p>That's an important reason for the creation of uniform initialization in C++11. To initialize the object using the constructor in C++11, use <code>a a1{};</code></p>\n", "LastActivityDate": "2013-10-08T14:38:53.683", "CommentCount": "2", "CreationDate": "2013-10-08T14:38:53.683", "ParentId": "19250608", "Score": "8", "OwnerUserId": "93558"}});