post_cb({"bq_ids": {"n4140": {"so_24423481_24424033_1": {"length": 70, "quality": 0.8974358974358975, "section_id": 5485}, "so_24423481_24424033_2": {"length": 48, "quality": 0.9795918367346939, "section_id": 6694}, "so_24423481_24423481_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5857}, "so_24423481_24424033_0": {"length": 7, "quality": 0.875, "section_id": 7055}}, "n3337": {"so_24423481_24424033_1": {"length": 74, "quality": 0.9487179487179487, "section_id": 5271}, "so_24423481_24424033_2": {"length": 48, "quality": 0.9795918367346939, "section_id": 6449}, "so_24423481_24423481_0": {"length": 40, "quality": 0.975609756097561, "section_id": 5627}, "so_24423481_24424033_0": {"length": 7, "quality": 0.875, "section_id": 6799}}, "n4659": {"so_24423481_24424033_1": {"length": 70, "quality": 0.8974358974358975, "section_id": 6920}, "so_24423481_24424033_2": {"length": 48, "quality": 0.9795918367346939, "section_id": 8169}, "so_24423481_24423481_0": {"length": 40, "quality": 0.975609756097561, "section_id": 7336}, "so_24423481_24424033_0": {"length": 7, "quality": 0.875, "section_id": 8552}}}, "24424033": {"Id": "24424033", "PostTypeId": "2", "Body": "<p>g++'s behavior here is entirely correct. This is specified in \u00a73.3.2 [basic.scope.pdecl]/p7 of the standard:</p>\n<blockquote>\n<p id=\"so_24423481_24424033_0\">The point of declaration of a class first declared in an\n  <em>elaborated-type-specifier</em> is as follows:</p>\n<ul>\n<li>for a declaration of the form <br>\n<em>class-key attribute-specifier-seq<sub>opt</sub> identifier ;</em> <br> the identifier is declared to be a <em>class-name</em> in the scope that contains\n  the declaration, otherwise</br></br></li>\n<li>for an <em>elaborated-type-specifier</em> of the form <br>\n<em>class-key identifier</em><br> if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a\n  function defined in namespace scope, the identifier is declared as a\n  <em>class-name</em> in the namespace that contains the declaration; otherwise, except as a friend declaration<sup>*</sup>, the identifier is declared\n  in the smallest namespace or block scope that contains the\n  declaration.</br></br></li>\n</ul>\n</blockquote>\n<p>Note that in the second case the declaration is always placed in a namespace or block scope, never a class scope, so it can never declare a nested class. Also, in the second case, a lookup will be performed and only if a previously declared <em>type-name</em> is not found will the <em>elaborated-type-specifier</em> be taken to declare a new name (\u00a73.4.4 [basic.lookup.elab]/p2, \u00a79.1 [class.name]/p3 note).</p>\n<hr>\n<p><sub><sup>*</sup> Friend declarations have their own weird rules. The names first declared in friend declarations are still placed in namespace (for non-local classes) or block (for local classes) scope, but they are not made visible for most name lookup (except for ADL in case of functions) until they are also declared in the scope containing them. The rules for non-local classes are specified in \u00a77.3.1.2 [namespace.memdef]/p3:</sub> </p>\n<blockquote>\n<p id=\"so_24423481_24424033_1\"><sub> If a friend declaration in a non-local class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a matching declaration is provided in that namespace scope (either before or after the class definition granting friendship). If a friend function is called, its name may be found by the name lookup that considers functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the\n  name in a friend declaration is neither qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace. </sub></p>\n</blockquote>\n<p><sub>The rules for local classes are specified in \u00a711.3 [class.friend]/p11: </sub></p>\n<blockquote>\n<p id=\"so_24423481_24424033_2\"><sub>If a friend declaration appears in a local class (9.8) and the name specified is an unqualified name, a prior declaration is looked up without considering scopes that are outside the innermost enclosing non-class scope. [...] For a friend class declaration, if there is no prior declaration, the class that is specified belongs to the innermost enclosing non-class scope, but if it is subsequently referenced, its name is not found by name lookup until a matching declaration is provided in the innermost enclosing non-class scope.</sub></p>\n</blockquote>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-07-25T01:34:01.520", "Score": "15", "CreationDate": "2014-06-26T06:45:27.633", "ParentId": "24423481", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2014-07-25T01:34:01.520"}, "24423481": {"ViewCount": "519", "Body": "<p>Take these class definitions:</p>\n<p>Class definition 1:</p>\n<pre><code>struct A \n{\n   struct B* m_b;\n};\n</code></pre>\n<p>Class definition 2:</p>\n<pre><code>struct A \n{\n   struct B;\n   B* m_b;\n};\n</code></pre>\n<p>Both the class defintions should declare <code>B</code> as a nested class. At least, that's what I thought by reading the following from the draft C++11 standard:</p>\n<blockquote>\n<p id=\"so_24423481_24423481_0\">9.1/2 A class declaration introduces the class name into the scope where it is declared and hides any class, variable, function, or other declaration of that name in an enclosing scope (3.3). If a class name is declared in a scope where a variable, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an <em>elaborated-type-specifier</em> `</p>\n</blockquote>\n<p>However, g++ 4.8.2 treats them differently. In the first definition, it treats <code>B</code> as a class that is a peer to <code>A</code>.</p>\n<p>The following program is built successfully:</p>\n<pre><code>struct A \n{\n   struct B* m_b;\n};\n\nvoid myfun(const B&amp; b )\n{\n}\n\nint main()\n{\n   A a;\n   myfun(*a.m_b);\n}\n</code></pre>\n<p>while the following program does not:</p>\n<pre><code>struct A \n{\n   struct B;\n   B* m_b;\n};\n\nvoid myfun(const B&amp; b )\n{\n}\n\nint main()\n{\n   A a;\n   myfun(*a.m_b);\n}\n</code></pre>\n<p>I understand why the second program does not compile but I don't understand why the first program is built successfully.</p>\n<p>Am I missing something in the interpretation of the standard?</p>\n<p>Is g++ 4.8.2 correct in compiling the first program?</p>\n", "AcceptedAnswerId": "24424033", "Title": "A class name introduced inside a class is not treated as a nested class name", "CreationDate": "2014-06-26T06:08:33.993", "Id": "24423481", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-07-25T01:34:01.520", "Score": "11", "OwnerUserId": "434551", "Tags": "<c++><c++11><g++>", "AnswerCount": "1"}});