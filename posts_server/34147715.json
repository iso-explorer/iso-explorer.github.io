post_cb({"34147715": {"CommentCount": "0", "ViewCount": "59", "CreationDate": "2015-12-08T03:53:31.450", "LastActivityDate": "2015-12-08T04:24:06.093", "Title": "Understanding the order of conversions, arithmetic conversions, and integer promotions for non-overloaded bitwise operators", "AcceptedAnswerId": "34147799", "PostTypeId": "1", "Id": "34147715", "Score": "0", "Body": "<p>I want to understand exactly what is happening, when the compiler encounter a non overloaded operator and what conversions are operated. As an example, let's take the bitwise operators, and for example <code>&amp;</code>. The standard says :</p>\n<blockquote>\n<p id=\"so_34147715_34147715_0\"><strong>[expr.bit.and]</strong> The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The operator applies only to integral or unscoped enumeration operands.</p>\n</blockquote>\n<p>Then if I am searching for the usual arithmetic conversions, I got:</p>\n<blockquote>\n<p id=\"so_34147715_34147715_1\"><strong>[expr]</strong> Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n<ul>\n<li>If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other\n  operand does not have the same type, the expression is ill-formed.</li>\n<li>If either operand is of type long double, the other shall be converted to long double.</li>\n<li>Otherwise, if either operand is double, the other shall be converted to double.</li>\n<li>Otherwise, if either operand is float, the other shall be converted to float.</li>\n<li>Otherwise, the integral promotions shall be performed on both operands. Then the following rules shall be applied to the promoted operands:\n  \n  <ul>\n<li>If both operands have the same type, no further conversion is needed.</li>\n<li>Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank shall be converted to the type of the operand with greater rank.</li>\n<li>Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type.</li>\n<li>Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</li>\n<li>Otherwise, both operands shall be converted to the unsigned integer type corresponding to the type of the operand with signed integer type</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Now if we look to integer promotion:</p>\n<blockquote>\n<p id=\"so_34147715_34147715_2\"><strong>[conv.prom]</strong>:</p>\n<ul>\n<li>A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int.</li>\n<li>A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted to a prvalue of the first of the following types that can represent all the values of its underlying type: int, unsigned int, long int, unsigned long int, long long int, or unsigned long long int. If none of the types in that list can represent all the values of its underlying type, a prvalue of type char16_t, char32_t, or wchar_t can be converted to a prvalue of its underlying type.</li>\n<li>A prvalue of an unscoped enumeration type whose underlying type is not fixed can be converted to a prvalue of the first of the following types that can represent all the values of the enumeration: int, unsigned int, long int, unsigned long int, long long int, or unsigned long long int. If none of the types in that list can represent all the values of the enumeration, a prvalue of an unscoped enumeration type can be converted to a prvalue of the extended\n  integer type with lowest integer conversion rank greater than the rank of long long in which all the values of the enumeration can be represented. If there are two such extended types, the signed one is chosen.</li>\n<li>A prvalue of an unscoped enumeration type whose underlying type is fixed can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying type.</li>\n<li>A prvalue for an integral bit-field can be converted to a prvalue of type int if int can represent all the values of the bit-field; otherwise, it can be converted to unsigned int if unsigned int can represent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.</li>\n<li>A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true becoming one.</li>\n<li>These conversions are called integral promotions.</li>\n</ul>\n</blockquote>\n<p>But if we do:</p>\n<pre><code>std::integral_constant&lt;int, 2&gt; x;\nstd::integral_constant&lt;int, 3&gt; y;\nint z = x &amp; y;\n</code></pre>\n<p>It will work, although I don't see where it is specified in the standard. I would like to exactly, all the conversion checks that are done in the order. I think that first, the compiler check whether the operator&amp; has an overload taking exactly the types. Then I don't know what other tests the compiler does. And probably only after that it uses the usual arithmetic conversions and then the integral promotion.</p>\n<p>So what conversions tests and steps is the compiler doing and in what order when it encounters <code>T1 &amp; T2</code>? (extracts from the standard are welcome).</p>\n", "Tags": "<c++11><integer><type-conversion><standards><integer-promotion>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34147715_34147715_0": {"section_id": 6160, "quality": 0.7777777777777778, "length": 14}, "so_34147715_34147799_1": {"section_id": 563, "quality": 1.0, "length": 27}, "so_34147715_34147799_2": {"section_id": 383, "quality": 0.8695652173913043, "length": 20}, "so_34147715_34147799_0": {"section_id": 1, "quality": 0.9090909090909091, "length": 10}, "so_34147715_34147715_1": {"section_id": 5943, "quality": 0.875, "length": 28}}, "n3337": {"so_34147715_34147715_0": {"section_id": 5921, "quality": 0.7777777777777778, "length": 14}, "so_34147715_34147799_1": {"section_id": 554, "quality": 1.0, "length": 27}, "so_34147715_34147799_2": {"section_id": 374, "quality": 0.8695652173913043, "length": 20}, "so_34147715_34147799_0": {"section_id": 1, "quality": 0.9090909090909091, "length": 10}, "so_34147715_34147715_1": {"section_id": 5714, "quality": 0.875, "length": 28}}, "n4659": {"so_34147715_34147799_1": {"section_id": 586, "quality": 1.0, "length": 27}, "so_34147715_34147715_0": {"section_id": 7657, "quality": 0.7777777777777778, "length": 14}, "so_34147715_34147799_2": {"section_id": 400, "quality": 0.8695652173913043, "length": 20}, "so_34147715_34147799_0": {"section_id": 1, "quality": 0.9090909090909091, "length": 10}, "so_34147715_34147715_1": {"section_id": 7428, "quality": 0.875, "length": 28}}}, "34147799": {"ParentId": "34147715", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>When the compiler sees this:</p>\n<pre><code>int z = x &amp; y;\n</code></pre>\n<p>It will see that there is no specific <code>operator &amp;</code> for <code>std::integral_constant&lt;&gt;</code>.  It will see however that there is a non-<code>explicit</code> <code>operator value_type()</code> for <code>x</code> and <code>y</code>.  Since <code>value_type</code> is <code>int</code>, this gives a direct match for the most common <code>operator &amp;</code>.</p>\n<p>No arithmetic conversion or integral promotion is required or performed.</p>\n<p>[conv] (2.1) says:</p>\n<blockquote>\n<p id=\"so_34147715_34147799_0\">When used as operands of operators. The operator\u2019s requirements for its operands dictate the destination type.</p>\n</blockquote>\n<p>[over.match] says:</p>\n<blockquote>\n<p id=\"so_34147715_34147799_1\">Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way.\n  But, once the candidate functions and argument lists have been identified, the selection of the best function\n  is the same in all cases:</p>\n<ul>\n<li>(2.8) \u2014 First, a subset of the candidate functions (those that have the proper number of arguments and meet\n  certain other conditions) is selected to form a set of viable functions (13.3.2).</li>\n<li>(2.9) \u2014 Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed\n  to match each argument to the corresponding parameter of each viable function.</li>\n</ul>\n</blockquote>\n<p>[class.conv] says:</p>\n<blockquote>\n<p id=\"so_34147715_34147799_2\">Type conversions of class objects can be specified by constructors and by conversion functions. These\n  conversions are called user-defined conversions and are used for implicit type conversions (Clause 4), for\n  initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n</blockquote>\n", "OwnerUserId": "4323", "LastEditorUserId": "4323", "LastEditDate": "2015-12-08T04:24:06.093", "Id": "34147799", "Score": "1", "CreationDate": "2015-12-08T04:04:35.613", "LastActivityDate": "2015-12-08T04:24:06.093"}});