post_cb({"13651400": {"Id": "13651400", "PostTypeId": "2", "Body": "<p>It will only work if <code>std::vector&lt;int&gt;::iterator</code> is an object type with <code>operator++</code> a member function.  If it's a scalar type (e.g. <code>int *</code>), or <code>operator++</code> is a non-member function, it will fail.</p>\n<blockquote>\n<h3>5.3.2 Increment and decrement [expr.pre.incr]</h3>\n<p id=\"so_13651313_13651400_0\">1 - The operand of prefix <code>++</code> is modified by adding <code>1</code> [...]. <em>The operand shall be a modifiable lvalue.</em> [...]<br/>\n  2 - [...] The requirements on the operand of prefix <code>--</code> [...] are [...] the same as those of prefix <code>++</code>. [...]</p>\n</blockquote>\n<p>Non-const non-static member functions can be called on temporary objects (since they have non-<code>const</code> object type, per 9.3.2p3), but an lvalue reference parameter in a non-member function cannot bind to a temporary (13.3.3.1.4p3).</p>\n<pre><code>struct S { S &amp;operator++(); };\nstruct T { }; T &amp;operator++(T &amp;);\ntypedef int U;\n\n++S();  // OK\n++T();  // fails\n++U();  // fails\n</code></pre>\n<p>This means that it's nothing to do with the compiler, but rather the standard library; as you've observed libstdc++ is implemented with <code>std::vector&lt;int&gt;::iterator</code> an object type with member <code>operator++</code>, but your code could easily be compiled with the same compiler and a different standard library where <code>std::vector&lt;int&gt;::iterator</code> is <code>int *</code>, in which case it would fail.</p>\n<p><code>std::vector</code>, <code>std::array</code> and <code>std::string</code> are the only container templates that can sensibly be implemented with scalar (pointer) iterators, but that doesn't mean that calling <code>++</code> on other containers' iterators is safe; they could have non-member <code>operator++</code> as <code>T</code> above.</p>\n<p>To make an iterator to the before-the-end element, use <code>std::prev</code>:</p>\n<pre><code>std::vector&lt;int&gt;::iterator it = std::prev(myVec.end());\n</code></pre>\n<p><code>std::prev</code> and <code>std::next</code> are new in C++11, but are easily implementable in C++03.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-11-30T21:14:36.170", "Score": "8", "CreationDate": "2012-11-30T18:59:56.670", "ParentId": "13651313", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2012-11-30T21:14:36.170"}, "bq_ids": {"n4140": {"so_13651313_13651400_0": {"length": 10, "quality": 0.625, "section_id": 6075}}, "n3337": {"so_13651313_13651400_0": {"length": 10, "quality": 0.625, "section_id": 5843}}, "n4659": {"so_13651313_13651400_0": {"length": 9, "quality": 0.5625, "section_id": 7571}}}, "13651469": {"Id": "13651469", "PostTypeId": "2", "Body": "<p>No that won't work in general.</p>\n<p>In C++11 we have: <code>auto it = std::prev(myVec.end());</code>, which works reliably.</p>\n<p>Boost has a similar function if you're in C++03, though it's trivial to write altogether:</p>\n<pre><code>template &lt;typename BidirectionalIterator&gt;\nBidirectionalIterator\n    prev(BidirectionalIterator x,\n         typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)\n{\n    std::advance(x, -n);\n    return x;\n}\n</code></pre>\n<p>Keep in mind you need at least one element in the range for this to make sense.</p>\n<hr>\n<p>Here's an example of how your method won't work in general, consider this stripped-down <code>std::vector&lt;&gt;</code>:</p>\n<pre><code>#include &lt;iterator&gt;\n\nnamespace std_exposition\n{\n    template &lt;typename T&gt;\n    struct vector\n    {\n        // this is compliant:\n        typedef T* iterator;\n\n        iterator end()\n        {\n            return std::end(data);\n        }\n\n        T data[4];\n    };\n\n    // manually implemented std::prev:\n    template &lt;typename BidirectionalIterator&gt;\n    BidirectionalIterator\n        prev(BidirectionalIterator x,\n             typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)\n    {\n        std::advance(x, -n);\n        return x;\n    }\n}\n</code></pre>\n<p>Test program:</p>\n<pre><code>int main()\n{\n    std_exposition::vector&lt;int&gt; myVec;\n\n    // Won't compile (method in question):\n    auto it0 = --(myVec.end());\n\n    // Compiles\n    auto it1 = std::prev(myVec.end());\n    auto it2 = std_exposition::prev(myVec.end());\n}\n</code></pre>\n<hr>\n<p>There is a corresponding <code>std::next</code> as well, implemented here:</p>\n<pre><code>template &lt;typename BidirectionalIterator&gt;\nBidirectionalIterator\n    next(BidirectionalIterator x,\n         typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)\n{\n    std::advance(x, n);\n    return x;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "87234", "LastActivityDate": "2012-11-30T19:12:39.087", "Score": "6", "CreationDate": "2012-11-30T19:03:31.883", "ParentId": "13651313", "CommentCount": "0", "OwnerUserId": "87234", "LastEditDate": "2012-11-30T19:12:39.087"}, "13651313": {"ViewCount": "382", "Body": "<p>For example, <code>std::vector&lt;int&gt;::iterator it = --(myVec.end());</code>. This works in GCC 4.4 but I have heard a rumor that it's not portable. </p>\n", "AcceptedAnswerId": "13651400", "Title": "Can we reliably pre-increment/decrement rvalues?", "CreationDate": "2012-11-30T18:53:36.783", "Id": "13651313", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-11-30T21:14:36.170", "Score": "5", "OwnerUserId": "540815", "Tags": "<c++><rvalue><pre-increment>", "AnswerCount": "3"}, "13651569": {"Id": "13651569", "PostTypeId": "2", "Body": "<p>This is indeed not portable, because there's no way to know whether <code>myVec.end()</code> returns an object of class type with operator <code>--</code> overloaded by a member function or something else (maybe even a regular raw ponter). In the former case the overloaded <code>--</code> will compile (operators overloaded by member functions can be applied to rvalues), while in the latter case it will not.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-11-30T19:19:01.700", "Score": "2", "CreationDate": "2012-11-30T19:12:13.957", "ParentId": "13651313", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2012-11-30T19:19:01.700"}});