post_cb({"36242724": {"ParentId": "36242567", "CommentCount": "2", "Body": "<p>The section in the standard you're looking for is \u00a714.8.2.4</p>\n<blockquote>\n<p id=\"so_36242567_36242724_0\">If A was transformed from a function parameter pack and P is not a parameter pack, type deduction fails. Otherwise, using the resulting types P and A, the deduction is then done as described in 14.8.2.5. If P\n  is a function parameter pack, the type A of each remaining parameter type of the argument template is\n  compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces\n  template arguments for subsequent positions in the template parameter packs expanded by the function\n  parameter pack. If deduction succeeds for a given type, the type from the argument template is considered\n  to be at least as specialized as the type from the parameter template. </p>\n<p id=\"so_36242567_36242724_1\">[ Example:</p>\n<pre><code>template&lt;class... Args&gt; void f(Args... args); // #1\ntemplate&lt;class T1, class... Args&gt; void f(T1 a1, Args... args); // #2\ntemplate&lt;class T1, class T2&gt; void f(T1 a1, T2 a2); // #3\nf(); // calls #1\nf(1, 2, 3); // calls #2\nf(1, 2); // calls #3; non-variadic template #3 is more\n// specialized than the variadic templates #1 and #2\n</code></pre>\n<p id=\"so_36242567_36242724_2\">\u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "36242724", "Score": "6", "CreationDate": "2016-03-27T00:59:50.100", "LastActivityDate": "2016-03-27T00:59:50.100"}, "36242641": {"ParentId": "36242567", "CommentCount": "0", "Body": "<p>The same reason <code>f(const int&amp;)</code> is a better match than <code>f(const T&amp;)</code> when <code>T</code> can be deduced as <code>int</code>: <code>A(int)</code> is a non-template function and <code>A(int, Ts...)</code> with <code>Ts...</code> deduced as the empty list is a function template specialization.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "36242641", "Score": "2", "CreationDate": "2016-03-27T00:48:30.507", "LastActivityDate": "2016-03-27T00:48:30.507"}, "bq_ids": {"n4140": {"so_36242567_36242724_0": {"section_id": 327, "quality": 0.9836065573770492, "length": 60}}, "n3337": {"so_36242567_36242724_0": {"section_id": 317, "quality": 0.9836065573770492, "length": 60}}, "n4659": {"so_36242567_36242724_0": {"section_id": 335, "quality": 0.7868852459016393, "length": 48}}}, "36242567": {"CommentCount": "0", "ViewCount": "117", "LastActivityDate": "2016-03-27T00:59:50.100", "Body": "<p>Given the following simple <code>struct</code></p>\n<pre><code>template &lt;typename T&gt;\nstruct A\n{\n   A(T a) {}\n\n   template &lt;typename ... Ts&gt;\n   A(T a, Ts ... more) {}\n};\n\nint main()\n{\n   A&lt;int&gt; a(1);\n}\n</code></pre>\n<p>What is the guarantee that <code>A(T a)</code> will be called instead of the variadic template constructor, and why?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "36242724", "FavoriteCount": "1", "Title": "Variadic template constructor priority", "Id": "36242567", "Score": "5", "CreationDate": "2016-03-27T00:36:27.380", "Tags": "<c++><c++11>", "OwnerUserId": "2430597", "AnswerCount": "2"}});