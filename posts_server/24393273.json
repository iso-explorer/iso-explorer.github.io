post_cb({"bq_ids": {"n4140": {"so_24393273_24393273_0": {"length": 21, "quality": 1.0, "section_id": 7065}}, "n3337": {"so_24393273_24393273_0": {"length": 21, "quality": 1.0, "section_id": 6809}}, "n4659": {"so_24393273_24393273_0": {"length": 21, "quality": 1.0, "section_id": 8562}}}, "24393273": {"ViewCount": "857", "Body": "<p>There is a definition of function prototype scope (3.3.4/1 N3797):</p>\n<blockquote>\n<p id=\"so_24393273_24393273_0\">In a function declaration, or in any function declarator except the\n  declarator of a function definition (8.4), names of parameters (if\n  supplied) have function prototype scope, which terminates at the end\n  of the nearest enclosing function declarator.</p>\n</blockquote>\n<p>Can we get an example described that rule?</p>\n", "AcceptedAnswerId": "24393440", "Title": "Example of function prototype scope", "CreationDate": "2014-06-24T17:57:08.037", "Id": "24393273", "CommentCount": "4", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-03-17T23:32:47.147", "Score": "1", "Tags": "<c++><function>", "AnswerCount": "2"}, "29111630": {"Id": "29111630", "PostTypeId": "2", "Body": "<p>Here's an example that involves a relatively rare, but sometimes encountered mistake </p>\n<pre><code>void foo(struct S *v);\n\nstruct S {\n  int i;\n};\n\nint main() {\n  struct S *p = 0;\n  foo(p);           // ERROR: incompatible pointer types\n}\n</code></pre>\n<p>The above code is ill-formed (to borrow a C++ term), because the forward declaration of <code>struct S</code> made inside the prototype of <code>foo</code> has <em>function prototype scope</em>. It goes out of scope once the prototype ends. This means that forward declaration of <code>struct S</code> inside the <code>foo</code>'s prototype is completely unrelated to the declaration of <code>struct S</code> that follows it. These are two different types. Pointer <code>p</code> inside <code>main</code> is not compatible to the parameter type of <code>foo</code>. The code is ill-formed.</p>\n<p>Note that if you swap the declaration of <code>struct S</code> and the prototype of <code>foo</code>, the declaration of <code>struct S</code> inside thew prototype is no longer a forward declaration. It is assumed to refer to the previously declared <code>struct S</code>. The code becomes correct.</p>\n", "LastActivityDate": "2015-03-17T23:32:47.147", "Score": "1", "CreationDate": "2015-03-17T23:32:47.147", "ParentId": "24393273", "CommentCount": "0", "OwnerUserId": "187690"}, "24393440": {"Id": "24393440", "PostTypeId": "2", "Body": "<p>Here is a simple example</p>\n<pre><code>int a;\n\nvoid f( int a, int a );\n</code></pre>\n<p>The compiler will issue an error for the second parameter a because its name coincides with the name of the first parameter. That is the compiler will report that there is a redefinition of name a. The same name is defined twice in the same scope.</p>\n<p>Or another example</p>\n<pre><code>struct A {};\n\nvoid f( int A, struct A );\n</code></pre>\n<p>The first parameter name hides the structure name so the second parameter is defined using the elaborated name of the structure.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-06-24T18:13:41.173", "Score": "4", "CreationDate": "2014-06-24T18:07:55.353", "ParentId": "24393273", "CommentCount": "2", "LastEditDate": "2014-06-24T18:13:41.173", "OwnerUserId": "2877241"}});