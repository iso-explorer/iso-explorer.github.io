post_cb({"10476487": {"Id": "10476487", "PostTypeId": "2", "Body": "<p><strong>Rule 17.5</strong> of the 2004 <a href=\"http://en.wikipedia.org/wiki/MISRA_C\" rel=\"nofollow\">MISRA C</a> standard prohibits more than 2 levels of pointer indirection.</p>\n", "Score": "3", "LastActivityDate": "2012-05-07T03:59:57.543", "CreationDate": "2012-05-07T03:59:57.543", "ParentId": "10087113", "CommentCount": "2", "OwnerUserId": "105137"}, "10104350": {"Id": "10104350", "PostTypeId": "2", "LastEditDate": "2013-04-19T06:01:11.407", "CommentCount": "0", "LastEditorUserId": "1312147", "LastActivityDate": "2013-04-19T06:01:11.407", "CreationDate": "2012-04-11T10:39:52.333", "ParentId": "10087113", "Score": "17", "Body": "<p>There is <strong>no limit</strong>. A pointer is a chunk of memory whose contents are an address. <br>\nAs you said </br></p>\n<pre><code>int a = 10;\nint *p = &amp;a;\n</code></pre>\n<p>A pointer to a pointer is also a variable which contains an address of another pointer. <br/></p>\n<pre><code>int **q = &amp;p;\n</code></pre>\n<p>Here <code>q</code> is pointer to pointer holding the address of <code>p</code> which is already holding the address of <code>a</code>.</p>\n<p>There is nothing particularly special about a pointer to a pointer. <br>So there is no limit on chain of poniters which are holding the address of another pointer.<br>\nie.</br></br></p>\n<pre><code> int **************************************************************************z;\n</code></pre>\n<p>is allowed.</p>\n", "OwnerUserId": "1312147"}, "10996649": {"Id": "10996649", "PostTypeId": "2", "LastEditDate": "2012-06-12T12:35:57.277", "CommentCount": "1", "LastEditorUserId": "863502", "LastActivityDate": "2012-06-12T12:35:57.277", "CreationDate": "2012-06-12T12:27:17.937", "ParentId": "10087113", "Score": "9", "Body": "<p>Every C++ developer should have heard of the (in)famous <a href=\"http://c2.com/cgi/wiki?ThreeStarProgrammer\">Three star programmer</a></p>\n<p>And there really seems to be some magic \"pointer barrier\" that has to be camouflaged</p>\n<blockquote>\n<blockquote>\n<p id=\"so_10087113_10996649_3\">Quote from C2:</p>\n<blockquote>\n<p id=\"so_10087113_10996649_6\"><strong>Three Star Programmer</strong></p>\n<blockquote>\n<p id=\"so_10087113_10996649_8\">A rating system for C-programmers. The more indirect your pointers are (i.e. the more \"*\" before your variables), the higher your reputation will be. No-star C-programmers are virtually non-existent, as virtually all non-trivial programs require use of pointers. Most are one-star programmers. In the old times (well, I'm young, so these look like old times to me at least), one would occasionally find a piece of code done by a three-star programmer and shiver with awe.\n        Some people even claimed they'd seen three-star code with function pointers involved, on more than one level of indirection. Sounded as real as UFOs to me. </p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n", "OwnerUserId": "863502"}, "10087626": {"Id": "10087626", "PostTypeId": "2", "LastEditDate": "2012-04-10T12:34:13.773", "CommentCount": "1", "LastEditorUserId": "1171191", "LastActivityDate": "2012-04-10T12:34:13.773", "CreationDate": "2012-04-10T11:12:01.883", "ParentId": "10087113", "Score": "70", "Body": "<p>As people have said, no limit \"in theory\". However, out of interest I ran this with g++ 4.1.2, and it worked with size up to 20,000. Compile was pretty slow though, so I didn't try higher. So I'd guess g++ doesn't impose any limit either. (Try setting <code>size = 10</code> and looking in ptr.cpp if it's not immediately obvious.)</p>\n<p><code>g++ create.cpp -o create ; ./create &gt; ptr.cpp ; g++ ptr.cpp -o ptr ; ./ptr</code></p>\n<p>create.cpp</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    const int size = 200;\n    std::cout &lt;&lt; \"#include &lt;iostream&gt;\\n\\n\";\n    std::cout &lt;&lt; \"int main()\\n{\\n\";\n    std::cout &lt;&lt; \"    int i0 = \" &lt;&lt; size &lt;&lt; \";\";\n    for (int i = 1; i &lt; size; ++i)\n    {\n        std::cout &lt;&lt; \"    int \";\n        for (int j = 0; j &lt; i; ++j) std::cout &lt;&lt; \"*\";\n        std::cout &lt;&lt; \" i\" &lt;&lt; i &lt;&lt; \" = &amp;i\" &lt;&lt; i-1 &lt;&lt; \";\\n\";\n    }\n    std::cout &lt;&lt; \"    std::cout &lt;&lt; \";\n    for (int i = 1; i &lt; size; ++i) std::cout &lt;&lt; \"*\";\n    std::cout &lt;&lt; \"i\" &lt;&lt; size-1 &lt;&lt; \" &lt;&lt; \\\"\\\\n\\\";\\n\";\n    std::cout &lt;&lt; \"    return 0;\\n}\\n\";\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1171191"}, "10087162": {"Id": "10087162", "PostTypeId": "2", "LastEditDate": "2012-04-11T12:33:45.300", "CommentCount": "7", "LastEditorUserId": "1065180", "LastActivityDate": "2012-04-11T12:33:45.300", "CreationDate": "2012-04-10T10:37:38.800", "ParentId": "10087113", "Score": "26", "Body": "<p>There is no limit, check example <a href=\"http://www.indiabix.com/technical/c/pointers/\">here</a>. </p>\n<p>The answer depends on what you mean by \"levels of pointers.\" If you mean \"How many levels of indirection can you have in a single declaration?\" the answer is \"At least 12.\"</p>\n<pre><code>int i = 0;\n\nint *ip01 = &amp; i;\n\nint **ip02 = &amp; ip01;\n\nint ***ip03 = &amp; ip02;\n\nint ****ip04 = &amp; ip03;\n\nint *****ip05 = &amp; ip04;\n\nint ******ip06 = &amp; ip05;\n\nint *******ip07 = &amp; ip06;\n\nint ********ip08 = &amp; ip07;\n\nint *********ip09 = &amp; ip08;\n\nint **********ip10 = &amp; ip09;\n\nint ***********ip11 = &amp; ip10;\n\nint ************ip12 = &amp; ip11;\n\n************ip12 = 1; /* i = 1 */\n</code></pre>\n<p>If you mean \"How many levels of pointer can you use before the program gets hard to read,\" that's a matter of taste, but there is a limit. Having two levels of indirection (a pointer to a pointer to something) is common. Any more than that gets a bit harder to think about easily; don't do it unless the alternative would be worse.</p>\n<p>If you mean \"How many levels of pointer indirection can you have at runtime,\" there's no limit. This point is particularly important for circular lists, in which each node points to the next. Your program can follow the pointers forever.</p>\n", "OwnerUserId": "1065180"}, "bq_ids": {"n4140": {"so_10087113_10087264_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 47}, "so_10087113_10087135_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 47}}, "n4659": {"so_10087113_10087264_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 48}, "so_10087113_10087135_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 48}}}, "10088074": {"Id": "10088074", "PostTypeId": "2", "Body": "<p>Note that there are two possible questions here: how many levels of pointer indirection we can achieve in a C type, and how many levels of pointer indirection we can stuff into a single declarator.</p>\n<p>The C standard allows a maximum to be imposed on the former (and gives a minimum value for that).  But that can be circumvented via multiple typedef declarations:</p>\n<pre><code>typedef int *type0;\ntypedef type0 *type1;\ntypedef type1 *type2; /* etc */\n</code></pre>\n<p>So ultimately, this is an implementation issue connected to the idea of how big/complex can a C program be made before it is rejected, which is very compiler specific.</p>\n", "Score": "13", "LastActivityDate": "2012-04-10T11:41:37.407", "CreationDate": "2012-04-10T11:41:37.407", "ParentId": "10087113", "CommentCount": "0", "OwnerUserId": "1250772"}, "10090483": {"Id": "10090483", "PostTypeId": "2", "Body": "<p>It's actually even funnier with pointer to functions.</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntypedef void (*FuncType)();\n\nstatic void Print() { std::printf(\"%s\", \"Hello, World!\\n\"); }\n\nint main() {\n  FuncType const ft = &amp;Print;\n  ft();\n  (*ft)();\n  (**ft)();\n  /* ... */\n}\n</code></pre>\n<p>As illustrated <a href=\"http://ideone.com/JFS14\" rel=\"noreferrer\">here</a> this gives:</p>\n<blockquote>\n<p id=\"so_10087113_10090483_0\">Hello, World!<br>\n  Hello, World!<br>\n  Hello, World!  </br></br></p>\n</blockquote>\n<p>And it does not involve any runtime overhead, so you can probably stack them as much as you want... until your compiler chokes on the file.</p>\n", "Score": "21", "LastActivityDate": "2012-04-10T14:16:47.007", "CreationDate": "2012-04-10T14:16:47.007", "ParentId": "10087113", "CommentCount": "0", "OwnerUserId": "147192"}, "10087264": {"Id": "10087264", "PostTypeId": "2", "LastEditDate": "2012-04-20T15:24:29.440", "CommentCount": "10", "LastEditorUserId": "7028", "LastActivityDate": "2012-04-20T15:24:29.440", "CreationDate": "2012-04-10T10:45:00.040", "ParentId": "10087113", "Score": "380", "Body": "<p>The <code>C</code> standard specifies the lower limit:</p>\n<blockquote>\n<h3><a href=\"http://c0x.coding-guidelines.com/5.2.4.1.html\" rel=\"noreferrer\">5.2.4.1 Translation limits</a></h3>\n<p id=\"so_10087113_10087264_0\">276 The implementation shall be able to translate and execute at least one program that contains at least one instance of every one of the following limits: [...]</p>\n<p id=\"so_10087113_10087264_1\">279 \u2014 12 pointer, array, and function declarators (in any combinations) modifying an\n      arithmetic, structure, union, or void type in a declaration</p>\n</blockquote>\n<p>The upper limit is implementation specific.</p>\n", "OwnerUserId": "1275169"}, "18003423": {"Id": "18003423", "PostTypeId": "2", "Body": "<p>It depends on the place where you store pointers. If they are in stack you have <em>quite low</em> limit. If you store it in heap, you limit is much much much higher.</p>\n<p>Look at this program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconst int CBlockSize = 1048576;\n\nint main() \n{\n    int number = 0;\n    int** ptr = new int*[CBlockSize];\n\n    ptr[0] = &amp;number;\n\n    for (int i = 1; i &lt; CBlockSize; ++i)\n        ptr[i] = reinterpret_cast&lt;int *&gt; (&amp;ptr[i - 1]);\n\n    for (int i = CBlockSize-1; i &gt;= 0; --i)\n        std::cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; (int)ptr[i] &lt;&lt; \"-&gt;\" &lt;&lt; *ptr[i] &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>It creates 1M pointers and at the shows what point to what it is easy to notice what the chain goes to the first variable <code>number</code>.</p>\n<p>BTW. It uses <code>92K</code> of RAM so just imagine how deep you can go.</p>\n", "Score": "0", "LastActivityDate": "2013-08-01T20:00:00.857", "CreationDate": "2013-08-01T20:00:00.857", "ParentId": "10087113", "CommentCount": "0", "OwnerUserId": "1237747"}, "10087135": {"Id": "10087135", "PostTypeId": "2", "LastEditDate": "2012-04-10T20:26:30.510", "CommentCount": "7", "LastEditorUserId": "63550", "LastActivityDate": "2012-04-10T20:26:30.510", "CreationDate": "2012-04-10T10:35:59.573", "ParentId": "10087113", "Score": "78", "Body": "<p><strong>Theoretically:</strong></p>\n<p>You can have as many levels of indirections as you want.</p>\n<p><strong>Practically:</strong></p>\n<p>Of course, nothing that consumes memory can be indefinite, there will be limitations due to resources available on the host environment. So practically there is a maximum limit to what an implementation can support and the implementation shall document it appropriately. So in all such artifacts, the standard does not specify the maximum limit, but it does specify the lower limits.</p>\n<p>Here's the reference:</p>\n<p><strong>C99 Standard 5.2.4.1 Translation limits:</strong></p>\n<blockquote>\n<p id=\"so_10087113_10087135_0\">\u2014 12 pointer, array, and function declarators (in any combinations) modifying an\n  arithmetic, structure, union, or void type in a declaration.</p>\n</blockquote>\n<p>This specifies the lower limit that every implementation <strong>must</strong> support. Note that in a footenote the standard further says:</p>\n<blockquote>\n<p id=\"so_10087113_10087135_1\">18)  Implementations should avoid imposing fixed translation limits whenever possible.</p>\n</blockquote>\n", "OwnerUserId": "452307"}, "10094450": {"Id": "10094450", "PostTypeId": "2", "LastEditDate": "2012-04-11T07:18:48.190", "CommentCount": "1", "LastEditorUserId": "865038", "LastActivityDate": "2012-04-11T07:18:48.190", "CreationDate": "2012-04-10T18:36:16.660", "ParentId": "10087113", "Score": "58", "Body": "<p>Sounds fun to check. </p>\n<ul>\n<li><p>Visual Studio 2010 (on Windows 7), you can have 1011 levels before getting this error:</p>\n<blockquote>\n<p id=\"so_10087113_10094450_0\">fatal error C1026: parser stack overflow, program too complex</p>\n</blockquote></li>\n<li><p>gcc (Ubuntu), 100k+ <code>*</code> without a crash ! I guess the hardware is the limit here.</p></li>\n</ul>\n<p>(tested with just a variable declaration)</p>\n", "OwnerUserId": "865038"}, "26356263": {"Id": "26356263", "PostTypeId": "2", "Body": "<p>I'd like to point out that producing a type with an arbitrary number of *'s is something that can happen with template metaprogramming.  I forget what I was doing exactly, but it was suggested that I could produce new distinct types that have some kind of meta maneuvering between them by using <em>recursive</em> T* types.</p>\n<p>Template Metaprogramming is a slow descent into madness, so it is not necessary to make excuses when generating a type with several thousand level of indirection.  It's just a handy way to map peano integers, for example, onto template expansion as a functional language.</p>\n", "Score": "1", "LastActivityDate": "2014-10-14T08:40:04.883", "CreationDate": "2014-10-14T08:40:04.883", "ParentId": "10087113", "CommentCount": "1", "OwnerUserId": "658087"}, "10091962": {"Id": "10091962", "PostTypeId": "2", "Body": "<p>Actually, C programs commonly make use of infinite pointer indirection. One or two static levels are common. Triple indirection is rare. But infinite is very common.</p>\n<p>Infinite pointer indirection is achieved with the help of a struct, of course, not with a direct declarator, which would be impossible. And a struct is needed so that you can include other data in this structure at the different levels where this can terminate.</p>\n<pre><code>struct list { struct list *next; ... };\n</code></pre>\n<p>now you can have <code>list-&gt;next-&gt;next-&gt;next-&gt;...-&gt;next</code>. This is really just multiple pointer indirections: <code>*(*(..(*(*(*list).next).next).next...).next).next</code>.  And the <code>.next</code> is basically a noop when it's the first member of the structure, so we can imagine this as <code>***..***ptr</code>.</p>\n<p>There is really no limit on this because the links can be traversed with a loop rather than a giant expression like this, and moreover, the structure can easily be made circular.</p>\n<p>Thus, in other words, linked lists may be the ultimate example of adding another level of indirection to solve a problem, since you're doing it dynamically with every push operation. :)</p>\n", "Score": "145", "LastActivityDate": "2012-04-10T15:44:27.307", "CreationDate": "2012-04-10T15:44:27.307", "ParentId": "10087113", "CommentCount": "14", "OwnerUserId": "1250772"}, "17940575": {"Id": "17940575", "PostTypeId": "2", "LastEditDate": "2013-07-30T07:33:51.003", "CommentCount": "5", "LastEditorUserId": "1237747", "LastActivityDate": "2013-07-30T07:33:51.003", "CreationDate": "2013-07-30T07:15:19.707", "ParentId": "10087113", "Score": "1", "Body": "<p>There isn't such a thing like <em>real limit</em> but limit exists. All pointers are variables that are usually storing in stack <strong>not heap</strong>. Stack is usually small (it is possible to change its size during some linking). So lets say you have 4MB stack, what is quite normal size. And lets say we have pointer which is 4 bytes size (pointer sizes are not the same depending on architecture, target and compiler settings).</p>\n<p>In this case <code>4 MB / 4 b = 1024</code> so possible maximum number would be 1048576, but we shouldn't ignore the fact that some other stuff is in stack.</p>\n<p>However some compilers may have maximum number of pointer chain, but the limit is stack size. So if you increase stack size during linking with infinity and have machine with infinity memory which runs OS which handles that memory so you will have unlimited pointer chain.</p>\n<p>If you use <code>int *ptr = new int;</code> and put your pointer into heap, that is not so <em>usual</em> way limit would be heap size, not stack.</p>\n<p><strong>EDIT</strong> Just realize that <code>infinity / 2 = infinity</code>. If machine has more memory so the pointer size increases. So if memory is infinity and size of pointer is infinity, so it is bad news... :)</p>\n", "OwnerUserId": "1237747"}, "10087113": {"ViewCount": "37252", "LastEditDate": "2012-04-30T03:56:34.020", "Body": "<p>How many pointers (<code>*</code>) are allowed in a single variable?</p>\n<p>Let's consider the following example.</p>\n<pre><code>int a = 10;\nint *p = &amp;a;\n</code></pre>\n<p>Similarly we can have</p>\n<pre><code>int **q = &amp;p;\nint ***r = &amp;q;\n</code></pre>\n<p>and so on.</p>\n<p>For example,</p>\n<pre><code>int ****************zz;\n</code></pre>\n", "Title": "How many levels of pointers can we have?", "CreationDate": "2012-04-10T10:34:17.970", "LastActivityDate": "2014-10-14T08:40:04.883", "CommentCount": "24", "FavoriteCount": "99", "PostTypeId": "1", "LastEditorUserId": "1312147", "Id": "10087113", "Score": "403", "OwnerUserId": "1297267", "Tags": "<c++><c><pointers>", "AnswerCount": "14"}});