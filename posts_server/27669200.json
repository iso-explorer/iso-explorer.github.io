post_cb({"bq_ids": {"n4140": {"so_27669200_27669457_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}}, "n3337": {"so_27669200_27669457_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}}, "n4659": {"so_27669200_27669457_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}}}, "27669457": {"Id": "27669457", "PostTypeId": "2", "Body": "<p><code>std::array</code> is an aggregate. It has only one data member - an array of the specified type of the <code>std::array</code> specialization. According to the C++ Standard. (8.5.1 Aggregates)</p>\n<blockquote>\n<p id=\"so_27669200_27669457_0\">2 When an aggregate is initialized by an initializer list, as\n  specified in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order</p>\n</blockquote>\n<p>So this record </p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { 0, 1 }, { 1, 2 } };\n</code></pre>\n<p>has more initializers then there are data members in std::array.</p>\n<p>The data member of <code>std::array</code> is in turn an aggregate. You have to provide for it an initializer list.</p>\n<p>So the record will look like</p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { { 0, 1 }, { 1, 2 } } };\n</code></pre>\n<p>For it would be more clear you can imagine the initialization the following way</p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { /* an initializer for data member of the array */ };\n</code></pre>\n<p>As the data member is aggregate then you have to write</p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { /* initializers for the aggregate data member*/ } };\n</code></pre>\n<p>And at last</p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { { 0, 1 }, { 1, 2 } } };\n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-12-27T17:08:37.417", "Score": "13", "CreationDate": "2014-12-27T17:02:36.867", "ParentId": "27669200", "CommentCount": "4", "LastEditDate": "2014-12-27T17:08:37.417", "OwnerUserId": "2877241"}, "27669319": {"Id": "27669319", "PostTypeId": "2", "Body": "<p>Add another pair of braces.</p>\n<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { { 0, 1 }, { 1, 2 } } };\n</code></pre>\n<p><code>std::array&lt;T, N&gt;</code> is an aggregate class containing a member of type <code>T[N]</code>. Usually, you can initialise that the same way you would a plain <code>T[N]</code> array, but when you're dealing with a non-aggregate element type, you may need to be more explicit.</p>\n", "LastActivityDate": "2014-12-27T16:45:20.047", "Score": "14", "CreationDate": "2014-12-27T16:45:20.047", "ParentId": "27669200", "CommentCount": "4", "OwnerUserId": "743382"}, "27669200": {"ViewCount": "5157", "Body": "<pre><code>std::array&lt;std::pair&lt;int, int&gt;, 2&gt; ids = { { 0, 1 }, { 1, 2 } };\n</code></pre>\n<p>VS2013 error:</p>\n<blockquote>\n<p id=\"so_27669200_27669200_0\">error C2440: 'initializing' : cannot convert from 'int' to 'std::pair' No constructor could take the source type, or constructor overload resolution was ambiguous`</p>\n</blockquote>\n<p>What am I doing wrong?</p>\n", "Title": "How should I brace-initialize an std::array of std::pairs?", "CreationDate": "2014-12-27T16:29:31.197", "LastActivityDate": "2015-11-14T22:25:32.567", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-11-14T22:25:32.567", "LastEditorUserId": "1950231", "Id": "27669200", "Score": "14", "OwnerUserId": "2068573", "Tags": "<c++><c++11><std-pair><stdarray><brace-initialization>", "AnswerCount": "2"}});