post_cb({"3394329": {"Id": "3394329", "PostTypeId": "2", "Body": "<p>The warning says it all!</p>\n<p>But in fairness I got bitten by the same error once.</p>\n<pre><code>int a = 1;\ncout &lt;&lt; ( a &gt;&gt; 32);\n</code></pre>\n<p>is completely undefined. In fact the compiler generally gives a different results than the runtime in my experience. What I mean by this is if the compiler can see to evaluate the shift expression at run time it may give you a different result to the expression evaluated at runtime.</p>\n", "LastActivityDate": "2010-08-03T07:12:44.790", "CommentCount": "0", "CreationDate": "2010-08-03T07:12:44.790", "ParentId": "3394259", "Score": "0", "OwnerUserId": "158285"}, "3394340": {"Id": "3394340", "PostTypeId": "2", "Body": "<p>foo(1,32) performs a rotate-shit, so bits that should disappear on the right reappear on the left. If you do it 32 times, the single bit set to 1 is back to its original position.</p>\n<p>bar(1,32) is the same, but the bit is in the 64-32+1=33th bit, which is above the representable numbers for a 32-bit int. Only the 32 lowest bit are taken, and they are all 0's.</p>\n<p>1 &gt;&gt; 32 is performed by the compiler. No idea why gcc uses a non-rotating shift here and not in the generated code.</p>\n<p>Same thing for ((int)1 &gt;&gt; (int)32)</p>\n", "LastActivityDate": "2010-08-03T07:14:29.507", "CommentCount": "1", "CreationDate": "2010-08-03T07:14:29.507", "ParentId": "3394259", "Score": "-5", "OwnerUserId": "124038"}, "3394302": {"Id": "3394302", "PostTypeId": "2", "Body": "<p>It's likely the <em>CPU</em> is actually computing</p>\n<pre><code>a &gt;&gt; (b % 32)\n</code></pre>\n<p>in <code>foo</code>; meanwhile, the 1 &gt;&gt; 32 is a constant expression, so the <em>compiler</em> will fold the constant at compile-time, which somehow gives 0.</p>\n<p>Since the standard (C++98 \u00a75.8/1) states that</p>\n<blockquote>\n<p id=\"so_3394259_3394302_0\"><strong>The behavior is undefined</strong> if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>there is no contradiction having <code>foo(1,32)</code> and <code>1&gt;&gt;32</code> giving different results.</p>\n<p>\u00a0</p>\n<p>On the other hand, in <code>bar</code> you provided a 64-bit unsigned value, as 64 &gt; 32 it is guaranteed the result <em>must be</em> 1 / 2<sup>32</sup> = 0. Nevertheless, if you write</p>\n<pre><code>bar(1, 64);\n</code></pre>\n<p>you may still get 1.</p>\n<hr>\n<p>Edit: The logical right shift (SHR) behaves like <code>a &gt;&gt; (b % 32/64)</code> on x86/x86-64 (Intel #253667, Page 4-404):</p>\n<blockquote>\n<p id=\"so_3394259_3394302_1\">The destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. <strong>The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used).</strong> The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.</p>\n</blockquote>\n<p>However, on ARM (armv6&amp;7, at least), the logical right-shift (LSR) is implemented as (ARMISA Page A2-6)</p>\n<pre><code>(bits(N), bit) LSR_C(bits(N) x, integer shift)\n    assert shift &gt; 0;\n    extended_x = ZeroExtend(x, shift+N);\n    result = extended_x&lt;shift+N-1:shift&gt;;\n    carry_out = extended_x&lt;shift-1&gt;;\n    return (result, carry_out);\n</code></pre>\n<p>where (ARMISA Page AppxB-13)</p>\n<pre><code>ZeroExtend(x,i) = Replicate('0', i-Len(x)) : x\n</code></pre>\n<p>This guarantees a right shift of \u226532 will produce zero. For example, when this code is run on the iPhone, <code>foo(1,32)</code> will give 0.</p>\n<p>These shows shifting a 32-bit integer by \u226532 is non-portable.</p>\n</hr>", "LastEditorUserId": "224671", "LastActivityDate": "2010-08-03T07:54:58.717", "Score": "35", "CreationDate": "2010-08-03T07:07:24.053", "ParentId": "3394259", "CommentCount": "4", "OwnerUserId": "224671", "LastEditDate": "2010-08-03T07:54:58.717"}, "3394304": {"Id": "3394304", "PostTypeId": "2", "Body": "<p>I suppose the reason is that <code>int</code> type holds 32-bits (for most systems), but one bit is used for sign as it is signed type. So only 31 bits are used for actual value.</p>\n", "LastActivityDate": "2010-08-03T07:07:54.917", "CommentCount": "1", "CreationDate": "2010-08-03T07:07:54.917", "ParentId": "3394259", "Score": "0", "OwnerUserId": "213725"}, "3394334": {"Id": "3394334", "PostTypeId": "2", "Body": "<p>I compiled it on 32 bit windows using VC9 compiler. It gave me the following <a href=\"http://msdn.microsoft.com/en-us/library/cx0bb1cy%28VS.80%29.aspx\" rel=\"nofollow noreferrer\">warning</a>. Since <code>sizeof(int)</code> is 4 bytes on my system compiler is indicating that right shifting by 32 bits results in undefined behavior. Since it is undefined, you can not predict the result. Just for checking I right shifted with 31 bits and all the warnings disappeared and the result was also as expected (i.e. 0).</p>\n", "LastActivityDate": "2010-08-03T07:13:30.443", "CommentCount": "3", "CreationDate": "2010-08-03T07:13:30.443", "ParentId": "3394259", "Score": "1", "OwnerUserId": "39742"}, "bq_ids": {"n4140": {"so_3394259_3394323_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6146}, "so_3394259_3394302_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}}, "n3337": {"so_3394259_3394323_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 5909}, "so_3394259_3394302_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}}, "n4659": {"so_3394259_3394323_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 7642}, "so_3394259_3394302_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}}}, "3394323": {"Id": "3394323", "PostTypeId": "2", "Body": "<p>OK. So it's in 5.8.1:</p>\n<blockquote>\n<p id=\"so_3394259_3394323_0\">The operands shall be of integral or enumeration type and integral promotions are performed. The type of the result is\n  that of the promoted left operand. The behavior is undefined if the right operand is negative, or greater than or equal to\n  the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>So you have an Undefined Behaviour(tm).</p>\n", "LastActivityDate": "2010-08-03T07:11:43.067", "CommentCount": "0", "CreationDate": "2010-08-03T07:11:43.067", "ParentId": "3394259", "Score": "6", "OwnerUserId": "113662"}, "3394552": {"Id": "3394552", "PostTypeId": "2", "Body": "<p>What happens in foo is that the shift width is greater than or equal to the size of the data being shifted.  In the C99 standard that results in undefined behaviour.  It's probably the same in whatever C++ standard MS VC++ is built to.</p>\n<p>The reason for this is to allow compiler designers to take advantage of any CPU hardware support for shifts.  For example, the i386 architecture has an instruction to shift a 32 bit word by a number of bits, but the number of bits is defined in a field in the instruction that is 5 bits wide.  Most likely, your compiler is generating the instruction by taking your bit shift amount and masking it with 0x1F to get the bit shift in the instruction.  This means that shifting by 32 is the same as shifting by 0.</p>\n", "LastActivityDate": "2010-08-03T07:50:31.617", "CommentCount": "0", "CreationDate": "2010-08-03T07:50:31.617", "ParentId": "3394259", "Score": "3", "OwnerUserId": "169346"}, "3394259": {"ViewCount": "3175", "Body": "<p>I recently faced a strange behavior using the right-shift operator.</p>\n<p>The following program:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\nint foo(int a, int b)\n{\n   return a &gt;&gt; b;\n}\n\nint bar(uint64_t a, int b)\n{\n   return a &gt;&gt; b;\n}\n\nint main(int argc, char** argv)\n{\n    std::cout &lt;&lt; \"foo(1, 32): \" &lt;&lt; foo(1, 32) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bar(1, 32): \" &lt;&lt; bar(1, 32) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"1 &gt;&gt; 32: \" &lt;&lt; (1 &gt;&gt; 32) &lt;&lt; std::endl; //warning here\n    std::cout &lt;&lt; \"(int)1 &gt;&gt; (int)32: \" &lt;&lt; ((int)1 &gt;&gt; (int)32) &lt;&lt; std::endl; //warning here\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Outputs:</p>\n<pre><code>foo(1, 32): 1 // Should be 0 (but I guess I'm missing something)\nbar(1, 32): 0\n1 &gt;&gt; 32: 0\n(int)1 &gt;&gt; (int)32: 0\n</code></pre>\n<p>What happens with the <code>foo()</code> function ? I understand that the only difference between what it does and the last 2 lines, is that the last two lines are evaluated at compile time. And why does it \"work\" if I use a 64 bits integer ?</p>\n<p>Any lights regarding this will be greatly appreciated !</p>\n<hr>\n<p>Surely related, here is what <code>g++</code> gives:</p>\n<pre><code>&gt; g++ -o test test.cpp\ntest.cpp: In function 'int main(int, char**)':\ntest.cpp:20:36: warning: right shift count &gt;= width of type\ntest.cpp:21:56: warning: right shift count &gt;= width of type\n</code></pre>\n</hr>", "AcceptedAnswerId": "3394302", "Title": "Weird behavior of right shift operator (1 >> 32)", "CreationDate": "2010-08-03T06:59:44.183", "Id": "3394259", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-10-16T12:21:04.407", "LastEditorUserId": "387076", "LastActivityDate": "2017-10-16T12:21:04.407", "Score": "21", "OwnerUserId": "279259", "Tags": "<c++><c><bit-manipulation><bit-shift>", "AnswerCount": "7"}});