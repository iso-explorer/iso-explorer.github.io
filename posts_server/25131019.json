post_cb({"25131019": {"CommentCount": "2", "ViewCount": "1509", "PostTypeId": "1", "LastEditorUserId": "2786156", "CreationDate": "2014-08-05T04:05:53.273", "LastActivityDate": "2014-08-05T18:21:30.740", "Title": "reinterpret_cast to function pointer", "AcceptedAnswerId": "25131113", "LastEditDate": "2014-08-05T04:07:59.827", "Id": "25131019", "Score": "1", "Body": "<p>There is the code that I've written for experiments with <code>reinterpret_cast&lt;T&gt;</code></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nusing std::cout;\nusing std::endl;\n\nint foo()\n{\n    cout &lt;&lt; \"foo\" &lt;&lt; endl;\n    return 0;\n}\n\nvoid (*bar)();\nint main()\n{\n\n    bar = reinterpret_cast&lt;void (*)()&gt;(foo); //Convertion a function type to a pointer to function type\n    bar(); //displays foo. Is it UB?\n}\n</code></pre>\n<p>First of all why such <code>reinterpret_cast</code> convertion permitted? I thought such conversion is ill-formed.</p>\n", "Tags": "<c++><reinterpret-cast>", "OwnerUserId": "2786156", "AnswerCount": "2"}, "25131113": {"ParentId": "25131019", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">The standard</a> (C++11 \u00a75.2.10/6) says</p>\n<blockquote>\n<p id=\"so_25131019_25131113_0\">A pointer to a function can be explicitly converted to a pointer to a function of a different type. The effect of calling a function through a pointer to a function type that is not the same as the type used in the definition of the function is undefined. Except that converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are function types) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>So it is undefined behavior. </p>\n", "OwnerUserId": "1325329", "LastEditorUserId": "464581", "LastEditDate": "2014-08-05T04:30:29.393", "Id": "25131113", "Score": "3", "CreationDate": "2014-08-05T04:16:27.997", "LastActivityDate": "2014-08-05T04:30:29.393"}, "bq_ids": {"n4140": {"so_25131019_25131113_0": {"section_id": 6045, "quality": 0.9333333333333333, "length": 42}}, "n3337": {"so_25131019_25131113_0": {"section_id": 5813, "quality": 0.9333333333333333, "length": 42}}, "n4659": {"so_25131019_25131113_0": {"section_id": 7544, "quality": 0.9333333333333333, "length": 42}}}, "25131183": {"ParentId": "25131019", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Formally calling via the pointer casted to different function type is Undefined Behavior (by C++11 \u00a75.2.10/6).</p>\n<p>In practice you're casting away a function result of type <code>int</code>, that would be returned in a register. So about the worst that can happen when you call via the casted pointer, is that contrary to the compiler's expectations a register has changed value.</p>\n<p>Another practical consideration: C++ does not support casting between function and data pointers, but Posix effectively requires cast to <code>void*</code> and back to work OK. The C++ restriction is presumably in support of Harvard architecture machines, where instructions are not retrieved via the same bus and memory as ordinary data. But the Posix round-trip would presumably work also on such architecture, unless the data address space was much smaller than the instruction address space.</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-08-05T18:21:30.740", "Id": "25131183", "Score": "1", "CreationDate": "2014-08-05T04:24:12.887", "LastActivityDate": "2014-08-05T18:21:30.740"}});