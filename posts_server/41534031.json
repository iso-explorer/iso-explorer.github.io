post_cb({"41538114": {"ParentId": "41534031", "LastEditDate": "2017-01-08T21:35:58.867", "CommentCount": "5", "CreationDate": "2017-01-08T21:30:45.100", "Score": "3", "LastEditorUserId": "1505939", "PostTypeId": "2", "Id": "41538114", "OwnerUserId": "1505939", "Body": "<p>I think the place you are stumbling is actually with the expression <code>c.getObj()</code> in the line <code>return c.getObj();</code>.</p>\n<p>You think the expression <code>c.getObj()</code> has type <code>const Int&amp;</code>.  However that is not true; expressions never have reference type. As noted by Kerrek SB in comments, we sometimes talk about expressions as if they had reference type, as a shortcut to save on verbosity, but that leads to misconceptions so I think it is important to understand what is really going on.</p>\n<p>The use of a reference type in a declaration (including as a return type as in <code>getObj</code>'s declaration) affects how the thing being declared is initialized,  but once it is initialized, there is no longer any evidence that it was originally a reference.  </p>\n<p>Here is a simpler example:</p>\n<pre><code>int a; int &amp;b = a;  // 1\n</code></pre>\n<p>versus</p>\n<pre><code>int b; int &amp;a = b;  // 2\n</code></pre>\n<p>These two codes are exactly identical <sup>(except for the result of <code>decltype(a)</code> or <code>decltype(b)</code> which is a bit of a hack to the system)</sup>.   In both cases the expressions <code>a</code> and <code>b</code> both have type <code>int</code> and value category \"lvalue\" and denote the same object.  It's not the case that <code>a</code> is the \"real object\" and <code>b</code> is some sort of disguised pointer to <code>a</code>.  They are both on equal footing. It's one object with two names.</p>\n<p>Going back to your code now: the expression <code>c.getObj()</code> has exactly the same behaviour as <code>c.m_obj</code>, apart from access rights.   The type is <code>Int</code> and the value category is \"lvalue\".  The <code>&amp;</code> in the return type of <code>getObj()</code> only dictates that this is an lvalue and it will also designate an object that already existed (approximately speaking).</p>\n<p>So the deduced return type from <code>return c.getObj();</code> is the same as it would be for <code>return c.m_obj;</code> , which -- to be compatible with template type deduction, as mentioned elsewhere -- is not a reference type.</p>\n<p>NB. If you understood this post you will also understand why I don't like the pedagogy of \"references\" being taught as \"disguised pointers that auto dereference\", which is somewhere between wrong and dangerous.</p>\n", "LastActivityDate": "2017-01-08T21:35:58.867"}, "41537651": {"ParentId": "41534031", "LastEditDate": "2017-01-08T21:33:04.963", "CommentCount": "10", "CreationDate": "2017-01-08T20:41:47.757", "Score": "3", "LastEditorUserId": "4987285", "PostTypeId": "2", "Id": "41537651", "OwnerUserId": "4987285", "Body": "<p>The <a href=\"http://eel.is/c++draft/expr.prim.lambda#5\" rel=\"nofollow noreferrer\">standard</a> (at least, the working draft) already gives you hints about what's happening and how to solve it:</p>\n<blockquote>\n<p id=\"so_41534031_41537651_0\">The lambda return type is\u00a0<code>auto</code>, which is replaced by the type specified by the\u00a0trailing-return-type\u00a0if provided and/or deduced from\u00a0return\u00a0statements as described in [dcl.spec.auto]. [\u00a0Example:</p>\n</blockquote>\n<pre><code>    auto x1 = [](int i){ return i; }; // OK: return type is int\n    auto x2 = []{ return { 1, 2 }; }; // error: deducing return type from braced-init-list int j;\n    auto x3 = []()-&gt;auto&amp;&amp; { return j; }; // OK: return type is int&amp; \n</code></pre>\n<blockquote>\n<p id=\"so_41534031_41537651_1\">\u2014 end example\u00a0]</p>\n</blockquote>\n<p>Consider now the following template function:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T t) {}\n\n// ....\n\nint x = 42;\nf(x);\n</code></pre>\n<p>What's <code>t</code> in <code>f</code>, a copy of <code>x</code> or a reference to it?<br>\nWhat happens if we change the function as it follows?</br></p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T &amp;t) {}\n</code></pre>\n<p>The same applies more or less to the deduced return type of a lambda: if you want a reference, you must be explicit about that.  </p>\n<blockquote>\n<p id=\"so_41534031_41537651_2\">Why was this decision made? It seems to me like a gotcha to remove a reference when that's what your return statement returns.</p>\n</blockquote>\n<p>The choice is consistent with how templates work since the beginning.<br>\nI would be surprised of the opposite instead.<br>\nReturn type is deduced as well as the template parameter and it's a pretty good decision not to define different set of rules for them (at least from my point of view).  </br></br></p>\n<hr>\n<p>That said, to solve your problem you have several alternatives:</p>\n<ol>\n<li><pre><code>[&amp;c]()-&gt;auto&amp;&amp;{ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>[&amp;c]()-&gt;auto&amp;{ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>[&amp;c]()-&gt;decltype(c.getObj())&amp;{ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>[&amp;c]()-&gt;decltype(c.getObj())&amp;&amp;{ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>[&amp;c]()-&gt;decltype(auto){ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>[&amp;c]()-&gt;const Int &amp;{ return c.getObj(); }\n</code></pre></li>\n<li><pre><code>...\n</code></pre></li>\n</ol>\n<p>Some of them are crazy, some of them are quite clear, all of them should work.<br>\nIf the intended behavior is to return a reference, probably to be explicit about that is the best choice:</br></p>\n<pre><code>[&amp;c]()-&gt;auto&amp;{ return c.getObj(); }\n</code></pre>\n<p>Anyway, this is mostly opinion-based, so feel free to pick your preferred alternative up and use it.</p>\n<hr>\n<blockquote>\n<p id=\"so_41534031_41537651_3\">Interestingly, even if the\u00a0auto\u00a0return type deduction makes sense, isn't it a bug that\u00a0std::function\u00a0gets happily initialized with a function that returns a non-reference?</p>\n</blockquote>\n<p>Let's consider the code below (no reason to call in a <code>std::function</code> right now):</p>\n<pre><code>int f() { return 0; }\nconst int &amp; g() { return f(); }\nint main() { const int &amp;x = g(); }\n</code></pre>\n<p>It gives you a few warnings but it compiles.<br>\nThe reason is that a temporary is created from an rvalue and a temporary can bind to a const reference, so I'd say it's <em>legal</em> from the point of view of the standard.<br>\nThe fact that it will explode at runtime is another problem.</br></br></p>\n<p>Something similar happens when using a <code>std:: function</code>.<br>\nAnyway it's an abstraction over a generic callable object, so do not expect the same warnings.</br></p>\n</hr></hr>", "LastActivityDate": "2017-01-08T21:33:04.963"}, "41534031": {"CommentCount": "16", "ViewCount": "352", "PostTypeId": "1", "LastEditorUserId": "4115625", "CreationDate": "2017-01-08T14:56:55.013", "LastActivityDate": "2017-01-08T21:35:58.867", "Title": "Why do lambda functions drop deduced return type reference by default?", "AcceptedAnswerId": "41538114", "LastEditDate": "2017-01-08T17:47:38.313", "Id": "41534031", "Score": "2", "Body": "<p>In C++14, why do lambda functions with a deduced return type drop references from the return type by default? IIUC, since C++14 lambda functions with a deduced return type (without an explicit trailing return type) have a return type of <code>auto</code>, which drops references (among other things).</p>\n<p>Why was this decision made? It seems to me like a gotcha to remove a reference when that's what your return statement returns.</p>\n<p>This behavior caused the following nasty bug for me:</p>\n<pre><code>class Int {\npublic:\n   Int(int i) : m_int{i} {}\n   int m_int;\n};\n\nclass C {\npublic:\n    C(Int obj) : m_obj{obj} {}\n    const auto&amp; getObj() { return m_obj; }\n    Int m_obj;\n};\n\nclass D {\npublic:\n    D(std::function&lt;const Int&amp;()&gt; f) : m_f{f} {}\n    std::function&lt;const Int&amp;()&gt; m_f;\n};\n\nInt myint{5};\nC c{myint};\nD d{ [&amp;c](){ return c.getObj(); } } // The deduced return type of the lambda is Int (with no reference)\nconst Int&amp; myref = d.m_f(); // Instead of referencing myint, myref is a dangling reference; d.m_f() returned a copy of myint, which is subsequently destroyed.\n</code></pre>\n<p>Specifying the desired return type when initializing <code>d</code> resolves the issue:</p>\n<pre><code>D d{ [&amp;c]() -&gt; const Int&amp; { return c.getObj(); } }\n</code></pre>\n<p>Interestingly, even if the <code>auto</code> return type deduction makes sense, isn't it a bug that <code>std::function&lt;const Int&amp;&gt;</code> gets happily initialized with a function that returns a non-reference? I see this also by writing explicitly:</p>\n<pre><code>D d{ [&amp;c]() -&gt; Int { return c.getObj(); } }\n</code></pre>\n<p>which compiles without a problem. (on <code>Xcode 8</code>, <code>clang 8.0.0</code>)</p>\n", "Tags": "<c++><lambda><clang><c++14><auto>", "OwnerUserId": "125997", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41534031_41537651_0": {"section_id": 5963, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_41534031_41537651_0": {"section_id": 7450, "quality": 0.8235294117647058, "length": 14}}}});