post_cb({"15604573": {"Id": "15604573", "PostTypeId": "2", "Body": "<h3>The Memory Model</h3>\n<p>The C++ standard has a <em>memory model</em>. It attempts to model the memory in a computer system in a generic way. The standard defines that a byte is a storage unit in the memory model and that memory is made up of bytes (\u00a71.7):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_0\">The fundamental storage unit in the C++ memory model is the byte. [...] The memory available to a C++ program consists of one or more sequences of contiguous bytes.</p>\n</blockquote>\n<h3>The Object Model</h3>\n<p>The standard always provides an <em>object model</em>. This specifies that an object is a region of storage (so it is made up of bytes and resides in memory) (\u00a71.8):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_1\">The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a region of storage.</p>\n</blockquote>\n<p>So there we go. Memory is where objects are stored. To store an object in memory, the required region of storage must be allocated.</p>\n<h3>Allocation and Deallocation Functions</h3>\n<p>The standard provides two implicitly declared global scope allocation functions:</p>\n<pre><code>void* operator new(std::size_t);\nvoid* operator new[](std::size_t);\n</code></pre>\n<p>How these are implemented is not the standard's concern. All that matters is that they should return a pointer to some region of storage with the number of bytes corresponding to the argument passed (\u00a73.7.4.1): </p>\n<blockquote>\n<p id=\"so_15604411_15604573_2\">The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size. There are no constraints on the contents of the allocated storage on return from the allocation function.</p>\n</blockquote>\n<p>It also defines two corresponding deallocation functions:</p>\n<pre><code>void operator delete(void*);\nvoid operator delete[](void*);\n</code></pre>\n<p>Which are defined to deallocate storage that has previously been allocated (\u00a73.7.4.2):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_3\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid all pointers referring to any part of the deallocated storage.</p>\n</blockquote>\n<h3><code>new</code> and <code>delete</code></h3>\n<p>Typically, you should not need to use the allocation and deallocation functions directly because they only give you uninitialised memory. Instead, in C++ you should be using <code>new</code> and <code>delete</code> to dynamically allocate objects. A <em>new-expression</em> obtains storage for the requested type by using one of the above allocation functions and then initialises that object in some way. For example <code>new int()</code> will allocate space for an <code>int</code> object and then initialise it to 0. See \u00a75.3.4:</p>\n<blockquote>\n<p id=\"so_15604411_15604573_4\">A new-expression obtains storage for the object by calling an allocation function (3.7.4.1).</p>\n<p id=\"so_15604411_15604573_5\">[...]</p>\n<p id=\"so_15604411_15604573_6\">A <em>new-expression</em> that creates an object of type T initializes that object [...]</p>\n</blockquote>\n<p>In the opposite direction, <code>delete</code> will call the destructor of an object (if any) and then deallocate the storage (\u00a75.3.5):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_7\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will invoke the destructor (if any) for the object or the elements of the array being deleted.</p>\n<p id=\"so_15604411_15604573_8\">[...]</p>\n<p id=\"so_15604411_15604573_9\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will call a deallocation function (3.7.4.2).</p>\n</blockquote>\n<h3>Other Allocations</h3>\n<p>However, these are not the only ways that storage is allocated or deallocated. Many constructs of the language implicitly require allocation of storage. For example, giving an object definition, like <code>int a;</code>, also requires storage (\u00a77):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_10\">A definition causes the appropriate amount of storage to be reserved and any appropriate initialization (8.5) to be done.</p>\n</blockquote>\n<h3>C standard library: <code>malloc</code> and <code>free</code></h3>\n<p>In addition, the <code>&lt;cstdlib&gt;</code> header brings in the contents of the <code>stdlib.h</code> C standard library, which includes the <code>malloc</code> and <code>free</code> functions. They are also defined, by the C standard, to allocate and deallocate memory, much like the allocation and deallocation functions defined by the C++ standard. Here's the definition of <code>malloc</code> (C99 \u00a77.20.3.3):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_11\"><code>void *malloc(size_t size);</code><br>\n<strong>Description</strong><br>\n  The <code>malloc</code> function allocates space for an object whose size is specified by <code>size</code> and\n  whose value is indeterminate.<br>\n<strong>Returns</strong><br>\n  The <code>malloc</code> function returns either a null pointer or a pointer to the allocated space.</br></br></br></br></p>\n</blockquote>\n<p>And the definition of <code>free</code> (C99 \u00a77.20.3.2):</p>\n<blockquote>\n<p id=\"so_15604411_15604573_12\"><code>void free(void *ptr);</code><br>\n<strong>Description</strong><br>\n  The <code>free</code> function causes the space pointed to by <code>ptr</code> to be deallocated, that is, made\n  available for further allocation. If <code>ptr</code> is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the <code>calloc</code>, <code>malloc</code>, or <code>realloc</code> function, or if the space has been deallocated by a call to <code>free</code> or <code>realloc</code>,\n  the behavior is undefined.</br></br></p>\n</blockquote>\n<p>However, there's never a good excuse to be using <code>malloc</code> and <code>free</code> in C++. As described before, C++ has its own alternatives.</p>\n<hr>\n<h3>Answers to Questions</h3>\n<p>So to answer your questions directly:</p>\n<ol>\n<li><p>Where is the \"memory\" that is being allocated? </p>\n<p>The C++ standard doesn't care. It simply says that the program has some memory which is made up of bytes. This memory can be allocated.</p></li>\n<li><p>What is this \"memory\"? Space in an array? Or something else? </p>\n<p>As far as the standard is concerned, the memory is just a sequence of bytes. This is purposefully very generic, as the standard only tries to <em>model</em> typical computer systems. You can, for the most part, think of it as a model of the RAM of your computer.</p></li>\n<li><p>What happens exactly when this \"memory\" gets allocated? </p>\n<p>Allocating memory makes some region of storage available for use by the program. Objects are initialized in allocated memory. All you need to know is that you can allocate memory. The actual allocation of physical memory to your process tends to be done by the operating system.</p></li>\n<li><p>What happens exactly when the memory gets deallocated? </p>\n<p>Deallocating some previously allocated memory causes that memory to be unavailable to the program. It becomes deallocated storage.</p></li>\n<li><p>It would also really help me if someone could answer what malloc does in these C++ lines:</p>\n<pre><code>char* x; \nx = (char*) malloc (8);\n</code></pre>\n<p>Here, <code>malloc</code> is simply allocating 8 bytes of memory. The pointer it returns is being cast to a <code>char*</code> and stored in <code>x</code>.</p></li>\n</ol>\n</hr>", "LastEditorUserId": "150634", "LastActivityDate": "2013-03-24T22:35:53.513", "Score": "51", "CreationDate": "2013-03-24T22:03:24.057", "ParentId": "15604411", "CommentCount": "4", "OwnerUserId": "150634", "LastEditDate": "2013-03-24T22:35:53.513"}, "15604541": {"Id": "15604541", "PostTypeId": "2", "Body": "<p>To allocate memory means to ask the operating system for memory. It means that it is the program itself to ask for \"space\" in RAM when only when it needs it. For example if you want to use an array but you don't know its size before the program runs, you can do two things:\n- declare and array[x] with x dediced by you, arbitrary long. For example 100. But what about if your program just needs an array of 20 elements? You are wasting memory for nothing.\n- then you program can malloc an array of x elements just when it knows the correct size of x.\nPrograms in memory are divided in 4 segments:\n-stack (needed for call to functions)\n-code (the bibary executable code)\n- data (global variables/data)\n- heap, in this segment you find the allocated memory.\nWhen you decide you don't need the allocated memory anymore, you give it back to the operating system.</p>\n<p>If you want to alloc and array of 10 integers, you do:</p>\n<p>int *array = (int *)malloc(sizeof(int) * 10)</p>\n<p>And then you give it back to the os with\nfree(array)</p>\n", "LastActivityDate": "2013-03-24T21:59:59.103", "CommentCount": "0", "CreationDate": "2013-03-24T21:59:59.103", "ParentId": "15604411", "Score": "3", "OwnerUserId": "2204592"}, "15604411": {"ViewCount": "56043", "Body": "<p>I have been looking at memory allocation lately and I am a bit confused about the basics. I haven't been able to wrap my head around the simple stuff. What does it mean to allocate memory? What happens? I would appreciated answers to any of these questions:\n<br><br/></br></p>\n<ol>\n<li>Where is the \"memory\" that is being allocated? <br/></li>\n<li>What is this \"memory\"? Space in an array? Or something else? <br/></li>\n<li>What happens exactly when this \"memory\" gets allocated? <br/></li>\n<li>What happens exactly when the memory gets deallocated? <br/></li>\n<li><p>It would also really help me if someone could answer what malloc does in these C++ lines:</p>\n<pre><code>char* x; \nx = (char*) malloc (8);\n</code></pre></li>\n</ol>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "15604573", "Title": "Memory Allocation/Deallocation?", "CreationDate": "2013-03-24T21:45:43.013", "Id": "15604411", "CommentCount": "3", "FavoriteCount": "20", "PostTypeId": "1", "LastEditDate": "2015-03-16T14:28:42.417", "LastEditorUserId": "1945948", "LastActivityDate": "2015-03-16T14:28:42.417", "ClosedDate": "2013-03-25T12:53:03.063", "Score": "30", "OwnerUserId": "2052564", "Tags": "<c++><memory><allocation><memory-management>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_15604411_15604573_4": {"length": 6, "quality": 0.75, "section_id": 6089}, "so_15604411_15604573_7": {"length": 15, "quality": 1.0, "section_id": 6110}, "so_15604411_15604573_0": {"length": 14, "quality": 0.875, "section_id": 5785}, "so_15604411_15604573_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5790}, "so_15604411_15604573_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 7183}, "so_15604411_15604573_10": {"length": 9, "quality": 1.0, "section_id": 5386}, "so_15604411_15604573_9": {"length": 11, "quality": 0.9166666666666666, "section_id": 6111}, "so_15604411_15604573_6": {"length": 6, "quality": 1.0, "section_id": 6098}, "so_15604411_15604573_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 7177}}, "n3337": {"so_15604411_15604573_4": {"length": 7, "quality": 0.875, "section_id": 5857}, "so_15604411_15604573_7": {"length": 15, "quality": 1.0, "section_id": 5876}, "so_15604411_15604573_0": {"length": 14, "quality": 0.875, "section_id": 5558}, "so_15604411_15604573_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5563}, "so_15604411_15604573_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 6927}, "so_15604411_15604573_10": {"length": 9, "quality": 1.0, "section_id": 5180}, "so_15604411_15604573_9": {"length": 11, "quality": 0.9166666666666666, "section_id": 5877}, "so_15604411_15604573_6": {"length": 6, "quality": 1.0, "section_id": 5864}, "so_15604411_15604573_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 6921}}, "n4659": {"so_15604411_15604573_4": {"length": 6, "quality": 0.75, "section_id": 7585}, "so_15604411_15604573_7": {"length": 15, "quality": 1.0, "section_id": 7607}, "so_15604411_15604573_0": {"length": 14, "quality": 0.875, "section_id": 7242}, "so_15604411_15604573_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7247}, "so_15604411_15604573_3": {"length": 16, "quality": 0.6666666666666666, "section_id": 8691}, "so_15604411_15604573_10": {"length": 9, "quality": 1.0, "section_id": 6811}, "so_15604411_15604573_9": {"length": 11, "quality": 0.9166666666666666, "section_id": 7608}, "so_15604411_15604573_6": {"length": 6, "quality": 1.0, "section_id": 7595}, "so_15604411_15604573_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 8685}}}, "15604841": {"Id": "15604841", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15604411_15604841_0\">1 . Where is the \"memory\" that is being allocated?</p>\n</blockquote>\n<p>From a language perspective, this isn't specified, and mostly because the fine details often don't matter. Also, the <code>C++</code> standard tends to err on the side of under-specifying hardware details, to minimise unnecessary restrictions (both on the platforms compilers can run on, and on possible optimisations).</p>\n<p>sftrabbit's answer gives a great overview of this end of things (and it's all you really need), but I can give a couple of worked examples in case that helps.</p>\n<h2>Example 1:</h2>\n<p>On a sufficiently old single-user computer (or a sufficiently small embedded one), most of the physical RAM may be directly available to your program. In this scenario, calling <code>malloc</code> or <code>new</code> is essentially internal book-keeping, allowing the runtime library to track which chunks of that RAM are currently in use. You can do this manually, but it gets tedious pretty quickly.</p>\n<h2>Example 2:</h2>\n<p>On a modern multitasking operating system, the physical RAM is shared with many processes and other tasks including kernel threads. It's also used for disk caching and I/O buffering in the background, and is augmented by the virtual memory subsystem which can swap data to disk (or some other storage device) when they're not being used.</p>\n<p>In this scenario, calling <code>new</code> may first check whether your process already has enough space free internally, and request more from the OS if not. Whatever memory is returned may be physical, or it may be virtual (in which case physical RAM may not be assigned to store it until it's actually accessed). You can't even tell the difference, at least without using platform-specific APIs, because the memory hardware and kernel conspire to hide it from you.</p>\n<blockquote>\n<p id=\"so_15604411_15604841_1\">2 . What is this \"memory\"? Space in an array? Or something else?</p>\n</blockquote>\n<p>In example 1, it's something like space in an array: the address returned identifies an addressable chunk of physical RAM. Even here, RAM addresses aren't necessarily flat or contiguous - some addresses may be reserved for ROM, or for I/O ports.</p>\n<p>In example 2, it's an index into something more virtual: your process' address space. This is an abstraction used to hide the underlying virtual memory details from your process. When you access this address, the memory hardware may directly access some real RAM, or it might need to ask the virtual memory subsystem to provide some.</p>\n<blockquote>\n<p id=\"so_15604411_15604841_2\">3 . What happens exactly when this \"memory\" gets allocated?</p>\n</blockquote>\n<p>In general, a pointer is returned which you can use to store as many bytes as you asked for. In both cases, <code>malloc</code> or the <code>new</code> operator will do some housekeeping to track which parts of your process' address space are used and which are free.</p>\n<blockquote>\n<p id=\"so_15604411_15604841_3\">4 . What happens exactly when the memory gets deallocated? </p>\n</blockquote>\n<p>Again in general, <code>free</code> or <code>delete</code> will do some housekeeping so they know that memory is available to be re-allocated.</p>\n<blockquote>\n<p id=\"so_15604411_15604841_4\">It would also really help me if someone could answer what malloc does in these C++ lines:</p>\n</blockquote>\n<pre><code>char* x; \nx = (char*) malloc (8);\n</code></pre>\n<p>It returns a pointer which is either <code>NULL</code> (if it couldn't find the 8 bytes you want), or some non-NULL value.</p>\n<p>The only things you can usefully say about this non-NULL value are that:</p>\n<ul>\n<li>it's legal (and safe) to access each of those 8 bytes <code>x[0]..x[7]</code>,</li>\n<li>it's illegal (undefined behaviour) to access <code>x[-1]</code> or <code>x[8]</code> or actually <em>any</em> <code>x[i]</code> unless <code>0 &lt;= i &lt;= 7</code></li>\n<li>it's legal to <em>compare</em> any of <code>x, x+1, ..., x+8</code> (although you can't <em>dereference</em> the last of those)</li>\n<li>if your platform/hardware/whatever have any restrictions on where you can store data in memory, then <code>x</code> meets them</li>\n</ul>\n", "LastActivityDate": "2013-03-24T22:31:36.163", "CommentCount": "1", "CreationDate": "2013-03-24T22:31:36.163", "ParentId": "15604411", "Score": "7", "OwnerUserId": "212858"}, "15604606": {"Id": "15604606", "PostTypeId": "2", "Body": "<p><strong>1) Where is the \"memory\" that is being allocated?</strong></p>\n<p>This is completely different based on your operating system, programming environment (gcc vs Visual C++ vs Borland C++ vs anything else), computer, available memory, etc. In general, memory is allocated from what is called the heap, region of memory just waiting around for you to use. It will generally use your available RAM. But there are always exceptions. For the most part, so long as it gives us memory, where it comes from isn't a great concern. There are special types of memory, such as virtual memory, which may or may not actually be in RAM at any given time and may get moved off to your hard drive (or similar storage device) if you run out of real memory. A full explanation would be very long!</p>\n<p><strong>2) What is this \"memory\"? Space in an array? Or something else?</strong></p>\n<p>Memory is generally the RAM in your computer. If it is helpful to think of memory as a gigantic \"array\", it certain operates like one, then think of it as a ton of bytes (8 bit values, much like <code>unsigned char</code> values). It starts at an index of 0 at the bottom of memory. Just like before, though, there are tons of exceptions here and some parts of memory may be mapped to hardware, or may not even exist at all!</p>\n<p><strong>3) What happens exactly when this \"memory\" gets allocated?</strong></p>\n<p>At any given time there should be (we really hope!) some of it available for software to allocate. How it gets allocated is highly system dependent. In general, a region of memory is allocated, the allocator marks it as used, and then a pointer is given to you to use that tells the program where in all of your system's memory that memory is located. In your example, the program will find a consecutive block of 8 bytes (char) and return a pointer to where it found that block after it marks it as \"in use\".</p>\n<p><strong>4) What happens exactly when the memory gets deallocated?</strong></p>\n<p>The system marks that memory as available for use again. This is incredibly complicated because this will often cause holes in memory. Allocate 8 bytes then 8 more bytes, then deallocate the first 8 bytes and you've got a hole. There are entire books written on handling deallocation, memory allocation, etc. So hopefully the short answer will be sufficient!</p>\n<p><strong>5) It would also really help me if someone could answer what malloc does in these C++ lines:</strong></p>\n<p>REALLY crudely, and assuming it's in a function (by the way, never do this because it doesn't deallocate your memory and causes a memory leak):</p>\n<pre><code>void mysample() {\n  char *x; // 1\n  x = (char *) malloc(8); // 2\n}\n</code></pre>\n<p>1) This is a pointer reserved in the local stack space. It has not be initialized so it points to whatever that bit of memory had in it.</p>\n<p>2) It calls malloc with a parameter of 8. The cast just let's C/C++ know you intend for it to be a (char *) because it returns a (void *) meaning it has no type applied. Then the resulting pointer is stored in your x variable.</p>\n<p>In very crude x86 32bit assembly, this will look vaguely like</p>\n<pre><code>PROC mysample:\n  ; char *x;\n  x = DWord Ptr [ebp - 4]\n  enter 4, 0   ; Enter and preserve 4 bytes for use with \n\n  ; x = (char *) malloc(8);\n  push 8       ; We're using 8 for Malloc\n  call malloc  ; Call malloc to do it's thing\n  sub esp, 4   ; Correct the stack\n  mov x, eax   ; Store the return value, which is in EAX, into x\n\n  leave\n  ret\n</code></pre>\n<p>The actual allocation is vaguely described in point 3. Malloc usually just calls a system function for this that handles all the rest, and like everything else here, it's wildly different from OS to OS, system to system, etc.</p>\n", "LastActivityDate": "2013-03-24T22:07:15.030", "CommentCount": "4", "CreationDate": "2013-03-24T22:07:15.030", "ParentId": "15604411", "Score": "11", "OwnerUserId": "1631871"}});