post_cb({"6547589": {"ParentId": "6546470", "CommentCount": "6", "CreationDate": "2011-07-01T11:51:27.430", "OwnerUserId": "201725", "PostTypeId": "2", "Id": "6547589", "Score": "6", "Body": "<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm\" rel=\"noreferrer\">N2672</a> the paragraph 8.5.4.4 should say:</p>\n<blockquote>\n<p id=\"so_6546470_6547589_0\">Otherwise, if T is a reference type, an rvalue temporary of the type referenced by T is list-initialized, and the reference is bound to that temporary. [ Note: As usual, the binding will fail and the program is ill-formed if the reference type is an lvalue reference to a non-const type. ]</p>\n</blockquote>\n<p>which (if I understand it correctly) means uniform initialization of references binds them to new anonymous instances, so it seems to me it's pretty useless. That still does not explain why one works and the other does not; they should behave the same (unless <code>Y</code> has some explicit constructors).</p>\n", "LastActivityDate": "2011-07-01T11:51:27.430"}, "bq_ids": {"n4140": {"so_6546470_6547589_0": {"section_id": 3325, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_6546470_6547589_0": {"section_id": 3195, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_6546470_6547589_0": {"section_id": 4091, "quality": 0.6956521739130435, "length": 16}}}, "6546470": {"CommentCount": "7", "AcceptedAnswerId": "6547589", "PostTypeId": "1", "LastEditorUserId": "436853", "CreationDate": "2011-07-01T10:01:13.140", "LastActivityDate": "2011-07-01T13:18:49.420", "LastEditDate": "2011-07-01T13:18:49.420", "ViewCount": "1604", "FavoriteCount": "5", "Title": "Uniform initialization of references", "Id": "6546470", "Score": "18", "Body": "<p>I am currently trying to understand the new uniform initialization of C++0x. Unfortunately, I stumpled over using uniform initialization of references. Example:</p>\n<pre><code>int main() {\n   int a;\n   int &amp;ref{a};\n}\n</code></pre>\n<p>This example works fine:</p>\n<pre><code>% LANG=C g++ uniform_init_of_ref.cpp -std=c++0x -o uni -Wall -Wextra\nuniform_init_of_ref.cpp: In function `int main()':\nuniform_init_of_ref.cpp:3:10: warning: unused variable `ref' [-Wunused-variable]\n</code></pre>\n<p>(<strong>Update</strong> Comeau throws an error for that example, so maybe gcc shouldn't compile it as well)</p>\n<p>Now, if I use a custom data type instead of an integer, it doesn't work anymore:</p>\n<pre><code>class Y\n{};\n\nint main()\n{\n    Y y;\n    Y &amp;ref{y};\n}\n\n% LANG=C g++ initialization.cpp -std=c++0x -o initialization -Wall -Wextra\ninitialization.cpp: In function `int main()':\ninitialization.cpp:9:13: error: invalid initialization of non-const reference of type `Y&amp;' from an rvalue of type `&lt;brace-enclosed initializer list&gt;'\ninitialization.cpp:9:8: warning: unused variable `ref' [-Wunused-variable]\n</code></pre>\n<p>Unfortunately, I didn't find the relevant section in the standard draft. My guess is that I am misunderstanding the usage of uniform initialization, as Comeau complains with this message:</p>\n<pre><code>ComeauTest.c(9): error: reference variable \"ref\" requires an initializer\n      Y &amp;ref{y};\n</code></pre>\n<p><strong>So, can someone of you point me in the right direction?</strong></p>\n<hr>\n<p>In case that you want to know why this question is relevant and why I don't just use <code>Y &amp;ref(y)</code>: I'd like to be able to use uniform initialization in the initialization list of a constructor:</p>\n<pre><code>class X { };\n\nclass Y {\n    const X&amp; x;\n\n    public:\n        Y (const X&amp; xx):\n            x{xx}\n        {}\n};\n\nint main () {\n    X x;\n    Y y{x};\n}\n</code></pre>\n<p>This fails with the same error message as above.</p>\n<p>Note: </p>\n<ul>\n<li>I am using <code>LANG=C</code> to enable english error messages.</li>\n<li>gcc version: 4.6.1</li>\n</ul>\n</hr>", "Tags": "<c++><c++11><g++><reference><uniform-initialization>", "OwnerUserId": "436853", "AnswerCount": "1"}});