post_cb({"38934879": {"CommentCount": "10", "CreationDate": "2016-08-13T16:44:31.507", "PostTypeId": "1", "AcceptedAnswerId": "38935340", "LastEditorUserId": "434551", "LastActivityDate": "2016-08-13T17:59:08.677", "LastEditDate": "2016-08-13T17:04:06.777", "ViewCount": "245", "FavoriteCount": "2", "Title": "Why am I able to assign a function reference to an anonymous function pointer variable?", "Id": "38934879", "Score": "19", "Body": "<p>The following code compiles just fine and I'm not sure why. Can someone please explain to me why this is legal? </p>\n<p>I am using g++ (Debian 6.1.1-10) 6.1.1 20160724 to compile.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint sum(int x, int y) { return x + y; }\n\nint main(int argc, char *argv[])\n{\n    using std::cout;\n\n    int (*) (int, int) = &amp;sum;\n    cout &lt;&lt; \"what\" &lt;&lt; '\\n';\n}\n</code></pre>\n<p><strong>Addendum</strong></p>\n<p>The following program compiles fine using g++ version 5.4.0 but fails to compile in gcc.</p>\n<pre><code>int main()\n{\n    int (*) = 20;\n}\n</code></pre>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "6713024", "AnswerCount": "1"}, "38935340": {"ParentId": "38934879", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's very likely to be related to <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68265\" rel=\"noreferrer\">this bug</a> reported by Zack Weinberg:</p>\n<blockquote>\n<h3>Bug 68265 - Arbitrary syntactic nonsense silently accepted after 'int (*){}' until the next close brace</h3>\n<p id=\"so_38934879_38935340_0\">(From <a href=\"https://stackoverflow.com/questions/33614455/\">Why does this invalid-looking code compile successfully on g++ 6.0?</a> :)</p>\n<p id=\"so_38934879_38935340_1\">The C++ compiler fails to diagnose ill-formed constructs such as</p>\n<pre><code>  int main()\n  {\n      int (*) {}\n         any amount of syntactic nonsense\n         on multiple lines, with *punctuation* and ++operators++ even...\n         will be silently discarded\n         until the next close brace\n  }\n</code></pre>\n<p id=\"so_38934879_38935340_2\">With -pedantic -std=c++98 you do get \"warning: extended initializer\n  lists only available with -std=c++11 or -std=gnu++11\", but with\n  -std=c++11, not a peep.</p>\n<p id=\"so_38934879_38935340_3\">If any one (or more) of the tokens 'int ( * ) { }' are removed, you do\n  get an error.  Also, the C compiler does not have the same bug.</p>\n</blockquote>\n<p>Of course, if you try <code>int (*) (int, int) {}</code> or other variants, it erroneously compiles. The interesting thing is that the difference between this and the previous duplicate/bug reports is that <code>int (*) (int, int) = asdf</code> requires <code>asdf</code> to be a name in scope. But I highly doubt that the bugs are different in nature, since the core issue is that GCC is allowing you to omit a <em>declarator-id</em>.</p>\n<blockquote>\n<p id=\"so_38934879_38935340_4\">[n4567 \u00a77/8]: \"Each <em>init-declarator</em> in the <em>init-declarator-list</em>\n  contains exactly one <em>declarator-id</em>, which is the name declared by\n  that <em>init-declarator</em> and hence one of the names declared by the\n  declaration.\"</p>\n</blockquote>\n<p>Here's an oddity:</p>\n<pre><code>int (*) (int, int) = main;\n</code></pre>\n<p>In this specific scenario, GCC doesn't complain about taking the address of main (like arrays, <code>&amp;main</code> is equivalent to <code>main</code>).</p>\n", "OwnerUserId": "6292850", "LastEditorUserId": "6292850", "LastEditDate": "2016-08-13T17:59:08.677", "Id": "38935340", "Score": "10", "CreationDate": "2016-08-13T17:35:52.037", "LastActivityDate": "2016-08-13T17:59:08.677"}, "bq_ids": {"n4140": {"so_38934879_38935340_4": {"section_id": 5384, "quality": 0.9375, "length": 15}}, "n3337": {"so_38934879_38935340_4": {"section_id": 5178, "quality": 0.9375, "length": 15}}, "n4659": {"so_38934879_38935340_4": {"section_id": 6809, "quality": 0.9375, "length": 15}}}});