post_cb({"32587320": {"ParentId": "32586871", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-09-15T13:25:41.070", "Score": "3", "LastEditorUserId": "2069064", "LastEditDate": "2015-09-15T13:40:13.097", "Id": "32587320", "OwnerUserId": "2069064", "Body": "<p>The rule of thumb here is that the <code>initializer_list&lt;X&gt;</code> overloads are <strong>strongly preferred</strong> to other overloads. </p>\n<p>First, from [over.ics.list]</p>\n<blockquote>\n<p id=\"so_32586871_32587320_0\">if the parameter type is <code>std::initializer_list&lt;X&gt;</code> and all the elements of the initializer list can\n  be implicitly converted to <code>X</code>, the implicit conversion sequence is the worst conversion necessary to convert an\n  element of the list to <code>X</code>, or if the initializer list has no elements, the identity conversion. This conversion can\n  be a user-defined conversion even in the context of a call to an initializer-list constructor.  </p>\n</blockquote>\n<p>And, from [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_32586871_32587320_1\">List-initialization sequence L1 is a better conversion sequence than list-initialization sequence L2 if<br>\n  \u2014 L1 converts to <code>std::initializer_list&lt;X&gt;</code> for some <code>X</code> and L2 does not [...]</br></p>\n</blockquote>\n<p>We have two relevant overloads of <a href=\"http://en.cppreference.com/w/cpp/container/set/insert\" rel=\"nofollow\"><code>std::set::insert</code></a>:</p>\n<pre><code>std::pair&lt;iterator,bool&gt; insert( value_type&amp;&amp; value );\nvoid insert( std::initializer_list&lt;value_type&gt; ilist );\n</code></pre>\n<p>For the first call:</p>\n<pre><code>s1.insert({1, 2});\n</code></pre>\n<p>Consider the overload with parameter type <code>std::initializer_list&lt;D1&gt;</code>. Neither <code>1</code> nor <code>2</code> can be implicitly converted to <code>D1</code>, so that overload is not viable. Now consider the <code>D1&amp;&amp;</code> overload. Since we can construct a <code>D1</code> with that initializer list, that's the overload that's selected, and we end up with a single element: <code>D1{1, 2}</code>.</p>\n<p>However, in this case:</p>\n<pre><code>s2.insert({1, 2});\n</code></pre>\n<p>Both <code>1</code> and <code>2</code> <em>can</em> be implicitly converted to <code>D2</code>, thanks to the default argument in <code>D2</code>'s constructor. So the <code>initializer_list&lt;D2&gt;</code> overload is viable. The <code>D2&amp;&amp;</code> overload is viable as well, but the <code>initializer_list</code> conversion sequence is a better conversion sequence, so it's preferred. This gives us <em>two</em> elements, <code>D2{1}</code> and <code>D2{2}</code>.</p>\n", "LastActivityDate": "2015-09-15T13:40:13.097"}, "32586871": {"CommentCount": "0", "AcceptedAnswerId": "32587320", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-09-15T13:04:28.993", "LastActivityDate": "2015-09-15T13:40:13.097", "LastEditDate": "2015-09-15T13:27:44.250", "ViewCount": "270", "FavoriteCount": "2", "Title": "std::set insert with initialiser lists", "Id": "32586871", "Score": "7", "Body": "<p>I have this simple code:</p>\n<pre><code>struct Base\n{\n    Base(int xx, int yy) : x(xx), y(yy){}\n    bool operator&lt;(const Base&amp; b) const {return (x &lt; b.x) || (x==b.x &amp;&amp; y &lt; b.y);}\n\n    int x;\n    int y;\n};\n\nstruct D1 : Base\n{\n    D1(int x, int y) : Base(x, y){}\n};\n\nstruct D2 : Base\n{\n    D2(int x = 0, int y = 0) : Base(x, y){}\n};\n\nvoid test()\n{\n    std::set&lt;D1&gt; s1;\n    std::set&lt;D2&gt; s2;\n\n    s1.insert({1, 2});\n    s2.insert({1, 2});\n\n    std::cout&lt;&lt;\"s1 size:\"&lt;&lt;s1.size()&lt;&lt;std::endl&lt;&lt;\"Content:\"&lt;&lt;std::endl;\n    for(auto&amp; v : s1)\n    {\n        std::cout&lt;&lt;v.x&lt;&lt;\" \"&lt;&lt;v.y&lt;&lt;std::endl;\n    }\n\n    std::cout&lt;&lt;std::endl&lt;&lt;\"s2 size:\"&lt;&lt;s2.size()&lt;&lt;std::endl&lt;&lt;\"Content:\"&lt;&lt;std::endl;\n    for(auto&amp; v : s2)\n    {\n        std::cout&lt;&lt;v.x&lt;&lt;\" \"&lt;&lt;v.y&lt;&lt;std::endl;\n    }\n}\n</code></pre>\n<p>With the output:</p>\n<pre><code>s1 size:1\nContent: \n1 2\n\ns2 size:2\nContent:\n1 0\n2 0\n</code></pre>\n<p>Why is the behaviour different when inserting objects with default arguments? Is this a bug or is it the intended behaviour?</p>\n<p>PS: You can see the code in action here: <a href=\"https://ideone.com/UPArOi\" rel=\"noreferrer\">https://ideone.com/UPArOi</a></p>\n", "Tags": "<c++><c++11><overload-resolution>", "OwnerUserId": "336578", "AnswerCount": "2"}, "32586994": {"ParentId": "32586871", "CommentCount": "0", "CreationDate": "2015-09-15T13:10:04.243", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "32586994", "Score": "1", "Body": "<p>This is standard behavior.  It's because you're using an <code>initialization list</code> to <code>insert</code> into your <code>set</code>. What that does for your default args is to create two objects with each <code>int</code> (using the defaulted value for the second arg).  </p>\n", "LastActivityDate": "2015-09-15T13:10:04.243"}, "bq_ids": {"n4140": {"so_32586871_32587320_0": {"section_id": 630, "quality": 0.9705882352941176, "length": 33}, "so_32586871_32587320_1": {"section_id": 639, "quality": 1.0, "length": 12}}, "n3337": {"so_32586871_32587320_0": {"section_id": 621, "quality": 0.8235294117647058, "length": 28}, "so_32586871_32587320_1": {"section_id": 629, "quality": 1.0, "length": 12}}, "n4659": {"so_32586871_32587320_0": {"section_id": 658, "quality": 0.9705882352941176, "length": 33}, "so_32586871_32587320_1": {"section_id": 667, "quality": 1.0, "length": 12}}}});