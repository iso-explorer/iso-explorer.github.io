post_cb({"17492530": {"Id": "17492530", "PostTypeId": "2", "Body": "<p>The C++11 standard 23.3.6.5/4 says (emphasis is mine):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_17492092_17492530_1\">Complexity: <strong>The destructor of T is called the number of times equal to the number of the elements erased</strong>, but the move assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.</p>\n</blockquote>\n</blockquote>\n<p>Had the implementation called the destructor on the 3rd element, it wouldn't be conform.</p>\n<p>Indeed, suppose that the destructor is called on the 3rd element. Since only one element is erased, the desctructor cannot be called again.</p>\n<p>After the destructor call, the 3rd position contains raw memory (not a fully constructd object <code>T</code>). Hence the implementation needs to call the move constructor to move from the 4th position to the 3rd one.</p>\n<p>It cannot destroy the 4th element (because it can no longer call the destructor) and then to move from the 5th to the 4th element it must call the move assignment operator.</p>\n<p>At this point, the implementation still needs to decrease the <code>vector</code> size by 1 and destroy the 5th element but, as we have seen, no other destrucor call is allowed. (Notice also that the move assignement operator would not be called twice as required by the standard.) QED.</p>\n", "LastActivityDate": "2013-07-05T15:39:41.257", "CommentCount": "0", "CreationDate": "2013-07-05T15:39:41.257", "ParentId": "17492092", "Score": "4", "OwnerUserId": "1137388"}, "17492555": {"Id": "17492555", "PostTypeId": "2", "Body": "<p>The standard says that's expected, the specification for <code>vector::erase(const_iterator)</code> (in the table of Sequence container requirements) says that the requirements on that function are:</p>\n<blockquote>\n<p id=\"so_17492092_17492555_0\">For <code>vector</code> and <code>deque</code>, <code>T</code> shall be <code>MoveAssignable</code>.</p>\n</blockquote>\n<p>The reason for requiring <code>MoveAssignable</code> is that each of the following elements will be (move) assigned over the element before them, and the last element destroyed.</p>\n<p>In theory it would have been possible for the original STL to have done it differently and to have destroyed the erased element as you expect, but there are good reasons that wasn't chosen.  If you <em>only</em> destroy the erased element you leave a \"hole\" in the vector, which isn't an option (the vector would have to remember where holes were and if a user says <code>v[5]</code> the vector would have to remember there's a hole there and return <code>v[6]</code> instead.)  So it's necessary to \"shuffle\" the later elements down to fill the hole.  That could have been done by destroying the Nth element in place (i.e. <code>v[N].~value_type()</code>) and then using placement <code>new</code> to create a new object at that location (i.e. <code>::new ((void*)&amp;v[N]) value_type(std::move(v[N+1]))</code>) and then doing the same for each following element, until you get to the end, however that would result in far worse performance in many cases.  If the existing elements have allocated memory, e.g. are containers themselves, then assigning to them may allow them to reuse  that memory, but destroying them and then constructing new elements would require deallocating and reallocating memory, which may be much slower and could fragment the heap.  So there is a very good reason to us assignment to alter the elements' values, without necessarily altering their identities.</p>\n<p>This isn't the case for <code>std::list</code> and other containers because they do not store elements in a contiguous block like <code>vector</code> and <code>deque</code>, so removing a single element just involves adjusting the links between the neighbouring elements, and there is no need to \"shuffle\" other elements down the block to take up the empty position.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-07-05T15:55:02.423", "Score": "2", "CreationDate": "2013-07-05T15:40:54.733", "ParentId": "17492092", "CommentCount": "2", "OwnerUserId": "981959", "LastEditDate": "2013-07-05T15:55:02.423"}, "17493518": {"Id": "17493518", "PostTypeId": "2", "Body": "<p>In reference to example by Mats Petersson, perhaps this example will show more clearly that destroy 2 really happens, we just don't have destructor available for built-in type where we can conveniently add the printout statement:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nstruct Integer\n{\n    int x;\n    Integer(int v) : x(v) {}\n    ~Integer() { cout &lt;&lt; \"Destroy Integer=\" &lt;&lt; x &lt;&lt; endl; }\n};\n\nclass X\n{\n    Integer Int;\npublic: \n    X(int v) : Int(v) {}\n    X operator=(const X&amp; a) \n    { \n        auto tmp(a.Int);\n        swap(this-&gt;Int, tmp);\n        cout &lt;&lt; \"copy x=\" &lt;&lt; Int.x &lt;&lt; endl;\n        return *this; \n    }\n};\n\nint main()\n{\n    vector&lt;X&gt; v;\n    for(int i = 0; i &lt; 5; i++)\n    {\n        X a(i); \n        v.push_back(a);\n    }\n    cout &lt;&lt; \"Erasing ... \" &lt;&lt; endl;\n    v.erase(v.begin() + 2);\n}\n</code></pre>\n<p>This will print:</p>\n<pre><code>Destroy Integer=0\nDestroy Integer=0\nDestroy Integer=1\nDestroy Integer=0\nDestroy Integer=1\nDestroy Integer=2\nDestroy Integer=0\nDestroy Integer=1\nDestroy Integer=2\nDestroy Integer=3\nDestroy Integer=0\nDestroy Integer=1\nDestroy Integer=2\nDestroy Integer=3\nDestroy Integer=4\nErasing ...\nDestroy Integer=2\ncopy x=3\nDestroy Integer=2\nDestroy Integer=3\nDestroy Integer=3\ncopy x=4\nDestroy Integer=3\nDestroy Integer=4\nDestroy Integer=4\n</code></pre>\n<p>(skipped printout of destructor calls for entire vector on program exit)</p>\n<p>One way of looking at this is to ask yourself: what does it mean to erase an object from a vector? It means that, given a way to identify that object, you won't be able to find it in a vector after the erase. Maybe it was a value that got overwritten, thereby acquiring a new identity. If it held resources that could identify it, those will be properly released, as others mentioned, as long as move, assignment and copy do the right thing. Additionally, the size of vector would reflect that there is one object less.</p>\n<p>For your philosophical amusement, here are some notes by Stepanov (primary STL author):</p>\n<blockquote>\n<p id=\"so_17492092_17493518_0\">Integral parts of an object are those parts of the object needed to\n  realize its primary purpose. Connections among integral parts\n  constitute the integral form of the object. Two intuitive constraints\n  that we have on the definition of essential parts are (i) for certain\n  objects, it is possible to take them apart which would result i n\n  their losing their identity and later they could be brought together\n  which would imply their regaining their identity. This allows objects\n  to exist, disappear and later reappear; thus there is a discontinuity\n  in their existence. (ii) some essential parts of an object can be\n  replaced one by one without the object losing its identity. To define\n  identity across time, we introduce the notion of essential parts and\n  essential form.</p>\n<p id=\"so_17492092_17493518_1\"><strong>Definition: An essential part of an object is an integral part such that if it is removed, the object loses its identity, hence it\n  disappears.</strong></p>\n</blockquote>\n", "LastEditorUserId": "153380", "LastActivityDate": "2013-07-06T00:06:26.893", "Score": "2", "CreationDate": "2013-07-05T16:43:59.960", "ParentId": "17492092", "CommentCount": "0", "OwnerUserId": "153380", "LastEditDate": "2013-07-06T00:06:26.893"}, "bq_ids": {"n4140": {"so_17492092_17492530_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 989}, "so_17492092_17492530_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 989}}, "n3337": {"so_17492092_17492530_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 974}, "so_17492092_17492530_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 974}}, "n4659": {"so_17492092_17492530_0": {"length": 21, "quality": 0.875, "section_id": 1052}, "so_17492092_17492530_1": {"length": 21, "quality": 0.875, "section_id": 1052}}}, "17492370": {"Id": "17492370", "PostTypeId": "2", "Body": "<p>Unlike <code>std::list</code>, <code>std::vector</code> holds its elements contiguously. So when an element is erased from the middle of the container, it would make more sense to copy assign all elements that need to be shifted. In this scenario, the destructor of the last shifted element would be called. This avoids a re-allocation of the whole data of the vector.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2013-07-05T15:35:14.660", "Score": "2", "CreationDate": "2013-07-05T15:30:08.337", "ParentId": "17492092", "CommentCount": "0", "OwnerUserId": "661519", "LastEditDate": "2013-07-05T15:35:14.660"}, "17493105": {"Id": "17493105", "PostTypeId": "2", "Body": "<p>This is perfectly valid behaviour. @Cassio Neri pointed out why it is required by the standard.</p>\n<p>Short:</p>\n<h3>\"<em>std::vector::erase(iterator position) does not necessarily invoke the corresponding element's destructor</em>\" [Op; Headline] <strong>but a destructor is invoked, handling the data of the corresponding elements which has been transfered to another object (either via move constructor to the <em>moved-from</em> or via RAII to the temporary instance).</strong></h3>\n<p>Long:</p>\n<h2>Why you don't have to rely on the <em>ith</em> destructor to be called.</h2>\n<p>I'll provide some hints why you shouldn't worry at all, which destructor is called in this case.</p>\n<p>Consider the following small class</p>\n<pre><code>  class test\n  {\n    int * p;\n  public:\n    test (void) : p(new int[5]) { cout &lt;&lt; \"Memory \" &lt;&lt; p &lt;&lt; \" claimed.\" &lt;&lt; endl;  }\n    ~test (void) { cout &lt;&lt; \"Memory \" &lt;&lt; p &lt;&lt; \" will be deleted.\" &lt;&lt; endl; delete p;  }\n  };\n</code></pre>\n<p>If you handle your object move-assignment correctly there is no need to worry about the fact which destructor is called properly.</p>\n<pre><code>    test&amp; operator= (test &amp;&amp; rhs)\n    { \n      cout &lt;&lt; \"Move assignment from \" &lt;&lt; rhs.p &lt;&lt; endl;\n      std::swap(p, rhs.p);\n      return *this;\n    }\n</code></pre>\n<p>Your move assignment operator has to transfer the state of the object that is \"overwritten\" into the object that is \"moved from\" (<code>rhs</code> here) so it's destructor will take proper action (if there is something the destructor needs to take care of). Perhaps you should use something like a \"swap\" member function to do the transfer for you.</p>\n<p>If your object is non-moveable you'll have to handle the \"cleanup\" (or whatever action that relies on the current state of the object) of the erased object in the copy assignment operation before you copy the new data into the object.</p>\n<pre><code>    test&amp; operator= (test const &amp;rhs)\n    {\n      test tmp(rhs);\n      std::swap(p, tmp.p);\n      return *this;\n    }\n</code></pre>\n<p>Here we use RAII and again the <code>swap</code> (which may still be a member function, too; but test only has one pointer...). The destructor of <code>tmp</code> will make things cosy.</p>\n<h2>Let's do a small test:</h2>\n<pre><code>  #include &lt;vector&gt;\n  #include &lt;iostream&gt;\n  using namespace std;\n  class test\n  {\n    int * p;\n  public:\n    test (void) : p(new int[5]) { cout &lt;&lt; \"Memory \" &lt;&lt; p &lt;&lt; \" claimed.\" &lt;&lt; endl;  }\n    test&amp; operator= (test &amp;&amp; rhs)\n    { \n      cout &lt;&lt; \"Move assignment from \" &lt;&lt; rhs.p &lt;&lt; endl;\n      std::swap(p, rhs.p);\n      return *this;\n    }\n    ~test (void) { cout &lt;&lt; \"Memory \" &lt;&lt; p &lt;&lt; \" will be deleted.\" &lt;&lt; endl; delete p;  }\n  };\n\n  int main (void)\n  {\n    cout &lt;&lt; \"Construct\" &lt;&lt; endl;\n    std::vector&lt;test&gt; v(5);\n    cout &lt;&lt; \"Erase\" &lt;&lt; endl;\n    v.erase(v.begin()+2);\n    cout &lt;&lt; \"Kick-off\" &lt;&lt; endl;\n    return 0;\n  }\n</code></pre>\n<p>Results in</p>\n<pre><code>Construct\nMemory 012C9F18 claimed.\nMemory 012CA0F0 claimed.\nMemory 012CA2B0 claimed. // 2nd element\nMemory 012CA2F0 claimed.\nMemory 012CA110 claimed.\nErase\nMove assignment from 012CA2F0\nMove assignment from 012CA110\nMemory 012CA2B0 will be deleted. // destruction of the data of 2nd element\nKick-off\nMemory 012C9F18 will be deleted.\nMemory 012CA0F0 will be deleted.\nMemory 012CA2F0 will be deleted.\nMemory 012CA110 will be deleted.\n</code></pre>\n<p>Every memory location that is claimed will be released properly if your move (or copy) assignment operation hands over the critical properties to the object that will be destroyed.</p>\n<h2>Every destructor that relies on the internal state of an object will be called with the proper object around if your assignment operations are designed properly.</h2>\n", "LastEditorUserId": "951423", "LastActivityDate": "2013-07-05T16:54:22.180", "Score": "3", "CreationDate": "2013-07-05T16:13:59.930", "ParentId": "17492092", "CommentCount": "0", "OwnerUserId": "951423", "LastEditDate": "2013-07-05T16:54:22.180"}, "17492434": {"Id": "17492434", "PostTypeId": "2", "Body": "<p>Here's a small program that shows the problem, and yes, if you RELY on the destructor being called for that very object, you need to do something other than what this code does:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass X\n{\n    int x;\npublic: \n    X(int v) : x(v) {}\n    ~X() { cout &lt;&lt; \"Destroy v=\" &lt;&lt; x &lt;&lt; endl; }\n    X operator=(const X&amp; a) { x = a.x; cout &lt;&lt; \"copy x=\" &lt;&lt; x &lt;&lt; endl; return *this; }\n\n};\n\nint main()\n{\n    vector&lt;X&gt; v;\n    for(int i = 0; i &lt; 5; i++)\n    {\n    X a(i); \n    v.push_back(a);\n    }\n    cout &lt;&lt; \"Erasing ... \" &lt;&lt; endl;\n    v.erase(v.begin() + 2);\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>Destroy v=0\nDestroy v=0\nDestroy v=1\nDestroy v=0\nDestroy v=1\nDestroy v=2\nDestroy v=3\nDestroy v=0\nDestroy v=1\nDestroy v=2\nDestroy v=3\nDestroy v=4\nErasing ... \ncopy x=3\nDestroy v=3\ncopy x=4\nDestroy v=4     &lt;&lt;&lt; We expedct \"destroy 2\", not \"destroy 4\". \nDestroy v=4\nDestroy v=0\nDestroy v=1\nDestroy v=3\nDestroy v=4\n</code></pre>\n<p>One variant to solve this would be to store a (smart) pointer, and manually copy out the pointer and then <code>delete</code> it. </p>\n", "LastActivityDate": "2013-07-05T15:33:30.013", "CommentCount": "2", "CreationDate": "2013-07-05T15:33:30.013", "ParentId": "17492092", "Score": "0", "OwnerUserId": "1919155"}, "17492092": {"ViewCount": "1362", "Body": "<p>Assuming I have a <code>std::vector</code> <code>V</code> of 5 elements,</p>\n<p><code>V.erase(V.begin() + 2)</code> remove the 3rd element.</p>\n<p>STL <code>vector</code> implementation will move 4th and 5th element up, and then <em>destruct</em> the 5th element.</p>\n<p>I.e. erasing element <em>i</em> in a <code>vector</code> does not guarantee that <em>ith</em> destructor is called.\nFor <code>std::list</code>, this is not the case. Erasing <em>ith</em> element invokes <em>ith</em> element's destructor.</p>\n<p>What does STL say about this behavior?</p>\n<p>This is code taken from my system's stl_vector.h:</p>\n<pre><code>392   iterator erase(iterator __position) {\n393     if (__position + 1 != end())\n394       copy(__position + 1, _M_finish, __position);\n395     --_M_finish;\n396     destroy(_M_finish);\n397     return __position;\n</code></pre>\n", "Title": "std::vector::erase(iterator position) does not necessarily invoke the corresponding element's destructor", "CreationDate": "2013-07-05T15:14:00.173", "LastActivityDate": "2013-07-06T00:06:26.893", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-07-05T15:57:50.857", "LastEditorUserId": "1137388", "Id": "17492092", "Score": "6", "OwnerUserId": "1401322", "Tags": "<c++><stl>", "AnswerCount": "6"}});