post_cb({"38860572": {"CommentCount": "9", "ViewCount": "331", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-09T21:16:25.500", "LastActivityDate": "2016-08-09T22:16:41.503", "Title": "Does Making std::mutex as static creates race-condition for the mutex itself", "LastEditDate": "2017-05-23T12:10:11.467", "Id": "38860572", "Score": "2", "Body": "<p>It may sound dummy but,Am sort of confused, I have gone through this <a href=\"https://stackoverflow.com/questions/17357909/do-we-need-to-have-static-lock-for-static-member-variable-of-the-class-in-c\">question</a>,when looking into it we both where in the same situation it seems, I have to make my <code>map</code> as static so it will be common to all instances that will be created in separate <code>threads</code> and I want to synchronize the functions that gonna act on my map, so i thought of making a <code>std::mutex</code> as <code>static</code> in my class like what was suggested as an answer in the given link.. in this case will there be any race-condition occur for acquiring and locking the <code>mutex</code> itself? is there any better way we can synchronize the functions on <code>static map</code> using <code>mutex</code></p>\n", "Tags": "<c++><multithreading><c++11><mutex>", "OwnerUserId": "5198101", "AnswerCount": "2"}, "38860978": {"ParentId": "38860572", "CommentCount": "0", "Body": "<p><strong>No.</strong></p>\n<p>Mutexes (and other synchronisation primitives) are implemented using support from the operating system. That's the only way that they can do their job.</p>\n<p>A direct corollorary of their ability to perform this job is that they are themselves not prone to race conditions \u2014 locking and unlocking operations on mutexes are atomic.</p>\n<p>Otherwise, they wouldn't be much use! Every time you used a mutex, you'd have to protect it with another mutex, then protect that mutex with another mutex, and so on and so forth until you had an infinite number of mutexes, none of them actually achieving anything of any use at all. :)</p>\n<p>The <code>std::mutex</code> object having static storage duration doesn't change this in any way. Presumably you were thinking of function-<code>static</code> variables (that, assuming they're not already immune to race conditions, must be synchronised because they may be accessed concurrently by different threads; but still, ideally you wouldn't use them at all because they make functions not be re-entrant).</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "38860978", "Score": "2", "CreationDate": "2016-08-09T21:47:50.623", "LastActivityDate": "2016-08-09T21:47:50.623"}, "38860689": {"ParentId": "38860572", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_38860572_38860689_0\">Does Making <code>std::mutex</code> as static creates race-condition for the mutex\n  itself</p>\n</blockquote>\n<p>No, a <a href=\"http://en.cppreference.com/w/cpp/concept/Mutex\" rel=\"nofollow\">Mutex</a> isn't vulnerable to race-conditions. And as for initializing it as <code>static</code>, you are safe.</p>\n<blockquote>\n<p id=\"so_38860572_38860689_1\"><a href=\"http://eel.is/c++draft/stmt.dcl#4\" rel=\"nofollow\">$6.7: 4</a>: Dynamic initialization of a block-scope variable with static storage duration ([basic.stc.static]) or thread storage\n  duration ([basic.stc.thread]) is performed the first time control\n  passes through its declaration; such a variable is considered\n  initialized upon the completion of its initialization. If the\n  initialization exits by throwing an exception, the initialization is\n  not complete, so it will be tried again the next time control enters\n  the declaration. If control enters the declaration concurrently while\n  the variable is being initialized, the concurrent execution shall wait\n  for completion of the initialization</p>\n</blockquote>\n<hr>\n<p>You said:</p>\n<blockquote>\n<p id=\"so_38860572_38860689_2\">i thought of making a <code>std::mutex</code> as static in my class like what was\n  suggested as an answer in the given link.</p>\n</blockquote>\n<p>Do that if you are trying to protect <code>static</code> class member variables as well. Otherwise, make it a <code>mutable</code> member. The fact that you said the <code>map</code> will be globally initialized as <code>static</code> is okay, since the mutex as a member variable, will follow suite.</p>\n<pre><code>class Map{\npublic:\n    Map(...){}\n\n    std::size_t size() const{\n         std::lock_guard&lt;std::mutex&gt; lck(m_m);\n         return m_size;\n     }\n\n     iterator add(....) {\n         std::lock_guard&lt;std::mutex&gt; lck(m_m);\n         ....\n         return your_iterator;\n     }\n\n     ...etc\n\nprivate:\n    mutable std::mutex m_m; //FREE ADVICE: Use a std::recursive_mutex instead\n    ...others\n};\n</code></pre>\n<p>Now:</p>\n<pre><code>//Somewhere at global scope:\n\nMap mp(... ...);\n\n// NOTES\n// 1. `mp` will be initialized in a thread safe way by the runtime. \n// 2. Since you've protected all Read or Write member functions of the class `Map`,\n//    you are safe to call it from any function and from any thread\n</code></pre>\n</hr>", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-08-09T22:16:41.503", "Id": "38860689", "Score": "5", "CreationDate": "2016-08-09T21:24:27.943", "LastActivityDate": "2016-08-09T22:16:41.503"}, "bq_ids": {"n4140": {"so_38860572_38860689_1": {"section_id": 3919, "quality": 0.9074074074074074, "length": 49}}, "n3337": {"so_38860572_38860689_1": {"section_id": 3779, "quality": 0.9074074074074074, "length": 49}}, "n4659": {"so_38860572_38860689_1": {"section_id": 4805, "quality": 0.9629629629629629, "length": 52}}}});