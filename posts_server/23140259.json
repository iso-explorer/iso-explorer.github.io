post_cb({"23156630": {"Id": "23156630", "PostTypeId": "2", "Body": "<p>There is only one intrinsic that \"extracts\" the lower order double value from xmm register:</p>\n<pre><code>double _mm_cvtsd_f64 (__m128d a)\n</code></pre>\n<p>You could use it this way:</p>\n<pre><code>return _mm_cvtsd_f64(x);\n</code></pre>\n<p>There is some contradiction between different references. <a href=\"http://msdn.microsoft.com/en-us/library/bb531421%28v=vs.90%29.aspx\" rel=\"nofollow\">MSDN</a> says: <code>This intrinsic does not map to any specific machine instruction</code>. While Intel intrinsic guide mentions <code>movsd</code> instruction. In latter case this additional instruction is easily eliminated by optimizer. At least gcc 4.8.1 with <code>-O2</code> flag generates code with no additional instruction.</p>\n", "LastActivityDate": "2014-04-18T14:54:37.260", "CommentCount": "1", "CreationDate": "2014-04-18T14:54:37.260", "ParentId": "23140259", "Score": "2", "OwnerUserId": "1009831"}, "23140953": {"Id": "23140953", "PostTypeId": "2", "Body": "<p>The bullet point in bold should i think allow your cast here, as we may consider <code>__m128d</code> as an aggregate of four <code>double</code> union to the full register. In regards to strict aliasing, compiler had always be very conciliate around union where at the origin, only a cast to (char*) was supposed valid.</p>\n<blockquote>\n<p id=\"so_23140259_23140953_0\">\u00a73.10:\n  If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined (The intent of this list is to specify those circumstances in which an object may or may not be aliased):</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li><strong>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</strong></li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "922184", "LastActivityDate": "2014-04-17T18:58:57.457", "Score": "4", "CreationDate": "2014-04-17T18:41:43.663", "ParentId": "23140259", "CommentCount": "2", "OwnerUserId": "2694444", "LastEditDate": "2014-04-17T18:58:57.457"}, "23140259": {"ViewCount": "442", "Body": "<p>I would like to know if I'm breaking strict aliasing rules with this snippet. (I think so since it's dereferencing a punned-pointer, however it's done in a single expression and /Wall doesn't cry.)</p>\n<pre><code>inline double plop() const // member function\n{\n    __m128d x = _mm_load_pd(v);\n    ... // some stuff\n    return *(reinterpret_cast&lt;double*&gt;(&amp;x)); // return the lower double in xmm reg referred to by x.\n}\n</code></pre>\n<p>If yes, what's the workaround? Using different representations simultaneously is becoming hardcore once you want to respect the spec.</p>\n<p>Thanks for your answers, I'm losing my good mood trying to find a solution.</p>\n<p>Answers that won't be accepted and why:</p>\n<p>\"use mm_store\" -&gt; The optimizer fails to remove it if the following instructions require an xmm register so it generates a load just after it. Store + load for nothing.</p>\n<p>\"use a union\" -&gt; Aliasing rule violation if using the two types for the same object. If I understood well the article written by Thiago Macieira.</p>\n", "AcceptedAnswerId": "23156630", "Title": "Am I breaking strict aliasing rules?", "CreationDate": "2014-04-17T18:01:35.820", "Id": "23140259", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-05-15T06:38:52.837", "LastEditorUserId": "681785", "LastActivityDate": "2014-05-15T06:38:52.837", "Score": "12", "OwnerUserId": "1924533", "Tags": "<c++><c++11><sse><strict-aliasing>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_23140259_23140953_0": {"length": 23, "quality": 0.92, "section_id": 7239}}, "n3337": {"so_23140259_23140953_0": {"length": 23, "quality": 0.92, "section_id": 6983}}, "n4659": {"so_23140259_23140953_0": {"length": 23, "quality": 0.92, "section_id": 8748}}}, "23141820": {"Id": "23141820", "PostTypeId": "2", "Body": "<p>Yes, I <em>think</em> this breaks strict aliasing. However, in practice this is usually fine.<br>\n(I'm mostly writing this as an answer because It's difficult to describe well in a comment)</br></p>\n<p>But, you could instead do something like this:</p>\n<pre><code>inline double plop() const // member function\n{\n    __m128d x = _mm_load_pd(v);\n    ... // some stuff\n\n    union {\n        unsigned long long i; // 64-bit int\n        double             d; // 64-bit double\n    };\n\n    i = _mm_cvtsi128_si64(_mm_castpd_si128(x)); // _mm_castpd_si128 to interpret the register as an int vector, _mm_cvtsi128_si64 to extract the lowest 64-bits\n\n    return d; // use the union to return the value as a double without breaking strict aliasing\n}\n</code></pre>\n", "LastActivityDate": "2014-04-17T19:28:50.700", "CommentCount": "6", "CreationDate": "2014-04-17T19:28:50.700", "ParentId": "23140259", "Score": "1", "OwnerUserId": "3100771"}, "23141996": {"Id": "23141996", "PostTypeId": "2", "Body": "<p>What about <code>return x.m128d_f64[0];</code> ?</p>\n", "LastActivityDate": "2014-04-17T19:39:22.513", "CommentCount": "2", "CreationDate": "2014-04-17T19:39:22.513", "ParentId": "23140259", "Score": "1", "OwnerUserId": "1196549"}});