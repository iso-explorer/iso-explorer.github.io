post_cb({"30259434": {"ParentId": "30258621", "CommentCount": "0", "Body": "<p><code>dynamic_cast</code> will confirm that the dynamic type does match the type indicated by the <code>switcher</code> variable, making the code slightly less dangerous. However, it will give a null pointer in the case of a mismatch, and the code neglects to check for that.</p>\n<p>But it seems more likely that the author didn't really understand the use of virtual functions (for uniform treatment of polymorphic types) and RTTI (for the rarer cases where you need to distinguish between types), and attempted to invent their own form of manual, error-prone type identification.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "30259434", "Score": "0", "CreationDate": "2015-05-15T12:21:25.410", "LastActivityDate": "2015-05-15T12:21:25.410"}, "30259301": {"ParentId": "30258621", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My guess would be that the coder screwed up.</p>\n<p>A second guess would be that you skipped a check for <code>a</code> being null in your simplification.</p>\n<p>A third, and highly unlikely possibility, is that the coder was exploiting undefined behavior to optimize.</p>\n<p>With this code:</p>\n<pre><code>            a = dynamic_cast&lt;DerivedA*&gt;(pAbstract);\n            a-&gt;doThis();\n</code></pre>\n<p>if <code>a</code> is not of type <code>DerivedA*</code> (or more derived), the <code>a-&gt;doThis()</code> is undefined behavior.  And if it is of type <code>DerivedA*</code>, then the <code>dynamic_cast</code> does absolutely nothing (guaranteed).</p>\n<p>A compiler can, in theory, optimize out any other possibility away, even if you did not change the type of <code>a</code>, and remain conforming behavior.  Even if someone later checks if <code>a</code> is null, the execution of undefined behavior on the very next line means that the compiler is free not to set <code>a</code> to null on the <code>dynamic_cast</code> line.</p>\n<p>I would doubt that a given compiler would do this, but I could be wrong.</p>\n<p>There are compilers that detect certain paths cause undefined behavior (in the future), eliminate such possibilities from happening <em>backwards in execution</em> to the point where the undefined behavior would have been set in motion, and then \"know\" that the code in question cannot be in the state that would trigger undefined behavior.  It can then use this knowledge to optimize the code in question.</p>\n<p>Here is an example:</p>\n<pre><code>std::string foo( unsigned int x ) {\n  std::string r;\n  if (x == (unsigned)-1)) {\n    r = \"hello \";\n  }\n  int y = x;\n  std::stringstream ss;\n  ss &lt;&lt; y;\n  r += ss.str();\n  return r;\n}\n</code></pre>\n<p>The compiler can see the <code>y=x</code> line above.  If <code>x</code> would overflow an int, then the conversion <code>y=x</code> is undefined behavior.  It happens regardless of the result of the first branch.</p>\n<p>In short, if the first branch runs, undefined behavior would result.  And undefined behavior can do anything, <em>including time travel</em> -- it can go back in time and prevent that branch from being taken.</p>\n<p>So the</p>\n<pre><code>  if (x == (unsigned)-1)) {\n    r = \"hello \";\n  }\n</code></pre>\n<p>branch can be eliminated by the optimizer, legally in C++.</p>\n<p>While the above is just a toy case, gcc does optimizations very much like this.  There is a flag to tell it not do.</p>\n<p>(<code>unsigned</code> <code>-1</code> is defined behavior, but overflowing an <code>int</code> is not, in C++.  In practice, this is because there are platforms in which signed int overflow causes problems, and C++ doesn't want to impose extra costs on them to make a conforming implementation.)</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2015-05-15T12:19:20.020", "Id": "30259301", "Score": "0", "CreationDate": "2015-05-15T12:14:00.127", "LastActivityDate": "2015-05-15T12:19:20.020"}, "30258621": {"CommentCount": "4", "ViewCount": "101", "PostTypeId": "1", "LastEditorUserId": "1747524", "CreationDate": "2015-05-15T11:41:06.140", "LastActivityDate": "2015-05-15T12:21:25.410", "Title": "Why downcast and then assign to base-class in C++?", "AcceptedAnswerId": "30259301", "LastEditDate": "2015-05-15T11:58:22.347", "Id": "30258621", "Score": "0", "Body": "<p>I have stumbled upon the following code structure and I'm wondering whether this is intentional or just poor understanding of casting mechanisms:</p>\n<pre><code>struct AbstractBase{ \n    virtual void doThis(){\n    //Basic implementation here.\n    };\n    virtual void doThat()=0;\n};\n\nstruct DerivedA: public AbstractBase{ \n    virtual void doThis(){\n    //Other implementation here.\n    };\n    virtual void doThat(){\n    // some stuff here.\n    };\n};\n// More derived classes with similar structure....\n\n// Dubious stuff happening here:\nvoid strangeStuff(AbstractBase* pAbstract, int switcher){\n   AbstractBase* a = NULL;\n   switch(switcher){\n       case TYPE_DERIVED_A: \n                // why would someone use the abstract base pointer here???\n                a = dynamic_cast&lt;DerivedA*&gt;(pAbstract);\n                a-&gt;doThis();\n                a-&gt;doThat();\n                break;\n       // similar case statement with other derived classes...\n   }\n}\n\n// \"main\"\nDerivedA* pDerivedA = new DerivedA;\nstrangeStuff( pDerivedA, TYPE_DERIVED_A );\n</code></pre>\n<p>My guess is, that this dynamic_cast statement is just the result of poor understanding and very bad programming style in general (the whole way the code works, just feels painful to me) and that it doesn't cause any change in behaviour for this specific use case.</p>\n<p>However, since I'm not an expert on casting, I'd like to know whether there are any subtle side-effects that I'm not aware of.</p>\n", "Tags": "<c++><casting><dynamic-cast><downcasting>", "OwnerUserId": "1747524", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30258621_30258715_0": {"section_id": 6019, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_30258621_30258715_0": {"section_id": 5787, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_30258621_30258715_0": {"section_id": 7518, "quality": 0.7333333333333333, "length": 11}}}, "30258715": {"ParentId": "30258621", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_30258621_30258715_0\">Blockquote [C++11: 5.2.7/9]: The value of a failed cast to pointer type is the null pointer value of the required result type. </p>\n</blockquote>\n<p>The <code>dynamic_cast</code> can return <code>NULL</code> if the type was wrong, making the following lines crash. Hence, this can be either 1. an attempt to make (logical) errors more explicit, or 2. some sort of in-code documentation.</p>\n<p>So while it doesn't look like the best design, it is not exactly true that the cast has no effect whatsoever.</p>\n", "OwnerUserId": "3510736", "LastEditorUserId": "3510736", "LastEditDate": "2015-05-15T11:47:56.677", "Id": "30258715", "Score": "3", "CreationDate": "2015-05-15T11:45:28.707", "LastActivityDate": "2015-05-15T11:47:56.677"}});