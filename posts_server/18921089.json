post_cb({"bq_ids": {"n4140": {"so_18921089_18922076_2": {"length": 84, "quality": 0.9230769230769231, "section_id": 6092}}, "n3337": {"so_18921089_18922076_2": {"length": 84, "quality": 0.9230769230769231, "section_id": 5859}}, "n4659": {"so_18921089_18922076_2": {"length": 85, "quality": 0.9340659340659341, "section_id": 7588}}}, "18921089": {"ViewCount": "617", "Body": "<pre><code>struct Alignment\n{\n    char one;\n    int four;\n};\nAlignment a = {' ',0};\nchar* buf = new char[8];\nAlignment* p = new (buf) Alignment(a);\n</code></pre>\n<h3>The size of Alignment a is 8 because of the memory alignment. But how much is the size of Alignment instance pointed by p? Will there be memory alignment in the buffer allocated by placement new?</h3>\n", "Title": "Will data align in the memory allocated by placement new?", "CreationDate": "2013-09-20T16:01:19.217", "LastActivityDate": "2013-09-20T16:59:17.640", "CommentCount": "0", "PostTypeId": "1", "Id": "18921089", "Score": "0", "OwnerUserId": "2278997", "Tags": "<c++><alignment>", "AnswerCount": "1"}, "18922076": {"Id": "18922076", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18921089_18922076_0\">The size of Alignment a is 8 because of the memory alignment.</p>\n</blockquote>\n<p>It's 8 <em>on your computer</em>. Don't make assumptions about how big objects will be. Use <code>sizeof</code>. It would be much better if were to use <code>char* buf = new char[sizeof(Alignment)];</code>. </p>\n<blockquote>\n<p id=\"so_18921089_18922076_1\">Will there be memory alignment in the buffer allocated by placement new?</p>\n</blockquote>\n<p><strong>Yes.</strong></p>\n<p>Well, with two assumptions, the answer is yes. First, this assumes that you have not overloaded <code>operator new</code> (or that your overload satisfies 5.3.4.) Second, it assumes you have allocated a properly sized array.</p>\n<p>The standard explicitly allows doing exactly what you have done. See 5.3.4, paragraph 10:</p>\n<blockquote>\n<p id=\"so_18921089_18922076_2\">A new-expression passes the amount of space requested to the allocation function as the first argument of type std::size_t. That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array. For arrays of char and unsigned char, the difference between the result of the new-expression and the address returned by the allocation function shall be an integral multiple of the strictest fundamental alignment requirement (3.11) of any object type whose size is no greater than the size of the array being created. [ Note: <strong>Because allocation functions are assumed to return pointers to storage that is appropriately aligned for objects of any type with fundamental alignment, this constraint on array allocation overhead permits the common idiom of allocating character arrays into which objects of other types will later be placed.</strong> \u2014 end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-09-20T16:59:17.640", "CommentCount": "0", "CreationDate": "2013-09-20T16:59:17.640", "ParentId": "18921089", "Score": "1", "OwnerUserId": "774499"}});