post_cb({"37205881": {"Id": "37205881", "PostTypeId": "2", "Body": "<p>There is no lower limit specified in the standard.  This is probably deliberate.</p>\n<p>Older standards (C I think) did use to provide lower limits for things like this.  The result was that people wrote coding standards which said you couldn't use more than these lower limits.  For example: It was (and I think still is) implementation defined how many characters of an external symbol were significant when comparing for equality.  So <code>a_very_very_long_name_indeed_with_extra_padding</code> and <code>a_very_very_long_name_indeed_with_extra_paddingX</code> might be treated as the same symbol.  The minimum length was specified as 8, and coding standards were written specifying \"maximum length of a external symbol is eight characters\".</p>\n<p>On the plausible lower bound for this value:  I can easily imagine that the count might be bit-packed into some other field so that the whole thing can be updated atomically with a suitable instruction.  As such, it might be a good deal less than 32 bits.  (It only really needs to be large enough for the maximum call stack depths, so in a constrained environment, 31 might be good enough.)</p>\n", "LastActivityDate": "2016-05-13T09:11:39.150", "CommentCount": "0", "CreationDate": "2016-05-13T09:11:39.150", "ParentId": "37203741", "Score": "0", "OwnerUserId": "771073"}, "bq_ids": {"n4140": {"so_37203741_37203741_0": {"length": 41, "quality": 1.0, "section_id": 2781}}, "n3337": {"so_37203741_37203741_0": {"length": 41, "quality": 1.0, "section_id": 2742}}, "n4659": {"so_37203741_37203741_0": {"length": 41, "quality": 1.0, "section_id": 3519}}}, "37203741": {"ViewCount": "49", "Body": "<p>Quoting <a href=\"http://eel.is/c++draft/thread.mutex.recursive#3\" rel=\"nofollow\">[thread.mutex.recursive]</a>:</p>\n<blockquote>\n<p id=\"so_37203741_37203741_0\">A thread that owns a <code>recursive_mutex</code> object may acquire additional levels of ownership by calling <code>lock()</code> or <code>try_lock()</code> on that object. It is unspecified how many levels of ownership may be acquired by a single thread. If a thread has already acquired the maximum level of ownership for a <code>recursive_mutex</code> object, additional calls to <code>try_lock()</code> shall fail, and additional calls to <code>lock()</code> shall throw an exception of type <code>system_error</code>.</p>\n</blockquote>\n<p>Is there a lower bound greater than 1 for the \"<em>maximum level of ownership</em>\"? What about recursive pthread mutexes?</p>\n", "Title": "Lower bound for the maximum level of ownership for recursive_mutex?", "CreationDate": "2016-05-13T07:24:30.250", "LastActivityDate": "2016-05-16T13:48:00.330", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-16T13:48:00.330", "LastEditorUserId": "3919155", "Id": "37203741", "Score": "2", "OwnerUserId": "3919155", "Tags": "<c++><pthreads><language-lawyer><recursive-mutex>", "AnswerCount": "1"}});