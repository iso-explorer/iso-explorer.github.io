post_cb({"bq_ids": {"n4140": {"so_46750163_46750570_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 5505}, "so_46750163_46750570_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 6066}, "so_46750163_46750570_2": {"length": 31, "quality": 1.0, "section_id": 43}, "so_46750163_46750570_3": {"length": 18, "quality": 0.9, "section_id": 6129}}, "n3337": {"so_46750163_46750570_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 5291}, "so_46750163_46750570_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 5834}, "so_46750163_46750570_2": {"length": 31, "quality": 1.0, "section_id": 40}, "so_46750163_46750570_3": {"length": 18, "quality": 0.9, "section_id": 5893}}, "n4659": {"so_46750163_46750570_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 6939}, "so_46750163_46750570_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 7562}, "so_46750163_46750570_2": {"length": 31, "quality": 1.0, "section_id": 43}, "so_46750163_46750570_3": {"length": 19, "quality": 0.95, "section_id": 7626}}}, "46750163": {"ViewCount": "31", "Body": "<p>The following code fails to compile with GCC 7.2.0 and Clang 5.0.0 on Linux.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    void f()\n    {\n        std::cout &lt;&lt; \"Hello, world!\\n\";\n    }\n};\n\nstruct B : private A\n{\n    using A::f;\n};\n\nint main()\n{\n    B b;\n    void (B::*f)() = &amp;B::f; // Error: 'A' is an inaccessible base of 'B'\n    (b.*f)();\n}\n</code></pre>\n<p>Is this in accordance with the standard? Shouldn't the public using-declaration in <code>B</code> allow a member function pointer to <code>B::f</code> to be transparently taken, rather than involving <code>A::f</code>'s accessibility outside of <code>B</code>'s perspective?</p>\n", "AcceptedAnswerId": "46750570", "Title": "Taking a pointer to a member function aliased from a private base class", "CreationDate": "2017-10-14T23:03:07.033", "Id": "46750163", "CommentCount": "2", "LastEditDate": "2017-10-14T23:08:34.943", "PostTypeId": "1", "LastEditorUserId": "5249858", "LastActivityDate": "2017-10-15T00:33:54.170", "Score": "2", "OwnerUserId": "5249858", "Tags": "<c++>", "AnswerCount": "1"}, "46750570": {"Id": "46750570", "PostTypeId": "2", "Body": "<p>Yes, your program is ill-formed.</p>\n<p>C++17 (N4659) [namespace.udecl]/16 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_46750163_46750570_0\">For the purpose of overload resolution, the functions that are introduced by a <em>using-declaration</em> into a derived class are treated as though they were members of the derived class. In particular, the implicit <code>this</code> parameter shall be treated as if it were a pointer to the derived class rather than to the base class. <strong>This has no effect on the type of the function, and in all other respects the function remains a member of the base class.</strong></p>\n</blockquote>\n<p>In other words, the <em>using-declaration</em> does not add a member of <code>B</code>, it just adds a second name for the same member <code>A::f</code>.  This second name can be selected by name lookup and used for the accessibility checks on use of the name, but beyond that point, except as noted for overload resolution, it's equivalent to the original member.</p>\n<p>[expr.unary.op]/3:</p>\n<blockquote>\n<p id=\"so_46750163_46750570_1\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a <em>qualified-id</em> naming a non-static or variant member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \"pointer to member of class <code>C</code> of type <code>T</code>\" and is a prvalue designating <code>C::m</code>.</p>\n</blockquote>\n<p>So even though the <em>qualified-id</em> <code>B::f</code> you used is spelled with the name of <code>class B</code> and the qualified name lookup finds the name introduced by the <em>using-declaration</em> in <code>B</code>, the actual function that expression names is a member of <code>A</code>, so the expression <code>&amp;B::f</code> has type \"pointer to member of class <code>A</code> of type function of () returning <code>void</code>\", or as a <em>type-id</em>, <code>void (A::*)()</code>.  You can verify this by adding to your example:</p>\n<pre><code>#include &lt;type_traits&gt;\nstatic_assert(std::is_same&lt;decltype(&amp;B::f), void (A::*)()&gt;::value, \"error\");\n</code></pre>\n<p>Finally, in [conv.mem]/2:</p>\n<blockquote>\n<p id=\"so_46750163_46750570_2\">A prvalue of type \"pointer to member of <code>B</code> of type <em>cv</em> <code>T</code>\", where <code>B</code> is a class type, can be converted to a prvalue of type \"pointer to member of <code>D</code> of type <em>cv</em> <code>T</code>\", where <code>D</code> is a derived class of <code>B</code>. If <code>B</code> is an inaccessible, ambiguous, or virtual base class of <code>D</code>, or a base class of a virtual base class of <code>D</code>, a program that necessitates this conversion is ill-formed.</p>\n</blockquote>\n<p>So naming the pointer to member function was valid, but converting it from <code>void (A::*)()</code> to <code>void (B::*)()</code> is not, since the inheritance is inaccessible from <code>main</code>.</p>\n<p>As a workaround, you could provide access to the pointer to member function in addition to the member function itself in <code>B</code>:</p>\n<pre><code>struct B : private A\n{\n    using A::f;\n    using func_ptr_type = void (B::*)();\n    static constexpr func_ptr_type f_ptr = &amp;A::f;\n};\n</code></pre>\n<p>Or if you really must, use a C-style cast.  In certain situations, a C-style cast is allowed to ignore accessibility of a class inheritance relationship where none of the C++-style casts can compile with the same results.  (<code>reinterpret_cast</code> can also convert any pointer to member function to any other, but its results are unspecified.)</p>\n<pre><code>int main()\n{\n    B b;\n    void (B::*f)() = (void (B::*)()) &amp;B::f;\n    (b.*f)();\n}\n</code></pre>\n<hr>\n<p>Note on the comments attached to the question: If you change <code>main</code> to</p>\n<pre><code>int main()\n{\n    B b;\n    auto f = &amp;B::f;\n    (b.*f)();\n}\n</code></pre>\n<p>then the type of <code>f</code> is <code>void (A::*)()</code> as explained above.  But then you run into [expr.mptr.oper]/2 (emphasis mine again):</p>\n<blockquote>\n<p id=\"so_46750163_46750570_3\">The binary operator <code>.*</code> binds its second operand, which shall be of type \"pointer to member of <code>T</code>\" to its first operand, which shall be a glvalue of class <code>T</code> or of a class of which <code>T</code> is an unambiguous and <strong>accessible</strong> base class.</p>\n</blockquote>\n<p>So, you still have the issue that the member function is associated with its original class and can't be considered a member of <code>B</code> except in the scope of <code>B</code> and any friends.</p>\n</hr>", "LastEditorUserId": "459640", "LastActivityDate": "2017-10-15T00:33:54.170", "Score": "5", "CreationDate": "2017-10-15T00:26:28.520", "ParentId": "46750163", "CommentCount": "2", "LastEditDate": "2017-10-15T00:33:54.170", "OwnerUserId": "459640"}});