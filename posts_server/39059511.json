post_cb({"bq_ids": {"n4140": {"so_39059511_39086337_0": {"length": 49, "quality": 0.98, "section_id": 216}, "so_39059511_39086337_2": {"length": 15, "quality": 0.9375, "section_id": 7051}}, "n3337": {"so_39059511_39086337_0": {"length": 49, "quality": 0.98, "section_id": 210}, "so_39059511_39086337_2": {"length": 15, "quality": 0.9375, "section_id": 6796}}, "n4659": {"so_39059511_39086337_1": {"length": 30, "quality": 0.967741935483871, "section_id": 180}, "so_39059511_39086337_0": {"length": 49, "quality": 0.98, "section_id": 224}, "so_39059511_39065216_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 242}, "so_39059511_39086337_2": {"length": 15, "quality": 0.9375, "section_id": 8548}}}, "39059511": {"ViewCount": "283", "Body": "<p>I am trying to understand why a piece of template metaprogramming is <strong>not</strong> generating an infinite recursion. I tried to reduce the test case as much as possible, but there's still a bit of setup involved, so bear with me :)</p>\n<p>The setup is the following. I have a generic function <code>foo(T)</code> which delegates the implementation to a generic functor called <code>foo_impl</code> via its call operator, like this:</p>\n<pre><code>template &lt;typename T, typename = void&gt;\nstruct foo_impl {};\n\ntemplate &lt;typename T&gt;\ninline auto foo(T x) -&gt; decltype(foo_impl&lt;T&gt;{}(x))\n{\n    return foo_impl&lt;T&gt;{}(x);\n}\n</code></pre>\n<p><code>foo()</code> uses decltype trailing return type for SFINAE purposes. The default implementation of <code>foo_impl</code> does not define any call operator. Next, I have a type-trait that detects whether <code>foo()</code> can be called with an argument of type <code>T</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct has_foo\n{\n    struct yes {};\n    struct no {};\n    template &lt;typename T1&gt;\n    static auto test(T1 x) -&gt; decltype(foo(x),void(),yes{});\n    static no test(...);\n    static const bool value = std::is_same&lt;yes,decltype(test(std::declval&lt;T&gt;()))&gt;::value;\n};\n</code></pre>\n<p>This is just the classic implementation of a type trait via expression SFINAE:\n<code>has_foo&lt;T&gt;::value</code> will be true if a valid <code>foo_impl</code> specialisation exists for <code>T</code>, false otherwise. Finally, I have two specialisations of the the implementation functor for integral types and for floating-point types:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo_impl&lt;T,typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;\n{\n    void operator()(T) {}\n};\n\ntemplate &lt;typename T&gt;\nstruct foo_impl&lt;T,typename std::enable_if&lt;has_foo&lt;unsigned&gt;::value &amp;&amp; std::is_floating_point&lt;T&gt;::value&gt;::type&gt;\n{\n    void operator()(T) {}\n};\n</code></pre>\n<p>In the last <code>foo_impl</code> specialisation, the one for floating-point types, I have added the extra condition that <code>foo()</code> must be available for the type <code>unsigned</code> (<code>has_foo&lt;unsigned&gt;::value</code>).</p>\n<p>What I don't understand is why the compilers (GCC &amp; clang both) accept the following code:</p>\n<pre><code>int main()\n{\n    foo(1.23);\n}\n</code></pre>\n<p>In my understanding, when <code>foo(1.23)</code> is called the following should happen:</p>\n<ol>\n<li>the specialisation of <code>foo_impl</code> for integral types is discarded because <code>1.23</code> is not integral, so only the second specialisation of <code>foo_impl</code> is considered;</li>\n<li>the enabling condition for the second specialisation of <code>foo_impl</code> contains <code>has_foo&lt;unsigned&gt;::value</code>, that is, the compiler needs to check if <code>foo()</code> can be called on type <code>unsigned</code>;</li>\n<li>in order to check if <code>foo()</code> can be called on type <code>unsigned</code>, the compiler needs again to select a specialisation of <code>foo_impl</code> among the two available;</li>\n<li>at this point, in the enabling condition for the second specialisation of <code>foo_impl</code> the compiler encounters again the condition <code>has_foo&lt;unsigned&gt;::value</code>.</li>\n<li>GOTO 3.</li>\n</ol>\n<p>However, it seems like the code is happily accepted both by GCC 5.4 and Clang 3.8. See here: <a href=\"http://ideone.com/XClvYT\">http://ideone.com/XClvYT</a></p>\n<p>I would like to understand what is going on here. Am I misunderstanding something and the recursion is blocked by some other effect? Or maybe am I triggering some sort of undefined/implementation defined behaviour?</p>\n", "AcceptedAnswerId": "39086337", "Title": "Infinite recursive template instantiation expected?", "CreationDate": "2016-08-20T23:12:20.040", "Id": "39059511", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-08-23T19:57:35.460", "Score": "10", "OwnerUserId": "453925", "Tags": "<templates><c++11><c++14><sfinae>", "AnswerCount": "2"}, "39086337": {"Id": "39086337", "PostTypeId": "2", "Body": "<p><code>has_foo&lt;unsigned&gt;::value</code> is a non-dependent expression, so it immediately triggers instantiation of <code>has_foo&lt;unsigned&gt;</code> (even if the corresponding specialization is never used).</p>\n<p>The relevant rules are [temp.point]/1:</p>\n<blockquote>\n<p id=\"so_39059511_39086337_0\">For a function template specialization, a member function template specialization, or a specialization for a member function or static data member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization and the context from which it is referenced depends on a template parameter, the point of instantiation of the specialization is the point of instantiation of the enclosing specialization. Otherwise, the point of instantiation for such a specialization immediately follows the namespace scope declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p>(note that we're in the non-dependent case here), and [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_39059511_39086337_1\">The program is\n  ill-formed, no diagnostic required, if:<br>\n   - [...]<br>\n   -  a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not depend on a template parameter, or<br>\n   -  the interpretation of such a construct in the hypothetical instantiation is different from the interpretation of the corresponding construct in any actual instantiation of the template.</br></br></br></p>\n</blockquote>\n<p>These rules are intended to give the implementation freedom to instantiate <code>has_foo&lt;unsigned&gt;</code> at the point where it appears in the above example, and to give it the same semantics as if it had been instantiated there. (Note that the rules here are actually subtly wrong: the point of instantiation for an entity referenced by the declaration of another entity <em>actually</em> must immediately precede that entity rather than immediately following it. This has been reported as a core issue, but it's not on the issues list yet as the list hasn't been updated for a while.)</p>\n<p>As a consequence, the point of instantiation of <code>has_foo</code> within the floating-point partial specialization occurs before the point of declaration of that specialization, which is after the <code>&gt;</code> of the partial specialization per [basic.scope.pdecl]/3:</p>\n<blockquote>\n<p id=\"so_39059511_39086337_2\">The point of declaration for a class or class template first declared by a class-specifier is immediately after the identifier or simple-template-id (if any) in its class-head (Clause 9).</p>\n</blockquote>\n<p>Therefore, when the call to <code>foo</code> from <code>has_foo&lt;unsigned&gt;</code> looks up the partial specializatios of <code>foo_impl</code>, it does not find the floating-point specialization at all.</p>\n<p><strong>A couple of other notes about your example:</strong></p>\n<p>1) Use of cast-to-<code>void</code> in comma operator:</p>\n<pre><code>static auto test(T1 x) -&gt; decltype(foo(x),void(),yes{});\n</code></pre>\n<p>This is a bad pattern. <code>operator,</code> lookup is <em>still</em> performed for a comma operator where one of its operands is of class or enumeration type (even though it can never succeed). This can result in ADL being performed [implementations are permitted but not required to skip this], which triggers the instantiation of all associated classes of the return type of foo (in particular, if <code>foo</code> returns <code>unique_ptr&lt;X&lt;T&gt;&gt;</code>, this can trigger the instantiation of <code>X&lt;T&gt;</code> and may render the program ill-formed if that instantiation doesn't work from this translation unit). You should prefer to cast all operands of a comma operator of user-defined type to <code>void</code>:</p>\n<pre><code>static auto test(T1 x) -&gt; decltype(void(foo(x)),yes{});\n</code></pre>\n<p>2) SFINAE idiom:</p>\n<pre><code>template &lt;typename T1&gt;\nstatic auto test(T1 x) -&gt; decltype(void(foo(x)),yes{});\nstatic no test(...);\nstatic const bool value = std::is_same&lt;yes,decltype(test(std::declval&lt;T&gt;()))&gt;::value;\n</code></pre>\n<p>This is not a correct SFINAE pattern in the general case. There are a few problems here:</p>\n<ul>\n<li>if <code>T</code> is a type that cannot be passed as an argument, such as <code>void</code>, you trigger a hard error instead of <code>value</code> evaluating to <code>false</code> as intended</li>\n<li>if <code>T</code> is a type to which a reference cannot be formed, you again trigger a hard error</li>\n<li>you check whether <code>foo</code> can be applied to an lvalue of type <code>remove_reference&lt;T&gt;</code> <em>even if</em> <code>T</code> is an rvalue reference</li>\n</ul>\n<p>A better solution is to put the entire check into the <code>yes</code> version of <code>test</code> instead of splitting the <code>declval</code> portion into <code>value</code>:</p>\n<pre><code>template &lt;typename T1&gt;\nstatic auto test(int) -&gt; decltype(void(foo(std::declval&lt;T1&gt;())),yes{});\ntemplate &lt;typename&gt;\nstatic no test(...);\nstatic const bool value = std::is_same&lt;yes,decltype(test&lt;T&gt;(0))&gt;::value;\n</code></pre>\n<p>This approach also more naturally extends to a ranked set of options:</p>\n<pre><code>// elsewhere\ntemplate&lt;int N&gt; struct rank : rank&lt;N-1&gt; {};\ntemplate&lt;&gt; struct rank&lt;0&gt; {};\n\n\ntemplate &lt;typename T1&gt;\nstatic no test(rank&lt;2&gt;, std::enable_if_t&lt;std::is_same&lt;T1, double&gt;::value&gt;* = nullptr);\ntemplate &lt;typename T1&gt;\nstatic yes test(rank&lt;1&gt;, decltype(foo(std::declval&lt;T1&gt;()))* = nullptr);\ntemplate &lt;typename T1&gt;\nstatic no test(rank&lt;0&gt;);\nstatic const bool value = std::is_same&lt;yes,decltype(test&lt;T&gt;(rank&lt;2&gt;()))&gt;::value;\n</code></pre>\n<p>Finally, your type trait will evaluate faster and use less memory at compile time if you move the above declarations of <code>test</code> outside the definition of <code>has_foo</code> (perhaps into some helper class or namespace); that way, they do not need to be redundantly instantiated once for each use of <code>has_foo</code>.</p>\n", "LastEditorUserId": "1041090", "LastActivityDate": "2016-08-23T19:57:35.460", "Score": "11", "CreationDate": "2016-08-22T18:27:32.323", "ParentId": "39059511", "CommentCount": "6", "OwnerUserId": "1041090", "LastEditDate": "2016-08-23T19:57:35.460"}, "39065216": {"Id": "39065216", "PostTypeId": "2", "Body": "<p>It's not actually UB. But it really shows you how TMP is complex...</p>\n<p>The reason this doesn't infinitely recurse is because of completeness.</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo_impl&lt;T,typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;\n{\n    void operator()(T) {}\n};\n\n// has_foo here\n\ntemplate &lt;typename T&gt;\nstruct foo_impl&lt;T,typename std::enable_if&lt;has_foo&lt;unsigned&gt;::value &amp;&amp; std::is_floating_point&lt;T&gt;::value&gt;::type&gt;\n{\n    void operator()(T) {}\n};\n</code></pre>\n<p>When you call <code>foo(3.14);</code>, you instantiate <code>has_foo&lt;float&gt;</code>. That in turn SFINAEs on <code>foo_impl</code>.</p>\n<p>The first one is enabled if <code>is_integral</code>. Obviously, this fails.</p>\n<p>The second <code>foo_impl&lt;float&gt;</code> is now considered. Trying to instantiate it, the compiles sees <code>has_foo&lt;unsigned&gt;::value</code>.</p>\n<p>Back to instantiating <code>foo_impl</code>: <code>foo_impl&lt;unsigned&gt;</code>!</p>\n<p>The first <code>foo_impl&lt;unsigned&gt;</code> is a match.</p>\n<p>The second one is considered. The <code>enable_if</code> contains <code>has_foo&lt;unsigned&gt;</code> - the one the compiler is already trying to instantiate.</p>\n<p>Since it's currently being instantiated, it's <strong>incomplete</strong>, and this specialization is not considered.</p>\n<p>Recursion stops, <code>has_foo&lt;unsigned&gt;::value</code> is true, and your code snippet works!</p>\n<hr>\n<p>So, you want to know how it comes down to it in the standard? Okay.</p>\n<blockquote>\n<p id=\"so_39059511_39065216_0\">[14.7.1/1] If a class template has been declared, but not defined, at the point of instantiation ([temp.point]), the instantiation yields an incomplete class type.</p>\n</blockquote>\n<p>(incomplete)</p>\n</hr>", "LastEditorUserId": "1737909", "LastActivityDate": "2016-08-21T20:22:02.373", "Score": "11", "CreationDate": "2016-08-21T14:20:02.953", "ParentId": "39059511", "CommentCount": "21", "OwnerUserId": "1737909", "LastEditDate": "2016-08-21T20:22:02.373"}});