post_cb({"19904461": {"CommentCount": "2", "AcceptedAnswerId": "19904529", "PostTypeId": "1", "LastEditorUserId": "1823524", "CreationDate": "2013-11-11T10:50:05.933", "LastActivityDate": "2013-11-12T10:42:18.323", "LastEditDate": "2013-11-12T10:42:18.323", "ViewCount": "119", "FavoriteCount": "1", "Title": "Order of global const definition", "Id": "19904461", "Score": "5", "Body": "<p>I suppose this question was already asked but I couldn't find it.\nIf I use macros instead of constants like this:</p>\n<pre><code> #define A 0\n #define B (A+1)\n #define C (B+A)\n</code></pre>\n<p>then it's guaranteed to be defined in strict order (A then B then C). \nBut what would happen if I use consts instead?</p>\n<pre><code> const int A = 0;\n const int B = A + 1;\n const int C = A + B;\n</code></pre>\n<p>If that's in function scope - it's fine. But what about global scope? As far as I know, order of definition of global variables is not guaranteed. And what about consts? </p>\n<p>I think that is the last thing that stops me from using consts instead of macros.</p>\n<p>(I'm also curious if there are any differences between C and C++ in this particular matter).</p>\n<p>UPD: The question should be like this: what are the differences (if any) between C and C++ in this matter?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1823524", "AnswerCount": "4"}, "19904527": {"ParentId": "19904461", "CommentCount": "7", "Body": "<p>Defining and initializing in this way at global scope is guaranteed to result in compile time error (in C):</p>\n<pre><code>error: initializer element is not constant\n</code></pre>\n", "OwnerUserId": "1606345", "PostTypeId": "2", "Id": "19904527", "Score": "2", "CreationDate": "2013-11-11T10:53:51.563", "LastActivityDate": "2013-11-11T10:53:51.563"}, "19904759": {"ParentId": "19904461", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Per \u00a73.6.2/2 in the standard:</p>\n<blockquote>\n<p id=\"so_19904461_19904759_0\">Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit.</p>\n</blockquote>\n<p>So your code is well-formed and has one result in any standard C++ compiler.</p>\n", "OwnerUserId": "952747", "LastEditorUserId": "584518", "LastEditDate": "2013-11-11T11:59:59.037", "Id": "19904759", "Score": "6", "CreationDate": "2013-11-11T11:05:07.923", "LastActivityDate": "2013-11-11T11:59:59.037"}, "19904529": {"ParentId": "19904461", "CommentCount": "2", "Body": "<p>Your code will work well as long as your 3 lines are in the same source file. (in C++). In C you'll get an error.</p>\n", "OwnerUserId": "480529", "PostTypeId": "2", "Id": "19904529", "Score": "3", "CreationDate": "2013-11-11T10:54:03.723", "LastActivityDate": "2013-11-11T10:54:03.723"}, "19906685": {"ParentId": "19904461", "CommentCount": "0", "Body": "<p>In <code>C</code> this is an error, this is because the <code>const</code> variables are allocated memory by c compiler.</p>\n<p>In <code>C++</code> compiler is free to embed the <code>const</code> variable in the code. Hence C++ wont throw any error. <code>const</code>variables are allocated memory only if you use address of (<code>&amp;</code>) operator with them. </p>\n<p>Hence your code will work in <code>C++</code> if the 3 lines are in that order.\nIn <code>C</code>, compiler will throw an error, because of the fact that initializing a <code>const</code> can not be done using variable!!!</p>\n", "Id": "19906685", "PostTypeId": "2", "OwnerDisplayName": "user1814023", "Score": "0", "CreationDate": "2013-11-11T12:44:18.780", "LastActivityDate": "2013-11-11T12:44:18.780"}, "bq_ids": {"n4140": {"so_19904461_19904759_0": {"section_id": 7151, "quality": 1.0, "length": 14}}, "n3337": {"so_19904461_19904759_0": {"section_id": 6895, "quality": 1.0, "length": 14}}, "n4659": {"so_19904461_19904759_0": {"section_id": 8655, "quality": 0.5714285714285714, "length": 8}}}});