post_cb({"14396189": {"Id": "14396189", "PostTypeId": "2", "Body": "<p>I think you want 9.4.2p3:</p>\n<blockquote>\n<p id=\"so_14395967_14396189_0\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). A static data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. [...] The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an <em>initializer</em>.</p>\n</blockquote>\n<p>The definition of a <em>template</em> static data member is a <em>template-declaration</em> (14p1).  The example given in 14.5.1.3p1 is:</p>\n<pre><code>template&lt;class T&gt; class X {\n  static T s;\n};\ntemplate&lt;class T&gt; T X&lt;T&gt;::s = 0;\n</code></pre>\n<p>However, as above a <code>constexpr static</code> or <code>const static</code> member whose in-class declaration specifies an <em>initializer</em> should not have an <em>initializer</em> in its namespace scope definition, so the syntax becomes:</p>\n<pre><code>template&lt;class T&gt; class X {\n  const static T s = 0;\n};\ntemplate&lt;class T&gt; T X&lt;T&gt;::s;\n</code></pre>\n<p>The difference with the non-array (i.e. integral or enumeration) static constexpr data member is that its use in lvalue-to-rvalue conversion is not odr-use; you would only need to define it if taking its address or forming a const reference to it.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2013-01-18T09:54:11.837", "Score": "10", "CreationDate": "2013-01-18T09:47:40.370", "ParentId": "14395967", "CommentCount": "2", "OwnerUserId": "567292", "LastEditDate": "2013-01-18T09:54:11.837"}, "bq_ids": {"n4140": {"so_14395967_14395967_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5907}, "so_14395967_14396189_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5908}}, "n3337": {"so_14395967_14395967_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5679}, "so_14395967_14396189_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5680}}, "n4659": {"so_14395967_14395967_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7389}, "so_14395967_14396189_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 7390}}}, "14395967": {"ViewCount": "6385", "Body": "<p>Static class members in C++ have caused a little confusion for me due to the standard's verbiage:</p>\n<blockquote>\n<p id=\"so_14395967_14395967_0\"><em>9.4.2  Static data members</em> <strong>[class.static.data]</strong></p>\n<p id=\"so_14395967_14395967_1\">The declaration of a static data member in its class definition is not a  definition...</p>\n</blockquote>\n<p>However a <em>constexpr</em> is required to be initialized (AFAIK, couldn't find a quote from the standard) at its declaration (e.g., in the class definition).</p>\n<p>Because of the restrictions on constexpr I had actually forgotten about the requisite for static members to be defined outside of the class, until I tried accessing a static constexpr array. <a href=\"https://stackoverflow.com/questions/8016780/undefined-reference-to-static-constexpr-char\">This related question</a> provides the correct way of defining the array member, but I'm interested as to the implications on this definition in a class template.</p>\n<p>This is what I ended up with:</p>\n<pre><code>template&lt;typename T&gt;\nclass MyClass\n{\nprivate:\n  static constexpr std::size_t _lut[256] = { /* ... */ };\n  T _data;\n\npublic:\n  static constexpr std::size_t GetValue(std::size_t n) noexcept\n  {\n    return _lut[n &amp; 255];\n  }\n\n  // ...\n};\n\ntemplate&lt;typename T&gt;\nconstexpr std::size_t MyClass&lt;T&gt;::_lut[256];\n</code></pre>\n<p><strong>Is this the right syntax?</strong> Particularly the use of template in the definition feels awkward, but GCC seems to be linking everything appropriately.</p>\n<p>As a follow-up question, should non-array static constexpr members be similarly defined (with template definition outside of class)?</p>\n", "AcceptedAnswerId": "14396189", "Title": "Proper initialization of static constexpr array in class template?", "CreationDate": "2013-01-18T09:34:22.257", "Id": "14395967", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:24.913", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-14T19:26:59.617", "Score": "13", "OwnerUserId": "1136311", "Tags": "<c++><templates><c++11><static-members><constexpr>", "AnswerCount": "2"}, "22414046": {"Id": "22414046", "PostTypeId": "2", "Body": "<p>In case it helps anyone out, the following worked for me with GCC 4.7 using constexpr:</p>\n<pre><code>template&lt;class T&gt; class X {\n  constexpr static int s = 0;\n};\ntemplate&lt;class T&gt; constexpr int X&lt;T&gt;::s; // link error if this line is omitted\n</code></pre>\n<p>I'm not making any claims of whether this is \"proper\".  I'll leave that to those more qualified.</p>\n", "LastActivityDate": "2014-03-14T19:26:59.617", "CommentCount": "1", "CreationDate": "2014-03-14T19:26:59.617", "ParentId": "14395967", "Score": "10", "OwnerUserId": "1797414"}});