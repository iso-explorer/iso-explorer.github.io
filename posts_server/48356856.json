post_cb({"bq_ids": {"n4140": {"so_48356856_48357402_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 7110}, "so_48356856_48357402_0": {"length": 20, "quality": 1.0, "section_id": 7081}}, "n3337": {"so_48356856_48357402_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 6854}, "so_48356856_48357402_0": {"length": 20, "quality": 1.0, "section_id": 6825}}, "n4659": {"so_48356856_48357402_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 8611}, "so_48356856_48357402_0": {"length": 20, "quality": 1.0, "section_id": 8582}}}, "48357402": {"Id": "48357402", "PostTypeId": "2", "Body": "<p>The key difference is that a using declaration is, well, a declaration. While a using directive is not. Sounds stupid, I know, but that's the nature of the difference. The former actually adds declarations to a declarative region, while the latter only makes certain names usable in a declarative region.</p>\n<p>Making a name usable in a certain scope, as opposed to declaring it, is intended to be a much weaker thing. The former is not considered during qualified lookup, if there's another declaration with the same name, as <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.scope.hiding#4\" rel=\"nofollow noreferrer\">[basic.scope.hiding]/4</a> says:</p>\n<blockquote>\n<p id=\"so_48356856_48357402_0\">During the lookup of a name qualified by a namespace name,\n  declarations that would otherwise be made visible by a <em>using-directive</em>\n  can be hidden by declarations with the same name in the namespace\n  containing the <em>using-directive</em></p>\n</blockquote>\n<p>And that pretty much explains your first code snippet. There's a declaration for that name, on account of the using declaration, so the name made visible by the using directive isn't considered. Doesn't matter which comes first, a declaration is always stronger. </p>\n<p>Your second code snippet has two declarations for <code>p</code> in <code>Y</code>. And when it comes to those, the usual rules for declarations apply. The second one must declare the same thing, or the program is ill-formed. Nothing more to it, really.</p>\n<p>Finally, in your third code snippet, it's more of the same as in your first code snippet. <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.qual#4\" rel=\"nofollow noreferrer\">[basic.lookup.qual]/4</a> says this:</p>\n<blockquote>\n<p id=\"so_48356856_48357402_1\">A name prefixed by the unary scope operator \u200b<code>::\u200b</code> ([expr.prim]) is\n  looked up in global scope, in the translation unit where it is used.\n  The name shall be declared in global namespace scope or shall be a\n  name whose declaration is visible in global scope because of a\n  <em>using-directive</em> ([namespace.qual]). The use of <code>\u200b::</code>\u200b allows a global\n  name to be referred to even if its identifier has been hidden.</p>\n</blockquote>\n<p>So other than the namespace being looked up, everything else is just like your first example. You both declare it, and make it available by the using directive. The first paragraph I quoted determines which one must be picked.</p>\n", "LastActivityDate": "2018-01-20T14:40:56.187", "CommentCount": "4", "CreationDate": "2018-01-20T14:40:56.187", "ParentId": "48356856", "Score": "2", "OwnerUserId": "817643"}, "48356856": {"ViewCount": "63", "Body": "<p>Can you explain why this code works and prints 16;</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace X {\nint  p = 5;\n}\nnamespace Y {\nint  p = 16;\n\nusing namespace X;\n}\n\nint main()\n{\nstd::cout &lt;&lt; Y::p;\n}\n</code></pre>\n<p>and why this code throws error of multiple declaration</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace X {\nint  p = 5;\n}\nnamespace Y {\nint  p = 16;\n\nusing X::p;\n}\n\nint main()\n{\nstd::cout &lt;&lt; Y::p;\n}\n</code></pre>\n<p>I have heard that using directive isn't simply the process of using declaration of any name, as it seems to work differently</p>\n<p>But I can't understand why, could you give some detailed explanation ??</p>\n<p>similarly this one works fine printing 16, if I replace using the directive with just the declaration of X::p it will throw the same error</p>\n<pre><code> #include &lt;iostream&gt;\n\nnamespace X {\n    int  p = 5;\n}\n\nint  p = 16;\n\nusing namespace X;\n\nint main()\n{\n    std::cout &lt;&lt; ::p;\n    std::cout &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "48357402", "Title": "Using directive vs using declaration", "CreationDate": "2018-01-20T13:45:34.520", "LastActivityDate": "2018-01-20T14:40:56.187", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-20T13:58:30.190", "LastEditorUserId": "817643", "Id": "48356856", "Score": "2", "OwnerUserId": "9241516", "Tags": "<c++><scope><namespaces><using>", "AnswerCount": "1"}});