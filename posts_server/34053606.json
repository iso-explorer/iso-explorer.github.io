post_cb({"bq_ids": {"n4140": {"so_34053606_34053854_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5908}}, "n3337": {"so_34053606_34053854_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5680}}}, "34053606": {"ViewCount": "4990", "Body": "<p>I have some confusions regarding <code>static constexpr</code> member variables in C++11.</p>\n<h2>In first.hpp</h2>\n<pre><code>template&lt;typename T&gt;\nstruct cond_I\n{ static constexpr T value = 0; }; \n\n\n// specialization \ntemplate&lt;typename T&gt;\nstruct cond_I&lt; std::complex&lt;T&gt; &gt;\n{ static constexpr std::complex&lt;T&gt; value = {0,1}; }; \n</code></pre>\n<h2>In main() function</h2>\n<pre><code>cout &lt;&lt; cond_I&lt;double&gt;::value &lt;&lt; endl;            // this works fine\ncout &lt;&lt; cond_I&lt; complex&lt;double&gt; &gt;::value &lt;&lt; endl; // linker error\n</code></pre>\n<p>However if I add the following line to <code>first.hpp</code> everything works fine.</p>\n<pre><code>template&lt;typename T1&gt; \nconstexpr std::complex&lt;T1&gt; cond_I&lt; std::complex&lt;T1&gt; &gt;::value;\n</code></pre>\n<p>What I understand (I may be wrong) is, that <code>cond_I&lt; std::complex&lt;double&gt; &gt;::value</code> needs a definition, but in the previous case it only has the declaration. But then what about <code>cond_I&lt;double&gt;::value</code>? Why it does not require a definition? </p>\n<p>Again, in another header file, <code>second.hpp</code>, I have:</p>\n<h2>In second.hpp</h2>\n<pre><code>// empty struct\ntemplate&lt;typename T&gt;\nstruct eps\n{ };\n\n\n// special cases\ntemplate&lt;&gt;\nstruct eps&lt;double&gt;\n{\n  static constexpr double value = 1.0e-12;\n};\n\ntemplate&lt;&gt;\nstruct eps&lt;float&gt;\n{\n  static constexpr float value = 1.0e-6;\n};\n</code></pre>\n<p>In this case, following codes works perfectly without any definition of <code>eps&lt;&gt;::value</code>.</p>\n<h2>In main() function</h2>\n<pre><code>cout &lt;&lt; eps&lt;double&gt;::value &lt;&lt; endl;    //  works fine\ncout &lt;&lt; eps&lt;float&gt;::value &lt;&lt; endl;     //  works fine\n</code></pre>\n<p>Can someone please explain me the different behaviors of <code>static constexpr</code> member variables, in these scenarios?</p>\n<p>These behaviors are also the same for <code>gcc-5.2</code> and <code>clang-3.6</code>.</p>\n", "AcceptedAnswerId": "34053854", "Title": "Understanding static constexpr member variables", "CreationDate": "2015-12-02T21:43:50.133", "Id": "34053606", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-02T21:48:00.257", "LastEditorUserId": "5395216", "LastActivityDate": "2017-10-04T04:20:17.487", "Score": "12", "OwnerUserId": "5395216", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "1"}, "34053854": {"PostTypeId": "2", "Body": "<p>According to the standard <em>9.4.2/p3 Static data members [class.static.data]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34053606_34053854_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression (5.20). <strong>A static data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014 end note ] The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer.</strong></p>\n</blockquote>\n<p>As M.M earlier explained in the comments <code>ostream::operator&lt;&lt;(ostream&amp;, const complex&lt;T&gt;&amp;)</code> passes by reference so value is considered odr-used in the program. Thus, as the wording above dictates you have to provide a definition.</p>\n<p>Now as you\u2019ve already found out fundamental types are passed by value, that it is why no definition required.</p>\n", "LastActivityDate": "2017-10-04T04:20:17.487", "LastEditorUserId": "2461638", "Id": "34053854", "CommentCount": "1", "CreationDate": "2015-12-02T21:56:48.037", "ParentId": "34053606", "Score": "8", "OwnerUserId": "2352671", "LastEditDate": "2017-10-04T04:20:17.487"}});