post_cb({"21397053": {"Id": "21397053", "PostTypeId": "2", "Body": "<p>Class templates and function templates are instantiated, but alias templates are simply substituted.  And by getting rid of the member name <code>type</code>, you lose a chance at invoking the dependent name lookup rules.</p>\n<p>[N3285] 14.5.7p2:</p>\n<blockquote>\n<p id=\"so_21395786_21397053_0\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated type obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias template.</p>\n</blockquote>\n<p>So in the first case, you have:</p>\n<p>The definition of <code>struct derived</code> requires the implicit instantiation of <code>base&lt;derived&gt;</code>.  During this instantiation, we discover <code>base&lt;derived&gt;</code> has a member function template:</p>\n<pre><code>template &lt;typename Delayer=void&gt;\ntypename derived_value_type&lt;derived, Delayer&gt;::type foo();\n</code></pre>\n<p>The return type is dependent, so <code>type</code> is not yet looked up, and no specialization of <code>derived_value_type</code> is instantiated.  The instantiation finishes, and <code>base&lt;derived&gt;</code> and <code>derived</code> are both now complete types.</p>\n<p>In <code>main</code>, the expression <code>d.foo()</code> requires the implicit instantiation of <code>base&lt;derived&gt;::foo&lt;void&gt;()</code>.  Now the name <code>typename derived_value_type&lt;derived, void&gt;::type</code> is looked up, instantiating <code>derived_value_type&lt;derived, void&gt;</code> along the way.  The return type is found to be <code>int</code>.</p>\n<p>In the second case, <code>derived_value_type</code> is not a dependent name, so is bound to your alias template declaration at the definition of template <code>base&lt;D&gt;</code>.  The compiler could do the alias substitution either at the template definition or during each instantiation of the class, but either way you get a class template equivalent to:</p>\n<pre><code>template &lt;typename Derived&gt;\nstruct base\n{\n  template &lt;typename Delayer = void&gt;\n  typename Derived::value_type\n  foo(){ return {}; }\n};\n</code></pre>\n<p>The definition of <code>struct derived</code> requires the implicit instantiation of <code>base&lt;derived&gt;</code>.  During this instantiation, we discover <code>base&lt;derived&gt;</code> has a member function template:</p>\n<pre><code>template &lt;typename Delayer=void&gt;\ntypename derived::value_type foo();\n</code></pre>\n<p>But <code>derived::value_type</code> is not dependent, and <code>derived</code> is an incomplete type, so the code is ill-formed.</p>\n", "LastActivityDate": "2014-01-28T04:49:27.737", "Score": "4", "CreationDate": "2014-01-28T04:49:27.737", "ParentId": "21395786", "CommentCount": "0", "OwnerUserId": "459640"}, "bq_ids": {"n4140": {"so_21395786_21397053_0": {"length": 17, "quality": 1.0, "section_id": 166}}, "n3337": {"so_21395786_21397053_0": {"length": 17, "quality": 1.0, "section_id": 160}}, "n4659": {"so_21395786_21397053_0": {"length": 17, "quality": 1.0, "section_id": 170}}}, "21395786": {"ViewCount": "300", "Body": "<p>While thinking how <em>CRTP</em> can be improved in <strong>C++11</strong>, I ended with the following code:</p>\n<pre><code>template &lt;typename Derived, typename Delayer&gt;\nstruct derived_value_type\n{\n  typedef typename Derived::value_type type;\n};\n\ntemplate &lt;typename Derived&gt;\nstruct base\n{\n  template &lt;typename Delayer = void&gt;\n  typename derived_value_type&lt;Derived, Delayer&gt;::type\n  foo(){ return {}; }\n};\n\nstruct derived : base&lt;derived&gt;\n{\n  typedef int value_type;\n};\n\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main()\n{\n  derived d;\n  auto bar = d.foo();\n\n  std::cout &lt;&lt; typeid(bar).name() &lt;&lt; ':' &lt;&lt; bar &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I believe the previous code to be standard conformant, and it compiles and works with the major compilers (resulting in <code>i:0</code>). However, when I use a template alias instead, I get a compilation error due to <code>derived</code> being incomplete:</p>\n<pre><code>template &lt;typename Derived, typename Delayer&gt;\nusing derived_value_type = typename Derived::value_type;\n\n/*...*/\n\ntemplate &lt;typename Delayer = void&gt;\nderived_value_type&lt;Derived, Delayer&gt;\nfoo(){ return {}; }\n</code></pre>\n<p>Is this a compiler bug, or does the fact that the compiler can determinate that there is no real dependency with <code>Delayer</code> mean that the template alias is not a dependent type? Where is this specified in the standard?</p>\n", "AcceptedAnswerId": "21397053", "Title": "Template aliases and dependent names", "CreationDate": "2014-01-28T02:33:49.383", "Id": "21395786", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-01-28T04:49:27.737", "Score": "5", "OwnerUserId": "927034", "Tags": "<c++><templates><c++11><language-lawyer>", "AnswerCount": "1"}});