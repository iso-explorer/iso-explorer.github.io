post_cb({"8566147": {"CommentCount": "0", "AcceptedAnswerId": "8566300", "CreationDate": "2011-12-19T19:06:58.210", "LastActivityDate": "2011-12-19T19:26:57.737", "PostTypeId": "1", "ViewCount": "1657", "FavoriteCount": "1", "Title": "C++: Signed/unsigned mismatch when only using unsigned types", "Id": "8566147", "Score": "5", "Body": "<p>When I try to compile the following C++ program using the Visual Studio 2010 C++ compiler (X86) with warning level /W4 enabled, I get a signed/unsigned mismatch warning at the marked line.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstddef&gt;\n\nint main(int argc, char **argv)\n{\n    size_t idx = 42;\n    uint8_t bytesCount = 20;\n\n    // warning C4389: '==' : signed/unsigned mismatch\n    if (bytesCount + 1 == idx)\n    {\n        printf(\"Hello World\\n\");\n    }\n\n    // no warning\n    if (bytesCount == idx)\n    {\n        printf(\"Hello World\\n\");\n    }\n}\n</code></pre>\n<p>This confuses me, since I'm only using unsigned types. Since the comparison</p>\n<pre><code>bytesCount == idx\n</code></pre>\n<p>causes no such warning, it probably has to do with some strange implicit conversation that happens here.</p>\n<p>Thus: what is the reason why I get this warning and by what rules does this conversation happen (if this is the reason)?</p>\n", "Tags": "<c++><unsigned><signed><unsigned-integer>", "OwnerUserId": "497193", "AnswerCount": "4"}, "8566174": {"ParentId": "8566147", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since 1 is of type <code>int</code> the expression <code>bytesCount + 1</code> is <code>int</code> (signed).</p>\n<p>In fact when a type smaller than <code>int</code> is used in a mathematical expression it is promoted to <code>int</code>, so even <code>+ bytesCount</code> and <code>bytesCount + bytesCount</code> are considered <code>int</code> and not <code>uint8_t</code> (while <code>bytesCount + 1U</code> is an <code>unsigned int</code> since that is <em>larger</em> than <code>int</code>).</p>\n<p>The <a href=\"http://codepad.org/7ljGJs2b\" rel=\"nofollow\">following program</a> outputs <code>true</code> three times.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    unsigned short s = 1;\n    std::cout &lt;&lt; (&amp;typeid( s + 1U ) == &amp;typeid(1U)) &lt;&lt; std::endl;\n    std::cout &lt;&lt; (&amp;typeid( + s ) == &amp;typeid(1)) &lt;&lt; std::endl;\n    std::cout &lt;&lt; (&amp;typeid( s + s ) == &amp;typeid(1)) &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "3848", "LastEditorUserId": "3848", "LastEditDate": "2011-12-19T19:26:57.737", "Id": "8566174", "Score": "3", "CreationDate": "2011-12-19T19:09:59.997", "LastActivityDate": "2011-12-19T19:26:57.737"}, "8566344": {"ParentId": "8566147", "CommentCount": "2", "Body": "<p>The other answers already tell you that <code>bytesCount + 1</code> is interpreted as <code>signed int</code>. However, I'd like to add that in <code>bytesCount == idx</code>, <code>bytesCount</code> is <em>also</em> interpreted as <code>signed int</code>. Conceptually, it is first converted to <code>signed int</code>, and it is only converted to <code>unsigned int</code> after that. Your compiler does not warn about this, because it has enough information to know that there is not really problem. The conversion to <code>signed int</code> cannot possibly make <code>bytesCount</code> negative. Comparing <code>bytesCount + 1</code> is equally valid, equally safe, but just that slight bit more complex to make the compiler no longer recognise it as safe.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "8566344", "Score": "1", "CreationDate": "2011-12-19T19:23:32.677", "LastActivityDate": "2011-12-19T19:23:32.677"}, "8566300": {"ParentId": "8566147", "CommentCount": "0", "Body": "<p><code>1</code> is an <code>int</code>. The type of an integral arithmetic expression depends on the types involved. In this case, you have an <code>unsigned</code> type and a <code>signed</code> type where the <code>unsigned</code> type is smaller than the <code>signed</code> type. This falls under the C++ standard on expressions (section 5.10 [expr]): </p>\n<blockquote>\n<p id=\"so_8566147_8566300_0\">Otherwise, if the type of the operand with signed integer type can\n  represent all of the values of the type of the operand with unsigned\n  integer type, the operand with unsigned integer type shall be\n  converted to the type of the operand with signed integer type.</p>\n</blockquote>\n<p>I.e., the type of the expression <code>bytesCount + 1</code> is <code>int</code> which is signed by default.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "8566300", "Score": "5", "CreationDate": "2011-12-19T19:19:25.097", "LastActivityDate": "2011-12-19T19:19:25.097"}, "8566160": {"ParentId": "8566147", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>1 is a signed literal. Try bytesCount + 1U.</p>\n<p>The compiler is probably creating a temporary value of the signed type due to the addition of signed and unsigned values ( bytesCount + 1 )</p>\n", "OwnerUserId": "52534", "LastEditorUserId": "52534", "LastEditDate": "2011-12-19T19:14:01.980", "Id": "8566160", "Score": "9", "CreationDate": "2011-12-19T19:08:58.063", "LastActivityDate": "2011-12-19T19:14:01.980"}, "bq_ids": {"n4140": {"so_8566147_8566300_0": {"section_id": 5943, "quality": 1.0, "length": 25}}, "n3337": {"so_8566147_8566300_0": {"section_id": 5714, "quality": 1.0, "length": 25}}, "n4659": {"so_8566147_8566300_0": {"section_id": 7428, "quality": 1.0, "length": 25}}}});