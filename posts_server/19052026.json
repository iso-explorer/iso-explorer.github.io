post_cb({"19052026": {"CommentCount": "1", "AcceptedAnswerId": "19052078", "PostTypeId": "1", "LastEditorUserId": "1729108", "CreationDate": "2013-09-27T13:28:52.547", "LastActivityDate": "2015-01-12T13:41:02.963", "LastEditDate": "2013-09-27T17:08:10.137", "ViewCount": "3415", "FavoriteCount": "1", "Title": "will range based for loop in c++ preserve the index order", "Id": "19052026", "Score": "9", "Body": "<p>in c++11, if I use a range based for loop on vector, will it guarantee the iterating order?\nsay, will the following code blocks are guaranteed for same output?</p>\n<pre><code>vector&lt;T&gt; output;\nvector&lt;U&gt; V;\nfor( auto v: V) output.push_back(f(v));\n</code></pre>\n<p>vs </p>\n<pre><code>for(int i =0; i &lt; V.size(); ++i) output.push_back(f(V[i])); \n</code></pre>\n<p>what if it is not <code>vector</code> but <code>map</code> etc? </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "305669", "AnswerCount": "3"}, "19052078": {"ParentId": "19052026", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes the two codes are guaranteed to do the same. Though I don't have a link to the standard you can have a look <a href=\"http://www.stroustrup.com/C++11FAQ.html#for\" rel=\"nofollow\">here</a>. I quote: <code>You can read that as \"for all x in v\" going through starting with v.begin() and iterating to v.end().</code></p>\n", "OwnerUserId": "812912", "LastEditorUserId": "812912", "LastEditDate": "2015-01-12T13:41:02.963", "Id": "19052078", "Score": "10", "CreationDate": "2013-09-27T13:31:07.497", "LastActivityDate": "2015-01-12T13:41:02.963"}, "19052278": {"ParentId": "19052026", "CommentCount": "0", "Body": "<p>Yes, they are equivalent.  The standard guarantees in 6.5.4:</p>\n<blockquote>\n<p id=\"so_19052026_19052278_0\">For a range-based for statement of the form</p>\n<p id=\"so_19052026_19052278_1\">for ( for-range-declaration : expression ) statement</p>\n<p id=\"so_19052026_19052278_2\">let range-init be equivalent to the expression surrounded by parentheses ( expression )</p>\n<p id=\"so_19052026_19052278_3\">and for a range-based for statement of the form</p>\n<p id=\"so_19052026_19052278_4\">for ( for-range-declaration : braced-init-list ) statement</p>\n<p id=\"so_19052026_19052278_5\">let range-init be equivalent to the braced-init-list. In each case, a range-based for statement is equivalent to</p>\n</blockquote>\n<pre><code>{\n  auto &amp;&amp; __range = range-init;\n  for ( auto __begin = begin-expr,\n      __end = end-expr;\n      __begin != __end;\n      ++__begin ) {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_19052026_19052278_6\">where __range, __begin, and __end are variables defined for exposition only, and _RangeT is the type of the expression, and begin-expr and end-expr are determined as follows:\n  of the expression, and begin-expr and end-expr are determined as follows:</p>\n<p id=\"so_19052026_19052278_7\">\u2014 if _RangeT is an array type, begin-expr and end-expr are __range and __range + __bound, respectively, where __bound is the array bound. If _RangeT is an array of unknown size or an array of incomplete type, the program is ill-formed;</p>\n<p id=\"so_19052026_19052278_8\">\u2014 if _RangeT is a class type, the unqualified-ids begin and end are looked up in the scope of class _RangeT\n  as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, begin-\n  expr and end-expr are __range.begin() and __range.end(), respectively;</p>\n<p id=\"so_19052026_19052278_9\">\u2014 otherwise, begin-expr and end-expr are begin(_<em>range) and end(</em>_range), respectively, where begin and end are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup, namespace std is an associated namespace.</p>\n</blockquote>\n<p>Though your question about map is a bit nonsensical.  If it's an ordered map and you iterate through the map properly, then they're equivalent.  If it's an unordered map then your question doesn't really make much sense.</p>\n", "OwnerUserId": "483486", "PostTypeId": "2", "Id": "19052278", "Score": "9", "CreationDate": "2013-09-27T13:40:08.660", "LastActivityDate": "2013-09-27T13:40:08.660"}, "19052266": {"ParentId": "19052026", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes and no (It depends on the container in use):</p>\n<ul>\n<li>The range based for is a loop like for(iterator pos = range.begin(); pos !=\nrange.end(); ++pos) { /* with a range variable = *pos */ ... } </li>\n<li>An operator [] might do something different (eg. a std::map operator does a lookup on the key and create a new entry, if the key does not exist)</li>\n</ul>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nint main()\n{\n    typedef std::map&lt;int, int&gt; map;\n    map m = { { 0, 0 }, { 2, 2 }, { 4, 4 } };\n    for(const auto&amp; e : m) {\n        std::cout &lt;&lt; e.first &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    for(map::size_type i = 0; i &lt; m.size(); ++i) {\n        std::cout &lt;&lt; m[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>The result is:</p>\n<pre><code>0 2 4 \n0 0 2 0 4 \n</code></pre>\n<p>(The second result might be a good shot in the own foot or even intended)</p>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2013-09-27T15:47:40.843", "Id": "19052266", "Score": "10", "CreationDate": "2013-09-27T13:39:21.390", "LastActivityDate": "2013-09-27T15:47:40.843"}, "bq_ids": {"n4140": {"so_19052026_19052278_6": {"section_id": 3906, "quality": 0.6842105263157895, "length": 13}, "so_19052026_19052278_2": {"section_id": 3906, "quality": 0.8571428571428571, "length": 6}, "so_19052026_19052278_8": {"section_id": 3906, "quality": 0.8518518518518519, "length": 23}, "so_19052026_19052278_7": {"section_id": 3906, "quality": 0.9047619047619048, "length": 19}, "so_19052026_19052278_5": {"section_id": 3906, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_19052026_19052278_6": {"section_id": 3766, "quality": 0.6842105263157895, "length": 13}, "so_19052026_19052278_8": {"section_id": 3766, "quality": 0.8518518518518519, "length": 23}, "so_19052026_19052278_7": {"section_id": 3766, "quality": 0.9047619047619048, "length": 19}, "so_19052026_19052278_9": {"section_id": 3766, "quality": 0.7619047619047619, "length": 16}, "so_19052026_19052278_2": {"section_id": 3766, "quality": 0.8571428571428571, "length": 6}, "so_19052026_19052278_5": {"section_id": 3766, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_19052026_19052278_6": {"section_id": 4792, "quality": 0.5263157894736842, "length": 10}, "so_19052026_19052278_8": {"section_id": 4792, "quality": 0.7407407407407407, "length": 20}, "so_19052026_19052278_7": {"section_id": 4792, "quality": 0.7619047619047619, "length": 16}, "so_19052026_19052278_2": {"section_id": 4792, "quality": 0.7142857142857143, "length": 5}}}});