post_cb({"bq_ids": {"n4140": {"so_4243915_4243950_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 32}}, "n3337": {"so_4243915_4243950_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 29}}, "n4659": {"so_4243915_4243950_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "4243952": {"Id": "4243952", "PostTypeId": "2", "Body": "<p>I'd say it's safe, but why not using an uint16_t without going through this misleading cast? </p>\n<p>Types exists for communication also, not only for the sake of compilation process.</p>\n", "LastActivityDate": "2010-11-22T09:27:40.263", "CommentCount": "0", "CreationDate": "2010-11-22T09:27:40.263", "ParentId": "4243915", "Score": "1", "OwnerUserId": "347137"}, "4244011": {"Id": "4244011", "PostTypeId": "2", "Body": "<p>Assigning a number that cannot be represented in a signed type is implementation-defined. The next conversion however has a standard defined behaviour. So the outcome of the function is implementation defined, if that is safe or not, is a subjective matter. But portable across platforms or compilers it is not.</p>\n", "LastActivityDate": "2010-11-22T09:37:20.993", "CommentCount": "0", "CreationDate": "2010-11-22T09:37:20.993", "ParentId": "4243915", "Score": "0", "OwnerUserId": "86638"}, "4243915": {"ViewCount": "2594", "Body": "<p>Is this safe:</p>\n<pre><code>int main()\n{\n    boost::int16_t t1 = 50000; // overflow here.\n    boost::uint16_t t2 = (boost::uint16_t)t1;\n    std::cout &lt;&lt; t1 &lt;&lt; \" \"  &lt;&lt; t2 &lt;&lt;  std::endl;\n}\n</code></pre>\n<p>To be even more specific: I'm storing this data in a table which is using signed types in its schema, is it safe to store, and retrieve this data in this manner?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "4243950", "Title": "Casting between signed and unsigned", "CreationDate": "2010-11-22T09:22:26.587", "Id": "4243915", "CommentCount": "13", "LastEditDate": "2010-11-22T09:26:40.033", "PostTypeId": "1", "LastEditorUserId": "140719", "LastActivityDate": "2010-11-22T09:42:16.240", "Score": "1", "OwnerUserId": "502756", "Tags": "<c++><casting><unsigned><unsafe><signed>", "AnswerCount": "3"}, "4243950": {"Id": "4243950", "PostTypeId": "2", "Body": "<p>No, I believe this is implementation defined.  From the C++ draft standard, \u00a74.7/3</p>\n<blockquote>\n<p id=\"so_4243915_4243950_0\">If the destination type is signed, the\n  value is unchanged if it can be\n  represented in the destination type\n  (and bit-\ufb01eld width); otherwise, the\n  value is implementation-de\ufb01ned.</p>\n</blockquote>\n<p>This applies to the first statement.  <code>int16_t</code> is signed, and it can not represent 50000.  So the value of <code>t1</code> depends on the implementation.</p>\n<p>Once you know <code>t1</code>, <code>t2</code> is guaranteed by \u00a74.7/2 to be the lowest <code>uint16_t</code> congruent modulus 2^16 to <code>t1</code>.  Basically, <code>t1</code> mod 2^16.</p>\n", "LastEditorUserId": "47773", "LastActivityDate": "2010-11-22T09:42:16.240", "Score": "4", "CreationDate": "2010-11-22T09:27:20.637", "ParentId": "4243915", "CommentCount": "0", "OwnerUserId": "47773", "LastEditDate": "2010-11-22T09:42:16.240"}});