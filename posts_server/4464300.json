post_cb({"bq_ids": {"n4140": {"so_4464300_4464739_1": {"length": 4, "quality": 1.0, "section_id": 5414}, "so_4464300_4464481_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 5407}, "so_4464300_4464300_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 229}, "so_4464300_4464739_0": {"length": 4, "quality": 1.0, "section_id": 5407}}, "n3337": {"so_4464300_4464739_1": {"length": 4, "quality": 1.0, "section_id": 5209}, "so_4464300_4464481_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 5202}, "so_4464300_4464300_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 222}, "so_4464300_4464739_0": {"length": 4, "quality": 1.0, "section_id": 5202}}, "n4659": {"so_4464300_4464739_1": {"length": 4, "quality": 1.0, "section_id": 6836}, "so_4464300_4464481_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 6829}, "so_4464300_4464300_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 237}, "so_4464300_4464739_0": {"length": 4, "quality": 1.0, "section_id": 6829}}}, "4464481": {"Id": "4464481", "PostTypeId": "2", "Body": "<p>I guess explicit specialization is not the case there. You may write the similar code without templates:</p>\n<pre><code>struct A\n{\n    static const char* const str;\n};\n\ntypedef A C;\n\nconst char* const C::str = \"B\";\n</code></pre>\n<p>This code is absolutely correct even if you use C instead of A. C is just an alias.</p>\n<p>Just imagine how C++ code is processed. Typedefs are obviously expanded by compiler before template instantiation process is even started. The same as all comments are expanded before macros. As all macros are expanded by preprocessor before actual C++ parsing is even started. This simplifies everything.</p>\n<p>Concerning C++03 standard, take a look at that</p>\n<blockquote>\n<p id=\"so_4464300_4464481_0\">7.1.3/1 A name declared with the typedef specifier becomes a\n  typedef-name. Within the scope of its\n  declaration, a typedef-name is\n  <strong>syntactically</strong> equivalent to a keyword\n  and names the type associated with the\n  identifier in the way described in\n  clause 8. A typedef-name is thus a\n  synonym for another type. A\n  typedef-name does not introduce a new\n  type the way a class declaration (9.1)\n  or enum declaration does.</p>\n</blockquote>\n<p>I guess this paragraph explains clearly that <strong>C</strong> in your code is actually a template-id.</p>\n", "LastEditorUserId": "194635", "LastActivityDate": "2010-12-16T19:44:42.547", "Score": "0", "CreationDate": "2010-12-16T19:10:13.177", "ParentId": "4464300", "CommentCount": "4", "OwnerUserId": "194635", "LastEditDate": "2010-12-16T19:44:42.547"}, "4464739": {"Id": "4464739", "PostTypeId": "2", "Body": "<p>I think this is strictly ill-formed (at least according to C++ '03).</p>\n<p>My logic is that although a typedef (7.1.3/1):</p>\n<blockquote>\n<p id=\"so_4464300_4464739_0\">... is thus a synonym for another type.</p>\n</blockquote>\n<p>The standard still has words to explictily allow for a typedef to be used where a <code>class-name</code> is required (7.1.3/4):</p>\n<blockquote>\n<p id=\"so_4464300_4464739_1\">A typedef-name that names a class is a class-name</p>\n</blockquote>\n<p>There are no such words for <code>template-id</code>.</p>\n", "LastActivityDate": "2010-12-16T19:46:19.063", "CommentCount": "12", "CreationDate": "2010-12-16T19:46:19.063", "ParentId": "4464300", "Score": "4", "OwnerUserId": "11698"}, "4464300": {"ViewCount": "279", "Body": "<p>g++ 3.4.5 accepts this code:</p>\n<pre><code>template &lt;typename T&gt; struct A\n{\n    static const char* const str;\n};\n\nstruct B {};\n\ntypedef A&lt;B&gt; C;\n\ntemplate&lt;&gt; const char* const C::str = \"B\";\n// Equivalent to following?\n// template&lt;&gt; const char* const A&lt;B&gt;::str = \"B\";\n</code></pre>\n<p>But I'm not sure it's actually legal C++03.  In particular,</p>\n<blockquote>\n<p id=\"so_4464300_4464300_0\">[14.7p3]  In an explicit specialization declaration for a class template, a member of a class template or a class member template, the name of the class that is explicitly specialized shall be a template-id.</p>\n</blockquote>\n<p>Does this requirement say that the non-typedef version must be used at the end of this example?  Or have I misinterpreted something?</p>\n<p>Edit: Further evidence: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#403\" rel=\"nofollow\">Defect Report 403</a> suggests that it is incorrect to say a type (in that context, the type of an argument of a function call expression) is a <em>template-id</em> because <em>template-id</em> has a syntactic meaning, not a semantic one.  Later drafts of the Standard have used \"class template specialization\" instead of \"<em>template-id</em>\" in 3.4.2.</p>\n<p>This supports the argument that although <code>A&lt;B&gt;</code> and <code>C</code> represent the same type (and have identical or nearly identical semantic meaning), <code>A&lt;B&gt;</code> is a <em>template-id</em> and <code>C</code> is not, because the term <em>template-id</em> refers to the syntactic content as a sequence of tokens rather than the meaning of those tokens.</p>\n", "AcceptedAnswerId": "4464739", "Title": "explicit member specialization", "CreationDate": "2010-12-16T18:49:25.010", "Id": "4464300", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-12-16T23:38:58.663", "LastEditorUserId": "459640", "LastActivityDate": "2010-12-16T23:38:58.663", "Score": "4", "OwnerUserId": "459640", "Tags": "<c++><templates><language-lawyer><explicit-specialization>", "AnswerCount": "2"}});