post_cb({"2944794": {"CommentCount": "1", "AcceptedAnswerId": "2945818", "CreationDate": "2010-05-31T16:32:45.980", "LastActivityDate": "2010-05-31T20:24:03.933", "PostTypeId": "1", "ViewCount": "262", "FavoriteCount": "1", "Title": "Is a function reference sizeof portable?", "Id": "2944794", "Score": "2", "Body": "<p>Looking for a way to do a portable, safe, elements count for c-style arrays, I found this solution:</p>\n<pre><code>template &lt;typename T, unsigned N&gt;  char (&amp;arrayCountofHelper(T(&amp;)[N]))[N];\n#define ARRAY_COUNTOF(arr) (sizeof(arrayCountofHelper(arr)))\n</code></pre>\n<p>It seems like arrayCountofHelper is actually a reference to a function, and the macro ARRAY_COUNTOF uses the fact that the size of a function is the size of it's returned type.<br>\nIt works just fine.<br>\nHowever, when I tried to check if it's portable, I didn't find any evidence for that. I couldn't find any reference to sizeof(function reference) in the standard (14882/1998) and, in fact, I am not entirely sure I am allowed to even create a function reference any more (although the standard does mention it several times).<br>\nSo, does someone know where in the standard I should look? (Or, if I misinterpreted the declaration some how, what is the correct interpretation?)</br></br></br></p>\n<p>Thanks<br>\nOren  </br></p>\n<p>P.S. (for those of you who think I didn't find the appropriate solution for my problem)<br>\nI know I can always use</br></p>\n<pre><code>#define ARRAY_COUNTOF sizeof(arr)/sizeof(arr[0])\n</code></pre>\n<p>or even</p>\n<pre><code>template &lt;typename T, unsigned N&gt; size_t arrayCountof(T(&amp;)[N]) {return N;}\n</code></pre>\n<p>but the first will not check if arr is a array (or pointer) and the second is not usable inside static_assert.<br>\n(and I would have used std::tr1::array or std::vector, but this is a legacy code I am maintaining)</br></p>\n", "Tags": "<c++><templates><function>", "OwnerUserId": "157274", "AnswerCount": "2"}, "2945818": {"ParentId": "2944794", "CommentCount": "2", "Body": "<p>We will pick this apart loosely, I'm using INCITS+ISO+IEC+14882-2003. I'll quote the small stuff, but some of the more complex stuff is too large to quote.</p>\n<p><code>sizeof</code> is defined in \u00a75.3.3, and it says (abridged):</p>\n<blockquote>\n<p id=\"so_2944794_2945818_0\">The sizeof operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is not evaluated, or a parenthesized type-id.</p>\n</blockquote>\n<p>In other words, it yields the size of a type in bytes or finds the type of an expression and yields the size of that. We don't have a type, we have the expression <code>arrayCountofHelper(arr)</code>.</p>\n<p>You can dissect this expression by looking at the definitions of <code>primary-expression</code> and <code>postfix-expression</code> as defined in \u00a75.1 and \u00a75.2 respectively. You will find it is a <code>postfix-expression</code> and fits the requirements of a function call (\u00a75.2.2).</p>\n<p>Now back to <code>sizeof</code>. We only care about the type of this function call expression (so we can yield the size of it), and \u00a75.2.2/3 says:</p>\n<blockquote>\n<p id=\"so_2944794_2945818_1\">The type of the function call expression is the return type of the statically chosen function [...]. This type shall be a complete object type, a reference type or the type <code>void</code>.</p>\n</blockquote>\n<p>So we need to find the return type of the function that would be called (remember, this is all unevaluated) with <code>arrayCountofHelper(arr)</code>. <code>arrayCountofHelper</code> is a function template which we would be instantiating (\u00a714.7), so we need to do that before we have an instantiated function to get the return type of.</p>\n<p>All the template parameters need to have values (\u00a714.8.2), and by using the rules defined in \u00a714.8.2.1 we will find <code>T</code> and <code>N</code> by matching the array passed to the function with the functions parameter (which is a reference to an array). (For example, if <code>arr</code> was <code>int[10]</code>, <code>T</code> would be <code>int</code> and <code>N</code> would be 10.) Once we have those, the function can be instantiated.</p>\n<p>Once instantiated, the return type of the function would be <code>char(&amp;)[N]</code>*, a reference to an array of <code>N</code> <code>char</code>'s. (If you need help parsing, see \u00a78.3.5. There are also questions on SO on how to parse \"complex\" types.) So now we've found the type of the expression, we must take the size of it.</p>\n<p>\u00a75.3.3/2 defines how <code>sizeof</code> works with references and arrays (emphasis mine):</p>\n<blockquote>\n<p id=\"so_2944794_2945818_2\"><strong>When applied to a reference or a reference type, the result is the size of the referenced type.</strong> When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8). The result of applying sizeof to a base class subobject is the size of the base class type.70) <strong>When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of n elements is n times the size of an element.</strong></p>\n</blockquote>\n<p>The size of a reference type is the size of its referenced type, so we need to size of <code>char[N]</code>. The size of this is <code>N * sizeof(char)</code>. <code>char</code> is fundamental as it is the smallest type there is; that is, <code>sizeof(char)</code> is <em>always</em> one. (\u00a75.3.3/1) So the size yielded by this expression is <code>1 * N</code>, or what we wanted the whole time: <code>N</code>.</p>\n<p>And that's how it works.</p>\n<hr>\n<p>The reason this one is preferred over your last example of <code>arrayCountof</code> is because the result of <code>sizeof</code> is a <em>constant expression</em>, so can be used in places where a constant expression is required.</p>\n<p>It should be noted that in C++0x, we can get our clean no-macro syntax with:</p>\n<pre><code>template &lt;typename T, unsigned N&gt;\nconstexpr size_t arrayCountof(T(&amp;)[N]) {return N;}\n</code></pre>\n<hr>\n<p><sub>* The reason the function return type is a reference to an array and not an array is simply because you cannot return arrays. If you could, either choice would suffice.</sub></p>\n</hr></hr>", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "2945818", "Score": "4", "CreationDate": "2010-05-31T20:24:03.933", "LastActivityDate": "2010-05-31T20:24:03.933"}, "2944814": {"ParentId": "2944794", "CommentCount": "0", "Body": "<p>Oren,</p>\n<p>This is not a function reference. This is a function call expression, and it has a type - the type of the result. Sizeof can be applied to any expression that has a type.</p>\n", "OwnerUserId": "73656", "PostTypeId": "2", "Id": "2944814", "Score": "2", "CreationDate": "2010-05-31T16:36:07.247", "LastActivityDate": "2010-05-31T16:36:07.247"}, "bq_ids": {"n4140": {"so_2944794_2945818_1": {"section_id": 5990, "quality": 0.7894736842105263, "length": 15}, "so_2944794_2945818_0": {"section_id": 6076, "quality": 0.8235294117647058, "length": 14}, "so_2944794_2945818_2": {"section_id": 6077, "quality": 0.9322033898305084, "length": 55}}, "n3337": {"so_2944794_2945818_1": {"section_id": 5758, "quality": 0.8421052631578947, "length": 16}, "so_2944794_2945818_0": {"section_id": 5844, "quality": 0.8235294117647058, "length": 14}, "so_2944794_2945818_2": {"section_id": 5845, "quality": 0.9322033898305084, "length": 55}}, "n4659": {"so_2944794_2945818_1": {"section_id": 7490, "quality": 0.7368421052631579, "length": 14}, "so_2944794_2945818_0": {"section_id": 7572, "quality": 0.8235294117647058, "length": 14}, "so_2944794_2945818_2": {"section_id": 7573, "quality": 0.9322033898305084, "length": 55}}}});