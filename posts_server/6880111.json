post_cb({"6880159": {"ParentId": "6880111", "CommentCount": "5", "Body": "<p>C++0x lambdas are const by default, unlike the rest of the language. Consequently, your member-function variable must be const as well. The following should work:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;typename F&gt;\nvoid bar(F func) {\n    typedef void (F::*pm_t)() const;\n    pm_t pm = &amp;F::operator();\n}\n</code></pre>\n", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "6880159", "Score": "4", "CreationDate": "2011-07-30T00:01:40.627", "LastActivityDate": "2011-07-30T00:01:40.627"}, "6880148": {"ParentId": "6880111", "CommentCount": "0", "Body": "<p>According to 5.1.2 of the N3291 C++0x specification, the lambda's operator() is <code>const</code> unless you explicitly declare it <code>mutable</code>:</p>\n<blockquote>\n<p id=\"so_6880111_6880148_0\">This function call operator is declared <code>const</code> (9.3.1) if and only if the lambda-\n  expression\u2019s parameter-declaration-clause is not followed by <code>mutable</code>.</p>\n</blockquote>\n<p>You may be able to do some template metaprogramming magic to detect which is which.</p>\n<p>However, it should be noted that, once <code>func</code> goes out of scope, you can't use that member pointer anymore. And it is a member pointer, not a function pointer, so you can't convert between the two.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "6880148", "Score": "8", "CreationDate": "2011-07-30T00:00:22.187", "LastActivityDate": "2011-07-30T00:00:22.187"}, "6881430": {"ParentId": "6880111", "CommentCount": "0", "Body": "<p>Consider this:</p>\n<pre><code>int x=0;\nauto show = [x]() mutable\n{\n        x++;\n};\n\nshow();\n</code></pre>\n<p>The variable 'x' is being captured <strong>by-value</strong>, and without <code>mutable</code>, you cannot modify the local copy of this variable. Specify <code>mutable</code> to enable modification of this local copy. For by-value captures, it doesn't matter if value is modified, the original <code>x</code> variable won't be modified.</p>\n", "OwnerUserId": "264325", "PostTypeId": "2", "Id": "6881430", "Score": "1", "CreationDate": "2011-07-30T06:03:39.720", "LastActivityDate": "2011-07-30T06:03:39.720"}, "bq_ids": {"n4140": {"so_6880111_6880148_0": {"section_id": 5964, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_6880111_6880148_0": {"section_id": 5733, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_6880111_6880148_0": {"section_id": 7454, "quality": 0.6666666666666666, "length": 8}}}, "6880111": {"CommentCount": "1", "AcceptedAnswerId": "6880148", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2011-07-29T23:52:33.517", "LastActivityDate": "2011-11-16T21:30:34.557", "LastEditDate": "2011-11-16T21:30:34.557", "ViewCount": "843", "FavoriteCount": "1", "Title": "Why mutable lambda with pointer to member function?", "Id": "6880111", "Score": "3", "Body": "<p>I'd like to get my mucky paws on the <code>operator()</code> of a lambda function. The following seems up the task:</p>\n<pre><code>template &lt;typename F&gt;\nvoid bar(F func) {\n  void (F ::*pm)();\n  pm = &amp;F::operator();\n}\n</code></pre>\n<p>However, in the following, I need to include the <code>mutable</code> keyword. Why is that? Is it possible to above instead declare a pointer to member function, which can target arbitrary lambdas?</p>\n<pre><code>int main(int argc, char *argv[])\n{\n  bar([]() mutable {});\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><pointers><lambda><c++11>", "OwnerUserId": "2023370", "AnswerCount": "3"}});