post_cb({"36558915": {"CommentCount": "0", "AcceptedAnswerId": "36559249", "PostTypeId": "1", "LastEditorUserId": "1593077", "CreationDate": "2016-04-11T20:45:33.003", "LastActivityDate": "2016-04-11T21:29:52.817", "LastEditDate": "2016-04-11T21:27:41.907", "ViewCount": "91", "FavoriteCount": "2", "Title": "Can I use decltype() to avoid code duplication in explicit template instantiations?", "Id": "36558915", "Score": "6", "Body": "<p>I have a long template function declaration:</p>\n<pre><code>template &lt;typename T&gt; void foo(lots ofargs, goin here, andeven more, ofthese arguments, they just, dont stop);\n</code></pre>\n<p>with no overloads. and I want to explicitly instantiate it. I can write (say for <code>T</code> = <code>int</code>):</p>\n<pre><code>template void foo&lt;int&gt;(lots ofargs, goin here, andeven more, ofthese arguments, they just, dont stop);\n</code></pre>\n<p>But I really don't want to copy that long declaration. I would have <em>liked</em> to be able to say something like:</p>\n<pre><code>template &lt;typename T&gt; using bar = decltype(foo&lt;T&gt;);\n</code></pre>\n<p>and then:</p>\n<pre><code>template bar&lt;int&gt;;\n</code></pre>\n<p>Now, the first line compiles (GCC 4.9.3), but the second line doesn't. Can I make it work somehow? Or can I use <code>decltype()</code> some other way to avoid copying the declaration for the instantiation?</p>\n<p><strong>Note:</strong> I intentially used an example in which you can't deduce the type from just the arguments, since I want any solution to support this case as well.</p>\n", "Tags": "<c++><templates><code-duplication><decltype><explicit-instantiation>", "OwnerUserId": "1593077", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36558915_36559249_1": {"section_id": 252, "quality": 0.8666666666666667, "length": 26}}, "n3337": {"so_36558915_36559249_1": {"section_id": 243, "quality": 0.8666666666666667, "length": 26}}, "n4659": {"so_36558915_36559249_1": {"section_id": 259, "quality": 0.8666666666666667, "length": 26}}}, "36559249": {"ParentId": "36558915", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Sure. From [temp.explicit]:</p>\n<blockquote>\n<p id=\"so_36558915_36559249_0\">The syntax for explicit instantiation is:<br>\n  \u00a0\u00a0\u00a0\u00a0<em>explicit-instantiation</em>:<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0extern<sub>opt</sub> <code>template</code> <em>declaration</em> </br></br></p>\n<p id=\"so_36558915_36559249_1\">[...] If the explicit instantiation is for a function or member function, the <em>unqualified-id</em> in the declaration shall be either a <em>template-id</em> or, where all template arguments can be deduced, a\n  <em>template-name</em> or <em>operator-function-id</em>. <em>[ Note:</em> The declaration may declare a <em>qualified-id</em>, in which case the\n  <em>unqualified-id</em> of the <em>qualified-id</em> must be a <em>template-id</em>. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>We need a declaration. Let's pretend we're starting with:</p>\n<pre><code>template &lt;class T&gt; void foo(T ) { }\n</code></pre>\n<p>We can explicitly specialize via just:</p>\n<pre><code>template void foo&lt;char&gt;(char );   // template-id\ntemplate void foo(int );          // or just template-name, if the types can be deduced\n</code></pre>\n<p>This is the same as having written:</p>\n<pre><code>using Fc = void(char );\nusing Fi = void(int );\n\ntemplate Fc foo&lt;char&gt;;\ntemplate Fi foo;\n</code></pre>\n<p>Which is the same as having written:</p>\n<pre><code>template &lt;class T&gt; using F = decltype(foo&lt;T&gt; );\n\ntemplate F&lt;char&gt; foo&lt;char&gt;;\ntemplate F&lt;int&gt; foo;\n</code></pre>\n<p>Basically, the reason that <code>template bar&lt;int&gt;</code> doesn't work is that it's not a declaration. You need the name too.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-04-11T21:29:52.817", "Id": "36559249", "Score": "3", "CreationDate": "2016-04-11T21:07:16.117", "LastActivityDate": "2016-04-11T21:29:52.817"}});