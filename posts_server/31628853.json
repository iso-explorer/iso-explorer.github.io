post_cb({"31629062": {"ParentId": "31628853", "LastEditDate": "2015-07-25T17:17:45.210", "CommentCount": "2", "CreationDate": "2015-07-25T17:12:15.897", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "31629062", "Score": "4", "Body": "<p>GCC is wrong. Qualified name lookup does consider <code>N::i</code>; \u00a73.4.3.2/2 &amp; /3:</p>\n<blockquote>\n<p id=\"so_31628853_31629062_0\">For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set\n  <code>S(X, m)</code> is defined as follows: Let <code>S'(X, m)</code> be the set of all\n  declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code>\n  (7.3.1). If <code>S'(X, m)</code> is not empty, <code>S(X, m)</code> is <code>S'(X, m)</code>;\n  <strong>otherwise, <code>S(X, m)</code> is the union of <code>S(N</code><sub>i</sub><code>, m)</code> for all namespaces <code>N</code><sub>i</sub> nominated by using-directives in <code>X</code>\n  and its inline namespace set.</strong>\n<br><br>\n  Given <code>X::m</code> (where <code>X</code> is a user-declared namespace), or given <code>::m</code> (where\n  <code>X</code> is the global namespace), [\u2026] if <code>S(X, m)</code> has exactly one member, or if the\n  context of the reference is a using-declaration (7.3.3), <code>S(X, m)</code> is\n  the required set of declarations of <code>m</code>.</br></br></p>\n</blockquote>\n<p>There is only one namespace nominated by a using-directive in your program: <code>N</code>. It's therefore included in the union and <code>::i</code> is resolved to <code>N::i</code>.</p>\n<p>Note that GCC is inconsistent with its lookup: Using <code>::i</code> in another context is fine.</p>\n<pre><code>namespace N { int i; }\nusing namespace N;\n\nint main() {\n    ::i = 5;\n}\n</code></pre>\n<p>This <a href=\"http://coliru.stacked-crooked.com/a/af402f5204c6319b\" rel=\"nofollow\">compiles</a>. The only difference that a using-declaration makes as a context is shown in the above quote and does not affect the established conclusion.</p>\n", "LastActivityDate": "2015-07-25T17:17:45.210"}, "31628853": {"CommentCount": "0", "ViewCount": "102", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2015-07-25T16:49:18.323", "LastActivityDate": "2015-07-25T22:21:10.347", "Title": "Name lookup in using-declaration via using-directive", "AcceptedAnswerId": "31629071", "LastEditDate": "2015-07-25T22:21:10.347", "Id": "31628853", "Score": "6", "Body": "<p>Is the following program well-formed or ill-formed according to the c++ standard?</p>\n<pre><code>namespace N { int i; }\nusing namespace N;\nusing ::i;\nint main() {}\n</code></pre>\n<p>I get different results with different compilers:</p>\n<ul>\n<li>Clang (<a href=\"http://melpon.org/wandbox/permlink/c8vl7XbumyyS6vsw\" rel=\"nofollow\">http://melpon.org/wandbox/permlink/c8vl7XbumyyS6vsw</a>): No errors.</li>\n<li>GCC (<a href=\"http://melpon.org/wandbox/permlink/immhNeWFCMcCA800\" rel=\"nofollow\">http://melpon.org/wandbox/permlink/immhNeWFCMcCA800</a>): Error: 'i' not declared.</li>\n</ul>\n<p>Is this program well-formed or ill-formed according to the c++ standard? References to the c++ standard needed.</p>\n<p>I'm trying to figure out for which compiler I should file a bug.</p>\n", "Tags": "<c++><language-lawyer><using-directives><name-lookup><using-declaration>", "OwnerUserId": "1272610", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31628853_31629071_1": {"section_id": 7117, "quality": 0.7352941176470589, "length": 25}, "so_31628853_31629062_0": {"section_id": 7117, "quality": 0.5434782608695652, "length": 25}}, "n3337": {"so_31628853_31629071_1": {"section_id": 6861, "quality": 0.7352941176470589, "length": 25}, "so_31628853_31629062_0": {"section_id": 6861, "quality": 0.5434782608695652, "length": 25}}, "n4659": {"so_31628853_31629071_0": {"section_id": 8617, "quality": 1.0, "length": 18}, "so_31628853_31629071_1": {"section_id": 8618, "quality": 0.7352941176470589, "length": 25}, "so_31628853_31629062_0": {"section_id": 8618, "quality": 0.5434782608695652, "length": 25}}}, "31629071": {"ParentId": "31628853", "LastEditDate": "2015-07-25T17:27:28.163", "CommentCount": "1", "CreationDate": "2015-07-25T17:12:54.820", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "PostTypeId": "2", "Id": "31629071", "Score": "5", "Body": "<p>Well-formed. </p>\n<p>The <em>using-directive</em> doesn't introduce the name <code>i</code> in the global namespace, but it is used during lookup. The <em>using-declaration</em> uses qualified lookup to find <code>i</code>; qualified lookup in the presence of <em>using-directives</em> is specified in [3.4.3.2 p1, p2] (quotes from N4527, the current working draft):</p>\n<blockquote>\n<p id=\"so_31628853_31629071_0\">If the <em>nested-name-specifier</em> of a <em>qualified-id</em> nominates a namespace\n  (including the case where the <em>nested-name-specifier</em> is <code>::</code>, i.e.,\n  nominating the global namespace), the name specified after the\n  <em>nested-name-specifier</em> is looked up in the scope of the namespace. [...]</p>\n<p id=\"so_31628853_31629071_1\">For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set\n  <em>S(X,m)</em> is defined as follows: Let <em>S'(X,m)</em> be the set of all\n  declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code> (7.3.1). If\n  <em>S'(X,m)</em> is not empty, <em>S(X,m)</em> is <em>S'(X,m)</em>; otherwise, <em>S(X,m)</em> is the\n  union of <em>S(N<sub>i</sub>,m)</em> for all namespaces <em>N<sub>i</sub></em> nominated \n  by <em>using-directives</em> in <code>X</code> and its inline namespace set.</p>\n</blockquote>\n<p>So, for qualified lookup, the first step is to look for declarations of <code>i</code> made directly in the namespace indicated by the <em>nested-name-specifier</em> (<code>::</code> in this case). There are no such declarations, so lookup then proceeds to the second step, which is to form the set of all declarations of <code>i</code> found by qualified lookup in all namespaces nominated by <em>using-directives</em> in the global namespace. That set is comprised of <code>N::i</code>, which is the result of name lookup, and is introduced as a name in global namespace by the using declaration.</p>\n<p>I find it worth noting (although pretty obvious) that this definition of qualified lookup is recursive: using the notation in the quote, qualified lookup in each namespace <em>N<sub>i</sub></em> will first look for declarations made directly in <em>N<sub>i</sub></em>, then, if none is found, will in turn proceed to look in the namespaces nominated by <em>using-directives</em> in <em>N<sub>i</sub></em>, and so on.</p>\n<hr>\n<p>For what it's worth, MSVC accepts the code as well.</p>\n</hr>", "LastActivityDate": "2015-07-25T17:27:28.163"}});