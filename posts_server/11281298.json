post_cb({"bq_ids": {"n4140": {"so_11281298_13260745_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5573}, "so_11281298_13260745_4": {"length": 7, "quality": 1.0, "section_id": 5573}, "so_11281298_13260745_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 5573}, "so_11281298_13260745_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 5573}, "so_11281298_13260745_0": {"length": 28, "quality": 0.875, "section_id": 5573}}, "n3337": {"so_11281298_13260745_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 5355}, "so_11281298_13260745_4": {"length": 7, "quality": 1.0, "section_id": 5355}, "so_11281298_13260745_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 5355}, "so_11281298_13260745_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5355}, "so_11281298_13260745_0": {"length": 28, "quality": 0.875, "section_id": 5355}}, "n4659": {"so_11281298_13260745_1": {"length": 23, "quality": 0.8518518518518519, "section_id": 7020}, "so_11281298_13260745_4": {"length": 7, "quality": 1.0, "section_id": 7020}, "so_11281298_13260745_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 7020}, "so_11281298_13260745_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7020}, "so_11281298_13260745_0": {"length": 27, "quality": 0.84375, "section_id": 7020}}}, "13260745": {"Id": "13260745", "PostTypeId": "2", "Body": "<p>Okay, after responding to <a href=\"https://stackoverflow.com/questions/11281298/boost-any-range-performance-stdpreviterator-versus-iterator#comment17991728_11281298\">SplinterOfChaos's comment</a>, I realized something.  The problem is in your use of the any_range.  In particular, the 3rd argument, which indicates that the Reference argument is a <code>const int</code>. In the boost iterator facade, when the reference is not a real reference, it will either use <code>std::input_iterator_tag</code>, or not provide an STL equivalent tag.  </p>\n<p>It has to do with the fact, that strictly speaking, all forward, bidirectional, and random access STL iterators must use a real reference for their reference type.  From 24.2.5 of the C++11 standard:</p>\n<blockquote> A class or a built-in type X satisfies the requirements of a forward iterator if<p id=\"so_11281298_13260745_0\">\n\u2014 X satisfies the requirements of an input iterator (24.2.3),<p id=\"so_11281298_13260745_1\">\n\u2014 X satisfies the DefaultConstructible requirements (17.6.3.1),<p id=\"so_11281298_13260745_2\">\n\u2014 <b>if X is a mutable iterator, reference is a reference to T; if X is a const iterator, reference is a reference to const T</b>,<p id=\"so_11281298_13260745_3\">\n\u2014 the expressions in Table 109 are valid and have the indicated semantics, and <p id=\"so_11281298_13260745_4\">\n\u2014 objects of type X offer the multi-pass guarantee, described below.\n</p></p></p></p></p></blockquote>\n<p>In this case, it's returning an <code>std::input_iterator_tag</code> when queried for its <code>iterator_category</code>, which causes the call to <code>std::prev()</code> veer into <em>Undefined Behavior</em>.</p>\n<p>Either way, the solution is to change (if possible) your use of <code>boost::any_range</code> to the following:</p>\n<pre><code>  boost::any_range &lt;\n        const X_type,\n        boost::random_access_traversal_tag,\n        const X_type&amp;,\n        std::ptrdiff_t\n    &gt;\n</code></pre>\n<p>This will cause it to have an <code>iterator_category</code> of <code>std::random_access_iterator_tag</code>, and will perform the operation as you originally expected.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-23T11:05:46.693", "Score": "3", "CreationDate": "2012-11-06T22:53:29.977", "ParentId": "11281298", "CommentCount": "1", "OwnerUserId": "862231", "LastEditDate": "2017-05-23T12:30:30.880"}, "11281298": {"ViewCount": "815", "Body": "<p>I've recently begun to prefer the free functions <code>std::next</code> and <code>std::prev</code> to explicitly copying and incrementing/decrementing iterators. Now, I am seeing weird behavior in a pretty specific case, and I would appreciate any help demystifying it.</p>\n<p>I have an interpolation/extrapolation function operating on a <code>boost::any_range</code> of some <code>X_type</code>. The full definition of the range type is:</p>\n<pre><code>boost::any_range &lt;\n    const X_type,\n    boost::random_access_traversal_tag,\n    const X_type,\n    std::ptrdiff_t\n&gt;\n</code></pre>\n<p>The <code>any_range</code>, in this particular case, is assigned from an <code>iterator_range</code> holding two pointers to <code>const X_type</code>, which serves as an <code>X_type</code> view of about half of the <code>data()</code> area of a <code>vector&lt;char&gt;</code>.</p>\n<p>Compiling my application in MSVC 2010, everything works just fine.\nCompiling the same code in MinGW g++ 4.7.0, it seemed to hang in one particular location, which I've then narrowed down to this (slightly abbreviated):</p>\n<pre><code>// Previously ensured conditions:\n// 1) xrange is nonempty;\n// 2) yrange is the same size as xrange.\n\nauto x_equal_or_greater =\n    std::lower_bound(std::begin(xrange),std::end(xrange),xval);\n\nif (x_equal_or_greater == std::end(xrange))\n{\n    return *yit_from_xit(std::prev(x_equal_or_greater),xrange,yrange);\n}\n</code></pre>\n<p>Stepping through the code in gdb, I found out it wasn't getting stuck, just taking a very long time to return from the single <code>std::prev</code> call - which in libstdc++ is implemented in terms of <code>std::advance</code> and ultimately the <code>+=</code> operator.</p>\n<p>By merely replacing the <code>return</code> line with:</p>\n<pre><code>auto xprev=x_equal_or_greater;\n--xprev;\nreturn *yit_from_xit(xprev,xrange,yrange);\n</code></pre>\n<p>Performance is great again, and there's virtually no delay.</p>\n<p>I am aware of the overhead of using type-erased iterators (those of <code>any_range</code>), but even so, are the two cases above really supposed to carry such different costs? Or am I doing something wrong?</p>\n", "AcceptedAnswerId": "13260745", "Title": "Boost any_range performance: std::prev(iterator) versus --iterator", "CreationDate": "2012-07-01T10:43:42.333", "Id": "11281298", "CommentCount": "3", "LastEditDate": "2012-07-01T10:58:34.713", "PostTypeId": "1", "LastEditorUserId": "1494104", "LastActivityDate": "2014-11-23T11:05:46.693", "Score": "8", "OwnerUserId": "1494104", "Tags": "<c++><performance><boost><c++11><iterator>", "AnswerCount": "1"}});