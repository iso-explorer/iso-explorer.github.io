post_cb({"32519433": {"ParentId": "32519082", "LastEditDate": "2017-05-23T12:02:12.967", "CommentCount": "0", "CreationDate": "2015-09-11T08:54:43.807", "OwnerUserId": "60281", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32519433", "Score": "9", "Body": "<p>The compiler <em>knows</em> the type an expression (like <code>1 + 2</code>) evaluates to. That's just the way the language works -- both operands are of type <code>int</code> so the result is <code>int</code> as well. With <code>auto a</code>, you are just telling the compiler to \"use the type of the initializing expression\".</p>\n<p>The compiler does not have to do any additional work or deducing here. The <code>auto</code> keyword is merely relieving <em>you</em> from figuring out the expression and writing the correct type. (Which you might get wrong, with probably unintended side-effects -- see <a href=\"https://stackoverflow.com/questions/32510183\">this question</a> (and the <a href=\"https://stackoverflow.com/a/32510343/841108\">top answer</a>) for an example how <code>auto</code> can avoid unintended run-time conversions and copying.</p>\n<hr>\n<p>The <code>auto</code> keyword really comes into its own with iterators:</p>\n<pre><code>std::vector&lt; std::string &gt;::const_iterator it = foo.cbegin();\n</code></pre>\n<p>versus</p>\n<pre><code>auto it = foo.cbegin();\n</code></pre>\n</hr>", "LastActivityDate": "2015-09-12T10:21:20.297"}, "32519417": {"ParentId": "32519082", "LastEditDate": "2017-08-26T14:50:41.983", "CommentCount": "2", "CreationDate": "2015-09-11T08:54:04.003", "OwnerUserId": "3313438", "LastEditorUserId": "3313438", "PostTypeId": "2", "Id": "32519417", "Score": "5", "Body": "<h2>How does it work:</h2>\n<p>From the <em>ISO/IEC</em>:</p>\n<blockquote>\n<p id=\"so_32519082_32519417_0\">...The auto specifier is a placeholder for a type to be deduced (7.1.6.4). The other simple-type-specifiers specify\n  either a previously-declared user-defined type or one of the fundamental types...</p>\n</blockquote>\n<h2>7.1.6.4 auto specifier</h2>\n<blockquote id=\"so_32519082_32519417_1\">\n<ol>\n<li>The auto type-specifier signifies that the type of a variable being declared shall be deduced from its initializer\n  or that a function declarator shall include a trailing-return-type.</li>\n<li>The auto type-specifier may appear with a function declarator with a trailing-return-type in any\n  context where such a declarator is valid.</li>\n<li>Otherwise, the type of the variable is deduced from its initializer. The name of the variable being declared\n  shall not appear in the initializer expression. This use of auto is allowed when declaring variables in a\n  block, in namespace scope, and in a for-init-statement; auto shall appear as one of the decl-specifiers in the decl-specifier-seq and the decl-specifier-seq shall be followed by one or more initdeclarators, each of which shall have a non-empty initializer...</li>\n</ol>\n</blockquote>\n<p>Example: </p>\n<pre><code>auto x = 5; // OK: x has type int\nconst auto *v = &amp;x, u = 6; // OK: v has type const int*, u has type const int\nstatic auto y = 0.0; // OK: y has type double\nauto int r; // error: auto is not a storage-class-specifier\n</code></pre>\n<h2>Is it faster:</h2>\n<p>The simple answer is <strong>Yes</strong>, by using it a lot of type conversions could be omitted, however, if not used properly it could become great source of errors.</p>\n<p>In one of the interviews from Bjarne Stroustrup, he said that <code>auto</code> keyword has resulted in win-win situation for coders and compiler implementers. </p>\n", "LastActivityDate": "2017-08-26T14:50:41.983"}, "32519082": {"CommentCount": "7", "CreationDate": "2015-09-11T08:36:05.900", "PostTypeId": "1", "AcceptedAnswerId": "32519112", "LastEditorUserId": "596781", "LastActivityDate": "2017-08-26T14:50:41.983", "LastEditDate": "2015-09-11T09:03:01.130", "ViewCount": "996", "FavoriteCount": "1", "Title": "Is `auto` specifier slower in compilation time?", "Id": "32519082", "Score": "10", "Body": "<p>Since C++11 we can use <code>auto a = 1+2</code> instead of <code>int a = 1+2</code> and the compiler deduces the type of <code>a</code> by itself. How does it work? Is it slower during compile time (more operations) than declaring the type myself?</p>\n", "Tags": "<c++><c++11><types><auto><compile-time>", "OwnerUserId": "3512538", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32519082_32519417_0": {"section_id": 5438, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_32519082_32519417_0": {"section_id": 5233, "quality": 0.8333333333333334, "length": 15}, "so_32519082_32519417_1": {"section_id": 5242, "quality": 0.5373134328358209, "length": 36}}, "n4659": {"so_32519082_32519417_0": {"section_id": 6865, "quality": 0.7222222222222222, "length": 13}}}, "32519112": {"ParentId": "32519082", "LastEditDate": "2017-05-23T12:17:39.233", "CommentCount": "5", "CreationDate": "2015-09-11T08:37:50.467", "OwnerUserId": "841108", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32519112", "Score": "15", "Body": "<p><code>auto</code> is asking the C++11 <em>compiler</em> to make some <em>limited</em> kind of <a href=\"https://en.wikipedia.org/wiki/Type_inference\" rel=\"nofollow noreferrer\">type inference</a> (look into <a href=\"http://ocaml.org/\" rel=\"nofollow noreferrer\">Ocaml</a> if you want some more sexy type inference language). But the overhead is compile-time only. </p>\n<p>If you replace <code>auto a=1+2;</code> with <code>int a=1+2;</code> (both have the same meaning, see <a href=\"https://stackoverflow.com/a/32519417/841108\">answer by simplicis</a>) and if you ask your compiler to <a href=\"https://en.wikipedia.org/wiki/Optimizing_compiler\" rel=\"nofollow noreferrer\">optimize</a> (and probably even without asking for optimizations) you'll probably get the same <a href=\"https://en.wikipedia.org/wiki/Machine_code\" rel=\"nofollow noreferrer\">machine code</a>. See also <a href=\"https://stackoverflow.com/a/32413422/841108\">this</a>.</p>\n<p>If using <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a> try to compile a small C++11 <code>foo.cc</code> file with <code>g++ -Wall -fverbose-asm -O -S foo.cc</code> and look (with an editor) into the generated <code>foo.s</code> assembler file. You'll see no difference in the generated code (but the assembler file might perhaps change slightly, e.g. because of metadata like debug information etc.)</p>\n<p>If you are concerned about <em>slower compile-time</em> I guess that using <code>auto</code> is not a decisive factor (probably, overloading could be more costly in compilation time). C++11 is nearly designed to practically <em>require</em> a lot of <a href=\"https://en.wikipedia.org/wiki/Optimizing_compiler\" rel=\"nofollow noreferrer\">optimizations</a> (in particular sophisticated inlining and constant folding and dead code elimination), and its \"parsing\" (notably header inclusion and template expansion) is costly. </p>\n<p><a href=\"https://stackoverflow.com/a/12438040/841108\">Precompiling headers</a> and parallel builds with <code>make -j</code> (and perhaps <a href=\"https://ccache.samba.org/\" rel=\"nofollow noreferrer\"><code>ccache</code></a> or <code>distcc</code>) might help in improving the overall compilation time, much more than avoiding <code>auto</code>.</p>\n<p>And if you wanted to systematically avoid <code>auto</code>  (in particular in <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow noreferrer\">range-for</a> loops like <code>std::map&lt;std::string,int&gt; dict; for (auto it: dict) {</code>...<code>}</code>) you'll end up typing much more source code (whose parsing and checking takes significant time) with more risks of error. As explained <a href=\"https://stackoverflow.com/a/32510343/841108\">here</a>, you might guess slightly wrongly the type, and expliciting it (slightly wrongly) might slow down the execution of your code because of additional conversions.</p>\n<p>If using <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a> you might pass the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html\" rel=\"nofollow noreferrer\"><code>-ftime-report</code></a> to <code>g++</code> and get time measurements about various GCC passes and phases.</p>\n", "LastActivityDate": "2015-09-12T11:35:49.970"}});