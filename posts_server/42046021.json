post_cb({"42046360": {"ParentId": "42046021", "LastEditDate": "2017-02-04T22:40:37.030", "CommentCount": "2", "CreationDate": "2017-02-04T22:29:00.453", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "42046360", "Score": "3", "Body": "<p><code>mutable</code> doesn't matter here. </p>\n<p>In [expr.prim.lambda]:</p>\n<blockquote>\n<p id=\"so_42046021_42046360_0\">An <em>init-capture</em> behaves as if it declares and explicitly captures a variable of the form \u201c<code>auto</code> init-capture ;\u201d</p>\n</blockquote>\n<p>And from [dcl.type.simple]:</p>\n<blockquote>\n<p id=\"so_42046021_42046360_1\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows: [...] if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>.</p>\n</blockquote>\n<p>So <code>decltype(j)</code> should be <code>int</code>. This is a gcc bug, reported as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79378\" rel=\"nofollow noreferrer\">79378</a>.</p>\n", "LastActivityDate": "2017-02-04T22:40:37.030"}, "42046021": {"CommentCount": "0", "ViewCount": "102", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-02-04T21:50:37.250", "LastActivityDate": "2017-02-04T22:40:37.030", "Title": "Non mutable lambda function: are copy-captured variables allowed to be const?", "AcceptedAnswerId": "42046360", "LastEditDate": "2017-05-23T10:29:28.723", "Id": "42046021", "Score": "2", "Body": "<p>While trying to reply to <a href=\"https://stackoverflow.com/questions/42044116/no-matching-function-stdforward-with-lambdas\">another question</a> here on SO, I found a difference in how GCC and clang work with lambdas.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nint main() {\n    int i = 0;\n    [j = i](){ static_assert(std::is_same&lt;decltype(j), const int&gt;::value, \"!\"); }();\n}\n</code></pre>\n<p>In this case, clang <a href=\"http://melpon.org/wandbox/permlink/FvgXYNuXpRt4oSA9\" rel=\"nofollow noreferrer\">rejects the snippet</a>, while GCC <a href=\"http://melpon.org/wandbox/permlink/GBP6v7Y3IMTAj1ee\" rel=\"nofollow noreferrer\">accepts the code</a>.</p>\n<p>On the other side, both of them accept the code below (for obvious reasons):</p>\n<pre><code>#include &lt;type_traits&gt;\n\nint main() {\n    int i = 0;\n    [j = i]()mutable{ static_assert(std::is_same&lt;decltype(j), int&gt;::value, \"!\"); }();\n}\n</code></pre>\n<p>Are compilers allowed to declare variables captured by copy as const for non-mutable lambdas?</p>\n", "Tags": "<c++><c++11><lambda><language-lawyer>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42046021_42046360_1": {"section_id": 5440, "quality": 0.8888888888888888, "length": 16}, "so_42046021_42046360_0": {"section_id": 5970, "quality": 1.0, "length": 9}}, "n3337": {"so_42046021_42046360_1": {"section_id": 5235, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_42046021_42046360_0": {"section_id": 7469, "quality": 1.0, "length": 9}, "so_42046021_42046360_1": {"section_id": 6867, "quality": 0.8888888888888888, "length": 16}}}});