post_cb({"3887788": {"ParentId": "3887759", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Other answers discuss why you're getting a compile-time failure (which is what most questions are about when such failures are the most prominent part of the question).  However. regarding your explicit question, \"whence the second constructor came?\":</p>\n<p>12.8/4 \"Copying class objects\" of standard says:</p>\n<blockquote>\n<p id=\"so_3887759_3887788_0\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n</blockquote>\n<p>If you'd like to avoid the implicit copy-ctor from being used, one of a few 'non-copyable' idioms can be used (such as <code>boost::noncopyable</code>): <a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-copyable_Mixin\" rel=\"nofollow\">http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-copyable_Mixin</a></p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-10-08T05:00:12.777", "Id": "3887788", "Score": "6", "CreationDate": "2010-10-08T04:49:58.380", "LastActivityDate": "2010-10-08T05:00:12.777"}, "3887759": {"CommentCount": "0", "ViewCount": "129", "CreationDate": "2010-10-08T04:43:05.270", "LastActivityDate": "2010-10-08T05:00:12.777", "Title": "Trouble understanding whence a copy constructor came", "AcceptedAnswerId": "3887788", "PostTypeId": "1", "Id": "3887759", "Score": "2", "Body": "<p>I have the following small code:</p>\n<pre><code>template &lt;typename T&gt;\nclass V\n{\n    public:\n        T x;\n\n    explicit V(T &amp; _x)\n    :x(_x){}\n\n};\n\nint main()\n{\n    V&lt;float&gt; b(1.0f); // fails\n    return 0;\n}\n</code></pre>\n<p>And it happens to fail. The message returned by g++ 4.4.5 is:</p>\n<blockquote>\n<p id=\"so_3887759_3887759_0\"><code>g++ -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF\"main.d\" -MT\"main.d\" -o\"main.o\" \"../main.cpp\"</code><br>\n<code>../main.cpp: In function \u2018int main()\u2019:</code><br>\n<code>../main.cpp:19: error: no matching function for call to \u2018V&lt;float&gt;::V(float)\u2019</code><br>\n<code>../main.cpp:10: note: candidates are: V&lt;T&gt;::V(T&amp;) [with T = float]</code><br>\n<code>../main.cpp:6: note:  V&lt;float&gt;::V(const V&lt;float&gt;&amp;)</code> </br></br></br></br></p>\n</blockquote>\n<p>The thing is... whence the second constructor came? I really have no clue...</p>\n", "Tags": "<c++><templates><constructor>", "OwnerUserId": "469837", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3887759_3887788_0": {"section_id": 456, "quality": 1.0, "length": 10}}, "n3337": {"so_3887759_3887788_0": {"section_id": 447, "quality": 1.0, "length": 10}}, "n4659": {"so_3887759_3887788_0": {"section_id": 479, "quality": 1.0, "length": 10}}}, "3887793": {"ParentId": "3887759", "CommentCount": "0", "Body": "<p>Compiler has supplied a copy constructor and assignment operator to your class. It is trying to match that copy constructor with your statement in <code>main</code>. The problem with this code is that in the constructor of class <code>V</code> you are taking the parameter as a non-const reference. When you do <code>V&lt;float&gt; b(1.0f)</code>, compiler will create an unnamed temporary variable of type <code>float</code> for the value <code>1.0f</code>. However, this unnamed temporary can not be bound to a non-const reference, it can be bound only to a const reference. Hence you need to change the constructor signature to <code>explicit V(const T &amp; _x)</code>.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "3887793", "Score": "4", "CreationDate": "2010-10-08T04:51:44.033", "LastActivityDate": "2010-10-08T04:51:44.033"}});