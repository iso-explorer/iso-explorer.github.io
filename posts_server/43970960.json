post_cb({"43970960": {"CommentCount": "6", "AcceptedAnswerId": "43971134", "PostTypeId": "1", "LastEditorUserId": "1944004", "CreationDate": "2017-05-15T02:54:01.487", "LastActivityDate": "2017-05-19T02:19:08.270", "LastEditDate": "2017-05-19T02:19:08.270", "ViewCount": "93", "FavoriteCount": "1", "Title": "Does the compiler generate a different type for each lambda?", "Id": "43970960", "Score": "3", "Body": "<blockquote>\n<p id=\"so_43970960_43970960_0\"><em>Disclaimer:</em>  Do not use the code in this question.  It invokes undefined behaviour.  The core statement of the question, whether the compiler generates a new type for each lambda, and the corresponding answer remain valid.</p>\n</blockquote>\n<p>To take get a function pointer to a lambda with a capture I came up with the following trick:</p>\n<pre><code>auto f = [&amp;a] (double x) { return a*x; };\nstatic auto proxy = f;\ndouble(*ptr)(double) = [] (double x) { return proxy(x); };\n// do something with ptr\n</code></pre>\n<p>I assign the lambda with a capture (which might be a function parameter) to a static variable inside the function, so I do not have to capture it when using it in the other lambda.  The other captureless lambda can then happily decay to a function pointer which I can pass to some shared library.</p>\n<p>Now one could attempt to generalize this:</p>\n<pre><code>template &lt; typename F &gt;\ndecltype(auto) get_ptr(F f)\n{\n  static auto proxy = f;\n  return [] (auto ... args) { return proxy(args...); };\n}\n</code></pre>\n<p>However, as <code>proxy</code> is a static variable it will be overwritten on each call to the function.  Because it is a template, I think that it will be overwritten only when I call the same instantiation, i.e. each instantiation has it's own static <code>proxy</code>.</p>\n<p>Nevertheless, the following works:</p>\n<pre><code>#include &lt;cassert&gt;\n\ntemplate &lt; typename F &gt;\ndecltype(auto) get_ptr(F f)\n{\n  static auto proxy = f;\n  return [] (auto ... args) { return proxy(args...); };\n}\n\nint main()\n{\n  auto f1 = [ ](double,double) { return 1; };\n  auto f2 = [=](double,double) { return 2; };\n  auto f3 = [&amp;](double,double) { return 3; };\n  auto f4 = [&amp;](double,double) { return 4; };\n  auto f5 = [ ](double,double) { return 5; };\n\n  int(*p1)(double,double) = get_ptr(f1);\n  int(*p2)(double,double) = get_ptr(f2);\n  int(*p3)(double,double) = get_ptr(f3);\n  int(*p4)(double,double) = get_ptr(f4);\n  int(*p5)(double,double) = get_ptr(f5);\n\n  assert( p1(0,0) == 1 );\n  assert( p2(0,0) == 2 );\n  assert( p3(0,0) == 3 );\n  assert( p4(0,0) == 4 );\n  assert( p5(0,0) == 5 );\n}\n</code></pre>\n<p>This looks suspicious as for <code>get_ptr(f1)</code> and <code>get_ptr(f5)</code> one might expect the same types to be deduced.  However, lambdas are compiler generated structs and it seems as if the compiler would generate a different type for each lambda, regardless of whether previous lambdas look like they could be reused.</p>\n<p>So the above trick would be extremely useful for me under the condition that the compiler will definitely generate a different type for each lambda.  If this is not the case the generalisation of my hack is useless.</p>\n", "Tags": "<c++><templates><lambda><c++14>", "OwnerUserId": "1944004", "AnswerCount": "2"}, "43998243": {"ParentId": "43970960", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>What you've effectively done is created a singleton holding a copy of the lambda, distinct for each type of lambda (which per <a href=\"http://eel.is/c++draft/expr.prim.lambda.closure#1\" rel=\"nofollow noreferrer\">[expr.prim.lambda.closure]/1</a> means every lambda expression). This works generally because lambdas are immutable, however, a mutable lambda would reveal the difference:</p>\n<pre><code>auto f6 = [i = 1]( double, double ) mutable { return 6 * i++; };\nint(*p6)(double,double) = get_ptr(f6);\n\nassert( p6(0,0) == 6 );\nassert( p6(0,0) == 12 );\n\nint(*p6_prime)(double,double) = get_ptr(f6);\nassert( p6_prime(0,0) == 18 ); // (!) p6_prime === p6\nassert( p6(0,0) == 24 );\n\nassert( f6(0,0) == 6 );\nassert( f6(0,0) == 12 );\nassert( f6(0,0) == 18 );\nassert( f6(0,0) == 24 );\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/Qw9tyPpN0EZn6AhJ\" rel=\"nofollow noreferrer\">Live demo on wandbox</a></p>\n<p>The reason for this is an incorrect assumption in your original write-up:</p>\n<blockquote>\n<p id=\"so_43970960_43998243_0\">However, as proxy is a static variable it will be overwritten on each call to the function.</p>\n</blockquote>\n<p>That's not true. The <code>static</code> variable is set once, the first time the function is called. Further calls to the same function will not evaluate the statement, so <code>proxy</code> will retain the value from the first time that particular template instantiation of <code>get_ptr</code> is called.</p>\n<p>Normally you could separate the <code>static</code> declaration and assignment, but in this case you can't because lambdas don't have a default constructor (yet). If you did that, then calling <code>get_ptr</code> a second time on a lambda would reset the lambda that the <em>first</em> call's returned pointer was using, changing the above result to have:</p>\n<pre><code>int(*p6_prime)(double,double) = get_ptr(f6);\nassert( p6_prime(0,0) == 6 );\nassert( p6(0,0) == 12 ); // (!) p6 === p_prime\n</code></pre>\n", "OwnerUserId": "166389", "LastEditorUserId": "166389", "LastEditDate": "2017-05-16T10:26:52.877", "Id": "43998243", "Score": "2", "CreationDate": "2017-05-16T09:58:13.027", "LastActivityDate": "2017-05-16T10:26:52.877"}, "bq_ids": {"n4140": {"so_43970960_43971134_0": {"section_id": 5962, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_43970960_43971134_0": {"section_id": 5731, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_43970960_43971134_0": {"section_id": 7451, "quality": 0.8666666666666667, "length": 13}}}, "43971134": {"ParentId": "43970960", "CommentCount": "0", "Body": "<p>From the draft spec (n3376 specifically), <em>5.1.2.3</em> (emphasis mine).</p>\n<blockquote>\n<p id=\"so_43970960_43971134_0\">The type of the lambda-expression (which is also the type of the closure object) is a <strong>unique</strong>, unnamed non-union class type \u2014 called the closure type...</p>\n</blockquote>\n", "OwnerUserId": "1085573", "PostTypeId": "2", "Id": "43971134", "Score": "5", "CreationDate": "2017-05-15T03:19:19.170", "LastActivityDate": "2017-05-15T03:19:19.170"}});