post_cb({"24372323": {"Id": "24372323", "PostTypeId": "2", "Body": "<p>If we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow noreferrer\">Rationale for International Standard\u2014Programming Languages\u2014C</a> in section <code>6.3.1.8</code> <em>Usual arithmetic conversions</em> it says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24371868_24372323_0\">The rules in the Standard for these conversions are slight\n  modifications of those in K&amp;R: the modifications accommodate the added\n  types and the value preserving rules. <strong>Explicit license was added to\n  perform calculations in a \u201cwider\u201d type than absolutely necessary,\n  since this can sometimes produce smaller and faster code, not to\n  mention the correct answer more often</strong>. Calculations can also be\n  performed in a \u201cnarrower\u201d type by the as if rule so long as the same\n  end result is obtained. Explicit casting can always be used to obtain\n  a value in a desired type</p>\n</blockquote>\n<p>Section <code>6.3.1.8</code> from the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">draft C99 standard</a> covers the <em>Usual arithmetic conversions</em> which is applied to operands of arithmetic expressions for example section <code>6.5.6</code> <em>Additive operators</em> says:</p>\n<blockquote>\n<p id=\"so_24371868_24372323_1\">If both operands have arithmetic type, the <strong>usual arithmetic\n  conversions</strong> are performed on them.</p>\n</blockquote>\n<p>We find similar text in section <code>6.5.5</code> <em>Multiplicative operators</em> as well. In the case of a <em>short</em> operand, first the <em>integer promotions</em> are applied from section <code>6.3.1.1</code> <em>Boolean, characters, and integers</em> which says:</p>\n<blockquote>\n<p id=\"so_24371868_24372323_2\">If an int can represent all values of the original type, the value is\n  converted to an int; otherwise, it is converted to an unsigned int.\n  <strong>These are called the integer promotions</strong>.<sup>48)</sup> All other types are\n  unchanged by the integer promotions.</p>\n</blockquote>\n<p>The discussion from section <code>6.3.1.1</code> of the <em>Rationale or International Standard\u2014Programming Languages\u2014C</em> on <em>integer promotions</em> is actually more interesting, I am going to selectively quote b/c it is too long to fully quote:</p>\n<blockquote>\n<p id=\"so_24371868_24372323_3\">Implementations fell into <strong>two major camps</strong> which may be characterized\n  as <strong>unsigned preserving and value preserving</strong>.</p>\n<p id=\"so_24371868_24372323_4\">[...]</p>\n<p id=\"so_24371868_24372323_5\">The <strong>unsigned preserving approach</strong> calls for promoting the two smaller\n  unsigned types to unsigned int. This is a simple rule, and yields a\n  type which is independent of execution environment.</p>\n<p id=\"so_24371868_24372323_6\">The <strong>value preserving approach</strong> calls for promoting those types to\n  signed int if that type can properly represent all the values of the\n  original type, and otherwise for promoting those types to unsigned\n  int. Thus, if the execution environment represents short as something\n  smaller than int, unsigned short becomes int; otherwise it becomes\n  unsigned int.</p>\n</blockquote>\n<p>This can have some rather unexpected results in some cases as <a href=\"https://stackoverflow.com/q/23994293/1708801\">Inconsistent behaviour of implicit conversion between unsigned and bigger signed types</a> demonstrates, there are plenty more examples like that. Although in most cases this results in the operations working as expected.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-07T12:40:52.037", "Score": "34", "CreationDate": "2014-06-23T17:56:32.897", "ParentId": "24371868", "CommentCount": "5", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:46:57.347"}, "24372005": {"Id": "24372005", "PostTypeId": "2", "Body": "<p>It's not a feature of the language as much as it is a limitation of physical processor architectures on which the code runs. The <code>int</code> typer in C is usually the size of your standard CPU register. More silicon takes up more space and more power, so in many cases arithmetic can only be done on the \"natural size\" data types. This is not universally true, but most architectures still have this limitation. In other words, when adding two 8-bit numbers, what actually goes on in the processor is some type of 32-bit arithmetic followed by either a simple bit mask or another appropriate type conversion.</p>\n", "LastEditorUserId": "573432", "LastActivityDate": "2014-06-23T19:03:43.010", "Score": "19", "CreationDate": "2014-06-23T17:39:23.930", "ParentId": "24371868", "CommentCount": "5", "OwnerUserId": "573432", "LastEditDate": "2014-06-23T19:03:43.010"}, "bq_ids": {"n4140": {"so_24371868_24372323_1": {"length": 9, "quality": 0.9, "section_id": 6172}}, "n3337": {"so_24371868_24372323_1": {"length": 9, "quality": 0.9, "section_id": 5933}}, "n4659": {"so_24371868_24372323_1": {"length": 9, "quality": 0.9, "section_id": 7670}}}, "24372191": {"Id": "24372191", "PostTypeId": "2", "Body": "<p><code>float</code>, <code>short</code> and <code>char</code> types are considered by the standard sort of \"storage types\" i.e. sub-ranges that you can use to save some space but that are not going to buy you any speed because their size is \"unnatural\" for the CPU.</p>\n<p>On certain CPUs this is not true but good compilers are smart enough to notice that if you e.g. add a constant to an unsigned char and store the result back in an unsigned char then there's no need to go through the <code>unsigned char -&gt; int</code> conversion.\nFor example with g++ the code generated for the inner loop of</p>\n<pre><code>void incbuf(unsigned char *buf, int size) {\n    for (int i=0; i&lt;size; i++) {\n        buf[i] = buf[i] + 1;\n    }\n}\n</code></pre>\n<p>is just</p>\n<pre><code>.L3:\n    addb    $1, (%rdi,%rax)\n    addq    $1, %rax\n    cmpl    %eax, %esi\n    jg  .L3\n.L1:\n</code></pre>\n<p>where you can see that an unsigned char addition instruction (<code>addb</code>) is used.</p>\n<p>The same happens if you're doing your computations between short ints and storing the result in short ints.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2014-11-28T14:40:55.357", "Score": "15", "CreationDate": "2014-06-23T17:49:22.367", "ParentId": "24371868", "CommentCount": "1", "OwnerUserId": "320726", "LastEditDate": "2014-11-28T14:40:55.357"}, "24371868": {"ViewCount": "5543", "Body": "<p>From the answers I got from <a href=\"https://stackoverflow.com/q/24370732/2317532\">this question</a>, it appears that C++ inherited this requirement for conversion of <code>short</code> into <code>int</code> when performing arithmetic operations from C. May I pick your brains as to <strong><em>why</em></strong> this was introduced in C in the first place? Why not just do these operations as <code>short</code>?</p>\n<p>For example (<em>taken from dyp's suggestion in the comments</em>):</p>\n<pre><code>short s = 1, t = 2 ;\nauto  x = s + t ;\n</code></pre>\n<p><code>x</code> will have type of <em>int</em>.</p>\n", "AcceptedAnswerId": "24372323", "Title": "Why must a short be converted to an int before arithmetic operations in C and C++?", "CreationDate": "2014-06-23T17:30:34.437", "Id": "24371868", "CommentCount": "9", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:39.290", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-28T14:40:55.357", "Score": "58", "OwnerUserId": "2317532", "Tags": "<c++><c><int><short><integer-promotion>", "AnswerCount": "4"}, "24372015": {"Id": "24372015", "PostTypeId": "2", "Body": "<p>The linked question seems to cover it pretty well: the CPU just doesn't. A 32-bit CPU has its native arithmetic operations set up for 32-bit registers. The processor prefers to work in its favorite size, and for operations like this, copying a small value into a native-size register is cheap. (For the x86 architecture, the 32-bit registers are named as if they are extended versions of the 16-bit registers (<code>eax</code> to <code>ax</code>, <code>ebx</code> to <code>bx</code>, etc); see <a href=\"http://en.wikipedia.org/wiki/X86_instruction_listings#x86_integer_instructions\" rel=\"nofollow noreferrer\">x86 integer instructions</a>).</p>\n<p>For some extremely common operations, particularly vector/float arithmetic, there may be specialized instructions that operate on a different register type or size. For something like a short, padding with (up to) 16 bits of zeroes has very little performance cost and adding specialized instructions is probably not worth the time or space on the die (if you want to get really physical about why; I'm not sure they would take actual space, but it does get way more complex).</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2014-07-07T15:20:44.447", "Score": "6", "CreationDate": "2014-06-23T17:39:53.393", "ParentId": "24371868", "CommentCount": "2", "OwnerUserId": "129032", "LastEditDate": "2014-07-07T15:20:44.447"}});