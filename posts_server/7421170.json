post_cb({"7424395": {"ParentId": "7421170", "PostTypeId": "2", "CommentCount": "24", "Body": "<p>\u00a75.19/2 (on the second page; it really should be split into many paragraphs) forbids constant expressions containing</p>\n<blockquote>\n<p id=\"so_7421170_7424395_0\">\u2014 an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<blockquote>\n<blockquote>\n<p id=\"so_7421170_7424395_5\">\u2014 a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression, or</p>\n<p id=\"so_7421170_7424395_6\">\u2014 a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers to a sub-object of such an object</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><code>str[1000]</code> translates to <code>* ( str + 1000 )</code>, which does not refer to a subobject of <code>str</code>, in contrast with an in-bounds array access. So this is a diagnosable rule, and the compiler is required to complain.</p>\n<p><strong>EDIT:</strong> It seems there's some confusion about how this diagnosis comes about. The compiler checks an expression against \u00a75.19 when it needs to be constant. If the expression doesn't satisfy the requirements, the compiler is required to complain. In effect, it is required to validate constant expressions against anything that might otherwise cause undefined behavior.* This may or may not involve attempting to evaluate the expression.</p>\n<p>\u00a0* In C++11, \"a result that is not mathematically defined.\" In C++14, \"an operation that would have undefined behavior,\" which by definition (\u00a71.3.24) ignores behavior that the implementation might define as a fallback.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2015-05-19T05:43:27.003", "Id": "7424395", "Score": "10", "CreationDate": "2011-09-14T23:59:08.703", "LastActivityDate": "2015-05-19T05:43:27.003"}, "21319606": {"ParentId": "7421170", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, the compiler is supposed to catch this at compile time, if we look at section <code>5.19</code> <em>Constant expressions</em> paragraph <em>2</em> of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft C++ standard</a> it lists this as an exclusion for constant expressions:</p>\n<blockquote>\n<p id=\"so_7421170_21319606_0\">\u2014 <strong>an operation that would have undefined behavior</strong> [ Note: including, for example, signed integer overflow (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8) \u2014end note ];</p>\n</blockquote>\n<p>and <a href=\"http://wg21.cmeerw.net/cwg/issue695\" rel=\"nofollow noreferrer\">issue 695</a> as far as I can tell says that undefined behavior is <em>non-const</em> and should issue a diagnostic:</p>\n<blockquote>\n<p id=\"so_7421170_21319606_1\">The consensus of the CWG was that an expression like 1/0 should simply be considered non-constant; any diagnostic would result from the use of the expression in a context requiring a constant expression.</p>\n</blockquote>\n<p>You can find more details at my <a href=\"https://stackoverflow.com/questions/21319413/why-do-constant-expressions-have-an-exclusion-for-undefined-behavior\">self answered question here</a> which also goes into the uses of this feature.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:52.943", "Id": "21319606", "Score": "4", "CreationDate": "2014-01-23T21:23:02.160", "LastActivityDate": "2014-01-24T19:51:11.973"}, "7421170": {"CommentCount": "9", "AcceptedAnswerId": "7424395", "PostTypeId": "1", "LastEditorUserId": "168175", "CreationDate": "2011-09-14T18:27:45.233", "LastActivityDate": "2015-05-19T05:43:27.003", "LastEditDate": "2011-09-14T18:57:06.547", "ViewCount": "734", "FavoriteCount": "3", "Title": "constexpr undefined behaviour", "Id": "7421170", "Score": "17", "Body": "<p>I've been experimenting with <code>constexpr</code>. On my test compiler (g++ 4.6) this fails to compile with an error about out of bounds access. Is a compiler <em>required</em> to spot this at compile time?</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nconstexpr const char *str = \"hi\";\n\nconstexpr int fail() {\n  return str[1000]; // Way past the end!\n}\n\ntemplate &lt;int N&gt;\nstruct foo {\n  static void print() { std::cout &lt;&lt; N &lt;&lt; std::endl; }\n};\n\nint main() {  \n  foo&lt;fail()&gt;::print();\n}\n</code></pre>\n", "Tags": "<c++><undefined-behavior><c++11><language-lawyer>", "OwnerUserId": "168175", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7421170_7424395_3": {"section_id": 6185, "quality": 1.0, "length": 13}, "so_7421170_7424395_2": {"section_id": 6185, "quality": 0.9166666666666666, "length": 11}, "so_7421170_7424395_6": {"section_id": 6185, "quality": 0.9166666666666666, "length": 11}, "so_7421170_7424395_4": {"section_id": 6185, "quality": 0.9166666666666666, "length": 11}, "so_7421170_7424395_5": {"section_id": 6185, "quality": 1.0, "length": 13}, "so_7421170_7424395_1": {"section_id": 6185, "quality": 1.0, "length": 13}, "so_7421170_21319606_0": {"section_id": 6185, "quality": 0.7727272727272727, "length": 17}}, "n3337": {"so_7421170_7424395_3": {"section_id": 5946, "quality": 1.0, "length": 13}, "so_7421170_7424395_2": {"section_id": 5946, "quality": 1.0, "length": 12}, "so_7421170_7424395_6": {"section_id": 5946, "quality": 1.0, "length": 12}, "so_7421170_7424395_4": {"section_id": 5946, "quality": 1.0, "length": 12}, "so_7421170_7424395_5": {"section_id": 5946, "quality": 1.0, "length": 13}, "so_7421170_7424395_1": {"section_id": 5946, "quality": 1.0, "length": 13}}, "n4659": {"so_7421170_7424395_3": {"section_id": 7687, "quality": 1.0, "length": 13}, "so_7421170_7424395_1": {"section_id": 7687, "quality": 1.0, "length": 13}, "so_7421170_7424395_6": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}, "so_7421170_7424395_4": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}, "so_7421170_7424395_5": {"section_id": 7687, "quality": 1.0, "length": 13}, "so_7421170_7424395_2": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}, "so_7421170_21319606_0": {"section_id": 7687, "quality": 0.7727272727272727, "length": 17}}}});