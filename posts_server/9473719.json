post_cb({"bq_ids": {"n4140": {"so_9473719_9474634_0": {"section_id": 261, "quality": 0.95, "length": 38}}, "n3337": {"so_9473719_9474634_0": {"section_id": 252, "quality": 0.95, "length": 38}}, "n4659": {"so_9473719_9474634_0": {"section_id": 268, "quality": 0.95, "length": 38}}}, "9473719": {"CommentCount": "0", "ViewCount": "2196", "CreationDate": "2012-02-27T22:57:27.977", "LastActivityDate": "2012-02-28T19:45:33.337", "Title": "Getting the ID of a boost::thread for PostThreadMessage", "AcceptedAnswerId": "9474634", "PostTypeId": "1", "Id": "9473719", "Score": "5", "Body": "<p>I have a Visual Studio 2008 C++ project using Boost 1.47.0 where I need to get the native Windows ID of a boost::thread to pass to PostThreadMessage.</p>\n<p>In Windows Vista and 7, I would just do this: </p>\n<pre><code>DWORD thread_id = ::GetThreadId( mythread.native_handle() );\n</code></pre>\n<p>This is fine, but I also need my app to work in XP where <code>GetThreadId</code> does not exist.</p>\n<p>I have found that boost:thread stores the thread ID value in boost::thread::id's private data member <code>thread_data</code>. I can get to that by doing some nasty casts:</p>\n<pre><code>boost::detail::thread_data_base* tdb = *reinterpret_cast&lt; boost::detail::thread_data_base** &gt;( &amp;message_thread.get_id() );\nDWORD thread_id = tdb-&gt;id;\n</code></pre>\n<p>But, I start getting compiler warnings for referencing a temporary <code>boost::thread::id</code> object.</p>\n<pre><code>warning C4238: nonstandard extension used : class rvalue used as lvalue\n</code></pre>\n<p>Is there a good way to get the ID? It is very frustrating to see the piece of data I need, but not be able to get at it.</p>\n<p>Thanks,\nPaulH</p>\n", "Tags": "<c++><windows><boost><boost-thread>", "OwnerUserId": "57185", "AnswerCount": "1"}, "9474634": {"ParentId": "9473719", "LastEditDate": "2017-05-23T12:25:06.277", "CommentCount": "2", "CreationDate": "2012-02-28T00:33:24.400", "OwnerUserId": "12711", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "9474634", "Score": "6", "Body": "<p>Here's a clever/nasty hack using a technique described by <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub - litb</a> on his blog, <a href=\"http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html\" rel=\"nofollow noreferrer\">Access to private members: Safer nastiness</a>.  All credit should go to Johannes.  I'll take the blame for applying it to a real-world scenario (or maybe you can):</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\n#include \"boost/thread.hpp\"\n\nusing namespace std;\n\n\n// technique for accessing private class members\n//\n//  from: http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html\n//\n\ntemplate&lt;typename Tag, typename Tag::type M&gt;\nstruct Rob { \n  friend typename Tag::type get(Tag) {\n    return M;\n  }\n};\n\nstruct thread_data_f {\n    typedef unsigned boost::detail::thread_data_base::*type;\n\n    friend type get(thread_data_f);\n};\n\nstruct thread_id_f {\n    typedef boost::detail::thread_data_ptr boost::thread::id::*type;\n\n    friend type get(thread_id_f);\n};\n\ntemplate struct Rob&lt;thread_data_f, &amp;boost::detail::thread_data_base::id&gt;;\ntemplate struct Rob&lt;thread_id_f, &amp;boost::thread::id::thread_data&gt;;\n\nunsigned int get_native_thread_id( boost::thread const&amp; t)\n{\n    boost::detail::thread_data_ptr thread_data = t.get_id().*get(thread_id_f());\n    unsigned thread_id = (*thread_data).*get(thread_data_f());\n\n    return thread_id;\n}\n\n//\n//\n//\n\n\n// test of get_native_thread_id()\n\n\nvoid thread_func()\n{\n    cout &lt;&lt; \"thread running...\" &lt;&lt; endl;\n\n    cout &lt;&lt; \"Windows says my ID is: \" &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;\n\n    for (;;) {\n        boost::this_thread::yield();\n    }\n}\n\n\nint main()\n{\n    boost::thread t(thread_func);\n\n    ::Sleep(2000);\n\n    cout &lt;&lt; \"boost says my thread ID is: \" &lt;&lt; get_native_thread_id(t) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>I'm not sure if this qualifies as a \"good way\" to get the info.  But it works without modifying the boost headers or libraries, and the compiler doesn't complain at all - even with relatively high warnings. Tested on:</p>\n<ul>\n<li>MinGW 4.6.1  <code>-Wall -Wextra</code> with a few especially noisy warnings turned off - but not for this test in particular. They're turned off in my generic 'compile this test' script.</li>\n<li>VC++ 2008 and 2010 with /W4</li>\n</ul>\n<p>Here a sample run that shows it works:</p>\n<pre><code>C:\\temp&gt;test\nthread running...\nWindows says my ID is: 5388\nboost says my thread ID is: 5388\n</code></pre>\n<p>Of course, it should go without saying that this might break if/when boost::thread changes over time, but probably not silently.</p>\n<hr>\n<p>Some explanatory notes/pointers:</p>\n<p>The 'loophole' used in this technique is in C++03 14.7.2/8 \"Explicit instantiation\":</p>\n<blockquote>\n<p id=\"so_9473719_9474634_0\">The usual access checking rules do not apply to names used to specify\n  explicit instantiations.  [Note: In particular, the template arguments\n  and names used in the function declarator (including parameter types,\n  return types and exception specifications) may be private types or\n  objects which would normally not be accessible and the template may be\n  a member template or member function which would not normally be\n  accessible.]</p>\n</blockquote>\n<p>Dave Abrahams has a 'gist' that uses similar techniques along with comments that explain pretty nicely what's going on:</p>\n<ul>\n<li><a href=\"https://gist.github.com/1528856\" rel=\"nofollow noreferrer\">https://gist.github.com/1528856</a></li>\n</ul>\n<p>I found that in a comment he left on a previous article about private member access on Johannes' blog: <a href=\"http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html\" rel=\"nofollow noreferrer\">Access to private members. That's easy!</a> </p>\n</hr>", "LastActivityDate": "2012-02-28T19:45:33.337"}});