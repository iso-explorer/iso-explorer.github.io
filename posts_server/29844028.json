post_cb({"bq_ids": {"n4140": {"so_29844028_29844272_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5908}}, "n3337": {"so_29844028_29844272_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5680}}}, "29844272": {"LastActivityDate": "2015-04-24T09:59:01.867", "CommentCount": "2", "Body": "<p>The difference is described in the following quote from the C++ Standard (9.4.2 Static data members)</p>\n<blockquote>\n<p id=\"so_29844028_29844272_0\">3 If a non-volatile <strong>const static data member is of integral or\n  enumeration type, its declaration in the class definition can specify\n  a brace-or-equal-initializer</strong> in which every initializer-clause that\n  is an assignmentexpression is a constant expression (5.19). <strong>A static\n  data member of literal type can be declared in the class definition\n  with the constexpr specifier; if so, its declaration shall specify a\n  brace-or-equal-initializer</strong> in which every initializer-clause that is\n  an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note\n  ] The member shall still be defined in a namespace scope if it is\n  odr-used (3.2) in the program and the namespace scope definition shall\n  not contain an initializer.</p>\n</blockquote>\n<p>Consider for example two programs</p>\n<pre><code>struct A\n{\n    const static double x = 1.0;\n};\n\nint main() \n{\n    return 0;\n}\n\nstruct A\n{\n    constexpr static double x = 1.0;\n};\n\nint main() \n{\n    return 0;\n}\n</code></pre>\n<p>The first one will not compile while the second one will compile.</p>\n<p>The same is valid for pointers</p>\n<p>This program</p>\n<pre><code>struct A\n{\n    static constexpr const char * myString = \"myString\";\n};\n\nint main() \n{\n    return 0;\n}\n</code></pre>\n<p>will compile while this porgram</p>\n<pre><code>struct A\n{\n    static const char * const myString = \"myString\";\n};\n\nint main() \n{\n    return 0;\n}\n</code></pre>\n<p>will not compile.</p>\n", "PostTypeId": "2", "LastEditDate": "2015-04-24T09:59:01.867", "ParentId": "29844028", "Id": "29844272", "OwnerUserId": "2877241", "Score": "4", "CreationDate": "2015-04-24T09:50:56.160", "LastEditorUserId": "2877241"}, "29844028": {"LastActivityDate": "2015-11-10T10:29:03.430", "ViewCount": "6476", "Id": "29844028", "AcceptedAnswerId": "29844272", "Score": "4", "Title": "Explain constexpr with const char*const", "LastEditorUserId": "462639", "CommentCount": "1", "Body": "<p>I have the following code:</p>\n<pre><code>static constexpr const char*const myString = \"myString\";\n</code></pre>\n<p>Could you please explain what is the difference from: </p>\n<pre><code>static const char*const myString = \"myString\";\n</code></pre>\n<p>What's new we have with constexpr in this case? </p>\n", "Tags": "<c++><c++11><const><constexpr>", "CreationDate": "2015-04-24T09:40:37.360", "LastEditDate": "2015-11-10T10:29:03.430", "ClosedDate": "2015-04-24T09:59:39.097", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "462639"}});