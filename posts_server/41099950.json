post_cb({"41100134": {"ParentId": "41099950", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>cr</code> parameter from your example is a r-value <strong>reference</strong>. The reference word is significant here. It acts somewhat similar to a plane old reference that we know from c++, before c++11 was in a game, in a terms that it does not invoke any constructor... it is just \"pointing\" to the object you pass...</p>\n<p>To invoke the moving constructor (or do other swap) and consume the reference we need to forward the reference further e.g. as follows:</p>\n<pre><code>void f( c&amp;&amp; cr ) {\n   c cr2(std::move(cr));\n}\n</code></pre>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2016-12-12T12:11:05.770", "Id": "41100134", "Score": "6", "CreationDate": "2016-12-12T11:45:07.513", "LastActivityDate": "2016-12-12T12:11:05.770"}, "41099950": {"CommentCount": "5", "ViewCount": "369", "PostTypeId": "1", "LastEditorUserId": "435800", "CreationDate": "2016-12-12T11:35:16.940", "LastActivityDate": "2016-12-12T12:11:05.770", "Title": "Move object without a move constructor", "AcceptedAnswerId": "41100134", "LastEditDate": "2016-12-12T11:38:38.417", "Id": "41099950", "Score": "2", "Body": "<p><sub>One more time about this, but the related questions do not answer my question.</sub></p>\n<p>The standard is pretty clear: </p>\n<blockquote>\n<p id=\"so_41099950_41099950_0\">12.8 Copying and moving class objects,<br>\n  \u00a79<br>\n   If the definition of a class X does not explicitly declare a move  constructor, one will be implicitly declared as defaulted if and only if<br>\n  \u2014 X does not have a user-declared copy constructor,<br>\n  \u2014 X does not have a user-declared copy assignment operator,<br>\n  \u2014 X does not have a user-declared move assignment operator,<br>\n  \u2014 X does not have a user-declared destructor, and<br>\n  \u2014 the move constructor would not be implicitly defined as deleted.<br>\n  [ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. \u2014 end note ]</br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>So, before noticing the \"Note\" at the end, I expected this piece of code to fail compilation (although I knew, that moving <em>should</em> fallback to copying):</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nclass c\n{\npublic:\n    c() { cout &lt;&lt; \"c::c()\\n\"; }\n    c( std::initializer_list&lt; int &gt; ) { cout &lt;&lt; \"c::c( std::initializer_list )\\n\"; };\n\n    c( const c&amp; ) { cout &lt;&lt; \"c::c( const c&amp; )\\n\"; }\n    c&amp; operator=( const c&amp; ) { cout &lt;&lt; \"c&amp; c::operator=( const c&amp; )\\n\"; return *this; }\n\n    ~c() { cout &lt;&lt; \"c::~c()\\n\"; }\n\n    void f() {}\n};\n\nvoid f( c&amp;&amp; cr ) { cout &lt;&lt; \"f()\\n\"; cr.f(); }\n\nint main()\n{\n    c x;\n    f( std::move( x ) );\n\n    return 0;\n}\n</code></pre>\n<p>Then I saw the note at the end, but I was still surprised, that the code above outputs:</p>\n<blockquote>\n<p id=\"so_41099950_41099950_1\">c::c()<br>\n  f()<br>\n  c::~c()</br></br></p>\n</blockquote>\n<p>Note the \"missing\" <code>c::c( const c&amp; )</code>. Then I added </p>\n<pre><code>c( c&amp;&amp; ) = delete;\nc&amp; operator=( c&amp;&amp; ) = delete;\n</code></pre>\n<p>and the result is still the same.</p>\n<p>What do I miss here?</p>\n<hr>\n<pre><code>$ g++ --version\ng++ (Ubuntu 5.4.0-6ubuntu1~16.04.2) 5.4.0 20160609\n</code></pre>\n<p>Compiler flags: <code>-s -O0 -march=native -pthread -std=c++11 -Wall -Wextra -DNDEBUG</code>.</p>\n</hr>", "Tags": "<c++><move><move-constructor><implicit-constructor>", "OwnerUserId": "435800", "AnswerCount": "2"}, "41100124": {"ParentId": "41099950", "CommentCount": "1", "Body": "<p>You didn't move any object.</p>\n<p><code>std::move</code> is actually quite confusing, because it does not move anything. only a move-constructor or a move assignment operator can move objects, what <code>std::move</code> do is just cast an l-value reference (<code>&amp;</code>) to r-value-reference(<code>&amp;&amp;</code>).</p>\n<p>the move constructor, or the move assignment operator can bind to the r-value-refernce(<code>&amp;&amp;</code>) and steal the object contents.</p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "41100124", "Score": "6", "CreationDate": "2016-12-12T11:44:33.550", "LastActivityDate": "2016-12-12T11:44:33.550"}, "bq_ids": {"n4140": {"so_41099950_41099950_0": {"section_id": 458, "quality": 0.7878787878787878, "length": 52}}, "n3337": {"so_41099950_41099950_0": {"section_id": 449, "quality": 0.8787878787878788, "length": 58}}, "n4659": {"so_41099950_41099950_0": {"section_id": 481, "quality": 0.7878787878787878, "length": 52}}}});