post_cb({"39092042": {"CommentCount": "3", "ViewCount": "175", "CreationDate": "2016-08-23T03:49:49.810", "LastActivityDate": "2016-08-23T04:05:55.160", "Title": "printf calls messed up with std::thread but std::cout are fine", "AcceptedAnswerId": "39092171", "PostTypeId": "1", "Id": "39092042", "Score": "1", "Body": "<p>When printf (stdio.h) is used, \"Start both threads\\n\" and \"Enter a number\\n\" mixed together (something like \"StEanterrt b a oth thnureaber\\nads\\n\"), but this does not happen in std::cout (iostream). I suspect this has something to do with std::thread, but I am still new with multi-threading programming.</p>\n<p>I really don't want to use iostream because it makes the program super large!</p>\n<p>I am using mingw32 g++ 4.9.2, compile with <code>g++ -o foreback foreback.cpp -O2 -std=c++11</code>. (Although my computer is 64-bits, but I find out that mingw-w64 produces program about twice the size by mingw32, so I didn't use it).</p>\n<pre><code>//#define IOS\n#ifdef IOS\n#include &lt;iostream&gt;\n#endif\n#include &lt;stdio.h&gt;\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;windows.h&gt; // for Sleep()\n\nstd::atomic&lt;int&gt; atom(1);\n\nvoid foreground() {\n    int c = 1;\n    while (c) {\n#ifdef IOS\n        std::cout &lt;&lt; \"Enter a number: \";\n        std::cin &gt;&gt; c;\n#else\n        printf(\"Enter a number: \");\n        scanf(\"%d\", &amp;c);\n#endif\n        atom.store(c, std::memory_order_relaxed);\n    }\n}\n\nvoid background() {\n    FILE *out = fopen(\"foreback.txt\", \"w\");\n    int c = 1;\n    while (c) {\n        fprintf(out, \"%d\", c);\n        c = atom.load(std::memory_order_relaxed);\n        Sleep(500);\n    }\n    fclose(out);\n}\n\nint main() {\n    std::thread f(foreground), b(background);\n#ifdef IOS\n    std::cout &lt;&lt; \"Start both threads.\\n\";\n#else\n    printf(\"Start both threads.\\n\");\n#endif\n    f.join();\n    b.join();\n#ifdef IOS\n    std::cout &lt;&lt; \"End of both threads.\\n\";\n#else\n    printf(\"End of both threads.\\n\");\n#endif\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "6521181", "AnswerCount": "1"}, "39092171": {"ParentId": "39092042", "CommentCount": "3", "Body": "<p><code>std::cout</code> provides no guarantees on interleaving either; it's not mentioned in C++03, and C++11's FDIS says the following in \u00a727.4.1 [iostream.objects.overview]:</p>\n<blockquote>\n<p id=\"so_39092042_39092171_0\">Concurrent access to a synchronized (\u00a727.5.3.4) standard iostream object\u2019s formatted and unformatted input (\u00a727.7.2.1) and output (\u00a727.7.3.1) functions or a standard C stream by multiple threads shall not result in a data race (\u00a71.10). [ Note: Users must still synchronize concurrent use of these objects and streams by multiple threads if they wish to avoid interleaved characters. \u2014 end note ]</p>\n</blockquote>\n<p>That note at the end basically means \"<code>std::cout</code> is allowed to interleave characters too\". It's possible it isn't doing so due to the compiler/runtime library specific implementation in general, or due to the attempts <a href=\"http://www.cplusplus.com/reference/ios/ios_base/sync_with_stdio/\" rel=\"nofollow\">to synchronize itself with <code>stdio.h</code></a> (turning off <code>sync_with_stdio</code> might cause it to begin interleaving again). But it's not a language guarantee; you're just lucking out.</p>\n<p>If you want output to not interleave, you need to either perform all I/O from a single thread (have your workers take arguments and compute values, and the main thread is responsible for performing the I/O to output the computed values), or explicitly lock around all I/O functions that are used from different threads that target the same stream/<code>FILE*</code>. You could easily use <code>stdio.h</code>, you'd just need to have a <code>std::mutex</code> that you lock (e.g. with <code>std::lock_guard</code>) around your uses of <code>stdio.h</code> functions; as long as it's done consistently, you're guaranteed no interleaving.</p>\n", "OwnerUserId": "364696", "PostTypeId": "2", "Id": "39092171", "Score": "1", "CreationDate": "2016-08-23T04:05:55.160", "LastActivityDate": "2016-08-23T04:05:55.160"}, "bq_ids": {"n4140": {"so_39092042_39092171_0": {"section_id": 1922, "quality": 0.8157894736842105, "length": 31}}, "n3337": {"so_39092042_39092171_0": {"section_id": 1911, "quality": 0.8157894736842105, "length": 31}}, "n4659": {"so_39092042_39092171_0": {"section_id": 2193, "quality": 0.8157894736842105, "length": 31}}}});