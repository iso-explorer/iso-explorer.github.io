post_cb({"bq_ids": {"n4140": {"so_47473621_47475941_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_47473621_47475941_1": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_47473621_47475941_4": {"length": 17, "quality": 1.0, "section_id": 7195}, "so_47473621_47475941_3": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_47473621_47475941_2": {"length": 9, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_47473621_47475941_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_47473621_47475941_1": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_47473621_47475941_4": {"length": 17, "quality": 1.0, "section_id": 6939}, "so_47473621_47475941_3": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_47473621_47475941_2": {"length": 9, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_47473621_47475941_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_47473621_47475941_1": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_47473621_47475941_4": {"length": 17, "quality": 1.0, "section_id": 8704}, "so_47473621_47475941_3": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_47473621_47475941_2": {"length": 9, "quality": 1.0, "section_id": 8704}}}, "47473621": {"ViewCount": "164", "Body": "<p>Why is that undefined behaviour?</p>\n<pre><code>struct s\n{\n    const int id; // &lt;-- const member\n\n    s(int id):\n        id(id)\n    {}\n\n    s&amp; operator =(const s&amp; m) {\n        return *new(this) s(m); // &lt;-- undefined behavior?\n    }\n};\n</code></pre>\n<p>(Quote from the standard would be nice).</p>\n<p>This question arose from <a href=\"https://stackoverflow.com/a/11602256/1729784\">this answer</a>.</p>\n", "AcceptedAnswerId": "47475941", "Title": "Placement new and assignment of class with const member", "CreationDate": "2017-11-24T12:45:34.500", "Id": "47473621", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-11-24T13:59:07.707", "LastEditorUserId": "598696", "LastActivityDate": "2017-11-24T15:15:42.350", "Score": "7", "OwnerUserId": "1729784", "Tags": "<c++><language-lawyer><undefined-behavior><assignment-operator><placement-new>", "AnswerCount": "1"}, "47475941": {"Id": "47475941", "PostTypeId": "2", "Body": "<p>There is nothing that makes the shown code snippet inherently UB. However, it is almost certain UB will follow immediately under any normal usage.</p>\n<p>From <a href=\"http://eel.is/c++draft/basic.life#8\" rel=\"noreferrer\">[basic.life]/8</a> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_47473621_47475941_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_47473621_47475941_1\">the storage for the new object exactly overlays the storage location which the original object occupied, and</p></li>\n<li><p id=\"so_47473621_47475941_2\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p></li>\n<li><p id=\"so_47473621_47475941_3\">the type of the original object is not const-qualified, and, if a class type, <strong>does not contain any non-static data member whose type is const-qualified</strong> or a reference type, and</p></li>\n<li><p id=\"so_47473621_47475941_4\">the original object was a most derived object of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</p></li>\n</ul>\n</blockquote>\n<p>Since there is a <code>const</code> member in <code>s</code>, using the original variable after a call to <code>operator=</code> will be UB.</p>\n<pre><code>s var{42};\nvar = s{420};         // OK\ndo_something(var.id); // UB! Reuses s through original name\ndo_something(std::launder(&amp;var)-&gt;id);  // OK, this is what launder is used for\n</code></pre>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-11-24T15:15:42.350", "Score": "9", "CreationDate": "2017-11-24T15:07:53.813", "ParentId": "47473621", "CommentCount": "3", "OwnerUserId": "4832499", "LastEditDate": "2017-11-24T15:15:42.350"}});