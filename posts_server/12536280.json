post_cb({"12536475": {"ParentId": "12536280", "PostTypeId": "2", "CommentCount": "1", "Body": "<ul>\n<li>Seems, you are right about the first example.</li>\n</ul>\n<p>Second and third examples deal with POD type. And there <a href=\"https://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new\">initialization differences</a> play role.</p>\n<ul>\n<li><p>In the second example your structure left <em>uninitialized</em>. No problem appear.</p></li>\n<li><p>In opposite, in third example structure <em>does</em> initialize, so you get first case.</p></li>\n</ul>\n<p><strong>Edit:</strong></p>\n<p>Then, <code>operator new</code> itself can throw an exception. Standard (c++11 darft says):</p>\n<blockquote>\n<p id=\"so_12536280_12536475_0\">If the <code>new</code> expression terminates by throwing an exception, it may\n  release storage by calling a deallocation function (3.7.4.2). If the\n  allocated type is a non-array type, the allocation function\u2019s name is\n  <code>operator new</code> and the deallocation function\u2019s name is <code>operator delete</code>.</p>\n</blockquote>\n<p>It's bit unclear, what authors wanted to express saying it <em>may</em> release storage. It seems to be implementation defined, if it <em>is</em> released.</p>\n<p>Anyway, you can try using not-throwing <code>new</code> version:</p>\n<pre><code>void *operator new (size_t size, std::nothrow_t) throw() {\n    return malloc(size);\n}\n</code></pre>\n", "OwnerUserId": "774651", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:48.207", "Id": "12536475", "Score": "2", "CreationDate": "2012-09-21T18:49:49.020", "LastActivityDate": "2012-09-21T20:07:21.747"}, "12536280": {"CommentCount": "3", "ViewCount": "1124", "PostTypeId": "1", "ClosedDate": "2012-09-21T20:00:49.650", "LastEditorUserId": "-1", "CreationDate": "2012-09-21T18:35:59.923", "LastActivityDate": "2012-09-21T20:07:21.747", "Title": "private operator delete", "LastEditDate": "2017-05-23T10:25:09.550", "Id": "12536280", "Score": "2", "Body": "<blockquote>\n<p id=\"so_12536280_12536280_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/1820069/public-operator-new-private-operator-delete-getting-c2248-can-not-access-priv\">Public operator new, private operator delete: getting C2248 \u201ccan not access private member\u201d when using new</a> </br></p>\n</blockquote>\n<p><a href=\"http://efesx.com/2009/12/01/public-operator-new-and-private-operator-delete/\" rel=\"nofollow noreferrer\">http://efesx.com/2009/12/01/public-operator-new-and-private-operator-delete/</a></p>\n<p>In this article i read that this code should give an error:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Try {\n        Try () { /* o/ */ }\n\n        void *operator new (size_t size) {\n            return malloc(size);\n        }\n\n    private:\n        void operator delete (void *obj) {\n            free(obj);\n        }\n};\n\nint main () {\n    Try *t = new Try();\n\n    return 0;\n}\n</code></pre>\n<p>I tried it with gcc 4.7.1:</p>\n<pre><code>Compilation finished with errors: source.cpp: In function 'int\nmain()': source.cpp:11:14: error: 'static void Try::operator\ndelete(void*)' is private source.cpp:17:22: error: within this context\nsource.cpp:11:14: error: 'static void Try::operator delete(void*)' is\nprivate source.cpp:17:22: error: within this context source.cpp:17:10:\nwarning: unused variable 't' [-Wunused-variable]\n</code></pre>\n<p>In comment in this article i saw this link - <a href=\"https://stackoverflow.com/questions/1820069/public-operator-new-private-operator-delete-getting-c2248-can-not-access-priv\">Public operator new, private operator delete: getting C2248 \"can not access private member\" when using new</a></p>\n<p>If i unserstand it correct, it doesn't compile because compiler should avoid any memory leaks in situations when there are exception thrown from constructor by calling the appropriate operator delete. But why this code compile and works?</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Try {\n        void *operator new (size_t size) {\n            return malloc(size);\n        }\n\n    private:\n        void operator delete (void *obj) {\n            free(obj);\n        }\n};\n\nint main () {\n    Try *t = new Try;\n\n    return 0;\n}\n</code></pre>\n<p>Is it correct by standard or not?</p>\n<p>And what about this code?</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Try {\n        void *operator new (size_t size) {\n            return malloc(size);\n        }\n\n    private:\n        void operator delete (void *obj) {\n            free(obj);\n        }\n};\n\nint main () {\n    Try *t = new Try();\n\n    return 0;\n}\n</code></pre>\n<p>It doesn't compile with gcc 4.7.1.</p>\n<p>And how things like this should be implemented in the standard library?</p>\n<p>Comeau doesn't compile all these examples:</p>\n<pre><code>\"ComeauTest.c\", line 15: error: function \"Try::operator delete\"\n(declared at line 9) is inaccessible Try *t = new Try; ^\n</code></pre>\n<p>Can anyone explain me this in detail, please?</p>\n", "Tags": "<c++>", "OwnerUserId": "1608835", "AnswerCount": "2"}, "12537343": {"ParentId": "12536280", "CommentCount": "0", "Body": "<p>Compiler creating constructor code which involves operators <strong>new</strong> and <strong>delete</strong> too in case if your constructor code throws an exception. So, using <strong>new</strong> automatically creates usage of <strong>delete</strong>.</p>\n<p>In 2nd example compiler knows you using default constructor which never throws(my guess)..</p>\n<p>Different compilers work different ways cus they are different (captain) and have different optimization capabilities and tricks to create code</p>\n", "OwnerUserId": "1671032", "PostTypeId": "2", "Id": "12537343", "Score": "0", "CreationDate": "2012-09-21T19:55:25.407", "LastActivityDate": "2012-09-21T19:55:25.407"}, "bq_ids": {"n4140": {"so_12536280_12536475_0": {"section_id": 6089, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_12536280_12536475_0": {"section_id": 5857, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_12536280_12536475_0": {"section_id": 7585, "quality": 0.8846153846153846, "length": 23}}}});