post_cb({"bq_ids": {"n4140": {"so_39472903_39473175_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 6130}, "so_39472903_39473175_1": {"length": 81, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_39472903_39473175_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 5894}, "so_39472903_39473175_1": {"length": 81, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_39472903_39473175_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7627}, "so_39472903_39473175_1": {"length": 81, "quality": 1.0, "section_id": 8748}}}, "39477065": {"Id": "39477065", "PostTypeId": "2", "Body": "<p>No, there is no portable way to do this directly.</p>\n<p>However in C++17 you can get close.</p>\n<pre><code>template&lt;auto ptr&gt;\nstruct magic_mem_fun;\n\ntemplate&lt;class T, class R, class...Args, R(T::*ptr)(Args...)&gt;\nstruct magic_mem_fun&lt;ptr&gt; {\n  friend R operator-&gt;*(void* lhs, universal_mem_fun) {\n    return [lhs = (T*)lhs](Args...args)-&gt;R {\n      return (lhs-&gt;*ptr)(std::forward&lt;Args&gt;(args)...);\n    };\n  }\n};\n</code></pre>\n<p>Now <code>magic_mem_fun_ptr&lt;&amp;MyClass::MyFunc&gt;</code> can work on <code>void*</code>s.  It presumes the types match (exactly).</p>\n<p>We now want to type erase this.</p>\n<pre><code>template&lt;class Sig&gt;\nstruct universal_mem_fun_ptr;\n\ntemplate&lt;class R, class...Args&gt;\nstruct universal_mem_fun_ptr&lt;R(Args...)&gt; {\n  R(*f)(void*, Args...) = nullptr;\n  template&lt;class T, class R, class...Args, R(T::*ptr)(Args...)&gt;\n  universal_mem_fun_ptr( magic_mem_ptr&lt;ptr&gt; ):\n    f( [](void* t, Args... args)-&gt;R {\n      return (t-&gt;*magic_mem_ptr&lt;ptr&gt;{})(std::forward&lt;Args&gt;(args)...);\n    } )\n  {}\n  friend R operator-&gt;*(void* t, universal_mem_fun_ptr f) {\n    return [=](Args...args)-&gt;R{\n      return f.f( t, std::forward&lt;Args&gt;(args)... );\n    };\n  }\n};\n</code></pre>\n<p>and I think we get a perfectly legal</p>\n<pre><code>universal_mem_fun_ptr&lt;void()&gt; MyFunc = magic_mem_fun&lt;&amp;MyClass::MyFunc&gt;{};\n\nauto my_class = std::make_unique&lt;MyClass&gt;();\n\nvoid* type_erased = (void*)my_class.get();\n\n(type_erased-&gt;*MyFunc)();\n</code></pre>\n<p>I cannot test this, as I do not have a compiler with <code>auto</code> template arguments, and I am uncertain if I got it right.</p>\n<p>This stores everything in a single function pointer.  If you want runtime type erasure from member function pointers (as opposed to erasing at the point where you have compile time knowledge of the member function pointer) the <code>universal_mem_fun_ptr</code> would have to store more state than a single function pointer.</p>\n<p>Deducing <code>Sig</code> in <code>universal_mem_fun_ptr</code> should be doable, but I will leave that as an exercise.</p>\n<p>The arguments are forwarded a number of times, so if they are expensive to move there could be performance hits.  Extremely careful use of forwarding references may be able to avoid some of those intermediate moves, but not all of them.</p>\n<p>Telling your compiler to discard most of these types (not emit <code>magic_mem_fun_ptr&lt;auto&gt;</code>, treat the constructor as not-shared, etc) and not expose them in your object file may be possible.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-09-13T18:55:57.970", "Score": "2", "CreationDate": "2016-09-13T18:50:26.307", "ParentId": "39472903", "CommentCount": "5", "LastEditDate": "2016-09-13T18:55:57.970", "OwnerUserId": "1774667"}, "39473175": {"Id": "39473175", "PostTypeId": "2", "Body": "<p>No. The wording in in [expr.mptr.oper], as of N4606, reads:</p>\n<blockquote>\n<p id=\"so_39472903_39473175_0\">The binary operator <code>-&gt;*</code> binds its second operand, which shall be of type \u201cpointer to member of <code>T</code>\u201d to its first\n  operand, which shall be of type \u201cpointer to <code>U</code>\u201d where <code>U</code> is either <code>T</code> or a class of which <code>T</code> is an unambiguous\n  and accessible base class.</p>\n</blockquote>\n<p>In the example <code>my_obj-&gt;*my_func</code>, <code>T</code> is <code>TypeEraser</code> and <code>U</code> is <code>void</code>, which does not satisfy the conditions, so the code is simply ill-formed. I am not aware of any proposal to change this. </p>\n<hr/>\n<p>For the new verison of the code, where you now use <code>reinterpret_cast&lt;TypeEraser*&gt;(obj)</code> instead so the types match... still no, as per [basic.lval]:</p>\n<blockquote>\n<p id=\"so_39472903_39473175_1\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined:<br>\n  (8.1) \u2014 the dynamic type of the object,<br>\n  (8.2) \u2014 a cv-qualified version of the dynamic type of the object,<br>\n  (8.3) \u2014 a type similar (as defined in 4.5) to the dynamic type of the object,<br>\n  (8.4) \u2014 a type that is the signed or unsigned type corresponding to the dynamic type of the object,<br>\n  (8.5) \u2014 a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type\n  of the object,<br>\n  (8.6) \u2014 an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic\n  data members (including, recursively, an element or non-static data member of a subaggregate or\n  contained union),<br>\n  (8.7) \u2014 a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,<br>\n  (8.8) \u2014 a <code>char</code> or <code>unsigned char</code> type.</br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p><code>TypeEraser</code> is none of those things for <code>MyClass</code>, so it's undefined behavior. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-09-13T16:10:03.790", "Score": "3", "CreationDate": "2016-09-13T14:58:45.527", "ParentId": "39472903", "CommentCount": "3", "LastEditDate": "2016-09-13T16:10:03.790", "OwnerUserId": "2069064"}, "39472903": {"ViewCount": "181", "Body": "<p>Since this question seems to be causing some contention, I am editing it to first show the intent with hypothetical syntax, and then show an implementation.  The implementation relies on a surprising type cast followed by a call of this type casted pointer.  The problem is that the type cast is standard (though non-portable) C++, but calling its result is undefined behavior.  My question concerns whether the standard has lately or may soon change the result of calling the type casted member function pointer to no longer be undefined behavior.</p>\n<p>The intent is to be able to write code like:</p>\n<pre><code>void* object = ...;  universal_mf_ptr mf_ptr = ...;\nreinterpret_call(object, mf_ptr);\n</code></pre>\n<p>We assume the object is known \"to the programmer\" to be an instance of the same class as is pointed to by the member function pointer.  However the class type is not known \"to the compiler\" at the call site.  The type <code>universal_mf_ptr</code> is a placeholder for \"pointer to a member function of any class type\".  The <code>reinterpret_call</code> is hypothetical syntax to tell the compiler \"trust me, this call will be valid at runtime just push the address of object on the stack and emit an assembly instruction to call-indirect mf_ptr\".  It is so named in analogy to <code>reinterpret_cast</code> which tells the compiler \"trust me, this cast is valid at runtime, just do the cast.\"</p>\n<p>It turns out that, surprisingly, <code>universal_mf_ptr</code> is a real thing and in the standard and it is not undefined behavior.  (According to the linked article below.)  Member function pointers can be reinterpret_cast to other member function pointers (even of different/incompatible class types).  However although it is <em>standard</em> it is not <em>portable</em> (i.e. not all compilers implement this part of the standard).</p>\n<p>The undefined behavior comes into play when attempting to actually make use of (call) a <code>reinterpret_cast</code>'ed member function pointer.  This is undefined behavior according to the <em>standard</em>, but (according to the linked article) is implemented on any compiler which implements the (non-portable, but standard) feature of casting member function pointers to unrelated class types.  The author's assertion is that if the casting the pointer is in the standard so should calling the casted pointer.</p>\n<p>In any case, should one wish to take advantage of the (standard, not undefined, but not portable) feature of casting member function pointers to a universal member function pointer type, for instance to store heterogeneous member functions in one collection, it is necessary to arbitrarily designate a \"victim\" class to be the target of type casts.  This class need not have any such member function as it is being asserted to have, indeed it may have no members or be only forward declared and left undefined.</p>\n<p>I suspect that it is this requirement to arbitrarily choose a victim class and assert that a member function pointer is of a class which it is not in fact a member of is what is causing this question to be down voted.  Many of the arguments that this cannot be/should not be standard so as to <em>call</em> a member function this way could apply equally well to the <em>cast</em>, yet the latter is already in the standard.</p>\n<p>The technique is <a href=\"http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible\" rel=\"nofollow\">described in this article</a>, but it warns:</p>\n<blockquote>\n<p id=\"so_39472903_39472903_0\">Casting between member function pointers is an extremely murky area. During the standardization of C++, there was a lot of discussion about whether you should be able to cast a member function pointer from one class to a member function pointer of a base or derived class, and whether you could cast between unrelated classes. By the time the standards committee made up their mind, different compiler vendors had already made implementation decisions which had locked them into different answers to these questions. According to the Standard (section 5.2.10/9), you can use reinterpret_cast to store a member function for one class inside a member function pointer for an unrelated class. The result of invoking the casted member function is undefined. The only thing you can do with it is cast it back to the class that it came from. I'll discuss this at length later in the article, because it's an area where the Standard bears little resemblance to real compilers.</p>\n</blockquote>\n<p>Why would you want to do this?  So that you can store member function pointers to many different classes of object in the same container and select one to call at runtime.  (Assume that the code also keeps track at runtime which member function pointers are legal to call on which objects.)</p>\n<pre><code>class TypeEraser; // Not a base of anything.\ntypedef void (TypeEraser::*erased_fptr)();\nmap&lt;string, erased_fptr&gt; functions;\n\n// Casting &amp; storage as if member function of unrelated class is in the standard\nfunctions[\"MyFunc\"] = reinterpret_cast&lt;erased_fptr&gt;(&amp;MyClass::MyFunc);\n\nTypeEraser* my_obj = (TypeEraser*)(void*)new MyClass;\nerased_fpr my_func = functions[\"MyFunc\"];\n\n// !!! But calling it is undefined behavior according to standard !!!\nmy_obj-&gt;*my_func();\n</code></pre>\n<p>Per the article linked above, on compilers where casting and storing the member function pointer is actually implemented, calling also works as expected.  But (again, per the article) not all compilers actually implement casting and storage.  That is, casting and storage is standard but it is not portable, while calling the member function pointer is not standard but works if the former works.  It would be better if both were standard and portable.</p>\n<p>And yes, there are several alternative ways to accomplish this same goal:  lambdas, functors with a base class, etc.  The place where all of these alternatives come up short is that they all cause the compiler to emit additional classes and members in the object file.  You may personally not consider that a problem, but in a use case where a large number of member function pointers are being stored, that increases the size of the object file and the compile time much more than simply taking the address of the member functions.</p>\n", "AcceptedAnswerId": "39473175", "Title": "Has or will C++14 or C++1z make it no longer undefined to call delegate class member function pointers?", "CreationDate": "2016-09-13T14:47:26.677", "Id": "39472903", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-09-13T17:36:57.777", "LastEditorUserId": "170361", "LastActivityDate": "2016-09-13T18:55:57.970", "Score": "-2", "OwnerUserId": "170361", "Tags": "<c++><undefined-behavior><member-function-pointers><c++1z>", "AnswerCount": "2"}});