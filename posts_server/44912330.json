post_cb({"bq_ids": {"n4140": {"so_44912330_44912330_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5510}}, "n3337": {"so_44912330_44912330_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5296}}, "n4659": {"so_44912330_44912330_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6945}}}, "44912330": {"ViewCount": "205", "Body": "<p>Quote from the standard:</p>\n<blockquote>\n<p id=\"so_44912330_44912330_0\">A using-directive specifies that the names in the nominated namespace\n  can be used in the scope in which the using-directive appears after\n  the using-directive. During unqualified name lookup (3.4.1), the names\n  appear as if they were declared in the nearest enclosing namespace\n  which contains both the using-directive and the nominated namespace.</p>\n</blockquote>\n<p>Look at this code:</p>\n<pre><code>namespace A {\n\n    int fn() { return 1; }\n\n}\n\nnamespace Inner {\n\n    int fn() { return 2; }\n\n    namespace B {\n\n        using namespace A;\n\n        int z = fn();\n\n    }\n\n}\n</code></pre>\n<p>Here, before I knew the exact rules of namespaces, I had expected that <code>z</code> will be initialized to 1, as I written <code>using namespace A</code>, so expected that <code>A::fn()</code> will be used. But it is not the case, <code>z</code> will be initialized to 2, as <code>Inner::fn()</code> is called because of the rule I quoted.</p>\n<p>What is the rationale behind this behavior: \"as if they were declared in the nearest enclosing namespace which contains both the using-directive and the nominated namespace\"?</p>\n<p>What would be the cons, if <code>using namespace</code> worked as applying using declarations for everything in that namespace?</p>\n<p>Note: <a href=\"https://stackoverflow.com/questions/44894400/resolving-ambiguity-with-using-declaration\">this</a> is the related issue that motivated me to ask this question.</p>\n", "AcceptedAnswerId": "44950817", "Title": "Rationale behind using namespace behavior", "CreationDate": "2017-07-04T18:36:52.450", "Id": "44912330", "CommentCount": "1", "LastEditDate": "2017-07-06T09:20:30.340", "PostTypeId": "1", "LastEditorUserId": "8157187", "LastActivityDate": "2017-07-06T13:47:53.537", "Score": "4", "OwnerUserId": "8157187", "Tags": "<c++><namespaces><language-lawyer>", "AnswerCount": "1"}, "44950817": {"Id": "44950817", "PostTypeId": "2", "Body": "<p>A desirable property of a namespace system is that of what I call <em>incremental API compatibility</em>. That is, if I add a symbol to a namespace, then any previously working program should keep working and mean the same thing.</p>\n<p>Now, plain C++ with overloads is not <em>incrementally API compatible</em>:</p>\n<pre><code>int foo(long x) { return 1; }\n\nint main()\n{\n    foo(0);\n}\n</code></pre>\n<p>Now I add the overload <code>int foo(int x) { return 2; }</code> and the program silently changes meaning.</p>\n<p>Anyway, when C++ people designed the <code>namespace</code> system they wanted that when incrementing an external API, previously working code should not change the namespace from where the symbol is chosen. From your example, the previous working code would be something like:</p>\n<pre><code>namespace A {\n    //no fn here, yet    \n}\n\nnamespace Inner {\n\n    int fn() { return 2; }\n\n    namespace B {\n\n        using namespace A;\n        int z = fn();\n    }\n}\n</code></pre>\n<p>And <code>z</code> is easily initialized to <code>2</code>. Now augmenting namespace <code>A</code> with a symbol named <code>fn</code> will not change the meaning of that working code.</p>\n<p>The opposite case does not really apply:</p>\n<pre><code>namespace A {\n    int fn() { return 1; }\n}\n\nnamespace Inner {\n\n    // no fn here\n\n    namespace B {\n\n        using namespace A;\n        int z = fn();\n    }\n}\n</code></pre>\n<p>Here <code>z</code> is initialized to <code>1</code>. Of course, if I add <code>fn</code> to <code>Inner</code> it will change the meaning of the program, but <code>Inner</code> is not an external API: actually, when <code>Inner</code> was written initially, <code>A::fn</code> did already exist (it was being called!), so there is no excuse for being unaware of the clash.</p>\n<hr>\n<h2>A somewhat practical example</h2>\n<p>Imagine this C++98 program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A {\nint move = 0;\nvoid foo()\n{\n    using namespace std;\n    cout &lt;&lt; move &lt;&lt; endl;\n    return 0;\n}\n}\n\nint main()\n{\n    A::foo();\n    return 0;\n}\n</code></pre>\n<p>Now, if I compile this with C++11, everything works fine thanks to this <code>using</code> rule. If <code>using namespace std</code> worked as applying using declarations for everything in that namespace, then this program would try to print function <code>std::move</code> instead of  <code>A::move</code>.</p>\n</hr>", "LastActivityDate": "2017-07-06T13:47:53.537", "CommentCount": "0", "CreationDate": "2017-07-06T13:47:53.537", "ParentId": "44912330", "Score": "2", "OwnerUserId": "865874"}});