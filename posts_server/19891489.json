post_cb({"19891938": {"Id": "19891938", "PostTypeId": "2", "Body": "<p>You would need to skip anything inside of <code>()</code> brackets.<br>\nYou need to look at the identifier before the <code>&lt;</code> and know if it's a type name or not.  </br></p>\n<p>This second one is the problematic one, you need to scan through all your source code and identify all the names of <code>class/struct/union</code>s and <code>typedef</code>s so that when you reach an expression of the form <code>__w &lt; __a</code> (simplified for this example) you know whether or not <code>__w</code> names a type.<br>\nThe reason this gets problematic is if you encounter any Preprocessor Metaprogramming (like Boost's library on the subject) you're basically stuck writing a program that can evaluate these to see what type names were created.<br>\nFurthermore, consider this piece of code (a little more complicated than necessary to show how hard it is):</br></br></p>\n<pre><code>    template &lt;template &lt;class&gt; class T&gt;\n    struct Base\n    {\n        template &lt;class X&gt;\n        using type = T&lt;X&gt;;\n    };\n\n    template &lt;&gt;\n    struct Base&lt;std::numeric_limits&gt;//Let's assume numeric_limits only has one template argument for this example\n    {\n        static const int type = 0;\n    };\n\n    template &lt;class T, Base&lt;T&gt;::type &lt; 0&gt;\n    struct OtherClass{};\n</code></pre>\n<p>This kind of complexity is what the <code>typename</code> keyword is for, since <code>Base&lt;T&gt;</code> is a dependent scope, you can't tell right away whether <code>Base&lt;T&gt;::type</code> names a type or a member variable.  In this way the grammar requires that <code>Base&lt;T&gt;::type</code> be a member variable and <code>typename Base&lt;T&gt;::type</code>  be a type (we don't know what kind of type, but that's okay we're only trying to find the end of the template identifier list).<br>\nFurther to the example above you also need to handle the lesser known use of the <code>template</code> keyword.  Since <code>Base&lt;T&gt;</code> is a dependent scope, how do you parse <code>Base&lt;T&gt;::type&lt;0&gt;</code>?  This depends on what <code>type</code> is.  The grammar, in this case, requires that <code>Base&lt;T&gt;::type</code> be a member variable and be parsed as <code>(Base&lt;T&gt;::type &lt; 0) &gt;</code>, and <code>Base&lt;T&gt;::template type&lt;0&gt;</code> is a template expression.</br></p>\n<p>The keywords <code>typename</code> and <code>template</code>, while difficult to wrap your mind around until you understand dependent scopes, make your job easier for you in the end.  Otherwise, the simple question of where does a template identifier list end becomes nigh-impossible to answer without writing a full compiler (and even then the compiler is much more difficult to write).</p>\n<p>Dependent scopes aside, you still need to be able to handle non-dependent scopes.  This means you need to know whether <code>Base&lt;numeric_limits&gt;::type</code> is a type or not, which means scanning every <code>struct/class/union</code> for <code>typedef</code>s and resolving public inheritance for base class <code>typedef</code>s and private inheritance + <code>using</code> statements.</p>\n<p>If you restrict yourself to code that compiles, your job remains tractable, otherwise you have a lot more work ahead of you.</p>\n<p>I don't promise this is everything, only that this will in all likelihood keep you busy for a while.</p>\n", "LastActivityDate": "2013-11-10T16:12:54.160", "CommentCount": "0", "CreationDate": "2013-11-10T16:12:54.160", "ParentId": "19891489", "Score": "1", "OwnerUserId": "1277769"}, "bq_ids": {"n4140": {"so_19891489_19891924_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 71}}, "n3337": {"so_19891489_19891924_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 66}}, "n4659": {"so_19891489_19891924_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 73}}}, "19891924": {"Id": "19891924", "PostTypeId": "2", "Body": "<p>There's really no easy way to find the end of any valid template identifier list, because there are even more pathological possibilities than the example from <code>bits/random.h</code>. (There's a an example of a pathological case at the end of this answer: <a href=\"https://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive/14589567#14589567\">Is C++ context-free or context-sensitive?</a> in which an identifier is a template or not depending on whether a largish integer is prime.)</p>\n<p>The algorithm is easy to state (it's in paragraph 3 of \u00a714.2 of the C++11 standard, <code>[temp.names]</code>). Basically, a <code>&lt;</code> is a template bracket if and only if it follows a template identifier, the word <code>template</code> or one of the <code>cast</code> operators. Once you have an open <code>&lt;</code>, it's matched by the first <code>&gt;</code> which is not nested inside some parenthetic syntax (including braces and brackets) and which does not match some nested template bracket. In C++11, this includes <code>&gt;</code> which are part of a <code>&gt;&gt;</code> token. </p>\n<p>As an example, had the <code>random.h</code> example said <code>bool = __w &gt; ...</code>, the <code>&gt;</code> would have been considered a closing template bracket. But since it was a <code>&lt;</code> and <code>__w</code> is not a template identifier, it's treated as a less-than operator. IMHO good style is always to wrap comparison and shift operators in parentheses if they're inside of template brackets, but that's just me.</p>\n<p>The precise wording of the standard:</p>\n<blockquote>\n<p id=\"so_19891489_19891924_0\">After name lookup finds that a name is a <em>template-name</em> or that an <em>operator-function-id</em> or a <em>literal operator-id</em> refers to a set of overloaded functions any member of which is a function template if this is followed by a <code>&lt;</code>, the <code>&lt;</code> is always taken as the delimiter of a <em>template-argument-list</em> and never as the less-than operator. When parsing a <em>template-argument-list</em>, the first non-nested <code>&gt;</code> is taken as the ending delimiter rather than a greater-than operator.</p>\n</blockquote>\n<p>The algorithm is hard to implement because there is no easy way to know what identifiers are template identifiers because you need to parse the entire program (at least, up to the point of use) to know what kind of thing each identifier is. And that includes finding and parsing included files, and otherwise preprocessing the source code.</p>\n<p>If you really want it to be accurate, you need to use a C++ parser and be aware that it is potentially quite a slow process, since it can include template instantiation (as with the cited prime-check example). If you're just trying to do something like syntax colouring, you can probably get away with an approximation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-11T04:05:31.327", "Score": "2", "CreationDate": "2013-11-10T16:12:13.700", "ParentId": "19891489", "CommentCount": "0", "OwnerUserId": "1566221", "LastEditDate": "2017-05-23T10:25:00.233"}, "19891489": {"ViewCount": "99", "Body": "<p>Let's say one, for parsing purposes, wants to skip the contents of the template identifier list:</p>\n<pre><code>template&lt;(valid code)&gt;\n        ^            ^\n        | from       | to\n</code></pre>\n<p>The first thing that comes to mind would be to blindly find the first &gt;, but that doesn't always work:</p>\n<pre><code>template&lt;(valid code),template&lt;(valid code)&gt; &gt;\n        ^                                  ^\n        | from                             | to, oops\n</code></pre>\n<p>A better approach is to skip pairs of &lt; and &gt; recursively:</p>\n<pre><code>template&lt;(valid code),template&lt;(valid code)&gt; &gt;\n        ^                                    ^\n        | from                               | to, better\n</code></pre>\n<p>However, even this approach fails for arcane but valid masterpieces like this one (from bits\\random.h, line 69, GCC 4.7.x):</p>\n<pre><code>template&lt;(...),bool = __w &lt; static_cast&lt;size_t&gt;(...)&gt;\n        ^                 ^            ^      ^     ^     ^\n        | 1               | 2          | 3    | 2   | 1   | where did 0 go?\n</code></pre>\n<p><strong>My question is then, what is a correct way to find the end of any valid template identifier list?</strong></p>\n", "AcceptedAnswerId": "19891924", "Title": "Find end of C++ template identifier list", "CreationDate": "2013-11-10T15:26:45.763", "Id": "19891489", "CommentCount": "2", "LastEditDate": "2013-11-10T16:14:35.020", "PostTypeId": "1", "LastEditorUserId": "377393", "LastActivityDate": "2013-11-11T04:05:31.327", "Score": "3", "OwnerUserId": "1419235", "Tags": "<c++><parsing><templates>", "AnswerCount": "2"}});