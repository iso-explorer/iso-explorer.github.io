post_cb({"31066712": {"CommentCount": "0", "CreationDate": "2015-06-26T06:49:57.253", "PostTypeId": "1", "AcceptedAnswerId": "31067392", "LastEditorUserId": "1938163", "LastActivityDate": "2015-06-26T07:56:13.237", "AnswerCount": "2", "LastEditDate": "2015-06-26T07:39:32.740", "ViewCount": "120", "FavoriteCount": "0", "Title": "Understanding template argument deduction", "Id": "31066712", "Score": "9", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nusing v_itt = typename std::vector&lt;T&gt;::iterator;\n\ntemplate &lt;typename T&gt;\nvoid foo(v_itt&lt;T&gt;){ }\n\nint main() {\n    typename std::vector&lt;long&gt;::iterator i = std::vector&lt;long&gt;().begin();\n    foo(i); //candidate template ignored: couldn't infer template argument 'T'\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fa007b07c04cefd8\" rel=\"nofollow\">DEMO</a></p>\n<p>What's wrong with the code? I thought the <code>T</code> should have been deduced to <code>long</code>. Is there a way to fix that somehow?</p>\n", "Tags": "<c++><templates>", "OwnerDisplayName": "user2953119"}, "31067392": {"ParentId": "31066712", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-06-26T07:26:12.760", "Score": "5", "LastEditorUserId": "1938163", "LastEditDate": "2015-06-26T07:38:43.763", "Id": "31067392", "OwnerUserId": "1938163", "Body": "<pre><code>typename std::vector&lt;T&gt;::iterator\n</code></pre>\n<p><code>iterator</code> (a dependent type) it is <strong>not deducible</strong> in your code since it is in a nested name specifier and the standard says</p>\n<p>\u00a714.8.2.5/4</p>\n<blockquote>\n<p id=\"so_31066712_31067392_0\">In certain contexts, however, the value does not participate in type deduction, but instead uses the values of template arguments that were either deduced elsewhere or explicitly specified. <strong>If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.</strong></p>\n</blockquote>\n<p>and \u00a714.8.2.5/5</p>\n<blockquote>\n<p id=\"so_31066712_31067392_1\">The non-deduced contexts are:</p>\n<p id=\"so_31066712_31067392_2\">\u2014 The nested-name-specifier of a type that was specified using a qualified-id.</p>\n</blockquote>\n<p>so this is a non-deduced context.</p>\n<p>Possible workarounds:</p>\n<ol>\n<li>Pass a vector reference instead of an iterator</li>\n<li>Use tag dispatching and <a href=\"http://www.mersenneforum.org/showpost.php?s=1c4961ed7d9f81a9991f752f5a04b3b0&amp;p=336909&amp;postcount=4\">compile time assertions</a> to verify your iterator</li>\n</ol>\n", "LastActivityDate": "2015-06-26T07:38:43.763"}, "31067949": {"ParentId": "31066712", "CommentCount": "4", "CreationDate": "2015-06-26T07:56:13.237", "OwnerUserId": "2508150", "PostTypeId": "2", "Id": "31067949", "Score": "3", "Body": "<p>I'd like just to add a possible workaround 3 to Marco's answer:</p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nvoid real_foo( typename std::vector&lt;T&gt;::iterator){}\n\ntemplate &lt;typename T&gt;\nvoid foo(T i){ real_foo&lt;typename decltype(i)::value_type&gt;(i); }\n\nint main() {\n    std::vector&lt;long&gt; v;\n    foo(v.begin());\n}\n</code></pre>\n", "LastActivityDate": "2015-06-26T07:56:13.237"}, "bq_ids": {"n4140": {"so_31066712_31067392_0": {"section_id": 335, "quality": 1.0, "length": 30}, "so_31066712_31067392_2": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_31066712_31067392_0": {"section_id": 325, "quality": 1.0, "length": 30}, "so_31066712_31067392_2": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_31066712_31067392_0": {"section_id": 344, "quality": 1.0, "length": 30}, "so_31066712_31067392_2": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}}}});