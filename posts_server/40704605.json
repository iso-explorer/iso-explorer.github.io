post_cb({"40704605": {"CommentCount": "7", "ViewCount": "74", "CreationDate": "2016-11-20T13:31:48.200", "LastActivityDate": "2016-11-21T00:56:20.230", "Title": "Deduction and parameter pack that is not the last template parameter: is this valid code?", "AcceptedAnswerId": "40705233", "PostTypeId": "1", "Id": "40704605", "Score": "3", "Body": "<p>Consider the following minimal example:</p>\n<pre><code>template&lt;typename... A, typename R&gt;\nvoid f(A&amp;&amp;..., R(*)(A...)) {}\n\nvoid g(int, char) {}\n\nint main() {\n    f&lt;int, char&gt;(42, 'c', g);\n}\n</code></pre>\n<p>The parameter pack <code>A</code> is not the last parameter.<br>\nAnyway, I thought <code>R</code> could have been deduced from the function pointer because of <a href=\"http://eel.is/c++draft/temp#param-11\" rel=\"nofollow\">[temp.param]/11</a>.</br></p>\n<p>GCC (6.2) <a href=\"https://godbolt.org/g/8QCAcn\" rel=\"nofollow\">agrees with me</a> on this, while clang (3.9) <a href=\"https://godbolt.org/g/YFtfW2\" rel=\"nofollow\">rejects the code</a> and says that it <em>could not infer template argument <code>R</code></em>.</p>\n<p>Was my expectation wrong, thus GCC shouldn't accept it, or is an issue of clang? </p>\n", "Tags": "<c++><templates><gcc><clang><language-lawyer>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "40705233": {"ParentId": "40704605", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-11-20T14:29:56.820", "Score": "1", "LastEditorUserId": "5386374", "LastEditDate": "2016-11-21T00:56:20.230", "Id": "40705233", "OwnerUserId": "4115625", "Body": "<p>From that mentioned paragraph:</p>\n<blockquote>\n<p id=\"so_40704605_40705233_0\">If a template-parameter of a class template, variable template, or alias template has a default template-argument, each subsequent template-parameter shall either have a default template-argument supplied or be a template parameter pack. If a template-parameter of a primary class template, primary variable template, or alias template is a template parameter pack, it shall be the last template-parameter. <strong>A template parameter pack of a function template shall not be followed by another template parameter <em>unless that template parameter can be deduced from the parameter-type-list ([dcl.fct])</em> of the function template or <em>has a default argument ([temp.deduct])</em>.</strong> A template parameter of a deduction guide template ([temp.deduct.guide]) that does not have a default argument shall be deducible from the parameter-type-list of the deduction guide template. [ Example:</p>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B;   // error\n\n// U can be neither deduced from the parameter-type-list nor specified\ntemplate&lt;class... T, class... U&gt; void f() { } // error\ntemplate&lt;class... T, class U&gt; void g() { }    // error\n</code></pre>\n<p id=\"so_40704605_40705233_1\">\u2014 end example ]</p>\n</blockquote>\n<p>In this case, <code>template&lt;typename... A, typename R&gt;</code> can't be deduced from the parameter-type-list of function template because with:</p>\n<pre><code>void f(A&amp;&amp;..., R(*)(A...))\n</code></pre>\n<p><code>A&amp;&amp;...</code> is greedy, and it will consume <code>g</code> as <code>A&amp;&amp;</code> not <code>R(*)(A...)</code></p>\n<p>Speaking pedantic, as in <a href=\"http://eel.is/c++draft/temp.fct.spec#temp.deduct.call-1\" rel=\"nofollow noreferrer\">temp.deduct.call-1</a>:</p>\n<blockquote>\n<p id=\"so_40704605_40705233_2\">For a function parameter pack that occurs at the end of the parameter-declaration-list, deduction is performed for each remaining argument of the call, taking the type P of the declarator-id of the function parameter pack as the corresponding function template parameter type. Each deduction deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack. <strong>When a function parameter pack appears in a non-deduced context (<a href=\"http://eel.is/c++draft/temp.deduct.type#9\" rel=\"nofollow noreferrer\"><code>[temp.deduct.type]</code></a>), the type of that parameter pack is never deduced.</strong></p>\n</blockquote>\n<p>and as in <a href=\"http://eel.is/c++draft/temp.deduct.type#9\" rel=\"nofollow noreferrer\">temp.deduct.type#9</a>:</p>\n<blockquote>\n<p id=\"so_40704605_40705233_3\">If P has a form that contains &lt;T&gt; or &lt;i&gt;, then each argument Pi of the respective template argument list of P is compared with the corresponding argument Ai of the corresponding template argument list of A. <strong>If the template argument list of P contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context. If Pi is a pack expansion, then the pattern of Pi is compared with each remaining argument in the template argument list of A.</strong></p>\n</blockquote>\n<p>And it can't be specified as you can see in the third example.</p>\n<p>clang is right when reject it.</p>\n", "LastActivityDate": "2016-11-21T00:56:20.230"}, "bq_ids": {"n4140": {"so_40704605_40705233_3": {"section_id": 340, "quality": 1.0, "length": 42}, "so_40704605_40705233_0": {"section_id": 64, "quality": 0.6714285714285714, "length": 47}, "so_40704605_40705233_2": {"section_id": 302, "quality": 0.7843137254901961, "length": 40}}, "n3337": {"so_40704605_40705233_3": {"section_id": 330, "quality": 1.0, "length": 42}, "so_40704605_40705233_0": {"section_id": 59, "quality": 0.6285714285714286, "length": 44}, "so_40704605_40705233_2": {"section_id": 293, "quality": 0.6666666666666666, "length": 34}}, "n4659": {"so_40704605_40705233_3": {"section_id": 349, "quality": 1.0, "length": 42}, "so_40704605_40705233_0": {"section_id": 66, "quality": 0.9428571428571428, "length": 66}, "so_40704605_40705233_2": {"section_id": 309, "quality": 0.9607843137254902, "length": 49}}}});