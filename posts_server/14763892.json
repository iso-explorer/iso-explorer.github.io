post_cb({"14764009": {"ParentId": "14763892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://www.unl.csi.cuny.edu/faqs/g++-faq/wp/sep96/cpp.html#cpp\" rel=\"nofollow\">Clause 16</a> states:</p>\n<blockquote>\n<p id=\"so_14763892_14764009_0\">all  white  space  is\n    equivalent  except in certain situations during preprocessing (see the\n    # character string literal creation operator in  <em>cpp.stringize</em>,  for\n    example).</p>\n</blockquote>\n<p>You can read about <a href=\"http://www.unl.csi.cuny.edu/faqs/g++-faq/wp/sep96/cpp.html#cpp.stringize\" rel=\"nofollow\">The # Operator [ccp.stringize] here</a>.  Here's the relevant info:</p>\n<blockquote>\n<p id=\"so_14763892_14764009_1\">If,  in the replacement list, a parameter is immediately preceded by a\n    <code>#</code> preprocessing token, both are replaced by a single character  string\n    literal  preprocessing token that contains the spelling of the prepro\u00adcessing token sequence for the corresponding  argument.   Each  occur\u00adrence  of  white  space  between  the  argument's preprocessing tokens\n    becomes a single space character  in  the  character  string  literal.\n    White  space  before  the first preprocessing token and after the last\n    preprocessing token comprising the argument  is  deleted.   Otherwise,\n    the  original  spelling of each preprocessing token in the argument is\n    retained in the character string literal, except for special  handling\n    for  producing the spelling of string literals and character literals:\n    a <code>\\</code> character is inserted before each <code>\"</code> and <code>\\</code> character of a character\n    literal or string literal (including the delimiting <code>\"</code> characters).  If\n    the replacement that results is not a valid character string  literal,\n    the behavior is undefined.  The order of evaluation of <code>#</code> and <code>##</code> opera\u00adtors is unspecified.</p>\n</blockquote>\n", "OwnerUserId": "1159604", "LastEditorUserId": "15168", "LastEditDate": "2013-02-08T01:00:26.773", "Id": "14764009", "Score": "1", "CreationDate": "2013-02-08T00:56:26.733", "LastActivityDate": "2013-02-08T01:00:26.773"}, "14764515": {"ParentId": "14763892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are several occasions during phase 4 where whitespace is significant:</p>\n<ul>\n<li><p>Each preprocessing directive begins with a <code>#</code> token that \"is either the first character in the source file...or that follows white space containing at least one new-line character.\"  Each preprocessing directive ends with a new-line character.</p></li>\n<li><p>In a function-like macro definition, the left parenthesis that begins the parameter list must immediately follow the identifier that names the macro.  There must be no whitespace between them.</p>\n<p>For example, the directive <code>#define F()</code> defines a function-like macro that expands to nothing, whereas the directive <code>#define F ()</code> defines an object-like macro that expands to <code>()</code>.</p></li>\n<li><p>Whitespace is accounted for during stringization, when the <code>#</code> operator is evaluated during macro replacement.  Sequences of whitespace between tokens to be stringized are collapsed to a single space in the resulting string literal.</p>\n<p>For example, the character sequence <code>f(x)</code> is stringized as <code>\"f(x)\"</code>, but the character sequence <code>f ( x )</code> is stringized as <code>\"f ( x )\"</code>, even though there is no semantic difference between these two after macro replacement.</p></li>\n</ul>\n<p>Note that escaped new-line characters are eliminated in phase 2 and each comment is replaced by a single space character in phase 3.  Both of these take place before phase 4, so during phase 4 an escaped new-line does not count as a new-line and a comment is indistinguishable from a space character.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2013-02-08T21:04:56.203", "Id": "14764515", "Score": "8", "CreationDate": "2013-02-08T01:56:59.490", "LastActivityDate": "2013-02-08T21:04:56.203"}, "14763892": {"CommentCount": "4", "ViewCount": "396", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2013-02-08T00:44:17.513", "LastActivityDate": "2013-02-08T21:04:56.203", "Title": "Whitespace in C++11 more than preprocessing token separation?", "AcceptedAnswerId": "14764515", "LastEditDate": "2013-02-08T00:46:26.683", "Id": "14763892", "Score": "2", "Body": "<p>In C++11 2.5 Preprocessing tokens [lex.pptoken]:</p>\n<blockquote>\n<p id=\"so_14763892_14763892_0\">As described in Clause 16,\n  in certain circumstances during translation phase 4, white space (or the absence thereof) serves as more than preprocessing token separation.</p>\n</blockquote>\n<p>Which circumstances is this referring to?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14763892_14763892_0": {"section_id": 5321, "quality": 1.0, "length": 17}, "so_14763892_14764009_1": {"section_id": 526, "quality": 0.9894736842105263, "length": 94}, "so_14763892_14764009_0": {"section_id": 491, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_14763892_14763892_0": {"section_id": 5118, "quality": 1.0, "length": 17}, "so_14763892_14764009_1": {"section_id": 517, "quality": 0.9894736842105263, "length": 94}, "so_14763892_14764009_0": {"section_id": 482, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_14763892_14763892_0": {"section_id": 6742, "quality": 1.0, "length": 17}, "so_14763892_14764009_1": {"section_id": 547, "quality": 0.9894736842105263, "length": 94}, "so_14763892_14764009_0": {"section_id": 506, "quality": 0.9411764705882353, "length": 16}}}});