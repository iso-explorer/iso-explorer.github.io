post_cb({"5024218": {"ViewCount": "2026", "Body": "<p>I'm trying to implement a basic shift cipher in C++. I can't move forward until I figure out what's causing the segmentation fault.\nI stepped through the code using gdb and the problem seems to stem from the iterator. </p>\n<pre><code> 1 #include &lt;iostream&gt;\n 2 #include &lt;string&gt;\n 3 \n 4 std::string encrypt (std::string plain, int key);\n 5 \n 6 int main()\n 7 {\n 8         std::string plaintext;\n 9         std::getline(std::cin,plaintext,'\\n');\n 10        encrypt(plaintext,3);   \n 11 }\n 12 \n 13 std::string encrypt(std::string plain, int key)\n 14 {\n 15         std::string::iterator ic;\n 16         for (ic= plain.begin(); ic != plain.end();++ic)\n 17         {\n 18                 std::cout &lt;&lt;*ic + key &lt;&lt; std::endl;\n 19         }\n 20 }\n</code></pre>\n<p>Error:</p>\n<pre><code>Program received signal SIGSEGV, Segmentation fault.\n0x00007ffff7b73ef1 in std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string() () from /usr/lib/libstdc++.so.6\n</code></pre>\n", "AcceptedAnswerId": "5024244", "Title": "Why do I get a segmentation fault while iterating through this string?", "CreationDate": "2011-02-17T01:37:33.243", "Id": "5024218", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-02-17T04:55:05.517", "Score": "5", "OwnerUserId": "620619", "Tags": "<c++><iterator>", "AnswerCount": "4"}, "5024244": {"Id": "5024244", "PostTypeId": "2", "Body": "<p>You have declared <code>encrypt</code> as returning an <code>std::string</code>, but you don't return anything from the function.  You need to return a value or you need to change the return type to be <code>void</code> to indicate that the function doesn't return anything.</p>\n<p>As for <em>why</em> it's crashing as written, I can only speculate.  It is likely that the compiler has generated a call to the <code>std::string</code> destructor in <code>main</code> to clean up the <code>std::string</code> object that <code>encrypt</code> returns.  Since <code>encrypt</code> doesn't actually return anything, the destructor ends up getting called for an object that doesn't exist.  The memory that should contain the object likely just contains garbage data and the destructor doesn't like that.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2011-02-17T01:47:25.737", "Score": "8", "CreationDate": "2011-02-17T01:42:22.483", "ParentId": "5024218", "CommentCount": "5", "OwnerUserId": "151292", "LastEditDate": "2011-02-17T01:47:25.737"}, "5024585": {"Id": "5024585", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5024218_5024585_0\">[C++2003 Standard section 6.6.3-2] Flowing off the end of a\n  function is equivalent to a return\n  with no value; this results in\n  undefined behavior in a\n  value-returning function.</p>\n</blockquote>\n<p>This is a very easy mistake to make if your compiler doesn't warn you.  You can save yourself a lot of debugging by enabling as many compiler warnings as possible.  In the case of gcc/g++, I suggest compiling with \"-Wall -Werror\" for any new code that you are writing.  With those options, compilation of this program fails with the following message:</p>\n<pre><code>cc1plus: warnings being treated as errors\nIn function 'std::string encrypt(std::string, int)':\nLine 20: warning: control reaches end of non-void function\n</code></pre>\n", "LastActivityDate": "2011-02-17T02:51:00.630", "CommentCount": "1", "CreationDate": "2011-02-17T02:51:00.630", "ParentId": "5024218", "Score": "5", "OwnerUserId": "86967"}, "bq_ids": {"n4140": {"so_5024218_5024585_0": {"length": 12, "quality": 0.75, "section_id": 3913}}, "n3337": {"so_5024218_5024585_0": {"length": 12, "quality": 0.75, "section_id": 3773}}, "n4659": {"so_5024218_5024585_0": {"length": 9, "quality": 0.5625, "section_id": 4799}}}, "5024263": {"Id": "5024263", "PostTypeId": "2", "Body": "<p>The problem is that your <code>encrypt</code> function lacks a <code>return</code> statement.</p>\n<p>Add</p>\n<pre><code>return \"blah blah\";\n</code></pre>\n<p>In addition to fixing that, consider passing strings by reference to <code>const</code>, like</p>\n<pre><code>std::string const&amp; plain\n</code></pre>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-02-17T01:45:46.523", "CommentCount": "3", "CreationDate": "2011-02-17T01:45:46.523", "ParentId": "5024218", "Score": "1", "OwnerUserId": "464581"}, "5024308": {"Id": "5024308", "PostTypeId": "2", "Body": "<p>Writing a loop, but changing it from using an index to using an iterator is usually a mistake. If you're going to use an explicit loop, it usually makes more sense to just continue to use an index, at least for something like <code>string</code> that allows random access. The primary point of iterators is to enable generic algorithms that aren't coupled to containers. To make good use of an iterator, use it with an algorithm:</p>\n<pre><code>int main() { \n    std::string plaintext;\n    std::getline(std::cin, plaintext);\n\n    std::transform(plaintext.begin(), plaintext.end(), \n                   std::ostream_iterator&lt;char&gt;(std::cout), \n                   std::bind2nd(std::plus&lt;int&gt;(), 3));\n    return 0;\n}\n</code></pre>\n<p>Edit: Since Hans Passant brought it up, a version using a lambda expression would look like this:</p>\n<pre><code>std::transform(line.begin(), line.end(), \n               std::ostream_iterator&lt;char&gt;(std::cout), \n               [](char ch) { return ch+'\\03'; });\n</code></pre>\n<p>Only relatively recent compilers support this though -- gcc &gt;= 4.6, Visual Studio &gt;= 2010.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2011-02-17T04:55:05.517", "Score": "3", "CreationDate": "2011-02-17T01:55:24.500", "ParentId": "5024218", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2011-02-17T04:55:05.517"}});