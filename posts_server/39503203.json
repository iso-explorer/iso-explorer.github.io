post_cb({"bq_ids": {"n4140": {"so_39503203_39503203_0": {"length": 16, "quality": 1.0, "section_id": 6109}, "so_39503203_39503316_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6109}}, "n3337": {"so_39503203_39503316_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 5875}, "so_39503203_39503203_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_39503203_39503316_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 7606}, "so_39503203_39503203_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "39503203": {"ViewCount": "74", "Body": "<p>I find myself have troubles in understanding following sentence quoted from C++ standard in 5.3.5$5: (emphasis is mine)</p>\n<blockquote>\n<p id=\"so_39503203_39503203_0\">If the object being deleted has <strong>incomplete</strong> class type at the point of deletion and the <strong>complete</strong> class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>I know this deleting incomplete type problem has been discussed several times in SO, and I can understand why deleting incomplete class type is undefined behavior. This <a href=\"https://stackoverflow.com/questions/2517245/why-really-deleting-an-incomplete-type-is-undefined-behaviour\">Q&amp;A</a> explains it very well. </p>\n<p>What I can't understand is the part about complete class type. Does it mean deleting a object of complete class has a non-trivial destructor or a deallocation function is undefined behavior? If so, please give some codes illustrating the undefined behavior that it could result in.</p>\n", "AcceptedAnswerId": "39503322", "Title": "Could deleting complete class type result in undefined behavior?", "CreationDate": "2016-09-15T04:37:24.213", "Id": "39503203", "CommentCount": "0", "LastEditDate": "2017-05-23T12:19:23.733", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-15T20:13:48.693", "Score": "3", "OwnerUserId": "5845611", "Tags": "<c++><undefined-behavior>", "AnswerCount": "3"}, "39503316": {"Id": "39503316", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39503203_39503316_0\">Does it mean deleting a object of complete class has a non-trivial destructor or a deallocation function is undefined behavior?</p>\n</blockquote>\n<p>No, as that would mean that</p>\n<pre><code>class Foo {\npublic:\n    ~Foo() { /*do something*/ };\n};\n</code></pre>\n<p>is undefined behavior, which isn't the case.</p>\n<p>You seem to already know that deleting an object which has an incomplete class type is undefined behavior. The thing is, it is only undefined behavior <em>if</em> the class has a non-trivial destructor/deallocation.</p>\n<p>It is not undefined behavior in this case:</p>\n<pre><code>//Foo is forward declared somewhere and destructed\n//This is the class definition not available at the point that it is destructed\nclass Foo {\npublic:\n    //~Foo() = default; \n};\n</code></pre>\n<p>It is only undefined in this case</p>\n<pre><code>class Foo {\npublic:\n    ~Foo() { /*do something*/ };\n};\n</code></pre>\n<p>Do note that even if <code>Foo</code> had a trivial destructor/deallocation, if <code>Foo</code> inherited from another class that had a non-trivial destructor/deallocation, it would still be undefined behavior.</p>\n", "LastEditorUserId": "3980929", "LastActivityDate": "2016-09-15T04:54:42.617", "Score": "2", "CreationDate": "2016-09-15T04:49:58.100", "ParentId": "39503203", "CommentCount": "2", "OwnerUserId": "3980929", "LastEditDate": "2016-09-15T04:54:42.617"}, "39503322": {"Id": "39503322", "PostTypeId": "2", "Body": "<p>There are two prerequisites for undefined behavior in the concerned case:</p>\n<ol>\n<li>Object is being deleted through a pointer to an incomplete type;</li>\n<li>The complete class of the object being deleted has a non-trivial destructor or a (user-defined) deallocation function.</li>\n</ol>\n<p>If either of these conditions is false, then there is no undefined behavior (at least due to the concern being discussed).</p>\n<p>This in particular means that</p>\n<ol>\n<li><p>Deleting an object of complete type is safe (because the right destructor and/or deallocation function will be executed).</p></li>\n<li><p>Deleting an object with a trivial destructor and without a user-defined deallocation function through a pointer to an incomplete type is safe (because in the absence of complete type information the compiler doesn't call the destructor and uses the default deallocation function, which perfectly matches what would happen had the deletion be performed through a pointer to complete type).</p></li>\n</ol>\n", "LastEditorUserId": "6394138", "LastActivityDate": "2016-09-15T20:13:48.693", "Score": "6", "CreationDate": "2016-09-15T04:50:32.743", "ParentId": "39503203", "CommentCount": "3", "OwnerUserId": "6394138", "LastEditDate": "2016-09-15T20:13:48.693"}, "39503314": {"Id": "39503314", "PostTypeId": "2", "Body": "<p>Let me try to explain what I understand using the code below:</p>\n<pre><code>struct Foo;\nstruct Bar;\n\nFoo* newFoo();\nBar* newBar();\n\nint main()\n{\n   // Get a pointer to Foo, somehow\n   Foo* fp = newFoo();\n\n   // Get a pointer to Bar, somehow\n   Bar* bp = newBar();\n\n   // Foo is an incomplete class at this point.\n   // This is OK since Foo has a trivial destructor.\n   delete fp;\n\n   // Bar is an incomplete class at this point.\n   // Not OK since Bar has a non-trivial destructor.\n   // This is cause for undefined behavior.\n   delete bp;\n}\n\nstruct Foo {};\n\nstruct Bar {\n   Bar() { data = new int[10]; }\n   ~Bar(){ delete [] data; }\n   int* data;\n};\n\nFoo* newFoo()\n{\n   return new Foo;\n}\n\nBar* newBar()\n{\n   return new Bar;\n}\n</code></pre>\n", "LastActivityDate": "2016-09-15T04:49:43.080", "CommentCount": "0", "CreationDate": "2016-09-15T04:49:43.080", "ParentId": "39503203", "Score": "2", "OwnerUserId": "434551"}});