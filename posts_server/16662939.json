post_cb({"16663114": {"ParentId": "16662939", "PostTypeId": "2", "CommentCount": "5", "Body": "<ol>\n<li>The code's buggy: change <code>array.clear();</code> to <code>array.~vector&lt;int&gt;();</code></li>\n</ol>\n<p>Explanation: <code>operator=</code> is using placement <code>new</code> over an object that hasn't been destructed, which could do anything but practically you can expect it to leak the dynamic memory the previous array had been using (<code>clear()</code> doesn't release memory / change capacity, it just destructs elements and changes <code>size</code>).</p>\n<p>From 9.5/2:</p>\n<blockquote>\n<p id=\"so_16662939_16663114_0\">If any non-static data member of a union has a non-trivial default\n  constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move\n  assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be\n  user-provided or it will be implicitly deleted (8.4.3) for the union.</p>\n</blockquote>\n<p>So, the <code>vector</code> constructor, destructor etc never kicks in by themselves: you must call them explicitly when wanted.</p>\n<p>In 9.5/3 there's an example:</p>\n<blockquote>\n<p id=\"so_16662939_16663114_1\">Consider the following union:</p>\n</blockquote>\n<pre><code>union U {\n    int i;\n    float f;\n    std::string s;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_16662939_16663114_2\">Since std::string (21.3) declares non-trivial versions of all of the special member functions, U will have\n  an implicitly deleted default constructor, copy/move constructor, copy/move assignment operator, and destructor.\n  To use U, some or all of these member functions must be user-provided.</p>\n</blockquote>\n<p>That last bit - \"To use U, some or all of these member functions must be user-provided.\" - seems to presume that <code>U</code> needs to coordinate its own vaguely value-semantic behaviour, but in your case the surrouding <code>struct</code> is doing that so you don't need to define any of these <code>union</code> member functions.</p>\n<p>2: we must call the array destructor whenever an array value is being replaced by a boolean value.  If in <code>operator=</code> a new array value is being placement-<code>new</code>ed instead of assigned, then the old array must also have its destructor called, but using <code>operator=</code> would be more efficient when the existing memory is sufficient for all the elements being copied.  Basically, you must match constructions and destructions.  UPDATE: the example code has a bug as per your comment below.</p>\n<blockquote>\n<p id=\"so_16662939_16663114_3\">3: Why a placement new is required instead of just doing something like 'array = ms.array' ?</p>\n</blockquote>\n<p>array = ms.array invokes <code>std::vector&lt;int&gt;::operator=</code> which always assumes the <code>this</code> pointer addresses an already properly constructed object.  Inside that object you can expect there to be a pointer which will either be NULL or refer to some internal short-string buffer, or refer to heap.  If your object hasn't been destructed, then <code>operator=</code> may well call a memory deallocation function on the bogus pointer.  Placement new says \"ignore the current content of the memory that this object will occupy, and construct a new object with valid members from scratch.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2013-05-21T08:40:01.037", "Id": "16663114", "Score": "2", "CreationDate": "2013-05-21T05:58:16.720", "LastActivityDate": "2013-05-21T08:40:01.037"}, "16662939": {"CommentCount": "1", "AcceptedAnswerId": "16663114", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-21T05:46:00.160", "LastActivityDate": "2013-05-21T08:48:24.047", "LastEditDate": "2017-05-23T12:33:43.717", "ViewCount": "1621", "FavoriteCount": "1", "Title": "Unrestricted union in practice", "Id": "16662939", "Score": "4", "Body": "<p>I have some questions about unrestricted unions and their application in practice.\nLet's suppose I have the following code :</p>\n<pre><code>struct MyStruct\n{\n    MyStruct(const std::vector&lt;int&gt;&amp; a) : array(a), type(ARRAY)\n    {}\n    MyStruct(bool b) : boolean(b), type(BOOL)\n    {}\n    MyStruct(const MyStruct&amp; ms) : type(ms.type)\n    {\n        if (type == ARRAY)\n            new (&amp;array) std::vector&lt;int&gt;(ms.array);\n        else\n            boolean = ms.boolean;\n    }\n    MyStruct&amp; operator=(const MyStruct&amp; ms)\n    {\n        if (&amp;ms != this) {\n            if (type == ARRAY)\n                array.~vector&lt;int&gt;(); // EDIT(2) \n            if (ms.type == ARRAY)\n                new (&amp;array) std::vector&lt;int&gt;(ms.array);\n            else\n                boolean = ms.boolean;\n            type = ms.type;\n        }\n        return *this;\n    }\n    ~MyStruct()\n    {\n        if (type == ARRAY)\n            array.~vector&lt;int&gt;();\n    }\n\n    union {\n        std::vector&lt;int&gt; array;\n        bool             boolean;\n    };\n    enum {ARRAY, BOOL} type;\n};\n</code></pre>\n<ol>\n<li>Is this code valid :) ?</li>\n<li>Is it necessary to explicitly call the vector destructor each time we are using the boolean (as stated here <a href=\"http://cpp11standard.blogspot.com/2012/11/c11-standard-explained-1-unrestricted.html\" rel=\"nofollow noreferrer\">http://cpp11standard.blogspot.com/2012/11/c11-standard-explained-1-unrestricted.html</a>)</li>\n<li>Why a placement new is required instead of just doing something like 'array = ms.array' ?</li>\n</ol>\n<p><strong>EDIT:</strong></p>\n<ul>\n<li>Yes, it compiles</li>\n<li>\"Members declared inside anonymous unions are actually members of the containing class, and can be initialized in the containing class's constructor.\" (<a href=\"https://stackoverflow.com/questions/10693913/c11-anonymous-union-with-non-trivial-members\">C++11 anonymous union with non-trivial members</a>)</li>\n<li>Adding explicit destructors as suggested, leads to SIGSEV with g++ 4.8 / clang 4.2 </li>\n</ul>\n", "Tags": "<c++><c++11><unions>", "OwnerUserId": "2404064", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16662939_16663114_0": {"section_id": 5914, "quality": 0.8, "length": 28}, "so_16662939_16663114_2": {"section_id": 5915, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_16662939_16663114_0": {"section_id": 5686, "quality": 0.8, "length": 28}, "so_16662939_16663114_2": {"section_id": 5687, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_16662939_16663114_0": {"section_id": 7406, "quality": 0.8, "length": 28}, "so_16662939_16663114_2": {"section_id": 7407, "quality": 0.9655172413793104, "length": 28}}}, "16663503": {"ParentId": "16662939", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><strike>The union does not declare a default constructor, copy constructor, copy assignment operator, or destructor.</strike></p>\n<p>If <code>std::string</code> declares at least one non-trivial version of a special member function (which is the case), the forementioned ones are all implicitly deleted, and you must declare (and define) them (... if they're used, which is the case).</p>\n<p>Insofar, that code isn't correct and should not successfully compile (this is almost-to-the-letter identical to the example in 9.5 par 3 of the standard, except there it's <code>std::string</code>, not <code>std::vector</code>).</p><br>\n(Does not apply for an anon union, as correctly pointed out)</br>\n<p>About question (2): In order to safely switch the union, this is necessary, yes. The Standard explicitly says that in 9.5 par 4 [Note].<br>\nIt makes sense too, if you think about it. At most one data member can be active in a <code>union</code> at any time, and they're not magically default constructed/destroyed, which means you need to properly construct/destruct things. It is not meaningful (or even defined) to use the <code>union</code> as something else otherwise (not that you <em>couldn't</em> do that anyway, but it's undefined).<br>\nThe object is not a pointer, and you don't know whether it's allocated on the heap either (even if it is allocated on the heap, then it's <em>inside</em> another object, so it's still not allowable to delete it). How do you destroy an object if you can't call <code>delete</code>? How do you allocate an object -- possibly several times -- without leaking if you can't delete it? This doesn't leave many choices. Insofar, the [Note] makes perfect sense.</br></br></p>\n", "OwnerUserId": "572743", "LastEditorUserId": "572743", "LastEditDate": "2013-05-21T08:01:12.590", "Id": "16663503", "Score": "1", "CreationDate": "2013-05-21T06:28:31.027", "LastActivityDate": "2013-05-21T08:01:12.590"}});