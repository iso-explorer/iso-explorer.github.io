post_cb({"7455484": {"PostTypeId": "2", "ParentId": "7453583", "Body": "<p>If I can give my 2 cents, I think the standard library \"flawed\" a bit, with all the good intentions.</p>\n<p>The <code>operator void*()</code> had been introduced to allow code like\n<code>while(stream)</code> or <code>if(!stream)</code> or <code>while(stream &amp;&amp; ...)</code>, without giving an implicit access to integer arithmetic (that <code>operator bool</code> whould have given).\nIn fact, this disable integer arithmetic, but gives access to pointer features (like delete ...).</p>\n<p>Now, in C++0x, an <code>explicit oeprator bool()</code> had been introduced. It doesn't implicitly give access to whatever feature, since it requires an implicit conversion. But ... wait a bit: 'while(bool(stream))' or even <code>while(static_cast&lt;bool&gt;(stream))</code> are so wordy...\nOperator ! is explicit, and \n'while(!!stream)' looks so effective that I even wonder why not accept this as a paradigm:</p>\n<p>If I want something to be explicitly converted into bool, I just provide an <code>operator!()</code>\nand give to <code>!</code> the memaning of \"is not valid\" and of <code>!!</code> as \"is valid\".</p>\n<p>Much safer then an implicit conversion and not uselessly wordy: after all <code>!</code> exist from ever!</p>\n", "CreationDate": "2011-09-17T14:28:35.737", "Score": "0", "CommentCount": "4", "Id": "7455484", "OwnerUserId": "924727", "LastActivityDate": "2011-09-17T14:28:35.737"}, "7453660": {"PostTypeId": "2", "ParentId": "7453583", "Body": "<p>It has apparently been fixed.</p>\n<p>At least, in N3290 you have <code>std::basic_ios::operator bool</code> instead of that <code>void*</code> conversion, and this <code>operator bool</code> is declared <strong><code>explicit</code></strong>.</p>\n<p>Note that C++98/C++03 did not support <code>explicit</code> type conversion operators, but C++11 does.</p>\n<p>An <code>explicit</code> type conversion operator</p>\n<blockquote>\n<p id=\"so_7453583_7453660_0\"><strong>N3290 \u00a712.3.2/2;</strong><br>\n  is only considered as a user-defined conversion\n  for direct-initialization (8.5)</br></p>\n</blockquote>\n<p>And that might seem to be impractical for the <em>condition</em> in e.g. a <code>while</code> or <code>for</code> statement.</p>\n<p>Happily, </p>\n<blockquote>\n<p id=\"so_7453583_7453660_1\"><strong>N3290 \u00a74/3;</strong><br>\n  An expression <code>e</code> can be <em>implicitly converted</em> to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). Certain language constructs require that an expression be converted to a Boolean value.\n  An expression <code>e</code> appearing in such a context is said to be <em>contextually converted to <code>bool</code></em> and is well-formed if and only if the declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of either implicit conversion is the same as performing the\n  declaration and initialization and then using the temporary variable as the result of the conversion.</br></p>\n</blockquote>\n<p>where <code>bool t(e);</code> is a <em>direct-initialization</em>.</p>\n<p>E.g. you don\u2019t have to explicit convert a stream object used as condition in a <code>while</code>, because there is implicitly an explicit conversion (he he).</p>\n<p>Unfortunately, searching N3290 I can\u2019t find any list of the \u201ccertain language constructs\u201d where this happens, but in comments to this answer JohannesD wrote:</p>\n<blockquote>\n<p id=\"so_7453583_7453660_2\">Searched through the FDIS for \u201ccontextually\u201d, and the whole list seems to be: <strong><code>if</code></strong>, <strong><code>while</code></strong>,\n  <strong><code>do</code></strong>, <strong><code>for</code></strong>, <strong><code>noexcept</code></strong>, and <strong><code>static_assert</code></strong> conditions; the first operand of <strong><code>?:</code></strong>; both\n  operands of <strong><code>&amp;&amp;</code></strong> and <strong><code>||</code></strong>; and the operand of <strong><code>!</code></strong>.</p>\n</blockquote>\n<p>Cheers &amp; hth.,</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-09-25T00:28:14.833", "LastEditDate": "2011-09-25T00:28:14.833", "CommentCount": "11", "Id": "7453660", "OwnerUserId": "464581", "Score": "17", "CreationDate": "2011-09-17T08:56:51.450"}, "7453583": {"LastEditDate": "2017-05-23T10:29:40.417", "Body": "<p>Will the following give a compilation error?</p>\n<pre><code>delete cout;\ndelete cin;\n</code></pre>\n<p>The answer is : No.  </p>\n<p>It is a flaw in the implementation of stream classes from the Standard library. They  have the following conversion function to <a href=\"http://www.cplusplus.com/reference/iostream/ios/operator_voidpt/\" rel=\"nofollow noreferrer\"><code>void*</code></a> type, which means, all stream objects can be <em>implicitly</em> converted to <code>void*</code>:</p>\n<pre><code>operator void * ( ) const;\n</code></pre>\n<p>This is very useful in general as it lets us write <a href=\"https://stackoverflow.com/questions/6404352/c-rewrite-a-file-but-leaving-out-everything-before-a-word\">very idiomatic loop</a>, say, when reading input from files. But at the same time, it lets user to write <code>delete stream</code>. As I said, you can delete any stream object. So all of these are allowed:</p>\n<pre><code>delete ss;  //declare std::stringstream ss;\ndelete iss; //declare std::istringstream iss;\ndelete oss; //declare std::ostringstream oss;\n</code></pre>\n<p>Only that they'll give a warning, saying (see at <a href=\"http://ideone.com/qdkWO\" rel=\"nofollow noreferrer\">ideone</a>):</p>\n<blockquote>\n<p id=\"so_7453583_7453583_0\">warning: deleting \u2018void*\u2019 is undefined</p>\n</blockquote>\n<p>which you can <a href=\"http://ideone.com/KZfUR\" rel=\"nofollow noreferrer\">easily avoid</a> just by casting, say, to<code>char*</code>. But the program has still issue, and most likely will crash when running it.</p>\n<p>--</p>\n<p>So my question is, has this issue been addressed and fixed, in C++11? The following article provides one fix for this problem:</p>\n<ul>\n<li><a href=\"http://www.artima.com/cppsource/safebool.html\" rel=\"nofollow noreferrer\">The Safe Bool Idiom</a></li>\n</ul>\n<p>--</p>\n<p>Edit:</p>\n<p>From @Xeo's comment on @Alf's answer:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/6242768/is-the-safe-bool-idiom-obsolete\">Is the safe-bool idiom obsolete in C++11?</a></li>\n</ul>\n<p>The paper which proposed a fix for this issue:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2333.html\" rel=\"nofollow noreferrer\">Explicit Conversion Operator\nDraft Working Paper \nRevision 1</a></li>\n</ul>\n", "LastEditorUserId": "-1", "Score": "13", "AcceptedAnswerId": "7453660", "CommentCount": "14", "OwnerUserId": "415784", "Title": "delete cout; delete cin; do not give compilation error - a flaw in the Standard library?", "LastActivityDate": "2015-08-07T04:36:47.027", "PostTypeId": "1", "Tags": "<c++><stream><c++11><implicit-conversion>", "AnswerCount": "2", "FavoriteCount": "3", "Id": "7453583", "ViewCount": "868", "CreationDate": "2011-09-17T08:42:04.313"}, "bq_ids": {"n3337": {"so_7453583_7453660_1": {"quality": 0.9215686274509803, "length": 47, "section_id": 2}}}});