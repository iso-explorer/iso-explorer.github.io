post_cb({"bq_ids": {"n4140": {"so_31040915_32895827_1": {"length": 18, "quality": 1.0, "section_id": 5977}, "so_31040915_32895827_0": {"length": 40, "quality": 1.0, "section_id": 5970}, "so_31040915_32895827_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5978}}, "n3337": {"so_31040915_32895827_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 5745}, "so_31040915_32895827_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5746}}, "n4659": {"so_31040915_32895827_1": {"length": 18, "quality": 1.0, "section_id": 7474}, "so_31040915_32895827_0": {"length": 40, "quality": 1.0, "section_id": 7469}, "so_31040915_32895827_2": {"length": 30, "quality": 0.967741935483871, "section_id": 7477}}}, "32895827": {"Id": "32895827", "PostTypeId": "2", "Body": "<p><strike>I believe that <strong>both</strong> compilers are wrong for (A) and gcc is wrong for (D). </strike><br>\nI believe that gcc is wrong for (A) and (D), while clang is correct for both.</br></p>\n<hr/>\n<p>The relevant sections of [expr.lambda.prim] are:</p>\n<blockquote>\n<p id=\"so_31040915_32895827_0\">An <em>init-capture</em> behaves as if it declares and explicitly captures a variable of the form \u201cauto <em>init-capture</em> ;\u201d\n  whose declarative region is the <em>lambda-expression</em>\u2019s <em>compound-statement</em>, except that:<br>\n  \u2014 if the capture is by copy (see below), the non-static data member declared for the capture and the\n  variable are treated as two different ways of referring to the same object, which has the lifetime of the\n  non-static data member, and no additional copy and destruction is performed,</br></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_31040915_32895827_1\">Every <em>id-expression</em> within the <em>compound-statement</em> of a <em>lambda-expression</em> <strong>that is an odr-use</strong> (3.2) of an\n  entity captured by copy is transformed into an access to the corresponding unnamed data member of the\n  closure type.</p>\n</blockquote>\n<p><code>decltype(j)</code> is not an odr-use of <code>j</code>, therefore no such transformation should be considered. Thus, in the case of <code>[=]{...}</code>, <code>decltype(j)</code> should yield <code>int&amp;</code>. However, in the case of an <em>init-capture</em>, the behavior is as if there was a variable of the form <code>auto j = j;</code>, and the variable <code>j</code> refers to the same unnamed non-static data member with no such transformation necessary. So in the case of <code>[j=j]{...}</code>, <code>decltype(j)</code> should yield the type of that variable - which is <code>int</code>. It is definitely not <code>const int</code>. That is a bug.</p>\n<p>The next relevant section:</p>\n<blockquote>\n<p id=\"so_31040915_32895827_2\">Every occurrence of <code>decltype((x))</code> where <code>x</code> is a possibly parenthesized <em>id-expression</em> that names an entity of automatic storage duration is treated as if <code>x</code> were transformed into an access to a corresponding data member of the closure type that would have been declared if <code>x</code> were an odr-use of the denoted entity.\n  <em>[ Example:</em></p>\n<pre><code>void f3() {\n    float x, &amp;r = x;\n    [=] {                       // x and r are not captured (appearance in a decltype operand is not an odr-use)\n        decltype(x) y1;         // y1 has type float\n        decltype((x)) y2 = y1;  // y2 has type float const&amp; because this lambda\n                                // is not mutable and x is an lvalue\n        decltype(r) r1 = y1;    // r1 has type float&amp; (transformation not considered)\n        decltype((r)) r2 = y2;  // r2 has type float const&amp;\n    }\n}\n</code></pre>\n<p id=\"so_31040915_32895827_3\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The example further illustrates that <code>decltype(j)</code> should be <code>int&amp;</code> in the implicit copy case and also demonstrates that <code>decltype((j))</code> is treated as if <code>x</code> were the corresponding data member that would have been declared: which is <code>int const&amp;</code> in both cases (as the lambda is not <code>mutable</code> and <code>j</code> is an lvalue). Your (C) and (D) cases exactly mirror the <code>r1</code>, <code>r2</code> declarations in the example. Which, while the examples are not normative, certainly suggests that gcc is in the wrong for having different behavior. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-10-01T20:55:18.977", "Score": "5", "CreationDate": "2015-10-01T19:57:06.903", "ParentId": "31040915", "CommentCount": "4", "LastEditDate": "2015-10-01T20:55:18.977", "OwnerUserId": "2069064"}, "31040915": {"ViewCount": "181", "Body": "<p>I've checked the <a href=\"https://gcc.gnu.org/bugzilla/buglist.cgi?quicksearch=decltype\" rel=\"noreferrer\">GCC buglist</a> and the <a href=\"https://llvm.org/bugs/buglist.cgi?quicksearch=decltype\" rel=\"noreferrer\">Clang buglist</a> and don't see anything relevant yet.</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/LYDzNhkbxN4A1Eaj\" rel=\"noreferrer\">This Wandbox link</a> shows some C++11/C++14 code exercising <code>decltype(x)</code> and <code>decltype((x))</code> for various kinds of <code>x</code> captured by lambdas. GCC and Clang give different answers for this code. Which of them, if either, is correct?</p>\n<p>Here's the offending snippet:</p>\n<pre><code>// inside main()\nint i = 42;\nint &amp;j = i;\n[j=j](){\n    static_assert(std::is_same&lt;decltype(j), GCC(const) int&gt;::value,\"\"); // A\n    static_assert(std::is_same&lt;decltype((j)), const int&amp;&gt;::value,\"\"); // B\n}();\n[=](){\n    static_assert(std::is_same&lt;decltype(j), int&amp;&gt;::value,\"\"); // C\n    static_assert(std::is_same&lt;decltype((j)), CLANG(const) int&amp;&gt;::value,\"\"); // D\n}();\n</code></pre>\n<p>where:</p>\n<pre><code>#ifdef __clang__\n #define CLANG(x) x\n #define GCC(x)\n#else\n #define GCC(x) x\n #define CLANG(x)\n#endif\n</code></pre>\n<p>I believe that in both cases, the thing that is actually captured<sup>(*)</sup> is a (non-const) <code>int</code> initialized to a copy of <code>j</code>'s value (that is to say, <code>i</code>'s value). Since the lambda isn't marked <code>mutable</code>, its <code>operator()</code> is going to be a <code>const</code> member function. With those prerequisites out of the way, let's proceed...</p>\n<p>On line <code>// A</code>, GCC tells me that the decltype of the explicitly init-captured <code>j</code> is <code>const int</code>, when I'm almost positive that it ought to be <code>int</code> (per Clang).</p>\n<p>On line <code>// B</code>, both compilers agree that <code>(j)</code> is an lvalue referring to a const int (since the lambda is not marked <code>mutable</code>); this makes perfect sense to me.</p>\n<p>On line <code>// C</code>, both compilers agree that <code>j</code> is a name referring to the <code>int&amp;</code> declared on line 2. This is a consequence of 5.1.2 [expr.prim.lambda]/19, or rather, a consequence of the-thing-that-happens-when-that-clause-is-<em>not</em>-being-invoked. Inside a <code>[=]</code> lambda, the <em>name</em> <code>j</code> refers to the <code>j</code> in the outer scope, but the <em>expression</em> <code>(j)</code> refers to the <code>(j)</code> that would exist if <code>j</code> were to have been captured. I don't <em>fully</em> understand how this works or why it's desirable, but there it is. I'm willing to stipulate that this is not a bug in either compiler.</p>\n<p>On line <code>// D</code>, Clang tells me that <code>(j)</code> is an lvalue referring to a const int, whereas GCC tells me that it's an lvalue referring to a <em>non-const</em> int. I'm pretty sure that Clang is right and GCC is wrong; <code>decltype((j))</code> should be the same whether <code>j</code> is captured implicitly or explicitly.</p>\n<p>So:</p>\n<ul>\n<li>Are my explanations correct (according to the Standard)?</li>\n<li>Does the correct answer change between C++11 and C++14 (and C++1z)?</li>\n<li>Are <code>// A</code> and <code>// D</code> both bugs in GCC?</li>\n<li>Have these bugs been filed already?</li>\n</ul>\n<hr>\n<p><sup>(*)</sup> \u2014 In fact nothing is technically <em>captured</em> by the second lambda, because it doesn't use <code>j</code> in any evaluated context. That's why lines <code>// A</code> and <code>// C</code> give different answers. But I don't know any nice terminology for the-thing-that-<em>is</em>-being-done-to-<code>j</code>, so I'm just saying \"captured\".</p>\n</hr>", "Title": "decltype() of captured variable in lambda: GCC bug and/or Clang bug?", "CreationDate": "2015-06-25T03:52:48.883", "LastActivityDate": "2017-10-05T13:23:17.720", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-05T13:23:17.720", "LastEditorUserId": "2069064", "Id": "31040915", "Score": "10", "OwnerUserId": "1424877", "Tags": "<c++><c++11><lambda><c++14><decltype>", "AnswerCount": "1"}});