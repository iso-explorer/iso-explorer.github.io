post_cb({"bq_ids": {"n4140": {"so_25670131_25682482_1": {"length": 9, "quality": 0.75, "section_id": 753}, "so_25670131_25682482_0": {"length": 11, "quality": 1.0, "section_id": 703}, "so_25670131_25682482_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 763}, "so_25670131_25682482_2": {"length": 22, "quality": 0.6875, "section_id": 763}}, "n3337": {"so_25670131_25682482_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 750}, "so_25670131_25682482_0": {"length": 11, "quality": 1.0, "section_id": 693}, "so_25670131_25682482_1": {"length": 9, "quality": 0.75, "section_id": 741}, "so_25670131_25682482_2": {"length": 22, "quality": 0.6875, "section_id": 750}}, "n4659": {"so_25670131_25682482_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 823}, "so_25670131_25682482_0": {"length": 11, "quality": 1.0, "section_id": 732}, "so_25670131_25682482_1": {"length": 9, "quality": 0.75, "section_id": 813}, "so_25670131_25682482_2": {"length": 22, "quality": 0.6875, "section_id": 823}}}, "25670131": {"ViewCount": "1634", "Body": "<p>I have found various resources enlisting the time complexity of various C++ STL containers. Where can I find the space complexities which are involved with using C++ STL containers?</p>\n<p>I do know that for most of the  containers the relationship is linear with respect to the number of elements contained. But what about containers which use a hash function? Is it possible to make any guarantees in that case?</p>\n", "Title": "Space complexity of C++ STL containers", "CreationDate": "2014-09-04T16:03:32.227", "LastActivityDate": "2014-09-05T09:17:45.533", "CommentCount": "6", "PostTypeId": "1", "Id": "25670131", "Score": "4", "OwnerUserId": "1429850", "Tags": "<c++><c++11><stl>", "AnswerCount": "1"}, "25682482": {"Id": "25682482", "PostTypeId": "2", "Body": "<p>There's two sources of complexity bounds for every STL container. First one is what the standard mandates. A good (and almost always correct) source for that is cppreference.com, e.g. <a href=\"http://en.cppreference.com/w/cpp/container\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container</a> if you don't have the standard itself. Second, things not specified in the standard are implementation defined. These implementations are mostly very efficient given their multi-purpose nature.</p>\n<p>To answer your question with a short answer: Yes, you can expect linear space. But the details are a bit more complicated.</p>\n<p>A quick look into the Standard (23.2.1 General container requirements) says:</p>\n<blockquote>\n<p id=\"so_25670131_25682482_0\">All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the contained objects. </p>\n</blockquote>\n<p>Section 23.2.5 (Unordered associative containers) states:</p>\n<blockquote>\n<p id=\"so_25670131_25682482_1\">The worst- case complexity for most operations is linear, but the average case is much faster. </p>\n</blockquote>\n<p>The standard goes on and defines certain aspects of unordered associative containers in more detail. When looking carefully at the operation complexities, we can infer something for the space. Digging a bit further (23.5.4.2 unordered_map constructors) reveals:</p>\n<blockquote>\n<p id=\"so_25670131_25682482_2\">Constructs an empty unordered_map using the specified hash function, key equality func- tion, and allocator, and using at least n buckets. If n is not provided, the number of buckets is implementation-defined. Then inserts elements from the range [f, l). max_load_factor() returns 1.0. Complexity: Average case linear, worst case quadratic</p>\n</blockquote>\n<p>Quadratic time happens for a pathologically bad hash function. The average case is what you should expect, namely linear time implies linear space. The worst case occurs when the hash map spills over and needs to be reconstructed (yes, handwaivingly speaking).</p>\n<p>For element access, we get a similar thing:</p>\n<blockquote>\n<p id=\"so_25670131_25682482_3\">Complexity: Average case O(1), worst case O(size()).</p>\n</blockquote>\n<p>Also, the standard says that the implementation has to use a bucketed data structure. Elements are hashed into buckets. These buckets will also need space and depending on the way you initialize the unordered_map, the number of buckets is implementation defined. So, efficient implementations will use O(n+N) space, where n is the number of elements and N the number of buckets.</p>\n<p>Hope that clarifies things a bit.</p>\n", "LastActivityDate": "2014-09-05T09:17:45.533", "CommentCount": "0", "CreationDate": "2014-09-05T09:17:45.533", "ParentId": "25670131", "Score": "1", "OwnerUserId": "1630944"}});