post_cb({"bq_ids": {"n4140": {"so_29172362_29172579_3": {"length": 88, "quality": 0.9072164948453608, "section_id": 3228}}, "n3337": {"so_29172362_29172579_3": {"length": 89, "quality": 0.9175257731958762, "section_id": 3101}}, "n4659": {"so_29172362_29172579_3": {"length": 84, "quality": 0.865979381443299, "section_id": 3985}}}, "29172579": {"Id": "29172579", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29172362_29172579_0\">What does <code>char[]</code> actually mean in C++?</p>\n</blockquote>\n<p>Let's find out:</p>\n<blockquote>\n<p id=\"so_29172362_29172579_1\"><code>[C++11: 8.3.4/1]:</code> In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<p id=\"so_29172362_29172579_2\">\u00a0\u00a0\u00a0<code>D1 [</code> <em>constant-expression</em><sub>opt</sub><code>]</code> <em>attribute-specifier-seq</em><sub>opt</sub></p>\n<p id=\"so_29172362_29172579_3\">and the type of the identifier in the declaration <code>T D1</code> is \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d, then the type of the identifier of <code>D</code> is an array type; if the type of the identifier of <code>D</code> contains the <code>auto</code> <em>type-specifier</em>, the program is ill-formed. <code>T</code> is called the array element type; this type shall not be a reference type, the (possibly cv-qualified) type <code>void</code>, a function type or an abstract class type. If the <em>constant-expression</em> (5.19) is present, it shall be an integral constant expression and its value shall be greater than zero. The constant expression specifies the <em>bound</em> of (number of elements in) the array. If the value of the constant expression is <code>N</code>, the array has <code>N</code> elements numbered <code>0</code> to <code>N-1</code>, and the type of the identifier of <code>D</code> is \u201c<em>derived-declarator-type-list</em> array of <code>N T</code>\u201d. An object of array type contains a contiguously allocated non-empty set of <code>N</code> subobjects of type <code>T</code>. Except as noted below, <strong>if the constant expression is omitted, the type of the identifier of <code>D</code> is \u201c<em>derived-declarator-type-list</em> array of unknown bound of <code>T</code>\u201d, an incomplete object type</strong>. The type \u201c<em>derived-declarator-type-list</em> array of <code>N T</code>\u201d is a different type from the type \u201c<em>derived-declarator-type-list</em> array of unknown bound of <code>T</code>\u201d, see 3.9. <em>[..]</em></p>\n</blockquote>\n<p>As you point out, these \"arrays of unknown bounds\" are being used through a <code>std::unique_ptr</code> specialisation.</p>\n<p>Regarding example 1, although it's surprisingly unclear in <code>[C++11: 8.5.5]</code>, <code>char[]</code> with initialiser is a special case that is not covered by the above text: <code>a</code> is in fact a <code>const char[16]</code>. So, yes, \"the compiler is basically handling the length for us behind the scenes\".</p>\n<hr>\n<blockquote>\n<p id=\"so_29172362_29172579_4\">Example 3 defines a function that takes an array of size 10 as a parameter. (Behind the scenes the compiler treats the array like a pointer)</p>\n</blockquote>\n<p>Almost. In fact there's nothing \"behind-the-scenes\" about it: the conversion is in the brochure. It's front and centre, explicit and standardised.</p>\n<p>So:</p>\n<blockquote>\n<p id=\"so_29172362_29172579_5\">-- e.g. it is an error to have:</p>\n<pre><code>void foo(char test[5]) {}\nvoid foo(char * test) {}\n</code></pre>\n<p id=\"so_29172362_29172579_6\">because the function signatures are ambiguous to the compiler.</p>\n</blockquote>\n<p>In fact it is an error not through \"ambiguity\", but because you literally defined the same function twice.</p>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2015-03-20T17:41:08.163", "Score": "4", "CreationDate": "2015-03-20T17:34:56.337", "ParentId": "29172362", "CommentCount": "5", "OwnerUserId": "560648", "LastEditDate": "2015-03-20T17:41:08.163"}, "29172362": {"ViewCount": "299", "Body": "<p>Yesterday, I was surprised to come across some code that seemed to treat <code>char[]</code> as being a type:</p>\n<pre><code>typedef std::unique_ptr&lt;char[]&gt; CharPtr;\n</code></pre>\n<p>Previously, I would have written something like:</p>\n<pre><code>typedef std::unique_ptr&lt;char*, CharDeleter&gt; CharPtr;\n// Custom definition of CharDeleter omitted\n</code></pre>\n<p>After some research, I discovered that the <code>char[]</code> syntax works because <code>std::unique_ptr</code> provides a template specialization to handle arrays (e.g. it will automatically invoke <code>delete[]</code> for the array without requiring a custom deleter)</p>\n<p>But what does <code>char[]</code> actually mean in C++?</p>\n<p>I've seen syntax like:</p>\n<pre><code>const char a[] = \"Constant string\"; // Example 1\n\nchar *p = new char[5]; // Example 2\n\nbool foo(char param[10]); // Example 3\n</code></pre>\n<p>This is how I interpret these examples:</p>\n<p>Example 1 allocates a static array (on the stack) and the empty indices are valid because the true size of the string is known at compile time (e.g. the compiler is basically handling the length for us behind the scenes)</p>\n<p>Example 2 dynamically allocates 5 contiguous characters with the first character being stored at the address stored in p.</p>\n<p>Example 3 defines a function that takes an array of size 10 as a parameter. (Behind the scenes the compiler treats the array like a pointer) -- e.g. it is an error to have:</p>\n<pre><code>void foo(char test[5]) {}\nvoid foo(char * test) {}\n</code></pre>\n<p>because the function signatures are ambiguous to the compiler.</p>\n<p>I feel like i understand the array/pointer differences and similarities. My confusion likely stems from my lack of experience with building/reading C++ templates.</p>\n<p>I know that a template specialization basically allows a customized template (based on a particular template) to be used depending on the template type parameters.  Is <code>char[]</code> simply a syntax that is available for template specialization (invoking a particular specialization)?</p>\n<p>Also, what is the proper name for array \"types\" like <code>char[]</code>?</p>\n", "AcceptedAnswerId": "29172579", "Title": "Is \"char[]\" a proper type?", "CreationDate": "2015-03-20T17:21:24.260", "Id": "29172362", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-03-20T17:31:39.923", "LastEditorUserId": "3204551", "LastActivityDate": "2015-03-20T17:47:16.343", "Score": "7", "OwnerUserId": "2905627", "Tags": "<c++><arrays><templates><c++11>", "AnswerCount": "3"}, "29172509": {"Id": "29172509", "PostTypeId": "2", "Body": "<p>Yes, <code>char[]</code> denotes the compound type \"array of unknown bound of <code>char</code>\". It is an incomplete type, but one that can be completed later:</p>\n<pre><code>extern char a[];    // \"a\" has incomplete type at point of declaration\n\nchar a[10];         // Now \"a\" has complete type.\n</code></pre>\n", "LastActivityDate": "2015-03-20T17:30:01.673", "CommentCount": "0", "CreationDate": "2015-03-20T17:30:01.673", "ParentId": "29172362", "Score": "2", "OwnerUserId": "596781"}, "29172756": {"Id": "29172756", "PostTypeId": "2", "Body": "<p><code>char[]</code> is a type, but a type that you cannot have an instance of.  It is an incomplete object type, somewhat like <code>struct foo;</code>.</p>\n<p>This means that templates can consume <code>char[]</code> as a type if they choose to.  They cannot create a variable of type <code>char[]</code>, but they can interact with the type.</p>\n<p>Now, there are a bunch of \"magic\" behavior attached to arrays inherited from C.  As a function argument parameter, <code>char[]</code> becomes <code>char*</code> (as does <code>char[33]</code>!)</p>\n<p>As a local variable, <code>char x[]=\"foo\";</code> or <code>char y[]={'a','b','c'};</code> becomes an array of fixed size.  Here, <code>char[]</code> means \"auto-size the array\".</p>\n<p>In a sense, these are both quirks in parameter types and variable declarations rather than quirks of the type.  The type you are declaring doesn't look all that much like the type you are declaring.</p>\n<p>There is also a bunch of strangeness involving type decay -- a variable of type <code>char[3]</code> like <code>char x[3];</code> will decay to <code>char*</code> at the drop of a hat.  This, much like auto-sizing arrays, is basically a legacy from C.</p>\n<p>All of this is explicitly described in the standard, but because it differs significantly from most \"regular\" types it acts like magic.</p>\n<p>After all, any sufficiently obtuse feature of the standard is indistinguishable from magic.</p>\n", "LastActivityDate": "2015-03-20T17:47:16.343", "CommentCount": "0", "CreationDate": "2015-03-20T17:47:16.343", "ParentId": "29172362", "Score": "3", "OwnerUserId": "1774667"}});