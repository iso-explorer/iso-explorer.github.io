post_cb({"2603360": {"Id": "2603360", "PostTypeId": "2", "Body": "<p>The reason it is undefined is that the compiler is free to calculate function parameters in any order.  Consider if you where calling a function (because you are, but it's easier to envision when it's in function syntax):</p>\n<pre><code>\n  cout.output(c++).output(c);\n</code></pre>\n<p>The compiler may hit the parameters in reverse order, forward order, or whatever.  It may call the first output before calculating the parameter to the second output or it may do both and then call.</p>\n", "LastActivityDate": "2010-04-08T20:48:46.400", "Score": "1", "CreationDate": "2010-04-08T20:48:46.400", "ParentId": "2603312", "CommentCount": "0", "OwnerUserId": "301883"}, "20411348": {"Id": "20411348", "PostTypeId": "2", "Body": "<p>As I see it,\n    f(c++);\nis equivalent to:\n    f(c); c += 1;</p>\n<p>And\n    f(c++,c++);\nis equivalent to:\n    f(c,c); c += 1; c += 1;</p>\n<p>But it may be the case that\n    f(c++,c++);\nbecomes\n    f(c,c+1); c+= 2;</p>\n<p>An experiment with gcc and clang, first in C</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid f(int a, int b) {\n    printf(\"%d %d\\n\",a,b);\n}\n\nint main(int argc, char **argv) {\n    int c = 0;\n    f(c++,c++);\n\n    return 0;\n}\n</code></pre>\n<p>and in C++</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(int argc, char **argv) {\n    int c = 0;\n    std::cout &lt;&lt; c++ &lt;&lt; \" \" &lt;&lt; c++ &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Is interesting, as gcc and g++ compiled results in\n    1 0\nwhereas clang compiled results in\n    0 1</p>\n", "LastActivityDate": "2013-12-05T21:40:47.580", "Score": "0", "CreationDate": "2013-12-05T21:40:47.580", "ParentId": "2603312", "CommentCount": "0", "OwnerUserId": "2138913"}, "2603355": {"Id": "2603355", "PostTypeId": "2", "Body": "<p>The behavior is defined but unspecified. The relative order of evaluating the two uses of 'c' in the expression isn't specified. However, if you convert it to functional notation, it looks like this:</p>\n<pre><code>cout.operator&lt;&lt;(c++).operator&lt;&lt;(c);\n</code></pre>\n<p>There's a sequence point between evaluating the arguments to a function, and executing the body of the function, and function bodies aren't interleaved, so the result is only unspecified, not undefined behavior.</p>\n<p>If you didn't have an overloaded operator:</p>\n<pre><code>int c=0;\nint a = c++ &lt;&lt; c;\n</code></pre>\n<p>Then the behavior would be undefined, because both modifying and using the value of <code>c</code> without an intervening sequence point.</p>\n<p>Edit: The sequence <code>litb</code> brings up is simply wrong. The standard specifies (\u00a71.9/17): \"When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all function arguments (if any) which takes place before execution of any expressions or statements in the function body.\"</p>\n<p>This clearly written with the idea that arguments are evaluated, then (immediately afterward) the body of the function is executed. The sequence he suggests, in which arguments to one function are evaluated, then arguments to another, then execution of both function bodies doesn't seem to have been intended, but also isn't prohibited. That, however, changes nothing -- the requirement is still that: \"...there is a sequence point after the evaluation of all function arguments (if any)...\"</p>\n<p>The subsequent language about execution of the body does NOT remove the requirement for a sequence point after evaluating all function arguments. <em>All</em> other evaluation, whether of the function body or other function arguments follows that sequence point. I can be as pedantic and perverse as anybody about mis-reading what's clearly intended (but not <em>quite</em> stated) -- but I can't imagine how \"there is a sequence point after the evaluation of all function arguments\" can be read as meaning \"there is NOT a sequence point after the evaluation of all function arguments.\"</p>\n<p>Neil's point is, of course, correct: the syntax I've used above is for member functions. For a non-member overload, the syntax would be more like:</p>\n<pre><code>operator&lt;&lt;(operator&lt;&lt;(cout,c++), c);\n</code></pre>\n<p>This doesn't remove the requirement for sequence points either though.</p>\n<p>As far as it being unspecified: it's pretty simple really: there's a sequence point after evaluating all function arguments, so all the arguments for one function call must be fully evaluated (including all side effects), then arguments for the other function call can be evaluated (taking into account any side effects from the other) -- BUT there's no requirement about WHICH function call's arguments must be evaluated first or second, so it could be <code>c</code>, then <code>c++</code>, or it could be <code>c++</code>, then <code>c</code> -- but it has to be one or the other, not an interleaving.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2010-04-08T21:46:01.160", "Score": "1", "CreationDate": "2010-04-08T20:48:11.517", "ParentId": "2603312", "CommentCount": "33", "LastEditDate": "2010-04-08T21:46:01.160", "OwnerUserId": "179910"}, "2603367": {"Id": "2603367", "PostTypeId": "2", "Body": "<p>It is undefined behavior if you modify a value and then read it (or try to modify it again) without an intervening sequence point. The concept of a sequence point in C++ is a bit technical (you can read a little about it <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">here</a>), but the bottom line is that stream insertion (<code>&lt;&lt;</code>) is <em>not</em> a sequence point. </p>\n<p>The reason why this is undefined behavior is because, in the absence of a sequence point, the compiler is allowed to re-order operations in any way it sees fit. That is, it is permitted to retrieve the value of <code>c</code> (and hold onto it for the second insertion) and then afterwords execute <code>c++</code> to get the value for the first insertion. So you can't be sure whether the increment will occur before or after the value of <code>c</code> for the second insertion is determined.</p>\n", "LastActivityDate": "2010-04-08T20:50:03.663", "Score": "4", "CreationDate": "2010-04-08T20:50:03.663", "ParentId": "2603312", "CommentCount": "1", "OwnerUserId": "39375"}, "2603312": {"ViewCount": "933", "Body": "<p>I think it should be 01 but someone says its \"undefined\", any reason for that?</p>\n", "AcceptedAnswerId": "2603349", "Title": "The result of int c=0; cout<<c++<<c;", "CreationDate": "2010-04-08T20:42:46.093", "Id": "2603312", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-12-05T21:40:47.580", "Score": "5", "OwnerUserId": "160333", "Tags": "<c++><ostream>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_2603312_2603349_1": {"length": 8, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_2603312_2603349_1": {"length": 8, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_2603312_2603349_1": {"length": 8, "quality": 1.0, "section_id": 7272}}}, "2603349": {"Id": "2603349", "PostTypeId": "2", "Body": "<p><code>c++</code> is both an increment and an assignment.  When the assignment occurs (before or after other code on that line) is left up to the discretion of the compiler.  It can occur after the <code>cout &lt;&lt;</code> or before.</p>\n<p>This can be found in the C99 standard\n <a href=\"http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf\" rel=\"noreferrer\">http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf</a></p>\n<p>You can find it on page 28 in the pdf or section 5.1.2.3</p>\n<blockquote>\n<p id=\"so_2603312_2603349_0\">the actual increment of p can occur at any time between the previous sequence point and the next sequence point</p>\n</blockquote>\n<p>Since someone asked for the C++ standard (as this is a C++ question) it can be found in section 1.9.15 page 10 (or 24 in pdf format)</p>\n<blockquote>\n<p id=\"so_2603312_2603349_1\">evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced</p>\n</blockquote>\n<p>It also includes the following code block: </p>\n<pre><code>i = v[i++]; // the behavior is undefined\ni = 7, i++, i++; // i becomes 9\ni = i++ + 1; // the behavior is undefined\n</code></pre>\n<p>I feel that the C99 standard's explanation is clearer, but it is true in both languages.</p>\n", "LastEditorUserId": "180604", "LastActivityDate": "2010-04-08T21:38:05.800", "Score": "8", "CreationDate": "2010-04-08T20:47:06.850", "ParentId": "2603312", "CommentCount": "3", "LastEditDate": "2010-04-08T21:38:05.800", "OwnerUserId": "180604"}});