post_cb({"3281119": {"ParentId": "3280768", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Keeping in mind C++0x isn't quite standard yet, this is subject to change. From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">FCD</a> (PDF link), move constructors and move assignment operators can indeed be explicitly defaulted, and even implicitly defaulted.*****</p>\n<hr>\n<p>I'm just going to quote (heavily abridged) a bunch of stuff that might be useful to glance at:</p>\n<p>On explicitly-defaulted functions, \u00a78.4.2/1-2:</p>\n<blockquote>\n<p id=\"so_3280768_3281119_0\">A function that is explicitly defaulted shall</p>\n<ul>\n<li>be a special member function,  </li>\n<li>have the same declared function type as if it had been implicitly declared,  </li>\n<li>not have default arguments, and  </li>\n<li>not have an exception-specification.  </li>\n</ul>\n<p id=\"so_3280768_3281119_1\">If it is explicitly defaulted on its first declaration,</p>\n<ul>\n<li>it shall be public,  </li>\n<li>it shall not be explicit,  </li>\n<li>it shall not be virtual,  </li>\n<li>it is implicitly considered to have the same exception-specification as if it had been implicitly declared (15.4), and  </li>\n<li>in the case of a copy constructor, move constructor, copy assignment operator, or move assignment operator, it shall have the same parameter type as if it had been implicitly declared.</li>\n</ul>\n</blockquote>\n<p>On special member functions, \u00a712/1:</p>\n<blockquote>\n<p id=\"so_3280768_3281119_2\">The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor and move assignment operator (12.8), and destructor (12.4) are special member functions. [ Note: The implementation will implicitly declare these member functions for some class types when the program does not explicitly declare them. The implementation will implicitly define them if they are used. See 12.1, 12.4\n  and 12.8. \u2014end note ]</p>\n</blockquote>\n<p>About implicitly declared functions, \u00a712.8/8-11:</p>\n<blockquote>\n<p id=\"so_3280768_3281119_3\">If the class definition does not explicitly declare a copy constructor and there is no user-declared move constructor, a copy constructor is implicitly declared as defaulted (8.4).  </p>\n<p id=\"so_3280768_3281119_4\">The implicitly-declared copy constructor for a class X will have the form <code>X::X(const X&amp;)</code> if  </p>\n<ul>\n<li>each direct or virtual base class B of X has a copy constructor whose first parameter is of type <code>const B&amp;</code> or <code>const volatile B&amp;</code>, and  </li>\n<li>for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy constructor whose first parameter is of type <code>const M&amp;</code> or <code>const volatile M&amp;</code>.  </li>\n</ul>\n<p id=\"so_3280768_3281119_5\">Otherwise, the implicitly-declared copy constructor will have the form <code>X::X(X&amp;)</code>.</p>\n<p id=\"so_3280768_3281119_6\">If the class definition does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>\n<ul>\n<li>X does not have a user-declared copy constructor and  </li>\n<li>the move constructor would not be implicitly defined as deleted.  </li>\n</ul>\n<p id=\"so_3280768_3281119_7\">[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. \u2014end note ]</p>\n<p id=\"so_3280768_3281119_8\">The implicitly-declared move constructor for class X will have the form <code>X::X(X&amp;&amp;)</code>.</p>\n</blockquote>\n<p>On implicitly deleted default functions, \u00a712.8/12:</p>\n<blockquote>\n<p id=\"so_3280768_3281119_9\">An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy-/move constructor for a class X is defined as deleted (8.4.3) if X has:</p>\n<ul>\n<li>a variant member with a non-trivial corresponding constructor and X is a union-like class,  </li>\n<li>a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor, or  </li>\n<li>a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor, or  </li>\n<li>for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.</li>\n</ul>\n</blockquote>\n<p>\u00a712.8/13-18 defines how the functions should work when they are implicitly generated.</p>\n<p>\u00a712.8/19 then does the same thing as \u00a712.8/8 did, except with the copy-assignment and move-assignment operators. They are similar enough not to warrant quoting here.</p>\n<p>For a more complete picture, you'll want to read those sections in their entirety, but that's the general idea. I'm glad we get implicit move semantics.</p>\n<hr>\n<p>*But like defaulted copy-functions, they might not always have the correct behavior! The Big Three should become The Big Five. (For example, The Big Three are implemented whenever we need to deep-copy something. We also need to make sure we do a \"deep-move\", where the source's data is nulled/reset. This is <em>not</em> done implicitly.)</p>\n</hr></hr>", "OwnerUserId": "87234", "LastEditorUserId": "87234", "LastEditDate": "2010-07-19T20:38:38.063", "Id": "3281119", "Score": "3", "CreationDate": "2010-07-19T12:48:24.757", "LastActivityDate": "2010-07-19T20:38:38.063"}, "3280768": {"CommentCount": "1", "ViewCount": "549", "PostTypeId": "1", "LastEditorUserId": "3848", "CreationDate": "2010-07-19T11:52:28.177", "LastActivityDate": "2010-07-20T15:06:52.313", "Title": "Special member functions in C++0x", "AcceptedAnswerId": "3281119", "LastEditDate": "2010-07-20T15:06:52.313", "Id": "3280768", "Score": "3", "Body": "<p>The Wikipedia article about <a href=\"http://en.wikipedia.org/wiki/Special_member_functions\" rel=\"nofollow noreferrer\">special member functions</a> doesn't contain any reference to move constructors and move assignment operators.</p>\n<p>I would like to update the entry but I'm not sure what the 0x standard says.</p>\n<p>What are the rules regarding these two functions? Are they automatically generated by the compiler and if so when?</p>\n<hr>\n<p><strong>Edit:</strong> I've updated the Wikipedia page, if anyone feels like it please help the community by editing it into shape (if needed).</p>\n</hr>", "Tags": "<c++><constructor><c++11><assignment-operator><move-semantics>", "OwnerUserId": "3848", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_3280768_3281119_8": {"section_id": 459, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_7": {"section_id": 458, "quality": 0.8636363636363636, "length": 19}, "so_3280768_3281119_4": {"section_id": 457, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_3": {"section_id": 469, "quality": 0.8125, "length": 13}, "so_3280768_3281119_5": {"section_id": 457, "quality": 0.875, "length": 7}, "so_3280768_3281119_9": {"section_id": 460, "quality": 0.8666666666666667, "length": 13}, "so_3280768_3281119_6": {"section_id": 458, "quality": 0.9166666666666666, "length": 11}, "so_3280768_3281119_2": {"section_id": 361, "quality": 0.72, "length": 36}, "so_3280768_3281119_1": {"section_id": 370, "quality": 1.0, "length": 5}}, "n3337": {"so_3280768_3281119_8": {"section_id": 450, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_7": {"section_id": 449, "quality": 0.8636363636363636, "length": 19}, "so_3280768_3281119_4": {"section_id": 448, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_3": {"section_id": 447, "quality": 0.75, "length": 12}, "so_3280768_3281119_5": {"section_id": 448, "quality": 0.875, "length": 7}, "so_3280768_3281119_9": {"section_id": 451, "quality": 0.8666666666666667, "length": 13}, "so_3280768_3281119_6": {"section_id": 449, "quality": 0.9166666666666666, "length": 11}, "so_3280768_3281119_2": {"section_id": 351, "quality": 0.72, "length": 36}, "so_3280768_3281119_1": {"section_id": 360, "quality": 1.0, "length": 5}}, "n4659": {"so_3280768_3281119_9": {"section_id": 483, "quality": 0.8666666666666667, "length": 13}, "so_3280768_3281119_7": {"section_id": 481, "quality": 0.8636363636363636, "length": 19}, "so_3280768_3281119_3": {"section_id": 492, "quality": 0.8125, "length": 13}, "so_3280768_3281119_8": {"section_id": 482, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_5": {"section_id": 480, "quality": 0.875, "length": 7}, "so_3280768_3281119_4": {"section_id": 480, "quality": 0.7777777777777778, "length": 7}, "so_3280768_3281119_6": {"section_id": 481, "quality": 0.9166666666666666, "length": 11}, "so_3280768_3281119_2": {"section_id": 373, "quality": 0.72, "length": 36}, "so_3280768_3281119_1": {"section_id": 384, "quality": 1.0, "length": 5}}}});