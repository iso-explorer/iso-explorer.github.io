post_cb({"41491416": {"ParentId": "41491221", "LastEditDate": "2017-01-05T17:53:49.700", "CommentCount": "10", "CreationDate": "2017-01-05T17:42:34.660", "OwnerUserId": "225074", "LastEditorUserId": "225074", "PostTypeId": "2", "Id": "41491416", "Score": "8", "Body": "<p>Let's put the issue of whether <code>inline</code> is forced or not, aside for now (there are lot's of discussions on the topic).</p>\n<p>Inlining a function is equivalent of pasting the contents of the function at the location of the function call (invocation).</p>\n<p>So given the following:</p>\n<pre><code>void Hello()\n{\n  std::cout &lt;&lt; \"Hello\\n\";\n}\n\nint main()\n{\n  Hello();\n  return 0;\n}\n</code></pre>\n<p>When the <code>Hello</code> function is inlined, you will get the equivalent of:</p>\n<pre><code>int main()\n{\n  // Hello();\n  std::cout &lt;&lt; \"Hello\\n\"; // This is the content of function Hello().\n  return 0;\n}\n</code></pre>\n<p>The compiler is allowed to inline functions that are not marked as being inlined.  This feature is often triggered by an optimization setting.  </p>\n<p><strong>Edit 1: Common reason for inlining</strong><br>\nA common reason for inlining a function is when the content is smaller or equal than the overhead to call the function.  </br></p>\n<p>There is a protocol associated with call a function, such as moving parameters to the stack or registers.  The protocol exists regardless of the size of the function.  So, inlining will remove the calling protocol (thus reducing program code size and increasing performance).  </p>\n<p>Another reason to inline is to reduce the quantity of function calls.  In some processors, a branch instruction (function call), causes the instruction cache (or pipeline) to be reloaded.  This takes time.  Inlining reduces the function calls and improves execution time.  </p>\n<p><strong>Edit 2:  Code Bloat</strong><br>\nOne reason to create functions is to reduce code size.  Inlining of large functions may result in <em>code bloat</em> or the increasing of the program's size.  </br></p>\n<p>Code bloat and function inlining are under the <em>Time versus Space</em> trade off.  Inlining of large functions may speed up execution, but you are trading space for it.  Place common code into functions may decrease the size of your program, but take more time to execute.  </p>\n", "LastActivityDate": "2017-01-05T17:53:49.700"}, "41491469": {"ParentId": "41491221", "LastEditDate": "2017-01-05T21:21:03.940", "CommentCount": "11", "CreationDate": "2017-01-05T17:45:29.697", "OwnerUserId": "596781", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "41491469", "Score": "42", "Body": "<p>Maybe a few examples would help.</p>\n<h3>1. Traditional compiled library</h3>\n<p><strong>foo.h:</strong></p>\n<pre><code>extern int x;\nint * f();\n</code></pre>\n<p><strong>foo.cpp:</strong></p>\n<pre><code>#include \"foo.h\"\n\nint x = 25;\n\nint * f() { return &amp;x; }\n</code></pre>\n<p>Users include <code>foo.h</code> and need to link in the translation unit containing <code>foo.cpp</code> in order to call <code>f</code>. Every such call returns the same address.</p>\n<h3>2. Separate, TU-local variables</h3>\n<p><strong>foo.h:</strong></p>\n<pre><code>static int x = 35;\nstatic int * f() { return &amp;x; }\n</code></pre>\n<p>Every TU that includes <code>foo.h</code> gets a <em>separate</em> and <em>distinct</em> function <code>f</code>, calling which results in a unique value per TU.</p>\n<h3>3. Baby's first ODR violation</h3>\n<p><strong>foo.h:</strong></p>\n<pre><code>static int x = 45;\ninline int * f() { return &amp;x; }\n</code></pre>\n<p>This appears to be a header-only library, but if <code>foo.h</code> is included in more than one TU, this constitutes an ODR violation, since <code>f</code> would be defined more than once but not all of its definitions would be identical.</p>\n<p>This is a common mistake. Workarounds include things like making <code>x</code> a template or replacing <code>x</code> with a function like <code>int &amp; x() { static int impl = 45; return impl; }</code>. Note that if you omit the <code>static</code>, you would most likely get a linker error because of multiple definitions of <code>x</code>; <code>static</code> seemingly \"makes the code compile\".</p>\n<h3>4. C++17 to the rescue: Proper header-only libraries</h3>\n<p><strong>foo.h:</strong></p>\n<pre><code>inline int x = 55;\ninline int * f() { return &amp;x; }\n</code></pre>\n<p>This version is functionally equivalent to (1), but does not require a dedicated translation unit to contain the definitions of <code>x</code> and <code>f</code>.</p>\n", "LastActivityDate": "2017-01-05T21:21:03.940"}, "41491221": {"CommentCount": "3", "ViewCount": "2016", "PostTypeId": "1", "LastEditorUserId": "4792660", "LastActivityDate": "2017-01-06T13:48:14.933", "Body": "<p>In <a href=\"http://en.cppreference.com/w/cpp/language/inline\" rel=\"noreferrer\">this link</a>, what is an inline function and what is the inline keyword is explained. I'm reading through it because I realized I've never understood the meaning of these two concepts and how they should be used in practice. I'm quoting and commenting from the link I provided</p>\n<blockquote>\n<p id=\"so_41491221_41491221_0\">An inline function or inline variable (since C++17) is a function or\n  variable (since C++17) with the following properties: </p>\n<p id=\"so_41491221_41491221_1\">1) There may be\n  more than one definition of an inline function or variable (since\n  C++17) in the program as long as each definition appears in a\n  different translation unit. For example, an inline function or an\n  inline variable (since C++17) may be defined in a header file that is\n  include'd in multiple source files.</p>\n</blockquote>\n<p>Here I already have understanding problems, declaration is the specification of new identifiers like</p>\n<pre><code>void func(void);\n</code></pre>\n<p>while a definition is the actual implementation, including the body</p>\n<pre><code>void func(void) {\n  //some code...\n}\n</code></pre>\n<p>The point 1) means that I can give different implementation as long as they're in different translation units (i.e. one implementation per header e per source files), but I'm puzzled in the case I have a source file <code>source.cc</code> with a declaration for <code>func</code> and an header file  with another declaration of <code>func</code> the translation unit is the pair <code>source.cc+header.h</code> and in such a case having declared two times <code>func</code> doesn't make any sense, is that right?</p>\n<blockquote>\n<p id=\"so_41491221_41491221_2\">2) The definition of an inline function or variable (since C++17) must\n  be present in the translation unit where it is accessed (not\n  necessarily before the point of access).</p>\n</blockquote>\n<p>This is the usual case where I separate definition from declaration, the first in an header file, the second one is in the source file, if I need to use the function I have to include only the header right? The access point would be provided by the source during the linking phase, correct?</p>\n<blockquote>\n<p id=\"so_41491221_41491221_3\">3) An inline function or variable (since C++17) with external linkage\n  (e.g. not declared static) has the following additional properties: 1)\n  It must be declared inline in every translation unit. 2) It has the\n  same address in every translation unit.</p>\n</blockquote>\n<p>Could you provide a simple example of what this means? I can't picture a practical case of such a case. The case 3) states that the keyword <code>inline</code> is mandatory unless the function to be declared is static.</p>\n<p>Is everything I said so far correct?</p>\n<p>In practice a function should be inline when such a function is very small, but not always the compiler would inline the function declared as inline, for example if it has loops inside or recursion (Effective C++ states so). In general then it's compiler dependent, I the wonder now...</p>\n<p>Say I have two functions the first one is self-contained (it doesn't internally call any-other function), the second one call's the first one (you can assume they're both 10 lines for sake of argument). Should both of them declared inline? should they be declared in an header file? or should I separate definition in an header file and the implementation in an source file? What would be better?</p>\n<p><strong>Edit 1</strong>:</p>\n<p>Following one of the answer is better if I work by examples, with related assembly code analysis.</p>\n<p>I removed the previous code because it was meaningless (the <code>-O3</code> flag optimization wasn't set).</p>\n<p>I start again... I have 5 files <code>header.h</code>,<code>src.cc</code>, <code>src1.cc</code>, <code>src2.cc</code> and <code>main.cc</code>. For each translation unit the related assembly code is posted.</p>\n<p>I've manipulated such files in three different ways and later observed the assembly code generated, this helped me to understand how the inline keyword works.</p>\n<p>Example 1:</p>\n<p>header.h</p>\n<pre><code>#ifndef HEADER_H_\n#define HEADER_H_\n\nint func(int a, int b);\nint test_1();\nint test_2();\n\n#endif /* HEADER_H_ */\n</code></pre>\n<p>src.cc</p>\n<pre><code>#include \"header.h\"\n\nint func(int a, int b)\n{\n   return a + b;\n}\n</code></pre>\n<p>src1.cc</p>\n<pre><code>#include \"header.h\"\n\nint test_1()\n{\n   int a, b, c;\n   a = 3;\n   b = 7;\n   c = func(a, b);\n   return c;\n}\n</code></pre>\n<p>src2.cc</p>\n<pre><code>#include \"header.h\"\n\nint test_2()\n{\n   int a, b, c;\n   a = 7;\n   b = 8;\n   c = func(a, b);\n   return c;\n}\n</code></pre>\n<p>main.cc</p>\n<pre><code>int main(int argc, char** argv)\n{\n   test_1();\n   test_2();\n   test_1();\n   test_2();\n}\n</code></pre>\n<p>Assembly 1:</p>\n<p>src.s</p>\n<pre><code>GAS LISTING /tmp/cc0j97WY.s             page 1\n\n\n   1                    .file   \"src.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl _Z4funcii\n   6                    .type   _Z4funcii, @function\n   7                _Z4funcii:\n   8                .LFB2:\n   9 0000 8D043E        leal    (%rsi,%rdi), %eax\n  10 0003 C3            ret\n  11                .LFE2:\n  12                    .size   _Z4funcii, .-_Z4funcii\n  13                .globl __gxx_personality_v0\n  14                    .section    .eh_frame,\"a\",@progbits\n  15                .Lframe1:\n  16 0000 1C000000      .long   .LECIE1-.LSCIE1\n  17                .LSCIE1:\n  18 0004 00000000      .long   0x0\n  19 0008 01            .byte   0x1\n  20 0009 7A505200      .string \"zPR\"\n  21 000d 01            .uleb128 0x1\n  22 000e 78            .sleb128 -8\n  23 000f 10            .byte   0x10\n  24 0010 06            .uleb128 0x6\n  25 0011 03            .byte   0x3\n  26 0012 00000000      .long   __gxx_personality_v0\n  27 0016 03            .byte   0x3\n  28 0017 0C            .byte   0xc\n  29 0018 07            .uleb128 0x7\n  30 0019 08            .uleb128 0x8\n  31 001a 90            .byte   0x90\n  32 001b 01            .uleb128 0x1\n  33 001c 00000000      .align 8\n  34                .LECIE1:\n  35                .LSFDE1:\n  36 0020 14000000      .long   .LEFDE1-.LASFDE1\n  37                .LASFDE1:\n  38 0024 24000000      .long   .LASFDE1-.Lframe1\n  39 0028 00000000      .long   .LFB2\n  40 002c 04000000      .long   .LFE2-.LFB2\n  41 0030 00            .uleb128 0x0\n  42 0031 00000000      .align 8\n  42      000000\n  43                .LEFDE1:\n  44                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  45                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src1.s</p>\n<pre><code>GAS LISTING /tmp/cchSilt1.s             page 1\n\n\n   1                    .file   \"src1.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl _Z6test_1v\n   6                    .type   _Z6test_1v, @function\n   7                _Z6test_1v:\n   8                .LFB2:\n   9 0000 BE070000      movl    $7, %esi\n   9      00\n  10 0005 BF030000      movl    $3, %edi\n  10      00\n  11 000a E9000000      jmp _Z4funcii\n  11      00\n  12                .LFE2:\n  13                    .size   _Z6test_1v, .-_Z6test_1v\n  14                .globl __gxx_personality_v0\n  15                    .section    .eh_frame,\"a\",@progbits\n  16                .Lframe1:\n  17 0000 1C000000      .long   .LECIE1-.LSCIE1\n  18                .LSCIE1:\n  19 0004 00000000      .long   0x0\n  20 0008 01            .byte   0x1\n  21 0009 7A505200      .string \"zPR\"\n  22 000d 01            .uleb128 0x1\n  23 000e 78            .sleb128 -8\n  24 000f 10            .byte   0x10\n  25 0010 06            .uleb128 0x6\n  26 0011 03            .byte   0x3\n  27 0012 00000000      .long   __gxx_personality_v0\n  28 0016 03            .byte   0x3\n  29 0017 0C            .byte   0xc\n  30 0018 07            .uleb128 0x7\n  31 0019 08            .uleb128 0x8\n  32 001a 90            .byte   0x90\n  33 001b 01            .uleb128 0x1\n  34 001c 00000000      .align 8\n  35                .LECIE1:\n  36                .LSFDE1:\n  37 0020 14000000      .long   .LEFDE1-.LASFDE1\n  38                .LASFDE1:\n  39 0024 24000000      .long   .LASFDE1-.Lframe1\n  40 0028 00000000      .long   .LFB2\n  41 002c 0F000000      .long   .LFE2-.LFB2\n  42 0030 00            .uleb128 0x0\n  43 0031 00000000      .align 8\n  43      000000\n  44                .LEFDE1:\n  45                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  46                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src2.s</p>\n<pre><code>GAS LISTING /tmp/cc2JMtt3.s             page 1\n\n\n   1                    .file   \"src2.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl _Z6test_2v\n   6                    .type   _Z6test_2v, @function\n   7                _Z6test_2v:\n   8                .LFB2:\n   9 0000 BE080000      movl    $8, %esi\n   9      00\n  10 0005 BF070000      movl    $7, %edi\n  10      00\n  11 000a E9000000      jmp _Z4funcii\n  11      00\n  12                .LFE2:\n  13                    .size   _Z6test_2v, .-_Z6test_2v\n  14                .globl __gxx_personality_v0\n  15                    .section    .eh_frame,\"a\",@progbits\n  16                .Lframe1:\n  17 0000 1C000000      .long   .LECIE1-.LSCIE1\n  18                .LSCIE1:\n  19 0004 00000000      .long   0x0\n  20 0008 01            .byte   0x1\n  21 0009 7A505200      .string \"zPR\"\n  22 000d 01            .uleb128 0x1\n  23 000e 78            .sleb128 -8\n  24 000f 10            .byte   0x10\n  25 0010 06            .uleb128 0x6\n  26 0011 03            .byte   0x3\n  27 0012 00000000      .long   __gxx_personality_v0\n  28 0016 03            .byte   0x3\n  29 0017 0C            .byte   0xc\n  30 0018 07            .uleb128 0x7\n  31 0019 08            .uleb128 0x8\n  32 001a 90            .byte   0x90\n  33 001b 01            .uleb128 0x1\n  34 001c 00000000      .align 8\n  35                .LECIE1:\n  36                .LSFDE1:\n  37 0020 14000000      .long   .LEFDE1-.LASFDE1\n  38                .LASFDE1:\n  39 0024 24000000      .long   .LASFDE1-.Lframe1\n  40 0028 00000000      .long   .LFB2\n  41 002c 0F000000      .long   .LFE2-.LFB2\n  42 0030 00            .uleb128 0x0\n  43 0031 00000000      .align 8\n  43      000000\n  44                .LEFDE1:\n  45                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  46                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>main.s</p>\n<pre><code>GAS LISTING /tmp/cc5CfYBW.s             page 1\n\n\n   1                    .file   \"main.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl main\n   6                    .type   main, @function\n   7                main:\n   8                .LFB2:\n   9 0000 4883EC08      subq    $8, %rsp\n  10                .LCFI0:\n  11 0004 E8000000      call    _Z6test_1v\n  11      00\n  12 0009 E8000000      call    _Z6test_2v\n  12      00\n  13 000e E8000000      call    _Z6test_1v\n  13      00\n  14                    .p2align 4,,5\n  15 0013 E8000000      call    _Z6test_2v\n  15      00\n  16 0018 31C0          xorl    %eax, %eax\n  17 001a 4883C408      addq    $8, %rsp\n  18                    .p2align 4,,1\n  19 001e C3            ret\n  20                .LFE2:\n  21                    .size   main, .-main\n  22                .globl __gxx_personality_v0\n  23                    .section    .eh_frame,\"a\",@progbits\n  24                .Lframe1:\n  25 0000 1C000000      .long   .LECIE1-.LSCIE1\n  26                .LSCIE1:\n  27 0004 00000000      .long   0x0\n  28 0008 01            .byte   0x1\n  29 0009 7A505200      .string \"zPR\"\n  30 000d 01            .uleb128 0x1\n  31 000e 78            .sleb128 -8\n  32 000f 10            .byte   0x10\n  33 0010 06            .uleb128 0x6\n  34 0011 03            .byte   0x3\n  35 0012 00000000      .long   __gxx_personality_v0\n  36 0016 03            .byte   0x3\n  37 0017 0C            .byte   0xc\n  38 0018 07            .uleb128 0x7\n  39 0019 08            .uleb128 0x8\n  40 001a 90            .byte   0x90\n  41 001b 01            .uleb128 0x1\n  42 001c 00000000      .align 8\n  43                .LECIE1:\n  44                .LSFDE1:\n  45 0020 14000000      .long   .LEFDE1-.LASFDE1\n  46                .LASFDE1:\n  47 0024 24000000      .long   .LASFDE1-.Lframe1\n  48 0028 00000000      .long   .LFB2\n  49 002c 1F000000      .long   .LFE2-.LFB2\n  50 0030 00            .uleb128 0x0\n  51 0031 44            .byte   0x4\n  52                    .long   .LCFI0-.LFB2\n  53 0032 0E            .byte   0xe\nGAS LISTING /tmp/cc5CfYBW.s             page 2\n\n\n  54 0033 10            .uleb128 0x10\n  55 0034 00000000      .align 8\n  56                .LEFDE1:\n  57                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  58                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>Example 2:</p>\n<p>header.h</p>\n<pre><code>#ifndef HEADER_H_\n#define HEADER_H_\n\ninline int func(int a, int b)\n{\n   return a + b;\n}\nint test_1();\nint test_2();\n\n#endif /* HEADER_H_ */\n</code></pre>\n<p>src.cc</p>\n<pre><code>#include \"header.h\"\n\n/*\nint func(int a, int b)\n{\n   return a + b;\n}*/\n</code></pre>\n<p>src1.cc</p>\n<pre><code>#include \"header.h\"\n\nint test_1()\n{\n   int a, b, c;\n   a = 3;\n   b = 7;\n   c = func(a, b);\n   return c;\n}\n</code></pre>\n<p>src2.cc</p>\n<pre><code>#include \"header.h\"\n\nint test_2()\n{\n   int a, b, c;\n   a = 7;\n   b = 8;\n   c = func(a, b);\n   return c;\n}\n</code></pre>\n<p>main.cc</p>\n<pre><code>int main(int argc, char** argv)\n{\n   test_1();\n   test_2();\n   test_1();\n   test_2();\n}\n</code></pre>\n<p>Assembly 2:</p>\n<p>src.s</p>\n<pre><code>GAS LISTING /tmp/cczLx8os.s             page 1\n\n\n   1                    .file   \"src.cc\"\n   2                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n   3                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src1.s</p>\n<pre><code>GAS LISTING /tmp/ccMFMy9s.s             page 1\n\n\n   1                    .file   \"src1.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl _Z6test_1v\n   6                    .type   _Z6test_1v, @function\n   7                _Z6test_1v:\n   8                .LFB3:\n   9 0000 B80A0000      movl    $10, %eax\n   9      00\n  10 0005 C3            ret\n  11                .LFE3:\n  12                    .size   _Z6test_1v, .-_Z6test_1v\n  13                .globl __gxx_personality_v0\n  14                    .section    .eh_frame,\"a\",@progbits\n  15                .Lframe1:\n  16 0000 1C000000      .long   .LECIE1-.LSCIE1\n  17                .LSCIE1:\n  18 0004 00000000      .long   0x0\n  19 0008 01            .byte   0x1\n  20 0009 7A505200      .string \"zPR\"\n  21 000d 01            .uleb128 0x1\n  22 000e 78            .sleb128 -8\n  23 000f 10            .byte   0x10\n  24 0010 06            .uleb128 0x6\n  25 0011 03            .byte   0x3\n  26 0012 00000000      .long   __gxx_personality_v0\n  27 0016 03            .byte   0x3\n  28 0017 0C            .byte   0xc\n  29 0018 07            .uleb128 0x7\n  30 0019 08            .uleb128 0x8\n  31 001a 90            .byte   0x90\n  32 001b 01            .uleb128 0x1\n  33 001c 00000000      .align 8\n  34                .LECIE1:\n  35                .LSFDE1:\n  36 0020 14000000      .long   .LEFDE1-.LASFDE1\n  37                .LASFDE1:\n  38 0024 24000000      .long   .LASFDE1-.Lframe1\n  39 0028 00000000      .long   .LFB3\n  40 002c 06000000      .long   .LFE3-.LFB3\n  41 0030 00            .uleb128 0x0\n  42 0031 00000000      .align 8\n  42      000000\n  43                .LEFDE1:\n  44                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  45                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src2.s</p>\n<pre><code>GAS LISTING /tmp/ccNXXmLv.s             page 1\n\n\n   1                    .file   \"src2.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl _Z6test_2v\n   6                    .type   _Z6test_2v, @function\n   7                _Z6test_2v:\n   8                .LFB3:\n   9 0000 B80F0000      movl    $15, %eax\n   9      00\n  10 0005 C3            ret\n  11                .LFE3:\n  12                    .size   _Z6test_2v, .-_Z6test_2v\n  13                .globl __gxx_personality_v0\n  14                    .section    .eh_frame,\"a\",@progbits\n  15                .Lframe1:\n  16 0000 1C000000      .long   .LECIE1-.LSCIE1\n  17                .LSCIE1:\n  18 0004 00000000      .long   0x0\n  19 0008 01            .byte   0x1\n  20 0009 7A505200      .string \"zPR\"\n  21 000d 01            .uleb128 0x1\n  22 000e 78            .sleb128 -8\n  23 000f 10            .byte   0x10\n  24 0010 06            .uleb128 0x6\n  25 0011 03            .byte   0x3\n  26 0012 00000000      .long   __gxx_personality_v0\n  27 0016 03            .byte   0x3\n  28 0017 0C            .byte   0xc\n  29 0018 07            .uleb128 0x7\n  30 0019 08            .uleb128 0x8\n  31 001a 90            .byte   0x90\n  32 001b 01            .uleb128 0x1\n  33 001c 00000000      .align 8\n  34                .LECIE1:\n  35                .LSFDE1:\n  36 0020 14000000      .long   .LEFDE1-.LASFDE1\n  37                .LASFDE1:\n  38 0024 24000000      .long   .LASFDE1-.Lframe1\n  39 0028 00000000      .long   .LFB3\n  40 002c 06000000      .long   .LFE3-.LFB3\n  41 0030 00            .uleb128 0x0\n  42 0031 00000000      .align 8\n  42      000000\n  43                .LEFDE1:\n  44                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  45                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>main.s</p>\n<pre><code>GAS LISTING /tmp/cc2cc5rp.s             page 1\n\n\n   1                    .file   \"main.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl main\n   6                    .type   main, @function\n   7                main:\n   8                .LFB3:\n   9 0000 4883EC08      subq    $8, %rsp\n  10                .LCFI0:\n  11 0004 E8000000      call    _Z6test_1v\n  11      00\n  12 0009 E8000000      call    _Z6test_2v\n  12      00\n  13 000e E8000000      call    _Z6test_1v\n  13      00\n  14                    .p2align 4,,5\n  15 0013 E8000000      call    _Z6test_2v\n  15      00\n  16 0018 31C0          xorl    %eax, %eax\n  17 001a 4883C408      addq    $8, %rsp\n  18                    .p2align 4,,1\n  19 001e C3            ret\n  20                .LFE3:\n  21                    .size   main, .-main\n  22                .globl __gxx_personality_v0\n  23                    .section    .eh_frame,\"a\",@progbits\n  24                .Lframe1:\n  25 0000 1C000000      .long   .LECIE1-.LSCIE1\n  26                .LSCIE1:\n  27 0004 00000000      .long   0x0\n  28 0008 01            .byte   0x1\n  29 0009 7A505200      .string \"zPR\"\n  30 000d 01            .uleb128 0x1\n  31 000e 78            .sleb128 -8\n  32 000f 10            .byte   0x10\n  33 0010 06            .uleb128 0x6\n  34 0011 03            .byte   0x3\n  35 0012 00000000      .long   __gxx_personality_v0\n  36 0016 03            .byte   0x3\n  37 0017 0C            .byte   0xc\n  38 0018 07            .uleb128 0x7\n  39 0019 08            .uleb128 0x8\n  40 001a 90            .byte   0x90\n  41 001b 01            .uleb128 0x1\n  42 001c 00000000      .align 8\n  43                .LECIE1:\n  44                .LSFDE1:\n  45 0020 14000000      .long   .LEFDE1-.LASFDE1\n  46                .LASFDE1:\n  47 0024 24000000      .long   .LASFDE1-.Lframe1\n  48 0028 00000000      .long   .LFB3\n  49 002c 1F000000      .long   .LFE3-.LFB3\n  50 0030 00            .uleb128 0x0\n  51 0031 44            .byte   0x4\n  52                    .long   .LCFI0-.LFB3\n  53 0032 0E            .byte   0xe\nGAS LISTING /tmp/cc2cc5rp.s             page 2\n\n\n  54 0033 10            .uleb128 0x10\n  55 0034 00000000      .align 8\n  56                .LEFDE1:\n  57                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  58                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>Example 3:</p>\n<p>header.h</p>\n<pre><code>#ifndef HEADER_H_\n#define HEADER_H_\n\ninline int func(int a, int b)\n{\n   return a + b;\n}\ninline int test_1()\n{\n   int a, b, c;\n   a = 3;\n   b = 7;\n   c = func(a, b);\n   return c;\n}\ninline int test_2()\n{\n   int a, b, c;\n   a = 7;\n   b = 8;\n   c = func(a, b);\n   return c;\n}\n\n#endif /* HEADER_H_ */\n</code></pre>\n<p>src.cc</p>\n<pre><code>#include \"header.h\"\n\n/*\nint func(int a, int b)\n{\n   return a + b;\n}*/\n</code></pre>\n<p>src1.cc</p>\n<pre><code>#include \"header.h\"\n\n/*int test_1()\n{\n   int a, b, c;\n   a = 3;\n   b = 7;\n   c = func(a, b);\n   return c;\n}*/\n</code></pre>\n<p>src2.cc</p>\n<pre><code>#include \"header.h\"\n\n\n/*int test_2()\n{\n   int a, b, c;\n   a = 7;\n   b = 8;\n   c = func(a, b);\n   return c;\n}*/\n</code></pre>\n<p>main.cc</p>\n<pre><code>int main(int argc, char** argv)\n{\n   test_1();\n   test_2();\n   test_1();\n   test_2();\n}\n</code></pre>\n<p>Assembly 3:</p>\n<p>src.s</p>\n<pre><code>GAS LISTING /tmp/ccfPkzMC.s             page 1\n\n\n   1                    .file   \"src.cc\"\n   2                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n   3                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src1.s</p>\n<pre><code>GAS LISTING /tmp/cckRkoWG.s             page 1\n\n\n   1                    .file   \"src1.cc\"\n   2                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n   3                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>src2.s</p>\n<pre><code>GAS LISTING /tmp/ccfmb3gI.s             page 1\n\n\n   1                    .file   \"src2.cc\"\n   2                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n   3                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>main.s</p>\n<pre><code>GAS LISTING /tmp/ccGBsR8z.s             page 1\n\n\n   1                    .file   \"main.cc\"\n   2                    .text\n   3                    .align 2\n   4                    .p2align 4,,15\n   5                .globl main\n   6                    .type   main, @function\n   7                main:\n   8                .LFB5:\n   9 0000 31C0          xorl    %eax, %eax\n  10 0002 C3            ret\n  11                .LFE5:\n  12                    .size   main, .-main\n  13                .globl __gxx_personality_v0\n  14                    .section    .eh_frame,\"a\",@progbits\n  15                .Lframe1:\n  16 0000 1C000000      .long   .LECIE1-.LSCIE1\n  17                .LSCIE1:\n  18 0004 00000000      .long   0x0\n  19 0008 01            .byte   0x1\n  20 0009 7A505200      .string \"zPR\"\n  21 000d 01            .uleb128 0x1\n  22 000e 78            .sleb128 -8\n  23 000f 10            .byte   0x10\n  24 0010 06            .uleb128 0x6\n  25 0011 03            .byte   0x3\n  26 0012 00000000      .long   __gxx_personality_v0\n  27 0016 03            .byte   0x3\n  28 0017 0C            .byte   0xc\n  29 0018 07            .uleb128 0x7\n  30 0019 08            .uleb128 0x8\n  31 001a 90            .byte   0x90\n  32 001b 01            .uleb128 0x1\n  33 001c 00000000      .align 8\n  34                .LECIE1:\n  35                .LSFDE1:\n  36 0020 14000000      .long   .LEFDE1-.LASFDE1\n  37                .LASFDE1:\n  38 0024 24000000      .long   .LASFDE1-.Lframe1\n  39 0028 00000000      .long   .LFB5\n  40 002c 03000000      .long   .LFE5-.LFB5\n  41 0030 00            .uleb128 0x0\n  42 0031 00000000      .align 8\n  42      000000\n  43                .LEFDE1:\n  44                    .ident  \"GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-54)\"\n  45                    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>Example 1 and example 3 are the ones I'm particularly interested in, because they should highlight somehow what is the difference between an inline function and a not inline function (following the points 1,2 and 3 of the link I posted above), I don't see any lack of properties in the not inline functions compared to the inline version. Can someone highlight the difference for me (again in terms of the points 1,2 and 3)?</p>\n", "Title": "Inline functions - what are they exactly vis-a-vis the inline keyword?", "FavoriteCount": "4", "LastEditDate": "2017-01-06T13:48:14.933", "Id": "41491221", "Score": "35", "CreationDate": "2017-01-05T17:32:03.517", "Tags": "<c++><function><inline>", "OwnerUserId": "4792660", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_41491221_41491221_3": {"section_id": 5404, "quality": 0.5652173913043478, "length": 13}, "so_41491221_41493715_5": {"section_id": 5404, "quality": 0.5555555555555556, "length": 5}, "so_41491221_41493715_2": {"section_id": 7043, "quality": 0.5384615384615384, "length": 7}, "so_41491221_41493715_4": {"section_id": 7043, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_41491221_41491221_3": {"section_id": 5199, "quality": 0.5652173913043478, "length": 13}, "so_41491221_41493715_5": {"section_id": 5199, "quality": 0.5555555555555556, "length": 5}, "so_41491221_41493715_2": {"section_id": 6788, "quality": 0.5384615384615384, "length": 7}, "so_41491221_41493715_4": {"section_id": 6788, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_41491221_41493715_5": {"section_id": 6853, "quality": 0.5555555555555556, "length": 5}, "so_41491221_41491221_3": {"section_id": 6853, "quality": 0.6086956521739131, "length": 14}, "so_41491221_41493715_2": {"section_id": 8540, "quality": 0.6153846153846154, "length": 8}, "so_41491221_41491221_2": {"section_id": 8540, "quality": 0.5294117647058824, "length": 9}, "so_41491221_41493715_4": {"section_id": 8540, "quality": 0.6153846153846154, "length": 8}}}, "41493715": {"ParentId": "41491221", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_41491221_41493715_0\">The point 1) means that I can give different implementation as long as they're in different translation units</p>\n</blockquote>\n<p>No, it says you can have more than one implementation. It does not say they can be different. The implementations must all be identical.</p>\n<blockquote>\n<p id=\"so_41491221_41493715_1\">I'm puzzled in the case I have a source file <code>source.cc</code> with a declaration for <code>func</code> and an header file with another declaration of <code>func</code> the translation unit is the pair <code>source.cc+header.h</code> and in such a case having declared two times <code>func</code> doesn't make any sense, is that right?</p>\n</blockquote>\n<p>You can declare a function as many times as you like, in as many translation units as you like, regardless of whether or not it is inline. Inline is not a factor here.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_41491221_41493715_4\">2) The definition of an inline function or variable (since C++17) must be present in the translation unit where it is accessed.</p>\n</blockquote>\n<p id=\"so_41491221_41493715_3\">This is the usual case where I separate definition from declaration, the first in an header file, the second one is in the source file, if I need to use the function I have to include only the header right? The access point would be provided by the source during the linking phase, correct?</p>\n</blockquote>\n<p>No, the <em>definition</em> of an inline function must be present in every TU that uses it, before the linking phase. <strong>It is the <em>purpose</em> of inline functions to <em>allow</em> definitions in multiple TUs; you use <code>inline</code> when you <em>want</em> to put the definition of a function in a header.</strong></p>\n<blockquote>\n<p id=\"so_41491221_41493715_5\">The case 3) states that the keyword inline is mandatory unless the function to be declared is static.</p>\n</blockquote>\n<p>No, it doesn't say that at all, I don't know how you could have interpreted it that way. It just says that an <code>inline</code> <code>static</code> function has internal linkage, and an <code>inline</code> non-<code>static</code> function has external linkage, and subpoints 3.1 and 3.2 apply to <code>inline</code> functions with external linkage.</p>\n<blockquote>\n<p id=\"so_41491221_41493715_6\">In practice a function should be inline when such a function is very small, but not always the compiler would inline the function declared as inline, for example if it has loops inside or recursion (Effective C++ states so). In general then it's compiler dependent, I the wonder now...</p>\n<p id=\"so_41491221_41493715_7\">Say I have two functions the first one is self-contained (it doesn't internally call any-other function), the second one call's the first one (you can assume they're both 10 lines for sake of argument). Should both of them declared inline? should they be declared in an header file? or should I separate definition in an header file and the implementation in an source file? What would be better?</p>\n</blockquote>\n<p>Whether or not the optimizer will perform inline substitution of a function body is not strongly correlated with whether it is an <code>inline</code> function. <strong>The optimizer will figure out for itself whether to perform inline substitution of a function, regardless of whether or not it is an <code>inline</code> function.</strong> You declare functions <code>inline</code> if you want to put their definition in a header.</p>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "41493715", "Score": "15", "CreationDate": "2017-01-05T20:03:34.650", "LastActivityDate": "2017-01-05T20:03:34.650"}});