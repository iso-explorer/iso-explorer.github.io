post_cb({"17407553": {"ViewCount": "2838", "Body": "<p>1) std::call_once</p>\n<pre><code>A a;\nstd::once_flag once;\n\nvoid f ( ) {\n    call_once ( once, [ ] { a = A {....}; } );\n}\n</code></pre>\n<p>2) function-level static</p>\n<pre><code>A a;\n\nvoid f ( ) {\n    static bool b = ( [ ] { a = A {....}; } ( ), true );\n}\n</code></pre>\n", "AcceptedAnswerId": "17410115", "Title": "what is the difference between std::call_once and function-level static initialization", "CreationDate": "2013-07-01T14:58:55.663", "Id": "17407553", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-01T15:43:52.520", "LastEditorUserId": "2088034", "LastActivityDate": "2013-07-01T17:20:29.417", "Score": "14", "OwnerUserId": "2088034", "Tags": "<multithreading><c++11>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17407553_17408879_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 2973}, "so_17407553_17408879_0": {"length": 110, "quality": 0.9482758620689655, "section_id": 3919}}, "n3337": {"so_17407553_17408879_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 2842}, "so_17407553_17408879_0": {"length": 110, "quality": 0.9482758620689655, "section_id": 3779}}, "n4659": {"so_17407553_17408879_1": {"length": 55, "quality": 0.9166666666666666, "section_id": 3732}, "so_17407553_17408879_0": {"length": 60, "quality": 0.5172413793103449, "section_id": 4805}}}, "17408879": {"Id": "17408879", "PostTypeId": "2", "Body": "<p>Both code snippets have the same behaviour, even in the presence of exceptions thrown during initialization.</p>\n<p>This conclusion is based on (my interpretation of) the following quotes from the c++11 standard (draft n3337):</p>\n<ul>\n<li>1  Section <em>6.7 Declaration statement</em> clause 4 states:</li>\n</ul>\n<blockquote>\n<p id=\"so_17407553_17408879_0\">The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered.  An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such <strong>a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.88</strong> If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>\n</blockquote>\n<p>This means that in:</p>\n<pre><code>void f ( ) {\n    static bool b = ( [ ] { a = A {....}; } ( ), true );\n}\n</code></pre>\n<p><code>b</code> is guaranteed to be initialized once only, meaning the lambda is executed (successfully) once only, meaning <code>a = A {...};</code> is executed (successfully) once only.</p>\n<ul>\n<li>2 Section <em>30.4.4.2 Function call-once</em> states:</li>\n</ul>\n<blockquote>\n<p id=\"so_17407553_17408879_1\">An execution of call_once that does not call its func is a passive execution. An execution of call_once that calls its func is an active execution. An active execution shall call INVOKE (DECAY_COPY ( std::forward(func)), DECAY_COPY (std::forward(args))...). If such a call to func throws an exception the execution is exceptional, otherwise it is returning. An exceptional execution shall propagate the exception to the caller of call_once. <strong>Among all executions of call_once for any given once_flag: at most one shall be a returning execution;</strong> if there is a returning execution, it shall be the last active execution; and there are passive executions only if there is a returning execution.</p>\n</blockquote>\n<p>This means that in:</p>\n<pre><code>void f ( ) {\n    call_once ( once, [ ] { a = A {....}; } );\n</code></pre>\n<p>the lambda argument to <code>std::call_once</code> is executed (successfully) once only, meaning <code>a = A {...};</code> is executed (successfully) once only.</p>\n<p>In both cases <code>a = A{...};</code> is executed (successfully) once only.</p>\n", "LastActivityDate": "2013-07-01T16:04:28.700", "CommentCount": "1", "CreationDate": "2013-07-01T16:04:28.700", "ParentId": "17407553", "Score": "6", "OwnerUserId": "1033896"}, "17410115": {"Id": "17410115", "PostTypeId": "2", "Body": "<p>For your example usage, hmjd's answer fully explains that there is no difference (except for the additional global <code>once_flag</code> object needed in the <code>call_once</code> case.)  However, the <code>call_once</code> case is more flexible, since the <code>once_flag</code> object isn't tied to a single scope. As an example, it could be a class member and be used by more than one function:</p>\n<pre><code>class X {\n  std::once_flag once;\n\n  void doSomething() {\n    std::call_once(once, []{ /* init ...*/ });\n    // ...\n  }\n\n  void doSomethingElse() {\n    std::call_once(once, []{ /*alternative init ...*/ });\n    // ...\n  }\n};\n</code></pre>\n<p>Now depending on which member function is called first the initialization code can be different (but the object will still only be initialized once.)</p>\n<p>So for simple cases a local static works nicely (if supported by your compiler) but there are some less common uses that might be easier to implement with <code>call_once</code>.</p>\n", "LastActivityDate": "2013-07-01T17:20:29.417", "CommentCount": "0", "CreationDate": "2013-07-01T17:20:29.417", "ParentId": "17407553", "Score": "10", "OwnerUserId": "981959"}});