post_cb({"40322579": {"CommentCount": "9", "ViewCount": "209", "PostTypeId": "1", "LastEditorUserId": "2430597", "CreationDate": "2016-10-29T18:59:59.797", "LastActivityDate": "2016-10-30T00:10:25.370", "Title": "constexpr member function of non constexpr constructible class", "LastEditDate": "2016-10-29T23:37:11.770", "Id": "40322579", "Score": "0", "Body": "<p>If a non-<a href=\"http://en.cppreference.com/w/cpp/concept/LiteralType\" rel=\"nofollow\">literal</a> class type has no <code>constexpr</code> constructor (it is not <code>constexpr</code> constructible), does a non-static <code>constexpr</code> member function make any sense? I mean if you cannot construct the object at compile time, how would you able to use its member functions?</p>\n<p>Anyway, the major compilers don't complain about it, which makes me think it is allowed by the standard.</p>\n<p>Nevertheless, you are able to use such <code>constexpr</code> member functions in runtime without any problem. The only question now what is the effect of <code>constexpr</code> in this case, if any. <strong>My best guess is that the return value of the <code>constexpr</code> member is being evaluated at compile-time (if possible), so on a run-time call it have to do a simple copy.</strong></p>\n<p>Is my guess correct, or is the <code>constexpr</code> specifier absolutely meaningless in this case (i.e. the member function is being evaluated at runtime)?</p>\n", "Tags": "<c++><language-lawyer><constexpr>", "OwnerUserId": "2430597", "AnswerCount": "1"}, "40324901": {"ParentId": "40322579", "CommentCount": "6", "Body": "<p>The premise of your question seems to be that only <code>constexpr</code> functions can be evaluated at compile-time.</p>\n<p>This premise is incorrect.  The compiler can precompute anything it can figure out a way to do, as long as the exact side result and side-effects are produced (as-if rule).</p>\n<p>What <code>constexpr</code> provides is a guarantee that certain expressions will be evaluated at compile-time by <em>every</em> compiler (it's not a \"quality of implementation\" issue), which makes it possible to use them in contexts where a compile-time value is needed, such as non-type template arguments, operands of <code>case</code> clauses in <code>switch</code> statements, etc.</p>\n<p>The specific details around <code>constexpr</code> functions include that there has to be at least one set of arguments (the target instance is an implied argument) such that the <code>constexpr</code> evaluation rules are met.  If that isn't true, your program is ill-formed and its runtime behavior is not specified at all, so don't go adding <code>constexpr</code> where it doesn't logically belong.</p>\n<p>However, compilers aren't required to diagnose violations of this rule.  That means that \"major compilers don't complain about it\" should not be in any way interpreted as assurance that the code is correct.</p>\n<hr>\n<p>Standard's wording, section 7.1.5 (draft n4582)</p>\n<blockquote>\n<p id=\"so_40322579_40324901_0\">For a <code>constexpr</code> function or <code>constexpr</code> constructor that is neither defaulted nor a template, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of\n  a core constant expression, or, for a constructor, a constant initializer for some object, the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "40324901", "Score": "0", "CreationDate": "2016-10-30T00:10:25.370", "LastActivityDate": "2016-10-30T00:10:25.370"}, "bq_ids": {"n4140": {"so_40322579_40324901_0": {"section_id": 5421, "quality": 0.6666666666666666, "length": 20}}, "n3337": {"so_40322579_40324901_0": {"section_id": 5216, "quality": 0.5333333333333333, "length": 16}}, "n4659": {"so_40322579_40324901_0": {"section_id": 6843, "quality": 0.9666666666666667, "length": 29}}}});