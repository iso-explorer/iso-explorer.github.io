post_cb({"8157583": {"ParentId": "8100492", "CommentCount": "6", "CreationDate": "2011-11-16T19:37:28.640", "OwnerUserId": "584746", "PostTypeId": "2", "Id": "8157583", "Score": "1", "Body": "<p>Having never used Clang, I was quite interested in this problem. (Ironic, yes I know.)</p>\n<p><a href=\"http://clang.llvm.org/compatibility.html#c++\" rel=\"nofollow\">Clang C++ Compatibility</a> indicates that there are several things regarding templates that other compilers (notably GCC) process that it will complain about. These are things that are weakly defined in the standard (\"well, you shouldn't allow this ... but you can\"); nearly all of them involve templates. None of these <em>exactly</em> look like your problem, but they're close enough to be informative -- and certainly worth a read.</p>\n<p>So, it doesn't look like Clang is broken -- it's just that Clang is pickier than the others.</p>\n", "LastActivityDate": "2011-11-16T19:37:28.640"}, "8123888": {"ParentId": "8100492", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-11-14T15:30:24.717", "Score": "4", "LastEditorUserId": "600135", "LastEditDate": "2011-11-14T15:52:27.717", "Id": "8123888", "OwnerUserId": "600135", "Body": "<p>When we call these two lines:</p>\n<pre><code>TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt; c;\nTemplateClass&lt;std::string&gt;::static_method(c);\n</code></pre>\n<p>then the type argument U is the type of the object c:</p>\n<pre><code>TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt;\n</code></pre>\n<p>Let's leave <code>static_method</code>, and do an experiment:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo.h&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass TemplateClass : public T {\npublic:\n  void method(int i) {\n    cout &lt;&lt; i &lt;&lt; \": \";\n    cout &lt;&lt; typeid(*this).name() &lt;&lt; endl; \n  }\n};\n\nclass EmptyClass { };\n\nvoid main() {\n  TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt; u;\n  u.method(1);\n  u.TemplateClass::method(2);\n  u.TemplateClass&lt;EmptyClass&gt;::method(3);\n  u.TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt;::method(4);\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>1: class TemplateClass&lt;class TemplateClass&lt;class EmptyClass&gt; &gt;\n2: class TemplateClass&lt;class TemplateClass&lt;class EmptyClass&gt; &gt;\n3: class TemplateClass&lt;class EmptyClass&gt;\n4: class TemplateClass&lt;class TemplateClass&lt;class EmptyClass&gt; &gt;\n</code></pre>\n<p>In all four cases (and inside <code>static_method</code>) we call <code>TemplateClass&lt;T&gt;::method</code>, and the type name given between <code>u.</code> and <code>::</code> will give the actual type T: </p>\n<ul>\n<li>Case #1 is the default, here T is given by the declaration of u. </li>\n<li>Case #4 is also trivial.</li>\n<li>Case #2 looks as if the compiler should have guessed the type argument of TemplateClass, which is trivially the one given in the declaration of u.</li>\n<li>Case #3 is very interesting. I guess function type casting happened here, from <code>TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt;::method</code> to <code>TemplateClass&lt;EmptyClass&gt;::method</code>.</li>\n</ul>\n<p>I don't know whether this behavior is part of the C++ standard. </p>\n<p><strong>EDIT:</strong></p>\n<p>Actually case #3 is not casting, these are <strong>qualified names</strong>. So in conclusion, Clang is not aware of this qualification syntax, while both GCC and Visual C++ 2010 are.</p>\n", "LastActivityDate": "2011-11-14T15:52:27.717"}, "8454314": {"ParentId": "8100492", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-12-10T04:09:08.600", "Score": "2", "LastEditorUserId": "963864", "LastEditDate": "2011-12-10T04:39:03.793", "Id": "8454314", "OwnerUserId": "963864", "Body": "<h1>Not an answer,</h1>\n<p>just my small contribution:</p>\n<p>Removing templates, but keeping the same names:</p>\n<pre>\nstruct A {\n    struct TemplateClass {\n        void method() {}\n    };\n};\nstruct B {\n    struct TemplateClass {\n        void method() {}\n\n        static void static_method(A::TemplateClass u) { \n            u.TemplateClass::method(); \n        }\n    };\n};\n\nint main() {\n    A::TemplateClass c;\n    B::TemplateClass::static_method(c);\n}\n</pre>\n<p>gives</p>\n<pre>\nComeau C/C++ 4.3.10.1 (Oct  6 2008 11:28:09) for ONLINE_EVALUATION_BETA2\nCopyright 1988-2008 Comeau Computing.  All rights reserved.\nMODE:strict errors C++ C++0x_extensions\n\n\"ComeauTest.c\", line 11: error: ambiguous class member reference -- type\n          \"B::TemplateClass::TemplateClass\" (declared at line 7) used in\n          preference to type \"A::TemplateClass::TemplateClass\" (declared at\n          line 2)\n            u.TemplateClass::method(); \n              ^\n\n\"ComeauTest.c\", line 11: error: qualified name is not a member of class\n          \"A::TemplateClass\" or its base classes\n            u.TemplateClass::method(); \n              ^\n\n2 errors detected in the compilation of \"ComeauTest.c\".\n</pre>\n<h1>From N3242</h1>\n<p><strong>Locally declared names [temp.local]</strong></p>\n<blockquote>\n<p id=\"so_8100492_8454314_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected class-name can be used with or without a template-argument-list. When it is used without a template-argument-list, it is equivalent to the injected-class-name followed by the template-parameters of the class\n  template enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>(...)</p>\n<blockquote>\n<p id=\"so_8100492_8454314_1\">Within the scope of a class template specialization or partial specialization, when the injected-class-name is not followed by a &lt;, it is equivalent to the injected-class-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;&gt;.</p>\n</blockquote>\n<p>(...)</p>\n<blockquote>\n<p id=\"so_8100492_8454314_2\">A lookup that finds an injected-class-name (10.2) can result in an ambiguity in certain cases</p>\n</blockquote>\n", "LastActivityDate": "2011-12-10T04:39:03.793"}, "8123034": {"ParentId": "8100492", "CommentCount": "4", "CreationDate": "2011-11-14T14:29:10.327", "OwnerUserId": "390807", "PostTypeId": "2", "Id": "8123034", "Score": "7", "Body": "<p>In ISO/IEC 14882:2011(E), \"14.6.1 Locally declared names [temp.local]\", [#5] says:</p>\n<blockquote>\n<p id=\"so_8100492_8123034_0\">When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name)\n  is used, it always refers to the class template itself and not a specialization of the template.[ Example:</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; class X {\n    X* p;    // meaning X&lt;T&gt;\n    X&lt;T&gt;* p2;\n    X&lt;int&gt;* p3;\n    ::X* p4;    // error: missing template argument list\n                // ::X does not refer to the injected-class-name\n};\n\u2014 end example ]\n</code></pre>\n<p>This leads me to believe that in your example <code>u.TemplateClass::method();</code> is equivalent to <code>u.TemplateClass&lt;T&gt;::method();</code> and if Clang gives an error in one case and compiles cleanly in the other case, then it's a Clang error.</p>\n", "LastActivityDate": "2011-11-14T14:29:10.327"}, "8100550": {"ParentId": "8100492", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-11-11T22:07:08.313", "Score": "0", "LastEditorUserId": "964135", "LastEditDate": "2011-11-11T22:38:23.263", "Id": "8100550", "OwnerUserId": "964135", "Body": "<p>I think the ambiguity is because <code>TemplateClass</code> is twice in the inheritance <code>TemplateClass : (TemplateClass : EmptyClass)</code></p>\n<p>Does <code>u.TemplateClass::method();</code> mean <code>u.TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt;::method();</code> or <code>u.TemplateClass&lt;EmptyClass&gt; &gt;::method();</code> ?</p>\n<p>Perhaps GCC has the standard right, but whatever the case is you should add the <code>&lt;T&gt;</code>.</p>\n", "LastActivityDate": "2011-11-11T22:38:23.263"}, "8453351": {"ParentId": "8100492", "CommentCount": "1", "CreationDate": "2011-12-10T00:23:08.247", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "8453351", "Score": "11", "Body": "<p>I believe that clang is correctly rejecting this code.</p>\n<p>The ambiguity that clang finds can be reproduced with a less complicated example:</p>\n<pre><code>template&lt;typename T&gt;\nclass TemplateClass {\n public:\n  void method() {}\n  template&lt;typename U&gt;\n  static void static_method(U u) { u.TemplateClass::method(); }                                  \n};\n\nstruct A {};\nstruct B {};\n\nint main() {\n  TemplateClass&lt;A&gt; c;\n  TemplateClass&lt;B&gt;::static_method(c);\n}\n</code></pre>\n<p>Here the inheritance in the template is omitted and two independent classes are used for the instantiations. The error produced by clang remains the same.</p>\n<p>First of all, in the scope of <code>TemplateClass&lt;T&gt;</code> the name <code>TemplateClass</code> refers to <code>TemplateClass&lt;T&gt;</code>, due to class name injection. This is the reason that the static method can use <code>TemplateClass::method</code> instead of a more explicit <code>TemplateClass&lt;T&gt;::method</code>.</p>\n<p>The name lookup used to interpret <code>u.TemplateClass::method</code> in the static method is defined in <em>\"3.4.5 Class member access [base.lookup.classref]\"</em> of the C++11 and C++98 standards.</p>\n<p>The relevant part is 3.4.5/4:</p>\n<blockquote>\n<p id=\"so_8100492_8453351_0\">If the <em>id-expression</em> in a class member access is a <em>qualified-id</em> of the form</p>\n<pre><code>class-name-or-namespace-name::...\n</code></pre>\n<p id=\"so_8100492_8453351_1\"><em>[...]</em></p>\n</blockquote>\n<p>This is the case here. The <em>id-expression</em> is the part to the right of the <code>.</code> and in our case this is the qualified name <code>TemplateClass::method</code>.</p>\n<blockquote>\n<p id=\"so_8100492_8453351_2\"><em>[...]</em><br>\n  the <em>class-name-or-namespace-name</em> following the <code>.</code> or <code>-&gt;</code> operator is looked up both in the context of the\n  entire <em>postfix-expression</em> and in the scope of the class of the object expression.</br></p>\n</blockquote>\n<p>The \"scope of the entire <em>postfix-expression</em>\" is the body of the static function, and in this static function <code>TemplateClass</code> refers to <code>TemplateClass&lt;B&gt;</code>, since the function is a member of that class (we called <code>TemplateClass&lt;B&gt;::static_method</code>).</p>\n<p>So in this scope the name refers to <code>TemplateClass&lt;B&gt;</code>.</p>\n<p>The \"object expression\" is the part left of <code>.</code>, in our case <code>c</code>. The class of <code>c</code> is <code>TemplateClass&lt;A&gt;</code> and in the scope of this class, <code>TemplateClass</code> refers to <code>TemplateClass&lt;A&gt;</code>.</p>\n<p>So, depending on the scope used for the lookup, the name refers to a different entity.</p>\n<p>The standard now says:</p>\n<blockquote>\n<p id=\"so_8100492_8453351_3\">If the name is found in both contexts, the <em>class-name-or-namespace-name</em> shall refer to the same entity.</p>\n</blockquote>\n<p>This is not the case in our program. The program is ill-formed, and the compiler is required to give a diagnostic message.</p>\n<p>The ambiguity stays the same if you replace <code>B</code> with <code>TemplateClass&lt;A&gt;</code>, as used in the question.</p>\n", "LastActivityDate": "2011-12-10T00:23:08.247"}, "8100492": {"CommentCount": "0", "AcceptedAnswerId": "8453351", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2011-11-11T21:59:07.790", "LastActivityDate": "2011-12-10T04:39:03.793", "LastEditDate": "2011-12-10T03:50:03.187", "ViewCount": "1773", "FavoriteCount": "2", "Title": "Ambiguous member access expression: is Clang rejecting valid code?", "Id": "8100492", "Score": "23", "Body": "<p>I have some code that, for the purposes of this question, boils down to</p>\n<pre><code>template&lt;typename T&gt;\nclass TemplateClass : public T {\n public:\n  void method() {}\n  template&lt;typename U&gt;\n  static void static_method(U u) { u.TemplateClass::method(); }\n};\n\nclass EmptyClass {};\n\nint main() {\n  TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt; c;\n  TemplateClass&lt;EmptyClass&gt;::static_method(c);\n}\n</code></pre>\n<p>I've tried to compile it with several versions of two compilers. GCC 4.2, 4.4, 4.6 accept it without complaint. Clang 2.9 and SVN trunk as of November 14 reject it with the following error message:</p>\n<pre><code>example.cc:6:38: error: lookup of 'TemplateClass' in member access expression is\n      ambiguous\n  static void static_method(U u) { u.TemplateClass::method(); }\n                                     ^\nexample.cc:13:3: note: in instantiation of function template specialization\n      'TemplateClass&lt;EmptyClass&gt;::static_method&lt;TemplateClass&lt;TemplateClass&lt;EmptyClass&gt;\n      &gt; &gt;' requested here\n  TemplateClass&lt;EmptyClass&gt;::static_method(c);\n  ^\nexample.cc:2:7: note: lookup in the object type\n      'TemplateClass&lt;TemplateClass&lt;EmptyClass&gt; &gt;' refers here\nclass TemplateClass : public T {\n      ^\nexample.cc:2:7: note: lookup from the current scope refers here\n1 error generated.\n</code></pre>\n<p>Which one is wrong? I can work around Clang by changing</p>\n<pre><code>  static void static_method(U u) { u.TemplateClass::method(); }\n</code></pre>\n<p>to</p>\n<pre><code>  static void static_method(U u) { u.TemplateClass&lt;T&gt;::method(); }\n</code></pre>\n<p>but I'd like be confident in my understanding of when it's OK to elide the template parameters.</p>\n<hr>\n<p>EDIT: I had thought that the ambiguity was between the two instantiations of <code>TemplateClass</code>. The following code compiles with GCC and Clang, calling that hypothesis into doubt:</p>\n<pre><code>class E {};\n\ntemplate&lt;typename T&gt;\nclass A : public T {\n public:\n  void method() {}\n};\n\nint main() {\n  A&lt;A&lt;E&gt; &gt; a;\n  a.A::method();\n}\n</code></pre>\n</hr>", "Tags": "<c++><gcc><clang><language-lawyer><name-lookup>", "OwnerUserId": "1042522", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_8100492_8454314_0": {"section_id": 179, "quality": 0.782608695652174, "length": 18}, "so_8100492_8453351_0": {"section_id": 7129, "quality": 1.0, "length": 6}, "so_8100492_8454314_2": {"section_id": 182, "quality": 0.8888888888888888, "length": 8}, "so_8100492_8454314_1": {"section_id": 180, "quality": 0.9, "length": 18}, "so_8100492_8123034_0": {"section_id": 183, "quality": 0.9375, "length": 15}}, "n3337": {"so_8100492_8454314_0": {"section_id": 173, "quality": 0.782608695652174, "length": 18}, "so_8100492_8453351_0": {"section_id": 5724, "quality": 1.0, "length": 6}, "so_8100492_8454314_2": {"section_id": 176, "quality": 0.8888888888888888, "length": 8}, "so_8100492_8454314_1": {"section_id": 174, "quality": 0.9, "length": 18}, "so_8100492_8123034_0": {"section_id": 177, "quality": 0.9375, "length": 15}}, "n4659": {"so_8100492_8454314_0": {"section_id": 184, "quality": 0.782608695652174, "length": 18}, "so_8100492_8454314_1": {"section_id": 185, "quality": 0.9, "length": 18}, "so_8100492_8453351_0": {"section_id": 8630, "quality": 1.0, "length": 6}, "so_8100492_8454314_2": {"section_id": 187, "quality": 0.8888888888888888, "length": 8}, "so_8100492_8123034_0": {"section_id": 188, "quality": 0.9375, "length": 15}}}});