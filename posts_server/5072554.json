post_cb({"5072554": {"CommentCount": "1", "AcceptedAnswerId": "5072596", "CreationDate": "2011-02-21T23:42:25.480", "LastActivityDate": "2011-02-22T00:14:05.890", "PostTypeId": "1", "ViewCount": "419", "FavoriteCount": "1", "Title": "How does Stroustrup's Can_Copy template work?", "Id": "5072554", "Score": "6", "Body": "<p>Stroustrup provides a <a href=\"http://www2.research.att.com/~bs/bs_faq2.html#constraints\" rel=\"nofollow\">Can_copy template</a>. How does it work?</p>\n<pre><code>template&lt;class T1, class T2&gt; struct Can_copy {\n    static void constraints(T1 a, T2 b) { T2 c = a; b = a; }\n    Can_copy() { void(*p)(T1,T2) = constraints; }\n};\n</code></pre>\n<p>In particular, why does he need the line <code>void(*p)(T1,T2) = constraints;</code> instead of an empty constructor? Are compilers allowed to produce only the functions a particular template instance uses as an optimisation?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "165495", "AnswerCount": "4"}, "5072596": {"ParentId": "5072554", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-02-21T23:50:00.173", "Score": "8", "LastEditorUserId": "527807", "LastEditDate": "2011-02-21T23:53:57.787", "Id": "5072596", "OwnerUserId": "527807", "Body": "<p>It's because not used member functions in templates don't exist in generated code, so to check constrainst you would have to call <code>constraints()</code> explicitly somewhere. </p>\n<p>This way code for <code>constraints()</code> is generated, so constraints are checked in compile time (and that is the purpose of <code>Can_copy</code>).</p>\n", "LastActivityDate": "2011-02-21T23:53:57.787"}, "5072613": {"ParentId": "5072554", "CommentCount": "0", "CreationDate": "2011-02-21T23:52:57.957", "OwnerUserId": "276994", "PostTypeId": "2", "Id": "5072613", "Score": "2", "Body": "<p>The usage of the template is as simple as <code>Can_copy&lt;int, char&gt;();</code></p>\n<p>If an instance of T1 cannot be copied to an instance of T2, the code <code>b = a</code> wouldn't <em>compile</em> at all. The same way, if an instance of T2 cannot be initialized with the instance of T1, the code <code>T2 c = a;</code> wouldn't compile.</p>\n<p>So, if <code>T1</code> cannot be copied to <code>T2</code>, the line containing the template usage won't compile.</p>\n<p>The whole construct produces (almost) no code, and is easily removed by the optimizer.</p>\n", "LastActivityDate": "2011-02-21T23:52:57.957"}, "5072740": {"ParentId": "5072554", "CommentCount": "0", "CreationDate": "2011-02-22T00:14:05.890", "OwnerUserId": "511601", "PostTypeId": "2", "Id": "5072740", "Score": "4", "Body": "<p>C++03 \u00a714.7.1p1:</p>\n<blockquote>\n<p id=\"so_5072554_5072740_0\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3), the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program. The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, <strong>but not of the definitions</strong> or default arguments, of the class member functions, member classes, static data members and member templates; \u2026</p>\n</blockquote>\n<p>Thus, this code <em>cannot</em> instantiate Can_copy::constraints:</p>\n<pre><code>template&lt;class T1, class T2&gt;\nstruct Can_copy {\n  static void constraints(T1 a, T2 b) { T2 c = a; b = a; }\n  Can_copy() { /* note the change here */ }\n};\n\ntemplate&lt;class Container&gt;\nvoid draw_all(Container&amp; c) {\n  typedef typename Container::value_type T;\n  Can_copy&lt;T,Shape*&gt;(); // accept containers of only Shape*s\n}\n</code></pre>\n<p>But, in the original code, when Can_copy's ctor is instantiated, as it must be when it is used, its body (definition) is as well, and that triggers instantiation of Can_copy::constraints.</p>\n<p>You can see this same problem in reverse, where an explicit instantiation gives you everything, even something you don't want:</p>\n<pre><code>typedef std::list&lt;int&gt;::iterator Iter;\nstd::reverse_iterator&lt;Iter&gt; x;  // Implicit instantiation; works.\n\ntemplate std::reverse_iterator&lt;Iter&gt;;\n// Explicit instantiation; fails to instantiate op+ and other operators used\n// for random access iterators from reverse_iterator.\n</code></pre>\n", "LastActivityDate": "2011-02-22T00:14:05.890"}, "5072676": {"ParentId": "5072554", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Meant to be informative, not an answer (not deserving of an upvote):</p>\n<p>In C++0x you will have improved facilities for this in the header <code>&lt;type_traits&gt;</code>.</p>\n<pre><code>std::is_copy_constructible&lt;T1&gt;::value;\nstd::is_copy_assignable&lt;T1&gt;::value;\nstd::is_constructible&lt;T1, T2&gt;::value;\nstd::is_assignable&lt;T1, T2&gt;::value;\nstd::is_convertible&lt;T1, T2&gt;::value;\n</code></pre>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3225.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3225.pdf</a></p>\n<p>search for \"[meta]\".</p>\n", "OwnerUserId": "576911", "CommunityOwnedDate": "2011-02-22T02:12:01.673", "Id": "5072676", "Score": "3", "CreationDate": "2011-02-22T00:04:05.647", "LastActivityDate": "2011-02-22T00:04:05.647"}, "bq_ids": {"n4140": {"so_5072554_5072740_0": {"section_id": 233, "quality": 0.9259259259259259, "length": 50}}, "n3337": {"so_5072554_5072740_0": {"section_id": 226, "quality": 0.9259259259259259, "length": 50}}, "n4659": {"so_5072554_5072740_0": {"section_id": 242, "quality": 0.6481481481481481, "length": 35}}}});