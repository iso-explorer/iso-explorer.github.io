post_cb({"34313708": {"ParentId": "34313492", "CommentCount": "4", "Body": "<p>According to my read of C++11:</p>\n<blockquote>\n<p id=\"so_34313492_34313708_0\">const charT&amp; front() const;</p>\n<p id=\"so_34313492_34313708_1\">charT&amp; front();</p>\n<p id=\"so_34313492_34313708_2\">Requires: !empty()</p>\n<p id=\"so_34313492_34313708_3\">Effects: Equivalent to operator[](0).</p>\n</blockquote>\n<p>Let's look at operator[]:</p>\n<blockquote>\n<p id=\"so_34313492_34313708_4\">const_reference operator[](size_type pos) const;</p>\n<p id=\"so_34313492_34313708_5\">reference operator[](size_type pos);</p>\n<p id=\"so_34313492_34313708_6\">1 Requires: pos &lt;= size().</p>\n<p id=\"so_34313492_34313708_7\">2 Returns: *(begin() + pos) if pos &lt; size(), otherwise a reference to\n  an object of type T with valuecharT(); the referenced value shall not be modified.</p>\n</blockquote>\n<p>Since you preallocate your buffer, <code>pos</code> will be less than size(). begin() returns an iterator, so all the usual iterator traits apply.</p>\n<p>So, according to my interpretation of C++11, this approach should be legal.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "34313708", "Score": "3", "CreationDate": "2015-12-16T13:45:57.487", "LastActivityDate": "2015-12-16T13:45:57.487"}, "34313492": {"CommentCount": "7", "AcceptedAnswerId": "34313708", "ClosedDate": "2015-12-16T14:01:15.157", "CreationDate": "2015-12-16T13:36:16.520", "LastActivityDate": "2015-12-16T14:00:37.337", "PostTypeId": "1", "ViewCount": "218", "Title": "Using &front() to modify underlying character array in std::string", "Id": "34313492", "Score": "3", "Body": "<p>I have to interface with a C library in one of my programs, and I am writing a thin wrapper to use C++ types such as <code>std::string</code>. There are quite a number of functions that accept a <code>char*</code> and a maximum length as parameter and overwrite the memory pointed to by the <code>char*</code> with a zero-terminated C-string. Traditionally, I used a stack array and copied the data into a string manually. </p>\n<pre><code>std::string call_C_function(int x) {\n    char buf[MAX_LEN] = {0}; // MAX_LEN is defined by the library\n    size_t len = MAX_LEN;\n    C_function(x, buf, &amp;len);\n    return std::string(buf, len);\n}\n</code></pre>\n<p>I tried to avoid the copy and came up with a solution, but I don't know if this is strictly legal:</p>\n<pre><code>std::string call_C_function(int x) {\n    std::string buf(MAX_LEN, '\\0'); // MAX_LEN is defined by the library\n    size_t len = MAX_LEN;\n    C_function(x, &amp;buf.front(), &amp;len);\n    buf.resize(len);\n    return buf;\n}\n</code></pre>\n<p>This compiles and works, but I am having doubts because the <code>std::string</code> class makes it quite hard to get a non-const pointer to the character data. <code>c_str()</code> and <code>data()</code> both return const pointers. The standard forbids modifications of the buffer explicitly for these functions:</p>\n<blockquote>\n<p id=\"so_34313492_34313492_0\">21.4.7.1: The program shall not alter any of the values stored in the character array.</p>\n</blockquote>\n<p>From the documentation, it seems that this is legal because <code>front()</code> returns a reference to the first character of the buffer which must be continuous (I am using C++11/14). In 21.4.5, the semantics of <code>front()</code> is defined in terms of <code>operator[](0)</code> which does not forbid modifications.</p>\n<p>Are there any issues with this approach from a language standard point of view? It seems that this would be a loop-hole allowing the modification explicitly forbidden in 21.4.7.1.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2169853", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34313492_34313492_0": {"section_id": 1763, "quality": 0.7142857142857143, "length": 5}, "so_34313492_34313708_7": {"section_id": 1617, "quality": 0.6153846153846154, "length": 8}, "so_34313492_34313708_0": {"section_id": 1621, "quality": 1.0, "length": 4}}, "n3337": {"so_34313492_34313492_0": {"section_id": 1757, "quality": 0.7142857142857143, "length": 5}, "so_34313492_34313708_7": {"section_id": 1613, "quality": 0.6153846153846154, "length": 8}, "so_34313492_34313708_0": {"section_id": 1618, "quality": 1.0, "length": 4}}, "n4659": {"so_34313492_34313492_0": {"section_id": 1929, "quality": 0.7142857142857143, "length": 5}, "so_34313492_34313708_7": {"section_id": 1770, "quality": 0.6153846153846154, "length": 8}, "so_34313492_34313708_0": {"section_id": 1774, "quality": 1.0, "length": 4}}}, "34313815": {"ParentId": "34313492", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is fine. You aren't allowed to modify the string via a pointer returned from a <code>const</code> member function but that doesn't mean you aren't allowed to modify the string at all. You have a non-const string, so you can modify it. In principle it's no different to doing <code>s[0] = 'a'; s[1] = 'b';</code> etc.</p>\n<p>It is forbidden to overwrite the final <code>'\\0'</code> that is stored after the string data, but I assume from your example that <code>MAX_LEN</code> includes the space for the null terminator that is written by the C function, so the C function will only overwrite the string contents and not the extra character stored afterwards.</p>\n<p>There is an open issue (<a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2391\" rel=\"nofollow\">LWG 2391</a>) proposing to add a non-const <code>std::string::data()</code> which would be equivalent to <code>&amp;s.front()</code>, and would give you direct access without making you concerned about going against the intention of the library.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-12-16T14:00:37.337", "Id": "34313815", "Score": "4", "CreationDate": "2015-12-16T13:51:11.093", "LastActivityDate": "2015-12-16T14:00:37.337"}});