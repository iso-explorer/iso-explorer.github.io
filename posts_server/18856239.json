post_cb({"bq_ids": {"n4140": {"so_18856239_18856908_0": {"length": 16, "quality": 1.0, "section_id": 142}}, "n3337": {"so_18856239_18856908_0": {"length": 16, "quality": 1.0, "section_id": 136}}}, "18856908": {"PostTypeId": "2", "Body": "<p>The restrictions on partially specializing a class template on a non-type template argument 14.5.5 [temp.class.spec] paragraph 8 list the following restriction:</p>\n<blockquote>\n<p id=\"so_18856239_18856908_0\">A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple identifier.</p>\n</blockquote>\n<p>The argument expression using a <code>size_t</code> involves a conversion to <code>int</code> (<code>size_t</code> is unsigned) and is, thus, not a simple identifier.</p>\n", "LastActivityDate": "2013-09-17T18:17:10.850", "LastEditorUserId": "1120273", "Id": "18856908", "CommentCount": "2", "CreationDate": "2013-09-17T18:09:53.547", "ParentId": "18856239", "Score": "0", "OwnerUserId": "1120273", "LastEditDate": "2013-09-17T18:17:10.850"}, "18857327": {"PostTypeId": "2", "Body": "<p>Gcc is wrong, because you simply can't call this specialization.\nJust remove primary template definition:</p>\n<pre><code>template &lt;int I, typename T&gt;\nstruct foo;\n\ntemplate &lt;std::size_t Index&gt;\nstruct foo&lt;Index, int*&gt; {\n  static int bar() {\n    return 2;\n  }\n};\n\nint main() {\n  std::cout &lt;&lt; foo&lt;std::size_t(0), int*&gt;::bar() &lt;&lt; std::endl; // nope, not work\n  std::cout &lt;&lt; foo&lt;0, int*&gt;::bar() &lt;&lt; std::endl; // nope, not work\n}\n</code></pre>\n<p>See live <a href=\"http://coliru.stacked-crooked.com/a/c924da7e25661441\" rel=\"nofollow\">example</a>. And <a href=\"http://coliru.stacked-crooked.com/a/de61df0092b84e4e\" rel=\"nofollow\">this</a> code must report ambiguous partial specialization, but it's not (for gcc). Clang <a href=\"http://coliru.stacked-crooked.com/a/e696fb52983c4194\" rel=\"nofollow\">report</a> \"ambiguous\".</p>\n<p>PS I argee, that this part is not covered enough by standard.</p>\n<p><strong>update</strong></p>\n<p>clang in this situation won't work with <strong>enums</strong>, <a href=\"http://coliru.stacked-crooked.com/a/39dab7587e216eee\" rel=\"nofollow\">example</a>.</p>\n", "LastActivityDate": "2013-09-18T09:16:16.017", "LastEditorUserId": "2288008", "Id": "18857327", "CommentCount": "1", "CreationDate": "2013-09-17T18:32:51.547", "ParentId": "18856239", "Score": "2", "OwnerUserId": "2288008", "LastEditDate": "2013-09-18T09:16:16.017"}, "18856239": {"ViewCount": "397", "Body": "<p>I have found this piece of bogus code (contrived example below):</p>\n<pre><code>template &lt;int I, typename T&gt;\nstruct foo\n{\n    static int bar()\n    {\n        return 1;\n    }\n};\n\ntemplate &lt;std::size_t Index, typename T&gt;\nstruct foo&lt;Index, T*&gt;\n{\n    static int bar()\n    {\n        return 2;\n    }\n};\n</code></pre>\n<p>Please note that specialization uses different type (by mistake). Surprisingly it compiles without any errors (or warnings) with both GCC 4.8.1 and Clang 3.4. But what is even more strange for GCC line <code>foo&lt;0, int*&gt;::bar()</code> results in <code>1</code>, but Clang gives <code>2</code>. What is going on? Is it still considered as a specialization by the standard?</p>\n", "AcceptedAnswerId": "18857327", "Title": "Template specialization with type conversion", "CreationDate": "2013-09-17T17:31:19.313", "Id": "18856239", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-09-18T09:16:16.017", "Score": "14", "OwnerUserId": "2224212", "Tags": "<c++><templates><gcc><clang><template-specialization>", "AnswerCount": "2"}});