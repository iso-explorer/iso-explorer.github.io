post_cb({"40019058": {"ParentId": "40018076", "CommentCount": "2", "Body": "<p>Using <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf\" rel=\"nofollow\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf</a>\nI think g++ is wrong.</p>\n<p>8.6.4 clause 3.7 states:</p>\n<blockquote>\n<p id=\"so_40018076_40019058_0\">\u2014 Otherwise, if the initializer list has a single element of type E\n  and either T is not a reference type or its referenced type is\n  reference-related to E, the object or reference is initialized from\n  that element (by copy-initialization for copy-list-initialization, or\n  by direct-initialization for direct-list-initialization); if a\n  narrowing conversion (see below) is required to convert the element to\n  T, the program is ill-formed.</p>\n</blockquote>\n<p>Meaning that direct init is used in this case of non-class type, which leads us to 8.6 clause 17.7:</p>\n<blockquote>\n<p id=\"so_40018076_40019058_1\">\u2014 Otherwise, if the source type is a (possibly cv-qualified) class\n  type, conversion functions are considered. The applicable conversion\n  functions are enumerated (13.3.1.5), and the best one is chosen\n  through overload resolution (13.3). The user-defined conversion so\n  selected is called to convert the initializer expression into the\n  object being initialized. If the conversion cannot be done or is\n  ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>And finally 13.3.1.5 states that both explicit and implicit conversions are considered for direct initialization:</p>\n<blockquote>\n<p id=\"so_40018076_40019058_2\">\u2014 The conversion functions of S and its base classes are considered.\n  Those non-explicit conversion functions that are not hidden within S\n  and yield type T or a type that can be converted to type T via a\n  standard conversion sequence (13.3.3.1.1) are candidate functions. <strong>For\n  direct-initialization, those explicit conversion functions that are\n  not hidden within S and yield type T or a type that can be converted\n  to type T with a qualification conversion (4.5) are also candidate\n  functions</strong>. Conversion functions that return a cv-qualified type are\n  considered to yield the cv-unqualified version of that type for this\n  process of selecting candidate functions. Conversion functions that\n  return \u201creference to cv2 X\u201d return lvalues or xvalues, depending on\n  the type of reference, of type \u201ccv2 X\u201d and are therefore considered to\n  yield X for this process of selecting candidate functions.</p>\n</blockquote>\n", "OwnerUserId": "7013190", "PostTypeId": "2", "Id": "40019058", "Score": "4", "CreationDate": "2016-10-13T10:55:52.087", "LastActivityDate": "2016-10-13T10:55:52.087"}, "bq_ids": {"n4140": {"so_40018076_40019058_1": {"section_id": 3296, "quality": 0.9, "length": 36}, "so_40018076_40019058_0": {"section_id": 3325, "quality": 0.8620689655172413, "length": 25}, "so_40018076_40019058_2": {"section_id": 595, "quality": 0.9333333333333333, "length": 70}}, "n3337": {"so_40018076_40019058_1": {"section_id": 3166, "quality": 0.9, "length": 36}, "so_40018076_40019058_0": {"section_id": 3195, "quality": 0.6551724137931034, "length": 19}, "so_40018076_40019058_2": {"section_id": 585, "quality": 0.9333333333333333, "length": 70}}, "n4659": {"so_40018076_40019058_1": {"section_id": 4058, "quality": 0.9, "length": 36}, "so_40018076_40019058_0": {"section_id": 4091, "quality": 1.0, "length": 29}, "so_40018076_40019058_2": {"section_id": 618, "quality": 0.9333333333333333, "length": 70}}}, "40018076": {"CommentCount": "2", "AcceptedAnswerId": "40019058", "CreationDate": "2016-10-13T10:07:56.657", "LastActivityDate": "2016-10-14T04:47:20.080", "PostTypeId": "1", "ViewCount": "269", "FavoriteCount": "1", "Title": "`auto x = type{...}` initialization syntax and `explicit` conversion operator - clang vs gcc", "Id": "40018076", "Score": "12", "Body": "<p>Given this code <em>(on <a href=\"http://melpon.org/wandbox/permlink/ZfUaA2LqTNRpuBTp\">wandbox</a>)</em>:</p>\n<pre><code>struct X\n{\n    explicit operator int() { return 0; }\n};\n\nint main()\n{\n    auto y = int{X{}};\n}\n</code></pre>\n<p>And the following compiler options:</p>\n<blockquote>\n<p id=\"so_40018076_40018076_0\">-std=c++1z -Wall -Wextra -Wpedantic</p>\n</blockquote>\n<hr>\n<ul>\n<li><p><code>g++</code> <em>(tested versions: 7, 6.1, 5.3)</em> <strong>refuses to compile the code</strong> with the following error</p>\n<blockquote>\n<p id=\"so_40018076_40018076_1\">error: cannot convert 'X' to 'int' in initialization</p>\n</blockquote></li>\n<li><p><code>clang++</code> <em>(tested versions: 4, 3.8, 3.6)</em> <strong>happily compiles the snippet</strong>.</p></li>\n</ul>\n<hr>\n<p><strong>Which compiler is doing the correct thing here?</strong></p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\">cppreference</a> seems to suggest that the <code>auto var = type{...}</code> syntax should trigger an explicit conversion.</p>\n</hr></hr>", "Tags": "<c++><type-conversion><language-lawyer><c++1z><explicit>", "OwnerUserId": "598696", "AnswerCount": "1"}});