post_cb({"1396786": {"Id": "1396786", "PostTypeId": "2", "Body": "<p>Do a google on \"c++ koenig lookup\"</p>\n<p>That should give you enough information on the template lookup rules.</p>\n<p>Herb Sutter has a good article on the subject:<br>\n<a href=\"http://www.gotw.ca/gotw/030.htm\" rel=\"nofollow noreferrer\">http://www.gotw.ca/gotw/030.htm</a></br></p>\n", "LastActivityDate": "2009-09-08T23:02:28.450", "Score": "2", "CreationDate": "2009-09-08T23:02:28.450", "ParentId": "1396458", "CommentCount": "2", "OwnerUserId": "14065"}, "1396611": {"Id": "1396611", "PostTypeId": "2", "Body": "<p>The following code compiles fine for me using VS 2005 Professional Edition:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing std::cout;\n\n\ntypedef std::vector&lt;int&gt; Vec;\n\nnamespace name {\n    template &lt;typename T&gt;\n    void foo(const T&amp; t) {\n        bar(t);\n    }\n\n    template &lt;typename T&gt;\n    void bar(const T&amp; t) {\n        baz(t);\n    }\n\n    void baz(int) {\n        std::cout &lt;&lt; \"baz(int)\\n\";\n    }   \n\n    void bar(const Vec&amp;) {\n        std::cout &lt;&lt; \"bar(const Vec&amp;)\\n\";\n    }\n}\n\n\nint main()\n{\n    name::foo(Vec());\n    return 0;\n}\n</code></pre>\n<p>Please post your original code so that we can find out what's wrong.</p>\n", "LastActivityDate": "2009-09-08T22:11:55.840", "Score": "-1", "CreationDate": "2009-09-08T22:11:55.840", "ParentId": "1396458", "CommentCount": "1", "OwnerUserId": "75889"}, "bq_ids": {"n4140": {"so_1396458_1402325_0": {"length": 6, "quality": 1.0, "section_id": 224}}, "n3337": {"so_1396458_1402325_0": {"length": 6, "quality": 1.0, "section_id": 217}}, "n4659": {"so_1396458_1402325_0": {"length": 6, "quality": 1.0, "section_id": 232}}}, "1396622": {"Id": "1396622", "PostTypeId": "2", "Body": "<p>I can confirm the behaviour you are seeing on my system and I believe it's correct.</p>\n<p>Looks like the overload resolution is just looking in the namespaces of it's arguments so the version of <code>bar</code> that takes a <code>test</code> works because <code>test</code> is in the global namespace and so the compiler checks there for a version of <code>bar</code> which , as you rightly pointed out, is prioritised over the templated version.</p>\n<p>For the <code>Vec</code> version the important namespace is <code>std</code>. If you put a version of <code>bar</code> in <code>std</code> you'll find it picks it up.</p>\n<p>The <code>double</code> version doesn't work because the global namespace is not used for the lookup since <code>double</code> is a built-in type and not specially associated with the global namespace in any way.</p>\n", "LastActivityDate": "2009-09-08T22:14:28.643", "Score": "2", "CreationDate": "2009-09-08T22:14:28.643", "ParentId": "1396458", "CommentCount": "5", "OwnerUserId": "74465"}, "1397275": {"Id": "1397275", "PostTypeId": "2", "Body": "<p>The rule for looking up name is that if the name is unqualified, the parameter's namespace will be used to search for the function.</p>\n<p><code>name::foo(test());</code> works because in <code>foo</code> you have call <code>bar(test());</code> basically and test's namespace is used for searching bar. In this case, global namespace.</p>\n<p><code>name::foo(Vec());</code> this wont work as Vec is a typedef not a class or struct.</p>\n<p>See C++ standard for function name lookup rules.</p>\n", "LastActivityDate": "2009-09-09T02:28:12.213", "Score": "0", "CreationDate": "2009-09-09T02:28:12.213", "ParentId": "1396458", "CommentCount": "1", "OwnerUserId": "45262"}, "1396592": {"Id": "1396592", "PostTypeId": "2", "Body": "<p>The following program works fine for me on gcc 4.3 and gcc 4.1 (the only two compilers I have on hand:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nnamespace name {\n   template &lt;typename T&gt;\n   void foo(const T&amp; t) {\n      bar(t);\n   }\n\n   template &lt;typename T&gt;\n   void bar(const T&amp; t) {\n      baz(t);\n   }\n\n   void baz(int) {\n      std::cout &lt;&lt; \"baz(int)\\n\";\n   }\n\n   struct test {};\n    void bar(const test&amp;) {\n       std::cout &lt;&lt; \"bar(const test&amp;)\\n\";\n    }\n\n    void bar(const double&amp;) {\n       std::cout &lt;&lt; \"bar(const double&amp;)\\n\";\n    }\n\n    typedef std::vector&lt;int&gt; Vec;\n    void bar(const Vec&amp;) {\n       std::cout &lt;&lt; \"bar(const Vec&amp;)\\n\";\n    }\n}\n\nint main()\n{\n    name::foo(name::test());\n    name::foo(5.0);\n    name::foo(name::Vec());\n}\n</code></pre>\n<p>Producing:</p>\n<blockquote>\n<p id=\"so_1396458_1396592_0\">bar(const test&amp;)<br>\n  bar(const double&amp;)<br>\n  bar(const Vec&amp;)</br></br></p>\n</blockquote>\n<p>What compiler are you using?</p>\n", "LastActivityDate": "2009-09-08T22:07:48.750", "Score": "-1", "CreationDate": "2009-09-08T22:07:48.750", "ParentId": "1396458", "CommentCount": "2", "OwnerUserId": "5963"}, "1402325": {"Id": "1402325", "PostTypeId": "2", "Body": "<p>I assume you added the <code>double</code> version to the global namespace too, and you call <code>foo</code> from main after everything is defined. So this is basically two phase name lookup. Looking up an unqualified function name that is dependent because an argument in the call is dependent (on its type) is done in  two phases. </p>\n<p>The first phase does a unqualified and argument dependent lookup in the definition context. It then freezes the result, and using the instantiation context (the sum of the declarations at the point of instantiation) does a second argument dependent lookup <em>only</em>. <em>No</em> unqualified lookup is done anymore. So for your example it means:</p>\n<ul>\n<li><p>The call <code>bar(t)</code> within <code>foo&lt;test&gt;</code> looks up <code>bar</code> using argument dependent lookup at the instantiation context (it doesn't find it using unqualified lookup, because <code>foo</code> is declared <code>above</code> the bar template). Depending on whether you define the global <code>bar</code> before or after the <code>foo</code> template, it will find the global <code>bar</code> declaration using argument dependent lookup already in the first phase (it's defined in <code>test</code>'s namespace). Then the call in main will instantiate <code>foo&lt;test&gt;</code> and it will possible find <code>bar</code> in this phase (if you declared it after you declared the template). </p></li>\n<li><p>The call <code>bar(t)</code> within <code>foo&lt;int&gt;</code> doesn't do argument dependent lookup (or rather, the result for the lookup is an empty declaration set), because <code>int</code> is a fundamental type. So, unqualified lookup at the definition context will find nothing either, because the matching <code>bar</code> template is declared <code>after</code> the <code>foo</code> template. The call would be ill-formed, and the standard says about this situation at <code>14.6.4.2/1</code></p>\n<blockquote>\n<p id=\"so_1396458_1402325_0\">If the call would be ill-formed [...] then the program has undefined behavior.</p>\n</blockquote>\n<p>You should therefor consider this as a \"i did a dirty thing and the compiler chose not to slap me\" case, i think :)</p></li>\n<li><p>The call <code>bar(t)</code> within <code>foo&lt;Vec&gt;</code> will do the lookups again, and will look for bar in <code>std::</code> (because that's where <code>std::vector</code> is defined). It doesn't find a <code>bar</code> there, neither in the definition context. So it decides to go by undefined behavior again, and uses the <code>bar</code> template, and which in itself again does undefined behavior by using the <code>baz</code> declared after it and which cannot be found by neither ADL nor unqualified lookup from the definition context. </p>\n<p>If the vector were a <code>vector&lt;test&gt;</code>, then lookup for <code>bar</code> would be done at global scope too, because argument dependent lookup will not only use the argument type directly, but also the type of the template arguments in them, if there are any. </p></li>\n</ul>\n<hr>\n<p>If you use GCC, then don't rely entirely on its behavior. In the following code, it claims the call is ambiguous, although the code is perfectly fine - the <code>f</code> in <code>afake</code> should not be a candidate. </p>\n<pre><code>namespace aname {\n  struct A { };\n  void f(A) { }\n}\n\nnamespace afake {\n  template&lt;typename T&gt;\n  void g(T t) { f(t); }\n  void f(aname::A) { }\n}\n\nint main() { aname::A a; afake::g(a); }\n</code></pre>\n<p>If you want to test your snippets against conformance, best use the <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow noreferrer\">comeau online compiler</a> with the strict settings. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-09-09T22:57:59.003", "Score": "8", "CreationDate": "2009-09-09T21:50:13.600", "ParentId": "1396458", "CommentCount": "2", "LastEditDate": "2009-09-09T22:57:59.003", "OwnerUserId": "34509"}, "1396458": {"ViewCount": "896", "Body": "<p>Starting with the following (using <code>gcc version 4.0.1</code>):</p>\n<pre><code>namespace name {\n   template &lt;typename T&gt;\n   void foo(const T&amp; t) {\n      bar(t);\n   }\n\n   template &lt;typename T&gt;\n   void bar(const T&amp; t) {\n      baz(t);\n   }\n\n   void baz(int) {\n      std::cout &lt;&lt; \"baz(int)\\n\";\n   }\n}\n</code></pre>\n<p>If I add (in the <em>global</em> namespace)</p>\n<pre><code>struct test {};\nvoid bar(const test&amp;) {\n   std::cout &lt;&lt; \"bar(const test&amp;)\\n\";\n}\n</code></pre>\n<p>then, as I expected,</p>\n<pre><code>name::foo(test()); // produces \"bar(const test&amp;)\"\n</code></pre>\n<p>But if I just add</p>\n<pre><code>void bar(const double&amp;) {\n   std::cout &lt;&lt; \"bar(const double&amp;)\\n\";\n}\n</code></pre>\n<p>it can't seem to find this overload:</p>\n<pre><code>name::foo(5.0) // produces \"baz(int)\"\n</code></pre>\n<p>What's more,</p>\n<pre><code>typedef std::vector&lt;int&gt; Vec;\nvoid bar(const Vec&amp;) {\n   std::cout &lt;&lt; \"bar(const Vec&amp;)\\n\";\n}\n</code></pre>\n<p>doesn't appear either, so</p>\n<pre><code>name::foo(Vec());\n</code></pre>\n<p>gives a compiler error</p>\n<pre><code>error: cannot convert \u2018const std::vector&lt;int, std::allocator&lt;int&gt; &gt;\u2019 to \u2018int\u2019 for argument \u20181\u2019 to \u2018void name::baz(int)\u2019\n</code></pre>\n<p>Is this how the lookup is supposed to work? (Note: if I remove the namespace <code>name</code>, then everything works as I expected.)</p>\n<p>How can I modify this example so that any overload for <code>bar</code> is considered? (I thought that overloads were supposed to be considered <em>before</em> templates?)</p>\n", "AcceptedAnswerId": "1402325", "Title": "Confusing function lookup with templates in C++", "CreationDate": "2009-09-08T21:37:11.243", "Id": "1396458", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2009-09-08T23:03:30.913", "LastEditorUserId": "112", "LastActivityDate": "2009-09-09T22:57:59.003", "Score": "3", "OwnerUserId": "112", "Tags": "<c++><templates><lookup>", "AnswerCount": "6"}});