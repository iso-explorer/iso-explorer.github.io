post_cb({"bq_ids": {"n4140": {"so_13625774_13626075_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_13625774_13626075_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_13625774_13626075_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "13626075": {"Id": "13626075", "PostTypeId": "2", "Body": "<p>Being trivial has nothing to do with how you can initialize something. The important bit is whether your <code>Derived</code> type is an <em>aggregate</em>, which is not the case:</p>\n<p><code>\u00a78.5.1 [dcl.init.aggr] p1</code></p>\n<blockquote>\n<p id=\"so_13625774_13626075_0\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no <em>brace-or-equal-initializers</em> for non-static data members (9.2), no private or protected non-static data members (Clause 11), <strong>no base classes (Clause 10)</strong>, and no virtual functions (10.3).</p>\n</blockquote>\n<p>Only aggregates can be initialized with aggregate initialization, so list-initialization (which is the official name for uniform initialization) can only try looking for a fitting constructor.</p>\n<p>What you can do is provide a <code>constexpr</code> constructor that forwards to the base-class, and add a <code>default</code>ed default constructor:</p>\n<pre><code>struct Derived : Base{\n    Derived() = default;\n    constexpr Derived(int a, int b, int c) : Base{a, b, c}{}\n};\n</code></pre>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-11-29T13:00:53.897", "Score": "11", "CreationDate": "2012-11-29T12:41:37.400", "ParentId": "13625774", "CommentCount": "11", "OwnerUserId": "500104", "LastEditDate": "2012-11-29T13:00:53.897"}, "13625774": {"ViewCount": "1041", "Body": "<p>I'm trying to wrap my head around some corner cases with c++11 uniform initialization and I can't figure out why is this:</p>\n<pre><code>struct Base\n{\n    int x,y,z;\n};\n\nstruct Derived : Base\n{\n};\nstatic_assert (std::is_trivial&lt;Base&gt;::value, \"Base must be trivial\");\nstatic_assert (std::is_trivial&lt;Derived&gt;::value, \"Derived must be trivial\");\n\nBase b{1, 2, 3};           // 1) This compiles fine\nDerived d{10, 20, 30};     // 2) This fails\n</code></pre>\n<p>Line marked <strong>2</strong> fails with a <strong>\"no matching constructor for initialization of Derived\"</strong> message both with <code>clang 3.1</code> and <code>g++ 4.7</code>.</p>\n<p>I can't understand why, in case of Derived, it is trying to call a constructor and not performing (I don't know how to call it, maybe <strong>aggregate initialization</strong>?) as is the case for line 1).</p>\n<p>Something in the following reasoning is wrong?:</p>\n<p>A) Being trivial guarantees it can be statically initialized</p>\n<p>B) To be statically initialized no code must be executed at runtime and hence no constructor call is required\n<code>A+B</code> =&gt; why is it trying to call a constructor on a type that it knows being trivial?</p>\n<p>I'm very confused....</p>\n", "AcceptedAnswerId": "13626075", "Title": "Uniform initialization of derived class with trivial ctor", "CreationDate": "2012-11-29T12:23:48.337", "Id": "13625774", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-11-29T12:41:56.387", "LastEditorUserId": "500104", "LastActivityDate": "2012-11-29T13:00:53.897", "Score": "8", "OwnerUserId": "41789", "Tags": "<c++><inheritance><c++11><uniform-initialization><list-initialization>", "AnswerCount": "1"}});