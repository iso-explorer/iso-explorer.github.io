post_cb({"1338419": {"ParentId": "1338403", "CommentCount": "4", "Body": "<p>Simply create <code>m_mutex</code> outside of <code>GetResource(),</code> before it can ever be called - this removes the critical section around the actual creation of the mutex.</p>\n<pre><code>MyClass::Init()\n{\n  m_mutex = new Mutex;\n}    \n\nMyClass::GetResource()\n{\n  m_mutex-&gt;Lock();\n  ...\n  m_mutex-&gt;Unlock();\n}\n</code></pre>\n", "OwnerUserId": "94239", "PostTypeId": "2", "Id": "1338419", "Score": "12", "CreationDate": "2009-08-27T01:30:46.577", "LastActivityDate": "2009-08-27T01:30:46.577"}, "1338403": {"CommentCount": "5", "ViewCount": "1038", "PostTypeId": "1", "LastEditorUserId": "2134", "CreationDate": "2009-08-27T01:23:59.673", "LastActivityDate": "2014-02-20T12:19:28.743", "Title": "How do I make sure there is only 1 mutex?", "LastEditDate": "2009-08-27T02:01:53.713", "Id": "1338403", "Score": "2", "Body": "<p>I am running some thread safe code here. I am using a mutex to protect the section of code that needs to be run only by only 1 thread at a time. The problem I have is using this code sometimes I end up with 2 Mutex objects. This is a static function by the way. How do I make sure only 1 mutex object gets created??</p>\n<pre><code>/*static*/ MyClass::GetResource()\n{\n\nif (m_mutex == 0)\n{\n// make a new mutex object\nm_mutex = new MyMutex();\n}\n\nm_mutex-&gt;Lock();\n</code></pre>\n", "Tags": "<c++><static><synchronization><mutex>", "OwnerUserId": "64758", "AnswerCount": "5"}, "1338429": {"ParentId": "1338403", "CommentCount": "0", "Body": "<p>Why use a pointer anyway? Why not replace the pointer with an actual instance that does not require dynamic memory management? This avoids the race condition, and does not impose a performance hit on every call into the function.</p>\n", "OwnerUserId": "3146", "PostTypeId": "2", "Id": "1338429", "Score": "2", "CreationDate": "2009-08-27T01:35:28.040", "LastActivityDate": "2009-08-27T01:35:28.040"}, "1338457": {"ParentId": "1338403", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Lazy mutex initialization isn't really appropriate for static methods; you need some guarantee that nobody races to the initialization. The following uses the compiler to generate a single static mutex for the class.</p>\n<pre><code>/* Header (.hxx) */\nclass MyClass\n{\n    ...\n\n  private:\n    static mutable MyMutex m_mutex;  // Declares, \"this mutex exists, somewhere.\"\n};\n\n\n/* Compilation Unit (.cxx) */\nMyMutex MyClass::m_mutex;            // The aforementioned, \"somewhere.\"\n\nMyClass::GetResource()\n{\n    m_mutex.Lock();\n    ...\n    m_mutex.Unlock();\n}\n</code></pre>\n<p>Some other solutions will require extra assumptions of your fellow programmers. With the \"call init()\" method, for instance, you have to be <em>sure</em> that the initialization method were called, and everybody would have to know this rule.</p>\n", "OwnerUserId": "1288364", "LastEditorUserId": "1288364", "LastEditDate": "2009-08-27T01:53:08.947", "Id": "1338457", "Score": "3", "CreationDate": "2009-08-27T01:45:59.793", "LastActivityDate": "2009-08-27T01:53:08.947"}, "21907389": {"ParentId": "1338403", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since it is only to protect one specific section of code, simply declare it static inside the function.</p>\n<pre><code>static MyClass::GetResource()\n{\n    static MyMutex mutex;\n\n    mutex.Lock();\n    // ...\n    mutex.Unlock();\n</code></pre>\n<p>The variable is a local variable with static storage duration. It is explicitly stated in the Standard:</p>\n<blockquote>\n<p id=\"so_1338403_21907389_0\">An implementation is permitted to perform early initialization of other block-scope variables with static or\n  thread storage duration under the same conditions that an implementation is permitted to statically initialize\n  a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is\n  initialized the first time control passes through its declaration; such a variable is considered initialized upon\n  the completion of its initialization. If the initialization exits by throwing an exception, the initialization\n  is not complete, so it will be tried again the next time control enters the declaration. If control enters\n  the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for\n  completion of the initialization.</p>\n</blockquote>\n<p>The last sentence is of particular interest to you.</p>\n", "OwnerUserId": "2071258", "LastEditorUserId": "2071258", "LastEditDate": "2014-02-20T12:19:28.743", "Id": "21907389", "Score": "0", "CreationDate": "2014-02-20T12:09:35.920", "LastActivityDate": "2014-02-20T12:19:28.743"}, "1338410": {"ParentId": "1338403", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The issue is the thread could be interrupted after checking if m_mutex is 0, but not before it creates the mutex, allowing another thread to run through the same code.</p>\n<p>Don't assign to m_mutex right away.  Create a new mutex, and then do an atomic compare exchange.</p>\n<p>You don't mention your target platform, but on Windows:</p>\n<pre><code>MyClass::GetResource()\n{\n    if (m_mutex == 0)\n    {\n        // make a new mutex object\n        MyMutex* mutex = new MyMutex();\n\n        // Only set if mutex is still NULL.\n        if (InterlockedCompareExchangePointer(&amp;m_mutex, mutex, 0) != 0)\n        {\n           // someone else beat us to it.\n           delete mutex;\n        }\n    }\n    m_mutex-&gt;Lock();\n</code></pre>\n<p>Otherwise, replace with whatever compare/swap function your platform provides.</p>\n<p>Another option is to use <a href=\"http://msdn.microsoft.com/en-us/library/aa363808(VS.85).aspx\" rel=\"nofollow noreferrer\">one-time initialization</a> support, which is available on Windows Vista and up, or just pre-create the mutex if you can.</p>\n", "OwnerUserId": "67132", "LastEditorUserId": "67132", "LastEditDate": "2009-08-27T17:59:36.750", "Id": "1338410", "Score": "8", "CreationDate": "2009-08-27T01:27:22.260", "LastActivityDate": "2009-08-27T17:59:36.750"}, "bq_ids": {"n4140": {"so_1338403_21907389_0": {"section_id": 3919, "quality": 0.9861111111111112, "length": 71}}, "n3337": {"so_1338403_21907389_0": {"section_id": 3779, "quality": 0.9861111111111112, "length": 71}}, "n4659": {"so_1338403_21907389_0": {"section_id": 4805, "quality": 0.6805555555555556, "length": 49}}}});