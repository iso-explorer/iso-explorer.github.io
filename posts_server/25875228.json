post_cb({"bq_ids": {"n4140": {"so_25875228_25875340_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5368}, "so_25875228_25875313_0": {"length": 36, "quality": 1.0, "section_id": 6090}, "so_25875228_25875313_1": {"length": 9, "quality": 0.9, "section_id": 413}}, "n3337": {"so_25875228_25875340_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5164}, "so_25875228_25875313_0": {"length": 36, "quality": 1.0, "section_id": 5858}, "so_25875228_25875313_1": {"length": 9, "quality": 0.9, "section_id": 404}}, "n4659": {"so_25875228_25875340_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 6793}, "so_25875228_25875313_0": {"length": 36, "quality": 1.0, "section_id": 7586}, "so_25875228_25875313_1": {"length": 9, "quality": 0.9, "section_id": 431}}}, "25875228": {"ViewCount": "185", "Body": "<p>Why overloaded new operator is implicitly static and how we are able to allocate memory by calling overloaded new operator without scope resolution operator?</p>\n<p>In my view if something is static then we can call it in main by through class name. </p>\n<pre><code>class xyz\n{\n    void* operator new (size_t size); //implicitly declared static\n    void operator delete (void *p); //implicitly declared static\n};\n\nint main()\n{\n    C *p = new C;\n    delete p;\n}\n</code></pre>\n", "Title": "Why overloaded new operator is implicitly static and no scope resolution required to construct the object", "CreationDate": "2014-09-16T17:41:17.243", "LastActivityDate": "2014-09-17T11:57:26.157", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-09-16T18:36:32.267", "LastEditorUserId": "1708801", "Id": "25875228", "Score": "7", "OwnerUserId": "3990393", "Tags": "<c++><new-operator>", "AnswerCount": "2"}, "25875313": {"Id": "25875313", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> says in section <code>5.3.4</code> <em>New</em> paragraph <em>9</em> that if the <em>new expression</em> does not begin with <code>::</code> then it is looked up in the scope of they type first and then if not found globally:</p>\n<blockquote>\n<p id=\"so_25875228_25875313_0\">If the new-expression begins with a unary :: operator, the allocation\n  function\u2019s name is looked up in the global scope. Otherwise, if the\n  allocated type is a class type T or array thereof, the allocation\n  function\u2019s name is looked up in the scope of T. If this lookup fails\n  to find the name, or if the allocated type is not a class type, the\n  allocation function\u2019s name is looked up in the global scope</p>\n</blockquote>\n<p>As to why it is implicitly static, it seems like it would be inconvenient restriction to require an instance of the type in order to invoke the member allocation function. It seems like would also require different syntax since how would the compiler know which instance to use which would make things messy.</p>\n<p>The fact that member allocation functions are implicitly static is covered in section <code>12.5</code> <em>Free store</em>:</p>\n<blockquote>\n<p id=\"so_25875228_25875313_1\">Any allocation function for a class T is a static member (even if not\n  explicitly declared static).</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-17T11:57:26.157", "Score": "5", "CreationDate": "2014-09-16T17:46:07.417", "ParentId": "25875228", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-09-17T11:57:26.157"}, "25875340": {"Id": "25875340", "PostTypeId": "2", "Body": "<p>All the operators are implicit. You don't have to use the scope operator for all the other operators either.  </p>\n<p>Think of how annoying it would be:</p>\n<pre><code>int a = 4 int::operator* 6;\n</code></pre>\n<p>And this is exactly the reason they made it this way.</p>\n<p>And besides that, all the operators are parsed in the lexical processing of the code. The meaning of those literals can be user defined:</p>\n<p>Section 2.14.8 discusses the literal rules:</p>\n<blockquote>\n<p id=\"so_25875228_25875340_0\">A user-defined-literal is treated as a call to a literal operator or\n  literal operator template (13.5.8). To determine the form of this call\n  for a given user-defined-literal L with ud-suffix X, the\n  literal-operator-id whose literal suffix identifier is X is looked up\n  in the context of L using the rules for unqualified name lookup\n  (3.4.1). Let S be the set of declarations found by this lookup. S\n  shall not be empty.</p>\n</blockquote>\n", "LastEditorUserId": "536086", "LastActivityDate": "2014-09-16T17:54:56.150", "Score": "1", "CreationDate": "2014-09-16T17:47:58.977", "ParentId": "25875228", "CommentCount": "0", "OwnerUserId": "536086", "LastEditDate": "2014-09-16T17:54:56.150"}});