post_cb({"bq_ids": {"n4140": {"so_28091889_28092512_1": {"length": 48, "quality": 0.9056603773584906, "section_id": 477}}, "n3337": {"so_28091889_28092512_1": {"length": 48, "quality": 0.9056603773584906, "section_id": 468}}, "n4659": {"so_28091889_28092512_1": {"length": 48, "quality": 0.9056603773584906, "section_id": 500}}}, "28092512": {"Id": "28092512", "PostTypeId": "2", "Body": "<p>I think this is why... Struct is a class object and there is this special rule for assignment of member its an array, not for an array itself (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">c++14 draft</a>):</p>\n<blockquote>\n<p id=\"so_28091889_28092512_0\"><strong>12.8 Copying and moving class objects</strong></p>\n<p id=\"so_28091889_28092512_1\">12.8.28. The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-\n  /move assignment of its subobjects. The direct base classes of X are assigned first, in the order of their\n  declaration in the base-specifier-list, and then the immediate non-static data members of X are assigned, in\n  the order in which they were declared in the class definition. Let x be either the parameter of the function\n  or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner\n  appropriate to its type:</p>\n<ol start=\"2\">\n<li>\u2014 if the subobject is an array, each element is assigned, in the manner appropriate to the element type;</li>\n</ol>\n</blockquote>\n<p>So the copy procedure is not defined for an array (because it's an unmodifiable variable type), but for a member type that is an array. There is no definition for implicit <code>operator=</code> for an array.</p>\n", "LastActivityDate": "2015-01-22T15:27:10.007", "CommentCount": "0", "CreationDate": "2015-01-22T15:27:10.007", "ParentId": "28091889", "Score": "1", "OwnerUserId": "1133179"}, "28091889": {"ViewCount": "99", "Body": "<p>What is the difference between the two array assignments, one inside a struct and one outside a struct?</p>\n<pre><code>struct A\n{\n   char s[4];\n};\n\nint main(int argc, char *argv[])\n{\n   char s[4];\n   char d[4];\n\n   d = s; // 'invalid array assignment'\n\n   A a, b;\n   b = a; // compiles without problems\n\n   return 0;\n}\n</code></pre>\n<p>The default operator <code>=</code> is supposed to invoke member-by-member assignment operators. If so, then there should exist an array assignment operator, but the compiler does not want to invoke it explicitly. Why?</p>\n", "Title": "Indirect array assignment works, while direct array assignment does not", "CreationDate": "2015-01-22T15:00:22.020", "Id": "28091889", "CommentCount": "3", "LastEditDate": "2015-01-22T15:13:38.123", "PostTypeId": "1", "LastEditorUserId": "1666510", "LastActivityDate": "2015-01-22T15:27:10.007", "Tags": "<c++><arrays><variable-assignment>", "Score": "0", "OwnerUserId": "1254395", "ClosedDate": "2015-01-23T18:54:20.250", "AnswerCount": "2"}, "28092097": {"Id": "28092097", "PostTypeId": "2", "Body": "<p>The value of an array name (e.g., <code>s</code>) is the starting address of the array. Once the array is allocated in memory, that address should be fixed. <code>d = s</code> is saying to assign the starting address of <code>s[4]</code> to <code>d[4]</code>, which obviously can't be done.</p>\n<p>A simple structure like yours is just a chuck of bits. In your case, an instance of <code>A</code> occupies 4 bytes. When you do <code>a = b</code>, it copies the bits of <code>b</code> to that of <code>a</code>.</p>\n<p>To illustrate the difference, I don't think you can do <code>a.s = b.s</code>. You can try.</p>\n", "LastActivityDate": "2015-01-22T15:08:57.667", "CommentCount": "0", "CreationDate": "2015-01-22T15:08:57.667", "ParentId": "28091889", "Score": "-2", "OwnerUserId": "3721062"}});