post_cb({"27133116": {"Id": "27133116", "PostTypeId": "2", "Body": "<p>If the pointer was initialised to <code>nullptr</code>, then deleting it would be safe. </p>\n<p>As it stands, <code>myptr</code> is not initialised and attempting to delete it's value will likely cause a segmentation fault.</p>\n<p><code>char* myptr = nullptr</code> Will solve this issue in c++11 or later, or use <code>0</code> or <code>NULL</code> for c++98 or earlier.</p>\n", "LastActivityDate": "2014-11-25T17:34:30.780", "CommentCount": "0", "CreationDate": "2014-11-25T17:34:30.780", "ParentId": "27133056", "Score": "3", "OwnerUserId": "1090266"}, "27133124": {"Id": "27133124", "PostTypeId": "2", "Body": "<p>It's <strong>undefined behavior</strong>. The pointer <strong>must</strong> come from <code>new</code> or must be a null pointer.</p>\n<p>Standard (N3797) 5.3.5<code>[expr.delete]</code>/2</p>\n<blockquote>\n<p id=\"so_27133056_27133124_0\">If the operand has a class type, the operand is converted to a pointer\n  type by calling the above-mentioned conversion function, and the\n  converted operand is used in place of the original operand for the\n  remainder of this section. <strong>In the first alternative (delete object),\n  the value of the operand of delete may be a null pointer value, a\n  pointer to a non-array object created by a previous new-expression, or\n  a pointer to a subobject (1.8) representing a base class of such an\n  object (Clause 10). If not, the behavior is undefined.<br>\n  [...]</br></strong></p>\n</blockquote>\n<p>The part left out at the bottom is the same for <code>delete []</code>. </p>\n<p>Deleting is only valid for </p>\n<ul>\n<li>null pointers</li>\n<li>pointers you got from new</li>\n<li>or a base class pointer pointing to the above.</li>\n</ul>\n<hr>\n<h2>Null pointers:</h2>\n<p>To follow up on null pointers, calling <code>delete</code> on a null pointer is a noop and the pointer is still a null pointer afterwards (no need to reassign <code>nullptr</code> to it). This is guaranteed at least for the standard <code>delete</code> and deallocation functions. If you define custom ones you should also handle this properly.</p>\n<p>Standard 5.3.5 <code>[expr.delete]</code>/7</p>\n<blockquote>\n<p id=\"so_27133056_27133124_1\">If the value of the operand of the delete-expression is not a null pointer value, then:</p>\n<ul>\n<li><strong>[...]</strong></li>\n</ul>\n<p id=\"so_27133056_27133124_2\"><strong>Otherwise, it is unspecified whether the deallocation function will be called.</strong> [ Note: The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an\n  exception. \u2014 end note ]</p>\n</blockquote>\n<p>So <code>delete</code> might do nothing at all or might call the deallocation function with the null pointer. Lets look at that function next:</p>\n<p>Standard 3.7.4.2 <code>[basic.stc.dynamic.deallocation]</code>/3</p>\n<blockquote>\n<p id=\"so_27133056_27133124_3\">If a deallocation function terminates by throwing an exception, the behavior is undefined. <strong>The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.<br>\n  [...]</br></strong></p>\n</blockquote>\n<p>It is explicitly mentioned that it got no effect.</p>\n<p><strong>Note:</strong> If you define your own custom deallocation functions you should make sure you handle it the same way. Not handling null pointers properly would be evil.</p>\n</hr>", "LastEditorUserId": "1942027", "LastActivityDate": "2014-11-27T07:20:44.323", "Score": "11", "CreationDate": "2014-11-25T17:35:08.607", "ParentId": "27133056", "CommentCount": "2", "OwnerUserId": "1942027", "LastEditDate": "2014-11-27T07:20:44.323"}, "bq_ids": {"n4140": {"so_27133056_27133124_1": {"length": 7, "quality": 1.0, "section_id": 6111}, "so_27133056_27133124_0": {"length": 45, "quality": 1.0, "section_id": 6106}, "so_27133056_27133124_3": {"length": 24, "quality": 0.96, "section_id": 7182}, "so_27133056_27133124_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 6111}}, "n3337": {"so_27133056_27133124_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5876}, "so_27133056_27133124_0": {"length": 45, "quality": 1.0, "section_id": 5872}, "so_27133056_27133124_3": {"length": 24, "quality": 0.96, "section_id": 6926}, "so_27133056_27133124_2": {"length": 19, "quality": 0.8260869565217391, "section_id": 5877}}, "n4659": {"so_27133056_27133124_2": {"length": 14, "quality": 0.6086956521739131, "section_id": 7608}, "so_27133056_27133124_3": {"length": 24, "quality": 0.96, "section_id": 8690}, "so_27133056_27133124_0": {"length": 45, "quality": 1.0, "section_id": 7603}, "so_27133056_27133124_1": {"length": 7, "quality": 1.0, "section_id": 7608}}}, "27133109": {"Id": "27133109", "PostTypeId": "2", "Body": "<p>It will be an undefined behavior . delete must be called on the pointer allocated memory using new.</p>\n<p>However you can call delete on null pointer safely.</p>\n", "LastActivityDate": "2014-11-25T17:34:03.493", "CommentCount": "0", "CreationDate": "2014-11-25T17:34:03.493", "ParentId": "27133056", "Score": "2", "OwnerUserId": "4047092"}, "27133056": {"ViewCount": "2496", "Body": "<p>Let's say I declare a pointer of char, and call delete on it without having called new. Can this cause a problem?</p>\n<pre><code>char* myptr;\n\nif (condition)\n    //do something involving myptr = new char[SIZE];\nelse\n    //do something that doesnt involve myptr\n\n//do more stuff\ndelete[] myptr;\n</code></pre>\n<p>I don't delete myptr under the if because another pointer in <code>//do more stuff</code> can point to it if <code>condition</code> was true. Obviously this works fine if <code>condition</code> was true because a \"new\" was called on <code>myptr</code>. Is deleting <code>myptr</code> bad if I entered the else condition, where <code>myptr</code> is unused?</p>\n", "AcceptedAnswerId": "27133124", "Title": "What happens when I call \"delete\" on an uninitialized pointer in C++?", "CreationDate": "2014-11-25T17:31:21.160", "Id": "27133056", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-05-20T12:01:38.703", "LastEditorUserId": "1942027", "LastActivityDate": "2015-05-20T12:01:38.703", "Score": "5", "OwnerUserId": "3554666", "Tags": "<c++><pointers><memory><memory-management>", "AnswerCount": "4"}, "27133132": {"Id": "27133132", "PostTypeId": "2", "Body": "<p>you can write like</p>\n<pre><code>char* myptr=NULL;\n\nif (condition)\n    //do something involving myptr = new char[SIZE];\nelse\n    //do something that doesnt involve myptr\n\n//do more stuff\nif(myptr)\n  delete[] myptr;\n</code></pre>\n", "LastActivityDate": "2014-11-25T17:35:27.550", "CommentCount": "0", "CreationDate": "2014-11-25T17:35:27.550", "ParentId": "27133056", "Score": "2", "OwnerUserId": "3479893"}});