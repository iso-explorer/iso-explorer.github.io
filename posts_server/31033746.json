post_cb({"bq_ids": {"n4140": {"so_31033746_31038983_1": {"length": 21, "quality": 0.7, "section_id": 7049}, "so_31033746_31038983_0": {"length": 18, "quality": 0.6923076923076923, "section_id": 7054}}, "n3337": {"so_31033746_31038983_1": {"length": 21, "quality": 0.7, "section_id": 6794}, "so_31033746_31038983_0": {"length": 18, "quality": 0.6923076923076923, "section_id": 6798}}, "n4659": {"so_31033746_31038983_1": {"length": 21, "quality": 0.7, "section_id": 8546}, "so_31033746_31038983_0": {"length": 18, "quality": 0.6923076923076923, "section_id": 8551}}}, "31038983": {"Id": "31038983", "PostTypeId": "2", "Body": "<p>In general, it is not <em>illegal</em> to use the <code>::</code> scope operator against the existing class scope to refer to its own members (even though it is redundant).</p>\n<blockquote>\n<p id=\"so_31033746_31038983_0\">After the point of declaration of a class member, the member name can be looked up in the scope of its\n  class. [ <em>Note:</em> this is true even if the class is an incomplete class. For example,\n  <code>struct X {</code><br>\n<code>enum E { z = 16 };</code><br>\n<code>int b[X::z];</code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>// OK</em><br>\n<code>};</code><br>\n<sub>C++11 \u00a73.3.2 \u00b65</sub></br></br></br></br></p>\n</blockquote>\n<p>The problem is that the definition of <em>point of declaration</em> seems to preclude using the scope operator in the member declaration if it is on its own name.</p>\n<blockquote>\n<p id=\"so_31033746_31038983_1\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its <em>initializer</em> (if any), except as noted below. [ <em>Example:</em><br>\n<code>int x = 12;</code><br>\n<code>{ int x = x; }</code><br>\n  Here the second <code>x</code> is initialized with its own (indeterminate) value. <em>\u2014 end example</em> ]<br>\n<sub>C++11 \u00a73.3.2 \u00b61</sub></br></br></br></br></p>\n</blockquote>\n<p>There are no exceptions for class members in the paragraphs that follow in the rest of \u00a73.3.2.</p>\n<p>Even with the above restriction, the syntax for class members do not prohibit the use of a <em>qualified-id</em> for the member name. It is therefore not a syntax error to accept the shown code. But, there is a semantic violation, and a diagnostic should have been emitted.</p>\n", "LastActivityDate": "2015-06-24T23:45:34.873", "CommentCount": "0", "CreationDate": "2015-06-24T23:45:34.873", "ParentId": "31033746", "Score": "1", "OwnerUserId": "315052"}, "31033746": {"ViewCount": "381", "Body": "<p>I have a class written by a 3rd party, which has something like this Foo.h:</p>\n<pre><code>class Foo\n{\npublic:\n    int Foo::dosomething(float x, float y, float z);\n\n    //Other things here\n};\n</code></pre>\n<p>And in Foo.cpp, dosomething is:</p>\n<pre><code>int Foo::dosomething(float x, float y, float z)\n{    \n    //Something\n}\n</code></pre>\n<p>What does the <code>::</code> before the function name in the header mean? When I create a new object</p>\n<pre><code>Foo foo;\n</code></pre>\n<p>I cannot access the dosomething function like this: </p>\n<pre><code>foo.dosomething(1,2,3);\n</code></pre>\n<p>How is dosomething meant to be accessed? When I remove the :: in the header file before dosomething like so:</p>\n<pre><code>class Foo\n{\npublic:\n    int dosomething(float x, float y, float z);\n\n    //Other things here\n};\n</code></pre>\n<p>I can access dosomething from an object of type Foo.</p>\n", "AcceptedAnswerId": "31038983", "Title": "double-colon (::) before method declaration in class definition", "CreationDate": "2015-06-24T18:01:08.980", "Id": "31033746", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-06-24T18:12:17.433", "LastEditorUserId": "717732", "LastActivityDate": "2015-06-24T23:45:34.873", "Score": "2", "OwnerUserId": "803017", "Tags": "<c++><oop><msvc12>", "AnswerCount": "2"}, "31033787": {"Id": "31033787", "PostTypeId": "2", "Body": "<p>It is incorrect (and many compilers consider it an error) to add the scope to the function name <em>within</em> the class definition. Since it is already within the scope of a class, you are essentially defining the functions scope as <code>Foo::Foo::dosomething</code> which is wrong.</p>\n<pre><code>class Foo\n{\npublic:\n    int Foo::dosomething(float x, float y, float z);   // Shouldn't have Foo::\n};\n</code></pre>\n<p>To answer your question of what the <code>::</code> does, it specifies the <strong>scope</strong> of the function. Consider these two functions</p>\n<pre><code>int dosomething(float x, float y, float z);\nint Foo::dosomething(float x, float y, float z);\n</code></pre>\n<p>The first is a free function, the latter is a method of the <code>Foo</code> class and (since it isn't preceded by the word <code>static</code>) requires an instance of <code>Foo</code> to be called from.</p>\n", "LastEditorUserId": "2296458", "LastActivityDate": "2015-06-24T18:09:13.490", "Score": "5", "CreationDate": "2015-06-24T18:02:42.833", "ParentId": "31033746", "CommentCount": "0", "OwnerUserId": "2296458", "LastEditDate": "2015-06-24T18:09:13.490"}});