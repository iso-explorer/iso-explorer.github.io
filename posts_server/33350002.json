post_cb({"33350002": {"ViewCount": "761", "Body": "<pre><code>#include &lt;iostream&gt; \n\nint C; \n\nclass C { \n  private: \n    int i[2]; \n  public: \n    static int f() { \n        return sizeof(C); \n    } \n}; \n\nint f() \n{ \n    return sizeof(C); // why the C can't be the class type C.\n} \n\nint main() \n{ \n   std::cout &lt;&lt; \"C::f() = \" &lt;&lt;C::f() &lt;&lt; \",\" \n             &lt;&lt; \" ::f() = \" &lt;&lt;::f() &lt;&lt; std::endl; \n} \n</code></pre>\n<p>The above code returns: <code>C::f() = 8, ::f() = 4</code></p>\n<p>My question is why the identifier <code>C</code> inside the global function <code>f</code> resolves to the object of type <code>int</code> that has name C, instead of the class type <code>C</code>? Does <code>sizeof</code> have a specific name lookup rule?</p>\n<p><strong>Conclusion</strong> : From what I read in this <a href=\"https://stackoverflow.com/a/612476/1021388\">https://stackoverflow.com/a/612476/1021388</a>, hiding class names by function/object/enumerator names is for compatibility concerns with C. And to avoid this inadvertent hiding, one should <code>typedef</code> the class to force compiler errors.</p>\n", "AcceptedAnswerId": "33350762", "Title": "Does sizeof operator prefer object over type?", "CreationDate": "2015-10-26T15:49:03.353", "Id": "33350002", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:10.153", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-26T18:53:13.050", "Score": "13", "OwnerUserId": "1021388", "Tags": "<c++><sizeof>", "AnswerCount": "3"}, "33350458": {"Id": "33350458", "PostTypeId": "2", "Body": "<p>Regarding your question, <code>sizeof</code> does not have any special parsing or evaluation rules.</p>\n<p>Consider the following:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint C; \n\nclass C { \npublic:\n    int i[2]; \n}; \n\nint main() \n{ \n   // compiles fine:\n   int x = C;\n\n   // prints 0:\n   std::cout &lt;&lt; C &lt;&lt; \"\\n\";\n\n   // prints something that corresponds to \"int\"\n   // (or even \"int\" itself):\n   std::cout &lt;&lt; typeid(C).name() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>In all three cases, <code>C</code> is taken as the <code>int</code> variable and not as the type name.</p>\n<p>If you need a clear distinction, you can always use <code>class C</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint C; \n\nclass C { \npublic:\n    int i[2]; \n}; \n\nint main() \n{ \n   // prints something that corresponds to \"class C\"\n   // (or even \"class C\" itself):\n   std::cout &lt;&lt; typeid(class C).name() &lt;&lt; \"\\n\";\n\n   // prints sizeof(int):\n   std::cout &lt;&lt; sizeof(C) &lt;&lt; \"\\n\";\n\n   // prints sizeof(int) * 2:\n   std::cout &lt;&lt; sizeof(class C) &lt;&lt; \"\\n\";\n} \n</code></pre>\n", "LastActivityDate": "2015-10-26T16:10:46.490", "CommentCount": "1", "CreationDate": "2015-10-26T16:10:46.490", "ParentId": "33350002", "Score": "3", "OwnerUserId": "3313064"}, "33350572": {"Id": "33350572", "PostTypeId": "2", "Body": "<p>Trying to compile this code will give you the answer</p>\n<pre><code>#include &lt;iostream&gt;\n\nint C;\n\nclass C {\n    int i[2];\n  public: \n    static int f() { \n        return sizeof(C); \n    }\n}; \n\nint f() { \n    return sizeof(C); // why the C can't be the class type C.\n} \n\nint main() {\n   C a; // &lt;-- Adding this line generates the error\n   std::cout &lt;&lt; \"C::f() = \" &lt;&lt;C::f() &lt;&lt; \",\" \n             &lt;&lt; \" ::f() = \" &lt;&lt;f() &lt;&lt; std::endl; \n} \n</code></pre>\n<hr>\n<pre><code>prog.cpp:22:4: error: must use 'class' tag to refer to type 'C' in this scope\n   C a;\n   ^\n   class \nprog.cpp:3:5: note: class 'C' is hidden by a non-type declaration of 'C' here\nint C; \n    ^\n1 error generated.\n</code></pre>\n<p>Compiler:</p>\n<pre><code>clang version 3.7.0 (tags/RELEASE_370/final 246979)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\n</code></pre>\n<p>To get the correct output:</p>\n<pre><code>int f() { \n    return sizeof(class C);\n} \n</code></pre>\n</hr>", "LastEditorUserId": "2089675", "LastActivityDate": "2015-10-26T16:30:03.913", "Score": "1", "CreationDate": "2015-10-26T16:16:20.453", "ParentId": "33350002", "CommentCount": "3", "OwnerUserId": "2089675", "LastEditDate": "2015-10-26T16:30:03.913"}, "bq_ids": {"n4140": {"so_33350002_33350762_2": {"length": 9, "quality": 0.75, "section_id": 5846}, "so_33350002_33350762_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5857}, "so_33350002_33350762_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5857}}, "n3337": {"so_33350002_33350762_2": {"length": 9, "quality": 0.75, "section_id": 5616}, "so_33350002_33350762_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5627}, "so_33350002_33350762_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5627}}, "n4659": {"so_33350002_33350762_2": {"length": 9, "quality": 0.75, "section_id": 7325}, "so_33350002_33350762_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 7336}, "so_33350002_33350762_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7336}}}, "33350762": {"Id": "33350762", "PostTypeId": "2", "Body": "<p><code>sizeof</code> isn't the key to this question. It simply happens to be something that can be used both on type name or a variable name. These rules apply to other uses of identifiers as well.</p>\n<p>\u00a79.1 [class.name] (c++ standard draft n3797):</p>\n<blockquote id=\"so_33350002_33350762_0\">\n<ol start=\"2\">\n<li>...snip... If a class name is declared in a scope where a variable, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an elaborated-type-specifier.</li>\n</ol>\n</blockquote>\n<p>There is a class by the name of <code>C</code> and a variable by the same name in the global scope. Therefore, the class can be referred to only using an elaborated type specifier (<code>class C</code>).</p>\n<p>Inside the definition of <code>C</code>, however, the first part of that paragraph is relevant:</p>\n<p>\u00a79.1 [class.name]:</p>\n<blockquote id=\"so_33350002_33350762_1\">\n<ol start=\"2\">\n<li>A class declaration introduces the class name into the scope where it is declared and hides any class, variable, function, or other declaration of that name in an enclosing scope ...snip...</li>\n</ol>\n</blockquote>\n<p>\u00a79 [class]:</p>\n<blockquote id=\"so_33350002_33350762_2\">\n<ol start=\"2\">\n<li>...snip... The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name ...snip...</li>\n</ol>\n</blockquote>\n<p>So, inside the scope of <code>class C</code>, the injected class name hides the <code>int C</code> declaration from the outer scope. Therefore you can refer to <code>C</code> without elaborated type specifier. To refer to the global <code>int C</code>, you could use <code>::C</code></p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2015-10-26T17:03:37.347", "Score": "20", "CreationDate": "2015-10-26T16:25:33.927", "ParentId": "33350002", "CommentCount": "2", "OwnerUserId": "2079303", "LastEditDate": "2015-10-26T17:03:37.347"}});