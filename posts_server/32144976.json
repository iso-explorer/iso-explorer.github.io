post_cb({"32145795": {"Id": "32145795", "PostTypeId": "2", "Body": "<p>There have been recent changes in clang due to <a href=\"http://wg21.cmeerw.net/cwg/issue1467\" rel=\"nofollow\">DR1467</a> (cfr. <a href=\"https://llvm.org/bugs/show_bug.cgi?id=22259\" rel=\"nofollow\">22259</a>)</p>\n<p>Recent version of gcc and clang both do the right thing: compile your code without errors.</p>\n<p>In the first round of overload resolution for the member initializer list A's constructors are discarded since they're not initializer-list constructors.</p>\n<p>Afterwards <em>[over.match.list]/p1</em> takes over</p>\n<blockquote id=\"so_32144976_32145795_0\">\n<ul>\n<li>If no viable initializer-list constructor is found, overload resolution\n  is performed again, where the candidate functions are all the\n  constructors of the class T and the argument list consists of the\n  elements of the initializer list.</li>\n</ul>\n</blockquote>\n<p>and this time A's constructors are kept into account. A's copy and move constructors have enough arguments to match the overload resolution process and they don't cause any user-defined conversion suppression since 13.3.1.3 and even 13.3.1.7 (still in <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaInit.cpp#L3379\" rel=\"nofollow\">Clang's code</a>) don't apply to these constructors.</p>\n<p>Therefore they're entered in the overload resolution set and <em>[over.best.ics]</em> applies.</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2015-08-21T23:01:21.537", "Score": "1", "CreationDate": "2015-08-21T17:05:10.110", "ParentId": "32144976", "CommentCount": "0", "OwnerUserId": "1938163", "LastEditDate": "2015-08-21T23:01:21.537"}, "bq_ids": {"n4140": {"so_32144976_32145795_0": {"length": 20, "quality": 1.0, "section_id": 599}}, "n3337": {"so_32144976_32145795_0": {"length": 20, "quality": 1.0, "section_id": 589}}, "n4659": {"so_32144976_32145795_0": {"length": 20, "quality": 1.0, "section_id": 622}}}, "32144976": {"ViewCount": "181", "Body": "<p>The code follows.</p>\n<pre><code>struct A {\n  A() {}\n};\n\nstruct B {\n  B() {}\n  explicit operator A() { return A{}; }\n};\n\nstruct C {\n  A a;\n  C(B b) : a{b} {}\n};\n</code></pre>\n<p>I have a <code>struct A</code> which is not aggregate constructible (because it has a constructor defined). The same goes for <code>struct B</code>. But it also has an explicit user-defined conversion operator to <code>struct A</code>. Now <code>struct C</code>'s constructor takes a <code>struct B</code>, and uses it to construct <code>struct A</code>. As on <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\" rel=\"noreferrer\">cppreference</a>, the conversion operator can participate in direct initialization, which I believe is the case for the member initialization of <code>struct C</code>. It passes on GCC 5.2 (C++11). But however it fails on Clang 3.6. I tried with C++11, C++14, and C++1z.</p>\n<p>If I change <code>a{b}</code> to <code>a(b)</code>, it passes on both Clang and GCC.</p>\n<p>I wonder if it is a Clang bug or I misunderstood the standard?</p>\n", "Title": "Clang cannot use braced initialization for user-defined conversion", "CreationDate": "2015-08-21T16:13:12.683", "LastActivityDate": "2015-08-21T23:01:21.537", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-21T16:18:24.487", "LastEditorUserId": "701092", "Id": "32144976", "Score": "6", "OwnerUserId": "1595430", "Tags": "<c++><c++11>", "AnswerCount": "1"}});