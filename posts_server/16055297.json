post_cb({"20292420": {"ParentId": "16055297", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_16055297_20292420_0\">if foo has a move constructor, then wouldn't foo f2(std::move(f)) calls it?\n  You do not get the default move constructor when you supply your copy constructor. Add following line to get it ( and notice the change ).\n  foo(foo&amp;&amp; ifm)=default;</p>\n</blockquote>\n", "OwnerUserId": "1135237", "PostTypeId": "2", "Id": "20292420", "Score": "0", "CreationDate": "2013-11-29T19:41:15.987", "LastActivityDate": "2013-11-29T19:41:15.987"}, "16055297": {"CommentCount": "2", "AcceptedAnswerId": "16055379", "PostTypeId": "1", "LastEditorUserId": "3425536", "CreationDate": "2013-04-17T08:34:24.887", "LastActivityDate": "2016-02-20T15:13:23.683", "LastEditDate": "2016-02-20T15:13:23.683", "ViewCount": "6524", "FavoriteCount": "5", "Title": "What is the behaviour of compiler generated move constructor?", "Id": "16055297", "Score": "27", "Body": "<p>Does <code>std::is_move_constructible&lt;T&gt;::value == true</code> imply that <code>T</code> has a usable move constructor? \nIf so, what is the default behaviour of it?</p>\n<p>Consider the following case:</p>\n<pre><code>struct foo {\n    int* ptr;\n};\n\nint main() {\n    {       \n        std::cout &lt;&lt; std::is_move_constructible&lt;foo&gt;::value &lt;&lt; '\\n';\n        foo f;\n        f.ptr = (int*)12;\n        foo f2(std::move(f));\n        std::cout &lt;&lt; f.ptr &lt;&lt; ' ' &lt;&lt; f2.ptr &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>\n<p>and the output is:</p>\n<pre><code>1\n0000000C 0000000C\n</code></pre>\n<p>I thought that <code>f.ptr</code> should be <code>nullptr</code>.\nSo in this case, </p>\n<ol>\n<li>Is <code>f2</code> move constructed ?</li>\n<li>If so, shouldn't the rvalue be invalidated?</li>\n<li>How can I know if instances of a class can be properly move-constructed (invalidate the old one)?</li>\n</ol>\n<p>(I'm using VS11.)</p>\n<h2>Update</h2>\n<p>The default behaviour of move constructor is same as a copy constructor, is it correct?\nIf it's true,</p>\n<ol>\n<li>We always expect a move ctor to steal the resources of the moved-from object, while the default one does not behave as expected, so what's the point of having a default move ctor? </li>\n<li>How can I know if a class has a custom move constructor (which can be guaranteed to behave properly)?</li>\n</ol>\n<p>It seems that <code>foo f2(std::move(f));</code> calls the copy ctor when I declared one, see:</p>\n<pre><code>struct foo {\n    int* ptr;\n    foo() {}\n    foo(const foo&amp; other) {\n        std::cout &lt;&lt; \"copy constructed\\n\";\n    }\n};\n\nint main() {\n    {       \n        std::cout &lt;&lt; std::is_move_constructible&lt;foo&gt;::value &lt;&lt; '\\n';\n        foo f;\n        foo f2(std::move(f));\n    }\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>Now the output is:</p>\n<pre><code>1\ncopy constructed\n</code></pre>\n<p>If <code>foo</code> has a move constructor, then wouldn't <code>foo f2(std::move(f))</code> call it?</p>\n<p>So now my questions is:\nHow to know if a class has a move ctor, and if it has one, how can I explicitly call it?</p>\n<h2>What I'm trying to do is\u2026</h2>\n<pre><code>template&lt;typename T, bool has_move_ctor&gt;\nstruct MoveAux;\n\ntemplate&lt;typename T&gt;\nstruct MoveAux&lt;T, true&gt; {\n    static void doMove(T* dest, T* src) {\n        new(dest) T(std::move(*src)); //move ctor\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct MoveAux&lt;T, false&gt; {\n    static void doMove(T* dest, T* src) {\n        new(dest) T(*src); //copy ctor\n        src-&gt;~T();\n    }\n};\n\ntemplate&lt;typename T&gt;\ninline doMove(T* dest, T* src) {\n    MoveAux&lt;T,/*a trait*/&gt;::doMove(dest, src);\n}\n</code></pre>\n<p>So I thought <code>std::is_move_constructible&lt;T&gt;::value</code> can be passed to the template, while now I see that this trait only cares if <code>T t(T())</code> is a valid expression, it may call <code>T::T(const T&amp;)</code>.\nNow assume that <code>T</code> is a custom class, then I want the above templates to behave like:</p>\n<ol>\n<li>If I don't declare a move ctor, I want that template method calls the <code>MoveAux&lt;T,false&gt;::doMove</code>.</li>\n<li>If I declared one,  I need it calls to <code>MoveAux&lt;T,true&gt;::doMove</code>.</li>\n</ol>\n<p>Is it possible to make this work?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "1971684", "AnswerCount": "6"}, "16055709": {"ParentId": "16055297", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Note that Visual Studio 2012 / VC++11 does <em>not</em> support compiler generated move constructors; in fact, consider this quote from <a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\" rel=\"nofollow\"><em>\"C++11 Features in Visual C++ 11\"</em></a> blog post (emphasis mine):</p>\n<blockquote>\n<p id=\"so_16055297_16055709_0\">Rvalue references v3.0 adds new rules to automatically generate move\n  constructors and move assignment operators under certain conditions.\n  This <strong>will not be implemented in VC11</strong>, which will continue to follow\n  VC10's behavior of <strong>never automatically generating move\n  constructors/move assignment operators</strong>.</p>\n</blockquote>\n<p>With <strong>raw pointers</strong>, you have to define move constructors by yourself, manually clearing the old \"moved-from\" pointer:</p>\n<pre><code>class Foo \n{\npublic:\n\n    // Move constructor\n    Foo(Foo&amp;&amp; other)\n        : m_ptr(other.m_ptr) // copy pointer value\n    {\n        // Clear out old \"moved-from\" pointer, to avoid dangling references\n        other.m_ptr = nullptr;\n    }\n\nprivate:\n    int* m_ptr;\n};\n</code></pre>\n<p>Instead, if you use a <strong>smart pointer</strong> like <code>std::unique_ptr</code>, move constructor is properly defined, and you can just call <code>std::move</code>:</p>\n<pre><code>class Foo \n{\npublic:\n\n    // Move constructor\n    Foo(Foo&amp;&amp; other)\n        : m_ptr(std::move(other.m_ptr)) // move from other, \n                                        // old pointer automatically cleared\n    {\n    }\n\nprivate:\n    std::unique_ptr&lt;int&gt; m_ptr;\n};\n</code></pre>\n<p>With <em>automatically generated</em> move constructors, you don't have to define a custom move constructor explicitly, if <em>member-wise</em> move is OK for you.</p>\n", "OwnerUserId": "1629821", "LastEditorUserId": "1629821", "LastEditDate": "2013-04-17T08:59:52.883", "Id": "16055709", "Score": "2", "CreationDate": "2013-04-17T08:54:30.110", "LastActivityDate": "2013-04-17T08:59:52.883"}, "16060939": {"ParentId": "16055297", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_16055297_16060939_0\">the defaulr behaviour of move constructor is same as a copy\n  constructor, is it correct? if it's true</p>\n</blockquote>\n<p>No. Its wrong. Its true only for primitives. Its similar to that of copy constructor.</p>\n<p>The default generated copy constructor calls the <strong>copy</strong> constructor of all its members in the declared order</p>\n<p>But The default generated move constructor calls the <strong>move</strong> constructor of all its members in the declared order</p>\n<p>Now the next question is what is the copy/move constructor of the primitives <code>int</code>s <code>float</code>s <code>pointer</code>s do? </p>\n<p>Ans: They just copy the values (both copy and move constructor)</p>\n", "OwnerUserId": "463758", "PostTypeId": "2", "Id": "16060939", "Score": "2", "CreationDate": "2013-04-17T13:08:50.320", "LastActivityDate": "2013-04-17T13:08:50.320"}, "16055390": {"ParentId": "16055297", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_16055297_16055390_0\">does std::is_move_constructible::value == true implies that T has a usable move constructor?</p>\n</blockquote>\n<p>No. It states that you can <a href=\"http://en.cppreference.com/w/cpp/concept/MoveConstructible\" rel=\"noreferrer\">take an rvalue expression of the object type and construct an object from it</a>. Whether this uses the move constructor or the copy constructor is not relevant to this trait.</p>\n<blockquote>\n<p id=\"so_16055297_16055390_1\">is f2 move constructed ?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_16055297_16055390_2\">if so, shouldn't the rvalue be invalidated?</p>\n</blockquote>\n<p>No. That's not how movement works.</p>\n<blockquote>\n<p id=\"so_16055297_16055390_3\">how can I know if instances of a class can be properly move-constructed(invalidate the old one)?</p>\n</blockquote>\n<p>That is not any definition of \"properly move-constructed\" that exists. If you want to \"invalidate the old one\", then you will have to do that yourself.</p>\n<p>Move construction generally guarantees <em>nothing</em> about the state of the old object. It will be in a valid but undefined state. Such state very much can be \"the same as it was before\". Move construction for a pointer is the same as copying the pointer.</p>\n<p>If you want to \"invalidate\" after a move, then you need to write your own move constructor that explicitly does that.</p>\n<blockquote>\n<p id=\"so_16055297_16055390_4\">(I'm using VS11)</p>\n</blockquote>\n<p>Then you have no compiler-generated move constructors <em>at all</em>. Not that it would matter, since the move and copy constructors for pointers both do the same thing.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "16055390", "Score": "5", "CreationDate": "2013-04-17T08:38:53.170", "LastActivityDate": "2013-04-17T08:38:53.170"}, "16055393": {"ParentId": "16055297", "CommentCount": "0", "Body": "<p>n3376 12.8/15</p>\n<p><blockquote><p id=\"so_16055297_16055393_0\">The implicitly-defined copy/<strong>move constructor</strong> for a non-union class X performs a <strong>memberwise</strong> copy/<strong>move</strong>\nof its bases and members.</p></blockquote>\n<blockquote><p id=\"so_16055297_16055393_1\">\nEach base or non-static data\nmember is copied/moved in the manner appropriate to its type:</p>\n<p id=\"so_16055297_16055393_2\">\u2014 if the member is an array, each element is direct-initialized with the corresponding subobject of x;</p>\n<p id=\"so_16055297_16055393_3\">\u2014 if a member m has rvalue reference type T&amp;&amp;, it is direct-initialized with static_cast(x.m);</p>\n<p id=\"so_16055297_16055393_4\">\u2014 otherwise, the base or member is direct-initialized with the corresponding base or member of x.</p></blockquote></p>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "16055393", "Score": "0", "CreationDate": "2013-04-17T08:39:15.090", "LastActivityDate": "2013-04-17T08:39:15.090"}, "bq_ids": {"n4140": {"so_16055297_16055379_2": {"section_id": 464, "quality": 0.7916666666666666, "length": 19}, "so_16055297_16055393_0": {"section_id": 464, "quality": 0.9166666666666666, "length": 11}, "so_16055297_16055393_2": {"section_id": 464, "quality": 1.0, "length": 7}, "so_16055297_16055393_4": {"section_id": 464, "quality": 1.0, "length": 7}, "so_16055297_16055393_1": {"section_id": 464, "quality": 1.0, "length": 10}, "so_16055297_16055393_3": {"section_id": 464, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_16055297_16055379_2": {"section_id": 455, "quality": 0.7916666666666666, "length": 19}, "so_16055297_16055393_1": {"section_id": 455, "quality": 1.0, "length": 10}, "so_16055297_16055393_2": {"section_id": 455, "quality": 1.0, "length": 7}, "so_16055297_16055393_4": {"section_id": 455, "quality": 1.0, "length": 7}, "so_16055297_16055393_0": {"section_id": 455, "quality": 0.9166666666666666, "length": 11}, "so_16055297_16055393_3": {"section_id": 455, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_16055297_16055379_2": {"section_id": 487, "quality": 0.75, "length": 18}, "so_16055297_16055393_0": {"section_id": 487, "quality": 0.9166666666666666, "length": 11}, "so_16055297_16055393_2": {"section_id": 487, "quality": 1.0, "length": 7}, "so_16055297_16055393_3": {"section_id": 487, "quality": 0.8333333333333334, "length": 5}, "so_16055297_16055393_1": {"section_id": 487, "quality": 1.0, "length": 10}, "so_16055297_16055393_4": {"section_id": 487, "quality": 1.0, "length": 7}}}, "16055379": {"ParentId": "16055297", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_16055297_16055379_0\">does <code>std::is_move_constructible&lt;T&gt;::value == true</code> implies that <code>T</code> has a usable move constructor?</p>\n</blockquote>\n<p>Either a move constructor or a copy constructor. Remember that the operation of copy construction satisfies all the requirements that are placed upon the operation move construction, and some more. </p>\n<p>In Standard terms, a <code>MoveConstructible</code> object is one for which the evaluation of the expression:</p>\n<pre><code>T u = rv; \n</code></pre>\n<p>makes <code>u</code> equivalent to the value of <code>rv</code> before the construction; the state of <code>rv</code> <em>after</em> being moved-from is <em>unspecified</em>. But since it is unspecified, this means the state could even be identical to the one <code>rv</code> had <em>before</em> being moved from: In other words, <code>u</code> could be a <em>copy</em> of <code>rv</code>.</p>\n<p>In fact, the Standard defines the <code>CopyConstructible</code> concept to be a <em>refinement</em> of the <code>MoveConstructible</code> concept (so everything which is <code>CopyConstructible</code> is also <code>MoveConstructible</code>, but not vice versa).</p>\n<blockquote>\n<p id=\"so_16055297_16055379_1\">if so, what is the default behaviour of it?</p>\n</blockquote>\n<p>The behavior of an implicitly generated move constructor is to perform a member-wise move of the data members of the type for which it is generated.</p>\n<p>Per Parahgraph 12.8/15 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16055297_16055379_2\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a <strong>memberwise copy/move\n  of its bases and members</strong>. [ Note: <em>brace-or-equal-initializers</em> of non-static data members are ignored. See\n  also the example in 12.6.2. \u2014end note ]</p>\n</blockquote>\n<p>Moreover:</p>\n<blockquote>\n<p id=\"so_16055297_16055379_3\">1 - is <code>f2</code> move constructed ?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_16055297_16055379_4\">2 - if so, shouldn't the rvalue be invalidated?</p>\n</blockquote>\n<p>Moving a <em>pointer</em> is the same as copying it. So no invalidation is going on, neither should it be going on. If you want a move constructor that leaves the moved-from object in a particular state (i.e. sets a pointer data member to <code>nullptr</code>), you have to write your own - or delegate this responsibility to some smart pointer class such as <code>std::unique_ptr</code>.</p>\n<p>Notice, that the word \"<em>invalidated</em>\" is not quite correct here. Move constructors (as well as move assignment operators) are meant to leave the moved-from object in a <em>valid</em> (yet unspecified) state. </p>\n<p>In other words, the class invariant needs to be respected - and it should be possible to invoke on a moved-from objects operations that do not have any precondition on its state (usually, destruction and assignment).</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-17T15:09:40.970", "Id": "16055379", "Score": "20", "CreationDate": "2013-04-17T08:38:32.553", "LastActivityDate": "2013-04-17T15:09:40.970"}});