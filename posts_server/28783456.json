post_cb({"bq_ids": {"n4140": {"so_28783456_28845770_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 1151}}, "n3337": {"so_28783456_28845770_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 1148}}, "n4659": {"so_28783456_28845770_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 1245}}}, "28845770": {"Id": "28845770", "PostTypeId": "2", "Body": "<p>Sigh, this was too long for a comment:</p>\n<blockquote>\n<p id=\"so_28783456_28845770_0\">Isn't the meaning of atomic \"to appear to occur instantaneously to the rest of the system\"?</p>\n</blockquote>\n<p>I'd say yes and no to that one, depending on how you think of it. For writes with <code>SEQ_CST</code>, yes. But as far as how atomic loads are handled, check out 29.3 of the C++11 standard. Specifically, 29.3.3 is really good reading, and 29.3.4 might be specifically what you're looking for:</p>\n<blockquote>\n<p id=\"so_28783456_28845770_1\">For an atomic operation B that reads the value of an atomic object M, if there is a memory_order_seq_-\n  cst fence X sequenced before B, then B observes either the last memory_order_seq_cst modification of M\n  preceding X in the total order S or a later modification of M in its modification order.</p>\n</blockquote>\n<p>Basically, <code>SEQ_CST</code> forces a global order just like the standard says, but reads can return and old value without violating the 'atomic' constraint.</p>\n<p>To accomplish 'getting the absolute latest value' you'll need to perform an operation that forces the hardware coherency protocol to lock(the <code>lock</code> instruction on x86_64). This is what the atomic compare-and-exchange operations do, if you look at the assembly output.</p>\n", "LastActivityDate": "2015-03-04T02:39:17.237", "CommentCount": "3", "CreationDate": "2015-03-04T02:39:17.237", "ParentId": "28783456", "Score": "3", "OwnerUserId": "947030"}, "28796354": {"Id": "28796354", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28783456_28796354_0\">Am I wrong to assume that the atomic::load should also act as a memory barrier ensuring that all previous non-atomic writes will become visible by other threads?</p>\n</blockquote>\n<p>Yes. <code>atomic::load(SEQ_CST)</code> just enforces that the read cannot load an 'invalid' value, and neither writes nor loads may be reordered by the compiler <em>or the cpu</em> around that statement. It does not mean you'll always get the most up to date value.</p>\n<p>I would expect your code to have a data race because again, barriers do not ensure the most up to date value is seen at a given time, they just prevent reordering. </p>\n<p>Its perfectly valid for Thread1 to not see the write by Thread2 and therefore not set <code>triggered</code>, and for Thread2 to not see the write by  Thread1 (again, not setting <code>triggered</code>), because you only write 'atomically' from one thread.</p>\n<p>With two threads writing and reading shared values, you'll need a barrier in each thread to maintain consistency. It looks like you knew this already based in your code comments, so I'll just leave it at \"the C++ standard is somewhat misleading when it comes to accurately describing meaning of atomic / multithreaded operations\". </p>\n<p>Even though you're writing C++, its still best, in my opinion, to think about what you're doing on the underlying architecture.</p>\n<p>Not sure I explained that well, but I'd be happy to go into more detail if you'd like.</p>\n", "LastActivityDate": "2015-03-01T17:00:05.773", "CommentCount": "1", "CreationDate": "2015-03-01T17:00:05.773", "ParentId": "28783456", "Score": "2", "OwnerUserId": "947030"}, "28783456": {"ViewCount": "867", "Body": "<p>Am I wrong to assume that the atomic::load should also act as a memory barrier ensuring that all previous <em>non-atomic</em> writes will become visible by other threads?</p>\n<p>To illustrate:</p>\n<pre><code>volatile bool arm1 = false;\nstd::atomic_bool arm2 = false;\nbool triggered = false;\n</code></pre>\n<p>Thread1:</p>\n<pre><code>arm1 = true;\n//std::std::atomic_thread_fence(std::memory_order_seq_cst); // this would do the trick \nif (arm2.load())\n    triggered = true;\n</code></pre>\n<p>Thread2:</p>\n<pre><code>arm2.store(true);\nif (arm1)\n    triggered = true;\n</code></pre>\n<p>I expected that after executing both 'triggered' would be true. Please don't suggest to make arm1 atomic, the point is to explore the behavior of atomic::load.</p>\n<p>While I have to admit I don't fully understand the formal definitions of the different relaxed semantics of <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">memory order</a> I thought that the <em>sequentially consistent ordering</em> was pretty straightforward in that it guarantees that \"a single total order exists in which all threads observe all modifications in the same order.\" To me this implies that the std::atomic::load with the default memory order of std::memory_order_seq_cst will also act as a memory fence. This is further corroborated by the following statement under \"Sequentially-consistent ordering\":</p>\n<p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. </p>\n<p>Yet, my simple example below demonstrates this is not the case with MSVC 2013, gcc 4.9 (x86) and clang 3.5.1 (x86), where the atomic load simply translates to a load instruction.</p>\n<pre><code>#include &lt;atomic&gt;\n\nstd::atomic_long al;\n\n#ifdef _WIN32\n__declspec(noinline)\n#else\n__attribute__((noinline))\n#endif\nlong load() {\n    return al.load(std::memory_order_seq_cst);\n}\n\nint main(int argc, char* argv[]) {\n    long r = load();\n}\n</code></pre>\n<p>With gcc this looks like:</p>\n<pre><code>load():\n   mov  rax, QWORD PTR al[rip]   ; &lt;--- plain load here, no fence or xchg\n   ret\nmain:\n   call load()\n   xor  eax, eax\n   ret\n</code></pre>\n<p>I'll omit the msvc and clang which are essentially identical. Now on gcc for ARM we get what I expected:</p>\n<pre><code>load():\n     dmb    sy                         ; &lt;---- data memory barrier here\n     movw   r3, #:lower16:.LANCHOR0\n     movt   r3, #:upper16:.LANCHOR0\n     ldr    r0, [r3]                   \n     dmb    sy                         ; &lt;----- and here\n     bx lr\nmain:\n    push    {r3, lr}\n    bl  load()\n    movs    r0, #0\n    pop {r3, pc}\n</code></pre>\n<p>This is not an academic question, it results in a subtle race condition in our code which called into question my understanding of the behavior of std::atomic. </p>\n", "AcceptedAnswerId": "28845770", "Title": "Memory ordering behavior of std::atomic::load", "CreationDate": "2015-02-28T15:36:09.383", "Id": "28783456", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-01T06:38:38.033", "LastEditorUserId": "4583970", "LastActivityDate": "2015-03-04T02:39:17.237", "Score": "5", "OwnerUserId": "4583970", "Tags": "<c++><c++11><atomic><atomicity><memory-fences>", "AnswerCount": "2"}});