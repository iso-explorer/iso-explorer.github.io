post_cb({"340466": {"Id": "340466", "PostTypeId": "2", "Body": "<p>The two C-style casts in your example are different kinds of cast. In C++, you'd normally write them</p>\n<pre><code>unsigned int uf1 = static_cast&lt;unsigned int&gt;(fl);\n</code></pre>\n<p>and</p>\n<pre><code>unsigned char* up = reinterpret_cast&lt;unsigned char*&gt;(p);\n</code></pre>\n<p>The first performs an arithmetic cast, which truncates the floating point number, so there is data loss.</p>\n<p>The second makes no changes to data - it just instructs the compiler to treat the pointer as a different type. Care needs to be taken with this kind of cast: it can be very dangerous.</p>\n", "OwnerDisplayName": "James Hopkin", "LastActivityDate": "2008-12-04T12:44:32.207", "Score": "8", "CreationDate": "2008-12-04T12:44:32.207", "ParentId": "340413", "CommentCount": "0", "OwnerUserId": "11828"}, "341330": {"Body": "<p>Well, first note that a cast is an <em>explicit request to convert a value of one type to a value of another type</em>. A cast will also always produce a new object, which is a temporary returned by the cast operator. Casting to a reference type, however, will not create a new object. The object referenced by the value is reinterpreted as a reference of a different type. </p>\n<p>Now to your question. Note that there are two major types of conversions:</p>\n<ul>\n<li><em>Promotions</em>: This type can be thought of casting from a possibly more narrow type to a wider type. Casting from char to int, short to int, float to double are all promotions. </li>\n<li><em>Conversions</em>: These allow casting from long to int, int to unsigned int and so forth. They can in principle cause loss of information. There are rules for what happens if you assign a <code>-1</code> to an unsigned typed object for example. In some cases, a wrong conversion can result in undefined behavior. If you assign a double larger than what a float can store to a float, the behavior is not defined. </li>\n</ul>\n<p>Let's look at your casts:</p>\n<pre><code>int i = 10; \nunsigned int k = (unsigned int) i; // :1\n\nfloat fl = 10.123;\nunsigned int  ufl = (unsigned int) fl; // :2\n\nchar *p = \"Stackoverflow Rocks\"; \nunsigned char *up = (unsigned char *) p; // :3\n</code></pre>\n<ol>\n<li>This cast causes a conversion to happen. No loss of data happens, since 10 is guaranteed to be stored by an <code>unsigned int</code>. If the integer were negative, the value would basically wrap around the maximal value of an unsigned int (see <strong>4.7/2</strong>). </li>\n<li>The value <code>10.123</code> is truncated to 10. Here, it <em>does</em> cause lost of information, obviously. As 10 fits into an unsigned int, the behavior is defined. </li>\n<li>This actually requires more attention. First, there is a deprecated conversion from a string literal to <code>char*</code>. But let's ignore that here. (see <a href=\"https://stackoverflow.com/questions/308279/c-vs#308724\">here</a>). More importantly, what does happen if you cast to an unsigned type? Actually, the result of that is unspecified per <strong>5.2.10/7</strong> (note the semantics of that cast is the same as using reinterpret_cast in this case, since that is the only C++ cast being able to do that):</li>\n</ol>\n<blockquote>\n<p id=\"so_340413_341330_0\">A pointer to an object can be explicitly converted to a pointer to\n  an object of different type. Except that converting an rvalue of type \u201cpointer to T1\u201d to the type \"pointer to T2\" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>So you are only safe to use the pointer after you cast back to <code>char *</code> again. </p>\n", "CreationDate": "2008-12-04T17:01:20.770", "ParentId": "340413", "CommentCount": "1", "LastEditDate": "2017-05-23T12:16:29.687", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2010-10-27T08:49:48.890", "LastEditorUserId": "-1", "Id": "341330", "OwnerDisplayName": "litb", "Score": "18", "OwnerUserId": "34509"}, "341494": {"Id": "341494", "PostTypeId": "2", "Body": "<p>Casts mean different things depending on what they are.  They can just be renamings of a data type, with no change in the bits represented (most casts between integral types and pointers are like this), or conversions that don't even preserve length (such as between double and int on most compilers).  In many cases, the meaning of a cast is simply unspecified, meaning the compiler has to do something reasonable but doesn't have to document exactly what.</p>\n<p>A cast doesn't even need to result in a usable value.  Something like <code>\nchar * cp; \nfloat * fp; \ncp = malloc(100); \nfp = (float *)(cp + 1);</code>\nwill almost certainly result in a misaligned pointer to float, which will crash the program on some systems if the program attempts to use it.</p>\n", "OwnerDisplayName": "David Thornley", "LastActivityDate": "2008-12-04T17:45:17.140", "Score": "1", "CreationDate": "2008-12-04T17:45:17.140", "ParentId": "340413", "CommentCount": "0", "OwnerUserId": "14148"}, "bq_ids": {"n4140": {"so_340413_341330_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 6045}}, "n3337": {"so_340413_341330_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5814}}, "n4659": {"so_340413_341330_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 7544}}}, "340439": {"Id": "340439", "PostTypeId": "2", "Body": "<p>\"Type\" in C and C++ is a property assigned to variables when they're handled in the compiler. The property doesn't exist at runtime anymore, except for virtual functions/RTTI in C++.</p>\n<p>The compiler uses the type of variables to determine a lot of things. For instance, in the assignment of a float to an int, it will know that it needs to convert. Both types are probably 32 bits, but with different meanings. It's likely that the CPU has an instruction, but otherwise the compiler would know to call a conversion function. I.e.\n<code>&amp; __stack[4] = float_to_int_bits(&amp; __stack[0])</code></p>\n<p>The conversion from char* to unsigned char* is even simpeler. That is just a different label. At bit level, p and up are identical. The compiler just needs to remember that *p requires sign-extension while *up does not.</p>\n", "OwnerDisplayName": "MSalters", "LastActivityDate": "2008-12-04T12:31:15.013", "Score": "5", "CreationDate": "2008-12-04T12:31:15.013", "ParentId": "340413", "CommentCount": "0", "OwnerUserId": "15416"}, "340413": {"ViewCount": "11570", "Body": "<p>How do type casting happen without loss of data inside the compiler?</p>\n<p>For example:</p>\n<pre><code> int i = 10;\n UINT k = (UINT) k;\n\n float fl = 10.123;\n UINT  ufl = (UINT) fl; // data loss here?\n\n char *p = \"Stackoverflow Rocks\";\n unsigned char *up = (unsigned char *) p;\n</code></pre>\n<p>How does the compiler handle this type of typecasting? A low-level example showing the bits would be highly appreciated.</p>\n", "AcceptedAnswerId": "341330", "Title": "How do C/C++ compilers handle type casting between types with different value ranges?", "CreationDate": "2008-12-04T12:20:44.470", "Id": "340413", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2011-09-26T18:21:31.143", "LastEditorDisplayName": "unwind", "OwnerDisplayName": "mahesh", "LastEditorUserId": "63550", "LastActivityDate": "2011-09-26T18:21:31.143", "Score": "11", "OwnerUserId": "38038", "Tags": "<c++><c><compiler-construction><casting>", "AnswerCount": "4"}});