post_cb({"bq_ids": {"n4140": {"so_27663055_27664497_2": {"section_id": 6689, "quality": 0.9375, "length": 15}, "so_27663055_27664497_1": {"section_id": 6687, "quality": 0.9285714285714286, "length": 13}, "so_27663055_27664497_4": {"section_id": 6690, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_27663055_27664497_2": {"section_id": 6444, "quality": 0.9375, "length": 15}, "so_27663055_27664497_1": {"section_id": 6442, "quality": 0.9285714285714286, "length": 13}, "so_27663055_27664497_4": {"section_id": 6445, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_27663055_27664497_2": {"section_id": 8164, "quality": 0.9375, "length": 15}, "so_27663055_27664497_1": {"section_id": 8162, "quality": 0.8571428571428571, "length": 12}, "so_27663055_27664497_4": {"section_id": 8165, "quality": 0.9444444444444444, "length": 17}}}, "27663108": {"ParentId": "27663055", "CommentCount": "4", "Body": "<p><code>mag</code> is not declared in global scope. Also, <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">ADL</a> kicks in during the function overload resolution case, but it is strictly based on the types of the argument - not on <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">implicity-convertible</a> types. If you want to use ADL, call <code>mag</code> with a <code>B</code>.</p>\n<pre><code>int main() {\n    A a;\n    mag(B(a));\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "862351", "PostTypeId": "2", "Id": "27663108", "Score": "0", "CreationDate": "2014-12-26T23:48:58.970", "LastActivityDate": "2014-12-26T23:48:58.970"}, "27663923": {"ParentId": "27663055", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>1.\nif class B is not a template class, you must define mag function outside class because it is a friend function which means that it is a non-class-member-function.</p>\n<pre><code>class B{\n    public:\n        B(const A&amp; p){\n            cout&lt;&lt;\"copy constructor\"&lt;&lt;endl;\n        }    \n        friend void mag(const B&amp; p);\n    private:\n        int k;\n};\n\nvoid mag(const B&amp; p){\n    cout&lt;&lt;\"mag\"&lt;&lt;endl;\n}\n</code></pre>\n<p>2.\nif class B is a template class, you should add template&lt;...&gt; statement both in function declaration and definition.</p>\n<pre><code>template&lt;class T&gt;\nclass B{\n    public:\n        B(const T&amp; p){\n            cout&lt;&lt;\"copy constructor\"&lt;&lt;endl;\n        }\n        template&lt;class T2&gt;        //declare mag as a template function\n        friend void mag(const T2&amp; p);\n};\n\ntemplate&lt;class T&gt;    //define mag function\nvoid mag(const T&amp; p){\n    cout&lt;&lt;\"mag\\n\";\n}\n</code></pre>\n", "OwnerUserId": "4396869", "LastEditorUserId": "4396869", "LastEditDate": "2014-12-27T05:57:40.580", "Id": "27663923", "Score": "0", "CreationDate": "2014-12-27T02:45:00.183", "LastActivityDate": "2014-12-27T05:57:40.580"}, "27664497": {"ParentId": "27663055", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Sections of the C++ Draft Standard N3337 that are relevant for this question:</p>\n<blockquote>\n<p id=\"so_27663055_27664497_0\"><strong>11.3 Friends</strong></p>\n<p id=\"so_27663055_27664497_1\">4 A function first declared in a friend declaration has external linkage (3.5). Otherwise, the function retains its previous linkage (7.1.1).</p>\n<p id=\"so_27663055_27664497_2\">6 A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8), the function name is unqualified, and the function has namespace scope. [ <em>Example:</em></p>\n<pre><code>class M {\n    friend void f() { } // definition of global f, a friend of M,\n                        // not the definition of a member function\n };\n</code></pre>\n<p id=\"so_27663055_27664497_3\"><em>\u2014 end example</em> ]</p>\n<p id=\"so_27663055_27664497_4\">7 Such a function is implicitly <code>inline</code>. A friend function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not (3.4.1).</p>\n</blockquote>\n<p>In your example, <code>mag</code> is defined in the lexical scope of class <code>B</code>, i.e. the name <code>mag</code> is not visible outside the class even though it has external linkage. To make the function visible outside the class <code>B</code>, it has to be declared outside <code>B</code>.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2014-12-27T17:52:32.510", "Id": "27664497", "Score": "2", "CreationDate": "2014-12-27T04:57:31.140", "LastActivityDate": "2014-12-27T17:52:32.510"}, "27663090": {"ParentId": "27663055", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Because the function <code>mag</code> is not <em>declared</em> in the global scope (you did defined and declared it when you made it a friend at the same time, but the declaration in it's own scope is still required).</p>\n<p>You need to declare it :</p>\n<pre><code>class B {\npublic:\n    B(const  A&amp; p) {\n        std::cout &lt;&lt; \"Copy constructor\" &lt;&lt; std::endl;\n    }\n    friend void mag(const B&amp; p) {\n        std::cout &lt;&lt; \"Mag Inside`.\\n\";\n    }\n};\n\nvoid mag(const B&amp; p);\n</code></pre>\n<p>If you call <code>mag</code> with a <code>B</code> object, <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">Argument Dependant Lookup</a> will look into <code>B</code>'s scope and find the definition.</p>\n<p>Now if <code>B</code> is a template, you'll need to declare each version of <code>mag</code> with the appropriate parameters (and if several exist, you'll need to help the compiler to resolve ambiguities during conversions) :</p>\n<pre><code>template&lt;typename T&gt;\nclass B {\npublic:\n    B(const  A&amp; p) {\n        std::cout &lt;&lt; \"Copy constructor\" &lt;&lt; std::endl;\n    }\n\n    friend void mag(const B&lt;T&gt;&amp; p) {\n        std::cout &lt;&lt; \"Mag Inside`.\\n\";\n    }\n};\n\nvoid mag(const B&lt;int&gt;&amp; p);  // Version for B&lt;int&gt; declared.\n</code></pre>\n", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-12-27T00:05:07.517", "Id": "27663090", "Score": "4", "CreationDate": "2014-12-26T23:45:10.290", "LastActivityDate": "2014-12-27T00:05:07.517"}, "27663176": {"ParentId": "27663055", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can't define friend function like that for a class if that class was a template, because :</p>\n<p>suppose you have for example <code>B&lt;int&gt;</code> and <code>B&lt;float&gt;</code> it will be ambiguous for  the compiler whether to treat B as <code>B&lt;int&gt;</code> or <code>B&lt;float&gt;</code></p>\n<p>therefore you must declare mag as a template as well like that :</p>\n<pre><code>// Inside the class :\nfriend void mag(const B&lt;T&gt;&amp; p);\n\n// Outside the class :\ntemplate &lt;typename T&gt; void mag(const B&lt;T&gt;&amp; p) {\n     std::cout &lt;&lt; \"Mag Outside.\\n\";\n}\n</code></pre>\n<p>then it will work!</p>\n", "OwnerUserId": "2783361", "LastEditorUserId": "2783361", "LastEditDate": "2014-12-27T00:09:23.267", "Id": "27663176", "Score": "0", "CreationDate": "2014-12-27T00:00:08.670", "LastActivityDate": "2014-12-27T00:09:23.267"}, "27663055": {"CommentCount": "2", "ViewCount": "894", "PostTypeId": "1", "LastEditorUserId": "2026108", "CreationDate": "2014-12-26T23:38:34.657", "LastActivityDate": "2014-12-27T17:52:32.510", "Title": "friend function and copy constructors", "AcceptedAnswerId": "27663090", "LastEditDate": "2014-12-26T23:44:20.550", "Id": "27663055", "Score": "1", "Body": "<p>The code shown below doesn't compile when the friend function mag() is defined inside the class, but works if defined outside class (commented). I think the difference is caused by the copy constructor used to change the argument type from A to B. Can someone explain why I should define the friend function outside?</p>\n<p>Moreover, if class B is a template class (adding <code>template &lt;class T&gt;</code> at the top), defining the friend function outside will also not work.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n};\n\nclass B {\npublic:\n    B(const  A&amp; p) {\n        std::cout &lt;&lt; \"Copy/Conversion constructor\" &lt;&lt; std::endl;\n    }\n    friend void mag(const B&amp; p) {\n        std::cout &lt;&lt; \"Mag Inside`.\\n\";\n    }\n};\n//void mag(const B&amp; p) {\n//     std::cout &lt;&lt; \"Mag Outside.\\n\";\n//}\nint main() {\n    A a;\n    mag(a);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><copy-constructor><friend-function>", "OwnerUserId": "2026108", "AnswerCount": "5"}});