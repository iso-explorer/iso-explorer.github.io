post_cb({"bq_ids": {"n4140": {"so_17481018_17483612_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}}, "n3337": {"so_17481018_17483612_0": {"length": 29, "quality": 1.0, "section_id": 472}}, "n4659": {"so_17481018_17483612_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}}}, "17483612": {"Id": "17483612", "PostTypeId": "2", "Body": "<p><strong>Update:</strong></p>\n<p>Explicit move should not be needed in modern compiler versions.</p>\n<p>Core <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow noreferrer\">DR 1579</a> changed the rules so that the return value will be treated as an rvalue even when the types are not the same. GCC 5 implements the new rule, for C++11 as well as C++14.</p>\n<p><strong>Original answer:</strong></p>\n<p>This is not a limitation of <code>unique_ptr</code>, it's a limitation of the language, the same limitation applies to any <code>return</code> statement that calls a converting constructor taking an rvalue reference:</p>\n<pre><code>struct U { };\n\nstruct T {\n  T(U&amp;&amp;) { }\n};\n\nT f() {\n  U u;\n  return u;  // error, cannot bind lvalue to U&amp;&amp;\n}\n</code></pre>\n<p>This will not compile because [class.copy]/32 says:</p>\n<blockquote>\n<p id=\"so_17481018_17483612_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>This means that the expression in a <code>return</code> statement can only be treated as an rvalue if it is eligible for copy/move elision (aka NRVO) but that is too restrictive because it means it only applies when the type is exactly the same, even though the variable is always going out of scope so it would be reasonable to always treat is as an rvalue (technically as an xvalue, an <em>expiring</em> value.)</p>\n<p>This was recently <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-proposals/Tc1p52jg-1Y/aTEsPprxzZgJ\" rel=\"nofollow noreferrer\">suggested</a> by <a href=\"https://stackoverflow.com/users/1041090/richard-smith\">Richard Smith</a> (and previously by Xeo) and I think it's a very good idea.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-16T19:12:46.750", "Score": "17", "CreationDate": "2013-07-05T07:42:02.747", "ParentId": "17481018", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2017-05-23T12:02:26.147"}, "17481018": {"ViewCount": "955", "Body": "<p>In a <a href=\"https://stackoverflow.com/q/17473753/321013\">comment to another question</a> Jonathan Wakely responds to my statement:</p>\n<blockquote>\n<p id=\"so_17481018_17481018_0\">You never need explicit move for a local variable function return\n  value. It's implicit move there</p>\n</blockquote>\n<p>-&gt;</p>\n<blockquote>\n<p id=\"so_17481018_17481018_1\">... never say never ... You need an explicit move if the local variable\n  is not the same type as the return type, e.g. <code>std::unique_ptr&lt;base&gt;\n  f() { auto p = std::make_unique&lt;derived&gt;(); p-&gt;foo(); return p; }</code>, but\n  if the types are the same it will move if possible ...</p>\n</blockquote>\n<p>So it seems sometimes we may <em>have to</em> move a local variable on return.</p>\n<p>The example</p>\n<pre><code>std::unique_ptr&lt;base&gt; f() { \n  auto p = std::make_unique&lt;derived&gt;();\n  p-&gt;foo(); \n  return p; \n}\n</code></pre>\n<p>is nice in that it gives a <a href=\"http://ideone.com/jKFClD\" rel=\"nofollow noreferrer\">compilation error</a></p>\n<pre><code>&gt; prog.cpp:10:14: error: cannot convert \u2018p\u2019 from type\n&gt; \u2018std::unique_ptr&lt;derived&gt;\u2019 to type \u2018std::unique_ptr&lt;derived&gt;&amp;&amp;\u2019\n</code></pre>\n<p>but I'm wondering whether there is a good chance to detect this in general -- and <strong>is this here a limit of the language rules or of <code>unique_ptr</code></strong>??</p>\n", "AcceptedAnswerId": "17483612", "Title": "When is explicit move needed for a return statement?", "CreationDate": "2013-07-05T04:21:43.613", "Id": "17481018", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:42.970", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-16T19:12:46.750", "Score": "16", "OwnerUserId": "321013", "Tags": "<c++><c++11><return><implicit-conversion><move-semantics>", "AnswerCount": "1"}});