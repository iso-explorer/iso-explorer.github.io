post_cb({"39548254": {"CommentCount": "0", "ViewCount": "2337", "PostTypeId": "1", "LastEditorUserId": "3552770", "CreationDate": "2016-09-17T15:00:25.157", "LastActivityDate": "2017-09-20T06:19:16.887", "Title": "Does std::array<> guarantee allocation on the stack only?", "AcceptedAnswerId": "39548345", "LastEditDate": "2016-09-17T16:11:49.413", "Id": "39548254", "Score": "14", "Body": "<p>Is <code>std::array&lt;int,10&gt;</code> (without myself using <code>new</code>) guaranteed to be allocated in the stack rather then the heap by the C++-Standard?</p>\n<p>To be clear, I do not mean <code>new std::array&lt;int, 10&gt;</code>. I mainly wonder, if the standard library is allowed to use <code>new</code> inside its implementation.</p>\n", "Tags": "<c++><arrays><stack><dynamic-allocation><static-allocation>", "OwnerUserId": "472245", "AnswerCount": "2"}, "39549597": {"ParentId": "39548254", "CommentCount": "3", "CreationDate": "2016-09-17T17:12:35.783", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "39549597", "Score": "9", "Body": "<p>C++ has no concept of stack or heap.  Those are implementation details, and there is at least one platform that does not use a traditional stack (but rather linked list of heap allocations for it).</p>\n<p>It has automatic storage and the free store.  <code>new</code> accesses the free store, and variables \"on the stack\" go into automatic storage.</p>\n<p>In practice, in order to allocate things on the free store, you have to risk an out of memory exception.  So the general rule is things that guarantee they do not throw must be using automatic storage.  <code>array</code> makes this guarantee (except whatever is in it can throw, natually).  It is also an aggregate of plain old data, effectively forced to look like:</p>\n<pre><code>template&lt;class T,std::size_t N&gt;\nstruct array {\n  T __no_fixed_name__[N];\n  // non-constructor/destructor methods omitted as they are noise at this point\n};\n</code></pre>\n<p>In theory it could be implemented by the compiler via magic that is not actual C++, but there is no need for that, so nobody bothers.</p>\n<p>TL;DR: yes, it is on the stack.</p>\n", "LastActivityDate": "2016-09-17T17:12:35.783"}, "bq_ids": {"n4140": {"so_39548254_39548345_1": {"section_id": 3310, "quality": 0.8, "length": 4}, "so_39548254_39548345_0": {"section_id": 775, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_39548254_39548345_1": {"section_id": 3180, "quality": 0.8, "length": 4}, "so_39548254_39548345_0": {"section_id": 762, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_39548254_39548345_1": {"section_id": 6103, "quality": 1.0, "length": 5}, "so_39548254_39548345_0": {"section_id": 836, "quality": 0.8888888888888888, "length": 8}}}, "39548345": {"ParentId": "39548254", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-09-17T15:08:52.303", "Score": "10", "LastEditorUserId": "3552770", "LastEditDate": "2017-09-20T06:19:16.887", "Id": "39548345", "OwnerUserId": "3552770", "Body": "<p>I could not find more explicit answer in the standard, but <a href=\"http://eel.is/c++draft/array#overview-2\" rel=\"nofollow noreferrer\"><code>[array.overview]/2</code></a>:</p>\n<blockquote>\n<p id=\"so_39548254_39548345_0\"><strong>An array is an aggregate</strong> (<code>[dcl.init.aggr]</code>) that can be list-initialized with up to <code>N</code> elements whose types are convertible to <code>T</code>.</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/dcl.init.aggr#1\" rel=\"nofollow noreferrer\"><code>[dcl.init.aggr]/1</code></a>:</p>\n<blockquote>\n<p id=\"so_39548254_39548345_1\"><strong>An aggregate is an array or a class</strong> (Clause <code>[class]</code>) <strong>with</strong></p>\n<ul>\n<li><strong>no user-provided</strong>, explicit, or inherited <strong>constructors</strong> (<code>[class.ctor]</code>),</li>\n</ul>\n<p id=\"so_39548254_39548345_2\">...</p>\n</blockquote>\n<p>That about covers it. No way an aggregate could allocate memory dynamically (or perhaps, do anything at all at its own during the construction). There's only an implicitly-declared trivial constructor.</p>\n<p><sup>Of course, if you <code>new std::array&lt;...&gt;</code>, you get an array on \"the heap\".</sup></p>\n<hr>\n<p>Some may be more satisfied by what we can get on <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_39548254_39548345_3\"><code>std::array</code> is a container that encapsulates fixed size arrays.</p>\n<p id=\"so_39548254_39548345_4\">This container is an aggregate type with the same semantics as a struct holding a C-style array <code>T[N]</code> as its only non-static data member.</p>\n</blockquote>\n<hr>\n<p>Thirdly, <code>std::array</code> was introduced in C++11. Why? For example, to complement <code>std::vector</code> in some ways, like usage in <code>constexpr</code> functions, where dynamic allocation is not allowed.</p>\n</hr></hr>", "LastActivityDate": "2017-09-20T06:19:16.887"}});