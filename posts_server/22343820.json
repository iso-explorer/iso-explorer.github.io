post_cb({"bq_ids": {"n4140": {"so_22343820_22344731_0": {"length": 19, "quality": 1.0, "section_id": 7156}}, "n3337": {"so_22343820_22344731_0": {"length": 19, "quality": 1.0, "section_id": 6900}}, "n4659": {"so_22343820_22344731_0": {"length": 19, "quality": 1.0, "section_id": 8663}}}, "22344731": {"Id": "22344731", "PostTypeId": "2", "Body": "<p>I would think yes. Both instances live from first access through the lifetime of the program. The only thing that could get tricky is destruction: If A's destructor used the reference/pointer to B but B were already destroyed. Fortunately, the standard guarantees in 3.6.3 (citing the 2012 draft): </p>\n<blockquote>\n<p id=\"so_22343820_22344731_0\">\"If the <strong>completion</strong> of the constructor or dynamic initialization of\n  an object with static storage duration is sequenced before that of\n  another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.\"</p>\n</blockquote>\n<p>(Emphasis by me.) In other words, reverse order of destruction is guaranteed for static objects. Since your order of construction is fine, the order of destruction will be as well. A's reference/pointer to B will be valid throughout A's instance destruction.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2014-03-12T08:08:43.460", "Score": "2", "CreationDate": "2014-03-12T07:30:46.757", "ParentId": "22343820", "CommentCount": "0", "OwnerUserId": "3150802", "LastEditDate": "2014-03-12T08:08:43.460"}, "22343820": {"ViewCount": "113", "Body": "<p>I have a two singleton classes.</p>\n<p>First one is holding a reference to a member from the second one.</p>\n<pre><code>#include &lt;memory&gt;\n\nclass B\n{\n    friend class A;\n    public:\n        static B&amp; getInstance()\n        {\n            static B    instance;\n\n            return instance;\n        }\n    private:\n        B()\n        : b(new int(5))\n        , c(8)\n        {};\n        B(B const&amp;);  \n        void operator=(B const&amp;);\n\n        private:\n            std::auto_ptr&lt;int&gt; b;\n            int c;\n};\n\n\nclass A\n{\n    public:\n        static A&amp; getInstance()\n        {\n            static A    instance;\n\n            return instance;\n        }\n    private:\n        A()\n        : b(B::getInstance().b.get())\n        , cRef(B::getInstance().c)\n        {\n        };\n        A(A const&amp;);  \n        void operator=(A const&amp;);\n        private:\n            int* b;\n            int&amp; cRef;\n};\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p>Is this code safe?</p>\n", "AcceptedAnswerId": "22344731", "Title": "Is it safe to hold a referece from one class to another?", "CreationDate": "2014-03-12T06:39:27.773", "Id": "22343820", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-12T08:08:43.460", "Score": "0", "OwnerUserId": "1892307", "Tags": "<c++>", "AnswerCount": "2"}, "22344136": {"Id": "22344136", "PostTypeId": "2", "Body": "<p>Here you are doing nothing with objects data, so this code is correct in single threaded environment. In multithreaded add lock to the getInstance() methods:</p>\n<pre><code>  static A&amp; getInstance() {\n       Lock lock;\n       static A instance;\n       return instance;\n  }\n</code></pre>\n<p>But be aware of B::b which is stored as a pointer in A. If in the future you'll be able to change B::b, say reset it, A pointer may become incorrect.</p>\n<p>If your compiler supports C++11 standard in the part of static local variables initialization (as @Mikhail noticed) you can avoid these locks.</p>\n<p>(BTW: what is the aim of these classes? No public methods.)</p>\n", "LastEditorUserId": "3291022", "LastActivityDate": "2014-03-12T07:54:35.613", "Score": "0", "CreationDate": "2014-03-12T06:58:01.673", "ParentId": "22343820", "CommentCount": "1", "OwnerUserId": "3291022", "LastEditDate": "2014-03-12T07:54:35.613"}});