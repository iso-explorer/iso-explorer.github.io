post_cb({"24518706": {"Id": "24518706", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow\">cppreference</a> says the following about <strong>functions</strong> :<br>\n<strong>prvaule</strong>  (\"pure\" rvalue) is an expression that identifies a temporary object (or a subobject thereof) or is a value not associated with any object.<br>\nThe following expressions are prvalues:  </br></br></p>\n<ol>\n<li>Literal (except string literal), such as 42 or true or nullptr.  </li>\n<li><strong>Function call/operator expression if the function's or the operator's return type is not a reference, such as str.substr(1, 2) or 2+2</strong> </li>\n</ol>\n<p>This apply for functions, I'm not sure what exactly are the rules regarding built in operators.</p>\n", "LastEditorUserId": "2959585", "LastActivityDate": "2014-07-02T04:35:39.287", "Score": "-2", "CreationDate": "2014-07-01T20:26:04.010", "ParentId": "24518517", "CommentCount": "5", "OwnerUserId": "2959585", "LastEditDate": "2014-07-02T04:35:39.287"}, "24518752": {"Id": "24518752", "PostTypeId": "2", "Body": "<p>There is small stuff:\n<a href=\"http://rextester.com/DUEJY28518\" rel=\"nofollow\">http://rextester.com/DUEJY28518</a>:</p>\n<pre><code>std::cout &lt;&lt; typeid(decltype(sizeof(char))).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1 &lt;&lt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1 &gt;&gt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(~1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1 &amp; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1 | 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1 ^ 1)).name() &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"-------------\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1U &lt;&lt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1U &gt;&gt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(~1U)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1U &amp; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1U | 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1U ^ 1)).name() &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"-------------\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1L &lt;&lt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1L &gt;&gt; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(~1L)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1L &amp; 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1L | 1)).name() &lt;&lt; std::endl;\nstd::cout &lt;&lt; typeid(decltype(1L ^ 1)).name() &lt;&lt; std::endl;\n</code></pre>\n<p>The result is(MSVC):</p>\n<pre><code>unsigned int\nint\nint\nint\nint\nint\nint\n-------------\nunsigned int\nunsigned int\nunsigned int\nunsigned int\nunsigned int\nunsigned int\n-------------\nlong\nlong\nlong\nlong\nlong\nlong\n</code></pre>\n", "LastActivityDate": "2014-07-01T20:29:25.090", "CommentCount": "1", "CreationDate": "2014-07-01T20:29:25.090", "ParentId": "24518517", "Score": "-3", "OwnerUserId": "2451677"}, "24518932": {"Id": "24518932", "PostTypeId": "2", "Body": "<p>sizeof() : size_t  according to Standard 5.3.3 pt6 - Standard 5.19/3 states that \"An integral constant expression is an expression of integral or unscoped enumeration type, implicitly converted to a prvalue, where the converted expression is a core constant expression.\" From 5.3.3/6 and 18.2/6 you can deduce that it's a prvalue.   </p>\n<p>E1 &lt;&lt; E2 and E1 &gt;&gt; E2 :   Standard 5.8.1 \"The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand.\".  According to standard 4.5 and in perticular pt.7,  integral promotion implies prvalue. </p>\n<p>&amp; | and ^ :  Standard specifies that \"The usual arithmetic conversions are performed; (...) operator applies only to integral or unscoped enumeration operands\". </p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2014-07-01T21:19:28.840", "Score": "0", "CreationDate": "2014-07-01T20:41:50.453", "ParentId": "24518517", "CommentCount": "4", "OwnerUserId": "3723423", "LastEditDate": "2014-07-01T21:19:28.840"}, "bq_ids": {"n4140": {"so_24518517_24519164_8": {"length": 8, "quality": 0.8888888888888888, "section_id": 6146}, "so_24518517_24519164_6": {"length": 21, "quality": 1.0, "section_id": 5940}, "so_24518517_24519164_5": {"length": 10, "quality": 1.0, "section_id": 5940}, "so_24518517_24519164_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 5943}, "so_24518517_24519164_2": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_24518517_24519164_7": {"length": 6, "quality": 0.8571428571428571, "section_id": 6065}, "so_24518517_24519164_4": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_24518517_24519164_10": {"length": 6, "quality": 1.0, "section_id": 6160}, "so_24518517_24519164_12": {"length": 10, "quality": 0.7692307692307693, "section_id": 6123}, "so_24518517_24519164_3": {"length": 5, "quality": 1.0, "section_id": 5940}, "so_24518517_24519164_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7230}}, "n3337": {"so_24518517_24519164_8": {"length": 8, "quality": 0.8888888888888888, "section_id": 5909}, "so_24518517_24519164_6": {"length": 21, "quality": 1.0, "section_id": 5711}, "so_24518517_24519164_7": {"length": 6, "quality": 0.8571428571428571, "section_id": 5833}, "so_24518517_24519164_4": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_24518517_24519164_12": {"length": 10, "quality": 0.7692307692307693, "section_id": 5818}, "so_24518517_24519164_2": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_24518517_24519164_3": {"length": 5, "quality": 1.0, "section_id": 5711}, "so_24518517_24519164_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 5714}, "so_24518517_24519164_5": {"length": 10, "quality": 1.0, "section_id": 5711}, "so_24518517_24519164_10": {"length": 6, "quality": 1.0, "section_id": 5921}, "so_24518517_24519164_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6974}}, "n4659": {"so_24518517_24519164_8": {"length": 8, "quality": 0.8888888888888888, "section_id": 7642}, "so_24518517_24519164_6": {"length": 21, "quality": 1.0, "section_id": 7424}, "so_24518517_24519164_5": {"length": 10, "quality": 1.0, "section_id": 7424}, "so_24518517_24519164_4": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_24518517_24519164_2": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_24518517_24519164_12": {"length": 10, "quality": 0.7692307692307693, "section_id": 4087}, "so_24518517_24519164_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 7428}, "so_24518517_24519164_10": {"length": 6, "quality": 1.0, "section_id": 7657}, "so_24518517_24519164_7": {"length": 6, "quality": 0.8571428571428571, "section_id": 7561}, "so_24518517_24519164_3": {"length": 5, "quality": 1.0, "section_id": 7424}, "so_24518517_24519164_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8741}}}, "24519164": {"Id": "24519164", "PostTypeId": "2", "Body": "<p>As far as I can tell the results are <em>prvalues</em> but that is just a speculative. This seems to be under-specified in a similar way to the value categories of operands which is covered in <a href=\"https://stackoverflow.com/q/14991219/1708801\">What is the value category of the operands of C++ operators when unspecified?</a> and <a href=\"https://stackoverflow.com/q/21053273/1708801\">Does the standard mandate an lvalue-to-rvalue conversion of the pointer variable when applying indirection?</a>.</p>\n<p>We can see from section <code>3.10</code> <em>Lvalues and rvalues</em> has the following note:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_0\">The discussion of each built-in operator in Clause 5 indicates the\n  category of the value it yields and the value categories of the\n  operands it expects.</p>\n</blockquote>\n<p>but as we can see section <code>5</code> only spells out the <em>value category</em> explicitly in a few cases. In the case of this particular question only spells out explicitly the <em>value category</em> of the result for <code>&amp;</code> and <code>~</code>.</p>\n<p>Even though it is underspecified we can find clues that point us in a consistent direction. We can make an argument that the operands for <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>^</code> and <code>|</code> are converted to <em>prvalues</em>. This does not dictate the value category of the result but it does seem to exclude the result being an <em>xvalue</em> as per section <code>5</code> paragraph <em>7</em> which has the following note:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_1\">An expression is an xvalue if it is:</p>\n<p id=\"so_24518517_24519164_2\">\u2014 the result of calling a\n  function, whether implicitly or explicitly, whose return type is an\n  rvalue reference to object type,</p>\n<p id=\"so_24518517_24519164_3\">\u2014 a cast to an rvalue reference to\n  object type,</p>\n<p id=\"so_24518517_24519164_4\">\u2014 a class member access expression designating a\n  non-static data member of non-reference type in which the object\n  expression is an xvalue, or</p>\n<p id=\"so_24518517_24519164_5\">\u2014 a .* pointer-to-member expression in\n  which the first operand is an xvalue and the second operand is a\n  pointer to data member.</p>\n<p id=\"so_24518517_24519164_6\">In general, the effect of this rule is that\n  named rvalue references are treated as lvalues and unnamed rvalue\n  references to objects are treated as xvalues; rvalue references to\n  functions are treated as lvalues whether named or not.</p>\n</blockquote>\n<p>I don't see any reasonable argument that the result could be an <em>lvalue</em> so that basically leaves us with a <em>prvalue</em>.</p>\n<p>So the details are as follows:</p>\n<p>Both <code>~</code> and <code>&amp;</code> are covered by section <code>5.3.1</code> <em>Unary operators</em> paragraph <em>2</em> which says:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_7\">The result of each of the following unary operators is a prvalue.</p>\n</blockquote>\n<p>The shift operators require the integral promotions which is covered in section <code>5.8</code> <em>Shift operators</em> paragraph <em>1</em> which says:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_8\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed.</p>\n</blockquote>\n<p>and we can see that the integral promotions require <em>prvalues</em> from section <code>4.5</code> <em>Integral promotions</em> which says in every paragraph starts with:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_9\">A prvalue of [...]</p>\n</blockquote>\n<p>Both <code>^</code> and <code>|</code> require the <em>usual arithmetic conversions</em> and both say:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_10\">operator applies only to integral or unscoped enumeration operands</p>\n</blockquote>\n<p>and therefore the last clause of the <em>usual arithmetic conversions</em> applies which says:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_11\">Otherwise, the integral promotions (4.5) shall be performed on both operands.<sup>59</sup></p>\n</blockquote>\n<p><b>Empirical approach</b></p>\n<p>Luc Danton has an empirical approach to determining the value category of an expression in his answer to <a href=\"https://stackoverflow.com/a/16638081/1708801\">Empirically determine value category of C++11 expression?</a>. The approach uses the following code:</p>\n<pre><code>template&lt;typename T&gt;\nstruct value_category {\n    // Or can be an integral or enum value\n    static constexpr auto value = \"prvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&gt; {\n    static constexpr auto value = \"lvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&amp;&gt; {\n    static constexpr auto value = \"xvalue\";\n};\n\n// Double parens for ensuring we inspect an expression,\n// not an entity\n#define VALUE_CATEGORY(expr) value_category&lt;decltype((expr))&gt;::value\n</code></pre>\n<p>and the answer outlines the logic as follows:</p>\n<blockquote>\n<p id=\"so_24518517_24519164_12\">an lvalue expression results in an lvalue reference type, an xvalue in\n  an rvalue reference type, and a prvalue in just the type.</p>\n</blockquote>\n<p>The following examples all yield <em>prvalue</em> (<em><a href=\"http://coliru.stacked-crooked.com/a/24fb95af8a2a40b3\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>int x = 10, y = 2 ;\nint &amp;xr = x ;\nint &amp;yr = y ;\n\nstd::cout &lt;&lt; VALUE_CATEGORY( x &lt;&lt; y ) &lt;&lt; std::endl ;\nstd::cout &lt;&lt; VALUE_CATEGORY( 10 &lt;&lt; 2 ) &lt;&lt; std::endl ;\nstd::cout &lt;&lt; VALUE_CATEGORY( xr &lt;&lt; yr ) &lt;&lt; std::endl ;\n\nstd::cout &lt;&lt; VALUE_CATEGORY( x | y ) &lt;&lt; std::endl ;\nstd::cout &lt;&lt; VALUE_CATEGORY( 10 | 2 ) &lt;&lt; std::endl ;\n\nstd::cout &lt;&lt; VALUE_CATEGORY( x ^ y ) &lt;&lt; std::endl ;\nstd::cout &lt;&lt; VALUE_CATEGORY( 10 ^ 2 ) &lt;&lt; std::endl ;\n\nstd::cout &lt;&lt; VALUE_CATEGORY( sizeof( int ) ) &lt;&lt; std::endl ;\nstd::cout &lt;&lt; VALUE_CATEGORY( sizeof( x ) ) &lt;&lt; std::endl ;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-02T09:47:56.120", "Score": "1", "CreationDate": "2014-07-01T20:57:26.643", "ParentId": "24518517", "CommentCount": "6", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:58:28.107"}, "24518517": {"ViewCount": "154", "Body": "<p>Shift operators: <code>&lt;&lt;</code> <code>&gt;&gt;</code>\nbit-wise operators: <code>~</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>\nsizeof operator: <code>sizeof()</code></p>\n<p>Per the C++ standard (n3797), I can only confirm that <code>~</code> yields prvalue (5.3.1/2), but not the others above.</p>\n", "Title": "What is the value category of result yielded from shift operators, bit-wise operators, and sizeof operator?", "CreationDate": "2014-07-01T20:10:22.320", "LastActivityDate": "2014-07-02T09:47:56.120", "CommentCount": "14", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-01T20:34:14.830", "LastEditorDisplayName": "user3795303", "OwnerDisplayName": "user3795303", "Id": "24518517", "Score": "3", "Tags": "<c++><operators><expression><language-lawyer>", "AnswerCount": "4"}});