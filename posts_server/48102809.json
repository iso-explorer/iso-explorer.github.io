post_cb({"48103463": {"Id": "48103463", "PostTypeId": "2", "Body": "<pre><code>template &lt;typename U&gt;\nU func1(std::function&lt;U()&gt; func2) {\n  return func2();\n}\n</code></pre>\n<p>When you instantiate this template with <code>U = const int&amp;</code> you get:</p>\n<pre><code>const int&amp; func1(std::function&lt;const int&amp;()&gt; func2) {\n  return func2();\n}\n</code></pre>\n<p>Then, you pass a lambda <code>[&amp;x](){ return x; }</code> to <code>func1</code>.</p>\n<p>Here is the thing: according to <em>8.1.5.4 Lambda expressions</em> the return type of lambda is deduced as <code>int</code>:</p>\n<blockquote>\n<p id=\"so_48102809_48103463_0\">If a lambda-expression does not include a lambda-declarator, it is as\n  if the lambda-declarator were (). The lambda return type is auto,\n  which is replaced by the type specified by the trailing-return-type if\n  provided and/or deduced from return statements as described in\n  10.1.7.4.</p>\n</blockquote>\n<p>It means that <code>func2</code> above returns returns a <em>temporary</em>.</p>\n<p>According to <em>15.2.6.2 Temporary Objects</em>:</p>\n<blockquote>\n<p id=\"so_48102809_48103463_1\">The lifetime of a temporary bound to the returned value in a function\n  return statement (9.6.3) is not extended; the temporary is destroyed\n  at the end of the full-expression in the return statement.</p>\n</blockquote>\n<p>So the returned value of <code>foo1</code> is bound to the temporary which is destroyed once</p>\n<pre><code>return func2();\n</code></pre>\n<p>is done.</p>\n<p>In the situation with <code>result2</code> the lambda still returns a temporary <code>int</code>, but the lifetime of the temporary is prolonged until the lifetime of <code>result2</code>according to <em>15.2.6 Temporary Objects</em> as this case does not fall to any exceptions listed in this section of the standard.</p>\n", "LastActivityDate": "2018-01-04T20:56:39.647", "CommentCount": "1", "CreationDate": "2018-01-04T20:56:39.647", "ParentId": "48102809", "Score": "1", "OwnerUserId": "5507349"}, "bq_ids": {"n4140": {"so_48102809_48103463_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 5963}, "so_48102809_48103463_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}}, "n3337": {"so_48102809_48103463_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}}, "n4659": {"so_48102809_48103463_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_48102809_48103463_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7450}}}, "48102809": {"ViewCount": "58", "Body": "<p>Given the following code:</p>\n<pre><code>template &lt;typename U&gt; U func1(std::function&lt;U()&gt; func2) {\n  return func2();\n}\n\nconst int x = 1;\nconst int&amp; result1 = func1&lt;const int&amp;&gt;([&amp;x]() { return x; });\n// result1 = ??????? (random garbage)\nconst int&amp; result2 = [&amp;x]() { return x; }();\n// result2 = 1\n</code></pre>\n<p>It seems rather inconvenient that the lambda by default strips the reference qualifier from the type of x in inferring the return value, sneakily resulting in a reference to a destructed temporary in this case.  Why was this language feature designed in this way?</p>\n<p>And why does result2 work, while result1 fails to extend the lifetime of the temporary?</p>\n", "AcceptedAnswerId": "48103463", "Title": "Why does c++ strip reference qualifiers from inferred return types, and why doesn't lifetime extension work?", "CreationDate": "2018-01-04T20:08:14.427", "Id": "48102809", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2018-01-04T20:56:39.647", "Score": "2", "OwnerUserId": "5556007", "Tags": "<c++>", "AnswerCount": "1"}});