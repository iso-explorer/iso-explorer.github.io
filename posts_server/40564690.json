post_cb({"bq_ids": {"n4140": {"so_40564690_40564690_2": {"length": 19, "quality": 0.95, "section_id": 639}, "so_40564690_40564690_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_40564690_40564690_2": {"length": 19, "quality": 0.95, "section_id": 629}, "so_40564690_40564690_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_40564690_40564690_2": {"length": 19, "quality": 0.95, "section_id": 667}, "so_40564690_40564690_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "40564916": {"Id": "40564916", "PostTypeId": "2", "Body": "<p><code>\"abc\"</code> cannot be passed directly into either overload of <code>fnc()</code>. For both of them it must be converted to an (rvalue) <code>std::string</code>. But then the cited rule from the standard unequivocally selects <code>fnc(std::string&amp;&amp;)</code> over <code>fnc(const std::string&amp;)</code>.</p>\n", "LastActivityDate": "2016-11-12T16:19:04.533", "CommentCount": "0", "CreationDate": "2016-11-12T16:19:04.533", "ParentId": "40564690", "Score": "1", "OwnerUserId": "6394138"}, "40564866": {"Id": "40564866", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40564690_40564866_0\">But it isn't that case, because S1 binds an rvalue reference to an lvalue (\"abc\", lvalue of const char[4]).</p>\n</blockquote>\n<p>Note that <code>\"abc\"</code> is a <code>const char[4]</code>, not a <code>std::string</code>. But both <code>fnc()</code> take <code>std::string</code> as parameter, and references can't be bound to objects with different type directly. Therefore firstly <code>\"abc\"</code> needs to be implicitly converted to <code>std::string</code>, which is a temporary, i.e. <strong>an rvalue</strong>. Then as the stardard says, the rvalue reference overload will be selected.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-11-12T16:29:55.163", "Score": "1", "CreationDate": "2016-11-12T16:14:09.217", "ParentId": "40564690", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-11-12T16:29:55.163"}, "40564856": {"Id": "40564856", "PostTypeId": "2", "Body": "<p>First the compiler performs an implicit array-to-pointer conversion for <code>\"abc\"</code>, so the type of <code>\"abc\"</code> becomes <code>const char*</code>. Second (and you probably missed that), <code>const char*</code> is converted to a <strong>rvalue</strong> <code>std::string</code> via the <code>const char*</code> <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow noreferrer\">non-explicit constructor of <code>std::string</code></a> (# 5 in the link). The constructed <code>std::string</code> rvalue  is a perfect match for the second overload, so the second overload is chosen.</p>\n", "LastEditorUserId": "3093378", "LastActivityDate": "2016-11-13T15:50:57.103", "Score": "6", "CreationDate": "2016-11-12T16:12:59.807", "ParentId": "40564690", "CommentCount": "2", "OwnerUserId": "3093378", "LastEditDate": "2016-11-13T15:50:57.103"}, "40564690": {"ViewCount": "164", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nvoid fnc (const std::string&amp;)\n{\n    std::cout&lt;&lt;1;\n}\n\nvoid fnc (std::string&amp;&amp;)\n{\n    std::cout&lt;&lt;2;\n}\n\nint main()\n{\n    fnc (\"abc\");\n}\n</code></pre>\n<p>All the compilers choose <code>std::string&amp;&amp;</code> version of <code>fnc</code>, and it is logical, because the temporary <code>std::string</code> is created for a reference binding, but I can't find, where is it described in C++ 14 Standard.\nI found one paragraph in there (3.2):</p>\n<blockquote>\n<p id=\"so_40564690_40564690_0\">\u2014 Standard conversion sequence S1 is a better conversion sequence than\n  standard conversion sequence S2 if</p>\n<p id=\"so_40564690_40564690_1\">[...]</p>\n<p id=\"so_40564690_40564690_2\">\u2014 S1 and S2 are reference bindings (8.5.3) and neither refers to an\n  implicit object parameter of a non-static member function declared\n  without a ref-qualifier, and S1 binds an rvalue reference to an <strong>rvalue</strong>\n  and S2 binds an lvalue reference</p>\n</blockquote>\n<p>But it isn't that case, because S1 binds an rvalue reference to an <strong>lvalue</strong> (\"abc\", lvalue of const char[4]).\nWhere can I find description, by which the second overload is selected?</p>\n<p>P.S. I pointed to C++14 Standard instead of C++11, because I know, that there was some defect reports in C++11, linked with rvalue reference binding.</p>\n", "AcceptedAnswerId": "40564856", "Title": "Overload resolution between const lvalue reference and rvalue reference", "CreationDate": "2016-11-12T15:57:53.103", "Id": "40564690", "CommentCount": "0", "LastEditDate": "2016-11-12T17:13:21.450", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2016-11-13T15:50:57.103", "Score": "3", "OwnerUserId": "3514538", "Tags": "<c++><c++14><rvalue-reference><overload-resolution>", "AnswerCount": "3"}});