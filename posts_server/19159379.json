post_cb({"19159840": {"Id": "19159840", "PostTypeId": "2", "Body": "<p>You can use a cast to convert an integer value to an enumeration. If you do that, you're responsible for ensuring that the resulting value is meaningful. In the example code, you should make sure that <code>getMessageNumType()</code> returns a suitable value.</p>\n<p>Values stored in an enumerated type are not restricted to the values named by the enumerators. For example, it's quite common to use an enumerator, along with appropriate overloaded operators, to implement a bit mask:</p>\n<pre><code>enum flag_values {\n    flag1 = 0x01,\n    flag2 = 0x02,\n    flag3 = 0x04,\n    flag4 = 0x08\n};\n\nflag_values flags = static_cast&lt;flag_values&gt;(flag1 | flag2);\n</code></pre>\n<p>That <code>|</code> operator should really be done with an overloaded operator; I left that out for simplicity. The cast is okay, but gets tedious to write everywhere.</p>\n", "LastActivityDate": "2013-10-03T12:58:10.153", "CommentCount": "0", "CreationDate": "2013-10-03T12:58:10.153", "ParentId": "19159379", "Score": "0", "OwnerUserId": "1593860"}, "19159379": {"ViewCount": "8410", "Body": "<p>My research has not yielded an answer for this yet (in SOF), but I am sure it must have been asked somewhere before, appologies if so.</p>\n<p>I have created an enumerated type in c++ and then I read in a value from a message header and want to store it into a variable of my enum type, example:</p>\n<pre><code>// My defined enum type\nenum myNumType_t\n{\n    MY_NUM_UNKNOWN = 0,\n    MY_NUM1 = 1,\n    MY_NUM2 = 2,\n    MY_NUM3 = 3,\n    MY_NUM4 = 4,\n    MY_NUM5 = 5,\n};\n\n// In the code\nint main()\n{\n    myNum_t myNum = MY_NUM_UNKNOWN;\n    myNum = getMessageNumType(); // returns an int\n\n    return 0;\n}\n</code></pre>\n<p>So, this code does not compile in c++ because it can't convert the int to myNum_t, fair enough. So then if I cast it <code>myNum = (myNum_t) getMessageNumType();</code> this of course now compiles. But does it do the right thing? What happens if the returned value is out of range of myNum_t? Is there a \"best practise\" here that I am missing?</p>\n", "AcceptedAnswerId": "19159852", "Title": "is it correct to cast an integer to enumerated type?", "CreationDate": "2013-10-03T12:33:59.360", "LastActivityDate": "2013-10-03T13:20:19.040", "CommentCount": "8", "LastEditDate": "2013-10-03T13:20:19.040", "PostTypeId": "1", "Tags": "<c++><casting><enumeration>", "Id": "19159379", "AnswerCount": "5", "Score": "8", "OwnerUserId": "2298137", "ClosedDate": "2013-10-04T09:00:29.947", "LastEditorUserId": "2298137"}, "19159876": {"Id": "19159876", "PostTypeId": "2", "Body": "<p>The only really safe int-to-enum cast is to cover ALL cases in the enum and in error-checking that the input might return and include boundary enums if there is a possibility of going out of range or returning an invalid value and then handle the bad value gracefully.</p>\n<p>If the enum is guaranteed to be a contiguous range then it is a little simpler:</p>\n<pre><code>enum myNumType_t\n{\n    MY_NUM_UNKNOWN = 0,\n    MY_NUM_MIN = 1,\n    MY_NUM1 = 1,\n    MY_NUM2 = 2,\n    MY_NUM3 = 3,\n    MY_NUM4 = 4,\n    MY_NUM5 = 5,\n    MY_NUM_MAX = MY_NUM5,\n};\n\nint main() {\n\n    //...getMessage...\n\n    myNumType_t result = static_cast&lt;myNumType_t&gt;(getMessageNumType());\n\n    if(result &lt; MY_NUM_MIN || result &gt; MY_NUM_MAX) {\n        //..handle out of range...\n    }\n}\n</code></pre>\n", "LastActivityDate": "2013-10-03T12:59:58.207", "CommentCount": "0", "CreationDate": "2013-10-03T12:59:58.207", "ParentId": "19159379", "Score": "1", "OwnerUserId": "421178"}, "bq_ids": {"n4140": {"so_19159379_19159481_0": {"length": 37, "quality": 1.0, "section_id": 24}}, "n3337": {"so_19159379_19159481_0": {"length": 37, "quality": 1.0, "section_id": 21}}, "n4659": {"so_19159379_19159481_0": {"length": 37, "quality": 1.0, "section_id": 24}}}, "19159852": {"Id": "19159852", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19159379_19159852_0\">But does it do the right thing?</p>\n</blockquote>\n<p>Assuming the value is valid for the enumeration type, yes.</p>\n<blockquote>\n<p id=\"so_19159379_19159852_1\">What happens if the returned value is out of range of myNum_t?</p>\n</blockquote>\n<p>It depends.</p>\n<p>Up to (and excluding) the nearest power of two, you're guaranteed to get exactly that value. What your code then does with it is up to you. In other words, given your code, <code>(int)(myNumType_t)7</code> is guaranteed to be equal to 7. This is important because some people use bitwise operations on enumeration values, so if an enumeration has <code>BIT0 = 1, BIT1 = 2, BIT2 = 4</code>, it is intended that <code>BIT0 | BIT1 | BIT2</code> can be stored in that same enumeration type.</p>\n<p>For larger values, not much of use can be said. Some implementations would store your enumeration in a single (8-bit) byte, so on those implementations, <code>(int)(myNumType_t)257</code> could not possibly be equal to 257. On others, it might be. You're better off avoiding that by checking the integer value beforehand.</p>\n", "LastActivityDate": "2013-10-03T12:58:51.060", "CommentCount": "0", "CreationDate": "2013-10-03T12:58:51.060", "ParentId": "19159379", "Score": "4", "OwnerUserId": "743382"}, "19159848": {"Id": "19159848", "PostTypeId": "2", "Body": "<p>The first question is whether you can trust the source of the value or not, and in general if you are reading messages off the network or any other input/output device, I would doubt that trust.</p>\n<p>If you cannot trust it, you should be able to write a small function that tests the value received and maps it to the appropriate enumerator or fails if the value is out of range. Note that in the example code you provided, the compiler could choose any type for the enumeration that was able to represent all the values in the range 0-7, the standard does not make any additional guarantees. </p>\n<p>While in practical terms the compiler will most probably pick a larger type like <code>int</code> for this particular case, the compiler can assume that the value is not outside of that range. If the value decoded from the message is larger than 8 you will be hitting undefined behavior and you might get results you don't really expect.</p>\n<p>For a practical example, if the enumerators ranged from 0 to 3, both included, and you had this code:</p>\n<pre><code>enum_t value = (enum_t) getInt();\nswitch (value) {\ncase V0:\ncase V1:\ncase V2:\ncase V3:  std::cout &lt;&lt; \"valid\\n\"; break;\ndefault:  std::cout &lt;&lt; \"unknown value\\n\"; break;\n}\n</code></pre>\n<p>The compiler is allowed to remove the <code>default</code> case, as all values that can be represented in the <code>enum_t</code> are explicitly enumerated in the <code>switch</code>, so the <code>default:</code> case cannot be hit in a well formed program. The optimizer can change that test into:</p>\n<pre><code>enum_t value = (enum_t) getInt();\nstd::cout &lt;&lt; \"valid\\n\";\n</code></pre>\n<p>And you might end up being surprised as of why all values are <em>valid</em> even when your test case sends messages with invalid values!</p>\n", "LastActivityDate": "2013-10-03T12:58:42.950", "CommentCount": "0", "CreationDate": "2013-10-03T12:58:42.950", "ParentId": "19159379", "Score": "2", "OwnerUserId": "36565"}, "19159481": {"Id": "19159481", "PostTypeId": "2", "Body": "<p>Yes, it is safe to cast from int type to enumeration type.</p>\n<p>\u00a7 4.5 Integral promotions</p>\n<blockquote>\n<p id=\"so_19159379_19159481_0\">A prvalue of an unscoped enumeration type whose underlying type is fixed (7.2) can be converted to a prvalue of its underlying type. Moreover, <strong>if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying type.</strong></p>\n</blockquote>\n<p>Just return enumeration type so you could avoid any cast troubles:</p>\n<pre><code>myNum_t getMessageNumType();\n</code></pre>\n", "LastEditorUserId": "951757", "LastActivityDate": "2013-10-03T12:52:44.490", "Score": "0", "CreationDate": "2013-10-03T12:39:45.897", "ParentId": "19159379", "CommentCount": "5", "OwnerUserId": "951757", "LastEditDate": "2013-10-03T12:52:44.490"}});