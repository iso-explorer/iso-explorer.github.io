post_cb({"bq_ids": {"n4140": {"so_10730682_10732001_3": {"length": 6, "quality": 1.0, "section_id": 4558}, "so_10730682_10732001_2": {"length": 12, "quality": 1.0, "section_id": 4557}, "so_10730682_10731800_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4660}, "so_10730682_10732001_1": {"length": 13, "quality": 1.0, "section_id": 4554}, "so_10730682_10731800_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_10730682_10732001_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_10730682_10732001_0": {"length": 9, "quality": 0.75, "section_id": 4652}}, "n3337": {"so_10730682_10732001_3": {"length": 6, "quality": 1.0, "section_id": 4388}, "so_10730682_10732001_2": {"length": 12, "quality": 1.0, "section_id": 4387}, "so_10730682_10732001_1": {"length": 13, "quality": 1.0, "section_id": 4384}, "so_10730682_10731800_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4470}, "so_10730682_10732001_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}, "so_10730682_10732001_0": {"length": 9, "quality": 0.75, "section_id": 4463}, "so_10730682_10731800_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}}, "n4659": {"so_10730682_10732001_2": {"length": 12, "quality": 1.0, "section_id": 5929}, "so_10730682_10731800_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 6020}, "so_10730682_10732001_1": {"length": 13, "quality": 1.0, "section_id": 5926}, "so_10730682_10732001_3": {"length": 6, "quality": 1.0, "section_id": 5930}, "so_10730682_10732001_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}, "so_10730682_10732001_0": {"length": 9, "quality": 0.75, "section_id": 6021}, "so_10730682_10731800_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}}}, "11508479": {"Id": "11508479", "PostTypeId": "2", "Body": "<p>I've committed a fix to libc++ such that this example now compiles, committed revision 160285.</p>\n<p>I believe libc++ was being overly aggressive in checking the argument list for complete types.</p>\n", "LastActivityDate": "2012-07-16T16:25:31.843", "Score": "4", "CreationDate": "2012-07-16T16:25:31.843", "ParentId": "10730682", "CommentCount": "2", "OwnerUserId": "576911"}, "10730682": {"ViewCount": "1558", "Body": "<p>Given:</p>\n<pre><code>#include &lt;functional&gt;\nclass world_building_gun;\nclass tile_bounding_box;\ntypedef std::function&lt;void (world_building_gun, tile_bounding_box)&gt; worldgen_function_t;\nvoid foo() {\n    worldgen_function_t v;\n    worldgen_function_t w(v);\n}\n</code></pre>\n<p>Should this compile?  My compilers say:</p>\n<p>Yes: GCC/stdlibc++ (also boost::function is yes in both GCC and Clang)</p>\n<p>No: Clang/libc++ ( <a href=\"http://libcxx.llvm.org/\" rel=\"nofollow\">http://libcxx.llvm.org/</a> , Clang 3.0, libc++ SVN as of today)</p>\n<p>(If \"no\" is the correct answer, I will fix my real code to put complete types in more headers or use boost::function.)</p>\n<p>EDIT: Here is the Clang error message:</p>\n<pre><code>In file included from foo.cpp:2:\nIn file included from /usr/include/c++/v1/functional:462:\n/usr/include/c++/v1/type_traits:2766:19: error: invalid appli\n    static_assert(sizeof(_Tp) &gt; 0, \"Type must be complete.\");\n                  ^~~~~~~~~~~\n/usr/include/c++/v1/type_traits:2752:15: note: in instantiation of template class 'std::__1::__check_complete&lt;world_buildin\n    : private __check_complete&lt;_Hp&gt;,\n              ^\n/usr/include/c++/v1/type_traits:2753:15: note: in instantiation of template class 'std::__1::__check_complete&lt;world_buildin\n      private __check_complete&lt;_T0, _Tp...&gt;\n              ^\n/usr/include/c++/v1/type_traits:2919:15: note: in instantiation of template class 'std::__1::__check_complete&lt;std::__1::fun\n      world_building_gun, tile_bounding_box&gt;' requested here\n    : private __check_complete&lt;_Fp, _Args...&gt;\n              ^\n/usr/include/c++/v1/type_traits:2930:11: note: in instantiation of template class 'std::__1::__invokable_imp&lt;std::__1::func\n      world_building_gun, tile_bounding_box&gt;' requested here\n          __invokable_imp&lt;_Fp, _Args...&gt;::value&gt;\n          ^\n/usr/include/c++/v1/functional:1115:33: note: in instantiation of template class 'std::__1::__invokable&lt;std::__1::function&lt;\n      world_building_gun, tile_bounding_box&gt;' requested here\n    template &lt;class _Fp, bool = __invokable&lt;_Fp&amp;, _ArgTypes...&gt;::value&gt;\n                                ^\n/usr/include/c++/v1/functional:1141:35: note: in instantiation of default argument for '__callable&lt;std::__1::function&lt;void (world_building_gun, tile_bounding_box)&gt; &gt;' required here\n              typename enable_if&lt;__callable&lt;_Fp&gt;::value&gt;::type* = 0);\n                                  ^~~~~~~~~~~~~~~\n/usr/include/c++/v1/functional:1140:7: note: while substituting deduced template arguments into function template 'function' [with _Fp = std::__1::function&lt;void\n      (world_building_gun, tile_bounding_box)&gt;]\n      function(_Fp,\n      ^\nfoo.cpp:4:7: note: forward declaration of 'world_building_gun'\nclass world_building_gun;\n      ^\nIn file included from foo.cpp:2:\nIn file included from /usr/include/c++/v1/functional:462:\n/usr/include/c++/v1/type_traits:2766:19: error: invalid application of 'sizeof' to an incomplete type 'tile_bounding_box'\n    static_assert(sizeof(_Tp) &gt; 0, \"Type must be complete.\");\n                  ^~~~~~~~~~~\n/usr/include/c++/v1/type_traits:2753:15: note: in instantiation of template class 'std::__1::__check_complete&lt;tile_bounding_box&gt;' requested here\n      private __check_complete&lt;_T0, _Tp...&gt;\n              ^\n/usr/include/c++/v1/type_traits:2753:15: note: in instantiation of template class 'std::__1::__check_complete&lt;world_building_gun, tile_bounding_box&gt;' requested here\n      private __check_complete&lt;_T0, _Tp...&gt;\n              ^\n/usr/include/c++/v1/type_traits:2919:15: note: in instantiation of template class 'std::__1::__check_complete&lt;std::__1::function&lt;void (world_building_gun, tile_bounding_box)&gt; &amp;,\n      world_building_gun, tile_bounding_box&gt;' requested here\n    : private __check_complete&lt;_Fp, _Args...&gt;\n              ^\n/usr/include/c++/v1/type_traits:2930:11: note: in instantiation of template class 'std::__1::__invokable_imp&lt;std::__1::function&lt;void (world_building_gun, tile_bounding_box)&gt; &amp;,\n      world_building_gun, tile_bounding_box&gt;' requested here\n          __invokable_imp&lt;_Fp, _Args...&gt;::value&gt;\n          ^\n/usr/include/c++/v1/functional:1115:33: note: in instantiation of template class 'std::__1::__invokable&lt;std::__1::function&lt;void (world_building_gun, tile_bounding_box)&gt; &amp;,\n      world_building_gun, tile_bounding_box&gt;' requested here\n    template &lt;class _Fp, bool = __invokable&lt;_Fp&amp;, _ArgTypes...&gt;::value&gt;\n                                ^\n/usr/include/c++/v1/functional:1141:35: note: in instantiation of default argument for '__callable&lt;std::__1::function&lt;void (world_building_gun, tile_bounding_box)&gt; &gt;' required here\n              typename enable_if&lt;__callable&lt;_Fp&gt;::value&gt;::type* = 0);\n                                  ^~~~~~~~~~~~~~~\n/usr/include/c++/v1/functional:1140:7: note: while substituting deduced template arguments into function template 'function' [with _Fp = std::__1::function&lt;void\n      (world_building_gun, tile_bounding_box)&gt;]\n      function(_Fp,\n      ^\nfoo.cpp:5:7: note: forward declaration of 'tile_bounding_box'\nclass tile_bounding_box;\n      ^\n2 errors generated.\n</code></pre>\n<p>Clang+libc++ compiles successfully if I delete the line \"worldgen_function_t w(v);\" or if I make the classes complete types.</p>\n", "AcceptedAnswerId": "10731800", "Title": "Does std::function's copy-constructor require the template type's argument types to be complete types?", "CreationDate": "2012-05-24T03:17:22.123", "Id": "10730682", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-05-24T04:18:11.957", "LastEditorUserId": "547512", "LastActivityDate": "2012-07-20T20:13:30.920", "Score": "6", "OwnerUserId": "547512", "Tags": "<c++><boost><c++11><tr1>", "AnswerCount": "3"}, "10731800": {"Id": "10731800", "PostTypeId": "2", "Body": "<p><strong>Edit:</strong> <a href=\"https://stackoverflow.com/a/11508479/500104\">Apperently</a>, this issue is now fixed, so the below text can be seen as history. :)</p>\n<hr>\n<p>The issue is indeed (as I predicted) with libc++'s SFINAE checks in the templated ctor (for a reasoning, check <a href=\"https://stackoverflow.com/q/5931214/500104\">this question</a>). It checks if the following (for example) is valid and gives a nice and clean error at the <em>construction</em> site rather than deep inside the guts of <code>std::function</code> (try the following example with <a href=\"http://ideone.com/JwfFT\" rel=\"nofollow noreferrer\">libstd++</a> or MSVC... <em>shudder</em>):</p>\n<pre><code>#include &lt;functional&gt;\n\nvoid f(int* p){}\n\nint main(){\n  std::function&lt;void(int)&gt; fun(f);\n}\n</code></pre>\n<p>libc++ will cause the compiler to spit out something along the lines of \"no constructor found that matches the argument list <code>void (*)(int*)</code>\", since the only applicable one (the templated ctor) gets SFINAE'd out.</p>\n<p>However, so that the <code>__callable</code> and <code>__invoke_imp</code> checks work, the argument and return types need to be complete, since otherwise implicit conversions wouldn't be taken into account here.</p>\n<p>The reason that the templated ctor is even looked at is that all ctors are enumerated before considering a best match (in this case the copy ctor).</p>\n<hr>\n<p>Now, the standard is very clear that the argument and return types need to be complete when constructing a <code>std::function</code> object from a callable object (aka calling the templated ctor):</p>\n<p><code>\u00a720.8.11.2.1 [func.wrap.func.con] p7</code></p>\n<pre><code>template &lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<blockquote>\n<p id=\"so_10730682_10731800_0\"><em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <strong><code>f</code> shall be Callable</strong> (20.8.11.2) for argument types <code>ArgTypes</code> and return type <code>R</code>. [...]</p>\n</blockquote>\n<p>(Note: \"Requires\" addresses the <em>user</em> of the functionality, not the implementer.)</p>\n<p><code>\u00a720.8.11.2 [func.wrap.func] p2</code></p>\n<blockquote>\n<p id=\"so_10730682_10731800_1\">A callable object <code>f</code> of type <code>F</code> is <em>Callable</em> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <em><code>INVOKE</code></em><code>(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is <strong>well formed</strong> (20.8.2).</p>\n</blockquote>\n<p><code>\u00a720.8.2 [func.req]</code></p>\n<blockquote>\n<p id=\"so_10730682_10731800_2\">p1 Define <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN)</code> as follows:</p>\n<ul>\n<li><code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</li>\n<li><code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</li>\n<li>[...]</li>\n<li><code>f(t1, t2, ..., tN)</code> in all other cases.</li>\n</ul>\n<p id=\"so_10730682_10731800_3\">p2 Define <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN, R)</code> as <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN)</code> implicitly converted to <code>R</code>.</p>\n</blockquote>\n<p>So, libc++ is certainly within its rights to do the SFINAE check in the templated ctor, since the types need to be complete, since otherwise you'd get undefined behaviour. However, it may be a bit unfortunate and be considered a defect that the safety check for a complete type triggers even if the actual SFINAE check is never needed (because the copy ctor will always be invoked). This may be alleviated by making the <code>callable</code> check a lazy one, like</p>\n<pre><code>template&lt;bool Copy, class F&gt;\nstruct lazy_callable{\n  static bool const value = callable&lt;F&gt;::value;\n};\n\ntemplate&lt;class F&gt;\nstruct lazy_callable&lt;true, F&gt;{\n  static bool const value = false;\n};\n\ntemplate&lt;class F&gt;\nfunction(F f, typename enable_if&lt;lazy_callable&lt;!std::is_same&lt;F,function&gt;::value&gt;::type* = 0);\n</code></pre>\n<p>This should only trigger the <code>callable</code> SFINAE check if <code>F</code> is not actually <code>std::function&lt;...&gt;</code>.</p>\n<p>Man, I <em>may</em> have digressed a bit here at the end...</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-20T20:13:30.920", "Score": "4", "CreationDate": "2012-05-24T05:45:30.007", "ParentId": "10730682", "CommentCount": "4", "LastEditDate": "2017-05-23T12:31:33.607", "OwnerUserId": "500104"}, "10732001": {"Id": "10732001", "PostTypeId": "2", "Body": "<p>I'd say no. From 20.8.11.2 Class template function [func.wrap.func], we have:</p>\n<blockquote>\n<p id=\"so_10730682_10732001_0\">3 The <code>function</code> class template is a call wrapper (20.8.1) whose call signature (20.8.1) is <code>R(ArgTypes...)</code>.</p>\n</blockquote>\n<p>In 20.8.1 Definitions [func.def ], we get the following definitions as to what constitutes a call wrapper type, a call wrapper and a call signature:</p>\n<blockquote>\n<p id=\"so_10730682_10732001_1\">2 A call signature is the name of a return type followed by a parenthesized comma-separated list of zero or more argument types.</p>\n<p id=\"so_10730682_10732001_2\">5 A call wrapper type is a type that holds a callable object and supports a call operation that forwards to that object.</p>\n<p id=\"so_10730682_10732001_3\">6 A call wrapper is an object of a call wrapper type.</p>\n</blockquote>\n<p>Notice how paragraph 2 doesn't mention completeness of types.</p>\n<p>To cut a story short (a lot of definitions are involved), the meaning of 'callable object' here means either a functor (the familiar notion, i.e. something that can be used like a function) or a pointer-to-member. Furthermore the Standard also describe the <em>Callable</em> concept in 20.8.11.2 paragraph 2:</p>\n<blockquote>\n<p id=\"so_10730682_10732001_4\">A callable object <code>f</code> of type <code>F</code> is <em>Callable</em> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <em>INVOKE</em><code>(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well formed (20.8.2).</p>\n</blockquote>\n<p>(The <em>INVOKE</em> bit is an imaginary function that the Standard uses to define how functors and pointers to members are, well, invoked.)</p>\n<p>What I think is the most important conclusion from that is the following requirement:</p>\n<ul>\n<li>given a callable object that is <em>Callable</em> with signature <code>R(A...)</code>, then <code>R</code> and <code>A...</code> are complete (or possibly <code>R</code> is <code>void</code>) by virtue of the <em>INVOKE</em> expression (i.e. otherwise it would not be well-formed, notice the use of <code>declval&lt;ArgTypes&gt;()...</code>)</li>\n</ul>\n<p>My argument now rests on '[the] call operation that forwards to that object' in the definition of call wrappers, which I think is intentionally left vague so as to not be overly restrictive. In the case of <code>std::function&lt;Sig&gt;</code> where some incomplete types are involved in <code>Sig</code> then we could define this operation as being 'first complete the types, <em>then</em> treat <code>std::function&lt;Sig&gt;</code> as a callable object type of call signature <code>Sig</code>'.</p>\n<p>Given that, here are the key points of my argument:</p>\n<ul>\n<li><code>std::function</code> is not described as being a callable object or as being <em>Callable</em> for any signature</li>\n<li>invoking an <code>std::function</code> is done in terms of <em>INVOKE</em> (20.8.11.2.4 function invocation [func.wrap.func.inv])</li>\n<li>constructing an <code>std::function</code> from a callable object is in terms of <em>Callable</em> with the call signature of <code>std::function</code> (20.8.11.2.1 function construct/copy/destroy [func.wrap.func.con] paragraph 7)</li>\n<li>calling the <code>target</code> member of <code>std::function</code> is in terms of <em>Callable</em> with the call signature of <code>std::function</code> (20.8.11.2.5 function target access [func.wrap.func.targ])</li>\n<li>all other operations of <code>std::function</code> are not described in terms of callable object(*) , <em>Callable</em>, <em>INVOKE</em> or otherwise require that the call signature of <code>std::function</code> involve complete types</li>\n</ul>\n<p>(*) except in the case of one constructor where the description contains \"shall not throw exceptions if <code>f</code>\u2019s target is a callable object passed via <code>reference_wrapper</code> or a function pointer\". I think in the context it's clear that this doesn't affect the argument. For what it's worth this constructor is not involved in the snippet of the OP.</p>\n<p>So I'd say unless you do use one of those operations that indirectly require the signature to involve complete types, you're good to go.</p>\n<hr>\n<p>It's all well and good to analyze what the Standard prescribes but it's also important to consider what is the <em>intent</em> of the Standard. In this case I think it is very much desirable and expected that <code>std::function</code> does not require that the types of the call signature be complete. Consider the following:</p>\n<pre><code>// in a_fwd.hpp\nstruct incomplete;\nusing callback_type = std::function&lt;void(incomplete)&gt;;\ncallback_type make_callback();\n\n// in b.hpp; depends on a_fwd.hpp\n#include \"a_fwd.hpp\"\nvoid eat_callback(callback_type);\n</code></pre>\n<p>Then without the requirement an unrelated TU, let's call it C, that is a client of B can do:</p>\n<pre><code>// in c.cpp\n#include \"b.hpp\"\n\n// somewhere in e.g. a function body\neat_callback(make_callback());\n</code></pre>\n<p>This is type-safe and minimizes the coupling since only translation unit B need to know about the details of translation unit A.</p>\n<p>Furthermore both Boost.Function and libstdc++ have demonstrated that it is possible to implement <code>std::function</code> without such a requirement.</p>\n</hr>", "LastActivityDate": "2012-05-24T06:06:15.277", "Score": "3", "CreationDate": "2012-05-24T06:06:15.277", "ParentId": "10730682", "CommentCount": "0", "OwnerUserId": "726300"}});