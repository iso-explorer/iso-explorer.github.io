post_cb({"44122578": {"ParentId": "44122476", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-22T21:42:25.357", "Score": "0", "LastEditorUserId": "2877241", "LastEditDate": "2017-05-22T21:50:35.857", "Id": "44122578", "OwnerUserId": "2877241", "Body": "<p>It means that the function in the derived class can have its own default arguments or neither default argument.</p>\n<p>For example</p>\n<pre><code>struct A {\n    virtual void f(int a = 7)\n    {\n        std::cout &lt;&lt; \"F(\" &lt;&lt; a &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n};\nstruct B : public A {\n    void f(int a = 10)\n    {\n        std::cout &lt;&lt; \"F(\" &lt;&lt; a &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n};\n\nB* pb = new B;\nA* pa = pb;\npa-&gt;f(); // OK, calls pa-&gt;B::f(7)\npb-&gt;f(); // OK, calls pa-&gt;B::f(10)\n</code></pre>\n<p>In the first call</p>\n<pre><code>pa-&gt;f(); // OK, calls pa-&gt;B::f(7)\n</code></pre>\n<p>there is used the default argument of the declaration of the function f according to the static type of the pointer <code>pa</code> that is the declaration of the function in class A. </p>\n<p>In the second call</p>\n<pre><code>pb-&gt;f(); // OK, calls pa-&gt;B::f(10)\n</code></pre>\n<p>there is used the default argument of the declaration of the function f according to the static type of the pointer <code>pb</code> that is the declaration of the function in class B. </p>\n", "LastActivityDate": "2017-05-22T21:50:35.857"}, "44122476": {"CommentCount": "1", "ViewCount": "37", "CreationDate": "2017-05-22T21:34:37.340", "LastActivityDate": "2017-05-22T21:50:35.857", "Title": "Apparent contradiction in [dcl.fct.default]/10", "PostTypeId": "1", "Id": "44122476", "Score": "2", "Body": "<p><a href=\"http://eel.is/c++draft/dcl.fct.default#10\" rel=\"nofollow noreferrer\">[dcl.fct.default]/10</a>:</p>\n<blockquote>\n<p id=\"so_44122476_44122476_0\">A virtual function call (10.3) uses the default arguments in the\n  declaration of the virtual function determined by the static type of\n  the pointer or reference denoting the object. <strong>An overriding function\n  in a derived class does not acquire default arguments from the\n  function it overrides</strong>. [ Example:</p>\n<pre><code>struct A {\n    virtual void f(int a = 7);\n};\nstruct B : public A {\n    void f(int a);\n};\nvoid m() {\n    B* pb = new B;\n    A* pa = pb;\n    pa-&gt;f(); // OK, calls pa-&gt;B::f(7)\n    pb-&gt;f(); // error: wrong number of arguments for B::f()\n}\n</code></pre>\n<p id=\"so_44122476_44122476_1\">\u2014end example ]</p>\n</blockquote>\n<p>The paragraph and the example are clear to me with the exception of the statement emphasized by me above. When I read this, I get the impression that <strong>it contradicts</strong> the first part of the paragraph, i.e. that a virtual function call uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "5479741", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_44122476_44122476_0": {"section_id": 3261, "quality": 0.9285714285714286, "length": 26}, "so_44122476_44122589_1": {"section_id": 3261, "quality": 1.0, "length": 10}, "so_44122476_44122589_0": {"section_id": 3261, "quality": 0.9411764705882353, "length": 16}, "so_44122476_44122589_2": {"section_id": 3261, "quality": 0.7272727272727273, "length": 16}}, "n3337": {"so_44122476_44122476_0": {"section_id": 3133, "quality": 0.9285714285714286, "length": 26}, "so_44122476_44122589_1": {"section_id": 3133, "quality": 1.0, "length": 10}, "so_44122476_44122589_0": {"section_id": 3133, "quality": 0.9411764705882353, "length": 16}, "so_44122476_44122589_2": {"section_id": 3133, "quality": 0.7272727272727273, "length": 16}}, "n4659": {"so_44122476_44122589_1": {"section_id": 4019, "quality": 1.0, "length": 10}, "so_44122476_44122476_0": {"section_id": 4019, "quality": 0.9285714285714286, "length": 26}, "so_44122476_44122589_0": {"section_id": 4019, "quality": 0.9411764705882353, "length": 16}, "so_44122476_44122589_2": {"section_id": 4019, "quality": 0.7272727272727273, "length": 16}}}, "44122589": {"ParentId": "44122476", "CommentCount": "0", "Body": "<p>They're not contradictory, because they refer to different things.</p>\n<blockquote>\n<p id=\"so_44122476_44122589_0\">A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object.</p>\n</blockquote>\n<p>This means the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base\n{\n   virtual void foo(int x = 3) { std::cerr &lt;&lt; x &lt;&lt; '\\n'; }\n};\n\nstruct Derived : Base\n{\n   virtual void foo(int x = 4) { std::cerr &lt;&lt; x &lt;&lt; '\\n'; }\n};\n\nint main()\n{\n   Derived d;\n   Base* ptr = &amp;d;\n   ptr-&gt;foo(); // prints 3, not 4\n}\n</code></pre>\n<h3>(<a href=\"http://coliru.stacked-crooked.com/a/0c60087ee7904922\" rel=\"nofollow noreferrer\">live demo</a>)</h3>\n<blockquote>\n<p id=\"so_44122476_44122589_1\">An overriding function in a derived class does not acquire default arguments from the function it overrides.</p>\n</blockquote>\n<p>This, on the other hand, means the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base\n{\n   virtual void foo(int x = 3) { std::cerr &lt;&lt; x &lt;&lt; '\\n'; }\n};\n\nstruct Derived : Base\n{\n   virtual void foo(int x) { std::cerr &lt;&lt; x &lt;&lt; '\\n'; }\n};\n\nint main()\n{\n   Derived d;\n   d.foo(); // doesn't compile; missing value for x\n}\n</code></pre>\n<h3>(<a href=\"http://coliru.stacked-crooked.com/a/6d41bd26e51590e9\" rel=\"nofollow noreferrer\">live demo</a>)</h3>\n<blockquote>\n<p id=\"so_44122476_44122589_2\">I get the impression that it contradicts the first part of the paragraph, i.e. that a virtual function call uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object.</p>\n</blockquote>\n<p>Nope. It means that <em>if</em> you access the object through its Base interface, you'll get the Base's default arguments\u2026 and that if you access the object through its Derived interface, and the Derived doesn't have default arguments of its own, you won't get the Base's. Two very different sides to the same coin.</p>\n<p>And, to be fair, the quoted standard text gives the exact same examples.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "44122589", "Score": "4", "CreationDate": "2017-05-22T21:43:21.590", "LastActivityDate": "2017-05-22T21:43:21.590"}});