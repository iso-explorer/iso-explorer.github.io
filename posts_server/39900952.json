post_cb({"39901200": {"ParentId": "39900952", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.22.1.3p9\" rel=\"nofollow\">The C11 standard, in 7.22.1.3p9</a>, has this to say about C's <code>strtof</code>/<code>strtod</code>/<code>strtold</code> (which should be what the C++ versions use underneath, at least judging from <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow\">cppreference</a>):</p>\n<blockquote>\n<p id=\"so_39900952_39901200_0\">If the subject sequence has the decimal form and at most <code>DECIMAL_DIG</code> (defined in <code>&lt;float.h&gt;</code>) significant digits, the result should be correctly rounded.</p>\n</blockquote>\n<p>Given that both of your code lines have the same number of significant digits, they <em>should</em> behave the same.  But this is merely conjecture based on the fact that the standard mentions \u201csignificant digits\u201d here at all; it is not mentioned anywhere else, and the standard does not say anything more explicit regarding leading (before the decimal point) or trailing (after the decimal point) zeroes.</p>\n", "OwnerUserId": "3233921", "LastEditorUserId": "3233921", "LastEditDate": "2016-10-06T16:45:03.567", "Id": "39901200", "Score": "2", "CreationDate": "2016-10-06T16:27:17.457", "LastActivityDate": "2016-10-06T16:45:03.567"}, "39913976": {"ParentId": "39900952", "CommentCount": "0", "Body": "<p>The C++ 14 (\u00a721.5) standard states that:</p>\n<blockquote>\n<p id=\"so_39900952_39913976_0\"><code>float stof(const string&amp; str, size_t* idx = 0);</code></p>\n<p id=\"so_39900952_39913976_1\"><code>double stod(const string&amp; str, size_t* idx = 0);</code></p>\n<p id=\"so_39900952_39913976_2\"><code>long double stold(const string&amp; str, size_t* idx = 0);</code></p>\n<p id=\"so_39900952_39913976_3\">Effects: the first two functions call <code>strtod(str.c_str(), ptr)</code> and the third function calls <code>strtold( str.c_str(), ptr)</code>. Each function returns the converted result, if any. The argument <code>ptr</code> designates a pointer to an object internal to the function that is used to determine what to store at <code>*idx</code>. If the function does not throw an exception and <code>idx != 0</code>, the function stores in <code>*idx</code> the index of the first unconverted element of <code>str</code>.</p>\n</blockquote>\n<p>In many cases therefore they will be the same, but the intermediate <code>double</code> does open the potential for <a href=\"http://www.exploringbinary.com/double-rounding-errors-in-floating-point-conversions/\" rel=\"nofollow\">double rounding</a>. E.g. if <code>str = \"1.0000000596046448\"</code>, then the closest <code>float</code> (assuming IEEE754 arithmetic) is <code>1.0000001f</code>, whereas the closest <code>double</code> is exactly halfway between <code>1.0f</code> and <code>1.0000001f</code>, and so subsequent conversion to <code>float</code> will round down to <code>1.0f</code>.</p>\n<p>That's the theory at least. In practice, however, I am unable to recreate this: <a href=\"http://ideone.com/NMRy14\" rel=\"nofollow\">http://ideone.com/NMRy14</a></p>\n", "OwnerUserId": "392585", "PostTypeId": "2", "Id": "39913976", "Score": "1", "CreationDate": "2016-10-07T09:31:22.097", "LastActivityDate": "2016-10-07T09:31:22.097"}, "bq_ids": {"n4140": {"so_39900952_39913976_0": {"section_id": 1868, "quality": 1.0, "length": 6}, "so_39900952_39913976_3": {"section_id": 1869, "quality": 0.9302325581395349, "length": 40}, "so_39900952_39913976_1": {"section_id": 1868, "quality": 1.0, "length": 6}, "so_39900952_39913976_2": {"section_id": 1868, "quality": 1.0, "length": 7}}, "n3337": {"so_39900952_39913976_0": {"section_id": 1862, "quality": 1.0, "length": 6}, "so_39900952_39913976_3": {"section_id": 1863, "quality": 0.9302325581395349, "length": 40}, "so_39900952_39913976_1": {"section_id": 1862, "quality": 1.0, "length": 6}, "so_39900952_39913976_2": {"section_id": 1862, "quality": 1.0, "length": 7}}, "n4659": {"so_39900952_39913976_0": {"section_id": 2040, "quality": 1.0, "length": 6}, "so_39900952_39913976_3": {"section_id": 2038, "quality": 0.813953488372093, "length": 35}, "so_39900952_39913976_1": {"section_id": 2040, "quality": 1.0, "length": 6}, "so_39900952_39913976_2": {"section_id": 2040, "quality": 1.0, "length": 7}}}, "39900952": {"CommentCount": "2", "AcceptedAnswerId": "39901200", "CreationDate": "2016-10-06T16:14:18.187", "LastActivityDate": "2016-10-07T09:31:22.097", "PostTypeId": "1", "ViewCount": "256", "FavoriteCount": "2", "Title": "Is stof, strtof deterministic?", "Id": "39900952", "Score": "2", "Body": "<p>I'm reading floats from a string. They can be written in a various form, so </p>\n<pre><code>float f1 = strtof(\"999999999999.16\");\nfloat f2 = stof(\"000999999999999.1600000\");\nassert(f1 == f2);\n</code></pre>\n<p>Can I be sure that the assertion will be always true, no matter of leading and trailing zeros? The separator will be always a dot, <code>stof</code> doesn't handle the comma.</p>\n", "Tags": "<c++><floating-point><deterministic>", "OwnerUserId": "1060159", "AnswerCount": "2"}});