post_cb({"6415550": {"ParentId": "6415509", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><em><strong>1.    C++ standard forbids using locally-defined classes with templates.</strong></em></p>\n<p><strong>14.3.1/2</strong>: <em>A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a template-argument for a template type-parameter.</em></p>\n<p>A code example:  </p>\n<pre><code>    template &lt;class T&gt; class X { /* ... */ };\n    void f()\n    {\n      struct S { /* ... */ };\n      X&lt;S&gt; x3;  // error: local type used as\n                //  template-argument\n      X&lt;S*&gt; x4; // error: pointer to local type\n                //  used as template-argument\n    }\n</code></pre>\n<p>Here is a little more reference from IBM documentation:</p>\n<p><em><strong>2.   Declarations in a local class can only use type names, enumerations, static variables from the enclosing scope, as well as external variables and functions.</strong></em></p>\n<p>A Code Example:  </p>\n<pre><code>int x;                         // global variable\nvoid f()                       // function definition\n{\n      static int y;            // static variable y can be used by\n                               // local class\n      int x;                   // auto variable x cannot be used by\n                               // local class\n      extern int g();          // extern function g can be used by\n                               // local class\n\n      class local              // local class\n      {\n            int g() { return x; }      // error, local variable x\n                                       // cannot be used by g\n            int h() { return y; }      // valid,static variable y\n            int k() { return ::x; }    // valid, global x\n            int l() { return g(); }    // valid, extern function g\n      };\n}\n\nint main()\n{\n      local* z;                // error: the class local is not visible\n      return 0;\n}\n</code></pre>\n<p><em><strong>3.   A local class cannot have static data members</strong></em></p>\n<p>A Code Example: </p>\n<pre><code>void f()\n{\n    class local\n    {\n       int f();              // error, local class has noninline\n                             // member function\n       int g() {return 0;}   // valid, inline member function\n       static int a;         // error, static is not allowed for\n                             // local class\n       int b;                // valid, nonstatic variable\n    };\n}\n</code></pre>\n", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2011-06-20T18:39:11.127", "Id": "6415550", "Score": "22", "CreationDate": "2011-06-20T18:12:30.073", "LastActivityDate": "2011-06-20T18:39:11.127"}, "6415621": {"ParentId": "6415509", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The scope of the local classes is the function in which they're defined.But that isn't interesting in itself<sup>1</sup>.</p>\n<p><sup>What makes local classes interesting is that <strong>if</strong> they implement some interface, then you can create instances of it (using <code>new</code>) and return them, thereby making <em>the implementation</em> accessible <strong>through the base class pointer</strong> even outside the function.</sup></p>\n<p>Some other facts about local classes:</p>\n<ul>\n<li><p>They cannot define static member variables.</p></li>\n<li><p>They cannot access nonstatic \"automatic\" local variables of the enclosing function. But they can access the <code>static</code> variables.</p></li>\n<li><p>They can be used in template functions. They cannot be used as <em>template argument</em>, however.</p></li>\n<li><p>If they defined inside template function, then they can use the template parameters of the enclosing function.</p></li>\n<li><p>Local classes are final, that means users outside the function cannot derive from local class to function. Without local classes, you'd have to add an unnamed namespace in separate translation unit.</p></li>\n<li><p>Local classes are used to create <a href=\"http://en.wikipedia.org/wiki/Trampoline_%28computers%29\" rel=\"nofollow\">trampoline functions</a> usually known as <em>thunks</em>.</p></li>\n</ul>\n<p>Some references from the Standard (2003)</p>\n<h1>9.8 Local class declarations [class.local]</h1>\n<blockquote>\n<p id=\"so_6415509_6415621_0\">\\1. A class can be defined within a function definition; such a class is\n  called a local class. The name of a\n  local class is local to its enclosing\n  scope. The local class is in the scope\n  of the enclosing scope, and has the\n  same access to names outside the\n  function as does the enclosing\n  function. Declarations in a local\n  class can use only type names, static\n  variables, extern variables and\n  functions, and enumerators from the\n  enclosing scope.</p>\n</blockquote>\n<pre><code>[Example:\n\nint x;\nvoid f()\n{\n   static int s ;\n   int x;\n   extern int g();\n\n   struct local {\n      int g() { return x; } // error: x is auto\n      int h() { return s; } // OK\n      int k() { return ::x; } // OK\n      int l() { return g(); } // OK\n   };\n// ...\n}\nlocal* p = 0; // error: local not in scope\n\n\u2014end example]\n</code></pre>\n<blockquote>\n<p id=\"so_6415509_6415621_1\">\\2. An enclosing function has no special access to members of the local\n  class; it obeys the usual access rules\n  (clause 11). Member functions of a\n  local class shall be defined within\n  their class definition, if they are\n  defined at all.</p>\n<p id=\"so_6415509_6415621_2\">\\3. If class X is a local class a nested class Y may be declared in\n  class X and later defined in the\n  definition of class X or be later\n  defined in the same scope as the\n  definition of class X. A class nested\n  within a local class is a local class.</p>\n<p id=\"so_6415509_6415621_3\">\\4. A local class shall not have static data members.</p>\n</blockquote>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-06-20T18:35:59.140", "Id": "6415621", "Score": "2", "CreationDate": "2011-06-20T18:17:55.823", "LastActivityDate": "2011-06-20T18:35:59.140"}, "6415617": {"ParentId": "6415509", "CommentCount": "0", "Body": "<p>Local structs / classes can't have static data members, only static member functions. Also, they can't be templates.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "6415617", "Score": "1", "CreationDate": "2011-06-20T18:17:48.977", "LastActivityDate": "2011-06-20T18:17:48.977"}, "6415658": {"ParentId": "6415509", "CommentCount": "1", "Body": "<p>local structs are perfectly legal, even in C++98. You cannot use them with templates in C++98 though, whereas you can in C++0x. g++ 4.5 supports using local structs with templates in -std=c++0x mode.  </p>\n", "Id": "6415658", "PostTypeId": "2", "OwnerDisplayName": "user195488", "Score": "0", "CreationDate": "2011-06-20T18:21:29.403", "LastActivityDate": "2011-06-20T18:21:29.403"}, "6415542": {"ParentId": "6415509", "CommentCount": "1", "Body": "<p>Yes. Local classes can't be used as template parameters in C++03</p>\n", "OwnerUserId": "785937", "PostTypeId": "2", "Id": "6415542", "Score": "0", "CreationDate": "2011-06-20T18:11:49.323", "LastActivityDate": "2011-06-20T18:11:49.323"}, "6415509": {"CommentCount": "7", "AcceptedAnswerId": "6415550", "PostTypeId": "1", "LastEditorUserId": "82320", "CreationDate": "2011-06-20T18:08:36.487", "LastActivityDate": "2013-11-26T21:48:26.480", "LastEditDate": "2013-11-26T21:48:26.480", "ViewCount": "1862", "FavoriteCount": "2", "Title": "What restrictions does ISO C++03 place on structs defined at function scope?", "Id": "6415509", "Score": "14", "Body": "<p>We're not allowed to define a functor struct inside a function because one is not allowed to use function declared structs in the instantiation of function templates.</p>\n<p>Are there any other significant pitfalls to be aware of? E.g. would this be bad:</p>\n<pre><code>int foo()\n{\n    struct Scratch\n    {\n        int a, b, c;\n    };\n    std::vector&lt;Scratch&gt; workingBuffer;\n    //Blah Blah\n}\n</code></pre>\n", "Tags": "<c++><c++03>", "OwnerUserId": "82320", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_6415509_6415621_1": {"section_id": 5930, "quality": 0.9583333333333334, "length": 23}, "so_6415509_6415621_3": {"section_id": 5910, "quality": 1.0, "length": 6}, "so_6415509_6415621_0": {"section_id": 5929, "quality": 0.7291666666666666, "length": 35}, "so_6415509_6415621_2": {"section_id": 5931, "quality": 1.0, "length": 25}}, "n3337": {"so_6415509_6415621_1": {"section_id": 5702, "quality": 0.9583333333333334, "length": 23}, "so_6415509_6415621_3": {"section_id": 5682, "quality": 1.0, "length": 6}, "so_6415509_6415621_0": {"section_id": 5701, "quality": 0.7291666666666666, "length": 35}, "so_6415509_6415621_2": {"section_id": 5703, "quality": 1.0, "length": 25}}, "n4659": {"so_6415509_6415621_1": {"section_id": 7415, "quality": 0.9583333333333334, "length": 23}, "so_6415509_6415621_3": {"section_id": 7392, "quality": 1.0, "length": 6}, "so_6415509_6415621_0": {"section_id": 7414, "quality": 0.7083333333333334, "length": 34}, "so_6415509_6415621_2": {"section_id": 7416, "quality": 1.0, "length": 25}}}});