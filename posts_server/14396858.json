post_cb({"14399510": {"ParentId": "14396858", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>To explain your real code you just need the C++ versions of the quotes from the C standard that Lundin gave in comments:</p>\n<pre><code>int number = ~0;\nnumber = number &lt;&lt; 4;\n</code></pre>\n<p>Undefined behavior. [expr.shift] says</p>\n<blockquote>\n<p id=\"so_14396858_14399510_0\">The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated\n  bits are zero-\ufb01lled. If E1 has an unsigned type, the value of the\n  result is E1 \u00d7 2<sup>E2</sup>, reduced modulo one more than the maximum value\n  representable in the result type. Otherwise, <strong>if E1 has a signed type\n  and non-negative value</strong>, and E1\u00d72<sup>E2</sup> is representable in the result\n  type, then that is the resulting value; <strong>otherwise, the behavior is\n  unde\ufb01ned</strong>.</p>\n</blockquote>\n<pre><code>number = ~0;\nnumber = number &gt;&gt; 4;\n</code></pre>\n<p>Implementation-defined result, in this case your implementation gave you an arithmetic shift:</p>\n<blockquote>\n<p id=\"so_14396858_14399510_1\">The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has\n  an unsigned type or if E1 has a signed type and a non-negative value,\n  the value of the result is the integral part of the quotient of\n  E1/2<sup>E2</sup>. <strong>If E1 has a signed type and a negative value, the resulting\n  value is implementation-de\ufb01ned</strong></p>\n</blockquote>\n<p>You should use an unsigned type:</p>\n<pre><code>unsigned int number = -1;\nnumber = number &gt;&gt; 4;\nstd::cout &lt;&lt; std::hex &lt;&lt; number &lt;&lt; std::endl;\n</code></pre>\n<p>Output:</p>\n<pre><code>0x0fffffff\n</code></pre>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2013-01-18T13:06:10.030", "Id": "14399510", "Score": "3", "CreationDate": "2013-01-18T12:58:47.350", "LastActivityDate": "2013-01-18T13:06:10.030"}, "14396890": {"ParentId": "14396858", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you explicitilhy shift 0xff it works as you expected </p>\n<pre><code>cout &lt;&lt; (0xff &gt;&gt; 3) &lt;&lt; endl; // 31\n</code></pre>\n<p>It should be possible only if <code>0xff</code> is in type of signed width 8 (<code>char</code> and <code>signed char</code> on popular platforms). </p>\n<hr>\n<p>So, in common case:</p>\n<p>You need use unsigned ints</p>\n<p><code>(unsigned type)0xff</code></p>\n<p>right shift works as division by 2(with rounding down, if I understand correctly).</p>\n<p>So when you have 1 as first bit, you have <strong>negative</strong> value and after division it's <strong>negative</strong> again.</p>\n</hr>", "OwnerUserId": "768110", "LastEditorUserId": "768110", "LastEditDate": "2013-03-03T23:12:37.577", "Id": "14396890", "Score": "7", "CreationDate": "2013-01-18T10:27:15.947", "LastActivityDate": "2013-03-03T23:12:37.577"}, "14396858": {"CommentCount": "9", "AcceptedAnswerId": "14397362", "PostTypeId": "1", "LastEditorUserId": "168868", "CreationDate": "2013-01-18T10:25:52.733", "LastActivityDate": "2015-06-19T11:04:27.800", "LastEditDate": "2013-01-18T17:21:07.553", "ViewCount": "6878", "FavoriteCount": "0", "Title": "Right shift with zeros at the beginning", "Id": "14396858", "Score": "7", "Body": "<p>I'm trying to do a kind of left shift that would add zeros at the beginning instead of ones. For example, if I left shift <code>0xff</code>, I get this:</p>\n<pre><code>0xff &lt;&lt; 3 = 11111000\n</code></pre>\n<p>However, if I right shift it, I get this:</p>\n<pre><code>0xff &gt;&gt; 3 = 11111111\n</code></pre>\n<p>Is there any operation I could use to get the equivalent of a left shift? i.e. I would like to get this:</p>\n<pre><code>00011111\n</code></pre>\n<p>Any suggestion?</p>\n<p><strong>Edit</strong></p>\n<p>To answer the comments, here is the code I'm using:</p>\n<pre><code>int number = ~0;\nnumber = number &lt;&lt; 4;   \nstd::cout &lt;&lt; std::hex &lt;&lt; number &lt;&lt; std::endl;\n\nnumber = ~0;\nnumber = number &gt;&gt; 4;\nstd::cout &lt;&lt; std::hex &lt;&lt; number &lt;&lt; std::endl;\n</code></pre>\n<p>output:</p>\n<pre><code>fffffff0\nffffffff\n</code></pre>\n<p>Since it seems that in general it should work, I'm interested as to why this specific code doesn't. Any idea?</p>\n", "Tags": "<c++><c><bit-manipulation><bit-shift>", "OwnerUserId": "561309", "AnswerCount": "5"}, "14397362": {"ParentId": "14396858", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is how C and binary arithmetic both work:</p>\n<p>If you left shift <code>0xff &lt;&lt; 3</code>, you get binary: <code>00000000 11111111 &lt;&lt; 3 = 00000111 11111000</code></p>\n<p>If you right shift <code>0xff &gt;&gt; 3</code>, you get binary: <code>00000000 11111111 &gt;&gt; 3 = 00000000 00011111</code></p>\n<p><code>0xff</code> is a (signed) int with the positive value <code>255</code>. Since it is positive, the outcome of shifting it is well-defined behavior in both C and C++. It will not do any arithmetic shifts nor any kind or poorly-defined behavior.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n\n  printf(\"%.4X %d\\n\", 0xff &lt;&lt; 3, 0xff &lt;&lt; 3);\n  printf(\"%.4X %d\\n\", 0xff &gt;&gt; 3, 0xff &gt;&gt; 3);\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>07F8 2040\n001F 31\n</code></pre>\n<p>So you are doing something strange in your program because it doesn't work as expected. Perhaps you are using char variables or C++ character literals.</p>\n<hr>\n<p>Source: ISO 9899:2011 6.5.7.</p>\n<hr>\n<p><strong>EDIT after question update</strong></p>\n<p><code>int number = ~0;</code> gives you a negative number equivalent to -1, assuming two's complement.</p>\n<p><code>number = number &lt;&lt; 4;</code> invokes undefined behavior, since you left shift a negative number. The program implements undefined behavior correctly, since it either does something or nothing at all. It may print fffffff0 or it may print a pink elephant, or it may format the hard drive.</p>\n<p><code>number = number &gt;&gt; 4;</code> invokes implementation-defined behavior. In your case, your compiler preserves the sign bit. This is known as <a href=\"http://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow\">arithmetic shift</a>, and arithmetic right shift works in such a way that the MSB is filled with whatever bit value it had before the shift. So if you have a negative number, you will experience that the program is \"shifting in ones\".</p>\n<p>In 99% of all real world cases, it doesn't make sense to use bitwise operators on signed numbers. Therefore, always ensure that you are using unsigned numbers, and that none of the dangerous implicit conversion rules in C/C++ transforms them into signed numbers (for more info about dangerous conversions, see \"the integer promotion rules\" and \"the usual arithmetic conversions\", plenty of good info about those on SO).</p>\n<p><strong>EDIT 2</strong>, some info from the C99 standard's rationale document V5.10:</p>\n<blockquote>\n<p id=\"so_14396858_14397362_0\">6.5.7 Bitwise shift operators</p>\n<p id=\"so_14396858_14397362_1\">The description of shift operators in K&amp;R suggests that shifting by a\n  long count should force the left operand to be widened to long before\n  being shifted. A more intuitive practice, endorsed by the C89\n  Committee, is that the type of the shift count has no bearing on the\n  type of the result. </p>\n<p id=\"so_14396858_14397362_2\">QUIET CHANGE IN C89</p>\n<p id=\"so_14396858_14397362_3\">Shifting by a long count no longer coerces the shifted operand to\n  long. The C89 Committee affirmed the freedom in implementation granted\n  by K&amp;R in not requiring the signed right shift operation to sign\n  extend, since such a requirement might slow down fast code and since\n  the usefulness of sign extended shifts is marginal. (Shifting a\n  negative two\u2019s complement integer arithmetically right one place is\n  not the same as dividing by two!)</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "584518", "LastEditorUserId": "584518", "LastEditDate": "2015-04-07T06:51:48.313", "Id": "14397362", "Score": "10", "CreationDate": "2013-01-18T10:52:03.103", "LastActivityDate": "2015-04-07T06:51:48.313"}, "30936572": {"ParentId": "14396858", "CommentCount": "0", "Body": "<p>To add my 5 cents worth here...\nI'm facing exactly the same problem as this.lau! I've done some perfunctory research on this and these are my results:</p>\n<pre><code>typedef unsigned int Uint;\n#define U31 0x7FFFFFFF\n#define U32 0xFFFFFFFF\n\nprintf (\"U31 right shifted: 0x%08x\\n\", (U31 &gt;&gt; 30));\nprintf (\"U32 right shifted: 0x%08x\\n\", (U32 &gt;&gt; 30));\n\nOutput:\nU31 right shifted: 0x00000001 (expected)\nU32 right shifted: 0xffffffff (not expected)\n</code></pre>\n<p>It would appear (in the absence of anyone with detailed knowledge) that the C compiler in XCode for Mac OS X v5.0.1 reserves the MSB as a carry bit that gets pulled along with each shift.</p>\n<p>Somewhat annoyingly, the converse is NOT true:-</p>\n<pre><code>#define ST00 0x00000001\n#define ST01 0x00000002\n\nprintf (\"ST00 left shifted: 0x%08x\\n\", (ST00 &lt;&lt; 30));\nprintf (\"ST01 left shifted: 0x%08x\\n\", (ST01 &lt;&lt; 30));\n\nOutput:\nST00 left shifted: 0x40000000\nST01 left shifted: 0x80000000\n</code></pre>\n<p>I concur completely with the people above that assert that the sign of the operand has no bearing on the behaviour of the shift operator.</p>\n<p>Can anyone shed any light on the specification for the Posix4 implementation of C? I feel a definitive answer may rest there.</p>\n<p>In the meantime, it appears that the only workaround is a construct along the following lines;-</p>\n<pre><code>#define CARD2UNIVERSE(c) (((c) == 32) ? 0xFFFFFFFF : (U31 &gt;&gt; (31 - (c))))\n</code></pre>\n<p>This works - exasperating but necessary.</p>\n", "OwnerUserId": "709909", "PostTypeId": "2", "Id": "30936572", "Score": "1", "CreationDate": "2015-06-19T11:04:27.800", "LastActivityDate": "2015-06-19T11:04:27.800"}, "14397090": {"ParentId": "14396858", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The two kinds of right shift you're talking about are called <a href=\"http://en.wikipedia.org/wiki/Logical_shift\" rel=\"nofollow\">Logical Shift</a> and <a href=\"http://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow\">Arithmetic Shift</a>. C and C++ use logical shift for unsigned integers and most compilers will use arithmetic shift for a signed integer but this is not guaranteed by the standard meaning that the value of right shifting a negative signed int is implementation defined.</p>\n<p>Since you want a logical shift you need to switch to using an unsigned integer. You can do this by replacing your constant with <code>0xffU</code>. </p>\n", "OwnerUserId": "1502345", "LastEditorUserId": "1502345", "LastEditDate": "2013-01-18T10:53:14.990", "Id": "14397090", "Score": "5", "CreationDate": "2013-01-18T10:36:39.813", "LastActivityDate": "2013-01-18T10:53:14.990"}, "bq_ids": {"n4140": {"so_14396858_14399510_1": {"section_id": 6148, "quality": 0.875, "length": 21}, "so_14396858_14399510_0": {"section_id": 6147, "quality": 0.868421052631579, "length": 33}}, "n3337": {"so_14396858_14399510_1": {"section_id": 5911, "quality": 0.875, "length": 21}, "so_14396858_14399510_0": {"section_id": 5910, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_14396858_14399510_1": {"section_id": 7644, "quality": 0.875, "length": 21}, "so_14396858_14399510_0": {"section_id": 7643, "quality": 0.868421052631579, "length": 33}}}});