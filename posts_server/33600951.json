post_cb({"bq_ids": {"n4140": {"so_33600951_33601014_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_33600951_33601014_2": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_33600951_33601014_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}}, "n3337": {"so_33600951_33601014_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_33600951_33601014_2": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_33600951_33601014_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}}, "n4659": {"so_33600951_33601014_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}, "so_33600951_33601014_2": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33600951_33601014_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}}}, "33601014": {"Id": "33601014", "PostTypeId": "2", "Body": "<p>If we go to the draft C++ standard section <code>7.1.6.2</code> Simple type specifiers [dcl.type.simple] and see what he cases are. For decltype it starts out saying:</p>\n<blockquote>\n<p id=\"so_33600951_33601014_0\">For an expression e, the type denoted by decltype(e) is defined as follows:</p>\n</blockquote>\n<p>We see that in this case the expression is not a id-expression nor a class member access, which would give the result you expected(<em>emphasis mine</em>):</p>\n<blockquote id=\"so_33600951_33601014_1\">\n<ul>\n<li>if <strong>e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e)\n  is the type of the entity named by e</strong>. If there is no such entity, or if e names a set of overloaded functions,\n  the program is ill-formed;</li>\n</ul>\n</blockquote>\n<p>but the result is an lvalue:</p>\n<blockquote id=\"so_33600951_33601014_2\">\n<ul>\n<li>otherwise, if <strong>e is an lvalue, decltype(e) is T&amp;</strong>, where T is the type of e;</li>\n</ul>\n</blockquote>\n<p>which results in a reference.</p>\n<p>As M.M point out <a href=\"http://en.cppreference.com/w/cpp/types/remove_reference\" rel=\"nofollow\">std::remove_reference</a> could be used to obtain the result you want:</p>\n<pre><code>std::remove_reference&lt;decltype(Ptr[0])&gt;::type Test = (int*)0;\n</code></pre>\n<p>As T.C. points out <a href=\"http://en.cppreference.com/w/cpp/types/decay\" rel=\"nofollow\">std::decay</a> is also an option and is shorter:</p>\n<pre><code>std::decay&lt;decltype(Ptr[0])&gt;::type Test = (int*)0;\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-09T10:38:29.870", "Score": "5", "CreationDate": "2015-11-09T01:09:43.677", "ParentId": "33600951", "CommentCount": "6", "OwnerUserId": "1708801", "LastEditDate": "2015-11-09T10:38:29.870"}, "33600951": {"ViewCount": "414", "Body": "<p>The following is a contrived example of the actual code:</p>\n<pre><code>int** Ptr = 0;\ndecltype(Ptr[0]) Test = (int*)0;\n</code></pre>\n<p>I get the error:</p>\n<blockquote>\n<p id=\"so_33600951_33600951_0\">error C2440: 'initializing': cannot convert from 'int *' to 'int *&amp;'</p>\n</blockquote>\n<p>I'm not sure why I'm getting that since from my understand of <code>decltype</code> (correct me if I'm wrong) it just takes whatever expression you give it and resolve it to its actual type. In this case <code>Ptr[0]</code> is an <code>int*</code> so I'm expecting: <code>int* Test = (int*)0;</code></p>\n<p>What am I missing? Why am I getting that error?</p>\n", "AcceptedAnswerId": "33601014", "Title": "decltype error C2440 cannot convert from 'int *' to 'int *&'", "CreationDate": "2015-11-09T01:01:03.097", "Id": "33600951", "CommentCount": "2", "LastEditDate": "2015-11-09T01:12:25.383", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-09T10:38:29.870", "Score": "3", "OwnerUserId": "1267466", "Tags": "<c++><decltype>", "AnswerCount": "1"}});