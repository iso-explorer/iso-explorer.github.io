post_cb({"9738582": {"ParentId": "9738471", "CommentCount": "0", "Body": "<p>As said by AIs... I'll even explain why: in many C++ implementations the <code>this</code> pointer is simply passed as the first \"hidden\" parameter of the method. So what you see as </p>\n<pre><code>void Method() {}\n</code></pre>\n<p>is really</p>\n<pre><code>void Method(P* this) {}\n</code></pre>\n<p>But for virtual methods it's more complex. The runtime needs to access the pointer to find the \"real\" type of P* to be able to call the \"right\" virtual implementation of the method. So it's something like</p>\n<pre><code>p-&gt;virtualTable-&gt;Method(p);\n</code></pre>\n<p>so p is always used.</p>\n", "OwnerUserId": "613130", "PostTypeId": "2", "Id": "9738582", "Score": "3", "CreationDate": "2012-03-16T13:57:28.407", "LastActivityDate": "2012-03-16T13:57:28.407"}, "9738507": {"ParentId": "9738471", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><strong>According to C++ Standard, it's perfectly acceptable to do this</strong> </p>\n<p><strong>No it is not!</strong><br>\nDereferencing a <code>NULL</code> pointer is <strong>Undefined Behavior</strong> as per the C++ Standard.<sup>[#1]</sup> </br></p>\n<p>However, If you do not access any members inside a non virtual member function it will most likely work on every implementation because for a non virtual member function the <code>this</code> only needs to be derefernced for accessing members of <code>this</code> since there are no members being accessed inside the function hence the result.<br>\nHowever, just because the observable behavior is okay does not mean the program is <strike>well-formed.</strike> correct.<br>\n<strike>It still is ill-formed.</strike><br>\nIt is an invalid program nevertheless.</br></br></br></p>\n<p>The second version crashes because while accessing a virtual member function, the <code>this</code> pointer needs to be dereferenced just even for calling the appropriate member function even if there are no members accessed within that member function.    </p>\n<p>A good read:<br>\n<a href=\"http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.3\" rel=\"nofollow\">What's the difference between how virtual and non-virtual member functions are called?</a></br></p>\n<hr>\n<p><strong><sup>[#1]</sup>Reference:</strong> </p>\n<p><strong>C++03 Standard: \u00a71.9/4</strong> </p>\n<blockquote>\n<p id=\"so_9738471_9738507_0\"><strong>Certain other operations are described in this International Standard as undefined (for example, the effect of dereferencing the <code>null</code> pointer)</strong>. [Note: this International Standard imposes no requirements on the behavior of programs that contain undefined behavior. ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-03-17T04:13:38.587", "Id": "9738507", "Score": "11", "CreationDate": "2012-03-16T13:52:59.623", "LastActivityDate": "2012-03-17T04:13:38.587"}, "9738471": {"CommentCount": "1", "ViewCount": "117", "CreationDate": "2012-03-16T13:51:02.230", "LastActivityDate": "2012-03-17T04:13:38.587", "Title": "-> operator on null objects", "AcceptedAnswerId": "9738507", "PostTypeId": "1", "Id": "9738471", "Score": "0", "Body": "<p>According to C++ Standard, it's perfectly acceptable to do this:</p>\n<pre><code>class P\n{\n    void Method() {}\n};\n\n...\n\nP* p = NULL;\np-&gt;Method();\n</code></pre>\n<p>However, a slight change to this:</p>\n<pre><code>class P\n{\n    virtual void Method() {}\n};\n\n...\n\nP* p = NULL;\np-&gt;Method();\n</code></pre>\n<p>produces an access violation when compiled with Visual Studio 2005.</p>\n<p>As far as I understand, this is caused by some quirk in Microsoft's compiler implementation and not by my sheer incompetence for a change, so the questions are:</p>\n<p>1) Does this behavior persist in more recent versions of VS?</p>\n<p>2) Are there any, I don't know, compiler settings that prevent this access violation?</p>\n", "Tags": "<c++>", "OwnerUserId": "1268928", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_9738471_9738507_0": {"section_id": 5800, "quality": 0.7272727272727273, "length": 16}}, "n3337": {"so_9738471_9738507_0": {"section_id": 5573, "quality": 0.7272727272727273, "length": 16}}, "n4659": {"so_9738471_9738507_0": {"section_id": 7259, "quality": 0.7272727272727273, "length": 16}}}, "9738877": {"ParentId": "9738471", "CommentCount": "0", "Body": "<p>First of all, neither one will even compile, because you've defined <code>Method</code> as private.</p>\n<p>Assuming you make <code>Method</code> public, you end up with undefined behavior in both cases. Based on the <em>typical</em> implementation, most compilers will allow the first to \"work\" (for a rather loose definition of work) while the second will essentially always fail.</p>\n<p>This is because a non-virtual member function is basically a normal function that receives an extra parameter. Inside that function, the keyword <code>this</code> refers to that extra parameter, which is a pointer to the class instance for which the function was invoked. If you invoke the member function via a null pointer, it mostly means that inside that function <code>this</code> will be a null pointer. As long as nothing in the function attempts to dereference <code>this</code>, chances are pretty good that you see any noticeable side effects.</p>\n<p>A virtual function, however, is basically a function called via a pointer. In a typical implementation, any class that has one or more virtual functions (whether defined directly in that class, or inherited from a base class) will have a vtable. Each instance of that class (i.e., each object) will contain a pointer to the vtable for its class. When you try to call a virtual function via a pointer, the compiler will generate code that:</p>\n<ol>\n<li>Dereferences that pointer.</li>\n<li>Gets the vtable pointer from the proper offset in that object</li>\n<li>dereferences the vtable pointer to get the class' vtable</li>\n<li>looks at the proper offset in the vtable to get a pointer to the function to invoke</li>\n<li>invokes that function</li>\n</ol>\n<p>Given a null pointer, step one of that process <em>is</em> going to break.</p>\n<p>I'd note for the record that this applies to virtually <em>all</em> C++ compilers. VC++ is far from unique in this regard. Quite the contrary -- while it's theoretically possible for a compiler to implement virtual functions (for one example) differently than this, the reality is that every compiler of which I'm aware works essentially identically for the kind of code you posted. Virtually all C++ compilers will show similar behavior given the same code -- major differences in implementation are mostly a theoretical possibility, not one you're at all likely to encounter in practice.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "9738877", "Score": "0", "CreationDate": "2012-03-16T14:14:52.900", "LastActivityDate": "2012-03-16T14:14:52.900"}});