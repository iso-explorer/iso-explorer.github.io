post_cb({"bq_ids": {"n4140": {"so_39732045_39736048_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6966}}, "n3337": {"so_39732045_39736048_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6713}}, "n4659": {"so_39732045_39736048_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 8465}}}, "39732113": {"Id": "39732113", "PostTypeId": "2", "Body": "<p><code>va_start</code> does use the address of the variable you give it.  With <code>myprintf2</code>, you're only passing one parameter to <code>myprintf</code>, so when you try to access the 2nd parameter (the passed value of <code>s</code>) it isn't there, and you seeing saved registers, the return address, or something else that's sitting on the stack.</p>\n<p>To do what you're trying to do, you'll need to pass the <code>va_list</code> variable to a common function called by both of your printf-like functions.</p>\n<p>Edit:  From the C++ language standard, \"If the parameter parmN is of a reference type, or of a type that is not compatible with the type that results when passing an argument for which there is no parameter, the behavior is undefined.\"  (parmN is the parameter passed to va_start.)</p>\n<p>Edit 2: Sample uncompiled implementation:</p>\n<pre><code>void myprintf_core(const char *fmt, va_list ap);\n\nvoid myprintf2(const char *fmt, ...) {\n    //...\n    va_list ap;\n    va_start(ap, fmt);\n    myprintf_core(fmt, ap);\n    va_end(ap);     // could be included in myprintf_core\n}\n</code></pre>\n<p><code>myprintf_core</code> is your <code>_myprintf</code> but without the 3 <code>va_</code> lines, which have been moved into <code>myprintf2</code>.</p>\n", "LastEditorUserId": "5231607", "LastActivityDate": "2016-09-30T01:18:19.347", "Score": "4", "CreationDate": "2016-09-27T18:42:42.973", "ParentId": "39732045", "CommentCount": "4", "OwnerUserId": "5231607", "LastEditDate": "2016-09-30T01:18:19.347"}, "39732045": {"ViewCount": "184", "Body": "<p>Why doesn't the following code work?</p>\n<pre><code>#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n\n// People are missing this in their reponses.... 'fmt' here is passed by\n// reference, not by value. So &amp;fmt in _myprintf is the same as &amp;fmt in \n// myprintf2. So va_start should use the address of the fmt char * on the\n// stack passed to the original call of myprintf2.\nvoid _myprintf(const char *&amp;fmt, ...)\n{\n    char buf[2000];\n//---\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n//---\n    printf(\"_myprintf:%sn\", buf);\n}\n\nvoid myprintf2(const char *fmt, ...)\n{\n    _myprintf(fmt);\n}\n\nvoid myprintf(const char *fmt, ...)\n{\n    char buf[2000];\n//---\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n//---\n    printf(\" myprintf:%sn\", buf);\n}\n\nint main()\n{\n    const char *s = \"string\";\n    unsigned u = 11;\n    char c = 'c';\n    float f = 2.22;\n    myprintf(\"s='%s' u=%u c='%c' f=%fn\", s, u, c, f);\n    myprintf2(\"s='%s' u=%u c='%c' f=%fn\", s, u, c, f);\n}\n</code></pre>\n<p>I expected both lines of output to be the same, but they differ:</p>\n<pre><code> myprintf:s='string' u=11 c='c' f=2.220000\n_myprintf:s='string' u=2020488703 c='c' f=0.000000\n</code></pre>\n<p>I thought <code>va_start()</code> used the address of the <code>fmt</code> variable, which should be the address of the string pointer on the stack.</p>\n", "Title": "Can I pass by reference to va_start()?", "CreationDate": "2016-09-27T18:38:47.023", "LastActivityDate": "2016-09-30T01:18:19.347", "CommentCount": "4", "LastEditDate": "2016-09-28T16:20:40.203", "PostTypeId": "1", "LastEditorUserId": "4850040", "Id": "39732045", "Score": "1", "OwnerUserId": "5351900", "Tags": "<c++><pass-by-reference><variadic-functions>", "AnswerCount": "3"}, "39732155": {"Id": "39732155", "PostTypeId": "2", "Body": "<p>When calling a function a so-called <em>stack frame</em> is created on the stack, it contains the return address, the arguments and maybe some other meta-data needed by the generated code. The arguments for the current function are <em>not</em> passed on to the new function.</p>\n<p>Therefore in <code>myprintf2</code> when you call <code>_myprintf</code> only the <code>fmt</code> argument is passed, none of the others will be passed. So your <code>vsnprintf</code> call will lead to <em>undefined behavior</em> as it tries to access arguments that doesn't exist.</p>\n<p>Semi-graphically the frames on the stack <em>could</em> be seen as something like this:</p>\n<pre>\n| .                                      |\n| .                                      |\n| .                                      |\n+----------------------------------------+\n| arguments for the _myprintf function   |\n| .                                      |\n| .                                      |\n| .                                      |\n| return address                         |\n| Stack frame for the _myprintf function |\n+----------------------------------------+\n| arguments for the myprintf2 function   |\n| .                                      |\n| .                                      |\n| .                                      |\n| return address                         |\n| Stack frame for the myprintf2 function |\n+----------------------------------------+\n| arguments for the main function        |\n| .                                      |\n| .                                      |\n| .                                      |\n| return address                         |\n| Stack frame for the main function      |\n+----------------------------------------+\n| .                                      |\n| .                                      |\n| .                                      |\n</pre>\n<p>It should make it very easy to see why the arguments to <code>myprintf2</code> are not available to <code>_myprintf</code>.</p>\n<p>The exact format and layout of the stack frames are of course system and compiler dependent.</p>\n", "LastActivityDate": "2016-09-27T18:44:46.247", "CommentCount": "3", "CreationDate": "2016-09-27T18:44:46.247", "ParentId": "39732045", "Score": "1", "OwnerUserId": "440558"}, "39736048": {"Id": "39736048", "PostTypeId": "2", "Body": "<p>See C++14 [support.runtime]/3:</p>\n<blockquote>\n<p id=\"so_39732045_39736048_0\">The parameter <code>parmN</code> is the identifier of the rightmost parameter in the variable parameter list of the function definition (the one just before the <code>...</code>). If the parameter <code>parmN</code> is of a reference type, or of a type that is not compatible with the type that results when passing an argument for which there is no parameter, the behavior is undefined.</p>\n</blockquote>\n<p>So your code causes undefined behaviour because the last parameter before the <code>...</code> in <code>_myprintf</code> has reference type.</p>\n", "LastActivityDate": "2016-09-27T23:59:01.187", "CommentCount": "0", "CreationDate": "2016-09-27T23:59:01.187", "ParentId": "39732045", "Score": "1", "OwnerUserId": "1505939"}});