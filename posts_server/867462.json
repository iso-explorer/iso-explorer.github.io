post_cb({"867804": {"Id": "867804", "PostTypeId": "2", "Body": "<p>I think the answer from sharptooth is precise. The C++ Standard (SC22-N-4411.pdf) section 12.3.4 titled 'Conversions' makes it clear that only one implicit user-defined conversion is allowed.</p>\n<blockquote>\n<p id=\"so_867462_867804_0\">1 Type conversions of class objects can be specified by\n  constructors and by conversion\n  functions. These\n      conversions are called user-defined conversions and are used\n  for implicit type conversions (Clause\n  4), for\n      initialization (8.5), and for explicit type conversions (5.4,\n  5.2.9).</p>\n<p id=\"so_867462_867804_1\">2 User-defined conversions are applied only where they are\n  unambiguous (10.2, 12.3.2).\n  Conversions obey the\n      access control rules (Clause 11). Access control is applied after\n  ambiguity resolution (3.4).</p>\n<p id=\"so_867462_867804_2\">3 [ Note: See 13.3 for a discussion of the use of conversions\n  in function calls as well as examples\n  below. \u2014end\n      note ]</p>\n<p id=\"so_867462_867804_3\">4 At most one user-defined conversion (constructor or conversion\n  function) is implicitly applied to a\n  single\n      value.</p>\n</blockquote>\n", "LastEditorDisplayName": "anon", "LastActivityDate": "2009-05-15T10:01:41.253", "Score": "12", "CreationDate": "2009-05-15T09:50:27.490", "ParentId": "867462", "CommentCount": "1", "OwnerUserId": "79298", "LastEditDate": "2009-05-15T10:01:41.253"}, "867470": {"Id": "867470", "PostTypeId": "2", "Body": "<p>That's true, only one <em>implicit</em> conversion is allowed.</p>\n<p>Two conversions in a row may be performed with a combination of a conversion operator and a parameterized constructor but this causes a <a href=\"http://msdn.microsoft.com/en-us/library/727wstex(VS.80).aspx\" rel=\"noreferrer\">C4927 warning</a> - \"illegal conversion; more than one user-defined conversion has been implicitly applied\" - in VC++ for a reason.</p>\n", "LastEditorUserId": "57428", "LastActivityDate": "2009-05-15T08:10:16.390", "Score": "8", "CreationDate": "2009-05-15T07:56:39.743", "ParentId": "867462", "CommentCount": "0", "OwnerUserId": "57428", "LastEditDate": "2009-05-15T08:10:16.390"}, "bq_ids": {"n4140": {"so_867462_867804_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 383}, "so_867462_867804_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 385}, "so_867462_867804_3": {"length": 11, "quality": 1.0, "section_id": 386}, "so_867462_867804_1": {"length": 18, "quality": 0.9, "section_id": 384}, "so_867462_867462_0": {"length": 11, "quality": 1.0, "section_id": 386}}, "n3337": {"so_867462_867804_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 374}, "so_867462_867462_0": {"length": 11, "quality": 1.0, "section_id": 377}, "so_867462_867804_3": {"length": 11, "quality": 1.0, "section_id": 377}, "so_867462_867804_1": {"length": 18, "quality": 0.9, "section_id": 375}, "so_867462_867804_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 376}}, "n4659": {"so_867462_867804_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 400}, "so_867462_867462_0": {"length": 11, "quality": 1.0, "section_id": 403}, "so_867462_867804_3": {"length": 11, "quality": 1.0, "section_id": 403}, "so_867462_867804_1": {"length": 18, "quality": 0.9, "section_id": 401}, "so_867462_867804_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 402}}}, "867462": {"ViewCount": "19664", "Body": "<p>Several comments on a recent answer of mine, <a href=\"https://stackoverflow.com/questions/862858/what-other-useful-casts-can-be-used-in-c/862896#862896\">What other useful casts can be used in C++</a>, suggest that my understanding of C++ conversions is faulty. Just to clarify the issue, consider the following code:</p>\n<pre><code>#include &lt;string&gt;\n\nstruct A {\n    A( const std::string &amp; s ) {}\n};\n\nvoid func( const A &amp; a ) {\n}\n\nint main() {\n    func( \"one\" );                  // error\n    func( A(\"two\") );           // ok\n    func( std::string(\"three\") );   // ok\n}\n</code></pre>\n<p>My assertion was that the the first function call is an error, becauuse there is no conversion from a const char * to an A. There is a conversion from a string to an A, but using this would involve more than one conversion. My understanding is that this is not allowed, and this seems to be confirmed by g++ 4.4.0 &amp; Comeau compilers. With Comeau, I get the following error:</p>\n<pre><code>\"ComeauTest.c\", line 11: error: no suitable constructor exists \n      to convert from \"const char [4]\" to \"A\"\n      func( \"one\" );                    // error\n</code></pre>\n<p>If you can point out, where I am wrong, either here or in the original answer, preferably with reference to the C++ Standard, please do so.</p>\n<p><strong>And the answer from the C++ standard seems to be:</strong> </p>\n<blockquote>\n<p id=\"so_867462_867462_0\">At most one user-defined conversion\n  (constructor or conversion function)\n  is implicitly applied to a single value.</p>\n</blockquote>\n<p><strong>Thanks to Abhay for providing the quote.</strong></p>\n", "AcceptedAnswerId": "867804", "Title": "C++ implicit conversions", "CreationDate": "2009-05-15T07:52:49.270", "LastActivityDate": "2016-06-04T22:51:23.090", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:27.663", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastEditorUserId": "-1", "Id": "867462", "Score": "23", "Tags": "<c++>", "AnswerCount": "4"}, "867647": {"Id": "867647", "PostTypeId": "2", "Body": "<p><em><a href=\"https://books.google.com/books?id=PSUNAAAAQBAJ&amp;pg=PA546&amp;lpg=PA546&amp;dq=%22only+one+level+of+user-defined+implicit+conversion+is+legal%22&amp;source=bl&amp;ots=DqxpDja_3L&amp;sig=qjudOpQncUR6BdzfFT_vGLwoGDc&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwi_tfvf-Y7NAhWDjz4KHd8tDmAQ6AEIMjAE#v=onepage&amp;q=%22only%20one%20level%20of%20user-defined%20implicit%20conversion%20is%20legal%22&amp;f=false\" rel=\"nofollow noreferrer\">The C++ Programming Language</a> (4th. ed.)</em> (section 18.4.3) says that</p>\n<blockquote>\n<p id=\"so_867462_867647_0\">only one level of user-defined\n  implicit conversion is legal</p>\n</blockquote>\n<p>That \"user-defined\" part makes it sound like multiple implicit conversions may be allowed if some are between native types.</p>\n", "LastEditorUserId": "1485877", "LastActivityDate": "2016-06-04T22:51:23.090", "Score": "5", "CreationDate": "2009-05-15T08:58:15.353", "ParentId": "867462", "CommentCount": "1", "OwnerUserId": "10593", "LastEditDate": "2016-06-04T22:51:23.090"}, "868398": {"Id": "868398", "PostTypeId": "2", "Body": "<p>As the consensus seems to be already: yes you're right.</p>\n<p>But as this question / answers will probably become the point of reference for C++ implicit conversions on stackoverflow I'd like to add that for template arguments the rules are different.</p>\n<p>No implicit conversions are allowed for arguments that are used for template argument deduction. This might seem pretty obvious but nevertheless can lead to subtle weirdness.</p>\n<p>Case in point, std::string addition operators</p>\n<pre><code> std::string s;\n s += 67;    // (1)\n s = s + 67; // (2)\n</code></pre>\n<p>(1) compiles and works fine, <code>operator+=</code> is a member function, the template character parameter is already deduced by instantiating <code>std::string</code> for s (to <code>char</code>). So implicit conversions are allowed (<code>int</code> -&gt; <code>char</code>), results in s containing the char equivalent of 67, e.g. in ASCII this would become 'C'</p>\n<p>(2) gives a compiler error as <code>operator+</code> is declared as a free function and here the template character argument <em>is</em> used in deduction.</p>\n", "LastActivityDate": "2009-05-15T12:26:55.523", "CommentCount": "0", "CreationDate": "2009-05-15T12:26:55.523", "ParentId": "867462", "Score": "9", "OwnerUserId": "5822"}});