post_cb({"32053359": {"CommentCount": "2", "AcceptedAnswerId": "32053869", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-08-17T14:46:01.100", "LastActivityDate": "2015-08-17T15:50:45.980", "LastEditDate": "2015-08-17T15:50:45.980", "ViewCount": "185", "FavoriteCount": "2", "Title": "Copy-initialization with implicit conversion in c++", "Id": "32053359", "Score": "6", "Body": "<pre><code>class Foo {\n  public:\n    Foo(float b) {}\n};\n\nclass Bar {\n  public:\n    Bar(Foo foo) {}\n};\n\nint main(int argc, char *argv[]) {\n    Bar b1(3.0f);  // accept, one implicit convertion happens there.\n    Bar b2 = 3.0f;  // error: no viable conversion from 'float' to 'Bar'\n    return 0;\n}\n</code></pre>\n<p>Why does the second expression fail to compile? I expected that it would call the same converting constructor as same as the first expression. </p>\n", "Tags": "<c++><initialization>", "OwnerUserId": "5139915", "AnswerCount": "2"}, "32053741": {"ParentId": "32053359", "CommentCount": "0", "CreationDate": "2015-08-17T15:03:50.880", "OwnerUserId": "647254", "PostTypeId": "2", "Id": "32053741", "Score": "3", "Body": "<p>The second type of initialization is called copy-initialization and uses copy constructor. Therefore, this type of initialization expects the right side is convertible to Bar.</p>\n", "LastActivityDate": "2015-08-17T15:03:50.880"}, "bq_ids": {"n4140": {"so_32053359_32053869_0": {"section_id": 3296, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_32053359_32053869_0": {"section_id": 3166, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_32053359_32053869_0": {"section_id": 4058, "quality": 0.9310344827586207, "length": 27}}}, "32053869": {"ParentId": "32053359", "CommentCount": "4", "CreationDate": "2015-08-17T15:11:23.470", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32053869", "Score": "7", "Body": "<p>From [dcl.init]:</p>\n<blockquote>\n<p id=\"so_32053359_32053869_0\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences\n  that can convert <strong>from the source type to the destination type</strong> or (when a conversion function\n  is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is\n  chosen through overload resolution (13.3).</p>\n</blockquote>\n<p>We can invoke a user-defined conversion that is from the source type <em>directly</em> to the target type. That is, if we had <code>Bar(float )</code>, we would consider that constructor. However, in this case, our candidate is simply <code>Bar(Foo )</code>, which does not take a <code>float</code>. </p>\n<p>You are allowed zero or one user-defined conversion. In the direct-initialization case, we simply call <code>Bar(Foo )</code> which invokes one user-defined conversion (<code>float --&gt; Foo</code>). In the copy-initialization case, we are looking for a conversion sequence from <code>float</code> (the source type) all the way to <code>Bar</code> (the destination type), which would involve <em>two</em> user-defined conversions (<code>float --&gt; Foo</code>, <code>Foo --&gt; Bar</code>), hence the error. </p>\n", "LastActivityDate": "2015-08-17T15:11:23.470"}});