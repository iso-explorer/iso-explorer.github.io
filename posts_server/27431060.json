post_cb({"27431789": {"ParentId": "27431060", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ Standard \u00a7 23.3.6:</p>\n<p>Vectors have a specific capacity, meaning</p>\n<blockquote>\n<p id=\"so_27431060_27431789_0\">The total number of elements that the vector can hold without requiring reallocation</p>\n</blockquote>\n<p>When you <code>push_back</code> an additional element, this effectively increases the container size by one, which</p>\n<blockquote>\n<p id=\"so_27431060_27431789_1\">Causes reallocation if the new size is greater than the old capacity</p>\n</blockquote>\n<p><em>Re</em>-allocation implies that you are <em>de</em>-allocating (i.e. destroying) the elements in the vector, then allocating (i.e. constructing) them again.</p>\n<p>Note that, in your case, the original <code>one</code> and <code>two</code> instances of <code>A</code> are not destroyed, rather their copies which are stored in the vector are.</p>\n<p>A programmer needs to be more careful with references and iterators though, because</p>\n<blockquote>\n<p id=\"so_27431060_27431789_2\">Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence.</p>\n</blockquote>\n<p>As others have mentioned, <code>reserve()</code> will help prevent this, because</p>\n<blockquote>\n<p id=\"so_27431060_27431789_3\">No reallocation shall take place during insertions that happen after a call to reserve()\n  until the time when an insertion would make the size of the vector greater than the value of capacity().</p>\n</blockquote>\n", "OwnerUserId": "1339615", "LastEditorUserId": "1339615", "LastEditDate": "2014-12-11T21:12:29.880", "Id": "27431789", "Score": "2", "CreationDate": "2014-12-11T20:27:21.677", "LastActivityDate": "2014-12-11T21:12:29.880"}, "27431261": {"ParentId": "27431060", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As the comments suggest, you should use <code>std::vector&lt;&gt;::reserve(size_t)</code>.</p>\n<p>What you are seeing is implementation defined. Most implementations approximately double the reserved allocation size when growing. This is to avoid making many allocations and copies whenever the size grows.</p>\n<p>Reserving simply suggests to the collection that you will need <em>n</em> elements. The implementation, if it chooses to honor the request, reallocates and moves/copies the existing values to the new allocation which is large enough to hold the number of elements you've requested. Now you can push back without costly reallocation. Reserving properly can save you many reallocations as the container is resized, when you have a good idea what the final size will be.</p>\n<p>Reserving in this case would avoid that resize, and the destruction of the temporary you see.</p>\n<p>You see the destructor likely because the collection is resizing. As you push back the second time, it reallocates.</p>\n<p>If the object must never be destroyed, you should consider another collection type or storage location, since the program <em>in its present form</em> relies on implementation-defined behavior (i.e. the standard's specification for vector does not make the guarantee you would need).</p>\n", "OwnerUserId": "191596", "LastEditorUserId": "191596", "LastEditDate": "2014-12-11T19:58:51.033", "Id": "27431261", "Score": "1", "CreationDate": "2014-12-11T19:53:29.237", "LastActivityDate": "2014-12-11T19:58:51.033"}, "27431197": {"ParentId": "27431060", "CommentCount": "2", "Body": "<p>Printouts in your code do not show you the complete picture: the destructor is called for a different object.</p>\n<p>Take a look at this modified code. I added printouts of the address, and logging in some other key places, such as calls of the assignment operator and copy constructor.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass A\n{\npublic:\n    A() {cout &lt;&lt; \"constructed \" &lt;&lt; (void*)this &lt;&lt; \"\\n\";}\n    A(const A&amp; a) {cout &lt;&lt; \"copied \" &lt;&lt; (void*)(&amp;a) &lt;&lt; \" to \" &lt;&lt; (void*)this &lt;&lt; \"\\n\"; }\n    A&amp; operator =(const A&amp; a) {cout &lt;&lt; \"assigned \" &lt;&lt; (void*)(&amp;a) &lt;&lt; \" to \" &lt;&lt; (void*)this &lt;&lt; \"\\n\"; }\n    ~A() { cout &lt;&lt; \"destructor called for \" &lt;&lt; (void*)this &lt;&lt; \"\\n\"; }\n};\n\nint main ()\n{\n    A one, two;\n\n    vector&lt;A&gt; vec;\n    cout &lt;&lt; \"push_back one\" &lt;&lt; endl;\n    vec.push_back(one);\n    cout &lt;&lt; \"push_back two\" &lt;&lt; endl;\n    vec.push_back(two);\n    //destructor gets called here\n    return 0;\n}\n</code></pre>\n<p>It produces the following output (<a href=\"http://ideone.com/6CjLZD\" rel=\"nofollow\">demo</a>):</p>\n<pre><code>constructed 0xbff229b2\nconstructed 0xbff229b3\npush_back one\ncopied 0xbff229b2 to 0x970c008\npush_back two\ncopied 0xbff229b3 to 0x970c019\ncopied 0x970c008 to 0x970c018\ndestructor called for 0x970c008\ndestructor called for 0x970c018\ndestructor called for 0x970c019\ndestructor called for 0xbff229b3\ndestructor called for 0xbff229b2\n</code></pre>\n<p>You can see that objects <code>one</code> and <code>two</code> (<code>0xbff229b2</code> and <code>0xbff229b3</code>) do not get destroyed until the end, when they go out of scope. Its their copies that get destroyed when the vector is resized.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "27431197", "Score": "3", "CreationDate": "2014-12-11T19:49:51.213", "LastActivityDate": "2014-12-11T19:49:51.213"}, "bq_ids": {"n4140": {"so_27431060_27431789_2": {"section_id": 972, "quality": 1.0, "length": 9}, "so_27431060_27431789_0": {"section_id": 967, "quality": 0.8888888888888888, "length": 8}, "so_27431060_27431789_1": {"section_id": 986, "quality": 1.0, "length": 8}, "so_27431060_27431789_3": {"section_id": 972, "quality": 1.0, "length": 21}}, "n3337": {"so_27431060_27431789_3": {"section_id": 961, "quality": 0.9523809523809523, "length": 20}, "so_27431060_27431789_1": {"section_id": 971, "quality": 1.0, "length": 8}, "so_27431060_27431789_0": {"section_id": 957, "quality": 0.8888888888888888, "length": 8}, "so_27431060_27431789_2": {"section_id": 961, "quality": 1.0, "length": 9}}, "n4659": {"so_27431060_27431789_2": {"section_id": 1034, "quality": 1.0, "length": 9}, "so_27431060_27431789_1": {"section_id": 1049, "quality": 1.0, "length": 8}, "so_27431060_27431789_0": {"section_id": 1029, "quality": 0.8888888888888888, "length": 8}, "so_27431060_27431789_3": {"section_id": 1034, "quality": 1.0, "length": 21}}}, "27431060": {"CommentCount": "8", "ViewCount": "181", "CreationDate": "2014-12-11T19:40:42.577", "LastActivityDate": "2014-12-11T21:12:29.880", "Title": "Destructor gets called when I don't want it to", "PostTypeId": "1", "Id": "27431060", "Score": "3", "Body": "<p>The destructor of the class I made gets called before the end of scope. I think that it has something to do with the reallocation in the vector when I add another element to it. How to I surpass this issue? I want the destructor to be called only when the object reaches the end of scope in my code.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass A\n{\npublic:\n    ~A() { cout &lt;&lt; \"destructor called\\n\"; }\n};\n\nint main ()\n{\n    A one, two;\n\n    vector&lt;A&gt; vec;\n    cout &lt;&lt; \"push_back one\" &lt;&lt; endl;\n    vec.push_back(one);\n    cout &lt;&lt; \"push_back two\" &lt;&lt; endl;\n    vec.push_back(two);\n    //destructor gets called here\n    system(\"pause\");\n    return 0;\n} //while i want it to be called here\n</code></pre>\n", "Tags": "<c++><class><oop><destructor>", "OwnerUserId": "4266765", "AnswerCount": "3"}});