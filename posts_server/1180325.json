post_cb({"1182688": {"Id": "1182688", "PostTypeId": "2", "Body": "<p>Edit: After studying <a href=\"http://clang.llvm.org\" rel=\"nofollow noreferrer\">Clang's</a> implementation (by Doug Gregor) of their partial ordering algorithm, I have come to agree with the rest of the posters that the original example is not 'intended' to be ambiguous - even though the standard is not as clear as it could be about what should happen in such situations.  I have edited this post to indicate my revised thoughts (for my own benefit &amp; reference).  In particular Clang's algorithm clarified that '<code>typename Const&lt;T&gt;::type</code>' is not translated into 'void' during the partial ordering step - and that each A/P pair is deduced independent of each other.</p>\n<p>Initially I wondered why the following was considered ambiguous:</p>\n<pre><code>        template&lt;class T&gt; void f(T,T*);  // 1\n\n        template&lt;class T&gt; void f(T, int*); // 2\n\n        f(0, (int*)0); // ambiguous\n</code></pre>\n<p><code>(The above is ambiguous because one cannot deduce f1(U1,U1*) from f2(T,int*), and going the other way, one cannot deduce f2(U2,int*) from f1(T,T*).  Neither is more specialized.)</code></p>\n<p>but the following would not be ambiguous:</p>\n<pre><code>        template&lt;class T&gt; struct X { typedef int type; };\n        template&lt;class T&gt; void f(T, typename X&lt;T&gt;::type*); // 3\n        template&lt;class T&gt; void f(T, int*); // 2\n</code></pre>\n<p>(The reason one could expect it to be ambiguous is if the following were to happen:<br>\n - <code>f3(U1,X&lt;U1&gt;::type*) -&gt; f3(U1, int*) ==&gt; f2(T,int*) (deduction ok, T=U1)</code><br>\n - <code>f2(U2,int*) ==&gt; f3(T, X&lt;T&gt;::type*) (deduction ok, T=U2 makes X&lt;U2&gt;::type* -&gt; int*)</code><br>\nIf this were true, neither one would be more specialized than the other.)</br></br></br></p>\n<p>After studying Clang's partial ordering algorithm it is clear that they treat '3' above as if it was:</p>\n<pre><code>template&lt;class T, class S&gt; void f(T, S*); // 4\n</code></pre>\n<p>so deduction of some unique 'U' against 'typename X::type' will succeed -</p>\n<ul>\n<li><code>f3(U1,X&lt;U1&gt;::type*) is treated as f3(U1, U2*) ==&gt; f2(T,int*) (deduction not ok)</code> </li>\n<li><code>f2(U2,int*) ==&gt; f3(T,S* [[X&lt;T&gt;::type*]]) (deduction ok, T=U2, S=int)</code> </li>\n</ul>\n<p>And so '2' is clearly more specialized than '3'.  </p>\n", "LastEditorUserId": "51103", "LastActivityDate": "2009-09-21T04:52:56.460", "Score": "2", "CreationDate": "2009-07-25T18:30:16.400", "ParentId": "1180325", "CommentCount": "1", "OwnerUserId": "51103", "LastEditDate": "2009-09-21T04:52:56.460"}, "1184924": {"Id": "1184924", "PostTypeId": "2", "Body": "<p>Edit: Please disregard this post - After studying clangs algorithm for partial ordering as implemented by Doug Gregor (even though it is only partially implemented as of this writing - it seems that the logic that's relevant to the OP's question is implemented adequately enough) - it appears as if it treats the undeduced context as just another template parameter.  Which suggests that the overload with the explicit void* argument should be the more specialized version and there should be no ambiguity.  As usual Comeau is correct.\nNow as for the wording in the standard that clearly defines this behavior - that's another matter ...</p>\n<p>Since this post was also posted on comp.lang.c++.moderated, and seems to be causing some confusion there too - i thought i'd post my answer to that group here too - since the discussion is obviously relevant to the question asked here.</p>\n<blockquote>\n<p id=\"so_1180325_1184924_0\"><code>On Jul 25, 1:11 pm, Bart van Ingen Schenau &lt;b...@ingen.ddns.info&gt; wrote:</code></p>\n<p id=\"so_1180325_1184924_1\"><code>You are going one step too fast here. How do you know (and would the compiler know) that there is no specialisation of Const&lt;Q&gt; such that Const&lt;Q&gt;::type != void?</code> </p>\n<p id=\"so_1180325_1184924_2\"><code>As far as I can see, the compiler would transform the parameter-list of A to: AT=(Q, &lt;unknown&gt;*). To call B with these parameters requires an implicit conversion  (&lt;unknown&gt;* to void*) and therefore A is less specialised than B.</code></p>\n</blockquote>\n<p>I believe this is incorrect.  When checking to see which function is more \nspecialized (during partial-ordering), the compiler transforms the\nparameter-list to <code>(Q, void*)</code> - i.e. it actually instantiates the relevant \ntemplate (best matching) and looks inside it for the value of 'type'  - in this case, based\non the primary template, it will be void*. </p>\n<p>Regarding your point concerning partial specialization - when checking for \nwhich template is more specialized than the other, the only type that can be used\nis the unique generated type - if there are other specializations at the point\nof instantiation of the declaration (when overload resolution is being done) \nthey will be considered.  If you add them later, and they should get selected\nyou will be violating the ODR (according to 14.7.4.1)</p>\n<p>The partial/explicit specializations will also get considertaion during \nformation of the candidate set - but this time using the types of the actual arguments\nto the function.  If the best matching partial specialization (of X) results in a \nfunction type that has a better implicit conversion sequence for some \nparameter, then we never make it to the partial-ordering phase, and that \n\"better\" function will get selected (before making it to the partial \nordering phase)</p>\n<p>Here is an example with comments about what should be going on at various steps:</p>\n<pre><code>    template&lt;class T, bool=true&gt; struct X;  // Primary\n\n    template&lt;class T&gt; struct X&lt;T,true&gt; { typedef T type; };  // A\n    template&lt;&gt; struct X&lt;int*,true&gt; { typedef void* type; };  // B\n\n\n    template&lt;class T&gt; void f(T,typename X&lt;T&gt;::type); //1\n    template&lt;class T&gt; void f(T*,void*); //2\n\n\n    int main()\n    {\n      void* pv;\n      int* pi;\n\n\n      f(pi,pi);   \n      // two candidate functions: f1&lt;int*&gt;(int*,void*),  f2&lt;int&gt;(int*,void*)\n      // Note: specialization 'B' used to arrive at void* in f1\n      // neither has a better ICS than the other, so lets partially order\n      // transformed f1 is f1&lt;U1&gt;(U1,X&lt;U1,true&gt;::type) --&gt; f1&lt;U1&gt;(U1,U1) \n      //       (template 'A' used to get the second U1)\n      // obviously deduction will fail (U1,U1) -&gt; (T*,void*)\n      // and also fails the other way (U2*, void*) -&gt; (T,X&lt;T&gt;::type)\n      // can not partially order them - so ambiguity \n\n\n\n\n      f(pv,pv);  \n      // two candidate functions: f1&lt;void*&gt;(void*,void*), f2&lt;void&gt;(void*,void*)\n      // Note: specialization 'A' used to arrive at second void* in f1\n      // neither has a better ICS than the other, so lets partially order\n      // transformed f1 is f1&lt;U1&gt;(U1,X&lt;U1&gt;::type) --&gt; f1&lt;U1&gt;(U1,U1) \n      //       (template 'A' used to get the second U1)\n      // obviously deduction will fail (U1,U1) -&gt; (T*,void*)\n      // and also fails the other way (U2*, void*) -&gt; (T,X&lt;T&gt;::type)\n      // can not partially order them - so ambiguity again             \n\n    }\n</code></pre>\n<p>It's also worth mentioning that if the primary template does not have a definition - then SFINAE operates during the partial ordering phase, \nneither can be deduced from the other, and ambiguity should result.</p>\n<p>Also if you add another template that would lead to another match if the point of instantation of either of those functions is moved elsewhere in the translation unit you will clearly violate the ODR.</p>\n<blockquote>\n<p id=\"so_1180325_1184924_3\"><code>On Jul 25, 1:11 pm, Bart van Ingen Schenau &lt;b...@ingen.ddns.info&gt; wrote:</code></p>\n<p id=\"so_1180325_1184924_4\">First, being more specialised means that these are <em>fewer</em> types where\n  that template can be selected by overload resolution.\n  Using this, the rules for partial ordering can be summarised as: Try to\n  find a type for A such that A can be called but B not, or overload\n  resolution prefers to call A. If that type can be found, then B is more\n  specialised than A.</p>\n</blockquote>\n<p>No argument here.\nBut based on the rules as they are currently, the OP's example has to be \nambiguous.</p>\n<hr>\n<p>Finally, here are explicit, unambiguous answers to the two specific questions raised by litb:  </p>\n<p><b>1) Will this now use the value of T deduced for the first parameter?</b><br>\nYes - of course, it has to, it is doing template argument deduction -\nthe 'links' have to be maintained.</br></p>\n<p><b>2) Now, why do the implementations say that the second is more specialized instead?</b><br>\nBecause they are wrong ;)</br></p>\n<p>I hope this puts the issue to rest - Please let me know if there is anything that is still unclear :)</p>\n<p>Edit:\nlitb raised a good point in his comment - perhaps stating that the primary template will always get\nused for the instantiation with the unique generated type is too strong a statement.<br>\nThere are instances where the primary template will not be called.<br>\nWhat I am getting at is that when partial ordering is occuring, some unique generated type is\nused to match the best specialization.  You're right, it doesn't have to be the primary template.\nI have edited the above language to do so.\nHe also raised an issue regarding defining a better matching template after the point of instantation.\nThat will be a violation of the ODR according to the section on point of instantiation.</br></br></p>\n<hr>\n<blockquote>\n<p id=\"so_1180325_1184924_5\">The standard says that once the A/P pairs are created (using the rules of transformation as described in temp.func.order) they are deduced against each other using template argument deduction (temp.deduct)- and that section handles the case of non-deduced contexts, instantiating the template and its nested type, triggering points of instantiations. The temp.point section handles the ODR violations (the meaning of partial ordering should not change regardless of the points of instantation within a translation unit). I'm still not sure where the confusion is coming from? \u2013 Faisal Vali 1 hour ago  [delete this comment]</p>\n<p id=\"so_1180325_1184924_6\">litb: \"Note that the step that puts Q into Const::type to build the arguments is not covered explicitly by the SFINAE rule. \n  The SFINAE rules work with argument deduction, put the paragraphs that put Q into the function template function parameter list are at 14.5.5.2.'</p>\n</blockquote>\n<p>The SFINAE rules have to be used here - how could they not be? \nI feel it is sufficiently implied - i won't deny that it could be clearer, and while i encourage the committee to clarify\nthis - i don't think it needs to be clarified to interpret your example sufficiently.</p>\n<p>Let me provide one way to link them.\nFrom (14.8.2):\n\"When an explicit template argument list is specified, the template arguments must be compatible with the\ntemplate parameter list and must result in a valid function type as described below; otherwise type deduction\nfails\"</p>\n<p>From (14.5.5.2/3)\n\"The transformation used is:\n\u2014 For each type template parameter, synthesize a unique type and substitute that for each occurrence of\nthat parameter in the function parameter list, or for a template conversion function, in the return type.\"</p>\n<p>In my mind, the above quote implies that once you \"create\" unique generated types for each template parameter, the function declaration has to be\nimplicity instantiated by <em>explicitly</em> supplying the unique types as template arguments to our function template.  If this results in an invalid\nfunction type, then not only the transformation, but more importantly the subsequent template argument deduction necessary to \npartially order the function fails.</p>\n<p>From (14.5.5.2/4)\n\"Using the transformed function parameter list, perform argument deduction against the other function template. The transformed template \nis at least as specialized as the other <em>if, and only if</em>, the deduction succeeds and the deduced parameter types \nare an exact match (so the deduction does not rely on implicit conversions).\"</p>\n<p>If the transformed function parameter list leads to substitution failure, then we know deduction could not have succeeded.\nAnd since deduction did not succeed, it is not as specialized as the other - that is all we need to know to proceed \nin partial ordering the two.</p>\n<blockquote>\n<p id=\"so_1180325_1184924_7\">litb: I'm also not sure what happens in this case: <code>template&lt;typename T&gt; struct A;</code>\n<code>template&lt;typename T&gt; void f(T, typename A&lt;T&gt;::type); template&lt;typename T&gt; void f(T*, typename A&lt;T&gt;::type);</code> surely, \n  that's indended to be valid code, but doing A::type, it will fail because at the \n  template definition context, A isn't defined yet\"\n  Also note that there is no POI defined for template instantiations resulting from this\n  kind of substitution while trying to determine an ordering (partial ordering does not depend \n  on any context. It's a static property of two function templates involved).\n  I think this looks like a problem in the Standard which needs to be fixed.</p>\n</blockquote>\n<p>Ok - i think i see where we are seeing things differently.  If i understand you correctly, you are saying that\nas these function templates get declared, the compiler is keeping a track of the partial ordering amongst them, \nregardless of overload resolution ever getting triggered to select between them.\nIf that is how you interpret it, then i can see why you would expect the above behavior you describe.\nBut I do not think that the standard ever requires or mandates that.</p>\n<p>Now, the standard is clear that the partial ordering is agnostic to the type that is used in calling the function (I believe\nthis is what you are referring to when you describe it as a static property and it being context independent).</p>\n<p>The standard is also clear that it only cares about partial ordering (invokes partial ordering) between function templates \nduring the process of overload resolution (13.3.3/1) if and only if it could not pick the better function based on ICS's or \nif one is a template and the other is not. [Partial ordering of class template partial specializations is a separate issue \nand in my mind uses the relevant context (other template definitions) that requires the instantiation of that particular class.]</p>\n<p>Thus, in my opinion, since the machinery of partial ordering of function templates is invoked when overload\nresolution is performed, it has to use a relevant portion of the context (template definitions and specializations) available \nat the point when the overload resolution is being done.</p>\n<p>So based on my interepretation, according to your example using 'template struct A' above, the code is valid.\nThe partial ordering is not done at the definition context. But if/when you happen to invoke overload resolution \nbetween the two functions by writing a call to f((int*)0,0) - and at that time when the compiler either\ntries to assemble a candidate declaration or partially order them (if it gets to the partial-ordering step) \nif an invalid expression or type results as part of the function type, SFINAE helps us out and tells\nus that template deduction fails (as far as partial ordering is concerned, that implies that one\ncannot be more specialized than the other if we could not even transform the template).</p>\n<p>Now as regards POIs - if you are convinced, as I am, that the transformed function types are supposed to \nrepresent implicit instantiations using explicitly supplied template argument lists (using the uniquely generated types) \nthen the following standard quotes are relevant:</p>\n<p>14.6.4.1/1 For a function template specialization, a member function template specialization, or a specialization for a\nmember function or static data member of a class template, if the specialization is implicitly instantiated\nbecause it is referenced from within another template specialization and the context from which it is referenced\ndepends on a template parameter, the point of instantiation of the specialization is the point of instantiation\nof the enclosing specialization.</p>\n<p>The way I interpret this is that the POI of the transformed function type and the origianl function type is the\nsame as the POI for those functions created by the actual function call.  </p>\n<blockquote>\n<p id=\"so_1180325_1184924_8\">litb: Since partial ordering is rather only \n  <code>a property of the syntactic form of parameters (i.e \"T*\" against \"T(*)[N]\"),</code> \n  i would vote for amending the specification (like \"if Q appears in a nested name specifier of \n  a qualified-id naming a type, then the type named is \"Q\") \n  Or saying that the type named is another unique type. \n  <code>This means that in template&lt;typename T&gt; void f(T, typename Const&lt;T&gt;::type*);</code>\n<code>the argument list is (Q, R*), for example.</code>\n<code>Same for template&lt;typename T&gt; void f(T*, typename ConstI&lt;sizeof(T)&gt;::type);</code>\n<code>the arg lisst would be (Q*, R). A similar rule would be needed for non-type parameters, of course.</code>\n  I would have to think about it and make some test cases to see if this would yield natural orderings, though.</p>\n</blockquote>\n<p>Aah - now you are suggesting a possible solution that resolves the ambiguity in favor of what we \nall intuitively expect - this is a separate problem, and while I like the direction you are heading in, \nlike you, I too would have to put some thought into it before proclaiming its workability.</p>\n<p>Thanks for continuing the discussion.  I wish SO didn't just limit you to placing comments.</p>\n<p>Since you can edit my posts, please feel free to respond within the post if that is easier.</p>\n</hr></hr>", "LastEditorUserId": "51103", "LastActivityDate": "2009-09-20T17:36:09.137", "Score": "1", "CreationDate": "2009-07-26T16:07:51.140", "ParentId": "1180325", "CommentCount": "9", "OwnerUserId": "51103", "LastEditDate": "2009-09-20T17:36:09.137"}, "bq_ids": {"n4140": {"so_1180325_1193395_1": {"length": 15, "quality": 0.75, "section_id": 162}, "so_1180325_1193395_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 161}}, "n3337": {"so_1180325_1193395_1": {"length": 16, "quality": 0.8, "section_id": 156}, "so_1180325_1193395_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 155}}, "n4659": {"so_1180325_1193395_1": {"length": 15, "quality": 0.75, "section_id": 166}, "so_1180325_1193395_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 165}}}, "1180325": {"ViewCount": "2026", "Body": "<p>While reading another question, i came to a problem with partial ordering, which i cut down to the following test-case</p>\n<pre><code>template&lt;typename T&gt;\nstruct Const { typedef void type; };\n\ntemplate&lt;typename T&gt;\nvoid f(T, typename Const&lt;T&gt;::type*) { cout &lt;&lt; \"Const\"; } // T1\n\ntemplate&lt;typename T&gt;\nvoid f(T, void*) { cout &lt;&lt; \"void*\"; } // T2\n\nint main() {\n  // GCC chokes on f(0, 0) (not being able to match against T1)\n  void *p = 0;\n  f(0, p);\n}\n</code></pre>\n<p>For both function templates, the function type of the specialization that enters overload resolution is <code>void(int, void*)</code>. But partial ordering (according to comeau and GCC) now says that the second template is more specialized. But why?</p>\n<p>Let me go through partial ordering and show where i have questions. May <code>Q</code> be an unique made-up type used for determining partial ordering according to <code>14.5.5.2</code>.</p>\n<ul>\n<li>Transformed parameter-list for <code>T1</code> (Q inserted): <code>(Q, typename Const&lt;Q&gt;::type*)</code>. The types of the arguments are <code>AT</code> = <code>(Q, void*)</code></li>\n<li>Transformed parameter-list for <code>T2</code> (Q inserted): <code>BT</code> = <code>(Q, void*)</code>, which are also the types of the arguments. </li>\n<li>Non-transformed parameter-list for <code>T1</code>: <code>(T, typename Const&lt;T&gt;::type*)</code></li>\n<li>Non-transformed parameter-list for <code>T2</code>: <code>(T, void*)</code></li>\n</ul>\n<p>Since C++03 under-specifies this, i did use the intention that i read about in several defect reports. The above transformed parameter list for <code>T1</code> (called <code>AT</code> by me) is used as argument list for <code>14.8.2.1</code> <em>\"Deducing template arguments from a function call\"</em>. </p>\n<p><code>14.8.2.1</code> does not need to transform <code>AT</code> or <code>BT</code> itself anymore (like, removing reference declarators, etc), and goes straight to <code>14.8.2.4</code>, which independently for each <code>A</code> / <code>P</code> pair does type deduction:</p>\n<ul>\n<li><p><code>AT</code> against <code>T2</code>: <strong><code>{</code></strong> <code>(Q, T)</code><strong><code>,</code></strong> <code>(void*, void*)</code> <strong><code>}</code></strong>. <code>T</code> is the only template parameter here, and it will find that <code>T</code> must be <code>Q</code>. Type deduction succeeds trivially for <code>AT</code> against <code>T2</code>. </p></li>\n<li><p><code>BT</code> against <code>T1</code>: <strong><code>{</code></strong> <code>(Q, T)</code><strong><code>,</code></strong> <code>(void*, typename Const&lt;T&gt;::type*)</code> <strong><code>}</code></strong>. It will find that <code>T</code> is <code>Q</code>, too here. <code>typename Const&lt;T&gt;::type*</code> is an un-deduced context, and so it won't be used to deduce anything. </p></li>\n</ul>\n<hr>\n<p>Here is my first question: Will this now use the value of <code>T</code> deduced for the first parameter? If the answer is no, then the first template is more specialized. This can't be the case, because both GCC and Comeau say that the second template is more specialized, and i don't believe they are wrong. So we assume \"yes\", and insert <code>void*</code> into <code>T</code>. The paragraph (<code>14.8.2.4</code>) says <em>\"Deduction is done independently for each pair and the results are then combined\"</em> and also <em>\"In certain contexts, however, the value does not participate in type deduction, but instead uses the values of template arguments that were either deduced elsewhere or explicitly specified.\"</em> This sounds like \"yes\" too. </p>\n<p>Deduction therefore succeeds too, for every A / P pair. Now, each template is at least as specialized as the other, because deduction didn't also rely on any implicit conversions and succeeded in both directions. As a result, the call should be ambiguous. </p>\n<p>So my second question: Now, why do the implementations say that the second template is more specialized? What point did i overlook?</p>\n<hr>\n<p><strong>Edit</strong>: I tested explicit specialization and instantiation, and both, in recent GCC versions (<code>4.4</code>) tell me that the reference to the specialization is ambiguous, while an older version of GCC (<code>4.1</code>) doesn't rise that ambiguity error. This suggests that recent GCC versions have inconsistent partial ordering for function templates. </p>\n<pre><code>template&lt;typename T&gt;\nstruct Const { typedef void type; };\n\ntemplate&lt;typename T&gt;\nvoid f(T, typename Const&lt;T&gt;::type*) { cout &lt;&lt; \"Const\"; } // T1\n\ntemplate&lt;typename T&gt;\nvoid f(T, void*) { cout &lt;&lt; \"void*\"; } // T2\n\ntemplate&lt;&gt; void f(int, void*) { }\n  // main.cpp:11: error: ambiguous template specialization \n  // 'f&lt;&gt;' for 'void f(int, void*)'\n</code></pre>\n</hr></hr>", "AcceptedAnswerId": "1193395", "Title": "Partial ordering with function template having undeduced context", "CreationDate": "2009-07-24T21:45:31.957", "Id": "1180325", "CommentCount": "0", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2011-12-25T20:58:41.403", "LastEditorUserId": "963864", "LastActivityDate": "2015-07-20T16:39:49.107", "Score": "21", "OwnerUserId": "34509", "Tags": "<c++><templates><function-templates><templates-deduction><partial-ordering>", "AnswerCount": "4"}, "1180531": {"Id": "1180531", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_1180325_1180531_0\">Transformed parameter-list for T1 (Q\n  inserted): (Q, typename\n  Const::type*). The types of the\n  arguments are AT = (Q, void*)</p>\n</blockquote>\n<p>I wonder if that really is a correct simplification. When you synthesise the type <code>Q</code>, are you allowed to conjure up a specialization for <code>Const</code> for the purposes of determining the ordering of template specliazation?</p>\n<pre><code>template &lt;&gt;\nstruct Const&lt;Q&gt; { typedef int type; }\n</code></pre>\n<p>This would imply that <code>T2</code> is not at least as specialized as <code>T1</code> because a <code>void*</code> parameter does not match <code>T1</code>'s second parameter for any given template parameters.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2009-07-25T00:05:30.237", "Score": "1", "CreationDate": "2009-07-24T22:39:42.907", "ParentId": "1180325", "CommentCount": "5", "OwnerUserId": "19563", "LastEditDate": "2009-07-25T00:05:30.237"}, "1193395": {"Id": "1193395", "PostTypeId": "2", "Body": "<p>Here's my go at this.  I agree with <a href=\"https://stackoverflow.com/questions/1180325/partial-ordering-with-function-template-having-undeduced-context/1180531#1180531\">Charles Bailey</a> that the incorrect step is to go from <code>Const&lt;Q&gt;::Type*</code> to <code>void*</code></p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T, typename Const&lt;T&gt;::type*) { cout &lt;&lt; \"Const\"; } // T1\n\ntemplate&lt;typename T&gt;\nvoid f(T, void*) { cout &lt;&lt; \"void*\"; } // T2\n</code></pre>\n<p>The steps we want to take are:</p>\n<p>14.5.5.2/2</p>\n<blockquote>\n<p id=\"so_1180325_1193395_0\">Given two overloaded function templates, whether one is more specialized than another can be determined by transforming each template in turn and using argument deduction (14.8.2) to compare it to the other.</p>\n</blockquote>\n<p>14.5.5.2/3-b1</p>\n<blockquote>\n<p id=\"so_1180325_1193395_1\">For each type template parameter, synthesize a unique type and substitute that for each occurrence of that parameter in the function parameter list, or for a template conversion function, in the return type.</p>\n</blockquote>\n<p>In my opinion, the types are synthesized as follows:</p>\n<pre><code>(Q, Const&lt;Q&gt;::Type*)    // Q1\n(Q, void*)              // Q2\n</code></pre>\n<p>I don't see any wording that requires that the second synthesized parameter of <code>T1</code> be <code>void*</code>.  I don't know of any precedent for that in other contexts either.  The type <code>Const&lt;Q&gt;::Type*</code> is perfectly valid type within the C++ type system.</p>\n<p>So now we perform the deduction steps:</p>\n<p><strong>Q2 to T1</strong></p>\n<p>We try to deduce the template parameters for T1 so we have:</p>\n<ul>\n<li>Parameter 1:  <code>T</code> is deduced to be <code>Q</code></li>\n<li>Parameter 2:  Nondeduced context</li>\n</ul>\n<p>Even though parameter 2 is a non deduced context, deduction has still succeeded because we have a value for T.</p>\n<p><strong>Q1 to T2</strong></p>\n<p>Deducing the template parameters for T2 we have:</p>\n<ul>\n<li>Parameter 1:  <code>T</code> is deduced to be <code>Q</code></li>\n<li>Parameter 2:  <code>void*</code> does not match <code>Const&lt;Q&gt;::Type*</code> so deduction failure.</li>\n</ul>\n<p>IMHO, here's where the standard lets us down.  The parameter is not dependent so it's not really clear what should happen, however, my experience (based on a squinted read of 14.8.2.1/3) is that even where the parameter type P is not dependent, then the argument type A should match it.</p>\n<p>The synthesized arguments of T1 can be used to specialize T2, but not vice versa.  T2 is therefore more specialized than T1 and so is the best function.</p>\n<hr>\n<p><strong>UPDATE 1:</strong></p>\n<p>Just to cover the poing about <code>Const&lt;Q&gt;::type</code> being void.  Consider the following example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Const;\n\ntemplate&lt;typename T&gt;\nvoid f(T, typename Const&lt;T&gt;::type*) // T1\n{ typedef typename T::TYPE1 TYPE; }\n\ntemplate&lt;typename T&gt;\nvoid f(T, void*)                    // T2\n{ typedef typename T::TYPE2 TYPE ; }\n\ntemplate&lt;&gt;\nstruct Const &lt;int&gt;\n{\n  typedef void type;\n};\n\ntemplate&lt;&gt;\nstruct Const &lt;long&gt;\n{\n  typedef long type;\n};\n\nvoid bar ()\n{\n  void * p = 0;\n  f (0, p);\n}\n</code></pre>\n<p>In the above, <code>Const&lt;int&gt;::type</code> is used when we're performing the usual overload resolution rules, but not when we get to the partial overloading rules.  It would not be correct to choose an arbitrary specialization for <code>Const&lt;Q&gt;::type</code>.  It may not be intuitive, but the compiler is quite happy to have a synthasized type of the form <code>Const&lt;Q&gt;::type*</code> and to use it during type deduction.</p>\n<hr>\n<p><strong>UPDATE 2</strong></p>\n<pre><code>template &lt;typename T, int I&gt;\nclass Const\n{\npublic:\n  typedef typename Const&lt;T, I-1&gt;::type type;\n};\n\ntemplate &lt;typename T&gt;\nclass Const &lt;T, 0&gt;\n{\npublic:\n  typedef void type;\n};\n\ntemplate&lt;typename T, int I&gt;\nvoid f(T (&amp;)[I], typename Const&lt;T, I&gt;::type*)     // T1\n{ typedef typename T::TYPE1 TYPE; }\n\ntemplate&lt;typename T, int I&gt;\nvoid f(T (&amp;)[I], void*)                           // T2\n{ typedef typename T::TYPE2 TYPE ; }\n\n\nvoid bar ()\n{\n  int array[10];\n  void * p = 0;\n  f (array, p);\n}\n</code></pre>\n<p>When the <code>Const</code> template is instantiated with some value <code>I</code>, it recursively instantiates itself until <code>I</code> reaches 0. This is when the partial specialization <code>Const&lt;T,0&gt;</code> is selected. If we have a compiler which synthesizes some real type for the parameters of the function, then what value will the compiler choose for the array index? Say 10? Well, this would be fine for the above example but it wouldn't match the partial specialization <code>Const&lt;T, 10 + 1&gt;</code> which, conceptually at least, would result in an infinite number of recursive instantiations of the primary. Whatever value that it selected we could modify the end condition to be that value + 1, and then we'd have an infinite loop in the partial ordering algorithm.</p>\n<p>I do not see how the partial ordering algorithm could correctly instantiate <code>Const</code> to find what <code>type</code> really is.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-20T16:39:49.107", "Score": "5", "CreationDate": "2009-07-28T11:06:49.913", "ParentId": "1180325", "CommentCount": "19", "OwnerUserId": "11698", "LastEditDate": "2017-05-23T12:08:44.193"}});