post_cb({"bq_ids": {"n4140": {"so_26022439_26022581_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7083}}, "n3337": {"so_26022439_26022581_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6827}}, "n4659": {"so_26022439_26022581_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8584}}}, "26022566": {"Id": "26022566", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26022439_26022566_0\">Why <code>B::foo()</code> is visible here</p>\n</blockquote>\n<p>Access restrictions don't affect the visibility of names during name lookup; they are only checked after lookup has found an unambiguous match.</p>\n<blockquote>\n<p id=\"so_26022439_26022566_1\">How to make the complier see only A::foo() without changing the public interfaces of A, B or C?</p>\n</blockquote>\n<p>Add <code>using C::foo;</code> to <code>D</code>. That hides any declarations of the same name in base classes, so only that overload is visible within <code>D</code>.</p>\n<p>Alternatively, qualify the function call: <code>myD.C::foo()</code></p>\n", "LastActivityDate": "2014-09-24T17:01:29.160", "CommentCount": "0", "CreationDate": "2014-09-24T17:01:29.160", "ParentId": "26022439", "Score": "4", "OwnerUserId": "204847"}, "26022557": {"Id": "26022557", "PostTypeId": "2", "Body": "<p>I'm not really sure why the conflict arises. Thankfully though, it's pretty easy to resolve:</p>\n<pre><code>struct D:private B, public C\n{\n    using C::foo;\n};\n</code></pre>\n", "LastActivityDate": "2014-09-24T17:00:43.540", "CommentCount": "0", "CreationDate": "2014-09-24T17:00:43.540", "ParentId": "26022439", "Score": "0", "OwnerUserId": "1356926"}, "26022439": {"ViewCount": "83", "Body": "<p>Consider this small example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    void foo()\n    {\n        std::cout &lt;&lt; \"A::foo\" &lt;&lt; std::endl;\n    }\n};\n\nstruct B\n{\n    void foo()\n    {\n        std::cout &lt;&lt; \"B::foo\" &lt;&lt; std::endl;\n    }\n};\n\nstruct C:private A\n{\n    using A::foo;\n};\n\nstruct D:private B, public C\n{\n};\n\nint main()\n{\n\n    D myD;\n    myD.foo();\n    return 0;\n}\n</code></pre>\n<p>When compiling this example with g++ 4.8.1, I get these errors:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:32:9: error: request for member \u2018foo\u2019 is ambiguous\n     myD.foo();\n         ^\nprog.cpp:5:10: note: candidates are: void A::foo()\n     void foo()\n          ^\nprog.cpp:5:10: note:                 void A::foo()\nprog.cpp:13:10: note:                 void B::foo()\n     void foo()\n</code></pre>\n<p>I would have thought that the lookup for D::foo() would have ignored B::foo() because B is privately inherited from D and there's no <code>using</code> declaration in D. I would have thought that the only visible foo() would be A::foo(). </p>\n<p>But clearly I thought wrong and I've misunderstood an aspect of the <code>using</code> declaration.</p>\n<p>Can anyone explain:</p>\n<ul>\n<li><p>Why B::foo() is visible here</p></li>\n<li><p>How to make the complier see only A::foo() without changing the public interfaces of A, B or C?</p></li>\n</ul>\n", "AcceptedAnswerId": "26022581", "Title": "unexpected behaviour of using declaration with private inheritance in c++", "CreationDate": "2014-09-24T16:54:45.203", "Id": "26022439", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-09-24T17:02:33.550", "Score": "3", "OwnerUserId": "78947", "Tags": "<c++><inheritance>", "AnswerCount": "3"}, "26022581": {"Id": "26022581", "PostTypeId": "2", "Body": "<p><strong>1)</strong> Accessibility is <strong>ignored</strong> during name lookup : it doesn't matter if the member is public, private or protected : all are equally considered, which is why <code>A::foo</code> and <code>B::foo</code> are ambiguous within <code>D</code>.</p>\n<p>C++ standard section 3.4 [basic.lookup]:</p>\n<blockquote>\n<p id=\"so_26022439_26022581_0\">The access rules (Clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded</p>\n</blockquote>\n<p><strong>2)</strong> Simply bring it into scope within <code>D</code> :</p>\n<pre><code>struct D: private B, public C\n{\n    using C::foo;\n};\n</code></pre>\n", "LastActivityDate": "2014-09-24T17:02:33.550", "CommentCount": "0", "CreationDate": "2014-09-24T17:02:33.550", "ParentId": "26022439", "Score": "6", "OwnerUserId": "3510483"}});