post_cb({"27090513": {"ParentId": "27090093", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-23T15:18:22.607", "Score": "4", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-23T15:24:12.133", "Id": "27090513", "OwnerUserId": "3647361", "Body": "<pre><code>const _ab &amp; i();\n</code></pre>\n<p>The standard explains this in a note in [dcl.init]/8:</p>\n<blockquote>\n<p id=\"so_27090093_27090513_0\">[ <em>Note:</em> Since <code>()</code> is not permitted by the syntax for initializer,</p>\n<pre><code>X a();\n</code></pre>\n<p id=\"so_27090093_27090513_1\">is not the declaration of an object of class <code>X</code>, but the declaration\n  of a function taking no argument and returning an <code>X</code>.</p>\n</blockquote>\n<p>This applies regardless of the type and is referred to as the most vexing parse. Of course <code>i.a</code> is thus ill-formed.</p>\n<hr>\n<blockquote>\n<p id=\"so_27090093_27090513_2\">But still can somebody explain me why references have the possibility\n  to be initialized with initialization list and for what is it used?</p>\n</blockquote>\n<p>[dcl.init]/3:</p>\n<blockquote>\n<p id=\"so_27090093_27090513_3\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li><p id=\"so_27090093_27090513_4\">[..]</p></li>\n<li><p id=\"so_27090093_27090513_5\">Otherwise, if the initializer list has a single element of type <code>E</code> and either T is not a reference type or its referenced type is\n  reference-related to <code>E</code>, the object or reference is initialized from\n  that element; if a narrowing conversion (see below) is required to\n  convert the element to T, the program is ill-formed.</p></li>\n<li><p id=\"so_27090093_27090513_6\">Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by T is copy-list-initialized or\n  direct-list-initialized, depending on the kind of initialization for\n  the reference, and the reference is bound to that temporary.<br>[ <em>Note:</em> As usual, the binding will fail and the program is ill-formed if the\n  reference type is an lvalue reference to a non-const type. <em>\u2014 end note</em> ]</br></p></li>\n</ul>\n</blockquote>\n<p>The last note refers to the fact that</p>\n<pre><code>int&amp; i = {1};\n</code></pre>\n<p>Is ill-formed since we would have to bind <code>1</code> to a non-const lvalue reference, which isn't possible. Neither would</p>\n<pre><code>std::string&amp; s = {20, '5'};\n</code></pre>\n<p>be valid since we have to initialize a non-const lvalue reference with a temporary.<br>\nThe standard then gives examples:</br></p>\n<pre><code>struct S {\n    S(std::initializer_list&lt;double&gt;); // #1\n    S(const std::string&amp;);            // #2\n    // ...\n};\n\nconst S&amp; r1 = { 1, 2, 3.0 };    // OK: invoke #1\nconst S&amp; r2 { \"Spinach\" };      // OK: invoke #2\nS&amp; r3 = { 1, 2, 3 };            // error: initializer is not an lvalue\nconst int&amp; i1 = { 1 };          // OK\nconst int&amp; i2 = { 1.1 };        // error: narrowing\nconst int (&amp;iar)[2] = { 1, 2 }; // OK: iar is bound to temporary array\n</code></pre>\n<p>This can also be particularly useful for function calls.</p>\n<pre><code>void f(std::vector&lt;int&gt; const&amp;);\n\nf( {first, last} );\n</code></pre>\n</hr>", "LastActivityDate": "2014-11-23T15:24:12.133"}, "27090116": {"ParentId": "27090093", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-11-23T14:40:26.997", "Score": "3", "LastEditorUserId": "157344", "LastEditDate": "2014-11-23T15:03:50.743", "Id": "27090116", "OwnerUserId": "157344", "Body": "<p><code>const _ab &amp; i();</code> </p>\n<p>Above code declares <strike>(and calls)</strike> a <em>function</em> that returns a const reference to _ab struct - that's the first error. The second error is that you try to access a member variable of a function (<code>i</code>), which is not possible.</p>\n<p>To use default constructor you could use the new <code>{...}</code> C++11 syntax, it should work in your example</p>\n<pre><code>const _ab &amp; i {}; // probably will work fine\n</code></pre>\n<p>however omiting the braces will lead to an error - this one will not work:</p>\n<pre><code>const _ab &amp; i;  // error\n</code></pre>\n<p>This should also work fine:</p>\n<pre><code>const _ab &amp; i = {};\n</code></pre>\n<p>EDIT:</p>\n<p>You can initialize reference with an \"anonymous\" object (like in all your examples) only if that is a <code>const</code> reference. It's allowed in the language, I'm not sure there's any deeper reason for that and why it shouldn't be allowed. So you don't actually initialize reference with initializer list (or whatever) - these are used to initialize an anonymous object, and this anonymous object is used as a \"target\" for the const reference. If you'd declare the constructor to be <code>explicit</code>, you'd need to specify the type, so maybe in that case it wouldn't be so confusing as for what the initializer is actually used:</p>\n<pre><code>const _ab &amp; i = _ab{/*...*/};\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>const _ab anonymousObject = _ab{/*...*/};\nconst _ab &amp; i = anonymousObject;\n</code></pre>\n", "LastActivityDate": "2014-11-23T15:03:50.743"}, "27090093": {"CommentCount": "2", "AcceptedAnswerId": "27090513", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-11-23T14:37:08.597", "LastActivityDate": "2016-03-18T10:39:06.067", "LastEditDate": "2016-03-18T10:39:06.067", "ViewCount": "316", "FavoriteCount": "1", "Title": "Reference initialization forms", "Id": "27090093", "Score": "4", "Body": "<p>So I was testing some of the reference initialization forms, described <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization\" rel=\"nofollow\">here</a>. I wonder when the:</p>\n<pre><code>T &amp; ref = { arg1, arg2, ... };\n</code></pre>\n<p>and</p>\n<pre><code>T &amp;&amp; ref = { arg1, arg2, ... };\n</code></pre>\n<p>forms will be ever used and for what exactly. I suppose it's for initializing temporary arrays and constructors with 'initializer_list', like this:</p>\n<pre><code>int main()\n{\n\n\n    struct _ab\n    {\n        _ab() {cout &lt;&lt; \"_ab()\" &lt;&lt; endl;}\n\n        _ab(initializer_list&lt;int&gt; iArr) : a(*iArr.begin()), b(*iArr.end()) {cout &lt;&lt; \"_ab()\" &lt;&lt; endl;}\n\n        ~_ab() {cout &lt;&lt; \"~_ab()\" &lt;&lt; endl;}\n        int a, b;\n    };\n    const _ab &amp; i = {1, 2};\n\n    cout &lt;&lt; i.a &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>In this context I tried to initialize the const reference with a temporary '_ab' object using the default constructor like this:</p>\n<pre><code>int main()\n    {\n\n\n        struct _ab\n        {\n            _ab() {cout &lt;&lt; \"_ab()\" &lt;&lt; endl;}\n\n            _ab(initializer_list&lt;int&gt; iArr) : a(*iArr.begin()), b(*iArr.end()) {cout &lt;&lt; \"_ab()\" &lt;&lt; endl;}\n\n            ~_ab() {cout &lt;&lt; \"~_ab()\" &lt;&lt; endl;}\n            int a, b;\n        };\n        const _ab &amp; i(); // error 1\n\n        cout &lt;&lt; i.a &lt;&lt; endl; // error 2\n\n        return 0;\n    }\n</code></pre>\n<p>But this example didn't compile with 2 errors:</p>\n<blockquote>\n<p id=\"so_27090093_27090093_0\">error 1: 'const main()::_ab&amp; i()', declared using local type 'const\n  main()::_ab', is used but never defined [-fpermissive]|</p>\n<p id=\"so_27090093_27090093_1\">error 2: request for member 'a' in 'i', which is of non-class type\n  'const main()::_ab&amp;()'|</p>\n</blockquote>\n<p>Can you enlighten me about what exactly the above 2 construct means &amp; are used for.</p>\n<p>EDIT: I understand the problem with the second example. It was declaring a function instead of variable. But still can somebody explain me why references have the possibility to be initialized with initialization list and for what is it used?</p>\n", "Tags": "<c++><c++11><gcc><language-lawyer><c++14>", "OwnerUserId": "4031604", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27090093_27090513_1": {"section_id": 3290, "quality": 1.0, "length": 9}, "so_27090093_27090513_3": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_27090093_27090513_6": {"section_id": 3325, "quality": 0.9, "length": 27}, "so_27090093_27090513_0": {"section_id": 3290, "quality": 0.8, "length": 4}, "so_27090093_27090093_1": {"section_id": 6441, "quality": 0.5714285714285714, "length": 4}, "so_27090093_27090513_5": {"section_id": 3325, "quality": 1.0, "length": 25}}, "n3337": {"so_27090093_27090513_1": {"section_id": 3160, "quality": 1.0, "length": 9}, "so_27090093_27090513_3": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_27090093_27090513_6": {"section_id": 3195, "quality": 0.7, "length": 21}, "so_27090093_27090513_0": {"section_id": 3160, "quality": 0.8, "length": 4}, "so_27090093_27090093_1": {"section_id": 6198, "quality": 0.5714285714285714, "length": 4}, "so_27090093_27090513_5": {"section_id": 3195, "quality": 0.76, "length": 19}}, "n4659": {"so_27090093_27090513_5": {"section_id": 4091, "quality": 1.0, "length": 25}, "so_27090093_27090513_1": {"section_id": 4052, "quality": 1.0, "length": 9}, "so_27090093_27090513_3": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_27090093_27090513_6": {"section_id": 4091, "quality": 0.7, "length": 21}, "so_27090093_27090513_0": {"section_id": 4052, "quality": 0.8, "length": 4}}}, "27090573": {"ParentId": "27090093", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-23T15:23:25.890", "Score": "0", "LastEditorUserId": "981959", "LastEditDate": "2014-11-23T15:30:23.050", "Id": "27090573", "OwnerUserId": "981959", "Body": "<p>What you're seeing is similar to the case that allows binding an rvalue to a const-reference e.g.</p>\n<pre><code>std::string str() { return \"blah\"; }\n\nconst std::string&amp; s = str();\n</code></pre>\n<p>The prvalue returned by the function is bound to the reference and its lifetime is extended until the reference's lifetime ends.</p>\n<p>Another way to exercise that same rule is just by creating a temporary object directly:</p>\n<pre><code>const std::string&amp; s = std::string();\n</code></pre>\n<p>This creates a temporary which is bound to the reference (extending its lifetime to the reference's lifetime).</p>\n<p>The case of <code>const _ab&amp; i = {1, 2}</code> is very similar, but relies on an implicit temporary of type <code>_ab</code> being constructed from the braced-init-list i.e. it's similar to this:</p>\n<pre><code>const _ab&amp; i = _ab{1, 2};\n</code></pre>\n<p>(The difference is that the first form won't work if the initializer_list constructor for <code>_ab</code> is <code>explicit</code> whereas the second one will work even for explicit constructors ... but marking initializer-list constructors <code>explicit</code> is a bad idea and should be avoided, because it makes it difficult and confusing to initialize objects).</p>\n<p>This syntax isn't necessarily useful exactly as written above, because you'd usually just write <code>const _ab{1, 2};</code> instead of using a reference. But when you are calling a function that takes a const-reference it's useful to be able to initialize the argument with a braced-init-list, e.g. a function taking <code>std::pair&lt;int, const char*&gt;</code> can be called as <code>func({1, \"two\"})</code>, which is more convenient than the C++03 equivalent: <code>func(std::make_pair(1, \"two\"))</code>. In order for that to work, it has to be possible for list-initialization of references to cause the implicit creation of a temporary, which leads to the <code>const _ab&amp; = {1, 2}</code> form you're asking about.</p>\n", "LastActivityDate": "2014-11-23T15:30:23.050"}});