post_cb({"bq_ids": {"n4140": {"so_32685319_32686009_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 5862}}, "n3337": {"so_32685319_32686009_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 5632}}, "n4659": {"so_32685319_32686009_0": {"length": 32, "quality": 0.7619047619047619, "section_id": 7345}}}, "32685319": {"ViewCount": "265", "Body": "<p>Consider the code below:</p>\n<pre><code>struct Foo {\n    struct Bar;\n    Foo()\n    {\n        Bar bar; // Why isn't Bar an incomplete type?!\n    }\n    struct Bar {}; // Full definition\n};\n\n// struct Bar {}; // fails to compile due to incomplete type\n\nint main()\n{\n    Foo foo;\n}\n</code></pre>\n<p>It compiles fine under at least 2 compilers (gcc5.2, clang3.5). My question is:</p>\n<ul>\n<li>Why isn't <code>Bar</code> considered an incomplete type in the constructor <code>Foo::Foo</code>, as I forward-declare it above the constructor but fully use it inside the constructor? </li>\n</ul>\n<p>Whenever I move <code>Foo::Bar</code> outside the class, in other words <code>Bar</code> becomes a stand-alone class, I get the expected </p>\n<blockquote>\n<p id=\"so_32685319_32685319_0\">error: aggregate 'Foo::Bar bar' has incomplete type and cannot be defined</p>\n</blockquote>\n", "AcceptedAnswerId": "32686009", "Title": "Why an inline declaration is not an incomplete type?", "CreationDate": "2015-09-20T23:20:34.953", "Id": "32685319", "CommentCount": "2", "LastEditDate": "2015-10-05T03:11:42.663", "PostTypeId": "1", "LastEditorUserId": "3093378", "LastActivityDate": "2015-10-05T03:11:42.663", "Score": "14", "OwnerUserId": "3093378", "Tags": "<c++><incomplete-type>", "AnswerCount": "1"}, "32686009": {"Id": "32686009", "PostTypeId": "2", "Body": "<p>Within the member specification the class is considered complete within function bodies, from the draft C++ standard section <code>9.2</code> <em>[class.mem]</em>:</p>\n<blockquote>\n<p id=\"so_32685319_32686009_0\">A class is considered a completely-defined object type (3.9) (or\n  complete type) at the closing } of the class-specifier. <strong>Within the\n  class member-specification, the class is regarded as complete within\n  function bodies</strong>, default arguments, using-declarations introducing\n  inheriting constructors (12.9), exception-specifications, and\n  brace-or-equal-initializers for non-static data members (including\n  such things in nested classes). Otherwise it is regarded as incomplete\n  within its own class member-specification</p>\n</blockquote>\n<p>Which means you don't even have to forward declare <code>Bar</code> (<em><a href=\"http://melpon.org/wandbox/permlink/LwUlYn675n2f7Zvb\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>struct Foo {\n    Foo()\n    {\n        Bar bar; \n    }\n    struct Bar {};  \n};\n</code></pre>\n<p>Forward declaring could be useful in avoiding violation of section <a href=\"https://stackoverflow.com/a/26682543/1708801\">3.3.7 paragraph 2 and 3</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-21T17:36:10.123", "Score": "8", "CreationDate": "2015-09-21T01:15:45.233", "ParentId": "32685319", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:30:19.230"}});