post_cb({"19564547": {"ParentId": "19564455", "CommentCount": "1", "Body": "<p>you are trying to write in a memory location not allocated by you.</p>\n<p>*a = 5;</p>\n<p>and then trying to delete a memory not allocated by you</p>\n<p>delete a;</p>\n<p>it has undefined behavior.</p>\n", "OwnerUserId": "1073981", "PostTypeId": "2", "Id": "19564547", "Score": "0", "CreationDate": "2013-10-24T11:21:57.887", "LastActivityDate": "2013-10-24T11:21:57.887"}, "19564499": {"ParentId": "19564455", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You have three cases of undefined behavior: The first is with your dereferencing and assigning using the uninitialized pointer <code>a</code>, the second is the dereferencing when printing <code>a</code>, and the last is when deleting <code>a</code>.</p>\n", "OwnerUserId": "440558", "LastEditorUserId": "440558", "LastEditDate": "2013-10-24T11:26:41.313", "Id": "19564499", "Score": "0", "CreationDate": "2013-10-24T11:19:47.187", "LastActivityDate": "2013-10-24T11:26:41.313"}, "19564632": {"ParentId": "19564455", "CommentCount": "0", "Body": "<p>After your editing, you only have one case of undefined behaviour: \n<code>delete</code>ing memory you did not aquire by <code>new</code>.</p>\n<p><code>delete</code> on a NULL-pointer is guaranteed to do no harm.\nBut <code>delete</code> on memory you did not allocate or deleted before is undefined. The implementations I know exit your program with some sort of access violation.</p>\n", "OwnerUserId": "2746744", "PostTypeId": "2", "Id": "19564632", "Score": "6", "CreationDate": "2013-10-24T11:26:06.840", "LastActivityDate": "2013-10-24T11:26:06.840"}, "24905746": {"ParentId": "19564455", "CommentCount": "0", "Body": "<p>You are trying to delete the stack memory. In stack memory will be contagious if you tried to delete it undefined behavior will occur.</p>\n<p>For heap memory allocation will not be contagious. </p>\n", "OwnerUserId": "3867890", "PostTypeId": "2", "Id": "24905746", "Score": "0", "CreationDate": "2014-07-23T08:41:15.987", "LastActivityDate": "2014-07-23T08:41:15.987"}, "19565322": {"ParentId": "19564455", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Calling <em>delete</em> on a pointer that has not been allocated with <em>new</em> or a <em>null pointer</em> is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> the draft C++ standard section <code>5.3.5</code> <em>Delete</em> paragraph <em>2</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19564455_19565322_0\">[...]In the first alternative (delete object), the value of the operand of delete may be a null pointer value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined.</p>\n</blockquote>\n<p>as with all <em>undefined behavior</em> anything is possible, the program could even seem to work fine but results are unreliable.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-10-24T12:12:13.390", "Id": "19565322", "Score": "0", "CreationDate": "2013-10-24T11:59:01.993", "LastActivityDate": "2013-10-24T12:12:13.390"}, "19564455": {"CommentCount": "1", "ViewCount": "1748", "PostTypeId": "1", "LastEditorUserId": "1395384", "CreationDate": "2013-10-24T11:17:36.863", "LastActivityDate": "2014-07-23T08:41:15.987", "Title": "What happens when we use delete on a pointer to an object not allocated with new operator?", "LastEditDate": "2013-10-25T05:58:11.967", "Id": "19564455", "Score": "-3", "Body": "<p>The below code compiles fine but does not execute</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int *a;\n    int b = 5;\n    a = &amp;b;\n    cout &lt;&lt; *a &lt;&lt; endl;\n    delete a;\n    return 0;\n}\n</code></pre>\n<p>EDIT:</p>\n<pre><code>int main()\n{\n    int *a = 0;\n    delete a;\n    return 0;\n}\n</code></pre>\n<p>This works fine. Why is that so?</p>\n", "Tags": "<c++><new-operator><delete-operator>", "OwnerUserId": "1395384", "AnswerCount": "7"}, "19564473": {"ParentId": "19564455", "CommentCount": "0", "Body": "<p>It causes <strong>undefined behavior</strong></p>\n<ol>\n<li>You are using unallocated memory to store data</li>\n<li>You are deleting memory that was not allocated</li>\n</ol>\n<p>Both of these factors most probably cause a crash with \"access violation\".</p>\n<p>But, as behavior is undefined, application can work.</p>\n", "OwnerUserId": "1132871", "PostTypeId": "2", "Id": "19564473", "Score": "0", "CreationDate": "2013-10-24T11:18:46.947", "LastActivityDate": "2013-10-24T11:18:46.947"}, "bq_ids": {"n4140": {"so_19564455_19565322_0": {"section_id": 6106, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_19564455_19565322_0": {"section_id": 5872, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_19564455_19565322_0": {"section_id": 7603, "quality": 0.9629629629629629, "length": 26}}}, "19564828": {"ParentId": "19564455", "CommentCount": "0", "Body": "<p>\"Undefined Behaviour\" means that there is no guaranteed post-condition for what you did.</p>\n<p>People will often say that the \"compiler\" chooses what happens. In reality, the compiler will compile it, and the heap manager decides at runtime how it handles the situation where you call an invalid delete call.</p>\n<p>Although the case here looks trivial to catch at compiler level, there are many cases where it is simply beyond the scope of the compiler to do so.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "19564828", "Score": "1", "CreationDate": "2013-10-24T11:36:38.127", "LastActivityDate": "2013-10-24T11:36:38.127"}});