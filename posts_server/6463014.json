post_cb({"6463014": {"CommentCount": "3", "ViewCount": "567", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-06-24T03:28:18.023", "LastActivityDate": "2016-06-21T22:19:27.963", "Title": "Why does stringizing an euro sign within a string literal using UTF8 not produce an UCN?", "FavoriteCount": "2", "LastEditDate": "2016-06-21T22:19:27.963", "Id": "6463014", "Score": "7", "Body": "<p>The spec says that at phase 1 of compilation</p>\n<blockquote>\n<p id=\"so_6463014_6463014_0\">Any source \ufb01le character not in the basic source character set (2.3) is replaced by the universal-character-name that designates that character. </p>\n</blockquote>\n<p>And at phase 4 it says</p>\n<blockquote>\n<p id=\"so_6463014_6463014_1\">Preprocessing directives are executed, macro invocations are expanded</p>\n</blockquote>\n<p>At phase 5, we have</p>\n<blockquote>\n<p id=\"so_6463014_6463014_2\">Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name in a character literal or a non-raw string literal, is converted to the corresponding member of the execution character set </p>\n</blockquote>\n<p>For the <code>#</code> operator, we have</p>\n<blockquote>\n<p id=\"so_6463014_6463014_3\">a <code>\\</code> character is inserted before each <code>\"</code> and <code>\\</code> character of a character literal or string literal (including the delimiting <code>\"</code> characters).</p>\n</blockquote>\n<p>Hence I conducted the following test</p>\n<pre><code>#define GET_UCN(X) #X\nGET_UCN(\"\u20ac\")\n</code></pre>\n<p>With an input character set of UTF-8 (matching my file's encoding), I expected the following preprocessing result of the <code>#X</code> operation: <code>\"\\\"\\\\u20AC\\\"\"</code>. GCC, Clang and boost.wave don't transform the <code>\u20ac</code> into a UCN and instead yield <code>\"\\\"\u20ac\\\"\"</code>. I feel like I'm missing something. Can you please explain?</p>\n", "Tags": "<c++><c-preprocessor>", "OwnerUserId": "34509", "AnswerCount": "4"}, "6463725": {"ParentId": "6463014", "CommentCount": "3", "Body": "<p>I'm not sure where you got that citation for translation phase 1\u2014the <a href=\"http://code.google.com/p/yesanshare/downloads/detail?name=ISO-C-FDIS.1999-04.pdf&amp;can=2&amp;q=\" rel=\"nofollow\">C99 standard</a> says this about translation phase 1 in \u00a75.1.1.2/1:</p>\n<blockquote>\n<p id=\"so_6463014_6463725_0\">Physical source file multibyte characters are mapped, in an implementation-defined manner, to the source character set (introducing new-line characters for end-of-line indicators) if necessary. Trigraph sequences are replaced by corresponding single-character internal representations.</p>\n</blockquote>\n<p>So in this case, the Euro character \u20ac (represented as the multibyte sequence E2 82 AC in UTF-8) is mapped into the execution character set, which also happens to be UTF-8, so its representation remains the same.  It doesn't get converted into a universal character name because, well, there's nothing that says that it should.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "6463725", "Score": "-1", "CreationDate": "2011-06-24T05:18:50.073", "LastActivityDate": "2011-06-24T05:18:50.073"}, "6463333": {"ParentId": "6463014", "CommentCount": "0", "Body": "<p>\"and universal-character-name in a character literal or a non-raw string literal, is converted to the corresponding member of the execution character set\"</p>\n<p>used to be</p>\n<p>\"or universal-character-name in character literals and string literals is converted to a member of the execution character set\"</p>\n<p>Maybe you need a future version of g++.</p>\n", "OwnerUserId": "23705", "PostTypeId": "2", "Id": "6463333", "Score": "-1", "CreationDate": "2011-06-24T04:22:45.123", "LastActivityDate": "2011-06-24T04:22:45.123"}, "6463292": {"ParentId": "6463014", "CommentCount": "2", "Body": "<p>I suspect you'll find that the euro sign does not satisfy the condition <code>Any source \ufb01le character not in the basic source character set</code> so the rest of the text you quote doesn't apply.</p>\n<p>Open your test file with your favourite binary editor and check what value is used to represent the euro sign in <code>GET_UCN(\"\u20ac\")</code></p>\n", "OwnerUserId": "654614", "PostTypeId": "2", "Id": "6463292", "Score": "-2", "CreationDate": "2011-06-24T04:17:24.187", "LastActivityDate": "2011-06-24T04:17:24.187"}, "bq_ids": {"n4140": {"so_6463014_6472770_0": {"section_id": 5313, "quality": 1.0, "length": 24}, "so_6463014_6463014_1": {"section_id": 5313, "quality": 1.0, "length": 6}, "so_6463014_6463014_2": {"section_id": 5313, "quality": 1.0, "length": 25}, "so_6463014_6463725_0": {"section_id": 5313, "quality": 0.875, "length": 21}, "so_6463014_6463014_0": {"section_id": 5313, "quality": 0.75, "length": 9}, "so_6463014_6463014_3": {"section_id": 526, "quality": 1.0, "length": 12}}, "n3337": {"so_6463014_6472770_0": {"section_id": 5110, "quality": 1.0, "length": 24}, "so_6463014_6463014_1": {"section_id": 5110, "quality": 1.0, "length": 6}, "so_6463014_6463014_2": {"section_id": 5110, "quality": 1.0, "length": 25}, "so_6463014_6463725_0": {"section_id": 5110, "quality": 0.875, "length": 21}, "so_6463014_6463014_0": {"section_id": 5110, "quality": 0.75, "length": 9}, "so_6463014_6463014_3": {"section_id": 517, "quality": 1.0, "length": 12}}, "n4659": {"so_6463014_6472770_0": {"section_id": 6737, "quality": 1.0, "length": 24}, "so_6463014_6463014_1": {"section_id": 6737, "quality": 1.0, "length": 6}, "so_6463014_6463725_0": {"section_id": 6737, "quality": 0.75, "length": 18}, "so_6463014_6463014_2": {"section_id": 6737, "quality": 1.0, "length": 25}, "so_6463014_6463014_0": {"section_id": 6737, "quality": 0.75, "length": 9}, "so_6463014_6463014_3": {"section_id": 547, "quality": 1.0, "length": 12}}}, "6472770": {"ParentId": "6463014", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It's simply a bug. \u00a72.1/1 says about Phase 1,</p>\n<blockquote>\n<p id=\"so_6463014_6472770_0\">(An implementation may use any internal encoding, so long as an actual extended character encountered in the source file, and the same extended character expressed in the source file as a universal-character-name (i.e. using the \\uXXXX notation), are handled equivalently.)</p>\n</blockquote>\n<p>This is not a note or footnote. C++0x adds an exception for raw string literals, which might solve your problem at hand if you have one.</p>\n<p>This program clearly demonstrates the malfunction:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define GET_UCN(X) L ## #X\n\nint main() {\nstd::wcout &lt;&lt; GET_UCN(\"\u20ac\") &lt;&lt; '\\n' &lt;&lt; GET_UCN(\"\\u20AC\") &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://ideone.com/lb9jc\" rel=\"nofollow\">http://ideone.com/lb9jc</a></p>\n<p>Because both strings are wide, the first is required to be corrupted into several characters if the compiler fails to interpret the input multibyte sequence. In your given example, total lack of support for UTF-8 could cause the compiler to slavishly echo the sequence right through.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2011-06-24T19:31:20.847", "Id": "6472770", "Score": "1", "CreationDate": "2011-06-24T19:22:41.697", "LastActivityDate": "2011-06-24T19:31:20.847"}});