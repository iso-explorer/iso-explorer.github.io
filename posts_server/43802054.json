post_cb({"43802054": {"CommentCount": "3", "ViewCount": "97", "PostTypeId": "1", "LastEditorUserId": "2374540", "CreationDate": "2017-05-05T10:01:43.607", "LastActivityDate": "2017-05-05T11:36:32.390", "Title": "How can I resolve ellipsis ambiguity?", "LastEditDate": "2017-05-05T10:34:36.080", "Id": "43802054", "Score": "2", "Body": "<p>Next code will compile with <code>error: call of overloaded 'f(int)' is ambiguous</code></p>\n<p>Can I resolve this without using <code>va_list</code> when I call <code>f</code> with one parameter?</p>\n<hr>\n<p>It is for a printf kind of function. I just wondering if I can make more efficient with handling the simple case separately without introducing a new name.</p>\n<p>Is there any workaround?</p>\n<pre><code>#include &lt;cstdarg&gt;\n\nvoid f(int n, ...) {\n    va_list args;\n    va_start(args, n);\n    //Do something\n    va_end(args);\n}\n\nvoid f(int n) {\n    //Do something without va_list\n}\n\nint main() {\n    f(42);\n    return 0;\n}\n</code></pre>\n</hr>", "Tags": "<c++><ellipsis><ambiguous>", "OwnerUserId": "2374540", "AnswerCount": "1"}, "43802594": {"ParentId": "43802054", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You can't have that overload (plainly), since it will always be ambiguous. The following paragraphs in the standard are pertinent, I think:</p>\n<p><a href=\"http://eel.is/c++draft/over.match.viable\" rel=\"nofollow noreferrer\">[over.match.viable]</a></p>\n<blockquote>\n<p id=\"so_43802054_43802594_0\">1 From the set of candidate functions constructed for a given context\n  ([over.match.funcs]), <strong>a set of viable functions is chosen, from which\n  the best function will be selected by comparing argument conversion\n  sequences for the best fit</strong> ([over.match.best]). The selection of\n  viable functions considers relationships between arguments and\n  function parameters other than the ranking of conversion sequences.</p>\n<p id=\"so_43802054_43802594_1\">2 <strong>First, to be a viable function, a candidate function shall have\n  enough parameters to agree in number with the arguments in the list.</strong></p>\n<ul>\n<li><p id=\"so_43802054_43802594_2\">If there are m arguments in the list, all candidate functions having exactly m parameters are viable.</p></li>\n<li><p id=\"so_43802054_43802594_3\">A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter list ([dcl.fct]). For the\n  purposes of overload resolution, any argument for which there is no\n  corresponding parameter is considered to \u201cmatch the ellipsis\u201d\n  ([over.ics.ellipsis]) .</p></li>\n<li><p id=\"so_43802054_43802594_4\">A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a default argument.130 For the purposes of\n  overload resolution, the parameter list is truncated on the right, so\n  that there are exactly m parameters.</p></li>\n</ul>\n</blockquote>\n<p>So both overloads are viable functions to call. Now the compiler has to determine which is a better candidate based on the conversion sequences for the argument you provided. And they are both equally good in that regard, no conversion is required for 42 in either case.</p>\n<hr>\n<h2>A possible solution</h2>\n<p>Let's take advantage of the other overloading rules. A template function that is generated and found in overload resolution is considered a lesser match than a non-template function. So let's make the ellipsis version a template:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;cstdarg&gt;\n\nvoid vf(int n, std::va_arg args) {\n    //Do something with args\n}\n\ntemplate&lt;typename T&gt;\nauto f(T n, ...)\n  -&gt; std::enable_if_t&lt;std::is_same&lt;T, int&gt;::value&gt; {\n  std::va_list args;\n  va_start(args, n);\n  vf(n, args);\n  va_end(args);\n}\n\nvoid f(int n) {\n    //Do something without va_list\n}\n\nint main() {\n    f(42);\n    f(42, 53);\n    return 0;\n}\n</code></pre>\n<p>But we'll apply SFINAE to the return type, so it could only be instantiated when T is an int (thus giving you your original function). Now the ellipsis version is chosen only when the single parameter version is not viable anymore, i.e. when there is more than one parameter.</p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-05-05T11:36:32.390", "Id": "43802594", "Score": "4", "CreationDate": "2017-05-05T10:27:52.417", "LastActivityDate": "2017-05-05T11:36:32.390"}, "bq_ids": {"n4140": {"so_43802054_43802594_4": {"section_id": 601, "quality": 0.8636363636363636, "length": 19}, "so_43802054_43802594_2": {"section_id": 601, "quality": 1.0, "length": 10}, "so_43802054_43802594_1": {"section_id": 601, "quality": 1.0, "length": 12}, "so_43802054_43802594_3": {"section_id": 601, "quality": 0.8695652173913043, "length": 20}, "so_43802054_43802594_0": {"section_id": 600, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_43802054_43802594_4": {"section_id": 591, "quality": 0.8636363636363636, "length": 19}, "so_43802054_43802594_2": {"section_id": 591, "quality": 1.0, "length": 10}, "so_43802054_43802594_1": {"section_id": 591, "quality": 1.0, "length": 12}, "so_43802054_43802594_3": {"section_id": 591, "quality": 0.8695652173913043, "length": 20}, "so_43802054_43802594_0": {"section_id": 590, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_43802054_43802594_4": {"section_id": 627, "quality": 0.8636363636363636, "length": 19}, "so_43802054_43802594_0": {"section_id": 626, "quality": 0.8947368421052632, "length": 34}, "so_43802054_43802594_1": {"section_id": 627, "quality": 1.0, "length": 12}, "so_43802054_43802594_2": {"section_id": 627, "quality": 1.0, "length": 10}, "so_43802054_43802594_3": {"section_id": 627, "quality": 0.8695652173913043, "length": 20}}}});