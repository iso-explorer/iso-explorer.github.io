post_cb({"46608738": {"CommentCount": "0", "AcceptedAnswerId": "46608866", "PostTypeId": "1", "LastEditorUserId": "4723722", "CreationDate": "2017-10-06T15:05:06.453", "LastActivityDate": "2017-10-07T17:42:27.957", "LastEditDate": "2017-10-06T15:23:09.873", "ViewCount": "148", "FavoriteCount": "0", "Title": "c++ template type deduction fail in cast operator", "Id": "46608738", "Score": "8", "Body": "<p>I have simplified my somewhat more difficult problem to this:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2660b33492651e92\" rel=\"noreferrer\">http://coliru.stacked-crooked.com/a/2660b33492651e92</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename C&gt;\nstruct get_type\n{\n    C operator()() const = delete;\n};\n\ntemplate&lt;&gt;\nstruct get_type&lt;std::string&gt;\n{\n    std::string operator()() const { return \"asd\"; }\n};\n\ntemplate&lt;&gt;\nstruct get_type&lt;size_t&gt; {\n    size_t operator()() const { return 6; }\n};\n\nstruct S\n{\n    S(){}\n    template&lt;typename T&gt;\n    operator T() { return get_type&lt;T&gt;{}(); }\n};\n\nstruct A\n{\n    A() :s{S{}}, n{S{}} {}\n    std::string s;\n    size_t n;\n};\n\nint main()\n{\n    A a;\n    std::cout &lt;&lt; \"Spock out.\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates the following error:</p>\n<pre><code>'In instantiation of 'S::operator T() [with T = char]':'...\n</code></pre>\n<p>Why is T is deduced to char and not std::string?</p>\n<p><strong>Edit:</strong></p>\n<p>@YSC's answer seems to be correct:\n<a href=\"https://stackoverflow.com/a/46608866/4723722\">https://stackoverflow.com/a/46608866/4723722</a></p>\n<p>I edited the post to add a solution:\n<a href=\"http://coliru.stacked-crooked.com/a/06d31d981acd2544\" rel=\"noreferrer\">http://coliru.stacked-crooked.com/a/06d31d981acd2544</a></p>\n<pre><code>struct S\n{\n    S(){}\n    template&lt;typename T&gt;\n    explicit operator T() { return get_type&lt;T&gt;{}(); }\n};\n</code></pre>\n", "Tags": "<c++><templates><casting><template-meta-programming><type-deduction>", "OwnerUserId": "4723722", "AnswerCount": "2"}, "46608866": {"ParentId": "46608738", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Here:</p>\n<pre><code>A() : s( S{} ), ...\n</code></pre>\n<p>the construction of <code>A::s</code> from a <code>S</code> instance is ambiguous because for every type <code>T</code> for witch <code>std::is_constructible&lt;std::string, T&gt;</code>, the template function <code>S::operator T()</code> is a possible conversion path from <code>S</code> to <code>T</code> to <code>std::string</code>.</p>\n<p>It seams your version of GCC starts by testing with <code>T</code> = <code>char</code>. clang list multiple candidates: <a href=\"http://coliru.stacked-crooked.com/a/17e247cca8b79c77\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/17e247cca8b79c77</a>:</p>\n<blockquote id=\"so_46608738_46608866_0\">\n<pre><code>/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../include/c++/7.2.0/bits/basic_string.h:413:7: note: candidate constructor\n      basic_string(const _Alloc&amp; __a) _GLIBCXX_NOEXCEPT\n      ^\n/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../include/c++/7.2.0/bits/basic_string.h:421:7: note: candidate constructor\n      basic_string(const basic_string&amp; __str)\n      ^\n/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../include/c++/7.2.0/bits/basic_string.h:493:7: note: candidate constructor\n      basic_string(const _CharT* __s, const _Alloc&amp; __a = _Alloc())\n      ^\n/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../include/c++/7.2.0/bits/basic_string.h:515:7: note: candidate constructor\n      basic_string(basic_string&amp;&amp; __str) noexcept\n      ^\n/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../include/c++/7.2.0/bits/basic_string.h:542:7: note: candidate constructor\n      basic_string(initializer_list&lt;_CharT&gt; __l, const _Alloc&amp; __a = _Alloc())\n</code></pre>\n</blockquote>\n<hr>\n<p>As OP found by themself, making the conversion operator of <code>S</code> <code>explicit</code> solves the ambiguity (<a href=\"http://coliru.stacked-crooked.com/a/06d31d981acd2544\" rel=\"nofollow noreferrer\">demo</a>):</p>\n<pre><code>struct S\n{\n    S(){}\n    template&lt;typename T&gt;\n    explicit operator T() { return get_type&lt;T&gt;{}(); }\n};\n</code></pre>\n<p>And this works (as user AndyG found) because under [over.match.copy] one can read:</p>\n<blockquote>\n<p id=\"so_46608738_46608866_1\">When initializing a temporary to be bound to the first parameter of a constructor where the parameter is of type \u201creference to possibly cv-qualified T\u201d and the constructor is called with a single argument in the context of direct-initialization of an object of type \u201ccv2 T\u201d, explicit conversion functions are also considered.</p>\n</blockquote>\n</hr>", "OwnerUserId": "5470596", "LastEditorUserId": "5470596", "LastEditDate": "2017-10-06T16:15:59.837", "Id": "46608866", "Score": "6", "CreationDate": "2017-10-06T15:11:57.693", "LastActivityDate": "2017-10-06T16:15:59.837"}, "bq_ids": {"n4140": {"so_46608738_46608866_1": {"section_id": 593, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_46608738_46608866_1": {"section_id": 583, "quality": 0.6923076923076923, "length": 18}}, "n4659": {"so_46608738_46608866_1": {"section_id": 616, "quality": 0.9230769230769231, "length": 24}}}, "46614150": {"ParentId": "46608738", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Here:</p>\n<pre><code>A() : s { S{} }, ...\n</code></pre>\n<p>You are initializing <code>s</code> with a braced-init-list, and <code>std::string</code> has a constructor from <code>std::initializer_list&lt;char&gt;</code>, so this is considered first. This succeeds, resulting in a call to <code>S::operator char</code>, which is ill-formed because it contains a call to a deleted function.</p>\n<p>When you add the <code>explicit</code> keyword to the conversion function, this makes the constructor from <code>initializer_list</code> non-viable, so the compiler must then consider the other constructors. Of those, the copy constructor is the only viable one, for the reason given by @YSC: explicit conversion functions are allowed when considering a copy constructor in the context of direct-initialization.</p>\n", "OwnerUserId": "1639256", "LastEditorUserId": "1639256", "LastEditDate": "2017-10-07T17:42:27.957", "Id": "46614150", "Score": "4", "CreationDate": "2017-10-06T21:27:32.260", "LastActivityDate": "2017-10-07T17:42:27.957"}});