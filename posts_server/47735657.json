post_cb({"bq_ids": {"n4140": {"so_47735657_47814885_11": {"length": 10, "quality": 1.0, "section_id": 7239}, "so_47735657_47814885_3": {"length": 7, "quality": 0.875, "section_id": 7223}, "so_47735657_47814885_1": {"length": 20, "quality": 1.0, "section_id": 6039}, "so_47735657_47814885_14": {"length": 4, "quality": 0.8, "section_id": 45}, "so_47735657_47814885_6": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_47735657_47814885_0": {"length": 17, "quality": 1.0, "section_id": 7223}, "so_47735657_47814885_13": {"length": 9, "quality": 1.0, "section_id": 7239}, "so_47735657_47814885_9": {"length": 6, "quality": 0.8571428571428571, "section_id": 7239}, "so_47735657_47814885_8": {"length": 5, "quality": 1.0, "section_id": 7239}, "so_47735657_47814885_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7185}, "so_47735657_47814885_12": {"length": 22, "quality": 1.0, "section_id": 7239}, "so_47735657_47814885_5": {"length": 20, "quality": 0.5714285714285714, "section_id": 6039}, "so_47735657_47814885_10": {"length": 8, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_47735657_47814885_11": {"length": 10, "quality": 1.0, "section_id": 6983}, "so_47735657_47814885_3": {"length": 7, "quality": 0.875, "section_id": 6967}, "so_47735657_47814885_10": {"length": 8, "quality": 1.0, "section_id": 6983}, "so_47735657_47814885_14": {"length": 4, "quality": 0.8, "section_id": 42}, "so_47735657_47814885_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6929}, "so_47735657_47814885_12": {"length": 22, "quality": 1.0, "section_id": 6983}, "so_47735657_47814885_13": {"length": 9, "quality": 1.0, "section_id": 6983}, "so_47735657_47814885_8": {"length": 5, "quality": 1.0, "section_id": 6983}, "so_47735657_47814885_9": {"length": 6, "quality": 0.8571428571428571, "section_id": 6983}, "so_47735657_47814885_0": {"length": 17, "quality": 1.0, "section_id": 6967}, "so_47735657_47814885_6": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_47735657_47814885_11": {"length": 10, "quality": 1.0, "section_id": 8748}, "so_47735657_47814885_3": {"length": 7, "quality": 0.875, "section_id": 8732}, "so_47735657_47814885_1": {"length": 16, "quality": 0.8, "section_id": 7538}, "so_47735657_47814885_14": {"length": 5, "quality": 1.0, "section_id": 7588}, "so_47735657_47814885_6": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_47735657_47814885_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 8732}, "so_47735657_47814885_13": {"length": 9, "quality": 1.0, "section_id": 8748}, "so_47735657_47814885_9": {"length": 6, "quality": 0.8571428571428571, "section_id": 8748}, "so_47735657_47814885_8": {"length": 5, "quality": 1.0, "section_id": 8748}, "so_47735657_47814885_2": {"length": 6, "quality": 1.0, "section_id": 8732}, "so_47735657_47814885_12": {"length": 22, "quality": 1.0, "section_id": 8748}, "so_47735657_47814885_5": {"length": 35, "quality": 1.0, "section_id": 7538}, "so_47735657_47814885_10": {"length": 8, "quality": 1.0, "section_id": 8748}}}, "47735657": {"ViewCount": "151", "Body": "<p>The following example comes from <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\">std::aligned_storage page</a> of cppreference.com:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;string&gt;\n\ntemplate&lt;class T, std::size_t N&gt;\nclass static_vector\n{\n    // properly aligned uninitialized storage for N T's\n    typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N];\n    std::size_t m_size = 0;\n\npublic:\n    // Create an object in aligned storage\n    template&lt;typename ...Args&gt; void emplace_back(Args&amp;&amp;... args) \n    {\n        if( m_size &gt;= N ) // possible error handling\n            throw std::bad_alloc{};\n        new(data+m_size) T(std::forward&lt;Args&gt;(args)...);\n        ++m_size;\n    }\n\n    // Access an object in aligned storage\n    const T&amp; operator[](std::size_t pos) const \n    {\n        return *reinterpret_cast&lt;const T*&gt;(data+pos);\n    }\n\n    // Delete objects from aligned storage\n    ~static_vector() \n    {\n        for(std::size_t pos = 0; pos &lt; m_size; ++pos) {\n            reinterpret_cast&lt;T*&gt;(data+pos)-&gt;~T();\n        }\n    }\n};\n\nint main()\n{\n    static_vector&lt;std::string, 10&gt; v1;\n    v1.emplace_back(5, '*');\n    v1.emplace_back(10, '*');\n    std::cout &lt;&lt; v1[0] &lt;&lt; '\\n' &lt;&lt; v1[1] &lt;&lt; '\\n';\n}\n</code></pre>\n<p>In the example, the <code>operator[]</code> just <code>reinterpret_cast</code>s <code>std::aligned_storage*</code> to <code>T*</code> without <code>std:launder</code>, and performs an indirection directly. However, according to <a href=\"https://stackoverflow.com/questions/27003727/does-this-really-break-strict-aliasing-rules\">this question</a>, this seems to be undefined, even if an object of type <code>T</code> has been ever created.</p>\n<p>So my question is: does the example program really violate strict-aliasing rules? If it does not, what's wrong with my comprehension?</p>\n", "AcceptedAnswerId": "47814885", "Title": "Does reinterpret_casting std::aligned_storage* to T* without std::launder violate strict-aliasing rules?", "CreationDate": "2017-12-10T03:44:08.357", "LastActivityDate": "2017-12-14T13:46:23.043", "CommentCount": "2", "LastEditDate": "2017-12-10T09:07:41.557", "PostTypeId": "1", "LastEditorUserId": "5376789", "Id": "47735657", "Tags": "<c++><language-lawyer><reinterpret-cast><strict-aliasing>", "Score": "1", "OwnerUserId": "5376789", "ClosedDate": "2017-12-14T14:01:22.840", "AnswerCount": "2"}, "47814885": {"Id": "47814885", "PostTypeId": "2", "Body": "<p>I asked <a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-discussion/xaAwFR6qUmY\" rel=\"nofollow noreferrer\">a related question</a> in the ISO C++ Standard - Discussion forum. I learned the answer from those discussions, and write it here to hope to help someone else who is confused about this question. I will keep updating this answer according to those discussions.</p>\n<p>Before <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html\" rel=\"nofollow noreferrer\">P0137</a>, refer to [basic.compound] paragraph 3:</p>\n<blockquote>\n<p id=\"so_47735657_47814885_0\">If an object of type T is located at an address A, a pointer of type cv T* whose value is the address A is said to point to that object, regardless of how the value was obtained.</p>\n</blockquote>\n<p>and [expr.static.cast] paragraph 13:</p>\n<blockquote>\n<p id=\"so_47735657_47814885_1\">If the original pointer value represents the address A of a byte in memory and A satisfies the alignment requirement of T, then the resulting pointer value represents the same address as the original pointer value, that is, A.</p>\n</blockquote>\n<p>The expression <code>reinterpret_cast&lt;const T*&gt;(data+pos)</code> represents the address of the previously created object of type <code>T</code>, thus points to that object. Indirection through this pointer indeed get that object, which is well-defined.</p>\n<p>However after P0137, the definition for a pointer value is changed and the first block-quoted words is deleted. Now refer to [basic.compound] paragraph 3:</p>\n<blockquote>\n<p id=\"so_47735657_47814885_2\">Every value of pointer type is one of the following:</p>\n<ul>\n<li><p id=\"so_47735657_47814885_3\">a pointer to an object or function (the pointer is said to point to the object or function), or</p></li>\n<li><p id=\"so_47735657_47814885_4\">...</p></li>\n</ul>\n</blockquote>\n<p>and [expr.static.cast] paragraph 13:</p>\n<blockquote>\n<p id=\"so_47735657_47814885_5\">If the original pointer value represents the address A of a byte in memory and A does not satisfy the alignment requirement of T, then the resulting pointer value is unspecified. Otherwise, if the original pointer value points to an object a, and there is an object b of type T (ignoring cv-qualification) that is pointer-interconvertible with a, the result is a pointer to b. <strong>Otherwise, the pointer value is unchanged by the conversion</strong>.</p>\n</blockquote>\n<p>The expression <code>reinterpret_cast&lt;const T*&gt;(data+pos)</code> still points to the object of type <code>std::aligned_storage&lt;...&gt;::type</code>, and indirection get a lvalue referring to that object, though the type of the lvalue is <code>const T</code>. Evaluation of the expression <code>v1[0]</code> in the example tries to access the value of the <code>std::aligned_storage&lt;...&gt;::type</code> object through the lvalue, which is undefined behavior according to [basic.lval] paragraph 11 (i.e. the strict-aliasing rules):</p>\n<blockquote>\n<p id=\"so_47735657_47814885_6\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li><p id=\"so_47735657_47814885_7\">the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_8\">a cv-qualified version of the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_9\">a type similar (as defined in [conv.qual]) to the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_10\">a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_11\">a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_12\">an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</p></li>\n<li><p id=\"so_47735657_47814885_13\">a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</p></li>\n<li><p id=\"so_47735657_47814885_14\">a char, unsigned char, or std\u200b::\u200bbyte type.</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2017-12-14T13:46:23.043", "Score": "1", "CreationDate": "2017-12-14T13:46:23.043", "ParentId": "47735657", "CommentCount": "0", "OwnerUserId": "5376789"}, "47737450": {"Id": "47737450", "PostTypeId": "2", "Body": "<p>The code doesn't violate the strict aliasing rule in any way. An lvalue of type <code>const T</code> is used to access an object of type <code>T</code>, which is permitted.</p>\n<p>The rule in question, as covered by the linked question, is a lifetime rule; C++14 (N4140)  [basic.life]/7.  The problem is that, according to this rule, the pointer <code>data+pos</code> may not be used to manipulate the object created by placement-new. You're supposed to use the value \"returned\" by placement-new.</p>\n<p>The question naturally follows: what about the pointer <code>reinterpret_cast&lt;T *&gt;(data+pos)</code> ? It is unclear whether accessing the new object via this new pointer violates [basic.life]/7. </p>\n<p>The author of the answer you link to, assumes (with no justification offered) that this new pointer is still \"a pointer that pointed to the original object\". However it seems to me that it is also possible to argue that , being a <code>T *</code>, it cannot point to the original object, which is a <code>std::aligned_storage</code> and not a <code>T</code>. </p>\n<p>This shows that the object model is underspecified. The proposal <a href=\"http://wg21.link/p0137\" rel=\"nofollow noreferrer\">P0137</a>, which was incorporated into C++17, was addressing a problem in a different part of the object model. But it introduced <code>std::launder</code> which is a sort of <em>mjolnir</em> to squash a wide range of aliasing, lifetime and provenance issues.</p>\n<p>Undoubtedly the version with <code>std::launder</code> is correct in C++17. However, as far as I can see, P0137 and C++17 don't have any more to say about whether or not the version without <code>launder</code> is correct. </p>\n<p>IMHO it is impractical to call the code UB in C++14, which did not have <code>std::launder</code>, because there is no way around the problem other than to waste memory storing all the result pointers of placement-new. If this is UB then it's impossible to implement <code>std::vector</code> in C++14, which is far from ideal.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-12-10T10:01:26.590", "Score": "0", "CreationDate": "2017-12-10T09:20:50.397", "ParentId": "47735657", "CommentCount": "3", "OwnerUserId": "1505939", "LastEditDate": "2017-12-10T10:01:26.590"}});