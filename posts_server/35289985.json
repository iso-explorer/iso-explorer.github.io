post_cb({"35290707": {"Id": "35290707", "PostTypeId": "2", "Body": "<p>It is required because in C doesn't exist the concept of multidimensional array.<br>\nWe can define an array of anything, even another array. The last could be seen as a multidimensional array.<br>\nNow consider a bidimensional array as:</br></br></p>\n<pre><code>int arrray[5][4];\n</code></pre>\n<p>This is to be interpreted as an array of 5 elements, each one being an array of 4 <code>int</code>.<br>\nIn memory the layout is sequential: first the 4 elements of the first array, then the second and so on up to the 5th array of 4 elements.<br>\nTo access the 2nd element of 3rd array <code>array[2][1]</code> the compiler have to skip the first 2 arrays, <strong>but to do so needs to know how many elements to skip</strong>.<br>\nI.e. mathematically the address of the 2nd element of the 3rd array is:</br></br></br></p>\n<pre><code>//pElement2Array3  points the 2nd element of the 3rd array.\n//Note that 4 is the number of elements of the base dimension\nint *pElement2Array3 = &amp;array[0] + (2 * 4) + 1;\n</code></pre>\n<p>(Note: the term <code>(2 * 4) + 1</code> is not multiplied by the <code>sizeof(int)</code> because this is done automatically by pointer arithmetic.)<br>\nThe math above is automatically performed by the compiler when using the addressing <code>array[2][1]</code>, <strong>but to execute it the compiler have to know how many elements are in the base array (that could be ana array of array of array...)</strong>.</br></p>\n", "LastActivityDate": "2016-02-09T11:20:05.283", "CommentCount": "2", "CreationDate": "2016-02-09T11:20:05.283", "ParentId": "35289985", "Score": "0", "OwnerUserId": "5157478"}, "35289985": {"ViewCount": "189", "Body": "<p>As per the post,</p>\n<p><a href=\"https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function?rq=1\">Passing a 2D array to a C++ function</a></p>\n<pre><code>int array[10][10];\nvoid passFunc(int a[][10]) //  &lt;---Notice 10 here\n{\n    // ...\n}\npassFunc(array);\n</code></pre>\n<p>Why is this higher dimension required from compilers internal point of view.</p>\n", "Title": "Why is dimension range of higher dimensions in multi-dimensional array required?", "CreationDate": "2016-02-09T10:46:00.747", "LastActivityDate": "2017-07-29T08:43:44.340", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-29T08:43:44.340", "LastEditorUserId": "1033581", "Id": "35289985", "Score": "5", "OwnerUserId": "4021785", "Tags": "<c++><c>", "AnswerCount": "6"}, "35290113": {"Id": "35290113", "PostTypeId": "2", "Body": "<p>Arrays in C/C++ are a type, but not a first-class object and they \"decay\" into a pointer to the first element when passed to functions.</p>\n<p>An <code>int[10][10]</code> is an array of 10 <code>int[10]</code> arrays... the function declarations:</p>\n<pre><code>void foo(int x[][10]);\n\ntypedef int IntArray10[10];\nvoid bar(IntArray10 *x);\n</code></pre>\n<p>are for the compiler identical.</p>\n<p>When passing a 2d array to a function therefore you're passing a pointer to the first element (and the first dimension is ignored) but the element itself is an array and the compiler needs to know its size.</p>\n", "LastActivityDate": "2016-02-09T10:51:19.077", "CommentCount": "4", "CreationDate": "2016-02-09T10:51:19.077", "ParentId": "35289985", "Score": "3", "OwnerUserId": "320726"}, "35290717": {"Id": "35290717", "PostTypeId": "2", "Body": "<p>Contrary to what you might think from the \"[]\" in the parameter <code>int a[][10]</code>, the function doesn't take a two-dimensional array but a pointer to a one-dimensional array - its prototype is equivalent to </p>\n<pre><code>void passFunc(int (*a)[10])\n</code></pre>\n<p><code>array</code> can decay into a pointer to its first element, like all arrays.<br>\nThat pointer is, as usual, <code>&amp;array[0]</code>, and in this case it is a pointer to an array with ten <code>int</code>s - an <code>int (*)[10]</code>.</br></p>\n<p>So it's not that you need to specify the \"higher dimension\", it's that the parameter is a pointer to an array of ten elements and not a two-dimensional array at all.  </p>\n<p>(You can't have <code>a</code> be a pointer to an array of unspecified size because the compiler needs to know where <code>a[1]</code> is located in relation to <code>a[0]</code>, i.e. it needs to know <code>sizeof(*a)</code>.)</p>\n", "LastActivityDate": "2016-02-09T11:20:32.823", "CommentCount": "0", "CreationDate": "2016-02-09T11:20:32.823", "ParentId": "35289985", "Score": "3", "OwnerUserId": "404970"}, "bq_ids": {"n4140": {"so_35289985_35291820_0": {"length": 5, "quality": 0.625, "section_id": 300}}, "n3337": {"so_35289985_35291820_0": {"length": 5, "quality": 0.625, "section_id": 291}}, "n4659": {"so_35289985_35291820_0": {"length": 6, "quality": 0.75, "section_id": 3997}}}, "35290096": {"Id": "35290096", "PostTypeId": "2", "Body": "<p>As a function parameter <code>int a[][10]</code> is equivalent to <code>int (*a)[10]</code>, means : <em><code>a</code> is a pointer to an array of 10 <code>int</code></em>. It doesn't represent a 2D array in this case.  </p>\n<p>If the higher dimension left blank then it is not possible for the compiler to know the length of array the pointer <code>a</code> is pointing to and pointer arithmetic can't be performed.  </p>\n", "LastEditorUserId": "2455888", "LastActivityDate": "2016-02-09T11:06:48.300", "Score": "-1", "CreationDate": "2016-02-09T10:50:35.970", "ParentId": "35289985", "CommentCount": "1", "OwnerUserId": "2455888", "LastEditDate": "2016-02-09T11:06:48.300"}, "35290170": {"Id": "35290170", "PostTypeId": "2", "Body": "<p>An alternative explanation (to array-to-pointer decay):</p>\n<p>Let's say we have a one-dimensional array, and we use it like this:</p>\n<pre><code>int array[10];\nint i = array[3];\n</code></pre>\n<p>The compiler has to know where to find <code>array[3]</code>. It knows it needs to skip 3 <code>int</code>s before it can get to the one in <code>array[3]</code>. So it works.</p>\n<p>But if we have a two-dimensional array,</p>\n<pre><code>int array[2][5];\nint i = array[1][1];\n</code></pre>\n<p>To get <code>i</code> here, how many <code>int</code>s does the compiler need to skip? It needs to skip an entire row, plus one. To skip one is easy, since we know the size of one <code>int</code>. But we also need to know the size of the row in the array\u2014and the size of the row is determined by the size of the type * number of columns per row. This is one way of looking at it, which explains why you need the latter dimension.</p>\n<p>Let's make this a small brain teaser by taking it one dimension further, to</p>\n<pre><code>int array[2][2][2];\nint i = array[1][1][1];\n</code></pre>\n<p>and let's call the dimensions <em>X, Y, Z</em>.</p>\n<p>Here, we can say we have a finite 3D space of <code>int</code>s. The unit is of course the size of one <code>int</code>. The number of rows is defined by <em>Y</em>, the number of planes is defined by <em>Z</em>. That leaves <em>X</em> as the basic unit, which is the size of one <code>int</code>, as we said. The combination of the three yields a \"point.\"</p>\n<p>To be able to get to any point in that 3D space, we need to know where each dimension \"stops\" and the next one begins. So we need:</p>\n<ol>\n<li>The size of the unit (<code>int</code>), to traverse the <em>X</em> dimension</li>\n<li>The size of each plane (<em>Y</em>), to traverse the <em>Y</em> dimension</li>\n<li>The number of planes, to traverse the <em>Z</em> dimension</li>\n</ol>\n<p>So again, <em>X</em> is already given to us, because we're using <code>int</code>. But we don't know the size of each plane, nor do we know how many planes there are. So we need to specify all but the first dimension. And that's the general rule.</p>\n<p>This also explains why this issue invites a bit more elaborate explanation than mere pointer decay, because once you get to more than 2 dimensions, you still need to know how this works.\nIn other words, you need the overall size (product of dimensions) to not overflow, and you need the dimension of <em>each</em> size to be able to use successive <code>[]</code> indices.</p>\n", "LastEditorUserId": "602372", "LastActivityDate": "2016-02-09T13:27:15.373", "Score": "4", "CreationDate": "2016-02-09T10:54:14.570", "ParentId": "35289985", "CommentCount": "11", "OwnerUserId": "602372", "LastEditDate": "2016-02-09T13:27:15.373"}, "35291820": {"Id": "35291820", "PostTypeId": "2", "Body": "<p>Simply put, because multi-dimensional arrays \"grow\" from right to left. Think of it like this:</p>\n<p><code>int arr [a];</code> is an array of <code>a</code> integers.</p>\n<p><code>int arr [b][a]</code> is an array of <code>b</code> arrays of <code>a</code> integers.</p>\n<p>And so on.</p>\n<p>As for why you can omit the left-most dimension when passing an array to a function, it is because of \"array decay\". 6.7.6.3/7 says:</p>\n<blockquote>\n<p id=\"so_35289985_35291820_0\">A declaration of a parameter as \u2018\u2018array of type\u2019\u2019 shall be adjusted to\n  \u2018\u2018qualified pointer to type\u2019\u2019</p>\n</blockquote>\n<p>That is, if you declare a function parameter as <code>int param[10]</code> or <code>int param[]</code>, it gets silently/invisibly replaced by the compiler with a pointer to int: <code>int* param</code>, which points at the first element of the array. The array itself remains allocated by the caller.</p>\n<p>It works like this to prevent arrays from getting passed to functions by value, which would be very ineffective and in most cases doesn't make any sense.</p>\n<p>Now for the case of multi-dimensional arrays, the same rule above applies. So if you have <code>int param[10][10]</code> it decays into a pointer to the first element. The first element is an array of 10 integers, so you get <em>an array pointer</em> to an array of 10 integers: <code>int (*param)[10]</code>.</p>\n<p>The very same would happen if you have <code>int param[][10]</code>, you would still get a <code>int (*param)[10]</code>. So the left-most dimension could be anything - it doesn't matter since it is ignored anyhow.</p>\n<p>But the other dimensions following the left-most are required, or otherwise the compiler wouldn't know which pointer type that the array would decay into. Outside the special case of function declarations, there is no such thing as <code>int(*param)[]</code> which would mean \"an array pointer to an array of unknown size\".</p>\n", "LastActivityDate": "2016-02-09T12:14:48.700", "CommentCount": "0", "CreationDate": "2016-02-09T12:14:48.700", "ParentId": "35289985", "Score": "0", "OwnerUserId": "584518"}});