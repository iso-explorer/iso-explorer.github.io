post_cb({"41210157": {"ParentId": "607259", "CommentCount": "0", "Body": "<p>There is another solution, you can create a shared parent class and put this static variable in it, then make your template class inherit it privately, here's an example:</p>\n<pre><code>class Parent\n{\nprotected: \n    static long count;\n};\n\nlong Parent::count = 0;\n\ntemplate&lt;typename T&gt;\nclass TemplateClass: private Parent\n{\nprivate: \n    int mKey;\npublic:\n    TemplateClass():mKey(count++){}\n    long getKey(){return mKey;}\n}\n\nint main()\n{\n    TemplateClass&lt;int&gt; obj1;\n    TemplateClass&lt;double&gt; obj2;\n\n    std::cout&lt;&lt;\"Object 1 key is: \"&lt;&lt;obj1.getKey()&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"Object 2 key is: \"&lt;&lt;obj2.getKey()&lt;&lt;std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Output will be:</p>\n<pre><code>Object 1 key is: 0 \nObject 2 key is: 1\n</code></pre>\n", "OwnerUserId": "3941213", "PostTypeId": "2", "Id": "41210157", "Score": "0", "CreationDate": "2016-12-18T15:58:57.373", "LastActivityDate": "2016-12-18T15:58:57.373"}, "607259": {"CommentCount": "0", "AcceptedAnswerId": "607335", "PostTypeId": "1", "LastEditorUserId": "7734", "LastEditorDisplayName": "EvilTeach", "CreationDate": "2009-03-03T17:08:19.430", "LastActivityDate": "2016-12-18T15:58:57.373", "AnswerCount": "5", "LastEditDate": "2009-03-03T17:15:25.483", "ViewCount": "18626", "FavoriteCount": "9", "Title": "Using static variable along with templates", "Id": "607259", "Score": "17", "Body": "<p>I have a template class defined in a header file like this. Here I have defined a static variable as well:</p>\n<pre><code>#ifndef TEST1_H_\n#define TEST1_H_\n\nvoid f1();\n\nstatic int count;\n\ntemplate &lt;class T&gt;\nclass MyClass\n{\npublic:\n\n    void f()\n    {\n        ++count;\n    }\n\n\n};\n\n#endif\n</code></pre>\n<p>And I have defined main() function in a different cpp file like this:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    MyClass&lt;int&gt; a;\n    a.f();\n    f1();\n\n    cout&lt;&lt;\"Main:\" &lt;&lt; count &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>I have implemented function f1() in a different cpp file like this:</p>\n<pre><code>void f1()\n{\n    MyClass&lt;int&gt; a;\n    a.f();\n\n    cout&lt;&lt;\"F1: \" &lt;&lt;count &lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>When I compiled this using VC6, I got the output as \"F1:0 Main:2\". How is this possible? Also, in general how should I handle if I want to use static variables along with templates?</p>\n", "Tags": "<c++><templates><static><vc6>", "OwnerUserId": "39742", "OwnerDisplayName": "Naveen"}, "33733088": {"ParentId": "607259", "CommentCount": "1", "Body": "<p>I think this is actually <em>undefined behaviour</em>.</p>\n<p>According to C++14 [basic.def.odr]/6:</p>\n<blockquote>\n<p id=\"so_607259_33733088_0\">There can be more than one definition of a [...] member function of a class template [...]  in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named <code>D</code> defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after matching of partial template specialization (14.8.3), except that a name can refer to a non-volatile\n  const object with internal or no linkage if the object has the same literal type in all definitions of D, and the object is initialized with a constant expression (5.19), and the object is not odr-used, and the object has the same value in all definitions of D; [...]</li>\n</ul>\n</blockquote>\n<p>The problem is that in the first <code>.cpp</code> file, the name <code>count</code> within <code>f1</code> refers to a different object than the name <code>count</code> within <code>f1</code> in the second <code>.cpp</code> file, thus violating the condition that corresponding names should refer to the same entity.</p>\n<p>They are different objects because of the <code>static</code> specifier which says that each translation unit gets its own object with that name.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "33733088", "Score": "-1", "CreationDate": "2015-11-16T10:26:46.770", "LastActivityDate": "2015-11-16T10:26:46.770"}, "607273": {"ParentId": "607259", "CommentCount": "2", "Body": "<p>Putting the static declaration in a header file will cause each .cpp file to get its own version of the variable.  So the two cout statements are printing different variables.</p>\n", "OwnerUserId": "34502", "Id": "607273", "PostTypeId": "2", "OwnerDisplayName": "David Norman", "Score": "3", "CreationDate": "2009-03-03T17:11:27.677", "LastActivityDate": "2009-03-03T17:11:27.677"}, "609513": {"ParentId": "607259", "CommentCount": "1", "Body": "<p>Were you expecting \"F1:1 Main:1\"? You instantiated <code>MyClass&lt;int&gt;</code> in two separate translation units (i.e. two object files), and the linker saw that there was a duplicate template instantiation, so it discarded the instantiation that was in <code>f1</code>'s object file.</p>\n<p>Are you passing <a href=\"http://msdn.microsoft.com/en-us/library/aa278533(VS.60).aspx\" rel=\"nofollow noreferrer\"><code>/OPT:ICF</code> or <code>/OPT:REF</code></a> to the VC6 linker? That might be related to the duplicate template instantiation removal (or not; duplicate template instantiations might be a special case, compared to ordinary duplicate functions). GCC seems to do <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Template-Instantiation.html\" rel=\"nofollow noreferrer\">something similar</a> on some platforms. </p>\n<p>Anyway, I wouldn't rely on this behavior being consistent across compilers. Also, changing the order of object files on the linker command line might affect which instantiation gets discarded.</p>\n", "OwnerUserId": "8090", "Id": "609513", "PostTypeId": "2", "OwnerDisplayName": "bk1e", "Score": "1", "CreationDate": "2009-03-04T07:07:30.380", "LastActivityDate": "2009-03-04T07:07:30.380"}, "607335": {"CommentCount": "3", "CreationDate": "2009-03-03T17:28:10.553", "LastEditorUserId": "111307", "LastActivityDate": "2013-07-07T19:31:29.017", "ParentId": "607259", "PostTypeId": "2", "LastEditorDisplayName": "tgamblin", "LastEditDate": "2013-07-07T19:31:29.017", "Id": "607335", "Score": "21", "Body": "<p>You're getting two copies of the same variable because you've declared a static variable in a header file.  When you declare a global variable <code>static</code> this way, you're saying it's local to the compilation unit (the <code>.o</code> file).  Since you include the header in two compilation units, you get two copies of <code>count</code>.</p>\n<p>I think what you really want here is a static template member variable associated with each <em>instance</em> of the template class.  It would look like this:</p>\n<pre><code>template &lt;class T&gt;\nclass MyClass\n{\n    // static member declaration\n    static int count;\n    ...\n};\n\n// static member definition\ntemplate&lt;class T&gt; int MyClass&lt;T&gt;::count = 0;\n</code></pre>\n<p>This will get you a count for each instantiation of your template.  That is, you'll have a count for <code>MyClass&lt;int&gt;</code>, <code>MyClass&lt;foo&gt;</code>, <code>MyClass&lt;bar&gt;</code>, etc.  <code>f1()</code> would now look like this:</p>\n<pre><code>void f1() {\n    MyClass&lt;int&gt; a;\n    a.f();\n\n    cout&lt;&lt;\"F1: \" &lt;&lt; MyClass&lt;int&gt;::count &lt;&lt;\"\\n\";\n}\n</code></pre>\n<hr>\n<p>If you want a count for <strong>all</strong> instantiations of MyClass (regardless of their template parameters), you do need to use a <strong>global variable</strong>.</p>\n<p>However, you probably don't want a global variable directly because you run the risk of using it before it gets initialized.  You can get around this by making a global static method that returns a reference to your count:</p>\n<pre><code>int&amp; my_count() {\n    static int count = 0;\n    return count;\n}\n</code></pre>\n<p>Then accessing it from within your class like this:</p>\n<pre><code>void f() {\n    ++my_count();\n}\n</code></pre>\n<p>This will ensure that count gets initialized before it's used, regardless of which compilation unit you access it from.  See the <a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12\" rel=\"noreferrer\">C++ FAQ on static initialization order</a> for more details.</p>\n</hr>", "OwnerUserId": "9122", "OwnerDisplayName": "tgamblin"}, "bq_ids": {"n4140": {"so_607259_33733088_0": {"section_id": 7043, "quality": 1.0, "length": 33}}, "n3337": {"so_607259_33733088_0": {"section_id": 6788, "quality": 1.0, "length": 33}}, "n4659": {"so_607259_33733088_0": {"section_id": 8540, "quality": 1.0, "length": 33}}}});