post_cb({"bq_ids": {"n4140": {"so_7776448_7776448_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 102}, "so_7776448_7776468_0": {"length": 16, "quality": 1.0, "section_id": 142}}, "n3337": {"so_7776448_7776448_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 97}, "so_7776448_7776468_0": {"length": 16, "quality": 1.0, "section_id": 136}}, "n4659": {"so_7776448_7776448_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 106}}}, "7776468": {"Id": "7776468", "PostTypeId": "2", "Body": "<p>Actually what you're doing is forbidden by section \u00a714.5.4/9 which says,</p>\n<blockquote>\n<p id=\"so_7776448_7776468_0\">A partially specialized <strong>non-type argument expression shall not involve a template parameter of the partial specialization</strong> except when the argument expression is a simple identifier. </p>\n</blockquote>\n<p>The trick could be using a <em>type</em> for second template parameter as well, encapsulating the <em>non-type</em> value, as described below:</p>\n<pre><code>template&lt;bool b&gt; struct booltype {};\n\ntemplate&lt;typename T, typename B = booltype&lt;true&gt; &gt;\nstruct Resolve\n{\n  static const bool value = false;\n};\n\ntemplate&lt;typename T&gt;\nstruct Resolve&lt;T, booltype&lt;T::my_value&gt; &gt;\n{\n  static const bool value = true;\n};\n</code></pre>\n<p>Now it <a href=\"http://ideone.com/4r6My\">compile fines</a>.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-10-15T07:58:45.603", "Score": "19", "CreationDate": "2011-10-15T07:34:21.333", "ParentId": "7776448", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-10-15T07:58:45.603"}, "7776448": {"ViewCount": "1801", "Body": "<p>I tried to implement an SFINAE using <code>bool</code> (unlike popular <code>void_</code> <a href=\"https://stackoverflow.com/questions/7709703/type-not-inherited-in-sfinae-for-multiple-inheritance\">trick</a>):</p>\n<pre><code>  template&lt;typename T, bool = true&gt;\n  struct Resolve\n  {\n    static const bool value = false;\n  };\n\n  template&lt;typename T&gt;\n  struct Resolve&lt;T, T::my_value&gt;\n  {\n    static const bool value = true;\n  };\n</code></pre>\n<p>The goal is to specialize, the classes which have <code>static const bool my_value = true;</code> defined inside it. If they are defined <code>false</code> or not defined then don't specialize it. i.e.</p>\n<pre><code>struct B1 {  // specialize Resolve for this case\n  static const bool my_value = true;\n};\nstruct B2 {  // don't specialize\n  static const bool my_value = false;\n};\nstruct B3 {};  // don't specialize\n</code></pre>\n<p>When applying the above trick on <code>B1</code> it gives the compilation error:</p>\n<pre><code>Resolve&lt;B1&gt;::value;\n</code></pre>\n<blockquote>\n<p id=\"so_7776448_7776448_0\">error: template argument \u2018T::my_value\u2019 involves template parameter(s)</p>\n</blockquote>\n<p>I am aware that this can be achieved with alternate ways. However, I am interested in knowing, why it gives compiler error here and can it be solved in this code itself ?</p>\n", "AcceptedAnswerId": "7776468", "Title": "SFINAE tried with bool gives compiler error: \"template argument \u2018T::value\u2019 involves template parameter\"", "CreationDate": "2011-10-15T07:28:27.860", "Id": "7776448", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:19.257", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-15T07:58:45.603", "ClosedDate": "2016-03-21T09:50:42.560", "Score": "9", "OwnerUserId": "514235", "Tags": "<c++><templates><compiler-errors><sfinae>", "AnswerCount": "1"}});