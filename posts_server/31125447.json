post_cb({"bq_ids": {"n4140": {"so_31125447_31125846_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6027}, "so_31125447_31125846_1": {"length": 21, "quality": 1.0, "section_id": 5997}}, "n3337": {"so_31125447_31125846_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5795}, "so_31125447_31125846_1": {"length": 21, "quality": 1.0, "section_id": 5765}}, "n4659": {"so_31125447_31125846_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7526}, "so_31125447_31125846_1": {"length": 21, "quality": 1.0, "section_id": 7498}}}, "31125447": {"ViewCount": "410", "Body": "<p>I'm struggling to understand what exactly happens when passing a reference-to-function to a function as a universal reference (what type is being deduced). Let's suppose we have a function foo that takes a param as a universal reference:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp;&amp; param)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And then let's do the following:</p>\n<pre><code>void(&amp;f)(int) = someFunction;\nfoo(f);\n</code></pre>\n<p>The result will be:</p>\n<p><strong><code>void foo(T&amp;&amp;) [with T = void (&amp;)int]</code></strong></p>\n<p>This is perfectly understandable: we are passing lvalue to our function foo, so the deduced type is void(&amp;)int, and the type of the param will be \"void(&amp;&amp; &amp;)int\" which under reference collapsing rules becomes void(&amp;)int. Param will be just an lvalue reference to a function.</p>\n<p>But when I do the following:</p>\n<pre><code>void(&amp;f)(int) = someFunction;\nfoo(std::move(f));\n</code></pre>\n<p>foo will print:</p>\n<p><strong><code>void foo(T&amp;&amp;) [with T = void (&amp;)int]</code></strong></p>\n<p>which is exactly the same as before! What is happening here? Why the result is the same as when passing lvalue? I would expect that since we are passing rvalue to foo, the deduced type should be T = void(int), and param should become void(&amp;&amp;)int. This always happen with all other \"normal\" types (like classes, primitive types, etc.) Why is it different when dealing with function references?</p>\n", "Title": "Passing a reference-to-function as a universal reference", "CreationDate": "2015-06-29T20:58:35.827", "LastActivityDate": "2015-06-29T21:44:10.393", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-06-29T21:02:34.453", "LastEditorUserId": "1413395", "Id": "31125447", "Score": "5", "OwnerUserId": "1601719", "Tags": "<c++><c++11><universal-reference>", "AnswerCount": "1"}, "31125846": {"Id": "31125846", "PostTypeId": "2", "Body": "<p>A <code>std::move</code> is a glorified <code>static_cast</code> to rvalue reference type. The standard says that casting to an rvalue reference to function type still yields an lvalue. Per [expr.static.cast]/p1:</p>\n<blockquote>\n<p id=\"so_31125447_31125846_0\">The result of the expression <code>static_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type <code>T</code>. <strong>If <code>T</code> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue;</strong></p>\n</blockquote>\n<p>Concerning the value category of the <code>std::move()</code> function call, which returns an rvalue reference designating the result of the conversion, we can also see from [expr.call]/p10 that a function call is an lvalue if its return type is an rvalue reference to function type:</p>\n<blockquote>\n<p id=\"so_31125447_31125846_1\"><strong>A function call is an lvalue if the result type is</strong> an lvalue reference type or <strong>an rvalue reference to function type</strong>, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n", "LastEditorUserId": "701092", "LastActivityDate": "2015-06-29T21:44:10.393", "Score": "6", "CreationDate": "2015-06-29T21:25:17.960", "ParentId": "31125447", "CommentCount": "2", "OwnerUserId": "701092", "LastEditDate": "2015-06-29T21:44:10.393"}});