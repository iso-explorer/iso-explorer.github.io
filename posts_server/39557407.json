post_cb({"39557407": {"CommentCount": "4", "ViewCount": "119", "CreationDate": "2016-09-18T11:57:14.580", "LastActivityDate": "2016-09-19T00:58:05.310", "Title": "Thread local variable accessed through non-thread local object", "AcceptedAnswerId": "39557478", "PostTypeId": "1", "Id": "39557407", "Score": "1", "Body": "<p>Let's start with a piece of <a href=\"http://coliru.stacked-crooked.com/a/66f46bf42c34a887\" rel=\"nofollow\">code (Coliru)</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nstruct A\n{\n    thread_local static A* p_a;\n    thread_local static int i;\n};\n\nthread_local int A::i;\nthread_local A* A::p_a;\n\nint main( )\n{\n    A::p_a = new A;\n\n    auto lambda = [](A* a)\n        {\n          a-&gt;i = 1; // Prints 1 (below, of course)\n          std::cout &lt;&lt; a-&gt;i &lt;&lt; std::endl;\n        };\n\n    std::thread t(std::bind(lambda, A::p_a));\n    t.join();\n\n    // Prints 0 (it hasn't been modified)\n    std::cout &lt;&lt; A::p_a-&gt;i &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>As all of you can see, the second thread modifies its thread local copy of <code>A::i</code>, even though I accessed it from another thread local object of another thread. Is it the expected behaviour? Because it makes impossible to get info from another thread using a \"referer\" unless I pass a pointer or reference to the foreign's thread_local object which I want to read.</p>\n<p>With \"referer\" I refer something which manages or can give you access to its own thread_local variable from its thread. But that's impossible!! Any expression yielding a thread_local variable, no matter from whom (I have done different test, even with accessor functions), ends by using the thread_local instance of the reading thread.</p>\n", "Tags": "<c++><multithreading><c++11><thread-local>", "OwnerUserId": "1794803", "AnswerCount": "2"}, "39557478": {"ParentId": "39557407", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is a syntax issue: In this case <code>a-&gt;i;</code> is <strong><em>identical</em></strong> to <code>A::i;</code> because <code>A::i</code> is a <em>static member</em> and its address is not dependant on any one instance of <code>A</code>.</p>\n<p>So just because you are using syntax that looks like you are dereferencing an <code>A</code> pointer, you're not. The compiler sees it is a <em>static member</em> and ignores the pointer and goes straight for the single (per thread in this case) <code>static</code> instance. The whole <code>thread_local</code> business is actually irrelevant to that.</p>\n<p>So when you are accessing a <em>static member</em> of <code>A</code> through <code>A* a</code> in your <em>lambda</em>, the compiler is ignoring the <em>address</em> you gave it and doing <code>A::i</code> regardless (getting its own <code>thread_local</code> version).</p>\n<pre><code>struct A\n{\n    static int i;\n};\n\nA* a = new A;\na-&gt;i; // identical to A::i (because i is static)\n</code></pre>\n<p>This is standard syntax as mentioned here in the <strong>C++14 Standard</strong>:</p>\n<blockquote>\n<p id=\"so_39557407_39557478_0\"><strong>5.2.5</strong> Class member access <strong>[</strong> expr.ref <strong>]</strong></p>\n<p id=\"so_39557407_39557478_1\"><strong>1.</strong> A postfix expression followed by a dot . or an arrow -&gt;, optionally followed by the keyword template (14.2),\n  and then followed by an id-expression, is a postfix expression. The postfix expression before the dot or arrow\n  is evaluated; <sup><strong>65</strong></sup> the result of that evaluation, together with the id-expression, determines the result of the\n  entire postfix expression.</p>\n<p id=\"so_39557407_39557478_2\">...</p>\n<p id=\"so_39557407_39557478_3\"><sup><strong>65)</strong></sup> If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary\n  to determine the value of the entire postfix expression, for example <strong><em>if the id-expression denotes a static member</em></strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "OwnerUserId": "3807729", "LastEditorUserId": "3807729", "LastEditDate": "2016-09-18T14:16:09.540", "Id": "39557478", "Score": "6", "CreationDate": "2016-09-18T12:07:13.610", "LastActivityDate": "2016-09-18T14:16:09.540"}, "39564029": {"ParentId": "39557407", "CommentCount": "0", "Body": "<p>you passed one 'A' porinter, but we should know that 'i' variable and 'p_a' variable are not belong 'A' actually, then are static, so although you started a thread passed by a 'A' pointer,then modified 'i' variable, it is different ,because this 'i' is not outside 'i',they are different.</p>\n", "OwnerUserId": "6845242", "PostTypeId": "2", "Id": "39564029", "Score": "0", "CreationDate": "2016-09-19T00:58:05.310", "LastActivityDate": "2016-09-19T00:58:05.310"}, "bq_ids": {"n4140": {"so_39557407_39557478_3": {"section_id": 6004, "quality": 1.0, "length": 21}, "so_39557407_39557478_1": {"section_id": 6004, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_39557407_39557478_3": {"section_id": 5772, "quality": 1.0, "length": 21}, "so_39557407_39557478_1": {"section_id": 5772, "quality": 0.9354838709677419, "length": 29}}, "n4659": {"so_39557407_39557478_1": {"section_id": 7503, "quality": 0.9354838709677419, "length": 29}, "so_39557407_39557478_3": {"section_id": 7503, "quality": 1.0, "length": 21}}}});