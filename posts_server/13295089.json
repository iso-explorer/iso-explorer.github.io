post_cb({"13295227": {"ParentId": "13295089", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The keyword <code>constexpr</code> in the function definition tells the compiler that this function <em>may</em> be executed at compile-time if the all the arguments and variables are known at the compile-time itself. There is no such guarantee, though, for example when some of the values can be known <em>only</em> at runtime in which case the function will be executed at runtime.</p>\n<p>However, it has nothing to do with <em>pure</em> or <em>impure</em>, since these terms imply that the output depends on the inputs only, and no matter how many times you call the function with the same values of input parameters, the output will be same everytime, irrespective of whether it is computed at compile-time or runtime. </p>\n<p>Example,</p>\n<pre><code>constexpr int add(int a, int b) { return a + b; } //pure!\n\nconst int a = 2, b = 3; //const\nint c = 2, d = 3;       //non-const\n\n//we may read update c and d here!\n\nconst int v1 = add(2,3);  //computed at compile-time\nconst int v2 = add(a,3);  //computed at compile-time\nconst int v3 = add(2,b);  //computed at compile-time\nconst int v4 = add(a,b);  //computed at compile-time\n\nconst int v3 = add(c,3);  //computed at runtime\nconst int v3 = add(c,b);  //computed at runtime\nconst int v3 = add(a,d);  //computed at runtime\nconst int v3 = add(c,d);  //computed at runtime\n</code></pre>\n<p>Note that here <code>add</code> is a pure function irrespective of whether it is computed at compile-time or runtime.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2012-11-08T18:44:24.503", "Id": "13295227", "Score": "7", "CreationDate": "2012-11-08T18:18:08.960", "LastActivityDate": "2012-11-08T18:44:24.503"}, "14472252": {"ParentId": "13295089", "CommentCount": "2", "Body": "<p>In the standard, the relevant requirement is buried below the main list of requirements for <code>constexpr</code> functions. It's in \u00a77.1.5/5:</p>\n<blockquote>\n<p id=\"so_13295089_14472252_0\">For a constexpr function, if no function argument values exist such that the function invocation substitution would produce a constant expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>\u00a75.19 defines the requirements for constant expressions, such that you can't call <code>rand()</code>.</p>\n<p>The relaxed restriction allows you to have functions that are conditionally pure. Your example <code>f(true)</code> is a valid template argument, but <code>f(false)</code> is not.</p>\n<p>The downside, of course, is that the compiler won't verify that a <code>constexpr</code> function can actually be used for its intended purpose. You need to write test cases.</p>\n<p>Ah, litb's answer is also correct. (But this one is worded more simply.)</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "14472252", "Score": "9", "CreationDate": "2013-01-23T04:03:13.593", "LastActivityDate": "2013-01-23T04:03:13.593"}, "13295089": {"CommentCount": "2", "ViewCount": "527", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-11-08T18:08:29.877", "LastActivityDate": "2013-01-23T04:03:13.593", "Title": "Why constexpr works for impure functions", "LastEditDate": "2017-05-23T12:24:56.423", "Id": "13295089", "Score": "11", "Body": "<p>while browsing one of my old questions on constexpr I stumbled onto a very(IMHO) important comment. \nBasically it boils down to :\n(this is legal C++11 :( )</p>\n<pre><code> constexpr double f(bool b)\n {\n return b? 42:42/(rand()+1); // how pure is rand ;)\n }\n</code></pre>\n<p>My question is what is the reason this is allowed by the standard. Since Im a big fan of referential transparency I hope they have a good reason :) and I would like to know it.  </p>\n<p>BTW there is related Q but most of the A even dont mention pure thing, or when they do they dont specify the reasoning why std allows this. \n<a href=\"https://stackoverflow.com/questions/5462388/relation-betwean-constexpr-and-pure-functions\">Relation between constexpr and pure functions</a></p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "700825", "AnswerCount": "3"}, "13296531": {"ParentId": "13295089", "CommentCount": "0", "Body": "<p>Because for some domain of input parameters, the impure path will never be taken. For that domain, constexpr will work fine.</p>\n<p>For instance, your function may have a simple branch and a more complicated branch. And you may specify that for your function to be usable in constant expressions, the function arguments must be such that this and that condition is met, yielding to the simple branch in your function that is always pure.</p>\n<p>A useful sideeffect of this is that you can cause errors during constant computation. I.e if a precondition in the simple branch is violated, you could cause the evaluation of an impure expression, provoking a compile time error (an assertion or an exception is a good idea here, as it continues to complain when the function is invoked in a runtime context).</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "13296531", "Score": "6", "CreationDate": "2012-11-08T19:42:21.187", "LastActivityDate": "2012-11-08T19:42:21.187"}, "bq_ids": {"n4140": {"so_13295089_14472252_0": {"section_id": 5421, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_13295089_14472252_0": {"section_id": 5216, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_13295089_14472252_0": {"section_id": 6843, "quality": 0.631578947368421, "length": 12}}}});