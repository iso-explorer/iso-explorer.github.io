post_cb({"bq_ids": {"n4140": {"so_22476782_22478593_0": {"length": 19, "quality": 1.0, "section_id": 7156}}, "n3337": {"so_22476782_22478593_0": {"length": 19, "quality": 1.0, "section_id": 6900}}, "n4659": {"so_22476782_22478593_0": {"length": 19, "quality": 1.0, "section_id": 8663}}}, "22478593": {"Id": "22478593", "PostTypeId": "2", "Body": "<p>Would it be acceptable for you to enforce the user of the class to use <a href=\"http://www.parashift.com/c++-faq-lite/static-init-order-on-first-use.html\" rel=\"nofollow\">Construct On First Use Idiom</a> for all static instances of <code>Object</code>? Then, they should always be constructed after the container which should be constructed before <code>main</code>. Static objects are destructed in reverse order of construction. Therefore all static <code>Object</code> that are constructed after the container will be destroyed first.</p>\n<p>Quote from standard \u00a73.6.3 / 1:</p>\n<blockquote>\n<p id=\"so_22476782_22478593_0\">... If the completion of the constructor or dynamic initialization of an object with static storage\n   duration is sequenced before that of another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>If that's not acceptable, how about adding a flag to the <code>Object</code> class:</p>\n<pre><code>class Object {\npublic:\n    bool registered; // init to false, set to true on registration\n    ~Object() { if(registered) reg.erase(this);  }\n</code></pre>\n<p>Then modify the destructor  of the container (use a custom delegating container or subclass if you cannot modify the current container) to set the flag <code>false</code> for each pointed object before clearing contents. This may also be possible if you wrap the container into a <code>unique_ptr</code> with a custom deleter.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2014-03-18T12:33:16.767", "Score": "1", "CreationDate": "2014-03-18T11:53:01.767", "ParentId": "22476782", "CommentCount": "4", "OwnerUserId": "2079303", "LastEditDate": "2014-03-18T12:33:16.767"}, "22476782": {"ViewCount": "93", "Body": "<p>I'm trying to implement the following behavior (simplified):</p>\n<ul>\n<li>There's an Object base class that anyone can derive from and there will be several instances of these.</li>\n<li>Anyone from anywhere can add an instance pointer to a globally accessible set of pointers to Object.</li>\n<li>An object should remove itself from that set (if it's in it) upon destruction.</li>\n<li>I only need it to work in a single thread and in a single module (no dynamic library loading etc.)</li>\n</ul>\n<p>Conceptually something like this:</p>\n<pre><code>class Object {\npublic:\n//...\n\n~Object() { reg.erase(this);  }\nstatic void register(Object* obj) { reg.insert(obj); }\n\nstatic std::set&lt;Object*&gt; reg;\n}\n</code></pre>\n<p>This is simplified, as it's not really a set but a more complicated container. As a result there are some iterators etc. involved in the register() and the destructor. I also omitted getters/setters and access control for brevity.</p>\n<p>The problem I have with this is that it works as long as no one creates a static Object (or derived). It will then depend on the actual order of destruction of the static set and the static object (which is undefined if I'm not mistaken). I tested that it really crashes or not, depending on the order of these two. I can't(and don't want to) guarantee that no static instance of Object will be created. I also don't want to enforce user of the class to call any cleanup code etc. Object should be \"self aware\".</p>\n<p>I tried to employ singleton for the set but I keep circling back to the same chicken and egg problem with statics in the destructor.</p>\n<p>How can I either fix this or achieve the same behavior with another design (possibly without so much statics)? Maybe there's a way to ensure that a particular static will be destroyed after anything else (at least in \"my\" code)?</p>\n", "AcceptedAnswerId": "22478593", "Title": "Static object with access to static member in the destructor", "CreationDate": "2014-03-18T10:36:44.920", "Id": "22476782", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-03-18T12:33:16.767", "Score": "3", "OwnerUserId": "1972990", "Tags": "<c++>", "AnswerCount": "1"}});