post_cb({"23758400": {"ParentId": "23758399", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-05-20T11:20:32.447", "Score": "10", "LastEditorUserId": "1090079", "LastEditDate": "2014-05-23T12:28:59.910", "Id": "23758400", "OwnerUserId": "1090079", "Body": "<p><sup>I can think of a few real-life scenarios where the construct allowed by the Standard both makes sense, and is required, however; I'll first try to answer this question from a broader perspective, not involving any specific problem.</sup></p>\n<hr>\n<p><strong>THE EXPLANATION</strong></p>\n<p><em>Allocators</em>  are this magical things responsible for allocating, constructing, destructing, and deallocating memory and entities. Since C++11 when <em>stateful allocators</em>  came into play an allocator can do much more than previously, but it all boils down to the previously mentioned four operations.</p>\n<p><em>Allocators</em> have loads of requirements, one of them being that <code>a1 == a2</code> (where <code>a1</code> and <code>a2</code> are allocators of the same type) must yield <code>true</code> <strong>only</strong> if memory <em>allocated</em> by one can be <em>deallocated</em> by the other <sup>[1]</sup>.</p>\n<p>The above requirement of <code>operator==</code> means that two allocators comparing equal can do things differently, as long as they still have a mutual understanding of how memory is allocated.</p>\n<p>The above is why the Standard allows <code>propagate_on_container_*</code> to be equal to <code>std::false_type</code>; we might want to change the contents of two containers which allocators have the same deallocation behavior, but leave the other behavior (not related to basic memory management) behind.</p>\n<p><br/></p>\n<p><sup><sup>[1]</sup> as stated in <code>[allocator.requirements]p2</code> (table 28)</sup></p>\n<hr>\n<p><strong>THE (SILLY) STORY</strong></p>\n<p>Imagine that we have an <em>Allocator</em> named <em>Watericator</em>, it gathers water upon requested allocation, and hands it to the requested container.</p>\n<p><em>Watericator</em> is a stateful Allocator, and upon constructing our instance we can choose two modes; </p>\n<ol>\n<li><p>employ <em>Eric</em>, who fetches water down at the fresh water spring, while also measures (and reports) water level and purity.</p></li>\n<li><p>employ <em>Adam</em>, who uses the tap out in the backyard and doesn't care anything about logging. <em>Adam</em> is a lot faster than <em>Eric</em>.</p></li>\n</ol>\n<p><br/></p>\n<p>No matter where the water comes from we <strong>always</strong> dispose of it in the same way; by watering our plants. Even if we have one instance where <em>Eric</em> is supplying us water (memory), and another where <code>Adam</code> is using the tap, both <em>Watericators</em> compare equal as far as <code>operator==</code> is concerned.</p>\n<p>Allocations done by one can be deallocated by the other.</p>\n<p><br/>\n<sup><em>The above might be a silly similie, but imagine we have an allocator which does logging upon every allocation, and we uses this on a container somewhere in our code that interests us; we later want to move the elements out from this container into another one.. but we are no longer interested in all that logging.</em></sup></p>\n<p><sup><em>Without stateful allocators, and the option to turn <code>propagate_on_container_*</code> off, we would be forced to either 1) copy every element involved 2) be stuck with that (no longer required) logging.</em></sup></p>\n</hr></hr>", "LastActivityDate": "2014-05-23T12:28:59.910"}, "23758399": {"CommentCount": "0", "AcceptedAnswerId": "23758400", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-20T11:20:32.447", "LastActivityDate": "2014-05-23T12:28:59.910", "LastEditDate": "2017-05-23T11:59:17.940", "ViewCount": "362", "FavoriteCount": "4", "Title": "Why allow `propagate_on_container_swap == false` in Allocators, when it might cause undefined behaviour?", "Id": "23758399", "Score": "11", "Body": "<p><sup><strong>Note:</strong> Originally asked by <a href=\"https://stackoverflow.com/users/1505939/matt-mcnabb\">Matt Mcnabb</a> as a <a href=\"https://stackoverflow.com/questions/23757166/why-can-swapping-standard-library-containers-be-problematic-in-c11-involving#comment36527699_23757167\">comment</a> on <a href=\"https://stackoverflow.com/q/23757166/1090079\">Why can swapping standard library containers be problematic in C++11 (involving allocators)?</a>.</sup></p>\n<hr>\n<p>The Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">N3797</a>) says that if <code>progagate_on_container_swap</code> inside an <em>Allocator</em> is <code>std::false_type</code> it will yield <em>undefined behaviour</em> if the two allocators involved doesn't compare equal.</p>\n<ul>\n<li>Why would the Standard allow such construct when it seems more than dangerous?</li>\n</ul>\n<hr>\n<blockquote>\n<p id=\"so_23758399_23758399_0\"><code>23.2.1p9</code> <strong>General Container Requirements</strong> <code>[container.requirements.general]</code></p>\n<blockquote>\n<p id=\"so_23758399_23758399_2\">If\n    <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code>\n    is <code>true</code>, then the allocators of <code>a</code> and <code>b</code> shall also be exchanged\n    using an unqalified call to non-member <code>swap</code>. <strong>Otherwise, they shall\n    not be swapped, and the behavior is undefined unless <code>a.get_allocator() == b.get_allocator()</code></strong>.</p>\n</blockquote>\n</blockquote>\n</hr></hr>", "Tags": "<c++><c++11><language-lawyer><allocator>", "OwnerUserId": "1090079", "AnswerCount": "2"}, "23759380": {"ParentId": "23758399", "CommentCount": "0", "CreationDate": "2014-05-20T12:06:47.250", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "23759380", "Score": "0", "Body": "<p>It is not so much that the Standard allows <code>propagate_on_container_swap</code> to <em>cause</em> Undefined Behavior, but that the Standard <em>exposes</em> Undefined Behavior via this value!</p>\n<hr>\n<p>A simple example is to consider a scoped allocator, which allocates memory from a local pool, and which said pool is deleted when the allocator goes out of scope:</p>\n<pre><code>template &lt;typename T&gt;\nclass scoped_allocator;\n</code></pre>\n<p>Now, let us use it:</p>\n<pre><code>int main() {\n    using scoped = scoped_allocator&lt;int&gt;;\n\n    scoped outer_alloc;\n    std::vector&lt;int, scoped&gt; outer{outer_alloc};\n\n    outer.push_back(3);\n\n    {\n        scoped inner_alloc;\n        std::vector&lt;int, scoped&gt; inner{inner_alloc};\n\n        inner.push_back(5);\n\n        swap(outer, inner); // Undefined Behavior: loading...\n    }\n\n    // inner_allocator is dead, but \"outer\" refers to its memory\n}\n</code></pre>\n</hr>", "LastActivityDate": "2014-05-20T12:06:47.250"}, "bq_ids": {"n4140": {"so_23758399_23758399_1": {"section_id": 710, "quality": 0.9444444444444444, "length": 17}, "so_23758399_23758399_2": {"section_id": 710, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_23758399_23758399_1": {"section_id": 699, "quality": 0.9444444444444444, "length": 17}, "so_23758399_23758399_2": {"section_id": 699, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_23758399_23758399_1": {"section_id": 739, "quality": 0.7222222222222222, "length": 13}, "so_23758399_23758399_2": {"section_id": 739, "quality": 0.7222222222222222, "length": 13}}}});