post_cb({"bq_ids": {"n4140": {"so_42602382_42602463_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 6173}, "so_42602382_42602479_0": {"length": 5, "quality": 1.0, "section_id": 6181}, "so_42602382_42602473_0": {"length": 5, "quality": 0.625, "section_id": 6173}}, "n3337": {"so_42602382_42602463_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 5934}, "so_42602382_42602479_0": {"length": 5, "quality": 1.0, "section_id": 5942}, "so_42602382_42602473_0": {"length": 5, "quality": 0.625, "section_id": 5934}}, "n4659": {"so_42602382_42602463_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 7675}, "so_42602382_42602479_0": {"length": 5, "quality": 1.0, "section_id": 7683}, "so_42602382_42602473_0": {"length": 5, "quality": 0.625, "section_id": 7675}}}, "42602382": {"ViewCount": "1225", "Body": "<p>This is a follow-up to <a href=\"https://stackoverflow.com/questions/42191661/why-cant-i-use-an-brace-enclosed-list-as-an-operand-to-an-overloaded-operator\">an earlier question about why I can't use a brace-enclosed initializer as an argument to <code>operator+</code></a>, which was resolved by looking at <a href=\"https://stackoverflow.com/questions/11420448/initializer-lists-and-rhs-of-operators\">this earlier question on the subject</a>.</p>\n<p>Consider the following C++ code, which you can <a href=\"http://ideone.com/xrS0HK\" rel=\"nofollow noreferrer\">try live at ideone.com</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\nusing namespace std;\n\nstruct AddInitializerList {\n    void operator+= (initializer_list&lt;int&gt; values) {\n        // Do nothing   \n    }\n\n    void operator+ (initializer_list&lt;int&gt; values) {\n        // Do nothing\n    }\n};\n\nint main() {\n    AddInitializerList adder;\n    adder += {1, 2, 3};  // Totally legit\n    adder +  {1, 2, 3};  // Not okay!\n\n    return 0;\n}\n</code></pre>\n<p>The line in <code>main</code> that uses <code>operator+</code> with a brace-enclosed initializer list does not compile (and, after asking that earlier question, I now know why this is). However, I'm confused why the code that uses <code>opeartor+=</code> in <code>main</code> does indeed compile just fine.</p>\n<p>I'm confused as to precisely why I can overload <code>+=</code> and have it work just fine, while overloading <code>+</code> doesn't seem to work here. Is there a particular provision in the standard that permits brace-enclosed initializers in the context of the <code>+=</code> operator but not the <code>+</code> operator? Or is this just a weird compiler quirk?</p>\n", "AcceptedAnswerId": "42602473", "Title": "Why can I use initializer lists on the right-hand side of operator += but not operator+?", "CreationDate": "2017-03-04T23:01:00.003", "Id": "42602382", "CommentCount": "5", "LastEditDate": "2017-05-23T10:30:49.243", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-04T23:25:21.813", "Score": "19", "OwnerUserId": "501557", "Tags": "<c++><operator-overloading><initializer-list>", "AnswerCount": "3"}, "42602463": {"Id": "42602463", "PostTypeId": "2", "Body": "<p><code>+=</code> operator is a <em>compound assignment</em>. The standard explicitly permits initializer lists on the right-hand side of assignments:</p>\n<blockquote>\n<p id=\"so_42602382_42602463_0\">\u00a78.5.4/1 [...] Note: List-initialization can be used</p>\n<p id=\"so_42602382_42602463_1\">...</p>\n<p id=\"so_42602382_42602463_2\">\u2014 on the right-hand side of an assignment (5.17)</p>\n</blockquote>\n<p>\u00a75.17 talks about all assignments, including compound ones:</p>\n<blockquote>\n<p id=\"so_42602382_42602463_3\">assignment-expression:<br/>\n   - conditional-expression<br/>\n   - logical-or-expression <em>assignment-operator</em> initializer-clause<br/>\n   - throw-expression</p>\n<p id=\"so_42602382_42602463_4\">assignment-operator: one of<br/>\n<code>=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>+=</code> <code>-=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>&amp;=</code> <code>\u02c6=</code> <code>|=</code></p>\n</blockquote>\n", "LastActivityDate": "2017-03-04T23:12:18.837", "CommentCount": "0", "CreationDate": "2017-03-04T23:12:18.837", "ParentId": "42602382", "Score": "7", "OwnerUserId": "335858"}, "42602479": {"Id": "42602479", "PostTypeId": "2", "Body": "<p>C++14 \u00a75.17/9:</p>\n<blockquote>\n<p id=\"so_42602382_42602479_0\"><strong>\u201d</strong> A <em>braced-init-list</em> may appear on the right-hand side of  </p>\n<ul>\n<li>an assignment to a scalar, in which case the initializer list shall have at most a single element. The meaning of <code>x={v}</code>, where <code>T</code> is the scalar type of the expression <code>x</code>, is that of <code>x=T{v}</code>. The meaning of <code>x={}</code> is <code>x=T{}</code>.  </li>\n<li>an assignment to an object of class type, in which case the initializer list is passed as the argument to the assignment operator function selected by overload resolution (13.5.3, 13.3).</li>\n</ul>\n</blockquote>\n<p>This applies to <em>a</em><code>+=</code><em>b</em> via its $5.7/7 equivalence to <em>a</em><code>=</code><em>a</em><code>+</code><em>b</em> (except that <em>a</em> is evaluated only once for <code>+=</code>). Put another way, due to a comment by M.M., because of the equivalence for the built-in operators <code>+=</code> is regarded as an assignment operator, and not a special update operator.\nHence the quoted text above about \u201cassignment\u201d applies to <code>+=</code>.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2017-03-04T23:25:21.813", "Score": "9", "CreationDate": "2017-03-04T23:14:39.400", "ParentId": "42602382", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2017-03-04T23:25:21.813"}, "42602473": {"Id": "42602473", "PostTypeId": "2", "Body": "<p>It is explained in the answer to <a href=\"https://stackoverflow.com/questions/11420448/initializer-lists-and-rhs-of-operators\">this question</a>  (which is linked from the question you linked to).</p>\n<p>The language grammar only allows a braced list in certain grammatical contexts, not in place of an arbitrary expression.  That list includes the right-hand side of assignment operators, but NOT the right-hand side of operators in general.</p>\n<p><code>+=</code> is an assignment operator, <code>+</code> is not.</p>\n<p>The grammar for assignment expressions is:</p>\n<blockquote>\n<p id=\"so_42602382_42602473_0\"><pre>\n  <em>assignment-expression:</em>\n     <em>conditional-expression</em>\n     <em>logical-or-expression assignment-operator initializer-clause</em>\n     <em>throw-expression</em>\n  <em>assignment-operator:</em> one of\n      <code>= *= *= /= %= += -= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</code>\n  </pre></p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-04T23:13:44.020", "Score": "21", "CreationDate": "2017-03-04T23:13:44.020", "ParentId": "42602382", "CommentCount": "5", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T11:47:35.397"}});