post_cb({"4418208": {"CommentCount": "1", "Body": "<p><strong>Allocation is one thing, object construction/destruction is another.</strong></p>\n<p>A <code>new</code> performs one allocation and one construction. However, a <code>new[]</code> still allocates one continuous memory block, but calls many constructors.</p>\n<p>The situation is the same with <code>delete</code> and <code>delete[]</code>.</p>\n<p>BTW- I'm not 100% sure with what I'm about to say, but I believe that you won't get an imemdiate memory leak if you call <code>delete</code> on an address received from <code>new[]</code>. The whole memory block would probably be freed. However, this is invalid because you'd call the destructor on the first object only, instead of on every object in the array. And this may result in <em>secondary</em> memory leaks... and lots of logic errors due to broken 1-1 relation of constructors and destructors, of course.</p>\n<p>(Also, remember to consider using <code>boost::array</code> or  <code>std::vector</code> instead of <code>new[]</code>! :))</p>\n", "CreationDate": "2010-12-11T18:21:27.210", "ParentId": "4417934", "Id": "4418208", "LastActivityDate": "2010-12-11T18:21:27.210", "PostTypeId": "2", "Score": "0", "OwnerUserId": "399317"}, "4417964": {"LastActivityDate": "2010-12-11T17:55:30.853", "CommentCount": "21", "Body": "<p>There's not a whole lot of difference between the required behavior of the functions <code>void* operator new(size_t)</code> and <code>void* operator new[](size_t)</code>, except that they're paired with different deallocation functions.</p>\n<p>The operators themselves are very different.  One of the differences between the operators is which allocation function is used, but there are ultimately many other differences including how many constructors get called, etc.  But your example code isn't using the operators (well, it is using placement new).  You might want to change your question title to be clear about that.</p>\n<p>From section <code>[basic.stc.dynamic.deallocation]</code>:</p>\n<blockquote>\n<p id=\"so_4417934_4417964_0\">If a deallocation function terminates\n  by throwing an exception, the behavior\n  is undefined. The value of the first\n  argument supplied to a deallocation\n  function may be a null pointer value;\n  if so, and if the deallocation\n  function  is  one  supplied  in  the \n  standard  library,  the  call  has  no\n  effect.   Otherwise,  the  value \n  supplied to <code>operator delete(void*)</code> in\n  the standard library shall be one of\n  the values returned by a previous\n  invocation of either operator\n  <code>new(std::size_t)</code> or operator\n  <code>new(std::size_t, const std::nothrow_-\n  t&amp;)</code> in the standard library, and the\n  value supplied to <code>operator\n  delete[](void*)</code> in the standard\n  library shall be one of the values\n  returned by a previous invocation of\n  either <code>operator new[](std::size_t)</code> or\n  <code>operator new[](std::size_t, const\n  std::nothrow_t&amp;)</code> in the standard\n  library.</p>\n</blockquote>\n", "CreationDate": "2010-12-11T17:27:40.347", "LastEditDate": "2010-12-11T17:55:30.853", "ParentId": "4417934", "Id": "4417964", "LastEditorUserId": "103167", "PostTypeId": "2", "Score": "0", "OwnerUserId": "103167"}, "4418263": {"LastActivityDate": "2010-12-11T18:48:57.497", "CommentCount": "3", "Body": "<p>These functions (<code>operator new</code> etc.) are not generally intended to be called explicitly, but rather used implicitly by <code>new</code>/<code>new[]</code> expressions (symmetrically, <code>operator delete</code>/<code>operator delete[]</code> functions are invoked implicitly by <code>delete</code>/<code>delete[]</code> expressions). An expression that uses <code>new</code> syntax for non-array type will implicitly call <code>operator new</code> function, while an expression with <code>new[]</code> will implicitly call <code>operator new[]</code>. </p>\n<p>The important detail here is that an array created by <code>new[]</code> expression will normally be destroyed later by <code>delete[]</code> expression. The latter will need to know the number of objects to destruct (if the objects have non-trivial destructors), i.e. this information has to be passed somehow from <code>new[]</code> expression (when it was known) to the corresponding <code>delete[]</code> expression (when it is needed). In a typical implementation this information is stored inside the block allocated by <code>new[]</code> expression, which is why the memory size requested in the implicit call to <code>operator new[]</code> is normally <em>greater</em> than the product of the number of elements and the element size. The extra space is used to store the household information (number of elements, namely). Later <code>delete[]</code> expression will retrieve that household information and use it to invoke the correct number of destructors before actually freeing the memory by calling <code>operator delete[]</code>.</p>\n<p>In your example you are not using any of these mechanisms. In your example you are calling memory allocation functions explicitly, perform construction manually and completely ignore the destruction step (which is OK, since your object has trivial destructor), which means that at least for destruction purposes you don't need to track the exact number of elements in the array. In any case, you keep track of that number manually, in a <code>no</code> variable.</p>\n<p>However, in general case it is not possible. In general case the code will use <code>new[]</code> expressions and <code>delete[]</code> expressions and the number of elements will have to get from <code>new[]</code> to <code>delete[]</code> somehow, meaning that it has to be stored internally, which is why there's a need for a dedicated memory allocation function for arrays - <code>operator new[]</code>. It is not equivalent to a mere <code>operator new</code> with the aforementioned product as size.</p>\n", "CreationDate": "2010-12-11T18:32:08.910", "LastEditDate": "2010-12-11T18:48:57.497", "ParentId": "4417934", "Id": "4418263", "LastEditorUserId": "187690", "PostTypeId": "2", "Score": "6", "OwnerUserId": "187690"}, "4418210": {"CommentCount": "7", "Body": "<p>In your example code, you're using placement <code>new</code> to perform the construction that <code>operator new[]</code> performs automatically - with the difference that <code>new[]</code> will only perform default construction and you're performing a non-default placement construction.</p>\n<p>The following is more or less equivalent to your example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct X\n{\n    int data_;\n    X(int v=0):data_(v){}\n};\n\nint main(int argc, char* argv[])\n{\n    unsigned no = 10;\n\n    X* xp = new X[no];\n\n    for (unsigned i = 0; i &lt; no; ++i) {\n        X tmp(i);\n        xp[i] = tmp;\n    }\n\n    for (unsigned i = 0; i &lt; no; ++i)\n    {\n        cout &lt;&lt; (xp[i]).data_ &lt;&lt; '\\n';\n    }\n\n    delete[] xp;\n\n    return 0;\n}\n</code></pre>\n<p>The differences in this example are:</p>\n<ul>\n<li>I believe the example here is more readable (casts can be ugly, and placement <code>new</code> is a pretty advanced technique that isn't often used, so isn't often understood)</li>\n<li>it properly destroys the allocated objects (it doesn't matter in the example since the object are PODs, but in the general case, you need to call the dtor for each object in the array)</li>\n<li>it has to default construct the array of objects, then iterate over them to set the actual value for the object - <em>this</em> is the one disadvantage in this example as opposed to yours</li>\n</ul>\n<p>I think that in general, using <code>new[]</code>/<code>delete[]</code> is a much better than allocating raw memory and using placement <code>new</code> to construct the objects. It pushes the complexity of the bookkeeping into those operators instead of having it in your code.  However, if the cost of the \"default construct/set desired value\" pair of operations is found to be too costly, then the complexity of doing it manually might be worthwhile.  That should be a pretty rare situation.</p>\n<p>Of course, any discussion of <code>new[]</code>/<code>delete[]</code> needs to mention that using <code>new[]</code>/'delete[]<code>should probably be avoided in favor of using</code>std::vector`.</p>\n", "CreationDate": "2010-12-11T18:21:59.350", "ParentId": "4417934", "Id": "4418210", "LastActivityDate": "2010-12-11T18:21:59.350", "PostTypeId": "2", "Score": "1", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_4417934_4417964_0": {"length": 60, "quality": 0.967741935483871, "section_id": 7182}}, "n3337": {"so_4417934_4417964_0": {"length": 60, "quality": 0.967741935483871, "section_id": 6926}}}, "4417934": {"CreationDate": "2010-12-11T17:23:25.190", "ViewCount": "1365", "FavoriteCount": "2", "Id": "4417934", "Score": "9", "Title": "Difference between operator new() and operator new[]()?", "LastEditorUserId": "103167", "CommentCount": "23", "Body": "<p>Is there any difference between fncs: operator new and operator new[] (NOT new and new[] operators)? Except of course call syntax? I'm asking because I can allocate X number of bytes for my objs with ::operator new(sizeof(T)*numberOfObject) and then access them with array notation, so what's the big deal with ::operator new[]. Is it only syntactic sugar?  </p>\n<pre><code>#include &lt;new&gt;\n#include &lt;iostream&gt;\n#include &lt;malloc.h&gt;\n\nusing namespace std;\nstruct X\n{\n  int data_;\n  X(int v):data_(v){}\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n  unsigned no = 10;\n  void* vp = ::operator new(sizeof(X) * no);\n  cout &lt;&lt; \"Mem reserved: \" &lt;&lt; _msize(vp) &lt;&lt; '\\n';\n  X* xp = static_cast&lt;X*&gt;(vp);\n  for (unsigned i = 0; i &lt; no; ++i)\n  {\n    new (xp + i) X(i);\n  }\n  for (unsigned i = 0; i &lt; no; ++i)\n  {\n    cout &lt;&lt; (xp[i]).data_ &lt;&lt; '\\n';\n  }\n  for (unsigned i = 0; i &lt; no; ++i)\n  {\n    (xp + i)-&gt;~X();\n  }\n  ::operator delete(vp);\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><memory>", "LastEditDate": "2010-12-12T01:45:00.620", "LastActivityDate": "2010-12-13T12:17:58.707", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "207177"}, "4428717": {"LastActivityDate": "2010-12-13T12:17:58.707", "CommentCount": "0", "Body": "<p>As <a href=\"https://stackoverflow.com/users/105936/sankoz\">user sankoz</a> explains in <a href=\"https://stackoverflow.com/questions/2499895/whats-the-purpose-of-having-a-separate-operator-new/2500544#2500544\">his answer</a> to <a href=\"https://stackoverflow.com/q/2499895/57428\">in fact the same question</a>, having separate <code>operator new[]</code> is intended for overloading single object allocations and array allocations separately in classes.</p>\n<p>For example, if you have some specific class and you know that its instances are never larger than say 50 bytes you might want to overload <code>operator new</code> for that class so that its instances are allocated on a superfast allocator for blocks of size 50.</p>\n<p>But what if the user calls <code>new[]</code>? The array can have whatever number of elemenents, so you can't universally allocate them on your custom allocator. The solution is you don't have to care of array allocations unless you want to.</p>\n", "CreationDate": "2010-12-13T12:17:58.707", "LastEditDate": "2017-05-23T12:25:16.487", "ParentId": "4417934", "Id": "4428717", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "0", "OwnerUserId": "57428"}});