post_cb({"23183376": {"Id": "23183376", "PostTypeId": "2", "Body": "<p><em>why won't this generate a compile time error when the compiler generates the default copy constructor and assignment operators in the derived class ?</em></p>\n<p>Because the compiler generates them only when they are needed by the code being compiled.  Write some code using the derived class where the copy constructor and/or assignment operator are involved, and you will see the compile-time error you are looking for.</p>\n", "LastActivityDate": "2014-04-20T14:07:50.660", "Score": "3", "CreationDate": "2014-04-20T14:07:50.660", "ParentId": "23183322", "CommentCount": "3", "OwnerUserId": "1916711"}, "bq_ids": {"n4140": {"so_23183322_23185451_5": {"length": 8, "quality": 1.0, "section_id": 460}, "so_23183322_23185451_1": {"length": 7, "quality": 1.0, "section_id": 460}, "so_23183322_23185451_3": {"length": 16, "quality": 0.8, "section_id": 460}, "so_23183322_23185451_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 460}, "so_23183322_23185451_4": {"length": 10, "quality": 0.7692307692307693, "section_id": 369}, "so_23183322_23185451_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 460}}, "n3337": {"so_23183322_23185451_3": {"length": 19, "quality": 0.95, "section_id": 451}, "so_23183322_23185451_1": {"length": 7, "quality": 1.0, "section_id": 451}, "so_23183322_23185451_5": {"length": 8, "quality": 1.0, "section_id": 451}, "so_23183322_23185451_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 451}, "so_23183322_23185451_4": {"length": 13, "quality": 1.0, "section_id": 359}, "so_23183322_23185451_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 451}, "so_23183322_23185451_6": {"length": 16, "quality": 1.0, "section_id": 451}}, "n4659": {"so_23183322_23185451_3": {"length": 16, "quality": 0.8, "section_id": 483}, "so_23183322_23185451_1": {"length": 7, "quality": 1.0, "section_id": 483}, "so_23183322_23185451_5": {"length": 8, "quality": 1.0, "section_id": 483}, "so_23183322_23185451_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 483}, "so_23183322_23185451_4": {"length": 10, "quality": 0.7692307692307693, "section_id": 382}, "so_23183322_23185451_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 483}, "so_23183322_23185451_6": {"length": 9, "quality": 0.5625, "section_id": 383}}}, "23183353": {"Id": "23183353", "PostTypeId": "2", "Body": "<p>The <code>private</code> in the inheritance makes them <code>private</code> to <code>Derived</code>, it can still see them, classes that use <code>Derived</code> can't.</p>\n", "LastActivityDate": "2014-04-20T14:05:18.290", "Score": "1", "CreationDate": "2014-04-20T14:05:18.290", "ParentId": "23183322", "CommentCount": "1", "OwnerUserId": "1312406"}, "23185451": {"Id": "23185451", "PostTypeId": "2", "Body": "<p>C++11 12.8/7 states \"If the class definition does not explicitly declare a copy constructor, one is declared implicitly.\" so <code>Dervied</code> has an implicitly declared copy constructor. 12.8/11 says:</p>\n<blockquote>\n<p id=\"so_23183322_23185451_0\">An implicitly-declared copy/move constructor is an <code>inline public</code> member of its class. A defaulted copy/move constructor for a class <code>X</code> is defined as deleted (8.4.3) if <code>X</code> has:</p>\n<ul>\n<li><p id=\"so_23183322_23185451_1\">a variant member with a non-trivial corresponding constructor and <code>X</code> is a union-like class,</p></li>\n<li><p id=\"so_23183322_23185451_2\">a non-static data member of class type <code>M</code> (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to <code>M</code>\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</p></li>\n<li><p id=\"so_23183322_23185451_3\">a direct or virtual base class <code>B</code> that cannot be copied/moved because overload resolution (13.3), as applied to <code>B</code>\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</p></li>\n<li><p id=\"so_23183322_23185451_4\">any direct or virtual base class or non-static data member of a type with a destructor that is deleted or inaccessible from the defaulted constructor,</p></li>\n<li><p id=\"so_23183322_23185451_5\">for the copy constructor, a non-static data member of rvalue reference type, or</p></li>\n<li><p id=\"so_23183322_23185451_6\">for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.</p></li>\n</ul>\n</blockquote>\n<p>Specifically, the third bullet applies: <code>Dervied</code> has a direct base class <code>Uncopyable</code> that cannot be copied because overload resolution results in a function that is inaccessible from <code>Dervied</code>::<code>Dervied(const Dervied&amp;)</code>. As a result <code>Dervied</code>'s implicitly declared copy constructor is declared as deleted, resulting in a compile time error if and only if that copy constructor is called.</p>\n", "LastActivityDate": "2014-04-20T17:24:38.483", "Score": "2", "CreationDate": "2014-04-20T17:24:38.483", "ParentId": "23183322", "CommentCount": "0", "OwnerUserId": "923854"}, "23183444": {"Id": "23183444", "PostTypeId": "2", "Body": "<p>One class cannot <em>call</em> private methods on another class, but it can inherit as much as it is coded too. This code just includes the member functions from Uncopyable in Derived. </p>\n<p>Imagine if you wrote a class inheriting from std::vector. You can still erase, insert, push_back and do all those sorts of things. Because these are all public or protected vector member functions, they in turn call implementation specific private functions that do the low level things like manage memory. Your code in this derived class couldn't call those memory management functions directly though. This is used to insure the creators of the vector can change the internal details freely without breaking your use of the class.</p>\n<p>If your example is what the code actually looks like, then this it is a common pattern used to make things that cannot be copied. It would make code like the following produce a compiler error:</p>\n<pre><code>Derived Foo;\nDerived Bar;\nFoo = Bar\n</code></pre>\n<p>It would also make the code throw an error on the following:</p>\n<pre><code>int GetAnswer(Derived bar)\n    { /* Do something with a Derived */ }\nDerived Foo;\nint answer = GetAnser(Foo);\n</code></pre>\n<p>This example fails because a copy of foo is made and passed as the parameter in the function GetAnswer.</p>\n<p>There are many reasons why something might not be copyable. The most common I have experienced is that the object manages some low level resource a single file, an opengl context, an audio output, etc... Imagine if you had a class that managed a log file. If it closed the file in the deconstructor, what happens to the original when a copy is destroyed.</p>\n<p>Edit: to pass an Uncopyable class to a function, pass it by reference. The Following function does not make a copy:</p>\n<pre><code>int GetAnswer(Derived&amp; bar)\n    { /* Do something with a Derived */ }\nDerived Foo;\nint answer = GetAnser(Foo);\n</code></pre>\n<p>It would also cause a compiler error if all the constructor were private and the class was instantiated. But even if all the member function even constructors were private and the class was never instantiated that would be valid compiling code.</p>\n<p>Edit: The reason a class with constructor is that there maybe other way to construct it or it maybe have static member functions, or class functions.</p>\n<p>Sometimes factories are used to build object which have no obvious constructor. These might have functions to whatever magic is required to make the umakeable class instance. The most common I have seen is just that there was another constructor that was public, but not in an obvious place. I have also seen factories as friend classes to the unconstructable class so they could call the constructors and I have seen code manually twiddle bits of memory and cast pointers to the memory it to an instance of a class. All of these patterns are used to insure that a class is correctly created beyond just the guarantees C++ supplies.</p>\n<p>A more common pattern I have seen is static member functions in classes.</p>\n<pre><code>class uncreateable\n{\n    uncreateable() {}\n  public:\n    static int GetImportantAnswer();\n};\n</code></pre>\n<p>Looking at this it can be seen that not only do I not need to create a instance of the class to call GetImportantAnswer() but I couldn't create an instance if I wanted. I could call this code using the following:</p>\n<pre><code>int answer;\nanswer = uncreateable::GetImportantAnswer();\n</code></pre>\n<p>Edit: Spelling and grammar</p>\n", "LastEditorUserId": "17315", "LastActivityDate": "2014-04-20T14:33:47.200", "Score": "1", "CreationDate": "2014-04-20T14:15:42.660", "ParentId": "23183322", "CommentCount": "0", "LastEditDate": "2014-04-20T14:33:47.200", "OwnerUserId": "17315"}, "23183322": {"ViewCount": "696", "Body": "<p>In C++, if we have this class</p>\n<pre><code>class Uncopyable{\npublic:\n    Uncopyable(){}\n    ~Uncopyable(){}\nprivate:\n    Uncopyable(const Uncopyable&amp;);\n    Uncopyable&amp; operator=(const Uncopyable&amp;);\n};\n</code></pre>\n<p>and then we have a derived class</p>\n<pre><code>class Dervied: private Uncopyable{\n};\n</code></pre>\n<p>My question is: why won't this generate a compile time error when the compiler generates the default copy constructor and assignment operators in the derived class ? Won't the generated code try to access base class private members ?</p>\n", "AcceptedAnswerId": "23183376", "Title": "c++ Inheriting private copy constructor: how doesn't this yield a compile time error?", "CreationDate": "2014-04-20T14:01:41.420", "Id": "23183322", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-04-20T14:09:42.470", "LastEditorUserId": "3309790", "LastActivityDate": "2014-04-20T17:24:38.483", "Score": "4", "OwnerUserId": "1011792", "Tags": "<c++><inheritance>", "AnswerCount": "6"}, "23183470": {"Id": "23183470", "PostTypeId": "2", "Body": "<p>The derived class will inherit the private copy constructor but will not need to use it unless you copy an object of derived type, as in this example.</p>\n<p>The compiler does not auto-generate constructors/operators unless they are <em>used</em> <strong>and</strong> no other constructor/operator can be used to do that operation (i.e. a copy operation can be used in some situations where a move operation would suffice). The latter statement results in the following set of rules.</p>\n<p>Here are the rules to the auto-generation of certain member functions:</p>\n<ul>\n<li><p>Default constructor (if no other constructor is explicitly declared)</p></li>\n<li><p>Copy constructor if no move constructor or move assignment operator\nis explicitly declared. If a destructor is declared generation of a\ncopy constructor is deprecated.</p></li>\n<li><p>Move constructor if no copy\nconstructor, move assignment operator or destructor is explicitly\ndeclared.</p></li>\n<li><p>Copy assignment operator if no move constructor or move assignment\noperator is explicitly declared. If a destructor is declared\ngeneration of a copy assignment operator is deprecated.</p></li>\n<li><p>Move assignment operator if no copy constructor, copy assignment operator\nor destructor is explicitly declared.</p></li>\n<li><p>Destructor</p></li>\n</ul>\n<p>The list is taken from <a href=\"http://en.wikipedia.org/wiki/Special_member_functions\" rel=\"nofollow\">this Wikipedia page</a>.</p>\n", "LastEditorUserId": "1576556", "LastActivityDate": "2014-04-20T14:29:18.567", "Score": "2", "CreationDate": "2014-04-20T14:18:58.653", "ParentId": "23183322", "CommentCount": "0", "LastEditDate": "2014-04-20T14:29:18.567", "OwnerUserId": "1576556"}, "23183398": {"Id": "23183398", "PostTypeId": "2", "Body": "<p>Well, actually this program does not compile with g++:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Uncopyable{\n  public:\n    Uncopyable(){}\n    ~Uncopyable(){}\n  private:\n    Uncopyable(const Uncopyable&amp;) {cout&lt;&lt;\"in parent copy constructor\";}\n    Uncopyable&amp; operator=(const Uncopyable&amp;) { cout &lt;&lt; \"in parent assignment operator\";}\n};\n\nclass Derived: private Uncopyable{\n\n};\n\nint main() {\n  Derived a;\n  Derived b = a;\n}\n</code></pre>\n<p>compiler output:</p>\n<pre><code>$ g++ 23183322.cpp \n23183322.cpp:10:88: warning: control reaches end of non-void function [-Wreturn-type]\n    Uncopyable&amp; operator=(const Uncopyable&amp;) { cout &lt;&lt; \"in parent assignment operator\";}\n                                                                                       ^\n23183322.cpp:13:7: error: base class 'Uncopyable' has private copy constructor\nclass Derived: private Uncopyable{\n      ^\n23183322.cpp:9:5: note: declared private here\n    Uncopyable(const Uncopyable&amp;) {cout&lt;&lt;\"in parent copy constructor\";}\n    ^\n23183322.cpp:19:15: note: implicit copy constructor for 'Derived' first required here\n  Derived b = a;\n              ^\n1 warning and 1 error generated.\n</code></pre>\n", "LastActivityDate": "2014-04-20T14:10:54.927", "Score": "0", "CreationDate": "2014-04-20T14:10:54.927", "ParentId": "23183322", "CommentCount": "2", "OwnerUserId": "166247"}});