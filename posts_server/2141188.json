post_cb({"2141461": {"ParentId": "2141188", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is legal C++, \u00a711.6/1 says:</p>\n<blockquote>\n<p id=\"so_2141188_2141461_0\">Access is checked at the call point\n  using the type of the expression used\n  to denote the object for which the\n  member function is called (B* in the\n  example above). The access of the\n  member function in the class in which\n  it was defined (D in the example\n  above) is in general not known.</p>\n</blockquote>\n<p>As you noted, <code>Child::Foo()</code> is thus still accessible via the base class, which is in most cases undesired:</p>\n<pre><code> Child* c = new Child;\n Base* b = c;\n c-&gt;Foo(); // doesn't work, Child::Foo() is private\n b-&gt;Foo(); // works, calls Child::Foo()\n</code></pre>\n<p>Basically, the declaration you refer to in the expression dictates the access mode - but virtual functions undermine that as another function then the named one may actually be invoked.</p>\n", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2010-01-26T20:10:55.867", "Id": "2141461", "Score": "19", "CreationDate": "2010-01-26T17:57:10.260", "LastActivityDate": "2010-01-26T20:10:55.867"}, "2141338": {"ParentId": "2141188", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Yes, changing the access mode in derived classes is legal.</p>\n<p>This is <strong>similar</strong> in form but <strong>different</strong> in intent to the <a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface\" rel=\"noreferrer\">Non-Virtual Interface</a> idiom. Some rationale is given <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"noreferrer\">here</a>:</p>\n<blockquote>\n<p id=\"so_2141188_2141338_0\">The point is that virtual functions exist to allow customization; unless they also need to be invoked directly from within derived classes' code, there's no need to ever make them anything but private.</p>\n</blockquote>\n<p>As to why you would actually make something <code>public</code> in base but <code>private</code> in derived without <code>private</code> or <code>protected</code> inheritance is beyond me.</p>\n", "OwnerUserId": "6210", "LastEditorUserId": "6210", "LastEditDate": "2012-04-26T15:48:24.827", "Id": "2141338", "Score": "11", "CreationDate": "2010-01-26T17:40:50.890", "LastActivityDate": "2012-04-26T15:48:24.827"}, "2141188": {"CommentCount": "6", "AcceptedAnswerId": "2141338", "CreationDate": "2010-01-26T17:20:18.147", "LastActivityDate": "2012-04-26T15:48:24.827", "PostTypeId": "1", "ViewCount": "11468", "FavoriteCount": "11", "Title": "Changing Function Access Mode in Derived Class", "Id": "2141188", "Score": "24", "Body": "<p>Consider the following snippet:</p>\n<pre><code>struct Base\n{\n  virtual ~Base() {}\n\n  virtual void Foo() const = 0; // Public\n};\n\nclass Child : public Base\n{\n  virtual void Foo() const {} // Private\n};\n\nint main()\n{\n  Child child;\n\n  child.Foo(); // Won't work. Foo is private in this context.\n\n  static_cast&lt;Base&amp;&gt; (child).Foo(); // Okay. Foo is public in this context.\n}\n</code></pre>\n<p>Is this legal C++? \"This\" being changing the virtual function's access mode in the derived class.</p>\n", "Tags": "<c++><inheritance><access-modifiers>", "OwnerUserId": "259426", "AnswerCount": "4"}, "2141270": {"ParentId": "2141188", "CommentCount": "1", "Body": "<p>It seems to compile and call the right method.</p>\n<p>Remember that access specifiers are there to help a disciplined programmer, not to prevent all attempts to circumvent it at all costs.</p>\n<p>In this particular case, Child has no business making the overridden virtual function private: isn't it supposed to implement the public interface of Base, so the \"is-a\" relationship holds? (If you didn't use public inheritance, which means \"Child is a Base\", your trick wouldn't work.)</p>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "2141270", "Score": "4", "CreationDate": "2010-01-26T17:33:00.310", "LastActivityDate": "2010-01-26T17:33:00.310"}, "2141245": {"ParentId": "2141188", "CommentCount": "0", "Body": "<p>It is perfectly legal C++. You are simply defining a new method in Child class. </p>\n<p>Now does it do what you want it to do, that's an other question.\nI believe the access mode is not part of the method signature, which means that calling Base's Foo virtual method does eventually call Child's Foo method.</p>\n<p>So here's the conclusion : <strong>it is legal c++ and it works the way you'd expect.</strong></p>\n<p>I am not taking into consideration the line <code>child.Foo();</code> which can't work because there is no doubt it is trying to access Child's private Foo() method.</p>\n", "OwnerUserId": "31640", "PostTypeId": "2", "Id": "2141245", "Score": "5", "CreationDate": "2010-01-26T17:27:55.553", "LastActivityDate": "2010-01-26T17:27:55.553"}, "bq_ids": {"n4140": {"so_2141188_2141461_0": {"section_id": 6697, "quality": 0.96, "length": 24}}, "n3337": {"so_2141188_2141461_0": {"section_id": 6452, "quality": 0.96, "length": 24}}, "n4659": {"so_2141188_2141461_0": {"section_id": 8172, "quality": 0.96, "length": 24}}}});