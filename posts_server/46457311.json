post_cb({"46457311": {"CommentCount": "14", "ViewCount": "88", "LastEditDate": "2017-09-27T21:39:10.260", "LastEditorUserId": "5501675", "CreationDate": "2017-09-27T21:13:21.390", "LastActivityDate": "2017-09-27T23:54:29.190", "PostTypeId": "1", "Title": "Why does std::(multi)set provide non const iterator methods", "Id": "46457311", "OwnerUserId": "5501675", "Body": "<p>Why do the sets (<code>std::set</code> and <code>std::multiset</code>) in the C++ standard library provide non <code>const_iterator</code> methods (<a href=\"http://en.cppreference.com/w/cpp/container/set/begin\" rel=\"nofollow noreferrer\"><code>set::begin</code></a> and <a href=\"http://en.cppreference.com/w/cpp/container/multiset/begin\" rel=\"nofollow noreferrer\"><code>multiset::begin</code></a>)?</p>\n<p>Access to the keys through iterators is always <code>const</code>. It does not matter if the set itself is const or not. <strong>Why introduce those extra overloads?</strong></p>\n", "Tags": "<c++><c++11><iterator><set><stdset>", "Score": "3", "AnswerCount": "2"}, "46458872": {"ParentId": "46457311", "CommentCount": "0", "Body": "<p>Note that in <a href=\"http://eel.is/c++draft/member.functions\" rel=\"nofollow noreferrer\">[member.functions]</a>, it's expressed that:</p>\n<blockquote>\n<p id=\"so_46457311_46458872_0\">For a non-virtual member function described in the C++ standard library, an implementation may declare a different set of member function signatures, provided that any call to the member function that would select an overload from the set of declarations described in this document behaves as if that overload were selected.</p>\n</blockquote>\n<p>The standard defines behavior for each container in <a href=\"http://eel.is/c++draft/container.requirements#tab:containers.container.requirements\" rel=\"nofollow noreferrer\">[container.requirements.general]</a> which require that:</p>\n<ul>\n<li><code>a.begin()</code> yields an <code>iterator</code> (or <code>const_iterator</code> for constant <code>a</code>)</li>\n<li><code>a.end()</code> yields an <code>iterator</code> (or <code>const_iterator</code> for constant <code>a</code>)</li>\n<li>...</li>\n</ul>\n<p>The requirement for the implementations are that those types (<code>C::iterator</code> and <code>C::const_iterator</code>) exist and that those functions yield those types. The requirement is <strong>not</strong> specifically that those four overloads must exist (nor that the two iterator types must be different). The requirement is just the behavior.</p>\n<p>The following would be a perfectly conforming implementation for <code>set</code>:</p>\n<pre><code>template &lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt;\nclass set {\npublic:\n    struct iterator { ... };\n    using const_iterator = iterator;\n\n    iterator begin() const { ... };\n    iterator end() const { ... };\n\n    // other stuff\n};    \n</code></pre>\n<p>With this implementation, all the requirements are satisfied. So it's sufficient. Indeed, this is how libstdc++ implements it - the two iterators are the <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_set.h#L138-L139\" rel=\"nofollow noreferrer\">same type</a> and there is just one <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_set.h#L334-L336\" rel=\"nofollow noreferrer\"><code>begin()</code></a> and just one <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_set.h#L343-L345\" rel=\"nofollow noreferrer\"><code>end()</code></a>. </p>\n<blockquote>\n<p id=\"so_46457311_46458872_1\">Why introduce those extra overloads?</p>\n</blockquote>\n<p>There aren't extra overloads. Or at least, there don't have to be. It's up to to the implementer. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46458872", "Score": "1", "CreationDate": "2017-09-27T23:54:29.190", "LastActivityDate": "2017-09-27T23:54:29.190"}, "bq_ids": {"n4659": {"so_46457311_46458872_0": {"section_id": 7851, "quality": 0.9310344827586207, "length": 27}}}, "46458252": {"ParentId": "46457311", "CommentCount": "0", "Body": "<p>While I can't say for certain, consistency (see comments by @yurikilochek) seems reasonable to me. \"Can you give an example of general code that will fail if those non const iterators methods are not present?\" The following code does not compile with libstdc++ (but does compile under Visual Studio) because set does not have the non-const methods. I acknowledge this is not code someone would write in the course of a day that is going well.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\ntemplate &lt;class C&gt; //C is some container\nvoid f(C&amp; c)\n{\n    typedef typename C::iterator iter;\n    typedef iter (C::*fn)(); // note non-const method\n\n    fn begin = &amp;C::begin; // will fail with set if begin() is const only\n    fn end = &amp;C::end;\n\n    for (iter i = (c.*begin)(), e = (c.*end)(); i != e; ++i)\n        std::cout &lt;&lt; *i &lt;&lt; ' ';\n    std::cout &lt;&lt; '\\n';\n}\n\nint\nmain()\n{\n    std::vector&lt;int&gt; v;\n    std::set&lt;int&gt; s;\n\n    f(v);\n    f(s);\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "453436", "PostTypeId": "2", "Id": "46458252", "Score": "-1", "CreationDate": "2017-09-27T22:36:51.983", "LastActivityDate": "2017-09-27T22:36:51.983"}});