post_cb({"bq_ids": {"n4140": {"so_5367674_5367826_1": {"length": 19, "quality": 0.95, "section_id": 6103}, "so_5367674_5367826_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 7181}, "so_5367674_5367792_2": {"length": 6, "quality": 1.0, "section_id": 6103}}, "n3337": {"so_5367674_5367826_1": {"length": 19, "quality": 0.95, "section_id": 5869}, "so_5367674_5367826_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6925}, "so_5367674_5367792_2": {"length": 6, "quality": 1.0, "section_id": 5869}}, "n4659": {"so_5367674_5367826_1": {"length": 17, "quality": 0.85, "section_id": 7600}, "so_5367674_5367792_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7600}}}, "5367792": {"Id": "5367792", "PostTypeId": "2", "Body": "<p>It looks like the class was missing the single parameter non-placement delete operator. As can be seen on:</p>\n<p><a href=\"http://oorexx.svn.sourceforge.net/viewvc/oorexx/main/trunk/interpreter/memory/RexxMemory.hpp?r1=6219&amp;r2=6218&amp;pathrev=6219\" rel=\"nofollow\">http://oorexx.svn.sourceforge.net/viewvc/oorexx/main/trunk/interpreter/memory/RexxMemory.hpp?r1=6219&amp;r2=6218&amp;pathrev=6219</a></p>\n<p>and in more details in the bug report:</p>\n<p><a href=\"http://sourceforge.net/tracker/?func=detail&amp;aid=2991134&amp;group_id=119701&amp;atid=684730\" rel=\"nofollow\">http://sourceforge.net/tracker/?func=detail&amp;aid=2991134&amp;group_id=119701&amp;atid=684730</a></p>\n<blockquote>\n<p id=\"so_5367674_5367792_0\">C++ PATCH for c++/34158 (template\n  placement delete)</p>\n<ul>\n<li>From: Jason Merrill </li>\n<li>To: gcc-patches List </li>\n<li>Date: Tue, 10 Nov 2009 13:31:17 -0500</li>\n<li><p id=\"so_5367674_5367792_1\">Subject: C++ PATCH for c++/34158 (template placement delete)</p></li>\n<li><p id=\"so_5367674_5367792_2\">/* \"If the lookup finds the two-parameter form of a usual\n  deallocation</p></li>\n<li>function (3.7.4.2) and that function, considered as a placement</li>\n<li>deallocation function, would have been selected as a match for the</li>\n<li>allocation function, the program is ill-formed.\" */</li>\n<li>if (non_placement_deallocation_fn_p (fn))</li>\n<li>{</li>\n<li>error (\"non-placement deallocation function %q+D\", fn);</li>\n<li>error (\"selected for placement delete\");</li>\n<li>}</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2011-03-20T10:00:34.793", "CommentCount": "0", "CreationDate": "2011-03-20T10:00:34.793", "ParentId": "5367674", "Score": "1", "OwnerUserId": "136285"}, "5367826": {"Id": "5367826", "PostTypeId": "2", "Body": "<p>I <strong>think</strong> that the problem comes from this wording in the spec:</p>\n<blockquote>\n<p id=\"so_5367674_5367826_0\">If class T does not declare such an operator delete but does declare a member deallocation function named operator delete with exactly two parameters, the second of which has type std::size_t (18.1), then this function is a usual deallocation function</p>\n</blockquote>\n<p>This would mean that if you tried to declare a pair <code>operator new</code> and <code>operator delete</code> that took a <code>size_t</code> as the second parameter, the compiler would think that your <code>operator delete</code> with this signature:</p>\n<pre><code>void operator delete (void* memory, size_t arg)\n</code></pre>\n<p>was the standard (non-placement) deallocator rather than the placement deallocator that's supposed to match <code>operator new(void*, size_t)</code>.</p>\n<p>What's odd about this is that nowhere in the spec does it say that this should cause a compiler error.  In fact, the spec just says that if you have this error, then if the custom <code>new</code> throws an exception then the memory just won't get cleaned up.  If anyone knows why <code>g++</code> is reporting this as an error, I'd love to know why (<em>especially</em> if I'm wrong and this really is supposed to be illegal).</p>\n<p><strong>EDIT</strong>: Ah!  The problem seems to be from C++0x.  According to the most recent draft of the new standard, \u00a73.5.4/20:</p>\n<blockquote>\n<p id=\"so_5367674_5367826_1\">If the lookup finds the two-parameter form of a usual deallocation function (3.7.4.2) and that function, considered as a placement deallocation function, would have been selected as a match for the allocation function, the program is ill-formed.</p>\n</blockquote>\n<p>It specifically lists doing this as an example of what would cause the breakage.  The fact that this is new in C++0x would explain why the error only started popping up in the newest version of <code>g++</code>.</p>\n", "LastEditorUserId": "501557", "LastActivityDate": "2011-03-20T10:14:36.943", "Score": "5", "CreationDate": "2011-03-20T10:07:58.920", "ParentId": "5367674", "CommentCount": "0", "OwnerUserId": "501557", "LastEditDate": "2011-03-20T10:14:36.943"}, "5367674": {"ViewCount": "2241", "Body": "<p>I am getting the following error while compiling the serna-free package:</p>\n<pre><code>build/buildd-serna-free_4.3.0.20110221-2-i386-pAsDoD/serna-free-4.3.0.20110221/\n  sfworks/common/RefCntStorage.h:76:10:\nerror: non-placement deallocation function 'static void\nStringPrivate::RefCntData&lt;E&gt;::operator\ndelete(void*,StringPrivate::size_type) [with E = QChar,\nStringPrivate::size_type = unsigned int]'\n/build/buildd-serna-free_4.3.0.20110221-2-i386-pAsDoD/serna-free-4.3.0.20110221/\n   sfworks/common/RefCntStorage.h:135:9:\nerror: selected for placement delete\n</code></pre>\n<p>Code looks like:</p>\n<pre><code>void operator delete(void* p, size_type)\n{\n    ::operator delete(p);\n}\n</code></pre>\n", "AcceptedAnswerId": "5367826", "Title": "What does the error \"non-placement deallocation function\"?", "CreationDate": "2011-03-20T09:27:15.747", "Id": "5367674", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-03-20T10:03:39.613", "LastEditorUserId": "15168", "LastActivityDate": "2011-03-20T10:14:36.943", "Score": "3", "OwnerUserId": "136285", "Tags": "<c++>", "AnswerCount": "2"}});