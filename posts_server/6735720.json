post_cb({"bq_ids": {"n4140": {"so_6735720_6735859_1": {"length": 20, "quality": 1.0, "section_id": 243}, "so_6735720_6735859_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 235}}, "n3337": {"so_6735720_6735859_1": {"length": 20, "quality": 1.0, "section_id": 235}, "so_6735720_6735859_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 228}}, "n4659": {"so_6735720_6735859_1": {"length": 18, "quality": 0.9, "section_id": 250}, "so_6735720_6735859_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 245}}}, "6735859": {"Id": "6735859", "PostTypeId": "2", "Body": "<p>From n3290, 14.7.1 Implicit instantiation [temp.inst]</p>\n<blockquote>\n<p id=\"so_6735720_6735859_0\">2 Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n<p>There are similar rules in paragraph 1 for class template specializations. Notice that the Standard speaks in terms of specialization because a specialization is implicitly declared when a template is used an no user-provided specialization is here, at least for function templates (paragraph 8).</p>\n<p>Combined with paragraph 10,</p>\n<blockquote>\n<p id=\"so_6735720_6735859_1\">10 An implementation shall not implicitly instantiate a function\n  template, a member template, a non-virtual member function, a member\n  class, or a static data member of a class template that does not\n  require instantiation.</p>\n</blockquote>\n<p>I think the rule of thumb is: as soon as an object/class member/function is needed or to make the program otherwise work (speaking informally), the template is implicitly instantiated but <em>no sooner</em>. This include taking the address of a function.</p>\n<p>As to the question you linked, some uses of <code>reinterpret_cast</code> may make the program non-conformant, by which time it's irrelevant to mention instantiations -- <a href=\"https://stackoverflow.com/questions/6734492/c-callback-to-function-template-explicitly-instantiate-template/6735302#6735302\">I invite you to see my answer there</a>&lt;<b></b>/shameless&gt;.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-18T16:13:10.757", "Score": "2", "CreationDate": "2011-07-18T16:07:02.667", "ParentId": "6735720", "CommentCount": "4", "LastEditDate": "2017-05-23T10:31:02.257", "OwnerUserId": "726300"}, "6735720": {"ViewCount": "1105", "Body": "<p>In answering <a href=\"https://stackoverflow.com/questions/6734492/c-callback-to-function-template-explicitly-instantiate-template\">this</a> question, I came across this difference in behaviour with respect to template instantiation.</p>\n<p>Initially there is a function template</p>\n<pre><code>template &lt;typename T&gt; void my_callback(void* data) { \u2026 }\n</code></pre>\n<p>Now something requires the address of this - specifically a <code>void*</code>, so the obvious approach is</p>\n<pre><code>bar(reinterpret_cast&lt;void*&gt;(&amp;my_callback&lt;int&gt;));\n</code></pre>\n<p>However, with compiler versions pre gcc 4.5, this fails with a not-enough context... error. Fine - so the fix is to \"cast\" first - which forces instantiation, i.e:</p>\n<pre><code>void (*callback)(void*) = my_callback&lt;int&gt;;\nbar(reinterpret_cast&lt;void*&gt;(callback));\n</code></pre>\n<p>This works fine. </p>\n<p>Now the second scenario, rather than being a free function, it's a static member of a class template, i.e.</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo\n{\n  static void my_callback(void* data) {\n    T&amp; x = *static_cast&lt;T*&gt;(data);\n    std:: cout &lt;&lt; \"Call[T] with \" &lt;&lt; x &lt;&lt; std::endl;\n  }\n};\n</code></pre>\n<p>Now, the original <code>reinterpret_cast</code> works fine.</p>\n<pre><code>bar(reinterpret_cast&lt;void*&gt;(&amp;foo&lt;int&gt;::my_callback));\n</code></pre>\n<p>So my question is - why this apparent difference in behaviour?</p>\n", "AcceptedAnswerId": "6735859", "Title": "What are the rules around instantiation of template types (class/function) when taking an address?", "CreationDate": "2011-07-18T15:56:00.683", "Id": "6735720", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:33.150", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-18T16:13:10.757", "Score": "6", "OwnerUserId": "266198", "Tags": "<c++><templates>", "AnswerCount": "1"}});