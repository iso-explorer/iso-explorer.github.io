post_cb({"45524824": {"CommentCount": "0", "AcceptedAnswerId": "45525034", "CreationDate": "2017-08-05T17:46:09.707", "LastActivityDate": "2017-08-06T14:33:30.713", "PostTypeId": "1", "ViewCount": "79", "FavoriteCount": "0", "Title": "template<> for the explicit specialization of a member enumeration", "Id": "45524824", "Score": "4", "Body": "<p>According to 17.7.3 [temp.expl.spec] paragraph 5 (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">N4659</a>),</p>\n<blockquote>\n<p id=\"so_45524824_45524824_0\">... Members of an explicitly specialized class template are defined in the same manner as members of normal classes, and not using the <code>template&lt;&gt;</code> syntax. The same is true when defining a member of an explicitly specialized member class. <strong>However, <code>template&lt;&gt;</code> is used in defining a member of an explicitly specialized member class template that is specialized as a class template.</strong></p>\n</blockquote>\n<p>The explicit specialization of <code>E</code> definitely does not belong to the bold case, and it still needs <code>template&lt;&gt;</code>. Why is that?</p>\n<pre><code>template&lt;class T&gt; struct A {\n    enum E : T;\n};\n\ntemplate&lt;&gt; enum A&lt;int&gt;::E : int { eint };\n</code></pre>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "5645940", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45524824_45525034_2": {"section_id": 48, "quality": 1.0, "length": 4}, "so_45524824_45524824_0": {"section_id": 267, "quality": 0.9722222222222222, "length": 35}, "so_45524824_45525034_4": {"section_id": 263, "quality": 0.75, "length": 6}}, "n3337": {"so_45524824_45525034_2": {"section_id": 43, "quality": 1.0, "length": 4}, "so_45524824_45524824_0": {"section_id": 258, "quality": 0.9722222222222222, "length": 35}, "so_45524824_45525034_4": {"section_id": 254, "quality": 0.75, "length": 6}}, "n4659": {"so_45524824_45525034_2": {"section_id": 49, "quality": 1.0, "length": 4}, "so_45524824_45524824_0": {"section_id": 274, "quality": 0.9722222222222222, "length": 35}, "so_45524824_45525034_4": {"section_id": 270, "quality": 0.75, "length": 6}}}, "45525034": {"ParentId": "45524824", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>This paragraph is related to members of an explicitly specialized class template, but you have not explicitly specialized the class template.  This is an example of the case it is talking about:</p>\n<pre><code>template&lt;class T&gt; struct A {\n    enum E : T;\n};\n\ntemplate&lt;&gt; struct A&lt;int&gt; {\n    enum E : int;\n};\n\nenum A&lt;int&gt;::E : int { eint }; // no template&lt;&gt; here\n</code></pre>\n<p>In your example code, you have explicitly specialized a member of the primary template, which does require using <code>template&lt;&gt;</code>, as specified in the first paragraph.</p>\n<blockquote>\n<p id=\"so_45524824_45525034_0\">1 An explicit specialization of any of the following:</p>\n<p id=\"so_45524824_45525034_1\">...</p>\n<p id=\"so_45524824_45525034_2\">(1.7) \u2014 member enumeration of a class template</p>\n<p id=\"so_45524824_45525034_3\">...</p>\n<p id=\"so_45524824_45525034_4\">can be declared by a declaration introduced by template&lt;&gt;; that is:\n  explicit-specialization:\n  template &lt; &gt; declaration</p>\n</blockquote>\n<p>The underlying principle behind paragraph 5 is that once you've explicitly specialized a template, it is no longer a template, and you work with the specialization just like you would any other non-template entity.</p>\n", "OwnerUserId": "951890", "LastEditorUserId": "951890", "LastEditDate": "2017-08-06T14:33:30.713", "Id": "45525034", "Score": "5", "CreationDate": "2017-08-05T18:10:20.360", "LastActivityDate": "2017-08-06T14:33:30.713"}});