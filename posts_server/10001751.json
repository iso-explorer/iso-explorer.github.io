post_cb({"10001751": {"CommentCount": "3", "AcceptedAnswerId": "10001898", "PostTypeId": "1", "LastEditorUserId": "365496", "CreationDate": "2012-04-03T21:34:18.677", "LastActivityDate": "2013-03-20T16:10:08.610", "LastEditDate": "2013-03-20T16:10:08.610", "ViewCount": "2058", "FavoriteCount": "2", "Title": "std::thread with movable, non-copyable argument", "Id": "10001751", "Score": "9", "Body": "<p>The following program doesn't build in VS11 beta, gcc 4.5, or clang 3.1</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;memory&gt;\n\nint main() {\n    std::unique_ptr&lt;int&gt; p;\n    std::thread th([](std::unique_ptr&lt;int&gt;) {\n\n    },std::move(p));\n    th.join();\n}\n</code></pre>\n<p>This is because the argument type is not copyable, but the implementation attempts to copy it.</p>\n<p>As far as I can tell, this program is well formed and should work. The requirements for std::thread seem to imply that movable, non-copyable arguments should work here. Specifically it says that the callable object and each argument shall satisfy the MoveConstructible requirements, and that <code>INVOKE(DECAY_COPY(std::forward&lt;F&gt;(f)),DECAY_COPY(std::forward&lt;Args&gt;(args))...)</code> shall be a valid expression.</p>\n<p>In this case I think expression works out to something like:</p>\n<pre><code>template &lt;class T&gt; typename std::decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)\n{ return std::forward&lt;T&gt;(v); }\n\nstd::unique_ptr&lt;int&gt; p;\nauto f = [](std::unique_ptr&lt;int&gt;) {};\n\ndecay_copy(f)(decay_copy(std::move(p)));\n</code></pre>\n<p>And I don't think this is supposed to involve a copy of <code>p</code>. gcc at least can compile this expression, though VS11 does not.</p>\n<ol>\n<li>Am I wrong about the requirements and the arguments must be copyable?</li>\n<li>Does the standard leave any leeway on this issue for implementations to copy arguments?</li>\n<li>Or are the implementation I tried non-conforming?</li>\n</ol>\n", "Tags": "<c++><multithreading><c++11><rvalue-reference>", "OwnerUserId": "365496", "AnswerCount": "2"}, "10002272": {"ParentId": "10001751", "CommentCount": "0", "Body": "<p>As an alternative, and as the standard <code>std::thread</code> idiom, you can pass a reference wrapper:</p>\n<pre><code>int p;\nstd::thread([](int &amp; x) { /* ... */ }, std::ref(p));\n</code></pre>\n<p>This creates an object of type <code>std::reference_wrapper&lt;int&gt;</code>, which has value semantics and wraps a reference to an <code>int</code> (i.e. copying the wrapper aliases the reference).</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "10002272", "Score": "3", "CreationDate": "2012-04-03T22:19:32.197", "LastActivityDate": "2012-04-03T22:19:32.197"}, "10001898": {"ParentId": "10001751", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From 30.3.1.2, paragraph 3 and 4 of N3337:</p>\n<blockquote>\n<p id=\"so_10001751_10001898_0\"><strong><code>template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);</code></strong></p>\n<p id=\"so_10001751_10001898_1\"><em>Requires</em>: <strong><code>F</code></strong> and each <strong><code>Ti</code></strong> in <strong><code>Args</code></strong> shall satisfy the <code>MoveConstructible</code> requirements. <code>INVOKE (DECAY_-COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> (20.8.2) shall be a valid expression.</p>\n<p id=\"so_10001751_10001898_2\"><em>Effects</em>: Constructs an object of type thread. The new thread of execution executes <code>INVOKE (DECAY_-COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> with the calls to <code>DECAY_COPY</code> being evaluated in the constructing thread. Any return value from this invocation is ignored. [ Note: This implies that any exceptions not thrown from the invocation of the copy of <strong><code>f</code></strong> will be thrown in the constructing thread, not the new thread. \u2014end note ] If the invocation of <code>INVOKE (DECAY_COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> terminates with an uncaught exception, std::terminate shall be called.</p>\n</blockquote>\n<p>So yes, this should work. If it doesn't, then that's a bug in your implementation.</p>\n<p>Do note that any parameter movement/copying will happen on the new thread. You're passing references to another thread, so you need to make sure that they still exist until that thread starts.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-04-03T22:31:14.040", "Id": "10001898", "Score": "14", "CreationDate": "2012-04-03T21:47:10.803", "LastActivityDate": "2012-04-03T22:31:14.040"}, "bq_ids": {"n4140": {"so_10001751_10001898_2": {"section_id": 2710, "quality": 0.6923076923076923, "length": 36}, "so_10001751_10001898_1": {"section_id": 2708, "quality": 0.5714285714285714, "length": 8}, "so_10001751_10001898_0": {"section_id": 2707, "quality": 1.0, "length": 8}}, "n3337": {"so_10001751_10001898_2": {"section_id": 2671, "quality": 0.6923076923076923, "length": 36}, "so_10001751_10001898_1": {"section_id": 2670, "quality": 0.5714285714285714, "length": 8}, "so_10001751_10001898_0": {"section_id": 2669, "quality": 1.0, "length": 8}}, "n4659": {"so_10001751_10001898_2": {"section_id": 3450, "quality": 0.6730769230769231, "length": 35}, "so_10001751_10001898_0": {"section_id": 3447, "quality": 1.0, "length": 8}}}});