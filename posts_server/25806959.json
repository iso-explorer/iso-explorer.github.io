post_cb({"25806959": {"CommentCount": "2", "ViewCount": "59", "PostTypeId": "1", "LastEditorUserId": "339249", "CreationDate": "2014-09-12T11:11:26.523", "LastActivityDate": "2014-09-15T10:08:28.367", "Title": "Can std::scoped_allocator_adaptor force allocator to be default constructible?", "LastEditDate": "2014-09-15T10:08:28.367", "Id": "25806959", "Score": "0", "Body": "<p>Let's start with standard requirements of an allocator type:</p>\n<blockquote>\n<p id=\"so_25806959_25806959_0\">17.6.3.5.4-5</p>\n<p id=\"so_25806959_25806959_1\">An allocator type X shall satisfy the requirements of <strong>CopyConstructible</strong> (17.6.3.1). The X::pointer, X::const_pointer, X::void_pointer, and X::const_void_pointer types shall satisfy the requirements of NullablePointer(17.6.3.3). No constructor, comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception. X::pointer and X::const_pointer shall also satisfy the requirements for a random access iterator (24.2).</p>\n</blockquote>\n<pre><code>template &lt;class Tp&gt;\nstruct SimpleAllocator {\n  typedef Tp value_type;\n  SimpleAllocator(ctor args);\n  template &lt;class T&gt; SimpleAllocator(const SimpleAllocator&lt;T&gt;&amp; other);\n\n  Tp* allocate(std::size_t n);\n  void deallocate(Tp* p, std::size_t n);\n};\n\ntemplate &lt;class T, class U&gt;\nbool operator==(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);\ntemplate &lt;class T, class U&gt;\nbool operator!=(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);\n</code></pre>\n<p>And what does the standard say about <code>scoped_allocator_adaptor</code>:</p>\n<blockquote>\n<p id=\"so_25806959_25806959_2\">20.13.3.1</p>\n<p id=\"so_25806959_25806959_3\">scoped_allocator_adaptor();</p>\n<p id=\"so_25806959_25806959_4\">Effects:\n  value-initializes the OuterAlloc base class and the inner allocator object.</p>\n</blockquote>\n<p>I am using my allocator in trivial way.</p>\n<pre><code>template&lt;typename T&gt;\nusing sa_t =\nstd::scoped_allocator_adaptor&lt;SimpleAllocator&lt;T&gt;&gt; ;\n\nint main()\n{\n  std::vector&lt;int, sa_t&lt;int&gt;&gt; xxx{ sa_t{ SimpleAllocator{Arg{}} } };\n  return 0;\n}\n</code></pre>\n<p>Question is:</p>\n<p>Does this mean that scoped_allocator_adaptor implies that a minimal allocator interface is not enough and empty-state allocator has to be provided?</p>\n<p>Am I allowed to create an allocator that can be default constructed, but which can throw on any requests to allocate/deallocate memory? In other words: is the scoped_allocator_adaptor clients (I am looking at you, standard containers) forced to ignore such default constructed adaptor?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "339249", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_25806959_25806959_4": {"section_id": 4861, "quality": 0.875, "length": 7}, "so_25806959_25806959_1": {"section_id": 6292, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_25806959_25806959_4": {"section_id": 4656, "quality": 0.875, "length": 7}, "so_25806959_25806959_1": {"section_id": 6052, "quality": 0.7567567567567568, "length": 28}}, "n4659": {"so_25806959_25806959_4": {"section_id": 5894, "quality": 0.75, "length": 6}, "so_25806959_25806959_1": {"section_id": 7800, "quality": 0.8648648648648649, "length": 32}}}});