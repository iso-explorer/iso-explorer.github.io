post_cb({"18456735": {"ParentId": "18456695", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Yes. Any unqualified reference to a member from within its class is entirely equivalent to</p>\n<pre><code>this-&gt;member\n</code></pre>\n<p>or</p>\n<pre><code>this-&gt;member(...)\n</code></pre>\n<p>as appropriate, and therefore despatched virtually if it's a virtual function. The standard doesn't make any exceptions about calls from constructors or destructors. It does make an exception about which function is called, but not about how that is accomplished.</p>\n<p><strong>EDIT</strong></p>\n<p>The actual VFT mechanism used to implement this exception is described in [1]. As Lippman points out, simply erasing virtual despath is not an acceptable technique, as any indirect virtual function call called by the called virtual function is also subject to the same exception ('directly or indirectly' clause).</p>\n<pre><code>[1] Lippman, Stanley B., *Inside the C++ Object Model,* Addison Wesley 1996, pp179ff.\n</code></pre>\n", "OwnerUserId": "207421", "LastEditorUserId": "207421", "LastEditDate": "2013-08-27T05:23:01.347", "Id": "18456735", "Score": "-3", "CreationDate": "2013-08-27T04:04:43.717", "LastActivityDate": "2013-08-27T05:23:01.347"}, "18457039": {"ParentId": "18456695", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>\u00a712.7.4:</p>\n<blockquote>\n<p id=\"so_18456695_18457039_0\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).\n  When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class.</p>\n</blockquote>\n<p>\u00a710.4.6:</p>\n<blockquote>\n<p id=\"so_18456695_18457039_1\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n<p>Virtual dispatch occurs and the function called is the last override in the class chain until the one being constructed. If the function was never implemented, the behavior is undefined.</p>\n<pre><code>// well-defined behavior, calls A::f()\nstruct A\n{\n    A() { f(); }\n    virtual void f();\n};\n\nstruct B\n{\n    virtual void f();\n};\n\n// well-defined behavior, calls B::f()\nstruct C : public B\n{\n    C() { f(); }\n};\n\n// well-defined behavior, calls D::f()\nstruct D : public B\n{\n    D() { f(); }\n    virtual void f(); \n};\n\n// calling a pure virtual method from a constructor: undefined behavior\n// (even if D::f() is implemented at a later point)\nstruct D\n{\n    D() { f(); }\n    virtual void f() = 0;\n};\n\n// specifying f() as pure virtual even if it has an implementation in B,\n// then calling it from the constructor: undefined behavior\nstruct E : public B\n{\n    E() { f(); }\n    virtual void f() = 0;\n};\n</code></pre>\n", "OwnerUserId": "251153", "LastEditorUserId": "251153", "LastEditDate": "2013-08-27T04:56:50.527", "Id": "18457039", "Score": "0", "CreationDate": "2013-08-27T04:37:38.970", "LastActivityDate": "2013-08-27T04:56:50.527"}, "18456695": {"CommentCount": "24", "ViewCount": "497", "PostTypeId": "1", "LastEditorUserId": "2068573", "CreationDate": "2013-08-27T03:59:24.037", "LastActivityDate": "2013-08-28T00:31:43.340", "Title": "If a virtual function is called from a constructor/destructor without qualification, does virtual dispatch occur?", "AcceptedAnswerId": "18456764", "LastEditDate": "2013-08-27T04:29:52.543", "Id": "18456695", "Score": "4", "Body": "<pre><code>struct A\n{\n    virtual ~A() { f(); }\n\n    virtual void f() {}\n};\n</code></pre>\n<p>I've edited my question to be more specific..</p>\n<p>In this code sample, MAY the call <code>f()</code> use virtual dispatch, or is it guaranteed equivalent to <code>A::f()</code>?</p>\n<p>Could you provide relevant section from C++ standard? Thanks.</p>\n", "Tags": "<c++>", "OwnerUserId": "2068573", "AnswerCount": "4"}, "18457024": {"ParentId": "18456695", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard does not require that the call is performed dynamically or statically. Conceptually it is dynamic, and all of the quotes regarding the call of a virtual function while an object is being constructed or destructed contain the text <em>directly or indirectly</em>. That is important, as it entails that whether the call is direct to the function or not the behavior should be the same. Now consider:</p>\n<pre><code>struct A {\n   A() { f(); }\n   void f() { g(); }\n   virtual void g() {};\n};\n</code></pre>\n<p>And assume that code is not visible and all the usual caveats so that the functions are not inlined. The definition of <code>A::f()</code> which might be in a different translation unit, does not know whether it is called from the constructor or destructor or neither of them. It does not know if the complete object is of type <code>A</code> or <code>Z</code> for any derived type <code>Z</code>, so it <em>must</em> use dynamic dispatch.</p>\n<p>Now, the <em>as-if</em> rule means that the compiler has some leeway to optimize, and it can decide that <em>within the body of the constructor/destructor</em> (or any function inlined into it) the final overrider is known and it can thus avoid dynamic dispatch and call the <em>known</em> final overrider directly. This works even for pure virtual functions, since in that case, the behavior is <em>undefined</em>, and thus there are no guarantees of behavior --so any transformation by the compiler will be <em>valid</em> in that case.</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-08-27T04:43:51.610", "Id": "18457024", "Score": "2", "CreationDate": "2013-08-27T04:36:47.767", "LastActivityDate": "2013-08-27T04:43:51.610"}, "18456764": {"ParentId": "18456695", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Within a constructor or destructor, the sub-class object has either not yet been constructed, or has already been destroyed. As a result, virtual dispatch does not lead to the derived-class version being used, and instead the base-class version is called.</p>\n<p>From the standard, <code>[class.cdtor]/4</code>:</p>\n<blockquote>\n<p id=\"so_18456695_18456764_0\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not the one overriding it in a more-derived class. If the virtual function call uses an explicit class member access (5.2.5) and the object expression refers to the complete object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>An example of this is given:</p>\n<pre><code>struct V {\n   virtual void f();\n   virtual void g();\n};\nstruct A : virtual V {\n   virtual void f();\n};\nstruct B : virtual V {\n   virtual void g();\n   B(V*, A*);\n};\nstruct D : A, B {\n   virtual void f();\n   virtual void g();\n   D() : B((A*)this, this) { }\n};\nB::B(V* v, A* a) {\n    f(); // calls V::f, not A::f\n    g(); // calls B::g, not D::g\n    v-&gt;g(); // v is base of B, the call is well-defined, calls B::g\n    a-&gt;f(); // undefined behavior, a\u2019s type not a base of B\n}\n</code></pre>\n<p>Also note that this can be unsafe if the function that is called is pure virtual, from <code>[class.abstract]/6</code>:</p>\n<blockquote>\n<p id=\"so_18456695_18456764_1\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n", "OwnerUserId": "485561", "LastEditorUserId": "485561", "LastEditDate": "2013-08-28T00:31:43.340", "Id": "18456764", "Score": "7", "CreationDate": "2013-08-27T04:07:40.857", "LastActivityDate": "2013-08-28T00:31:43.340"}, "bq_ids": {"n4140": {"so_18456695_18457039_1": {"section_id": 7023, "quality": 0.9615384615384616, "length": 25}, "so_18456695_18457039_0": {"section_id": 447, "quality": 0.9574468085106383, "length": 45}, "so_18456695_18456764_0": {"section_id": 447, "quality": 0.9594594594594594, "length": 71}, "so_18456695_18456764_1": {"section_id": 7023, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_18456695_18457039_1": {"section_id": 6769, "quality": 0.9615384615384616, "length": 25}, "so_18456695_18457039_0": {"section_id": 438, "quality": 0.9574468085106383, "length": 45}, "so_18456695_18456764_0": {"section_id": 438, "quality": 0.9594594594594594, "length": 71}, "so_18456695_18456764_1": {"section_id": 6769, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_18456695_18457039_1": {"section_id": 8520, "quality": 0.9615384615384616, "length": 25}, "so_18456695_18457039_0": {"section_id": 469, "quality": 0.9574468085106383, "length": 45}, "so_18456695_18456764_0": {"section_id": 469, "quality": 0.9594594594594594, "length": 71}, "so_18456695_18456764_1": {"section_id": 8520, "quality": 0.9615384615384616, "length": 25}}}});