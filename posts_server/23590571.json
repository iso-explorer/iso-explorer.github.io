post_cb({"23590571": {"CommentCount": "2", "CreationDate": "2014-05-11T08:32:19.450", "PostTypeId": "1", "AcceptedAnswerId": "23590638", "LastEditorUserId": "1136700", "LastActivityDate": "2014-05-11T08:53:07.387", "LastEditDate": "2014-05-11T08:41:52.067", "ViewCount": "77", "FavoriteCount": "0", "Title": "what's the difference between those two regarding bit operations?", "Id": "23590571", "Score": "1", "Body": "<p>say, a is an unsigned 32 bit integer.</p>\n<pre><code>a &lt;&lt; 24\n(a &amp; 0xff)&lt;&lt;24\n</code></pre>\n<p>Similiar one, any difference for this two</p>\n<pre><code>a &gt;&gt; 16\n(a &gt;&gt; 16) &amp; 0xff\n</code></pre>\n", "Tags": "<c++><c><visual-c++>", "OwnerUserId": "1136700", "AnswerCount": "3"}, "23590715": {"ParentId": "23590571", "CommentCount": "1", "Body": "<pre><code>a &lt;&lt; 24\n(a &amp; 0xff)&lt;&lt;24\n</code></pre>\n<p>no difference between results, but the  latter may avoid influencing overflow flag of register ?</p>\n", "OwnerUserId": "3624923", "PostTypeId": "2", "Id": "23590715", "Score": "0", "CreationDate": "2014-05-11T08:53:07.387", "LastActivityDate": "2014-05-11T08:53:07.387"}, "23590638": {"ParentId": "23590571", "LastEditDate": "2014-05-11T08:48:30.503", "CommentCount": "3", "CreationDate": "2014-05-11T08:41:49.447", "OwnerUserId": "1187415", "LastEditorUserId": "1187415", "PostTypeId": "2", "Id": "23590638", "Score": "4", "Body": "<p>Your first example:</p>\n<pre><code>a &lt;&lt; 24\n(a &amp; 0xff)&lt;&lt;24\n</code></pre>\n<p>In the case of a 32-bit unsigned integer, there is no difference in the result.\nFrom the C standard (6.5.7 Bitwise shift operators):</p>\n<blockquote>\n<p id=\"so_23590571_23590638_0\">The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated\n  bits are filled with zeros. If E1 has an unsigned type, the value of\n  the result is E1 \u00d7 2<sup>E2</sup>, reduced modulo one more than the maximum value\n  representable in the result type.\n  (...)</p>\n</blockquote>\n<p>Your second example</p>\n<pre><code>a &gt;&gt; 16\n(a &gt;&gt; 16) &amp; 0xff\n</code></pre>\n<p>The seconds line truncates the result to the range 0 .. 255, while the first does not.\nIf you meant the difference between</p>\n<pre><code>a &gt;&gt; 16\n(a &gt;&gt; 16) &amp; 0xffff\n</code></pre>\n<p>then there is again no difference for unsigned 32-bit integers:</p>\n<blockquote>\n<p id=\"so_23590571_23590638_1\">The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has\n  an unsigned type or if E1 has a signed type and a nonnegative value,\n  the value of the result is the integral part of the quotient of E1 /\n  2<sup>E2</sup>.\n  (...)</p>\n</blockquote>\n<p>Note that \"unsigned\" is important here. For signed integers, the behaviour can\nbe different, implementation-defined, or undefined.</p>\n", "LastActivityDate": "2014-05-11T08:48:30.503"}, "bq_ids": {"n4140": {"so_23590571_23590638_0": {"section_id": 6147, "quality": 0.7916666666666666, "length": 19}, "so_23590571_23590638_1": {"section_id": 6148, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_23590571_23590638_0": {"section_id": 5910, "quality": 0.7916666666666666, "length": 19}, "so_23590571_23590638_1": {"section_id": 5911, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_23590571_23590638_0": {"section_id": 7643, "quality": 0.7916666666666666, "length": 19}, "so_23590571_23590638_1": {"section_id": 7644, "quality": 0.8235294117647058, "length": 14}}}, "23590671": {"ParentId": "23590571", "CommentCount": "0", "Body": "<p>Any difference for these two:</p>\n<pre><code>a &gt;&gt; 16\n(a &gt;&gt; 16) &amp; 0xff\n</code></pre>\n<p>Yes, you'll get different results for every <code>a &gt; 0x00FFFFFF</code>.</p>\n", "OwnerUserId": "1382251", "PostTypeId": "2", "Id": "23590671", "Score": "0", "CreationDate": "2014-05-11T08:46:46.337", "LastActivityDate": "2014-05-11T08:46:46.337"}});