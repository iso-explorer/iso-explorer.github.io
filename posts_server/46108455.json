post_cb({"46108455": {"CommentCount": "1", "ViewCount": "49", "PostTypeId": "1", "LastEditorUserId": "440558", "CreationDate": "2017-09-08T04:05:24.137", "LastActivityDate": "2017-09-08T04:23:36.863", "Title": "Where does the standard define the order of preference for binding of values to references?", "AcceptedAnswerId": "46108512", "LastEditDate": "2017-09-08T04:07:01.607", "Id": "46108455", "Score": "0", "Body": "<p>As it is explained <a href=\"http://codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/\" rel=\"nofollow noreferrer\">here</a>, values of different categories bind to references of different kinds according to the following order of preference:</p>\n<pre><code>struct s {};\n\nvoid f (      s&amp;);  // #1\nvoid f (const s&amp;);  // #2\nvoid f (      s&amp;&amp;); // #3\nvoid f (const s&amp;&amp;); // #4\n\nconst s g ();\ns x;\nconst s cx;\n\nf (s ()); // rvalue        #3, #4, #2\nf (g ()); // const rvalue  #4, #2\nf (x);    // lvalue        #1, #2\nf (cx);   // const lvalue  #2\n</code></pre>\n<p>Where in the standard is this order of preference described?</p>\n", "Tags": "<c++><c++11><reference><language-lawyer><value-categories>", "OwnerUserId": "8414561", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46108455_46108512_4": {"section_id": 639, "quality": 0.9130434782608695, "length": 21}, "so_46108455_46108512_0": {"section_id": 603, "quality": 0.8, "length": 8}, "so_46108455_46108512_2": {"section_id": 639, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_46108455_46108512_4": {"section_id": 629, "quality": 0.9130434782608695, "length": 21}, "so_46108455_46108512_0": {"section_id": 593, "quality": 0.8, "length": 8}, "so_46108455_46108512_2": {"section_id": 629, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_46108455_46108512_4": {"section_id": 667, "quality": 0.9130434782608695, "length": 21}, "so_46108455_46108512_0": {"section_id": 629, "quality": 0.8, "length": 8}, "so_46108455_46108512_2": {"section_id": 667, "quality": 0.9047619047619048, "length": 19}}}, "46108512": {"ParentId": "46108455", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-09-08T04:11:47.700", "Score": "2", "LastEditorUserId": "1670129", "LastEditDate": "2017-09-08T04:23:36.863", "Id": "46108512", "OwnerUserId": "1670129", "Body": "<blockquote>\n<p id=\"so_46108455_46108512_0\"><strong>[over.ics.rank]/3</strong> \n  - (3.1) Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if</p>\n<p id=\"so_46108455_46108512_1\">...</p>\n<p id=\"so_46108455_46108512_2\">(3.1.3) \u2014 <code>S1</code> and <code>S2</code> are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and <code>S1</code> binds an rvalue reference to an rvalue and <code>S2</code> binds an lvalue reference.</p>\n<p id=\"so_46108455_46108512_3\">...</p>\n<p id=\"so_46108455_46108512_4\">(3.1.6) \u2014 <code>S1</code> and <code>S2</code> are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by <code>S2</code> refers is more cv-qualified than the type to which the reference initialized by <code>S1</code> refers.</p>\n</blockquote>\n<p>By these rules, a function taking rvalue reference is preferred over one taking lvalue reference, and then a function taking non-const reference is preferred over one taking const. Considering only overloads that are viable, of course.</p>\n", "LastActivityDate": "2017-09-08T04:23:36.863"}});