post_cb({"27433544": {"CommentCount": "3", "ViewCount": "193", "PostTypeId": "1", "LastEditorUserId": "3290628", "CreationDate": "2014-12-11T22:23:28.073", "LastActivityDate": "2014-12-11T23:27:09.263", "Title": "using directive -- why so strange behaviour?", "FavoriteCount": "1", "LastEditDate": "2014-12-11T23:27:09.263", "Id": "27433544", "Score": "10", "Body": "<p>I have this sample code</p>\n<pre><code>namespace ns1\n{\n    void foo(int)\n    {\n    }\n}\n\nnamespace ns2\n{\n    void foo()\n    {\n    }\n    void bar()\n    {\n        using namespace ::ns1;\n        foo(42); // why compiler can't just call ns1::foo?\n    }\n}\n</code></pre>\n<p>And it doesn't compile with error:</p>\n<pre><code>prog.cpp:16:9: error: too many arguments to function \u2018void ns2::foo()\u2019\n</code></pre>\n<p>I found reason of this error in C++ 2003 standard:</p>\n<blockquote>\n<p id=\"so_27433544_27433544_0\">A using-directive specifies that the names in the nominated namespace\n  can be used in the scope in which the using-directive appears after\n  the using-directive. During unqualified name lookup (3.4.1), <strong>the names\n  appear as if they were declared in the nearest enclosing namespace\n  which contains both the using-directive and the nominated namespace.</strong>\n  [Note: in this context, \u201ccontains\u201d means \u201ccontains directly or\n  indirectly\u201d. ]</p>\n</blockquote>\n<p>Is any <strong>rationale</strong> for this strange rule? Why names from namespace ns1 can't directly appear in namespace ns2?</p>\n", "Tags": "<c++>", "OwnerUserId": "3290628", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27433544_27434098_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_27433544_27433544_0": {"section_id": 5510, "quality": 0.9444444444444444, "length": 34}, "so_27433544_27434098_1": {"section_id": 5511, "quality": 0.875, "length": 7}}, "n3337": {"so_27433544_27434098_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_27433544_27433544_0": {"section_id": 5296, "quality": 0.9444444444444444, "length": 34}, "so_27433544_27434098_1": {"section_id": 5297, "quality": 0.875, "length": 7}}, "n4659": {"so_27433544_27434098_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_27433544_27433544_0": {"section_id": 6945, "quality": 0.9444444444444444, "length": 34}, "so_27433544_27434098_1": {"section_id": 6946, "quality": 0.875, "length": 7}}}, "27433767": {"ParentId": "27433544", "CommentCount": "3", "Body": "<p>I believe this was/is done in an attempt at reducing conflicts and surprises. Names brought into scope by a <code>using</code> directive are visible, but anything that's directly contained in the local scope will take precedence over it.</p>\n<p>If you really want to call you function without a qualified ID, you make it visible with a <code>using</code> declaration instead:</p>\n<pre><code>namespace ns1 {\n    void foo(int) { }\n}\n\nnamespace ns2 {\n    void foo() { }\n    void bar() {\n        using ::ns1::foo;\n        foo(42); // No problem; calls ::ns1::foo.\n    }\n}\n</code></pre>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "27433767", "Score": "9", "CreationDate": "2014-12-11T22:39:41.880", "LastActivityDate": "2014-12-11T22:39:41.880"}, "27434098": {"ParentId": "27433544", "CommentCount": "3", "Body": "<p><code>ns1::foo</code> is being hidden by the declaration of <code>ns2::foo</code></p>\n<p>From N3337, <em>\u00a73.3.10/1</em> <strong>[basic.scope.hiding]</strong></p>\n<blockquote>\n<p id=\"so_27433544_27434098_0\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class (10.2).</p>\n</blockquote>\n<p>The section you've quoted (<em>\u00a77.3.4/2</em>) is immediately followed by</p>\n<blockquote>\n<p id=\"so_27433544_27434098_1\"><em>3</em> \u00a0 A <em>using-directive</em> does not add any members to the declarative region in which it appears. <em>[ Example:</em></p>\n<pre><code>    namespace A {\n      int i;\n      namespace B {\n        namespace C {\n          int i;\n        }\n        using namespace A::B::C;\n        void f1() {\n          i = 5; // OK, C::i visible in B and hides A::i\n        }\n      }\n      // more (irrelevant) stuff\n    }\n</code></pre>\n<p id=\"so_27433544_27434098_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>In your case, the <em>using-directive</em> is introducing the names in <code>ns1</code> to the common ancestor namespace of where it appears, and that of <code>ns1</code>, meaning the global namespace. It <strong>does not</strong> introduce them within <code>ns2</code>, so the declaration of <code>ns2::foo</code> hides that of <code>ns1::foo</code>.</p>\n<p>If you want <code>ns1::foo</code> to be found, use a using declaration instead.</p>\n<pre><code>void bar()\n{\n    using ::ns1::foo;\n    foo(42);\n}\n</code></pre>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "27434098", "Score": "2", "CreationDate": "2014-12-11T23:06:02.957", "LastActivityDate": "2014-12-11T23:06:02.957"}});