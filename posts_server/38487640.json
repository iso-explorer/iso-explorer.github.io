post_cb({"bq_ids": {"n4140": {"so_38487640_38488280_2": {"length": 24, "quality": 0.96, "section_id": 3296}, "so_38487640_38488280_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 6030}, "so_38487640_38488280_4": {"length": 35, "quality": 0.9459459459459459, "section_id": 446}, "so_38487640_38488280_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 41}}, "n3337": {"so_38487640_38488280_2": {"length": 24, "quality": 0.96, "section_id": 3166}, "so_38487640_38488280_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5798}, "so_38487640_38488280_4": {"length": 35, "quality": 0.9459459459459459, "section_id": 437}, "so_38487640_38488280_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 38}}, "n4659": {"so_38487640_38488280_2": {"length": 24, "quality": 0.96, "section_id": 4058}, "so_38487640_38488280_4": {"length": 35, "quality": 0.9459459459459459, "section_id": 468}, "so_38487640_38488280_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 41}}}, "38537319": {"Id": "38537319", "PostTypeId": "2", "Body": "<p><em>It may be a compiler bug</em>.</p>\n<p>I reduced and simplified the code example:</p>\n<pre><code>struct ctor_takes_int\n{\n    // dummy parameter needed to put expression in a ctor-init-list of derived class\n    ctor_takes_int (int=0){ }\n} ;\n\nstruct stupid_base\n{\n    //int nevermind;\n} ;\n\nstruct upcast_in_init_list;\n\n/* \n * volatile = anti optimisation :\n * no value propagation possible on volatile variables\n * no constant propagation\n * no inlining of volatile pointer to function!\n */\nint (*volatile upcast) (struct upcast_in_init_list *that);\n\nstruct upcast_in_init_list\n: virtual stupid_base, ctor_takes_int\n{\n    upcast_in_init_list ()\n    :    ctor_takes_int (upcast(this))\n    { }\n} ;\n\n/*\n * volatile = anti optimisation\n * no dead assignment removal\n */\nstupid_base *volatile p;\n\n// must be compiled out of line\nint do_upcast (upcast_in_init_list *that) {\n    p = that;\n    return 0;\n}\n\nint main ()\n{\n    upcast = &amp;do_upcast;\n    new upcast_in_init_list() ; \n    return 0 ;\n}\n</code></pre>\n<p>The program crashes on <a href=\"http://www.tutorialspoint.com/compile_cpp11_online.php\" rel=\"nofollow\">http://www.tutorialspoint.com/compile_cpp11_online.php</a></p>\n<p>(Note the use of <code>volatile</code> to prevent some optimisations, but it doesn't seem needed in practice. It's just more \"robust\", to have a \"robust crash\".)</p>\n<p>If instead of calling a function, I do the up cast inside the ctor-init-list, with <code>((p = this,0))</code>, the program works. This means that the compilers knows how to perform the pointer conversion on <code>this</code> inside the ctor-init-list of the object being constructor, but the common conversion code doesn't know how perform the conversion, as the derived object doesn't exist at that point (you can't use <code>typeid</code> on it for example).</p>\n<p>When you think about it in term of implementation, it's understandable: for non virtual base classes, the derived to base pointer conversion is a simple \"if non null add a fixed offset\" adjustment, but it involves something more complicated for virtual base classes, as they don't reside at a fixed offset, by definition (making a base class virtual is much like adding a level of indirection).</p>\n<p>The essence of virtual items (virtual functions, virtual base classes) is a dependency on the dynamic (real) type of the object. Note that a class without virtual functions but with a virtual base class isn't \"polymorphic\" in C++ and doesn't support RTTI (<code>dynamic_cast</code> and <code>typeid</code>), but must still have some \"virtual\" runtime information, either vptr (vtable pointer), or some virtual base offset or pointer. In either case, the runtime information is initialized during construction.</p>\n<p><strong>When the body of a constructor is entered (immediately after <code>{</code>), the object being constructed doesn't officially \"exists\"</strong> as its lifetime has not started: if the constructor body exits with an exception, the corresponding destructor will not be invoked. But the un-started lifetime still has all the attribute of a \"virtual\" object (= an object with virtual features, either functions or base classes). Virtual functions can be called virtually and the overrider in the current class will be invoked, <code>typeid</code> will indicate the type of the object in construction, etc.</p>\n<p>In practice, conversions to non virtual base classes always work, in all compilers, as no \"virtual\"/dynamic information is used, just like calling non virtual functions \"works\" (in practice) on un-constructed objects, even if it isn't legal.</p>\n<p>Also, conversion of the expression (not value) <code>this</code> in the initialization list works, as it is a special optimized case: the compiler knows the layout of the class and the (static) offset of all virtual in the complete constructor (the constructor used to construct complete objects, not base class subobjects). You can see that <code>this</code> is special cased: using <code>(that = this, p = that, 0)</code> (where <code>that</code> is some <code>upcast_in_init_list *</code> variable) in a ctor-init-list of a complete constructor doesn't work, as the special isn't recognized anymore.</p>\n<p>Handling of <code>this</code> is a base class constructor call (a constructor call that doesn't get to initialize virtual base classes) apparently works too, I don't know why.</p>\n", "LastEditorUserId": "963864", "LastActivityDate": "2016-07-23T06:28:49.713", "Score": "0", "CreationDate": "2016-07-23T01:34:46.740", "ParentId": "38487640", "CommentCount": "6", "OwnerUserId": "963864", "LastEditDate": "2016-07-23T06:28:49.713"}, "38488280": {"Id": "38488280", "PostTypeId": "2", "Body": "<p>For what it's worth, the code looks OK to me. I don't see anything controversial in this use of <code>static_cast</code> - it's run-of-the-mill derived-to-base pointer conversion. Looks like a compiler bug to me.</p>\n<p>If you insist on chapter and verse:</p>\n<blockquote>\n<p id=\"so_38487640_38488280_0\"><strong>[expr.static.cast]/4</strong> An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion.</p>\n</blockquote>\n<p>So we are looking at the validity of <code>T t(this);</code> within the constructor of <code>InheritAndLinkList&lt;T&gt;</code> - a <em>direct-initialization</em>:</p>\n<blockquote>\n<p id=\"so_38487640_38488280_1\"><strong>[dcl.init]/17</strong> ...</p>\n<p id=\"so_38487640_38488280_2\">-- Otherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression. Standard conversions (Clause 4) will be used, if necessary, to convert the initializer expression to the cv-unqualified version of the destination type; no user-defined conversions are considered.</p>\n</blockquote>\n<p>.</p>\n<blockquote>\n<p id=\"so_38487640_38488280_3\"><strong>[conv.ptr]/3</strong> A prvalue of type \u201cpointer to <em>cv</em> <code>D</code>\u201d, where <code>D</code> is a class type, can be converted to a prvalue of type \u201cpointer\n  to <em>cv</em> <code>B</code>\u201d, where <code>B</code> is a base class (Clause 10) of <code>D</code>. If <code>B</code> is an inaccessible (Clause 11) or ambiguous (10.2) base class of <code>D</code>, a program that necessitates this conversion is ill-formed. The result of the conversion is a\n  pointer to the base class subobject of the derived class object.</p>\n</blockquote>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>After vigorous discussion in comments, using <code>this</code> from within constructor initializer list is not quite as straightforward - but your particular use is still legal, I believe.</p>\n<blockquote>\n<p id=\"so_38487640_38488280_4\"><strong>[class.cdtor]/3</strong> To explicitly or implicitly convert a pointer (a glvalue) referring to an object of class <code>X</code> to a pointer (reference) to a direct or indirect base class <code>B</code> of <code>X</code>, the construction of <code>X</code> and the construction of all of its direct or indirect bases that directly or indirectly derive from <code>B</code> shall have started and the destruction of these classes shall not have completed, otherwise the conversion results in undefined behavior... [<em>Example</em>:</p>\n<pre><code>struct A { };\nstruct B : virtual A { };\nstruct C : B { };\nstruct D : virtual A { D(A*); };\nstruct X { X(A*); };\n\nstruct E : C, D, X {\n  E() : D(this), // undefined: upcast from E* to A*\n                 // might use path E* ! D* ! A*\n                 // but D is not constructed\n                 // D((C*)this), // defined:\n                 // E* ! C* defined because E() has started\n                 // and C* ! A* defined because\n                 // C fully constructed\n  X(this) {      // defined: upon construction of X,\n                 // C/B/D/A sublattice is fully constructed\n  }\n};\n</code></pre>\n<p id=\"so_38487640_38488280_5\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Your case resembles <code>X(this)</code> in the example above, and is actually simpler than that because you only cast one step up in the hierarchy, so there are no intermediate classes to be concerned about.</p>\n</hr>", "LastEditorUserId": "1670129", "LastActivityDate": "2016-07-23T06:05:46.707", "Score": "4", "CreationDate": "2016-07-20T18:33:33.750", "ParentId": "38487640", "CommentCount": "2", "OwnerUserId": "1670129", "LastEditDate": "2016-07-23T06:05:46.707"}, "38487640": {"ViewCount": "317", "Body": "<p>I have some code. It doesn't work.</p>\n<p>At first, you will look at this sample code snippet and think \"WHY?\" but trust me: there is a reason.</p>\n<p>Here's the code:</p>\n<pre><code>class LinkedListNode\n// blaa\n{\npublic:\n    LinkedListNode ( void* p )\n    {\n        // blaa\n    }\n} ;\n\ntemplate &lt;typename T&gt;\nclass InheritAndLinkList\n:   public virtual T\n,   public LinkedListNode\n{\npublic:\n    InheritAndLinkList ()\n    :    LinkedListNode ( static_cast&lt;void*&gt;(static_cast&lt;T*&gt;(this)) ) // an exception occurs here when ..... (scroll down)\n    { }\n} ;\n\ntemplate &lt;typename T&gt;\nclass Implements\n:   public virtual InheritAndLinkList&lt;T&gt;\n{ } ;\n\n\nclass    A\n{\npublic:\n    virtual void goA () =0 ;\n} ;\n\nclass    B\n:   public Implements&lt;A&gt;\n{\npublic:\n    virtual void goB () =0 ;\n} ;\n\n\nclass    MyClass\n:   public Implements&lt;B&gt;\n{\npublic:\n    virtual void goA ()\n    {\n        // blaa\n    }\n    virtual void goB ()\n    {\n        // blaa\n    }\n} ;\n\n\nint main ( ... )\n{\n    MyClass * p = new MyClass () ; // ..... This line executes\n\n    p-&gt;goA() ;\n    p-&gt;goB() ;\n\n    return 0 ;\n}\n</code></pre>\n<p>The specific error is that, upon construction, the expression <code>static_cast&lt;T*&gt;(this)</code> causes a segmentation fault....... when using the Intel C++ compiler. This has been working for years on many version of GCC, LLVM, MS Visual Studio, etc. And now ICPC makes it die.</p>\n<p>I believe this is a perfectly valid thing to do. By the time this line gets called, <code>T</code> has been constructed and should be valid to use... unless there is another weird thing in the C++ spec about that.</p>\n<p>Putting the <code>static_cast</code> in the constructor body (and changing its super to match) causes it to avoid this seg-fault.</p>\n<p>So my question: <strong>where in the spec does it say this <em>[static cast]</em> is/isn't safe?</strong></p>\n", "Title": "C++ Virtual Inheritance: static_cast \"this\" to virtual parent in initializer list of derived", "CreationDate": "2016-07-20T17:59:18.823", "LastActivityDate": "2016-07-24T15:26:58.193", "CommentCount": "23", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-07-24T15:26:58.193", "LastEditorUserId": "884986", "Id": "38487640", "Score": "3", "OwnerUserId": "884986", "Tags": "<c++><constructor><language-lawyer><lifetime><virtual-inheritance>", "AnswerCount": "2"}});