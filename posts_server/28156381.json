post_cb({"bq_ids": {"n4140": {"so_28156381_28159822_1": {"length": 14, "quality": 1.0, "section_id": 43}, "so_28156381_28159822_2": {"length": 10, "quality": 1.0, "section_id": 41}, "so_28156381_28159822_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}}, "n3337": {"so_28156381_28159822_1": {"length": 14, "quality": 1.0, "section_id": 40}, "so_28156381_28159822_2": {"length": 10, "quality": 1.0, "section_id": 38}, "so_28156381_28159822_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}}, "n4659": {"so_28156381_28159822_1": {"length": 14, "quality": 1.0, "section_id": 43}, "so_28156381_28159822_2": {"length": 10, "quality": 1.0, "section_id": 41}, "so_28156381_28159822_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 0}}}, "28177191": {"Id": "28177191", "PostTypeId": "2", "Body": "<p>C++ does not allow this conversion, and many others like it, because it would complicate the implementation of virtual inheritance.</p>\n<pre><code>struct A { int a; };\nstruct B : virtual A { int b; };\nstruct C : virtual A { int c; };\nstruct D : B, C { int d };\n</code></pre>\n<p>Here's how a compiler might try to lay out these classes:</p>\n<pre><code>A:  [ A::a ]\nB:  [ B::b ] [ A ]\nC:  [ C::c ] [ A ]\nD:  [ D::d ] [ B ] [ C ] [ A ]\n</code></pre>\n<p>If we have a pointer to B, it's not an easy task to get a pointer to its base class A, because it's not at a fixed offset from the beginning of the B object. A may be located right next to B::b, or it may be somewhere else, depending on whether our object is a standalone B or a B that is a base of D. There is no way to know which case we have!</p>\n<p>To make a cast, the program needs to actually access the B object and get a <em>hidden base pointer</em> from it. So the real layout would be more like this:</p>\n<pre><code>A:  [ A::a ]\nB:  [ B::b | B::address-of-A ] [ A ]\nC:  [ C::c | C::address-of-A ] [ A ]\nD:  [ D::d | D::address-of-A ] [ B ] [ C ] [ A ]\n</code></pre>\n<p>where <code>address-of-A</code>s are hidden members added by the compiler.</p>\n<p>That's all fine and dandy while we are talking about regular pointers. But when we have a pointer-to-member, we don't have any object to go and fetch the hidden base pointer from. So if we have only <code>B X::*</code>, there is absolutely no way to convert it to <code>A X::*</code> without having an actual X object.</p>\n<p>While it is in theory possible to allow conversions like this, it would be hugely complicated. For example, a pointer-to member would need to hold variable amount of data (all the hidden pointer-to-base values the original object has).</p>\n<p>In theory C++ could allow such conversions of pointers-to-members only to non-virtual base classes (in this example, <code>D X::*</code> to <code>B X::*</code> or <code>C X::*</code>, but not <code>A X::*</code>). Or at least I don't see why it could be an insurmountable problem for implementations. I guess this is not done because it would introduce additional complexity to the standard for very little benefit. Or maybe the standard doesn't want to preclude unusual implementations of inheritance. For instance an implementation may want to implement all inheritance with hidden pointer-to-base members, as if it's always virtual (for debugging purposes, or for compatibility with other languages, or whatever). Or perhaps it is just overlooked. Maybe in another revision of the standard (2020?)</p>\n", "LastActivityDate": "2015-01-27T18:11:46.173", "Score": "3", "CreationDate": "2015-01-27T18:11:46.173", "ParentId": "28156381", "CommentCount": "3", "OwnerUserId": "775806", "CommunityOwnedDate": "2015-01-27T18:24:48.773"}, "28156381": {"ViewCount": "649", "Body": "<p>Calling virtual member functions of a class using a pointer to the base class is of course a very common thing to do in C++. So I find it strange that it seems impossible to do the same thing when you have a member pointer instead of a normal pointer. Please consider the following code:</p>\n<pre><code>struct B\n{\n    virtual void f();\n};\n\nstruct D : B\n{\n    virtual void f();\n};\n\nstruct E\n{\n    B b;\n    D d;\n};\n\nint main()\n{\n    E e;\n\n    // First with normal pointers:\n    B* pb1 = &amp;e.b;  // OK\n    B* pb2 = &amp;e.d;  // OK, B is a base of D\n    pb1-&gt;f();  // OK, calls B::f()\n    pb2-&gt;f();  // OK, calls D::f()\n\n    // Now with member pointers:\n    B E::* pmb1 = &amp;E::b;  // OK\n    B E::* pmb2 = &amp;E::d;  // Error: invalid conversion from \u2018D E::*\u2019 to \u2018B E::*\u2019\n    (e.*pmb1).f();  // OK, calls B::f()\n    (e.*pmb2).f();  // Why not call D::f() ???\n\n    return 0;\n}\n</code></pre>\n<p>Visual C++ goes on to say:</p>\n<p><code>error C2440: 'initializing' : cannot convert from 'D E::* ' to 'B E::* '\nTypes pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast</code></p>\n<p>I don't understand why these are 'unrelated'. Why is this not possible?</p>\n<hr>\n<p><strong>Edit:</strong><br>\nI am trying to keep this a C++ question and not about the particular problem I am trying to solve, but this is essentially what I want to do:</br></p>\n<pre><code>std::vector&lt;B E::*&gt; v;\nv.push_back( &amp;E::b ); // OK\nv.push_back( &amp;E::d ); // Error\n\nB&amp; g( E&amp; e, int i )\n{\n  return e.*v[i];\n}\n</code></pre>\n<p>E is a class containing several members derived from B.  The vector v is used to organize (eg reorder) member pointers to these members. Vector v changes infrequently. The function g() allows you to select one of the members of E using an index into v. It is called very often and each time with a different E.</p>\n<p>If you think about it, v is just a lookup table of offsets. The function g() simply selects one of these offsets and add it to the E* in order to return the B*. The function g() is inlined by the compiler and compiles to just 4 CPU instructions, which is exactly what I want:</p>\n<pre><code>// g( e, 1 )\nmov         rax,qword ptr [v (013F7F5798h)]\nmovsxd      rcx,dword ptr [rax+4]\nlea         rax,[e]\nadd         rcx,rax\n</code></pre>\n<p>I cannot think of any reason why the standard would not allow a D E::* to be converted to a B E::*.</p>\n</hr>", "Title": "Cannot cast \"member pointer to derived class\" to \"member pointer to base class\"", "CreationDate": "2015-01-26T18:28:39.080", "LastActivityDate": "2015-01-27T18:11:46.173", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-01-27T05:56:26.227", "LastEditorUserId": "254722", "Id": "28156381", "Score": "8", "OwnerUserId": "254722", "Tags": "<c++>", "AnswerCount": "2"}, "28159822": {"Id": "28159822", "PostTypeId": "2", "Body": "<p>The simple answer, is that C++ does not define the conversion you are attempting and thus your program is ill formed.</p>\n<p>Consider <em>standard conversions</em> (C++11\u00a74/1):</p>\n<blockquote>\n<p id=\"so_28156381_28159822_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions.</p>\n</blockquote>\n<p>Since you are not performing any cast, nor do you have any custom conversions defined, you are indeed performing such a standard conversion. Without enumerating all possible such conversions, two are of explicit interest for your example: <em>pointer</em> conversions and <em>pointer to member</em> conversions. Note that C++ does not consider pointer to member types to be a subset of pointer types.</p>\n<p>Pointer to member conversions are defined in C++11\u00a74.11 and consist of exactly two conversions:</p>\n<p><ul>\n<li>The null member pointer conversion which allows null pointer constants to be converted to pointer to member types (4.11/1).</li>\n<li>The somewhat more contrived second conversion (4.11/2):</li></ul></p>\n<blockquote>\n<p id=\"so_28156381_28159822_1\">\u201cpointer to member of B of type cv T\u201d, where B is a class type, can be converted to a [...] \u201cpointer to member of D of type cv T\u201d, where D is a derived class [...] of B</p></blockquote>\n\n  Contrast this with the previous section 4.10 which defines three pointer conversions:\n\n<p><ul>\n<li>The null pointer conversion (4.10/1) which allows null pointer constants to be converted to pointer types.</li>\n<li>Conversion to pointers to <code>void</code> (4.10/2) which allows the conversion of any pointer type to pointer to <code>void</code>.</li>\n<li>And finally why it works with pointers (but not pointers to member) (4.10/3):</li></ul></p>\n<blockquote>\n<p id=\"so_28156381_28159822_2\">A [...] \u201cpointer to cv D\u201d, where D is a class type, can be converted to a [...] \u201cpointer to cv B\u201d, where B is a base class [...] of D</p></blockquote>\n\n  Therefore, to wrap it all up: The standard conversion you are attempting is defined for your pointer example, but simply does not exist for the pointer to member variant.\n\n", "LastActivityDate": "2015-01-26T22:22:22.193", "CommentCount": "0", "CreationDate": "2015-01-26T22:22:22.193", "ParentId": "28156381", "Score": "3", "OwnerUserId": "65678"}});