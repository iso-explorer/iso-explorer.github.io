post_cb({"20874388": {"CommentCount": "3", "AcceptedAnswerId": "20874570", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2014-01-01T23:33:03.447", "LastActivityDate": "2016-07-08T21:46:55.323", "LastEditDate": "2014-01-01T23:58:32.217", "ViewCount": "1473", "FavoriteCount": "1", "Title": "Error spliting an std::index_sequence", "Id": "20874388", "Score": "4", "Body": "<p>I'm trying to split an <code>index_sequence</code> into two halves. For that, I generate an <code>index_sequence</code> with the lower half and use it to skip the leading elements on the full <code>index_sequence</code>. The following is a minimal test case that represents what I'm trying to achieve:</p>\n<pre><code>template &lt;int ...I&gt;\nstruct index_sequence {};\n\ntemplate &lt;int ...I, int ...J&gt;\nvoid foo(index_sequence&lt;I...&gt;, index_sequence&lt;I..., J...&gt;)\n{}\n\nint main()\n{\n    foo(index_sequence&lt;0&gt;{}, index_sequence&lt;0, 1&gt;{});\n}\n</code></pre>\n<p>I've tried this with the latest versions of <em>Clang</em>, <em>GCC</em> and <em>MSVC</em>, and they all fail to deduce <code>J...</code>. Is this allowed by the standard? If not, why and what would be a good way to achieve my intent?</p>\n", "Tags": "<c++><templates><c++11><std>", "OwnerUserId": "927034", "AnswerCount": "4"}, "20878648": {"ParentId": "20874388", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If what you want is to split a <code>std::index_sequence</code> instead of removing the common prefix of two <code>std::index_sequence</code>s, I think you can benefit from an implementation of <code>slice</code> and using it to split a <code>std::index_sequence</code> into pieces.</p>\n<p>I'm going to omit the implementation of <code>std::index_sequence</code> and friends, since you can refer to the paper, <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3658.html\" rel=\"nofollow noreferrer\">N3658</a>, and a sample implementation <a href=\"https://gitorious.org/redistd/integer_seq/source/fdce85d18df4ea99240524c626d5452a0f7c3faf%3ainteger_seq.h\" rel=\"nofollow noreferrer\">here</a>.</p>\n<h3>make_index_range</h3>\n<p>To implement <code>slice</code>, we'll use a helper called <code>make_integer_range</code>. We want a <code>std::index_sequence</code> generator which gives us [Begin, End) instead of [0, End). Leveraging <code>std::make_integer_sequence</code>, we get:</p>\n<pre><code>template &lt;typename T, typename Seq, T Begin&gt;\nstruct make_integer_range_impl;\n\ntemplate &lt;typename T, T... Ints, T Begin&gt;\nstruct make_integer_range_impl&lt;T, std::integer_sequence&lt;T, Ints...&gt;, Begin&gt; {\n  using type = std::integer_sequence&lt;T, Begin + Ints...&gt;;\n};\n\n/* Similar to std::make_integer_sequence&lt;&gt;, except it goes from [Begin, End)\n   instead of [0, End). */\ntemplate &lt;typename T, T Begin, T End&gt;\nusing make_integer_range = typename make_integer_range_impl&lt;\n    T, std::make_integer_sequence&lt;T, End - Begin&gt;, Begin&gt;::type;\n\n/* Similar to std::make_index_sequence&lt;&gt;, except it goes from [Begin, End)\n   instead of [0, End). */\ntemplate &lt;std::size_t Begin, std::size_t End&gt;\nusing make_index_range = make_integer_range&lt;std::size_t, Begin, End&gt;;\n</code></pre>\n<h3>slice</h3>\n<p>Since we don't have a <code>std::get</code>-like functionality for <code>std::index_sequence</code> or a variadic template pack, we just build a temporary <code>std::array</code> to get us <code>std::get</code>. Then explode the array with only the slice we want. </p>\n<pre><code>template &lt;std::size_t... Indices, std::size_t... I&gt;\nconstexpr decltype(auto) slice_impl(\n      std::index_sequence&lt;Indices...&gt;,\n      std::index_sequence&lt;I...&gt;) {\n  using Array = std::array&lt;std::size_t, sizeof...(Indices)&gt;;\n  return std::index_sequence&lt;std::get&lt;I&gt;(Array{{Indices...}})...&gt;();\n}\n\ntemplate &lt;std::size_t Begin, std::size_t End, std::size_t... Indices&gt;\nconstexpr decltype(auto) slice(std::index_sequence&lt;Indices...&gt; idx_seq) {\n  return slice_impl(idx_seq, make_index_range&lt;Begin, End&gt;());\n}\n</code></pre>\n<h3>split_at</h3>\n<p>One example of using the <code>slice</code> we just built is to write a <code>split_at</code> function. We specify the index at which we want to split the <code>std::index_sequence</code>, and return a pair of <code>std::index_sequence</code>s split at the given index. </p>\n<pre><code>template &lt;std::size_t At, std::size_t... Indices&gt;\nconstexpr decltype(auto) split_at(index_sequence&lt;Indices...&gt; idx_seq) {\n    return std::make_pair(slice&lt;0, At&gt;(idx_seq), \n                          slice&lt;At, sizeof...(Indices)&gt;(idx_seq));\n}\n</code></pre>\n<h3>Examples of <code>split_at</code>:</h3>\n<pre><code>static_assert(std::is_same&lt;\n                decltype(split_at&lt;2&gt;(index_sequence&lt;1, 4, 2&gt;())),\n                std::pair&lt;index_sequence&lt;1, 4&gt;, index_sequence&lt;2&gt;&gt;&gt;(), \"\");\n\nstatic_assert(std::is_same&lt;\n                decltype(split_at&lt;1&gt;(index_sequence&lt;1, 4, 2, 3&gt;())),\n                std::pair&lt;index_sequence&lt;1&gt;, index_sequence&lt;4, 2, 3&gt;&gt;&gt;(), \"\");\n</code></pre>\n", "OwnerUserId": "2968284", "LastEditorUserId": "2968284", "LastEditDate": "2016-07-08T21:46:55.323", "Id": "20878648", "Score": "6", "CreationDate": "2014-01-02T07:55:40.047", "LastActivityDate": "2016-07-08T21:46:55.323"}, "20874884": {"ParentId": "20874388", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>To get suffix, you may use something like:</p>\n<pre><code>template&lt;int ... I&gt; struct get_suffix_helper {\n    template&lt;int ... J&gt; static index_sequence&lt;J...&gt; foo(index_sequence&lt;I..., J...&gt;);\n};\n\ntemplate&lt;typename T1, typename T2&gt; struct get_suffix;\n\ntemplate&lt;int ... Is1, int ... Is2&gt;\nstruct get_suffix&lt;index_sequence&lt;Is1...&gt;, index_sequence&lt;Is2...&gt;&gt; :\n    public decltype(get_suffix_helper&lt;Is1...&gt;::foo(std::declval&lt;index_sequence&lt;Is2...&gt;&gt;())) {};\n\nstatic_assert(std::is_base_of&lt;index_sequence&lt;&gt;,\n                              get_suffix&lt;index_sequence&lt;1, 2&gt;,\n                                         index_sequence&lt;1, 2&gt;&gt;&gt;::value, \"error\");\n\nstatic_assert(std::is_base_of&lt;index_sequence&lt;42&gt;,\n                              get_suffix&lt;index_sequence&lt;1, 2&gt;,\n                                         index_sequence&lt;1, 2, 42&gt;&gt;&gt;::value, \"error\");\n</code></pre>\n<p>Or, with some error check:</p>\n<pre><code>template &lt;typename T1, typename T2&gt; struct get_suffix;\n\ntemplate&lt;int ...Is&gt;\nstruct get_suffix&lt;index_sequence&lt;&gt;, index_sequence&lt;Is...&gt;&gt;\n{\n    typedef index_sequence&lt;Is...&gt; type;\n    static const bool valid = true;\n};\n\ntemplate&lt;int ...Is&gt;\nstruct get_suffix&lt;index_sequence&lt;Is...&gt;, index_sequence&lt;&gt;&gt;\n{\n    typedef void type;\n    static const bool valid = false;\n};\n\ntemplate&lt;&gt;\nstruct get_suffix&lt;index_sequence&lt;&gt;, index_sequence&lt;&gt;&gt;\n{\n    typedef index_sequence&lt;&gt; type;\n    static const bool valid = true;\n};\n\ntemplate&lt;int N, int ...Is, int... Js&gt;\nstruct get_suffix&lt;index_sequence&lt;N, Is...&gt;, index_sequence&lt;N, Js...&gt;&gt;\n{\n    typedef typename get_suffix&lt;index_sequence&lt;Is...&gt;, index_sequence&lt;Js...&gt;&gt;::type type;\n    static const bool valid = get_suffix&lt;index_sequence&lt;Is...&gt;, index_sequence&lt;Js...&gt;&gt;::valid;\n};\n\ntemplate&lt;int N1, int N2, int ...Is, int... Js&gt;\nstruct get_suffix&lt;index_sequence&lt;N1, Is...&gt;, index_sequence&lt;N2, Js...&gt;&gt;\n{\n    typedef void type;\n    static const bool valid = false;\n};\n\nstatic_assert(std::is_same&lt;index_sequence&lt;&gt;,\n                           get_suffix&lt;index_sequence&lt;1, 2&gt;,\n                                      index_sequence&lt;1, 2&gt;&gt;::type&gt;::value, \"error\");\n\nstatic_assert(!get_suffix&lt;index_sequence&lt;1, 2, 42&gt;, index_sequence&lt;1, 2&gt;&gt;::valid, \"error\");\nstatic_assert(!get_suffix&lt;index_sequence&lt;0, 2, 1&gt;, index_sequence&lt;0, 1, 2&gt;&gt;::valid, \"error\");\n\nstatic_assert(std::is_same&lt;index_sequence&lt;42&gt;,\n                           get_suffix&lt;index_sequence&lt;1, 2&gt;,\n                                      index_sequence&lt;1, 2, 42&gt;&gt;::type&gt;::value, \"error\");\n</code></pre>\n", "OwnerUserId": "2684539", "LastEditorUserId": "2684539", "LastEditDate": "2014-01-02T01:16:16.103", "Id": "20874884", "Score": "2", "CreationDate": "2014-01-02T00:53:40.503", "LastActivityDate": "2014-01-02T01:16:16.103"}, "20874570": {"ParentId": "20874388", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_20874388_20874570_0\"><strong>14.8.2.5/9</strong> ... If the template argument list of <code>P</code> contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context...</p>\n</blockquote>\n<p>Thus, when comparing <code>index_sequence&lt;I..., J...&gt;</code> with <code>index_sequence&lt;0, 1&gt;{}</code>, neither <code>I...</code> nor <code>J...</code> can be deduced.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "20874570", "Score": "6", "CreationDate": "2014-01-02T00:00:58.997", "LastActivityDate": "2014-01-02T00:00:58.997"}, "20874863": {"ParentId": "20874388", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Not an answer, but a workaround: recursively trim off the leading elements a la:</p>\n<pre><code>template &lt;typename, typename&gt; struct remove_prefix;\n\ntemplate &lt;std::size_t... I&gt;\nstruct remove_prefix&lt;index_sequence&lt;&gt;, index_sequence&lt;I...&gt;&gt; {\n  using type = index_sequence&lt;I...&gt;;\n};\n\ntemplate &lt;std::size_t First, std::size_t... I, std::size_t... J&gt;\nstruct remove_prefix&lt;index_sequence&lt;First, I...&gt;,\n                     index_sequence&lt;First, J...&gt;&gt; {\n  using type = typename remove_prefix&lt;index_sequence&lt;I...&gt;,\n                                      index_sequence&lt;J...&gt;&gt;::type;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/85f7c293760c9fc9\" rel=\"nofollow\">Demo at Coliru</a>.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-01-02T00:56:18.227", "Id": "20874863", "Score": "0", "CreationDate": "2014-01-02T00:50:30.290", "LastActivityDate": "2014-01-02T00:56:18.227"}, "bq_ids": {"n4140": {"so_20874388_20874570_0": {"section_id": 340, "quality": 0.9375, "length": 15}}, "n3337": {"so_20874388_20874570_0": {"section_id": 330, "quality": 0.9375, "length": 15}}, "n4659": {"so_20874388_20874570_0": {"section_id": 349, "quality": 0.9375, "length": 15}}}});