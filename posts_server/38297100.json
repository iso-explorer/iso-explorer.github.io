post_cb({"38297134": {"ParentId": "38297100", "CommentCount": "0", "CreationDate": "2016-07-10T22:51:12.783", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "38297134", "Score": "4", "Body": "<p>If Alternative #1 were the definition of <code>nullptr</code>, then you are right that it would be an lvalue. However, it could be forced to be an rvalue using something like this:</p>\n<pre><code>const class __nullptr_t {...} __nullptr = {};\n#define nullptr (__nullptr_t(__nullptr));\n</code></pre>\n<p>That's not what was ultimately standardized though. In actual C++11, <code>nullptr</code> is a literal, the same way as <code>3.14</code> or <code>'x'</code>.</p>\n", "LastActivityDate": "2016-07-10T22:51:12.783"}, "38297100": {"CommentCount": "2", "AcceptedAnswerId": "38297115", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2016-07-10T22:45:49.663", "LastActivityDate": "2016-07-10T23:01:26.717", "LastEditDate": "2016-07-10T23:01:26.717", "ViewCount": "261", "FavoriteCount": "1", "Title": "How is nullptr rvalue", "Id": "38297100", "Score": "6", "Body": "<p>While looking at the implementation of <code>nullptr</code> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf\" rel=\"nofollow\">here</a>, what got my attention is that <code>nullptr</code> is <code>rvalue</code> which means we can do something like this </p>\n<pre><code>std::nullptr_t&amp;&amp; nullref = nullptr;\n</code></pre>\n<p>But how could <code>nullptr</code> be <code>rvalue</code> since the implementations is something like this </p>\n<pre><code>const class {...} nullptr = {};\n</code></pre>\n<p>Is this core feature ? What am I missing ? </p>\n", "Tags": "<c++><language-lawyer><rvalue><nullptr>", "OwnerUserId": "6189761", "AnswerCount": "2"}, "38297115": {"ParentId": "38297100", "CommentCount": "0", "CreationDate": "2016-07-10T22:48:05.540", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "38297115", "Score": "14", "Body": "<p>Implementation has nothing to do with it.</p>\n<p>The keyword <code>nullptr</code> is defined to produce an rvalue expression, and that's the end of it.</p>\n<blockquote>\n<p id=\"so_38297100_38297115_0\"><code>[C++14: 2.14.7/1]</code>: The pointer literal is the keyword <code>nullptr</code>. It is a prvalue of type <code>std::nullptr_t</code>. <em>[ Note:</em> <code>std::nullptr_t</code> is a distinct type that is neither a pointer type nor a pointer to member type; rather, a prvalue of this type is a null pointer constant and can be converted to a null pointer value or null member pointer value. See 4.10 and 4.11. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>I agree you couldn't yourself reimplement it to this criterion in userspace, but then that's the case for every single other keyword also.</p>\n<p>Expressions consisting only of the keywords <code>true</code> and <code>false</code> are also rvalues, if you're curious.</p>\n<blockquote>\n<p id=\"so_38297100_38297115_1\"><code>[C++14: 2.14.6/1]:</code> The Boolean literals are the keywords <code>false</code> and <code>true</code>. Such literals are prvalues and have type <code>bool</code>.</p>\n</blockquote>\n", "LastActivityDate": "2016-07-10T22:48:05.540"}, "bq_ids": {"n4140": {"so_38297100_38297115_1": {"section_id": 5365, "quality": 0.7857142857142857, "length": 11}, "so_38297100_38297115_0": {"section_id": 5366, "quality": 0.8048780487804879, "length": 33}}, "n3337": {"so_38297100_38297115_1": {"section_id": 5161, "quality": 0.7857142857142857, "length": 11}, "so_38297100_38297115_0": {"section_id": 5162, "quality": 0.8048780487804879, "length": 33}}, "n4659": {"so_38297100_38297115_1": {"section_id": 6790, "quality": 0.7857142857142857, "length": 11}, "so_38297100_38297115_0": {"section_id": 6791, "quality": 0.8048780487804879, "length": 33}}}});