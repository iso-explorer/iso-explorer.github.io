post_cb({"21029511": {"CommentCount": "13", "ViewCount": "262", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2014-01-09T19:36:03.337", "LastActivityDate": "2014-01-09T20:34:53.603", "Title": "friend class declaration and using directive", "AcceptedAnswerId": "21030560", "LastEditDate": "2014-01-09T20:03:50.367", "Id": "21029511", "Score": "13", "Body": "<p>Is the following example well-formed?</p>\n<pre><code>namespace N {\n    class A;\n}\nusing namespace N;\n\nclass B {\n    int i;\n    friend class A;\n};\n\nnamespace N {\n    class A {\n        B m;\n        int get() { return m.i; }\n    };\n}\n</code></pre>\n<p>This example compiled successfully with Clang 3.5, but failed with g++ 4.8.1 with the following:</p>\n<pre class=\"lang-none prettyprint-override\"><code>main.cpp: In member function \u2018int N::A::get()\u2019:\nmain.cpp:7:9: error: \u2018int B::i\u2019 is private\n     int i;\n         ^\nmain.cpp:14:30: error: within this context\n         int get() { return m.i; }\n                              ^\n</code></pre>\n<p>C++11 standard \u00a77.3.1.2 p3 says,</p>\n<blockquote>\n<p id=\"so_21029511_21029511_0\">If the name in a <code>friend</code> declaration is neither qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace.</p>\n</blockquote>\n<p>In example, <code>class A</code> is not member of <strong>innermost enclosing namespace</strong> (i.e. global namespace), but <code>class A</code> is introduced by using directive into global namespace.</p>\n", "Tags": "<c++><namespaces><friend><using-directives><name-lookup>", "OwnerUserId": "1873224", "AnswerCount": "2"}, "21030111": {"ParentId": "21029511", "CommentCount": "2", "Body": "<p>To make <code>N::A</code> without qualification a <code>friend</code> of <code>B</code> you'd use</p>\n<pre><code>friend A;\n</code></pre>\n<p>rather than</p>\n<pre><code>friend class A;\n</code></pre>\n<p>When using an elaborated type specifier, i.e., <code>class A</code>, and it is in this specific form, it introduces a class name (see 3.4.4 [basic.lookup.elab] paragraph 2).</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "21030111", "Score": "8", "CreationDate": "2014-01-09T20:08:33.577", "LastActivityDate": "2014-01-09T20:08:33.577"}, "bq_ids": {"n4140": {"so_21029511_21029511_0": {"section_id": 5485, "quality": 1.0, "length": 22}}, "n3337": {"so_21029511_21029511_0": {"section_id": 5271, "quality": 1.0, "length": 22}}, "n4659": {"so_21029511_21029511_0": {"section_id": 6920, "quality": 1.0, "length": 22}}}, "21030560": {"ParentId": "21029511", "CommentCount": "2", "Body": "<p>While using namespace N is pulling the name N::A into the global namespace, it is not declaring that A in the global namespace. Hence an additional A in the global namespace is the friend of B. clang is wrong.</p>\n", "OwnerUserId": "2249683", "PostTypeId": "2", "Id": "21030560", "Score": "1", "CreationDate": "2014-01-09T20:34:53.603", "LastActivityDate": "2014-01-09T20:34:53.603"}});