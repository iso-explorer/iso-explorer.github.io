post_cb({"bq_ids": {"n4140": {"so_21029511_21029511_0": {"length": 22, "quality": 1.0, "section_id": 5485}}, "n3337": {"so_21029511_21029511_0": {"length": 22, "quality": 1.0, "section_id": 5271}}, "n4659": {"so_21029511_21029511_0": {"length": 22, "quality": 1.0, "section_id": 6920}}}, "21030111": {"Id": "21030111", "PostTypeId": "2", "Body": "<p>To make <code>N::A</code> without qualification a <code>friend</code> of <code>B</code> you'd use</p>\n<pre><code>friend A;\n</code></pre>\n<p>rather than</p>\n<pre><code>friend class A;\n</code></pre>\n<p>When using an elaborated type specifier, i.e., <code>class A</code>, and it is in this specific form, it introduces a class name (see 3.4.4 [basic.lookup.elab] paragraph 2).</p>\n", "LastActivityDate": "2014-01-09T20:08:33.577", "CommentCount": "2", "CreationDate": "2014-01-09T20:08:33.577", "ParentId": "21029511", "Score": "8", "OwnerUserId": "1120273"}, "21029511": {"ViewCount": "262", "Body": "<p>Is the following example well-formed?</p>\n<pre><code>namespace N {\n    class A;\n}\nusing namespace N;\n\nclass B {\n    int i;\n    friend class A;\n};\n\nnamespace N {\n    class A {\n        B m;\n        int get() { return m.i; }\n    };\n}\n</code></pre>\n<p>This example compiled successfully with Clang 3.5, but failed with g++ 4.8.1 with the following:</p>\n<pre class=\"lang-none prettyprint-override\"><code>main.cpp: In member function \u2018int N::A::get()\u2019:\nmain.cpp:7:9: error: \u2018int B::i\u2019 is private\n     int i;\n         ^\nmain.cpp:14:30: error: within this context\n         int get() { return m.i; }\n                              ^\n</code></pre>\n<p>C++11 standard \u00a77.3.1.2 p3 says,</p>\n<blockquote>\n<p id=\"so_21029511_21029511_0\">If the name in a <code>friend</code> declaration is neither qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace.</p>\n</blockquote>\n<p>In example, <code>class A</code> is not member of <strong>innermost enclosing namespace</strong> (i.e. global namespace), but <code>class A</code> is introduced by using directive into global namespace.</p>\n", "AcceptedAnswerId": "21030560", "Title": "friend class declaration and using directive", "CreationDate": "2014-01-09T19:36:03.337", "Id": "21029511", "CommentCount": "13", "LastEditDate": "2014-01-09T20:03:50.367", "PostTypeId": "1", "LastEditorUserId": "819272", "LastActivityDate": "2014-01-09T20:34:53.603", "Score": "13", "OwnerUserId": "1873224", "Tags": "<c++><namespaces><friend><using-directives><name-lookup>", "AnswerCount": "2"}, "21030560": {"Id": "21030560", "PostTypeId": "2", "Body": "<p>While using namespace N is pulling the name N::A into the global namespace, it is not declaring that A in the global namespace. Hence an additional A in the global namespace is the friend of B. clang is wrong.</p>\n", "LastActivityDate": "2014-01-09T20:34:53.603", "CommentCount": "2", "CreationDate": "2014-01-09T20:34:53.603", "ParentId": "21029511", "Score": "1", "OwnerUserId": "2249683"}});