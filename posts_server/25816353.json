post_cb({"bq_ids": {"n4140": {"so_25816353_25816353_0": {"length": 15, "quality": 1.0, "section_id": 429}}, "n3337": {"so_25816353_25816353_0": {"length": 15, "quality": 1.0, "section_id": 421}}, "n4659": {"so_25816353_25816353_0": {"length": 15, "quality": 1.0, "section_id": 447}}}, "25816353": {"ViewCount": "142", "Body": "<p>Given this snippet</p>\n<pre><code>class Base\n{\npublic:\n    Base(){};\n};\n\nclass Derived : public Base\n{\npublic:\n    Derived();\n};\n\nDerived::Derived() :Base() {}\n</code></pre>\n<p>and considering this statement in \u00a712.6.2/2 (my emphasis)</p>\n<blockquote>\n<p id=\"so_25816353_25816353_0\">In a <em>mem-initializer-id</em> an initial unqualified identifier is looked up\n  in the scope of the constructor\u2019s class <strong>and, if not found in that\n  scope</strong>, it is looked up in the scope containing the constructor\u2019s\n  definition.</p>\n</blockquote>\n<p>I would you say that the lookup for the name <code>Base</code> in the definition of the <code>Derived</code> constructor <strong>is</strong> found in the <code>Derived</code> class definition.</p>\n<p>I was just wondering, if there are other more tangible examples, other than the one given in 12.6.2/3, where a <em>mem-initializer-id</em> is not found in the constructor's class. </p>\n", "AcceptedAnswerId": "25816474", "Title": "When is it the case that a mem-initializer-id is not found by ordinary lookup in the constructor's class definition?", "CreationDate": "2014-09-12T20:29:35.100", "Id": "25816353", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-06-28T15:15:58.877", "Score": "1", "OwnerUserId": "2548699", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "25948309": {"Id": "25948309", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25816353_25948309_0\"><em>I was just wondering, if there are other more tangible examples, other than the one given in 12.6.2/3, where a mem-initializer-id is not found in the constructor's class.</em></p>\n</blockquote>\n<p>A little more practical example than the one using a simple alias with <code>typedef</code>/<code>using</code> for a base class from \u00a712.6.2/p3: </p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct Base {};\nstruct Base2 {};\n\nstruct Derived : Base, Base2\n{\n    Derived();\n};\n\nusing namespace std;\n\nDerived::Derived() : conditional_t&lt;true, Base, Base2&gt;{} {}\n//                   ~~~~~~~~~~~~^\n</code></pre>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-28T15:15:58.877", "Score": "0", "CreationDate": "2014-09-20T11:34:14.847", "ParentId": "25816353", "CommentCount": "0", "OwnerUserId": "3953764", "LastEditDate": "2015-06-28T15:15:58.877"}, "25816474": {"Id": "25816474", "PostTypeId": "2", "Body": "<p>The <em>mem-initializer-id</em> must name the constructor\u2019s class, a non-static data member of the\nconstructor\u2019s class, or a direct or virtual base of that class. If it's an actual class name (whether the derived class or a base), it will be found as an <em>injected-class-name</em> inside the class's scope. If it's a data member, name lookup will obviously find it inside the class's scope. So that leaves a typedef, but that's also the example given in 12.6.2/3:</p>\n<pre><code>class Base { };\n\nclass Derived : public Base\n{\npublic:\n    Derived();\n};\n\nusing BaseAlias = Base;\n\nDerived::Derived() : BaseAlias() {}\n</code></pre>\n", "LastActivityDate": "2014-09-12T20:39:39.723", "CommentCount": "0", "CreationDate": "2014-09-12T20:39:39.723", "ParentId": "25816353", "Score": "5", "OwnerUserId": "2756719"}});