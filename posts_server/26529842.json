post_cb({"26530462": {"ParentId": "26529842", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-10-23T14:28:40.107", "Score": "13", "LastEditorUserId": "567292", "LastEditDate": "2014-10-23T15:04:41.147", "Id": "26530462", "OwnerUserId": "567292", "Body": "<p>The three <code>Foo</code>s are layout-compatible because they are the <em>same type</em>, <code>struct ::Foo</code>.</p>\n<blockquote>\n<h3>[basic.types]</h3>\n<p id=\"so_26529842_26530462_0\">11 - If two types T1 and T2 are the same type, then T1 and T2 are layout-compatible types.</p>\n</blockquote>\n<p>The classes are the same type because they have the same (fully-qualified) name and have external linkage:</p>\n<blockquote>\n<h3>[basic]</h3>\n<p id=\"so_26529842_26530462_1\">9 - A name used in more than one translation unit can potentially refer to the same entity in these translation units depending on the linkage (3.5) of the name specified in each translation unit.</p>\n</blockquote>\n<p>Class names declared at namespace scope that are not declared (recursively) within an unnamed namespace have external linkage:</p>\n<blockquote>\n<h3>[basic.link]</h3>\n<p id=\"so_26529842_26530462_2\">2 - A name is said to have linkage when it might denote the same [...] type [...] as a name introduced by a declaration in another scope:<br/>\n  \u2014 When a name has external linkage , the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit. [...]<br/>\n  4 - An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. All other namespaces have external linkage. A name having namespace scope that has not been given internal linkage above has the same linkage as the enclosing namespace if it is the name of [...]<br/>\n  \u2014 a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes (7.1.3) [...]</p>\n</blockquote>\n<p>Note that it is allowed to have multiple definitions of a class type appearing in different translation units, as long as the definitions consist of the same token sequence:</p>\n<blockquote>\n<h3>[basic.def.odr]</h3>\n<p id=\"so_26529842_26530462_3\">6 - There can be more than one definition of a class type (Clause 9) [...]  in a program provided that each definition appears in a different translation unit, and provided [...] each definition [...] shall consist of the same sequence of tokens [...]</p>\n</blockquote>\n<p>So if the <code>Foo</code>s had different names, they would not be the same type; if they appeared within an anonymous namespace or within a function definition (<em>except</em> an inline function; see <strong>[dcl.fct.spec]</strong>/4) they would not have external linkage and so would not be the same type.  In either case they would be layout-compatible only if they were standard-layout.</p>\n<hr>\n<p>Some examples:</p>\n<pre><code>// tu1.cpp\nstruct Foo { private: int i; public: int j; };\n\n// tu2.cpp\nstruct Foo { private: int i; public: int j; };\n</code></pre>\n<p>The two <code>Foo</code>s are the same type.</p>\n<pre><code>// tu1.cpp\nstruct Foo { private: int i; public: int j; };\n\n// tu2.cpp\nstruct Foo { private: int i; public: int k; };\n</code></pre>\n<p>ODR violation; undefined behavior.</p>\n<pre><code>// tu1.cpp\nstruct Foo { private: int i; public: int j; };\n\n// tu2.cpp\nstruct Bar { private: int i; public: int j; };\n</code></pre>\n<p>Different names, so different types. Not layout-compatible.</p>\n<pre><code>// tu1.cpp\nstruct Foo { int i; int j; };\n\n// tu2.cpp\nstruct Bar { int i; int j; };\n</code></pre>\n<p>Different names, different types, but layout-compatible (since standard-layout).</p>\n<pre><code>// tu1.cpp\nnamespace { struct Foo { private: int i; public: int j; }; }\n\n// tu2.cpp\nnamespace { struct Foo { private: int i; public: int j; }; }\n</code></pre>\n<p>Internal linkage; different types.</p>\n<pre><code>// tu1.cpp\nstatic void f() { struct Foo { private: int i; public: int j; }; }\n\n// tu2.cpp\nstatic void f() { struct Foo { private: int i; public: int j; }; }\n</code></pre>\n<p>No linkage; different types.</p>\n<pre><code>// tu1.cpp\ninline void f() { struct Foo { private: int i; public: int j; }; }\n\n// tu2.cpp\ninline void f() { struct Foo { private: int i; public: int j; }; }\n</code></pre>\n<p>Same type by <strong>[dcl.fct.spec]</strong>/4.</p>\n</hr>", "LastActivityDate": "2014-10-23T15:04:41.147"}, "bq_ids": {"n4140": {"so_26529842_26530462_1": {"section_id": 7032, "quality": 1.0, "length": 20}, "so_26529842_26529842_2": {"section_id": 5876, "quality": 0.8695652173913043, "length": 20}, "so_26529842_26529842_1": {"section_id": 5852, "quality": 1.0, "length": 16}, "so_26529842_26530462_0": {"section_id": 7209, "quality": 0.8571428571428571, "length": 6}, "so_26529842_26530462_3": {"section_id": 7043, "quality": 1.0, "length": 23}, "so_26529842_26530462_2": {"section_id": 7137, "quality": 0.5714285714285714, "length": 44}}, "n3337": {"so_26529842_26530462_1": {"section_id": 6778, "quality": 1.0, "length": 20}, "so_26529842_26529842_2": {"section_id": 5647, "quality": 0.9130434782608695, "length": 21}, "so_26529842_26529842_1": {"section_id": 5622, "quality": 1.0, "length": 16}, "so_26529842_26530462_0": {"section_id": 6953, "quality": 1.0, "length": 7}, "so_26529842_26530462_3": {"section_id": 6788, "quality": 1.0, "length": 23}, "so_26529842_26530462_2": {"section_id": 6881, "quality": 0.5714285714285714, "length": 44}}, "n4659": {"so_26529842_26530462_3": {"section_id": 8540, "quality": 1.0, "length": 23}, "so_26529842_26529842_2": {"section_id": 7361, "quality": 0.7391304347826086, "length": 17}, "so_26529842_26529842_1": {"section_id": 7331, "quality": 0.875, "length": 14}, "so_26529842_26530462_0": {"section_id": 6124, "quality": 0.7142857142857143, "length": 5}, "so_26529842_26530462_1": {"section_id": 8529, "quality": 1.0, "length": 20}, "so_26529842_26530462_2": {"section_id": 8638, "quality": 0.5714285714285714, "length": 44}}}, "26529842": {"CommentCount": "14", "AcceptedAnswerId": "26530462", "PostTypeId": "1", "LastEditorUserId": "853462", "CreationDate": "2014-10-23T13:58:58.730", "LastActivityDate": "2014-10-23T15:04:41.147", "LastEditDate": "2014-10-23T14:45:39.667", "ViewCount": "355", "FavoriteCount": "1", "Title": "Is layout-compatibility in the c++11 (working draft) standard too weak?", "Id": "26529842", "Score": "6", "Body": "<p>Of course, the answer is \"no\", because the people who wrote it thought really hard about it, however I want to know why.</p>\n<p>Considering that (template-less) classes are often declared in header files, which are then included in several files which are compiled separately, sub-consider these two files:</p>\n<h3>file1.c</h3>\n<pre><code>#include &lt;cstddef&gt;\n\nstruct Foo {\npublic:\n   int pub;\nprivate:\n   int priv;\n};\n\nsize_t getsize1(Foo const &amp;foo) {\n  return sizeof(foo);\n}\n</code></pre>\n<h3>file2.c</h3>\n<pre><code>#include &lt;cstddef&gt;\n\nstruct Foo {\npublic:\n   int pub;\nprivate:\n   int priv;\n};\n\nsize_t getsize2(Foo const &amp;foo) {\n  return sizeof(foo);\n}\n</code></pre>\n<p>In general Foo will be declared in a header file and included in both, but the effect is as shown above. (That is, including a header is no magic, it just puts the headers content on that line.) We can compile both and link them to the following:</p>\n<h3>main.cc</h3>\n<pre><code>#include &lt;iostream&gt;\nstruct Foo {\npublic:\n   int pub;\nprivate:\n   int priv;\n};\n\nsize_t getsize1(Foo const &amp;);\nsize_t getsize2(Foo const &amp;);\n\nint main() {\n    Foo foo;\n    std::cout &lt;&lt; getsize1(foo) &lt;&lt; \", \" &lt;&lt; getsize2(foo) &lt;&lt; \", \" &lt;&lt; sizeof(foo) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>One way to do so, is by using g++:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -std=c++11 -c -Wall file1.cc \ng++ -std=c++11 -c -Wall file2.cc \ng++ -std=c++11 -c -Wall main.cc \ng++ -std=c++11 -Wall *.o -o main\n</code></pre>\n<p>And (on my architecture and environment), this shows: 8, 8, 8. The sizeof's are the same for each compilation of file1.cc, file2.cc and main.cc</p>\n<p>But does the c++11 standard guarantee this, is it <em>really</em> OK to expect to have layout compatibility with all 3 Foo's? Foo contains both private and public fields, hence it is not a standard-layout struct as is defined in Clause 9 par 7 of the c++11 standard (working draft):</p>\n<blockquote>\n<p id=\"so_26529842_26529842_0\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li><strong>has the same access control (Clause 11) for all non-static data members</strong>,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p>Since we are using structs, and to be thorough, the next par says:</p>\n<blockquote>\n<p id=\"so_26529842_26529842_1\">A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class. A standard-layout union is a standard-layout class defined with the class-key union.</p>\n</blockquote>\n<p>To the best of my knowledge, the standard only defines layout-compatibility between structs in standard layout (Clause 9.2, par 18). </p>\n<blockquote>\n<p id=\"so_26529842_26529842_2\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout compatible types (3.9).</p>\n</blockquote>\n<p>So is it guaranteed all three Foo's are layout-compatible, and more importantly why?</p>\n<p>Why would a (non-deterministic) compiler, which creates different layouts for Foo during compilation, not be a c++11 compiler?</p>\n", "Tags": "<c++><c++11><struct><language-lawyer><memory-layout>", "OwnerUserId": "853462", "AnswerCount": "1"}});