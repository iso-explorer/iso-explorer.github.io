post_cb({"3225733": {"CommentCount": "1", "CreationDate": "2010-07-12T03:42:54.463", "PostTypeId": "1", "AcceptedAnswerId": "3226752", "LastEditorUserId": "380621", "LastActivityDate": "2010-07-21T13:38:12.687", "LastEditDate": "2010-07-12T03:49:48.643", "ViewCount": "415", "FavoriteCount": "0", "Title": "Size of a class containing only compile-time constants", "Id": "3225733", "Score": "3", "Body": "<p>If I have a class that contains only compile-time constants, for example,</p>\n<pre><code>class A {\n    static const int x = 1;\n    static const int y = 2;\n    static const int z = 3;\n};\n</code></pre>\n<p>I believe it's the case that, so long as the address of the constants is not taken, they can (will?) be replaced at compile time where they are used and will not take up any space in the executable (as constants that is, obviously the numbers themselves are going to have to show up). If this is the case can/will the class also be optimized out? And, will this change if something inherits from <code>class A</code>, but still only uses the constants themselves and does not take their addresses?</p>\n<p>Oh, and assuming, in the non-inheritance version, that the class is not actually used itself anywhere apart from as a means to access the constants.</p>\n<p>Thanks.</p>\n", "Tags": "<c++><const>", "OwnerUserId": "380621", "AnswerCount": "4"}, "3225741": {"ParentId": "3225733", "CommentCount": "2", "Body": "<p>It doesn't matter whether those variables are <code>const</code>; they are <code>static</code>, so they won't affect the size of the class anyway.</p>\n<p><code>sizeof(A)</code> cannot be zero, so if you create an instance of <code>A</code> it has to be at least one byte in size.  However, having <code>A</code> as a base class does not necessarily increase the size of a derived class because \"base class sub-objects may have zero size\" (C++03 \u00a71.8/5).</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3225741", "Score": "7", "CreationDate": "2010-07-12T03:45:11.073", "LastActivityDate": "2010-07-12T03:45:11.073"}, "3226752": {"ParentId": "3225733", "CommentCount": "5", "Body": "<h2>Space used</h2>\n<p>No, the static const int member will will not have any space allocated for them, as they are evaluated as compile time constants.</p>\n<p>As for size of the class object (i.e. <code>sizeof(A)</code>), this is not relevant unless you are creating instances of the class A - which you explicitly said you are not.</p>\n<h2>Use <em>namespace</em> instead?</h2>\n<p>That said, perhaps you could use <em>namespace</em> instead to make your intention a bit clearer? Unless you are using it for something like template traits, it seems you are abusing <em>class</em> to do the job namespaces are intended for.</p>\n", "OwnerUserId": "16673", "PostTypeId": "2", "Id": "3226752", "Score": "3", "CreationDate": "2010-07-12T08:02:11.703", "LastActivityDate": "2010-07-12T08:02:11.703"}, "3226671": {"ParentId": "3225733", "LastEditDate": "2010-07-21T13:38:12.687", "CommentCount": "2", "CreationDate": "2010-07-12T07:50:56.030", "OwnerUserId": "140719", "LastEditorUserId": "140719", "PostTypeId": "2", "Id": "3226671", "Score": "1", "Body": "<p>It's been given a size just because even object of such a class <strong><em>need to have a size</em></strong>. (For starters, if two such objects were members of another object, would they have distinct addresses if you form member pointers to them?) When this class is used as a base class, it will benefit from the <strong><em>empty base class optimization</em></strong> and be reduced to size 0. In fact, this </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {};\nstruct B { char x; };\nstruct C : public A, public B {};\n\nint main()\n{\n    std::cout &lt;&lt; sizeof(A) &lt;&lt; '\\n';\n    std::cout &lt;&lt; sizeof(B) &lt;&lt; '\\n';\n    std::cout &lt;&lt; sizeof(C) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>prints </p>\n<pre>\n1\n1\n1\n</pre>\n<p>for me, so <code>A</code> doesn't contribute anything to the size of <code>C</code>, which seems to support my interpretation that <code>A</code>'s size of <code>1</code> is artificial. </p>\n", "LastActivityDate": "2010-07-21T13:38:12.687"}, "3225743": {"ParentId": "3225733", "LastEditDate": "2010-07-12T03:55:42.313", "CommentCount": "2", "CreationDate": "2010-07-12T03:45:37.377", "OwnerUserId": "14860", "LastEditorUserId": "14860", "PostTypeId": "2", "Id": "3225743", "Score": "1", "Body": "<p>I believe that <em>every</em> type must have a <code>sizeof</code> of at least 1 (partly to ensure instance of that type get different addresses in an array for example).</p>\n<p>Section 5.3.3 of the C++0x draft standard is where this is dictated:</p>\n<blockquote>\n<p id=\"so_3225733_3225743_0\">When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. The size of a most derived class shall be greater than zero.</p>\n</blockquote>\n<p>They shouldn't affect the size of an <em>instance</em> (since they're static) but they will probably need to be stored in the executable somewhere since you need to be able to use the address-of operator on them. Whether they can be optimised out of existence depends entirely on the compiler and whether it can tell they're not being de-referenced. Enumerations are probably a better tool to use in this particular case.</p>\n<p>However, three integers in an application is unlikely to cause a problem.</p>\n", "LastActivityDate": "2010-07-12T03:55:42.313"}, "bq_ids": {"n4140": {"so_3225733_3225743_0": {"section_id": 6077, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_3225733_3225743_0": {"section_id": 5845, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_3225733_3225743_0": {"section_id": 7573, "quality": 0.9565217391304348, "length": 22}}}});