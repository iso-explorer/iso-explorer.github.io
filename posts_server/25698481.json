post_cb({"25698523": {"Id": "25698523", "PostTypeId": "2", "Body": "<p>\u00a76.6.3 [stmt.return]/p2:</p>\n<blockquote>\n<p id=\"so_25698481_25698523_0\">Flowing off the end of a function is equivalent to a <code>return</code> with no\n  value; this results in undefined behavior in a value-returning\n  function.</p>\n</blockquote>\n<p>(<code>main()</code> is a special exception. Flowing off the end of <code>main()</code> is equivalent to a <code>return 0;</code>)</p>\n<p>Permissible UB include:</p>\n<ul>\n<li>Returning what you \"wanted\" to return</li>\n<li>Returning a garbage value instead</li>\n<li>Crashing</li>\n<li>Sending your password to hackers</li>\n<li>Formatting your hard drive</li>\n<li>Making your computer explode and blow your legs off</li>\n<li>Conjuring nasal demons</li>\n<li>Traveling back in time and fixing your program to the right thing</li>\n<li>Creating a black hole</li>\n<li>......</li>\n</ul>\n<hr>\n<p>But seriously, UB can manifest in all sorts of ways. For instance, given this code:</p>\n<pre><code>#include &lt;iostream&gt;\nbool foo = false;\nint addNumbers(int x, int y)\n{\n    int answer = x;\n    answer = 1;\n    //return x + y;\n}\n\nint main(){\n  if(!foo) {\n    addNumbers(10, 20);\n    std::cout &lt;&lt; 1 &lt;&lt; std::endl;\n  }\n  else {\n    std::cout &lt;&lt; 2 &lt;&lt; std::endl;\n  }\n}\n</code></pre>\n<p>clang++ at -O2 <a href=\"http://coliru.stacked-crooked.com/a/d8573a4f791cf335\" rel=\"nofollow\">prints</a> <code>2</code>.</p>\n<p>Why? Because it deduced that <code>addNumbers(10, 20);</code> has undefined behavior, which allows it to assume that the first branch is never taken and that <code>foo</code> is always <code>true</code>, even though that's obviously not the case.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-06T09:05:35.150", "Score": "2", "CreationDate": "2014-09-06T08:48:21.397", "ParentId": "25698481", "CommentCount": "3", "OwnerUserId": "2756719", "LastEditDate": "2014-09-06T09:05:35.150"}, "25698481": {"ViewCount": "99", "Body": "<p>If I have a function like this:</p>\n<pre><code>int addNumbers(int x, int y)\n{\n    return x + y;\n}\n</code></pre>\n<p>and if I use it as such:</p>\n<pre><code>cout &lt;&lt; addNumbers(4, 5) &lt;&lt; endl;\n</code></pre>\n<p>It will return and print <code>9</code>. Using the same <code>cout</code> line above, if I comment out or delete the return in <code>addNumbers</code>, it will return and print <code>1</code>. If I do this:</p>\n<pre><code>int addNumbers(int x, int y)\n{\n    int answer = x + y;\n    //return x + y;\n}\n</code></pre>\n<p>It will automatically return and print <code>9</code>, without me using return. Similarly, I can write <code>int answer = x</code>; and it will return <code>4</code>. I can also write this:</p>\n<pre><code>int addNumbers(int x, int y)\n{\n    int answer = x;\n    answer = 1;\n    //return x + y;\n}\n</code></pre>\n<p>and it will still return 4.</p>\n<p>What exactly is returned and why? It only returns something other than 1 when I use the parameter variables, but it isn't returning the variable answer as shown in the last example because I changed it to 1 and it still returned the value of <code>x (4)</code>. </p>\n", "AcceptedAnswerId": "25698523", "Title": "Function of type int not using return C++", "CreationDate": "2014-09-06T08:42:06.270", "Id": "25698481", "CommentCount": "2", "LastEditDate": "2014-09-06T09:05:21.250", "PostTypeId": "1", "LastEditorUserId": "3905567", "LastActivityDate": "2014-09-07T03:11:16.377", "Score": "2", "OwnerUserId": "4014129", "Tags": "<c++><return><cout><endl>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25698481_25698523_0": {"length": 12, "quality": 1.0, "section_id": 3913}}, "n3337": {"so_25698481_25698523_0": {"length": 12, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_25698481_25698523_0": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "25698488": {"Id": "25698488", "PostTypeId": "2", "Body": "<p>You are observing undefined behavior.  There is no good reason \"why\" the program does that, because it isn't a well-formed program.  It could do anything, including delete itself from disk when run.  Enable compiler warnings and errors (e.g. <code>g++ -Wall -Wextra -Werror</code>) and you will be automatically prevented from writing such code (as you should be).</p>\n", "LastActivityDate": "2014-09-06T08:43:41.780", "CommentCount": "0", "CreationDate": "2014-09-06T08:43:41.780", "ParentId": "25698481", "Score": "0", "OwnerUserId": "4323"}, "25698499": {"Id": "25698499", "PostTypeId": "2", "Body": "<p>You are relying on \"undefined behaviour\". The return value is, for simple types, typically stored in a register, which may also be used in the formation of the result of the calculation. But it may also NOT be used, and you get some arbitrary \"random\" result, and being \"undefined behaviour\", you may also get any other possible operation that your computer may perform - such as crashing or executing some code you didn't want to execute...</p>\n", "LastActivityDate": "2014-09-06T08:44:53.633", "CommentCount": "0", "CreationDate": "2014-09-06T08:44:53.633", "ParentId": "25698481", "Score": "1", "OwnerUserId": "1919155"}, "25706749": {"Id": "25706749", "PostTypeId": "2", "Body": "<p>Thus it is undefined behavior, disassembling your binary may explain why such values are returned.</p>\n<p><code>objdump -d example.bin</code> </p>\n<p>Since the return value is associated with the rax registry, if the compiler uses rax to process the function, the returned value is the value that remains in rax.</p>\n<p>Anyway, you shouldn't do this because compiler optimizations and use of registries isn't known when you write such code. </p>\n", "LastActivityDate": "2014-09-07T03:11:16.377", "CommentCount": "0", "CreationDate": "2014-09-07T03:11:16.377", "ParentId": "25698481", "Score": "0", "OwnerUserId": "2034218"}});