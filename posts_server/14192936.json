post_cb({"bq_ids": {"n4140": {"so_14192936_14192936_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 87}, "so_14192936_14192936_1": {"length": 15, "quality": 0.9375, "section_id": 87}, "so_14192936_14192936_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 87}}, "n3337": {"so_14192936_14192936_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 82}, "so_14192936_14192936_1": {"length": 15, "quality": 0.9375, "section_id": 82}, "so_14192936_14192936_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 82}}}, "14193765": {"Id": "14193765", "PostTypeId": "2", "Body": "<p>I think that the problem is that the expression you use are not actually pointers but arrays, and the pointer decay only works for <code>name1</code>. It is most likely a compiler bug, as kindly @KonradRudolph pointed out in the comment, section 14.3.2 of the C++11 standard allows it, and there is nothing essentially different between <code>name1</code>, <code>name2</code> and <code>name3</code>.</p>\n<p>As a workaround, the following will compile with GCC 4.7.2 using <code>-std=c++11</code>:</p>\n<pre><code>template&lt;char const *p&gt; void f()\n{\n}\n\nchar name1[] = \"Hi\";\nstatic char name2[]= \"Hi\";\nconst static char name3[]= \"Hi\";\n\nint main()\n{\n    f&lt;(char const*)&amp;name1&gt;();\n    f&lt;(char const*)&amp;name2&gt;();\n    f&lt;(char const*)&amp;name3&gt;();\n}\n</code></pre>\n<p>In C++98 mode it does not compile because the result of a cast is never a constant expression, while in C++11 it may be.</p>\n", "CommentCount": "3", "LastEditorUserId": "865874", "LastActivityDate": "2013-01-07T10:25:12.843", "CreationDate": "2013-01-07T10:12:39.687", "ParentId": "14192936", "Score": "3", "OwnerUserId": "865874", "LastEditDate": "2013-01-07T10:25:12.843"}, "14192936": {"ViewCount": "1061", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_14192936_14192936_2\">$14.3.2 - \"... A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n</blockquote>\n<p id=\"so_14192936_14192936_1\">...a constant expression (5.19) that designates the address of an object with static storage duration and <strong>external or internal</strong> linkage or a function with external or internal linkage...\"</p>\n</blockquote>\n<p>In the code shown below, I fail to understand why 'name2' and 'name3' are not allowed as non type template arguments. I am using gcc 4.7.2 on Windows.</p>\n<p>Both 'name2' and 'name3' are names of array and hence are constant expressions. Further 'name2' is having internal linkage and 'name3' has both static and internal linkage.</p>\n<pre><code>template&lt;char const *p&gt; void f()\n{\n\n}\n\nchar name1[] = \"Hi\";\nstatic char name2[]= \"Hi\";\nconst static char name3[]= \"Hi\";\nchar *name4 = \"Hi\";\n\nint main()\n{\n    f&lt;name1&gt;();\n    f&lt;name2&gt;();\n    f&lt;name3&gt;();\n    f&lt;name4&gt;();\n}\n</code></pre>\n", "AcceptedAnswerId": "14193677", "Title": "template non type arguments", "CreationDate": "2013-01-07T09:18:34.763", "Id": "14192936", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-01-07T23:27:23.033", "Score": "11", "OwnerUserId": "418110", "Tags": "<c++><templates><c++11><arguments><linkage>", "AnswerCount": "2"}, "14193677": {"Id": "14193677", "PostTypeId": "2", "Body": "<p>As @Nawaz correctly guessed, this is an implementation bug, not an esoteric corner of the standard. </p>\n<p>Specifically, gcc seems to have trouble with it. Barring the last <code>name4</code> which is against the standard, the rest of it compiles fine with <a href=\"http://liveworkspace.org/code/JDZqy%2450\" rel=\"nofollow\">clang</a></p>\n", "CommentCount": "7", "LastEditorUserId": "1520364", "LastActivityDate": "2013-01-07T23:27:23.033", "CreationDate": "2013-01-07T10:07:02.537", "ParentId": "14192936", "Score": "5", "OwnerUserId": "1520364", "LastEditDate": "2013-01-07T23:27:23.033"}});