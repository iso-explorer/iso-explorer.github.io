post_cb({"bq_ids": {"n4140": {"so_30524479_30526469_1": {"length": 6, "quality": 1.0, "section_id": 6681}, "so_30524479_30526469_3": {"length": 12, "quality": 1.0, "section_id": 6681}, "so_30524479_30526469_4": {"length": 10, "quality": 1.0, "section_id": 6681}, "so_30524479_30526469_5": {"length": 13, "quality": 0.8666666666666667, "section_id": 6682}, "so_30524479_30526469_2": {"length": 11, "quality": 1.0, "section_id": 6681}}, "n3337": {"so_30524479_30526469_3": {"length": 12, "quality": 1.0, "section_id": 6436}, "so_30524479_30526469_1": {"length": 6, "quality": 1.0, "section_id": 6436}, "so_30524479_30526469_2": {"length": 11, "quality": 1.0, "section_id": 6436}, "so_30524479_30526469_4": {"length": 10, "quality": 1.0, "section_id": 6436}, "so_30524479_30526469_5": {"length": 13, "quality": 0.8666666666666667, "section_id": 6437}}, "n4659": {"so_30524479_30526469_3": {"length": 12, "quality": 1.0, "section_id": 8156}, "so_30524479_30526469_1": {"length": 6, "quality": 1.0, "section_id": 8156}, "so_30524479_30526469_2": {"length": 11, "quality": 1.0, "section_id": 8156}, "so_30524479_30526469_4": {"length": 10, "quality": 1.0, "section_id": 8156}, "so_30524479_30526469_5": {"length": 13, "quality": 0.8666666666666667, "section_id": 8157}}}, "30524479": {"ViewCount": "131", "Body": "<p>The rule I uses to quickly determine if a derived-to-base conversion is legal is to check if, in the context of the conversion, the <code>derived</code> IS-A <code>base</code> (i.e., <code>derived</code> provides access to the public API of <code>base</code>).<br/>\nIt is better formulated in C++ Primer (5th edition) as:</p>\n<blockquote>\n<p id=\"so_30524479_30524479_0\">For any given point in your code, if a <code>public</code>member of the base class would be accessible, then the derived-to-base conversion is also accessible, and not otherwise.</p>\n</blockquote>\n<p>Now let's imagine a class hierarchy as follows:</p>\n<pre><code>class Base\n{\npublic:\n    int mem;\n};\n\nclass Derived : protected Base\n{\n    static void f(Derived *d)\n    {\n        d-&gt;mem; // OK, in this context, a Derived IS-A Base\n        Base *b = d;\n    }\n};\n\nint main()\n{\n    Derived d;\n    //d.mem;        // Compilation error : in this context a Derived IS-NOT-A Base\n    //Base *b = &amp;d; // Compilation error too : consistent with the intuitive rule\n    return 0;\n}\n\nclass Derived_Derived : public Derived\n{\n    static void f(Derived *d)\n    {\n        //d-&gt;mem;    // Compilation error : in this context a Derived IS-NOT-A Base (as expected)\n        Base *b = d; // COMPILATION OK : which seems to violate the rule above\n    }\n};\n</code></pre>\n<p>The result that seems to violate the rule cited above is in the class <code>Derived_Derived</code>, function <code>f</code>:<br/>\nThe conversion from <code>d</code>to <code>b</code>is accepted by the compiler.\nIn this context, it is not possible to access the public API defined by <code>Base</code>through a pointer to a <code>Derived</code>, because of the <code>protected</code>inheritance. Yet the derived-to-base conversion works.</p>\n<p>It was tested on a few compilers to give the same results, so I assume it is a standard defined behaviour. What is the rationale for allowing that ?</p>\n<hr>\n<h1>Edit</h1>\n<p><strong>Arne Vogel</strong>'s answer confirms that it is a standard defined behaviour, with relevant extract and explanations.<br/>\nYet I cannot find the rationale behind condition #3 of \u00a711.2/4 (authorising the last conversion), which is usually useful to help in remembering the rule.</p>\n<p><strong>The question regarding the rationale is still open.</strong></p>\n</hr>", "Title": "What is the rationale for allowing this derived-to-base conversion (when it seems to violate IS-A)?", "CreationDate": "2015-05-29T08:12:34.850", "LastActivityDate": "2015-06-03T10:43:27.330", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-06-03T10:43:27.330", "LastEditorUserId": "1027706", "Id": "30524479", "Score": "4", "OwnerUserId": "1027706", "Tags": "<c++><inheritance><type-conversion>", "AnswerCount": "2"}, "30526469": {"Id": "30526469", "PostTypeId": "2", "Body": "<p>The author of C++ Primer subtly misquotes the ISO C++ standard. Quoting from N3376 (late/final working draft of C++11):</p>\n<blockquote>\n<p id=\"so_30524479_30526469_0\">\u00a711.2/4 A base class <code>B</code> of <code>N</code> is accessible at <em>R</em>, if</p>\n<p id=\"so_30524479_30526469_1\">\u2014 an invented public member of <code>B</code> would be a public member of <code>N</code>, or</p>\n<p id=\"so_30524479_30526469_2\">\u2014 <em>R</em> occurs in a member or friend of class <code>N</code>, and an invented public\n  member of <code>B</code> would be a private or protected member of <code>N</code>, or</p>\n<p id=\"so_30524479_30526469_3\">\u2014 <em>R</em> occurs in a member or friend of a class <code>P</code> derived from <code>N</code>, and an\n  invented public member of <code>B</code> would be a private or protected member of\n  <code>P</code>, or</p>\n<p id=\"so_30524479_30526469_4\">\u2014 there exists a class <code>S</code> such that <code>B</code> is a base class of <code>S</code> accessible\n  at <em>R</em> and <code>S</code> is a base class of <code>N</code> accessible at <em>R</em>.</p>\n</blockquote>\n<p>In the example you give, the third condition holds and the base class is <em>accessible</em>. Continuing\u2026</p>\n<blockquote>\n<p id=\"so_30524479_30526469_5\">5 If a base class is accessible, one can implicitly convert a pointer\n  to a derived class to a pointer to that base class (4.10, 4.11).</p>\n</blockquote>\n<p>This means the implicit conversion is allowed by the standard and a compliant compiler has to support it.</p>\n<p>If the text from C++ Primer were law, the base class conversion should be equally forbidden as the access to <code>mem</code> because an invented public member would not be accessible (cf. \u00a711.2/5, \u00a711.4) any more than <code>mem</code>. However, that is not what the standard says about the \"invented public member\". In the above-mentioned condition #3 of \u00a711.2/4, it says that the base class is accessible if the invented public member would be \"a private or protected member of P\", and this is clearly the case. It doesn't require said invented private or protected member to be actually accessible.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2015-05-29T11:38:19.630", "Score": "5", "CreationDate": "2015-05-29T09:50:38.720", "ParentId": "30524479", "CommentCount": "2", "LastEditDate": "2015-05-29T11:38:19.630", "OwnerUserId": "4083309"}, "30525125": {"Id": "30525125", "PostTypeId": "2", "Body": "<p>You used protected inheritance to define class Derived. So, public members of Base class becomes protected in the Derived class. Hence, you cannot access the base member variables like d.m or d-&gt;m from outside the class. \nBut it will be possible to access them from the member functions, as the member functions have no restrictions accessing private or protected members of the class. The access restrictions is only applicable to the world outside of the class. </p>\n<pre><code>   class Derived_Derived : public Derived\n    {\n        static void f(Derived_Derived *d)\n        {\n            d-&gt;mem;    // Will work\n            Base *b = d; // COMPILATION OK : which seems to violate the rule above\n        }\n    };\n\n   class Derived_Derived : public Derived\n    {\n        static void f(Derived *din)\n        {\n            d = (Derived_Derived *) din; // Will work too, of course use dynamic_cast when if class is polymorphic\n            d-&gt;mem;    // Will work\n            Base *b = d; // COMPILATION OK : which seems to violate the rule above\n        }\n    };\n</code></pre>\n<p>It boils down to a simple rule. All the members private/protected/public of a class are accessible to its member functions. Consider the function f from Derived_Derived, it will have access to all members of any Derived_Derived class objects passed to it. Because within the context of  function Derived_Derived::f,  the access restrictions specific to Derived_Derived class is applied and which gives access to all the members of Derived_Derived. \nIf Derived_Derived::f takes a parameter of type Derived, in the context of f,   the private or protected members won't be accessible, because on the passed object the access restriction specific to class Derived will be applied and it doesn't matter if Derived_Derived was derived from Derived.</p>\n", "LastEditorUserId": "1898070", "LastActivityDate": "2015-05-29T10:32:00.693", "Score": "-2", "CreationDate": "2015-05-29T08:46:32.677", "ParentId": "30524479", "CommentCount": "3", "LastEditDate": "2015-05-29T10:32:00.693", "OwnerUserId": "1898070"}});