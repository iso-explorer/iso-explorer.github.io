post_cb({"19603927": {"ViewCount": "185", "Body": "<p>I have a class which looks like this</p>\n<pre><code>class A\n{\n    int b;\n\n    void B()\n    {\n        int c;\n    } \n}\n\n\nint main()\n{\n    A asdf;\n\n    A fdsa = new A();\n}\n</code></pre>\n<p>What's the difference between asdf and fdsa instances of class A? In both cases which goes to the stack and which goes to the heap?</p>\n<p>b variable inside of class A is a global variable and should get a space in heap no matter how the class was declared, correct?</p>\n<p>Also do copies of function B is assigned to the heap and executed from there?</p>\n", "AcceptedAnswerId": "19603950", "Title": "OOP and heap/stack", "CreationDate": "2013-10-26T07:00:24.730", "Id": "19603927", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-26T07:16:18.363", "LastEditorUserId": "1373856", "LastActivityDate": "2013-10-26T10:22:41.187", "Score": "0", "OwnerUserId": "2237158", "Tags": "<java><c++><oop>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_19603927_19604373_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 3345}}, "n3337": {"so_19603927_19604373_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 3215}}}, "19603963": {"PostTypeId": "2", "Body": "<p>First of all fdsa should be a pointer.</p>\n<pre><code>A a_on_stack; // Destroys when going out of scope\nA* a_on_heap = new A(); // Need to call \"delete a_on_head;\" to remove from memory\n</code></pre>\n<p>Hope this helps</p>\n", "LastActivityDate": "2013-10-26T07:05:30.433", "Id": "19603963", "CommentCount": "0", "CreationDate": "2013-10-26T07:05:30.433", "ParentId": "19603927", "Score": "1", "OwnerUserId": "2895654"}, "19604373": {"PostTypeId": "2", "Body": "<p>There are no <em>stack</em> or <em>heap</em> places in memory in C++ standard. They're implementation specifics.</p>\n<pre><code>A asdf;\n</code></pre>\n<p>It's a automatic object which allocates and destroys automatically.</p>\n<pre><code>A *fdsa = new A();\n</code></pre>\n<p>It's a dynamic and non-automatic object which the allocating and destroying should manage by you.</p>\n<hr>\n<p>The only thing about <em>stack</em> in standard is,  <em>\u201cstack unwinding.\u201d</em> :</p>\n<blockquote>\n<p id=\"so_19603927_19604373_0\">The process of calling destructors for automatic objects constructed\n  on the path from a try block to the point where an exception is thrown\n  is called \u201cstack unwinding. [\u00a715.2/3]</p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-10-26T07:57:52.950", "Id": "19604373", "CommentCount": "0", "CreationDate": "2013-10-26T07:57:52.950", "ParentId": "19603927", "Score": "1", "OwnerUserId": "952747"}, "19603960": {"PostTypeId": "2", "Body": "<p>Assuming <code>fsda</code> is a declared as <code>A*</code> (i.e. a pointer):</p>\n<ul>\n<li><code>asdf.b</code> is on the stack.</li>\n<li><code>fsda-&gt;b</code> is on the heap.</li>\n<li>Whenever you call <code>A::B()</code>, <code>c</code> goes on the stack.</li>\n</ul>\n", "LastActivityDate": "2013-10-26T10:22:41.187", "LastEditorUserId": "367273", "Id": "19603960", "CommentCount": "2", "CreationDate": "2013-10-26T07:05:14.917", "ParentId": "19603927", "Score": "1", "OwnerUserId": "367273", "LastEditDate": "2013-10-26T10:22:41.187"}, "19603950": {"PostTypeId": "2", "Body": "<p><code>asdf</code> goes to stack while <code>fdsa</code> goes to heap.</p>\n", "LastActivityDate": "2013-10-26T07:21:31.377", "LastEditorUserId": "2866073", "Id": "19603950", "CommentCount": "1", "CreationDate": "2013-10-26T07:03:44.980", "ParentId": "19603927", "Score": "2", "OwnerUserId": "2866073", "LastEditDate": "2013-10-26T07:21:31.377"}});