post_cb({"3100560": {"ParentId": "3100365", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>because -1 gets casted to <code>size_t</code> and this is an unsigned data type - so <code>(size_t)-1 == 4294967295</code> (on a 32bit system) which is definitely larger than 4</p>\n<p>if you add <code>-Wall</code> to the gcc settings for example you get a warning that you are comparing a signed and an unsigned data type</p>\n", "OwnerUserId": "276076", "LastEditorUserId": "2932052", "LastEditDate": "2017-09-13T09:55:50.577", "Id": "3100560", "Score": "4", "CreationDate": "2010-06-23T09:51:31.957", "LastActivityDate": "2017-09-13T09:55:50.577"}, "bq_ids": {"n4140": {"so_3100365_3100936_1": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}, "so_3100365_3100936_0": {"section_id": 6138, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_3100365_3100936_1": {"section_id": 18, "quality": 0.6060606060606061, "length": 20}, "so_3100365_3100936_0": {"section_id": 5902, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_3100365_3100936_1": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}, "so_3100365_3100936_0": {"section_id": 7635, "quality": 0.8888888888888888, "length": 8}}}, "8441265": {"ParentId": "3100365", "CommentCount": "1", "Body": "<p>It's simple and sad. In C/C++:</p>\n<ol>\n<li>most of the time, unsigned integer types have the semantic of modular integers (they represent equivalence classes)</li>\n<li>comparisons of unsigned integer types have the semantic of usual integer ordering, so that <code>1U &lt; 2U</code> (IOW <code>0U</code> is the smallest <code>unsigned</code> value)</li>\n<li><code>sizeof</code> has type <code>size_t</code></li>\n<li><code>size_t</code> is an unsigned integer type </li>\n<li>Point (1) implies that mixed arithmetic computations involving a signed and an unsigned integer are done in unsigned, modular arithmetic: this is the only possibility without violating \"unsigned mean modular\" rule. It's trivial to convert an integer to the equivalence class of integers equivalent to it. (Whereas going the other way requires the choice of an integer to represent the equivalence class.)</li>\n<li>Point (5) implies that <code>-1 &lt; 1U</code> is interpreted as <code>unsigned(-1) &lt; 1U</code>, and <code>unsigned(-1)</code> = <code>- 1U</code>, and obviously <code>- 1U &lt; 1U</code>, so <code>-1 &lt; 1U</code> is true.</li>\n<li>Points (1,3,4) imply that <code>sizeof something</code> acts (mostly) as an equivalent class (!!!).</li>\n<li>All this imply that <code>-1 &lt; sizeof something</code></li>\n</ol>\n<p>The conclusion: this is a design error inherited from C.</p>\n<p><strong>Rule:</strong></p>\n<p>Only use unsigned types for modular arithmetic, bits manipulations (<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>~</code> operators), byte manipulations (<code>unsigned char</code> means \"byte\" in C/C++), and characters (<code>unsigned char</code> means character in C/C++).</p>\n<p><strong>Do not use unsigned types to do arithmetic.</strong></p>\n<p>If a function expects an integer value that should never be negative, take a signed integer, and optionally check in the function that the value is in range.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "8441265", "Score": "2", "CreationDate": "2011-12-09T04:57:50.180", "LastActivityDate": "2011-12-09T04:57:50.180"}, "3100365": {"CommentCount": "0", "AcceptedAnswerId": "3100936", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2010-06-23T09:16:40.083", "LastActivityDate": "2017-09-13T09:55:50.577", "LastEditDate": "2011-12-09T04:59:59.663", "ViewCount": "1825", "FavoriteCount": "0", "Title": "Why is \u22121 > sizeof(int)?", "Id": "3100365", "Score": "17", "Body": "<p>Consider the following code:</p>\n<pre><code>template&lt;bool&gt; class StaticAssert;\ntemplate&lt;&gt; class StaticAssert&lt;true&gt; {};\nStaticAssert&lt; (-1 &lt; sizeof(int)) &gt; xyz1; // Compile error\nStaticAssert&lt; (-1 &gt; sizeof(int)) &gt; xyz2; // OK\n</code></pre>\n<p>Why is <code>-1 &gt; sizeof(int)</code> true?</p>\n<ol>\n<li>Is it true that <code>-1</code> is promoted to <code>unsigned(-1)</code> and then <code>unsigned(-1) &gt; sizeof(int)</code>.</li>\n<li>Is it true that <code>-1 &gt; sizeof(int)</code> is equivalent to <code>-1 &gt; size_t(4)</code> if sizeof(int) is 4. If this is so why <code>-1 &gt; size_t(4)</code> is false?</li>\n</ol>\n<p><strong>Is this C++ standard comformant?</strong></p>\n", "Tags": "<c++><type-conversion><sizeof><unsigned><modular>", "OwnerUserId": "124161", "AnswerCount": "4"}, "3100936": {"ParentId": "3100365", "CommentCount": "4", "Body": "<p>The following is how standard (ISO 14882) explains abort -1 &gt; sizeof(int)</p>\n<p>Relational operator `&gt;' is defined in 5.9 (expr.rel/2)</p>\n<blockquote>\n<p id=\"so_3100365_3100936_0\">The usual arithmetic conversions are\n  performed on operands of arithmetic or\n  enumeration type. ...</p>\n</blockquote>\n<p>The usual arithmetic conversions is defined in 5 (expr/9)</p>\n<p>... The pattern is called the usual arithmetic conversions, which are defined as following:</p>\n<ul>\n<li>If either operand is of type long\ndouble, ...</li>\n<li>Otherwise, if either operand is dobule, ...</li>\n<li>Otherwise, if either operand is float, ...</li>\n<li>Otherwise, the integral promotions shall be performed on both operands.</li>\n<li>...</li>\n</ul>\n<p>The integral promotions is defined in 4.5 (conv.prom/1)</p>\n<blockquote>\n<p id=\"so_3100365_3100936_1\">An rvalue of type char, signed char,\n  unsigned char, short int, or unsigned\n  short int can be converted to an\n  rvalue of type int if int can\n  represent all the values of the source\n  type; otherwise, the source rvalue can\n  be converted to an rvalue of type\n  unsigned int.</p>\n</blockquote>\n<p>The result of sizeof is defined in 5.3.3 (expr.sizeof/6)</p>\n<blockquote>\n<p id=\"so_3100365_3100936_2\">The result is a constant of type\n  size_t</p>\n</blockquote>\n<p>size_t is defined in C standard (ISO 9899), which is <strong>unsigned integer type</strong>.</p>\n<p>So for <code>-1 &gt; sizeof(int)</code>, the &gt; triggers usual arithmetic conversions. The usual arithmetic conversion converts -1 to unsigned int because int cannot represent all the value of <code>size_t</code>. <code>-1</code> becomes a very large number depend on platform. So <code>-1 &gt; sizeof(int)</code> is <code>true</code>.</p>\n", "OwnerUserId": "79816", "PostTypeId": "2", "Id": "3100936", "Score": "14", "CreationDate": "2010-06-23T10:50:24.507", "LastActivityDate": "2010-06-23T10:50:24.507"}, "3100381": {"ParentId": "3100365", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Because unsigned is stronger then signed and -1 converted to unsigned value as of <code>size_t</code> , so actually <code>-1 == 0xFFFFFFFF &gt; 4</code></p>\n<p>This is how it should work according to C++ standard</p>\n", "OwnerUserId": "66522", "LastEditorUserId": "66522", "LastEditDate": "2010-06-23T12:31:07.327", "Id": "3100381", "Score": "14", "CreationDate": "2010-06-23T09:19:26.247", "LastActivityDate": "2010-06-23T12:31:07.327"}});