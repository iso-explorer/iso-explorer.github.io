post_cb({"9429156": {"ViewCount": "335", "Body": "<p>I have a doubt in Left Shift Operator</p>\n<pre><code>int i = 1;\ni &lt;&lt;= (sizeof (int) *8);\ncout &lt;&lt; i;\n</code></pre>\n<p>It prints 1.</p>\n<ol>\n<li>i has been initialized to 1.</li>\n<li>And while moving the bits till the size of the integer, it fills the LSB with 0's and as 1 crosses the limit of integer, i was expecting the output to be 0. </li>\n</ol>\n<p>How and Why it is 1?</p>\n", "Title": "By Left shifting, can a number be set to ZERO", "CreationDate": "2012-02-24T10:28:17.990", "LastActivityDate": "2012-02-24T11:17:51.243", "CommentCount": "4", "PostTypeId": "1", "Id": "9429156", "Score": "4", "OwnerUserId": "1230496", "Tags": "<c++><c><bit-manipulation><bitwise-operators><bit-shift>", "AnswerCount": "4"}, "9429228": {"Id": "9429228", "PostTypeId": "2", "Body": "<p>Let's say <code>sizeof(int)</code> is 4 on your platform. Then the expression becomes:</p>\n<pre><code>i = i &lt;&lt; 32;\n</code></pre>\n<p>The standard says:</p>\n<blockquote>\n<p id=\"so_9429156_9429228_0\">6.5.7-3</p>\n<p id=\"so_9429156_9429228_1\">If the value of the right operand is negative or is <strong>greater than or\n  equal to the width of the promoted left operand</strong>, the behavior is\n  unde\ufb01ned.</p>\n</blockquote>\n", "LastActivityDate": "2012-02-24T10:32:46.323", "CommentCount": "6", "CreationDate": "2012-02-24T10:32:46.323", "ParentId": "9429156", "Score": "14", "OwnerUserId": "714501"}, "9429411": {"Id": "9429411", "PostTypeId": "2", "Body": "<p>Expanding on the <a href=\"https://stackoverflow.com/a/9429228/968261\">previous answer</a>...</p>\n<p>On the x86 platform your code would get compiled down to something like this:</p>\n<pre><code>; 32-bit ints:\nmov cl, 32\nshl dword ptr i, cl\n</code></pre>\n<p>The CPU will shift the dword in the variable <code>i</code> by the value contained in the <code>cl</code> register modulo 32. So, 32 modulo 32 yields 0. Hence, the shift doesn't really occur. And that's perfectly fine per the C standard. In fact, what the C standard says in 6.5.7-3 is because the aforementioned CPU behavior was quite common back in the day and influenced the standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-24T11:17:51.243", "Score": "2", "CreationDate": "2012-02-24T10:46:29.870", "ParentId": "9429156", "CommentCount": "3", "OwnerUserId": "968261", "LastEditDate": "2017-05-23T12:12:08.043"}, "bq_ids": {"n4140": {"so_9429156_9429228_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 6146}}, "n3337": {"so_9429156_9429228_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 5909}}, "n4659": {"so_9429156_9429228_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 7642}}}, "9429626": {"Id": "9429626", "PostTypeId": "2", "Body": "<p>As already mentioned by others, according to C standard the behavior of the shift is undefined.</p>\n<p>That said, the program prints 1. A low-level explanation of why it prints 1 is as follows:</p>\n<p>When compiling without optimizations the compiler (GCC, clang) emits the <code>SHL</code> instruction:</p>\n<pre><code>...\nmov    $32,%ecx\nshll   %cl,0x1c(%esp)\n...\n</code></pre>\n<p>The Intel documentation for <code>SHL</code> instruction says:</p>\n<blockquote>\n<p id=\"so_9429156_9429626_0\"><strong>SAL/SAR/SHL/SHR\u2014Shift</strong></p>\n<p id=\"so_9429156_9429626_1\">The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used).</p>\n</blockquote>\n<p>Masking the shift count 32 (binary 00100000) to 5 bits yields 0 (binary 00000000). Therefore the <code>shll   %cl,0x1c(%esp)</code> instruction isn't doing any shifting and leaves the value of <code>i</code> unchanged.</p>\n", "OwnerDisplayName": "user811773", "LastActivityDate": "2012-02-24T11:02:54.197", "Score": "1", "CreationDate": "2012-02-24T11:02:54.197", "ParentId": "9429156", "CommentCount": "2"}, "9429309": {"Id": "9429309", "PostTypeId": "2", "Body": "<p>As <a href=\"https://stackoverflow.com/a/9429228/430766\">cnicutar said</a>, your example exhibits undefined behaviour. That means that the compiler is free to do whatever the vendor seems fit, including <a href=\"http://catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow noreferrer\">making demons fly out your nose</a> or just doing nothing to the value at hand.</p>\n<p>What you <em>can</em> do to convince yourself, that left shifting by the number of bits will produce <code>0</code> is this:</p>\n<pre><code>int i = 1;\ni &lt;&lt;= (sizeof (int) *4);\ni &lt;&lt;= (sizeof (int) *4);\ncout &lt;&lt; i;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-24T10:38:34.387", "Score": "3", "CreationDate": "2012-02-24T10:38:34.387", "ParentId": "9429156", "CommentCount": "3", "OwnerUserId": "430766", "LastEditDate": "2017-05-23T12:27:30.993"}});