post_cb({"34811638": {"ParentId": "34811364", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You think about it wrong. <code>on_receipt</code> is not a \"place holder for a function name\" it is a typename you introduce. Think about the usage.</p>\n<p>You would use it like <code>on_receipt function_variable;</code>, so your interpretation is actually misleading, because the \"name\" by which you would refer your function is not <code>on_receipt</code> but <code>function_variable</code>.</p>\n<p>I would say that the <code>typedef</code> syntax for functions is rather odd. In <code>using</code> style you have the type name on one side, and the thing defining it on the the other. In the <code>typedef</code> style you have it interleaved.</p>\n<p><code>typedef</code> kinda looks like a function declaration, but it really isn't; it's a type declaration. I find that messy.</p>\n<p>Oh, of course, those statements are equivalent.</p>\n", "OwnerUserId": "1133179", "LastEditorUserId": "1133179", "LastEditDate": "2016-01-15T13:08:28.750", "Id": "34811638", "Score": "0", "CreationDate": "2016-01-15T12:58:43.097", "LastActivityDate": "2016-01-15T13:08:28.750"}, "34811672": {"ParentId": "34811364", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes they are:</p>\n<blockquote>\n<p id=\"so_34811364_34811672_0\"><strong>[dcl.typedef]</strong> </p>\n<p id=\"so_34811364_34811672_1\">2 A typedef-name can also be introduced by an\n  alias-declaration. The identifier following the <code>using</code> keyword becomes\n  a typedef-name and the optional attribute-specifier-seq following the\n  identifier appertains to that typedef-name. It has the same semantics\n  as if it were introduced by the <code>typedef</code> specifier. In particular, it\n  does not define a new type.</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a3c00713d81cfb4e\" rel=\"nofollow\"><strong>Live Example</strong></a></p>\n<pre><code>#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\nint main()\n{\n    using on_receipt1 = void (const std::string);    \n    typedef void on_receipt2(const std::string);\n    static_assert(std::is_same&lt;on_receipt1, on_receipt2&gt;::value, \"\");\n}\n</code></pre>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2016-01-15T13:04:27.967", "Id": "34811672", "Score": "3", "CreationDate": "2016-01-15T13:00:46.927", "LastActivityDate": "2016-01-15T13:04:27.967"}, "34811364": {"CommentCount": "0", "ViewCount": "87", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2016-01-15T12:43:26.657", "LastActivityDate": "2016-01-15T13:08:28.750", "Title": "Is this using alias for a function type (not pointer) the same as this typedef", "AcceptedAnswerId": "34811672", "LastEditDate": "2016-01-15T13:01:47.560", "Id": "34811364", "Score": "1", "Body": "<p>Are these the same?</p>\n<pre><code>using on_receipt = void (const string);\n\ntypedef void on_receipt(const string);\n</code></pre>\n<p>These are not aliasing a function pointer, but rather an actual function type. They both compile fine. What seems odd is that the <code>typedef</code> version at least has the placeholder for the name of the function, but since the <code>using</code> moves this placeholder before the <code>=</code>, there is nothing separating the return and the parameters, which looks like it could be incorrect or misleading.</p>\n", "Tags": "<c++><c++11><typedef><using>", "OwnerUserId": "3758484", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34811364_34811672_1": {"section_id": 5408, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_34811364_34811672_1": {"section_id": 5203, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_34811364_34811672_1": {"section_id": 6830, "quality": 0.9655172413793104, "length": 28}}}});