post_cb({"9954451": {"Id": "9954451", "PostTypeId": "2", "Body": "<p>While <code>nullptr</code> is a new addition to the language itself, <code>std::nullptr_t</code> is just an alias of an unnamed type, the alias declared in <code>cstddef</code> like this:</p>\n<pre><code>typedef decltype(nullptr) nullptr_t;\n</code></pre>\n<p>While <code>nullptr_t</code>, being a typedef and not a language keyword, is not listed as a fundamental type, it is specified to behave as a fundamental type (and not, for example, as a pointer type or a class type).  Therefore it does not have a default constructor, but you can still declare a variable like you have done.  Your variable is not initialized and I wonder what its use could be and what error message you exactly got from <code>clang</code>.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/5547664/what-c0x-headers-are-supposed-to-define-nullptr\">here</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-31T18:51:15.670", "Score": "1", "CreationDate": "2012-03-31T08:51:04.337", "ParentId": "9953068", "CommentCount": "3", "OwnerUserId": "1235565", "LastEditDate": "2017-05-23T12:24:49.367"}, "bq_ids": {"n4140": {"so_9953068_9954287_2": {"length": 18, "quality": 0.72, "section_id": 39}, "so_9953068_9954287_1": {"length": 5, "quality": 0.625, "section_id": 6711}}, "n3337": {"so_9953068_9954287_2": {"length": 24, "quality": 0.96, "section_id": 36}, "so_9953068_9954287_1": {"length": 5, "quality": 0.625, "section_id": 6466}}, "n4659": {"so_9953068_9954287_2": {"length": 18, "quality": 0.72, "section_id": 39}, "so_9953068_9954287_1": {"length": 5, "quality": 0.625, "section_id": 8179}}}, "9953068": {"ViewCount": "2434", "Body": "<p>I can't tell from the C++11 Standard if nullptr_t has a default constructor. In other words, is the following valid?:</p>\n<pre><code>nullptr_t n; \n</code></pre>\n<p>GCC and VC++ allow the above code, but clang does not. I can't find anything in the Standard specifying that it doesn't have a default constructor, and what I can find suggests that it ought to. This matters to me because I'm writing a basic fallback implementation of nullptr for older compiler support and need to know if I need to give it a default constructor.</p>\n", "Title": "Is nullptr_t a default constructible type?", "CreationDate": "2012-03-31T04:38:32.107", "LastActivityDate": "2012-04-01T07:11:45.497", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-03-31T11:45:48.063", "LastEditorUserId": "577603", "Id": "9953068", "Score": "16", "OwnerUserId": "725009", "Tags": "<c++><gcc><clang><nullptr>", "AnswerCount": "2"}, "9954287": {"Id": "9954287", "PostTypeId": "2", "Body": "<h1>What the Standard says</h1>\n<p>The standard says (18.2)</p>\n<blockquote>\n<p id=\"so_9953068_9954287_0\">nullptr_t is defined as follows:</p>\n<pre><code>namespace std {\n   typedef decltype(nullptr) nullptr_t;\n}\n</code></pre>\n<p id=\"so_9953068_9954287_1\">The type for which nullptr_t is a synonym has the characteristics described in 3.9.1 and\n  4.10.</p>\n</blockquote>\n<p>Where 3.9.1 basically says it should be of the same size as <code>void*</code> and 4.10 specifies the conversion rules for <code>nullptr</code>.</p>\n<p><strong>Edit:</strong> 3.9.9 furthermore explicitly states that <code>nullptr_t</code> is a scalar type, which means  the expected initialization rules for built-in types from 8.5 apply:</p>\n<ul>\n<li>Default-initialization (<code>nullptr_t n;</code>), which leaves the value of <code>n</code> undefined. As Johannes Schaub pointed out correctly, this compiles fine with the newest version of Clang.</li>\n<li>Value-initialization (<code>nullptr_t n = nullptr_t();</code>), which initializes n to 0.</li>\n</ul>\n<p>This behavior is identical to e.g. <code>int</code>, so <code>nullptr_t</code> is definitely default-constructible.\nThe interesting question here is: What does it mean for <code>nullptr_t</code> to have undefined value? At the end of the day, there is only one meaningful possible value for <code>nullptr_t</code>, which is <code>nullptr</code>. Furthermore the type itself is only defined through the semantics of the <code>nullptr</code>literal. Do these semantics still apply for an unitialized value?</p>\n<h1>Why that question doesn't matter in practice</h1>\n<p>You don't want to declare a new variable of type <code>nullptr_t</code>. The only meaningful semantic of that type is already expressed through the <code>nullptr</code> literal, so whenever you would use your custom variable of type <code>nullptr_t</code>, you can just as well use <code>nullptr</code>.</p>\n<h1>What does matter in practice</h1>\n<p>The only exception to this comes from the fact that you can take non-type template parameters of type <code>nullptr_t</code>. For this case, it is useful to know which values can convert to <code>nullptr_t</code>, which is described in 4.10:</p>\n<blockquote>\n<p id=\"so_9953068_9954287_2\">A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. [...]\n  A null pointer constant of integral type can be converted to a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Which basically does just what you'd expect: You can write</p>\n<pre><code>nullptr_t n = 0;    // correct: 0 is special\n</code></pre>\n<p>but not</p>\n<pre><code>nullptr_t n = 42;   // WRONG can't convert int to nullptr_t\n</code></pre>\n<p>Both gcc 4.6 and Clang SVN get this right.</p>\n", "LastEditorUserId": "577603", "LastActivityDate": "2012-04-01T07:11:45.497", "Score": "17", "CreationDate": "2012-03-31T08:22:48.090", "ParentId": "9953068", "CommentCount": "21", "OwnerUserId": "577603", "LastEditDate": "2012-04-01T07:11:45.497"}});