post_cb({"34566193": {"ParentId": "34562865", "CommentCount": "0", "Body": "<p>One might be tempted to make the copy-assignment operator return <code>void</code> if you won't ever need chained assignments (as shown in the other answers) anyway. After all, chained assignments are often hard to read and understand, so not allowing them might be considered an <em>improvement</em>.</p>\n<p>However, an often overlooked aspect is that <code>void operator=(Poly&amp; const)</code> means that your type would no longer fulfuill the <a href=\"http://en.cppreference.com/w/cpp/concept/CopyAssignable\" rel=\"nofollow\"><strong><code>CopyAssignable</code> concept</strong></a>, which requires a <code>T&amp;</code> return type.</p>\n<p>A type which does not fulfill the <code>CopyAssignable</code> concept cannot be officially used for some standard-container operations, for example <code>std::vector::insert</code>, which means that the following seemingly innocent piece of code yields undefined behaviour, even though it probably runs perfectly fine:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct Poly\n{\n    void operator=(Poly const&amp;) {} // Poly is not CopyAssignable\n};\n\nint main()\n{\n  std::vector&lt;Poly&gt; v;\n  Poly p;\n  v.insert(v.begin(), p); // undefined behaviour\n}\n</code></pre>\n<p>As the C++ standard explains in \u00a7 17.6.4.8/2.3 where it talks about constraints on programs using the standard library:</p>\n<blockquote>\n<p id=\"so_34562865_34566193_0\">(...) the effects are <strong>undefined</strong> in the following cases:</p>\n<p id=\"so_34562865_34566193_1\">(...) for types used as template arguments when instantiating a\n  template component, <strong>if the operations on the type do not implement the\n  semantics of the applicable Requirements</strong> subclause (...).</p>\n</blockquote>\n<p>Of course, it's precisely <em>because</em> of the undefined behaviour that a compiler is allowed to ignore the error and make the program behave nicely, matching the obviously intended behaviour. But it's not required to do so.</p>\n<p>You should also consider that you cannot predict all future uses of your <code>Poly</code> type. Someone might write some template function such as:</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T const&amp; t)\n{\n    T t2;\n    T t3 = t2 = t;\n    // ...\n}\n</code></pre>\n<p>This function would then not work with your <code>Poly</code> class.</p>\n<p>Just don't violate this C++ convention and you won't run into troubles.</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "34566193", "Score": "4", "CreationDate": "2016-01-02T13:02:10.630", "LastActivityDate": "2016-01-02T13:02:10.630"}, "34562982": {"ParentId": "34562865", "CommentCount": "0", "Body": "<p>Returning a reference to the target object allow assignment chaining (cascading), and overloading operators within a class follows right-associative (click <a href=\"http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html\" rel=\"nofollow\">here</a> for detailed operator overloading rules)</p>\n<pre><code>Poly a, b, c;\na = b = c;\n</code></pre>\n", "OwnerUserId": "5012676", "PostTypeId": "2", "Id": "34562982", "Score": "0", "CreationDate": "2016-01-02T05:38:28.257", "LastActivityDate": "2016-01-02T05:38:28.257"}, "34562890": {"ParentId": "34562865", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>You <code>return *this</code> so you can write normal compound C++ <code>=</code> statements like:</p>\n<pre><code>Poly p1; //an object representing a polynomial\nPoly p2;\nPoly p2;\n\n// ...\n\np3 = p2 = p1;  //assigns all the contents of p1 to p2 and then to p3\n</code></pre>\n<p>because that statement is basically:</p>\n<pre><code>p3.operator=(p2.operator=(p1));\n</code></pre>\n<p>If <code>p2.operator=(...)</code> didn't <code>return *this</code> you'd have nothing meaningful to pass into <code>p3.operator=(...)</code>.</p>\n", "OwnerUserId": "1312406", "LastEditorUserId": "1312406", "LastEditDate": "2016-01-02T05:31:52.823", "Id": "34562890", "Score": "13", "CreationDate": "2016-01-02T05:22:34.417", "LastActivityDate": "2016-01-02T05:31:52.823"}, "34562865": {"CommentCount": "1", "ViewCount": "618", "PostTypeId": "1", "LastEditorUserId": "1392132", "CreationDate": "2016-01-02T05:19:57.350", "LastActivityDate": "2016-01-07T17:52:52.590", "Title": "Why does operator = return *this?", "AcceptedAnswerId": "34562890", "LastEditDate": "2016-01-02T05:33:14.900", "Id": "34562865", "Score": "7", "Body": "<p>Say I want to override the <code>operator =</code> so I can do something like</p>\n<pre><code>Poly p1;  // an object representing a polynomial\nPoly p2;  // another object of the same type    \np2 = p1;  // assigns all the contents of p1 to p2\n</code></pre>\n<p>Then in my implementation of the <code>operator =</code>, I have something like this:</p>\n<pre><code>Poly&amp; Poly::operator=(const Poly &amp;source) {\n    // Skipping implementation, it already works fine\u2026\n    return *this;\n}\n</code></pre>\n<p>Don't mind the implementation, it already works fine.</p>\n<p>My concern is that what happens when you <code>return *this</code>? I know it returns a reference to the object but is this what happens?</p>\n<pre><code>p2 = &amp;p1\n</code></pre>\n", "Tags": "<c++><assignment-operator><copy-assignment>", "OwnerUserId": "4826123", "AnswerCount": "5"}, "34661909": {"ParentId": "34562865", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_34562865_34661909_0\">what happens when you return *this?</p>\n</blockquote>\n<p>In your example (<code>p2 = p1;</code>), nothing.  The method copies <code>p1</code> into <code>p2</code> and returns a reference to the 'this' object, which the calling code doesn't use.</p>\n<p>In code such as <code>p3 = p2 = p1;</code>, the first invocation is <code>p2 = p1</code>, which copies <code>p1</code> into <code>p2</code> and returns a reference to <code>p2</code>.  The calling code then copies from that reference-to-<code>p2</code> into <code>p3</code> (and ignores the reference to <code>p3</code> that is returned).</p>\n<p>(In passing: do your unit tests ensure that <code>p1 = p1</code> works properly?  It's easy to forget that case!)</p>\n", "OwnerUserId": "4850040", "PostTypeId": "2", "Id": "34661909", "Score": "2", "CreationDate": "2016-01-07T17:52:52.590", "LastActivityDate": "2016-01-07T17:52:52.590"}, "bq_ids": {"n4140": {"so_34562865_34566193_0": {"section_id": 6324, "quality": 1.0, "length": 4}, "so_34562865_34566193_1": {"section_id": 6324, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_34562865_34566193_0": {"section_id": 6081, "quality": 1.0, "length": 4}, "so_34562865_34566193_1": {"section_id": 6081, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_34562865_34566193_0": {"section_id": 7834, "quality": 1.0, "length": 4}, "so_34562865_34566193_1": {"section_id": 7834, "quality": 0.9285714285714286, "length": 13}}}, "34562918": {"ParentId": "34562865", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>p2 = p1</code> is a shorthand for <code>p2.operator=(p1)</code>.  It is just calling your <code>operator=</code> function, which is returning a reference to <code>p2</code>, which you are then ignoring.  To make this clear, let's call it <code>assign</code> instead of <code>operator=</code>:</p>\n<pre><code>Poly&amp; Poly::assign(const Poly &amp;source) {\n    .\n    .\n    .\n    return *this;\n}\n</code></pre>\n<p>Now instead of <code>p2 = p1</code>, you would write</p>\n<pre><code>p2.assign(p1);\n</code></pre>\n<p>In this case, the result of calling <code>assign</code> is being ignored, but you don't have to ignore it. For example, you could write:</p>\n<pre><code>p3.assign(p2.assign(p1));\n</code></pre>\n<p>Using <code>operator=</code> instead of <code>assign</code>, this becomes</p>\n<pre><code>p3 = (p2 = p1);\n</code></pre>\n<p>but since assignment is right-associative, this can also be written as</p>\n<pre><code>p3 = p2 = p1;\n</code></pre>\n<p>This form of being able to do multiple assignments at once originally comes from C and has been preserved in C++ through the convention of returning <code>*this</code> in <code>operator=()</code>.</p>\n", "OwnerUserId": "951890", "LastEditorUserId": "951890", "LastEditDate": "2016-01-02T13:12:07.470", "Id": "34562918", "Score": "5", "CreationDate": "2016-01-02T05:28:15.903", "LastActivityDate": "2016-01-02T13:12:07.470"}});