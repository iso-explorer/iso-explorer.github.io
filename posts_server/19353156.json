post_cb({"19353156": {"CommentCount": "0", "ViewCount": "708", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-10-14T03:35:44.583", "LastActivityDate": "2013-10-14T12:04:50.920", "Title": "Performance cost of comparing two C++ iterators", "AcceptedAnswerId": "19355116", "LastEditDate": "2013-10-14T07:15:42.360", "Id": "19353156", "Score": "3", "Body": "<p>In general, what is the performance cost of an equality comparison between two STL container iterators?  I'm only talking about defined operations; that is, comparing two iterators referring to the same object.</p>\n<p>My specific use-case is that I have a <code>std::map</code> that could potentially have very large elements, lots of elements, or both.  If an equality comparison between two iterators over such a map have hidden penalties that I'm not aware of, it could impact the performance of my code.</p>\n", "Tags": "<c++><performance><c++11><stl><iterator>", "OwnerUserId": "1830736", "AnswerCount": "3"}, "19355116": {"ParentId": "19353156", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-10-14T07:12:28.053", "Score": "4", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:05:14.467", "Id": "19355116", "OwnerUserId": "819272", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3691.pdf\" rel=\"nofollow noreferrer\"><strong>draft Standard</strong></a> states that iterator operations are <a href=\"https://stackoverflow.com/q/200384/819272\"><strong>amortized constant time</strong></a></p>\n<p><strong>24.2.1 In general [iterator.requirements.general]</strong></p>\n<blockquote>\n<p id=\"so_19353156_19355116_0\">8 All the categories of iterators require only those functions that\n  are realizable for a given category in constant time (amortized).\n  Therefore, requirement tables for the iterators do not have a\n  complexity column.</p>\n</blockquote>\n<p>If you look at the signatures of iterator operations, there are no parameters or return types that correspond to the underlying elements <code>T</code> themselves, only <code>T*</code> and <code>T&amp;</code> are required. Even <code>operator==</code> does not have to directly compare two arbitrarily large elements <code>T</code> themselves.</p>\n<p>However, this does not give a hard real-time upper-bound for iterator operations. In particular, iterators can do <a href=\"https://stackoverflow.com/q/6103314/819272\">very costly bounds checking</a>, but these Debug mode security guards can usually be left out in Release builds.</p>\n", "LastActivityDate": "2013-10-14T07:19:45.580"}, "bq_ids": {"n4140": {"so_19353156_19355116_0": {"section_id": 5562, "quality": 1.0, "length": 19}}, "n3337": {"so_19353156_19355116_0": {"section_id": 5344, "quality": 1.0, "length": 19}}, "n4659": {"so_19353156_19355116_0": {"section_id": 7009, "quality": 1.0, "length": 19}}}, "19353214": {"ParentId": "19353156", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-10-14T03:43:37.243", "Score": "4", "LastEditorUserId": "1625206", "LastEditDate": "2013-10-14T03:52:07.163", "Id": "19353214", "OwnerUserId": "1625206", "Body": "<p>Most of STL containers <code>operator==()</code> is just raw pointer comparison. Which is meaningless unless it's for boundaries checking. More over, if you are comparing iterators from different containers - it's undefined behaviour.</p>\n<p>If you override this operator or use external comparison function, perfomance depends on how large are object you are comparing.</p>\n<p>Probably I got your question wrong, it's not 100% clear what do you mean by \"iterator comparison\" and what's your use case.</p>\n", "LastActivityDate": "2013-10-14T03:52:07.163"}, "19353279": {"ParentId": "19353156", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2013-10-14T03:51:35.350", "Score": "5", "LastEditorUserId": "534124", "LastEditDate": "2013-10-14T12:04:50.920", "Id": "19353279", "OwnerUserId": "534124", "Body": "<p>Generally, the <em>performance</em> of comparing two iterators depends on the implementation of the STL.</p>\n<p>However, concerning the <em>time complexity</em>, the C++ standard imposes the restriction that comparison of input iterators (and thus forward iterators, bidirectional iterators and random access iterators) takes amortized constant time. Particularly, this means for an <code>std::map&lt;std::string, int&gt;</code>, that its iterators cannot be compared by comparing the keys for equality, because that would be linear with respect to the length of the key.</p>\n", "LastActivityDate": "2013-10-14T12:04:50.920"}});