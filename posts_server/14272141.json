post_cb({"14272141": {"CommentCount": "24", "AcceptedAnswerId": "14285236", "CreationDate": "2013-01-11T05:17:45.943", "LastActivityDate": "2013-01-11T22:18:09.090", "PostTypeId": "1", "ViewCount": "755", "FavoriteCount": "4", "Title": "Is casting std::pair<T1, T2> const& to std::pair<T1 const, T2> const& safe?", "Id": "14272141", "Score": "14", "Body": "<p>Is it safe (in theory or in practice) to <code>reinterpret_cast</code> a <code>std::pair&lt;T1, T2&gt; const &amp;</code> into a <code>std::pair&lt;T1 const, T2&gt; const &amp;</code>, assuming that the programmer hasn't intentionally done something weird like specializing <code>std::pair&lt;T1 const, T2&gt;</code>?</p>\n", "Tags": "<c++><templates><casting><const><reinterpret-cast>", "OwnerUserId": "541686", "AnswerCount": "3"}, "14283533": {"ParentId": "14272141", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The practical answer is that casting to const should be safe since you are reinterpret-casting to an object with an identical representation. However, the other way around introduces undefined behaviour (const to non-const).</p>\n<p>As for the \"theoretical\" answer, I should note that the C++ standard does not guarantee an identical bitwise representation of const/non-const objects. The const keyword guarantees \"conceptual constness\", which is implementation dependant.</p>\n", "Id": "14283533", "LastEditDate": "2013-01-11T17:50:30.817", "OwnerDisplayName": "user1556013", "Score": "0", "CreationDate": "2013-01-11T17:31:20.873", "LastActivityDate": "2013-01-11T17:50:30.817", "LastEditorDisplayName": "user1556013"}, "14285078": {"ParentId": "14272141", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><code>pair</code> is defined in section 20.3.2 of the standard to have data members:</p>\n<pre><code>template &lt;class T1, class T2&gt;\nstruct pair {\n    T1 first;\n    T2 second;\n};\n</code></pre>\n<p>This means that for concrete types <code>T1</code>, <code>T2</code>, <code>pair&lt;T1, T2&gt;</code> and <code>pair&lt;const T1, T2&gt;</code> are guaranteed to have respective data members:</p>\n<pre><code>struct pair&lt;T1, T2&gt; {\n    T1 first;\n    T2 second;\n};\nstruct pair&lt;const T1, T2&gt; {\n    const T1 first;\n    T2 second;\n};\n</code></pre>\n<p>Now, <em>if <code>T1</code> and <code>T2</code> are both standard-layout</em>, then <code>pair&lt;T1, T2&gt;</code> and <code>pair&lt;const T1, T2&gt;</code> are both standard-layout.  As discussed above, by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1334\" rel=\"nofollow\">DR1334</a> they are not <em>layout-compatible</em> (3.9p11), but by 9.2p19 they can be <code>reinterpret_cast</code> to their respective <code>T1</code> or <code>const T1</code> first member.  By 9.2p13 the <code>T2</code> second member must be located after the first member (i.e. with higher address) and by 1.8p5 must be located immediately after the first member such that the object is contiguous after accounting for alignment (9.2p19).</p>\n<p>We can check this using <code>offsetof</code> (which is defined for standard-layout types):</p>\n<pre><code>static_assert(offsetof(pair&lt;T1, T2&gt;, second) ==\n    offsetof(pair&lt;const T1, T2&gt;, second), \"!\");\n</code></pre>\n<p>Since <code>pair&lt;T1, T2&gt;</code> and <code>pair&lt;const T1, T2&gt;</code> have the same layout, casting in the forward direction and using the result to access the members is valid by 3.9.2p3:</p>\n<blockquote>\n<p id=\"so_14272141_14285078_0\">If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the address <code>A</code> is said to point to that object, regardless of how the value was obtained.</p>\n</blockquote>\n<p>So the <code>reinterpret_cast</code> is safe only if <code>std::is_standard_layout&lt;std::pair&lt;T1, T2&gt;&gt;::value</code> is <code>true</code>.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2013-01-11T20:01:06.657", "Id": "14285078", "Score": "4", "CreationDate": "2013-01-11T19:14:29.073", "LastActivityDate": "2013-01-11T20:01:06.657"}, "14285236": {"ParentId": "14272141", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>It's NOT portable to do so.</p>\n<p><code>std::pair</code> requirements are laid out in clause 20.3.  Clause 17.5.2.3 clarifies that</p>\n<blockquote>\n<p id=\"so_14272141_14285236_0\">Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit specification of class members.  An implementation may define static or non-static class members, or both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and Annex D.</p>\n</blockquote>\n<p>This implies that it's legal (although incredibly unlikely) for an implementation to include a partial specialization such as:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nstruct pair&lt;T1, T2&gt;\n{\n    T1 first;\n    T2 second;\n};\n\ntemplate&lt;typename T1, typename T2&gt;\nstruct pair&lt;const T1, T2&gt;\n{\n    T2 second;\n    const T1 first;\n};\n</code></pre>\n<p>which are <em>clearly</em> not layout-compatible.  Other variations including inclusion of additional non-static data members possibly before <code>first</code> and/or <code>second</code> are also allowed under the rule.</p>\n<hr>\n<p>Now, it is somewhat interesting to consider the case where the layout is known.  Although Potatoswatter pointed out <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1334\" rel=\"nofollow\">DR1334</a> which asserts that <code>T</code> and <code>const T</code> are not <em>layout-compatible</em>, the Standard provides enough guarantees to allow us to get most of the way anyway:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nstruct mypair&lt;T1, T2&gt;\n{\n    T1 first;\n    T2 second;\n};\n\nmypair&lt;int, double&gt; pair1;\nmypair&lt;int, double&gt;* p1 = &amp;pair1;\nint* p2 = reinterpret_cast&lt;int*&gt;(p1); // legal by 9.2p20\nconst int* p3 = p2;\nmypair&lt;const int, double&gt;* p4 = reinterpret_cast&lt;mypair&lt;const int, double&gt;*&gt;(p3); // again 9.2p20\n</code></pre>\n<p>However this doesn't work on <code>std::pair</code> as we can't apply 9.2p20 without knowing that <code>first</code> is actually the initial member, which is not specified.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2013-01-11T22:18:09.090", "Id": "14285236", "Score": "6", "CreationDate": "2013-01-11T19:25:38.803", "LastActivityDate": "2013-01-11T22:18:09.090"}, "bq_ids": {"n4140": {"so_14272141_14285078_0": {"section_id": 7223, "quality": 0.9411764705882353, "length": 16}, "so_14272141_14285236_0": {"section_id": 6246, "quality": 1.0, "length": 28}}, "n3337": {"so_14272141_14285078_0": {"section_id": 6967, "quality": 0.9411764705882353, "length": 16}, "so_14272141_14285236_0": {"section_id": 6006, "quality": 1.0, "length": 28}}, "n4659": {"so_14272141_14285078_0": {"section_id": 8732, "quality": 0.5294117647058824, "length": 9}, "so_14272141_14285236_0": {"section_id": 7750, "quality": 1.0, "length": 28}}}});