post_cb({"bq_ids": {"n4140": {"so_25595742_25598405_4": {"length": 5, "quality": 0.625, "section_id": 6184}, "so_25595742_25598405_5": {"length": 10, "quality": 0.7692307692307693, "section_id": 87}, "so_25595742_25598405_1": {"length": 5, "quality": 1.0, "section_id": 6185}, "so_25595742_25598405_0": {"length": 5, "quality": 1.0, "section_id": 6185}, "so_25595742_25598405_6": {"length": 12, "quality": 1.0, "section_id": 6187}, "so_25595742_25598405_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_25595742_25598405_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 382}}, "n3337": {"so_25595742_25598405_4": {"length": 5, "quality": 0.625, "section_id": 5945}, "so_25595742_25598405_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 5947}, "so_25595742_25598405_1": {"length": 4, "quality": 0.8, "section_id": 1182}, "so_25595742_25598405_0": {"length": 4, "quality": 0.8, "section_id": 5946}, "so_25595742_25598405_6": {"length": 7, "quality": 0.5833333333333334, "section_id": 559}, "so_25595742_25598405_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_25595742_25598405_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 373}}, "n4659": {"so_25595742_25598405_4": {"length": 5, "quality": 0.625, "section_id": 7686}, "so_25595742_25598405_5": {"length": 10, "quality": 0.7692307692307693, "section_id": 7690}, "so_25595742_25598405_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_25595742_25598405_1": {"length": 5, "quality": 1.0, "section_id": 7687}, "so_25595742_25598405_6": {"length": 12, "quality": 1.0, "section_id": 7690}, "so_25595742_25598405_2": {"length": 17, "quality": 0.8095238095238095, "section_id": 397}}}, "25598405": {"Id": "25598405", "PostTypeId": "2", "Body": "<p><code>clang 3.4</code> does not compile this code since <code>sum(get_str())</code> is not a <em>constexpr</em> and as far as I can tell <code>clang</code> is correct here, this line (<em><a href=\"http://coliru.stacked-crooked.com/a/00a60541c07ff407\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>constexpr int s = sum(get_str());\n</code></pre>\n<p>generates the following error:</p>\n<pre><code>error: constexpr variable 's' must be initialized by a constant expression\nconstexpr int s = sum(get_str());\n              ^   ~~~~~~~~~~~~~~\n\nnote: read of temporary whose lifetime has ended\nreturn str[0] + str[1] + str[2] + str[3] \n       ^\n</code></pre>\n<p>It is not a valid <code>constexpr</code> for two reasons. This invokes undefined behavior and this is <a href=\"https://stackoverflow.com/questions/21319413/why-do-constant-expressions-have-an-exclusion-for-undefined-behavior\">explicitly disallowed in a constant expression</a>, to summarize <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow noreferrer\">the draft C++ standard</a> section <code>5.19</code> says:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_0\">A conditional-expression e is a core constant expression unless the evaluation of e,</p>\n</blockquote>\n<p>and contains the following bullet:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_1\">an operation that would have undefined behavior</p>\n</blockquote>\n<p>which accessing outside of its lifetime would be. We know the lifetime of the temporary is not extended in this case from section <code>12.2</code> <em>Temporary objects</em> which says:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_2\">The second context is when a reference is bound to a temporary.117 The\n  temporary to which the reference is bound or the temporary that is the\n  complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_3\">The lifetime of a temporary bound to the returned value in a function\n  return statement (6.6.3) is not extended; the temporary is destroyed\n  at the end of the full-expression in the return statement.</p>\n</blockquote>\n<p>So although it is indeed true that a <em>constant expression</em> is not guaranteed to be evaluated at translation, we have a note in section <code>5.19</code> <em>Constant expressions</em> that mentions this (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_25595742_25598405_4\">Note: Constant expressions <strong>can be</strong> evaluated during translation.\u2014end\n  note ]</p>\n</blockquote>\n<p>Even if it was guaranteed we still would not be allowed to invoke undefined behavior.</p>\n<p>The second issue is that constexpr references must be either to objects of static storage duration or functions, <a href=\"http://en.cppreference.com/w/Main_Page\" rel=\"nofollow noreferrer\">cppreference</a> mentions this in its <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression#Core_constant_expressions\" rel=\"nofollow noreferrer\">core constant expression section</a>:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_5\">Reference constant expression is an lvalue core constant expression\n  that designates an object with static storage duration or a function</p>\n</blockquote>\n<p>and as far as I can tell this is covered in section <code>5.19</code> <em>Constant expressions</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_25595742_25598405_6\">each non-static data member of reference type refers to an object with\n  static storage duration or to a function,</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-02T18:45:12.640", "Score": "2", "CreationDate": "2014-09-01T03:17:28.820", "ParentId": "25595742", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:01:02.177"}, "25595775": {"Id": "25595775", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25595742_25595775_0\">the function is never actually called at runtime, only during\n  compilation?</p>\n</blockquote>\n<p>Not guaranteed <em>at all</em> by Standard. The compiler is well within it's rights to invoke it at runtime.</p>\n<p><code>constexpr</code> temporaries never die <em>if</em> the compiler invokes it at compilation time. The compiler is under no obligation.</p>\n", "LastActivityDate": "2014-08-31T20:01:49.017", "CommentCount": "2", "CreationDate": "2014-08-31T20:01:49.017", "ParentId": "25595742", "Score": "1", "OwnerUserId": "298661"}, "25595742": {"ViewCount": "681", "Body": "<p>I wrote a constexpr function that returns an array. </p>\n<pre><code>#include &lt;iostream&gt;\n\nconstexpr auto get_str(void)\n-&gt; const char(&amp;)[4] {   \n    return { 'T', 'E', 'S', 'T' };\n}\n\nconstexpr int sum(const char(&amp;str)[4]){\n    return str[0] + str[1] + str[2] + str[3];\n}\n\nint main(void){\n\n    constexpr int s = sum(get_str());\n\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>g++ 4.8 compiles the code correctly, but issues the following warning:</p>\n<pre><code>test.cpp: In function \u2018constexpr const char (&amp; get_str())[4]\u2019:\ntest.cpp:5:30: warning: returning reference to temporary [-Wreturn-local-addr]\n  return { 'T', 'E', 'S', 'T' };\n</code></pre>\n<p>Is the warning correct in this circumstance? Is it incorrect to return an array from a constexpr function like this even though the function is never actually called at runtime, only during compilation?</p>\n", "AcceptedAnswerId": "25598405", "Title": "constexpr returning array, gcc warning", "CreationDate": "2014-08-31T19:56:49.497", "Id": "25595742", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-09-02T18:45:12.640", "Score": "8", "OwnerUserId": "607084", "Tags": "<c++><arrays><gcc><constexpr><gcc-warning>", "AnswerCount": "2"}});