post_cb({"9155476": {"CommentCount": "2", "AcceptedAnswerId": "9155486", "PostTypeId": "1", "LastEditorUserId": "501557", "CreationDate": "2012-02-06T04:07:51.980", "LastActivityDate": "2014-01-19T19:51:04.733", "LastEditDate": "2014-01-19T19:51:04.733", "ViewCount": "912", "FavoriteCount": "0", "Title": "What algorithm is used in std::search?", "Id": "9155476", "Score": "3", "Body": "<p>There are many string matching algorithms can be used to find a pattern (string) in a big text, like Boyer-Moore, Aho-Corasick, etc.</p>\n<p>Which string matching algorithm is applied to implement <code>std::search</code> function in C++ ?</p>\n", "Tags": "<c++><string><algorithm><pattern-matching><string-matching>", "OwnerUserId": "630908", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9155476_9155486_0": {"section_id": 1261, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_9155476_9155486_0": {"section_id": 1259, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_9155476_9155486_0": {"section_id": 1381, "quality": 0.8888888888888888, "length": 8}}}, "9155486": {"ParentId": "9155476", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++03 ISO standard, \u00a725.1.9/3, the complexity of <code>std::search</code> is</p>\n<blockquote>\n<p id=\"so_9155476_9155486_0\">Complexity: At most (last1 - first1) * (last2 - first2) applications of the corresponding predicate</p>\n</blockquote>\n<p>This is the only requirement on the implementation of this algorithm.  The ISO spec does not specify which algorithm should be used here, and it's completely implementation-dependent.  These time bounds permit the use of the naive sequence-searching algorithm, <a href=\"http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\">Knuth-Morris-Pratt</a>, <a href=\"http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm\">Boyer-Moore</a>, and <a href=\"http://en.wikipedia.org/wiki/Rabin-Karp_string_search_algorithm\">Rabin-Karp</a>.  To know which one is being used, you should probably pull up the documentation for whichever version of the standard library that you're using.  That said, you can't count on that being portable.  My guess is that most implementations just use the naive matching algorithm, since the worst case typically doesn't arise in practice.</p>\n<p>Hope this helps!</p>\n", "OwnerUserId": "501557", "LastEditorUserId": "501557", "LastEditDate": "2012-02-06T04:20:12.343", "Id": "9155486", "Score": "10", "CreationDate": "2012-02-06T04:10:34.240", "LastActivityDate": "2012-02-06T04:20:12.343"}});