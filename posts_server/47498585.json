post_cb({"47499126": {"ParentId": "47498585", "CommentCount": "0", "Body": "<p>Any interpretation that disallows the intended usage of <code>offsetof</code> must be wrong:</p>\n<pre><code>#include &lt;stddef.h&gt;\nstruct S { float a, b, c; };\n\nvoid fn(S *sp)\n{\n    return *(float *)(((char *)sp) + offsetof(S, c));\n}\n</code></pre>\n<p>... however, any interpretation that allows one to step past the end of an explicitly-declared array must also be wrong:</p>\n<pre><code>#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\nstruct S { float a[2]; float b[2]; };\n\nstatic_assert(offsetof(S, b) == sizeof(float)*2,\n    \"padding between S.a and S.b -- should be impossible\");\n\nfloat fn(S *sp)\n{\n    return S-&gt;a[2]; // undefined behavior, reading past end of array\n}\n</code></pre>\n<p>And we are now on the horns of a dilemma, because the wording in both the C and C++ standards, that was intended to disallow the second case, probably also disallows the first case.</p>\n<p>This is commonly known as the \"what is an object?\" problem.  People, including members of the C and C++ committees, have been arguing about this and related issues since the 1990s, and there have been multiple attempts to fix the wording, and to the best of my knowledge none has succeeded (in the sense that all existing \"reasonable\" code is rendered definitely conforming and all existing \"reasonable\" optimizations are still allowed).</p>\n", "OwnerUserId": "388520", "PostTypeId": "2", "Id": "47499126", "Score": "1", "CreationDate": "2017-11-26T17:44:34.020", "LastActivityDate": "2017-11-26T17:44:34.020"}, "47499092": {"ParentId": "47498585", "CommentCount": "1", "Body": "<p>As far as I know, your code is valid.  Aliasing an object as a <code>char</code> array is explicitly allowed as per \u00a7\u00a03.10 \u00b6\u00a010.8:</p>\n<blockquote>\n<p id=\"so_47498585_47499092_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>[\u2026]</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<p>The other question is whether casting the <code>char*</code> pointer back to <code>float*</code> and assigning through it is valid.  Since your <code>Foo</code> is a POD type, this is okay.  You are allowed to compute the address of a POD's member (given that the computation itself is not UB) and then access the member through that address.  You must not abuse this to, for example, gain access to a <code>private</code> member of a non-POD object. Furthermore, it would be UB if you'd, say, cast to <code>int*</code> or write at an address where no object of type <code>float</code> exists.  The reasoning behind this can be found in the section quoted above.</p>\n", "OwnerUserId": "1392132", "PostTypeId": "2", "Id": "47499092", "Score": "0", "CreationDate": "2017-11-26T17:39:49.867", "LastActivityDate": "2017-11-26T17:39:49.867"}, "47499066": {"ParentId": "47498585", "CommentCount": "0", "Body": "<p>The addition is intended to be valid, but I do not believe the standard manages to say so clearly enough. Quoting N4140 (roughly C++14):</p>\n<blockquote>\n<p id=\"so_47498585_47499066_0\"><strong>3.9 Types [basic.types]</strong></p>\n<p id=\"so_47498585_47499066_1\">2 For any object (other than a base-class subobject) of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes (1.7) making up the object can be copied into an array\n  of <code>char</code> or <code>unsigned char</code>.<sup>42</sup> [...]</p>\n<p id=\"so_47498585_47499066_2\"><sup>42) By using, for example, the library functions (17.6.1.2) <code>std::memcpy</code> or <code>std::memmove</code>.</sup></p>\n</blockquote>\n<p>It says \"for example\" because <code>std::memcpy</code> and <code>std::memmove</code> are not the only ways in which the underlying bytes are intended to be allowed to be copied. A simple <code>for</code> loop which copies byte by byte manually is supposed to be valid as well.</p>\n<p>In order for that to work, addition has to be defined for pointers to the raw bytes that make up an object, and the way definedness of expressions works, the addition's definedness cannot depend on whether the addition's result will subsequently be used to copy the bytes into an array.</p>\n<p>Whether that means those bytes form an array already or whether this is a special exception to the general rules for the <code>+</code> operator that is somehow omitted in the operator description, is not clear to me (I suspect the former), but either way would make the addition you're performing in your code valid.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "47499066", "Score": "0", "CreationDate": "2017-11-26T17:37:25.850", "LastActivityDate": "2017-11-26T17:37:25.850"}, "bq_ids": {"n4140": {"so_47498585_47498585_0": {"section_id": 6142, "quality": 0.6842105263157895, "length": 26}, "so_47498585_47499066_2": {"section_id": 7200, "quality": 0.8571428571428571, "length": 6}, "so_47498585_47499066_1": {"section_id": 7200, "quality": 0.9230769230769231, "length": 24}, "so_47498585_47499092_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_47498585_47498585_0": {"section_id": 5906, "quality": 0.6842105263157895, "length": 26}, "so_47498585_47499066_2": {"section_id": 6944, "quality": 0.8571428571428571, "length": 6}, "so_47498585_47499066_1": {"section_id": 6944, "quality": 0.9230769230769231, "length": 24}, "so_47498585_47499092_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_47498585_47498585_0": {"section_id": 7638, "quality": 0.8947368421052632, "length": 34}, "so_47498585_47499066_2": {"section_id": 8709, "quality": 0.8571428571428571, "length": 6}, "so_47498585_47499066_1": {"section_id": 8709, "quality": 0.9230769230769231, "length": 24}, "so_47498585_47499092_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}, "47498585": {"CommentCount": "18", "ViewCount": "80", "PostTypeId": "1", "LastEditorUserId": "8157187", "CreationDate": "2017-11-26T16:47:38.600", "LastActivityDate": "2017-11-26T17:44:34.020", "Title": "Is adding to a \"char *\" pointer UB, when it doesn't actually point to a char array?", "LastEditDate": "2017-11-26T17:07:13.033", "Id": "47498585", "Score": "3", "Body": "<p>C++17 (<a href=\"http://eel.is/c++draft/expr.add#4\" rel=\"nofollow noreferrer\">expr.add/4</a>) say:</p>\n<blockquote>\n<p id=\"so_47498585_47498585_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  expression P points to element x[i] of an array object x with n\n  elements, the expressions P + J and J + P (where J has the value j)\n  point to the (possibly-hypothetical) element x[i+j] if 0\u2264i+j\u2264n;\n  otherwise, the behavior is undefined. Likewise, the expression P - J\n  points to the (possibly-hypothetical) element x[i\u2212j] if 0\u2264i\u2212j\u2264n;\n  otherwise, the behavior is undefined.</p>\n</blockquote>\n<pre><code>struct Foo {\n    float x, y, z;\n};\n\nFoo f;\nchar *p = reinterpret_cast&lt;char*&gt;(&amp;f) + offsetof(Foo, z); // (*)\n*reinterpret_cast&lt;float*&gt;(p) = 42.0f;\n</code></pre>\n<p>Has the line marked with (*) UB? <code>reinterpret_cast&lt;char*&gt;(&amp;f)</code> doesn't point to a char array, but to a float, so it should UB according to the cited paragraph. But, if it is UB, then <code>offsetof</code>'s usefulness would be limited.</p>\n<p>Is it UB? If not, why not?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "8157187", "AnswerCount": "3"}});