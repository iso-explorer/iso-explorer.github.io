post_cb({"25957705": {"CommentCount": "6", "ViewCount": "167", "PostTypeId": "1", "LastEditorUserId": "1128289", "CreationDate": "2014-09-21T09:18:38.597", "LastActivityDate": "2014-09-21T20:57:35.363", "Title": "Is dynamic loading strictly compatible with the C++ Standard?", "AcceptedAnswerId": "25963793", "LastEditDate": "2014-09-21T20:48:08.487", "Id": "25957705", "Score": "3", "Body": "<p>Does the use of dynamic loading require any special precautions for code to be strictly legal C++?</p>\n<p>The C++11 Standard refers to the order of certain events such as what goes on before the first call to main(). However, dynamic loading seems to pull the rug out from under typical assumptions regarding the ordering of events in a program.</p>\n<p>As an example is a quote from \u00a73.6.2.</p>\n<blockquote>\n<p id=\"so_25957705_25957705_0\">Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n<p>In the case of dynamic loading, this seems a nearly impossible obligation if taken literally. A program may incur dynamic initialization and then dynamically load code. If that code contains variables that would normally have been statically initialized, the C++ Standard has been violated. It seems possible that the order of events mandated by the Standard could still appear to be satisfied and be legal by the \"as-if\" rule but elsewhere on SO others have warned about interpreting that rule too broadly.</p>\n", "Tags": "<c++><c++11><language-lawyer><dynamic-loading>", "OwnerUserId": "1128289", "AnswerCount": "1"}, "25963793": {"ParentId": "25957705", "CommentCount": "2", "Body": "<p>The C++ standard doesn't have any provision for dynamic modules, so a certain amount of interpretation is necessary.</p>\n<p>Yes, static-initialized variables in dynamically loaded modules will be initialized after dynamically initialized variables in the main module. You can observe this, and construct programs where it has an effect on the program's behavior. But if you think of the DLL as a separate program, one which shares the main program's memory space but has its own timeline, you can pretty much apply the same rules at the module level, and use them to predict behavior at the application-wide behavior. The compiler doesn't <em>want</em> to surprise you... it just has to sometimes.</p>\n<p>Incidentally, initialization order is really the least of your concerns when it comes to the collision between C++ and DLLs. Dynamic modules break far more rules than that, particularly when it comes to RTTI. </p>\n", "OwnerUserId": "787480", "PostTypeId": "2", "Id": "25963793", "Score": "3", "CreationDate": "2014-09-21T20:57:35.363", "LastActivityDate": "2014-09-21T20:57:35.363"}, "bq_ids": {"n4140": {"so_25957705_25957705_0": {"section_id": 7151, "quality": 1.0, "length": 8}}, "n3337": {"so_25957705_25957705_0": {"section_id": 6895, "quality": 1.0, "length": 8}}, "n4659": {"so_25957705_25957705_0": {"section_id": 8652, "quality": 0.625, "length": 5}}}});