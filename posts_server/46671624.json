post_cb({"46671624": {"CommentCount": "5", "ViewCount": "46", "PostTypeId": "1", "ClosedDate": "2017-10-10T17:33:08.893", "LastEditorUserId": "6949852", "CreationDate": "2017-10-10T16:31:40.767", "LastActivityDate": "2017-10-10T17:04:44.197", "Title": "Why does postfix failed and prefix work fine when pass an iterator as argument and recurse it at tail position?", "AcceptedAnswerId": "46671799", "LastEditDate": "2017-10-10T17:04:00.753", "Id": "46671624", "Score": "2", "Body": "<p>I come across this problem accidentally.</p>\n<p>I have thought google can solve it surely, but after searching multiple keywords, I still can't find answers, which confused me a lot. </p>\n<p>When I use prefix at tail position, codes works fine: </p>\n<pre><code>template&lt;class ContinerIterator, class F&gt;\nconstexpr auto fun(ContinerIterator IteratorBegin, ContinerIterator IteratorEnd, F f)\n{\n    switch (IteratorBegin == IteratorEnd)\n    {\n    case true: return;\n    case false: f(*IteratorBegin);\n    }\n    return fun(++IteratorBegin, IteratorEnd, f);\n}\nint main()\n{\n    std::vector&lt;int&gt; a = { 1, 2, 3, 4 };\n    fun(std::begin(a), std::end(a), [](auto &amp;a)-&gt;auto{a *= 2; });\n    for (auto v : a)\n    {\n        std::cout &lt;&lt; v &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_46671624_46671624_0\">1</p>\n<p id=\"so_46671624_46671624_1\">2</p>\n<p id=\"so_46671624_46671624_2\">3</p>\n<p id=\"so_46671624_46671624_3\">4</p>\n<p id=\"so_46671624_46671624_4\">Press any key to continue . . .</p>\n</blockquote>\n<hr>\n<p>Howerer, if I use postfix, <code>IteratorBegin</code> nerve arrives <code>iteratorEnd</code> and goes far and far away, so segmentfault. </p>\n<pre><code>template&lt;class ContinerIterator, class F&gt;\nconstexpr auto fun(ContinerIterator IteratorBegin, ContinerIterator IteratorEnd, F f)\n{\n    switch (IteratorBegin == IteratorEnd)\n    {\n    case true: return;\n    case false: f(*IteratorBegin);\n    }\n    return fun(IteratorBegin++, IteratorEnd, f);\n}\nvoid test()\n{\n\n}\nint main()\n{\n    std::vector&lt;int&gt; a = { 1, 2, 3, 4 };\n    fun(std::begin(a), std::end(a), [](auto &amp;a)-&gt;auto{a *= 2; });\n    for (auto v : a)\n    {\n        std::cout &lt;&lt; v &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>I have tried on MSVC, G++, Clang, all fails. \nHere is gcc's error list: </p>\n<blockquote>\n<p id=\"so_46671624_46671624_5\">Segmentation fault (core dumped)</p>\n</blockquote>\n<p>Here is Clang's: </p>\n<blockquote>\n<p id=\"so_46671624_46671624_6\">Error occurred (timeout). Try again later.</p>\n</blockquote>\n</hr>", "Tags": "<c++><recursion><prefix><postfix>", "OwnerUserId": "6949852", "AnswerCount": "3"}, "46671762": {"ParentId": "46671624", "CommentCount": "0", "Body": "<p>The prefix case:</p>\n<pre><code>return fun(++IteratorBegin, IteratorEnd, f);\n</code></pre>\n<p>says, <em>first</em> increment <code>IteratorBegin</code> by one, and then call the function <code>fun</code>. After that, return.</p>\n<p>On the other hand, the postfix case:</p>\n<pre><code>return fun(IteratorBegin++, IteratorEnd, f);\n</code></pre>\n<p>says, first call <code>fun()</code>, then increment the iterator, and then return.</p>\n<p>This means that <code>fun()</code> is always being called with the non-incremented iterator.</p>\n", "OwnerUserId": "2411320", "PostTypeId": "2", "Id": "46671762", "Score": "3", "CreationDate": "2017-10-10T16:40:06.523", "LastActivityDate": "2017-10-10T16:40:06.523"}, "46671799": {"ParentId": "46671624", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This statement</p>\n<pre><code>return fun(IteratorBegin++, IteratorEnd, f);\n</code></pre>\n<p>with some exceptions can be considered like</p>\n<pre><code>fun(IteratorBegin, IteratorEnd, f);\n++IteratorBegin;\nreturn;\n</code></pre>\n<p>So the function is always called with the same value of <code>IteratorBegin</code>.</p>\n<p>From the C++ Standard (5.2.6 Increment and decrement)</p>\n<blockquote>\n<p id=\"so_46671624_46671799_0\">1 The value of a postfix ++ expression is the value of its operand. [\n  Note: <strong>the value obtained is a copy of the original value</strong> \u2014end note\n  ]...</p>\n</blockquote>\n<p>Consider the following simple program</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f(int x)\n{\n    std::cout &lt;&lt; \"Inside f( x ): x = \" &lt;&lt; x &lt;&lt; std::endl;\n}\n\nint main()\n{\n    int x = 0;\n\n    std::cout &lt;&lt; \"Before f( x ): x = \" &lt;&lt; x &lt;&lt; std::endl;\n    f(x++);\n    std::cout &lt;&lt; \"After  f( x ): x = \" &lt;&lt; x &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Its output is</p>\n<pre><code>Before f( x ): x = 0\nInside f( x ): x = 0\nAfter  f( x ): x = 1\n</code></pre>\n<p>Also it will be useful to consider the following simple program</p>\n<pre><code>#include &lt;iostream&gt;\n\nint x = 0;\n\nvoid f(int x)\n{\n    std::cout &lt;&lt; \"Local (parameter) x = \" &lt;&lt; x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Global variable ::x = \" &lt;&lt; ::x &lt;&lt; std::endl;\n}\n\nint main()\n{\n    f(x++);\n\n    return 0;\n}\n</code></pre>\n<p>Its output is</p>\n<pre><code>Local (parameter) x = 0\nGlobal variable ::x = 1\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2017-10-10T17:04:44.197", "Id": "46671799", "Score": "3", "CreationDate": "2017-10-10T16:41:27.510", "LastActivityDate": "2017-10-10T17:04:44.197"}, "bq_ids": {"n4140": {"so_46671624_46671799_0": {"section_id": 6009, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_46671624_46671799_0": {"section_id": 5777, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_46671624_46671799_0": {"section_id": 7508, "quality": 0.7333333333333333, "length": 11}}}, "46671778": {"ParentId": "46671624", "CommentCount": "0", "Body": "<p>When you use postfix increment in the tail call, the recursive call does not get the incremented value of the iterator. It gets the value of the iterator before the increment is applied. Hence, the recursion is infinite. That causes stack overflow.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "46671778", "Score": "3", "CreationDate": "2017-10-10T16:40:39.403", "LastActivityDate": "2017-10-10T16:40:39.403"}});