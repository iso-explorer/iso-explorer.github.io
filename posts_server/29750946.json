post_cb({"29750947": {"ParentId": "29750946", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Looks like <code>libstdc++</code> is correct, this is not ill-formed, although we will see there are some doubts expressed over whether this is a defect in LWG active issue <code>2192</code>. </p>\n<p>The draft C++11 standard section <code>26.8</code> <em>[c.math]</em> paragraph <code>11</code> says:</p>\n<blockquote>\n<p id=\"so_29750946_29750947_0\">Moreover, there shall be additional overloads sufficient to ensure:</p>\n</blockquote>\n<p>and includes the following item:</p>\n<blockquote id=\"so_29750946_29750947_1\">\n<ol start=\"2\">\n<li>Otherwise, if any argument corresponding to a double parameter has type double or an integer type, then all arguments corresponding to\n  double parameters are effectively cast to double.</li>\n</ol>\n</blockquote>\n<p>and we can see this <code>libstdc++</code> does <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/c_std/cmath#L92\" rel=\"nofollow\">indeed provide for this</a> case:</p>\n<pre><code>template&lt;typename _Tp&gt;\ninline typename __gnu_cxx::__enable_if&lt;__is_integer&lt;_Tp&gt;::__value,\n                                                  double&gt;::__type\nabs(_Tp __x)\n{ return __builtin_fabs(__x); }\n</code></pre>\n<p>There is a also a <code>gcc</code> bug report <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54686\" rel=\"nofollow\">std::abs (long long) resorts to std::abs (double) if llabs is absent</a>, which questions if this implementation is correct and one response says:</p>\n<blockquote>\n<p id=\"so_29750946_29750947_2\">[...]is fine per the Standard, any integer is supposed to\n  unconditionally become double. [...]</p>\n</blockquote>\n<p>The bug report eventually lead to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2192\" rel=\"nofollow\">LWG active issue 2192: Validity and return type of std::abs(0u) is unclear</a> being filed which says amongst other things:</p>\n<blockquote>\n<ol>\n<li>In C++11 the additional \"sufficient overload\" rule from 26.8 [c.math]\n  p11 (see also LWG 2086) can be read to be applicable to the std::abs()\n  overloads as well, which can lead to the following possible\n  conclusions:</li>\n</ol>\n<p id=\"so_29750946_29750947_3\">The program</p>\n<pre><code>    #include &lt;type_traits&gt;\n    #include &lt;cmath&gt;\n\n    static_assert(std::is_same&lt;decltype(std::abs(0u)), double&gt;(), \"Oops\");\n\n    int main() {\n      std::abs(0u); // Calls std::abs(double)\n    }\n</code></pre>\n<p id=\"so_29750946_29750947_4\">is required to be well-formed, because of sub-bullet 2 (\"[..] or an\n  integer type [..]\") of 26.8 [c.math] p11 (Note that the current\n  resolution of LWG 2086 doesn't fix this problem).</p>\n<ol start=\"2\">\n<li>Any translation unit including both  and  might be ill-formed because of two conflicting requirements for the return type\n  of the overload std::abs(int).</li>\n</ol>\n<p id=\"so_29750946_29750947_5\">It seems to me that at least the second outcome is not intended,\n  personally I think that both are unfortunate [...] It should also be\n  noted, that the corresponding \"generic type function\" rule set from\n  C99/C1x in 7.25 p2+3 is restricted to the floating-point functions\n  from  and , so cannot be applied to the abs\n  functions (but to the fabs functions!).</p>\n</blockquote>\n<p>The question is whether this was intended to apply to <code>abs</code> as well. This could be a defect since there does not seem to a way to interpret the current wording to exclude <code>abs</code>.</p>\n<p>So current wording indicates <code>libstdc++</code> is conformant, it is not clear why <code>libc++</code> has chosen their current implementation as it is. I can find no bug reports nor discussions involving this topic and the LWG issue does not mention diverging implementations.</p>\n<p>The proposed solution would make <code>std::abs(0u)</code> ill-formed:</p>\n<blockquote>\n<p id=\"so_29750946_29750947_6\">If abs() is called with an argument of unsigned integral type that\n  cannot be converted to int by integral promotion ([conv.prom]), the\n  program is ill-formed. [Note: arguments that can be promoted to int\n  are permitted for compatibility with C. \u2014 end note]</p>\n</blockquote>\n<p>While some may question the notion of using <code>abs</code> with an unsigned type Howard Hinnant points out in the report that when using templates such consequences may not be apparent and provides an example:</p>\n<blockquote>\n<p id=\"so_29750946_29750947_7\">[...]especially in C++ where we have templates, and the types involved\n  are not always apparent to the programmer at design time. For example,\n  consider:</p>\n<pre><code>template &lt;class Int&gt;\nInt\nanalyze(Int x, Int y)\n{\n  // ...\n  if (std::abs(x - y) &lt; threshold)\n  {\n    // ...\n  }\n  // ...\n}\n</code></pre>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-04-22T17:48:48.510", "Id": "29750947", "Score": "16", "CreationDate": "2015-04-20T14:39:55.233", "LastActivityDate": "2015-04-22T17:48:48.510"}, "bq_ids": {"n4140": {"so_29750946_29750947_1": {"section_id": 3876, "quality": 1.0, "length": 18}, "so_29750946_29750947_0": {"section_id": 3876, "quality": 1.0, "length": 6}}, "n3337": {"so_29750946_29750947_1": {"section_id": 3736, "quality": 1.0, "length": 18}, "so_29750946_29750947_0": {"section_id": 3736, "quality": 1.0, "length": 6}}, "n4659": {"so_29750946_29750947_6": {"section_id": 4693, "quality": 0.6818181818181818, "length": 15}, "so_29750946_29750947_0": {"section_id": 4690, "quality": 0.8333333333333334, "length": 5}, "so_29750946_29750947_1": {"section_id": 4690, "quality": 1.0, "length": 18}}}, "29750946": {"CommentCount": "0", "ViewCount": "1256", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-20T14:39:55.233", "LastActivityDate": "2015-04-23T03:05:33.737", "Title": "Is std::abs(0u) ill-formed?", "LastEditDate": "2017-05-23T12:33:08.790", "Id": "29750946", "Score": "16", "Body": "<p>Given the following program:</p>\n<pre><code>#include &lt;cmath&gt;\n\nint main()\n{\n    std::abs(0u) ;\n}\n</code></pre>\n<p><code>gcc</code> and <code>clang</code> disagree on whether this is ill-formed. Using <code>gcc</code> with <code>libstdc++</code> the code builds without error or warning (<em><a href=\"http://melpon.org/wandbox/permlink/5sASqwTFEidudt0S\" rel=\"nofollow noreferrer\">see it live</a></em>), while using <code>clang</code> with <code>libc++</code> it generates the following error (<em><a href=\"http://melpon.org/wandbox/permlink/xRL9kXz2sjeda2ZE\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>error: call to 'abs' is ambiguous\nstd::abs(0u) ;\n^~~~~~~~\n</code></pre>\n<p>Which result is correct? Should <code>abs(0u)</code> be ambiguous or not?</p>\n<hr>\n<p>MSalters points out an interesting related question: <a href=\"https://stackoverflow.com/q/29411486/1708801\">Template version of std::abs</a>.</p>\n</hr>", "Tags": "<c++><c++11><language-lawyer><cmath>", "OwnerUserId": "1708801", "AnswerCount": "1"}});