post_cb({"13955770": {"ParentId": "13955634", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The two are equally safe. Provided no element is accessed from multiple threads you're OK. Your parallel loop will access each element only once, and hence only from one thread.</p>\n<p>There's space in the standard for the member functions of containers to be non-thread-safe. In this case you use <code>vector&lt;int&gt;::operator[]</code>, so you'd want an explicit guarantee of thread-safety for that member, which seems reasonable since calling it even on a non-const vector doesn't modify the vector itself. So I doubt that there's a problem in this case, but I haven't looked for the guarantee [edit: rici found it]. Even if it's potentially unsafe, you could do <code>int *dataptr = &amp;data.front()</code> before the loop and then index off <code>dataptr</code> instead of <code>data</code>.</p>\n<p>As an aside, this code is <em>not</em> guaranteed safe for <code>vector&lt;bool&gt;</code>, since it's a special-case for which multiple elements co-exist inside one object. It would be safe for an array of <code>bool</code>, since the different elements of that are different \"memory locations\" (1.7 in C++11).</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2012-12-19T15:48:40.920", "Id": "13955770", "Score": "22", "CreationDate": "2012-12-19T15:33:21.617", "LastActivityDate": "2012-12-19T15:48:40.920"}, "13955871": {"ParentId": "13955634", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>For c++11, which specifies rules for data races, the thread-safety of containers is described. A relevant section of the standard is \u00a7 23.2.2, paragraph 2:</p>\n<blockquote>\n<p id=\"so_13955634_13955871_0\">Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting vector&lt;bool&gt;, are modified concurrently.</p>\n<p id=\"so_13955634_13955871_1\">[ Note: For a vector&lt;int&gt; x with a size greater than one, x[1] = 5 and *x.begin() = 10 can be executed concurrently without a data race, but x[0] = 5 and *x.begin() = 10 executed concurrently may result in a data race. As an exception to the general rule, for a vector&lt;bool&gt; y, y[0] = true may race with y[1] = true. \u2014end note ]</p>\n</blockquote>\n<p>The mentioned \u00a7 17.6.5.9 essentially bans any concurrent modification by any standard library interface unless specifically allowed, so the section I quote tells you exactly what's allowed (and that includes your usage).</p>\n<p>Since the question was raised by Steve Jessop, paragraph 1 of \u00a7 23.2.2 explicitly allows the concurrent use of <code>[]</code> in sequence containers:</p>\n<blockquote>\n<p id=\"so_13955634_13955871_2\">For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at and, except in associative or unordered associative containers, operator[].</p>\n</blockquote>\n", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2012-12-19T15:44:23.187", "Id": "13955871", "Score": "16", "CreationDate": "2012-12-19T15:39:24.843", "LastActivityDate": "2012-12-19T15:44:23.187"}, "13955634": {"CommentCount": "3", "AcceptedAnswerId": "13955770", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-19T15:27:57.460", "LastActivityDate": "2012-12-19T15:48:40.920", "LastEditDate": "2017-05-23T12:34:14.767", "ViewCount": "6642", "FavoriteCount": "2", "Title": "Thread-safety of writing a std::vector vs plain array", "Id": "13955634", "Score": "16", "Body": "<p>I've read <a href=\"https://stackoverflow.com/questions/1362110/is-the-c-stdset-thread-safe\">on Stackoverflow</a> that <strong>none of the STL containers are thread-safe for writing</strong>. But what does that mean in practice? Does it mean I should store writable data in plain arrays?</p>\n<p>I expect concurrent calls to <code>std::vector::push_back(element)</code> could lead to inconsistent data structures becaue it might entail resizing the vector. But what about a case like this, where resizing is not involved:</p>\n<p>1) using an array:</p>\n<pre><code>int data[n];\n// initialize values here...\n\n#pragma omp parallel for\nfor (int i = 0; i &lt; n; ++i) {\n    data[i] += func(i);\n}\n</code></pre>\n<p>2) using a `std::vector``:</p>\n<pre><code>std::vector&lt;int&gt; data;\ndata.resize(n);\n// initialize values here...\n\n#pragma omp parallel for\nfor (int i = 0; i &lt; n; ++i) {\n    data[i] += func(i);\n}\n</code></pre>\n<p>Is the first implementation really better than the second one a) in terms of thread-safety and b) in terms of performance? I would prefer to use a std::vector, since I am less comfortable with C-style arrays.</p>\n<p>EDIT: I removed a <code>#pragma omp atomic update</code> protecting the write.</p>\n", "Tags": "<c++><stl><thread-safety><openmp>", "OwnerUserId": "626537", "AnswerCount": "4"}, "13955703": {"ParentId": "13955634", "CommentCount": "2", "Body": "<p>The main thing it means is that if you have multiple threads accessing the vector, you can't depend on C++ to keep you from corrupting the data structure with multiple concurrent writes.  So you need to use some kind of guard.  On the other hand, if your program doesn't use multiple threads, as your examples don't seem to, you're perfectly fine.</p>\n", "OwnerUserId": "35092", "PostTypeId": "2", "Id": "13955703", "Score": "1", "CreationDate": "2012-12-19T15:30:54.330", "LastActivityDate": "2012-12-19T15:30:54.330"}, "bq_ids": {"n4140": {"so_13955634_13955871_1": {"section_id": 719, "quality": 0.8709677419354839, "length": 27}, "so_13955634_13955871_2": {"section_id": 717, "quality": 0.9259259259259259, "length": 25}, "so_13955634_13955871_0": {"section_id": 718, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_13955634_13955871_1": {"section_id": 708, "quality": 0.8709677419354839, "length": 27}, "so_13955634_13955871_2": {"section_id": 706, "quality": 0.9259259259259259, "length": 25}, "so_13955634_13955871_0": {"section_id": 707, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_13955634_13955871_1": {"section_id": 750, "quality": 0.8709677419354839, "length": 27}, "so_13955634_13955871_2": {"section_id": 748, "quality": 0.9259259259259259, "length": 25}, "so_13955634_13955871_0": {"section_id": 749, "quality": 0.8947368421052632, "length": 17}}}, "13955743": {"ParentId": "13955634", "CommentCount": "0", "Body": "<p>In this case you should just construct your vector with necessary number of values? and all will work fine.</p>\n<pre><code>std::vector&lt;int&gt; data(n, 0);\n</code></pre>\n<p><code>resize()</code> works well to. The performance will be equal.\nThe reason why multithread access will not corrupt the vector is: your data is located at its place and will not move from there. OMP threads will not access to the same element at a time.</p>\n", "OwnerUserId": "706900", "PostTypeId": "2", "Id": "13955743", "Score": "1", "CreationDate": "2012-12-19T15:32:04.463", "LastActivityDate": "2012-12-19T15:32:04.463"}});