post_cb({"8062466": {"ParentId": "8062344", "CommentCount": "0", "Body": "<p>The statement you cite is a generic description.  Regardless of what is\nbeing output, the field will have at least that many characters; that is\nthe meaning of <em>minimum</em>.  The exact meaning of the field depends on the\ntype of data being output.  In the case of integer output, the exact\nformat is specified in \u00a722.4.2.2; this includes not only how the width\nfield is interpreted, and a guarantee that the field will not be larger\nunless necessary to display the value according to the format specified,\nbut also what character to use for the fill, and where to put it.\n(Stroustrup's example leaves all of the other parameters with their\ndefault values, but if you have a negative number, and specified a fill\ncharacter of '0', you wouldn't want it to result in <code>|000-1234|</code>, but\nrather <code>|-0001234|</code>.)</p>\n<p>For user defined types, it's entirely possible that the field contain\nless than the minimum.  I would consider this a bug, but I imagine a lot\nof user defined <code>&lt;&lt;</code> are written without consideration of any of the\nformatting parameters.  The actual effect of <code>std::setw</code> is only to set\na field in the <code>std::basic_ios&lt;char&gt;</code> class; it's up to the\nimplementation of <code>&lt;&lt;</code> to handle it correctly. </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "8062466", "Score": "1", "CreationDate": "2011-11-09T08:58:49.720", "LastActivityDate": "2011-11-09T08:58:49.720"}, "8062344": {"CommentCount": "1", "ViewCount": "265", "CreationDate": "2011-11-09T08:47:09.597", "LastActivityDate": "2011-11-09T08:58:49.720", "Title": "formatted output of a number and field width, where does the C++ standard say about it?", "PostTypeId": "1", "Id": "8062344", "Score": "1", "Body": "<p>This code snippet:</p>\n<pre><code>//\n// This is example code from Chapter 11.2.5 \"Fields\" of\n// \"Programming -- Principles and Practice Using C++\" by Bjarne Stroustrup\n//\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; 123456                        // no field used\n         &lt;&lt;'|'&lt;&lt; setw(4) &lt;&lt; 123456 &lt;&lt; '|' // 123456 doesn't fit in a 4 char field\n         &lt;&lt; setw(8) &lt;&lt; 123456 &lt;&lt; '|'      // set field width to 8\n         &lt;&lt; 123456 &lt;&lt; \"|\\n\";              // field sizes don't stick\n}\n</code></pre>\n<p>produces this output:</p>\n<pre><code>123456|123456|  123456|123456|\n</code></pre>\n<p>The second print of <code>123456</code> is not truncated to fit in a field with width of 4 and Stroustrup explains that it is the right thing to do because a bad looking table with right numbers is better than a good looking table with wrong numbers.</p>\n<p>where does the C++ standard say about this behaviour?</p>\n<p>I found <code>ios_base::width</code> where the standard says:</p>\n<blockquote>\n<p id=\"so_8062344_8062344_0\">The minimum field width (number of characters) to generate on certain\n  output conversions</p>\n</blockquote>\n<p>Is \"minimum\" the keyword here to explain the said behaviour?</p>\n", "Tags": "<c++>", "OwnerUserId": "15485", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8062344_8062344_0": {"section_id": 1965, "quality": 0.9, "length": 9}}, "n3337": {"so_8062344_8062344_0": {"section_id": 1954, "quality": 0.9, "length": 9}}, "n4659": {"so_8062344_8062344_0": {"section_id": 2236, "quality": 0.9, "length": 9}}}});