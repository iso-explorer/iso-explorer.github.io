post_cb({"bq_ids": {"n4140": {"so_32017004_32017587_1": {"length": 45, "quality": 0.9, "section_id": 300}}, "n3337": {"so_32017004_32017587_1": {"length": 45, "quality": 0.9, "section_id": 291}}, "n4659": {"so_32017004_32017587_1": {"length": 41, "quality": 0.82, "section_id": 307}}}, "32017004": {"ViewCount": "243", "Body": "<p>I want to implement a <code>has_no_duplicates&lt;...&gt;</code> type trait that evaluates to <code>std::true_type</code> if the passed variadic type list has no duplicate types.</p>\n<pre><code>static_assert(has_no_duplicates&lt;int, float&gt;{}, \"\");\nstatic_assert(!has_no_duplicates&lt;float, float&gt;{}, \"\");\n</code></pre>\n<p>Let's assume, for the scope of this question, that I want to do that using multiple inheritance. </p>\n<p>When a class inherits from the same type more than once, an error occurs.</p>\n<pre><code>template&lt;class T&gt; \nstruct type { };\n\ntemplate&lt;class... Ts&gt;\nstruct dup_helper : type&lt;Ts&gt;... { };\n\n// No errors, compiles properly.\ndup_helper&lt;int, float&gt; ok{};\n\n// Compile-time error: \n// base class 'type&lt;float&gt;' specified more than once as a direct base class\ndup_helper&lt;float, float&gt; error{};\n</code></pre>\n<p>I assumed I could've used <code>void_t</code> to \"detect\" this error, but I couldn't implement a working solution <a href=\"http://en.cppreference.com/w/cpp/types/void_t\">following the code samples from cppreference</a>.</p>\n<p>This is what I tried:</p>\n<pre><code>template&lt;class, class = void&gt;\nstruct is_valid \n    : std::false_type { };\n\n// First try:\ntemplate&lt;class T&gt;\nstruct is_valid&lt;T, std::void_t&lt;decltype(T{})&gt;&gt; \n    : std::true_type { };\n\n// Second try:\ntemplate&lt;class T&gt;\nstruct is_valid&lt;T, std::void_t&lt;T&gt;&gt; \n    : std::true_type { };\n</code></pre>\n<p>For my third try, I tried delaying the expansion of <code>dup_helper&lt;...&gt;</code> using a wrapper class that took <code>dup_helper</code> as a template template parameter, like <code>wrapper&lt;dup_helper, ...&gt;</code> and expanded it inside of <code>void_t</code>.</p>\n<p>Unfortunately, all my tries resulted in the aforementioned error always preventing compilation.</p>\n<p>I assume this type of error is not detectable as a \"substitution failure\", but I'd like confirmation.</p>\n<hr>\n<p>Is this kind of error actually impossible to detect using <code>void_t</code>? (Will it always result in a compilation failure?)</p>\n<p>Is there a way to detect it without causing compilation to fail? (Or a non-<code>void_t</code> workaround that still makes use of the \"multiple inheritance trick\")?</p>\n</hr>", "AcceptedAnswerId": "32017587", "Title": "Using `void_t` to detect multiple inheritance type repetition errors", "CreationDate": "2015-08-14T18:57:34.167", "Id": "32017004", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-08-14T20:55:12.703", "Score": "8", "OwnerUserId": "598696", "Tags": "<c++><templates><sfinae><c++1z><variadic-functions>", "AnswerCount": "2"}, "32017587": {"Id": "32017587", "PostTypeId": "2", "Body": "<p>As @Canoninos noted, the problem is that:</p>\n<blockquote>\n<p id=\"so_32017004_32017587_0\">it isn't the declaration of <code>dup_helper&lt;T, T&gt;</code> which causes an error but its definition [...].</p>\n</blockquote>\n<p>Or, in Standardese, the error occurs outside the \"immediate context\" (<strong>[temp.deduct]</strong>) of the substitution:</p>\n<blockquote>\n<p id=\"so_32017004_32017587_1\">8 - [...] Only invalid types and expressions in the <strong>immediate context</strong> of the function type and\n  its template parameter types can result in a deduction failure. [ <em>Note:</em> The evaluation of the substituted types\n  and expressions can result in side effects such as the <strong>instantiation of class template specializations</strong> and/or\n  function template specializations, the generation of implicitly-defined functions, etc. Such side effects are\n  not in the \u201cimmediate context\u201d and can result in the program being ill-formed. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Here the error occurs <em>while instantiating</em> <code>dup_helper&lt;float, float&gt;</code> so is not in the \"immediate context\".</p>\n<p>One multiple inheritance trick that's very close to yours involves adding an extra layer of inheritance, by indexing the multiple bases:</p>\n<pre><code>helper&lt;&lt;0, 1&gt;, &lt;float, float&gt;&gt;        \n             +            \n        +----+----+       \n        v         v       \n ix&lt;0, float&gt;  ix&lt;1, float&gt;\n        +         +       \n        v         v       \n     t&lt;float&gt;  t&lt;float&gt;   \n</code></pre>\n<p>This gives us a helper class with a valid definition and that can be instantiated but not cast to its ultimate base classes, because of ambiguity:</p>\n<pre><code>static_cast&lt;t&lt;float&gt;&gt;(helper&lt;...&gt;{});  // Error, SFINAE-usable\n</code></pre>\n<p><a href=\"http://goo.gl/q42uVU\" rel=\"nofollow\">Example</a>.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-08-14T19:59:48.930", "Score": "6", "CreationDate": "2015-08-14T19:43:23.143", "ParentId": "32017004", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2015-08-14T19:59:48.930"}, "32018387": {"Id": "32018387", "PostTypeId": "2", "Body": "<p>That's my solution using meta-programming and type-list idiom.\nI use this code as part of my library implementing reflection for C++. I think there is no need in void_t or inheritance at all to solve this task.</p>\n<pre><code>template &lt;typename ...Args&gt;\nstruct type_list\n{};\n\nusing empty_list = type_list&lt;&gt;;\n\n// identity\ntemplate&lt;typename T&gt;\nstruct identity\n{\n    using type = T;\n};\n\n// is_typelist\ntemplate&lt;typename T&gt;\nstruct is_typelist: std::false_type\n{};\n\ntemplate&lt;typename ...Args&gt;\nstruct is_typelist&lt;type_list&lt;Args...&gt;&gt;: std::true_type\n{};\n\ntemplate&lt;typename T&gt;\nstruct check_typelist\n{\n    using type = void;\n    static constexpr void *value = nullptr;\n    static_assert(is_typelist&lt;T&gt;::value, \"T is not a type_list!\");\n};\n\n// indexof\nnamespace internal {\n\ntemplate&lt;typename T, typename V, std::int64_t index&gt;\nstruct typelist_indexof_helper: check_typelist&lt;T&gt;\n{};\n\ntemplate&lt;typename H, typename ...T, typename V, std::int64_t index&gt;\nstruct typelist_indexof_helper&lt;type_list&lt;H, T...&gt;, V, index&gt;:\n        std::conditional&lt;std::is_same&lt;H, V&gt;::value,\n            std::integral_constant&lt;std::int64_t, index&gt;,\n            typelist_indexof_helper&lt;type_list&lt;T...&gt;, V, index + 1&gt;\n        &gt;::type\n{};\n\ntemplate&lt;typename V, std::int64_t index&gt;\nstruct typelist_indexof_helper&lt;empty_list, V, index&gt;: std::integral_constant&lt;std::int64_t, -1&gt;\n{};\n\n}\n\ntemplate&lt;typename T, typename V&gt;\nusing typelist_indexof = ::internal::typelist_indexof_helper&lt;T, V, 0&gt;;\n\ntemplate&lt;typename T, typename V&gt;\nstruct typelist_exists: std::integral_constant&lt;bool, typelist_indexof&lt;T, V&gt;::value &gt;= 0&gt;\n{};\n\n// remove_duplicates\nnamespace internal {\n\ntemplate&lt;typename P, typename T&gt;\nstruct typelist_remove_duplicates_helper: check_typelist&lt;T&gt;\n{};\n\ntemplate&lt;typename ...P, typename H, typename ...T&gt;\nstruct typelist_remove_duplicates_helper&lt;type_list&lt;P...&gt;, type_list&lt;H, T...&gt;&gt;:\n        std::conditional&lt;typelist_exists&lt;type_list&lt;T...&gt;, H&gt;::value,\n            typelist_remove_duplicates_helper&lt;type_list&lt;P...&gt;, type_list&lt;T...&gt;&gt;,\n            typelist_remove_duplicates_helper&lt;type_list&lt;P..., H&gt;, type_list&lt;T...&gt;&gt;\n        &gt;::type\n{};\n\ntemplate&lt;typename ...P&gt;\nstruct typelist_remove_duplicates_helper&lt;type_list&lt;P...&gt;, empty_list&gt;: identity&lt;type_list&lt;P...&gt;&gt;\n{};\n\n}\n\ntemplate&lt;typename T&gt;\nusing typelist_remove_duplicates = ::internal::typelist_remove_duplicates_helper&lt;empty_list, T&gt;;\n\n\ntemplate&lt;typename ...Args&gt;\nstruct has_no_duplicates: std::integral_constant&lt;bool, std::is_same&lt;type_list&lt;Args...&gt;,\n                                                                    typename typelist_remove_duplicates&lt;type_list&lt;Args...&gt;&gt;::type&gt;::value&gt;\n{};\n</code></pre>\n<p><a href=\"http://ideone.com/28xolZ\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n", "LastEditorUserId": "4712648", "LastActivityDate": "2015-08-14T20:55:12.703", "Score": "0", "CreationDate": "2015-08-14T20:44:39.803", "ParentId": "32017004", "CommentCount": "0", "OwnerUserId": "4712648", "LastEditDate": "2015-08-14T20:55:12.703"}});