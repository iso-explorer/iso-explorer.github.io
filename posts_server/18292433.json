post_cb({"18293070": {"ParentId": "18292433", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>NO, no elements will be harmed during any operation.</p>\n<p>As is explained in <a href=\"https://stackoverflow.com/q/6438086/819272\"><strong>this famous Q&amp;A</strong></a>, for associative containers, there is no iterator invalidation upon insertions / erasure (except for the element being erased of course). For unordered associative containers, there is iterator invalidation during <strong>rehashing</strong>, about which the Standard says (emphasize mine)</p>\n<p><strong>23.2.5 Unordered associative containers [unord.req]</strong></p>\n<blockquote>\n<p id=\"so_18292433_18293070_0\">9 The elements of an unordered associative container are organized into\n  buckets. Keys with the same hash code appear in the same bucket. The\n  number of buckets is automatically increased as elements are added to\n  an unordered associative container, so that the average number of\n  elements per bucket is kept below a bound. <strong>Rehashing invalidates\n  iterators</strong>, changes ordering between elements, and changes which\n  buckets elements appear in, but <strong>does not invalidate pointers or\n  references to elements</strong>. For unordered_multiset and unordered_multimap,\n  rehashing preserves the relative ordering of equivalent elements.</p>\n</blockquote>\n<p>Again, this does not entail the reshuflling of the actually stored elements (the <code>Key</code> and <code>Value</code> types in <code>unordered_map&lt;Key, Value&gt;</code>), because unordered  maps have buckets that are organized as linked lists, and iterators to stored elements (key-value pairs) have both an element pointer and a bucket pointer. The rehashing shuffles buckets, which invalidates the iterators (because their bucket pointer is invalidated) but not pointers or references to the elements itself. This is explained in detail in <a href=\"https://stackoverflow.com/q/11337494/819272\"><strong>another Q&amp;A</strong></a></p>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:56:38.647", "Id": "18293070", "Score": "5", "CreationDate": "2013-08-17T20:34:07.780", "LastActivityDate": "2013-08-17T20:34:07.780"}, "18292559": {"ParentId": "18292433", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_18292433_18292559_0\">How often do std::multimap and std::unordered_multimap shuffle entries around?</p>\n</blockquote>\n<p>Never. The iterators that point to elements of any associative container (including sets, maps, and their unordered or \"multi\" versions) are never invalidated (unless the specific element they point to is deleted). In other words, the actual elements are never \"shuffled around\". These are required to be implemented as linked structures (e.g., linked-tree), meaning they can be re-structured just by changing a few pointers, without having to physically move any element.</p>\n<p>EDIT: Apparently (see TemplateRex' comment), this is not the case for unordered containers. In that case, the iterators can get invalidated, but the elements themselves do not move around. These requirements imply an indirect container with no back-pointer, which I guess is a reasonable choice, but not one I would have expected.</p>\n<blockquote>\n<p id=\"so_18292433_18292559_1\">What happens if I do this: ... (get <code>[]</code> of multimap) ...</p>\n</blockquote>\n<p>The <code>operator[]</code> is not defined for <code>std::multimap</code> (or unordered version). So, what would happen? A compiler error would happen.</p>\n<blockquote>\n<p id=\"so_18292433_18292559_2\">Is the result different if it's an unordered_multimap instead?</p>\n</blockquote>\n<p>No, it's the same, the <code>operator[]</code> does not exist.</p>\n<blockquote>\n<p id=\"so_18292433_18292559_3\">Back to passing references around to distinguish entries with the same hash. Is there a safer way to do that?</p>\n</blockquote>\n<p>Yes, the recommended practice is to refer to elements of the map / set / whatever using iterators, not references. The iterators to elements are guaranteed to remain valid, and they are copyable and have the right const-ness protection on them, and that makes them the perfect objects to \"refer to an entry\".</p>\n<p>EDIT: As per the same comment, I would have to recommend using pointers to the elements if dealing with a hashed container (unordered containers), because iterators are not guaranteed (by the standard) to remain valid.</p>\n", "OwnerUserId": "491645", "LastEditorUserId": "491645", "LastEditDate": "2013-08-17T21:25:49.227", "Id": "18292559", "Score": "2", "CreationDate": "2013-08-17T19:28:47.017", "LastActivityDate": "2013-08-17T21:25:49.227"}, "18292528": {"ParentId": "18292433", "CommentCount": "0", "Body": "<p>All of the associative containers in the C++ standard library are node based, i.e., their elements stay put. However, whether the hash is computed on the object after copying it or on a temporary object passed to the container isn't specified. I would guess, that generally the hash is computed before the object is copied/moved.</p>\n<p>To distinguish elements with the same hash you need to have an equality function anyway: if the location of the object causes it to be different it would mean that all objects are different and you wouldn't be able to look them up at all. You need to have an equality function for the elements in an unordered container which defines equivalence of keys. For the ordered associative the equivalent class is based on the strict weak ordering, i.e., on an expression like this (using <code>&lt;</code> rather than a binary predicate for readability; any binary predicate defining a strict weak order would work, too):</p>\n<pre><code>bool equivalent = !(a &lt; b) &amp;&amp; !(b &lt; a);\n</code></pre>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "18292528", "Score": "1", "CreationDate": "2013-08-17T19:24:22.057", "LastActivityDate": "2013-08-17T19:24:22.057"}, "bq_ids": {"n4140": {"so_18292433_18293070_0": {"section_id": 761, "quality": 0.9322033898305084, "length": 55}}, "n3337": {"so_18292433_18293070_0": {"section_id": 748, "quality": 0.9322033898305084, "length": 55}}, "n4659": {"so_18292433_18293070_0": {"section_id": 821, "quality": 0.9322033898305084, "length": 55}}}, "18292433": {"CommentCount": "2", "ViewCount": "288", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-08-17T19:12:37.257", "LastActivityDate": "2013-08-17T21:25:49.227", "Title": "Questions about STL containers in C++", "LastEditDate": "2013-08-17T21:23:40.447", "Id": "18292433", "Score": "3", "Body": "<ol>\n<li><p>How often do std::multimap and std::unordered_multimap shuffle entries around? I'm asking because my code passes around references to distinguish between entries with the same hash, and I want to know when to run the reference redirection function on them. </p></li>\n<li><p>What happens if I do this:</p>\n<pre><code>std::multimap atable; //Type specification stuff left out\n//Code that pus in two entries with the same key, call that key foo\nint bar = atable[foo];\n</code></pre></li>\n<li><p>Is the result different if it's an unordered_multimap instead?</p></li>\n<li><p>Back to passing references around to distinguish entries with the same hash. Is there a safer way to do that?</p></li>\n<li><p>Do the entries move around if I remove one of the entries (That's what's suggested by a reading of the documentation for std::vector)? </p></li>\n</ol>\n", "Tags": "<c++><c++11><stl><unordered-map><multimap>", "OwnerUserId": "2557075", "AnswerCount": "3"}});