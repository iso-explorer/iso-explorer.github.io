post_cb({"39614455": {"ParentId": "39614225", "CommentCount": "12", "Body": "<p>The compilers seem to adhere to <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow\">[expr.const]/(2.20)</a>:</p>\n<blockquote>\n<p id=\"so_39614225_39614455_0\">\u2014 a relational (5.9) or equality (5.10) operator where the result is unspecified;</p>\n</blockquote>\n<p>Perhaps pointers to two such objects are not necessarily specified to be unequal, but it appears to be a bug to me, nonetheless.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "39614455", "Score": "2", "CreationDate": "2016-09-21T10:49:23.033", "LastActivityDate": "2016-09-21T10:49:23.033"}, "39614225": {"CommentCount": "9", "ViewCount": "343", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2016-09-21T10:38:58.040", "LastActivityDate": "2017-02-02T20:58:22.497", "Title": "Weird constexpr typeid errors", "FavoriteCount": "2", "LastEditDate": "2017-02-02T20:58:22.497", "Id": "39614225", "Score": "3", "Body": "<p>Given the code</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;type_traits&gt;\n\nstruct A {};\nstruct B {};\n\nstatic_assert(&amp;typeid(A), \"\"); // Fine\nstatic_assert(&amp;typeid(B), \"\"); // Fine\nstatic_assert(&amp;typeid(A) != nullptr, \"\"); // Fine\nstatic_assert(&amp;typeid(B) != nullptr, \"\"); // Fine\n\nconstexpr auto const * tA = &amp;typeid(A);\nconstexpr auto const * tB = &amp;typeid(B);\nusing T = decltype(tA);\nusing T2 = decltype(tB);\nstatic_assert(std::is_same&lt;T, T2&gt;::value, \"\"); // Fine, identical types!\nstatic_assert(tA == tA, \"\"); // Fine (comparing values of identical type)\nstatic_assert(tB == tB, \"\"); // Fine (comparing values of identical type)\nstatic_assert(tA != tB, \"\"); // Error: comparing values of identical type\n                             //        suddenly not constexpr?\n</code></pre>\n<p>I get the following error with Clang:</p>\n<pre><code>$ clang++ -std=c++1z test.cpp -o test\ntest.cpp:19:18: error: static_assert expression is not an integral constant expression\nstatic_assert(tA != tB, \"\"); // Error: comparing values of identical type not constexpr?\n            ~~~^~~~~\n1 error generated.\n</code></pre>\n<p>And GCC:</p>\n<pre><code>$ g++-6.3.0 -std=c++1z test.cpp -o test\ntest.cpp:19:1: error: non-constant condition for static assertion\nstatic_assert(tA != tB, \"\"); // Error: comparing values of identical type not constexpr?\n^~~~~~~~~~~~~\ntest.cpp:19:18: error: '(((const std::type_info*)(&amp; _ZTI1A)) != ((const std::type_info*)(&amp; _ZTI1B)))' is not a constant expression\nstatic_assert(tA != tB, \"\"); // Error: comparing values of identical type not constexpr?\n            ~~~^~~~~\n</code></pre>\n<p>It doesn't matter if I use <code>void</code> instead of <code>auto</code> for <code>tA</code> and <code>tB</code>. Only GCC-s output changes slightly:</p>\n<pre><code>$ g++-6.3.0 -std=c++1z test.cpp -o test\ntest.cpp:19:5: error: non-constant condition for static assertion\n    static_assert(tA != tB, \"\"); // Error: comparing values of identical type not constexpr?\n    ^~~~~~~~~~~~~\ntest.cpp:19:22: error: '(((const void*)(&amp; _ZTI1A)) != ((const void*)(&amp; _ZTI1B)))' is not a constant expression\n    static_assert(tA != tB, \"\"); // Error: comparing values of identical type not constexpr?\n                ~~~^~~~~\n</code></pre>\n<p>Can someone please explain why only the last <code>static_assert</code> fails to compile, whereas the others do compile AND pass?</p>\n", "Tags": "<c++><c++11><language-lawyer><typeid><compiler-bug>", "OwnerUserId": "3919155", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39614225_39614455_0": {"section_id": 6185, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_39614225_39614455_0": {"section_id": 5946, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_39614225_39614455_0": {"section_id": 7687, "quality": 0.8571428571428571, "length": 6}}}});