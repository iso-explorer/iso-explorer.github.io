post_cb({"bq_ids": {"n4140": {"so_35425488_35427581_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 6030}, "so_35425488_35427581_3": {"length": 19, "quality": 1.0, "section_id": 593}, "so_35425488_35427581_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 620}, "so_35425488_35427581_2": {"length": 34, "quality": 0.7906976744186046, "section_id": 592}}, "n3337": {"so_35425488_35427581_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 5798}, "so_35425488_35427581_3": {"length": 19, "quality": 1.0, "section_id": 583}, "so_35425488_35427581_2": {"length": 34, "quality": 0.7906976744186046, "section_id": 582}, "so_35425488_35427581_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 610}}, "n4659": {"so_35425488_35427581_3": {"length": 19, "quality": 1.0, "section_id": 616}, "so_35425488_35427581_2": {"length": 36, "quality": 0.8372093023255814, "section_id": 615}, "so_35425488_35427581_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 646}}}, "35425488": {"ViewCount": "303", "Body": "<p>I have two classes, <code>A</code> and <code>B</code>, each defining a conversion to <code>B</code>. <code>A</code> has a conversion operator to <code>B</code>, <code>B</code> has a constructor from <code>A</code>. Shouldn't a call to <code>static_cast&lt;B&gt;</code> be ambiguous? Using g++ this code compiles and chooses the conversion constructor.</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nstruct B;\nstruct A {\n    A(const int&amp; n) : x(n) {}\n    operator B() const;         //this const doesn't change the output of this code\n    int x;\n};\n\nstruct B{\n    B(const double&amp; n) : x(n) {}\n    B(const A&amp; a);\n    double x;\n};\n\nA::operator B() const           //this const doesn't change the output of this code\n{\n    cout &lt;&lt; \"called A's conversion operator\" &lt;&lt; endl;\n    return B(double(x));\n}\n\nB::B(const A&amp; a)\n{\n    cout &lt;&lt; \"called B's conversion constructor\" &lt;&lt; endl;\n    x = (double) a.x;\n}\n\nint main() {\n    A a(10);\n    static_cast&lt;B&gt;(a);            // prints B's conversion constructor\n}\n</code></pre>\n", "AcceptedAnswerId": "35427581", "Title": "Shouldn't this code throw an ambiguous conversion error?", "CreationDate": "2016-02-16T06:41:10.410", "Id": "35425488", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-02-16T10:17:38.417", "LastEditorUserId": "3747990", "LastActivityDate": "2016-02-17T13:16:36.380", "Score": "14", "OwnerUserId": "5522938", "Tags": "<c++><casting>", "AnswerCount": "1"}, "35427581": {"Id": "35427581", "PostTypeId": "2", "Body": "<p>For user defined conversion sequences; there does not seem to a precedence given between the converting constructor and the conversion operator, they are both candidates;</p>\n<p>\u00a713.3.3.1.2/1 <strong>User-defined conversion sequences</strong></p>\n<blockquote>\n<p id=\"so_35425488_35427581_0\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by a user- defined conversion (12.3) followed by a second standard conversion sequence. If the user-defined conversion is specified by a constructor (12.3.1), the initial standard conversion sequence converts the source type to the type required by the argument of the constructor. If the user-defined conversion is specified by a conversion function (12.3.2), the initial standard conversion sequence converts the source type to the implicit object parameter of the conversion function.</p>\n</blockquote>\n<p>Hence if the conversion had been;</p>\n<pre><code>B b2 = a; // ambiguous?\n</code></pre>\n<p>It could be ambiguous and the compilation fail. Clang fails the compilation, g++ accepts the code and uses the constructor; <a href=\"http://coliru.stacked-crooked.com/a/c9600d06d7009131\" rel=\"nofollow\">demo code</a>, VS also accepts the code. VS and g++ call the converting constructor (as per the OP code).</p>\n<p>In consideration of the posted code, the user defined conversion sequences (by constructor and converting operator) and the use of <code>static_cast</code> need to be considered.</p>\n<p>\u00a75.2.9/4 <strong>Static cast</strong></p>\n<blockquote>\n<p id=\"so_35425488_35427581_1\">An expression e can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. The expression <code>e</code> is used as a glvalue if and only if the initialization uses it as a lvalue.</p>\n</blockquote>\n<p>From the above quote, the <code>static_cast</code> is equivalent to <code>B temp(a);</code> and as such, the direct initialisation sequence is used.</p>\n<p>\u00a713.3.1.3/1 <strong>Initialization by constructor</strong></p>\n<blockquote>\n<p id=\"so_35425488_35427581_2\">When objects of class type are direct-initialized (8.5), copy-initialized from an expression of the same or a derived class type (8.5), or default-initialized (8.5), <strong>overload resolution selects the constructor</strong>. For direct- initialization or default-initialization, the candidate functions are all the constructors of the class of the object being initialized. For copy-initialization, the candidate functions are all the converting constructors (12.3.1) of that class. The argument list is the expression-list or assignment-expression of the initialiser.</p>\n</blockquote>\n<p>In general (excluding any constructors and operators marked as <code>explicit</code> and <code>const</code> concerns), given the <code>B(const A&amp; a);</code> constructor and the construction of a <code>B</code> from an <code>A</code>, the constructor should win since it offers the exact match when considering the <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">best viable function</a>; since further <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">implicit conversions</a> are not needed (\u00a713.3; Overload resolution).</p>\n<hr>\n<p>If the constructor <code>B(const A&amp; a);</code> was removed, the conversion (with the <code>static_cast&lt;&gt;</code> would still succeed since the user defined conversion operator is a candidate and its use is not ambiguous.</p>\n<p>\u00a713.3.1.4/1 <strong>Copy-initialization of class by user-defined conversion</strong></p>\n<blockquote>\n<p id=\"so_35425488_35427581_3\">Under the conditions specified in 8.5, as part of a copy-initialization of an object of class type, a user-defined conversion can be invoked to convert an initializer expression to the type of the object being initialized.</p>\n</blockquote>\n<p>Quotes are taken from the N4567 draft of the C++ standard.</p>\n<hr>\n<p>It would also be instructive to invoke a user-defined conversion sequence outside just the construction of an object, i.e. calling a method.</p>\n<p>Given the code listing (and the rules above);</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct A;\nstruct B {\n    B() {}\n    B(const A&amp;) { cout &lt;&lt; \"called B's conversion constructor\" &lt;&lt; endl; }\n};\nstruct A {\n    A() {}\n    operator B() const { cout &lt;&lt; \"called A's conversion operator\" &lt;&lt; endl; return B(); }\n};\nvoid func(B) {}\nint main() {\n    A a;\n    B b1 = static_cast&lt;B&gt;(a); // 1. cast\n    B b2 = a; // 2. copy initialise\n    B b3 ( a ); // 3. direct initialise\n    func(a); // 4. user defined conversion\n}\n</code></pre>\n<p>Clang, g++ (<a href=\"http://coliru.stacked-crooked.com/a/69580bf68f5adde0\" rel=\"nofollow\">demo</a>) and VS offer different results and thus possibly different levels of compliance.</p>\n<ul>\n<li>clang fails 2. and 4.</li>\n<li>g++ accepts 1. through 4.</li>\n<li>VS fails 4.</li>\n</ul>\n<p>From the rules above, 1. through 3. should all succeed since the <code>B</code> converting constructor is a candidate and requires no further user conversions; direct construction and copy initialisation is used for those forms. Reading from the standard (the excerpts above, in particular \u00a713.3.3.1.2/1 and \u00a713.3.1.4/1, and then \u00a78.5/17.6.2), 2. and 4. could/should fail and be ambiguous - since the conversion constructor and the conversion operator are being considered with no clear ordering.</p>\n<p>I believe this may well be an unintended use case (types being able to convert to each other in this way; there is an argument for where there would be one conversion sequence would be the general use case).</p>\n</hr></hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2016-02-17T13:16:36.380", "Score": "13", "CreationDate": "2016-02-16T08:39:11.383", "ParentId": "35425488", "CommentCount": "4", "LastEditDate": "2016-02-17T13:16:36.380", "OwnerUserId": "3747990"}});