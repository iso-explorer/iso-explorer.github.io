post_cb({"3507150": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First the derived, then the base. No difference wrt the non-virtual cases. </p>\n<p>Additional note. When you have inheritance and virtual methods, you have to declare destructors as virtual, otherwise you can have undefined behavior at deletion.</p>\n<p>Example, suppose Derived is derived from Base, and you allocate Derived with the following line:</p>\n<pre><code>Base *o = new Derived();\ndelete(o);\n</code></pre>\n<p>If this case occurs in your code, and Base has no virtual destructor, the resulting behavior is undefined. Typically, only the destructor of Base will be called. The destructor of Derived will not be called, because you are calling delete on a Base pointer. However, the program might crash instead. Once you are in the realm of undefined behavior, all bets are off and your running code is doomed. To prevent chaos the Base destructor must be virtual.</p>\n", "OwnerUserId": "78374", "LastEditorUserId": "78374", "LastEditDate": "2010-08-17T21:48:45.870", "Id": "3507150", "Score": "0", "CreationDate": "2010-08-17T21:33:29.333", "LastActivityDate": "2010-08-17T21:48:45.870"}, "3507226": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Since I don't see how virtual function change any objects' destruction order, I assume you're referring to the order of destruction for base classes and data members in a virtual <strong><em>inheritance</em></strong> scenario.  </p>\n<p>Sub-objects are <strong><em>constructed</em></strong> </p>\n<ol>\n<li><strong>base classes</strong> are constructed <em>from most base to most derived</em>;</li>\n<li><strong>multiple base classes</strong> are constructed in the <em>order of their declaration as base classes</em>;</li>\n<li><strong>virtual base classes</strong> are constructed <em>before all others</em>, amongst themselves adhering to the above two rules; </li>\n<li><strong>data members</strong> are constructed <em>before the enclosing object's constructor's body is executed</em>, in order of their declaration.</li>\n</ol>\n<p><strong><em>Destruction</em></strong> is simply the opposite of <em>construction</em>, so you only need to memorize the above. </p>\n<p>However, the above four rules are in that order because that makes sense, and if you understand why this order makes sense, you will not even have to memorize those four rules, but can infer them from your understanding (as I just did). So let's examine that order: </p>\n<ul>\n<li>You might want to use whatever service the base class provide from a derived class' constructor. Of course, you cannot use a (base) class object before it's actually constructed. Therefore, when a derived class is constructed, the base class needs to be already constructed. (Incidentally, this also explains why the virtual function dispatching doesn't fully work from within constructors: When a sub-object is constructed, only the sub-objects of base classes are already constructed; the derived classes' sub-objects are not yet constructed. Therefore a call to a virtual function must not be dispatched to a derived class. As always, destructors are the same, just backwards.) </li>\n<li>With multiple base classes being equal siblings, some order had to be picked arbitrarily. Ultimately, the order of declaration is the most simple one to use. Data members, which also are equal siblings, follow the same (more or less arbitrary) in-order-of-declaration rule.</li>\n<li>Virtual base classes are strange beasts. Because there will always only be one sub-object of a virtual base class, there's that special rule which says it always needs to be constructed first, right from the most derived class' constructor. (Which is why virtual base classes work best as abstract base classes with no data and only default constructors.)  </li>\n</ul>\n", "OwnerUserId": "140719", "LastEditorUserId": "140719", "LastEditDate": "2011-12-29T11:12:58.333", "Id": "3507226", "Score": "10", "CreationDate": "2010-08-17T21:43:56.240", "LastActivityDate": "2011-12-29T11:12:58.333"}, "3507100": {"CommentCount": "0", "AcceptedAnswerId": "3507226", "PostTypeId": "1", "LastEditorUserId": "711006", "CreationDate": "2010-08-17T21:29:17.867", "LastActivityDate": "2017-09-11T08:27:31.240", "LastEditDate": "2017-09-11T08:21:03.317", "ViewCount": "4592", "FavoriteCount": "4", "Title": "order of destruction using virtual", "Id": "3507100", "Score": "8", "Body": "<p>Can some one please help what the order of destruction is when I am using virtual functions. Does it start with the base class and then derived class?</p>\n", "Tags": "<c++><destructor><virtual-destructor>", "OwnerUserId": "384252", "AnswerCount": "8"}, "3507137": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Order of destructions if from the bottom up. (from derived to base)</p>\n<blockquote>\n<p id=\"so_3507100_3507137_0\">Short answer: the exact opposite of\n  the constructor order.</p>\n<p id=\"so_3507100_3507137_1\">Long answer: suppose the \"most\n  derived\" class is D, meaning the\n  actual object that was originally\n  created was of class D, and that D\n  inherits multiply (and non-virtually)\n  from B1 and B2. The sub-object\n  corresponding to most-derived class D\n  runs first, followed by the dtors for\n  its non-virtual base classes in\n  reverse declaration-order. Thus the\n  destructor order will be D, B2, B1.\n  This rule is applied recursively; for\n  example, if B1 inherits from B1a and\n  B1b, and B2 inherits from B2a and B2b,\n  the final order is D, B2, B2b, B2a,\n  B1, B1b, B1a.</p>\n</blockquote>\n<p>See the <a href=\"http://www.parashift.com/c++-faq-lite/multiple-inheritance.html#faq-25.15\" rel=\"nofollow noreferrer\">c++ faq section 25</a></p>\n", "OwnerUserId": "63309", "LastEditorUserId": "63309", "LastEditDate": "2010-08-17T21:37:19.047", "Id": "3507137", "Score": "0", "CreationDate": "2010-08-17T21:32:00.033", "LastActivityDate": "2010-08-17T21:37:19.047"}, "3507127": {"ParentId": "3507100", "CommentCount": "0", "Body": "<p>It is the opposite way as the constructors.  So derived first.</p>\n", "OwnerUserId": "108238", "PostTypeId": "2", "Id": "3507127", "Score": "0", "CreationDate": "2010-08-17T21:31:21.680", "LastActivityDate": "2010-08-17T21:31:21.680"}, "3510583": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Section 12.6.2/5:</p>\n<blockquote>\n<p id=\"so_3507100_3510583_0\">Initialization shall proceed in the following order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class as\n  described below, virtual base classes shall be initialized in the\n  order they appear on a depth-first left-to-right traversal of the\n  directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the\n  order of appearance of the base class names in the derived class\n  base-specifier-list.</li>\n<li>Then, direct base classes shall be initialized\n  in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).</li>\n<li>Then, nonstatic\n  data members shall be initialized in the order they were declared in\n  the class definition (again regardless of the order of the\n  mem-initializers). \u2014 Finally, the body of the constructor is executed.</li>\n</ul>\n<p id=\"so_3507100_3510583_1\">[Note: the declaration order is mandated to ensure that base and\n  member subobjects are destroyed in the reverse order of\n  initialization. ]</p>\n</blockquote>\n", "OwnerUserId": "418110", "LastEditorUserId": "711006", "LastEditDate": "2017-09-11T08:27:31.240", "Id": "3510583", "Score": "1", "CreationDate": "2010-08-18T09:19:56.703", "LastActivityDate": "2017-09-11T08:27:31.240"}, "3507142": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The destruction order is the construction order backwards. I've recently made a small tool to display the construction order for any hierarchy. Look here:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/3414639/where-is-the-virtual-keyword-necessary-in-a-complex-multiple-inheritance-hierar/3414910#3414910\">Where is the \"virtual\" keyword necessary in a complex multiple inheritance hierarchy?</a></li>\n</ul>\n<p>In the diagrams, the nodes with the smaller numbers are constructed <strong>first</strong> and destructed <strong>last</strong>.</p>\n", "OwnerUserId": "385433", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:21.663", "Id": "3507142", "Score": "1", "CreationDate": "2010-08-17T21:32:19.377", "LastActivityDate": "2010-08-17T21:41:47.093"}, "3507126": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Virtual functions make no difference to the order of destruction, virtual base classes, on the other hand, do.</p>\n<p>Without virtual base classes, derived classes are always destroyed before their base classes; this is the reverse order in which they are constructed.</p>\n<p>For the most derived class, virtual base classes are constructed first, before other base classes and before the most derived class itself. Destruction happens in the reverse order. This means that a virtual base <em>may</em> be destroyed after a class that derives virtually from it, if that class is not the most derived class being destroyed. This can never happen for direct base classes.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2010-08-17T21:39:22.243", "Id": "3507126", "Score": "0", "CreationDate": "2010-08-17T21:31:14.450", "LastActivityDate": "2010-08-17T21:39:22.243"}, "bq_ids": {"n4140": {"so_3507100_3510583_1": {"section_id": 438, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_3507100_3510583_1": {"section_id": 429, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_3507100_3510583_1": {"section_id": 458, "quality": 0.9166666666666666, "length": 11}}}, "3507135": {"ParentId": "3507100", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Assuming you have correctly declared your destructor as virtual.</p>\n<p>Then destruction is done in the exact opposite order of construction.  </p>\n<h3>In General this will be:</h3>\n<p>A) Start in the most derived class.<br>\nB) Repeat the following recursively.  </br></p>\n<p>1) Execute the destructor code.<br>\n2) Execute the destructor of each member (in reverse order of creation)<br>\n3) Execute the destructor of the parent class.  (if more than one in reverse order of creation)</br></br></p>\n<p>If you use virtual inheritance though then things are slightly different as the order of base class construction is not the same as normal. <b>BUT</b> The order of destruction is <b>ALWAYS</b> the reverse of the order of construction.</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2010-08-17T21:39:28.047", "Id": "3507135", "Score": "4", "CreationDate": "2010-08-17T21:31:53.420", "LastActivityDate": "2010-08-17T21:39:28.047"}});