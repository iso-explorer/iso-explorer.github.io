post_cb({"16101672": {"Id": "16101672", "PostTypeId": "2", "Body": "<p>You have a serious logic problem here:</p>\n<pre><code>cout &lt;&lt; \"The beginnings of the vectors are different: \"\n &lt;&lt; (fooOne.getMyIntVec().begin() == fooTwo.getMyIntVec().begin()) &lt;&lt; endl;\n</code></pre>\n<p>If they are equal, it will output 1 instead of 0 which you normally expect.</p>\n", "LastActivityDate": "2013-04-19T09:39:48.080", "CommentCount": "0", "CreationDate": "2013-04-19T09:39:48.080", "ParentId": "16100865", "Score": "0", "OwnerUserId": "2183287"}, "16101066": {"Id": "16101066", "PostTypeId": "2", "Body": "<p>The reason for this is that it is undefined behaviour to compare two iterators which refer to elements in different containers. So, there is no guarantee what you will get. This comes from the fact that <code>getMyIntVec</code> returns a copy of <code>_MyIntVec</code> and you assign these copies to new instances of <code>vector&lt;int&gt;</code>, so these are indeed iterators of two different copies of the <code>_MyIntVec</code> member.</p>\n<p>According to the standard: </p>\n<p>\u00a7 24.2.1</p>\n<blockquote>\n<p id=\"so_16100865_16101066_0\">An iterator j is called reachable from an iterator i if and only if there is a finite sequence of applications of\n  the expression ++i that makes i == j. If j is reachable from i, they refer to elements of the same sequence.</p>\n</blockquote>\n<p>and a bit later in the standard:</p>\n<p>\u00a7 24.2.5</p>\n<blockquote>\n<p id=\"so_16100865_16101066_1\">The domain of == for forward iterators is that of iterators over the same underlying sequence.</p>\n</blockquote>\n<p>This has already been answered in <a href=\"https://stackoverflow.com/questions/4657513/comparing-iterators-from-different-containers\" title=\"Comparing Iterators from different containersquot;\">this question</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-19T09:07:59.420", "Score": "0", "CreationDate": "2013-04-19T09:07:59.420", "ParentId": "16100865", "CommentCount": "0", "OwnerUserId": "980195", "LastEditDate": "2017-05-23T11:50:16.053"}, "16101053": {"Id": "16101053", "PostTypeId": "2", "Body": "<p>The problem is that your accessor in Foo:</p>\n<pre><code>std::vector&lt;int&gt; getMyIntVec() const {\nreturn _myIntVec;\n}\n</code></pre>\n<p>I doesn't return _myIntVec, it returns a <strong>copy</strong> of myIntVec.\nInstead it should look like:</p>\n<pre><code>const std::vector&lt;int&gt;&amp; getMyIntVec() const {\nreturn _myIntVec;\n}\n</code></pre>\n<p>Otherwise when you create iterators they are created from copies that are directly thrown away so your C++ compiler reuses the address. That is why you get \"equal\" iterators, at least I think so.</p>\n", "LastActivityDate": "2013-04-19T09:07:05.143", "CommentCount": "1", "CreationDate": "2013-04-19T09:07:05.143", "ParentId": "16100865", "Score": "2", "OwnerUserId": "1599976"}, "16100865": {"ViewCount": "254", "Body": "<p>I want to construct nested loops over arrays of objects, having a rather complex data structure. Because I use arrays, I want to make use of their iterators. After I got unexpected results I boiled down the problem to the following code snippet, that shows my iterators to be equal when I expect them to be different:</p>\n<pre><code>vector&lt;int&gt; intVecA;\nvector&lt;int&gt; intVecB;\n\nintVecA.push_back(1);\nintVecA.push_back(2);\n\nintVecB.push_back(5);\nintVecB.push_back(4);\n\nFoo fooOne(intVecA);\nFoo fooTwo(intVecB);\n\nvector&lt;int&gt;::const_iterator itA = fooOne.getMyIntVec().begin();\nvector&lt;int&gt;::const_iterator itB = fooTwo.getMyIntVec().begin();\ncout &lt;&lt; \"The beginnings of the vectors are different: \"\n     &lt;&lt; (fooOne.getMyIntVec().begin() == fooTwo.getMyIntVec().begin()) &lt;&lt; endl;\ncout &lt;&lt; (*(fooOne.getMyIntVec().begin()) == *(fooTwo.getMyIntVec().begin())) &lt;&lt; endl;\ncout &lt;&lt; (&amp;(*(fooOne.getMyIntVec().begin())) == &amp;(*(fooTwo.getMyIntVec().begin()))) &lt;&lt; endl;\ncout &lt;&lt; \"But the iterators are equal: \"\n     &lt;&lt; (itA==itB) &lt;&lt; endl;\n</code></pre>\n<p>This produces:</p>\n<pre><code>The beginnings of the vectors are different: 0\n0\n0\nBut the iterators are equal: 1\n</code></pre>\n<p>This behaviour does not make sense to me and I'd be happy about hearing an explanation.</p>\n<p>Foo is a simple object containing a vector and getter function for it:</p>\n<pre><code>class Foo {\n    public:\n    Foo(std::vector&lt;int&gt; myIntVec);\n\n    std::vector&lt;int&gt; getMyIntVec() const {\n    return _myIntVec;\n    }\n\n    private:\n    std::vector&lt;int&gt; _myIntVec;\n};\n\nFoo::Foo(std::vector&lt;int&gt; myIntVec) {\n    _myIntVec = myIntVec;\n}\n</code></pre>\n<p>When first copying the vectors the problem vanishes. Why?</p>\n<pre><code>vector&lt;int&gt; intVecReceiveA = fooOne.getMyIntVec();\nvector&lt;int&gt; intVecReceiveB = fooTwo.getMyIntVec();\n\nvector&lt;int&gt;::const_iterator newItA = intVecReceiveA.begin();\nvector&lt;int&gt;::const_iterator newItB = intVecReceiveB.begin();\n\ncout &lt;&lt; \"The beginnings of the vectors are different: \"\n     &lt;&lt; (intVecReceiveA.begin() == intVecReceiveB.begin()) &lt;&lt; endl;\ncout &lt;&lt; \"And now also the iterators are different: \"\n     &lt;&lt; (newItA==newItB) &lt;&lt; endl;\n</code></pre>\n<p>produces:</p>\n<pre><code>The beginnings of the vectors are different: 0\nAnd now also the iterators are different: 0\n</code></pre>\n<p>Further notes:\nI need these nested loops in functions which need to be extremely efficient regarding computation time, thus I would not want to do unnecessary operations. Since I'm new to c++ I do not know whether copying the vectors would actually take additional time or whether they would be copied internally anyway. I'm also thankful for any other advice.</p>\n", "AcceptedAnswerId": "16101053", "Title": "nested iterator loop, why are iterators equal? - c++", "CreationDate": "2013-04-19T08:56:18.110", "Id": "16100865", "CommentCount": "1", "LastEditDate": "2013-04-19T08:59:00.643", "PostTypeId": "1", "LastEditorUserId": "1033896", "LastActivityDate": "2013-04-19T09:39:48.080", "Score": "1", "OwnerUserId": "2296653", "Tags": "<c++><arrays><iterator><nested-loops>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_16100865_16101066_0": {"length": 16, "quality": 1.0, "section_id": 5560}, "so_16100865_16101066_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5574}}, "n3337": {"so_16100865_16101066_0": {"length": 16, "quality": 1.0, "section_id": 5342}, "so_16100865_16101066_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5356}}, "n4659": {"so_16100865_16101066_0": {"length": 16, "quality": 1.0, "section_id": 7007}, "so_16100865_16101066_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7021}}}, "16100946": {"Id": "16100946", "PostTypeId": "2", "Body": "<p>You realize that you compare things the wrong way round? If you compare <code>a == b</code>, even if you write </p>\n<pre><code>cout &lt;&lt; \"a is different from b: \" &lt;&lt; (a==b) &lt;&lt; endl;\n</code></pre>\n<p>The output will tell if the two elements are the same not different. To check if two things are different use <code>!=</code> instead of <code>==</code>.</p>\n", "LastActivityDate": "2013-04-19T09:01:00.457", "CommentCount": "1", "CreationDate": "2013-04-19T09:01:00.457", "ParentId": "16100865", "Score": "0", "OwnerUserId": "812912"}});