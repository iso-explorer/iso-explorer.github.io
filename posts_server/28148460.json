post_cb({"28148460": {"ViewCount": "81", "Body": "<p>I wonder if this code is fine or not:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;future&gt;\nstruct Foo\n{\n    Foo()\n        :m_a(0)\n    {\n    }\n\n    int m_a;\n};\n\nint main()\n{\n    Foo f;\n    auto handle =\n        std::async( std::launch::async, \n                [](Foo* f) { std::cout &lt;&lt; f-&gt;m_a &lt;&lt; '\\n'; } ,\n                &amp;f\n              );\n\n    handle.get();\n}\n</code></pre>\n<p>I believe <code>m_a</code> should be protected by a synchronization mechanism but my colleague says it is not necessary.</p>\n<p><strong>EDIT</strong>: To clarify my question: I am worried that the STORE operation from the constructor of <code>Foo()</code> happens after the LOAD operation from the other thread. I can't see what mechanism prevents the compiler from executing those instruction in this order.</p>\n<p><strong>EDIT</strong>: I believe an enthusiastic compiler could decide to inline the constructor, and delay the STORE operation for after the CALL operation to <code>std::async</code>. In which case the second thread could access <code>m_a</code> before it has been committed to memory.</p>\n", "AcceptedAnswerId": "28148540", "Title": "Is this code correctly synchronized?", "CreationDate": "2015-01-26T10:33:40.837", "Id": "28148460", "CommentCount": "4", "LastEditDate": "2015-01-26T10:59:43.847", "PostTypeId": "1", "LastEditorUserId": "748175", "LastActivityDate": "2015-01-26T10:59:43.847", "Score": "1", "OwnerUserId": "748175", "Tags": "<c++><synchronization><stdasync>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28148460_28148540_0": {"length": 4, "quality": 1.0, "section_id": 3163}, "so_28148460_28148540_1": {"length": 8, "quality": 1.0, "section_id": 3163}}, "n3337": {"so_28148460_28148540_0": {"length": 4, "quality": 1.0, "section_id": 3036}, "so_28148460_28148540_1": {"length": 8, "quality": 1.0, "section_id": 3036}}, "n4659": {"so_28148460_28148540_0": {"length": 4, "quality": 1.0, "section_id": 3925}, "so_28148460_28148540_1": {"length": 8, "quality": 1.0, "section_id": 3925}}}, "28148540": {"Id": "28148540", "PostTypeId": "2", "Body": "<p>Yes, this is correctly synchronised. </p>\n<p>From the specification for <code>async</code>, C++11 30.6.8/5:</p>\n<blockquote>\n<p id=\"so_28148460_28148540_0\">the invocation of <code>async</code> synchronizes with the invocation of <code>f</code>.</p>\n</blockquote>\n<p>where <code>f</code> is the function argument to <code>async</code> (the lambda in your example).</p>\n<p>Initialisation of <code>f.m_a</code> is sequenced before the call to <code>async</code>, and therefore before any access by the asynchronous function.</p>\n<p>Furthermore,</p>\n<blockquote>\n<p id=\"so_28148460_28148540_1\">the completion of the function f is sequenced before the shared state is made ready.</p>\n</blockquote>\n<p>so the access must happen before the call to <code>get()</code> returns, and therefore before the object is destroyed.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2015-01-26T10:51:57.230", "Score": "1", "CreationDate": "2015-01-26T10:38:59.717", "ParentId": "28148460", "CommentCount": "4", "OwnerUserId": "204847", "LastEditDate": "2015-01-26T10:51:57.230"}});