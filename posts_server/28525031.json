post_cb({"28525031": {"CommentCount": "4", "ViewCount": "61", "PostTypeId": "1", "ClosedDate": "2015-02-15T11:40:15.287", "LastEditorUserId": "3953764", "CreationDate": "2015-02-15T10:12:55.870", "LastActivityDate": "2015-02-15T11:43:45.117", "LastEditDate": "2015-02-15T11:07:07.837", "OwnerDisplayName": "user2953119", "Title": "A variable template at class scope", "Id": "28525031", "Score": "5", "Body": "<p>I have a question specifically about clang's behavior when we declare a variable template within a class scope. What the Standard stated about this is (<code>N4296::14/1 [temp]</code>):</p>\n<blockquote>\n<p id=\"so_28525031_28525031_0\">A variable template at class scope is a static data member template.</p>\n</blockquote>\n<p>I thought that any variable template (static and non-static) is going to be declared as just static data member template. But actually, <code>clang</code> prevent declaring non-static data member template ever. </p>\n<pre><code>template &lt;class U&gt;\nstruct A\n{\n    template &lt;class T, const T&amp; t&gt;\n    int a; //non-static data member template\n};\n\nint main(){}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/2bff5f2a37dc97e4\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>My question is how the rule actually should be treated. Does it mean a compiler should declare any data member template as a static data template member implicitly?</p>\n", "Tags": "<c++><templates><language-lawyer><specifications><c++14>", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_28525031_28525031_0": {"section_id": 48, "quality": 0.875, "length": 7}}, "n3337": {"so_28525031_28525031_0": {"section_id": 221, "quality": 0.75, "length": 6}}, "n4659": {"so_28525031_28525031_0": {"section_id": 49, "quality": 0.875, "length": 7}}}});