post_cb({"34929388": {"CommentCount": "1", "ViewCount": "43", "CreationDate": "2016-01-21T16:41:12.813", "LastActivityDate": "2016-01-21T20:18:11.693", "Title": "cpp. Template class inheritance does not work", "PostTypeId": "1", "Id": "34929388", "Score": "0", "Body": "<p>I have the following code:</p>\n<pre><code>template &lt;class T&gt;\nclass Planet{\n    protected:\n        std::map&lt;ID, std::shared_ptr&lt;T&gt;&gt; population;\n        ID freeId;\n    public:\n    //@todo dorobi\u0107 name\n        Planet();\n        T&amp; registerCitizen(std::string);\n        T&amp; findCitizen(ID);\n        T&amp; findCitizen(std::string);\n};\n\ntemplate &lt;class T&gt;\nclass PairPlanet: public Planet&lt;T&gt;{\n    public:\n        T&amp; registerCitizen(T&amp;, T&amp;);\n};\n</code></pre>\n<p>The problem here is that PairPlanet seems not to inherit from planet:\nFor example if I try to define:\ntemplate</p>\n<pre><code>T&amp; PairPlanet&lt;T&gt;::registerCitizen(T&amp; per1, T&amp; per2){\n    T* new_person = new T(per1.citizenName+\"&amp;\"+per2.citizenName,freeId);\n    population.insert(std::pair&lt;ID, T&gt;(freeId, *new_person)).first;\n    freeId++;\n    return *new_person; \n};\n</code></pre>\n<p>I receive an information that both population and freeId are undefined. May I ask for some hints?</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "5821464", "AnswerCount": "1"}, "34929686": {"ParentId": "34929388", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-01-21T16:55:09.550", "Score": "0", "LastEditorUserId": "1566221", "LastEditDate": "2016-01-21T20:18:11.693", "Id": "34929686", "OwnerUserId": "1566221", "Body": "<p>Short answer: You need to use an explicit <code>this-&gt;</code> to refer to <code>freeId</code> and <code>population</code>:</p>\n<pre><code>template &lt;class T&gt;\nT&amp; PairPlanet&lt;T&gt;::registerCitizen(T&amp; per1, T&amp; per2){\n    T* new_person = new T(per1.citizenName+\"&amp;\"+per2.citizenName,\n                          this-&gt;freeId);\n    // The original had a pointless `.first` at the end,\n    // but I removed it because it was pointless.\n    this-&gt;population.insert(std::make_pair(this-&gt;freeId, *new_person));\n    ++this-&gt;freeId;\n    return *new_person; \n};\n</code></pre>\n<p>The reason is \"non-dependent name lookup\" (\u00a714.6.3 [temp.nondep] of the current C++14 draft):</p>\n<blockquote>\n<p id=\"so_34929388_34929686_0\">Non-dependent names used in a template definition are found using the usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>A non-dependent name is a name which doesn't visibly depend on a template parameter. The unqualified use of <code>freeId</code> and <code>population</code> is not visibly dependent on anything, so they are looked up \"using the usual name lookup ... at the point they are used\". In other words, the compiler resolves them at the point where they appear in the program text, during the definition of the <code>PairPlanet</code> template. They're not in the class itself nor in global scope, so it doesn't find them and complains.</p>\n<p>Your intention was that <code>freeId</code> and <code>population</code> come from the base class, which is dependent on the template parameter. So you need to explicitly state that those identifiers are dependent, by showing that they are members of the object pointed to by <code>this</code>. For dependent names, the compiler uses the name lookup strategy from the next section of the standard, which defers name lookup until the point of instantiation when the template parameter is known. At that point, the compiler has worked out the definition of the base class, and the names defined in it are available for the lookup.</p>\n", "LastActivityDate": "2016-01-21T20:18:11.693"}, "bq_ids": {"n4140": {"so_34929388_34929686_0": {"section_id": 214, "quality": 1.0, "length": 12}}, "n3337": {"so_34929388_34929686_0": {"section_id": 208, "quality": 1.0, "length": 12}}, "n4659": {"so_34929388_34929686_0": {"section_id": 222, "quality": 1.0, "length": 12}}}});