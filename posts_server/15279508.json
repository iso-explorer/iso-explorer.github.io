post_cb({"15279587": {"Id": "15279587", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15279508_15279587_0\">what will work??</p>\n</blockquote>\n<p>Nothing will work.</p>\n<p>The object running its constructor is <strong>never <code>const</code></strong>.  It may only be assigned to a <code>const</code> variable <em>after</em> the constructor has run its course.</p>\n<p>It also can't be determined for member functions (non-const member functions included, since <code>const_cast</code> may have been used)</p>\n<p>Const-ness is a property that exists at <strong>each call site</strong>, not as a property of the function body itself.</p>\n<blockquote>\n<p id=\"so_15279508_15279587_1\">MOTIVATION: I want to be able to detect whether a const member function is invoked on a const object </p>\n</blockquote>\n<p>You can't do that, but you can come close...</p>\n<pre><code>class C\n{\npublic:\n    void func() const\n    {\n        std::cout &lt;&lt; \"const!\";\n        func_impl();\n    }\n    void func()\n    {\n        std::cout &lt;&lt; \"non-const!\";\n        func_impl();\n    }\nprivate:\n    void func_impl() const;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_15279508_15279587_2\">The object could e.g. represent a cache and the member a view. If the cache was const, one could presumably use an optimized draw routine, whereas if the underlying data was non-const, the draw routine would need to do periodically check if the data was refreshed.</p>\n</blockquote>\n<p>That would be an unreliable usage of <code>const</code> because <code>const</code> is not a property of the object itself.  It's a property of the current context that the object's being used.</p>\n<p>Detecting that it's <code>const</code> in the current context doesn't tell you that the object has always been treated in a <code>const</code> context.</p>\n", "LastEditorUserId": "16287", "LastActivityDate": "2013-03-07T19:28:16.603", "Score": "3", "CreationDate": "2013-03-07T19:03:33.717", "ParentId": "15279508", "CommentCount": "4", "OwnerUserId": "16287", "LastEditDate": "2013-03-07T19:28:16.603"}, "15280192": {"Id": "15280192", "PostTypeId": "2", "Body": "<p>Detecting constness within an object isn't possible, but you state that your motivation is\u2026</p>\n<blockquote>\n<p id=\"so_15279508_15280192_0\">\u201c I want to be able to detect whether a const member function is invoked on a const object or is coming from a non-const object.\u201d</p>\n</blockquote>\n<p>Well that\u2019s easy, just provide a non-<code>const</code> overload.</p>\n<p>The overloads can defer to a common implementation, e.g. as follows:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Test\n{\nprivate:\n    template&lt; class CvTest &gt;\n    static void print( CvTest&amp; o )\n    {\n        cout &lt;&lt; boolalpha;\n        cout &lt;&lt; \"&gt; object says: Hey, const = \" &lt;&lt; std::is_const&lt;CvTest&gt;::value &lt;&lt; \"!\" &lt;&lt; endl;\n    }\n\npublic:\n    bool print()        { return (print( *this ), false); }\n    bool print() const  { return (print( *this ), true); }\n};\n\nint main()\n{\n    Test t;\n    const Test s;\n\n    cout &lt;&lt; \"External constness test:\" &lt;&lt; endl;\n    cout &lt;&lt; boolalpha &lt;&lt; is_const&lt;decltype(t)&gt;::value &lt;&lt; \"\\n\";\n    cout &lt;&lt; boolalpha &lt;&lt; is_const&lt;decltype(s)&gt;::value &lt;&lt; \"\\n\";\n\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; \"Internal constness test:\" &lt;&lt; endl;\n    cout &lt;&lt; boolalpha &lt;&lt; t.print() &lt;&lt; \"\\n\";\n    cout &lt;&lt; boolalpha &lt;&lt; s.print() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Results:</p>\n<pre>\nExternal constness test:\nfalse\ntrue\n\nInternal constness test:\n&gt; object says: Hey, const = false!\nfalse\n&gt; object says: Hey, const = true!\ntrue\n</pre>\n", "LastActivityDate": "2013-03-07T19:38:21.770", "CommentCount": "1", "CreationDate": "2013-03-07T19:38:21.770", "ParentId": "15279508", "Score": "2", "OwnerUserId": "464581"}, "15279652": {"Id": "15279652", "PostTypeId": "2", "Body": "<p>It's not possible for constructors (the original question) because of</p>\n<blockquote>\n<h3>12.1 Constructors [class.ctor]</h3>\n<p id=\"so_15279508_15279652_0\"><sup>4</sup> A constructor shall not be <code>virtual</code> (10.3) or <code>static</code> (9.4). A constructor can be invoked for a <code>const</code>, <code>volatile</code> or <code>const volatile</code> object. A constructor shall not be declared <code>const</code>, <code>volatile</code>, or <code>const volatile</code> (9.3.2). <code>const</code> and <code>volatile</code> semantics (7.1.6.1) are not applied on an object under construction. They come into effect when the constructor for the most derived object (1.8) ends. A constructor shall not be declared with a ref-qualifier.</p>\n</blockquote>\n<p>For member functions (the current question), you could simply provide both a <code>const</code> and a non-<code>const</code> overload, forward both to a (private) method that takes the constness as a boolean template parameter.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-03-07T19:22:06.227", "Score": "6", "CreationDate": "2013-03-07T19:07:09.327", "ParentId": "15279508", "CommentCount": "7", "OwnerUserId": "2073257", "LastEditDate": "2013-03-07T19:22:06.227"}, "15280431": {"Id": "15280431", "PostTypeId": "2", "Body": "<p>As others have stated, you cannot tell if an object was declared as <code>const</code> from within a member function. You can only tell if it's being called in a <code>const</code> context, which is not the same.</p>\n<blockquote>\n<p id=\"so_15279508_15280431_0\"><strong>MOTIVATION:</strong> I want to be able to detect whether a const member function is invoked on a const object or is coming from a non-const object. The object could e.g. represent a cache and the member a view. If the cache was const, one could presumably use an optimized draw routine, whereas if the underlying data was non-const, the draw routine would need to do periodically check if the data was refreshed.</p>\n</blockquote>\n<p>You can't tell that reliably.</p>\n<pre><code>struct A\n{\n  void draw() { fut = std::async(&amp;A::do_draw, this, false); }\n  void draw() const { fut = std::async(&amp;A::do_draw, this, true); }\n  void update(Data&amp;);\nprivate:\n  void do_draw(bool this_is_const) const;\n  mutable std::future&lt;void&gt; fut;\n};\n\nA a;\nconst A&amp; ca = a;\nca.draw();           // object will think it's const, but isn't\nData new_data = ...;\na.update(new_data);  // do_draw() should recheck data, but won't\n</code></pre>\n<p>You can model it in the type system, by defining separate mutable and immutable types.</p>\n<pre><code>struct Base\n{\n  virtual ~Base();\n  virtual void draw() const = 0;\nprotected:\n  void do_draw(bool) const;\n};\n\nstruct MutableCache : Base\n{\n  virtual void draw() const { fut = std::async(&amp;Base::do_draw, this, false); }\n  void update();\n};\n\nstruct ImmutableCache : Base\n{\n  virtual void draw() const { fut = std::async(&amp;Base::do_draw, this, true); }\n  // no update function defined, data cannot change!\n};\n</code></pre>\n<p>Now if a cache is create as an <code>ImmutableCache</code> you know it <em>can't</em> change, so that replaces your previous idea of a \"const\" object.  A <code>MutableCache</code> can change, so needs to check for refreshed data.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-03-07T20:06:59.390", "Score": "5", "CreationDate": "2013-03-07T19:50:23.193", "ParentId": "15279508", "CommentCount": "5", "OwnerUserId": "981959", "LastEditDate": "2013-03-07T20:06:59.390"}, "15280016": {"Id": "15280016", "PostTypeId": "2", "Body": "<p>The type of <code>this</code> (and consequently of <code>*this</code>) is purely determined by the cv-qualifier of the function and does not change depending on whether the actual object is cv-qualified or not.</p>\n<p><code>\u00a79.3.2 [class.this] p1</code></p>\n<blockquote>\n<p id=\"so_15279508_15280016_0\">In the body of a non-static (9.3) member function, the keyword <code>this</code> is a prvalue expression whose value is the address of the object for which the function is called. The type of <code>this</code> in a member function of a class <code>X</code> is <code>X*</code>. <strong>If the member function is declared <code>const</code>, the type of <code>this</code> is <code>const X*</code></strong>, if the member function is declared <code>volatile</code>, the type of <code>this</code> is <code>volatile X*</code>, and if the member function is declared <code>const volatile</code>, the type of <code>this</code> is <code>const volatile X*</code>.</p>\n</blockquote>\n<p>So, you can't see <em>inside</em> of a member function whether the object it's invoked on is <code>const</code>, but you can make the compiler call different functions depending on <code>const</code>ness:</p>\n<pre><code>struct X{\n  void f(){ /* non-const object */ }\n  void f() const{ /* const object */ }\n};\n\nint main(){\n  X x1;\n  X const x2;\n  x1.f(); // calls non-const 'f'\n  x2.f(); // calls const 'f'\n\n  // but beware:\n  X const&amp; rx = x1;\n  rx.f(); // calls const 'f', because the \"object\" it's invoked on is const\n}\n</code></pre>\n<p>Beware of the limitation laid out in the snippet, though.</p>\n", "LastActivityDate": "2013-03-07T19:28:04.170", "CommentCount": "1", "CreationDate": "2013-03-07T19:28:04.170", "ParentId": "15279508", "Score": "3", "OwnerUserId": "500104"}, "bq_ids": {"n4140": {"so_15279508_15279652_0": {"length": 25, "quality": 0.625, "section_id": 368}, "so_15279508_15280016_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5895}}, "n3337": {"so_15279508_15280016_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5666}, "so_15279508_15279652_0": {"length": 37, "quality": 0.925, "section_id": 358}}, "n4659": {"so_15279508_15280016_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 7378}, "so_15279508_15279652_0": {"length": 25, "quality": 0.625, "section_id": 380}}}, "15279508": {"ViewCount": "615", "Body": "<p>With <code>decltype</code> and <code>std::is_const</code> the constness of a variable can be externally detected. <strong>But is it also possible for an object to know its own constness?</strong> Usage should be like:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;ios&gt;\n\nstruct Test\n{\n    Test() {}\n\n    bool print() const\n    {\n       // does not work as is explained in https://stackoverflow.com/q/9890218/819272\n       return std::is_const&lt;decltype(*this)&gt;::value; // &lt;--- what will work??\n    }\n};\n\nint main()\n{\n    Test t;\n    const Test s;\n\n    // external constness test\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_const&lt;decltype(t)&gt;::value &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_const&lt;decltype(s)&gt;::value &lt;&lt; \"\\n\";\n\n    // internal constness test\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; t.print() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; s.print() &lt;&lt; \"\\n\"; // &lt;--- false??\n}\n</code></pre>\n<p>Output on <a href=\"http://liveworkspace.org/code/2HfkHT$35\" rel=\"nofollow noreferrer\">LiveWorkSpace</a> Is this somehow possible?</p>\n<p><strong>MOTIVATION</strong>: I want to be able to detect whether a const member function is invoked on a const object or is coming from a non-const object. The object could e.g. represent a cache and the member a view. If the cache was const, one could presumably use an optimized draw routine, whereas if the underlying data was non-const, the draw routine would need to do periodically check if the data was refreshed.</p>\n<p><strong>NOTE</strong>: the related <a href=\"https://stackoverflow.com/q/9890218/819272\">question</a> asks how to break the build for const objects, but I don't quite understand if the answer to that implies a definite NO for my question. If not, I want to capture the constness in a boolean for further usage. </p>\n<p><strong>EDIT</strong>: as was pointed out @DanielFrey, the constructor is not a good place to test for constness. What about a const member function?</p>\n<hr>\n<p><strong>UPDATE</strong>: Thanks everyone for correcting my initially ill-posed question and providing the various parts of the answer (constructors' ill-defined constness, rvaluedness of <code>this</code>, the contextual meaning of <code>const</code>, the -with hindsight- obvious overload trick that I had overlooked, and the const reference aliasing loophole lurking in the shadows). For me this question was Stackoverflow at its best. I decided to select @JonathanWakely's answer because it showed how to define <code>Mutable</code> and <code>Immutable</code> classes that strengthen the constness concept to achieve what I want in a foolproof way.</p>\n</hr>", "AcceptedAnswerId": "15280431", "Title": "Can an object know its own constness?", "CreationDate": "2013-03-07T19:00:03.833", "Id": "15279508", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:49:19.713", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-08T02:37:52.910", "Score": "10", "OwnerUserId": "819272", "Tags": "<c++><reflection><c++11><typetraits><const-correctness>", "AnswerCount": "7"}, "15279775": {"Id": "15279775", "PostTypeId": "2", "Body": "<p>I don't know if it's possible <em>in that way</em>, by means of a member value that's set in the constructor, but the object can report its const-ness with member functions:</p>\n<pre><code>struct Test\n{\n  bool is_const() const\n  {\n    return(true);\n  }\n\n  bool is_const()\n  {\n    return(false);\n  }\n};\n</code></pre>\n", "LastEditorUserId": "128940", "LastActivityDate": "2013-03-08T02:37:52.910", "Score": "3", "CreationDate": "2013-03-07T19:14:40.440", "ParentId": "15279508", "CommentCount": "5", "OwnerUserId": "128940", "LastEditDate": "2013-03-08T02:37:52.910"}, "15279579": {"Id": "15279579", "PostTypeId": "2", "Body": "<p>This isn't possible because it's possible for a particular value to be simultaneously viewed as <code>const</code> and not <code>const</code>.  Consider</p>\n<pre><code>MyType t = ...;\nMyType&amp; nonConstRef = t;\nconst MyType&amp; constRef = t;\n</code></pre>\n<p>At this point <code>t</code> has both a <code>const</code> and a non-const reference.  </p>\n", "LastActivityDate": "2013-03-07T19:03:17.033", "CommentCount": "0", "CreationDate": "2013-03-07T19:03:17.033", "ParentId": "15279508", "Score": "2", "OwnerUserId": "23283"}});