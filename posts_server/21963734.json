post_cb({"21963998": {"Id": "21963998", "PostTypeId": "2", "Body": "<p>MSVC is right; <code>void*</code> is not covariant with <code>T*</code>. Quoting from the standard (10.3 [class.virtual], section 7):</p>\n<blockquote>\n<p id=\"so_21963734_21963998_0\">The return type of an overriding function shall be either identical to the return type of the overridden\n  function or covariant with the classes of the functions. If a function <code>D::f</code> overrides a function <code>B::f</code>, the\n  return types of the functions are covariant if they satisfy the following criteria:</p>\n<p id=\"so_21963734_21963998_1\">\u2014 both are pointers to classes, both are lvalue references to classes, or both are rvalue references to\n  classes</p>\n<p id=\"so_21963734_21963998_2\">\u2014 the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code>, or is an\n  unambiguous and accessible direct or indirect base class of the class in the return type of <code>D::f</code></p>\n<p id=\"so_21963734_21963998_3\">\u2014 both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code>\n  has the same cv-qualification as or less cv-qualification than the class type in the return type of <code>B::f</code>.</p>\n</blockquote>\n<p><code>void</code> is not a base class of <code>T</code> (= <code>data</code>), so the return types are <strong>not</strong> covariant.</p>\n<hr>\n<p>So why this rule? Well, the idea is that if you have</p>\n<pre><code>struct B {\n    virtual U* f();\n};\n\nstruct D : B {\n    virtual V* f();\n};\n\nB* b1 = new B();\nB* b2 = new D();\nU* u1 = b1-&gt;f();\nU* u2 = b2-&gt;f();\n</code></pre>\n<p><code>b1-&gt;f()</code> is going to call <code>B::f</code>, which returns <code>U*</code>. But <code>b2-&gt;f()</code> is going to call <code>D::f</code>, which returns <code>V*</code>. <code>V</code> must be derived from <code>U</code> so that the <code>V*</code> returned from <code>D::f</code> can always be converted to <code>U*</code>.</p>\n<p>Now, it is <strong>reasonable</strong> to allow <code>U</code> to be <code>void</code> in this case, because any pointer to object type can be converted to <code>void*</code>, even though <code>void</code> is not a base class of anything. But the standard does not require that it be allowed.</p>\n<p>The standard also says (1.4 [intro.compliance], paragraph 8),</p>\n<blockquote>\n<p id=\"so_21963734_21963998_4\">A conforming implementation may have extensions (including additional library functions), provided they do\n  not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however,\n  they can compile and execute such programs.</p>\n</blockquote>\n<p>So g++ is not <em>wrong</em>. Allowing <code>U</code> to be <code>void</code> is an <em>extension</em> which does not alter the behaviour of any well-formed program, and g++ <em>does</em> issue a warning when you try to compile this code.</p>\n</hr>", "LastActivityDate": "2014-02-23T03:55:10.547", "CommentCount": "1", "CreationDate": "2014-02-23T03:55:10.547", "ParentId": "21963734", "Score": "4", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_21963734_21963998_2": {"length": 17, "quality": 1.0, "section_id": 7008}, "so_21963734_21963998_3": {"length": 19, "quality": 1.0, "section_id": 7008}, "so_21963734_21963998_4": {"length": 33, "quality": 0.9705882352941176, "section_id": 5776}, "so_21963734_21963998_1": {"length": 11, "quality": 1.0, "section_id": 7008}, "so_21963734_21963998_0": {"length": 24, "quality": 0.96, "section_id": 7008}}, "n3337": {"so_21963734_21963998_2": {"length": 17, "quality": 1.0, "section_id": 6754}, "so_21963734_21963998_3": {"length": 19, "quality": 1.0, "section_id": 6754}, "so_21963734_21963998_4": {"length": 33, "quality": 0.9705882352941176, "section_id": 5549}, "so_21963734_21963998_1": {"length": 11, "quality": 1.0, "section_id": 6754}, "so_21963734_21963998_0": {"length": 24, "quality": 0.96, "section_id": 6754}}, "n4659": {"so_21963734_21963998_2": {"length": 17, "quality": 1.0, "section_id": 8505}, "so_21963734_21963998_3": {"length": 19, "quality": 1.0, "section_id": 8505}, "so_21963734_21963998_4": {"length": 33, "quality": 0.9705882352941176, "section_id": 7233}, "so_21963734_21963998_1": {"length": 11, "quality": 1.0, "section_id": 8505}, "so_21963734_21963998_0": {"length": 23, "quality": 0.92, "section_id": 8505}}}, "21963734": {"ViewCount": "655", "Body": "<p>I'm trying to override a base class function. Both the derived type and the base type return pointers so it should be covariant according to some posts I read on google and here on stackoverflow..</p>\n<p>However in MSVC2013 for the following classes:</p>\n<pre><code>class PSBaseObject\n{\n    public:\n        PSBaseObject() {}\n        virtual ~PSBaseObject() {}\n\n        virtual void* data() { return this; }\n        virtual const void* data() const { return this; }\n};\n\ntemplate&lt;typename T&gt;\nclass PSObject : public PSBaseObject\n{\n    private:\n        T* data_;\n\n    public:\n        PSObject(T* object) : data_(object) {}\n        ~PSObject() { delete data_; }\n\n        T* data() { return data_; }\n        const T* data() const { return data_; }\n};\n</code></pre>\n<p>I get an error:</p>\n<pre><code>'PSObject&lt;data&gt;::data': overriding virtual function return type differs and is not covariant from 'PSBaseObject::data'\n</code></pre>\n<p>Where data is defined and used as follows:</p>\n<pre><code>typedef struct\n{\n    void* hFileMap;\n    void* pData;\n    std::size_t size; \n} data;\n\ndata* info = new data();\n\nauto ptr = new PSObject&lt;data&gt;(info);\n</code></pre>\n<p>Why is it not covariant?</p>\n<p>Any ideas what I'm doing wrong in <code>MSVC2013</code>? The code compiles and works fine in <code>g++ 4.8.1</code>.</p>\n", "AcceptedAnswerId": "21963917", "Title": "overriding virtual function covariant return types (both pointers)", "CreationDate": "2014-02-23T03:14:28.797", "Id": "21963734", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-02-23T03:55:10.547", "Score": "0", "OwnerUserId": "1462718", "Tags": "<c++>", "AnswerCount": "3"}, "21963782": {"Id": "21963782", "PostTypeId": "2", "Body": "<p>MSVC2013 is right.</p>\n<p>When you will call</p>\n<pre><code>  ptr-&gt;data();\n</code></pre>\n<p>Compiler will not know what method to use, it could be <code>PSBaseObject::data()</code> or <code>PSObject&lt;data&gt;::data();</code></p>\n<p>So you need to fix your design.</p>\n", "LastActivityDate": "2014-02-23T03:21:09.920", "CommentCount": "1", "CreationDate": "2014-02-23T03:21:09.920", "ParentId": "21963734", "Score": "0", "OwnerUserId": "421163"}, "21963917": {"Id": "21963917", "PostTypeId": "2", "Body": "<p>In this case gcc is wrong, and VS is right in rejecting the code. The standard treats this in 10.3/7, where it defines what <em>covariant</em> means. That definition requires that both return types are pointers or references to <em>classes</em>. Since <code>void</code> is not a class, the code you present does not show <em>covariance</em>.</p>\n<p>Gcc is wrongly accepting the code.</p>\n", "LastActivityDate": "2014-02-23T03:41:52.030", "CommentCount": "0", "CreationDate": "2014-02-23T03:41:52.030", "ParentId": "21963734", "Score": "1", "OwnerUserId": "36565"}});