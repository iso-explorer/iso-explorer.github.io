post_cb({"bq_ids": {"n4140": {"so_28048208_28048551_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}}, "n3337": {"so_28048208_28048551_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}}, "n4659": {"so_28048208_28048551_0": {"length": 12, "quality": 1.0, "section_id": 4087}}}, "28048208": {"ViewCount": "177", "Body": "<p>I don't understand why the following code doesn't compile:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Test {\npublic:\n    Test() {\n        std::cout &lt;&lt; \"Constructor\" &lt;&lt; std::endl;\n    }\n    Test(const Test&amp;) {\n        std::cout &lt;&lt; \"Copy Constructor\" &lt;&lt; std::endl;\n    }\n\n    Test&amp; operator=(const Test&amp;) {\n        std::cout &lt;&lt; \"Assign Op\" &lt;&lt; std::endl;\n        return *this;\n    }\n\n    Test&amp; operator=(const volatile Test&amp;) {\n        std::cout &lt;&lt; \"Volatile Assign Op\" &lt;&lt; std::endl;\n        return *this;\n    }\n};\n\nvolatile Test func() {\n    Test a;\n    return a;\n}\nint main() {\n    Test b;\n    volatile Test c;\n    b = c; // this line is correct\n    b = func(); // this line doesnt compile correct\n    return 0;\n}\n</code></pre>\n<p>the line:</p>\n<pre><code>    b = c; // this line is correct\n</code></pre>\n<p>While:</p>\n<pre><code>    b = func(); // this line doesn t compile\n</code></pre>\n<p>The compile complains about: </p>\n<pre><code>test.cc: In function \u2018int main()\u2019:\ntest.cc:31:14: error: no match for \u2018operator=\u2019 in \u2018b = func()()\u2019\ntest.cc:31:14: note: candidates are:\ntest.cc:12:11: note: Test&amp; Test::operator=(const Test&amp;)\ntest.cc:12:11: note:   no known conversion for argument 1 from \u2018volatile Test\u2019 to \u2018const Test&amp;\u2019\ntest.cc:17:11: note: Test&amp; Test::operator=(const volatile Test&amp;)\ntest.cc:17:11: note:   no known conversion for argument 1 from \u2018volatile Test\u2019 to \u2018const volatile Test&amp;\u2019\n</code></pre>\n<p>In the beginning I thought that it was due to constructor elision, which I was experimenting how to disable it using volatile, when I got into this situation. Compiling with:</p>\n<blockquote>\n<p id=\"so_28048208_28048208_0\">-fno-elide-constructors</p>\n</blockquote>\n<p>Didn't make any difference.</p>\n<p>Any explanation for this?\nTesting with:</p>\n<blockquote>\n<p id=\"so_28048208_28048208_1\">g++ (GCC) 4.6.3 20120306 (Red Hat 4.6.3-2)</p>\n</blockquote>\n", "Title": "Assigning a volatile rvalue", "CreationDate": "2015-01-20T14:46:46.090", "LastActivityDate": "2015-01-20T16:51:42.130", "CommentCount": "0", "LastEditDate": "2015-01-20T15:02:25.133", "PostTypeId": "1", "LastEditorUserId": "567292", "Id": "28048208", "Score": "1", "OwnerUserId": "4474306", "Tags": "<c++><volatile><rvalue>", "AnswerCount": "1"}, "28048551": {"Id": "28048551", "PostTypeId": "2", "Body": "<p>Per <strong>[dcl.init.ref]</strong>/5, for a reference (i.e. the parameter of <code>Test::operator=()</code>) to be initialized by binding to an rvalue, the reference must be a <code>const</code> non-<code>volatile</code> lvalue reference, or an rvalue reference:</p>\n<blockquote>\n<p id=\"so_28048208_28048551_0\">\u2014 Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference. </p>\n</blockquote>\n<p>The line <code>b = c;</code> works because you are binding a reference (the parameter of <code>Test::operator=()</code>) to an lvalue.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-01-20T16:51:42.130", "Score": "4", "CreationDate": "2015-01-20T15:01:45.060", "ParentId": "28048208", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2015-01-20T16:51:42.130"}});