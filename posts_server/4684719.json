post_cb({"bq_ids": {"n4140": {"so_4684719_4684860_0": {"length": 39, "quality": 0.9285714285714286, "section_id": 6094}, "so_4684719_4684860_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6095}}, "n3337": {"so_4684719_4684860_0": {"length": 39, "quality": 0.9285714285714286, "section_id": 5860}, "so_4684719_4684860_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 5861}}}, "4684935": {"CommentCount": "0", "Body": "<p>My assumption is that it is placement new, and that all 5 are arguments to the overload. In my inerpretation, one of the arguments is <code>&amp;hr</code>, which is an error code and then is used as second argument to <code>operator,</code> to provide that as a result value.</p>\n<p>I don't think that your usage of the macro is correct, in particular I believe that <code>NEWPTR</code> is intended to be the address of the actual pointer to initialize, that is, calling code should be:</p>\n<pre><code>hr = NewArrayOnHeap(double, 10, heap, &amp;ptr, \"Help\");\n</code></pre>\n<p>which would make the expansion:</p>\n<pre><code>hr = ((*(&amp;ptr) = new ( \"double[ 10 ]\", __alignof(double), (NULL), &amp;hr, (\"Help\")) double[10] ), hr);\n</code></pre>\n<p>Without the extra <code>&amp;</code>, the left and right hand sides of the inner assignment would not match in type: <code>*(ptr)</code> is a <code>double, while the result of placement new would be a</code>double*`.</p>\n", "CreationDate": "2011-01-13T20:31:00.657", "ParentId": "4684719", "Id": "4684935", "LastActivityDate": "2011-01-13T20:31:00.657", "PostTypeId": "2", "Score": "3", "OwnerUserId": "36565"}, "4684719": {"CreationDate": "2011-01-13T20:09:42.937", "ViewCount": "296", "FavoriteCount": "0", "Id": "4684719", "AcceptedAnswerId": "4684860", "Score": "5", "Title": "Unusual use of new in historical code. What does it mean?", "LastEditorUserId": "21234", "CommentCount": "4", "Body": "<p>I am just porting some old code:</p>\n<pre><code>#define NewArrayOnHeap(TYPE, COUNT, HEAP, NEWPTR, ERROR) \\\n((*(NEWPTR) = new ( #TYPE \"[\" #COUNT \"]\", __alignof(TYPE), (HEAP), &amp;hr, (ERROR)) TYPE[COUNT] ), hr)\n</code></pre>\n<p>It looks like the original was supposed to define their own magical <code>new</code> operator. I am curious about this usage.</p>\n<h3>Example usage</h3>\n<pre><code>int main()\n{\n    void*   heap = /* Don't know how to define this */\n    double* ptr;\n    HRESULT hr;\n\n    hr = NewArrayOnHeap(double, 10, heap, ptr, \"Help /* Just guessing here */\");\n}\n</code></pre>\n<p>When I use <code>g++ -E</code> to get the preprocessor output, it's:</p>\n<pre><code>int main()\n{\n    double* ptr;\n    HRESULT hr;\n\n    hr = ((*(ptr) = new ( \"double[ 10 ]\", __alignof(double), (NULL), &amp;hr, (\"Help\")) double[10] ), hr);\n}\n</code></pre>\n<p>This looks slightly more like a <code>placement new</code>.</p>\n<p>But is this now an overloaded new call (with some funky parameters, a five parameter <code>new</code> call), or are the commas here the comma operator and thus it gets reduced to <code>(\"Help\")</code> (which wouldn't make sense).</p>\n<p>Was <code>new</code> historically (or even now) allowed to have more than two parameters, <code>(size, hint)</code>?</p>\n<p>Any help on decoding would be appreciated.</p>\n", "Tags": "<c++><new-operator><legacy-code><placement-new>", "LastEditDate": "2011-01-14T03:58:25.123", "LastActivityDate": "2011-01-14T03:58:25.123", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "14065"}, "4684860": {"LastActivityDate": "2011-01-13T20:40:14.050", "CommentCount": "4", "Body": "<p>The section you want to look at is \u00a75.3.4/11-12, paraphrased here:</p>\n<blockquote>\n<p id=\"so_4684719_4684860_0\">The new-placement syntax is used to supply additional arguments to an allocation function. If used, overload resolution is performed on a function call created by assembling an argument list consisting of the amount of space requested (the first argument) and the expressions in the new-placement part of the new-expression (the second and succeeding arguments). The first of these arguments has type size_t and the remaining arguments have the corresponding types of the expressions in the new-placement.</p>\n<p id=\"so_4684719_4684860_1\">[Example:<br>\n  \u2014 new T results in a call of operator new(sizeof(T)),<br>\n  \u2014 new(2,f) T results in a call of operator new(sizeof(T),2,f),<br>\n  \u2014 new T[5] results in a call of operator new, and<br>\n  \u2014 new(2,f) T[5] results in a call of operator new[](sizeof(T)*5+y,2,f).]  </br></br></br></br></p>\n</blockquote>\n<p>So your macro, to be used correctly, requires that somewhere there's an <code>operator new</code> overload defined similar to:</p>\n<pre><code>void* operator new[](size_t, const char*, size_t, void*, HRESULT*, const char*);\n</code></pre>\n<p>Which I suspect uses the information given to it to allocate memory (potentially from a pre-allocated source) that satisfies alignment requirements, while logging this allocation and providing a custom error message if the allocation could not be made.</p>\n<p>Personally, I find it gross. :)</p>\n<hr>\n<p>The typical \"placement new\" operator you're referring to is defined in <code>&lt;new&gt;</code>, and is just another overload that accepts a <code>void*</code> and returns that as the allocation result.</p>\n</hr>", "CreationDate": "2011-01-13T20:24:37.090", "LastEditDate": "2011-01-13T20:40:14.050", "ParentId": "4684719", "Id": "4684860", "LastEditorUserId": "14065", "PostTypeId": "2", "Score": "7", "OwnerUserId": "87234"}});