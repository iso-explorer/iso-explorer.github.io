post_cb({"bq_ids": {"n4140": {"so_34154770_34157327_1": {"length": 12, "quality": 1.0, "section_id": 214}, "so_34154770_34154770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7083}}, "n3337": {"so_34154770_34157327_1": {"length": 12, "quality": 1.0, "section_id": 208}, "so_34154770_34154770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6827}}, "n4659": {"so_34154770_34157327_1": {"length": 12, "quality": 1.0, "section_id": 222}, "so_34154770_34154770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 8584}, "so_34154770_34157327_0": {"length": 28, "quality": 0.8484848484848485, "section_id": 180}}}, "34155752": {"Id": "34155752", "PostTypeId": "2", "Body": "<p>If my understanding of the lookup rules are correct, then since <code>g()</code> is a non-dependent name, the overload set won't be added to in phase 2. Therefore the only choice for <code>g(0)</code> at the point of definition is <code>g(long)</code>, and Clang is correct.</p>\n<p>I would certainly naively <em>expect</em> only <code>g(long)</code> to be considered given the ordering of the definitions, but then again the C++ standard isn't always intuitive when templates are involved...</p>\n", "LastActivityDate": "2015-12-08T12:20:32.427", "CommentCount": "1", "CreationDate": "2015-12-08T12:20:32.427", "ParentId": "34154770", "Score": "0", "OwnerUserId": "2797826"}, "34154770": {"ViewCount": "87", "Body": "<blockquote>\n<p id=\"so_34154770_34154770_0\">3.4 [basic.lookup]/p1</p>\n<p id=\"so_34154770_34154770_1\">Overload resolution (13.3) takes place after name lookup has succeeded.</p>\n</blockquote>\n<pre><code>void g(long);\n\nvoid g(int, int);\n\ntemplate&lt;class T&gt; void f() { g(0); }\n\nvoid g(int, int = 0) {}\n\nint main(){\n    f&lt;int&gt;();\n}\n</code></pre>\n<p>gcc compiles succeed, clang faild.</p>\n<p>When does overload resolution of non-dependent name take place, in definition context or point of instantiation? Or both are right?</p>\n", "AcceptedAnswerId": "34157327", "Title": "When does overload resolution of non-dependent name take place, in definition context or point of instantiation?", "CreationDate": "2015-12-08T11:30:53.357", "Id": "34154770", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-01-27T10:14:49.920", "LastEditorUserId": "13302", "LastActivityDate": "2017-01-27T10:14:49.920", "Score": "3", "OwnerUserId": "4958516", "Tags": "<c++><templates><language-lawyer><overload-resolution><name-lookup>", "AnswerCount": "2"}, "34157327": {"Id": "34157327", "PostTypeId": "2", "Body": "<p>In both context.</p>\n<p><strong>[temp.res] 14.6\\8</strong></p>\n<blockquote>\n<p id=\"so_34154770_34157327_0\">If a hypothetical instantiation of a template immediately following\n  its definition would be ill-formed due to a construct that does not\n  depend on a template parameter, the program is ill-formed; no\n  diagnostic is required. If the interpretation of such a construct in\n  the hypothetical instantiation is different from the interpretation of\n  the corresponding construct in any actual instantiation of the\n  template, the program is ill-formed; no diagnostic is required.</p>\n</blockquote>\n<p><strong>[temp.nondep] 14.6.3\\1</strong></p>\n<blockquote>\n<p id=\"so_34154770_34157327_1\">Non-dependent names used in a template definition are found using the\n  usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>So both compilers are right.</p>\n", "LastActivityDate": "2015-12-08T13:37:48.387", "CommentCount": "13", "CreationDate": "2015-12-08T13:37:48.387", "ParentId": "34154770", "Score": "2", "OwnerUserId": "5181494"}});