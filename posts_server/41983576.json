post_cb({"41983849": {"ParentId": "41983576", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_41983576_41983849_0\">Copying/NRVO/moving or destruction of shared_ptr there by causing memory fault?</p>\n</blockquote>\n<p>Well, let's think about it. Consider this function:</p>\n<pre><code>X foo() {\n    X x;\n    return x;\n}\n</code></pre>\n<p>There are two potential orderings here, let's forget about copy elision.</p>\n<ol>\n<li><code>x</code> is copied into the return value, then <code>x</code> is destroyed.</li>\n<li><code>x</code> is destroyed, then <code>x</code> is copied into the return value.</li>\n</ol>\n<p>The implication of (2) would be that such code would be undefined behavior, which would make it pretty much impossible to write a function at all - since you couldn't return any local variables. So from a language sanity design perspective, it had better be (1).</p>\n<hr/>\n<p>The explicit rule is in [stmt.return]:</p>\n<blockquote>\n<p id=\"so_41983576_41983849_1\">The copy-initialization of the result of the call <strong>is sequenced before the destruction of temporaries</strong> at the end of the full-expression established by the operand of the return statement, which, in turn, is sequenced before\n  the destruction of local variables (6.6) of the block enclosing the return statement.</p>\n</blockquote>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "41983849", "Score": "4", "CreationDate": "2017-02-01T15:43:14.920", "LastActivityDate": "2017-02-01T15:43:14.920"}, "bq_ids": {"n4659": {"so_41983576_41983849_1": {"section_id": 4800, "quality": 0.9583333333333334, "length": 23}}}, "41983965": {"ParentId": "41983576", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This happens:</p>\n<ul>\n<li>A temporary copy of the pointed object is made. This is the return value of the function. The copy can not be elided.</li>\n<li>The local variables of the function, including the shared pointer are destroyed.</li>\n<li>When the shared pointer is destroyed, the refcount is decremented. If no copies of the shared pointer were made within the function, refocount will reach 0 and the pointed object is destroyed.</li>\n</ul>\n<p>It is safe, but the use of dynamic allocation, and shared pointer seems <em>pointless</em> and the inefficiency of the copy may hurt performance if the set is large.</p>\n<hr>\n<p>Since you haven't demonstrated any need for using the pointer, I suggest a simpler alternative:</p>\n<pre><code>boost::unordered_set&lt;std::string&gt; list;\n\n/* Code to populate the unordered_set goes here and I do\n     populate my set. */\n\nreturn list;\n</code></pre>\n<p>NRVO can be applied to this and if it's not applied, the return value is constructed by move.</p>\n</hr>", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2017-02-27T23:57:08.580", "Id": "41983965", "Score": "8", "CreationDate": "2017-02-01T15:47:59.997", "LastActivityDate": "2017-02-27T23:57:08.580"}, "41983611": {"ParentId": "41983576", "CommentCount": "2", "Body": "<p>Your shared_ptr is not doing anything, you are not returning it, you are returning its contents, i.e. the unordered_set itself.\nYou should change your function to return the shared_ptr and return it by value.</p>\n<p>You should probably be using std:: not boost (unless this is an old compiler).</p>\n", "OwnerUserId": "68105", "PostTypeId": "2", "Id": "41983611", "Score": "2", "CreationDate": "2017-02-01T15:33:20.270", "LastActivityDate": "2017-02-01T15:33:20.270"}, "41983576": {"CommentCount": "2", "AcceptedAnswerId": "41983965", "LastEditDate": "2017-02-01T15:36:33.033", "LastEditorUserId": "3919155", "CreationDate": "2017-02-01T15:31:28.377", "LastActivityDate": "2017-02-27T23:57:08.580", "PostTypeId": "1", "ViewCount": "172", "Title": "Return a dereferenced value of shared_ptr from a function", "Id": "41983576", "OwnerUserId": "1410711", "Body": "<p>Here is a rookie question. Is the following code safe?</p>\n<pre><code>boost::unordered_set&lt;std::string&gt; func()\n{\n      boost::shared_ptr&lt;boost::unordered_set&lt;std::string&gt;&gt; list =\n              boost::make_shared&lt;boost::unordered_set&lt;std::string&gt;&gt;();\n\n      /* Code to populate the shared_ptr to unordered_set goes here and I do\n         populate my set. */\n\n      return *list;\n}\n</code></pre>\n<p>What will happen first? Copying/NRVO/moving or destruction of <code>shared_ptr</code> there by causing memory fault? If unsafe, what are my alternatives?</p>\n", "Tags": "<c++><c++11><boost><shared-ptr>", "Score": "3", "AnswerCount": "3"}});