post_cb({"11783201": {"Id": "11783201", "PostTypeId": "2", "Body": "<p>A compiler can do anything it wants with your code so long as the 'observable' results are indistinguishable from running the code exactly as you wrote it on the idealized 'virtual machine' defined by the language.</p>\n<p>'observable' does not include things like running time, profiler results, variables observed via a debugger, etc. Observable behavior is considered to be accesses of volatile objects, data written to files, and handling of input and output devices.</p>\n<p>So to ensure that your code actually runs you need to make sure that it has to be run in order to produce correct observable behavior. Generally you can just save the output to be printed or written to a file (outside the code you're timing). Another option is to write the output to a volatile variable.</p>\n<p>Another thing that may matter is if the compiler can statically evaluate your code then even if you print the output the function call may be reduced to just loading the compiler's statically computed output. To avoid this you may have to provide input to the function that cannot be statically known, such as data read from input or a file or a volatile variable.</p>\n<hr>\n<p>Of course using input and output in ways you wouldn't in a real program can affect the timing. So the most reliable way to measure performance is to do so in a real program with exactly the configuration you wish to test. Write your program to be easily switched between configurations and then test both.</p>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2012-08-02T18:12:51.667", "Score": "4", "CreationDate": "2012-08-02T18:01:01.167", "ParentId": "11782973", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2012-08-02T18:12:51.667"}, "11782973": {"ViewCount": "184", "Body": "<p>I am working on and ios project compiling with Apple LLVM 4.0 with optimizations.  I implemented two different versions of a function, one in C and one in NEON.  I wanted to test their performance against one another.  My idea was to call them both the same amount of times and then look them up in Time Profiler to see the relative time spent in each.  Originally my code looked like</p>\n<pre><code>used_value = score_squareNEON(patch, image, current_pos);\nused_value = score_squareC(patch, image, current_pos);\n</code></pre>\n<p>When I profiled the time the NEON code did not appear at all.  Next I tried</p>\n<pre><code>for(int i = 0; i &lt; successively_bigger_numbers; i++)\n{\n    used_value = score_squareNEON(patch, image, current_pos);\n{\nused_value = score_squareC(patch, image, current_pos);\n</code></pre>\n<p>Still no contribution from NEON code.  Next was</p>\n<pre><code>used_value = score_squareNEON(patch, image, current_pos);\ntest = score_squareC(patch, image, current_pos);\n</code></pre>\n<p>where test never got read.  Nothing.  Then</p>\n<pre><code>test = score_squareNEON(patch, image, current_pos);\ntest = 0;\nother_used_variable += test;\nused_value = score_squareC(patch, image, current_pos);\n</code></pre>\n<p>Still nothing.  What finally made it execute both functions was </p>\n<pre><code>value = score_squareNEON(patch, image, current_pos);\ntest = score_squareC(patch, image, current_pos);\n...\nmin = (value+test)/2; //before it was min=value;\n</code></pre>\n<p>Also very important.  The functions were both defined in the same file in which I was calling them.  When I tried moving the function declarations to a different file both of them are called in every example.</p>\n<p>First off, I have gained a lot of respect for compilers.  Second, what exactly do I have to do to make sure a function is called?  This has made me start to question all the things I have timed before.  What if in the normal pattern of</p>\n<pre><code>timerStart();\nfunctionCall();\ntimerEnd();\n</code></pre>\n<p>the function in the middle gets optimized out completely?  Do I need to start checking for this somehow every time or is there a trick I can use?  What are the rules governing when a compiler can optimize out an entire function call?</p>\n", "AcceptedAnswerId": "11783200", "Title": "What do I have to do to get a function called in compiler optimized code?", "CreationDate": "2012-08-02T17:46:22.843", "Id": "11782973", "CommentCount": "2", "LastEditDate": "2012-08-02T18:22:06.607", "PostTypeId": "1", "LastEditorUserId": "852487", "LastActivityDate": "2012-08-02T18:22:06.607", "Score": "4", "OwnerUserId": "852487", "Tags": "<c++><ios><optimization><compilation><llvm>", "AnswerCount": "2"}, "11783200": {"Id": "11783200", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11782973_11783200_0\">Also very important. The functions were both defined in the same file in which I was calling them. When I tried moving the function declarations to a different file both of them are called in every example.</p>\n</blockquote>\n<p>When the compiler can prove that a function call has no side effect, and its result is not used, it can remove the call. If it can't prove that, the call cannot be removed because as far as the compiler can tell, the function may have side effects, and those mustn't be eliminated.</p>\n<p>Declaring the variable the result of the function call is assigned to\u00b9 should be enough to force the compiler to leave the function call in the program (6.7.3, paragraph 7 in N1570):</p>\n<blockquote>\n<p id=\"so_11782973_11783200_1\">An object that has volatile-quali\ufb01ed type may be modi\ufb01ed in ways unknown to the\n  implementation or have other unknown side effects. Therefore any expression referring\n  to such an object shall be evaluated strictly according to the rules of the abstract machine,\n  as described in 5.1.2.3. Furthermore, at every sequence point the value last stored in the\n  object shall agree with that prescribed by the abstract machine, except as modi\ufb01ed by the\n  unknown factors mentioned previously. What constitutes an access to an object that\n  has volatile-quali\ufb01ed type is implementation-de\ufb01ned.</p>\n</blockquote>\n<p>For C++ the guarantees are a little less unambiguous, as far as I can tell, but I think 1.9 should take precedence:</p>\n<p>Program execution, 1.9 (6) and (7):</p>\n<blockquote>\n<p id=\"so_11782973_11783200_2\">The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and\n  calls to library I/O functions.6)</p>\n<p id=\"so_11782973_11783200_3\">Accessing an object designated by a volatile lvalue (3.10), modifying an object, calling a library I/O\n  function, or calling a function that does any of those operations are all side effects, which are changes in the\n  state of the execution environment. Evaluation of an expression might produce side effects. At certain\n  specified points in the execution sequence called sequence points, all side effects of previous evaluations\n  shall be complete and no side effects of subsequent evaluations shall have taken place.</p>\n</blockquote>\n<p>And in 7.1.5.1:</p>\n<blockquote>\n<p id=\"so_11782973_11783200_4\">[Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object\n  because the value of the object might be changed by means undetectable by an implementation. See 1.9 for\n  detailed semantics. In general, the semantics of volatile are intended to be the same in C++ as they are\n  in C. ]</p>\n</blockquote>\n<p>\u00b9 That doesn't work with <code>void fun()</code>, of course.</p>\n", "LastEditorUserId": "1011995", "LastActivityDate": "2012-08-02T18:10:07.233", "Score": "5", "CreationDate": "2012-08-02T18:00:53.130", "ParentId": "11782973", "CommentCount": "1", "OwnerUserId": "1011995", "LastEditDate": "2012-08-02T18:10:07.233"}, "bq_ids": {"n4140": {"so_11782973_11783200_4": {"length": 25, "quality": 0.9615384615384616, "section_id": 5436}}, "n3337": {"so_11782973_11783200_4": {"length": 25, "quality": 0.9615384615384616, "section_id": 5231}}, "n4659": {"so_11782973_11783200_4": {"length": 25, "quality": 0.9615384615384616, "section_id": 6863}}}});