post_cb({"bq_ids": {"n4140": {"so_23750766_23751003_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7070}, "so_23750766_23751003_0": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_23750766_23751003_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6814}, "so_23750766_23751003_0": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_23750766_23751003_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8567}, "so_23750766_23751003_0": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "23751003": {"Id": "23751003", "PostTypeId": "2", "Body": "<p>This example demonstrates the class scope and its rules particularly the following rule</p>\n<blockquote>\n<p id=\"so_23750766_23751003_0\">2) A name N used in a class S shall refer to the same declaration in\n  its context and when re-evaluated in the completed scope of S. No\n  diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p>In this example name i does not refer to the same name in the class scope. At first it refers to the global enumerator i and then it is reevaluated and refers to the class enumerator i.</p>\n<p>So the compiler issues an error though as there is written in the rule it is implementation defined whether there will be a compiler diagnostic.</p>\n<p>As for using name c in operator sizeof in function f then it is refers to the class data member with the same name because according to the rules</p>\n<blockquote>\n<p id=\"so_23750766_23751003_1\">1) The potential scope of a name declared in a class consists not only\n  of the declarative region following the name\u2019s point of declaration,\n  but also of <strong>all function bodies</strong></p>\n</blockquote>\n", "LastActivityDate": "2014-05-20T04:25:57.227", "CommentCount": "4", "CreationDate": "2014-05-20T04:25:57.227", "ParentId": "23750766", "Score": "1", "OwnerUserId": "2877241"}, "23750766": {"ViewCount": "105", "Body": "<p>There is the example from 3.3.7/5:</p>\n<pre><code>typedef int c;\nenum { i = 1 };\nclass X \n{\n    char v[i]; // error: i refers to ::i\n               // but when reevaluated is X::i\n    int f() { return sizeof(c); } // OK: X::c\n    char c;\n    enum { i = 2 };\n};\n</code></pre>\n<p>But it doesn't even compile. The following error is caused:</p>\n<blockquote>\n<p id=\"so_23750766_23750766_0\">test.cpp:9:12: error: declaration of \u2018i\u2019 [-fpermissive] </p>\n<p id=\"so_23750766_23750766_1\">test.cpp:4:8: error: changes meaning of \u2018i\u2019 from \u2018 i\u2019 [-fpermissive]</p>\n</blockquote>\n<p>What is the sense of that example?</p>\n", "AcceptedAnswerId": "23751003", "Title": "Unscoped enum redefinition inside and outside the class", "CreationDate": "2014-05-20T03:56:16.610", "Id": "23750766", "CommentCount": "3", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-05-20T04:25:57.227", "Score": "0", "Tags": "<c++><class><enums>", "AnswerCount": "1"}});