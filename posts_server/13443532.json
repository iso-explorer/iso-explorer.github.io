post_cb({"bq_ids": {"n4140": {"so_13443532_13445881_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 5811}}, "n3337": {"so_13443532_13445881_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 5584}}, "n4659": {"so_13443532_13445881_0": {"length": 18, "quality": 0.5294117647058824, "section_id": 7273}}}, "13443532": {"ViewCount": "2315", "Body": "<p>Given the following function call:</p>\n<pre><code>f(g(), h())\n</code></pre>\n<p>since the order of evaluation of function arguments is unspecified (still the case in C++11 as far as I'm aware), could an implementation theoretically execute <code>g()</code> and <code>h()</code> in parallel?</p>\n<p>Such a parallelisation could only kick in were <code>g</code> and <code>h</code> known to be fairly trivial (in the most obvious case, accessing only data local to their bodies) so as not to introduce concurrency issues but, beyond that restriction I can't see anything to prohibit it.</p>\n<p>So, does the standard allow it? Even if only by the as-if rule?</p>\n<p><sub>(In <a href=\"https://stackoverflow.com/a/9116081/560648\">this answer</a>, Mankarse asserts otherwise; however, he does not cite the standard, and my read-through of <code>[expr.call]</code> hasn't revealed any obvious wording.)</sub></p>\n", "AcceptedAnswerId": "13445881", "Title": "Could a C++ implementation, in theory, parallelise the evaluation of two function arguments?", "CreationDate": "2012-11-18T19:08:43.353", "Id": "13443532", "CommentCount": "12", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:02.083", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-31T02:03:24.573", "Score": "68", "OwnerUserId": "560648", "Tags": "<c++><language-lawyer>", "AnswerCount": "4"}, "13443696": {"Id": "13443696", "PostTypeId": "2", "Body": "<p>As long as you can't tell, whatever the compiler does to evaluate these functions is entirely up to the compiler. Clearly, the evaluation of the functions cannot involve any access to shared, mutable data as this would introduce data races. The basic guiding principle is the \"as if\"-rule and the fundamental observable operations, i.e., access to <code>volatile</code> data, I/O operations, access to atomic data, etc. The relevant section is 1.9 [intro.execution].</p>\n", "LastActivityDate": "2012-11-18T19:25:45.427", "CommentCount": "6", "CreationDate": "2012-11-18T19:25:45.427", "ParentId": "13443532", "Score": "16", "OwnerUserId": "1120273"}, "13443692": {"Id": "13443692", "PostTypeId": "2", "Body": "<p>Not unless the compiler knew exactly what <code>g()</code>, <code>h()</code>, and anything they call does.</p>\n<p>The two expressions are function calls, which may have unknown side effects. Therefore, parallelizing them could cause a data-race on those side effects. Since the C++ standard does not allow argument evaluation to cause a data-race on any side effects of the expressions, the compiler can only parallelize them if it <em>knows</em> that no such data race is possible.</p>\n<p>That means walking though each function and look at exactly what they do and/or call, then tracking through <em>those</em> functions, etc. In the general case, it's not feasible.</p>\n", "LastActivityDate": "2012-11-18T19:24:45.813", "CommentCount": "1", "CreationDate": "2012-11-18T19:24:45.813", "ParentId": "13443532", "Score": "3", "OwnerUserId": "734069"}, "13445881": {"Id": "13445881", "PostTypeId": "2", "Body": "<p>The requirement comes from <code>[intro.execution]/15</code>:</p>\n<blockquote>\n<p id=\"so_13443532_13445881_0\">... When calling a function ... Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is <strong>indeterminately sequenced</strong> with respect to the execution of the called function [Footnote: <strong>In other words, function executions do not interleave with each other.</strong>].</p>\n</blockquote>\n<p>So any execution of the body of <code>g()</code> must be indeterminately sequenced with (that is, not overlapping with) the evaluation of <code>h()</code> (because <code>h()</code> is an expression in the calling function).</p>\n<p>The critical point here is that <code>g()</code> and <code>h()</code> are both function calls.</p>\n<p>(Of course, the as-if rule means that the possibility cannot be entirely ruled out, but it should never happen in a way that could affect the observable behaviour of a program. At most, such an implementation would just change the performance characteristics of the code.)</p>\n", "LastEditorUserId": "485561", "LastActivityDate": "2013-05-31T02:03:24.573", "Score": "42", "CreationDate": "2012-11-18T23:50:31.327", "ParentId": "13443532", "CommentCount": "3", "OwnerUserId": "485561", "LastEditDate": "2013-05-31T02:03:24.573"}, "13487538": {"Id": "13487538", "PostTypeId": "2", "Body": "<p>Easy answer: when the functions are <em>sequenced</em>, even if indeterminately, there is no possibility for a race condition between the two, which is not true if they are parallelized.  Even a pair of one line \"trivial\" functions could do it.</p>\n<pre><code>void g()\n{\n    *p = *p + 1;\n}\n\n\nvoid h()\n{\n    *p = *p - 1;\n}\n</code></pre>\n<p>If <code>p</code> is a name shared by <code>g</code> and <code>h</code>, then a sequential calling of <code>g</code> and <code>h</code> in any order will result in the value pointed to by <code>p</code> not changing.  If they are parallelized, the reading of <code>*p</code> and the assigning of it could be interleaved arbitrarily between the two:</p>\n<ol>\n<li><code>g</code> reads <code>*p</code> and finds the value 1.</li>\n<li><code>f</code> reads <code>*p</code> and also finds the value 1.</li>\n<li><code>g</code> writes 2 to <code>*p</code>.</li>\n<li><code>f</code>, still using the value 1 it read before will write 0 to <code>*p</code>.</li>\n</ol>\n<p>Thus, the behavior is different when they are parallelized.</p>\n", "LastActivityDate": "2012-11-21T06:23:43.470", "CommentCount": "1", "CreationDate": "2012-11-21T06:23:43.470", "ParentId": "13443532", "Score": "1", "OwnerUserId": "1564201"}});