post_cb({"bq_ids": {"n4140": {"so_211376_211419_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 7104}}, "n3337": {"so_211376_211419_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 6848}}, "n4659": {"so_211376_211419_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 8605}}}, "211419": {"Id": "211419", "PostTypeId": "2", "Body": "<p>C++ Standard, 3.4.4.2 declares:</p>\n<blockquote>\n<p id=\"so_211376_211419_0\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero\n  or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of\n  the function arguments (and the namespace of any template template argument). <strong>Typedef names and using-declarations\n  used to specify the types do not contribute to this set</strong>.</p>\n</blockquote>\n<p>ADL doesn't work with typedef's.</p>\n", "LastActivityDate": "2008-10-17T08:36:25.693", "CommentCount": "2", "CreationDate": "2008-10-17T08:36:25.693", "ParentId": "211376", "Score": "2", "OwnerUserId": "11401"}, "211386": {"Body": "<pre><code>bool operator==(Vector3 const &amp;lhs, Vector3 const &amp;rhs) { ... }\n</code></pre>\n<p>The canonical definition of an equality operator defined on a class should only have one argument, namely the rhs. The lhs is this.\nDon't know if this would be a solution to your problem though.</p>\n<p>This is what I would write :</p>\n<p>class Vector3 {\n bool operator==( const Vector3 &amp; rhs) const { ... } \n};</p>\n", "CreationDate": "2008-10-17T08:17:24.577", "ParentId": "211376", "CommentCount": "4", "LastEditDate": "2008-10-17T11:35:12.757", "PostTypeId": "2", "LastEditorDisplayName": "QBziZ", "LastActivityDate": "2008-10-17T11:35:12.757", "LastEditorUserId": "11572", "Id": "211386", "OwnerDisplayName": "QBziZ", "Score": "-1", "OwnerUserId": "11572"}, "211376": {"ViewCount": "373", "Body": "<p>I've got a big big code base that includes two main namespaces: the engine and the application.  </p>\n<p>The engine defines a vector3 class as a typedef of another vector3 class, with equality operators that sit in the engine namespace, not in the vector3 class.  I added a class to the application that also had equality operators in the application namespace.  </p>\n<p>When I tried to compile, unrelated but near-by vector3 comparisons failed because it couldn't find an appropriate equality operator.  I suspected I was causing a conflict so moved my equality operators into the class I added, and the compile succeeded.</p>\n<pre><code>// engine.h\nnamespace Engine\n{\n    class Vector3Impl { ... };\n    typedef Vector3Impl Vector3;\n    bool operator==(Vector3 const &amp;lhs, Vector3 const &amp;rhs) { ... }\n}\n\n\n// myfile.cpp\n#include \"engine.h\"\n\nnamespace application\n{\n    class MyClass { ... };\n    bool operator==(MyClass const &amp;lhs, MyClass const &amp;rhs) { ... }\n\n    void myFunc(...)\n    {\n        if ( myClassA == myClassB ) { ... } // builds\n    }\n\n    void anotherFunc(...)\n    {\n        Engine::Vector3 a, b;\n        ...\n        if ( a == b ) { ... } // fails\n    }\n}\n</code></pre>\n<p>However after thinking about it I can't see why the compile failed.  There are no implicit conversions from vector3s to my class or vice-versa, and argument-dependent look-up should be pulling in the equality operator from the engine namespace and matching it.</p>\n<p>I've tried reproducing this bug in a sample C++ project but that refuses to break.  There must be something in the big big code base that is causing this problem, but I'm not sure where to start looking.  Something like the opposite of a rogue \"using Engine\"?  Anyone got any ideas?</p>\n", "AcceptedAnswerId": "211419", "Title": "function overloading fail: why did these operators clash?", "CreationDate": "2008-10-17T08:13:00.917", "Id": "211376", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "tenpn", "LastActivityDate": "2008-10-17T11:35:12.740", "Score": "1", "OwnerUserId": "11801", "Tags": "<c++><operator-overloading><overloading>", "AnswerCount": "3"}, "211417": {"Body": "<p>I once ran into the same problem with a compiler that didn't have Argument Dependent Lookup (Koenig Lookup - thanks @igor) (VC6 I think).  This means that when it sees an operator, it just looks in the enclosing namespaces.</p>\n<p>So can you tell us what compiler you use?</p>\n<p>Moving to another compiler solved it.</p>\n<p>Very inconvenient indeed.</p>\n", "CreationDate": "2008-10-17T08:35:17.473", "ParentId": "211376", "CommentCount": "0", "LastEditDate": "2008-10-17T08:50:02.980", "PostTypeId": "2", "LastEditorDisplayName": "xtofl", "LastActivityDate": "2008-10-17T08:50:02.980", "LastEditorUserId": "6610", "Id": "211417", "OwnerDisplayName": "xtofl", "Score": "0", "OwnerUserId": "6610"}});