post_cb({"13724993": {"Id": "13724993", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13724553_13724993_0\">I thought that R-value was 'anything' which cannot be on the left\n  hand side [of an assignment operaton]</p>\n</blockquote>\n<p>That's the C++03 definition of <code>rvalue</code>, and even then its a colloquialism and not universally true.</p>\n<p>In C++11, the definitions for <code>lvalue</code> and <code>rvalue</code> have changed somewhat.  The rules are complex, and individual situations are handled on a case-by-case basis in the Standard, but here is a general rule of thumb:</p>\n<ol>\n<li>If you can take the address of something, it is an <code>lvalue</code></li>\n<li>If the type of an expression is an <code>lvalue</code> reference, that expression is an <code>lvalue</code></li>\n<li>If neither of the above apply, it is an <code>rvalue</code></li>\n</ol>\n<p>In your particular case, you can take the address of <code>x</code> (eg, it \"has a name\") and it is therefore an lvalue.</p>\n<p>You can read more about lvalues and rvalues in C++11 in two excellent articles:</p>\n<ul>\n<li><a href=\"http://thbecker.net/articles/rvalue_references/section_01.html\" rel=\"noreferrer\">rvalue References Explained</a>, by Thomas Becker (blog article)</li>\n<li><a href=\"http://accu.org/var/uploads/journals/Overload111.pdf\" rel=\"noreferrer\">Universal References</a>, by Scott Meyers (Overload #111)</li>\n</ul>\n", "LastEditorUserId": "241536", "LastActivityDate": "2012-12-05T14:12:14.807", "Score": "6", "CreationDate": "2012-12-05T14:04:36.963", "ParentId": "13724553", "CommentCount": "3", "OwnerUserId": "241536", "LastEditDate": "2012-12-05T14:12:14.807"}, "13724553": {"ViewCount": "330", "Body": "<p>Why <code>const int</code> is <strong>not</strong> an R-value in C++(11)? I thought that R-value was 'anything' which cannot be on the left hand side and constants fulfil that. This code fails:</p>\n<pre><code>int f(int &amp;&amp; x) { return 100; }\n\nvoid g() {\n  const int x = 1;\n  f(x);\n}\n\nerror: invalid initialization of reference of type \u2018int&amp;&amp;\u2019 from expression\nof type \u2018const int\u2019\n</code></pre>\n", "AcceptedAnswerId": "13724891", "Title": "Constant as rvalue in C++(11)", "CreationDate": "2012-12-05T13:39:31.147", "Id": "13724553", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-12-05T15:08:16.857", "Score": "10", "OwnerUserId": "684534", "Tags": "<c++><gcc><c++11>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_13724553_13724838_2": {"length": 7, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_13724553_13724838_2": {"length": 7, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_13724553_13724838_2": {"length": 7, "quality": 1.0, "section_id": 4087}}}, "13724838": {"Id": "13724838", "PostTypeId": "2", "Body": "<p>The parameter type is an rvalue reference and the standard forbids initialization\n of an rvalue-reference with an lvalue of a \"reference-related\" type.</p>\n<blockquote>\n<p id=\"so_13724553_13724838_0\">8.5.3 References [dcl.init.ref ]</p>\n<p id=\"so_13724553_13724838_1\">...</p>\n<p id=\"so_13724553_13724838_2\">5 ... If T1 is reference-related to T2 and the reference is an rvalue\n  reference, the initializer expression shall not be an lvalue.</p>\n</blockquote>\n<p>Hence, the following is an error:</p>\n<pre><code>void f (long &amp;&amp;);\n\nconst long x = 1;\nvoid g () { f (x); }\n</code></pre>\n<p>But the following is not:</p>\n<pre><code>void f (long &amp;&amp;);\n\nconst int x = 1;\nvoid g () { f (x); }\n</code></pre>\n<hr>\n<p>So, the reason for the error is <strong>not</strong> simply \"the initialization is not with an rvalue\", but because \"the initialization is with an lvalue of a reference-related type.\"</p>\n</hr>", "LastEditorUserId": "390807", "LastActivityDate": "2012-12-05T15:08:16.857", "Score": "1", "CreationDate": "2012-12-05T13:56:13.787", "ParentId": "13724553", "CommentCount": "0", "OwnerUserId": "390807", "LastEditDate": "2012-12-05T15:08:16.857"}, "13724891": {"Id": "13724891", "PostTypeId": "2", "Body": "<p>Ok, there are three categories of expressions<sup>1</sup>:</p>\n<ol>\n<li>those that represent objects that have an identity and cannot be moved from;</li>\n<li>those that represent objects that have an identity and can be moved from;</li>\n<li>those that represent objects that do not have an identity and can be moved from;</li>\n</ol>\n<p>The first ones are called lvalues, the second ones are xvalues, and the third ones are prvalues. If we put lvalues and xvalues together, we have glvalues. Glvalues are all expressions that represent objects with an identity. If we put xvalues and prvalues together we have rvalues. Rvalues are all expressions that represent objects that can be moved.</p>\n<p>The expression in question, <code>x</code>, is a glvalue: one can write <code>&amp;x</code>, so the object clearly has an identity.</p>\n<p>Can we move from this expression? Is this object about to expire? No, it is not. It only expires sometime after the current expression. That means it cannot be moved from. That makes it an lvalue.</p>\n<p>All these names can be a bit confusing because lvalue and rvalue in C++ no longer mean what they meant in their C origins. The C++ meaning is completely unrelated to being on the left or right side of assignment<sup>2</sup>.</p>\n<p>Personally, I prefer to use the terminology from <a href=\"http://stroustrup.com/terminology.pdf\">this paper</a> by Bjarne: iM-values (instead of lvalues), im-values (instead of xvalues), Im-values (instead of prvalues), i-values (instead of glvalues), and m-values (instead of rvalues). That is not the terminology that the standard uses, unfortunately.</p>\n<hr>\n<p><sup>1</sup> Here \"have an identity\" means \"its address can be taken\"; \"can be moved from\" means that it is about to expire, either due to its temporary nature, or because the programmer made that explicit in the type system by calling <code>std::move</code> or something similar.</p>\n<p><sup>2</sup> You can have rvalues on the left side of assignment: <code>std::vector&lt;int&gt;(17) = std::vector&lt;int&gt;(42)</code> is a valid expression, even if it is useless.</p>\n</hr>", "LastEditorUserId": "46642", "LastActivityDate": "2012-12-05T14:07:07.390", "Score": "12", "CreationDate": "2012-12-05T13:58:59.770", "ParentId": "13724553", "CommentCount": "4", "OwnerUserId": "46642", "LastEditDate": "2012-12-05T14:07:07.390"}, "13724950": {"Id": "13724950", "PostTypeId": "2", "Body": "<p>In the simple words, you should be able to 'steal' the value of rvalue. This is the whole point of different treatment of rvalues. So rvalue should be unnamed-going-to-die-in-near-future-something.</p>\n", "LastActivityDate": "2012-12-05T14:01:46.403", "CommentCount": "0", "CreationDate": "2012-12-05T14:01:46.403", "ParentId": "13724553", "Score": "0", "OwnerUserId": "1826073"}});