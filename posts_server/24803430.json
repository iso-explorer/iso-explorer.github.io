post_cb({"24803430": {"CommentCount": "2", "AcceptedAnswerId": "24846295", "PostTypeId": "1", "LastEditorUserId": "576911", "CreationDate": "2014-07-17T12:20:51.610", "LastActivityDate": "2014-07-20T01:07:32.553", "LastEditDate": "2014-07-20T00:42:14.183", "ViewCount": "524", "FavoriteCount": "4", "Title": "C++ allocator and memory pool ownership", "Id": "24803430", "Score": "14", "Body": "<p>I'm confused about something. Let's say I have an arbitrary C++ allocator -- say, something like this:</p>\n<pre><code>template&lt;class T&gt;\nstruct my_allocator\n{\n    template&lt;class Other&gt;\n    struct rebind { typedef my_allocator&lt;Other&gt; other; };\n\n    // [other members here]\n};\n</code></pre>\n<p>Now consider the following code (please read the comments):</p>\n<pre><code>typedef my_allocator&lt;int&gt; Alloc;\nAlloc alloc = get_my_allocator();  // assume this works properly\n\nlong *const p = Alloc::rebind&lt;long&gt;::other(alloc).allocate(1, NULL);\n// Notice that the rebound allocator for 'long' is now destroyed\n\n// Can a NEW rebound allocator for 'long' deallocate the memory from the old one?\nAlloc::rebind&lt;long&gt;::other(alloc).deallocate(p, 1);\n// i.e., does the 'int' allocator 'alloc' keep alive the 'long' memory pool too?\n</code></pre>\n<p><em>At what point exactly</em> can the backing storage pool be freed?</p>\n<p>Or, to put it another way: <em>which allocator shares ownership of which memory pool</em>?</p>\n<p>I had always assumed -- without much second thought -- that allocators of the <strong>same</strong> value type shared ownership of their <em>own</em> memory pools, but now it occurred to me that they may also share ownership of the memory pool behind all <em>rebound</em> allocators as well, even though they manage entirely different types.</p>\n<p>Must allocators of rebound types \"keep alive\" each others' memory pools until <em>all</em> of them are destroyed?</p>\n<p>If the answer is different for C++03 and C++11, please explain both and the difference between them.</p>\n", "Tags": "<c++><c++11><memory-management><allocator>", "OwnerUserId": "541686", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24803430_24846295_1": {"section_id": 6290, "quality": 1.0, "length": 16}}, "n3337": {"so_24803430_24846295_1": {"section_id": 6050, "quality": 1.0, "length": 16}}, "n4659": {"so_24803430_24846295_1": {"section_id": 7797, "quality": 1.0, "length": 16}}}, "24846295": {"ParentId": "24803430", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-07-20T00:41:45.893", "Score": "11", "LastEditorUserId": "576911", "LastEditDate": "2014-07-20T01:07:32.553", "Id": "24846295", "OwnerUserId": "576911", "Body": "<blockquote>\n<p id=\"so_24803430_24846295_0\">Must allocators of rebound types \"keep alive\" each others' memory pools until all of them are destroyed?</p>\n</blockquote>\n<p>The short answer is yes, though admittedly with caveats.  The long answer follows...</p>\n<hr>\n<p>C++11 (and C++14) says [allocator.requirements] that a <code>my_allocator&lt;long&gt;</code> constructed from a <code>my_allocator&lt;int&gt;</code> must be able to delete memory allocated from the <code>my_allocator&lt;int&gt;</code>.  This is expressed in the Allocator requirements table as:</p>\n<pre><code>X a(b);\n</code></pre>\n<p>with the post-condition of:</p>\n<pre><code>Y(a) == b and a == X(b)\n</code></pre>\n<p>As you know, operator== is used to here to mean: two allocators that are equal can deallocate each other's allocated pointers.  Also the table documents that <code>b</code> is an object of type <code>Y</code> where <code>X</code> and <code>Y</code> are allocators related by <code>rebind</code> as you show above.</p>\n<p>Now that alone doesn't nail your exact question, as in your question <code>my_allocator&lt;int&gt;</code> never actually allocates anything.  However another row in this same table goes on to say the following about the allocator's operator==:</p>\n<pre><code>a1 == a2\n</code></pre>\n<p>Post-condition:</p>\n<blockquote>\n<p id=\"so_24803430_24846295_1\">returns true only if storage allocated from each can be deallocated\n  via the other. operator== shall be reflexive, symmetric, and\n  <strong>transitive</strong>, and shall not exit via an exception.</p>\n</blockquote>\n<p>(emphasis is my own)</p>\n<p>Transitive means that if a1 == a2, and a2 == a3, then it is implied that a1 == a3.</p>\n<p>This detail nails your question.  The first temporary <code>my_allocator&lt;long&gt;</code> is copied from <code>alloc</code> and is thus equal to <code>alloc</code>.</p>\n<p>The second temporary <code>my_allocator&lt;long&gt;</code> is also copied from <code>alloc</code>, and is thus also equal to <code>alloc</code>.  And furthermore, because of the transitive property, the two temporary <code>my_allocator&lt;long&gt;</code> must also be equal to one another.</p>\n<p>This doesn't exactly mean that they all have to share the same memory pool.  But it does mean that all three of these allocators must be able to somehow deallocate each other's allocated pointers.  I.e. your example is required to work.</p>\n<p>C++03 lacks the \"transitive\" requirement.  That being said, the addition of \"transitive\" to the C++11 wording was considered to be merely a \"cleanup\" of the C++03 intention, and not a new requirement.  Therefore language lawyers can argue whether or not transitive was required or not in C++98/03, but from a practical standpoint, code better assume that it was, because that was the intent.</p>\n<p>Indeed, C++98/03 also included this \"weasel\" wording (no longer in C++11/14):</p>\n<blockquote>\n<p id=\"so_24803430_24846295_2\">All instances of a given allocator type are required to be\n  interchangeable and always compare equal to each other.</p>\n</blockquote>\n<p>I.e. C++98/03 containers were allowed to assume that all instances (really even rebound instances) were <em>always</em> equal.  Official support for \"stateful\" allocators did not really begin until C++11.</p>\n</hr>", "LastActivityDate": "2014-07-20T01:07:32.553"}});