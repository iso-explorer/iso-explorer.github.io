post_cb({"29455248": {"Body": "<p>I don't know if anyone can name all the rules off the top of their head, so a community wiki may be appropriate.</p>\n<p>The array to pointer conversion occurs in the following contexts. All references are to the C++11 standard.</p>\n<ul>\n<li>As part of an implicit conversion sequence selected by overload resolution<sup>1</sup></li>\n<li>As part of a standard conversion sequence, in contexts where one is allowed\n<ul>\n<li>When initializing an object of non-class type from an array ([dcl.init]/16)<sup>2</sup></li>\n<li>When assigning to an lvalue of non-class type from an array ([expr.ass]/3)</li>\n</ul></li>\n<li>When a prvalue of pointer type is required as the operand to a built-in operator ([expr]/8)\n<ul>\n<li>When subscripting into the array ([expr.sub]/1)</li>\n<li>When dereferencing a pointer ([expr.unary.op]/1)</li>\n<li>With the unary <code>+</code> operator ([expr.unary.op]/7)</li>\n<li>With the binary <code>+</code> operator ([expr.add]/1)</li>\n<li>With the binary <code>-</code> operator ([expr.add]/2)</li>\n<li>With the relational operators ([expr.rel]/1)</li>\n<li>With the equality operators ([expr.eq]/1)</li>\n</ul></li>\n<li>When calling a function, if an argument has array type and is passed to an ellipsis ([expr.call]/7)</li>\n<li>When converting from a pointer to base class to a pointer to derived class ([expr.static.cast]/11)</li>\n<li>In a reinterpret cast to a non-reference type ([expr.reinterpret.cast]/1)</li>\n<li>In a const cast to a non-reference type ([expr.const.cast]/1)</li>\n<li>In the second or third operand of the conditional operator, under certain circumstances ([expr.cond])</li>\n<li>In a template argument, if the corresponding (non-type) template parameter has pointer to object type ([temp.arg.nontype]/5)</li>\n</ul>\n<p>The array to pointer conversion does not occur in the following contexts:</p>\n<ul>\n<li>Where an lvalue (or glvalue) is required\n<ul>\n<li>By the unary <code>&amp;</code> operator ([expr.unary.op]/3)</li>\n<li>In a static cast to reference type ([expr.static.cast]/2, [expr.static.cast]/3)</li>\n<li>In a reinterpret cast to reference type ([expr.reinterpret.cast]/11)</li>\n<li>In a const cast to reference type ([expr.const.cast]/4)</li>\n</ul></li>\n<li>When binding to a reference to the same array type</li>\n<li>In a discarded-value expression ([expr]/10)</li>\n<li>In the operand to <code>sizeof</code> ([expr.sizeof]/4)</li>\n<li>When the second and third operands to the conditional operator have the same array type and are both glvalues of the same value category</li>\n<li>In either operand to the built-in comma operator</li>\n</ul>\n<p><sup>1</sup> This includes the case where an array of <code>T</code> is passed to a function expecting <em>cv</em> <code>T*</code>, <em>cv</em> <code>void*</code>, or <code>bool</code>, when a user-defined conversion requires one of those types, <em>etc.</em></p>\n<p><sup>2</sup> This includes contextual conversions to <code>bool</code> as they occur in <code>if</code> statements and the like.</p>\n", "CreationDate": "2015-04-05T07:51:12.540", "ParentId": "29454806", "CommentCount": "0", "LastEditDate": "2015-04-05T07:57:03.847", "Id": "29455248", "PostTypeId": "2", "LastActivityDate": "2015-04-05T07:57:03.847", "LastEditorUserId": "481267", "CommunityOwnedDate": "2015-04-05T07:51:12.540", "Score": "2", "OwnerUserId": "481267"}, "29454867": {"Id": "29454867", "PostTypeId": "2", "Body": "<p>I know of the following expressions in which an array is not converted/decayed to a pointer.</p>\n<ol>\n<li>When used in a <code>sizeof</code> operator: <code>sizeof(array)</code></li>\n<li>When used in an addressof operator: <code>&amp;array</code></li>\n<li>When used to bind a reference to an array: <code>int (&amp;ref)[3] = array;</code>.</li>\n<li>When deducing the typename to be used for instantiating templates.</li>\n<li>When used in <code>decltype</code>: <code>decltype(array)</code></li>\n</ol>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-04-05T07:06:59.683", "Score": "3", "CreationDate": "2015-04-05T06:46:01.750", "ParentId": "29454806", "CommentCount": "10", "OwnerUserId": "434551", "LastEditDate": "2015-04-05T07:06:59.683"}, "29455004": {"Id": "29455004", "PostTypeId": "2", "Body": "<p>The rule of thumb I work by is \"in any part of an expression that produces a value result that can be stored in a pointer but cannot be stored in an array\".</p>\n<p>So, for example;</p>\n<ul>\n<li>The expression <code>array + 0</code> converts <code>array</code> to a pointer before doing the addition, and gives a result that is a pointer.</li>\n<li><code>f(array)</code> converts <code>array</code> to a pointer before calling the function <code>f()</code> that accepts a pointer or an array (not a reference).</li>\n<li><code>array[0]</code> is not required to convert <code>array</code> to a pointer (but the\ncompiler is free to, since it makes no difference on the result of that expression).</li>\n<li><code>sizeof array</code> does not convert <code>array</code> to a pointer (since it doesn't\nevaluate <code>array</code> at all, just its size)</li>\n<li>The expression <code>p = array</code> converts <code>array</code> to a pointer and that value\nis stored in <code>p</code></li>\n</ul>\n<p>I'm sure there are some cases I've missed, but that simple rule works reasonably well.   Of course, it is based on an understanding of what an expression is.....</p>\n", "LastEditorUserId": "4706785", "LastActivityDate": "2015-04-05T07:34:25.077", "Score": "1", "CreationDate": "2015-04-05T07:10:03.880", "ParentId": "29454806", "CommentCount": "3", "OwnerUserId": "4706785", "LastEditDate": "2015-04-05T07:34:25.077"}, "29454806": {"ViewCount": "121", "Body": "<p>Consider the following simple example computing lenght of an array:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint a[] = {1, 2, 4};\n\nint main(){ std::cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; std::endl; }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/36a1d02c7feff41c\" rel=\"nofollow\">DEMO</a></p>\n<p>The Standard <code>N4296::8.3.4/7 [dcl.array]</code></p>\n<blockquote>\n<p id=\"so_29454806_29454806_0\">If E is an n-dimensional array of rank i\u00d7j\u00d7. . .\u00d7k, then E appearing\n  in an expression that <em>is</em> subject to the array-to-pointer conversion\n  (4.2) is converted to a pointer to an (n\u22121)-dimensional array with\n  rank j \u00d7. . .\u00d7k.</p>\n</blockquote>\n<p><code>N4296::4.2/1 [conv.array]</code></p>\n<blockquote>\n<p id=\"so_29454806_29454806_1\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound\n  of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result\n  is a pointer to the first element of the array.</p>\n</blockquote>\n<p>So what is the expressions which are the subject of the convertion? Looks like unevaluated operands are not the subject.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/36a1d02c7feff41c\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/36a1d02c7feff41c</a></p>\n", "AcceptedAnswerId": "29454867", "Title": "When are arrays converted to pointers?", "CreationDate": "2015-04-05T06:36:56.770", "Id": "29454806", "CommentCount": "8", "LastEditDate": "2015-04-05T13:54:46.290", "PostTypeId": "1", "LastEditorUserId": "1968182", "LastActivityDate": "2015-04-05T13:54:46.290", "Score": "0", "OwnerUserId": "3663882", "Tags": "<c++><arrays><pointers><c++14>", "AnswerCount": "4"}, "29454888": {"Id": "29454888", "PostTypeId": "2", "Body": "<p>In your example code, <code>a[0]</code> is identical to <code>*(a + 0)</code>, and is thus subject to array-to-pointer conversion. See the <strong>Built-in subscript operator</strong> section <a href=\"http://en.cppreference.com/w/cpp/language/operator_member_access\" rel=\"nofollow\">here</a>.</p>\n", "LastActivityDate": "2015-04-05T06:48:08.397", "CommentCount": "2", "CreationDate": "2015-04-05T06:48:08.397", "ParentId": "29454806", "Score": "-2", "OwnerUserId": "1348273"}, "bq_ids": {"n4140": {"so_29454806_29454806_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3234}, "so_29454806_29454806_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}}, "n3337": {"so_29454806_29454806_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_29454806_29454806_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3107}}, "n4659": {"so_29454806_29454806_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_29454806_29454806_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3991}}}});