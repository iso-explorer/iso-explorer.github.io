post_cb({"25902512": {"CommentCount": "4", "AcceptedAnswerId": "25902625", "CreationDate": "2014-09-18T00:46:38.930", "LastActivityDate": "2014-09-18T01:49:20.363", "PostTypeId": "1", "ViewCount": "1724", "FavoriteCount": "4", "Title": "why the size of array as a constant variable is not allowed in C but allowed in C++?", "Id": "25902512", "Score": "5", "Body": "<p>I tried to write a c program as below?</p>\n<pre><code>const int x = 5;\n\nint main()\n{\n    int arr[x] = {1, 2, 3, 4, 5};\n}\n</code></pre>\n<p>This is giving warnings when I tried to compile with gcc as below.</p>\n<p>simple.c:9: error: variable-sized object may not be initialized.</p>\n<p>But the same is allowed in C++. When I pass x as array size, why x is not treated as constant?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "3137388", "AnswerCount": "4"}, "25902558": {"ParentId": "25902512", "CommentCount": "0", "Body": "<p>I will assume you are using a C99 compiler (which supports dynamically sized arrays).\nWhat happens is that the compiler can't know for sure in compilation time how your array will behave regarding memory.</p>\n<p>Try this:</p>\n<pre><code>int arr[x];\nmemset( arr, 0, x*sizeof(int) );\n</code></pre>\n<p>and see if it works.</p>\n<p>Another thing I think could be causing this is that const does not really mean anything under the hood, and so the compiler might not let you do what you are trying to because of that. You see, there are several ways you can alter const variables, and that is part of why c#, for example, does not present the const keyword.\nconst is more like an alert for humans than anything else.</p>\n", "OwnerUserId": "1836773", "PostTypeId": "2", "Id": "25902558", "Score": "0", "CreationDate": "2014-09-18T00:55:33.887", "LastActivityDate": "2014-09-18T00:55:33.887"}, "bq_ids": {"n4140": {"so_25902512_25902703_3": {"section_id": 4706, "quality": 0.6153846153846154, "length": 8}, "so_25902512_25902703_5": {"section_id": 3228, "quality": 0.8518518518518519, "length": 23}, "so_25902512_25902703_1": {"section_id": 4706, "quality": 0.5333333333333333, "length": 8}}, "n3337": {"so_25902512_25902703_3": {"section_id": 3101, "quality": 0.5384615384615384, "length": 7}, "so_25902512_25902703_5": {"section_id": 3101, "quality": 0.7777777777777778, "length": 21}, "so_25902512_25902703_1": {"section_id": 4515, "quality": 0.5333333333333333, "length": 8}}, "n4659": {"so_25902512_25902703_3": {"section_id": 6103, "quality": 0.6153846153846154, "length": 8}, "so_25902512_25902703_5": {"section_id": 3985, "quality": 0.8888888888888888, "length": 24}, "so_25902512_25902703_1": {"section_id": 6103, "quality": 0.5333333333333333, "length": 8}}}, "25902625": {"ParentId": "25902512", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C <code>const</code> doesn't mean \"constant\" (i.e., evaluable at compile time). It merely means <em>read-only</em>.</p>\n<p>For example, within a function, this:</p>\n<pre><code>const int r = rand();\nconst time_t now = time(NULL);\n</code></pre>\n<p>is perfectly valid.</p>\n<p>The name of an object defined as <code>const int</code> is not a <em>constant expression</em>. That means that (in C prior to C99, and in all versions of C++) it can't be used to define the length of an array.</p>\n<p>Although C99 (and, optionally, C11) support <em>variable-length arrays</em> (VLAs), they can't be initialized. In principle, the compiler doesn't know the size of a VLA when it's defined, so it can't check whether an initializer is valid. In your particular case, the compiler quite probably is able to figure it out, but the language rules are designed to cover the more general case.</p>\n<p>C++ is <em>nearly</em> the same, but C++ has a special rule that C lacks: if an object is defined as <code>const</code>, and its initialization is a constant expression, then the name of the object it itself a constant expression (at least for integral types).</p>\n<p>There's no really good reason that C hasn't adopted this feature.  In C, if you want a name constant of an integer type, the usual approach is to use a macro:</p>\n<pre><code> #define LEN 5\n ...\n int arr[LEN] = {1, 2, 3, 4, 5};\n</code></pre>\n<p>Note that if you change the value of <code>LEN</code>, you'll have to re-write the initializer.</p>\n<p>Another approach is to use an anonymous <code>enum</code>:</p>\n<pre><code> enum { LEN = 5 };\n ...\n int arr[LEN] = {1, 2, 3, 4, 5};\n</code></pre>\n<p>The name of an enumeration constant is actually a constant expression.  In C, for historical reasons, it's always of type <code>int</code>; in C++ it's of the enumeration type. Unfortunately, this trick only works for constants of type <code>int</code>, so it's restricted to values in the range from <code>INT_MIN</code> to <code>INT_MAX</code>.</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2014-09-18T01:13:03.200", "Id": "25902625", "Score": "10", "CreationDate": "2014-09-18T01:04:00.543", "LastActivityDate": "2014-09-18T01:13:03.200"}, "25902578": {"ParentId": "25902512", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25902512_25902578_0\">When I pass x as array size, why x is not treated as constant?</p>\n</blockquote>\n<p>Because in C, constant expressions can't involve the values of any variables, even <code>const</code> ones. (This is one reason why C is so dependent on macro constants, whereas C++ would use <code>const</code> variables for the same purpose.)</p>\n<p>On the other hand, in C++, <code>x</code> would certainly be a constant expression if <code>x</code> is declared as <code>const int x = 5;</code>.</p>\n<p>If your question is <em>why</em> C++ is so much more liberal than C when it comes to constant expressions, I think it's to support metaprogramming, and allow complex computation to be performed at compile time using templates.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "25902578", "Score": "4", "CreationDate": "2014-09-18T00:58:22.470", "LastActivityDate": "2014-09-18T00:58:22.470"}, "25902703": {"ParentId": "25902512", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I think almost everyone has misunderstood the error, the error says:</p>\n<blockquote>\n<p id=\"so_25902512_25902703_0\">variable-sized object may not be initialized.</p>\n</blockquote>\n<p>which is correct, C99 and C11(<em>although they are optional in C11</em>). They can not be initialized in the declaration, we can see this from section <code>6.7.8</code> <em>Initialization</em>:</p>\n<p>It is treated as a VLA because unlike C++, C expect an <em>integer constnt expression</em>:</p>\n<blockquote>\n<p id=\"so_25902512_25902703_1\">If the size is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type;</p>\n</blockquote>\n<p>and an integer constant expression has the following restrictions:</p>\n<blockquote>\n<p id=\"so_25902512_25902703_2\">shall have integer type and shall only have operands\n  that are integer constants, enumeration constants, character constants, sizeof\n  expressions whose results are integer constants, and floating constants that are the\n  immediate operands of casts. Cast operators in an integer constant expression shall only\n  convert arithmetic types to integer types, except as part of an operand to the sizeof\n  operator.</p>\n</blockquote>\n<p>which <code>x</code> does not satisfy.</p>\n<blockquote>\n<p id=\"so_25902512_25902703_3\">The type of the entity to be initialized shall be an array of unknown size or an object type\n  that is not a variable length array type.</p>\n</blockquote>\n<p>In C++ this is not a variable length array since <code>x</code> is considered a <em>constant expression</em> and we can this is valid from the draft C++ standard section <code>8.3.4</code> <em>Arrays</em> under section <code>8</code> <em>Declarators</em> which says:</p>\n<blockquote>\n<p id=\"so_25902512_25902703_4\">In a declaration T D where D has the form</p>\n<pre><code> D1 [ constant-expressionopt] attribute-specifier-seqopt\n</code></pre>\n<p id=\"so_25902512_25902703_5\">[...]If the constant-expression (5.19)\n  is present, it shall be a converted constant expression of type\n  std::size_t and its value shall be greater than zero. The constant\n  expression specifies the bound of (number of elements in) the array.\n  If the value of the constant expression is N, the array has N elements\n  numbered 0 to N-1[...]</p>\n</blockquote>\n<p>If we removed the <em>const</em> from the declaration of <code>x</code> it would fail for one of two reasons, either the compiler supports VLA as an extension and it would fail for the same reason it fails in C or the compiler does not support VLA as an extension and the therefore the declaration would not be valid.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-09-18T01:49:20.363", "Id": "25902703", "Score": "3", "CreationDate": "2014-09-18T01:15:10.207", "LastActivityDate": "2014-09-18T01:49:20.363"}});