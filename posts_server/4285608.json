post_cb({"bq_ids": {"n4140": {"so_4285608_4285641_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 3294}}, "n3337": {"so_4285608_4285641_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 3164}}, "n4659": {"so_4285608_4285641_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 4056}}}, "4285641": {"Id": "4285641", "PostTypeId": "2", "Body": "<p>You can't : a return by value is an <em>implicit</em> copy construction. Here, the return attempts to implicitly copy your explicitly copy-constructed temporary.</p>\n<p>From 8.5/12 :</p>\n<blockquote>\n<p id=\"so_4285608_4285641_0\">The initialization that occurs in\n  argument passing, <strong>function return</strong>,\n  throwing an exception (15.1), handling\n  an exception (15.3), and\n  brace-enclosed initializer lists\n  (8.5.1) is called copy-initialization\n  and is equivalent to the form :</p>\n<p id=\"so_4285608_4285641_1\"><code>T x = a;</code></p>\n</blockquote>\n", "LastEditorUserId": "451980", "LastActivityDate": "2010-11-26T13:30:07.380", "Score": "5", "CreationDate": "2010-11-26T13:23:36.130", "ParentId": "4285608", "CommentCount": "4", "OwnerUserId": "451980", "LastEditDate": "2010-11-26T13:30:07.380"}, "4285785": {"Id": "4285785", "PostTypeId": "2", "Body": "<pre><code>return Hugo(hugo); \n</code></pre>\n<p>this just creates one additional copy <em>before</em> returning. The actual return statement then takes that copy and copies it <em>again</em>. The entire point in the copy constructor is that it can be used implicitly, whenever we or the compiler need an object copied.</p>\n<p>If you you want an explicit syntax, you can just add a <code>Clone()</code> or <code>Copy()</code> function to the class, but it can't replace the copy constructor.</p>\n<p>Every time the compiler needs to copy an object (for example when passing it by value as a function parameter, or when returning it from a function), it needs to create a copy of the object. There is no way that you can do it for the compiler, because you don't see the \"transition\" code between caller and callee. You can copy the object around <em>inside the called function</em>, or outside it, but you have no way of copying from the callee's body to the caller. Only the compiler can do that, and in order to do that, it needs to be able to copy the object <em>at will</em> -- which is done through the copy constructor.</p>\n", "LastActivityDate": "2010-11-26T13:42:32.533", "CommentCount": "0", "CreationDate": "2010-11-26T13:42:32.533", "ParentId": "4285608", "Score": "1", "OwnerUserId": "33213"}, "4285608": {"ViewCount": "317", "Body": "<p>I'm looking for a syntax like this:</p>\n<pre><code>class Hugo\n{\n    Hugo();\n    explicit Hugo( const Hugo&amp; hugo );\n\n    Hugo GetRandomHugo()\n    {\n        Hugo hugo;\n        hugo.value = rand();\n                                  // this would fail:\n                                  //    return hugo;\n\n        return Hugo(hugo);        // explicit copy!!\n    }\n};</code></pre>\n<p>In other words: I'm looking for a explicit copy syntax, to allow methods to return a copy, even if my copy constructor is explicit.</p>\n<p>I'm using GCC 4.4.5.</p>\n<p>Thanks a lot,</p>\n<p>Charly</p>\n", "Title": "Is there a explicit copy", "CreationDate": "2010-11-26T13:19:16.483", "LastActivityDate": "2010-11-26T13:58:14.140", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-11-26T13:27:05.920", "LastEditorUserId": "521410", "Id": "4285608", "Score": "2", "OwnerUserId": "521410", "Tags": "<c++><gcc><explicit-constructor>", "AnswerCount": "3"}, "4285803": {"Id": "4285803", "PostTypeId": "2", "Body": "<p>You can work around this by having an explicit <code>HugoCopy</code> class like the following</p>\n<pre><code>class HugoCopy;\nclass Hugo {\npublic:\n    Hugo() { ... }  \n    Hugo(HugoCopy const&amp;);\n    explicit Hugo(Hugo const&amp;) { ... }\n};\n\nstruct HugoCopy { \n    HugoCopy(Hugo const&amp; hugo) \n      :hugo(hugo)\n    { }\n\n    Hugo const&amp; hugo;\n};\n\nHugo::Hugo(HugoCopy const&amp;) { ... }\n</code></pre>\n<p>Now the following semantics apply</p>\n<pre><code>Hugo a;\nHugo b = a; // forbidden\nHugo c(a); // allowed\nHugo d = HugoCopy(a); // allowed\n\nHugo f() {\n  Hugo a;\n  return a; // forbidden\n  return HugoCopy(a); // allowed\n}\n</code></pre>\n<p>Alternatively, you can use a conversion function</p>\n<pre><code>class Hugo {\npublic:\n    Hugo() { ... }  \n    explicit Hugo(Hugo const&amp;) { ... }\n};\n\nstruct HugoCopy { \n    HugoCopy(Hugo const&amp; hugo) \n      :hugo(hugo)\n    { }\n    operator Hugo const&amp;() { return hugo; }\n\nprivate:\n    Hugo const&amp; hugo;\n};\n</code></pre>\n<p>This relies on a subtle corner of the C++ language. So if you use this, you better know what you're doing or you don't do it: It first calls the conversion function on HugoCopy (or in the first case, the constructor of <code>Hugo</code>) to get a <code>Hugo</code> / <code>Hugo const&amp;</code>, and then it <em>direct initializes</em> the destination <code>Hugo</code> object with that <code>Hugo</code> object. GCC doesn't like the code, but Clang and Comeau/EDG accept it according to the above semantics. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-11-26T13:58:14.140", "Score": "3", "CreationDate": "2010-11-26T13:45:28.807", "ParentId": "4285608", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2010-11-26T13:58:14.140"}});