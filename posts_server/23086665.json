post_cb({"23088522": {"ParentId": "23086665", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to C++ standard:</p>\n<blockquote>\n<p id=\"so_23086665_23088522_0\"><strong>\u00a723.6.3.1 <code>queue</code> definition</strong></p>\n<p id=\"so_23086665_23088522_1\">Any sequence container supporting operations <code>front()</code>, <code>back()</code>, <code>push_back()</code> and <code>pop_front()</code> can be used to instantiate queue. <strong>In particular, list (23.3.5) and deque (23.3.3) can be used.</strong></p>\n</blockquote>\n<p>You can see that, no matter <code>queue</code> uses <code>list</code> or <code>deque</code> internally, data are not contiguous. So it will be fine as long as you have enough available memory. </p>\n<p>In addition, it will probably be fine even if you do not currently have enough memory as long as the supercomputer has virtual memory; i.e. quite pages of the <code>queue</code> will be moved to disk as required (thanks to @LokiAstari).</p>\n", "OwnerUserId": "2589776", "LastEditorUserId": "2589776", "LastEditDate": "2014-04-15T15:55:34.660", "Id": "23088522", "Score": "0", "CreationDate": "2014-04-15T15:45:31.817", "LastActivityDate": "2014-04-15T15:55:34.660"}, "23086665": {"CommentCount": "11", "ViewCount": "218", "PostTypeId": "1", "LastEditorUserId": "1810751", "CreationDate": "2014-04-15T14:28:06.100", "LastActivityDate": "2014-04-16T00:20:34.880", "Title": "3 million elements in STL C++ Queue", "FavoriteCount": "1", "LastEditDate": "2014-04-16T00:20:34.880", "Id": "23086665", "Score": "0", "Body": "<p>I am trying to implement BFS on a graph with 3 million nodes. If I use the STL C++ Data structure Queue, will there be a problem if I insert 3 million elements ?</p>\n<p>Assume I will run it on a supercomputing cluster with 48 GB of memory. Each node is an <code>int</code> data type so we will not need anymore than 3*10<sup>6</sup>*8 = 2.4x10<sup>7</sup> = 24 MB of memory, right?</p>\n", "Tags": "<c++><stl><queue>", "OwnerUserId": "1810751", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23086665_23088522_1": {"section_id": 1097, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_23086665_23088522_1": {"section_id": 1094, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_23086665_23088522_1": {"section_id": 1187, "quality": 0.8333333333333334, "length": 15}}}, "23088936": {"ParentId": "23086665", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I am not sure why you didn't check it by yourself. </p>\n<p>Fast look at <a href=\"http://en.cppreference.com/w/cpp/container/queue\" rel=\"nofollow noreferrer\">queue</a> says, that default container is <a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow noreferrer\">deque</a>, which in turn has a method called <a href=\"http://en.cppreference.com/w/cpp/container/deque/max_size\" rel=\"nofollow noreferrer\">max_size</a>, where you can check for implementational limits.</p>\n<p>The other limit is run-time memory available. You calculated the amount of memory needed to store all the data in a continuous block. I am afraid that <code>deque</code> does not do it, thus some overhead might be introduced for every element. (Interesting read (IMO) on what happens when too much pointer inderections are used is here: <a href=\"https://stackoverflow.com/questions/22932260/eigen-library-memory-usage-for-dynamic-vectors\">Eigen library memory usage for dynamic vectors</a>.)</p>\n<p>I don't think there is any other way to check it, other than testing it. There is too much implementational details that might come along the way. From the standard's point of view, I think the only sure limiting factor is the <code>max_size</code>, though it probably is not very useful (avaiable RAM will be the lower bound most probably).</p>\n<p>Here you have a simple program that you can test:</p>\n<pre><code>#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n\ntypedef int64_t Type;\nint main(){\n  std::srand(std::time(0));\n  const size_t N = 3*1000*1000;\n  std::deque&lt;Type&gt; d;\n  std::generate_n(std::inserter(d,d.begin()), N, std::rand);\n\n  std::queue&lt;Type&gt; q(std::move(d));\n\n  std::cout &lt;&lt; sizeof(Type) &lt;&lt; '\\n';\n  std::cout &lt;&lt; sizeof(Type)*N &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n<p>Sample run through <code>valgrind</code> yields:</p>\n<pre><code>8\n24000000\n==6992== \n==6992== HEAP SUMMARY:\n==6992==     in use at exit: 0 bytes in 0 blocks\n==6992==   total heap usage: 46,892 allocs, 46,892 frees, 24,656,264 bytes allocated\n</code></pre>\n<p>Which means there is no significant overhead.</p>\n", "OwnerUserId": "1133179", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:05:09.013", "Id": "23088936", "Score": "0", "CreationDate": "2014-04-15T16:04:31.963", "LastActivityDate": "2014-04-15T16:18:02.493"}});