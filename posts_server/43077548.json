post_cb({"43078625": {"ParentId": "43077548", "CommentCount": "2", "Body": "<p>You can always attempt to make a type with arbitrary (valid) alignment <code>N</code>:</p>\n<pre><code>template &lt;std::size_t N&gt; struct X { alignas(N) char c; };\n</code></pre>\n<p>When <code>N</code> is greater than the default alignment, <code>X</code> has extended alignment. The support for extended alignment is implementation-defined, and [dcl.align] says:</p>\n<blockquote>\n<p id=\"so_43077548_43078625_0\">if the constant expression does not evaluate to an alignment value (6.11), or evaluates to an extended\n  alignment and the implementation does not support that alignment in the context of the declaration, the program is ill-formed.</p>\n</blockquote>\n<p>Therefore, when you attempt to say <code>X&lt;N&gt;</code> for an extended alignment that is not supported, you will face a diagnostic. You can now use the existence (or otherwise) of <code>X&lt;N&gt;</code> to justify the validity of the specialization <code>aligned_storage&lt;Len, N&gt;</code> (whose condition is now met with <code>T = X&lt;N&gt;</code>).</p>\n<p>Since <code>aligned_storage</code> will effectively use something like <code>X</code> internally, you don't even have to actually define <code>X</code>. It's just a mental aid in the explanation. The <code>aligned_storage</code> will be ill-formed if the requested alignment is not supported.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "43078625", "Score": "1", "CreationDate": "2017-03-28T19:50:08.543", "LastActivityDate": "2017-03-28T19:50:08.543"}, "43077548": {"CommentCount": "6", "ViewCount": "571", "PostTypeId": "1", "LastEditorUserId": "1362568", "CreationDate": "2017-03-28T18:46:08.927", "LastActivityDate": "2017-03-28T19:50:08.543", "Title": "Over-aligned types with std::aligned_storage", "AcceptedAnswerId": "43078625", "LastEditDate": "2017-03-28T19:27:47.817", "Id": "43077548", "Score": "4", "Body": "<p>The C++ standard states, regarding the <code>std::aligned_storage</code> template, that</p>\n<blockquote>\n<p id=\"so_43077548_43077548_0\"><code>Align</code> shall be equal to <code>alignof(T)</code> for some type <code>T</code> or to <em>default-alignment.</em></p>\n</blockquote>\n<p>Does that mean that there must be such a type in the program, or that it must be possible to make such a type? In particular, the <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage#Possible_implementation\" rel=\"nofollow noreferrer\">possible implementation</a> suggested on cppreference is</p>\n<pre><code>template&lt;std::size_t Len, std::size_t Align /* default alignment not implemented */&gt;\nstruct aligned_storage {\n    typedef struct {\n        alignas(Align) unsigned char data[Len];\n    } type;\n};\n</code></pre>\n<p>It seems like this <em>makes</em> a type with that alignment, if possible (that is, if <code>Align</code> is a valid alignment). Is that behavior required, or is it undefined behavior to specify an <code>Align</code> if such a type does not already exist?</p>\n<p>And, perhaps more importantly, is it plausible in practice that the compiler or standard library would fail to do the right thing in this case, assuming that <code>Align</code> is at least a legal alignment for a type to have?</p>\n", "Tags": "<c++><c++11><memory-alignment>", "OwnerUserId": "27302", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43077548_43078625_0": {"section_id": 5533, "quality": 0.7647058823529411, "length": 13}}, "n3337": {"so_43077548_43078625_0": {"section_id": 5319, "quality": 0.7647058823529411, "length": 13}}, "n4659": {"so_43077548_43078625_0": {"section_id": 6969, "quality": 0.9411764705882353, "length": 16}}}});