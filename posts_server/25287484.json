post_cb({"bq_ids": {"n4140": {"so_25287484_25287819_2": {"length": 18, "quality": 1.0, "section_id": 5801}, "so_25287484_25287819_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5809}, "so_25287484_25287484_0": {"length": 9, "quality": 1.0, "section_id": 5809}}, "n3337": {"so_25287484_25287484_0": {"length": 9, "quality": 1.0, "section_id": 5582}, "so_25287484_25287819_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5582}, "so_25287484_25287819_2": {"length": 18, "quality": 1.0, "section_id": 5574}}, "n4659": {"so_25287484_25287484_0": {"length": 9, "quality": 1.0, "section_id": 7270}, "so_25287484_25287819_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7270}, "so_25287484_25287819_2": {"length": 18, "quality": 1.0, "section_id": 7260}}}, "25287819": {"Id": "25287819", "PostTypeId": "2", "Body": "<p>Since \"sequenced before\" (in this instance) only applies to a single thread:</p>\n<blockquote>\n<p id=\"so_25287484_25287819_0\">Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single thread [...]</p>\n<p id=\"so_25287484_25287819_1\">\u00a71.9 [intro.execution]</p>\n</blockquote>\n<p>And since the compiler/CPU can perform whatever transformations they wish provided the code executes as if it followed the standard:</p>\n<blockquote>\n<p id=\"so_25287484_25287819_2\">A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input.</p>\n<p id=\"so_25287484_25287819_3\">\u00a71.9 [intro.execution]</p>\n</blockquote>\n<p>Arbitrary reorderings may (or may not) occur.</p>\n<p>Note that special rules apply between threads.  See \u00a71.10 [intro.multithread].</p>\n", "LastActivityDate": "2014-08-13T13:42:34.027", "CommentCount": "12", "CreationDate": "2014-08-13T13:42:34.027", "ParentId": "25287484", "Score": "8", "OwnerUserId": "1007504"}, "25287484": {"ViewCount": "257", "Body": "<p>I know that generally a modern C++ compiler and processor will perform certain optimizations by sometimes reordering instructions for better performance.</p>\n<p>C++11 introduces a <strong><em>sequenced before</em></strong> relation. And if instruction <code>A</code> comes before instruction <code>B</code> in program order, we say that <code>A</code> is <strong><em>sequenced before</em></strong> <code>B</code>.</p>\n<pre><code>int data = 0;\nbool ready = 0;\n\n// A is sequenced before B\ndata = 6;      // A\nready = true;  // B\n</code></pre>\n<p>C++11 also defines a requirement for <strong><em>sequenced before</em></strong> relation.</p>\n<blockquote>\n<p id=\"so_25287484_25287484_0\">Given any two evaluations A and B, if A is sequenced before B, then\n  the execution of A shall precede the execution of B.</p>\n</blockquote>\n<p>This puzzles me. To me, it conflicts with out-of-order executions because the reordering may break the above required property. E.g., when store to <code>ready</code> happens before store to <code>data</code>.</p>\n<p>Does the definition above stop instruction reordering? (<em>I'm pretty sure it's not. But what did I miss?</em>)</p>\n", "AcceptedAnswerId": "25287819", "Title": "Does sequenced-before relation in C++11 prevent compiler/CPU reordering?", "CreationDate": "2014-08-13T13:25:14.623", "Id": "25287484", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-13T13:49:53.340", "LastEditorUserId": "1007504", "LastActivityDate": "2014-08-13T13:49:53.340", "Score": "7", "OwnerUserId": "419391", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}});