post_cb({"4805892": {"ParentId": "4801136", "CommentCount": "0", "CreationDate": "2011-01-26T14:50:05.400", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "4805892", "Score": "0", "Body": "<p>As you mentioned, gcc doesn't compile the following code.</p>\n<pre><code>struct A {\n  A( int ) {}\n  explicit A( A const&amp; ) {}\n};\n\nint main() {\n  A a = 2;\n}\n</code></pre>\n<p>I think this isn't standard conformant according to current standard 8.5 p15.<br>\nHowever, as for your first case,</br></p>\n<pre><code>struct A {\n  A( int ) {}\n  explicit A( A const&amp; ) {}\n};\n\nstruct B {\n  operator A() { return 2; }\n};\n\nint main() {\n  B b;\n  A a = b;\n}\n</code></pre>\n<p>I'm not convinced that allowing this is conformant.<br>\nAs you may know, <code>return</code> will invoke copying twice conceptually.<br>\n<code>return 2;</code> constructs an <code>A</code> implicitly from an <code>int</code> 2, and it is used to\ndirect-initialize a temporal return-value(R).<br>\nHowever, should direct-initialization be applied to the second copying\nfrom R to <code>a</code>?<br>\nI couldn't find the wording in current standard which explicitly states that\ndirect-initialization should be applied twice.<br>\nSince it is certain that this sequence spoils <code>explicit</code> specification in a\nsense, I'm not surprised even if compiler developers thought allowing this\n is a defect.</br></br></br></br></br></p>\n<p>Let me make an unnecessary addition.<br>\nA compiler's non-conformant behaviour doesn't mean that the compiler has a\n defect directly.<br>\nThe standard already has defects as defect reports show.<br>\nFor example, the C standard doesn't allow the conversion from a pointer to\nan array of type T, to a pointer to an array of <code>const</code> T.<br>\nThis is allowed in C++, and I think it should be allowed semantically in C\nsimilarly.<br>\nGcc issues a warning about this conversion.\nComeau issues an error, and doesn't compile.</br></br></br></br></br></p>\n", "LastActivityDate": "2011-01-26T14:50:05.400"}, "4801211": {"ParentId": "4801136", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2011-01-26T03:38:12.073", "Score": "8", "LastEditorUserId": "187690", "LastEditDate": "2011-01-26T03:59:20.160", "Id": "4801211", "OwnerUserId": "187690", "Body": "<p>You declared your copy constructor <code>explicit</code> (BTW, why?), which means that it can no longer be used for implicit copying of class objects. In order to use this constructor for copying you are now forced to use direct-initialization syntax. See 12.3.1/2</p>\n<blockquote>\n<p id=\"so_4801136_4801211_0\">2 An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote>\n<p>The issue can be illustrated by the following much shorter example</p>\n<pre><code>struct A {\n  A() {}\n  explicit A(const A&amp;) {}\n};\n\nint main() {\n  A a;\n  A b = a; // ERROR: copy-initialization\n  A c(a); // OK: direct-initialization\n}\n</code></pre>\n<p>This is what blocks all of your conversions from working, since all of them rely on copy-initialization, which in turns relies on implicit copying. And you disabled implicit copying.</p>\n<p>Additionally, see the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#152\" rel=\"noreferrer\">Defect Report #152</a> which covers this specific issue. Although I'm not sure what the consequences of the \"proposed resolution\" are supposed to be...</p>\n", "LastActivityDate": "2011-01-26T03:59:20.160"}, "bq_ids": {"n4140": {"so_4801136_4801211_0": {"section_id": 389, "quality": 0.9411764705882353, "length": 16}, "so_4801136_4801136_0": {"section_id": 3296, "quality": 0.9204545454545454, "length": 81}}, "n3337": {"so_4801136_4801211_0": {"section_id": 380, "quality": 0.9411764705882353, "length": 16}, "so_4801136_4801136_0": {"section_id": 3166, "quality": 0.9204545454545454, "length": 81}}, "n4659": {"so_4801136_4801211_0": {"section_id": 406, "quality": 0.9411764705882353, "length": 16}, "so_4801136_4801136_0": {"section_id": 4058, "quality": 0.6818181818181818, "length": 60}}}, "4801136": {"CommentCount": "4", "AcceptedAnswerId": "4801211", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-01-26T03:15:46.797", "LastActivityDate": "2011-01-26T14:50:05.400", "LastEditDate": "2017-05-23T12:04:16.363", "ViewCount": "3878", "FavoriteCount": "1", "Title": "c++ copy initialization & direct initialization, the weird case", "Id": "4801136", "Score": "6", "Body": "<p>Before continue reading this, please read <a href=\"https://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-assignment-initializ\">Is there a difference in C++ between copy initialization and direct initialization?</a> first, make sure you understand what it is talking about.</p>\n<p>I'll summarize the rule here first (read standard n3225 8.5/16, 13.3.1.3, 13.3.1.4, and 13.3.1.5),</p>\n<p>1) For direct initialization, all constructors will be considered as the overloading set, the overloading resolution will select the best one according to the overloading resolution rules.</p>\n<p>2) For copy initialization and the source type is the same as destination type or derived from destination type, the rule is as same as above except that only converting constructors (constructors without explicit) will be considered as the overloading set. This actually means explicit copy/move constructors will not be considered into the overloading set.</p>\n<p>3) For copy initialization cases not included in (2) above (source type is different from destination type and not derived from destination type), we first consider user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof. If the conversion succeeds, the result is used to <strong>direct initialize</strong> the destination object.</p>\n<p>3.1) During this user-defined conversion sequence, both converting ctors (non-explicit ctors) and non-explicit conversion functions will be considered, according to rules in 8.5/16 and 13.3.1.4.</p>\n<p>3.2) The result prvalue will <strong>direct initialize</strong> the destination object, as rules listed in (1), see 8.5/16.</p>\n<p>Okay, enough for rules, let's look at some weird code, which I really have no idea on where my reasoning is wrong, or just all compilers are wrong. Please help me, thanks.</p>\n<pre><code>struct A\n{\n    A (int) { }\n    A() { }\n    explicit A(const A&amp;) { }\n};\nstruct B\n{\n    operator A() { return 2; }\n    //1) visual c++ and clang passes this\n    //gcc 4.4.3 denies this, says no viable constructor available\n};\nint main()\n{\n    B b;\n    A a = b;\n    //2) oops, all compilers deny this\n}\n</code></pre>\n<p>In my understanding, for (1),</p>\n<pre><code>operator A() { return 2; }\n</code></pre>\n<p>Because C++ has a rule that function return is taken as copy-initialization, according to the rule above, 2 will be firstly implicitly converted to A, which should be OK because A has a constructor A(int). Then the converted temporary prvalue will be used to direct-initialize the returned object, which should be OK too because direct-initialization can make use of the explicit copy constructor. So GCC is wrong.</p>\n<p>For (2),</p>\n<pre><code>A a = b;\n</code></pre>\n<p>In my understanding, firstly b is implicitly converted to A, by operator A(), and then the converted value shall be used to direct-initialize a, which can of course call the explicit copy constructor? Thus this should pass compilation and all compilers are wrong?</p>\n<p>Note that for (2), both visual c++ and clang has an error similar to,\n\"Error, cannot convert from B to A\", but if I remove the explicit keyword in the copy constructor of A, the error is gone..</p>\n<p>Thanks for reading.</p>\n<hr>\n<p>edit 1</p>\n<p>Because somebody still didn't get what I meant, I quote the following standard from 8.5/16,</p>\n<blockquote>\n<p id=\"so_4801136_4801136_0\">Otherwise (i.e., for the remaining\n  copy-initialization cases),\n  user-defined conversion sequences that\n  can convert from the source type to\n  the destination type or (when a\n  conversion function is used) to a\n  derived class thereof are enumerated\n  as described in 13.3.1.4, and the best\n  one is chosen through overload\n  resolution (13.3). If the conversion\n  cannot be done or is ambiguous, the\n  initialization is ill-formed. The\n  function selected is called with the\n  initializer expression as its\n  argument; if the function is a\n  constructor, the call initializes a\n  temporary of the cv-unqualified\n  version of the destination type. The\n  temporary is a prvalue. The result of\n  the call (which is the temporary for\n  the constructor case) is then used to\n  direct-initialize, according to the\n  rules above, the object that is the\n  destination of the\n  copy-initialization. In certain cases,\n  an implementation is permitted to\n  eliminate the copying inherent in this\n  direct-initialization by constructing\n  the intermediate result directly into\n  the object being initialized; see\n  12.2, 12.8.</p>\n</blockquote>\n<p>Note that it did mention direct initialize after the user-defined conversion. Which means, in my understanding, the following code shall obey the rules as what I commented, which is confirmed by both clang, coomeau online, visual c++, but GCC 4.4.3 fails both (1) and (2). Although this is a weird rule, but it follows the reasoning from the standard.</p>\n<pre><code>struct A\n{\n    A (int) { }\n    A() { }\n    explicit A(const A&amp;) { }\n};\n\nint main()\n{\n    A a = 2;    //1)OK, first convert, then direct-initialize\n    A a = (A)2; //2)oops, constructor explicit, not viable here!\n}\n</code></pre>\n</hr>", "Tags": "<c++><constructor><copy-constructor><explicit-constructor>", "OwnerUserId": "534498", "AnswerCount": "2"}});