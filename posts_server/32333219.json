post_cb({"bq_ids": {"n4140": {"so_32333219_32333219_0": {"length": 4, "quality": 0.8, "section_id": 3141}, "so_32333219_32333219_2": {"length": 4, "quality": 1.0, "section_id": 3114}, "so_32333219_32333444_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 3132}, "so_32333219_32333444_2": {"length": 14, "quality": 0.875, "section_id": 3147}}, "n3337": {"so_32333219_32333219_0": {"length": 4, "quality": 0.8, "section_id": 3016}, "so_32333219_32333219_2": {"length": 4, "quality": 1.0, "section_id": 2991}, "so_32333219_32333444_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 3007}, "so_32333219_32333444_2": {"length": 14, "quality": 0.875, "section_id": 3022}}, "n4659": {"so_32333219_32333444_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 3894}, "so_32333219_32333444_2": {"length": 13, "quality": 0.8125, "section_id": 3909}, "so_32333219_32333219_2": {"length": 4, "quality": 1.0, "section_id": 3876}, "so_32333219_32333219_0": {"length": 4, "quality": 0.8, "section_id": 3903}}}, "32333219": {"ViewCount": "218", "Body": "<p><strong>General question:</strong> <strong>Is std::shared_future::operator= atomic?</strong></p>\n<p>For example</p>\n<pre><code>struct object {\n    object() {\n        sf = std::async(std::launch::async, &amp;async_func).share(); \n    }\n    void change(){\n        sf = std::async(std::launch::async, &amp;other_async_func).share();\n    }\n    void read(){\n        while (true){ sf.get(); }\n    }\n    std::shared_future&lt;int&gt; sf;\n};\n</code></pre>\n<p><strong>Question Part 1</strong> Is it ok to call <code>std::shared_future::operator=</code> while the left e.g. old <code>shared_future</code> has not been waited on/<em>asynchronous provider</em> still running? Like in <code>object::change()</code>.</p>\n<p><strong>Question Part 2</strong> Is it ok to call <code>std::shared_future::operator=</code> while other <em>asynchronous return objects</em> / threads that are concurrent calling <code>std::shared_future.get()</code>? Like in <code>object::read()</code>?\n<strong>Edit:</strong> Forget <code>object::read()</code>, I mean of course with their own <code>std::shared_future</code> but the same <em>shared state</em>.</p>\n<p>After reading of C++11 draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">N3485</a> \u00a730.6.7:12 </p>\n<blockquote>\n<p id=\"so_32333219_32333219_0\">shared_future&amp; operator=(shared_future&amp;&amp; rhs) noexcept; \n  12 Effects:</p>\n<p id=\"so_32333219_32333219_1\">\u2014 releases any shared state (30.6.4); </p>\n<p id=\"so_32333219_32333219_2\">\u2014 move assigns the contents of rhs to *this</p>\n</blockquote>\n<p><strong>Question Part 1</strong> depends solely on <em>releasing a shared state</em> e.g. after reading of \u00a730.6.4, <em>destroying a shared state</em> so I guess that means, Part 1 <strong>should be true</strong>, but I'm not sure.</p>\n<p><strong>Question Part 2 seems to be false</strong>, because this are 2 steps and I neither don't know if the move part is atomic nor if what happens if the <em>shared state</em> is destroyed while other threads are in <code>shared_future::get()</code></p>\n", "AcceptedAnswerId": "32333444", "Title": "std::shared_future operator= thread safety/ atomic?", "CreationDate": "2015-09-01T13:41:21.923", "Id": "32333219", "CommentCount": "0", "LastEditDate": "2015-09-01T13:52:09.153", "PostTypeId": "1", "LastEditorUserId": "3537677", "LastActivityDate": "2015-09-01T13:52:09.153", "Score": "1", "OwnerUserId": "3537677", "Tags": "<c++><multithreading><c++11><std><future>", "AnswerCount": "1"}, "32333444": {"Id": "32333444", "PostTypeId": "2", "Body": "<p>These are only notes in [futures.shared_future], but they're relevant:</p>\n<blockquote>\n<p id=\"so_32333219_32333444_0\"><em>[ Note:</em> Member functions of shared_future <strong>do not synchronize with themselves</strong>, but they synchronize with\n  the shared shared state. <em>\u2014end note ]</em> </p>\n<p id=\"so_32333219_32333444_1\">[...]</p>\n<pre><code>const R&amp; shared_future::get() const;\nR&amp; shared_future&lt;R&amp;&gt;::get() const;\nvoid shared_future&lt;void&gt;::get() const;\n</code></pre>\n<p id=\"so_32333219_32333444_2\"><em>Note:</em> access to a value object stored in the shared state is <strong>unsynchronized</strong>, so programmers should\n  apply only those operations on <code>R</code> that do not introduce a data race (1.10).</p>\n</blockquote>\n<p>So calling <code>change()</code> is fine as long as nobody is calling <code>read()</code> or otherwise accessing <code>sf</code>.</p>\n", "LastActivityDate": "2015-09-01T13:51:12.810", "CommentCount": "0", "CreationDate": "2015-09-01T13:51:12.810", "ParentId": "32333219", "Score": "1", "OwnerUserId": "2069064"}});