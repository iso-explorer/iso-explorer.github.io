post_cb({"42363605": {"ParentId": "42363040", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>If you read e.g. <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow noreferrer\">this <code>decltype</code> reference</a> you will see</p>\n<blockquote>\n<p id=\"so_42363040_42363605_0\">2) If the argument is an <strong>unparenthesized</strong> id-expression or an <strong>unparenthesized</strong> class member access expression, ...</p>\n<p id=\"so_42363040_42363605_1\">3) If the argument is <strong>any other expression</strong>...</p>\n<p id=\"so_42363040_42363605_2\">...\n  b) if the value category of <em>expression</em> is lvalue, then <code>decltype</code> yields <code>T&amp;</code>;</p>\n</blockquote>\n<p><sub>[Emphasis mine]</sub></p>\n<p>And then a little further down the note</p>\n<blockquote>\n<p id=\"so_42363040_42363605_3\">Note that if the name of an object is parenthesized, it is treated as an ordinary lvalue expression, thus <code>decltype(x)</code> and <code>decltype((x))</code> are often different types. </p>\n</blockquote>\n<p>Because you use a parenthesized expression it is treated as an lvalue, meaning that 3.b above is active and <code>decltype((x))</code> gives you <code>int&amp;</code> if <code>x</code> is <code>int</code>.</p>\n<p>It should be noted that while the reference isn't authoritative it is derived from the specification and generally reliable and correct.</p>\n<hr>\n<p>From the C++11 specification ISO/IEC 14882:2011, section 7.1.6.2 [dcl.type.simple], sub-section 4:</p>\n<blockquote>\n<p id=\"so_42363040_42363605_4\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_42363040_42363605_5\">\u2014 if <code>e</code> is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p>\n<p id=\"so_42363040_42363605_6\">\u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_42363040_42363605_7\">\u2014 otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_42363040_42363605_8\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code></p>\n</blockquote>\n<p>And with an example:</p>\n<blockquote id=\"so_42363040_42363605_9\">\n<pre><code>struct A { double x; };\nconst A* a = new A();\n...\ndecltype((a-&gt;x)) x4 = x3; // type is const double&amp;\n</code></pre>\n</blockquote>\n<p>Basically exactly what the previously linked reference said.</p>\n<p>With your example, <code>e</code> in the specification is <code>(x)</code> (since you have <code>declspec((x))</code>). Now the first case doesn't fit because <code>(x)</code> is not an unparenthesized expression. The second case doesn't fit because <code>(x)</code> isn't an <a href=\"http://en.cppreference.com/w/cpp/language/value_category#xvalue\" rel=\"nofollow noreferrer\">xvalue</a>. The third case matches though, <code>(x)</code> is an lvalue of type <code>int</code>, leading <code>decltype((x))</code> to be <code>int&amp;</code>.</p>\n<p>So the answer to your query is simply: Because the specification says so.</p>\n</hr>", "OwnerUserId": "440558", "LastEditorUserId": "440558", "LastEditDate": "2017-02-21T12:15:15.240", "Id": "42363605", "Score": "1", "CreationDate": "2017-02-21T09:36:09.393", "LastActivityDate": "2017-02-21T12:15:15.240"}, "42363040": {"CommentCount": "3", "ViewCount": "101", "CreationDate": "2017-02-21T09:11:47.800", "LastActivityDate": "2017-02-21T12:15:15.240", "Title": "C++11 why the type of 'decltype(x)' and 'decltype((x))' are different?", "AcceptedAnswerId": "42363605", "PostTypeId": "1", "Id": "42363040", "Score": "2", "Body": "<p>I found they're different, and the language standard says what kind of type each statement should retrieve(difference between variable and expression). But I really wish to know why these 2 kinds of types should be different?</p>\n<pre><code>#include&lt;stdio.h&gt;\nint x=0;\ndecltype((x)) y=x;\nint main()\n{\n    y=2;\n    printf(\"%d,\",x);\n    decltype((1+2))&amp;z=x;//OK (1+2) is an express, but why decltype should differ?\n    z=3;\n    printf(\"%d\\n\",x);\n    return 0;\n}\n</code></pre>\n<p>The running result is '2,3'</p>\n<p>So why decltype((int)) is int&amp; by design, what's the consideration of C++ language design here? Any syntax consistency that requires such a design? (I don't wish to get \"This is by design\")</p>\n<p>Thanks for your explanations.</p>\n", "Tags": "<c++11><variables><types><expression><decltype>", "OwnerUserId": "5890784", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42363040_42363605_5": {"section_id": 5440, "quality": 0.9473684210526315, "length": 18}, "so_42363040_42363605_2": {"section_id": 763, "quality": 0.5714285714285714, "length": 4}, "so_42363040_42363605_7": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_42363040_42363605_4": {"section_id": 5440, "quality": 0.8333333333333334, "length": 5}, "so_42363040_42363605_6": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_42363040_42363605_0": {"section_id": 3260, "quality": 0.75, "length": 6}}, "n3337": {"so_42363040_42363605_5": {"section_id": 5235, "quality": 0.9473684210526315, "length": 18}, "so_42363040_42363605_2": {"section_id": 750, "quality": 0.5714285714285714, "length": 4}, "so_42363040_42363605_7": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_42363040_42363605_4": {"section_id": 5235, "quality": 0.8333333333333334, "length": 5}, "so_42363040_42363605_6": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_42363040_42363605_0": {"section_id": 3132, "quality": 0.75, "length": 6}}, "n4659": {"so_42363040_42363605_4": {"section_id": 6867, "quality": 0.8333333333333334, "length": 5}, "so_42363040_42363605_7": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_42363040_42363605_5": {"section_id": 6867, "quality": 0.9473684210526315, "length": 18}, "so_42363040_42363605_6": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_42363040_42363605_2": {"section_id": 823, "quality": 0.5714285714285714, "length": 4}, "so_42363040_42363605_0": {"section_id": 4018, "quality": 0.75, "length": 6}}}});