post_cb({"3568068": {"Id": "3568068", "PostTypeId": "2", "Body": "<p>Yes and no. </p>\n<p>The language specification explicitly states that it is safe (meaning that in the end you will get the original pointer value) as long as the size of the integral type is sufficient to store the [implementation-dependent] integral representation of the pointer.</p>\n<p>So, in general case it is not \"safe\", since in general case <code>int</code> can easily turn out to be too small. In your specific case it though it might be safe, since your <code>int</code> might be sufficiently large to store your pointer.</p>\n<p>Normally, when you need to do something like that, you should use the <code>intptr_t</code>/<code>uintptr_t</code> types, which are specifically introduced for that purpose. Unfortunately, <code>intptr_t</code>/<code>uintptr_t</code> are not the part of the current C++ standard (they are standard C99 types), but many implementations provide them nevertheless. You can always define these types yourself, of course.</p>\n", "LastActivityDate": "2010-08-25T16:22:44.233", "CommentCount": "0", "CreationDate": "2010-08-25T16:22:44.233", "ParentId": "3567905", "Score": "21", "OwnerUserId": "187690"}, "3567921": {"Id": "3567921", "PostTypeId": "2", "Body": "<p>Absolutely not.  Doing some makes a bad assumption that the size of an <code>int</code> and a pointer are the same.  This is almost always no the case on 64 bit platforms.  If they are not the same a precision loss will occur and the final pointer value will be incorrect.</p>\n<pre><code>MyType* pValue = ...\nint stored = (int)pValue; // Just lost the upper 4 bytes on a 64 bit platform\npValue = (MyType*)stored; // pValue is now invalid \npValue-&gt;SomeOp();  // Kaboom\n</code></pre>\n", "LastActivityDate": "2010-08-25T16:04:46.453", "CommentCount": "0", "CreationDate": "2010-08-25T16:04:46.453", "ParentId": "3567905", "Score": "2", "OwnerUserId": "23283"}, "3568187": {"Id": "3568187", "PostTypeId": "2", "Body": "<p>In general, no; pointers may be larger than <code>int</code>, in which case there's no way to reconstruct the value.</p>\n<p>If an integer type is known to be large enough, then you can; according to the Standard (5.2.10/5):</p>\n<blockquote>\n<p id=\"so_3567905_3568187_0\">A pointer converted to an integer of sufficient size ... and back to the same pointer type will have its original value</p>\n</blockquote>\n<p>However, in C++03, there's no standard way to tell which integer types are large enough. C++11 and C99 (and hence in practice <em>most</em> C++03 implementations), and also Boost.Integer, define <code>intptr_t</code> and <code>uintptr_t</code> for this purpose. Or you could define your own type and assert (preferably at compile time) that it's large enough; or, if you don't have some special reason for it to be an integer type, use <code>void*</code>.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-07-26T13:44:15.260", "Score": "5", "CreationDate": "2010-08-25T16:33:14.667", "ParentId": "3567905", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2013-07-26T13:44:15.260"}, "3567945": {"Id": "3567945", "PostTypeId": "2", "Body": "<p>Is it safe? Not really.</p>\n<p>In most circumstances, will it work? Yes</p>\n<p>Certainly if an <code>int</code> is too small to hold the full pointer value and truncates, you won't get your original pointer back (hopefully your compiler will warn you about this case, with GCC truncating conversions from pointer to integers are hard errors). A <code>long</code>, or <code>uintptr_t</code> if your library supports it, may be better choices.</p>\n<p>Even if your integer type and pointer types are the same size, it will not necessarily work depending on your application runtime. In particular, if you're using a garbage collector in your program it might easily decide that the pointer is no longer outstanding, and when you later cast your integer back to a pointer and try to dereference it, you'll find out the object was already reaped.</p>\n", "LastActivityDate": "2010-08-25T16:08:35.340", "CommentCount": "0", "CreationDate": "2010-08-25T16:08:35.340", "ParentId": "3567905", "Score": "3", "OwnerUserId": "152148"}, "bq_ids": {"n4140": {"so_3567905_17881962_0": {"length": 32, "quality": 0.7111111111111111, "section_id": 6044}, "so_3567905_3568187_0": {"length": 14, "quality": 1.0, "section_id": 6044}}, "n3337": {"so_3567905_17881962_0": {"length": 32, "quality": 0.7111111111111111, "section_id": 5812}, "so_3567905_3568187_0": {"length": 14, "quality": 1.0, "section_id": 5812}}, "n4659": {"so_3567905_17881962_0": {"length": 31, "quality": 0.6888888888888889, "section_id": 7543}, "so_3567905_3568187_0": {"length": 14, "quality": 1.0, "section_id": 7543}}}, "3567920": {"Id": "3567920", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>For instance, on x86-64, a pointer is 64-bit long, but <code>int</code> is only 32-bit long. Casting a pointer to int and back again makes the upper 32-bit of the pointer value lost.</p>\n<p>You may use the <code>intptr_t</code> type in <code>&lt;cstdint&gt;</code> if you want an integer type which is guaranteed to be as long as the pointer. You could safely reinterpret_cast from a pointer to an <code>intptr_t</code> and back. </p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2016-05-25T14:10:38.940", "Score": "35", "CreationDate": "2010-08-25T16:04:40.493", "ParentId": "3567905", "CommentCount": "7", "OwnerUserId": "224671", "LastEditDate": "2016-05-25T14:10:38.940"}, "17390170": {"Id": "17390170", "PostTypeId": "2", "Body": "<p>To an int ? not always if you are on a 64 bit machine then int is only 4 bytes, however pointers are 8 bytes long and thus you would end up with a different pointer when you cast it back from int.</p>\n<p>There are however ways to get around this. You can simply use an 8 byte long data type ,which would work whether or not you are on 32/64 bit system, such as <code>unsigned long long</code> unsigned because you don't want sign extension on 32-bit systems.</p>\n<p>It is important to note that on Linux <code>unsigned long</code> will always be pointer size<sup>*</sup> so if you are targeting Linux systems you could just use that.</p>\n<p>*According to <a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow\">cppreference</a> and also tested it myself but not on all Linux and Linux like systems</p>\n", "LastActivityDate": "2013-06-30T12:03:29.030", "CommentCount": "0", "CreationDate": "2013-06-30T12:03:29.030", "ParentId": "3567905", "Score": "0", "OwnerUserId": "1345339"}, "3567905": {"ViewCount": "10421", "Body": "<p>Is it safe to cast pointer to int and later back to pointer again?</p>\n<p>How about if we know if the pointer is 32 bit long and int is 32 bit long?</p>\n<pre><code>long* juggle(long* p) {\n    static_assert(sizeof(long*) == sizeof(int));\n    int v = reinterpret_cast&lt;int&gt;(p); // or if sizeof(*)==8 choose long here\n    do_some_math(v); // prevent compiler from optimizing\n    return reinterpret_cast&lt;long*&gt;(v);\n}\n\nint main() {\n    long* stuff = new long(42);\n    long* ffuts = juggle(stuff); \n    std::cout &lt;&lt; \"Is this always 42? \" &lt;&lt; *ffuts &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Is this covered by the Standard?</p>\n", "Title": "C++: Is it safe to cast pointer to int and later back to pointer again?", "CreationDate": "2010-08-25T16:02:33.760", "LastActivityDate": "2016-05-25T14:10:38.940", "CommentCount": "13", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-07-26T07:19:24.413", "LastEditorUserId": "472245", "Id": "3567905", "Score": "23", "OwnerUserId": "425541", "Tags": "<c++><pointers>", "AnswerCount": "12"}, "3568066": {"Id": "3568066", "PostTypeId": "2", "Body": "<p>No it is not. Even if we rule out the architecture issue, size of a pointer and an integer have differences. A pointer can be of three types in C++ : near, far, and huge. They have different sizes. And if we talk about an integer its normally of 16 or 32 bit. So casting integer into pointers and vice-verse is not safe. Utmost care has to be taken, as there very much chances of precision loss. In most of the cases an integer will be short of space to store a pointer, resulting in loss of value.</p>\n", "LastEditorUserId": "408333", "LastActivityDate": "2010-08-25T16:27:31.497", "Score": "0", "CreationDate": "2010-08-25T16:22:25.003", "ParentId": "3567905", "CommentCount": "0", "OwnerUserId": "408333", "LastEditDate": "2010-08-25T16:27:31.497"}, "17878386": {"Id": "17878386", "PostTypeId": "2", "Body": "<p><strong>Yes, if...</strong>  (or \"Yes, but...\") and no otherwise.</p>\n<p>The standard specifies (3.7.4.3) the following:</p>\n<ul>\n<li>A pointer value is a safely-derived pointer [...] if it is the result of a well-defined pointer conversion or <code>reinterpret_cast</code> of a safely-derived pointer value [or] the result of a <code>reinterpret_cast</code> of an integer representation of a safely-derived pointer value</li>\n<li>An integer value is an integer representation of a safely-derived pointer [...] if its type is at least as large as <code>std::intptr_t</code> and [...] the result of a <code>reinterpret_cast</code> of a safely-derived pointer value [or]\nthe result of a valid conversion of an integer representation of a safely-derived pointer value [or] the result of an additive or bitwise operation, one of whose operands is an integer representation of a\nsafely-derived pointer value</li>\n<li>A traceable pointer object is [...] <em>an object of an integral type that is at least as large as <code>std::intptr_t</code></em></li>\n</ul>\n<p>The standard further states that implementations <em>may be</em> relaxed or <em>may be</em> strict about enforcing safely-derived pointers. Which means it is unspecified whether using or dereferencing a not-safely-derived pointer invokes undefined behavior (that's a funny thing to say!)</p>\n<p>Which alltogether means no more and no less than \"something different <em>might</em> work anyway, but the only safe thing is as specified above\".</p>\n<p>Therefore, <strong>if</strong> you either use <code>std::intptr_t</code> in the first place (the preferrable thing to do!) or if you know that the storage size of whatever integer type you use (say, <code>long</code>) is at least the size of <code>std::intptr_t</code>, then it is allowable and well-defined (i.e. \"safe\") to cast to your integer type and back. The standard guarantees that.</p>\n<p>If that's not the case, the conversion from pointer to integer representation will probably (or at least possibly) lose some information, and the conversion back will not give a valid pointer. Or, it <em>might</em> by accident, but this is not guaranteed.</p>\n<p>An interesting anecdote is that the C++ standard does not <em>directly</em> define <code>std::intptr_t</code> at all; it merely says <em>\"the same as 7.18 in the C standard\"</em>.</p>\n<p>The C standard, on the other hand, states <em>\"designates a signed integer type with the property that any valid\npointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer\"</em>.<br>\nWhich means, without the rather complicated definitions above (in particular the last bit of the first bullet point), it wouldn't be allowable to convert to/from anything but <code>void*</code>.</br></p>\n", "LastEditorUserId": "572743", "LastActivityDate": "2013-07-26T10:36:00.933", "Score": "21", "CreationDate": "2013-07-26T09:58:48.730", "ParentId": "3567905", "CommentCount": "1", "OwnerUserId": "572743", "LastEditDate": "2013-07-26T10:36:00.933"}, "3568152": {"Id": "3568152", "PostTypeId": "2", "Body": "<p>If your going to be doing any system portable casting, you need to use something like Microsofts <a href=\"http://msdn.microsoft.com/en-us/library/aa383751(VS.85).aspx\" rel=\"nofollow noreferrer\">INT_PTR/UINT_PTR</a>, the safety after that relies on the target platforms and what you intend doing to the INT_PTR. generally for most arithmatic char* or uint_8* works better while being typesafe(ish)</p>\n", "LastActivityDate": "2010-08-25T16:30:23.237", "CommentCount": "5", "CreationDate": "2010-08-25T16:30:23.237", "ParentId": "3567905", "Score": "0", "OwnerUserId": "255049"}, "17881962": {"Id": "17881962", "PostTypeId": "2", "Body": "<p>No, it is <em>not (always)</em> safe (thus not safe in general). And it <em>is</em> covered by the standard.</p>\n<p>ISO C++ 2003, 5.2.10:</p>\n<blockquote id=\"so_3567905_17881962_0\">\n<ol>\n<li>A pointer can be explicitly converted to any integral type <strong>large enough to hold it</strong>. The mapping function is implementation-defined.</li>\n<li>A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to an integer of <strong>sufficient size</strong> (<strong>if any such exists</strong> on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation-defined.</li>\n</ol>\n</blockquote>\n<p>(The above emphases are mine.)</p>\n<p>Therefore, if you know that the sizes are compatible, then the conversion <em>is</em> safe.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// C++03 static_assert.\n#define ASSURE(cond) typedef int ASSURE[(cond) ? 1 : -1]\n\n// Assure that the sizes are compatible.\nASSURE(sizeof (int) &gt;= sizeof (char*));\n\nint main() {\n    char c = 'A';\n    char *p = &amp;c;\n    // If this program compiles, it is well formed.\n    int i = reinterpret_cast&lt;int&gt;(p);\n    p = reinterpret_cast&lt;char*&gt;(i);\n    std::cout &lt;&lt; *p &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2013-07-26T12:59:51.833", "CommentCount": "0", "CreationDate": "2013-07-26T12:59:51.833", "ParentId": "3567905", "Score": "2", "OwnerUserId": "259543"}, "3568043": {"Id": "3568043", "PostTypeId": "2", "Body": "<p>Use uintptr_t from \"stdint.h\" or from \"boost/stdint.h\". It is guaranteed to have enough storage for a pointer.</p>\n", "LastActivityDate": "2010-08-25T16:19:37.540", "CommentCount": "1", "CreationDate": "2010-08-25T16:19:37.540", "ParentId": "3567905", "Score": "0", "OwnerUserId": "412080"}, "17882448": {"Id": "17882448", "PostTypeId": "2", "Body": "<p>If the issue is that you want to do normal math on it, probably the safest thing to do would be to cast it to a pointer to char (or better yet, <code>* uint8_t</code>), do your math, and then cast it back.</p>\n", "LastActivityDate": "2013-07-26T13:22:01.853", "CommentCount": "0", "CreationDate": "2013-07-26T13:22:01.853", "ParentId": "3567905", "Score": "0", "OwnerUserId": "29639"}});