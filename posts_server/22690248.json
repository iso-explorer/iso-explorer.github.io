post_cb({"22690391": {"ParentId": "22690248", "CommentCount": "2", "Body": "<p>Regarding</p>\n<blockquote>\n<p id=\"so_22690248_22690391_0\">\u201cIn a sensible implementation, as long as there's single inheritance, the bits of a Base and Derived pointer would match.\u201d</p>\n</blockquote>\n<p>Yes for simple types, but <strong>no</strong> when base is non-polymorphic and derived introduces some virtual member.</p>\n<p>So, a conversion <code>Derived*</code> to <code>void*</code> and then directly to <code>Base*</code> is Undefined Behavior not just pedantically formally, but also in practice.</p>\n<hr>\n<p>In passing, the special cast <code>dynamic_cast&lt;void*&gt;( p )</code> gives you a pointer to the <em>most derived object</em> if the statically known type of <code>p</code> is pointer to polymorphic object.</p>\n<p>This can be useful for example for use of hash tables like <code>std::unordered_map</code>.</p>\n<hr>\n<p>Also in passing, possibly related to your Real Purpose\u2122, the standard guarantees that a pointer to first member of a POD type can be cast to pointer to that type, and vice versa. This is in support of a C way to emulate inheritance.</p>\n</hr></hr>", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "22690391", "Score": "5", "CreationDate": "2014-03-27T14:19:16.227", "LastActivityDate": "2014-03-27T14:19:16.227"}, "22690339": {"ParentId": "22690248", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strong>Yes</strong>, what you are doing does in fact invoke <em>undefined-behaviour</em>.</p>\n<hr>\n<p>The standard mandates that casting from <code>T*</code> to <code>void*</code> back to <code>T*</code> is guaranteed to be safe, the latter <code>T*</code> will hold the same value as the original <code>T*</code>.</p>\n<blockquote>\n<p id=\"so_22690248_22690339_0\">5.29 <strong>Static cast</strong> <code>[expr.static.cast]</code></p>\n<blockquote>\n<p id=\"so_22690248_22690339_2\"><sup>13</sup> <sub>...</sub> A value of type pointer to object converted to \"pointer to cv void\" and back, possibly with different cv-qualification, shall have its original value.\n    `.</p>\n</blockquote>\n</blockquote>\n<p>The above behaviour guarantees that <code>T * p = static_cast&lt;T*&gt; (static_cast&lt;void*&gt; (some_T_ptr))</code> will yield a value in <code>p</code> such that <code>p == some_p</code>.</p>\n<hr>\n<p>In your example we are however casting from <code>void*</code> to a type related to the original <code>T</code>, but it's not the same exact <code>T</code>; this means that the result of the operation is unspecified.</p>\n<p>The compiler is safe to assume that the address in the <code>void*</code> pointer (<code>pv</code>) originally points to a <code>Base</code> as a result it will not do any offset modifications to properly adjust to the fact that we are going from <code>Derived*</code> to <code>Base*</code>, and not <code>Base*</code> to <code>Base*</code>.</p>\n<p>The compiler can simply copy the value of <code>pv</code> into <code>b</code>, when it really should adjust this value as it is coming from the address of a <code>Derived</code>.</p>\n<pre><code>Derived * pd = &amp;some_derived;\nvoid    * pv = static_cast&lt;void*&gt; (pd);\nBase    * pb = static_cast&lt;Base*&gt; (pv); // unsafe\n</code></pre>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-03-27T14:32:28.683", "Id": "22690339", "Score": "7", "CreationDate": "2014-03-27T14:17:25.010", "LastActivityDate": "2014-03-27T14:32:28.683"}, "22690248": {"CommentCount": "0", "AcceptedAnswerId": "22690391", "PostTypeId": "1", "LastEditorUserId": "219159", "CreationDate": "2014-03-27T14:13:58.420", "LastActivityDate": "2014-04-21T15:57:52.267", "LastEditDate": "2014-04-21T15:57:52.267", "ViewCount": "94", "FavoriteCount": "1", "Title": "Casting to base via void*", "Id": "22690248", "Score": "3", "Body": "<p>Is this undefined behavior?</p>\n<pre><code>class Derived: public Base //No other bases!!!\n{\n//...\n};\n\nDerived d;\nvoid *pv = &amp;d;\nBase *b = static_cast&lt;Base*&gt;(pv);\nb-&gt;SomeMethod();\n</code></pre>\n<p>In a sensible implementation, as long as there's single inheritance, the bits of a <code>Base</code> and <code>Derived</code> pointer would match. But does the language guarantee it?</p>\n<p>EDIT: the Real Purpose\u2122 is to pass a pointer to a polymorphic C++ object through a C layer back to a C++ callback. The object is created as Derived but consumed in the said callback as Base. The full story is <a href=\"http://rathertech.blogspot.com/2014/03/seh-for-fun-and-profit.html\" rel=\"nofollow\">here</a>.</p>\n", "Tags": "<c++>", "OwnerUserId": "219159", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22690248_22690339_2": {"section_id": 6039, "quality": 1.0, "length": 15}, "so_22690248_22690339_1": {"section_id": 6039, "quality": 1.0, "length": 15}}, "n3337": {"so_22690248_22690339_2": {"section_id": 5807, "quality": 1.0, "length": 15}, "so_22690248_22690339_1": {"section_id": 5807, "quality": 1.0, "length": 15}}, "n4659": {"so_22690248_22690339_2": {"section_id": 7543, "quality": 0.6, "length": 9}, "so_22690248_22690339_1": {"section_id": 7543, "quality": 0.6, "length": 9}}}});