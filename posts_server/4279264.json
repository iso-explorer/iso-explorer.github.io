post_cb({"4279313": {"Id": "4279313", "PostTypeId": "2", "Body": "<p>yes, formally an rvalue conversion of indeterminate value is UB (except for <code>unsigned char</code>, originally i wrote \"and variants\" but as i recall the formal caters to 1's complement signed char where possibly minus 0 could be used as trap value)</p>\n<p>i'm too lazy to do the standard paragraph lookup for you, and also to lazy to care about downvotes for that</p>\n<p>however, in practice only a problem on (1) archaic architectures, and perhaps (2) 64-bit systems.</p>\n<p><strong>EDIT</strong>: oops, i now seem to recall a blog posting and associated Defect Report about formal UB for accessing indeterminate char. so perhaps i'll have to actually check the standard, + search DRs. argh, it will have to be later then, now coffee!</p>\n<p><strong>EDIT2</strong>: Johannes Schaub was kind enough to provide this <a href=\"https://stackoverflow.com/questions/3892098/ctor-initializer-self-initialization-causes-crash/3892209#3892209\">link to SO question</a> where that UB for accessing char was discussed. So, that's where I remembered it from! Thanks, Johannes.</p>\n<p>cheers &amp; hth.,</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-11-25T17:11:08.997", "Score": "4", "CreationDate": "2010-11-25T16:54:10.190", "ParentId": "4279264", "CommentCount": "8", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T11:53:21.420"}, "23429477": {"Id": "23429477", "PostTypeId": "2", "Body": "<p>The answer to this question changes with the latest C++1y working draft(<code>N3946</code>) which we can find <a href=\"https://github.com/cplusplus/draft/tree/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers\" rel=\"nofollow noreferrer\">here</a>. Section <code>8.5</code> <em>Initializers</em> paragraph <em>12</em> changes a lot from C++03 and C++11 and now contains the following (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_4279264_23429477_0\">If no initializer is specified for an object, the object is\n  default-initialized. <strong>When storage for an object with automatic or\n  dynamic storage duration is obtained, the object has an</strong> <em>indeterminate\n  value</em>, and if no initialization is performed for the object, that\n  object retains an indeterminate value until that value is replaced\n  (5.17). [ Note: Objects with static or thread storage duration are\n  zero-initialized, see 3.6.2. \u2014 end note ] <strong>If an indeterminate value is\n  produced by an evaluation, the behavior is undefined except in the\n  following cases</strong>:</p>\n</blockquote>\n<p>and goes on to list some exceptions for <em>unsigned narrow character type</em> only, I have a complete quote in <a href=\"https://stackoverflow.com/questions/23415661/has-c1y-changed-with-respect-to-the-use-of-indeterminate-values-and-undefined\">Has C++1y changed with respect to the use of indeterminate values and undefined behavior?</a>.</p>\n<p>So in your case <code>b</code> has automatic storage duration and is not initialized and therefore has indeterminate value. So evaluating <code>b[0]</code> is indeed undefined behavior. </p>\n<p>Previously we were required to use the lvalue-to-rvalue conversion to prove this was undefined but that is problematic since <a href=\"https://stackoverflow.com/questions/14991219/what-is-the-value-category-of-the-operands-of-c-operators-when-unspecified\">the conversion is underspecified</a>.</p>\n<p>Note that indeterminate value is italicized in this section and therefore it means it is being defined in place and so now C++1y actually defines the term. Previously the term was used without a definition, this is covered in <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#616\" rel=\"nofollow noreferrer\">defect report 616</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-03T02:35:52.897", "Score": "4", "CreationDate": "2014-05-02T13:34:25.950", "ParentId": "4279264", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:00:17.993"}, "37090849": {"Id": "37090849", "PostTypeId": "2", "Body": "<p>The fact that reading an Indeterminate Value generally results in Undefined Behavior is not merely a \"theoretical\" issue.  Even for types where all possible bit patterns have defined values, it should not be considered \"surprising\" for indeterminate values to behave in ways which differ from Unspecified values.  For example, if *p holds Indeterminate Value, and x is not used anywhere except\nas shown, the code:</p>\n<pre><code>uint32_t x,y,z;\n...\nx = *p;\nif (condition1) y=x;\n... code that \"shouldn't\" affect *p if its value is defined\nif (condition2) z=x;\n</code></pre>\n<p>could be rewritten as:</p>\n<pre><code>if (condition1) y=*p;\n... code that \"shouldn't\" affect *p if its value is defined\nif (condition2) z=*p;\n</code></pre>\n<p>If the value of *p is Indeterminate, a compiler would not be forbidden\nfrom having the code between the two \"if\" statements modify its value.\nFor example, if the storage occupied by *p was occupied by a \"float\"\nbefore it freed and re-malloc'ed, the compiler might write that \"float\"\nvalue between the two \"if\" statements above.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2016-05-09T19:45:47.963", "Score": "0", "CreationDate": "2016-05-07T16:17:10.113", "ParentId": "4279264", "CommentCount": "0", "OwnerUserId": "363751", "LastEditDate": "2016-05-09T19:45:47.963"}, "bq_ids": {"n4140": {"so_4279264_23429477_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 3291}, "so_4279264_4279901_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 7215}, "so_4279264_4279901_0": {"length": 6, "quality": 1.0, "section_id": 7215}}, "n3337": {"so_4279264_4279901_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6959}, "so_4279264_4279901_0": {"length": 6, "quality": 1.0, "section_id": 6959}}, "n4659": {"so_4279264_23429477_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 4053}, "so_4279264_4279901_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 8724}, "so_4279264_4279901_0": {"length": 6, "quality": 1.0, "section_id": 8724}}}, "4279901": {"Id": "4279901", "PostTypeId": "2", "Body": "<p>On <code>bool</code>, the standard says under <strong>3.9.1 Fundamental types</strong>:</p>\n<blockquote>\n<p id=\"so_4279264_4279901_0\">Values of type bool are either true or\n  false.</p>\n</blockquote>\n<p>With a footnote stating:</p>\n<blockquote>\n<p id=\"so_4279264_4279901_1\">Using a bool value in ways described\n  by this International Standard as\n  <strong>\u201cundefined,\u201d</strong> such as by examining the\n  value of an uninitialized automatic\n  object, might cause it to behave <strong>as if\n  it is neither true nor false.</strong></p>\n</blockquote>\n", "LastActivityDate": "2010-11-25T18:22:45.287", "CommentCount": "0", "CreationDate": "2010-11-25T18:22:45.287", "ParentId": "4279264", "Score": "3", "OwnerUserId": "155693"}, "4279264": {"ViewCount": "1186", "Body": "<p>The question arose in the comments of an answer to the question <a href=\"https://stackoverflow.com/questions/4276207/is-c-c-bool-type-always-guaranteed-to-be-0-or-1-when-typecasted-to-int/4276293#4276293\">Is C/C++ bool type always guaranteed to be 0 or 1 when typecast'ed to int?</a></p>\n<p>The code in question allocates a (local) array of <code>bool</code> without initializing their value. </p>\n<pre><code>const int n = 100;\nbool b[n];\n</code></pre>\n<p>Clearly the values in <code>b</code> are indeterminate. </p>\n<p>Some of the commenters opined that reading e.g. <code>b[0]</code> was undefined behavior. Is this stated anywhere in the C++ standard? I am still convinced of the opposite:</p>\n<ol>\n<li><p>There is clearly storage allocated and initialization of the fundamental bool type is complete, since it doesn't have a constructor. It is thus certainly not the same as dereferencing an uninitialized pointer, or calling methods/cast operators on uninitialized non-trivial objects. These specific cases seem to be covered by the standard. </p></li>\n<li><p>The behavior is indeed undefined in C: <a href=\"https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value\">What happens to a declared, uninitialized variable in C? Does it have a value?</a> and some respondents seem to confuse the two. </p></li>\n<li><p>In the latest C++0x draft I can find no definition of <em>indeterminate value</em> especially no definition that would allow accessing such a value to trigger a processor trap. Indeed, Bjarne Stroustrup is not sure what an inderminate value may be: <a href=\"http://zamanbakshifirst.blogspot.com/2007/02/c-indeterminate-value.html\" rel=\"nofollow noreferrer\">http://zamanbakshifirst.blogspot.com/2007/02/c-indeterminate-value.html</a></p></li>\n</ol>\n", "AcceptedAnswerId": "4279313", "Title": "Is reading an indeterminate value undefined behavior?", "CreationDate": "2010-11-25T16:47:44.530", "Id": "4279264", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:02.027", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-09T19:45:47.963", "Score": "11", "OwnerUserId": "214777", "Tags": "<c++><initialization><undefined-behavior>", "AnswerCount": "4"}});