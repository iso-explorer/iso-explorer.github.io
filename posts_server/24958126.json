post_cb({"24958126": {"CommentCount": "2", "ViewCount": "194", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-07-25T14:30:46.987", "LastActivityDate": "2014-08-02T06:43:16.307", "Title": "How do I initialize an object of std::array<std::array<T, 2>, 2>?", "AcceptedAnswerId": "24958839", "LastEditDate": "2014-08-02T06:43:16.307", "Id": "24958126", "Score": "5", "Body": "<p>I'm trying to initialize objects of type thing:</p>\n<pre><code>template&lt;typename T&gt;\n  struct thing : std::array&lt;std::array&lt;T, 2&gt;, 2&gt;\n  {\n  };\n\nthing&lt;int&gt; t1 {{ {1,2}, {3,4} }};\n</code></pre>\n<p>I get:</p>\n<pre><code> error: no matching function for call to \u2018thing&lt;int&gt;::thing(&lt;brace-enclosed initializer list&gt;)\u2019\n thing&lt;int&gt; t1 {{{1,2},{3,4}}};\n</code></pre>\n<p>Ditto with</p>\n<pre><code>thing&lt;int&gt; t0{{ 1, 2, 3, 4 }};\n</code></pre>\n<p>and several other things.</p>\n", "Tags": "<c++><c++11><initialization><brace-initialization>", "OwnerUserId": "680359", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24958126_24958839_0": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_24958126_24958839_0": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_24958126_24958839_0": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}}}, "24958839": {"ParentId": "24958126", "CommentCount": "0", "Body": "<p><code>std::array</code> is an aggregate, and the initialization done using a braced-init-list is aggregate initialization. However, <code>thing</code> is not an aggregate because it has a base class.</p>\n<p>From <em>\u00a78.5.1/1 [dcl.init.aggr]</em></p>\n<blockquote>\n<p id=\"so_24958126_24958839_0\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), <strong>no base classes</strong> (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Thus, aggregate initialization is not going to work. Depending on what you're attempting to do, you either want to provide a constructor for <code>thing</code> that takes an <code>std::array&lt;std::array&lt;T, 2&gt;, 2&gt;</code> argument, and initialize the base subobject</p>\n<pre><code>template&lt;typename T&gt;\nstruct thing : std::array&lt;std::array&lt;T, 2&gt;, 2&gt;\n{\n    thing(std::array&lt;std::array&lt;T, 2&gt;, 2&gt; arr) \n    : std::array&lt;std::array&lt;T, 2&gt;, 2&gt;(arr) \n    {}\n};\nthing&lt;int&gt; t{ {{ {{1,2}}, {{3,4}} }} };\n</code></pre>\n<p>Or have <code>thing</code> contain the <code>std::array</code> as a data member. Now <code>thing</code> is still an aggregate.</p>\n<pre><code>template&lt;typename T&gt;\nstruct thing\n{\n    std::array&lt;std::array&lt;T, 2&gt;, 2&gt; arr;\n};\nthing&lt;int&gt; t{ {{ {{1,2}}, {{3,4}} }} };\n</code></pre>\n<hr>\n<p>If what you're attempting to do is have <code>thing</code> be an alias for an <code>array&lt;array&lt;T,2&gt;,2&gt;</code>, then you don't need either of the above. Use</p>\n<pre><code>template&lt;typename T&gt;\nusing thing = std::array&lt;std::array&lt;T, 2&gt;, 2&gt;;\n\nthing&lt;int&gt; t{{ {{1,2}}, {{3,4}} }};\n</code></pre>\n</hr>", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "24958839", "Score": "9", "CreationDate": "2014-07-25T15:07:07.590", "LastActivityDate": "2014-07-25T15:07:07.590"}});