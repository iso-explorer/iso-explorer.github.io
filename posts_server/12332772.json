post_cb({"12332978": {"Id": "12332978", "PostTypeId": "2", "Body": "<p>I think the reasoning for this goes like this.</p>\n<p><code>basic_string</code> only works with non-array POD types. As such, their destructors must be trivial. This means that if you do a <code>swap</code> for move-assignment, it doesn't matter as much to you that the original contents of the moved-to string haven't been destroyed yet.</p>\n<p>Whereas containers (<code>basic_string</code> is not technically a container by the C++ spec) can contain arbitrary types. Types with destructors, or types that contain objects with destructors. This means that it is more important to the user to maintain control over exactly <em>when</em> an object is destroyed. It specifically states that:</p>\n<blockquote>\n<p id=\"so_12332772_12332978_0\">All existing elements of <strong>a</strong> [the moved-to object] are either move assigned to or destroyed.</p>\n</blockquote>\n<p>So the difference does make sense. You can't make move-assignment <code>noexcept</code> once you start deallocating memory (through the allocator) because that can fail via exception. Thus, once you start requiring that memory is deallocated on move-assign, you give up being able to enforce <code>noexcept</code>.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2012-09-08T17:57:06.077", "Score": "9", "CreationDate": "2012-09-08T17:33:33.687", "ParentId": "12332772", "CommentCount": "5", "LastEditDate": "2012-09-08T17:57:06.077", "OwnerUserId": "734069"}, "12334918": {"Id": "12334918", "PostTypeId": "2", "Body": "<p>I believe we're looking at a standards defect.  The <code>noexcept</code> specification, if it is to be applied to the move assignment operator, is somewhat complicated.  And I believe this statement to be true whether we are talking about <code>basic_string</code> or <code>vector</code>.</p>\n<p>Based on [container.requirements.general]/p7 my English translation of what a container move assignment operator is supposed to do is:</p>\n<pre><code>C&amp; operator=(C&amp;&amp; c)\n</code></pre>\n<blockquote>\n<p id=\"so_12332772_12334918_0\">If <code>alloc_traits::propagate_on_container_move_assignment::value</code> is\n  <code>true</code>, dumps resources, move assigns allocators, and transfers\n  resources from <code>c</code>.</p>\n<p id=\"so_12332772_12334918_1\">If\n  <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>false</code>\n  and <code>get_allocator() == c.get_allocator()</code>, dumps resources, and transfers\n  resources from <code>c</code>.</p>\n<p id=\"so_12332772_12334918_2\">If\n  <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>false</code>\n  and <code>get_allocator() != c.get_allocator()</code>, move assigns each <code>c[i]</code>.</p>\n</blockquote>\n<p>Notes:</p>\n<ol>\n<li><p><code>alloc_traits</code> refers to <code>allocator_traits&lt;allocator_type&gt;</code>.</p></li>\n<li><p>When <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>true</code> the move assignment operator can be specified <code>noexcept</code> because all it is going to is deallocate current resources and then pilfer resources from the source.  Also in this case, the allocator must also be move assigned, and that move assignment must be <code>noexcept</code> for the container's move assignment to be <code>noexcept</code>.</p></li>\n<li><p>When <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>false</code>, and if the two allocators are equal, then it is going to do the same thing as #2.  However one doesn't know if the allocators are equal until run time, so you can't base <code>noexcept</code> on this possibility.</p></li>\n<li><p>When <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>false</code>, and if the two allocators are <strong>not</strong> equal, then one has to move assign each individual element.  This may involve adding capacity or nodes to the target, and thus is intrinsically <code>noexcept(false)</code>.</p></li>\n</ol>\n<p>So in summary:</p>\n<pre><code>C&amp; operator=(C&amp;&amp; c)\n        noexcept(\n             alloc_traits::propagate_on_container_move_assignment::value &amp;&amp;\n             is_nothrow_move_assignable&lt;allocator_type&gt;::value);\n</code></pre>\n<p>And I see no dependence on <code>C::value_type</code> in the above spec and so I believe it should apply equally well to <code>std::basic_string</code> despite C++11 specifying otherwise.</p>\n<p><strong>Update</strong></p>\n<p>In the comments below Columbo correctly points out that things have gradually been changing all the time.  My comments above are relative to C++11.</p>\n<p>For the draft C++17 (which seems stable at this point) things have changed somewhat:</p>\n<ol>\n<li><p>If <code>alloc_traits::propagate_on_container_move_assignment::value</code> is <code>true</code>, the spec now requires the move assignment of the <code>allocator_type</code> to not throw exceptions (17.6.3.5 [allocator.requirements]/p4).  So one no longer needs to check <code>is_nothrow_move_assignable&lt;allocator_type&gt;::value</code>.</p></li>\n<li><p><code>alloc_traits::is_always_equal</code> has been added.  If this is true, then one can determine at compile time that point 3 above can not throw because resources can be transferred.</p></li>\n</ol>\n<p>So the new <code>noexcept</code> spec for containers could be:</p>\n<pre><code>C&amp; operator=(C&amp;&amp; c)\n        noexcept(\n             alloc_traits::propagate_on_container_move_assignment{} ||\n             alloc_traits::is_always_equal{});\n</code></pre>\n<p>And, for <code>std::allocator&lt;T&gt;</code>, <code>alloc_traits::propagate_on_container_move_assignment{}</code> and <code>alloc_traits::is_always_equal{}</code> are both true.</p>\n<p>Also now in the C++17 draft, both <code>vector</code> and <code>string</code> move assignment carry <em>exactly</em> this <code>noexcept</code> specification.  However the other containers carry variations of this <code>noexcept</code> specification.</p>\n<p>The safest thing to do if you care about this issue is to test explicit specializations of containers you care about.  I've done exactly that for <code>container&lt;T&gt;</code> for VS, libstdc++ and libc++ here:</p>\n<p><a href=\"http://howardhinnant.github.io/container_summary.html\" rel=\"nofollow noreferrer\">http://howardhinnant.github.io/container_summary.html</a></p>\n<p>This survey is about a year old, but as far as I know is still valid.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2016-11-28T00:11:06.930", "Score": "20", "CreationDate": "2012-09-08T22:15:47.323", "ParentId": "12332772", "CommentCount": "4", "LastEditDate": "2016-11-28T00:11:06.930", "OwnerUserId": "576911"}, "bq_ids": {"n4140": {"so_12332772_12332978_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 705}}, "n3337": {"so_12332772_12332978_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 695}}, "n4659": {"so_12332772_12332978_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 734}}}, "12332772": {"ViewCount": "2726", "Body": "<p>I noticed that <code>std::string</code>'s (really <code>std::basic_string</code>'s) move assignment operator is   <code>noexcept</code>. That makes sense to me. But then I noticed that none of the standard containers (e.g., <code>std::vector</code>, <code>std::deque</code>, <code>std::list</code>, <code>std::map</code>) declares its move assignment operator <code>noexcept</code>. That makes less sense to me.  A <code>std::vector</code>, for example, is typically implemented as three pointers, and pointers can certainly be move-assigned without throwing an exception.  Then I thought that maybe the problem is with moving the container's allocator, but <code>std::string</code>'s have allocators, too, so if that were the issue, I'd expect it to affect <code>std::string</code>.</p>\n<p>So why is <code>std::string</code>'s move assignment operator <code>noexcept</code>, yet the move assignment operators for the standard containers are not?</p>\n", "AcceptedAnswerId": "12334918", "Title": "Why aren't container move assignment operators noexcept?", "CreationDate": "2012-09-08T17:07:39.550", "Id": "12332772", "CommentCount": "6", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-11-28T00:11:06.930", "Score": "31", "OwnerUserId": "1426649", "Tags": "<c++><c++11>", "AnswerCount": "2"}});