post_cb({"30642418": {"ParentId": "30641865", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It would be nice to have a simple way of deriving classes from built-in types, especially if automatic conversions were disabled. For example one could define distinct integer classes for feet and meters, preventing errors like the one which led to the <a href=\"http://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure\" rel=\"nofollow noreferrer\">Mars Orbiter Crash in 1999</a>. Ada with its focus on safety <a href=\"http://en.wikibooks.org/wiki/Ada_Programming/Types/range\" rel=\"nofollow noreferrer\">provides that feature</a>. The reason why it is not possible in C++ is provided in <a href=\"https://stackoverflow.com/a/2143734/3150802\">another answer</a> (the OP there tried to explicitly inherit from int): The C type system for ints is so \"chaotic\" (Stroustrup) that it makes these types unsuitable for building blocks in a class hierarchy.</p>\n<p>As it is in C++, one must write a wrapper including all the operations one wants to have, which are provided automatically in the case of Ada.</p>\n", "OwnerUserId": "3150802", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:40.380", "Id": "30642418", "Score": "1", "CreationDate": "2015-06-04T11:16:00.757", "LastActivityDate": "2015-06-04T11:16:00.757"}, "30641865": {"CommentCount": "2", "AcceptedAnswerId": "30641971", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-06-04T10:49:56.117", "LastActivityDate": "2015-06-04T11:16:00.757", "LastEditDate": "2017-05-23T12:21:56.990", "ViewCount": "71", "FavoriteCount": "1", "Title": "When I use typedef or using for an int, how much is it still an int?", "Id": "30641865", "Score": "1", "Body": "<p>I tried the following:</p>\n<pre><code>using Idx = int;\narray&lt;Value, N&gt; arr;\n\nfor(Idx i = 0; i &lt; N; i ++){\n  arr[i].doSomething();\n}\n</code></pre>\n<p>I expected that the compiler would issue a warning or an error when I try to use <code>Idx</code> as if it was an <code>int</code>. But it does not.</p>\n<p>So, when I use <code>using</code> or <code>typedef</code> to alias type A as a B, are variables of type B still also of type A, and vice versa? So that no type safety can be achieved by renaming a type when it looks the same but has a different meaning.</p>\n<p>(This is related to the following question I recently asked: <a href=\"https://stackoverflow.com/questions/30641165/how-to-make-types-for-indexing\">How to make types for indexing</a>)</p>\n", "Tags": "<c++><typedef><using>", "OwnerUserId": "2109064", "AnswerCount": "3"}, "30641971": {"ParentId": "30641865", "CommentCount": "0", "Body": "<p>An alias declaration or <code>typedef</code> just makes a new name for the aliased type. <code>Idx</code> is not a different type from <code>int</code> in this case; they can be used interchangeably with no difference in semantics. </p>\n<p>From [dcl.typedef] (emphasis mine):</p>\n<blockquote>\n<p id=\"so_30641865_30641971_0\">A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a\n  typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in\n  the way described in Clause 8. <strong>A typedef-name is thus a synonym for another type. A typedef-name does\n  not introduce a new type the way a class declaration or enum declaration does.</strong></p>\n</blockquote>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "30641971", "Score": "3", "CreationDate": "2015-06-04T10:54:48.273", "LastActivityDate": "2015-06-04T10:54:48.273"}, "bq_ids": {"n4140": {"so_30641865_30641971_0": {"section_id": 5407, "quality": 1.0, "length": 37}}, "n3337": {"so_30641865_30641971_0": {"section_id": 5202, "quality": 1.0, "length": 37}}, "n4659": {"so_30641865_30641971_0": {"section_id": 6829, "quality": 1.0, "length": 37}}}, "30641973": {"ParentId": "30641865", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>typedef</code> and equivalent <code>using</code> statements do not add any type safety in that they introduce alternative identifiers for the <em>same</em> type.</p>\n<p>Sometimes it is desirable to create distinct types easily, and you may come across things like this:</p>\n<pre><code>template &lt;typename T, size_t Id&gt;\nstruct Distinct_Type\n{\n    explicit Distinct_Type(const T&amp; t) : t_(t) { }\n    const T&amp; get() const { return t_; }\n    ...whatever else...\n    T t_;\n};\n</code></pre>\n<p>And usage like:</p>\n<pre><code>typedef Distinct_Type&lt;int, __LINE__&gt; Age;\nvoid f(Age);\nvoid g() { f(Age(88)); /*forced explicit construction*/ }\n</code></pre>\n<p>Clearly <code>__LINE__</code> is a nasty and error prone hack: with C++11 it's possible to create compile time incrementing values that work reliably, but the code's too long for recreation and inclusion here - google if interested.</p>\n<p>These really-distinct types have problems though: for example, if you call a function like <code>template &lt;typename T&gt; void f(T t);</code> ala <code>f(Distinct_Type&lt;int, 1&gt;(1));</code>, <code>f(Distinct_Type&lt;int, 2&gt;(1));</code>, <code>f(Distinct_Type&lt;int, 3&gt;(1));</code> - the compiler/linker may or may not eliminate two of the three instantiations from the executable image, reducing code bloat.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2015-06-04T11:02:02.410", "Id": "30641973", "Score": "1", "CreationDate": "2015-06-04T10:54:51.297", "LastActivityDate": "2015-06-04T11:02:02.410"}});