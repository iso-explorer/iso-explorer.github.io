post_cb({"32029293": {"Id": "32029293", "PostTypeId": "2", "Body": "<p><code>bool</code> takes up a minimum 1 byte. Even though there are only two options of <code>true</code> or <code>false</code>, it can't be 1 bit because a <code>bool</code> needs to be addressable. </p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2015-08-15T21:22:27.900", "Score": "3", "CreationDate": "2015-08-15T20:58:58.720", "ParentId": "32029213", "CommentCount": "3", "LastEditDate": "2015-08-15T21:22:27.900", "OwnerUserId": "5221096"}, "32029213": {"ViewCount": "721", "Body": "<p>I was studying about <em>arithmetic types</em> in C++ Prime by Stanley B. Lippman. When the author talks about <em>integral types</em> and the size of each one of them, like for example char is 8 bits, I noticed that it is not so clear the minimum size of a boolean. Considering type conversions, and the following code:</p>\n<pre><code>bool b = 42; // b is true\nint i = b; // i had value 1\n</code></pre>\n<p>Can I say that booleans have the same minimum size of an integer (usually 16 bits), since if it is false it would be 0, that is an int, and 1 if it is true, another int? And if what I said is wrong, what is the minimum size of a boolean?</p>\n", "AcceptedAnswerId": "32029296", "Title": "What is the minimum size of a boolean?", "CreationDate": "2015-08-15T20:50:20.620", "Id": "32029213", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2015-08-17T09:38:18.957", "Score": "1", "OwnerUserId": "4882392", "Tags": "<c++><c++11><boolean><sizeof>", "AnswerCount": "7"}, "32029601": {"Id": "32029601", "PostTypeId": "2", "Body": "<p>There is a difference between the general notion of \u201cboolean\u201d that you ask about, and the C++ type <code>bool</code>.</p>\n<p>A <code>bool</code> that is not a bitfield is minimum 1 byte, i.e. <code>sizeof(bool)</code> \u2265 1. This limit is because a byte is the minimum addressable unit; any C++ object is at least 1 byte. The standard does not place any upper limit on the size of <code>bool</code>, but in practice it will not be larger than can be handled with single memory read and write operation.</p>\n<p>A <em>boolean</em> variable is any variable used to implement the notion of boolean. There are a lot of boolean types around, not just C++'s own <code>bool</code>. E.g., in Windows programming you have a <code>BOOL</code> type that's more than one byte, and that in some cases can represent logical <em>true</em> via any non-zero value.</p>\n<p>And in some cases, with a collection of boolean values they can be represented with just 1 bit each, for example in a <code>std::bitset</code> or in a <code>std::vector&lt;bool&gt;</code> (which is special-cased for the item type <code>bool</code> in order to allow this). Or, I believe, but I haven't checked if that's supported, with a bitfield of size 1 of type <code>bool</code>. And these considerations means that the question is a bit too vague to have a simple and crisp answer. If you'd asked about <code>sizeof(bool)</code> it would have been much more clear-cut: just 1 or more bytes, depending on the implementation.</p>\n", "LastActivityDate": "2015-08-15T21:35:48.047", "Score": "3", "CreationDate": "2015-08-15T21:35:48.047", "ParentId": "32029213", "CommentCount": "1", "OwnerUserId": "464581"}, "32029270": {"Id": "32029270", "PostTypeId": "2", "Body": "<p>If you have <code>bool b = 42;</code> in your code, compiler finds out, that <code>42</code> is not of type <code>bool</code> and will treat it is if it was <code>bool b = true;</code>.<br>\nWhen you write later <code>int i = true</code> compiler will again find out, that <code>true</code> is not integer, and will treat it as it was <code>int i = 1</code>, because, by definition, <code>0</code> is <code>false</code> and every other int is <code>true</code>.</br></p>\n<p>However, talking about size of the type is something different. <code>bool</code>'s size will always be at least <code>8bit</code>s, because, that's how addresses work.</p>\n", "LastActivityDate": "2015-08-15T20:57:10.423", "Score": "0", "CreationDate": "2015-08-15T20:57:10.423", "ParentId": "32029213", "CommentCount": "3", "OwnerUserId": "3087601"}, "bq_ids": {"n4140": {"so_32029213_32029296_1": {"length": 11, "quality": 0.6111111111111112, "section_id": 6076}, "so_32029213_32029331_0": {"length": 5, "quality": 0.625, "section_id": 7210}}, "n3337": {"so_32029213_32029296_1": {"length": 11, "quality": 0.6111111111111112, "section_id": 5844}, "so_32029213_32029331_0": {"length": 5, "quality": 0.625, "section_id": 6954}}, "n4659": {"so_32029213_32029296_1": {"length": 11, "quality": 0.6111111111111112, "section_id": 7572}, "so_32029213_32029331_0": {"length": 5, "quality": 0.625, "section_id": 8719}}}, "32029233": {"Id": "32029233", "PostTypeId": "2", "Body": "<p>No, you can't. </p>\n<p>A Boolean has a distinct size. Sometimes Ints can be treated as Booleans because of 0,1 but that does not mean a Boolean has the same size as a Int.</p>\n", "LastActivityDate": "2015-08-15T20:53:09.917", "Score": "1", "CreationDate": "2015-08-15T20:53:09.917", "ParentId": "32029213", "CommentCount": "0", "OwnerUserId": "5229124"}, "32029331": {"Id": "32029331", "PostTypeId": "2", "Body": "<p>In the c99 standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a>) the integer is defined as spanning <em>at least</em> the range [-32767, 32767] (see section 5.2.4.2.1).  However, the spec also says (in 6.2.5 2)</p>\n<blockquote>\n<p id=\"so_32029213_32029331_0\">An object declared as type _Bool is large enough to store the values 0\n  and 1.</p>\n</blockquote>\n<p>The implications of this, is that the spec in no way requires them to be the same size.  Satisfying the spec doesn't require having them match.  It is distinctly possible (although unlikely) for a particular implementation to choose to have them be the same size.  But it's nothing you can/should rely on.</p>\n", "LastActivityDate": "2015-08-15T21:04:39.043", "Score": "1", "CreationDate": "2015-08-15T21:04:39.043", "ParentId": "32029213", "CommentCount": "0", "OwnerUserId": "5227391"}, "32029296": {"Id": "32029296", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32029213_32029296_0\">What is the minimum size of a boolean?</p>\n</blockquote>\n<p>in standard you can read 5.3.3:</p>\n<blockquote>\n<p id=\"so_32029213_32029296_1\">The result of sizeof applied to any other fundamental type (3.9.1) is\n  implementation-defined. [ Note: in particular, sizeof(bool), sizeof(char16_t), sizeof(char32_t), and\n  sizeof(wchar_t) are implementation-defined.75 \u2014end note ]</p>\n</blockquote>\n<p>and note:</p>\n<blockquote>\n<p id=\"so_32029213_32029296_2\">sizeof(bool) is not required to be 1</p>\n</blockquote>\n<p>so it might be 1 byte but it might be also 4 bytes. Standard also allows for ints to be of size <strike>1 byte</strike> 16bits:</p>\n<blockquote>\n<p id=\"so_32029213_32029296_3\">1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</p>\n</blockquote>\n<p>so minimum size for bool is 1 byte, <strike>the same as for int. The other question is whether you will ever find platform with 1 byte <code>int</code> type.</strike></p>\n<p>[edit]</p>\n<p>minimum size (guaranteed minimum) for <code>int</code> is 16bits, this <a href=\"https://stackoverflow.com/questions/4091826/size-guarantee-for-integral-arithmetic-types-in-c-and-c\">size guarantee for integral/arithmetic types in C and C++</a> explains why.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-17T09:38:18.957", "Score": "4", "CreationDate": "2015-08-15T20:59:27.767", "ParentId": "32029213", "CommentCount": "6", "LastEditDate": "2017-05-23T12:24:17.757", "OwnerUserId": "471160"}, "32029255": {"Id": "32029255", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32029213_32029255_0\">Can I say that booleans have the same minimum size of an integer</p>\n</blockquote>\n<p>No, if you could it would be in the standard. </p>\n<p>Most standard implementations on modern systems (x86/x64) use <code>bool</code> to be the same size as a register (32/64 bits respectively) for speed reasons. However nothing stops you from having bit-sized <code>bool</code> variables, they're a simple bitfield away! And on microcontroller implementations <code>bool</code> is usually as small as possible (a single byte) since your memory is extremely limited.</p>\n", "LastActivityDate": "2015-08-15T20:55:31.163", "Score": "1", "CreationDate": "2015-08-15T20:55:31.163", "ParentId": "32029213", "CommentCount": "5", "OwnerUserId": "108796"}});