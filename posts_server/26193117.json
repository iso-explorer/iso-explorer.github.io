post_cb({"bq_ids": {"n4140": {"so_26193117_26193285_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_26193117_26193285_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}}, "n4659": {"so_26193117_26193285_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}, "26193137": {"Id": "26193137", "PostTypeId": "2", "Body": "<p>The return statement copies your return value into the temporary object in scope of the calling function, that is, main. Then the temporary object Foo(), created in scope of foo, gets destructed, and then the temporary in scope of main gets destructed. The compiler is allowed, but not obligated, to optimize this away.</p>\n", "LastActivityDate": "2014-10-04T13:08:08.640", "CommentCount": "0", "CreationDate": "2014-10-04T13:08:08.640", "ParentId": "26193117", "Score": "1", "OwnerUserId": "469935"}, "26193117": {"ViewCount": "222", "Body": "<p><strong>Problem</strong></p>\n<p>The destructor gets called twice in the following code:</p>\n<pre><code>class Foo\n{\npublic: \n    ~Foo()\n    {\n        std::cout &lt;&lt; \"Destructor called\\n\";\n    }\n\n    Foo&amp; operator=(const Foo&amp; other)\n    {\n        std::cout &lt;&lt; \"Assignment called\\n\";\n\n        return *this;\n    }\n};\n\nFoo foo()\n{\n    return Foo();\n}\n\nint main()\n{\n    foo();\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Destructor called\nDestructor called\n</code></pre>\n<p>I suspect this is due to some implicit call to an assignment operator or a copy constructor. I cannot tell if the copy constructor gets called as adding a constructor of any kind magically solves the problem (as explained further down), but at least the assignment operator does not get called.</p>\n<p>And as mentioned, if I add a constructor, the problem goes away:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo()\n    {\n        std::cout &lt;&lt; \"Constructor called\\n\";\n    }\n\n    Foo(const Foo&amp; other)\n    {\n        std::cout &lt;&lt; \"Copy constructor called\\n\";\n    }\n\n    ~Foo()\n    {\n        std::cout &lt;&lt; \"Destructor called\\n\";\n    }\n\n    Foo&amp; operator=(const Foo&amp; other)\n    {\n        std::cout &lt;&lt; \"Assignment called\\n\";\n\n        return *this;\n    }\n};\n</code></pre>\n<p>The output changes into:</p>\n<pre><code>Constructor called\nDestructor called\n</code></pre>\n<p>The problem also goes away if I return a reference instead of an object (but results in a \"returning address of local or temporary variable\" warning):</p>\n<pre><code>Foo&amp; foo()\n{\n    return Foo();\n}\n</code></pre>\n<p><strong>Question</strong></p>\n<p>Why is the destructor called twice, and why is the behavior different when using a default constructor or not? Is there a logical explanation or could it be a mistake by the compiler? </p>\n<p>I'm using MSVC 2013 if it could make any difference.</p>\n", "AcceptedAnswerId": "26193285", "Title": "Destuctor called twice when returning a temporary objects with default constructor", "CreationDate": "2014-10-04T13:04:03.523", "Id": "26193117", "CommentCount": "16", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-17T10:36:52.093", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-17T10:36:52.093", "Score": "2", "OwnerUserId": "1937742", "Tags": "<c++><constructor><language-lawyer><destructor>", "AnswerCount": "3"}, "26193254": {"Id": "26193254", "PostTypeId": "2", "Body": "<p>In the function <code>foo()</code> your object gets created. It returns a copy of that object. When the function ends, the first object (created in the function) goes out of scope, invoking the destructor.  </p>\n<p>Next, you <code>main()</code> gets a whole new object. And when it ends, it invokes destructor of this new object.</p>\n<p>For the following: </p>\n<pre><code>Foo&amp; foo()\n{\n   return Foo();\n}\n</code></pre>\n<p>..You return reference to a local variable which gives a worthless return and main function doesn't get an object at all, no duplicate destructor is called.</p>\n", "LastEditorUserId": "2557812", "LastActivityDate": "2014-10-04T13:29:49.470", "Score": "-1", "CreationDate": "2014-10-04T13:22:47.703", "ParentId": "26193117", "CommentCount": "3", "OwnerUserId": "2557812", "LastEditDate": "2014-10-04T13:29:49.470"}, "26193285": {"Id": "26193285", "PostTypeId": "2", "Body": "<pre><code>Foo foo()\n{\n    return Foo(); // temporary is created and copied into the return value. \n                  // The temporary gets destroyed at the end of the copy constructor.\n}\n\nint main()\n{\n    foo(); // discarded-value expression; the return value gets destroyed immediately.\n}\n</code></pre>\n<p>The compiler is allowed to apply copy-elision - in this case, NRVO (\u00a712.8/31):</p>\n<blockquote>\n<p id=\"so_26193117_26193285_0\">\u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n      to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n      constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n<p>Note that this works regardless of whether the copy constructor has any side effects or not. This is an \"optimization\" that can legally change the observable behavior of the program without disobeying the standard.</p>\n<p>Since the compiler is not obliged to optimize anything, results may differ from code to code (and optimization level).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-04T15:49:53.140", "Score": "1", "CreationDate": "2014-10-04T13:25:40.250", "ParentId": "26193117", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-10-04T15:49:53.140"}});