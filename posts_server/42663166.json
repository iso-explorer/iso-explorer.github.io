post_cb({"42663166": {"CommentCount": "3", "AcceptedAnswerId": "42663598", "CreationDate": "2017-03-08T04:41:08.533", "LastActivityDate": "2017-03-08T15:54:38.270", "PostTypeId": "1", "ViewCount": "105", "FavoriteCount": "2", "Title": "C++ direct list initialization with deleted default constructor", "Id": "42663166", "Score": "2", "Body": "<p>I have the following class definition. I included a private <code>x</code> to make sure it is not an aggregate.</p>\n<pre><code>class A {\n private:\n  int x;\n\n public:\n  A() = delete;\n  A(std::initializer_list&lt;int&gt;) { printf(\"init\\n\"); }\n};\n</code></pre>\n<p>Now if I initialize this object with <code>A a = A{}</code>, it will say <code>A::A()</code> is deleted. I guess it is trying to call <code>A::A()</code> but it is deleted. If I comment out that line, so <code>A::A()</code> is automatically generated. Then if I run this code, I could see that it is calling <code>A::A(std::initializer_list&lt;int&gt;)</code>!</p>\n<p>And more confusing, if I define <code>A() = default</code>, the initialization calls <code>A::A()</code> again.</p>\n<p>Can anyone point me to the right direction of understading this behavior? Thanks!</p>\n<p>I'm using G++ 6.3.0 with flag <code>-std=c++17</code>.</p>\n", "Tags": "<c++><c++1z>", "OwnerUserId": "1595430", "AnswerCount": "3"}, "42663784": {"ParentId": "42663166", "CommentCount": "1", "Body": "<p>You have lots of cases listed, so let us go over them one by one.</p>\n<pre><code>A() = delete;\nA(std::initializer_list&lt;int&gt;) { ... }\n</code></pre>\n<p>Writing <code>A a = A{};</code> will indeed try to call the deleted default constructor, and your code fails to compile.</p>\n<p>What you have above is <a href=\"http://eel.is/c++draft/dcl.init.list#1\" rel=\"nofollow noreferrer\">list initialization</a>, and because the <a href=\"http://eel.is/c++draft/dcl.init.list#3.4\" rel=\"nofollow noreferrer\"><em>braced-init-list</em> is empty</a>, <a href=\"http://eel.is/c++draft/dcl.init#8.1\" rel=\"nofollow noreferrer\">value initialization</a> will be performed. This selects the deleted default constructor, which makes your code ill-formed.</p>\n<hr>\n<blockquote>\n<p id=\"so_42663166_42663784_0\">If I comment out that line, so <code>A::A()</code> is automatically generated</p>\n</blockquote>\n<p>No, this is not the case. There is no implicitly declared default constructor due to the presence of the user provided constructor that takes an <code>initializer_list</code>. Now, <code>A a = A{};</code> will call the <code>initializer_list</code> constructor, and in this case the <code>initializer_list</code> will be empty.</p>\n<hr>\n<blockquote>\n<p id=\"so_42663166_42663784_1\">if I define <code>A() = default</code>, the initialization calls <code>A::A()</code> again</p>\n</blockquote>\n<p>This behaves the same as the first case, except the default constructor is explicitly <code>default</code>ed instead of <code>delete</code>d, so your code compiles.</p>\n<hr>\n<p>Finally,</p>\n<blockquote>\n<p id=\"so_42663166_42663784_2\">I included a private <code>x</code> to make sure it is not an aggregate</p>\n</blockquote>\n<p>There's no need for this, defining a constructor makes <code>A</code> a non-<a href=\"https://stackoverflow.com/q/4178175/241631\">aggregate</a>.</p>\n</hr></hr></hr>", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "42663784", "Score": "2", "CreationDate": "2017-03-08T05:39:55.783", "LastActivityDate": "2017-03-08T05:39:55.783"}, "42675964": {"ParentId": "42663166", "CommentCount": "0", "Body": "<p>List initialization follows a very specific ordering, as laid out in <a href=\"http://eel.is/c++draft/dcl.init.list#3\" rel=\"nofollow noreferrer\">[dcl.init.list]/3</a>. The two relevant bullet points and their relative ordering are highlighted:</p>\n<blockquote>\n<p id=\"so_42663166_42675964_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:<br>\n  \u2014 If <code>T</code> is an aggregate class and [...]<br>\n  \u2014 Otherwise, if <code>T</code> is a character array and [...]<br>\n  \u2014 Otherwise, if <code>T</code> is an aggregate, [...]<br>\n  \u2014 <strong>Otherwise, if the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.</strong><br>\n  \u2014 Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>, [...]<br>\n  \u2014 <strong>Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7).</strong><br>\n  \u2014 Otherwise, if the initializer list has a single element of type <code>E</code> and [...]<br>\n  \u2014 Otherwise, if <code>T</code> is a reference type, [...]<br>\n  \u2014 Otherwise, if <code>T</code> is an enumeration with a fixed underlying type (7.2), [...]<br>\n  \u2014 Otherwise, if the initializer list has no elements, the object is value-initialized.<br>\n  \u2014 Otherwise, the program is ill-formed.</br></br></br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>An empty initializer list for class types with default constructors is a special case that precedes normal constructor resolution. Your class isn't an aggregate (since it has a user-provided constructor), so <code>A{}</code> will attempt to value-initialize <code>A</code> if <code>A</code> has a default constructor. It doesn't matter if that default constructor is <em>accessible</em>, it only matters if it <em>exists</em>. If it exists and is inaccessible (your first case), that's ill-formed. If it exists and is accessible (your third case), then it's invoked. Only if your class does not have a default constructor will the constructors be enumerated, in which case the <code>A(initializer_list&lt;int&gt; )</code> constructor will be invoked with an empty initializer list (your second case). </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42675964", "Score": "1", "CreationDate": "2017-03-08T15:54:38.270", "LastActivityDate": "2017-03-08T15:54:38.270"}, "bq_ids": {"n4140": {"so_42663166_42675964_0": {"section_id": 3325, "quality": 0.8125, "length": 52}}, "n3337": {"so_42663166_42675964_0": {"section_id": 3195, "quality": 0.671875, "length": 43}}, "n4659": {"so_42663166_42675964_0": {"section_id": 4091, "quality": 0.890625, "length": 57}}}, "42663598": {"ParentId": "42663166", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The behaviour is correct.</p>\n<p>First of all: </p>\n<pre><code>// Calling\nA a = A{}; // equals A a = A();, \n</code></pre>\n<p>which was a convenience uniformization of the list-initialization idiom.\nRefer to: <a href=\"https://stackoverflow.com/a/9020606/3754223\">https://stackoverflow.com/a/9020606/3754223</a></p>\n<h2>Case A:</h2>\n<pre><code>class A {\n     private:\n         int x;\n\n     public:\n         **A() = delete;**\n         A(std::initializer_list&lt;int&gt;) { printf(\"init\\n\"); }\n};\n</code></pre>\n<p>As said above, A a = A{} will be ... = A(), which is deleted.</p>\n<h2>Case B:</h2>\n<pre><code>class A {\n     private:\n         int x;\n\n     public:\n         A(std::initializer_list&lt;int&gt;) { printf(\"init\\n\"); }\n};\n</code></pre>\n<p>In this case, there's no default constructor provided, since you have your initializer-list constructor be defined. Consequently {} is converted to an empty initializer list implicitely!</p>\n<h2>Case C:</h2>\n<pre><code>class A {\n     private:\n         int x;\n\n     public:\n         **A() = default;**\n         A(std::initializer_list&lt;int&gt;) { printf(\"init\\n\"); }\n};\n</code></pre>\n<p>In this case the empty default constructor is available and A{} is converted back to A(), causing it to be called.</p>\n<p>Please refer to the below pages and get a thorough read into it. \n<a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/initializer_list</a>\n<a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/value_initialization</a></p>\n<h2>Finally:</h2>\n<p>Using:</p>\n<pre><code>A a = {{}};\n</code></pre>\n<p>Would cause that ALWAYS the initializer-list constructor is called, as the outer-curly-brackets denoted the init-list, and the inner a zero-constructed element. -&gt; Non-empty initializer-list... (See stackoverflow link above again!)</p>\n<p>And btw, I cannot understand why the question is downvoted, considering that this is a really tricky part...</p>\n", "OwnerUserId": "3754223", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:04.887", "Id": "42663598", "Score": "2", "CreationDate": "2017-03-08T05:25:04.753", "LastActivityDate": "2017-03-08T05:25:04.753"}});