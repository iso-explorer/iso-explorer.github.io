post_cb({"41412882": {"ParentId": "41411009", "CommentCount": "0", "Body": "<p>This is a nice, dark corner of the standard for the language lawyers to feast upon.</p>\n<blockquote>\n<p id=\"so_41411009_41412882_0\"><strong>[expr.ref] \u00b64.3</strong></p>\n<p id=\"so_41411009_41412882_1\">If E2 is a (possibly overloaded) member function, <strong>function overload resolution is used to determine whether E1.E2 refers to a static or a non-static member function</strong>.</p>\n<ul>\n<li><p id=\"so_41411009_41412882_2\">If it refers to a static member function and the type of E2 is \"function of parameter-type-list returning T\", then E1.E2 is an lvalue; the expression designates the static member function. The type of E1.E2 is the same type as that of E2, namely \"function of parameter-type-list returning T\".</p></li>\n<li><p id=\"so_41411009_41412882_3\">Otherwise, if E1.E2 refers to a non-static member function and the type of E2 is \"function of parameter-type-list <em>cv ref-qualifier<sub>opt</sub></em> returning T\", then E1.E2 is a prvalue. The expression designates a non-static member function. <strong>The expression can be used only as the left-hand operand of a member function call</strong>. The type of E1.E2 is \"function of parameter-type-list cv returning T\".</p></li>\n</ul>\n</blockquote>\n<p>It goes without saying that only pointers to <em>static</em> member functions can be formed by the member access expression (i.e. dot or arrow operator). What is to be noted, though, is that <em>overload resolution determines the \"staticness\"</em> of a member function. So the question is, <strong>how can overload resolution act without an argument list?</strong> Compilers seem to differ on their interpretation.</p>\n<p>Some compilers may recognize that because the expression is being used to form a pointer to a function, the function <em>must</em> be a static member function or else the program is ill formed, and so exclude non-static member functions from the set of candidate functions.</p>\n<p>Other compilers may recognize that because all of the overloads are static, overload resolution can not possibly select a non-static member function, and so skip the step altogether.</p>\n<p>Yet other compilers may give up entirely, faced with the instruction to apply overload resolution without any argument list.</p>\n<p>This is a related example:</p>\n<pre><code>struct A {\n    static void foo(int) {}\n    static void bar(int) {}\n    static void bar(double) {}\n};\n\nvoid test() {\n    A a;\n    void(*f)(int) =  a.foo; // gcc:OK, msvc:OK,    clang:OK\n    void(*g)(int) =  a.bar; // gcc:OK, msvc:OK,    clang:ERROR\n    void(*h)(int) = &amp;a.bar; // gcc:OK, msvc:ERROR, clang:ERROR\n}\n</code></pre>\n<p>Here Clang is unable to form a pointer to the <code>int</code> overload of <code>bar</code> using the member access expression, with or without the <code>&amp;</code> address-of operator. MSVC is inconsistent in that it succeeds without the <code>&amp;</code> but not with it. But for the aforementioned reasons it is difficult to say which is conformant. GCC is quite happy in all cases to let the member access expression designate an unresolved overload that is then resolved due to the target type of the initialization ([over.over] \u00b61).</p>\n<p>It gets even more interesting when SFINAE gets involved:</p>\n<blockquote>\n<p id=\"so_41411009_41412882_4\"><strong>[temp.over] \u00b61</strong></p>\n<p id=\"so_41411009_41412882_5\">...If, for a given function template, argument deduction fails or the synthesized function template specialization would be ill-formed, no such function is added to the set of candidate functions for that template...</p>\n</blockquote>\n<p>Thus, some compilers may exclude SFINAE failures from the set of candidate functions for overload resolution for the purpose of determining the \"staticness\" of a member function. But again, it is hard to say what is conformant here. This may explain why Clang accepts the example in the original question, but not my <code>bar</code> example. I get the feeling implementors are just trying their best to fill in the blanks here.</p>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "41412882", "Score": "1", "CreationDate": "2017-01-01T02:01:31.260", "LastActivityDate": "2017-01-01T02:01:31.260"}, "41411009": {"CommentCount": "0", "ViewCount": "39", "CreationDate": "2016-12-31T19:02:52.427", "LastActivityDate": "2017-01-01T02:01:31.260", "Title": "msvc visual c++ incorrect formation of bound member function expression from static member function", "PostTypeId": "1", "Id": "41411009", "Score": "1", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct A {\n    template&lt;typename T, std::enable_if_t&lt;sizeof(T)&lt;=sizeof(int), int&gt; = 0&gt;\n    static void fun() {}\n    template&lt;typename T, std::enable_if_t&lt;(sizeof(T)&gt;sizeof(int)), int&gt; = 0&gt;\n    static void fun() {}\n    void test() {\n        using fun_t = void(*)();\n        fun_t ff[] = {\n            fun&lt;int&gt;,\n            &amp;fun&lt;int&gt;,\n            A::fun&lt;int&gt;,\n            &amp;A::fun&lt;int&gt;,\n            this-&gt;fun&lt;int&gt;,\n            &amp;this-&gt;fun&lt;int&gt;, //error C2276: '&amp;': illegal operation on bound member function expression\n        };\n    }\n};\n</code></pre>\n<p>msvc 2015update3 and 2017rc generate error C2276, which makes no sense. gcc, clang and intel compiler are fine.</p>\n<p>The work-around is simple: use any of the other expressions above which should all be equivalent.</p>\n<p>However, the wording of the error message is disturbing, and one has to wonder, if a bound member function expression is incorrectly formed for any of the other alternatives.</p>\n<p>Any insights into this matter?</p>\n", "Tags": "<c++><visual-c++><visual-studio-2015><compiler-bug>", "OwnerUserId": "5281260", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41411009_41412882_3": {"section_id": 6007, "quality": 0.8823529411764706, "length": 30}, "so_41411009_41412882_2": {"section_id": 6007, "quality": 0.96, "length": 24}, "so_41411009_41412882_5": {"section_id": 355, "quality": 0.7368421052631579, "length": 14}, "so_41411009_41412882_1": {"section_id": 6007, "quality": 1.0, "length": 15}}, "n3337": {"so_41411009_41412882_3": {"section_id": 5775, "quality": 0.8823529411764706, "length": 30}, "so_41411009_41412882_2": {"section_id": 5775, "quality": 0.96, "length": 24}, "so_41411009_41412882_5": {"section_id": 345, "quality": 0.7368421052631579, "length": 14}, "so_41411009_41412882_1": {"section_id": 5775, "quality": 1.0, "length": 15}}, "n4659": {"so_41411009_41412882_3": {"section_id": 7506, "quality": 0.8823529411764706, "length": 30}, "so_41411009_41412882_1": {"section_id": 7506, "quality": 1.0, "length": 15}, "so_41411009_41412882_5": {"section_id": 365, "quality": 1.0, "length": 19}, "so_41411009_41412882_2": {"section_id": 7506, "quality": 0.96, "length": 24}}}});