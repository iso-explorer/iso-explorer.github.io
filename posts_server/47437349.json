post_cb({"47437349": {"CommentCount": "0", "AcceptedAnswerId": "47437418", "CreationDate": "2017-11-22T14:37:45.800", "LastActivityDate": "2017-11-23T08:35:52.437", "PostTypeId": "1", "ViewCount": "289", "FavoriteCount": "6", "Title": "Is it undefined behavior to read and compare padding bytes of a POD type?", "Id": "47437349", "Score": "11", "Body": "<p>Today I've encountered some code that roughly looks like the following snippet. Both <code>valgrind</code> and <code>UndefinedBehaviorSanitizer</code> detected reads of uninitialized data.</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(const T&amp; x)\n{\n    static_assert(std::is_pod_v&lt;T&gt; &amp;&amp; sizeof(T) &gt; 1);\n    auto p = reinterpret_cast&lt;const char*&gt;(&amp;x);\n\n    std::size_t i = 1; \n    for(; i &lt; sizeof(T); ++i)\n    {\n        if(p[i] != p[0]) { break; }\n    }\n\n    // ...\n}\n</code></pre>\n<p>The aforementioned tools complained about the <code>p[i] != p[0]</code> comparison when an \nobject containing padding bytes was passed to <code>foo</code>. Example:</p>\n<pre><code>struct obj { char c; int* i; };\nfoo(obj{'b', nullptr});\n</code></pre>\n<p><strong>Is it undefined behavior to read padding bytes from a POD type and compare them to something else?</strong> I couldn't find a definitive answer neither in the Standard nor on StackOverflow.</p>\n", "Tags": "<c++><language-lawyer><padding><undefined-behavior><standard-layout>", "OwnerUserId": "598696", "AnswerCount": "3"}, "47437418": {"ParentId": "47437349", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The behaviour of your program is <em>implementation defined</em> on two counts:</p>\n<hr>\n<p>1) Prior to C++14: Due to the possibility of a 1's complement or signed magnitude <code>signed</code> type for your <code>char</code>, you <em>might</em> return a surprising result due to comparing +0 and -0.</p>\n<p>The truly watertight way would be to use a <code>const unsigned char*</code> pointer. This obviates any concerns with the now abolished (from C++14) 1's complement or signed magnitude <code>char</code>.</p>\n<hr>\n<p>Since (i) you own the memory, (ii) you are taking a pointer to <code>x</code>, and (iii) an <code>unsigned char</code> cannot contain a trap representation, (iv) <code>char</code>, <code>unsigned char</code>, and <code>signed char</code> being exempted from the <em>strict aliasing rules</em>, the behaviour on using <code>const unsigned char*</code> to read uninitialised memory is perfectly well defined.</p>\n<hr>\n<p>2) But since you don't know what is contained in that uninitialised memory, the behaviour on reading it is unspecified and that means the program behaviour is implementation defined since the char types cannot contain trap representations.</p>\n</hr></hr></hr>", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2017-11-23T08:35:52.437", "Id": "47437418", "Score": "8", "CreationDate": "2017-11-22T14:41:05.823", "LastActivityDate": "2017-11-23T08:35:52.437"}, "47440920": {"ParentId": "47437349", "CommentCount": "0", "Body": "<p>It depends on the conditions.</p>\n<p>If <code>x</code> is zero-initialized, then padding has zero bits, so this case is <strong>well defined</strong> (8.5/6 of C++14):</p>\n<blockquote>\n<p id=\"so_47437349_47440920_0\">To zero-initialize an object or reference of type T means:</p>\n<p id=\"so_47437349_47440920_1\">\u2014 if T is a scalar type (3.9), the object is initialized to the value\n  obtained by converting the integer literal</p>\n<p id=\"so_47437349_47440920_2\">0 (zero) to T;105</p>\n<p id=\"so_47437349_47440920_3\">\u2014 if T is a (possibly cv-quali\ufb01ed) non-union class type, each\n  non-static data member and each base-class</p>\n<p id=\"so_47437349_47440920_4\">subobject is zero-initialized and <strong>padding is initialized to zero bits</strong>;</p>\n<p id=\"so_47437349_47440920_5\">\u2014 if T is a (possibly cv-quali\ufb01ed) union type, the object\u2019s \ufb01rst\n  non-static named data member is zero-</p>\n<p id=\"so_47437349_47440920_6\">initialized and <strong>padding is initialized to zero bits</strong>;</p>\n<p id=\"so_47437349_47440920_7\">\u2014 if T is an array type, each element is zero-initialized; \u2014 if T is a\n  reference type, no initialization is performed.</p>\n</blockquote>\n<p>However, if <code>x</code> is default-initialized, then padding isn't specified, so it has indeterminate value (inferred by the fact that there's no mention of padding here) (8.5/7):</p>\n<blockquote>\n<p id=\"so_47437349_47440920_8\">To default-initialize an object of type T means:</p>\n<p id=\"so_47437349_47440920_9\">\u2014 if T is a (possibly cv-quali\ufb01ed) class type (Clause 9), the default\n  constructor (12.1) for T is called (and the initialization is\n  ill-formed if T has no default constructor or overload resolution\n  (13.3) results in an ambiguity or in a function that is deleted or\n  inaccessible from the context of the initialization);</p>\n<p id=\"so_47437349_47440920_10\">\u2014 if T is an array type, each element is default-initialized;</p>\n<p id=\"so_47437349_47440920_11\">\u2014 otherwise, no initialization is performed.</p>\n</blockquote>\n<p>And comparing indeterminate values is <strong>UB for this case</strong>, as none of the mentioned exceptions apply, as you compare the indeterminate value to something (8.5/12):</p>\n<blockquote>\n<p id=\"so_47437349_47440920_12\">If no initializer is speci\ufb01ed for an object, the object is\n  default-initialized. When storage for an object with automatic or\n  dynamic storage duration is obtained, the object has an indeterminate\n  value, and if no initialization is performed for the object, that\n  object retains an indeterminate value until that value is replaced\n  (5.17). [ Note: Objects with static or thread storage duration are\n  zero-initialized, see 3.6.2. \u2014 end note ] <strong>If an indeterminate value is\n  produced by an evaluation, the behavior is unde\ufb01ned except in the\n  following cases:</strong></p>\n<p id=\"so_47437349_47440920_13\">\u2014 If an indeterminate value of unsigned narrow character type (3.9.1)\n  is produced by the evaluation of:</p>\n<p id=\"so_47437349_47440920_14\">......\u2014 the second or third operand of a conditional expression (5.16),</p>\n<p id=\"so_47437349_47440920_15\">......\u2014 the right operand of a comma expression (5.18),</p>\n<p id=\"so_47437349_47440920_16\">......\u2014 the operand of a cast or conversion to an unsigned narrow character type (4.7, 5.2.3, 5.2.9, 5.4),</p>\n<p id=\"so_47437349_47440920_17\">or</p>\n<p id=\"so_47437349_47440920_18\">......\u2014 a discarded-value expression (Clause 5), then the result of the\n  operation is an indeterminate value.</p>\n<p id=\"so_47437349_47440920_19\">\u2014 If an indeterminate value of unsigned narrow character type is\n  produced by the evaluation of the right operand of a simple assignment\n  operator (5.17) whose \ufb01rst operand is an lvalue of unsigned narrow\n  character type, an indeterminate value replaces the value of the\n  object referred to by the left operand.</p>\n<p id=\"so_47437349_47440920_20\">\u2014 If an indeterminate value of\n  unsigned narrow character type is produced by the evaluation of the\n  initialization expression when initializing an object of unsigned\n  narrow character type, that object is initialized to an indeterminate\n  value.</p>\n</blockquote>\n", "OwnerUserId": "8157187", "PostTypeId": "2", "Id": "47440920", "Score": "1", "CreationDate": "2017-11-22T17:42:45.067", "LastActivityDate": "2017-11-22T17:42:45.067"}, "bq_ids": {"n4140": {"so_47437349_47440920_6": {"section_id": 3285, "quality": 1.0, "length": 5}, "so_47437349_47447101_0": {"section_id": 435, "quality": 0.5555555555555556, "length": 5}, "so_47437349_47440920_0": {"section_id": 3285, "quality": 1.0, "length": 5}, "so_47437349_47440920_19": {"section_id": 3291, "quality": 0.9333333333333333, "length": 28}, "so_47437349_47440920_8": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_47437349_47440920_15": {"section_id": 3291, "quality": 0.8, "length": 4}, "so_47437349_47440920_14": {"section_id": 3291, "quality": 0.8333333333333334, "length": 5}, "so_47437349_47440920_3": {"section_id": 3285, "quality": 0.9090909090909091, "length": 10}, "so_47437349_47440920_9": {"section_id": 3286, "quality": 0.8695652173913043, "length": 20}, "so_47437349_47440920_18": {"section_id": 3291, "quality": 1.0, "length": 8}, "so_47437349_47440920_4": {"section_id": 3285, "quality": 1.0, "length": 6}, "so_47437349_47440920_12": {"section_id": 3291, "quality": 0.8297872340425532, "length": 39}, "so_47437349_47440920_7": {"section_id": 3285, "quality": 1.0, "length": 9}, "so_47437349_47440920_13": {"section_id": 3291, "quality": 0.8888888888888888, "length": 8}, "so_47437349_47440920_16": {"section_id": 3291, "quality": 0.7777777777777778, "length": 7}, "so_47437349_47440920_10": {"section_id": 3286, "quality": 1.0, "length": 5}, "so_47437349_47440920_5": {"section_id": 3285, "quality": 0.8181818181818182, "length": 9}, "so_47437349_47440920_20": {"section_id": 3291, "quality": 1.0, "length": 21}, "so_47437349_47440920_1": {"section_id": 3285, "quality": 1.0, "length": 9}}, "n3337": {"so_47437349_47440920_6": {"section_id": 3155, "quality": 1.0, "length": 5}, "so_47437349_47447101_0": {"section_id": 3161, "quality": 0.5555555555555556, "length": 5}, "so_47437349_47440920_0": {"section_id": 3155, "quality": 1.0, "length": 5}, "so_47437349_47440920_1": {"section_id": 3155, "quality": 0.5555555555555556, "length": 5}, "so_47437349_47440920_8": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_47437349_47440920_14": {"section_id": 5930, "quality": 0.6666666666666666, "length": 4}, "so_47437349_47440920_3": {"section_id": 3155, "quality": 0.9090909090909091, "length": 10}, "so_47437349_47440920_9": {"section_id": 359, "quality": 0.5652173913043478, "length": 13}, "so_47437349_47440920_4": {"section_id": 3155, "quality": 1.0, "length": 6}, "so_47437349_47440920_7": {"section_id": 3155, "quality": 1.0, "length": 9}, "so_47437349_47440920_18": {"section_id": 5943, "quality": 0.625, "length": 5}, "so_47437349_47440920_5": {"section_id": 3155, "quality": 0.8181818181818182, "length": 9}, "so_47437349_47440920_15": {"section_id": 5766, "quality": 0.8, "length": 4}, "so_47437349_47440920_10": {"section_id": 3156, "quality": 1.0, "length": 5}}, "n4659": {"so_47437349_47440920_6": {"section_id": 4047, "quality": 1.0, "length": 5}, "so_47437349_47447101_0": {"section_id": 454, "quality": 0.5555555555555556, "length": 5}, "so_47437349_47440920_0": {"section_id": 653, "quality": 0.8, "length": 4}, "so_47437349_47440920_1": {"section_id": 4047, "quality": 1.0, "length": 9}, "so_47437349_47440920_16": {"section_id": 4053, "quality": 0.7777777777777778, "length": 7}, "so_47437349_47440920_15": {"section_id": 4053, "quality": 0.8, "length": 4}, "so_47437349_47440920_14": {"section_id": 4053, "quality": 0.8333333333333334, "length": 5}, "so_47437349_47440920_19": {"section_id": 4053, "quality": 0.9333333333333333, "length": 28}, "so_47437349_47440920_9": {"section_id": 382, "quality": 0.5217391304347826, "length": 12}, "so_47437349_47440920_3": {"section_id": 4047, "quality": 0.8181818181818182, "length": 9}, "so_47437349_47440920_4": {"section_id": 4047, "quality": 1.0, "length": 6}, "so_47437349_47440920_12": {"section_id": 4053, "quality": 0.8297872340425532, "length": 39}, "so_47437349_47440920_7": {"section_id": 4047, "quality": 1.0, "length": 9}, "so_47437349_47440920_13": {"section_id": 4053, "quality": 0.8888888888888888, "length": 8}, "so_47437349_47440920_18": {"section_id": 4053, "quality": 1.0, "length": 8}, "so_47437349_47440920_5": {"section_id": 4047, "quality": 0.8181818181818182, "length": 9}, "so_47437349_47440920_20": {"section_id": 4053, "quality": 1.0, "length": 21}, "so_47437349_47440920_10": {"section_id": 4048, "quality": 1.0, "length": 5}}}, "47447101": {"ParentId": "47437349", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Bathsheba's answer correctly describes the letter of the C++ standard.  </p>\n<p>The bad news is that all modern compilers I have tested (GCC, Clang, MSVC, and ICC) all ignore the letter of the standard on this point.  They instead treat the bald statement in <a href=\"http://port70.net/~nsz/c/c11/n1570.html#J.2\" rel=\"nofollow noreferrer\">Annex J.2</a> to the C standard</p>\n<blockquote>\n<p id=\"so_47437349_47447101_0\">[the behavior is undefined if] the value of an object with automatic storage duration is used while it is indeterminate</p>\n</blockquote>\n<p>as if it were 100% normative, in both C and C++, even though Annex J is not normative.  This applies to <em>all</em> possible read accesses to uninitialized storage, including those carefully performed through <code>unsigned char *</code>, and, yes, including read accesses to padding bytes.</p>\n<p>Moreover, if you were to file a bug report, I am confident that you would be told that, to the extent the normative text of the standard does not agree with what they are doing, it is the <em>standard</em> that is defective.</p>\n<p>The <em>good</em> news is that you will only incur UB upon access to padding bytes if you <em>inspect</em> the contents of the padding bytes.  Copying them around is OK.  In particular, if you initialize all the named fields of a POD structure, it will be safe to copy it around by structure assignment and by <code>memcpy</code>, but it will <em>not</em> be safe to compare it to another such structure using <code>memcmp</code>.</p>\n", "OwnerUserId": "388520", "LastEditorUserId": "388520", "LastEditDate": "2017-11-23T03:35:22.693", "Id": "47447101", "Score": "0", "CreationDate": "2017-11-23T03:29:55.107", "LastActivityDate": "2017-11-23T03:35:22.693"}});