post_cb({"456630": {"PostTypeId": "2", "Body": "<p>Everyone else has explained why throwing destructors are terrible... what can you do about it?  If you're doing an operation that may fail, create a separate public method that performs cleanup and can throw arbitrary exceptions.  In most cases, users will ignore that.  If users want to monitor the success/failure of the cleanup, they can simply call the explicit cleanup routine.</p>\n<p>For example:</p>\n<pre><code>class TempFile {\npublic:\n    TempFile(); // throws if the file couldn't be created\n    ~TempFile() throw(); // does nothing if close() was already called; never throws\n    void close(); // throws if the file couldn't be deleted (e.g. file is open by another process)\n    // the rest of the class omitted...\n};\n</code></pre>\n", "OwnerDisplayName": "Tom", "LastActivityDate": "2009-01-19T05:39:54.597", "Id": "456630", "CommentCount": "0", "CreationDate": "2009-01-19T05:39:54.597", "ParentId": "130117", "Score": "4", "OwnerUserId": "40620"}, "29660507": {"PostTypeId": "2", "Body": "<p>Martin Ba (above) is on the right track- you architect differently for RELEASE and COMMIT logic.</p>\n<h2>For Release:</h2>\n<p>You should eat any errors. You're freeing memory, closing connections, etc. Nobody else in the system should ever SEE those things again, and you're handing back resources to the OS. If it looks like you need real error handling here, its likely a consequence of design flaws in your object model.</p>\n<h2>For Commit:</h2>\n<p>This is where you want the same kind of RAII wrapper objects that things like std::lock_guard are providing for mutexes. With those you don't put the commit logic in the dtor AT ALL. You have a dedicated API for it, then wrapper objects that will RAII commit it in THEIR dtors and handle the errors there. Remember, you can CATCH exceptions in a destructor just fine; its issuing them that's deadly. This also lets you implement policy and different error handling just by building a different wrapper (e.g. std::unique_lock vs. std::lock_guard), and ensures you won't forget to call the commit logic- which is the only half-way decent justification for putting it in a dtor in the 1st place.</p>\n", "LastActivityDate": "2015-04-15T20:42:07.097", "Id": "29660507", "CommentCount": "0", "CreationDate": "2015-04-15T20:42:07.097", "ParentId": "130117", "Score": "0", "OwnerUserId": "3726672"}, "4098662": {"Id": "4098662", "PostTypeId": "2", "Body": "<p>We have to <strong>differentiate</strong> here instead of blindly following <em>general</em> advice for <em>specific</em> cases.</p>\n<p>Note that the following <em>ignores</em> the issue of containers of objects and what to do in the face of multiple d'tors of objects inside containers. (And it can be ignored partially, as some objects are just no good fit to put into a container.)</p>\n<p>The whole problem becomes easier to think about when we split classes in two types. A class dtor can have two different responsibilities:</p>\n<ul>\n<li>(R) release semantics (aka free that memory)</li>\n<li>(C) <em>commit</em> semantics (aka <em>flush</em> file to disk)</li>\n</ul>\n<p>If we view the question this way, then I think that it can be argued that (R) semantics should never cause an exception from a dtor as there is a) nothing we can do about it and b) many free-resource operations do not even provide for error checking, e.g. <em><code>void</code></em> <code>free(void* p);</code>.</p>\n<p>Objects with (C) semantics, like a file object that needs to successfully flush it's data or a (\"scope guarded\") database connection that does a commit in the dtor are of a different kind: We <em>can</em> do something about the error (on the application level) and we really should not continue as if nothing happened.</p>\n<p>If we follow the RAII route and allow for objects that have (C) semantics in their d'tors I think we then also have to allow for the odd case where such d'tors can throw. It follows that you should not put such objects into containers and it also follows that the program can still <code>terminate()</code> if a commit-dtor throws while another exception is active.</p>\n<hr>\n<p>With regard to error handling (Commit / Rollback semantics) and exceptions, there is a good talk by one <a href=\"http://erdani.com/\" rel=\"nofollow noreferrer\">Andrei Alexandrescu</a>: <em><a href=\"http://vimeo.com/channels/ndc2014/97329153\" rel=\"nofollow noreferrer\">Error Handling in C++ / Declarative Control Flow</a></em> (held at <a href=\"http://www.ndcoslo.com/poster\" rel=\"nofollow noreferrer\">NDC 2014</a>)</p>\n<p>In the details, he explains how the Folly library implements an <a href=\"https://github.com/facebook/folly/blob/master/folly/detail/UncaughtExceptionCounter.h\" rel=\"nofollow noreferrer\"><code>UncaughtExceptionCounter</code></a> for their <a href=\"https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h\" rel=\"nofollow noreferrer\"><code>ScopeGuard</code></a> tooling.</p>\n<p>(I should note that <a href=\"https://github.com/panaseleus/stack_unwinding/\" rel=\"nofollow noreferrer\">others</a> also had similar ideas.)</p>\n<p>While the talk doesn't focus on throwing from a d'tor, it shows a tool that can be used <em>today</em> to get rid of the <a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"nofollow noreferrer\">problems with when to throw</a> from a d'tor. </p>\n<p>In the <strike>future</strike>, there <strike>may</strike> be a std feature for this, <strike>see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3614.pdf\" rel=\"nofollow noreferrer\">N3614</a>,</strike> and a <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-proposals/PCpJMgzla80/-grf1-ITAYUJ\" rel=\"nofollow noreferrer\">discussion about it</a>.</p>\n<p>Upd '17: The C++17 std feature for this is <a href=\"http://en.cppreference.com/w/cpp/error/uncaught_exception\" rel=\"nofollow noreferrer\"><code>std::uncaught_exceptions</code></a> afaikt. I'll quickly quote the cppref article:</p>\n<blockquote>\n<h3>Notes</h3>\n<p id=\"so_130117_4098662_0\">An example where <code>int</code>-returning <code>uncaught_exceptions</code> is used is ... ... first\n  creates a guard object and records the number of uncaught exceptions\n  in its constructor. The output is performed by the guard object's\n  destructor unless foo() throws (<em>in which case the number of uncaught\n  exceptions in the destructor is greater than what the constructor\n  observed</em>)</p>\n</blockquote>\n</hr>", "LastEditorUserId": "321013", "LastActivityDate": "2017-05-30T19:38:20.183", "CommentCount": "8", "CreationDate": "2010-11-04T16:07:37.493", "ParentId": "130117", "Score": "31", "OwnerUserId": "321013", "LastEditDate": "2017-05-30T19:38:20.183"}, "15062201": {"PostTypeId": "2", "Body": "<p>Set an alarm event. Typically alarm events are better form of notifying failure while cleaning up objects</p>\n", "LastActivityDate": "2013-02-25T07:42:25.230", "Id": "15062201", "CommentCount": "0", "CreationDate": "2013-02-25T07:42:25.230", "ParentId": "130117", "Score": "0", "OwnerUserId": "2103624"}, "bq_ids": {"n4140": {"so_130117_739424_0": {"length": 29, "quality": 0.7837837837837838, "section_id": 3345}}, "n3337": {"so_130117_739424_0": {"length": 29, "quality": 0.7837837837837838, "section_id": 3215}}}, "374875": {"PostTypeId": "2", "Body": "<p>Throwing out of a destructor can result in a crash, because this destructor might be called as part of \"Stack unwinding\".\nStack unwinding is a procedure which takes place when an exception is thrown.\nIn this procedure, all the objects that were pushed into the stack since the \"try\" and until the exception was thrown, will be terminated -&gt; their destructors will be called.\nAnd during this procedure, another exception throw is not allowed, because it's not possible to handle two exceptions at a time, thus, this will provoke a call to abort(), the program will crash and the control will return to the OS. </p>\n", "OwnerDisplayName": "Gal Goldman", "LastActivityDate": "2008-12-17T15:22:03.820", "Id": "374875", "CommentCount": "2", "CreationDate": "2008-12-17T15:22:03.820", "ParentId": "130117", "Score": "42", "OwnerUserId": "46418"}, "130117": {"ViewCount": "81466", "Body": "<p>Most people say <em>never</em> throw an exception out of a destructor - doing so results in undefined behavior. Stroustrup makes the point that <em>\"the vector destructor explicitly invokes the destructor for every element. This implies that if an element destructor throws, the vector destruction fails... There is really no good way to protect against exceptions thrown from destructors, so the library makes no guarantees if an element destructor throws\" (from Appendix E3.2)</em>.</p>\n<p><a href=\"http://www.kolpackov.net/projects/c++/eh/dtor-1.xhtml\" rel=\"noreferrer\">This article</a> seems to say otherwise - that throwing destructors are more or less okay.</p>\n<p><em>So my question is this - if throwing from a destructor results in undefined behavior, how do you handle errors that occur during a destructor?</em></p>\n<p>If an error occurs during a cleanup operation, do you just ignore it? If it is an error that can potentially be handled up the stack but not right in the destructor, doesn't it make sense to throw an exception out of the destructor?</p>\n<p>Obviously these kinds of errors are rare, but possible.</p>\n", "AcceptedAnswerId": "130123", "Title": "throwing exceptions out of a destructor", "CreationDate": "2008-09-24T21:34:01.177", "Id": "130117", "CommentCount": "14", "FavoriteCount": "91", "PostTypeId": "1", "LastEditDate": "2008-10-03T06:53:55.527", "LastEditorDisplayName": "Martin York", "OwnerDisplayName": "Greg Rogers", "LastEditorUserId": "14065", "LastActivityDate": "2017-09-14T14:50:31.203", "Score": "194", "OwnerUserId": "5963", "Tags": "<c++><exception><destructor><raii>", "AnswerCount": "15"}, "2470770": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_130117_2470770_0\">Q: So my question is this - if\n  throwing from a destructor results in\n  undefined behavior, how do you handle\n  errors that occur during a destructor?</p>\n</blockquote>\n<p>A: There are several options:</p>\n<ol>\n<li><p>Let the exceptions flow out of your destructor, regardless of what's going on elsewhere. And in doing so be aware (or even fearful) that std::terminate may follow.</p></li>\n<li><p>Never let exception flow out of your destructor. May be write to a log, some big red bad text if you can. </p></li>\n<li><p><em>my fave</em> : If <code>std::uncaught_exception</code> returns false, let you exceptions flow out. If it returns true, then fall back to the logging approach.</p></li>\n</ol>\n<p>But is it good to throw in d'tors?</p>\n<p>I agree with most of the above that throwing is best avoided in destructor, where it can be. But sometimes you're best off accepting it can happen, and handle it well. I'd choose 3 above. </p>\n<p>There are a few odd cases where its actually a <em>great idea</em> to throw from a destructor.\nLike the \"must check\" error code. This is a value type which is returned from a function. If the caller reads/checks the contained error code, the returned value destructs silently.\n<em>But</em>, if the returned error code has not been read by the time the return values goes out of scope, it will throw some exception, <em>from its destructor</em>.</p>\n", "LastActivityDate": "2010-03-18T14:57:57.800", "Id": "2470770", "CommentCount": "1", "CreationDate": "2010-03-18T14:57:57.800", "ParentId": "130117", "Score": "2", "OwnerUserId": "243879"}, "130178": {"Body": "<p>Its dangerous, but it also doesn't make sense from a readability/code understandability standpoint.</p>\n<p>What you have to ask is in this situation</p>\n<pre><code>int foo()\n{\n   Object o;\n   // As foo exits, o's destructor is called\n}\n</code></pre>\n<p>What should catch the exception? Should the caller of foo? Or should foo handle it? Why should the caller of foo care about some object internal to foo? There might be a way the language defines this to make sense, but its going to be unreadable and difficult to understand.</p>\n<p>More importantly, where does the memory for Object go? Where does the memory the object owned go? Is it still allocated (ostensibly because the destructor failed)? Consider also the object was in <em>stack space</em>, so its obviously gone regardless.</p>\n<p>Then consider this case</p>\n<pre><code>class Object\n{ \n   Object2 obj2;\n   Object3* obj3;\n   virtual ~Object()\n   {\n       // What should happen when this fails? How would I actually destroy this?\n       delete obj3;\n\n       // obj 2 fails to destruct when it goes out of scope, now what!?!?\n       // should the exception propogate? \n   } \n};\n</code></pre>\n<p>When the delete of obj3 fails, how do I actually delete in a way that is guaranteed to not fail? Its my memory dammit!</p>\n<p>Now consider in the first code snippet Object goes away automatically because its on the stack while Object3 is on the heap. Since the pointer to Object3 is gone, you're kind of SOL. You have a memory leak.</p>\n<p>Now one safe way to do things is the following</p>\n<pre><code>class Socket\n{\n    virtual ~Socket()\n    {\n      try \n      {\n           Close();\n      }\n      catch (...) \n      {\n          // Why did close fail? make sure it *really* does close here\n      }\n    } \n\n};\n</code></pre>\n<p>Also see this <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.3\" rel=\"noreferrer\">FAQ</a></p>\n", "CreationDate": "2008-09-24T21:48:07.740", "ParentId": "130117", "CommentCount": "1", "LastEditDate": "2008-11-10T01:14:52.007", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastActivityDate": "2008-11-10T01:14:51.990", "LastEditorUserId": "14065", "Id": "130178", "OwnerDisplayName": "Doug T.", "Score": "10", "OwnerUserId": "8123"}, "739424": {"PostTypeId": "2", "Body": "<p>From the ISO draft for C++ (ISO/IEC JTC 1/SC 22 N 4411)</p>\n<p><strong>So destructors should generally catch exceptions and not let them propagate out of the destructor.</strong></p>\n<blockquote>\n<p id=\"so_130117_739424_0\">3 The process of calling destructors for automatic objects constructed on the path from a try block to a throw-\n    expression is called \u201cstack unwinding.\u201d [ Note: If a destructor called during stack unwinding exits with an\n    exception, std::terminate is called (15.5.1). So destructors should generally catch exceptions and not let\n    them propagate out of the destructor. \u2014 end note ]</p>\n</blockquote>\n", "LastActivityDate": "2009-04-11T03:00:42.170", "Id": "739424", "CommentCount": "3", "CreationDate": "2009-04-11T03:00:42.170", "ParentId": "130117", "Score": "7", "OwnerUserId": "44434"}, "462851": {"PostTypeId": "2", "Body": "<p>As an addition to the main answers, which are good, comprehensive and accurate, I would like to comment about the article you reference - the one that says \"throwing exceptions in destructors is not so bad\".</p>\n<p>The article takes the line \"what are the alternatives to throwing exceptions\", and lists some problems with each of the alternatives. Having done so it concludes that because we can't find a problem-free alternative we should keep throwing exceptions. </p>\n<p>The trouble is is that none of the problems it lists with the alternatives are anywhere near as bad as the exception behaviour, which, let's remember, is \"undefined behaviour of your program\". Some of the author's objections include \"aesthetically ugly\" and \"encourage bad style\". Now which would you rather have? A program with bad style, or one which exhibited undefined behaviour?</p>\n", "OwnerDisplayName": "DJClayworth", "LastActivityDate": "2009-01-20T19:57:08.563", "Id": "462851", "CommentCount": "3", "CreationDate": "2009-01-20T19:57:08.563", "ParentId": "130117", "Score": "4", "OwnerUserId": "19276"}, "41429901": {"Id": "41429901", "PostTypeId": "2", "Body": "<p>I am in the group that considers that the \"scoped guard\" pattern throwing in the destructor is useful in many situations - particularly for unit tests. However, be aware that in C++11, throwing in a destructor results in a call to <code>std::terminate</code> since destructors are implicitly annotated with <code>noexcept</code>.</p>\n<p>Andrzej Krzemie\u0144ski has a great post on the topic of destructors that throw: </p>\n<ul>\n<li><a href=\"https://akrzemi1.wordpress.com/2011/09/21/destructors-that-throw/\" rel=\"nofollow noreferrer\">https://akrzemi1.wordpress.com/2011/09/21/destructors-that-throw/</a></li>\n</ul>\n<p>He points out that C++11 has a mechanism to override the default <code>noexcept</code> for destructors:</p>\n<blockquote>\n<p id=\"so_130117_41429901_0\">In C++11, a destructor is implicitly specified as <code>noexcept</code>. Even if you add no specification and define your destructor like this:</p>\n<pre><code>  class MyType {\n        public: ~MyType() { throw Exception(); }            // ...\n  };\n</code></pre>\n<p id=\"so_130117_41429901_1\">The compiler will still invisibly add specification <code>noexcept</code> to your destructor. And this means that the moment your destructor throws an exception, <code>std::terminate</code> will be called, even if there was no double-exception situation. If you are really determined to allow your destructors to throw, you will have to specify this explicitly; you have three options:</p>\n<ul>\n<li>Explicitly specify your destructor as <code>noexcept(false)</code>,</li>\n<li>Inherit your class from another one that already specifies its destructor as <code>noexcept(false)</code>.</li>\n<li>Put a non-static data member in your class that already specifies its destructor as <code>noexcept(false)</code>.</li>\n</ul>\n</blockquote>\n<p>Finally, if you do decide to throw in the destructor, you should always be aware of the risk of a double-exception (throwing while the stack is being unwind because of an exception). This would cause a call to <code>std::terminate</code> and it is rarely what you want. To avoid this behaviour, you can simply check if there is already an exception before throwing a new one using <code>std::uncaught_exception()</code>.</p>\n", "LastEditorUserId": "4660481", "LastActivityDate": "2017-01-02T16:23:19.813", "CommentCount": "0", "CreationDate": "2017-01-02T16:02:04.373", "ParentId": "130117", "Score": "1", "OwnerUserId": "4660481", "LastEditDate": "2017-01-02T16:23:19.813"}, "130152": {"PostTypeId": "2", "Body": "<p>The real question to ask yourself about throwing from a destructor is \"What can the caller do with this?\"  Is there actually anything useful you can do with the exception, that would offset the dangers created by throwing from a destructor?</p>\n<p>If I destroy a <code>Foo</code> object, and the <code>Foo</code> destructor tosses out an exception, what I can reasonably do with it?  I can log it, or I can ignore it.  That's all.  I can't \"fix\" it, because the <code>Foo</code> object is already gone.  Best case, I log the exception and continue as if nothing happened (or terminate the program).  Is that really worth potentially causing undefined behavior by throwing from a destructor?</p>\n", "OwnerDisplayName": "Derek Park", "LastActivityDate": "2008-09-24T21:42:05.417", "Id": "130152", "CommentCount": "1", "CreationDate": "2008-09-24T21:42:05.417", "ParentId": "130117", "Score": "18", "OwnerUserId": "872"}, "130145": {"PostTypeId": "2", "Body": "<p>Your destructor might be executing inside a chain of other destructors. Throwing an exception that is not caught by your immediate caller can leave multiple objects in an inconsistent state, thus causing even more problems then ignoring the error in the cleanup operation.</p>\n", "OwnerDisplayName": "francip", "LastActivityDate": "2008-09-24T21:41:01.173", "Id": "130145", "CommentCount": "0", "CreationDate": "2008-09-24T21:41:01.173", "ParentId": "130117", "Score": "6", "OwnerUserId": "17028"}, "19614326": {"PostTypeId": "2", "Body": "<p>Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation succeeded, exceptions should not be thrown in destructors.</p>\n<p>The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn\u2019t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately.</p>\n<p>Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead.</p>\n", "LastActivityDate": "2013-10-27T03:31:54.980", "Id": "19614326", "CommentCount": "0", "CreationDate": "2013-10-27T03:31:54.980", "ParentId": "130117", "Score": "0", "OwnerUserId": "1216931"}, "2182220": {"PostTypeId": "2", "Body": "<p>I currently follow the policy (that so many are saying) that classes shouldn't actively throw exceptions from their destructors but should instead provide a public \"close\" method to perform the operation that could fail...</p>\n<p>...but I do believe destructors for container-type classes, like a vector, should not mask exceptions thrown from classes they contain.  In this case, I actually use a \"free/close\" method that calls itself recursively.  Yes, I said recursively.  There's a method to this madness.  Exception propagation relies on there being a stack:  If a single exception occurs, then both the remaining destructors will still run and the pending exception will propagate once the routine returns, which is great.  If multiple exceptions occur, then (depending on the compiler) either that first exception will propagate or the program will terminate, which is okay.  If so many exceptions occur that the recursion overflows the stack then something is seriously wrong, and someone's going to find out about it, which is also okay.  Personally, I err on the side of errors blowing up rather than being hidden, secret, and insidious.</p>\n<p>The point is that the container remains neutral, and it's up to the contained classes to decide whether they behave or misbehave with regard to throwing exceptions from their destructors.</p>\n", "LastActivityDate": "2010-02-02T06:21:18.730", "Id": "2182220", "CommentCount": "0", "CreationDate": "2010-02-02T06:21:18.730", "ParentId": "130117", "Score": "1", "OwnerUserId": "264108"}, "130123": {"Body": "<p>Throwing an exception out of a destructor is dangerous.<br>\nIf another exception is already propagating the application will terminate.</br></p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Bad\n{\n    public:\n        // Added the noexcept(false) so the code keeps its original meaning.\n        // Post C++11 destructors are by default `noexcept(true)` and\n        // this will (by default) call terminate if an exception is\n        // escapes the destructor.\n        //\n        // But this example is designed to show that terminate is called\n        // if two exceptions are propagating at the same time.\n        ~Bad() noexcept(false)\n        {\n            throw 1;\n        }\n};\nclass Bad2\n{\n    public:\n        ~Bad2()\n        {\n            throw 1;\n        }\n};\n\n\nint main(int argc, char* argv[])\n{\n    try\n    {\n        Bad   bad;\n    }\n    catch(...)\n    {\n        std::cout &lt;&lt; \"Print This\\n\";\n    }\n\n    try\n    {\n        if (argc &gt; 3)\n        {\n            Bad   bad; // This destructor will throw an exception that escapes (see above)\n            throw 2;   // But having two exceptions propagating at the\n                       // same time causes terminate to be called.\n        }\n        else\n        {\n            Bad2  bad; // The exception in this destructor will\n                       // cause terminate to be called.\n        }\n    }\n    catch(...)\n    {\n        std::cout &lt;&lt; \"Never print this\\n\";\n    }\n\n}\n</code></pre>\n<p>This basically boils down to:</p>\n<p>Anything dangerous (i.e. that could throw an exception) should be done via public methods (not necessarily directly). The user of your class can then potentially handle these situations by using the public methods and catching any potential exceptions.</p>\n<p>The destructor will then finish off the object by calling these methods (if the user did not do so explicitly), but any exceptions throw are caught and dropped (after attempting to fix the problem).</p>\n<p>So in affect you pass the responsibility onto the user. If the user is in a position to correct exceptions they will manually call the appropriate functions and processes any errors. If the user of the object is not worried (as the object will be destroyed) then the destructor is left to take care of business.</p>\n<h1>An example:</h1>\n<p>std::fstream</p>\n<p>The close() method can potentially throw an exception.\nThe destructs calls close() if the file has been opened but makes sure that any exceptions do not propagate out of the destructor.</p>\n<p>So if the user of a file object wants to do special handling for problems associated to closing the file they will manually call close() and handle any exceptions. If on the other hand they do not care then the destructor will be left to handle the situation.</p>\n<p>Scott Myers has an excellent article about the subject in his book \"Effective C++\"  </p>\n<h3>Edit:</h3>\n<p>Apparently also in \"More Effective C++\"<br>\n<a href=\"http://bin-login.name/ftp/pub/docs/programming_languages/cpp/cffective_cpp/MEC/MI11_FR.HTM\" rel=\"nofollow noreferrer\">Item 11:  Prevent exceptions from leaving destructors</a></br></p>\n", "CreationDate": "2008-09-24T21:35:59.893", "ParentId": "130117", "CommentCount": "31", "LastEditDate": "2017-09-14T14:50:31.203", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastActivityDate": "2017-09-14T14:50:31.203", "LastEditorUserId": "14065", "Id": "130123", "OwnerDisplayName": "Martin York", "Score": "159", "OwnerUserId": "14065"}});