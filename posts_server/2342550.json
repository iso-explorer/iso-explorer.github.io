post_cb({"bq_ids": {"n4140": {"so_2342550_2342696_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 7043}, "so_2342550_2342696_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 275}, "so_2342550_2342696_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 7041}, "so_2342550_2342696_0": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_2342550_2342696_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 6788}, "so_2342550_2342696_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 266}, "so_2342550_2342696_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 6786}, "so_2342550_2342696_0": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_2342550_2342696_4": {"length": 34, "quality": 0.8095238095238095, "section_id": 8540}, "so_2342550_2342696_1": {"length": 18, "quality": 0.782608695652174, "section_id": 282}, "so_2342550_2342696_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 8538}, "so_2342550_2342696_0": {"length": 29, "quality": 1.0, "section_id": 275}}}, "2342566": {"Id": "2342566", "PostTypeId": "2", "Body": "<p>You need to actually assign a value to it.</p>\n<pre><code>template&lt;&gt; int B&lt;A, 1&gt;::a[1] = {0};\n</code></pre>\n", "LastActivityDate": "2010-02-26T15:15:02.677", "CommentCount": "3", "CreationDate": "2010-02-26T15:15:02.677", "ParentId": "2342550", "Score": "1", "OwnerUserId": "224671"}, "2342696": {"Id": "2342696", "PostTypeId": "2", "Body": "<p>For static member specializations, if you don't initialize the member, it is taken as a specialization <em>declaration</em>, that just says \"Oh, don't instantiate the member from the primary template, because there is a specialized definition somewhere else\". It should be mentioned that the definition should appear in a .cpp file (otherwise, you will earn the opposite: multiple definitions), and the declaration without initializer should still be placed in the header file. </p>\n<p>Now the correct syntax is indeed the following, and it should <em>not</em> appear in a header file, but in a <code>.cpp</code> file</p>\n<pre><code>template&lt;&gt; int B&lt;A, 1&gt;::a[1] = { };\n</code></pre>\n<p>The following should still appear in a header file:</p>\n<pre><code>template&lt;&gt; int B&lt;A, 1&gt;::a[1];\n</code></pre>\n<p>This will serve as the specialization <em>declaration</em>.</p>\n<hr>\n<p>From this, it follows that you can't specialize a member that only has a default constructor and is not copyable, because you would need this syntax:</p>\n<pre><code>// needs a copy constructor!\ntemplate&lt;&gt; Type Class&lt;Arguments&gt;::member = Type();\n</code></pre>\n<p>C++0x fixes this:</p>\n<pre><code>// doesn't anymore need a copy constructor\ntemplate&lt;&gt; Type Class&lt;Arguments&gt;::member{};\n</code></pre>\n<hr>\n<p>For the Standardese people among us, here are the quotes:</p>\n<p><code>14.7.3/6</code>:</p>\n<blockquote>\n<p id=\"so_2342550_2342696_0\">If a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. </p>\n</blockquote>\n<p><code>14.7.3/15</code>:</p>\n<blockquote>\n<p id=\"so_2342550_2342696_1\">An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. [Note: there is no syntax for the definition of a static data member of a template that requires default initialization. </p>\n<pre><code>template&lt;&gt; X Q&lt;int&gt;::x;\n</code></pre>\n<p id=\"so_2342550_2342696_2\">This is a declaration regardless of whether X can be default initialized (8.5). ]</p>\n</blockquote>\n<p><code>3.2/3</code>:</p>\n<blockquote>\n<p id=\"so_2342550_2342696_3\">Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required. </p>\n</blockquote>\n<p><code>3.2/5</code>:</p>\n<blockquote>\n<p id=\"so_2342550_2342696_4\">There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (clause 14), non-static function template (14.5.5), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.4) in a program [...]</p>\n</blockquote>\n<p>The restriction of this to \"for which some template parameters are not specified\" means that we <em>are</em> allowed to do the following, placing it into a header (thus possibly having multiple definitions of this specialization):</p>\n<pre><code>template&lt;&gt; template&lt;typename T&gt;\nType OuterClass&lt;int&gt;::InnerClass&lt;T&gt;::StaticMember = 0;\n</code></pre>\n<p>In your case, you have all parameters specified, making it not being covered by the one defintion rule for allowing multiple definitions.</p>\n</hr></hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-02-26T16:00:41.537", "Score": "32", "CreationDate": "2010-02-26T15:32:32.150", "ParentId": "2342550", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2010-02-26T16:00:41.537"}, "2342550": {"ViewCount": "13456", "Body": "<pre><code>class A\n{\n};\n\ntemplate &lt;typename A, int S&gt;\nclass B\n{\npublic:\n        static int a[S];\n\n        B()\n        {\n                a[0] = 0;\n        }\n};\n\ntemplate&lt;&gt; int B&lt;A, 1&gt;::a[1];\n\nint main()\n{\n        B&lt;A, 1&gt; t;\n        t;\n}\n</code></pre>\n<p>It compiles under GCC 4.1, but does not link:</p>\n<pre><code>static.cpp:(.text._ZN1BI1ALi1EEC1Ev[B&lt;A, 1&gt;::B()]+0x5): undefined reference to `B&lt;A, 1&gt;::a'\n</code></pre>\n<p>I would prefer to keep initialisation specialised if it is possible, since the array holds some data specific to the type.</p>\n", "Title": "static member initialization for specialized template class", "CreationDate": "2010-02-26T15:11:12.980", "LastActivityDate": "2010-02-26T16:00:41.537", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "Id": "2342550", "Score": "13", "OwnerUserId": "282133", "Tags": "<c++><static><templates><initialization><specialization>", "AnswerCount": "3"}, "2342627": {"Id": "2342627", "PostTypeId": "2", "Body": "<p>It does not link because you don't define a value to your static member.</p>\n<pre><code>template&lt;&gt; int B&lt;A, 1&gt;::a[] = { 0 };\n</code></pre>\n<hr>\n<p>Edit:</p>\n<p>Btw: I would always prefer to use boost::array instead of native C-types:</p>\n<pre><code>class A { };\n\ntemplate &lt;typename A, std::size_t S&gt;\nclass B\n{\npublic:\n    static boost::array&lt;int, S&gt; a;\n\n    B() { a[0] = 0; }\n};\n\ntemplate&lt;&gt;  boost::array&lt;int, 1&gt; B&lt;A, 1&gt;::a = { };\n\nint main()\n{\n    B&lt;A, 1&gt; t;\n    cout &lt;&lt; t.a[0] &lt;&lt; endl;\n}\n</code></pre>\n</hr>", "LastEditorUserId": "112736", "LastActivityDate": "2010-02-26T15:45:58.780", "Score": "0", "CreationDate": "2010-02-26T15:23:32.047", "ParentId": "2342550", "CommentCount": "0", "OwnerUserId": "112736", "LastEditDate": "2010-02-26T15:45:58.780"}});