post_cb({"bq_ids": {"n4140": {"so_27303650_27304057_0": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_27303650_27303980_4": {"length": 64, "quality": 0.927536231884058, "section_id": 3296}, "so_27303650_27303980_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5418}, "so_27303650_27303980_1": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_27303650_27304057_2": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_27303650_27304057_1": {"length": 44, "quality": 0.8979591836734694, "section_id": 3299}, "so_27303650_27303980_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 5425}}, "n3337": {"so_27303650_27304057_0": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_27303650_27303980_4": {"length": 64, "quality": 0.927536231884058, "section_id": 3166}, "so_27303650_27303980_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5213}, "so_27303650_27304057_2": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_27303650_27303980_3": {"length": 17, "quality": 0.7391304347826086, "section_id": 5220}, "so_27303650_27304057_1": {"length": 44, "quality": 0.8979591836734694, "section_id": 3169}}, "n4659": {"so_27303650_27304057_0": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_27303650_27303980_4": {"length": 56, "quality": 0.8115942028985508, "section_id": 4058}, "so_27303650_27303980_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6840}, "so_27303650_27303980_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_27303650_27304057_2": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_27303650_27304057_1": {"length": 37, "quality": 0.7551020408163265, "section_id": 4065}}}, "27303650": {"ViewCount": "443", "Body": "<p>I have a class with a <code>constexpr</code> value constructor, but no copy or move ctor</p>\n<pre><code>class  C {\n    public:\n        constexpr C(int) { }\n        C(const C&amp;) = delete;\n        C&amp; operator=(const C&amp;) = delete;\n};\n\nint main() {\n    constexpr C arr[] = {1, 2};\n}\n</code></pre>\n<p>I've found that this code doesn't work because it's actually trying to use the move constructor for <code>C</code> rather than the value constructor to construct in place.  One issue is that I want this object to be unmovable (for test purposes) but I thought \"okay, fine, I'll add a move constructor.\"</p>\n<pre><code>class  C {\n    public:\n        constexpr C(int) { }\n        C(const C&amp;) = delete;\n        C&amp; operator=(const C&amp;) = delete;\n        C&amp; operator=(C&amp;&amp;) = delete;\n\n        C(C&amp;&amp;) { /*something*/ } // added, assume this must be non trivial\n};\n</code></pre>\n<p>Okay fine, now it uses the move constructor and everything works <strong>under gcc</strong> but when I use clang, it complains because the move constructor is not marked <code>constexpr</code></p>\n<pre><code>error: constexpr variable 'arr' must be initialized by a constant expression\n    constexpr C arr[] = {1, 2};\n</code></pre>\n<p>If I mark the move constructor <code>constexpr</code> it works under gcc and clang, but the issue is that I want to have code in the move constructor if it runs at all, and constexpr constructors must have empty bodies.  (The reason for my having code in the move ctor isn't worth getting into).</p>\n<p>So who is right here? My inclination is that clang would be correct for rejecting the code.</p>\n<p><strong>NOTE</strong></p>\n<p>It does compile with initializer lists and non-copyable non-movable objects as below:</p>\n<pre><code>class  C {\n    public:\n        constexpr C(int) { }\n        C(const C&amp;) = delete;\n        C&amp; operator=(const C&amp;) = delete;\n        C&amp; operator=(C&amp;&amp;) = delete;\n        C(C&amp;&amp;) = delete;\n\n};\n\nint main() {\n    constexpr C arr[] = {{1}, {2}};\n}\n</code></pre>\n<p>My main concern is which compiler above is correct.</p>\n", "AcceptedAnswerId": "27303980", "Title": "constexpr array of constexpr objects using move ctor", "CreationDate": "2014-12-04T20:41:42.543", "Id": "27303650", "CommentCount": "1", "LastEditDate": "2014-12-04T21:04:40.947", "PostTypeId": "1", "LastEditorUserId": "1013719", "LastActivityDate": "2014-12-04T22:54:24.557", "Score": "9", "OwnerUserId": "1013719", "Tags": "<c++><c++11><c++14><constexpr>", "AnswerCount": "2"}, "27303980": {"Id": "27303980", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27303650_27303980_0\">So who is right here?</p>\n</blockquote>\n<p>Clang is correct in rejecting the code. [expr.const]/2:</p>\n<blockquote>\n<p id=\"so_27303650_27303980_1\">A <em>conditional-expression</em> <code>e</code> is a core constant expression unless\n  the evaluation of <code>e</code>, following the rules of the abstract machine\n  (1.9), would evaluate one of the following expressions:</p>\n<ul>\n<li>an invocation of a function other than a <code>constexpr</code> constructor for a literal class, a <code>constexpr</code> function, or an implicit invocation\n  of a trivial destructor (12.4)</li>\n</ul>\n</blockquote>\n<p>Clearly your move constructor isn't a <code>constexpr</code> constructor - [dcl.constexpr]/2</p>\n<blockquote>\n<p id=\"so_27303650_27303980_2\">Similarly, a <code>constexpr</code> specifier used in a constructor declaration\n  declares that constructor to be a <code>constexpr</code> constructor.</p>\n</blockquote>\n<p>And the requirements for an initializer of a <code>constexpr</code> object are in [dcl.constexpr]/9:</p>\n<blockquote>\n<p id=\"so_27303650_27303980_3\">[\u2026] every full-expression that appears in its initializer shall be a\n  constant expression. [ <em>Note</em>: <strong>Each implicit conversion u</strong>sed in\n  converting the initializer expressions and each constructor call used\n  for the initialization is part of such a full-expression. \u2014 <em>end note</em>\n  ]</p>\n</blockquote>\n<p>Finally the move constructor is invoked by  the copy-initialization of the array elements with the corresponding initializer-clauses - [dcl.init]:</p>\n<blockquote>\n<p id=\"so_27303650_27303980_4\">Otherwise (i.e., for the remaining copy-initialization cases),\n  user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; <strong>if the function is a constructor, the\n  call initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization.</strong></p>\n</blockquote>\n<p>In the second example, <em>copy-list-initialization</em> applies - <a href=\"https://stackoverflow.com/q/26964221/3647361\">and no temporary is introduced</a>.</p>\n<p>By the way: <a href=\"http://coliru.stacked-crooked.com/a/a5e581d4d6448d5e\" rel=\"nofollow noreferrer\"><strong>GCC 4.9 does not compile the above</strong></a>, even without any warning flags provided.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-04T22:54:24.557", "Score": "3", "CreationDate": "2014-12-04T21:00:37.247", "ParentId": "27303650", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2017-05-23T12:01:52.157"}, "27304057": {"Id": "27304057", "PostTypeId": "2", "Body": "<p>\u00a78.5 [dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_27303650_27304057_0\">The semantics of initializers are as follows. The destination type is\n  the type of the object or reference being initialized and the source\n  type is the type of the initializer expression. If the initializer is\n  not a single (possibly parenthesized) expression, the source type is\n  not defined.</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n<li>[...]</li>\n<li>If the destination type is a (possibly cv-qualified) class type:\n  <ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source\n  type is the same class as, or a derived class of, the class of the\n  destination, [...]</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; if the function is a constructor, the call\n  initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization. In certain cases, an\n  implementation is permitted to eliminate the copying inherent in this\n  direct-initialization by constructing the intermediate result directly\n  into the object being initialized; see 12.2, 12.8.</li>\n</ul></li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>\u00a78.5.1 [dcl.init.aggr]/p2:</p>\n<blockquote>\n<p id=\"so_27303650_27304057_1\">When an aggregate is initialized by an initializer list, as specified\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is copy-initialized from the\n  corresponding <em>initializer-clause</em>. If the <em>initializer-clause</em> is an\n  expression and a narrowing conversion (8.5.4) is required to convert\n  the expression, the program is ill-formed. [ <em>Note</em>: If an\n  <em>initializer-clause</em> is itself an initializer list, the member is\n  list-initialized, which will result in a recursive application of the\n  rules in this section if the member is an aggregate. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>\u00a78.5.4 [dcl.init.list]/p3:</p>\n<blockquote>\n<p id=\"so_27303650_27304057_2\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n<ul>\n<li>If T is an aggregate, aggregate initialization is performed (8.5.1).</li>\n<li>[...]</li>\n<li>Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>For <code>constexpr C arr[] = {1, 2};</code>, aggregate initialization copy-initializes each element from the corresponding <em>initializer-clause</em>, i.e., <code>1</code> and <code>2</code>. As described in \u00a78.5 [dcl.init]/p17, this constructs a temporary <code>C</code> and then direct-initializes the array element from the temporary, which requires an accessible copy or move constructor. (The copy/move can be elided, but the constructor must still be available.)</p>\n<p>For <code>constexpr C arr[] = {{1}, {2}};</code>, the elements are <em>copy-list-initialized</em> instead, which does not construct temporaries (note the absence of any mention of a temporary being constructed in \u00a78.5.4 [dcl.init.list]/p3).</p>\n", "LastActivityDate": "2014-12-04T21:05:30.737", "CommentCount": "0", "CreationDate": "2014-12-04T21:05:30.737", "ParentId": "27303650", "Score": "3", "OwnerUserId": "2756719"}});