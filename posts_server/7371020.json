post_cb({"7371037": {"Id": "7371037", "PostTypeId": "2", "Body": "<p>Built In data types(fundamental types, arrays,references, pointers, and enums) do not have constructors.   </p>\n<p>A constructor is a member function. A member function can only be defined for a class type </p>\n<p><strong>C++03 9.3/1:</strong></p>\n<p><em>\"Functions declared in the definition of a class, excluding those declared with a friend specifier, are called member functions of that class\".</em></p>\n<hr>\n<p>Many a times usage of an POD type in certain syntax's(given below) might give an impression that they are constructed using constructors or copy constructors but it just Initialization without any of the two.</p>\n<pre><code>int x(5);  \n</code></pre>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2011-09-10T10:22:27.277", "Score": "0", "CreationDate": "2011-09-10T10:13:28.137", "ParentId": "7371020", "CommentCount": "3", "OwnerUserId": "452307", "LastEditDate": "2011-09-10T10:22:27.277"}, "7371020": {"ViewCount": "1294", "Body": "<blockquote>\n<p id=\"so_7371020_7371020_0\">Constructors build objects from dust.</p>\n</blockquote>\n<p>This is a statement which I have been coming across many times,recently.</p>\n<p>While initializing a built-in datatype variable, the variable also HAS to be \"built from dust\" . So, are there also constructors for built in types?</p>\n<p>Also, how does the compiler treat a BUILT IN DATATYPE and a USER DEFINED CLASS differently, while creating instances for each?\nI mean details regarding constructors, destructors etc.</p>\n<p>This query on stack overflow is regarding the same and it has some pretty intresting details , most intresting one being what Bjarne said ... !</p>\n<p><a href=\"https://stackoverflow.com/questions/5113365/do-built-in-types-have-default-constructors\">Do built-in types have default constructors?</a></p>\n", "AcceptedAnswerId": "7371200", "Title": "Built-in datatypes versus User defined datatypes in C++", "CreationDate": "2011-09-10T10:09:47.543", "Id": "7371020", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:43:21.253", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-10T12:57:19.910", "Score": "2", "OwnerUserId": "2666601", "Tags": "<c++><constructor>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_7371020_7371035_3": {"length": 9, "quality": 1.0, "section_id": 5845}, "so_7371020_7371035_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 5845}, "so_7371020_7371035_1": {"length": 6, "quality": 1.0, "section_id": 367}}, "n3337": {"so_7371020_7371035_1": {"length": 6, "quality": 1.0, "section_id": 356}, "so_7371020_7371035_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 5615}, "so_7371020_7371035_3": {"length": 9, "quality": 1.0, "section_id": 5615}}, "n4659": {"so_7371020_7371035_1": {"length": 6, "quality": 1.0, "section_id": 379}, "so_7371020_7371035_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 7324}, "so_7371020_7371035_3": {"length": 9, "quality": 1.0, "section_id": 7324}}}, "7371200": {"Id": "7371200", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7371020_7371200_0\">While initializing a built-in datatype variable, the variable also HAS to be \"built from dust\" . So, are there also constructors for built in types?</p>\n</blockquote>\n<p>Per request, I am rebuilding my answer from dust.</p>\n<p>I'm not particularly fond of that \"Constructors build objects from dust\" phrase. It is a bit misleading.</p>\n<p>An object, be it a primitive type, a pointer, or a instance of a big class, occupies a certain <em>known</em> amount of memory. That memory must somehow be set aside for the object. In some circumstances, that set-aside memory is initialized. That initialization is what constructors do. They do not set aside (or allocate) the memory needed to store the object. That step is performed before the constructor is called.</p>\n<p>There are times when a variable does not have to be initialized. For example,</p>\n<pre><code>int some_function (int some argument) {\n  int index;\n  ...\n}\n</code></pre>\n<p>Note that <code>index</code> was not assigned a value. On entry to <code>some_function</code>, a chunk of memory is set aside for the variable <code>index</code>. This memory already exists somewhere; it is just set aside, or allocated. Since the memory already exists somewhere, each bit will have some pre-existing value. If a variable is not initialized, it will have an initial value. The initial value of the variable <code>index</code> might be 42, or 1404197501, or something entirely different.</p>\n<p>Some languages provide a default initialization in case the programmer did not specify one. (C and C++ do not.) Sometimes there is nothing wrong with not initializing a variable to a known value. The very next statement might be an assignment statement, for example. The upside of providing a default initialization is that failing to initialize variables is a typical programming mistake. The downside is that this initialization has a cost, albeit typically tiny. That tiny cost can be significant when it occurs in a time-critical, multiply-nested loop. Not providing a default initial value fits the C and C++ philosophy of not providing something the programmer did not ask for.</p>\n<p>Some variables, even non-class variables, absolutely do need to be given an initial value. For example, there is no way to assign a value to a variable that is of a reference type except in the declaration statement. The same goes for variables that are declared to be constant.</p>\n<p>Some classes have hidden data that absolutely do need to be initialized. Some classes have <code>const</code> or reference data members that absolutely do need to be initialized. These classes need to be initialized, or constructed. Not all classes do need to be initialized. A class or structure that  doesn't have any virtual functions, doesn't have an explicitly-provided constructor or destructor, and whose member data are all primitive data types, is called plain old data, or POD. POD classes do not need to be constructed.</p>\n<p>Bottom line:</p>\n<ul>\n<li>An object, whether it is a primitive type or an instance of a very complex class, is not \"built from dust\". Dust is, after all, very harmful to computers. They are built from bits.</li>\n<li>Setting aside, or allocating, memory for some object and initializing that set-aside memory are two different things.</li>\n<li>The memory need to store an object is allocated, not created. The memory already exists. Because that memory already exists, the bits that comprise the object will have some pre-existing values. You should of course never rely on those preexisting values, but they are there.</li>\n<li>The reason for initializing variables, or data members, is to give them a reliable, known value. Sometimes that initialization is just a waste of CPU time. If you didn't ask the compiler to provide such a value, C and C++ assume the omission is intentional.</li>\n<li>The constructor for some object does not allocate the memory needed to store the object itself. That step has already been done by the time the constructor is called. What a constructor does do is to initialize that already allocated memory.</li>\n</ul>\n<p>The initial response:</p>\n<p><strike>A variable of a primitive type does not have to be \"built from dust\". The memory to store the variable needs to be allocated, but the variable can be left uninitialized. A constructor does not build the object from dust. A constructor does not allocate the memory needed to store the to-be constructed object. That memory has already been allocated by the time the constructor is called. (A constructor might initialize some pointer data member to memory allocated by the constructor, but the bits occupied by that pointer must already exist.)</strike></p>\n<p>Some objects such as primitive types and POD classes do not necessarily need to be initialized. Declare a non-static primitive type variable without an initial value and that variable will be uninitialized. The same goes for POD classes. Suppose you know you are going to assign a value to some variable before the value of the variable is accessed. Do you need to provide an initial value? No.</p>\n<p>Some languages do give an initial value to every variable. C and C++ do not. If you didn't ask for an initial value, C and C++ are not going to force an initial value on the variable.  That initialization has a cost, typically tiny, but it exists.</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2011-09-10T12:36:18.520", "Score": "1", "CreationDate": "2011-09-10T10:52:23.793", "ParentId": "7371020", "CommentCount": "3", "OwnerUserId": "774499", "LastEditDate": "2011-09-10T12:36:18.520"}, "7371035": {"Id": "7371035", "PostTypeId": "2", "Body": "<p>Simply put, according to the C++ standard:</p>\n<blockquote>\n<p id=\"so_7371020_7371035_0\"><strong>12.1 Constructors [class.ctor]</strong></p>\n<p id=\"so_7371020_7371035_1\"><em>2.</em> A constructor is used to initialize objects of its class type...</p>\n</blockquote>\n<p>so no, built-in datatypes (assuming you're talking about things like <code>int</code>s and <code>float</code>s) do not have constructors because they are not class types. Class types are are specified as such:</p>\n<blockquote>\n<p id=\"so_7371020_7371035_2\"><strong>9 Classes [class]</strong></p>\n<p id=\"so_7371020_7371035_3\"><em>1.</em> A class is a type. Its name becomes a <em>class-name</em> (9.1) within\n  its scope.</p>\n</blockquote>\n<pre>\n        class-name:\n                identifier\n                template-id\n</pre>\n<blockquote>\n<p id=\"so_7371020_7371035_4\"><em>Class-specifiers</em> and <em>elaborated-type-specifiers</em> (7.1.5.3) are used\n  to make <em>class-names</em>. An object of a class consists of a (possibly\n  empty) sequence of members and base class objects.</p>\n</blockquote>\n<pre>\n        class-specifier:\n                class-head { member-specification (opt) }\n\n        class-head:\n                class-key identifieropt base-clauseopt\n                class-key nested-name-specifier identifier base-clauseopt\n                class-key nested-name-specifieropt template-id base-clauseopt\n\n        class-key:\n                class\n                struct\n                union\n</pre>\n<p>And since the built-in types are not declared like that, they cannot be class types.</p>\n<p>So how are instances of built-in types created? The general process of bringing built-in and class instances into existance is called <em>initialization</em>, for which there's a huge 8-page section in the C++ standard (8.5) that lays out in excruciating detail about it. <a href=\"https://stackoverflow.com/questions/5999522/c-default-constructor/5999549#5999549\">Here's some of the rules</a> you can find in section 8.5.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-10T10:39:00.590", "Score": "5", "CreationDate": "2011-09-10T10:13:17.790", "ParentId": "7371020", "CommentCount": "2", "OwnerUserId": "308661", "LastEditDate": "2017-05-23T12:29:09.360"}, "7371054": {"Id": "7371054", "PostTypeId": "2", "Body": "<p>As already mentioned, built-in data types don't have constructors.</p>\n<p>But you still can use construction-like initialization syntax, like in <code>int i(3)</code>, or <code>int i = int()</code>. As far as I know that was introduced to language to better support generic programming, i.e. to be able to write</p>\n<pre><code>template &lt;class T&gt;\nT f() { T t = T(); }\n\nf(42);\n</code></pre>\n", "LastActivityDate": "2011-09-10T10:18:35.540", "CommentCount": "1", "CreationDate": "2011-09-10T10:18:35.540", "ParentId": "7371020", "Score": "2", "OwnerUserId": "104451"}});