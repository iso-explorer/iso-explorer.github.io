post_cb({"45648286": {"Id": "45648286", "PostTypeId": "2", "Body": "<p><strong>std::basic_ios::clear</strong></p>\n<pre><code>void clear( std::ios_base::iostate state = std::ios_base::goodbit ); \n</code></pre>\n<p>Sets the stream error state flags by assigning them the value of <code>state</code>. By default, assigns <code>std::ios_base::goodbit</code> which has the effect of clearing all error state flags. </p>\n<p>If <code>rdbuf()</code>  is a null pointer (i.e. there is no associated stream buffer),  then <code>state | badbit</code> is assigned. May throw an exception. </p>\n<p>Essentially in this case to set bit means that it sets bit to <em>clear</em> state.</p>\n<p>If you call clear without parameters, it sets all bits to clear state, by setting \"goodbit\", which is exclusive with other states. If you mark only certain bit, only that bit will will be set, clearing other bits ( and good bit as well). Anyway, as said above, if during call of this method input buffer of  stream is not valid, then <code>clear()</code> also   sets <code>badbit</code> to true, so method <code>good()</code> and <code>operator bool</code> will return <code>false</code> and <code>fail()</code> will still return <code>true</code>. </p>\n<p>To wit, why one need to clear those bits but keep a error state is depends on  further code, often it is to be able to detect that  error happened , but being able to request more data from stream (ask for correct input?)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt; \n#include &lt;string&gt; \nint main() {\n    using std::cout;\n    using std::cin;\n\n    int a;\n    do\n    {\n        cout &lt;&lt; \" Please enter an integer number:\";\n        cin.clear();\n        cin &gt;&gt; a;\n        if(cin.fail())\n        {\n            cout &lt;&lt; \"Error occured while parsing input.\\n\";\n            cin.clear(std::istream::failbit);\n        }\n\n\n        // do something\n\n        if(cin.fail())\n        {\n            std::string str;\n                    //now clear everything,  to unlock the input.\n            cin.clear(); \n            cin &gt;&gt; str;\n            cout &lt;&lt; \"Wrong input was: \" &lt;&lt; str &lt;&lt; \"\\n\";\n            cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n                    // setting fail bit again, so   loop will go on\n            cin.clear(std::istream::failbit);\n        }\n\n    } while(cin.fail());\n    cout &lt;&lt; \"Thank you!\";\n}\n</code></pre>\n<p>Without calling <code>::clear(std::istream::failbit)</code> and <code>::ignore</code> the loop would  be working forever, because state of the flags and buffer would force an attempt to parse same buffer content over and over. Actually, a that point you may  try to reparse it , e.g. read the string and print it. It would be ok to call  just <code>clear()</code> but then we need to create own flag that would  allow us to react correctly. </p>\n<p>The \"state\" of stream is a private field of type <code>std::ios_base::iostate</code>, which value is equal to a binary combination of it <code>eofbit</code>, <code>badbit</code>, and <code>failbit</code> constants.  <code>goodbit</code> constant is equal to zero and represents no-error state. Two accessors that provide  read and write operations to this field:</p>\n<pre><code>void setstate( iostate state );\niostate rdstate() const;\n</code></pre>\n<p>Note, <code>setstate(state)</code> got effect of <code>clear(rdstate() | state)</code>, which means that if <code>clear</code> can set exact value of iostate, setstate can only set new bits to true, but can't  clear bits that already set.</p>\n<pre><code>int main()\n{\n  std::ostringstream stream;\n\n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout &lt;&lt; \"stream state is goodbit\\n\";\n  }\n\n  stream.setstate(std::ios_base::eofbit);\n\n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout &lt;&lt; \"stream state is eofbit\\n\";\n  }\n}\n</code></pre>\n<p>for each bit there are accessors: <code>fail()</code>, <code>bad()</code>, <code>eof()</code>, <code>good()</code>.\nEssentially, <code>fail()</code> returns true if  <code>(rdstate()|std::ios_base::failbit) != 0</code>, and so on (See 30.5.5.4 basic_ios flags functions, ISO/IEC 14882:2017, Programming\nLanguages \u2014 C++)</p>\n<ul>\n<li><code>operator bool</code> is defined  and returns <code>good()</code></li>\n<li><code>operator!</code> is defined and returns <code>!good()</code></li>\n</ul>\n<p>The line</p>\n<pre><code>if (stream.rdstate() == std::ios_base::goodbit)\n</code></pre>\n<p>can be replaced by</p>\n<pre><code>if (stream)\n</code></pre>\n<p>because the latter results in contextual conversion to <code>bool</code>.</p>\n<p>Effects, associated with <code>iostate</code>'s bits (according to ISO C++):</p>\n<blockquote id=\"so_45647977_45648286_0\">\n<ul>\n<li><em>badbit</em> indicates a loss of integrity in an input or output sequence (such as an irrecoverable read error from a file);</li>\n<li><em>eofbit</em> indicates that an input operation reached the end of an input sequence;</li>\n<li><em>failbit</em> indicates that an input operation failed to read the expected characters, or that an output operation failed to generate\n  the desired characters.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2017-08-17T13:07:34.593", "Score": "1", "CreationDate": "2017-08-12T08:40:36.853", "ParentId": "45647977", "CommentCount": "6", "OwnerUserId": "2742717", "LastEditDate": "2017-08-17T13:07:34.593"}, "bq_ids": {"n4140": {"so_45647977_45648286_0": {"length": 34, "quality": 1.0, "section_id": 1946}}, "n3337": {"so_45647977_45648286_0": {"length": 34, "quality": 1.0, "section_id": 1935}}, "n4659": {"so_45647977_45648286_0": {"length": 34, "quality": 1.0, "section_id": 2217}}}, "45647977": {"ViewCount": "174", "Body": "<p>In C++ primer I found this code:</p>\n<pre><code> if (cin.fail())\n { // bad input\n      cerr&lt;&lt; \"bad data, try again\"; // warn the user\n      cin.clear(istream::failbit); // reset the stream\n      continue; // get next input\n }\n</code></pre>\n<p>I am confused that why the <code>istream::failbit</code> is used to set the error state flag, I mean that since the error has occurred (hence the flow is right now in <strong>if</strong> block then the failbit must be set, they why use it to set the error flag with that again. Where am I wrong in understanding this? </p>\n<p>EDIT:\nThe book says \"We print a warning and clear the <em>failbit</em> state\", but IMO clear(istream::failbit) is setting the current state of <strong>stream</strong> with the value contained in failbit. So why the book is setting the stream's state with that of failbit as it will stop <strong>cin</strong> from functioning as it will be in error state. <strong>++++</strong> By state of a stream, what bit actually is being talked about, is it eofbit, badbit, goodbit, failbit or a combination of them? How can I know the value of these individual bit as well?</p>\n", "AcceptedAnswerId": "45648286", "Title": "Clarification regarding use of flagbit to set internal error flag", "CreationDate": "2017-08-12T08:04:43.207", "Id": "45647977", "CommentCount": "6", "LastEditDate": "2017-08-14T14:26:40.307", "PostTypeId": "1", "LastEditorUserId": "7939838", "LastActivityDate": "2017-08-17T13:07:34.593", "Score": "8", "OwnerUserId": "7939838", "Tags": "<c++><io>", "AnswerCount": "1"}});