post_cb({"31410986": {"ParentId": "31410933", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-07-14T15:30:24.850", "Score": "10", "LastEditorUserId": "1708801", "LastEditDate": "2015-07-23T20:19:49.220", "Id": "31410986", "OwnerUserId": "1708801", "Body": "<p>The base issue isn't directly related to relaxed constexpr rules, a constexpr function is only a constant expression if the arguments are constant expressions. In your second case:</p>\n<pre><code>int array[std::max(1,2)];\n</code></pre>\n<p>this works because integer literals are indeed constant expressions.</p>\n<p>C++11 was more specific in this case, the draft C++11 standard in section <code>5.19</code> <em>[expr.const]</em> lays out the cases where a sub-expression is not considered a constant expression and contains the following:</p>\n<blockquote>\n<p id=\"so_31410933_31410986_0\">an invocation of a constexpr function with arguments that, when\n  substituted by function invocation substitution (7.1.5), do not\n  produce a constant expression;</p>\n</blockquote>\n<p>in C++14 this paragraph was removed and we have the following exception:</p>\n<blockquote>\n<p id=\"so_31410933_31410986_1\">an invocation of a function other than a constexpr constructor for a\n  literal class, a constexpr function, or an implicit invocation of a\n  trivial destructor (12.4) [ Note: Overload resolution (13.3) is\n  applied as usual \u2014end note ];</p>\n</blockquote>\n<p>and we have to use the rest of the rules with respect to the arguments(<em>sub-expressions</em>).</p>\n<p>In the first case:</p>\n<pre><code>int array[std::max(a.size(), b.size()];\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/vector/size\" rel=\"nofollow\">std::vector::size</a> is not marked constexpr and so it falls under the above quoted exception.</p>\n<p>Also note that in section <code>7.1.5</code> <em>[dcl.constexpr]</em> we have the following:</p>\n<blockquote>\n<p id=\"so_31410933_31410986_2\">A call to a constexpr function produces the same result as a call to\n  an equivalent non-constexpr function in all respects except that a\n  call to a constexpr function can appear in a constant expression.</p>\n</blockquote>\n<p>Passing arguments to a constexpr function that are not constant expressions just means the expression is not available for uses in contexts that require a constant expression.</p>\n<p>As dyp points out that <code>std::max</code> was not made constexpr in C++11 due <s>to various issues probably including committee being conservative and limited time, we can see some of the issues involved in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3039.pdf\" rel=\"nofollow\">N3039</a>.</s> it being forgotten see <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3856.pdf\" rel=\"nofollow\">N3856</a> which says:</p>\n<blockquote>\n<p id=\"so_31410933_31410986_3\">This short paper proposes to make the standard functions min and max\n  constexpr. They were top on the list of motivating cases for al-\n  lowing reference parameters for constexpr functions in C++11. They\n  were forgotten after the core language change was accepted</p>\n</blockquote>\n<p>For reference we know that <code>1</code> and <code>2</code> are constant expression from section <code>5.19</code> which says:</p>\n<blockquote>\n<p id=\"so_31410933_31410986_4\">A literal constant expression is a prvalue core constant expression of literal type, but not pointer type. An\n  integral constant expression is a literal constant expression of integral or unscoped enumeration type. [...]</p>\n</blockquote>\n", "LastActivityDate": "2015-07-23T20:19:49.220"}, "31410933": {"CommentCount": "1", "AcceptedAnswerId": "31410986", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-07-14T15:28:05.810", "LastActivityDate": "2015-07-23T20:19:49.220", "LastEditDate": "2015-07-14T17:43:06.343", "ViewCount": "694", "FavoriteCount": "0", "Title": "Trouble understanding C++14 Relaxed constexpr restrictions", "Id": "31410933", "Score": "5", "Body": "<p>I've came across new C++14 signature for <code>std::max</code> function:</p>\n<pre><code>template&lt; class T &gt; \nconst T&amp; max( const T&amp; a, const T&amp; b ); // (C++11)\n\ntemplate&lt; class T &gt; \nconstexpr const T&amp; max( const T&amp; a, const T&amp; b );// (C++14)\n</code></pre>\n<p>I've read about <em>Relaxed constexpr restrictions</em> proposal for C++14 but I'm still don't understand why this function return value can be <code>constexpr</code></p>\n<p>Example:</p>\n<pre><code>std::vector&lt;int&gt; a, b;\n//This does not compile but as my understadnding of `constexpr` this should\nint array[std::max(a.size(), b.size()]; (1)\n//This is trivial use that does compile\nint array[std::max(1,2)]; (2)\n</code></pre>\n<p>When calling <code>std::max</code> in (1) <code>constexpr</code> is ignored ?</p>\n", "Tags": "<c++><c++11><c++14><constexpr>", "OwnerUserId": "4347209", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31410933_31410986_4": {"section_id": 6186, "quality": 0.5909090909090909, "length": 13}, "so_31410933_31410986_1": {"section_id": 6185, "quality": 0.782608695652174, "length": 18}, "so_31410933_31410986_2": {"section_id": 5423, "quality": 1.0, "length": 20}}, "n3337": {"so_31410933_31410986_4": {"section_id": 5947, "quality": 0.9090909090909091, "length": 20}, "so_31410933_31410986_1": {"section_id": 5946, "quality": 0.5217391304347826, "length": 12}, "so_31410933_31410986_0": {"section_id": 5946, "quality": 0.9230769230769231, "length": 12}, "so_31410933_31410986_2": {"section_id": 5218, "quality": 1.0, "length": 20}}, "n4659": {"so_31410933_31410986_4": {"section_id": 7687, "quality": 0.5454545454545454, "length": 12}, "so_31410933_31410986_1": {"section_id": 7687, "quality": 0.782608695652174, "length": 18}, "so_31410933_31410986_0": {"section_id": 7687, "quality": 0.5384615384615384, "length": 7}, "so_31410933_31410986_2": {"section_id": 6845, "quality": 1.0, "length": 20}}}});