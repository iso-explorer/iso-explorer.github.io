post_cb({"33314071": {"Id": "33314071", "PostTypeId": "2", "Body": "<p>Not a complete answer but that is a clear situation that shows even declaring using namespace, for objects with the same name as the namespace you need to declare the namespace.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nnamespace test\n{\n    void function1(void){std::cout &lt;&lt; \"Function inside the namespace\" &lt;&lt; std::endl;}\n\n    class test\n    {\n    public:\n        static void function1(void){std::cout &lt;&lt; \"Function inside the class\" &lt;&lt; std::endl;}    \n    };\n};\n\nusing namespace test;\n\nint main()\n{\n    function1();\n\n    test::function1();\n\n    test::test::function1();\n}\n</code></pre>\n<p>Output (GCC 4.9.2)</p>\n<pre><code>\"Function inside the namespace\"\n\"Function inside the namespace\"\n\"Function inside the class\"\n</code></pre>\n", "LastActivityDate": "2015-10-24T03:00:55.837", "CommentCount": "0", "CreationDate": "2015-10-24T03:00:55.837", "ParentId": "33313853", "Score": "0", "OwnerUserId": "5420624"}, "33313853": {"ViewCount": "312", "Body": "<p>Consider the code:</p>\n<pre><code>template&lt;typename T&gt; \nclass Foo{};\n\nnamespace X\n{\n    class X{};\n}\n\nusing namespace X; // now both class X and namespace X are visible\nFoo&lt;X::X&gt; f()\n{\n    return {};\n}\n\nint main() {}\n</code></pre>\n<p>gcc5.2 compiles the code with no errors whatsoever. However clang spits the error:</p>\n<blockquote>\n<p id=\"so_33313853_33313853_0\">error: 'X' is not a class, namespace, or enumeration\n  Foo f()          </p>\n<p id=\"so_33313853_33313853_1\">error: reference to 'X' is ambiguous</p>\n</blockquote>\n<p>Is the code syntactically valid, according to the C++ standard? Or is just a gcc bug? Removing the qualified name <code>X::X</code> and using <code>Foo&lt;X&gt;</code> instead makes gcc choke also</p>\n<blockquote>\n<p id=\"so_33313853_33313853_2\">error: template argument 1 is invalid\n   Foo f()</p>\n</blockquote>\n", "AcceptedAnswerId": "33318306", "Title": "Namespace having the same name as contained class, ok for gcc, not ok for clang", "CreationDate": "2015-10-24T02:18:12.563", "Id": "33313853", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-24T02:50:48.497", "LastEditorUserId": "3093378", "LastActivityDate": "2015-10-24T12:39:45.180", "Score": "4", "OwnerUserId": "3093378", "Tags": "<c++><c++11><gcc><clang><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33313853_33318306_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 7117}, "so_33313853_33318306_0": {"length": 17, "quality": 1.0, "section_id": 5514}}, "n3337": {"so_33313853_33318306_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 6861}, "so_33313853_33318306_0": {"length": 17, "quality": 1.0, "section_id": 5300}}, "n4659": {"so_33313853_33318306_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 8618}, "so_33313853_33318306_0": {"length": 17, "quality": 1.0, "section_id": 6949}}}, "33318306": {"Id": "33318306", "PostTypeId": "2", "Body": "<p>[namespace.udir]/6:</p>\n<blockquote>\n<p id=\"so_33313853_33318306_0\">If name lookup finds a declaration for a name in two different\n  namespaces, and the declarations do not declare the same entity and do\n  not declare functions, the use of the name is ill-formed.</p>\n</blockquote>\n<p>For the first <code>X</code> in <code>X::X</code>, both the namespace and the class are considered. However, the name of the namespace resides in the global namespace while the class resides in namespace <code>X</code>; Hence the above quote applies, Clang is therefore correct. (This also occurs when just writing <code>X</code>, clearly).</p>\n<p><code>::X</code> removes this ambiguity. Lookup does not proceed into the namespace anymore. [namespace.qual]/2:</p>\n<blockquote>\n<p id=\"so_33313853_33318306_1\">For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set\n  <em>S(X, m)</em> is defined as follows: Let\n  <em>S<sub>0</sub>(X, m)</em> be the set of all declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code> (7.3.1). <strong>If <em>S<sub>0</sub>(X, m)</em> is\n  not empty, <em>S(X, m)</em> is <em>S<sub>0</sub>(X, m)</em>;</strong> otherwise, [\u2026]</p>\n</blockquote>\n<p>Here, <code>X</code> is the global namespace and <code>m</code> is \"X\". Clearly, the declaration of our namespace is found, so lookup is definite here.</p>\n", "LastActivityDate": "2015-10-24T12:39:45.180", "CommentCount": "3", "CreationDate": "2015-10-24T12:39:45.180", "ParentId": "33313853", "Score": "2", "OwnerUserId": "3647361"}});