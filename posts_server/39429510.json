post_cb({"bq_ids": {"n4140": {"so_39429510_39431986_1": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_39429510_39431986_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 3304}, "so_39429510_39429696_2": {"length": 14, "quality": 0.6086956521739131, "section_id": 3287}, "so_39429510_39431986_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_39429510_39431986_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 3298}}, "n3337": {"so_39429510_39431986_1": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_39429510_39431986_3": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}, "so_39429510_39431986_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_39429510_39431986_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 3168}}, "n4659": {"so_39429510_39431986_1": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_39429510_39431986_3": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}, "so_39429510_39429696_2": {"length": 14, "quality": 0.6086956521739131, "section_id": 4049}, "so_39429510_39431986_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_39429510_39431986_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 4063}}}, "39431986": {"Id": "39431986", "PostTypeId": "2", "Body": "<p>The wording in the Standard changed between C++11 and C++14, and the end result is similar but not identical.</p>\n<hr>\n<p>This code is <em>list-initialization</em> because a braced list (albeit empty) is the initializer. In C++11 the following quote from [dcl.init.list]/3 applies:</p>\n<blockquote>\n<p id=\"so_39429510_39431986_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized.</li>\n</ul>\n</blockquote>\n<p>However in C++14 the same section starts with a different bullet point:</p>\n<blockquote>\n<p id=\"so_39429510_39431986_1\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If T is an aggregate, aggregate initialization is performed</li>\n</ul>\n</blockquote>\n<p>In this case, <code>Entry</code> is an aggregate because it meets the conditions for one ([dcl.init.aggr]/1):</p>\n<blockquote>\n<p id=\"so_39429510_39431986_2\">An aggregate is an array or a class with no user-provided constructors (12.1), no private or protected non-static data members, no base classes, and no virtual functions</p>\n</blockquote>\n<p>The term \"user-provided\" excludes a defaulted function.</p>\n<p>The behaviour of aggregate initialization is covered in [dcl.init.aggr], which says that successive members of the list are taken as initializer for the members of the aggregate.  When there are fewer list members than aggregate members, then [dcl.init.aggr]/7 applies:</p>\n<blockquote>\n<p id=\"so_39429510_39431986_3\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its <em>brace-or-equal-initializer</em> or, if there is no <em>brace-or-equal-\n  initializer</em>, from an empty initializer list.</p>\n</blockquote>\n<p>This is saying that, for example, <code>e.overlaps</code> is initialized in the same way as <code>std::vector&lt;Constraint&gt; overlaps{};</code> would be.</p>\n<p>You may note that this is a recursive definition for aggregates. When we get to something that is not an aggregate (e.g. <code>std::vector</code>) , then the second bullet point in [dcl.init.list]/3 will apply, which is the first one from C++11: value-initialization.</p>\n<hr>\n<p>Comparing the C++11 with the C++14, there is a small difference: in C++14 there is no step of <em>zero-initializing</em> the entire object before calling default constructors of members.  Instead, only the sub-objects without user-provided constructors will be zero-initialized.   In C++14, struct padding in <code>Entry</code> might not be initialized to zero bits. (There could be padding after the <code>std::array</code> members). Similarly, if the <code>std::vector</code>'s internals contain any members not initialized by its constructor; they would remain uninitialized, and not zero-initialized.</p>\n</hr></hr>", "LastActivityDate": "2016-09-11T01:14:13.890", "CommentCount": "0", "CreationDate": "2016-09-11T01:14:13.890", "ParentId": "39429510", "Score": "1", "OwnerUserId": "1505939"}, "39429696": {"Id": "39429696", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39429510_39429696_0\">What do empty brackets mean in struct declaration?</p>\n</blockquote>\n<p><code>T object {};</code> is syntax for <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow\">value initialization (4)</a>. Without the curly brackets, the object would be <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow\">default initialized</a>.</p>\n<p>To be pedantic, this is not a \"struct declaration\". It is declaration of a variable.</p>\n<blockquote>\n<p id=\"so_39429510_39429696_1\">when I go to value initialization, I can't figure out which, if any, of the cases apply.</p>\n</blockquote>\n<p>This one applies:</p>\n<blockquote>\n<p id=\"so_39429510_39429696_2\">2) if T is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is zero-initialized and then it is default-initialized if it has a non-trivial default constructor; (since C++11)</p>\n</blockquote>\n<p>And that is how we get to zero initialization. Your interpretation of the zero initialization rules is correct.</p>\n<blockquote>\n<p id=\"so_39429510_39429696_3\">I'm wondering if this behavior is actually defined in the specs</p>\n</blockquote>\n<p>The rules in the linked pages are based on the standard, not on a specific implementation. The behaviour is defined.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2016-09-10T19:24:03.640", "Score": "5", "CreationDate": "2016-09-10T19:13:43.780", "ParentId": "39429510", "CommentCount": "1", "OwnerUserId": "2079303", "LastEditDate": "2016-09-10T19:24:03.640"}, "39429510": {"ViewCount": "1547", "Body": "<p>Here is a cut-down definition of a <code>struct</code>, showing only the point at issue.</p>\n<pre><code>struct Entry {\n    // bookkeeping record for managing solution search\n    std::array&lt;std::array&lt;bool, DIM&gt;, DIM&gt; filled;   // which holes have been filled\n    std::array&lt;std::array&lt;char, MAX&gt;, MAX&gt; cells;    // individual cell entries, 0=empty\n    std::vector&lt;Constraint&gt; overlaps;\n    std::vector&lt;Hole*&gt;::iterator candidates;\n    Entry() = default;\n};\n</code></pre>\n<p>This was actually a mistake.  I was thinking that the default constructor would zero-initialize the arrays, but it just fills them with random garbage.  I now know I need to write the default constructor, but I am confused by the behavior I ran across when testing.</p>\n<p>This is a cut-down version of my test function:</p>\n<pre><code>void testEntry(void) {\n    Entry e;\n    std::cout &lt;&lt; std::boolalpha;\n    e.cells[1][2] = 'a';\n    e.filled[0][0] = true;\n    for (int i = 0; i &lt; MAX; ++i)\n        for (int j = 0; j &lt; MAX; ++j)\n            std::cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;e.cells[i][j]&lt;&lt;std::endl;\n    for (int i = 0; i &lt; DIM; ++i)\n        for (int j = 0; j &lt; DIM; ++j)\n            std::cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;e.filled[i][j]&lt;&lt;std::endl;\n}\n</code></pre>\n<p>When I ran this, the <code>filled</code> and <code>cells</code> arrays contained random garbage, and eventually I found my mistake.   While debugging, I changed the declaration <code>Entry e;</code> to <code>Entry e{};</code> and the modified code appears to work as I intended, but I don't understand why. </p>\n<p>I'm not quite able to follow the documentation.  Under <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">list initialization</a> it says that, \"If the braced-init-list is empty and T is a class type with a default constructor, value-initialization is performed.\"  This is pretty clear, but when I go to <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow\">value initialization</a>, I can't figure out which, if any, of the cases apply.\nIs seems like this clause under <a href=\"http://en.cppreference.com/w/cpp/language/zero_initialization\" rel=\"nofollow\">zero-intialization</a> is being applied\n\"If T is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored,\" but I don't see how to get here.</p>\n<p>More than anything, I'm wondering if this behavior is actually defined in the specs, or if it might be different with a different compiler.  (I'm using clang under Xcode 7.2.1). </p>\n", "AcceptedAnswerId": "39429696", "Title": "What do empty braces mean in struct declaration?", "CreationDate": "2016-09-10T18:54:58.907", "Id": "39429510", "CommentCount": "4", "LastEditDate": "2016-09-10T23:44:31.593", "PostTypeId": "1", "LastEditorUserId": "908293", "LastActivityDate": "2016-09-11T01:14:13.890", "Score": "4", "OwnerUserId": "908293", "Tags": "<c++><c++11>", "AnswerCount": "2"}});