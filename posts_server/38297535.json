post_cb({"38297554": {"ParentId": "38297535", "CommentCount": "0", "Body": "<p>A literal string ends up being a pointer to your data section of your program so it is safe. But when you assign an int to a <code>int*</code> it is telling the OS to use that memory location which is not safe</p>\n", "OwnerUserId": "23528", "PostTypeId": "2", "Id": "38297554", "Score": "1", "CreationDate": "2016-07-11T00:13:06.940", "LastActivityDate": "2016-07-11T00:13:06.940"}, "38297654": {"ParentId": "38297535", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to the C++ standard \u00a7 2.14.5/8</p>\n<blockquote>\n<p id=\"so_38297535_38297654_0\">8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration</p>\n</blockquote>\n<p>and section 2.14.5/14</p>\n<blockquote>\n<p id=\"so_38297535_38297654_1\">14 After any necessary concatenation, in translation phase 7 (2.2), \u2019\\0\u2019 is appended to every string literal so that programs that scan a string can find its end.</p>\n</blockquote>\n<p><code>\"Hello\"</code> is a narrow string literal, it produces</p>\n<pre><code>static const char __hello_str[] = { 'H', 'e', 'l', 'l', 'o', '\\0' };\n</code></pre>\n<p>In C++, inherited from C, is the concept of <a href=\"http://c-faq.com/aryptr/aryptrequiv.html\" rel=\"nofollow\">array-pointer equivalence</a>, which in this context boils down to the fact that an array - or a string literal - will gladly decay into a pointer.</p>\n<pre><code>char* text;\ntext = \"hello\";\n</code></pre>\n<p>introduces a static, nul-terminated character array in the data section of the program, and assigns it's address to the char* variable pointer.</p>\n<p>Technically, we're violating the <code>const</code>ness of the array here, but many compilers allow this because of legacy C code. However, the C++ standard states in Annex C:</p>\n<blockquote>\n<p id=\"so_38297535_38297654_2\">Subclause 2.14.5:\n  The type of a string literal is changed from \u201carray of char\u201d to \u201carray of const char.\u201d The type of a\n  char16_t string literal is changed from \u201carray of some-integer-type\u201d to \u201carray of const char16_t.\u201d The\n  type of a char32_t string literal is changed from \u201carray of some-integer-type\u201d to \u201carray of const char32_t.\u201d\n  The type of a wide string literal is changed from \u201carray of wchar_t\u201d to \u201carray of const wchar_t.\u201d\n  Rationale: This avoids calling an inappropriate overloaded function, which might expect to be able to modify its argument.</p>\n</blockquote>\n<p>The legacy conversions were deprecated some time ago and have been illegal since C++11. The correct way to do this is:</p>\n<pre><code>const char* text;\ntext = \"hello\";  // correct\n</code></pre>\n<p>It's unclear whether you were trying to write</p>\n<pre><code>int* text;\ntext = \"hello\";  // error: incompatible types int* vs const char*\n</code></pre>\n<p>or whether you were trying to do something like:</p>\n<pre><code>const int a = 1;\nint* ptr;\nptr = &amp;a;  // error: int* vs const int*.\n</code></pre>\n", "OwnerUserId": "257645", "LastEditorUserId": "257645", "LastEditDate": "2016-07-11T02:01:41.357", "Id": "38297654", "Score": "1", "CreationDate": "2016-07-11T00:30:04.043", "LastActivityDate": "2016-07-11T02:01:41.357"}, "38297535": {"CommentCount": "1", "ViewCount": "54", "PostTypeId": "1", "ClosedDate": "2016-07-11T09:15:45.907", "LastEditorUserId": "6572399", "CreationDate": "2016-07-11T00:09:50.337", "LastActivityDate": "2016-07-11T16:34:38.003", "Title": "c++ pointer of char exception", "LastEditDate": "2016-07-11T16:34:38.003", "Id": "38297535", "Score": "-3", "Body": "<p>when I do this:\nchar* text;\ntext = \"Hello\";\nit works but what I'm really doing here is initialising a pointer of char and it can't hold the value \"Hello\", just the value of an address? If I do the same thing with int, it does not work why? </p>\n", "Tags": "<c++><pointers><char>", "OwnerUserId": "6572399", "AnswerCount": "3"}, "38297846": {"ParentId": "38297535", "CommentCount": "0", "Body": "<p>Re the example</p>\n<pre><code>char* text; text = \"Hello\";    //! Not OK\n</code></pre>\n<p>The string literal has type <code>char const [6]</code>, where the 6<sup>th</sup> <code>char</code> value is a terminating zero-byte.</p>\n<p>Converting that to <code>char*</code> is <strong>invalid</strong> as of C++11 and later.</p>\n<p>However, in C++98 and C++03 it was valid for backward compatibility with C. There was a special rule for string literals, that allowed dropping the <code>const</code>. In C++11 and later you have to keep the <code>const</code>-ness (which is more safe because modifying the literal is Undefined Behavior), i.e.</p>\n<pre><code>char const* text; text = \"Hello\";\n</code></pre>\n<p>Here the string literal decays to a <code>char const*</code> pointer that points to the first <code>char</code> value, and this pointer value is assigned to <code>text</code>.</p>\n<p>There is no such implicit conversion from <code>int</code> to pointer value. But if you had an array of <code>int</code>, that array would convert implicitly to pointer. E.g.,</p>\n<pre><code>int const a[] = { 2, 7, 1, 8, 2, 8, 1, 8, 2, 8};\nint const* p = a;\n</code></pre>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "38297846", "Score": "0", "CreationDate": "2016-07-11T01:04:10.593", "LastActivityDate": "2016-07-11T01:04:10.593"}, "bq_ids": {"n4140": {"so_38297535_38297654_0": {"section_id": 5356, "quality": 1.0, "length": 26}, "so_38297535_38297654_1": {"section_id": 5363, "quality": 1.0, "length": 16}}, "n3337": {"so_38297535_38297654_0": {"section_id": 5153, "quality": 1.0, "length": 26}, "so_38297535_38297654_1": {"section_id": 5159, "quality": 1.0, "length": 16}}, "n4659": {"so_38297535_38297654_0": {"section_id": 6781, "quality": 1.0, "length": 26}, "so_38297535_38297654_1": {"section_id": 6787, "quality": 1.0, "length": 16}}}});