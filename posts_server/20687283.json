post_cb({"bq_ids": {"n4140": {"so_20687283_20687576_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 5362}, "so_20687283_20687603_0": {"length": 28, "quality": 1.0, "section_id": 5362}, "so_20687283_20687576_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5362}}, "n3337": {"so_20687283_20687576_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 5158}, "so_20687283_20687603_0": {"length": 28, "quality": 1.0, "section_id": 5158}, "so_20687283_20687576_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5158}}, "n4659": {"so_20687283_20687576_1": {"length": 33, "quality": 0.7333333333333333, "section_id": 6786}, "so_20687283_20687603_0": {"length": 20, "quality": 0.7142857142857143, "section_id": 6786}, "so_20687283_20687576_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 6786}}}, "20687576": {"Id": "20687576", "PostTypeId": "2", "Body": "<p>The 2003 ISO C++ standard, section 2.13.4p3, says:</p>\n<blockquote>\n<p id=\"so_20687283_20687576_0\">In translation phase 6 (2.1), adjacent narrow string literals are\n  concatenated and adjacent wide string literals are concatenated.  If a\n  narrow string literal token is adjacent to a wide string literal\n  token, the behavior is undefined.  Characters in concatenated strings\n  are kept distinct.</p>\n</blockquote>\n<p>The 2011 standard, section 2.14.5p13, says:</p>\n<blockquote>\n<p id=\"so_20687283_20687576_1\">In translation phase 6 (2.2), adjacent string literals are\n  concatenated. If both string literals have the same <em>encoding-prefix</em>,\n  the resulting concatenated string literal has that <em>encoding-prefix</em>.\n  If one string literal has no <em>encoding-prefix</em>, it is treated as a\n  string literal of the same encoding-prefix as the other operand. If a\n  UTF-8 string literal token is adjacent to a wide string literal token,\n  the program is ill-formed. Any other concatenations are conditionally\n  supported with implementation-defined behavior.</p>\n</blockquote>\n<p>So the sequence <code>L\"boo \" \"hoo\"</code> has undefined behavior in C2003 but is well defined and equivalent to <code>L\"boohoo\"</code> in C2011.</p>\n<p>I can't tell from the information you've given us whether MSVS2013 conforms to C++11. You say it \"doesn't like\" the construct, but if the dislike is expressed as a non-fatal warning and the semantics are as specified in the 2011 standard, then it could be conforming.</p>\n<p>Can you update the question to show the diagnostic message?</p>\n", "LastActivityDate": "2013-12-19T17:05:37.960", "CommentCount": "2", "CreationDate": "2013-12-19T17:05:37.960", "ParentId": "20687283", "Score": "5", "OwnerUserId": "827263"}, "20687283": {"ViewCount": "197", "Body": "<p>In MSVS2013, which I believe to be C++11 compliant, the compiler doesn't like the following:</p>\n<pre><code>LPCTSTR str = _T(\"boo \" \"hoo\");\n</code></pre>\n<p>which translates to:</p>\n<pre><code>wchar_t const * str = L\"boo \" \"hoo\";\n</code></pre>\n<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"nofollow\">cppreference.com</a> (which I know is not definitive, but it's the only reference I have at the moment):</p>\n<ul>\n<li>String literals placed side-by-side are concatenated during compilation. That is, \"Hello,\"  \" world!\" yields the (single) string \"Hello, world!\".\n<ul>\n<li>If the two strings have the same encoding prefix (or neither has one), the resulting string will have the same encoding prefix (or no prefix).</li>\n<li><strong><em>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</em></strong></li>\n<li>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</li>\n<li>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</li>\n</ul></li>\n</ul>\n<p>The emphasis is my own.</p>\n<p>Can anyone confirm if this is in the standard as indicated by cppreference?</p>\n<p><strong>EDIT</strong></p>\n<p>By doesn't like, I mean I get the following error:</p>\n<pre><code>error C2308: concatenating mismatched strings\n</code></pre>\n", "AcceptedAnswerId": "20687576", "Title": "String literal concatenation fails when prefixed string is adjacent to non-prefixed string?", "CreationDate": "2013-12-19T16:51:03.407", "Id": "20687283", "CommentCount": "3", "LastEditDate": "2013-12-19T17:10:53.187", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2013-12-19T17:10:53.187", "Score": "3", "OwnerUserId": "1366368", "Tags": "<c++><visual-studio><c++11>", "AnswerCount": "2"}, "20687603": {"Id": "20687603", "PostTypeId": "2", "Body": "<p>From N3797, <em>\u00a72.14.5/13</em> [lex.string]</p>\n<blockquote>\n<p id=\"so_20687283_20687603_0\">In translation phase 6 (2.2), adjacent string literals are\n  concatenated. If both string literals have the same encoding-prefix,\n  the resulting concatenated string literal has that encoding-prefix. If\n  one string literal has no encoding-prefix, it is treated as a string\n  literal of the same encoding-prefix as the other operand.</p>\n</blockquote>\n<p>The table following that even lists an example that's the same as what you've shown</p>\n<pre><code>// Source         Means\nL\"a\" \"b\"          L\"ab\"\n</code></pre>\n<p>So I'd say your code is well-formed and this is a VisualStudio bug.</p>\n", "LastActivityDate": "2013-12-19T17:07:08.203", "CommentCount": "0", "CreationDate": "2013-12-19T17:07:08.203", "ParentId": "20687283", "Score": "3", "OwnerUserId": "241631"}});