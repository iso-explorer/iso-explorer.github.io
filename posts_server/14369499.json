post_cb({"14369499": {"CommentCount": "4", "ViewCount": "237", "PostTypeId": "1", "LastEditorUserId": "1947008", "CreationDate": "2013-01-16T23:04:12.680", "LastActivityDate": "2013-01-20T18:54:38.890", "Title": "Search within list c++?", "AcceptedAnswerId": "14369748", "LastEditDate": "2013-01-16T23:05:29.483", "Id": "14369499", "Score": "0", "Body": "<p>Thanks for looking at my question in advance.</p>\n<p>I am completing a question for a university assignment that asks the following:</p>\n<blockquote>\n<p id=\"so_14369499_14369499_0\">For each of std::list&lt; &gt;, std::map&lt; &gt;, std::unordered_map&lt; &gt; document and explain the guaranteed performance for element insertion and look-up.</p>\n</blockquote>\n<p>I have had no trouble doing most of this, until I come to explain element look-up within a list.</p>\n<p>I have been gathering my information from Josuttis and <a href=\"http://www.cplusplus.com\" rel=\"nofollow\">http://www.cplusplus.com</a> and cannot seem to find any information about this.</p>\n<p>I'm guessing because it's not possible?</p>\n", "Tags": "<c++><search><element><stdlist>", "OwnerUserId": "1825198", "AnswerCount": "4"}, "14370750": {"ParentId": "14369499", "CommentCount": "0", "Body": "<p>In case you want a more formal statement of what's supported, here's what the standard has to say. About the best searching we can do is with a binary search, such as <code>std::lower_bound</code> (\u00a725.4.3.1/3):</p>\n<blockquote>\n<p id=\"so_14369499_14370750_0\">Complexity: At most log<sub>2</sub>(<code>last \u2212 first</code>) + O(1) comparisons.</p>\n</blockquote>\n<p>That only tells us the number of <em>comparisons</em> though. To move through the container, <code>lower_bound</code> uses <code>std::advance</code>. About an std::list we find (\u00a723.3.5.1/1):</p>\n<blockquote>\n<p id=\"so_14369499_14370750_1\">A list is a sequence container that supports bidirectional iterators [...]</p>\n</blockquote>\n<p>So, how does <code>std::advance</code> work for a collection that provides bidirectional iterators?\n(\u00a724.4.4/1):</p>\n<blockquote>\n<p id=\"so_14369499_14370750_2\">[...] for input, forward and bidirectional iterators they use ++ to provide linear time implementations.</p>\n</blockquote>\n<p>So, to find anything in a list (by either value or position) we're going to be looking at linear complexity overall, with a logarithmic number of comparisons. To be honest, we're probably better off with <code>std::find</code> (\u00a725.2.5/2):</p>\n<blockquote>\n<p id=\"so_14369499_14370750_3\">Complexity: At most <code>last - first</code> applications of the corresponding predicate.</p>\n</blockquote>\n<p>The choice between the two may not always be entirely obvious though -- traversing the list is obviously linear. <code>std::find</code> minimizes traversal, while <code>std::lower_bound</code> minimizes comparisons. If comparison is a lot more expensive than traversal, <code>std::lower_bound</code> will probably do better. If comparison is fairly cheap, <code>std::find</code> is probably better.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "14370750", "Score": "1", "CreationDate": "2013-01-17T01:20:00.340", "LastActivityDate": "2013-01-17T01:20:00.340"}, "14369750": {"ParentId": "14369499", "CommentCount": "0", "Body": "<p>From <a href=\"http://www.cplusplus.com/reference/list/list/\" rel=\"nofollow\">http://www.cplusplus.com/reference/list/list/</a></p>\n<blockquote>\n<p id=\"so_14369499_14369750_0\">The main drawback of lists and forward_lists compared to these other\n  sequence containers is that they lack direct access to the elements by\n  their position; For example, to access the sixth element in a list one\n  has to iterate from a known position (like the beginning or the end)\n  to that position, which takes linear time in the distance between\n  these. They also consume some extra memory to keep the linking\n  information associated to each element (which may be an important\n  factor for large lists of small-sized elements).</p>\n</blockquote>\n<p>So, iterating through a std::list&lt; &gt; (looking up an element) is linear complexity.  Also, you cannot access elements by index.</p>\n", "OwnerUserId": "1742632", "PostTypeId": "2", "Id": "14369750", "Score": "1", "CreationDate": "2013-01-16T23:25:37.053", "LastActivityDate": "2013-01-16T23:25:37.053"}, "14369871": {"ParentId": "14369499", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I recommend that you read the following reference:\n<a href=\"https://stackoverflow.com/questions/181693/what-are-the-complexity-guarantees-of-the-standard-containers\">What are the complexity guarantees of the standard containers?</a></p>\n<p>It has a chart of order complexity of many standard containers and one of the answers links to the STL complexity specifications. (<a href=\"http://www.sgi.com/tech/stl/complexity.html\" rel=\"nofollow noreferrer\">http://www.sgi.com/tech/stl/complexity.html</a>)</p>\n<p>Since this is a class project, I recommend that you not only read these reference for your answer, but spend some time in the STL headers and get a feel for the implementation of these containers on your architecture. </p>\n<p>STL is a fantastic way to leverage the knowledge of true experts ... however it can also be the proverbial enough rope, if not given due diligence</p>\n", "OwnerUserId": "1981877", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:34.503", "Id": "14369871", "Score": "1", "CreationDate": "2013-01-16T23:36:27.250", "LastActivityDate": "2013-01-17T01:28:49.213"}, "14369748": {"ParentId": "14369499", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You mention that you had no trouble except with the <code>list</code> portion, so I'm only going to answer for that portion.</p>\n<p>In order to answer this question, you need to understand how <a href=\"http://en.cppreference.com/w/cpp/container/list\" rel=\"nofollow\"><code>std::list</code></a> is implemented.\nSome quick searching brings up:</p>\n<blockquote>\n<p id=\"so_14369499_14369748_0\">List containers are implemented as doubly-linked lists. </p>\n</blockquote>\n<p>From how I interpret it, <strong>Guaranteed Performance</strong> means the same thing as <strong>Worse-case Runtime Complexity</strong>.</p>\n<p>For <strong>element lookup</strong> in a doubly-linked list, the worst-case scenario is that your list does not contain the item you are trying to lookup. In that case, you would have to compare every item in the list to the item you are searching for. So the worst-case runtime complexity of this operation is <strong>O(n)</strong>, where <code>n</code> is the size of the list.</p>\n", "OwnerUserId": "1825250", "LastEditorDisplayName": "user283145", "LastEditDate": "2013-01-20T18:54:38.890", "Id": "14369748", "Score": "2", "CreationDate": "2013-01-16T23:25:26.467", "LastActivityDate": "2013-01-20T18:54:38.890"}, "bq_ids": {"n4140": {"so_14369499_14370750_2": {"section_id": 5593, "quality": 1.0, "length": 10}, "so_14369499_14370750_3": {"section_id": 1258, "quality": 0.8571428571428571, "length": 6}, "so_14369499_14370750_1": {"section_id": 902, "quality": 1.0, "length": 6}}, "n3337": {"so_14369499_14370750_2": {"section_id": 5376, "quality": 1.0, "length": 10}, "so_14369499_14370750_0": {"section_id": 1427, "quality": 0.8, "length": 4}, "so_14369499_14370750_3": {"section_id": 1256, "quality": 0.8571428571428571, "length": 6}, "so_14369499_14370750_1": {"section_id": 888, "quality": 1.0, "length": 6}}, "n4659": {"so_14369499_14370750_1": {"section_id": 962, "quality": 1.0, "length": 6}, "so_14369499_14370750_3": {"section_id": 1378, "quality": 0.8571428571428571, "length": 6}, "so_14369499_14370750_2": {"section_id": 7037, "quality": 1.0, "length": 10}}}});