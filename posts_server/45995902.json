post_cb({"bq_ids": {"n4140": {"so_45995902_45996037_5": {"length": 5, "quality": 0.625, "section_id": 599}}, "n3337": {"so_45995902_45996037_5": {"length": 5, "quality": 0.625, "section_id": 589}}, "n4659": {"so_45995902_45996037_5": {"length": 5, "quality": 0.625, "section_id": 622}}}, "45995902": {"ViewCount": "1323", "Body": "<p>I read about deduction guides for <code>std::vector</code> from using <a href=\"http://en.cppreference.com/w/cpp/container/vector/deduction_guides\" rel=\"nofollow noreferrer\">cppreference</a>. </p>\n<p><strong>Example:</strong> </p>\n<pre><code>#include &lt;vector&gt;\n\nint main() {\n   std::vector&lt;int&gt; v = {1, 2, 3, 4};\n   std::vector x{v.begin(), v.end()}; // uses explicit deduction guide\n}\n</code></pre>\n<p>So, I have some questions about it:</p>\n<ul>\n<li><p>What are <code>std::vector</code> deduction guides in C++17?</p></li>\n<li><p>Why and when do we need vector deduction?</p></li>\n<li><p>Here, Is <code>x</code> a <code>std::vector&lt;int&gt;</code> or a <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>?</p></li>\n</ul>\n", "AcceptedAnswerId": "45996037", "Title": "What are std::vector deduction guides in C++17?", "CreationDate": "2017-09-01T08:14:56.213", "Id": "45995902", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-09-02T05:33:08.667", "LastEditorUserId": "6935629", "LastActivityDate": "2017-09-02T05:33:08.667", "Score": "20", "OwnerUserId": "6935629", "Tags": "<c++><vector><c++1z><deduction-guide>", "AnswerCount": "3"}, "45996037": {"Id": "45996037", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45995902_45996037_0\">What are <code>std::vector</code> deduction guides in C++17?</p>\n</blockquote>\n<p>An user-defined deduction guide allows users to decide how <a href=\"http://en.cppreference.com/w/cpp/language/class_template_argument_deduction\" rel=\"noreferrer\">class template argument deduction</a> deduces arguments for a template class from its constructor arguments. In this case, it seems that <code>std::vector</code> has an explicit guide that should make construction from an iterator pair more intuitive.</p>\n<hr>\n<blockquote>\n<p id=\"so_45995902_45996037_1\">Why and when do we need vector deduction?</p>\n</blockquote>\n<p>We don't \"need\" it, but it is useful in generic code and in code that's very obvious <em>(i.e. code where explicitly specifying the template arguments is not beneficial to the reader)</em>. </p>\n<hr>\n<blockquote>\n<p id=\"so_45995902_45996037_2\">Is <code>x</code> a <code>vector&lt;int&gt;</code> or a <code>vector&lt;vector&lt;int&gt;&gt;</code>?</p>\n</blockquote>\n<p>Here's a nice trick to figure this out quickly - write a template function declaration without a definition and attempt to call it. The compiler will print out the type of the passed arguments. Here's what g++ 8 prints out:</p>\n<pre><code>template &lt;typename&gt; \nvoid foo();\n\n// ...\n\nfoo(x);\n</code></pre>\n<blockquote>\n<p id=\"so_45995902_45996037_3\">error: no matching function for call to <code>foo(std::vector&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int&gt; &gt; ...</code></p>\n</blockquote>\n<p>As you can see from the error message, <code>x</code> is deduced to <code>std::vector&lt;std::vector&lt;int&gt;::iterator&gt;</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_45995902_45996037_4\">Why? </p>\n</blockquote>\n<p><code>std::vector</code>'s deduction guides <a href=\"http://en.cppreference.com/w/cpp/container/vector/deduction_guides\" rel=\"noreferrer\">are available on cppreference.org</a>. The Standard seems to define an explicit deduction guide from an iterator pair:</p>\n<p><a href=\"https://i.stack.imgur.com/eVyU3.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/eVyU3.png\"/></a></p>\n<p>The behavior encountered in g++ 8 seems to be correct regardless, as <em>(quoting <a href=\"https://stackoverflow.com/users/3980929/rakete1111\">Rakete1111</a>)</em></p>\n<blockquote>\n<ul>\n<li><p id=\"so_45995902_45996037_5\">overload resolution prefers the constructor with <code>std::initializer_list</code> with the braced initializer list</p></li>\n<li><p id=\"so_45995902_45996037_6\">other constructors are considered only after all <code>std::initializer_list</code> constructors have been tried in <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution#List-initialization\" rel=\"noreferrer\">list-initialization</a></p></li>\n</ul>\n</blockquote>\n<p><code>std:vector&lt;std::vector&lt;int&gt;::iterator&gt;</code> is therefore the correct result when using list-initialization.  <a href=\"https://wandbox.org/permlink/3SZWR0sR2q3ezyxn\" rel=\"noreferrer\"><strong>live example</strong></a></p>\n<p>When constructing <code>x</code> with <code>std::vector x(v.begin(), v.end())</code>, <code>int</code> will be deduced instead. <a href=\"https://wandbox.org/permlink/IEvJjxyOTljYvwMd\" rel=\"noreferrer\"><strong>live example</strong></a></p>\n</hr></hr></hr>", "LastEditorUserId": "598696", "LastActivityDate": "2017-09-01T12:54:42.077", "Score": "17", "CreationDate": "2017-09-01T08:23:38.157", "ParentId": "45995902", "CommentCount": "8", "OwnerUserId": "598696", "LastEditDate": "2017-09-01T12:54:42.077"}, "46000869": {"Id": "46000869", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45995902_46000869_0\">Here, Is <code>x</code> a <code>std::vector&lt;int&gt;</code> or a <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>?</p>\n</blockquote>\n<p>The other answers here address your other questions, but I wanted to address this one a little more thoroughly. When we're doing class template argument deduction, we <a href=\"http://eel.is/c++draft/over.match.class.deduct#1.1\" rel=\"noreferrer\">synthesize a bunch of function templates</a> from the constructors, and then some more from <a href=\"http://eel.is/c++draft/over.match.class.deduct#1.4\" rel=\"noreferrer\">deduction guides</a> and perform overload resolution to determine the correct template parameters.</p>\n<p>There are quite a few constructors to <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"noreferrer\"><code>std::vector&lt;T,A&gt;</code></a> , but most of them don't mention <code>T</code> which would make <code>T</code> a non-deduced context and thus not a viable option in this overload. If we pre-prune the set to only use the ones that could be viable:</p>\n<pre><code>template &lt;class T&gt; vector&lt;T&gt; __f(size_t, T const&amp; );    // #2\ntemplate &lt;class T&gt; vector&lt;T&gt; __f(vector&lt;T&gt; const&amp; );    // #5\ntemplate &lt;class T&gt; vector&lt;T&gt; __f(vector&lt;T&gt;&amp;&amp; );         // #6, NB this is an rvalue ref\ntemplate &lt;class T&gt; vector&lt;T&gt; __f(initializer_list&lt;T&gt; ); // #8\n</code></pre>\n<p>And then also this <a href=\"http://en.cppreference.com/w/cpp/container/vector/deduction_guides\" rel=\"noreferrer\">deduction guide</a>, which I'll also simplify by dropping the allocator:</p>\n<pre><code>template &lt;class InputIt&gt;\nvector&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type&gt; __f(InputIt, InputIt );\n</code></pre>\n<p>Those are our 5 candidates, and we're overloading as if by [dcl.init], a call via <code>__f({v.begin(), v.end()})</code>. Because this is list-initialization, we <a href=\"http://eel.is/c++draft/over.match.list#1.1\" rel=\"noreferrer\">start with the <code>initializer_list</code> candidates</a> and, only if there aren't any, do we proceed to the other candidates. In this case, there is an <code>initializer_list</code> candidate that is viable (#8), so we select it without even considering any of the others. That candidate deduces <code>T</code> as <code>std::vector&lt;int&gt;::iterator</code>, so we then restart the process of overload resolution to select a constructor for <code>std::vector&lt;std::vector&lt;int&gt;::iterator&gt;</code> list-initialized with two iterators.</p>\n<p>This is probably not the desired outcome - we probably wanted a <code>vector&lt;int&gt;</code>. The solution there is simple: use <code>()</code>s:</p>\n<pre><code>std::vector x(v.begin(), v.end()); // uses explicit deduction guide\n</code></pre>\n<p>Now, we're not doing list-initialization so the <code>initializer_list</code> candidate isn't a viable candidate. As a result, we deduce <code>vector&lt;int&gt;</code> through the deduction guide (the only viable candidate), and end up calling the iterator-pair constructor of it. This has the side benefit of actually making the comment correct. </p>\n<hr/>\n<p>This is one of the many places where initializing with <code>{}</code> does something wildly different than initializing with <code>()</code>. Some argue that <code>{}</code> is uniform initialization - which examples like this seem to counter. My rule of thumb: use <code>{}</code> when you specifically, consciously need the behavior that <code>{}</code> provides. <code>()</code> otherwise. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-09-02T00:12:41.050", "Score": "6", "CreationDate": "2017-09-01T13:02:42.283", "ParentId": "45995902", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-09-02T00:12:41.050"}, "45996139": {"Id": "45996139", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45995902_45996139_0\">What are <code>std::vector</code> deduction guides in C++17?</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/class_template_argument_deduction\" rel=\"nofollow noreferrer\">Class template argument deduction</a> specifies: \"In order to instantiate a class template, every template argument must be known, but not every template argument has to be specified.\"</p>\n<p>And that's localized for <code>std:vector</code>, I mean a <code>std:vector</code> is just a class. Nothing special about it.</p>\n<p>Here is the <code>std::vector</code> deducation guide from the ref:</p>\n<pre><code>template&lt; class InputIt,\n          class Alloc = std::allocator&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;&gt;\nvector(InputIt, InputIt, Alloc = Alloc())\n  -&gt; vector&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type, Alloc&gt;;\n</code></pre>\n<p>If you are unfamiliar with the syntax, please read <a href=\"https://stackoverflow.com/questions/40951697/what-are-template-deduction-guides-in-c17\">What are template deduction guides in C++17?</a></p>\n<blockquote>\n<p id=\"so_45995902_45996139_1\">Why and when do we need vector deduction?</p>\n</blockquote>\n<p>You need guides when the deduction of the type from the arguments is not based on the type of one of those arguments.</p>\n<blockquote>\n<p id=\"so_45995902_45996139_2\">Is x a <code>vector&lt;int&gt;</code> or a <code>vector&lt;vector&lt;int&gt;&gt;</code>?</p>\n</blockquote>\n<p>Neither!</p>\n<p>It's an:</p>\n<pre><code>std::vector&lt;std::vector&lt;int&gt;::iterator&gt;\n</code></pre>\n<p>Forcing a simple compilation error (by assigning a number to <code>x</code> for example) will unveil its type):</p>\n<pre><code>error: no match for 'operator=' (operand types are 'std::vector&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int&gt; &gt;, std::allocator&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int&gt; &gt; &gt; &gt;' and 'int')\n</code></pre>\n<hr>\n<p>PS:</p>\n<blockquote>\n<p id=\"so_45995902_45996139_3\">Why do we need that initialization, Alloc = Alloc() in that guide? </p>\n</blockquote>\n<p>That's a <em>default argument</em>, which allows to pass in an allocator. The defaulting means you don't need two guides.</p>\n</hr>", "LastEditorUserId": "2411320", "LastActivityDate": "2017-09-01T16:23:51.630", "Score": "5", "CreationDate": "2017-09-01T08:30:02.440", "ParentId": "45995902", "CommentCount": "6", "OwnerUserId": "2411320", "LastEditDate": "2017-09-01T16:23:51.630"}});