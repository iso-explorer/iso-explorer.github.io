post_cb({"12629563": {"ParentId": "12364074", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-09-27T20:30:35.320", "Score": "3", "LastEditorUserId": "1424877", "LastEditDate": "2012-09-28T17:25:25.480", "Id": "12629563", "OwnerUserId": "1424877", "Body": "<p>(My answer is greatly informed by DS's previous answer.)</p>\n<p>First of all, notice that you have <code>class is_okay { typedef void type; }</code>, i.e., <code>type</code> is a private member of <code>is_okay</code>. This means that it's not actually visible outside the class and therefore</p>\n<pre><code>template&lt; class U &gt;\nstatic yes sfinae( typename is_equal&lt; sizeof U(), sizeof U() &gt;::type * );\n</code></pre>\n<p>will never succeed. However, SFINAE didn't originally apply to this situation in C++98; it wasn't until the resolution to DR 1170 that \"access checking [started being] done as part of the substitution process\".<a href=\"https://blogs.oracle.com/pcarlini/entry/c_11_tidbits_access_control\" rel=\"nofollow\">[1]</a></p>\n<blockquote>\n<p id=\"so_12364074_12629563_0\">(Amazingly, Paolo Carlini wrote that blog entry just 10 days ago, so your timing with this question is impeccable. In cases like this, according to Carlini, GCC prior to 4.8 didn't do access checking during SFINAE at all. So that explains why you didn't see GCC complaining about the private-ness of <code>type</code>. You'd have to be using a top-of-tree GCC from literally less than two weeks ago, in order to see the correct behavior.)</p>\n</blockquote>\n<p>Clang (top-of-tree) follows the DR in <code>-std=c++11</code> mode, but gives the expected error in its default C++03 mode (i.e. Clang doesn't follow the DR in C++03 mode). This is slightly odd but maybe they do it for backwards compatibility.</p>\n<p>But <em>anyway</em>, you don't actually want <code>type</code> to be private in the first place. What you meant to write is <code>struct is_equal</code> and <code>struct is_okay</code>.</p>\n<p>With this change, Clang passes all of your test cases. GCC 4.6.1 passes all of your test cases too, <em>except</em> for <code>int[100]</code>. GCC thinks that <code>int[100]</code> is okay, whereas you're asserting that it's <em>not</em> okay.</p>\n<p>But another problem with your code is that it doesn't test what you think it's testing. The C++ standard, clause 8.5#10, says very clearly: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">[2]</a></p>\n<blockquote>\n<p id=\"so_12364074_12629563_1\">An object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be value-initialized.</p>\n</blockquote>\n<p>So when you write <code>sizeof U()</code>, you're not testing if <code>U</code> can be <em>default</em>-initialized; you're testing if it can be <em>value</em>-initialized!</p>\n<p>...Or are you? At least in some of my test cases, GCC's error messages indicated that <code>U()</code> was being interpreted as the name of a type \u2014 \"function returning <code>U</code>\" \u2014 and <em>that</em> was why <code>int[100]</code> behaved differently. I don't see how that behavior is valid, but I really don't understand the syntactic subtleties here.</p>\n<p>If you really mean to test <em>default</em> initialization, you should use something like <code>sizeof *new U</code> everywhere you currently have <code>sizeof U()</code>.</p>\n<p>By the way, <code>int[100]</code> <strong><em>is</em></strong> default-initializable, period. The Standard is clear on what it means to default-initialize an array type.</p>\n<p>Finally, I wonder if one cause of wacky behavior in your code is that you're trying to pass an unadorned <code>0</code> (which is of type <code>int</code>) to a function whose set of overloads includes one function taking <code>void *</code> and one taking <code>...</code>. I could totally understand if a compiler picked the wrong one in that case. You'd be better advised to try passing <code>0</code> to a function taking <code>int</code>.</p>\n<p>Putting it all together, here's a version of your code that works perfectly for me (i.e., no assertion-failures) in both ToT Clang and GCC 4.6.1.</p>\n<pre><code>template&lt; class T &gt;\nclass is_default_constructible {\n    typedef int yes;\n    typedef char no;\n\n    template&lt;int x&gt; struct is_okay { typedef int type; };\n\n    template&lt; class U &gt;\n    static yes sfinae( typename is_okay&lt; sizeof (*new U) &gt;::type );\n\n    template&lt; class U &gt;\n    static no sfinae( ... );\n\npublic:\n    enum { value = sizeof( sfinae&lt;T&gt;(0) ) == sizeof(yes) };\n};\n\n#if __has_feature(cxx_static_assert)\n#define BOOST_STATIC_ASSERT(x) static_assert(x, \"or fail\")\n#else\n#define dummy2(line) dummy ## line\n#define dummy(line) dummy2(line)\n#define BOOST_STATIC_ASSERT(x) int dummy(__COUNTER__)[(x) - 1]\n#endif\n\n#include &lt;string&gt;\n\nBOOST_STATIC_ASSERT( !is_default_constructible&lt;int()&gt;::value );\nBOOST_STATIC_ASSERT( is_default_constructible&lt;bool&gt;::value );\nBOOST_STATIC_ASSERT( is_default_constructible&lt;std::string&gt;::value );\nBOOST_STATIC_ASSERT( is_default_constructible&lt;int[100]&gt;::value );\n\nBOOST_STATIC_ASSERT( is_default_constructible&lt;const std::string&gt;::value );\n\nstruct NotDefaultConstructible {\n    const int x;\n    NotDefaultConstructible( int a ) : x(a) {}\n};\n\nBOOST_STATIC_ASSERT( !is_default_constructible&lt;NotDefaultConstructible&gt;::value );\n\nstruct DefaultConstructible {\n    const int x;\n\n    DefaultConstructible() : x(0) {}\n};\n\nBOOST_STATIC_ASSERT( is_default_constructible&lt;DefaultConstructible&gt;::value );\n</code></pre>\n", "LastActivityDate": "2012-09-28T17:25:25.480"}, "12616416": {"ParentId": "12364074", "CommentCount": "0", "CreationDate": "2012-09-27T07:40:02.383", "OwnerUserId": "328565", "PostTypeId": "2", "Id": "12616416", "Score": "3", "Body": "<p>This seems almost certainly an artifact (bug) of the compiler, since g++ behaves (and fails) differently. I can only guess at why VS behaves differently, but one guess that seems reasonable is that this class:</p>\n<pre><code>template&lt;int x&gt; class is_okay { typedef void type; };\n</code></pre>\n<p>has the same definition regardless of the template parameter, so perhaps the compiler skips a step when analyzing <code>static sfinae( typename is_okay&lt; sizeof U() &gt;::type * );</code> and considers it well-defined without looking closely at the parameter of <code>is_okay</code>. So then it thinks everything is default-constructible.</p>\n<p>Why neither VS nor g++ is bothered by <code>is_okay::type</code> being private, I don't know. Seems like they both should be.</p>\n<p>g++, on the other hand, treats both versions as equivalent. In both, however, it gives a different error for <code>int[100]</code>. That one is debatable as to whether it should be default-constructible. You seem to think it shouldn't be. g++47's <code>std::is_default_constructible</code> thinks it is! To get that behavior (which is likely more standard), you can replace <code>T</code> with <code>typename boost::remove_all_extents&lt;T&gt;::type</code> in the <code>enum</code> line.</p>\n", "LastActivityDate": "2012-09-27T07:40:02.383"}, "12364074": {"CommentCount": "9", "AcceptedAnswerId": "12629563", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-09-11T06:41:12.253", "LastActivityDate": "2012-09-28T17:25:25.480", "LastEditDate": "2017-05-23T10:25:07.943", "ViewCount": "979", "FavoriteCount": "2", "Title": "Why does using two sizeofs work to check whether a class is default constructible, but one does not?", "Id": "12364074", "Score": "19", "Body": "<p>I used the code from \"<a href=\"https://stackoverflow.com/a/2770326/854731\">Is there a way to test whether a C++ class has a default constructor (other than compiler-provided type traits)?</a>\".</p>\n<p>I modified it slightly to work with all my test cases:</p>\n<pre><code>template&lt; class T &gt;\nclass is_default_constructible {\n    typedef int yes;\n    typedef char no;\n\n\n    // the second version does not work\n#if 1\n    template&lt;int x, int y&gt; class is_equal {};\n    template&lt;int x&gt; class is_equal&lt;x,x&gt; { typedef void type; };\n\n    template&lt; class U &gt;\n    static yes sfinae( typename is_equal&lt; sizeof U(), sizeof U() &gt;::type * );\n#else\n    template&lt;int x&gt; class is_okay { typedef void type; };\n\n    template&lt; class U &gt;\n    static yes sfinae( typename is_okay&lt; sizeof U() &gt;::type * );\n#endif\n\n    template&lt; class U &gt;\n    static no sfinae( ... );\n\npublic:\n    enum { value = sizeof( sfinae&lt;T&gt;(0) ) == sizeof(yes) };\n};\n</code></pre>\n<p>Why does it work correctly with the two template argument version but not with the normal one (set <code>#if 0</code>)?\nIs this a compiler bug? I'm using Visual Studio 2010.</p>\n<p>I used the following tests:</p>\n<pre><code>BOOST_STATIC_ASSERT( is_default_constructible&lt;int&gt;::value );\nBOOST_STATIC_ASSERT( is_default_constructible&lt;bool&gt;::value );\nBOOST_STATIC_ASSERT( is_default_constructible&lt;std::string&gt;::value );\nBOOST_STATIC_ASSERT( !is_default_constructible&lt;int[100]&gt;::value );\n\nBOOST_STATIC_ASSERT( is_default_constructible&lt;const std::string&gt;::value );\n\nstruct NotDefaultConstructible {\n    const int x;\n    NotDefaultConstructible( int a ) : x(a) {}\n};\n\nBOOST_STATIC_ASSERT( !is_default_constructible&lt;NotDefaultConstructible&gt;::value );\n\nstruct DefaultConstructible {\n    const int x;\n\n    DefaultConstructible() : x(0) {}\n};\n\nBOOST_STATIC_ASSERT( is_default_constructible&lt;DefaultConstructible&gt;::value );\n</code></pre>\n<p>I'm really at a loss here:</p>\n<ol>\n<li>Two tests are failing with the other version: <code>int[100]</code> and <code>NotDefaultConstructible</code>. All the tests succeed with the two template argument version.</li>\n<li>Visual Studio 2010 does not support <code>std::is_default_constructible</code>. However, my question is about why there is any difference in the two implementations and why one works and the other does not.</li>\n</ol>\n", "Tags": "<c++><templates><metaprogramming>", "OwnerUserId": "854731", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12364074_12629563_1": {"section_id": 3290, "quality": 1.0, "length": 7}}, "n3337": {"so_12364074_12629563_1": {"section_id": 3160, "quality": 1.0, "length": 7}}, "n4659": {"so_12364074_12629563_1": {"section_id": 4052, "quality": 1.0, "length": 7}}}});