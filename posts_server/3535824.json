post_cb({"3535834": {"ParentId": "3535824", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2010-08-21T01:11:34.800", "OwnerUserId": "151292", "CommunityOwnedDate": "2010-08-21T02:27:15.523", "Id": "3535834", "Score": "2", "Body": "<blockquote>\n<p id=\"so_3535824_3535834_0\">So, is \"string\" a <code>std::string</code>, a c-string or a <code>char*</code>, or does it depend on the context?</p>\n</blockquote>\n<p>It depends entirely on the context.  :-)  Welcome to C++.</p>\n<p>A C string is a null-terminated string, which is almost always the same thing as a <code>char*</code>.</p>\n<p>Depending on the platforms and frameworks you are using, there might be even more meanings of the word \"string\" (for example, it is also used to refer to <code>QString</code> in Qt or <code>CString</code> in MFC).</p>\n", "LastActivityDate": "2010-08-21T01:11:34.800"}, "3535847": {"ParentId": "3535824", "PostTypeId": "2", "CommentCount": "10", "Body": "<pre><code>std::string file = \"file.txt\"; \n</code></pre>\n<p>The right hand side of the <code>=</code> contains a (raw) string literal (i.a. a null-terminated byte string). Its effective type is <code>array of const char</code>.</p>\n<p>The <code>=</code> is a tricky pony here: No assignment happens. The <code>std::string</code> class has a constructor that takes a pointer to char as an argument and this is called to create a temporary <code>std::string</code> and this is used to copy-construct (using the copy ctor of <code>std::string</code>) the object <code>file</code> of type <code>std::string</code>.</p>\n<p>The compiler is free to elide the copy ctor and directly instantiate file though.</p>\n<p>However, note that <code>std:string</code> is not the same thing as a C-style null-terminated string. It is not even required to be null-terminated.</p>\n<pre><code>ifstream inf(\"file.txt\");\n</code></pre>\n<p>The <code>std::ifstream</code> class has a ctor that takes a <code>const char *</code> and the string literal passed to it decays to a pointer to the first element of the string. </p>\n<p>The thing to remember is this: <code>std::string</code> provides (almost seamless) conversion from C-style strings. You have to look up the signature of the function to see if you are passing in a <code>const char *</code> or a <code>std::string</code> (the latter because of implicit conversions).</p>\n", "OwnerUserId": "66692", "LastEditorUserId": "66692", "LastEditDate": "2010-08-21T01:37:39.433", "Id": "3535847", "Score": "3", "CreationDate": "2010-08-21T01:17:32.867", "LastActivityDate": "2010-08-21T01:37:39.433"}, "3535876": {"ParentId": "3535824", "CommentCount": "1", "Body": "<p>As often as possible it should mean <code>std::string</code> (or an alternative such as <code>wxString</code>, <code>QString</code>, etc., if you're using a framework that supplies such. Sometimes you have no real choice but to use a NUL-terminated byte sequence, but you generally want to avoid it when possible.</p>\n<p>Ultimately, there simply is no clear, unambiguous terminology. Such is life.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3535876", "Score": "0", "CreationDate": "2010-08-21T01:30:04.647", "LastActivityDate": "2010-08-21T01:30:04.647"}, "3536096": {"ParentId": "3535824", "CommentCount": "0", "Body": "<p><code>\"myString\"</code> is a string literal, and has the type <code>const char[9]</code>, an array of 9 constant <code>char</code>.  Note that it has enough space for the null terminator.  So <code>\"Hi\"</code> is a <code>const char[3]</code>, and so forth.</p>\n<p>This is pretty much always true, with no ambiguity.  However, whenever necessary, a <code>const char[9]</code> will decay into a <code>const char*</code> that points to its first element.  And <code>std::string</code> has an implicit constructor that accepts a <code>const char*</code>.  So while it always starts as an array of char, it can become the other types if you need it to.</p>\n<p>Note that string literals have the unique property that <code>const char[N]</code> can also decay into <code>char*</code>, but this behavior is deprecated.  If you try to modify the underlying string this way, you end up with undefined behavior.  Its just not a good idea.</p>\n", "OwnerUserId": "293791", "PostTypeId": "2", "Id": "3536096", "Score": "7", "CreationDate": "2010-08-21T03:04:57.070", "LastActivityDate": "2010-08-21T03:04:57.070"}, "3535904": {"ParentId": "3535824", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_3535824_3535904_0\">So, is \"string\" a std::string, a c-string or a *char, or does it depend on the context? </p>\n</blockquote>\n<ul>\n<li>Neither C nor C++ have a built-in string data type, so any double-quoted strings in your code are essentially <code>const char *</code> (or <code>const char []</code> to be exact). \"C string\" usually refers to this, specifically a character array with a null terminator.</li>\n<li>In C++, <code>std::string</code> is a convenience class that wraps a raw string into an object. By using this, you can avoid having to do (messy) pointer arithmetic and memory reallocations by yourself.</li>\n<li>Most standard library functions still take only <code>char *</code> (or <code>const char *</code>) parameters.</li>\n<li>You can implicitly convert a <code>char *</code> into <code>std::string</code> because the latter has a constructor to do that.</li>\n<li>You must explicitly convert a <code>std::string</code> into a <code>const char *</code> by using the <code>c_str()</code> method.</li>\n</ul>\n<p>Thanks to Clark Gaebel for pointing out <code>const</code>ness, and jalf and GMan for mentioning that it is actually an array.</p>\n", "OwnerUserId": "381345", "LastEditorUserId": "381345", "LastEditDate": "2010-08-21T15:13:40.523", "Id": "3535904", "Score": "9", "CreationDate": "2010-08-21T01:42:01.903", "LastActivityDate": "2010-08-21T15:13:40.523"}, "29465106": {"ParentId": "3535824", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Neither C nor C++ have a built-in string data type. </p>\n<p>When the compiler finds, during the compilation, a <strong>double-quoted</strong> strings is implicitly referred (see the code below), the string itself is stored in program code/text and generates code to create even character array:</p>\n<ul>\n<li>The array is created in static storage because it must persist to be referred later.</li>\n<li>The array is made to constant because it must always contain the original data (Hello).</li>\n</ul>\n<p>So at last, what you have is <strong>const char *</strong> to this constant static character array.</p>\n<pre><code>const char* v()\n{\n    char* text = \u201cHello\u201d;\n    return text;\n    // Above code can be reduced to:\n    // return \u201cHello\u201d;\n}\n</code></pre>\n<p>During the program run, when the control finds opening bracket, it creates \u201ctext\u201d, the char* pointer, in the stack and constant array of 6 elements (including the null terminator \u2018\\0\u2019 at the end) in static memory area. When control finds next line (char* text = \u201cHello\u201d;), the starting address of the 6 element array is assigned to \u201ctext\u201d. In next line (return text;), it returns \u201ctext\u201d. With the closing bracket \u201ctext\u201d will disappear from the stack, but array is still in the static memory area. </p>\n<p>You need not to make return type const. But if you try to change the value in static array using non constant char* it will still give you an error during the run time because the array is constant. So, it\u2019s always good to make return constant to make sure, it cannot be referred by non constant pointer.</p>\n<p>But if the compiler finds a <strong>double-quoted</strong> strings is explicitly referred as an array, the compiler assumes that the programmer is going to (smartly) handle it. See the following wrong example:</p>\n<pre><code>const char* v()\n{\n    char text[] = \u201cHello\u201d;\n    return text;\n}\n</code></pre>\n<p>During the compilation, compiler checks, quoted text and save it as it is in the code to fill the generated array during the runt time. Also, it calculate the array size, in this case again as 6.</p>\n<p>During the program run, with the open bracket, the array \u201ctext[]\u201d with 6 elements is created in stack. But no initialization.  When the code finds (char text[] = \u201cHello\u201d;), the array is initialized (with the text in compiled code). So array is now on the stack. When the compiler finds (return text;), it returns the starting address of the array \u201ctext\u201d. When the compiler find the closing bracket, the array disappears from the stack. So no way to refer it by the return pointer.</p>\n<p>Most standard library functions still take only char * (or const char *) parameters.</p>\n<p>The Standard C++ library has a powerful class called string for manipulating text. The internal data structure for string is character arrays. The Standard C++ string class is designed to take care of (and hide) all the low-level manipulations of character arrays that were previously required of the C programmer. Note that std::string is a class:</p>\n<ul>\n<li>You can implicitly convert a char * into std::string because the\nlatter has a constructor to do that.  </li>\n<li>You can explicitly convert a std::string into a const char * by using the c_str() method.</li>\n</ul>\n", "OwnerUserId": "4753146", "LastEditorUserId": "4753146", "LastEditDate": "2015-04-06T04:05:08.757", "Id": "29465106", "Score": "1", "CreationDate": "2015-04-06T03:51:43.893", "LastActivityDate": "2015-04-06T04:05:08.757"}, "3535917": {"ParentId": "3535824", "CommentCount": "0", "Body": "<p>To use the proper wording (as found in the C++ language standard) <strong>string</strong> is one of the varieties of std::basic_string (including std::string) from chapter 21.3 \"String classes\" (as in C++0x N3092), while the argument of ifstream's constructor is <strong>NTBS</strong> (Null-terminated byte sequence)</p>\n<p>To quote, C++0x N3092 27.9.1.4/2.</p>\n<blockquote>\n<p id=\"so_3535824_3535917_0\">basic_filebuf* open(const char* s, ios_base::openmode mode);</p>\n<p id=\"so_3535824_3535917_1\">...</p>\n<p id=\"so_3535824_3535917_2\">opens a file, if possible, whose name is the NTBS s</p>\n</blockquote>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "3535917", "Score": "0", "CreationDate": "2010-08-21T01:46:16.943", "LastActivityDate": "2010-08-21T01:46:16.943"}, "3535858": {"ParentId": "3535824", "CommentCount": "0", "Body": "<p>The C++ standard library provides a std::string class to manage and represent character sequences. It encapsulates the memory management and is most of the time implemented as a C-string; but that is an implementation detail. It also provides manipulation routines for common tasks.</p>\n<p>The std::string type will always be that (it doesn't have a conversion operator to char* for example, that's why you have the c_str() method), but it can be initialized or assigned to by a C-string (char*). </p>\n<p>On the other hand, if you have a function that takes a std::string or a const std::string&amp; as a parameter, you can pass a c-string (char*) to that function and the compiler will construct a std::string in-place for you. That would be a differing interpretation according to context as you put it.</p>\n", "OwnerUserId": "28275", "PostTypeId": "2", "Id": "3535858", "Score": "1", "CreationDate": "2010-08-21T01:21:54.853", "LastActivityDate": "2010-08-21T01:21:54.853"}, "3535824": {"CommentCount": "3", "AcceptedAnswerId": "3535904", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-08-21T01:07:30.550", "LastActivityDate": "2015-04-06T04:05:08.757", "LastEditDate": "2017-05-23T12:13:38.490", "ViewCount": "3045", "FavoriteCount": "1", "Title": "C++: Is \"my text\" a std::string, a *char or a c-string?", "Id": "3535824", "Score": "7", "Body": "<p>I have just done what appears to be <a href=\"https://stackoverflow.com/questions/721129/spot-the-error-in-this-file-reading-code-c\">a common newbie mistake</a>: </p>\n<p>First we read <a href=\"http://www.learncpp.com/cpp-tutorial/136-basic-file-io/\" rel=\"nofollow noreferrer\">one of many tutorials</a> that goes like this: </p>\n<pre><code> #include &lt;fstream&gt;\n int main() {\n      using namespace std;\n      ifstream inf(\"file.txt\");\n      // (...)\n }  \n</code></pre>\n<p>Secondly, we try to use something similar in our code, which goes something like this:</p>\n<pre><code>#include &lt;fstream&gt;\nint main() {\n    using namespace std;\n    std::string file = \"file.txt\"; // Or get the name of the file \n                                   // from a function that returns std::string.\n    ifstream inf(file);\n    // (...)\n}\n</code></pre>\n<p>Thirdly, the newbie developer is perplexed by some cryptic compiler error message. </p>\n<p>The problem is that <a href=\"http://www.cplusplus.com/reference/iostream/ifstream/ifstream/\" rel=\"nofollow noreferrer\">ifstream</a> takes <code>const * char </code> as a constructor argument.  </p>\n<p>The <a href=\"https://stackoverflow.com/questions/347949/convert-stdstring-to-const-char-or-char\">solution</a> is to <a href=\"http://www.cplusplus.com/reference/string/string/c_str/\" rel=\"nofollow noreferrer\">convert std::string to const * char</a>.</p>\n<p>Now, the real problem is that, for a newbie, \"file.txt\" or similar examples given in almost all the tutorials very much looks like a std::string.  </p>\n<p>So, is \"my text\" a std::string, a c-string or a *char, or does it depend on the context?  </p>\n<p>Can you provide examples on how \"my text\" would be interpreted differently according to context?   </p>\n<p>[Edit: I thought the example above would have made it obvious, but I should have been more explicit nonetheless: what I mean is the type of any string enclosed within double quotes, i.e. \"myfilename.txt\", not the meaning of the word 'string'.]</p>\n<p>Thanks.</p>\n", "Tags": "<c++><string><char>", "OwnerUserId": "401523", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_3535824_3535917_0": {"section_id": 2425, "quality": 0.8, "length": 4}, "so_3535824_3535917_2": {"section_id": 2426, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_3535824_3535917_0": {"section_id": 2410, "quality": 0.8, "length": 4}, "so_3535824_3535917_2": {"section_id": 2411, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_3535824_3535917_0": {"section_id": 2700, "quality": 1.0, "length": 5}, "so_3535824_3535917_2": {"section_id": 2701, "quality": 0.8333333333333334, "length": 5}}}});