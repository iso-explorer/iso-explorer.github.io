post_cb({"14085599": {"ParentId": "14085553", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2012-12-29T20:21:32.300", "Score": "6", "LastEditorUserId": "1149664", "LastEditDate": "2012-12-29T20:40:19.643", "Id": "14085599", "OwnerUserId": "1149664", "Body": "<pre><code>A(A&amp;&amp;) = delete;\n</code></pre>\n<p>Declaring and defining it as <code>delete</code> does still declare it, and does not make it completely non-existent. Rather, it's <em>similar</em> (but not identical) to declaring it empty and private. Like so:</p>\n<pre><code>private: \n  A(A&amp;&amp;){}\n</code></pre>\n<p>In fact, that was the trick sometimes used for other operators before <code>= delete</code> was available.\nAgain, it exists in the sense of lookup, but calling it is not ever allowed and in C++ calling permissions are (in almost or all cases) done after everything else, such as overload resolution, name lookup.</p>\n<p>The standard actually say (8.4.3)</p>\n<blockquote>\n<p id=\"so_14085553_14085599_0\">A deleted function is implicitly inline.</p>\n</blockquote>\n<p>And there's noting (that I find) saying that deleted functions should not participate in name lookup.</p>\n<p>Also, from 8.4.3</p>\n<blockquote>\n<p id=\"so_14085553_14085599_1\">A program that refers to a deleted function implicitly or explicitly,\n  other than to declare it, is ill-formed. [ Note: This includes calling\n  the function implicitly or explicitly and forming a pointer or\n  pointer-to-member to the function. It applies even for references in\n  expressions that are not potentially-evaluated.</p>\n</blockquote>\n", "LastActivityDate": "2012-12-29T20:40:19.643"}, "14085621": {"ParentId": "14085553", "CommentCount": "0", "CreationDate": "2012-12-29T20:23:53.637", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "14085621", "Score": "2", "Body": "<p>When you delete the move constructor, it doesn't remove it from the set of functions found by name lookup. Whenever your code would normally use the move constructor, you will get an error because, even though it was found, it has been deleted.</p>\n<p>You have two moves in your code. The first is when you <code>return a</code> because when copy elision is possible and the object that would be copied is designated by an lvalue (<code>a</code>, here), it is treated as a move. The second is in the assignment <code>A b = f()</code>, because a <code>f()</code> is giving you a temporary that has not yet been bound to a reference.</p>\n<p>If you want the copy constructor to be found rather than the deleted move constructor, you should just get rid of your deleted definition.</p>\n", "LastActivityDate": "2012-12-29T20:23:53.637"}, "14085774": {"ParentId": "14085553", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-12-29T20:47:11.587", "Score": "1", "LastEditorUserId": "1741542", "LastEditDate": "2012-12-29T21:03:53.660", "Id": "14085774", "OwnerUserId": "1741542", "Body": "<p>From C++ Working Draft 2012-11-02</p>\n<blockquote>\n<p id=\"so_14085553_14085774_0\"><strong>8.4.3 Deleted definitions [dcl.fct.def.delete]</strong><br>\n  ...<br>\n  2 A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed. [ <em>Note</em>: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member\n  to the function. It applies even for references in expressions that are not potentially-evaluated. If a function\n  is overloaded, it is referenced only if the function is selected by overload resolution. \u2014 end note ]<br>\n  ...<br>\n  4 A deleted function is implicitly inline.  </br></br></br></br></p>\n</blockquote>\n<p>Since the deleted move constructor is referenced, the program is ill-formed.</p>\n<p>A \"usage\" for a non-movable type could be to prevent moving, and so prevent returning a local object. I haven't seen such a usage myself and I don't know whether this makes sense at all, but YMMV.</p>\n", "LastActivityDate": "2012-12-29T21:03:53.660"}, "14085604": {"ParentId": "14085553", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-12-29T20:21:45.533", "Score": "2", "LastEditorUserId": "1120273", "LastEditDate": "2012-12-29T20:30:14.833", "Id": "14085604", "OwnerUserId": "1120273", "Body": "<p>This is a bit of a research task but I <em>think</em> declaring a move constructor states that the move constructor is to be considered. When it then gets <code>delete</code>d, it means that objects can be moved where they could be moved if there were a move constructor. If you want an object which isn't moved but copied, you'd just declare a copy constructor and you wouldn't mention the move constructor.</p>\n<p>I haven't quite found the statement in the standard, yet, which explicitly states the above but there is Note in 12.8 [class.copy] paragraph 9 backing up part the above statement:</p>\n<blockquote>\n<p id=\"so_14085553_14085604_0\">[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2012-12-29T20:30:14.833"}, "14085553": {"CommentCount": "3", "ViewCount": "1553", "PostTypeId": "1", "ClosedDate": "2012-12-30T14:57:46.770", "LastEditorUserId": "-1", "CreationDate": "2012-12-29T20:16:54.007", "LastActivityDate": "2012-12-30T12:34:54.460", "LastEditDate": "2017-05-23T12:06:33.847", "FavoriteCount": "3", "Title": "C++11 \"Non-movable\" type", "Id": "14085553", "Score": "11", "Body": "<blockquote>\n<p id=\"so_14085553_14085553_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/14085620/why-do-c11-deleted-functions-participate-in-overload-resolution\">Why do C++11-deleted functions participate in overload resolution?</a> </br></p>\n</blockquote>\n<p>I have two questions about the following C++11 code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct A {\n  A()  { cout &lt;&lt; \"Default c-tor\" &lt;&lt; endl; }\n  A(const A&amp;)  { cout &lt;&lt; \"Copy c-tor\" &lt;&lt; endl; }\n  A(A&amp;&amp;) = delete;\n};\n\nA f()\n{\n A a;\n return a;\n}\n\nint main()\n{\n  A b = f();\n  return 0;\n}\n</code></pre>\n<p>I get the following compile errors with gcc and clang</p>\n<p>gcc-4.7.2 (g++ --std=c++11 main.cpp):</p>\n<pre><code>main.cpp: In function \u2018A f()\u2019:\nmain.cpp:16:9: error: use of deleted function \u2018A::A(A&amp;&amp;)\u2019\nmain.cpp:8:2: error: declared here\nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:21:10: error: use of deleted function \u2018A::A(A&amp;&amp;)\u2019\nmain.cpp:8:2: error: declared here\n</code></pre>\n<p>clang-3.0 (clang++ --std=c++11 main.cpp):</p>\n<pre><code>main.cpp:19:4: error: call to deleted constructor of 'A'\n        A b = f();\n          ^   ~~~\nmain.cpp:8:2: note: function has been explicitly marked deleted here\n        A(A&amp;&amp;) = delete;\n        ^\n1 error generated.\n</code></pre>\n<ul>\n<li>Shouldn't the compiler use the copy constructor if the move constructor is explicitly deleted?</li>\n<li>Does anyone know any use for \"non-movable\" types? </li>\n</ul>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><gcc><c++11><clang><move-semantics>", "OwnerUserId": "1935175", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14085553_14085599_0": {"section_id": 3279, "quality": 1.0, "length": 4}, "so_14085553_14085599_1": {"section_id": 3277, "quality": 0.92, "length": 23}, "so_14085553_14085604_0": {"section_id": 458, "quality": 0.8636363636363636, "length": 19}, "so_14085553_14085774_0": {"section_id": 3277, "quality": 0.7142857142857143, "length": 30}}, "n3337": {"so_14085553_14085599_0": {"section_id": 3150, "quality": 1.0, "length": 4}, "so_14085553_14085599_1": {"section_id": 3148, "quality": 0.92, "length": 23}, "so_14085553_14085604_0": {"section_id": 449, "quality": 0.8636363636363636, "length": 19}, "so_14085553_14085774_0": {"section_id": 3148, "quality": 0.7142857142857143, "length": 30}}, "n4659": {"so_14085553_14085599_0": {"section_id": 4037, "quality": 1.0, "length": 4}, "so_14085553_14085599_1": {"section_id": 4035, "quality": 0.92, "length": 23}, "so_14085553_14085604_0": {"section_id": 481, "quality": 0.8636363636363636, "length": 19}, "so_14085553_14085774_0": {"section_id": 4035, "quality": 0.7380952380952381, "length": 31}}}});