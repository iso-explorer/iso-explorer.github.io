post_cb({"bq_ids": {"n4140": {"so_9964786_9964844_1": {"length": 68, "quality": 0.8831168831168831, "section_id": 2973}, "so_9964786_9964844_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 2974}, "so_9964786_9964844_0": {"length": 18, "quality": 1.0, "section_id": 5810}}, "n3337": {"so_9964786_9964844_1": {"length": 68, "quality": 0.8831168831168831, "section_id": 2842}, "so_9964786_9964844_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 2843}, "so_9964786_9964844_0": {"length": 18, "quality": 1.0, "section_id": 5583}}, "n4659": {"so_9964786_9964844_1": {"length": 68, "quality": 0.8831168831168831, "section_id": 3732}, "so_9964786_9964844_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 3733}, "so_9964786_9964844_0": {"length": 18, "quality": 1.0, "section_id": 7271}}}, "9964844": {"Id": "9964844", "PostTypeId": "2", "Body": "<p>Programming in C++ would be essentially impossible if the compiler was allowed to produce code that matched what you describe.</p>\n<p>This is stated in \u00a71.9/14 <em>Program Execution</em> (n3290):</p>\n<blockquote>\n<p id=\"so_9964786_9964844_0\">Every value computation and side effect associated with a full-expression is sequenced before every value\n  computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>Your <code>return</code> statement is sequenced after the preceding full expression. The compiler has to output code <em>as if</em> all side-effects of that preceding statement has been completely evaluated before it evaluates the return statement.<br>\nYour example doesn't respect that rule, since it evaluates <code>*data</code> before taking into account the side-effects of the <code>std::call_once(...)</code> full expression.</br></p>\n<p>Additionally, <code>std::call_once</code> has this in its description (\u00a730.4.4.2/2 and 3):</p>\n<blockquote>\n<p id=\"so_9964786_9964844_1\">2/ <em>Effects</em>: An execution of call_once that does not call its func is a passive execution. An execution of call_once that calls its func is an active execution. An active execution shall call <code>INVOKE (DECAY_-\n  COPY ( std::forward&lt;Callable&gt;(func)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code>. If such\n  a call to func throws an exception the execution is exceptional, otherwise it is returning. An exceptional execution shall propagate the exception to the caller of call_once. Among all executions of call_once for any given once_flag: at most one shall be a returning execution; if there is a returning execution, it shall be the last active execution; and there are passive executions only if there is a returning execution. [ <strong>Note: passive executions allow other threads to reliably observe the results produced by the earlier returning execution. \u2014 end note</strong> ]</p>\n<p id=\"so_9964786_9964844_2\">3/ <em>Synchronization</em>: For any given once_flag: all active executions occur in a total order; completion of an active execution synchronizes with the start of the next one in this total order; and the returning execution synchronizes with the return from all passive executions.</p>\n</blockquote>\n<p>So the standard mandates synchronization to fit your use-case.</p>\n", "LastEditorUserId": "635608", "LastActivityDate": "2012-04-01T14:45:31.310", "Score": "7", "CreationDate": "2012-04-01T13:44:56.530", "ParentId": "9964786", "CommentCount": "4", "OwnerUserId": "635608", "LastEditDate": "2012-04-01T14:45:31.310"}, "9964786": {"ViewCount": "1179", "Body": "<p>Given the code from <a href=\"http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html\" rel=\"nofollow\">here</a>:</p>\n<pre><code>class lazy_init\n{\n    mutable std::once_flag flag;\n    mutable std::unique_ptr&lt;expensive_data&gt; data;\n\n    void do_init() const\n    {\n        data.reset(new expensive_data);\n    }\npublic:\n    expensive_data const&amp; get_data() const\n    {\n        std::call_once(flag,&amp;lazy_init::do_init,this);\n        return *data;\n    }\n};\n</code></pre>\n<p>And I saw a few variants of the same pattern elsewhere also. So my question is: why this code is considered save? and why compiler can't just read <em>data</em> before calling std::call_once and ends up with an incorrect data?\ne.g</p>\n<pre><code>tmp = data.get();\nstd::call_once(flag,&amp;lazy_init::do_init,this);\nreturn *tmp;\n</code></pre>\n<p>I mean I have found nothing about any barriers which would prevent that. </p>\n", "AcceptedAnswerId": "9964844", "Title": "std::call_once and memory reordering", "CreationDate": "2012-04-01T13:33:47.523", "Id": "9964786", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-04-01T17:55:38.843", "LastEditorUserId": "636019", "LastActivityDate": "2012-04-01T17:55:38.843", "Score": "4", "OwnerUserId": "643393", "Tags": "<c++><c++11><memory-fences>", "AnswerCount": "1"}});