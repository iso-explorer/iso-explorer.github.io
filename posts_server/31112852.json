post_cb({"bq_ids": {"n4140": {"so_31112852_31113618_0": {"length": 23, "quality": 0.92, "section_id": 767}}, "n3337": {"so_31112852_31113618_0": {"length": 23, "quality": 0.92, "section_id": 754}}, "n4659": {"so_31112852_31113618_0": {"length": 23, "quality": 0.92, "section_id": 827}}}, "31113618": {"Id": "31113618", "PostTypeId": "2", "Body": "<p>The Standard effectively mandates <code>std::unordered_set</code> and <code>std::unordered_map</code> implementations that use open hashing, which means an array of buckets, each of which holds the head of a logical (and typically actual) list.  That requirement is subtle: it's a consequence of the default max load factor being 1.0 and the guarantee that the table will not be rehashed unless grown beyond that load factor: that would be impractical without chaining, as the collisions with closed hashing become overwhelming as the load factor approaches 1:</p>\n<blockquote>\n<p id=\"so_31112852_31113618_0\">23.2.5/15: The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators if <code>(N+n) &lt; z * B</code>, where <code>N</code> is the number of elements in the container prior to the insert operation, <code>n</code> is the number of elements inserted, <code>B</code> is the container\u2019s bucket count, and <code>z</code> is the container\u2019s maximum load factor.</p>\n<p id=\"so_31112852_31113618_1\">amongst the <em>Effects</em> of the constructor at 23.5.4.2/1: <code>max_load_factor()</code> returns <code>1.0</code>.</p>\n</blockquote>\n<p>(To allow optimal iteration without passing over any empty buckets, GCC's implementation fills the buckets with iterators into a single singly-linked list holding all the values: the iterators point to the element immediately before that bucket's elements, so the next pointer there can be rewired if erasing the bucket's last value.) </p>\n<p>Regarding the text you quote:</p>\n<blockquote>\n<p id=\"so_31112852_31113618_2\">No, that is not at all the most efficient way to implement a hash map for most common uses. Unfortunately, a small \"oversight\" in the specification of unordered_map all but requires this behavior. The required behavior is that iterators to elements must stay valid when inserting or deleting other elements</p>\n</blockquote>\n<p>There is no \"oversight\"... what's done was very deliberate and done with full awareness.  It's true that other compromises could have been struck, but the open hashing / chaining approach is a reasonable compromise for general use, that copes reasonably elegantly with collisions from mediocre hash functions, isn't too wasteful with small or large key/value types, and handles arbitrarily-many <code>insert</code>/<code>erase</code> pairs without gradually degrading performance the way many closed hashing implementations do.</p>\n<p>As evidence of the awareness, from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html\">Matthew Austern's proposal here</a>:</p>\n<blockquote>\n<p id=\"so_31112852_31113618_3\">I'm not aware of any satisfactory implementation of open addressing in a generic framework. Open addressing presents a number of problems: </p>\n<p id=\"so_31112852_31113618_4\">\u2022 It's necessary to distinguish between a vacant position and an occupied one.</p>\n<p id=\"so_31112852_31113618_5\">\u2022 It's necessary either to restrict the hash table to types with a default constructor, and to construct every array element ahead of time, or else to maintain an array some of whose elements are objects and others of which are raw memory.</p>\n<p id=\"so_31112852_31113618_6\">\u2022 Open addressing makes collision management difficult: if you're inserting an element whose hash code maps to an already-occupied location, you need a policy that tells you where to try next. This is a solved problem, but the best known solutions are complicated.</p>\n<p id=\"so_31112852_31113618_7\">\u2022 Collision management is especially complicated when erasing elements is allowed. (See Knuth for a discussion.) A container class for the standard library ought to allow erasure.</p>\n<p id=\"so_31112852_31113618_8\">\u2022 Collision management schemes for open addressing tend to assume a fixed size array that can hold up to N elements. A container class for the standard library ought to be able to grow as necessary when new elements are inserted, up to the limit of available memory.</p>\n<p id=\"so_31112852_31113618_9\">Solving these problems could be an interesting research project, but, in the absence of implementation experience in the context of C++, it would be inappropriate to standardize an open-addressing container class. </p>\n</blockquote>\n<p>Specifically for insert-only tables with data small enough to store directly in the buckets, a convenient sentinel value for unused buckets, and a good hash function, a closed hashing approach may be roughly an order of magnitude faster and use dramatically less memory, but that's not general purpose.</p>\n<p>A full comparison and elaboration of hash table design options and their implications is off topic for S.O. as it's way too broad to address properly here.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2016-04-18T06:24:09.777", "Score": "34", "CreationDate": "2015-06-29T10:41:26.090", "ParentId": "31112852", "CommentCount": "3", "OwnerUserId": "410767", "LastEditDate": "2016-04-18T06:24:09.777"}, "31112852": {"ViewCount": "14231", "Body": "<p><a href=\"https://stackoverflow.com/questions/31098123/c-unordered-map-collision-handling-resize-and-rehash\">c++ unordered_map collision handling , resize and rehash</a></p>\n<p>This is a previous question opened by me and I have seen that I am having a lot of confusion about how unordered_map is implemented. I am sure many other people shares that confusion with me. Based on the information I have know without reading the standard:</p>\n<blockquote>\n<p id=\"so_31112852_31112852_0\">Every unordered_map implementation stores a linked list to external\n  nodes in the array of buckets... No, that is not at all the most\n  efficient way to implement a hash map for most common uses.\n  Unfortunately, a small \"oversight\" in the specification of\n  unordered_map all but requires this behavior. The required behavior is\n  that iterators to elements must stay valid when inserting or deleting\n  other elements</p>\n</blockquote>\n<p>I was hoping that someone might explain the implementation and how it corresponds to the c++ standard definition (in terms of performance requirements ) and if it is really not the  most efficient way to implement an hash map data structure how it can be improved ?</p>\n", "AcceptedAnswerId": "31113618", "Title": "How std::unordered_map is implemented", "CreationDate": "2015-06-29T10:04:52.863", "Id": "31112852", "CommentCount": "10", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:46.517", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-18T06:24:09.777", "ClosedDate": "2015-06-29T13:58:05.907", "Score": "21", "OwnerUserId": "2993035", "Tags": "<c++><c++11><hashmap><unordered-map>", "AnswerCount": "1"}});