post_cb({"32009694": {"CommentCount": "10", "CreationDate": "2015-08-14T12:06:23.563", "PostTypeId": "1", "AcceptedAnswerId": "32010054", "LastEditorUserId": "464581", "LastActivityDate": "2016-08-19T12:36:39.787", "LastEditDate": "2016-08-19T12:36:39.787", "ViewCount": "717", "FavoriteCount": "1", "Title": "Why implicit conversion of bool to string isn't an error?", "Id": "32009694", "Score": "5", "Body": "<p>I goggled it &amp; tried to find similar question on SO also but didn't find anything useful. So, posting my question here.</p>\n<p>Consider this program:</p>\n<pre><code>#include &lt;iostream&gt;\nvoid foo(const std::string &amp;) {}\nint main() \n{\n    foo(false);\n}\n</code></pre>\n<pre>\n[Warning] converting 'false' to pointer type for argument 1 of 'std::basic_string::basic_string(const _CharT*, const _Alloc&amp;) [with _CharT = char; _Traits = std::char_traits; _Alloc = std::allocator]' [-Wconversion-null]\n</pre>\n<p>Why C++ allows this without explicit cast? I was expecting to get compiler error. The program abnormally terminates at runtime due to exception displaying following:</p>\n<pre><code>terminate called after throwing an instance of 'std::logic_error'\n  what():  basic_string::_S_construct null not valid\n\nThis application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information.\n</code></pre>\n<p>What the standard says about this type of implicit conversion? </p>\n", "Tags": "<c++><string><boolean><language-lawyer><implicit-conversion>", "OwnerUserId": "3777958", "AnswerCount": "3"}, "32009989": {"ParentId": "32009694", "CommentCount": "5", "Body": "<p>What happens is that an <code>std::string</code> is implicitly constructed from <code>false</code>, using the <code>const CharT*</code> overload and converting <code>false</code> to a null pointer. According to the documentation for that constructor :</p>\n<blockquote>\n<p id=\"so_32009694_32009989_0\">The behavior is undefined if <code>s</code> [the pointer] does not point at an array of at least <code>Traits::length(s)+1</code> elements of <code>CharT</code>.</p>\n</blockquote>\n<p>Hence the malfunctioning (in the form of a friendly exception, but don't rely on it).</p>\n<p>Now, is it correct ? According to [conv.ptr] :</p>\n<blockquote>\n<p id=\"so_32009694_32009989_1\">A <em>null pointer constant</em> is an integer literal (2.13.2) with value zero or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p><code>false</code> has indeed a value of zero, but is not an integer literal (it's a boolean literal). The implicit conversion to the <code>CharT*</code> that <code>std::string</code>'s constructor takes is thus non-standard.</p>\n<p>And indeed, while GCC emits a warning, Clang refuses to compile it.</p>\n", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "32009989", "Score": "3", "CreationDate": "2015-08-14T12:22:04.073", "LastActivityDate": "2015-08-14T12:22:04.073"}, "32009769": {"ParentId": "32009694", "CommentCount": "0", "Body": "<p>A bool is basically an integer so it will be interpreted as a zero ,in your case it is probablly the 0 character and this will cause that problem the string will an exception</p>\n", "OwnerUserId": "3318862", "PostTypeId": "2", "Id": "32009769", "Score": "-1", "CreationDate": "2015-08-14T12:10:08.253", "LastActivityDate": "2015-08-14T12:10:08.253"}, "bq_ids": {"n4140": {"so_32009694_32009989_1": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_32009694_32009989_1": {"section_id": 5947, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_32009694_32009989_1": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}}, "32010054": {"ParentId": "32009694", "LastEditDate": "2015-08-14T12:46:19.430", "CommentCount": "9", "CreationDate": "2015-08-14T12:25:02.333", "OwnerUserId": "153285", "LastEditorUserId": "153285", "PostTypeId": "2", "Id": "32010054", "Score": "7", "Body": "<p>Before C++11 introduced the <code>nullptr</code> keyword, null pointers were a bit of a  hack. Any integer literal equal to zero would suffice as a null pointer constant, and <code>false</code> fit the bill.</p>\n<p>So, the effect of your program is to construct the <code>std::string</code> with a <code>char const *</code> argument of <code>NULL</code>. The constructor doesn't support null pointers, so you get undefined behavior.</p>\n<p>The solution to this problem is to use a newer dialect of C++. Pass <code>-std=c++11</code> to the compiler if necessary, or <code>-std=c++14</code>. Then you should get something like this:</p>\n<blockquote id=\"so_32009694_32010054_0\">\n<pre><code>error: no matching function for call to 'foo'\n</code></pre>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7f3048229a1d0e5a\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/7f3048229a1d0e5a</a></p>\n<p><strong>EDIT:</strong> Hmm, GCC doesn't appear to implement this change yet. That's a bit surprising. You might try Clang.</p>\n<p>I've <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67216\" rel=\"nofollow\">filed</a> a bug report.</p>\n", "LastActivityDate": "2015-08-14T12:46:19.430"}});