post_cb({"17551625": {"ParentId": "17551087", "LastEditDate": "2013-07-09T15:31:31.723", "CommentCount": "5", "CreationDate": "2013-07-09T15:01:48.620", "OwnerUserId": "348388", "LastEditorUserId": "348388", "PostTypeId": "2", "Id": "17551625", "Score": "0", "Body": "<p>In the norm:</p>\n<blockquote>\n<p id=\"so_17551087_17551625_0\"><strong>3.6.1.5 -</strong> A return statement in main has the effect of leaving the main function\n  (destroying any objects with automatic storage duration)</p>\n</blockquote>\n<p>So, during your program, you create several variables. When returning from main, only those with automatic storage duration are destroyed. Those with dynamic storage duration are not. For your variables with dynamic storage duration, you have to explicitly call <code>delete</code>.</p>\n<p>Here is a small example. Put a breakpoint in the destructor and check for m_name value.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass A\n{\npublic:\n    A(const std::string &amp;name):m_name(name){}\n\n    ~A()\n    {\n        std::cout&lt;&lt;\"deleting \"&lt;&lt;m_name&lt;&lt;std::endl;\n    }\n\nprivate:\n    std::string m_name;\n};\n\nA a(\"Variable at namespace scope\");\n\nint main()\n{\n    A a0(\"Automatic storage\"); \n    A *a1 = new A(\"Dynamic storage 1\"); \n    A *a2 = new A(\"Dynamic storage 2\"); \n    delete a2;\n    static A a3(\"Static storage\");\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2013-07-09T15:31:31.723"}, "17551125": {"ParentId": "17551087", "CommentCount": "0", "Body": "<p>Because you use dynamic allocation. And for that you are responsible of destroying what you allocate.  </p>\n<p>read about new and delete here: \n<a href=\"http://www.cplusplus.com/reference/new/\" rel=\"nofollow\">http://www.cplusplus.com/reference/new/</a></p>\n", "OwnerUserId": "849602", "PostTypeId": "2", "Id": "17551125", "Score": "2", "CreationDate": "2013-07-09T14:39:44.417", "LastActivityDate": "2013-07-09T14:39:44.417"}, "17551087": {"CommentCount": "2", "ViewCount": "104", "CreationDate": "2013-07-09T14:37:35.817", "LastActivityDate": "2013-07-09T15:31:31.723", "Title": "Constructors and destructors", "AcceptedAnswerId": "17551129", "PostTypeId": "1", "Id": "17551087", "Score": "1", "Body": "<p>I have the following code and as I knew,at the end of a program which uses class constructors,if certain objects were created,they're destroyed.Judging by that,at the end of the execution I should've had some \"~B()\" and \"~D()\" printed out in a particular order but that's not happening when I'm runing the code.Why's that?</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\n\nclass B{\npublic:\n    B(){cout&lt;&lt;\"B()\";}\n    virtual void print(){cout&lt;&lt;\"b\";}\n    ~B(){cout&lt;&lt;\"~B()\";}\n};\n\nclass D:public B{\npublic:\n    D(){cout&lt;&lt;\"D()\";}\n    void print(){B::print()\n    ;cout&lt;&lt;\"d\";}\n    ~D(){cout&lt;&lt;\"~D()\";}\n    };\n\nvoid testI(){\n    B* b[]={new B(),new D()};\n    b[1]-&gt;print();\n    B&amp;c=*b[1];\n    c.print();\n}\n\n\n\nint main(){\n    testI();\nreturn 0;\n}\n</code></pre>\n", "Tags": "<c++><constructor><eclipse-cdt><destructor>", "OwnerUserId": "2177920", "AnswerCount": "4"}, "17551473": {"ParentId": "17551087", "CommentCount": "0", "Body": "<p>You're using new to allocate dynamic memory without deleting objects. While you can solve this by adding a delete statement,as your code gets more complex you'll find manual memory management can get unwieldy and error-prone.</p>\n<p>You'll be much better off using the automatic memory management classes like  <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, and using container classes like <code>std::vector</code>.</p>\n<pre><code>void testI()\n{\n    std::vector&lt;std::shared_ptr&lt;B&gt;&gt; b = {std::make_shared&lt;B&gt;(), std::make_shared&lt;D&gt;()};\n    b[1]-&gt;print();\n    B&amp; c= *b[1];\n    c.print();\n} //b is destroyed here\n</code></pre>\n", "OwnerUserId": "1540733", "PostTypeId": "2", "Id": "17551473", "Score": "0", "CreationDate": "2013-07-09T14:54:01.430", "LastActivityDate": "2013-07-09T14:54:01.430"}, "17551129": {"ParentId": "17551087", "CommentCount": "1", "Body": "<p>You are creating your objects with <code>new</code>, this means that they are allocated on the heap and NOT the stack and there fore it is up to you to delete them.</p>\n<pre><code>B * b = new B();\n</code></pre>\n<p>Later on..</p>\n<pre><code>delete b;\n</code></pre>\n<p>Edit:</p>\n<p>For arrays use:</p>\n<pre><code>delete[] b; //if b is a pointer to an array of B's\n</code></pre>\n", "OwnerUserId": "2236401", "PostTypeId": "2", "Id": "17551129", "Score": "3", "CreationDate": "2013-07-09T14:39:59.150", "LastActivityDate": "2013-07-09T14:39:59.150"}, "bq_ids": {"n4140": {"so_17551087_17551625_0": {"section_id": 7149, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_17551087_17551625_0": {"section_id": 6893, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_17551087_17551625_0": {"section_id": 8650, "quality": 0.9230769230769231, "length": 12}}}});