post_cb({"bq_ids": {"n4140": {"so_19712539_19713329_0": {"length": 19, "quality": 0.95, "section_id": 7003}, "so_19712539_19713329_1": {"length": 14, "quality": 1.0, "section_id": 7003}}, "n3337": {"so_19712539_19713329_0": {"length": 19, "quality": 0.95, "section_id": 6749}, "so_19712539_19713329_1": {"length": 14, "quality": 1.0, "section_id": 6749}}, "n4659": {"so_19712539_19713329_0": {"length": 19, "quality": 0.95, "section_id": 8500}, "so_19712539_19713329_1": {"length": 14, "quality": 1.0, "section_id": 8500}}}, "19712539": {"ViewCount": "2277", "Body": "<p>In the code below, I get the following warning and error:</p>\n<pre><code>test.cpp:15: warning: direct base 'B' inaccessible in 'D' due to ambiguity\ntest.cpp:15: error: no unique final overrider for 'virtual void A::f()' in 'D'\n</code></pre>\n<p>But if I remove the virtual inheritance of B from A (i.e. <code>struct B : public A</code>), I only get the warning, no error.</p>\n<pre><code>struct A\n{\n  virtual void f() = 0;\n};\n\nstruct B : public virtual A\n{\n  void f() {}\n};\n\nclass C : public B\n{};\n\nstruct D : public C, virtual B\n{};\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p>Why? Is this the dreaded diamond?</p>\n", "AcceptedAnswerId": "19712877", "Title": "Why does GCC give me an error: no unique final overrider?", "CreationDate": "2013-10-31T17:01:07.237", "Id": "19712539", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-31T18:49:58.793", "Score": "4", "OwnerUserId": "1958315", "Tags": "<c++><gcc><diamond-problem>", "AnswerCount": "3"}, "19713329": {"Id": "19713329", "PostTypeId": "2", "Body": "<p>Let's look at the definition of 'final overrider' from <code>10.3[class.virtual]/2</code></p>\n<blockquote>\n<p id=\"so_19712539_19713329_0\">A virtual member function <code>C::vf</code> of a class object <code>S</code> is a final overrider unless the most derived class of which <code>S</code> is a base class subobject (if any) declares or inherits another member function that overrides <code>vf</code>.</p>\n<p id=\"so_19712539_19713329_1\">In a derived class, if a virtual member function of a base class subobject has more than one final overrider the program is ill-formed.</p>\n</blockquote>\n<p>With virtual inheritance from A, there is only one base class subobject of type A, and its virtual member function f() has more than one final overrider (one in each subobject of type B)</p>\n<p>Without virtual inheritance from A, there are two different base class subobjects of type A, and their virtual member functions f() each has its own final overrider (one in each B subobject)</p>\n", "LastActivityDate": "2013-10-31T17:45:43.377", "Score": "2", "CreationDate": "2013-10-31T17:45:43.377", "ParentId": "19712539", "CommentCount": "0", "OwnerUserId": "273767"}, "19713489": {"Id": "19713489", "PostTypeId": "2", "Body": "<p>Virtual base sub-objects are 'shared' between all base sub-objects in a complete object. Since A is is shared between D::C::B and D::B it can't tell which B object should have its <code>f()</code> called as the override for <code>A::f().</code></p>\n<p>Consider:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n  virtual void f() = 0;\n  virtual ~A() {}\n};\n\nstruct B : virtual A\n{\n  void f() { std::cout &lt;&lt; \"B\\n\"; }\n};\n\nstruct C : virtual A\n{\n  void f() { std::cout &lt;&lt; \"C\\n\"; }\n};\n\nstruct D : C, B {};\n\nint main() {\n  D d;\n  A *a = dynamic_cast&lt;A*&gt;(&amp;d); // single shared A between B and C\n  a-&gt;f(); // Should B::f() be called, or C::f()?\n}\n</code></pre>\n<p>The B and C base sub-objects in D both share the same A base sub-object. When we call A::f() a virtual look-up is done for the overriding function. But both B and C are trying to override it, so which one 'wins'? Does <code>x-&gt;f()</code> print \"B\" or \"C\"? The answer is that a program that gets into the situation is ill-formed.</p>\n<p>When we eliminate the sharing by making B and C inherit non-virtually, then the separate A base sub-objects each have their functions overridden by unique base classes:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n  virtual void f() = 0;\n  virtual ~A() {}\n};\n\nstruct B : A\n{\n  void f() { std::cout &lt;&lt; \"B\\n\"; }\n};\n\nstruct C : A\n{\n  void f() { std::cout &lt;&lt; \"C\\n\"; }\n};\n\nstruct D : C, B {};\n\nint main() {\n  D d;\n  // two different A objects\n  A *a1 = static_cast&lt;A*&gt;(static_cast&lt;B*&gt;(&amp;d));\n  A *a2 =  static_cast&lt;A*&gt;(static_cast&lt;C*&gt;(&amp;d));\n  a1-&gt;f();\n  a2-&gt;f();\n}\n</code></pre>\n", "LastEditorUserId": "365496", "LastActivityDate": "2013-10-31T18:27:05.573", "Score": "0", "CreationDate": "2013-10-31T17:55:18.267", "ParentId": "19712539", "CommentCount": "0", "LastEditDate": "2013-10-31T18:27:05.573", "OwnerUserId": "365496"}, "19712877": {"Id": "19712877", "PostTypeId": "2", "Body": "<p>It's because <code>C</code> inherits in a non-virtual way from <code>B</code> while <code>D</code> inherits in a virtual way from <code>B</code>. This gives you <code>B</code> two times including two <code>f()</code>. </p>\n<p>Try virtual inheritance of <code>B</code> in <code>C</code>.</p>\n<p>Update: So why does it work when you remove the virtual inheritance in <code>B</code> from <code>A</code>? Because it changes the \"final overrider\". Without virtual in <code>B</code> from <code>A</code> and in <code>C</code> from <code>B</code> you have <code>A</code> two times: once in <code>C</code> (with the final override of <code>f()</code> in <code>B</code>) and once in the virtual <code>B</code> in <code>D</code> (with the final override of <code>f()</code> in <code>B</code>). If you add back the virtual inheritance in <code>B</code> to <code>A</code>, <code>A</code> will be present only once and there will be two final overrides competing to implement the pure <code>f()</code> from <code>A</code>, both in <code>B</code>, once from <code>C</code> and once from the virtual <code>B</code>.</p>\n<p>As a workaround you could add a <code>using</code> to D, that is <code>using C::f;</code> or <code>using B::f</code>.</p>\n<p>See C++ 10.3/2 </p>\n", "LastEditorUserId": "168683", "LastActivityDate": "2013-10-31T18:49:58.793", "Score": "3", "CreationDate": "2013-10-31T17:19:46.640", "ParentId": "19712539", "CommentCount": "5", "LastEditDate": "2013-10-31T18:49:58.793", "OwnerUserId": "168683"}});