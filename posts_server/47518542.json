post_cb({"bq_ids": {"n4140": {"so_47518542_47518542_4": {"length": 4, "quality": 1.0, "section_id": 5768}, "so_47518542_47518542_5": {"length": 4, "quality": 1.0, "section_id": 5768}, "so_47518542_47518542_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 5962}, "so_47518542_47518542_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 5962}}, "n3337": {"so_47518542_47518542_4": {"length": 4, "quality": 1.0, "section_id": 5541}, "so_47518542_47518542_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 5731}, "so_47518542_47518542_5": {"length": 4, "quality": 1.0, "section_id": 5541}, "so_47518542_47518542_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 5731}}, "n4659": {"so_47518542_47518542_4": {"length": 4, "quality": 1.0, "section_id": 7225}, "so_47518542_47518542_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 8181}, "so_47518542_47518542_5": {"length": 4, "quality": 1.0, "section_id": 7225}, "so_47518542_47518542_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 8181}}}, "47518694": {"Id": "47518694", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47518542_47518694_0\">Does it mean that I can safely attempt to use this with non standard-layout classes?</p>\n</blockquote>\n<p>If the implementation permits it. Being conditionally supported means this must be documented.</p>\n<blockquote>\n<p id=\"so_47518542_47518694_1\">How is \"conditionally-supported\" different from implementation defined?</p>\n</blockquote>\n<p>To quote the standard on this:</p>\n<p><a href=\"http://eel.is/c++draft/intro.defs#defns.cond.supp\" rel=\"nofollow noreferrer\">[defns.cond.supp] conditionally-supported</a> - <em>\"program construct that an implementation is not required to support\"</em></p>\n<p><a href=\"http://eel.is/c++draft/intro.defs#defns.impl.defined\" rel=\"nofollow noreferrer\">[defns.impl.defined] implementation-defined behavior</a> - <em>\"behavior, for a well-formed program construct and correct data, that depends on the implementation and that each implementation documents\"</em></p>\n<p>The key difference is what choice the implementation has. Do it exactly as the standard says, or not at all. Vs. doing it in one of several ways without an option to refuse.</p>\n<blockquote>\n<p id=\"so_47518542_47518694_2\">Is a compiler not supporting <code>offsetof</code> for a particular type of class required to produce a diagnostic?</p>\n</blockquote>\n<p>If it's a conforming implementation, it will issue a diagnostic (<a href=\"http://eel.is/c++draft/intro.compliance#2.2\" rel=\"nofollow noreferrer\">[intro.compliance]/2.2</a> courtesy of @T.C.):</p>\n<p><em>\"If a program contains a violation of any diagnosable rule or an occurrence of a construct described in this document as \u201cconditionally-supported\u201d when the implementation does not support that construct, a conforming implementation shall issue at least one diagnostic message.\"</em></p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-11-28T05:37:15.533", "Score": "9", "CreationDate": "2017-11-27T19:46:53.643", "ParentId": "47518542", "CommentCount": "9", "OwnerUserId": "817643", "LastEditDate": "2017-11-28T05:37:15.533"}, "47518542": {"ViewCount": "218", "Body": "<p>The C++17 Standard says:</p>\n<blockquote>\n<p id=\"so_47518542_47518542_0\"><a href=\"http://eel.is/c++draft/support.types.layout#footnote-189\" rel=\"nofollow noreferrer\">[support.types.layout]</a></p>\n<blockquote>\n<p id=\"so_47518542_47518542_2\">Use of the <code>offsetof</code> macro with a type other than a <em>standard-layout</em> class is conditionally-supported.</p>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_47518542_47518542_3\"><a href=\"http://eel.is/c++draft/defns.cond.supp#:behavior,conditionally-supported\" rel=\"nofollow noreferrer\">[defns.cond.supp]</a></p>\n<blockquote>\n<h2>conditionally-supported</h2>\n<p id=\"so_47518542_47518542_5\">program construct that an implementation is not required to support</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>I find this definition of <code>offsetof</code> not very precise. </p>\n<ul>\n<li><p>Does it mean that I can safely attempt to use this with non standard-layout classes? </p></li>\n<li><p>How is \"conditionally-supported\" different from implementation defined?</p></li>\n<li><p>Is a compiler not supporting <code>offsetof</code> for a particular type of class required to produce a diagnostic?</p></li>\n</ul>\n</hr></hr>", "AcceptedAnswerId": "47518694", "Title": "What does it mean for `offsetof` to be \"conditionally-supported\" for non standard-layout classes in C++17?", "CreationDate": "2017-11-27T19:37:18.573", "Id": "47518542", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-11-27T19:50:52.123", "LastEditorUserId": "2069064", "LastActivityDate": "2017-11-28T05:37:15.533", "Score": "8", "OwnerUserId": "598696", "Tags": "<c++><language-lawyer><c++1z><offsetof>", "AnswerCount": "1"}});