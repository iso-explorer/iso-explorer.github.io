post_cb({"37194245": {"ViewCount": "716", "Body": "<p>Why is this <code>constexpr</code> <code>static</code> member function, identified by the <code>//! Nah</code> comment, not seen as <code>constexpr</code> when called?</p>\n<pre><code>struct Item_id\n{\n    enum Enum\n    {\n        size, position, attributes, window_rect, max_window_size, _\n    };\n\n    static constexpr int n_items_ = _;                          // OK\n    constexpr auto member_n_items() const -&gt; int { return _; }  // OK\n    static constexpr auto static_n_items() -&gt; int { return _; } // OK\n    static constexpr int so_far = n_items_;                     // OK\n    #ifndef OUT_OF_CLASS\n        static constexpr int bah = static_n_items();            //! Nah.\n    #endif\n};\n\nconstexpr auto n_ids() -&gt; int { return Item_id().member_n_items(); }    // OK\n\nauto main() -&gt; int\n{\n    #ifdef OUT_OF_CLASS\n        static constexpr int bah = Item_id::static_n_items();   // OK\n    #endif\n}\n</code></pre>\n<p>MinGW g++ 5.1 reports</p>\n<pre>\nconstexpr.cpp:12:46: error: 'static constexpr int Item_id::static_n_items()' called in a constant expression\n     static constexpr int bah = static_n_items();                //! Nah.\n</pre>\n<p>Visual C++ 2015 reports</p>\n<pre>\nconstexpr.cpp(12): error C2131: expression did not evaluate to a constant\nconstexpr.cpp(12): note: failure was caused by call of undefined function or one not declared 'constexpr'\nconstexpr.cpp(12): note: see usage of 'Item_id::static_n_items'\n</pre>\n<p>My text editor insists that the name in the call is the same as the name in the function definition.</p>\n<p>It appears to have something to do with incomplete class, because with <code>OUT_OF_CLASS</code> defined it compiles nicely.</p>\n<p>But then why does the <code>n_items_</code> data work, and, why such a rule (doesn't make sense to me)?</p>\n", "AcceptedAnswerId": "37194551", "Title": "Why is this constexpr static member function not seen as constexpr when called?", "CreationDate": "2016-05-12T17:56:32.220", "Id": "37194245", "CommentCount": "4", "LastEditDate": "2016-05-12T18:10:10.633", "PostTypeId": "1", "LastEditorUserId": "464581", "LastActivityDate": "2016-05-12T19:05:11.480", "Score": "14", "OwnerUserId": "464581", "Tags": "<c++><constexpr>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37194245_37194749_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 5862}}, "n3337": {"so_37194245_37194749_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 5632}}, "n4659": {"so_37194245_37194749_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7345}}}, "37194551": {"Id": "37194551", "PostTypeId": "2", "Body": "<p>From memory, member function bodies are evaluated only once the class has been completely defined.</p>\n<pre><code>static constexpr int bah = static_n_items(); \n</code></pre>\n<p>forms part of the class definition, but it's referring to a (static) member function, which cannot yet be defined.</p>\n<p>Solution: </p>\n<p>defer constant expressions to a base class and derive from it.</p>\n<p>e.g.:</p>\n<pre><code>struct Item_id_base\n{\n    enum Enum\n    {\n        size, position, attributes, window_rect, max_window_size, _\n    };\n\n    static constexpr int n_items_ = _;                          // OK\n    constexpr auto member_n_items() const -&gt; int { return _; }  // OK\n    static constexpr auto static_n_items() -&gt; int { return _; } // OK\n    static constexpr int so_far = n_items_;                     // OK\n};\n\nstruct Item_id : Item_id_base\n{\n    #ifndef OUT_OF_CLASS\n        static constexpr int bah = static_n_items();            // now OK\n    #endif\n};\n\nconstexpr auto n_ids() -&gt; int { return Item_id().member_n_items(); }    // OK\n\nauto main() -&gt; int\n{\n    #ifdef OUT_OF_CLASS\n        static constexpr int bah = Item_id::static_n_items();   // OK\n    #endif\n}\n</code></pre>\n<blockquote>\n<p id=\"so_37194245_37194551_0\">Why do you think the standard disallows it?</p>\n</blockquote>\n<p>Because this is illegal:</p>\n<pre><code>struct Item_id\n{   \n    // ... etc.\n\n    #ifndef OUT_OF_CLASS\n        static constexpr int bah;// = static_n_items();            //! Nah.\n    #endif\n};\n\nconstexpr int Item_id::bah = static_n_items();\n</code></pre>\n<p>And a constexpr must have a constexpr definition. The only place we can define it is during its declaration...</p>\n<p>... so by deduction it cannot refer to any function who's body is not yet defined.</p>\n<p>I am at a loss to know where to look in the standard for all that. Probably 5 different, seemingly unrelated clauses :)</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-05-12T18:33:31.690", "Score": "11", "CreationDate": "2016-05-12T18:14:12.493", "ParentId": "37194245", "CommentCount": "3", "OwnerUserId": "2015579", "LastEditDate": "2016-05-12T18:33:31.690"}, "37194749": {"Id": "37194749", "PostTypeId": "2", "Body": "<p>[class.mem]/2</p>\n<blockquote>\n<p id=\"so_37194245_37194749_0\">Within the class <em>member-specification</em>, the class is regarded as complete within function bodies, default arguments, <em>exception-specifications</em>, and default member initializers (including such things in nested classes). Otherwise it is regarded as incomplete within its own class <em>member-specification</em>.</p>\n</blockquote>\n<p>In the initializer of a <code>static</code> data member of a class, the class is incomplete. The initializer can only see the declarations of members which precede it, and any member functions it can see are considered declared but not defined. A call to a function that is declared but not defined can not be a constant expression.</p>\n", "LastEditorUserId": "1639256", "LastActivityDate": "2016-05-12T19:05:11.480", "Score": "3", "CreationDate": "2016-05-12T18:26:19.127", "ParentId": "37194245", "CommentCount": "2", "OwnerUserId": "1639256", "LastEditDate": "2016-05-12T19:05:11.480"}});