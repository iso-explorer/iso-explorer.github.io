post_cb({"7189821": {"ParentId": "4178175", "PostTypeId": "2", "CommentCount": "6", "Body": "<h1>What changes for C++11?</h1>\n<h2>Aggregates</h2>\n<p>The standard definition of an aggregate has changed slightly, but it's still pretty much the same:</p>\n<blockquote>\n<p id=\"so_4178175_7189821_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1),\n  no <em>brace-or-equal-initializers</em> for non-static data members (9.2), no private or protected\n  non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Ok, what changed?</p>\n<ol>\n<li><p>Previously, an aggregate could have no <em>user-declared</em> constructors, but now it can't have <em>user-provided</em> constructors. Is there a difference? Yes, there is, because now you can declare constructors and <em>default</em> them:</p>\n<pre><code>struct Aggregate {\n    Aggregate() = default; // asks the compiler to generate the default implementation\n};\n</code></pre>\n<p>This is still an aggregate because a constructor (or any special member function) <em>that is defaulted on the first declaration</em> is not user-provided.</p></li>\n<li><p>Now an aggregate cannot have any <em>brace-or-equal-initializers</em> for non-static data members. What does this mean? Well, this is just because with this new standard, we can initialize members directly in the class like this:</p>\n<pre><code>struct NotAggregate {\n    int x = 5; // valid in C++11\n    std::vector&lt;int&gt; s{1,2,3}; // also valid\n};\n</code></pre>\n<p>Using this feature makes the class no longer an aggregate because it's basically equivalent to providing your own default constructor.</p></li>\n</ol>\n<p>So, what is an aggregate didn't change much at all. It's still the same basic idea, adapted to the new features.</p>\n<h2>What about PODs?</h2>\n<p>PODs went through a lot of changes. Lots of previous rules about PODs were relaxed in this new standard, and the way the definition is provided in the standard was radically changed.</p>\n<p>The idea of a POD is to capture basically two distinct properties:</p>\n<ol>\n<li>It supports static initialization, and</li>\n<li>Compiling a POD in C++ gives you the same memory layout as a struct compiled in C.</li>\n</ol>\n<p>Because of this, the definition has been split into two distinct concepts: <em>trivial</em> classes and <em>standard-layout</em> classes, because these are more useful than POD. The standard now rarely uses the term POD, preferring the more specific <em>trivial</em> and <em>standard-layout</em> concepts.</p>\n<p>The new definition basically says that a POD is a class that is both trivial and has standard-layout, and this property must hold recursively for all non-static data members:</p>\n<blockquote>\n<p id=\"so_4178175_7189821_1\">A POD struct is a non-union class that is both a trivial class and a standard-layout class,\n  and has no non-static data members of type non-POD struct, non-POD union (or array of such types).\n  Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has\n  no non-static data members of type non-POD struct, non-POD union (or array of such types).\n  A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>Let's go over each of these two properties in detail separately.</p>\n<h2>Trivial classes</h2>\n<p><em>Trivial</em> is the first property mentioned above: trivial classes support static initialization. \nIf a class is trivially copyable (a superset of trivial classes), it is ok to copy its representation over the place with things like <code>memcpy</code> and expect the result to be the same.</p>\n<p>The standard defines a trivial class as follows:</p>\n<blockquote>\n<p id=\"so_4178175_7189821_2\">A trivially copyable class is a class that:</p>\n<p id=\"so_4178175_7189821_3\">\u2014 has no non-trivial copy constructors (12.8),</p>\n<p id=\"so_4178175_7189821_4\">\u2014 has no non-trivial move constructors (12.8),</p>\n<p id=\"so_4178175_7189821_5\">\u2014 has no non-trivial copy assignment operators (13.5.3, 12.8),</p>\n<p id=\"so_4178175_7189821_6\">\u2014 has no non-trivial move assignment operators (13.5.3, 12.8), and</p>\n<p id=\"so_4178175_7189821_7\">\u2014 has a trivial destructor (12.4).</p>\n<p id=\"so_4178175_7189821_8\">A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n<p id=\"so_4178175_7189821_9\">[ <em>Note:</em> In particular, a trivially copyable or trivial class does not have virtual functions\n  or virtual base classes.<em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So, what are all those trivial and non-trivial things?</p>\n<blockquote>\n<p id=\"so_4178175_7189821_10\">A copy/move constructor for class X is trivial if it is not user-provided and if</p>\n<p id=\"so_4178175_7189821_11\">\u2014 class X has no virtual functions (10.3) and no virtual base classes (10.1), and</p>\n<p id=\"so_4178175_7189821_12\">\u2014 the constructor selected to copy/move each direct base class subobject is trivial, and</p>\n<p id=\"so_4178175_7189821_13\">\u2014 for each non-static data member of X that is of class type (or array thereof), the constructor\n  selected to copy/move that member is trivial;</p>\n<p id=\"so_4178175_7189821_14\">otherwise the copy/move constructor is non-trivial.</p>\n</blockquote>\n<p>Basically this means that a copy or move constructor is trivial if it is not user-provided, the class has nothing virtual in it, and this property holds recursively for all the members of the class and for the base class.</p>\n<p>The definition of a trivial copy/move assignment operator is very similar, simply replacing the word \"constructor\" with \"assignment operator\".</p>\n<p>A trivial destructor also has a similar definition, with the added constraint that it can't be virtual.</p>\n<p>And yet another similar rule exists for trivial default constructors, with the addition that a default constructor is not-trivial if the class has non-static data members with <em>brace-or-equal-initializers</em>, which we've seen above.</p>\n<p>Here are some examples to clear everything up:</p>\n<pre><code>// empty classes are trivial\nstruct Trivial1 {};\n\n// all special members are implicit\nstruct Trivial2 {\n    int x;\n};\n\nstruct Trivial3 : Trivial2 { // base class is trivial\n    Trivial3() = default; // not a user-provided ctor\n    int y;\n};\n\nstruct Trivial4 {\npublic:\n    int a;\nprivate: // no restrictions on access modifiers\n    int b;\n};\n\nstruct Trivial5 {\n    Trivial1 a;\n    Trivial2 b;\n    Trivial3 c;\n    Trivial4 d;\n};\n\nstruct Trivial6 {\n    Trivial2 a[23];\n};\n\nstruct Trivial7 {\n    Trivial6 c;\n    void f(); // it's okay to have non-virtual functions\n};\n\nstruct Trivial8 {\n     int x;\n     static NonTrivial1 y; // no restrictions on static members\n};\n\nstruct Trivial9 {\n     Trivial9() = default; // not user-provided\n      // a regular constructor is okay because we still have default ctor\n     Trivial9(int x) : x(x) {};\n     int x;\n};\n\nstruct NonTrivial1 : Trivial3 {\n    virtual void f(); // virtual members make non-trivial ctors\n};\n\nstruct NonTrivial2 {\n    NonTrivial2() : z(42) {} // user-provided ctor\n    int z;\n};\n\nstruct NonTrivial3 {\n    NonTrivial3(); // user-provided ctor\n    int w;\n};\nNonTrivial3::NonTrivial3() = default; // defaulted but not on first declaration\n                                      // still counts as user-provided\nstruct NonTrivial5 {\n    virtual ~NonTrivial5(); // virtual destructors are not trivial\n};\n</code></pre>\n<h2>Standard-layout</h2>\n<p><em>Standard-layout</em> is the second property. The standard mentions that these are useful for communicating with other languages, and that's because a standard-layout class has the same memory layout of the equivalent C struct or union.</p>\n<p>This is another property that must hold recursively for members and all base classes. And as usual, no virtual functions or virtual base classes are allowed. That would make the layout incompatible with C.</p>\n<p>A relaxed rule here is that standard-layout classes must have all non-static data members with the same access control. Previously these had to be all <em>public</em>, but now you can make them private or protected, as long as they are <em>all</em> private or <em>all</em> protected.</p>\n<p>When using inheritance, <em>only one</em> class in the whole inheritance tree can have non-static data members, and the first non-static data member cannot be of a base class type (this could break aliasing rules), otherwise, it's not a standard-layout class.</p>\n<p>This is how the definition goes in the standard text:</p>\n<blockquote>\n<p id=\"so_4178175_7189821_15\">A standard-layout class is a class that:</p>\n<p id=\"so_4178175_7189821_16\">\u2014 has no non-static data members of type non-standard-layout class (or array of such types)\n  or reference,</p>\n<p id=\"so_4178175_7189821_17\">\u2014 has no virtual functions (10.3) and no virtual base classes (10.1),</p>\n<p id=\"so_4178175_7189821_18\">\u2014 has the same access control (Clause 11) for all non-static data members,</p>\n<p id=\"so_4178175_7189821_19\">\u2014 has no non-standard-layout base classes,</p>\n<p id=\"so_4178175_7189821_20\">\u2014 either has no non-static data members in the most derived class and at most one base class with\n  non-static data members, or has no base classes with non-static data members, and</p>\n<p id=\"so_4178175_7189821_21\">\u2014 has no base classes of the same type as the first non-static data member.</p>\n<p id=\"so_4178175_7189821_22\">A standard-layout struct is a standard-layout class defined with the class-key struct or\n  the class-key class.</p>\n<p id=\"so_4178175_7189821_23\">A standard-layout union is a standard-layout class defined with the class-key union.</p>\n<p id=\"so_4178175_7189821_24\">[ <em>Note:</em> Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.<em>\u2014end note</em> ]</p>\n</blockquote>\n<p>And let's see a few examples.</p>\n<pre><code>// empty classes have standard-layout\nstruct StandardLayout1 {};\n\nstruct StandardLayout2 {\n    int x;\n};\n\nstruct StandardLayout3 {\nprivate: // both are private, so it's ok\n    int x;\n    int y;\n};\n\nstruct StandardLayout4 : StandardLayout1 {\n    int x;\n    int y;\n\n    void f(); // perfectly fine to have non-virtual functions\n};\n\nstruct StandardLayout5 : StandardLayout1 {\n    int x;\n    StandardLayout1 y; // can have members of base type if they're not the first\n};\n\nstruct StandardLayout6 : StandardLayout1, StandardLayout5 {\n    // can use multiple inheritance as long only\n    // one class in the hierarchy has non-static data members\n};\n\nstruct StandardLayout7 {\n    int x;\n    int y;\n    StandardLayout7(int x, int y) : x(x), y(y) {} // user-provided ctors are ok\n};\n\nstruct StandardLayout8 {\npublic:\n    StandardLayout8(int x) : x(x) {} // user-provided ctors are ok\n// ok to have non-static data members and other members with different access\nprivate:\n    int x;\n};\n\nstruct StandardLayout9 {\n    int x;\n    static NonStandardLayout1 y; // no restrictions on static members\n};\n\nstruct NonStandardLayout1 {\n    virtual f(); // cannot have virtual functions\n};\n\nstruct NonStandardLayout2 {\n    NonStandardLayout1 X; // has non-standard-layout member\n};\n\nstruct NonStandardLayout3 : StandardLayout1 {\n    StandardLayout1 x; // first member cannot be of the same type as base\n};\n\nstruct NonStandardLayout4 : StandardLayout3 {\n    int z; // more than one class has non-static data members\n};\n\nstruct NonStandardLayout5 : NonStandardLayout3 {}; // has a non-standard-layout base class\n</code></pre>\n<h2>Conclusion</h2>\n<p>With these new rules a lot more types can be PODs now. And even if a type is not POD, we can take advantage of some of the POD properties separately (if it is only one of trivial or standard-layout).</p>\n<p>The standard library has traits to test these properties in the header <code>&lt;type_traits&gt;</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct std::is_pod;\ntemplate &lt;typename T&gt;\nstruct std::is_trivial;\ntemplate &lt;typename T&gt;\nstruct std::is_trivially_copyable;\ntemplate &lt;typename T&gt;\nstruct std::is_standard_layout;\n</code></pre>\n", "OwnerUserId": "46642", "LastEditorUserId": "3325279", "LastEditDate": "2016-07-19T07:53:48.860", "Id": "7189821", "Score": "349", "CreationDate": "2011-08-25T11:48:47.087", "LastActivityDate": "2016-07-19T07:53:48.860"}, "9491406": {"ParentId": "4178175", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_4178175_9491406_0\">can you please elaborate following rules: </p>\n</blockquote>\n<p>I'll try:</p>\n<blockquote>\n<p id=\"so_4178175_9491406_1\">a) standard-layout classes must have all non-static data members with the same access control</p>\n</blockquote>\n<p>That's simple: all non-static data members must <em>all</em> be <code>public</code>, <code>private</code>, or <code>protected</code>. You can't have some <code>public</code> and some <code>private</code>.</p>\n<p>The reasoning for them goes to the reasoning for having a distinction between \"standard layout\" and \"not standard layout\" at all. Namely, to give the compiler the freedom to choose how to put things into memory. It's not just about vtable pointers.</p>\n<p>Back when they standardized C++ in 98, they had to basically predict how people would implement it. While they had quite a bit of implementation experience with various flavors of C++, they weren't certain about things. So they decided to be cautious: give the compilers as much freedom as possible.</p>\n<p>That's why the definition of POD in C++98 is so strict. It gave C++ compilers great latitude on member layout for most classes. Basically, POD types were intended to be special cases, something you specifically wrote for a reason.</p>\n<p>When C++11 was being worked on, they had a lot more experience with compilers. And they realized that... C++ compiler writers are really lazy. They had all this freedom, but they didn't <em>do</em> anything with it.</p>\n<p>The rules of standard layout are more or less codifying common practice: most compilers didn't really have to change much if anything at all to implement them (outside of maybe some stuff for the corresponding type traits).</p>\n<p>Now, when it came to <code>public</code>/<code>private</code>, things are different. The freedom to reorder which members are <code>public</code> vs. <code>private</code> actually can matter to the compiler, particularly in debugging builds. And since the point of standard layout is that there is compatibility with other languages, you can't have the layout be different in debug vs. release.</p>\n<p>Then there's the fact that it doesn't really hurt the user. If you're making an encapsulated class, odds are good that all of your data members will be <code>private</code> anyway. You generally don't expose public data members on fully encapsulated types. So this would only be a problem for those few users who do want to do that, who want that division.</p>\n<p>So it's no big loss.</p>\n<blockquote>\n<p id=\"so_4178175_9491406_2\">b) only one class in the whole inheritance tree can have non-static data members,</p>\n</blockquote>\n<p>The reason for this one comes back to why they standardized standard layout again: common practice.</p>\n<p>There's <em>no</em> common practice when it comes to having two members of an inheritance tree that actually store things. Some put the base class before the derived, others do it the other way. Which way do you order the members if they come from two base classes? And so on. Compilers diverge greatly on these questions.</p>\n<p>Also, thanks to the zero/one/infinity rule, once you say you can have two classes with members, you can say as many as you want. This requires adding a lot of layout rules for how to handle this. You have to say how multiple inheritance works, which classes put their data before other classes, etc. That's a lot of rules, for very little material gain.</p>\n<p>You can't make everything that doesn't have virtual functions and a default constructor standard layout.</p>\n<blockquote>\n<p id=\"so_4178175_9491406_3\">and the first non-static data member cannot be of a base class type (this could break aliasing rules).</p>\n</blockquote>\n<p>I can't really speak to this one. I'm not educated enough in C++'s aliasing rules to really understand it. But it has something to do with the fact that the base member will share the same address as the base class itself. That is:</p>\n<pre><code>struct Base {};\nstruct Derived : Base { Base b; };\n\nDerived d;\nstatic_cast&lt;Base*&gt;(&amp;d) == &amp;d.b;\n</code></pre>\n<p>And that's probably against C++'s aliasing rules. In some way.</p>\n<p>However, consider this: how useful could having the ability to do this ever <em>actually</em> be? Since only one class can have non-static data members, then <code>Derived</code> must be that class (since it has a <code>Base</code> as a member). So <code>Base</code> <em>must</em> be empty (of data). And if <code>Base</code> is empty, <em>as well as</em> a base class... why have a data member of it at all?</p>\n<p>Since <code>Base</code> is empty, it has no state. So any non-static member functions will do what they do based on their parameters, not their <code>this</code> pointer.</p>\n<p>So again: no big loss.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-03-16T02:43:10.320", "Id": "9491406", "Score": "33", "CreationDate": "2012-02-28T23:26:31.440", "LastActivityDate": "2012-03-16T02:43:10.320"}, "4178176": {"CommentCount": "23", "CreationDate": "2010-11-14T15:36:17.293", "CommunityOwnedDate": "2012-07-27T22:01:18.543", "LastEditorUserId": "2326961", "LastActivityDate": "2015-08-16T16:18:24.897", "ParentId": "4178175", "PostTypeId": "2", "LastEditDate": "2015-08-16T16:18:24.897", "Id": "4178176", "Score": "425", "Body": "<h1>How to read:</h1>\n<p>This article is rather long. If you want to know about both aggregates and PODs (Plain Old Data) take time and read it. If you are interested just in aggregates, read only the first part. If you are interested only in PODs then you must first read the definition, implications, and examples of aggregates and then you <em>may</em> jump to PODs but I would still recommend reading the first part in its entirety. The notion of aggregates is essential for defining PODs. If you find any errors (even minor, including grammar, stylistics, formatting, syntax, etc.) please leave a comment, I'll edit.</p>\n<h1>What are aggregates and why they are special </h1>\n<p><strong>Formal definition from the C++ standard (<em>C++03 8.5.1 \u00a71</em>)</strong>:</p>\n<blockquote>\n<p id=\"so_4178175_4178176_0\">An aggregate is an array or a class (clause 9) with no user-declared \n  constructors (12.1), no private or protected non-static data members (clause 11),\n  no base classes (clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>So, OK, let's parse this definition. First of all, any array is an aggregate. A class can also be an aggregate if\u2026 wait! nothing is said about structs or unions, can't they be aggregates? Yes, they can. In C++, the term <code>class</code> refers to all classes, structs, and unions. So, a class (or struct, or union) is an aggregate if and only if it satisfies the criteria from the above definitions. What do these criteria imply?</p>\n<ul>\n<li><p>This does not mean an aggregate class cannot have constructors, in fact it can have a default constructor and/or a copy constructor as long as they are implicitly declared by the compiler, and not explicitly by the user</p></li>\n<li><p>No private or protected <strong><em>non-static data members</em></strong>. You can have as many private and protected member functions (but not constructors) as well as as many private or protected <strong><em>static</em></strong> data members and member functions as you like and not violate the rules for aggregate classes</p></li>\n<li><p>An aggregate class can have a user-declared/user-defined copy-assignment operator and/or destructor</p></li>\n<li><p>An array is an aggregate even if it is an array of non-aggregate class type. </p></li>\n</ul>\n<p>Now let's look at some examples:</p>\n<pre><code>class NotAggregate1\n{\n  virtual void f() {} //remember? no virtual functions\n};\n\nclass NotAggregate2\n{\n  int x; //x is private by default and non-static \n};\n\nclass NotAggregate3\n{\npublic:\n  NotAggregate3(int) {} //oops, user-defined constructor\n};\n\nclass Aggregate1\n{\npublic:\n  NotAggregate1 member1;   //ok, public member\n  Aggregate1&amp; operator=(Aggregate1 const &amp; rhs) {/* */} //ok, copy-assignment  \nprivate:\n  void f() {} // ok, just a private function\n};\n</code></pre>\n<p>You get the idea. Now let's see how aggregates are special. They, unlike non-aggregate classes, can be initialized with curly braces <code>{}</code>. This initialization syntax is commonly known for arrays, and we just learnt that these are aggregates. So, let's start with them.</p>\n<p><code>Type array_name[n] = {a<sub>1</sub>, a<sub>2</sub>, \u2026, a<sub>m</sub>};</code></p>\n<p><strong><em>if(m == n)</em></strong><br>\n   the i<sup>th</sup> element of the array is initialized with a<sub>i</sub><br>\n<strong><em>else if(m &lt; n)</em></strong><br>\n  the first m elements of the array are initialized with a<sub>1</sub>, a<sub>2</sub>, \u2026, a<sub>m</sub> and the other <code>n - m</code> elements are, if possible, <em>value-initialized</em> (see below for the explanation of the term)<br>\n<strong><em>else if(m &gt; n)</em></strong><br>\n   the compiler will issue an error<br>\n<strong><em>else</em></strong> <em>(this is the case when n isn't specified at all like <code>int a[] = {1, 2, 3};</code>)</em><br>\n the size of the array (n) is assumed to be equal to m, so <code>int a[] = {1, 2, 3};</code> is equivalent to <code>int a[3] = {1, 2, 3};</code></br></br></br></br></br></br></br></p>\n<p>When an object of scalar type (<code>bool</code>, <code>int</code>, <code>char</code>, <code>double</code>, pointers, etc.) is <em>value-initialized</em> it means it is initialized with <code>0</code> for that type (<code>false</code> for <code>bool</code>, <code>0.0</code> for <code>double</code>, etc.). When an object of class type with a user-declared default constructor is value-initialized its default constructor is called. If the default constructor is implicitly defined then all nonstatic members are recursively value-initialized. This definition is imprecise and a bit incorrect but it should give you the basic idea. A reference cannot be value-initialized. Value-initialization for a non-aggregate class can fail if, for example, the class has no appropriate default constructor.</p>\n<p>Examples of array initialization:</p>\n<pre><code>class A\n{\npublic:\n  A(int) {} //no default constructor\n};\nclass B\n{\npublic:\n  B() {} //default constructor available\n};\nint main()\n{\n  A a1[3] = {A(2), A(1), A(14)}; //OK n == m\n  A a2[3] = {A(2)}; //ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]\n  B b1[3] = {B()}; //OK b1[1] and b1[2] are value initialized, in this case with the default-ctor\n  int Array1[1000] = {0}; //All elements are initialized with 0;\n  int Array2[1000] = {1}; //Attention: only the first element is 1, the rest are 0;\n  bool Array3[1000] = {}; //the braces can be empty too. All elements initialized with false\n  int Array4[1000]; //no initializer. This is different from an empty {} initializer in that\n  //the elements in this case are not value-initialized, but have indeterminate values \n  //(unless, of course, Array4 is a global array)\n  int array[2] = {1, 2, 3, 4}; //ERROR, too many initializers\n}\n</code></pre>\n<p>Now let's see how aggregate classes can be initialized with braces. Pretty much the same way. Instead of the array elements we will initialize the non-static data members in the order of their appearance in the class definition (they are all public by definition). If there are fewer initializers than members, the rest are value-initialized. If it is impossible to value-initialize one of the members which were not explicitly initialized, we get a compile-time error. If there are more initializers than necessary, we get a compile-time error as well.</p>\n<pre><code>struct X\n{\n  int i1;\n  int i2;\n};\nstruct Y\n{\n  char c;\n  X x;\n  int i[2];\n  float f; \nprotected:\n  static double d;\nprivate:\n  void g(){}      \n}; \n\nY y = {'a', {10, 20}, {20, 30}};\n</code></pre>\n<p>In the above example <code>y.c</code> is initialized with <code>'a'</code>, <code>y.x.i1</code> with <code>10</code>, <code>y.x.i2</code> with <code>20</code>, <code>y.i[0]</code> with <code>20</code>, <code>y.i[1]</code> with <code>30</code> and <code>y.f</code> is value-initialized, that is, initialized with <code>0.0</code>. The protected static member <code>d</code> is not initialized at all, because it is <code>static</code>.</p>\n<p>Aggregate unions are different in that you may initialize only their first member with braces. I think that if you are advanced enough in C++ to even consider using unions (their use may be very dangerous and must be thought of carefully), you could look up the rules for unions in the standard yourself :). </p>\n<p>Now that we know what's special about aggregates, let's try to understand the restrictions on classes; that is, why they are there. We should understand that memberwise initialization with braces implies that the class is nothing more than the sum of its members. If a user-defined constructor is present, it means that the user needs to do some extra work to initialize the members therefore brace initialization would be incorrect. If virtual functions are present, it means that the objects of this class have (on most implementations) a pointer to the so-called vtable of the class, which is set in the constructor, so brace-initialization would be insufficient. You could figure out the rest of the restrictions in a similar manner as an exercise :).</p>\n<p>So enough about the aggregates. Now we can define a stricter set of types, to wit, PODs</p>\n<h1>What are PODs and why they are special</h1>\n<p><strong>Formal definition from the C++ standard (<em>C++03 9 \u00a74</em>)</strong>:</p>\n<blockquote>\n<p id=\"so_4178175_4178176_1\">A POD-struct is an aggregate class\n  that has no non-static data members of\n  type non-POD-struct, non-POD-union (or\n  array of such types) or reference, and\n  has no user-defined copy assignment\n  operator and no user-defined\n  destructor. Similarly, a POD-union is\n  an aggregate union that has no\n  non-static data members of type\n  non-POD-struct, non-POD-union (or\n  array of such types) or reference, and\n  has no user-defined copy assignment\n  operator and no user-defined\n  destructor. A POD class is a class\n  that is either a POD-struct or a\n  POD-union.</p>\n</blockquote>\n<p>Wow, this one's tougher to parse, isn't it? :) Let's leave unions out (on the same grounds as above) and rephrase in a bit clearer way:</p>\n<blockquote>\n<p id=\"so_4178175_4178176_2\">An aggregate class is called a POD if\n  it has no user-defined copy-assignment\n  operator and destructor and none of\n  its nonstatic members is a non-POD\n  class, array of non-POD, or a\n  reference.</p>\n</blockquote>\n<p>What does this definition imply? (Did I mention <strong>POD</strong> stands for <strong><em>Plain Old Data</em></strong>?)</p>\n<ul>\n<li>All POD classes are aggregates, or, to put it the other way around, if a class is not an aggregate then it is sure not a POD</li>\n<li>Classes, just like structs, can be PODs even though the standard term is POD-struct for both cases</li>\n<li>Just like in the case of aggregates, it doesn't matter what static members the class has</li>\n</ul>\n<p>Examples:</p>\n<pre><code>struct POD\n{\n  int x;\n  char y;\n  void f() {} //no harm if there's a function\n  static std::vector&lt;char&gt; v; //static members do not matter\n};\n\nstruct AggregateButNotPOD1\n{\n  int x;\n  ~AggregateButNotPOD1() {} //user-defined destructor\n};\n\nstruct AggregateButNotPOD2\n{\n  AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class\n};\n</code></pre>\n<p>POD-classes, POD-unions, scalar types, and arrays of such types are collectively called <strong><em>POD-types.</em></strong><br>\nPODs are special in many ways. I'll provide just some examples.</br></p>\n<ul>\n<li><p>POD-classes are the closest to C structs. Unlike them, PODs can have member functions and arbitrary static members, but neither of these two change the memory layout of the object. So if you want to write a more or less portable dynamic library that can be used from C and even .NET, you should try to make all your exported functions take and return only parameters of POD-types.</p></li>\n<li><p>The lifetime of objects of non-POD class type begins when the constructor has finished and ends when the destructor has finished. For POD classes, the lifetime begins when storage for the object is occupied and finishes when that storage is released or reused.  </p></li>\n<li><p>For objects of POD types it is guaranteed by the standard that when you <code>memcpy</code> the contents of your object into an array of char or unsigned char, and then <code>memcpy</code> the contents back into your object, the object will hold its original value. Do note that there is no such guarantee for objects of non-POD types. Also, you can safely copy POD objects with <code>memcpy</code>. The following example assumes T is a POD-type:</p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj; // obj initialized to its original value\nmemcpy(buf, &amp;obj, N); // between these two calls to memcpy,\n// obj might be modified\nmemcpy(&amp;obj, buf, N); // at this point, each subobject of obj of scalar type\n// holds its original value\n</code></pre></li>\n<li><p>goto statement. As you may know, it is illegal (the compiler should issue an error) to make a jump via goto from a point where some variable was not yet in scope to a point where it is already in scope. This restriction applies only if the variable is of non-POD type. In the following example <code>f()</code> is ill-formed whereas <code>g()</code> is well-formed. Note that Microsoft's compiler is too liberal with this rule\u2014it just issues a warning in both cases.</p>\n<pre><code>int f()\n{\n  struct NonPOD {NonPOD() {}};\n  goto label;\n  NonPOD x;\nlabel:\n  return 0;\n}\n\nint g()\n{\n  struct POD {int i; char c;};\n  goto label;\n  POD x;\nlabel:\n  return 0;\n}\n</code></pre></li>\n<li><p>It is guaranteed that there will be no padding in the beginning of a POD object. In other words, if a POD-class A's first member is of type T, you can safely <code>reinterpret_cast</code> from <code>A*</code> to <code>T*</code> and get the pointer to the first member and vice versa.</p></li>\n</ul>\n<p>The list goes on and on\u2026</p>\n<h1>Conclusion</h1>\n<p>It is important to understand what exactly a POD is because many language features, as you see, behave differently for them.</p>\n", "OwnerUserId": "469935"}, "4178175": {"CommentCount": "0", "ViewCount": "97765", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-11-14T15:35:50.007", "LastActivityDate": "2016-07-19T07:53:48.860", "Title": "What are Aggregates and PODs and how/why are they special?", "FavoriteCount": "447", "LastEditDate": "2017-05-23T12:26:36.443", "Id": "4178175", "Score": "407", "Body": "<p>This <a href=\"https://stackoverflow.com/tags/c%2b%2b-faq/info\">FAQ</a> is about Aggregates and PODs and covers the following material:</p>\n<ul>\n<li>What are <strong><em>Aggregates</em></strong>? </li>\n<li>What are <strong><em>POD</em></strong>s (Plain Old Data)? </li>\n<li>How are they related? </li>\n<li>How and why are they special? </li>\n<li>What changes for C++11?</li>\n</ul>\n", "Tags": "<c++><aggregate><c++-faq><pod><c++11>", "OwnerUserId": "469935", "AnswerCount": "4"}, "27511360": {"ParentId": "4178175", "PostTypeId": "2", "CommentCount": "1", "Body": "<h1>What has changed for C++14</h1>\n<p>We can refer to the <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf\" rel=\"noreferrer\">Draft C++14 standard</a> for reference. </p>\n<h2>Aggregates</h2>\n<p>This is covered in section <code>8.5.1</code> <em>Aggregates</em> which gives us the following definition:</p>\n<blockquote>\n<p id=\"so_4178175_27511360_0\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>The only change is now adding <em>in-class member initializers</em> does not make a class a non-aggregate. So the following example from <a href=\"https://stackoverflow.com/q/27118535/1708801\">C++11 aggregate initialization for classes with member in-pace initializers</a>:</p>\n<pre><code>struct A\n{\n  int a = 3;\n  int b = 3;\n};\n</code></pre>\n<p>was not an aggregate in C++11 but it is in C++14. This change is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html\" rel=\"noreferrer\">N3605: Member initializers and aggregates</a>, which has the following abstract:</p>\n<blockquote>\n<p id=\"so_4178175_27511360_1\">Bjarne Stroustrup and Richard Smith raised an issue about aggregate\n  initialization and member-initializers not working together. This\n  paper proposes to fix the issue by adopting Smith's proposed wording\n  that removes a restriction that aggregates can't have\n  member-initializers.</p>\n</blockquote>\n<h1>POD stays the same</h1>\n<p>The definition for POD(<em>plain old data</em>) struct is covered in section <code>9</code> <em>Classes</em> which says:</p>\n<blockquote>\n<p id=\"so_4178175_27511360_2\">A POD struct<sup>110</sup> is a non-union class that is both a trivial class and\n  a standard-layout class, and has no non-static data members of type\n  non-POD struct, non-POD union (or array of such types). Similarly, a\n  POD union is a union that is both a trivial class and a\n  standard-layout class, and has no non-static data members of type\n  non-POD struct, non-POD union (or array of such types). A POD class is\n  a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>which is the same wording as C++11.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:02.523", "Id": "27511360", "Score": "67", "CreationDate": "2014-12-16T18:21:24.763", "LastActivityDate": "2014-12-20T02:35:08.470"}, "bq_ids": {"n4140": {"so_4178175_7189821_1": {"section_id": 5854, "quality": 0.9166666666666666, "length": 44}, "so_4178175_7189821_6": {"section_id": 5850, "quality": 0.6666666666666666, "length": 4}, "so_4178175_7189821_13": {"section_id": 461, "quality": 1.0, "length": 13}, "so_4178175_7189821_11": {"section_id": 369, "quality": 0.75, "length": 6}, "so_4178175_7189821_14": {"section_id": 461, "quality": 1.0, "length": 4}, "so_4178175_9491406_1": {"section_id": 5851, "quality": 0.6363636363636364, "length": 7}, "so_4178175_7189821_0": {"section_id": 3298, "quality": 0.6956521739130435, "length": 16}, "so_4178175_7189821_17": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_4178175_9491406_2": {"section_id": 467, "quality": 0.6, "length": 6}, "so_4178175_7189821_24": {"section_id": 5853, "quality": 0.8, "length": 12}, "so_4178175_7189821_8": {"section_id": 5850, "quality": 0.7777777777777778, "length": 7}, "so_4178175_7189821_10": {"section_id": 461, "quality": 1.0, "length": 5}, "so_4178175_7189821_2": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_4178175_7189821_12": {"section_id": 461, "quality": 1.0, "length": 9}, "so_4178175_27511360_0": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}, "so_4178175_7189821_20": {"section_id": 5851, "quality": 1.0, "length": 19}, "so_4178175_4178176_0": {"section_id": 3298, "quality": 0.631578947368421, "length": 12}, "so_4178175_7189821_5": {"section_id": 5850, "quality": 0.6666666666666666, "length": 4}, "so_4178175_7189821_23": {"section_id": 5852, "quality": 1.0, "length": 7}, "so_4178175_7189821_22": {"section_id": 5852, "quality": 1.0, "length": 9}, "so_4178175_7189821_21": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_4178175_7189821_18": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_4178175_7189821_9": {"section_id": 5850, "quality": 0.7857142857142857, "length": 11}, "so_4178175_7189821_16": {"section_id": 5851, "quality": 1.0, "length": 10}, "so_4178175_27511360_2": {"section_id": 5854, "quality": 0.9375, "length": 45}}, "n3337": {"so_4178175_7189821_1": {"section_id": 5624, "quality": 0.9375, "length": 45}, "so_4178175_7189821_6": {"section_id": 5620, "quality": 0.6666666666666666, "length": 4}, "so_4178175_7189821_13": {"section_id": 452, "quality": 1.0, "length": 13}, "so_4178175_7189821_11": {"section_id": 359, "quality": 0.75, "length": 6}, "so_4178175_7189821_14": {"section_id": 452, "quality": 1.0, "length": 4}, "so_4178175_9491406_1": {"section_id": 5621, "quality": 0.6363636363636364, "length": 7}, "so_4178175_7189821_0": {"section_id": 3168, "quality": 0.8695652173913043, "length": 20}, "so_4178175_7189821_17": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_4178175_9491406_2": {"section_id": 458, "quality": 0.6, "length": 6}, "so_4178175_7189821_24": {"section_id": 5623, "quality": 0.8, "length": 12}, "so_4178175_7189821_8": {"section_id": 5620, "quality": 0.8888888888888888, "length": 8}, "so_4178175_7189821_10": {"section_id": 452, "quality": 1.0, "length": 5}, "so_4178175_7189821_2": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_4178175_7189821_9": {"section_id": 5620, "quality": 0.7857142857142857, "length": 11}, "so_4178175_7189821_12": {"section_id": 452, "quality": 1.0, "length": 9}, "so_4178175_27511360_0": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}, "so_4178175_7189821_20": {"section_id": 5621, "quality": 1.0, "length": 19}, "so_4178175_4178176_0": {"section_id": 3168, "quality": 0.631578947368421, "length": 12}, "so_4178175_7189821_5": {"section_id": 5620, "quality": 0.6666666666666666, "length": 4}, "so_4178175_7189821_23": {"section_id": 5622, "quality": 1.0, "length": 7}, "so_4178175_7189821_22": {"section_id": 5622, "quality": 1.0, "length": 9}, "so_4178175_7189821_18": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_4178175_7189821_21": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_4178175_7189821_16": {"section_id": 5621, "quality": 1.0, "length": 10}, "so_4178175_9491406_3": {"section_id": 451, "quality": 0.5833333333333334, "length": 7}, "so_4178175_27511360_2": {"section_id": 5624, "quality": 0.9166666666666666, "length": 44}}, "n4659": {"so_4178175_7189821_1": {"section_id": 7333, "quality": 0.9166666666666666, "length": 44}, "so_4178175_7189821_9": {"section_id": 7329, "quality": 0.7857142857142857, "length": 11}, "so_4178175_7189821_13": {"section_id": 484, "quality": 1.0, "length": 13}, "so_4178175_7189821_12": {"section_id": 484, "quality": 1.0, "length": 9}, "so_4178175_27511360_0": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}, "so_4178175_7189821_0": {"section_id": 4063, "quality": 0.5217391304347826, "length": 12}, "so_4178175_7189821_21": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_4178175_7189821_23": {"section_id": 7331, "quality": 1.0, "length": 7}, "so_4178175_7189821_22": {"section_id": 7331, "quality": 0.8888888888888888, "length": 8}, "so_4178175_7189821_20": {"section_id": 7330, "quality": 0.7894736842105263, "length": 15}, "so_4178175_9491406_1": {"section_id": 383, "quality": 0.5454545454545454, "length": 6}, "so_4178175_7189821_18": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_4178175_7189821_11": {"section_id": 383, "quality": 0.75, "length": 6}, "so_4178175_7189821_16": {"section_id": 7330, "quality": 1.0, "length": 10}, "so_4178175_7189821_17": {"section_id": 383, "quality": 0.7142857142857143, "length": 5}, "so_4178175_9491406_2": {"section_id": 490, "quality": 0.6, "length": 6}, "so_4178175_7189821_24": {"section_id": 7332, "quality": 0.8, "length": 12}, "so_4178175_7189821_8": {"section_id": 7329, "quality": 0.6666666666666666, "length": 6}, "so_4178175_27511360_2": {"section_id": 7333, "quality": 0.9375, "length": 45}, "so_4178175_7189821_10": {"section_id": 484, "quality": 1.0, "length": 5}, "so_4178175_7189821_2": {"section_id": 6103, "quality": 1.0, "length": 4}}}});