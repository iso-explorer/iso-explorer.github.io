post_cb({"bq_ids": {"n4140": {"so_47610789_47612863_1": {"length": 24, "quality": 1.0, "section_id": 6152}, "so_47610789_47612863_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6151}}, "n4659": {"so_47610789_47612863_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5962}, "so_47610789_47612863_1": {"length": 24, "quality": 1.0, "section_id": 7649}, "so_47610789_47612863_0": {"length": 6, "quality": 1.0, "section_id": 7648}}}, "47612863": {"Id": "47612863", "PostTypeId": "2", "Body": "<p>Pointer comparison is defined in <a href=\"http://eel.is/c++draft/expr.rel#3\" rel=\"nofollow noreferrer\">[expr.rel]/3-4</a>:</p>\n<blockquote>\n<p id=\"so_47610789_47612863_0\">Comparing unequal pointers to objects is defined as follows:</p>\n<ul>\n<li>If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript compares greater.</li>\n<li>If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the pointer to the later declared member compares greater provided the two members have the same access control and provided their class is not a union.</li>\n<li>Otherwise, neither pointer compares greater than the other.</li>\n</ul>\n<p id=\"so_47610789_47612863_1\">If two operands p and q compare equal, p&lt;=q and p&gt;=q both yield true and pq both yield false. Otherwise, if a pointer p compares greater than a pointer q, p&gt;=q, p&gt;q, q&lt;=p, and q=p, and q&gt;p all yield false. Otherwise, the result of each of the operators is unspecified.</p>\n</blockquote>\n<p>What conclusions can we draw from this?</p>\n<p>First, there is a <em>total order</em> of pointers of the same type within an object, but there is <em>no order</em> of pointers to different objects or of different subobjects with different access control. This lack of a general total order of pointers makes <code>is_within_object()</code> not very meaningful. In the cases where you'd expect it to return <code>true</code>, it works. In the cases where you'd expect it to return <code>false</code>, the result of these operators is unspecified? That's not a very useful result.</p>\n<p>On top of that, I don't even think the cases where you'd expect it to return <code>true</code> work. We don't have pointers to different members - we have pointers to <code>unsigned char</code>. We've already left the realm of objects, so we can't meaningfully compare these things. I think these comparisons are all still unspecified.</p>\n<hr/>\n<p><strong>That</strong> said, we do have a giant loophole for this in the form of <a href=\"http://eel.is/c++draft/comparisons#2\" rel=\"nofollow noreferrer\">[comparisons]</a>:</p>\n<blockquote>\n<p id=\"so_47610789_47612863_2\">For templates <code>less</code>, <code>greater</code>, <code>less_\u00adequal</code>, and <code>greater_\u00adequal</code>, the specializations for any pointer type yield a strict total order that is consistent among those specializations and is also consistent with the partial order imposed by the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>\n</blockquote>\n<p>So the following would be well-defined:</p>\n<pre><code>template&lt;class T&gt; \nauto byte_address(T&amp; p) {\n    return reinterpret_cast&lt;std::byte const*&gt;(std::addressof(p));\n}\n\ntemplate&lt;class Object, class Part&gt;\nbool is_within_object(Object&amp; object, Part&amp; part)\n{\n    auto first = byte_address(object);\n    auto last = first + sizeof(Object);   \n    auto p = byte_address(part);\n\n\n    return std::less_equal&lt;std::byte*&gt;{}(first, p) &amp;&amp;\n        std::less&lt;std::byte*&gt;{}(p, last);\n}\n</code></pre>\n", "Score": "1", "LastActivityDate": "2017-12-02T21:38:54.177", "CreationDate": "2017-12-02T21:38:54.177", "ParentId": "47610789", "CommentCount": "5", "OwnerUserId": "2069064"}, "47610789": {"ViewCount": "135", "FavoriteCount": "2", "Title": "Is it legal to check whether the address of a subobject lies within the bounds of a containing object", "CreationDate": "2017-12-02T17:53:29.897", "LastActivityDate": "2017-12-02T21:38:54.177", "CommentCount": "3", "Body": "<p>2 Questions:</p>\n<ol>\n<li><p>Is the following code well formed with defined behaviour?</p></li>\n<li><p>Is there any possible c++ implementation in which it could assert?</p></li>\n</ol>\n<p>Code (c++11 and higher):</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;utility&gt;\n#include &lt;ciso646&gt;\n\ntemplate&lt;class T&gt; \nauto to_address(T* p) { return reinterpret_cast&lt;unsigned char const*&gt;(p); }\n\n/// Test whether part is a sub-object of object\ntemplate&lt;class Object, class Part&gt;\nbool is_within_object(Object&amp; object, Part&amp; part)\n{\n    auto first = to_address(std::addressof(object)),\n                 last = first + sizeof(Object);\n\n    auto p = to_address(std::addressof(part));\n\n    return (first &lt;= p) and (p &lt; last);\n}\n\nstruct X\n{\n    int a = 0;\n\n    int&amp; get_a() { return a; }\n    int&amp; get_b() { return b; }\nprivate:\n\n    int b = 0;\n};\n\nint main()\n{\n    X x;\n\n    assert(is_within_object(x, x.get_a()));\n    assert(is_within_object(x, x.get_b()));\n}\n</code></pre>\n<p>Note that <code>a</code> and <code>b</code> have different visibility.</p>\n", "PostTypeId": "1", "Id": "47610789", "Score": "7", "OwnerUserId": "2015579", "Tags": "<c++><c++11><c++14><language-lawyer><c++1z>", "AnswerCount": "1"}});