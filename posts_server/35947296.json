post_cb({"35947797": {"Id": "35947797", "PostTypeId": "2", "Body": "<p>EDIT: This answer is incorrect! As others have pointed out, <code>center().x</code> is an xvalue, not an rvalue.</p>\n<p>g++ is correct, and this is a bug in clang.  From draft N3242 section 8.5.3/5, with bullet points changed to numbers:</p>\n<blockquote>\n<p id=\"so_35947296_35947797_0\">A reference to type \"<em>cv1</em> <code>T1</code>\" is initialized by an expression of type \"<em>cv2</em> <code>T2</code>\" as follows:</p>\n<ol>\n<li><p id=\"so_35947296_35947797_1\">If the reference is an lvalue reference and the initializer expression</p>\n<p id=\"so_35947296_35947797_2\">a. is an lvalue (but is not a bit-field) and \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv2</em> <code>T2</code>\", or</p>\n<p id=\"so_35947296_35947797_3\">b. has a class type ...</p>\n<p id=\"so_35947296_35947797_4\">then ...</p></li>\n<li><p id=\"so_35947296_35947797_5\">Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference.</p>\n<p id=\"so_35947296_35947797_6\">a. If the initializer expression</p>\n<ul>\n<li><p id=\"so_35947296_35947797_7\">i. is an xvalue, class prvalue, array prvalue or function lvalue and \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv2</em> <code>T2</code>\", or</p></li>\n<li><p id=\"so_35947296_35947797_8\">ii. has a class type ...</p></li>\n</ul>\n<p id=\"so_35947296_35947797_9\">then the reference is bound to the value of the initializer expression in the first case....</p>\n<p id=\"so_35947296_35947797_10\">b. Otherwise, a temporary of type \"<em>cv1</em> <code>T1</code>\" is created and initialized from the initializer expression using the rules for a non-reference copy-initialization (8.5).  The reference is then bound to the temporary.</p></li>\n</ol>\n</blockquote>\n<p>Since the initializer expression is a non-class scalar prvalue, point 2.a.i. does not apply, and we end up in case 2.b.  A temporary <code>double</code> is to be created by copy-initialization, and the reference binds to that, not to the subobject of <code>center()</code>.</p>\n<p>As you noticed, if the expression has a class type, things are different and the reference does bind directly to the subobject.</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2016-03-13T17:08:29.900", "Score": "2", "CreationDate": "2016-03-11T18:53:11.977", "ParentId": "35947296", "CommentCount": "6", "OwnerUserId": "459640", "LastEditDate": "2016-03-13T17:08:29.900"}, "35947513": {"Id": "35947513", "PostTypeId": "2", "Body": "<p>I would argue for a bug in g++, because, quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">draft N3242</a>, \u00a712.2/5:</p>\n<blockquote>\n<p id=\"so_35947296_35947513_0\">The second context is when a reference is bound to a temporary. The temporary to which the reference is\n  bound or <strong>the temporary that is the complete object of a subobject to which the reference is bound</strong> persists for the lifetime of the reference except:</p>\n</blockquote>\n<p>So its lifetime must be extended, except when:</p>\n<blockquote>\n<p id=\"so_35947296_35947513_1\">A temporary bound to a reference member in a constructor\u2019s ctor-initializer [..]</p>\n<p id=\"so_35947296_35947513_2\">A temporary bound to a reference parameter in a function call [..]</p>\n<p id=\"so_35947296_35947513_3\">The lifetime of a temporary bound to the returned value in a function return statement [..]</p>\n<p id=\"so_35947296_35947513_4\">A temporary bound to a reference in a <code>new-initializer</code> [..]</p>\n</blockquote>\n<p>Our case doesn't fit any of these exceptions, thus it must follow the rule. I'd say g++ is wrong here.</p>\n<p>Then, regarding the quote aschepler brought up from the same draft \u00a78.5.3/5 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_35947296_35947513_5\">A reference to type \"<em>cv1</em> <code>T1</code>\" is initialized by an expression of type \"<em>cv2</em> <code>T2</code>\" as follows:</p>\n<ol>\n<li><p id=\"so_35947296_35947513_6\">If the reference is an lvalue reference and the initializer expression</p>\n<p id=\"so_35947296_35947513_7\">a. is an lvalue (but is not a bit-field) and \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv2</em> <code>T2</code>\", or</p>\n<p id=\"so_35947296_35947513_8\">b. has a class type ...</p>\n<p id=\"so_35947296_35947513_9\">then ...</p></li>\n<li><p id=\"so_35947296_35947513_10\">Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference.</p>\n<p id=\"so_35947296_35947513_11\">a. If the <strong>initializer expression</strong></p>\n<ul>\n<li><p id=\"so_35947296_35947513_12\">i. <strong>is an xvalue</strong>, class prvalue, array prvalue or function lvalue and \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv2</em> <code>T2</code>\", or</p></li>\n<li><p id=\"so_35947296_35947513_13\">ii. has a class type ...</p></li>\n</ul>\n<p id=\"so_35947296_35947513_14\"><strong>then the reference is bound to the value of the initializer expression in the first case</strong>....</p>\n<p id=\"so_35947296_35947513_15\">b. Otherwise, a temporary of type \"<em>cv1</em> <code>T1</code>\" is created and initialized from the initializer expression using the rules for a non-reference copy-initialization (8.5).  The reference is then bound to the temporary.</p></li>\n</ol>\n</blockquote>\n<p>Looking at what an xvalue is, this time quoting <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/value_category</a> ...</p>\n<blockquote>\n<p id=\"so_35947296_35947513_16\">An xvalue (\"expiring value\") expression is [..]</p>\n<p id=\"so_35947296_35947513_17\"><code>a.m</code>, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference type;</p>\n</blockquote>\n<p>... the expression <code>center().x</code> <strong>should be</strong> an xvalue, thus case 2a from \u00a78.5.3/5 applies (and <strong>not</strong> the copy). I'll stay with my suggestion: g++ is wrong.</p>\n", "LastEditorUserId": "1116364", "LastActivityDate": "2016-03-11T19:33:09.433", "Score": "9", "CreationDate": "2016-03-11T18:35:45.983", "ParentId": "35947296", "CommentCount": "9", "OwnerUserId": "1116364", "LastEditDate": "2016-03-11T19:33:09.433"}, "35947296": {"ViewCount": "819", "Body": "<p>With code like</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct P {\n    int x;\n    P(int x) : x(x) {}\n    ~P() { std::cout &lt;&lt; \"~P()\\n\"; }\n};\n\nint main() {\n    auto const&amp; x = P{10}.x;\n    std::cout &lt;&lt; \"extract\\n\";\n}\n</code></pre>\n<p>GCC prints <code>~P() extract</code>, indicating that the temporary's lifetime is not extended by the reference. </p>\n<p>By contrast, Clang (IMO correctly) extends the lifetime of the temporary to the lifetime of the reference <code>x</code> and the destructor will be therefore called <strong>after</strong> the output in <code>main</code>.</p>\n<p>Note that GCC suddenly shows Clang's behavior if we, instead of <code>int</code>, use some class type (e.g. <code>string</code>).</p>\n<p>Is this a bug in GCC or something allowed by the standard?</p>\n", "AcceptedAnswerId": "35947572", "Title": "About binding a const reference to a sub-object of a temporary", "CreationDate": "2016-03-11T18:23:50.117", "Id": "35947296", "CommentCount": "0", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2016-03-13T20:11:30.833", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-14T13:11:26.457", "Score": "24", "OwnerUserId": "320726", "Tags": "<c++><reference><language-lawyer><temporary><object-lifetime>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_35947296_35947797_7": {"length": 10, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_12": {"length": 10, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_6": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_35947296_35947797_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_35947296_35947797_9": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_35947296_35947797_10": {"length": 12, "quality": 0.7058823529411765, "section_id": 3321}, "so_35947296_35947513_15": {"length": 12, "quality": 0.7058823529411765, "section_id": 3321}, "so_35947296_35947513_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 382}, "so_35947296_35947465_0": {"length": 10, "quality": 1.0, "section_id": 381}, "so_35947296_35947465_1": {"length": 56, "quality": 0.8888888888888888, "section_id": 382}, "so_35947296_35947513_10": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_35947296_35947797_1": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_1": {"length": 6, "quality": 1.0, "section_id": 382}, "so_35947296_35947513_4": {"length": 4, "quality": 1.0, "section_id": 382}, "so_35947296_35947513_2": {"length": 6, "quality": 1.0, "section_id": 382}, "so_35947296_35947797_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_35947296_35947572_3": {"length": 12, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 382}, "so_35947296_35947572_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 3321}, "so_35947296_35947513_7": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_14": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_35947296_35947797_2": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_35947296_35947513_17": {"length": 6, "quality": 0.6, "section_id": 4701}, "so_35947296_35947513_5": {"length": 8, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_35947296_35947797_7": {"length": 10, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_12": {"length": 10, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_6": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_35947296_35947797_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_35947296_35947797_9": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_35947296_35947797_10": {"length": 15, "quality": 0.8823529411764706, "section_id": 3191}, "so_35947296_35947513_15": {"length": 15, "quality": 0.8823529411764706, "section_id": 3191}, "so_35947296_35947513_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 373}, "so_35947296_35947465_0": {"length": 10, "quality": 1.0, "section_id": 372}, "so_35947296_35947465_1": {"length": 56, "quality": 0.8888888888888888, "section_id": 373}, "so_35947296_35947513_10": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_35947296_35947797_1": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_1": {"length": 6, "quality": 1.0, "section_id": 373}, "so_35947296_35947513_2": {"length": 6, "quality": 1.0, "section_id": 373}, "so_35947296_35947797_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_35947296_35947572_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_35947296_35947513_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 373}, "so_35947296_35947513_5": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_7": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_14": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_35947296_35947797_2": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_35947296_35947513_17": {"length": 6, "quality": 0.6, "section_id": 3155}, "so_35947296_35947513_4": {"length": 4, "quality": 1.0, "section_id": 373}}, "n4659": {"so_35947296_35947797_7": {"length": 6, "quality": 0.6, "section_id": 620}, "so_35947296_35947513_12": {"length": 6, "quality": 0.6, "section_id": 620}, "so_35947296_35947513_6": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_35947296_35947797_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_35947296_35947797_9": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_35947296_35947797_10": {"length": 10, "quality": 0.5882352941176471, "section_id": 4087}, "so_35947296_35947513_15": {"length": 10, "quality": 0.5882352941176471, "section_id": 4087}, "so_35947296_35947513_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 397}, "so_35947296_35947465_0": {"length": 9, "quality": 0.9, "section_id": 396}, "so_35947296_35947465_1": {"length": 56, "quality": 0.8888888888888888, "section_id": 397}, "so_35947296_35947513_10": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_35947296_35947797_1": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_35947296_35947513_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 453}, "so_35947296_35947513_2": {"length": 6, "quality": 1.0, "section_id": 397}, "so_35947296_35947797_5": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_35947296_35947572_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 4087}, "so_35947296_35947513_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 397}, "so_35947296_35947513_5": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_35947296_35947513_7": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_35947296_35947513_14": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_35947296_35947797_2": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_35947296_35947513_17": {"length": 6, "quality": 0.6, "section_id": 4047}, "so_35947296_35947513_4": {"length": 4, "quality": 1.0, "section_id": 397}, "so_35947296_35947572_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 4087}}}, "35947465": {"Id": "35947465", "PostTypeId": "2", "Body": "<p>Just read <a href=\"https://stackoverflow.com/a/35947572/2069064\">Columbo's answer</a>.</p>\n<hr/>\n<p>This is a gcc bug. The relevant rule is in <a href=\"http://eel.is/c++draft/class.temporary#5\" rel=\"nofollow noreferrer\">[class.temporary]</a>:</p>\n<blockquote>\n<p id=\"so_35947296_35947465_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. [...]  </p>\n<p id=\"so_35947296_35947465_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the <strong>temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference</strong> except:<br>\n  \u2014 A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion\n  of the full-expression containing the call.<br>\n  \u2014 The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not\n  extended; the temporary is destroyed at the end of the full-expression in the return statement.<br>\n  \u2014 A temporary bound to a reference in a <em>new-initializer</em> (5.3.4) persists until the completion of the\n  full-expression containing the <em>new-initializer</em>.</br></br></br></p>\n</blockquote>\n<p>We're binding a reference to a subobject of a temporary, so the temporary should persist for the lifetime of the reference. None of those three exceptions to this rule apply here. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-14T13:11:26.457", "Score": "3", "CreationDate": "2016-03-11T18:33:15.003", "ParentId": "35947296", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T10:30:08.527"}, "35947572": {"Id": "35947572", "PostTypeId": "2", "Body": "<p>This is covered by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1651\" rel=\"nofollow noreferrer\">CWG 1651</a>:</p>\n<blockquote>\n<p id=\"so_35947296_35947572_0\">The resolution of issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#616\" rel=\"nofollow noreferrer\">616</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1213\" rel=\"nofollow noreferrer\">1213</a>, making the result of a member\n  access or subscript expression applied to a prvalue an xvalue, means\n  that binding a reference to such a subobject of a temporary does not\n  extend the temporary's lifetime. 12.2 [class.temporary] should be\n  revised to ensure that it does.</p>\n</blockquote>\n<p>The status quo is that <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/ecOwk4tzEWU/nEspcCcHEQAJ\" rel=\"nofollow noreferrer\">only prvalues are treated as referring to temporaries</a> - thus <a href=\"http://eel.is/c++draft/class.temporary#5\" rel=\"nofollow noreferrer\">[class.temporary]/5</a> (<em>\"The second context is when a reference is bound to a temporary.\"</em>) is not considered applicable. Clang and GCC have not actually implemented issue 616's resolution, though. <a href=\"http://coliru.stacked-crooked.com/a/cc3471b082b51636\" rel=\"nofollow noreferrer\"><code>center().x</code> is treated as a prvalue by both</a>. My best guess:</p>\n<ul>\n<li><p>GCC simply didn't react to any DRs yet, at all. It doesn't extend lifetime when using <strong>scalar subobjects</strong>, because those are <strong>not</strong> covered by <a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"nofollow noreferrer\">[dcl.init.ref]/(5.2.1.1)</a><sup>\u2020</sup>. So the complete temporary object doesn't need to live on (see <a href=\"https://stackoverflow.com/a/35947797/3647361\">aschelper's answer</a>), and it doesn't, because the reference doesn't bind directly. If the subobject is of class or array type, the reference binds directly, and GCC extends the temporary's lifetime. This has been noted in <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60297\" rel=\"nofollow noreferrer\">DR 60297</a>.</p></li>\n<li><p>Clang recognizes member access and implemented the \"new\" lifetime extension rules already - it even <a href=\"http://coliru.stacked-crooked.com/a/a4cb98bb815d079d\" rel=\"nofollow noreferrer\">handles casts</a>. Technically speaking, this is not consistent with the way it handles value categories. However, it is more sensible and will be the correct behavior once the aforementioned DR is resolved.</p></li>\n</ul>\n<p>I'd therefore say that GCC is correct by current wording, but current wording is defective and vague, and Clang already implemented the pending resolution to DR 1651, which is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3918.html\" rel=\"nofollow noreferrer\"><strong>N3918</strong></a>. This paper covers the example very clearly:</p>\n<blockquote>\n<p id=\"so_35947296_35947572_1\">If <code>E1</code> is a temporary expression and <code>E2</code> does not designate a\n  bit-field, then <code>E1.E2</code> is a temporary expression.</p>\n</blockquote>\n<p><code>center()</code> is a temporary expression as per the paper's wording for [expr.call]/11. Thus its modified wording in the aforementioned [class.temporary] /5 applies:</p>\n<blockquote>\n<p id=\"so_35947296_35947572_2\">The second context is when a reference does not bind directly (8.5.3\n  dcl.init.ref) <strong>or is initialized with a temporary expression</strong> (clause 5). <strong>The corresponding temporary\n  object (if any) persists for the lifetime of the reference</strong> except: <em>[...inapplicable exceptions...]</em></p>\n</blockquote>\n<p>Voil\u00e0, we have lifetime extension. Note that \"the corresponding temporary object\" is not clear enough, one of the reasons for the proposal's deferment; it will assuredly be adopted once it gets revised.</p>\n<hr>\n<p><sup>\u2020</sup></p>\n<blockquote>\n<p id=\"so_35947296_35947572_3\">is an xvalue (but not a bit-field), <strong>class prvalue, array prvalue</strong> or function lvalue and \u201c<code>cv1 T1</code>\u201d is reference-compatible with \u201c<code>cv2 T2</code>\u201d, or [\u2026]</p>\n</blockquote>\n<p>Indeed, GCC respects this fully and will extend lifetime if the subobject has array type.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-14T12:17:39.030", "Score": "12", "CreationDate": "2016-03-11T18:39:43.407", "ParentId": "35947296", "CommentCount": "11", "OwnerUserId": "3647361", "LastEditDate": "2017-05-23T12:34:54.180"}});