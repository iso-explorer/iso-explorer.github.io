post_cb({"bq_ids": {"n4140": {"so_22146749_22147471_4": {"length": 16, "quality": 0.8888888888888888, "section_id": 6328}, "so_22146749_22147471_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 4663}, "so_22146749_22147471_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4662}, "so_22146749_22147471_6": {"length": 10, "quality": 0.7692307692307693, "section_id": 4660}}, "n3337": {"so_22146749_22147471_4": {"length": 16, "quality": 0.8888888888888888, "section_id": 6085}, "so_22146749_22147471_0": {"length": 12, "quality": 0.8, "section_id": 4470}, "so_22146749_22147471_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4472}, "so_22146749_22147471_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 4473}}, "n4659": {"so_22146749_22147471_4": {"length": 16, "quality": 0.8888888888888888, "section_id": 7838}, "so_22146749_22147471_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 6032}, "so_22146749_22147471_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 6033}, "so_22146749_22147471_6": {"length": 8, "quality": 0.6153846153846154, "section_id": 6030}}}, "22147375": {"Id": "22147375", "PostTypeId": "2", "Body": "<p><strong>It is totally valid.</strong> Since c++11 lambda expressions (and your <code>std::function</code> wrapper) create function objects. The great strength of function objects is that, even when they are generic, they remain first-class objects. Unlike ordinary function templates, they can be passed to and returned from functions. </p>\n<p>You can create operator overload sets explicitly with inheritance and using declarations. The following usage from <a href=\"https://plus.google.com/109462007708056630177/posts\" rel=\"nofollow\">Mathias Gaunard</a> demonstrates \u201coverloaded lambda expressions\".</p>\n<pre><code>template &lt;class F1, class F2&gt;\nstruct overload_set : F1, F2\n{\n    overload_set(F1 x1, F2 x2) : F1(x1), F2(x2) {}\n    using F1::operator();\n    using F2::operator();\n};\n\ntemplate &lt;class F1, class F2&gt;\noverload_set&lt;F1,F2&gt; overload(F1 x1, F2 x2)\n{\n    return overload_set&lt;F1,F2&gt;(x1,x2);\n}\n\nauto f = overload(\n    [](){return 1;}, \n    [](int x){return x+1;}\n);\n\nint x = f();\nint y = f(2);\n</code></pre>\n<p><a href=\"http://cpp-next.com/archive/2012/09/unifying-generic-functions-and-function-objects/\" rel=\"nofollow\">source</a></p>\n<p><strong>EDIT:</strong> Maybe it'll become more clear if in the provided example you replace</p>\n<pre><code>F1 -&gt; std::function&lt;void()&gt; \nF2 -&gt; std::function&lt;void(int)&gt;\n</code></pre>\n<p>and <a href=\"http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22MQSwdgxgNgrgJgUwAQB4QHsDOAXATggQwFsA%2BAKFElkVQDMZJsMwCpyzsBPABwUVqQ44ALmH1GzFADd0IOAAokSgJQkkAMQCMAbg48%2BCAUNHiITdGGmyF4bKo0AmXWRy4YZpOikJcUdATgAfUwEbCRhDU0AGkcyAG8yAEgvHz8A4ND5LSQAD2jHXIdlcMj5POUY9QcyoqQ4gF8kmExwAHNI0XReXAJsdFx5ZV1E5rbHTu7e%2FsHdeucU338gkLCFtIVsvMqHQuV4pPxsGFwwT29F9JWy6Jyi2bIyWyQiAnBB%2FcSCGD6kAQBeM6pJbyMhKMFIADaAF1BuClHFBNgRMIIOhvqgUEgAESKFSAi5wAA6YCx2nqMVBcOh8ieOWKCOMKLRYRQmJxtmKayWxNJ9SGD0StBmSSFdwFh2OpwADLMgAAA%3D%3D%22%2C%22compiler%22%3A%22%2Fusr%2Fbin%2Fg%2B%2B-4.7%22%2C%22options%22%3A%22-std%3Dc%2B%2B0x%22%7D%5D%7D\" rel=\"nofollow\">see it compile in gcc4.7</a></p>\n<p>The templated solution was only provide to demonstrate that concept scales to generic code and dissambiguation is possible. </p>\n<p><strong>In your case, when using an older compiler like gcc 4.7</strong>, you could help by explicit cast and <a href=\"http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22MQSwdgxgNgrgJgUwAQB4QHsDOAXATggQwFsA%2BAKFElkVQDMZJsMwCpyzsBPABwUVqQ44ALmH1GzFADd0IOAAoAlCSTiIARgD62ANwcefBAKGi1TdGGmyF4bMtUMIAJm16yOXDAjYkADTIA3mRIIb5I8mpaPrSKwSEBSAC%2BZHF%2B4Wou0bEhSAnJiW62SEQE4OFIsUGhSOgARgBW6vKC2CJijuaWMnJKJM0A2gC6SgkARAASCFBQ6AA0SADu6LhQcACEADpgozpJFRV6IXFhdfVOzSbtEhZWPbbKA8NFANaKY5PTc4vLq5vbu4l9oo9IkgAAA%3D%22%2C%22compiler%22%3A%22%2Fusr%2Fbin%2Fg%2B%2B-4.7%22%2C%22options%22%3A%22-std%3Dc%2B%2B0x%22%7D%5D%7D\" rel=\"nofollow\">gcc will work things out, as you can see in this live example</a></p>\n<p>Just in case you're wondering, it wouldn't work if you cast the other way around (try to convert the lambda taking int to the std::function taking no arguments and so on)</p>\n", "LastEditorUserId": "2567683", "LastActivityDate": "2014-03-03T15:43:19.527", "Score": "-3", "CreationDate": "2014-03-03T12:54:51.307", "ParentId": "22146749", "CommentCount": "8", "OwnerUserId": "2567683", "LastEditDate": "2014-03-03T15:43:19.527"}, "22147471": {"Id": "22147471", "PostTypeId": "2", "Body": "<p>In C++11...</p>\n<p>Let's take a look at the specification of the constructor template of <code>std::function</code> (which takes any Callable): [func.wrap.func.con]/7-10</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_22146749_22147471_0\">7 <em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> (20.10.11.2) for argument types <code>ArgTypes</code> and return type\n  <code>R</code>. The copy constructor and destructor of <code>A</code> shall not throw\n  exceptions.</p>\n<p id=\"so_22146749_22147471_1\">8 <em>Postconditions:</em> <code>!*this</code> if any of the following hold:</p>\n<ul>\n<li><code>f</code> is a <code>NULL</code> function pointer.</li>\n<li><code>f</code> is a <code>NULL</code> pointer to member.</li>\n<li><code>F</code> is an instance of the function class template, and <code>!f</code></li>\n</ul>\n<p id=\"so_22146749_22147471_2\">9 Otherwise, <code>*this</code> targets a copy of <code>f</code> initialized with <code>std::move(f)</code>. [left out a note here]</p>\n<p id=\"so_22146749_22147471_3\">10 <em>Throws:</em> shall not throw exceptions when <code>f</code> is a function pointer or a <code>reference_wrapper&lt;T&gt;</code> for some <code>T</code>. Otherwise, may throw\n  <code>bad_alloc</code> or any exception thrown by <code>F</code>\u2019s copy or move constructor.</p>\n</blockquote>\n<p>Now, constructing, or attempting to construct (for overload resolution) a <code>std::function&lt;void(int)&gt;</code> from a <code>[](){}</code> (i.e. with signature <code>void(void)</code>) violates the requirements of <code>std::function&lt;void(int)&gt;</code>'s constructor.</p>\n<p>[res.on.required]/1</p>\n<blockquote>\n<p id=\"so_22146749_22147471_4\">Violation of the preconditions specified in a function\u2019s <em>Requires:</em> paragraph results in undefined behavior unless the function\u2019s <em>Throws:</em> paragraph specifies throwing an exception when the precondition is violated.</p>\n</blockquote>\n<p>So, AFAIK, even the result of the overload resolution is undefined. Therefore, both versions of g++/libstdc++ are complying in this aspect.</p>\n<hr>\n<p>In C++14, this has been changed, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2132\" rel=\"nofollow\">LWG 2132</a>. Now, the converting constructor template of <code>std::function</code> is required to SFINAE-reject incompatible Callables (more about SFINAE in the next chapter):</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_22146749_22147471_5\">7 <em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>.</p>\n<p id=\"so_22146749_22147471_6\">8 <em>Remarks:</em> These constructors shall not participate in overload\n  resolution unless <code>f</code> is Callable (20.9.11.2) for argument types\n  <code>ArgTypes...</code> and return type <code>R</code>.</p>\n<p id=\"so_22146749_22147471_7\">[...]</p>\n</blockquote>\n<p>The \"shall not participate in overload resolution\" corresponds to rejection via SFINAE. The net effect is that if you have an overload set of functions <code>foo</code>,</p>\n<pre><code>void foo(std::function&lt;void(double)&gt;);\nvoid foo(std::function&lt;void(char const*)&gt;);\n</code></pre>\n<p>and a call-expression such as</p>\n<pre><code>foo([](std::string){}) // (C)\n</code></pre>\n<p>then the second overload of <code>foo</code> is chosen unambiguously: Since <code>std::function&lt;F&gt;</code> defines <code>F</code> as its interface to the outside, the <code>F</code> defines which argument types are passed into <code>std::function</code>. Then, the wrapped function object has to be called with those arguments (argument types). If a <code>double</code> is passed into <code>std::function</code>, it cannot be passed on to a function taking a <code>std::string</code>, because there's no conversion <code>double</code> -&gt; <code>std::string</code>.\nFor the first overload of <code>foo</code>, the argument <code>[](std::string){}</code> is therefore not considered Callable for <code>std::function&lt;void(double)&gt;</code>. The constructor template is deactivated, hence there's no viable conversion from <code>[](std::string){}</code> to <code>std::function&lt;void(double)&gt;</code>. This first overload is removed from the overload set for resolving the call (C), leaving only the second overload.</p>\n<p>Note that there's been a slight change to the wording above, due to <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2420\" rel=\"nofollow\">LWG 2420</a>: There's an exception that if the return type <code>R</code> of a <code>std::function&lt;R(ArgTypes...)&gt;</code> is <code>void</code>, then any return type is accepted (and discarded) for the Callable in the constructor template mentioned above. For example, both <code>[]() -&gt; void {}</code> and <code>[]() -&gt; bool {}</code> are Callable for <code>std::function&lt;void()&gt;</code>. The following situation therefore produces an ambiguity:</p>\n<pre><code>void foo(std::function&lt;void()&gt;);\nvoid foo(std::function&lt;bool()&gt;);\n\nfoo([]() -&gt; bool {}); // ambiguous\n</code></pre>\n<p>The overload resolution rules don't try to rank among different user-defined conversions, and hence both overloads of <code>foo</code> are viable (first of all) and neither is better.</p>\n<hr>\n<h3>How can SFINAE help here?</h3>\n<p>Note when a SFINAE-check fails, the program isn't ill-formed, but the function isn't viable for overload resolution. For example:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nauto foo(T) -&gt; typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type\n{  std::cout &lt;&lt; \"foo 1\\n\";  }\n\ntemplate&lt;class T&gt;\nauto foo(T) -&gt; typename std::enable_if&lt; not std::is_integral&lt;T&gt;::value &gt;::type\n{  std::cout &lt;&lt; \"foo 2\\n\";  }\n\nint main()\n{\n    foo(42);\n    foo(42.);\n}\n</code></pre>\n<p>Similarly, a conversion can be made non-viable by using SFINAE on the converting constructor:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\nstruct foo\n{\n    template&lt;class T, class =\n             typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type &gt;\n    foo(T)\n    {  std::cout &lt;&lt; \"foo(T)\\n\";  }\n};\n\nstruct bar\n{\n    template&lt;class T, class =\n             typename std::enable_if&lt; not std::is_integral&lt;T&gt;::value &gt;::type &gt;\n    bar(T)\n    {  std::cout &lt;&lt; \"bar(T)\\n\";  }\n};\n\nstruct kitty\n{\n    kitty(foo) {}\n    kitty(bar) {}\n};\n\nint main()\n{\n    kitty cat(42);\n    kitty tac(42.);\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2016-04-21T21:30:35.387", "Score": "11", "CreationDate": "2014-03-03T12:58:52.143", "ParentId": "22146749", "CommentCount": "18", "OwnerUserId": "420683", "LastEditDate": "2016-04-21T21:30:35.387"}, "22146749": {"ViewCount": "2161", "Body": "<p>Consider this example of code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\ntypedef std::function&lt;void()&gt; func1_t;\ntypedef std::function&lt;void(int)&gt; func2_t;\n\nstruct X\n{\n   X (func1_t f)\n   { }\n\n   X (func2_t f)\n   { }\n};\n\nint main ( )\n{\n   X x([](){ std::cout &lt;&lt; \"Hello, world!\\n\"; });\n}\n</code></pre>\n<p>I was sure that it shouldn't compile, because the compiler shouldn't be able to choose one of the two constructors. g++-4.7.3 shows this expected behavior: it says that call of overloaded constructor is ambiguous. However, g++-4.8.2 successfully compiles it.</p>\n<p>Is this code correct in C++11 or it is a bug/feature of this version of g++?</p>\n", "AcceptedAnswerId": "22147471", "Title": "Overload resolution with std::function", "CreationDate": "2014-03-03T12:25:04.190", "Id": "22146749", "CommentCount": "13", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2016-04-21T21:30:35.387", "Score": "14", "OwnerUserId": "2315602", "Tags": "<c++><c++11><lambda><overloading>", "AnswerCount": "2"}});