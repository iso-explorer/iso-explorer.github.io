post_cb({"14251032": {"ParentId": "14251010", "CommentCount": "4", "Body": "<p>It is fine and legal code.<br>\nThe compiler will take care of necessary optimizations(<em>if it can</em>) through copy elision.      </br></p>\n<p>The temporary <code>f(...)</code> is guaranteed to live at least until the expression ends. Note that the expressions ends just after the return from <code>stl_instance(f(...))</code>, to be precise <code>;</code>(<em>the semicolon at the end of call</em>). So it is perfectly valid. </p>\n<p><strong>C++03 Standard \u00a712.2/3:</strong></p>\n<blockquote>\n<p id=\"so_14251010_14251032_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. </p>\n</blockquote>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "14251032", "Score": "1", "CreationDate": "2013-01-10T04:52:45.723", "LastActivityDate": "2013-01-10T04:52:45.723"}, "14251010": {"CommentCount": "0", "AcceptedAnswerId": "14255922", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-01-10T04:50:39.873", "LastActivityDate": "2013-01-10T16:46:54.367", "LastEditDate": "2013-01-10T10:39:56.220", "ViewCount": "210", "FavoriteCount": "0", "Title": "Efficiency of construction of stl container based on a function return", "Id": "14251010", "Score": "4", "Body": "<p>I have a factory function which return a stl container:</p>\n<pre><code>const std::vector&lt;int&gt; f(...) {\n    std::vector&lt;int&gt; retval;\n    return retval;\n}\n</code></pre>\n<p>I guess it is ok to define a stl instance as follow(no error):</p>\n<pre><code>const std::vector&lt;int&gt; stl_instance(f(...));\n</code></pre>\n<p>But is it efficient to do so?</p>\n<p>Is the temporary stl object directly assigned to <code>stl_instance</code>?</p>\n", "Tags": "<c++><c++11><rvalue-reference><move-semantics><return-value-optimization>", "OwnerUserId": "1182304", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14251010_14251032_0": {"section_id": 380, "quality": 1.0, "length": 14}}, "n3337": {"so_14251010_14251032_0": {"section_id": 371, "quality": 1.0, "length": 14}}, "n4659": {"so_14251010_14251032_0": {"section_id": 395, "quality": 1.0, "length": 14}}}, "14255922": {"ParentId": "14251010", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Returning a const rvalue is an anti-pattern in C++11. First consider returning non-const rvalues:</p>\n<pre><code>std::vector&lt;int&gt; f(int n) \n{ \n    return std::vector&lt;int&gt;(n); \n}\n\nint main() \n{ \n    std::vector&lt;int&gt; v; \n    v = f(3); \n} \n</code></pre>\n<p>In C++98/03, this code will go to the heap at least twice: </p>\n<ol>\n<li>To create the vector inside of f (if the RVO applies)</li>\n<li>To assign from f's return to v.  </li>\n</ol>\n<p>If your compiler does not apply the RVO, you get 3 heap allocations.</p>\n<p>In C++11, you only get 1 heap allocation: to create the vector inside of <code>f</code>. This happens regardless of the RVO. The reason is that all the STL containers have move constructors and move assignment operators that have the signatures</p>\n<pre><code>vector( vector&amp;&amp; other );\nvector&amp; operator=( vector&amp;&amp; other );\n</code></pre>\n<p>The rvalue references <code>&amp;&amp;</code> will move the resources from inside your creation function directly to their destination. However, your code has the signature </p>\n<pre><code>const std::vector&lt;int&gt; f(int n) \n{ \n    return std::vector&lt;int&gt;(n); \n}\n</code></pre>\n<p>will disable the move semantics because a T&amp;&amp; (i.e. the argument of the move constructor and assignment operator)  will not bind to a const rvalue parameter (i.e. the return value of your function). This effectively makes your code run as under C++98/03 (i.e. with 2 or 3 heap allocations).</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-01-10T16:46:54.367", "Id": "14255922", "Score": "5", "CreationDate": "2013-01-10T10:39:17.907", "LastActivityDate": "2013-01-10T16:46:54.367"}});