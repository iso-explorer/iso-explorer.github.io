post_cb({"bq_ids": {"n4140": {"so_14251010_14251032_0": {"length": 14, "quality": 1.0, "section_id": 380}}, "n3337": {"so_14251010_14251032_0": {"length": 14, "quality": 1.0, "section_id": 371}}, "n4659": {"so_14251010_14251032_0": {"length": 14, "quality": 1.0, "section_id": 395}}}, "14255922": {"Id": "14255922", "PostTypeId": "2", "Body": "<p>Returning a const rvalue is an anti-pattern in C++11. First consider returning non-const rvalues:</p>\n<pre><code>std::vector&lt;int&gt; f(int n) \n{ \n    return std::vector&lt;int&gt;(n); \n}\n\nint main() \n{ \n    std::vector&lt;int&gt; v; \n    v = f(3); \n} \n</code></pre>\n<p>In C++98/03, this code will go to the heap at least twice: </p>\n<ol>\n<li>To create the vector inside of f (if the RVO applies)</li>\n<li>To assign from f's return to v.  </li>\n</ol>\n<p>If your compiler does not apply the RVO, you get 3 heap allocations.</p>\n<p>In C++11, you only get 1 heap allocation: to create the vector inside of <code>f</code>. This happens regardless of the RVO. The reason is that all the STL containers have move constructors and move assignment operators that have the signatures</p>\n<pre><code>vector( vector&amp;&amp; other );\nvector&amp; operator=( vector&amp;&amp; other );\n</code></pre>\n<p>The rvalue references <code>&amp;&amp;</code> will move the resources from inside your creation function directly to their destination. However, your code has the signature </p>\n<pre><code>const std::vector&lt;int&gt; f(int n) \n{ \n    return std::vector&lt;int&gt;(n); \n}\n</code></pre>\n<p>will disable the move semantics because a T&amp;&amp; (i.e. the argument of the move constructor and assignment operator)  will not bind to a const rvalue parameter (i.e. the return value of your function). This effectively makes your code run as under C++98/03 (i.e. with 2 or 3 heap allocations).</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-01-10T16:46:54.367", "Score": "5", "CreationDate": "2013-01-10T10:39:17.907", "ParentId": "14251010", "CommentCount": "0", "OwnerUserId": "819272", "LastEditDate": "2013-01-10T16:46:54.367"}, "14251032": {"Id": "14251032", "PostTypeId": "2", "Body": "<p>It is fine and legal code.<br>\nThe compiler will take care of necessary optimizations(<em>if it can</em>) through copy elision.      </br></p>\n<p>The temporary <code>f(...)</code> is guaranteed to live at least until the expression ends. Note that the expressions ends just after the return from <code>stl_instance(f(...))</code>, to be precise <code>;</code>(<em>the semicolon at the end of call</em>). So it is perfectly valid. </p>\n<p><strong>C++03 Standard \u00a712.2/3:</strong></p>\n<blockquote>\n<p id=\"so_14251010_14251032_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. </p>\n</blockquote>\n", "LastActivityDate": "2013-01-10T04:52:45.723", "CommentCount": "4", "CreationDate": "2013-01-10T04:52:45.723", "ParentId": "14251010", "Score": "1", "OwnerUserId": "452307"}, "14251010": {"ViewCount": "210", "Body": "<p>I have a factory function which return a stl container:</p>\n<pre><code>const std::vector&lt;int&gt; f(...) {\n    std::vector&lt;int&gt; retval;\n    return retval;\n}\n</code></pre>\n<p>I guess it is ok to define a stl instance as follow(no error):</p>\n<pre><code>const std::vector&lt;int&gt; stl_instance(f(...));\n</code></pre>\n<p>But is it efficient to do so?</p>\n<p>Is the temporary stl object directly assigned to <code>stl_instance</code>?</p>\n", "AcceptedAnswerId": "14255922", "Title": "Efficiency of construction of stl container based on a function return", "CreationDate": "2013-01-10T04:50:39.873", "Id": "14251010", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-01-10T10:39:56.220", "LastEditorUserId": "819272", "LastActivityDate": "2013-01-10T16:46:54.367", "Score": "4", "OwnerUserId": "1182304", "Tags": "<c++><c++11><rvalue-reference><move-semantics><return-value-optimization>", "AnswerCount": "2"}});