post_cb({"35536263": {"ParentId": "35536146", "CommentCount": "0", "Body": "<p>According to the C++ Standard (4.5 Integral promotions)</p>\n<blockquote>\n<p id=\"so_35536146_35536263_0\">4 A prvalue of an unscoped enumeration type whose underlying type is\n  fixed (7.2) can be converted to a prvalue of its underlying type.\n  <strong>Moreover, if integral promotion can be applied to its underlying type,\n  a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying\n  type</strong>.</p>\n</blockquote>\n<p>So the integral promotion is applied and the operator &lt;&lt; for objects of type int is called. </p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "35536263", "Score": "14", "CreationDate": "2016-02-21T12:43:02.683", "LastActivityDate": "2016-02-21T12:43:02.683"}, "35536906": {"ParentId": "35536146", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>When you say <code>enum num : char</code>, then you express the fact that <code>num</code> is internally implemented in terms of a <code>char</code> but can still be automatically converted to an integer value, which is <em>not</em> necessarily <code>char</code>.</p>\n<p>As the page you cite says:</p>\n<blockquote>\n<p id=\"so_35536146_35536906_0\">Values of unscoped enumeration type are implicitly-convertible to\n  integral types.</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/14206403/why-does-a-value-of-an-enum-with-a-fixed-underlying-type-of-char-resolve-to-fct\">Why does a value of an enum with a fixed underlying type of char resolve to fct(int) instead of fct(char)?</a> for an interesting discussion on problems in the C++ standard's wording regarding the combination of integral promotion and fixed underlying types.</p>\n<p>In any case, you can imagine this whole thing like a class with a private <code>char</code> member variable and a public <code>int</code> conversion operator:</p>\n<pre><code>// very similar to your enum:\nclass num {\nprivate:\n    char c;\n\npublic:\n    num(char c) : c(c) {}\n    operator int() const {\n        return c;\n    }\n};\n\nnum two { '2' };\nstd::cout &lt;&lt; two; // prints 50\n</code></pre>\n<p>To increase type safety and make the <code>std::cout</code> line a compilation error, just turn the <code>enum</code> into an <code>enum class</code>:</p>\n<pre><code>enum class num : char\n</code></pre>\n<p>This is again similar to the imagined <code>class num</code> above, but without the conversion operator.</p>\n<p>When you feed an instance of <code>num</code> to <code>std::cout</code>, then you are a client of <code>num</code> and are not logically supposed to think that the output format will take its internal <code>char</code> implementation into account.</p>\n<p>To get more control over the output format, you should instead do like with any other custom type, and overload <code>operator&lt;&lt;</code> for <code>std::ostream</code>. Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum class num : char {\n    zero = '0',\n    one = '1',\n    two = '2',\n    three = '3',\n    four = '4',\n    five = '5',\n    six = '6'\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, num const&amp; n)\n{\n    switch (n)\n    {\n        case num::zero: os &lt;&lt; \"Zero\"; break;\n        case num::one: os &lt;&lt; \"One\"; break;\n        case num::two: os &lt;&lt; \"Two\"; break;\n        case num::three: os &lt;&lt; \"Three\"; break;\n        // and so on\n    }\n    return os;\n}\n\nint main()\n{\n    std::cout &lt;&lt; num::two; // prints \"Two\"\n}\n</code></pre>\n<p>Of course, the specific <code>char</code> values of the enum instances have now become pretty useless, so you may as well get rid of them completely:</p>\n<pre><code>enum class num : char {\n    zero,\n    one,\n    two,\n    three,\n    four,\n    five,\n    six\n};\n</code></pre>\n<p>This may strike you as strange, but keep in mind that an enum which represents nothing but generic numbers from zero to six is not a realistic use case.</p>\n", "OwnerUserId": "3313064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:14.737", "Id": "35536906", "Score": "11", "CreationDate": "2016-02-21T13:45:30.333", "LastActivityDate": "2016-02-21T16:05:19.453"}, "35536279": {"ParentId": "35536146", "CommentCount": "0", "Body": "<p>The reason is that your <code>enum : char</code> is not the same as <code>char</code> (which is exactly what we want - we don't want enum to be the same as other types, even if they are assignment compatible - we want <code>void func(num n)</code> to be distinct from <code>void func(char n)</code>, right?). </p>\n<p>So, since <code>enum num</code> isn't a <code>char</code>, the <code>operator&lt;&lt;(int)</code> will be used, and prints the integer value, even if the underlying type is <code>char</code>. Not entirely sensible, but I'm sure this is what happens.</p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "35536279", "Score": "5", "CreationDate": "2016-02-21T12:45:23.970", "LastActivityDate": "2016-02-21T12:45:23.970"}, "35536146": {"CommentCount": "6", "AcceptedAnswerId": "35538979", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2016-02-21T12:31:01.853", "LastActivityDate": "2016-03-15T21:46:53.753", "LastEditDate": "2016-02-21T23:16:04.220", "ViewCount": "3477", "FavoriteCount": "1", "Title": "Incorrect assignment of values in char enum", "Id": "35536146", "Score": "25", "Body": "<p>I was playing with enums and tried to reproduce some examples <a href=\"http://en.cppreference.com/w/cpp/language/enum\">from this</a> page. Initial examples worked as intended, however I got some interesting results with following code: </p>\n<pre><code>#include &lt;iostream&gt;\n\nenum num : char {\n    zero = '0',\n    one = '1',\n    two = '2',\n    three = '3',\n    four = '4',\n    five = '5',\n    six = '6'\n};\n\nint main()\n{\n    const char two = '2';\n    std::cout &lt;&lt; two &lt;&lt; std::endl;\n    std::cout &lt;&lt; num::two;\n    return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<blockquote>\n<p id=\"so_35536146_35536146_0\">2<br>\n  50</br></p>\n</blockquote>\n<p>I expected both outcomes to be the same, but the <code>num::two</code> seems to print some other value. Also this value doesn't changes<code>(50)</code>, so I assume this isn't a random/garbage value &amp; there is some sort of char/int parsing being done that I don't understand? Here is <a href=\"http://ideone.com/gSn9Md\">the ideone link</a>. </p>\n<p>I know that I can make it work by assigning like this <code>zero = 0</code>, without single quotes and it works. However, I want to know what is happening behind the scenes and how could I control what non-single digits value I can print via single quotes assignments.</p>\n", "Tags": "<c++><c++11><enums><type-conversion><implicit-conversion>", "OwnerUserId": "2648679", "AnswerCount": "5"}, "35538979": {"ParentId": "35536146", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This should actually go to the <code>char</code> overload now; unfortunately none of the compilers at issue implement <a href=\"http://wg21.link/cwg1601\" rel=\"noreferrer\">DR 1601</a>.</p>\n<p><a href=\"http://eel.is/c++draft/conv.prom#4\" rel=\"noreferrer\">[conv.prom]/4</a>:</p>\n<blockquote>\n<p id=\"so_35536146_35538979_0\">A prvalue of an unscoped enumeration type whose underlying type is\n  fixed ([dcl.enum]) can be converted to a prvalue of its underlying\n  type. </p>\n</blockquote>\n<p>This means <code>num</code> can be promoted to <code>char</code>.</p>\n<blockquote>\n<p id=\"so_35536146_35538979_1\">Moreover, if integral promotion can be applied to its underlying\n  type, a prvalue of an unscoped enumeration type whose underlying type\n  is fixed can also be converted to a prvalue of the promoted underlying\n  type.</p>\n</blockquote>\n<p>So <code>num</code> can be promoted to <code>int</code>, too.</p>\n<p>The relevant candidates are:</p>\n<pre><code>template &lt;class Traits &gt;\nbasic_ostream&lt;char,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;char,Traits&gt;&amp; os,\n                                        char ch );\ntemplate&lt;class charT, class Traits&gt;\nbasic_ostream&lt;charT, Traits&gt;&amp; basic_ostream&lt;charT, Traits&gt;::operator&lt;&lt;(int);\n</code></pre>\n<p>For both candidates, the first argument is an identity conversion and the second is a promotion. Both <code>num</code> to <code>char</code> and <code>num</code> to <code>int</code> have promotion rank.</p>\n<p>Pre-DR1601, these are equally as good, so the template/non-template tiebreaker comes in. The first one is a function template; the second one is a plain member function, so the second one wins.</p>\n<p>DR1601 added a rule that says:</p>\n<blockquote>\n<p id=\"so_35536146_35538979_2\">A conversion that promotes an enumeration whose underlying type is\n  fixed to its underlying type is better than one that promotes to the\n  promoted underlying type, if the two are different.</p>\n</blockquote>\n<p>This means that <code>num</code> to <code>char</code> is now better than <code>num</code> to <code>int</code>, so the first overload is now a better match and should be selected.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2016-03-15T21:46:53.753", "Id": "35538979", "Score": "19", "CreationDate": "2016-02-21T16:55:59.120", "LastActivityDate": "2016-03-15T21:46:53.753"}, "bq_ids": {"n4140": {"so_35536146_35536906_0": {"section_id": 5469, "quality": 0.7142857142857143, "length": 5}, "so_35536146_35538979_2": {"section_id": 640, "quality": 1.0, "length": 19}, "so_35536146_35538979_1": {"section_id": 24, "quality": 1.0, "length": 23}, "so_35536146_35538979_0": {"section_id": 24, "quality": 0.9333333333333333, "length": 14}, "so_35536146_35536263_0": {"section_id": 24, "quality": 1.0, "length": 37}}, "n3337": {"so_35536146_35536906_0": {"section_id": 5255, "quality": 0.7142857142857143, "length": 5}, "so_35536146_35538979_2": {"section_id": 21, "quality": 0.5789473684210527, "length": 11}, "so_35536146_35538979_1": {"section_id": 21, "quality": 1.0, "length": 23}, "so_35536146_35538979_0": {"section_id": 21, "quality": 0.9333333333333333, "length": 14}, "so_35536146_35536263_0": {"section_id": 21, "quality": 1.0, "length": 37}}, "n4659": {"so_35536146_35536906_0": {"section_id": 6903, "quality": 0.7142857142857143, "length": 5}, "so_35536146_35538979_2": {"section_id": 668, "quality": 1.0, "length": 19}, "so_35536146_35538979_1": {"section_id": 24, "quality": 1.0, "length": 23}, "so_35536146_35538979_0": {"section_id": 24, "quality": 0.9333333333333333, "length": 14}, "so_35536146_35536263_0": {"section_id": 24, "quality": 1.0, "length": 37}}}, "35536253": {"ParentId": "35536146", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Because the two call two different operator overloads:</p>\n<ul>\n<li><p>the first calls the non-member <code>operator&lt;&lt;</code> for <code>std::ostream</code> and <code>char</code>. This prints the character.</p></li>\n<li><p>The second example calls the member <code>operator&lt;&lt;</code> for <code>int</code> due to integer promotions, as explained by other answers.</p></li>\n</ul>\n", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2016-02-21T12:47:01.153", "Id": "35536253", "Score": "7", "CreationDate": "2016-02-21T12:42:00.897", "LastActivityDate": "2016-02-21T12:47:01.153"}});