post_cb({"33277347": {"Id": "33277347", "PostTypeId": "2", "Body": "<p>Here is my own attempt at an answer focusing strictly on portability.</p>\n<p>Standard-layout is defined in \u00a79.1[class.name]/7:</p>\n<blockquote>\n<p id=\"so_33069102_33277347_0\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base\n  classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p>By this definition <code>Result&lt;T&gt;</code> is standard-layout provided that:</p>\n<ul>\n<li>Both <code>error_type</code> and <code>T</code> are standard-layout. Note that this is <em>not</em> guaranteed for <code>std::exception_ptr</code>, though likely in practice.</li>\n<li><code>T</code> is not <code>ResultBase</code>.</li>\n</ul>\n<p>\u00a79.2[class.mem]/20 states that:</p>\n<blockquote>\n<p id=\"so_33069102_33277347_1\">A pointer to a standard-layout struct object, suitably converted using\n  a reinterpret_cast, points to its initial member (or if that member is\n  a bit-field, then to the unit in which it resides) and vice versa. [\n  Note: There might therefore be unnamed padding within a\n  standard-layout struct object, but not at its beginning, as necessary\n  to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>This implies that empty base class optimization is mandatory for standard-layout types. Assuming <code>Result&lt;T&gt;</code> does have standard-layout, <code>this</code> in <code>ResultBase</code> is guaranteed to point at the first field in <code>Result&lt;T&gt;</code>.</p>\n<p>9.5[class.union]/1 states:</p>\n<blockquote>\n<p id=\"so_33069102_33277347_2\">In a union, at most one of the non-static data members can be active\n  at any time, that is, the value of at most one of the non-static data\n  members can be stored in a union at any time. [...] Each non-static\n  data member is allocated as if it were the sole member of a struct.</p>\n</blockquote>\n<p>And additionaly \u00a73.10[basic.lval]/10:</p>\n<blockquote>\n<p id=\"so_33069102_33277347_3\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>This guarantees <code>reinterpret_cast&lt;const error_type*&gt;(this)</code> will yield a valid pointer to the <code>mError</code> field.</p>\n<p>All controversy aside, this technique looks portable. Just keep formal limitations in mind: <code>error_type</code> and <code>T</code> must be standard-layout, and <code>T</code> may not be type <code>ResultBase</code>.</p>\n<p>Side note: On most compilers (at least GCC, Clang and MSVC) non-standard-layout types will work as well. As long as <code>Result&lt;T&gt;</code> has predictable layout, error and result types are irrelevant.</p>\n", "LastActivityDate": "2015-10-22T09:10:52.563", "CommentCount": "0", "CreationDate": "2015-10-22T09:10:52.563", "ParentId": "33069102", "Score": "1", "OwnerUserId": "211387"}, "33197739": {"Id": "33197739", "PostTypeId": "2", "Body": "<p>To answer the question:\nIs that portable? </p>\n<p>No it is not even possible </p>\n<hr>\n<p><strong>Details:</strong></p>\n<p>This is <strong>not possible without at least <a href=\"https://stackoverflow.com/questions/5450159/type-erasure-techniques\">type erasure</a></strong> (wich do not need RTTI/dynamic_cast, but needs at least a virtual function). There are already working solutions for type erasure (<code>Boost.Any</code>)</p>\n<p>The reason is the following:</p>\n<ul>\n<li><p>You want to instantiate the class</p>\n<p><code>Result&lt;int&gt; r;</code></p></li>\n</ul>\n<p>Instantiating a template class means allowing the compiler deduce member variables size so it can allocating the object on the stack.</p>\n<p>However in your implementation:</p>\n<pre><code>private:\nunion { error_type mError; T mValue; };\n</code></pre>\n<p>You have a variable <code>error_type</code> wich seems you want to use in a polymorphic way. However if you fix the type at template instantiation you cannot later change it (a different type could have a different size! you could as well impose yourself to fix the size of the objects, but don't do that. Ugly and hackish).</p>\n<p>So you have 2 solutions, use virtual functions, or use error codes.</p>\n<p>It could be possible to do what you want, but you cannot do that:</p>\n<pre><code> Result&lt;int&gt; r;\n r.setError(...);\n</code></pre>\n<p>with the exact interface that you want.</p>\n<p>There are <strong>many possible solutions as long as you allow virtual functions</strong> and error codes, why exactly you don't want virtual functions here? If performance matters keep in mind that the cost of \"setting\" an error is as much as setting a pointer to a virtual class (if you do not have errors you don't need to resolve the Vtable, and anyway Vtable in templated code is likely to be optimized away most times).</p>\n<p>Also if you don't want to \"allocate\" error codes, you can pre-allocate them.</p>\n<p>You can do the following:</p>\n<pre><code>template&lt; typename Rtype&gt;\nclass Result{\n     //... your detail here\n\n\n    ~Result(){\n         if(error)\n             delete resultOrError.errorInstance;\n         else\n             delete resultOrError.resultValue;\n    }\n\nprivate:\n    union {\n        bool error;\n        std::max_align_t mAligner;\n    };\n    union uif \n    { \n        Rtype               *          resultValue;\n        PointerToVirtualErrorHandler  errorInstance;\n    } resultOrError;\n}\n</code></pre>\n<p>Where you have 1 result type, or 1 pointer to a virtual class with desired error. You check the boolean to see if currently you got an error or a result, and then you get corresponding value from the union. The virtual cost is paid only if you have an error, while for regular result you have only the penalty for the boolean check.</p>\n<p>Of course in the above solution I used a pointer to result because that allow generic result, if you are interested in basic data type results or POD structs with only basic data types then you can avoid using a pointer also for result.</p>\n<p><strong>Note</strong> in your case <code>std::exception_ptr</code> <strong>does already type erasure</strong>, but you lose some type info, to get again the missing type info you can implement yourself something similiar to <code>std::exception_ptr</code> but with enough virtual methods to allow safe casting to proper exceptions type.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-18T12:41:49.857", "Score": "2", "CreationDate": "2015-10-18T12:07:24.027", "ParentId": "33069102", "CommentCount": "3", "OwnerUserId": "1829943", "LastEditDate": "2017-05-23T12:29:55.913"}, "33069102": {"ViewCount": "333", "Body": "<p>I have a <code>Result&lt;T&gt;</code> template class that holds a union of some <code>error_type</code> and <code>T</code>. I would like to expose the common part (the error) in a base class without resorting to virtual functions.</p>\n<p>Here is my attempt:</p>\n<pre><code>using error_type = std::exception_ptr;\n\nstruct ResultBase\n{\n    error_type error() const\n    {\n        return *reinterpret_cast&lt;const error_type*&gt;(this);\n    }\n\nprotected:\n    ResultBase() { }\n};\n\ntemplate &lt;class T&gt;\nstruct Result : ResultBase\n{\n    Result() { new (&amp;mError) error_type(); }\n\n    ~Result() { mError.~error_type(); }\n\n    void setError(error_type error) { mError = error; }\n\nprivate:\n    union { error_type mError; T mValue; };\n};\n\nstatic_assert(std::is_standard_layout&lt;Result&lt;int&gt;&gt;::value, \"\");\n\nvoid check(bool condition) { if (!condition) std::terminate(); }\n\nvoid f(const ResultBase&amp; alias, Result&lt;int&gt;&amp; r)\n{\n    r.setError(std::make_exception_ptr(std::runtime_error(\"!\")));\n    check(alias.error() != nullptr);\n\n    r.setError(std::exception_ptr());\n    check(alias.error() == nullptr);\n}\n\nint main()\n{\n    Result&lt;int&gt; r;\n    f(r, r);\n}\n</code></pre>\n<p>(This is stripped down, see <a href=\"https://ideone.com/GJaaYb\">extended version</a> if unclear).</p>\n<p>The base class takes advantage of standard-layout to find the address of the error field at offset zero. Then it casts the pointer to <code>error_type</code> (assuming this really is the current dynamic type of the union).</p>\n<p>Am I right to assume this is portable? Or is it breaking some pointer aliasing rule?</p>\n<hr>\n<p>EDIT: My question was 'is this portable', but many commenters are puzzled by the use of inheritance here, so I will clarify.</p>\n<p>First, this is a toy example. Please don't take it too literally or assume there is no use for the base class.</p>\n<p>The design has three goals:</p>\n<ol>\n<li><em>Compactness</em>. Error and result are mutually exclusive, so they should be in a union.</li>\n<li><em>No runtime overhead</em>. Virtual functions are excluded (plus, holding vtable pointer conflicts with goal 1). RTTI also excluded.</li>\n<li><em>Uniformity</em>. The common fields of different <code>Result</code> types should be acessible via homogenous pointers or wrappers. For example: if instead of <code>Result&lt;T&gt;</code> we were talking about <code>Future&lt;T&gt;</code>, it should be possible to do <code>whenAny(FutureBase&amp; a, FutureBase&amp; b)</code> regardless of <code>a</code> / <code>b</code> concrete type.</li>\n</ol>\n<p>If willing to sacrifice (1), this becomes trivial. Something like:</p>\n<pre><code>struct ResultBase\n{\n    error_type mError;\n};\n\ntemplate &lt;class T&gt;\nstruct Result : ResultBase\n{\n    std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; mValue;\n};\n</code></pre>\n<p>If instead of goal (1) we sacrifice (2), it might look like this:</p>\n<pre><code>struct ResultBase\n{\n    virtual error_type error() const = 0;\n};\n\ntemplate &lt;class T&gt;\nstruct Result : ResultBase\n{\n    error_type error() const override { ... }\n\n    union { error_type mError; T mValue; };\n};\n</code></pre>\n<p>Again, the justification is not relevant. I just want to make sure original sample is conformant C++11 code.</p>\n</hr>", "AcceptedAnswerId": "33277347", "Title": "Accessing common part of an union from base class", "CreationDate": "2015-10-11T19:18:04.470", "Id": "33069102", "CommentCount": "26", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-10-18T05:20:15.530", "LastEditorUserId": "211387", "LastActivityDate": "2015-10-22T09:10:52.563", "Score": "7", "OwnerUserId": "211387", "Tags": "<c++><c++11><strict-aliasing>", "AnswerCount": "5"}, "33197977": {"Id": "33197977", "PostTypeId": "2", "Body": "<p>There is common mistake made by C++ programmers in believing that virtual functions causes higher usage of CPU and memory. I call it mistake even though I know using virtual functions costs memory and CPU. But, hand written replacements for virtual functions mechanism are in most cases much worst.</p>\n<p>You already said how to achieve the goal using virtual functions - just to repeat:</p>\n<pre><code>class ResultBase\n{\npublic:\n    virtual ~ResultBase() {}\n\n    virtual bool hasError() const = 0;\n\n    virtual std::exception_ptr error() const = 0;\n\nprotected:\n    ResultBase() {}\n};\n</code></pre>\n<p>And its implementation:</p>\n<pre><code>template &lt;class T&gt;\nclass Result : public ResultBase\n{\npublic:\n    Result(error_type error) { this-&gt;construct(error); }\n    Result2(T value) { this-&gt;construct(value); }\n\n    ~Result(); // this does not change\n    bool hasError() const override { return mHasError; }\n    std::exception_ptr error() const override { return mData.mError; }\n\n    void setError(error_type error); // similar to your original approach\n    void setValue(T value); // similar to your original approach\nprivate:\n    bool mHasError;\n    union Data\n    {\n        Data() {} // in this way you can use also Non-POD types\n        ~Data() {}\n\n        error_type mError;\n        T mValue;\n    } mData;\n\n    void construct(error_type error)\n    {\n        mHasError = true;\n        new (&amp;mData.mError) error_type(error);\n    }\n    void construct(T value)\n    {\n        mHasError = false;\n        new (&amp;mData.mValue) T(value);\n    }\n};\n</code></pre>\n<p>Look at full example <a href=\"https://ideone.com/F4IFAG\" rel=\"nofollow\">here</a>. As you can see there version with virtual functions is 3 times smaller and 7 (!) times faster - so, not so bad...</p>\n<p>Another benefit is that you might have \"cleaner\" design and no \"aliasing\"/\"aligning\" problems.</p>\n<p>If you really have some reason called compactness (I have no idea what it is) - with this very simple example you might implement virtual functions by hand (but why???!!!). Here you are:</p>\n<pre><code>class ResultBase;\nstruct ResultBaseVtable\n{\n    bool (*hasError)(const ResultBase&amp;);\n    error_type (*error)(const ResultBase&amp;);\n};\n\nclass ResultBase\n{\npublic:\n    bool hasError() const { return vtable-&gt;hasError(*this); }\n\n    std::exception_ptr error() const { return vtable-&gt;error(*this); }\n\nprotected:\n    ResultBase(ResultBaseVtable* vtable) : vtable(vtable) {}\nprivate:\n    ResultBaseVtable* vtable;\n};\n</code></pre>\n<p>And the implementation is identical to previous version with the differences showed below:</p>\n<pre><code>template &lt;class T&gt;\nclass Result : public ResultBase\n{\npublic:\n    Result(error_type error) : ResultBase(&amp;Result&lt;T&gt;::vtable)\n    {\n        this-&gt;construct(error);\n    }\n    Result(T value) : ResultBase(&amp;Result&lt;T&gt;::vtable)\n    {\n        this-&gt;construct(value);\n    }\n\nprivate:\n    static bool hasErrorVTable(const ResultBase&amp; result)\n    {\n        return static_cast&lt;const Result&amp;&gt;(result).hasError();\n    }\n    static error_type errorVTable(const ResultBase&amp; result)\n    {\n        return static_cast&lt;const Result&amp;&gt;(result).error();\n    }\n    static ResultBaseVtable vtable;\n};\n\ntemplate &lt;typename T&gt;\nResultBaseVtable Result&lt;T&gt;::vtable{\n    &amp;Result&lt;T&gt;::hasErrorVTable, \n    &amp;Result&lt;T&gt;::errorVTable,    \n};\n</code></pre>\n<p>The above version is identical in CPU/memory usage with \"virtual\" implementation (surprise)...</p>\n", "LastEditorUserId": "1829943", "LastActivityDate": "2015-10-18T12:48:51.123", "Score": "2", "CreationDate": "2015-10-18T12:34:04.897", "ParentId": "33069102", "CommentCount": "6", "OwnerUserId": "1463922", "LastEditDate": "2015-10-18T12:48:51.123"}, "33071615": {"Id": "33071615", "PostTypeId": "2", "Body": "<p>Abstract base class, two implementations, for error and data, both with multiple inheritance, and use RTTI or an <code>is_valid()</code> member to tell which it is at runtime.</p>\n", "LastActivityDate": "2015-10-12T00:32:03.520", "CommentCount": "1", "CreationDate": "2015-10-12T00:32:03.520", "ParentId": "33069102", "Score": "1", "OwnerUserId": "4474419"}, "bq_ids": {"n4140": {"so_33069102_33277347_3": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_33069102_33277347_2": {"length": 28, "quality": 1.0, "section_id": 5913}, "so_33069102_33277347_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}}, "n3337": {"so_33069102_33277347_3": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_33069102_33277347_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}, "so_33069102_33277347_2": {"length": 28, "quality": 1.0, "section_id": 5685}}, "n4659": {"so_33069102_33277347_3": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_33069102_33277347_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}, "so_33069102_33277347_2": {"length": 23, "quality": 0.8214285714285714, "section_id": 7404}}}, "33197627": {"Id": "33197627", "PostTypeId": "2", "Body": "<pre><code>union {\n    error_type mError;\n    T mValue;\n};\n</code></pre>\n<p>Type T is not guaranteed to work with unions, for example it could have a non trivial constructor. some info about unions and constructors: <a href=\"https://stackoverflow.com/questions/321351/initializing-a-union-with-a-non-trivial-constructor\">Initializing a union with a non-trivial constructor</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-18T11:50:17.190", "Score": "1", "CreationDate": "2015-10-18T11:50:17.190", "ParentId": "33069102", "CommentCount": "0", "OwnerUserId": "1756939", "LastEditDate": "2017-05-23T11:58:26.423"}});