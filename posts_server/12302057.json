post_cb({"bq_ids": {"n4140": {"so_12302057_12302355_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_12302057_12302355_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_12302057_12302355_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "45767547": {"Id": "45767547", "PostTypeId": "2", "Body": "<p>Since you wanted to see a valid DCLP C++11 implementation, here is one.  </p>\n<p>The behavior is fully thread-safe and identical to <code>GetInstance()</code> in Grizzly's answer.</p>\n<pre><code>std::mutex mtx;\nstd::atomic&lt;MySingleton *&gt; instance_p{nullptr};\n\nMySingleton* GetInstance()\n{\n    auto *p = instance_p.load(std::memory_order_acquire);\n\n    if (!p)\n    {\n        std::lock_guard&lt;std::mutex&gt; lck{mtx};\n\n        p = instance_p.load(std::memory_order_relaxed);\n        if (!p)\n        {\n            p = new MySingleton;\n            instance_p.store(p, std::memory_order_release);\n        }\n    }\n\n    return p;\n}\n</code></pre>\n", "LastEditorUserId": "6651824", "LastActivityDate": "2017-08-20T00:00:38.840", "Score": "2", "CreationDate": "2017-08-19T04:09:11.360", "ParentId": "12302057", "CommentCount": "4", "OwnerUserId": "6651824", "LastEditDate": "2017-08-20T00:00:38.840"}, "12302355": {"Id": "12302355", "PostTypeId": "2", "Body": "<p>Simply use a static local variable for lazily initialized Singletons, like so:</p>\n<pre><code>MySingleton* GetInstance() {\n  static MySingleton instance;\n  return &amp;instance; \n}\n</code></pre>\n<p>The (C++11) standard already guarantees that static variables are initialized in a threadsafe manner and it seems likely that the implementation of this at least as robust and performant as anything you'd write yourself.</p>\n<p>The threadsafety of the initialization can be found in \u00a76.7.4 of the (C++11) standard:</p>\n<blockquote>\n<p id=\"so_12302057_12302355_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n", "LastActivityDate": "2012-09-06T14:28:03.290", "CommentCount": "5", "CreationDate": "2012-09-06T14:28:03.290", "ParentId": "12302057", "Score": "16", "OwnerUserId": "201270"}, "12302057": {"ViewCount": "4117", "Body": "<p>I have read many questions considering thread-safe double checked locking (for singletons or lazy init). In some threads, the answer is that the pattern is entirely broken, others suggest a solution.</p>\n<p>So my question is: Is there a way to write a fully thread-safe double checked locking pattern in C++? If so, how does it look like.</p>\n<p>We can assume C++11, if that makes things easier. As far as I know, C++11 improved the memory model which could yield the needed improvements.</p>\n<p>I do know that it is possible in Java by making the double-check guarded variable volatile. Since C++11 borrowed large parts of the memory model from the one of Java, so I think it could be possible, but how?</p>\n", "AcceptedAnswerId": "12302355", "Title": "C++11: Safe double checked locking for lazy initialization. Possible?", "CreationDate": "2012-09-06T14:10:48.853", "Id": "12302057", "CommentCount": "9", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-09-06T14:18:25.340", "LastEditorUserId": "1408611", "LastActivityDate": "2017-08-20T00:00:38.840", "Score": "10", "OwnerUserId": "1408611", "Tags": "<c++><c++11><thread-safety><double-checked-locking>", "AnswerCount": "2"}});