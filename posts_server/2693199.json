post_cb({"bq_ids": {"n4140": {"so_2693199_2693199_3": {"length": 33, "quality": 0.8918918918918919, "section_id": 409}, "so_2693199_2693199_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 6002}}, "n3337": {"so_2693199_2693199_3": {"length": 35, "quality": 0.9459459459459459, "section_id": 400}, "so_2693199_2693199_1": {"length": 19, "quality": 0.95, "section_id": 388}, "so_2693199_2693199_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 5770}, "so_2693199_2693199_0": {"length": 21, "quality": 0.7, "section_id": 355}}, "n4659": {"so_2693199_2693199_3": {"length": 30, "quality": 0.8108108108108109, "section_id": 427}, "so_2693199_2693199_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 7501}}}, "2693450": {"Id": "2693450", "PostTypeId": "2", "Body": "<p>First of all, the Standard is ambivalent on the use of \"name\", i think. First, it says (added the other forms of names below, as corrected by the C++0x draft)</p>\n<blockquote>\n<p id=\"so_2693199_2693450_0\">A name is a use of an identi\ufb01er (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).</p>\n</blockquote>\n<p>Then in parts of the Standard it uses \"name\" as if it would <em>contain</em> qualifier portions like <code>foo::bar</code>. And in other parts, it excludes such portions from a \"name\". One paragraph even says that a name prefixed by <code>::</code> refers to a global name. But in our example, <code>bar</code> was prefixed by such a token, even though its intentionally not referring to a global name. </p>\n<p>The construct in our example is not a name, i think, but rather two names, one qualifying the other. A destructor is referenced by the construct <code>~ class-name</code> (see <code>3.4.5/3</code> and <code>3.4.3/6</code>). Such a construct consists of a <code>~</code> token and a name, refering to the constructor's class. It's conventional to call it the destructor's \"name\" (just like the Standard at <code>3.4.3.1/2</code> talks about a \"constructor name\") - but pedantically, it isn't a name. </p>\n<p>So, if you are pedantical, you would say that a destructor does not have an own name, but rather special mechanisms are used for referring to it. Likewise for constructors, special constructs are used to refer to them (otherwise, you couldn't declare a constructor out of class - the declaration has to refer to it!). And in C++0x using declarations have to be able to refer to them too, using the special constructs provided (see <code>3.4.3.1/2</code> for how you can refer to a constructor). </p>\n<p>The destructor lookup is quite convoluted, and has quite a few bugs in the Standard. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#399\" rel=\"noreferrer\">this issue report</a> for further details. </p>\n", "LastActivityDate": "2010-04-22T18:34:55.953", "CommentCount": "2", "CreationDate": "2010-04-22T18:34:55.953", "ParentId": "2693199", "Score": "8", "OwnerUserId": "34509"}, "2693199": {"ViewCount": "625", "Body": "<p>Do class destructors have names in the pedantic sense according to the Standard?</p>\n<p>Recall that constructors explicitly do not have names:</p>\n<h2>12.1.1 :</h2>\n<blockquote>\n<p id=\"so_2693199_2693199_0\">Constructors do not have names. A\n  special declarator syntax using an\n  optional sequence of\n  function-specifiers (7.1.2) followed\n  by the constructor\u2019s class name\n  followed by a parameter list is used\n  to declare or define the constructor.\n  In such a declaration, optional\n  parentheses around the constructor\n  class name are ignored.</p>\n</blockquote>\n<p>The Standard does not explicitly state that destructors do or do not have names, but there are many references to how to refer to and declare a destructor using special language, none of which refer directly to the destructor's name.  The issue seems to be skirted around in various places:</p>\n<h2>12.4.1:</h2>\n<blockquote>\n<p id=\"so_2693199_2693199_1\">A special declarator syntax using an\n  optional function-specifier (7.1.2)\n  followed by ~ followed by the\n  destructor\u2019s class name followed by an\n  empty parameter list is used to\n  declare the destructor in a class\n  definition.</p>\n</blockquote>\n<h2>5.2.4.1:</h2>\n<blockquote>\n<p id=\"so_2693199_2693199_2\">The use of a pseudo-destructor-name\n  after a dot . or arrow -&gt; operator\n  represents the destructor for the\n  non-class type named by type-name. The\n  result shall only be used as the\n  operand for the function call operator\n  (), and the result of such a call has\n  type void. The only effect is the\n  evaluation of the postfix-expression\n  before the dot or arrow.</p>\n</blockquote>\n<h2>12.4.12 :</h2>\n<blockquote>\n<p id=\"so_2693199_2693199_3\">In an explicit destructor call, the\n  destructor name appears as a ~\n  followed by a type-name that names the\n  destructor\u2019s class type. The\n  invocation of a destructor is subject\n  to the usual rules for member\n  functions (9.3), that is, if the\n  object is not of the destructor\u2019s\n  class type and not of a class derived\n  from the destructor\u2019s class type, the\n  program has undefined behavior (except\n  that invoking delete on a null pointer\n  has no effect).</p>\n</blockquote>\n<p>This last case (12.4.12) seems to be the most direct reference to the destructor's name, but it still avoids saying that the destructor has a name, and is quite ambigious about this.  12.4.12 could be interpreted as \"blah is the destructor's name\" or as \"destructors don't have names, but you can refer to the destructor as blah.\"</p>\n<p>So, do destructors have names or not?</p>\n", "AcceptedAnswerId": "2693450", "Title": "Do Destructors Have Names According To The Standard?", "CreationDate": "2010-04-22T17:55:06.930", "Id": "2693199", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-09T17:59:06.463", "LastEditorUserId": "3043", "LastActivityDate": "2011-12-09T17:59:06.463", "Score": "5", "OwnerUserId": "241536", "Tags": "<c++>", "AnswerCount": "1"}});