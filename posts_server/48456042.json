post_cb({"bq_ids": {"n4140": {"so_48456042_48464354_2": {"length": 32, "quality": 0.7441860465116279, "section_id": 5504}}, "n3337": {"so_48456042_48464354_2": {"length": 32, "quality": 0.7441860465116279, "section_id": 5290}}, "n4659": {"so_48456042_48464354_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 6924}, "so_48456042_48464354_2": {"length": 43, "quality": 1.0, "section_id": 6938}}}, "48456042": {"ViewCount": "124", "Body": "<p>This code can be used just fine on gcc , but it does not work on mac OS with clang \nThe code is utilizing recursive templates via inheritance of next type in the typelist \nThink of a Entity =&gt; Head and Entities... =&gt; Tail...</p>\n<pre><code>template&lt;typename ...Entities&gt;\n    struct GenericBidderCacheLoader;\n\n    template&lt;typename Entity, typename ...Entities&gt;\n    struct GenericBidderCacheLoader&lt;Entity, Entities ...&gt; :  GenericBidderCacheLoader&lt;Entities ...&gt; {\n        using GenericBidderCacheLoader&lt;Entities ...&gt;::retrieve;\n\n        template&lt;typename Config&gt;\n        GenericBidderCacheLoader(const Config &amp;config): GenericBidderCacheLoader&lt;Entities...&gt;(config), entity(config)\n        {}\n        void load() noexcept(false) {\n           entity.load();\n           GenericBidderCacheLoader&lt;Entities...&gt;::load();\n        }\n\n        template&lt;typename T, typename... Keys&gt;\n        decltype(std::declval&lt;Entity&gt;().retrieve(std::declval&lt;T&amp;&gt;(),std::declval&lt;Keys&gt;()...), bool())\n        retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n            return  entity.template retrieve(t, std::forward&lt;Keys&gt;(keys)...);\n        }\n\n        Entity entity;\n    };\n\ntemplate&lt;typename Entity&gt;\n    struct GenericBidderCacheLoader&lt;Entity&gt; {\n\n\n        template&lt;typename Config&gt;\n        GenericBidderCacheLoader(const Config &amp;config): entity(config)\n        {}\n        void load() noexcept(false) {\n            entity.load();\n        }\n\n        template&lt;typename T, typename... Keys&gt;\n        decltype(std::declval&lt;Entity&gt;().retrieve(std::declval&lt;T&amp;&gt;(), std::declval&lt;Keys&gt;()...), bool())\n        retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n            return  entity.template retrieve(t, std::forward&lt;Keys&gt;(keys)...);\n        }\n\n        Entity entity;\n    };\n</code></pre>\n<p>Basically GenericBidderCacheLoader holds a typeist , and inheritance model works like that GenericBidderCacheLoad&lt;FirstType&gt; is derived from GenericBidderCacheLoad&lt;SecondType&gt; which is derived from GenericBidderCacheLoad&lt;ThirdType&gt; Which is very common if you want to build a typelist with delegated functionality .</p>\n<p>Use case for GenericBidderCacheLoader type is here:</p>\n<pre><code>using CacheLoader  =  vanilla::GenericBidderCacheLoader&lt;RefererEntity&lt;&gt;, ICOCampaignEntity&lt;&gt;, AdDataEntity&lt;BidderConfig&gt;&gt;;   \n...\n...\nCacheLoader cacheLoader(config);    \n //Return from each lambda becomes input for next lambda in the tuple of functions\nauto retrieve_referer_f = [&amp;cacheLoader](const std::string&amp; ref, auto&amp;&amp; ...) {\n    Referer referer;\n    if(!cacheLoader.retrieve(referer,ref)) {\n        return boost::optional&lt;uint32_t&gt;();\n    }\n    return boost::optional&lt;uint32_t&gt;(referer.ref_id);\n};\n\nauto retrieve_ico_campaign_f = [&amp;cacheLoader](boost::optional&lt;uint32_t&gt; ref_id, auto&amp;&amp; ...)  {\n    std::vector&lt;ICOCampaign&gt; ico_campains;\n    if (!cacheLoader.retrieve(ico_campains,*ref_id)) {\n        return boost::optional&lt;decltype(ico_campains)&gt;();\n    }\n    return boost::optional&lt;decltype(ico_campains)&gt;(ico_campains);\n};\n\n\nauto retrieve_campaign_ads_f = [&amp;cacheLoader](boost::optional&lt;std::vector&lt;ICOCampaign&gt;&gt; campaigns, auto &amp;&amp; req, auto &amp;&amp; imp)  {\n    std::vector&lt;Ad&gt; retrieved_cached_ads;\n    for (auto &amp;campaign : *campaigns) {\n        if (!cacheLoader.retrieve(retrieved_cached_ads, campaign.campaign_id, imp.banner.get().w, imp.banner.get().h)) {\n            continue;\n        }\n        auto budget_bid = selector.authorize(cacheLoader.get_entity&lt;CampaignCache&lt;BidderConfig&gt;&gt;(), campaign.campaign_id);\n        std::transform(std::begin(retrieved_cached_ads),\n                       std::end(retrieved_cached_ads),\n                       std::begin(retrieved_cached_ads), [budget_bid](Ad &amp; ad){\n                    ad.auth_bid_micros = std::min(budget_bid, ad.max_bid_micros);\n                    return ad;\n                });\n    }\n    if ( retrieved_cached_ads.empty() ) {\n        return boost::optional&lt;decltype(retrieved_cached_ads)&gt;();\n    }\n    return boost::optional&lt;decltype(retrieved_cached_ads)&gt;(retrieved_cached_ads);\n};\n</code></pre>\n<p>Error message :</p>\n<pre><code>error: no matching member function for call to\n      'retrieve'\n        if (!cacheLoader.retrieve(ico_campains,*ref_id)) {\n             ~~~~~~~~~~~~^~~~~~~~\ngeneric_bidder_cache_loader.hpp:42:9: note: candidate template ignored: substitution failure [with\n      T = std::__1::vector&lt;ICOCampaign, std::__1::allocator&lt;ICOCampaign&gt; &gt;, Keys = &lt;unsigned int &amp;&gt;]: non-const lvalue reference to type 'Referer'\n      cannot bind to a value of unrelated type 'std::__1::vector&lt;ICOCampaign, std::__1::allocator&lt;ICOCampaign&gt; &gt;'\n        retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n</code></pre>\n<p>In case of GCC </p>\n<pre><code>using GenericBidderCacheLoader&lt;Entities...&gt;::retrieve \n</code></pre>\n<p>Helped GCC to see those functions defined in all base classes , but clang gives up can't see them ?\nIdeally it should work as following , when substitution fails SFINAE it should be able to see function in any of the derived, base-I , base-II , base-III classes.</p>\n<p>Full implementation can be found in the temporary branch on github here \n<a href=\"https://github.com/venediktov/vanilla-rtb/tree/ico_bidder20171217\" rel=\"nofollow noreferrer\">https://github.com/venediktov/vanilla-rtb/tree/ico_bidder20171217</a></p>\n<p><a href=\"https://github.com/venediktov/vanilla-rtb/blob/ico_bidder20171217/examples/ico_campaign_bidder/ico_campaign_bidder_test.cpp\" rel=\"nofollow noreferrer\">https://github.com/venediktov/vanilla-rtb/blob/ico_bidder20171217/examples/ico_campaign_bidder/ico_campaign_bidder_test.cpp</a></p>\n<p><a href=\"https://github.com/venediktov/vanilla-rtb/blob/ico_bidder20171217/rtb/datacache/generic_bidder_cache_loader.hpp\" rel=\"nofollow noreferrer\">https://github.com/venediktov/vanilla-rtb/blob/ico_bidder20171217/rtb/datacache/generic_bidder_cache_loader.hpp</a></p>\n<p>I also tried to do recursion to help Clang to see those recursive instantiated class functions </p>\n<pre><code>template&lt;typename T, typename... Keys&gt;\nusing retrieve_type = decltype(std::declval&lt;Entity&gt;().retrieve(std::declval&lt;T&amp;&gt;(), std::declval&lt;Keys&gt;()...)) ;\n\n      template&lt;typename T, typename... Keys&gt;\n      typename std::enable_if&lt;std::is_same&lt;retrieve_type&lt;T,Keys...&gt;,bool&gt;::value,bool&gt;::type\n        retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n            return  entity.template retrieve(t, std::forward&lt;Keys&gt;(keys)...);\n        }\n\n        template&lt;typename T, typename... Keys&gt;\n        typename std::enable_if&lt;std::is_same&lt;typename GenericBidderCacheLoader&lt;Entities ...&gt;::template retrieve_type&lt;T,Keys...&gt;,bool&gt;::value,bool&gt;::type\n        retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n            return  GenericBidderCacheLoader&lt;Entities ...&gt;::retrieve(t, std::forward&lt;Keys&gt;(keys)...);\n        }\n</code></pre>\n<p>But it only helped clang to see the second in the typelist but not  the third , it almost the case that I had to recurse to the final type from the top level .</p>\n", "Title": "Base class C++14 template functions are not visible in clang on Mac os ( recursive templates)", "CreationDate": "2018-01-26T05:03:34.483", "LastActivityDate": "2018-01-27T18:29:47.567", "CommentCount": "4", "LastEditDate": "2018-01-26T08:35:07.763", "PostTypeId": "1", "LastEditorUserId": "2264070", "Id": "48456042", "Score": "1", "OwnerUserId": "2264070", "Tags": "<c++><templates><c++14><sfinae><llvm-clang>", "AnswerCount": "2"}, "48464354": {"Id": "48464354", "PostTypeId": "2", "Body": "<p>This question lacks a minimal, complete, and verifiable example. So I haven't tested OP's code. However, by reading the quoted code piece and the error message, I constructed a minimal example which can make the different behavior between g++ and clang++ clearer:</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;class U&gt;\nstruct Foo\n{\n    template&lt;class V&gt;\n    decltype(std::declval&lt;U&gt;().echo_dumb(std::declval&lt;V&gt;()))\n    dumb(V const &amp;v) {\n        u.echo_dumb(v);\n    }\n    U u;\n};\n\ntemplate&lt;class T, class U&gt;\nstruct Bar\n    : public Foo&lt;U&gt;\n{\n    using Foo&lt;U&gt;::dumb;\n\n    template&lt;class V&gt;\n    decltype(std::declval&lt;T&gt;().echo_dumb(std::declval&lt;V&gt;()))\n    dumb(V const &amp;v) {\n        t.echo_dumb(v);\n    }\n    T t;\n};\n\nstruct A { void echo_dumb(A const &amp;) {} };\nstruct B { void echo_dumb(B const &amp;) {} };\n\nint main() {\n    Bar&lt;A, B&gt; bar;\n    bar.dumb(A{}); // ok for everyone\n    bar.dumb(B{}); // error for clang++, ok for g++\n}\n</code></pre>\n<p>Thus the problem becomes \"what is the semantics of <code>using</code> declaration ?\".</p>\n<p>After reading some C++ standard pages, I think clang++ has correctly rejected this code, because:</p>\n<p><a href=\"http://www.eel.is/c++draft/namespace.udecl\" rel=\"nofollow noreferrer\">[namespace.udecl]</a></p>\n<blockquote>\n<p id=\"so_48456042_48464354_0\">The set of declarations introduced by the using-declarator is found by performing qualified name lookup ([basic.lookup.qual], [class.member.lookup]) for the name in the using-declarator, excluding functions that are hidden as described below.</p>\n<p id=\"so_48456042_48464354_1\">...</p>\n<p id=\"so_48456042_48464354_2\">When a using-declarator brings declarations from a base class into a derived class, member functions and member function templates in the derived class override and/or hide member functions and member function templates with the same name, parameter-type-list, cv-qualification, and ref-qualifier (if any) in a base class (rather than conflicting). Such hidden or overridden declarations are excluded from the set of declarations introduced by the using-declarator.</p>\n</blockquote>\n<p>Since 2 <code>dumb</code> function have exactly the same parameter-type-list, the one introduced by <code>using</code> declaration is hidden and will not be included.</p>\n<p>If the <code>dumb</code> in <code>Foo</code> has signature <code>dumb(V const &amp;v, int = 0)</code>, then both g++ and clang++ accept this code. </p>\n<p>What is interesting is, if we replace 2 <code>decltype(std::declval&lt;U&gt;().echo_dumb(std::declval&lt;V&gt;()))</code> by simply a <code>void</code>, then both g++ and clang++ correctly reject it, with message <em>no matching function</em>. So it seems the <code>decltype</code> part in the return part confuses g++ compiler.</p>\n", "LastActivityDate": "2018-01-26T15:25:20.693", "Score": "2", "CreationDate": "2018-01-26T15:25:20.693", "ParentId": "48456042", "CommentCount": "4", "OwnerUserId": "8605791"}, "48473722": {"Id": "48473722", "PostTypeId": "2", "Body": "<p>This is not an answer , I just wanted to show how I fixed my code based on the answer from @liliscent </p>\n<pre><code>        template&lt;typename T, typename... Keys&gt;\n        bool retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n            auto tuple = std::make_tuple(std::forward&lt;Keys&gt;(keys)...);\n            return  this-&gt;retrieve(t, tuple, std::make_index_sequence&lt;std::tuple_size&lt;decltype(tuple)&gt;::value&gt;());\n        }\n\n        template&lt;typename T, typename Tuple, std::size_t... Idx&gt;\n        decltype(std::declval&lt;Entity&gt;().retrieve(std::declval&lt;T&amp;&gt;(),std::get&lt;Idx&gt;(std::declval&lt;Tuple&gt;())...), bool())\n        retrieve(T &amp; t, Tuple&amp;&amp; tuple, std::index_sequence&lt;Idx...&gt;, Entity* = 0) {\n            return  entity.template retrieve(t, std::get&lt;Idx&gt;(std::forward&lt;Tuple&gt;(tuple))...);\n        }\n</code></pre>\n<p>New code now compiles with both gcc and clang . I would be happy If anyone reviewed my change. This code is an open-source project available on GitHub. The links to the files in my original question are outdated if anyone wants to see the original problem please click on revision history.</p>\n<p>And with sizeof... operator it's even shorter </p>\n<pre><code>    template&lt;typename T, typename... Keys&gt;\n    bool retrieve(T &amp; t, Keys&amp;&amp; ... keys) {\n        return  this-&gt;retrieve(t, std::make_tuple(std::forward&lt;Keys&gt;(keys)...),\n                                  std::make_index_sequence&lt;sizeof...(keys)&gt;()\n                               );\n    }\n\n    template&lt;typename T, typename Tuple, std::size_t... Idx&gt;\n    decltype(std::declval&lt;Entity&gt;().retrieve(std::declval&lt;T&amp;&gt;(),std::get&lt;Idx&gt;(std::declval&lt;Tuple&gt;())...), bool())\n    retrieve(T &amp; t, Tuple&amp;&amp; tuple, std::index_sequence&lt;Idx...&gt;, Entity* = 0) {\n        return  entity.template retrieve(t, std::get&lt;Idx&gt;(std::forward&lt;Tuple&gt;(tuple))...);\n    }\n</code></pre>\n", "LastEditorUserId": "2264070", "LastActivityDate": "2018-01-27T18:29:47.567", "Score": "0", "CreationDate": "2018-01-27T07:43:45.003", "ParentId": "48456042", "CommentCount": "0", "OwnerUserId": "2264070", "LastEditDate": "2018-01-27T18:29:47.567"}});