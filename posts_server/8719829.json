post_cb({"8719829": {"CommentCount": "4", "AcceptedAnswerId": "8720166", "CreationDate": "2012-01-03T22:56:47.843", "LastActivityDate": "2012-01-04T01:19:16.690", "PostTypeId": "1", "ViewCount": "442", "FavoriteCount": "5", "Title": "Should the implementation guard itself against comma overloading?", "Id": "8719829", "Score": "26", "Body": "<p>For example <code>uninitialized_copy</code> is defined in the standard as:</p>\n<blockquote>\n<p id=\"so_8719829_8719829_0\"><em>Effects:</em></p>\n<pre><code>for (; first != last; ++result, ++first)\n  ::new (static_cast&lt;void*&gt;(&amp;*result))\n    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);\n</code></pre>\n</blockquote>\n<p>If understood literally, this is a requirement to call <code>operator ,(ForwardIterator, InputIterator)</code>. And in fact this code prints <code>Hello world!</code> ten times:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nnamespace N {     \n    struct X : iterator&lt;forward_iterator_tag, int&gt; {\n        pointer _p;\n        X(pointer p) : _p(p) {}\n        X&amp; operator++() { ++_p; return *this; }\n        X operator++(int) { X r(*this); ++_p; return r; }\n        reference operator*() const { return *_p; }\n        pointer operator-&gt;() const { return _p; }\n    };\n\n    bool operator==(X a, X b) { return a._p == b._p; }\n    bool operator!=(X a, X b) { return !(a == b); }\n\n    void operator,(X a, X b) { cout &lt;&lt; \"Hello world!\\n\"; }\n}\n\nint a[10], b[10];\n\nint main()\n{\n    using N::X;\n    uninitialized_copy(X(a), X(a+10), X(b));\n}\n</code></pre>\n<p>However, for most other algorithms the standard gives the description in prose. E.g. for <code>copy</code> there's no requirement for operator <code>,</code> to be called. But if I change</p>\n<pre><code>    uninitialized_copy(X(a), X(a+10), X(b));\n</code></pre>\n<p>in the above code to</p>\n<pre><code>    copy(X(a), X(a+10), X(b));\n</code></pre>\n<p>then <code>Hello world!</code> is <em>still printed ten times</em>. The said results are observable in both, VS2005 and GCC 4.3.4. However, if I write</p>\n<pre><code>    mismatch(X(a), X(a+10), X(b));\n</code></pre>\n<p>instead, then VS2005 prints <code>Hello world!</code> ten times but GCC does not.</p>\n<p>Unfortunately I couldn't find where the standard prohibits <code>operator,</code> overloading for iterator types. On the contrary, it prohibits the implementations to do calls as above [global.functions]:</p>\n<blockquote>\n<p id=\"so_8719829_8719829_1\">Unless otherwise specified, global and non-member functions in the standard library shall not use functions from another namespace which are found through argument-dependent name lookup (3.4.2).</p>\n</blockquote>\n<p>So who of the four parties is wrong: MSVC, GCC, ISO or me? (Choose one)</p>\n", "Tags": "<c++><language-lawyer><comma-operator>", "OwnerUserId": "277176", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8719829_8719829_1": {"section_id": 6339, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_8719829_8719829_1": {"section_id": 6096, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_8719829_8719829_1": {"section_id": 7849, "quality": 0.7058823529411765, "length": 12}}}, "8720166": {"ParentId": "8719829", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Nice catch. I think in my humble opinion that the ISO committee's intention was that \u00a73.4.2 should be followed. The suggested semantics of <code>uninitialized_copy</code> is wrongly interpreted as if requiring the comma to be called. And implementations should not be using it (I'd report a bug to gcc btw).</p>\n", "OwnerUserId": "55935", "LastEditorUserId": "560648", "LastEditDate": "2012-01-04T01:19:16.690", "Id": "8720166", "Score": "3", "CreationDate": "2012-01-03T23:32:34.013", "LastActivityDate": "2012-01-04T01:19:16.690"}});