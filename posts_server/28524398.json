post_cb({"28524398": {"CommentCount": "3", "AcceptedAnswerId": "28524697", "CreationDate": "2015-02-15T08:43:29.390", "LastActivityDate": "2015-02-18T14:24:07.630", "PostTypeId": "1", "ViewCount": "144", "FavoriteCount": "1", "Title": "Prevent writing clone method for each subclass", "Id": "28524398", "Score": "5", "Body": "<p>Here is my case:</p>\n<pre><code>class A\n{\npublic:\n    virtual A* clone() = 0;\n};\n\nclass B : public A\n{\n    virtual B* clone() override\n    { \n        return new B();\n    }\n};\n</code></pre>\n<p>In my code now 100% of sublcasses of <code>A</code> just implement the <code>clone</code> method exactly the same way only for class <code>D</code> I have return type <code>D</code> and I create object of <code>D</code> of course.</p>\n<p>How can I prevent this duplication? What patterns or tricks can help? </p>\n<p>I have thought to use <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\">CRTP pattern</a>, but it uses templates, and my function is virtual. As we understand templates and virtual functions are incompatible.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Non-virtual_interface_pattern\">NVI pattern</a> does not work either, as return type of clone methods are different.</p>\n", "Tags": "<c++>", "OwnerUserId": "163394", "AnswerCount": "1"}, "28524697": {"ParentId": "28524398", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>[class.virtual]/8:</p>\n<blockquote>\n<p id=\"so_28524398_28524697_0\">If the class type in the covariant return type of <code>D::f</code> differs from\n  that of <code>B::f</code>, the class type in the return  type of <code>D::f</code> shall be\n  complete at the point of declaration of <code>D::f</code> or shall be the class\n  type <code>D</code>.</p>\n</blockquote>\n<p>So CRTP cannot work perfectly, since the template argument which refers to the derived class would be an incomplete type, and thus covariant return types are difficult to simulate.</p>\n<p>However, here's a try:</p>\n<pre><code>class A\n{\npublic:\n    virtual A* clone() = 0;\n};\n\nnamespace detail {\n    template &lt;typename T&gt;\n    struct Cloner : A {\n        using A::A; // For constructors\n        virtual A* clone() override {return new T;}\n    };\n}\n\ntemplate &lt;typename T&gt;\nstruct Cloner : detail::Cloner&lt;T&gt; {\n    using detail::Cloner&lt;T&gt;::Cloner; // For constructors\n\n    // For callers \n    template &lt;class=void&gt;\n    T* clone() {return static_cast&lt;T*&gt;(detail::Cloner&lt;T&gt;::clone());}\n};\n\nclass B : public Cloner&lt;B&gt;\n{\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4b795df8721877a8\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n<p>Note two things:</p>\n<ul>\n<li><p>The overload of <code>clone</code> returning a pointer to the derived class type is a function template. That's so we don't override the virtual function <code>clone</code>: If we would, the code would be ill-formed, because the return type is not covariant (see above).</p></li>\n<li><p>Because <code>clone</code> is a function template, to ensure that it get's called at all, we can to let it hide the virtual <code>clone</code> function. That's achieved via inheritance: Names in derived classes hide names in base classes. Thus if we call through a <code>B</code>-pointer/reference, we get the appropriate return type (<code>B*</code>), since the name is looked up in <code>::Cloner</code> before <code>detail::Cloner</code>.</p></li>\n</ul>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-02-18T14:24:07.630", "Id": "28524697", "Score": "3", "CreationDate": "2015-02-15T09:24:55.363", "LastActivityDate": "2015-02-18T14:24:07.630"}, "bq_ids": {"n4140": {"so_28524398_28524697_0": {"section_id": 7009, "quality": 1.0, "length": 15}}, "n3337": {"so_28524398_28524697_0": {"section_id": 6755, "quality": 0.8, "length": 12}}, "n4659": {"so_28524398_28524697_0": {"section_id": 8506, "quality": 1.0, "length": 15}}}});