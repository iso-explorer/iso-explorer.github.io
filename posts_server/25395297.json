post_cb({"25395297": {"ViewCount": "496", "Body": "<p>Is the following safe?</p>\n<pre><code>*(new int);\n</code></pre>\n<p>I get output as <code>0</code>.</p>\n", "Title": "What happens if you dereference `new int`?", "CreationDate": "2014-08-20T01:09:25.090", "LastActivityDate": "2014-08-23T18:06:30.603", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-21T05:52:34.247", "LastEditorUserId": "1708801", "Id": "25395297", "Score": "4", "OwnerUserId": "3958332", "Tags": "<c++><initialization><undefined-behavior>", "AnswerCount": "4"}, "25395346": {"Id": "25395346", "PostTypeId": "2", "Body": "<p>It\u2019s undefined because you\u2019re reading an object with an indeterminate value. The expression <code>new int()</code> uses zero-initialisation, guaranteeing a zero value, while <code>new int</code> (without parentheses) uses default-initialisation, giving you an indeterminate value. This is effectively the same as saying:</p>\n<pre><code>int x;              // not initialised\ncout &lt;&lt; x &lt;&lt; '\\n';  // undefined value\n</code></pre>\n<p>But in addition, since you are immediately dereferencing the pointer to the object you just allocated, and do not store the pointer anywhere, this constitutes a memory leak.</p>\n<p>Note that the presence of such an expression does not necessarily make a program ill-formed; this is a perfectly valid program, because it sets the value of the object before reading it:</p>\n<pre><code>int&amp; x = *(new int);  // x is an alias for a nameless new int of undefined value\nx = 42;\ncout &lt;&lt; x &lt;&lt; '\\n';\ndelete &amp;x;\n</code></pre>\n", "LastEditorUserId": "246886", "LastActivityDate": "2014-08-20T01:22:59.623", "Score": "11", "CreationDate": "2014-08-20T01:15:52.743", "ParentId": "25395297", "CommentCount": "0", "OwnerUserId": "246886", "LastEditDate": "2014-08-20T01:22:59.623"}, "25396208": {"Id": "25396208", "PostTypeId": "2", "Body": "<p>First of all, <em>Shafik Yaghmour</em> gave references to the Standard in his <a href=\"https://stackoverflow.com/a/25395408/1543378\">answer</a>. That is the best, complete and authoritative answer. None the less, let me try to give you specific examples that should illustrate the aforementioned points.</p>\n<p>This code is safe, well-formed and meaningful:</p>\n<pre><code>int *p = new int;       // ie this is a local variable (ptr) that points \n                        // to a heap-allocated block\n</code></pre>\n<p>You must not, however, dereference the pointer as that results in <strong>undefined behavior</strong>. IE you may get 0x00, or 0xFFFFFFFF, or the instruction pointer (aka RIP register on Intel) may jump to a random location. The computer may crash. </p>\n<pre><code>int *p = new int;\nstd::cout &lt;&lt; *p;    // Very, bad. Undefined behavior.\n</code></pre>\n<p>Run-time checkers such as <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">Valgrind</a> and <a href=\"http://clang.llvm.org/docs/AddressSanitizer.html\" rel=\"nofollow noreferrer\">ASan</a> will catch the issue, flag it and crash with a nice error message.</p>\n<p>It is, however, perfectly fine to initialize the memory block you had allocated:</p>\n<pre><code>int *p = new int;\n*p = 0;\n</code></pre>\n<p>Background info: this particular way of writing the specification is very useful for performance, as it is prohibitively expensive to implement the alternative. </p>\n<p>Note, as per the Standard references, sometimes the initialization is cheap, so you can do the following:</p>\n<pre><code>// at the file scope\nint global1;          // zero-initialized\nint global2 = 1;      // explicitly initialized\n\nvoid f()\n{\n    std::cout &lt;&lt; global1;\n}\n</code></pre>\n<p>These things go into the executable's sections (.bss and .data) and are initialized by the OS loader.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-20T03:25:59.523", "Score": "1", "CreationDate": "2014-08-20T03:17:44.277", "ParentId": "25395297", "CommentCount": "2", "OwnerUserId": "1543378", "LastEditDate": "2017-05-23T10:29:54.633"}, "25395348": {"Id": "25395348", "PostTypeId": "2", "Body": "<p>It is possible that a computer has \"trapping\" values of <code>int</code>: invalid values, such as a checksum bit which raises a hardware exception when it doesn't match its expected state.</p>\n<p>In general, uninitialized values lead to undefined behavior. Initialize it first.</p>\n<p>Otherwise, no, there's nothing wrong or really unusual about dereferencing a new-expression. Here is some odd, but entirely valid code using your construction:</p>\n<pre><code>int &amp; ir = * ( new int ) = 0;\n\u2026\ndelete &amp; ir;\n</code></pre>\n", "LastActivityDate": "2014-08-20T01:15:54.350", "CommentCount": "0", "CreationDate": "2014-08-20T01:15:54.350", "ParentId": "25395297", "Score": "2", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_25395297_25395408_1": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_25395297_25395408_12": {"length": 22, "quality": 0.8461538461538461, "section_id": 3321}, "so_25395297_25395408_7": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_25395297_25395408_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 3286}, "so_25395297_25395408_5": {"length": 42, "quality": 0.8936170212765957, "section_id": 3291}, "so_25395297_25395408_8": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_25395297_25395408_6": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_25395297_25395408_0": {"length": 9, "quality": 0.75, "section_id": 6098}, "so_25395297_25395408_3": {"length": 5, "quality": 1.0, "section_id": 3286}, "so_25395297_25395408_9": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_25395297_25395408_10": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_25395297_25395408_11": {"length": 6, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_25395297_25395408_12": {"length": 22, "quality": 0.8461538461538461, "section_id": 3191}, "so_25395297_25395408_0": {"length": 9, "quality": 0.75, "section_id": 5864}, "so_25395297_25395408_1": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_25395297_25395408_7": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_2": {"length": 13, "quality": 0.5652173913043478, "section_id": 359}, "so_25395297_25395408_8": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_9": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_6": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_10": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_11": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_25395297_25395408_3": {"length": 5, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_25395297_25395408_12": {"length": 22, "quality": 0.8461538461538461, "section_id": 4087}, "so_25395297_25395408_5": {"length": 42, "quality": 0.8936170212765957, "section_id": 4053}, "so_25395297_25395408_7": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_2": {"length": 12, "quality": 0.5217391304347826, "section_id": 382}, "so_25395297_25395408_0": {"length": 9, "quality": 0.75, "section_id": 7595}, "so_25395297_25395408_8": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_9": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_6": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_10": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_11": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_25395297_25395408_3": {"length": 5, "quality": 1.0, "section_id": 4048}}}, "25395408": {"Id": "25395408", "PostTypeId": "2", "Body": "<p>This is <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a>(<em>UB</em>) since you are accessing an indeterminate value, C++14 clearly makes this undefined behavior. We can see that <code>new</code> without initializer is <em>default initialized</em>, from the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">draft C++14 standard</a> section <code>5.3.4</code> <em>New</em> paragraph <em>17</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_25395297_25395408_0\">If the new-initializer is omitted, the object is default-initialized\n  (8.5). [ Note: If no initialization is performed, the object has an\n  indeterminate value. \u2014end note ]</p>\n</blockquote>\n<p>for <em>int</em> this means an indeterminate value, from section <code>8.5</code> paragraph <em>7</em> which says:</p>\n<blockquote>\n<p id=\"so_25395297_25395408_1\">To default-initialize an object of type T means:</p>\n<p id=\"so_25395297_25395408_2\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor (12.1) for T is called (and\n  the initialization is ill-formed if T has no default constructor or overload resolution (13.3) results in an\n  ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</p>\n<p id=\"so_25395297_25395408_3\">\u2014   if T is an array type, each element is default-initialized;</p>\n<p id=\"so_25395297_25395408_4\">\u2014   <strong>otherwise, no initialization is performed.</strong></p>\n</blockquote>\n<p>we can see from section <code>8.5</code> that producing an indeterminate value is undefined:</p>\n<blockquote>\n<p id=\"so_25395297_25395408_5\">If no initializer is specified for an object, the object is\n  <strong>default-initialized</strong>. When storage for an object with automatic or\n  dynamic storage duration is obtained, <strong>the object has an indeterminate\n  value</strong>, and if no initialization is performed for the object, that\n  object retains an indeterminate value until that value is replaced\n  (5.17). [ Note: Objects with static or thread storage duration are\n  zero-initialized, see 3.6.2. \u2014 end note\n  <strong>If an indeterminate value is produced by an evaluation, the behavior is undefined except in the following cases</strong></p>\n</blockquote>\n<p>and all the exceptions have to do with <em>unsigned narrow char</em> which <em>int</em> is not.</p>\n<p>Jon brings up an interesting example:</p>\n<pre><code>int&amp; x = *(new int); \n</code></pre>\n<p>it may not be immediately obvious why this is not undefined behavior. The key point to notice is that is is undefined behavior to produce a <em>value</em> but in this case no value is produced. We can see this by going to section <code>8.5.3</code> <em>References</em>, which covers initialization of references and it says:</p>\n<blockquote>\n<p id=\"so_25395297_25395408_6\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<blockquote>\n<p id=\"so_25395297_25395408_9\">\u2014 If the reference is an lvalue reference and the initializer expression</p>\n<blockquote>\n<p id=\"so_25395297_25395408_11\">\u2014 is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d or</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>and goes on to say:</p>\n<blockquote>\n<p id=\"so_25395297_25395408_12\">then the reference is bound to the initializer expression lvalue in\n  the first case [...][ Note: <strong>The usual lvalue-to-rvalue (4.1),\n  array-to-pointer (4.2), and function-to-pointer (4.3) standard\n  conversions are not needed, and therefore are suppressed,</strong> when such\n  direct bindings to lvalues are done. \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-08-23T18:06:30.603", "Score": "7", "CreationDate": "2014-08-20T01:25:57.370", "ParentId": "25395297", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-08-23T18:06:30.603"}});