post_cb({"41096869": {"Id": "41096869", "PostTypeId": "2", "Body": "<p>It's a violation of the strict aliasing rule (the compiler assumes that two pointers of different types never reference the same memory location) combined with compiler optimization (the compiler is not performing the second memory access to read <code>i</code> but uses the previous variable).</p>\n<p><strong>EDIT</strong> (as suggested inside the comments):</p>\n<p>From the working draft of the ISO C++ standard (N3376):</p>\n<blockquote>\n<p id=\"so_41096733_41096869_0\">\"If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined [...] \n  \u2014 a cv-qualified version of the dynamic type of the\n  object, [...] \n   \u2014 a type that is the signed or unsigned type\n  corresponding to a cv-qualified version of the dynamic type of the\n  object,  [...] \n   \u2014 a type that is a (possibly cv-qualified) base class\n  type of the dynamic type of the object,\"</p>\n</blockquote>\n<p>As far as i understand it specifies, that a possibly cv-qualified type can be used as an alias, but not that a non cv qualified type for a cv qualified type can be.</p>\n", "LastEditorUserId": "7283940", "LastActivityDate": "2016-12-12T10:17:52.570", "Score": "2", "CreationDate": "2016-12-12T08:34:32.253", "ParentId": "41096733", "CommentCount": "8", "OwnerUserId": "7283940", "LastEditDate": "2016-12-12T10:17:52.570"}, "41096757": {"Id": "41096757", "PostTypeId": "2", "Body": "<p>The behaviour on casting away <code>const</code> from a variable (even via a pointer or a reference in C++) that was originally declared as <code>const</code>, and then subsequently attempting to change the variable through that pointer or reference, is <em>undefined</em>.</p>\n<p>So changing <code>i</code> if it's declared as <code>const int i = 5;</code> is undefined behaviour: the output you are observing is a manifestation of that.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2016-12-12T08:33:55.093", "Score": "36", "CreationDate": "2016-12-12T08:25:50.880", "ParentId": "41096733", "CommentCount": "6", "OwnerUserId": "2380830", "LastEditDate": "2016-12-12T08:33:55.093"}, "41102903": {"Id": "41102903", "PostTypeId": "2", "Body": "<p>The short answer is that C++ 'const' declaration rules allow it to use the constant value directly in places where C would have to dereference the variable.  I.e, C++ compiles the statement</p>\n<pre><code>cout &lt;&lt; i &lt;&lt; '\\n';\n</code></pre>\n<p>as if it what was actually written was</p>\n<pre><code>cout &lt;&lt; 5 &lt;&lt; '\\n';\n</code></pre>\n<p>All of the other non-pointer values are the results of dereferencing pointers.</p>\n", "LastActivityDate": "2016-12-12T14:19:04.200", "CommentCount": "0", "CreationDate": "2016-12-12T14:19:04.200", "ParentId": "41096733", "Score": "0", "OwnerUserId": "7285474"}, "bq_ids": {"n4140": {"so_41096733_41097201_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5435}, "so_41096733_41096869_0": {"length": 38, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_41096733_41097201_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5230}, "so_41096733_41096869_0": {"length": 38, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_41096733_41097201_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 6862}, "so_41096733_41096869_0": {"length": 38, "quality": 1.0, "section_id": 8748}}}, "41100010": {"Id": "41100010", "PostTypeId": "2", "Body": "<p>It would be more fruitful to ask what one specific compiler with certain flags set does with that code than what \u201cC\u201d or \u201cC++\u201d does, because neither C nor C++ will do anything consistently with code like that.  It\u2019s undefined behavior.  Anything could happen.</p>\n<p>It would, for example, be entirely legal to stick <code>const</code> variables in a read-only page of memory that will cause a hardware fault if the program attempts to write to it.  Or to fail silently if you try writing to it.  Or to turn a dereferenced <code>int*</code> cast from a <code>const int*</code> into a temporary copy that can be modified without affecting the original.  Or to modify every reference to that variable after the reassignment.  Or to refactor the code on the assumption that a <code>const</code> variable can\u2019t change so that the operations happen in a different order, and you end up modifying the variable before you think you did or not modifying it after.  Or to make <code>i</code> an alias for other references to the constant <code>1</code> and modify those, too, elsewhere in the program.  Or to break a program invariant that makes the program bug out in totally unpredictable ways.  Or to print an error message and stop compiling if it catches a bug like that.  Or for the behavior to depend on the phase of the moon.  Or anything else.</p>\n<p>There are combinations of compilers and flags and targets that will do those things, with the <em>possible</em> exception of the phase-of-the-moon bug.  The funniest variant I\u2019ve heard of, though, is that in some versions of Fortran, you could set the constant 1 equal to -1, and all loops would run backwards.</p>\n<p>Writing production code like this is a terrible idea, because your compiler almost certainly makes no guarantees what this code will do in your next build.</p>\n", "LastEditorUserId": "4474419", "LastActivityDate": "2016-12-12T18:35:15.347", "Score": "2", "CreationDate": "2016-12-12T11:38:37.227", "ParentId": "41096733", "CommentCount": "0", "OwnerUserId": "4474419", "LastEditDate": "2016-12-12T18:35:15.347"}, "41097201": {"Id": "41097201", "PostTypeId": "2", "Body": "<p>It is undefined behavior as per C11 6.7.3/6:</p>\n<blockquote>\n<p id=\"so_41096733_41097201_0\">If an attempt is made to modify an object defined with a\n  const-qualified type through use of an lvalue with non-const-qualified\n  type, the behavior is undefined.</p>\n</blockquote>\n<p>(C++ will have a similar normative text.)</p>\n<p>And since it is undefined behavior, anything can happen. Including: weird output, program crashes, \"seems to work fine\" (this build).</p>\n", "LastActivityDate": "2016-12-12T08:56:57.140", "CommentCount": "0", "CreationDate": "2016-12-12T08:56:57.140", "ParentId": "41096733", "Score": "16", "OwnerUserId": "584518"}, "41096733": {"ViewCount": "1445", "Body": "<p>In c it's possible to change const using pointers like so:</p>\n<pre><code>//mainc.c\n#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv) {\n    const int i = 5;\n    const int *cpi = &amp;i;\n\n    printf(\"  5:\\n\");\n    printf(\"%d\\n\", &amp;i);\n    printf(\"%d\\n\", i);\n    printf(\"%d\\n\", cpi);    \n    printf(\"%d\\n\", *cpi);   \n\n    *((int*)cpi) = 8;\n    printf(\"  8?:\\n\");\n    printf(\"%d\\n\", &amp;i);\n    printf(\"%d\\n\", i);\n    printf(\"%d\\n\", cpi);\n    printf(\"%d\\n\", *cpi);\n}\n</code></pre>\n<p>The constant is changed as can be seen in the output:\n<a href=\"https://i.stack.imgur.com/9xoT9.png\" rel=\"nofollow noreferrer\"><img alt=\"mainc output\" src=\"https://i.stack.imgur.com/9xoT9.png\"/></a></p>\n<p>If we try the same in c++:</p>\n<pre><code>//main.cpp\n#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nint main(int argc, char** argv) {\n    const int i = 5;\n    const int *cpi = &amp;i;\n\n    cout &lt;&lt; \"  5:\" &lt;&lt; '\\n';\n    cout &lt;&lt; &amp;i &lt;&lt; '\\n';\n    cout &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; cpi &lt;&lt; '\\n';    \n    cout &lt;&lt; *cpi &lt;&lt; '\\n';   \n\n    *((int*)cpi) = 8;\n    cout &lt;&lt; \"  8?:\" &lt;&lt; '\\n';\n    cout &lt;&lt; &amp;i &lt;&lt; '\\n';\n    cout &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; cpi &lt;&lt; '\\n';\n    cout &lt;&lt; *cpi &lt;&lt; '\\n';\n\n    int* addr = (int*)0x28ff24;\n    cout &lt;&lt; *addr &lt;&lt; '\\n';\n}\n</code></pre>\n<p>The result is not so clear:\n<a href=\"https://i.stack.imgur.com/rs978.png\" rel=\"nofollow noreferrer\"><img alt=\"main output\" src=\"https://i.stack.imgur.com/rs978.png\"/></a></p>\n<p>From the output is looks like <code>i</code> is still <code>5</code> and is still located at <code>0x28ff24</code> so the const is unchanged. But in the same time <code>cpi</code> is also <code>0x28ff24</code> (the same as <code>&amp;i</code>) but the value it points to is <code>8</code> (not <code>5</code>).</p>\n<p>Can someone please explain what kind of magic is happening here?</p>\n<p>Explained here: <a href=\"https://stackoverflow.com/a/41098196/2277240\">https://stackoverflow.com/a/41098196/2277240</a></p>\n", "AcceptedAnswerId": "41096757", "Title": "C++ const changed through pointer, or is it?", "CreationDate": "2016-12-12T08:23:49.500", "Id": "41096733", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:43.737", "LastEditorUserId": "-1", "LastActivityDate": "2017-11-01T13:34:51.860", "ClosedDate": "2016-12-12T14:22:12.343", "Score": "16", "OwnerUserId": "2277240", "Tags": "<c++><c><pointers><const>", "AnswerCount": "7"}, "41097239": {"Id": "41097239", "PostTypeId": "2", "Body": "<p>The rule of <code>const_cast&lt;Type *&gt;()</code> or c-type conversion <code>(Type *)</code>:<br>\nThe conversion is to remove <code>const</code> declaration, NOT to remove the <code>const</code> of the value (object) itself.<br/></br></p>\n<pre><code>const Type i = 1;\n// p is a variable, i is an object\nconst Type * p = &amp;i; // i is const --- const is the property of i, you can't remove it\n(Type *)p; // remove the const of p, instead the const of i ---- Here p is non-const but i is ALWAYS const!\n</code></pre>\n<p>Now if you try to change the value of <code>i</code> through <code>p</code>, it's Undefined Behavior because <code>i</code> is ALWAYS const.<br/></p>\n<p>When to use this kind of conversion?<br>\n1) If you can make sure that the pointed value is NOT const.<br>\ne.g.<br/></br></br></p>\n<pre><code>int j = 1;\nconst int *p = &amp;j;\n*(int *)p = 2; // You can change the value of j because j is NOT const\n</code></pre>\n<p>2) The pointed value is const but you ONLY read it and NEVER change it.</p>\n<p>If you really need to change a const value, please redesign you code to avoid this kind of case.</p>\n", "LastEditorUserId": "3305546", "LastActivityDate": "2016-12-12T15:01:55.477", "Score": "4", "CreationDate": "2016-12-12T08:59:44.027", "ParentId": "41096733", "CommentCount": "1", "OwnerUserId": "3305546", "LastEditDate": "2016-12-12T15:01:55.477"}, "41098196": {"Id": "41098196", "PostTypeId": "2", "Body": "<p>So after some thinking I guess I know what happens here. Though it is architecture/implementation dependent since it is undefined behaviour as Marian pointed out. My setup is mingw 5.x 32bit on windows 7 64 bit in case someone is interested.</p>\n<p>C++ consts act like #defines, g++ replaces all <code>i</code> references  with its value in compiled code (since i is a const) but it also writes <code>5</code> (i value) to some address in memory to provide acceses to <code>i</code> via pointer (a dummy pointer). And replaces all the occurences of <code>&amp;i</code> with that adress (not exactly the compiler does it but you know what I mean).</p>\n<p>In C consts are treated mostly like usual variables. With the only difference being that the compiler doesn't allow to change them directly.</p>\n<p>That's why Bjarne Stroustrup says in his book that you don't need #defines in c++.</p>\n<p>Here comes the proof:\n<a href=\"https://i.stack.imgur.com/pU0XI.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/pU0XI.png\"/></a></p>\n", "LastEditorUserId": "2277240", "LastActivityDate": "2017-11-01T13:34:51.860", "Score": "3", "CreationDate": "2016-12-12T09:57:55.650", "ParentId": "41096733", "CommentCount": "4", "OwnerUserId": "2277240", "LastEditDate": "2017-11-01T13:34:51.860"}});