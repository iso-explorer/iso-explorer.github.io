post_cb({"36676527": {"ParentId": "36676419", "CommentCount": "0", "Body": "<p>A <code>sizeof()</code> of a reference does not give you the size of the reference itself, but the <code>sizeof()</code> of whatever the reference is referring to.</p>\n<pre><code>struct foo {\n    int a[128];\n};\n\nfoo bar;\nfoo &amp;baz=bar;\n\nstd::cout &lt;&lt; sizeof(baz) &lt;&lt; std::endl;\n</code></pre>\n<p>You'll get a pretty big <code>sizeof()</code> here. Obviously that's not the size of the reference, but the size of the object being referred to.</p>\n<p>This applies to both lvalue and rvalue references.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "36676527", "Score": "3", "CreationDate": "2016-04-17T12:33:28.503", "LastActivityDate": "2016-04-17T12:33:28.503"}, "36676466": {"ParentId": "36676419", "CommentCount": "2", "Body": "<p>References are, essentially, another name for the same value. As you can see in your tests they have the same size and address as the original value. If you create a value and reference it directly then the reference will be a name for that value also.</p>\n", "OwnerUserId": "887210", "PostTypeId": "2", "Id": "36676466", "Score": "1", "CreationDate": "2016-04-17T12:27:41.300", "LastActivityDate": "2016-04-17T12:27:41.300"}, "36676575": {"ParentId": "36676419", "CommentCount": "2", "Body": "<p>I guess your real question is \"where do the rvalue/const references go when they do not reference anything with a name\"?</p>\n<pre><code>const int&amp; r1 = 8;      // lvalue ref to const int\nint&amp;&amp; r2 = 32;          // rvlaue ref to int\nconst int&amp;&amp; r3 = 128;   // rvalue ref to const int\n</code></pre>\n<p>In all three situations above the compiler allocates space in a temporary location, places the value there, and gives you a reference to that value. The compiler is allowed to do that because it can guarantee that the temporary location would remain read-only.</p>\n<p>That is how your references get their addresses - the objects (8, 32, 128) are still there, because the compiler creates them for you. The addresses of these hidden objects become addresses of the references; the sizes of these hidden objects are reported by the <code>sizeof</code> operator.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "36676575", "Score": "6", "CreationDate": "2016-04-17T12:38:17.740", "LastActivityDate": "2016-04-17T12:38:17.740"}, "36676419": {"CommentCount": "8", "ViewCount": "165", "PostTypeId": "1", "LastEditorUserId": "335858", "CreationDate": "2016-04-17T12:22:31.783", "LastActivityDate": "2016-04-17T13:06:31.310", "Title": "Why do rvalue/const references have memory address and size?", "AcceptedAnswerId": "36676575", "LastEditDate": "2016-04-17T12:35:19.973", "Id": "36676419", "Score": "2", "Body": "<p>I read everywhere that references are not objects, they are just aliases and they have no location on the memory</p>\n<pre><code>int x = 256;\nint&amp; rx = x;\n\nstd::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; &amp;x &lt;&lt; std::endl;       // Output: 256  0x15FAB0\nstd::cout &lt;&lt; rx &lt;&lt; \" \" &lt;&lt; &amp;rx &lt;&lt; std::endl;     // Output: 256  0x15FAB0\n\n// seems legit ... fair enough ...\n</code></pre>\n<p>Now consider the following</p>\n<pre><code>const int&amp; r1 = 8;      // lvalue ref to const int\nint&amp;&amp; r2 = 32;          // rvlaue ref to int\nconst int&amp;&amp; r3 = 128;   // rvalue ref to const int\n\nstd::cout &lt;&lt; r1 &lt;&lt; \" \" &lt;&lt; &amp;r1 &lt;&lt; std::endl;     // Output: 8     0x15FA8C\nstd::cout &lt;&lt; r2 &lt;&lt; \" \" &lt;&lt; &amp;r2 &lt;&lt; std::endl;     // Output: 32    0x15FA74\nstd::cout &lt;&lt; r3 &lt;&lt; \" \" &lt;&lt; &amp;r3 &lt;&lt; std::endl;     // Output: 128   0x15FA5C\n\n// and ...\n\nstd::cout &lt;&lt; sizeof(r1) &lt;&lt; std::endl;   // Ouput: 4\nstd::cout &lt;&lt; sizeof(r2) &lt;&lt; std::endl;   // Ouput: 4\nstd::cout &lt;&lt; sizeof(r3) &lt;&lt; std::endl;   // Ouput: 4\n</code></pre>\n<p>So why these references behave like objects, they do have values , memory address and size ... are they exception from the rules of references ?\nare they located on the stack or somewhere else ?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "6189761", "AnswerCount": "5"}, "36676551": {"ParentId": "36676419", "CommentCount": "0", "Body": "<blockquote>\n<pre><code>int x = 256;\nint&amp; rx = x;\n</code></pre>\n<p id=\"so_36676419_36676551_0\">[...]</p>\n<pre><code>const int&amp; r1 = 8;      // lvalue ref to const int\nint&amp;&amp; r2 = 32;          // rvlaue ref to int\nconst int&amp;&amp; r3 = 128;   // rvalue ref to const int\n</code></pre>\n</blockquote>\n<p>There is not much difference between those two examples. In the first example, you declare a reference (<code>rx</code>) to an object which was already named before (<code>x</code>). In the second example, your three references (<code>r1</code>, <code>r2</code>, <code>r3</code>) refer to temporary objects which are created during the initialisation of each reference.</p>\n<blockquote>\n<p id=\"so_36676419_36676551_1\">So why these references behave like objects, they do have values ,\n  memory address and size ...</p>\n</blockquote>\n<p>They don't. It's just that the objects here are only named by the references and not by anything else. Your <code>sizeof</code> and address-of operators are still applied to those objects.</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "36676551", "Score": "1", "CreationDate": "2016-04-17T12:35:03.587", "LastActivityDate": "2016-04-17T12:35:03.587"}, "36676909": {"ParentId": "36676419", "CommentCount": "0", "Body": "<p>The reference has an address and a size because it is bound to a temporary. The lifetime of the temporary is therefore being extended to match the lifetime of the reference.</p>\n<p>This is expressly covered by \u00a712.2 paras 4,5:</p>\n<blockquote>\n<p id=\"so_36676419_36676909_0\">4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression.\n  The first context is when a default constructor is called to initialize an element of an array. If\n  the constructor has one or more default arguments, the destruction of every temporary created in a default\n  argument is sequenced before the construction of the next array element, if any.</p>\n<p id=\"so_36676419_36676909_1\">5 <strong>The second context is when a reference is bound to a temporary</strong>.117 The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound <strong>persists\n  for the lifetime of the reference</strong> except: ...</p>\n</blockquote>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "36676909", "Score": "2", "CreationDate": "2016-04-17T13:06:31.310", "LastActivityDate": "2016-04-17T13:06:31.310"}, "bq_ids": {"n4140": {"so_36676419_36676909_0": {"section_id": 381, "quality": 0.972972972972973, "length": 36}, "so_36676419_36676909_1": {"section_id": 382, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_36676419_36676909_0": {"section_id": 372, "quality": 0.972972972972973, "length": 36}, "so_36676419_36676909_1": {"section_id": 373, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_36676419_36676909_0": {"section_id": 396, "quality": 0.9459459459459459, "length": 35}, "so_36676419_36676909_1": {"section_id": 397, "quality": 0.8095238095238095, "length": 17}}}});