post_cb({"bq_ids": {"n4140": {"so_31479552_31479828_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 6045}}, "n3337": {"so_31479552_31479828_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5813}}, "n4659": {"so_31479552_31479828_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7544}}}, "31479552": {"ViewCount": "338", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int (*test_func_t) (int, int, int);\n\nint print_integer (int a)\n{\n    std::cout &lt;&lt; \"num: \" &lt;&lt; a &lt;&lt; \"\\n\";\n    return a;\n}\n\nint main (int argc, char * argv[])\n{\n    test_func_t func = (test_func_t) &amp;print_integer;\n    std::cout &lt;&lt; \"calling with 3 parameters func(5,7,9)\\n\";\n    func(5,7,9);\n    return 0;\n}\n</code></pre>\n<p>As you can see, a type (test_func_t) is defined as a function with 3 int arguments. A function pointer (func) is assigned with a pointer to \"print_integer\", which receives only 1 argument, and the function pointer is then called with 3 arguments (5, 7, 9).</p>\n<p>This code works and produces \"num: 5\" output.</p>\n<p>gdb disas output (Intel syntax)</p>\n<pre><code>disas main\n...\n   0x080486cb &lt;+9&gt;:     mov    DWORD PTR [esp+0x1c],0x804867d\n...\n   0x080486e0 &lt;+37&gt;:    mov    DWORD PTR [esp+0x8],0x9\n   0x080486e8 &lt;+45&gt;:    mov    DWORD PTR [esp+0x4],0x7\n   0x080486f0 &lt;+53&gt;:    mov    DWORD PTR [esp],0x5\n   0x080486f7 &lt;+60&gt;:    mov    eax,DWORD PTR [esp+0x1c]\n   0x080486fb &lt;+64&gt;:    call   eax\n\ndisas print_integer\n   ...\n   0x08048683 &lt;+6&gt;:     mov    DWORD PTR [esp+0x4],0x8048830\n   0x0804868b &lt;+14&gt;:    mov    DWORD PTR [esp],0x8049ae0\n   0x08048692 &lt;+21&gt;:    call   0x8048530 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)@plt&gt;\n   0x08048697 &lt;+26&gt;:    mov    edx,DWORD PTR [ebp+0x8]\n   0x0804869a &lt;+29&gt;:    mov    DWORD PTR [esp+0x4],edx\n   0x0804869e &lt;+33&gt;:    mov    DWORD PTR [esp],eax\n   0x080486a1 &lt;+36&gt;:    call   0x80484d0 &lt;std::ostream::operator&lt;&lt;(int)@plt&gt;\n</code></pre>\n<p>As you can see, the rest of the arguments ([ebp+0x12] and [ebp+0x16]) are simply not used.</p>\n<p>My questions:</p>\n<ol>\n<li>This seems to work on Linux x86 with __cdecl calling convention. Is it safe on other architectures and calling conventions as well?</li>\n<li>Does any C/C++ standard allows/defines the result of assigning a function pointer from a function that expects fewer arguments?</li>\n</ol>\n<p>Example of such use: node.js's <a href=\"https://github.com/joyent/node/blob/v0.12.7/src/node.h#L388-L427\" rel=\"nofollow\">NODE_MODULE</a> registers a function whose <a href=\"https://github.com/joyent/node/blob/v0.12.7/src/node.h#L338-L341\" rel=\"nofollow\">type</a> has 3 arguments [exports, module, priv]. It is <a href=\"https://github.com/joyent/node/blob/v0.12.7/src/node.cc#L2217-L2218\" rel=\"nofollow\">called with those 3</a> but formal examples show registering of a function with <a href=\"https://nodejs.org/api/addons.html#addons_hello_world\" rel=\"nofollow\">1</a> or <a href=\"https://nodejs.org/api/addons.html#addons_callbacks\" rel=\"nofollow\">2</a> arguments.</p>\n", "Title": "Calling a function pointer whose assigned function has less arguments then the pointer type", "CreationDate": "2015-07-17T15:38:30.477", "LastActivityDate": "2015-07-18T06:26:23.403", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-18T06:26:23.403", "LastEditorUserId": "1659872", "Id": "31479552", "Score": "2", "OwnerUserId": "1659872", "Tags": "<c++><c><function-pointers><calling-convention>", "AnswerCount": "2"}, "31479828": {"Id": "31479828", "PostTypeId": "2", "Body": "<p>Quoting from the C++11 standard <em>expr.reinterpret.cast 6</em>:</p>\n<blockquote>\n<p id=\"so_31479552_31479828_0\">A function pointer can be explicitly converted to a function pointer of a different type. The effect of calling\n  a function through a pointer to a function type (8.3.5) that <strong>is not the same as the type used in the definition</strong>\n  of the function is <strong>undefined</strong>.</p>\n</blockquote>\n<p>So, I'd say that it is <strong>not</strong> safe in general. It is undefined behaviour. That said, I don't know how other implementation of C++ behave in this situation.</p>\n", "LastEditorUserId": "2508150", "LastActivityDate": "2015-07-17T16:02:34.090", "Score": "12", "CreationDate": "2015-07-17T15:53:05.900", "ParentId": "31479552", "CommentCount": "0", "OwnerUserId": "2508150", "LastEditDate": "2015-07-17T16:02:34.090"}, "31480342": {"Id": "31480342", "PostTypeId": "2", "Body": "<p>Thus will work on all platforms that use the __cdecl calling convention. This calling convention pushes the arguments right-to-left onto the stack and then calls the function. A function requiring less parameters than pushed will thus simply not access the parameters more to the right, which were pushed earlier and are higher on the stack.</p>\n<pre><code>// func(5,7,9);\npush 9\npush 7\npush 5\ncall func\n---&gt; func:\n     push bp\n     mov bp, sp\n     mov ax, [bp+8]  ; get 5\n\n// stack:\n9\n7\n5                     [bp+8]\n&lt;return address&gt;      [bp+4]\n&lt;value of old bp&gt;        ^\n    new bp: -------------+\n</code></pre>\n", "LastActivityDate": "2015-07-17T16:20:32.813", "CommentCount": "4", "CreationDate": "2015-07-17T16:20:32.813", "ParentId": "31479552", "Score": "3", "OwnerUserId": "3100312"}});