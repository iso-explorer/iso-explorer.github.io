post_cb({"22116997": {"ViewCount": "68", "Body": "<p>two quesions:\n1)how is reference variable stored in mem?</p>\n<pre><code>int a=1;\nint &amp;b=a;\ncout&lt;&lt;&amp;a&lt;&lt;endl&lt;&lt;&amp;b;\n</code></pre>\n<p>the addr of a and b are same?so,b as a refrence variable takes no space in mem?!</p>\n<p>2)refrence variable can only be initialized when defined,but if it can be initialized more than one time?how to wrote the code (just to tell the form itself only)?</p>\n<pre><code>int a=c=1;\nint &amp;b=a;\nb=c;//i know this will change the source value of a,not re-assign the ref b,so\n&amp;b=c;//will this be ok?\n</code></pre>\n", "Title": "how is reference variable stored in mem", "CreationDate": "2014-03-01T16:29:20.283", "LastActivityDate": "2014-03-01T17:26:29.763", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "Id": "22116997", "Score": "1", "OwnerUserId": "1980834", "Tags": "<c++><reference>", "AnswerCount": "5"}, "22117182": {"Id": "22117182", "PostTypeId": "2", "Body": "<ol>\n<li><p>The fact that <code>&amp;b</code> gives you the same value as <code>&amp;a</code> does not say anything about where <code>b</code> is stored in memory (if at all). C++ language does not provide you with any means to determine the address of the reference itself. By definition, your <code>&amp;b</code> evaluates to <code>&amp;a</code>. It has absolutely no connection to the actual address of <code>b</code>'s representation in memory, if such representation exists.</p>\n<p>Whether references have representation in memory or not is unspecified. In reality, it might easily vary from one context to another: some references will occupy memory, others will not. In your specific example it is very possible that the compiler will not create any memory representation for <code>b</code>. It will simply treat <code>b</code> as just another name for <code>a</code>.</p>\n<p>But even if compiler decides to allocate something in memory for <code>b</code>, you still won't be able to detect that fact by analyzing the value of <code>&amp;b</code>. The value of <code>&amp;b</code> is completely irrelevant here.</p></li>\n<li><p>As you said it yourself, \"refrence variable can only be initialized when defined\". There's no way to \"redefine\" an existing reference. There's no way to \"reinitialize\" it.</p></li>\n</ol>\n", "LastEditorUserId": "187690", "LastActivityDate": "2014-03-01T17:26:29.763", "Score": "1", "CreationDate": "2014-03-01T16:42:35.293", "ParentId": "22116997", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2014-03-01T17:26:29.763"}, "22117172": {"Id": "22117172", "PostTypeId": "2", "Body": "<p>The C++ standard does not define how references are stored in memory. In fact, perhaps they don't always need to be stored at all, because the compiler may optimize them away. It depends on your compiler, your compiler options, your operating system and the context of the code within your program. It's completely impossible to give you a general answer for this case.</p>\n<p>What is relevant is observable behaviour. And far as that is concerned, <strong>the reference <em>is</em> the object</strong>. It appears under a <strong>different name</strong>, but it is the same object. That's why as soon as you have the reference, taking its address is the same as taking the address of the object under its original name. Everything you do with the reference is the same as doing it with the object, including taking its address. Reference = object.</p>\n<p>As you can see, this is very different from pointers. <strong>Pointers are objects of their own</strong> which may happen to point at other objects. You can take the address of the pointer itself, and it will be different from the address of the pointed-to object.</p>\n<p>The fact that a reference to an object <em>is</em> the object also means that you cannot make a reference refer to something else later on. Remember, it's just a way to access one and the same object under a different name.</p>\n", "LastActivityDate": "2014-03-01T16:42:08.963", "CommentCount": "0", "CreationDate": "2014-03-01T16:42:08.963", "ParentId": "22116997", "Score": "0", "OwnerUserId": "3313064"}, "22117044": {"Id": "22117044", "PostTypeId": "2", "Body": "<p>It is not specified by the language as to how references are stored, but most compilers will implement them as pointers internally.</p>\n<p>Regardless, since references are \"transparent\" to you as a programmer, when you write <code>&amp;b</code> you are in fact taking the address of the referand, not the reference. That's why you get the same address.</p>\n<p>Similarly, writing <code>&amp;b=c</code> does nothing to the reference itself, but writes the value <code>c</code> to pointer that is the address of <code>a</code> (a meaningless thing). It is the same as <code>int* ptr = &amp;b; ptr = c;</code></p>\n<p>It is important to understand that <code>&amp;</code> as \"address of\", and <code>&amp;</code> as in reference type notation, <a href=\"http://kera.name/articles/2010/05/tomalaks-monday-monstrous-rant-i-align-your-asterisks/\" rel=\"nofollow noreferrer\">are <em>two different things</em></a>:</p>\n<pre><code>int a;\nint* ptr = &amp;a; // &lt;--- taking (and storing) the address of  `a`, i.e. a pointer\n\nint&amp; b = a;    // &lt;--- declares a reference to `a`; `b` now behaves like `a`\n\n// Two entirely different meanings of `&amp;`.\n</code></pre>\n<p>There is also a third meaning of <code>&amp;</code>, which is <em>bitwise AND</em>.</p>\n<p><strong>Anyway, if you want to re-seat a reference, you're out of luck. You simply cannot do that.</strong></p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-03-01T17:05:43.727", "Score": "7", "CreationDate": "2014-03-01T16:32:48.743", "ParentId": "22116997", "CommentCount": "2", "OwnerUserId": "560648", "LastEditDate": "2014-03-01T17:05:43.727"}, "bq_ids": {"n4140": {"so_22116997_22117225_1": {"length": 5, "quality": 1.0, "section_id": 3221}}, "n3337": {"so_22116997_22117225_1": {"length": 5, "quality": 1.0, "section_id": 3095}}, "n4659": {"so_22116997_22117225_1": {"length": 5, "quality": 1.0, "section_id": 3978}}}, "22117056": {"Id": "22117056", "PostTypeId": "2", "Body": "<p>I think there is a confusion here between:</p>\n<ul>\n<li><strong>semantics</strong>: what the code you write mean and should do</li>\n<li><strong>implementation</strong>: how those semantics are translated into something the computer executes, and that produces the desired effects</li>\n</ul>\n<p>The C++ Standard precises how references should behave (and notably, that you cannot have them reference another object or that taking their address should yield the same value as taking the address of the object they reference). This has nothing to do with how they are implemented under the hood... otherwise you would have no portability.</p>\n", "LastActivityDate": "2014-03-01T16:33:32.427", "CommentCount": "0", "CreationDate": "2014-03-01T16:33:32.427", "ParentId": "22116997", "Score": "0", "OwnerUserId": "147192"}, "22117225": {"Id": "22117225", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22116997_22117225_0\">how is reference variable stored in mem?</p>\n</blockquote>\n<p>As per \u00a7 8.3.2/4 of the Standard:</p>\n<blockquote>\n<p id=\"so_22116997_22117225_1\">It is unspecified whether or not a reference requires storage</p>\n</blockquote>\n<p>Therefore it's not guaranteed that references are stored in memory.</p>\n<hr>\n<blockquote>\n<p id=\"so_22116997_22117225_2\">refrence variable can only be initialized when defined,but if it can be initialized more than one time?</p>\n</blockquote>\n<p>Remember that <code>&amp;</code> in:</p>\n<pre><code>int&amp; x;\n</code></pre>\n<p>is part of the type. While <code>&amp;</code> in:</p>\n<pre><code>&amp;var\n</code></pre>\n<p>is the operator that will return the address of <code>var</code>. </p>\n<p>They are two completely different things. One is used to declare a <em>reference</em>, the other (usually, because it can be overloaded) to take the address of some l-value.</p>\n</hr>", "LastActivityDate": "2014-03-01T16:47:13.740", "CommentCount": "0", "CreationDate": "2014-03-01T16:47:13.740", "ParentId": "22116997", "Score": "1", "OwnerUserId": "493122"}});