post_cb({"2778357": {"Id": "2778357", "PostTypeId": "2", "Body": "<p>A class template may have virtual member functions.</p>\n<p>A member function template cannot be virtual.  That is, the following is invalid:</p>\n<pre><code>class C\n{\npublic:\n    template &lt;typename T&gt;\n    virtual void f();\n};\n</code></pre>\n<p>In addition, if a derived class has a member function template with the same name as a virtual function in a base class, it does not override the virtual function.  So, if <code>TemplateClass::Func</code> had been a member function template, e.g.,</p>\n<pre><code>template &lt;typename T&gt;\nvoid Func(T var) { /* ... */ }\n</code></pre>\n<p>it would not have overridden <code>BaseClass::Func</code>.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-05-06T04:12:54.513", "Score": "8", "CreationDate": "2010-05-06T03:59:32.690", "ParentId": "2778352", "CommentCount": "2", "OwnerUserId": "151292", "LastEditDate": "2010-05-06T04:12:54.513"}, "2778387": {"Id": "2778387", "PostTypeId": "2", "Body": "<p>It doesn't break the rule. The actual rule is 14.5.2/4:</p>\n<blockquote>\n<p id=\"so_2778352_2778387_0\">A member function template shall not be virtual. [Example:</p>\n<pre><code>template &lt;class T&gt; struct AA {\n  template &lt;class C&gt; virtual void g(C); // error\n  virtual void f(); // OK\n};\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2010-05-06T04:09:38.697", "CommentCount": "0", "CreationDate": "2010-05-06T04:09:38.697", "ParentId": "2778352", "Score": "2", "OwnerUserId": "123111"}, "bq_ids": {"n4140": {"so_2778352_2778387_0": {"length": 4, "quality": 0.8, "section_id": 112}}, "n3337": {"so_2778352_2778387_0": {"length": 4, "quality": 0.8, "section_id": 107}}, "n4659": {"so_2778352_2778387_0": {"length": 4, "quality": 0.8, "section_id": 116}}}, "2778352": {"ViewCount": "5293", "Body": "<p>The below code compiles with gcc v4.3.3 and the templated child class seems to be overriding a virtual function in the parent, but doesn't that break the rule that you cannot have a virtual template function?  Or is something else happening that I don't understand?</p>\n<pre><code>class BaseClass\n{\npublic:\n  virtual void Func(int var)\n  {\n    std::cout&lt;&lt;\"Base int \"&lt;&lt;var&lt;&lt;std::endl;\n  }\n\n  virtual void Func(double var)\n  {\n    std::cout&lt;&lt;\"Base double \"&lt;&lt;var&lt;&lt;std::endl;\n  }\n};\n\ntemplate &lt;class TT&gt;\nclass TemplateClass : public BaseClass\n{\npublic:\n  using BaseClass::Func;\n  virtual void Func(TT var)\n  {\n    std::cout&lt;&lt;\"Child TT \"&lt;&lt;var&lt;&lt;std::endl;\n  }\n};\n\nint main(int argc, char **argv)\n{\n  BaseClass a;\n  TemplateClass&lt;int&gt; b;\n  BaseClass *c = new TemplateClass&lt;int&gt;;\n\n  int intVar = 3;\n  double doubleVar = 5.5;\n\n  a.Func(intVar);\n  a.Func(doubleVar);\n  b.Func(intVar);\n  b.Func(doubleVar);\n  c-&gt;Func(intVar);\n  c-&gt;Func(doubleVar);\n  delete c;\n}\n</code></pre>\n<p>This then outputs: </p>\n<p>Base int 3<br>\nBase double 5.5<br>\nChild TT 3<br>\nBase double 5.5<br>\nChild TT 3<br>\nBase double 5.5  </br></br></br></br></br></p>\n<p>as I hoped, but I'm not sure why it works.</p>\n", "AcceptedAnswerId": "2778357", "Title": "Template Child Class Overriding a Parent Class's Virtual Function", "CreationDate": "2010-05-06T03:56:56.317", "Id": "2778352", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-05-06T04:12:54.513", "Score": "5", "OwnerUserId": "334066", "Tags": "<c++><templates><virtual>", "AnswerCount": "2"}});