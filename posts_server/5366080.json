post_cb({"bq_ids": {"n4140": {"so_5366080_5366094_1": {"length": 7, "quality": 1.0, "section_id": 686}, "so_5366080_5366094_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 686}}, "n3337": {"so_5366080_5366094_1": {"length": 7, "quality": 1.0, "section_id": 676}, "so_5366080_5366094_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 676}}, "n4659": {"so_5366080_5366094_1": {"length": 7, "quality": 1.0, "section_id": 715}, "so_5366080_5366094_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 715}}}, "5366080": {"ViewCount": "192", "Body": "<p>In the following, I'm expecting <code>obj</code> to be converted to an <code>int</code> but why does it returns operator + ambiguous in the following?</p>\n<pre><code>class MyClass\n{\npublic:\n    MyClass(int X = 0, double Y = 0):x(X), y(Y){}\n\n    operator int() const  { return x; }\n    operator double() const  { return y; }\n\nprivate:\n    int x;\n    double y;\n};\n\nint main()\n{\n    MyClass obj(10, 20);\n\n    int x = obj + 5; //obj converted to int\n}\n</code></pre>\n", "AcceptedAnswerId": "5366094", "Title": "ClassType Conversions - operator + ambiguous", "CreationDate": "2011-03-20T01:08:36.083", "Id": "5366080", "CommentCount": "1", "LastEditDate": "2011-03-20T01:13:15.543", "PostTypeId": "1", "LastEditorUserId": "187543", "LastActivityDate": "2011-03-20T02:19:08.340", "Score": "2", "OwnerUserId": "255412", "Tags": "<c++><type-conversion>", "AnswerCount": "3"}, "5366094": {"Id": "5366094", "PostTypeId": "2", "Body": "<p>Because both conversions are equivalent, it's ambiguous.  Remember that the C++ language directly defines <code>+</code> for arguments of <code>double</code> and <code>int</code>, there is no standard conversion involved.</p>\n<p>So neither of these functions is better than the other:</p>\n<ul>\n<li><code>double operator+ (double, int)</code> -- requires one user-defined conversion and no standard conversions</li>\n<li><code>int operator+ (int, int)</code> -- requires one user-defined conversion and no standard conversions</li>\n</ul>\n<p>You'll need to provide all the usual arithmetic operators yourself, if you want to make this work, and not rely on implicit conversion operators.</p>\n<ul>\n<li><code>double operator+ (const MyClass&amp;, int)</code> -- requires one standard conversion</li>\n<li><code>int operator+ (const MyClass&amp;, double)</code> -- requires no conversions</li>\n</ul>\n<p>Now <code>obj + 5</code> will have an unambiguous best match.</p>\n<hr>\n<p>C++0x draft n3245 says, in section <code>[over.built]</code></p>\n<blockquote>\n<ul>\n<li>In this subclause, the term <em>promoted integral type</em> is used to refer to those integral types which are preserved by integral promotion (including e.g. <code>int</code> and <code>long</code> but excluding e.g. <code>char</code>). Similarly, the term <em>promoted arithmetic type</em> refers to floating types plus promoted integral types.</li>\n</ul>\n<p id=\"so_5366080_5366094_0\">For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form</p>\n<pre><code>LR operator*(L,  R);\nLR operator/(L,  R);\nLR operator+(L,  R);\nLR operator-(L,  R);\nbool       operator&lt;(L,  R);\nbool       operator&gt;(L,  R);\nbool       operator&lt;=(L,  R);\nbool       operator&gt;=(L,  R);\nbool       operator==(L,  R);\nbool       operator!=(L,  R);\n</code></pre>\n<p id=\"so_5366080_5366094_1\">where <code>LR</code> is the result of the usual arithmetic conversions between types <code>L</code> and <code>R</code>.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-03-20T01:22:45.233", "Score": "4", "CreationDate": "2011-03-20T01:10:38.860", "ParentId": "5366080", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2011-03-20T01:22:45.233"}, "5366096": {"Id": "5366096", "PostTypeId": "2", "Body": "<p>You need do an explicit cast to instruct the compiler that you do really want an integer.</p>\n<pre><code>int x = static_cast&lt;int&gt;(obj) + 5; //obj converted to int\n</code></pre>\n", "LastActivityDate": "2011-03-20T01:11:06.417", "CommentCount": "2", "CreationDate": "2011-03-20T01:11:06.417", "ParentId": "5366080", "Score": "1", "OwnerUserId": "187543"}, "5366350": {"Id": "5366350", "PostTypeId": "2", "Body": "<p>Of course, you could solve this by overloading the <code>+</code> <code>operator</code> within <code>MyClass</code> (as opposed to the global one in <a href=\"https://stackoverflow.com/questions/5366080/classtype-conversions-operator-ambiguous/5366094#5366094\">Ben Voigt's answer</a>):</p>\n<pre><code>int operator +(const int rhs) const\n{\n    return x + rhs;\n}\n\nint operator +(const double rhs) const\n{\n    return y + rhs;\n}\n</code></pre>\n<p>Tidy and unambiguous.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-03-20T02:19:08.340", "Score": "1", "CreationDate": "2011-03-20T02:19:08.340", "ParentId": "5366080", "CommentCount": "2", "OwnerUserId": "78845", "LastEditDate": "2017-05-23T10:33:10.013"}});