post_cb({"26614490": {"ParentId": "17536570", "CommentCount": "0", "Body": "<p>You may want to look into tied streams - <a href=\"http://www.cplusplus.com/reference/ios/ios/tie/\" rel=\"nofollow\">http://www.cplusplus.com/reference/ios/ios/tie/</a></p>\n<p>This makes every time an input reads the output will automatically be flushed, which is I think the behavior you want, although it does require a separate input and output stream</p>\n", "OwnerUserId": "2898302", "PostTypeId": "2", "Id": "26614490", "Score": "0", "CreationDate": "2014-10-28T17:16:40.423", "LastActivityDate": "2014-10-28T17:16:40.423"}, "17536570": {"CommentCount": "0", "AcceptedAnswerId": "17567454", "CreationDate": "2013-07-08T21:48:25.343", "LastActivityDate": "2014-10-28T17:16:40.423", "PostTypeId": "1", "ViewCount": "12862", "FavoriteCount": "6", "Title": "Reading and writing to the same file using the same fstream", "Id": "17536570", "Score": "11", "Body": "<p>I have a file that already contains some data (say, 8 kB). I want to read something from the beginning of the file, and then overwrite data starting where I finished reading. So I try to use the following code:</p>\n<pre><code>std::fstream stream(\"filename\", std::ios::in | std::ios::out | std::ios::binary);\n\nchar byte;\nstream.read(&amp;byte, 1);\n\n// stream.seekp(1);\n\nint bytesCount = 4096;\n\nauto bytesVec = std::vector&lt;char&gt;(bytesCount, 'c');\nchar* bytes = bytesVec.data();\n\nstd::cout &lt;&lt; stream.bad() &lt;&lt; std::endl;\n\nstream.write(bytes, bytesCount);\n\nstd::cout &lt;&lt; stream.bad() &lt;&lt; std::endl;\n</code></pre>\n<p>If I execute this code, the first <code>bad()</code> returns <code>false</code>, but the second one returns <code>true</code> and nothing actually gets written.</p>\n<p>If I decrease <code>bytesCount</code> to anything smaller than 4096 (presumably the size of some internal buffer), the second <code>bad()</code> returns <code>false</code>, but still nothing gets written.</p>\n<p>If I uncomment the <code>seekp()</code> line, the writing starts working: <code>bad()</code> returns <code>false</code> and the bytes actually get written.</p>\n<p>Why is the <code>seekp()</code> necessary here? Why doesn't it work without it? Is the <code>seekp()</code> the right way to do this?</p>\n<p>I'm using Visual Studio 2012 on Windows 7.</p>\n", "Tags": "<c++><visual-studio-2012><iostream><fstream>", "OwnerUserId": "41071", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17536570_17567454_1": {"section_id": 2412, "quality": 0.8, "length": 12}}, "n3337": {"so_17536570_17567454_1": {"section_id": 2397, "quality": 0.8, "length": 12}}, "n4659": {"so_17536570_17567454_1": {"section_id": 2687, "quality": 0.8, "length": 12}}}, "17567454": {"ParentId": "17536570", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You are falling foul of a restriction upon the intermixing of read and\nwrite operations on a file opened in update mode that MS's <code>fstream</code>\nlibrary inherits from from the its C <code>&lt;stdio.h&gt;</code> implementation.</p>\n<p>The C Standard (I cite C99, but it doesn't differ in this point from C89)\nat 7.19.5.3/6 states:</p>\n<blockquote>\n<p id=\"so_17536570_17567454_0\">When a file is opened with update mode ('+' as the second or third character in the\n  above list of mode argument values), both input and output may be performed on the\n  associated stream. However, output shall not be directly followed by input without an\n  intervening call to the fflush function or to a file positioning function (fseek,\n  fsetpos, or rewind), and <em>input shall not be directly followed by output without an\n  intervening call to a file positioning function</em>, unless the input operation encounters end-\n  of-file.</p>\n</blockquote>\n<p>(my emphasis).</p>\n<p>So your <code>stream.seekp(1)</code> solution, which devolves to a C <code>fseek</code>, is correct.</p>\n<p>The GNU C library does not have this Standard limitation, so your code as posted works\nas expected when built with GCC.</p>\n<p>The MS <code>&lt;fstream&gt;</code> library is compliant with the C++ Standard in inheriting\nthis restriction. <code>fstream</code>s are implemented using <code>basic_filebuf&lt;charT,traits&gt;</code>. In the (C++11) Standard's account of this template, at \u00a7 27.9.1.1/2, it simply says:</p>\n<blockquote>\n<p id=\"so_17536570_17567454_1\">The restrictions on reading and writing a sequence controlled by an object of class basic_filebuf are the same as for reading and writing with the Standard C library FILEs.</p>\n</blockquote>\n", "OwnerUserId": "1362568", "LastEditorUserId": "1362568", "LastEditDate": "2013-07-10T13:46:58.503", "Id": "17567454", "Score": "18", "CreationDate": "2013-07-10T09:47:15.643", "LastActivityDate": "2013-07-10T13:46:58.503"}});