post_cb({"1164267": {"ParentId": "1164266", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>References are not objects. They don't have storage of their own, they just reference existing objects. For this reason it doesn't make sense to have arrays of references.</p>\n<p>If you want a light-weight <em>object</em> that references another object then you can use a pointer. You will only be able to use a <code>struct</code> with a reference member as objects in arrays if you provide explicit initialization for all the reference members for all <code>struct</code> instances. References cannot be default initalized.</p>\n<p><strong>Edit:</strong> As jia3ep notes, in the standard section on declarations there is an explicit prohibition on arrays of references.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2009-07-22T11:06:47.777", "Id": "1164267", "Score": "43", "CreationDate": "2009-07-22T10:11:12.630", "LastActivityDate": "2009-07-22T11:06:47.777"}, "bq_ids": {"n4140": {"so_1164266_1164306_0": {"section_id": 3222, "quality": 1.0, "length": 7}}, "n3337": {"so_1164266_1164306_0": {"section_id": 3096, "quality": 1.0, "length": 7}}, "n4659": {"so_1164266_1164306_0": {"section_id": 3979, "quality": 1.0, "length": 7}}}, "1164411": {"ParentId": "1164266", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Because like many have said here, references are not objects. they are simply aliases. True some compilers might implement them as pointers, but the standard does not force/specify that. And because references are not objects, you cannot point to them. Storing elements in an array means there is some kind of index address (i.e., pointing to elements at a certain index); and that is why you cannot have arrays of references, because you cannot point to them.</p>\n<p>Use boost::reference_wrapper, or boost::tuple instead; or just pointers.</p>\n", "OwnerUserId": "115387", "LastEditorUserId": "450000", "LastEditDate": "2012-11-29T05:24:07.430", "Id": "1164411", "Score": "7", "CreationDate": "2009-07-22T10:40:19.640", "LastActivityDate": "2012-11-29T05:24:07.430"}, "28766450": {"ParentId": "1164266", "CommentCount": "1", "Body": "<p>Actually, this is a mixture of C and C++ syntax.</p>\n<p>You should <strong>either</strong> use pure C arrays, which cannot be of references, since reference are part of C++ only. <strong>Or</strong> you go the C++ way and use the <code>std::vector</code> or <code>std::array</code> class for your purpose.</p>\n<p>As for the edited part: Even though the <code>struct</code> is an element from C, you define a constructor and operator functions, which make it a C++ <code>class</code>. Consequently, your <code>struct</code> would not compile in pure C!</p>\n", "OwnerUserId": "4428496", "PostTypeId": "2", "Id": "28766450", "Score": "-1", "CreationDate": "2015-02-27T13:39:03.727", "LastActivityDate": "2015-02-27T13:39:03.727"}, "1164276": {"ParentId": "1164266", "CommentCount": "2", "Body": "<p>An array is implicitly convertable to a pointer, and <a href=\"http://www.codeguru.com/forum/archive/index.php/t-417237.html\" rel=\"noreferrer\">pointer-to-reference is illegal in C++</a></p>\n", "OwnerUserId": "72896", "PostTypeId": "2", "Id": "1164276", "Score": "10", "CreationDate": "2009-07-22T10:12:57.603", "LastActivityDate": "2009-07-22T10:12:57.603"}, "1164308": {"ParentId": "1164266", "CommentCount": "1", "Body": "<p>Consider an array of pointers. A pointer is really an address; so when you initialize the array, you are analogously telling the computer, \"allocate this block of memory to hold these X numbers (which are addresses of other items).\" Then if you change one of the pointers, you are just changing what it points to; it is still a numerical address which is itself sitting in the same spot.</p>\n<p>A reference is analogous to an alias. If you were to declare an array of references, you would basically be telling the computer, \"allocate this amorphous blob of memory consisting of all these different items scattered around.\"</p>\n", "OwnerUserId": "105570", "PostTypeId": "2", "Id": "1164308", "Score": "0", "CreationDate": "2009-07-22T10:19:18.323", "LastActivityDate": "2009-07-22T10:19:18.323"}, "20573198": {"ParentId": "1164266", "CommentCount": "0", "Body": "<p>You can get fairly close with this template struct.\nHowever, you need to initialize with expressions that are pointers to T, rather than T; and so, though you can easily make a 'fake_constref_array' similarly, you won't be able to bind that to rvalues as done in the OP's example ('8');</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntemplate&lt;class T, int N&gt; \nstruct fake_ref_array {\n   T * ptrs[N];\n  T &amp; operator [] ( int i ){ return *ptrs[i]; }\n};\n\nint A,B,X[3];\n\nvoid func( int j, int k)\n{\n  fake_ref_array&lt;int,3&gt; refarr = { &amp;A, &amp;B, &amp;X[1] };\n  refarr[j] = k;  // :-) \n   // You could probably make the following work using an overload of + that returns\n   // a proxy that overloads *. Still not a real array though, so it would just be\n   // stunt programming at that point.\n   // *(refarr + j) = k  \n}\n\nint\nmain()\n{\n    func(1,7);  //B = 7\n    func(2,8);     // X[1] = 8\n    printf(\"A=%d B=%d X = {%d,%d,%d}\\n\", A,B,X[0],X[1],X[2]);\n        return 0;\n}\n</code></pre>\n<p>--&gt; A=0 B=7 X = {0,8,0}</p>\n", "OwnerUserId": "450000", "PostTypeId": "2", "Id": "20573198", "Score": "3", "CreationDate": "2013-12-13T18:11:48.897", "LastActivityDate": "2013-12-13T18:11:48.897"}, "8088355": {"ParentId": "1164266", "CommentCount": "6", "Body": "<p>This is an interesting discussion. Clearly arrays of refs are outright illegal, but IMHO the reason why is not so simple as saying 'they are not objects' or 'they have no size'. I'd point out that arrays themselves are not full-fledged objects in C/C++ - if you object to that, try instantiating some stl template classes using an array as a 'class' template parameter, and see what happens. You can't return them, assign them, pass them as parameters. ( an array param is treated as a pointer). But it is legal to make arrays of arrays.\nReferences do have a size that the compiler can and must calculate - you can't sizeof() a reference, but you can make a struct containing nothing but references. It will have a size sufficient to contain all the pointers which implement the references. You can't instantiate such a struct without initializing all the members:</p>\n<pre><code>struct mys {\n int &amp; a;\n int &amp; b;\n int &amp; c;\n};\n...\nint ivar1, ivar2, arr[200];\nmys my_refs = { ivar1, ivar2, arr[12] };\n\nmy_refs.a += 3  ;  // add 3 to ivar1\n</code></pre>\n<p>In fact you can add this line to the struct definition</p>\n<pre><code>struct mys {\n ...\n int &amp; operator[]( int i ) { return i==0?a : i==1? b : c; }\n};\n</code></pre>\n<p>...and now I have something which looks a LOT like an array of refs:</p>\n<pre><code>int ivar1, ivar2, arr[200];\nmys my_refs = { ivar1, ivar2, arr[12] };\n\nmy_refs[1] = my_refs[2]  ;  // copy arr[12] to ivar2\n&amp;my_refs[0];               // gives &amp;my_refs.a == &amp;ivar1\n</code></pre>\n<p>Now, this is not a real array, it's an operator overload; it won't do things that arrays normally do like sizeof(arr)/sizeof(arr[0]), for instance. But it does exactly what I want an array of references to do, with perfectly legal C++.\nExcept (a) it's a pain to set up for more than 3 or 4 elements, and (b) it's doing a calculation using a bunch of ?: which could be done using indexing (not with normal C-pointer-calculation-semantics indexing, but indexing nonetheless). I'd like to see a very limited 'array of reference' type which can actually do this. I.e. an array of references would not be treated as a general array of things which are references, but rather it would be a new 'array-of-reference' thing which effectively maps to an internally generated class similar to the one above (but which you unfortunately <em>can't</em> make with templates).</p>\n<p>this would probably work, if you don't mind this kind of nasty: recast '*this' as an array of int *'s and return a reference made from one: (not recommended, but it shows how the proper 'array' would work):</p>\n<pre><code> int &amp; operator[]( int i ) { return *(reinterpret_cast&lt;int**&gt;(this)[i]); }\n</code></pre>\n", "OwnerUserId": "450000", "PostTypeId": "2", "Id": "8088355", "Score": "21", "CreationDate": "2011-11-11T00:39:32.457", "LastActivityDate": "2011-11-11T00:39:32.457"}, "32277527": {"ParentId": "1164266", "CommentCount": "3", "Body": "<p>Just to add to all the conversation.\nSince arrays requires consecutive memory locations to store the item, so if we create an array of references then it's not guaranteed that they will be at consecutive memory location so accessing will be a problem and hence we can't even apply all the mathematical operations on array.</p>\n", "OwnerUserId": "4015191", "PostTypeId": "2", "Id": "32277527", "Score": "0", "CreationDate": "2015-08-28T18:25:22.703", "LastActivityDate": "2015-08-28T18:25:22.703"}, "25953607": {"ParentId": "1164266", "CommentCount": "3", "Body": "<p>Comment to your edit:</p>\n<p>Better solution is <code>std::reference_wrapper</code>.</p>\n<p>Details:\n<a href=\"http://www.cplusplus.com/reference/functional/reference_wrapper/\" rel=\"noreferrer\">http://www.cplusplus.com/reference/functional/reference_wrapper/</a></p>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nint main() {\n    int a=1,b=2,c=3,d=4;\n    using intlink = std::reference_wrapper&lt;int&gt;;\n    intlink arr[] = {a,b,c,d};\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3697939", "PostTypeId": "2", "Id": "25953607", "Score": "17", "CreationDate": "2014-09-20T21:46:29.210", "LastActivityDate": "2014-09-20T21:46:29.210"}, "38323422": {"ParentId": "1164266", "CommentCount": "2", "Body": "<p>For a simple reason arrays of references cannot exist!\nReferences are compile time entities. Meaning they are replaced with the appropriate addresses during compile time. Now Say you made and array of references array[].</p>\n<p>And some where in the code you did array[2], that would be fine. The compiler can just look at the third initializer from the array and replace the address.</p>\n<p>But now say you did array[i], what is it going to replace with? There is no information on i. </p>\n<p>The case with pointers is different. They are actual variables which have memory allotted to them and are resolved during runtime if you do *pointer. Hence if you have an array of pointers and do *array[i], it will be valid since there is information about of i during execution.</p>\n<p>I hope it answers the query.</p>\n", "OwnerUserId": "2858773", "PostTypeId": "2", "Id": "38323422", "Score": "-1", "CreationDate": "2016-07-12T08:17:26.417", "LastActivityDate": "2016-07-12T08:17:26.417"}, "22285844": {"ParentId": "1164266", "CommentCount": "2", "Body": "<p>When you store something in an array , its size needs to be known (since array indexing relies on the size). Per the C++ standard It is unspecified whether or not a reference requires storage, as a result indexing an array of references would not be possible.</p>\n", "OwnerUserId": "160831", "PostTypeId": "2", "Id": "22285844", "Score": "0", "CreationDate": "2014-03-09T17:58:31.307", "LastActivityDate": "2014-03-09T17:58:31.307"}, "1164281": {"ParentId": "1164266", "CommentCount": "1", "Body": "<p>A reference object has no size. If you write <code>sizeof(referenceVariable)</code>, it will give you the size of the object referenced by <code>referenceVariable</code>, not that of the reference itself. It has no size of its own, which is why the compiler can't calculate how much size the array would require.</p>\n", "OwnerUserId": "2095", "PostTypeId": "2", "Id": "1164281", "Score": "1", "CreationDate": "2009-07-22T10:14:40.440", "LastActivityDate": "2009-07-22T10:14:40.440"}, "1164266": {"CommentCount": "7", "AcceptedAnswerId": "1164306", "PostTypeId": "1", "LastEditorUserId": "3614835", "CreationDate": "2009-07-22T10:09:49.217", "LastActivityDate": "2016-08-21T21:32:37.537", "LastEditDate": "2016-08-21T21:32:37.537", "ViewCount": "60341", "FavoriteCount": "42", "Title": "Why are arrays of references illegal?", "Id": "1164266", "Score": "98", "Body": "<p>The following code does not compile.</p>\n<pre><code>int a = 1, b = 2, c = 3;\nint&amp; arr[] = {a,b,c,8};\n</code></pre>\n<p><strong>What does the C++ standard say about this?</strong></p>\n<p>I know I could declare a class that contains a reference, then create an array of that class, as shown below.  But I really want to know why the code above doesn't compile.</p>\n<pre><code>struct cintref\n{\n    cintref(const int &amp; ref) : ref(ref) {}\n    operator const int &amp;() { return ref; }\nprivate:\n    const int &amp; ref;\n    void operator=(const cintref &amp;);\n};\n\nint main() \n{\n  int a=1,b=2,c=3;\n  //typedef const int &amp;  cintref;\n  cintref arr[] = {a,b,c,8};\n}\n</code></pre>\n<p>It is possible to use <code>struct cintref</code> instead of <code>const int &amp;</code> to simulate an array of references.</p>\n", "Tags": "<c++><arrays><reference>", "OwnerUserId": "124161", "AnswerCount": "14"}, "1164306": {"ParentId": "1164266", "PostTypeId": "2", "CommentCount": "15", "Body": "<p><strong>C++ Standard 8.3.2/4</strong>:</p>\n<blockquote>\n<p id=\"so_1164266_1164306_0\">There shall be no references to references, <strong>no arrays of references</strong>, and no pointers to references.  </p>\n</blockquote>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-07-22T10:30:42.217", "Id": "1164306", "Score": "120", "CreationDate": "2009-07-22T10:19:05.733", "LastActivityDate": "2009-07-22T10:30:42.217"}, "33850870": {"ParentId": "1164266", "CommentCount": "4", "Body": "<p>Given <code>int&amp; arr[] = {a,b,c,8};</code>, what is <code>sizeof(*arr)</code> ?</p>\n<p>Everywhere else, a reference is treated as being simply the thing itself, so <code>sizeof(*arr)</code> should simply be <code>sizeof(int)</code>. But this would make array pointer arithmetic on this array wrong (assuming that references are not the same widths is ints). To eliminate the ambiguity, it's forbidden. </p>\n", "OwnerUserId": "244365", "PostTypeId": "2", "Id": "33850870", "Score": "7", "CreationDate": "2015-11-22T02:08:54.857", "LastActivityDate": "2015-11-22T02:08:54.857"}});