post_cb({"bq_ids": {"n4140": {"so_17188485_17190112_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5962}}, "n3337": {"so_17188485_17190112_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5731}}}, "17191171": {"PostTypeId": "2", "Body": "<p>The first is a function template. It can be specialized and overloaded. It can be found by ADL. When you want to take the address, you must either explicitly give it template parameters or do it in a context where the compiler can deduce them.</p>\n<p>The second, assuming it appears on namespace scope, is a global object with a templated function call operator. It cannot be specialized or overloaded (global variables conflict with functions, they don't overload them). It cannot be found by ADL (ADL only finds functions and function templates). If you use the address operator on it, you get the address of the object, which is pretty useless. The object itself can be converted to a function pointer if the compiler can deduce the arguments; you cannot supply them explicitly.</p>\n<p>You can use whichever you want; just be aware of the advantages and disadvantages of either choice. I would recommend the first. The only advantage of the second is its terseness, and I hope we'll get terse syntax for function templates in the not-too-distant future as well.</p>\n<pre><code>auto func(auto t) { ... }\n</code></pre>\n", "LastActivityDate": "2013-06-19T12:26:54.840", "Id": "17191171", "CommentCount": "0", "CreationDate": "2013-06-19T12:26:54.840", "ParentId": "17188485", "Score": "5", "OwnerUserId": "8922"}, "17190112": {"PostTypeId": "2", "Body": "<p>N3337, [expr.prim.lambda]/3:</p>\n<blockquote>\n<p id=\"so_17188485_17190112_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed nonunion class type \u2014 called the\n  closure type \u2014 whose properties are described below. This class type\n  is not an aggregate (8.5.1). The closure type is declared in the\n  smallest block scope, class scope, or namespace scope that contains\n  the corresponding lambda-expression.</p>\n</blockquote>\n<p>This closure type will stay a class. But its overloaded function call operator will be a <em>operator function template</em>, allowing different specializations. Furthermore, unlike function templates, you can implicitely convert a closure object to a function pointer. Its really handy, isn't it?\nQuoting N3559, it'll look something like that:\n</p>\n<p>For a generic lambda L:</p>\n<pre><code>int(*fp)(int, char) = [](auto a, auto b){return a+b;};\n</code></pre>\n<p>The closure type is</p>\n<pre><code>struct/*anonymous*/\n{\n    template&lt;class A,class B&gt;\n    auto operator()(A a,B b) const\n    {\n        return a+b;\n    }\n\n    private:\n        template&lt;class A,class B&gt;\n        static auto __invoke(A a,B b)\n        {\n            return a+b;\n        }\n\n        template&lt;class A,class B,class R&gt;\n        using fptr_t = R(*)(A,B);\n\n    public:\n\n        template&lt;class A,class B,class R&gt;\n        operator fptr_t&lt;R,A,B&gt;() const\n        {\n            return &amp;__invoke&lt;A,B&gt;; // Fixed that manually, they forgot to qualify the template name\n        }\n} L;\n\nint(*fp)(int,char) = L;\n</code></pre>\n<p>(There will be usual template argument deduction performed)</p>\n", "OwnerDisplayName": "user2500922", "LastActivityDate": "2013-06-19T11:33:25.827", "Id": "17190112", "CommentCount": "3", "CreationDate": "2013-06-19T11:33:25.827", "ParentId": "17188485", "Score": "2"}, "17188570": {"PostTypeId": "2", "Body": "<p>The difference is that the first one is function template which you have to define before you use it; once the definition is there, anyone can use it. So it is a reusable piece of code and remains there forever. </p>\n<p>Lambdas, on the other hand, are handy: you can define it when you need it. If the lambda is defined inside a function, as a local object, then only that function can use it and pass it to other functions. It is still reusuable, but less than function template. However  lambdas, defined at namespace level, is as reusable as function template, because anyone can use it. So it is not much different from function template when you define it at namespace level. There can be some corner cases to be discovered by experts. One such case is, you can specialize function template:</p>\n<pre><code>//specialization : possible only in case of template!\ntemplate&lt;&gt; void func(MyClass obj) { /* ... */ }\n</code></pre>\n<p>You cannot do this with lambdas!</p>\n", "LastActivityDate": "2013-06-19T11:20:32.227", "LastEditorUserId": "212858", "Id": "17188570", "CommentCount": "3", "CreationDate": "2013-06-19T10:09:58.090", "ParentId": "17188485", "Score": "8", "OwnerUserId": "415784", "LastEditDate": "2013-06-19T11:20:32.227"}, "17188485": {"ViewCount": "837", "Body": "<p>What are the differences between</p>\n<pre><code>template &lt;typename T&gt; void func( T t ) { /* ... */ }\n</code></pre>\n<p>and the C++14 alternative using lambdas with auto parameters?</p>\n<pre><code>auto func = []( auto t ) { /* ... */ }\n</code></pre>\n<p>Which one should be preferred?</p>\n", "AcceptedAnswerId": "17191171", "Title": "Template functions versus named lambdas with auto parameters", "CreationDate": "2013-06-19T10:05:50.543", "Id": "17188485", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-06-19T10:25:59.753", "LastEditorUserId": "1335865", "LastActivityDate": "2013-06-19T12:26:54.840", "Score": "10", "OwnerUserId": "1335865", "Tags": "<c++><templates><lambda><c++14>", "AnswerCount": "3"}});