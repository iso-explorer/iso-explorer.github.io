post_cb({"bq_ids": {"n4140": {"so_44977326_44977601_0": {"section_id": 6009, "quality": 0.7333333333333333, "length": 11}, "so_44977326_44977601_1": {"section_id": 6074, "quality": 0.8, "length": 4}}, "n3337": {"so_44977326_44977601_0": {"section_id": 5777, "quality": 0.7333333333333333, "length": 11}, "so_44977326_44977601_1": {"section_id": 5842, "quality": 0.8, "length": 4}}, "n4659": {"so_44977326_44977601_0": {"section_id": 7508, "quality": 0.7333333333333333, "length": 11}, "so_44977326_44977601_1": {"section_id": 7570, "quality": 0.8, "length": 4}}}, "44977326": {"CommentCount": "10", "AcceptedAnswerId": "44977407", "PostTypeId": "1", "LastEditorUserId": "1324", "CreationDate": "2017-07-07T18:18:02.480", "LastActivityDate": "2017-08-14T14:01:53.283", "LastEditDate": "2017-08-14T14:01:53.283", "ViewCount": "91", "FavoriteCount": "1", "Title": "Postfix and prefix increment that causes an error", "Id": "44977326", "Score": "2", "Body": "<p>Why does that code does not compile due to an error:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int i = 0; \n    cout &lt;&lt; ++(i++) &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>While that code does compile:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int i = 0; \n    cout &lt;&lt; (++i)++ &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>I do not understand that. From my point of view it would be pretty reasonable for the first chunk to compile. The expression ++(i++) would just mean take i, increment it and output, then increment it again.</p>\n<p>I am not asking about an undefined behavior in int overflow. I do not know about r and l value at all at the time of writing the question and I do not care why is ++i considered an l-value, but i++ is not.</p>\n", "Tags": "<c++><increment><postfix-notation><prefix-notation>", "OwnerUserId": "7909529", "AnswerCount": "3"}, "44977928": {"ParentId": "44977326", "CommentCount": "0", "Body": "<p>When you compile it with clang you get error message that says it all.</p>\n<pre><code>&lt;source&gt;:8:13: error: expression is not assignable\ncout &lt;&lt; ++(i++) &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl;\n</code></pre>\n<p>Maybe it is good to start with ++ operator. In fact it is shorthand for <code>i = i + 1</code>. Now if we look at postfix version i++, it says in standard that it returns copy of original value and as <code>side efect</code> it increments original value.\nSo from (i++) you get rvalue and are trying to assign to it and as we know you can't assign to rvalue.  </p>\n", "OwnerUserId": "8113019", "PostTypeId": "2", "Id": "44977928", "Score": "1", "CreationDate": "2017-07-07T18:58:47.840", "LastActivityDate": "2017-07-07T18:58:47.840"}, "44977407": {"ParentId": "44977326", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is because the post increment and pre increment operators return values with different types. Result of post increment is a so-called 'rvalue', meaning it can not be modified. But pre-increment needs a modifiable value to increment it!</p>\n<p>On the other hand, result of pre-increment is an lvalue, meaning that it can be safely modified by the post increment.</p>\n<p>And the reason for above rules is the fact that post-increment needs to return a value of the object as it was before increment was applied. By the way, this is why in general case post-incrememts are considered to be more expensive than pre-increments when used on non-builtin objects.</p>\n", "OwnerUserId": "5245033", "LastEditorUserId": "3980929", "LastEditDate": "2017-07-07T18:29:53.110", "Id": "44977407", "Score": "5", "CreationDate": "2017-07-07T18:23:35.140", "LastActivityDate": "2017-07-07T18:29:53.110"}, "44977601": {"ParentId": "44977326", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Shortly speaking the difference is that in C++ you may use any even number of pluses (restricted only by the compiler limits) for the prefix increment operator like this</p>\n<pre><code>++++++++++++++++i;\n</code></pre>\n<p>and only two pluses for the post increment operator</p>\n<pre><code>i++;\n</code></pre>\n<p>The postfix increment operator returns a value (The C++ Standard, 5.2.6 Increment and decrement)</p>\n<blockquote>\n<p id=\"so_44977326_44977601_0\">1 The value of a postfix ++ expression is the <strong>value of its\n  operand</strong>. [ Note: the value obtained is a copy of the original value\n  \u2014end note ]</p>\n</blockquote>\n<p>While the prefix increment operator returns its operand after increment (The C++ Standard ,5.3.2 Increment and decrement)</p>\n<blockquote>\n<p id=\"so_44977326_44977601_1\">1  ...<strong>The result is the updated operand; it is an lvalue</strong>...</p>\n</blockquote>\n<p>Opposite to C++ in C you also can apply only two pluses to an object using the prefix increment operator.:) Thus the C compiler will issue an error for such an expression like this</p>\n<pre><code>++++++++++++++++i;\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2017-07-07T18:40:38.620", "Id": "44977601", "Score": "2", "CreationDate": "2017-07-07T18:35:27.917", "LastActivityDate": "2017-07-07T18:40:38.620"}});