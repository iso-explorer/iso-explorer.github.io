post_cb({"46958273": {"CommentCount": "3", "ViewCount": "54", "PostTypeId": "1", "LastEditorUserId": "1919486", "CreationDate": "2017-10-26T15:29:00.757", "LastActivityDate": "2017-10-26T16:29:10.757", "Title": "Amortizing in std::vector::resize and std::vector::push_back", "AcceptedAnswerId": "46958370", "LastEditDate": "2017-10-26T16:21:44.997", "Id": "46958273", "Score": "2", "Body": "<p>We know that the reallocation mechanism takes care of allocating more memory that we actually need when calling <code>std::vector::push_back()</code>.\nUsually the capacity grows with the multiplier 2x or with a golden ratio number ~1.618...</p>\n<p>Assume, we add elements as follows:</p>\n<pre><code>std::vector&lt;int&gt; v;\nfor(unsigned i = 0; i &lt; 100000; ++i)\n{\n    v.resize(v.size() + 1);\n}\n</code></pre>\n<p>Is it guaranteed that the capacity of the vector is \"doubled\" if the reallocation takes place?\nIn other words: would the \"+1 resize\" allocate the memory the same way as it is done for <code>push_back</code>.</p>\n<p>Or it is a pure implementation-depended thing?</p>\n", "Tags": "<c++><vector><resize><capacity>", "OwnerUserId": "1919486", "AnswerCount": "2"}, "46958961": {"ParentId": "46958273", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_46958273_46958961_0\">A vector is a sequence container that supports (amortized) constant\n  time insert and erase operations at the end; [vector.overview]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_46958273_46958961_1\">If size() &lt; sz , appends sz - size() default-inserted elements to the\n  sequence.</p>\n</blockquote>\n<p>for resize. IMHO that means, yes, it is guaranteed that the capacity of the vector is \"doubled\" if the reallocation takes place</p>\n", "OwnerUserId": "2672107", "PostTypeId": "2", "Id": "46958961", "Score": "0", "CreationDate": "2017-10-26T16:05:25.203", "LastActivityDate": "2017-10-26T16:05:25.203"}, "bq_ids": {"n4140": {"so_46958273_46958961_0": {"section_id": 955, "quality": 0.9166666666666666, "length": 11}, "so_46958273_46958961_1": {"section_id": 810, "quality": 1.0, "length": 6}}, "n3337": {"so_46958273_46958961_0": {"section_id": 943, "quality": 0.9166666666666666, "length": 11}, "so_46958273_46958961_1": {"section_id": 801, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_46958273_46958961_0": {"section_id": 1016, "quality": 0.9166666666666666, "length": 11}, "so_46958273_46958961_1": {"section_id": 868, "quality": 1.0, "length": 6}}}, "46958370": {"ParentId": "46958273", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_46958273_46958370_0\">Is it guaranteed that the capacity of the vector is \"doubled\" if the reallocation takes place?</p>\n</blockquote>\n<p>No. The complexity of memory reallocation is amortized constant.  Whether the capacity of the object is doubled when needed or increased by another factor is implementation dependent.</p>\n<blockquote>\n<p id=\"so_46958273_46958370_1\">would the \"+1 resize\" allocate the memory the same way as it is done for push_back</p>\n</blockquote>\n<p>Yes.</p>\n<p><code>std::vector::resize(size_type sz)</code>  appends <code>sz - size()</code> value-initialized elements to the sequence when <code>sz</code> is greater than <code>size()</code>. That is equivalent to:</p>\n<pre><code> insert(end(), sz-size(), &lt;value initialized object&gt;);\n</code></pre>\n<p><code>std::vector::insert</code>, <code>std::vector::emplace</code>, and <code>std::vector::push_back</code> have the same complexity for memory allocation - amortized constant.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2017-10-26T16:29:10.757", "Id": "46958370", "Score": "1", "CreationDate": "2017-10-26T15:34:39.610", "LastActivityDate": "2017-10-26T16:29:10.757"}});