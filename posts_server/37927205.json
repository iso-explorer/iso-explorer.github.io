post_cb({"45749833": {"ParentId": "37927205", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-08-18T06:25:10.240", "Score": "1", "LastEditorUserId": "641507", "LastEditDate": "2017-08-18T07:25:25.873", "Id": "45749833", "OwnerUserId": "641507", "Body": "<p>This is something I've been trying to figure out myself. I had a hypothesis, but no real evidence for it. However, the document the rule originated in (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf\" rel=\"nofollow noreferrer\">N2079</a> as linked by @T.C.) confirmed part of my theory.</p>\n<p>Note that the function that the rule comes from takes in a <code>std::seed_seq</code> object in the document, and not a templated class. This means that when the rule was written, it was made specifically for <code>std::seed_seq</code>, and not the concept of a SeedSequence in general. This means that we can look at the <code>std::seed_seq</code> class for information about this, specifically with how <code>std::seed_seq::generate</code> is defined.</p>\n<p>The method that <code>std::seed_seq::generate</code> uses is well explained <a href=\"http://en.cppreference.com/w/cpp/numeric/random/seed_seq/generate\" rel=\"nofollow noreferrer\">on cppreference.com</a>. It's a bit complicated, but it can be summarized in 4 stages.</p>\n<ol>\n<li><p>Initialize the output range with some initial data (I'm including <code>k=0</code> here)</p></li>\n<li><p>Move the original seed data into the output range (<code>k=1..s</code>)</p></li>\n<li><p>Extend the seed data into the rest of the output range (<code>k=s+1..m-1</code> where <code>m=max(s+1, n)</code>)</p></li>\n<li><p>Shuffle the data in the output range (<code>k=m..m+n-1</code>)</p></li>\n</ol>\n<p>When seeding a <code>std::linear_congruential_engine</code> with the modulo &lt;= 2<sup>32</sup> (which includes <code>std::minstd_rand</code> and <code>std::minstd_rand0</code>), it should only need to generate 1 value from <code>std::seed_seq</code>, but with this rule, it generates 4. So what changes in this algorithm when changing <code>n</code> from 1 to 4?</p>\n<p>One part that changes is that the shuffling stage goes from 1 iteration to 4. Since one of the goals of <code>std::seed_seq</code> is to produce high quality seeding values \"given a small seed or a poorly distributed initial seed sequence.`, these extra shuffling iterations likely improve the resulting seed value. The reason why it drops the first 3 values instead of the last is because the later values are (usually) the ones that get shuffled more.</p>\n<p>It's also worth noting that a key equation of all 4 stages is the value <code>begin[k]^begin[k+p]^begin[k\u22121]</code> (with XOR replaced with addition in the last stage). When <code>n=1</code>, this simply becomes <code>begin[k]</code> (or <code>3*begin[k]</code> for the last stage) (note that \"the indexing of the output range <code>begin[x]</code> is taken modulo n\" and <code>x % 1 == 0</code>). When <code>n=4</code>, this equation works more like it was intended to, which helps shuffle the data around more effectively.</p>\n<p>So the short answer is that <code>std::linear_congruential_engine</code> discards 3 numbers generated by the seed sequence because having <code>std::seed_seq</code> generate those numbers improves the quality of the values it actually uses. Now, the decision to discard these numbers in the generator was decided before the <em>generic concept</em> of SeedSequence was defined, so it made more sense to solve the issue in the generator, instead of overcomplicating the seed sequence class. However, this now means that the first 3 values generated by <strong>any</strong> seed sequence are discarded. Whether or not that's worth it is probably debatable, but it is the way it is now.</p>\n", "LastActivityDate": "2017-08-18T07:25:25.873"}, "37927205": {"CommentCount": "3", "ViewCount": "99", "CreationDate": "2016-06-20T16:12:53.923", "LastActivityDate": "2017-08-18T07:25:25.873", "Title": "Why does linear_congruential_engine::seed(Sseq) discard three numbers generated by the seed sequence?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "37927205", "Score": "6", "Body": "<p>The C++ standard (all the way from C++11 to the current C++17 draft) says the following in [rand.eng.lcong]:</p>\n<blockquote>\n<pre><code>template&lt;class Sseq&gt; explicit linear_congruential_engine(Sseq&amp; q);\n</code></pre>\n<p id=\"so_37927205_37927205_0\"><em>Effects:</em> Constructs a <code>linear_congruential_engine</code> object. With <em>k</em> = \u2308log<sub>2</sub>(<em>m</em>) \u00f7 32\u2309 and <em>a</em> an array 32 (or equivalent) of length <em>k</em> + 3, invokes <code>q.generate(a + 0, a + k + 3)</code> and then computes <em>S</em> = (\u2211<sub><em>j</em>=0</sub><sup><em>k</em>\u22121</sup> <em>a</em><sub><em>j</em>+3</sub> \u00b7 2<sup>32\u200b<em>j</em></sup>) mod <em>m</em>. If <em>c</em> mod <em>m</em> is 0 and <em>S</em> is 0, sets the engine\u2019s state to 1, else sets the engine\u2019s state to S.</p>\n</blockquote>\n<p>Why are <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub> and <em>a</em><sub>2</sub> discarded?</p>\n", "Tags": "<c++>", "OwnerUserId": "865331", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37927205_37927205_0": {"section_id": 3531, "quality": 0.68, "length": 17}}, "n3337": {"so_37927205_37927205_0": {"section_id": 3396, "quality": 0.68, "length": 17}}, "n4659": {"so_37927205_37927205_0": {"section_id": 4295, "quality": 0.68, "length": 17}}}});