post_cb({"bq_ids": {"n4140": {"so_35229620_35230278_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5895}}, "n3337": {"so_35229620_35230278_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5666}}, "n4659": {"so_35229620_35230278_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 7378}}}, "35229620": {"ViewCount": "163", "Body": "<p>So what I wanted to do is to store:</p>\n<ul>\n<li>object B in object A and </li>\n<li>reference of object A in object B </li>\n</ul>\n<p>while not using pointers.</p>\n<p>The only difference between using pointers and references I try to avoid is accessing syntax. I don't want to write '-&gt;' each time I access an object A in object B.</p>\n<p>Code I thought could work but throws segmentation fault:</p>\n<p>A.h</p>\n<pre><code>#ifndef A_H\n#define A_H\n\nclass B;\nclass A{\n    B b;\npublic:\n    A();\n};\n#endif\n</code></pre>\n<p>B.h</p>\n<pre><code>#ifndef B_H\n#define B_H\n\nclass A;\nclass B{\n    A&amp; a;\npublic:\n    B(A &amp;_a);\n};\n#endif\n</code></pre>\n<p>A.cpp</p>\n<pre><code>#include \"A.h\"\n#include \"B.h\"\n\nA::A():b(B(*this)){}\n</code></pre>\n<p>B.cpp</p>\n<pre><code>#include \"B.h\"\n#include \"A.h\"\n\nB::B(B &amp;_b):a(_b){}    \n</code></pre>\n<p>First thing I thought was causing segmentation fault was using 'this' keyword (of uninititialized instance) in initializer-list, but I've read that as long as I don't access it everything should be OK. My constructors are empty so I don't what could be wrong.</p>\n<p>Is it possible to do it similar to how I am doing it? And if no then why and is there something that could allow me to not write '-&gt;'?</p>\n<p><strong>EDIT:</strong>\nIndeed there were some compilation errors because it was just written as pseudocode just to not paste unnecessary code here so nobody has to waste time. After writing the pseudocode of course it compiled. <a href=\"https://i.stack.imgur.com/qxxSI.jpg\" rel=\"nofollow noreferrer\"><img alt=\"But\" src=\"https://i.stack.imgur.com/qxxSI.jpg\"/></a> goo.gl/DHlM6X</p>\n<p>But now it runs without seg fault. I guess there is something that I do differently in my project. I will have to test for some time why it doesn't work in project and I will post what was the problem so the Question could have real answer.</p>\n", "AcceptedAnswerId": "35230278", "Title": "Object B in object A and reference of object A in object B without pointers", "CreationDate": "2016-02-05T17:03:10.093", "Id": "35229620", "CommentCount": "6", "LastEditDate": "2016-02-05T20:16:15.500", "PostTypeId": "1", "LastEditorUserId": "2326991", "LastActivityDate": "2016-02-05T20:16:15.500", "Score": "0", "OwnerUserId": "2326991", "Tags": "<c++><constructor><reference><initialization><initializer-list>", "AnswerCount": "1"}, "35230278": {"Id": "35230278", "PostTypeId": "2", "Body": "<p>At first it might seem a good idea to use references here and not to mess with pointers, but you don't help yourself with this. Why? A reference is meant to link to an object where you can be sure the linked object lives longer than the reference.</p>\n<p>So your code </p>\n<pre><code>class B{\n  A&amp; a;\n};\n</code></pre>\n<p>basically states: \"For every object of type <code>B</code> there is a known, not changeable object of type <code>A</code> that exists before the object of type <code>B</code> is created and will still live at the time the <code>B</code>-object is destructed\".</p>\n<p>At the same time your code</p>\n<pre><code>class A{\n  B b;\n};\n</code></pre>\n<p>states: \"Every object of type <code>A</code> consists of an object of type <code>B</code>\", which basically tells to compiler to allocate memory for an object of type <code>A</code> (including the space for <code>B b</code>), then construct an object of type <code>B</code> at the right position inside that memory and then construct an object of type <code>A</code>. But in this example A is constructed <strong>after</strong> B and destroyed <strong>before</strong> B.</p>\n<p>Both statements exclude each other.</p>\n<p>So either you switch to pointers (which state \"The object knows about another object of type <code>X</code>\" and can be the <code>nullptr</code>) or you might consider doing something like this:</p>\n<pre><code>class Combined{\n  A a;\n  B b;\n}\n</code></pre>\n<p>and then add functions that need to know about both objects in the <code>Combined</code> class.</p>\n<p>In the standard i found the following about your problem and why it shouldn't work at all:</p>\n<blockquote>\n<p id=\"so_35229620_35230278_0\">9.3.2 <strong>The this pointer [class.this]</strong><br>\n  In the body of a non-static (9.3) member function, the keyword this\n  is a prvalue expression whose value is the address of the object for which the function is called. The type of this in a member function of\n  a class X is X*. If the member function is declared const(...)</br></p>\n</blockquote>\n<p>So from what i can say, <code>this</code> has only defined behaviour \"inside the body of a non-static member function\". Some compilers allow <code>this</code>, <code>typeid(this)</code> or <code>sizeof(this)</code> also in other parts of the class, but i couldn't find this in the standard.</p>\n", "LastActivityDate": "2016-02-05T17:40:49.703", "CommentCount": "2", "CreationDate": "2016-02-05T17:40:49.703", "ParentId": "35229620", "Score": "1", "OwnerUserId": "3193464"}});