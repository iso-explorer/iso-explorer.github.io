post_cb({"2140182": {"ParentId": "2140025", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to paragraph 14.8.2.1 of the C++ standard, when a template parameter is used only in a non-deduced context, the corresponding template argument cannot be deduced:</p>\n<blockquote>\n<p id=\"so_2140025_2140182_0\">If a <em>template-parameter</em> is not used in any of the function parameters of a function template, or is used only in a non-deduced context, its corresponding <em>template-argument</em> cannot be deduced from a function call and the <em>template-argument</em> must be explicitly specified.</p>\n</blockquote>\n<p>The definition of nondeduced contexts, as stated in \u00a714.8.2.4:</p>\n<blockquote>\n<p id=\"so_2140025_2140182_1\">The nondeduced contexts are:</p>\n<ul>\n<li><p id=\"so_2140025_2140182_2\">the <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.</p></li>\n<li><p id=\"so_2140025_2140182_3\">A type that is a <em>template-id</em> in wich one or more of the <em>template-arguments</em> is an expression that references a <em>template-parameter</em>.</p></li>\n</ul>\n</blockquote>\n<p>In <code>Bar&lt;T&gt;::type</code>, <code>Bar&lt;T&gt;</code> is a <em>nested-name-specifier</em> and hence a non-deduced context, so you must explicitly specify the template argument when calling the constructor...which is not possible (i.e. you cannot write <code>Foo f&lt;int&gt;(v)</code>).</p>\n<p>I suppose the compiler cannot deduce the template argument because that would be at least cumbersome, and more probably impossible: imagine Bar is specialized:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Bar\n{\n    typedef std::pair&lt;T,T&gt; type;\n};\n\ntemplate&lt;&gt;\nstruct Bar&lt;char&gt;\n{\n    typedef std::pair&lt;int,int&gt; type;\n};\n</code></pre>\n<p>Now I have an ambiguity when calling Foo's constructor with <code>std::vector&lt;std::pair&lt;int,int&gt; &gt;</code>: should the template argument be <code>int</code> or <code>char</code>? And even if there was no such ambiguity, you can easily see that the compiler would have to instantiate Bar with potentially any type before finding the instantiation with the correct typedef (well, I'm not so sure above statements are truly relevant since I often find out compilers to be much more smarter than I thought :-)!)</p>\n", "OwnerUserId": "20984", "LastEditorUserId": "20984", "LastEditDate": "2010-01-26T15:30:33.063", "Id": "2140182", "Score": "9", "CreationDate": "2010-01-26T14:59:47.423", "LastActivityDate": "2010-01-26T15:30:33.063"}, "2140650": {"ParentId": "2140025", "CommentCount": "0", "Body": "<p>I think the only reason for that is that you want to instantiate a Bar of corresponding type instead of printing \"hello\".</p>\n<p>Perhaps you could try mapping the types in the reversed direction (the kind of reversed deduction that you are hoping the compiler would be able to perform):</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nstruct BarType;\n\ntemplate &lt;class T&gt;\nstruct BarType&lt;std::pair&lt;T, T&gt; &gt;\n{\n    typedef T type;\n};\n\ntemplate &lt;class T&gt;\nstruct Bar {};\n\nstruct Foo\n{\n    template &lt;class T&gt;\n    Foo(const std::vector&lt;T&gt;&amp; )\n    {\n        Bar&lt;typename BarType&lt;T&gt;::type&gt; bar;\n        //...\n    }\n};\n\nint main()\n{\n    Foo(std::vector&lt;std::pair&lt;int, int&gt; &gt;());\n}\n</code></pre>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "2140650", "Score": "0", "CreationDate": "2010-01-26T16:09:55.663", "LastActivityDate": "2010-01-26T16:09:55.663"}, "2141483": {"ParentId": "2140025", "CommentCount": "0", "Body": "<p>Could something like this work for you?</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;boost/static_assert.hpp&gt;\n\ntemplate &lt;typename T&gt;\nstruct Bar\n{\n    typedef std::pair&lt;T, T&gt; type; // or anything else that uses T\n    enum {val = 42};\n};\n\ntemplate &lt;typename T&gt;\nstruct Traits\n{\n    enum {allowed = false};\n};\n\ntemplate &lt;typename T&gt;\nstruct Traits&lt;std::pair&lt;T, T&gt; &gt;\n{\n    enum {allowed = true};\n    typedef Bar&lt;T&gt; BarType;\n};\n\nstruct Foo\n{\n    Foo() {}\n\n    template &lt;typename T&gt; explicit Foo( const std::vector&lt;T&gt;&amp; data )\n    {\n        BOOST_STATIC_ASSERT(Traits&lt;T&gt;::allowed);\n        typedef typename Traits&lt;T&gt;::BarType BarType;\n        std::cout &lt;&lt; BarType::val &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    std::vector&lt;Bar&lt;int&gt;::type&gt; v;\n    std::vector&lt;float&gt; v2;\n\n    Foo f( v );\n//    Foo f2( v2 ); // Compile error\n    return 0;\n}\n</code></pre>\n<p>This compiles and runs on GCC 4.4.1. You can specialize <code>Traits</code> for other <code>vector::value_type</code>'s that are allowed by your constructor.</p>\n", "OwnerUserId": "245265", "PostTypeId": "2", "Id": "2141483", "Score": "0", "CreationDate": "2010-01-26T18:00:15.200", "LastActivityDate": "2010-01-26T18:00:15.200"}, "2140084": {"ParentId": "2140025", "CommentCount": "1", "Body": "<p>Your constructor is:</p>\n<pre><code>template &lt;typename T&gt; \nexplicit \nFoo( const std::vector&lt;typename Bar&lt;T&gt;::type&gt;&amp; data )\n</code></pre>\n<p>The template argument <code>T</code> cannot be deduced from the function argument this way. (I think this is called a \"non-deducible context\", but I'm not sure.) </p>\n<p>This simply won't work. You'll have to write </p>\n<pre><code>template &lt;typename B&gt; \nexplicit \nFoo( const std::vector&lt;B&gt;&amp; data )\n</code></pre>\n<p>instead and find other ways to assert that <code>B</code> is of type <code>typename Bar&lt;T&gt;::type</code>. </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "2140084", "Score": "4", "CreationDate": "2010-01-26T14:45:13.893", "LastActivityDate": "2010-01-26T14:45:13.893"}, "2140025": {"CommentCount": "3", "AcceptedAnswerId": "2140182", "CreationDate": "2010-01-26T14:35:17.073", "LastActivityDate": "2010-01-26T18:00:15.200", "PostTypeId": "1", "ViewCount": "4728", "FavoriteCount": "2", "Title": "C++ templated constructor won't compile", "Id": "2140025", "Score": "5", "Body": "<p>How come I can't instantiate an object of type Foo with above constructor?</p>\n<p>I have a class Bar that uses an internal typedef (as a workaround for \"template typedefs\") and intend to use it in a constructor as below (CASE 1).\nHowever, I don't seem to get it to compile. Is this legal C++?\nCASE 2 seems to suggest the problem is related to the typedef in Bar.</p>\n<p>How can I define a constructor that will accept std::vectors of objects with the type in Bar?</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nstruct Bar\n{\n    typedef std::pair&lt;T, T&gt; type; // or anything else that uses T\n};\n\nstruct Foo\n{\n    Foo() {}\n\n    // CASE 1: doesn't compile\n    template &lt;typename T&gt; explicit Foo( const std::vector&lt;typename Bar&lt;T&gt;::type&gt;&amp; data )\n    {\n        std::cout &lt;&lt; \"Hello\\n\";\n    }\n\n    //// CASE 2: compiles, but it's not what I want\n    //template &lt;typename T&gt; explicit Foo( const std::vector&lt;Bar&lt;T&gt; &gt;&amp; data )\n    //{\n    //  std::cout &lt;&lt; \"Hello\\n\";\n    //}\n};\n\nint main()\n{\n    std::vector&lt;Bar&lt;int&gt;::type&gt; v; // for CASE 1\n    //std::vector&lt;Bar&lt;int&gt; &gt; v; // for CASE 2\n\n    Foo f( v );\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><constructor><typedef><typename>", "OwnerUserId": "218634", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_2140025_2140182_0": {"section_id": 306, "quality": 1.0, "length": 18}, "so_2140025_2140182_2": {"section_id": 336, "quality": 1.0, "length": 6}}, "n3337": {"so_2140025_2140182_0": {"section_id": 297, "quality": 1.0, "length": 18}, "so_2140025_2140182_2": {"section_id": 326, "quality": 1.0, "length": 6}}, "n4659": {"so_2140025_2140182_0": {"section_id": 313, "quality": 1.0, "length": 18}, "so_2140025_2140182_2": {"section_id": 345, "quality": 1.0, "length": 6}}}});