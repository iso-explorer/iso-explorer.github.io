post_cb({"11656916": {"ParentId": "11656794", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Remove the extra bits by masking with <code>0xFF</code>:</p>\n<pre><code>result = (((value &lt;&lt; 3) &amp; 0xFF) &gt;&gt; 2);\n</code></pre>\n<p>You can also trim the upper three bits off after the sequence of shifts:</p>\n<pre><code>result = 0x1F &amp; ((value &lt;&lt; 3) &gt;&gt; 2);\n</code></pre>\n<p>According to the language specification, default integer promotions are applied to shift operands before shifting, and the result of the operation is the promoted type of the first operand.</p>\n<blockquote>\n<p id=\"so_11656794_11656916_0\">5.8.1 The operands shall be of integral or enumerated type and integral promotions are performed. The type of the result is that of the promoted left operand.</p>\n</blockquote>\n<p>If an integral type can fit in an <code>int</code>, then <code>int</code> is the result of the promotion. When you shift left, the most significant bits \"spill\" into the upper part of the <code>int</code>. Your first snippet cuts them off by assigning back to <code>byte</code>; you can achieve the same result by masking the result with <code>0xFF</code>.</p>\n<p><a href=\"http://ideone.com/5GCSs\" rel=\"nofollow\">Link to ideone</a>.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2012-07-25T19:27:55.203", "Id": "11656916", "Score": "5", "CreationDate": "2012-07-25T19:13:46.430", "LastActivityDate": "2012-07-25T19:27:55.203"}, "11656794": {"CommentCount": "2", "AcceptedAnswerId": "11656944", "CreationDate": "2012-07-25T19:06:00.253", "LastActivityDate": "2012-07-25T22:59:39.553", "PostTypeId": "1", "ViewCount": "884", "FavoriteCount": "1", "Title": "bit shift - shifting a shifted value", "Id": "11656794", "Score": "3", "Body": "<p>I have tried to make a longer function but it has acted very weird. I had tried to isolate the  problem and I have been able to find the buggy part.</p>\n<p>This program made for an Arduino but this phenomenon probably appear in other environment. I have tried to make a lot of searches but I cannot find the solution.</p>\n<h2>So, my buggy part:</h2>\n<p><strong>Why do not these two codes give the same result?<br>\nHow can I construct a one line function without extra variable<br>\nbut same operation like \"Code 1\"?</br></br></strong></p>\n<p>Results:</p>\n<ul>\n<li>Code 1: 0b00101100</li>\n<li>Code 2: 0b01101100</li>\n</ul>\n<p>Source codes:</p>\n<hr>\n<p>Code 1: (correct operation but not one line)</p>\n<pre><code>#include &lt;binary.h&gt;\n\nconst byte value=B00110110;\nbyte buffer,result;\n\nvoid setup(){\n  Serial.begin(115200);\n\n  buffer = (value &lt;&lt; 3);\n  result = (buffer &gt;&gt; 2);\n\n  Serial.println(result,BIN);\n}\n\nvoid loop(){\n}\n</code></pre>\n<p>It gives: <strong>0b00101100</strong></p>\n<hr>\n<p>Code 2: (incorrect operation but one line)</p>\n<pre><code>#include &lt;binary.h&gt;\n\nconst byte value=B00110110;\nbyte result;\n\nvoid setup(){\n  Serial.begin(115200);\n\n  result = ((value &lt;&lt; 3) &gt;&gt; 2);\n\n  Serial.println(result,BIN);\n}\n\nvoid loop(){\n}\n</code></pre>\n<p>It gives: <strong>0b01101100</strong></p>\n<hr>\n</hr></hr></hr>", "Tags": "<c++><arduino><bit-manipulation><bit-shift><shift>", "OwnerUserId": "1124446", "AnswerCount": "3"}, "11656883": {"ParentId": "11656794", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If <code>byte</code> is a <code>uint8_t</code> (thanks Mr. Fernandes!), the result of <code>(value &lt;&lt; 3)</code> is wider than a <code>byte</code>. More precisely, <code>value</code> is promoted to a wider type before the shift occurs, and the result is that wider type. To get the behavior of Code 1, you can change Code 2 to do this:</p>\n<pre><code>result = (static_cast&lt;byte&gt;(value &lt;&lt; 3) &gt;&gt; 2);\n</code></pre>\n<p>This mimics the intermediate assignment to <code>buffer</code> in Code 1 with a cast.</p>\n", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2012-07-25T22:59:39.553", "Id": "11656883", "Score": "3", "CreationDate": "2012-07-25T19:11:59.920", "LastActivityDate": "2012-07-25T22:59:39.553"}, "bq_ids": {"n4140": {"so_11656794_11656916_0": {"section_id": 6146, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_11656794_11656916_0": {"section_id": 5909, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_11656794_11656916_0": {"section_id": 7642, "quality": 0.7333333333333333, "length": 11}}}, "11656944": {"ParentId": "11656794", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I assume that your <code>byte</code> is some unsigned integral type smaller than <code>int</code>.</p>\n<p>Most arithmetic operations in C++ are performed in the domain of <code>int</code> type, after all \"smaller\" operands are implicitly converted (<em>promoted</em>) to type <code>int</code>. </p>\n<p>For this reason, your first group of shifts is equivalent to </p>\n<pre><code>buffer = (byte) ((int) value &lt;&lt; 3);\nresult = (byte) ((int) buffer &gt;&gt; 2);\n</code></pre>\n<p>while your second group if shifts is equivalent to </p>\n<pre><code>result = (byte) (((int) value &lt;&lt; 3) &gt;&gt; 2);\n</code></pre>\n<p>In the first variant, any bits that get shifted outside the range of type <code>byte</code> by the <code>&lt;&lt; 3</code> shift are lost during intermediate conversion and assignment to <code>buffer</code>. In the second variant all calculations are performed within the range of <code>int</code>, so nothing is lost.</p>\n<p>If you want your second variant to produce the same results as the first, you need to explicitly \"truncate\" the intermediate shift result</p>\n<pre><code>result = ((byte) (value &lt;&lt; 3) &gt;&gt; 2);\n</code></pre>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-07-25T19:28:55.513", "Id": "11656944", "Score": "2", "CreationDate": "2012-07-25T19:15:44.323", "LastActivityDate": "2012-07-25T19:28:55.513"}});