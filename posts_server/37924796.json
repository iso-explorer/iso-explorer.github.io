post_cb({"37926042": {"ParentId": "37924796", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As Holt mentioned the standard is very strict when it comes to variadic template parameters deduction: </p>\n<blockquote>\n<p id=\"so_37924796_37926042_0\">14.8.2.5/9</p>\n<p id=\"so_37924796_37926042_1\">If P has a form that contains T or i, then each argument Pi of the \n  respective template argument list P is compared with the corresponding\n  argument Ai of the corresponding template argument list of A. <strong>If the\n  template argument list of P contains a pack expansion that is not the\n  last template argument, the entire template argument list is a\n  non-deduced context.</strong> If Pi is a pack expansion, then the pattern of Pi\n  is compared with each remaining argument in the template argument list\n  of A. Each comparison deduces template arguments for subsequent\n  positions in the template parameter packs expanded by Pi.</p>\n</blockquote>\n<p>This as interpreted by T.C. would mean that <code>Ts1...</code> can be deduced from the second argument but it leaves no room to <code>Ts2...</code> deduction. As such apparently clang would be the right here and gcc would be wrong... The overload should be therefor chosen <strong>only if</strong> the second parameter would contain exactly the same template parameters e.g:</p>\n<pre><code>starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, double&gt;())\n</code></pre>\n<p>Still example 5. does not fulfil this requirement and does not allow compiler to chose the overload.</p>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2016-06-21T15:39:37.797", "Id": "37926042", "Score": "4", "CreationDate": "2016-06-20T15:14:35.817", "LastActivityDate": "2016-06-21T15:39:37.797"}, "37925434": {"ParentId": "37924796", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>information only: not an answer. This is a response to a question in the comments:</p>\n<p>on gcc5.3 making the following small change induces it to produce the expected results, or at least the same results as clang.</p>\n<pre><code>rhodges@dingbat:~$ cat nod.cpp\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class... Ts&gt;\nstruct pack { };\n\ntemplate &lt;class a, class b&gt;\nconstexpr bool starts_with(a, b) {\n    return false;\n}\n\ntemplate &lt;typename... Ts1, typename... Ts2 &gt;\nconstexpr bool starts_with(pack&lt;Ts1..., Ts2...&gt;, pack&lt;Ts1...&gt;) {\n    return true;\n}\n\nint main() {\n   std::cout &lt;&lt; std::boolalpha;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;float, int, double&gt;()) &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, double, int&gt;()) &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, int&gt;()) &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, double&gt;()) &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int&gt;()) &lt;&lt; std::endl;\n}\n\n\nrhodges@dingbat:~$ g++ -std=c++14 nod.cpp &amp;&amp; ./a.out\nfalse\nfalse\nfalse\ntrue\nfalse\nrhodges@dingbat:~$ g++ --version\ng++ (Ubuntu 5.3.1-14ubuntu2.1) 5.3.1 20160413\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nrhodges@dingbat:~$\n</code></pre>\n<p>and for the record, modifying the program to evaluate all packs in deduced contexts brings success on both platforms:</p>\n<pre><code>rhodges@dingbat:~$ cat nod.cpp\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class... Ts&gt;\nstruct pack { };\n\ntemplate &lt;class a, class b&gt;\nconstexpr bool starts_with_impl(a, b) {\n    return false;\n}\n\ntemplate&lt;typename...LRest&gt;\nconstexpr bool starts_with_impl(pack&lt;LRest...&gt;, pack&lt;&gt;)\n{\n    return true;\n}\n\ntemplate&lt;typename First, typename...LRest, typename...RRest&gt;\nconstexpr bool starts_with_impl(pack&lt;First, LRest...&gt;, pack&lt;First, RRest...&gt;)\n{\n    return starts_with_impl(pack&lt;LRest...&gt;(), pack&lt;RRest...&gt;());\n}\n\ntemplate &lt;typename... Ts1, typename... Ts2 &gt;\nconstexpr bool starts_with(pack&lt;Ts2...&gt; p1, pack&lt;Ts1...&gt; p2) {\n    return starts_with_impl(p1, p2);\n}\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;float, int, double&gt;()) &lt;&lt; std::endl;\n    std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, double, int&gt;()) &lt;&lt; std::endl;\n    std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, int&gt;()) &lt;&lt; std::endl;\n    std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int, float, double&gt;()) &lt;&lt; std::endl;\n    std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(), pack&lt;int&gt;()) &lt;&lt; std::endl;\n}\n\n\nrhodges@dingbat:~$ g++ -std=c++14 nod.cpp &amp;&amp; ./a.out\nfalse\nfalse\nfalse\ntrue\ntrue\n</code></pre>\n<p>Credit to W.F. for guiding me in this direction.</p>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2016-06-20T14:58:46.350", "Id": "37925434", "Score": "2", "CreationDate": "2016-06-20T14:45:32.950", "LastActivityDate": "2016-06-20T14:58:46.350"}, "37924796": {"CommentCount": "10", "ViewCount": "358", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-20T14:14:14.033", "LastActivityDate": "2016-06-21T15:39:37.797", "Title": "Which is the more specialized template function? clang and g++ differ on that", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:10:15.510", "Id": "37924796", "Score": "18", "Body": "<p>While playing with variadic templates, following <a href=\"https://stackoverflow.com/questions/37767558/is-it-legal-to-partially-specialise-variadic-template-inner-class-with-args-from/37916494#37916494\">this SO question</a> (note: it is not mandatory to go there for following this question), I came to a different behavior of clang (3.8) and g++ (6.1) for the following template overloaded functions:</p>\n<pre><code>template &lt;class... Ts&gt;\nstruct pack { };\n\ntemplate &lt;class a, class b&gt;\nconstexpr bool starts_with(a, b) {\n    return false;\n}\n\ntemplate &lt;template &lt;typename...&gt; class PACK_A,\n          template &lt;typename...&gt; class PACK_B, typename... Ts1, typename... Ts2&gt;\nconstexpr bool starts_with(PACK_A&lt;Ts1..., Ts2...&gt;, PACK_B&lt;Ts1...&gt;) {\n    return true;\n}\n\nint main() {\n   std::cout &lt;&lt; std::boolalpha;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(),\n                            pack&lt;float, int, double&gt;())        &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(),\n                            pack&lt;int, float, double, int&gt;())   &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(),\n                            pack&lt;int, float, int&gt;())           &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(),\n                            pack&lt;int, float, double&gt;())        &lt;&lt; std::endl;\n   std::cout &lt;&lt; starts_with(pack&lt;int, float, double&gt;(),\n                            pack&lt;int&gt;())                       &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Code: <a href=\"http://coliru.stacked-crooked.com/a/b62fa93ea88fa25b\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/b62fa93ea88fa25b</a></p>\n<h2>Output</h2>\n<pre><code>|---|-----------------------------------------------------------------------------|\n| # |starts_with(a, b)                  | expected    | clang (3.8) | g++ (6.1)   |\n|---|-----------------------------------|-------------|-------------|-------------|\n| 1 |a: pack&lt;int, float, double&gt;()      |  false      |  false      |  false      |\n|   |b: pack&lt;float, int, double&gt;()      |             |             |             |\n|---|-----------------------------------|-------------|-------------|--------- ---|\n| 2 |a: pack&lt;int, float, double&gt;()      |  false      |  false      |  false      |\n|   |b: pack&lt;int, float, double, int&gt;() |             |             |             |\n|---|-----------------------------------|-------------|-------------|--------- ---|\n| 3 |a: pack&lt;int, float, double&gt;()      |  false      |  false      |  false      |\n|   |b: pack&lt;int, float, int&gt;()         |             |             |             |\n|---|-----------------------------------|-------------|-------------|--------- ---|\n| 4 |a: pack&lt;int, float, double&gt;()      |  true       |  true       |  false      |\n|   |b: pack&lt;int, float, double&gt;()      |             |             |             |\n|---|-----------------------------------|-------------|-------------|--------- ---|\n| 5 |a: pack&lt;int, float, double&gt;()      |  true       |  false      |  false      |\n|   |b: pack&lt;int&gt;()                     |             |             |             |\n|---|-----------------------------------------------------------------------------|\n</code></pre>\n<p>The last two cases (4 and 5) are in question: are my expectation for the <em>more specialized template</em> wrong? and if so, who is right in case 4, clang or g++? (note that the code compiles without any error or warning on both, yet with different results).</p>\n<p>Trying to answer that myself, I went several times through the \"more specialized\" rules in the spec <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf#page=354\" rel=\"nofollow noreferrer\">(14.5.6.2 Partial ordering of function templates)</a> and in <a href=\"http://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading\" rel=\"nofollow noreferrer\">cppreference</a> -- it seems that the more specialized rule shall give the result I'm expecting (one may expect ambiguity error if not, but this is not the case either). So, what am I missing here?</p>\n<hr>\n<p>Wait (1): please don't rush and bring the \"<a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow noreferrer\">prefer not to overload templates</a>\" of Herb Sutter and his <a href=\"http://www.gotw.ca/gotw/049.htm\" rel=\"nofollow noreferrer\">template methods quiz</a>. These are surely important, but the language still allows templates overloading! (It is indeed a strengthening point why you should prefer not to overload templates -- in some edge cases it may confuse two different compilers, or confuse the programmer. But the question is not whether to use it or not, it is: <strong><em>what is the right behavior if you do use it?</em></strong>).</p>\n<p>Wait (2): please don't rush to bring other possible solutions. There are for sure. Here are two: <a href=\"http://coliru.stacked-crooked.com/a/52b7d44cc4482c24\" rel=\"nofollow noreferrer\">one with inner struct</a> and <a href=\"http://coliru.stacked-crooked.com/a/f93c81352d526dc6\" rel=\"nofollow noreferrer\">another with inner static methods</a>. Both are suitable solutions, both work as expected, yet the question regarding the above template overloading behavior still stays.</p>\n</hr>", "Tags": "<c++><templates><c++11><variadic-templates><method-overloading>", "OwnerUserId": "2085626", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37924796_37926042_1": {"section_id": 340, "quality": 1.0, "length": 53}}, "n3337": {"so_37924796_37926042_1": {"section_id": 330, "quality": 1.0, "length": 53}}, "n4659": {"so_37924796_37926042_1": {"section_id": 349, "quality": 1.0, "length": 53}}}});