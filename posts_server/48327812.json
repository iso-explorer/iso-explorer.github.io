post_cb({"bq_ids": {"n4140": {"so_48327812_48334293_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 6353}, "so_48327812_48334293_4": {"length": 7, "quality": 1.0, "section_id": 5811}, "so_48327812_48334293_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 1268}, "so_48327812_48334293_0": {"length": 13, "quality": 0.8125, "section_id": 1337}}, "n3337": {"so_48327812_48334293_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 6110}, "so_48327812_48334293_4": {"length": 7, "quality": 1.0, "section_id": 5584}, "so_48327812_48334293_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 1266}, "so_48327812_48334293_0": {"length": 13, "quality": 0.8125, "section_id": 1331}}, "n4659": {"so_48327812_48334293_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 7862}, "so_48327812_48334293_4": {"length": 7, "quality": 1.0, "section_id": 7273}, "so_48327812_48334293_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 1388}, "so_48327812_48334293_0": {"length": 13, "quality": 0.8125, "section_id": 1467}}}, "48334293": {"Id": "48334293", "PostTypeId": "2", "Body": "<p>The standard does not specify the implementation. However, we can derive from the standard that your code will work as intended as long as you do not care the evaluation order of the prediction function for each element.</p>\n<p>First, <a href=\"http://eel.is/c++draft/alg.remove\" rel=\"nofollow noreferrer\">[alg.remove]</a> says</p>\n<blockquote>\n<p id=\"so_48327812_48334293_0\"><em>Effects:</em> Eliminates all the elements referred to by iterator <code>i</code> in the range [<code>first</code>, <code>last</code>) for which the following corresponding conditions hold: <code>*i == value</code>, <code>pred(*i) != false</code>.</p>\n<p id=\"so_48327812_48334293_1\">...</p>\n<p id=\"so_48327812_48334293_2\"><em>Complexity:</em> Exactly <code>last - first</code> applications of the corresponding predicate.</p>\n</blockquote>\n<p>These constraints guarantee the prediction function executes <strong>exactly once</strong> for each element.</p>\n<p>Second, <a href=\"http://eel.is/c++draft/res.on.data.races#8\" rel=\"nofollow noreferrer\">[res.on.data.races]/8</a> says</p>\n<blockquote>\n<p id=\"so_48327812_48334293_3\">Unless otherwise specified, C++ standard library functions shall perform all operations solely within the current thread if those operations have effects that are visible to users.</p>\n</blockquote>\n<p>And regarding <a href=\"http://eel.is/c++draft/intro.execution#footnote-53\" rel=\"nofollow noreferrer\">the comment in [intro.execution]/11</a>,</p>\n<blockquote>\n<p id=\"so_48327812_48334293_4\">In other words, function executions do not interleave with each other.</p>\n</blockquote>\n<p>So you can consider an execution of the prediction function atomic in a sense.</p>\n", "LastEditorUserId": "212378", "LastActivityDate": "2018-01-19T04:58:11.530", "Score": "2", "CreationDate": "2018-01-19T04:50:47.230", "ParentId": "48327812", "CommentCount": "0", "OwnerUserId": "5376789", "LastEditDate": "2018-01-19T04:58:11.530"}, "48327812": {"ViewCount": "61", "Body": "<p>I have a vector of weak pointers and want to go through that list and execute a function if the pointer still exists. If the pointer is gone, I want to remove it instead.</p>\n<pre><code>class my_class\n{\npublic:\n    std::shared_ptr&lt;my_class&gt;    pointer_t;\n    std::weak_ptr&lt;my_class&gt;      weak_pointer_t;\n    ...\n\nprivate:\n    ...\n};\n\nclass listeners_class\n{\npublic:\n    typedef std::vector&lt;my_class::weak_ptr&gt;  listeners_t;\n    ...\n\nprivate:\n    listeners_t    f_listeners;\n    ...\n};\n</code></pre>\n<p>I noticed that I could implement that directly in the <code>remove_if()</code> test function since the <code>remove_if()</code> actually loops through the entire vector and attempts a lock on the weak pointer already. Plus this way it is <em>a bit more atomic</em>.</p>\n<p>There is the code with lambda.</p>\n<pre><code>    f_listeners.erase(\n        std::remove_if(\n              f_listeners.begin()\n            , f_listeners.end()\n            , [&amp;ptr](my_class::weak_pointer_t l)\n            {\n                my_class::pointer_t ll(l.lock());\n                if(ll == nullptr)\n                {\n                    return true;\n                }\n                ll-&gt;some_callback(ptr);  // &lt;&lt;-- side effect!\n                return false;\n            })\n        );\n</code></pre>\n<p>I'm thinking that this is bad practice, but would like to confirm whether there is a form of standard about such code.</p>\n", "Title": "Is there a programming standard about algorithms such as erase/remove_if and possible side effects of the remove_if implementation?", "CreationDate": "2018-01-18T18:14:20.507", "LastActivityDate": "2018-01-19T04:58:11.530", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-01-19T04:53:31.690", "LastEditorUserId": "5376789", "Id": "48327812", "Score": "1", "OwnerUserId": "212378", "Tags": "<c++><language-lawyer><stl-algorithm><side-effects>", "AnswerCount": "1"}});