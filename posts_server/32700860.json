post_cb({"bq_ids": {"n4140": {"so_32700860_32701150_3": {"length": 6, "quality": 0.6, "section_id": 3321}}, "n3337": {"so_32700860_32701150_3": {"length": 9, "quality": 0.9, "section_id": 5732}, "so_32700860_32701150_1": {"length": 14, "quality": 1.0, "section_id": 5732}}, "n4659": {"so_32700860_32701150_3": {"length": 7, "quality": 0.7, "section_id": 7667}}}, "32701150": {"Id": "32701150", "PostTypeId": "2", "Body": "<p>When you use:</p>\n<pre><code>auto f = [](int a, int b)-&gt;int\n{\n    return a * b;\n};\n</code></pre>\n<p>the type of <code>f</code> is type of the lambda expression. It is not <code>int</code>, the return type of the lambda expression.</p>\n<p>As far as the <code>-&gt; int</code> part goes, that's the only syntax available to explicitly specify the return type of a lambda expression. It that is omitted, the return type is deduced by the compiler using an algorithm specified by the standard:</p>\n<blockquote>\n<p id=\"so_32700860_32701150_0\"><strong>5.1.2 Lambda expressions</strong></p>\n<p id=\"so_32700860_32701150_1\">4 If a <em>lambda-expression</em> does not include a <em>lambda-declarator</em>, it is as if the <em>lambda-declarator</em> were (). If a <em>lambda-expression</em> does not include a <em>trailing-return-type</em>, it is as if the <em>trailing-return-type</em> denotes the\n  following type:</p>\n<p id=\"so_32700860_32701150_2\">\u2014 if the <em>compound-statement</em> is of the form<br>\n<code>{</code> <em>attribute-specifier-seqopt</em> <code>return</code> <em>expression</em> <code>; }</code></br></p>\n<p id=\"so_32700860_32701150_3\">the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion(4.2), and function-to-pointer conversion (4.3);</p>\n<p id=\"so_32700860_32701150_4\">\u2014 otherwise, void.</p>\n<p id=\"so_32700860_32701150_5\">[ <em>Example:</em></p>\n</blockquote>\n<pre><code> auto x1 = [](int i){ return i; }; // OK: return type is int\n auto x2 = []{ return { 1, 2 }; }; // error: the return type is void (a\n // braced-init-list is not an expression)\n</code></pre>\n<blockquote>\n<p id=\"so_32700860_32701150_6\">\u2014<em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2015-09-21T17:24:32.590", "CommentCount": "0", "CreationDate": "2015-09-21T17:24:32.590", "ParentId": "32700860", "Score": "2", "OwnerUserId": "434551"}, "32701044": {"Id": "32701044", "PostTypeId": "2", "Body": "<pre><code>auto f = [](int a, int b)-&gt;int\n{\n    return a * b;\n};\n</code></pre>\n<p>The <code>f</code> here is a global variable of some anonymous type, holding an instance of the anonymous function object defined after the <code>operator=</code>. Such anonymous function objects are called <em>lambda</em>s, they can occur everywhere where you can have some expression:</p>\n<pre><code>int main(int, char**) {\n  ([](int a) {\n    cout &lt;&lt; \"lambda called with \" &lt;&lt; a &lt;&lt; endl;\n  })(42);\n  return ([](int a, int b) { return a - 2 * b; })(42, 21);\n}\n</code></pre>\n<p>The general syntax of such a lambda expression is the following:</p>\n<pre><code>\"[\"CAPTURE\"]\" PARAMETERS [\"mutable\"] [RETURN] { BODY }\n</code></pre>\n<p><code>CAPTURE</code> being a list of zero ore more of</p>\n<ul>\n<li>variable from the enclosing scope, capture by value</li>\n<li>variable from the enclosing scope, preceeded by <code>&amp;</code>, capture by reference</li>\n<li><code>&amp;</code> means capture all variables from the enclosing scope by reference</li>\n<li><code>=</code> means capture all variables from the enclosing scope by value</li>\n</ul>\n<p><code>PARAMETERS</code> are the usual parameter lists you know from functions, optionally (since C++14) with <code>auto</code> and type deduction.</p>\n<p><code>mutable</code> allows the lambda to mutate its captured variables.</p>\n<p>The <em>optional</em> <code>RETURN</code> contains a specification of the return type, e.g. <code>-&gt; void</code> and the <code>BODY</code> contains arbitrary expressions and statements.</p>\n<p><strong>Note</strong> that this is only a rough sketch of the syntax, but it should get you started. You can find out more about lambdas in the standard, searching for \"C++11 lambda\" on Google or for example <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">here</a>.</p>\n<p>Btw, a lambda is nothing spooky, you can think of your <code>f</code> as being a rough equivalent of the following, \"old style\" C++ code:</p>\n<pre><code>struct {\n  int operator()(int a, int b) const {\n    return a * b;\n  }\n} f;\n</code></pre>\n", "LastEditorUserId": "1116364", "LastActivityDate": "2015-09-21T17:23:13.077", "Score": "3", "CreationDate": "2015-09-21T17:16:34.743", "ParentId": "32700860", "CommentCount": "2", "OwnerUserId": "1116364", "LastEditDate": "2015-09-21T17:23:13.077"}, "32700860": {"ViewCount": "100", "Body": "<p>I found a function defined this way on:<br>\n<a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/decltype</a> </br></p>\n<p>I have never seen this syntax used to defined a function, can anyone explain this?<br>\nThis only seems to work with auto and decltype </br></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nauto f = [](int a, int b)-&gt;int\n{\n    return a * b;\n};\n\n/*\nint f = [](int a, int b)  //DOES NOT WORK\n{\n    return a * b;\n};\n*/\n\nint main()\n{\n    int a = 2, b = 3;\n    cout&lt;&lt;f(a,b);\n    return 0;\n}\n</code></pre>\n<p>I'm not certain if the following function uses dectype when we do:  </p>\n<pre><code>-&gt;int      \n</code></pre>\n<p>If it does, then how?</p>\n", "AcceptedAnswerId": "32701044", "Title": "Declaring a function using auto, decltype, = , [ ]", "CreationDate": "2015-09-21T17:06:27.437", "Id": "32700860", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-09-21T17:24:32.590", "Score": "2", "OwnerUserId": "4871296", "Tags": "<c++>", "AnswerCount": "2"}});