post_cb({"21483564": {"CommentCount": "0", "AcceptedAnswerId": "21483704", "PostTypeId": "1", "LastEditorUserId": "2694444", "CreationDate": "2014-01-31T15:22:02.700", "LastActivityDate": "2014-01-31T15:55:11.423", "LastEditDate": "2014-01-31T15:40:11.570", "ViewCount": "1491", "FavoriteCount": "1", "Title": "Alternative to reinterpret_cast with constexpr functions", "Id": "21483564", "Score": "12", "Body": "<p>Below, you will find a constexpr string literal to CRC32 computation.</p>\n<p>I had to reinterpret the string literal character from <code>char</code> to <code>unsigned char</code>. Because <code>reinterpret_cast</code> is not available in constexpr function, the workaround is a small utility function to Two's complement manually but i am a little disappointed with it.</p>\n<p>Does it exist a more elegant solution to deal with that kind of manipulation ? </p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Crc32Gen {\n    uint32_t m_[256] {};\n\n    static constexpr unsigned char reinterpret_cast_schar_to_uchar( char v ) {\n        return v&gt;=0 ? v : ~(v-1);\n    }\npublic:\n    // algorithm from http://create.stephan-brumme.com/crc32/#sarwate\n    constexpr Crc32Gen() {\n        constexpr uint32_t polynomial = 0xEDB88320;\n        for (unsigned int i = 0; i &lt;= 0xFF; i++) { \n            uint32_t crc = i; \n            for (unsigned int j = 0; j &lt; 8; j++) \n                crc = (crc &gt;&gt; 1) ^ (-int(crc &amp; 1) &amp; polynomial);\n            m_[i] = crc;\n        }\n    }\n\n    constexpr uint32_t operator()( const char* data ) const { \n        uint32_t crc = ~0; \n        while (auto c = reinterpret_cast_schar_to_uchar(*data++))\n            crc = (crc &gt;&gt; 8) ^ m_[(crc &amp; 0xFF) ^ c];\n        return ~crc; \n    } \n};\nconstexpr Crc32Gen const crc32Gen_;\n\nint main() {\n    constexpr auto const val = crc32Gen_( \"The character code for \u00c9 is greater than 127\" );\n    std::cout &lt;&lt; std::hex &lt;&lt; val &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Edit : in that case, <code>static_cast&lt;unsigned char&gt;(*data++)</code> is enough.</p>\n", "Tags": "<c++><constexpr><crc32><c++14><reinterpret-cast>", "OwnerUserId": "2694444", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21483564_21483704_0": {"section_id": 7216, "quality": 0.7916666666666666, "length": 19}, "so_21483564_21483704_1": {"section_id": 31, "quality": 0.90625, "length": 29}}, "n3337": {"so_21483564_21483704_0": {"section_id": 6960, "quality": 0.7916666666666666, "length": 19}, "so_21483564_21483704_1": {"section_id": 28, "quality": 0.90625, "length": 29}}, "n4659": {"so_21483564_21483704_0": {"section_id": 8725, "quality": 0.7916666666666666, "length": 19}, "so_21483564_21483704_1": {"section_id": 31, "quality": 0.90625, "length": 29}}}, "21483704": {"ParentId": "21483564", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Two's complement is not guaranteed by the standard; in clause 3.9.1:</p>\n<blockquote>\n<p id=\"so_21483564_21483704_0\">7 - [...] The representations of integral types\n  shall define values by use of a pure binary numeration system. [<em>Example</em>: this International Standard\n  permits 2's complement, 1's complement and signed magnitude representations for integral types. \u2014 <em>end\n  example</em> ]</p>\n</blockquote>\n<p>So any code that assumes two's complement is going to have to perform the appropriate manipulations manually.</p>\n<p>That said, your conversion function is unnecessary (and possibly incorrect); for signed-to-unsigned conversions you can just use the standard integral conversion (4.7):</p>\n<blockquote>\n<p id=\"so_21483564_21483704_1\">2 - If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits used to represent the unsigned type). [ <em>Note:</em> In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Corrected code, using <code>static_cast</code>::</p>\n<pre><code>constexpr uint32_t operator()( const char* data ) const { \n    uint32_t crc = ~0; \n    while (auto c = static_cast&lt;unsigned char&gt;(*data++))\n        crc = (crc &gt;&gt; 8) ^ m_[(crc &amp; 0xFF) ^ c];\n    return ~crc; \n} \n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-01-31T15:55:11.423", "Id": "21483704", "Score": "9", "CreationDate": "2014-01-31T15:29:09.977", "LastActivityDate": "2014-01-31T15:55:11.423"}});