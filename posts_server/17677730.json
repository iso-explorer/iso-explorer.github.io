post_cb({"17677859": {"ParentId": "17677730", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In both cases, the compiler generates a copy constructor for you, that has no output so you won't know if it is called: <a href=\"https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap\">See this question.</a></p>\n<p>In the first case the compiler generated copy constructor is used, which matches the second destructor call. The line <code>return my;</code> calls the copy constructor, giving it the variable <code>my</code> to be used to construct the return value. This doesn't generate any output. </p>\n<p><code>my</code> is then destroyed. Once the function call has completed, the return value is destroyed at the end of the line <code>{ function();</code>.</p>\n<p>In the second case, the copy for the return is <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow noreferrer\">elided</a> completely (the compiler is allowed to do this as an optimisation). You only ever have one <code>My</code> instance. (Yes, it is allowed to do this even though it changes the observable behaviour of your program!)</p>\n<p>These are both ok. Although as a general rule, if you define your own constructor and destructor, you should also define your own copy constructor (and assignment operator, and possibly move constructor and move assignment if you have c++11).</p>\n<p>Try adding your own copy constructor and see what you get. Something like</p>\n<pre><code>My (const My&amp; otherMy) { cout &lt;&lt; \"My copy constructor\\n\"; }\n</code></pre>\n", "OwnerUserId": "1171191", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:03.560", "Id": "17677859", "Score": "7", "CreationDate": "2013-07-16T13:28:01.087", "LastActivityDate": "2013-07-16T13:39:59.583"}, "17678970": {"ParentId": "17677730", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_17677730_17678970_0\">To date, I have been designing my classes on the assumption that for each constructor call there will be at most one destructor call [...]</p>\n</blockquote>\n<p>You can still \"assume\" that since it is true. Each constructor call will go in hand with <em>exactly one</em> destructor call. (Remember that if you handle stuff on the free/heap memory on your own.)</p>\n<blockquote>\n<p id=\"so_17677730_17678970_1\">[..] and can be compiler-dependent [...]</p>\n</blockquote>\n<p>In this case it can't. It is optimization depedant. Both, MSVC and GCC behave identically if optimization is applied.</p>\n<h1>Why don't you see identical behaviour?</h1>\n<h2>1. You don't track everything that happens with your object. Compiler-generated functions bypass your output.</h2>\n<p>If you want to \"follow-up\" on the things your compiler does with your objects, you should define all of the special members so you can really track everything and do not get bypassed by any implicit function.</p>\n<pre><code>struct My\n{  \n   My() { cout &lt;&lt; \"My constructor \" &lt;&lt; endl; }\n   My(My const&amp;) { cout &lt;&lt; \"My copy-constructor \" &lt;&lt; endl; }\n   My(My &amp;&amp;) { cout &lt;&lt; \"My move-constructor \" &lt;&lt; endl; }\n   My&amp; operator=(My const&amp;) { cout &lt;&lt; \"My copy-assignment \" &lt;&lt; endl; }\n   My&amp; operator=(My &amp;&amp;) { cout &lt;&lt; \"My move-assignment \" &lt;&lt; endl; }\n  ~My() { cout &lt;&lt; \"My destructor \" &lt;&lt; endl; }\n};\n</code></pre>\n<p>[Note: The move-constructor and move-assignment will not be implicitly present if you have the copy ones but it's still nice to see when the compiler use which of them.]</p>\n<h2>2. You don't compile with optimization on both MSVC and GCC.</h2>\n<p>If compiled with MSVC++11 <code>/O2</code> option the output is:</p>\n<blockquote>\n<p id=\"so_17677730_17678970_2\">My constructor<br>\n  My function<br>\n  My destructor</br></br></p>\n</blockquote>\n<p>If compiled in debug mode / without optimization:</p>\n<blockquote>\n<p id=\"so_17677730_17678970_3\">My constructor<br>\n  My function<br>\n  My move-constructor<br>\n  My destructor<br>\n  My destructor</br></br></br></br></p>\n</blockquote>\n<p>I can't do a test on gcc to verify if there's an option that enforces all of these steps but <code>-O0</code> should do the trick I guess.</p>\n<h1>What's the difference between optimized and non-optimized compilation here?</h1>\n<h2>The case without any copy omittance:</h2>\n<p>The completely \"non-optimized\" behaviour in this line <code>My my_in_main = function();\n</code> (changed the name to make things clear) would be:</p>\n<ol>\n<li>Call <code>function()</code></li>\n<li>In function construct My <code>My my;</code></li>\n<li>Output stuff.</li>\n<li>Copy-construct <code>my</code> into the return value instance.</li>\n<li>return and destroy <code>my</code> instance.</li>\n<li>Copy(or move in my example)-construct the return value instance into <code>my_in_main</code>.</li>\n<li>Destroy the return value instance.</li>\n</ol>\n<p>As you can see: we have at most two copies (or one copy and one move) here but the compilers may possibly omit them. </p>\n<p>To my understanding, the first copy is omited even without optimization turned on (in this case), leaving the process as follows:</p>\n<ol>\n<li>Call <code>function()</code></li>\n<li>In function construct My <code>My my;</code> <em>First constructor output!</em></li>\n<li>Output stuff. <em>Function output!</em></li>\n<li>Copy(or move in my example)-construct the return value instance into <code>my_in_main</code>. <em>Move output!</em></li>\n<li>Destroy the return value instance. <em>Destroy output!</em></li>\n</ol>\n<p>The <code>my_in_main</code> is destroy at the end of main giving the last <em>Destroy output!</em>. So we know what happens in the non-optimized case now.</p>\n<h2>Copy elision</h2>\n<p>The copy (or move if the class has a move constructor as in my example) can be elided.</p>\n<p><strong>\u00a7 12.8 [class.copy] / 31</strong></p>\n<blockquote>\n<p id=\"so_17677730_17678970_4\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects.</p>\n</blockquote>\n<p>So now the question is when does this happen in this example? The reason for the elison of the first copy is given in the very same paragraph:</p>\n<blockquote>\n<p id=\"so_17677730_17678970_5\">[...] in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value.</p>\n</blockquote>\n<p><strong>Return type matches type in the return statement: <code>function</code> will construct <code>My my;</code> directly into the return value.</strong></p>\n<p>The reason for the elison of the second copy/move:</p>\n<blockquote>\n<p id=\"so_17677730_17678970_6\">[...] when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move.</p>\n</blockquote>\n<p><strong>Target type matches the type returned by the function: The return value of the function will be constructed into <code>my_in_main</code>.</strong></p>\n<p>So you have a cascade here:</p>\n<p><code>My my;</code> in your function is directly constructed into the return value which is directly constructed into <code>my_in_main</code> So you have in fact only one object here and <code>function()</code> would (whatever it does) in fact operate on the object <code>my_in_main</code>.</p>\n<ol>\n<li>Call <code>function()</code></li>\n<li>In function construct My instance into <code>my_in_main</code>. <em>Constructor output!</em></li>\n<li>Output stuff. <em>Function output!</em></li>\n</ol>\n<p><code>my_in_main</code> is still destroyed at the end of main giving a <em>Destructor output!</em>.</p>\n<p>That makes three outputs in total: Those you observe if optimization is turned on.</p>\n<h1>An example where elision is not possible.</h1>\n<p>In the following example both copies mentioned above cannot be omitted because the class types do not match:</p>\n<ul>\n<li>The return statement does not match the return type</li>\n<li>The target type does not match the return type of the function</li>\n</ul>\n<p>I just created two additional types:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct A\n{  \n   A(void) { cout &lt;&lt; \"A constructor \" &lt;&lt; endl; }\n  ~A(void) { cout &lt;&lt; \"A destructor \" &lt;&lt; endl; }\n};\nstruct B\n{  \n   B(A const&amp;) { cout &lt;&lt; \"B copy from A\" &lt;&lt; endl; }\n  ~B(void) { cout &lt;&lt; \"B destructor \" &lt;&lt; endl; }\n};\n\nstruct C\n{\n   C(B const &amp;) { cout &lt;&lt; \"C copy from B\" &lt;&lt; endl; }\n  ~C(void) { cout &lt;&lt; \"C destructor \" &lt;&lt; endl; }\n};\n\nB function() { A my; cout &lt;&lt; \"function\" &lt;&lt; endl; return my; }\n\nint main()\n{ \n  C my_in_main(function());\n  return 0;\n}\n</code></pre>\n<p>Here we have the \"completely non-optimized behaviour\" I mentioned above. I'll refer to the points I've drawn there.</p>\n<pre>A constructor (see 2.)\nfunction (see 3.)\nB copy from A (see 4.)\nA destructor (see 5.)\nC copy from B (see 6.)\nB destructor (see 7.)\nC destructor (instance in main, destroy at end of main)</pre>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2013-07-16T14:43:21.517", "Id": "17678970", "Score": "1", "CreationDate": "2013-07-16T14:14:58.193", "LastActivityDate": "2013-07-16T14:43:21.517"}, "17677983": {"ParentId": "17677730", "CommentCount": "1", "Body": "<p>The problem is that your class <code>My</code> violates the <a href=\"https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29\" rel=\"nofollow\">Rule of Three</a>; if you write a custom destructor then you should also write a custom copy constructor (and copy assignment operator, but that's not relevant here).</p>\n<p>With:</p>\n<pre><code>struct My\n{  My() { cout &lt;&lt; \"My constructor \" &lt;&lt; endl; }\n   My(const My &amp;) { cout &lt;&lt; \"My copy constructor \" &lt;&lt; endl; }\n  ~My() { cout &lt;&lt; \"My destructor \" &lt;&lt; endl; }\n};\n</code></pre>\n<p>the output for MSVC is:</p>\n<pre><code>My constructor\nMy function\nMy copy constructor\nMy destructor\nMy destructor\n</code></pre>\n<p>As you can see, (copy) constructors match with destructors correctly.</p>\n<p>The output under gcc is unchanged, because gcc is performing copy elision as allowed (but not <em>required</em>) by the standard.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "17677983", "Score": "3", "CreationDate": "2013-07-16T13:33:26.217", "LastActivityDate": "2013-07-16T13:33:26.217"}, "17678004": {"ParentId": "17677730", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are missing two things here: the copy constructor and NRVO.</p>\n<p>The behavior seen with MSVC++ is the \"normal\" behavior; <code>my</code> is created and the rest of the function is run; then, when returning, a <em>copy</em> of your object is created. The local <code>my</code> object is destroyed, and the copy is returned to the caller, which just discards it, resulting in its destruction.</p>\n<p>Why does it seem that you are missing a constructor call? Because the compiler automatically generated a copy constructor, which is called but doesn't print anything. If you added your own copy constructor:</p>\n<pre><code>My(const My&amp; Right) { cout &lt;&lt; \"My copy constructor \" &lt;&lt; endl; }\n</code></pre>\n<p>you'd see</p>\n<pre><code>My constructor      &lt;----+\nMy function              |      this is the local \"my\" object\nMy copy constructor   &lt;--|--+\nMy destructor       &lt;----+  |   this is the return value\nMy destructor         &lt;-----+\n</code></pre>\n<p>So the point is: it's not that there are more calls to destructors than constructors, it's just that you are not seeing the call to the <em>copy</em> constructor.</p>\n<hr>\n<p>In the gcc output, you are also seeing NRVO applied.</p>\n<p>NRVO (Named <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">Return Value Optimization</a>) is one of the few cases where the compiler is allowed to perform an optimization that alters the visible behavior of your program. In fact, the compiler is allowed to elide the copy to the temporary return value, and construct the returned object directly, thus eliding temporary copies.</p>\n<p>So, no copy is created, and <code>my</code> is actually the same object that is returned.</p>\n<pre><code>My constructor  &lt;-- called at the beginning of f\nMy function    \nMy destructor   &lt;-- called after f is terminated, since\n                    the caller discarded the return value of f\n</code></pre>\n</hr>", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2013-07-16T13:40:24.617", "Id": "17678004", "Score": "3", "CreationDate": "2013-07-16T13:34:09.563", "LastActivityDate": "2013-07-16T13:40:24.617"}, "17677730": {"CommentCount": "9", "ViewCount": "2075", "PostTypeId": "1", "LastEditorUserId": "1958486", "CreationDate": "2013-07-16T13:22:58.787", "LastActivityDate": "2013-07-16T14:43:21.517", "Title": "can a C++ function return an object with a constructor and a destructor", "LastEditDate": "2013-07-16T13:35:05.840", "Id": "17677730", "Score": "2", "Body": "<p>I'm trying to establish whether it is safe for a C++ function to return an object that has a constructor and a destructor. My understanding of the standard is that it ought to be possible, but my tests with simple examples show that it can be problematic. For example the following program:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct My\n{  My() { cout &lt;&lt; \"My constructor \" &lt;&lt; endl; }\n  ~My() { cout &lt;&lt; \"My destructor \" &lt;&lt; endl; }\n};\nMy function() { My my; cout &lt;&lt; \"My function\" &lt;&lt; endl; return my; }\n\nint main()\n{ My my = function();\n  return 0;\n}\n</code></pre>\n<p>gives the output:</p>\n<pre><code>My constructor\nMy function\nMy destructor\nMy destructor\n</code></pre>\n<p>when compiled on MSVC++, but when compiled with gcc gives the following output:</p>\n<pre><code>My constructor\nMy function\nMy destructor\n</code></pre>\n<p>Is this a case of \"undefined behavior\", or is one of the compilers not behaving in a standard way? If the latter, which ?  The gcc output is closer to what I would have expected. </p>\n<p>To date, I have been designing my classes on the assumption that for each constructor call there will be at most one destructor call, but this example seems to show that this assumption does not always hold, and can be compiler-dependent.  Is there anything in the standard that specifies what should happen here, or is it better to avoid having functions return non-trivial objects ?  Apologies if this question is a duplicate.</p>\n", "Tags": "<c++><constructor><destructor>", "OwnerUserId": "1958486", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_17677730_17678970_3": {"section_id": 7040, "quality": 0.8, "length": 4}, "so_17677730_17678970_6": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}, "so_17677730_17678970_4": {"section_id": 480, "quality": 0.95, "length": 19}, "so_17677730_17678970_5": {"section_id": 480, "quality": 1.0, "length": 35}}, "n3337": {"so_17677730_17678970_3": {"section_id": 6785, "quality": 0.8, "length": 4}, "so_17677730_17678970_6": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}, "so_17677730_17678970_4": {"section_id": 471, "quality": 1.0, "length": 20}, "so_17677730_17678970_5": {"section_id": 471, "quality": 1.0, "length": 35}}, "n4659": {"so_17677730_17678970_3": {"section_id": 4871, "quality": 0.8, "length": 4}, "so_17677730_17678970_6": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}, "so_17677730_17678970_5": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_17677730_17678970_4": {"section_id": 502, "quality": 0.95, "length": 19}}}});