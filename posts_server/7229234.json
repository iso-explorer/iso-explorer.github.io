post_cb({"bq_ids": {"n4140": {"so_7229234_7229381_1": {"length": 9, "quality": 0.9, "section_id": 5991}, "so_7229234_7229381_0": {"length": 28, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_7229234_7229381_1": {"length": 9, "quality": 0.9, "section_id": 5759}, "so_7229234_7229381_0": {"length": 28, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_7229234_7229381_1": {"length": 9, "quality": 0.9, "section_id": 7491}, "so_7229234_7229381_0": {"length": 28, "quality": 1.0, "section_id": 7273}}}, "7229234": {"ViewCount": "199", "Body": "<p>Suppose I have the following function:</p>\n<pre><code>void foo(std::vector&lt;int&gt; vec, int n);\n</code></pre>\n<p>If I call the function like this:</p>\n<pre><code>std::vector&lt;int&gt; numbers { 2, 3, 5, 7, 11, 13, 17, 19 };\nfoo(std::move(numbers), numbers[0]);\n</code></pre>\n<p>Are all the arguments completely evaluated before being bound to their parameters? In that case, the <code>std::move</code> is harmless, because it simply yields an xvalue referring to <code>numbers</code>. Or can each individual argument immediately be bound to its parameter as soon as it is evaluated? In that case, <code>numbers[0]</code> could cause undefined behavior, because <code>numbers</code> could already have been moved into <code>vec</code>.</p>\n", "AcceptedAnswerId": "7229381", "Title": "Is parameter binding sequenced after argument evaluation?", "CreationDate": "2011-08-29T11:03:37.057", "Id": "7229234", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-08-29T11:23:27.603", "LastEditorUserId": "36565", "LastActivityDate": "2011-08-29T11:27:51.580", "Score": "13", "OwnerUserId": "252000", "Tags": "<c++><parameter-passing><evaluation><c++11><move-semantics>", "AnswerCount": "1"}, "7229381": {"Id": "7229381", "PostTypeId": "2", "Body": "<p>On \u00a71.9/15 we're told that:</p>\n<blockquote>\n<p id=\"so_7229234_7229381_0\">When calling a function (whether or not the function is inline), every value computation and side effect\n  associated with any argument expression, or with the postfix expression designating the called function, is\n  sequenced before execution of every expression or statement in the body of the called function. (...)</p>\n</blockquote>\n<p>And on \u00a75.2.2/4:</p>\n<blockquote>\n<p id=\"so_7229234_7229381_1\">(...) The initialization and destruction of each parameter occurs within the context of the\n  calling function. (...)</p>\n</blockquote>\n<p>I couldn't find any other relevant text in the final draft. Since this does not explicitly define a <em>sequenced before</em> relationship between evaluation of arguments and the initialization of the parameters, they're <em>unsequenced</em> and the <code>std::move</code> is not harmless.</p>\n<p>A solution to this issue would be to force a sequence with a temporary variable:</p>\n<pre><code>std::vector&lt;int&gt; numbers { 2, 3, 5, 7, 11, 13, 17, 19 };\nint num = numbers[0];\nfoo(std::move(numbers), num);\n</code></pre>\n", "LastEditorUserId": "46642", "LastActivityDate": "2011-08-29T11:27:51.580", "Score": "10", "CreationDate": "2011-08-29T11:19:38.650", "ParentId": "7229234", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2011-08-29T11:27:51.580"}});