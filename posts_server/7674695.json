post_cb({"7676073": {"ParentId": "7674695", "CommentCount": "1", "Body": "<p>The best way to get the <code>.template operator</code> construct to work would be to submit a bug report to IBM.</p>\n<p>This code conforms to the C++ standard. It is, in fact, the only legal way to write this code.</p>\n<hr>\n<p>When you file the report you can use the following as evidence:</p>\n<p><code>\u00a714.2/4</code> states:</p>\n<blockquote>\n<p id=\"so_7674695_7676073_0\">When the name of a member template specialization appears after . or -&gt; in a <em>postfix-expression</em> ... and the object expression of the <em>postfix-expression</em> is\n  type-dependent ... the member template name must be prefixed by the keyword template. ...</p>\n</blockquote>\n<hr>\n<p>The first part: \"<code>the name of a member template specialization</code>\", applies because because <code>operator()&lt;int&gt;</code> is the name of a member template specialization. There is evidence for this in <code>\u00a714.2/1</code>:</p>\n<blockquote>\n<p id=\"so_7674695_7676073_1\">A template specialization can be referred to by a <em>template-id</em>:</p>\n</blockquote>\n<p><code>\u00a714.2/1</code> then specifies a syntax for a <em>template-id</em> which matches <code>operator()&lt;int&gt;</code>.</p>\n<hr>\n<p>The second part: \"<code>and the object expression of the _postfix-expression_ is\ntype-dependent</code>\", applies because <code>obj</code> is type-dependent. <code>obj</code> is type-dependent because of  <code>\u00a714.6.2.2/3</code>:</p>\n<blockquote>\n<p id=\"so_7674695_7676073_2\">An <em>id-expression</em> is type-dependent if it contains: - an <em>identifier</em> associated by name lookup with one or more declarations declared with a dependent type, ...</p>\n</blockquote>\n<p>In this case, <code>obj</code> is associated with <code>T&amp;</code>, which is a dependent type (because <code>T</code> is a template parameter).</p>\n<hr>\n<p>This is only half of a definitive answer, as I have not provided references for many claims that I made. I have been at this for an hour now though, so it is probably time to stop. </p>\n</hr></hr></hr></hr>", "OwnerUserId": "485561", "PostTypeId": "2", "Id": "7676073", "Score": "3", "CreationDate": "2011-10-06T14:47:02.867", "LastActivityDate": "2011-10-06T14:47:02.867"}, "7674695": {"CommentCount": "5", "ViewCount": "290", "CreationDate": "2011-10-06T13:11:57.010", "LastActivityDate": "2011-10-06T14:47:02.867", "Title": "obj.template operator() construct does not work with xlC 11.1", "AcceptedAnswerId": "7676073", "PostTypeId": "1", "Id": "7674695", "Score": "3", "Body": "<p>The following piece of C++ code:</p>\n<pre><code>template &lt;typename T&gt;\nstatic void execute(T&amp; obj) {\n    obj.template operator()&lt;int&gt;();\n}\n</code></pre>\n<p>when compiled with IBM's xlC 11.1 results in the error message: <i>1540-0063 (S) The text \"operator\" is unexpected</i>. If I use a function instead of an operator, it works fine, but I do not want to rewrite a lot of library code. Is there any other way how to make the <code>.template operator</code> construct work with xlC?</p>\n", "Tags": "<c++><templates><operator-keyword><xlc>", "OwnerUserId": "580083", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7674695_7676073_1": {"section_id": 69, "quality": 1.0, "length": 5}, "so_7674695_7676073_2": {"section_id": 202, "quality": 1.0, "length": 13}, "so_7674695_7676073_0": {"section_id": 72, "quality": 1.0, "length": 19}}, "n3337": {"so_7674695_7676073_1": {"section_id": 64, "quality": 1.0, "length": 5}, "so_7674695_7676073_2": {"section_id": 196, "quality": 1.0, "length": 13}, "so_7674695_7676073_0": {"section_id": 67, "quality": 1.0, "length": 19}}, "n4659": {"so_7674695_7676073_1": {"section_id": 71, "quality": 1.0, "length": 5}, "so_7674695_7676073_2": {"section_id": 208, "quality": 1.0, "length": 13}}}});