post_cb({"4338228": {"ParentId": "4338073", "CommentCount": "0", "Body": "<p>I think the distinction between the two depends on the details of your specific implementation (and doesn't make much difference). For what it's worth, Comeau gives this:</p>\n<pre><code>\"ComeauTest.c\", line 7: error: \"A &amp;A::operator=(const A &amp;)\" (declared at line 4) is\n          inaccessible\n  struct B : A\n             ^\n          detected during implicit generation of \"B &amp;B::operator=(const B &amp;)\"\n                    at line 16\n\n1 error detected in the compilation of \"ComeauTest.c\".\n</code></pre>\n<p>So on that compiler, it detects the error \"during\" the implicit generation of B's assignment operator. In other words, it tries to generate it, and finds that it can't. Whether it detects it as it's writing it out, or by looking at <code>A</code> directly, doesn't really matter.</p>\n", "OwnerUserId": "499449", "PostTypeId": "2", "Id": "4338228", "Score": "1", "CreationDate": "2010-12-02T18:03:07.840", "LastActivityDate": "2010-12-02T18:03:07.840"}, "4338239": {"ParentId": "4338073", "CommentCount": "1", "Body": "<p>The standard seems to agree with you. Quoting from the current draft:</p>\n<h3>\u00a712.8/8:</h3>\n<blockquote>\n<p id=\"so_4338073_4338239_0\">If the class definition does not\n  explicitly declare a copy constructor\n  and there is no user-declared move\n  constructor, a copy constructor is\n  implicitly declared as defaulted\n  (8.4).</p>\n</blockquote>\n<h3>\u00a712.8/12:</h3>\n<blockquote>\n<p id=\"so_4338073_4338239_1\">A defaulted copy/move constructor for\n  a class X is defined as deleted\n  (8.4.3) if X has: [\u2026]</p>\n<ul>\n<li>a direct or virtual base class B that cannot be copied/moved because\n  overload resolution (13.3), as applied\n  to B\u2019s corresponding constructor,\n  results in an ambiguity or a function\n  that is deleted or inaccessible from\n  the defaulted constructor [\u2026]</li>\n</ul>\n</blockquote>\n<p>So the synthesized copy constructor is declared and defined, but defined as deleted.</p>\n", "OwnerUserId": "178761", "PostTypeId": "2", "Id": "4338239", "Score": "0", "CreationDate": "2010-12-02T18:04:12.713", "LastActivityDate": "2010-12-02T18:04:12.713"}, "4338073": {"CommentCount": "0", "AcceptedAnswerId": "4338232", "PostTypeId": "1", "LastEditorUserId": "56338", "CreationDate": "2010-12-02T17:46:49.143", "LastActivityDate": "2010-12-02T18:49:15.327", "LastEditDate": "2010-12-02T18:02:03.040", "ViewCount": "2751", "FavoriteCount": "1", "Title": "Implementation supplied copy constructor and assignment operator", "Id": "4338073", "Score": "2", "Body": "<p>I have a small confusion regarding the situations where the implementation (compiler) will not supply the copy constructor and the copy assignment operator.</p>\n<ol>\n<li>When we declare the copy ctor and/or copy assignment operator in our class.</li>\n<li>Some says when we derive from a class which has a private copy ctor and/or copy assignment operator.</li>\n</ol>\n<p>I am a little confused about the second situation, is the second situation is precisely.<br>\na) The implementation will not declare them for you, so you will get a compile time error.<br>\nOR<br>\nb) The  implementation will declare and define them, but when the compiler defined implementation tries to find the base class' method, we will get a compile time error.</br></br></br></p>\n<p>I had an interview yesterday, I said its (b) that is happening but the interviewer disagrees, he says its (a).</p>\n<p>I tried to compile the following code in both Microsoft C/C++ 14.00 and gcc 4.4.5</p>\n<pre><code>struct A\n{\nprivate:\n  A&amp; operator = ( const A&amp; );\n};\n\nstruct B : A\n{\n};\n\n\nint main()\n{\n  B b1;\n  B b2;\n  b1 = b2;\n\n  return 0;\n}\n</code></pre>\n<p>Microsoft compiler output</p>\n<pre><code>ctor01.cpp(9) : error C2248: 'A::operator =' : cannot access private member declared in class 'A'\nctor01.cpp(4) : see declaration of 'A::operator ='\nctor01.cpp(2) : see declaration of 'A'\nThis diagnostic occurred in the compiler generated function 'B &amp;B::operator =(const B &amp;)'\n</code></pre>\n<p>gcc compiler output</p>\n<pre><code>Ctor01.cpp: In member function \u2018B&amp; B::operator=(const B&amp;)\u2019:\nCtor01.cpp:4: error: \u2018A&amp; A::operator=(const A&amp;)\u2019 is private\nCtor01.cpp:8: error: within this context\nCtor01.cpp: In function \u2018int main()\u2019:\nCtor01.cpp:15: note: synthesized method \u2018B&amp; B::operator=(const B&amp;)\u2019 first required here \n</code></pre>\n<p>So I think, the  implementation will declare and define it, but when the compiler defined implementation tries to find the base class method, we will get a compile time error. Correct me if I am wrong.</p>\n", "Tags": "<c++><copy-constructor><noncopyable><copy-assignment>", "OwnerUserId": "513810", "AnswerCount": "6"}, "4338260": {"ParentId": "4338073", "CommentCount": "0", "Body": "<p>A class will have a copy constructor and a copy assignment operator implicitly <em>declared</em> if there is no user declared version of either. This always happens.</p>\n<p>Simplistically, the implementation will implicitly <em>define</em> these only if they are actually used. If, when the implementation tries to define them, the implicit definition would be ill-formed (e.g. for copy-assignment the class contains a reference member or const member or for the copy constructor a base or member has private copy constructor) then the program is ill-formed.</p>\n<p>A program can still be valid if it contains classes which have implicitly <em>declared</em> copy constructors and copy assignment operators which cannot be implicitly defined so long as it does not cause these to actually be defined by using them or causing them to be used.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "4338260", "Score": "3", "CreationDate": "2010-12-02T18:06:20.133", "LastActivityDate": "2010-12-02T18:06:20.133"}, "4338232": {"ParentId": "4338073", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Regarding the copy constructor, this is what the standard says (12.8/7) :</p>\n<blockquote>\n<p id=\"so_4338073_4338232_0\">A program is illformed if the class\n  for which a copy constructor is\n  <strong>implicitly defined</strong> has:</p>\n<ul>\n<li>a nonstatic data member of class type (or array thereof) with an\n  inaccessible or ambiguous copy\n  constructor, or</li>\n<li><strong>a base class with an inaccessible or ambiguous copy\n  constructor</strong>.</li>\n</ul>\n</blockquote>\n<p>Regarding the copy assignment operator (12.8/12) :</p>\n<blockquote>\n<p id=\"so_4338073_4338232_1\">A program is illformed if the class\n  for which a copy assignment operator\n  is <strong>implicitly defined</strong> has:</p>\n<ul>\n<li>a nonstatic data member of const type, or</li>\n<li>a nonstatic data member of reference type, or</li>\n<li>a nonstatic data member of class type (or array thereof) with an\n  inaccessible copy assignment operator,\n  or</li>\n<li><strong>a base class with an inaccessible copy assignment operator.</strong></li>\n</ul>\n</blockquote>\n<p>How the compiler reports the error, or how it actually <em>falls</em> into it, is pretty much irrelevant from my point of view.</p>\n<p>However, I do believe that answer (b) is probably <em>more</em> correct : the base class copy assignment is declared, and it's inaccessible. The derived class has an implicitly <em>declared</em> copy assignment which the compiler will try to <em>define</em> <strong>if used</strong>, thus making the program ill-formed.</p>\n", "OwnerUserId": "451980", "LastEditorUserId": "451980", "LastEditDate": "2010-12-02T18:09:56.663", "Id": "4338232", "Score": "7", "CreationDate": "2010-12-02T18:03:23.147", "LastActivityDate": "2010-12-02T18:09:56.663"}, "4338206": {"ParentId": "4338073", "CommentCount": "4", "Body": "<p>This is what happens :</p>\n<pre><code>struct A\n{\nprivate:\n  A&amp; operator = ( const A&amp; );\n};\n\nstruct B : A\n{\n  B&amp; operator = ( const B&amp; other )\n  {\n    A::operator=( other );\n    return *this;\n  }\n};\n\n\nint main()\n{\n  B b1;\n  B b2;\n  b1 = b2;\n\n  return 0;\n}\n</code></pre>\n<p>The default operator= tries to call A::operator=, which is private.</p>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "4338206", "Score": "0", "CreationDate": "2010-12-02T17:59:53.907", "LastActivityDate": "2010-12-02T17:59:53.907"}, "4338547": {"ParentId": "4338073", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your case (b) is more accurate.</p>\n<p>C++03 Standard 12.8p10</p>\n<blockquote>\n<p id=\"so_4338073_4338547_0\">If the class definition does not explicitly declare a copy assignment operator, one is declared <em>implicitly</em>.</p>\n</blockquote>\n<p>And 12.8p12</p>\n<blockquote>\n<p id=\"so_4338073_4338547_1\">An implicitly-declared copy assignment operator is <em>implicitly defined</em> when an object of its class type is assigned a value of its class type or a value of a class type derived from its class type.  A program is ill-formed if the class for which a copy assignment operator is implicitly defined has:</p>\n</blockquote>\n<ul>\n<li>a nonstatic data member of <code>const</code> type, or</li>\n<li>a nonstatic data member of reference type, or</li>\n<li>a nonstatic data member of class type (or array thereof) with inaccessible copy assignment operator, or</li>\n<li>a base class with an inaccessible copy assignment operator.</li>\n</ul>\n<p>The corresponding requirements for implicitly defined copy constructors, default constructors, and destructors have similar wordings.</p>\n<p>Specifying that the methods exist even though their definitions will be illegal clarifies some things about overload resolution.  For example,</p>\n<pre><code>class A {\nprivate:\n  A&amp; operator=(const A&amp;);\n};\n\nclass B : public A {\npublic:\n  operator int() const;\n  B&amp; operator=(int);\n};\n\nvoid f(B&amp; b1, const B&amp; b2)\n{ b1 = b2; }\n</code></pre>\n<p>is illegal because the implicitly-declared <code>B::operator=(const B&amp;)</code> is the better overload but the implicit definition is ill-formed.  Without that declaration, you might think the compiler should implicitly convert <code>b2</code> to <code>int</code> and then assign that to <code>b1</code>.</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2010-12-02T18:49:15.327", "Id": "4338547", "Score": "2", "CreationDate": "2010-12-02T18:36:45.623", "LastActivityDate": "2010-12-02T18:49:15.327"}, "bq_ids": {"n4140": {"so_4338073_4338232_1": {"section_id": 456, "quality": 0.8571428571428571, "length": 6}, "so_4338073_4338232_0": {"section_id": 456, "quality": 0.8333333333333334, "length": 5}, "so_4338073_4338547_0": {"section_id": 467, "quality": 1.0, "length": 11}, "so_4338073_4338239_1": {"section_id": 460, "quality": 0.7142857142857143, "length": 5}, "so_4338073_4338239_0": {"section_id": 469, "quality": 0.8125, "length": 13}}, "n3337": {"so_4338073_4338232_1": {"section_id": 449, "quality": 0.8571428571428571, "length": 6}, "so_4338073_4338547_1": {"section_id": 453, "quality": 0.5666666666666667, "length": 17}, "so_4338073_4338547_0": {"section_id": 458, "quality": 1.0, "length": 11}, "so_4338073_4338232_0": {"section_id": 449, "quality": 0.8333333333333334, "length": 5}, "so_4338073_4338239_0": {"section_id": 447, "quality": 0.75, "length": 12}, "so_4338073_4338239_1": {"section_id": 451, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_4338073_4338232_1": {"section_id": 479, "quality": 0.8571428571428571, "length": 6}, "so_4338073_4338232_0": {"section_id": 479, "quality": 0.8333333333333334, "length": 5}, "so_4338073_4338547_0": {"section_id": 490, "quality": 1.0, "length": 11}, "so_4338073_4338239_1": {"section_id": 382, "quality": 0.7142857142857143, "length": 5}, "so_4338073_4338239_0": {"section_id": 492, "quality": 0.8125, "length": 13}}}});