post_cb({"30081493": {"ParentId": "30078818", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-05-06T15:42:11.660", "Score": "9", "LastEditorUserId": "1774667", "LastEditDate": "2015-05-06T15:48:25.410", "Id": "30081493", "OwnerUserId": "1774667", "Body": "<p>Quotes found by @TartainLlama</p>\n<blockquote>\n<p id=\"so_30078818_30081493_0\">If a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not depend on a template parameter, the program is ill-formed; no diagnostic is required.</p>\n</blockquote>\n<p><em>N4296 [temp.res]/8</em></p>\n<p>This applies immediately after the primary template is defined (the one with the <code>static_assert</code> in it).  So the later specialization (for <code>42</code>) cannot be considered, as it does not exist yet.</p>\n<p>The next question is if <code>static_assert( sizeof(answer) != sizeof(answer),</code> <em>depends</em> on <code>answer</code>.  Semantically it does not, syntactically it does, and standard-wise:</p>\n<blockquote>\n<p id=\"so_30078818_30081493_1\">Inside a template, some constructs have semantics which may differ from one instantiation to another. Such a construct <em>depends</em> on the template parameters.</p>\n</blockquote>\n<p><em>N4296 [temp.dep]/1</em></p>\n<p>The construct <code>sizeof(answer) != sizeof(answer)</code> does not differ from one instantiation to another.  So such a construct <em>does not depend</em> on the template parameters.  Which means the entire <code>static_assert</code> does not depend on the template parameter.</p>\n<p>Thus your program is ill formed, no diagnostic required.  Issuing an arbitrary diagnostic (such as the <code>static_assert</code> failing) is valid compiler behavior.  Missing the problem is valid compiler behavior.  The behavior of a program compiled from an ill formed, no diagnostic required program is not defined by the standard: it is undefined behavior.  Nasal demons are permitted.</p>\n<p>Fancy attempts (like <code>sizeof(int[answer])!=sizeof(int[answer])</code> may please the current <s>god</s> compiler, but does not make your program more well formed.</p>\n<p>You could make a case where the compiler is unlikely to be able to catch you at it, but the ill-formed-ness remains regardless of the ability for the compiler to catch you with it.  As a general rule, C++ wants to leave itself (and its compilers) freedom to find invalid template code \"earlier than instantiation\"; this means that template code must produce possibly legal code.</p>\n<p>It is possible you want something like <code>=delete</code> with a message attached.</p>\n", "LastActivityDate": "2015-05-06T15:48:25.410"}, "30079285": {"ParentId": "30078818", "PostTypeId": "2", "CommentCount": "17", "CreationDate": "2015-05-06T14:12:22.877", "Score": "13", "LastEditorUserId": "2069064", "LastEditDate": "2015-05-06T15:55:56.477", "Id": "30079285", "OwnerUserId": "2069064", "Body": "<p>Both compilers are correct. From [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_30078818_30079285_0\">If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>There does not exist a valid specialization that can be generated from the primary template <code>Hitchhiker</code>, so it is ill-formed, no diagnostic required. clang chooses to issue a diagnostic anyway. </p>\n<p>If you only want to allow <code>42</code>, then simply don't define the general template:</p>\n<pre><code>template &lt;int &gt; struct Hitchhiker;\ntemplate &lt;&gt; struct Hitchhiker&lt;42&gt; {};\n</code></pre>\n", "LastActivityDate": "2015-05-06T15:55:56.477"}, "bq_ids": {"n4140": {"so_30078818_30081493_1": {"section_id": 188, "quality": 0.9375, "length": 15}, "so_30078818_30079285_0": {"section_id": 175, "quality": 1.0, "length": 11}}, "n3337": {"so_30078818_30081493_1": {"section_id": 182, "quality": 0.9375, "length": 15}, "so_30078818_30079285_0": {"section_id": 169, "quality": 1.0, "length": 11}}, "n4659": {"so_30078818_30081493_0": {"section_id": 180, "quality": 0.8888888888888888, "length": 16}, "so_30078818_30079285_0": {"section_id": 180, "quality": 0.8181818181818182, "length": 9}, "so_30078818_30081493_1": {"section_id": 193, "quality": 0.9375, "length": 15}}}, "30078818": {"CommentCount": "5", "AcceptedAnswerId": "30081493", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2015-05-06T13:52:16.667", "LastActivityDate": "2015-05-06T15:55:56.477", "LastEditDate": "2015-05-06T14:12:45.003", "ViewCount": "641", "FavoriteCount": "4", "Title": "static_assert dependent on non-type template parameter (different behavior on gcc and clang)", "Id": "30078818", "Score": "21", "Body": "<pre><code>template &lt;int answer&gt; struct Hitchhiker {\n  static_assert(sizeof(answer) != sizeof(answer), \"Invalid answer\");\n};\n\ntemplate &lt;&gt; struct Hitchhiker&lt;42&gt; {};\n</code></pre>\n<p>While trying to disable general template instantiation with <code>static_assert</code> I discovered that the above code in <code>clang</code> generates the assert error even when the template is not instantiated, while <code>gcc</code> generates the assert error only when instantiating <code>Hitchhiker</code> with a parameter other than <code>42</code>.</p>\n<p>Fiddling around I found that this assert:</p>\n<pre><code>template &lt;int answer&gt; struct Hitchhiker {\n  static_assert(sizeof(int[answer]) != sizeof(int[answer]), \"Invalid answer\");\n};\n\ntemplate &lt;&gt; struct Hitchhiker&lt;42&gt; {};\n</code></pre>\n<p>behaves the same on both compilers: the assert kicks in only when the general template is instantiated.</p>\n<p>What does the standard says, which compiler is right?</p>\n<pre><code>g++ 4.9.2\nclang++ 3.50\n</code></pre>\n", "Tags": "<c++><templates><language-lawyer><c++14><dependent-name>", "OwnerUserId": "2805305", "AnswerCount": "2"}});