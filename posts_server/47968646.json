post_cb({"47968646": {"ViewCount": "72", "Body": "<p>In the following code the move constructor of the derived class is obviously not generated although the base class is move constructible.</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;memory&gt;\n#include &lt;cstring&gt;\n#include &lt;cassert&gt;\n\ntemplate &lt;typename T&gt;\nclass unique_array : public std::unique_ptr&lt;T[],void (*)(void*)&gt;\n{   size_t Size;\n protected:\n    typedef std::unique_ptr&lt;T[],void (*)(void*)&gt; base;\n    unique_array(T* ptr, size_t size, void (*deleter)(void*)) noexcept : base(ptr, deleter), Size(size) {}\n public:\n    constexpr unique_array() noexcept : base(NULL, operator delete[]), Size(0) {}\n    explicit unique_array(size_t size) : base(new T[size], operator delete[]), Size(size) {}\n    unique_array(unique_array&lt;T&gt;&amp;&amp; r) : base(move(r)), Size(r.Size) { r.Size = 0; }\n    void reset(size_t size = 0) { base::reset(size ? new T[size] : NULL); Size = size; }\n    void swap(unique_array&lt;T&gt;&amp;&amp; other) noexcept { base::swap(other); std::swap(Size, other.Size); }\n    size_t size() const noexcept { return Size; }\n    T* begin() const noexcept { return base::get(); }\n    T* end() const noexcept { return begin() + Size; }\n    T&amp; operator[](size_t i) const { assert(i &lt; Size); return base::operator[](i); }\n    unique_array&lt;T&gt; slice(size_t start, size_t count) const noexcept\n    {   assert(start + count &lt;= Size); return unique_array&lt;T&gt;(begin() + start, count, [](void*){}); }\n};\n\ntemplate &lt;typename T&gt;\nclass unique_num_array : public unique_array&lt;T&gt;\n{   static_assert(std::is_arithmetic&lt;T&gt;::value, \"T must be arithmetic\");\n public:\n    using unique_array&lt;T&gt;::unique_array;\n    unique_num_array(unique_num_array&lt;T&gt;&amp;&amp; r) : unique_array&lt;T&gt;(move(r)) {}\n    unique_num_array&lt;T&gt; slice(size_t start, size_t count) const noexcept\n    {   assert(start + count &lt;= this-&gt;size()); return unique_num_array&lt;T&gt;(this-&gt;begin() + start, count, [](void*){}); }\n public: // math operations\n    void clear() const { std::memset(this-&gt;begin(), 0, this-&gt;size() * sizeof(T)); }\n    const unique_num_array&lt;T&gt;&amp; operator =(const unique_num_array&lt;T&gt;&amp; r) const { assert(this-&gt;size() == r.size()); memcpy(this-&gt;begin(), r.begin(), this-&gt;size() * sizeof(T)); return *this; }\n    const unique_num_array&lt;T&gt;&amp; operator +=(const unique_num_array&lt;T&gt;&amp; r) const;\n    // ...\n};\n\nint main()\n{   // works\n    unique_array&lt;int&gt; array1(7);\n    unique_array&lt;int&gt; part1 = array1.slice(1,3);\n    // does not work\n    unique_num_array&lt;int&gt; array2(7);\n    unique_num_array&lt;int&gt; part2 = array2.slice(1,3);\n    // test for default constructor\n    unique_num_array&lt;int&gt; array3;\n    return 0;\n}\n</code></pre>\n<p>With the above code I get an error (gcc 4.8.4):</p>\n<blockquote>\n<p id=\"so_47968646_47968646_0\">test6.cpp: In function \u2018int main()\u2019: test6.cpp:47:48: error: use of\n  deleted function \u2018unique_num_array::unique_num_array(const\n  unique_num_array&amp;)\u2019   unique_num_array part2 =\n  array2.slice(1,3);</p>\n</blockquote>\n<p>The slice function in the derived class cannot return by value because the <strong>move constructor is missing</strong>. All other constructors seem to work as expected (not covered by this example).</p>\n<p>If I define the move constructor explicitly (uncomment line) the example compiles. But in this case the default constructor vanishes which is, of course, not intended.</p>\n<p>What is going on here? I do not understand either of the cases.</p>\n<p>Why is the move constructor deleted in the first case?</p>\n<p>Why is the default constructor dropped in the second case? Others seem to survive.</p>\n", "AcceptedAnswerId": "47975346", "Title": "Why is the move constructor not inhereted by using declaration", "CreationDate": "2017-12-25T12:30:54.810", "Id": "47968646", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-12-26T07:32:20.270", "Score": "1", "OwnerUserId": "6256451", "Tags": "<c++><c++11><constructor><using-declaration>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47968646_47970710_2": {"length": 5, "quality": 1.0, "section_id": 458}, "so_47968646_47975346_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 369}, "so_47968646_47970710_4": {"length": 6, "quality": 1.0, "section_id": 458}, "so_47968646_47975346_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 458}, "so_47968646_47970710_5": {"length": 4, "quality": 1.0, "section_id": 458}, "so_47968646_47970710_7": {"length": 10, "quality": 0.8333333333333334, "section_id": 369}, "so_47968646_47970710_3": {"length": 6, "quality": 1.0, "section_id": 458}, "so_47968646_47970710_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 458}}, "n3337": {"so_47968646_47970710_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 449}, "so_47968646_47970710_2": {"length": 5, "quality": 1.0, "section_id": 449}, "so_47968646_47970710_4": {"length": 6, "quality": 1.0, "section_id": 449}, "so_47968646_47970710_5": {"length": 4, "quality": 1.0, "section_id": 449}, "so_47968646_47975346_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 449}, "so_47968646_47970710_7": {"length": 10, "quality": 0.8333333333333334, "section_id": 359}, "so_47968646_47970710_3": {"length": 6, "quality": 1.0, "section_id": 449}, "so_47968646_47975346_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 359}}, "n4659": {"so_47968646_47970710_1": {"length": 13, "quality": 1.0, "section_id": 481}, "so_47968646_47970710_2": {"length": 5, "quality": 1.0, "section_id": 481}, "so_47968646_47970710_4": {"length": 6, "quality": 1.0, "section_id": 481}, "so_47968646_47970710_5": {"length": 4, "quality": 1.0, "section_id": 481}, "so_47968646_47975346_1": {"length": 19, "quality": 1.0, "section_id": 481}, "so_47968646_47970710_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 396}, "so_47968646_47970710_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 381}, "so_47968646_47970710_3": {"length": 6, "quality": 1.0, "section_id": 481}, "so_47968646_47975346_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 381}}}, "47970710": {"Id": "47970710", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47968646_47970710_0\">Why is the move constructor deleted in the first case?</p>\n</blockquote>\n<p>Because there is a user-declared copy assignment operator in <code>unique_num_array&lt;T&gt;</code>, no move constructor is implicitly declared by the compiler. The standard in [class.copy.ctor]/8 says</p>\n<blockquote>\n<p id=\"so_47968646_47970710_1\">If the definition of a class X does not explicitly declare a move constructor, a non-explicit one will be implicitly declared as defaulted if and only if</p>\n<ul>\n<li><p id=\"so_47968646_47970710_2\">X does not have a user-declared copy constructor,</p></li>\n<li><p id=\"so_47968646_47970710_3\"><strong>X does not have a user-declared copy assignment operator</strong>,</p></li>\n<li><p id=\"so_47968646_47970710_4\">X does not have a user-declared move assignment operator, and</p></li>\n<li><p id=\"so_47968646_47970710_5\">X does not have a user-declared destructor.</p></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_47968646_47970710_6\">Why is the default constructor dropped in the second case?</p>\n</blockquote>\n<p>Because there is a user-declared move constructor in <code>unique_num_array&lt;T&gt;</code>, no default constructor is implicitly declared by the compiler. The standard in [class.ctor]/4 says</p>\n<blockquote>\n<p id=\"so_47968646_47970710_7\">... If <strong>there is no user-declared constructor for class X</strong>, a non-explicit constructor having no parameters is implicitly declared as defaulted ([dcl.fct.def]).</p>\n</blockquote>\n<hr>\n<p>In addition, this code will work after C++17 because of guaranteed <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">copy elision</a>. In detail, before C++17, the <strong>semantic</strong> of both the context</p>\n<pre><code>return unique_num_array&lt;T&gt;(...);\n</code></pre>\n<p>and</p>\n<pre><code>unique_num_array&lt;int&gt; part2 = array2.slice(1,3);\n</code></pre>\n<p>requires a copy/move operation, while after C++17, the semantic becomes that the destination object is initialized by the prvalue initializer without ever materializing a temporary, thus no copy/move is required.</p>\n</hr></hr>", "LastEditorUserId": "5376789", "LastActivityDate": "2017-12-25T17:32:07.177", "Score": "4", "CreationDate": "2017-12-25T17:26:38.233", "ParentId": "47968646", "CommentCount": "2", "OwnerUserId": "5376789", "LastEditDate": "2017-12-25T17:32:07.177"}, "47975346": {"Id": "47975346", "PostTypeId": "2", "Body": "<p>There are two sets of rules that apply here:</p>\n<ol>\n<li><p><strong>Neither the move constructor nor the default constructor is covered by the using directive.</strong></p>\n<blockquote>\n<p id=\"so_47968646_47975346_0\">[...] All candidate inherited constructors <strong>that aren't the default constructor or the copy/move constructor</strong> and whose signatures do not match user-defined constructors in the derived class, are implicitly declared in the derived class.</p>\n</blockquote></li>\n<li><p>Now <strong>the rules for auto generating non-explicit constructors apply</strong> (as xskxsr already mentioned).</p>\n<blockquote>\n<p id=\"so_47968646_47975346_1\">If the definition of a class X does not explicitly declare a move constructor, a non-explicit one will be implicitly declared as defaulted if and only <strong>if</strong> [...]\n  <strong>X does not have a user-declared copy assignment operator</strong></p>\n<p id=\"so_47968646_47975346_2\">[...] <strong>If there is no user-declared constructor for class X</strong>, a non-explicit constructor having no parameters is implicitly declared as defaulted ([dcl.fct.def]).</p>\n</blockquote></li>\n</ol>\n", "LastActivityDate": "2017-12-26T07:32:20.270", "Score": "1", "CreationDate": "2017-12-26T07:32:20.270", "ParentId": "47968646", "CommentCount": "0", "OwnerUserId": "6256451"}});