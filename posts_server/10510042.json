post_cb({"10510042": {"AcceptedAnswerId": "10510105", "Tags": "<c++><namespaces><scope><function-overloading><using-declaration>", "AnswerCount": "1", "OwnerUserId": "141719", "Body": "<p>For example, GCC and clang both fail to compile the following code:</p>\n<pre><code>struct S {};\n\nnamespace N\n{\n    void g(S);\n}\n\nusing N::g;\n\nnamespace N\n{\n    void g(int);\n}\n\nint main()\n{\n    g(0);\n}\n</code></pre>\n<p>with the error:</p>\n<pre><code>test.cpp: In function 'int main()':\ntest.cpp:17:8: error: could not convert '0' from 'int' to 'S'\n     g(0);\n        ^\n</code></pre>\n<p>suggesting that the using-declaration only imports the overloads declared <strong>above</strong> the point where the using-declaration appears, not ones that may appear later (but before the use of the name).</p>\n<p>Is this behaviour correct?</p>\n", "CommentCount": "0", "CreationDate": "2012-05-09T04:53:47.713", "PostTypeId": "1", "LastActivityDate": "2012-05-09T15:48:29.283", "Id": "10510042", "Title": "Does a using-declaration only import overloads declared above the using-declaration?", "Score": "3", "ViewCount": "78"}, "10510105": {"CreationDate": "2012-05-09T05:00:30.240", "LastActivityDate": "2012-05-09T15:48:29.283", "LastEditorUserId": "452307", "ParentId": "10510042", "Score": "6", "Id": "10510105", "OwnerUserId": "452307", "Body": "<blockquote>\n<p id=\"so_10510042_10510105_0\"><strong>Is this behaviour correct?</strong></p>\n</blockquote>\n<p>Yes, this behavior is correct and is well defined as per the c++ standard.      </p>\n<p>The relevant section is <strong>\u00a7 7.3.3.11</strong> of C++11 standard:</p>\n<blockquote>\n<p id=\"so_10510042_10510105_1\">The entity declared by a using-declaration shall be known in the context using it according to its definition at the point of the using-declaration. Definitions added to the namespace after the using-declaration are not considered when a use of the name is made. </p>\n</blockquote>\n<pre><code>[ Example:    \n    namespace A {\n        void f(int);\n     }\n    using A::f; // f is a synonym for A::f;\n    // that is, for A::f(int).\n    namespace A {\n        void f(char);\n    }\n    void foo() {\n        f(\u2019a\u2019); // calls f(int),\n    } // even though f(char) exists.\n    void bar() {\n        using A::f; // f is a synonym for A::f;\n        // that is, for A::f(int) and A::f(char).\n        f(\u2019a\u2019); // calls f(char)\n    }\n \u2014end example ]\n</code></pre>\n", "CommentCount": "0", "PostTypeId": "2", "LastEditDate": "2012-05-09T15:48:29.283"}, "bq_ids": {"n3337": {"so_10510042_10510105_1": {"section_id": 5286, "quality": 0.9523809523809523, "length": 20}}}});