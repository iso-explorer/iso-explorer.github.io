post_cb({"bq_ids": {"n4140": {"so_29864305_29864445_0": {"section_id": 103, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_29864305_29864445_0": {"section_id": 98, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_29864305_29864445_0": {"section_id": 107, "quality": 0.9411764705882353, "length": 16}}}, "29864445": {"ParentId": "29864305", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Actually, this is made ill-formed by a subtlety in \u00a714.5.1/4:</p>\n<blockquote>\n<p id=\"so_29864305_29864445_0\"><strong>In a</strong> redeclaration, <strong>partial specialization</strong>, explicit specialization or\n  explicit instantiation of a class template, <strong>the <em>class-key</em> shall agree\n  in kind with the original class template declaration</strong> (7.1.6.3).</p>\n</blockquote>\n<p>And, according to \u00a720.9/2, <code>hash</code> is declared as</p>\n<blockquote>\n<p id=\"so_29864305_29864445_1\"><strong>Header <code>&lt;functional&gt;</code> synopsis</strong></p>\n<pre><code>// 20.9.12, hash function primary template:\ntemplate &lt;class T&gt; struct hash;\n</code></pre>\n</blockquote>\n<p>Hence try</p>\n<pre><code>template &lt;int NUMBER&gt;\nstruct hash&lt;Container&lt;NUMBER&gt;&gt; { /*\u2026*/ };\n</code></pre>\n<p>instead.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-25T11:24:16.297", "Id": "29864445", "Score": "3", "CreationDate": "2015-04-25T11:18:54.877", "LastActivityDate": "2015-04-25T11:24:16.297"}, "29864305": {"CommentCount": "5", "ViewCount": "262", "CreationDate": "2015-04-25T11:02:46.900", "LastActivityDate": "2015-04-25T11:24:16.297", "Title": "C2535 with template-class in unordered_map (Microsoft Visual Studio 2015 CTP6)", "AcceptedAnswerId": "29864445", "PostTypeId": "1", "Id": "29864305", "Score": "1", "Body": "<p>I'm getting a strange C2535-compiler error while trying to compile the following code:</p>\n<pre><code>template&lt;int NUMBER&gt;\nclass Container {\npublic:\n    bool operator==(const Container&amp; other) const { return true; }\n};\n\nnamespace std {\n    template &lt;int NUMBER&gt;\n    class hash&lt;Container&lt;NUMBER&gt;&gt; {\n    public:\n        size_t operator()(const Container&lt;NUMBER&gt; &amp; state) const {\n            return 0;\n        }\n    };\n}\n\nint main(int argc, char* argv[]){\n    auto* b = new std::unordered_map&lt; Container&lt;1&gt;, int&gt;(); //C2535\n}\n</code></pre>\n<p>Note that if I use a my own template-based Hasher</p>\n<pre><code>template&lt;int NUMBER&gt;\nclass Hash {\npublic:\n    size_t operator()(const Container&lt;NUMBER&gt; &amp; state) const {\n        return 0;\n    }\n};\n\nint main(int argc, char* argv[]){\n    auto* b = new std::unordered_map&lt; Container&lt;1&gt;, int, Hash&lt;1&gt;&gt;();\n}\n</code></pre>\n<p>the code compiles just fine. And I remember that the code was being compiled without a hitch in Visual Studio 2013 Express.</p>\n<p>Question: Is this a VS 2015 - bug or is this behaviour in some way standard-conforming?</p>\n", "Tags": "<c++><hash><unordered-map><visual-studio-2015>", "OwnerUserId": "3532688", "AnswerCount": "1"}});