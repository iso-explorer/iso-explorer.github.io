post_cb({"22206844": {"ParentId": "22206044", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C++ \"object\" and \"instance\" are used nearly interchangably.</p>\n<p>There is a general programming design pattern of <code>class</code> and <code>instance</code>.  The <code>class</code> holds the information about all <code>instance</code>s in that <code>class</code>.</p>\n<p>In C++ when you declare a <code>class</code> or <code>struct</code>, the compiler makes code that describes how you create an <code>instance</code> of that <code>class</code>, what the data layout is, and provides some methods that can be used to interact with that <code>instance</code> (up to and including destruction).</p>\n<p><code>virtual</code> methods and inheritance seemingly moves some of the methods and layout to the instance: but the amount is quite limited.  Instead, each instance holds pointers to <code>virtual</code> class data.  In some languages, you can do things like replace individual methods of an instance at runtime: but not in C++.</p>\n<p>When you create an instance of that <code>class</code> or <code>struct</code>, it can be via an automatic named variable on the stack (like <code>Foo f;</code>), an anonymous automatic named variable (like <code>some_function( Foo(17,22) )</code>), an instance on the free store (like <code>new Foo(17, 22)</code>), or via placement-<code>new</code> (which is how <code>std::vector</code> and <code>std::make_shared</code> creates instances).</p>\n<p>Confusingly, there is a separate parallel <code>class</code>-<code>instance</code> pattern in C++ -- <code>class template</code>-<code>class</code>.  The <code>class template</code> is the <code>class</code>, the instantiation is the instance.  The <code>template</code> arguments and specializations indicate how, at compile time, you can \"construct\" the <code>class</code>es.  Pattern matching on the <code>class template</code>s provide a limited amount of properties that are not tied to the instances (\"class properties\" in the pattern).  (Arguably the function template-function is another instance of the pattern).</p>\n<p>If you look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf\">C++1y proposal for concepts lite</a> you will see where object and instance might mean different things in C++.</p>\n<pre><code>int x = 0;\nint&amp; foo = x;\nint* bar = &amp;x;\n</code></pre>\n<p><code>x</code> is both an object and an instance of the type <code>int</code>. </p>\n<p><code>foo</code> is an instance of the type <code>int&amp;</code>, but calling <code>foo</code> an object is probably wrong!  It is a reference -- an alias, or a different name for some object (in this case <code>x</code>).</p>\n<p><code>bar</code> is a pointer to an <code>int</code>, which is an instance of type <code>int*</code>, and calling it an object is probably correct.</p>\n<p>This is a useful distinction: a type does not have to denote an object type if it is a reference type.  Object types behave differently than reference types in a number of important ways.</p>\n<p>Now, some types have \"reference semantics\", in that they behave like references in many ways, but are actually <code>class</code>es.  Are instances of such a type better called references or objects?  In horrible cases, some instances have a mixture of both reference and object semantics: such is often a bad sign.</p>\n<p>Via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf\">latest standard</a> in 3.9 [Types] we have the kinds of types in C++.  They describe what an <em>object type</em> is:</p>\n<blockquote>\n<p id=\"so_22206044_22206844_0\">Types describe objects (1.8), references (8.3.2), or functions (8.3.5)</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_22206044_22206844_1\">An object type is a (possibly cv-qualified) type that is not a function type, not a reference type, and not a void type.</p>\n</blockquote>\n<p>So calling the \"instances\" of things that are function types or reference types \"objects\" seems incorrect.  Note that accessing the \"representation\" of a function or a reference instance is basically impossible: references alias into the object they refer to, and using the name of a function decays to a pointers-to-functions at the drop of a hat (and pointers-to-a-function are basically opaque handles that let you invoke them).</p>\n<p>So arguably functions are not instances, and references are not instances.</p>\n<p>On the third hand, we do talk about instantiations of <code>class</code> <code>template</code>s and function <code>template</code>s.  14.7 is \"template instantiation and specialization\", and points of instantiation (of a <code>template</code>) are all formal terms from the standard.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-03-05T19:37:32.007", "Id": "22206844", "Score": "6", "CreationDate": "2014-03-05T19:01:21.917", "LastActivityDate": "2014-03-05T19:37:32.007"}, "22206044": {"CommentCount": "3", "ViewCount": "17470", "PostTypeId": "1", "LastEditorUserId": "2589776", "CreationDate": "2014-03-05T18:23:14.903", "LastActivityDate": "2014-09-11T11:47:32.453", "Title": "Difference between Object and instance : C++", "AcceptedAnswerId": "22206844", "LastEditDate": "2014-03-05T18:27:03.457", "Id": "22206044", "Score": "3", "Body": "<p>I followed a number of posts on SO, and finally I can draw a conclusion that when we \nhave something like :</p>\n<pre><code>Person name;\n</code></pre>\n<p><code>name</code> is an object of class <code>person</code>.</p>\n<p>It becomes instance when instantiate  it :</p>\n<pre><code>name=new Person();\n</code></pre>\n<p>I am a beginner in C++, and so far I have seen we can access the functions and variables like:</p>\n<pre><code>Person name;\nname.getValue;\nname.callFunction();\n</code></pre>\n<p>We need not to use <code>new</code> operator for this. So can we say the differentiating factor between an object and instance can be ignored in C++?</p>\n", "Tags": "<c++><oop><object><instance>", "OwnerUserId": "1820722", "AnswerCount": "5"}, "22206154": {"ParentId": "22206044", "CommentCount": "3", "Body": "<p>Object and instance are two words for the same thing.</p>\n", "OwnerUserId": "1025445", "PostTypeId": "2", "Id": "22206154", "Score": "4", "CreationDate": "2014-03-05T18:28:39.507", "LastActivityDate": "2014-03-05T18:28:39.507"}, "22206361": {"ParentId": "22206044", "CommentCount": "2", "Body": "<p>\"Object\" and \"instance\" are almost interchangeable. In C++, an object is formally any region of storage. \"Instance\" is not a formally defined term, but we typically refer to \"instances of type <code>X</code>\", most commonly used with class types.</p>\n<pre><code>Foo f;\n</code></pre>\n<p>This declaration creates an object named <code>f</code>. The object's type is <code>Foo</code>. You could say the object <code>f</code> is an instance of <code>Foo</code>.</p>\n<p>Your attempt to distinguish the terms was incorrect. The two things you've actually pointed out are two different ways of creating objects.</p>\n<pre><code>Person name;\n</code></pre>\n<p>In this case, we're creating an object <code>name</code> of type <code>Person</code>.</p>\n<pre><code>Person* name = new Person();\n</code></pre>\n<p>In this case, we're creating an object <code>name</code> of type <code>Person*</code> (pointer to <code>Person</code>). We are also creating another object of type <code>Person</code> using the expression <code>new Person()</code>. This expression returns a pointer, which we are initialising the <code>name</code> object with.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "22206361", "Score": "2", "CreationDate": "2014-03-05T18:37:51.800", "LastActivityDate": "2014-03-05T18:37:51.800"}, "22206458": {"ParentId": "22206044", "CommentCount": "2", "Body": "<p>First, you should know that there is no difference between \"object\" and \"instance\". They are synonyms. In C++, you also call instances of primitive types like <code>int</code> or <code>double</code> \"objects\". One of the design principles of C++ is that custom types (i.e. classes) can be made to behave exactly like primitive types. In fact, in C++, one often prefers to refer to \"types\" and not \"classes\".</p>\n<p>So, <em>types</em> and <em>objects</em> it shall be. Now that we've settled this, I'm afraid I must tell you that your conclusions are wrong.</p>\n<p><code>Person</code> is a <em>type</em>.\n<code>name</code> is a (not very well named) variable to access an <em>object</em> of that type.</p>\n<p>A whole line of C++ code would look like this:</p>\n<pre><code>Person name;\n</code></pre>\n<p>This means: \"create an object of type Person and let me access it via the name variable\".</p>\n<p><code>new Person()</code> is much more complicated. You may be familiar with the <code>new</code> keyword from languages like Java, but in C++, it's a very different beast. It means that a new object of type <code>Person</code> is created, but it also means that <strong>you are responsible for destroying it</strong> later on. It also gives you a different kind of handle to the newly created object: a so-called <em>pointer</em>. A <code>Person</code> pointer looks like this:</p>\n<pre><code>Person*\n</code></pre>\n<p>A pointer is itself a type, and the types <code>Person*</code> and <code>Person</code> are not compatible. (I told you that this would be much more complicated :))</p>\n<p>You will notice the incompatibility when you try to compile the following line:</p>\n<pre><code>Person name = new Person();\n</code></pre>\n<p>It won't compile; you will instead receive an error message. You'd have to do it like this instead:</p>\n<pre><code>Person* name_ptr = new Person();\n</code></pre>\n<p>And then you'd have to access all the members of <code>Person</code> with a different syntax:</p>\n<pre><code>name_ptr-&gt;getValue();\nname_ptr-&gt;callFunction();\n</code></pre>\n<p>Finally, remember you must explicitly destroy the object in this case:</p>\n<pre><code>delete name_ptr;\n</code></pre>\n<p>If you forget this, bad things can happen. More precisely, your program will likely use more and more memory the longer it runs.</p>\n<p>I think that pointers are too advanced yet for your level of C++ understanding. Stay away from them until you actually need them.</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "22206458", "Score": "3", "CreationDate": "2014-03-05T18:43:07.920", "LastActivityDate": "2014-03-05T18:43:07.920"}, "bq_ids": {"n4140": {"so_22206044_22206844_1": {"section_id": 7206, "quality": 0.9090909090909091, "length": 10}, "so_22206044_22206844_0": {"section_id": 7199, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_22206044_22206844_1": {"section_id": 6950, "quality": 0.9090909090909091, "length": 10}, "so_22206044_22206844_0": {"section_id": 6943, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_22206044_22206844_1": {"section_id": 4058, "quality": 0.8181818181818182, "length": 9}, "so_22206044_22206844_0": {"section_id": 8708, "quality": 0.7142857142857143, "length": 5}}}, "25786658": {"ParentId": "22206044", "CommentCount": "0", "Body": "<p>It is very simple but very important </p>\n<p>Take a general example:  what is the general meaning of object? its nothing but which occupies some space right....keep that in mind we now talk about Object in java or C++</p>\n<p>example: here I am creating Object \u00a0 \u00a0  <strong>Student std=new Student();</strong></p>\n<p>where <strong>Student</strong> is a <strong>Class</strong> and <strong>std</strong> is a <strong>Object</strong> because we Created a memory for std with the help of <strong>new</strong> keyWord it means it internally occupies some space in memory right thats y we call <strong>std</strong> as <strong>Object</strong> </p>\n<p>if you won`t create memory for an object so we call that <strong>object</strong> as <strong>instance</strong>.</p>\n<p>example: Student std;</p>\n<p>here <strong>Student</strong> is a class and <strong>std</strong> is a instance(means a just a copy that class),with this we won`t do anything untill unless we create a memory for that.</p>\n<p>Thats all about object and Instance :)</p>\n", "OwnerUserId": "4030528", "PostTypeId": "2", "Id": "25786658", "Score": "2", "CreationDate": "2014-09-11T11:47:32.453", "LastActivityDate": "2014-09-11T11:47:32.453"}});