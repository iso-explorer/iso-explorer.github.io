post_cb({"bq_ids": {"n4140": {"so_5149119_5149468_3": {"length": 13, "quality": 1.0, "section_id": 7093}, "so_5149119_5149468_1": {"length": 7, "quality": 0.875, "section_id": 7093}, "so_5149119_5149468_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 7085}, "so_5149119_5149468_4": {"length": 22, "quality": 1.0, "section_id": 7093}, "so_5149119_5149468_7": {"length": 10, "quality": 0.8333333333333334, "section_id": 181}, "so_5149119_5149468_2": {"length": 17, "quality": 1.0, "section_id": 7093}, "so_5149119_5149468_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 7056}}, "n3337": {"so_5149119_5149468_3": {"length": 13, "quality": 1.0, "section_id": 6837}, "so_5149119_5149468_1": {"length": 7, "quality": 0.875, "section_id": 6837}, "so_5149119_5149468_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 6829}, "so_5149119_5149468_7": {"length": 10, "quality": 0.8333333333333334, "section_id": 175}, "so_5149119_5149468_2": {"length": 17, "quality": 1.0, "section_id": 6837}, "so_5149119_5149468_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 6838}, "so_5149119_5149468_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 6800}, "so_5149119_5149468_4": {"length": 22, "quality": 1.0, "section_id": 6837}}, "n4659": {"so_5149119_5149468_3": {"length": 13, "quality": 1.0, "section_id": 8594}, "so_5149119_5149468_1": {"length": 7, "quality": 0.875, "section_id": 8594}, "so_5149119_5149468_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 8586}, "so_5149119_5149468_7": {"length": 10, "quality": 0.8333333333333334, "section_id": 186}, "so_5149119_5149468_2": {"length": 17, "quality": 1.0, "section_id": 8594}, "so_5149119_5149468_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 8553}, "so_5149119_5149468_4": {"length": 22, "quality": 1.0, "section_id": 8594}}}, "5149119": {"ViewCount": "671", "Body": "<p>Does anyone know why template arguments are needed for return-types but not for argument-types when defining template-methods?  An example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Car {\n  Car drive(Car);  // will be defined after the template declaration.\n};\n\n// Attempt #1: does not compile.\n// Error: use of class template Car requires template arguments\ntemplate&lt;typename T&gt;\ninline Car Car&lt;T&gt;::drive(Car) {}\n\n// Attempt #2: compiles!  \n// The only difference is the use of template argument in return type.\n// However, note that the argument to func does not require template argument!\ntemplate&lt;typename T&gt;\ninline Car&lt;T&gt; Car&lt;T&gt;::drive(Car) {}\n</code></pre>\n<p>Not sure why the template argument is needed for the return-type but not required for the argument-type.  When Attempt #1 failed, I was expecting Attempt #2 to fail too and expected I would need:</p>\n<pre><code>template&lt;typename T&gt;\ninline Car&lt;T&gt; Car&lt;T&gt;::drive(Car&lt;T&gt;) {}  // but no need to go this far.\n</code></pre>\n<p>but Attempt #2 worked!</p>\n<p>Is there good reason for this behavior?</p>\n", "AcceptedAnswerId": "5149223", "Title": "Template Arguments Needed in Return Types during Method Definition", "CreationDate": "2011-03-01T00:11:34.700", "Id": "5149119", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-03-01T01:12:00.280", "Score": "5", "OwnerUserId": "2063015", "Tags": "<c++><templates>", "AnswerCount": "3"}, "5149172": {"Id": "5149172", "PostTypeId": "2", "Body": "<p>First, you acknowledge this makes no sense: <code>Car c;</code>, right? <code>Car</code> must have template arguments. That's why you need to specify it on the return type, and on the class name.</p>\n<p>But after the scope-resolution operator (<code>::</code>), <code>Car&lt;T&gt;</code> is <em>injected</em> as <code>Car</code>*, so <code>Car</code> is an alias to <code>Car&lt;T&gt;</code>. But this only happens inside the scope of <code>Car&lt;T&gt;</code>, which is why you need it everywhere else but not after <code>::</code>. Of course, you are free to explicitly specify the arguments yourself anyway.</p>\n<hr>\n<p>*This feature is better explained like this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo\n{\n    // as if the compiler did this:\n    typedef foo&lt;T&gt; foo; // (of course, actually illegal)\n};\n</code></pre>\n<p><code>foo</code> is available within the scope of <code>foo&lt;T&gt;</code> as <code>foo&lt;T&gt;</code>. After the scope-resolution operator, though, that scope is available for use, and the template arguments are optional.</p>\n</hr>", "LastActivityDate": "2011-03-01T00:20:23.460", "CommentCount": "1", "CreationDate": "2011-03-01T00:20:23.460", "ParentId": "5149119", "Score": "9", "OwnerUserId": "87234"}, "5149223": {"Id": "5149223", "PostTypeId": "2", "Body": "<p>This is because argument(s) type(s) of a method are deduced using class scope, but return type is deduced from the same scope where a class is defined if those methods are defined outside class scope. This is true for everything, not only templates. To add to your example, the following won't compile:</p>\n<pre><code>class Foo\n{\n    typedef int Bar;\n\n    Bar foo () const;\n};\n\nBar\nFoo::foo () const\n{\n    return 0;\n}\n</code></pre>\n<p>... and to fix it you have to tell exactly that Bar is from Foo's scope:</p>\n<pre><code>Foo::Bar\nFoo::foo () const\n{\n    return 0;\n}\n</code></pre>\n", "OwnerDisplayName": "user405725", "LastActivityDate": "2011-03-01T00:28:46.377", "Score": "2", "CreationDate": "2011-03-01T00:28:46.377", "ParentId": "5149119", "CommentCount": "1"}, "5149468": {"Id": "5149468", "PostTypeId": "2", "Body": "<p>From N3225, 3.4.1/8 (unqualified name lookup), a name used after a member function's declarator-id shall be looked-up inside the class definition first.</p>\n<blockquote>\n<p id=\"so_5149119_5149468_0\">A name used in the definition of a\n  member function (9.3) of class X\n  following the function\u2019s declarator-id\n  (That is, an unqualified name that occurs, for instance, in a type or default argument expression in the parameter declaration-\n  clause or in the function body.) or in the\n  brace-or-equal-initializer of a\n  non-static data member (9.2) of class\n  X shall be declared in one of the\n  following ways:</p>\n<p id=\"so_5149119_5149468_1\">\u2014 before its use in class X or be a\n  member of a base class of X (10.2), or</p>\n<p id=\"so_5149119_5149468_2\">\u2014 if X is a nested class of class Y\n  (9.7), before the definition of X in\n  Y, or shall be a member of a base\n  class of Y (this lookup applies in\n  turn to Y \u2019s enclosing classes,\n  starting with the innermost enclosing\n  class), or </p>\n<p id=\"so_5149119_5149468_3\">\u2014 if X is a local class\n  (9.8) or is a nested class of a local\n  class, before the definition of class\n  X in a block enclosing the definition\n  of class X, or </p>\n<p id=\"so_5149119_5149468_4\">\u2014 if X is a member of\n  namespace N, or is a nested class of a\n  class that is a member of N, or is a\n  local class or a nested class within a\n  local class of a function that is a\n  member of N, before the definition of\n  class X in namespace N or in one of N\n  \u2019s enclosing namespaces.</p>\n</blockquote>\n<p>Then injected-class-name is a normal class member for the purpose of name lookup, and injected-class-name is declared at the beginning of the class, before any other members.</p>\n<p>3.3.2/7</p>\n<blockquote>\n<p id=\"so_5149119_5149468_5\">The point of declaration for an\n  injected-class-name (Clause 9) is\n  immediately following the opening\n  brace of the class definition.</p>\n</blockquote>\n<p>3.4/3</p>\n<blockquote>\n<p id=\"so_5149119_5149468_6\">The injected-class-name of a class\n  (Clause 9) is also considered to be a\n  member of that class for the purposes\n  of name hiding and lookup.</p>\n</blockquote>\n<p>Lastly, for template,</p>\n<p>14.6.1/3</p>\n<blockquote>\n<p id=\"so_5149119_5149468_7\">The injected-class-name of a class\n  template or class template\n  specialization can be used either with\n  or without a template-argument-list\n  wherever it is in scope.</p>\n</blockquote>\n<p>Therefore,</p>\n<pre><code>template&lt;typename T&gt;\ninline Car&lt;T&gt; Car&lt;T&gt;::drive(Car) {}\n</code></pre>\n<p>The first return type name Car cannot find injected-class-name, because it is looked up as a normal name and will find the global class Car.</p>\n<p>But the second parameter type Car can find injected-class-name, because it is after the function's delcarator-id. Injected-class-name can be used with or without bracket T bracket.</p>\n<p>So you got the answer now.</p>\n", "LastActivityDate": "2011-03-01T01:12:00.280", "CommentCount": "2", "CreationDate": "2011-03-01T01:12:00.280", "ParentId": "5149119", "Score": "0", "OwnerUserId": "534498"}});