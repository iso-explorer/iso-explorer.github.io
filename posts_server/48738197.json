post_cb({"bq_ids": {"n4140": {"so_48738197_48738504_0": {"length": 39, "quality": 0.6610169491525424, "section_id": 6046}}, "n3337": {"so_48738197_48738504_0": {"length": 57, "quality": 0.9661016949152542, "section_id": 5814}}, "n4659": {"so_48738197_48738504_0": {"length": 39, "quality": 0.6610169491525424, "section_id": 7545}}}, "48738197": {"ViewCount": "57", "Body": "<p>So I came across this piece of code reading about arduino's memory</p>\n<pre><code>void EEPROM_writeDouble(int address, double value)\n{\n   byte* p = (byte*)(void*)&amp;value;\n   for (int i = 0; i &lt; sizeof(value); i++)\n   {\n      EEPROM.write(address++, *p++);\n   }\n}\n</code></pre>\n<p>What intrigues me is this line of code <code>byte* p = (byte*)(void*)&amp;value;</code> do completety but didn't figure it out or maybe. So we have a pointer of type <code>byte(char)</code> that takes the reference of value of type <code>void*</code> and convert it to an byte pointer? </p>\n", "AcceptedAnswerId": "48738504", "Title": "c++ double cast void pointer", "CreationDate": "2018-02-12T00:59:22.127", "LastActivityDate": "2018-02-12T01:47:22.367", "CommentCount": "3", "LastEditDate": "2018-02-12T01:05:45.987", "PostTypeId": "1", "LastEditorUserId": "391161", "Id": "48738197", "Score": "2", "OwnerUserId": "3134909", "Tags": "<c++><casting>", "AnswerCount": "3"}, "48738504": {"Id": "48738504", "PostTypeId": "2", "Body": "<p>Since a conversion from <code>double*</code> to <code>byte*</code> would not be a valid <code>static_cast</code> or <code>const_cast</code>, C++ interprets a C-style cast requesting that conversion as equivalent to a <code>reinterpret_cast</code>.  (I'm assuming <code>byte</code> is a typedef for <code>unsigned char</code> or <code>char</code>.)</p>\n<p>In the original C++98 Standard and in the C++03 Standard, there were essentially no guarantees on what a <code>reinterpret_cast</code> will do, just saying that the result was \"implementation-defined\".  So a single cast would probably get a pointer to the beginning of the storage for the <code>double</code> variable, but technically you couldn't count on that.</p>\n<p>On the other hand, the two conversions in the example, from <code>double*</code> to <code>void*</code> and then from <code>void*</code> to <code>byte*</code>, are valid <code>static_cast</code> conversions, so the C-style casts would both have the behavior of a <code>static_cast</code>.  And a <code>static_cast</code> to or from a (non-null) [cv] <code>void*</code> has always guaranteed the <code>void*</code> points at the beginning of the object's storage, resulting in a pointer to an imaginary <code>byte</code> overlapping the storage of the <code>double</code> object.  (And reading from an <code>unsigned char</code> or <code>char</code> which is really in storage belonging to an object of a different type is a specific exception to the strict aliasing rules, so that's okay.)</p>\n<p>Note that beginning with the C++11 Standard, the behavior of <code>reinterpret_cast</code>, and therefore C-style casts, was more specified for certain categories of pointer conversions: ([expr.reinterpret.cast]/7)</p>\n<blockquote>\n<p id=\"so_48738197_48738504_0\">An object pointer can be explicitly converted to an object pointer of a different type.  When a prvalue <code>v</code> of type \"pointer to <code>T1</code>\" is converted to the type \"pointer to <em>cv</em> <code>T2</code>\", the result is <code>static_cast&lt;</code><em>cv</em><code>T2*&gt;(static_cast&lt;</code><em>cv</em><code>void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is void.  Converting a prvalue of type \"pointer to <code>T1</code>\" to the type \"pointer to <code>T2</code>\" (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value.  The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>So using a recent Standard mode, the two casts are no longer necessary.  (The code might have been written earlier, or might need to still work under multiple C++ versions, or might have just been written using old habits.  Though using C++-style casts to say what sort of conversion logic you really mean is nearly always a better idea than using C-style casts.)</p>\n", "LastActivityDate": "2018-02-12T01:47:22.367", "Score": "3", "CreationDate": "2018-02-12T01:47:22.367", "ParentId": "48738197", "CommentCount": "0", "OwnerUserId": "459640"}, "48738388": {"Id": "48738388", "PostTypeId": "2", "Body": "<p>The standard defines that <code>(byte *)p</code> is the same as <code>(byte *)(void *)p</code>, if <code>p</code> is a pointer. </p>\n<p>In more detail, N4659 [expr.reinterpret.cast]/7 defines <code>reinterpret_cast&lt;T1 *&gt;(p)</code> as <code>static_cast&lt;T1 *&gt;(static_cast&lt;void *&gt;(p))</code>, and [expr.cast] covers that the two C-style casts resolve to <code>static_cast</code> in this case.</p>\n<p>So this cast is redundant, we could speculate that the author didn't know the language so well.</p>\n", "LastActivityDate": "2018-02-12T01:31:17.090", "Score": "2", "CreationDate": "2018-02-12T01:31:17.090", "ParentId": "48738197", "CommentCount": "0", "OwnerUserId": "1505939"}, "48738292": {"Id": "48738292", "PostTypeId": "2", "Body": "<p>There's no actual reason for this cast. The code is doing type punning and the programmer who wrote the code was probably confused. When trying to get individual bytes out of a variable, you can use an <code>unsigned char*</code> pointer. Which I assume is what <code>byte</code> is in this example. You do not need to go through a <code>void*</code> pointer for this.</p>\n", "LastEditorUserId": "856199", "LastActivityDate": "2018-02-12T01:27:46.967", "Score": "3", "CreationDate": "2018-02-12T01:16:22.127", "ParentId": "48738197", "CommentCount": "0", "OwnerUserId": "856199", "LastEditDate": "2018-02-12T01:27:46.967"}});