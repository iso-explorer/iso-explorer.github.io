post_cb({"bq_ids": {"n4140": {"so_37581041_37581235_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}}, "n3337": {"so_37581041_37581235_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}}}, "37581041": {"ViewCount": "108", "Body": "<p>I am implementing a <code>SizeTag</code> method that will take a size value and keep the l-value reference.</p>\n<p>Things work fine and in this code the intent is to use the <code>T&amp;&amp;</code>  constructor.</p>\n<p>However, if I explicitly delete the copy constructor the compiler will give an error:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename T = std::uint64_t&gt;\nclass SizeTag {\n  public: \n    using size_type = std::uint64_t;\n    using Type = std::conditional_t&lt;std::is_lvalue_reference&lt;T&gt;::value, const size_type&amp;, size_type&gt;;\n    inline const Type&amp; get() const { return _size; }\n\n    SizeTag(T&amp;&amp; sz) : _size(std::forward&lt;T&gt;(sz)) { }\n    SizeTag&amp; operator = (const SizeTag&amp;) = delete;\n\n    SizeTag(const SizeTag&amp;) = delete;   // No error if this line removed\n\n  private:\n    Type _size;\n};\n\ntemplate &lt;typename T&gt;\nSizeTag&lt;T&gt; make_size_tag(T&amp;&amp; t) {\n  return std::forward&lt;T&gt;(t);\n}\n\nint main()\n{\n    int a = 9;\n    make_size_tag(a);\n}\n</code></pre>\n<p>Why is this happening? The copy constructor should never be called in this case.</p>\n", "AcceptedAnswerId": "37582248", "Title": "Explicitly delete never-use copy constructor give compile error", "CreationDate": "2016-06-02T00:54:34.427", "Id": "37581041", "CommentCount": "8", "LastEditDate": "2016-06-02T03:15:08.773", "PostTypeId": "1", "LastEditorUserId": "1505939", "LastActivityDate": "2016-06-02T03:57:06.790", "Score": "1", "OwnerUserId": "2828925", "Tags": "<c++><constructor><copy-constructor><perfect-forwarding>", "AnswerCount": "3"}, "37582248": {"PostTypeId": "2", "Body": "<p>The function <code>make_size_tag</code> returns <code>SizeTag&lt;T&gt;</code> by value.</p>\n<p>Let's recap how <a href=\"http://en.cppreference.com/w/cpp/language/return\" rel=\"nofollow\">function returning by value</a> works:</p>\n<ul>\n<li>There is a temporary object usually called the <em>return value object</em>.</li>\n<li>For the case <code>return expression;</code>:\n\n<ul>\n<li>The expression <em>copy-initializes</em> the return value object.</li>\n<li>This is a copy elision context.</li>\n</ul></li>\n<li>For the case <code>return { zero_or_more_items };</code>:\n\n<ul>\n<li>The braced list <em>copy-list-initializes</em> the return value object.</li>\n</ul></li>\n<li>If the calling code initializes an variable with the function call, then the return value object is the initializer. (The exact form of initialization may vary depending on the calling code). For initialization of an object, this is also a copy elision context.</li>\n</ul>\n<p>In your code, <code>make_size_tag(a)</code> deduces <code>T</code> (the parameter of <code>make_size_tag</code> ) to <code>int&amp;</code>, because this is a perfect forwarding scenario.</p>\n<p>The instantiation of <code>make_size_tag</code> for this <code>T</code> looks like, after expanding out <a href=\"http://en.cppreference.com/w/cpp/utility/forward\" rel=\"nofollow\">std::forward</a>:</p>\n<pre><code>SizeTag&lt;int&amp;&gt; make_size_tag(int&amp; t)\n{\n    return t;\n}\n</code></pre>\n<p>because <code>static_cast&lt;int&amp;&gt;(t)</code> is just the same as <code>t</code> , since <code>t</code> is already an lvalue of type <code>int</code>.</p>\n<hr>\n<p>As mentioned earlier, this code <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow\">copy-initializes</a> the return value object. So the code now behaves sort of like:</p>\n<pre><code>SizeTag&lt;int&amp;&gt; temp_rv = t;\n</code></pre>\n<p>and because <code>t</code> is not a <code>SizeTag</code>, the definition of copy-initialization is that this is the same as:</p>\n<pre><code>SizeTag&lt;int&amp;&gt; temp_rv = SizeTag&lt;int&amp;&gt;(t);\n</code></pre>\n<p>which obviously invokes a copy/move operation to initialize <code>temp_rv</code> from a temporary of type <code>SizeTag&lt;int&amp;&gt;</code>. Although this copy would be elided by copy elision, the accessible copy/move constructor must exist.</p>\n<hr>\n<p>The solution suggested by Jarod42, putting braces around the return expression, works because the equivalent initialization is now <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization#copy-list-initialization\" rel=\"nofollow\">copy-list-initialization</a>:</p>\n<pre><code>SizeTag&lt;int&amp;&gt; temp_list_rv { t };\n</code></pre>\n<p>which initializes <code>temp_list_rv</code> using the <code>SizeTag&lt;int&amp;&gt;(int&amp;)</code> constructor.</p>\n<hr>\n<p>NB; Your code has a separate bug: since <code>Type</code> is <code>const uint64_t &amp;</code>,  the initialization of <code>_size</code> from <code>int</code> creates a temporary which is destroyed when the <code>SizeTag</code> constructor completes; and so the tag returns with a dangling reference. clang warns about this, but g++ doesn't. </p>\n<p>To fix this: you either need to change <code>Type</code> to be the same as <code>T&amp;</code> so it binds directly to <code>a</code>, e.g.:</p>\n<pre><code>using size_type = typename std::remove_reference&lt;T&gt;::type;\n</code></pre>\n<p>or make <code>_size</code> not be a reference. It seems the latter would defeat the whole purpose of your tag, so you might need to rethink your design a bit.</p>\n<p>To avoid the possibility of generating this danging reference, change <code>const size_type &amp;</code> to <code>size_type &amp;</code> in the conditional_t.  Then the compiler (assuming you're not using MSVC) will point out the problem.</p>\n</hr></hr></hr>", "LastActivityDate": "2016-06-02T03:57:06.790", "LastEditorUserId": "1505939", "Id": "37582248", "CommentCount": "0", "CreationDate": "2016-06-02T03:42:32.217", "ParentId": "37581041", "Score": "2", "OwnerUserId": "1505939", "LastEditDate": "2016-06-02T03:57:06.790"}, "37581235": {"PostTypeId": "2", "Body": "<p>You have to use <code>{}</code> to avoid the copy/move constructor in that case:</p>\n<pre><code>template &lt;typename T&gt;\nSizeTag&lt;T&gt; make_size_tag(T&amp;&amp; t) {\n    return { std::forward&lt;T&gt;(t) } ; // Note the extra {}\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ce0a0be2709c16cb\" rel=\"nofollow\">Demo</a></p>\n<p>Using the braces, use the <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">copy-list-initialization</a> whereas without, you create a temporary object that you copy/move construct (even if RVO apply).</p>\n<p>Section 6.6.3 of the standard:</p>\n<blockquote>\n<p id=\"so_37581041_37581235_0\">A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-02T01:43:07.357", "LastEditorUserId": "2684539", "Id": "37581235", "CommentCount": "3", "CreationDate": "2016-06-02T01:24:03.167", "ParentId": "37581041", "Score": "1", "OwnerUserId": "2684539", "LastEditDate": "2016-06-02T01:43:07.357"}, "37581135": {"PostTypeId": "2", "Body": "<p>A function that returns a <code>class</code> or a <code>struct</code> copies the returned object as part of the process of returning the object. After all, the returned object has to get copied somewhere.</p>\n<p>Although a compiler is allowed to elide, or optimize the copy away when the compiler can prove to itself that this is safe, the copy still technically takes place.</p>\n<p><code>make_size_tag</code>() returns an object. The conversion from <code>T</code> to <code>SizeTag&lt;T&gt;</code> gets implicitly done using <code>SizeTag</code>'s constructor, then the constructed object gets copied on return. Because the copy constructor is <code>delete</code>d, the error is reported.</p>\n", "LastActivityDate": "2016-06-02T01:10:06.277", "Id": "37581135", "CommentCount": "6", "CreationDate": "2016-06-02T01:10:06.277", "ParentId": "37581041", "Score": "2", "OwnerUserId": "3943312"}});