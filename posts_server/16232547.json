post_cb({"16232656": {"ParentId": "16232547", "CommentCount": "3", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/types/is_constructible\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/types/is_constructible</a>:</p>\n<p>The \"constructor expression does not call any operation that is not trivial\". and that is the case when you write</p>\n<pre><code>B(B&amp;);\n</code></pre>\n<p>nothing fancy going on there, you just pass in a reference.</p>\n", "OwnerUserId": "818924", "PostTypeId": "2", "Id": "16232656", "Score": "1", "CreationDate": "2013-04-26T09:08:28.190", "LastActivityDate": "2013-04-26T09:08:28.190"}, "16232547": {"CommentCount": "2", "ViewCount": "394", "PostTypeId": "1", "LastEditorUserId": "1971684", "CreationDate": "2013-04-26T09:02:48.273", "LastActivityDate": "2013-04-26T13:05:32.447", "Title": "incorrect result for std::is_trivially_constructible<T, T&>::value when T declared T::T(T&)", "AcceptedAnswerId": "16233624", "LastEditDate": "2013-04-26T09:25:48.697", "Id": "16232547", "Score": "3", "Body": "<p>This is a little problem that I get confused with, I don't know how to describe it, so just see the codes below:</p>\n<pre><code>struct B {\n  B() {}\n  B(B&amp;) {\n    std::cout &lt;&lt; \"not trivial\\n\";\n  }\n};\n\nint main() {\n  B b1;\n  B b2(b1);\n  std::cout &lt;&lt; std::is_trivially_constructible&lt;B,  B&amp;&gt;::value &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n<p>the output is:</p>\n<pre><code>not trivial\n1\n</code></pre>\n<p>I'm using VS11.</p>\n<p><strong>EDIT:</strong></p>\n<p>I just tested the example in <a href=\"http://en.cppreference.com/w/cpp/types/is_constructible\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/types/is_constructible</a>\nsome of the output is incorrect.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nclass Foo {\n    int v1;\n    double v2;\n public:\n    Foo(int n) : v1(n), v2() {}\n    Foo(int n, double f) : v1(n), v2(f) {}\n};\nint main() {\n    std::cout &lt;&lt; \"Foo is ...\\n\" &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\tTrivially-constructible from const Foo&amp;? \"\n              &lt;&lt; std::is_trivially_constructible&lt;Foo, const Foo&amp;&gt;::value &lt;&lt; '\\n'\n              &lt;&lt; \"\\tTrivially-constructible from int? \"\n              &lt;&lt; std::is_trivially_constructible&lt;Foo, int&gt;::value &lt;&lt; '\\n'\n              &lt;&lt; \"\\tConstructible from int? \"\n              &lt;&lt; std::is_constructible&lt;Foo, int&gt;::value &lt;&lt; '\\n'\n}\n</code></pre>\n<p>the output is:</p>\n<pre><code>Foo is ...\n        Trivially-constructible from const Foo&amp;? true\n        Trivially-constructible from int? true//Trivially-constructible from int? false\n        Constructible from int? true\nPress any key to continue . . .\n</code></pre>\n", "Tags": "<c++><typetraits>", "OwnerUserId": "1971684", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16232547_16233624_3": {"section_id": 461, "quality": 1.0, "length": 4}, "so_16232547_16233624_2": {"section_id": 461, "quality": 1.0, "length": 13}, "so_16232547_16233624_1": {"section_id": 461, "quality": 1.0, "length": 5}, "so_16232547_16233624_0": {"section_id": 4706, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_16232547_16233624_3": {"section_id": 452, "quality": 1.0, "length": 4}, "so_16232547_16233624_2": {"section_id": 452, "quality": 1.0, "length": 13}, "so_16232547_16233624_1": {"section_id": 452, "quality": 1.0, "length": 5}, "so_16232547_16233624_0": {"section_id": 4515, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_16232547_16233624_2": {"section_id": 484, "quality": 1.0, "length": 13}, "so_16232547_16233624_1": {"section_id": 484, "quality": 1.0, "length": 5}, "so_16232547_16233624_0": {"section_id": 6103, "quality": 0.9090909090909091, "length": 10}}}, "16233624": {"ParentId": "16232547", "PostTypeId": "2", "CommentCount": "9", "Body": "<p><strong>FINAL UPDATE</strong></p>\n<p>After a very insightful comment by @SebastianRedl I realized that the intention of the standard is to refer to the entire construction of the object, not just the operations inside the constructor. This would mean that there is, indeed, a bug in Visual C++. However, it is still my view that the wording of the standard is not sufficiently clear, so I'll leave the rest of my answer unchanged for posterity.</p>\n<p>To clarify: The behaviour mentioned by the OP is actually a bug, and in light of this, most of what I say below this update is wrong.</p>\n<p><strong>End Update</strong></p>\n<p>This is actually not a compiler bug, but rather a strange quirk of the standard, so your confusion is understandable. </p>\n<p>According to the C++11 standard, the following is the condition for <code>is_trivially_constructible::value</code> to be <code>true</code>.</p>\n<p>\u00a720.9</p>\n<blockquote>\n<p id=\"so_16232547_16233624_0\"><code>is_constructible&lt;T,Args...&gt;::value</code> is true and the variable definition for <code>is_constructible</code>, as defined below, is known to call no operation that is not trivial</p>\n</blockquote>\n<p>So, <code>is_trivially_constructible</code> is true as long as the given type is constructible with the given arguments and it does not call any non-trivial operations. Your example includes only one such constructor, a copy constructor. In fact, by the definition of \"non-trivial operation\" (essentially a non-trivial operator or constructor), this does hold for your type. So returning <code>true</code> is correct.</p>\n<p>However, there is one very strange point! The C+11 standard says the following about copy constructors:</p>\n<p>\u00a712.8.12  (emphasis mine)</p>\n<blockquote>\n<p id=\"so_16232547_16233624_1\">A <strong>copy/move constructor</strong> for class X is trivial if it is <strong>not user-provided</strong> and if</p>\n<ul>\n<li>class X has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>the constructor selected to copy/move each direct base class subobject is trivial, and</li>\n<li><p id=\"so_16232547_16233624_2\">for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;</p>\n<p id=\"so_16232547_16233624_3\">otherwise the copy/move constructor is non-trivial.</p></li>\n</ul>\n</blockquote>\n<p>Since you do provide a user-defined copy constructor your class is not trivially copy constructible. The copy constructor you've given is not trivial. Still, the non-trivial copy constructor <em>does</em> fulfil the necessary criteria for <code>is_trivially_constructible</code> to return <code>true</code> given an argument which matches your copy constructor.</p>\n<p>In my mind, this seems to be more of a \"bug\" in the standard. <code>is_trivially_constructible</code> returns whether the type is trivially constructible given certain arguments. This does not seem to guarantee that the constructor itself is deemed trivial!</p>\n<p><strong>Update:</strong></p>\n<p>After trying to devise a test to show this following case, I did find a bug in VC11. The logic described by the standard means that, if <code>B</code> is used as a sub-object (member or base) of another type, any constructor of that type which invokes the copy constructor of <code>B</code> should be deemed <strong>non-trivial</strong> by <code>std::is_trivially_constructible</code>. This is not the case in VC11.</p>\n<p><strong>Example Code</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct B \n{\n  B() {}\n  B(B&amp;) {\n    std::cout &lt;&lt; \"not trivial\\n\";\n  }\n};\n\nstruct A : B\n{\n  A(B&amp; B) : b(B){}\n    B b;\n};\n\nint main() \n{\n  std::cout &lt;&lt; std::is_trivially_constructible&lt;B,  B&amp;&gt;::value &lt;&lt; '\\n'; // Should print 1\n  std::cout &lt;&lt; std::is_trivially_constructible&lt;A,  B&amp;&gt;::value &lt;&lt; '\\n'; // Should print 0\n  getchar();\n  return 0;\n</code></pre>\n<p>}</p>\n", "OwnerUserId": "980195", "LastEditorUserId": "980195", "LastEditDate": "2013-04-26T13:05:32.447", "Id": "16233624", "Score": "4", "CreationDate": "2013-04-26T09:55:36.073", "LastActivityDate": "2013-04-26T13:05:32.447"}});