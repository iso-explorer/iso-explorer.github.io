post_cb({"37927752": {"Id": "37927752", "PostTypeId": "2", "Body": "<p>In the <a href=\"https://isocpp.org/wiki/faq/mixing-c-and-cpp#c-calls-cpp\" rel=\"nofollow\">same document</a>, it shows a code example that has <code>extern \"C\"</code> in the declaration, but not in the definition.</p>\n<p>If your definition \"sees\" the declaration (that is, the declaration precedes the definition in the translation unit), you <em>don't</em> need <code>extern \"C\"</code> on the definition. But it won't hurt - it will be silently ignored by the compiler.</p>\n<p>Here is the code example given in the FAQ:</p>\n<pre><code>// This is C++ code\n// Declare f(int,char,float) using extern \"C\":\nextern \"C\" void f(int i, char c, float x);\n// ...\n// Define f(int,char,float) in some C++ module:\nvoid f(int i, char c, float x)\n{\n  // ...\n}\n</code></pre>\n<p>If you, for any reason, decide not to include the declaration before your definition, you <em>have to</em> provide the <code>extern \"C\"</code> modifier:</p>\n<pre><code>// This is C++ code\n// Define f(int,char,float) in some C++ module:\nextern \"C\" void f(int i, char c, float x)\n{\n  // ...\n}\n</code></pre>\n<p>However, this goes against most style guidelines of C and C++.</p>\n", "LastEditorUserId": "509868", "LastActivityDate": "2016-06-20T16:50:24.430", "Score": "-2", "CreationDate": "2016-06-20T16:45:14.483", "ParentId": "37927388", "CommentCount": "0", "OwnerUserId": "509868", "LastEditDate": "2016-06-20T16:50:24.430"}, "37927500": {"Id": "37927500", "PostTypeId": "2", "Body": "<p>It should enclose the declarations in the header file, and definitions should be enclosed as long the translation unit is compiled using the c++ compiler, and as long the declaration wasn't seen there.<br>\nIt's never wrong doing both in c++ code.</br></p>\n<p>If the c compiler is used to compile the function definitions, it's not necessary (or should I better to say would be wrong syntax, see the note below).</p>\n<p><code>extern \"C\" {}</code> scopes control that plain c symbols linkage is used for everything inside. Otherwise <a href=\"https://en.wikipedia.org/wiki/Name_mangling\" rel=\"nofollow noreferrer\"><strong>c++ name mangling</strong></a> would be applied.</p>\n<hr>\n<p>Note: </p>\n<p>Since <code>extern \"C\" {}</code> this isn't valid c syntax, to make that working with the c compiler, you'll need to use it within <code>#ifdef</code>:</p>\n<p><strong><code>MyHeader.h</code>:</strong></p>\n<pre><code> #ifdef __cplusplus\n extern \"C\" {\n #endif\n\n // ... c style function name declarations\n void foo(int i);\n\n #ifdef __cplusplus\n } // extern \"C\"\n #endif\n</code></pre>\n<hr>\n<h2>The use of the <code>extern \"C\" {}</code> scope is actually twofold:</h2>\n<hr>\n<h3>Exporting C++ code to C</h3>\n<p>If the above is compiled with the c compiler, it appears for it as a normal c function declaration. If compiled with the c++ compiler the <code>extern</code> keyword applies and the c++ name mangling will be suppressed.</p>\n<p>Regarding the definition, the function can use any c++ features inside it's definition:</p>\n<pre><code> extern \"C\" {\n     void foo(int x) {\n         std::vector v(x);\n         // ... blah, more c++ stuff\n     }\n }\n</code></pre>\n<p>Note that the declaration wasn't included here. This can be used as a technique, particularly useful when you want to override functions exposed from a library for <a href=\"https://stackoverflow.com/questions/15525537/what-are-practical-applications-of-weak-linking\"><em>weak linkage</em></a>.</p>\n<p>In case of including the <code>MyHeader.h</code>, the <code>extern \"C\" {}</code> scope can be omitted.</p>\n<hr>\n<h3>Importing C code from C++</h3>\n<p>If the above declaration is seen in the c++ compiler, again c++ name mangling is suppressed, and any call reference to <code>foo()</code> wil be resolved by the linker using a plain c function symbol name:</p>\n<pre><code>  #include \"MyHeader.h\"\n  class MyClass {\n  public:\n       void bar(int y) {\n           // Use foo() as plain c function:\n           foo(y);\n       }\n  };\n</code></pre>\n<p>The <code>foo()</code> function implementation is provided from an object file (or archive) that was created using the c compiler.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-20T18:57:03.947", "Score": "15", "CreationDate": "2016-06-20T16:29:50.177", "ParentId": "37927388", "CommentCount": "10", "OwnerUserId": "1413395", "LastEditDate": "2017-05-23T11:48:29.943"}, "37927576": {"Id": "37927576", "PostTypeId": "2", "Body": "<p>You should enclose both declarations and definitions. \"C\" and \"C++\" functions are exported with different names. To produce correct \"C\" external name in object file <code>extern \"C\"</code> is needed in cpp, otherwise function will be exported with <a href=\"https://en.wikipedia.org/wiki/Name_mangling\" rel=\"nofollow\">C++ name mangling</a> . You also need to enclose those <code>extern \"C\" {</code> and corresponding <code>}</code> into <code>#ifdef __cplusplus</code> and <code>#endif</code> in header file, which is going to be #included by a C project to avoid C compilation error</p>\n", "LastActivityDate": "2016-06-20T16:34:34.180", "CommentCount": "2", "CreationDate": "2016-06-20T16:34:34.180", "ParentId": "37927388", "Score": "1", "OwnerUserId": "1468415"}, "37927669": {"Id": "37927669", "PostTypeId": "2", "Body": "<p>[dcl.link]/5:</p>\n<blockquote>\n<p id=\"so_37927388_37927669_0\">Except for functions with C++ linkage, a function declaration without\n  a linkage specification shall not precede the first linkage\n  specification for that function. A function can be declared without a\n  linkage specification after an explicit linkage specification has been\n  seen; the linkage explicitly specified in the earlier declaration is\n  not affected by such a function declaration.</p>\n</blockquote>\n<p>Both versions are fine as far as the language linkage of the function is concerned. The important part is that the first declaration of the function must have <code>extern \"C\"</code> on it.</p>\n", "LastActivityDate": "2016-06-20T16:40:30.763", "CommentCount": "1", "CreationDate": "2016-06-20T16:40:30.763", "ParentId": "37927388", "Score": "7", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_37927388_37927669_0": {"length": 32, "quality": 1.0, "section_id": 5521}}, "n3337": {"so_37927388_37927669_0": {"length": 32, "quality": 1.0, "section_id": 5307}}, "n4659": {"so_37927388_37927669_0": {"length": 32, "quality": 1.0, "section_id": 6956}}}, "37927985": {"Id": "37927985", "PostTypeId": "2", "Body": "<p>Better should include both.</p>\n<p>To make sure that symbol is not mangled when we link a C code in C++. we use extern \"C\" block.</p>\n<p>Whenever some code is put in extern \u201cC\u201d block, C++ compiler ensures that the function names are unmangled i.e compiler generate a binary file with their names unchanged, as C compiler will do.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Name_mangling\" rel=\"nofollow\">Mangling</a> As C++ supports function overloading, so basically there can be more than one function with same name. So to distinguish between different functions when it generates object code \u2013 it changes names by adding information about arguments. Technique of adding additional information to function names is called Name Mangling.</p>\n<p>As C does not support function overloading. So we use extern 'C' block while linking C code in C++.</p>\n", "LastEditorUserId": "2165524", "LastActivityDate": "2016-06-20T17:10:50.540", "Score": "3", "CreationDate": "2016-06-20T16:58:12.757", "ParentId": "37927388", "CommentCount": "0", "OwnerUserId": "2165524", "LastEditDate": "2016-06-20T17:10:50.540"}, "37927388": {"ViewCount": "921", "Body": "<p>I  saw in a cpp file that <code>external \"C\" {...}</code> encloses the definitions of several functions.</p>\n<p>From <a href=\"https://isocpp.org/wiki/faq/mixing-c-and-cpp\">https://isocpp.org/wiki/faq/mixing-c-and-cpp</a>, I guess the purpose of using <code>extern \"C\"</code> in the cpp file is to make the enclosed C++ functions available to be used in a C  program. </p>\n<p>The example in the link shows that <code>extern \"C\"</code> encloses the declarations of the C++ functions only, not their definitions</p>\n<blockquote>\n<p id=\"so_37927388_37927388_0\">Just declare the C++ function extern \"C\" (in your C++ code) and call\n  it (from your C or C++ code). For example:</p>\n<pre><code>    // C++ code:\n    extern \"C\" void f(int);\n    void f(int i)\n    {\n        // ...\n    }\n</code></pre>\n</blockquote>\n<p>The cpp file I mentioned at the beginning looks like instead:</p>\n<pre><code>    // C++ code:\n    extern \"C\" {\n\n    void f(int i)\n    {\n        // ...\n    }\n\n    void g(int i)\n    {\n        // ...\n    }\n\n    }\n</code></pre>\n<p>Shall <code>extern \"C\"</code> enclose the declarations or definitions of C++ functions? \nIf so, why?</p>\n", "Title": "Shall external \"C\" enclose the declaration or definition of a C++ function?", "CreationDate": "2016-06-20T16:23:01.943", "LastActivityDate": "2016-06-20T18:57:03.947", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-06-20T17:15:51.027", "LastEditorUserId": "1413395", "Id": "37927388", "Score": "13", "OwnerUserId": "156458", "Tags": "<c++><c>", "AnswerCount": "5"}});