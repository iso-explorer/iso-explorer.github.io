post_cb({"2491726": {"ParentId": "2491495", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2010-03-22T11:19:22.443", "OwnerUserId": "9990", "CommunityOwnedDate": "2010-03-22T11:19:22.443", "Id": "2491726", "Score": "-2", "Body": "<p>I don't know specifically whether Alexandrescu's advice is sound, but, for all that I respect him as a super-smart dude, his treatment of volatile's semantics suggests that he's stepped way outside his area of expertise. Volatile has absolutely no value in multithreading (see <a href=\"http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming/\" rel=\"nofollow noreferrer\">here</a> for a good treatment of the subject) and so Alexandrescu's claim that volatile <em>is</em> useful for multithreaded access leads me to seriously wonder how much faith I can place in the rest of his article.</p>\n", "LastActivityDate": "2010-03-22T11:19:22.443"}, "2492574": {"CommentCount": "11", "CreationDate": "2010-03-22T13:35:38.180", "CommunityOwnedDate": "2010-03-22T13:35:38.180", "LastEditorUserId": "13005", "LastActivityDate": "2010-03-22T13:58:48.370", "ParentId": "2491495", "PostTypeId": "2", "LastEditDate": "2010-03-22T13:58:48.370", "Id": "2492574", "Score": "4", "Body": "<p>This catches some kinds of thread-unsafe code (concurrent access), but misses others (deadlocks due to locking inversion). Neither is especially easy to test for, so it's a modest partial win. In practice, remembering to enforce a constraint that a particular private member is accessed only under some specified lock, hasn't been a big problem for me.</p>\n<p>Two answers to this question have demonstrated that you're correct to say that confusion is a significant disadvantage - maintainers may have been so strongly conditioned to understand that volatile's memory-access semantics have nothing to do with thread-safety, that they will not even read the rest of the code/article before declaring it incorrect.</p>\n<p>I think the other big disadvantage, outlined by Alexandrescu in the article, is that it doesn't work with non-class types. This might be a difficult restriction to remember. If you think that marking your data members <code>volatile</code> stops you using them without locking, and then expect the compiler to tell you when to lock, then you might accidentally apply that to an <code>int</code>, or to a member of template-parameter-dependent type. The resulting incorrect code will compile fine, <em>but you may have stopped examining your code for errors of this kind</em>. Imagine the errors which would occur, especially in template code, if it was possible to assign to a <code>const int</code>, but programmers nevertheless expected the compiler would check const-correctness for them...</p>\n<p>I think the risk that the data member's type actually has any <code>volatile</code> member functions should be noted and then discounted, although it might bite somebody someday.</p>\n<p>I wonder if there's anything to be said for compilers providing additional const-style type modifiers via attributes. <a href=\"http://www2.research.att.com/~bs/C++0xFAQ.html#attributes\" rel=\"nofollow noreferrer\">Stroustrup says</a>, \"The recommendation is to use attributes to only control things that do not affect the meaning of a program but might help detect errors\". If you could replace all mentions of <code>volatile</code> in the code with <code>[[__typemodifier(needslocking)]]</code> then I think it would be better. It would then be impossible to use the object without a <code>const_cast</code>, and hopefully you wouldn't write a <code>const_cast</code> without thinking about what it is you're discarding.</p>\n", "OwnerUserId": "13005"}, "bq_ids": {"n4140": {"so_2491495_4875393_0": {"section_id": 5435, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_2491495_4875393_0": {"section_id": 5230, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_2491495_4875393_0": {"section_id": 6862, "quality": 0.6428571428571429, "length": 9}}}, "4877977": {"ParentId": "2491495", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-02-02T17:55:31.027", "OwnerUserId": "1968", "CommunityOwnedDate": "2011-02-02T17:55:31.027", "Id": "4877977", "Score": "0", "Body": "<blockquote>\n<p id=\"so_2491495_4877977_0\">In the article the keyword is used more like a <code>required_thread_safety</code> tag than the actual intended use of volatile.</p>\n</blockquote>\n<p>Without having read the article \u2013\u00a0why isn\u2019t Andrei using said <code>required_thread_safety</code> tag then? Abusing <code>volatile</code> doesn\u2019t sound such a good idea here. I believe this causes <em>more</em> confusion (like you said), rather than avoiding it.</p>\n<p>That said, <code>volatile</code> may sometimes be required in multi-threaded code even if it\u2019s not a <em>sufficient</em> condition, just to prevent the compiler from optimizing away checks that rely on asynchronous update of a value.</p>\n", "LastActivityDate": "2011-02-02T17:55:31.027"}, "2491848": {"CommentCount": "2", "CreationDate": "2010-03-22T11:40:13.843", "CommunityOwnedDate": "2010-03-22T11:40:13.843", "LastEditorUserId": "79298", "LastActivityDate": "2010-03-22T11:52:57.753", "ParentId": "2491495", "PostTypeId": "2", "LastEditDate": "2010-03-22T11:52:57.753", "Id": "2491848", "Score": "6", "Body": "<p>I think the issue is not about thread-safety provided by <code>volatile</code>. It dosen't and <em>Andrei's</em> article dosen't say it does. Here, a <code>mutex</code> is used to achieve that. The issue is, whether the use of <code>volatile</code>keyword to provide <strong><em>static type-checking</em></strong> along with use of mutex for thread-safe code, is abuse of the <code>volatile</code> keyword? IMHO it's pretty smart, but i have come across developers who are not fans of <em>strict-type-checking</em> just for the sake of it.</p>\n<p>IMO when you are writing code for multi-threaded environment, there is already enough caution to emphasize wherein you would expect people not to be ignorant of race-conditions and deadlocks.</p>\n<p>A downside of this wrapped approach is that every operation on the type that is wrapped using <code>LockingPtr</code> must be through a member function. That will increase one level of indirection which might considerably affect developers comfort in a team.</p>\n<p>But if you are a purist who believes in the spirit of C++ a.k.a <strong><em>strict-type-checking</em></strong>; this is a good alternative.</p>\n", "OwnerUserId": "79298"}, "2491723": {"ParentId": "2491495", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2010-03-22T11:18:58.637", "OwnerUserId": "31152", "CommunityOwnedDate": "2010-03-22T11:18:58.637", "Id": "2491723", "Score": "0", "Body": "<p>You must better not do that. <strong>volatile</strong> was not even invented to provide thread-safety. It was invented to access memory-mapped hardware registers properly. <strong>volatile</strong> keyword has no effect over CPU's out-of-order execution feature. You should use proper OS calls or CPU defined CAS instructions, memory fences, etc.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Compare-and-swap\" rel=\"nofollow noreferrer\">CAS</a></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Memory_fence\" rel=\"nofollow noreferrer\">Memory Fence</a></p>\n", "LastActivityDate": "2010-03-22T11:18:58.637"}, "2492940": {"ParentId": "2491495", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-03-22T14:27:03.007", "OwnerUserId": "241536", "CommunityOwnedDate": "2010-03-22T14:27:03.007", "Id": "2492940", "Score": "1", "Body": "<p>Look at this from a different perspective.  When you declare a variable as const, you are telling the compiler that the value cannot be changed by your code.  But that doesn't mean that the value <em>won't</em> change.  For example, if you do this:</p>\n<pre><code>const int cv = 123;\nint* that = const_cast&lt;int*&gt;(&amp;cv);\n*that = 42;\n</code></pre>\n<p>...this evokes undefined behavior according to the standard, but in practice something will happen.  Maybe the value will be changed.  Maybe there will be a sigfault.  Maybe flight simulator will launch -- who knows.  The point is you don't know on a platform-independant basis what's going to happen.  So the <em>apparent</em> promise of <code>const</code> is not fulfilled.  The value may or may not actually be const.</p>\n<p>Now, given that this is true, is using <code>const</code> an abuse of the language?  Of course not.  It is still a tool that the language provides to help you write better code.  It will never be the end-all, be-all tool to ensure that values remain unchanged -- the programmer's brain is ultimately that tool -- but does that make <code>const</code> unuseful?</p>\n<p>I say no, using const as a tool to help you write better code is not an abuse of the language.  In fact I'd go one step further, and say it is the <strong>intent</strong> of that feature.</p>\n<p>Now, the same is true of volatile.  Declaring something as volatile will not make your program thread safe.  It probably won't even make that variable or object thread safe.  But the compiler will enforce CV-qualification semantics, and careful programmer can leverage this fact to help him write better code by helping the compiler to identify places where he might be writing a bug.  Just like the compiler helps him when he tries to do this:</p>\n<pre><code>const int cv = 123;\ncv = 42;  // ERROR - compiler complains that the programmer is potentially making a mistake\n</code></pre>\n<p>Forget about memory fences and atomicity of volatile objects and variables, just like you have long forgotten about <code>cv</code>'s true constness.  But use the tools that the language gives you to write better code.  One of those tools is <code>volatile</code>.</p>\n", "LastActivityDate": "2010-03-22T14:27:03.007"}, "4877183": {"CommentCount": "1", "CreationDate": "2011-02-02T16:44:20.093", "CommunityOwnedDate": "2011-02-02T16:44:20.093", "LastEditorUserId": "-1", "LastActivityDate": "2011-02-02T16:44:20.093", "ParentId": "2491495", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:00:20.863", "Id": "4877183", "Score": "2", "Body": "<p><a href=\"https://stackoverflow.com/questions/2491495/may-volatile-be-in-user-defined-types-to-help-writing-thread-safe-code/4875393#4875393\">Building on other code</a> and removing the need for the volatile specifier entirely, this not only works, but correctly propagates const (similar to iterator vs const_iterator).  Unfortunately, it requires quite a bit of boilerplate code for the two interface types, but you don't have to repeat any logic of methods: each is still defined once, even if you do have to \"duplicate\" the \"volatile\" versions similarly to normal overloading of methods on const and non-const.</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\nstruct ExampleMutex {  // Purely for the sake of this example.\n  ExampleMutex() : _locked (false) {}\n  bool try_lock() {\n    if (_locked) return false;\n    _locked = true;\n    return true;\n  }\n  void lock() {\n    bool acquired = try_lock();\n    assert(acquired);\n  }\n  void unlock() {\n    assert(_locked);\n    _locked = false;\n  }\nprivate:\n  bool _locked;\n};\n\n// Customization point so these don't have to be implemented as nested types:\ntemplate&lt;class T&gt;\nstruct VolatileTraits {\n  typedef typename T::VolatileInterface       Interface;\n  typedef typename T::VolatileConstInterface  ConstInterface;\n};\n\ntemplate&lt;class T&gt;\nclass Lock;\ntemplate&lt;class T&gt;\nclass ConstLock;\n\ntemplate&lt;class T, class Mutex=ExampleMutex&gt;\nstruct Volatile {\n  typedef typename VolatileTraits&lt;T&gt;::Interface       Interface;\n  typedef typename VolatileTraits&lt;T&gt;::ConstInterface  ConstInterface;\n\n  Volatile() : _data () {}\n  Volatile(T const &amp;data) : _data (data) {}\n\n  Interface       operator*()        { return _data; }\n  ConstInterface  operator*() const  { return _data; }\n  Interface       operator-&gt;()        { return _data; }\n  ConstInterface  operator-&gt;() const  { return _data; }\n\nprivate:\n  T _data;\n  mutable Mutex _mutex;\n\n  friend class Lock&lt;T&gt;;\n  friend class ConstLock&lt;T&gt;;\n};\n\ntemplate&lt;class T&gt;\nstruct Lock {\n  Lock(Volatile&lt;T&gt; &amp;data) : _data (data) { _data._mutex.lock(); }\n  ~Lock() { _data._mutex.unlock(); }\n\n  T&amp; operator*() { return _data._data; }\n  T* operator-&gt;() { return &amp;**this; }\n\nprivate:\n  Volatile&lt;T&gt; &amp;_data;\n};\n\ntemplate&lt;class T&gt;\nstruct ConstLock {\n  ConstLock(Volatile&lt;T&gt; const &amp;data) : _data (data) { _data._mutex.lock(); }\n  ~ConstLock() { _data._mutex.unlock(); }\n\n  T const&amp; operator*() { return _data._data; }\n  T const* operator-&gt;() { return &amp;**this; }\n\nprivate:\n  Volatile&lt;T&gt; const &amp;_data;\n};\n\nstruct Something {\n  class VolatileConstInterface;\n  struct VolatileInterface {\n    // A bit of boilerplate:\n    VolatileInterface(Something &amp;x) : base (&amp;x) {}\n    VolatileInterface const* operator-&gt;() const { return this; }\n\n    void action() const {\n      base-&gt;_do(\"in a thread-safe way\");\n    }\n\n  private:\n    Something *base;\n\n    friend class VolatileConstInterface;\n  };\n\n  struct VolatileConstInterface {\n    // A bit of boilerplate:\n    VolatileConstInterface(Something const &amp;x) : base (&amp;x) {}\n    VolatileConstInterface(VolatileInterface x) : base (x.base) {}\n    VolatileConstInterface const* operator-&gt;() const { return this; }\n\n    void action() const {\n      base-&gt;_do(\"in a thread-safe way to a const object\");\n    }\n\n  private:\n    Something const *base;\n  };\n\n  void action() {\n    _do(\"knowing only one thread accesses this object\");\n  }\n\n  void action() const {\n    _do(\"knowing only one thread accesses this const object\");\n  }\n\nprivate:\n  void _do(char const *restriction) const {\n    std::cout &lt;&lt; \"do action \" &lt;&lt; restriction &lt;&lt; '\\n';\n  }\n};\n\nint main() {\n  Volatile&lt;Something&gt; x;\n  Volatile&lt;Something&gt; const c;\n\n  x-&gt;action();\n  c-&gt;action();\n\n  {\n    Lock&lt;Something&gt; locked (x);\n    locked-&gt;action();\n  }\n\n  {\n    ConstLock&lt;Something&gt; locked (x);  // ConstLock from non-const object\n    locked-&gt;action();\n  }\n\n  {\n    ConstLock&lt;Something&gt; locked (c);\n    locked-&gt;action();\n  }\n\n  return 0;\n}\n</code></pre>\n<p>Compare class Something to what Alexandrescu's use of volatile would require:</p>\n<pre><code>struct Something {\n  void action() volatile {\n    _do(\"in a thread-safe way\");\n  }\n\n  void action() const volatile {\n    _do(\"in a thread-safe way to a const object\");\n  }\n\n  void action() {\n    _do(\"knowing only one thread accesses this object\");\n  }\n\n  void action() const {\n    _do(\"knowing only one thread accesses this const object\");\n  }\n\nprivate:\n  void _do(char const *restriction) const volatile {\n    std::cout &lt;&lt; \"do action \" &lt;&lt; restriction &lt;&lt; '\\n';\n  }\n};\n</code></pre>\n", "OwnerUserId": "600324"}, "2491495": {"CommentCount": "2", "ViewCount": "2327", "PostTypeId": "1", "CommunityOwnedDate": "2010-03-22T10:43:41.293", "LastEditorUserId": "36565", "CreationDate": "2010-03-22T10:43:26.507", "LastActivityDate": "2011-02-02T17:55:31.027", "LastEditDate": "2010-03-22T12:13:30.220", "FavoriteCount": "14", "Title": "May volatile be in user defined types to help writing thread-safe code", "Id": "2491495", "Score": "24", "Body": "<p>I know, it has been made quite clear in a couple of questions/answers before, that <code>volatile</code> is related to the visible state of the c++ memory model and not to multithreading.</p>\n<p>On the other hand, this <a href=\"http://www.drdobbs.com/cpp/184403766;jsessionid=OEWBPI10M2IQLQE1GHPCKHWATMY32JVN\" rel=\"noreferrer\">article</a> by Alexandrescu uses the <code>volatile</code> keyword not as a runtime feature but rather as a compile time check to force the compiler into failing to accept code that could be not thread safe. In the article the keyword is used more like a <code>required_thread_safety</code> tag than the actual intended use of <code>volatile</code>.</p>\n<p>Is this (ab)use of <code>volatile</code> appropriate? What possible gotchas may be hidden in the approach?</p>\n<p>The first thing that comes to mind is added confusion: <code>volatile</code> is not related to thread safety, but by lack of a better tool I could accept it.</p>\n<p>Basic simplification of the article:</p>\n<p>If you declare a variable <code>volatile</code>, only <code>volatile</code> member methods can be called on it, so the compiler will block calling code to other methods. Declaring an <code>std::vector</code> instance as <code>volatile</code> will block all uses of the class. Adding a wrapper in the shape of a locking pointer that performs a <code>const_cast</code> to release the <code>volatile</code> requirement, any access through the locking pointer will be allowed.</p>\n<p>Stealing from the article:</p>\n<pre><code>template &lt;typename T&gt;\nclass LockingPtr {\npublic:\n   // Constructors/destructors\n   LockingPtr(volatile T&amp; obj, Mutex&amp; mtx)\n      : pObj_(const_cast&lt;T*&gt;(&amp;obj)), pMtx_(&amp;mtx)\n   { mtx.Lock(); }\n   ~LockingPtr()   { pMtx_-&gt;Unlock(); }\n   // Pointer behavior\n   T&amp; operator*()  { return *pObj_; }\n   T* operator-&gt;() { return pObj_; }\nprivate:\n   T* pObj_;\n   Mutex* pMtx_;\n   LockingPtr(const LockingPtr&amp;);\n   LockingPtr&amp; operator=(const LockingPtr&amp;);\n};\n\nclass SyncBuf {\npublic:\n   void Thread1() {\n      LockingPtr&lt;BufT&gt; lpBuf(buffer_, mtx_);\n      BufT::iterator i = lpBuf-&gt;begin();\n      for (; i != lpBuf-&gt;end(); ++i) {\n         // ... use *i ...\n      }\n   }\n   void Thread2();\nprivate:\n   typedef vector&lt;char&gt; BufT;\n   volatile BufT buffer_;\n   Mutex mtx_; // controls access to buffer_\n};\n</code></pre>\n<p><strong>NOTE</strong></p>\n<p>After the first couple of answers have appeared I think I must clarify, as I might not have used the most appropriate words.</p>\n<p>The use of <code>volatile</code> is not because of what it provides at runtime but because of what it means at compile time. That is, the same trick could be pulled with the <code>const</code> keyword if it was as rarely used in user defined types is as <code>volatile</code> is. That is, there is a keyword  (that happens to be spelled volatile) that allows me to block member function calls, and Alexandrescu is using it to trick the compiler into failing to compile thread-unsafe code.</p>\n<p>I see it as many metaprogramming tricks that are there not because of what they do at compile time, but rather for what it forces the compiler to do for you.</p>\n", "Tags": "<c++><thread-safety><volatile>", "OwnerUserId": "36565", "AnswerCount": "8"}, "4875393": {"ParentId": "2491495", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-02-02T14:10:18.993", "OwnerUserId": "511601", "CommunityOwnedDate": "2011-02-02T14:10:18.993", "Id": "4875393", "Score": "2", "Body": "<p>C++03 \u00a77.1.5.1p7:</p>\n<blockquote>\n<p id=\"so_2491495_4875393_0\">If an attempt is made to refer to an object defined with a volatile-qualified type through the use of an lvalue with a non-volatile-qualified type, the program behaviour is undefined.</p>\n</blockquote>\n<p>Because buffer_ in your example is defined as volatile, casting it away is undefined behavior.  However, you can get around that with an adapter which defines the object as non-volatile, but adds volatility:</p>\n<pre><code>template&lt;class T&gt;\nstruct Lock;\n\ntemplate&lt;class T, class Mutex&gt;\nstruct Volatile {\n  Volatile() : _data () {}\n  Volatile(T const &amp;data) : _data (data) {}\n\n  T        volatile&amp; operator*()        { return _data; }\n  T const  volatile&amp; operator*() const  { return _data; }\n\n  T        volatile* operator-&gt;()        { return &amp;**this; }\n  T const  volatile* operator-&gt;() const  { return &amp;**this; }\n\nprivate:\n  T _data;\n  Mutex _mutex;\n\n  friend class Lock&lt;T&gt;;\n};\n</code></pre>\n<p>The friendship is needed to strictly control non-volatile access through an already locked object:</p>\n<pre><code>template&lt;class T&gt;\nstruct Lock {\n  Lock(Volatile&lt;T&gt; &amp;data) : _data (data) { _data._mutex.lock(); }\n  ~Lock() { _data._mutex.unlock(); }\n\n  T&amp; operator*() { return _data._data; }\n  T* operator-&gt;() { return &amp;**this; }\n\nprivate:\n  Volatile&lt;T&gt; &amp;_data;\n};\n</code></pre>\n<p>Example:</p>\n<pre><code>struct Something {\n  void action() volatile;  // Does action in a thread-safe way.\n  void action();  // May assume only one thread has access to the object.\n  int n;\n};\nVolatile&lt;Something&gt; data;\nvoid example() {\n  data-&gt;action();  // Calls volatile action.\n  Lock&lt;Something&gt; locked (data);\n  locked-&gt;action();  // Calls non-volatile action.\n}\n</code></pre>\n<p>There are two caveats.  First, you can still access public data members (Something::n), but they will be qualified volatile; this will probably fail at various points.  And second, Something doesn't know if it really has been defined as volatile and casting away that volatile (from \"this\" or from members) in methods will still be UB if it has been defined that way:</p>\n<pre><code>Something volatile v;\nv.action();  // Compiles, but is UB if action casts away volatile internally.\n</code></pre>\n<p>The main goal is achieved: objects don't have to be aware that they are used this way, and the compiler will prevent calls to non-volatile methods (which is all methods for most types) unless you explicitly go through a lock.</p>\n", "LastActivityDate": "2011-02-02T14:10:18.993"}});