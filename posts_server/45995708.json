post_cb({"45995960": {"ParentId": "45995708", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If during construction using <code>new</code>, a constructor throws an exception, the C++ runtime library:</p>\n<ol>\n<li>calls <code>std::terminate()</code> if no suitable catch handler is found. Whether or not <code>delete</code> is called is implementation defined.</li>\n</ol>\n<p>or</p>\n<ol start=\"2\">\n<li>calls <code>delete</code> for you before \"sending\" that exception to the suitable catch handler if one is found, although the destructor is not called - i.e. <code>~A()</code>, if you had one, would not be called when <code>i</code> is greater than 1.</li>\n</ol>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2017-09-01T08:38:36.643", "Id": "45995960", "Score": "1", "CreationDate": "2017-09-01T08:18:36.380", "LastActivityDate": "2017-09-01T08:38:36.643"}, "45996000": {"ParentId": "45995708", "CommentCount": "1", "Body": "<p>As others already noted, it is because you do not catch the exception. As the standard notes:</p>\n<blockquote>\n<p id=\"so_45995708_45996000_0\"><strong>C++11 \u00a715.3/9</strong>:<br>\n  \u201cIf no matching handler is found, the function <code>std::terminate()</code>  is called; whether or not the stack is unwound before this call to <code>std::terminate()</code> is implementation-defined.\u201d</br></p>\n</blockquote>\n<p>While I think this is not specifically related to the stack in your case, the same principle will hold here, too. So it is actually up to the implementation if any memory is cleaned up. As we see here, it is usually not the case, because the operating system cleans up the memory anyway.</p>\n", "OwnerUserId": "2487023", "PostTypeId": "2", "Id": "45996000", "Score": "2", "CreationDate": "2017-09-01T08:20:43.273", "LastActivityDate": "2017-09-01T08:20:43.273"}, "45995952": {"ParentId": "45995708", "CommentCount": "0", "Body": "<p>If you fix your code to throw exception, it works as expected:</p>\n<pre><code>int main(int argc,char* arg[])\n{\n    try {\n        new A(2);\n    }\n    catch (...)\n    {}\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/09ae44f3e0ff688d\" rel=\"nofollow noreferrer\">Demo</a></p>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "45995952", "Score": "1", "CreationDate": "2017-09-01T08:18:03.710", "LastActivityDate": "2017-09-01T08:18:03.710"}, "bq_ids": {"n4140": {"so_45995708_45995708_0": {"section_id": 6101, "quality": 1.0, "length": 28}, "so_45995708_45996000_0": {"section_id": 3354, "quality": 0.8, "length": 12}}, "n3337": {"so_45995708_45995708_0": {"section_id": 5867, "quality": 1.0, "length": 28}, "so_45995708_45996000_0": {"section_id": 3224, "quality": 0.8, "length": 12}}, "n4659": {"so_45995708_45995708_0": {"section_id": 7598, "quality": 1.0, "length": 28}, "so_45995708_45996000_0": {"section_id": 4121, "quality": 0.8, "length": 12}}}, "45995708": {"CommentCount": "8", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "5632316", "CreationDate": "2017-09-01T08:02:25.467", "LastActivityDate": "2017-09-01T08:38:36.643", "Title": "Why deallocation function is not called when object constructor throw in a new expression?", "AcceptedAnswerId": "45995952", "LastEditDate": "2017-09-01T08:18:30.513", "Id": "45995708", "Score": "5", "Body": "<p>If I define operator delete as following and if an object constructor throw in the new expression I expected to see the result of the call to the defined operator delete:</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nvoid*\noperator new(std::size_t s){\n  std::cout &lt;&lt; \"alloc \" &lt;&lt; std::endl;\nreturn std::malloc(s);\n}\n\nvoid\noperator delete(void* p) noexcept {\n  std::cout &lt;&lt; \"dealloc \" &lt;&lt; std::endl;\n  std::free(p);\n}\nvoid\noperator delete(void* p,std::size_t) noexcept{\n    std::free(p);\n    std::cout &lt;&lt; \"dealloc s\" &lt;&lt; std::endl;\n}\n\nstruct A{\n  A(int i){\n     if(i&gt;0)\n       throw 10;\n  }\n};\n\nint main(int argc// will equal 10\n        ,char* arg[])\n{\n  for(int i=0;i&lt;argc;++i)\n     auto p=new A{argc};\n  return 0;\n}\n</code></pre>\n<p>This program just output <code>alloc</code>, why the operator delete are not called? In the standard [expr.new] it is specified that:</p>\n<blockquote>\n<p id=\"so_45995708_45995708_0\">If any part of the object initialization described above terminates by throwing an exception and a suitable\n  deallocation function can be found, the deallocation function is called to free the memory in which the object\n  was being constructed, after which the exception continues to propagate in the context of the new-expression.</p>\n</blockquote>\n", "Tags": "<c++><new-operator><dynamic-memory-allocation><delete-operator>", "OwnerUserId": "5632316", "AnswerCount": "3"}});