post_cb({"11791712": {"Id": "11791712", "PostTypeId": "2", "Body": "<p>Copy-elision applies just the same to move construction, it's the exact same clause and both the elision of copy construction and move construction is collectively called \"copy-elision\".</p>\n<p><code>\u00a712.8 [class.copy] p31</code></p>\n<blockquote>\n<p id=\"so_11791644_11791712_0\">When certain criteria are met, an implementation is allowed to omit the copy/<strong>move construction</strong> of a class object, even if the copy/<strong>move constructor</strong> and/or destructor for the object have side effects. [...]</p>\n</blockquote>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-08-03T08:10:35.640", "Score": "9", "CreationDate": "2012-08-03T08:04:36.183", "ParentId": "11791644", "CommentCount": "0", "OwnerUserId": "500104", "LastEditDate": "2012-08-03T08:10:35.640"}, "bq_ids": {"n4140": {"so_11791644_11791712_0": {"length": 19, "quality": 0.95, "section_id": 480}}, "n3337": {"so_11791644_11791712_0": {"length": 20, "quality": 1.0, "section_id": 471}}, "n4659": {"so_11791644_11791712_0": {"length": 19, "quality": 0.95, "section_id": 502}}}, "11791644": {"ViewCount": "249", "Body": "<p>In C++ one cannot rely on the copy constructor being called from a return statement because of a special clause in the standard that allows a compiler to omit a call to the copy constructor resulting from a return statement, even if the copy constructor has side effects. Thus, it is bad style to write a copy constructor that does something else than just copy constructing the instance.</p>\n<p>Are there similar statements in the C++11 standard that allow the compiler to eliminate a call to the move constructor under certain circumstances - and if so, what are those circumstances?</p>\n", "AcceptedAnswerId": "11791712", "Title": "C++11 move constructor with side effects", "CreationDate": "2012-08-03T08:00:04.500", "Id": "11791644", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-08-03T08:12:33.703", "LastEditorUserId": "27615", "LastActivityDate": "2012-08-03T08:12:33.703", "Score": "6", "OwnerUserId": "712302", "Tags": "<c++><c++11><move-semantics><move-constructor>", "AnswerCount": "3"}, "11791726": {"Id": "11791726", "PostTypeId": "2", "Body": "<p>When copy elision is allowed, no copying will be performed, so there will be no call to the move copy constructor, even if the object is movable. So copy elision wins over move, and you cannot be certain (at least not in a portable way) when it will take place. So this is one scenario when side effects on move copy construction would be a bad idea.</p>\n", "LastActivityDate": "2012-08-03T08:05:15.710", "CommentCount": "0", "CreationDate": "2012-08-03T08:05:15.710", "ParentId": "11791644", "Score": "3", "OwnerUserId": "661519"}, "11791791": {"Id": "11791791", "PostTypeId": "2", "Body": "<p>Elision is defined identically for both copy and move. The Standard does not have any specific wording for move, because they're defined identically. </p>\n", "LastActivityDate": "2012-08-03T08:09:02.207", "CommentCount": "0", "CreationDate": "2012-08-03T08:09:02.207", "ParentId": "11791644", "Score": "1", "OwnerUserId": "298661"}});