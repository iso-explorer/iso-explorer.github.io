post_cb({"33218870": {"Id": "33218870", "PostTypeId": "2", "Body": "<p>I m posting 2 codes to explain your problem :-</p>\n<p>Code 1 :-</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nvoid foo() noexcept     // see the noexcept specifier\n{\n    throw 42;\n}\nint main()\n{\n    try\n    {\n        foo();\n    }\n    catch(...)\n    {\n        cerr&lt;&lt;\"exception caught\\n\";\n    }\n    return 0;\n}\n</code></pre>\n<p>Here the output will be :-</p>\n<pre><code>terminate called after throwing an instance of 'int'\n\nThis application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information.\n</code></pre>\n<p>If I remove the <code>noexcept</code>then :-</p>\n<p>Code 2 :-</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nvoid foo()    // noexcept is eliminated\n{\n    throw 42;\n}\nint main()\n{\n    try\n    {\n        foo();\n    }\n    catch(...)\n    {\n        cerr&lt;&lt;\"exception caught\\n\";\n    }\n    return 0;\n}\n</code></pre>\n<p>Output will be :-</p>\n<pre><code>exception caught\n</code></pre>\n<p>Because <code>foo</code> was signed as <code>noexcept</code>, hence <code>terminate</code> was called.</p>\n<p><code>Inheriting constructors</code> and the <code>implicitly-declared default constructors, copy constructors, move constructors, destructors, copy-assignment operators, move-assignment operators</code> are all <code>noexcept(true)</code> by default, unless they are required to call a function that is <code>noexcept(false)</code>, in which case these functions are <code>noexcept(false)</code>.</p>\n<p>You can also  write lines like :-</p>\n<pre><code>cout &lt;&lt; boolalpha &lt;&lt; noexcept(foo);   // here noexcept acts as \n                                     // an operator instead of a specifier\n</code></pre>\n<p>The above line will check if <code>foo</code> will throw an <code>exception</code> or not. If it would throw then the return value will be <code>true</code> else <code>false</code>.</p>\n<p>You can check more about these in this -&gt; <a href=\"http://scottmeyers.blogspot.dk/2014/03/declare-functions-noexcept-whenever.html\" rel=\"nofollow\">http://scottmeyers.blogspot.dk/2014/03/declare-functions-noexcept-whenever.html</a></p>\n", "LastActivityDate": "2015-10-19T15:55:50.267", "Score": "4", "CreationDate": "2015-10-19T15:55:50.267", "ParentId": "33210169", "CommentCount": "0", "OwnerUserId": "5433221"}, "bq_ids": {"n4140": {"so_33210169_33210300_2": {"length": 6, "quality": 0.75, "section_id": 6121}, "so_33210169_33210300_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6120}, "so_33210169_33210300_4": {"length": 42, "quality": 0.8571428571428571, "section_id": 6122}, "so_33210169_33210300_3": {"length": 9, "quality": 0.9, "section_id": 6122}}, "n3337": {"so_33210169_33210300_2": {"length": 7, "quality": 0.875, "section_id": 5885}, "so_33210169_33210300_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 5884}, "so_33210169_33210300_4": {"length": 39, "quality": 0.7959183673469388, "section_id": 5886}, "so_33210169_33210300_3": {"length": 9, "quality": 0.9, "section_id": 5886}}, "n4659": {"so_33210169_33210300_2": {"length": 6, "quality": 0.75, "section_id": 7618}, "so_33210169_33210300_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 7617}}}, "33210384": {"Id": "33210384", "PostTypeId": "2", "Body": "<p>A noexcept specification on a function is merely a method for a programmer to inform the compiler whether or not a function should throw exceptions. </p>\n<p>The compiler can use this information to enable certain optimizations on non-throwing functions as well as enable the noexcept operator, which can check at compile time if a particular expression is declared to throw any exceptions. </p>\n<p>For example, containers such as std::vector will move their elements if the elements' move constructor is noexcept, and copy otherwise (unless the copy constructor is not accessible, but a potentially throwing move constructor is, in which case the strong exception guarantee is waived).</p>\n<p>noexcept is an improved version of throw(), which is deprecated in C++11. Unlike throw(), noexcept will not call std::unexpected and may or may not unwind the stack, which potentially allows the compiler to implement noexcept without the runtime overhead of throw().</p>\n<p>For more details, please visit below websites</p>\n<ul>\n<li><a href=\"https://akrzemi1.wordpress.com/2014/04/24/noexcept-what-for/\" rel=\"nofollow noreferrer\">https://akrzemi1.wordpress.com/2014/04/24/noexcept-what-for/</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10787766/when-should-i-really-use-noexcept\">When should I really use noexcept?</a></li>\n</ul>\n<p>Edit: Sample source code to illustrate above points.</p>\n<pre><code>// whether foo is declared noexcept depends on if the expression\n// T() will throw any exceptions, check in compile time\ntemplate &lt;class T&gt;\nvoid foo() noexcept(noexcept(T())) {     \n}\n\nvoid bar() noexcept(true) {    \n}\n\nvoid baz() noexcept {\n    throw 42;     \n}  // noexcept is the same as noexcept(true)\n\nint main() \n{\n    foo&lt;int&gt;();  // noexcept(noexcept(int())) =&gt; noexcept(true), so this is fine\n\n    bar();  // fine\n    baz();  // compiles, but at runtime this calls std::terminate\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-19T09:05:27.983", "Score": "8", "CreationDate": "2015-10-19T08:58:02.303", "ParentId": "33210169", "CommentCount": "2", "LastEditDate": "2017-05-23T12:17:42.260", "OwnerUserId": "1516116"}, "33210300": {"Id": "33210300", "PostTypeId": "2", "Body": "<p><code>noexcept</code> indicates that a function is intended not to to throw an exception, a guarantee you as a developer provides, that is not enforced by the compiler. So using it in a situation where your function calls functions that might throw exceptions that you do not catch yourself is bad.</p>\n<p>The whole range of <code>throw()</code> specifiers were removed because the exception specifiers were less than optimal in C++, see: <a href=\"https://stackoverflow.com/questions/12833241/difference-between-c03-throw-specifier-c11-noexcept\">Difference between C++03 throw() specifier C++11 noexcept</a> </p>\n<p><code>noexcept</code> has the advantage of not stating which exception is thrown, but rather whether an exception is thrown or not. It accepts a parameter which may be <code>false</code> if you expect the function to throw an exception.</p>\n<p>The uses of this, can be in for instance an inherited class structure, where one super class wish to \"enforce\" to an inherited class, that a specific virtual function is not allowed to throw an exception. Further more the compiler may use the information for optimization.</p>\n<p><code>noexcept</code> is also an operator which can evaluate an expression and return whether or not that expression may thrown an exception or not, as per \u00a7 5.3.7.</p>\n<blockquote>\n<p id=\"so_33210169_33210300_0\">5.3.7 noexcept operator [expr.unary.noexcept]</p>\n<p id=\"so_33210169_33210300_1\">1 The noexcept operator determines whether the evaluation of its operand, which is an unevaluated operand\n  (Clause 5), can throw an exception (15.1).\n  noexcept-expression:\n  noexcept ( expression )</p>\n<p id=\"so_33210169_33210300_2\">2 The result of the noexcept operator is a constant of type bool and is an rvalue.</p>\n<p id=\"so_33210169_33210300_3\">3 The result of the noexcept operator is false if in a potentially-evaluated context the expression would\n  contain</p>\n<p id=\"so_33210169_33210300_4\">\u2014 a potentially-evaluated call to a function, member function, function pointer, or member function pointer that does not have a non-throwing exception-specification (15.4), unless the call is a constant\n  expression (5.19),<br>\n  \u2014 a potentially-evaluated throw-expression (15.1),<br>\n  \u2014 a potentially-evaluated dynamic_cast expression dynamic_cast(v), where T is a reference type, that requires a run-time check (5.2.7), or<br>\n  \u2014 a potentially-evaluated typeid expression (5.2.8) applied to a glvalue expression whose type is a polymorphic class type (10.3).<br>\n  Otherwise, the result is true.</br></br></br></br></p>\n</blockquote>\n<p>I can't explain the possible optimizations as well as Scott Meyers: <a href=\"http://aristeia.com/EC++11-14/noexcept%202014-03-31.pdf\" rel=\"nofollow noreferrer\">http://aristeia.com/EC++11-14/noexcept%202014-03-31.pdf</a> from his blog post: <a href=\"http://scottmeyers.blogspot.dk/2014/03/declare-functions-noexcept-whenever.html\" rel=\"nofollow noreferrer\">Declare functions noexcept whenever possible?</a></p>\n<blockquote>\n<p id=\"so_33210169_33210300_5\">The difference between unwinding the call stack and possibly unwinding it has a surprisingly large impact on code generation. In a noexcept function, optimizers need not keep the runtime stack in an unwindable state if an exception would propagate out of the function, nor must they ensure that objects in a noexcept function are destroyed in the inverse order of construction should an exception leave the function. <em>The result is more opportunities for optimization</em>, not only within the body of a noexcept function, but also at sites where the function is called. Such flexibility is present only for noexcept functions. Functions with \u201cthrow()\u201d exception specifications lack it, as do functions with no exception specification at all.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-19T17:21:36.783", "Score": "5", "CreationDate": "2015-10-19T08:53:17.117", "ParentId": "33210169", "CommentCount": "6", "LastEditDate": "2017-05-23T11:46:57.347", "OwnerUserId": "111143"}, "33210169": {"ViewCount": "3962", "Body": "<p>I am unable to understand the use &amp; purpose of <code>noexcept</code> in keyword in C++11/14. I mean it is a signature for those functions which do not emit <code>exceptions</code>. But does it really work?</p>\n<p>Look at this code below :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nvoid seev (vector&lt;int&gt; &amp;v) noexcept;\nvoid seev (vector&lt;int&gt; &amp;v) noexcept\n{\n    for (int i=0;i&lt;10;++i)\n    {\n        cout&lt;&lt;v.at(i)&lt;&lt;' ';\n    }\n}\nint main()\n{\n    vector&lt;int&gt; v {1,2,3,4,5};\n    seev(v);\n    return 0;\n}\n</code></pre>\n<p>The above code will surely throw an <code>out_of_range exception</code>. So the use of <code>noexcept</code> here is useless, or is it?</p>\n<p>My queries are :</p>\n<ol>\n<li><p>How does <code>noexcept</code> work?</p></li>\n<li><p>How is it used?</p></li>\n<li><p>What <code>throw()</code> wasn't able to do that <code>noexcept</code> could?</p></li>\n</ol>\n", "AcceptedAnswerId": "33210384", "Title": "How to use noexcept in C++ or How does it work?", "CreationDate": "2015-10-19T08:47:12.857", "Id": "33210169", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-10-20T08:48:25.363", "LastEditorUserId": "4851927", "LastActivityDate": "2015-10-20T08:48:25.363", "Score": "8", "OwnerUserId": "4851927", "Tags": "<c++11><noexcept>", "AnswerCount": "3"}});