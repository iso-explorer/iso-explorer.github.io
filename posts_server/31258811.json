post_cb({"31258938": {"ParentId": "31258811", "CommentCount": "0", "Body": "<p>Change your template version to</p>\n<pre><code>template &lt;typename ValueType&gt;\nvoid operator =(const std::initializer_list&lt;ValueType&gt; &amp;) {}\n</code></pre>\n", "OwnerUserId": "2425366", "PostTypeId": "2", "Id": "31258938", "Score": "1", "CreationDate": "2015-07-07T02:49:21.030", "LastActivityDate": "2015-07-07T02:49:21.030"}, "31258811": {"CommentCount": "2", "ViewCount": "448", "CreationDate": "2015-07-07T02:34:45.880", "LastActivityDate": "2015-07-07T02:57:47.837", "Title": "In C++ template copy assignment operator not compatible with initializer_list?", "AcceptedAnswerId": "31258865", "PostTypeId": "1", "Id": "31258811", "Score": "2", "Body": "<p>Consider I have such code:</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nclass my_class\n{\npublic:\n    my_class() {}\n\n    void operator = (const std::initializer_list&lt;int&gt;&amp;) {} // OK\n    template&lt;typename ValueType&gt; void operator = (const ValueType&amp;) {} // Failed\n};\n\nint main(int argc, char* argv[])\n{\n    my_class instance;\n    instance = {1, 2};\n\n    return 0;\n}\n</code></pre>\n<p>The first copy assignment operator could be compiled OK with <code>instance = {1, 2}</code>. However, the template version would failed with such error:</p>\n<pre><code>code.cpp:15:14: error: no viable overloaded '='\n    instance = {1, 2};\n    ~~~~~~~~ ^ ~~~~~~\ncode.cpp:3:7: note: candidate function (the implicit copy assignment operator) not viable: cannot convert initializer list argument to 'const my_class'\nclass my_class\n      ^\ncode.cpp:3:7: note: candidate function (the implicit move assignment operator) not viable: cannot convert initializer list argument to 'my_class'\nclass my_class\n      ^\ncode.cpp:9:39: note: candidate template ignored: couldn't infer template argument 'ValueType'\n    template&lt;typename ValueType&gt; void operator = (const ValueType&amp;) {}\n</code></pre>\n<p>Why the template version is not compatible with the initializer_list?</p>\n", "Tags": "<c++><templates><c++11><initializer-list>", "OwnerUserId": "2289969", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31258811_31258865_0": {"section_id": 336, "quality": 0.6190476190476191, "length": 13}, "so_31258811_31258865_2": {"section_id": 302, "quality": 0.8035714285714286, "length": 45}}, "n3337": {"so_31258811_31258865_0": {"section_id": 326, "quality": 0.6190476190476191, "length": 13}, "so_31258811_31258865_2": {"section_id": 293, "quality": 0.8035714285714286, "length": 45}}, "n4659": {"so_31258811_31258865_0": {"section_id": 345, "quality": 0.8095238095238095, "length": 17}, "so_31258811_31258865_2": {"section_id": 309, "quality": 0.9464285714285714, "length": 53}}}, "31258865": {"ParentId": "31258811", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Because initializer list is a non-deduced context. From [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_31258811_31258865_0\">The non-deduced contexts are:<br>\n  \u2014 [...]<br>\n  \u2014 A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter\n  does not have a type for which deduction from an initializer list is specified (14.8.2.1). <em>[ Example:</em></br></br></p>\n<pre><code>template&lt;class T&gt; void g(T);\ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_31258811_31258865_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>There are some cases, however, where you can still pass in an initializer list to a template. From [temp.deduct.call]</p>\n<blockquote>\n<p id=\"so_31258811_31258865_2\">Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with\n  the type of the corresponding argument of the call (call it <code>A</code>) as described below. If <code>P</code> is a dependent type,\n  removing references and <em>cv</em>-qualifiers from <code>P</code> gives <code>std::initializer_list&lt;P'&gt;</code> or <code>P'[N]</code> for some <code>P'</code> and\n  <code>N</code> and the argument is a non-empty initializer list (8.5.4), then deduction is performed instead for each element of the initializer list, taking <code>P'</code> as a function template parameter type and the initializer element as\n  its argument, and in the <code>P'[N]</code> case, if <code>N</code> is a non-type template parameter, <code>N</code> is deduced from the length of the initializer list.</p>\n</blockquote>\n<p>The examples that follow illustrate the cases in which this works:</p>\n<pre><code>template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);\nf({1,2,3}); // T deduced to int\n\ntemplate&lt;class T, int N&gt; void h(T const(&amp;)[N]);\nh({1,2,3}); // T deduced to int, N deduced to 3\n\ntemplate&lt;class T&gt; void j(T const(&amp;)[3]);\nj({42}); // T deduced to int, array bound not considered\n</code></pre>\n<p>So in your specific case, you could do something like:</p>\n<pre><code>template &lt;typename T&gt;\nvoid operator=(std::initializer_list&lt;T&gt; ) { }\n</code></pre>\n<p>Or:</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nvoid operator=(T const(&amp;)[N]) { }\n</code></pre>\n<p>Although the latter apparently doesn't compile on clang, incorrectly.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-07T02:57:47.837", "Id": "31258865", "Score": "5", "CreationDate": "2015-07-07T02:40:37.043", "LastActivityDate": "2015-07-07T02:57:47.837"}});