post_cb({"18461082": {"ParentId": "18460289", "CommentCount": "2", "Body": "<p>I'm answering your question from a comment:</p>\n<blockquote>\n<p id=\"so_18460289_18461082_0\">Could you please elaborate on why my conversion does not make sense? While trying to resolve operator[], why should the compiler not consider possible conversions?</p>\n</blockquote>\n<p>Short answer, because that's how it works. A conversion operator to a built-in type can be called here, not to user-defined type.</p>\n<p>A bit longer answer:</p>\n<p>When an operator is used in an expression, overload resolution follows the rules laid out in <code>13.3.1.2</code>.</p>\n<p>First:</p>\n<blockquote>\n<p id=\"so_18460289_18461082_1\">2 If either operand has a type that is a class or an enumeration, a user-de\ufb01ned operator function might be\n  declared that implements this operator or <strong>a user-de\ufb01ned conversion can be necessary to convert the operand\n  to a type that is appropriate for a built-in operator.</strong> In this case, overload resolution is used to determine\n  which operator function or built-in operator is to be invoked to implement the operator [...]. </p>\n</blockquote>\n<p><code>a[1]</code> is, for this purpose interpreted as <code>a.operator[](1)</code>, as shown in <code>Table 11</code> in the same section.</p>\n<p>The lookup is then performed as follows:</p>\n<blockquote>\n<p id=\"so_18460289_18461082_2\">3 For a unary operator @ with an operand of a type whose cv-unquali\ufb01ed version is T1, and for a binary\n  operator @ with a left operand of a type whose cv-unquali\ufb01ed version is T1 and a right operand of a type\n  whose cv-unquali\ufb01ed version is T2, three sets of candidate functions, designated member candidates, non-\n  member candidates and built-in candidates, are constructed as follows:  </p>\n<blockquote>\n<p id=\"so_18460289_18461082_7\">\u2014 If T1 is a complete class type, the set of member candidates is the result of the quali\ufb01ed lookup of\n    T1::operator@ (13.3.1.1.1); otherwise, the set of member candidates is empty. <strong>[1]</strong></p>\n<p id=\"so_18460289_18461082_8\">\u2014 The set of non-member candidates is the result of the unquali\ufb01ed lookup of operator@ in the context\n    of the expression according to the usual rules for name lookup in unquali\ufb01ed function calls (3.4.2)\n    except that all member functions are ignored. However, if no operand has a class type, only those\n    non-member functions in the lookup set that have a \ufb01rst parameter of type T1 or \u201creference to (possibly\n    cv-quali\ufb01ed) T1\u201d, when T1 is an enumeration type, or (if there is a right operand) a second parameter\n    of type T2 or \u201creference to (possibly cv-quali\ufb01ed) T2\u201d, when T2 is an enumeration type, are candidate\n    functions.  <strong>[2]</strong> </p>\n<p id=\"so_18460289_18461082_9\">\u2014 For the operator ,, the unary operator &amp;, or the operator -&gt;, the built-in candidates set is empty.\n    For all other operators, the built-in candidates include all of the candidate operator functions de\ufb01ned\n    in 13.6 that, compared to the given operator,  </p>\n<blockquote>\n<p id=\"so_18460289_18461082_11\">\u2014 have the same operator name, and<br>\n      \u2014 accept the same number of operands, and<br>\n      \u2014 accept operand types to which the given operand or operands can be converted according to\n      13.3.3.1, and <strong>[3]</strong><br>\n      \u2014 do not have the same parameter-type-list as any non-template non-member candidate.</br></br></br></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>The result is as follows:</p>\n<ul>\n<li><code>[1]</code> finds nothing (there's no <code>operator[]</code> in your class</li>\n<li><code>[2]</code> finds nothing (there's no free function <code>operator[]</code> and neither of operands are enumeration types)</li>\n<li><code>[3]</code> finds built-in <code>operator[](float*, std::ptrdiff_t)</code> because <code>A</code> declares a conversion to <code>float*</code></li>\n</ul>\n", "OwnerUserId": "947836", "PostTypeId": "2", "Id": "18461082", "Score": "3", "CreationDate": "2013-08-27T08:54:52.770", "LastActivityDate": "2013-08-27T08:54:52.770"}, "18460360": {"ParentId": "18460289", "CommentCount": "2", "Body": "<p>You can get them to work by overloading <code>operator[]</code> and <code>begin()</code> on <code>A</code>, or publicly inheriting from <code>array</code> (not recommended though).</p>\n<p>The implicit conversion only works when it makes sense (say if you passed an <code>A</code> to a function that expects a <code>std::array&lt;float, 7&gt;</code>), not in your case. And that's a good thing if you ask me.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "18460360", "Score": "3", "CreationDate": "2013-08-27T08:15:29.507", "LastActivityDate": "2013-08-27T08:15:29.507"}, "18460289": {"CommentCount": "4", "ViewCount": "532", "CreationDate": "2013-08-27T08:11:41.260", "LastActivityDate": "2013-08-27T08:54:52.770", "Title": "Is it possible to define an implicit conversion operator to std::array?", "AcceptedAnswerId": "18461082", "PostTypeId": "1", "Id": "18460289", "Score": "4", "Body": "<p>I am trying to have a C++ class that can be implicitly converted to <code>std::array</code>. Conversion works, but it is not implicit.</p>\n<pre><code>#include &lt;array&gt;\n\nclass A {\nprivate:\n    std::array&lt;float, 7&gt; data;\npublic:\n    operator std::array&lt;float, 7&gt;&amp;() { return data; }\n    operator const std::array&lt;float, 7&gt;&amp;() const { return data; }\n};\n\nint main() {\n    A a;\n    a[1] = 0.5f; // fails to compile\n    auto it = a.begin(); // fails to compile\n    A b;\n    static_cast&lt;std::array&lt;float, 7&gt;&gt;(b)[1] = 0.5f; //ok\n    auto it2 = static_cast&lt;std::array&lt;float, 7&gt;&gt;(b).begin(); //ok\n    return 0;\n}\n</code></pre>\n<p>I understand the above example is quite convoluted, as it basically completely exposes a <code>private</code> member of the class. But this is an oversimplified example, I am just trying to tackle the problem of why implicit conversions to <code>std::array</code> does not work.</p>\n<p>I have tried the above example with both <code>clang-3.2</code> and <code>gcc-4.8</code>. Neither compiles.</p>\n<p>Even more perplexing is that if I use implicit conversion to pointer, compilation apparently succeeds:</p>\n<pre><code>operator float *() { return data.begin(); }\noperator const float *() const { return data.cbegin(); }\n</code></pre>\n<p>But of course, this means losing the many niceties of <code>std::array</code>, which I will accept if there isn't a better solution.</p>\n", "Tags": "<c++><c++11><implicit-conversion>", "OwnerUserId": "1102119", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18460289_18461082_6": {"section_id": 584, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_1": {"section_id": 583, "quality": 0.9393939393939394, "length": 31}, "so_18460289_18461082_11": {"section_id": 584, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_9": {"section_id": 584, "quality": 0.84, "length": 21}, "so_18460289_18461082_4": {"section_id": 584, "quality": 0.8771929824561403, "length": 50}, "so_18460289_18461082_3": {"section_id": 584, "quality": 0.875, "length": 14}, "so_18460289_18461082_10": {"section_id": 584, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_5": {"section_id": 584, "quality": 0.84, "length": 21}, "so_18460289_18461082_7": {"section_id": 584, "quality": 0.875, "length": 14}, "so_18460289_18461082_2": {"section_id": 584, "quality": 0.7777777777777778, "length": 28}, "so_18460289_18461082_8": {"section_id": 584, "quality": 0.8771929824561403, "length": 50}}, "n3337": {"so_18460289_18461082_6": {"section_id": 574, "quality": 0.9583333333333334, "length": 23}, "so_18460289_18461082_1": {"section_id": 573, "quality": 0.9393939393939394, "length": 31}, "so_18460289_18461082_11": {"section_id": 574, "quality": 0.9583333333333334, "length": 23}, "so_18460289_18461082_9": {"section_id": 574, "quality": 0.84, "length": 21}, "so_18460289_18461082_4": {"section_id": 574, "quality": 0.8771929824561403, "length": 50}, "so_18460289_18461082_3": {"section_id": 574, "quality": 0.875, "length": 14}, "so_18460289_18461082_10": {"section_id": 574, "quality": 0.9583333333333334, "length": 23}, "so_18460289_18461082_2": {"section_id": 574, "quality": 0.7777777777777778, "length": 28}, "so_18460289_18461082_7": {"section_id": 574, "quality": 0.875, "length": 14}, "so_18460289_18461082_8": {"section_id": 574, "quality": 0.8771929824561403, "length": 50}, "so_18460289_18461082_5": {"section_id": 574, "quality": 0.84, "length": 21}}, "n4659": {"so_18460289_18461082_6": {"section_id": 607, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_8": {"section_id": 607, "quality": 0.8421052631578947, "length": 48}, "so_18460289_18461082_11": {"section_id": 607, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_4": {"section_id": 607, "quality": 0.8421052631578947, "length": 48}, "so_18460289_18461082_3": {"section_id": 607, "quality": 0.875, "length": 14}, "so_18460289_18461082_1": {"section_id": 606, "quality": 0.9393939393939394, "length": 31}, "so_18460289_18461082_2": {"section_id": 607, "quality": 0.7777777777777778, "length": 28}, "so_18460289_18461082_7": {"section_id": 607, "quality": 0.875, "length": 14}, "so_18460289_18461082_10": {"section_id": 607, "quality": 0.9166666666666666, "length": 22}, "so_18460289_18461082_9": {"section_id": 607, "quality": 0.84, "length": 21}, "so_18460289_18461082_5": {"section_id": 607, "quality": 0.84, "length": 21}}}});