post_cb({"14468561": {"ParentId": "14468460", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The C++ answer (\u00a72.14.5):</p>\n<blockquote>\n<p id=\"so_14468460_14468561_0\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined.</p>\n</blockquote>\n<p>It is entirely up to the implementation how it decides to create the string literal objects. One implementation may do it differently to another. Yours appears to treat identical string literals as the same object.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-01-22T21:59:57.817", "Id": "14468561", "Score": "2", "CreationDate": "2013-01-22T21:43:23.627", "LastActivityDate": "2013-01-22T21:59:57.817"}, "14468460": {"CommentCount": "3", "AcceptedAnswerId": "14468505", "ClosedDate": "2013-01-23T10:35:06.627", "CreationDate": "2013-01-22T21:37:28.247", "LastActivityDate": "2013-01-22T21:59:57.817", "PostTypeId": "1", "ViewCount": "106", "Title": "intern work of char - better/equal to lookup", "Id": "14468460", "Score": "1", "Body": "<p>i tried the following:</p>\n<pre><code>int main()\n{\n    char* a = \"sdwgfwegwe wefwef wefwefwefwysadqaw\";\n    char* b = \"acd\";\n    char* c = \"sdwgfwegwe wefwef wefwefwefwysadqaw\";\n    char* d;\n\n    d = \"acd\";\n\n    printf(\"%p\\n\", a);\n    printf(\"%p\\n\", b);\n    printf(\"%p\\n\", c);\n    printf(\"%p\\n\", d);\n\n    getchar();\n\n    return 0;\n}\n</code></pre>\n<p>and on the output(console) a and c had the same address as well as b and d.\ni thought about implementing a lookup-table for every character.\nis there any benefit/situation of doing it?\nand what does the compiler makes out of it (the example above, not the lookup-table :) )? check if this string is already used, if not, reserve memory for the given string -&gt; return it to a?\nhas anybody some book tips or links, that go this deep and explain the internal memory allocations/management, even if it is compiler dependent?\nthanks in advance.</p>\n", "Tags": "<c++><c><lookup-tables>", "OwnerUserId": "1347198", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14468460_14468561_0": {"section_id": 5361, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_14468460_14468561_0": {"section_id": 5157, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_14468460_14468561_0": {"section_id": 6789, "quality": 0.8888888888888888, "length": 8}}}, "14468505": {"ParentId": "14468460", "CommentCount": "1", "Body": "<p>String literals are specified to be unmodifiable in C.</p>\n<p>And from the C99 rationale <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\">document</a>: </p>\n<blockquote>\n<p id=\"so_14468460_14468505_0\">\"This specification <strong>allows implementations to  share copies of strings with identical text</strong>, to place string\n          literals in read-only memory, and to perform certain optimizations\"</p>\n</blockquote>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "14468505", "Score": "7", "CreationDate": "2013-01-22T21:39:40.447", "LastActivityDate": "2013-01-22T21:39:40.447"}});