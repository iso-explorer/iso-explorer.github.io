post_cb({"8600619": {"ParentId": "8600486", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This is a design error of C++. The rule says that any integer constant expression with value zero can be considered as the null pointer constant.</p>\n<p>This <strike>idiotic</strike> highly questionable decision allows to use as null pointer  <code>'\\0'</code> (as you found) but also things like <code>(1==2)</code> or even <code>!!!!!!!!!!!1</code> (an example similar to one that is present on \"The C++ programming language\", no idea if Stroustrup thinks this is indeed a \"cool\" feature).</p>\n<p>This ambiguity IMO even creates a loophole in the syntax definition when mixed with ternary operator semantic and implicit conversions rules: I remember finding a case in which out of three compilers one was not compiling and the other two were compiling with different semantic ... and after wasting a day on reading the standard and asking experts on c.c.l.c++.m I was not able to decide which of the three compilers was right.</p>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2011-12-22T10:14:52.617", "Id": "8600619", "Score": "1", "CreationDate": "2011-12-22T07:25:08.617", "LastActivityDate": "2011-12-22T10:14:52.617"}, "8601976": {"ParentId": "8600486", "CommentCount": "0", "Body": "<p>What makes it legal and well defined is the fact that <code>'\\0'</code> is a <em>null pointer constant</em> so it can be converted to any pointer type to make a <em>null pointer value</em>.</p>\n<p>ISO/IEC 14882:2011 4.10 [conv.ptr] / 1:</p>\n<blockquote>\n<p id=\"so_8600486_8601976_0\">A <em>null pointer constant</em> is an integral constant expression prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a <em>null pointer conversion</em>.</p>\n</blockquote>\n<p><code>'\\0'</code> meets the requirements of \"integral constant expression prvalue of integer type that evaluates to zero\" because <code>char</code> is an integer type and <code>\\0</code> has the value zero.</p>\n<p>Other integers can only be explicitly converted to a pointer type via a <code>reinterpret_cast</code> and the result is only meaningful if the integer was the result of converting a valid pointer to an integer type of sufficient size.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "8601976", "Score": "8", "CreationDate": "2011-12-22T09:40:40.910", "LastActivityDate": "2011-12-22T09:40:40.910"}, "8600512": {"ParentId": "8600486", "CommentCount": "7", "Body": "<p><code>'\\0'</code> is simply a different way of writing <code>0</code>.  I would guess that this is legal comparing pointers to <code>0</code> makes sense, no matter how you wrote the <code>0</code>, while there is almost never any valid meaning to comparing a pointer to any other non-pointer type.</p>\n", "OwnerUserId": "1084", "PostTypeId": "2", "Id": "8600512", "Score": "5", "CreationDate": "2011-12-22T07:12:17.357", "LastActivityDate": "2011-12-22T07:12:17.357"}, "bq_ids": {"n4140": {"so_8600486_8601976_0": {"section_id": 39, "quality": 0.8048780487804879, "length": 33}}, "n3337": {"so_8600486_8601976_0": {"section_id": 36, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_8600486_8601976_0": {"section_id": 39, "quality": 0.8048780487804879, "length": 33}}}, "8600486": {"CommentCount": "0", "ViewCount": "355", "PostTypeId": "1", "LastEditorUserId": "187584", "CreationDate": "2011-12-22T07:09:30.703", "LastActivityDate": "2011-12-22T10:14:52.617", "Title": "Why is it okay to compare a pointer with '\\0'? (but not 'A')", "AcceptedAnswerId": "8601976", "LastEditDate": "2011-12-22T09:31:28.860", "Id": "8600486", "Score": "5", "Body": "<p>I found a bug in my code where I compared the pointer with '\\0'.</p>\n<p>Wondering why the compiler didn't warn me about this bug I tried the following.</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct Foo\n{\n    char bar[5];\n};\n\nint main()\n{\n    Foo f;\n    Foo* p = &amp;f;\n    p-&gt;bar[0] = '\\0';\n    assert(p-&gt;bar == '\\0');    // #1. I forgot [] Now, comparing pointer with NULL and fails.\n    assert(p-&gt;bar == 'A');     // #2. error: ISO C++ forbids comparison between pointer and integer\n    assert(p-&gt;bar[0] == '\\0'); // #3. What I intended, PASSES\n    return 0;\n}\n</code></pre>\n<p>What is special about '\\0' which makes #1 legal and #2 illegal?</p>\n<p>Please add a reference or quotation to your answer.</p>\n", "Tags": "<c++>", "OwnerUserId": "187584", "AnswerCount": "3"}});