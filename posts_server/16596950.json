post_cb({"bq_ids": {"n4140": {"so_16596950_16596950_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 2707}, "so_16596950_16596950_3": {"length": 4, "quality": 1.0, "section_id": 4352}, "so_16596950_16596950_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 4354}, "so_16596950_16596950_6": {"length": 7, "quality": 0.7777777777777778, "section_id": 4355}, "so_16596950_16596950_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 4353}}, "n3337": {"so_16596950_16596950_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 2669}, "so_16596950_16596950_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 6050}}, "n4659": {"so_16596950_16596950_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1076}, "so_16596950_16596950_3": {"length": 4, "quality": 1.0, "section_id": 5614}, "so_16596950_16596950_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5616}, "so_16596950_16596950_6": {"length": 7, "quality": 0.7777777777777778, "section_id": 5617}, "so_16596950_16596950_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 5615}}}, "16597578": {"Id": "16597578", "PostTypeId": "2", "Body": "<p>Quoting from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3588.txt\" rel=\"nofollow noreferrer\">the original proposal</a>:</p>\n<blockquote>\n<p id=\"so_16596950_16597578_0\"><code>T[N]</code></p>\n<p id=\"so_16596950_16597578_1\">As of N3485, <code>unique_ptr</code> doesn't provide a partial specialization for <code>T[N]</code>.\n      However, users will be strongly tempted to write <code>make_unique&lt;T[N]&gt;()</code>. This\n      is a no-win scenario. Returning <code>unique_ptr&lt;T[N]&gt;</code> would select the primary\n      template for single objects, which is bizarre. Returning <code>unique_ptr&lt;T[]&gt;</code>\n      would be an exception to the otherwise ironclad rule that\n      <code>make_unique&lt;something&gt;()</code> returns <code>unique_ptr&lt;something&gt;</code>. Therefore, this\n      proposal makes <code>T[N]</code> ill-formed here, allowing implementations to emit\n      helpful <code>static_assert</code> messages.</p>\n</blockquote>\n<p>The author of the proposal, Stephan T. Lavavej, illustrates this situation in <a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/STLCCSeries6\" rel=\"nofollow noreferrer\">this video on Core C++</a> (courtesy of <a href=\"https://stackoverflow.com/users/962089/chris\">chris</a>), starting from minute 1:01:10 (more or less).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-16T22:08:18.570", "Score": "31", "CreationDate": "2013-05-16T21:12:33.910", "ParentId": "16596950", "CommentCount": "1", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:16:56.820"}, "16596950": {"ViewCount": "2973", "Body": "<p><sup>Assume namespace <code>std</code> throughout.</sup></p>\n<p>The C++14 committee draft N3690 defines <code>std::make_unique</code> thus:</p>\n<blockquote>\n<p id=\"so_16596950_16596950_0\"><code>[n3690: 20.9.1.4]:</code> <strong><code>unique_ptr</code> creation</strong> \u00a0\u00a0\u00a0<em>[unique.ptr.create]</em></p>\n<p id=\"so_16596950_16596950_1\"><code>template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);</code></p>\n<p id=\"so_16596950_16596950_2\"><strong>1</strong> Remarks: This function shall not participate in overload resolution unless <code>T</code> is not an array.<br>\n<strong>2</strong> Returns: <code>unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...)).</code></br></p>\n<p id=\"so_16596950_16596950_3\"><code>template &lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);</code></p>\n<p id=\"so_16596950_16596950_4\"><strong>3</strong> Remarks: This function shall not participate in overload resolution unless <code>T</code> is an array of unknown bound.<br>\n<strong>4</strong> Returns: <code>unique_ptr&lt;T&gt;(new typename remove_extent&lt;T&gt;::type[n]()).</code></br></p>\n<p id=\"so_16596950_16596950_5\"><code>template &lt;class T, class... Args&gt; unspecified make_unique(Args&amp;&amp;...) = delete;</code></p>\n<p id=\"so_16596950_16596950_6\"><strong>5</strong> Remarks: This function shall not participate in overload resolution unless <code>T</code> is an array of known bound.</p>\n</blockquote>\n<p>Now, this seems to me to be about as clear as mud, and I think it needs more exposition. But, this editorial comment aside, I believe I've decoded the meanings of each variant:</p>\n<ol>\n<li><p><code>template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);</code></p>\n<p>Your bog-standard <code>make_unique</code> for non-array types. Presumably the \"remark\" indicates that some form of static assertion or SFINAE trick is to prevent the template from being successfully instantiated when <code>T</code> is an array type.</p>\n<p>At a high-level, see it as the smart-pointer equivalent to <code>T* ptr = new T(args);</code>.</p></li>\n<li><p><code>template &lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);</code></p>\n<p>A variant for array types. Creates a dynamically-allocated array of <code>n</code> \u00d7 <code>Ts</code>, and returns it wrapped in a <code>unique_ptr&lt;T[]&gt;</code>.</p>\n<p>At a high-level, see it as the smart-pointer equivalent to <code>T* ptr = new T[n];</code>.</p></li>\n<li><p><code>template &lt;class T, class... Args&gt; unspecified make_unique(Args&amp;&amp;...)</code></p>\n<p>Disallowed. \"<em>unspecified</em>\" would probably be <code>unique_ptr&lt;T[N]&gt;</code>.</p>\n<p>Would otherwise be the smart-pointer equivalent to something like the invalid <code>T[N]* ptr = new (keep_the_dimension_please) (the_dimension_is_constexpr) T[N];</code>.</p></li>\n</ol>\n<p>First of all, am I correct? And, if so, what's going on with the third function?</p>\n<ul>\n<li><p>If it's there to disallow programmers from attempting to dynamically-allocate an array while providing constructor arguments for each element (just as <code>new int[5](args)</code> is impossible), then that's already covered by the fact that the first function cannot be instantiated for array types, isn't it?</p></li>\n<li><p>If it's there to prevent the addition to the language of a construct like <code>T[N]* ptr = new T[N]</code> (where <code>N</code> is some <code>constexpr</code>) then, well, why? Wouldn't it be completely possible for a <code>unique_ptr&lt;T[N]&gt;</code> to exist that wraps a dynamically-allocated block of <code>N</code> \u00d7 <code>T</code>s? Would this be such a bad thing, to the extent that the committee has gone out of its way to disallow its creation using <code>make_unique</code>?</p></li>\n</ul>\n<p><strong>Why is <code>make_unique&lt;T[N]&gt;</code> disallowed?</strong></p>\n", "AcceptedAnswerId": "16597578", "Title": "Why is `make_unique<T[N]>` disallowed?", "CreationDate": "2013-05-16T20:33:02.743", "Id": "16596950", "CommentCount": "25", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-07-02T11:34:17.307", "LastEditorUserId": "46642", "LastActivityDate": "2013-12-01T15:34:13.487", "Score": "24", "OwnerUserId": "560648", "Tags": "<c++><language-lawyer><unique-ptr><c++14>", "AnswerCount": "2"}, "20313842": {"Id": "20313842", "PostTypeId": "2", "Body": "<p>To me the third overload looks superfluous as does not change the fact that the other overloads won't match <code>T[N]</code> and it does <em>not</em> seem to help to generate better error messages. Consider the following implementation:</p>\n<pre><code>template&lt; typename T, typename... Args &gt;\ntypename enable_if&lt; !is_array&lt; T &gt;::value, unique_ptr&lt; T &gt; &gt;::type\nmake_unique( Args&amp;&amp;... args )\n{\n  return unique_ptr&lt; T &gt;( new T( forward&lt; Args &gt;( args )... ) );\n}\n\ntemplate&lt; typename T &gt;\ntypename enable_if&lt; is_array&lt; T &gt;::value &amp;&amp; extent&lt; T &gt;::value == 0, unique_ptr&lt; T &gt; &gt;::type\nmake_unique( const size_t n )\n{\n  using U = typename remove_extent&lt; T &gt;::type;\n  return unique_ptr&lt; T &gt;( new U[ n ]() );\n}\n</code></pre>\n<p>When you try to call <code>std::make_unique&lt;int[1]&gt;(1)</code>, the error message lists both candidates as disabled by <code>enable_if</code>. If you add the third, deleted overload, the error message lists three candidates instead. Also, since it is specified as <code>=delete;</code>, you can not provide a more meaningful error message in the third overload's body, e.g., <code>static_assert(sizeof(T)==0,\"array of known bound not allowed for std::make_shared\");</code>.</p>\n<p>Here's the <a href=\"http://coliru.stacked-crooked.com/a/1494be9e4ce4866c\" rel=\"nofollow\"><strong>live example</strong></a> in case you want to play with it.</p>\n<p>The fact that the third overload ended up in N3656 and N3797 is probably due to the history of how <code>make_unique</code> was developed over time, but I guess only STL can answer that :)</p>\n", "LastActivityDate": "2013-12-01T15:34:13.487", "CommentCount": "6", "CreationDate": "2013-12-01T15:34:13.487", "ParentId": "16596950", "Score": "0", "OwnerUserId": "2073257"}});