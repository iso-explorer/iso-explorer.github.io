post_cb({"36334378": {"ParentId": "36333003", "CommentCount": "3", "Body": "<p>I suspect this is all simply covered by <a href=\"http://eel.is/c++draft/temp.inst#14\" rel=\"nofollow\">[temp.inst]</a>:</p>\n<blockquote>\n<p id=\"so_36333003_36334378_0\">The result of an infinite recursion in instantiation is\n  undefined.</p>\n</blockquote>\n<p>Regardless of which way you define your <code>has_f</code>, it involves infinite recursion. <code>has_f&lt;Bar&gt;</code> involves the instantiation of <code>f(Bar )</code> which involves the instantiation of <code>has_f&lt;Bar&gt;</code> which involves the instantiation of ... </p>\n<p>The fact that one way of defining <code>has_f</code> works in some circumstances but not in others, and the other way definitely doesn't work, is just a consequence of undefined behavior. Undefined behavior is undefined. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "36334378", "Score": "2", "CreationDate": "2016-03-31T13:05:51.867", "LastActivityDate": "2016-03-31T13:05:51.867"}, "36333003": {"CommentCount": "2", "AcceptedAnswerId": "36334378", "CreationDate": "2016-03-31T12:06:31.170", "LastActivityDate": "2016-03-31T13:05:51.867", "PostTypeId": "1", "ViewCount": "129", "FavoriteCount": "1", "Title": "C++ function which is only enabled if it doesn't exist", "Id": "36333003", "Score": "3", "Body": "<p>I think I just made a C++ paradox...</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\n// If has_f trait is defined in this way, compilation breaks because of infinite recursion in template substitution\n/*\ntemplate&lt; typename T, typename Enable=void &gt;\nstruct has_f : std::false_type { };\n\ntemplate&lt; typename T &gt;\nstruct has_f&lt;T, decltype(f(std::declval&lt;T&gt;()))&gt; : std::true_type { };\n*/\n\n// Defining has_f like this works on MSVC, gcc and CLang\nnamespace has_f_impl {\n  struct no{ };\n  template&lt; typename T &gt;\n  no check(...);\n  template&lt; typename T &gt;\n  decltype(f(std::declval&lt;T&gt;())) check(void const*);\n\n  template&lt; typename T &gt;\n  struct has_f : std::integral_constant&lt;bool, !std::is_same&lt;no, decltype(check&lt;T&gt;(nullptr))&gt;::value&gt; { };\n}\nusing has_f_impl::has_f;\n\nstruct Foo { };\nstruct Bar { };\n\ntemplate&lt; typename T, std::enable_if_t&lt;std::is_same&lt;Foo, T&gt;::value, int&gt; = 0 &gt;\nvoid f(T const&amp;);\n\ntemplate&lt; typename T, std::enable_if_t&lt;!has_f&lt;T const&amp;&gt;::value, int&gt; = 1 &gt;\nvoid f(T const&amp;);\n\nint main() {\n  f(Foo()); // Calls f&lt;Foo,0&gt;()\n  f(Bar()); // Calls f&lt;Bar,1&gt;()\n  f(Foo()); // Calls f&lt;Foo,0&gt;()\n  f(Bar()); // Calls f&lt;Bar,1&gt;()\n}\n</code></pre>\n<p>The above code surprisingly works, and in a very smart way, only using the generic <code>f</code> when there's really no other option.</p>\n<p>Also, and this is probably because of ODR, the following happens</p>\n<pre><code>// Includes, has_f, Foo, Bar and f as above\ntemplate&lt; typename T, std::enable_if_t&lt;has_f&lt;T const&amp;&gt;::value&gt;* = nullptr &gt;\nvoid g(T const&amp;);\n\nint main() {\n  f(Foo()); // Calls f&lt;Foo,0&gt;()\n  f(Bar()); // Calls f&lt;Bar,1&gt;()\n  f(Foo()); // Calls f&lt;Foo,0&gt;()\n  f(Bar()); // Calls f&lt;Bar,1&gt;()\n  g(Foo());\n  //g(Bar()); //No such function\n}\n</code></pre>\n<p>As far as I tried, all of this seems to be independent from declaration order.</p>\n<p>My question is: what's really happening here? Is this a standard-defined behavior, an undefined condition which all the compiler I tried handle in the same way, or a bug which is present by coincidence in all the compilers I tried?</p>\n", "Tags": "<c++><c++14><sfinae>", "OwnerUserId": "2653222", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36333003_36334378_0": {"section_id": 249, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_36333003_36334378_0": {"section_id": 240, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_36333003_36334378_0": {"section_id": 256, "quality": 0.8333333333333334, "length": 5}}}});