post_cb({"6179994": {"ParentId": "5924870", "CommentCount": "7", "Body": "<p>From 5.19 <code>[expr.const]</code>, every <em>literal constant expression</em> is a prvalue.</p>\n<blockquote>\n<p id=\"so_5924870_6179994_0\">A <em>literal constant expression</em> is a prvalue core constant expression of literal type, but not pointer type. An <em>integral constant expression</em> is a literal constant expression of integral or unscoped enumeration type.</p>\n</blockquote>\n<p>Therefore rule 4 applies to all literal constant expressions.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "6179994", "Score": "2", "CreationDate": "2011-05-30T19:20:08.467", "LastActivityDate": "2011-05-30T19:20:08.467"}, "5924986": {"ParentId": "5924870", "CommentCount": "1", "Body": "<p>Your reasoning is correct. An expression involving only constants is a constant by itself. Thus</p>\n<pre><code>decltype(0 + 0) x;\n</code></pre>\n<p>equals</p>\n<pre><code>decltype(0) x;\n</code></pre>\n<p>which equals</p>\n<pre><code>int x;\n</code></pre>\n", "OwnerUserId": "565635", "PostTypeId": "2", "Id": "5924986", "Score": "2", "CreationDate": "2011-05-08T01:02:13.183", "LastActivityDate": "2011-05-08T01:02:13.183"}, "5925323": {"ParentId": "5924870", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>0 + 0</code> is an expression of two prvalues, (n3290 par. 3.10) which applies the built-in <code>operator+</code>, which, per 13.6/12 is <code>LR operator+(L,R)</code>, which is therefore a function that returns something that is not a reference. The result of the expression is therefore also a prvalue (as per 3.10).</p>\n<p>Hence, the result of 0 + 0 is a prvalue, 0 is an <code>int</code>, therefore the result of 0 + 0 is an <code>int</code></p>\n", "OwnerUserId": "663580", "LastEditorUserId": "663580", "LastEditDate": "2011-05-08T03:14:19.113", "Id": "5925323", "Score": "9", "CreationDate": "2011-05-08T02:55:29.880", "LastActivityDate": "2011-05-08T03:14:19.113"}, "5924870": {"CommentCount": "6", "ViewCount": "1045", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-05-08T00:21:43.513", "LastActivityDate": "2011-05-30T19:20:08.467", "Title": "What is decltype(0 + 0)?", "AcceptedAnswerId": "6179994", "LastEditDate": "2017-05-23T10:29:49.260", "Id": "5924870", "Score": "13", "Body": "<p><em>(Prompted by <a href=\"https://stackoverflow.com/q/5877810\">an answer</a>.)</em></p>\n<p>Given N3290, \u00a77.1.6.2p4, where the list items are unnumbered, but numbered here for our convenience:</p>\n<blockquote>\n<p id=\"so_5924870_5924870_0\">The type denoted by decltype(e) is defined as follows:</p>\n<ol>\n<li>if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e) is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded functions, the program is ill-formed;</li>\n<li>otherwise, if e is an xvalue, decltype(e) is T&amp;&amp;, where T is the type of e;</li>\n<li>otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;</li>\n<li>otherwise, decltype(e) is the type of e.</li>\n</ol>\n</blockquote>\n<p>What is the type specified by decltype(0 + 0)?</p>\n<p>Item 1 doesn't apply, 2 might, but if not, then 3 doesn't apply and 4 would be the result. So, what is an xvalue, and is 0 + 0 an xvalue?</p>\n<p>\u00a73.10p1:</p>\n<blockquote>\n<p id=\"so_5924870_5924870_1\">An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2).</p>\n</blockquote>\n<p>I don't see anything in \u00a78.3.2 that would be helpful here, but I do know \"0 + 0\" doesn't involve any rvalue-references. The literal 0 is a prvalue, which is \"an rvalue that is not an xvalue\" (\u00a73.10p1).  I believe \"0 + 0\" is also a prvalue.  If that's true, \"decltype(0 + 0)\" would be int (not int&amp;&amp;).</p>\n<p>Have I missed something in my interpretation?  Is this code well-formed?</p>\n<pre><code>decltype(0 + 0) x;  // Not initialized.\n</code></pre>\n<p>The code compiles on GCC 4.7.0 20110427 and Clang 2.9 (trunk 126116).  It would not be well-formed if the decltype specified an int&amp;&amp; type, for example.</p>\n", "Tags": "<c++><c++11><rvalue><decltype><xvalue>", "OwnerUserId": "511601", "AnswerCount": "5"}, "5925363": {"ParentId": "5924870", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is definitely an int:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;typename T&gt;\nstruct ref_depth\n{\n        enum { value = 0 };\n};\n\ntemplate&lt;typename T&gt;\nstruct ref_depth&lt;T&amp;&gt;\n{\n        enum { value = 1 };\n};\n\ntemplate&lt;typename T&gt;\nstruct ref_depth&lt;T&amp;&amp;&gt;\n{\n        enum { value = 2 };\n};\n\nint main() {\n\n  std::cout\n    &lt;&lt; \"int: \" &lt;&lt; typeid(int).name() &lt;&lt; \"\\n\"\n       \"decltype(0 + 0): \" &lt;&lt; typeid(decltype(0 + 0)).name() &lt;&lt; \"\\n\"\n       \"int&amp;&amp;: \" &lt;&lt; typeid(int&amp;&amp;).name() &lt;&lt; \"\\n\";\n  std::cout \n    &lt;&lt; \"ref_depth: int: \" &lt;&lt; ref_depth&lt;int&gt;::value &lt;&lt; \"\\n\"\n       \"ref_depth: decltype(0 + 0): \" &lt;&lt; ref_depth&lt;decltype(0 + 0)&gt;::value &lt;&lt; \"\\n\"\n       \"ref_depth: int&amp;&amp;: \" &lt;&lt; ref_depth&lt;int&amp;&amp;&gt;::value &lt;&lt; \"\\n\";\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>int: i\ndecltype(0 + 0): i\nint&amp;&amp;: i\nref_depth: int: 0\nref_depth: decltype(0 + 0): 0\nref_depth: int&amp;&amp;: 2\n</code></pre>\n", "OwnerUserId": "612665", "LastEditorUserId": "612665", "LastEditDate": "2011-05-08T12:00:12.320", "Id": "5925363", "Score": "5", "CreationDate": "2011-05-08T03:13:16.767", "LastActivityDate": "2011-05-08T12:00:12.320"}, "bq_ids": {"n4140": {"so_5924870_5924870_0": {"section_id": 5440, "quality": 0.8333333333333334, "length": 5}, "so_5924870_6179994_0": {"section_id": 6186, "quality": 0.5909090909090909, "length": 13}, "so_5924870_5924870_1": {"section_id": 7230, "quality": 0.92, "length": 23}}, "n3337": {"so_5924870_5924870_0": {"section_id": 5235, "quality": 0.8333333333333334, "length": 5}, "so_5924870_6179994_0": {"section_id": 5947, "quality": 0.9090909090909091, "length": 20}, "so_5924870_5924870_1": {"section_id": 6974, "quality": 0.92, "length": 23}}, "n4659": {"so_5924870_5924870_0": {"section_id": 6867, "quality": 0.8333333333333334, "length": 5}, "so_5924870_6179994_0": {"section_id": 7687, "quality": 0.5454545454545454, "length": 12}}}, "5924958": {"ParentId": "5924870", "CommentCount": "2", "Body": "<p>GCC says <code>int</code>-</p>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint\nmain ()\n{\n  int n;\n  decltype(0 + 0) x;\n  std::cout &lt;&lt; \"Type of `n': \" &lt;&lt; typeid(n).name() &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Type of `x': \" &lt;&lt; typeid(x).name() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_5924870_5924958_0\">i</p>\n<p id=\"so_5924870_5924958_1\">i</p>\n</blockquote>\n<p>Edit: It makes sense according to point 4, but I can't say for sure that point 2 isn't actually the one in effect.  From what I can tell, 0 + 0 is evaluated to 0, and the type of 0 is <code>int</code>, so that is the declared type.</p>\n", "OwnerUserId": "539810", "PostTypeId": "2", "Id": "5924958", "Score": "0", "CreationDate": "2011-05-08T00:48:04.923", "LastActivityDate": "2011-05-08T00:48:04.923"}});