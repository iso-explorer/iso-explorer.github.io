post_cb({"3849816": {"ParentId": "3849724", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><i>it means that my derived class can always be converted to base class</i></p>\n<p>Actually it means better than that. <code>int</code> can always be converted to <code>float</code>, but that doesn't mean an int \"is a\" float. It just means a float can be constructed from an int. Likewise you can have user-defined classes that convert, but have no other relationship.</p>\n<p>With inheritance, a pointer or reference to the derived class can always be converted to a pointer or reference to the base class[*]. That is to say, an object of the derived class can stand in place of an object of the base class. It actually is one of those things. If a person can stand in for a brain surgeon, then they're a brain surgeon.</p>\n<p>One formal definition if \"is a\" is Barbara Liskov's <a href=\"http://en.wikipedia.org/wiki/Liskov_substitution_principle\" rel=\"nofollow\">substitution principle</a>. Which admittedly is still philosophy, but it's very sound philosophy and it relates directly to how you write programs.</p>\n<p>The other thing you have to keep straight when using inheritance in C++ is the difference between runtime polymorphism (achieved using <code>virtual</code> functions) and static polymorphism (which doesn't actually require inheritance at all). With non-virtual function calls, the version of the function called is always the version defined in the class that the compiler is told the object has (the static type). This might not actually work correctly, if it's overloaded in the derived class. With virtual calls, the version called is the version defined in the class the object actually is (the dynamic type). It's essential to decide which of the two kinds of \"is a\" you're aiming for.</p>\n<p>[*] and the object be validly accessible through the pointer, that is. You can always coerce pointer types with <code>reinterpret_cast</code>, but that's not what I mean here. And there are some fiddly details - if the base class is ambiguous then you can't convert the pointer in one go, but you can do it explicitly using several unambiguous casts. If the base class is not accessible then you <em>can</em> convert it, but only with a C-style cast, not implicitly. The C-style cast acts like a <code>static_cast</code> which ignores accessibility, not like a <code>reinterpret_class</code>. So you get a working pointer, but hopefully also a strong sense that you're doing something very wrong ;-)</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-10-07T11:24:41.323", "Id": "3849816", "Score": "4", "CreationDate": "2010-10-03T12:55:13.327", "LastActivityDate": "2010-10-07T11:24:41.323"}, "3849776": {"ParentId": "3849724", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>A derived class can be converted to only an accessible and unambiguous base class at a given point R. There is no dearth of references and what other place than the C++ standard itself.</p>\n<blockquote>\n<p id=\"so_3849724_3849776_0\">$10.2 is a good reference: A derived\n  class can itself serve as a base class\n  subject to access control; see 11.2. A\n  pointer to a derived class can be\n  implicitly converted to a pointer to\n  an accessible unambiguous base class\n  (4.10). An lvalue of a derived class\n  type can be bound to a reference to an\n  accessible unambiguous base class\n  (8.5.3). \u2014end note ]</p>\n</blockquote>\n<p>And again</p>\n<blockquote>\n<p id=\"so_3849724_3849776_1\">$10.3 - \"The base-specifier-list\n  specifies the type of the base class\n  subobjects contained in an object of\n  the derived class type.[..] Here, an\n  object of class Derived2 will have a\n  subobject of class Derived which in\n  turn will have a subobject of class\n  Base.[...]</p>\n</blockquote>\n<p>In terms of OOAD principles:</p>\n<p>I would personally recommend <a href=\"http://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"nofollow\">Robert Martin's articles</a> for getting a good hold on this especially the OCP principle. It is not possible for me to beat the clarity and authority with which the author explains these legendary OOAD guidelines</p>\n<p>Also look at LSP as explained in @Steves' post</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-10-03T13:33:33.320", "Id": "3849776", "Score": "2", "CreationDate": "2010-10-03T12:44:02.733", "LastActivityDate": "2010-10-03T13:33:33.320"}, "3849724": {"CommentCount": "0", "ViewCount": "739", "PostTypeId": "1", "LastEditorUserId": "418110", "CreationDate": "2010-10-03T12:33:28.950", "LastActivityDate": "2010-10-07T11:24:41.323", "Title": "technical aspects of 'isa' in c++", "AcceptedAnswerId": "3849816", "LastEditDate": "2010-10-03T12:46:51.277", "Id": "3849724", "Score": "1", "Body": "<p>what exactly does it mean from <code>technical point of view</code>, I understood that it means that my <code>derived class</code> can always be converted to <code>base class</code>, that's it? I read some materials without any reference to technical aspects, only philosophy! thanks in advance</p>\n", "Tags": "<c++><principles><ooad>", "OwnerUserId": "457445", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3849724_3849776_1": {"section_id": 6976, "quality": 0.8928571428571429, "length": 25}, "so_3849724_3849776_0": {"section_id": 6975, "quality": 0.8048780487804879, "length": 33}}, "n3337": {"so_3849724_3849776_1": {"section_id": 6722, "quality": 0.8928571428571429, "length": 25}, "so_3849724_3849776_0": {"section_id": 6721, "quality": 0.8048780487804879, "length": 33}}, "n4659": {"so_3849724_3849776_0": {"section_id": 8474, "quality": 0.8048780487804879, "length": 33}, "so_3849724_3849776_1": {"section_id": 8475, "quality": 0.8928571428571429, "length": 25}}}});