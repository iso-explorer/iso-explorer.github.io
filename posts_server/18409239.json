post_cb({"bq_ids": {"n4140": {"so_18409239_18411541_1": {"length": 26, "quality": 1.0, "section_id": 625}, "so_18409239_18411541_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}}, "n3337": {"so_18409239_18411541_1": {"length": 26, "quality": 1.0, "section_id": 615}, "so_18409239_18411541_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}}, "n4659": {"so_18409239_18411541_1": {"length": 26, "quality": 1.0, "section_id": 651}, "so_18409239_18411541_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}}}, "18411541": {"Id": "18411541", "PostTypeId": "2", "Body": "<p>One call involves an \"lvalue-to-rvalue conversion\", the other requires an identity conversion (for references) or a \"qualification adjustment\" (for pointers), and according to the Standard these are treated equally when it comes to overload resolution.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4EeJu.png\"/></p>\n<p>So, neither is better on the basis of differing conversions.</p>\n<p>There is, however, a special rule in the Standard, section 13.3.3.2, that applies only if both candidates being compared take the parameter by reference.</p>\n<blockquote>\n<p id=\"so_18409239_18411541_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if ... <code>S1</code> and <code>S2</code> are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level <em>cv-qualifiers</em>, and the type to which the reference initialized by <code>S2</code> refers is more <em>cv-qualified</em> than the type to which the reference initialized by <code>S1</code> refers.</p>\n</blockquote>\n<p>There's an identical rule for pointers.</p>\n<p>Therefore the compiler will prefer</p>\n<pre><code>f(int*);\nf(int&amp;);\n</code></pre>\n<p>over</p>\n<pre><code>f(const int*);\nf(const int&amp;);\n</code></pre>\n<p>respectively, but there's no preference for <code>f(int)</code> vs <code>f(const int)</code> vs <code>f(const int&amp;)</code>, because lvalue-to-rvalue transformation and qualification adjustment are both considered \"Exact Match\".</p>\n<hr>\n<p>Also relevant, from section 13.3.3.1.4:</p>\n<blockquote>\n<p id=\"so_18409239_18411541_1\">When a parameter of reference type binds directly to an argument expression, the implicit conversion sequence is the identity conversion, unless the argument expression has a type that is a derived class of the parameter type, in which case the implicit conversion sequence is a derived-to-base Conversion.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2013-08-23T23:13:04.743", "Score": "3", "CreationDate": "2013-08-23T20:44:46.990", "ParentId": "18409239", "CommentCount": "7", "OwnerUserId": "103167", "LastEditDate": "2013-08-23T23:13:04.743"}, "18409597": {"Id": "18409597", "PostTypeId": "2", "Body": "<p>The second call <code>f(i)</code> is also ambiguous because <code>void f(const int &amp;ri)</code> indicates that <code>ri</code> is a reference to <code>i</code> and is a constant. Meaning it says that it will not modify the original  <code>i</code> which is passed to that function. </p>\n<p>The choice whether to modify the passed argument or not is in the hands of the implementer of the function not the client programmer who mearly uses that function.</p>\n", "LastActivityDate": "2013-08-23T18:33:18.880", "CommentCount": "0", "CreationDate": "2013-08-23T18:33:18.880", "ParentId": "18409239", "Score": "1", "OwnerUserId": "1634969"}, "18409239": {"ViewCount": "532", "Body": "<p>I have a question regarding the c++ function matching for parameters of types <code>T</code> and <code>const T&amp;</code>.\nLet's say I have the following two functions:</p>\n<pre><code>void f(int i) {}\nvoid f(const int &amp;ri) {}\n</code></pre>\n<p>If I call <code>f</code> with an argument of type <code>const int</code> then this call is of course ambiguous. But why is a call of <code>f</code> with an argument of type <code>int</code> also ambiguous? Wouldn't be the first version of <code>f</code> be an exact match and the second one a worse match, because the <code>int</code> argument must be converted to a <code>const int</code>?</p>\n<pre><code>const int ci = 0;\nint i = 0;\nf(ci); // of course ambiguous\nf(i); // why also ambiguous?\n</code></pre>\n<p>I know that such kind of overloading doesn't make much sense, because calls of <code>f</code> are almost always ambiguous unless the parameter type T doesn't have an accessible copy constructor. But I'm just studying the rules of function matching.</p>\n<p>Regards,\nKevin</p>\n<p>EDIT: To make my question more clear. If I have the two functions:</p>\n<pre><code>void f(int *pi) {}\nvoid f(const int *pi) {}\n</code></pre>\n<p>Then the following call is not ambiguous:</p>\n<pre><code>int i = 0;\nf(&amp;i); // not ambiguous, first version f(int*) chosen\n</code></pre>\n<p>Although both versions of <code>f</code> could be called with <code>&amp;i</code> the first version is chosen, because the second version of <code>f</code> would include a conversion to <code>const.</code> That is, the first version is a \"better match\". But in the two functions:</p>\n<pre><code>void f(int i) {} and\nvoid f(const int &amp;ri) {}\n</code></pre>\n<p>This additional conversion to <code>const</code> seems to be ignored for some reason. Again both versions of <code>f</code> could be called with an <code>int</code>. But again, the second version of <code>f</code> would require a conversion to <code>const</code> which would make it a worse match than the first version <code>f(int).</code></p>\n<pre><code>int i = 1;\n// f(int) requires no conversion\n// f(const int &amp;) does require a const conversion\n// so why are both versions treated as \"equally good\" matches?\n// isnt this analogous to the f(int*) and f(const int*) example?\nf(i); // why ambiguous this time?\n</code></pre>\n", "AcceptedAnswerId": "18411541", "Title": "Function Matching for parameters of type const T& and T", "CreationDate": "2013-08-23T18:12:48.887", "Id": "18409239", "CommentCount": "4", "LastEditDate": "2015-10-18T19:46:45.360", "PostTypeId": "1", "LastEditorUserId": "85371", "LastActivityDate": "2015-10-18T19:46:45.360", "Score": "4", "OwnerUserId": "1692163", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "18410513": {"Id": "18410513", "PostTypeId": "2", "Body": "<p>The reason the second call f(i) is ambiguous is because to the compiler, both functions would be acceptable.  const-ness can't be used to overload functions because different const versions of functions can be used in a single cause. So in your example:</p>\n<pre><code>int i = 0;\nfi(i);\n</code></pre>\n<p>How would the compiler know which function you intended in invoking?  The const qualifier is only relevant to the function definition.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/3682049/functions-with-const-arguments-and-overloading\">const function overloading</a> for a more detailed explanation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-23T19:30:36.620", "Score": "0", "CreationDate": "2013-08-23T19:30:36.620", "ParentId": "18409239", "CommentCount": "2", "OwnerUserId": "1886304", "LastEditDate": "2017-05-23T12:03:52.487"}});