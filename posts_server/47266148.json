post_cb({"47266148": {"Tags": "<c++><exception><compiler-optimization><noexcept>", "ViewCount": "187", "LastEditDate": "2017-11-13T18:16:33.210", "CreationDate": "2017-11-13T14:03:27.883", "LastEditorUserId": "1593077", "Title": "In what cases does a C++ compiler infer noexcept?", "CommentCount": "6", "AnswerCount": "1", "Score": "8", "OwnerUserId": "1593077", "Id": "47266148", "LastActivityDate": "2017-11-13T18:22:54.933", "Body": "<p>Suppose a C++ compiler is compiling a function whose definition is available in the same translation unit as its invocation. Suppose that it does not throw itself nor calls a function that is know to throw. Suppose also no <code>extern C</code> code is called, nor a numeric division with a potentially-zero value. </p>\n<p>Under these assumptions, will the compiler treat the function as <code>noexcept</code>? If not, are there additional conditions under which <code>noexcept</code> is inferred?</p>\n<p>Specifically, what about super-simple functions such as</p>\n<pre><code>void foo() { } /* this one */\nclass A { \n    int x_; \npublic: \n    x() const { return x_; }  /* ... and this one */\n}\n</code></pre>\n<p>?</p>\n<p>I'd like an answer based only on the standard, foremost, and possibly also what GCC and clang do.</p>\n", "PostTypeId": "1", "FavoriteCount": "2"}, "47266493": {"ParentId": "47266148", "Score": "3", "CreationDate": "2017-11-13T14:20:50.237", "LastActivityDate": "2017-11-13T18:22:54.933", "LastEditDate": "2017-11-13T18:22:54.933", "OwnerUserId": "27678", "LastEditorUserId": "27678", "Body": "<p>Almost all functions are assumed to be potentially throwing unless you explicitly use a <code>noexcept</code> specifier. The exceptions are for your own definitions of <code>delete</code> (deallocation functions), and some special member functions: constructors, destructors, and assignment operators. (C++17)</p>\n<p>From [except.spec]</p>\n<blockquote>\n<p id=\"so_47266148_47266493_0\">If a declaration of a function does not have a <em>noexcept-specifier</em>, the declaration has a potentially throwing\n  exception specification unless it is a destructor or a deallocation function or is defaulted on its first declaration,\n  in which cases the exception specification is as specified below and no other declaration for that function shall\n  have a <em>noexcept-specifier</em>.</p>\n</blockquote>\n<h3>Constructors</h3>\n<p>Are implicitly <code>noexcept</code> unless any initialization performed for any member (or a member's member etc) is potentially throwing</p>\n<h3>Destructors</h3>\n<p>Are implicitly <code>noexcept</code> unless any destructor for a potentially constructed sub-object is potentially throwing.</p>\n<h3>Assignment operators</h3>\n<p>Are implicitly <code>noexcept</code> unless any use of assignment within is potentially-throwing.</p>\n<hr>\n<p>Here's some sample code that demonstrates the above (<a href=\"https://wandbox.org/permlink/ml6aRaVv0fHgxjhW\" rel=\"nofollow noreferrer\">clang 6.0.0</a>, <a href=\"https://wandbox.org/permlink/LGT19KiteLXefufS\" rel=\"nofollow noreferrer\">gcc 8.0.0</a>):</p>\n<pre><code>int foo() { return 1; }\nint bar() noexcept{ return 1; }\n\nstruct Foo{};\n\nstruct Bar{\n Bar(){}\n};\n\nint main()\n{\n    static_assert(noexcept(bar()));\n    static_assert(!noexcept(foo()));\n    static_assert(noexcept(Foo()));\n    static_assert(noexcept(Foo().~Foo()));\n    static_assert(noexcept(Foo().operator=(Foo())));\n    static_assert(!noexcept(Bar()));\n    Bar b;\n    static_assert(noexcept(b.~Bar()));\n}\n</code></pre>\n<p>Yet another reason to use <code>=default</code> or allow the compiler to generate its own versions of your special member functions via omission.</p>\n</hr>", "Id": "47266493", "PostTypeId": "2", "CommentCount": "4"}, "bq_ids": {"n4659": {"so_47266148_47266493_0": {"length": 26, "section_id": 4131, "quality": 0.9629629629629629}}}});