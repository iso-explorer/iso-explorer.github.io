post_cb({"41397232": {"CommentCount": "10", "ViewCount": "87", "ClosedDate": "2016-12-30T13:57:59.987", "LastEditDate": "2016-12-30T13:44:24.653", "LastEditorUserId": "560648", "CreationDate": "2016-12-30T13:40:03.687", "LastActivityDate": "2016-12-30T13:53:01.070", "PostTypeId": "1", "Title": "Class-typed static constexpr field giving link-time errors in g++", "Id": "41397232", "OwnerUserId": "3962396", "Body": "<p>I have this snippet of code I was testing today:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Literal {\n    constexpr operator int() const { return 0; }\n};\n\nstruct Class {\n    constexpr static const Literal field0 = Literal();\n};\n\nint main(void) {\n    std::cout &lt;&lt; \"Class::field0: \" &lt;&lt; Class::field0 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>It compiles without errors (G++ 6.2.1), but unfortunately I get a link error when generating the executable:</p>\n<pre><code>/tmp/ccao6eTy.o: In function `main':\ntest-constexpr-static-field.cpp:(.text+0xa): undefined reference to `Class::field0'\ncollect2: error: ld returned 1 exit status\n[Finished in 0.3s with exit code 1]\n</code></pre>\n<p>Reading <a href=\"http://en.cppreference.com/w/cpp/language/static\" rel=\"nofollow noreferrer\">this page</a> I see this explanation:</p>\n<blockquote>\n<p id=\"so_41397232_41397232_0\">If a static data member of LiteralType is declared constexpr,\n  it must be initialized with an initializer in which every expression\n  is a constant expression, right inside the class definition (...).</p>\n</blockquote>\n<p>Then I went for the <a href=\"http://en.cppreference.com/w/cpp/concept/LiteralType\" rel=\"nofollow noreferrer\">definition of what is a LiteralType</a>, and I saw that:</p>\n<blockquote>\n<p id=\"so_41397232_41397232_1\">A literal type is any of the following:</p>\n<ul>\n<li>possibly cv-qualified class type that has all of the following properties:\n  \n  <ul>\n<li>has a trivial destructor,</li>\n<li>is either</li>\n<li>an aggregate type,</li>\n<li>a type with at least one constexpr (possibly template) constructor that is not a copy or move constructor,</li>\n<li>a closure type (since C++17)</li>\n</ul></li>\n<li>all non-static data members and base classes are of non-volatile literal types.</li>\n</ul>\n</blockquote>\n<p>Is it the case that <code>Literal</code> does not conform to a <code>LiteralType</code>? As I see it, it has a trivial constructor, and even has no internal state to avoid any troublesome issue with aggregate types or non-static fields on a literal type.</p>\n<p>But considering it does conform (primarily because the program compiled without errors), why the link-time error? Is that a G++ bug, perhaps?</p>\n", "Tags": "<c++><c++11>", "Score": "1", "AnswerCount": "1"}, "41397335": {"ParentId": "41397232", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Well, apparently I need to add a <strong>definition</strong> outside the class.</p>\n<p>Working example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Literal {\n    constexpr Literal() = default;\n    constexpr operator int() const { return 0; }\n};\n\nstruct Class {\n    constexpr static const Literal field0 = Literal();\n};\n\n// This is needed to avoid undefined reference errors\n// This is a definition. Very strange.\nconstexpr const Literal Class::field0;\n\nint main(void) {\n    std::cout &lt;&lt; \"Class::field0: \" &lt;&lt; Class::field0 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Source: <a href=\"https://stackoverflow.com/a/8016853/3962396\">https://stackoverflow.com/a/8016853/3962396</a></p>\n", "OwnerUserId": "3962396", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:35.843", "Id": "41397335", "Score": "0", "CreationDate": "2016-12-30T13:47:42.777", "LastActivityDate": "2016-12-30T13:53:01.070"}, "bq_ids": {"n4659": {"so_41397232_41397232_0": {"section_id": 8540, "quality": 0.5294117647058824, "length": 9}}}});