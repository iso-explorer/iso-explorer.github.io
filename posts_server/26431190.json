post_cb({"26431541": {"ParentId": "26431190", "CommentCount": "2", "Body": "<p>As per C++11 3.3.10/1:</p>\n<blockquote>\n<p id=\"so_26431190_26431541_0\">A name can be hidden by an explicit declaration of that same name in a <strong>nested declarative region</strong> or derived\n  class.</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>That's why the template name <code>Foo</code> can be hidden by the typedef name <code>Foo</code> inside <code>main()</code> (a different scope), but not in the same scope as the template name is declared.</p>\n<p>As to why this similar case is legal:</p>\n<pre><code>struct Foo\n{\n};\n\ntypedef Foo Foo;   // *DOES* compile\n</code></pre>\n<p>That is explicitly allowed by 7.1.3/3:</p>\n<blockquote>\n<p id=\"so_26431190_26431541_1\">In a given non-class scope, a <code>typedef</code> specifier can be used to redefine the name of any type declared in that\n  scope to refer to the type to which it already refers.</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "26431541", "Score": "17", "CreationDate": "2014-10-17T18:51:22.863", "LastActivityDate": "2014-10-17T18:51:22.863"}, "26431190": {"CommentCount": "2", "ViewCount": "447", "PostTypeId": "1", "LastEditorUserId": "181783", "CreationDate": "2014-10-17T18:25:28.220", "LastActivityDate": "2014-10-17T18:51:22.863", "Title": "typedef Foo<> Foo compiles but is it valid?", "AcceptedAnswerId": "26431541", "LastEditDate": "2014-10-17T18:32:14.970", "Id": "26431190", "Score": "15", "Body": "<p>The following bit of code compiles in VS2008 and GCC 4.8.2</p>\n<pre><code>template&lt;typename T=void&gt;\nstruct Foo\n{\n};\n\n// typedef Foo&lt;&gt; Foo;   // Does *NOT* compile\n\nint main()\n{\n    typedef Foo&lt;&gt; Foo;\n    Foo f1;\n\n   // Foo&lt;char&gt; f2;     // Does *NOT* compile\n   //::Foo&lt;char&gt; f3;    // COMPILES\n}\n</code></pre>\n<p>Is it valid?</p>\n", "Tags": "<c++><templates><typedef>", "OwnerUserId": "181783", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26431190_26431541_0": {"section_id": 7078, "quality": 1.0, "length": 12}, "so_26431190_26431541_1": {"section_id": 5409, "quality": 1.0, "length": 15}}, "n3337": {"so_26431190_26431541_0": {"section_id": 6822, "quality": 1.0, "length": 12}, "so_26431190_26431541_1": {"section_id": 5204, "quality": 1.0, "length": 15}}, "n4659": {"so_26431190_26431541_0": {"section_id": 8579, "quality": 1.0, "length": 12}, "so_26431190_26431541_1": {"section_id": 6831, "quality": 1.0, "length": 15}}}, "26431277": {"ParentId": "26431190", "CommentCount": "5", "Body": "<p>Yes it's valid, for the same reason that this is valid:</p>\n<pre><code>struct Foo { };\n\nnamespace bar {\n    struct Foo { };\n}\n</code></pre>\n<p>You're just overwriting the name in a different scope. Inside of main, you can still do something like:</p>\n<pre><code>::Foo&lt;int&gt; f2;\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "26431277", "Score": "11", "CreationDate": "2014-10-17T18:31:54.923", "LastActivityDate": "2014-10-17T18:31:54.923"}});