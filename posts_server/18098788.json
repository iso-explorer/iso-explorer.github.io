post_cb({"18099299": {"ParentId": "18098788", "CommentCount": "1", "Body": "<p>Consider the following minimal example:</p>\n<pre><code>struct Base {};\n\nstruct Derived {};\n\nint main()\n{\n    Derived** ppD;\n    Base** ppB = ppD; // (A)\n}\n</code></pre>\n<p>This code does <em>not</em> compile, because there's no implicit conversion in the line (A) to convert from <code>Derived**</code> to <code>Base**</code>. [conv.ptr]/3</p>\n<blockquote>\n<p id=\"so_18098788_18099299_0\">A prvalue of type \u201cpointer to <em>cv</em> <code>D</code>\u201d, where <code>D</code> is a class type, can be converted to a prvalue of type \u201cpointer to <em>cv</em> <code>B</code>\u201d, where <code>B</code> is a base class of <code>D</code>. If <code>B</code> is an inaccessible or ambiguous base class of <code>D</code>, a program that necessitates this conversion is ill-formed.</p>\n</blockquote>\n<p>This means that the conversion <code>Base* pB = *ppD;</code> is well-formed, but there's no implicit conversion for the case in line (A). Problems could occur if it was legal for example for multiple inheritance, virtual inheritance, or any other situation where the address of a pointer to an object of <code>Derived</code> has to be adjusted to get a pointer to the subobject of type <code>Base</code>.</p>\n<p>Also consider the following scenario:</p>\n<pre><code>void f(Base** p)\n{\n    delete *p;\n    *p = new Base;\n}\n\nint main()\n{\n    Derived* pDerived = new Derived;\n    f(&amp;p); // imagine this was allowed\n    // pDerived now points to an object of type Base!\n}\n</code></pre>\n", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "18099299", "Score": "1", "CreationDate": "2013-08-07T09:12:42.623", "LastActivityDate": "2013-08-07T09:12:42.623"}, "18098788": {"CommentCount": "7", "ViewCount": "2809", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-08-07T08:48:21.230", "LastActivityDate": "2013-08-07T09:15:00.067", "Title": "Pass a pointer to a derived class pointer as a parameter to a constructor expecting a pointer to a base class pointer", "AcceptedAnswerId": "18099299", "LastEditDate": "2017-05-23T11:55:07.183", "Id": "18098788", "Score": "0", "Body": "<p>I've read</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/14280698/passing-pointer-to-derived-class-to-function-that-expects-pointer-to-base-class\">Passing pointer to derived class, to function that expects pointer to base class?</a></li>\n</ul>\n<p>but the answer doesn't seem applicable to my issue.</p>\n<p>I checked <a href=\"http://ideone.com/oYn75X\" rel=\"nofollow noreferrer\">via Ideone</a> that the following compiles, as it should:</p>\n<pre><code>class Base\n{\npublic:\n    Base() {}\n    virtual ~Base() {}\n};\n\nclass Derived : public Base\n{\npublic:\n    Derived() {}\n    virtual ~Derived() {}\n};\n\nclass Manager\n{\npublic:\n    Manager(Base* b) {}\n    ~Manager() {}\nprivate:\n    Manager() {}\n};\n\nint main()\n{\n    Derived* d = new Derived;\n    Manager* m = new Manager(d);\n    return 0;\n}\n</code></pre>\n<p>However, what I <em>believe</em> is the same scenario in my actual program, produces an error (keywords have been replaced of course):</p>\n<pre><code>\"main.cc\", line 551: Error: Could not find a match for Manager::Manager(Derived*) needed in main().\n</code></pre>\n<p>I realize that posting explicit code would help, but the complexity of the code (not written by me, involving countless layers of inheritance, tens of includes per file, friend classes everywhere, extern'ed variables, etc.) is mind-numbing, and I'm not even sure what to reduce (what is relevant and what is not) to obtain something reasonable to post here.</p>\n<p>I have one hint that may help. I found that casting to the base class beforehand works:</p>\n<pre><code>Manager* m = new Manager((Base*)d);\n</code></pre>\n<p>Of course, I shouldn't have to do that. But the fact that that works tells me that I haven't made some trivial mistake like forgetting a <code>*</code> in the constructor's signature.</p>\n<p><strong>Can anyone think of some possible reasons I could be getting the error that I'm getting, but not when I explicitly cast the derived instance to the base class?</strong></p>\n<p>I'm using Sun Studio 12 Update 1.</p>\n<hr>\n<h2>Additional Details</h2>\n<p>I don't know why this would matter, but in my real application I'm working with pointer pointers, <em>e.g.</em></p>\n<pre><code>...\n\nclass Manager\n{\npublic:\n    Manager(Base** b) {}\n    ~Manager() {}\nprivate:\n    Manager() {}\n};\n\n...\n\n    Derived* d = new Derived;\n    Derived** d_ptr = &amp;d;\n    Manager* m = new Manager(&amp;d_ptr);\n</code></pre>\n<p>So, to reiterate, the above works when I do the following.</p>\n<pre><code>    Manager* m = new Manager((Base**)(&amp;d));\n</code></pre>\n</hr>", "Tags": "<c++><inheritance><constructor><polymorphism>", "OwnerUserId": "925913", "AnswerCount": "4"}, "18099181": {"ParentId": "18098788", "CommentCount": "1", "Body": "<p>Implicit conversion from pointer-to-derived to pointer-to-base does not extend to pointer-to-pointer-to-derived. You would get the same error if you tried this:</p>\n<pre><code>struct Base{};\nstruct Derived: Base {};\n\nvoid f(Base **p){}\n\nint main()\n{\n    Derived *dp = 0;\n    f( &amp;dp);\n}\n</code></pre>\n", "OwnerUserId": "1150249", "PostTypeId": "2", "Id": "18099181", "Score": "1", "CreationDate": "2013-08-07T09:07:42.167", "LastActivityDate": "2013-08-07T09:07:42.167"}, "18099358": {"ParentId": "18098788", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The following code will compile and work as the 'Derived' class is derived from the 'Base' class.</p>\n<pre><code>class Base\n{\npublic:\n    Base() {}\n    virtual ~Base() {}\n};\n\nclass Derived : public Base\n{\npublic:\n    Derived() {}\n    virtual ~Derived() {}\n};\n\nclass Manager\n{\npublic:\n    Manager(Base* b) {}\n    ~Manager() {}\nprivate:\n    Manager() {}\n};\n\nint main()\n{\n    Derived* d = new Derived;\n    Manager* m = new Manager(d);\n    return 0;\n}\n</code></pre>\n<p>However, a pointer to a pointer to a 'Derived' class is not the same as (nor derived from) a pointer to a pointer to a 'Base' class.</p>\n<p>For a great explanation involving bowls of bananas and apples, look here:\n<a href=\"https://stackoverflow.com/questions/8026040/conversion-from-derived-to-base\">Conversion from Derived** to Base**</a></p>\n<p>HTH.</p>\n", "OwnerUserId": "2591187", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:31:14.630", "Id": "18099358", "Score": "1", "CreationDate": "2013-08-07T09:15:00.067", "LastActivityDate": "2013-08-07T09:15:00.067"}, "18099138": {"ParentId": "18098788", "CommentCount": "1", "Body": "<p>Do either</p>\n<pre><code>Derived* d = new Derived;\nDerived** d_ptr = &amp;d;\nManager* m = new Manager(*d_ptr);\n</code></pre>\n<p>or</p>\n<pre><code>Derived* d = new Derived;\nDerived** d_ptr = &amp;d;  // not needed ?\nManager* m = new Manager(d);\n</code></pre>\n", "OwnerUserId": "2656151", "PostTypeId": "2", "Id": "18099138", "Score": "0", "CreationDate": "2013-08-07T09:05:18.557", "LastActivityDate": "2013-08-07T09:05:18.557"}, "bq_ids": {"n4140": {"so_18098788_18099299_0": {"section_id": 41, "quality": 1.0, "length": 21}}, "n3337": {"so_18098788_18099299_0": {"section_id": 38, "quality": 1.0, "length": 21}}, "n4659": {"so_18098788_18099299_0": {"section_id": 41, "quality": 1.0, "length": 21}}}});