post_cb({"bq_ids": {"n4140": {"so_32889492_32892157_3": {"length": 16, "quality": 1.0, "section_id": 5457}, "so_32889492_32892157_0": {"length": 39, "quality": 0.8297872340425532, "section_id": 5446}, "so_32889492_32890958_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5457}, "so_32889492_32892157_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5455}}, "n4659": {"so_32889492_32892157_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 6873}, "so_32889492_32892157_3": {"length": 16, "quality": 1.0, "section_id": 6883}, "so_32889492_32890958_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6883}, "so_32889492_32892157_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 6881}}}, "32889492": {"ViewCount": "349", "LastEditDate": "2015-10-01T14:02:41.530", "AcceptedAnswerId": "32892157", "Title": "Friend function template with automatic return type deduction cannot access a private member", "CreationDate": "2015-10-01T13:57:47.813", "LastActivityDate": "2015-10-01T16:08:59.017", "CommentCount": "5", "Body": "<p><em>Sorry for how complicated the title of this question is; I tried to describe the minimal SSCCE I constructed for this problem.</em></p>\n<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace fizz\n{\n    template&lt;typename... Ts&gt;\n    class bar\n    {\n    public:\n        template&lt;int I, typename... Us&gt;\n        friend auto foo(const bar&lt;Us...&gt; &amp;);\n\n    private:\n        int i = 123;\n    };\n\n    template&lt;int I, typename... Ts&gt;\n    auto foo(const bar&lt;Ts...&gt; &amp; b)\n    {\n        return b.i;\n    }\n}\n\nint main()\n{\n    std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{});\n}\n</code></pre>\n<p>This code <a href=\"http://coliru.stacked-crooked.com/a/7d45c79e8f9ba902\" rel=\"noreferrer\">compiles with GCC 5.2</a> and <a href=\"http://coliru.stacked-crooked.com/a/b9735ebd213a4840\" rel=\"noreferrer\">doesn't with Clang 3.7</a>:</p>\n<pre><code>main.cpp:19:18: error: 'i' is a private member of 'fizz::bar&lt;int, float&gt;'\n        return b.i;\n                 ^\nmain.cpp:25:24: note: in instantiation of function template specialization 'fizz::foo&lt;1, int, float&gt;' requested here\n    std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{});\n                       ^\nmain.cpp:13:13: note: declared private here\n        int i = 123;\n            ^\n</code></pre>\n<p>However, if you change the code slightly (although in a way that is not exactly useful for me, since in the real code this would introduce tons of boilerplate):</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace fizz\n{\n    template&lt;typename... Ts&gt;\n    class bar\n    {\n    public:\n        template&lt;int I, typename... Us&gt;\n        friend int foo(const bar&lt;Us...&gt; &amp;);\n\n    private:\n        int i = 123;\n    };\n\n    template&lt;int I, typename... Ts&gt;\n    int foo(const bar&lt;Ts...&gt; &amp; b)\n    {\n        return b.i;\n    }\n}\n\nint main()\n{\n    std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{});\n}\n</code></pre>\n<p>it suddenly <a href=\"http://coliru.stacked-crooked.com/a/2f2b259d0fc6d494\" rel=\"noreferrer\">works with that Clang 3.7</a>.</p>\n<p>The difference is that in the version of the code that doesn't compile with Clang, the friend function template uses C++14 <code>auto</code> return type deduction, while the working one plainly says it returns <code>int</code>. The same problem also happens with other variants of <code>auto</code> return type deduction, like <code>auto &amp;&amp;</code> or <code>const auto &amp;</code>.</p>\n<p>Which compiler is right? Please provide some standard quotes to support the answer, since it is quite possible that a bug will need to be filed for one (...hopefully not both) compilers... or a standard defect, if both are right (which wouldn't be the first time).</p>\n", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "32889492", "AnswerCount": "2", "Score": "24", "OwnerUserId": "809387", "Tags": "<c++><templates><language-lawyer><c++14><friend>", "FavoriteCount": "0"}, "32890958": {"Id": "32890958", "PostTypeId": "2", "LastEditDate": "2015-10-01T15:44:11.890", "CommentCount": "0", "LastEditorUserId": "951890", "LastActivityDate": "2015-10-01T15:44:11.890", "CreationDate": "2015-10-01T15:07:54.397", "ParentId": "32889492", "Score": "0", "Body": "<p>It appears that your first example should work.  There is a statement in C++14 (7.1.6.4 p12):</p>\n<blockquote>\n<p id=\"so_32889492_32890958_0\">Redeclarations or specializations of a function or function template with a declared return type that uses a\n  placeholder type shall also use that placeholder, not a deduced type. [ Example:</p>\n</blockquote>\n<p>.\n.\n.</p>\n<pre><code>template &lt;typename T&gt; struct A {\n    friend T frf(T);\n};\nauto frf(int i) { return i; } // not a friend of A&lt;int&gt;\n</code></pre>\n<p>The reason for the example appears to be to explain that to make the declarations match (and cause the defined function to be a friend) the declaration of frf inside struct A would also need to use <code>auto</code>.  This implies to me that having a friend declaration with an auto return type and later defining the friend function (and also using auto) is allowed.  I can't find anything that would make this work differently for a member function template, like in your example.</p>\n", "OwnerUserId": "951890"}, "32892157": {"Id": "32892157", "PostTypeId": "2", "Body": "<p>I believe it's a clang bug. I want to approach it from this direction. What wrinkles does the <code>auto</code> placeholder type add, as compared to having a specified return type? From [dcl.spec.auto]:</p>\n<blockquote>\n<p id=\"so_32889492_32892157_0\">The placeholder type can appear with a function declarator in the <em>decl-specifier-seq</em>, <em>type-specifier-seq</em>, <em>conversion-function-id</em>, or <em>trailing-return-type</em>, in any context where such a declarator is valid. If the function declarator includes a <em>trailing-return-type</em> (8.3.5), that <em>trailing-return-type</em> specifies the declared return type\n  of the function. Otherwise, the function declarator shall declare a function. If the declared return type of\n  the function contains a placeholder type, the return type of the function is deduced from return statements\n  in the body of the function, if any.</p>\n</blockquote>\n<p><code>auto</code> can appear in <code>foo</code>'s declaration and definition, and is valid.</p>\n<blockquote>\n<p id=\"so_32889492_32892157_1\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression,\n  the program is ill-formed. Once a <code>return</code> statement has been seen in a function, however, the return type\n  deduced from that statement can be used in the rest of the function, including in other return statements. <em>[ Example:</em></p>\n<pre><code>auto n = n;              // error, n\u2019s type is unknown\nauto f();\nvoid g() { &amp;f; }         // error, f\u2019s return type is unknown\nauto sum(int i) {\n  if (i == 1)\n    return i;            // sum\u2019s return type is int\n  else\n    return sum(i-1)+i;   // OK, sum\u2019s return type has been deduced\n}\n</code></pre>\n<p id=\"so_32889492_32892157_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The first time we need to use determine the type of an expression, the return type of the function will already have been deduced from the <code>return</code> in the definition of <code>foo()</code>, so this is still valid.</p>\n<blockquote>\n<p id=\"so_32889492_32892157_3\">Redeclarations or specializations of a function or function template with a declared return type that uses a\n  placeholder type shall also use that placeholder, not a deduced type.</p>\n</blockquote>\n<p>We're using <code>auto</code> in both places, so we don't violate this rule either.</p>\n<hr/>\n<p>In short, there are several things that differentiate a specific return type from an placeholder return type from a function declaration. But all the usages of <code>auto</code> in the example are correct, so the namespace-scope <code>foo</code> should be seen as a redeclaration and definition of the first-declared <code>friend auto foo</code> within class template <code>bar</code>. The fact that clang accepts the former as a redeclaration for return type <code>int</code> but not for <code>auto</code>, and there is no relevant different for <code>auto</code>, definitely suggests this is a bug.</p>\n<p>Further, if you drop the <code>int I</code> template parameter so that you can call <code>foo</code> unqualified, clang will report the call as ambiguous:</p>\n<pre><code>std::cout &lt;&lt; foo(fizz::bar&lt;int, float&gt;{});\n\nmain.cpp:26:18: error: call to 'foo' is ambiguous\n    std::cout &lt;&lt; foo(fizz::bar&lt;int, float&gt;{});\n                 ^~~\nmain.cpp:10:21: note: candidate function [with Us = &lt;int, float&gt;]\n        friend auto foo(const bar&lt;Us...&gt; &amp;);\n                    ^\nmain.cpp:17:10: note: candidate function [with Ts = &lt;int, float&gt;]\n    auto foo(const bar&lt;Ts...&gt;&amp; b)\n         ^\n</code></pre>\n<p>So we have <em>two</em> function templates named <code>foo</code> in the same namespace (since from [namespace.memdef] the <code>friend</code> declaration for <code>foo</code> will place it in the nearest enclosing namespace) that take the same arguments and have the same return type (<code>auto</code>)? That shouldn't be possible. </p>\n", "Score": "6", "LastActivityDate": "2015-10-01T16:08:59.017", "CreationDate": "2015-10-01T16:08:59.017", "ParentId": "32889492", "CommentCount": "5", "OwnerUserId": "2069064"}});