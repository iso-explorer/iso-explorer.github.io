post_cb({"14509291": {"CommentCount": "2", "ViewCount": "2033", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-01-24T19:35:43.007", "LastActivityDate": "2013-01-24T20:46:05.007", "Title": "std::bind()-ing a base protected member function from a derived class's member function", "AcceptedAnswerId": "14509612", "LastEditDate": "2013-01-24T19:47:49.070", "Id": "14509291", "Score": "10", "Body": "<p>I want to <code>bind()</code> to my base class's version of a function from the derived class. The function is marked protected in the base. When I do so, the code compiles happily in Clang (Apple LLVM Compiler 4.1) but gives an error in both g++ 4.7.2 and in Visual Studio 2010. The error is along the lines of: \"'Base::foo' : cannot access protected member.\"</p>\n<p>The implication is that the context for the reference is actually within <code>bind()</code>, where of course the function is seen as protected. But shouldn't <code>bind()</code> inherit the context of the calling function--in this case, <code>Derived::foo()</code>--and therefore see the base method as accessible?</p>\n<p>The following program illustrates the issue.</p>\n<pre><code>struct Base\n{\nprotected: virtual void foo() {}\n};\n\nstruct Derived : public Base\n{\nprotected:\n    virtual void foo() override\n    {\n        Base::foo();                        // Legal\n\n        auto fn = std::bind( &amp;Derived::foo, \n            std::placeholders::_1 );        // Legal but unwanted.\n        fn( this );\n\n        auto fn2 = std::bind( &amp;Base::foo, \n            std::placeholders::_1 );        // ILLEGAL in G++ 4.7.2 and VS2010.\n        fn2( this );\n    }\n};\n</code></pre>\n<p>Why the discrepancy in behavior? Which is correct? What workaround is available for the error-giving compilers?</p>\n", "Tags": "<c++><c++11><protected><derived-class><stdbind>", "OwnerUserId": "358475", "AnswerCount": "2"}, "14510123": {"ParentId": "14509291", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This has nothing to do with <code>bind</code>.  Because of the piece of the Standard @rhalbersma already quoted, the expression <code>&amp;Base::foo</code> is illegal in a non-friended member of <code>Derived</code>, in every context.</p>\n<p>But if your intent was to do something equivalent to calling <code>Base::foo();</code>, you have a bigger issue: pointers to member functions <em>always</em> invoke a virtual override.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B {\npublic:\n    virtual void f() { std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl; }\n};\n\nclass D : public B {\npublic:\n    virtual void f() { std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl; }\n};\n\nint main() {\n    D d;\n    d.B::f();   // Prints B::f\n\n    void (B::*ptr)() = &amp;B::f;\n    (d.*ptr)(); // Prints D::f!\n}\n</code></pre>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2013-01-24T20:46:05.007", "Id": "14510123", "Score": "9", "CreationDate": "2013-01-24T20:27:34.810", "LastActivityDate": "2013-01-24T20:46:05.007"}, "bq_ids": {"n4140": {"so_14509291_14509612_0": {"section_id": 6695, "quality": 0.9152542372881356, "length": 54}}, "n3337": {"so_14509291_14509612_0": {"section_id": 6450, "quality": 0.9152542372881356, "length": 54}}, "n4659": {"so_14509291_14509612_0": {"section_id": 8170, "quality": 0.9152542372881356, "length": 54}}}, "14509612": {"ParentId": "14509291", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Answer: see <a href=\"https://stackoverflow.com/q/3057789/819272\">boost::bind with protected members &amp; context</a> which quotes this part of the Standard</p>\n<blockquote>\n<p id=\"so_14509291_14509612_0\">An additional access check beyond those described earlier in clause 11\n  is applied when a non-static data member or nonstatic member function\n  is a protected member of its naming class (11.2)105) As described\n  earlier, access to a protected member is granted because the reference\n  occurs in a friend or member of some class C. If the access is to form\n  a pointer to member (5.3.1), the nested-name-specifier shall name C or\n  a class derived from C. All other accesses involve a (possibly\n  implicit) object expression (5.2.5). In this case, the class of the\n  object expression shall be C or a class derived from C. </p>\n</blockquote>\n<p>Workaround: make <code>foo</code> a <code>public</code> member function</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct Base\n{\npublic: virtual void foo() {}\n};\n</code></pre>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:32.147", "Id": "14509612", "Score": "9", "CreationDate": "2013-01-24T19:55:08.347", "LastActivityDate": "2013-01-24T20:00:26.977"}});