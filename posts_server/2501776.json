post_cb({"2501810": {"ParentId": "2501776", "CommentCount": "1", "Body": "<p>It is necessarily treated by the compiler as a request for inline -- which it can ignore. There are some idioms for defining some functions in the header (e.g. empty virtual destructors) and some necessary header definitions (template functions), but other than that see <a href=\"http://www.gotw.ca/gotw/033.htm\" rel=\"nofollow noreferrer\">GotW #33</a> for more information.</p>\n<p>Some have noted that the compiler may even inline functions you never asked it to, but I'm not sure whether that would defeat the purpose of requesting to inline a function.</p>\n", "OwnerUserId": "456", "PostTypeId": "2", "Id": "2501810", "Score": "3", "CreationDate": "2010-03-23T16:42:32.213", "LastActivityDate": "2010-03-23T16:42:32.213"}, "2501783": {"ParentId": "2501776", "CommentCount": "0", "Body": "<p>Yes, functions that are defined inside a class body are implicitly <code>inline</code>.</p>\n<p>(As with other functions declared <code>inline</code> it doesn't mean that the complier has to perform inline expansion in places where the function is called, it just enables the permitted relaxations of the \"one definition rule\", combined with the requirement that a definition must be included in all translation units where the function is used.)</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "2501783", "Score": "18", "CreationDate": "2010-03-23T16:38:12.097", "LastActivityDate": "2010-03-23T16:38:12.097"}, "2502358": {"ParentId": "2501776", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>As stated by others, a method defined within a class is automatically requested inline.\nIt's useful to understand why.</p>\n<p>Suppose it weren't.  You'd have to generate code for such a function, and everywhere it is called, a jump to subroutine instruction would have to reference the location, via the linker.</p>\n<pre><code>class A {\npublic:\n  void f() { ... your code ... }\n};\n</code></pre>\n<p>Every time this code is seen, if it's not inline, the compiler can only assume it must be generated, so it would generate a symbol.  Suppose it was like this:</p>\n<p>A__f_v:</p>\n<p>If that symbol were global, then if you happened to include this class code multiple times in different modules, you would have a multiply defined symbol error at link time.  So it can't be global.  Instead, it's file local.</p>\n<p>Imagine you include the above header file in a number of modules.  In each one, it's going to generate a local copy of that code.  Which is better than not compiling at all, but you're getting multiple copies of the code when you really need only one.</p>\n<p>This leads the the following conclusion: if your compiler is not going to inline a function, you are significantly better off declaring it somewhere once, and not requesting it to be inlined.</p>\n<p>Unfortunately, what is and is not inline is not portable.  It's defined by the compiler writer.  A good rule of thumb is to always make every one liner, particularly all functions which themselves just call a function, inline, as you remove overhead.  Anything below three lines of linear code is almost certainly ok.  But if you have a loop in the code, the question is whether the compiler will allow it inline, and more to the point, how much benefit you would see even if it did what you want.</p>\n<p>consider this inline code:</p>\n<pre><code>inline int add(int a, int b) { return a + b; }\n</code></pre>\n<p>It's not only almost as small as the prototype would be in source code, but the assembly language generated by the inline code is smaller than the call to a routine would be.  So this code is smaller, and faster.</p>\n<p>And, if you happen to be passing in constants:</p>\n<pre><code>int c= add(5,4);\n</code></pre>\n<p>It's resolved at compile time and there is no code.</p>\n<p>In gcc, I recently noticed that even if I don't inline code, if it's local to a file, they will sneakily inline it anyway.  It's only if I declare the function in a separate source module that they do not optimize away the call.</p>\n<p>On the other end of the spectrum, suppose you request inline on a 1000 line piece of code.  Even if your compiler is silly enough to go along with it, the only thing you save is the call itself, and the cost is that every time you call it, the compiler must paste all that code in.  If you call that code n times, your code grows by the size of the routine * n.  So anything bigger than 10 lines is pretty much not worth inlining, except for the special case where it is only called a very small number of times.  An example of that might be in a private method called by only 2 others.</p>\n<p>If you request to inline a method containing a loop, it only makes sense if it often executes a small number of times. But consider a loop which iterates one million times.  Even if the code is inlined, the percentage of time spent in the call is tiny.  So if you have methods with loops in it, which tend to be bigger anyway, those are worth removing from the header file because they a) will tend to be rejected as inline by the compiler and b) even if they were inlined, are generally not going to provide any benefit</p>\n", "OwnerUserId": "233928", "LastEditorUserId": "233928", "LastEditDate": "2011-08-14T16:00:48.300", "Id": "2502358", "Score": "4", "CreationDate": "2010-03-23T17:58:06.640", "LastActivityDate": "2011-08-14T16:00:48.300"}, "2501876": {"ParentId": "2501776", "CommentCount": "0", "Body": "<p>There are two things that shouldn't be lumped together:</p>\n<ol>\n<li>How you mark a function as being inline: define it with inline in front of the signature or define it at declaration point;</li>\n<li>What the compiler will treat such inline marking: regardless of how you marked the function as inline it will be treated as a request by the compiler.</li>\n</ol>\n", "OwnerUserId": "153861", "PostTypeId": "2", "Id": "2501876", "Score": "1", "CreationDate": "2010-03-23T16:52:26.573", "LastActivityDate": "2010-03-23T16:52:26.573"}, "2501776": {"CommentCount": "1", "AcceptedAnswerId": "2501783", "CreationDate": "2010-03-23T16:36:09.327", "LastActivityDate": "2011-08-14T16:00:48.300", "PostTypeId": "1", "ViewCount": "866", "FavoriteCount": "1", "Title": "Inline functions in C++", "Id": "2501776", "Score": "18", "Body": "<p>If we define a member function inside the class definition itself, is it necessarily treated inline or is it just a request to the compiler which it can ignore.</p>\n", "Tags": "<c++><inline-functions>", "OwnerUserId": "265260", "AnswerCount": "7"}, "2501826": {"ParentId": "2501776", "CommentCount": "0", "Body": "<p>It is indeed inlined - but any inline request can be ignored by the compiler.</p>\n", "OwnerUserId": "223046", "PostTypeId": "2", "Id": "2501826", "Score": "3", "CreationDate": "2010-03-23T16:45:12.720", "LastActivityDate": "2010-03-23T16:45:12.720"}, "2501780": {"ParentId": "2501776", "CommentCount": "6", "Body": "<p>It is a request to the compiler that it can ignore.</p>\n", "OwnerUserId": "133520", "PostTypeId": "2", "Id": "2501780", "Score": "2", "CreationDate": "2010-03-23T16:36:50.047", "LastActivityDate": "2010-03-23T16:36:50.047"}, "2501873": {"ParentId": "2501776", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The 2003 ISO C++ standard says</p>\n<blockquote>\n<p id=\"so_2501776_2501873_0\">7.1.2/2   A function declaration (8.3.5, 9.3, 11.4) with an inline\n  specifier   declares an inline\n  function. The inline specifier\n  indicates to the   implementation that\n  inline substitution of the function\n  body at the   point of call is to be\n  preferred to the usual function call<br>\n  mechanism. An implementation is not\n  required to perform this inline<br>\n  substitution at the point of call;\n  however, even if this inline<br>\n  substitution is omitted, the other\n  rules for inline functions   defined\n  by 7.1.2 shall still be respected. </br></br></br></p>\n<p id=\"so_2501776_2501873_1\">7.1.2/3   A function defined within a class definition is an inline<br>\n  function. The inline specifier shall\n  not appear on a block scope   function\n  declaration.</br></p>\n<p id=\"so_2501776_2501873_2\">7.1.2/4   An inline function shall be defined in every translation unit in<br>\n  which it is used and shall have\n  exactly the same definition in every<br>\n  case (3.2). [Note: a call to the\n  inline function may be encountered<br>\n  before its defi-nition appears in the\n  translation unit. ] If a   function\n  with external linkage is declared\n  inline in one   transla-tion unit, it\n  shall be declared inline in all\n  translation   units in which it\n  appears; no diagnostic is required. An\n  inline   function with external\n  linkage shall have the same address in\n  all   translation units. A static\n  local variable in an extern inline<br>\n  function always refers to the same\n  object. A string literal in an<br>\n  extern inline function is the same\n  object in different translation<br>\n  units.</br></br></br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "254628", "LastEditorUserId": "254628", "LastEditDate": "2010-03-23T17:00:15.260", "Id": "2501873", "Score": "2", "CreationDate": "2010-03-23T16:51:34.827", "LastActivityDate": "2010-03-23T17:00:15.260"}, "bq_ids": {"n4140": {"so_2501776_2501873_0": {"section_id": 5402, "quality": 0.8695652173913043, "length": 40}, "so_2501776_2501873_2": {"section_id": 5404, "quality": 0.971830985915493, "length": 69}, "so_2501776_2501873_1": {"section_id": 5403, "quality": 0.875, "length": 14}}, "n3337": {"so_2501776_2501873_0": {"section_id": 5197, "quality": 0.8695652173913043, "length": 40}, "so_2501776_2501873_2": {"section_id": 5199, "quality": 0.971830985915493, "length": 69}, "so_2501776_2501873_1": {"section_id": 5198, "quality": 0.875, "length": 14}}, "n4659": {"so_2501776_2501873_2": {"section_id": 6853, "quality": 0.8732394366197183, "length": 62}, "so_2501776_2501873_0": {"section_id": 6849, "quality": 0.8478260869565217, "length": 39}}}});