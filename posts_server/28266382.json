post_cb({"28266883": {"Id": "28266883", "PostTypeId": "2", "Body": "<p>The things are a bit different for <code>std::vector</code> and <code>std::deque</code>, as well as they are different for C++98 and C++11.</p>\n<h3>std::vector</h3>\n<p>The complexity of <code>std::vector::erase()</code> is linear both to the length of the range erased and to the number of elements between the end of the range and the end of the container (so erasing an element from the end takes constant time).</p>\n<p>C++2003 <code>[lib.vector.modifiers]</code> reads:</p>\n<pre><code>iterator erase(iterator position);\niterator erase(iterator first, iterator last);`\n</code></pre>\n<blockquote>\n<p id=\"so_28266382_28266883_0\">...</p>\n<p id=\"so_28266382_28266883_1\"><em>Complexity:</em> The destructor of <code>T</code> is called the number of times equal to the number of the elements erased,\n  but the <strong>assignment operator</strong> of <code>T</code> is called the number of times equal to the number of elements in the vector after the erased elements.</p>\n</blockquote>\n<p>C++14 draft N4140 <code>[vector.modifiers]</code> reads:</p>\n<blockquote>\n<p id=\"so_28266382_28266883_2\"><em>Complexity:</em> The destructor of <code>T</code> is called the number of times equal to the number of the elements\n  erased, but the <strong>move assignment operator</strong> of <code>T</code> is called the number of times equal to the number of\n  elements in the vector after the erased elements.</p>\n</blockquote>\n<p>So you see that C++11/14 implementation is more efficient in general since it perform move assignment instead of copy assignment, but the complexity remains the same.</p>\n<h3>std::deque</h3>\n<p>The complexity of <code>std::deque::erase()</code> is linear both to the length of the range erased and to the <strong>minimum</strong> of two numbers: number of remaining elements before the start of the range, and number of remaining elements after the end of the range. So, erasing an element either from the beginning or from the end takes constant time.</p>\n<p>C++2003 <code>[lib.deque.modifiers]</code>:</p>\n<pre><code>iterator erase(iterator position);\niterator erase(iterator first, iterator last);\n</code></pre>\n<blockquote>\n<p id=\"so_28266382_28266883_3\"><em>Complexity:</em> The number of calls to the destructor is the same as the number of elements erased, but the\n  number of the calls to the assignment operator is <em>at most</em> equal to the minimum of the number of elements\n  before the erased elements and the number of elements after the erased elements.</p>\n</blockquote>\n<p>C++14 draft N4140 <code>[deque.modifiers]/5</code>:</p>\n<blockquote>\n<p id=\"so_28266382_28266883_4\"><em>Complexity:</em> The number of calls to the destructor is the same as the number of elements erased, but the number of calls to the assignment operator is <em>no more</em> than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</p>\n</blockquote>\n<p>So, it's the same in C++98 and C++11/14, again except that C++11 can choose between move assignment and copy assignment (here I see some inconsistency in the standard because the wording doesn't mention move assignment like for <code>std::vector</code> - might be a reason for another question).</p>\n<p>Note also the \"at most\" and \"no more\" in the wordings. This allows for implementations to be more efficient than linear, though in practice they are linear (<a href=\"http://coliru.stacked-crooked.com/a/b24f47317e782232\" rel=\"noreferrer\">DEMO</a>).</p>\n", "LastActivityDate": "2015-02-01T19:32:59.877", "CommentCount": "0", "CreationDate": "2015-02-01T19:32:59.877", "ParentId": "28266382", "Score": "5", "OwnerUserId": "3959454"}, "bq_ids": {"n4140": {"so_28266382_28266883_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 989}, "so_28266382_28266883_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 821}, "so_28266382_28266883_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 989}, "so_28266382_28266883_4": {"length": 25, "quality": 0.9259259259259259, "section_id": 821}}, "n3337": {"so_28266382_28266883_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 974}, "so_28266382_28266883_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 810}, "so_28266382_28266883_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 974}, "so_28266382_28266883_4": {"length": 25, "quality": 0.9259259259259259, "section_id": 810}}, "n4659": {"so_28266382_28266883_2": {"length": 21, "quality": 0.875, "section_id": 1052}, "so_28266382_28266883_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 880}, "so_28266382_28266883_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 1052}, "so_28266382_28266883_4": {"length": 25, "quality": 0.9259259259259259, "section_id": 880}}}, "28266444": {"Id": "28266444", "PostTypeId": "2", "Body": "<p>Erasing an element in a vector is O(n) since once you remove the element you still need to shift all successive elements to fill the gap created. If a vector has n elements, then at the worst case you will need to shift n-1 elemets, hence the complexity is O(n).</p>\n", "LastActivityDate": "2015-02-01T18:51:54.230", "CommentCount": "0", "CreationDate": "2015-02-01T18:51:54.230", "ParentId": "28266382", "Score": "4", "OwnerUserId": "2626606"}, "28266382": {"ViewCount": "5192", "Body": "<p>I have read that time complexity of adding items to end of a <code>std::vector</code> is amortized constant and inserting items at the top and bottom of a <code>std::deque</code> is constant.Since both these containers have a random access iterator thus accessing elements at any index is constant. Please let me know if I have any of these facts wrong.My question is if accessing an element in a <code>std::vector</code> or <code>std::deque</code> is constant then why is the time complexity of removing an element via erase O(n). One of the answers <a href=\"https://stackoverflow.com/questions/181693/what-are-the-complexity-guarantees-of-the-standard-containers\">here</a> here states that removing elements via erase is O(n). I know that erase removes the elements between the starting iterators and the ending one so does the answer basically mean that its <code>O(n)</code> depending on the no of elements between the two iterators and that removing a single element from a vector/deque in any index will be zero?</p>\n", "AcceptedAnswerId": "28266883", "Title": "Time complexity of removing items in vectors and deque", "CreationDate": "2015-02-01T18:45:00.450", "Id": "28266382", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:23:26.147", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-01T19:32:59.877", "Score": "8", "OwnerUserId": "1305891", "Tags": "<c++><vector><deque><c++98>", "AnswerCount": "3"}, "28266471": {"Id": "28266471", "PostTypeId": "2", "Body": "<p>Removing elements is indeed <code>O(n)</code> not because of what you have to do to find the element to remove but because of what you have to do to all of the ones <em>after</em> it. Those elements need to be slid down to fill the empty slot.</p>\n<p>So on average, erase will take an element about halfway through the vector, so you'll have to shift about half the elements. Hence <code>O(n)</code>. Best case, you erase the last element - no sliding necessary. Worst case, you erase the first element - have to then move <em>every</em> other element.</p>\n", "LastActivityDate": "2015-02-01T18:54:36.680", "CommentCount": "1", "CreationDate": "2015-02-01T18:54:36.680", "ParentId": "28266382", "Score": "3", "OwnerUserId": "2069064"}});