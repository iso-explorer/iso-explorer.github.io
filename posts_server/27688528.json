post_cb({"27689476": {"CommentCount": "20", "CreationDate": "2014-12-29T13:03:57.697", "CommunityOwnedDate": "2014-12-29T13:48:42.957", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-29T14:04:57.243", "ParentId": "27688528", "PostTypeId": "2", "LastEditDate": "2014-12-29T14:04:57.243", "Id": "27689476", "Score": "4", "Body": "<p>According to my understanding (and the current wording of the standard), <code>C</code> in your example is not dependent. Neither is <code>A&lt;C&gt;::Type</code>, so the <code>typename</code> is not required.</p>\n<p>There is a fundamental difference between nested classes of class templates and local classes in function templates: The latter cannot be specialized, thus any reference to a local class inside a function template is uniform. That is, in every specialization of <code>f</code>, <code>C</code> refers to the class <code>C</code> that is defined in this function template <code>f</code>. That is not the case with class templates as you can indeed explicitly specialize members on their own (as covered in [temp.expl.spec]\n/(1.6)):</p>\n<pre><code>template &lt;typename T&gt;\nclass A { class C{}; };\n\ntemplate &lt;&gt;\nclass A&lt;int&gt;::C { int i; };\n</code></pre>\n<p>However:</p>\n<blockquote>\n<p id=\"so_27688528_27689476_0\">A type is dependent if it is</p>\n<ul>\n<li>a compound type constructed from any dependent type,</li>\n</ul>\n</blockquote>\n<p>So if the definition was done as in <a href=\"http://coliru.stacked-crooked.com/a/a03aebd672bfa7c7\" rel=\"nofollow\">dyp's example</a>, <code>C</code> would be dependent as it is constructed from <code>T</code>.<br>\nThere are unclarities in the standards wording that are being discussed in the comment section, e.g. about definitions of member functions that depend on <code>T</code> and how that transposes to the classes dependency.</br></p>\n", "OwnerUserId": "3647361"}, "27688962": {"ParentId": "27688528", "CommentCount": "3", "Body": "<p>Following is my reasoning, hope it helps. The local <code>C</code> does not instantiate until <code>f</code> instantiate. So, <code>A&lt;C&gt;</code> is not an instantiation and is opaque to the compiler when it sees it. Because of the opaqueness, the compiler cannot determine whether <code>A&lt;C&gt;::Type</code> is a nested type name or a data member or a method. However, by default, the compiler does not see <code>A&lt;C&gt;::Type</code> as a nested type name. Therefore, an explicit specification is needed.</p>\n", "OwnerUserId": "1348273", "PostTypeId": "2", "Id": "27688962", "Score": "0", "CreationDate": "2014-12-29T12:32:28.490", "LastActivityDate": "2014-12-29T12:32:28.490"}, "27689890": {"ParentId": "27688528", "CommentCount": "0", "Body": "<p>There doesn't appear to be anything in the standard to state that the <code>typename</code> keyword should be necessary here. The wording does not explicitly state otherwise, either, which may have led GCC to take a bit of a shortcut in treating <code>f&lt;T&gt;(T)::C</code> (being a local class in a function template specialisation) as dependent on <code>T</code> \u2014 by extension, this would make <code>A&lt;[f&lt;T&gt;(T)::]C&gt;::Type</code> dependent.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1484\" rel=\"nofollow\">Core defect 1484</a> wasn't raised for this issue specifically, but I think the additional non-normative text it proposes makes the intention clear and, were it in a standard, GCC would compliantly not require the <code>typename</code> keyword here.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "27689890", "Score": "0", "CreationDate": "2014-12-29T13:31:43.500", "LastActivityDate": "2014-12-29T13:31:43.500"}, "bq_ids": {"n4140": {"so_27688528_27688528_5": {"section_id": 198, "quality": 1.0, "length": 6}, "so_27688528_27688528_8": {"section_id": 198, "quality": 1.0, "length": 11}, "so_27688528_27688528_9": {"section_id": 198, "quality": 1.0, "length": 13}, "so_27688528_27688528_7": {"section_id": 198, "quality": 1.0, "length": 5}, "so_27688528_27688528_6": {"section_id": 198, "quality": 1.0, "length": 6}, "so_27688528_27688528_10": {"section_id": 198, "quality": 1.0, "length": 5}}, "n3337": {"so_27688528_27688528_5": {"section_id": 192, "quality": 1.0, "length": 6}, "so_27688528_27688528_8": {"section_id": 192, "quality": 1.0, "length": 11}, "so_27688528_27688528_9": {"section_id": 192, "quality": 1.0, "length": 13}, "so_27688528_27688528_7": {"section_id": 192, "quality": 1.0, "length": 5}, "so_27688528_27688528_6": {"section_id": 192, "quality": 1.0, "length": 6}, "so_27688528_27688528_10": {"section_id": 192, "quality": 1.0, "length": 5}}, "n4659": {"so_27688528_27688528_5": {"section_id": 204, "quality": 1.0, "length": 6}, "so_27688528_27688528_8": {"section_id": 204, "quality": 0.6363636363636364, "length": 7}, "so_27688528_27688528_9": {"section_id": 204, "quality": 1.0, "length": 13}, "so_27688528_27688528_7": {"section_id": 204, "quality": 1.0, "length": 5}, "so_27688528_27688528_6": {"section_id": 204, "quality": 1.0, "length": 6}, "so_27688528_27688528_10": {"section_id": 204, "quality": 1.0, "length": 5}}}, "27688528": {"CommentCount": "8", "CreationDate": "2014-12-29T12:04:41.190", "PostTypeId": "1", "AcceptedAnswerId": "27689476", "LastEditorUserId": "1690864", "LastActivityDate": "2014-12-29T17:35:17.583", "LastEditDate": "2014-12-29T17:35:17.583", "ViewCount": "166", "FavoriteCount": "2", "Title": "Is a local class dependent if declared within a function template?", "Id": "27688528", "Score": "4", "Body": "<p>Current C++ compilers (latest gcc, clang) require the <code>typename</code> keyword in the example below:</p>\n<pre><code>template&lt;class T&gt;\nstruct A\n{\n};\n\ntemplate&lt;class T&gt;\nvoid f(T)\n{\n    struct C\n    {\n    };\n    typedef typename A&lt;C&gt;::Type Type; // typename required\n}\n</code></pre>\n<p>If <code>typename</code> is omitted gcc (4.9, 5.0) reports the error:</p>\n<blockquote>\n<p id=\"so_27688528_27688528_0\"><code>need 'typename' before 'A&lt;f(T)::C&gt;::Type' because 'A&lt;f(T)::C&gt;' is a dependent scope</code></p>\n</blockquote>\n<p>This example is otherwise well-formed according to my reading of the C++11 standard.</p>\n<p>This behaviour seems to be covered by the following wording:</p>\n<blockquote>\n<p id=\"so_27688528_27688528_1\">[temp.dep.type]/8</p>\n<p id=\"so_27688528_27688528_2\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_27688528_27688528_3\">a template parameter,</p></li>\n<li><p id=\"so_27688528_27688528_4\">a member of an unknown specialization,</p></li>\n<li><p id=\"so_27688528_27688528_5\">a nested class or enumeration that is a member of the current instantiation,</p></li>\n<li><p id=\"so_27688528_27688528_6\">a cv-qualified type where the cv-unqualified type is dependent,</p></li>\n<li><p id=\"so_27688528_27688528_7\">a compound type constructed from any dependent type,</p></li>\n<li><p id=\"so_27688528_27688528_8\">an array type constructed from any dependent type or whose size is specified by a constant expression\n  that is value-dependent,</p></li>\n<li><p id=\"so_27688528_27688528_9\">a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent, or</p></li>\n<li><p id=\"so_27688528_27688528_10\">denoted by decltype(expression), where expression is type-dependent.</p></li>\n</ul>\n</blockquote>\n<p>However, according to [class.local] the class <code>C</code> is a <em>local</em> class rather than a <em>nested</em> class. If so, why should <code>A&lt;C&gt;</code> be treated as dependent?</p>\n<p><strong>EDIT</strong></p>\n<p>For bonus points, if the example is modified by adding a member enum to <code>C</code> as follows:</p>\n<pre><code>template&lt;typename T&gt;\nstruct A\n{\n    typedef T Type;\n};\n\ntemplate&lt;class T&gt;\nvoid f(T)\n{\n    struct C\n    {\n        enum { value = T::value };\n    };\n    typedef typename A&lt;C&gt;::Type Type; // typename required\n}\n</code></pre>\n<p>Should <code>A&lt;C&gt;</code> now be treated as dependent?</p>\n", "Tags": "<c++><templates><language-lawyer><typename><local-class>", "OwnerUserId": "1690864", "AnswerCount": "3"}});