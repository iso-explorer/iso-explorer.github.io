post_cb({"29831706": {"ParentId": "29831654", "CommentCount": "0", "Body": "<p>The overload for <code>f(double)</code> is not visible to the compiler when the <code>entry(T)</code> template is parsed. Therefore, it won't participate in overload resolution when the <code>entry(T)</code> template is instantiated. This is just an obscure rule when it comes to resolving overloads in a template instantiation context. In order for an overload to be considered, it has to already have been visible in the translation unit before the template definition was parsed.</p>\n", "OwnerUserId": "919747", "PostTypeId": "2", "Id": "29831706", "Score": "0", "CreationDate": "2015-04-23T18:36:46.947", "LastActivityDate": "2015-04-23T18:36:46.947"}, "29831841": {"ParentId": "29831654", "CommentCount": "2", "Body": "<p><code>f</code> is a dependent name, since it depends on <code>t</code> whose type is a template parameter. The name lookup rules for dependent names are given in [temp.dep.res]/1:</p>\n<blockquote>\n<p id=\"so_29831654_29831841_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</li>\n</ul>\n</blockquote>\n<p>In other words, normally name lookup inside a template only finds names that have been declared before the template definition (which is not that surprising, since it's the same as for non-templates). The second bullet point allows names declared after the template definition to be found, but only when ADL occurs. This won't be the case when the argument is a fundamental type such as <code>double</code>.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "29831841", "Score": "7", "CreationDate": "2015-04-23T18:43:46.660", "LastActivityDate": "2015-04-23T18:43:46.660"}, "29831654": {"CommentCount": "0", "ViewCount": "82", "CreationDate": "2015-04-23T18:33:28.257", "LastActivityDate": "2015-04-23T18:43:46.660", "Title": "c++ function resolution selects templated version over plain function", "AcceptedAnswerId": "29831841", "PostTypeId": "1", "Id": "29831654", "Score": "6", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T t)\n{\n  (void)t;\n  std::cout &lt;&lt; \"templated f(T)\\n\";\n}\n\ntemplate&lt;typename T&gt;\nvoid entry(T t)\n{\n  f(t);\n}\n\nvoid f(double d)\n{\n  (void)d;\n  std::cout &lt;&lt; \"normal f(double)\\n\";\n}\n\nint main()\n{\n  double d = 0.0;\n  entry(d);\n\n  return 0;\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_29831654_29831654_0\">templated f(T)</p>\n</blockquote>\n<p>I find this surprising, because I thought that the plain function will be selected over any templated version. Why does this happen?</p>\n<p>Another thing I noticed while playing around is that: if I put the normal function <code>void f(double)</code> before the templated <code>void entry(T)</code> function the code will call the normal function, basically outputting:</p>\n<blockquote>\n<p id=\"so_29831654_29831654_1\">normal f(double)</p>\n</blockquote>\n<p>Therefore my other question: why does the order matter in this particular example?</p>\n", "Tags": "<c++><function><templates><resolution>", "OwnerUserId": "4825432", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29831654_29831841_0": {"section_id": 215, "quality": 1.0, "length": 6}}, "n3337": {"so_29831654_29831841_0": {"section_id": 209, "quality": 1.0, "length": 6}}, "n4659": {"so_29831654_29831841_0": {"section_id": 223, "quality": 1.0, "length": 6}}}});