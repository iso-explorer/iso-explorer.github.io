post_cb({"bq_ids": {"n4140": {"so_14770252_14770297_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 638}}, "n3337": {"so_14770252_14770297_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 628}}, "n4659": {"so_14770252_14770297_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 666}}}, "14770252": {"ViewCount": "2085", "Body": "<p>I am trying to write a C++ class that has some overloaded methods:</p>\n<pre><code>class Output\n{\npublic:\n    static void Print(bool value)\n    {\n        std::cout &lt;&lt; value ? \"True\" : \"False\";\n    }\n\n    static void Print(std::string value)\n    {\n        std::cout &lt;&lt; value;\n    }\n};\n</code></pre>\n<p>Now lets say I call the method as follows:</p>\n<pre><code>Output::Print(\"Hello World\");\n</code></pre>\n<p>this is the result</p>\n<blockquote>\n<p id=\"so_14770252_14770252_0\">True</p>\n</blockquote>\n<p>So, why, when I have defined that the method can accept boolean and string, does it use the boolean overload when I pass in a non-boolean value?</p>\n<p><em>EDIT: I come from a C#/Java environment, so quite new to C++!</em></p>\n", "AcceptedAnswerId": "14770297", "Title": "String literal matches bool overload instead of std::string", "CreationDate": "2013-02-08T10:16:00.820", "Id": "14770252", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-10-16T21:58:47.203", "LastEditorUserId": "1505939", "LastActivityDate": "2017-03-16T12:26:34.527", "Score": "21", "OwnerUserId": "1033686", "Tags": "<c++><string><boolean><overloading><overload-resolution>", "AnswerCount": "2"}, "42834094": {"Id": "42834094", "PostTypeId": "2", "Body": "<p>FWIW, it can be address this way (if templates can be used), if you don't want to add overloads for <code>const char*</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename Bool,\n          typename T = std::enable_if_t&lt;std::is_same&lt;Bool, bool&gt;{}&gt;&gt;\nvoid foo(Bool)\n{\n  std::cerr &lt;&lt; \"bool\\n\";\n}\n\nvoid foo(const std::string&amp;)\n{\n  std::cerr &lt;&lt; \"string\\n\";  \n}\n\nint main()\n{\n  foo(\"bar\");\n  foo(false);\n}\n</code></pre>\n", "LastActivityDate": "2017-03-16T12:26:34.527", "CommentCount": "0", "CreationDate": "2017-03-16T12:26:34.527", "ParentId": "14770252", "Score": "0", "OwnerUserId": "1353549"}, "14770297": {"Id": "14770297", "PostTypeId": "2", "Body": "<p><code>\"Hello World\"</code> is a string literal of type \"array of 12 <code>const char</code>\" which can be converted to a \"pointer to <code>const char</code>\" which can in turn be converted to a <code>bool</code>. That's precisely what is happening. The compiler prefers this to using <code>std::string</code>'s conversion constructor.</p>\n<p>A conversion sequence involving a conversion constructor is known as a <em>user-defined conversion sequence</em>. The conversion from <code>\"Hello World\"</code> to a <code>bool</code> is a <em>standard conversion sequence</em>. The standard states that a standard conversion sequence is always better than a user-defined conversion sequence (\u00a713.3.3.2/2):</p>\n<blockquote>\n<p id=\"so_14770252_14770297_0\">a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence</p>\n</blockquote>\n<p>This \"better conversion sequence\" analysis is done for each argument of each viable function (and you only have one argument) and the better function is chosen by overload resolution.</p>\n<p>If you want to make sure the <code>std::string</code> version is called, you need to give it an <code>std::string</code>:</p>\n<pre><code>Output::Print(std::string(\"Hello World\"));\n</code></pre>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-02-08T10:23:23.597", "Score": "31", "CreationDate": "2013-02-08T10:18:22.460", "ParentId": "14770252", "CommentCount": "6", "OwnerUserId": "150634", "LastEditDate": "2013-02-08T10:23:23.597"}});