post_cb({"15098897": {"CommentCount": "2", "ViewCount": "134", "CreationDate": "2013-02-26T20:44:40.303", "LastActivityDate": "2013-02-26T22:02:07.437", "Title": "What are the alternatives to references and standard pointers for returning local variables in C++?", "AcceptedAnswerId": "15098927", "PostTypeId": "1", "Id": "15098897", "Score": "0", "Body": "<p>I am fairly new to C++ and I know of three ways of returning a local variable and all have their downsides:</p>\n<pre><code>Person&amp; getPerson()\n{\n   Person bob;\n   return bob;\n}\n</code></pre>\n<p>Clearly not a good idea.</p>\n<pre><code>Person getPerson()\n{\n   Person bob;\n   return bob;\n}\n</code></pre>\n<p>No chance of a null pointer or dangling reference but a performance hit.</p>\n<pre><code>Person* getPerson()\n{\n   return new Person();\n}\n</code></pre>\n<p>No chance of a null pointer but surely this violates the basic rules of OO design. Another object will have to delete this - but why should it have to? The implemenation of the getPerson() method has nothing to do with it.</p>\n<p>So, I am looking for an alternative. I have heard of shared pointers and smart pointers (standard and Boost) but I'm not sure whether any of them are designed to deal with this problem. What do you guys suggest?</p>\n", "Tags": "<c++><pointers><boost><reference><smart-pointers>", "OwnerUserId": "1873268", "AnswerCount": "7"}, "15100209": {"ParentId": "15098897", "CommentCount": "0", "Body": "<p>I know I bang on about this a lot.</p>\n<p>Another alternative is to not return anything.</p>\n<p>Tell the object what to do:</p>\n<ul>\n<li>display yourself, using this renderer</li>\n<li>serialise yourself using this serialiser (implementation could be xml, database, json, network)</li>\n<li>update your state for this time</li>\n<li>decorate yourself with controls, using this control creator (creates sliders, dropdown lists, checkboxes, etc)</li>\n</ul>\n<p>No need for getters on the whole. Make efforts to avoid them and you'll find your designs pleasantly changed, testable, reasonable.</p>\n", "OwnerUserId": "1084416", "PostTypeId": "2", "Id": "15100209", "Score": "0", "CreationDate": "2013-02-26T22:02:07.437", "LastActivityDate": "2013-02-26T22:02:07.437"}, "15098924": {"ParentId": "15098897", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You shouldn't worry too much about a performance hit here:</p>\n<pre><code>Person getPerson()\n{\n   Person bob;\n   return bob;\n}\n</code></pre>\n<p>The copy you are worried about will most likely be elided in what is called <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow noreferrer\">return value optimization (RVO)</a>. The C++ standard allows compilers to make this optimization, even if it breaks the <em>as-if</em> rule. I haven't come across a compiler that wouldn't elide a copy in this kind of expression for a long time:</p>\n<pre><code>Person p = getPerson();\n</code></pre>\n<p>In C++11, even in the absence of copy elision, this would be a candidate for a move construction. This <em>could</em> be an extremely cheap operation, but that really depends on the type in question. In any case, copy elision is hard to avoid.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/10553091/what-is-the-best-way-to-return-string-in-c/10553140#10553140\">this related post</a>.</p>\n<p>See <a href=\"http://ideone.com/JnMVsR\" rel=\"nofollow noreferrer\">this demo</a>.</p>\n", "OwnerUserId": "661519", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:40.203", "Id": "15098924", "Score": "3", "CreationDate": "2013-02-26T20:46:08.973", "LastActivityDate": "2013-02-26T21:18:35.247"}, "15099536": {"ParentId": "15098897", "CommentCount": "0", "Body": "<p>Should you ever need to return polymorphic objects, I recommend using unique pointers:</p>\n<pre><code>std::unique_ptr&lt;Person&gt; getPerson()\n{\n    return std::unique_ptr&lt;Person&gt;(new Programmer);\n}\n</code></pre>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "15099536", "Score": "0", "CreationDate": "2013-02-26T21:23:52.723", "LastActivityDate": "2013-02-26T21:23:52.723"}, "15098918": {"ParentId": "15098897", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_15098897_15098918_0\">No chance of a null pointer or dangling reference but a performance hit.</p>\n</blockquote>\n<p>Actually, no performance hit at all.\nSee for example here: <a href=\"http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/\" rel=\"nofollow\">Want Speed? Pass by Value</a>.</p>\n<p>Compiler can easily optimize that, with strategies called copy elision and the named return value optimization (check out the link for that).</p>\n", "OwnerUserId": "1176973", "PostTypeId": "2", "Id": "15098918", "Score": "4", "CreationDate": "2013-02-26T20:45:50.743", "LastActivityDate": "2013-02-26T20:45:50.743"}, "15098981": {"ParentId": "15098897", "CommentCount": "0", "Body": "<p>Local variables go out of scope - their lifetime ends - once the function execution is complete. Therefore, generally it is not a good idea to return references or pointers to local variables.</p>\n<p>What you might want to do is to return references or pointers to class member variables, which maintain their lifetime as long as the class object is in scope or has a valid lifetime.</p>\n", "OwnerUserId": "165887", "PostTypeId": "2", "Id": "15098981", "Score": "0", "CreationDate": "2013-02-26T20:49:36.920", "LastActivityDate": "2013-02-26T20:49:36.920"}, "15099118": {"ParentId": "15098897", "CommentCount": "0", "Body": "<p>As others have already pointed out, return value optimization helps minimize the performance hit from simply returning a value.</p>\n<p>Move semantics (new with C++11) can also help in this regard -- a return expression is pretty much the canonical example of an \"xvalue\", which is eligible to have its value moved from the source to the destination, rather than copied. Especially for a type (e.g., vector) that mostly consists of a pointer to the real data, this can be <em>extremely</em> beneficial, as it allows essentially a shallow copy instead of a deep copy (i.e., instead of making a copy of the entire vector, it only ends up copying the pointer).</p>\n<p>A shared_ptr or unique_ptr can work here as well. A shared_ptr is basically a reference counted pointer, so (pre-C++11) it lets you keep the object alive by just incrementing a reference count during the return process, then decrementing it again afterwards. At least in a single-threaded environment, this is generally pretty cheap -- often cheaper than making a copy of the data.</p>\n<p>A unique_ptr does roughly similar things, but without the overhead of incrementing and decrementing a reference count. The basic difference is that instead of a making copying cheap, it moves the pointer to avoid doing a copy at all.</p>\n<p>Any of these can work, but pretty clearly the best of them in most cases is to just return the value (and if it makes sense, add a move constructor and/or move assignment operator to the type you're working with).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "15099118", "Score": "2", "CreationDate": "2013-02-26T20:57:02.627", "LastActivityDate": "2013-02-26T20:57:02.627"}, "bq_ids": {"n4140": {"so_15098897_15098927_0": {"section_id": 480, "quality": 1.0, "length": 35}, "so_15098897_15098927_1": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_15098897_15098927_0": {"section_id": 471, "quality": 1.0, "length": 35}, "so_15098897_15098927_1": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_15098897_15098927_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_15098897_15098927_1": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}}}, "15098927": {"ParentId": "15098897", "CommentCount": "6", "Body": "<p>Option #2: return by value.</p>\n<pre><code>Person getPerson()\n{\n  Person bob;\n  return bob;\n}\n</code></pre>\n<p>There is no performance hit here. This copy may be (and probably will be) elided by your compiler. In fact, even if you turn off your compiler's copy elision optimizations, with a C++11 compiler this will be considered as a move first.</p>\n<p>In fact, even if you then do <code>Person p = getPerson()</code>, which would normally involve two copies, <em>both</em> may be elided.</p>\n<p>See \u00a712.9/31:</p>\n<blockquote>\n<p id=\"so_15098897_15098927_0\">in a <code>return</code> statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</p>\n</blockquote>\n<p>And \u00a712.9/32:</p>\n<blockquote>\n<p id=\"so_15098897_15098927_1\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15098927", "Score": "6", "CreationDate": "2013-02-26T20:46:20.390", "LastActivityDate": "2013-02-26T20:46:20.390"}});