post_cb({"13385601": {"ViewCount": "254", "Body": "<p>This code does not compile:</p>\n<pre><code>class C {};\n\nvoid foo (C&amp; c) {}\n\nC bar() { return C(); }\n\nint main()              \n{\n  foo(bar());\n}               \n</code></pre>\n<p>Compilation error (GCC 4.1.2) in line <code>foo(bar())</code>:<br/></p>\n<blockquote>\n<p id=\"so_13385601_13385601_0\">invalid initialization of non-const reference of type 'C&amp;' \n  from a temporary of type 'C'</p>\n</blockquote>\n<p>As <code>bar()</code> returns a <code>mutable</code> object, it should compile...<br>\n<strong>Why C++ does not allow this above code?</strong></br></p>\n<p><br>\n<strong>EDIT:</strong> I have summarize in <a href=\"https://stackoverflow.com/a/13385827/938111\">an answer below</a> all good ideas from all answers ;-)</br></p>\n", "AcceptedAnswerId": "13385664", "Title": "Is return by value always const?", "CreationDate": "2012-11-14T19:09:25.113", "Id": "13385601", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:24:42.710", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-19T16:42:13.537", "Score": "3", "OwnerUserId": "938111", "Tags": "<c++><return-value><rvalue-reference><temporary-objects><pass-by-rvalue-reference>", "AnswerCount": "8"}, "13385827": {"Id": "13385827", "PostTypeId": "2", "Body": "<p>Thank you all for your answers :-)<br>\nHere I gather your good ideas ;-)</br></p>\n<h2>Answer</h2>\n<p><em>Return by value</em> is <strong>not</strong> <code>const</code>. For example, we can call non-const member functions of <em>return by value</em>:</p>\n<pre><code>class C { \n  public:\n    int x;\n    void set (int n) { x = n; }  // non-const function\n};\n\nC bar()  { return C(); }\n\nint main ()\n{\n    bar.set(5); // OK\n}\n</code></pre>\n<p>But <strong>C++ does not allow non-const references to temporary objects</strong>. <br>\nHowever C++11 allow non-const <em>rvalue-references</em> to temporary objects. ;-)</br></p>\n<h2>Explanation</h2>\n<pre><code>class C {};\n\nvoid foo (C&amp; c) {}\n\nC bar()  { return C(); }\n//bar() returns a temporary object\n//temporary objects cannot be non-const referenced\n\nint main()\n{\n  //foo() wants a mutable reference (i.e. non-const)\n  foo( bar() ); // =&gt; compilation error     \n}                 \n</code></pre>\n<h2>Three fixes</h2>\n<ol>\n<li><p>Change <code>foo</code> declaration</p>\n<pre><code>  void foo (const C&amp; c) {}\n</code></pre></li>\n<li><p>Use another object</p>\n<pre><code>  int main()              \n  {\n    C c;\n    foo( c = bar() );\n  }\n</code></pre></li>\n<li><p>Use C++11 <em>rvalue-reference</em></p>\n<pre><code>  void foo(C &amp;&amp; c) {}\n</code></pre></li>\n</ol>\n<h2>Moreover</h2>\n<p>To confirm temporary objects are const, this above source code fails for the same reason:</p>\n<pre><code>class C {};\n\nvoid foo(C&amp; c) {}\n\nint main()                \n{\n  foo( C() );\n}            \n</code></pre>\n", "LastEditorUserId": "938111", "LastActivityDate": "2013-05-24T14:34:30.433", "Score": "0", "CreationDate": "2012-11-14T19:23:04.610", "ParentId": "13385601", "CommentCount": "3", "LastEditDate": "2013-05-24T14:34:30.433", "OwnerUserId": "938111"}, "13385654": {"Id": "13385654", "PostTypeId": "2", "Body": "<p>The issue is not with the declaration of <code>bar</code> but with that of <code>foo</code>. <code>foo</code> takes a non-<code>const</code> reference, and temporaries can only bind to <code>const</code> references (which then extends the lifetime of the temporary to match that of the reference it is bound to).</p>\n<p>Allowing a non-<code>const</code> reference to bind to a temporary doesn't make much sense. A non-<code>const</code> reference implies that it will modify whatever object is bound to it. Modifying a temporary serves no purpose since its lifetime is limited and the changes will be lost as soon as it goes out of scope.</p>\n", "LastActivityDate": "2012-11-14T19:13:16.900", "Score": "3", "CreationDate": "2012-11-14T19:13:16.900", "ParentId": "13385601", "CommentCount": "0", "OwnerUserId": "241631"}, "13385641": {"Id": "13385641", "PostTypeId": "2", "Body": "<p>It's because the value returned by <code>bar</code> is a <em>temporary</em> value. As it's existence is temporary, you can't use a pointer or reference to that.</p>\n<p>However, if you store a <em>copy</em> of that temporary, as in your second change, you no longer pass a reference to a temporary object to <code>foo</code>, but a reference to a real tangible object. And in the first case, when you change to a reference to a constant object, the compiler makes sure the temporary object stays around long enough (as per the C++ specification).</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-11-14T19:36:23.693", "Score": "8", "CreationDate": "2012-11-14T19:12:27.633", "ParentId": "13385601", "CommentCount": "1", "LastEditDate": "2012-11-14T19:36:23.693", "OwnerUserId": "440558"}, "13385649": {"Id": "13385649", "PostTypeId": "2", "Body": "<p>Modifiable (lvalue-)references do not bind to temporary values. However, const-references <em>do</em> bind to temporary values. It has nothing to do with whether the object returned by value is const or not; it's simply a matter of whether the expression is temporary or not.</p>\n<p>For example, the following <em>is</em> valid:</p>\n<pre><code>struct C { void i_am_non_const() {} };\n\nint main()\n{\n    bar().i_am_non_const();\n}\n</code></pre>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-11-14T19:26:39.040", "Score": "3", "CreationDate": "2012-11-14T19:13:01.130", "ParentId": "13385601", "CommentCount": "3", "LastEditDate": "2012-11-14T19:26:39.040", "OwnerUserId": "596781"}, "13385664": {"Id": "13385664", "PostTypeId": "2", "Body": "<p>The applicable rule here is that you can't create a non-const reference to a temporary object. If <code>foo</code> was declared as <code>foo(const C&amp;)</code> the code would be okay.</p>\n<p>The temporary object itself is not const, though; you can call non-const member functions on it, e.g., <code>bar().non_const_member_function()</code>.</p>\n<p>With C++11, foo can be written to take an rvalue reference; in that case, the call would be okay:</p>\n<pre><code>void foo(C&amp;&amp;);\nfoo(bar());  // okay\n</code></pre>\n", "LastActivityDate": "2012-11-14T19:13:46.553", "Score": "13", "CreationDate": "2012-11-14T19:13:46.553", "ParentId": "13385601", "CommentCount": "0", "OwnerUserId": "1593860"}, "13385706": {"Id": "13385706", "PostTypeId": "2", "Body": "<p>It's not const, but it is a temporary <em>rvalue</em>. As such, it can't bind to a non-const <em>lvalue</em> reference.</p>\n<p>It can bind to a const or <em>rvalue</em> reference, and you can call member functions (const or not) on it:</p>\n<pre><code>class C { void f(); };\n\nvoid foo_const(C const &amp;);\nvoid foo_rvalue(C &amp;&amp;);\n\nfoo_const( bar() );  // OK\nfoo_rvalue( bar() ); // OK\nbar().f();           // OK\n</code></pre>\n", "LastActivityDate": "2012-11-14T19:15:35.963", "Score": "1", "CreationDate": "2012-11-14T19:15:35.963", "ParentId": "13385601", "CommentCount": "0", "OwnerUserId": "204847"}, "bq_ids": {"n4140": {"so_13385601_13385601_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5}}, "n3337": {"so_13385601_13385601_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 291}}, "n4659": {"so_13385601_13385601_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5}}}, "13385665": {"Id": "13385665", "PostTypeId": "2", "Body": "<p>It is a design choice. There is nothing inherently impossible here. Just a design choice.</p>\n<p>In C++11, you have a third alternative which is also <em>superior</em> alternative:</p>\n<pre><code>void foo(C &amp;&amp; c) {} \n</code></pre>\n<p>That is, use rvalue-references.</p>\n", "LastActivityDate": "2012-11-14T19:13:53.757", "Score": "1", "CreationDate": "2012-11-14T19:13:53.757", "ParentId": "13385601", "CommentCount": "0", "OwnerUserId": "415784"}, "13385689": {"Id": "13385689", "PostTypeId": "2", "Body": "<p>The real, hard truth is that it makes no sense to get a reference to a temporary value.</p>\n<p>The big point of passing an object by reference is that it allows you to modify its state. However, in the case of a temporary, by its very nature, it would not be particularly helpful to be able to modify it, since you have no way of getting another reference to it later in your code to see the changes.</p>\n<p>However, this is somewhat different in the case you have a <code>const</code> reference. Since you'll only ever read from a <code>const</code> reference, it makes total sense to be able to use temporaries there. This is why the compiler will \"hack\" around it for you, and give a more permanent address to temporaries that you want to \"turn\" into <code>const</code> references.</p>\n<p>So, the rule is that you cannot get a non-<code>const</code> reference to a temporary value. (This slightly changed with C++11, where we have a new type of references that serve this exact purpose, but methods are expected to deal with those in a special way.)</p>\n", "LastActivityDate": "2012-11-14T19:15:05.633", "Score": "0", "CreationDate": "2012-11-14T19:15:05.633", "ParentId": "13385601", "CommentCount": "4", "OwnerUserId": "251153"}});