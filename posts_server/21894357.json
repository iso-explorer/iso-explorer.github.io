post_cb({"21895421": {"ParentId": "21894357", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Reference or pointer to const doesn't mean the referenced object cannot be modified at all - it just means that the object cannot be modified <strong>via this reference/pointer</strong>. It may very well be modified via another reference/pointer to the same object. This is called <a href=\"http://en.wikipedia.org/wiki/Aliasing_%28computing%29\" rel=\"nofollow\">aliasing</a>.</p>\n<p>Here's an example that doesn't use lambdas or any other fancy features:</p>\n<pre><code>int x = 0;\n\nvoid f() { x = 42; }\n\nvoid g(const int&amp; y) {\n  cout &lt;&lt; y;\n  f();\n  cout &lt;&lt; y;\n}\n\nint main() {\n  g(x);\n}\n</code></pre>\n<p>There's nothing undefined going on, because the object itself is not <code>const</code>, and constness on aliases is primarily for the <em>user's</em> benefit. For thoroughness, the relevant section is <code>[dcl.type.cv]p3</code>:</p>\n<blockquote>\n<p id=\"so_21894357_21895421_0\">A pointer or reference to a cv-quali\ufb01ed type need not actually point\n  or refer to a cv-quali\ufb01ed object, but it is treated as if it does; a\n  const-quali\ufb01ed access path cannot be used to modify an object even if\n  the object referenced is a non-const object <strong>and can be modi\ufb01ed\n  through some other access path</strong>. [ Note: Cv-quali\ufb01ers\n  are supported by the type system so that they cannot be subverted without casting (5.2.11). \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "1670129", "LastEditorUserId": "1325447", "LastEditDate": "2014-02-20T06:43:49.847", "Id": "21895421", "Score": "4", "CreationDate": "2014-02-20T00:08:45.227", "LastActivityDate": "2014-02-20T06:43:49.847"}, "21894357": {"CommentCount": "11", "AcceptedAnswerId": "21895421", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2014-02-19T22:52:11.970", "LastActivityDate": "2014-02-20T06:43:49.847", "LastEditDate": "2014-02-19T23:00:47.023", "ViewCount": "133", "FavoriteCount": "1", "Title": "Constness of captured reference", "Id": "21894357", "Score": "7", "Body": "<p>An object can be captured by mutable reference, and changed inside a member function which takes the same object as <code>const</code>.</p>\n<pre><code>void g(const int&amp; x, std::function&lt;void()&gt; f)\n{\n  std::cout &lt;&lt; x &lt;&lt; '\\n';\n  f();\n  std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\nint main()\n{\n  int y = 0;\n  auto f = [&amp;y] { ++y; };\n  g(y, f);\n}\n</code></pre>\n<p>An object is mutated in a scope where it is <code>const</code>. I understand that the compiler can't enforce constness here without proving that <code>x</code> and <code>y</code> are aliases. I suppose all I'm looking for is confirmation that this is undefined behavior. Is it equivalent in some sense to a <code>const_cast</code> - using a value as non-<code>const</code> in a context where it should be? </p>\n", "Tags": "<c++11><const>", "OwnerUserId": "1325447", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21894357_21895421_0": {"section_id": 5432, "quality": 0.7906976744186046, "length": 34}}, "n3337": {"so_21894357_21895421_0": {"section_id": 5227, "quality": 0.7906976744186046, "length": 34}}, "n4659": {"so_21894357_21895421_0": {"section_id": 6860, "quality": 0.7906976744186046, "length": 34}}}});