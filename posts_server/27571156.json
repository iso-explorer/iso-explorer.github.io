post_cb({"27571655": {"ParentId": "27571156", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can do this in Java.</p>\n<pre><code>try(FileChannel fc = new RandomAccessFile(\"myFile.bin\", \"rw\").getChannel()) {\n    FloatBuffer fb = fc.map(MapMode.READ_WRITE, 0, fc.size())\n                       .order(ByteOrder.nativeOrder()).asFloatBuffer();\n    // use fb \n}\n</code></pre>\n<p>This is quite a bit faster as it memory maps the file and avoids a memory copy (you can do the same in C++)</p>\n", "OwnerUserId": "57695", "LastEditorUserId": "221955", "LastEditDate": "2016-12-06T03:04:26.413", "Id": "27571655", "Score": "3", "CreationDate": "2014-12-19T18:14:32.183", "LastActivityDate": "2016-12-06T03:04:26.413"}, "27571156": {"CommentCount": "3", "AcceptedAnswerId": "27571655", "PostTypeId": "1", "LastEditorUserId": "1930254", "CreationDate": "2014-12-19T17:38:36.150", "LastActivityDate": "2017-07-05T22:24:29.900", "LastEditDate": "2014-12-19T18:11:56.930", "ViewCount": "1235", "FavoriteCount": "1", "Title": "reading C++ binary file in Java", "Id": "27571156", "Score": "2", "Body": "<p>I have a 500MB binary file. with a bunch of float entries. It was written by a C++ program. I would load it in C++ like this.</p>\n<pre><code>void load(char f_name[], int size, float data[])\n{\n    std::fstream f_bin(f_name, std::ios::in|std::ios::binary);\n\n    f_bin.seekg(std::ios::beg);\n    f_bin.read((char*)data, size*sizeof(float));\n    f_bin.close();\n}\n\nfloat *data;\nint size = 123456789;\ndata = new float[size];\nload(\"myFile.bin\", size, data);\n</code></pre>\n<p>And i can access the float values: data[x]; In c++ it works preatty fast. Is there something simular in java?</p>\n<p><strong>Edit</strong>\nAfter reading a bit around i have this so far:</p>\n<pre><code>        RandomAccessFile f = new RandomAccessFile(\"C://path//myFile.bin\", \"r\");\n        byte[] bytes = new byte[(int)f.length()];\n        f.read(bytes);\n\n        float fl = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN).getFloat();     \n\n\n        System.out.println(fl);\n</code></pre>\n<p>Which prints the <strong>first</strong> float entry. Now i should loop float by float and put it in an array like <code>float[] data</code>.</p>\n", "Tags": "<java><c++><binaryfiles>", "OwnerUserId": "1930254", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27571156_27571696_1": {"section_id": 7217, "quality": 0.8181818181818182, "length": 27}}, "n3337": {"so_27571156_27571696_1": {"section_id": 6961, "quality": 0.8181818181818182, "length": 27}}, "n4659": {"so_27571156_27571696_1": {"section_id": 8726, "quality": 0.7878787878787878, "length": 26}}}, "27571696": {"ParentId": "27571156", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The Java standard is very precise about how floating points are to be represented:</p>\n<blockquote>\n<p id=\"so_27571156_27571696_0\"><a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.3.2\" rel=\"nofollow noreferrer\"><strong>Java virtual machine specification 2.3.2:</strong></a> The floating-point types are float and double, which are conceptually associated with the\n  32-bit single-precision and 64-bit double-precision format IEEE 754\n  values and operations as specified in IEEE Standard for Binary\n  Floating-Point Arithmetic (ANSI/IEEE Std. 754-1985, New York).</p>\n</blockquote>\n<p>But the C++ standard doesn't give many guarantees regarding this:  </p>\n<blockquote>\n<p id=\"so_27571156_27571696_1\"><strong>C++11 standard 3.9.1/8:</strong> There are three floating point types: float, double, and long double. The type double provides at least as much precision as\n  float, and the type long double provides at least as much precision as\n  double.  (...) The value representation of floating-point types is\n  <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>With <a href=\"http://www.cplusplus.com/reference/limits/numeric_limits/?kw=numeric_limits\" rel=\"nofollow noreferrer\"><code>&lt;limits&gt;</code></a> you can in a portable way know a little bit more about your floats:  <code>std::numeric_limits&lt;float&gt;::is_iec559</code> will for example tell you if the  IEC-559 / IEEE-754 standard (aka the same as java) is used: </p>\n<ul>\n<li>If it is,  you could then read the float, using binary data as it is.  (<em>Edit following PoweredByRice comment; in fact you still have to address potential endianness issues, because IEEE-754 leaves this point open.  For more info on how to force a specific ordering on the C++ side, <a href=\"https://www.gamedev.net/articles/programming/general-and-gameplay-programming/writing-endian-independent-code-in-c-r2091\" rel=\"nofollow noreferrer\">look here</a>.  On the java side you can force a byte ordering or use the default one</em>).    </li>\n<li>If not, you'll have to read the bytes and write floating point format conversion routines, which usually proves to be challenging.  </li>\n</ul>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2017-07-05T22:24:29.900", "Id": "27571696", "Score": "0", "CreationDate": "2014-12-19T18:17:35.287", "LastActivityDate": "2017-07-05T22:24:29.900"}});