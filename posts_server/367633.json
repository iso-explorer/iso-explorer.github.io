post_cb({"367750": {"ParentId": "367633", "Score": "5", "CreationDate": "2008-12-15T08:17:32.243", "LastActivityDate": "2008-12-15T08:17:32.243", "Id": "367750", "OwnerUserId": "27423", "OwnerDisplayName": "Earwicker", "Body": "<p>My favourite is \"Infinite recursion in the instantiation of templates\" because I believe it's the only one where the undefined behaviour occurs at compile time.</p>\n", "PostTypeId": "2", "CommentCount": "5"}, "367650": {"ParentId": "367633", "LastEditDate": "2014-01-22T21:13:01.900", "CreationDate": "2008-12-15T07:06:09.873", "LastEditorUserId": "63550", "CommentCount": "10", "Score": "2", "OwnerUserId": "23283", "Id": "367650", "LastActivityDate": "2014-01-22T21:13:01.900", "OwnerDisplayName": "JaredPar", "Body": "<p>The only type for which C++ guarantees a size is <code>char</code>. And the size is 1. The size of all other types is platform dependent.</p>\n", "PostTypeId": "2"}, "367693": {"ParentId": "367633", "LastEditDate": "2012-08-07T10:53:52.280", "CreationDate": "2008-12-15T07:36:48.953", "LastEditorUserId": "319931", "CommentCount": "0", "Score": "5", "OwnerUserId": "22076", "Id": "367693", "LastActivityDate": "2012-08-07T10:53:52.280", "OwnerDisplayName": "rajKumar", "Body": "<p>Assigning to a constant after stripping <code>const</code>ness using <code>const_cast&lt;&gt;</code>:</p>\n<pre><code>const int i = 10; \nint *p =  const_cast&lt;int*&gt;( &amp;i );\n*p = 1234; //Undefined\n</code></pre>\n", "PostTypeId": "2"}, "bq_ids": {"n4659": {"so_367633_11211519_5": {"length": 4, "section_id": 1672, "quality": 0.6666666666666666}}}, "367671": {"ParentId": "367633", "LastEditDate": "2014-01-22T21:15:50.933", "CreationDate": "2008-12-15T07:22:53.133", "LastEditorUserId": "63550", "CommentCount": "2", "Score": "4", "OwnerUserId": "14065", "Id": "367671", "LastActivityDate": "2014-01-22T21:15:50.933", "OwnerDisplayName": "Martin York", "Body": "<p>Variables may only be updated once in an expression (technically once between sequence points).</p>\n<pre><code>int i =1;\ni = ++i;\n\n// Undefined. Assignment to 'i' twice in the same expression.\n</code></pre>\n", "PostTypeId": "2"}, "368589": {"ParentId": "367633", "LastEditDate": "2017-05-23T12:10:48.007", "CreationDate": "2008-12-15T14:49:10.440", "LastEditorUserId": "-1", "CommentCount": "0", "Score": "5", "OwnerUserId": "20310", "Id": "368589", "LastActivityDate": "2014-01-22T21:17:52.070", "OwnerDisplayName": "Constantin", "Body": "<p>Besides <strong>undefined behaviour</strong>, there is also the equally nasty <strong>implementation-defined behaviour</strong>.</p>\n<p>Undefined behaviour occurs when a program does something the result of which is not specified by the standard.</p>\n<p>Implementation-defined behaviour is an action by a program the result of which is not defined by the standard, but which the implementation is required to document. An example is \"Multibyte character literals\", from Stack Overflow question <em><a href=\"https://stackoverflow.com/questions/328215\">Is there a C compiler that fails to compile this?</a></em>.</p>\n<p>Implementation-defined behaviour only bites you when you start porting (but upgrading to new version of compiler is also porting!)</p>\n", "PostTypeId": "2"}, "367690": {"ParentId": "367633", "LastEditDate": "2008-12-15T15:58:31.860", "CreationDate": "2008-12-15T07:35:13.420", "LastEditorUserId": "14065", "LastEditorDisplayName": "Martin York", "CommentCount": "20", "Score": "27", "OwnerUserId": "14065", "Id": "367690", "LastActivityDate": "2008-12-15T15:58:31.860", "OwnerDisplayName": "Martin York", "Body": "<p>The compiler is free to re-order the evaluation parts of an expression (assuming the meaning is unchanged).</p>\n<p>From the original question:</p>\n<pre><code>a[i] = i++;\n\n// This expression has three parts:\n(a) a[i]\n(b) i++\n(c) Assign (b) to (a)\n\n// (c) is guaranteed to happen after (a) and (b)\n// But (a) and (b) can be done in either order.\n// See n2521 Section 5.17\n// (b) increments i but returns the original value.\n// See n2521 Section 5.2.6\n// Thus this expression can be written as:\n\nint rhs  = i++;\nint lhs&amp; = a[i];\nlhs = rhs;\n\n// or\nint lhs&amp; = a[i];\nint rhs  = i++;\nlhs = rhs;\n</code></pre>\n<p>Double Checked locking.\nAnd one easy mistake to make.</p>\n<pre><code>A* a = new A(\"plop\");\n\n// Looks simple enough.\n// But this can be split into three parts.\n(a) allocate Memory\n(b) Call constructor\n(c) Assign value to 'a'\n\n// No problem here:\n// The compiler is allowed to do this:\n(a) allocate Memory\n(c) Assign value to 'a'\n(b) Call constructor.\n// This is because the whole thing is between two sequence points.\n\n// So what is the big deal.\n// Simple Double checked lock. (I know there are many other problems with this).\nif (a == null) // (Point B)\n{\n    Lock   lock(mutex);\n    if (a == null)\n    {\n        a = new A(\"Plop\");  // (Point A).\n    }\n}\na-&gt;doStuff();\n\n// Think of this situation.\n// Thread 1: Reaches point A. Executes (a)(c)\n// Thread 1: Is about to do (b) and gets unscheduled.\n// Thread 2: Reaches point B. It can now skip the if block\n//           Remember (c) has been done thus 'a' is not NULL.\n//           But the memory has not been initialized.\n//           Thread 2 now executes doStuff() on an uninitialized variable.\n\n// The solution to this problem is to move the assignment of 'a'\n// To the other side of the sequence point.\nif (a == null) // (Point B)\n{\n    Lock   lock(mutex);\n    if (a == null)\n    {\n        A* tmp = new A(\"Plop\");  // (Point A).\n        a = tmp;\n    }\n}\na-&gt;doStuff();\n\n// Of course there are still other problems because of C++ support for\n// threads. But hopefully these are addresses in the next standard.\n</code></pre>\n", "PostTypeId": "2"}, "1944325": {"ParentId": "367633", "Score": "2", "CreationDate": "2009-12-22T05:28:34.973", "LastActivityDate": "2014-01-22T21:18:08.367", "LastEditDate": "2014-01-22T21:18:08.367", "OwnerUserId": "22076", "LastEditorUserId": "63550", "Body": "<p>Namespace-level objects in a different compilation units should never depend on each other for initialization, because their initialization order is undefined.</p>\n", "Id": "1944325", "PostTypeId": "2", "CommentCount": "0"}, "367633": {"Tags": "<c++><undefined><undefined-behavior><c++-faq>", "Id": "367633", "ViewCount": "48871", "LastEditDate": "2014-01-22T21:11:44.067", "OwnerUserId": "22076", "LastEditorUserId": "63550", "Title": "What are all the common undefined behaviours that a C++ programmer should know about?", "CommentCount": "11", "AcceptedAnswerId": "367662", "Score": "201", "CreationDate": "2008-12-15T06:55:42.423", "ClosedDate": "2013-06-15T21:56:46.903", "LastEditorDisplayName": "Gamecat", "LastActivityDate": "2014-01-22T21:19:12.420", "OwnerDisplayName": "rajKumar", "Body": "<p>What are all the common undefined behaviours that a C++ programmer should know about?</p>\n<p>Say, like:</p>\n<pre><code>a[i] = i++;\n</code></pre>\n<p></p>\n", "PostTypeId": "1", "FavoriteCount": "379", "AnswerCount": "11"}, "367663": {"ParentId": "367633", "LastEditDate": "2011-09-27T04:26:33.253", "CreationDate": "2008-12-15T07:15:46.063", "LastEditorUserId": "365102", "LastEditorDisplayName": "philippe ", "CommentCount": "5", "Score": "31", "OwnerUserId": "14065", "Id": "367663", "LastActivityDate": "2011-09-27T04:26:33.253", "OwnerDisplayName": "Martin York", "Body": "<p>The order that function parameters are evaluated is <strong><em>unspecified</em> behavior</strong>. (This won't make your program crash, explode, or order pizza... unlike <strong><em>undefined</em> behavior</strong>.)</p>\n<p>The only requirement is that all parameters must be fully evaluated before the function is called.</p>\n<hr>\n<p>This:</p>\n<pre><code>// The simple obvious one.\ncallFunc(getA(),getB());\n</code></pre>\n<p>Can be equivalent to this:</p>\n<pre><code>int a = getA();\nint b = getB();\ncallFunc(a,b);\n</code></pre>\n<p>Or this:</p>\n<pre><code>int b = getB();\nint a = getA();\ncallFunc(a,b);\n</code></pre>\n<p>It can be either; it's up to the compiler. The result can matter, depending on the side effects.</p>\n</hr>", "PostTypeId": "2"}, "5360204": {"ParentId": "367633", "Score": "3", "CreationDate": "2011-03-19T05:03:00.623", "LastActivityDate": "2014-01-22T21:19:12.420", "LastEditDate": "2014-01-22T21:19:12.420", "OwnerUserId": "67819", "LastEditorUserId": "63550", "Body": "<p>A basic understanding of the various environmental limits. The full list is in section 5.2.4.1 of the C specification. Here are a few;</p>\n<ul>\n<li>127 parameters in one function de\ufb01nition </li>\n<li>127 arguments in one function call </li>\n<li>127 parameters in one macro de\ufb01nition </li>\n<li>127 arguments in one macro invocation</li>\n<li>4095 characters in a logical source line </li>\n<li>4095 characters in a character string\nliteral or wide string literal (after\nconcatenation) </li>\n<li>65535 bytes in an\nobject (in a hosted environment only)</li>\n<li>15nesting levels for #included\ufb01les</li>\n<li>1023 case labels for a switch\nstatement (excluding those for\nanynested switch statements)</li>\n</ul>\n<p>I was actually a bit surprised at the limit of 1023 case labels for a switch statement, I can forsee that being exceeded for generated code/lex/parsers fairly easially.</p>\n<p>If these limits are exceeded, you have undefined behavior (crashes, security flaws, etc...).</p>\n<p>Right, I know this is from the C specification, but C++ shares these basic supports.</p>\n", "Id": "5360204", "PostTypeId": "2", "CommentCount": "2"}, "11211519": {"ParentId": "367633", "Score": "2", "CreationDate": "2012-06-26T16:10:25.950", "Id": "11211519", "OwnerUserId": "241536", "LastActivityDate": "2012-06-26T16:10:25.950", "Body": "<p>Using <code>memcpy</code> to copy between overlapping memory regions.  For example:</p>\n<pre><code>char a[256] = {};\nmemcpy(a, a, sizeof(a));\n</code></pre>\n<p>The behavior is undefined according to the C Standard, which is subsumed by the C++03 Standard.</p>\n<h2>7.21.2.1 The memcpy function</h2>\n<blockquote>\n<p id=\"so_367633_11211519_0\">Synopsis </p>\n<p id=\"so_367633_11211519_1\">1/ #include  void *memcpy(void * restrict s1, const\n  void * restrict s2, size_t n); </p>\n<p id=\"so_367633_11211519_2\">Description </p>\n<p id=\"so_367633_11211519_3\">2/ The memcpy function\n  copies n characters from the object pointed to by s2 into the object\n  pointed to by s1. If copying takes place between objects that overlap,\n  the behavior is undefined. Returns 3 The memcpy function returns the\n  value of s1.</p>\n</blockquote>\n<h2>7.21.2.2 The memmove function</h2>\n<blockquote>\n<p id=\"so_367633_11211519_4\">Synopsis</p>\n<p id=\"so_367633_11211519_5\">1 #include  void *memmove(void *s1, const void *s2, size_t\n  n);</p>\n<p id=\"so_367633_11211519_6\">Description</p>\n<p id=\"so_367633_11211519_7\">2 The memmove function copies n characters from the object pointed to\n  by s2 into the object pointed to by s1. Copying takes place as if the\n  n characters from the object pointed to by s2 are first copied into a\n  temporary array of n characters that does not overlap the objects\n  pointed to by s1 and s2, and then the n characters from the temporary\n  array are copied into the object pointed to by s1. Returns</p>\n<p id=\"so_367633_11211519_8\">3 The memmove function returns the value of s1.</p>\n</blockquote>\n", "PostTypeId": "2", "CommentCount": "0"}, "367662": {"ParentId": "367633", "LastEditDate": "2017-05-23T12:18:24.630", "CreationDate": "2008-12-15T07:15:24.583", "LastEditorUserId": "-1", "LastEditorDisplayName": "Carl Seleborg", "CommentCount": "10", "Score": "233", "CommunityOwnedDate": "2008-12-15T07:47:05.067", "Id": "367662", "LastActivityDate": "2013-08-19T22:07:48.070", "OwnerDisplayName": "Diomidis Spinellis", "Body": "<h3>Pointer</h3>\n<ul>\n<li>Dereferencing a <code>NULL</code> pointer</li>\n<li>Dereferencing a pointer returned by a \"new\" allocation of size zero</li>\n<li>Using pointers to objects whose lifetime has ended (for instance, stack allocated objects or deleted objects)</li>\n<li>Dereferencing  a pointer that has not yet been definitely initialized</li>\n<li>Performing pointer arithmetic that yields a result outside the boundaries (either above or below) of an array.</li>\n<li>Dereferencing the pointer at a location beyond the end of an array.</li>\n<li>Converting pointers to objects of incompatible types</li>\n<li><a href=\"https://stackoverflow.com/a/11211519/241536\">Using <code>memcpy</code> to copy overlapping buffers</a>.</li>\n</ul>\n<h3>Buffer overflows</h3>\n<ul>\n<li>Reading or writing to an object or array at an offset that is negative, or beyond the size of that object (stack/heap overflow)</li>\n</ul>\n<h3>Integer Overflows</h3>\n<ul>\n<li>Signed integer overflow</li>\n<li>Evaluating an expression that is not mathematically defined</li>\n<li>Left-shifting values by a negative amount (right shifts by negative amounts are implementation defined)</li>\n<li>Shifting values by an amount greater than or equal to the number of bits in the number (e.g. <code>int64_t i = 1; i &lt;&lt;= 72</code> is undefined)</li>\n</ul>\n<h3>Types, Cast and Const</h3>\n<ul>\n<li>Casting a numeric value into a value that can't be represented by the target type (either directly or via static_cast)</li>\n<li>Using an automatic variable before it has been definitely assigned (e.g., <code>int i; i++; cout &lt;&lt; i;</code>)</li>\n<li>Using the value of any object of type other than <code>volatile</code> or <code>sig_atomic_t</code> at the receipt of a signal</li>\n<li>Attempting to modify a string literal or any other const object during its lifetime</li>\n<li>Concatenating a narrow with a wide string literal during preprocessing</li>\n</ul>\n<h3>Function and Template</h3>\n<ul>\n<li>Not returning a value from a value-returning function (directly or by flowing off from a try-block)</li>\n<li>Multiple different definitions for the same entity (class, template, enumeration, inline function, static member function, etc.)</li>\n<li>Infinite recursion in the instantiation of templates</li>\n<li>Calling a function using different parameters or linkage to the parameters and linkage that the function is defined as using.</li>\n</ul>\n<h3>OOP</h3>\n<ul>\n<li>Cascading destructions of objects with static storage duration</li>\n<li>The result of assigning to partially overlapping objects</li>\n<li>Recursively re-entering a function during the initialization of its static objects</li>\n<li>Making virtual function calls to pure virtual functions of an object from its constructor or destructor</li>\n<li>Referring to nonstatic members of objects that have not been constructed or have already been destructed</li>\n</ul>\n<h3>Source file and Preprocessing</h3>\n<ul>\n<li>A non-empty source file that doesn't end with a newline, or ends with a backslash (prior to C++11)</li>\n<li>A backslash followed by a character that is not part of the specified escape codes in a character or string constant (this is implementation-defined in C++11).</li>\n<li>Exceeding implementation limits (number of nested blocks, number of functions in a program, available stack space ...)</li>\n<li>Preprocessor numeric values that can't be represented by a <code>long int</code></li>\n<li>Preprocessing directive on the left side of a function-like macro definition</li>\n<li>Dynamically generating the defined token in a <code>#if</code> expression</li>\n</ul>\n<h3>To be classified</h3>\n<ul>\n<li>Calling exit during the destruction of a program with static storage duration</li>\n</ul>\n", "PostTypeId": "2", "OwnerUserId": "20520"}});