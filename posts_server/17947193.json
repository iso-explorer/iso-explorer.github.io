post_cb({"17947193": {"ViewCount": "523", "Body": "<p>What happens to the allocated memory when a class throws an exception during construction and how would you handle something like this.  For example:</p>\n<pre><code>std::auto_ptr&lt;ThirdPartyClass&gt; au_tpc;\n\ntry\n{\n    au_tpc.reset(new ThirdPartyClass());\n}\ncatch(...)\n{\n    // What happened to the memory allocated of \n    // sizeof(ThirdPartyClass) for the new instance?\n}\n</code></pre>\n", "AcceptedAnswerId": "17947217", "Title": "What happens to heap allocated memory when exceptions occur during the constructing 'new' objects?", "CreationDate": "2013-07-30T12:35:25.513", "Id": "17947193", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-07-30T13:26:41.737", "Score": "2", "OwnerUserId": "1489354", "Tags": "<c++><memory>", "AnswerCount": "4"}, "17947627": {"Id": "17947627", "PostTypeId": "2", "Body": "<p>Check the Item 10 of the Scoot Meyers book 'More Effective C++'.</p>\n<p>A important quote from item is:</p>\n<ul>\n<li>\"<em>C++ destroys only fully constructed objects, and an object isn\u2019t fully constructed until its constructor has run to completion.</em>\". So, if you throw an exception in the constructor and dont catch it in the the constructor, the destructor will never be called.</li>\n</ul>\n<p>For specific solutions, I strongly suggest you to read this item (or better, the entire book).</p>\n", "LastActivityDate": "2013-07-30T12:55:19.477", "CommentCount": "2", "CreationDate": "2013-07-30T12:55:19.477", "ParentId": "17947193", "Score": "-1", "OwnerUserId": "334397"}, "17947217": {"Id": "17947217", "PostTypeId": "2", "Body": "<p>It just works. The memory will be released before your exception handling block is executed.</p>\n", "LastActivityDate": "2013-07-30T12:36:27.150", "CommentCount": "6", "CreationDate": "2013-07-30T12:36:27.150", "ParentId": "17947193", "Score": "7", "OwnerUserId": "46642"}, "bq_ids": {"n4140": {"so_17947193_17948221_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 6089}, "so_17947193_17948221_2": {"length": 7, "quality": 0.875, "section_id": 6101}, "so_17947193_17948221_1": {"length": 53, "quality": 0.9137931034482759, "section_id": 6101}}, "n3337": {"so_17947193_17948221_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 5857}, "so_17947193_17948221_2": {"length": 7, "quality": 0.875, "section_id": 5867}, "so_17947193_17948221_1": {"length": 53, "quality": 0.9137931034482759, "section_id": 5867}}, "n4659": {"so_17947193_17948221_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 7585}, "so_17947193_17948221_2": {"length": 7, "quality": 0.875, "section_id": 7598}, "so_17947193_17948221_1": {"length": 53, "quality": 0.9137931034482759, "section_id": 7598}}}, "17948221": {"Id": "17948221", "PostTypeId": "2", "Body": "<p>Relevant parts of the C++11 Standard: <strong>5.3.4 [expr.new]</strong></p>\n<blockquote>\n<p id=\"so_17947193_17948221_0\"><strong>8-</strong> A new-expression obtains storage for the object by calling an allocation function (3.7.4.1). If the new-\n  expression terminates by throwing an exception, it may release storage by calling a deallocation function (3.7.4.2). If the allocated type is a non-array type, the allocation function\u2019s name is <code>operator new</code> and\n  the deallocation function\u2019s name is <code>operator delete</code>. If the allocated type is an array type, the allocation\n  function\u2019s name is <code>operator new[]</code> and the deallocation function\u2019s name is <code>operator delete[]</code>.</p>\n<p id=\"so_17947193_17948221_1\"><strong>18-</strong> If any part of the object initialization described above<sup>76</sup> terminates by throwing an exception and a suitable\n  deallocation function can be found, <strong>the deallocation function is called to free the memory in which the object\n  was being constructed</strong>, after which the exception continues to propagate in the context of the new-expression.\n  If no unambiguous matching deallocation function can be found, propagating the exception does not cause\n  the object\u2019s memory to be freed.  [ Note: This is appropriate when the called allocation function does not\n  allocate memory; otherwise, it is likely to result in a memory leak. \u2014 end note ]</p>\n<p id=\"so_17947193_17948221_2\"><sup>76) This may include evaluating a new-initializer and/or calling a constructor.</sup></p>\n</blockquote>\n<p>In other words, the memory will be freed automatically except under very specific circumstances where the compiler can't find a proper deallocation function (eg. you messed up your custom (de)allocators, or the memory actually doesn't need to be freed).</p>\n", "LastActivityDate": "2013-07-30T13:20:57.797", "CommentCount": "0", "CreationDate": "2013-07-30T13:20:57.797", "ParentId": "17947193", "Score": "2", "OwnerUserId": "2070725"}, "17948365": {"Id": "17948365", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17947193_17948365_0\">What happens to the allocated memory when a class throws an exception during construction and how would you handle something like this</p>\n</blockquote>\n<p>This is a good question and correct treatment requires a full-blown article. Good news someone wrote that article already: <a href=\"http://www.gotw.ca/gotw/066.htm\" rel=\"nofollow\">Constructor Failures</a>.</p>\n", "LastActivityDate": "2013-07-30T13:26:41.737", "CommentCount": "5", "CreationDate": "2013-07-30T13:26:41.737", "ParentId": "17947193", "Score": "-2", "OwnerUserId": "412080"}});