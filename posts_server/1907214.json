post_cb({"1907214": {"CommentCount": "5", "AcceptedAnswerId": "1907353", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2009-12-15T12:47:52.987", "LastActivityDate": "2010-01-21T01:27:50.833", "LastEditDate": "2017-05-23T12:13:26.427", "ViewCount": "1645", "FavoriteCount": "1", "Title": "Why are \"inlined\" static consts not allowed, except ints?", "Id": "1907214", "Score": "4", "Body": "<blockquote>\n<p id=\"so_1907214_1907214_0\"><strong>Possible Duplicate</strong><br>\n<a href=\"https://stackoverflow.com/questions/370283/why-cant-i-have-a-non-integral-static-const-member-in-a-class\">Why can't I have a non-integral static const member in a class?</a></br></p>\n</blockquote>\n<pre><code>struct Example\n{\n    static const int One = 1000; // Legal\n    static const short Two = 2000; // Illegal\n    static const float Three = 2000.0f; // Illegal\n    static const double Four = 3000.0; // Illegal\n    static const string Five = \"Hello\"; // Illegal\n};\n</code></pre>\n<p><strong>Is there any reason for which #2, #3, #4 and #5 are illegal?</strong></p>\n<p>I think I know the reason for #5: the compiler needs a \"real\" string object (since it's not a built in type) and cannot mindlessy replace <code>Five</code> with <code>\"Hello\"</code> as if it was <code>#define Five \"Hello\"</code>. But if that's the case, can't the compiler leave an hint in the .obj files and tell the linker to automatically create one instance of <code>string Five</code> somewhere?</p>\n<p>For #3 and #4 and especially #2 (lol!)... I can't really see any possible reason! Floats and doubles are built-in types, just as int is! And short is just a (possibly) shorter integer.</p>\n<hr>\n<p><strong>EDIT</strong>: I'm using Visual Studio 2008 to compile it. I thought all compilers behaved the same in this case, but apparently g++ compiles that fine (except #5). The errors VS gives for that snippets are:</p>\n<pre>\n    error C2864: 'Example::Two' : only static const integral data members can be initialized within a class\n    error C2864: 'Example::Three' : only static const integral data members can be initialized within a class\n    error C2864: 'Example::Four' : only static const integral data members can be initialized within a class\n    error C2864: 'Example::Five' : only static const integral data members can be initialized within a class\n</pre>\n</hr>", "Tags": "<c++><static><initialization><class-members>", "OwnerUserId": "95135", "AnswerCount": "8"}, "1907353": {"ParentId": "1907214", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The int and the short are legal, and if your compiler doesn't allow them then your compiler is bust:</p>\n<blockquote>\n<p id=\"so_1907214_1907353_0\">9.4.2/4: ... If the static data member is of const integral or const\n  enumeration type, its declaration in\n  the class definition can specify a\n  <em>constant-initializer</em> which shall be an integral constant expression.</p>\n</blockquote>\n<p>I believe that the reason that floats and doubles aren't treated specially as constants in the C++ standard, in the way that integral types are, is that the C++ standard is wary that the arithmetic operations on float and double could be subtly different on the compiling machine, than they are on the machine that executes the code. For the compiler to evaluate a constant expression like (a + b), it needs to get the same answer that the runtime would get.</p>\n<p>This isn't so much of an issue with ints - you can emulate integer arithmetic relatively cheaply if it differs. But for the compiler to emulate floating-point hardware on the target device might be very difficult. It might even be impossible, if there are different versions of the chip and the compiler doesn't know which the code will run on. And that's even before you start messing with the IEEE rounding mode. So the standard avoided requiring it, so that it didn't have to define when and how compile-time evaluation can differ from runtime evaluation.</p>\n<p>As Brian mentions, C++0x is going to address this with <code>constexpr</code>. If I'm right about the original motivation, then presumably 10 years has been long enough to work through the difficulties in specifying this stuff.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2009-12-15T13:52:25.120", "Id": "1907353", "Score": "7", "CreationDate": "2009-12-15T13:11:05.983", "LastActivityDate": "2009-12-15T13:52:25.120"}, "1907315": {"ParentId": "1907214", "CommentCount": "0", "Body": "<p>#1 and 2 are compliant with the standard.  Unfortunately, some compilers simply don't conform.  That's why, for example, the Boost designers had to introduce annoying macros like <code>BOOST_STATIC_CONSTANT</code> to generate portable libraries.  If you don't want to define the constant in a .cpp file, a portable workaround is to use an <code>enum</code>.  Although, obviously in that case you have no guarantee about the type, and you can't use floats.  </p>\n", "OwnerUserId": "168288", "PostTypeId": "2", "Id": "1907315", "Score": "1", "CreationDate": "2009-12-15T13:04:37.460", "LastActivityDate": "2009-12-15T13:04:37.460"}, "1907416": {"ParentId": "1907214", "CommentCount": "0", "Body": "<p>Re the floating point initializers, the C++98 spec has this to say (5.19):</p>\n<blockquote>\n<p id=\"so_1907214_1907416_0\">Floating literals can  appear only if they are cast to integral or enumeration types.</p>\n</blockquote>\n", "OwnerUserId": "112950", "PostTypeId": "2", "Id": "1907416", "Score": "0", "CreationDate": "2009-12-15T13:22:07.910", "LastActivityDate": "2009-12-15T13:22:07.910"}, "1908085": {"ParentId": "1907214", "CommentCount": "0", "Body": "<p>As others have found, the C++ standard forbids initializing a static const member with a floating point value.</p>\n<p>At least as I understand it, there's a fairly simple reason for this. There's a feeling (at least partially justified) that an implementation should be allowed to adjust the floating point precision dynamically, so it might not be until runtime that the implementation knows the exact floating point value that would/will be produced from a particular floating point literal. In fact, it's even possible that this could change during execution.</p>\n<p>This capability does exist in real hardware. Just for example, the Intel x86 has a couple of bits in the floating point control register that control the accuracy of floating point calculations. By default, calculations are done on the 80-bit long double type, and only rounded to something like a 64-bit double or 32-bit float upon request. These bits in the register can be modified during execution, so (for example) \"1.23\" in one place could initialize a variable to one value, while \"1.23\" in another part of the program (after the precision had been adjusted) could result in a (slightly) different value.</p>\n<p>At least as far as I know, this remains a theoretical possibility, at least on most typical machines. Although the Intel hardware allows dynamic adjustment of FP precision, I don't know of any compiler (not even Intel's) that attempts to take such an adjustment into account when translating FP literals (though Intel's compiler does at least support an 80-bit long double type).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "1908085", "Score": "0", "CreationDate": "2009-12-15T15:08:51.157", "LastActivityDate": "2009-12-15T15:08:51.157"}, "1911050": {"ParentId": "1907214", "CommentCount": "0", "Body": "<p>As others have pointed out, your compiler is broken in some cases. But I have never really understood the reason why it is not allowed for floating-point types, other than \"The standard says so\". There appears to be no good technical reason.</p>\n", "OwnerUserId": "82312", "PostTypeId": "2", "Id": "1911050", "Score": "0", "CreationDate": "2009-12-15T22:56:30.270", "LastActivityDate": "2009-12-15T22:56:30.270"}, "1907257": {"ParentId": "1907214", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Both <code>Example::One</code> and <code>Example::Two</code> should compile for you, and they do indeed compile for me in the same environment you stated (VS 2008). </p>\n<p>I don't believe <code>Example::Three</code>, and <code>Example::Four</code> should compile at all in standard C++, but I think there is a gcc extension that allows it.   <code>Example::Five</code> should not compile.</p>\n<p>You can initialize them like so after the struct declaration, typically in your source file:</p>\n<pre><code>const float Example::Three = 2000.0f;\nconst double Example::Four = 3000.0;\nconst string Example::Five = \"Hello\";\n</code></pre>\n<p>This is the most portable way to do it, and the way I would recommend doing it even if your compiler allows you to define <code>Example::Three</code> and <code>Example::Four</code> in your declaration.</p>\n<p>Another option would be to simply return the value from a static function of the same type.</p>\n<pre><code>struct Example\n{\n    //...\n    static double Four() { return  = 3000.0; }\n    //...\n};\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/370283/why-cant-i-have-a-non-integral-static-const-member-in-a-class\">This answer</a> discusses a possible reason as well.<br>\n<a href=\"https://stackoverflow.com/questions/370283/why-cant-i-have-a-non-integral-static-const-member-in-a-class/370337#370337\">This answer</a> discusses how the upcoming C++ standard will help via constexpr</br></p>\n", "OwnerUserId": "3153", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:05.650", "Id": "1907257", "Score": "4", "CreationDate": "2009-12-15T12:54:38.990", "LastActivityDate": "2009-12-15T13:15:16.443"}, "1907287": {"ParentId": "1907214", "CommentCount": "0", "Body": "<p>Under VS2008 I get the following error:</p>\n<pre><code>1&gt;.\\Weapon Identification SystemDlg.cpp(223) : error C2864: 'Example::Three' : only static const integral data members can be initialized within a class\n1&gt;.\\Weapon Identification SystemDlg.cpp(224) : error C2864: 'Example::Four' : only static const integral data members can be initialized within a class\n1&gt;.\\Weapon Identification SystemDlg.cpp(225) : error C2864: 'Example::Five' : only static const integral data members can be initialized within a class\n</code></pre>\n<p>It sucks but I guess you just have to NOT do it if your compiler refuses too ... I'm not aware of this being a spec thing but im sure someone will correct me ...</p>\n", "OwnerUserId": "131140", "PostTypeId": "2", "Id": "1907287", "Score": "0", "CreationDate": "2009-12-15T12:59:17.207", "LastActivityDate": "2009-12-15T12:59:17.207"}, "bq_ids": {"n4140": {"so_1907214_1907353_0": {"section_id": 5908, "quality": 0.7368421052631579, "length": 14}, "so_1907214_1907283_2": {"section_id": 5908, "quality": 0.6756756756756757, "length": 25}}, "n3337": {"so_1907214_1907353_0": {"section_id": 5680, "quality": 0.7368421052631579, "length": 14}, "so_1907214_1907283_2": {"section_id": 5680, "quality": 0.6756756756756757, "length": 25}}, "n4659": {"so_1907214_1907353_0": {"section_id": 7390, "quality": 0.7368421052631579, "length": 14}, "so_1907214_1907283_2": {"section_id": 7390, "quality": 0.5675675675675675, "length": 21}}}, "1907283": {"ParentId": "1907214", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_1907214_1907283_0\">In C++98, only static const members of\n  integral types can be initialized\n  in-class, and the initializer has to\n  be a constant expression. These\n  restrictions ensure that we can do the\n  initialization at compile-time.</p>\n</blockquote>\n<p>See <a href=\"http://www2.research.att.com/~bs/C++0xFAQ.html#member-init\" rel=\"nofollow noreferrer\">In-class member initializers</a>.</p>\n<blockquote>\n<p id=\"so_1907214_1907283_1\">\u00a79.4.2 Static data members</p>\n<p id=\"so_1907214_1907283_2\">If a static data member is of const integral or const enumeration type, its declaration in the class de\ufb01nition can \n  specify a constant-initializer which shall be an integral constant expression (5.19). In that case, the member can appear \n  in integral constant expressions. The member shall still be de\ufb01ned in a namespace scope if it is used in the program and \n  the namespace scope de\ufb01nition shall not contain an initializer. </p>\n</blockquote>\n", "OwnerUserId": "216063", "LastEditorUserId": "216063", "LastEditDate": "2009-12-15T13:13:32.297", "Id": "1907283", "Score": "1", "CreationDate": "2009-12-15T12:58:53.053", "LastActivityDate": "2009-12-15T13:13:32.297"}});