post_cb({"8887864": {"CommentCount": "2", "CreationDate": "2012-01-16T23:40:24.837", "PostTypeId": "1", "AcceptedAnswerId": "8887980", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-17T10:15:52.257", "LastEditDate": "2012-01-17T00:23:29.557", "ViewCount": "10105", "FavoriteCount": "2", "Title": "Template base constructor call in member initialization list error", "Id": "8887864", "Score": "11", "Body": "<p>I have a base class that looks like the following.</p>\n<pre><code>template&lt;typename T&gt;\nclass Base\n{\n   public:\n      Base(int someValue);\n\n      virtual T someFunc() =0;\n};\n\ntemplate&lt;typename T&gt;\nBase&lt;T&gt;::Base(int someValue)\n{}\n</code></pre>\n<p>And then the following.</p>\n<pre><code>#include \"base.hpp\"\n\nclass Foo\n   : public Base&lt;Foo&gt;\n{\n   public:\n      Foo(int someValue);\n\n      virtual Foo someFunc();\n};\n\nFoo::Foo(int someValue)\n   : Base(someValue)\n{}\n</code></pre>\n<p>I get the following error from gcc 4.2.1.</p>\n<pre><code>error: class \u2018Foo\u2019 does not have any field named \u2018Base\u2019\n</code></pre>\n<p>I should mention this compiles fine on my Fedora box wich is running gcc 4.6.2. This error occurs when compiling on my os x Lion machine.</p>\n<p>Thanks in advance for the help.</p>\n<p>EDIT</p>\n<p>Problem seems that I am not indicating type of template in the Foo class when calling the constructor. The following fixes the error in os x.</p>\n<pre><code>: Base&lt;Foo&gt;(someValue, parent)\n</code></pre>\n<p>EDIT</p>\n<p>Yes this does look like a bug. What I mentioned before fixes the error under os x and code compiles fine in fedora with that fix. Will go and see if there is an update to gcc in os x.</p>\n", "Tags": "<c++><qt><inheritance><compiler-errors><g++>", "OwnerUserId": "174084", "AnswerCount": "1"}, "8887980": {"ParentId": "8887864", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>First:</p>\n<blockquote>\n<p id=\"so_8887864_8887980_0\"><code>[C++11: 12.6.2/3]:</code> A <em>mem-initializer-list</em> can initialize a base class using any <em>class-or-decltype</em> that denotes that base class type.</p>\n<p id=\"so_8887864_8887980_1\">[ <em>Example:</em></p>\n<pre><code>struct A { A(); };\ntypedef A global_A;\nstruct B { };\nstruct C: public A, public B { C(); };\nC::C(): global_A() { } // mem-initializer for base A\n</code></pre>\n<p id=\"so_8887864_8887980_2\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>And <code>Base</code> should be a valid <em>injected-class-name</em> for the base here (that is, you can use it in place of <code>Base&lt;T&gt;</code>):</p>\n<blockquote>\n<p id=\"so_8887864_8887980_3\"><code>[C++11: 14.6.1/1]:</code> <strong>Like normal (non-template) classes, class templates have an <em>injected-class-name</em> (Clause 9). The <em>injected-class-name</em> can be used as a <em>template-name</em> or a <em>type-name</em>.</strong> When it is used with a <em>template-argument-list</em>, as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em>\n  of a friend class template declaration, it refers to the class template itself. Otherwise, <strong>it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</strong></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p id=\"so_8887864_8887980_4\"><code>[C++11: 14.6.1/3]:</code> The <em>injected-class-name</em> of a class template or class template specialization can be used either as a <em>template-name</em> or a <em>type-name</em> wherever it is in scope. [ <em>Example:</em></p>\n<pre><code>template &lt;class T&gt; struct Base {\n   Base* p;\n};\n\ntemplate &lt;class T&gt; struct Derived: public Base&lt;T&gt; {\n   typename Derived::Base* p; // meaning Derived::Base&lt;T&gt;\n};\n\ntemplate&lt;class T, template&lt;class&gt; class U = T::template Base&gt; struct Third { };\nThird&lt;Base&lt;int&gt; &gt; t; // OK: default argument uses injected-class-name as a template\n</code></pre>\n<p id=\"so_8887864_8887980_5\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>I haven't found anything to indicate that this doesn't apply in the <em>ctor-initializer</em>, so I'd say that this is a compiler bug.</p>\n<p>My stripped-down testcase <a href=\"http://codepad.org/faB14asJ\" rel=\"noreferrer\">fails in GCC 4.1.2</a> and <a href=\"http://ideone.com/awtPS\" rel=\"noreferrer\">GCC 4.3.4</a> but <a href=\"http://ideone.com/tSWdI\" rel=\"noreferrer\">succeeds in GCC 4.5.1 (C++11 mode)</a>. It seems to be resolved by <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=189\" rel=\"noreferrer\">GCC bug 189</a>; in <a href=\"http://gcc.gnu.org/gcc-4.5/changes.html\" rel=\"noreferrer\">the GCC 4.5 release notes</a>:</p>\n<blockquote>\n<p id=\"so_8887864_8887980_6\">G++ now implements <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#176\" rel=\"noreferrer\">DR 176</a>. Previously G++ did not support using the\n  injected-class-name of a template base class as a type name, and\n  lookup of the name found the declaration of the template in the\n  enclosing scope. Now lookup of the name finds the injected-class-name,\n  which can be used either as a type or as a template, depending on\n  whether or not the name is followed by a template argument list. As a\n  result of this change, some code that was previously accepted may be\n  ill-formed because</p>\n<ul>\n<li>The injected-class-name is not accessible because it's from a private base, or</li>\n<li>The injected-class-name cannot be used as an argument for a template template parameter.</li>\n</ul>\n<p id=\"so_8887864_8887980_7\">In either of these cases, the code can be fixed by adding a\n  nested-name-specifier to explicitly name the template. The first can\n  be worked around with -fno-access-control; the second is only rejected\n  with -pedantic.</p>\n</blockquote>\n<hr>\n<p>My stripped-down testcase with Qt abstracted out:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Base { };\n\nstruct Derived : Base&lt;Derived&gt; { // I love the smell of CRTP in the morning\n   Derived();\n};\n\nDerived::Derived() : Base() {};\n</code></pre>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-01-17T10:15:52.257", "Id": "8887980", "Score": "8", "CreationDate": "2012-01-16T23:59:10.663", "LastActivityDate": "2012-01-17T10:15:52.257"}, "bq_ids": {"n4140": {"so_8887864_8887980_0": {"section_id": 430, "quality": 0.8461538461538461, "length": 11}, "so_8887864_8887980_3": {"section_id": 179, "quality": 0.925, "length": 37}, "so_8887864_8887980_4": {"section_id": 181, "quality": 0.75, "length": 12}}, "n3337": {"so_8887864_8887980_0": {"section_id": 422, "quality": 0.8461538461538461, "length": 11}, "so_8887864_8887980_3": {"section_id": 173, "quality": 0.925, "length": 37}, "so_8887864_8887980_4": {"section_id": 175, "quality": 0.75, "length": 12}}, "n4659": {"so_8887864_8887980_0": {"section_id": 448, "quality": 0.8461538461538461, "length": 11}, "so_8887864_8887980_3": {"section_id": 184, "quality": 0.925, "length": 37}, "so_8887864_8887980_4": {"section_id": 186, "quality": 0.75, "length": 12}}}});