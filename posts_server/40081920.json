post_cb({"40082277": {"ParentId": "40081920", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>For the 2nd case, <em>inheriting constructor</em> doesn't take effect. According to the rules of <a href=\"http://en.cppreference.com/w/cpp/language/default_constructor#Deleted_implicitly-declared_default_constructor\" rel=\"nofollow\">deleted implicitly-declared default constructor</a>, that in the 2nd case class <code>D</code> doesn't violate (there's a well-formed <code>B::B()</code> for <code>D</code>); the compiler will declare a default constructor as an inline public member for <code>D</code>, which makes <code>D d{};</code> work well.</p>\n<blockquote>\n<p id=\"so_40081920_40082277_0\">...</p>\n<p id=\"so_40081920_40082277_1\"><code>T</code> has a direct or virtual base which has a deleted default constructor, or it is ambiguous or inaccessible from this constructor.</p>\n<p id=\"so_40081920_40082277_2\">...</p>\n</blockquote>\n<p>For the 1st case, <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration#Inheriting_constructors\" rel=\"nofollow\">inheriting constructors</a> takes effect:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_40081920_40082277_3\">If overload resolution selects an inherited constructor, it is\n  accessible if it would be accessible when used to construct an object\n  of the corresponding base class: <strong>the accessibility of the\n  using-declaration that introduced it is ignored</strong>.</p>\n<p id=\"so_40081920_40082277_4\"><strong>If overload resolution selects one of the inherited constructors when\n  initializing an object of such derived class, then the Base subobject\n  from which the constructor was inherited is initialized using the\n  inherited constructor</strong>, and all other bases and members of Derived are\n  initialized as if by the defaulted default constructor (default member\n  initializers are used if provided, otherwise default initialization\n  takes place).</p>\n</blockquote>\n<p>Then it fails because of the access isolation.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-10-17T09:46:32.393", "Id": "40082277", "Score": "3", "CreationDate": "2016-10-17T09:02:17.707", "LastActivityDate": "2016-10-17T09:46:32.393"}, "40081920": {"CommentCount": "5", "ViewCount": "309", "PostTypeId": "1", "LastEditorUserId": "1593860", "CreationDate": "2016-10-17T08:42:34.290", "LastActivityDate": "2016-10-17T12:40:39.330", "Title": "Inherited constructors, default constructor and visibility", "AcceptedAnswerId": "40082277", "LastEditDate": "2016-10-17T12:40:39.330", "Id": "40081920", "Score": "8", "Body": "<p>As stated by <a href=\"http://eel.is/c++draft/namespace.udecl#18\" rel=\"nofollow\">[namespace.udecl]/18</a>:</p>\n<blockquote>\n<p id=\"so_40081920_40081920_0\">[...] A using-declaration that names a constructor does not create a synonym; instead, the additional constructors are accessible if they would be accessible when used to construct an object of the corresponding base class, and the accessibility of the using-declaration is ignored. [...]</p>\n</blockquote>\n<p>Because of that, the following code does not compile:</p>\n<pre><code>class B { protected: B(int) { } };\nclass D: B { using B::B; };\nint main () { D d{0}; }\n</code></pre>\n<p>It returns an error that is more or less the same with all the major compilers:</p>\n<blockquote>\n<p id=\"so_40081920_40081920_1\">declared protected here</p>\n</blockquote>\n<p>On the other side, the following code compiles:</p>\n<pre><code>class B { protected: B() { } };\nclass D: B { using B::B; };\nint main () { D d{}; }\n</code></pre>\n<p>Shouldn't it fail to compile instead for the same reasons that lead to an error in the previous example?<br>\nWhat does it allow it to compile?</br></p>\n", "Tags": "<c++><c++11><language-lawyer><default-constructor><inherited-constructors>", "OwnerUserId": "4987285", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40081920_40082277_1": {"section_id": 369, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_40081920_40082277_1": {"section_id": 359, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_40081920_40082277_3": {"section_id": 6942, "quality": 0.7222222222222222, "length": 13}, "so_40081920_40081920_0": {"section_id": 6942, "quality": 1.0, "length": 22}, "so_40081920_40082277_1": {"section_id": 382, "quality": 0.5555555555555556, "length": 5}}}, "40082189": {"ParentId": "40081920", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>class B { protected: B() { } };\nclass D: B { using B::B; };\nint main () { D d{}; }\n</code></pre>\n<p><code>D</code> has no user-defined constructor in this case, so the compiler generates one (public) for you that calls <code>B::B</code> (but not because of the <code>using</code>, that has no effect in this case), that compiler-generated constructor is then called by main.</p>\n<pre><code>class B { protected: B(int) { } };\nclass D: B { using B::B; };\nint main () { D d{0}; }\n</code></pre>\n<p>Even though <code>D</code> has no user-defined constructor here, the compiler-generated one is implicitly deleted because <code>B</code> only has a constructor that takes an <code>int</code>. <code>D</code> does also have a constructor that takes an <code>int</code> (<code>using</code> did that) but this constructor is marked <code>protected</code> and thus inaccessible by <code>main</code>.</p>\n", "OwnerUserId": "1870760", "LastEditorUserId": "1870760", "LastEditDate": "2016-10-17T09:03:49.177", "Id": "40082189", "Score": "5", "CreationDate": "2016-10-17T08:57:29.803", "LastActivityDate": "2016-10-17T09:03:49.177"}});