post_cb({"15007832": {"ParentId": "15007244", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Unless you know the complete set of types used as arguments to <code>InputIterator</code>, the definition needs to go into the header file.</p>\n<p>A template definition (implementation) can only be separated from the declaration when you know the full set of instantiations (arguments) needed. The compiler cannot remember what instantiations were used in one <code>.cpp</code> (translation unit) and provide them using code in another <code>.cpp</code>.</p>\n<p>As Andy mentions, the behavior you seem to be looking for was previously assigned to the C++03 <code>export</code> keyword, which was seldom implemented, and turned out to be less useful than hoped, and has now been completely removed from the standard.</p>\n<p>If you do want to go this route (I'm writing a similar library right now!), the <code>extern</code> keyword needs to go outside the <code>class {}</code> scope and the <code>.cpp</code> file needs to explicitly instantiate the needed specializations.</p>\n<pre><code>// header file\n\nclass lexer {\n    public:\n    template&lt;class InputIterator&gt;\n    lexer(InputIterator i, InputIterator end);\n};\n\nextern template lexer::lexer( foo::iterator, foo::iterator );\nextern template lexer::lexer( bar::iterator, bar::iterator );\n\n// source file\n\ntemplate&lt;class InputIterator &gt;\nlexer::lexer(InputIterator i, InputIterator end) {\n    //make it work\n};\n\ntemplate lexer::lexer( foo::iterator, foo::iterator );\ntemplate lexer::lexer( bar::iterator, bar::iterator );\n</code></pre>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-02-21T17:01:45.510", "Id": "15007832", "Score": "1", "CreationDate": "2013-02-21T16:50:32.747", "LastActivityDate": "2013-02-21T17:01:45.510"}, "bq_ids": {"n4140": {"so_15007244_15007521_2": {"section_id": 251, "quality": 1.0, "length": 17}}, "n3337": {"so_15007244_15007521_2": {"section_id": 242, "quality": 1.0, "length": 17}}, "n4659": {"so_15007244_15007521_2": {"section_id": 258, "quality": 1.0, "length": 17}}}, "15007521": {"ParentId": "15007244", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason why it doesn't work is that you are not instantiating your class template, neither are you instantiating your class template's constructor: while processing translation units (i.e. <code>.cpp</code> files) other than <code>lexer.cpp</code> that invoke that constructor, the compiler won't be able to see its definition, so it will not emit any object code for it; on the other hand, in the only translation unit that <em>can</em> see its definition (<code>lexer.cpp</code>), you are not invoking the constructor, so again the compiler won't emit any object code. </p>\n<p>As a result, no object code for your constructor is present in your program's compiled translation units, and the linker will complain about <em>unresolved references</em> to your class's constructor when trying to create the executable.</p>\n<p>The <code>extern</code> keyword is used to <em>prevent</em> the instantiation of a template in one translation unit (even though its full definition is visible!) when you <em>know</em> that it will be (explicitly) instantiated in another translation unit, thus saving compilation time. See <strong><a href=\"https://stackoverflow.com/questions/8130602/using-extern-template-c0x\">this Q&amp;A on StackOverflow</a></strong> for a clarification.</p>\n<p>From Paragraph 14.7.2/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15007244_15007521_0\">The syntax for explicit instantiation is:</p>\n<p id=\"so_15007244_15007521_1\">explicit-instantiation:\n  extern(opt) template declaration</p>\n<p id=\"so_15007244_15007521_2\">There are two forms of explicit instantiation: an explicit instantiation definition and an explicit instantiation declaration. An explicit instantiation <strong>declaration</strong> begins with the <code>extern</code> keyword.</p>\n</blockquote>\n<p>Thus, what you are providing is simply a declaration. There is no way of relegating member function definitions of a class template in a <code>.cpp</code> file without getting unresolved reference errors from the linker, unless you instantiate them (possibly through an explicit instantiation of the class template) in that very same translation unit (the only one which has access to those definitions).</p>\n<p>C++03 had a keyword called <code>export</code> which allowed doing what you are trying to achieve, but <a href=\"https://stackoverflow.com/questions/5416872/using-export-keyword-with-templates\"><strong>it has been removed</strong></a> during standardization of C++11 because it proved to be too difficult to implement for compiler vendors.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:18.723", "Id": "15007521", "Score": "0", "CreationDate": "2013-02-21T16:36:18.067", "LastActivityDate": "2013-02-21T17:20:58.637"}, "15007244": {"CommentCount": "3", "ViewCount": "977", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-02-21T16:23:11.927", "LastActivityDate": "2013-02-21T19:54:47.057", "Title": "extern template constructor in c++", "AcceptedAnswerId": "15007521", "LastEditDate": "2013-02-21T19:54:47.057", "Id": "15007244", "Score": "0", "Body": "<p>for quite some time i struggle with old-as-c++ problem of separating the implementation of a templated function from the definition. C++0x' <code>extern</code> seem to be a solution for this, but i fail to apply it properly</p>\n<p>my code:</p>\n<p><code>main.cpp</code></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include \"lexer.h\"\n\nint main(int argc, char const *argv[]) {\n    std::string foo(\"foo\");\n    new lexer((foo.begin()),(foo.end()));\n    return 0;\n}\n</code></pre>\n<p><code>lexer.h</code></p>\n<pre><code>#ifndef lexer_h\n#define lexer_h\nclass lexer {\n    public:\n    extern template&lt;class InputIterator&gt;\n    lexer(InputIterator i, InputIterator end);\n};\n#endif //lexer_h\n</code></pre>\n<p><code>lexer.cpp</code></p>\n<pre><code>#include \"lexer.h\"\ntemplate&lt;class InputIterator &gt;\nlexer::lexer(InputIterator i, InputIterator end) {\n    //make it work\n};\n</code></pre>\n<p>compiling with <code>g++ main.cpp lexer.cpp -std=c++0x</code>. I want to use object files later.</p>\n<p>so how would it look fixed?</p>\n", "Tags": "<c++><templates><c++11><constructor><extern>", "OwnerUserId": "382736", "AnswerCount": "2"}});