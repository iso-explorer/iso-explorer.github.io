post_cb({"bq_ids": {"n4140": {"so_26220448_26220448_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_26220448_26220448_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_26220448_26220448_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "26233121": {"Id": "26233121", "PostTypeId": "2", "Body": "<p>I found a workaround for my problem. The initial problem in my first post can be solved by using a C-Cast to give the compiler a hint of what type <strong><em>p</em></strong> should be without using the unary + operator.</p>\n<pre><code>using ExplicitCast = void();\n// valid but does not work in MSVC\nauto fn = +[]() {};\n// fix for MSVC\nauto fn = (ExplicitCast*)[]() {};\n</code></pre>\n<p>Unfortunately this does not solve the problem when the types in the parameter list do not match (which is legal if the types are inherited). I have a function where the first parameter is different to the first parameter in my lambda. E.g:</p>\n<pre><code>class Foo {};\nclass Bar : public Foo {};\n\nusing ExplicitCast = void(Bar*);\nusing Function = void(Foo*);\nstatic Function* func = nullptr;\n\nint main()\n{\n    // does not work because the parameter list does not match\n    // func = [](Bar*) -&gt; void { };\n    // func = +[](Bar*) -&gt; void { };\n\n    // does work because we first explicit cast to a function and then to the needed function.\n    func = (Function*)(ExplicitCast*)[](Bar*) -&gt; void { };\n\n    Bar o;\n    func(&amp;o);\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-10-07T09:45:22.880", "CommentCount": "0", "CreationDate": "2014-10-07T09:45:22.880", "ParentId": "26220448", "Score": "0", "OwnerUserId": "1385931"}, "26220448": {"ViewCount": "391", "Body": "<p>Can anyone help me pointing out why this does not work in VS2013?</p>\n<pre><code>auto p = +[]() -&gt; void { std::cout &lt;&lt; \"Hello, world!\\n\"; };\np();\n\nsource_file.cpp(7) : error C2593: 'operator +' is ambiguous\n    could be 'built-in C++ operator+(void (__cdecl *)(void))'\n    or       'built-in C++ operator+(void (__stdcall *)(void))'\n    or       'built-in C++ operator+(void (__fastcall *)(void))'\n    or       'built-in C++ operator+(void (__vectorcall *)(void))'\n</code></pre>\n<p>This is a legal operator to force-cast the lambda</p>\n<blockquote>\n<h3>5.1.2 Lambda expressions [expr.prim.lambda]</h3>\n<p id=\"so_26220448_26220448_0\"><sup>6</sup> The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>How can I tell the compiler what conversion he should use?</p>\n", "AcceptedAnswerId": "26220743", "Title": "operator + on Lambda", "CreationDate": "2014-10-06T16:17:34.223", "Id": "26220448", "CommentCount": "3", "LastEditDate": "2015-06-13T14:02:11.177", "PostTypeId": "1", "LastEditorUserId": "1385931", "LastActivityDate": "2015-06-13T14:02:11.177", "Score": "4", "OwnerUserId": "1385931", "Tags": "<c++><c++11><lambda>", "AnswerCount": "2"}, "26220743": {"Id": "26220743", "PostTypeId": "2", "Body": "<p>Apparently this is a VC++ bug. There seems to be no other way than to explicitly cast: </p>\n<pre><code>+ static_cast&lt; void(*)() &gt;( []{} ); // Empty lamba without loss of generality\n</code></pre>\n<p>Unfortunately, the magic is lost like this.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-06T16:49:34.947", "Score": "2", "CreationDate": "2014-10-06T16:36:27.243", "ParentId": "26220448", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-10-06T16:49:34.947"}});