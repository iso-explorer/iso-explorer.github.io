post_cb({"5216132": {"Id": "5216132", "PostTypeId": "2", "Body": "<p>The <code>vector</code> constructor you are using is actually defined like this:</p>\n<pre><code>explicit vector ( size_type n, const T&amp; value= T(), const Allocator&amp; = Allocator() );\n</code></pre>\n<p>(see e.g., <a href=\"http://www.cplusplus.com/reference/stl/vector/vector/\" rel=\"nofollow\">http://www.cplusplus.com/reference/stl/vector/vector/</a>).</p>\n<p>In other words, <strong>one</strong> element is default constructed (i.e., the default parameter value as you call the constructor), and the remaining elements are then created by copying the first one. My guess is that you need a copy constructor for <code>point</code> that properly handles the (non-)copying of <code>__m128i</code> values. </p>\n<p><strong>Update:</strong> When I try to build your code with Visual Studio 2010 (v. 10.0.30319.1), I get the following build error:</p>\n<pre><code>error C2719: '_Val': formal parameter with __declspec(align('16')) won't be aligned c:\\program files\\microsoft visual studio 10.0\\vc\\include\\vector 870 1   meh\n</code></pre>\n<p>This suggests Ben is right on the money regarding this being an alignment problem. </p>\n", "LastEditorUserId": "569266", "LastActivityDate": "2011-03-07T05:33:22.120", "Score": "3", "CreationDate": "2011-03-07T05:21:10.793", "ParentId": "5216071", "CommentCount": "10", "OwnerUserId": "569266", "LastEditDate": "2011-03-07T05:33:22.120"}, "5216071": {"ViewCount": "2951", "Body": "<p>Is there an obvious reason why the following code segfaults ?</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;emmintrin.h&gt;\n\nstruct point {\n    __m128i v;\n\n  point() {\n    v = _mm_setr_epi32(0, 0, 0, 0);\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  std::vector&lt;point&gt; a(3);\n}\n</code></pre>\n<p>Thanks</p>\n<p>Edit: I'm using g++ 4.5.0 on linux/i686, I might not know what I'm doing here, but since even the following segfaults</p>\n<pre><code>int main(int argc, char *argv[])\n{\n  point *p = new point();\n}\n</code></pre>\n<p>I really think it must be and alignment issue.</p>\n", "AcceptedAnswerId": "5216238", "Title": "SSE and C++ containers", "CreationDate": "2011-03-07T05:11:29.960", "Id": "5216071", "CommentCount": "10", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-12-17T22:12:48.550", "LastEditorUserId": "104099", "LastActivityDate": "2012-12-17T22:12:48.550", "Score": "9", "OwnerUserId": "104099", "Tags": "<c++><sse><memory-alignment><allocator>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5216071_5216238_1": {"length": 13, "quality": 1.0, "section_id": 7248}, "so_5216071_5216238_0": {"length": 65, "quality": 0.9285714285714286, "section_id": 7177}}, "n3337": {"so_5216071_5216238_0": {"length": 65, "quality": 0.9285714285714286, "section_id": 6921}, "so_5216071_5216238_1": {"length": 13, "quality": 1.0, "section_id": 6992}}, "n4659": {"so_5216071_5216238_0": {"length": 62, "quality": 0.8857142857142857, "section_id": 8685}}}, "5216237": {"Id": "5216237", "PostTypeId": "2", "Body": "<p>SSE intrinsics are required to be 16-byte aligned in memory. When you allocate an <code>__m128</code> on the stack, there's no problem because the compiler automatically aligns these correctly. The default allocator for <code>std::vector&lt;&gt;</code>, which handles dynamic memory allocation, does not produce aligned allocations. </p>\n", "LastActivityDate": "2011-03-07T05:39:01.443", "CommentCount": "0", "CreationDate": "2011-03-07T05:39:01.443", "ParentId": "5216071", "Score": "1", "OwnerUserId": "158259"}, "5216166": {"Id": "5216166", "PostTypeId": "2", "Body": "<p>There is a possibility that the memory that is allocated by the default allocator in your compiler's STL implementation is not aligned. This will be dependent on the specific platform and compiler vendor.</p>\n<p>Usually the default allocator uses operator <code>new</code>, which usually does not guarantee alignment beyond the word size (32-bit or 64-bit). To solve the problem, it may be necessary to implement a custom allocator which uses <code>_aligned_malloc</code>.</p>\n<p>Also, a simple fix (although not a satisfactory one) would be to assign the value to a local <code>__m128i</code> variable, then copy that variable to the struct using unaligned instruction. Example:</p>\n<pre><code>struct point {\n    __m128i v;\n    point() {\n        __m128i temp = _mm_setr_epi32(0, 0, 0, 0);\n        _mm_storeu_si128(&amp;v, temp);\n    }\n};\n</code></pre>\n", "LastEditorUserId": "377657", "LastActivityDate": "2011-03-07T05:41:24.087", "Score": "1", "CreationDate": "2011-03-07T05:26:43.547", "ParentId": "5216071", "CommentCount": "4", "OwnerUserId": "377657", "LastEditDate": "2011-03-07T05:41:24.087"}, "5216238": {"Id": "5216238", "PostTypeId": "2", "Body": "<p>The obvious thing that could have gone wrong would be if <code>v</code> wasn't aligned properly.</p>\n<p>But it's allocated dynamically by <code>vector</code>, so it isn't subject to stack misalignment issues. </p>\n<p>However, as <a href=\"https://stackoverflow.com/questions/5216071/sse-and-c-containers/5216132#5216132\">phooji</a> correctly points out, a \"template\" or \"prototype\" value is passed to the <code>std::vector</code> constructor which will be copied to all the elements of the vector.  It's this parameter of <code>std::vector::vector</code> that will be placed on the stack and may be misaligned.</p>\n<p>Some compilers have a pragma for controlling stack alignment within a function (basically, the compiler wastes some extra space as needed to get all locals properly aligned).</p>\n<p>According to the Microsoft documentation, <a href=\"http://msdn.microsoft.com/en-us/library/k1a8ss06.aspx\" rel=\"nofollow noreferrer\">Visual C++ 2010 should set up 8 byte stack alignment automatically for SSE types</a> and <a href=\"http://msdn.microsoft.com/en-us/library/aa290049.aspx\" rel=\"nofollow noreferrer\">has done so since Visual C++ 2003</a></p>\n<p>For gcc I don't know.</p>\n<hr>\n<p>Under C++0x, for <code>new point()</code> to return unaligned storage is a serious non-compliance.  <code>[basic.stc.dynamic.allocation]</code> says (wording from draft n3225):</p>\n<blockquote>\n<p id=\"so_5216071_5216238_0\">The allocation function attempts to allocate the requested amount of storage.  If it is successful, it shall\n  return the address of the start of a block of storage whose length in bytes shall be at least as large as\n  the requested size.  There are no constraints on the contents of the allocated storage on return from the\n  allocation function.  The order, contiguity, and initial value of storage allocated by successive calls to an\n  allocation function are unspeci\ufb01ed. The pointer returned shall be suitably aligned so that it can be converted\n  to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used\n  to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to\n  a corresponding deallocation function).</p>\n</blockquote>\n<p>And <code>[basic.align]</code> says:</p>\n<blockquote>\n<p id=\"so_5216071_5216238_1\">Additionally, a request for runtime allocation of dynamic storage for which the\n  requested alignment cannot be honored shall be treated as an allocation failure.</p>\n</blockquote>\n<p>Can you try a newer version of gcc where this might be fixed?</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-08T13:52:20.777", "Score": "11", "CreationDate": "2011-03-07T05:39:11.000", "ParentId": "5216071", "CommentCount": "1", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T10:30:42.240"}});