post_cb({"9834832": {"ParentId": "9834273", "CommentCount": "0", "Body": "<p>IEEE-754, which is a standard common implementations of floating point numbers abide to, requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result. Thus the only imprecision that you will face is rounding after each operation you perform, as well as propagation of rounding errors from the operations performed earlier in the chain. Floats are not per se inexact. And by the way, epsilon can and should be computed, you can consult any numerics book on that.</p>\n<p>Floating point numbers can represent integers precisely up to the length of their mantissa. So for example if you cast from an int to a double, it will always be exact, but for casting into into a float, it will no longer be exact for very large integers.</p>\n<p>There is one major example of extensive usage of floating point numbers as a substitute for integers, it's the LUA scripting language, which has no integer built-in type, and floating-point numbers are used extensively for logic and flow control etc.  The performance and storage penalty from using floating-point numbers turns out to be smaller than the penalty of resolving multiple types at run time and makes the implementation lighter. LUA has been extensively used not only on PC, but also on game consoles.</p>\n<p>Now, many compilers have an optional switch that disables IEEE-754 compatibility. Then compromises are made. Denormalized numbers (very very small numbers where the exponent has reached smallest possible value) are often treated as zero, and approximations in implementation of power, logarithm, sqrt, and 1/(x^2) can be made, but addition/subtraction, comparison and multiplication should retain their properties for numbers which can be exactly represented.</p>\n", "OwnerUserId": "207427", "PostTypeId": "2", "Id": "9834832", "Score": "0", "CreationDate": "2012-03-23T06:05:42.433", "LastActivityDate": "2012-03-23T06:05:42.433"}, "9843678": {"ParentId": "9834273", "CommentCount": "0", "Body": "<p>The easy answer: For constants == is ok.\nThere are <em>two</em> exceptions which you should be aware of:</p>\n<p>First exception:</p>\n<p>0.0 == -0.0</p>\n<p>There is a negative zero which compares equal for the IEEE 754 standard. This means\n1/INFINITY == 1/-INFINITY which breaks f(x) == f(y) =&gt; x == y</p>\n<p>Second exception:</p>\n<p>NaN != NaN</p>\n<p>This is a special caveat of NotaNumber which allows to find out if a number is a NaN\non systems which do not have a test function available (Yes, that happens).</p>\n", "OwnerUserId": "224774", "PostTypeId": "2", "Id": "9843678", "Score": "0", "CreationDate": "2012-03-23T17:21:42.833", "LastActivityDate": "2012-03-23T17:21:42.833"}, "9834302": {"ParentId": "9834273", "CommentCount": "0", "Body": "<p>No if you assign literals they should be the same :)</p>\n<p>Also if you start with the same value and do the same operations, they should be the same.</p>\n<p>Floating point values are non-exact, but the operations should produce consistent results :)</p>\n", "OwnerUserId": "1248861", "PostTypeId": "2", "Id": "9834302", "Score": "0", "CreationDate": "2012-03-23T04:49:43.800", "LastActivityDate": "2012-03-23T04:49:43.800"}, "9834759": {"ParentId": "9834273", "CommentCount": "0", "Body": "<p>Both cases are ultimately subject to implementation defined representations.</p>\n<p>Storage of floating point values and their representations take on may forms - load by address or constant? optimized out by fast math? what is the register width? is it stored in an SSE register? Many variations exist.</p>\n<p>If you need precise behavior and portability, do not rely on this implementation defined behavior.</p>\n", "OwnerUserId": "191596", "PostTypeId": "2", "Id": "9834759", "Score": "0", "CreationDate": "2012-03-23T05:57:43.193", "LastActivityDate": "2012-03-23T05:57:43.193"}, "9834608": {"ParentId": "9834273", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Actually, it depends on the value and the implementation. The C++ standard (draft n3126) has this to say in <code>2.14.4 Floating literals</code>:</p>\n<blockquote>\n<p id=\"so_9834273_9834608_0\">If the scaled value is in the range of representable values for its type, the result is the scaled value if representable, else the larger or smaller representable value nearest the scaled value, chosen in an implementation-defined manner.</p>\n</blockquote>\n<p>In other words, if the value is exactly representable (and <code>1</code> is, in IEEE754, as is <code>100</code> in your static cast), you get the value. Otherwise (such as with <code>0.1</code>) you get an implementation-defined close match <sup>(a)</sup>. Now I'd be very worried about an implementation that chose a <em>different</em> close match based on the same input token but it <em>is</em> possible.</p>\n<hr>\n<p><sup>(a)</sup> Actually, that paragraph can be read in two ways, either the implementation is free to choose either the closest higher or closest lower value regardless of which is actually the closest, or it must choose the closest to the desired value.</p>\n<p>If the latter, it doesn't change this answer however since all you have to do is hardcode a floating point value exactly at the midpoint of two representable types and the implementation is once again free to choose either.</p>\n<p>For example, it might alternate between the next higher and next lower for the same reason banker's rounding is applied - to reduce the cumulative errors.</p>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2012-03-23T05:47:40.800", "Id": "9834608", "Score": "3", "CreationDate": "2012-03-23T05:36:59.077", "LastActivityDate": "2012-03-23T05:47:40.800"}, "bq_ids": {"n4140": {"so_9834273_9834608_0": {"section_id": 5348, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_9834273_9834608_0": {"section_id": 5145, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_9834273_9834608_0": {"section_id": 6773, "quality": 0.9545454545454546, "length": 21}}}, "9834273": {"CommentCount": "1", "ViewCount": "1282", "PostTypeId": "1", "LastEditorUserId": "509205", "CreationDate": "2012-03-23T04:45:57.533", "LastActivityDate": "2012-03-23T17:21:42.833", "Title": "Floating-point comparison of constant assignment", "AcceptedAnswerId": "9834608", "LastEditDate": "2012-03-23T04:53:36.047", "Id": "9834273", "Score": "5", "Body": "<p>When comparing doubles for equality, we need to give a tolerance level, because floating-point computation might introduce errors. For example:</p>\n<pre><code>double x; \ndouble y; \nx = f();\ny = g();\n\nif (fabs(x-y)&lt;epsilon) {\n   // they are equal!\n} else {\n   // they are not!\n}\n</code></pre>\n<p>However, if I simply <em>assign</em> a constant value, without any computation, do I still need to check the epsilon? </p>\n<pre><code>double x = 1;\ndouble y = 1;\n\nif (x==y) {\n   // they are equal!\n} else {\n   // no they are not!\n}\n</code></pre>\n<p>Is <code>==</code> comparison good enough? Or I need to do <code>fabs(x-y)&lt;epsilon</code> again? Is it possible to introduce error in assigning? Am I too paranoid? </p>\n<p>How about casting (<code>double x = static_cast&lt;double&gt;(100)</code>)? Is that gonna introduce floating-point error as well? </p>\n<p>I am using C++ on Linux, but if it differs by language, I would like to understand that as well.</p>\n", "Tags": "<c++><floating-point><floating-point-precision>", "OwnerUserId": "509205", "AnswerCount": "5"}});