post_cb({"bq_ids": {"n4140": {"so_26317798_26318330_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 603}, "so_26317798_26318330_4": {"length": 11, "quality": 1.0, "section_id": 623}, "so_26317798_26318330_0": {"length": 49, "quality": 0.875, "section_id": 603}, "so_26317798_26318330_3": {"length": 20, "quality": 1.0, "section_id": 324}, "so_26317798_26318330_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 143}}, "n3337": {"so_26317798_26318330_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 593}, "so_26317798_26318330_4": {"length": 11, "quality": 1.0, "section_id": 613}, "so_26317798_26318330_0": {"length": 49, "quality": 0.875, "section_id": 593}, "so_26317798_26318330_3": {"length": 20, "quality": 1.0, "section_id": 314}, "so_26317798_26318330_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 137}}, "n4659": {"so_26317798_26318330_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 629}, "so_26317798_26318330_4": {"length": 11, "quality": 1.0, "section_id": 649}, "so_26317798_26318330_0": {"length": 49, "quality": 0.875, "section_id": 629}, "so_26317798_26318330_3": {"length": 20, "quality": 1.0, "section_id": 332}, "so_26317798_26318330_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 147}}}, "26317798": {"ViewCount": "291", "Body": "<p>I'm completely confused after reading the question <a href=\"https://stackoverflow.com/questions/26299212/how-to-make-these-stdfunction-parameters-unambiguous\">How to make these std::function parameters unambiguous?</a>, so far I'd thought I understood what <em>partial ordering of function templates</em> is, but after reading that question I wrote down three examples to check the compiler's behavior, and the results received are hard for me to understand.</p>\n<h3>Example #1</h3>\n<pre><code>template &lt;class T&gt;\nvoid foo(T) {}\n\ntemplate &lt;class T&gt;\nvoid foo(T&amp;) {}\n\nint main()\n{\n  int i;\n  foo&lt;int&gt;(i); // error: call is ambiguous! \n}\n</code></pre>\n<p><em>Question:</em> Both functions are viable, that's obvious, but isn't the one taking <code>T&amp;</code> more specialized than <code>T</code>? Instead, the compiler raises <em>ambiguous call</em> error.</p>\n<h3>Example #2</h3>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nstruct X {};\n\ntemplate &lt;&gt;\nstruct X&lt;int&gt; \n{\n  X() {}\n  X(X&lt;int&amp;&gt; const&amp;) {} // X&lt;int&gt; is constructible from X&lt;int&amp;&gt;\n  // note: this is not a copy constructor!\n};\n\ntemplate &lt;&gt;\nstruct X&lt;int&amp;&gt; \n{\n  X() {}\n  X(X&lt;int&gt; const&amp;) {} // X&lt;int&amp;&gt; is constructible from X&lt;int&gt;\n  // note: this is not a copy constructor!\n};\n\ntemplate &lt;class T&gt;\nvoid bar(X&lt;T&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\ntemplate &lt;class T&gt;\nvoid bar(X&lt;T&amp;&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\nint main()\n{\n  bar&lt;int&gt;(X&lt;int&gt;());   // calls void bar(X&lt;T&gt;) [with T = int]\n\n  bar&lt;int&gt;(X&lt;int&amp;&gt;());  // calls void bar(X&lt;T&amp;&gt;) [with T = int]\n}\n</code></pre>\n<p><em>Question:</em> If the <code>T&amp;</code> and <code>T</code> are ambiguous in Example #1, then why here none call is ambiguous? <code>X&lt;int&gt;</code> is constructible from <code>X&lt;int&amp;&gt;</code>, as well as <code>X&lt;int&amp;&gt;</code> is constructible from <code>X&lt;int&gt;</code> thanks to provided constructors. Is it because compiler generated <code>X&lt;int&gt;::X(X&lt;int&gt; const&amp;)</code> copy-constructor is a <em>better conversion sequence</em> than <code>X&lt;int&gt;::X(X&lt;int&amp;&gt; const&amp;)</code>, (if so, what makes it better, note that arguments are passed by value), and so the ordering of specializations does not matter at all?</p>\n<h3>Example #3</h3>\n<pre><code>#include &lt;iostream&gt;\n\n// note: a new type used in constructors!\ntemplate &lt;class U&gt;\nstruct F {};\n\ntemplate &lt;class T&gt;\nstruct X\n{\n  X() {}\n\n  template &lt;class U&gt;\n  X(F&lt;U&gt; const&amp;) {}  // X&lt;T&gt; is constructible from any F&lt;U&gt;\n  // note: it takes F type, not X!\n};\n\ntemplate &lt;class T&gt;\nvoid qux(X&lt;T&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\ntemplate &lt;class T&gt;\nvoid qux(X&lt;T&amp;&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\nint main()\n{\n  qux&lt;int&gt;(F&lt;int&gt;());  // calls void qux(X&lt;T&amp;&gt;) [with T = int]\n\n  qux&lt;int&gt;(F&lt;int&amp;&gt;()); // calls void qux(X&lt;T&amp;&gt;) [with T = int]\n}\n</code></pre>\n<p><em>Question:</em> Now this is similar scenario to <em>\"matching lambda <code>[](int){}</code> against <code>std::function&lt;void(int&amp;)&gt;</code> and <code>std::function&lt;void(int)&gt;</code>\"</em> from question linked. Why in both calls the <em>more specialized</em> function template is picked? Is it because the conversion sequence is the same, so partial ordering starts to matter?</p>\n<p>All tests done on GCC 4.9.0 with <code>-std=c++11</code> and no extra flags.</p>\n", "AcceptedAnswerId": "26318330", "Title": "When are two function templates considered as partially ordered and when are ambiguous?", "CreationDate": "2014-10-11T18:23:37.463", "Id": "26317798", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:30:14.780", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-17T10:53:55.873", "Score": "11", "OwnerUserId": "391022", "Tags": "<c++><templates><language-lawyer><overload-resolution><partial-ordering>", "AnswerCount": "2"}, "26318330": {"Id": "26318330", "PostTypeId": "2", "Body": "<p>Overload resolution tries to find the best function like this:</p>\n<p>(1) [over.match.best]/1:</p>\n<blockquote>\n<p id=\"so_26317798_26318330_0\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  <em>i</em>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then<br> \u2014 for some argument <em>j</em>, <code>ICSj(F1)</code> is a better conversion\n  sequence than <code>ICSj(F2)</code>, or, if not that,<br> \u2014 the context is an\n  initialization by user-defined conversion (see 8.5, 13.3.1.5, and\n  13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being\n  initialized) is a better conversion sequence than the standard\n  conversion sequence from the return type of <code>F2</code> to the destination\n  type. <br>[ Example:</br></br></br></p>\n<pre><code>struct A {\n  A();\n  operator int();\n  operator double();\n} a;\n\nint i = a;    // a.operator int() followed by no conversion is better \n              // than `a.operator double()`     \n              // followed by a conversion to `int`\nfloat x = a;  // ambiguous: both possibilities require conversions,\n              // and neither is better than the other\n</code></pre>\n<p id=\"so_26317798_26318330_1\">\u2014 <em>end example</em> ] or, if not that, <br>  \u2014 F1 is a non-template\n  function and F2 is a function template specialization, or, if not\n  that,<br> \u2014 F1 and F2 are function template specializations, and the\n  function template for F1 is more specialized than the template for F2\n  according to the partial ordering rules described in 14.5.6.2.</br></br></p>\n</blockquote>\n<hr>\n<h3> Case 1: </h3>\n<blockquote>\n<p id=\"so_26317798_26318330_2\">but isn't the one taking <code>T&amp;</code> more specialized than <code>T</code>?</p>\n</blockquote>\n<p>According to overload resolution, no conversion is better (both are identity conversions, which are exact matches), and since no other bullet in (1) applies, partial ordering is done. [temp.deduct.partial]/5 says that references are replaced by the type they refer to for purposes of partial ordering:</p>\n<blockquote>\n<p id=\"so_26317798_26318330_3\">Before the partial ordering is done, certain transformations are\n  performed on the types used for partial ordering:<br> \u2014 If <code>P</code> is a\n  reference type, <code>P</code> is replaced by the type referred to.<br> \u2014 If <code>A</code> is a\n  reference type, <code>A</code> is replaced by the type referred to.</br></br></p>\n</blockquote>\n<p>Since the parameters of the parameter templates are completely identical it is not hard to see that the deductions against each other are successful both ways -- so neither template is more specialized than the other.</p>\n<h3> Case 2: </h3>\n<p>Partial ordering isn't needed here. The user-defined-conversion from <code>X&lt;int&gt;</code> to <code>X&lt;int&amp;&gt;</code> has a worse rank than converting <code>X&lt;int&gt;</code> to <code>X&lt;int&gt;</code> -- The latter is given Exact Match rank by [over.ics.user]/4:</p>\n<blockquote>\n<p id=\"so_26317798_26318330_4\">A conversion of an expression of class type to the same class type is\n  given Exact Match rank, [\u2026]</p>\n</blockquote>\n<p>Thus it's obviously a better conversion than <code>X&lt;int&gt;</code> to <code>X&lt;int&amp;&gt;</code>, which has Conversion rank. Same goes vice versa, for <code>X&lt;int&amp;&gt;</code> to <code>X&lt;int&gt;</code>.</p>\n<h3> Case 3: </h3>\n<p>The third case is similar to the first. <code>X&lt;int&gt;</code> and <code>X&lt;int&amp;&gt;</code> both have a constructor template that can take an arbitrary specialization of <code>F</code>. (1) tells us that since none of the conversion sequences is better than the other in any way (in fact, they are completely identical), the more specialized template is chosen.</p>\n<pre><code>template &lt;class T&gt; void bar(X&lt;T&gt;);  // #1\n\ntemplate &lt;class T&gt; void bar(X&lt;T&amp;&gt;); // #2\n\n// Call:\nbar&lt;int&gt;( F&lt;int&gt;() );\n</code></pre>\n<p>Going back to [temp.deduct.partial], type deduction is performed. A unique type, call it <code>Unique</code>, is synthesized for the template parameter of each argument template. The following procedures with corresponding results are carried out - note that the steps are exactly the same when calling with <code>F&lt;int&gt;</code> as with <code>F&lt;int&amp;&gt;</code> (and any other specialization of <code>F</code>):</p>\n<ol>\n<li>template #1 as the parameter template and template #2 as the argument template, <code>X&lt;Unique&amp;&gt;</code> is deduced against <code>X&lt;T&gt;</code>, yielding <code>T=Unique&amp;</code>. On the other hand,</li>\n<li>template #2 as the parameter template against template #1 as the argument template, <code>X&lt;Unique&gt;</code> is deduced against <code>X&lt;T&amp;&gt;</code>, <strong>which results in a deduction failure</strong>.</li>\n</ol>\n<p>As we can see template #2 is more specialized. When used as an argument template in step 1, deduction succeeded, whereas for template #1 as the argument template in step 2, the deduction failed. Therefore the second, more specialized function templates' specialization is called.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-05T12:36:53.160", "Score": "7", "CreationDate": "2014-10-11T19:16:46.707", "ParentId": "26317798", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-11-05T12:36:53.160"}, "26318223": {"Id": "26318223", "PostTypeId": "2", "Body": "<p>Example 1 : </p>\n<p>The compiler cannot know if you want to pass <code>a</code> by reference or by value. If you specialize your template with a <code>T *</code> he will know easily because the function call syntax will be different <code>foo(&amp;a)</code>.</p>\n<p>Example 2 : </p>\n<p>Here you tell the compiler that the second overload of <code>qux</code> takes a <code>X&lt;T &amp;&gt;</code> so he knows that you want to construct this object with an <code>T &amp;</code>. There is no ambiguity. But if you do this : </p>\n<pre><code>template &lt;class T&gt;\nvoid qux(X&lt;T&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\ntemplate &lt;class T&gt;\nvoid qux(X&lt;T&gt; &amp;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n</code></pre>\n<p>You will end up with the same problem</p>\n<p>Example 3:</p>\n<p>Same problem.</p>\n<p>I don't know if it's very clear so if someone could improve my answer, that could be useful to the author</p>\n", "LastActivityDate": "2014-10-11T19:05:40.570", "CommentCount": "3", "CreationDate": "2014-10-11T19:05:40.570", "ParentId": "26317798", "Score": "1", "OwnerUserId": "4116453"}});