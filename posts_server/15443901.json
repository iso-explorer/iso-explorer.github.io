post_cb({"bq_ids": {"n4140": {"so_15443901_15443968_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5910}}, "n3337": {"so_15443901_15443968_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5682}}, "n4659": {"so_15443901_15443968_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7392}}}, "15444206": {"Id": "15444206", "PostTypeId": "2", "Body": "<p>The multiple definition problem for variables is due to two main deficiencies in the language definition.</p>\n<p>As shown below you can easily work around it. There is no <em>technical</em> reason why there is no direct support. It has to do with the feature not being in sufficient high demand that people on the committee have chosen to make it a priority.</p>\n<p>First, why multiple definitions in general are a problem. Since C++ lacks support for separately compiled modules (deficiency #1), programmers have to emulate that feature by using textual preprocessing etc. And then it's easy to <em>inadvertently</em> introduce two or more definitions of the same name, which would most likely be in error.</p>\n<p>For functions this was solved by the <code>inline</code> keyword and property. A freestanding function can only be explicitly <code>inline</code>, while a member function can be implicitly <code>inline</code> by being defined in the class definition. Either way, if a function is <code>inline</code> then it can be defined in multiple translation units, and it must be defined in every translation unit where it's used, and those definitions must be equivalent.</p>\n<p>Mainly that solution allowed classes to be defined in header files.</p>\n<p>No such language feature was needed to support data, variables defined in header files, so it just isn't there: you can't have <code>inline</code> variables. This is language deficiency #2.</p>\n<p>However, you can obtain the <em>effect</em> of <code>inline</code> variables via a special exemption for <code>static</code> data members of class templates. The reason for the exemption is that class templates generally have to be fully defined in header files (unless the template is only used internally in a translation unit), and so for a class template to be able to have <code>static</code> data members, it's necessary with either an exemption from the general rules, or some special support. The committee chose the exemption-from-the-rules route.</p>\n<pre><code>template&lt; class Dummy &gt;\nstruct math_\n{\n    static double const pi;\n};\n\ntemplate&lt; class Dummy &gt;\ndouble const math_&lt;Dummy&gt;::pi = 3.14;\n\ntypedef math_&lt;void&gt; math;\n</code></pre>\n<p>The above has been referred to as the <strong>templated const trick</strong>. As far as I know I was the one who once introduced it, in the [comp.lang.c++] Usenet group, so I can't give credit to someone else. I've also posted it a few times here on SO.</p>\n<p>Anyway, this means that every C++ compiler and linker internally supports and must support the machinery needed for <code>inline</code> data, and yet the language doesn't have that feature.</p>\n<p>However, on the third hand, C++11 has <code>constexpr</code>, where you can write the above as just</p>\n<pre><code>struct math\n{\n    static double constexpr pi = 3.14;\n};\n</code></pre>\n<p>Well, there is a difference, that you can't take the address of the C++11 <code>math::pi</code>, but that's a very minor limitation.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2013-03-16T00:42:36.543", "Score": "2", "CreationDate": "2013-03-16T00:34:32.357", "ParentId": "15443901", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2013-03-16T00:42:36.543"}, "15443901": {"ViewCount": "416", "Body": "<p>I read the reason for defining static data members in the source file is because if they were in the header file and multiple source files included the header file- the definitions would get output multiple times. I can see why this would be a problem for the static const data member, but why is this a problem for the static data member?</p>\n<p>I'm not too sure I fully understand why there is a problem if the definition is written in the header file... </p>\n", "AcceptedAnswerId": "15443968", "Title": "Declaring static data members of normal class and class template", "CreationDate": "2013-03-15T23:51:14.343", "Id": "15443901", "CommentCount": "0", "LastEditDate": "2013-08-30T05:45:41.663", "PostTypeId": "1", "LastEditorUserId": "415784", "LastActivityDate": "2013-08-30T05:45:41.663", "Score": "0", "OwnerUserId": "997112", "Tags": "<c++><oop><static><const>", "AnswerCount": "2"}, "15443968": {"Id": "15443968", "PostTypeId": "2", "Body": "<p>I think you're confusing two things: <code>static</code> data members and global variables markes as <code>static</code>. </p>\n<p>The latter have <em>internal linkage</em>, which means that if you put their definition in a header file that multiple translation units <code>#include</code>, each translation unit will receive a <em>private copy</em> of those variables. </p>\n<p>Global variables marked as <code>const</code> have internal linkage by default, so you won't need to specify <code>static</code> explicitly for those. Hence, the linker won't complain about multiple definitions of global <code>const</code> variable or of global non-<code>const</code> variables marked as <code>static</code>, while it will complain in the other cases (because those variables would have external linkage).</p>\n<p>Concerning <code>static</code> data members, this is what Paragraph 9.4.2/5 of the C++11 Standard says:</p>\n<blockquote>\n<p id=\"so_15443901_15443968_0\"><code>static</code> data members of a class in namespace scope <strong>have external linkage</strong> (3.5). A local class shall not have\n  <code>static</code> data members.</p>\n</blockquote>\n<p>This means that if you put their definition in a header file <code>#include</code>d by multiple translation units, you will end up with multiple definitions of the same symbol in the corresponding object files (exactly like non-<code>const</code> global variables), no matter what their <code>const</code>-qualification is. In that case, your program would violate the <strong><a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">One Definition Rule</a></strong>.</p>\n<p>Also, <a href=\"https://stackoverflow.com/questions/11300652/static-data-member-initialization\"><strong>this Q&amp;A on StackOverflow</strong></a> may give you a clearer understanding of the subject.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-16T00:22:59.817", "Score": "1", "CreationDate": "2013-03-15T23:59:17.337", "ParentId": "15443901", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:11:05.840"}});