post_cb({"bq_ids": {"n4140": {"so_14669995_14670387_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 4689}}, "n3337": {"so_14669995_14670387_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 4498}}, "n4659": {"so_14669995_14670387_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 6080}}}, "14669995": {"ViewCount": "1014", "Body": "<p>It's unclear to me from the C++11 standard where user-defined <code>hash&lt;T&gt;</code> functors should be defined.</p>\n<p>For example, in <em>23.5.2 Header <code>&lt;unordered_map&gt;</code></em>, it shows:</p>\n<pre><code>template &lt;class Key,\n        class T,\n        class Hash = hash&lt;Key&gt;,\n        class Pred = std::equal_to&lt;Key&gt;,\n        class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;\n    class unordered_map;\n</code></pre>\n<p>This suggests that, by default, <code>hash&lt;T&gt;</code> is searched for in the global namespace, whereas <code>equal_to&lt;&gt;</code> is searched for in the <code>std</code> namespace.</p>\n<p>Why the difference in namespace between <code>hash&lt;&gt;</code> and <code>equal_to&lt;&gt;</code>?</p>\n<p>(Actually, in the description at <a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/\">http://www.cplusplus.com/reference/unordered_map/unordered_map/</a>, neither specifies the <code>std</code> namespace.)</p>\n<p>Thus, when defining a <code>hash&lt;&gt;</code> functor for a user type, should we enclose it within a <code>namespace std { }</code> block, or can it remain in the current namespace?</p>\n<p>If the code does not have a <code>using namespace std;</code>, how do the STL containers like <code>unordered_map</code> know to look in the <code>std</code> namespace for the predefined <code>hash&lt;&gt;</code> functors associated with the primitive types?  It seems like the default <code>Hash = hash&lt;Key&gt;</code> would fail to find these.</p>\n<p>Sorry if these are stupid questions..</p>\n", "AcceptedAnswerId": "14670387", "Title": "In which namespace do hash<T> functors for user types belong?", "CreationDate": "2013-02-03T06:15:18.113", "Id": "14669995", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-03T06:18:53.910", "LastEditorUserId": "1381108", "LastActivityDate": "2013-02-03T08:47:35.767", "Score": "11", "OwnerUserId": "1190077", "Tags": "<c++><hash><c++11><namespaces>", "AnswerCount": "2"}, "14670387": {"Id": "14670387", "PostTypeId": "2", "Body": "<p>First of all, there is no \"argument dependent lookup\" for templates. So <code>hash&lt;Key&gt;</code> will always refer to the same template, either in <code>std</code> or in global namespace, independent of <code>Key</code>. If it had resolved to different templates in different translation units, it would cause undefined behavior by ODR violation. This alone suggests that <code>hash</code> here means <code>std::hash</code>, that is as-if <code>unordered_map</code> was declared like this:</p>\n<pre><code>namespace std {\n    template&lt;class T&gt; struct hash;\n\n    template &lt;class Key,\n        class T,\n        class Hash = hash&lt;Key&gt;,    // resolves to std::hash&lt;Key&gt; for all Keys\n        class Pred = std::equal_to&lt;Key&gt;,\n        class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;\n    class unordered_map;\n}\n</code></pre>\n<p>However, the types declared in the standard headers are not required to be written in source (they could be in principle built-in to the compiler or pre-compiled by some other magic). The standard requires each standard header to declare only the types in its synopsis, which means that by omitting the <code>std::hash</code> declaration the standard permits some hypothetical implementation to avoid the above namespace pollution. This explains why you do not see the above declaration in the synopsis.</p>\n<p>To further back-up the above conclusion, we go to \u00a720.8.12 Class template hash [unord.hash] that reads:</p>\n<blockquote>\n<p id=\"so_14669995_14670387_0\">The unordered associative containers defined in 23.5 use specializations of the class template hash as the default hash function.</p>\n</blockquote>\n<p>This paragraph refers to the <code>std::hash</code>, which we can infer from the synopsis of <code>&lt;functional&gt;</code>.</p>\n<p><strong>Bottom line:</strong> This is an inconsistency in the standard formatting. There are plenty of inconsistencies, so this specific case is not surprising at all. In such cases one has to understand what has been intended by deducing what is the only sensible thing.</p>\n<p><strong>Specialization.</strong> You specialize templates in the namespace that they were declared. You are explicitly granted the right to specialize standard templates for your own type:</p>\n<pre><code>namespace std {\n    template&lt;&gt; struct hash&lt;YourClass&gt; {\n        // specialization goes here\n    };\n}\n</code></pre>\n", "LastEditorUserId": "277176", "LastActivityDate": "2013-02-03T08:47:35.767", "Score": "6", "CreationDate": "2013-02-03T07:31:23.367", "ParentId": "14669995", "CommentCount": "3", "OwnerUserId": "277176", "LastEditDate": "2013-02-03T08:47:35.767"}, "14670389": {"Id": "14670389", "PostTypeId": "2", "Body": "<p>when you want to define a <em>hash functor</em> for your type, just put it into <strong>your</strong> namespace and instantiate <code>unordered_xxx</code> with it -- pretty simple...</p>\n<pre><code>namespace my {\nstruct some_type {/*...*/};\nstruct some_hasher {/*...*/};\n}\n\ntypedef std::unordered_map&lt;int, my::some_type, my::some_hasher&gt; my_some_hash_map;\n</code></pre>\n<p>AFAIK it is not recommended (and obviously unsafe) to add smth into <code>std</code> namespace. and actually it is not required (in my experience I can't recall when I want to add smth into <code>std</code> -- it is always possible to solve a \"problem\" not doing this)</p>\n<p>And btw:</p>\n<blockquote>\n<p id=\"so_14669995_14670389_0\">This suggests that, by default, hash is searched for in the global namespace, whereas equal_to&lt;&gt; is searched for in the std namespace.</p>\n</blockquote>\n<p>WRONG! Consider this:</p>\n<pre><code>namespace my {\n// See declaration of some_type above...\ntemplate &lt;\n    typename SomeType = some_type\n  , typename Alloc = std::allocator&lt;SomeType&gt;\n  &gt;\nstruct test;\n}\n</code></pre>\n<p>obviously, <code>some_type</code> would be searched in the current namespace!</p>\n<blockquote>\n<p id=\"so_14669995_14670389_1\">Thus, when defining a hash&lt;&gt; functor for a user type, should we enclose it within a <code>namespace std { }</code> block, or can it remain in the current namespace?</p>\n</blockquote>\n<p>No! Do not try to reduce symbols count to type by providing a template specialization for <code>std::hash&lt;YourType&gt;</code> -- just write your own hash functor in your namespace and add it as a template parameter when instantiate <code>std::unordered_xxx</code>... </p>\n<p>Follow this simple rule: <strong>avoid to add smth into a <code>namespace</code> which is not under your control</strong> (ALL namespaces! not only <code>std</code>...) Except cases, when it is required (by some library) explicitly.</p>\n", "LastActivityDate": "2013-02-03T07:31:33.780", "CommentCount": "0", "CreationDate": "2013-02-03T07:31:33.780", "ParentId": "14669995", "Score": "-1", "OwnerUserId": "1655064"}});