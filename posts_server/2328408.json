post_cb({"2328408": {"CommentCount": "2", "ViewCount": "2001", "PostTypeId": "1", "LastEditorUserId": "207313", "CreationDate": "2010-02-24T18:19:38.027", "LastActivityDate": "2011-07-23T00:07:36.617", "Title": "default template arguments in c++", "AcceptedAnswerId": "2328573", "LastEditDate": "2010-02-24T18:32:52.370", "Id": "2328408", "Score": "3", "Body": "<p>Suppose i have a function template StrCompare<br/></p>\n<pre><code>template&lt;typename T=NonCaseSenCompare&gt;//NonCaseSenCompare is a user defined class look at the detailed code below.\nint StrCompare(char* str1, char* str2)\n{\n...\n}\n</code></pre>\n<p>now in the main function i write a line </p>\n<pre><code>char* str1=\"Zia\";\nchar* str2=\"zia\";\nint result=StrCompare(str1,str2);\n</code></pre>\n<p>it should work because we have provided a default template argument, but it does'nt <br>compiler gives the following error<br>\nno matching function for call to `StrCompare(char*&amp;, char*&amp;)' \nNow the detailed code is given by<br/></br></br></p>\n<pre><code>#include&lt;iostream.h&gt;\nclass CaseSenCompare\n{\npublic: \nstatic int isEqual(char x, char y)\n{\nreturn x==y;\n}\n};\nclass NonCaseSenCompare\n{\npublic:\nstatic int isEqual(char x,char y)\n{\nchar char1=toupper(x);\nchar char2=toupper(y);\nreturn char1==char2;\n}\n};\ntemplate&lt;typename T=NonCaseSenCompare&gt;\nint StrCompare(char* str1, char* str2)\n{\nfor(int i=0;i &lt; strlen(str1)&amp;&amp; strlen(str2);i++)\n{\nif(!T::isEqual(str1[i],str2[i]))\nreturn str1[i]-str2[i];\n}\nreturn strlen(str1)-strlen(str2);\n}\n\nmain()\n{\nchar* ptr1=\"Zia ur Rahman\";\nchar* ptr2=\"zia ur Rahman\";\nint result=StrCompare(ptr1,ptr2);//compiler gives error on this line\ncout&lt;&lt;result&lt;&lt;endl;\nsystem(\"pause\");\n}\n</code></pre>\n<p>If I write </p>\n<pre><code>int result=StrCompare&lt;&gt;(ptr1,ptr2);\n</code></pre>\n<p>compiler gives the same error message.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "238919", "AnswerCount": "4"}, "2328573": {"ParentId": "2328408", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As <a href=\"https://stackoverflow.com/questions/2328408/2328461#2328461\">gf</a> and <a href=\"https://stackoverflow.com/questions/2328408/2328485#2328485\">AndreyT</a> already wrote, you can't have default template arguments with function templates. However, if you turn your comparators  into function objects, you can still use default function arguments: </p>\n<pre><code>template&lt;typename Comp&gt;\nint StrCompare(char* str1, char* str2, Comp = NonCaseSenCompare())\n{\n  ...\n}\n</code></pre>\n<p>You can now call <code>StrCompare()</code> like this</p>\n<pre><code>StrCompare(\"abc\",\"aBc\",CaseSenCompare());\n</code></pre>\n<p>or like this:</p>\n<pre><code>StrCompare(\"abc\",\"aBc\"); // uses NonCaseSenCompare\n</code></pre>\n<p>A comparator would then have to look like this: </p>\n<pre><code>struct CaseSenCompare {\n  bool operator()(char x, char y) const {return x==y;}\n};\n</code></pre>\n<p>Adjust <code>StrCompare()</code> accordingly. </p>\n", "OwnerUserId": "140719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:49.347", "Id": "2328573", "Score": "5", "CreationDate": "2010-02-24T18:44:06.823", "LastActivityDate": "2010-02-24T18:44:06.823"}, "2328461": {"ParentId": "2328408", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><em>\u00a714.1/9</em>:</p>\n<blockquote>\n<p id=\"so_2328408_2328461_0\">A default template-argument shall not\n  be specified in a function template\n  declaration or a function template\n  definition, nor in the\n  template-parameter-list of the\n  definition of a member of a class\n  template.</p>\n</blockquote>\n<p>A simple work-around would be to move it into a class:</p>\n<pre><code>template&lt;typename T=NonCaseSenCompare&gt;\nstruct StrCompare {\n    static int compare(char* str1, char* str2) { /* ... */ }\n};\n</code></pre>\n", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2010-02-24T18:34:07.030", "Id": "2328461", "Score": "4", "CreationDate": "2010-02-24T18:28:37.973", "LastActivityDate": "2010-02-24T18:34:07.030"}, "6797337": {"ParentId": "2328408", "CommentCount": "1", "Body": "<p>What i use is next trick;</p>\n<p>lets say you want to have function like this</p>\n<pre><code>template &lt;typename E, typename ARR_E = MyArray_t&lt;E&gt; &gt; void doStuff(ARR_E array)\n{\n    E one(1);\n    array.add( one );\n}\n</code></pre>\n<p>you will not be allowed, but i do next way:</p>\n<pre><code>template &lt;typename E, typename ARR_E = MyArray_t&lt;E&gt; &gt;\nclass worker {\npublic:\n    /*static - as you wish */ ARR_E* parr_;\n    void doStuff(); /* do not make this one static also, MSVC complains */\n};\n\ntemplate &lt;typename E, typename ARR_E&gt;\nvoid worker::doStuff&lt;E, ARR_E&gt;::getChunks()\n{\n    E one(1);\n    parr_-&gt;add( one );\n}\n</code></pre>\n<p>so this way you may use it like this.</p>\n<pre><code>MyArray_t my_array;\nworker&lt;int&gt; w;\nw.parr_ = &amp;arr;\nw.doStuff();\n</code></pre>\n<p>as we can see no need to explicitly set second parameter.\nmaybe it will be useful for someone.</p>\n", "OwnerUserId": "837614", "PostTypeId": "2", "Id": "6797337", "Score": "0", "CreationDate": "2011-07-23T00:07:36.617", "LastActivityDate": "2011-07-23T00:07:36.617"}, "2328485": {"ParentId": "2328408", "CommentCount": "4", "Body": "<p>Firstly, function templates do not support default template arguments, only class templates do.</p>\n<p>Secondly, even when all <em>class</em> template parameters have default arguments, you still have to specify an empty <code>&lt;&gt;</code> to refer to that class template.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "2328485", "Score": "2", "CreationDate": "2010-02-24T18:31:48.247", "LastActivityDate": "2010-02-24T18:31:48.247"}, "bq_ids": {"n4140": {"so_2328408_2328461_0": {"section_id": 4706, "quality": 0.6, "length": 9}}, "n3337": {"so_2328408_2328461_0": {"section_id": 57, "quality": 0.5333333333333333, "length": 8}}, "n4659": {"so_2328408_2328461_0": {"section_id": 64, "quality": 0.6, "length": 9}}}});