post_cb({"4484913": {"Id": "4484913", "PostTypeId": "2", "Body": "<p><code>std::sort</code> must have average case linearithmic (n log n) time complexity.  Any algorithm may be used so long as that time complexity requirement is met.  There is no worst case time complexity requirement.</p>\n<p>If you want a guaranteed worst case time complexity function, use <code>std::stable_sort</code>, which has quasilinear worst case time complexity (n log^2 n).</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-12-19T20:42:03.903", "Score": "22", "CreationDate": "2010-12-19T20:23:21.590", "ParentId": "4484900", "CommentCount": "3", "OwnerUserId": "151292", "LastEditDate": "2010-12-19T20:42:03.903"}, "4484900": {"ViewCount": "22468", "Body": "<p>What is the complexity of std::sort() in the C++ Standard Library? Which sort is applied? Is there any rule of applying any particular sorting algorithm there?</p>\n", "Title": "What is the time complexity of std::sort() in the C++ standard library?", "CreationDate": "2010-12-19T20:20:44.410", "LastActivityDate": "2016-03-25T23:23:17.893", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2016-03-25T23:23:17.893", "LastEditorUserId": "5042431", "Id": "4484900", "Score": "27", "OwnerUserId": "547939", "Tags": "<c++><stl><time-complexity>", "AnswerCount": "5"}, "4484912": {"Id": "4484912", "PostTypeId": "2", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Sort_%28C%2B%2B%29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Sort_(C%2B%2B)</a></p>\n<blockquote>\n<p id=\"so_4484900_4484912_0\">The specific sorting algorithm is not mandated and may vary across implementations. The GNU Standard C++ library, for example, uses a hybrid sorting algorithm: introsort is performed first, to a maximum depth given by 2\u00d7log2 n, where n is the number of elements, followed by an insertion sort on the result.[1] Whatever the implementation, the complexity should be O(n log n) comparisons on the average. [2]</p>\n</blockquote>\n", "LastEditorUserId": "402169", "LastActivityDate": "2014-06-29T23:42:05.160", "Score": "4", "CreationDate": "2010-12-19T20:23:03.477", "ParentId": "4484900", "CommentCount": "0", "OwnerUserId": "66229", "LastEditDate": "2014-06-29T23:42:05.160"}, "4484916": {"Id": "4484916", "PostTypeId": "2", "Body": "<p>If you mean <code>std::sort()</code>:</p>\n<p>This is from C++03 standard, section 25.3. The performance guarantee:</p>\n<pre><code>template&lt;class RandomAccessIterator&gt;\nvoid sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate&lt;class RandomAccessIterator, class Compare&gt; void sort(RandomAccessIterator first, RandomAccessIterator last,\n    Compare comp);\n</code></pre>\n<blockquote>\n<p id=\"so_4484900_4484916_0\">1 Effects: Sorts the elements in the range [first, last).</p>\n<p id=\"so_4484900_4484916_1\">2 Complexity: Approximately N log N (where N == last - first) comparisons on the average.</p>\n</blockquote>\n", "LastEditorUserId": "297696", "LastActivityDate": "2010-12-19T20:32:30.863", "Score": "1", "CreationDate": "2010-12-19T20:23:43.027", "ParentId": "4484900", "CommentCount": "2", "OwnerUserId": "297696", "LastEditDate": "2010-12-19T20:32:30.863"}, "24481485": {"Id": "24481485", "PostTypeId": "2", "Body": "<h2>The standard guarantees</h2>\n<p>From the C++11/14 standard, <code>std::sort</code> is guaranteed to have:</p>\n<blockquote>\n<p id=\"so_4484900_24481485_0\"><strong>\u00a725.4.1.1/3</strong></p>\n<p id=\"so_4484900_24481485_1\">Complexity: <code>O(N log(N))</code> (where <code>N == last - first</code>) comparisons.</p>\n</blockquote>\n<p>The other, stable, standard sorting algorithm (namely <code>std::stable_sort</code>) is guaranteed to have:</p>\n<blockquote>\n<p id=\"so_4484900_24481485_2\"><strong>25.4.1.2/3</strong></p>\n<p id=\"so_4484900_24481485_3\">Complexity: It does at most <code>N log2(N)</code> (where <code>N == last - first</code>) comparisons; if enough extra memory is available, it is <code>N log(N)</code>.</p>\n</blockquote>\n<p>For <code>std::forward_list::stable</code>, instead:</p>\n<blockquote>\n<p id=\"so_4484900_24481485_4\"><strong>23.3.4.6/26</strong></p>\n<p id=\"so_4484900_24481485_5\">Complexity: Approximately <code>N log(N)</code> comparisons, where <code>N</code> is <code>distance(begin(), end())</code>.</p>\n</blockquote>\n<p>The same goes for <code>std::list</code>:</p>\n<blockquote>\n<p id=\"so_4484900_24481485_6\"><strong>23.3.5.5/31</strong></p>\n<p id=\"so_4484900_24481485_7\">Complexity: Approximately <code>N log(N)</code> comparisons, where <code>N == size()</code>.</p>\n</blockquote>\n<h2>Sorting algorithm</h2>\n<p>The C++ standard does not specify which sorting algorithm to apply in any of the above cases. This would be oftentimes and unnecessary implementation restriction.</p>\n<p>If you need to know you might have luck looking in a specific compiler specification. For example for GNU GCC you would start <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.4/a01027.html\" rel=\"nofollow\">here</a>.</p>\n", "LastActivityDate": "2014-06-30T00:23:33.943", "CommentCount": "1", "CreationDate": "2014-06-30T00:23:33.943", "ParentId": "4484900", "Score": "1", "OwnerUserId": "493122"}, "bq_ids": {"n4140": {"so_4484900_24481485_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 1402}, "so_4484900_4484916_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1286}, "so_4484900_24481485_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 953}, "so_4484900_24481485_3": {"length": 10, "quality": 0.7692307692307693, "section_id": 1405}, "so_4484900_24481485_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 898}}, "n3337": {"so_4484900_24481485_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 1396}, "so_4484900_4484916_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1281}, "so_4484900_24481485_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 941}, "so_4484900_24481485_3": {"length": 10, "quality": 0.7692307692307693, "section_id": 1399}, "so_4484900_24481485_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 884}}, "n4659": {"so_4484900_24481485_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 1523}, "so_4484900_4484916_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1409}, "so_4484900_24481485_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 1014}, "so_4484900_24481485_5": {"length": 5, "quality": 0.7142857142857143, "section_id": 958}, "so_4484900_24481485_3": {"length": 8, "quality": 0.6153846153846154, "section_id": 1523}}}, "4484915": {"Id": "4484915", "PostTypeId": "2", "Body": "<p>The complexity is <code>O(n log n)</code>. Some common implementations use introsort as far as I know:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Introsort\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Introsort</a></p>\n", "LastActivityDate": "2010-12-19T20:23:30.880", "CommentCount": "3", "CreationDate": "2010-12-19T20:23:30.880", "ParentId": "4484900", "Score": "4", "OwnerUserId": "499449"}});