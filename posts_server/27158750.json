post_cb({"27158950": {"ParentId": "27158750", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The problem is that <code>Type</code> is not a class, but a class template. You can do the following (this way you tell the compiler that <code>Type</code> is a class template in scope of <code>B</code>):</p>\n<pre><code>template&lt;typename T&gt;\nstruct B : A&lt;T&gt;\n{\n    using A&lt;T&gt;::Type;\n    typedef typename B::template Type&lt;int&gt; IntType;\n};\n</code></pre>\n<p>Actually, in your second example in order to write <code>typedef</code> for <code>IntType</code> you'd have to do the same.</p>\n", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2014-11-26T21:27:04.123", "Id": "27158950", "Score": "2", "CreationDate": "2014-11-26T21:10:53.970", "LastActivityDate": "2014-11-26T21:27:04.123"}, "27158750": {"CommentCount": "1", "ViewCount": "823", "PostTypeId": "1", "LastEditorUserId": "1690864", "CreationDate": "2014-11-26T20:58:05.747", "LastActivityDate": "2014-11-27T12:25:08.407", "Title": "Should a class-member using-declaration with a dependent qualified-id be a dependent name?", "LastEditDate": "2014-11-26T21:04:00.123", "Id": "27158750", "Score": "7", "Body": "<p>Draft N3337 of the C++11 standard states in <code>[namespace.udecl]</code></p>\n<blockquote>\n<p id=\"so_27158750_27158750_0\">A using-declaration introduces a name into the declarative region in which the using-declaration appears.</p>\n<p id=\"so_27158750_27158750_1\">Every using-declaration is a declaration and a member-declaration and so can be used in a class definition.</p>\n<p id=\"so_27158750_27158750_2\">In a using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the\n  class being defined.</p>\n</blockquote>\n<p>This is generally used to make a protected typedef within a base-class public in the derived class, as in the following example, which compiles successfully in the latest version of Clang:</p>\n<pre><code>struct A\n{\nprotected:\n    typedef int Type;\n};\n\nstruct B : A\n{\n    using A::Type;\n};\n\nB::Type x;\n</code></pre>\n<p>The using-declaration can refer to a template class. This compiles:</p>\n<pre><code>struct A\n{\nprotected:\n    template&lt;typename T&gt;\n    struct Type\n    {\n    };\n};\n\nstruct B : A\n{\n    using A::Type;\n};\n\nB::Type&lt;int&gt; x;\n</code></pre>\n<p>It's also possible to refer to a template in a dependent base-class. The following compiles successfully (with the typedef commented.)</p>\n<pre><code>template&lt;typename T&gt;\nstruct A\n{\nprotected:\n    template&lt;typename U&gt;\n    struct Type\n    {\n    };\n};\n\n\ntemplate&lt;typename T&gt;\nstruct B : A&lt;T&gt;\n{\n    using /* typename */ A&lt;T&gt;::Type; // A&lt;T&gt; is dependent, typename required?\n    // typedef Type&lt;int&gt; IntType; // error: unknown type name 'Type'\n};\n\nB&lt;int&gt;::Type&lt;int&gt; x;\n</code></pre>\n<p>Uncommenting the <code>typename</code> causes an error when instantiating <code>B&lt;int&gt;</code>: \"error: 'typename' keyword used on a non-type\".</p>\n<p>Uncommenting the typedef causes an error when parsing <code>B</code> before its first instantiation. I'm guessing this is because the compiler does not treat <code>Type</code> as a dependent type-name.</p>\n<p>The last paragraph of <code>[namespace.udecl]</code> suggests that using-declarations may specify dependent names, and that the <code>typename</code> keyword must be used in order to disambiguate further usage of the name introduced:</p>\n<blockquote>\n<p id=\"so_27158750_27158750_3\">If a using-declaration uses the keyword typename and specifies a dependent name (14.6.2), the name introduced\n  by the using-declaration is treated as a typedef-name</p>\n</blockquote>\n<p>My reading of <code>[temp.dep]</code> suggests that <code>A&lt;T&gt;::Type</code> is a dependent name. It follows logically that the name introduced by the using-declaration should also be dependent, but <code>[temp.dep]</code> does not explicitly mention the case of a dependent using-declaration. Am I missing something?</p>\n", "Tags": "<c++><templates><language-lawyer><using-declaration><dependent-name>", "OwnerUserId": "1690864", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27158750_27158750_2": {"section_id": 5492, "quality": 1.0, "length": 9}, "so_27158750_27158750_1": {"section_id": 5491, "quality": 1.0, "length": 7}, "so_27158750_27158750_0": {"section_id": 5490, "quality": 1.0, "length": 8}, "so_27158750_27159170_1": {"section_id": 5490, "quality": 1.0, "length": 8}, "so_27158750_27158750_3": {"section_id": 5508, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_27158750_27158750_2": {"section_id": 5278, "quality": 1.0, "length": 9}, "so_27158750_27158750_1": {"section_id": 5277, "quality": 1.0, "length": 7}, "so_27158750_27158750_0": {"section_id": 5276, "quality": 1.0, "length": 8}, "so_27158750_27159170_1": {"section_id": 5276, "quality": 1.0, "length": 8}, "so_27158750_27158750_3": {"section_id": 5294, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_27158750_27158750_0": {"section_id": 6924, "quality": 0.875, "length": 7}, "so_27158750_27158750_2": {"section_id": 6926, "quality": 1.0, "length": 9}, "so_27158750_27159170_1": {"section_id": 6924, "quality": 0.875, "length": 7}, "so_27158750_27158750_3": {"section_id": 6943, "quality": 0.8461538461538461, "length": 11}, "so_27158750_27158750_1": {"section_id": 6925, "quality": 1.0, "length": 7}}}, "27159170": {"ParentId": "27158750", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, a class-member using-declaration with a dependent qualified-id introduces a dependent name.</p>\n<blockquote>\n<p id=\"so_27158750_27159170_0\">[namespace.udecl]</p>\n<p id=\"so_27158750_27159170_1\">A using-declaration introduces a name into the declarative region in which the using-declaration appears.</p>\n</blockquote>\n<p>If the name introduced is dependent, it stays dependent - I can find nothing to suggest otherwise.</p>\n<p>However, the using-declaration syntax does not provide a way to specify that a dependent name is a template. Subsequent references to the dependent name <code>Type</code> within <code>B</code> may or may not refer to a template, so <code>Type&lt;int&gt;</code> cannot be parsed.</p>\n<p>The following example demonstrates valid usage of a dependent using-declaration.</p>\n<pre><code>template&lt;typename T&gt;\nstruct A\n{\nprotected:\n    struct Type\n    {\n        typedef int M;\n    };\n};\n\n\ntemplate&lt;typename T&gt;\nstruct B : A&lt;T&gt;\n{\n    using typename A&lt;T&gt;::Type;\n    typedef typename Type::M Type2;\n};\n\nB&lt;int&gt;::Type2 x;\n</code></pre>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2014-11-27T12:25:08.407", "Id": "27159170", "Score": "0", "CreationDate": "2014-11-26T21:26:53.007", "LastActivityDate": "2014-11-27T12:25:08.407"}});