post_cb({"3261778": {"Id": "3261778", "PostTypeId": "2", "Body": "<p>When any object is destroyed, destructors run for all sub-objects.  This includes both reuse by containment and reuse by inheritance.</p>\n", "LastActivityDate": "2010-07-16T03:41:35.277", "CommentCount": "0", "CreationDate": "2010-07-16T03:41:35.277", "ParentId": "3261694", "Score": "0", "OwnerUserId": "103167"}, "3261730": {"Id": "3261730", "PostTypeId": "2", "Body": "<p>This is by design. The destructor on the base class must be called in order for it to release its resources. Rule of thumb is that a derived class should only clean up its own resources and leave the base class to clean up itself.</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf\" rel=\"noreferrer\">C++ spec</a>:</p>\n<blockquote>\n<p id=\"so_3261694_3261730_0\">After executing the body of the\n  destructor and destroying any\n  automatic objects allocated within the\n  body, a destructor for class X calls\n  the destructors for X\u2019s direct\n  members, the destructors for X\u2019s\n  direct base classes and, if X is the\n  type of the most derived class\n  (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base\n  classes. All destructors are called as\n  if they were referenced with a\n  qualified name, that is, ignoring any\n  possible virtual overriding\n  destructors in more derived classes.\n  Bases and members are destroyed in the\n  reverse order of the completion of\n  their constructor (see\n  12.6.2).</p>\n</blockquote>\n<p>Also, because there is only one destructor, there is no ambiguity as to which destructor a class must call. This is not the case for constructors, where a programmer must pick which base class constructor should be called if there isn't an accessible default constructor.</p>\n", "LastEditorUserId": "129404", "LastActivityDate": "2010-07-16T04:51:28.187", "Score": "11", "CreationDate": "2010-07-16T03:27:14.847", "ParentId": "3261694", "CommentCount": "2", "OwnerUserId": "129404", "LastEditDate": "2010-07-16T04:51:28.187"}, "3261770": {"Id": "3261770", "PostTypeId": "2", "Body": "<p>The Standard says</p>\n<blockquote>\n<p id=\"so_3261694_3261770_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body,\n  a destructor for class X calls the destructors for X\u2019s direct non-variant members,<strong>the destructors for X\u2019s direct\n  base classes</strong> and, <strong>if X is the type of the most derived class (12.6.2), its destructor calls the destructors for\n  X\u2019s virtual base classes</strong>.  All destructors are called as if they were referenced with a quali\ufb01ed name, that is,\n  ignoring any possible virtual overriding destructors in more derived classes. <strong>Bases and members are destroyed\n  in the reverse order of the completion of their constructor</strong> (see 12.6.2).  A return statement (6.6.3) in a\n  destructor might not directly return to the caller; before transferring control to the caller, the destructors\n  for the members and bases are called.  Destructors for elements of an array are called in reverse order of\n  their construction (see 12.6).</p>\n</blockquote>\n<p>Also as per <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"noreferrer\">RAII</a> resources need to be tied to the lifespan of suitable objects and  the destructors of respective classes must be called upon to release the resources.</p>\n<p>For example the following code leaks memory.</p>\n<pre><code> struct Base\n {\n       int *p;\n        Base():p(new int){}\n       ~Base(){ delete p; } //has to be virtual\n };\n\n struct Derived :Base\n {\n       int *d;\n       Derived():Base(),d(new int){}\n       ~Derived(){delete d;}\n };\n\n int main()\n {\n     Base *base=new Derived();\n     //do something\n\n     delete base;   //Oops!! ~Base() gets called(=&gt;Memory Leak).\n }\n</code></pre>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-07-16T04:20:34.853", "Score": "13", "CreationDate": "2010-07-16T03:37:41.120", "ParentId": "3261694", "CommentCount": "5", "OwnerUserId": "165520", "LastEditDate": "2010-07-16T04:20:34.853"}, "3261694": {"ViewCount": "33749", "Body": "<p>A difference between a destructor (of course also the constructor) and other member functions is that, if a regular member function has a body at the derived class, only the version at Derived class gets executed. Whereas in case of destructors, both derived as well as base class versions get executed?</p>\n<p>It will be great to know what exactly happens in case of destructor (maybe virtual) &amp; constructor, that they are called for all its base classes  even if the most derived class object is deleted.</p>\n<p>Thanks in advance!</p>\n", "AcceptedAnswerId": "3261770", "Title": "Why base class destructor (virtual) is called when a derived class object is deleted?", "CreationDate": "2010-07-16T03:18:34.703", "Id": "3261694", "CommentCount": "1", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2010-07-16T03:35:21.817", "LastEditorUserId": "168225", "LastActivityDate": "2012-07-30T14:38:32.660", "Score": "25", "OwnerUserId": "360654", "Tags": "<c++><inheritance><destructor>", "AnswerCount": "7"}, "3261780": {"Id": "3261780", "PostTypeId": "2", "Body": "<p><strong>Constructor and destructor are different from the rest of regular methods.</strong></p>\n<p><strong>Constructor</strong></p>\n<ul>\n<li>can't be virtual</li>\n<li>in derived class you either call explicitly constructor of base class</li>\n<li>or, in case where you don't call base class constructor compiler will insert the call. It will call the base constructor without parameters. If no such constructor exists then you get compiler error.</li>\n</ul>\n<hr>\n<pre><code>struct A {};\nstruct B : A { B() : A() {} };\n\n// but this works as well because compiler inserts call to A():\nstruct B : A { B() {} };\n\n// however this does not compile:\nstruct A { A(int x) {} };\nstruct B : A { B() {} };\n\n// you need:\nstruct B : A { B() : A(4) {} };\n</code></pre>\n<p><strong>Destructor</strong>:</p>\n<ul>\n<li>when you call destructor on derived class over a pointer or a reference, where the base class has virtual destructor, the most derived destructor will be called first and then the rest of derived classes in reversed order of construction. This is to make sure that all memory has been properly cleaned. It would not work if the most derived class was called last because by that time the base class would not exists in memory and you would get segfault.</li>\n</ul>\n<hr>\n<pre><code>struct C\n{\n    virtual ~C() { cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; }\n};\n\nstruct D : C\n{\n    virtual ~D() { cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; }\n};\n\nstruct E : D\n{\n    virtual ~E() { cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; }\n};\n\nint main()\n{\n    C * o = new E();\n    delete o;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>~E\n~D\n~C\n</code></pre>\n<p>If the method in base class is marked as <code>virtual</code> all the inherited methods are virtual as well so even if you don't mark the destructors in <code>D</code> and <code>E</code> as <code>virtual</code> they will still be <code>virtual</code> and they still get called in the same order.</p>\n</hr></hr>", "LastActivityDate": "2010-07-16T03:42:23.950", "CommentCount": "0", "CreationDate": "2010-07-16T03:42:23.950", "ParentId": "3261694", "Score": "7", "OwnerUserId": "45654"}, "bq_ids": {"n4140": {"so_3261694_3261770_0": {"length": 79, "quality": 0.9294117647058824, "section_id": 404}, "so_3261694_3261730_0": {"length": 56, "quality": 0.9655172413793104, "section_id": 404}}, "n3337": {"so_3261694_3261770_0": {"length": 79, "quality": 0.9294117647058824, "section_id": 395}, "so_3261694_3261730_0": {"length": 56, "quality": 0.9655172413793104, "section_id": 395}}, "n4659": {"so_3261694_3261770_0": {"length": 79, "quality": 0.9294117647058824, "section_id": 422}, "so_3261694_3261730_0": {"length": 56, "quality": 0.9655172413793104, "section_id": 422}}}, "3261762": {"Id": "3261762", "PostTypeId": "2", "Body": "<p>A base class destructor may be responsible for cleaning up resources that were allocated by the base class constructor.</p>\n<p>If your base class has a default constructor (one that doesn't take parameters or has defaults for all its parameters) that constructor is automatically called upon construction of a derived instance.</p>\n<p>If your base class has a constructor that requires parameters, you must call it manually in the initializer list of the derived class constructor.</p>\n<p>Your base class destructor will always be automatically called upon deletion of the derived instance since destructors don't take parameters.</p>\n<p>If you're using polymorphism and your derived instance is pointed to by a base class pointer, then the <strong>derived</strong> class destructor is only called if the base destructor is virtual.</p>\n", "LastActivityDate": "2010-07-16T03:36:04.747", "CommentCount": "0", "CreationDate": "2010-07-16T03:36:04.747", "ParentId": "3261694", "Score": "2", "OwnerUserId": "350821"}, "3261741": {"Id": "3261741", "PostTypeId": "2", "Body": "<p>Because that's how dtor's work. When you create an object, ctors are invoked starting from the base, and going all the way to the most derived. When you destroy objects (correctly) the reverse happens. The time that making a dtor virtual makes a difference is if/when you destroy an object via a pointer (or reference, though that's fairly unusual) to the base type. In that case, the alternative isn't really that only the derived dtor gets invoked -- rather, the alternative is simply undefined behavior. That make happen to take the form of invoking only the derived dtor, but it might take an entirely different form as well.</p>\n", "LastActivityDate": "2010-07-16T03:30:52.450", "CommentCount": "0", "CreationDate": "2010-07-16T03:30:52.450", "ParentId": "3261694", "Score": "2", "OwnerUserId": "179910"}, "3261743": {"Id": "3261743", "PostTypeId": "2", "Body": "<p>As Igor says constructors must be called for base classes. Consider what would happen if it wouldn't be called:</p>\n<pre><code>struct A {\n    std::string s;\n    virtual ~A() {}\n};\n\nstruct B : A {};\n</code></pre>\n<p>If the destructor for <code>A</code> would not be called when deleting a <code>B</code> instance, <code>A</code> would never be cleaned up.</p>\n", "LastActivityDate": "2010-07-16T03:31:09.377", "CommentCount": "0", "CreationDate": "2010-07-16T03:31:09.377", "ParentId": "3261694", "Score": "2", "OwnerUserId": "168225"}});