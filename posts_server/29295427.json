post_cb({"bq_ids": {"n4140": {"so_29295427_29295427_0": {"length": 35, "quality": 0.875, "section_id": 5838}}, "n3337": {"so_29295427_29295427_0": {"length": 35, "quality": 0.875, "section_id": 5608}}, "n4659": {"so_29295427_29295427_0": {"length": 33, "quality": 0.825, "section_id": 7300}}}, "29296483": {"Id": "29296483", "PostTypeId": "2", "Body": "<p><code>fork</code> is a normal function just like other library functions it invokes <code>glibc fork()</code> wrapper rather than invoking system call directly.</p>\n<p>A compiler has no way to determine what does this function contain and a conformant compiler should always avoid optimizing this loop away and this would result in <a href=\"http://en.wikipedia.org/wiki/Fork_bomb\" rel=\"noreferrer\">fork bomb</a> as referred in one of the comment.</p>\n<p>To avoid the consequences, one should avoid the maximum number of processes a user can own.</p>\n<p>From man fork</p>\n<blockquote>\n<p id=\"so_29295427_29296483_0\">Since  version  2.3.3,  rather than invoking the kernel's fork() system call, the glibc fork() wrapper that is provided as part\n  of the NPTL threading implementation invokes clone(2) with flags\n  that provide the same effect as the traditional system call.  The glibc wrapper invokes any fork handlers that have been established\n  using pthread_atfork(3).</p>\n</blockquote>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2015-03-27T12:56:07.163", "Score": "9", "CreationDate": "2015-03-27T08:45:53.703", "ParentId": "29295427", "CommentCount": "12", "OwnerUserId": "2659313", "LastEditDate": "2015-03-27T12:56:07.163"}, "29295427": {"ViewCount": "855", "Body": "<p>Considering</p>\n<i>C++11 \u00a71.10/24 (in [intro.multithread])</i>\n<blockquote>\n<p id=\"so_29295427_29295427_0\"><strong>\u201d</strong> The implementation may assume that any thread will eventually do one of the following:<br>\n  \u2014 terminate,<br>\n  \u2014 make a call to a library I/O function,<br>\n  \u2014 access or modify a volatile object, or<br>\n  \u2014 perform a synchronization operation or an atomic operation.<br>\n  [Note: This is intended to allow compiler transformations such as removal of empty loops, even when\n  termination cannot be proven. \u2014end note ]</br></br></br></br></br></p>\n</blockquote>\n<p>\u2026 is the compiler allowed to optimize away the following loop:</p>\n<pre><code>int main(int argc, char* argv[]) {\n    while ( true )\n        fork();\n}\n</code></pre>\n<p>?</p>\n<p>(There is some earlier discussion at (<a href=\"https://stackoverflow.com/questions/3592557/optimizing-away-a-while1-in-c0x\">Optimizing away a \"while(1);\" in C++0x</a>), but it does not seem to answer the case of a <code>fork</code> call in the loop.)</p>\n", "Title": "Why is a `fork()` call not optimized away in an infinite loop?", "CreationDate": "2015-03-27T07:30:39.483", "LastActivityDate": "2015-04-05T15:28:52.460", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:24.660", "Tags": "<c++><c++11><fork><posix>", "Id": "29295427", "LastEditorUserId": "-1", "Score": "-22", "OwnerUserId": "4719638", "ClosedDate": "2016-08-24T22:14:23.207", "AnswerCount": "1"}});