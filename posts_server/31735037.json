post_cb({"31735037": {"CommentCount": "8", "ViewCount": "351", "PostTypeId": "1", "LastEditorUserId": "50385", "CreationDate": "2015-07-30T22:18:00.870", "LastActivityDate": "2015-07-31T09:18:34.127", "Title": "Is there any way for constexpr objects to refer/point to other non-static constexpr objects?", "AcceptedAnswerId": "31740377", "LastEditDate": "2015-07-30T22:43:36.573", "Id": "31735037", "Score": "2", "Body": "<p>Say I want to build a graph at compile time, using some algorithm, and then count how many nodes ended up in the graph. This seems like an ideal situation for constexpr, rather than template metaprogramming, since the goal is a computation that yields a value, rather than really being about types. I have some code that works, but the feature is so new I'm afraid the compilers are being lenient, and I could interpret part of the standard as saying I can't do this.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { int x; constexpr A(int i) noexcept : x{i} {} };\nstruct B { A&amp; a; constexpr B(A&amp; a) noexcept : a{a} {} };\n\nconstexpr int foo() { \n    A a{55};\n    B b{a};\n    return b.a.x;\n}\n\ntemplate&lt;int N&gt;\nvoid output()\n{\n    std::cout &lt;&lt; N &lt;&lt; std::endl;\n}\n\nint main() {\n    // to be absolutely sure compile time eval'd,\n    // pass as template arg\n    constexpr auto b = foo();\n    output&lt;b&gt;();\n}\n</code></pre>\n<p>Both the <code>a</code> and <code>b</code> instances are created at compile time, and they have the same lifetime so this should be \"safe\". But <code>a</code> is a non-static object, and <a href=\"http://eel.is/c++draft/expr.const#5\" rel=\"nofollow\">this part of the standard</a> seems to say that's not allowed:</p>\n<blockquote>\n<p id=\"so_31735037_31735037_0\">An entity is a permitted result of a constant expression if it is an\n  object with static storage duration that is either not a temporary\n  object or is a temporary object whose value satisfies the above\n  constraints, or it is a function.</p>\n</blockquote>\n<p>So can I or can't I? <a href=\"http://melpon.org/wandbox/permlink/2VOpd7U0YfbdtPBq\" rel=\"nofollow\">GCC and clang are both fine with it.</a></p>\n", "Tags": "<c++><metaprogramming><standards><c++14><constexpr>", "OwnerUserId": "50385", "AnswerCount": "3"}, "31739204": {"ParentId": "31735037", "CommentCount": "1", "CreationDate": "2015-07-31T06:11:51.507", "OwnerUserId": "257645", "PostTypeId": "2", "Id": "31739204", "Score": "0", "Body": "<p>In a nutshell, you can't pass non-static/temporary values as references at compile time. You can pass static/global values as <code>constexpr</code> references. But anything else is simply not available <em>at compile time</em>.</p>\n<pre><code>constexpr void foo() {\n    int a; // run-time value.\n    ...\n}\n</code></pre>\n<p>An obvious solution would be to pass by value. It's happening at compile time, so you might not get the usual optimizations, but it's also <em>happening at compile time</em>.</p>\n<p><a href=\"http://ideone.com/J7mVj5\" rel=\"nofollow\">http://ideone.com/J7mVj5</a></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { int x; constexpr A(int i) noexcept : x{i} {} };\nstruct B { A a; constexpr B(A a) noexcept : a{a} {} };\n\nconstexpr int foo() { \n    B b{55};\n    return b.a.x;\n}\n\ntemplate&lt;int N&gt;\nvoid output()\n{\n    std::cout &lt;&lt; N &lt;&lt; std::endl;\n}\n\nint main() {\n    // to be absolutely sure compile time eval'd,\n    // pass as template arg\n    constexpr auto b = foo();\n    output&lt;b&gt;();\n}\n</code></pre>\n<p>See also <a href=\"http://ideone.com/tw4jzG\" rel=\"nofollow\">http://ideone.com/tw4jzG</a></p>\n", "LastActivityDate": "2015-07-31T06:11:51.507"}, "31736000": {"ParentId": "31735037", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-30T23:58:14.387", "Score": "0", "LastEditorUserId": "1708801", "LastEditDate": "2015-07-31T09:18:34.127", "Id": "31736000", "OwnerUserId": "1708801", "Body": "<p>In your example:</p>\n<pre><code>B b{a};\n</code></pre>\n<p><code>b</code> is not a constexpr variable the draft C++14 section <code>7.1.5</code> <em>[dcl.constexpr]p5</em> which says:</p>\n<blockquote>\n<p id=\"so_31735037_31736000_0\">A constexpr specifier used in an object declaration declares the object as const. Such an object shall have\n  literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19). Otherwise, or if a constexpr specifier is used in a reference declaration, every fullexpression\n  that appears in its initializer shall be a constant expression. [ Note: Each implicit conversion\n  used in converting the initializer expressions and each constructor call used for the initialization is part of\n  such a full-expression. \u2014end note ]</p>\n</blockquote>\n<p>does not apply but if we modify your example slightly:</p>\n<pre><code>int main() {\n    constexpr auto b = foo();\n    A a1(42) ;\n    constexpr B b1( a1 ) ;\n}\n</code></pre>\n<p>and introduce <code>b1</code> which is a constexpr variable then this will not work (<em><a href=\"http://melpon.org/wandbox/permlink/bQtKINMPdcxjNCM9\" rel=\"nofollow\">see it live</a></em>), clang says:</p>\n<pre><code>error: 'B{a1}' is not a constant expression\n     constexpr B b1( a1 ) ;\n                        ^\n</code></pre>\n<p>if we further modify the example from above as follows though:</p>\n<pre><code>static A a1(42) ;\nconstexpr B b1( a1 ) ;\n</code></pre>\n<p>it will work. A constexpr function is available for use in a constexpr but if it does not satisfy the requirements it will not yield a constant expression.</p>\n", "LastActivityDate": "2015-07-31T09:18:34.127"}, "bq_ids": {"n4140": {"so_31735037_31740377_0": {"section_id": 6185, "quality": 1.0, "length": 12}, "so_31735037_31736000_0": {"section_id": 5425, "quality": 0.9166666666666666, "length": 44}}, "n3337": {"so_31735037_31740377_0": {"section_id": 5946, "quality": 0.75, "length": 9}, "so_31735037_31736000_0": {"section_id": 5220, "quality": 0.8541666666666666, "length": 41}}, "n4659": {"so_31735037_31740377_0": {"section_id": 7687, "quality": 1.0, "length": 12}, "so_31735037_31735037_0": {"section_id": 7690, "quality": 1.0, "length": 20}}}, "31740377": {"ParentId": "31735037", "CommentCount": "2", "CreationDate": "2015-07-31T07:22:58.457", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "31740377", "Score": "5", "Body": "<p>Yes, your example is conforming.</p>\n<p>The special thing about C++14 relaxed <code>constexpr</code> is that intermediate results inside the evaluation of a constant expression do not themselves need to be constant expressions.</p>\n<p><code>return</code> applies an lvalue-to-rvalue conversion to <code>b.a.x</code>, because the function returns by value, and <code>b.a.x</code> is:</p>\n<blockquote>\n<p id=\"so_31735037_31740377_0\">a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of <code>e</code></p>\n</blockquote>\n<p>(N4527 \u00a75.20/2.7.4)</p>\n<p>If you tried to save a (dangling) <em>reference</em> to <code>b.a.x</code>, that would be a problem. That would not be a \"permitted result of a constant expression\" per your quote.</p>\n", "LastActivityDate": "2015-07-31T07:22:58.457"}});