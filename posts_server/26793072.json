post_cb({"bq_ids": {"n4140": {"so_26793072_26793233_1": {"length": 43, "quality": 0.8113207547169812, "section_id": 6050}, "so_26793072_26793404_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6050}, "so_26793072_26793233_0": {"length": 7, "quality": 1.0, "section_id": 6040}, "so_26793072_26793255_0": {"length": 42, "quality": 0.7924528301886793, "section_id": 6050}}, "n3337": {"so_26793072_26793233_1": {"length": 32, "quality": 0.6037735849056604, "section_id": 5818}, "so_26793072_26793404_0": {"length": 17, "quality": 1.0, "section_id": 5818}, "so_26793072_26793233_0": {"length": 7, "quality": 1.0, "section_id": 5808}, "so_26793072_26793255_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 5818}}, "n4659": {"so_26793072_26793233_1": {"length": 43, "quality": 0.8113207547169812, "section_id": 7549}, "so_26793072_26793404_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7549}, "so_26793072_26793233_0": {"length": 7, "quality": 1.0, "section_id": 7539}, "so_26793072_26793255_0": {"length": 42, "quality": 0.7924528301886793, "section_id": 7549}}}, "26793072": {"ViewCount": "734", "Body": "<p>Is the following code legal (by C++11 and/or C++14 standard(s))?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nvoid foo(int &amp;a) {\n    cout &lt;&lt; a &lt;&lt; endl;\n}\n\nint main() {\n    foo(reinterpret_cast&lt;int &amp;&gt;(move(5)));\n}\n</code></pre>\n<ul>\n<li>If yes, is it undefined behavior?</li>\n<li>If it's not undefined behavior, can I even mutate <code>a</code> inside <code>foo</code> without it becoming UB?</li>\n</ul>\n<p>It compiles on clang 3.5, not on gcc 4.9.\nGCC error:</p>\n<pre><code>\u27a4 g++-4.9 -std=c++1y sample.cpp -o sample                                                                                        \nsample.cpp: In function 'int main()':\nsample.cpp:11:40: error: invalid cast of an rvalue expression of type 'std::remove_reference&lt;int&gt;::type {aka int}' to type 'int&amp;'\n     foo(reinterpret_cast&lt;int &amp;&gt;(move(5)));\n                                        ^\n</code></pre>\n<h1>EDIT</h1>\n<p>FYI, a custom made cast that's less hairy than the previous, and which works on C++11 for both GCC and Clang, would be the following <code>lvalue</code> function:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace non_std {\n    template &lt;typename T&gt;\n    constexpr T &amp;lvalue(T &amp;&amp;r) noexcept { return r; }\n}\n\nvoid divs(int &amp;a, int &amp;b) {\n    int t = a;\n    a /= b;\n    b /= t;\n}\n\nint main() {\n    using namespace std;\n    using namespace non_std;\n\n    int i_care_for_this_one = 4;\n    divs(i_care_for_this_one, lvalue(2));\n    cout &lt;&lt; i_care_for_this_one &lt;&lt; endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "26793255", "Title": "Can reinterpret_cast (or any cast) convert xvalues to lvalues?", "CreationDate": "2014-11-07T02:30:38.830", "Id": "26793072", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-11-21T03:18:58.323", "LastEditorUserId": "1000282", "LastActivityDate": "2014-11-21T03:18:58.323", "Score": "8", "OwnerUserId": "1000282", "Tags": "<c++><c++11><language-lawyer><c++14><reinterpret-cast>", "AnswerCount": "3"}, "26793233": {"Id": "26793233", "PostTypeId": "2", "Body": "<p>The relevant section in the standard is 5.2.10 [expr.reinterpret.cast]. There are two relevant paragraphs:</p>\n<p>First, there is paragraph 1 which ends in:</p>\n<blockquote>\n<p id=\"so_26793072_26793233_0\">No other conversion can be performed explicitly using reinterpret_cast.</p>\n</blockquote>\n<p>... and paragraph 11 as none of the other apply:</p>\n<blockquote>\n<p id=\"so_26793072_26793233_1\">A glvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. The result refers to the same object as the source glvalue, but with the specified type. [ Note: That is, for lvalues, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x))</code>. \u2014end note ] No temporary is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.</p>\n</blockquote>\n<p>All the other clauses don't apply to objects but only to pointers, pointers to functions, etc. Since an rvalue is not a glvalue, the code is illegal.</p>\n", "LastActivityDate": "2014-11-07T02:50:32.167", "Score": "1", "CreationDate": "2014-11-07T02:50:32.167", "ParentId": "26793072", "CommentCount": "6", "OwnerUserId": "1120273"}, "26793404": {"Id": "26793404", "PostTypeId": "2", "Body": "<p>The issue turns on whether reinterpret_cast is allowed to convert xvalues to lvalues. Contrary to what others are pasting, the relevant paragraph (5.2.10.11) only mentions lvalues:</p>\n<blockquote>\n<p id=\"so_26793072_26793404_0\">An lvalue expression of type T1 can be cast to the type \u201creference to\n  T2\u201d if an \n      expression of type \u201cpointer to T1\u201d can be explicitly converted to the type \n      \u201cpointer to T2\u201d using a reinterpret_cast..</p>\n</blockquote>\n<p>There is a proposal submitted by Michael Wong to change the wording to glvalue, but it appears to have hit a wall:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1268\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1268</a></p>\n<p>I take it that this means, as of now, the conversion is not legal, since it only explicitly allows the conversion from lvalues.</p>\n", "LastActivityDate": "2014-11-07T03:11:43.573", "Score": "4", "CreationDate": "2014-11-07T03:11:43.573", "ParentId": "26793072", "CommentCount": "1", "OwnerUserId": "4216528"}, "26793255": {"Id": "26793255", "PostTypeId": "2", "Body": "<p><strong>Update:</strong> The code is ill-formed in C++11. Answer below is for C++14. See note at the end of this answer.</p>\n<p>I believe this code is both <strong>well-formed</strong> and <strong>well-defined</strong>. Here's why.</p>\n<p>The result of <code>std::move</code> is an xvalue [1], which is a type of glvalue; and converting a glvalue to an lvalue reference with <code>reinterpret_cast</code> appears to be allowed by the wording of the standard:</p>\n<blockquote>\n<p id=\"so_26793072_26793255_0\">A glvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer\n  to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. The result refers\n  to the same object as the source glvalue, but with the specified type. [ Note: That is, for lvalues, a reference\n  cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with\n  the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). \u2014 end note ] No temporary\n  is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.73</p>\n</blockquote>\n<p>Since \"pointer to <code>int</code>\" can be converted to \"pointer to <code>int</code>\", this <code>reinterpret_cast</code> is also allowed. The standard doesn't say anything about whether the destination type has to be an lvalue reference or rvalue reference.</p>\n<p>The result of the cast is well-defined by the paragraph above: it refers to the same object as the source glvalue---that is, a temporary <code>int</code> object with the value <code>5</code>. ([dcl.init.ref] specifies that a temporary is created when a prvalue is bound to a reference.)</p>\n<p>Accessing the value through the <code>int&amp;</code> also doesn't violate any aliasing rules since the original object was also of type <code>int</code>. In fact I believe it would even be well-defined to modify the temporary through the lvalue thus obtained.</p>\n<p><strong>Note:</strong> The C++11 wording says \"lvalue expression\", not \"glvalue expression\". The wording with \"glvalue expression\" is from N3936, which is the final working draft for C++14. I'm not an expert in how the standardization process works, but I believe this means that the change of \"lvalue\" to \"glvalue\" was already voted in by the committee, and when ISO publishes the C++14 standard, it's going to be pretty similar to what it says above.</p>\n<p>[1] Except in the rare case in which the argument is a function; in that case the result is an lvalue, since there are no function rvalues.</p>\n", "LastEditorUserId": "481267", "LastActivityDate": "2014-11-07T04:23:26.053", "Score": "7", "CreationDate": "2014-11-07T02:53:34.673", "ParentId": "26793072", "CommentCount": "3", "LastEditDate": "2014-11-07T04:23:26.053", "OwnerUserId": "481267"}});