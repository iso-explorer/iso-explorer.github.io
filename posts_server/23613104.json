post_cb({"23613104": {"CommentCount": "7", "ViewCount": "518", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-12T15:29:26.943", "LastActivityDate": "2014-05-13T07:45:28.493", "Title": "Non-copyable deleter in std::unique_ptr", "AcceptedAnswerId": "23625482", "LastEditDate": "2017-05-23T10:33:21.153", "Id": "23613104", "Score": "2", "Body": "<p>I've just been looking at solutions to another question (<a href=\"https://stackoverflow.com/questions/23610561/return-locked-resource-from-class-with-automatic-unlocking?noredirect=1#comment36246246_23610561\">this one</a>). It seems that it should be possible to create a custom deleter for a <code>unique_ptr</code> instance that can unlock a mutex.</p>\n<p>For example,</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;memory&gt;\n\nstruct LockDeleter\n{\n  std::unique_lock&lt;std::mutex&gt; lock_;\n\n  LockDeleter(std::mutex&amp; m) : lock_(m) {}\n  void operator()(void*) { lock_.unlock(); }\n};\n\nint main()\n{\n  std::mutex moo;\n\n  {\n    std::unique_ptr&lt;int, LockDeleter&gt; ptr(new int(42), LockDeleter(moo));\n  }\n}\n</code></pre>\n<p>Compiling this under VS2013 express, I get</p>\n<blockquote>\n<p id=\"so_23613104_23613104_0\">Error  1   error C2280: 'std::unique_lock::unique_lock(const std::unique_lock &amp;)' : attempting to reference a deleted function</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_23613104_23613104_1\">This diagnostic occurred in the compiler generated function 'LockDeleter::LockDeleter(const LockDeleter &amp;)'</p>\n</blockquote>\n<p>Now, I can't seem to <em>force</em> the lock deleter instance to be moved, rather than copied using <code>std::move</code>... even adding an explicit move constructor to <code>LockDeleter</code> doesn't help, and the deleted copy constructor still gets called.</p>\n<p>So, am I doing something silly, or must <code>unique_ptr</code> deleters always be copy constructable?</p>\n", "Tags": "<c++><c++11><move><unique-ptr>", "OwnerUserId": "1450890", "AnswerCount": "1"}, "23625482": {"ParentId": "23613104", "CommentCount": "0", "CreationDate": "2014-05-13T07:45:28.493", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "23625482", "Score": "1", "Body": "<p><code>unique_ptr</code> is required to support move-constructible deleters; <strong>20.7.1.2.1 [unique.ptr.single.ctor]</strong>:</p>\n<blockquote>\n<p id=\"so_23613104_23625482_0\">9 - [...] if [the deleter type] <code>D</code> is non-reference type <code>A</code>, then the [two-argument constructor] signatures are:</p>\n<pre><code>unique_ptr(pointer p, const A&amp; d);\nunique_ptr(pointer p, A&amp;&amp; d);\n</code></pre>\n<p id=\"so_23613104_23625482_1\">[...]</p>\n<p id=\"so_23613104_23625482_2\">12 - <em>Requires:</em> [...]</p>\n<ul>\n<li>[if <code>d</code> is a non-const rvalue then] <code>D</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 20), and the move constructor of <code>D</code> shall not throw an exception. This <code>unique_ptr</code> will hold a value move constructed from <code>d</code>. [...]</li>\n</ul>\n</blockquote>\n<p>If we explicitly add a move constructor and delete the copy constructor from <code>LockDeleter</code> then we get a more informative error message; <a href=\"http://rextester.com/XFYUG91939\" rel=\"nofollow\">http://rextester.com/XFYUG91939</a>:</p>\n<pre><code>Error(s):\nC:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\memory(1243) : error C2280: 'LockDeleter::LockDeleter(const LockDeleter &amp;)' : attempting to reference a deleted function\n        source_file.cpp(10) : see declaration of 'LockDeleter::LockDeleter'\n        C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\memory(1241) : while compiling class template member function 'std::_Unique_ptr_base&lt;_Ty,_Dx,false&gt;::_Unique_ptr_base(int *,_Dx)'\n        with\n        [\n            _Ty=int\n,            _Dx=LockDeleter\n        ]\n        C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\memory(1380) : see reference to function template instantiation 'std::_Unique_ptr_base&lt;_Ty,_Dx,false&gt;::_Unique_ptr_base(int *,_Dx)' being compiled\n        with\n        [\n            _Ty=int\n,            _Dx=LockDeleter\n        ]\n        C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\memory(1331) : see reference to class template instantiation 'std::_Unique_ptr_base&lt;_Ty,_Dx,false&gt;' being compiled\n        with\n        [\n            _Ty=int\n,            _Dx=LockDeleter\n        ]\n        source_file.cpp(20) : see reference to class template instantiation 'std::unique_ptr&lt;int,LockDeleter&gt;' being compiled\n</code></pre>\n<p>Note the mention of <code>std::_Unique_ptr_base&lt;_Ty,_Dx,false&gt;::_Unique_ptr_base(int *,_Dx)</code>; this indicates that the deleter parameter is incorrectly being copied into the internal base class, when it should be being moved.</p>\n<p>The only workaround I can see is to make <code>lock_</code> mutable, allowing a copy constructor to operate as a move constructor.</p>\n", "LastActivityDate": "2014-05-13T07:45:28.493"}, "bq_ids": {"n4140": {"so_23613104_23625482_0": {"section_id": 4302, "quality": 0.625, "length": 5}}, "n3337": {"so_23613104_23625482_0": {"section_id": 4143, "quality": 0.625, "length": 5}}, "n4659": {"so_23613104_23625482_0": {"section_id": 5560, "quality": 0.625, "length": 5}}}});