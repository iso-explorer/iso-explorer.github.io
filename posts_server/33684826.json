post_cb({"33684826": {"CommentCount": "2", "AcceptedAnswerId": "33684863", "ClosedDate": "2015-11-13T02:42:24.623", "CreationDate": "2015-11-13T02:07:36.433", "LastActivityDate": "2015-11-13T02:38:14.240", "PostTypeId": "1", "ViewCount": "129", "Title": "C++ Why does the \"const volatile\" type qualifier exist?", "Id": "33684826", "Score": "1", "Body": "<p>Say I have some object declared as <code>const volatile</code>:</p>\n<p>According to the C++ standard ($7.1.5.1/8):</p>\n<blockquote>\n<p id=\"so_33684826_33684826_0\">[..] volatile is a hint to the implementation to avoid aggressive\n  optimization involving the object <b>because the value of the object\n  might be changed</b> by means undetectable by an implementation.[...]</p>\n</blockquote>\n<p>However, the <code>const</code> qualifier implies than the object is <i><b>not</b></i> subject to change, so the two qualifiers appear to conflict:</p>\n<p>One implies the object should be treated differently because it is subject to change, and the other implies it should be treated differently because it is <i>not</i> subject to change. </p>\n<p>So, why are variables allowed be be <code>const volatile</code> in the first place? </p>\n", "Tags": "<c++><const><volatile>", "OwnerUserId": "4404330", "AnswerCount": "2"}, "33684846": {"ParentId": "33684826", "CommentCount": "0", "Body": "<p>This doesn\u2019t make much sense:</p>\n<pre><code>int const volatile x = 42;\n</code></pre>\n<p>You\u2019re right, <code>x</code> cannot be changed \u2014 drop <code>volatile</code>. However, the following is different:</p>\n<pre><code>int x = 42;\nint const volatile&amp; y = x;\n</code></pre>\n<p>Now <code>y</code> cannot be changed, but <code>x</code> can, and its change propagates through to <code>y</code>. This works regardless of <code>volatile</code>, of course \u2014 but if the change to <code>y</code> comes from a source that is unobservable to the C++ compiler, <code>volatile</code> may become necessary. Of course in cases where <code>volatile</code> makes sense, the pointer/reference wouldn\u2019t just refer to any other variable but rather to a specific memory address that is mapped to the hardware or elsewhere.</p>\n", "OwnerUserId": "1968", "PostTypeId": "2", "Id": "33684846", "Score": "1", "CreationDate": "2015-11-13T02:11:04.453", "LastActivityDate": "2015-11-13T02:11:04.453"}, "bq_ids": {"n4140": {"so_33684826_33684826_0": {"section_id": 5436, "quality": 1.0, "length": 16}}, "n3337": {"so_33684826_33684826_0": {"section_id": 5231, "quality": 1.0, "length": 16}}, "n4659": {"so_33684826_33684826_0": {"section_id": 6863, "quality": 1.0, "length": 16}}}, "33684863": {"ParentId": "33684826", "CommentCount": "0", "Body": "<p>If you define</p>\n<pre><code>const some_type x = some_value;\n</code></pre>\n<p>that means you can't modify the value of <code>x</code>.  In the absence of <code>volatile</code>, the compiler can replace a reference to <code>x</code> by <code>some_value</code>.</p>\n<p>If you define</p>\n<pre><code>const volatile some_type x = some_value;\n</code></pre>\n<p>then you still can't modify <code>x</code> (at least not by using the name <code>x</code>), but the compiler can no longer assume that its value cannot change.  Any reference to the value of <code>x</code> must actually load its value from memory; it can't assume that it will always retain its initial value.</p>\n<p>For example, there might be some compiler-specific attribute that associates <code>x</code> with some device.  The name <code>x</code> provides a read-only view of the object; the <code>volatile</code> inhibits certain optimizations.</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "33684863", "Score": "3", "CreationDate": "2015-11-13T02:13:20.073", "LastActivityDate": "2015-11-13T02:13:20.073"}});