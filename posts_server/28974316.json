post_cb({"bq_ids": {"n4140": {"so_28974316_28974609_3": {"length": 26, "quality": 0.8125, "section_id": 3242}, "so_28974316_28974609_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5408}, "so_28974316_28974609_0": {"length": 33, "quality": 1.0, "section_id": 3364}}, "n3337": {"so_28974316_28974609_3": {"length": 26, "quality": 0.8125, "section_id": 3115}, "so_28974316_28974609_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5203}, "so_28974316_28974609_0": {"length": 33, "quality": 1.0, "section_id": 3234}}, "n4659": {"so_28974316_28974609_3": {"length": 24, "quality": 0.75, "section_id": 4000}, "so_28974316_28974609_2": {"length": 28, "quality": 0.9032258064516129, "section_id": 6830}}}, "28974609": {"Id": "28974609", "PostTypeId": "2", "Body": "<p>This seems to be a bug in GCC; Clang rejects both as exception specifications are not allowed in type aliases or <code>typedef</code>s. This can be found in:</p>\n<blockquote>\n<h3>15.4 Exception specifications [except.spec]</h3>\n<p id=\"so_28974316_28974609_0\"><sup>2</sup> An <em>exception-specification</em> shall appear only on a function declarator for a function type, pointer to function type, reference to function type, or pointer to member function type that is the top-level type of a declaration or definition, or on such a type appearing as a parameter or return type in a function declarator. <strong>An <em>exception-specification</em> shall not appear in a typedef declaration or <em>alias-declaration</em>.</strong></p>\n<p id=\"so_28974316_28974609_1\">[...]</p>\n</blockquote>\n<p>The standard also explicitly says that both should be consistent:</p>\n<blockquote>\n<h3>7.1.3 The <code>typedef</code> specifier [dcl.typedef]</h3>\n<p id=\"so_28974316_28974609_2\"><sup>2</sup> A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. The identifier following the <code>using</code> keyword becomes a <em>typedef-name</em> and the optional <em>attribute-specifier-seq</em> following the identifier appertains to that <em>typedef-name</em>. <strong>It has the same semantics as if it were introduced by the <code>typedef</code> specifier</strong>. In particular, it does not define a new type and it shall not appear in the <em>type-id</em>. </p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>To answer your second question: GCC probably just ignores the exception specification as functions can not be overloaded on just the exception specification - it is not part of the function's signature. This can be found here:</p>\n<blockquote>\n<h3>8.3.5 Functions [dcl.fct]</h3>\n<p id=\"so_28974316_28974609_3\"><sup>6</sup> [...] The return type, the parameter-type-list, the <em>ref-qualifier</em>, and the <em>cv-qualifier-seq</em>, but not the default arguments (8.3.6) or the exception specification (15.4), are part of the function type. [ <em>Note:</em> Function types are checked during the assignments and initializations of pointers to functions, references to functions, and pointers to member functions. \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2015-03-10T21:59:41.227", "Score": "7", "CreationDate": "2015-03-10T21:40:56.747", "ParentId": "28974316", "CommentCount": "2", "OwnerUserId": "2073257", "LastEditDate": "2015-03-10T21:59:41.227"}, "28974316": {"ViewCount": "271", "Body": "<p>I realized that I can declare a type for a pointer to <code>noexcept</code> function via <code>using</code>, but I am forbidden such declaration if I use a <code>typedef</code>. Consider the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing fptr = void(*)() noexcept;\n// typedef void(*FPTR)() noexcept; // fails to compile\n\nvoid f() noexcept\n{\n    std::cout &lt;&lt; \"void f() noexcept\" &lt;&lt; std::endl;\n}\n\nvoid g()\n{\n    std::cout &lt;&lt; \"void g()\" &lt;&lt; std::endl;\n    throw 10;\n}\n\nint main()\n{\n    fptr f1 = f;\n    fptr f2 = g; // why can we do this?\n\n    try {\n        f1();\n        f2();\n    }\n    catch (...)\n    {\n        std::cout &lt;&lt; \"Exception caught\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>If I uncomment the <code>FPTR</code> declaration, I'm getting </p>\n<blockquote>\n<p id=\"so_28974316_28974316_0\"><code>error: 'FPTR' declared with an exception specification</code></p>\n</blockquote>\n<p>However, the <code>using</code> works just fine. Compiled with both gcc4.9 and gcc5. </p>\n<p>My questions are:</p>\n<ol>\n<li>Why this inconsistency?</li>\n<li>Why can we even use <code>using</code> with <code>noexcept</code> since we can bind the pointer to functions not declared <code>noexcept</code>, as in the line <code>fptr f2 = g;</code></li>\n</ol>\n<hr>\n<p>Seems to be a bug related to gcc, even gcc5 doesn't catch it. Filled a bug report</p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65382\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65382</a></p>\n</hr>", "AcceptedAnswerId": "28974609", "Title": "using vs typedef pointer-to-noexcept-function inconsistency", "CreationDate": "2015-03-10T21:21:23.827", "Id": "28974316", "CommentCount": "2", "LastEditDate": "2015-03-10T22:32:56.423", "PostTypeId": "1", "LastEditorUserId": "3093378", "LastActivityDate": "2015-03-10T22:32:56.423", "Score": "3", "OwnerUserId": "3093378", "Tags": "<c++><exception><c++11>", "AnswerCount": "1"}});