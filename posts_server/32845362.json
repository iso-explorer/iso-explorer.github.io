post_cb({"bq_ids": {"n4140": {"so_32845362_32848577_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 3909}, "so_32845362_32848577_1": {"length": 17, "quality": 0.85, "section_id": 3909}}, "n3337": {"so_32845362_32848577_1": {"length": 17, "quality": 0.85, "section_id": 3769}, "so_32845362_32848577_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 3769}}, "n4659": {"so_32845362_32848577_1": {"length": 17, "quality": 0.85, "section_id": 4795}, "so_32845362_32848577_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 4795}}}, "32845362": {"ViewCount": "214", "Body": "<p>I am trying to make a dynamic bidimensional array (in which case i pretty much did successfully). I have a class which includes some constructors, a destructors and other functions that deals with arithmetic operations on the matrix. so here is the whole code:</p>\n<pre><code>  #include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\nusing namespace std; \nint n,m,input,i,j;\n\nclass Matrix{\n    int **matrix;\n    int i,j,codeError;\n    public:\n        Matrix();\n        Matrix(int);\n        Matrix(int, int);\n        Matrix(const Matrix&amp;, int, int);\n        ~Matrix();\n        void setIJ(int, int);\n        int getIJ(int, int);\n        void set(int,int);\n        void position();\n        void plus(const Matrix&amp;,const Matrix&amp;,int, int);\n        void minus(const Matrix&amp;,const Matrix&amp;,int, int);\n        void multiply(const Matrix&amp;,const Matrix&amp;,int, int);\n        //void multiply(int,int,int);\n        void print(int, int);\n    };\nMatrix a,b,c,d,e;\nMatrix::Matrix(){\n\n        matrix=NULL;\n        i=0;\n        j=0;\n    }\nMatrix::Matrix(int n){\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int[n];\n    for (int i=0;i&lt;n;i++){\n        for(int j=0;j&lt;n;j++){\n            if(i==j)\n            matrix[i][j]=1;\n            else matrix[i][j]=2;\n            }\n        }\n    }\n\nMatrix::Matrix(int m, int n){\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int[m];\n    for (int i=0;i&lt;n;i++){\n        for(int j=0;j&lt;m;j++){\n            if(i==j)\n            matrix[i][j]=0;\n            else matrix[i][j]=1;\n            }\n        }\n}\n\n\nMatrix::Matrix(const Matrix &amp;obj,int n, int m)\n\n    {\n        matrix=new int*[n];\n    for(i=0;i&lt;n;++i)\n    matrix[i]=new int[m];\n        for (int i=0;i&lt;n;i++){\n            for (int  j=0; j&lt;n; j++){\n                    matrix[i][j]=obj.matrix[i][j];\n                }\n            }\n        }\n\nMatrix::~Matrix(){\n    delete [] matrix;\n}\n\n\nvoid Matrix::set(int n, int m){\n     matrix=new int*[n];\n    for(i=0;i&lt;n;++i)\n    matrix[i]=new int[m];\n\n    for ( i=0;i&lt;n;i++){\n        for( j=0;j&lt;m;j++){\n            cin&gt;&gt;matrix[i][j];\n            }\n        }\n    }\nvoid Matrix::setIJ(int i, int j){\n        int num;\n        cout&lt;&lt;\"matrix[i][j]=\"&lt;&lt;endl;\n        cin&gt;&gt;num;\n        matrix[i][j]=num;\n        }\n\n\nint Matrix::getIJ(int i, int j){\n    return matrix[i][j];\n    }\n\nvoid Matrix::plus(const Matrix &amp;obj,const Matrix &amp;tmp,int n,int m){\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int [m];\n    for(i=0;i&lt;n;i++){\n        for(j=0;j&lt;m;j++){\n            matrix[i][j]=tmp.matrix[i][j]+obj.matrix[i][j];\n        }\n    }\n}\n\nvoid Matrix::minus(const Matrix &amp;obj,const Matrix &amp;tmp,int n,int m){\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int [m];\n    for(i=0;i&lt;n;i++){\n        for(j=0;j&lt;m;j++){\n            matrix[i][j]=tmp.matrix[i][j]-obj.matrix[i][j];\n        }\n    }\n}\n\nvoid Matrix::multiply(const Matrix &amp;obj,const Matrix &amp;tmp,int n,int m){\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int [m];\n    int temp1=0,temp2=0;\n    for(i=0;i&lt;n;i++){\n        for(j=0;j&lt;m;j++){\n            for(int k=0;k&lt;n;k++){\n            temp1=tmp.matrix[i][k];\n            temp2=obj.matrix[k][j];\n            matrix[i][j]+=temp1*temp2;\n            }\n        }\n    }\n}\n\n/*void Matrix::multiply(int n,int m,int scalar){\n\n    matrix=new int*[n];\n    for(i=0;i&lt;n;i++)\n    matrix[i]=new int [m];\n    for(i=0;i&lt;n;i++){\n        for(j=0;j&lt;m;j++){\n            matrix[i][j]*=scalar;\n        }\n    }\n}*/\n\nvoid Matrix::print(int n, int m){\n    for(int i=0;i&lt;n;i++){\n        cout&lt;&lt;endl;\n        for(int j=0;j&lt;m;j++){\n            cout&lt;&lt;\" \"&lt;&lt;matrix[i][j];\n            }\n        }\n    }\n\nint main(){\n        menu:\n    cout&lt;&lt;\"menu\"&lt;&lt;endl;\n    cout&lt;&lt;\"1.Constructor without parameters\"&lt;&lt;endl;\n    cout&lt;&lt;\"2.Constructor 1 parameter\"&lt;&lt;endl;\n    cout&lt;&lt;\"3.Constructor 2 parameters\"&lt;&lt;endl;\n    cout&lt;&lt;\"4.copy constructor\"&lt;&lt;endl;\n    cout&lt;&lt;\"5.change number on IJ position\"&lt;&lt;endl;\n    cout&lt;&lt;\"6.what is the number on IJ position\"&lt;&lt;endl;\n    cout&lt;&lt;\"7.adition\"&lt;&lt;endl;\n    cout&lt;&lt;\"8.substraction\"&lt;&lt;endl;\n    cout&lt;&lt;\"9.multiply\"&lt;&lt;endl;\n    cout&lt;&lt;\"10.print\"&lt;&lt;endl;\n\n    cin&gt;&gt;input;\n    switch(input){\n        case 1:{\n            Matrix a;\n            cout&lt;&lt;\"write n si m\"&lt;&lt;endl;\n            cin&gt;&gt;n&gt;&gt;m;\n            a.set(n,m);\n            goto menu;\n            }\n        case 2:{\n            Matrix b(3);\n            goto menu;\n            }\n        case 3:{\n            Matrix c(3,4);\n            goto menu;\n            }\n        case 4:{\n            Matrix d(a);\n            goto menu;\n            }   \n        case 5:{\n            cout&lt;&lt;\"write i,j\"&lt;&lt;endl;\n            cin&gt;&gt;i&gt;&gt;j;\n            a.setIJ(i,j);\n            goto menu;\n            }\n        case 6:{\n            cout&lt;&lt;\"itnrodu i,j\"&lt;&lt;endl;\n            cin&gt;&gt;i&gt;&gt;j;\n            a.getIJ(i,j);\n            goto menu;\n            }\n        case 7:{\n            e.plus(a,d,n,m);\n            goto menu;\n            }\n        case 8:{\n            e.minus(a,d,n,m);\n            goto menu;\n            }\n        /*case 9:{\n\n            }*/\n        case 10:{\n            a.print(n,m);\n            b.print(3,3);\n            c.print(3,4);\n            d.print(n,m);\n            e.print(n,m);\n\n            goto menu;\n            }\n        }\n    }\n</code></pre>\n<p>so before including the switch statement in the main function, everything worked perfectly normal by manually calling each function. now however, the first 4 switch statements work properly i guess, but when i go to the 5-10 cases, i get the Segmentation fault (core dumped 139). i tried debugging the code and it shows me that the problem is always when i assign the matrix[i][j] to something else, for example here :</p>\n<pre><code>void Matrix::setIJ(int i, int j){\n    int num;\n    cout&lt;&lt;\"matrix[i][j]=\"&lt;&lt;endl;\n    cin&gt;&gt;num;\n    **matrix[i][j]=num;**&lt;-here\n    }\n</code></pre>\n<p>or here:</p>\n<pre><code>void Matrix::plus(const Matrix &amp;obj,const Matrix &amp;tmp,int n,int m){\nmatrix=new int*[n];\nfor(i=0;i&lt;n;i++)\nmatrix[i]=new int [m];\nfor(i=0;i&lt;n;i++){\n    for(j=0;j&lt;m;j++){\n        **matrix[i][j]=tmp.matrix[i][j]+obj.matrix[i][j];**&lt;-here\n    }\n}\n</code></pre>\n<p>}</p>\n<p>i know something's gotta be with pointers but i am still a rookie in programming please help me</p>\n", "AcceptedAnswerId": "32848577", "Title": "Segmentation fault (core dumped 139)", "CreationDate": "2015-09-29T13:32:37.623", "Id": "32845362", "CommentCount": "3", "LastEditDate": "2015-09-29T13:38:59.310", "PostTypeId": "1", "LastEditorUserId": "5388962", "LastActivityDate": "2015-09-29T16:02:09.667", "Score": "2", "OwnerUserId": "5388962", "Tags": "<c++><pointers><matrix><dynamic>", "AnswerCount": "1"}, "32848577": {"Id": "32848577", "PostTypeId": "2", "Body": "<p>Here is the problem. You're creating <code>Matrix</code> objects under <code>case</code>'s scope. But like said by <a href=\"https://stackoverflow.com/a/7334968/5118690\">Lightness Races in Orbit</a> :</p>\n<blockquote>\n<p id=\"so_32845362_32848577_0\">[...] objects with automatic storage duration are not \"leaked\" when you <code>goto</code> out of their scope</p>\n</blockquote>\n<p>and :</p>\n<blockquote>\n<p id=\"so_32845362_32848577_1\">[n3290: 6.6/2]: On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been\n  constructed in that scope are destroyed in the reverse order of their\n  construction. [..]</p>\n</blockquote>\n<p>So, when the <code>goto</code> is done and you left the <code>case</code>'s scope, <code>Matrix</code> objects created under the scope will be destroy. That's why when you're using it after, you obtain a <code>Segmentation fault (core dumped 139)</code></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-29T16:02:09.667", "Score": "0", "CreationDate": "2015-09-29T15:55:05.850", "ParentId": "32845362", "CommentCount": "0", "OwnerUserId": "5118690", "LastEditDate": "2017-05-23T11:45:26.887"}});