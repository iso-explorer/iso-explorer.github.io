post_cb({"17426570": {"ParentId": "17426476", "CommentCount": "0", "Body": "<p>The C++11 standard actually says (3.9.3/1)  (emphasis mine)</p>\n<blockquote>\n<p id=\"so_17426476_17426570_0\">[...] The cv-qualified or\n  cv-unqualified versions of a type <strong>are distinct types</strong>; however, they shall have the same representation and\n  alignment requirements</p>\n</blockquote>\n<p>with the following precision: </p>\n<blockquote>\n<p id=\"so_17426476_17426570_1\">The same representation and alignment requirements are meant to imply interchangeability as arguments to functions,\n  return values from functions, and non-static data members of unions</p>\n</blockquote>\n", "OwnerUserId": "1594913", "PostTypeId": "2", "Id": "17426570", "Score": "2", "CreationDate": "2013-07-02T13:11:48.463", "LastActivityDate": "2013-07-02T13:11:48.463"}, "17428667": {"ParentId": "17426476", "CommentCount": "0", "Body": "<p>As stated, typeid().name() isn't a great choice, because the result is implementation defined. Try this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid array_function(const int a[]) {\n   cout &lt;&lt; \"const int a[]\" &lt;&lt; endl;\n}\n\nvoid array_function(int a[]) {\n   cout &lt;&lt; \"int a[]\" &lt;&lt; endl;\n}\n\n\nint main()\n{\n    const int carray[] = { 1, 2, 3};\n    int array[] = { 1, 2, 3};\n    array_function(carray);\n    array_function(array);\n}\n</code></pre>\n<p>It'll show you that the compiler can tell the difference. (The type <em>is</em> different.)</p>\n", "OwnerUserId": "785937", "PostTypeId": "2", "Id": "17428667", "Score": "0", "CreationDate": "2013-07-02T14:46:53.387", "LastActivityDate": "2013-07-02T14:46:53.387"}, "bq_ids": {"n4140": {"so_17426476_17426570_1": {"section_id": 7225, "quality": 0.9411764705882353, "length": 16}, "so_17426476_17426570_0": {"section_id": 7225, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_17426476_17426570_1": {"section_id": 6969, "quality": 0.9411764705882353, "length": 16}, "so_17426476_17426570_0": {"section_id": 6969, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_17426476_17426570_1": {"section_id": 8735, "quality": 0.9411764705882353, "length": 16}, "so_17426476_17426570_0": {"section_id": 8735, "quality": 0.9285714285714286, "length": 13}}}, "17426476": {"CommentCount": "6", "ViewCount": "319", "CreationDate": "2013-07-02T13:07:26.207", "LastActivityDate": "2013-07-02T14:46:53.387", "Title": "Type of array of const elements", "FavoriteCount": "1", "PostTypeId": "1", "Id": "17426476", "Score": "6", "Body": "<p>is it specified in standard that array of const elements has different type than array of non-const elements? Here is my code and output of VC2010 and GCC4.8.0.</p>\n<p>Thank you.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;ios&gt;\nint main(){\n    int arr_a[] = {1, 2};\n    int const arr_b[] = {3, 4}; // or const int arr_b[] = {3, 4};\n    std::cout &lt;&lt; typeid(arr_a).name() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; typeid(arr_b).name() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Same type: \" &lt;&lt; std::boolalpha &lt;&lt; (typeid(arr_a) == typeid(arr_b)) &lt;&lt; \".\\n\";\n}\n\nint [2]\nint const [2]\nSame type: false.\n\nA2_i\nA2_i\nSame type: true.\n</code></pre>\n", "Tags": "<c++><arrays><const><standards-compliance>", "OwnerUserId": "2542707", "AnswerCount": "2"}});