post_cb({"bq_ids": {"n4140": {"so_39664672_39665291_0": {"length": 6, "quality": 0.6, "section_id": 6325}}, "n3337": {"so_39664672_39665291_0": {"length": 6, "quality": 0.6, "section_id": 6082}}, "n4659": {"so_39664672_39665291_0": {"length": 6, "quality": 0.6, "section_id": 7835}}}, "39664672": {"ViewCount": "224", "Body": "<p>Is the standard C <code>assert(e)</code> macro permitted to evaluate <code>e</code> multiple times?  What about C++11 or later?  I don't see any guarantees in <a href=\"http://pubs.opengroup.org/onlinepubs/000095399/functions/assert.html\" rel=\"nofollow noreferrer\">the Open Group spec</a>, and the answer isn't apparent to me from some searching (<a href=\"http://ptolemy.eecs.berkeley.edu/~johnr/tutorials/assertions.html\" rel=\"nofollow noreferrer\">1</a>, <a href=\"https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_34.html\" rel=\"nofollow noreferrer\">2</a>).</p>\n<p>Context: could <code>func()</code> be called multiple times in <code>assert(func() != NULL)</code>?</p>\n<p>Yes, I already know this is a bad idea for other reasons: as <a href=\"https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_34.html\" rel=\"nofollow noreferrer\">the glibc manual</a> points out, the argument of <code>assert()</code> won't be evaluated at all if <code>NDEBUG</code> is defined.  However, assuming <code>NDEBUG</code> is <em>not</em> defined, is there any guarantee on the <em>maximum</em> number of times <code>e</code> is evaluated?</p>\n<p><sup>Question prompted by <a href=\"https://stackoverflow.com/q/39664376/2877364\">this one</a>.</sup></p>\n", "AcceptedAnswerId": "39665291", "Title": "May a standards-compliant C assert() evaluate its argument multiple times?", "CreationDate": "2016-09-23T15:38:05.417", "Id": "39664672", "CommentCount": "4", "LastEditDate": "2017-05-23T10:27:46.330", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-24T04:33:23.503", "Score": "6", "OwnerUserId": "2877364", "Tags": "<c++><c><c++11><language-lawyer><assert>", "AnswerCount": "1"}, "39665291": {"Id": "39665291", "PostTypeId": "2", "Body": "<h3>The C standard says</h3>\n<p>In the C11 standard (ISO/IEC 9899:2011), \u00a77.1.4 <strong>Use of library functions</strong> says:</p>\n<blockquote>\n<p id=\"so_39664672_39665291_0\">Each of the following statements applies unless explicitly stated otherwise in the detailed descriptions that follow: \u2026</p>\n<p id=\"so_39664672_39665291_1\">Any invocation of a library function that is implemented as a macro shall expand to code that evaluates each of its arguments exactly once, fully protected by parentheses where necessary, so it is generally safe to use arbitrary expressions as arguments.<sup>186)</sup> Likewise, those function-like macros described in the following subclauses may be invoked in an expression anywhere a function with a compatible return type could be called.<sup>187)</sup></p>\n<p id=\"so_39664672_39665291_2\"><sup>186)</sup> Such macros might not contain the sequence points that the corresponding function calls do.</p>\n<p id=\"so_39664672_39665291_3\"><sup>187)</sup> Because external identifiers and some macro names beginning with an underscore are reserved, implementations may provide special semantics for such names. For example, the identifier <code>_BUILTIN_abs</code> could be used to indicate generation of in-line code for the <code>abs</code> function. Thus, the appropriate header could specify</p>\n<pre><code>#define abs(x) _BUILTIN_abs(x)\n</code></pre>\n<p id=\"so_39664672_39665291_4\">for a compiler whose code generator will accept it. In this manner, a user desiring to guarantee that a given library function such as <code>abs</code> will be a genuine function may write</p>\n<pre><code>#undef abs\n</code></pre>\n<p id=\"so_39664672_39665291_5\">whether the implementation\u2019s header provides a macro implementation of <code>abs</code> or a built-in implementation. The prototype for the function, which precedes and is hidden by any macro definition, is thereby revealed also.</p>\n</blockquote>\n<p>The preamble in \u00a77.2 <strong>Diagnostics <code>&lt;assert.h&gt;</code></strong> says:</p>\n<blockquote>\n<p id=\"so_39664672_39665291_6\">The <code>assert</code> macro shall be implemented as a macro, not as an actual function. If the macro definition is suppressed in order to access an actual function, the behavior is undefined.</p>\n</blockquote>\n<p>And section \u00a77.2.1.1 <strong>The <code>assert</code> macro</strong> says:</p>\n<blockquote>\n<p id=\"so_39664672_39665291_7\">The <code>assert</code> macro puts diagnostic tests into programs; it expands to a void expression. When it is executed, if <code>expression</code> (which shall have a scalar type) is false (that is, compares equal to 0), the <code>assert</code> macro writes information about the particular call that failed (including the text of the argument, the name of the source file, the source line\n  number, and the name of the enclosing function \u2014 the latter are respectively the values of the preprocessing macros <code>__FILE__</code> and <code>__LINE__</code> and of the identifier <code>__func__</code>) on the standard error stream in an implementation-defined format.<sup>191)</sup> It then calls the <code>abort</code> function.</p>\n<p id=\"so_39664672_39665291_8\"><sup>191)</sup> The message written might be of the form:<br>\n<code>Assertion failed:</code><em><code>expression</code></em><code>, function</code><em><code>abc</code></em><code>, file</code><em><code>xyz</code></em><code>, line</code><em><code>nnn</code></em><code>.</code></br></p>\n</blockquote>\n<h3>A possible interpretation of the standard</h3>\n<p>So much for the verbiage of the standard \u2014 how does that translate in practice?</p>\n<p>A lot hinges on the interpretation of the statement:</p>\n<ul>\n<li><em>Any invocation of a library function that is implemented as a macro shall expand to code that evaluates each of its arguments exactly once</em></li>\n</ul>\n<p>If <code>assert</code> is regarded as a function that is implemented via a macro, then its argument shall be evaluated just once (the conversion to string is a compile-time operation that does not evaluate the expression).</p>\n<p>If <code>assert</code> is regarded as 'not a function' (because it is explicitly a macro), then the restriction quoted doesn't necessarily apply to it.</p>\n<p>In practice, I'm sure that the intent is that the expression argument to <code>assert</code> should only be evaluated once (and that only if <code>NDEBUG</code> was not defined when the <code>&lt;assert.h&gt;</code> header was last included) \u2014 so I'd regard it as being constrained as if it was a function that is implemented via a macro.  I'd also regard any implementation that implemented <code>assert</code> in such a way that the expression was evaluated twice as defective.  I'm not certain that the quoted material supports that, but it is all the relevant material I know of in the standard.</p>\n", "LastEditorUserId": "15168", "LastActivityDate": "2016-09-23T16:27:45.573", "Score": "7", "CreationDate": "2016-09-23T16:14:53.953", "ParentId": "39664672", "CommentCount": "1", "OwnerUserId": "15168", "LastEditDate": "2016-09-23T16:27:45.573"}});