post_cb({"34238806": {"CommentCount": "0", "ViewCount": "435", "PostTypeId": "1", "LastEditorUserId": "3723423", "CreationDate": "2015-12-12T10:31:43.143", "LastActivityDate": "2015-12-12T10:56:28.080", "Title": "Is std::map create the new memory for the object added", "LastEditDate": "2015-12-12T10:56:28.080", "Id": "34238806", "Score": "1", "Body": "<p>What I want I know is std::map.insert() will allocated a new memory for the object to be inserted or it uses the current object.</p>\n<p>So, if it uses the current object (the parameter), we need to allocate the memory for that object and pass as a parameter and we are responsible for that allocated memory. </p>\n<p>If it does not use the current object and it automatically allocates the new object and then copy the current object to the new allocated object, we just call the clear function. Is it correct?</p>\n<p>I am facing the memory leak when using std:map.</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><dictionary><stdmap>", "OwnerUserId": "5509699", "AnswerCount": "3"}, "34238995": {"ParentId": "34238806", "CommentCount": "0", "CreationDate": "2015-12-12T10:54:11.940", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "34238995", "Score": "3", "Body": "<p><a href=\"http://www.cplusplus.com/reference/map/map/insert/\" rel=\"nofollow\"><strong><code>std::map::insert()</code></strong></a> does not insert your current object into the container, but a new element. You don't need to allocate the element:  <code>insert()</code> will take care. </p>\n<p>If possible, insert will create the new object by moving the content of the object that you provided as parameter, otherwhise it will be copied.  </p>\n<p>It is therefore very important that your key and value types used in the map are properly defined according to at least <a href=\"https://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\" rel=\"nofollow\">the rule of 3 or better, the rule of 5</a>.  Leaking with maps usually relates to failed implementation of this rule.</p>\n<p>If the map gets deleted (it goes out of scope or you delete it), all its elements will be destroyed automatically, without you having to do anything.  The same if you <code>clear()</code> it.  No leaking should occur, unless your object destructor is not properly implemented.   </p>\n", "LastActivityDate": "2015-12-12T10:54:11.940"}, "34238912": {"ParentId": "34238806", "CommentCount": "0", "CreationDate": "2015-12-12T10:44:31.350", "OwnerUserId": "4115625", "PostTypeId": "2", "Id": "34238912", "Score": "0", "Body": "<p>Yes, <code>std::map::insert</code> will call appreciated constructor to copy/move the given parameter to its own tree.</p>\n<p>See C++11 standard, article 23.4.4.4 [map.modifiers]</p>\n<blockquote>\n<p id=\"so_34238806_34238912_0\">If P is instantiated as a reference type, then the argument x is copied from. Otherwise x is considered to be an rvalue as it is converted to value_type and inserted into the map. Specifically, in\n  such cases CopyConstructible is not required of key_type or mapped_type unless the conversion\n  from P specifically requires it (e.g., if P is a tuple, then key_type\n  must be CopyConstructible). The signature taking InputIterator parameters does not require\n  CopyConstructible of either key_type or mapped_type if the dereferenced InputIterator returns a\n  non-const rvalue pair. Otherwise CopyConstructible is required for both\n  key_type and mapped_type.</p>\n</blockquote>\n<p>Table 102 Article 23.2.4 [associative.reqmts]</p>\n<blockquote>\n<p id=\"so_34238806_34238912_1\">a_uniq.insert(t) pair&lt;iterator,bool&gt;\n  Requires: If t is a non-const rvalue expression, value_type shall be MoveInsertable into X; otherwise, value_type shall be CopyInsertable into X.</p>\n</blockquote>\n<p>Regarding the <code>clear</code> and <code>erase</code> functionality, if you store objects which is not pointers in the map, these function will release them when these function is called, if you store pointers, you need to free it your self.</p>\n", "LastActivityDate": "2015-12-12T10:44:31.350"}, "bq_ids": {"n4140": {"so_34238806_34238912_1": {"section_id": 763, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_34238806_34238912_0": {"section_id": 1003, "quality": 0.9411764705882353, "length": 48}, "so_34238806_34238912_1": {"section_id": 750, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_34238806_34238912_1": {"section_id": 823, "quality": 0.8461538461538461, "length": 11}}}, "34238953": {"ParentId": "34238806", "CommentCount": "2", "CreationDate": "2015-12-12T10:50:12.010", "OwnerUserId": "5428089", "PostTypeId": "2", "Id": "34238953", "Score": "0", "Body": "<p>It depends which version you use. If you call</p>\n<pre><code>insert(const value_type&amp; value)\n</code></pre>\n<p>then it's a caller responsability to manage object's lifetime. By using (C++17 version)</p>\n<pre><code>insert(value_type&amp;&amp; value)\n</code></pre>\n<p>that does not have to be the case.</p>\n<p>clear() will call destructors of the objects in the map.</p>\n", "LastActivityDate": "2015-12-12T10:50:12.010"}});