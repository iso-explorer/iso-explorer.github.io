post_cb({"bq_ids": {"n4140": {"so_6942949_6946317_0": {"length": 10, "quality": 0.625, "section_id": 5490}, "so_6942949_6946317_1": {"length": 60, "quality": 0.821917808219178, "section_id": 43}, "so_6942949_6946317_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 5505}}, "n3337": {"so_6942949_6946317_0": {"length": 15, "quality": 0.9375, "section_id": 5276}, "so_6942949_6946317_1": {"length": 64, "quality": 0.8767123287671232, "section_id": 40}, "so_6942949_6946317_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 5291}}, "n4659": {"so_6942949_6946317_0": {"length": 11, "quality": 0.6875, "section_id": 6924}, "so_6942949_6946317_1": {"length": 60, "quality": 0.821917808219178, "section_id": 43}, "so_6942949_6946317_2": {"length": 39, "quality": 0.9285714285714286, "section_id": 6939}}}, "6944129": {"Id": "6944129", "PostTypeId": "2", "Body": "<p>I can't say I know why (nor can I speak to the spec), but clang's error message may be instructive:</p>\n<pre><code>error: cannot cast private base class 'base' to 'base_der'\n</code></pre>\n<p>So changing the type of the member function works, in clang and gcc at least:</p>\n<pre><code>void (base::* print)(int);\nprint = &amp;base_der::print; // works!\n</code></pre>\n", "LastActivityDate": "2011-08-04T15:24:27.247", "CommentCount": "1", "CreationDate": "2011-08-04T15:24:27.247", "ParentId": "6942949", "Score": "4", "OwnerUserId": "194670"}, "6946317": {"Id": "6946317", "PostTypeId": "2", "Body": "<p>I think there are a few interacting problems contributing to the error:</p>\n<ol>\n<li>pointer-to-member types have unintuitive type conversion characteristics</li>\n<li>the using declaration doesn't affect the type of the name brought into scope</li>\n<li>while the name <code>base_der::print</code> is accessible, the class <code>base</code> still isn't and in an attempt to convert a pointer-to-member, the actual type of the class in the  pointer-to-member type is part of the consideration.</li>\n</ol>\n<p><strong>C++03 7.3.3 \"The using declaration\"</strong></p>\n<blockquote>\n<p id=\"so_6942949_6946317_0\">A using-declaration introduces a name into the declarative region in which the using-declaration appears. That name is a synonym for the name of some entity declared elsewhere.</p>\n</blockquote>\n<p>Note that while the name is brought into the new 'region', it's a synonym - the type of what the name refers to is the same.  So, I think that in your example, the name <code>base_der::print</code> has a type <code>void (base::*)(int)</code>, not type <code>void (base_der::*)(int)</code>.</p>\n<p>The C++03 standard also says this about conversions between pointer-to-member types (<strong>4.11 \"Pointer to member conversions\"</strong>):</p>\n<blockquote>\n<p id=\"so_6942949_6946317_1\">An rvalue of type \"pointer to member of B of type cv T\", where B is a class type, can be converted to an rvalue of type \"pointer to member of D of type cv T\", where D is a derived class (clause 10) of B. If B is an inaccessible (clause 11), ambiguous (10.2) or virtual (10.1) base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers to the same member as the pointer to member before the conversion took place, but it refers to the base class member as if it were a member of the derived class. The result refers to the member in D\u2019s instance of B. Since the result has type \"pointer to member of D of type cv T\", it can be dereferenced with a D object. The result is the same as if the pointer to member of B were dereferenced with the B sub-object of D.</p>\n</blockquote>\n<p>Also note  7.3.3/13 \"The using declaration\" (emphasis added):</p>\n<blockquote>\n<p id=\"so_6942949_6946317_2\">For the purpose of overload resolution, the functions which are introduced by a using-declaration into a derived class will be treated as though they were members of the derived class. In particular, the implicit this parameter shall be treated as if it were a pointer to the derived class rather than to the base class. <strong>This has no effect on the type of the function, and in all other respects the function remains a member of the base class.</strong></p>\n</blockquote>\n<p>Now, the code example that generates an error:</p>\n<pre><code>// This doesn't:    \nvoid (base_der::* print)(int);\nprint = &amp;base_der::print; // Compile error here\n</code></pre>\n<p>is trying to convert a \"pointer to member of D\" to a \"pointer to member of B\" - which is a conversion in the wrong direction.  If you think about it for a moment, you'll realize why a conversion in this direction isn't safe. A variable of type \"pointer to member of B\" might not be used with an object that has anything to do with <code>class D</code> - but if you call a function with type \"pointer to member of D\" (which is what <code>void (base_der::* print)(int)</code> is), it'll rightly expect that the <code>this</code> pointer will be pointing to a <code>D</code> object.</p>\n<p>Anyway, while I think that the root of the problem is this conversion problem, I think you're getting a complaint about the accessibility because when the compiler is trying to handle the conversion, it's first checking the accessibility of <code>base</code> - and even though the name <code>base_der::print</code> (which is an alias for <code>base::print</code>) is accessible because of the <code>using</code> declaration, class <code>base</code> still isn't.</p>\n<p>Disclaimer: this analysis is coming from someone who has little experience in the nuances of pointer-to-member types. They're an area of C++ that is complex, difficult to use except in the simplest scenarios, and apparently have a lot of portability problems (see Doug Clugston's article, <a href=\"http://www.codeproject.com/KB/cpp/FastDelegate.aspx\">http://www.codeproject.com/KB/cpp/FastDelegate.aspx</a>, which is old enough that a lot of these problems may have been addressed by now, but I suspect they aren't). </p>\n<p>And when you say that something in C++ is one of the more complex or less-well-understood areas, that's saying a lot.</p>\n", "LastEditorUserId": "12711", "LastActivityDate": "2011-08-04T18:23:32.100", "Score": "5", "CreationDate": "2011-08-04T18:03:59.887", "ParentId": "6942949", "CommentCount": "4", "OwnerUserId": "12711", "LastEditDate": "2011-08-04T18:23:32.100"}, "6943021": {"Id": "6943021", "PostTypeId": "2", "Body": "<p>It's because,</p>\n<pre><code>class base_der : private base\n</code></pre>\n<p>Inheritance is <code>private</code>. So <code>base</code> is inaccessible to <code>base_der</code>. Change that to <code>public</code> and it will work.</p>\n", "LastActivityDate": "2011-08-04T14:15:30.557", "CommentCount": "3", "CreationDate": "2011-08-04T14:15:30.557", "ParentId": "6942949", "Score": "1", "OwnerUserId": "514235"}, "6942949": {"ViewCount": "483", "Body": "<p>The following code yields a compile time error:</p>\n<blockquote>\n<p id=\"so_6942949_6942949_0\">'<code>base::print</code>' : cannot access private member declared in class '<code>base_der</code>'</p>\n</blockquote>\n<p>However, I have made the member <code>public</code> in the derived class. Why doesn't this work?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass base\n{\npublic:\n    int i;\n    void print(int i)\n    {\n        printf(\"base i\\n\");\n    }\n};\n\nclass base_der : private base\n{\npublic:\n    using base::print;\n};\n\nint main()\n{\n    // This works:\n    base_der cls;\n    cls.print(10);\n\n    // This doesn't:    \n    void (base_der::* print)(int);\n    print = &amp;base_der::print; // Compile error here\n}\n</code></pre>\n", "Title": "Function member pointer with private base", "CreationDate": "2011-08-04T14:11:11.473", "LastActivityDate": "2011-12-24T04:08:42.720", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-24T04:08:42.720", "LastEditorUserId": "963864", "Id": "6942949", "Score": "5", "OwnerUserId": "639734", "Tags": "<c++><implicit-conversion><member-function-pointers><member-pointers><private-inheritance>", "AnswerCount": "3"}});