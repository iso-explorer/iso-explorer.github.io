post_cb({"bq_ids": {"n4140": {"so_31583326_31583846_2": {"length": 25, "quality": 0.7575757575757576, "section_id": 5421}, "so_31583326_31583846_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 5421}}, "n3337": {"so_31583326_31583846_1": {"length": 16, "quality": 0.5925925925925926, "section_id": 5216}, "so_31583326_31583846_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 5216}}, "n4659": {"so_31583326_31583846_2": {"length": 25, "quality": 0.7575757575757576, "section_id": 6843}, "so_31583326_31583846_1": {"length": 20, "quality": 0.7407407407407407, "section_id": 6843}}}, "31583846": {"Id": "31583846", "PostTypeId": "2", "Body": "<p>The rules on constexpr constructors changed between C++11 and C++14; see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1911\" rel=\"nofollow\">DR1911 <em>constexpr constructor with non-literal base class</em></a> and <a href=\"http://llvm.org/bugs/show_bug.cgi?id=19344\" rel=\"nofollow\">this bug</a>.</p>\n<p>The fix is to compile in C++14 mode (<code>-std=c++14</code>).</p>\n<p>Language in C++11 <strong>[dcl.constexpr]</strong>:</p>\n<blockquote>\n<p id=\"so_31583326_31583846_0\">For a constexpr function, if no function argument values exist such that the function invocation substitution would produce a constant expression (5.19), the program is ill-formed; no diagnostic required. For a constexpr constructor, if no argument values exist such that after function invocation substitution, every\n  constructor call and full-expression in the mem-initializers would be a constant expression (including conversions), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>Under C++11, <code>shared_ptr</code> can have <code>constexpr</code> constructors but any class type inheriting from <code>shared_ptr</code> or with a <code>shared_ptr</code> member cannot, because <code>shared_ptr</code> is not a literal type (it has a destructor) and so cannot appear in a constant expression. For C++14 this was simplified to:</p>\n<blockquote>\n<p id=\"so_31583326_31583846_1\">For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting constexpr constructor, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>Unfortunately this makes <em>all</em> constexpr constructors of non-literal types undefined behavior; DR1911 fixed this by adding a subclause (<strong>bolded</strong> below):</p>\n<blockquote>\n<p id=\"so_31583326_31583846_2\">For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting constexpr constructor, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression (5.20), <strong>or, for a constructor, a constant initializer for some object (3.6.2),</strong> the program is ill-formed; no diagnostic required. </p>\n</blockquote>\n<pre><code>struct X { ~X() {} constexpr X() {} };   // OK in C++11, UB in C++14, OK since DR1911\nstruct Y : X { constexpr Y() : X() {} }; // UB in C++11, UB in C++14, OK since DR1911\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-07-23T11:58:13.590", "Score": "4", "CreationDate": "2015-07-23T09:50:31.850", "ParentId": "31583326", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2015-07-23T11:58:13.590"}, "31583326": {"ViewCount": "114", "Body": "<p>I want to implement my own pointer (with few helper methods) extended from shared_ptr.</p>\n<pre><code>class Event;\n\nclass EventPtr : public std::shared_ptr&lt;Event&gt; {\npublic:\n    constexpr EventPtr()\n        : std::shared_ptr&lt;Event&gt;() {\n    }\n\n    constexpr EventPtr(std::nullptr_t p)\n        : std::shared_ptr&lt;Event&gt;(p) {\n    }\n\n    explicit EventPtr(Event* ptr)\n        : std::shared_ptr&lt;Event&gt;(ptr) {\n    }\n};\n</code></pre>\n<p>The problem is that compiler gives me the following error for both constexpr constructors: \n<em>constexpr constructor never produces constant expression</em></p>\n<p>Tell me please how to fix it.</p>\n", "AcceptedAnswerId": "31583846", "Title": "constrexpr constructor inherited from shared_ptr", "CreationDate": "2015-07-23T09:27:02.757", "Id": "31583326", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-07-23T11:58:13.590", "Score": "3", "OwnerUserId": "1614520", "Tags": "<c++><memory><constructor><shared-ptr><constexpr>", "AnswerCount": "1"}});