post_cb({"38040678": {"LastActivityDate": "2016-07-04T01:38:35.867", "CommentCount": "21", "Body": "<p>Third attempt. The second became very long in the process of explaining every nook and cranny of the situation. But hey, I learned a lot too in the process, which I suppose is the point, no? :) Anyway. I'll re-address the question anew, keeping my longer answer as it in itself is a useful reference but falls short of a 'clear explanation'.</p>\n<h1>What are we dealing with here?</h1>\n<p><code>f</code> and <code>g</code> are not trivial situations. They take time to understand and appreciate the first few times you encounter them. The issues at play are the <strong>lifetime of objects</strong>, <strong>Return Value Optimization</strong>, confusion of <strong>returning object values</strong>, and confusion with <strong>overloads of reference types</strong>. I'll address each and explain their relevance.</p>\n<h2>References</h2>\n<p>First thing's first. What's a reference? Aren't they just pointers without the syntax?</p>\n<p>They are, but in an important way they're much more than that. Pointers are literally that, they refer to memory locations in general. There are few if any guarantees about the values located at wherever the pointer is set to. References on the other hand are bound to addresses of real values - values that guarantee to exist <em>for the duration they can be accessed</em>, but may not have a name for them available to be accessed in any other way (such as temporaries).</p>\n<p>As a rule of thumb, if you can 'take its address' then you're dealing with a reference, a rather special one known as an <code>lvalue</code>. You can assign to an lvalue. This is why <code>*pointer = 3</code> works, the operator <code>*</code> creates a reference to the address being pointed to.</p>\n<p>This doesn't make the reference any more or less valid than the address it points to, however, references you <em>naturally find</em> in C++ do have this guarantee (as would well-written C++ code) - that they are referring to real values in a way where we don't need to know about its lifetime for the duration of our interactions with them.</p>\n<h2>Lifetime of Objects</h2>\n<p>We all should know by now when the c'tors and d'tors will be called for something like this:</p>\n<pre><code>{\n  A temp;\n  temp.property = value;\n}\n</code></pre>\n<p><code>temp</code>'s scope is set. We know exactly when it's created and destroyed. One way we can be sure it's destroyed is because this is impossible:</p>\n<pre><code>A &amp; ref_to_temp = temp; // nope\nA * ptr_to_temp = &amp;temp; // double nope\n</code></pre>\n<p>The compiler stops us from doing that because <em>very</em> clearly we should not expect that object to still exist. This can arise <em>subtly</em> whenever using references, which is why sometimes people can be found suggesting avoidance of references until you know what you're doing with them (or entirely if they've given up understanding them and just want to move on with their lives).</p>\n<h2>Scope of Expressions</h2>\n<p>On the other hand we also have to be mindful that temporaries exist until the outer-most expression they're found in has completed. That means up to the semicolon. An expression existing in the LHS of a comma operator, for example, doesn't get destroyed until the semicolon. Ie:</p>\n<pre><code>struct scopetester {\n    static int counter = 0;\n    scopetester(){++counter;}\n    ~scopetester(){--counter;}\n};\n\nscopetester(), std::cout &lt;&lt; scopetester::counter; // prints 1\nscopetester(), scopetester(), std::cout &lt;&lt; scopetester::counter; // prints 2\n</code></pre>\n<p>This still does not avoid issues of sequencing of execution, you still have to deal with <code>++i++</code> and other things - operator precedence and the dreaded <em>undefined behavior</em> that can result when forcing ambiguous cases (eg <code>i++ = ++i</code>). What is important is that all temporaries created exist until the semicolon and no longer.</p>\n<p>There are two exceptions - <em>elision / in-place-construction</em> (aka RVO) and <em>reference-assignment-from-temporary</em>.</p>\n<h2>Returning by value and Elision</h2>\n<p>What is elision? Why use RVO and similar things? All of these come down under a single term that's far easier to appreciate - \"in-place construction\". Suppose we were using the result of a function call to initialize or set an object. Eg:</p>\n<pre><code>A x (void) {return A();}\nA y( x() );\n</code></pre>\n<p>Lets consider the longest possible sequence of events that could happen here.</p>\n<ol>\n<li>A new <code>A</code> is constructed in <code>x</code></li>\n<li>The temporary value returned by <code>x()</code> is a new <code>A</code>, initialized using a reference to the previous</li>\n<li>A new <code>A</code> - <code>y</code> - is initialized using the temporary value</li>\n</ol>\n<p>Where possible, the compiler should re-arrange things so that as few as possible intermediate <code>A</code>'s are constructed where it's <em>safe to assume</em> the intermediate is inaccessible or otherwise unnecessary. The question is <em>which</em> of the objects can we do without?</p>\n<p>Case #1 is an explicit new object. If we are to avoid this being created, we need to have a reference to an object that already exists. This is the most straightforward one and nothing more needs to be said.</p>\n<p>In #2 we cannot avoid constructing <em>some</em> result. After all, we are returning <em>by value</em>. However, there are two important exceptions (not including exceptions themselves which are <em>also</em> affected when thrown): <strong>NRVO</strong> and <strong>RVO</strong>. These affect what happens in #3, but there are important consequences and <em>rules</em> regarding #2...</p>\n<p>This is due to an interesting <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision#Notes\" rel=\"nofollow\">quirk of elision</a>:</p>\n<blockquote>\n<p id=\"so_37871609_38040678_0\"><strong>Notes</strong></p>\n<p id=\"so_37871609_38040678_1\">Copy elision is the only allowed form of optimization that can change the observable side-effects. Because some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), programs that rely on the side-effects of copy/move constructors and destructors are not portable.</p>\n<p id=\"so_37871609_38040678_2\">Even when copy elision takes place and the copy-/move-constructor is not called, it must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed. </p>\n<p id=\"so_37871609_38040678_3\"><em>(Since C++11)</em></p>\n<p id=\"so_37871609_38040678_4\">In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see return statement for details.</p>\n</blockquote>\n<p>And more on that in the <a href=\"http://en.cppreference.com/w/cpp/language/return#Notes\" rel=\"nofollow\">return statement notes</a>:</p>\n<blockquote>\n<p id=\"so_37871609_38040678_5\"><strong>Notes</strong></p>\n<p id=\"so_37871609_38040678_6\">Returning by value may involve construction and copy/move of a temporary object, unless copy elision is used.</p>\n<p id=\"so_37871609_38040678_7\"><em>(Since C++11)</em></p>\n<p id=\"so_37871609_38040678_8\">If <code>expression</code> is an lvalue expression and the conditions for copy elision are met, or would be met, except that <code>expression</code> names a function parameter, then overload resolution to select the constructor to use for initialization of the returned value is performed twice: first as if <code>expression</code> were an rvalue expression (thus it may select the move constructor or a copy constructor taking reference to const), and if no suitable conversion is available, overload resolution is performed the second time, with lvalue expression (so it may select the copy constructor taking a reference to non-const).</p>\n<p id=\"so_37871609_38040678_9\">The above rule applies even if the function return type is different from the type of <code>expression</code> (copy elision requires same type) </p>\n</blockquote>\n<p>The compiler is allowed to even chain together multiple elisions. All it means is that two sides of a move / copy that would involve an intermediate object, could potentially be made to refer directly to each-other or even be made to be the same object. We don't know and <em>shouldn't need to know</em> when the compiler chooses to do this - it's an optimization, for one, but importantly you should think of move and copy constructors et al as a \"last resort\" usage.</p>\n<p>We can agree the goal is to reduce the number of unnecessary operations in any optimization, provided the observable behavior is the same. Move and copy constructors are used <em>wherever moves and copy operations happen</em>, so what about when the compiler sees fit to remove a move/copy operation itself as an optimization? Should the <em>functionally unnecessary</em> intermediate objects exist in the final program just for the purposes of their side effects? The way the standard is right now, and compilers, seems to be: no - the move and copy constructors satisfy the <em>how</em> of those operations, not the <em>when</em> or <em>why</em>.</p>\n<p>The short version: You have less temporary objects, that you ought to not care about to begin with, so why should you miss them. If you do miss them it may just be that your code relies on intermediate copies and moves to do things beyond their stated purpose and contexts.</p>\n<p>Lastly, you need to be aware that the elided object is <em>always</em> stored (and constructed) in the <em>receiving</em> location, not the location of its inception.</p>\n<p>Quoting <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">this reference</a> - </p>\n<blockquote>\n<p id=\"so_37871609_38040678_10\"><strong>Named Return Value Optimization</strong></p>\n<p id=\"so_37871609_38040678_11\">If a function returns a class type by value, and the return statement's expression is the name of a non-volatile object with automatic storage duration, which isn't the function parameter, or a catch clause parameter, and which has the same type (ignoring top-level cv-qualification) as the return type of the function, then copy/move is omitted. When that local object is constructed, it is constructed directly in the storage where the function's return value would otherwise be moved or copied to. This variant of copy elision is known as NRVO, \"named return value optimization\".</p>\n<p id=\"so_37871609_38040678_12\"><strong>Return Value Optimization</strong></p>\n<p id=\"so_37871609_38040678_13\">When a nameless temporary, not bound to any references, would be moved or copied into an object of the same type (ignoring top-level cv-qualification), the copy/move is omitted. When that temporary is constructed, it is constructed directly in the storage where it would otherwise be moved or copied to. When the nameless temporary is the argument of a return statement, this variant of copy elision is known as RVO, \"return value optimization\". </p>\n</blockquote>\n<h2>Lifetime of References</h2>\n<p>One thing we should not do, is this:</p>\n<pre><code>A &amp; func() {\n    A result;\n    return result;\n}\n</code></pre>\n<p>While tempting because it would avoid implicit copying of anything (we're just passing an address right?) it's also a short-sighted approach. Remember the compiler above preventing something looking like this with <code>temp</code>? Same thing here - <code>result</code> is gone once we're done with <code>func</code>, it could be reclaimed and could be anything now.</p>\n<p>The reason we cannot is because we cannot pass an address to <code>result</code> out of <code>func</code> - whether as reference or as pointer - and consider it valid memory. We would get no further passing <code>A*</code> out.</p>\n<p>In this situation it is best to use an object-copy return type and rely on moves, elision or both to occur as the compiler finds suitable. Always think of copy and move constructors as 'measures of last resort' - you should not rely on the compiler to use them because the compiler <em>can</em> find ways to avoid copy and move operations entirely, and is <em>allowed to</em> do so even if it means the side effects of those constructors wouldn't happen any more.</p>\n<p>There is however a special case, alluded to earlier.</p>\n<p>Recall that references are <em>guarantees</em> to real values. This implies that the <em>first</em> occurrence of the reference initializes the object and the <em>last</em> (as far as known at compile time) destroys it when going out of scope.</p>\n<p>Broadly this covers two situations: when we return a temporary <em>from</em> a function. and when we <em>assign</em> from a function result. The first, returning a temporary, is basically what elision does but you can in effect elide explicitly with reference passing - like passing a pointer in a call chain. It constructs the object at the time of return, but what changes is the object is no longer destroyed after leaving scope (the return statement). And on the other end the second kind happens - the variable storing the result of the function call now has the honor of destroying the value when <em>it</em> goes out of scope.</p>\n<p>The important point here is that elision and reference passing are related concepts. You can emulate elision by using pointers to uninitialized variables' storage location (of known type), for example, as you can with reference passing semantics (basically what they're <em>for</em>).</p>\n<h2>Overloads of Reference Types</h2>\n<p>References allow us to treat non-local variables as if they are local variables - to take their address, write to that address, read from that address, and importantly, be able to destroy the object at the right time - when the address can no longer be reached by anything.</p>\n<p>Regular variables when they leave scope, have their only reference to them disappear, and are promptly destroyed at that time. Reference variables can refer to regular variables, but except for elision / RVO circumstances they do not affect the scope of the original object - not even if the object they referred to goes out of scope early, which can happen if you make references to dynamic memory and are not careful to manage those references yourself.</p>\n<p>This means you can capture the results of an expression explicitly by reference. How? Well, this may seem odd at first but if you read the above it will make sense why this works:</p>\n<pre><code>class A {\n    /* assume rule-of-5 (inc const-overloads) has been followed but unless\n     * otherwise noted the members are private */\n  public:\n    A (void) { /* ... */ }\n    A operator+ ( const A &amp; rhs ) {\n        A res;\n        // do something with `res`\n        return res;\n    }\n};\n\nA x = A() + A(); // doesn't compile\nA &amp; y = A() + A(); // doesn't compile\nA &amp;&amp; z = A() + A(); // compiles\n</code></pre>\n<h3>Why? What's going on?</h3>\n<p><code>A x = ...</code> - we can't because constructors and assignment is private.</p>\n<p><code>A &amp; y = ...</code> - we can't because we're returning a value, not a reference to a value who's scope is greater or equal to our current scope.</p>\n<p><code>A &amp;&amp; z = ...</code> - we can because we're able to refer to xvalues. As consequence of this assignment the lifetime of the temporary value is extended to this capturing lvalue because it in effect has become an lvalue reference. Sound familiar? It's <em>explicit elision</em> if I were to call it anything. This is more apparent when you consider this syntax must involve a new value and must involve assigning that value to a reference.</p>\n<p>In all three cases when all constructors and assignment is made public, there is always only three objects constructed, with the address of <code>res</code> always matching the variable storing the result. (on my compiler anyway, optimizations disabled, -std=gnu++11, g++ 4.9.3).</p>\n<p>Which means the differences really do come down to just the storage duration of function arguments themselves. Elision and move operations cannot happen on anything but pure expressions, expiring values, or explicit targeting of the \"expiring values\" reference overload <code>Type&amp;&amp;</code>.</p>\n<h2>Re-examining <code>f</code> and <code>g</code></h2>\n<p>I've annotated the situation in both functions to get things rolling, a shortlist of assumptions the compiler would note when generating (reusable) code for each.</p>\n<pre><code>A f( A &amp;&amp; a ) {\n    // has storage duration exceeding f's scope.\n    // already constructed.\n\n    return a;\n    // can be elided.\n    // must be copy-constructed, a exceeds f's scope.\n}\n\nA g( A a ) {\n    // has storage duration limited to this function's scope.\n    // was just constructed somehow, whether by elision, move or copy.\n\n    return a;\n    // elision may occur.\n    // can move-construct if can't elide.\n    // can copy-construct if can't move.\n}\n</code></pre>\n<p>What we can say for sure about <code>f</code>'s <code>a</code> is that it's expecting to capture moved or expression-type values. Because <code>f</code> can accept either expression-references (prvalues) or lvalue-references about to disappear (xvalues) or moved lvalue-references (converted to xvalues via <code>std::move</code>), and because <code>f</code> must be homogenous in the treatment of <code>a</code> for all three cases, <code>a</code> is seen as a reference first and foremost to an area of memory who's lifetime exists for longer than a call to <code>f</code>. That is, it is not possible to distinguish which of the three cases we called <code>f</code> with from within <code>f</code>, so the compiler assumes the longest storage duration it needs for any of the cases, and finds it safest not to assume anything about the storage duration of <code>a</code>'s data.</p>\n<p>Unlike the situation in <code>g</code>. Here, <code>a</code> - however it happens upon its value - will cease to be accessible beyond a call to <code>g</code>. As such returning it is tantamount to moving it, since it's seen as an xvalue in that case. We could still copy it or more probably even elide it, it can depend on which is allowed / defined for <code>A</code> at the time.</p>\n<h3>The issues with <code>f</code></h3>\n<pre><code>// we can't tell these apart.\n// `f` when compiled cannot assume either will always happen.\n// case-by-case optimizations can only happen if `f` is\n// inlined into the final code and then re-arranged, or if `f`\n// is made into a template to specifically behave differently\n// against differing types.\n\nA case_1() {\n    // prvalues\n    return f( A() + A() );\n}\n\nA make_case_2() {\n    // xvalues\n    A temp;\n    return temp;\n}\nA case_2 = f( make_case_2() )\n\nA case_3(A &amp; other) {\n    // lvalues\n    return f( std::move( other ) );\n}\n</code></pre>\n<p>Because of the ambiguity of usage the compiler and standards are designed to make <code>f</code> usable consistently in all cases. There can be no assumptions that <code>A&amp;&amp;</code> will always be a new expression or that you will only use it with <code>std::move</code> for its argument etc. Once <code>f</code> is made external to your code, leaving only its call signature, that cannot be the excuse anymore. The function signature - which reference overload to target - is a clue to what the function should be doing with it and how much (or little) it can assume about the context.</p>\n<p>rvalue references are not a panacea for targeting only \"moved values\", they can target a good deal more things and even be targeted incorrectly or unexpectedly if you assume that's all they do. A reference to <em>anything</em> in general should be expected to and be made to exist for longer than the reference does, with the one exception being rvalue reference variables.</p>\n<p>rvalue reference variables are in essence, <em>elision operators</em>. Wherever they exist there is in-place construction going on of some description.</p>\n<p>As regular variables, they extend the scope of any xvalue or rvalue they receive - they hold the result of the expression as it's constructed rather than by move or copy, and from thereon are equivalent to regular reference variables in usage.</p>\n<p>As function variables they can also elide and construct objects in-place, but there is a very important difference between this:</p>\n<pre><code>A c = f( A() );\n</code></pre>\n<p>and this:</p>\n<pre><code>A &amp;&amp; r = f( A() );\n</code></pre>\n<p>The difference is there is no guarantee that <code>c</code> will be move-constructed vs elided, but <code>r</code> definitely will be elided / constructed in-place at some point, owing to the nature of what we're binding <em>to</em>. For this reason we can only assign to <code>r</code> in situations where there will be a new temporary value created.</p>\n<h2>But why is <code>A&amp;&amp;a</code> not destroyed if it is captured?</h2>\n<p>Consider this:</p>\n<pre><code>void bad_free(A &amp;&amp; a) {\n    A &amp;&amp; clever = std::move( a );\n    // 'clever' should be the last reference to a?\n}\n</code></pre>\n<p>This won't work. The reason is subtle. <code>a</code>'s scope is longer, and rvalue reference assignments can only <em>extend</em> the lifetime, not control it. <code>clever</code> exists for less time than <code>a</code>, and therefore is not an xvalue itself (unless using <code>std::move</code> again, but then you're back to the same situation, and it continues forth etc).</p>\n<h3>lifetime extension</h3>\n<p>Remember that what makes lvalues different to rvalues is that they cannot be bound to objects that have less lifetime than themselves. All lvalue references are either the original variable or a reference that has less lifetime than the original.</p>\n<p>rvalues allow binding to reference variables that have <em>longer</em> lifetime than the original value - that's half the point. Consider:</p>\n<pre><code>A r = f( A() ); // v1\nA &amp;&amp; s = f( A() ); // v2\n</code></pre>\n<p>What happens? In both cases <code>f</code> is given a temporary value that outlives the call, and a result object (because <code>f</code> returns by value) is constructed <em>somehow</em> (it will not matter as you shall see). In v1 we are constructing a new object <code>r</code> using the temporary result - we can do this in three ways: move, copy, elide. In v2 we are not constructing a new object, we are extending the lifetime of the result of <code>f</code> to the scope of <code>s</code>, alternatively saying the same: <code>s</code> is constructed in-place using <code>f</code> and therefore the temporary returned by <code>f</code> has its lifetime extended rather than being moved or copied.</p>\n<p>The main distinction is v1 <strong>requires</strong> move and copy constructors (at least one) to be defined <em>even if</em> the process is elided. For v2 you are not invoking constructors and are explicitly saying you want to reference and/or extend the lifetime of a temporary value, and <em>because</em> you don't invoke move or copy constructors the compiler can <em>only</em> elide / construct in-place!</p>\n<p>Remember that this has nothing to do with the argument given to <code>f</code>. It works identically with <code>g</code>:</p>\n<pre><code>A r = g( A() ); // v1\nA &amp;&amp; s = g( A() ); // v2\n</code></pre>\n<p><code>g</code> will create a temporary for its argument and move-construct it using <code>A()</code> for both cases. It like <code>f</code> also constructs a temporary for its return value, but it can use an xvalue because the result is constructed using a temporary (temporary to <code>g</code>). Again, this will not matter because in v1 we have a new object that could be copy-constructed or move-constructed (either is required but not both) while in v2 we are demanding reference to something that's constructed but will disappear if we don't catch it.</p>\n<h3>Explicit xvalue capture</h3>\n<p>Example to show this is possible in theory (but useless):</p>\n<pre><code>A &amp;&amp; x (void) { \n    A temp;\n    // return temp; // even though xvalue, can't do this\n    return std::move(temp);\n}\nA &amp;&amp; y = x(); // y now refers to temp, which is destroyed\n</code></pre>\n<p>Which object does <code>y</code> refer to? We have left the compiler no choice: <code>y</code> must refer to the result of some function or expression, and we've given it <code>temp</code> which works based on type. But no move has occurred, and <code>temp</code> will be deallocated by the time we use it via <code>y</code>.</p>\n<p>Why didn't lifetime extension kick in for <code>temp</code> like it did for <code>a</code> in <code>g</code> / <code>f</code>? Because of what we're returning: we can't specify a function to construct things in-place, we can specify a variable to <em>be</em> constructed in place. It also goes to show that the compiler does not look across function / call boundaries to determine lifetime, it will just look at which variables are on the calling side or local, how they're assigned to and how they're initialized if local.</p>\n<p>If you want to clear all doubts, try passing this as an rvalue reference: <code>std::move(*(new A))</code> - what should happen is that nothing should ever destroy it, because it isn't on the stack and because rvalue references do not alter the lifetime of anything but temporary objects (ie, intermediates / expressions). xvalues are candidates for move construction / move assignment and can't be elided (already constructed) but all other move / copy operations can in theory be elided on the whim of the compiler; when using rvalue references the compiler has no choice but to elide or pass on the address.</p>\n", "CreationDate": "2016-06-26T16:31:21.373", "LastEditDate": "2016-07-04T01:38:35.867", "ParentId": "37871609", "Id": "38040678", "LastEditorUserId": "5134012", "PostTypeId": "2", "Score": "0", "OwnerUserId": "5134012"}, "bq_ids": {"n4140": {"so_37871609_38040678_6": {"length": 6, "quality": 0.6, "section_id": 480}}, "n3337": {"so_37871609_38040678_6": {"length": 6, "quality": 0.6, "section_id": 3773}}}, "37871609": {"CreationDate": "2016-06-17T01:07:31.527", "ViewCount": "692", "FavoriteCount": "2", "Id": "37871609", "Score": "5", "Title": "Returning an argument passed by rvalue reference", "LastEditorUserId": "-1", "CommentCount": "6", "Body": "<p>If I have a class <code>A</code> and functions</p>\n<pre><code>A f(A &amp;&amp;a)\n{\n  doSomething(a);\n  return a;\n}\nA g(A a)\n{\n  doSomething(a);\n  return a;\n}\n</code></pre>\n<p>the copy constructor is called when returning <code>a</code> from <code>f</code>, but the move constructor is used when returning from <code>g</code>. However, from what I understand, <code>f</code> can only be passed an object that it is safe to move (either a temporary or an object marked as moveable, e.g., using <code>std::move</code>). Is there any example when it would not be safe to use the move constructor when returning from <code>f</code>? Why do we require <code>a</code> to have automatic storage duration?</p>\n<p>I read the answers <a href=\"https://stackoverflow.com/questions/13430831/return-by-rvalue-reference\">here</a>, but the top answer only shows that the spec should not allow moving when passing <code>a</code> to other functions in the function body; it does not explain why moving <em>when returning</em> is safe for <code>g</code> but not for <code>f</code>. Once we get to the return statement, we will not need <code>a</code> anymore inside <code>f</code>.</p>\n<h1>Update 0</h1>\n<p>So I understand that temporaries are accessible until the end of the full expression. However, the behavior when returning from <code>f</code> still seems to go against the semantics ingrained into the language that it is safe to move a temporary or an xvalue. For example, if you call <code>g(A())</code>, the temporary is moved into the argument for <code>g</code> even though there could be references to the temporary stored somewhere. The same happens if we call <code>g</code> with an xvalue. Since only temporaries and xvalues bind to rvalue references, it seems like to be consistent about the semantics we should still move <code>a</code> when returning from <code>f</code>, since we know <code>a</code> was passed either a temporary or an xvalue.</p>\n", "Tags": "<c++><return><move-semantics><pass-by-rvalue-reference>", "LastEditDate": "2017-05-23T11:53:28.723", "LastActivityDate": "2016-07-04T01:38:35.867", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "6402759"}, "37875254": {"LastActivityDate": "2016-06-23T16:09:31.597", "CommentCount": "15", "Body": "<p>Second attempt. Hopefully this is more <strike>succinct and</strike> clear.</p>\n<p>I am going to ignore RVO almost entirely for this discussion. It makes it really confusing as to what should happen sans optimizations - this is just about move vs copy semantics.</p>\n<p>To assist this a reference is going to be very helpful here on <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow\">the sorts of value types in c++11</a>.</p>\n<h2>When to move?</h2>\n<h3>lvalue</h3>\n<p>These are never moved. They refer to variables or storage locations that are potentially being referred to elsewhere, and as such should not have their contents transferred to another instance.</p>\n<h3>prvalue</h3>\n<p>The above defines them as \"expressions that do not have identity\". Clearly nothing else can refer to a nameless value so these can be moved.</p>\n<h3>rvalue</h3>\n<p>The general case of \"right-hand\" value, and the only thing that's certain is they can be moved from. They may or may not have a named reference, but if they do it is the last such usage.</p>\n<h3>xvalue</h3>\n<p>These are sort of a mix of both - they have identity (are a reference) <em>and</em> they can be moved from. They need not have a named variable. The reason? They are eXpiring values, about to be destroyed. Consider them the 'final reference'. <strong>xvalues can only be generated from rvalues</strong> which is why/how <code>std::move</code> works in converting lvalues to xvalues (through the result of a function call).</p>\n<h3>glvalue</h3>\n<p>Another mutant type with its rvalue cousin, it can be either an xvalue or an lvalue - it has identity but it's unclear if this is the last reference to the variable / storage or not, hence it is unclear if it can or cannot be moved from.</p>\n<h2>Resolution Order</h2>\n<p>Where an overload exists that can accept either a <code>const lvalue ref</code> or <code>rvalue ref</code>, and an rvalue is passed, the rvalue is bound otherwise the lvalue version is used. (move for rvalues, copy otherwise).</p>\n<h2>Where it potentially happens</h2>\n<p>(assume all types are <code>A</code> where not mentioned)</p>\n<p>It only occurs where an object is \"initialized from an xvalue of the same type\". xvalues bind to rvalues but are not as restricted as pure expressions. In other words, movable things are more than unnamed references, they can also be the 'last' reference to an object with respect to the compiler's awareness.</p>\n<h3>initialization</h3>\n<pre><code>A a = std::move(b); // assign-move\nA a( std::move(b) ); // construct-move\n</code></pre>\n<h3>function argument passing</h3>\n<pre><code>void f( A a );\nf( std::move(b) );\n</code></pre>\n<h3>function return</h3>\n<pre><code>A f() {\n    // A a exists, will discuss shortly\n    return a;\n}\n</code></pre>\n<h2>Why it will not happen in <code>f</code></h2>\n<p>Consider this variation on f:</p>\n<pre><code>void action1(A &amp; a) {\n    // alter a somehow\n}\n\nvoid action2(A &amp; a) {\n    // alter a somehow\n}\n\nA f(A &amp;&amp; a) {\n    action1( a );\n    action2( a );\n    return a;\n}\n</code></pre>\n<p>It is not illegal to treat <code>a</code> as an lvalue within <code>f</code>. Because it is an <code>lvalue</code> it must be a reference, whether explicit or not. Every plain-old variable is technically a reference to itself.</p>\n<p>That's where we trip up. Because <code>a</code> is an lvalue for the purposes of <code>f</code>, we are in fact returning an lvalue.</p>\n<p>To explicitly generate an rvalue, we must use <code>std::move</code> (or generate an <code>A&amp;&amp;</code> result some other way).</p>\n<h2>Why it will happen in <code>g</code></h2>\n<p>With that under our belts, consider <code>g</code></p>\n<pre><code>A g(A a) {\n    action1( a ); // as above\n    action2( a ); // as above\n    return a;\n}\n</code></pre>\n<p>Yes, <code>a</code> is an lvalue for the purposes of <code>action1</code> and <code>action2</code>. However, because all references to <code>a</code> only exist within <code>g</code> (it's a copy or moved-into copy), it can be considered an xvalue in the return.</p>\n<h2>But why not in <code>f</code>?</h2>\n<p>There is no specific magic to <code>&amp;&amp;</code>. Really, you should think of it as a reference first and foremost. The fact that we are demanding an rvalue <em>reference</em> in <code>f</code> as opposed to an lvalue <em>reference</em> with <code>A&amp;</code> does not alter the fact that, being a reference, it must be an lvalue, because the <em>storage location</em> of <code>a</code> is external to <code>f</code> and that's as far as any compiler will be concerned.</p>\n<p>The same does not apply in <code>g</code>, where it's clear that <code>a</code>'s storage is temporary and exists only when <code>g</code> is called and at no other time. In this case it is clearly an xvalue and can be moved.</p>\n<hr>\n<h2><code>rvalue ref</code> vs <code>lvalue ref</code> and safety of reference passing</h2>\n<p>Suppose we overload a function to accept both types of references. What would happen?</p>\n<pre><code>void v( A  &amp; lref );\nvoid v( A &amp;&amp; rref );\n</code></pre>\n<p>The only time <code>void v( A&amp;&amp; )</code> will be used per the above (\"Where it potentially happens\"), otherwise <code>void v( A&amp; )</code>. That is, an rvalue ref will always attempt to bind to an rvalue ref signature before an lvalue ref overload is attempted. An lvalue ref should not ever bind to the rvalue ref except in the case where it can be treated as an xvalue (guaranteed to be destroyed in the current scope whether we want it to or not).</p>\n<p>It is tempting to say that in the rvalue case we know for sure that the object being passed is temporary. That is not the case. It is a signature <em>intended for</em> binding references to what <em>appears to be</em> a temporary object.</p>\n<p>For analogy, it's like doing <code>int * x = 23;</code> - it may be wrong, but you could (eventually) force it to compile with bad results if you run it. The compiler can't say for sure if you're being serious about that or pulling its leg.</p>\n<p>With respect to safety one must consider functions that do this (and why not to do this - if it still compiles at all):</p>\n<pre><code>A &amp; make_A(void) {\n    A new_a;\n    return new_a;\n}\n</code></pre>\n<p>While there is nothing ostensibly wrong with the language aspect - the types work and we will get a reference to <em>somewhere</em> back - because <code>new_a</code>'s storage location is <em>inside</em> a function, the memory will be reclaimed / invalid when the function returns. Therefore anything that uses the result of this function will be dealing with freed memory.</p>\n<p>Similarly, <code>A f( A &amp;&amp; a )</code> is intended to but is not limited to accepting prvalues or xvalues if we really want to force something else through. That's where <code>std::move</code> comes in, and let's us do just that.</p>\n<p>The reason this is the case is because it differs from <code>A f( A &amp; a )</code> <strong>only with respect to which contexts it will be preferred, over the rvalue overload</strong>. In all other respects it is identical in how <code>a</code> is treated by the compiler.</p>\n<p>The fact that we <em>know</em> that <code>A&amp;&amp;</code> is a signature reserved for moves is a moot point; it is used to determine which version of \"reference to <code>A</code> -type parameter\" we want to bind to, the sort where we <em>should</em> take ownership (rvalue) or the sort where we <em>should not</em> take ownership (lvalue) of the underlying data (that is, move it elsewhere and wipe the instance / reference we're given). In both cases, what we are working with is a <em>reference to memory that is not controlled by <code>f</code></em>.</p>\n<p>Whether we do or not is not something the compiler can tell; it falls into the 'common sense' area of programming, such as not to use memory locations that don't make sense to use but are otherwise valid memory locations.</p>\n<p>What the compiler knows about <code>A f( A &amp;&amp; a )</code> is to not create new storage for <code>a</code>, since we're going to be given an address (reference) to work with. We can choose to leave the source address untouched, but the whole idea here is that by declaring <code>A&amp;&amp;</code> we're telling the compiler \"hey! give me references to objects that are about to disappear so I might be able to do something with it before that happens\". The key word here is <em>might</em>, and again also the fact that we can explicitly target this function signature incorrectly.</p>\n<p>Consider if we had a version of <code>A</code> that, when move-constructing, did not erase the old instance's data, and for some reason we did this by design (let's say we had our own memory allocation functions and knew exactly how our memory model would keep data beyond the lifetime of objects).</p>\n<p>The compiler cannot know this, because it would take code analysis to determine what happens to the objects when they're handled in rvalue bindings - it's a human judgement issue at that point. At best the compiler sees 'a reference, yay, no allocating extra memory here' and follows rules of reference passing.</p>\n<p>It's safe to assume the compiler is thinking: \"it's a reference, I don't need to deal with its memory lifetime inside <code>f</code>, it being a temporary will be removed after <code>f</code> is finished\".</p>\n<p>In that case, when a temporary is passed to <code>f</code>, the storage of that temporary will disappear as soon as we leave <code>f</code>, and then we're potentially in the same situation as <code>A &amp; make_A(void)</code> - a very bad one.</p>\n<h2>An issue of semantics...</h2>\n<h3><code>std::move</code></h3>\n<p>The very purpose of <code>std::move</code> is to create rvalue references. By and large what it does (if nothing else) is force the resulting value to bind to rvalues as opposed to lvalues. The reason for this is a return signature of <code>A&amp;</code> prior to rvalue references being available, was ambiguous for things like operator overloads (and other uses surely).</p>\n<h3>Operators - an example</h3>\n<pre><code>class A {\n    // ...\n  public:\n    A &amp; operator= (A &amp; rhs); // what is the lifetime of rhs? move or copy intended?\n    A &amp; operator+ (A &amp; rhs); // ditto\n    // ...\n};\n\nint main() {\n    A result = A() + A(); // wont compile!\n}\n</code></pre>\n<p>Note that this <em>will not accept temporary objects for either operator</em>! Nor does it make sense to do this in the case of object copy operations - why do we need to modify an original object that we are <em>copying</em>, probably <em>in order to</em> have a copy we can modify later. This is the reason we have to declare <code>const A &amp;</code> parameters for copy operators and any situation where a copy is to be taken of the reference, as a guarantee that we are not altering the original object.</p>\n<p>Naturally this is an issue with moves, where we <em>must</em> modify the original object to avoid the new container's data being freed prematurely. (hence \"move\" operation).</p>\n<p>To solve this mess along comes <code>T&amp;&amp;</code> declarations, which are a replacement to the above example code, and specifically target references to objects in the situations where the above won't compile. But, we wouldn't need to modify <code>operator+</code> to be a move operation, and you'd be hard pressed to find a reason for doing so (though you could I think). Again, because of the assumption that addition should not modify the original object, only the left-operand object in the expression. So we can do this:</p>\n<pre><code>class A {\n    // ...\n  public:\n    A &amp; operator= (const A &amp; rhs); // copy-assign\n    A &amp; operator= (A &amp;&amp; rhs); // move-assign\n    A &amp; operator+ (const A &amp; rhs); // don't modify rhs operand\n    // ...\n};\n\nint main() {\n    A result = A() + A(); // const A&amp; in addition, and A&amp;&amp; for assign\n    A result2 = A().operator+(A()); // literally the same thing\n}\n</code></pre>\n<p>What you should take note of here is that <em>despite</em> the fact that <code>A()</code> returns a temporary, it not only is able to bind to <code>const A&amp;</code> but it <em>should</em> because of the expected semantics of addition (that it does not modify its right operand). The second version of the assignment is clearer why only one of the arguments should be expected to be modified.</p>\n<p>It's also clear that a move will occur on the assignment, and no move will occur with <code>rhs</code> in <code>operator+</code>.</p>\n<h3>Separation of return value semantics and argument binding semantics</h3>\n<p>The reason that there is only one move above is clear from the function (well, operator) definitions. What's important is we are indeed binding what is clearly an xvalue / rvalue, to what is unmistakably an lvalue in <code>operator+</code>.</p>\n<p>I have to stress this point: there is no effective difference in this example in the way that <code>operator+</code> and <code>operator=</code> refer to their argument. As far as the compiler is concerned, within either's function body the argument is effectively <code>const A&amp;</code> for <code>+</code> and <code>A&amp;</code> for <code>=</code>. The difference is purely in <code>const</code>ness. The only way in which <code>A&amp;</code> and <code>A&amp;&amp;</code> differ is to distinguish signatures, not types.</p>\n<p>With different signatures come different semantics, it's the compiler's toolkit for distinguishing certain cases where there otherwise is no clear distinction from the code. The behavior of the functions themselves - the code body - may not be able to tell the cases apart either!</p>\n<p>Another example of this is <code>operator++(void)</code> vs <code>operator++(int)</code>. The former expects to return its underlying value <em>before</em> an increment operation and the latter afterwards. There is no <code>int</code> being passed, it's just so the compiler has two signatures to work with - there is just no other way to specify two identical functions with the same name, and as you may or may not know, it is illegal to overload a function on just the return type for similar reasons of ambiguity.</p>\n<h2>rvalue variables and other odd situations - an exhaustive test</h2>\n<p>To understand unambiguously what is happening in <code>f</code> I've put together a smorgasbord of things one \"should not attempt but look like they'd work\" that forces the compiler's hand on the matter almost exhaustively:</p>\n<pre><code>void bad (int &amp;&amp; x, int &amp;&amp; y) {\n  x += y;\n}\nint &amp; worse (int &amp;&amp; z) {\n  return z++, z + 1, 1 + z;\n}\nint &amp;&amp; justno (int &amp; no) {\n  return worse( no );\n}\nint num () {\n  return 1;\n}\nint main () {\n  int &amp;&amp; a = num();\n  ++a = 0;\n  a++ = 0;\n  bad( a, a );\n  int &amp;&amp; b = worse( a );\n  int &amp;&amp; c = justno( b );\n  ++c = (int) 'y';\n  c++ = (int) 'y';\n  return 0;\n}\n</code></pre>\n<p><code>g++ -std=gnu++11 -O0 -Wall -c -fmessage-length=0 -o \"src\\\\basictest.o\" \"..\\\\src\\\\basictest.cpp\"</code> </p>\n<pre><code>..\\src\\basictest.cpp: In function 'int&amp; worse(int&amp;&amp;)':\n..\\src\\basictest.cpp:5:17: warning: right operand of comma operator has no effect [-Wunused-value]\n   return z++, z + 1, 1 + z;\n                 ^\n..\\src\\basictest.cpp:5:26: error: invalid initialization of non-const reference of type 'int&amp;' from an rvalue of type 'int'\n   return z++, z + 1, 1 + z;\n                          ^\n..\\src\\basictest.cpp: In function 'int&amp;&amp; justno(int&amp;)':\n..\\src\\basictest.cpp:8:20: error: cannot bind 'int' lvalue to 'int&amp;&amp;'\n   return worse( no );\n                    ^\n..\\src\\basictest.cpp:4:7: error:   initializing argument 1 of 'int&amp; worse(int&amp;&amp;)'\n int &amp; worse (int &amp;&amp; z) {\n       ^\n..\\src\\basictest.cpp: In function 'int main()':\n..\\src\\basictest.cpp:16:13: error: cannot bind 'int' lvalue to 'int&amp;&amp;'\n   bad( a, a );\n             ^\n..\\src\\basictest.cpp:1:6: error:   initializing argument 1 of 'void bad(int&amp;&amp;, int&amp;&amp;)'\n void bad (int &amp;&amp; x, int &amp;&amp; y) {\n      ^\n..\\src\\basictest.cpp:17:23: error: cannot bind 'int' lvalue to 'int&amp;&amp;'\n   int &amp;&amp; b = worse( a );\n                       ^\n..\\src\\basictest.cpp:4:7: error:   initializing argument 1 of 'int&amp; worse(int&amp;&amp;)'\n int &amp; worse (int &amp;&amp; z) {\n       ^\n..\\src\\basictest.cpp:21:7: error: lvalue required as left operand of assignment\n   c++ = (int) 'y';\n       ^\n..\\src\\basictest.cpp: In function 'int&amp; worse(int&amp;&amp;)':\n..\\src\\basictest.cpp:6:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n..\\src\\basictest.cpp: In function 'int&amp;&amp; justno(int&amp;)':\n..\\src\\basictest.cpp:9:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n\n01:31:46 Build Finished (took 72ms)\n</code></pre>\n<p>This is the unaltered output sans build header which you don't need to see :) I will leave it as an exercise to understand the errors found but re-reading my own explanations (particularly in what follows) it should be apparent what each error was caused by and why, imo anyway.</p>\n<h2>Conclusion - What can we learn from this?</h2>\n<p>First, note that the compiler treats function bodies as individual code units. This is basically the key here. Whatever the compiler does with a function body, it cannot make assumptions about the behavior of the function that would require the function body to be altered. To deal with those cases there are <em>templates</em> but that's beyond the scope of this discussion - just note that templates generate multiple function bodies to handle different cases, while otherwise the same function body must be re-usable in every case the function could be used.</p>\n<p>Second, rvalue types were predominantly envisioned for move operations - a very specific circumstance that was expected to occur in assignment and construction of objects. Other semantics using rvalue reference bindings are beyond the scope of any compiler to deal with. In other words, it's better to think of rvalue references as syntax sugar than actual code. The signature differs in <code>A&amp;&amp;</code> vs <code>A&amp;</code> but the argument type for the purposes of the function body does not, it is always treated as <code>A&amp;</code> with the <em>intention</em> that the object being passed <em>should</em> be modified in some way because <code>const A&amp;</code>, while correct syntactically, would not allow the desired behavior.</p>\n<p>I can be very sure at this point when I say that the compiler will generate the code body for <code>f</code> as if it were declared <code>f(A&amp;)</code>. Per above, <code>A&amp;&amp;</code> assists the compiler in choosing when to <em>allow</em> binding a mutable reference to <code>f</code> but otherwise the compiler doesn't consider the semantics of <code>f(A&amp;)</code> and <code>f(A&amp;&amp;)</code> to be different with respect to what <code>f</code> <em>returns</em>.</p>\n<p>It's a long way of saying: the return method of <code>f</code> does not depend on the type of argument it receives.</p>\n<p>The confusion is elision. In reality there are two copies in the returning of a value. First a copy is created as a temporary, then this temporary is assigned to something (or it isn't and remains purely temporary). The <em>second</em> copy is very likely elided via return optimization. The <em>first</em> copy can be moved in <code>g</code> and cannot in <code>f</code>. I expect in a situation where <code>f</code> cannot be elided, there will be a copy then a move from <code>f</code> in the original code.</p>\n<p>To override this the temporary must be explicitly constructed using <code>std::move</code>, that is, in the return statement in <code>f</code>. However in <code>g</code> we're returning something that is known to be temporary to the function body of <code>g</code>, hence it is either moved twice, or moved once then elided.</p>\n<p>I would suggest compiling the original code with all optimizations disabled and adding in diagnostic messages to copy and move constructors to keep tabs on when and where the values are moved or copied before elision becomes a factor. Even if I'm mistaken, an un-optimized trace of the constructors / operations used would paint an unambiguous picture of what the compiler has done, hopefully it will be apparent why it did what it did as well...</p>\n</hr>", "CreationDate": "2016-06-17T07:10:33.803", "LastEditDate": "2016-06-23T16:09:31.597", "ParentId": "37871609", "Id": "37875254", "LastEditorUserId": "5134012", "PostTypeId": "2", "Score": "7", "OwnerUserId": "5134012"}, "37985225": {"CommentCount": "6", "Body": "<p>Short story: it only depends on <code>doSomething</code>.</p>\n<p>Medium story: if <code>doSomething</code> <strong>never</strong> change <code>a</code>, then <code>f</code> is safe. It receives a rvalue reference and returns a new temporary moved from there.</p>\n<p>Long story: things will go bad as soon as <code>doSomething</code> uses <code>a</code> in a move operation, because a may be in an undefined state before it is used in the return statement - it would be the same in <code>g</code> but at least the conversion to a rvalue reference should be explicit</p>\n<p>TL/DR: both <code>f</code> and <code>g</code> are safe as long as there is no move operation inside <code>doSomething</code>. The difference comes that a move will silently executed in <code>f</code>, while it will require an explicit conversion to a rvalue reference (eg with <code>std::move</code>) in g.</p>\n", "CreationDate": "2016-06-23T07:44:36.497", "ParentId": "37871609", "Id": "37985225", "LastActivityDate": "2016-06-23T07:44:36.497", "PostTypeId": "2", "Score": "0", "OwnerUserId": "3545273"}});