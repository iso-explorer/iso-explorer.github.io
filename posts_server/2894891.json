post_cb({"2894906": {"ParentId": "2894891", "CommentCount": "6", "CreationDate": "2010-05-24T05:24:42.323", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "2894906", "Score": "16", "Body": "<p>This code doesn't work, though it may appear to work.  This line dereferences a null pointer:</p>\n<pre><code>return *static_cast&lt;MyType*&gt;(0);\n</code></pre>\n<p>The zero, cast to a pointer type, results in a null pointer; this null pointer is then dereferenced using the unary-<code>*</code>.</p>\n<p>Dereferencing a null pointer results in undefined behavior, so your program may do anything.  In the example you describe, you get a \"null reference\" (or, it appears you get a null reference), but it would also be reasonable for your program to crash or for anything else to happen.</p>\n", "LastActivityDate": "2010-05-24T05:24:42.323"}, "2895038": {"ParentId": "2894891", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2010-05-24T05:57:35.273", "Score": "0", "LastEditorUserId": "141349", "LastEditDate": "2010-05-24T11:27:33.037", "Id": "2895038", "OwnerUserId": "141349", "Body": "<p>As others have mentioned, your code is erroneous since it dereferences a null pointer.</p>\n<p>Secondly, you are using the reference return type incorrectly, returning a reference in your example is usually not good in C/C++ since it violates the memory management model of the language where all objects are referenced to by pointers to a memory address. If you rewrite C/C++ code that was written using pointers into code that uses references you will end up with these problems. The code using pointers could return a NULL pointer without causing problems, but when returning a reference you must return something that can be cast into a 0 or false statement.</p>\n<p>Most important of all is the pattern where your erroneous code only gets executed in the case of an exception, in this example your \"fail case\". Incorrect error handling, error logging with bugs etc are the most disastreous bugs in computer systems since they never show up in the happy case but always causes a system breakdown when something doesnt follow the normal flow.</p>\n<p>The only way to ensure that your code is correct is to have testcases with 100% coverage, that means also testing the error handling, which in your example probably would cause a segmentation fault on your program.</p>\n", "LastActivityDate": "2010-05-24T11:27:33.037"}, "2896720": {"ParentId": "2894891", "CommentCount": "0", "CreationDate": "2010-05-24T11:50:26.137", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "2896720", "Score": "1", "Body": "<p>As others have already said, the code unfortunately only appears to work... however, more fundamentally, you are breaking a contract here.</p>\n<p>In C++, a reference is meant to be an alias for an object. Based on the signature of your function I would never expect to be passed a 'NULL' reference, and I would certainly NOT test it before using it. As James McNellis said, creating a NULL reference is undefined behavior, however in most case this behavior only creeps in when you actually try to use it, and you are now exposing the users of your methods to nasty / tricky to nail down bugs.</p>\n<p>I won't go any further on that issue, just points you toward <a href=\"http://www.gotw.ca/conv/002.htm\" rel=\"nofollow noreferrer\">Herb Sutter's pick</a> on the issue.</p>\n<p>Now for the solution to your problem.</p>\n<p>The evident solution is of course a plain pointer. People expect a pointer to be possibly null, so they will test it when it's returned to them (and if they don't it's their damn fault for being lazy).</p>\n<p>There are other alternatives, but they mainly boil down to having a special value indicating your failure and there is not much point using complicated designs just for the sake of it...</p>\n<p>The last alternative is the use of exceptions here, however I am myself partial to the advice. Exceptions are meant for exceptional situations you see, and for a <code>find</code>/<code>search</code> feature it really depends on the expected result:</p>\n<ul>\n<li>if you are implementing some internal factory where you register modules and then call them back later on, then not being able to retrieve one module would indicate an error in the program and as such being reported by an exception is fine</li>\n<li>if you are implementing a search engine for a database of yours, thus dealing with user input, then not finding a result matching the input criteria is quite likely to occur, and thus I would not use exceptions in this circumstance, for it's not a programming error but a perfectly normal course</li>\n</ul>\n<p><em>Note: other ways include</em></p>\n<ul>\n<li><em>Boost.Optional, though I find it clumsy to wrap a reference with it</em></li>\n<li><em>A shared pointer or weak pointer, to control/monitor the object lifetime in case it may be deleted while you still use it... monitoring does not work by itself in Multi-Threaded environment though</em></li>\n<li><em>A sentinel value (usually declared static const), but it only works if your object has a meaningful \"bad\" or \"null\" value. It's certainly not the approach I would recommend since once again you give an object but it blows up in the users hand if they do anything with it</em></li>\n</ul>\n", "LastActivityDate": "2010-05-24T11:50:26.137"}, "2895547": {"ParentId": "2894891", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-05-24T07:56:07.797", "Score": "2", "LastEditorUserId": "33213", "LastEditDate": "2012-04-29T12:24:41.730", "Id": "2895547", "OwnerUserId": "33213", "Body": "<p>Well, you said it yourself in the title of your question. The code <strong>appears</strong> to work with a null reference.</p>\n<p>When people say null references do not exist in C++, it does not mean that the compiler will generate an error message if you try to create one. As you've found out, there's nothing to stop you from creating a reference from a null pointer.</p>\n<p>It simply means that the C++ standard does not specify what should happen if you do it. Null references are not possible because the C++ standard says that references must not be created from null pointers. (but doesn't say anything about generating a compile error if you try to do it.)</p>\n<p>It is <em>undefined behavior</em>. In practice, because references are typically implemented as pointers, it usually seems to work if you try to create a reference from a null pointer. But there's no <em>guarantee</em> that it'll work. Or that it'll keep working tomorrow. It's not possible in C++ because if you do it, the behavior specified by C++ no longer applies. Your program might do <em>anything</em></p>\n<p>This might all sound a bit hypothetical, because hey, it seems to work just fine. But keep in mind that just because it works, and it makes sense that it works, when naively compiled, it may break when the compiler tries to apply some optimization or other. When the compiler sees a reference, it is guaranteed by the language rules that <strong>it is not null</strong>. So what happens if the compiler uses this assumption to speed up the code, and you go behind its back creating a \"null reference\"?</p>\n", "LastActivityDate": "2012-04-29T12:24:41.730"}, "2896330": {"ParentId": "2894891", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-05-24T10:46:45.217", "Score": "11", "LastEditorUserId": "258009", "LastEditDate": "2010-05-25T10:15:43.217", "Id": "2896330", "OwnerUserId": "258009", "Body": "<p>I agree with other posters that the behaviour of your example is undefined and really shouldn't be used. I offer some alternatives here. Each of them has pros and cons</p>\n<ol>\n<li>If the object can't be found, throw an exception which is caught in the calling layer.</li>\n<li>Create a globally accessible instance of <code>MyType</code> which is a simple shell object (i.e. <code>static const MyType BAD_MYTYPE</code>) and can be used to represent a bad object.</li>\n<li>If it's likely that the object will not be found often then maybe pass the object in by reference as a parameter and return a bool or other error code indicating success / failure. If it can't find the object, you just don't assign it in the function.</li>\n<li>Use pointers instead and check for 0 on return.</li>\n<li>Use Boost smart pointers which allow for the validity of the returned object to be checked.</li>\n</ol>\n<p>My personal preference would be for one of the first three.</p>\n", "LastActivityDate": "2010-05-25T10:15:43.217"}, "2894949": {"ParentId": "2894891", "CommentCount": "0", "CreationDate": "2010-05-24T05:36:31.223", "OwnerUserId": "29809", "PostTypeId": "2", "Id": "2894949", "Score": "8", "Body": "<p>That is undefined behavior.  Because it is undefined behavior, it may \"work\" on your current compiler, but it could break if you ever upgrade/change your compiler.</p>\n<p>From the C++03 spec:</p>\n<blockquote>\n<p id=\"so_2894891_2894949_0\">8.3.2/4 ... A reference shall be initialized to refer to a valid object or function. [Note: in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer, which causes undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2010-05-24T05:36:31.223"}, "2894891": {"CommentCount": "2", "ViewCount": "1587", "PostTypeId": "1", "LastEditorUserId": "14065", "CreationDate": "2010-05-24T05:21:49.197", "LastActivityDate": "2012-04-29T12:24:41.730", "Title": "This code appears to achieve the return of a null reference in C++", "FavoriteCount": "1", "LastEditDate": "2010-05-24T06:59:59.063", "Id": "2894891", "Score": "13", "Body": "<p>My C++ knowledge is somewhat piecemeal. I was reworking some code at work. I changed a function to return a reference to a type. Inside, I look up an object based on an identifier passed in, then return a reference to the object if found. Of course I ran into the issue of what to return if I don't find the object, and in looking around the web, many people claim that returning a \"null reference\" in C++ is impossible. Based on this advice, I tried the trick of returning a success/fail boolean, and making the object reference an out parameter. However, I ran into the roadblock of needing to initialize the references I would pass as actual parameters, and of course there is no way to do this. I retreated to the usual approach of just returning a pointer.</p>\n<p>I asked a colleague about it. He uses the following trick quite often, which is accepted by both a recent version of the Sun compiler and by gcc:</p>\n<pre><code>MyType&amp; someFunc(int id)\n{\n  // successful case here:\n  // ...\n\n  // fail case:\n  return *static_cast&lt;MyType*&gt;(0);\n}\n\n// Use:\n\n...\nMyType&amp; mt = somefunc(myIdNum);\n\nif (&amp;mt) // test for \"null reference\"\n{\n  // whatever\n}\n...\n</code></pre>\n<p>I have been maintaining this code base for a while, but I find that I don't have as much time to look up the small details about the language as I would like. I've been digging through my reference book but the answer to this one eludes me.</p>\n<p>Now, I had a C++ course a few years ago, and therein we emphasized that in C++ everything is types, so I try to keep that in mind when thinking things through. Deconstructing the expression: \"<em>static_cast&lt;MyType</em>&gt;(0);\", it indeed seems to me that we take a literal zero, cast it to a pointer to MyType (which makes it a null pointer), and then apply the dereferencing operator in the context of assigning to a reference type (the return type), which should give me a reference to the same object pointed to by the pointer. This sure looks like returning a null reference to me.</p>\n<p>Any advice in explaining why this works (or why it shouldn't) would be greatly appreciated.</p>\n<p>Thanks,\nChuck</p>\n", "Tags": "<c++>", "OwnerUserId": "348680", "AnswerCount": "8"}, "2894960": {"ParentId": "2894891", "CommentCount": "1", "CreationDate": "2010-05-24T05:39:15.697", "OwnerUserId": "29639", "PostTypeId": "2", "Id": "2894960", "Score": "5", "Body": "<p>If you are married to that return-a-reference interface, then the <em>Right Thing</em>\u00ae\n would be to throw an exception if you can't find an object for the given ID. At least that way your poor user can trap the condition with a catch. </p>\n<p>If you go dereferencing a null pointer on them, they have no defined way to handle the error.</p>\n", "LastActivityDate": "2010-05-24T05:39:15.697"}, "bq_ids": {"n4140": {"so_2894891_2894949_0": {"section_id": 3222, "quality": 0.896551724137931, "length": 26}}, "n3337": {"so_2894891_2894949_0": {"section_id": 3096, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_2894891_2894949_0": {"section_id": 3979, "quality": 0.896551724137931, "length": 26}}}, "2894909": {"ParentId": "2894891", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-05-24T05:25:30.390", "Score": "2", "LastEditorUserId": "125672", "LastEditDate": "2010-05-24T05:35:32.460", "Id": "2894909", "OwnerUserId": "125672", "Body": "<p>The line return <code>*static_cast&lt;MyType*&gt;(0);</code> is dereferencing the null pointer which causes undefined behaviour.</p>\n", "LastActivityDate": "2010-05-24T05:35:32.460"}});