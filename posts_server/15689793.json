post_cb({"bq_ids": {"n4140": {"so_15689793_15689925_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 7043}}, "n3337": {"so_15689793_15689925_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 6788}}, "n4659": {"so_15689793_15689925_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 7709}}}, "15689793": {"ViewCount": "1780", "Body": "<p><strong>This Question Determined That a Non-Copyable Type Can't Be Used With Boost Variant</strong></p>\n<p><code>Tree</code> class</p>\n<pre><code>template &lt;class T = int&gt;\n\nclass Tree{\n\nprivate:\n\n         class TreeNode{\n\n         public:\n                 std::unique_ptr Nodes\n                 Move constructors and move assignment + other public members\n\n         private:\n\n                 TreeNode(const TreeNode &amp;other);      (= delete not supported on compiler)\n                 TreeNode&amp; operator=(const TreeNode &amp;rhs);    (= delete not supported on compiler)\n\n\n         };  // End Tree Node Class Definition\n\n\n         Tree(const Tree &amp;other);     (= delete not supported on compiler)\n         Tree&amp; operator=(const Tree &amp;rhs);    (= delete not supported on compiler)\n\npublic:\n\n         Move constructors and move assignment + other public members\n};\n</code></pre>\n<p><code>TreeVisitor</code> class</p>\n<pre><code>class TreeVisitor : public boost::static_visitor&lt;bool&gt; {\npublic:\n        TreeVisitor() {}\n\n        bool operator() (BinarySearchTree&lt;std::string&gt;&amp; tree) const {\n            return searchTree.load(tree);\n        }\nprivate:\n\n};\n</code></pre>\n<p><code>TreeVariant</code></p>\n<pre><code>typedef boost::variant&lt;Tree&lt;std::string&gt;, Tree&lt;int&gt;&gt; TreeVariant;     \nTreeVariant tree;\n\nTree&lt;std::string&gt; stringTree;\nTree&lt;int&gt; intTree;\n</code></pre>\n<p>Applying <code>Visitors</code> as follows</p>\n<pre><code>tree = intSearchTree;\nboost::apply_visitor(TreeVisitor(), tree)\n</code></pre>\n<p>Also using boost::bind for desired parameters</p>\n<pre><code>boost::bind(TreeVisitor(), tree, val, keyIndex);\n</code></pre>\n<p>Compiler errors of the type </p>\n<pre><code>error C2248: 'Tree&lt;T&gt;::Tree' : cannot access private member declared in class 'Tree&lt;T&gt;'  &lt;----- related to private copy constructor in Tree (not TreeNode)\ntree = stringTree;  &lt;-------  error related to assignment\n</code></pre>\n<p><code>Tree</code> compiles correctly and has been tested.  How can I resolve these compilation errors that appear related to trying to obtain a copy of the <code>Tree</code> class which, because of <code>std::unique_ptr</code>, is just not possible?</p>\n<p>SSCCE</p>\n<pre><code>&lt;class T = int&gt;\n\nclass Tree{\n\nprivate:\n\nclass TreeNode{\n\npublic:\n\n    TreeNode() {}\n    ~TreeNode() {}  \n\n    TreeNode(TreeNode &amp;&amp;other) : \n        key(other.key), index(other.index), left(std::move(other.left)), right(std::move(other.right)) \n    {\n        key = index = left = right = nullptr; \n    }\n\n    TreeNode &amp;operator=(BTreeNode &amp;&amp;rhs)\n    { \n        if(this != &amp;rhs) \n        { \n            key = rhs.key; index = rhs.index; \n            left = std::move(rhs.left); right = std::move(rhs.right); \n            rhs.key = rhs.index = rhs.left = rhs.right = nullptr;\n        } \n        return *this;\n    }\n\n    TreeNode(const T &amp;new_key, const T &amp;new_index) :\n        key(new_key), index(new_index), left(nullptr), right(nullptr) {}\n\n    friend class Tree;\n\nprivate:\n\n    TreeNode(const BinarySearchTreeNode &amp;other);\n    TreeNode&amp; operator=(const BinarySearchTreeNode &amp;rhs);\n\n    std::unique_ptr&lt;TreeNode&gt; left;\n    std::unique_ptr&lt;TreeNode&gt; right;\n\n};  // End Tree Node Class Definition\n\nstd::unique_ptr&lt;TreeNode&gt; root;\n\nBinarySearchTree(const BinarySearchTree &amp;other);\nBinarySearchTree&amp; operator=(const BinarySearchTree &amp;rhs);\n\n\npublic:\n\nTree() : root(nullptr), flag(false), run(true), leftCount(0), rightCount(0) {}\n\n~Tree() {}\n\nTree(BinarySearchTree &amp;&amp;other) : root(std::move(other.root)) { other.root = nullptr; }\n\nTree &amp;operator=(BinarySearchTree &amp;&amp;rhs) \n{ \n    if(this != &amp;rhs)\n    { \n        root = std::move(rhs.root); \n        rhs.root = nullptr;\n    } \n    return *this;\n}\n\n\n};\n</code></pre>\n<p>Example use:</p>\n<pre><code>bool delete_(){\n\n    while(!instances.empty()){\n                    // grab first instance\n                    keyIndex = instances.at(0);\n                    // compute end of the tuple to delete\n                    endIndex = keyIndex + sizeToDelete;\n\n                    // read the first attribute\n                    try{\n                        temp = boost::trim_copy(dataFile-&gt;readData(keyIndex, domainSize));\n                    }\n                    catch (std::exception &amp;e){\n                        printw(\"Error reading from the data file\");\n                    }\n\n                    // delete tuple from data file\n                    if(!dataFile-&gt;deleteTuple(keyIndex, endIndex)){\n                        printw(\"Error attempting to remove tuple\");\n                        if (writer_ != nullptr)\n                            writer_ &lt;&lt; \"Error attempting to remove tuple\";\n                        try{\n                            printw(\"%s\");\n                            // close catalog and search file\n\n                        }\n                        catch (std::exception &amp;e){\n                            e.what();\n                        }\n                        // close data file\n                        dataFile-&gt;closeFile();\n                        return false;\n                    }\n\n\n                    try{\n                        int val = boost::lexical_cast&lt;int&gt;(temp);\n\n                        searchTree = intSearchTree;\n\n                        boost::bind(BinarySearchTreeVisitor(), searchTree, val, keyIndex);\n\n                        // delete key index from the index file\n                        if (!boost::apply_visitor(BinarySearchTreeVisitor(), searchTree)){\n                            printw(\"No index present in index file\");\n                            try{\n                                printw(\" \");\n\n                            }\n                            catch (std::exception &amp;e){\n\n                            }\n                            // close data file\n                            dataFile-&gt;closeFile();\n                            return false;           \n                        }\n                    }\n                    catch(boost::bad_lexical_cast &amp;e){\n\n                        /*\n                         * Must be a std::string --- wow who knew\n                         */\n\n                        searchTree = stringSearchTree;\n\n                        boost::bind(BinarySearchTreeVisitor(), searchTree, temp, keyIndex);\n\n                        // delete key index from the index file\n                        if (!boost::apply_visitor(BinarySearchTreeVisitor(), searchTree)){\n                            printw(\"No index present in index file\");\n                            try{\n                                printw(\" \");\n                                // close catalog and search file\n\n                            }\n                            catch (std::exception &amp;e){\n                                e.what();\n                            }\n                            // close data file\n                            dataFile-&gt;closeFile();\n                            return false;           \n                        }\n\n                    }                       \n\n                    // clean up the index file\n                    boost::bind(BinarySearchTreeVisitor(), searchTree, keyIndex, sizeToDelete);\n                    boost::apply_visitor(BinarySearchTreeVisitor(), searchTree);\n\n                    instances.erase(instances.begin());\n\n                    for(int i= 0; i &lt; instances.size(); i++){\n                        instances.assign(i, instances.at(i) - \n                                                            sizeToDelete);\n                    }\n\n                }\n}\n</code></pre>\n", "AcceptedAnswerId": "15689925", "Title": "boost::variant; std::unique_ptr and copy", "CreationDate": "2013-03-28T18:43:42.397", "Id": "15689793", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-03-28T20:08:51.417", "LastEditorUserId": "2172135", "LastActivityDate": "2016-09-23T02:05:26.743", "Score": "6", "OwnerUserId": "2172135", "Tags": "<c++><c++11><unique-ptr><boost-variant>", "AnswerCount": "2"}, "39651468": {"Id": "39651468", "PostTypeId": "2", "Body": "<pre><code>using Mixed = boost::variant&lt; \n  std::unique_ptr&lt;char&gt;,\n  std::unique_ptr&lt;short&gt;,\n  std::unique_ptr&lt;int&gt;,\n  std::unique_ptr&lt;unsigned long&gt;\n&gt;;\n\nint main() {    \n  auto md = std::unique_ptr&lt;int&gt;(new int(123));\n  Mixed mixed = std::move(md);\n  std::cout &lt;&lt; *boost::get&lt; std::unique_ptr&lt;int&gt; &gt;(mixed) &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>unique_ptr is move-only and can be used in variant. The above example can compile and work (C++11).</p>\n", "LastActivityDate": "2016-09-23T02:05:26.743", "CommentCount": "0", "CreationDate": "2016-09-23T02:05:26.743", "ParentId": "15689793", "Score": "1", "OwnerUserId": "6670353"}, "15689925": {"Id": "15689925", "PostTypeId": "2", "Body": "<p>Concerning the call to <code>boost::bind()</code>, you should use <a href=\"http://www.boost.org/doc/libs/1_53_0/doc/html/ref.html\" rel=\"noreferrer\"><code>boost::ref()</code></a> when passing an object by reference to a function template that accepts the corresponding argument by value, otherwise a <em>copy</em> will be attempted (which results in a compiler error in this case, since the copy constructor is inaccessible):</p>\n<pre><code>boost::bind(TreeVisitor(), boost::ref(tree), val, keyIndex);\n//                         ^^^^^^^^^^^^^^^^\n</code></pre>\n<p>However, there is a bigger problem here: <code>boost::variant</code> can only hold types which are copy-constructible. From the <a href=\"http://www.boost.org/doc/libs/1_53_0/doc/html/variant/reference.html#header.boost.variant_hpp\" rel=\"noreferrer\">Boost.Variant online documentation</a>:</p>\n<blockquote>\n<p id=\"so_15689793_15689925_0\">The requirements on a bounded type are as follows:</p>\n<ul>\n<li><p id=\"so_15689793_15689925_1\"><strong><code>CopyConstructible</code></strong> [20.1.3].</p></li>\n<li><p id=\"so_15689793_15689925_2\">Destructor upholds the no-throw exception-safety guarantee.</p></li>\n<li><p id=\"so_15689793_15689925_3\">Complete at the point of variant template instantiation. (See <code>boost::recursive_wrapper&lt;T&gt;</code> for a type wrapper that accepts incomplete types to enable recursive variant types.)</p></li>\n</ul>\n<p id=\"so_15689793_15689925_4\"><strong>Every type specified as a template argument to <code>variant</code> must at minimum fulfill the above requirements</strong>. [...]</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-28T19:53:00.857", "Score": "5", "CreationDate": "2013-03-28T18:52:25.247", "ParentId": "15689793", "CommentCount": "11", "OwnerUserId": "1932150", "LastEditDate": "2013-03-28T19:53:00.857"}});