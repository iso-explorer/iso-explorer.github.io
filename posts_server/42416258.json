post_cb({"42416258": {"CommentCount": "3", "ViewCount": "109", "CreationDate": "2017-02-23T12:50:34.090", "LastActivityDate": "2017-02-23T16:27:10.450", "Title": "Can an union's destructor be trivial?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "42416258", "Score": "2", "Body": "<p>Given the following code:</p>\n<pre><code>struct Bar {\n    Bar() { }\n    ~Bar() { }\n};\n\nstruct FooBase {\n    // No virtual destructor\n};\n\nstruct Foo : FooBase {\n    Foo() : bar{} { }\n\n    union {\n        Bar bar;\n    };\n};\n\nint main() {\n    FooBase *p = new Foo;\n    static_cast&lt;Foo *&gt;(p)-&gt;bar.~Bar();\n    delete p;\n}\n</code></pre>\n<p>I wish to detach <code>Foo::bar</code>'s lifetime from its enclosing <code>Foo</code>.<br>\nAs far as I know, <code>delete p;</code> is well-defined if and only if <code>Foo</code>'s destructor is trivial.<br>\nSince <code>Foo</code> only contains an union, and is not supposed to destruct its <code>bar</code> itself, it looks like it is the case: informally speaking, that destructor does nothing.</br></br></p>\n<p>But is this code actually well-defined according to the standard?</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/689ac09526e80c48\" rel=\"nofollow noreferrer\">See it live on Coliru</a></p>\n", "Tags": "<c++><language-lawyer><undefined-behavior><unions>", "OwnerUserId": "3233393", "AnswerCount": "1"}, "42418091": {"ParentId": "42416258", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>First of all, <code>[expr.delete]</code> for me doesn't support your claim that \"<em><code>delete p;</code> is well-defined if and only if Foo's destructor is trivial</em>\".</p>\n<blockquote>\n<p id=\"so_42416258_42418091_0\">In the first alternative (<em>delete object</em>), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>Since the static type is <code>FooBase</code> whereas the dynamic type is <code>Foo</code>, I'd expect that to be UB.</p>\n<p>Furthermore, (even in case this is not UB) I think that the destructor of <code>Foo</code> isn't trivial.</p>\n<blockquote>\n<p id=\"so_42416258_42418091_1\">[class.union]</p>\n<p id=\"so_42416258_42418091_2\">A union-like class is a union or a class that has an anonymous union as a direct member. A union-like <code>class X</code> has a set of variant members. If <code>X</code> is a union its variant members are the non-static data members; otherwise, its variant members are the non-static data members of all anonymous unions that are members of <code>X</code>.</p>\n</blockquote>\n<p>Thus <code>Foo</code> is a union-like class with <code>bar</code> (of type <code>Bar</code> which has a non-trivial destructor) being a variant member.</p>\n<blockquote>\n<p id=\"so_42416258_42418091_3\">[class.dtor]</p>\n<p id=\"so_42416258_42418091_4\">4) If a class has no user-declared destructor, a destructor is implicitly declared as defaulted [...].</p>\n<p id=\"so_42416258_42418091_5\">5) A defaulted destructor for a <code>class X</code> is defined as deleted if</p>\n<ul>\n<li><code>X</code> is a union-like class that has a variant member with a non-trivial destructor [...].</li>\n</ul>\n</blockquote>\n<p>Therefore, I think that the implicitly defaulted destructor of <code>Foo</code> should be defined as deleted and must be user-provided.</p>\n<p>(Declare <code>Foo q;</code> and see the compilation fail.)</p>\n<blockquote>\n<p id=\"so_42416258_42418091_6\">A destructor is trivial if it is not user-provided and if</p>\n<ul>\n<li>[...] for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.</li>\n</ul>\n</blockquote>\n<p>I'd exepect that clause to extend to variant members as well since it doesn't say \"non-variant data members\".</p>\n<hr>\n<p>You <strong>could</strong> have a virtual destructor in <code>FooBase</code> and then implement <code>~Foo()</code> without including <code>bar.~bar();</code> where it would be possible to destroy <code>bar</code> in advance without it being destructed again in <code>~Foo()</code>.</p>\n<p>I'd however strongly advise against it since you'd have to somehow call <code>~bar</code> for every static or dynamic <code>Foo</code> before it goes out of scope.</p>\n</hr>", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2017-02-23T16:27:10.450", "Id": "42418091", "Score": "1", "CreationDate": "2017-02-23T14:09:15.417", "LastActivityDate": "2017-02-23T16:27:10.450"}, "bq_ids": {"n4140": {"so_42416258_42418091_0": {"section_id": 6107, "quality": 0.9629629629629629, "length": 26}, "so_42416258_42418091_4": {"section_id": 400, "quality": 1.0, "length": 7}, "so_42416258_42418091_2": {"section_id": 5920, "quality": 0.5806451612903226, "length": 18}, "so_42416258_42418091_5": {"section_id": 401, "quality": 1.0, "length": 5}}, "n3337": {"so_42416258_42418091_2": {"section_id": 5692, "quality": 0.967741935483871, "length": 30}, "so_42416258_42418091_4": {"section_id": 391, "quality": 1.0, "length": 7}, "so_42416258_42418091_5": {"section_id": 392, "quality": 1.0, "length": 5}, "so_42416258_42418091_0": {"section_id": 5873, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_42416258_42418091_0": {"section_id": 7604, "quality": 0.9629629629629629, "length": 26}, "so_42416258_42418091_2": {"section_id": 7413, "quality": 0.5483870967741935, "length": 17}, "so_42416258_42418091_4": {"section_id": 417, "quality": 1.0, "length": 7}, "so_42416258_42418091_5": {"section_id": 418, "quality": 1.0, "length": 5}}}});