post_cb({"6663083": {"ParentId": "6662917", "CommentCount": "5", "CreationDate": "2011-07-12T10:55:38.723", "OwnerUserId": "837803", "PostTypeId": "2", "Id": "6663083", "Score": "-1", "Body": "<p>Taking the address of a member function results in a constant expression that cannot be stored in a variable. It can only be used to compare for equality to another expression that represenst the address of a function taking the same set of parameters, with the same return type and the same type of this pointer. </p>\n<pre><code>    class a \n    {\n    public:\n        virtual void test();\n    };\n    class b\n    {\n    public:\n        virtual void test();\n    };\n\n    ....\n    a *pa = new a;\n    b *pb = new b;\n\n    if (pb-&gt;test == pa-&gt;test) // legal, but  false\n    if (pb-&gt;test==pb::test) // legal and true\n    // pa-&gt;test will evaluate to a::test, although calling pa-&gt;test() would call\n    // b::test()\n</code></pre>\n", "LastActivityDate": "2011-07-12T10:55:38.723"}, "6663142": {"ParentId": "6662917", "CommentCount": "2", "CreationDate": "2011-07-12T11:00:08.723", "OwnerUserId": "458742", "PostTypeId": "2", "Id": "6663142", "Score": "1", "Body": "<p>If you just want to arbitrarily order them to be keys in a set/map, then you can <code>reinterpret_cast</code> them. You may need a template class like <code>exact_int&lt;sizeof(void (Foo::*bar)())&gt;::type</code> because <a href=\"http://www.codeproject.com/KB/cpp/FastDelegate.aspx\" rel=\"nofollow\">pointers to member functions can have funny sizes</a>.</p>\n", "LastActivityDate": "2011-07-12T11:00:08.723"}, "6669571": {"ParentId": "6662917", "CommentCount": "2", "CreationDate": "2011-07-12T19:00:03.193", "OwnerUserId": "637801", "PostTypeId": "2", "Id": "6669571", "Score": "0", "Body": "<p>You could do something like Ise's idea, only keep it contained to Callback2 class so that you don't need to change anything that uses the class.</p>\n<pre><code>template &lt;class Receiver, class Sender&gt;class CallBack2 : public ICallBack2 {\nprivate:\n   static int nextSequenceNumber;\n   int sequenceNumber;\n\n//snip\n\npublic:\n  CallBack2(Receiver* _receiver, void(Receiver::*_function)(Sender*), Sender* _sender) :\n   sequenceNumber(nextSequenceNumber++), receiver(_receiver), function(_function), sender(_sender) {};\n\n//snip\n\nvirtual bool operator&lt;(const ICallBack2* _other) const {\n  return sequenceNumber&lt;_other-&gt;sequenceNumber;}\n</code></pre>\n", "LastActivityDate": "2011-07-12T19:00:03.193"}, "6662986": {"ParentId": "6662917", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-07-12T10:47:30.517", "Score": "3", "LastEditorUserId": "90527", "LastEditDate": "2011-07-12T11:21:05.710", "Id": "6662986", "OwnerUserId": "90527", "Body": "<p>C++03 <a href=\"http://www.open-std.org/jtc1/sc22/open/n2356/expr.html#expr.rel\" rel=\"nofollow\">\u00a7 5.9</a>, which covers the semantics of the built-in &lt;, &gt;, &lt;= and &gt;=, doesn't mention pointers to members and states:</p>\n<blockquote>\n<p id=\"so_6662917_6662986_0\">Other pointer comparisons are unspecified.</p>\n</blockquote>\n<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/open/n2356/decl.html#dcl.mptr\" rel=\"nofollow\">\u00a7 8.3.3</a>, 3</p>\n<blockquote>\n<p id=\"so_6662917_6662986_1\">The type \"pointer to member\" is distinct from the type \"pointer\",</p>\n</blockquote>\n<p>As a result, we can conclude the result of relational operators applied to pointers to members (whether functions or fields) is unspecified. </p>\n<p>Note that \"unspecified behavior\" is different from \"undefined behavior\", but still means you can't usefully apply the operators as different implementations may have different results. \"Unspecified\" basically means the implementation gets to define the behavior.</p>\n", "LastActivityDate": "2011-07-12T11:21:05.710"}, "6662917": {"CommentCount": "9", "AcceptedAnswerId": "6663142", "CreationDate": "2011-07-12T10:41:31.337", "LastActivityDate": "2011-07-12T19:00:03.193", "PostTypeId": "1", "ViewCount": "181", "FavoriteCount": "2", "Title": "In what ways member functions may be compared to each other?", "Id": "6662917", "Score": "1", "Body": "<p>I would like to know if I can compare 2 member functions with the \"&lt;\" operator. I can do \"==\" but I can't use it in the case below. I tried casting them to <strong>void*</strong> but that won't work either.</p>\n<pre><code>template &lt;class Receiver, class Sender&gt;\nclass CallBack2 : public ICallBack2 {\n\nprotected:\n\n    Receiver* receiver;\n    void(Receiver::*function)(Sender*);\n    Sender* sender;\n\npublic:\n\n    CallBack2(Receiver* _receiver, void(Receiver::*_function)(Sender*), Sender* _sender) : receiver(_receiver), function(_function), sender(_sender) {};\n    virtual ~CallBack2() {};\n\n    virtual void callBack() {\n        (receiver-&gt;*function)(sender);\n    }\n\n    virtual bool operator&lt;(const ICallBack2* _other) const {\n        CallBack2&lt;Receiver, Sender&gt;* other = (CallBack2&lt;Receiver, Sender&gt;*)_other;\n        if (receiver &lt; other-&gt;receiver) {\n            return true;\n        } else if (receiver == other-&gt;receiver &amp;&amp; function &lt; other-&gt;function) {\n            return true; // this line gives the error\n        }\n        return false;\n    }\n};\n</code></pre>\n<p>Any ideas please?</p>\n", "Tags": "<c++><function><operator-overloading><compare>", "OwnerUserId": "113718", "AnswerCount": "7"}, "6663208": {"ParentId": "6662917", "CommentCount": "0", "CreationDate": "2011-07-12T11:04:09.793", "OwnerUserId": "373025", "PostTypeId": "2", "Id": "6663208", "Score": "1", "Body": "<p>5.9.7 (relational operators): \"Other pointer comparisons are unspecified\".</p>\n<p>Since 5.9 is unclear (it deals with functions, but not explicitly member functions), a quick look at 5.10 (equality comparison) clearly separates <em>functions</em> from <em>member functions</em>:</p>\n<blockquote>\n<p id=\"so_6662917_6663208_0\">In addition, pointers to members can be compared, or a pointer to\n  member and a null pointer constant. Pointer to member conversions\n  (4.11) and qualification conversions (4.4) are performed to bring them\n  to a common type. If one operand is a null pointer constant, the\n  common type is the type of the other operand. Otherwise, the common\n  type is a pointer to member type similar (4.4) to the type of one of\n  the operands, with a cv-qualification signature (4.4) that is the\n  union of the cv-qualification signatures of the operand types. [Note:\n  this implies that any pointer to member can be compared to a null\n  pointer constant. ] If both operands are null, they compare equal.\n  Otherwise if only one is null, they compare unequal. Otherwise if\n  either is a pointer to a virtual member function, the result is\n  unspecified. Otherwise they compare equal if and only if they would\n  refer to the same member of the same most derived object (1.8) or the\n  same subobject if they were dereferenced with a hypothetical object of\n  the associated class type.</p>\n</blockquote>\n<p>So you can use the operators, the meaning of <code>==</code> and <code>!=</code> is specified, but the meaning of <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> is unspecified.</p>\n<p>In particular, nothing enforces transitivity, so it is not clear whether putting them in a set is ok or not.</p>\n", "LastActivityDate": "2011-07-12T11:04:09.793"}, "6663551": {"ParentId": "6662917", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-07-12T11:34:48.627", "Score": "1", "LastEditorUserId": "547710", "LastEditDate": "2011-07-12T12:05:23.960", "Id": "6663551", "OwnerUserId": "547710", "Body": "<p>Though the description gets a little lengthy, how about having a dummy\nvariable and comparing its pointer like the following?</p>\n<pre><code>template&lt; class T &gt;\nstruct comparable_value {\n    T value;\n    char *id;\n\n    comparable_value( T value, char* id ) : value( value ), id( id ) {}\n\n    bool operator&lt;( comparable_value const&amp; x ) const {\n        return std::less&lt; char* &gt;()( id, x.id );\n    }\n};\n\ntemplate&lt; class T, T V &gt;\ncomparable_value&lt; T &gt; get_comparable_value() {\n    static char dummy;\n    return comparable_value&lt; T &gt;( V, &amp;dummy );\n}\n\nstruct A {\n    void f() { puts( \"f\" ); }\n    void g() { puts( \"g\" ); }\n};\n\nint main() {\n    typedef void (A::*MF)();\n    typedef std::set&lt; comparable_value&lt; MF &gt; &gt; set_t;\n    set_t s;\n    s.insert( get_comparable_value&lt; MF, &amp;A::f &gt;() );\n    s.insert( get_comparable_value&lt; MF, &amp;A::g &gt;() );\n    A a;\n    for ( set_t::iterator i = s.begin(), e = s.end();  i != e;  ++ i )\n        (a.*i-&gt;value)();\n}\n</code></pre>\n<p>Here is a test on <a href=\"http://ideone.com/ltefn\" rel=\"nofollow\">ideone</a>.</p>\n", "LastActivityDate": "2011-07-12T12:05:23.960"}, "bq_ids": {"n4140": {"so_6662917_6662986_1": {"section_id": 3227, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_6662917_6663208_0": {"section_id": 5918, "quality": 0.98, "length": 98}, "so_6662917_6662986_1": {"section_id": 3100, "quality": 0.8571428571428571, "length": 6}, "so_6662917_6662986_0": {"section_id": 5913, "quality": 1.0, "length": 4}}, "n4659": {"so_6662917_6662986_1": {"section_id": 3984, "quality": 0.8571428571428571, "length": 6}}}, "6663140": {"ParentId": "6662917", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-07-12T10:59:57.723", "Score": "-1", "LastEditorUserId": "306161", "LastEditDate": "2011-07-12T11:56:51.920", "Id": "6663140", "OwnerUserId": "306161", "Body": "<p>It makes no sense to compare two function pointers. What you could compare is actually the return value of those functions:</p>\n<pre><code>*function(sender) &lt; *(other-&gt;function)(sender)\n</code></pre>\n<p>but in your case you declare the function as:</p>\n<pre><code>void(Receiver::*function)(Sender*);\n</code></pre>\n<p>so, in my opinion. Comparing the functions is useless. Either change the function's signature to return something or better describe your business scenario so we can better understand what you want.</p>\n", "LastActivityDate": "2011-07-12T11:56:51.920"}});