post_cb({"17628398": {"ParentId": "17627302", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++ Standard does not define for any non-standard-layout class how it should be laid out in memory, e.g. [class.mem]/13</p>\n<blockquote>\n<p id=\"so_17627302_17628398_0\">Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspecified (Clause 11). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>There are some exceptions / simplifications for standard layout types, but there's no <em>general</em> specification for the memory layout of classes.</p>\n<p>This also holds for the classes in the Standard Library. In addition to that, the Standard only defines requirements for these classes, some of those are \"interfaces\" in the sense of signatures of member functions. Very explicitly in [objects.within.classes]:</p>\n<blockquote>\n<p id=\"so_17627302_17628398_1\">1) Clauses 18 through 30 and Annex D [i.e. the Standard Library] do not specify the representation of classes, and intentionally omit specification of class members (9.2). An implementation may define static or non-static class members, or both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and Annex D.</p>\n<p id=\"so_17627302_17628398_2\">2) Objects of certain classes are sometimes required by the external specifications of their classes to store data, apparently in member objects. For the sake of exposition, some subclauses provide representative declarations, and semantic requirements, for private member objects of classes that meet the external specifications of the classes. The declarations for such member objects and the definitions of related member types are followed by a comment that ends with exposition only, as in:</p>\n<pre><code>streambuf* sb; // exposition only\n</code></pre>\n</blockquote>\n<hr>\n<p>That said, some remarks for required functionality for <code>std::shared_ptr</code>:</p>\n<ul>\n<li>you need to store the reference count for the owned object, in a dynamically allocated object which contains this ownership information (dyn. alloc. because it's not clear which <code>shared_ptr</code> is the last one alive, and this last one has to deallocate it)</li>\n<li>you also need to store the reference count of this ownership information object for the use of <code>weak_ptr</code>, as <code>weak_ptr::expired</code> and <code>weak_ptr::lock</code> etc. may not <em>fail</em> (via an access violation, for example)</li>\n</ul>\n<p><em>Pedantic side remark: The Standard doesn't require <code>shared_ptr</code> <strong>not</strong> to leak memory, but a typical implementation for PC-type architecture will probably use dynamic memory allocation.</em></p>\n<p><code>std::make_shared</code> btw is considered to be faster than using the ctor of <code>std::shared_ptr</code> because it can allocate the memory for both the owned object and the ownership information object in one allocation (the Standard says \"Implementations should perform no more than one memory allocation.\", though that is only a <em>Remark</em>).</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-07-13T08:32:36.380", "Id": "17628398", "Score": "2", "CreationDate": "2013-07-13T08:26:53.857", "LastActivityDate": "2013-07-13T08:32:36.380"}, "17627302": {"CommentCount": "4", "ViewCount": "285", "CreationDate": "2013-07-13T05:35:36.723", "LastActivityDate": "2013-07-13T08:32:36.380", "Title": "How shared_ptr reference counter laid out?", "AcceptedAnswerId": "17628398", "PostTypeId": "1", "Id": "17627302", "Score": "1", "Body": "<p>I am pretty new to C++. I have been though <code>shared_ptr</code> is keeping separated pointer to separate reference-counter variable. But today, I suddenly realized actually I don't know how it laid out, and the reference-value doesn't need to have separated pointer in C++.</p>\n<p>If the layout is defined by standard, what's is correct expected layout of <code>std::shared_ptr</code>?</p>\n", "Tags": "<c++11><shared-ptr><memory-layout>", "OwnerUserId": "246776", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17627302_17628398_0": {"section_id": 5873, "quality": 0.9433962264150944, "length": 50}, "so_17627302_17628398_2": {"section_id": 6247, "quality": 0.9333333333333333, "length": 42}, "so_17627302_17628398_1": {"section_id": 6246, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_17627302_17628398_0": {"section_id": 5644, "quality": 0.9245283018867925, "length": 49}, "so_17627302_17628398_2": {"section_id": 6007, "quality": 0.9333333333333333, "length": 42}, "so_17627302_17628398_1": {"section_id": 6006, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_17627302_17628398_0": {"section_id": 7356, "quality": 0.9433962264150944, "length": 50}, "so_17627302_17628398_1": {"section_id": 7750, "quality": 0.9333333333333333, "length": 28}}}});