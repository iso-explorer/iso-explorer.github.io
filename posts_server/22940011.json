post_cb({"22941590": {"ParentId": "22940011", "CommentCount": "0", "Body": "<p>An old fashioned portable method:</p>\n<pre><code>    bool is_in_range(char range_start, char range_end, char c)\n    {\n      static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz\";\n      unsigned int start_position = 0;\n      unsigned int end_position = 0;\n      unsigned int character_position = 0;\n      c = std::tolower(c);\n      for (unsigned int i = 0; i &lt; sizeof(alphabet); ++i)\n      {\n         if (range_start == alphabet[i])\n         {\n            start_position = i;\n         }\n         if (range_end == alphabet[i])\n         {\n            end_position = i;\n         }\n         if (c == alphabet[i])\n         {\n            character_position = i;\n         }\n      }\n      bool result = false;\n      if (end_position &lt;= start_position)\n      {\n        result = false;\n      }\n      else\n      {\n        if ((character_position &gt;= start_position) &amp;&amp; (character_position &lt;= end_position))\n        {\n          result = true;\n        }\n      }\n      return result;\n}\n</code></pre>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "22941590", "Score": "1", "CreationDate": "2014-04-08T15:33:41.567", "LastActivityDate": "2014-04-08T15:33:41.567"}, "22940149": {"ParentId": "22940011", "CommentCount": "2", "Body": "<p>loop through the string, check every character and see if it stays between a and n using str[i]&gt;'a' and str[i]&lt;'n'</p>\n", "Id": "22940149", "PostTypeId": "2", "OwnerDisplayName": "user3360398", "Score": "0", "CreationDate": "2014-04-08T14:31:19.697", "LastActivityDate": "2014-04-08T14:31:19.697"}, "22940246": {"ParentId": "22940011", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you want to check whether or not the first character of you string is between 'a' and 'n', for instance, checking <code>name[0] &gt;= 'a' &amp;&amp; name[0] &lt;= 'n'</code> should do the job properly.</p>\n<p>Keep in mind, however, that if you can also have caps as a first character in your letter, you have to check <code>(name[0] &gt;= 'a' &amp;&amp; name[0] &lt;= 'n') || (name[0] &gt;= 'A' &amp;&amp; name[0] &lt;= 'N')</code> instead.</p>\n", "OwnerUserId": "3455072", "LastEditorUserId": "3455072", "LastEditDate": "2014-04-08T14:40:28.440", "Id": "22940246", "Score": "5", "CreationDate": "2014-04-08T14:35:08.087", "LastActivityDate": "2014-04-08T14:40:28.440"}, "22940011": {"CommentCount": "7", "AcceptedAnswerId": "22940246", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2014-04-08T14:25:53.617", "LastActivityDate": "2014-04-08T15:33:41.567", "LastEditDate": "2014-04-08T14:31:58.370", "ViewCount": "9181", "FavoriteCount": "0", "Title": "How do I check if a character is in a given range of characters?", "Id": "22940011", "Score": "6", "Body": "<p>C++: How do i check if a character is between a given range of characters?</p>\n<p>Say, if I have a string name.\nI want to check if the first character of this string is between 'a' to 'n'.</p>\n<p>How do I do it? </p>\n<p>To do (name[0] == 'a') (name[0] == 'b')... would be too long...</p>\n<p>If possible, I would like a solution that deals with ASCII values elegantly.</p>\n", "Tags": "<c++><ascii>", "OwnerUserId": "3464570", "AnswerCount": "5"}, "22940529": {"ParentId": "22940011", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can use <a href=\"http://en.cppreference.com/w/cpp/algorithm/all_any_none_of\" rel=\"nofollow\"><code>std::all_of</code></a> in combination with a <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">lambda expression</a>:</p>\n<pre><code>std::all_of(name.begin(), name.end(), [](char i) { return (i &gt;= 'a' &amp;&amp; i &lt;= 'z'); });\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f02d361bfa53e128\" rel=\"nofollow\"><kbd>Live demo</kbd></a></p>\n<p>This is portable enough for most application, since the character set is usually implemented following the ASCII conventions as explain in \u00a72.3/14:</p>\n<blockquote>\n<p id=\"so_22940011_22940529_0\">The glyphs for the members of the basic source character set are intended to identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII character set. However, because the mapping from source file characters to the source character set (described in translation phase 1) is specified as implementation-defined, an implementation is required to document how the basic source characters are represented in source files.</p>\n</blockquote>\n<p>The complexity of the above algorithm is <code>O(n)</code>. The alternative (check every character to be one in the character range with <code>k</code> characters) is <code>O(n*k)</code>, but at least you can be sure it's not implementation defined.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-04-08T15:03:26.663", "Id": "22940529", "Score": "3", "CreationDate": "2014-04-08T14:46:37.693", "LastActivityDate": "2014-04-08T15:03:26.663"}, "22940642": {"ParentId": "22940011", "CommentCount": "0", "Body": "<p>If you're sure the used character set on your platform(s) is ASCII, you can use something like :</p>\n<pre><code>if (std::all_of(name.begin(), name.end(), [](char c){return ((c &gt;= 'a') &amp;&amp; (c &lt;= 'n'));}) ) {\n    // name contains only characters between 'a' and 'n' inclusive\n}\n</code></pre>\n<p>Otherwise, something like this should do the trick :</p>\n<pre><code>if (name.find_first_not_of(\"abcdefghijklmn\") == std::string::npos) {\n    // name contains only characters between 'a' and 'n' inclusive\n}\n</code></pre>\n", "OwnerUserId": "822669", "PostTypeId": "2", "Id": "22940642", "Score": "2", "CreationDate": "2014-04-08T14:51:32.217", "LastActivityDate": "2014-04-08T14:51:32.217"}, "bq_ids": {"n4140": {"so_22940011_22940529_0": {"section_id": 5314, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_22940011_22940529_0": {"section_id": 5111, "quality": 0.975609756097561, "length": 40}}, "n4659": {"so_22940011_22940529_0": {"section_id": 6738, "quality": 0.9512195121951219, "length": 39}}}});