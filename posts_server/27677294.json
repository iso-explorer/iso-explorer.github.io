post_cb({"27677294": {"CommentCount": "2", "ViewCount": "1048", "PostTypeId": "1", "ClosedDate": "2014-12-29T00:50:34.947", "LastEditorUserId": "2755662", "CreationDate": "2014-12-28T14:25:16.837", "LastActivityDate": "2015-06-27T21:00:43.547", "Title": "vector memory allocation call to copy constructor with push_back function", "AcceptedAnswerId": "27677551", "LastEditDate": "2014-12-28T19:47:13.573", "Id": "27677294", "Score": "-1", "Body": "<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nusing namespace std;\n\nclass MoveableClass\n{\npublic:\n        MoveableClass() {\n                cout &lt;&lt; \"Default constructor\" &lt;&lt; endl;\n        }\n        MoveableClass(const MoveableClass&amp; src) {\n                cout &lt;&lt; \"Copy constructor\" &lt;&lt; endl;\n        }\n        MoveableClass(MoveableClass&amp;&amp; src) {\n                cout &lt;&lt; \"Move constructor\" &lt;&lt; endl;\n        }\n        MoveableClass&amp; operator=(const MoveableClass&amp; rhs) {\n                cout &lt;&lt; \"Copy assignment operator\" &lt;&lt; endl;\n                return *this;\n        }\n        MoveableClass&amp; operator=(MoveableClass&amp;&amp; rhs) {\n                cout &lt;&lt; \"Move assignment operator\" &lt;&lt; endl;\n                return *this;\n        }\n};\n\nint main()\n{\n    vector&lt;MoveableClass&gt; vecSource(3);\n    cout &lt;&lt; \"----\" &lt;&lt; endl;\n    MoveableClass mc;\n    cout &lt;&lt; \"----\" &lt;&lt; endl;\n    vecSource.push_back(mc);\n//      vecSource.push_back(mc);\n//      vecSource.push_back(mc);\n//      vecSource.push_back(mc);\n    cout &lt;&lt; \"----\" &lt;&lt; endl;\n    // Copy the elements from vecSource to vecOne\n    vector&lt;MoveableClass&gt; vecOne(vecSource.begin(), vecSource.end());\n    cout &lt;&lt; \"----\" &lt;&lt; endl;\n    // Move the elements from vecSource to vecTwo\n    vector&lt;MoveableClass&gt; vecTwo(make_move_iterator(vecSource.begin()),\n                                                         make_move_iterator(vecSource.end()));\n    cout &lt;&lt; \"----\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>From the above code I have 2 doubts:</p>\n<ol>\n<li><p>Why move ctor is not called from implemented class when I use 2 push_back(mc) functions\n   call to copy ctor is 3 times i.e 1 for first push and for 2nd push first vector is resized (sequently grow) to different memory location (which should have triggered move for first push) 3rd for 2nd push</p></li>\n<li><p>Even when I initialize the vector object  with size 3 why the call to copy ctor increases to 4 for one push_back(mc).</p></li>\n</ol>\n<p>Output:        </p>\n<pre><code>Default constructor\nDefault constructor\nDefault constructor\n----\nDefault constructor\n----\nCopy constructor\nCopy constructor\nCopy constructor\nCopy constructor\n----\nCopy constructor\nCopy constructor\nCopy constructor\nCopy constructor\n----\nMove constructor\nMove constructor\nMove constructor\nMove constructor\n----\n</code></pre>\n<p>gcc version I am using is:</p>\n<pre><code>&gt; gcc version 4.7.3\n</code></pre>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>Thanks for replies I am getting somewhere</p>\n<p>for my 1) point I want to add</p>\n<pre><code>//    MoveableClass(const MoveableClass&amp; src) {\n//                        cout &lt;&lt; \"Copy constructor\" &lt;&lt; endl;\n//                }\n\n    MoveableClass(MoveableClass&amp;&amp; src) noexcept {\n                    cout &lt;&lt; \"Move constructor\" &lt;&lt; endl;\n            }\n    ....\n    void fun() {\n                    cout &lt;&lt; \"hello\\n\";\n            }\n\n    int main()\n    {\n            vector&lt;MoveableClass&gt; vecSource(3);\n    //        vector&lt;MoveableClass&gt;::iterator it;\n       //     vecSource.reserve(3);\n            cout &lt;&lt; \"----\" &lt;&lt; endl;\n            MoveableClass mc;\n            cout &lt;&lt; \"----\" &lt;&lt; endl;\n            mc.fun();\n            vecSource.push_back(mc);\n    //      vecSource.push_back(move(mc));\n    //      vecSource.push_back(move_if_noexcept(mc));\n    //      vecSource.push_back(mc);\n    //      vecSource.push_back(mc);\n    //      vecSource.push_back(mc);\n    //        for(it = vecSource.begin(); it != vecSource.end(); ++it )\n     //          cout &lt;&lt; (*it).fun() &lt;&lt; endl;\n            cout &lt;&lt; \"----\" &lt;&lt; endl;\n            // Copy the elements from vecSource to vecOne\n            vector&lt;MoveableClass&gt; vecOne(vecSource.begin(), vecSource.end());\n        cout &lt;&lt; \"----\" &lt;&lt; endl;\n        // Move the elements from vecSource to vecTwo\n        vector&lt;MoveableClass&gt; vecTwo(make_move_iterator(vecSource.begin()),\n                                                             make_move_iterator(vecSource.end()));\n        cout &lt;&lt; \"----\" &lt;&lt; endl;\n\n        return 0;\n}\n</code></pre>\n<p>I have edited above code </p>\n<pre><code>//      vecSource.push_back(move(mc));               I can call move ctor only\n//      vecSource.push_back(move_if_noexcept(mc));  I can call move ctor only\n                 understood..\n</code></pre>\n<p>If I comment copy constructor I am getting compile error </p>\n<blockquote>\n<p id=\"so_27677294_27677294_0\">knils@knils-HP:IteratorAdapters$ g++ -g -std=c++0x MoveIterators.cpp </p>\n<p id=\"so_27677294_27677294_1\">Internal compiler error: Error reporting routines re-entered.</p>\n<p id=\"so_27677294_27677294_2\">Please submit a full bug report,\n  with preprocessed source if appropriate.</p>\n<p id=\"so_27677294_27677294_3\">See  for instructions.\n  Preprocessed source stored into /tmp/ccHhV599.out file, please attach this to your bugreport.</p>\n</blockquote>\n<p>why its giving this error , why Its not using its default copy ctor </p>\n<p>for 2) point when I initilize for size 3 , does this mean 3 memory locations are initialized with class instance ?</p>\n<pre><code>for(it = vecSource.begin(); it != vecSource.end(); ++it )\n    cout &lt;&lt; (*it).fun() &lt;&lt; endl;\n</code></pre>\n<p>I am not able to use above code It gives error</p>\n<blockquote>\n<p id=\"so_27677294_27677294_4\"><code>MoveIterators.cpp:48:30: note:   mismatched types \u2018const _CharT*\u2019 and \u2018void\u2019</code></p>\n</blockquote>\n<p>To add I think here lies the diff for resize an reserve where reserve do not call default ctor and leaves the memory uninitialised.</p>\n<p>I think its better to use reserve to some space for vector to an extent we need so than It avoids regular memory swaps. even if it exceeds it will to new location.</p>\n<p><strong>UPDATE</strong></p>\n<p>for piece of code changes</p>\n<pre><code>   vector&lt;MoveableClass&gt; vecSource;\n\n    vecSource.push_back(mc);\n    vecSource.push_back(mc);\n</code></pre>\n<p>The o/p I get is</p>\n<p>Copy constructor\nCopy constructor\nMove constructor</p>\n<p>I am confused by the order here.\nI am expecting it \nCopy constructor\nMove constructor\nCopy constructor</p>\n<p>because for first push It initialize one size(copy) for second it reallocate , so moves the existing memory to new location(move) and the copy the second push in new location(copy)\ncompiler differs why..</p>\n<p>Regards! </p>\n</hr>", "Tags": "<c++><c++11><constructor>", "OwnerUserId": "2755662", "AnswerCount": "2"}, "27677551": {"ParentId": "27677294", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_27677294_27677551_0\"><em>vector is resized (sequently grow) to different memory location (which should have triggered move for first push)</em></p>\n</blockquote>\n<p><code>std::vector</code> will utilize a move-constructor during a reallocation only if that move-constructor is declared with a <a href=\"http://en.cppreference.com/w/cpp/language/noexcept_spec\" rel=\"nofollow\"><code>noexcept</code> specifier</a>, or if there is no available copy-constructor (see <a href=\"http://en.cppreference.com/w/cpp/utility/move_if_noexcept\" rel=\"nofollow\"><code>std::move_if_noexcept</code></a> for more details):</p>\n<p>By adding the following minor change:</p>\n<pre><code>MoveableClass(MoveableClass&amp;&amp; src) noexcept {\n//                                 ~~~~~~~^\n        cout &lt;&lt; \"Move constructor\" &lt;&lt; endl;\n}\n</code></pre>\n<p>You will get the output:</p>\n<pre><code>Copy constructor\nMove constructor\nMove constructor\nMove constructor\n</code></pre>\n<p>The <code>noexcept</code> specifier tells the <code>std::vector</code> implementation that it can safely apply a <em>move-semantics</em> to its content. Otherwise, you wouldn't have a <em>strong exception safety guarantee</em>, which basically states that the vector remains intact if the reallocation fails due to an exception:</p>\n<p>\u00a723.3.6.5 [vector.modifiers]/p1:</p>\n<blockquote>\n<p id=\"so_27677294_27677551_1\"><em>Requires:</em> If an exception is thrown other\n  than by the copy constructor, move constructor, assignment operator, or move assignment operator\n  of <code>T</code> or by any <code>InputIterator</code> operation there are no effects. If an exception is thrown by the move\n  constructor of a non-<code>CopyInsertable T</code>, the effects are unspecified.</p>\n</blockquote>\n<p>In addition, the <code>push_back</code> member function will not attempt to move-construct a new element unless its argument can be bound by a non-const rvalue reference - if not, then it falls back to a copy-construction. If you want to move-construct a new element based on the <code>mc</code> instance in a <code>push_back</code> call, you need to pass in an xvalue of <code>mc</code>:</p>\n<pre><code>vecSource.push_back(std::move(mc));\n//                  ~~~~~~~~^\n</code></pre>\n<p><em>Output:</em></p>\n<pre><code>Move constructor\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27677294_27677551_2\"><em>Even when I initialize the vector object with size 3 why the call to copy ctor increases to 4 for one push_back(mc).</em></p>\n</blockquote>\n<p>The initial capacity of <code>vecSource</code>, that one can query with the <code>.capacity()</code> member function, is presumably set to <code>3</code> <em>in your case</em>, which means that any attempt to store more elements results in a need for a reallocation, which requires all the elements already stored in the vector to be copy-constructed to a new memory location.</p>\n<p>One can avoid unexpected reallocations by <em>reserving</em> a sufficient amount of storage space prior the <code>push_back</code> calls that follow:</p>\n<pre><code>vector&lt;MoveableClass&gt; vecSource;\nvecSource.reserve(4);    // reserve a storage for 4 elements\nvecSource.resize(3);     // default-construct 3 elements\ncout &lt;&lt; \"----\" &lt;&lt; endl;\nMoveableClass mc;\nvecSource.push_back(mc); // copy-construct 4th element\n</code></pre>\n<p><em>Output:</em></p>\n<pre><code>Default constructor\nDefault constructor\nDefault constructor\n----\nDefault constructor\nCopy constructor\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27677294_27677551_3\"><em>2) point when I initilize for size 3 , does this mean 3 memory locations are initialized with class instance ?</em></p>\n</blockquote>\n<p>Yes, by giving an initial capacity in the vector's constructor call, or by using the <code>resize</code> member function, in C++11 you get that amount of default-constructed (in C++03 - copy-constructed from a default-constructed element) elements that are ready to be accessed and used.</p>\n<hr>\n<blockquote>\n<p id=\"so_27677294_27677551_4\"><code>cout &lt;&lt; (*it).fun() &lt;&lt; endl;</code></p>\n<p id=\"so_27677294_27677551_5\"><em>I am not able to use above code It gives error</em></p>\n</blockquote>\n<p>You can't print out the result of a function call that declares <code>void</code> as a return type. Just remove the <code>cout</code> part and it wll compile:</p>\n<pre><code>for(auto it = vecSource.begin(); it != vecSource.end(); ++it )\n    (*it).fun();\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27677294_27677551_6\"><em>If I comment copy constructor I am getting compile error</em></p>\n</blockquote>\n<p>Certain operations require the type of vector element to be <em>CopyConstructible</em>; in your code these are:</p>\n<pre><code>vecSource.push_back(mc);\n//...\nvector&lt;MoveableClass&gt; vecOne(vecSource.begin(), vecSource.end());\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_27677294_27677551_7\"><em>\"Copy constructor Copy constructor Move constructor.\" I am confused by the order here. I am expecting it \"Copy constructor Move constructor Copy constructor\"</em></p>\n</blockquote>\n<p>For the following piece of code:</p>\n<pre><code>vector&lt;MoveableClass&gt; vecSource;\nvecSource.push_back(mc);\nvecSource.push_back(mc);\n</code></pre>\n<p>According to your output, the following happens:</p>\n<ol>\n<li>The initial capacity of <code>vector</code> is set to <code>0</code>.</li>\n<li>First <code>push_back</code> call: the <code>mc</code> is copy-inserted to a newly allocated memory storage (<em>Copy constructor</em>).</li>\n<li>Second <code>push_back</code> call: the <code>mc</code> is attempted to be copy-inserted. The capacity of <code>vector</code> is too small, so a new storage is allocated. The copy of <code>mc</code> is inserted into the new storage (<em>Copy constructor</em>). Then, the rest of elements are moved to the new memory location (<em>Move constructor</em>).</li>\n</ol>\n<p>I don't think the order in which a copy-construction of an appended element goes before a rellocation is mandated by the Standard, it's just how it's implemented in libstdc++ you're using.</p>\n<hr>\n<p>Side notes:</p>\n<ol>\n<li><p>Prefer <code>-std=c++11</code> to <code>-std=c++0x</code> if the compiler supports the former.</p></li>\n<li><p>You should not reuse an instance that has already been moved from. I hope you're doing this only for testing purposes.</p></li>\n</ol>\n</hr></hr></hr></hr></hr></hr>", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2015-06-27T21:00:43.547", "Id": "27677551", "Score": "5", "CreationDate": "2014-12-28T14:59:44.240", "LastActivityDate": "2015-06-27T21:00:43.547"}, "27677514": {"ParentId": "27677294", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I have not understood your questions. Sorry. But in my opinion the only place in the code where a question can be arised why is not move constructor  used is where you call push_back</p>\n<pre><code>vecSource.push_back( mc );\n</code></pre>\n<p>In this place the vector reallocates memory that to accomodate one more element that is a copy of <code>mc</code>. If the vector would use move constructor for its already existent elements when in case of an exceprtion the state of the vector would be undefined. Using the copy constructor guarantees that even in case of an exceprion the state of the vector will be valid because the original elements will not be changed.</p>\n<p>But if you will declare the move constructor as not throwing an exception for example</p>\n<pre><code>MoveableClass( MoveableClass &amp;&amp;src ) noexcept\n{\n    std::cout &lt;&lt; \"Move constructor\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>then the output will be</p>\n<pre><code>Copy constructor\nMove constructor\nMove constructor\nMove constructor\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-28T15:02:15.773", "Id": "27677514", "Score": "0", "CreationDate": "2014-12-28T14:54:13.337", "LastActivityDate": "2014-12-28T15:02:15.773"}, "bq_ids": {"n4140": {"so_27677294_27677551_1": {"section_id": 986, "quality": 0.96, "length": 24}}, "n3337": {"so_27677294_27677551_1": {"section_id": 971, "quality": 0.96, "length": 24}}, "n4659": {"so_27677294_27677551_1": {"section_id": 1049, "quality": 0.96, "length": 24}}}});