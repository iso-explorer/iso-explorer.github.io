post_cb({"28034635": {"CommentCount": "4", "ViewCount": "112", "CreationDate": "2015-01-19T22:31:08.777", "LastActivityDate": "2015-01-19T22:44:12.417", "Title": "C++ Size of std::vector Contiguous Section", "AcceptedAnswerId": "28034776", "PostTypeId": "1", "Id": "28034635", "Score": "-1", "Body": "<p>Within a struct, to minimize padding, one should declare the elements largest to smallest, correct?</p>\n<p>An std::vector allocates memory on a section that is not necessarily contiguous, correct?</p>\n<p>Within a struct, how many bits should I consider the std::vector to be when considering its placement within the struct with respect to padding?</p>\n", "Tags": "<c++><vector><struct><size>", "OwnerUserId": "4471821", "AnswerCount": "2"}, "28034669": {"ParentId": "28034635", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28034635_28034669_0\">Within a struct, to minimize padding, one should declare the elements largest to smallest, correct?</p>\n</blockquote>\n<p>That depends. You may be optimizing for cache behavior in some cases which may not necessarily result in that ordering. On most implementations ordering things that way will result in a structure of the smallest size (with the least padding), but that's not guaranteed by the standard or anything like that.<sup>1</sup></p>\n<blockquote>\n<p id=\"so_28034635_28034669_1\">An std::vector allocates memory on a section that is not necessarily contiguous, correct?</p>\n</blockquote>\n<p>That is not correct. <code>vector</code> is required to use one contiguous section. See N3936 23.3.6.1/1:</p>\n<blockquote>\n<p id=\"so_28034635_28034669_2\">A <code>vector</code> is a sequence container that supports random access iterators. In addition, it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve efficiency. The elements of a vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code>.</p>\n</blockquote>\n<blockquote>\n<p id=\"so_28034635_28034669_3\">Within a struct, how many bits should I consider the std::vector to be when considering its placement within the struct with respect to padding?</p>\n</blockquote>\n<p>Vector can't see anything about the members in your structure; it only knows the size.</p>\n<hr>\n<p><sup>1</sup>Consider a hypothetical machine which has 4 byte <code>int</code>s and requires everything be 5 byte aligned. (I don't know of such a machine, but the standard is written in such a way that such a machine would be possible) In that case a structure like:</p>\n<pre><code>struct X\n{\n    int a;\n    int b;\n    char c;\n    char d;\n};\n</code></pre>\n<p>would waste space because</p>\n<pre><code>struct X\n{\n    int a;\n    char c;\n    int b;\n    char d;\n};\n</code></pre>\n<p>would have each of the <code>char</code>s stored into the unused 5<sup>th</sup> byte. Which is why the standard leaves this implementation defined.</p>\n</hr>", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2015-01-19T22:44:12.417", "Id": "28034669", "Score": "4", "CreationDate": "2015-01-19T22:33:33.233", "LastActivityDate": "2015-01-19T22:44:12.417"}, "28034776": {"ParentId": "28034635", "CommentCount": "2", "Body": "<p>I assume you're imagining something like this:</p>\n<pre><code>struct foo {\n  // ...\n  std::vector&lt;T&gt; vec;\n  // ...\n};\n</code></pre>\n<p>I think the thing you're missing is the distinction between the <code>std::vector</code> object itself and the memory it allocates for its elements. The <code>std::vector</code> itself takes up <code>sizeof(std::vector)</code> bytes, so will contribute at least this many bytes to a struct it is contained within if you account for padding.</p>\n<p>Internally, the <code>std::vector</code> object allocates a contiguous region of memory elsewhere in which the elements are stored. To allow an increase or reduction in size, the <code>std::vector</code> may allocate different sizes of memory as you add or remove elements. However, this is irrelevent to your question, as this memory does not contribute to the size of the <code>std::vector</code> and not therefore to the size of the struct of which it is a member.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "28034776", "Score": "1", "CreationDate": "2015-01-19T22:42:38.910", "LastActivityDate": "2015-01-19T22:42:38.910"}, "bq_ids": {"n4140": {"so_28034635_28034669_2": {"section_id": 955, "quality": 0.9803921568627451, "length": 50}}, "n3337": {"so_28034635_28034669_2": {"section_id": 943, "quality": 0.9803921568627451, "length": 50}}, "n4659": {"so_28034635_28034669_2": {"section_id": 1016, "quality": 0.5294117647058824, "length": 27}}}});