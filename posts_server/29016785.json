post_cb({"29016785": {"CommentCount": "4", "AcceptedAnswerId": "29017032", "CreationDate": "2015-03-12T17:47:15.737", "LastActivityDate": "2015-03-12T18:06:23.547", "PostTypeId": "1", "ViewCount": "1092", "FavoriteCount": "1", "Title": "C++ STL's copy() exception safety", "Id": "29016785", "Score": "12", "Body": "<p>If I do </p>\n<pre><code>std::copy(source, source + size, destination);\n</code></pre>\n<p>Do I have strong exception safety guarantee? I.e. if std::copy throws, destination is left unchanged?</p>\n", "Tags": "<c++><exception><stl>", "OwnerUserId": "1441794", "AnswerCount": "4"}, "29017060": {"ParentId": "29016785", "CommentCount": "0", "Body": "<p>A quick search through Clause 25 (the clause specifying most standard algorithms) shows that there are no instance of the phrase <em>no effects</em>, and the standard specifies strong exception safety as \"if an exception is thrown (there are/the function has) no effects\". In other words, nothing in Clause 25 has the strong exception safety guarantee.</p>\n<p>Besides, how could <code>std::copy</code> possibly offer the strong exception safety guarantee? <code>dest</code> can be an arbitrary output iterator that isn't necessarily readable, and can perform arbitrary operations on a write. What if it's a <code>std::ostream_iterator</code> - how do you \"un-write\" what's been written into the stream?</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "29017060", "Score": "7", "CreationDate": "2015-03-12T18:00:55.830", "LastActivityDate": "2015-03-12T18:00:55.830"}, "bq_ids": {"n4140": {"so_29016785_29017032_1": {"section_id": 1286, "quality": 0.8260869565217391, "length": 19}, "so_29016785_29017032_4": {"section_id": 1289, "quality": 0.8, "length": 4}}, "n3337": {"so_29016785_29017032_1": {"section_id": 1281, "quality": 0.8260869565217391, "length": 19}, "so_29016785_29017032_4": {"section_id": 1284, "quality": 0.8, "length": 4}}, "n4659": {"so_29016785_29017032_1": {"section_id": 1409, "quality": 0.8260869565217391, "length": 19}, "so_29016785_29017032_4": {"section_id": 1411, "quality": 0.8, "length": 4}}}, "29017162": {"ParentId": "29016785", "CommentCount": "0", "Body": "<p><strong>Appendix E: Standard-Library Exception Safety</strong> from  Stroustrop's <em>The C++ Programming Language</em> is <a href=\"http://www.stroustrup.com/3rd_safe.pdf\">freely viewable from his website</a>.</p>\n<p>From that:</p>\n<blockquote>\n<p id=\"so_29016785_29017162_0\">The copy() algorithm (\u00a718.6.1) does <em>not</em> offer the strong\n  exception-safety guarantee. It does not guarantee that it will leave its target unchanged if an exception\n  is thrown during copying</p>\n</blockquote>\n", "OwnerUserId": "16287", "PostTypeId": "2", "Id": "29017162", "Score": "13", "CreationDate": "2015-03-12T18:06:23.547", "LastActivityDate": "2015-03-12T18:06:23.547"}, "29017032": {"ParentId": "29016785", "CommentCount": "2", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_29016785_29017032_0\"><strong>25.3.1 Copy</strong>  [alg.copy]</p>\n<pre><code>template&lt;class InputIterator, class OutputIterator&gt;\n   OutputIterator copy(InputIterator first, InputIterator last,\n                       OutputIterator result);\n</code></pre>\n<p id=\"so_29016785_29017032_1\">1 <em>Effects:</em> Copies elements in the range <code>[first,last)</code> into the range <code>[result,result + (last -first))</code> starting from <code>first</code> and proceeding to <code>last</code>. For each non-negative integer <code>n &lt; (last -first)</code>, performs <code>*(result + n) = *(first + n)</code>.</p>\n<p id=\"so_29016785_29017032_2\">2 <em>Returns:</em> <code>result + (last - first).</code></p>\n<p id=\"so_29016785_29017032_3\">3 <em>Requires:</em> <code>result</code> shall not be in the range <code>[first,last)</code>.</p>\n<p id=\"so_29016785_29017032_4\">4 <em>Complexity:</em> Exactly <code>last - first</code> assignments.</p>\n</blockquote>\n<p>It does not make any guarantees about exception safety. It also does not specify what the behavior would be if <code>result</code> is in the range <code>[first,last)</code>.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29017032", "Score": "8", "CreationDate": "2015-03-12T17:59:46.690", "LastActivityDate": "2015-03-12T17:59:46.690"}, "29017035": {"ParentId": "29016785", "CommentCount": "0", "Body": "<p>Copy is defined in 25.3.1 as</p>\n<pre><code>template&lt;class InputIterator, class OutputIterator&gt;\nOutputIterator copy(InputIterator first, InputIterator last,\nOutputIterator result);\n1 Effects: Copies elements in the range [first,last) into the range [result,result + (last -\nfirst)) starting from first and proceeding to last. For each non-negative integer n &lt; (last -\nfirst), performs *(result + n) = *(first + n).\n2 Returns: result + (last - first).\n3 Requires: result shall not be in the range [first,last).\n4 Complexity: Exactly last - first assignments.\n</code></pre>\n<p>Which can be effectively written as:</p>\n<pre><code>template&lt;class InputIterator, class OutputIterator&gt;\n  OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)\n{\n  while (first!=last) {\n    *result = *first;\n    ++result; ++first;\n  }\n  return result;\n}\n</code></pre>\n<p>The way that it is formatted if the exception happens any time after the first execution of the loop then the the destination will be changed.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "29017035", "Score": "4", "CreationDate": "2015-03-12T17:59:55.850", "LastActivityDate": "2015-03-12T17:59:55.850"}});