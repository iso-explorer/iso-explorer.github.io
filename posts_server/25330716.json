post_cb({"25408989": {"LastActivityDate": "2016-03-07T02:12:56.790", "LastEditorUserId": "-1", "ParentId": "25330716", "LastEditDate": "2017-04-13T12:40:33.367", "Id": "25408989", "Score": "13", "Body": "<p>No, there is no move-only version of <code>std::function</code> in the C++ <code>std</code> library.  (As of C++14)</p>\n<p><a href=\"https://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11\">Fastest possible delegates</a> is an implementation of a <code>std::function</code> like class that happens to be faster than most <code>std::function</code> implementations in many <code>std</code> libraries, and it should be easy to fork into a <code>move</code> and <code>copy</code> version.</p>\n<p>Wrapping your <code>move</code> only function object into a <code>shared_ptr&lt;F&gt;</code> in a class with a forwarding <code>operator()</code> is another approach.</p>\n<p>Here is a <code>task</code> sketch:</p>\n<pre><code>template&lt;class Sig&gt;\nstruct task;\n\nnamespace details {\n  template&lt;class Sig&gt;\n  struct task_iimpl;\n  template&lt;class R, class...Args&gt;\n  struct task_iimpl&lt;R(Args...)&gt; {\n    virtual ~task_iimpl() {}\n    virtual R invoke(Args&amp;&amp;...args) const = 0;\n  };\n  template&lt;class F, class Sig&gt;\n  struct task_impl;\n  template&lt;class F, class R, class...Args&gt;\n  struct task_impl&lt;F,R(Args...)&gt;:\n    task_iimpl&lt;R(Args...)&gt;\n  {\n    F f;\n    template&lt;class T&gt;\n    task_impl(T&amp;&amp; t):f(std::forward&lt;T&gt;(t)) {}\n    virtual R invoke(Args&amp;&amp;...args) const override {\n      return f( std::forward&lt;Args&gt;(args...) );\n    }\n  };\n  template&lt;class F, class...Args&gt;\n  struct task_impl&lt;F,void(Args...)&gt;:\n    task_iimpl&lt;void(Args...)&gt;\n  {\n    F f;\n    template&lt;class T&gt;\n    task_impl(T&amp;&amp; t):f(std::forward&lt;T&gt;(t)) {}\n    virtual void invoke(Args&amp;&amp;...args) const override {\n      f( std::forward&lt;Args&gt;(args...) );\n    }\n  };\n}\ntemplate&lt;class R, class...Args&gt;\nstruct task&lt;R(Args...)&gt; {\n  virtual ~task_iimpl() {}\n  R operator()(Args...args) const {\n    return pImpl-&gt;invoke(std::forward&lt;Args&gt;(args...));\n  }\n  explicit operator bool()const{ return static_cast&lt;bool&gt;(pImpl); }\n  task(task &amp;&amp;)=default;\n  task&amp; operator=(task &amp;&amp;)=default;\n  task()=default;\n\n  // and now for a mess of constructors\n  // the rule is that a task can be constructed from anything\n  // callable&lt;R(Args...)&gt;, destroyable, and can be constructed\n  // from whatever is passed in.  The callable feature is tested for\n  // in addition, if constructed from something convertible to `bool`,\n  // then if that test fails we construct an empty task.  This makes us work\n  // well with empty std::functions and function pointers and other tasks\n  // that are call-compatible, but not exactly the same:\n  struct from_func_t {};\n  template&lt;class F,\n    class dF=std::decay_t&lt;F&gt;,\n    class=std::enable_if_t&lt;!std::is_same&lt;dF, task&gt;{}&gt;,\n    class FR=decltype(std::declval&lt;F const&amp;&gt;()(std::declval&lt;Args&gt;()...)),\n    std::enable_if_t&lt;std::is_same&lt;R, void&gt;{} || std::is_convertible&lt;FR, R&gt;{} &gt;*=0,\n    std::enable_if_t&lt;std::is_convertible&lt;dF, bool&gt;{}&gt;*=0\n  &gt;\n  task(F&amp;&amp; f):\n    task(\n      static_cast&lt;bool&gt;(f)?\n      task( from_func_t{}, std::forward&lt;F&gt;(f) ):\n      task()\n    )\n  {}\n  template&lt;class F,\n    class dF=std::decay_t&lt;F&gt;,\n    class=std::enable_if_t&lt;!std::is_same&lt;dF, task&gt;{}&gt;,\n    class FR=decltype(std::declval&lt;F const&amp;&gt;()(std::declval&lt;Args&gt;()...)),\n    std::enable_if_t&lt;std::is_same&lt;R, void&gt;{} || std::is_convertible&lt;FR, R&gt;{} &gt;*=0,\n    std::enable_if_t&lt;!std::is_convertible&lt;dF, bool&gt;{}&gt;*=0\n  &gt;\n  task(F&amp;&amp; f):\n    task( from_func_t{}, std::forward&lt;F&gt;(f) )\n  {}\n\n  task(std::nullptr_t):task() {}\n  // overload resolution helper when signatures match exactly:\n  task( R(*pf)(Args...) ):\n    task( pf?task( from_func_t{}, pf ):task() )\n  {}\nprivate:\n  template&lt;class F,\n    class dF=std::decay_t&lt;F&gt;\n  &gt;\n  task(from_func_t, F&amp;&amp; f):\n    pImpl( std::make_unique&lt;details::task_impl&lt;dF,R(Args...)&gt;&gt;(\n      std::forward&lt;F&gt;(f)\n    )\n  {}\n\n  std::unique_ptr&lt;details::task_iimpl&lt;R(Args...)&gt; pImpl;\n};\n</code></pre>\n<p>but it has not been tested or compiled, I just wrote it.</p>\n<p>A more industrial strength version would include a small buffer optimization (SBO) to store small callables (assuming they are movable; if not movable, store on heap to allow moving), and a get-pointer-if-you-guess-the-type-right (like <code>std::function</code>).</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1774667", "CreationDate": "2014-08-20T15:41:13.963"}, "25330716": {"ViewCount": "3107", "Tags": "<c++><c++11>", "AnswerCount": "1", "OwnerUserId": "2392147", "Body": "<p>Because  <code>std::function</code> is copyable, the standard requires that callables used to construct std::function also be copyable:</p>\n<p>n337 (20.8.11.2.1) </p>\n<blockquote>\n<p id=\"so_25330716_25330716_0\"><code>template&lt;class F&gt; function(F f);</code></p>\n<p id=\"so_25330716_25330716_1\">Requires: <code>F</code> shall be CopyConstructible. <code>f</code> shall be Callable (20.8.11.2) for argument types <code>ArgTypes</code> and return type <code>R</code>. The copy constructor and destructor of A shall not throw exceptions.`</p>\n</blockquote>\n<p>This implies that it is not possible to form a std::function from a non-copyable bind object or a lambda that captured a move-only type such as a unique_ptr.  </p>\n<p>It seems possible to implement such a move-only wrapper for move-only callables.  Is there a standard library move-only equivalent for std::function? or, is there a common workaround for this problem?</p>\n", "CommentCount": "12", "PostTypeId": "1", "CreationDate": "2014-08-15T16:55:37.607", "FavoriteCount": "11", "LastActivityDate": "2016-03-07T02:12:56.790", "Id": "25330716", "LastEditorUserId": "2392147", "Title": "move-only version of std::function", "Score": "37", "LastEditDate": "2014-08-20T19:02:06.010"}, "bq_ids": {"n3337": {"so_25330716_25330716_1": {"section_id": 4470, "quality": 0.8, "length": 12}}}});