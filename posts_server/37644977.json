post_cb({"37644977": {"ViewCount": "532", "Body": "<p>Consider following sample code:</p>\n<pre><code>class C\n{\npublic:\n    int* x;\n};\n\nvoid f()\n{\n    C* c = static_cast&lt;C*&gt;(malloc(sizeof(C)));\n    c-&gt;x = nullptr; // &lt;-- here\n}\n</code></pre>\n<p>If I had to live with the uninitialized memory for any reason (of course, if possible, I'd call <code>new C()</code> instead), I still <em>could</em> call the placement constructor. But if I omit this, as above, and initialize <em>every</em> member variable manually, does it result in undefined behaviour? I.e. is circumventing the constructor per se undefined behaviour or is it legal to replace calling it with some equivalent code outside the class?</p>\n<p>(Came across this via another question on a completely different matter; asking for curiosity...)</p>\n", "AcceptedAnswerId": "37645107", "Title": "Is circumventing a class' constructor legal or does it result in undefined behaviour?", "CreationDate": "2016-06-05T17:49:48.680", "Id": "37644977", "CommentCount": "25", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-06-11T05:30:11.027", "LastEditorUserId": "963864", "LastActivityDate": "2016-07-08T04:25:49.227", "Score": "14", "OwnerUserId": "1312382", "Tags": "<c++><malloc><language-lawyer><object-lifetime>", "AnswerCount": "6"}, "37646022": {"Id": "37646022", "PostTypeId": "2", "Body": "<p>I think the code is ok, as long as the type has a trivial constructor, as yours. Using the object cast from <code>malloc</code> without calling the placement <code>new</code> is just using the object before calling its constructor. From C++ standard 12.7 [class.dctor]:</p>\n<blockquote>\n<p id=\"so_37644977_37646022_0\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior.</p>\n</blockquote>\n<p>Since <em>the exception proves the rule</em>, referrint to a non-static member of an object with a trivial constructor before the constructor begins execution <strong>is not UB</strong>.</p>\n<p>Further down in the same paragraphs there is this example:</p>\n<pre><code>extern X xobj;\nint* p = &amp;xobj.i;\nX xobj;\n</code></pre>\n<p>This code is labelled as UB when <code>X</code> is non-trivial, but as not UB when <code>X</code> is trivial.</p>\n", "LastActivityDate": "2016-06-05T19:40:36.133", "Score": "3", "CreationDate": "2016-06-05T19:40:36.133", "ParentId": "37644977", "CommentCount": "11", "OwnerUserId": "865874"}, "37645271": {"Id": "37645271", "PostTypeId": "2", "Body": "<p>This particular code is fine, because <code>C</code> is a POD. As long as <code>C</code> is a POD, it can be initialized that way as well.</p>\n<p>Your code is equivalent to this:</p>\n<pre><code>struct C\n{\n   int *x;\n};\n\nC* c = (C*)malloc(sizeof(C)); \nc-&gt;x = NULL;\n</code></pre>\n<p>Does it not look like familiar? It is all good. There is no problem with this code.</p>\n", "LastActivityDate": "2016-06-05T18:20:03.740", "Score": "0", "CreationDate": "2016-06-05T18:20:03.740", "ParentId": "37644977", "CommentCount": "58", "OwnerUserId": "415784"}, "37645073": {"Id": "37645073", "PostTypeId": "2", "Body": "<p>For the most part, circumventing the constructor generally <strong>results in undefined behavior</strong>.</p>\n<p>There are some, arguably, <strong>corner cases for plain old data types</strong>, but you don't win anything avoiding them in the first place anyway, the constructor is trivial. Is the code as simple as presented?</p>\n<p><a href=\"http://eel.is/c++draft/basic.life#1\" rel=\"nofollow\">[basic.life]/1</a></p>\n<blockquote>\n<p id=\"so_37644977_37645073_0\">The lifetime of an object or reference is a runtime property of the object or reference. An object is said to have non-vacuous initialization if it is of a class or aggregate type and it or one of its subobjects is initialized by a constructor other than a trivial default constructor. [ Note: initialization by a trivial copy/move constructor is non-vacuous initialization.  \u2014 end note ] The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-vacuous initialization, its initialization is complete.</li>\n</ul>\n<p id=\"so_37644977_37645073_1\">The lifetime of an object of type T ends when:</p>\n<ul>\n<li>if T is a class type with a non-trivial destructor ([class.dtor]), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>Aside from code being harder to read and reason about, you will either not win anything, or land up with undefined behavior. <strong>Just use the constructor, it is idiomatic C++.</strong></p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2016-06-08T20:29:01.280", "Score": "1", "CreationDate": "2016-06-05T18:00:15.517", "ParentId": "37644977", "CommentCount": "7", "LastEditDate": "2016-06-08T20:29:01.280", "OwnerUserId": "3747990"}, "37645065": {"Id": "37645065", "PostTypeId": "2", "Body": "<p>I think it shouldn't be UB. You make your pointer point to some raw memory and are treating its data in a particular way, there's nothing bad here. </p>\n<p>If the constructor of this class does something (initializes variables, etc), you'll end up with, again, a pointer to raw, uninitialized object, using which without knowing what the (default) constructor was supposed to be doing (and repeating its behavior) will be UB.</p>\n", "LastActivityDate": "2016-06-05T17:59:38.727", "Score": "-2", "CreationDate": "2016-06-05T17:59:38.727", "ParentId": "37644977", "CommentCount": "0", "OwnerUserId": "4354477"}, "bq_ids": {"n4140": {"so_37644977_37646022_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}, "so_37644977_37645073_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_37644977_37645073_0": {"length": 30, "quality": 0.7317073170731707, "section_id": 7189}}, "n3337": {"so_37644977_37645073_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_37644977_37646022_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}, "so_37644977_37645073_0": {"length": 30, "quality": 0.7317073170731707, "section_id": 6933}}, "n4659": {"so_37644977_37645073_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_37644977_37645107_0": {"length": 13, "quality": 0.6842105263157895, "section_id": 7247}, "so_37644977_37646022_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_37644977_37645073_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 8697}}}, "37650139": {"Id": "37650139", "PostTypeId": "2", "Body": "<p>While you can initialize all explicit members that way, you cannot initialize everything a class may contain:</p>\n<ol>\n<li><p>references cannot be set outside an initializer list</p></li>\n<li><p>vtable pointers cannot be manipulated by code at all</p></li>\n</ol>\n<p>That is, the moment that you have a single virtual member, or virtual base class, or reference member, there is no way to correctly initialize your object except by calling its constructor.</p>\n", "LastEditorUserId": "2445184", "LastActivityDate": "2016-06-11T19:45:01.803", "Score": "-1", "CreationDate": "2016-06-06T05:33:12.793", "ParentId": "37644977", "CommentCount": "13", "LastEditDate": "2016-06-11T19:45:01.803", "OwnerUserId": "2445184"}, "37645107": {"Id": "37645107", "PostTypeId": "2", "Body": "<p>There is no living <code>C</code> object, so pretending that there is one results in undefined behavior.</p>\n<p><a href=\"https://github.com/cplusplus/draft/commit/531b0dc95328b7f6e0648667803da713c7f4fc23\" rel=\"nofollow\">P0137R1</a>, adopted at the committee's Oulu meeting, makes this clear by defining <em>object</em> as follows (<a href=\"http://eel.is/c++draft/intro.object#1\" rel=\"nofollow\">[intro.object]/1</a>):</p>\n<blockquote>\n<p id=\"so_37644977_37645107_0\">An <em>object</em> is created by a definition ([basic.def]), by a <em>new-expression</em> ([expr.new]), when implicitly changing the active member of a union ([class.union]), or when a temporary object is created ([conv.rval], [class.temporary]). </p>\n</blockquote>\n<p><code>reinterpret_cast&lt;C*&gt;(malloc(sizeof(C)))</code> is none of these.</p>\n<p>Also see <a href=\"https://groups.google.com/a/isocpp.org/d/topic/std-proposals/gN-_7CJ58G4/discussion\" rel=\"nofollow\">this std-proposals thread</a>, with a very similar example from Richard Smith (with a typo fixed):</p>\n<blockquote id=\"so_37644977_37645107_1\">\n<pre><code>struct TrivialThing { int a, b, c; };\nTrivialThing *p = reinterpret_cast&lt;TrivialThing*&gt;(malloc(sizeof(TrivialThing))); \np-&gt;a = 0; // UB, no object of type TrivialThing here\n</code></pre>\n</blockquote>\n<p>The [basic.life]/1 quote applies only when an object is created in the first place. Note that \"trivial\" or \"vacuous\" (after the terminology change done by <a href=\"http://wg21.link/CWG1751\" rel=\"nofollow\">CWG1751</a>) initialization, as that term is used in [basic.life]/1, is a property of an object, not a type, so \"there is an object because its initialization is vacuous/trivial\" is backwards.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-07-08T04:25:49.227", "Score": "5", "CreationDate": "2016-06-05T18:03:05.897", "ParentId": "37644977", "CommentCount": "26", "LastEditDate": "2016-07-08T04:25:49.227", "OwnerUserId": "2756719"}});