post_cb({"bq_ids": {"n4140": {"so_33212696_33213424_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5408}, "so_33212696_33212696_0": {"length": 4, "quality": 0.8, "section_id": 5497}}, "n3337": {"so_33212696_33213424_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5203}, "so_33212696_33212696_0": {"length": 4, "quality": 0.8, "section_id": 5283}}, "n4659": {"so_33212696_33213424_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 6830}, "so_33212696_33212696_0": {"length": 4, "quality": 0.8, "section_id": 6931}}}, "33213424": {"Id": "33213424", "PostTypeId": "2", "Body": "<p>Do not confuse using-declarations and alias declarations. <code>using A = B;</code> is an <em>alias-declaration</em>, which semantically is the same as a typedef:</p>\n<blockquote>\n<p id=\"so_33212696_33213424_0\">A\n  typedef-name\n  can also be introduced by an\n  alias-declaration\n  . The\n  identifier\n  following the\n  using\n  keyword\n  becomes a\n  typedef-name\n  and the optional\n  attribute-specifier-seq\n  following the\n  identifier\n  appertains to that\n  typedef-name\n  . It has the same semantics as if it were introduced by the\n  typedef\n  specifier. In particular, it\n  does not define a new type and it shall not appear in the\n  type-id\n  .</p>\n</blockquote>\n<p>So, you write <code>using Inner = Outer::Inner</code> because it's the same as <code>typedef Outer::Inner Inner</code>, not just <code>typedef Outer::Inner</code>. An <em>alias-declaration</em> makes an alias for a type name. </p>\n<p>A <em>using-declaration</em>, on the other hand, is something different: it introduces a name into scope (7.3.3/1), but it is also invoked by the word <code>using</code>, which is somewhat confusing.</p>\n<p>So,</p>\n<blockquote>\n<p id=\"so_33212696_33213424_1\">// using Outer::Inner should be identical to\n  using Inner = Outer::Inner</p>\n</blockquote>\n<p>they can't be identical, they are different things.</p>\n", "LastActivityDate": "2015-10-19T11:39:13.080", "CommentCount": "1", "CreationDate": "2015-10-19T11:39:13.080", "ParentId": "33212696", "Score": "1", "OwnerUserId": "1490355"}, "33212696": {"ViewCount": "62", "Body": "<p>What is the reason that using declarations for class members are only allowed as a member declaration? I cannot do</p>\n<pre><code>struct Outer\n{\n    typedef int Inner;\n};\n\nvoid f()\n{\n// this doesn't work with C++14\n     using Outer::Inner;\n}\n</code></pre>\n<p>, but I think this would be fairly orthogonal with the intended semantics of using-declaratives to introduce a name declared somewhere else into the current region. It is explicitly restricted by the C++ standard </p>\n<blockquote>\n<p id=\"so_33212696_33212696_0\">7.3.3/8: A using-declaration for a class member shall be a\n  member-declaration</p>\n</blockquote>\n<p>, but I wonder why. </p>\n<p>I think it would make the language more regular if it was allowed for inner-types (typedefs, classes etc) and defined to be identical to </p>\n<pre><code>// using Outer::Inner should be identical to\nusing Inner = Outer::Inner\n</code></pre>\n<p>, which is identical to the behavior for namespaces. </p>\n<p>I know this question <a href=\"https://stackoverflow.com/questions/11126203/using-declaration-for-a-class-member-shall-be-a-member-declaration-c2003\">has been asked before</a>, but the accepted answer is that is forbidden because the standard says so. I am wondering if there any technical reasons behind it. In one of the comments, it is said that</p>\n<blockquote>\n<p id=\"so_33212696_33212696_1\">Making the Standard (and therefore all compilers) more complicated to\n  handle an unusual case that has a convenient workaround just doesn't\n  pass the cost-benefit test.</p>\n</blockquote>\n<p>I would say that is an opinion rather than an argument. Changing it such that the language becomes more uniform is a huge benefit. Right now, you have to teach different things for doing the same thing. And if you remove the clause, the standard would become simpler, both because the size is reduced, but also because a (seamingly arbitrary) special case is removed.</p>\n<p>To be more precise, I am looking for <strong>technical reasons</strong> why this is not allowed, e.g. places were it would create ambiguities or other problems. </p>\n", "Title": "Using declaration for inner types", "CreationDate": "2015-10-19T11:01:15.960", "Id": "33212696", "CommentCount": "8", "LastEditDate": "2015-10-19T11:39:25.407", "PostTypeId": "1", "LastEditorUserId": "2169853", "LastActivityDate": "2015-10-19T11:39:25.407", "Tags": "<c++>", "Score": "2", "OwnerUserId": "2169853", "ClosedDate": "2015-10-19T11:35:54.130", "AnswerCount": "1"}});