post_cb({"16527949": {"Id": "16527949", "PostTypeId": "2", "Body": "<p>You cannot delete your object properly if you do it like that.</p>\n<p>Implicitly you do the following.</p>\n<pre><code>class A\n{\npublic:\n  int test (void) { return 1; }\n};\n\nint main (void)\n{\n  A * p = new A;\n  A v(*p);\n  //...\n  delete &amp;v; // &amp;v != p and v is not constructed via new!\n  return 0;\n}\n</code></pre>\n<p>If you want to work with an object-like-syntax you can bind a reference to the object.</p>\n<pre><code>class A\n{\npublic:\n  int test (void) { return 1; }\n};\n\nint main (void)\n{\n   A * p = new A;\n   A &amp; r = *p;\n   int i = r.test();\n   delete p;\n   return 0;\n}\n</code></pre>\n<p>If you delete your object through the same pointer, there will be no leak.</p>\n", "LastActivityDate": "2013-05-13T17:40:43.947", "CommentCount": "0", "CreationDate": "2013-05-13T17:40:43.947", "ParentId": "16527829", "Score": "0", "OwnerUserId": "951423"}, "16527858": {"Id": "16527858", "PostTypeId": "2", "Body": "<p>No, and in fact this leads to a leak. <code>x</code> is <strong>copy initialized</strong>, so the original object pointed to by <code>new obj</code> is lost.</p>\n<p>Just use</p>\n<pre><code>obj x(...);\n</code></pre>\n<p>No need for dynamic allocation. Or</p>\n<pre><code>obj x = obj(...);\n</code></pre>\n<p>if you must (doubt it).</p>\n", "LastActivityDate": "2013-05-13T17:33:51.120", "CommentCount": "6", "CreationDate": "2013-05-13T17:33:51.120", "ParentId": "16527829", "Score": "8", "OwnerUserId": "673730"}, "16527829": {"ViewCount": "1816", "Body": "<p>To avoid keep having to use <code>-&gt;</code> and instead work directly with the object, is it acceptable  practice to do:</p>\n<pre><code>obj x = *(new obj(...));\n...\ndelete &amp;obj;\n</code></pre>\n", "AcceptedAnswerId": "16527861", "Title": "Is it considered good style to dereference `new` pointer?", "CreationDate": "2013-05-13T17:32:27.667", "Id": "16527829", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-05-13T17:34:30.737", "LastEditorUserId": "21640", "LastActivityDate": "2013-05-14T13:49:28.683", "Score": "14", "OwnerUserId": "1681681", "Tags": "<c++><pointers><new-operator><dereference>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_16527829_16527861_0": {"length": 27, "quality": 1.0, "section_id": 6106}}, "n3337": {"so_16527829_16527861_0": {"length": 27, "quality": 1.0, "section_id": 5872}}, "n4659": {"so_16527829_16527861_0": {"length": 27, "quality": 1.0, "section_id": 7603}}}, "16527899": {"Id": "16527899", "PostTypeId": "2", "Body": "<p>Certainly not; that copies the dynamic object to an automatic variable, loses the only pointer to it, and then attempts to delete the automatic copy. You've got a memory leak and an invalid deletion.</p>\n<p>Much better would be to use an automatic variable in the first place:</p>\n<pre><code>obj x(...);\n...\n// no need to delete anything\n</code></pre>\n<p>or, if it really must be dynamic for some reason (because it's too big for the stack, or you don't always want to destroy it here), then use a smart pointer, and a reference if you really don't like <code>-&gt;</code></p>\n<pre><code>std::unique_ptr&lt;obj&gt; p(new obj(...));\nobj &amp; x = *p;\n...\n// still no need to delete anything\n</code></pre>\n<p>Changing your <code>x</code> into a reference would be valid (as long as you're careful that exceptions, early function returns, etc. won't cause a leak), but would cause howls of confusion among anyone unfortunate enough to have to maintain it.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-05-14T13:49:28.683", "Score": "7", "CreationDate": "2013-05-13T17:37:11.220", "ParentId": "16527829", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2013-05-14T13:49:28.683"}, "16527861": {"Id": "16527861", "PostTypeId": "2", "Body": "<p>This is not just poor practice, but:</p>\n<ol>\n<li>Leaking memory (most likely, unless you are using some pattern that is not visible from the code you provided), since <code>obj</code> will store a <em>copy</em> of the original object created by the <code>new</code> expression, and the pointer to that object returned by <code>new</code> is lost;</li>\n<li>Most importantly, <strong>undefined behavior</strong>, since you are passing to <code>delete</code> a pointer to an object that was not allocated with <code>new</code>. Per paragraph 5.3.5/2 of the C++11 Standard:</li>\n</ol>\n<blockquote>\n<p id=\"so_16527829_16527861_0\">[...] In the first alternative (delete object), the value of the operand of delete may be a null pointer \n  value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8)\n  representing a base class of such an object (Clause 10). <strong>If not, the behavior is undefined</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-13T17:34:01.360", "CommentCount": "3", "CreationDate": "2013-05-13T17:34:01.360", "ParentId": "16527829", "Score": "29", "OwnerUserId": "1932150"}});