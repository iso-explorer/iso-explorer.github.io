post_cb({"27629237": {"ParentId": "27629039", "CommentCount": "1", "CreationDate": "2014-12-23T22:58:37.283", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "27629237", "Score": "2", "Body": "<p>You can extend the idea of a helper template class, and put pretty much everything in there. It's not exactly pretty for whoever has to write the specialisations, but it's very convenient for the user, who can just call <code>f&lt;0&gt;</code>, <code>f&lt;1&gt;</code>, etc. It doesn't really <em>need</em> <code>decltype</code>, but <code>decltype</code> does make it quite a bit easier to write.</p>\n<pre><code>template &lt;int N&gt;\nstruct f_impl;\n\ntemplate &lt;int N&gt;\ndecltype(f_impl&lt;N&gt;::impl()) f()\n{ return f_impl&lt;N&gt;::impl(); }\n\ntemplate &lt;&gt; struct f_impl&lt;0&gt; {\n  static int impl() { return 1; }\n};\n\ntemplate &lt;&gt; struct f_impl&lt;1&gt; {\n  static const char *impl() { return \" Hello, world!\"; }\n};\n\nint main() {\n  std::puts(f&lt;1&gt;() + f&lt;0&gt;());\n}\n</code></pre>\n<p>You might be able to make it a bit more manageable with macros: instead of</p>\n<pre><code>template &lt;&gt; struct f_impl&lt;1&gt; {\n  static const char *impl() { return \" Hello, world!\"; }\n};\n</code></pre>\n<p>you could write something along the lines of</p>\n<pre><code>#define DEFINE_F(N, Result)      \\\n  template &lt;&gt; struct f_impl&lt;N&gt; { \\\n    static Result impl();        \\\n  };                             \\\n  Result f_impl&lt;N&gt;::impl()\n\nDEFINE_F(1, const char *) {\n  return \" Hello, world!\";\n}\n</code></pre>\n<p>but I'm not convinced it's an improvement over just writing out <code>f_impl</code> (with a better name) in full.</p>\n", "LastActivityDate": "2014-12-23T22:58:37.283"}, "27629039": {"CommentCount": "3", "ViewCount": "249", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-23T22:35:25.567", "LastActivityDate": "2016-05-01T07:46:49.533", "Title": "C++ explicit return type template specialisation", "AcceptedAnswerId": "27629237", "LastEditDate": "2017-05-23T12:16:10.407", "Id": "27629039", "Score": "0", "Body": "<p>This is a follow up on this (more general) question: <a href=\"https://stackoverflow.com/questions/27627908/c-pipeline-segment-with-multiple-output-ports-type-matching\">previous question</a>. A partial answer to the present question is given here: <a href=\"https://stackoverflow.com/questions/15911890/overriding-return-type-in-function-template-specialization\">partial answer to the present question</a>.</p>\n<p>I am interested in explicit specialisation of the return type based on the template argument. While the answer presented above provides a solution to the problem, I believe that there is a more elegant way of solving the problem using C++11/14 techniques:</p>\n<pre><code>template&lt;int N&gt; auto getOutputPort2();\ntemplate&lt;&gt; auto getOutputPort2&lt;0&gt;();\ntemplate&lt;&gt; auto getOutputPort2&lt;1&gt;();\n\ntemplate&lt;&gt;\nauto getOutputPort2&lt;0&gt;()\n{\n    return std::unique_ptr&lt;int&gt;(new int(10));\n}\n\ntemplate&lt;&gt;\nauto getOutputPort2&lt;1&gt;()\n{\n    return std::unique_ptr&lt;string&gt;(new string(\"asdf\"));\n}\n</code></pre>\n<p>The code above compiles and works as expected using gcc 4.8.3 (with -std=c++0x flag). However, it issues the following warning: </p>\n<blockquote>\n<p id=\"so_27629039_27629039_0\"><code>getOutputPort2</code> function uses <code>auto</code> type specifier without trailing return type. </p>\n</blockquote>\n<p>From my understanding this will become part of the C++14 standard. However, is there a way of implementing the functionality above in C++11? Can <code>decltype</code> be used here?</p>\n<hr>\n<p>EDIT. Following the comments below, I would also like to ask an additional question. Is the code above valid from the perspective of the C++14 standard? If not, why not?</p>\n</hr>", "Tags": "<c++><templates><c++11><overloading><explicit-specialization>", "OwnerUserId": "1391279", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27629039_27629039_0": {"section_id": 5451, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_27629039_27629039_0": {"section_id": 6880, "quality": 0.5555555555555556, "length": 5}}}});