post_cb({"bq_ids": {"n4140": {"so_27792604_27792948_1": {"length": 7, "quality": 1.0, "section_id": 472}}, "n3337": {"so_27792604_27792948_1": {"length": 7, "quality": 1.0, "section_id": 463}}, "n4659": {"so_27792604_27792948_1": {"length": 7, "quality": 1.0, "section_id": 495}}}, "27792948": {"Id": "27792948", "PostTypeId": "2", "Body": "<p>A class with a reference member has no default-provided copy/move assignment operators. References cannot be rebound to reference a different variable once binding is established. In short, the copy constructor is making that initial establishment, while the default assignment operator would be trying to <em>change</em> it after-binding.</p>\n<p>The standard therefore calls this case out for both default copy and move assignment operators.</p>\n<blockquote>\n<p id=\"so_27792604_27792948_0\"><strong>C++11 \u00a7 12.8p23</strong></p>\n<p id=\"so_27792604_27792948_1\">A defaulted copy/move assignment operator for class X is defined as deleted if X has:</p>\n</blockquote>\n<ul>\n<li>a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or</li>\n<li>a non-static data member of const non-class type (or array thereof), or</li>\n<li><strong>a non-static data member of reference type</strong>, or</li>\n<li>a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or</li>\n<li>a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B\u2019s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or</li>\n<li>for the move assignment operator, a non-static data member or direct base class with a type that does not have a move assignment operator and is not trivially copyable, or any direct or indirect virtual base class.</li>\n</ul>\n<p>You can certainly write <em>your own</em> overload.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A(int&amp; var) : r(var) {}\n\n    int &amp;r;\n\n    A&amp; operator=(const A&amp; obj)\n    {\n        r = obj.r; // value copied, reference-binding remains the same\n        return *this;\n    }\n};\n\nint main(int argc, char** argv)\n{\n\n    int x = 42;\n    int y = 43;\n\n    A a1(x);\n    A a2(y);\n\n    A a3 = a1; // legal. default copy-ctor invoked\n    a3 = a2;   // legal. user-defined copy-assignment invoked\n\n    std::cout &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>43,43\n</code></pre>\n<p>But this will not (and cannot) rebind the reference. The overload provided here changes the <em>referenced</em> data; not the references themselves. Such a distinction is important.</p>\n<p>Hope this helps.</p>\n", "LastEditorUserId": "1322972", "LastActivityDate": "2015-01-06T06:16:39.087", "Score": "3", "CreationDate": "2015-01-06T06:02:05.767", "ParentId": "27792604", "CommentCount": "0", "LastEditDate": "2015-01-06T06:16:39.087", "OwnerUserId": "1322972"}, "27792898": {"Id": "27792898", "PostTypeId": "2", "Body": "<p>Line 16 uses a copy constructor, line 18 uses the assignment operator <code>operator=</code>. Two different functions with different restrictions.</p>\n<p>Because a reference can't be rebound, the compiler can't generate an implicit assignment operator that makes any sense. Thus it refuses to do so, and generates an error.</p>\n<p>A copy constructor is generating the object for the first time, so it can bind that reference the same way you did in your own constructor.</p>\n", "LastActivityDate": "2015-01-06T05:58:39.600", "Score": "6", "CreationDate": "2015-01-06T05:58:39.600", "ParentId": "27792604", "CommentCount": "0", "OwnerUserId": "5987"}, "27792636": {"Id": "27792636", "PostTypeId": "2", "Body": "<p>Because it is illegal in <code>C++</code> to reassign to a reference.</p>\n<pre><code>int &amp;a = some_int;\na = some_other_int; // value copied not reference\na = some_int; // value copied not reference\n</code></pre>\n<p>When you use assignation operator (generated by compiler), it blindly does the copy of objects and thus try to reassign to your reference and hence is invalid.</p>\n<p>When you say <code>a2 = a1;</code>, compiler would try to reassign <code>a1.r</code> to <code>a2.r</code> making it fail at compile time because it is ill-formation.</p>\n<p>You can think of a reference as an <code>automatically dereferenced constant pointer</code>. So the line <code>a2 = a1;</code> will remain ill-formatted for the same reason as for the class below.</p>\n<pre><code>struct A\n{\n  A(int *var) : p(var) {}\n  int * const p;\n};\n</code></pre>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2015-01-07T02:50:48.063", "Score": "1", "CreationDate": "2015-01-06T05:33:56.083", "ParentId": "27792604", "CommentCount": "7", "LastEditDate": "2015-01-07T02:50:48.063", "OwnerUserId": "2659313"}, "27792604": {"ViewCount": "260", "Body": "<p>I met a quiz saying that the code in line 18 below is ill-formed because \"It is ill-formed to use an implicitly defined assignment operator when one of the members that will need to be copied is a reference. \"</p>\n<p>I couldn't understand that. Why reference could not be copied? Why Line 16 is legal? Line 16 is quite similar to line 18, a copy constructor still need to do the copy, right?</p>\n<pre><code>1 #include &lt;iostream&gt;\n2\n3 struct A\n4 {\n5   A(int&amp; var) : r(var) {}\n6\n7   int &amp;r;\n8 };\n9\n10 int main(int argc, char** argv)\n11 {\n12   int x = 23;\n13\n14   A a1(x);\n15\n16   A a2 = a1;\n17\n18   a2 = a1;\n19\n20   return 0;\n21 }\n</code></pre>\n", "AcceptedAnswerId": "27792636", "Title": "Why It is illegal to copy an object if a member of the class is a reference?", "CreationDate": "2015-01-06T05:30:13.030", "Id": "27792604", "CommentCount": "3", "LastEditDate": "2015-01-06T05:43:13.377", "PostTypeId": "1", "LastEditorUserId": "1322972", "LastActivityDate": "2015-01-07T02:50:48.063", "Score": "5", "OwnerUserId": "826203", "Tags": "<c++><copy><copy-constructor>", "AnswerCount": "3"}});