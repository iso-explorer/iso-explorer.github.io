post_cb({"bq_ids": {"n4140": {"so_19347671_19347715_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 53}}, "n3337": {"so_19347671_19347715_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 48}}, "n4659": {"so_19347671_19347715_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 55}}}, "19347715": {"Id": "19347715", "PostTypeId": "2", "Body": "<p>You must move the static member definition to the header. Just like with everything else templated, a definition of a static member of a class template must be present in every translation unit where it's used. This basically means it belongs into the header.</p>\n<p>Quoting C++11, <code>[temp]\u00a76</code>:</p>\n<blockquote>\n<p id=\"so_19347671_19347715_0\">A function template, member function of a class template, or <strong>static data member of a class template</strong> shall be defined in every translation unit in which it is implicitly instantiated (14.7.1) unless the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is required.</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n", "LastActivityDate": "2013-10-13T16:51:13.897", "CommentCount": "0", "CreationDate": "2013-10-13T16:51:13.897", "ParentId": "19347671", "Score": "1", "OwnerUserId": "1782465"}, "19347671": {"ViewCount": "730", "Body": "<p>I have a template singleton class, with a static instance, and a static getInstance() method. However, I'm getting an undefined reference error on the instance from g++ (MinGW); at first, I thought it was linker-order error, but I get the same thing no matter which order I put them in.</p>\n<p>However, I found that if I explicitly specialize the instance, it does compile (which isn't an acceptable solution). So, here's the code:</p>\n<p>Singleton.hpp:</p>\n<pre><code>#ifndef SINGLETON_HPP\n#define SINGLETON_HPP\n\n#include &lt;iostream&gt;\n\ntemplate&lt;int X=100&gt;\nclass Singleton {\nprotected:\n    static Singleton&lt;X&gt; *instance;\npublic:\n\n    static Singleton&lt;X&gt;&amp; getInstance() {\n        if(!Singleton&lt;X&gt;::instance) {\n            Singleton&lt;X&gt;::instance = new Singleton&lt;X&gt;();\n        }\n        return *Singleton&lt;X&gt;::instance;\n    }\n\n    void foo() {\n        std::cout &lt;&lt; \"Test&lt;\" &lt;&lt; X &lt;&lt; \")::foo()\" &lt;&lt; std::endl;\n    }\n};\n\n#endif\n</code></pre>\n<p>Singleton.cpp:</p>\n<pre><code>#include \"Singleton.hpp\"\n\ntemplate&lt;int X&gt;\nSingleton&lt;X&gt;* Singleton&lt;X&gt;::instance = NULL;\n\n#ifdef SPECIALIZE\ntemplate&lt;&gt;\nSingleton&lt;100&gt;* Singleton&lt;100&gt;::instance = NULL;\n#endif\n</code></pre>\n<p>Main.cpp:</p>\n<pre><code>#include \"Singleton.hpp\"\n\nint main(int ac, char *av[]) {\n    Singleton&lt;100&gt; &amp;sing = Singleton&lt;100&gt;::getInstance();\n    sing.foo();\n}\n</code></pre>\n<p>Then here's the three different ways of compiling, and the output:</p>\n<p>No specialization, SingletonMain.o linked first:</p>\n<pre><code>C:\\Test&gt;g++ -c Singleton.cpp\n\nC:\\Test&gt;g++ -c SingletonMain.cpp\n\nC:\\Test&gt;g++ -o Singleton.exe SingletonMain.o Singleton.o\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x7): undefined reference to `Singleton&lt;100&gt;::instance'\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x1c): undefined reference to `Singleton&lt;100&gt;::instance'\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x21): undefined reference to `Singleton&lt;100&gt;::instance'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>No specialization, Singleton.o linked first:</p>\n<pre><code>C:\\Test&gt;g++ -c Singleton.cpp\n\nC:\\Test&gt;g++ -c SingletonMain.cpp\n\nC:\\Test&gt;g++ -o Singleton.exe Singleton.o SingletonMain.o\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x7): undefined reference to `Singleton&lt;100&gt;::instance'\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x1c): undefined reference to `Singleton&lt;100&gt;::instance'\nSingletonMain.o:SingletonMain.cpp:(.text$_ZN9SingletonILi100EE11getInstanceEv[Singleton&lt;100&gt;::getInstance()]+0x21): undefined reference to `Singleton&lt;100&gt;::instance'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>With specialization:</p>\n<pre><code>C:\\Test&gt;g++ -DSPECIALIZE -c Singleton.cpp\n\nC:\\Test&gt;g++ -DSPECIALIZE -c SingletonMain.cpp\n\nC:\\Test&gt;g++ -DSPECIALIZE -o Singleton.exe Singleton.o SingletonMain.o\n</code></pre>\n<p>Now, there does seem to be someone having a similar problem here -- <a href=\"https://stackoverflow.com/questions/3704970/c-template-static-member-instantiation\">C++ template static member instantiation</a> -- but the \"solution\" was to have an explicit specialization for each type you might use...which seems to totally defeat the purpose of templates...so there has to be a better way, right?</p>\n", "Title": "Static member of template class not instantiated unless explicitly specialized?", "CreationDate": "2013-10-13T16:47:07.817", "LastActivityDate": "2013-10-13T16:51:13.897", "CommentCount": "0", "LastEditDate": "2017-05-23T11:57:20.880", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "19347671", "Score": "2", "OwnerUserId": "2863442", "Tags": "<c++><templates><singleton><linker-errors><static-members>", "AnswerCount": "1"}});