post_cb({"bq_ids": {"n4140": {"so_16873215_16873237_4": {"length": 15, "quality": 1.0, "section_id": 438}, "so_16873215_16873237_1": {"length": 6, "quality": 1.0, "section_id": 438}, "so_16873215_16873237_2": {"length": 29, "quality": 1.0, "section_id": 438}, "so_16873215_16873237_3": {"length": 13, "quality": 1.0, "section_id": 438}, "so_16873215_16873237_5": {"length": 5, "quality": 1.0, "section_id": 438}}, "n3337": {"so_16873215_16873237_3": {"length": 13, "quality": 1.0, "section_id": 429}, "so_16873215_16873237_4": {"length": 15, "quality": 1.0, "section_id": 429}, "so_16873215_16873237_1": {"length": 6, "quality": 1.0, "section_id": 429}, "so_16873215_16873237_2": {"length": 29, "quality": 1.0, "section_id": 429}, "so_16873215_16873237_5": {"length": 5, "quality": 1.0, "section_id": 429}}, "n4659": {"so_16873215_16873237_4": {"length": 15, "quality": 1.0, "section_id": 458}, "so_16873215_16873237_1": {"length": 6, "quality": 1.0, "section_id": 458}, "so_16873215_16873237_2": {"length": 29, "quality": 1.0, "section_id": 458}, "so_16873215_16873237_3": {"length": 13, "quality": 1.0, "section_id": 458}, "so_16873215_16873237_5": {"length": 5, "quality": 1.0, "section_id": 458}}}, "16873237": {"Id": "16873237", "PostTypeId": "2", "Body": "<p>I will start with the second question:</p>\n<blockquote>\n<p id=\"so_16873215_16873237_0\">2) is the order in derived constructor not followed strictly ?</p>\n</blockquote>\n<p>The order is not the one that appears in your constructor's initialization list, but rather the one in which the base classes appear in your class definition.</p>\n<p>So if your class definition looks like this:</p>\n<pre><code>struct A : B, C\n{\n    // ...\n};\n</code></pre>\n<p>Then the constructor of <code>B</code> will be called before the constructor of <code>C</code>, no matter what order you specify in the initialization list of <code>A</code>'s constructor.</p>\n<p>Paragraph 12.6.2/10 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_16873215_16873237_1\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<p id=\"so_16873215_16873237_2\">\u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</p>\n<p id=\"so_16873215_16873237_3\">\u2014 Then, <strong>direct base classes are initialized in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers)</strong>.</p>\n<p id=\"so_16873215_16873237_4\">\u2014 Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).</p>\n<p id=\"so_16873215_16873237_5\">\u2014 Finally, the compound-statement of the constructor body is executed.</p>\n</blockquote>\n<p>Now the first question:</p>\n<blockquote>\n<p id=\"so_16873215_16873237_6\">1) why does compiler not complain ?</p>\n</blockquote>\n<p>The compiler <em>may</em> warn you that the initialization order in the constructor initializer list is different from the one in the base class list (GCC does with <code>-Wall</code>), but does not have to. Eventually, only the latter matters.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-01T13:34:53.533", "Score": "4", "CreationDate": "2013-06-01T13:29:28.680", "ParentId": "16873215", "CommentCount": "1", "OwnerUserId": "1932150", "LastEditDate": "2013-06-01T13:34:53.533"}, "16873215": {"ViewCount": "2721", "Body": "<p>I have a class A and Class B . Class C derives from Class B and has Class A object as composition . <a href=\"http://ideone.com/JGT48M\" rel=\"nofollow\">http://ideone.com/JGT48M</a> </p>\n<pre><code>#include \"iostream\"\nusing namespace std;\n\nclass A {\n  int i;\npublic:\n  A(int ii) : i(ii) {\n      cout &lt;&lt; \"\\n Constructor of A is called \\n\";\n\n  }\n  ~A() {\n      cout &lt;&lt; \"\\n destructor  of A is called \\n\";\n  }\n  void f() const {}\n};\n\nclass B {\n  int i;\npublic:\n  B(int ii) : i(ii) {\n      cout &lt;&lt; \"\\n Constructor of B is called \\n\";\n  }\n  ~B() {\n      cout &lt;&lt; \"\\n destructor  of B is called \\n\";\n  }\n  void f() const {}\n};\n\nclass C : public B {\n  A a;\npublic:\n  C(int ii) : a(ii), B(ii) {\n      cout &lt;&lt; \"\\n Constructor of C is called \\n\";\n  }\n  ~C() {\n  cout &lt;&lt; \"\\n destructor  of C is called \\n\";\n  } // Calls ~A() and ~B()\n  void f() const {  // Redefinition\n    a.f();\n    B::f();\n  }\n};\n\nint main() {\n  C c(47);\n} ///:~\n</code></pre>\n<p>I have read that constructors are called based on how they are called in my derived class constructor . What i mean is that let there be a class called REF derived from REF_BASE1 and REF_BASE2 then </p>\n<pre><code> REF (int ii) : REF_BASE2(ii), REF_BASE1 (ii) {\n</code></pre>\n<p>would mean that REF_BASE2 would be called first then REF_BASE1 and then REF constructor is called . \nand if we defined it like </p>\n<pre><code>REF (int ii) : REF_BASE1(ii), REF_BASE2 (ii) {\n</code></pre>\n<p>would mean that REF_BASE1 would be called first then REF_BASE2 and then REF constructor is called .</p>\n<p>However in my program above i have explicitly \"wrongly\" stated that by internal composition variable A a be initialized first and then B should get initialized , yet the compiler does it the right way but fails to let me know of my mistake </p>\n<p>output of above program irrespective of order i specify in derived class constcutor initialization list is </p>\n<pre><code>Constructor of B is called \n\n Constructor of A is called \n\n Constructor of C is called \n\n destructor  of C is called \n\n destructor  of A is called \n\n destructor  of B is called \n</code></pre>\n<p>My question is \n1) why does compiler not complain ? or am i correct ?\n2) is the order in derived constructor not followed strictly ? </p>\n", "AcceptedAnswerId": "16873237", "Title": "constructor calling order with composition", "CreationDate": "2013-06-01T13:26:12.243", "Id": "16873215", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-06-01T13:34:53.533", "Score": "2", "OwnerUserId": "1636300", "Tags": "<c++><inheritance><constructor><composition>", "AnswerCount": "1"}});