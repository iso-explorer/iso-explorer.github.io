post_cb({"bq_ids": {"n4140": {"so_20714286_20714611_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6049}}, "n3337": {"so_20714286_20714611_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5817}}, "n4659": {"so_20714286_20714611_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7548}}}, "20714611": {"Id": "20714611", "PostTypeId": "2", "Body": "<p>You could capture the objects as a <code>void*</code>, store the member function in random member function type, and have a function restore the necessary types. This approach avoid allocating any memory on the heap. The problematic step is the conversion from a member function of some type to another member function. However, according to 5.2.10 [expr.reinterpret.cast] paragraph 10 this approach can be used safely as long at the member function is cast back to its original type before being used:</p>\n<blockquote>\n<p id=\"so_20714286_20714611_0\">[...] The result of this conversion is unspecified, except in the following cases:</p>\n<ul>\n<li>converting a prvalue of type \u201cpointer to member function\u201d to a different pointer to member function type and back to its original type yields the original pointer to member value.</li>\n</ul>\n</blockquote>\n<p>Below is an example which implements this approach. Note, however, that it is probably easier to use <code>std::function&lt;R(Args...)&gt;</code> with a suitable lambda as the standard library is likely to implementation an approach like that in the first place.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;class T&gt;\nstruct FastDelegate {};\n\ntemplate&lt;class R, class... Args&gt;\nstruct FastDelegate&lt;R (Args...)&gt; \n{\n    struct dummy {};\n    template &lt;typename T&gt;\n    FastDelegate(T* t, R (T::*f)(Args...))\n        : m_t(t)\n        , m_f(reinterpret_cast&lt;void (dummy::*)()&gt;(f))\n        , m_call([](void(dummy::*d)(), void* v, Args... a){\n                typedef R (T::*mem)(Args...);\n                T* t = static_cast&lt;T*&gt;(v);\n                mem f = reinterpret_cast&lt;mem&gt;(d);\n                return (t-&gt;*f)(std::forward&lt;Args&gt;(a)...);\n            }) {\n    }\n\n    R operator()(Args... p) {\n        return (this-&gt;m_call)(this-&gt;m_f, this-&gt;m_t, std::forward&lt;Args&gt;(p)...);\n    }\n\n    void* m_t;\n    void  (dummy::*m_f)();\n    R     (*m_call)(void (dummy::*)(), void*, Args...);\n};\n\nstruct Tester\n{\n int add ( int x, int y ) {\n     std::cout &lt;&lt; \"add(\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\\n\";\n     return x+y;\n }\n};\n\nint main ()\n{\n int x = 5;\n int y = 4;\n\n Tester t;\n FastDelegate&lt;int (int,int)&gt; d (&amp;t, &amp;Tester::add);\n int z = d(x,y);\n}\n</code></pre>\n", "LastActivityDate": "2013-12-21T01:57:15.770", "CommentCount": "4", "CreationDate": "2013-12-21T01:57:15.770", "ParentId": "20714286", "Score": "4", "OwnerUserId": "1120273"}, "20714286": {"ViewCount": "505", "Body": "<p>Hi I am trying to write a delegate class that can take a template argument similar to a standard function signature and create a delegate for a member function pointer as shown below in the main. The code may be oversimplified but that is what I was looking for was a simple and fast solution to this problem with as little overhead as possible. I think this implementation is pretty close to achieving what I want if I can get the type T in the class without runtime polymorphism etc.</p>\n<pre><code>template&lt;class T&gt;\nstruct FastDelegate {};\n\ntemplate&lt;class R, class... Args&gt;\nstruct FastDelegate&lt;R (Args...)&gt; \n{\n    template &lt;typename T&gt;\n    FastDelegate(T* t, R (T::*f)(Args...)) : m_t(t), m_f(f) {} \n\n    R operator()(Args... p)\n    {\n        return (m_t-&gt;*m_f)(std::forward&lt;Args&gt;(p)...);\n    }\n\n    T* m_t;  // How can I capture T as a type in this partial specialization?\n    R  (T::*m_f)(Args...);\n};\n\nstruct Test\n{\n int add ( int x, int y ) { return x+y; }\n};\n\nint main ()\n{\n int x = 5;\n int y = 4;\n\n Tester t;\n FastDelegate&lt;int (int,int)&gt; d (&amp;t, &amp;Test::calc );\n int z = d(x,y);\n}\n</code></pre>\n", "AcceptedAnswerId": "20714611", "Title": "std::function like delegate template class", "CreationDate": "2013-12-21T01:02:11.873", "Id": "20714286", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-12-21T07:58:02.510", "LastEditorUserId": "708803", "LastActivityDate": "2013-12-21T07:58:02.510", "Score": "3", "OwnerUserId": "708803", "Tags": "<c++><templates><c++11><delegates><variadic-templates>", "AnswerCount": "2"}, "20714555": {"Id": "20714555", "PostTypeId": "2", "Body": "<p>You don't need to capture type T, because you can use <code>t-&gt;*m_f</code> as a <code>function&lt;R(Args...)&gt;</code></p>\n<pre><code>template&lt;class R, class... Args&gt;\nstruct FastDelegate&lt;R (Args...)&gt; \n{\n    template &lt;typename T&gt;\n    FastDelegate(T* t, R (T::*f)(Args...)) \n        : m_f([=](Args... v){ return (t-&gt;*f)(std::forward(v)...); }) {} \n\n    R operator()(Args... p)\n    {\n        return m_f(std::forward&lt;Args&gt;(p)...);\n    }\n\n    std::function&lt;R(Args...)&gt; m_f;\n};\n</code></pre>\n<p>If you want to compare 2 FastDelegate instance by comparing <code>t</code> and <code>f</code>, there is still no need for type info, just take raw pointer.</p>\n", "LastEditorUserId": "2190129", "LastActivityDate": "2013-12-21T01:53:03.787", "Score": "3", "CreationDate": "2013-12-21T01:47:39.450", "ParentId": "20714286", "CommentCount": "1", "OwnerUserId": "2190129", "LastEditDate": "2013-12-21T01:53:03.787"}});