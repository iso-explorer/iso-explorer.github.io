post_cb({"41347826": {"CommentCount": "4", "ViewCount": "51", "PostTypeId": "1", "LastEditorUserId": "817643", "CreationDate": "2016-12-27T15:25:29.537", "LastActivityDate": "2016-12-27T15:53:55.083", "Title": "Pointer to member function of derived class, but not derived(virtual) function", "LastEditDate": "2016-12-27T15:53:55.083", "Id": "41347826", "Score": "1", "Body": "<p>I have a particular problem I want to solve, I'm not sure if it's possible as I can't find any information or examples of it being done.\nBasically, I have:</p>\n<pre><code>class ParentObject {};\n\nclass DerivedObject : public ParentObject\n{\n    void myFunction(){}\n};\n\nclass OtherDerivedObject\n{\n   void myOtherFunction(){}\n};\n</code></pre>\n<p>and want a function pointer to ParentObject::* and have it able to take functions from either derived class. \nMy reason for wanting to do so, I have another class</p>\n<pre><code>class functionRegistry\n{\n  std::map&lt;string, *functionPoint&gt; functionMap;\n}\n</code></pre>\n<p>and each object (ideally in ParentObject but can do individually in the derived objects if necessary) have an instance of a functionRegistry, and I need functionPoint to be able to point to functions in objects of either type DerivedObject or OtherDerivedObject.</p>\n<p>Thanks in advance</p>\n", "Tags": "<c++><inheritance><function-pointers><member-function-pointers>", "OwnerUserId": "5719531", "AnswerCount": "1"}, "41347931": {"ParentId": "41347826", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2016-12-27T15:32:51.043", "Score": "2", "LastEditorUserId": "817643", "LastEditDate": "2016-12-27T15:51:34.153", "Id": "41347931", "OwnerUserId": "817643", "Body": "<p>All you need is a <code>static_cast</code> to populate the map with the correct type.</p>\n<pre><code>using pfunc_type = void (ParentObject::*)() ;\npfunc_type pfunc1 = static_cast&lt;pfunc_type&gt;(&amp;DerivedObject::myFunction);\n</code></pre>\n<p>As this is allowed by the standard:</p>\n<p><strong>[expr.static.cast/12] - <a href=\"http://eel.is/c++draft/expr.static.cast#12\" rel=\"nofollow noreferrer\">\u00a75.2.9\u00b612</a></strong></p>\n<blockquote>\n<p id=\"so_41347826_41347931_0\">A prvalue of type \u201cpointer to member of D of type cv1 T\u201d can be\n  converted to a prvalue of type \u201cpointer to member of B of type cv2 T\u201d,\n  where B is a base class (Clause [class.derived]) of D, if cv2 is the\n  same cv-qualification as, or greater cv-qualification than, cv1.72 If\n  no valid standard conversion from \u201cpointer to member of B of type T\u201d\n  to \u201cpointer to member of D of type T\u201d exists ([conv.mem]), the program\n  is ill-formed. The null member pointer value ([conv.mem]) is converted\n  to the null member pointer value of the destination type. If class B\n  contains the original member, or is a base or derived class of the\n  class containing the original member, the resulting pointer to member\n  points to the original member. Otherwise, the behavior is undefined. [\n  <strong>Note: although class B need not contain the original member, the\n  dynamic type of the object with which indirection through the pointer\n  to member is performed must contain the original member;</strong> see\n  [expr.mptr.oper].  \u2014 end note ]</p>\n</blockquote>\n<p>But while this is allowed, you must be <em>very</em> careful to make sure you apply the pointer to member on an object with the correct dynamic type.</p>\n", "LastActivityDate": "2016-12-27T15:51:34.153"}, "bq_ids": {"n4140": {"so_41347826_41347931_0": {"section_id": 6038, "quality": 0.8064516129032258, "length": 75}}, "n3337": {"so_41347826_41347931_0": {"section_id": 5806, "quality": 0.7634408602150538, "length": 71}}, "n4659": {"so_41347826_41347931_0": {"section_id": 7537, "quality": 0.8602150537634409, "length": 80}}}});