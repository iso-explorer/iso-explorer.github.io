post_cb({"bq_ids": {"n4140": {"so_39150553_39150553_2": {"length": 11, "quality": 1.0, "section_id": 303}, "so_39150553_39150553_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 313}, "so_39150553_39150553_1": {"length": 12, "quality": 1.0, "section_id": 314}, "so_39150553_39276652_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 571}}, "n3337": {"so_39150553_39150553_2": {"length": 11, "quality": 1.0, "section_id": 294}, "so_39150553_39150553_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 303}, "so_39150553_39150553_1": {"length": 12, "quality": 1.0, "section_id": 304}, "so_39150553_39276652_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 562}}, "n4659": {"so_39150553_39150553_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 310}, "so_39150553_39150553_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 321}, "so_39150553_39150553_1": {"length": 12, "quality": 1.0, "section_id": 322}, "so_39150553_39276652_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 594}}}, "39277578": {"Id": "39277578", "PostTypeId": "2", "Body": "<p>The key point you're missing is that overload resolution still has to happen. Template deduction isn't the end of the story. Addressing both of your examples separately:</p>\n<hr/>\n<blockquote>\n<p id=\"so_39150553_39277578_0\">To me, this seems to imply that <code>template &lt;class T&gt; operator T()</code> and <code>template &lt;class T&gt; operator T&amp;()</code> are the same (and specifying both would result in an ambiguity). But that isn't the case in any compiler I've used! </p>\n</blockquote>\n<p>The text you cite indicates that <em>deduction of <code>T</code></em> is the same for both conversion operators, this is true. But the operators themselves are not the same. You have to additionally consider the rules for binding to references, which are enumerated in [dcl.init.ref]. The section is too long to concisely copy, but the reason that this is an error</p>\n<pre><code>f2(any1()); // error\n</code></pre>\n<p>is the same reason that <code>f2(1)</code> is an error: you can't bind an lvalue reference to non-<code>const</code> to an rvalue. As a result, even having both operators isn't in of itself ambiguous:</p>\n<pre><code>struct X {\n    template &lt;class T&gt; operator T();   // #1\n    template &lt;class T&gt; operator T&amp;();  // #2\n};\n\nf1(X{}); // error: ambiguous\nf2(X{}); // ok! #1 is not viable, calls #2\nf3(X{}); // ok! #2 is preferred (per [dcl.init.ref]/5.1.2)\n</code></pre>\n<hr/>\n<blockquote>\n<p id=\"so_39150553_39277578_1\">And yet this works fine with both gcc and clang.</p>\n<pre><code>struct any3 {\n  template &lt;typename T&gt; operator T&amp;();      // #3\n  template &lt;typename T&gt; operator T const&amp;() // #4\n};\n\nvoid f1(int) { }\n\nint main() {\n  f1(any3());\n}\n</code></pre>\n</blockquote>\n<p>This is an interesting scenario as far as compilers go, because gcc has a bug here. Both candidates should be valid (gcc doesn't consider #4 valid due to <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61663\" rel=\"nofollow\">61663</a>). None of the tiebreakers apply on determining best viable candidate, so in this case we have to fall back to [temp.deduct.partial] to determine which candidate is more specializated... which, in this case, is #4. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-09-01T18:27:18.267", "Score": "3", "CreationDate": "2016-09-01T17:27:19.687", "ParentId": "39150553", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-09-01T18:27:18.267"}, "39150553": {"ViewCount": "196", "Body": "<p>I'm having trouble understanding the implications of the conversion function template argument deduction rules in the C++ standard.  The standard states that ([temp.deduct.conv] clause 1, \u00a714.8.2.3.1 in N4594):</p>\n<blockquote>\n<p id=\"so_39150553_39150553_0\">Template argument deduction is done by comparing the return type of the conversion function template (call it P) with the type that is required as the result of the conversion (call it A; see 8.5, 13.3.1.5, and 13.3.1.6 for the determination of that type) as described in 14.8.2.5.</p>\n</blockquote>\n<p>where 14.8.2.5 ([temp.deduct.type]) is the section that describes general template argument deduction (though the most common case, function call template argument deduction [temp.deduct.call], no longer seems to point there; did it ever?).  The next clause is what confuses me, though (clause 2):</p>\n<blockquote>\n<p id=\"so_39150553_39150553_1\">If P is a reference type, the type referred to by P is used in place of P for type deduction and for any further references to or transformations of P in the remainder of this section.</p>\n</blockquote>\n<p>To me, this seems to imply that <code>template &lt;class T&gt; operator T()</code> and <code>template &lt;class T&gt; operator T&amp;()</code> are the same (and specifying both would result in an ambiguity).  But that isn't the case in any compiler I've used!  For instance:</p>\n<pre><code>struct any1 { template &lt;typename T&gt; operator T() { } };\n\nstruct any2 { template &lt;typename T&gt; operator T&amp;() { } };\n\nvoid f1(int) { }\nvoid f2(int&amp;) { }\nvoid f3(int const&amp;) { }\n\nint main() {\n  f1(any1());\n  // f2(any1()); compile time error\n  f3(any1());\n\n  f1(any2());\n  f2(any2());\n  f3(any2());\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/42871804770ace98\" rel=\"nofollow\">Live Demo</a></p>\n<p>But if references are ignored, <code>any1</code> and <code>any2</code> should have the same behavior, right?  Clearly they don't, since <code>f2(any1())</code> doesn't compile with either gcc or clang, while <code>f2(any2())</code> compiles fine with both.</p>\n<p>The next clause (clause 3, particularly 3.3) confuses things even further:</p>\n<blockquote>\n<p id=\"so_39150553_39150553_2\">If A is not a reference type: [...] If P is a cv-qualified type, the top level cv-qualifiers of P\u2019s type are ignored for type deduction.</p>\n</blockquote>\n<p>This, along with clause 2 about the removal of references, would seem to imply that the following code should not compile because of an ambiguity:</p>\n<pre><code>struct any3 {\n  template &lt;typename T&gt; operator T&amp;() { }\n  template &lt;typename T&gt; operator T const&amp;() { }\n};\n\nvoid f1(int) { }\n\nint main() {\n  f1(any3());\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1bb988e92a68c9c3\" rel=\"nofollow\">Live Demo</a></p>\n<p>And yet this works fine with both gcc and clang.</p>\n<p>What am I missing?</p>\n<h1>Edit</h1>\n<p>I should clarify that the way the clang and gcc compilers handle this is exactly what I would expect from a general (relatively advanced) understanding of C++.  Some commenters have asked for clarification on what my confusion is (and, implicitly, why I should care).  My confusion here is entirely related to trying to understand the implications of the standard.  I need a clear understanding of this because I am submitting a paper with code that relies heavily on this working and on my use of it being standards-compliant.</p>\n", "AcceptedAnswerId": "39277578", "Title": "Implications of conversion function template argument deduction in C++", "CreationDate": "2016-08-25T16:37:06.943", "Id": "39150553", "CommentCount": "5", "LastEditDate": "2016-09-01T15:38:54.817", "PostTypeId": "1", "LastEditorUserId": "152060", "LastActivityDate": "2016-09-01T18:27:18.267", "Score": "3", "OwnerUserId": "152060", "Tags": "<c++><templates><standards><type-deduction>", "AnswerCount": "3"}, "39276887": {"Id": "39276887", "PostTypeId": "2", "Body": "<p>Type deduction is a separate step from overload resolution and semantic checking.</p>\n<pre><code>struct any1 { template &lt;typename T&gt; operator T() { } };\n\nstruct any2 { template &lt;typename T&gt; operator T&amp;() { } };\n\nvoid f1(int) { }\nvoid f2(int&amp;) { }\nvoid f3(int const&amp;) { }\n\nint main() {\n  f1(any1());\n  // f2(any1()); compile time error\n  f3(any1());\n\n  f1(any2());\n  f2(any2());\n  f3(any2());\n}\n</code></pre>\n<p>Here <code>f2(any1())</code> and <code>f2(any2())</code> do behave identically for type deduction.  Both deduce <code>T=int</code>.  But then that <code>T</code> is substituted into the <em>original</em> declaration to get member specializations <code>any1::operator int()</code> and <code>any2::operator int&amp;()</code>.  <code>f2(any1().operator int())</code> is a semantic error because it attempts to bind a non-const lvalue reference function parameter to an rvalue expression.  This makes <code>operator int()</code> a non-viable function; if <code>any1</code> had other conversion functions, they could be selected by overload resolution.</p>\n<pre><code>struct any3 {\n  template &lt;typename T&gt; operator T&amp;() { }\n  template &lt;typename T&gt; operator T const&amp;() { }\n};\n\nvoid f1(int) { }\n\nint main() {\n  f1(any3());\n}\n</code></pre>\n<p>Here again, the two template conversion functions do behave identically for type deduction.  Both deduce <code>T=int</code>.  Then that deduction is substituted into the original declarations to get <code>operator int&amp;()</code> and <code>operator int const&amp;()</code>.  Then overload resolution compares those two.  By my reading of Clause 13, they are ambiguous, but <a href=\"http://coliru.stacked-crooked.com/a/e68a74ad86750a3a\" rel=\"nofollow\">gcc chooses <code>operator int&amp;()</code> and clang chooses <code>operator int const&amp;()</code></a>...</p>\n", "LastActivityDate": "2016-09-01T16:46:51.833", "CommentCount": "0", "CreationDate": "2016-09-01T16:46:51.833", "ParentId": "39150553", "Score": "2", "OwnerUserId": "459640"}, "39276652": {"Id": "39276652", "PostTypeId": "2", "Body": "<p>Template argument deduction for a function template is just one step in the complex process of overload resolution.</p>\n<blockquote>\n<p id=\"so_39150553_39276652_0\"><strong>\u00a713.3.1 Candidate functions and argument lists</strong></p>\n<p id=\"so_39150553_39276652_1\">...</p>\n<p id=\"so_39150553_39276652_2\">7 In each case where a candidate is a function template, candidate function\n  template specializations are generated using template argument deduction\n  (14.8.3, 14.8.2).</p>\n</blockquote>\n<p>Template argument deduction is performed for a given function template <em>as if no other function template exists</em>. Reread the section \u00a714.8.2.3 with that in mind, and you will realize that your questions belong to a different part of the standard.</p>\n<p>After template argument deduction is performed for all candidate template functions, the best viable function must be selected according to the rules of \u00a713.3.3. If by this time two or more function template specializations are present in the candidate function list, then the best viable function selection process involves partial ordering rules described in \u00a714.5.6.2 (I think it's this section that contains answers to you questions).</p>\n", "LastEditorUserId": "6394138", "LastActivityDate": "2016-09-01T16:37:24.343", "Score": "2", "CreationDate": "2016-09-01T16:32:12.223", "ParentId": "39150553", "CommentCount": "0", "OwnerUserId": "6394138", "LastEditDate": "2016-09-01T16:37:24.343"}});