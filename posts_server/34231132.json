post_cb({"34231132": {"CommentCount": "0", "ViewCount": "87", "PostTypeId": "1", "ClosedDate": "2015-12-11T19:32:47.783", "LastEditorUserId": "1708801", "CreationDate": "2015-12-11T19:29:34.997", "LastActivityDate": "2015-12-14T12:34:22.467", "Title": "Can't initialize a struct using an initializer list if it inherits?", "LastEditDate": "2015-12-11T20:02:04.213", "Id": "34231132", "Score": "3", "Body": "<p>I'm puzzled by this fragment of (C++14) code I wrote:</p>\n<pre><code>struct B {};\nstruct C     { int m; };\nstruct D : B { int m; };\n\nint main() {\n    C c = { 1 }; // this works\n    D d = { 1 }; // this doesn't work\n}\n</code></pre>\n<p>I'm fine writing a constructor for <code>D</code> myself, but I can't find a good explanation for <em>why</em> the struct <code>D</code> is no longer initializable with an initializer list. All I changed was make it inherit from a completely empty class -- I suppose I somehow made it behave less struct-like.</p>\n<p>How exactly does my compiler handle the structs <code>C</code> and <code>D</code> differently?</p>\n", "Tags": "<c++><inheritance><struct><aggregate-initialization>", "OwnerUserId": "257418", "AnswerCount": "3"}, "34231167": {"ParentId": "34231132", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It works for <code>C</code> because it is an <a href=\"https://stackoverflow.com/q/4178175/1708801\">aggregate</a> and therefore it is using <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">aggregate initialization</a> but <code>D</code> is not an aggregate because it has a base class. The obvious work-around as you mention is to write a constructor.</p>\n<p>This is covered in the draft C++ standard section <code>8.5.1</code> Aggregates <em>[dcl.init.aggr]</em> with emphasis mine:</p>\n<blockquote>\n<p id=\"so_34231132_34231167_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or\n  protected non-static data members (Clause 11), <strong>no base classes (Clause 10)</strong>, and no virtual functions (10.3).</p>\n</blockquote>\n<p>There is a proposal: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r1.html\" rel=\"nofollow noreferrer\">Extension to aggregate initialization</a> to remove that restriction. As chris points out this was accepted by Evolution Working Group but as far as I understand now needs to accepted by Core as well.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:21.027", "Id": "34231167", "Score": "4", "CreationDate": "2015-12-11T19:31:35.400", "LastActivityDate": "2015-12-14T12:34:22.467"}, "bq_ids": {"n4140": {"so_34231132_34231167_0": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_34231132_34231167_0": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_34231132_34231167_0": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}}}, "34231190": {"ParentId": "34231132", "CommentCount": "1", "Body": "<p>struct c is a POD while struct D is an object.  Class initializer rules apply because of the inheritance. </p>\n", "OwnerUserId": "1304785", "PostTypeId": "2", "Id": "34231190", "Score": "-1", "CreationDate": "2015-12-11T19:33:22.263", "LastActivityDate": "2015-12-11T19:33:22.263"}, "34231173": {"ParentId": "34231132", "CommentCount": "0", "Body": "<p><code>D</code> is no longer an aggregate type so it cannot be directly initialized with an initialization list.  If you provide a constructor then it will work.</p>\n<pre><code>struct B {};\nstruct C     { int m; };\nstruct D : B { int m; D(int m_) : m(m_) {} };\n\nint main() \n{\n    C c = { 1 }; // this works\n    D d = { 1 }; // this works\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/0b4964b798e1e4e7\" rel=\"nofollow\">Live Example</a></kbd></p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "34231173", "Score": "3", "CreationDate": "2015-12-11T19:31:52.680", "LastActivityDate": "2015-12-11T19:31:52.680"}});