post_cb({"4715759": {"ParentId": "4715740", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>A reference is always initialized from an existing object, thus it can never be NULL, whereas a pointer variable is allowed to be NULL.</p>\n<p><strong>EDIT:</strong> Thanks for all of the replies.  Yes, a reference can indeed point to garbage, I forgot about dangling references.</p>\n", "OwnerUserId": "194709", "LastEditorUserId": "194709", "LastEditDate": "2011-01-17T17:51:51.377", "Id": "4715759", "Score": "2", "CreationDate": "2011-01-17T17:02:20.283", "LastActivityDate": "2011-01-17T17:51:51.377"}, "4715888": {"ParentId": "4715740", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It's considered safer because a lot of people have \"heard\" that it's safer and then told others, who now have also \"heard\" that it's safer.</p>\n<p>Not a single person who understands references will tell you that they're any safer than pointers, they have the same flaws and potential to become invalid.</p>\n<p>e.g.</p>\n<pre><code>#include &lt;vector&gt;\n\nint main(void)\n{\n    std::vector&lt;int&gt; v;\n    v.resize(1);\n\n    int&amp; r = v[0];\n    r = 5; // ok, reference is valid\n\n    v.resize(1000);\n    r = 6; // BOOM!;\n\n    return 0;\n}\n</code></pre>\n<p>EDIT: Since there seems to be some confusion about whether a reference is an alias for an object or bound to a memory location, here's the paragraph from the standard (draft 3225, section <code>[basic.life]</code>) which clearly states that a reference binds to storage and can outlive the object which existed when the reference was created:</p>\n<blockquote>\n<p id=\"so_4715740_4715888_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or\n  released, a new object is created at the storage location which the original object occupied, a pointer that\n  pointed to the original object, a reference that referred to the original object, or the name of the original\n  object will automatically refer to the new object and, once the lifetime of the new object has started, can\n  be used to manipulate the new object, if:</p>\n<ul>\n<li>the storage for the new object exactly overlays the storage location which the original object occupied,\n  and</li>\n<li>the new object is of the same type as the original object (ignoring the top-level cv-quali\ufb01ers), and</li>\n<li>the type of the original object is not const-quali\ufb01ed, and, if a class type, does not contain any non-static\n  data member whose type is const-quali\ufb01ed or a reference type, and</li>\n<li>the original object was a most derived object of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-01-18T03:59:31.037", "Id": "4715888", "Score": "16", "CreationDate": "2011-01-17T17:16:22.113", "LastActivityDate": "2011-01-18T03:59:31.037"}, "4715756": {"ParentId": "4715740", "CommentCount": "55", "Body": "<p>Because references (which are simply an alias for other variable) can't be <code>NULL</code> by definition, providing an inherent layer of safety.</p>\n", "OwnerUserId": "541686", "PostTypeId": "2", "Id": "4715756", "Score": "6", "CreationDate": "2011-01-17T17:02:13.593", "LastActivityDate": "2011-01-17T17:02:13.593"}, "bq_ids": {"n4140": {"so_4715740_4715888_0": {"section_id": 7195, "quality": 1.0, "length": 43}}, "n3337": {"so_4715740_4715888_0": {"section_id": 6939, "quality": 1.0, "length": 43}}, "n4659": {"so_4715740_4715888_0": {"section_id": 8704, "quality": 1.0, "length": 43}}}, "4716674": {"ParentId": "4715740", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Suppose you didn't have the reference operator <code>&lt;type&gt;&amp;</code> in the language. Then whenever you wanted to pass a reference to an object to a function you would have to do what's done in C, pass the argument as <code>&amp;&lt;myobject&gt;</code> and receive it in the function as a pointer parameter <code>&lt;type&gt;* p</code>. Then you would have to discipline yourself <em>not</em> to do something like <code>p++</code>. </p>\n<p>That's where the safety comes in.\nPassing by reference is very useful, and having the reference operator avoids the risk that you'll modify the pointer.</p>\n<p>(Maybe a const pointer would accomplish the same thing, but you've got to admit the <code>&amp;</code> is cleaner. And it can be applied to other variables besides parameters.)</p>\n", "OwnerUserId": "23771", "LastEditorUserId": "23771", "LastEditDate": "2011-01-17T18:54:19.807", "Id": "4716674", "Score": "0", "CreationDate": "2011-01-17T18:48:07.053", "LastActivityDate": "2011-01-17T18:54:19.807"}, "4715814": {"ParentId": "4715740", "CommentCount": "3", "Body": "<p>It depends how you define \"safer\".</p>\n<p>The compiler won't let you create an uninitialised reference, or one that points to NULLness, and it won't let you accidentally make your reference refer someplace else whilst you're using it. These stricter rules also mean that your compiler can give you some more warnings about common mistakes, whereas with pointers it's never really sure whether you <em>meant</em> to do what you did, or not.</p>\n<p>On the other hand, the transparency of the syntax -- namely, what Alexandre C. mentioned about what it looks like at the <em>call-site</em> to pass an argument as a reference -- makes it quite easy not to realise that you're passing a reference. Consequently, you might not realise that you're supposed to maintain ownership and lifetime of the argument, or that your argument may get permanently modified.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "4715814", "Score": "7", "CreationDate": "2011-01-17T17:08:07.257", "LastActivityDate": "2011-01-17T17:08:07.257"}, "4715766": {"ParentId": "4715740", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It is a little safer, but not the same thing. Note that you have the same problems of \"dangling references\" as with \"dangling pointers\". For instance, returning a reference from a scoped object yields undefined behaviour, exactly the same as pointers:</p>\n<pre><code>int&amp; f() { int x = 2; return x; }\n</code></pre>\n<p>The only benefit is that you cannot <strong>create</strong> a null reference. Even if you try hard:</p>\n<pre><code>int&amp; null_ref = *((int*)0); // Dereferencing a null pointer is undefined in C++\n                            // The variable null_ref has an undefined state.\n</code></pre>\n<p>As class members, pointers are preferred since they have better assignment semantics: you cannot reassign a reference when it has been initialized. The compiler won't be able to provide a default assignment operator if there are reference members in the class. </p>\n<p>Therefore, C++ cannot get rid of pointers, and you can use them freely: by passing arguments as pointers and not as (non const) references, you make it clear at the call site that the object will be modified. This can add a little safety, since you see by naked eye what functionsindeed modify objects.</p>\n<p>I play a little the devil's advocate, but references are easy to abuse.</p>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2011-01-17T20:56:58.997", "Id": "4715766", "Score": "2", "CreationDate": "2011-01-17T17:02:37.150", "LastActivityDate": "2011-01-17T20:56:58.997"}, "4715813": {"ParentId": "4715740", "CommentCount": "0", "Body": "<p>Because references must always be initialized and since they must refer to an existing object, it is much harder (but by no means impossible) to end up with dangling references than it is to have uninitialized/dangling pointers. Also, it's easier to manipulate references because you don't have to worry about taking addresses and dereferencing them.</p>\n<p>But just to show you that a reference by itself doesn't make your program 100% safe, consider this:</p>\n<pre><code>int *p = NULL;\nint &amp;r = *p;\nr = 10; /* bad things will happen here */\n</code></pre>\n<p>Or this:</p>\n<pre><code>int &amp;foo() {\n  int i;\n  return i;\n}\n\n...\n\nint &amp;r = foo();\nr = 10; /* again, bad things will happen here */\n</code></pre>\n", "OwnerUserId": "381345", "PostTypeId": "2", "Id": "4715813", "Score": "2", "CreationDate": "2011-01-17T17:07:58.500", "LastActivityDate": "2011-01-17T17:07:58.500"}, "4715809": {"ParentId": "4715740", "CommentCount": "0", "Body": "<p>Well the answer you point out answer that. From the \"safer\" point of view I think that basically it is hard to write code like :</p>\n<pre><code>int* i;\n// ...\ncout &lt;&lt; *i &lt;&lt; endl; // segfault\n</code></pre>\n<p>As a reference is always initialized, and </p>\n<pre><code>MyObject* po = new MyObject(foo);\n// ...\ndelete po;\n// ...\npo-&gt;doSomething(); // segfault\n</code></pre>\n<p>But as said in the question you mention, that's not only because they are safer that references are used ...</p>\n<p>my2c</p>\n", "OwnerUserId": "135549", "PostTypeId": "2", "Id": "4715809", "Score": "0", "CreationDate": "2011-01-17T17:07:38.157", "LastActivityDate": "2011-01-17T17:07:38.157"}, "4715740": {"CommentCount": "3", "AcceptedAnswerId": "4715888", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-01-17T17:00:10.983", "LastActivityDate": "2011-01-18T03:59:31.037", "LastEditDate": "2017-05-23T11:47:08.517", "ViewCount": "2304", "FavoriteCount": "1", "Title": "Why is a c++ reference considered safer than a pointer?", "Id": "4715740", "Score": "8", "Body": "<p>When the c++ compiler generates very similar assembler code for a reference and pointer, why is using references preferred (and considered safer) compared to pointers?</p>\n<p>I did see </p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/57483/difference-between-pointer-variable-and-reference-variable-in-c\">Difference between pointer variable and reference variable in C++</a> which discusses the differences between them.</li>\n</ul>\n<p><strong>EDIT-1:</strong></p>\n<p>I was looking at the assembler code generated by g++ for this small program:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n  int a;\n  int &amp;ra = a;\n  int *pa = &amp;a;\n}\n</code></pre>\n", "Tags": "<c++><pointers><reference>", "OwnerUserId": "338913", "AnswerCount": "9"}, "4715816": {"ParentId": "4715740", "CommentCount": "17", "Body": "<p>A pointer is an independent variable that can be reassigned to point to another date item, unintialized memory, or just no where at all (NULL). A pointer can be incremented, decremented, subtracted from another pointer of the same type, etc. A reference is tied to an existing variable and is simply an alias for the variable name.</p>\n", "OwnerUserId": "540815", "PostTypeId": "2", "Id": "4715816", "Score": "-1", "CreationDate": "2011-01-17T17:08:15.580", "LastActivityDate": "2011-01-17T17:08:15.580"}});