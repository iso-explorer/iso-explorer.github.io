post_cb({"40965252": {"ParentId": "40965191", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The result of a <code>std::bind</code> is not a <code>std::function</code>, as the shown code assumes.</p>\n<p>As such, when the shown code casts the pointer to the return value from <code>std::bind</code> to a <code>void *</code>, then casts it back to a pointer to a <code>std::function</code>, then invokes or accesses the function object, this results in undefined behavior.</p>\n<p>[func.bind.isbind] specifies <code>std::bind</code> as follows:</p>\n<blockquote>\n<p id=\"so_40965191_40965252_0\">template&lt;class F, class... BoundArgs&gt; <em>unspecified</em> bind(F&amp;&amp; f,\n  BoundArgs&amp;&amp;... bound_args);</p>\n</blockquote>\n<p>With the return value of: \"A forwarding call wrapper <em>g</em> with a weak result type (20.9.2). The effect of g(u1, u2, ..., uM) shall be INVOKE (fd, std::forward(v1), std::forward(v2), ..., std::forward(vN), result_of_t)\".</p>\n<p>That's it. The class returned by <code>std::bind</code> is unspecified, and although it is certainly permitted for a given C++ implementation to, somehow, produce a <code>std::function</code>, it is not required to do so.</p>\n<p>But, the solution is simple: explicitly assign the return value from <code>std::bind</code> to an appropriate <code>std::function</code>.</p>\n", "OwnerUserId": "3943312", "LastEditorUserId": "3943312", "LastEditDate": "2016-12-05T00:20:51.337", "Id": "40965252", "Score": "0", "CreationDate": "2016-12-05T00:04:16.830", "LastActivityDate": "2016-12-05T00:20:51.337"}, "40965191": {"CommentCount": "0", "ViewCount": "437", "CreationDate": "2016-12-04T23:55:45.403", "LastActivityDate": "2016-12-05T00:20:51.337", "Title": "Cast std::bind function pointer to void* and back", "FavoriteCount": "1", "PostTypeId": "1", "Id": "40965191", "Score": "1", "Body": "<p>Let's say I want to bind a function and then pass it to another function as a void *, and cast it back.</p>\n<p>I have a global function in which I try to cast the function:</p>\n<pre><code>void function_wrapper(void * func){\n\nstd::function&lt;void(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;)&gt; * function = reinterpret_cast&lt;std::function&lt;void(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;)&gt; *&gt;(func);\n\nstd::function&lt;void(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;)&gt; function_ = *function;\n}\n</code></pre>\n<p>func, meanwhile, is created as:</p>\n<pre><code>auto func = std::bind(&amp;MyObj&lt;dim&gt;::myfunc, this, _1, _2);\n</code></pre>\n<p>Here <code>dim</code> is a templated integer equal to <code>2</code> And <code>function_wrapper</code> is called via </p>\n<pre><code>function_wrapper((void *)(&amp;func));\n</code></pre>\n<p>Meanwhile, <code>myfunc</code> is a method of <code>MyObj&lt;dim&gt;</code> with type:</p>\n<pre><code>void myfunc(const std::vector&lt;double&gt;&amp; x, std::vector&lt;double&gt;&amp; F) const;\n</code></pre>\n<p>When I try to call function_wrapper as described above, I get the following error when I dereference it:</p>\n<pre><code>Exception thrown: read access violation.\n\nstd::_Func_class&lt;void,std::vector&lt;double,std::allocator&lt;double&gt; &gt; const &amp; __ptr64,std::vector&lt;double,std::allocator&lt;double&gt; &gt; const &amp; __ptr64&gt;::_Getimpl(...) returned 0xFFFFFFFFFFFFFFFF.\n\nIf there is a handler for this exception, the program may be safely continued.\n</code></pre>\n<p>I presume I have the typing wrong of my cast, but I don't know the correct way to declare the type.  What is the proper way to do this?</p>\n", "Tags": "<c++><casting><stdbind>", "OwnerUserId": "650261", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40965191_40965252_0": {"section_id": 4632, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_40965191_40965252_0": {"section_id": 4443, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_40965191_40965252_0": {"section_id": 6002, "quality": 0.8571428571428571, "length": 6}}}});