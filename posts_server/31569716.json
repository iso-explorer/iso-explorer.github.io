post_cb({"bq_ids": {"n4140": {"so_31569716_31570089_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 313}}, "n3337": {"so_31569716_31570089_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 303}}, "n4659": {"so_31569716_31570089_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 321}}}, "31569716": {"ViewCount": "386", "Body": "<p>I have a class template <code>CFoo&lt;T&gt;</code>. I want to allow implicit casts to other instantiations of <code>CFoo</code>, but only for those whose template argument is a base class of <code>T</code>. </p>\n<p>I tried to use SFINAE, but neither of my attempts worked on any compiler I tried (VC 2012 or gcc):</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;class T&gt; class CFoo {\npublic:\n    template &lt;class Q&gt;  operator\n     // typename std::enable_if&lt;std::is_base_of&lt;Q, T&gt;::value, CFoo&lt;Q&gt;&amp;&gt;::type   // SHOULD WORK?\n     // typename std::enable_if&lt;1, CFoo&lt;Q&gt;&amp;&gt;::type                              // SHOULD WORK?\n     CFoo&lt;Q&gt;&amp;  // compiles, but doesn't restrict on Q like I want\n     () const {\n        return *(CFoo&lt;Q&gt;*)this;\n    }\n};\n\nclass A {};\nclass B : public A {};\n\nint main(int argc, char* argv[])\n{\n    CFoo&lt;B&gt; b;\n    CFoo&lt;A&gt;&amp; a = b;\n    return 0;\n}\n</code></pre>\n<p>Why don't either of the commented out attempts at SFINAE work here? In both cases I just get an error for an invalid initialization of <code>a</code>, as if my operator didn't get called. </p>\n", "AcceptedAnswerId": "31570089", "Title": "SFINAE to enable cast operator only from derived to base class", "CreationDate": "2015-07-22T17:10:34.873", "Id": "31569716", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-22T17:44:43.000", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-22T17:50:23.077", "Score": "2", "OwnerUserId": "121540", "Tags": "<c++><templates><c++11><template-deduction>", "AnswerCount": "1"}, "31570089": {"Id": "31570089", "PostTypeId": "2", "Body": "<p>According to [temp.deduct.conv]:</p>\n<blockquote>\n<p id=\"so_31569716_31570089_0\">Template argument deduction is done by comparing the return type of the conversion function template (call\n  it P) with the type that is required as the result of the conversion (call it A; see 8.5, 13.3.1.5, and 13.3.1.6\n  for the determination of that type) as described in 14.8.2.5.</p>\n</blockquote>\n<p>In the simple case:</p>\n<pre><code>template &lt;class Q&gt;\noperator CFoo&lt;Q&gt;&amp; const;\n</code></pre>\n<p>That's straightforward, we try to deduce <code>CFoo&lt;Q&gt;&amp;</code> against <code>CFoo&lt;A&gt;&amp;</code>. There's other rules in that section, but ultimately that deduction succeeds with <code>Q == A</code>.</p>\n<p>Both of your other attempts fail for the same reason. I'll pick the simpler one:</p>\n<pre><code>template &lt;class Q&gt;\noperator typename std::enable_if&lt;1, CFoo&lt;Q&gt;&amp;&gt;::type const;\n</code></pre>\n<p>Here, we're trying to deduce <code>typename std::enable_if&lt;1, CFoo&lt;Q&gt;&amp;&gt;::type</code>. This is a non-deduced context (it's a <em>nested-name-specifier</em>  of a type that was specified using a <em>qualified-id</em>), so deduction fails. So this conversion function won't be considered, so the assignment fails as no conversion is found.</p>\n<p>You need the return type to be a deduced context, so the SFINAE has to go here:</p>\n<pre><code>template &lt;class Q,\n          typename = std::enable_if_t&lt;std::is_base_of&lt;Q, T&gt;::value&gt;&gt;\noperator CFoo&lt;Q&gt;&amp; const;\n</code></pre>\n<p>That way, we have something to deduce (<code>CFoo&lt;Q&gt;&amp;</code>) - and the deduction can succeed (if <code>Q</code> is a base of <code>T</code>):</p>\n<pre><code>CFoo&lt;A&gt;&amp; a = b; // OK\nCFoo&lt;int&gt;&amp; i = b; // deduction failure on Q, so there's no viable conversion function\n                  // so this is an error\n</code></pre>\n<hr/>\n<p>That said, while I got carried away with solving template puzzles, as <a href=\"https://stackoverflow.com/questions/31569716/sfinae-to-enable-cast-operator-only-from-derived-to-base-class/31570089?noredirect=1#comment51095596_31570089\">T.C.</a> points out, this really isn't a good solution because:</p>\n<pre><code>return *(CFoo&lt;Q&gt;*)this;\n</code></pre>\n<p>just does a <code>reinterpret_cast</code> (and a <code>const_cast</code>) so it really cannot possibly be doing anything reasonable and you will almost certainly (unless <code>CFoo</code> is trivial) end up with undefined behavior by trying to access its members with the wrong type. </p>\n<p>You probably instead want to add a conversion <em>constructor</em> rather than a conversion <em>function</em>:</p>\n<pre><code>template &lt;typename Q,\n          typename = std::enable_if_t&lt;std::is_base_of&lt;T, Q&gt;::value&gt;&gt;\nCFoo(CFoo&lt;Q&gt; const&amp; ) { }\n</code></pre>\n<p>That way, when you do:</p>\n<pre><code>CFoo&lt;A&gt; a = b; // a is not a reference anymore\n</code></pre>\n<p>You are constructing a <em>new</em> object that will necessarily be valid. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-22T17:50:23.077", "Score": "6", "CreationDate": "2015-07-22T17:30:12.607", "ParentId": "31569716", "CommentCount": "9", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T11:55:07.183"}});