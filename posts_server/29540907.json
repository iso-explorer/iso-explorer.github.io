post_cb({"bq_ids": {"n4140": {"so_29540907_29541200_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 3218}, "so_29540907_29541200_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 3223}}, "n3337": {"so_29540907_29541200_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 3092}, "so_29540907_29541200_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 3097}}, "n4659": {"so_29540907_29541200_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 3975}, "so_29540907_29541200_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 3980}}}, "29541200": {"Id": "29541200", "PostTypeId": "2", "Body": "<p>I believe the code is valid and the two types are the same.</p>\n<p>[dcl.ref]/1 says:</p>\n<blockquote>\n<p id=\"so_29540907_29541200_0\">Cv-qualified references are ill-formed except when the cv-qualifiers are introduced through the use of a <em>typedef-name</em> (7.1.3, 14.1) or <em>decltype-specifier</em> (7.1.6.2), in which case the cv-qualifiers are ignored.</p>\n</blockquote>\n<p>Since you are introducing the first <code>const</code> through a <em>decltype-specifier</em>, it is ignored, and your first type is equivalent to <code>decltype(b)&amp;</code>.</p>\n<p>Now [dcl.ref]/6 says:</p>\n<blockquote>\n<p id=\"so_29540907_29541200_1\">If a <em>typedef-name</em> (7.1.3, 14.1) or a <em>decltype-specifier</em> (7.1.6.2) denotes a type <code>TR</code> that is a reference to a type <code>T</code>, an attempt to create the type \"lvalue reference to <em>cv</em> <code>TR</code>\" creates the type \"lvalue reference to <code>T</code>\" [...]</p>\n</blockquote>\n<p>Your <em>decltype-specifier</em> denotes the type \"reference to <code>const int</code>\", and you are attempting to create an lvalue reference, so you end up with an lvalue reference to <code>const int</code>.</p>\n", "LastActivityDate": "2015-04-09T14:22:29.513", "Score": "3", "CreationDate": "2015-04-09T14:22:29.513", "ParentId": "29540907", "CommentCount": "4", "OwnerUserId": "596781"}, "29540907": {"ViewCount": "110", "Body": "<p>Consider the following code:</p>\n<pre><code>int a = 1;\nconst int&amp; b = a;\nstd::cout &lt;&lt; std::is_same&lt;const decltype(b)&amp;, const int&amp;&gt;();\n</code></pre>\n<p>It compiles on clang 3.5 while GCC 4.9 gives the following error:</p>\n<p><code>error: 'const' qualifiers cannot be applied to 'const int&amp;'</code></p>\n<p>Which one is correct according to the standard? My guess is that GCC is standard-conformant, just as you can't do <code>int&amp; const b = a;</code>.</p>\n", "AcceptedAnswerId": "29541200", "Title": "Issues concerning const decltype(x)&", "CreationDate": "2015-04-09T14:10:00.673", "Id": "29540907", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-04-09T14:16:11.520", "LastEditorUserId": "1348273", "LastActivityDate": "2015-04-09T14:22:29.513", "Score": "9", "OwnerUserId": "1348273", "Tags": "<c++><templates><metaprogramming><language-lawyer><decltype>", "AnswerCount": "1"}});