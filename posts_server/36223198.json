post_cb({"bq_ids": {"n4140": {"so_36223198_36223967_4": {"length": 30, "quality": 1.0, "section_id": 3270}, "so_36223198_36223967_0": {"length": 7, "quality": 0.875, "section_id": 457}, "so_36223198_36223967_1": {"length": 24, "quality": 1.0, "section_id": 457}}, "n3337": {"so_36223198_36223967_4": {"length": 30, "quality": 1.0, "section_id": 3142}, "so_36223198_36223967_1": {"length": 21, "quality": 0.875, "section_id": 448}, "so_36223198_36223967_0": {"length": 7, "quality": 0.875, "section_id": 448}}, "n4659": {"so_36223198_36223967_4": {"length": 30, "quality": 1.0, "section_id": 4028}, "so_36223198_36223967_1": {"length": 24, "quality": 1.0, "section_id": 480}, "so_36223198_36223967_0": {"length": 7, "quality": 0.875, "section_id": 480}}}, "36223967": {"Id": "36223967", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/class.copy#8\" rel=\"nofollow\">[class.copy]/8</a>:</p>\n<blockquote>\n<p id=\"so_36223198_36223967_0\">The implicitly-declared copy constructor for a class <code>X</code> will have the\n  form</p>\n<pre><code>X::X(const X&amp;)\n</code></pre>\n<p id=\"so_36223198_36223967_1\">if each potentially constructed subobject of a class type <code>M</code> (or\n  array thereof) has a copy constructor whose first parameter is of type\n  <code>const M&amp;</code> or <code>const volatile M&amp;</code>. Otherwise, the implicitly-declared\n  copy constructor will have the form</p>\n<pre><code>X::X(X&amp;)\n</code></pre>\n</blockquote>\n<p>Therefore, if the copy constructor of <code>std::pair&lt;A, int&gt;</code> were to be implicitly declared, it would have the form <code>pair::pair(pair &amp;)</code>.</p>\n<p><a href=\"http://eel.is/c++draft/dcl.fct.def.default#1\" rel=\"nofollow\">[dcl.fct.def.default]/1</a>:</p>\n<blockquote>\n<p id=\"so_36223198_36223967_2\">A function that is explicitly defaulted shall</p>\n<ul>\n<li><p id=\"so_36223198_36223967_3\">be a special member function,</p></li>\n<li><p id=\"so_36223198_36223967_4\">have the same declared function type (except for possibly differing <em>ref-qualifier</em>s and except that in the case of a copy constructor or\n  copy assignment operator, the parameter type may be \u201creference to\n  non-const <code>T</code>\u201d, where <code>T</code> is the name of the member function's class) as\n  if it had been implicitly declared, and</p></li>\n<li><p id=\"so_36223198_36223967_5\">not have default arguments.</p></li>\n</ul>\n</blockquote>\n<p>Since the declaration <code>pair(const pair&amp;) = default;</code> doesn't have the same declared function type as the copy constructor that would have been implicitly declared, and neither exception applies, the program is ill-formed.</p>\n", "LastActivityDate": "2016-03-25T16:31:20.587", "CommentCount": "0", "CreationDate": "2016-03-25T16:31:20.587", "ParentId": "36223198", "Score": "4", "OwnerUserId": "2756719"}, "36223401": {"Id": "36223401", "PostTypeId": "2", "Body": "<p>If you want to <code>= delete</code> the copy constructor, the proper form is: <code>A(const A&amp;) = delete;</code>. See how you forgot that <code>const</code>? <code>pair</code> can be used with a non-copyable type, even a non-moveable type.</p>\n<p>Your instantiation problem can also be demonstrated with:</p>\n<pre><code>struct A {\n    A(A&amp;) = delete;\n};\n\nstruct B : A {\n    B(const B&amp;) = default;\n};\n</code></pre>\n<p>or...</p>\n<pre><code>struct B {\n    B(const B&amp;) = default;\n    A a;\n};\n</code></pre>\n<p>Basically, <code>pair</code> <code>= default</code> its copy ctor, and defines it as taking a <code>const pair&amp;</code>, but one one of your types defines it to take a non-const &amp;, so the default generation fails since it can't pass it's const&amp; to your non-const&amp;. Even though yours is <code>= delete</code>ed, it doesn't matter, it doesn't get that far.</p>\n<p>A defaulted copy ctor will effectively be deleted if a member or base class is non-copyable. But in order to figure that out, it has to have a function it is able to call (even if that function is deleted). In these cases, it can't pass a const&amp; to a non-const&amp; so it can't even figure out that you have a deleted copy ctor. Conceivably, something in the standard could be written to accommodate this edge case.</p>\n", "LastEditorUserId": "369872", "LastActivityDate": "2016-03-25T16:04:27.227", "Score": "6", "CreationDate": "2016-03-25T15:59:10.660", "ParentId": "36223198", "CommentCount": "0", "OwnerUserId": "369872", "LastEditDate": "2016-03-25T16:04:27.227"}, "36223198": {"ViewCount": "1517", "Body": "<p>Suppose you have the following class:</p>\n<pre><code>struct A {\n    A () {}\n    A (A &amp;) = delete;\n};\n\nint main() {\n    std::pair&lt;A, int&gt; p1;\n    return 0;\n}\n</code></pre>\n<p>The following code will fail to compile (using <code>-std=c++11</code> with <code>g++</code>) with the following error:</p>\n<blockquote>\n<p id=\"so_36223198_36223198_0\">/usr/include/c++/5/bits/stl_pair.h: In instantiation of \u2018struct std::pair\u2019:</p>\n<p id=\"so_36223198_36223198_1\">test.cpp:13:23:   required from here</p>\n<p id=\"so_36223198_36223198_2\">/usr/include/c++/5/bits/stl_pair.h:127:17: error: \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) [with _T1 = A; _T2 = int]\u2019 declared to take const reference, but implicit declaration would take non-const</p>\n<pre><code>constexpr pair(const pair&amp;) = default;\n</code></pre>\n</blockquote>\n<p>According to the error message, I would assume that this is because it is not possible to instanciate the default copy constructor because of the <code>const</code> qualifier on the <code>std::pair</code> argument.</p>\n<p>I could understand why this would not compile without the <code>= delete</code>, because it is not possible to instanciate the copy constructor which takes a <code>std::pair const&amp;</code> parameter. </p>\n<p>But with the <code>= delete</code>, I would expect the compiler to not instantiate such constructor because it cannot (as far as I understand). Actually, this copy constructor is deleted as shown by this piece of code:</p>\n<pre><code>std::pair&lt;A, int&gt; p1;\ndecltype(p1) p2(p1);\n</code></pre>\n<p>Which fails:</p>\n<blockquote>\n<p id=\"so_36223198_36223198_3\">test.cpp:11:23: error: use of deleted function \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) [with _T1 = A; _T2 = int]\u2019</p>\n<pre><code>decltype(p1) p2(p1);\n</code></pre>\n</blockquote>\n<p>Basically, my question is: Why does the compiler fails to instantiate a deleted copy constructor of <code>std::pair</code>?</p>\n", "AcceptedAnswerId": "36223967", "Title": "Why is it not possible to instantiate pair with \"non const\" copy constructor while it is possible to instantiate one without?", "CreationDate": "2016-03-25T15:48:13.343", "Id": "36223198", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-25T16:22:06.870", "LastEditorUserId": "1362568", "LastActivityDate": "2016-03-25T16:31:20.587", "Score": "5", "OwnerUserId": "2666289", "Tags": "<c++><c++11><constructor>", "AnswerCount": "2"}});