post_cb({"23543826": {"LastActivityDate": "2014-05-08T14:08:00.857", "LastEditorUserId": "3235496", "ParentId": "23543300", "LastEditDate": "2014-05-08T14:08:00.857", "Id": "23543826", "Score": "1", "Body": "<p><code>std::begin</code> and <code>std::end</code> work with parameters that are C style arrays.</p>\n<p>A possible implementation of <code>std::end</code> is:</p>\n<pre><code>template&lt;class T, std::size_t sizeOfArray&gt;\nconstexpr T *end(T (&amp;array)[sizeOfArray])\n{\n  return &amp;array[sizeOfArray];\n}\n</code></pre>\n<p>This way <code>arr</code> is not converted in a pointer when you call <code>std::end(arr)</code> (and the information about the size of the array isn't lost... the function only accepts arrays with exactly <code>sizeOfArray</code> elements as argument).</p>\n<pre><code>template&lt;class T&gt;\nT *end(T array[])\n{\n  // ?\n}\n</code></pre>\n<p>won't work since <code>T array[]</code> behaves like a flat pointer (<code>T *array</code>), rather than a real array, when used as a function parameter.</p>\n<p><code>auto</code> decays the array <code>arr</code> into a pointer and the <em>trick</em> won't work anymore.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "3235496", "CreationDate": "2014-05-08T13:54:05.463"}, "23543555": {"LastActivityDate": "2014-05-08T14:00:54.357", "LastEditorUserId": "2589776", "ParentId": "23543300", "LastEditDate": "2014-05-08T14:00:54.357", "Id": "23543555", "Score": "2", "Body": "<p>Here, <code>auto</code> will decay the <code>arr</code> (array type) to a pointer. And both <a href=\"http://en.cppreference.com/w/cpp/iterator/begin\" rel=\"nofollow\"><strong><code>std::begin</code></strong></a> and <a href=\"http://en.cppreference.com/w/cpp/iterator/end\" rel=\"nofollow\"><strong><code>std::end</code></strong></a> can only work for containers or arrays, but not for pointers.</p>\n<p>From C++11 standard </p>\n<blockquote>\n<p id=\"so_23543300_23543555_0\"><strong>\u00a77.1.6.4 auto specifier</strong> [dcl.spec.auto]</p>\n<p id=\"so_23543300_23543555_1\">1 The auto type-specifier signifies that <strong>the type of a variable being declared shall be deduced from its initializer</strong>\n  or that a function declarator shall include a trailing-return-type.</p>\n</blockquote>\n<p>You code cannot work here as <code>auto</code> cannot deduce array types. Just like:</p>\n<pre><code>char a[5];\nauto b[5] = a;  // error, a evaluates to a pointer, which does\n                // not match the array type\n</code></pre>\n<p>To make it work, just use C++ containers like <code>std::vector</code>:</p>\n<pre><code>vector&lt;int&gt; arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n</code></pre>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "2589776", "CreationDate": "2014-05-08T13:43:21.380"}, "bq_ids": {"n3337": {"so_23543300_23543555_1": {"section_id": 5240, "quality": 0.9333333333333333, "length": 14}}}, "23543437": {"LastActivityDate": "2014-05-08T13:39:08.273", "ParentId": "23543300", "Id": "23543437", "Score": "2", "Body": "<p>Because <code>std::begin</code> is defined for arrays but not for pointers. An array type is not the same as a pointer type.</p>\n<p>The problem here is that apparently the <code>auto arr2 = arr</code> degrades the type from the array type to a pointer type.</p>\n<p>Note that the problem is actually in <code>std::end</code> not in <code>std::begin</code>. After all how would <code>std::end</code> be able to give the pointer to the last+1 element when all it has is a pointer to the first element? It can't, therefore <code>std::end</code> cannot be defined for a pointer type and hence <code>std::begin</code> does not make any sense for a pointer type.</p>\n<p>To be precise the type of <code>arr</code> is <code>int[10]</code> while that of <code>arr2</code> and <code>arr3</code> is <code>int*</code>. The former can degrade into the latter but not vice versa.</p>\n", "CommentCount": "4", "PostTypeId": "2", "OwnerUserId": "251414", "CreationDate": "2014-05-08T13:39:08.273"}, "23544364": {"LastActivityDate": "2014-05-08T14:14:54.277", "ParentId": "23543300", "Id": "23544364", "Score": "6", "Body": "<p>An array is converted to a pointer easily, but not always.  For example, if you take the address of the array or get a reference then the original array type isn't lost:</p>\n<pre><code>int a[10];\nint (&amp;ar)[10] = a; // fine\nint (*ap)[10] = &amp;a; // also fine\n</code></pre>\n<p>However, when you use an array in a way where most other types would be copied, the array is converted to a pointer and the pointer is copied instead.</p>\n<p>In your example, you can use arr2 if you make it be a reference:</p>\n<pre><code> auto &amp;arr2 = arr;\n</code></pre>\n<p>Now <code>arr2</code> has type <code>int (&amp;)[10]</code> instead of <code>int *</code>.</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "951890", "CreationDate": "2014-05-08T14:14:54.277"}, "23543300": {"ViewCount": "4877", "AcceptedAnswerId": "23544364", "Tags": "<c++><arrays><pointers><c++11><iterator>", "AnswerCount": "4", "OwnerUserId": "2034041", "Body": "<p>It is stated in <a href=\"http://rads.stackoverflow.com/amzn/click/0321714113\">C++ Primer</a> that</p>\n<blockquote>\n<p id=\"so_23543300_23543300_0\">In C++ pointers and arrays are closely intertwined. In particular, as\n  we\u2019ll see, <strong>when we use an array, the compiler ordinarily converts the\n  array to a pointer</strong>.</p>\n</blockquote>\n<p>I wanted to use iterators for printing an array. The program below works fine but when I try to print <code>arr2</code> or <code>arr3</code>, if I'm not mistaken, which is of type <code>int *</code>, I get an error (judging that the &amp; operator means reference below). </p>\n<blockquote>\n<p id=\"so_23543300_23543300_1\"><code>error: no matching function for call to \u2018begin(int*&amp;)\u2019</code></p>\n</blockquote>\n<pre><code>int main(int argc, char** argv) {\n\n    int arr[] = {0,1,2,3,4,5,6,7,8,9};\n    auto arr2 = arr;\n    auto arr3(arr);   // I think arr2 and arr3 are of same type\n\n    for(auto it = std::begin(arr) ; it != std::end(arr) ; ++it)\n        std::cout &lt;&lt; *it &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Considering the statement, if an array is converted into a pointer by the compiler, how does this program work for printing contents of <code>arr</code> using <code>std::begin()</code> and <code>std::end()</code>  and do not work for <code>arr2</code> or <code>arr3</code> if all of them are pointers to integers?</p>\n<hr>\n<p><strong>Edit</strong></p>\n<p>I'm sorry if I couldn't make it clear. I hope I'll clarify the problem by this edit. </p>\n<p>Now that I am aware that <code>begin()</code> and <code>end()</code> won't work with pointers (thanks to the answers), I wonder if the quoted text is not true as it specifies that there is an <strong>Array -&gt; Pointer</strong> conversion. If what text says is true then the type of <code>arr</code> should be a pointer. Is there a problem with the quoted text at this point?</p>\n<p>Also, is there any way that I can use <code>begin()</code> and <code>end()</code> for pointers (not STL containers) with specifying the size, possibly using the following constructor?</p>\n<pre><code>template&lt; class T, size_t N &gt; \nT* begin( T (&amp;array)[N] );\n</code></pre>\n</hr>", "CommentCount": "1", "PostTypeId": "1", "CreationDate": "2014-05-08T13:33:19.780", "FavoriteCount": "1", "LastActivityDate": "2014-05-08T14:15:36.627", "Id": "23543300", "LastEditorUserId": "2034041", "Title": "Using iterators on arrays", "Score": "14", "LastEditDate": "2014-05-08T14:15:36.627"}});