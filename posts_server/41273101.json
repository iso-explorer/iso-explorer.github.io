post_cb({"41273286": {"ParentId": "41273101", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Yes, what you are attempting is allowed. The two relevant excerpts I've found in <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf\" rel=\"nofollow noreferrer\">N4606</a> are:</p>\n<p>6.4.1/2 [stmt.if]</p>\n<blockquote>\n<p id=\"so_41273101_41273286_0\">If the if statement is of the form if constexpr [...] If the value of\n  the converted condition is false, the first substatement is a discarded statement, otherwise the second substatement, if present, is a discarded statement.</p>\n</blockquote>\n<p>Indicating an untaken branch in a <em>constexpr if</em> is a discarded statment. Further, auto functions only consider non-discarded return statements for deducing the return type</p>\n<p>7.1.7.4/2 [dcl.spec.auto] (emphasis mine)</p>\n<blockquote>\n<p id=\"so_41273101_41273286_1\">[...] If the declared return type of the function contains a placeholder type, the return type of the function is <strong>deduced from non-discarded return statements</strong>, if any, in the body of the function (6.4.1).</p>\n</blockquote>\n<p>Simplified, the following code works on both <a href=\"http://melpon.org/wandbox/permlink/fqu824ZX79MG53Th\" rel=\"nofollow noreferrer\">gcc</a> and <a href=\"http://melpon.org/wandbox/permlink/QUPdvtRqnWMR60ti\" rel=\"nofollow noreferrer\">clang</a> head.</p>\n<pre><code>namespace {\n\nenum class shape_type { TRIANGLE, RECTANGLE, CIRCLE};\n\ntemplate&lt;shape_type&gt;\nstruct shape { };\n\nusing triangle = shape&lt;shape_type::TRIANGLE&gt;;\nusing rectangle = shape&lt;shape_type::RECTANGLE&gt;;\nusing circle = shape&lt;shape_type::CIRCLE&gt;;\n\ntemplate&lt;shape_type ST&gt;\nconstexpr auto make() {\n  if constexpr (ST == shape_type::TRIANGLE) {\n    return triangle{};\n  } else if constexpr (ST == shape_type::RECTANGLE) {\n    return rectangle{};\n  } else if constexpr (ST == shape_type::CIRCLE) {\n    return circle{};\n  } \n}\n\n}\n\nint main() {\n  auto t = make&lt;shape_type::TRIANGLE&gt;();\n  auto r = make&lt;shape_type::RECTANGLE&gt;();\n  auto c = make&lt;shape_type::CIRCLE&gt;();\n}\n</code></pre>\n", "OwnerUserId": "1013719", "LastEditorUserId": "1013719", "LastEditDate": "2016-12-21T23:45:48.917", "Id": "41273286", "Score": "6", "CreationDate": "2016-12-21T22:53:53.073", "LastActivityDate": "2016-12-21T23:45:48.917"}, "41273101": {"CommentCount": "4", "ViewCount": "283", "PostTypeId": "1", "LastEditorUserId": "562174", "CreationDate": "2016-12-21T22:38:07.380", "LastActivityDate": "2016-12-22T00:30:28.460", "Title": "Can constexpr-if-else bodies return different types in constexpr auto function?", "LastEditDate": "2016-12-22T00:30:28.460", "Id": "41273101", "Score": "4", "Body": "<p>I'm trying to write a function that maps an enumeration of values to a set of types based on the runtime value of the enumeration. I realize that you cannot return different types based on the runtime value of an enumeration because the compiler wouldn't know how much stack space to allocate. However I'm trying to write this as a constexpr function, using the new if-constexpr functionality to implement this.</p>\n<p>I'm getting an error from clang complaining that I'm using an illegally specified template parameter. Does anyone see how to implement this?</p>\n<p>edit: Here is an easier to grok version demonstrating my problem more concisely:\n<a href=\"http://coliru.stacked-crooked.com/a/2b9fef340bd167a8\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/2b9fef340bd167a8</a></p>\n<p>old code:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\nnamespace\n{\n\nenum class shape_type : std::size_t\n{\n  TRIANGLE = 0u,\n  RECTANGLE,\n  POLYGON,\n  CUBE,\n  INVALID_SHAPE_TYPE\n};\n\ntemplate&lt;std::size_t T&gt;\nstruct shape {\n};\n\nusing triangle = shape&lt;static_cast&lt;std::size_t&gt;(shape_type::TRIANGLE)&gt;;\nusing rectangle = shape&lt;static_cast&lt;std::size_t&gt;(shape_type::RECTANGLE)&gt;;\nusing polygon = shape&lt;static_cast&lt;std::size_t&gt;(shape_type::POLYGON)&gt;;\nusing cube = shape&lt;static_cast&lt;std::size_t&gt;(shape_type::CUBE)&gt;;\n\ntemplate&lt;std::size_t A, std::size_t B&gt;\nstatic bool constexpr same() noexcept { return A == B; }\n\ntemplate&lt;std::size_t ST&gt;\nstatic auto constexpr make_impl(draw_mode const dm)\n{\n  if constexpr (same&lt;ST, shape_type::TRIANGLE&gt;()) {\n    return triangle{};\n  } else if (same&lt;ST, shape_type::RECTANGLE&gt;()) {\n    return rectangle{};\n  } else if (same&lt;ST, shape_type::POLYGON&gt;()) {\n    return polygon{};\n  } else if (same&lt;ST, shape_type::CUBE&gt;()) {\n    return cube{};\n  } else {\n    assert(0 == 5);\n  }\n}\n\nstatic auto constexpr make(shape_type const st, draw_mode const dm)\n{\n  switch (st) {\n      case shape_type::TRIANGLE:\n        return make_impl&lt;shape_type::TRIANGLE&gt;(dm);\n      case shape_type::RECTANGLE:\n        return make_impl&lt;shape_type::RECTANGLE&gt;(dm);\n      case shape_type::POLYGON:\n        return make_impl&lt;shape_type::POLYGON&gt;(dm);\n      case shape_type::CUBE:\n        return make_impl&lt;shape_type::CUBE&gt;(dm);\n      case shape_type::INVALID_SHAPE_TYPE:\n        assert(0 == 17);\n  }\n}\n\n} // ns anon\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// demo\nint main()\n{\n}\n</code></pre>\n<p>Errors:</p>\n<pre class=\"lang-none prettyprint-override\"><code>/home/benjamin/github/BoomHS/main.cxx:42:6: warning: constexpr if is a\nC++1z extension [-Wc++1z-extensions]\n\nif constexpr (same&lt;ST, shape_type::TRIANGLE&gt;()) {\n        ^ /home/benjamin/github/BoomHS/main.cxx:59:16: error: no matching function for call to 'make_impl'\n        return make_impl&lt;shape_type::TRIANGLE&gt;(dm);\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /home/benjamin/github/BoomHS/main.cxx:40:23: note: candidate template\nignored: invalid explicitly-specified argument for template parameter\n'ST' static auto constexpr make_impl(draw_mode const dm)\n                      ^ /home/benjamin/github/BoomHS/main.cxx:61:16: error: no matching function for call to 'make_impl'\n        return make_impl&lt;shape_type::RECTANGLE&gt;(dm);\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /home/benjamin/github/BoomHS/main.cxx:40:23: note: candidate template\nignored: invalid explicitly-specified argument for template parameter\n'ST' static auto constexpr make_impl(draw_mode const dm)\n                      ^ /home/benjamin/github/BoomHS/main.cxx:63:16: error: no matching function for call to 'make_impl'\n        return make_impl&lt;shape_type::POLYGON&gt;(dm);\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /home/benjamin/github/BoomHS/main.cxx:40:23: note: candidate template\nignored: invalid explicitly-specified argument for template parameter\n'ST' static auto constexpr make_impl(draw_mode const dm)\n                      ^ /home/benjamin/github/BoomHS/main.cxx:65:16: error: no matching function for call to 'make_impl'\n        return make_impl&lt;shape_type::CUBE&gt;(dm);\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~ /home/benjamin/github/BoomHS/main.cxx:40:23: note: candidate template\nignored: invalid explicitly-specified argument for template parameter\n'ST' static auto constexpr make_impl(draw_mode const dm)\n</code></pre>\n", "Tags": "<c++><c++1z><multiple-return-values><if-constexpr>", "OwnerUserId": "562174", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41273101_41273286_1": {"section_id": 5446, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_41273101_41273286_1": {"section_id": 5541, "quality": 0.5294117647058824, "length": 9}}, "n4659": {"so_41273101_41273286_0": {"section_id": 4773, "quality": 0.9411764705882353, "length": 16}, "so_41273101_41273286_1": {"section_id": 6873, "quality": 0.9411764705882353, "length": 16}}}});