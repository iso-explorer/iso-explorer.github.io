post_cb({"44970192": {"ParentId": "44969892", "CommentCount": "2", "Body": "<p>Maybe this is not the best reference but this is what Wikipedia says about <a href=\"https://en.wikipedia.org/wiki/Placement_syntax#History\" rel=\"noreferrer\"><em>placement <code>new</code></em></a> in C++:</p>\n<blockquote>\n<p id=\"so_44969892_44970192_0\">In earlier versions of C++ there was no such thing as <em>placement new</em>; instead, developers used explicit assignment to <code>this</code> within constructors to achieve similar effect. This practice has been deprecated and abolished later, and third edition of The <em>\"C++ Programming Language\"</em> doesn't mention this technique. Support for <em>placement new</em> operator has been added to compilers circa 1995.</p>\n</blockquote>\n<p>Maybe in 2017 it is possible to implement <code>new</code> as a standard library function. Your suggested implementation uses language features that were added recently (many of them after 2010).</p>\n<p>The C++ language, however, is much older (since 1983) and in the beginning there were no variadic templates, no <code>typename</code>, no placement <code>new</code>, no forwarding references. </p>\n<p>In the beginning there was only the regular <code>new</code> and it had to be a language feature at that time because there was no way to implement it as a library function.</p>\n", "OwnerUserId": "4265352", "PostTypeId": "2", "Id": "44970192", "Score": "14", "CreationDate": "2017-07-07T11:56:35.063", "LastActivityDate": "2017-07-07T11:56:35.063"}, "44969892": {"CommentCount": "24", "AcceptedAnswerId": "44970089", "CreationDate": "2017-07-07T11:40:16.140", "LastActivityDate": "2017-07-12T12:24:49.783", "Title": "Why are non-placement `new` and `delete` built into the language and not just regular functions?", "ViewCount": "2760", "FavoriteCount": "5", "PostTypeId": "1", "Id": "44969892", "OwnerUserId": "598696", "Body": "<p>Why were the non-placement <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"noreferrer\"><code>new</code> expression</a> and the <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"noreferrer\"><code>delete</code> expression</a> implemented as language built-in instead of regular functions?</p>\n<p>If we have...</p>\n<ul>\n<li><p>a way of requesting/giving back memory to the OS</p></li>\n<li><p>a way of explicitly invoking a constructor <em>(placement <code>new</code>)</em></p></li>\n<li><p>a way of explicitly invoking a destructor <em>(<code>~T()</code>)</em></p></li>\n</ul>\n<p>...why couldn't non-placement <code>new</code> and <code>delete</code> just be regular functions in the Standard Library? Example:</p>\n<pre><code>template &lt;typename T, typename... Ts&gt;\nT* library_new(Ts&amp;&amp;... xs)\n{\n    auto* ptr = /* request enough memory for `T` from OS */;\n    new (ptr) T(std::forward&lt;Ts&gt;(xs)...);\n    return ptr;\n}\n\ntemplate &lt;typename T&gt;\nvoid library_delete(T* ptr)\n{\n    ptr-&gt;~T();\n    /* reclaim memory for `T` from OS */\n} \n</code></pre>\n", "Tags": "<c++><new-operator><delete-operator>", "Score": "38", "AnswerCount": "3"}, "44970016": {"ParentId": "44969892", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>If they were already provided as standalone functions then it would be impossible to provide user-defined replacement for them.</p>\n<p>e.g. right now according to standard it is legel to write my own globl <code>new</code> and <code>delete</code> they will be used thoughout the program.</p>\n<blockquote>\n<p id=\"so_44969892_44970016_0\"><strong>18.6.2 Storage allocation and deallocation [new.delete]</strong></p>\n<p id=\"so_44969892_44970016_1\">2 Replaceable: A C ++ program may define functions with either of these function signatures, and thereby displace the default versions defined by the C ++ standard library.</p>\n</blockquote>\n<p>If those were supplied just like the rest of library functions then every normal call to <code>new</code> or <code>delete</code> would result \"more than one instance of overloaded function matches arguments\" error.</p>\n", "OwnerUserId": "7860670", "LastEditorUserId": "7860670", "LastEditDate": "2017-07-07T11:57:25.737", "Id": "44970016", "Score": "4", "CreationDate": "2017-07-07T11:47:49.687", "LastActivityDate": "2017-07-07T11:57:25.737"}, "bq_ids": {"n4659": {"so_44969892_44970016_1": {"section_id": 8303, "quality": 0.8461538461538461, "length": 11}}}, "44970089": {"ParentId": "44969892", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If the user's goal was to create an object in some memory location, then <code>new</code> seemed like a natural approach since <strong>forwarding references</strong>, <strong>variadic templates</strong> and <strong>placement new</strong> were not a thing back in those days.  As correctly pointed out by <a href=\"https://stackoverflow.com/questions/44969892/why-are-non-placement-new-and-delete-built-into-the-language-and-not-just-re/44970089#comment76938766_44969892\">@T.C.</a> templates were released in 1990 and placement new in 1989.  Variadic templates on the other hand, became a part of C++ only in C++11.</p>\n<p>tl;dr <strong>There was no way to forward a bunch of arguments to a constructor of an arbitrary type (as you can do these days with <code>make</code> functions).</strong> </p>\n", "OwnerUserId": "5501675", "LastEditorUserId": "5501675", "LastEditDate": "2017-07-12T12:24:49.783", "Id": "44970089", "Score": "26", "CreationDate": "2017-07-07T11:50:49.150", "LastActivityDate": "2017-07-12T12:24:49.783"}});