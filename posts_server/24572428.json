post_cb({"bq_ids": {"n4140": {"so_24572428_24573119_0": {"length": 58, "quality": 0.8923076923076924, "section_id": 5908}}, "n3337": {"so_24572428_24573119_0": {"length": 58, "quality": 0.8923076923076924, "section_id": 5680}}}, "24572428": {"CreationDate": "2014-07-04T10:37:54.697", "ViewCount": "7698", "Id": "24572428", "AcceptedAnswerId": "24573119", "Score": "2", "Title": "C++ inline initialization of a static const char*", "CommentCount": "1", "Body": "<p>Why I cannot initialize a static const char* in the header file?\nIn my code I have in my Class header:</p>\n<pre><code>static const char* xml_ID_TAG;\n</code></pre>\n<p>and in the cpp:</p>\n<pre><code>const char* Class::xml_ID_TAG = \"id\";\n</code></pre>\n<p>The xml_ID_TAG variable contains the attribute string of an XML document.\nSince it's static, const, primitive type (char*), etc... I can't figure out why the compiler forbid to write something like:</p>\n<pre><code>static const char* xml_ID_TAG = \"id\";\n</code></pre>\n<p>I'm using MSVC2013 compiler, giving for the example above the error: \"Error: a member with an in-class initializer must be const\"</p>\n", "Tags": "<c++>", "LastActivityDate": "2014-07-04T11:24:19.093", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "3253359"}, "24573119": {"LastActivityDate": "2014-07-04T11:24:19.093", "CommentCount": "0", "Body": "<p>Generally speaking you must define your static members in precisely one translation unit, and the language helps to enforce this by prohibiting you from writing an initialiser for such a member inside the surrounding class definition:</p>\n<pre><code>struct T\n{\n   static int x = 42;\n   // ^ error: ISO C++ forbids in-class initialization of\n   // non-const static member 'T::x'\n};\n</code></pre>\n<p>However, a special exception is made for constants, for convenience:</p>\n<pre><code>struct T\n{\n   static const int x = 42;\n   // ^ OK\n};\n</code></pre>\n<p>Note that in most cases you still need to <em>define</em> the constant (in your .cpp file would be the best place):</p>\n<pre><code>const int T::x;\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_24572428_24573119_0\"><code>[C++11: 9.4.2/3]:]</code> If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. <em>[ Note:</em> In both these cases, the member may appear in constant expressions. <em>\u2014end note ]</em> The member shall still be defined in a namespace scope if it is <em>odr-used</em> (3.2) in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<hr>\n<p>Now, your member is not an <code>int</code> and even a <code>const char* const</code> is not of an \"integral type\":</p>\n<pre><code>struct T\n{\n   static const char* const str = \"hi\";\n   // ^ error: 'constexpr' needed for in-class initialization of\n   // static data member 'const char* const T::str' of non-integral type\n};\n</code></pre>\n<p>but it <em>is</em> of a \"literal type\"; the upshot for you is that if you write it like this:</p>\n<pre><code>static constexpr const char* const xml_ID_TAG = \"id\";\n//     ^^^^^^^^^             ^^^^^\n</code></pre>\n<p>you should be okay. This probably makes more sense anyway: why would you want to change the pointer?</p>\n</hr></hr>", "CreationDate": "2014-07-04T11:18:20.307", "LastEditDate": "2014-07-04T11:24:19.093", "ParentId": "24572428", "Id": "24573119", "LastEditorUserId": "560648", "PostTypeId": "2", "Score": "10", "OwnerUserId": "560648"}, "24572569": {"LastActivityDate": "2014-07-04T10:45:48.963", "CommentCount": "0", "Body": "<p>\"<em>Since it's [...] const</em>\" - Nope.</p>\n<p>You need <code>const char* const</code> - assuming you're using C++11.</p>\n<p>Otherwise you have to put the definition in the cpp file.</p>\n<p>See: <a href=\"https://stackoverflow.com/questions/3531060/how-to-initialize-a-static-const-member-in-c\">How to initialize a static const member in C++?</a></p>\n", "CreationDate": "2014-07-04T10:45:48.963", "LastEditDate": "2017-05-23T12:00:35.347", "ParentId": "24572428", "Id": "24572569", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "3", "OwnerUserId": "650405"}, "24572621": {"CommentCount": "0", "Body": "<p>Because string literals (eg <code>\"id\"</code>) are stored per file compilation unit.  So if they are in a header file, there's a different instance stored for each source file that includes it.  So your 'initialisation' is trying to store different values in a <code>static</code> variable for each compilation unit that <code>#include</code>s it..</p>\n", "CreationDate": "2014-07-04T10:49:08.477", "ParentId": "24572428", "Id": "24572621", "LastActivityDate": "2014-07-04T10:49:08.477", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1312406"}});