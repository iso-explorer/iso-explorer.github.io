post_cb({"bq_ids": {"n4140": {"so_5684253_5684253_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5368}}, "n3337": {"so_5684253_5684253_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5164}}, "n4659": {"so_5684253_5684253_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 6793}}}, "14003988": {"Id": "14003988", "PostTypeId": "2", "Body": "<p>@Johannes S is correct of course, but I'd like to add clearly (since I faced this), that even for <code>constexpr</code> user defined literals, the <em>parameters</em> are not considered constexpr or compile time constant, for example in the sense that they can not be used as integer constants for templates.</p>\n<p><em>In addition, only things like this will actually give compile-time evaluation:</em> </p>\n<pre><code>inline constexpr long long _xx(unsigned long long v) {\n  return (v &gt; 100 ) ? throw std::exception() : v; \n}\nconstexpr auto a= 150_xx;\n</code></pre>\n<p>So, that will not compile. But this will:</p>\n<pre><code>cout &lt;&lt; 150_xx &lt;&lt; endl;\n</code></pre>\n<p>And the following is not allowed:</p>\n<pre><code>inline constexpr long long _xx(unsigned long long v) {\n  return some_trait&lt;v&gt;::value; \n}\n</code></pre>\n<p>That's annoying, but natural considering that (other) constexpr functions can be called also during execution.</p>\n<p>Only <em>for integer user-defined literals is it possible to force compile-time processing</em>, by using the template form. Examples in my question and self answer: <a href=\"https://stackoverflow.com/a/13869688/1149664\">https://stackoverflow.com/a/13869688/1149664</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-22T15:23:26.057", "Score": "0", "CreationDate": "2012-12-22T15:23:26.057", "ParentId": "5684253", "CommentCount": "0", "OwnerUserId": "1149664", "LastEditDate": "2017-05-23T11:55:14.817"}, "5684253": {"ViewCount": "976", "Body": "<p>I wonder, because predefined literals like <code>ULL</code>, <code>f</code>, etc. are obviously resolved at compile time. The standard (2.14.8 [lex.ext]) doesn't seem to define this, but it seems to tend towards runtime:</p>\n<blockquote>\n<p id=\"so_5684253_5684253_0\">[2.14.8 / 2]<br>\n  A user-defined-literal <strong>is treated as a call to</strong> a literal operator or literal operator template (13.5.8). To\n  determine the form of this call for a given user-defined-literal L with ud-suffix X, the literal-operator-id\n  whose literal suffix identifier is X is looked up in the context of L using the rules for unqualified name\n  lookup (3.4.1). Let S be the set of declarations found by this lookup. S shall not be empty.<br>\n<em>(emphasis mine.)</em></br></br></p>\n</blockquote>\n<p>However, to me this seems to introduce unnecessary runtime-overhead, as literals can only be appended to values that are available at compile-time anyways like <code>13.37f</code> or <code>\"hello\"_x</code> (where <code>_x</code> is a user-defined-literal).<br>\nThen, we got the templated user-defined-literal, that never really gets defined in the standard AFAICS (i.e., no example is given, please prove me wrong). Is that function somehow magically invoked at compile time or is it still runtime?</br></p>\n", "AcceptedAnswerId": "5684273", "Title": "Are user-defined-literals resolved at compile-time or runtime?", "CreationDate": "2011-04-16T03:15:39.277", "Id": "5684253", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-19T15:25:24.930", "LastEditorUserId": "500104", "LastActivityDate": "2012-12-22T15:23:26.057", "Score": "8", "OwnerUserId": "500104", "Tags": "<c++><c++11><user-defined-literals>", "AnswerCount": "2"}, "5684273": {"Id": "5684273", "PostTypeId": "2", "Body": "<p>Yes, you get a function call. But function calls can be compile time constant expressions because of <code>constexpr</code> literal operator functions. </p>\n<p>For an example, see <a href=\"https://stackoverflow.com/questions/537303/binary-literals/538101#538101\">this one</a>. As another example to show the advanced form of <code>constexpr</code> computations allowed by the FDIS, to have compile time base-26 literals you can do</p>\n<pre><code>typedef unsigned long long ull;\n\nconstexpr ull base26(char const *s, ull ps) {\n  return (*s &amp;&amp; !(*s &gt;= 'a' &amp;&amp; *s &lt;= 'z')) ? throw \"bad char!\" :\n    (!*s ? ps : base26(s + 1, (ps * 26ULL) + (*s - 'a')));\n}\n\nconstexpr ull operator \"\" _26(char const *s, std::size_t len) {\n  return base26(s, 0);\n}\n</code></pre>\n<p>Saying <code>\"bcd-\"_26</code> will evaluate a throw-expression, and thereby cause the return value to become non-constant. In turn, it causes any use of <code>\"bcd-\"_26</code> as a constant expression to become ill-formed, and any non-constant use to throw at runtime. The allowed form <code>\"bcd\"_26</code> evaluates to a constant expression of the respective computed value. </p>\n<p>Note that reading from string literals is not explicitly allowed by the FDIS, however it presents no problem and GCC supports this (the character lvalue reference is a constant expression and the character's value is known at compile time). IMO if one squints, one can read the FDIS as if this is allowed to do. </p>\n<blockquote>\n<p id=\"so_5684253_5684273_0\">Then, we got the templated user-defined-literal, that never really gets defined in the standard AFAICS (i.e., no example is given, please prove me wrong)</p>\n</blockquote>\n<p>The treatment of literals as invoking literal operator templates is defined in 2.14.8. You find more examples at 13.5.8 that detail on the literal operator function/function templates itself. </p>\n<blockquote>\n<p id=\"so_5684253_5684273_1\">Is that function somehow magically invoked at compile time or is it still runtime?</p>\n</blockquote>\n<p>The keyword is <em>function invocation substitution</em>. See 7.1.5. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-04-16T12:07:28.197", "Score": "6", "CreationDate": "2011-04-16T03:23:46.850", "ParentId": "5684253", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T10:29:30.073"}});