post_cb({"7319975": {"ParentId": "7319810", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_7319810_7319975_0\">...when the exception handling mechanism, after completing evaluation\n  of the expression to be thrown but before the exception is caught\n  (15.1), calls a user function that exits via an uncaught exception...\n  terminate shall be called.</p>\n</blockquote>\n<p>The exception handling mechanism calls <code>~Catcher()</code>, which doesn't exit via an uncaught exception; hence it doesn't call <code>std::terminate</code>. It doesn't (directly) call <code>thrower()</code>.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "7319975", "Score": "3", "CreationDate": "2011-09-06T12:32:14.170", "LastActivityDate": "2011-09-06T12:32:14.170"}, "7319899": {"ParentId": "7319810", "CommentCount": "0", "Body": "<p>This is perfectly legal code.  You're catching everything that's thrown before it causes problems.\nOnly if you remove the try/catch in ~Catcher, you'd be throwing an exception during unwinding.</p>\n", "OwnerUserId": "930581", "PostTypeId": "2", "Id": "7319899", "Score": "0", "CreationDate": "2011-09-06T12:26:40.710", "LastActivityDate": "2011-09-06T12:26:40.710"}, "7319950": {"ParentId": "7319810", "CommentCount": "0", "Body": "<p>Which function, called by the exception handling mechanism, exits via an\nuncaught exception.  The only function called by the exception handling\nmechanism here is <code>Catcher::~Catcher()</code>, and it exits normally, by\nreaching the end of the function.</p>\n<p>And there is fundamentally no limit to the number of simultaneously\nactive exceptions.  The limit is to the number of exceptions which must\nbe propagated up past a given point.  If <code>Catcher::~Catcher()</code> exited\nvia an exception, we would have two exceptions to propagate up, the one\nwhich triggered the call of the destructor, and the one by which the\ndestructor exited.  As long as the destructor catches all exceptions,\nand doesn't propagate them, there is no problem. </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "7319950", "Score": "3", "CreationDate": "2011-09-06T12:30:54.020", "LastActivityDate": "2011-09-06T12:30:54.020"}, "7319856": {"ParentId": "7319810", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Why should <code>terminate</code> have been called? You have a <code>catch(...)</code> block which catches all exceptions: one that catches the <code>double</code> (the one in <code>main</code>) and one that catches the <code>char const[4]</code> (the one in <code>~Catcher</code>).</p>\n<p>So no functions are \"exiting with an uncaught exception\" because all the exceptions are caught.</p>\n<p>The key words here are \"calls a user function which terminates with an uncaught exception\". This is <strong>not</strong> the same as \"calls a user function which somewhere down the line calls a user function which terminates with an uncaught exception.\" If you call a function and it has a <code>try/catch</code> block in it, and then in that you call some function which terminates with an exception <em>but</em> you catch the exception, <code>terminate</code> is not called.</p>\n<p>tl;dr: The <em>very first call</em> in a call hierarchy originating between the exception evaluation and before the catch must exit with an exception for <code>terminate</code> to be called, <em>not</em> branches below the first call. This makes sense because there's no way you could set up <em>another</em> <code>catch</code> block between when the object being thrown was evaluated and  when it was caught.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2011-09-06T12:37:13.630", "Id": "7319856", "Score": "4", "CreationDate": "2011-09-06T12:23:22.317", "LastActivityDate": "2011-09-06T12:37:13.630"}, "7319810": {"CommentCount": "0", "ViewCount": "227", "CreationDate": "2011-09-06T12:20:11.457", "LastActivityDate": "2011-09-06T12:37:31.987", "Title": "Throwing during unwinding -- why does this example work?", "AcceptedAnswerId": "7320054", "PostTypeId": "1", "Id": "7319810", "Score": "4", "Body": "<p>Consider this:</p>\n<pre><code>void thrower () {\n    throw \"123\";\n}\n\nstruct Catcher {\n    ~ Catcher () {\n        try {thrower ();}\n        catch (...) {}\n    }\n};\n\nint main () {\n    try {\n       Catcher c;\n       throw 1.23;\n    }\n    catch (...) {}\n}\n</code></pre>\n<p>This compiles and runs without calling <code>terminate</code> on gcc 4.3, but <a href=\"http://cs.nyu.edu/courses/summer11/G22.2110-001/documents/c++2003std.pdf\" rel=\"nofollow\">according to the standard</a> (15.5.1)</p>\n<blockquote>\n<p id=\"so_7319810_7319810_0\">...when the exception handling mechanism, after completing evaluation of the expression to be thrown but before the exception is caught (15.1), calls a user function that exits via an uncaught exception... terminate shall be called.</p>\n</blockquote>\n<p>When <code>~Catcher</code> is called after the double has been thrown, this is \"after completing evaluation...before the exception is caught\" and <code>thrower</code> is \"a user function that exits via an uncaught exception\", <em>this satisfies the above condition</em>. Yes, the <code>char*</code> is caught but only <em>after</em> the user function exits.</p>\n<p>Shouldn't <code>terminate</code> have been called?</p>\n<p>To emphasise this:</p>\n<pre><code>void do_throw () {\n    throw \"123\";\n}\n\nvoid thrower () {\n    do_throw ();\n    // Uncaught exception here (A)\n}\n\nstruct Catcher {\n    ~ Catcher () {\n        try {thrower (); /* (B) */}\n        catch (...) {}\n    }\n};\n\nint main () {\n    try {\n       Catcher c;\n       throw 1.23;\n    }\n    catch (...) {}\n}\n</code></pre>\n<p>(A) happens in the context of (B), which already has an exception in progress.</p>\n<p>So, shouldn't <code>terminate</code> have been called? If not, and this is a legal situation in which we can have two simultaneous exceptions, where do we draw the line?</p>\n", "Tags": "<c++><exception><gcc><terminate>", "OwnerUserId": "458742", "AnswerCount": "5"}, "7320054": {"ParentId": "7319810", "CommentCount": "0", "Body": "<p>Different emphasis:</p>\n<blockquote>\n<p id=\"so_7319810_7320054_0\">when <strong>the exception handling mechanism</strong>, after completing evaluation of the expression to be thrown but before the exception is caught (15.1), <strong>calls a user function</strong> that exits via an uncaught exception... terminate shall be called</p>\n</blockquote>\n<p><code>thrower()</code> is a user function that exits via an exception but it is not called by the exception handling mechanism; it is called by another user function (<code>Catcher</code>'s destructor) which itself is called by the exception handling mechanism and this function <em>doesn't</em> exit via an exception.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "7320054", "Score": "3", "CreationDate": "2011-09-06T12:37:31.987", "LastActivityDate": "2011-09-06T12:37:31.987"}, "bq_ids": {"n4140": {"so_7319810_7320054_0": {"section_id": 3382, "quality": 0.6521739130434783, "length": 15}, "so_7319810_7319975_0": {"section_id": 3382, "quality": 0.6521739130434783, "length": 15}, "so_7319810_7319810_0": {"section_id": 3382, "quality": 0.6521739130434783, "length": 15}}, "n3337": {"so_7319810_7320054_0": {"section_id": 3210, "quality": 0.782608695652174, "length": 18}, "so_7319810_7319975_0": {"section_id": 3210, "quality": 0.782608695652174, "length": 18}, "so_7319810_7319810_0": {"section_id": 3210, "quality": 0.782608695652174, "length": 18}}, "n4659": {"so_7319810_7320054_0": {"section_id": 4142, "quality": 0.6521739130434783, "length": 15}, "so_7319810_7319975_0": {"section_id": 4142, "quality": 0.6521739130434783, "length": 15}, "so_7319810_7319810_0": {"section_id": 4142, "quality": 0.6521739130434783, "length": 15}}}});