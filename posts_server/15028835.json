post_cb({"15029228": {"ParentId": "15028835", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_15028835_15029228_0\">does an operator overload defined inside a class have priority over an operator overload defined globally?</p>\n</blockquote>\n<p><strong>No</strong>. Per Paragraph 13.3.1/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15028835_15029228_1\"><strong>The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list</strong>. So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the implicit object parameter, which represents the object for which the member function has been called. For the purposes of overload resolution, both static and non-static member functions have an implicit object parameter, but constructors do not.</p>\n</blockquote>\n<p>Moreover, nowhere in the Standard member functions are mentioned to be preferred to non-member functions, or vice-versa.</p>\n<blockquote>\n<p id=\"so_15028835_15029228_2\">is this kind of problem something covered by the standard?</p>\n</blockquote>\n<p>Yes. The reason why the global operator is (<em>should be!</em>) selected is that it is a <em>more specialized</em> template than the function template defined inside your class: after template argument deduction, both <code>vectorN&lt;U, N&gt; const&amp;</code> and <code>matrix_t&lt;T&gt; const&amp;</code> can be made to match <code>matrix_t&lt;T&gt; const&amp; r</code>, but the former is more specialized than the latter and, therefore, it is preferred.</p>\n<p>Per Paragraph 13.3.3/1:</p>\n<blockquote>\n<p id=\"so_15028835_15029228_3\">Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then:</p>\n<p id=\"so_15028835_15029228_4\">[...]</p>\n<p id=\"so_15028835_15029228_5\">\u2014 <strong>F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.6.2.</strong></p>\n</blockquote>\n<p>Therefore:</p>\n<blockquote>\n<p id=\"so_15028835_15029228_6\">So it is like the matrix_t::operator*(U const&amp;) is catching all template specialization lookups</p>\n</blockquote>\n<p>This behavior qualifies as a <strong>bug</strong>. However, note that these are not <em>specializations</em>, but <em>overloads</em>.</p>\n<p>Finally:</p>\n<blockquote>\n<p id=\"so_15028835_15029228_7\">what is the qualification of <code>operator * (matrix_t&lt;T&gt; const&amp;, vectorN&lt;U, N&gt; const&amp;)</code>?</p>\n</blockquote>\n<p>I guess you could say it is a (global) operator overload template. It is <em>not</em> a specialization, because template function specializations have a different syntax. Therefore, there is no primary template it is specializing. It is just a function template that, once instantiated, generates an <em>overload</em> of the multiplicative operator.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-02-22T17:06:40.773", "Id": "15029228", "Score": "2", "CreationDate": "2013-02-22T16:53:02.273", "LastActivityDate": "2013-02-22T17:06:40.773"}, "15028835": {"CommentCount": "0", "AcceptedAnswerId": "15029228", "CreationDate": "2013-02-22T16:31:13.030", "LastActivityDate": "2013-02-22T17:06:40.773", "PostTypeId": "1", "ViewCount": "760", "FavoriteCount": "2", "Title": "Template binary operator overload resolution", "Id": "15028835", "Score": "4", "Body": "<p>I encountered an issue using Apple LLVM compiler (shipped with XCode 4.5.2), while running correctly with GCC. More importantly than a debate on compiler issues (I think GCC is right though), this raises the question about the resolution order of template specialization when overloaded operators are concerned [1]. </p>\n<p>Consider a simple matrix class <code>template &lt;class T&gt; class matrix_t</code>, with a traits defining the result type of multiplication (with scalar, matrices or vectors). This would be something like the following code:</p>\n<pre><code>template &lt;class T, class U, class Enable = void&gt;\nstruct matrix_multiplication_traits {\n  //typedef typename boost::numeric::conversion_traits&lt;T,U&gt;::supertype type;\n  typedef double type;\n};\n\ntemplate &lt;class T, int N&gt;\nstruct vectorN {\n  std::vector&lt;T&gt; vect;\n  vectorN() : vect(N) { for(int i = 0; i &lt; N; i++) vect[i] = i; }\n};\n\n\ntemplate &lt;class T&gt;\nclass matrix_t {\n  std::vector&lt;T&gt; vec;\npublic:\n  matrix_t&lt;T&gt; operator*(matrix_t&lt;T&gt; const&amp; r) const {\n    std::cout &lt;&lt; \"this_type operator*(this_type const&amp; r) const\" &lt;&lt; std::endl;\n    return r;\n  }\n\n  template &lt;class U&gt;\n  matrix_t&lt;typename matrix_multiplication_traits&lt;T, U&gt;::type&gt;\n  operator*(U const &amp;u) const {\n    std::cout &lt;&lt; \"different_type operator*(U const &amp;u) const\" &lt;&lt; std::endl;\n    return matrix_t&lt;typename matrix_multiplication_traits&lt;T, U&gt;::type&gt;();\n  }\n\n};\n</code></pre>\n<p>Consider also a specialization of the <code>operator*</code> for the <code>vectorN</code>:</p>\n<pre><code>template &lt;class T, class U, int N&gt;\n//vectorN&lt;typename matrix_multiplication_traits&lt;T,U&gt;::type, N&gt;\nvectorN&lt;double, N&gt;\noperator*(matrix_t&lt;T&gt; const&amp;m, vectorN&lt;U, N&gt; const&amp;v)\n{\n  std::cout &lt;&lt; \"vectorN operator*(matrix, vectorN)\" &lt;&lt; std::endl;\n  //return vectorN&lt;typename matrix_multiplication_traits&lt;T,U&gt;::type, N&gt;();\n  return vectorN&lt;double, N&gt;();\n}\n</code></pre>\n<p>and consider a simple test program:</p>\n<pre><code>int main(int argc, const char * argv[])\n{\n  matrix_t&lt;double&gt; test;\n  vectorN&lt;double, 10&gt; my_vector;\n  test * my_vector; // problematic line\n  return 0;\n}\n</code></pre>\n<p>The \"problematic line\" runs the globally defined <code>operator*(matrix_t&lt;T&gt; const&amp;, vectorN&lt;U, N&gt; const&amp;)</code> on GCC and <code>template &lt;class U&gt; matrix_t&lt;T&gt;::operator*(U const&amp;) const</code> on LLVM. So it is like the <code>matrix_t&lt;T&gt;::operator*(U const&amp;)</code> is catching all template specialization lookups. A simple \"fix\" would be to move the global <code>operator*</code> into the matrix class. </p>\n<p>I first thought it was a problem in the traits class, that was maybe too complex or erroneous (SFINAE). But even simplifying the traits or completely disabling it (as in the paste code) produces the error. I then thought it was an order problem (like in Herb Shutter's article), but moving the global <code>operator*</code> between <code>matrix_t</code> declaration and definition does not change things.</p>\n<h1>Here is the question</h1>\n<p>Of course, the real problem is that <code>template &lt;class U&gt; matrix_t::operator*(U const&amp;) const</code> is too general, but:</p>\n<ul>\n<li>is this kind of problem something covered by the standard?</li>\n<li>does an operator overload defined inside a class have priority over an operator overload defined globally?</li>\n<li>(more like a vocabulary issue) what is the qualification of <code>operator*(matrix_t&lt;T&gt; const&amp;, vectorN&lt;U, N&gt; const&amp;)</code>? template overload operator specialization? Is this more a template specialization or an overloaded function? What is the base definition for that? Since it is intrinsically an overloaded operator, I am a bit lost.</li>\n</ul>\n<p>[1] I have read Herb Shutter advices on template specialization order.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "1617295", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_15028835_15029228_1": {"section_id": 566, "quality": 0.9423076923076923, "length": 49}, "so_15028835_15029228_5": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_15028835_15029228_3": {"section_id": 603, "quality": 0.85, "length": 17}}, "n3337": {"so_15028835_15029228_1": {"section_id": 557, "quality": 0.9423076923076923, "length": 49}, "so_15028835_15029228_5": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_15028835_15029228_3": {"section_id": 593, "quality": 0.85, "length": 17}}, "n4659": {"so_15028835_15029228_1": {"section_id": 589, "quality": 0.9423076923076923, "length": 49}, "so_15028835_15029228_3": {"section_id": 629, "quality": 0.85, "length": 17}, "so_15028835_15029228_5": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}}}});