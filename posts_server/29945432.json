post_cb({"29945584": {"ParentId": "29945432", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I don't think this is possible. From standard draft N4296:</p>\n<p><strong>\u00a7 14.5.4/1 [temp.friend]</strong></p>\n<blockquote>\n<p id=\"so_29945432_29945584_0\">A friend of a class or class template can be a function template or class template, a specialization of a\n  function template or class template, or a non-template function or class.</p>\n</blockquote>\n<p>This doesn't include alias templates, so the standard doesn't support what you want to do. This is perhaps due to the following excerpt (emphasis mine):</p>\n<p><strong>\u00a7 14.5.7/1 [temp.alias]</strong></p>\n<blockquote>\n<p id=\"so_29945432_29945584_1\">A template-declaration in which the declaration is an alias-declaration (Clause 7) declares the identifier to\n  be a alias template. <strong>An alias template is a name for a family of types</strong>.</p>\n</blockquote>\n<p>An alias template names a separate family of types, so even if there were some syntax which made sense for this, you would be friending the alias template rather than the template which is being aliased.</p>\n<p>For example, GCC will compile this (Clang won't), but you won't actually be able to use the friendship in any reasonable way:</p>\n<pre><code>template &lt;bool B&gt;\nusing MyTFoo = typename tTRAIT::template TFoo&lt;B&gt;;\n\ntemplate &lt;bool&gt; friend class MyTFoo; \n</code></pre>\n<p>Another example of how an alias template is not the same as the aliased template:</p>\n<pre><code>template &lt;template &lt;typename...&gt; class A, template &lt;typename...&gt; class B&gt;\nstruct is_same_template : std::false_type{};\n\ntemplate &lt;template &lt;typename...&gt; class A&gt;\nstruct is_same_template&lt;A,A&gt; : std::true_type{};\n\ntemplate &lt;typename T&gt; using myvec = std::vector&lt;T&gt;;\n\n//this fails\nstatic_assert(is_same_template&lt;myvec,std::vector&gt;::value, \"wat\");\n</code></pre>\n<p>Your manual friending with explicit instantiation will work, because the alias template will collapse down to exactly the same type as the aliased template. An analogous example:</p>\n<pre><code>//this passes!\nstatic_assert(std::is_same&lt;myvec&lt;int&gt;,std::vector&lt;int&gt;&gt;::value, \"wat\");\n</code></pre>\n", "OwnerUserId": "496161", "LastEditorUserId": "496161", "LastEditDate": "2015-04-29T18:09:23.987", "Id": "29945584", "Score": "4", "CreationDate": "2015-04-29T13:43:22.800", "LastActivityDate": "2015-04-29T18:09:23.987"}, "29948615": {"ParentId": "29945432", "CommentCount": "2", "Body": "<p>I could go I step further with Clang 3.4.1 in std=c++11 mode.</p>\n<p>This compiles without error :</p>\n<p>template </p>\n<pre><code>struct SBar\n    {\nprivate:\n    int j;\npublic:\n        template &lt;bool bBOOL&gt;\n        friend struct tTRAIT::TFoo;\n        void setJ(int j) {\n            this-&gt;j = j;\n        }\n};\n</code></pre>\n<p>But ... I get this warning : <em>warning: dependent nested name specifier 'tTRAIT::' for friend template declaration is not supported; ignoring this friend declaration [-Wunsupported-friend] : friend struct tTRAIT::TFoo;</em></p>\n<p>and I can confirm that the <code>SFoo</code> classes are not friend (the reason for <code>private j</code> ...)</p>\n<p>The only way I could have it all to compile and run is :</p>\n<pre><code>struct SBar\n    {\nprivate:\n    int j;\npublic:\n        template &lt;bool bBOOL&gt;\n        friend struct sFoo;\n        void setJ(int j) {\n            this-&gt;j = j;\n        }\n};\n</code></pre>\n<p>Fine, <code>SFoo</code> classes <strong>are</strong> friends, but it somewhat defeats OP requirement ( template type member of [template parameter]) ...</p>\n<p>I currently have no access to a recent gcc but I think we are here on the edge of how compilers interprets the standard. I read the chapter referenced by TartanLlama, but could not make sure if this was intended or not. Maybe my first try would be accepted by gcc ...</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "29948615", "Score": "2", "CreationDate": "2015-04-29T15:46:49.110", "LastActivityDate": "2015-04-29T15:46:49.110"}, "bq_ids": {"n4140": {"so_29945432_29945584_0": {"section_id": 126, "quality": 1.0, "length": 17}, "so_29945432_29945584_1": {"section_id": 165, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_29945432_29945584_0": {"section_id": 120, "quality": 1.0, "length": 17}, "so_29945432_29945584_1": {"section_id": 159, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_29945432_29945584_0": {"section_id": 131, "quality": 1.0, "length": 17}, "so_29945432_29945584_1": {"section_id": 169, "quality": 0.9230769230769231, "length": 12}}}, "29945432": {"CommentCount": "0", "AcceptedAnswerId": "29945584", "PostTypeId": "1", "LastEditorUserId": "3969962", "CreationDate": "2015-04-29T13:36:28.367", "LastActivityDate": "2015-04-29T18:09:23.987", "LastEditDate": "2015-04-29T16:31:00.983", "ViewCount": "343", "FavoriteCount": "0", "Title": "C++: Correct syntax for friending a template type member of template parameter?", "Id": "29945432", "Score": "10", "Body": "<p>I have a class that takes a template type parameter (tTRAIT). I want to friend a template <em>type</em> <em>member</em> <em>alias</em> of tTRAIT, but I can't figure out the syntax. (Is this even possible?).</p>\n<pre><code>template &lt;bool bBOOL&gt;\nstruct SFoo {};\n\nstruct STrait\n    {\n        template &lt;bool bBOOL&gt;\n        using TFoo = SFoo&lt;bBOOL&gt;;\n    };\n\ntemplate &lt;typename tTRAIT&gt;\nstruct SBar\n    {\n        template &lt;bool bBOOL&gt;\n        friend typename tTRAIT::template TFoo&lt;bBOOL&gt;;\n    };\n\nSBar&lt;STrait&gt; bar;\n</code></pre>\n<p>Clang's error (on the <code>friend</code> line) is:</p>\n<pre><code>error: friend type templates must use an elaborated type\n</code></pre>\n<p>I have tried exhausting all possible combinations I can think of:</p>\n<pre><code>friend tTRAIT::TFoo;\nfriend tTRAIT::template TFoo;\nfriend typename tTRAIT::TFoo;\nfriend typename tTRAIT::template TFoo;\ntemplate &lt;bool bBOOL&gt; friend tTRAIT::TFoo;\ntemplate &lt;bool bBOOL&gt; friend tTRAIT::TFoo&lt;bBOOL&gt;;\ntemplate &lt;bool bBOOL&gt; friend tTRAIT::template TFoo;\ntemplate &lt;bool bBOOL&gt; friend tTRAIT::template TFoo&lt;bBOOL&gt;;\ntemplate &lt;bool bBOOL&gt; friend typename tTRAIT::TFoo;\ntemplate &lt;bool bBOOL&gt; friend typename tTRAIT::TFoo&lt;bBOOL&gt;;\ntemplate &lt;bool bBOOL&gt; friend typename tTRAIT::template TFoo;\ntemplate &lt;bool bBOOL&gt; friend typename tTRAIT::template TFoo&lt;bBOOL&gt;;\n</code></pre>\n<p>I have also tried using <code>using</code>, but it doesn't seem to help.</p>\n<p>As an ugly hack (which only works for bool parameters), I can get it to work by friending each specialization manually.</p>\n<pre><code>friend typename tTRAIT::template TFoo&lt;false&gt;;\nfriend typename tTRAIT::template TFoo&lt;true &gt;;\n</code></pre>\n<p>But that's yucky.</p>\n<p>Does anyone know how to do this, or if this can be done?</p>\n", "Tags": "<c++><templates><c++11><using><friend>", "OwnerUserId": "3969962", "AnswerCount": "2"}});