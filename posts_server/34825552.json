post_cb({"bq_ids": {"n4140": {"so_34825552_34829349_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 1243}}, "n3337": {"so_34825552_34829349_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 1241}}, "n4659": {"so_34825552_34829349_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 1331}}}, "34825552": {"ViewCount": "286", "Body": "<p>Isn't it better to pass function objects into the STL algorithms by forwarding reference rather then by value? It would allow one to utilize ref-qualifiers of <code>operator ()</code> of function objects passed.</p>\n<p>There are a couple of questions about <code>std::for_each</code> algorithm on SO (<a href=\"https://stackoverflow.com/questions/18418470/\">1</a>, <a href=\"https://stackoverflow.com/questions/2048967/\">2</a>), which are considering a problem with changing of observable state of function object passed to <code>std::for_each</code>. </p>\n<p>Passing functional objects by lvalue leference would solve the problem as a side effect even for those of algorithms, which can't return functional object (due to they should return, say, output iterator last value or something else).</p>\n<p>For example the algorithm <code>std::for_each</code> can be changed from (copied from libc++):</p>\n<pre><code>template&lt;typename _InputIterator, typename _Function&gt;\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n  for (; __first != __last; ++__first)\n    __f(*__first);\n  return _GLIBCXX_MOVE(__f);\n}\n</code></pre>\n<p>to:</p>\n<pre><code>template&lt;typename _InputIterator, typename _Function&gt;\n_Function &amp;&amp;\nfor_each(_InputIterator __first, _InputIterator __last, _Function &amp;&amp; __f)\n{\n  for (; __first != __last; ++__first)\n    _GLIBCXX_FORWARD(_Function, __f)(*__first);\n  return _GLIBCXX_FORWARD(_Function, __f);\n}\n</code></pre>\n<p>or (if such breaking changing is allowed) <code>std::for_each</code> can return <code>void</code> without loss of functionality. Similar changes (change from passing by value to passing by forwarding reference and change all invocations to calling <code>std::forward</code>ed function object instead of just non-const-lvalue) are possible for all the rest <code>&lt;numeric&gt;</code>'s and <code>&lt;algorithm&gt;</code>'s algorithms.</p>\n<p>I know a partial workaround: is to pass object, wrapped by <code>std::ref</code> (or <code>std::cref</code> to enforce <code>const this</code>), but there are issues with forwarding <code>operator ()</code> cv-ref-qualifiers from wrapped functional object to wrapper's <code>operator ()</code>.</p>\n<p>Another workaround is to explicitly specify reference argument type into alorithm's template parameter list, but currently <code>Function</code> parameter sadly always follows the <code>InputIterator</code> and <code>OutputIterator</code> parameters in the list:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;utility&gt;\n\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    std::list&lt; int &gt; l{{1, 2, 3, 4}};\n    std::copy_n(std::cbegin(l), l.size(), std::ostream_iterator&lt; int &gt;(std::cout, \" \"));\n    std::cout &lt;&lt; std::endl;\n    struct F\n    {\n        int state;\n        void operator () (int i) { state += i; }\n    } f{0};\n    using I = std::list&lt; int &gt;::const_iterator;\n    std::for_each&lt; I, F &amp;&amp; &gt;(std::cbegin(l), std::cend(l), std::move(f));\n    std::cout &lt;&lt; f.state &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>By the way the change would allow to pass a non-copyable and/or non-moveable function objects to the algorithms w/o wrapping them.</p>\n", "AcceptedAnswerId": "34829349", "Title": "Passing function objects into std algorithms by reference", "CreationDate": "2016-01-16T09:42:09.347", "Id": "34825552", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:45:43.277", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-16T16:36:18.620", "Score": "7", "OwnerUserId": "1430927", "Tags": "<c++><algorithm><c++11><stl><c++14>", "AnswerCount": "1"}, "34829349": {"Id": "34829349", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34825552_34829349_0\">Isn't it better to pass function objects into the STL algorithms by\n  forwarding reference rather then by value?</p>\n</blockquote>\n<p>Yes, it would be better.  And it would be better if there were a requirement that the functor need not be <code>CopyConstructible</code>, <code>CopyAssignable</code>, <code>MoveConstructible</code> or <code>MoveAssignable</code>.  However the standard specifically says in 25.1:</p>\n<blockquote>\n<p id=\"so_34825552_34829349_1\"><em>Note:</em> Unless otherwise specified, algorithms that take function\n  objects as arguments are permitted to copy those function objects\n  freely. Programmers for whom object identity is important should\n  consider using a wrapper class that points to a noncopied\n  implementation object such as <code>reference_wrapper&lt;T&gt;</code> (20.9.4), or some\n  equivalent solution. <em>\u2014 end note</em>]</p>\n</blockquote>\n<p>This issue was considered all the way back in 1998 as <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#92\" rel=\"noreferrer\">LWG 92</a>.  And at that time the Note I quote above was added (the Note has since been modified as <code>reference_wrapper&lt;T&gt;</code> didn't exist at the time).</p>\n<p>This was a good resolution for vendors of the std::lib, and a good resolution for members of the committee who had the job of fixing the specification, but not so much for people such as yourself wanting to use stateful functors.</p>\n<p>And of course, at that time, forwarding references weren't available as a possible solution.  Also at that time, it was common for std::implementations to pass the functor around by value <em>within</em> an algorithm, which would further destroy its state (as demonstrated in the description of <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#92\" rel=\"noreferrer\">LWG 92</a>.</p>\n<p>You have correctly touched upon all of the points connected to this issue:</p>\n<ul>\n<li><p>Clients can use <code>std::ref</code> instead, but this won't respect reference-qualified functors.</p></li>\n<li><p>Clients can explicitly specify functor reference parameters, but this won't prohibit implementations from copying the functor <em>within</em> the algorithm.</p></li>\n<li><p>Explicitly specifying functor reference parameters is extremely inconvenient for the client since they are always ordered last in the template parameter list.</p></li>\n</ul>\n<p>Fwiw, libc++ is the only std::implementation that was written which forbade itself from internally copying functors.  I.e. if you code up the <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#92\" rel=\"noreferrer\">LWG 92</a> example:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;numeric&gt;\n\ntemplate &lt;class C&gt;\nvoid\ndisplay(const C&amp; c)\n{\n    std::cout &lt;&lt; '{';\n    if (!c.empty())\n    {\n        auto i = c.begin();\n        std::cout &lt;&lt; *i;\n        for (++i; i != c.end(); ++i)\n            std::cout &lt;&lt; \", \" &lt;&lt; *i;\n    }\n    std::cout &lt;&lt; '}' &lt;&lt; '\\n';\n}\n\nclass Nth {    // function object that returns true for the nth element \n  private: \n    int nth;     // element to return true for \n    int count;   // element counter \n  public: \n    Nth (int n) : nth(n), count(0) { \n    } \n    bool operator() (int) { \n        return ++count == nth; \n    } \n};\n\nint\nmain()\n{\n    std::list&lt;int&gt; coll(10);\n    std::iota(coll.begin(), coll.end(), 0);\n    display(coll);\n    auto pos = std::remove_if(coll.begin(), coll.end(), Nth{3});\n    coll.erase(pos, coll.end());\n    display(coll);\n}\n</code></pre>\n<p>The results today are:</p>\n<p><strong>libc++</strong></p>\n<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n{0, 1, 3, 4, 5, 6, 7, 8, 9}\n</code></pre>\n<p><strong>g++</strong></p>\n<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n{0, 1, 3, 4, 6, 7, 8, 9}\n</code></pre>\n<p><strong>VS-2015</strong></p>\n<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n{0, 1, 3, 4, 6, 7, 8, 9}\n</code></pre>\n<p>g++'s libstdc++ and VS-2015 are <em>still</em> copying <code>Nth</code> internal to <code>remove_if</code> just as described 18 years ago by Nico Josuttis.</p>\n<p>Changing the code to:</p>\n<pre><code>    Nth pred{3};\n    auto pos = std::remove_if(coll.begin(), coll.end(), std::ref(pred));\n</code></pre>\n<p>does portably change the results to:</p>\n<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n{0, 1, 3, 4, 5, 6, 7, 8, 9}\n</code></pre>\n<p>Imho, this is just a run-time error waiting to happen to programmers not familiar with the long history of the std::lib.</p>\n", "LastActivityDate": "2016-01-16T16:36:18.620", "CommentCount": "0", "CreationDate": "2016-01-16T16:36:18.620", "ParentId": "34825552", "Score": "8", "OwnerUserId": "576911"}});