post_cb({"bq_ids": {"n4140": {"so_11936730_11936784_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 451}, "so_11936730_11936784_2": {"length": 18, "quality": 0.9, "section_id": 466}, "so_11936730_11936784_3": {"length": 11, "quality": 0.8461538461538461, "section_id": 467}, "so_11936730_11936784_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 456}}, "n3337": {"so_11936730_11936784_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 447}, "so_11936730_11936784_2": {"length": 18, "quality": 0.9, "section_id": 457}, "so_11936730_11936784_3": {"length": 11, "quality": 0.8461538461538461, "section_id": 458}, "so_11936730_11936784_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 442}}, "n4659": {"so_11936730_11936784_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 479}, "so_11936730_11936784_2": {"length": 18, "quality": 0.9, "section_id": 489}, "so_11936730_11936784_3": {"length": 11, "quality": 0.8461538461538461, "section_id": 490}, "so_11936730_11936784_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 474}}}, "11936730": {"ViewCount": "178", "Body": "<p>In C++, if I define a copy constructor and operator= that take a non-const reference to the class, is the compiler supposed to still supply default versions for const reference?</p>\n<pre><code>struct Test {\n  Test(Test &amp;rhs);\n  Test &amp;operator=(Test &amp;rhs);\n\nprivate:\n  // Do I still need to declare these to avoid automatic definitions?\n  Test(const Test &amp;rhs);\n  Test &amp;operator=(const Test &amp;rhs);\n};\n</code></pre>\n", "AcceptedAnswerId": "11936784", "Title": "Do I still get default copy constructor and operator= if I define ones with non-const arguments?", "CreationDate": "2012-08-13T14:48:01.867", "Id": "11936730", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-08-13T15:02:57.423", "Score": "7", "OwnerUserId": "115751", "Tags": "<c++><const><language-lawyer><default-copy-constructor>", "AnswerCount": "2"}, "11936940": {"Id": "11936940", "PostTypeId": "2", "Body": "<p>No, once you declare your own copy constructor or copy assignment operator (whether or not it uses the canonical <code>const</code>ness) the compiler won't do it for you anymore.</p>\n<p>But doing this by non-const reference is pretty much a textbook example of violating the principle of least surprise. Everyone expects that const objects can be assigned from and that the right hand side won't be mutated. The first isn't so bad as the compiler will catch it but the second could cause a variety of hard-to-spot bugs.</p>\n<p>If you're trying to implement move semantics and you can't use C++11, I would suggest creating a special move method and just not allowing \"move\" construction at all. If you can use C++11 then use the builtin rvalue references.</p>\n", "LastActivityDate": "2012-08-13T14:59:07.100", "CommentCount": "0", "CreationDate": "2012-08-13T14:59:07.100", "ParentId": "11936730", "Score": "1", "OwnerUserId": "251738"}, "11936784": {"Id": "11936784", "PostTypeId": "2", "Body": "<p>No, if you define a copy constructor and assignment operator, the compiler will not implicitly declare or define it's own. Note that the definition of <em>copy-constructor</em> allows for the argument to be taken by either const or non-const reference, so your constructor is indeed a <em>copy-constructor</em>. Similarly for <code>operator=</code></p>\n<p>[<em>Omitting a big part of the details, in particular under what circumstances the</em> implicitly declared <em>special member functions will also be</em> implicitly defined]</p>\n<blockquote>\n<p id=\"so_11936730_11936784_0\">12.8 [class.copy]/2 A non-template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n<p id=\"so_11936730_11936784_1\">12.8 [class.copy]/7 If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n<p id=\"so_11936730_11936784_2\">12.8 [class.copy]/17 A user-declared copy assignment operator X::operator= is a non-static non-template member function of class X with exactly one parameter of type X, X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;.</p>\n<p id=\"so_11936730_11936784_3\">12.8 [class.copy]/18 If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly.</p>\n</blockquote>\n", "LastEditorUserId": "36565", "LastActivityDate": "2012-08-13T15:02:57.423", "Score": "7", "CreationDate": "2012-08-13T14:50:41.640", "ParentId": "11936730", "CommentCount": "1", "OwnerUserId": "36565", "LastEditDate": "2012-08-13T15:02:57.423"}});