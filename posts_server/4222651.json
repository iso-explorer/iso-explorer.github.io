post_cb({"4222901": {"Id": "4222901", "PostTypeId": "2", "Body": "<p>C++ started out as an extension of C.</p>\n<p>In C class names are not full-fledged typenames. So in C, if you write</p>\n<pre><code>struct Blah\n{\n    int x;\n};\n</code></pre>\n<p>then to declare a variable of this class, in C you have to write</p>\n<pre><code>struct Blah myBlahObject;\n</code></pre>\n<p>In C++ the class name is a full-fledge typename, so you can just write</p>\n<pre><code>Blah myBlahObject;\n</code></pre>\n<p>But mainly for compatibility with C, C++ retains the C-style declaration syntax, and generalizes it to also work with the C++ <code>class</code> keyword.</p>\n<p>And that means that in C++ you <em>can</em> write e.g.</p>\n<pre><code>class NeverSeenBefore* p;\n</code></pre>\n<p>to declare a pointer variable <code>p</code> of type <code>NeverSeenBefore*</code>. Where <code>NeverSeenBefore</code> has not been declared anywhere yet. It's just an <em>incomplete type</em>, and use of the <code>class</code> (or <code>struct</code>) keyword informs the compiler, as in C, that there is such a type, even though it's not yet been declared.</p>\n<p>C++ has a built in incomplete type, called <code>void</code>  --  and you get the same kind of error message (from a good compiler) if you try to declare a <code>void</code> variable.</p>\n<p>The main difference between <code>void</code> and other incomplete types is that <code>void</code> can not be completed.</p>\n<p>By the way, the C technique for obtaining a full fledged typename is to use <code>typedef</code>. Since class names are full fledged typenames in C++, such <code>typedef</code> is not necessary in C++. So, when you see C++ code where a <code>typedef</code> is provided for a class <em>instead</em> of just naming the class, then you know that a C programmer has been there  \u2013 or a person taught by a C programmer (or recursively, taught by a person taught by a C programmer, so on).</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2010-11-19T07:14:42.693", "Score": "3", "CreationDate": "2010-11-19T07:14:42.693", "ParentId": "4222651", "CommentCount": "0", "OwnerUserId": "464581"}, "4223081": {"Id": "4223081", "PostTypeId": "2", "Body": "<p>This is called an elborated type specifier and is useful in cases such as below:</p>\n<blockquote>\n<p id=\"so_4222651_4223081_0\">$9.1/3 - \"An elaborated-type-specifier\n  (7.1.5.3) can also be used as a\n  type-specifier as part of a\n  declaration. It differs from a class\n  declaration in that if a class of the\n  elaborated name is in scope the\n  elaborated name will refer to it.\"</p>\n</blockquote>\n<pre><code>int bad;\n\nclass bad{};\n\nint main(){\n   //bad b;\n   class bad b;    // Elaborated type specifier\n}\n</code></pre>\n<p>You should now be able to undersand the difference between <code>class Z z</code> and <code>Z z</code>;</p>\n", "LastActivityDate": "2010-11-19T07:54:00.127", "Score": "4", "CreationDate": "2010-11-19T07:54:00.127", "ParentId": "4222651", "CommentCount": "0", "OwnerUserId": "418110"}, "4222676": {"Id": "4222676", "PostTypeId": "2", "Body": "<p>AFAIK</p>\n<pre><code>class X x;\n</code></pre>\n<p>is equivalent to </p>\n<pre><code>X x;\n</code></pre>\n<p>(<em>EDIT: for those nitpickers: at least, in your case, when X is a previously defined class and there is no other variable named X in the same scope</em>).</p>\n<p>In plain-old C, whenever you define a <code>struct</code> without a <code>typedef</code>, you have explicitly use the <code>struct</code> keyword when creating variables. In C++, one can omit the <code>struct</code> keyword, but you also can write <code>struct X x;</code> if you prefer that. And since the only difference between <code>class</code> and <code>struct</code> in C++ is the default visibility, one can conclude that it is also legal to write  <code>class X x;</code></p>\n<p><strong>Answer to your edit:</strong></p>\n<pre><code> class Z;\n</code></pre>\n<p>is a forward declaration (often used in header files where you don't want to <code>#include \"Z.hpp\"</code>). This is also called an <em>incomplete type declaration</em>. It allows <em>pointers</em> to Z to be declared, for example</p>\n<pre><code> class Z *z;\n</code></pre>\n<p>is legal code, even when the compiler has not seen any class body declaration of Z. What is not allowed is to create an instance of z like <code>class Z z;</code> as long as Z is incomplete from the compiler's view.</p>\n<p>The code <code>Z z;</code>, however cannot be interpreted as a forward declaration by the compiler (not even as a disallowed forward declaration). It just shows up as \"Z is undefined\".</p>\n", "LastEditorUserId": "220984", "LastActivityDate": "2010-11-19T16:21:58.457", "Score": "3", "CreationDate": "2010-11-19T06:34:33.680", "ParentId": "4222651", "CommentCount": "7", "LastEditDate": "2010-11-19T16:21:58.457", "OwnerUserId": "220984"}, "4222651": {"ViewCount": "260", "Body": "<p>Can any one explain \"class X x;\" what actually it mean ...in the program...Please give me some example also?\nEx:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass X {\n    public:\n        X() {}\n};\n\nclass Y {\n    public:\n        Y() {}\n};\n\nint main()\n {\n    class X x; //what is this? explain it\n    class Y y; //what is this? explain it\n    class Z z; //what is this? explain it    //error\n    return 0;\n  }\n</code></pre>\n<p>Edited: May i know the exact difference between \"Class Z z\" and \"Z z\".Because While \ncompiling this program in 2 ways</p>\n<pre><code>  class Z Z;   //here iam getting as Error: error: incomplete type is not allowed\n  Z z; //error: identifier \"Z\" is undefined\n</code></pre>\n<p>Since iam asking the exact difference.</p>\n", "AcceptedAnswerId": "4222676", "Title": "C++ syntax question, use of the class keyword", "CreationDate": "2010-11-19T06:30:18.580", "Id": "4222651", "CommentCount": "2", "LastEditDate": "2010-11-19T09:24:59.467", "PostTypeId": "1", "OwnerDisplayName": "BE Student", "LastEditorUserId": "418110", "LastActivityDate": "2010-11-19T16:21:58.457", "Score": "0", "Tags": "<c++>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_4222651_4223081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5858}}, "n3337": {"so_4222651_4223081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5628}}, "n4659": {"so_4222651_4223081_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7337}}}, "4222683": {"Id": "4222683", "PostTypeId": "2", "Body": "<p><code>class X x;</code> instantiates an object of type <code>class X</code> on the stack that is named <code>x</code>. Looking at your definition of <code>X</code> there are no methods or fields, so you really can't do much with it.</p>\n<p>Do you know what classes are in c++?</p>\n", "LastActivityDate": "2010-11-19T06:36:06.390", "Score": "1", "CreationDate": "2010-11-19T06:36:06.390", "ParentId": "4222651", "CommentCount": "0", "OwnerUserId": "47453"}, "4222844": {"Id": "4222844", "PostTypeId": "2", "Body": "<p>As per your new edit,</p>\n<p><code>class Z z;</code> when the compiler encounter this, it identifies that <code>Z</code> is a class since you specified it. But it cannot find the declaration of the <code>class Z</code>. Hence it is showing <code>error: incomplete type is not allowed</code>.</p>\n<p>Now, when the compiler encounters <code>Z z;</code> it will not have any idea about what <code>Z</code> is since you didn't specify it anywhere. So it reports <code>error: identifier \"Z\" is undefined</code>.</p>\n", "LastActivityDate": "2010-11-19T07:02:31.553", "Score": "0", "CreationDate": "2010-11-19T07:02:31.553", "ParentId": "4222651", "CommentCount": "0", "OwnerUserId": "249490"}, "4222711": {"Id": "4222711", "PostTypeId": "2", "Body": "<p>When declaring an instance of a class, the <code>class</code> keyword is optional.</p>\n", "LastActivityDate": "2010-11-19T06:39:59.090", "Score": "0", "CreationDate": "2010-11-19T06:39:59.090", "ParentId": "4222651", "CommentCount": "0", "OwnerUserId": "86436"}});