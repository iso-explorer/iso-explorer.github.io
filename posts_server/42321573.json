post_cb({"42321690": {"ParentId": "42321573", "CommentCount": "0", "CreationDate": "2017-02-18T23:03:42.123", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42321690", "Score": "16", "Body": "<p>This is actually quite tricky. The rule you're running afoul of is in [dcl.spec.auto]:</p>\n<blockquote>\n<p id=\"so_42321573_42321690_0\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression, the program is ill-formed.</p>\n</blockquote>\n<p>That is what's going wrong here:</p>\n<pre><code>auto callSelf = [](auto&amp; func) {func(func);};\ncallSelf(callSelf);\n</code></pre>\n<p>We need to know the type of <code>callSelf</code> to determine the type of the expression of <code>func(func)</code>, which it iself circular. This is easily resolvable by simply specifying the return type:</p>\n<pre><code>auto callSelf = [](auto&amp; func) -&gt; void {func(func);};\ncallSelf(callSelf); // ok. I mean, infinite recursion, but otherwise ok. ish.\n</code></pre>\n<p>However, when you <em>wrap</em> the lambda, you get different behavior. This line here:</p>\n<pre><code>w(w);\n</code></pre>\n<p>is passing an object of type <code>wrapper</code> into, effectively, the lambda. That is not its own type. The body of the lambda invokes that object on itself, but we know the type of that expression. You declared it:</p>\n<pre><code>template&lt;class T&gt;\nvoid operator()(T&amp; func) {\n~~~~~\n</code></pre>\n<p>This function works (for some definition of works) with <code>void</code> for the same reason the lambda worked when we added <code>-&gt; void</code>. It's no longer an undeduced placeholder. We already know the return type. To get the same behavior as with the lambda, change the declaration of <code>operator()</code> to be <code>auto</code>. </p>\n", "LastActivityDate": "2017-02-18T23:03:42.123"}, "42321573": {"CommentCount": "6", "AcceptedAnswerId": "42321690", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2017-02-18T22:49:18.873", "LastActivityDate": "2017-02-19T08:32:52.550", "LastEditDate": "2017-02-19T08:32:52.550", "ViewCount": "544", "FavoriteCount": "2", "Title": "Why can't a generic lambda call itself, but wrapping it in a class allows it?", "Id": "42321573", "Score": "13", "Body": "<p>Here is the full example:</p>\n<pre><code>auto callSelf = [](auto&amp; func) {func(func);};\n\nclass wrapper : public decltype(callSelf) {\n    using base = decltype(callSelf);\npublic:\n    wrapper() : base(callSelf) {}\n\n    template&lt;class T&gt;\n    void operator()(T&amp; func) {\n        base::operator()(func);\n    }\n};\n\nint main()\n{\n    //callSelf(callSelf); // Error\n    wrapper w;\n    w(w); // OK, nice endless recursion\n}\n</code></pre>\n<p>Why is it possible with the wrapper, while doing it directly causes the following error?</p>\n<pre><code>main.cpp:30: error: use of '&lt;lambda(auto:1&amp;)&gt; [with auto:1 = &lt;lambda(auto:1&amp;)&gt;]' before deduction of 'auto'\n auto callSelf = [&amp;](auto&amp; func) {func(func);};\n                                  ~~~~^~~~~~\n</code></pre>\n", "Tags": "<c++><templates><recursion><lambda><c++14>", "OwnerUserId": "5405086", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42321573_42321690_0": {"section_id": 5455, "quality": 1.0, "length": 10}}, "n3337": {"so_42321573_42321690_0": {"section_id": 3191, "quality": 0.6, "length": 6}}, "n4659": {"so_42321573_42321690_0": {"section_id": 6881, "quality": 1.0, "length": 10}}}, "42321691": {"ParentId": "42321573", "CommentCount": "3", "CreationDate": "2017-02-18T23:03:53.453", "OwnerUserId": "2104697", "PostTypeId": "2", "Id": "42321691", "Score": "8", "Body": "<p>In your case, simply define the return type and the compiler should accept it:</p>\n<pre><code>auto callSelf = [](auto&amp; func) -&gt; void {func(func);};\n\nclass wrapper : public decltype(callSelf) {\n    using base = decltype(callSelf);\npublic:\n    wrapper() : base(callSelf) {}\n\n    template&lt;class T&gt;\n    void operator()(T&amp; func) {\n        base::operator()(func);\n    }\n};\n\nint main()\n{\n    callSelf(callSelf); //works\n    wrapper w;\n    w(w); //ok, nice endless recursion\n}\n</code></pre>\n<p>With return type deduction, the compiler cannot use the lambda in the lambda itself because the compiler has to see the body of the function to deduce the return type. The fact that the compiler has to check the body of the function make it see the content of your lambda that uses the lambda itself. Since the compiler is in the deduction process, you cannot use the lambda, hence the compilation error.</p>\n", "LastActivityDate": "2017-02-18T23:03:53.453"}});