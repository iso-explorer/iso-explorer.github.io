post_cb({"12689212": {"ParentId": "12688942", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-10-02T11:12:00.337", "Score": "1", "LastEditorUserId": "323547", "LastEditDate": "2012-10-02T11:17:42.257", "Id": "12689212", "OwnerUserId": "323547", "Body": "<blockquote>\n<p id=\"so_12688942_12689212_0\">Why would I want to use a copy constructor instead of a conversion constructor?</p>\n</blockquote>\n<p>It can be problematic if you give <code>MyClass</code> objects to some code that expect your copy-constructor to be valid.</p>\n<p>This is the case for STL containers. For instance, if you use a <code>std::vector&lt;MyClass&gt;</code>, you must be aware that vectors are allowed to move elements around for reallocation using their copy constructors.</p>\n<p>The default constructor provided by the compiler will perform a shallow copy, calling copy constructors of every attributes, making simple copies for base type like pointers. If you want some form of deep copy you will have to properly rewrite the copy constructor of <code>MyClass</code></p>\n", "LastActivityDate": "2012-10-02T11:17:42.257"}, "12688942": {"CommentCount": "0", "AcceptedAnswerId": "12688958", "CreationDate": "2012-10-02T10:52:58.757", "LastActivityDate": "2012-10-02T11:42:02.330", "PostTypeId": "1", "ViewCount": "4126", "FavoriteCount": "1", "Title": "c++ copy constructor signature : does it matter", "Id": "12688942", "Score": "6", "Body": "<p>My current implementation uses lots of copy constructors with this syntax</p>\n<p><code>MyClass::Myclass(Myclass* my_class)</code></p>\n<p>Is it really (functionnaly) different from</p>\n<p><code>MyClass::MyClass(const MyClass&amp; my_class)</code></p>\n<p>and why?</p>\n<p>I was adviced that first solution was not a true copy constructor. However, making the change implies quite a lot of refactoring. </p>\n<p>Thanks!!!</p>\n", "Tags": "<c++><copy><const><copy-constructor>", "OwnerUserId": "1141493", "AnswerCount": "5"}, "12689345": {"ParentId": "12688942", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-10-02T11:21:10.467", "Score": "5", "LastEditorUserId": "13005", "LastEditDate": "2012-10-02T11:42:02.330", "Id": "12689345", "OwnerUserId": "13005", "Body": "<p>Certain language constructs call for a copy constructor:</p>\n<ul>\n<li>passing by value</li>\n<li>returning by value</li>\n<li>copy-style initialization (although the copy is often elided in that case)</li>\n</ul>\n<p>If the language calls for a copy, and you have provided a copy constructor, then it can be used (assuming the cv-qualifications are OK, of course).</p>\n<p>Since you have not provided a copy constructor, you will get the compiler-generated copy constructor instead. This works by copying each data member, even if that's not the right thing to do for your class. For example if your not-a-copy-constructor explicitly does any deep copies or allocates resources, then you need to suppress the compiler-generated copy.</p>\n<p>If the compiler-generated copy works for your class, then your not-a-copy-constructor is mostly harmless. I don't think it's a particularly good idea, though:</p>\n<pre><code>void some_function(const MyClass &amp;foo);\n\nMyClass *ptr = new MyClass();\nconst MyClass *ptr2 = ptr;\nsome_function(ptr); // compiles, but copies *ptr and uses the copy\nMyClass bar(ptr2);  // doesn't compile -- requires pointer-to-non-const\n</code></pre>\n<p>Even assuming that the compiler-generated copy is no good for your class, making the necessary change need not require a lot of refactoring. Suppose that your not-a-constructor doesn't actually modify the object pointed to by its argument, so after fixing the signature you have:</p>\n<pre><code>MyClass::MyClass(const MyClass* my_class) {\n    // maybe treat null pointer specially\n    // do stuff here\n}\n</code></pre>\n<p>You need:</p>\n<pre><code>MyClass::MyClass(const MyClass&amp; my_class) {\n    do_stuff(my_class);\n}\n\nMyClass::MyClass(const MyClass* my_class) {\n    // maybe treat null pointer specially\n    do_stuff(*my_class);\n}\n\nMyClass::do_stuff(const MyClass&amp; my_class) {\n    // do stuff here\n}\n</code></pre>\n<p>You also need to copy any initializer list from the old constructor to the new one, and modify it for the fact that <code>my_class</code> isn't a pointer in the new one.</p>\n<p>Removing the old constructor might require a lot of refactoring, since you have to edit any code that uses it. You don't have to remove the old constructor in order to fix any problems with the default copy constructor, though.</p>\n", "LastActivityDate": "2012-10-02T11:42:02.330"}, "12688958": {"ParentId": "12688942", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2012-10-02T10:54:10.380", "Score": "16", "LastEditorUserId": "673730", "LastEditDate": "2012-10-02T11:01:07.030", "Id": "12688958", "OwnerUserId": "673730", "Body": "<p>It's different in the sense that the first isn't a copy constructor, but a conversion constructor. It converts from a <code>MyClass*</code> to a <code>MyClass</code>.</p>\n<p>By definition, a copy-constructor has one of the following signatures:</p>\n<pre><code>MyClass(MyClass&amp; my_class)\nMyClass(const MyClass&amp; my_class)\n//....\n//combination of cv-qualifiers and other arguments that have default values\n</code></pre>\n<h3>12.8. Copying class objects</h3>\n<blockquote>\n<p id=\"so_12688942_12688958_0\">2) A non-template constructor for class X is a copy constructor if its\n  first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile\n  X&amp;, and either there are no other parameters or else all other\n  parameters have default arguments (8.3.6).113) [ Example: X::X(const\n  X&amp;) and X::X(X&amp;,int=1) are copy constructors.</p>\n</blockquote>\n<p>EDIT: you seem to be confusing the two.</p>\n<p>Say you have:</p>\n<pre><code>struct A\n{\n   A();\n   A(A* other);\n   A(const A&amp; other);\n};\n\nA a;     //uses default constructor\nA b(a);  //uses copy constructor\nA c(&amp;a); //uses conversion constructor\n</code></pre>\n<p>They serve different purposes alltogether.</p>\n", "LastActivityDate": "2012-10-02T11:01:07.030"}, "12688974": {"ParentId": "12688942", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-10-02T10:55:06.880", "Score": "7", "LastEditorUserId": "596781", "LastEditDate": "2012-10-02T11:16:45.833", "Id": "12688974", "OwnerUserId": "596781", "Body": "<p>The first version is <em>not</em> a copy constructor. Simple as that. It's just another constructor.</p>\n<p>A <em>copy</em> constructor for a class <code>X</code> must have signature <code>(X &amp;, ...)</code> or <code>(X const &amp;, ...)</code> or <code>(X volatile &amp;, ...)</code> or <code>(X const volatile &amp;, ...)</code>, where all arguments but the first have default values if they are present (and it must not be a template).</p>\n<hr>\n<p>That said, you should think very carefully about why you're violating the Rule of Zero: Most well-designed classes shouldn't have <em>any</em> user-defined copy-constructor, copy-assignment operator or destructor at all, and instead rely on well-designed members. The fact that your current constructor takes a pointer makes me wonder if your code behaves correctly for something like <code>MyClass x = y;</code> \u2014 worth checking.</p>\n</hr>", "LastActivityDate": "2012-10-02T11:16:45.833"}, "bq_ids": {"n4140": {"so_12688942_12688958_0": {"section_id": 451, "quality": 0.9, "length": 27}}, "n3337": {"so_12688942_12688958_0": {"section_id": 442, "quality": 0.9, "length": 27}}, "n4659": {"so_12688942_12688958_0": {"section_id": 474, "quality": 0.9, "length": 27}}}, "12689015": {"ParentId": "12688942", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-10-02T10:57:39.707", "Score": "1", "LastEditorUserId": "661519", "LastEditDate": "2012-10-02T11:07:59.327", "Id": "12689015", "OwnerUserId": "661519", "Body": "<p>The first example is not a copy constructor. This means that when you provide it, the compiler still provides you with a default copy constructor with signature equivalent to</p>\n<pre><code>MyClass(const MyClass&amp; my_class);\n</code></pre>\n<p>If you are doing something special with your constructor, and the compiler provided copy constructor does not follow that logic, you should either implement a copy constructor or find a way to disable it.</p>\n", "LastActivityDate": "2012-10-02T11:07:59.327"}});