post_cb({"30394180": {"Id": "30394180", "PostTypeId": "2", "Body": "<p>For reference, the sentence that totally misled me is in <code>[over.match.funcs]</code>, \u00a713.3.1/4 of N3337:</p>\n<blockquote>\n<ol start=\"4\">\n<li>For non-static member functions, the type of the implicit object parameter is</li>\n</ol>\n<p id=\"so_30393443_30394180_0\">\u2014 <strong>\u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</strong></p>\n<p id=\"so_30393443_30394180_1\">\u2014 \u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</p>\n</blockquote>\n<p>(emphasis mine).</p>\n<p>So I was getting kind of crazy about why there was a difference in the output. Without or with a <code>&amp;</code> ref qualifier should be the same according to here, right? </p>\n<p>Well, the reason is an additional rule sneaked in afterwards in \u00a713.3.1/5</p>\n<blockquote>\n<p id=\"so_30393443_30394180_2\">For non-static member functions declared without a ref-qualifier, an additional rule applies:</p>\n<p id=\"so_30393443_30394180_3\">\u2014 even if the implicit object parameter is not const-qualified, an rvalue can be bound to the parameter as long as in all other respects the argument can be converted to the type of the implicit object parameter.</p>\n</blockquote>\n<p>Which basically triggers the non-const rvalue to non-const lvalue conversion and makes <strong>all the difference</strong> in the example above. D'uh.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-05-22T16:59:45.690", "Score": "6", "CreationDate": "2015-05-22T10:20:57.720", "ParentId": "30393443", "CommentCount": "1", "LastEditDate": "2015-05-22T16:59:45.690", "OwnerUserId": "1873944"}, "bq_ids": {"n4140": {"so_30393443_30394180_1": {"length": 5, "quality": 1.0, "section_id": 568}, "so_30393443_30394180_0": {"length": 6, "quality": 1.0, "section_id": 568}, "so_30393443_30394180_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 569}, "so_30393443_30394180_3": {"length": 20, "quality": 1.0, "section_id": 569}}, "n3337": {"so_30393443_30394180_1": {"length": 5, "quality": 1.0, "section_id": 559}, "so_30393443_30394180_0": {"length": 6, "quality": 1.0, "section_id": 559}, "so_30393443_30394180_3": {"length": 20, "quality": 1.0, "section_id": 560}, "so_30393443_30394180_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 560}}, "n4659": {"so_30393443_30394180_1": {"length": 5, "quality": 1.0, "section_id": 591}, "so_30393443_30394180_0": {"length": 6, "quality": 1.0, "section_id": 591}, "so_30393443_30394180_3": {"length": 20, "quality": 1.0, "section_id": 592}, "so_30393443_30394180_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 592}}}, "30393443": {"ViewCount": "504", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {\n    void f() { cout &lt;&lt; \"A::f\" &lt;&lt; endl; }\n    void f() const { cout &lt;&lt; \"A::f const\" &lt;&lt; endl; }\n};\n\nstruct B {\n    void f() &amp; { cout &lt;&lt; \"B::f &amp;\" &lt;&lt; endl; }\n    void f() const &amp; { cout &lt;&lt; \"B::f const &amp;\" &lt;&lt; endl; }\n};\n\nA getA() { return A{}; }\nB getB() { return B{}; }\n\nint main() {\n    getA().f();\n    getB().f();\n}\n</code></pre>\n<p>which prints</p>\n<pre><code>A::f\nB::f const &amp;\n</code></pre>\n<p>For <code>B</code>, the const overload gets selected, not the non-const one. I guess this means that specifying a lvalue ref qualifier for *this is different from not specifying anything at all. Why is that? Does the \"implicit this argument\" change type and the const overload now becomes a better candidate in overload resolution?</p>\n", "AcceptedAnswerId": "30393632", "Title": "Why specifying a lvalue reference for *this on a member function is different from not specifying anything?", "CreationDate": "2015-05-22T09:44:40.827", "Id": "30393443", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-05-22T16:59:45.690", "Score": "19", "OwnerUserId": "1873944", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "30393632": {"Id": "30393632", "PostTypeId": "2", "Body": "<p>In this case:</p>\n<pre><code>struct A {\n    void f() { cout &lt;&lt; \"A::f\" &lt;&lt; endl; }\n    void f() const { cout &lt;&lt; \"A::f const\" &lt;&lt; endl; }\n};\n\ngetA().f();\n</code></pre>\n<p>Both overloads are viable for <code>f</code>, but the non-const one is preferred because it requires no conversion.</p>\n<p>But in this case: </p>\n<pre><code>struct B {\n    void f() &amp; { cout &lt;&lt; \"B::f &amp;\" &lt;&lt; endl; }\n    void f() const &amp; { cout &lt;&lt; \"B::f const &amp;\" &lt;&lt; endl; }\n};\n\ngetB().f();\n</code></pre>\n<p>The first overload requires <code>this</code> to be an lvalue. But in <code>getB().f()</code>, the result of <code>getB()</code> is a prvalue, which can't bind to a non-const lvalue. So this overload is not viable and not selected.</p>\n<p>The second overload however requires <code>this</code> to be a const lvalue, which a prvalue can bind to: this overload is viable and selected by the compiler.</p>\n", "LastEditorUserId": "703016", "LastActivityDate": "2015-05-22T10:17:28.990", "Score": "19", "CreationDate": "2015-05-22T09:53:39.227", "ParentId": "30393443", "CommentCount": "7", "LastEditDate": "2015-05-22T10:17:28.990", "OwnerUserId": "703016"}});