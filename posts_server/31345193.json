post_cb({"bq_ids": {"n4140": {"so_31345193_31347287_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 4375}, "so_31345193_31345795_1": {"length": 52, "quality": 0.5591397849462365, "section_id": 175}, "so_31345193_31345795_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 76}, "so_31345193_31347287_0": {"length": 5, "quality": 1.0, "section_id": 6324}, "so_31345193_31347287_3": {"length": 11, "quality": 1.0, "section_id": 6324}}, "n3337": {"so_31345193_31347287_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 4212}, "so_31345193_31345795_1": {"length": 53, "quality": 0.5698924731182796, "section_id": 169}, "so_31345193_31347287_0": {"length": 5, "quality": 1.0, "section_id": 6081}, "so_31345193_31347287_3": {"length": 11, "quality": 1.0, "section_id": 6081}, "so_31345193_31345795_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 71}}, "n4659": {"so_31345193_31347287_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 5638}, "so_31345193_31345795_1": {"length": 71, "quality": 0.7634408602150538, "section_id": 180}, "so_31345193_31347287_0": {"length": 5, "quality": 1.0, "section_id": 7834}, "so_31345193_31347287_3": {"length": 11, "quality": 1.0, "section_id": 7834}, "so_31345193_31345795_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 78}}}, "31345795": {"Id": "31345795", "PostTypeId": "2", "Body": "<p>This is what I've gathered from the standard</p>\n<p><strong>\u00a714.3.1 Template type arguments</strong></p>\n<blockquote>\n<p id=\"so_31345193_31345795_0\">1 A template-argument for a template-parameter which is a type shall be a type-id<br>\n  2 ... [Note: <strong>A template type argument may be an incomplete type</strong>]</br></p>\n</blockquote>\n<p><strong>\u00a714.6 Name resolution</strong></p>\n<blockquote>\n<p id=\"so_31345193_31345795_1\">Knowing which names are type names allows the syntax of every template to be checked. No diagnostic shall be issued for a template for which a valid specialization can be generated. If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic required. If every valid specialization of a variadic template requires an empty template parameter pack, the template is ill-formed, no diagnostic required. If a hypothetical instantiation of a template immediately\n  following its definition would be ill-formed due to a construct that does not depend on a template parameter, the program is ill-formed; no diagnostic is required. If the interpretation of such a construct in the hypothetical instantiation is different from the interpretation of the corresponding construct in any actual instantiation of the template, the program is ill-formed; no diagnostic is required. [ Note: This can happen in situations including the following:<br>\n  -- <strong>a type used in a non-dependent name is incomplete at the point at which a template is defined but is complete at the point at which an instantiation is performed, or</strong><br>\n  -- ...</br></br></p>\n</blockquote>\n<p>So in your example, <code>Bar</code> was incomplete upon declaring <code>Foo</code>, but it was complete by the time you <em>instantiated</em> a <code>Foo</code></p>\n", "LastActivityDate": "2015-07-10T16:24:56.510", "CommentCount": "5", "CreationDate": "2015-07-10T16:24:56.510", "ParentId": "31345193", "Score": "7", "OwnerUserId": "2296458"}, "31347287": {"Id": "31347287", "PostTypeId": "2", "Body": "<p>I think in practice this may work but from what I can tell this looks like undefined behavior. From the draft C++11 standard <code>17.6.4.8</code> <em>[res.on.functions]</em>:</p>\n<blockquote>\n<p id=\"so_31345193_31347287_0\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_31345193_31347287_1\">[...]</p>\n<ul>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component,\n  unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p>Although <em>instantiating a template component</em> does not seem like a well-defined term.</p>\n<p>I came to this via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611\">LWG defect 611</a> which added:</p>\n<blockquote>\n<p id=\"so_31345193_31347287_2\">unless specifically allowed for the component. </p>\n</blockquote>\n<p>to the end of the bullet above so it now reads:</p>\n<blockquote>\n<p id=\"so_31345193_31347287_3\">if an incomplete type (3.9) is used as a template argument when instantiating a template component, <strong>unless specifically allowed for the component.</strong></p>\n</blockquote>\n<p>as an exception for <code>shared_ptr</code> since the above quote conflicted with this quote from <code>20.6.6.2</code> [util.smartptr.shared]:</p>\n<blockquote>\n<p id=\"so_31345193_31347287_4\">The template parameter T of shared_ptr may be an incomplete type. </p>\n</blockquote>\n<p>Also see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html\">N4371: Minimal incomplete type support for standard containers, revision 2</a>. </p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-12T18:17:05.010", "Score": "10", "CreationDate": "2015-07-10T17:55:36.360", "ParentId": "31345193", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2015-07-12T18:17:05.010"}, "31345193": {"ViewCount": "1701", "Body": "<p>TIL the following program is legal and whatnot:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct Bar;\n\nstruct Foo\n{\n    using BarVec = std::vector&lt;Bar&gt;::size_type;\n};\n\nstruct Bar {};\n\nint main()\n{\n   Foo f;\n}\n</code></pre>\n<p>How? <code>Bar</code> is an incomplete type so the compiler has no way of knowing what <code>std::vector&lt;Bar&gt;</code> is, or that it contains a member <code>size_type</code>, or that the member <code>size_type</code> is a type.</p>\n<p>The only explanation I can come up with is that any hypothetical specialisation would (presumably) have to already be in scope to cause <code>size_type</code> to take on a meaning different from that given in the \"base\" template definition, and <code>size_type</code> is not a dependent name (both factors contributing to the compiler's certainty).</p>\n<p>What's the legal rationale here?</p>\n", "AcceptedAnswerId": "31347287", "Title": "How can an incomplete type be used as a template parameter to vector here?", "CreationDate": "2015-07-10T15:54:22.283", "Id": "31345193", "CommentCount": "10", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-07-12T18:17:05.010", "Score": "16", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}});