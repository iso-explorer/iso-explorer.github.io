post_cb({"7884102": {"CommentCount": "4", "ViewCount": "1631", "PostTypeId": "1", "LastEditorUserId": "812034", "CreationDate": "2011-10-25T02:36:59.560", "LastActivityDate": "2011-10-26T02:14:03.953", "Title": "Multiple copy constructors specified", "AcceptedAnswerId": "7885665", "LastEditDate": "2011-10-26T02:14:03.953", "Id": "7884102", "Score": "4", "Body": "<p>With Visual C++ 2010, I have a class like this:</p>\n<pre><code>class MyClass{\npublic:\n    MyClass(){}\n    MyClass(MyClass &amp;){/*...*/}   //A\n    MyClass(const MyClass &amp;){/*...*/}   //B\n    template&lt;typename T&gt; MyClass(T &amp;&amp;t){ static_assert(\n        !std::is_same&lt;typename \n        std::remove_cv&lt;typename  std::remove_reference&lt;T&gt;::type&gt;::type, \n        MyClass&gt;::value,\n        \"Wrapping over wrapping is not allowed!\"); } //C\n};\n\nint main(int, char**){\n    MyClass a;\n    const MyClass b(a); //assert fail if line A removed\n    auto c=b; //assert fail if line B removed\n}\n//If both A and B exists\n//Warning C4521: multiple copy constructors specified\n//Furthermore, if both A and B removed\n//No error or warnings; VC2010 accepts peacefully.\n//In debug mode you will find the compiler generated trivial copy constructor\n</code></pre>\n<p>According to C++ standard, both line A and B are considered copy constructors, and C is a convert constructor. It is not surprising that I receive a warning that I declared multiple copy constructors. However, if I remove any of them, the static_assert fails and the code would not compile, that means the template constructor received control.</p>\n<p>I am sure that this behaviour follows the rule of function overloading. However is this a conflict of two rules? If A and B are copy constructors and one of them was declared, any attempt to copy the objects should not drop to the template, is it right?</p>\n<p>Update:\nAccording to N3242, 12.8.7,</p>\n<blockquote>\n<p id=\"so_7884102_7884102_0\">\"a member function template is NEVER INSTANTIATED to perform the copy of a class object to an object of its class type.\"</p>\n</blockquote>\n<p>the correct implementation should be:</p>\n<ul>\n<li>No assert failure should occur when either A or B or both removed.</li>\n<li>If line B is removed, construction of c should fail because b is const.</li>\n<li>If both lines are removed, compiler should generate a copy constructor for the class.</li>\n<li>It is up to the implementation to warn the user if both lines exists.</li>\n</ul>\n<p>Any comment?</p>\n", "Tags": "<templates><visual-c++><constructor><c++11><gcc4>", "OwnerUserId": "812034", "AnswerCount": "2"}, "7885665": {"ParentId": "7884102", "CommentCount": "6", "CreationDate": "2011-10-25T06:55:40.513", "OwnerUserId": "1000804", "PostTypeId": "2", "Id": "7885665", "Score": "1", "Body": "<p>First of all, <code>template&lt;T&gt;</code> should be <code>template &lt;typename T&gt;</code>.</p>\n<p>I am using gcc 4.4.3 on 64-bit Ubuntu Linux, the codes behave differently from what you have demonstrated in the post. </p>\n<ul>\n<li>If nothing changed, the codes could be compiled without any warning. The constructor A and B are evoked one after another.</li>\n<li>If I comment line A, it fails to be compiled just as what you said: failing in line <code>const MyClass b(a);</code>. The reason is that the object a is not constant, so constructor B can not be matched and the compiler has to instantiate the template constructor. Of course, <code>const MyClass</code> and <code>MyClass</code> are different types.</li>\n<li>However, if I comment line B only, the codes could be compiled successfully and the template copy constructor was evoked. Object b is a constant object, so construct A can not be matched and the compiler instantiate the template constructor. However, the question remains: should the static_assert fails or not? The difference may be because of the platform/compiler difference. GCC seems implementing the <code>is_same&lt;MyClass&amp;&amp;, MyClass&gt;::value</code> to be true. You may use typeid to print out both of the types.</li>\n</ul>\n", "LastActivityDate": "2011-10-25T06:55:40.513"}, "7888261": {"ParentId": "7884102", "CommentCount": "1", "CreationDate": "2011-10-25T11:00:38.860", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "7888261", "Score": "0", "Body": "<blockquote>\n<p id=\"so_7884102_7888261_0\">If A and B are copy constructors and one of them was declared, any attempt to copy the objects should not drop to the template, is it right?</p>\n</blockquote>\n<p>A constructor that is not a copy constructor can still be used to copy objects. In your case the constructor instantiated from the constructor template is used for copying the object. Which is fine.</p>\n", "LastActivityDate": "2011-10-25T11:00:38.860"}, "bq_ids": {"n4140": {"so_7884102_7884102_0": {"section_id": 466, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_7884102_7884102_0": {"section_id": 457, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_7884102_7884102_0": {"section_id": 489, "quality": 0.5384615384615384, "length": 7}}}});