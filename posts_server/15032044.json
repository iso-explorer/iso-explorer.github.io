post_cb({"15032114": {"ParentId": "15032044", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The C++ standard defines overload resolution rules in chapter 13.3, there you find:</p>\n<blockquote>\n<p id=\"so_15032044_15032114_0\"><strong>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</strong></p>\n<p id=\"so_15032044_15032114_1\"><sup>2</sup> When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)</p>\n<p id=\"so_15032044_15032114_2\">\u2014 a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</p>\n<p id=\"so_15032044_15032114_3\">\u2014 a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</p>\n</blockquote>\n<p>This means that the compiler will prefer a standard conversion sequence from the string literal to <code>bool</code> or <code>int</code> if available. Now, which standard conversions are relevant? In your case, these two are relevant:</p>\n<blockquote>\n<p id=\"so_15032044_15032114_4\"><strong>4.2 Array-to-pointer conversion [conv.array]</strong></p>\n<p id=\"so_15032044_15032114_5\"><sup>1</sup> An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>This conversion turns the string literal, which is of type <code>const char[N]</code>, into a <code>const char*</code>. The second one is:</p>\n<blockquote>\n<p id=\"so_15032044_15032114_6\"><strong>4.12 Boolean conversions [conv.bool]</strong></p>\n<p id=\"so_15032044_15032114_7\"><sup>1</sup> A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>; any other value is converted to <code>true</code>. A prvalue of type <code>std::nullptr_t</code> can be converted to a prvalue of type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p>That is the reason why the pointer is converted to <code>bool</code>. Since a standard conversion sequence exists, the user-defined conversion to <code>std::string</code> is not used.</p>\n<p>To solve your problem, I suggest you add another overloaded version that takes <code>const char*</code> and make it forward the call to the <code>const std::string&amp;</code> overload.</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-02-22T20:33:38.403", "Id": "15032114", "Score": "9", "CreationDate": "2013-02-22T19:48:55.307", "LastActivityDate": "2013-02-22T20:33:38.403"}, "15032571": {"ParentId": "15032044", "CommentCount": "7", "Body": "<p>Daniel is right.</p>\n<p>The short answer is that <code>std::string</code> is not a built-in type and, as such, doesn't get any magical preferential treatment. And that, unfortunately, the type of a string literal such as <code>\"hi world\"</code> is <em>not</em> <code>std::string</code>, but a pointer type which more easily converts to the built-in type <code>bool</code> than to the \"user-defined\"<sup>\u2020</sup> type <code>std::string</code>.</p>\n<p>Basically, the answer is: welcome to C++.</p>\n<p><sup><sup>\u2020</sup> Yes, I know, it's from the <em>standard</em> library and, no, it doesn't matter.</sup></p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "15032571", "Score": "3", "CreationDate": "2013-02-22T20:22:07.063", "LastActivityDate": "2013-02-22T20:22:07.063"}, "15032044": {"CommentCount": "5", "AcceptedAnswerId": "15032114", "PostTypeId": "1", "LastEditorUserId": "845092", "CreationDate": "2013-02-22T19:44:56.640", "LastActivityDate": "2013-02-22T20:33:38.403", "LastEditDate": "2013-02-22T20:07:03.687", "ViewCount": "1028", "FavoriteCount": "1", "Title": "Boolean and String Overloads of the Assignment Operator (C++)", "Id": "15032044", "Score": "5", "Body": "<p>I am defining multiple overloads of the <strong>assignment operator</strong> as follows:</p>\n<p>Foo.h</p>\n<pre><code>class Foo\n{\nprivate:\n    bool my_bool;\n    int my_int;\n    std::string my_string;\npublic:\n    Foo&amp; operator= (bool value);\n    Foo&amp; operator= (int value);\n    Foo&amp; operator= (const std::string&amp; value);\n};\n</code></pre>\n<p>Foo.cpp</p>\n<pre><code>// Assignment Operators.\nFoo&amp; Foo::operator= (bool value) {my_bool = value; return *this;}\nFoo&amp; Foo::operator= (int value) {my_int = value; return *this;}\nFoo&amp; Foo::operator= (const std::string&amp; value) {my_string = value; return *this;}\n</code></pre>\n<p>And here's my main.cpp (see the comment marked <code>SURPRISE</code>):</p>\n<pre><code>Foo boolFoo;\nFoo intFoo;\nFoo stringFoo;\n\n// Reassign values via appropriate assignment operator.\nboolFoo = true;                // works...assigned as bool\nintFoo = 42;                   // works...assigned as int\nstringFoo = \"i_am_a_string\";   // SURPRISE...assigned as bool, not string\n\nstd::string s = \"i_am_a_string\";\nstringFoo = s;                 // works...assigned as string\n\n// works...but awkward\nstringFoo = static_cast&lt;std::string&gt;(\"i_am_a_string\");\n</code></pre>\n<p><strong>Question:</strong> Can someone tell me why an uncasted string literal is being evaluated in a boolean context?</p>\n", "Tags": "<c++><string><boolean><operator-overloading><assignment-operator>", "OwnerUserId": "1497596", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15032044_15032114_7": {"section_id": 44, "quality": 1.0, "length": 39}, "so_15032044_15032114_1": {"section_id": 638, "quality": 0.8888888888888888, "length": 8}, "so_15032044_15032114_5": {"section_id": 11, "quality": 0.9444444444444444, "length": 17}, "so_15032044_15032114_3": {"section_id": 638, "quality": 0.8333333333333334, "length": 10}, "so_15032044_15032114_2": {"section_id": 638, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_15032044_15032114_7": {"section_id": 41, "quality": 1.0, "length": 39}, "so_15032044_15032114_5": {"section_id": 8, "quality": 0.9444444444444444, "length": 17}, "so_15032044_15032114_1": {"section_id": 628, "quality": 0.8888888888888888, "length": 8}, "so_15032044_15032114_3": {"section_id": 628, "quality": 0.8333333333333334, "length": 10}, "so_15032044_15032114_2": {"section_id": 628, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_15032044_15032114_5": {"section_id": 12, "quality": 0.9444444444444444, "length": 17}, "so_15032044_15032114_7": {"section_id": 45, "quality": 1.0, "length": 39}, "so_15032044_15032114_1": {"section_id": 666, "quality": 0.8888888888888888, "length": 8}, "so_15032044_15032114_2": {"section_id": 666, "quality": 0.9230769230769231, "length": 12}, "so_15032044_15032114_3": {"section_id": 666, "quality": 0.8333333333333334, "length": 10}}}});