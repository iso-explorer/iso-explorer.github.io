post_cb({"bq_ids": {"n4140": {"so_44338559_44338825_0": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}, "so_44338559_44338825_8": {"section_id": 45, "quality": 0.8, "length": 4}, "so_44338559_44338825_2": {"section_id": 7239, "quality": 1.0, "length": 5}, "so_44338559_44338825_4": {"section_id": 7239, "quality": 1.0, "length": 8}, "so_44338559_44338825_6": {"section_id": 7239, "quality": 1.0, "length": 22}, "so_44338559_44338825_3": {"section_id": 416, "quality": 1.0, "length": 5}, "so_44338559_44338825_5": {"section_id": 7239, "quality": 1.0, "length": 10}, "so_44338559_44338825_1": {"section_id": 7239, "quality": 0.9, "length": 9}, "so_44338559_44338825_7": {"section_id": 7239, "quality": 1.0, "length": 9}}, "n3337": {"so_44338559_44338825_0": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_44338559_44338825_8": {"section_id": 42, "quality": 0.8, "length": 4}, "so_44338559_44338825_2": {"section_id": 6983, "quality": 1.0, "length": 5}, "so_44338559_44338825_4": {"section_id": 6983, "quality": 1.0, "length": 8}, "so_44338559_44338825_6": {"section_id": 6983, "quality": 1.0, "length": 22}, "so_44338559_44338825_3": {"section_id": 407, "quality": 1.0, "length": 5}, "so_44338559_44338825_5": {"section_id": 6983, "quality": 1.0, "length": 10}, "so_44338559_44338825_1": {"section_id": 6983, "quality": 0.9, "length": 9}, "so_44338559_44338825_7": {"section_id": 6983, "quality": 1.0, "length": 9}}, "n4659": {"so_44338559_44338825_0": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}, "so_44338559_44338825_8": {"section_id": 7588, "quality": 1.0, "length": 5}, "so_44338559_44338825_2": {"section_id": 8748, "quality": 1.0, "length": 5}, "so_44338559_44338825_4": {"section_id": 8748, "quality": 1.0, "length": 8}, "so_44338559_44338825_3": {"section_id": 434, "quality": 1.0, "length": 5}, "so_44338559_44338825_6": {"section_id": 8748, "quality": 1.0, "length": 22}, "so_44338559_44338825_5": {"section_id": 8748, "quality": 1.0, "length": 10}, "so_44338559_44338825_1": {"section_id": 8748, "quality": 0.9, "length": 9}, "so_44338559_44338825_7": {"section_id": 8748, "quality": 1.0, "length": 9}}}, "44338559": {"CommentCount": "0", "ViewCount": "68", "CreationDate": "2017-06-02T23:06:09.577", "LastActivityDate": "2017-06-03T00:23:43.853", "Title": "Does the following reinterpret_cast lead to undefined behavior?", "AcceptedAnswerId": "44338825", "PostTypeId": "1", "Id": "44338559", "Score": "1", "Body": "<p>Does the <code>reinterpret_cast</code> in the code below lead to undefined behavior? In case it does, is it possible to define <code>rpd</code> in a type-safe manner?</p>\n<pre><code>class Base\n{ \npublic:\n  virtual ~Base() = default;\n};\n\nclass Derived : public Base { };\n\nint main(void)\n{\n  Derived d;\n  Base* pb = &amp;d;\n  Base*&amp; rpb = pb;\n\n  Derived*&amp; rpd = reinterpret_cast&lt;Derived*&amp;&gt;(rpb);\n\n  return 0;\n}\n</code></pre>\n<p>Sort of related to my previous <a href=\"https://stackoverflow.com/questions/44338171/casting-pointer-to-pointer-in-a-type-safe-manner\">recent question</a>. Context behind this; I am experimenting with an adapter class that should allow vectors containing covariant pointer types to be used as covariant types themselves.</p>\n", "Tags": "<c++><pointers><reinterpret-cast>", "OwnerUserId": "79111", "AnswerCount": "1"}, "44338825": {"ParentId": "44338559", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-06-02T23:45:18.337", "Score": "3", "LastEditorUserId": "2079303", "LastEditDate": "2017-06-03T00:23:43.853", "Id": "44338825", "OwnerUserId": "2079303", "Body": "<p>The cast itself doesn't have UB (see [expr.reinterpret.cast]), but accessing the referred pointer (<code>rpb</code>) through the reinterpreted reference (<code>rpd</code>) does:</p>\n<p>[basic.lval] (standard draft)</p>\n<blockquote>\n<p id=\"so_44338559_44338825_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the <strong>behavior is undefined</strong>:<sup>56</sup></p>\n<p id=\"so_44338559_44338825_1\">56) The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>\n<ul>\n<li>(8.1)\n  the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>Does not apply, the dynamic type is the static type which is <code>Base*</code>, not <code>Derived*</code> that is the type of the glvalue.</p>\n<blockquote id=\"so_44338559_44338825_2\">\n<ul>\n<li>(8.2)\n  a cv-qualified version of the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>There are no cv-qualifications, and the types still don't match.</p>\n<blockquote id=\"so_44338559_44338825_3\">\n<ul>\n<li>(8.3)\n  a type similar to the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>Does not apply. This is about cv-qualifier de-compositions, see [conv.qual] (sorry, those many subscripts in the paragraphs are a pain to type in html and are necessary to keep the text readable).</p>\n<blockquote id=\"so_44338559_44338825_4\">\n<ul>\n<li>(8.4)\n  a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>Only relevant to integral types.</p>\n<blockquote id=\"so_44338559_44338825_5\">\n<ul>\n<li>(8.5)\n  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>Ditto.</p>\n<blockquote id=\"so_44338559_44338825_6\">\n<ul>\n<li>(8.6)\n  an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n</ul>\n</blockquote>\n<p><code>Derived*</code> is neither an aggregate nor a union.</p>\n<blockquote id=\"so_44338559_44338825_7\">\n<ul>\n<li>(8.7)\n  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p><code>Derived*</code> is not a base of <code>Base*</code>.</p>\n<blockquote id=\"so_44338559_44338825_8\">\n<ul>\n<li>(8.8)\n  a char, unsigned char, or std\u200b::\u200bbyte type.</li>\n</ul>\n</blockquote>\n<p><code>Derived*</code> is none of those.</p>\n<hr>\n<p>As none of the exceptions apply, the behaviour of accessing a <code>Base*</code> through a glvalue of <code>Derived*</code> type is undefined.</p>\n<hr>\n<blockquote>\n<p id=\"so_44338559_44338825_9\">I am experimenting with an adapter class that should allow vectors containing covariant pointer types to be used as covariant types themselves.</p>\n</blockquote>\n<p>Your experiment would fail to uphold basic object oriented principles.</p>\n<p>Base references are covariant with derived, because you cannot do anything with a derived object through a base reference that you couldn't do with the derived object itself.</p>\n<p>Containers of base type cannot be covariant with containers of derived, because you can do something with a container of (derived through a \"referencing\" container of) base that you couldn't do with a container of derived: Add objects of other derived types.</p>\n<p>Although, if the containers are immutable... it might work conceptually. Actually implementing it in C++ is another matter.</p>\n</hr></hr>", "LastActivityDate": "2017-06-03T00:23:43.853"}});