post_cb({"bq_ids": {"n4140": {"so_47696686_47696995_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6185}, "so_47696686_47697963_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6185}}, "n4659": {"so_47696686_47696995_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7687}, "so_47696686_47697963_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7687}}}, "47697963": {"PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow noreferrer\">[expr.const]</a>:</p>\n<blockquote>\n<p id=\"so_47696686_47697963_0\">An expression e is a <em>core constant expression</em> unless the evaluation of e, following the rules of the abstract machine, would evaluate one of the following expressions:</p>\n<ul>\n<li>[...]</li>\n<li><p id=\"so_47696686_47697963_1\">an lvalue-to-rvalue conversion unless it is applied to</p>\n<ul>\n<li>a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile const object with a preceding initialization, initialized with a constant expression, or</li>\n<li>a non-volatile glvalue that refers to a subobject of a string literal, or</li>\n<li>a non-volatile glvalue that refers to a non-volatile object defined with constexpr, or that refers to a non-mutable subobject of such an object, or</li>\n<li>a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of e;</li>\n</ul></li>\n<li><p id=\"so_47696686_47697963_2\">[...]</p></li>\n</ul>\n</blockquote>\n<p>In <code>f(x)</code>, we do an lvalue-to-rvalue conversion on <code>x</code>. <code>x</code> isn't of integral or enumeration type, it's not a subobject of a string-literal, it's not an object defined with constexpr, and its lifetime did not begin with the evaluation of <code>f(x)</code>.</p>\n<p>That seems to make this not a core constant expression.</p>\n<p><i>However</i>, as Casey points out, since <code>S</code> is empty, nothing in its implicitly-generated copy constructor would actually trigger this lvalue-to-rvalue conversion. That would mean that nothing in this expression actually violates any of the core constant expression restrictions, and hence gcc and clang are correct in accepting it. This interpretation seems correct to me. <code>constexpr</code> is fun. </p>\n", "LastActivityDate": "2017-12-07T17:58:03.443", "LastEditorUserId": "2069064", "Score": "4", "Id": "47697963", "CreationDate": "2017-12-07T15:04:36.740", "ParentId": "47696686", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2017-12-07T17:58:03.443"}, "47696686": {"ViewCount": "193", "LastEditDate": "2017-12-07T14:16:15.203", "AcceptedAnswerId": "47697963", "Title": "Generic lambda and its argument as constant expression", "CreationDate": "2017-12-07T13:56:08.537", "LastActivityDate": "2017-12-07T17:58:03.443", "CommentCount": "5", "FavoriteCount": "1", "OwnerUserId": "1625187", "PostTypeId": "1", "LastEditorUserId": "598696", "Id": "47696686", "Score": "7", "Body": "<p>The following code is accepted by GCC 7.2 and clang 5.0.0, but is rejected by Microsoft VS 2017 15.5.0 Preview 5 and Intel C++ compiler 19:</p>\n<pre><code>struct S { };\n\nconstexpr int f(S)\n{\n    return 0;\n}\n\nint main()\n{\n    auto lambda = [](auto x)\n    {\n        constexpr int e = f(x);\n    };\n\n    lambda(S{});\n}\n</code></pre>\n<p>Microsoft:</p>\n<pre><code>&lt;source&gt;(12): error C2131: expression did not evaluate to a constant\n</code></pre>\n<p>Intel:</p>\n<pre><code>&lt;source&gt;(12): error: expression must have a constant value\n    constexpr int e = f(x);\n                      ^\n&lt;source&gt;(12): note: the value of parameter \"x\" (declared at line 10) cannot be used as a constant\n    constexpr int e = f(x);\n                        ^\n</code></pre>\n<p>If I replace <code>f(x)</code> with <code>f(decltype(x){})</code>, both Microsoft and Intel do not complain. I understand that <code>x</code> is not a constant expression, but it is not used inside <code>f</code>. This is probably why GCC and clang do not complain.</p>\n<p>I guess that Microsoft and Intel compilers are correct in rejecting this code. What do you think?</p>\n", "Tags": "<c++><lambda><c++14><language-lawyer>", "AnswerCount": "2"}, "47696995": {"PostTypeId": "2", "Body": "<p>This is not a gcc/clang bug. The same behavior can be reproduced in C++11 with a template function:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T x)\n{\n    constexpr int e = f(x);\n}\n\nint main()\n{\n    foo(S{});\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/UBP7k5\" rel=\"nofollow noreferrer\"><strong>on godbolt.org</strong></a></p>\n<hr>\n<p>The question is, given...</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T x)\n{\n    constexpr int e = f(x);\n}\n</code></pre>\n<p>...is <code>f(x)</code> a constant expression?</p>\n<p>From <a href=\"http://eel.is/c++draft/expr.const#def:constant_expression\" rel=\"nofollow noreferrer\">[expr.const]</a>:</p>\n<blockquote>\n<p id=\"so_47696686_47696995_0\">An expression <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code>, following the rules of the abstract machine, would evaluate one of the following expressions:</p>\n<ul>\n<li>invocation of a function other than a <code>constexpr</code> constructor for a literal class, a <code>constexpr</code> function, or an implicit invocation of a trivial destructor </li>\n</ul>\n</blockquote>\n<p><code>S{}</code> and <code>0</code> are constant expressions because it doesn't violate any of the rules in [expr.const]. <code>f(x)</code> is a constant expression because it's an invocation to a <code>constexpr</code> function.</p>\n<p>Unless I am missing something, gcc and clang are correct here.</p>\n</hr>", "LastActivityDate": "2017-12-07T14:14:43.420", "Score": "2", "Id": "47696995", "CreationDate": "2017-12-07T14:14:43.420", "ParentId": "47696686", "CommentCount": "0", "OwnerUserId": "598696"}});