post_cb({"bq_ids": {"n4140": {"so_31473756_31473875_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6299}}, "n3337": {"so_31473756_31473875_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6056}}, "n4659": {"so_31473756_31473875_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 7808}}}, "31473756": {"ViewCount": "277", "Body": "<p>I have a type with a strict alignment requirement (due to AVX operations being used) that is larger than the platforms default alignment. </p>\n<p>To make usage of this class simpler, I would like to specialize <code>std::make_shared</code> to always use a suitable allocator for this type. </p>\n<p>Something like this:</p>\n<pre><code>namespace std{\n    template&lt;class... Args&gt; inline\n    auto make_shared&lt;X, Args...&gt;(Args&amp;&amp;... args){\n        return std::allocate_shared(allocator_type&lt;X, 32&gt;, std::forward&lt;Args&gt;(args)...);\n    }\n}\n</code></pre>\n<p>My question is, is this allowed by the standard? Will it work as expected?</p>\n", "AcceptedAnswerId": "31473875", "Title": "Specializing std::make_shared", "CreationDate": "2015-07-17T10:28:46.203", "Id": "31473756", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-07-17T12:05:48.193", "Score": "3", "OwnerUserId": "2498188", "Tags": "<c++><c++14><memory-alignment><standard-library>", "AnswerCount": "2"}, "31475475": {"Id": "31475475", "PostTypeId": "2", "Body": "<p>This is what I ended up doing to get a generic solution that doesn't involve a lot of boilerplate:</p>\n<pre><code>namespace xtd{\n    template&lt; typename T, std::size_t align = std::alignment_of&lt;T&gt;::value, typename... Args &gt;\n    std::shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args){\n        // Platform specific knowledge.\n#if defined(_WIN64) || defined(_WIN32)\n#if defined(_WIN64)\n        const std::size_t default_alignment = 16;\n#else\n        const std::size_t default_alignment = 8;\n#endif\n#else\n#error \"Only windows for now\"\n#endif\n\n        if (align &gt; default_alignment) {\n            typedef aligned_allocator&lt;T, align&gt; alloc_type;\n            return std::allocate_shared&lt;T, alloc_type&gt;(alloc_type(), std::forward&lt;Args&gt;(args)...);\n        }\n        else {\n            return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n        }\n    }\n}\n</code></pre>\n<p>Then I find Search &amp; Replace <code>std::make_shared</code> with <code>xtd::make_shared</code> :)</p>\n<p>I wish this would be in the standard...</p>\n", "LastActivityDate": "2015-07-17T12:05:48.193", "CommentCount": "0", "CreationDate": "2015-07-17T12:05:48.193", "ParentId": "31473756", "Score": "4", "OwnerUserId": "2498188"}, "31473875": {"Id": "31473875", "PostTypeId": "2", "Body": "<p>From N4140 [namespace.std]/1 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31473756_31473875_0\">The behavior of a C++program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified. <strong>A program may add a template specialization\n  for any standard library template to namespace std only if the declaration depends on a user-defined type</strong> and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>Since you are adding a template specialization which depends on a user-defined type, this is a valid extension of the <code>std</code> namespace.</p>\n<p>However, as pointed out by @dyp, you can't partially specialize function templates. Your best options would be to explicitly specify the arguments to the <code>X</code> constructor (losing out on perfect-forwarding), or just write a <code>make_shared_x</code> function (losing out on consistency).</p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2015-07-17T11:09:15.317", "Score": "8", "CreationDate": "2015-07-17T10:35:24.520", "ParentId": "31473756", "CommentCount": "5", "OwnerUserId": "496161", "LastEditDate": "2015-07-17T11:09:15.317"}});