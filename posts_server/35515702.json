post_cb({"35515914": {"ParentId": "35515702", "CommentCount": "0", "CreationDate": "2016-02-19T22:03:40.907", "OwnerUserId": "4092381", "PostTypeId": "2", "Id": "35515914", "Score": "0", "Body": "<p>Why do you feel you need to worry about the casting?</p>\n<p>Just <code>reinterpret_cast</code> the void pointer to a <code>char*</code> and iterate over each character up to the size of the original object. Keep in mind that the <code>char*</code> pointer is not a null-terminated string and may or may not contain null characters in the middle of the data, so do not process it like a C string.</p>\n", "LastActivityDate": "2016-02-19T22:03:40.907"}, "35515908": {"ParentId": "35515702", "CommentCount": "5", "CreationDate": "2016-02-19T22:03:30.533", "OwnerUserId": "4756309", "PostTypeId": "2", "Id": "35515908", "Score": "3", "Body": "<p>In the link I put in the comments, the accepted answer goes into great detail about type punning and why you can't do it in c++.</p>\n<p>What you can do is safely inspect any object with a <code>char*</code> (signed or unsigned) by using <code>reinterpret_cast</code>.</p>\n<pre><code>char* ptr = reinterpret_cast&lt;char*&gt;(&amp;object);\nfor (std::size_t x = 0; x &lt; sizeof(object); ++x)\n    std::cout &lt;&lt; ptr[x]; //Or something less slow but this is an example\n</code></pre>\n<p>If you want to actually move the object into a <code>char[]</code>, you should use <code>std::memcpy</code>.</p>\n", "LastActivityDate": "2016-02-19T22:03:30.533"}, "35515938": {"ParentId": "35515702", "CommentCount": "1", "CreationDate": "2016-02-19T22:05:33.407", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "35515938", "Score": "1", "Body": "<p>If you are not worried about a bit of extra memory, you can use <code>memcpy</code>.</p>\n<pre><code>int i = 10;\nchar carray[sizeof(i)];\nmemcpy(carray, &amp;i, sizeof(i));\n</code></pre>\n<p>However, remember that <code>carray</code> won't be a null terminated string. It will be just an array of <code>char</code>s. It will be better to use <code>unsigned char</code> since the value in one of those bytes might be too large for <code>char</code> if <code>char</code> is a signed type on your platform.</p>\n<pre><code>int i = 10;\nunsigned char carray[sizeof(i)];\nmemcpy(carray, &amp;i, sizeof(i));\n</code></pre>\n", "LastActivityDate": "2016-02-19T22:05:33.407"}, "35515702": {"CommentCount": "9", "ViewCount": "102", "PostTypeId": "1", "LastEditorUserId": "5931966", "CreationDate": "2016-02-19T21:49:27.730", "LastActivityDate": "2016-02-19T22:38:39.990", "Title": "Cast the object pointed by (void*) to char[]", "AcceptedAnswerId": "35515908", "LastEditDate": "2016-02-19T21:58:23.800", "Id": "35515702", "Score": "1", "Body": "<p>I'm trying to cast some objects (the size is known) pointed by void* to a char array bitwisely in c++. I'm considering using union with a char array so that I don't need to worry too much about the casting. However, since the type of the object is unknown, I don't know how to define this union.</p>\n<p>Just wondering if there is any other better way to deal with this?</p>\n<p>PS: edited to avoid confusion. For instance, an integer could be cast to a 4-character array.</p>\n<p>Thanks!</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "5931966", "AnswerCount": "4"}, "35515916": {"ParentId": "35515702", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-02-19T22:03:50.393", "Score": "0", "LastEditorUserId": "1312406", "LastEditDate": "2016-02-19T22:38:39.990", "Id": "35515916", "OwnerUserId": "1312406", "Body": "<p>From 5.2.10 Reinterpret cast:</p>\n<blockquote>\n<p id=\"so_35515702_35515916_0\">An object pointer can be explicitly converted to an object pointer of a different type.  When a prvalue\n  v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is static_cast(static_cast(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment\n  requirements of T2 are no stricter than those of T1, or if either type is void.</p>\n</blockquote>\n<p>So you simply want to use:</p>\n<pre><code>char* my_bytes = reinterpret_cast&lt;char*&gt;(my_pointer); \nsize_t num_bytes = sizeof(my_pointer);\nfor(size_t i = 0; i &lt; num_bytes; ++i) {\n   // *(my_bytes + i) has the most significant to least significant bytes\n}\n</code></pre>\n", "LastActivityDate": "2016-02-19T22:38:39.990"}, "bq_ids": {"n4140": {"so_35515702_35515916_0": {"section_id": 6046, "quality": 0.7931034482758621, "length": 23}}, "n3337": {"so_35515702_35515916_0": {"section_id": 5814, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_35515702_35515916_0": {"section_id": 7545, "quality": 0.7931034482758621, "length": 23}}}});